00:02:43 <pumpkin> so for what functions can we define equality? finite-domain and DFA/regex-equivalent ones work, anything else?
00:02:58 <pumpkin> or is equality decidable, that is
00:03:52 <harblcat> lpjhjdh: yi?
00:04:18 <dmwit> pumpkin: Not much else.  There are some clever hacks to decide equality of total functions of infinite streams of finite types.
00:04:53 <dmwit> pumpkin: I'm not sure what you mean by regex-equivalent functions (those are recognizers, not functions), either.
00:05:17 <lpjhjdh> harblcat: yi with vim keymap
00:05:32 <pumpkin> well I mean a function that runs a (pure) regex on an input and returns a boolean that says whether the regex accepted the input or not, I guess
00:05:38 <dmwit> harblcat: yi is a text editor written in Haskell
00:06:16 <dmwit> pumpkin: Right, okay.  So yeah, we can decide equality of those.
00:06:34 <dmwit> Provided we get to look at the regex and we don't have to just treat the function as a black box.
00:06:43 <pumpkin> yeah
00:07:14 <pumpkin> we were just talking about making sets of functions earlier, and I was wondering what we could counceivably stick into them
00:07:29 <pumpkin> (if the Ord constraint were removed)
00:07:55 <dmwit> Well, conceivably, we could stick in Haskell functions.  We just wouldn't be able to write computable programs that used such a set representation. =)
00:08:16 <pumpkin> :P
00:08:32 <pumpkin> *coinceivably and computably stick into them
00:08:46 <dmwit> I know, I was just teasing. =)
00:08:53 <pumpkin> :)
00:10:57 <adimit> hello, my ghci reports that FiniteMap is a member of ghc-6.10, which in turn is hidden. Have FiniteMaps been deprecated?
00:11:10 <dmwit> Yes.
00:11:14 <dmwit> Use Data.Map instead.
00:11:17 <jdrake> Is there any library that can do graphs but also display them on screen in its own window?
00:11:37 <dmwit> jdrake: graphviz ;-)
00:12:04 <dmwit> jdrake: Seriously, though, it should be pretty easy to write a pretty printer from Data.Graph to graphviz syntax.
00:12:12 <dmwit> There might even be something on Hackage already.
00:12:19 <jdrake> What is Data.Graph
00:12:36 <jdrake> I have never used it
00:12:46 <dmwit> Try :browse Data.Graph
00:12:48 <dmwit> See also
00:12:51 <dmwit> ?docs Data.Graph
00:12:51 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Graph.html
00:13:04 <dmwit> urgh
00:13:10 <dmwit> It seems ?docs is a bit broken.
00:13:22 <dmwit> However, you might like this:
00:13:23 <dmwit> http://www.haskell.org/ghc/docs/latest/html/libraries/
00:13:25 <lambdabot> Title: Haskell Hierarchical Libraries
00:13:33 <pumpkin> there's fgl I think that can output graphviz
00:13:39 <dmwit> (Which has a link to Data.Graph documentation.)
00:13:40 <pumpkin> and also includes a bunch of handy graph algorithms
00:14:19 <jdrake> I do have the docs on my local machine, because I don't run the latest ghc
00:16:16 <adimit> sorry folks, my irssi just exhibited a strange bug. I don't know if anybody heard (or I got an answer). I was just asking why FiniteMap seems to be hidden in the module ghc-6.10, where I cannot load it.
00:16:38 <scook0> <dmwit> Yes.
00:16:38 <scook0> <dmwit> Use Data.Map instead.
00:16:45 <adimit> scook0: thanks
00:16:52 <adimit> dmwit: thanks, too
00:16:54 <adimit> :-)
00:17:00 <dmwit> =)
00:17:41 <ski_> (pumpkin : <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/> might be interesting ..)
00:17:42 <lambdabot> http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>
00:18:16 <badri> pointfree
00:18:25 <ski_> pointless !
00:18:48 <jdrake> :t apply
00:18:49 <lambdabot> Not in scope: `apply'
00:18:54 <badri> haha, what is the pointfree bot?
00:18:58 <badri> sorry where?
00:18:59 <Axman6> :t pi
00:19:00 <lambdabot> forall a. (Floating a) => a
00:19:04 <jdrake> :t fmap
00:19:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:19:43 <Axman6> @hoogle fromF
00:19:43 <lambdabot> Distribution.Simple.Setup fromFlag :: Flag a -> a
00:19:43 <lambdabot> Distribution.Simple.Setup fromFlagOrDefault :: a -> Flag a -> a
00:19:43 <lambdabot> Data.ByteString.Internal fromForeignPtr :: ForeignPtr Word8 -> Int -> Int -> ByteString
00:19:46 <Axman6> @hoogle fromFr
00:19:47 <lambdabot> No results found
00:19:52 <jdrake> If you had two functions (a -> a) that took the same initial parameter, but whose outputs were multiplied, is there a short cut for doing that?
00:19:52 <Axman6> @hoogle fromFl
00:19:53 <lambdabot> Distribution.Simple.Setup fromFlag :: Flag a -> a
00:19:53 <lambdabot> Distribution.Simple.Setup fromFlagOrDefault :: a -> Flag a -> a
00:20:15 <ski_> @pl \x -> x * x
00:20:16 <lambdabot> join (*)
00:20:19 <ski_> badri : ^
00:20:26 <badri> ski_ : Thanks
00:20:28 <pumpkin> ski_: interesting :)
00:20:32 <Axman6> @hoogle (Floating a, Num b) => a -> b
00:20:32 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
00:20:32 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
00:20:32 <lambdabot> Data.List genericLength :: Num i => [b] -> i
00:20:33 <ski_> @help pl
00:20:34 <lambdabot> pointless <expr>. Play with pointfree code.
00:20:47 <Axman6> hmm
00:21:13 <pumpkin> we can also decide functions whose domain is only Int, Float, or Double, or other combinations of other finite types
00:21:17 <pumpkin> (equality)
00:21:19 <badri> @pl  \f g a b -> max (f a) (g b)
00:21:20 <lambdabot> flip . (((.) . max) .)
00:21:23 <pumpkin> actually, we can't
00:21:24 <badri> !!
00:21:26 <pumpkin> well, sort of
00:22:27 <badri> @pl  \f -> (\ g -> (\a b -> max (f a) (g b)))
00:22:28 <lambdabot> flip . (((.) . max) .)
00:22:38 <badri> haha currying
00:22:52 <badri> there must be a neater way!
00:23:44 <badri> For tree depth, this is what I have : depth t = depth' 0 t where
00:23:44 <badri>   depth' n (Leaf _) = n
00:23:44 <badri>   depth' n (Branch _ [branches]) = foldr (\a b -> max a (depth' (n+1) b)) 0 branches
00:23:57 <badri> I don't like the lambda fn in foldr
00:24:04 <badri> I want to write in neater..
00:24:17 <badri> using const, some pointfree combinators etc.,
00:24:21 <badri> can anybody help?
00:24:27 <ski_> (pumpkin : also a short thread at <http://www.haskell.org/pipermail/haskell/2004-June/014134.html>)
00:24:49 <badri> Oh btw my Tree is "data Tree a = Leaf a  | Branch a [Tree a]"
00:25:13 <Axman6> badri: it's clear isn;t it? that's what i strive for in my code, not necessarilly how short i can make it
00:25:54 <badri> yeah. not short per se. but after discovering pointfree, became an obsession ;)
00:26:03 <Asztal> clearer than "(. depth' (n + 1)) . max", anyway
00:26:15 <ski_> (badri : do you really need `Leaf a' there ? does not `Branch a []' suffice ? .. or maybe you don't want empty trees ?)
00:26:29 <badri> oh yes, thanks ski_
00:26:29 <Axman6> @pl (\a b -> max a (depth' (n+1) b))
00:26:30 <lambdabot> (. depth' (n + 1)) . max
00:26:38 <Axman6> right, well...
00:26:57 <badri> hmm!! I didn't realize that it can infer the userdefined depth!!!
00:26:59 <ski_> @hoogle Tree
00:27:00 <lambdabot> module Data.Tree
00:27:00 <lambdabot> Data.Tree data Tree a
00:27:00 <lambdabot> Text.XHtml.Debug treeColors :: [String]
00:27:03 <badri> lambdabot rocks!!!
00:27:09 <ski_> @type Data.Tree.Leaf
00:27:11 <lambdabot> Not in scope: data constructor `Data.Tree.Leaf'
00:27:22 <ski_> er, right
00:27:24 <ski_> @type Data.Tree.Node
00:27:25 <lambdabot> forall a. a -> Forest a -> Tree a
00:27:36 <badri> Forest my goodness
00:27:50 <ski_>   data Tree a = Node {rootLabel :: a , forest :: Forest a}
00:27:56 <ski_>   type Forest a = [Tree a]
00:27:58 <ski_> iirc
00:28:07 <badri> ha, I see, makes sense...
00:28:21 <ski_> (so that's nonempty trees)
00:28:43 <badri> So isLeaf (Node {forest:[]}) = True right?
00:29:47 <badri> and then I must add isLeaf _ = False to complete pattern matching.
00:29:53 <badri> Any better way?
00:30:09 <ski_> isLeaf = null . forest
00:30:24 <badri> duh! thanks...
00:30:27 <ski_> (if you have no `Leaf' constructore, i.e.)
00:30:57 <badri> so for record types, the record labels automatically become functions?
00:31:05 <luqui> yep
00:31:10 <badri> cool.
00:33:35 <badri> So I rewrote my Tree as data Tree a = Branch a [Tree a]
00:33:36 <badri> Then, depth t = depth' 0 t where
00:33:36 <badri>   depth' n (Branch _ branches) = if null branches then 0 else foldr (\a b -> max a (depth' (n+1) b)) 0 branches
00:33:58 <badri> That still hurts my eyes
00:34:44 <sjanssen> badri: how deep might your Tree be?
00:34:58 <badri> It would be a simple looking foldr if I didn't try to make depth tail recursive..
00:35:23 <sjanssen> that's what I'm wondering, does depth really have to be tail recursive?
00:35:25 <badri> sjanssen: It is not for any purpose yet. I just want to implement some tree algos
00:35:49 <sjanssen> actually, it requires O(n) stack already
00:35:50 <badri> sjanssen: yeah, just for fun... I would like it to be tail recursive without the ugliness
00:35:59 <badri> may be there is a monad to do that! ?
00:36:11 <sjanssen> badri: you can't really do it with O(n) stack, since you have to check every branch
00:36:20 <sjanssen> so forget about making it tail recursive
00:36:23 <badri> I have always noticed : Neat Code -> Forced Tail Recursive Rewrite -> Ugliness
00:36:44 <sjanssen> yes, and in this case the rewrite doesn't even make the code faster
00:36:52 <badri> oh yes, good point!
00:37:31 <sjanssen> here is how I'd write it: depth (Branch _ []) = 0; depth (Branch _ xs) = 1 + maximum (map depth xs)
00:37:55 <badri> yes yes..
00:37:57 <sjanssen> but even better would be to write a fold for your tree and use that
00:38:17 <Axman6> badri: maybe some form of maximum . map (depth' (n+1)) might work
00:38:23 <badri> oh even better..
00:38:33 <luqui> Badger, can't you just lose the null branches case?
00:38:34 <Axman6> (also opens the opportunity for parallelism :o
00:38:38 <badri> yeah Axman6 : thats what I wanted. byt
00:38:41 <luqui> er, badri ^
00:39:01 <badri> but pf didnt help me with it.
00:39:10 <badri> oooh luqui : I am a badger ;)
00:39:34 <badri> from UW. kinda stunned that somebody here call me by my nick!
00:39:57 <badri> pf = pl (lambdabot)
00:40:03 <blackh> instance Monoid b => Monoid (a -> b) where
00:40:03 <blackh>   mempty _ = mempty
00:40:03 <blackh>   mappend f g x = f x `mappend` g x
00:40:03 <blackh> Can someone explain this to me?
00:40:16 <blackh> How does a function that takes two arguments take three arguments (mappend) ?
00:40:50 <luqui> badri, pl is a pretty simple-minded algorithm.  it can't do reasoning like that...
00:40:58 <badri> oh cool.
00:41:22 <Axman6> blackh: are you reading that as mapend f g x = (f x) `mappend` (g x)?
00:41:34 <blackh> Yes
00:41:40 <sjanssen> blackh: it doesn't take three arguments, it takes one argument and returns a function that takes one argument that returns a function that takes one argument
00:41:57 <sjanssen> (all functions in Haskell take one argument)
00:42:36 <sjanssen> or, mappend = \f -> \g -> \x -> mappend (f x) (g x)
00:42:59 <blackh> Ah - thanks.  Now It makes a little more sense. :)
00:43:23 <sjanssen> and mappend :: Monoid b => (a -> b) -> (a -> b) -> (a -> b)
00:43:49 <badri> :t Data.Tree
00:43:50 <lambdabot> Couldn't find qualified module.
00:44:00 <badri> :t Data.Tree.Tree
00:44:01 <lambdabot> Not in scope: data constructor `Data.Tree.Tree'
00:44:16 <badri> @t Data.Tree.Node
00:44:17 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
00:44:31 <badri> argh!
00:44:37 <badri> :t Data.Tree.Node
00:44:38 <lambdabot> forall a. a -> Forest a -> Tree a
00:45:22 <badri> ski_ how did you pull the def of Tree - Can lambdabot help?
00:45:37 <badri> Or should I use documentation / source code?
00:45:56 <sjanssen> @docs Data.Tree
00:45:57 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Tree.html
00:45:57 <ksf> blackh, mempty is [], mappend ++. does that help?
00:46:05 <badri> nice!
00:46:15 <badri> url = 404
00:46:18 <sjanssen> @source Data.Tree
00:46:18 <lambdabot> http://darcs.haskell.org/packages/base/Data/Tree.hs
00:46:26 <ksf> ...failing to have an "is" relation in their implementation, they're isomorph.
00:46:34 <sjanssen> badri: http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Tree.html
00:46:36 <lambdabot> Title: Data.Tree, http://tinyurl.com/2phbrb
00:46:53 <badri> oh ool
00:46:56 <badri> cool
00:47:00 <blackh> ksf: This instance of Monoid does not do what I want it to do!
00:47:38 <blackh> So do I not use Monoid, or do I use some fancy GHC extension that lets me define it specifically for my type.
00:47:48 <sjanssen> blackh: what do you want it to do?
00:48:10 <blackh> type Output = [OutputElement] -> [OutputElement]
00:48:10 <blackh> instance Monoid Output where
00:48:10 <blackh>     mempty = id
00:48:10 <blackh>     mappend a b = a . b
00:48:24 <sjanssen> blackh: ah, the standard solution is a newtype
00:48:26 <luqui> blackh, fancy?
00:48:31 * ksf still thinks of the head of a list as its lower and [] as its upper bound and now even has an explanation
00:48:35 <sjanssen> there is also the Endo newtype that does what you want
00:48:42 <blackh> I think you might be right - a newtype would be the proper way to fix it.
00:48:45 <badri> ok. looking at Data.Tree, I see that there is no fold fn for tree. Can you confirm? If so, I want to try that. Pl don't reply with an implementation
00:48:59 <badri> there are lots of unfoldss
00:49:00 <luqui> > appEndo (Endo succ `mappend` Endo succ) 42
00:49:01 <lambdabot>   44
00:49:07 <sjanssen> badri: you're right, there isn't a fold function
00:49:16 <badri> nice!
00:49:42 <ksf> ...would be kinda strange to have one, considering trees are higher-dimensional than lists and lists already have two.
00:50:03 <badri> May be Foldable Tree instance does. But I'm not gonna look there!
00:50:10 <badri> Cause I want to try first
00:50:13 <blackh> sjanssen: newtype won't work. This is an analogue of ShowS...
00:50:18 <sjanssen> badri: it does, but it doesn't have the sort of fold you want
00:50:23 <blackh> I can't use the . operator on a newtype.
00:50:24 <badri> Oh awesome
00:50:42 <sjanssen> blackh: why won't newtype work?  You don't have to use (.) directly
00:51:22 <blackh> sjanssen: My code has millions of them.  I could write a new operator, I suppose!
00:51:41 <sjanssen> ksf: Data.Tree should have a fold.  foldr is The One True fold for lists, foldl is just an optimization
00:52:00 <blackh>                 markup "</table>\n" .
00:52:00 <blackh>                 markup "</div>\n" .
00:52:00 <blackh>                 markup "<div style=\"padding-top:10px;padding-bottom:10px\">" .
00:52:00 <blackh>                 language "app.deliver_to.explanation" .
00:52:00 <blackh> ...etc...
00:52:30 <sjanssen> blackh: the alternative is to just not use a Monoid instance
00:52:50 <blackh> I think that's going to be the answer.
00:53:31 <ksf> sjanssen, I tend to intuitively assume that you can't create those tree folds out of each other like you can do with foldl and foldr.
00:53:39 <sjanssen> on the other hand, it might also be good to make your code abstract and use a newtype
00:53:52 <sjanssen> blackh: someday you might decide to use a different representation
00:54:04 <sjanssen> ksf: hmm
00:54:18 <ksf> ...for the very reason of depth-first vs. breadth-first, which is a difference in the order of dimensions, not only direction of axis.
00:55:17 <sjanssen> yes, I don't think there is a nice expresion of breadth-first with a fold.  It is actually somewhat tricky to express in a functional language
00:55:31 <mmorrow> just found out there's a #yi
00:55:39 <mmorrow> yeehaw
00:55:41 <blackh> sjanssen: I am thinking I may want to re-write using ByteString later on so maybe you're on the right track there.
00:56:07 <mmorrow> sjanssen: ooh, i've got a good bfs:
00:56:50 <sjanssen> mmorrow: I've got one too :)
00:56:56 <mmorrow> fold cont f s = list (cont s)
00:56:56 <mmorrow>                      (\x xs -> f s x xs (\s xs -> fold cont f s xs))
00:57:03 <mmorrow> bfs = fold (\(as,fs) -> reverse as : if null fs then [] else bfs fs)
00:57:03 <mmorrow>            (\(as,fs) (Node a xs) ys go -> go (a:as,xs++fs) ys)
00:57:03 <mmorrow>            ([],[])
00:57:11 <mmorrow> sorry for the verbosity in chat
00:57:18 * pumpkin tsk tsks
00:57:19 <sjanssen> mine is not that nice
00:57:31 <mmorrow> that fold function *rocks*
00:57:37 <mmorrow> it's my new favorite
00:57:56 <mmorrow> the coolest part of it too is:
00:57:59 <mmorrow> foldl f = fold id (\z x xs k -> k (f z x) xs)
00:58:06 <mmorrow> foldr f = fold id (\z x xs k -> f x (k z xs))
00:58:10 <sjanssen> mmorrow: what is list?
00:58:16 <mmorrow> oh, its:
00:58:28 <mmorrow> @let list n _ [] = n; list _ c (x:xs) = c x xs
00:58:29 <lambdabot>  Defined.
00:58:40 <mmorrow> so just the "maybe" for []
00:58:51 <badri> sjanssen: I'm slow. what is the meaning of a tree fold. Aren't there many ways you can fold? May be it is a dumb q :(
00:59:09 <sjanssen> badri: there are many ways, but there is one way that is more natural
00:59:31 <badri> hmm which way - can you please explain w/o code?
00:59:41 <sjanssen> badri: do you see how foldr matches the structure of []?
00:59:57 <sjanssen> for each constructor of [], foldr has an argument
00:59:57 <badri> yes.. goes in order in that list
01:00:04 <badri> trees - multiple ways to traverse
01:00:36 <badri> hmm I got it!
01:00:41 <sjanssen> mmorrow: now I get type errors
01:00:48 <sjanssen> mmorrow: is this code for Data.Tree?
01:01:23 <luqui> badri, I think he's referring to the "replacement interpretation" of foldr.  so if you have a list like a:(b:(c:[]))
01:01:24 <mmorrow> yeah, but you probably need the type sig for fold. one sec, i'll paste the code + type sigs
01:01:29 <sjanssen> mmorrow: nevermind, I didn't copy the "s" in "xs" :)
01:01:35 <luqui> then foldr f z replaces [] with z and (:) with f
01:01:44 <luqui> > foldr f z (a:b:c:[])
01:01:45 <lambdabot>   f a (f b (f c z))
01:01:54 <badri> so you are suggesting that the foldr for tree be foldTree :: (root->forest->b->b)->b->(tree)->b
01:02:14 <sjanssen> badri: yes
01:02:17 <badri> ok cool
01:02:30 <luqui> sjanssen, you are?
01:02:39 <luqui> sjanssen, what's that b doing in the argument?
01:02:46 <luqui> there should be one b for each child.
01:03:40 <sjanssen> oops
01:03:53 <mmorrow> here's the minimal code http://hpaste.org/12718
01:03:56 <sjanssen> delete forest and you have the right type
01:04:10 <mmorrow> sjanssen: heh, did you try Tree instead of Forest?
01:04:14 <mmorrow> hah
01:04:21 <sjanssen> no, still wrong
01:04:41 <mmorrow> i think you might actually need the type sig for fold for ghc to infer the type you want
01:05:06 <sjanssen> (a -> [b] -> b) -> Tree a -> b
01:05:24 <mmorrow> err, for bfs?
01:05:37 <mmorrow> oh, you're not even talking to me
01:05:43 <mmorrow> :)
01:05:57 <sjanssen> mmorrow: ghc seems to infer the correct type for fold
01:06:09 <mmorrow> sjanssen: ah, just saw "mmorrow: nevermind, I didn't copy the "s" in "xs" :)"
01:06:14 <mmorrow> cool
01:06:45 <sjanssen> mmorrow: can fold build the breadth-first numbering of a tree?
01:07:32 <mmorrow> sjanssen: heh, (like the okasaki paper, right?) i'd love to find out.
01:07:48 <sjanssen> mmorrow: exactly
01:07:52 <mmorrow> here's an old paste with a bunch of prelude functions defined in terms of fold http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=413#a417
01:08:16 <badri> ah ! thanks : (a -> [b] -> b) -> Tree a -> b.
01:08:23 <mmorrow> sjanssen: i bet it could
01:08:43 * mmorrow reference unfoldForestQ in Data.Tree
01:08:49 <mmorrow> *references
01:09:04 <badri> How would type safety ensure that there are as many [b] as elements in Forest?
01:09:08 <mmorrow> *looks to for reference
01:09:53 <mmorrow> @let mutual f g a = f a (\b -> g b (\a -> mutual f g a))
01:09:53 <lambdabot>  <local>:10:0:
01:09:53 <lambdabot>      Multiple declarations of `L.mutual'
01:09:53 <lambdabot>      Declared at: <lo...
01:09:59 <mmorrow> nice
01:10:29 <sjanssen> badri: with regular lists, it can't
01:10:33 <mmorrow> sjanssen: fold and this mutual function are analogs of fold* and unfoldr i think
01:10:46 <mmorrow> mutual can define unfoldr
01:11:10 <hydo> Just out of curiosity and as a measure of my own newbness, I'm trying to mentally parse (a -> [b] -> b) -> Tree a -> b  ... does that mean 'a function that takes a Tree and results in a value of the same type as b inside the ()'s?
01:11:29 <badri> sjanssen: hmm, "regular" lists! so you mean we can define a new type class that can ensure this right? or is there already such a list?
01:11:42 <luqui> hydo, yeah
01:11:58 <sjanssen> badri: there are some statically sized lists tricks you can do with GADTs
01:11:59 <luqui> hydo, it's a two argument function, accepting a two argument function and a Tree
01:12:05 <sjanssen> badri: it is all rather complicated, however
01:12:28 <badri> sjanssen: nice, will look up
01:12:45 <hydo> really?  damn... some of this is actually sinking in.  luqui yea, I'm a little unclear about what (a -> [b] -> b) says, but I know it's saying a function is passed as an argument with a Tree
01:13:04 <hydo> brain full, time for sleep.
01:13:14 <luqui> dream of lambdasheep
01:13:41 <badri> haha@ luqui
01:14:28 <sjanssen> mmorrow: fold is looking like a paramorphism
01:15:08 <Smokey`> anyone know the name of the unboxed array type? (eg: the haskell quiv of std::vector)
01:15:21 <luqui> sjanssen, is a paramorphism just the recursive eliminator for a type?
01:15:30 <luqui> Smokey`, UArray?
01:15:37 <Smokey`> <3
01:15:57 <Axman6> could someone explain unboxing?
01:15:59 <Smokey`> (getting back into haskle, sorry - only just realised I should've used hoogle)
01:16:05 <mmorrow> sjanssen: yes
01:16:22 <sjanssen> luqui: foldr is a catamorphism, paramorphism is a catamorphism that gets the original structure too
01:16:33 <mmorrow> sjanssen: you can abort to "cont" at any point
01:16:43 <luqui> sjanssen, so... foldr is a para also?
01:16:49 <mmorrow> (and pass it an arg of your choice)
01:16:59 <mmorrow> luqui: it's a cata
01:17:02 <sjanssen> luqui: para :: (a -> [a] -> b -> b) -> b -> [a] -> b -- for lists
01:17:14 <luqui> oh I see
01:17:25 <jkff> Axman6: What exactly is unclear for you? What is an unboxed type, what are they needed for, or?
01:17:27 <luqui> well then foldTree is a cata, at least how I intended it...
01:17:31 <mmorrow> para f z (x:xs) = f z xs (\z' xs' -> para f z' xs')
01:17:31 <sjanssen> luqui: it gets the result of of reducing the list, and the list itself
01:17:38 <luqui> right.
01:17:40 <mmorrow> para f z [] = z
01:17:43 <luqui> "strong induction"
01:17:49 <Axman6> jkff: both really, i've heard the name used, but never got what it was
01:17:50 <luqui> oh no
01:18:28 <jkff> Did you already read this? http://www.haskell.org/ghc/docs/latest/html/users_guide/primitives.html
01:18:30 <mmorrow> so that fold function is that "para", but adds the ability for the result type to not be a list via the "cont" arg
01:18:30 <lambdabot> Title: 8.2.�Unboxed types and primitive operations, http://tinyurl.com/y59rbr
01:18:43 <luqui> what would be the strong induction morphism:   foomorphism :: (a -> [b] -> b) -> b -> [a] -> b
01:18:44 <Axman6> nope, will do, cheers :)
01:18:50 <luqui> (for lists)
01:18:58 <hydo> on last question, mainly a curiosity, is it pronounced MOE-nad or MAW-nad?
01:19:13 <luqui> hydo, depends.  spj says MOE-nad.  I go back and forth.
01:19:17 * Axman6 pronounces it mon-add
01:19:20 <mmorrow> hmm, i guess it depends on your accent
01:19:34 <jkff> btw, luqui, how is your nick pronounced?
01:19:37 <dolio> Eugenia Cheng pronounces it moe-nad.
01:19:40 <luqui> jkff, lukee
01:19:42 * mmorrow says it like Axman6 
01:20:04 <luqui> jkff, my name is luke.  so it's like lukey, or whatever...
01:20:11 <vegai> my name is vegai and I pronounce monad as monad
01:20:21 <mmorrow> dolio: hmm, so is that the commonly accepted pronuciation then it seems?
01:20:21 <jkff> @seen Cale
01:20:24 <hydo> I'll switch back and forth every time I say it just to mess with people.
01:20:25 <lambdabot> Cale is in #haskell, #haskell-overflow and #ghc. I last heard Cale speak 2h 46m 41s ago.
01:20:28 <luqui> sigh.  influential dick quotes.
01:20:30 <Smokey`> I say moe-nad :P
01:20:41 * mmorrow says moe-nad now :)
01:20:56 * sjanssen says warm fuzzy thing
01:21:07 <dolio> mmorrow: I guess. One would think she'd know, since she does category theory full time, I think.
01:21:26 <luqui> warm fuzzy thing is not in the spirit of avoiding success.  what are you doing?
01:21:44 <mmorrow> dolio: oh, she's the one from the youtube category theory vids, right?
01:21:46 <luqui> scary thing from category theory (but you will not need a background in category theory to read this paper)
01:21:49 <dolio> Yeah.
01:21:50 <pumpkin> conal has a smiley face at the bottom of his blog :o
01:22:04 <dolio> Kind of weird, since it allegedly comes from monoid, which is maw-noid.
01:22:16 <Cale> jkff: hello
01:22:23 <mornfall> pumpkin: You mean the part that never evaluates?
01:22:30 <Axman6> luqui: i always just pronounced it liqui, like liquid. being rather dyslexic can be fun sometimes
01:22:34 <mmorrow> dolio: yeah, that's what i assumed too
01:22:38 <pumpkin> mornfall: ?
01:22:38 <luqui> where are these alleged category theory vids?
01:22:38 <jkff> Cale: Hi. Thanks for recommending the algebra books, they arrived with RWH and Dummit+Foote is terrific
01:22:40 <mmorrow> (that it was like monoid)
01:22:43 <mornfall> pumpkin: Nevermind.
01:22:48 <Cale> Great :)
01:22:49 <dolio> luqui: Search for The Catsters.
01:23:10 <Cale> http://www.youtube.com/user/TheCatsters
01:23:10 <lambdabot> Title: YouTube - TheCatsters's Channel
01:23:23 <jkff> Cale: I read it like I'd read detective stories if only I liked them :) I never thought that group theory is *that* interesting
01:23:35 <Cale> :)
01:24:55 <luqui> nice.  I always learned better from lectures than from books!
01:25:15 <Axman6> me too
01:25:38 <jkff> Oh, it's cool that you mentioned these lectures. Seems like it's just the right time for me to finally watch them
01:26:00 <Axman6> supposed to be one of the least effective forms of learning, but i learn the most from it (well, after teaching, which is by far the best way to learn anything0
01:26:45 <jkff> I learn next to nothing from books if I don't solve the exercises. I guess the same thing applies to lectures, but in case of video lectures you usually don't have exercises.
01:26:47 <Smokey`> I tend to learn better from books/texts... personally
01:26:54 <Smokey`> but more than that, trial and error, practical experience.
01:28:24 <jkff> I think someone has to write a book about category theory like Goguen's Categorical Manifesto, but much larger: ultimately focused on examples and counterexamples to stuff. Without that, things like the Yoneda Lemma or representable functors make me ask 'Ehm, so what?'
01:28:53 <jkff> Barr and Wells are good in that aspect, but not good enough
01:29:12 <jkff> At least, the Yoneda Lemma and representable functors *made* me ask 'Ehm, so what?'.
01:29:34 <Cale> jkff: I finally got what the Yoneda Lemma was about from reading Awodey's book
01:30:01 <blackh> sjanssen: My new // concatenation operator is working really well.  I only have 857 .'s left to change into //'s.
01:30:28 <jkff> Which one? Actually, I somewhat 'got' the Yoneda lemma, but representable functors still elide me.
01:30:35 <jkff> And universal elements.
01:30:46 <Cale> jkff: It should be called Yoneda's Completion Theorem. It lets you take any category at all, even a particularly "bad" one, which is missing most constructions, and embed it into an extremely nice category.
01:31:06 <jkff> Is the Awodey's book that one you sent me a PDF of?
01:31:10 <Cale> yeah
01:31:15 <Cale> Nice, in the sense that it has all limits and colimits, among other things
01:32:30 <jkff> So, the lemma, as say B&W, is similar to the Cayley theorem? And how can this embedding be used afterwards?
01:32:49 <Cale> and it does this embedding in a very nice way: if X and Y are objects of your original category, every arrow between their images in the new category comes from an arrow in the original one.
01:33:00 <jkff> Yes, it's full and faithful
01:33:31 <jkff> So, one can study properties of arrows on the images and use them for the original category?
01:33:48 <luqui> blackh, whaa?
01:33:48 <sjanssen> blackh: hopefully you can automate that.  I suppose '.' is not the nicest character to search and replace
01:34:04 <sjanssen> blackh: by the way, // is used by Data.Array
01:34:05 <Cale> So you get this nice category with lots of extra constructions, and if you can prove the existence or uniqueness of arrows between objects in the image of the original category, then you get those results for the original one.
01:34:07 <Cale> yeah
01:34:42 <quicksilver> sjanssen: this is one of the few times it would be nice to have a haskell IDE
01:34:44 <jkff> Sounds not bad :)
01:34:44 <sjanssen> blackh: if you want to be like Cale, you could use (++) = mappend :)
01:34:49 <sjanssen> quicksilver: definitely
01:34:52 <quicksilver> sjanssen: (syntax aware search and replace)
01:35:14 <quicksilver> sjanssen: one of the cute things about eclipse (and I assume its competitors) is you can change the name of a class or method and it gets changed globally.
01:35:16 <sjanssen> HARE can supposedly do this
01:35:26 <quicksilver> without being fooled by other things which merely happen to have the same name
01:35:28 <sjanssen> quicksilver: eclipse has lots of cute things
01:35:32 <quicksilver> (i.e. it doesn't get fooled by shadowing)
01:36:29 <sjanssen> tack "extends AbstractClass" to a class defn. and hit the "fix errors" button.  It will add all the necessary stub methods
01:36:49 <blackh> sjanssen: Thanks for all that info. There isn't any way to overload ++ is there?
01:37:04 <sjanssen> blackh: import Prelude hiding ((++))
01:37:05 <Cale> blackh: Not without hiding the Prelude's version
01:37:15 <sjanssen> blackh: if you find that annoying, you might choose another operator
01:37:35 <blackh> That doesn't sound like much fun. I'll use // and arrays be damned.
01:37:41 <Cale> I hope that someday the Prelude's version will be our current mappend :)
01:37:57 <sjanssen> mmorrow: ah, I understand fold now that I've written para with it.  Very clever
01:38:20 <luqui> > fix error
01:38:21 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
01:38:37 <Axman6> :t fix
01:38:38 <lambdabot> forall a. (a -> a) -> a
01:39:00 <quicksilver> sjanssen: the annoying thing about hiding is re-export.
01:39:10 <quicksilver> sjanssen: you have to hide it from Data.List as well, and anywhere else.
01:39:12 <Axman6> > fix (1+) :: Int8
01:39:13 <lambdabot>   * Exception: stack overflow
01:39:14 <quicksilver> Not a huge problem with (++)
01:39:26 <quicksilver> but some of the monad functions are exported from all of Control.Monad.*
01:39:36 <quicksilver> so if you want to hide one you have to hide it all over.
01:39:48 <sjanssen> quicksilver: huh, that is unfortunate
01:39:53 <badri> finally: I did this:
01:39:54 <badri> let foldTree f xs t = f (head xs) (rootLabel t) (map (foldTree f (tail xs)) (subForest t))
01:40:01 <sjanssen> re-exporting Prelude identifiers is a bit dubious, I think
01:40:18 <badri> then ghci loaded some weird packages
01:40:21 <badri> syb
01:40:22 <badri> arrays
01:40:24 <badri> containers
01:40:26 <badri> why?
01:40:32 <pumpkin> it has dependencies
01:40:45 <badri> hmm
01:40:56 <badri> sjanssen: Is that the foldTree you were expecting?
01:41:00 <mmorrow> sjanssen: i arrived at it by first writing that "para", then being like "crap, i can't return anything other than a list", which made me add the "cont" and get fold
01:41:02 <sjanssen> mmorrow: and now I've written paraL, which is neat :)
01:41:21 <mmorrow> sjanssen: ooh, cool. paste?
01:41:23 <sjanssen> mmorrow: para can return things other than lists
01:41:35 <sjanssen> paral f z = fold id (\z x xs c -> c (f z x xs) xs) z
01:41:43 <mmorrow> ohhh, ok. totally
01:41:45 <sjanssen> para :: (a -> [a] -> acc -> acc) -> acc -> [a] -> acc
01:42:02 <mmorrow> i was talking about:  para f z [] = z; para f z (x:xs) = f z xs (\z' xs' -> para f z' xs')
01:42:16 <mmorrow> (or that's where i started from (i called it foldC))
01:42:38 <mmorrow> oh yeah, of course, hah
01:42:50 <mmorrow> i coulda just done    para f z [] = z
01:42:55 <mmorrow> duh
01:43:19 <sjanssen> that doesn't make fold any less interesting
01:43:20 <mmorrow> but fold with cont is great
01:43:26 <mmorrow> yeah, totally
01:43:38 <mmorrow> the ability to not have id there really makes it powerful
01:44:04 <sjanssen> it is more powerful than para, because it can choose the next list to process
01:44:32 <mmorrow> sjanssen: exactly
01:44:58 <mmorrow> (and at /any/ point during the entire computation)
01:49:24 <luqui> but doesn't that mean you lose the nice totality properties of the other morphisms?
01:49:43 <luqui> eg. a fold of a total function over a finite list is total.
01:50:15 <mmorrow> foldl f = fold id (\z x xs k -> k (f z x) xs)
01:50:15 <mmorrow> foldr f = fold id (\z x xs k -> f x (k z xs))
01:50:30 <sjanssen> luqui: yes
01:50:49 <badri> let foldTree f xs t = f (head xs) (rootLabel t) (map (foldTree f (tail xs)) (subForest t))
01:50:49 <badri> let zeros = 0:zeros
01:50:49 <badri> let depth = foldTree (\a b xs -> max a (1 + foldr max 0 xs)) zeros
01:50:49 <badri> Is that right?
01:50:56 <quicksilver> sjanssen: yes. I wish I could coherently describe the shortcomings in the haskell import/namespace system and propose something better.
01:51:07 <quicksilver> sjanssen: but I can't. I just know it isn't quite right.
01:51:08 <badri> It has all the right types..
01:51:14 <mmorrow> luqui: err, what do you mean by "other morphism". i think i misunderstood.
01:51:38 <luqui> quicksilver, that's what Udon wishes to address, you know.  But I haven't hopes of changing the language, so only on the package level...
01:52:03 <luqui> mmorrow, cata-, para-, ...
01:52:08 <sjanssen> fold id (\z x xs c -> c z (x:xs)) () [()] -- loops forever
01:52:18 <badri> :(
01:52:23 <quicksilver> luqui: I thought Udon was a noodle.
01:52:30 <Phyx-> hi, i've installed cabal, but when i try to use it, i get cabal.exe: Network.Socket.recvLen: failed (Unknown error)
01:52:36 <luqui> quicksilver, it's a very ambitious noodle
01:52:46 <quicksilver> luqui: excellent. Does it have a webpage?
01:52:51 <mmorrow> luqui: ah, i gotcha. yes you do lose that. but you /gain/ that when you lose it ;)
01:52:55 <badri> Can somebody help me with the depth code?
01:53:08 <luqui> mmorrow, heh.
01:53:15 <sjanssen> quicksilver: hiding a function from one module should hide it from all other imported modules that re-export it
01:53:23 <quicksilver> sjanssen: that would help.
01:53:33 <quicksilver> sjanssen: but also modules need to be able to export qualified identifiers.
01:53:48 <luqui> quicksilver, it's still just a sketch and pet implementation of mine.  http://github.com/luqui/udon/tree/master
01:53:53 <lambdabot> Title: luqui's udon at master — GitHub
01:53:55 * badri How may I rephrase my question so I can be helped
01:54:10 <quicksilver> sjanssen: it's all very well to say that we should use qualification instead of stupid names like mapM
01:54:27 <quicksilver> sjanssen: but it's a real pain to have hundreds of slight variations of qualified import statements at the top of every file.
01:54:41 <quicksilver> badri: by tell us if it appears to work to you; or if it doesn't appear to work, in what way it appears to fail.
01:55:01 <badri> hmm ok, fair enough. thanks quicksilver
01:55:05 <sjanssen> quicksilver: agreed.  You've also got to deal with the idiot that thinks "import Control.Monad as Z" is a good idea
01:55:44 <quicksilver> sjanssen: in all kinds of small niggly ways it doesn't quite scale and isn't quite compositional.
01:57:15 <pumpkin> sjanssen: what's wrong with importing it as Z? not that I do that, but I'm curious :)
01:57:42 <sjanssen> pumpkin: if you're used to M.map, Z.map will be annoying
01:57:54 <pumpkin> ah
01:58:02 * mmorrow likes importing Control.Monad qualified as Functor
01:58:15 <sjanssen> Functor.join -- huh?
01:58:17 <pumpkin> :
01:58:19 <Peaker> hehe
01:58:32 <mmorrow> really messes with peoples' heads
01:59:07 <quicksilver> import qualified Control.Monad as ZZ9PluralZAlpha
01:59:11 <ddarius> String.join
01:59:14 <pumpkin> o.O Left-to-right Kleisli composition of monads.
01:59:29 * sjanssen import qualified System.Posix as Win32
01:59:33 <pumpkin> @src (>=>)
01:59:34 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
01:59:39 <mmorrow> hehe, zencode all import qualifiers, and do it ALWAYS
02:00:03 <mmorrow> preflex: zdec ZZ9PluralZAlpha
02:00:03 <preflex>  Z9PluralZAlpha
02:00:15 <mmorrow> preflex: zdec Control.Monad.Functor.String
02:00:15 <preflex>  Control.Monad.Functor.String
02:00:19 <mmorrow> preflex: zenc Control.Monad.Functor.String
02:00:19 <preflex>  ControlziMonadziFunctorziString
02:00:27 <mmorrow> preflex: zenc Control.Monad.Functor.String_____
02:00:27 <preflex>  ControlziMonadziFunctorziStringzuzuzuzuzu
02:00:38 <Smokey`> are there any SIMD libraries for Haskell?
02:01:01 <badri> How do I convert number to string?
02:01:09 <mmorrow> , show 42
02:01:13 <lunabot>  "42"
02:01:18 <badri> cool
02:01:29 <mmorrow> show converts anything that can be converted to a String to a String
02:02:03 <mmorrow> (well, show converts anything that can be converted with show ;)
02:02:21 <quicksilver> Smokey`: there have been some SIMD code-generation libraries
02:02:26 <quicksilver> Smokey`: not quite the same thing.
02:02:54 <mmorrow> quicksilver: really? do you know where one might look for these?
02:03:06 <quicksilver> http://www.reddit.com/r/programming/comments/6c4d3/coconut_code_constructing_user_tool_haskell_dsl
02:03:09 <lambdabot> Title: Coconut: COde CONstructing User Tool - Haskell DSL to produce high performance S ..., http://tinyurl.com/6zepea
02:03:14 <mmorrow> quicksilver: cool, thx
02:04:41 <quicksilver> I don't believe any of the auto-vectorisation DPH work actually targets native SIMD yet, although I think it's a rather obvious step.
02:04:41 <hugo___> hey haskellians
02:04:41 <pumpkin> > (negate &&& negate) (1,5)
02:04:43 <lambdabot>       No instance for (Num (t, t1))
02:04:43 <lambdabot>        arising from a use of `negate' at ...
02:04:51 <quicksilver> pumpkin: ITYM ***
02:04:54 <pumpkin> > (negate *** negate) (1,5)
02:04:56 <pumpkin> yeah :)
02:04:56 <lambdabot>   (-1,-5)
02:04:57 <pumpkin> sorry
02:05:09 <pumpkin> so I get how the *** and &&& work, but I don't get their types :P
02:05:22 <quicksilver> specialise their types to (->)
02:05:23 <pumpkin> :t (&&&)
02:05:24 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
02:05:36 <quicksilver> (replace Arrow a => a b c with (b -> c))
02:06:04 <pumpkin> oh, in the haddock docs, I just saw the A bit, not the Arrow on a
02:06:05 <Cale> Hello hugo___
02:06:17 <pumpkin> that makes more sense
02:06:25 <luqui> hugo___, gday
02:06:28 <badri> I have a code which runs a print statement when I do "ghci tree.hs" and then type "main". However, if I do "ghc --make tree.hs" and then "./a.out", it prints nothing! What could be wrong?
02:06:44 <pumpkin> badri: buffering?
02:06:51 <blackh> gidday mr hugo___ sir eh
02:06:55 <sjanssen> badri: did you forget to print a newline?
02:06:55 <luqui> badri, are you printing an infinite list?
02:07:15 <luqui> badri, is the computer plugged in?
02:07:17 <badri> should I print a newline?
02:07:19 <badri> haha!
02:07:56 <badri> this is the code: http://hpaste.org/12721
02:08:00 <pumpkin> > (+1) ^>> (1,2)
02:08:01 <lambdabot>       No instance for (Arrow (,))
02:08:01 <lambdabot>        arising from a use of `^>>' at <inte...
02:08:19 <quicksilver> @src print
02:08:20 <lambdabot> print x = putStrLn (show x)
02:08:25 <quicksilver> print adds a newline on its own
02:08:27 <quicksilver> that's what I thought.
02:08:45 <pumpkin> :t (+1) ^>> (+2)
02:08:46 <lambdabot> forall b. (Num b) => b -> b
02:08:47 <badri> oh.  so is that correct?
02:08:51 <pumpkin> :t (+1) ^>> (+2) 5
02:08:52 <lambdabot> forall b (a :: * -> * -> *) d. (Arrow a, Num (a b d), Num b) => a b d
02:09:02 <pumpkin> :t (+1) ^>> (+2) 5 3
02:09:03 <badri> But ghci works and linked program does not
02:09:03 <lambdabot> forall b (a :: * -> * -> *) d t. (Arrow a, Num t, Num (t -> a b d), Num b) => a b d
02:09:09 <pumpkin> (+1) ^>> (+2) 5 3
02:09:12 <pumpkin> > (+1) ^>> (+2) 5 3
02:09:13 <lambdabot>       No instance for (Show (a b d))
02:09:13 <lambdabot>        arising from a use of `show' at <...
02:09:14 <quicksilver> badri: will just try compiling it myself
02:09:18 <quicksilver> badri: it works in ghci for me also
02:09:21 <badri> thanks quicksilver
02:09:25 <luqui> badri, works for me
02:09:28 <badri> but linked version does not?
02:09:37 <badri> no luqui - not from ghci
02:09:41 <quicksilver> badri: linked version works for me.
02:09:47 <luqui> badri, both work for me
02:09:52 <badri> oh I see. something wrog with my mac!
02:09:54 <quicksilver> $ ./test
02:09:54 <quicksilver> "F\n|\n+- B\n|  |\n|  +- A\n|  |\n|  `- D\n|     |\n|     +- C\n|     |\n|     `- E\n|\n`- G\n   |\n   `- G\n      |\n      `- I\n         |\n         `- H\n"
02:09:58 <luqui> badri, try kicking out an extra newline
02:10:01 <quicksilver> (on a mac, as it happens)
02:10:08 <luqui> badri, sometimes it gets overwritten by the prompt
02:10:14 <badri> Do I compile it as "ghc --make tree.hs" or something else?
02:10:25 <quicksilver> that's the right way.
02:10:26 <luqui> badri, that's how I did it
02:10:41 <badri> oh, why does it print "\n" literally anyway?
02:10:43 <badri> I see.
02:10:44 <luqui> badri, (also you should probably putStrLn rather than print)
02:10:47 <dolio> @let fixit f = mutual (\a k -> f (k a)) (\b k -> k b) undefined
02:10:48 <lambdabot>  Defined.
02:10:50 <badri> I see. will do
02:10:51 <dolio> @type fixit
02:10:52 <lambdabot> forall t. (t -> t) -> t
02:11:09 <dolio> fixit (\fac n -> if n == 0 then 1 else n * fac (n-1)) 5
02:11:18 <dolio> > fixit (\fac n -> if n == 0 then 1 else n * fac (n-1)) 5
02:11:20 <lambdabot>   120
02:11:20 <luqui> badri, print first renders it as a haskell-parsable value (with the show function).  putStrLn just prints a string to the screen,
02:11:21 <badri> oh worked. thanks
02:11:25 <dolio> mutual is general recursion.
02:11:25 <quicksilver> badri: because 'print' calls 'show' which wraps strings up ;)
02:11:34 <badri> hmmm.
02:11:37 <ddarius> @src print
02:11:37 <lambdabot> print x = putStrLn (show x)
02:11:45 <Axman6> > fixif error
02:11:46 <lambdabot>   Not in scope: `fixif'
02:11:49 <Axman6> > fixit error
02:11:50 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
02:11:59 <quicksilver> badri: compare the following:
02:12:02 <quicksilver> > "\n"
02:12:03 <lambdabot>   "\n"
02:12:05 <quicksilver> > show "\n"
02:12:06 <lambdabot>   "\"\\n\""
02:12:12 <pumpkin> @hoogle fix
02:12:12 <lambdabot> Data.Function fix :: (a -> a) -> a
02:12:12 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
02:12:12 <lambdabot> module Control.Monad.Fix
02:12:20 <badri> Interesting!
02:15:16 <badri> I tried depth of that tree and it gives one more than it should! How can I debug?
02:15:48 <quicksilver> try depth of smaller tree. think about answer. fix bug ;)
02:15:53 <luqui> > let it = const "Fixed" in fix it
02:15:54 <lambdabot>   "Fixed"
02:16:05 <badri> oh no - it is correct! my eyes
02:16:26 <quicksilver> badri: ;)
02:18:12 <badri> haskell is awesome! who do I thank? Walder, Simon,...
02:18:34 <badri> wadler*
02:18:38 <Phyx-> budha
02:18:57 <hugo___> in real world haskell there is the following example:
02:18:58 <hugo___> http://hpaste.org/12722
02:19:03 <hugo___> in chapter 9
02:19:17 <mapreduce> "Haskell?  You mean Pascal?"
02:19:32 <hugo___> my doubt is those let's inside the "do", without the final "in" , is this possible ?
02:20:18 <badri> ooh there is a huge list of primary contributors!
02:20:20 <blackh> hugo___: In do notation, let doesn't have an 'in'
02:20:34 <luqui> > let obscene = (.).(.) in obscene show (+) 1 2
02:20:36 <lambdabot>   "3"
02:20:53 <pumpkin> lol
02:21:05 <pumpkin> :t (.).(.)
02:21:06 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
02:21:15 <pumpkin> @let boobs = (.).(.)
02:21:16 <lambdabot>  Defined.
02:21:16 <badri> lol @luqui
02:21:22 <hugo___> :D
02:21:38 <ivanm> I see that #haskell has started to attract the immature script kiddies... ;-)
02:21:48 <pumpkin> onoes
02:22:08 <pumpkin> I'z in ur chanulz, lowrn ur iqz
02:22:16 <badri> pumpkin how do you use @let in lambdabot?
02:22:18 <hugo___> ahah
02:22:24 <luqui> :t </>
02:22:26 <lambdabot> parse error on input `</>'
02:22:28 <luqui> :t (</>)
02:22:29 <lambdabot> Not in scope: `</>'
02:22:32 <badri> haha! I mean an you print it back?
02:22:35 <luqui> @hoogle </>
02:22:36 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
02:22:36 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
02:22:37 <badri> can*
02:22:46 <pumpkin> badri: like the normal let with an @ in front of it :)
02:22:50 <luqui> how very cool, I knew not of this useful little thing
02:23:09 <badri> @let x = 3
02:23:10 <pumpkin> oh that is neat
02:23:10 <lambdabot>  Defined.
02:23:16 <luqui> > x
02:23:17 <blackh> > x
02:23:17 <badri> @x
02:23:17 <lambdabot> Maybe you meant: . ? @ v
02:23:18 <lambdabot>       Ambiguous occurrence `x'
02:23:18 <lambdabot>      It could refer to either `L.x', defined a...
02:23:18 <lambdabot>       Ambiguous occurrence `x'
02:23:18 <lambdabot>      It could refer to either `L.x', defined a...
02:23:22 <badri> x
02:23:25 <badri> >x
02:23:35 <pumpkin> x should already be defined by that Expr magic though
02:23:36 <luqui> there was already an x defined though
02:23:36 <badri> .?@x
02:23:38 <luqui> @undef x
02:23:45 <badri> !
02:23:47 <luqui> @unset x
02:23:47 <lambdabot> Unknown command, try @list
02:23:53 <pumpkin> > f x
02:23:54 <lambdabot>   Add a type signature
02:23:57 <luqui> > x
02:23:58 <pumpkin> > f x :: Expr
02:23:58 <lambdabot>   x
02:23:59 <lambdabot>   f x
02:24:00 <luqui> okay good.
02:24:10 <badri> I didn't follow a thing there!
02:24:19 <pumpkin> badri: there are some things already let
02:24:23 <luqui> badri, prefix a line with > and a space to evaluate something
02:24:23 <pumpkin> to let magic happen
02:24:31 <badri> oh the space
02:24:33 <badri> > x
02:24:35 <lambdabot>   x
02:24:35 <luqui> badri, but don't define single letter names
02:24:40 <luqui> badri, those are already magic
02:24:42 <badri> oh ok. cool
02:24:48 <pumpkin> > scanl f 0 [1,2,3]
02:24:49 <lambdabot>   Add a type signature
02:24:51 <luqui> (just in lambdabot, not in haskell)
02:24:52 <badri> can I unset it after I do?
02:24:54 <pumpkin> > scanl f 0 [1,2,3] :: [Expr]
02:24:56 <lambdabot>   [0,f 0 1,f (f 0 1) 2,f (f (f 0 1) 2) 3]
02:25:00 <luqui> badri, yes, with @unset
02:25:01 <Cale> @undefine
02:25:07 <luqui> er, right
02:25:15 <badri> @let var = 3
02:25:16 <lambdabot>  Defined.
02:25:18 <badri> > var
02:25:19 <lambdabot>       Ambiguous occurrence `var'
02:25:19 <lambdabot>      It could refer to either `L.var', defin...
02:25:23 <Cale> heh
02:25:31 <Cale> What are the chances? :)
02:25:34 <Cale> @undefine
02:25:38 <Cale> @let foo = 3
02:25:38 <luqui> :t var
02:25:39 <lambdabot>  Defined.
02:25:40 <lambdabot> forall a. String -> Sym a
02:25:43 <badri> > foo
02:25:44 <lambdabot>   3
02:25:45 <luqui> haha same lib
02:25:48 <badri> @undefine foo
02:25:52 <badri> > foo
02:25:53 <lambdabot>   Not in scope: `foo'
02:25:58 <badri> Cool!
02:26:02 <Cale> It doesn't really take a parameter
02:26:09 <Cale> @undefine just clears all the user definitions
02:26:13 <luqui> oh
02:26:17 <badri> oh
02:26:22 <luqui> > var "foox"
02:26:23 <lambdabot>       Ambiguous occurrence `var'
02:26:23 <lambdabot>      It could refer to either `Data.Number.S...
02:26:30 <luqui> oh please!
02:26:39 <badri> @undefine var
02:26:46 <badri> > var "foox"
02:26:47 <lambdabot>       Ambiguous occurrence `var'
02:26:47 <lambdabot>      It could refer to either `Data.Number.S...
02:26:52 <badri> hmm
02:27:01 <badri> :t var
02:27:02 <lambdabot> forall a. String -> Sym a
02:27:13 <luqui> that's very strange.  :t thinks it's fine, but > doesn't.
02:27:23 <badri> yeah.
02:27:28 <dolio> > let uncons z _ [] = z ; uncons _ f (x:xs) = f x xs ; fold k f z = uncons (k z) (\x xs -> f z x xs $ \z xs -> fold k f z xs) ; fixit2 f = fold id (\z x xs k -> f $ k z (x:xs)) undefined [()] in fixit2 $ (0:) . scanl (+) 1 -- fold is also general recursion
02:27:29 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
02:29:26 <badri> Is there a better way of defining foldTree than http://hpaste.org/12721 for the purposes of calculating depth? I would have liked to get rid of the infinite list that provides zero seeds
02:30:44 <quicksilver> badri: well you could define it directly, not using foldTree.
02:30:59 <badri> hmm yeah. that's there
02:31:11 <quicksilver> or you could use a slightly different definition of foldTree
02:31:12 <luqui> badri, why is the leaf parameter a list?
02:31:20 <badri> but something about the foldTree is ugly.
02:31:22 <luqui> I would have made it a constant
02:31:26 <quicksilver> that particular one (passing a different value to each depth of the tree) is a bit odd.
02:31:27 <badri> Leaf Parameter?
02:31:37 <luqui> "t" in the def. of foldTree
02:31:53 <badri> t is the tree itself
02:32:06 <badri> (subForest t) gives a list of trees
02:32:14 <quicksilver> I think luqui means 'xs'
02:32:16 <badri> (rootLabel t) gives the value of that node
02:32:17 <luqui> oh sorry, I mean xs
02:32:23 <quicksilver> it's more of a level parameter than a leaf one, though.
02:32:26 <badri> Oh yeah, xs is ugly
02:32:34 <quicksilver> it gets incorporated in every usage of 'f'
02:32:46 <quicksilver> but the value is set per-level, using a list.
02:32:49 <luqui> I would just say "x", and replace (head xs) and (tail xs) both with just "X"
02:32:56 <quicksilver> I can see that being occasionaly useful but it's a little odd ;)
02:32:57 <badri> xs must be atleast the size of the flattened tree
02:33:30 <badri> yeah luqui - that should rid it of infinite list!
02:33:42 <badri> but I must see how general that fold can be
02:33:51 <badri> What would a general fold on the tree be?
02:33:54 <luqui> badri, that would be a typical inductive fold
02:34:06 <badri> hmm. inductive fold. will google
02:34:15 <luqui> probably not find much
02:34:29 <luqui> basically folds replace constructors with functions.
02:34:36 <badri> ha ya - just inductive def of fol
02:34:38 <badri> fold*
02:34:40 <luqui> (well, loosely.  I guess that's cata)
02:35:02 <luqui> so a "global context" of computation, as xs provides, is not usually in fold
02:35:03 <badri> ok.. but if I don't supply xs, and only put x, it feels less general
02:35:11 <badri> I see
02:35:21 <luqui> you can add global context back in by folding into a monad, for example.
02:35:36 <luqui> (which is what Data.Foldable does)
02:35:50 <badri> ok, I didn't understand that. will have to wait till I get that maturity
02:36:13 <badri> I'm just a novice and still scared of warm fuzzy things
02:36:16 <luqui> it won't take long
02:36:29 <luqui> mwahahahahahaaaa!
02:36:39 <badri> oh ok. haskell wiki is great. will slowly learn monads and arrows.
02:36:44 <badri> haha
02:37:35 <badri> does clicking annotate on hpaste edit an old paste?
02:37:57 <quicksilver> yes
02:38:01 <quicksilver> well it lets you add new bits
02:38:04 <quicksilver> (annotations)
02:38:04 <badri> cool. awesome
02:38:33 <dolio> @type let f g x (z, l) = (g x l z, x:l) in \g z -> fst $ foldr (f g) (z,[])
02:38:34 <lambdabot>     Couldn't match expected type `(a, b)'
02:38:34 <lambdabot>            against inferred type `[a1] -> (t, [a1])'
02:38:34 <lambdabot>     In the second argument of `($)', namely `foldr (f g) (z, [])'
02:39:29 <dolio> @type let f g x (z, l) = (g x l z, x:l) in \g z -> fst . foldr (f g) (z,[])
02:39:30 <lambdabot> forall a a1. (a1 -> [a1] -> a -> a) -> a -> [a1] -> a
02:43:01 <Peaker> are regexps required for reasonable-complexity substring lookup?
02:43:33 <luqui> > foldr (\a b -> [(a:),id] <*> b) (pure []) [1,2,3,4]
02:43:34 <lambdabot>       Ambiguous occurrence `pure'
02:43:34 <lambdabot>      It could refer to either `Control.Appl...
02:43:40 <luqui> > foldr (\a b -> [(a:),id] <*> b) ([[]]) [1,2,3,4]
02:43:41 <lambdabot>   [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4...
02:44:19 <luqui> Peaker, by required you mean in common usage?
02:44:35 <Peaker> luqui: I mean are they the only option in the stdlib?
02:44:41 <badri> luqui : Are you in Madison?!
02:44:52 <luqui> badri, ... no...
02:45:07 <badri> Oh that's some other Luke Palmer. My bad!
02:45:13 <quicksilver> Peaker: erm, no.
02:45:27 <quicksilver> Peaker: why would regexp be any better than just looking for the substring?
02:45:38 <Peaker> quicksilver: O(N+M) rather than O(N*M) worst case?
02:46:07 <luqui> badri, ah yeah, the other Luke Palmer, engineer and musician, just like me.  He  has confused many employers...
02:46:14 <quicksilver> someone wrote a KMP bytestring algorithm.
02:46:19 <badri> haha
02:46:29 <luqui> wait, KMP, not boyer-moore?
02:46:32 <quicksilver> but to be honest, how often does that worst case occur?
02:46:50 <quicksilver> are you often looking for "aaaaaab" in "aaaaabaaaaabaaaaabaaaaabaaaaaab" ?
02:47:21 <quicksilver> (and I wonder if the regexp implementation gets this right either ;)
02:47:55 <Peaker> quicksilver: if it doesn't, I'd be very disappointed :)
02:48:17 <luqui> well an NFA implementation would suck
02:48:21 <luqui> but the DFA implementation will be fine
02:48:58 <dolio> @type let cata f = f . fmap (cata f) . out ; para g = cata (g &&& In . fmap snd) in para
02:48:59 <lambdabot> forall (f :: * -> *) c. (Functor f) => (f (c, Mu f) -> c) -> Mu f -> (c, Mu f)
02:49:11 <dolio> @type let cata f = f . fmap (cata f) . out ; para g = fst . cata (g &&& In . fmap snd) in para
02:49:12 <lambdabot> forall (f :: * -> *) c. (Functor f) => (f (c, Mu f) -> c) -> Mu f -> c
02:49:48 <vaskaren> if i have a list xs = [a,b,c,d,e] and i want to compare each number to the other. is the total nbr of comparisons the facotiral of the length?
02:49:55 <vaskaren> so 120 diff comparisons?
02:50:03 <Peaker> What's Mu? Is it a part of the Cow package?
02:50:05 <luqui> vaskaren, no, n(n+1)/2
02:50:32 <dolio> newtype Mu f = In { out :: f (Mu f) }
02:50:44 <Peaker> n(n-1)/2
02:50:45 <dolio> Not sure where lambdabot gets it from.
02:50:56 <luqui> Peaker, oh right, I think it is -
02:51:09 <Peaker> luqui: yeah, choose one out of n, then another one out of n-1, then divide by 2 for symmetry
02:51:12 <vaskaren> (n^2-n)/2
02:51:14 <vaskaren> ok
02:51:15 <luqui> vaskaren, pairings = n(n-1)/2, subsets = 2^n, permutations = n!
02:51:29 <luqui> Peaker, hmm, good intuition :-)
02:51:31 <Peaker> vaskaren: the logic behind it is simple
02:51:52 <vaskaren> permutaions means [a,b,c] [b,c] etc? not just paris but all possible orderings? also [b,a,c,d,e]?
02:52:21 <luqui> vaskaren, all possible orderings of the complete length.  so [b,c] wouldn't be included.
02:53:17 <luqui> choose 1 out of 5 to be first, 1 out of the remaining 4 to be second, 1 out of the the remaining 3 to be third, ...    5*4*3*2*1
02:53:37 <quicksilver> sometimes haskell-cafe is just the best.
02:54:06 <quicksilver> dan weston++ # principle fiber bundles the 'obvious' way to do line art animation.
02:54:19 <luqui> yeah that was cool
02:54:29 <luqui> had to read up.  still have to read up more, I don't really get it.
02:55:23 <Axman6> quicksilver: got a link?
02:55:36 <quicksilver> Axman6: http://www.nabble.com/Re%3A-Animated-line-art-p20845793.html
02:55:41 <lambdabot> Title: Nabble - Re: Animated line art
02:55:48 <Axman6> cheers
02:58:20 <Peaker> what's a nice definition of perms?
02:58:54 * paolin1 thanks a lot the authors of real world haskell
02:59:36 <Axman6> Peaker: i was looking for one the other day, and still had this open: http://www.mail-archive.com/haskell@haskell.org/msg19031.html
02:59:41 <lambdabot> Title: Re: [Haskell] String permutation
02:59:47 <luqui> > permutations [1,2,3,4]
02:59:48 <lambdabot>   Not in scope: `permutations'
02:59:54 <luqui> awww.  it's in base 4
03:00:21 <Axman6> i quite like this one though:
03:00:22 <Axman6> perms [] = [[]]
03:00:22 <Axman6>     perms (x:xs) = [ p ++ [x] ++ s | xs' <- perms xs
03:00:22 <Axman6>                                    , (p, s) <- zip (inits xs') (tails xs') ]
03:00:28 <dolio> > let inserts e [] = [[e]] ; inserts e l@(x:xs) = (e:l) : map (x:) inserts e xs ; perms [] = [[]] ; perms (x:xs) = inserts x (perms xs) in perms [1..3]
03:00:30 <lambdabot>   Couldn't match expected type `[[t]]'
03:00:48 <dolio> > let inserts e [] = [[e]] ; inserts e l@(x:xs) = (e:l) : map (x:) (inserts e xs) ; perms [] = [[]] ; perms (x:xs) = inserts x (perms xs) in perms [1..3]
03:00:49 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
03:00:49 <lambdabot>        Expect...
03:00:53 <dolio> Bah.
03:01:27 <dolio> > let inserts e [] = [[e]] ; inserts e l@(x:xs) = (e:l) : map (x:) (inserts e xs) ; perms [] = [[]] ; perms (x:xs) = perms xs >>= inserts x in perms [1..3]
03:01:29 <lambdabot>   [[1,2,3],[2,1,3],[2,3,1],[1,3,2],[3,1,2],[3,2,1]]
03:02:30 <Axman6> > let perms [] = [[]]; perms (x:xs) = [ p ++ [x] ++ s | xs' <- perms xs, (p, s) <- zip (inits xs') (tails xs') ] in perms [1..3]
03:02:31 <lambdabot>   [[1,2,3],[2,1,3],[2,3,1],[1,3,2],[3,1,2],[3,2,1]]
03:02:38 <luqui> Axioplase, that's a neat one
03:02:56 <luqui> damnit.   Axman6, of course
03:02:57 <Axman6> i didn't write it sadly, i do like the way it works though
03:03:13 <Axman6> first one i've seen that makes a lot of sense to me
03:03:39 <Peaker> Axman6: those aren't very nice
03:03:48 <Peaker> Axman6: (on the web page)
03:04:01 <Axman6> yeah, i meant to paste http://www.mail-archive.com/haskell@haskell.org/msg19029.html
03:04:47 <Peaker> Axman6: now convert that to a foldr :)
03:05:08 <Axman6> @undo [ p ++ [x] ++ s | xs' <- perms xs, (p, s) <- zip (inits  xs') (tails xs') ] in perms [1..3]
03:05:08 <lambdabot>  Parse error at "in" (column 77)
03:05:15 <Axman6> @undo [ p ++ [x] ++ s | xs' <- perms xs, (p, s) <- zip (inits  xs') (tails xs') ]
03:05:15 <lambdabot> concatMap (\ xs' -> concatMap (\ (p, s) -> [p ++ [x] ++ s]) zip (inits xs') (tails xs')) perms xs
03:06:09 <Peaker> > let perms = foldr (\x pxs -> [ p ++ [x] ++ s | xs' <- pxs, (p, s) <- zip (inits xs') (tails xs') ]) [[]] in perms [1..3]
03:06:10 <lambdabot>   [[1,2,3],[2,1,3],[2,3,1],[1,3,2],[3,1,2],[3,2,1]]
03:06:19 <Axman6> :t concatMap (f :: a -> b) zip
03:06:20 <lambdabot>     Couldn't match expected type `[a]'
03:06:20 <lambdabot>            against inferred type `[a1] -> [b] -> [(a1, b)]'
03:06:20 <lambdabot>     In the second argument of `concatMap', namely `zip'
03:07:29 <Peaker> > let perms = foldr (\x pxs -> pxs >>= \xs' -> zip (inits xs') (tails xs') >>= \(p, s) -> p ++ [x] ++ s) [[]] in perms [1..3]
03:07:30 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
03:07:30 <lambdabot>        Expect...
03:08:27 <dolio> I kind of like 'perms l = do (x,xs) <- select l ; p <- perms xs ; return (x:p)', where select is defined for a class MonadSelect or some such.
03:08:49 <dolio> Then you can implement it with [] to get all permuatations, and with Random to get one random permutation.
03:09:04 <Peaker> > let perms = foldr (\x pxs -> (pxs >>= (\xs' -> zip (inits xs') (tails xs') >>= (\(p, s) -> p ++ [x] ++ s)))) [[]] in perms [1..3]
03:09:05 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
03:09:05 <lambdabot>        Expect...
03:09:09 <quicksilver> and Maybe to get the first permutation (if any)
03:10:02 <hugo___> is there a fold that doesn't take a initial/final argument ?
03:10:10 <Axman6> foldl1
03:10:15 <hugo___> ah nice
03:10:16 <hugo___> okey
03:10:20 <Axman6> > foldl1 (+) [1..10]
03:10:21 <lambdabot>   55
03:10:25 <hugo___> yes :D
03:10:26 <hugo___> great
03:10:28 <Axman6> > foldl1 (+) []
03:10:29 <lambdabot>   * Exception: Prelude.foldl1: empty list
03:10:31 <luqui> > foldl (+) [1..999999]
03:10:32 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
03:10:32 <lambdabot>        arising from a use...
03:10:32 <Axman6> :o
03:10:40 <luqui> > foldl1 (+) [1..999999]
03:10:42 <lambdabot>   * Exception: stack overflow
03:10:45 <luqui> > foldl1' (+) [1..999999]
03:10:47 <lambdabot>   499999500000
03:10:56 <Axman6> @hoogle foldl1'
03:10:56 <lambdabot> Data.ByteString foldl1' :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
03:10:56 <lambdabot> Data.List foldl1' :: (a -> a -> a) -> [a] -> a
03:10:56 <lambdabot> Data.ByteString.Char8 foldl1' :: (Char -> Char -> Char) -> ByteString -> Char
03:11:17 <ivanm> how does one get lambdabot to use Data.Map?
03:11:18 <luqui> foldl1' is just foldl1 which doesn't stack overflow =P
03:11:20 <hugo___> ouch
03:11:38 <ivanm> M.union and Data.Map.union both fail :s
03:11:40 <hugo___> my computer is darn slow doing a foldl1 (+) [1..9999999]
03:11:42 <hugo___> :D
03:11:54 <luqui> hugo___, aye, use foldl1' :-)
03:12:12 <hugo___> *** Exception: stack overflow
03:12:12 <hugo___> yes
03:12:20 <hugo___> foldl1' isn't recursive ?
03:12:22 <Axman6> > foldl1 (GHC.Prim.+#) [1..maxBound :: Int]
03:12:23 <lambdabot>   Couldn't match kind `#' against `*'
03:12:29 <dolio> @type M.union
03:12:30 <lambdabot> forall k a. (Ord k) => M.Map k a -> M.Map k a -> M.Map k a
03:12:39 <ivanm> > Data.Map.union (M.fromList [(1,2)])  (M.fromList [(1,3)])
03:12:40 <lambdabot>   /tmp/966991441562236632:70:48: Not in scope: `Data.Map.union'/tmp/966991441...
03:12:48 <ivanm> > M.union (M.fromList [(1,2)])  (M.fromList [(1,3)])
03:12:50 <lambdabot>   /tmp/49738604701817669:70:48: Not in scope: `M.union'/tmp/49738604701817669...
03:12:53 <luqui> hugo___, foldl1 is not strict, so it builds up a giant thunk then evaluates it.  foldl1' is strict, so it evaluates the thunk as it chunks through the list.
03:12:59 <ivanm> dolio: ^^
03:13:03 <hugo___> ah
03:13:05 <hugo___> okey
03:13:13 <dolio> That's a weird error, all right.
03:13:17 <fasta> quicksilver: is there a program that creates the Storable instances for a given Haskell module or datatype? I read the FFI spec, but that only contains the bare minimum to build something like that on top of it.
03:13:19 <hugo___> i prefer the recursive one, dont know why, it seems more "correct"
03:13:39 <Axman6> @src foldl'
03:13:39 <lambdabot> foldl' f a []     = a
03:13:39 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
03:13:46 <luqui> hugo___, they are both recursive...
03:13:49 <hugo___> probably "in the future"computers will be able to split and process pending recursive operations or whatever :P
03:13:50 <dolio> @undefine
03:13:53 <hugo___> oh
03:13:54 <hugo___> yes
03:13:57 <hugo___> one is non-strict
03:14:09 <dolio> > M.union (M.fromList [(1,2)]) (M.fromList [(1,3)])
03:14:10 <lambdabot>   /tmp/1076568646358868799:70:48: Not in scope: `M.union'/tmp/107656864635886...
03:14:11 <ivanm> > (M.fromList [(1,2)])
03:14:12 <lambdabot>   /tmp/6264419389930530615:70:41: Not in scope: `M.fromList'
03:14:20 <ivanm> looks like all map stuff fails :s
03:14:22 <luqui> in my years of haskelling, I have only seen one case where foldl was the right choice.
03:14:27 <dolio> Something weird is going on today.
03:14:31 <luqui> and I don't remember what it was.
03:14:35 <hugo___> ahah
03:14:37 <ivanm> luqui: lol
03:14:38 <hugo___> nice luqui :)
03:14:55 <hugo___> but "in the future" ...
03:15:30 <MyCatVerbs> hugo___: THERE WILL BE ROBOTS
03:15:36 <quicksilver> fasta: well, how should it creat them? There are choices involved in storable instances...
03:15:37 <hugo___> :D
03:15:41 <dolio> foldl is the right choice for reverse, because the extra seqs don't do anything.
03:15:43 <MyCatVerbs> hugo___: *bzzzzt*
03:15:44 <Axman6> would map (foldl' f i) still be lazy when taking the results from the map?
03:15:47 <quicksilver> fasta: I believe that one of the deriving programs can do it.
03:16:29 <luqui> Axman6, yeah.  to seq a map is to evaluate its spine.  the values are still lazy.
03:16:34 <MyCatVerbs> Axman6: yes, unless (I'm too lazy to scroll up and read) you're using some kind of strict list type instead of ordinary lists.
03:16:35 <dolio> (Although foldl' is equally valid, since seq should have no runtime cost in general.)
03:16:41 <quicksilver> fasta: hmm. I think I'm wrong.
03:16:56 <fasta> quicksilver: about what?
03:17:06 <Axman6> luqui: heh, nah i was hoping it'd still be lazy :)
03:17:27 <ivanm> Axman6: no RWH for a while :(
03:17:38 <Axman6> yeah, i got your email :(
03:17:41 <luqui> Axman6, what do you mean lazy?  maps don't ever have a lazy spine.
03:18:02 <Axman6> i thought map was lazy?
03:18:09 <luqui> only in its values
03:18:10 <quicksilver> fasta: neither DrIFT not Derive support a derivation for storable.
03:18:25 <quicksilver> fasta: maybe c2hs can.
03:18:50 <fasta> quicksilver: I think c2hs is only from c to Haskell, not the other way around.
03:19:28 <luqui> Axman6, in other words,  foldr (uncurry Map.insert) Map.empty [ (x,x) | x <- [1..] ]  = _|_
03:19:35 <Peaker> need a nice PL of: (\x pxs -> pxs >>= \xs' -> zip (inits xs') (tails xs') >>= \(p, s) -> [p ++ [x] ++ s])  for nice permutations :)
03:20:04 * luqui doesn't think that's going to have a nice pointfree form...
03:20:08 <Axman6> luqui: i was talking about map for lists, 'map (foldl' f i) [a..b]' type map
03:20:19 <luqui> Axman6, oh!
03:20:25 <Axman6> @pl (\x pxs -> pxs >>= \xs' -> zip (inits xs') (tails xs') >>= \(p, s) -> [p ++  [x] ++ s])
03:20:26 <lambdabot> (=<<) . flip ((>>=) . liftM2 zip inits tails) . (`ap` snd) . (. fst) . flip flip [] . ((flip . ((:) .)) .) . flip ((.) . (++)) . (:)
03:20:31 <Axman6> Peaker: nice enough?
03:20:36 <Peaker> hah
03:20:49 <luqui> Axman6, it would b as lazy as foldl, which is to say not at all.
03:20:53 <Axman6> Peaker: i thought the list comprehension version was very nice
03:21:08 <Peaker> Axman6: I am growing into a PL fanatic :)
03:21:17 <luqui> Peaker, don't give in!
03:21:17 <Axman6> bad Peaker!
03:21:26 <Axman6> no! bad boy!
03:21:36 <Peaker> I believe PL code can be more general than point-ful code
03:21:52 <luqui> @pl \a b c d e f g h i j k l m n o p q r s t u v w x y z -> p e a k e r   d o n t   g i v e   i n
03:21:55 <lambdabot> const . const . ((const .) .) . (((const .) .) .) . ((((const .) .) .) .) . (((((const .) .) .) .) .) . (((((const .) .) .) .) .) . ((((((((const .) .) .) .) .) .) .) .) . (((((((((const .) .) .) .)
03:21:55 <lambdabot> .) .) .) .) .) . ((((((((((const .) .) .) .) .) .) .) .) .) .) . (((((((((((const .) .) .) .) .) .) .) .) .) .) .) . (((((((((((const .) .) .) .) .) .) .) .) .) .) .) . (((((((((((const .) .) .) .) .
03:21:55 <lambdabot> ) .) .) .) .) .) .) . (((((((((((const .) .) .) .) .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((ap .) .) .) .) .) . ((((((flip .) .) .)
03:21:55 <lambdabot>  .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((((flip .) .) .) .) .) .) .) .) .) . ((((((((((flip .) .) .) .) .) .) .) .) .) .) . flip (flip . (flip .) .
03:21:58 <lambdabot>  ((flip .) .) . (((ap .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((((
03:22:01 <lambdabot> [5 @more lines]
03:22:01 <Peaker> hehehe
03:22:03 <lambdabot> optimization suspended, use @pl-resume to continue.
03:22:04 <dolio> @pl \x -> x
03:22:05 <lambdabot> id
03:22:43 <luqui> Peaker, in many cases, pointfree code is stated compositionally so it generalizes to other categories
03:22:45 <Axman6> Peaker: i don't know what you mean, but i'll take readable code over most pointfree code anyday
03:23:04 <Peaker> luqui: exactly
03:23:06 <luqui> Peaker, but gratuitous pointlessness doesn't buy you anything.
03:23:31 <Peaker> luqui: that's why I want a good PL and not the out-of-box @pl one
03:23:35 <vegai> luqui++
03:24:07 <Peaker> luqui: Generally, if I don't use the magic backslash, I can have my code translate to any type I want, by using only composition methods rather than composition functions
03:24:35 <luqui> well to find it, perhaps we should find the categorical essence of permutations and it will become obvious
03:25:09 <Axman6> i still stick by my 'no pointfree for more than two arguments, should be avoided with two arguments unless clear, and only used on one argument when it's clear' rule
03:25:46 * luqui sticks by his 'no pointfree unless clear'
03:26:05 <Peaker> I created a google group for Haskell Cafe
03:26:11 <Axman6> luqui: my rule tries to define that to some point ;)
03:26:13 <hugo___> hmm, i have a list of Maybe's, is there anyway to filter it, in order to have only the Just typeclass it holds ?
03:26:24 <Peaker> luqui, Axman6: I think PL *can* always be clear, we just need to find the right combinators
03:26:25 <luqui> Axman6, but the definition is recursive :-)
03:26:25 <hugo___> i mean, to remove the Nothing's :P
03:26:27 <dolio> @type catMaybes
03:26:28 <lambdabot> forall a. [Maybe a] -> [a]
03:26:36 <hugo___> allright! thanks dolio
03:26:37 <hugo___> :D
03:26:38 <Axman6> Peaker: i disagree
03:26:41 <Peaker> luqui, Axman6: I think the magic backslash is evil, too :-)
03:26:46 <luqui> Peaker, except in a few select cases, I agree
03:26:53 <Peaker> power stems from user-definable operations
03:27:10 <luqui> Peaker, well we could just give you s, k, and fix, and you could pointfree to your heart's content without ever using backslash
03:27:21 <sjanssen> Axman6: my personal rule is to only use point free when I can do the translation in my head
03:27:26 <Axman6> i don't see how making something pointfull makes it any less useful or generic
03:27:39 <Peaker> luqui: which categories can implement s, k, and fix, and subsets of those?
03:27:48 <Peaker> Axman6: Here's an example
03:27:54 <Peaker> @type (***)
03:27:54 <luqui> Peaker, cartesian closed is my guess
03:27:55 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
03:28:19 <luqui> s in particular is very strong
03:28:21 <Axman6> sjanssen: yeah, that's not bad. but if you're used to writing pointfree nonsense, you might still end up with non-clear code to others
03:28:28 <Peaker> > ((*2) *** (+1)) (3,5)
03:28:29 <lambdabot>   (6,6)
03:28:34 <Axman6> i try to think about readability for others, not myself
03:28:42 <Peaker> @src (->) (***)
03:28:42 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
03:28:50 <opqdonut> aww, lazy patterns
03:29:01 <Peaker> Axman6: consider using: \ ~(x,y) = (f x, g y)           vs.  using (***),   which code is more general?
03:29:09 <Axman6> Peaker: see, that's a nice pointful definition :P
03:29:09 <Peaker> s/=/->
03:29:33 <Peaker> Axman6: but your point-ful definition will create a Haskell function, my points-free definition will create an arrow, which CAN be a function, but it can also be a data structure and various other things
03:29:42 <Peaker> Axman6: so my code will be more general
03:29:48 <goober> http://www.e-pig.org/downloads/epigram-notes.pdf
03:29:52 <lambdabot> Title: Epigram: Practical Programming with Dependent Types
03:29:55 <dolio> And you will never use that generatlity. :)
03:30:00 <Axman6> i think we're talking about different things now
03:30:06 <dolio> Generality, even.
03:30:24 <Peaker> dolio: That may be true for now, because the mind-set is still that points-free is nothing other than style, if we get enough stuff to actually be general, then that generality will start to be of use
03:30:31 <goober> you guys ever tried Epigram?
03:30:40 <dolio> Epigram is awesome.
03:30:41 <luqui> goober, absolutely!
03:31:08 <luqui> it's kind of a pain in the ass because of its immaturity, but definitely a cool concept and really fun to play with
03:31:13 <dolio> Peaker: There are already plenty of languages where everything is written point-free.
03:31:30 <dolio> Forth, Factor, Joy...
03:31:34 <Peaker> dolio: PL is half way there, you also need the composition operators to be methods rather than functions
03:31:34 <luqui> dolio, concatenative you speak?
03:31:36 <Axman6> Peaker: try defining (***) in a pointfree way clearly for me
03:31:47 <goober> what fundamental restrictions of Haskell does Epigram break free from that you like?
03:31:50 <dolio> Probably APL and J qualify, too.
03:31:58 <luqui> here's a more fun challenge:  try defining the quadratic formula pointfree %-)
03:32:07 <Peaker> Axman6: Its a combinator, it does not need a definition, but ok
03:32:14 <luqui> but I don't think anyone here is arguing that zero points is the way to go all the time
03:32:15 <Peaker> @pl \(x,y) -> (f x, g y)
03:32:16 <lambdabot> f *** g
03:32:19 <Peaker> doh :-)
03:32:21 <opqdonut> Peaker: :D
03:32:25 <Axman6> :)
03:32:44 <opqdonut> @pl \(x,y) -> (f x, g y, 0)
03:32:45 <lambdabot> uncurry (flip flip 0 . (. g) . (,,) . f)
03:32:48 <opqdonut> there
03:32:52 <Axman6> Peaker: it has to take in the functions too
03:33:03 <opqdonut> @pl \f g (x,y) -> (f x, g y, 0)
03:33:04 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip 0 . ((flip . (flip .)) .) . flip . (((.) . (,,)) .)
03:33:10 <opqdonut> yay for flips
03:33:17 <hugo___> hmm
03:33:17 <dolio> Even if you're trying to be as categorically inspired as possible, you don't eliminate all function parameters in the name of being point-free.
03:33:18 <Axman6> \pl \f g (x,y) = (f x, g y)
03:33:22 <Axman6> @pl \f g (x,y) = (f x, g y)
03:33:23 <lambdabot> (line 1, column 12):
03:33:23 <lambdabot> unexpected "="
03:33:23 <lambdabot> expecting pattern or "->"
03:33:26 <dolio> For instance...
03:33:27 <Axman6> @pl \f g (x,y) -> (f x, g y)
03:33:27 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
03:33:31 <hugo___> how do i change from: [IO (Maybe Image)] to IO [Maybe Image] ?
03:33:33 <Axman6> wow, clarity!
03:33:38 <dolio> @pl cata f = f . fmap (cata f) . out
03:33:38 <lambdabot> cata = fix (ap (.) . flip flip out . (((.) . fmap) .))
03:33:41 <quicksilver> hugo___: sequence
03:33:42 <Axman6> :t sequence
03:33:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
03:33:45 <opqdonut> hugo___: sequence
03:33:48 <goober> the problem with Epigram is... could you even write it on IRC?
03:33:48 <hugo___> allright :D
03:33:50 <hugo___> thanks
03:33:51 <Axman6> whoot, i was right :D
03:33:53 <Peaker> Axman6: the idea is that you don't build _everything_ from very very basic combinators like flip/id/(.)
03:34:16 <goober> If I tried to write Epigram on this channel, I'd get banned for ASCII art spamming
03:34:25 <Peaker> Axman6: the idea is that you have a bunch of combinators like Arrows, Functors, Applicatives, and even define more for clarity of PL expressions, and you use those
03:34:32 <dolio> That's wrong, because when you define such a thing categorically, f isn't just some 'point' that you ignore because 'you don't talk about object structure in category theory.'
03:34:37 <hugo___> haskell is amazing :)
03:34:41 <Peaker> Axman6: for example,  (f .) . (. g)  is unreadable,  but:  result f . argument g      is pretty readable
03:34:47 <lilac> @type liftM catMaybes . sequence
03:34:49 <lambdabot> forall a (m :: * -> *). (Monad m) => [m (Maybe a)] -> m [a]
03:34:51 <Peaker> Axman6: (at least if you know what "result" and "argument" mean)
03:34:56 <Axman6> Peaker: not to me
03:35:03 <Axman6> which i don't ;)
03:35:10 <luqui> dolio, except when you do talk about objects via the embedded language, a la sigfpe's recent post
03:35:22 <Peaker> Axman6: result says "then apply the given function to the result",  argument says "apply this function to the argument before applying the function"
03:35:22 <dolio> Sure.
03:35:24 <Axman6> like i said, i try and write code that other people could follow if they wanted to
03:35:45 <Axman6> :t argument
03:35:45 <lambdabot> Not in scope: `argument'
03:35:58 <lilac> Peaker: do you really use result rather than fmap?
03:36:20 <luqui> this is highly relevant to the present discussion actually
03:36:20 <Peaker> lilac: result can be fmap
03:36:22 <lilac> (just curious because i'd always use fmap myself)
03:36:31 <luqui> http://sigfpe.blogspot.com/2008/11/some-thoughts-on-reasoning-and-monads.html
03:36:33 <lambdabot> Title: A Neighborhood of Infinity: Some thoughts on reasoning and monads, http://tinyurl.com/67z4mz
03:37:09 <Peaker> @type let argument f = (. f) ; result f = (f .) in \f g -> result f . argument g
03:37:10 <lambdabot> forall c a b c1. (c1 -> c) -> (a -> b) -> (b -> c1) -> a -> c
03:38:00 <luqui> BACKSLASH?  Let's don't be silly.
03:38:03 <Peaker> lilac, luqui: "result" and "argument" can be general in referring to the Functor as a computation, but still apply to all functors
03:38:22 <luqui> Peaker, argument referring to cofunctors
03:38:31 <Peaker> luqui: oops, yes
03:39:07 <lilac> Peaker: i would be disappointed if 'result :: Functor f => (a -> b) -> f a -> f b'
03:39:19 <Peaker> lilac: why? result = fmap
03:39:26 <lilac> Peaker: operationally, yes
03:39:35 <quicksilver> Axman6: yes, but you have to prepared to assume something.
03:39:37 <mmorrow> sjanssen: that breadth first numbering problem is a bitch. i've gotta dig up that paper...
03:39:44 <Peaker> lilac: its just for clarity, if you make it specific, you lose generality
03:39:50 <lilac> but the reason to have result, second, map, etc. instead of just fmap is surely (1) to make errors better and (2) for clarity
03:39:56 <Axman6> quicksilver: hmm?
03:40:00 <quicksilver> Axman6: otherwise any code which uses 'putStrLn' is unclear, because people might not know what putStrLn does.
03:40:01 <lilac> and you lose both  of those if you use the more general type signature
03:40:20 <quicksilver> Axman6: you said you like to write code other people can read; I'm saying you have make a decision about what you expect them to know and what you don't.
03:40:45 <quicksilver> Axman6: if you think putStrLn falls on one side of the line and result/argument fall on the other, that's fair enough, but it's a choice.
03:40:48 <MyCatVerbs> lilac: perhaps also because it's not *entirely* fair to newbies to throw them in at the deep end of understanding typeclasses, no?
03:40:49 <Peaker> lilac: the name is for clarity, not the type :-)
03:40:52 <quicksilver> if result/argument catch ont hey might cross the line.
03:40:54 <lilac> if i see (result.second) f then i expect f to be applied to the snd of a pair returned by a function
03:41:05 <lilac> further, i want the type system to check that for me
03:41:10 <MyCatVerbs> lilac: remember that Haskell was standardized for pedagogical reasons, too. :)
03:41:14 <Peaker> lilac: why not s/function/computation
03:41:47 <lilac> Peaker: because there's fmap if i want to map on the result of a general computation
03:41:48 <MyCatVerbs> Peaker: because if he wanted computations thene he'd be writing (>>=) instead of (.). =)
03:42:15 <Axman6> quicksilver: well yess. but i try to write it in a way that anyone who knew what al the functions there that i didn't define (because i'm not going to go and write those out just so people can tell), without having to try and figure out 'ok, that goes in there, and i get this... now wtf do i have. wtf does (g .) . (. f) .((.).).k mean?'\
03:42:20 <Axman6> -s
03:42:30 <lilac> i quite like that the type system can prove that my code is clear as well as correct
03:42:37 <MyCatVerbs> Axman6: it means "someone's been masturbating with @pl again, dammit."
03:42:49 <Axman6> MyCatVerbs: exactly
03:43:08 <Peaker> lilac, MyCatVerbs: I think its more important to use the generic types (don't lose generality unless you must). We can have an example in mind and use deceivingly specific names for clarity of that example. I am not sure I am against that :)
03:43:10 <lilac> @unpl (g.) . (.f) . ((.).).k
03:43:11 <lambdabot> (\ l u -> g (\ d e -> k l (f u) (d e)))
03:43:14 <MyCatVerbs> Axman6: so you either a) feed it through @unpl or b) shoot them in the head.
03:43:22 <Axman6> i think that if you have to use more than one flip, and there's a (.) in there, you're doing something very wrong
03:43:26 <lilac> Peaker: if you want generic types, why not use fmap?
03:43:37 <luqui> though (f .) . (. g)  is a unfortunately common idiom
03:43:58 <lilac> Peaker: i guess i can't see any reason why you'd want your function's name to lie about its generality
03:43:59 <Axman6> @unpl (f .) . (. g)
03:43:59 <lambdabot> (\ e j -> f (e (g j)))
03:44:10 <Peaker> lilac: because (second.fmap.second  is more readable than fmap.fmap.fmap)
03:44:16 <opqdonut> heh
03:44:21 <luqui> less hillarious though
03:44:30 <Axman6> heh
03:44:36 <Peaker> lilac: I guess "second" loses generality compared to "fmap", but not useful generality.   (.) loses useful generality over "fmap" though
03:44:41 <lilac> Peaker: second is /specific/ in this case though
03:45:00 <opqdonut> about a year back people were playing around with transforming haskell expressions into "fmap fmap fmap fmap fmap fmap .... fmap x"
03:45:02 <lilac> in that it maps over the snd of a pair
03:45:18 <lilac> whereas a 'result' which maps over the snd of a pair is weird
03:45:26 <opqdonut> yep
03:45:34 <Peaker> lilac: right, being specific about the type of result that flows through a computation is much less limiting than being specific about the type of computation itself
03:45:35 <opqdonut> specific types ftw
03:45:37 <mmorrow> dolio: heh, nice fixit and fixit2
03:45:39 <opqdonut> they avoid bugs
03:46:31 <lilac> Peaker: the only Arrow that most code will use second with is (->) (as far as i'm aware). so for all practical purposes, second :: (a -> b) -> (x,a) -> (x,b).
03:46:58 <lilac> Peaker: i'm completely happy with second having that type signature (or the Arrow one). but i find it odd for @type result == @type fmap
03:47:06 <luqui> (fmap `fmap` fmap `fmap` fmap) succ [Just [1,2], Nothing, Just [3]]
03:47:13 <luqui> > (fmap `fmap` fmap `fmap` fmap) succ [Just [1,2], Nothing, Just [3]]
03:47:15 <lambdabot>   [Just [2,3],Nothing,Just [4]]
03:47:55 <Peaker> lilac: If we weren't stuck with a text editor, we could have our code editing UI show us specialization of the more general (and thus more confusing) types
03:48:19 <Peaker> lilac: and thus not have any disadvantage at all to using the most general types possible
03:48:19 <lilac> Peaker: we'd still be stuck with a computer interpreting our code. more specific types give better error messages.
03:48:24 <dolio> luqui: I was looking at Lawvere's thesis not too long ago, and he sort of argues that you can do more interesting talking about the structure of objects in category theory, because not everything is reduced to a single primitive structural relation like say, membership in set theory.
03:48:36 <jkff> > fmap (fmap (fmap succ)) [Just [1,2], Nothing, Just [3]]
03:48:37 <lambdabot>   [Just [2,3],Nothing,Just [4]]
03:48:40 <dolio> At least, I think that's the gist.
03:49:04 <opqdonut> :t fmap fmap
03:49:05 <opqdonut> :t fmap fmap fmap
03:49:06 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => f1 (a -> b) -> f1 (f a -> f b)
03:49:07 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
03:49:07 <opqdonut> :t fmap fmap fmap fmap
03:49:07 <Peaker> lilac: it could do error checking on specialized types before doing them on the generic types, perhaps (if you specify both a specific[for clarity] and a general type)
03:49:08 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
03:49:20 <luqui> dolio, hmm.  i'm not experienced in category theory... so I can't really comment
03:49:50 <Peaker> lilac: for example, you could start by writing a specifically-typed function, and ask the code UI to generalize it to use the most general combinators -- then it could keep around the specialized types it came from for error messages and a specific example
03:50:05 <jkff> :t iterate fmap
03:50:05 <lambdabot>     Occurs check: cannot construct the infinite type: a = f a
03:50:05 <lambdabot>       Expected type: (a -> b) -> a -> b
03:50:05 <lambdabot>       Inferred type: (a -> b) -> f a -> f b
03:50:17 <luqui> Peaker, I don't think you can do that
03:50:17 <jkff> That's quite a pity.
03:50:24 <Peaker> luqui: why not?
03:50:28 <lilac> Peaker: that is not the language and environment we use today, so seems somewhat irrelevant in a discussion of the practicality of specific vs general
03:50:29 <luqui> Peaker, there are a lot of ways to generalize, using instances of various structures
03:50:47 <luqui> Peaker, eg do you change . to fmap or . to Control.Category..
03:50:57 <Peaker> lilac: The question is whether the extra learning curve to be unconfused by fmap rather than (.) is not outweighed by the benefits
03:51:13 <lilac> i don't follow
03:51:29 <luqui> lilac, I hope it is soon though
03:51:29 <Peaker> lilac: the downside of being general is confusion, the upside is that the code is more re-usable
03:51:33 <luqui> text is showing its age
03:51:50 <lilac> luqui: i completely agree. i like the look of the epigram emacs thing.
03:51:54 <Peaker> lilac: which outweighs which?
03:52:01 <lilac> Peaker: neither.
03:52:11 <Peaker> luqui: I think those 2 can be shown to be equivalent?
03:52:13 <lilac> Peaker: be general where generality is warranted, and be specific where clarity is needed
03:52:44 <luqui> Peaker, in the case of (->) yes, but are you generalzing to functors or are you generalizing to categorical composition?
03:52:49 <lilac> Peaker: but if you're mapping over the second of a pair returned by a function, (result.second) /will/ be clearer than (fmap fmap fmap)
03:53:04 <Peaker> lilac: clarity is always needed, and generality is almost always needed, at least if we can squeeze enough generality from the various positions (the code is only as general as its weakest link, currently we have many weak links disabling the benefits)
03:53:20 <luqui> Peaker, Category doesn't necessarily come with a functor instance on its right argument.
03:53:20 <lilac> Peaker: generality is rarely needed in my experience
03:53:37 <Peaker> lilac: its never "needed", you can always duplicate code :)
03:53:49 <quicksilver> luqui: text has been showing its age for at least 20 years but it's SO HARD to come up with something better.
03:53:51 <Peaker> lilac: that's the general solution to software problems today :)
03:53:59 <lilac> Peaker: sure, but usually you have a pretty well-constrained type
03:54:01 <luqui> quicksilver, my next project :-)
03:54:07 <lilac> Peaker: so there's only so much generality that makes sense
03:54:12 <quicksilver> luqui: text has so many nice properties which are easily lost as you try something more sophisticated.
03:54:18 <luqui> once there is a good gui framework to deal with.  that's why I'm working on frp currently.
03:54:27 <luqui> quicksilver... for example?
03:54:33 <luqui> discussion on email groups I can see
03:54:51 <lilac> Peaker: anyway i must be off now, and i don't see us agreeing on this :)
03:54:55 <Peaker> lilac: My intuition is that we have so many combinators that weren't yet generalized, that you will lose generality on some combinator somewhere, negating the entire benefit
03:55:09 <Peaker> lilac: and that once those are also generalized, we'll actually start seeing benefits of reusability
03:55:38 <Peaker> lilac: ok, see you around, hope you can help solve OpenAL issues some time later :)
03:55:59 <lilac> Peaker: i suggest you look through the 'reactive' source code. lots of uses of fmap there. count how many need to be fmap and how many could be more specific with no loss of generality but perhaps improved clarity. :)
03:56:04 <luqui> Peaker, agree with you there.  to me fmap isn't a big deal until you get all the way up to a free monad.
03:56:26 <Peaker> lilac: you're only making my last point stronger -- they are fmap but have a specific type because other combinators are specializing the types :)
03:56:54 <lilac> Peaker: no, the type is specific because of the nature of teh reactive types themselves
03:56:56 <quicksilver> luqui: the ability to easily search, easily create it with other tools
03:57:05 <quicksilver> luqui: its ubiquitous use in pipelines
03:57:15 <Peaker> lilac: you have to generalize whole functions (and probably more) before you get any benefit, so its easy to miss that there's any benefit at all. And perhaps we are even lacking generic combinators to get that benefit as of yet
03:57:15 * luqui doesn't remember the last time he created haskell with anything but vim
03:57:23 <quicksilver> luqui: interoperability with simple composable tools like grep and find
03:57:41 <lilac> Peaker: i'd be interested in specifics of this -- cases you think can be generalized further
03:57:44 <Peaker> lilac: When you come back, lets go over specific examples of those
03:57:49 <luqui> quicksilver, yes, but those are relics of the text age as well.  a graphical system would of course be TV based
03:57:54 <lilac> Peaker: i can certainly believe they exist and i'd like to see them for my own benefit :)
03:58:27 <Peaker> lilac: the type of Image in FieldTrip.Image is (R,R) -> Bool, iirc, instead of an arrow type, is one example I remember
03:58:42 <quicksilver> luqui: transport to distant planets will of course be based on faster-than-light matter transference.
03:59:06 <luqui> quicksilver, haha
03:59:09 <dancor> are we talking about the benefits of using text to write source code?  giving variables names which are words seems pretty good to me
03:59:34 <quicksilver> luqui: the point I'm making is there is a large cooperating ecosystem which needs replacing.
03:59:53 <quicksilver> luqui: replacing one part (The format of source code) is not going to help without an entire ecosystem upgrade.
04:00:13 <luqui> quicksilver, ah.  agreed.
04:00:21 <luqui> I'm interested in upgrading the ecosystem
04:00:23 <Peaker> I think there's tons of confusion about "text-based coding".  There are several distinct issues:  A) How the code is represented in the editor  B) How the code is presented to the user.     When people hate text and want to replace that, they mainly refer to A,  everyone agrees B should still be using text, even if it also uses some graphical elements like tables/etc
04:00:29 <luqui> from the perspective that nobody in the world uses anything but haskell
04:00:29 <quicksilver> luqui: which makes it a large job. Nonetheless I wish you luck ;)
04:00:44 <luqui> I'm doing it little bits at a time...
04:00:48 <Peaker> Very few people think we should change the presentation syntax to flow charts and imagery.
04:00:50 <quicksilver> Peaker: c) how it's stored on the filesystem
04:00:50 <dancor> like if my variable is called horse it's all good and we to have a picture of a horse instead, if you've got one on hand
04:01:10 <dancor> s/we to/well to
04:01:21 <Peaker> quicksilver: Yeah, though C matters less, probably, as serializing to/fro anything is easy
04:01:30 <luqui> Peaker, I don't agree with B.
04:01:37 <quicksilver> Peaker: it matters from the perspective of integration with grep.
04:01:43 <quicksilver> Peaker: and other external tools.
04:02:05 <luqui> Peaker, well sortof.  I don't have anything better for the small scales.  much can be improved on large scales.
04:02:11 <Peaker> luqui: do you think that any good code presentation will lack text completely?  Surely you agree the presentation will be a combination of text and non-text
04:02:28 <luqui> yeah I do
04:02:28 <Peaker> quicksilver: the existing tools are overrated, IMO
04:02:36 <Peaker> quicksilver: not that much work to get a better eco-system
04:02:41 <luqui> overrated _but_ existant!
04:02:56 <Peaker> grep sucks for code searches!
04:03:04 <Peaker> we use it not because its great, but because there's nothing better
04:03:27 <Peaker> well, some use better things like cscope/etc, but those are sucky too, because of the difficulties in keeping the text and db in sync
04:03:32 <luqui> Peaker, (by "yeah I do" I meant "yeah I agree")
04:03:42 <dancor> if you tokenize source one token per line you can grep that
04:03:48 <dancor> and it's kind of cool
04:03:54 <quicksilver> Peaker: it may not be great, but it's scalable and compositional
04:03:56 <dancor> and it works without a lot of effort
04:04:01 <quicksilver> Peaker: you can layer other tools on top and so on.
04:04:03 <Peaker> quicksilver: its not very scalable at all
04:04:10 <Peaker> quicksilver: grep on large source trees takes a long while
04:04:18 <luqui> whaaat?
04:04:19 <quicksilver> really?
04:04:24 <quicksilver> if you have a computer from the 70s, perhaps.
04:04:30 <dancor> i do: token-type<tab>token-value<tab>row<tab>col
04:04:32 <quicksilver> I can grep gigabytes in under a second.
04:04:38 <luqui> grep -rI '...'  never takes more than a second
04:04:44 <luqui> as long as I put that capital I there
04:04:45 <Peaker> quicksilver: It takes about 10-30 seconds to grep stuff in my work project
04:05:02 <dancor> visual grep would be tough
04:05:05 <Peaker> quicksilver: maybe the IT configuration in terms of drive locality/etc is not perfect...
04:05:11 <Peaker> dancor: the opposite of non-textual is _not_ visual
04:05:22 <Peaker> s/non-textual/textual
04:05:34 <quicksilver> Peaker: yeah, sounds like a networked filesystem latency issue ;)
04:05:36 <Peaker> I think that's the main source of confusion about it, people see a false dichotomy between representing code as text, and as visual flow charts or such
04:05:39 <luqui> who's looking for an opposite?
04:05:58 <dancor> i admit lack of creativity, but i can't think of any non-textual grep that wouldn't be hard
04:06:05 <Peaker> luqui: when you tell people serializing code to textual syntax and working with that is a bad idea, they almost always figure the alternative is working with MS paint
04:06:13 <Peaker> dancor: AST grep?
04:06:25 <Peaker> dancor: instead of editing concrete string-syntax, you work with abstract syntax
04:06:28 <luqui> Peaker, a la hxt arrows
04:06:40 <dancor> i'm down with that
04:06:43 <dancor> metacoding++
04:06:44 <Peaker> actually its ASG, not AST, the reason we use trees and not graphs is because text serializes trees, not graphs
04:07:02 <quicksilver> current approaches to searching structured date, like XQuery, are not desperately easy to use
04:07:09 <quicksilver> XPath
04:07:12 <Peaker> if we disconnect from text, we can work with Abstract Syntax Graphs, where links are used rather than names (names still exist, but they are comments, and renames don't break links)
04:07:14 <quicksilver> whatever they're called.
04:07:24 <quicksilver> maybe that's partly a question of getting used to it though.
04:07:26 <luqui> Peaker, you're in #haskell; trees and graphs are almost the same :-)
04:07:31 <mapreduce> Peaker: So use s-expressions and write a graphical backend if you need to.
04:07:37 <Peaker> luqui: trees are subsets of graphs
04:07:38 <dancor> i had trouble even making my todo list into a graph instead of a tree
04:07:42 <dancor> everything's harder
04:07:46 <Peaker> mapreduce: s-expressions are trees, I want graphs
04:07:49 <luqui> Peaker, if you want to be all stiff about it
04:07:53 <mapreduce> Peaker: IDs.
04:08:06 <dancor> but i did try and probably will again
04:08:14 <dancor> it's not like #1 on the meta-todo-list tho
04:08:28 <dancor> there i go ordering my items again
04:08:31 <quicksilver> I don't think the different between trees and graphs is important for this discussion. I think that argument is dull ;)
04:08:35 <luqui> the problem with graphs is that they are not locally compositional
04:08:42 <Peaker> luqui, mapreduce: its an important point.  We're all actually encoding code graphs on top of trees, so we invent complicated notions of namespacing and names to do this, and then our code is fragile to merges/etc because name changing breaks links.  We should separate naming (which is really commenting) from linking (which is the code structure itself)
04:09:00 <mapreduce> Or we should organise the code as trees.
04:09:07 <Peaker> quicksilver: see above why I do think its an important point. The fact we encode graphs into trees led to names and namespace complexities
04:09:15 <luqui> Peaker, yes yes yes!  that is my Udon project.
04:09:29 <Peaker> mapreduce: we already do, because text can only encode trees, not graphs, but then we need namespaces and names :(
04:09:52 * luqui doesn't see how text encodes trees
04:09:59 <luqui> other than it being able to be printed on paper
04:10:01 <Peaker> luqui: via openers/closers
04:10:13 <luqui> it can encode graphs via names
04:10:20 <Peaker> luqui: yes, but openers/closers don't suck :)
04:10:36 <luqui> maybe you should reassess that in the context of this argument
04:11:03 <dancor> trees involve picking 'most significant divisions' (do you have ~/music/mp3 or ~/mp3/music) which is sometimes good to do
04:11:04 <mapreduce> Peaker: Does =A3 * B3 suck in Excel?
04:11:23 <Peaker> luqui: openers/closers don't easily break when merging work, for example, names do.  Openers/closers don't cause random access to code to be slow/painful (links could be O(1) dereference, a name requires searching)
04:11:34 <Peaker> mapreduce: A3 and B3 are references/links, not names
04:11:39 <luqui> Peaker, s/don't/don't always/
04:11:46 <dancor> you still get O(1) with like cscope..
04:11:54 <mapreduce> Peaker: What's the difference between a reference and a name?
04:11:56 <Peaker> mapreduce: and yes, they kind of suck, need to be corrected when things move around
04:12:12 <luqui> mapreduce, names are in limited supply
04:12:15 <Peaker> mapreduce: a reference is O(1) to dereference
04:12:26 <mapreduce> luqui: Hardly.
04:12:28 <Peaker> dancor: cscope re-parses the tree into a graph, but has to keep doing that
04:12:45 <mapreduce> > let a3 = 4 in let b3 = 5 in a3 + b3
04:12:45 <Peaker> mapreduce: it also doesn't braek when things are renamed(comment changed) and moved around
04:12:46 <lambdabot>   9
04:13:03 <Peaker> brb
04:13:03 <mapreduce> Peaker: Do you know how Smalltalks do renames?
04:13:09 <Peaker> mapreduce: how?
04:13:13 <luqui> mapreduce, okay, I suppose more appropriately, names know they are supposed to be meaningful
04:13:18 <mapreduce> They make the original method a delegate to the new one.
04:13:28 <luqui> mapreduce, and yeah they are in limited supply.  by which I mean "import Data.Tree"
04:13:33 <luqui> which version are you talking about?
04:13:35 <mapreduce> Then the existing code doesn't have to be updated.  Once it is though, the original name can disappear.
04:13:38 <ivanm> mapreduce: using M-%? ;-)
04:13:43 <luqui> can you specify a range of versions
04:13:53 <luqui> what about an algorithm to determine if you can use a new version?
04:14:28 <mapreduce> If you can't use a new version, then you fix it so that you can. :)
04:14:45 <luqui> mapreduce, what if your fix breaks an old version of something else?
04:15:03 <mapreduce> Then you edit it so that it doesn't.
04:15:04 <luqui> Data.Tree is not a thing, it's a whole complex class of things
04:15:20 <luqui> a reference refers to one thing.
04:16:06 <mapreduce> s-expressions in CL can have IDs so you can refer to them again.  I forget the syntax.
04:16:09 <luqui> however, I doubt I have the skill to convince someone who doesn't already agree that the whole hierarchical library naming package thing is horribly wrong and broken
04:16:31 <mapreduce> Let's pretend it's like: (* #234(+ x y) #234)
04:16:43 <luqui> mapreduce, is that compositional?
04:16:53 <luqui> i.e. are these names scoped or global?
04:17:05 <luqui> because if they're global, composing your software with someone elses could cause a conflict
04:17:27 <mapreduce> I don't know, but I would guess scoped.
04:17:54 <luqui> okay that's nice.  how to you refer to an S-expression in another module?
04:18:27 * mapreduce looks up the details of this.
04:18:55 <luqui> whatever your answer, I have the next rhetorical question prepared =P
04:19:06 <luqui> how to you refer to a module in another project?
04:21:18 <quicksilver> I actually don't dislike the Java package style name space organisation.
04:21:24 <quicksilver> You've got to namespace somehow.
04:21:34 <quicksilver> unless luqui has a really clever alternative in mind.
04:22:28 <luqui> quicksilver, i don't know about its cleverness
04:22:33 <luqui> but my answer is "no you don't"
04:22:45 <luqui> just refer to a package by reference rather than by name
04:22:56 <luqui> (using a UUID for a package + version)
04:23:53 <luqui> (for practicality, you "import" a package by reference into your namespace, the same way you import modules qualified.  but that is a temporary detail until we are liberated from text)
04:24:01 <quicksilver> well, UUIDs are extremely ugly so presumably there would be a human-readable name too?
04:24:41 <luqui> my goal in Udon is to keep the UUIDs perpetually hidden, never viewable by anyone but network and library clients
04:25:09 <quicksilver> right.
04:25:19 <mapreduce> luqui: From what I can see, it's scoped, so you can't use it outside the s-exp it's declared in.
04:25:21 <quicksilver> so then you've just pushed the namespace problem into the human readable name.
04:25:38 <quicksilver> what happens if two people publish a package by the same human readable name
04:25:49 <quicksilver> (although they have different UUIDs so the computer doesn't really get confused, the users will)
04:25:51 <mapreduce> luqui: There is a programming language where copy and paste is the way you reuse code.
04:25:52 <luqui> you import one by one name, and the other by another
04:25:59 <mapreduce> And I'm not being silly about PHP or something.
04:26:00 <luqui> just like we import modules qualified...
04:26:03 <quicksilver> but how do I, the human, know which is which?
04:26:17 <mapreduce> luqui: The copies are linked to each other, thus forming a graph.
04:26:19 <luqui> because you said so.
04:26:22 <Peaker> luqui: I agree that namespace hierarchies (including Haskell's module one) suck :)
04:26:25 <quicksilver> if they're both just identified by the name 'RoseTree'
04:26:37 <quicksilver> and one was written by luqui and one by johnmeacham
04:26:40 <quicksilver> and I have them both installed
04:26:45 <quicksilver> how am I supposed to tell them apaart?
04:26:52 <quicksilver> forall that they have different UUIDs
04:26:53 <Peaker> quicksilver: references by links rather than by name?
04:26:53 <luqui> (in the package config file -- which isn't so much a file as a data structure)
04:27:15 <mapreduce> luqui: Here it is: http://subtextual.org/
04:27:16 <lambdabot> Title: Subtext home
04:27:17 <luqui> so each of us would publish an "external reference" to the package on our websites
04:27:33 <luqui> you would enter that and give it a name to call it by
04:27:37 <quicksilver> so you're just using website URLs as names, then.
04:27:45 <quicksilver> instead of the java convention of domain names
04:27:50 <quicksilver> that'st he same thign basically ;)
04:28:03 <luqui> quicksilver, sure, but as soon as it goes into the package config it becomes a UUID, changable nevermore
04:28:06 <Peaker> for uniqueness, we have UUID's
04:28:13 <luqui> even if the website goes down or moves or ...
04:29:02 <luqui> you have names to refer to objects, but with _early binding_; we resolve the names into actual references to objects as soon as possible
04:29:28 <luqui> whereas java is late binding... it stays a name until you compile.
04:29:38 <quicksilver> that makes sense, yes.
04:30:21 <luqui> mapreduce, I've seen subtextual.  I like it for the most part.  Seems very apt for certain kinds of things; i'm not so sure about general purpose programming
04:30:37 <luqui> (I'm not sure it won't work, I just can't play with it because the damn guy doesn't publish any software)
04:31:24 <ksf> in fact, the vm op invokevirtual takes an object reference and a "string description" of the method name and signature as argument.
04:31:42 <quicksilver> I find subtextual interesting but not convincing.
04:31:47 <ksf> or, actually, an object, it's on the stack.
04:31:55 <quicksilver> he talks the talk, but does the software actually walk the walk?
04:31:57 <ksf> the op doesn't care about whether it's a reference.
04:33:02 <Axman6> @hoogle Complex
04:33:02 <lambdabot> module Data.Complex
04:33:02 <lambdabot> Data.Complex data RealFloat a => Complex a
04:33:02 <lambdabot> package storable-complex
04:34:17 <luqui> quicksilver, the demo was cool looking, but after asking him for the source he said it was very buggy
04:34:25 <luqui> and not really fit for others' eyes
04:34:52 <quicksilver> luqui: vaporware. don't you just love it?
04:35:10 <quicksilver> luqui: blatantly he produce the whole thing in macromedia flash. It doesn't even exist :P
04:35:10 <luqui> sigh
04:35:17 <luqui> haha
04:36:09 <luqui> a lot of the real-timeness of it was very intruiguing.  seems like it would be pleasing to work wit
04:36:28 <quicksilver> it's double-exponential in size of code base.
04:36:37 <Axman6> :t map const
04:36:38 <lambdabot> forall a b. [a] -> [b -> a]
04:36:54 <quicksilver> (I'm trolling, but my point is that there are large gaps between having a cute idea and it actually being feasible)
04:36:56 <luqui> what?
04:37:02 <luqui> oh
04:37:16 <quicksilver> the realtimeness may easily depend on all kinds of assumptions which don't work in practice
04:37:36 <luqui> the automatic case coverage thing was the only iffy part to me
04:37:40 <luqui> the rest seemed straightforward
04:37:47 <mapreduce> luqui: heh.  I thought it seemed interesting but I think you could easily build it on top of s-expressions with managed IDs.
04:38:44 <luqui> mapreduce, I'm not quite sure what you're talking about
04:38:58 <luqui> resolve those pronoun references
04:39:19 <mapreduce> it = Subtextual
04:40:15 <Axman6> :t join const
04:40:16 <lambdabot> forall a. a -> a
04:40:20 <luqui> mapreduce, "easily"  it's a GUI, I don't think the algorithmic or representation challenges are the hard part
04:41:27 <luqui> :t join const . fix . const
04:41:29 <lambdabot> forall a. a -> a
04:41:57 <luqui> :t join . fix . const $ const
04:41:59 <lambdabot> forall a. a -> a
04:42:31 <luqui> seems every well typed expression involving those is the identity function :-)
04:44:04 <mapreduce> :t join . fix . const
04:44:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
04:45:45 <luqui> :t fix $ join (.)
04:45:47 <lambdabot> forall b. b -> b
04:48:06 <luqui> :t fix (join (.) . const . const (fix . const) $ join const)
04:48:08 <lambdabot> forall a. a -> a
04:48:14 <luqui> okay, time for bed.  =)
04:48:14 <ksf> what we call "now" is merely the least fixed point of a stateful function.
04:48:44 <quicksilver> ksf: sometimes you sounds a bit like a bored chatbot trying to start a conversation :P
04:48:50 <ksf> actually, there's only one.
04:49:06 <quicksilver> @vixen is ksf your brother?
04:49:07 <lambdabot> let's don't talk about that
04:49:12 <quicksilver> sounds like a confession to me.
04:49:35 <ksf> so i fail the turing test?
04:50:45 <quicksilver> at the moment yes ;) normally you don't.
04:50:58 <ksf> what does that mean to you?
04:51:28 <ksf> does it make you anxious?
04:51:34 <ksf> does it make you feel bad?
04:51:37 <ksf> you can tell me.
04:51:39 <SamB_XP> ksf: I hate you!
04:52:23 * SamB_XP was hoping to be therapized
04:52:58 <blackh> I like this language. The code practically writes itself!
04:53:51 <SamB_XP> blackh: well, after you write the types I guess
04:54:00 <ksf> SamB_XP, is that a hypothesis, eternal fact or fleeting feeling?
04:54:19 <SamB_XP> ksf: an attempt to provoke a reaction ;-P
04:54:25 <ksf> how does your hate and hope correlate?
04:54:56 <quicksilver> blackh: in soviet russia, haskell writes YOU
04:55:12 <SamB_XP> they are both actually just for amusement
04:55:16 <blackh> rofl
04:55:50 <SamB_XP> quicksilver: shouldn't it be ... in soviet russia, you practically write yourself ?
04:56:15 <quicksilver> possibly.
04:56:21 <ksf> in soviet russia, you have to queue up to be written.
04:56:30 <SamB_XP> lol
04:58:10 <SamB_XP> my sister made a cake yesterday ... the top layer cracked, so she's trying to pass it off as ancient ...
04:58:25 * quicksilver wonders if there is much of a market for ancient cake.
04:58:35 <chrisdone> there is sure to be a fetish for it
04:58:54 <Axman6> what function does '(a -> b -> c) -> (a -> b) -> a -> c' relate to? supposed to be 'the S combinator'
04:59:20 <earthy> why does 'ancient cake' remind me of hundred-year egg?
04:59:46 <Axman6> reminds me of cake farts >_< (if you don't know what i'm on about, you should feel lucky)
05:00:05 <Axman6> stupid internet
05:00:08 <earthy> ewww...
05:00:09 <earthy> yah
05:00:15 <SamB_XP> lol
05:00:33 <chrisdone> imagine it like tubes where they certain colours that map to the types. you fit them together. it takes an a, feeds it to the (a -> b), then gives the a and the result of the (a -> b) to the (a -> b -> c), and returns that result ._.
05:01:12 <SamB_XP> what does that have to do with cake ?
05:01:21 <chrisdone> Sxyz → xz(yz)
05:01:41 <Axman6> chrisdone: yeah, i get that, just not what function it's supposed to relate to in haskell. hoogle gives `on` as the closest function
05:01:44 <Axman6> :t on
05:01:45 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
05:01:46 <chrisdone> see how 'x' here is the (a -> b -> c)
05:01:52 <chrisdone> ohh
05:02:14 <chrisdone> :t const on
05:02:16 <lambdabot> forall b c a b1. b1 -> (b -> b -> c) -> (a -> b) -> a -> a -> c
05:02:29 <chrisdone> nah
05:03:15 <chrisdone> off to glasgow to meet a fellow haskeller now, yaaaay
05:03:15 <byorgey> Axman6: it's ap for the ((->) e) monad
05:03:16 <chrisdone> bye
05:03:19 <byorgey> @type ap
05:03:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
05:03:34 <byorgey> replace each m with  e ->
05:03:46 <byorgey> (e -> a -> b) -> (e -> a) -> e -> b
05:04:01 <byorgey> voila!
05:04:34 * earthy always thought of S as  the choice operator
05:04:51 <earthy> take K to be 'true', K* (\xy->y) to be 'false'
05:05:09 <earthy> then S is analogous to 'if'
05:05:19 <Axman6> byorgey: ah thank you
05:05:28 <earthy> IIRC
05:05:52 <byorgey> earthy: sort of, but it chooses between y and yz, not y and z
05:06:02 <earthy> byorgey: true
05:06:41 <byorgey> er, I meant z and yz
05:07:47 <byorgey> Axman6: note also that K  is 'return' for the ((->) e) monad
05:08:01 <byorgey> @src (->) return
05:08:01 <lambdabot> return = const
05:08:02 <Axman6> yeah, that makes sense
05:08:13 <Axman6> i'm watching http://au.youtube.com/watch?v=h0OkptwfX4g
05:08:14 <lambdabot> Title: YouTube - Advanced Topics in Programming Languages Series:...
05:09:11 <byorgey> yeah, that's a fun one =)
05:11:02 <Axman6> though, i was trying to do some of the Djinn stuff, and i was wondering how you're supposed to define the type C a = (a -> Ans) -> Ans thing in Djinn
05:12:16 <byorgey> Axman6: hm, at what position in the video is this?
05:12:30 <Axman6> 23 mins ish
05:13:41 <BeelsebobWork> @seen Cale
05:13:41 <lambdabot> Cale is in #haskell, #haskell-overflow and #ghc. I last heard Cale speak 2h 47m 32s ago.
05:13:45 <BeelsebobWork> :/
05:14:36 <vegai> No instance for (Stream String)
05:14:39 <vegai> ugh, why not
05:17:41 <vegai> oh, perhaps it shouldn't.
05:19:01 <Axman6> @src ap
05:19:01 <lambdabot> ap = liftM2 id
05:19:10 <Axman6> @src liftM2
05:19:10 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
05:19:26 <Axman6> :t ap
05:19:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
05:22:08 <EvilTerran> ap = liftM2 ($), if you prefer
05:23:08 <Axman6> i do, thanks :)
05:23:26 <lilac> K and S are pure and <*> for the Applicative ((->) a) instance, right?
05:23:47 <EvilTerran> yes
05:23:55 <EvilTerran> you can tell by the types :)
05:24:16 <lilac> indeed. does that mean that we can somehow use Applicative as a model of computation?
05:24:36 * lilac is not quite sure exactly what he's asking
05:24:53 * EvilTerran neither :P
05:24:57 <Eduard_Munteanu> Hi. I want to multiply a Double with an Int. How should I typecast the Int to a Double so the compiler doesn't bail out?
05:25:17 <EvilTerran> ?type fromIntegral
05:25:18 <byorgey> @quote fromIntegral
05:25:18 <lambdabot> forall a b. (Num b, Integral a) => a -> b
05:25:19 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
05:25:22 <byorgey> =)
05:25:35 <Eduard_Munteanu> Thanks.
05:25:45 <byorgey> and welcome, Eduard_Munteanu
05:26:00 <mlesniak> In one of SPJ paper is a function getClockTime, but hoogle does not find it. Any ideas a) why hoogle does not find it and b) where to find it?
05:26:07 <Eduard_Munteanu> Yes, thanks, I just got into Haskell recently.
05:26:15 <lilac> EvilTerran: i think i mean, every term in \-calculus can be expressed in terms of K and S. does that mean that every term can be expressed in terms of pure and <*> for ((->) a)?
05:26:17 <byorgey> Eduard_Munteanu: fromIntegral can convert any Integral type (such as Int or Integer) into any other numeric type.
05:26:25 <lilac> i think the answer is no, due to a restriction on infinite types
05:26:27 <quicksilver> mlesniak: try getCurrentTime
05:26:30 <Axman6> mlesniak: i think you want Data.Time
05:26:37 <Axman6> @hoogle Data.Time.
05:26:37 <lambdabot> Parse error:
05:26:37 <lambdabot>   --count=20 Data.Time.
05:26:37 <lambdabot>                  ^
05:26:39 <Axman6> @hoogle Data.Time
05:26:39 <lambdabot> module Data.Time
05:26:39 <lambdabot> package time
05:26:39 <lambdabot> Data.Time.LocalTime data TimeOfDay
05:26:39 <mlesniak> quicksilver: Axman6: Thanks
05:26:53 <EvilTerran> lilac, indeed, you'd be restricted to STLC terms
05:26:58 <Axman6> bah, oh well, hoping for a list. but you can find out what it has easily enough
05:30:48 <EvilTerran> lilac, however, you can embed the untyped \calc into haskell with a type like (Mu Endo)
05:31:38 <lilac> hmm. can you actually do anything useful with that?
05:31:41 <EvilTerran> no :P
05:32:48 <EvilTerran> but you can with, say, Mu (Either a `O` Endo)
05:33:30 <EvilTerran> (~~ data Term a = Val a | Fn (Term a -> Term a))
05:33:49 <opqdonut> ah nice
05:33:58 <lilac> you presumably don't even need that? isn't Mu (Maybe `O` Endo) sufficient? :)
05:34:33 <opqdonut> well no, not if you really want to accomplish something
05:35:38 <Baughn> ..so, cache coherency just isn't an issue with multiple processes using the same data in haskell, is it?
05:36:01 <byorgey> lilac: that's just isomorphic to   data Term = Nothing | Fn (Term -> Term), isn't it?
05:36:31 <quicksilver> Baughn: cache coherency only matters on writes, and multiple haskell processes don't normally try to write to the same place.
05:36:40 <quicksilver> Baughn: GHC deliberately gives threads separate nurseries
05:36:55 <EvilTerran> byorgey, i guess, with that, you could actually distinguish an arbitrary number of values, but it'd be really kinda fiddly
05:37:00 <quicksilver> (so that newly allocate transient objects aren't fighting over cache)
05:37:05 <byorgey> heh, I guess you're right
05:37:18 <Eduard_Munteanu> And how should Double be converted to Int? I tried fromRational, but it's incompatible.
05:37:30 <byorgey> Eduard_Munteanu: you can use   round, floor, or ceiling
05:37:31 <opqdonut> :t floor
05:37:33 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
05:37:37 <EvilTerran> "iterate (Fn . const) Nothing"
05:37:41 <byorgey> depending on what you want
05:37:53 <Eduard_Munteanu> Thanks, I thought those returned Doubles.
05:38:07 <byorgey> EvilTerran: right.  And then you Godel-encode everything, and...
05:38:31 <Baughn> quicksilver: Thought so. Well, that's very convenient. :)
05:50:12 <mlesniak> Currently I'm reading the tutorial on parallel and concurrent programming in haskell from SPJ but do not get any speedup in the example (even when using the f `par` (e `pseq` (e+f))). I remember to have read something about problems with ghc but can't remember where. Any hints?
05:50:24 <mlesniak> (the fib + eulerSum example)
05:50:43 <blackh> I had a play myself for an evening.
05:50:50 <byorgey> mlesniak: what version of GHC are you using?
05:51:02 <blackh> I found it was rather tricky to get the granularity right with `par`
05:51:10 <mlesniak> byorgey: 6.10.1
05:51:48 <byorgey> mlesniak: IIRC there's a bug in GHC 6.10.1 where if you only have one spark it won't fire up another thread, or something like that.  I don't know if that's the problem you're experiencing.
05:51:50 <mlesniak> blackh: Probably. But this is were the tutorial starts and I think it's a good starting point (in theory)
05:52:08 <mlesniak> byorgey: at least this would explain the behaviour I'm observing
05:52:32 <byorgey> ok, that's probably it then
05:52:34 <blackh> I tried to do it with an anagram generator, but it spent almost all of its time allocating memory. :)
05:52:49 <byorgey> apparently this will be fixed in 6.10.2
05:53:07 <mlesniak> byorgey: any idea when it will be released? i.e. any time soon or in a few month... ?
05:53:15 <byorgey> mlesniak: no idea.
05:56:49 <maltem> didn't they plan periodic releases for ghc now?
05:57:09 <maltem> I think there was some rumour of that sort
05:57:45 <maltem> or maybe I'm confusing with darcs
05:57:50 <Eduard_Munteanu> Hooray, just wrote an integration function in Haskell. Quite elegant.
05:58:07 <vixey> numerical integration?
05:58:27 <Eduard_Munteanu> vixey, yes, it takes a function, the limits of integration and step size
05:58:31 <vixey> cool
05:58:48 <tomh> hey how do you escape chars in strings for haskell?
05:58:55 <blackh> \
05:58:56 <byorgey> maltem: you may also be confusing it with the Haskell language standard
05:59:01 <tomh> somehow it still displays \ everywhere
05:59:08 <byorgey> for which there will now be regular periodic updates.
05:59:10 <ogex> Eduard_Munteanu, what kind of functions does it get?
05:59:18 <blackh> tomh: paste what you've done
05:59:20 <vixey> tomh: hhat's because haskell escapes too
05:59:28 <byorgey> Eduard_Munteanu: congrats!
05:59:32 <Eduard_Munteanu> ogex, Double -> Double
05:59:39 <Eduard_Munteanu> Thanks
06:00:02 <tomh> let me make a small testcase
06:00:05 <byorgey> tomh: you mean you want to print out a string without it displaying escape \ chars ?
06:00:11 <tomh> yes
06:00:17 <byorgey> ok, then you should use 'putStr'
06:00:20 <byorgey> or putStrLn
06:00:46 <tomh> ok thanks
06:00:48 <byorgey> if you 'show' a string (or just enter an expression at the ghci prompt that evaluates to a String) it will show it with escapes
06:01:14 <blackh> Also 'show' puts quotes around it.
06:01:18 <byorgey> the point is to print a representation which is valid Haskell syntax for itself
06:01:20 <byorgey> right.
06:01:59 <byorgey> whereas  putStr(Ln) are for doing actual output, rather than just displaying the value of a String.
06:02:23 <tomh> i see ok
06:02:48 <Eduard_Munteanu> Here it is, http://pastebin.com/d5086be1c
06:03:05 <alar> can anybody help me with MPTC?
06:03:06 <alar> I want to define class "collection that collects keys 'k' with values 'v'" and state that "Data.Map.Map k [v] is an instance of it"
06:03:15 <Eduard_Munteanu> well, I wrote it how I knew best, it doesn't mean it's really the best way.
06:03:36 <alar> can't figure what lines with "class MyColl" and "instance MyColl" should look like
06:03:48 <byorgey> Eduard_Munteanu: nice.
06:03:51 <quicksilver> alar: class MyColl c k v where ....
06:03:57 <vixey> @src sum
06:03:58 <lambdabot> sum = foldl (+) 0
06:04:00 <orbitz> alar: liek the syntax?
06:04:03 <quicksilver> alar: instance MyColl (Map k [v]) k v
06:04:07 <orbitz> alar: any haskell book/tutorial will cover it
06:04:18 <quicksilver> I doubt that.
06:04:27 <quicksilver> Very few haskell tutorials mention MPTCs.
06:04:41 <quicksilver> alar: you may also want c -> k, c -> v in the class definition.
06:04:46 <alar> quicksilver: and MPTC and "flexible instances" extensions enabled?
06:04:48 <quicksilver> depending what your intentions are.
06:04:53 <orbitz> ohh ok, specific to MPTCs, sorry
06:04:56 <byorgey> Eduard_Munteanu: I would probably pass the number of steps as a parameter rather than the step size
06:04:57 <quicksilver> alar: yes, at least those.
06:05:08 <quicksilver> alar: probably FunctionalDependencies too, for the last part.
06:05:53 <Eduard_Munteanu> byorgey, oh, I see. I thought the step size could provide some (rather bad) indication of precision, i.e. error.
06:06:01 <alar> quicksilver: I'm not quite sure about fundeps, but it is not hard to figure whether I need them
06:06:17 <EvilTerran> with fundeps, it'd be "class MyColl c k v | c -> k v where ..."
06:06:21 <byorgey> Eduard_Munteanu: well, you can do it either way, it's not really that important
06:06:29 <EvilTerran> and the instance would look the same
06:06:53 <byorgey> Eduard_Munteanu: I guess it depends how you want to think about the precision -- in absolute or relative terms
06:07:06 <Eduard_Munteanu> Yeah.
06:07:09 <quicksilver> alar: FWIW, this all looks a bit nicer with associated types.
06:07:16 <quicksilver> Mind you I don't know how to use them, so I couldn't help you there :)
06:08:06 <SamB_XP> quicksilver: how do you know it looks nicer, then ?
06:08:07 <EvilTerran> "class MyColl t where type Key t; type Val t; ...; get :: t -> Key t -> Val t; ..." or whatever
06:08:08 <byorgey> Eduard_Munteanu: you could also specify 'pairs' like this:
06:08:17 <ziman> @index CReal
06:08:17 <lambdabot> bzzt
06:08:29 <byorgey> steps = [a, a+stepsize .. b]
06:08:33 <vixey> You can get lower and upper bounds by summing the rectangles below vs above
06:08:38 <EvilTerran> "instance MyColl (Map k [v]) where type Key (Map k [v]) = k; type Val (Map k [v]) = v; ..."
06:08:39 <byorgey> pairs = zip steps (tail steps)
06:08:47 <alar> quiksilver: I'm not sure how
06:08:58 <Eduard_Munteanu> byorgey, uh, that's the first thing I tried, but it erred out. It says something about [Enum (Double, Double)]
06:09:08 <vixey> @let pairs = zip steps (tail steps)
06:09:08 <alar> should I create type family "collection" associated with class MyColl?
06:09:09 <lambdabot>  <local>:1:12: Not in scope: `steps'
06:09:09 <lambdabot>  
06:09:09 <lambdabot>  <local>:1:24: Not in scope: `steps'
06:09:15 <EvilTerran> alar, i just gave an example of associated types
06:09:15 <vixey> @let pairs steps = zip steps (tail steps)
06:09:17 <lambdabot>  Defined.
06:09:25 <vixey> > (pairs . pairs . pairs) "xyz"
06:09:27 <lambdabot>   []
06:09:32 <vixey> > (pairs . pairs . pairs) "xyzw"
06:09:33 <lambdabot>   [((('x','y'),('y','z')),(('y','z'),('z','w')))]
06:09:34 <alar> oh, thanks
06:09:36 <byorgey> Eduard_Munteanu: if it said something about Enum (Double, Double) then you didn't do exactly what I typed above =)
06:09:56 <alar> EvilTerran: the syntax looks a bit nicer
06:10:10 * alar goes to check if it will work
06:10:17 <byorgey> Eduard_Munteanu: you first compute the list of Doubles which are the division points: [a, a+stepsize .. b]
06:10:33 <byorgey> Eduard_Munteanu: then you zip those up offset by one to get a list of pairs
06:11:18 <Eduard_Munteanu> byorgey, oh, I see. What I had tried was different.
06:11:23 <EvilTerran> alar, to be honest, i find the associated type syntax to be a bit clunky
06:12:09 <SamB_XP> EvilTerran: yeah ?
06:12:13 <EvilTerran> especially when you're being olegian and your types get really long
06:12:15 <byorgey> Eduard_Munteanu: also, foldr (+) 0 === sum
06:12:19 <EvilTerran> it's annoying to have to give them repeatedly
06:12:24 <Axman6> @pl \xs -> zip xs (tails xs)
06:12:24 <lambdabot> ap zip tails
06:12:33 <alar> EvilTerran: in GHC docs it looks ...strange, but in your example, it's rather nice
06:12:43 <Axman6> @quote zip`ap`tails
06:12:44 <lambdabot> No quotes match. Wrong!  You cheating scum!
06:12:45 <orbitz> :t ap
06:12:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
06:12:48 <quicksilver> @quote aztec
06:12:49 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
06:12:57 <Axman6> that's the one i was after :)
06:13:06 <Eduard_Munteanu> byorgey, oh, I'll fix that. foldr (+) 0 is a common example in tutorials so I got stuck with it.
06:13:16 <orbitz> > zip`ap`tail
06:13:17 <byorgey> Eduard_Munteanu: heh, right
06:13:17 <lambdabot>       Overlapping instances for Show ([b] -> [(b, b)])
06:13:17 <lambdabot>        arising from a ...
06:13:25 <byorgey> Eduard_Munteanu: but anyway, this is a great start!
06:13:38 <Eduard_Munteanu> Thanks.
06:13:56 <Axman6> > zip `ap` tail [1..10]
06:13:57 <lambdabot>   Couldn't match expected type `[a] -> [b]'
06:14:02 <orbitz> > ap zip tails [1, 2, 3]
06:14:02 <Axman6> > (zip `ap` tail) [1..10]
06:14:04 <lambdabot>   [(1,[1,2,3]),(2,[2,3]),(3,[3])]
06:14:04 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
06:14:31 <vixey> > pairs [1..10]
06:14:33 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
06:15:00 <byorgey> now look what I've started!
06:15:43 <alar> it compiles!!!
06:15:51 <alar> @karma+ quicksilver
06:15:51 <lambdabot> quicksilver's karma raised to 5.
06:16:40 * quicksilver blinks
06:16:41 <quicksilver> 5?
06:16:48 <quicksilver> OK, I'm not exactly a karma whore
06:16:57 <quicksilver> but surely in 3 years on the channel I've earnt more than 5?
06:17:17 <SamB_XP> quicksilver: probably
06:17:23 <vixey> @karma quicksliver
06:17:23 <lambdabot> quicksliver has a karma of 0
06:17:25 <SamB_XP> lambdabot is always losing it
06:17:36 <int-e> @karma
06:17:37 <lambdabot> You have a karma of 1
06:17:40 <SamB_XP> @karma
06:17:41 <lambdabot> You have a karma of 0
06:17:47 <quicksilver> lambdabot-- # losing it
06:17:48 <SamB_XP> I used to have some karma, too ;-P
06:17:48 <vixey> @camelion
06:17:48 <int-e> state resets :/
06:17:49 <lambdabot> Unknown command, try @list
06:17:51 <byorgey> preflex: karma quicksilver
06:17:51 <preflex>  karma for quicksilver: 15
06:18:00 <quicksilver> preflex: karma lambdabot
06:18:01 <preflex>  karma for lambdabot: 2
06:18:04 <SamB_XP> preflex: karma
06:18:04 <preflex>  SamB_XP has no karma
06:18:08 <SamB_XP> preflex: karma SamB
06:18:09 <preflex>  karma for SamB: 3
06:18:22 <Eduard_Munteanu> > show [1..]
06:18:23 <lambdabot>   "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
06:18:23 <int-e> @karma moritz
06:18:24 <lambdabot> moritz has a karma of 248
06:18:24 <alar> @where SPOJ
06:18:24 <lambdabot> http://www.spoj.pl/
06:18:33 <Eduard_Munteanu> Uh, had to try it.
06:18:37 <Eduard_Munteanu> :P
06:18:39 <byorgey> Eduard_Munteanu: hehe =)
06:19:38 <jkff> @karma
06:19:39 <lambdabot> You have a karma of 0
06:19:42 <jkff> Wow, not much
06:19:54 <int-e> jkff-- -- could be worse ;)
06:19:56 <Eduard_Munteanu> @karma
06:19:57 <lambdabot> You have a karma of 0
06:20:00 <int-e> @karma jkff
06:20:00 <lambdabot> jkff has a karma of -1
06:20:03 <int-e> jkff++
06:20:15 <jkff> Oh, that's how it's done
06:20:26 <jkff> int-e++
06:20:28 <jkff> for pointing out :)
06:20:32 <Eduard_Munteanu> Uh, that's not pure.
06:20:43 <alar> @karma jkff
06:20:43 <ksf> preflex, nickometer
06:20:44 <lambdabot> jkff has a karma of 0
06:20:44 <byorgey> someone should really write a little program to parse all the #haskell logs and construct a 'canonical' \bot state
06:20:44 <preflex>  ksf is 0% lame
06:20:48 <lilac> @karma lunabot
06:20:49 <lambdabot> lunabot has a karma of 0
06:20:51 <Eduard_Munteanu> That's imperative.
06:21:11 <opqdonut> preflex: nickometer
06:21:11 <preflex>  opqdonut is 0% lame
06:21:13 <opqdonut> @karma
06:21:14 <lambdabot> You have a karma of 0
06:21:17 <opqdonut> hmm
06:21:23 <opqdonut> preflex used to give me 70% or something
06:21:28 <SamB_XP> byorgey: what about -blah ?
06:21:35 <opqdonut> preflex: nickometer ^hello73Tharr_
06:21:35 <byorgey> SamB_XP: that too.
06:21:35 <preflex>  ^hello73Tharr_ is 73% lame
06:21:41 <opqdonut> *shrug*
06:21:44 <SamB_XP> -blah is logged ???
06:22:00 <byorgey> SamB_XP: oh, no, of course not.
06:22:22 <SamB_XP> well, what I really mean is publicly logged
06:22:28 <SamB_XP> I expect the logs exist ...
06:22:33 <byorgey> I guess if anyone gave anyone else karma in -blah it is lost forever.
06:22:46 <byorgey> it's definitely not publicly logged
06:23:04 <SamB_XP> yes, far too much sex in it for that
06:23:17 <opqdonut> or then there should be a channel #lambdabot where the different lambdabots could dump their states
06:23:22 <opqdonut> and somebody would offer public logs
06:23:24 <byorgey> Eduard_Munteanu: yes, Haskell is the best imperative language in the world =)
06:23:32 <alar> lambdabot is just multiplayer GHCi
06:23:37 <alar> what's preflex?
06:23:47 <EvilTerran> preflex: version
06:23:48 <preflex>  4.166
06:23:48 <Saizan> what about fixing the state serialization?
06:23:50 <EvilTerran> hm
06:23:51 <int-e> karma is overrated :)
06:23:52 <byorgey> alar: a bot mauke wrote, I think
06:23:59 <Eduard_Munteanu> byorgey, yeah, monads rock
06:24:44 <SamB_XP> preflex: about
06:24:51 <lilac> preflex: nickometer
06:24:51 <preflex>  lilac is 0% lame
06:24:55 <lilac> yay
06:24:56 <SamB_XP> preflex: who are you ?
06:25:00 <lilac> preflex++
06:25:06 <SamB_XP> preflex: help
06:25:06 <preflex>  try 'help help' or see 'list' for available commands
06:25:07 <Baughn> preflex: nickometer
06:25:08 <preflex>  Baughn is 0% lame
06:25:11 <SamB_XP> preflex: list
06:25:11 <preflex>  Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; ZCode: [zdec, zenc]
06:25:32 <Axman6> preflex: Factoid: ?
06:25:39 <opqdonut> preflex: quote
06:25:40 <preflex>  <procyon> optimizing bubblesort is like masturbating.  Sure, it's not going to do you much good in the long run, and it's probably a waste of time, but it still feels good.
06:26:02 <SamB_XP> mmmkay ...
06:26:04 <jkff> preflex: help cdecl
06:26:04 <preflex>  cdecl DECLARATION - explain a C declaration
06:26:18 <int-e> preflex: zenc @#$%^&*()_+
06:26:18 <jkff> preflex: cdecl int f(char *s)
06:26:18 <preflex>  z40UzhzdzvzczaztZLZRzuzp
06:26:20 <preflex>  f: function(s: pointer to char) returning int
06:26:25 <jkff> Very nice
06:26:31 <jkff> As if I didn't knew myself
06:26:44 <EvilTerran> preflex: cdecl int (*foo) (int (*) bar)
06:26:45 <preflex>  missing ')'
06:26:55 <jkff> preflex: cdecl int (*)(*)
06:26:55 <preflex>  missing type
06:26:58 <EvilTerran> preflex: cdecl int (*foo) (int (*) (int))
06:26:58 <preflex>  foo: pointer to function(pointer to function(int) returning int) returning int
06:27:02 <jkff> preflex: cdecl int (*)(int (*)(int))
06:27:02 <preflex>  pointer to function(pointer to function(int) returning int) returning int
06:27:04 <opqdonut> :)
06:27:15 <jkff> Now try some boob combinator
06:27:19 <jkff> preflex: cdecl (.) . (.)
06:27:20 <preflex>  missing type
06:27:27 <SamB_XP> jkff: you silly
06:27:31 <SamB_XP> you know that isn't valid C
06:27:41 <Axman6> :t (.).(.)
06:27:42 <int-e> SamB_XP: oh?
06:27:42 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
06:27:43 <jkff> preflex does, too
06:27:44 <Saizan> no boobs for C!
06:27:49 <lilac> preflex: cdecl void*(*f((*)()))()[10]
06:27:50 <preflex>  missing type
06:27:50 <jkff> That's the point
06:27:57 <BeelsebobWork> Axman6: fmap . fmap is rather more useful than boobs unfortunately
06:28:09 <opqdonut> BeelsebobWork: not if (.)=fmap
06:28:10 <lilac> preflex: cdecl void*(*f(int(*)()))()[10]
06:28:11 <preflex>  trailing garbage
06:28:17 <lilac> :(
06:28:23 <SamB_XP> :t fmap . fmap
06:28:24 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
06:28:25 <vixey> preflex: cdecl printf("hello");
06:28:26 <preflex>  missing type
06:28:28 <BeelsebobWork> opqdonut: yes -- but (.) *shouldn't* equal fmap -- (.) is function composition
06:28:31 <SamB_XP> :t fmap fmap fmap
06:28:32 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
06:28:33 <jkff> preflex: rot13 (.) . (.)
06:28:33 <preflex>  (.) . (.)
06:28:38 <Axman6> BeelsebobWork: when boobs fail, time to fap.fap?
06:28:38 <BeelsebobWork> the two just happen to be the same in the function case
06:28:44 <jkff> Hm. Rotated boobs are boobs still?
06:28:45 <Axman6> uh, fmap.fmap >_>
06:28:52 <BeelsebobWork> Axman6: when boobs fail time to fmap fmap fmap
06:28:54 <jkff> preflex: rot13 fmap.fmap
06:28:55 <preflex>  sznc.sznc
06:28:58 <lilac> Peaker: you about?
06:29:11 <lilac> preflex: rot13 boobs
06:29:11 <preflex>  obbof
06:29:17 <Axman6> @unpl (.).(.)
06:29:17 <lambdabot> (\ i b c f -> i (b c f))
06:29:37 <SamB_XP> why i b c f?
06:29:39 <jkff> preflex: help wcalc
06:29:40 <preflex>  wcalc: alias of calc
06:29:45 <jkff> preflex: help calc
06:29:46 <preflex>  calc EXPR - evaluate an arithmetic expression
06:29:47 <BeelsebobWork> @check let fap = fmap in \f x -> ((.) . (.)) f x == (fap fap fap) f x
06:29:49 <quicksilver> :t (.)
06:29:49 <lambdabot>       Overlapping instances for Show ((b -> b1) -> (b -> b1) -> b)
06:29:49 <lambdabot>        ari...
06:29:50 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
06:29:51 <BeelsebobWork> bah
06:29:54 <BeelsebobWork> :(
06:29:55 <quicksilver> SamB_XP: no idea.
06:29:57 <jkff> preflex: calc (+) 1 2
06:29:58 <preflex>  3
06:30:02 <jkff> preflex: calc (.) . (.)
06:30:02 <preflex>  Lexical error
06:30:03 <BeelsebobWork> I wanted lambdabot to proved boobs equaled fap fap fap
06:30:10 <jkff> preflex: calc (+1) 2
06:30:11 <preflex>  3
06:30:11 <ksf> rotating boobs is both value- and  structure-preserving
06:30:12 <lilac> SamB_XP: i'd guess that the other letters appeared and disappeared during expansion of the type
06:30:19 <vixey> preflex: calc (((((((((((4(((()))))))))))()(+)(((((((((((8)))))))))))))))()
06:30:20 <preflex>  12
06:30:24 <jkff> Rotation is a boobomorphism
06:30:33 <SamB_XP> @unpl (.).(.).(.)
06:30:33 <lambdabot> (\ l b c f i -> l (b c f i))
06:30:36 <int-e> vixey: ouch!
06:30:56 <jkff> preflex: calc ()
06:30:57 <preflex>  Not enough mana
06:31:01 <EvilTerran> !
06:31:03 <jkff> preflex: calc ()()
06:31:04 <preflex>  Not enough mana
06:31:11 <jkff> preflex: calc )1(
06:31:11 <preflex>  1
06:31:14 <SamB_XP> preflex: help calc
06:31:14 <preflex>  calc EXPR - evaluate an arithmetic expression
06:31:18 <SamB_XP> preflex: help Calc
06:31:18 <preflex>  unknown command: Calc
06:31:22 <int-e> preflex: calc )
06:31:22 <preflex>  Not enough mana
06:31:24 <int-e> preflex: calc )1
06:31:25 <preflex>  1
06:31:26 <lilac> preflex: calc )))1+2)))
06:31:27 <preflex>  3
06:31:33 <jkff> preflex: calc +
06:31:33 <preflex>  Not enough mana
06:31:37 <lilac> preflex: calc (2*2)+3
06:31:38 <preflex>  7
06:31:46 <lilac> preflex: calc 2*(2+3)
06:31:46 <preflex>  10
06:31:47 <vixey> preflex calc: 1!2@3#4$5%6^7&8*9(0)
06:31:52 <lilac> preflex: calc 2*)2+3(
06:31:53 <preflex>  7
06:31:55 <int-e> preflex: calc ><(((1)>
06:31:55 <preflex>  Lexical error
06:31:58 <jkff> preflex: calc 5!
06:31:58 <preflex>  Lexical error
06:32:02 <vixey> preflex: calc 1!2@3#4$5%6^7&8*9(0)
06:32:03 <preflex>  Lexical error
06:32:10 <int-e> weird
06:32:10 <jkff> preflex: calc 2*(3+4)
06:32:11 <preflex>  14
06:32:15 <vixey> preflex: calc 9(0)
06:32:16 <preflex>  Too many operands
06:32:20 <vixey> preflex: calc (0)
06:32:20 <jkff> preflex: calc 2*)3+4(
06:32:20 <preflex>  10
06:32:22 <preflex>  0
06:32:23 <vixey> preflex: calc pi
06:32:24 <preflex>  3.141592653589793
06:32:25 <Axman6> heh, that reminds me of something i saw on out uni forums. turns out that ()())()()()()()()()()()()()()()()()()()()()()()()( really large and in <marquee> tags looks a lot like dancing legs
06:32:26 <SamB_XP> preflex: calc 1)
06:32:26 <int-e> preflex: calc 2*(2+3)
06:32:26 <preflex>  1
06:32:27 <vixey> preflex: calc e
06:32:28 <preflex>  10
06:32:29 <lilac> preflex: calc (2*)2+3(
06:32:30 <preflex>  2.718281828459045
06:32:32 <preflex>  7
06:32:32 <int-e> preflex: calc )2*(2+3)
06:32:34 <preflex>  10
06:32:48 <lilac> preflex: calc (2*)(2+3(
06:32:48 <preflex>  7
06:32:57 <Axman6> preflex: cals e ^ (i*pi) + 1
06:32:57 <lilac> preflex: calc (2*(2+3)
06:32:57 <preflex>  10
06:33:01 <Axman6> preflex: calc e ^ (i*pi) + 1
06:33:01 <preflex>  Lexical error
06:33:09 <jkff> preflex: calc i
06:33:09 <preflex>  Lexical error
06:33:11 <Axman6> preflex: calc 2 ^ 4
06:33:12 <preflex>  16
06:33:27 <Axman6> preflex: calc e ^ (√(-1)*pi) + 1
06:33:27 <preflex>  Lexical error
06:33:30 <Axman6> >_>
06:33:37 <jkff> preflex: help nickr
06:33:37 <preflex>  nickr NICK - increment NICK
06:33:43 <jkff> preflex: nickr jkff
06:33:43 <preflex>  jkff_
06:33:48 <jkff> preflex: nickr jkff_
06:33:48 <preflex>  jkf_f
06:33:54 <vixey> preflex: nickr vixey
06:33:55 <preflex>  vixey_
06:33:58 <jkff> preflex: iterate nickr jkff
06:34:12 <opqdonut> stop the floor already
06:34:19 <jkff> preflex: nickr 0
06:34:19 <preflex>  0_
06:34:21 <jkff> preflex: nickr _
06:34:22 <preflex>  a
06:34:24 <jkff> preflex: nickr a
06:34:25 <preflex>  a_
06:34:26 <jkff> preflex: nickr a_
06:34:27 <preflex>  b
06:34:30 <jkff> preflex: nickr z_
06:34:31 <preflex>  a[
06:34:40 <opqdonut> *flood
06:34:48 <Axman6> preflex: help nickr
06:34:48 <preflex>  nickr NICK - increment NICK
06:35:03 <Axman6> eh?
06:35:22 <jkff> Just in case your nick isn't big enough
06:35:29 <quicksilver> I call "enough bot games", I think.
06:35:37 <quicksilver> Feel free to continue in -blah or privmsg :)
06:35:54 <BeelsebobWork> @vixen have we played with the bot enough? >.>
06:35:54 <quicksilver> and summarise the funniest discoveries here, of course.
06:35:55 <lambdabot> bots should be destroyed. they are so annoying
06:36:04 <BeelsebobWork> I think that settles it :)
06:36:36 <ksf> preflex, 8ball will #haskell stop playing with bots?
06:36:37 <preflex>  cannot predict now
06:40:18 <vixey> jkff, I printed and reread the Theroems for Free paper.. still lost :/
06:40:37 <vixey> also I had a look at the haskell implementation but it didn't really help
06:40:50 <vixey> (still wondering how to define the relation)
06:41:48 <byorgey> yeah, that Theorems for Free paper is not easy to follow
06:42:06 <byorgey> I think I've read it thrice now
06:42:09 <wchogg> Well, I think it helps to keep in mind the whole natural transformations picture the whole time.
06:42:43 <wchogg> I said 'whole' twice in that sentence.  I should be slapped.
06:43:24 <vixey> I don't really know the natural transforms..
06:43:31 <byorgey> @slap wchogg
06:43:32 * lambdabot submits wchogg's email address to a dozen spam lists
06:43:39 <wchogg> oh noes!
06:49:41 <goober> so....
06:50:06 <Goober> why can't there be a "low level Haskell" ?
06:50:21 <Goober> which directly translates into opcodes the same way as C does
06:50:51 <Goober> why does Haskell ..have to be high level
06:51:01 <vixey> Goober, 1) C doesn't do that 2) There already is
06:51:07 <Philippa> because it wouldn't be Haskell otherwise
06:51:09 <Goober> vixey: 1) Yes it does
06:51:26 <Philippa> Goober: ever used a C compiler on a system with no hardware stack?
06:51:43 <Philippa> and that's before you run stuff through an optimiser
06:51:49 <Philippa> C is /not/ a portable assembler
06:51:52 <Goober> irrelevant, I'm talking about 99% of C implementations
06:51:54 <vixey> Goober, (not sure why you'd ask a question then just argue with the answers, but whatever)
06:52:09 <Philippa> you mean the 99% that you pulled out of your arse that nobody uses?
06:52:53 <vixey> hehe
06:52:55 <Goober> vixey: because you're being flippant
06:53:12 * sw17ch is very bad at writing portable C code...
06:53:27 <Goober> C has a high level of correlation to direct ASM code
06:53:35 <sw17ch> either that, or theres some mysterious reason that my 16bit C code doesn't work on my 8bit systems :)
06:53:36 <Goober> on 99.9% of compilers
06:53:39 <lilac> Goober: that seems to be the answer to your question
06:53:53 <Philippa> ooh, you found another 900 compilers?
06:53:53 <lilac> C corresponds better to Von Neumann architectures than Haskell does
06:54:12 * sw17ch realizes he walked into a holy war and backs away
06:54:39 <Goober> I don't think the conversation benefits from hair-splitting that vixey attempts
06:54:48 <lilac> Goober: there's a tendency for people here to dislike made-up facts
06:54:51 <Philippa> that's okay: we don't think it benefits from you
06:55:09 <Philippa> lilac: ITYM "facts" :-)
06:55:31 <Goober> It's not "made up", but you guys have some strong desire towards retardation and focusing on obscure compilers
06:55:37 <Goober> you obviously know what I'm saying
06:55:38 <lilac> Goober: we like people to state sources for facts, or state opinions as opinion rather than fact
06:55:39 <Axman6> Goober: look in GHC.Prim
06:55:41 <Philippa> GCC is obscure?
06:55:42 * vixey goes to get more sunflower seeds
06:55:42 <Goober> abouot C to asm
06:55:46 <Eduard_Munteanu> Can Haskell compilers output non-interpreted code? I mean something like C-like executable code, my simple program is a huge 864KiB when compiled.
06:55:53 <Philippa> optimising compilers are obscure?
06:55:58 <Philippa> wow, what world do you live in?
06:55:58 <Goober> Philippa: obscure targets
06:55:59 <Axman6> Philippa: of course!
06:56:16 <lilac> Goober: have you seen anything about the Reduceron?
06:56:17 <Philippa> Goober: the one I had in mind was a games console sitting about 2m away from me
06:56:20 <Eduard_Munteanu> I mean, can it drop lazy evaluation and such things in compiled code?
06:56:23 <fasta> Is there a way to download all the packages on hackage, unpack them, so I can grep over them? (other than just writing the script myself to do so)
06:56:25 <sw17ch> Eduard_Munteanu: Haskell is statically linked. GHC will happily interpret code, or compile it for you.
06:56:28 <Goober> Philippa: gcc at -O3 does not make the asm correspond to the code any less than no -O3
06:56:34 <Philippa> the bestseller in its generation
06:56:35 <sw17ch> Eduard_Munteanu: the reason it's big is probably b/c of the static linkage
06:56:39 <Goober> They have the same level of correspondence
06:56:41 <sw17ch> Eduard_Munteanu: make a C program, and compile it with -static
06:56:47 <sw17ch> and then compare the sizes
06:57:10 <scook0> "dropping lazy evaluation" is called strictness analysis, and much work has been done on it
06:57:15 <Goober> the No -O3 has slightly better locality
06:57:17 <Eduard_Munteanu> sw17ch, oh, my understanding was that Haskell includes some interpreter in executables. Thanks, it sounds okay now.
06:57:29 <fasta> Eduard_Munteanu: there are compilers that create smaller binaries. IIRC nhc98 does that.
06:57:35 <sw17ch> Eduard_Munteanu: no, it's actually very good ASM code for the most part
06:57:42 <Goober> In the case of inlining
06:57:47 <fasta> Eduard_Munteanu: but nhc98 is fairly unsupported now.
06:57:50 <Philippa> Eduard_Munteanu: there's a runtime system, but that's not the same as a virtual machine - C implementations have RTSes too
06:58:06 <fasta> Eduard_Munteanu: and see Philippa for why GHC's is that big.
06:58:17 <paolino> fasta :http://hackage.haskell.org/cgi-bin/hackage-scripts/archive.tar maybe
06:58:23 <Philippa> of course, the other reason C makes a crap portable assembler is that it's not low level enough
06:58:24 * sw17ch notes that he can follow the output from gcc -S -O, but cannot follow (without some serious work) the output from gcc -S -O3
06:58:30 <vixey> mm
06:58:31 <sw17ch> even on happy architectures like PPC
06:58:38 <vixey> 'kind' and 'type' are bad choices of names
06:58:44 <Goober> sw17ch: You get used to it
06:58:44 <Eduard_Munteanu> So careful coding (where possible) in Haskell should yield machine code just as performant as C counterparts?
06:58:46 <wchogg> vixey:  why?
06:58:48 <Philippa> vixey: 'sort' is better?
06:58:52 <vixey> sort is better
06:58:57 <malcolmw> Eduard_Munteanu: fasta: even though nhc98 is not actively developed, it is certainly maintained.
06:59:03 <sw17ch> Goober: i should hope i get better... since it's kinda waht i do for a living :\
06:59:04 <lilac> vixey: and class?
06:59:13 <vixey> wchogg, in this source code:  match kind_of_term t1, kind_of_term t2 with
06:59:26 <vixey> it's not immediately clear what "kind" means here
06:59:27 <fasta> malcolmw: ok, sorry about that.
06:59:29 <Philippa> Eduard_Munteanu: within the same ballpark generally, yeah
06:59:30 <sw17ch> Goober: but some of the more advanced flow analysis conditions and crazy inlining in various places gets thick in a hurry
06:59:34 <Goober> anyways, my point comes from reading my asm regularly -- whereas vixey's "it doesn't correspond to asm" is theoretical about "implementations"
06:59:40 <Eduard_Munteanu> Philippa, thanks.
06:59:48 <vixey> Goober, going to /ignore you if you keep hilighting me
06:59:58 <Philippa> Goober: seeing as you pulled 99.9% out of your arse I don't think you've much room to talk there
06:59:59 <Goober> fuck you?
07:00:05 <Goober> what is your problem, vixey
07:00:09 <Philippa> I highly doubt you've used 1000 different implementations and examined their asm
07:00:32 <Axman6> Goober: what's your problem? you've been rude and aggressive in an otherwise friendly and helpful channel. vixey isn't the one in the wrong
07:00:34 <Goober> Philippa: why focus on such trivialties?
07:00:36 <fasta> paolino: where did you get that link?
07:00:42 <sw17ch> I've used two compilers where i inspected the resultant machien code... the Obfuscated C Code compiler entry and GCC
07:00:43 <Goober> Axman6: Fuck you as well.
07:00:43 <Philippa> Goober: why not? You're fond of it
07:00:57 <paolino> fasta : main page
07:00:59 --- mode: ChanServ set +o Philippa
07:01:07 <Eduard_Munteanu> And here's another question that bugs me. Can, by its functional form, Haskell code be compiled into in-place code where possible? Somebody said finding a general algo for this is NP-hard, is this correct?
07:01:08 <Philippa> Goober: say "fuck you" one more time?
07:01:19 <Goober> Scroll back to the start of the convo
07:01:41 <Axman6> Goober: you're talking to a lot of people who know what they're on about. stop fighting and start learning or leave
07:01:42 <lilac> Goober: we all know what's been said. you've made assertions, you've not backed them up.
07:01:43 <vixey> Eduard_Munteanu: what exactly is in-place ?
07:01:44 <fasta> paolino: ah, nice that they thought of this.
07:01:44 <sw17ch> Eduard_Munteanu: by in place, do you mean tail recursive
07:01:51 <Philippa> you mean the start where you got answers you didn't like?
07:02:06 <Philippa> oh, and ignored anything but the one you're currently trolling about?
07:02:26 <Goober> You're obsessed with minor details Philippa.. my statement was general
07:02:33 <Goober> try to be pragmatic
07:02:34 <Eduard_Munteanu> vixey, meaning that data will be stored in the minimum amount of space, e.g. like in "in-place sorting algorithms"
07:02:55 <vixey> Eduard_Munteanu: geez NP-complete.. sounds like a _lower_ bound
07:02:55 <Philippa> I don't need to try, dear child
07:02:57 <Goober> C compilers *practically* translate quite directly to ASM. That's why we code in C!
07:03:01 <lilac> Goober: ok, some facts. on /some/ architectures, there's an easy mapping between C and asm. on other architectures, there isn't.
07:03:20 <Philippa> and it's distinctly less easy the better your compiler's optimisations are
07:03:24 <lilac> even on those architectures where there's an easy mapping, that is usually not the mapping that's used
07:03:24 <opqdonut> and in any case, heavy optimizations are taking place
07:03:25 <opqdonut> yes
07:03:34 <Axman6> Goober: optimising ones change the code a hell of a lot, they're nowhere direct translations in many cases
07:03:43 <Philippa> of course, C itself puts upper bounds on how good an optimiser can be...
07:03:53 <Goober> I disagree, Axman6
07:03:57 <wchogg> I think part of the problem is that it's not very clear what your initial statement really meant, Goober.  C & Haskell both compile down to ASM.  What's the distinction between them?
07:04:01 <Axman6> o rly?
07:04:06 * sw17ch notes that optimizations that try and get the CPU's branch predictor to behave a specific way are hugely wicked and dont map to the C code hardly at all
07:04:06 <vixey> hm
07:04:10 <Eduard_Munteanu> vixey, yes, given a piece of Haskell code, can it be transformed into in-place asm code?
07:04:13 <vixey> I think that what I said there does't really make sense
07:04:14 <Goober> gcc at O3 on x86 is still a very high correlation
07:04:27 <vixey> it shouldn't be NP-complete as a lower bound but NP-hard (?)
07:04:36 <Philippa> wchogg: low-level vs high-level, approximately. Of course, the part where you can give clear if boring operational semantics to haskell with extremely clear low-level interpretation goes out of the window
07:04:44 <lilac> Goober: the extent to which the C source resembles the ASM is the same as the extent to which your language has /prevented/ optimization, in my opinion...
07:04:47 <Philippa> Goober: pull another percentage out of your arse, go on
07:04:48 <Axman6> if by high correlation you mean it doed the same thing as the code is supposed to, then yes
07:05:02 <Eduard_Munteanu> vixey, the correct way to say it is "the problem is in NP"
07:05:02 <Goober> I spend 4-5 hours a day in Ida Pro
07:05:05 <vixey> Eduard_Munteanu, still not totally sure what you mean, it is possible to compile haskell into assembly though.. SPJs book has got some info about it
07:05:05 <Philippa> c'mon, "very high" is the best you can do?
07:05:15 <Goober> Ida has no problem with O3
07:05:23 <Goober> it's minor
07:05:27 <vixey> @go simon peyton jones implementing functional languages
07:05:29 <lambdabot> http://research.microsoft.com/~simonpj/papers/pj-lester-book/
07:05:29 <lambdabot> Title: Simon Peyton Jones: book
07:05:51 <vixey> Eduard_Munteanu, the chapters in there about STG are interesting
07:06:14 <Eduard_Munteanu> vixey, example: reading a list, modifying it and printing it out again. Can the compiler transform the functional code (which isn't in-place) in asm-code that uses the minimum required storage space, without any hints provided?
07:06:15 <kalven> Goober: have you worn out Ezla already?
07:06:33 <Axman6> you know, Goober is the first troll i've ever seen in here. never thought they'd know what haskell was
07:06:59 <Vq^> Axman6: oh, there has been a few
07:07:01 <opqdonut> 1359.43    # Ezla !n=Ezla@cpe-76-172-169-17.socal.res.rr.com has left #Haskell []
07:07:02 <Goober> Saying that C corresponds to Asm == trolling
07:07:04 <opqdonut> 1706.26 [freenode]    # Goober !n=Goobre@cpe-76-172-169-17.socal.res.rr.com
07:07:12 <Philippa> pretty lame troll given that odds are someone's actually learning about haskell implementations here
07:07:14 <opqdonut> uncanny resemblance ;)
07:07:14 <lilac> Ezla [n=Ezla@cpe-76-172-169-17.socal.res.rr.com]
07:07:14 <Goober> That's a really fringe perspective
07:07:27 <quicksilver> Eduard_Munteanu: No.
07:07:36 <Axman6> opqdonut: heh
07:07:40 <Philippa> nah, using poor strawman arguments to get a rise, that's second-rate trolling
07:07:44 <vixey> lilac, hehe
07:07:46 <quicksilver> Eduard_Munteanu: well it doesn't anyway. If by 'Can' you're talking about the realm of possibility, then one can imagine it of course.
07:07:51 <opqdonut> Ezla was actually pretty good
07:08:17 <Eduard_Munteanu> quicksilver, my specific question was: can there exist such an algorithm?
07:08:28 <sw17ch> So, i entered before this exchange started, what was his original point?
07:08:33 <lilac> Goober: why don't you tell us how great D is?
07:08:34 <quicksilver> Eduard_Munteanu: for all code in general, I suspect not.
07:08:35 <Eduard_Munteanu> AFAICT, it isn't possible for imperative languages.
07:08:39 <sw17ch> I'm assuming it was "C is better than Haskell for reason X"
07:08:42 <sw17ch> what was the "X"?
07:08:48 <Axman6> Goober: you affraid you'll lose your job to some haskell expert or something? seems you're pretty well invested in C, and you're not liking all this news about haskell's awesomeness
07:08:50 <quicksilver> Eduard_Munteanu: for various specific programs yes.
07:08:55 <lilac> sw17ch: actually, preference hasn't been expressed
07:08:58 * paolino wishes to have the standard troll free time to spare in other ways
07:09:00 <Philippa> sw17ch: "OMG, Haskell's all high-level and icky, why can't it be low-level like C?"
07:09:02 <Eduard_Munteanu> quicksilver, thanks, I see.
07:09:22 <Axman6> sw17ch: it was "why isn;t there a low-level haskell like C?" or some such nonsense
07:09:26 <sw17ch> Philippa: Haskell is the first High Level language that forced me to understand what it was doign on the low level to be good at it
07:09:31 <Goober> Now, your reactions towards " C <--> Asm " lead me to wonder where the overemphasised reactions come from. Do Haskell programmers have some kind of "opcode envy" or "C envy" regarding the correlation of their code to machine code?
07:09:35 <quicksilver> Eduard_Munteanu: I can't give you a proof but most forms of 'perfect code analysis' will inevitably be halting problem.
07:09:38 <lilac> sw17ch: the assertion that "C [...] directly translates into opcodes"
07:09:41 <Goober> Why is this such a pronounced negativity on this channel?
07:09:50 <Goober> lilac: Not directly
07:09:55 <lilac> Goober: that's what you said
07:09:55 <Philippa> hell no, the problem's that C's too high-level for good functional language implementations
07:09:58 <Goober> I said like 10 times, correlation
07:10:02 <Philippa> it's a shite portable assembler
07:10:10 <Eduard_Munteanu> quicksilver, no, this can't be reduced to the halting problem, since that is specific to Von Neumann machines (i.e. imperative code).
07:10:16 <Axman6> Goober: because you got perfectly reasonable responses to your questions and then started fighting people about their answers, when you were wrong
07:10:27 <Goober> I'm not wrong.
07:10:29 <vixey> Goober, yeah what Philippa said is very a good point
07:10:33 <Axman6> yes you are
07:10:34 <lilac> "14:50 < Goober> which directly translates into opcodes the same way as C does"
07:10:38 <sw17ch> Ah, we're making the claim that C is a portable assembler? Well, maybe with a lot of preprocessor help and typedef help...
07:10:40 <fasta> Goober: GHC's generated ASM could be improved for readability, yes.
07:10:40 <Eduard_Munteanu> quicksilver, or at least, not without proof.
07:10:46 <quicksilver> Eduard_Munteanu: not it's not. The halting problem applies to all turing complete languages, von neumann style or otherwise.
07:11:02 <Goober> lilac: You're hair splitting, my point was clear.
07:11:12 <Goober> "the way that C does"
07:11:14 <Eduard_Munteanu> quicksilver, sorry, Turing-complete. But my impression is Haskell doesn't qualify as Turing-complete.
07:11:14 <vixey> does any analogue of the halting problem apply to non-TC languages?
07:11:18 <Goober> implies some degree of "the way"
07:11:20 <Philippa> so "not that much, really"?
07:11:22 <quicksilver> Eduard_Munteanu: Your impression is wrong.
07:11:27 <Axman6> Goober: did you look at GHC.Prim?
07:11:29 <quicksilver> Eduard_Munteanu: haskell is very much turing complete.
07:11:37 <vixey> Eduard_Munteanu, haskell isn't Turing Complete -- it's General Recursive :)
07:11:38 <Goober> Answer my question
07:11:41 <lilac> Goober: sure, but the argument here was that degree is not that great
07:11:45 <Goober> Why are Haskell programmers so angry about this?
07:11:51 <Axman6> no of course not, because you're not here to listen, you're here to moan about things you don't know about
07:11:55 <lilac> Goober: the only anger i've sensed here was from you
07:11:58 <Eduard_Munteanu> quicksilver, how does something like "list = [1..]" qualify as a statement from a Turing-complete language.
07:12:00 <Eduard_Munteanu> ?
07:12:05 <Philippa> we answered your original question. You seized on the answer you didn't like. Terrible shame, really
07:12:11 <Philippa> I mean, talk about showing your hand early
07:12:18 <Goober> lilac: No, if we discuss the correspondence of Asm <-> C on other channels, there's a different perspective
07:12:23 <Goober> this is unusual here
07:12:24 <vixey> Eduard_Munteanu, (These two computational classes are equivalent)
07:12:26 <quicksilver> Eduard_Munteanu: "turing-complete" and "statement" are unrelated.
07:12:27 <opqdonut> Eduard_Munteanu: look at it this way: you can implement a turing machine in haskell
07:12:30 <Goober> you guys have Opcode envy
07:12:36 <Axman6> o.O
07:12:40 <Axman6> what a nutjob
07:12:41 <opqdonut> :D
07:12:44 <quicksilver> Eduard_Munteanu: "turing complete" is about whether or not you can compute all computable functions.
07:12:49 <orbitz> is Goober still upset Haskell isnt' D
07:12:57 <vixey> Goober, There's various abstract machines for lazy evaluation ...
07:13:25 <Philippa> hell, Goober's only in here because it's getting scarily easy to write haskell that performs as well as or better than C anyway
07:13:29 <lilac> Goober: as far as i can see, no-one here has argued that, for instance, GHC translates Haskell to x86 asm more faithfully than GCC translates C to x86 asm
07:13:39 <Axman6> Goober: Haskell programmers in general don't give a shit about how the machine handles their code, they just hope it'll be fast, and it often is.
07:13:41 <orbitz> Philippa: amen!
07:13:41 <Philippa> I don't think we're the ones with envy issues, somehow
07:13:49 <Axman6> we use haskell because we don't want to have to think like machines
07:14:12 <kalven> :P
07:14:23 <lilac> Goober: the answer to your original question is, it's impossible to design a language which corresponds directly to all hardware, since hardware differs
07:14:43 <lilac> Goober: and if haskell corresponded exactly to, say, x86, it wouldn't be haskell any more
07:14:45 <Goober> lilac: Of course
07:14:50 <Goober> I didn't argue that
07:14:56 <Eduard_Munteanu> opqdonut, quicksilver, but isn't it true that in Haskell you can compute things you can't compute on Turing machines?
07:14:58 <Goober> I simply made a reasonable analog
07:15:04 <opqdonut> Eduard_Munteanu: no
07:15:05 <Axman6> no, you didn't
07:15:06 <vixey> Eduard_Munteanu, *AHEM* (These two computational classes are equivalent)
07:15:12 <Philippa> and you got an answer: "it's like this because otherwise it couldn't be what it is"
07:15:16 <Philippa> funny how you ignored that one
07:15:16 <vixey> Eduard_Munteanu, missing all my remarks...
07:15:18 <Axman6> no one here is sure what your point is
07:15:19 <opqdonut> Eduard_Munteanu: as you could write a haskell interpreter for a turing machine
07:15:25 <Goober> Axman6: Saying that C translates to Asm is very reasonable.
07:15:36 <opqdonut> Eduard_Munteanu: because the computer you are currently running haskell on is practically a turing machine
07:15:45 <Axman6> that wasn;t what you were talking about originally. and... who cares?
07:15:46 <lilac> Goober: that's just saying that C can be compiled. beyond that it's a question of degree
07:15:54 <Goober> Fine
07:15:57 <Axman6> i don't care what my haskell looks like in asm
07:16:00 <Goober> *relatively high degree*
07:16:14 <Axman6> doesn't matter one bit to me, as long as it runs ok, i'm happy
07:16:17 <Goober> particularly because of the mannerisms of "call", push and pop
07:16:23 <quicksilver> Eduard_Munteanu: basically the argument is as follows : you can write a turing machine in haskell; you can write a haskell interpreter in a turing machine.
07:16:29 <Goober> many of the C language ideas match up with Asm in the first place
07:16:36 <quicksilver> Eduard_Munteanu: therefore the two have equivalent computability power.
07:16:42 <opqdonut> Goober: yes, C is an imperative language
07:16:44 <Axman6> Goober: what's your point?
07:16:52 <quicksilver> Eduard_Munteanu: (substitute 'your favourite language' for haskell too)
07:16:55 <Philippa> Goober: except that C won't let you manipulate the stack directly, and many compilers do their best to find other ways to handle function calls when they can
07:17:10 <lilac> Goober: i'd agree, having looked at both, that GCC's C compiler often produces asm which is more similar to the C code than the asm produced by GHC
07:17:18 <lilac> Goober: but why do i care?
07:17:29 <Eduard_Munteanu> quicksilver, err, while you can write a Turing machine in Haskell, writing Haskell on a Turing machine misses a few things, for example you can define infinite stuff, but not actually "iterate" it.
07:17:32 <Eduard_Munteanu> Is this correct?
07:17:33 <Axman6> i'd be a interested in seeing functional ASM
07:17:34 <lilac> also, that doesn't mean these are inherent properties of C or Haskell
07:17:39 <Goober> Axman6: The fact that asm is inclusive of C's paradigm is a large contributor towards the level of correlation
07:17:53 <vixey> Eduard_Munteanu, "iterate"?
07:17:54 <Goober> asm is not inclusive of Haskell's paradigm
07:18:02 <Axman6> Goober: so what? i still can't see your point
07:18:04 <quicksilver> Eduard_Munteanu: no, it's not correct.
07:18:07 <Goober> The point is
07:18:13 <Eduard_Munteanu> vixey, you can define an infinite list, but not actually store it on a Turing machine.
07:18:14 <Goober> *C CAN BE REPRESENTED IN ASM* directly
07:18:18 <Goober> Haskell cannot
07:18:20 <Axman6> ok? so?
07:18:30 <quicksilver> Eduard_Munteanu: you can't *actually* store an infinite list in haskell either.
07:18:36 <Axman6> why do i care?
07:18:38 <lilac> Goober: for certain values of asm, i agree. so what?
07:18:44 <Philippa> Sure. You've got to flatten Haskell's declarations first. Once you've lambda-lifted it's not that much further away than C, though
07:18:48 <quicksilver> Eduard_Munteanu: (obviously that would use infinite space)
07:18:49 <Philippa> it's just that nobody wants that implementation
07:18:50 <vixey> In some interpretation, you can store an infinite list...
07:19:00 <lilac> Goober: also, for certain values of 'directly'
07:19:05 <vixey> the encoding is programatic though
07:19:09 <Eduard_Munteanu> quicksilver, isn't "storing" in Haskell just a definition? I mean, it's only referential.
07:19:12 <quicksilver> Eduard_Munteanu: however you can work with an representation of an infinite list using laziness, just as you can in a turing machine.
07:19:13 <Philippa> lazy evaluation is just another calling convention
07:19:22 * sw17ch ponders how one would write a C  ->  JavaScript compiler...
07:19:22 <Goober> I think that's the point you guys missed from my original statements.. the fact that C can be represented in Asm, and that optimization is a further mangling of such a direct rep
07:19:22 <vixey> as opposed to malloc(length * sizeof(element))
07:19:27 <Philippa> Axman6: consider the relationship between jumps and CPS :-)
07:19:38 <lilac> Philippa: depends what you mean by 'calling convention' really
07:19:49 <quicksilver> Eduard_Munteanu: you can choose what 'store' meant. In that context it sounded like you meant store physically on the tape, which is why I gave a physically motivated answer.
07:19:50 <Axman6> Philippa: yep, i love me my CPS... what's CPS?
07:20:05 <Axman6> Goober: why would i want haskell to be like ASM?
07:20:09 <lilac> Philippa: i'd say it's a /slight/ generalization of the usual concept to include laziness, but only slight
07:20:14 <Philippa> Goober: it's more that the mapping's not all that useful unless you run with the optimiser off all the time. Not to mention that there are subsets of Haskell that do map cleanly
07:20:21 <Goober> Axman6: I never said you'd want Haskell to be like Asm
07:20:26 <Goober> I never said anything like that
07:20:28 <lilac> Philippa: since it also affects how you use the return value, and not just how you call the function
07:20:29 <Philippa> or at least, as cleanly as C ever does
07:20:31 <Goober> My original question, was...
07:20:37 <StoneToad> sw17ch: well, one could write a generic asm interpreter in JS, and then just compile the C to asm
07:20:38 <vixey> Axman6: You don't know CPS yet? :)
07:20:39 <Goober> "Can there be a low level haskell"
07:20:47 <Philippa> yes. And you got an answer right at the start
07:20:48 <Axman6> vixey: nope
07:20:48 <Goober> which translates directly to asm the way that C does
07:20:49 <lilac> Goober: if you recall, vixey answered that
07:20:50 <Philippa> "no"
07:20:50 <Eduard_Munteanu> quicksilver, storing == represent. I like to thing there is such a thing like a "Haskell machine" that can "iterate over" (e.g. print) or "store" infinite lists.
07:21:01 <Eduard_Munteanu> s/thing/think
07:21:02 <quicksilver> Eduard_Munteanu: Yes.
07:21:06 <quicksilver> Eduard_Munteanu: you can do that in a turing machine too.
07:21:08 <Philippa> there are significant subsets that there can be, but it'd be a haskell--
07:21:10 <Axman6> Goober: no. now, go look at GHC.Prim and see how close you can get, ok?
07:21:19 <Eduard_Munteanu> quicksilver, yeah, but the Turing machine won't halt.
07:21:23 <quicksilver> Eduard_Munteanu: wrong.
07:21:27 <vixey> Axman6: It's a form for programs so that everything takes a continuation -- and plugs its result into that continuation instead of 'returning'
07:21:30 <wchogg> Phillippa:  Gah...so what I meant earlier was that I wasn't clear on what the point of this discussion was supposed to be, what Goober wanted to understand.  If it's just the fact that Haskell has semantics that require trickier compilation techniques than C, then so what?
07:21:30 <Philippa> of course, it wouldn't have been a good trolling run if you'd paid attention to that answer now, would it?
07:21:31 <Axman6> vixey: where should i have learnt it?
07:21:42 <quicksilver> Eduard_Munteanu: any particular haskell program which uses infinite lists to produce a finite result, can be encoded on a turing machine.
07:21:58 <StoneToad> Eduard_Munteanu: anything dealing with an infinite output won't terminate...
07:21:59 <quicksilver> Eduard_Munteanu: (come to that, any haskell program which doesn't halt can also be encoded as a non-halting turing machine program!)
07:22:06 <Goober> lilac: vixey answered nothing
07:22:10 <vixey> Axman6: here's an example of a program in CPS http://hpaste.org/12697#a5
07:22:15 <Eduard_Munteanu> quicksilver, I see.
07:22:23 <lilac> Axman6: CPS means that your function, instead of returning a value, takes a function which consumes the return value as an argument.
07:22:24 <Goober> he had no interest concept or insight, he just said "whatever"
07:22:29 <orbitz> Goober: are you just pointing otu that C maps somewhat more idrectly to ASM (depending on the ASM), or are you makign some sort of value judgemetn abed off that?
07:22:35 <Philippa> sure, vixey isn't the person I'd ask about low-level behaviour. OTOH, vixey wasn't the only person to answer
07:22:52 <Philippa> oh, and I think you'll find that's "she"
07:22:58 <Axman6> lilac: oh, ha, right. i'm getting strange cannibalistic function images in my head now :)
07:23:00 <Goober> I won't ask him in the future, because she proved herself to be a newbie.
07:23:08 <Goober> her him she whatever :)
07:23:15 <orbitz> newbie in what?
07:23:18 <vixey> Axman6: (Don't know any good reference, avoid wikipedia though)
07:23:25 <Eduard_Munteanu> quicksilver, but for the sake of computational theory, can't we imagine a Haskell machine that (1) doesn't handle imperative code and (2) always halts, no matter what infinite input is told to process?
07:23:30 <sw17ch> @karma vixey
07:23:32 <vixey> I'm thinking about writing a short thing about it, to learn some TeX
07:23:44 <sw17ch> @bot
07:23:45 <lunabot>  :)
07:23:50 <Axman6> vixey: now that is another language well worth learning :)
07:23:54 <Eduard_Munteanu> quicksilver, I mean, is this a consistent machine?
07:23:56 <lilac> Goober: orly? you: "why can't there be a low level haskell?" her: "there already is" you: "raah i know better"
07:23:58 <Axman6> lambdabot: oi!
07:23:59 <Goober> Orbitz: I was wondering if there could be a subset of Haskell which * can be represented directly in Asm * with a relatively same level of correspondence as C can be
07:24:05 <Axman6> , karma vixey
07:24:12 <lunabot>  luna: Not in scope: `karma'
07:24:13 <Axman6> preflex: karma Philippa
07:24:13 <preflex>  karma for Philippa: 1
07:24:17 <lilac> Goober: whether the answer to your question is yes or no depends entirely on what you consider to still be haskell
07:24:17 <Axman6> preflex: karma vixey
07:24:17 <preflex>  karma for vixey: 9
07:24:22 <orbitz> Goober: i beleivei Philippa said that after one does lambda lifts on haskell code you get something very close
07:24:28 <Axman6> p and v are right next to each other >_>
07:24:44 <lilac> Goober: had you asked further rather than getting angry, you could have learnt about what the already-existing thing was
07:24:51 <Goober> After the lambda lifts. .
07:24:52 <orbitz> Goober: is this sort of attribute particularly useful for some reason or are you just curious?
07:24:58 <Goober> lilac: what's the already existing thing?
07:25:01 <quicksilver> Eduard_Munteanu: in your mind there seems to be some connection between imperative code and not halting.
07:25:05 <quicksilver> Eduard_Munteanu: there honest isn't.
07:25:07 <Axman6> Goober: i think i remember reading about a language that aimed to do that recently
07:25:16 <quicksilver> Eduard_Munteanu: "last [0..]" is a non-halting program. No imperative work there.
07:25:28 <lilac> Goober: i don't know, but i recall there being a low-level haskell variant designed for writing embedded software with
07:25:40 <quicksilver> Eduard_Munteanu: notions of turing computation are inherently about computing numbers and so are very pure and functional.
07:25:42 <orbitz> lilac: Timber?
07:25:44 <Goober> lilac: I'd like to know the name if you remember
07:25:45 <Philippa> Goober: after the lifts, it's just ordinary code for a GCed language - you need a representation for higher-order functions and you need a way of handling laziness, but closures and thunks handle that neatly
07:25:46 <wchogg> lilac:  I know there is current work on such things.
07:26:03 <sw17ch> C-- is a good portable assembler
07:26:09 <Philippa> the intermediate languages for languages like haskell and those in vogue for languages like C are surprisingly closely related
07:26:19 <Eduard_Munteanu> quicksilver, yeah, I imagine any imperative code in a statement = statement(time) manner, so infinite data leads to infinite statements which lead to no halting.
07:26:19 <Philippa> (for the haskellers: we're talking STG, not Core)
07:26:32 <Axman6> anyone remember that functional language that aimed to correspond to hardware types quite closely?
07:26:34 <sw17ch> perhaps one could consider LLVM a portable assembler as well
07:26:37 <orbitz> Philippa: STG?
07:26:37 <Eduard_Munteanu> quicksilver, gotta read more of that, sorry.
07:26:39 <Axman6> bitsomething maybeh
07:26:50 <Eduard_Munteanu> quicksilver, I know some basics.
07:26:54 <vixey> Eduard_Munteanu: You know the definition of Turing Complete?
07:27:02 <Axman6> speaking of LLVM, could it be used to improve GHC at all?
07:27:17 <orbitz> Goober: is a correspondence to ASM a useful attribute of a language you are interested in or are you just curious?
07:27:20 <Philippa> orbitz: "Spineless Tagless G-Machine". One of GHC's intermediate languages
07:27:22 <quicksilver> Eduard_Munteanu: let x = x + 1 in x is another non-halting program, if you want to avoid infinite data.
07:27:29 <Eduard_Munteanu> vixey, a Turing machine. It processes code and data sequentially.
07:27:42 <vixey> Eduard_Munteanu: There's also a definition of General or Mu-recursive functions-- Haskell fits _this_ definition
07:27:43 <quicksilver> Eduard_Munteanu: basically unrestricted recursion or unrestricted looping allows you to write non-halting code.
07:27:52 <Goober> orbitz: curious
07:27:53 <alar> is it possible to say "instance MyColl PriorityQ" instead of "instance MyColl (PriorityQ k v) k v"?
07:27:58 <orbitz> Philippa: is it a cowardly language?
07:28:09 <quicksilver> Eduard_Munteanu: and yet, unrestricted recursion and unrestricted looping are known to be required for turing completeness.
07:28:10 <vixey> Eduard_Munteau, It turns out these two classes are equivalent (like I said..)
07:28:20 <Goober> How do you guys "judge" GHC's output?
07:28:26 <quicksilver> alar: only in the associated types version.
07:28:29 <Eduard_Munteanu> Oh, I understand.
07:28:30 <Goober> I judge my GCC's output.
07:28:31 <orbitz> Goober: okay.  i think as you learn haskell you'll see beign close to ASM is not a particualrly useful attribute of a language as well
07:28:32 <Philippa> orbitz: heh. Totally. Not as lazy as Haskell, though
07:28:34 <vixey> so I think it's not useful to think about haskell as "turing complete"
07:28:48 <sw17ch> Goober: with a stopwatch and the size of the binary?
07:28:51 <vixey> this is just a consequence of some mathematical nonsense that you don't need when programming
07:28:57 <Philippa> quicksilver: the untyped lambda calculus has neither ;-)
07:29:12 <Goober> sw17ch: But in the asm, are haskell programmers truly blind?
07:29:14 <Eduard_Munteanu> quicksilver, my judgement came from the consideration that there could be a Haskell machine that can process such infinite inputs and always halt.
07:29:16 <Goober> there must be a way to judge it
07:29:17 <vixey> what is interesting is that any general recursive function is expressible in haskell *directly*
07:29:18 <quicksilver> alar: that is, essentially, the advantage of the AT version.
07:29:20 <sw17ch> Goober: you could stop by insulting us
07:29:27 <quicksilver> Goober: I judge it by whether it does the task I wanted it to do.
07:29:28 <fasta> Goober: most people don't care. You are thinking about security probably.
07:29:30 <Goober> sw17ch: that's not an insult
07:29:33 <Goober> it's a metaphor
07:29:35 <quicksilver> Goober: correctly, and in an acceptable time.
07:29:42 <orbitz> Goober: what do you mean by judging it?
07:29:42 <Eduard_Munteanu> But I see that this is my definition only.
07:29:48 <alar> quicksilver: and all this type-family stuff is just for this?
07:30:04 <Philippa> Goober: like I said, some subsets map fairly cleanly and others don't. In practice, people want an aggressively optimising compiler and GHC does things GCC could barely dream of
07:30:07 <quicksilver> Philippa: untyped lambda calculus has unrestricted recursion, effectively, just not as an explicit syntax.
07:30:17 <quicksilver> alar: not at all.
07:30:20 <Philippa> quicksilver: or a concept in the language :-)
07:30:24 <quicksilver> alar: it's for a whole bunch of struff
07:30:27 <quicksilver> Philippa: agreed.
07:30:28 <fasta> Goober: or at least, they don't care enough to push patches to GHC.
07:30:37 <quicksilver> alar: but that is its effect on your simple example.
07:30:43 * sw17ch ponders how being called "truly blind" is a metaphor, not an insult
07:30:56 <Goober> orbitz: For example, I compile my O3 code in GCC, I make sure to include debug symbols so that non-inlined procedures are easy to find, and I produce an output which (in OllyDbg) very nicely aligns the source code alongside my C++ code. Then I "pass judgement" on how good GCC did.
07:30:57 <Eduard_Munteanu> quicksilver, vixey, thanks.
07:30:59 <Goober> That's what I mean.
07:31:02 <Goober> I'll show an example:
07:31:04 <Philippa> sw17ch: hell, there's a good argument for the metaphor being ablist
07:31:13 <fasta> Goober: for some inner loops one can see what's going on with quite some effort.
07:31:33 <fasta> Goober: now, find a different topic :)
07:31:48 <orbitz> Goober: so you are judging it based on how well the executable aligsn with yoru sorucecode?
07:32:01 <sw17ch> My haskell aligns with source code just fine...
07:32:15 <Eduard_Munteanu> Although I wonder if there is such a thing like a truly functional CPU (no emulation).
07:32:17 <Goober> http://img530.imageshack.us/img530/9948/xxx1iq9.png
07:32:20 <sw17ch> you can even tell which functions the ASM comes from!
07:32:21 <Goober> Notice the "code column"
07:32:30 <Goober> Having a code column works *even in O3*
07:32:37 <Goober> you can see the procedure being repeated
07:32:37 <quicksilver> Goober: very few people that I have spoken to bother to analyse their haskell code in that detail.
07:32:42 <Goober> at each inlining spot
07:32:49 <quicksilver> Goober: having said that, very few people analyze their C in that detail
07:32:52 <quicksilver> (although evidently you do)
07:32:54 <orbitz> Goober: you judge this as good?
07:32:59 <wchogg> Eduard_Munteanu:  Maybe the old lisp machines were closer?
07:33:01 <quicksilver> dons analyses haskell ASM output.
07:33:05 <Goober> orbitz: This is unoptimized
07:33:09 <quicksilver> and obviously the guys who write the codegen do.
07:33:10 <orbitz> ok
07:33:12 <Goober> orbitz: its easy to read
07:33:16 <Goober> for the example
07:33:26 <Eduard_Munteanu> wchogg, Lisp machines? That's gotta be something. /me googles...
07:33:32 <Philippa> Goober: Haskell's concrete syntax isn't particularly amenable to that particular way of comparing. Effectively you have to think through a couple of layers of translation
07:33:39 <orbitz> Goober: i'm afraid i don't see the poitn very much.  unless you are writing a haskell optimizer...
07:33:51 <vixey> Axman6, saw the CPS example?
07:33:55 <Goober> orbitz: it's just a "habit"
07:33:58 <Axman6> Goober: ASM is inherently imperative right?
07:34:04 <Philippa> mostly that's due to the fact functions are first-class
07:34:07 <Axman6> vixey: yep
07:34:17 <Goober> axman6: the asm itself is, not the code it represents.
07:34:28 <daf> assembler is dull
07:34:29 <orbitz> Goober: being a habit doesn't make it useful
07:34:29 <Axman6> it is with C
07:34:37 * sw17ch goes to find dons' blog
07:34:44 <solrize_> @src (&&)
07:34:51 <Goober> The ASM in my screenshot does *exactly* what the C code does on the right side
07:34:57 <Axman6> @go don steward blog
07:35:07 <Axman6> Goober: so?
07:35:12 <alar> Goober: that means your C compiler optimizes poorly
07:35:21 <orbitz> Goober: i'm not seeing the connection between that being true and that being valuable
07:35:22 <Axman6> Cale: lambdabot needs a restart again
07:35:41 <Eduard_Munteanu> wchogg, yeah, though it seems the underlying hardware still maintains some imperative flavor.
07:35:45 <alar> @bot
07:35:45 <lunabot>  :)
07:35:46 <sw17ch> Goober: http://cgi.cse.unsw.edu.au/~dons/blog/2008/05/16#fast
07:35:49 <Axman6> orbitz: which is what i've been trying to say, but failing. well put
07:35:49 <Philippa> orbitz: it has some value if you want to tweak the compiler into producing specific output. Of course, so do things like GHC's inline function
07:36:07 <sw17ch> dons goes over a bunch of stuff about haskell code generation there and strictness analysis
07:36:14 <Goober> Well, if I code in Haskell, I want to know how I will avoid my OCD habit of reading Asm
07:36:18 <Goober> it's difficult not to do it
07:36:19 <orbitz> Philippa: i feel like Goober is trying to get at something else...
07:36:26 <sw17ch> Goober: you can read it, i read mine
07:36:33 <orbitz> Goober: habits ca nbe broken in 14 days, just obstain
07:36:41 <Goober> I dont wanna abstain
07:36:43 <alar> Goober: what OS do you write for?
07:36:49 <Goober> windows
07:36:56 <solrize_> Eduard_Munteanu - look for "reduceron"
07:37:00 <orbitz> Goober: then you don't want to avoid your OCD, so your initial statement is false
07:37:02 <alar> you're lucky
07:37:03 <salty-horse> hi. question: do parentheses have any meaning in function signatures? or are they added just for readability? I'm trying to understand the return value of liftP (linked) and it only makes sense when I "expand" the type InfoP and remove the parentheses around it... http://book.realworldhaskell.org/read/io-case-study-a-library-for-searching-the-filesystem.html#find.predicate.lift
07:37:08 <Goober> orbitz: explain?
07:37:25 <alar> in unices Asm is so obscure that I can't even find decent debugeer
07:37:29 <orbitz> Goober: you just said "I want to know how I will avoid my OCD habit", then you said "But i dont' want to abstain", so you don't want to avoid your habit
07:37:32 <Goober> alar: No
07:37:36 <Goober> that's only AT&T syntax
07:37:37 <vixey> salty-horse, (a -> b) -> c  is different to  a -> (b -> c)
07:37:48 <orbitz> Goober: feelf ree to compare ASM to haskell, i jus may not be informative, but nothign will stop you
07:37:50 <Goober> you can output/convert to Intel/Masm syntax
07:37:59 <Philippa> orbitz: people have conflicting desires, that's nothing new
07:38:10 <alar> Goober: what syntax? I;m talking about debugger program
07:38:16 <Eduard_Munteanu> solrize_, whoa, great stuff. Still, gotta read those papers and see what it does exactly.
07:38:19 <Goober> Just use NASM
07:38:20 <alar> is there TD for *NIX?
07:38:22 <orbitz> Philippa: i just pion them out, don't claim revelation :)
07:38:23 <Goober> Nasm is highly readable
07:38:29 <vixey> salty-horse, (a -> b) -> c  means it takes a function 'a -> b' to a 'c', whereas a -> b -> c means it takes an 'a' and a 'b' to a 'c'
07:38:44 <alar> yes, NASM all the way, but what I will debug it with?
07:38:59 <Philippa> orbitz: you made the leap from "want X" to "don't want X" though
07:39:01 <salty-horse> vixey, ok. can you explain liftP then? it's supposed to return a function (InfoP c). but instead, that function's arguments are part of liftP's parameters
07:39:17 <salty-horse> vixey, (at least to my understanding)
07:39:31 <quicksilver> salty-horse: it specifies the function it returns by defining what it does, with its parameters
07:39:36 <Eduard_Munteanu> salty-horse, you should look at what "currying" means.
07:39:50 <Eduard_Munteanu> It's quite handy to understand typing.
07:39:53 <quicksilver> Eduard_Munteanu: no, he shouldn't.
07:39:55 <Philippa> orbitz: compare and contrast with intuitionistic logic :-)
07:40:17 <quicksilver> salty-horse: it could have been written "liftP q f k w = \x y z -> f w x y z `q` k"
07:40:18 <salty-horse> Eduard_Munteanu, I understand currying.. this is a bit different.. should I start by expanding the type InfoP into its original definition?
07:40:29 <salty-horse> Eduard_Munteanu, (I think :D)
07:40:34 <orbitz> Philippa: I'm human too, can't I be illogical in my logical analysis?!
07:40:34 <Eduard_Munteanu> quicksilver, why? Only after I got what curry means I could understand what types really mean.
07:40:35 <Goober> On thing to think about, regarding Haskell <-> ASM. Have you guys ever coded in a Macro assembler?
07:40:39 <quicksilver> salty-horse: which would be "more obviously" a function which takes four parameters returning a function which takes three.
07:40:53 <quicksilver> salty-horse: is that what you would have expected?
07:41:08 <alar> Goober: have you ever tried typeful asm?
07:41:15 <Goober> Have you ever worked with ObjectAsm for example ?
07:41:25 <Philippa> orbitz: sure, just don't expect to get away with then implying it's valid by stating the conclusion as a fact :-)
07:41:26 <Axman6> Goober: have you done much Haskell yet?
07:41:34 <Axman6> s/done/written
07:41:38 <Goober> it's a serious question
07:41:38 <Eduard_Munteanu> Many things go as a -> b -> c -> d, though this really means (a, b, c) -> d
07:41:40 <orbitz> Axman6: ohh beat me too it
07:41:41 <salty-horse> quicksilver, I don't understand is how liftP has 7 parameters when it should have only 3 according to the signature
07:41:48 <Philippa> Goober: as with most things, some #haskellers have and some haven't
07:41:49 <Goober> just... answer ;)
07:42:06 <Goober> Ok, if you didnt work with a macro assembler, I'll give an example:
07:42:07 <Axman6> Goober: i'm just curous, not trying to fight or anything :)
07:42:10 <quicksilver> salty-horse: because "InfoP c" itself means another 3 parameters.
07:42:25 <quicksilver> salty-horse: did you see my alternative way of writing it?
07:42:30 <alar> @where paste
07:42:47 <Philippa> you can safely assume that most are familiar with some form of macro system, and there're only so many ways it could work with asm
07:43:03 <quicksilver> salty-horse: the key point here is that a haskell function which takes two parameters is also a haskell function which takes one parameter ... but returns a function which takes one more.
07:43:28 <quicksilver> salty-horse: so, a haskell function which takes 4 params and returns a function which takes 3, is the same thing as a haskall function which takes 8.
07:43:31 <quicksilver> salty-horse: 7. sorry. typo.
07:43:43 <Wrong> @paste
07:43:53 <alar> @bot
07:43:53 <lunabot>  :)
07:44:00 <Goober> K, check here, from MASM32's macros
07:44:01 <Goober> http://rafb.net/p/G0wWN017.html
07:44:02 <Axman6> lambdabot's dead atm :\
07:44:12 <Axman6> Goober: have you written any haskell yet?
07:44:45 <Axman6> argh, that's really ugly!
07:44:50 <Goober> Yes, pretty ugly.
07:44:59 <Goober> Now, the core point I've been leading up to.
07:45:03 <orbitz> Goober: anyways, what's the punch-line of you question
07:45:10 <lilac> Goober: my guess would be that a few people here have written compilers, some people here have written assembler of some flavour, and more here can read assembler of some flavour
07:45:12 <Goober> This can be done, in Haskell, with perfection.
07:45:30 <Goober> Because Haskell's type system is what they were trying to achieve with the macro assemblers
07:45:41 <daf> what's "This"?
07:45:46 <Goober> Yet Haskell has the intermediate layer of compiling
07:45:51 <Goober> Rather than *being the assembler*
07:45:59 <Axman6> again, so?
07:46:01 <Goober> being the assembler isnt all that far of a stretch
07:46:10 <Philippa> yes. People do actually do such things with it, in fact
07:46:11 <sw17ch> we're getting a code generator soon...
07:46:12 <Goober> Axman6: It would allow perfect code generation
07:46:15 <orbitz> Haskell is more than it's type system though, isn't it?
07:46:18 <Philippa> in fact, look at Harpy
07:46:22 <sw17ch> Goober: "perfect" ?
07:46:25 <lilac> Goober: last i checked, gcc goes via two intermediate languages, and gcc-with-llvm goes via three
07:46:28 <Philippa> it's a run-time assembler library
07:46:37 <Axman6> Goober: would it hinder things like STM, concurrency, and parallelism in haskell?
07:46:48 <Philippa> Axman6: humungously
07:46:52 <alar> Goober: it's simple
07:46:52 <alar> authors just don't want to implement every and each of typesystem extensions in macros
07:46:56 <Philippa> it'd require fixed semantics for everything
07:46:56 <Goober> Axman6: No, you'd be using Haskell's type system as a macro system.
07:46:59 <Axman6> i don't thing there's an easy asm translasion for a `par` b ...
07:47:06 <Goober> it harms only what you choose to do with it
07:47:26 <Goober> Axman6: Ah, because...
07:47:29 <sw17ch> Axman6: there's not an easy asm translation for let x = 1 : x
07:47:37 <Goober> there's no standard library of abstractions
07:47:38 <sw17ch> (or maybe there is)
07:47:43 <lilac> sw17ch: it depends what you think that means i guess :)
07:47:52 <Goober> The "compiler" can be a library
07:47:53 <fasta> Axman6: in 10 years there will be.
07:47:55 <sw17ch> lilac: how about we say no "obvious" representation
07:47:56 <Goober> rather than a honking codebase
07:48:03 <Axman6> fasta: let's hope so
07:48:03 <Philippa> Goober: same difference
07:48:10 <Philippa> in fact, the compiler /is/ a library
07:48:16 <Goober> It's not quite the same Philippa
07:48:19 <fasta> Axman6: I see it as a disadvantage personally.
07:48:46 <Eduard_Munteanu> quicksilver, http://en.wikipedia.org/wiki/Functional_programming#Recursion (last paragraph)
07:48:51 <lilac> sw17ch: in C++, you might say "List<Int> x(new Int(1), &x);" -- that has a reasonable translation into x86, but is less lazy than your code
07:48:53 <fasta> A computer should export just the primitives.
07:49:00 <Goober> You cannot write new GHC optimizations in the form of a simple extension library
07:49:03 <Axman6> Goober: what i want to be able to do is say a `par` b + a and have a and b evaluated at the same time, and i don't think anything that is that close to ASM would let me do that
07:49:05 <Eduard_Munteanu> It describes functional languages that fail to be compatible with Turing machines
07:49:05 <Philippa> actually, you can
07:49:10 <Goober> There just *IS* ghc
07:49:20 <quicksilver> Eduard_Munteanu: indeed. That's not because they're functional, though.
07:49:25 <Goober> there isn't Mr.LeetThunderX's Optimizations Lib
07:49:25 <quicksilver> Eduard_Munteanu: it's because they're total.
07:49:37 <lilac> Goober: actually, in 6.10, you /can/ write new GHC optimizations as a simple library
07:49:39 <Goober> with the GHC model, you have to have one.
07:49:42 <Goober> Not legos.
07:49:52 <quicksilver> Eduard_Munteanu: it happens that people who study these things tend to work in a functional setting.
07:49:53 <Philippa> Goober: got news for you, enabling that was a Summer of Code project this year
07:49:53 <lilac> Goober: you should check your facts
07:50:02 <Goober> LINK
07:50:03 <Axman6> lilac: obviously you're a liar
07:50:13 <Axman6> Goober said so
07:50:14 <lilac> Goober: plus theres {-# RULES ... #-} pragmas which have been aroudn for longer
07:50:18 <Eduard_Munteanu> quicksilver, can you point me to some information source? I can't find a definition on wikipedia for "total programming language"
07:50:20 <Philippa> Goober: google "summer of code" haskell 2008 and dig it up yourself
07:50:22 <quicksilver> Goober: you have been able to write quite wide-ranging GHC optimisations as RULES pragma.
07:50:31 <Philippa> for a very long time
07:50:36 <quicksilver> Eduard_Munteanu: a total programming language is one for which every program terminates in finite time.
07:50:45 <Philippa> fusion for a number of datatypes /has/ been supplied as an ordinary library
07:50:49 <Goober> quicksilver: Is it good?
07:50:52 <Goober> polished?
07:50:53 <quicksilver> yes, it's awesome.
07:50:55 <Eduard_Munteanu> quicksilver, thanks.
07:50:59 <quicksilver> you should read the stream-fusion paper.
07:51:03 <orbitz> Goober: you might benefit from learnign haskell
07:51:03 <Axman6> @check \xs -> (reverse.reverse) xs == xs
07:51:10 <sw17ch> I <3 Stream Fusion
07:51:11 <Eduard_Munteanu> quicksilver, where can I find some computational theory about this stuff?
07:51:16 <alar> where should I put default implementation for a class methods? In class definition?
07:51:20 <quicksilver> Goober: http://www.cse.unsw.edu.au/~dons/papers/stream-fusion.pdf
07:51:29 <Goober> quicksilver: thx
07:51:35 <quicksilver> Eduard_Munteanu: turner's relatively recent roundup paper is good.
07:51:35 <sw17ch> Where's the array fusion paper?
07:51:35 <vixey> Eduard_Munteanu, Simple Typed Lambda Calculus is a good start
07:51:36 <Axman6> Goober: can i ask again, and get an answer this time, have you ever written any haskell?
07:51:38 <Eduard_Munteanu> Philippa, I participated in this year's GSoC :)
07:51:39 <sw17ch> i mean, recycling
07:51:43 <Wrong> alar yes
07:51:43 <daf> Eduard_Munteanu: http://www.jucs.org/jucs_10_7/total_functional_programming/jucs_10_07_0751_0768_turner.pdf, perhaps
07:51:49 <Goober> anyways, this is still fundamentally different from using Haskell's typesystem as a macro assembler
07:51:57 <Eduard_Munteanu> quicksilver, vixey, daf: thanks.
07:52:02 <Goober> which does not even imply any GC
07:52:11 <Goober> or imply anything at all
07:52:24 <quicksilver> Eduard_Munteanu: it is the footnote to that paragraph you linked to me
07:52:24 <Philippa> Eduard_Munteanu: yeah, I didn't really in SoC itself though I still got sent a t-shirt
07:52:29 <Axman6> Goober: i think you want haskell to do something no one else wants it to
07:52:30 <vixey> Eduard_Munteanu, Lectures on Curry-Howard Isomorphism covers STLC (and other things)
07:52:32 <salty-horse> quicksilver, here's a better phrasing of my qusetion: http://hpaste.org/12748
07:52:36 <Goober> the GC exists only at Compile time
07:52:54 * alar wonders why some authors put default implementations in separate module
07:52:57 <Eduard_Munteanu> quicksilver, oh, I see.
07:52:58 <quicksilver> salty-horse: yes.
07:52:59 <Philippa> (I didn't end up mentoring this year, that is: still participated in the selection beforehand)
07:53:05 <quicksilver> salty-horse: (->) is right associative
07:53:20 <lilac> Goober: if what you want is to use haskell to write a program which generates assember code for another program, that's actually really easy
07:53:28 <salty-horse> quicksilver, were the steps I made logical?
07:53:31 <quicksilver> salty-horse: so (a -> b -> c) -> (a -> b -> c) is (a -> b -> c) -> a -> b -> c
07:53:34 <Eduard_Munteanu> Philippa, nice. I worked for Linux Foundation on the kmemtrace project. Got a t-shirt too.
07:53:37 <quicksilver> salty-horse: yes, they were.
07:53:41 <sw17ch> harpy!
07:53:45 <edwardk> alar: depends on the library but there are a number of reasons, sometimes you don't want to have big instances dragged in with the classes just in case th user has another instance in mind
07:53:48 <quicksilver> salty-horse: even if you didn't fully understand why they were logical, they were ;)
07:54:03 <quicksilver> salty-horse: you can remove parens around (->) at the right hand end but not the left hand end.
07:54:11 <quicksilver> because -> associates to the right.
07:54:15 <edwardk> alar: keep in mind that a lot of typeclasses would admit multiple implementations, when you define a Monoid you are forcing the user into your worldview about which Monoid
07:54:22 <Philippa> lilac: not only is it, but similar approaches have been used for hardware design with Haskell :-)
07:54:40 <Axman6> Goober: am i going to get an answer or not?
07:54:44 <Goober> quicksilver: What does this paper have to do with {-# RULES #-} ??
07:54:49 <salty-horse> quicksilver, if I remove parentheses from "left" areas of the signature, then haskell will make different bindings to the pattern I supplied, right? that's why it's safe to remove the right-side parens? (sorry if I got the terms wrong)
07:55:12 <edwardk> so, for instance there is a monad instance for (->)e. should it be in scope whenevr you bring in the Reader monad class?
07:55:12 <alar> edwark: default implementation must be consistent anyway, regardless of different instances
07:55:13 <BeelsebobWork> @bot
07:55:14 <lunabot>  :)
07:55:20 <BeelsebobWork> oh, has lambdabot died?
07:55:23 <Goober> I thought you were sending something about ghc optimizations as a lib
07:55:30 <edwardk> beelsebob: apparently
07:55:40 <quicksilver> Goober: they implemented those clever tricks using RULES
07:55:48 <Goober> quicksilver: Ah
07:55:50 <quicksilver> Goober: which effectively taught GHC a whole new kind of optimisation.
07:55:57 <quicksilver> Goober: without needing to change the compiler source at all.
07:56:03 <Goober> neat
07:56:33 <quicksilver> salty-horse: yes, removing parens from the left changes the function to something else entirely.
07:56:36 <Goober> axman6: no
07:56:57 <Goober> I don't know how to respond to you, you keep telling me I'm not using haskell for what it should be or something
07:57:14 <orbitz> Goober: I think you would benefit from writing a few projects in Haskell
07:57:19 <Axman6> Goober: my question is simple, have you written any haskell before, that's it
07:57:24 <salty-horse> quicksilver, ok. is this "effect" also due to currying? or is it simply due to ->'s precedence?
07:57:41 <quicksilver> salty-horse: it is simply due to ->'s precedence.
07:57:44 <Goober> I'm a haskell newb
07:57:53 <quicksilver> salty-horse: it's just a convention of how we write stuff.
07:57:55 <sw17ch> Goober: so... lines > 0?
07:58:00 <quicksilver> salty-horse: we could choose to right all the parens, all the time
07:58:01 * edwardk was so tempted to come in here and ask what a comonad was.
07:58:05 <quicksilver> salty-horse: but that would be a lot of parens.
07:58:09 <lilac> salty-horse: (->) is right-associative. that makes it easier to write the types of curried functions, but is an arbitrary choice other than that, i think.
07:58:13 <Goober> no, more like: I haven't crossed over into understanding yet how to write PROGRAMS in haskell
07:58:39 <Goober> which, I think, practical haskell book touches on.
07:58:41 <sw17ch> Goober: map (+1) [1,2..400] <-- this means nothign to you then?
07:58:52 <Axman6> Goober: well, learn before critisising
07:58:53 <Goober> means something, sw17ch
07:58:56 <lilac> Goober: do you think it would help you to understand how haskell compiles to asm?
07:58:58 <orbitz> sw17ch: the answer is pi!
07:59:00 <Goober> that's an easy one
07:59:11 <Goober> i learned map in learnyouahaskell
07:59:16 <Axman6> good
07:59:19 <Goober> however, many other languages have it
07:59:30 <sw17ch> [ (x,y)
07:59:34 <salty-horse> quicksilver, you mean like (a->(b->(c->(d->e))))? which better emphasizes the "all functions have only one parameter" view?
07:59:35 <Axman6> what about foldl (+) [1..100]?
07:59:40 <Goober> foldl is easy.
07:59:42 <orbitz> Goober: it might be good to forget abotu ASM and C for long enough to learn how to write things in haskell, then you can go back to determining how it translates to ASM
07:59:46 <sw17ch> [ (x,y) | x <- [1..], y <- [1..x], gcd x y == 1]
07:59:48 <sw17ch> how about that
08:00:00 <quicksilver> salty-horse: yes.
08:00:01 <edwardk> er.. what did i miss that Goober did/said to get the fifth degree?
08:00:01 <sw17ch> (i'm just trying to get a rough understanding of what you know already)
08:00:07 <saml> > [ (x,y) | x <- [1..], y <- [1..x], gcd x y == 1]
08:00:11 <Wrong> Axman6: doesn't typecheck
08:00:21 <Axman6> heh, indeed.
08:00:28 <Wrong> :)
08:00:31 <Axman6> foldl (+) 0 [1..100]*
08:00:47 <salty-horse> quicksilver, lilac. thanks a lot for helping me understand this!
08:00:50 <saml> > foldl (+) 0 [1..100]
08:01:02 <Axman6> gahh, we need lambdabot back!
08:01:11 <BeelsebobWork> who broke her?
08:01:12 <quicksilver> , foldl (+) 0 [1..100]
08:01:14 <saml> ok i'll pretend as a lambdabot
08:01:16 <lunabot>  5050
08:01:31 * saml opens ghci and readys to copy and paste
08:01:55 <Goober> sw17ch: i do understand that one
08:01:56 <Axman6> BeelsebobWork: no idea :\
08:02:04 <quicksilver> , "that won't be" ++ " " ++ "neccessary, saml"
08:02:06 <lunabot>  "that won't be neccessary, saml"
08:02:12 <Goober> although I find the defining of the gcd function inside the list to be odd
08:02:20 <saml> lunabot, poser!
08:02:28 <sw17ch> Goober: it's not being defined inside the list, just used
08:02:32 <quicksilver> Goober: == isn't a definition, it's a equality
08:02:34 <orbitz> Goober: he isn't
08:02:37 <BeelsebobWork> saml: that's not good enough, you should be working with pencil and paper to truely emulate a bot
08:02:41 <quicksilver> Goober: one "=" for defn, two "==" for comparison.
08:02:43 <orbitz> Goober: gcd is part of Prelude
08:02:56 <alar> function inside of list is memoization for free
08:03:03 <sw17ch> Goober: that produces a list of all relatively prime numbers
08:03:25 <Axman6> , take 50 [ (x,y) | x <- [1..], y <- [1..x], gcd x y == 1]
08:03:27 <lunabot>  [(1,1),(2,1),(3,1),(3,2),(4,1),(4,3),(5,1),(5,2),(5,3),(5,4),(6,1),(6,5),...
08:03:41 <dons> hey all
08:03:48 <sw17ch> oh good, dons is here :)
08:04:15 <drdozer> hi all
08:04:22 <alar> greetings
08:04:32 <dons> sw17ch: wassup?
08:04:36 <Axman6> Goober: direct all Haskell --> ASM questions to dons, and you may be amazed
08:04:37 <dons> i've got about 5 mins.
08:04:42 <dons> oh. asm time!
08:04:45 <drdozer> is there an uncurry I could use for (a -> b -> c -> d) -> ((a, b), c) -> d
08:05:04 <dons> i think i wrote about some of ghc's code gen tricks in RWH, and on the blog.
08:05:08 <sw17ch> dons: the last 45 minutes of conversation are best handled by you :)
08:05:13 <dons> there's also ghc-core, a good tool for reading the core/assembly
08:05:20 <Twey> :t uncurry . (. uncurry)
08:05:24 <dons> with syntax highlighting for assembly. i know you all like that.
08:05:29 <Goober> What I'm wondering now, Is there a way to get Haskell <-> Asm concordance output?
08:05:32 <Twey> :(
08:05:33 <dons> yes.
08:05:38 <dons> Goober: via the ghc-core program
08:05:42 <dons> it's on hackage.haskell.org
08:05:44 <Axman6> dons: quick update, us aussies (ivnam and I) won't be getting RWH until at the earliest the 15th :(
08:05:44 <Twey> \b is dead again
08:05:47 <Goober> dons: cool
08:05:54 <dons> i wrote it to help me optimise the asm / haskell at the same time
08:05:55 <Twey> Anyway
08:05:59 <drdozer> :t uncurry . uncurry
08:06:03 <dons> Axman6: 15th of Dec?
08:06:06 <Twey> drdozer: It's something like uncurry . (. uncurry)
08:06:06 <Axman6> aye
08:06:11 <saml> Twey, (((a, b1) -> c1) -> b -> c) -> (a -> b1 -> c1, b) -> c
08:06:12 <Twey> Hm
08:06:14 <dons> Axman6: sounds ok. but gee , brazil already has copies. :/
08:06:20 <Axman6> yeah :\
08:06:27 <Twey> Rearrange dots 'til you get it right :-P
08:06:31 <saml> no command found, :(
08:06:35 <orbitz> Brazil has prettier people than .au and pretty peopel get treated better
08:06:43 <drdozer> mm - is lambdabot alive? she doesn't seem to be giving feedback about those :t lines
08:06:45 <Twey> saml: *laughs*
08:06:47 <Axman6> well, it's an online store that i'd never heard of before, so it could just be O'Reilly doesn't like them...
08:06:47 <Goober> dons: Does the xlation of Haskell to ASM make sense to you in common reading, in the same way that asm reading of C makes sense to me? Is it just practice?
08:06:56 <Twey> @botsnack
08:06:57 <lunabot>  :)
08:06:59 <Goober> Or does that apply to nobody :P
08:07:01 <dons> yes, just took practice.
08:07:04 <Twey> Nope, but lunabot is
08:07:06 <dons> now it makes sense, and is pretty easy.
08:07:09 <Twey> Does lunabot do types?
08:07:18 <dons> Goober: using ghc-core was really useful to help learn the code gen strategies
08:07:28 <alar> dons: are you the author of native-code backend?
08:07:30 <Goober> well that's great
08:07:44 <orbitz> dons: would you suggest it to a haskell newbie?
08:07:51 <dons> ghc-core? no.
08:07:55 <dons> newbies shouldn't need to read asm
08:08:05 <dons> alar, i wrote some of the C-- layer in the current backend
08:08:07 <dons> not the new backend
08:08:09 <orbitz> Goober: you might want to get soem haskell practice befor eplaying
08:08:12 <dons> which is about to land.
08:08:22 * Axman6 has ghc-core suggested to him by dons as a newbie
08:08:27 <dons> heh
08:08:28 <dons> oops
08:08:36 <dons> well, it can't hurt.
08:08:39 <sw17ch> dons: when is that new codegen going to land?
08:08:42 <Axman6> i was rather confused :P
08:08:42 <dons> the medicine. it is good for you.
08:09:02 <dons> sw17ch: i saw the first commits last week
08:09:02 <Goober> orbitz: Maybe I have a convoluted way of learning...
08:09:02 <gwern> hm. how would I find out whether bytestring has read/show instances?
08:09:02 <Axman6> but, each time i look at it, it makes slightly more sense
08:09:08 <Philippa> Axman6: yeah, if you don't understand Haskell itself yet then it's probably too early :-)
08:09:18 <Axman6> Philippa: heh, indeed
08:09:31 <gwern> :i ByteString
08:09:31 <sw17ch> dons: in the git repo? when will there be a release for with it included?
08:09:40 <orbitz> Goober: i hear that a lot form people. I think it often stems for ma lack of patience
08:10:02 <dons> sw17ch: 6.12
08:10:02 <Goober> No, convoluted in the sense of going Low then High
08:10:06 <Goober> rather than High then Low
08:10:10 <dons> so next Sept. it will go live.
08:10:28 <sw17ch> dons: ah, of course :(
08:10:29 <lilac> gwern: @instances-importing Data.ByteString Show includes ByteString
08:10:45 <lilac> good old \b to the rescue :)
08:10:50 <sw17ch> dons: sorry for the flood, but will the C-- backend make porting GCC to other architectures easier?
08:10:54 <gwern> lilac: is @instances-importing a command to something?
08:11:02 <lilac> gwern: lambdabot.
08:11:14 <dons> sw17ch: yeah.
08:11:21 <dons> sw17ch: yes, ghc is becoming a cross compiler
08:11:24 <sw17ch> I want an ARM target soooooooo bad
08:11:37 * sw17ch does a fist pump
08:11:37 <dons> well, hey, there's already an arm via-C build on debian
08:11:39 <dons> can you use that?
08:11:46 <dons> or you want it on android ...
08:11:46 <sw17ch> whhhatt????
08:11:52 <dons> debian/arm-ghc
08:11:52 <lilac> gwern: but :info ByteString in GHCi works too
08:11:53 <gwern> lilac: oh. truly lambdabot does much
08:11:55 <dons> it ships with debian
08:11:57 <sw17ch> no, i want it on my microcontrollers :)
08:12:00 <dons> ah ha
08:12:04 <dons> will the ghc rts fit?
08:12:10 <dons> i've run nhc98 on an arm box
08:12:16 <dons> arm card-sized device.
08:12:24 <sw17ch> that's pretty close
08:12:34 <sw17ch> the first would be my stupid POS Windows Mobile 6 phone
08:12:44 <sw17ch> well, probably not, since i need that gadget yet
08:12:56 <sw17ch> but i work with a lot of ARM's... many with plenty of memory /disk
08:12:58 <Eduard_Munteanu> I compiled a program which calls integrate from http://pastebin.com/d5086be1c with a small stepsize. As I see it, the integration could be done with minimal memory requirements, but the program quickly eats all memory and available swap. What's wrong?
08:13:17 <Eduard_Munteanu> Or should I use monads to do this more efficiently?
08:13:24 <sw17ch> dons: i'll have to look at nhc98
08:13:28 <sw17ch> how long ago was this that you did that?
08:13:42 <Ezla> Salutations
08:14:07 <vixey> Eduard_Munteanu, probably lazyness
08:14:16 <quicksilver> Eduard_Munteanu: foldr (+) is going to built up an enormous thunk
08:14:17 * sw17ch notes that Ezla and Goober may feed off eachother...
08:14:35 <quicksilver> Eduard_Munteanu: you want foldl'
08:14:40 * Ezla bites Goober
08:14:40 <quicksilver> sw17ch: Ezla is Goober ;)
08:14:41 <alar> sw17ch: GHC RTS is very powerful, therefore it is not easy to port
08:14:45 * Goober ouch
08:14:48 <quicksilver> sw17ch: he said as much yesterday (or she)
08:14:50 <Philippa> sw17ch: RPS is evil, bad and wrong :-)
08:14:53 <Eduard_Munteanu> quicksilver, I've also tried sum. Lemme try foldl.
08:14:54 <drdozer> quicksilver: is there some way to 'compute' what will build a thunk?
08:15:01 <quicksilver> Eduard_Munteanu: foldl'
08:15:03 <drdozer> so we could potentially push that info into the type layer?
08:15:05 <quicksilver> Eduard_Munteanu: the ' is important
08:15:05 <sw17ch> quicksilver: i had my suspicions
08:15:11 <Eduard_Munteanu> quicksilver, I see.
08:15:17 <quicksilver> Eduard_Munteanu: makes it strict.
08:15:27 <Ezla> Why does Haskell need so many thunks?
08:15:31 <quicksilver> drdozer: it's fairly easy, yes. All functions ;)
08:15:31 <sw17ch> alar: the RTS is the C bits, right?
08:15:40 <vixey> drdozer, I don't know about putting it into the type level, but you can do call-by-push-value to make that stuff explicit
08:15:42 <sw17ch> or, it's mostly C
08:15:45 <quicksilver> sw17ch: the RTS is written in haskell, C and Cmm
08:16:02 <quicksilver> Ezla: for laziness.
08:16:03 <Axman6> why are Goober and Ezla both connecting from the same hostname?
08:16:06 <alar> sw17ch: not sure, but it does lots of system-specific stuff
08:16:07 <lilac> i find it quite amusing that i've only seen two trolls here in about a month, and they have the same IP :)
08:16:08 <sw17ch> if GHC is becoming a cross compiler, what good will it be without the RTS?
08:16:11 <quicksilver> because they are the same person, Axman6
08:16:13 <quicksilver> as I just said.
08:16:17 <drdozer> quicksilver: some combinations of function compositions don't build thunks
08:16:20 <Goober> why are you so obsessed about Ezla + Goober
08:16:26 <Eduard_Munteanu> quicksilver, where do I find stuff about foldl' or any function' stuff?
08:16:27 <Ezla> I'm not even a regular.
08:16:28 <sw17ch> or is there goign to be effort to make the non-portable parts of the RTS easier to work
08:16:33 <drdozer> quicksilver: you'd think there would be an algebra to describe this
08:16:39 <dons> the rts isn't too hart to port. it's C.
08:16:47 <sw17ch> dons: well, that i can do :)
08:16:56 <sw17ch> dons: in your app, did it run OS-less?
08:16:56 <quicksilver> drdozer: what combinations are you thinking of which don't build thunks?
08:17:05 <sw17ch> the ARM app, that is
08:17:09 <quicksilver> drdozer: loosely speaking, without optimisation everything will build thunks.
08:17:22 <quicksilver> drdozer: with optimisations on, GHC will remove some of them.
08:17:37 <drdozer> sure, but sometimes those thunks explode, and other times they get consumed as they are made
08:17:46 <Ezla> quicksilver: Why "some of them" ?
08:17:53 <Axman6> Goober: because it's very strange for two people to have the same hostname like that and not be different people
08:18:06 <Goober> Axman6: shhhh
08:18:21 <Goober> You're way too nosy!
08:18:42 <quicksilver> Ezla: because the optimiser is fairly complex and I don't ahev a simple way to explain which thunks it can remove ;)
08:18:56 <quicksilver> indeed, I don't underswtand the optimiser well enough to explain every case, either.
08:19:12 <quicksilver> drdozer: "case" consumes them.
08:19:26 <vixey> @remember <Ezla> Why does Haskell need so many thunks?
08:19:28 <quicksilver> drdozer: simple lazy operational semantics are fairly straightforwward.
08:19:33 <vixey> aww
08:19:36 <lilac> vixey: \b is dead
08:19:42 <Ezla> vixey: s/Haskell/ghc/
08:19:51 <quicksilver> drdozer: function applications create thunks, case reduces thunks.
08:20:07 <quicksilver> drdozer: that is a "worst-case" for GHC; the optimiser will remove some of them.
08:20:10 <gwern> vixey: personally, I don't think it's that great a quote
08:20:20 <vixey> gwern, I think it's hilarious...
08:20:23 <Ezla> vixey is obsessed with me
08:20:25 <Axman6> Goober: i wasn't the one who noticed it ;)
08:20:41 <Ezla> Usually 100% of thunks can be eliminated when incremental linking is disabled.
08:20:58 <lilac> Ezla: what do you mean by thunks here?
08:20:58 <Ezla> Are you guys talking about "dynamic dispatch" thunks
08:21:02 <lilac> Ezla: nope.
08:21:03 <Ezla> whiich are more general
08:21:04 <quicksilver> no
08:21:09 <Ezla> So plain old dumb thunks
08:21:10 <Ezla> why?
08:21:11 <quicksilver> although the concept is very loosely related
08:21:12 <alar> integrate f low hi step = sum $ (\x -> f x * step) [low,low+step..hi] -- <- rectangle integration
08:21:13 <lilac> Ezla: no, they're not more general, they're completely different
08:21:26 <quicksilver> these thunks are suspended function evaluations.
08:21:28 <Ezla> lilac: Yeah, completely different
08:21:39 <quicksilver> thunk is a rather overloaded word.
08:21:43 <Axman6> alar: got one for simpson's rule?
08:21:49 <vixey> f x || f (x + step) where (||) = min or max
08:22:02 <alar> Axman: what's simpson rule?
08:22:03 <vixey> oh way that doesn't work
08:22:11 <Axman6> can't'r remember, heh
08:22:18 <Axman6> 'r yup
08:22:28 <drdozer> quicksilver: OK - I really just want something that will either give me hints or will chose code for e.g. which fold to use
08:22:36 * alar knows of rectangle, trapezio and something more complicated, can't remember the name
08:22:43 <quicksilver> drdozer: foldr when you are generating a lazy list or other lazy structure
08:22:51 <alar> parabola?
08:22:52 <Ezla> Show an example of a simple haskell expression which necessitates the suspended eval thunk?
08:22:53 <quicksilver> drdozer: foldl' when you are collapsing to a summary value.
08:23:00 <Axman6> alar: aye
08:23:09 <quicksilver> Ezla: let l = [1..]
08:23:18 <quicksilver> Ezla: if it didn't suspend, it would occupy all your memory ;)
08:23:22 <Axman6> http://en.wikipedia.org/wiki/Simpson's_rule
08:23:27 <Ezla> quicksilver: that is insane.
08:23:33 <Axman6> Ezla: why?>
08:23:35 <Ezla> I thought Haskell was doing this via VM.
08:23:38 <quicksilver> insane? it was a statement of fact.
08:23:40 <opqdonut> :D
08:23:41 <Ezla> Rather than something more direct
08:23:45 <Axman6> nope
08:23:45 <opqdonut> how does VM come into this
08:23:52 <Axman6> haskell compiles into ASM
08:23:52 <vixey> Ezla, what is it doing?
08:23:52 <Ezla> opqdonut: It doesn't!
08:24:00 * alar is too lazy to   use smart integration, because decreasing integration step is easier 
08:24:03 <Ezla> I meant some form of "fake vm"
08:24:03 <Eduard_Munteanu> FWIW, http://www.haskell.org/haskellwiki/Performance/Accumulating_Parameters
08:24:14 <Eduard_Munteanu> Found out what quicksilver was referring to.
08:24:17 <daf> a virtual virtual machine?
08:24:20 <Ezla> Yeah
08:24:23 <Ezla> that, daf
08:24:24 <Axman6> heh
08:24:30 <lilac> Ezla: nope, it compiles to proper native code (or at least, it can and GHC does)
08:24:57 <quicksilver> Ezla: it's a surprisingly efficient setup, in fact.
08:25:04 <quicksilver> GHC thunks are very low-overhead.
08:25:14 <quicksilver> and they are mutated in-place to constructors
08:25:20 <quicksilver> (if they turn out to evaluate to a constructor)
08:25:22 <Axman6> (map (^193) [1..]) !! 1000000
08:25:23 <Ezla> heheheheheh
08:25:43 <quicksilver> it sounds like a bonkers implementations strategy and turns out to be really quite good.
08:25:51 <saml> , (map (^193) [1..]) !! 1000000
08:25:52 <Ezla> No, it doesn't sound bonkers
08:25:54 <lunabot>  1000193018529179672033878066893789452519116002588293557464747653046044550...
08:25:54 <alar> > (map (^193) [1..]) !! 1000000
08:25:57 <Ezla> it sounds awesome
08:26:02 <Axman6> lambdabot's dead remember?
08:26:11 <alar> @bot
08:26:11 <lunabot>  :)
08:26:27 <alar> lunabot doesn't mueval?
08:26:57 <Ezla> What other aspects besides the thunks are in a similar vein?
08:27:10 <gwern> alar: we had a bot which did javascript, if that help...
08:27:17 <quicksilver> alar: it does, but you use "," to talk to it.
08:27:23 <Ezla> how do you avoid not fucking cache coherency?
08:27:45 <quicksilver> Ezla: I think it's fair to say that's a weak point, for uniprocessor code.
08:27:51 <quicksilver> the data locality isn't great.
08:27:55 <Ezla> isn't Haskell code the worst ever at branch mispredictions?
08:27:57 <mrd> GC coalesces data
08:28:05 <quicksilver> although the simple allocation model does do consecutive cheap allocations
08:28:17 <quicksilver> so stuff allocated together, lives together.
08:28:21 <saml> what does it take to directly call .dll or .so functions from haskell? without writing a wrapper. dynamically loading compiled libraries
08:28:29 <quicksilver> for multi-core code it turns out to be a win, though.
08:28:36 <quicksilver> because haskell code is mostly read only
08:28:40 <quicksilver> (no coherency on that part)
08:28:45 <int-e> Ezla: it's not quite as bad since it got pointer tagging. but it's still a problem
08:28:51 <quicksilver> and each thread writes to a thread-local nursery
08:29:02 <quicksilver> (so hopefully cores have non-overlapping writes)
08:29:05 <Ezla> Does haskell have any mechanism for branch hinting?
08:29:36 <mrd> unlikely() ?
08:29:38 <int-e> no. on which level would it live? haskell code has no branches.
08:30:03 <Ezla> int-e: good question, heh
08:30:15 <mrd> it would be a pragma
08:30:21 <lilac> int-e: it could live on any multi-branch pattern matching construct
08:30:40 <lilac> but haskell already has that
08:30:52 <lilac> given that tehy're checked in order
08:31:17 <Ezla> are Haskell thunks localized?
08:31:28 <Ezla> or do they pile up in some common range of addy space
08:31:33 <int-e> lilac: true, but I'm not convinced that this information would be all that useful to the compiler.
08:32:14 <int-e> lilac: hard to say. somebody (tm) should try it out ;)
08:32:30 <lilac> or we could ask one of the ghc authors :)
08:32:30 <Ezla> by localized, I mean nearest to their target as possible
08:32:38 <Ezla> rather than how fixups are elsewhere
08:32:54 <lilac> what do you mean by 'target'?
08:33:12 <lilac> thunks represent some datum which has not yet been computed
08:33:39 <Ezla> lilac: possible data / destination <- target
08:34:13 <int-e> Ezla: no, they're not localised. They end up wherever the heap top was when they were created, and they're copied along while garbage collecting.
08:34:58 <Ezla> That's no good for the L1
08:35:00 <int-e> Ezla: really, haskell code thrashes the CPU cache quite badly. It's a big problem, but a very hard one to solve.
08:35:15 <Ezla> why can't some effort be put in to localize them?
08:35:22 <alar> FFI rules
08:35:26 <Ezla> FFI rules?
08:35:37 <alar> rulez
08:35:38 <lilac> yep, it rules
08:35:56 <Axman6> i think time is better spent finding other ways to make haskell programs run faster at a higher level personally
08:36:15 <lilac> Ezla: in some sense they are localized. a lot of the work done by a program is likely to be at the top of the heap.
08:37:33 <int-e> Ezla: one reason that it's hard is that any idea that makes allocation more expensive is very unlikely to pay off. reducing allocations is the most attractive route - which is accomplished by inlining, eliminating cases where possible, and by unboxing values and allocating them in registers instead of the heap.
08:37:36 <Eduard_Munteanu> quicksilver, I don't get it, I couldn't find a definition for foldl'. Were you suggesting I should use an accumulating parameter for foldl?
08:37:51 <quicksilver> Eduard_Munteanu: no. I was simply suggesting you use foldl'
08:38:05 <alar> @src foldl
08:38:07 <Ezla> int-e: What about the static thunks?
08:38:07 <dmwit_> Eduard_Munteanu: It's in Data.List.
08:38:13 <quicksilver> Eduard_Munteanu: foldl' is strict as it goes along
08:38:37 <lilac> Ezla: what do you mean by that?
08:38:43 <dmwit_> Ezla: Are you actually running into performance problems, or are you just speculatively optimizing?
08:38:46 <Eduard_Munteanu> quicksilver, oh I see.
08:38:49 <quicksilver> Eduard_Munteanu: instead of building a big thunk of (+)s
08:38:53 <int-e> Ezla: they're an exception. but there aren't many of those, usually. (large, unboxed?) arrays are also an exception - they're pinned in memory.
08:39:00 * alar is not quite sure that using strict functions in integration is good
08:39:05 <quicksilver> Eduard_Munteanu: (this requires to be left fold, you can't be strict as you go along on the right fold)
08:39:29 <quicksilver> alar: Eduard_Munteanu's code is just calculating a number, if I read it right.
08:39:36 <quicksilver> no reason not to use a strict foldl' for that
08:39:44 <quicksilver> Eduard_Munteanu: also, compile with optimisation ;)
08:39:57 <alar> is there any danger that strict function will force entire argument list/
08:39:59 <alar> ?
08:40:17 <quicksilver> no.
08:40:20 <Ezla> Can you show me a simple expression which cannot be a static thunk?
08:40:28 <Eduard_Munteanu> quicksilver, why wouldn't foldr work? Because of it's recursive definition?
08:40:28 <quicksilver> , foldl' (+) 0 [1..1000000]
08:40:31 <lunabot>  500000500000
08:40:47 <quicksilver> Eduard_Munteanu: because with a foldr the innermost (+) is at the right hand end
08:40:49 <Ezla> quicksilver: why not?
08:40:54 <quicksilver> Eduard_Munteanu: you can't evaluated it until you get to it.
08:41:00 <int-e> Ezla: maybe I should ask what you mean by 'static'.
08:41:14 <Eduard_Munteanu> quicksilver, oh, I see, thanks.
08:41:22 <dmwit_> Ezla: What is a static thunk?
08:41:22 <quicksilver> Eduard_Munteanu: (1+(2+(3+(4+(5+6)))))
08:41:34 <quicksilver> Eduard_Munteanu: can't evaluate "5+6" until you get that far in the list ;)
08:41:37 <Ezla> int-e: corresponding to a not yet existing value required by static code
08:41:37 <Eduard_Munteanu> quicksilver, yeah, starting with that initial value.
08:41:48 <int-e> Ezla: I'd expect only global constants to result in static thunks - allocated before the program starts running.
08:41:49 <Ezla> which is always the same
08:41:50 <quicksilver> Eduard_Munteanu: compare (((((1+2)+3)+4)+5)+6)
08:42:00 <quicksilver> Eduard_Munteanu: you can evaluate (1+2) before you even read the '3' from the list.
08:42:01 <dmwit_> Ezla: ...okay, what is static code? =P
08:42:04 <int-e> Ezla: everything that depends on a program argument, etc, can't be static.
08:42:04 <lilac> Ezla: i think you're referring to what we'd call a CAF
08:42:10 <Ezla> CAF?
08:42:26 <int-e> "constant applicative form" ... think of it as a constant
08:42:56 * Axman6 wonders why Goober is so silent now Ezla i asking all the hard questions...
08:43:02 <Goober> cause
08:43:09 <Goober> let Ezla do the work
08:43:15 <Goober> Ezla's more polite
08:43:20 <Ezla> No I'm not, really.
08:43:38 <lilac> your poor fractured mind! :(
08:43:51 <Ezla> lilac: lol ;)
08:43:59 <Eduard_Munteanu> quicksilver, but isn't the compiler supposed to order operations accordingly? I mean, why doesn't it transform it into (((((6+5)+4)+3)+2)+1) ?
08:44:14 <quicksilver> Eduard_Munteanu: the point is it don't know about the '5' until it gets to the end of the list
08:44:20 <quicksilver> Eduard_Munteanu: you want it to work with the beginning of the list first.
08:44:23 <dmwit_> Eduard_Munteanu: The compiler doesn't know that (+) is commutative!
08:44:32 <quicksilver> Eduard_Munteanu: then it can throw it away when it's done, and move on
08:44:32 <pizza_> oho
08:44:35 <Eduard_Munteanu> Oh, now I see.
08:44:37 <quicksilver> Eduard_Munteanu: -- uses less memory.
08:44:52 <Eduard_Munteanu> Thanks a lot.
08:44:55 <dmwit_> pizza_: aha! ehe! ihi, uhu!
08:45:16 <Eduard_Munteanu> quicksilver, you mean (--) instead of (+)? :o
08:45:16 <int-e> Ezla: and even then, take  nats = [1..]. Only the first cons will end up in a static thunk - the list elements and the other cons cells will end up on the heap (once their values are demanded).
08:45:26 <Ezla> Can you show an example of a CAF expression?
08:45:46 <Ezla> int-e: the first is the caf?
08:45:50 <Eduard_Munteanu> quicksilver, oh, nevermind, I read like a compiler :)
08:45:58 <dmwit_> Ezla: primes = 2 : nubBy (\x y -> y `mod` x /= 0) primes
08:46:01 <Axman6> , foldr mod 1 [1..10]
08:46:05 <lunabot>  luna: divide by zero
08:46:09 <int-e> Ezla: no, 'nats' is the caf - its value doesn't depend on any arguments
08:46:12 <Axman6> , foldr mod 2 [3..10]
08:46:14 <lunabot>  luna: divide by zero
08:46:22 <Ezla> int-e: ah
08:46:23 <Axman6> makes sense, heh
08:47:09 <Axman6> , let primes = 2 : nubBy (\a b -> mod a b == 0) [3,5..] in take 10 primes
08:47:11 <lunabot>  [2,3,5,7,11,13,17,19,23,29]
08:47:22 <Ezla> does GHC's collector 'move' ?
08:47:38 <Ezla> I don't mean the allocation pointer
08:47:40 <Eduard_Munteanu> Yup, now it works, no more swap meltdown.
08:47:52 <Axman6> , let primes = 2 : nubBy (\a b -> mod a b == 0) [3,5..] in foldr div 2 primes
08:47:58 <dcoutts> Ezla: it has a copying and a compacting garbage collector
08:47:58 <lunabot>  Killed.
08:47:58 <Axman6> wait, ha
08:48:08 <Axman6> , let primes = 2 : nubBy (\a b -> mod a b == 0) [3,5..] in foldr div 2 .take 100 $ primes
08:48:10 <lunabot>  luna: divide by zero
08:48:18 <int-e> Ezla: so, yes, it does.
08:48:30 <dmwit_> > let primes = nubBy (\a b -> mod b a == 0) [2..] in primes
08:48:38 <dmwit_> uh
08:48:40 <dmwit_> , let primes = nubBy (\a b -> mod b a == 0) [2..] in primes
08:48:43 <lunabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
08:48:51 <dmwit_> , let primes = nubBy (\a b -> mod b a /= 0) [2..] in primes
08:48:54 <Ezla> int-e: What does Haskell utilize the stack for?
08:48:58 <lunabot>  Killed.
08:49:01 <int-e> dmwit_: use gcd :P
08:49:02 <dmwit_> Ezla: It pretty much doesn't.
08:49:25 <Axman6> , let primes = 2 : nubBy (\a b -> gcd a b == 1) [3,5..] in primes
08:49:27 <lunabot>  [2,3,9,15,21,27,33,39,45,51,57,63,69,75,81,87,93,99,105,111,117,123,129,1...
08:49:38 <Axman6> , let primes = nubBy (\a b -> gcd a b == 1) 2:[3,5..] in primes
08:49:39 <lunabot>  luna: No instance for (GHC.Enum.Enum [a])
08:49:45 <quicksilver> it mostly does direct jumps which is one of the reasons compiling via C was such a nightmare, right?
08:49:46 <Axman6> , let primes = nubBy (\a b -> gcd a b == 1) (2:[3,5..]) in primes
08:49:49 <int-e> Ezla: uhm, I'd point you at the STG paper for that. It's really rather involved. But as a basic idea, evaluating nested thunks uses the stack.
08:49:50 <Ezla> I'm having trouble mapping the concept of a stack to Haskell
08:49:52 <lunabot>  Killed.
08:50:07 <Axman6> Ezla: you're better off not trying to
08:50:13 <Ezla> int-e: so the stack is the "thunk workspace"
08:50:28 <Axman6> you'll do much better if you think at a (much) higher level imo
08:51:10 <Ezla> Coming from C++, I pathologically avoid the heap. If I make use of the heap, I often consider it a bug.
08:51:19 <Ezla> Unless the code's back is against the wall
08:51:26 <Ezla> And is forced onto the heap
08:51:32 <dcoutts> Ezla: you'll have to change that to program effectively in Haskell
08:51:34 <lilac> do you write hard realtime systems?
08:51:41 <conal> Ezla: we breathe heap here
08:51:46 <lilac> or embedded code or similar?
08:51:54 <Ezla> The prospect of using the heap for everything hurts me inside
08:52:09 <vegai> didn't we already convince you about this? :)
08:52:16 <vegai> I remember trying at least
08:52:20 <Philippa> Ezla: most stuff's allocated inside a pool to start with. It's nowhere near the cost of new/delete
08:52:21 <lilac> Ezla: why specifically?
08:52:22 <Axman6> Ezla: you shouldn't care how your code's working at that level realy
08:52:31 <dcoutts> Ezla: that's because you're used to thinking of heap allocation as expensive. It's not in Haskell, it is in C++/
08:52:49 <quicksilver> Ezla: or is that because you're worried about resource management?
08:52:53 <quicksilver> (RAII etc)
08:52:58 <Ezla> not raii, no
08:53:02 <Ezla> only performance reasons
08:53:03 <dcoutts> Ezla: but certainly it's ok to think about whether something uses a linear or constant amount of memory. But the heap vs stack isn't the crucial point there.
08:53:05 * quicksilver nods
08:53:12 <quicksilver> Ezla: haskell heap is a single pointer increment
08:53:18 <Ezla> oh
08:53:18 <quicksilver> just link stack allocation on C++
08:53:21 <Ezla> you have a SuperStack
08:53:32 <quicksilver> occasionally it moves around, of course, when it gets full (GC)
08:53:41 <quicksilver> but in the common case, it's just a pointer increment.
08:53:48 <alar> why this
08:53:48 <alar> module Data.PSQueue
08:53:48 <alar>     (
08:53:48 <alar>     -- * Binding Type
08:53:48 <alar>     Binding((:->))
08:53:49 <alar> is ok and this
08:53:51 <alar> import	Data.PSQueue(Binding(:->))
08:53:53 <alar> is error?
08:54:02 <quicksilver> alar: Binding((:->))
08:54:16 <quicksilver> alar: (extra level of parens for operators)
08:54:30 <alar> @karma+ quicksilver
08:54:59 <alar> without you I'd spent lots of time wandering around this import
08:55:05 <Axman6> quicksilver: do you know who's able to do something about lambdabot?
08:55:28 <Ezla> Does GHC have plans to avoid freezing all threads during collection?
08:55:31 <Axman6> is it just Cale?
08:56:00 <dcoutts> Ezla: yes. In future, for minor collections, each thread will do it independently.
08:56:24 <Ezla> what's a "major" collection ?
08:56:31 <dcoutts> Ezla: for the major GC, all threads will stop and perform GC simultaneously. That bit is done already.
08:56:42 <Ezla> major gc?
08:56:52 <Ezla> so each thread has an instance, and then there's a global one
08:56:52 <dcoutts> Ezla: generational garbage collectors have minor and major collections
08:57:00 <Eduard_Munteanu> Hm, I was just looking for object-oriented Haskell variants, but it seems they are outdated. Are there any plans for ghc or such projects to support OOP?
08:57:13 <opqdonut> well no
08:57:14 <quicksilver> Axman6: I fear it's just cale.
08:57:17 <opqdonut> why would you want OOP?
08:57:23 <dcoutts> Ezla: there is a smaller per-thread first generation heap and a larger global heap.
08:57:33 <Eduard_Munteanu> opqdonut, hm... building GUIs in Haskell? :)
08:57:41 <quicksilver> Ezla: the latest version of GHC has a concurrent collector, so it at least uses all threads.
08:57:45 <dcoutts> Ezla: this is because most objects are short-lived.
08:57:49 <quicksilver> Ezla: (it does still freeze them though)
08:57:52 <Axman6> Eduard_Munteanu: what's what gtk2hs is for, and doesn't need OO :)
08:57:55 <Goober> Eduard_Munteanu: Haskell supports OO, but these nutjobs will claim it doesn't cause they don't like the phrase "OO" due to stigma
08:58:01 <Goober> in reality, it 100% does.
08:58:14 <opqdonut> well haskell is turing complete
08:58:20 <Philippa> Goober: it doesn't. You can do it in Haskell, but it doesn't support it any more than C does
08:58:22 <Eduard_Munteanu> Goober, well, I've seen stuff like constructors and so.
08:58:30 <Philippa> "support" means more than "it's possible"
08:58:30 <dcoutts> Eduard_Munteanu: you can encode almost all OO styles in Haskell relatively easily.
08:58:34 <Goober> Philippa: wrong.
08:58:35 <int-e> dcoutts: 'thread' is dangerously overloaded :)
08:58:42 <quicksilver> (in reference to Philippa's comment, I note that GTK is written in C in an OO style)
08:58:46 <dcoutts> int-e: yeah, I know :-(
08:58:47 <Axman6> Goober: how much haskell have you written again?
08:58:51 <opqdonut> quicksilver: exactly
08:58:52 <Ezla> quicksilver: concurrent collector?
08:58:59 <Ezla> how does that work?
08:59:08 <Saya> hmm is there a clean way to set one element in a list (immutable one) or do i have to do (take x-1) ++ v ++ (drop x)
08:59:12 <quicksilver> Ezla: I'm not sure exactly. each core looks through a different bit of heap ;)
08:59:18 <Eduard_Munteanu> dcoutts, my OOP-detector (:D): does it support polymorphism and virtual methods?
08:59:19 <quicksilver> Ezla: strikes me as clever stuff.
08:59:26 <Eduard_Munteanu> sorry, inheritance, not polymorphism
08:59:54 <dcoutts> Eduard_Munteanu: it really depends on the details of what you mean by that.
09:00:01 <Ezla> quicksilver: but still, they all do so at the same trigger moments?
09:00:06 <Philippa> Goober: do grow up, there's a dear. If you're going to tell someone they're wrong, you damn well explain why - Haskell has no specific OO support and no OO concepts in the language. It has an awful lot of concepts that can encode different OO styles easily, but you can do that in C too
09:00:07 <Ezla> Not at different times?
09:00:08 <int-e> Ezla: basically, the garbage collector works by creating a queue of objects that have to be copied. The parallel GC has several threads processing that queue.
09:00:35 <Philippa> and no, type classes aren't OO classes
09:00:37 <Eduard_Munteanu> dcoutts, can you derive a data type and have the derived methods be called instead of the base class' methods?
09:00:39 <Goober> Philippa, you're so trivial. Haskell's type system goes so far beyond C it's not even funny..
09:00:41 <opqdonut> Saya: no there's no quick way
09:00:46 <opqdonut> Saya: but take a look at zippers
09:00:50 <Philippa> Goober: no shit, I do type system research
09:00:52 <Axman6> wut?
09:00:55 <Goober> it can be used to simulate all kinds of OO-ish behaviours
09:01:05 <dcoutts> Eduard_Munteanu: eg do you think of the different objects as being different types, or just different values of the same type.
09:01:08 <Philippa> sure. And so can untyped languages
09:01:21 <Goober> Not in the same way.
09:01:23 <Eduard_Munteanu> dcoutts, different types.
09:01:24 <Goober> directly
09:01:24 <Philippa> Haskell no more supports subtyping than C does, however
09:01:26 <Axman6> Goober: so? that's not the same as Haskell having OOP stuff in it
09:01:32 <Ezla> what's zippers?
09:01:50 <Goober> haskell has OO stuff ;)
09:02:03 <quicksilver> Ezla: yes, it's still stop the world.
09:02:03 <dcoutts> Eduard_Munteanu: but you say that just because that's the way it's done in most OO languages (but not all, eg proto-type non-class based OO languages)
09:02:10 <lilac> Goober: it must be so nice for you being right all the time
09:02:11 <Eduard_Munteanu> Goober, as I see it, it's just like C + polymorphism
09:02:12 <quicksilver> Ezla: it's just stop-the-world-and-work-in-all-threads.
09:02:25 <quicksilver> Ezla: I know people have discussed not stopping the world.
09:02:25 <Philippa> Eduard_Munteanu: to be fair, closures make a difference
09:02:30 <Axman6> Goober: again, i'll ask, how much haskell have you written? just because you've read someone's blog on the subject doesn't make you, or them an expert.
09:02:35 <Saya> opqdonut: thx ill look into it
09:02:43 <Eduard_Munteanu> dcoutts, yeah, I'm biased towards C++-style OOP.
09:02:53 <Ezla> quicksilver: In Haskell, what's the fundamental thing requiring stop the world?
09:02:55 <blueonyx> hi
09:03:11 <quicksilver> Ezla: the fact that another thread might dereference a pointer to the bit you just moved.
09:03:14 <dcoutts> Ezla: it's a design choice, not a fundamental requirement.
09:03:28 <int-e> Ezla: it's not haskell, it's GHC and its RTS.
09:03:33 <quicksilver> Ezla: obviously you can fix that problem, but that's the basic issue.
09:03:44 <quicksilver> the various different ways of fixing it and how well they would perform are up for discussion.
09:03:54 <dcoutts> Ezla: it would be possible to make a concurrent collector but it'd probably be slower on average. So it's a design trade-off.
09:04:15 <quicksilver> it might be interesting, for example, to allow purely local collectiosn on the local nurserys
09:04:24 <quicksilver> and only global collect the higher generations.
09:04:27 <quicksilver> but it's not trivial.
09:04:33 <Ezla> How about: "we have segregated the following Half of our memoruy as provable that it will not move"
09:04:34 <Eduard_Munteanu> dcoutts, so am I correct to say there isn't any widely-adopted OO variant of Haskell?
09:04:36 <quicksilver> threads can gain references to things in each other's local nurseries.
09:04:41 <dcoutts> Eduard_Munteanu: so there are a series of increasingly complex encodings of OO in FP languages. The more of the funny properties that you need the more complex the encoding.
09:04:54 <quicksilver> Eduard_Munteanu: there is no need for a variant of haskell, per-se. YOu can encode it all in haskell.
09:04:59 <quicksilver> Eduard_Munteanu: there are choices about how you do so.
09:05:06 <Eduard_Munteanu> I see.
09:05:10 <mrd> OO isn't well defined, so it's hard to say what's in what
09:05:13 <quicksilver> YOu can look at the API choices made by the bindings to certain OO-libraries.
09:05:17 <dcoutts> Eduard_Munteanu: for the vast majoity of uses cases in an OO style people are only using a couple properties and so the encoding is simple.
09:05:18 <quicksilver> GTK and Wx spring to mind.
09:05:31 <quicksilver> the WX binding models subtyping using type parameters.
09:05:37 <Philippa> Ezla: you end up needing to leave that half allocated - so the tradeoff there's heap footprint
09:05:45 <blueonyx> http://hpaste.org/12750 what would this eq look like in terms of foldr?
09:05:47 <quicksilver> how does the GTK binding model subtyping, dcoutts ?
09:05:48 <Eduard_Munteanu> Well, it's more than what C provides. I just hope inheritance is more than simple composition (as one usually implements it in C)
09:06:01 --- mode: Philippa set -o Philippa
09:06:03 <int-e> Ezla: there are more complications. for example, the moment that you have two reachable copies of a thunk you risk duplicating work when two threads enter each copy. Or even the same thread enters first one copy, then the other one.
09:06:08 <dcoutts> quicksilver: classes and instances, the classes provide safe up and down casting.
09:06:18 <int-e> Ezla: this can not happen in the stop-the-world version of GC
09:06:47 <Eduard_Munteanu> quicksilver, oh, wxWidgets bindings for Haskell? Then it must be OO. :)
09:06:50 <Ezla> Alright, how about this simple proposition of a problem:
09:07:01 <Eduard_Munteanu> I love wxWidgets.
09:07:08 <quicksilver> dcoutts: erm, for example, I downcast a Button to a Widget. What are the types involved?
09:07:18 <int-e> (the parallel RTS as such has a similar issue, a race between two thread entering the same copy of the same thunk, but the time window for that scenario is much smaller. It does happen, but far less frequently.)
09:07:19 <Ezla> You guys asked me why I obsess over the stack, and why I hate the heap, and if I write real time systems
09:07:26 <Ezla> Not the real time systems you'd expect
09:07:28 <Ezla> but
09:07:47 <Ezla> I write audio code / sequencers  to enable my artwork to get done.
09:08:00 <dcoutts> Eduard_Munteanu: in my experience there are very few problems that are best solved using inheritance. And I say that having used OO style in quite a few programs.
09:08:00 <Ezla> If there is a SINGLE stop, it's 100% unacceptable
09:08:08 <Ezla> GC halts my audio thread
09:08:14 <Ezla> Click, click
09:08:25 <Ezla> And the callbacks happen in the interrupt.
09:08:44 <Ezla> every 0.75 ms
09:09:08 <camio> [a]->[b] has kind * -> * -> *, correct?
09:09:26 <dcoutts> camio: no, it's kind *
09:09:31 <quicksilver> camio: well if you mean a and b to be parameters, it does.
09:09:32 <Ezla> I'm uncertain of Haskell is even usable for my work
09:09:37 <Ezla> One single GC freeze makes it unusable
09:09:41 <Philippa> Ezla: force a GC at the end of the handler
09:09:44 <quicksilver> camio: type L a b = [a] -> [b]
09:09:49 <Eduard_Munteanu> dcoutts, yeah, I was mainly concerned about GUI applications. For non-GUI stuff, I usually code in C, so Haskell is a good enough alternative.
09:09:51 <quicksilver> camio: then "L" has kind * -> * -> *
09:10:08 <Ezla> Philippa: That just seems wrong to do...
09:10:11 <camio> I have an instace: instance Arm [] ([a]->[b]) where
09:10:11 <dcoutts> Ezla: so that kind of environment is a good example of where the perf tradeoff of a concurrent collector may make sense
09:10:32 <Ezla> can I make an "uncollected" Haskell thread
09:10:34 <quicksilver> camio: [a] -> [b] has kind *.
09:10:35 <Ezla> 100% not touched
09:10:39 <camio> Where the second parameter needs to have kind * -> * -> *.
09:10:40 <dcoutts> Ezla: no
09:10:41 <Ezla> out of the GC's jurisdiction
09:10:45 <int-e> Ezla: I'd expect to write the time critical part in C (running a separate OS thread), and providing a buffered interface which has less strict timing constraints. Then use FFI to bind that and go wild.
09:10:48 <camio> hrm
09:11:12 <Ezla> Is there a good lock-free queue for Haskell?
09:11:32 <Axman6> Ezla: have you tried writing any such code in haskell to see if your worries are actual issues?
09:11:33 <dcoutts> Ezla: right as int-e says, that doesn't necessarily mean that you couldn't use ghc with it's default GC. If there is enough buffering it could all be fine.
09:11:33 <Cale> In fact, that seems to be what people have done with the SuperCollider stuff.
09:11:46 <Axman6> Cale!
09:11:49 <Cale> hey
09:11:51 <Ezla> Axman6: Your question isn't reasonable
09:12:02 <Ezla> Axman6: consider, again, my problem domain
09:12:05 <Axman6> Cale: could you revive lambdabot please?
09:12:09 * Eduard_Munteanu goes looking at that OS kernel written in Haskell; it sounds like a good brain twister.
09:12:10 <Cale> I can try
09:12:21 <Ezla> saying "have you tried using Haskell when you have 0.75 ms callbacks" is way too predictable
09:12:23 <dcoutts> Eduard_Munteanu: right. The OO encodings that wxHaskell and Gtk2Hs use seem to be fine for OO-style GUI stuff.
09:12:25 <mrd> Ezla: do you use heap memory allocation in C ever?
09:12:25 <camio> quicksilver: I don't understand why it has kind *. Could you point me in the right direction?
09:12:29 <Philippa> Ezla: GC happens when the heap's full otherwise, making it happen more often reduces the max workload/GC time
09:12:50 <Ezla> mrd: I use pools in C++, and beyond that, I use nedmalloc
09:12:59 <Ezla> The pools do the job.
09:13:07 <Cale> okay, so the last 2 or 3 lambdabot crashes have been in the url module, so I think I'll turn that off, unless it's too much of a burden
09:13:22 <mrd> generational GC is very much like a style of pool allocation
09:13:37 <lilac> Ezla: fwiw, yours is a problem domain where i probably wouldn't consider haskell except as an experiment
09:13:38 <mrd> because short-lived objects are all discarded at once
09:13:48 <dcoutts> camio: (->) has kind * -> * -> * because it takes two type parameters
09:13:56 <lilac> Ezla: that said, it's an experiment i'm currently conducting
09:14:22 <Ezla> what're you doing lilac?
09:14:25 <dcoutts> camio: forall a b. a -> b has kind *, because the -> is fully applied
09:14:41 <lilac> Ezla: i'm writing a .mod player using conal's reactive library
09:14:54 <Axman6> .mod?
09:15:01 <mrd> good ol' mod files
09:15:06 <int-e> Philippa: hmm, I don't buy it. For the two-space collector, the GC time should be largely independent of the heap size - the working size is what matters - that's the amount of memory that gets copied. The generational collector should behave similarily for major GCs.
09:15:08 <Axman6> > 1+1
09:15:17 <lambdabot>   2
09:15:20 <Axman6> hoorah
09:15:21 <Ezla> neat, I write Mods, I'd even play you one :P
09:15:24 <mrd> Ezla: Axman6 is right though, you can't really know unless you try.
09:15:24 <lilac> Axman6: http://en.wikipedia.org/wiki/MOD_(file_format)
09:15:28 <vegai> lilac: whoa.
09:15:33 <camio> dcoutts: thanks
09:15:36 <vegai> lilac: is your source open?
09:15:36 <dcoutts> camio: like quicksilver said, if you have type L a b = [a] -> [b], then the kind of L is * -> * -> * because it has two simple type parameters
09:15:49 <Axman6> mrd: glad someone appreciates my input :)
09:15:50 <lilac> vegai: yes, but so far i've got not very far before running into reactive issues :)
09:16:10 <Ezla> what is Reactive?
09:16:23 <lilac> Reactive is a Functional Reactive Programming library for haskell.
09:16:38 <Axman6> event based functional programming
09:16:41 <Ezla> i've never even heard of reactive programming
09:16:44 <Ezla> oh.
09:16:45 <Axman6> well, not based
09:16:48 <camio> Ezla: http://netsuperbrain.com/blog/posts/introducing-reactive-events/
09:16:54 <conal> event based and continuous time
09:17:06 <Axman6> ah the man himself
09:17:28 <Axman6> Cale: thanks :)
09:17:35 <Cale> no problem :)
09:17:56 <Ezla> this is the Reactor pattern
09:17:59 <Axman6> @karma quicksilver
09:17:59 <lambdabot> quicksilver has a karma of 4
09:18:10 <Axman6> there was a quicksilver++ back there somewhere, so i'll make sure it gets through
09:18:11 <Ezla> done in FP
09:18:13 <Axman6> @karma quicksilver
09:18:13 <lambdabot> quicksilver has a karma of 5
09:18:24 <Goober> @karma Goober
09:18:25 <lambdabot> You have a karma of 0
09:18:26 <vixey> Ezla, no it's not
09:18:42 <pk> @karma lambdabot
09:18:42 <lambdabot> lambdabot has a karma of 2
09:18:44 <Ezla> How's it different from reactor?
09:18:46 <lilac> Ezla: that's the right kind of idea but it's more general than that
09:18:48 <pk> I hoped a crash
09:18:59 <lilac> Ezla: continuous time behaviours
09:19:21 <Ezla> does it have a concept of time?
09:19:33 <Ezla> You would not use that for a mod player--
09:19:47 <Ezla> ASIO or win32 or whatever sound API you use, provides your clock
09:20:08 <lilac> Ezla: as i said, it's an experiment to see whether it can work
09:20:16 <Axman6> Ezla: traditionally, sure. but us haskell types like to try new things ;)
09:20:19 <Philippa> Ezla: FRP's concept of time is what you feed it
09:20:35 <Ezla> It's not that it can't work, but more like -- there's no benefit except for "broken" from trying to make it work
09:20:42 <Ezla> the audio clock is PULL
09:20:44 <Ezla> not push
09:20:49 <Philippa> yes. That's fine
09:21:02 <lilac> Ezla: as is Reactive.
09:21:03 <quicksilver> there is no reasona  reactive implementation can't use an external source (like the audio clock) as its canonical time.
09:21:15 <quicksilver> in fact, that would be quite a big advantage in many cases.
09:21:17 <Philippa> in fact, that's been done already
09:21:23 <quicksilver> having a dependendable time source is nice.
09:21:30 <Ezla> by Pull I mean, ... you field the callbacks
09:21:39 <Ezla> so why would you need something with a concept of time
09:21:49 <lilac> to represent your audio signal
09:21:59 <Ezla> irrelevant
09:22:03 <Ezla> you represent it in chunks
09:22:09 <conal> lol
09:22:16 <Ezla> that's what the buffer is for
09:22:24 <vixey> hehe
09:22:27 <conal> guys, i'm not sure Ezla wants mind expanding today
09:22:33 * lilac giggles
09:22:39 <adimit> hey there. I'm using -Wall in my .ghci to better catch any errors and mistakes on my side, and get used to a clean style. I heard other people do this as well. How do you escape the warnings when using the (^) operator on Integers? 2^2 gives four warnings alone. That can be quite distracting.
09:22:39 <Axman6> heh, you remind me of this guy in some of my courses at uni
09:22:57 <Axman6> conal: he's made it obvious he doesn't want it ever i think :)
09:23:12 <lilac> Ezla: if i wanted to make a traditional .mod player this isn't the way i'd do it. that's entirely not the point.
09:23:30 <Ezla> can you explain your alternative to the buffer?
09:23:40 <vegai> lilac: what sort of issues you faced? Not fundamental ones, I guess?
09:24:05 <Ezla> conal: Go ahead and expound
09:24:14 <quicksilver> adimit: I don't think -Wall is quite useful enough for this purpose.
09:24:25 <lilac> vegai: no. bugs and space leaks
09:24:28 <quicksilver> adimit: it warns on too many things I consider quite acceptable, especially in ghci.
09:24:42 <vegai> lilac: I'm hungry for some real working code that uses reactive.
09:24:52 <lilac> vegai: plus further optimization of reactive will be necessary
09:24:54 <conal> Ezla: when i believe there's sincere curiosity on the other end, then i invest in explaining.  i'm not getting that impression so far.
09:24:55 <Saya> Little problem learning StateT here: i have functions using the State monad just fine but when inside the IO monad do i have to explicitely pass state around defying the purpose of the monad?
09:24:59 <vegai> the tutorial is pretty nice, but I cannot grasp the idea without an actual thing
09:25:01 <adimit> quicksilver: well, I think 2^2 is but one instance of that, I guess. So far, I found -Wall to be quite useful.
09:25:06 <Ezla> Conal: Fuck you?
09:25:11 <Ezla> I've only asked questions.
09:25:15 <Ezla> Can't possibly be more curious.
09:25:34 <vixey> Ezla, really.. that is not appropriate at all
09:25:34 <adimit> quicksilver: Do you have a good alternative (for a Haskell newbie)?
09:25:37 <camio> Ezla: I'd like to try to explain it to you if you're interested.
09:26:11 <Ezla> Anyways, I suspect, that since Haskell functions can have [0 to .... results, you're thinking in terms of synthesis towards a hypothetical Time value
09:26:25 <lilac> Philippa: does that count as three 'fu's?
09:26:35 <drdozer> haha, solving sudoku by brute-force isn't very efficient
09:26:48 <Ezla> ...but
09:26:49 <conal> Ezla: are you curious about how some people here got the impression that you're not very open to new ideas?
09:26:50 <Philippa> Ezla: the way you're putting your concerns doesn't suggest an open mind to a lot of people. Conal is perhaps more sensitive than some on the subject, but then he's had a lot of cases where someone really wasn't willing to listen enough
09:26:58 <Axman6> Ezla: geez, why do you have to swear at everyone who does something you don't like? grow up. conal is the one who wrote Reactive (along with quicksilver i think?) and he knows what he's on about, the least you can do is be plesant if you're not going to listen
09:27:21 <Ezla> because Conal is using meta-argumentation
09:27:26 <Ezla> Which is a sign of lack of genius
09:27:28 <Philippa> no, he's not
09:27:32 <Axman6> haha!
09:27:34 <Philippa> he isn't even arguing
09:27:34 <conal> Philippa: thanks.
09:27:37 <vixey> I don't know why #haskell it putting up with Ezla anymore
09:27:50 <Axman6> yeah, conal is one of the more stupid regulars here
09:27:52 <vegai> it's a republic, not a democracy :P
09:27:52 <Axman6> wow, classic
09:27:54 <Philippa> and one more line like "a sign of lack of genius" and I /will/ k/b you
09:28:11 <Philippa> because that is an insult, straight up
09:28:14 <vixey> Philippa, I respect your patience
09:28:24 <vixey> Philippa, That's definitely not the first insult Ezla has said. .
09:28:31 <Ezla> meta argumentation is where, rather than discussing the code and launching directly into it, you make Comments about the social aspect
09:28:34 <Axman6> Philippa: you've been dooing
09:28:43 <Ezla> I flow through a stream of speaking only in code
09:28:51 <Ezla> None of my questions are meta
09:28:55 <Axman6> doing something i've been accused many times of in #macosx, playing with your food ;)
09:28:57 <Philippa> Ezla: you can drop the patronising crap, too
09:29:02 <Philippa> we know what meta means
09:29:06 <Ezla> If you read the words of Cale, you'll notice that he'll never make a statement like Conal's
09:29:15 <vixey> Ezla isn't patronizing he just sounds like a teenager
09:29:17 <Saya> wooooooooohooooooooooooooo finally understood state/stateT :) but its lame that in the IO monad you have to pass around state explicitely
09:29:19 <Ezla> he is only oon topic
09:29:20 <Philippa> Cale is patient. Conal has a right not to be
09:29:32 <Philippa> and to explain why he isn't and why he isn't going to continue the discussion
09:29:34 <vegai> vixey: oh, I picture rather an old C+
09:29:35 <drdozer> congrats Saya
09:29:38 <vegai> ...+ geezer
09:29:41 <camio> Saya: awesome!
09:29:45 <Ezla> Simply, do not speak in meta arguments to be because I will flatly not read them.
09:29:46 <Philippa> note that you are also indulging in metadiscussion here
09:29:49 <Saya> lol :(
09:29:52 <Axman6> Ezla: you've proved to be very unreceptive, conal was perfectly justified in everything he said, so what are you on about?
09:29:58 <Ezla> And I do appologize for spamming the channel with the metaargument description.
09:30:13 <Cale> Saya: You don't. There are IORefs.
09:30:32 <Axman6> @src StateT
09:30:32 <Saya> well i use an IORef
09:30:32 <lambdabot> Source not found. Just try something else.
09:30:35 <Philippa> and that double standard is not appropriate for this channel. You don't get to insist that every discussion meet your standards
09:30:41 <Axman6> :t StateT
09:30:42 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
09:30:45 <Saya> that contains a grid (im trying to do a minsweeper in haskell)
09:30:55 <quicksilver> But nonetheless, all parties are correct that metadiscussion is not helpful.
09:31:02 <quicksilver> So, please, return to discussion of haskell.
09:31:10 <Philippa> quicksilver: I disagree. OTOH, it does have to happen in good faith
09:31:13 <Saya> and i do runStateT stuff on it but between the calls of runStateT i have to pass around the state
09:31:40 <Ezla> Every single comment of Axman6 for me so far is meta commentary, and then he says how "unreceptive" a guy asking questions for 2 hours is.
09:31:41 * Philippa waits for the inevitable, namely somebody building a meta^omega discussion
09:31:43 <Axman6> :t runStateT
09:31:44 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
09:31:55 <Ezla> he's said nothing about Haskell today
09:31:57 <Ezla> So, onward.
09:32:07 <int-e> Philippa: you mean, meta discussions suck? :)
09:32:10 <Ezla> camio: Hi
09:32:11 <Saya> Cale: or are you saying that my state should contain only IORefs?
09:32:28 <Philippa> int-e: eh, that's cheating :-)
09:32:50 <Ezla> camio: despite the controversy, would you try?
09:33:04 <Axman6> Ezla: i've said plenty about haskell today, but i've been frustrated by your total rudeness and lack of respect in here. if i were an op, you would have been banned a long time ago
09:33:06 <Ezla> boogey down
09:33:14 <Eduard_Munteanu> What is this, a meta-meta-discussion? That's Haskell alright.
09:33:17 <camio> Ezla: Sure. The idea is separate how we'd implement something from how we'd think about it.
09:33:25 <camio> s/is/is to/
09:33:29 <Ezla> Axman6: Invoke the herd
09:33:37 <Ezla> Another great sign of a great mind
09:33:43 <ArneB> Eduard_Munteanu: Now you made it a meta-meta-meta-discussion. Good job. ;)
09:33:53 <Eduard_Munteanu> ArneB, :))
09:33:53 <int-e> > fix ("meta":)
09:33:54 --- mode: ChanServ set +o Philippa
09:33:55 <lambdabot>   ["meta","meta","meta","meta","meta","meta","meta","meta","meta","meta","met...
09:33:56 --- mode: Philippa set +b *!*@cpe-76-172-169-17.socal.res.rr.com
09:34:01 --- kick: Ezla was kicked by Philippa (You were warned)
09:34:05 <Cale> Saya: oh, I don't mean that. I just mean that IORefs are a way to get state implicitly to various places in IO code
09:34:10 --- mode: Philippa set -o Philippa
09:34:13 <conal> Ezla: i really didn't mean anything personal with my comment about "when i believe there's sincere curiosity on the other end" to help you give you clue about what it might take for me to want to spend time explaining to you.  I thought you might take me up on it.
09:34:14 <Axman6> i think a great mind is one that listens to the answers to the questions they ask
09:34:21 <Axman6> meh
09:34:25 <Axman6> thanks Philippa
09:34:35 <conal> oh, i was a bit too late.
09:34:39 <conal> yes, thanks Philippa
09:34:42 <Philippa> Axman6: OTOH, I don't approve of your baiting there
09:34:55 <camio> Ah, brother. I was really hoping to give a try explaining FRP.
09:35:06 <vixey> camio, I'm listening :p
09:35:13 <conal> heh
09:35:24 <drdozer> right, 5 min for brute-force sudoku solver, and still not completed - time to terminate it and try another approach
09:35:42 <conal> i've experienced explaining to people who talk like Ezra.  turned out to be a waste of my time.
09:35:50 <Cale> Saya: If you don't like passing around IORefs, you can use a reader monad with a record containing IORefs.
09:35:59 * paolino put on logging on camio explanation
09:36:05 <camio> Explaining it to someone helps me understand it sometimes. That's my interest.
09:36:26 <camio> I'll continue hoping someone can gain something :)
09:36:36 <Axman6> camio: teaching is supposed to be the most effective way of learning a topic, so... there ya go
09:36:51 <Cale> Saya: The way you're describing using StateT makes me wonder if your StateT computations are a little too small. If you're passing the state explicitly from one runStateT to the next, you're probably doing something wrong.
09:37:06 <Axman6> it's 4:36AM here, but i'd quite like to hear how FRP works too
09:37:09 <camio> So with an audio player, in implementation terms, I would think of buffers and lists and other details.
09:37:43 <camio> In thinking terms, I know an audo stream is a function of time.
09:38:06 <camio> It is continuously changing in amplitude and frequency.
09:38:10 <Saya> Cale: well i dont do in a statet computation for now but that should change. Basically i call a runStateT every time the user clicks a button so between clicks i have to pass around state (which is only at one place so isnt that much hard). How would you do it?
09:38:32 <Cale> Saya: Ah, that's fair.
09:38:34 <camio> So FRP is an attempt to provide a programmer interface that reflects how I think about it. Buffers, lists, and other implementation details are hidden.
09:38:46 <lilac> conal: your response to Ezra wasn't wasted. *looks at Goober*
09:38:53 <Cale> Saya: However, probably a shared IORef could avoid StateT altogether.
09:38:54 <Eduard_Munteanu> Is there a Fruit-like wxHaskell binding for wxWidgets? I found wxFruit, but the site's down or something.
09:38:59 <Axman6> heh
09:39:21 <camio> And if FRP works well, my code looks like my thought process directly instead of showing implementation details. done. ;)
09:40:05 <Cale> Saya: Generally, depending on the details of your GUI library, you'll define an IORef just above where you're setting up all the event handlers, and then pass it along into the ones which need access to that state.
09:40:26 <Cale> (Or pass a partially applied version of read/writeIORef)
09:40:32 <Saya> *dont do much
09:40:43 <vaskaren> can monads be parallellized?
09:40:51 <Cale> vaskaren: Mu. :)
09:41:39 <Cale> vaskaren: Monads are type constructors... there are various specific monads whose computations can be parallelised to varying extents.
09:42:06 <Cale> vaskaren: But it's a bit like asking "can libraries be parallelised?"
09:42:08 <opqdonut> for example a parallel list monad would be very possible
09:42:21 <vaskaren> and can i say to ghc: run all the pure stuff in this program in parallell or do i have to explicitly program for multiple cores?
09:42:27 <vaskaren> Cale: I see, but how does ghc know if t can be safely parallellized? some builtin monads for can you annotate monads for parallellism?
09:42:34 <Saya> Cale: ok :) i guess StateT makes more sense in a "continuous" setting
09:42:44 <opqdonut> vaskaren: there's no automagic parallelisation
09:42:46 <Cale> vaskaren: Parallelism is not automatic.
09:42:56 <opqdonut> but there is "easy" parallelisation with par and pseq and so on
09:43:03 <opqdonut> and Strategies
09:43:03 <vaskaren> could there be?
09:43:12 <Cale> vaskaren: It's too hard for the compiler to figure out which chunks are large enough to be worth doing in parallel.
09:43:22 * mlesniak did a parallel quicksort just a few minutes ago ;-)
09:43:29 <Saya> Cale: here i read the grid, modify it and then i have to copy all back into the ioref so its not that efficient :/ but i nearly killed myself trying to do an array of arrays of IORefs
09:43:40 <EvilTerran> vaskaren, the trouble with doing parallelisation nicely with a monad is that the RHS of >>= is completely abstract
09:43:43 <EvilTerran> (being a function)
09:43:44 <Cale> Saya: You know about MArray, right?
09:43:44 * conal returns.  reads scrollback.
09:43:52 <vaskaren> rhs?
09:43:57 <EvilTerran> "right hand side"
09:43:57 <opqdonut> right hand side
09:44:38 <EvilTerran> it'd be easier to make, say, an Arrow instance that did parallelisation
09:44:51 <conal> camio: i love your explanation.  thanks!
09:44:58 <Saya> Cale: Hehe :p yeah well my objective was to learn how to use reader/writer/state and basic monad transformers so nevermind. ^^ but yeah i should use mutable array :p
09:45:20 <Eduard_Munteanu> conal, I see you're the guy that worked on Fruit. Are you aware of any Fruit-like wxWidgets binding for Haskell? I'm familiar with wxWidgets (Fruit itself is unknown to me).
09:45:54 <Cale> Saya: The other option is to keep a pure datastructure which has more efficient updates, like possibly a Data.Map
09:46:07 <Cale> (more efficient than an immutable array)
09:46:27 <camio> conal: :)
09:46:28 <conal> Eduard_Munteanu: antony courtney did the fruit implementation and might know if there's a descendent.
09:47:22 <Eduard_Munteanu> Cale, wouldn't using divide-et-impera on a list be a good candidate for automatic paralelisation? Or has it been at least tried/researched?
09:47:27 <Eduard_Munteanu> conal, thanks.
09:47:54 <Cale> Eduard_Munteanu: The trouble tends to be with the list structure itself.
09:48:01 <edwardk> conal: are you sure the definition of dup from your post should contain [mempty] and not []? it seems to go to dangerous places in terms of the comonad laws
09:48:07 <Cale> Eduard_Munteanu: Lists are only quickly accessible from the beginning.
09:48:25 <kazimir> hey guys...got a question
09:48:38 <conal> edwardk: i'm certainly not certain
09:48:40 <solussd> waht is the difference between map and MapM_
09:48:55 <Cale> Eduard_Munteanu: Otherwise, it works well -- the nested data parallelism stuff defines parallel arrays, and computations on those are automatically broken up and balanced across processors.
09:49:07 <Axman6> :y mapM_
09:49:10 <Axman6> :t mapM_
09:49:10 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
09:49:12 <Zao> solussd: One applies a function to each element of a list, yielding a list of the results.
09:49:16 <edwardk> conal: k, i'd just look at it from a base case perspective. i think its an error, but feel free to find a reason why I'm wrong ;)
09:49:33 <Axman6> :t map
09:49:33 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:49:36 <kazimir> i want to call a function (func x y) for every item where y is the item
09:49:46 <Zao> solussd: The other one maps an action to a list of thingies, and yields a list of actions that are sequentially evaluated and the results thrown away.
09:49:48 <Eduard_Munteanu> Cale, the Haskell wiki says enabling SMP paralelism without using 'par' doesn't provide any benefit, AFAICS.
09:49:52 <Cale> solussd: mapM_ carries out a bunch of actions based on the contents of a list, and throws away their results. map takes a function and a list and produces a new list by applying the function to each element.
09:50:07 <kazimir> item in a list
09:50:07 <solussd> thanks
09:50:13 <Cale> Eduard_Munteanu: Apart from possibly threaded GC.
09:50:15 <conal> edwardk: i'd like for you & others to offer critiques & suggestions on my posts.  it's a big part of why i'm posting. to get help with steering.
09:50:17 <Zao> mapM_ is map and sequence_ with some duct tape.
09:50:31 <Eduard_Munteanu> Cale, I see.
09:50:35 <kazimir> i want to call a function (func x y) for every item in a list where y is the item...now its correct
09:50:48 <Cale> kazimir: map (func x) myList
09:50:51 <Eduard_Munteanu> kazimir, map
09:51:08 <kazimir> i tried but i get a [[]]
09:51:13 <kazimir> but want to have []
09:51:14 <edwardk> conal: oh you'll probably get a laugh out of this. i spent about 3 hours this morning going through a painstaking derivation that wound up with me deriving the exact same thing as you're using in Reactive for Behaviors just with different type names. not much progress there ;)
09:51:24 <Cale> kazimir: Maybe you want concatMap ?
09:51:29 <conal> edwardk: lol
09:51:29 <Cale> kazimir: It's hard to tell.
09:51:40 <conal> edwardk: thx for the confession. :)
09:51:43 <kazimir> concatMap... i will take a look at it
09:51:52 <Cale> kazimir: That means your input list was one element and the result of applying that function to the one element was an empty list.
09:52:05 <conal> edwardk: meanwhile, i'm moving on to another definition.
09:52:14 <Cale> kazimir: map never changes the number of elements in the list
09:52:22 <kazimir> ah i see
09:52:37 <Eduard_Munteanu> kazimir, you should probably show us the type of func
09:52:59 <kazimir> its very complex now
09:53:12 <Eduard_Munteanu> and of course, the type of myList.
09:53:18 <kazimir> im trying to do a eulerTour :D
09:53:32 <kazimir> theres something like:
09:53:41 <kazimir> find_tour(u):
09:53:42 <kazimir>  for each edge e=(u,v)
09:53:42 <kazimir>   find_tour(v)
09:54:07 <kazimir> and i got a problem translating for each to haskell
09:54:57 <Cale> Eduard_Munteanu, vaskaren: The nice thing about pure parallelism annotations is that while they're not totally automatic, you can add them to your program without changing the program's semantics.
09:55:16 <kazimir> but concatMap helped me i think
09:55:34 <opqdonut> kazimir: you might want to have a look at the list monad
09:56:09 <Cale> The primitive is called par, and (par x y), when evaluated, causes x to be placed in a queue of values to be evaluated on some processor if there is free time, before resulting in y.
09:56:20 <Eduard_Munteanu> Cale, the good side is Haskell isn't just another no-brainer for Mathematicians, like FORTRAN.
09:56:31 <Eduard_Munteanu> s/Mathematicians/mathematicians
09:56:42 <Cale> So it behaves just like (\x y -> y) with regard to semantics, but affects performance of course.
09:57:21 <Cale> Eduard_Munteanu: I wouldn't think of FORTRAN as a no-brainer for mathematicians. It's likely harder to learn than Haskell for them. :)
09:57:42 <Cale> Haskell has the astoundingly nice property that functions are actually functions.
09:57:45 <edwardk> conal: oh another random categorical tidbit, since Futures are adjoint to Behaviors, you can show that you can derive: instance Representable Behavior Time, which sounds pretty deep, but basically says you can use at and an inverse for it to go back and forth to B a from Behavior a
09:57:55 <iabal> Cale, but have another complex things ;P
09:58:01 <Axman6> Eduard_Munteanu: you can use par like: fib 0 = ; fib 1 = 1 fib n = l `par` r+l where l = fib (n-1); r = fib (n-2);
09:58:15 <Axman6> uh, yeh sif the fib formula, and she'll be right
09:58:19 <Axman6> fix*
09:58:19 <edwardk> but it puts the B a <-> Behavior a on a firmer theoretical footing
09:58:28 <Axman6> can anyone tell it's 5AM here?>
09:58:37 <Cale> Axman6: Too much coffee, or not enough yet?
09:58:45 <Cale> ;)
09:58:53 <vixey> you stick `par` in a few places and the program runs slower
09:58:54 <conal> edwardk: "Representable"?
09:58:55 <Axman6> i don't drink coffee... maybe i should :P
09:58:55 <Beelsebob> Axman6: assuming ofc you want to randomly use an inefficient fib in parallel, rather than an efficient one :P
09:59:05 <Axman6> Beelsebob: yes :P
09:59:06 <Zao> @time Axman6
09:59:09 <lambdabot> Local time for Axman6 is Sat Dec  6 04:59:07 2008
09:59:20 <Axman6> quit it!
09:59:38 <Zao> CTCP HUG? :)
09:59:39 * Axman6 isn't sure why he got that twice
09:59:47 <Axman6> yus pls :(
09:59:48 <Zao> Tried it in private with the bot first.
09:59:55 <edwardk> conal: http://comonad.com/haskell/category-extras/src/Control/Functor/Internal/Adjunction.hs contains the definition, look up 'Representable functor; http://en.wikipedia.org/wiki/Representable_functor
10:00:05 <Eduard_Munteanu> Axman6, yeah, to think about it, it's not such a hassle.
10:00:22 <edwardk> plug in Behavior and Time into the types for rep and unrep and it should be obvious what it is saying
10:00:24 <Axman6> ah
10:00:24 <Axman6> all is forgiven then
10:00:33 <Axman6> Eduard_Munteanu: there's also stuff like parMap, which is quite handeh
10:00:55 <Eduard_Munteanu> Cale, probably, math-people have no coding standards, no best practices, but they do understand functional descriptions.
10:00:57 * Cale is drinking a cappuccino with probably about twice as much espresso as a cappuccino would normally have. :)
10:01:05 <conal> edwardk: thx for the pointers.
10:01:25 <Cale> Eduard_Munteanu: The nice thing about Haskell is that it largely enforces the important coding standards.
10:01:30 <opqdonut> Cale: I prefer "doble cortado" too
10:01:33 <Eduard_Munteanu> Axman6, does that spawn a thread for each element in the list? oO
10:01:36 <edwardk> conal: i just keep poking at the types until they tell me what to do ;)
10:01:39 <opqdonut> (the spanish equivalent of a strong cappucino)
10:01:47 <Axman6> Eduard_Munteanu: well, a spark
10:01:54 <opqdonut> just finished a cup
10:02:02 <Cale> :)
10:02:24 <opqdonut> dl for my bachelor's dissertation/thesis/whatever in 4 hours
10:02:32 <Eduard_Munteanu> Axman6, yeah, but that's useful in special situations, like lists of lists to think of it.
10:02:37 <conal> edwardk: cool.  me too.  and i haven't yet learned some of the dialects you recognize.  i appreciate the extra ear.
10:02:49 <Axman6> Eduard_Munteanu: yup
10:02:53 <Saya> Cale: voila works with Data.Map :)
10:03:13 <thetallgu1> Anyone here good with SYB with Class?
10:03:24 <edwardk> conal: its ok, one of these days i'll finally 'get' FRP ;)
10:03:51 <ddarius> conal: I mentioned this before but I'm not sure you got it, but Functor type class morphisms are free (modulo seq).  Any semantic function (not using seq) will automatically be a Functor type class morphism and also immediately validate the functor laws.
10:04:08 <Saya> Cale: thanks for the help, cya!
10:04:19 <edwardk> the other thing is the future/behavior adjunction gives rise to the State Time monad and Context Time comonad, which seems to be deep somehow. i'm trying to figure out if i can explain FRP as working with half of the context comonad or half of the state monad at a time
10:04:27 <Eduard_Munteanu> Axman6, it'd be useful to be able to spawn a number of threads proportional to the number of CPUs in the system.
10:04:41 <Axman6> Eduard_Munteanu: that's what happens i believe
10:05:08 <Cale> Actually, it must be specified on the commandline.
10:05:08 <Axman6> GHc's parallelism stuff is very nice stuff ;)
10:05:14 <Eduard_Munteanu> Crap, we're going to see new fork bombs: parMap [1..]
10:05:18 <conal> ddarius: do you mean any seq-less definition of fmap that type-checks has to be natural?
10:05:28 <Cale> +RTS -Nk  where k is the number of OS threads to execute Haskell code on.
10:05:33 <edwardk> conal: er and yet another thing, i couldn't get typecompose to build it complained about my type for arrows when trying to build data.bijection, is the version on hackage old or will it build correctly against 6.10?
10:05:33 <ddarius> conal: Of the semantic function, yes.
10:05:41 <Cale> This is independent of the number of Haskell threads which are created.
10:06:08 <conal> ddarius: oh, yeah.
10:06:11 <Axman6> Eduard_Munteanu: it's smarter than that
10:06:18 <Eduard_Munteanu> > parMap sin [1..]
10:06:20 <lambdabot>   Couldn't match expected type `a -> Done'
10:06:22 <Cale> (The GHC threaded runtime contains an N:M scheduler for scheduling the work of N Haskell threads onto M OS threads.)
10:06:35 <Eduard_Munteanu> Well, I had to try it.
10:06:37 <conal> edwardk: the latest typecompose builds for me on 6.10.  would you send me details?
10:06:52 <Cale> > parMap rnf (map sin [1..])
10:06:53 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
10:07:00 <edwardk> sure i'll try to build it again, but it blew up for me on two boxes
10:07:01 <Cale> er, I should actually check the type :)
10:07:03 <Cale> :t parMap
10:07:04 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
10:07:08 <Cale> ah
10:07:13 <Cale> > parMap rnf sin [1..]
10:07:13 <Axman6> Eduard_Munteanu: you shoudl check out http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html
10:07:19 <Eduard_Munteanu> > parMap (\x -> x*x) [1..]
10:07:22 <lambdabot>   mueval: Prelude.read: no parse
10:07:25 <lambdabot>   Couldn't match expected type `a -> ()' against inferred type `[a1]'
10:07:33 <Axman6> :t parMap
10:07:35 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
10:07:40 <Cale> You need to supply a strategy for evaluating the elements.
10:07:46 <Axman6> Eduard_Munteanu: it takes a third function
10:07:57 <Axman6> or, strategy
10:08:07 <Axman6> :t rnf
10:08:08 <lambdabot> forall a. (NFData a) => a -> Done
10:08:29 <Axman6> > parMap rnf (^4) [1..]
10:08:36 <lambdabot>   mueval: Prelude.read: no parse
10:08:38 <Cale> Of course that won't finish.
10:08:39 <conal> ddarius: i didn't get it before, and i probably don't now.  do you mean that i can define fmap and meaning however i want (without using seq), and 'meaning . fmap h == fmap h . meaning' will be true?
10:08:39 <conal>  
10:08:52 <Axman6> > Control.Concurrent.parMap rnf (^4) [1..]
10:08:53 <Eduard_Munteanu> Cale, but it would be a hell of a fork-bomb
10:08:55 <lambdabot>   Not in scope: `Control.Concurrent.parMap'
10:08:55 <Cale> It strictly evaluates the spine of the list, so it won't work with infinite ones.
10:09:13 <iabal> Eduard_Munteanu, you need parListChunk
10:09:32 <conal> ddarius: and i love blog comments.  you don't have to register.
10:09:38 <Cale> Eduard_Munteanu: It's more just a memory leak. Lots of work gets put on the queue, but it never finishes traversing the list.
10:09:40 <Axman6> @src parMap
10:09:40 <lambdabot> Source not found. That's something I cannot allow to happen.
10:09:51 <Axman6> @src Control.Concurrent.parMap
10:09:51 <lambdabot> Source not found. My pet ferret can type better than you!
10:09:51 <Cale> (so you never get to see any of the results)
10:09:59 <iabal> :t parListChunk
10:10:01 <Cale> It doesn't actually create threads.
10:10:02 <lambdabot> forall a. Int -> Strategy a -> [a] -> Done
10:10:13 <ddarius> conal: Yes.
10:10:23 <Axman6> shit, the sun's rising
10:10:27 <Eduard_Munteanu> I see.
10:10:44 <ddarius> conal: It's a consequence of parametricity.  It is, in fact, exactly the free theorem for a polymorphic function.
10:11:05 <Cale> (par x y) puts x into a work queue shared across the (generally fixed number of) worker threads.
10:11:06 <conal> ddarius: wow.  i've got a lot to learn.
10:11:08 <thetallgu1> Axman6: where does that put you?  Hawaii?
10:11:20 <Axman6> australia
10:11:27 <Stephan202> Summertime, even
10:11:39 <Axman6> dman, i can't even tell if i spelt that right. i need sleep. night all
10:11:42 <Eduard_Munteanu> Cale, ah, then it sounds reasonable.
10:11:57 <Axman6> Eduard_Munteanu: it's very reasonable
10:12:44 <vixey> @free fmap
10:12:46 <lambdabot> Expected variable or '.'
10:12:48 <vixey> :/
10:13:04 <ddarius> @free reverse
10:13:04 <Axman6> Eduard_Munteanu: http://hackage.haskell.org/packages/archive/parallel/1.0.0.1/doc/html/Control-Parallel-Strategies.html
10:13:05 <lambdabot> $map f . reverse = reverse . $map f
10:13:15 <Cale> But of course, par forces the programmer to know which chunks are the right size to do sequentially.
10:14:04 <Cale> The nested data parallelism stuff still requires the programmer to express what should go in parallel, but makes some of the choices about chunking for you.
10:14:35 <ddarius> @free seq
10:14:36 <lambdabot> g . seq x = seq (f x) . g
10:16:29 <edwardk> i keep thinking the current spark stuff is just flawed and would be better served with something that basically just maintained a work stealing deque  that pointed into the stack with a slow path for stolen work ala cilk then par's that happened when there weren't cores free would mostly just come for free.
10:17:27 <edwardk> which would work pretty much orthogonally to the ndp stuff, etc. just like the existing spark mechanism does now, the problem is its a very invasive change
10:18:19 <edwardk> (mainly because you have to compile bost fast and slow paths)
10:18:24 <edwardk> er both
10:18:41 <Axman6> edwardk: well get to it and write it (or at least a paper ;)
10:19:00 <edwardk> axman: actually i have been, but its been for a very different compiler
10:19:20 <Axman6> i see. which compiler?
10:20:33 <edwardk> i have a compiler for a toy language called kata, haskell + views + sessions - static types, with a weird tracing jit
10:20:54 <edwardk> so the approach i'm implementing there lets me let the jit optimize out the fast path, which doesn't work in a ghc like setting
10:21:44 <edwardk> and yes i realize that 'haskell - static types' doesn't leave a lot behind ;)
10:22:11 <ddarius> It leaves an applied untyped lambda calculus.
10:22:29 <thomashartman1> I need some advice. I am creating an out-of-the-box solution for web 2.0 type apps using haskell and HAppS. (happstutorial.com)
10:22:38 <thomashartman1> Obviously this requires some way to send email for verifications.
10:22:46 <edwardk> ddarius: well, in my case it leaves a sea of constructors and open extendable functions
10:22:54 <thomashartman1> The way I've done this when doing something similar for perl and python is to just use gmail as an smtp server.
10:23:06 <thomashartman1> there are libs that make this just 2 minutes of cut and page.
10:23:09 <edwardk> ddarius: and a lot of trickery to get back the utility lost with typeclasses, etc.
10:23:11 <thomashartman1> paste.
10:23:22 <pk> instance (someClass a) => otherClass a where ..
10:23:28 <pk> is that possible ?
10:23:37 <pk> ghc 's giving me errors
10:23:40 <thomashartman1> It seems there are no haskell libs for email -- well, haskellnet, but it's apparent abandonware
10:23:57 <thomashartman1> I'm not an email expert, I just want to get the job done and move on.
10:24:05 <edwardk> pk: case on someClass and otherClass like that or like SomeClass, OtherClass?
10:24:06 <conal> Reflecting over Ezla's reaction to my remark about curiosity ("... when i believe there's sincere curiosity on the other end ..."), my sweetie Holly reminded me that I use the word "curiosity" in a specific way that's probably different from Ezla's.  I guess to him asking questions is curiosity.  While I meant an eagerness to release one's own preconceptions and explore a different perspective.
10:24:15 <mmorrow> nice, gtk2hs just compiled flawlessly on ghc-6.10.1
10:24:24 <thomashartman1> It seems to me that my options are use sendmail, or implement something similar to what perl/python have where you use an external smtp server.
10:24:41 <thomashartman1> Sendmail would be okay but when I google on it I see a lot of worry about security.
10:25:08 * edwardk is trying very hard not to make a joke that his perspective is affine where it is.
10:25:41 <pk> edwark, what do you mean ?
10:25:53 <Saizan> edwardk: sessions in which sense?
10:26:07 <edwardk> affine vs. perspective... nevermind ;)
10:26:42 <edwardk> saizan: enforced 2 party channel protocols.
10:27:20 <Eduard_Munteanu> Cale, I assume one could define a variant of par that first checks the chunk size to see if it's worth parallelizing.
10:27:31 <edwardk> saizan: basically i force the process to get those right and i don't care about what it does inside for the most part
10:27:33 <Saizan> edwardk: ah, so you've a type system for that?
10:27:48 <edwardk> saizan: yeah, its a bit schizophrenic ;)
10:27:51 <thomashartman1> Do you think it's worth implementing something like the perl/pythionish modules that let you call an external smtp server, or is just using sendmail all the time basically okay?
10:28:02 <thomashartman1> Surprised actually that nobody seems to have done this yet.
10:28:11 <Cale> Eduard_Munteanu: The trouble is to determine whether an expression is worth evaluating in parallel, you need to have some idea of how long it will take to evaluate.
10:28:12 <Zao> thomashartman1: sendmail on Windows will be hard.
10:28:17 <edwardk> saizan: and to be honest you can't get effects without using the right monads, etc. but nothing really prevents you from inspecting stuff you really shouldn't
10:28:24 <thomashartman1> Not an issue, I'm on unix
10:28:40 <Cale> Eduard_Munteanu: and computing that is very hard (i.e. impossible)
10:28:40 <thomashartman1> and users of my out of the box web web 2.0 can use unix
10:29:18 <Saizan> edwardk: not having types you don't have abstract types either, is that the point?:)
10:29:19 <pk> Is it possible to make instance declarations for every type that obey some interface ?
10:29:31 <pk> like for every num
10:29:37 <thomashartman1> So basically, would you say smtp libs haven't been implemented because sendmail is good enough to get the job done?
10:29:40 <Cale> Eduard_Munteanu: You could have a runtime system which records the amount of time various expressions took to compute in previous runs, but that's still quite tricky.
10:29:44 <pk> or do I have to declare each one in turn ?
10:30:14 <Cale> pk: You can do it with the undecidable instances extension.
10:30:23 <edwardk> saizan: pretty much. technically they are there but i don't like to talk about them, they mostly come in the form of what kinds of patterns have been bound by the function so far to make it so that extensions to a function definition across multiple modules are consistent and don't change existing behavior
10:30:40 <pk> Cale: thx
10:30:42 <edwardk> er they in this case being types
10:30:59 <Saizan> edwardk: btw, is the compiler available to the public?
10:31:35 <edwardk> saizan: it will be, i've been sort of side tracked into the jit
10:34:32 <Eduard_Munteanu> My net connection was out for a while.
10:35:44 <Eduard_Munteanu> Cale, yes, I meant you could use par if the number of elements is greater than a heuristic threshold.
10:36:30 <Eduard_Munteanu> nothing more elaborate, since I understand it's quite a difficult problem.
10:36:36 <Cale> There are things like parChunkList which let you do that, but it's often hard to know what the right chunk size is.
10:47:52 <quicksilver> conal: I think I have managed to reduce my recursion problem to a much simpler case.
10:48:19 <quicksilver> conal: are you around to discuss?
10:50:28 <Surma> Guys, I have a list of tuples (Int, Int). Is there some way to use ``elem'' with only checking out one part of the tuple? (or is there a special function for that)?
10:50:52 <quicksilver> Surma: find
10:50:56 <quicksilver> :t find
10:50:57 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
10:51:07 <quicksilver> Surma: hmm. not quite actually.
10:51:10 <quicksilver> :t any
10:51:11 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
10:51:27 <Surma> k thx
10:51:33 <quicksilver> Surma: that's is. "elem 4" is the same as any (\y -> y == 4)
10:51:40 <quicksilver> you can genearlise the second form
10:51:40 <tromp> @src elem
10:51:41 <lambdabot> elem x    =  any (== x)
10:51:53 <quicksilver> to "any (\(x,y) -> x == 4)
10:51:56 <quicksilver> etc.
10:52:26 <tromp> any ((==4).snd)
10:53:10 <Surma> gotta love haskell for '.' ;)
10:55:47 <drdozer> Surma: and $
10:58:03 <quicksilver> @tell conal The simple recursive definition "let e = ev `mappend` e" is sufficient to demonstrate the problem. This may not be very useful, but it clearly should not be _|_.
10:58:04 <lambdabot> Consider it noted.
11:00:00 <lilac> quicksilver: where ev is an event?
11:00:08 <conal> quicksilver: i'm here.  was on another screen.
11:00:09 <lambdabot> conal: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:00:27 <quicksilver> lilac: yes, any arbitrary event.
11:00:37 <quicksilver> lilac: that should yield an infinitity of simultaneous copies of 'ev'
11:00:39 <lilac> doesn't that give you omega events at the same instant?
11:00:46 <quicksilver> it does, but it should still "work"
11:00:52 <lilac> how is it to tell which one happens first in finite time?
11:00:54 <quicksilver> I should be able to observe any finite number of them
11:01:00 <quicksilver> lilac: mappend is supposed to be left-biased.
11:01:09 <quicksilver> so the "original" ev one should be produced "first".
11:01:30 <lilac> right, but...
11:01:31 <Cale> hmm
11:01:55 <Cale> The last value produced by the event at any future time will be _|_ though.
11:02:01 <lilac> foldr mappend ev (replicate 10000 e ++ e2)  will clearly be slow
11:02:14 <conal> quicksilver: interesting.  how about this question: what's ev `mappend` _|_ ?
11:02:43 <drdozer> are there going to be any haskell events in the UK in the next few months?
11:02:53 <conal> if the answer is bottom, then bottom is a fixpoint of 'mappend ev'
11:02:59 <conal> and so it's the least fixpoint
11:03:31 <lilac> neat proof :)
11:04:02 <quicksilver> conal: Oh, interesting.
11:04:40 <conal> also monotonicity says that 'ev `mappend` bottom [= ev e' for every e
11:04:54 <lilac> quicksilver: the 10000'th event in a chain of `mappend` could be earlier and it can't know that
11:04:54 <conal> oops
11:05:05 <conal> 'ev `mappend` bottom [= ev `mappend` e' for every e
11:07:09 <quicksilver> yes, I'm convinced.
11:07:31 <conal> finishing ..., pick two different e's.  one before ev and one after. ...
11:07:38 <quicksilver> I also thought that f = fv `mappend` f should produce f = fv
11:07:46 <byorgey> hmm, I tried doing  cabal install --user --prefix=$HOME/local lhs2tex
11:07:53 <byorgey> and it failed trying to write /usr/local/share/texmf/tex/latex/polytable
11:07:59 <conal> quicksilver: that's a fixpoint also.  and a more useful one.
11:08:05 <byorgey> any ideas how I can force it to install in $HOME/local ?
11:08:07 <quicksilver> but I now see that, by the same argument, that is also not the least fixed point.
11:08:27 <conal> yeah
11:08:43 <quicksilver> so my minmal counterexample is not the right one.
11:08:55 <conal> quicksilver: please keep looking
11:09:01 <dcoutts> byorgey: not sure. Bascially lhs2tex is being naughty and trying to write to some fixed location.
11:09:43 <byorgey> yeah, that's what I figured
11:09:44 <Philonous> What was ev defined to be?
11:10:02 <Surma> is it possible to only evaluate where-statements when a guard condition is true (i.e. making a where-statement belong to a guard, not a whoel function)?
11:10:45 <lilac> Philonous: ev :: Event a
11:11:15 <Philonous> Surma: Where statmements should only be evaulated  "on demand" anyway
11:11:43 <Surma> Philonous: Oh, yeah right... the lazy evaluation thing... i'm new to this kind of programming ;) thanks :)
11:11:54 <lilac> Surma: laziness takes some getting used to :)
11:12:01 <bos> If you just can't get enough random FP distraction: http://www.serpentine.com/blog/2008/12/05/functional-programmers-on-twitter/
11:12:27 <evident> hi guys
11:12:47 <conal> bos: you outted us!
11:13:03 <bos> conal:  :-)
11:13:08 <conal> bos: thx, now i know whom else to stalk.
11:13:10 <Cale> hello evident
11:14:36 <quicksilver> I am back to pointing the blame at (my implementation of) catMaybesE.
11:15:09 <quicksilver> conal: the problem is (as I said yesterday) the failure of the 'Nothings' which get filtered out by catMaybesE to convey information about event non-occurrence.
11:15:11 * ksf read that as "maybeaise"
11:15:19 <jberryman> will there be any efficiency lost if instead of pattern matching a type, I use guards with a function that checks whether one of the two possible patterns is true?
11:15:40 <byorgey> dcoutts: it seems there is a 'configure' script which you can pass a prefix to if installing manually.
11:15:43 <quicksilver> or, ignoring the actual implementation of JoinE, we require this property of joinE
11:15:53 <byorgey> dcoutts: do you know if this would get called automatically by cabal install ?
11:16:01 <byorgey> and if so, how I can pass other parameters to it?
11:16:05 <dcoutts> byorgey: yes, if the Setup.hs in the package does it
11:16:08 <ksf> depends on complexity of patterns, stuff and so on.
11:16:15 <ksf> if in doubt, look at the assembly.
11:16:37 <byorgey> dcoutts: well, I tried looking through the Setup.hs and I'm not really sure what it's doing... it does a lot of stuff. =)  a simple search for 'configure' doesn't turn anything up.
11:16:42 <quicksilver> if the first event of the Event (Event a) is of the form "Event (NeverHappens)", then, even though we don't get an actual occurence until we get an actual occurrence, we need to get a non-occurrence.
11:16:54 <byorgey> well, no matter, it's not like installing it manually is that big of a deal.  I'll just file a bug.
11:17:16 <conal> quicksilver: meaning, a lower bound on the first occurrence?
11:17:39 <quicksilver> jberryman: in general you can expect (==) might be slightly slower than a pattern match. The derived instance of (==) might check patterns in the wrong order.
11:17:44 <quicksilver> conal: exactly.
11:17:53 <dcoutts> byorgey: do you mean the simple ./configure --prefix= parameter? that already gets passed by default.
11:18:05 <conal> quicksilver: doesn't your joinE do that?  via joinF?
11:18:12 <conal> quicksilver: (i really don't know)
11:18:16 <dcoutts> byorgey: but I'm guessing that in this Setup.hs it's calling the configure directly right?
11:18:29 <quicksilver> conal: even an Event(NeverHappens) gives you a lower bound on the next event.
11:18:36 <dcoutts> byorgey: in which case it would not benefit from that feature
11:18:48 <conal> quicksilver: yeah, i got that
11:19:09 <conal> quicksilver: that's what my clumsy adjustE functions are about
11:19:21 <evident23> sry got disconnected... did anybody answer my question? if so, pls repeat
11:19:23 <byorgey> dcoutts: that's exactly what I mean.
11:19:24 <conal> quicksilver: and what i imagine your elegant joinF does
11:19:27 <quicksilver> conal: yeah. I'm doing something wrong here.
11:19:33 <byorgey> dcoutts: and no, it doesn't look like Setup.hs is calling configure directly.
11:19:34 <conal> quicksilver: elegant *use* of joinF
11:20:00 <quicksilver> conal: I never understood why you needed adjustE. Now I do :)
11:20:08 <lilac> conal: i'm amused that your Signal type (which looks like relative-time Behaviour) has the same representation as a Reactive Behaviour :)
11:20:20 <conal> lilac: shh! ;)
11:20:33 <conal> lilac: you're peeking ahead.
11:20:34 <quicksilver> conal: I don't quite understand what my joinF is doing in this case. Currently staring at it.
11:20:49 <evident23> can you tell me where the mistake is? cant find it
11:21:07 <lilac> conal: oops, sorry :)
11:21:12 <conal> heh
11:21:23 <byorgey> dcoutts: aha, it fails even if I do it manually with ./configure --prefix=blah.
11:21:27 * lilac doesn't want to get ahead of the class :)
11:21:55 <byorgey> it's installing the binary in that prefix location just fine, but it's also trying to install some latex files in the texmf tree
11:21:59 <byorgey> =P
11:22:01 <conal> lilac: one of the risks of blogging a piece at a time is having a clever someone shouting out the ending before i get there.
11:22:26 <quicksilver> conal: no. If have a Future Future, and the outer time is fixed, and the inner time is Never, joinF converts that into something operationally equilvalent to Never.
11:22:52 <quicksilver> conal: but this gives me insight into what I need to think about.
11:22:52 <jberryman> quicksilver: but what if my function isConstructorA returns Bool, and I use it like: f x | isConstructorA x =...; |otherwise = ...?
11:22:58 <byorgey> ok, it turns out this is covered in the installation README, but it's kind of annoying.
11:22:59 <conal> quicksilver: yeah.
11:23:12 <byorgey> problem solved, thanks dcoutts
11:23:31 <quicksilver> jberryman: that will almost certainly inline and be exactly the same. But not absolutely certainly.
11:23:39 <conal> quicksilver: cool.  i haven't dug into the joinF formulation.  i expect it does the required magic, just because it's beautiful.
11:23:48 <dcoutts> byorgey: as far as I can see ./configure is never called
11:23:55 <conal> and beauty == truth == works
11:24:01 <byorgey> dcoutts: right, it isn't, not from Setup.hs.
11:24:18 <dcoutts> byorgey: but not from anywhere else either, it's just never run
11:24:37 <byorgey> well, maybe not
11:25:06 <byorgey> dcoutts: the point is, it's not even particularly a problem with the way it is cabalized, it even "fails" if you try to manually install it locally.
11:25:28 <byorgey> dcoutts: but it only fails to install some .sty files, which it says you should copy manually somewhere LaTeX can find them
11:25:28 <dcoutts> byorgey: what version? 1.14 doesn't fail for me
11:25:44 <byorgey> dcoutts: 1.14.  You have to install it as --user for it to fail.
11:25:51 <dcoutts> byorgey: I did
11:26:10 <byorgey> dcoutts: maybe it's because you already have those .sty files installed.
11:26:18 <dcoutts> byorgey: right, probably so
11:26:30 <byorgey> dcoutts: I found where it explains this in the INSTALL file.
11:26:34 <byorgey> towards the end.
11:26:35 <conal> lilac: sry i've taken so long to dig into your snapshot and unamb stuff, which looks really cool.  i've had less focus than usual over the last three days.  and i really want to grok what you've done.  it may lead me to rethink some things.
11:27:05 <jberryman> thanks a lot. The other thing I've been wondering: there must be some benefit to putting patterns that happen the most infrequently lower in a function, but I gave up trying to find a measurable difference. I thought my test program was pretty extreme, but profiler measured them identically
11:28:27 <conal> bos: did you omit yourself from that twitter list?
11:28:40 <bos> Not as far as I know.
11:29:21 <lilac> conal: it's ok. i think i need to think more about this stuff too -- in particular, about improving time and why it doesn't leak space :)
11:30:10 <lilac> i could really do with a tool which would let me pause a haskell program and dig through its allocations to find what still has a reference to my data
11:30:12 <conal> lilac: i need to think about it more also!  i'm not really sure it works that great.  so if you think you spot problem and/or improvements, please say so.
11:30:24 <lilac> absolutely, will do
11:30:56 <conal> bos: i don't see you on the list
11:37:38 <quicksilver> conal: let me know if you can think of a simple joinE example which is recursive and yet should work.
11:37:59 <quicksilver> conal: because the snapshot example is rather complex and I'd love to aim at something simpler.
11:38:07 <hcube> Hi! Do you know GpuGen project what compiles ghc core language to CUDA? Is it a public project? I dont fint it's homepage.
11:38:53 <conal> quicksilver: it'd be great to have a simpler example.  i don't yet.
11:39:22 <quicksilver> conal: I'll try inlining all the definitions and see if there is an obvioius way to simplify.
11:39:55 <conal> quicksilver: thanks!
11:40:26 <quicksilver> conal: do you agree with "catMaybesE = joinE . fmap (maybe mempty alwaysE)"
11:40:44 <quicksilver> I'm not sure if you call that combinator 'alwaysE' but it should be obvious what it means.
11:41:47 <Surma> uhm, is there anything to pay attention to (syntax-wise) when defining multiple functions with where? ghci is complaining
11:42:29 <quicksilver> ghci mostly does expressions, and where clauses don't attach to expressions.
11:42:34 <Surma> just separated them by newline
11:42:55 <Surma> well, i meants ghc, just used to type ghci from the prompt ;)
11:43:08 <quicksilver> you need all the defns to start at the same indent.
11:43:13 <quicksilver> where b = 1
11:43:16 <quicksilver>       c = 2
11:43:50 <Surma> thanks a lot
11:44:47 <cpfr> hey if i am writing a problem in Haskell is it better bundled with a makefile or a cabal file
11:45:00 <mauke> cabal
11:46:48 <wchogg> I gots to admit.  The Haskell FFI is pretty slick.
11:47:12 <cpfr> mauke, i ask since i don't have a library component to my program
11:47:30 <wchogg> I've started working on my Bluetooth bindings again & it's pretty straightforward.
11:47:50 <mauke> I want to be able to install haskell packages with a simple 'make install', and that requires cabal
11:48:16 <cpfr> mauke, duly noted
11:48:28 <dcoutts> cpfr: cabal can handle programs as well as libs
11:48:41 <mauke> (because I have a generic Makefile that simply calls Setup)
11:49:01 <dcoutts> cpfr: it's a particular advantage if your program has dependencies on non-standard packages
11:49:05 <conal> quicksilver: looks good to me.  i think i have an almost identical definition: 'joinMaybes = (>>= maybe mzero return)'
11:49:05 <cpfr> dcoutts, do I just not include a section for library?
11:49:24 <conal> quicksilver: which Cale came up with.
11:49:28 <dcoutts> cpfr: you use an executable section instead of a library section
11:49:29 <BrokenClockwork> if you divide an atom, dou you get a lambda?
11:49:45 <dcoutts> cpfr: take a look at an example on hackage
11:49:51 <cpfr> got it
11:50:00 <cpfr> any package you would suggest?
11:51:30 <conal> quicksilver: i'm guessing about your alwaysE.  however, i wouldn't call what i have in mind "alwaysE", so maybe we don't have the same def.
11:51:46 <dcoutts> cpfr: eg http://hackage.haskell.org/packages/archive/darcs-graph/1.0/darcs-graph.cabal
11:52:48 <cpfr> thanks
11:53:10 <wchogg> dcoutts:  So have you seen anyone else with the issue with hsc2hs I was whining about on the mailing list?  Or was it a unique thing I managed to create on my own box?
11:53:46 <Surma> hm, my progam gives me  a stack overflow, because a list actually gets to big (but that is intended). Is there some way of making this not happen? ;)
11:54:03 <opqdonut> Surma: yes, in most cases
11:54:08 <opqdonut> are you folding over the list?
11:54:14 <Surma> yeah
11:54:22 <gwern> be strciter? use fold'?
11:54:22 <Surma> well no
11:54:23 <opqdonut> are you using foldr'?
11:54:28 <gwern> *foldl'
11:54:31 <opqdonut> yeah
11:54:34 <Surma> foldl prodcues that list actually
11:55:08 <Surma> and it coudl very well have over 2million tuples (Int,Int) - I don't know yet
11:55:14 <dcoutts> wchogg: no, I've seen it too on my box, but only when mixing the hsc2hs versions from different ghc installations
11:55:39 <dcoutts> wchogg: check where hsc2hs, is that the instance you expect? does it come from the right ghc version?
11:56:03 <Surma> so what can I do? there's no way I can reduce that list
11:56:05 <dcoutts> wchogg: erm, I mean $ which hsc2hs
11:56:11 <wchogg> the hsc2hs version was from 6.10.1
11:56:23 <dcoutts> wchogg: and you were using it with 6.10 or 6.8 ?
11:57:44 <conal> omg -- i can print right from emacs again.  praise be to Linux!
11:58:14 <wchogg> dcoutts:  How do you distinguish between the two when you just are running the hsc2hs program by itself?
11:58:28 <wchogg> I mean, I was intending to use it with 6.10.1
11:59:05 <dcoutts> wchogg: ohh, you're running hsc2hs directly and it fails?
11:59:22 <dcoutts> wchogg: so this isn't Cabal running hsc2hs
11:59:34 <byorgey> @remember conal  omg -- i can print right from emacs again.  praise be to Linux!
11:59:34 <lambdabot> Done.
11:59:36 <wchogg> Oh!  No, I'm running it directly
12:00:15 <dcoutts> wchogg: seems that it does indeed fail. I'd never noticed because I never run it directly.
12:01:02 <wchogg> dcoutts:  It was just something small I was playing with, so I haven't set up cabal yet for the project.
12:11:07 <drdozer> is there a sort function with a signature like: (Ord b) => (a -> b) -> [a] -> [a]
12:11:27 <mauke> :t sortBy . comparing
12:11:28 <lambdabot> forall b a. (Ord a) => (b -> a) -> [b] -> [b]
12:11:31 <kapsas> hi there, is there somebody whos willing to help a Haskell noobie out... and yes its school work and yes i know that i should learn it but there aint time anymore + Haskell is HARD... really-really hard for me :( Its only 3 little-little functions that deal with lists - i would be very-very happy :):)
12:11:40 <drdozer> oh, thanks mauke
12:17:56 <kapsas> http://hpaste.org/12752
12:18:40 <kapsas> and there is the link also, ive managed to do 1st 2 but after that its just blurr :(
12:18:52 <orbitz> kapsas: what is your question?
12:19:13 <mauke> kapsas: as for 3), do you know 'map'?
12:19:29 <kapsas> a little
12:19:50 <mauke> because that's exactly what it does, iterate a function over a list and return a list of results
12:20:14 <byorgey> kapsas: we will not finish your homework for you.  if you have some code that you've tried to write which doesn't work or is getting an error, we can help you figure out what is wrong
12:20:45 <kapsas> i know that
12:20:53 <orbitz> mauke: do you mean 4?
12:21:00 <orbitz> err no you don't nm
12:30:05 <Surma> Guys, please help me once again: I have a list of tuples. I could find the Tuple with the biggest snd with maximumBy and a selfwritte comparisionfunction. But is there something generic?
12:30:31 <mauke> why use a self written comparison function?
12:30:34 <BONUS_> just do
12:30:50 <Surma> but you can't just comapre tuples, can't you?
12:30:51 <BONUS_> maximumBy (compare `on` snd)
12:30:57 <BONUS_> :t maximumBy (compare `on` snd)
12:30:58 <lambdabot> forall a b. (Ord b) => [(a, b)] -> (a, b)
12:31:09 <Surma> I don't now that command, thanks
12:31:10 <BONUS_> the on function is in Data.Function
12:31:12 <BONUS_> :)
12:31:32 <MyCatVerbs> Surma: you could create newtype wrappers around them to distinguish what ordering you want to sort them on, but it's not really worth the extra typing. BONUS_ has it.
12:31:39 <MyCatVerbs> @src on
12:31:39 <lambdabot> (*) `on` f = \x y -> f x * f y
12:31:40 <ksf> It's a function of the hermetic order of the lazy Lambda.
12:31:46 <orbitz> > (1, 2) == (3, 4)
12:31:48 <lambdabot>   False
12:31:49 * MyCatVerbs slaps ksf
12:32:18 <orbitz> @pl \x y -> snd x == snd y
12:32:18 <lambdabot> (. snd) . (==) . snd
12:32:19 <MyCatVerbs> Surma: "compare `on` snd" comes out as: \x y -> compare (snd x) (snd y)
12:32:46 <MyCatVerbs> Surma: which is exactly the type of function you'd want to pass to, say, maximumBy.
12:32:55 <Surma> thanks alot
12:33:05 <MyCatVerbs> Surma: hope it helps. ^^
12:33:06 <mauke> :t sortBy . comparing
12:33:08 <lambdabot> forall b a. (Ord a) => (b -> a) -> [b] -> [b]
12:33:23 <mauke> :t sortBy (comparing snd)
12:33:24 <lambdabot> forall a b. (Ord b) => [(a, b)] -> [(a, b)]
12:34:58 <eyeris> http://hpaste.org/12754      Could someone help me figure out these linker errors?
12:35:14 <mauke> ghc --make
12:35:32 <eyeris> When I run with --make, I don't get a binary
12:35:36 <mauke> yes, you do
12:35:46 <eyeris> Oh wait, I think I forgot module Main
12:35:57 <ksf> ...was just about to guess that.
12:36:39 <luite_> @where lyah
12:36:39 <lambdabot> www.learnyouahaskell.com
12:36:49 <luite_> Erik__: read that :)
12:36:50 <Erik__> *click*
12:36:57 <Erik__> ty
12:37:28 <Erik__> already found that link on this page http://www.haskell.org/haskellwiki/Haskell_in_5_steps
12:37:38 <MyCatVerbs> What the smegging Hell?
12:37:59 <MyCatVerbs> Did an H98 weenie discover Why the Luck Stiff or something?
12:38:15 <luite_> Erik__: you should probably ignore any haskell tutorial that tells you to start hugs :)
12:39:59 <wchogg> MyCatVerbs:  I think Learn You a Haskell is pretty good, actually, and it's not nearly as surreal as Why's Ruby tutorial.
12:40:17 <MyCatVerbs> wchogg: well no, but then it wouldn't be.
12:40:56 <MyCatVerbs> wchogg: it's more like someone took just one hit of the Chunky Bacon rather than the whole packet.
12:41:28 <wchogg> MyCatVerbs:  Honestly I thought Why's tutorial was...obfuscatingly whimsical.
12:41:40 <MyCatVerbs> wchogg: I thought it was funny. =)
12:41:52 <wchogg> Didn't say it wasn't funny!
12:41:58 <MyCatVerbs> wchogg: didn't really sell me on Ruby, though, but that's not really the point.
12:42:40 <MyCatVerbs> Well, not entirely. If I'd particularly wanted to go learn Ruby, then it'd have been a good enough starting point to just use the reference docs for everything else.
12:42:50 <Badger> BONUS's tutorial is a friendly starter. :)
12:43:25 <jsn> MyCatVerbs: i found it pretty confusing
12:43:27 <MyCatVerbs> wchogg: I can't say I honestly found that much in it that I'd go for it over Python, though.
12:43:32 <Badger> I just wish there were monads. :P
12:43:37 <jsn> and i really want to learn ruby :)
12:43:56 <jsn> s/want/wanted/
12:44:03 <jsn> i mean, i actually know ruby now
12:44:30 <pizza_> yeah, bummer
12:44:55 <MyCatVerbs> Badger: there could easily be, all you need are first class functions. ;P
12:45:30 <MyCatVerbs> Badger: and preferrably a type system that makes it easy to keep it all straight... >_>
12:45:37 <wchogg> Right.
12:45:49 <wchogg> In a dynamically typed language, I'm not sure of the point of Monads.
12:45:55 <vixey> ruby and python both suck
12:46:05 <jsn> vixey: compared to ... ?
12:46:15 <vixey> I'm not even comparing them to anything
12:46:19 <mauke> jsn: perl
12:46:31 <jsn> mauke: you've used all three at work?
12:46:34 <mauke> no
12:46:38 <jsn> well, i have
12:46:41 <blackh> Can someone explain this perl thing to me?
12:46:47 <mauke> that means you can't be objective anymore
12:46:52 <vixey> haha
12:46:58 <blackh> I have deliberately avoided perl all my life and now that I learnt Haskell...
12:47:05 <blackh> I have come across more mention of it than ever.
12:47:11 <jsn> mauke: it means i've learned to reserve judgement
12:47:32 <MyCatVerbs> vixey: I take issue with that assertion, at least in Python's case. For what reason do you make it?
12:47:33 <blackh> Is it really that great?
12:47:36 <mauke> my opinion is unspoiled by experience or facts
12:47:39 <ksf> Perl is Haskell's evil twin.
12:47:44 <jsn> mauke: anyway, you perl programmers are not doing yourselves any favours by saying that kind of stuff
12:47:56 <jsn> vixey: haskell sucks
12:47:57 <orbitz> mauke: those pesky facts
12:48:20 <jsn> blackh: are you familiar with sed or shellscript?
12:48:37 <jsn> vixey: which is why i end up using other languages every so often
12:48:39 <blackh> jsn: Intimately (since I deliberately avoided perl all my life)
12:48:45 <conal> lilac: ping
12:48:49 <jsn> blackh: ah, well
12:48:54 <ksf> Perl is obfuscated by design, haskell is designed by obfuscation.
12:48:57 <vixey> jsn, yeah most of the haskell I write is other peoples homework
12:49:15 <conal> @seen lilac
12:49:15 <lambdabot> lilac is in #haskell. I last heard lilac speak 1h 18m 50s ago.
12:49:23 <jsn> blackh: perl kind of mashes up shell, sed, awk and C
12:49:30 <mauke> jsn: and lisp
12:49:34 <jsn> yes
12:49:36 <jsn> and lisp
12:49:36 <MyCatVerbs> conal: ICMP ECHO INJECTION ATTACK, MWHAHAHAH!
12:49:49 <mauke> it also stole features from Ada and BASIC
12:49:49 <pumpkin> OMG language wars in #haskell whee
12:50:01 <Surma> Hm... I should worry, if my program does overflow with 50MB of stack, richt?
12:50:05 <Surma> ;)
12:50:09 <vixey> perl isn't just an amalgamation of other languages, it has lots of original parts also
12:50:18 <jsn> Surma: yes, worry
12:50:20 <blackh> My neighbour describes it as "powerful".
12:50:23 <jsn> vixey: right
12:50:28 <jsn> blackh: that is correct
12:50:30 * Badger DoSes MyCatVerbs violently.
12:50:42 <Surma> vixey: to me, perl is just a unreadable language
12:50:44 <MyCatVerbs> vixey: honestly, Python's design is such that I think I'd be roughly as happy with it as I'd ever be with only fairly minor changes that aren't really all that important.
12:50:44 <jsn> with great power comes responsibility...
12:50:52 <MyCatVerbs> Badger: no, that's my hobby.
12:50:59 <maltem> @remember ksf Perl is obfuscated by design, haskell is designed by obfuscation.
12:50:59 <lambdabot> Done.
12:51:04 <jsn> MyCatVerbs: have you used ruby much?
12:51:12 <MyCatVerbs> vixey: in Haskell's case, I'd like to throw away huge chunks of the language. :P
12:51:17 <Surma> MyCatVerbs: I don't know who said it, but someone said: If python is executable pseudo code, perl is executable line noise xD
12:51:19 <ksf> well perl does'nt try to hide complex concepts behind a simple syntax.
12:51:34 <mauke> ksf: disagree
12:51:36 <MyCatVerbs> jsn: no. Read through WTLS, got the impression that it didn't actually have anything interesting over any random Lisp.
12:51:59 <ksf> s/simple syntax/syntax that is easy to parse/
12:52:04 <jsn> MyCatVerbs: well, it's not really to be compared to lisp
12:52:05 <MyCatVerbs> ksf: Python doesn't try to hide complex concepts behind a simple syntax either.
12:52:15 <ksf> nope, but haskell does.
12:52:28 <vixey> kinda weird comparing ruby with lisp
12:52:48 <MyCatVerbs> ksf: I respectfully disagree. Very few of Haskell 98's features are even remotely complicated.
12:53:12 <MyCatVerbs> ksf: and actually the syntax for Haskell comes out with just these most obscene parse trees... :)
12:53:19 <ksf> it's not the features, it's the way of attaining them.
12:53:35 <jsn> MyCatVerbs: anyways, if you tried ruby for a couple of months you would like it much better than python
12:53:42 <ksf> ...but you agree that it's visually much cleaner than perl's, don't you?
12:53:43 <jsn> especially for text processing
12:53:44 <MyCatVerbs> ksf: please elaborate?
12:54:14 <ksf> well you can't really grok the language without knowing a fair deal of category theory.
12:54:17 <vegai> shouldn't you just use sed and awk for simple text processing...
12:54:24 <MyCatVerbs> ksf: utter dog poo.
12:54:26 <vegai> ksf: what language?
12:54:35 <jsn> vegai: well, unfortunately, they are missing things
12:54:46 <jsn> like awk can't really tell you what the present file is
12:54:47 <blackh> ksf: Not true.
12:54:48 <ksf> "knowing" meaning having at least knowledge at a level of popular science.
12:54:59 <jsn> also, those languages have no module system
12:55:28 <MyCatVerbs> ksf: I know category theory like I know the migration patterns of ugly caribou. The only Haskell features that trip me up are the bizarre and exotic stuff way over at the edge of extension-land.
12:55:30 * ksf wonders whether he was the only one utterly perplexed by monads
12:55:31 <jsn> ksf: i think that haskell suffers from an overly elaborate presentation
12:55:38 <vegai> jsn: yes, you don't make applications on them
12:55:51 <MyCatVerbs> jsn: Ruby it has special syntax for regexen, right? How about LR parsers?
12:56:03 <vegai> ruby has special syntax for fuck all :P
12:56:09 <jsn> vegai: well, i very often do text-processing within small applications, that call in all sorts of libs
12:56:09 <blackh> ksf: I was perplexed by monads for a while when learning... and that's because every tutorial missed out one important thing:
12:56:10 <vegai> sadly, not LR parsers, though.
12:56:14 <im_maciek> could I gently ask what kind of complex concepts does haskell hide behind the simple syntax?
12:56:23 <vegai> jsn: oh, well. Haskell then.
12:56:25 <pumpkin> im_maciek: as many as you want
12:56:27 <jsn> MyCatVerbs: ruby has Perl-like syntax for regexen
12:56:29 <blackh> ksf: ...how monads work when you use them.
12:56:34 <vixey> im_maciek, I can't think of any
12:56:36 <jsn> vegai: unfortunately, not the best option yet
12:56:45 <ksf> it's not like call/cc, where you know what you're getting into if you read up about it. otoh, reading up about IO or lists in haskell can be futile to your preconceptions.
12:56:54 <jsn> maybe with quasi-quoting, we'll get it right
12:57:04 <blackh> ksf: I think I could write a really good monad tutorial.
12:57:14 <MyCatVerbs> jsn: that's handy, buuut... the re module isn't exactly painful to use, and for anything interesting I'd rather be using a real parser kit anyway.
12:57:42 <jsn> MyCatVerbs: well, obviously, that's not the only thing that appeals about ruby
12:57:51 <ksf> blackh, if you do, please it "monadic design patterns for the discerning hacker" ;)
12:58:18 <MyCatVerbs> jsn: say, spark.py :)
12:58:26 <ksf> I guess it's the genericity of monads that make them hard to grok.
12:58:32 <jsn> MyCatVerbs: i'm just saying, as someone who has worked with both languages (Python more than a year, Ruby more than two) that there is a lot to like about ruby
12:58:56 <gwern> @hoogle read
12:58:56 <lambdabot> Prelude read :: Read a => String -> a
12:58:56 <lambdabot> Text.Read read :: Read a => String -> a
12:58:56 <lambdabot> module Text.Read
12:59:06 <ksf> in a certain sense, haskell shows a lot more of its plumbing that most other languages by exposing them.
12:59:10 <Cale> I think monads are not actually what's hard to understand.
12:59:15 <MyCatVerbs> jsn: please hit me with the highlights? I've hacked in anger in Python, but not in Ruby.
12:59:50 <jsn> MyCatVerbs: i don't think this can actually go anywhere constructive
12:59:50 <gwern> dang it. is there no read for ByteString?
12:59:55 <Cale> The trouble I think comes more from the fact that people are not really very well-versed in functional programming yet when they first see them, and many of the examples really use functions as data in a way which other libraries might not do quite as much.
13:00:26 <Cale> To understand the State monad for instance, you really have to be quite comfortable working with functions.
13:00:37 <jsn> MyCatVerbs: as for using a real parser kit -- at that point, i graduate to Haskell
13:00:43 <pumpkin> ruby passes functions around all the time!
13:00:45 <MyCatVerbs> jsn: how about I offer to not reply? I'm genuinely curious.
13:00:46 <blackh> Cale: I think another problem is that monads rely heavily on the functioning of the type system, and a monad tutorial would be easier to understand if it dealt with how they work together.
13:00:54 <gwern> guys - I have a file which represents [ByteString], but B.readFile returns a ByteString; how do I turn readFile's stuff into [ByteString]? read doesn't seem to work
13:01:11 <gwern> unless I want o unpack the ByteString, which sort of defeats the point
13:01:16 <mauke> gwern: define "represents"
13:01:19 <Cale> blackh: Yeah, a lot of people (and monad tutorials!) miss the whole point of abstracting over monads.
13:01:24 <ksf> I also think it's important to point out their relationship to purity.
13:01:25 <blackh> Cale: In the end it was reading the implementation of the state monad that made me understand.
13:01:34 <ksf> s/also/too
13:01:40 <ksf> ...and put it at the end.
13:01:42 <Cale> Which of course is to be able to eliminate code duplication, like every other programming abstraction.
13:01:48 <paolino> the purity is really hard for me, that's all
13:01:57 <gwern> mauke: as in, I have [a, b, c], I call 'show' on it, and writeFile $ show [a, b, c]
13:01:58 <blackh> Cale: I would have got it quicker if someone had told me this:
13:02:04 <mauke> er
13:02:07 <mauke> whoa
13:02:11 <ksf> well monads are one way to make purity manageable.
13:02:13 <takinitez> the whole idea of monads only opened up to me when i understood the list monad
13:02:23 <ksf> same with me.
13:02:27 <Cale> For me, it was Parsec :)
13:02:47 <takinitez> some kind of revelation that was
13:02:50 <ksf> @src [] (>>=)
13:02:50 <gwern> mauke: obviously I'd like to go the other way, with 'read . readFile'
13:02:50 <lambdabot> xs >>= f     = concatMap f xs
13:03:03 <ksf> concatMap is a nasty, but elegant beast.
13:03:05 <MyCatVerbs> Cale: for me, it was trouble with Parsec that put me off monad abuse for a while. ;)
13:03:19 <mauke> gwern: that should work, actually
13:03:20 <jsn> MyCatVerbs: ruby's system of modules and mixins facilitates good design; the simple syntax allows for clear list handling, regular expressions and control flow (thank god for case); the package manager works well and essential packages are handled in a responsible way (unlike, say, Python's imaging libs)
13:03:31 <gwern> mauke: B.readfile, I mean
13:03:35 <gwern> sry
13:03:40 <mauke> why B.readfile?
13:03:46 <blackh> Cale: A do-notation statement is a function that hasn't been executed yet, and a monad implements the way in which they are glued together.
13:03:50 <gwern> since I understand the bytestring IO is faster
13:03:50 <Cale> The real purpose of defining monads and pointing them out is so that the stuff in Control.Monad (among other things) can be shared between all the monadic libraries.
13:04:05 <mauke> blackh: a do-notation statement is not a function
13:04:15 <Cale> blackh: In the case of monads which are implemented using functions, perhaps...
13:04:18 <ksf> MyCatVerbs, repeat after me: I don't want to influence ParseT behaviour by ParseT state.
13:04:19 <C-Keen> gwern: why not use ByteString.readFile?
13:04:24 <paolino> and that once you reached purity , it's ugly to get back, which is a meta-problem of haskell really
13:04:33 <mauke> gwern: yeah, but you lose all that in read anyway
13:04:33 <gwern> :t Data.ByteString.readFile
13:04:35 <lambdabot> FilePath -> IO BSC.ByteString
13:04:37 <MyCatVerbs> jsn: you say mixins, are you referring to things like CLOS's :begins, :afters :arounds, etc?
13:04:40 <gwern> C-Keen: ^
13:04:52 <jsn> MyCatVerbs: i don't know CLOS
13:05:02 <jsn> they are somewhat like type classes
13:05:19 <jsn> in that they allow you to add methods to an object after the fact
13:05:39 <jsn> though the similarity is pretty much superficial
13:06:04 <MyCatVerbs> jsn: ah no, completely different thing.
13:06:32 <blackh> Another possible approach to explaining monads:
13:06:45 <blackh> First implement a really simple DSL to show the principle of how they work.
13:06:57 <blackh> Then explain that monads are also a DSL.
13:07:14 <mauke> another approach: don't explain monads
13:07:17 <vixey> "DSL" is a ugly term
13:07:29 <blackh> How about "cold smooth thing"?
13:07:36 <MyCatVerbs> vixey: indeed! I much prefer "aDSL". =)
13:07:45 <mauke> > reverse "DSL"
13:07:46 <lambdabot>   "LSD"
13:07:53 <MyCatVerbs> vixey: or "OC-192..." *drools quietly in a corner*
13:07:54 <blackh> rofl
13:07:57 <mauke> COINCIDENCE‽
13:08:00 <jsn> MyCatVerbs: this explains it pretty well
13:08:01 <jsn> http://www.ruby-doc.org/docs/ProgrammingRuby/html/tut_modules.html
13:08:47 <jsn> i think one can introduce imperative programming in haskell without discussing monads first
13:08:58 <jsn> but then you should discuss them, like, a week later
13:09:08 <mauke> I don't see why
13:09:09 <edwardk> jsn: that way lies.. Frag
13:09:22 <pumpkin> jsn: "the basic syntax for a haskell program is main = do <stmt>;<stmt>;...", right? :P
13:09:24 <MyCatVerbs> Well, you can always teach it by explicit world-passing.
13:09:34 <jsn> the fact is, the whole point of using this language is to describe and verify structures
13:09:41 <MyCatVerbs> Then once you've shown people the State monad, heh. =)
13:09:43 <mauke> pumpkin: ew, no
13:09:48 <pumpkin> :D
13:10:03 <jsn> so you can only go for so long without learning a lot of new things
13:10:08 <mauke> and explicit world passing is retarded. it doesn't really explain anything.
13:10:09 <jsn> if you want to get anything out of it
13:10:14 <C-Keen> gwern: sorry if I missed your pointn
13:10:36 <blackh> MyCatVerbs: A lot of monad tutorials start with explicit world passing, but I found that didn't work for me.  That didn't explain how monads actually work when you use them.  Maybe jsn is right - start with examples of what you can do with monads for a week, *then* explain how they're implemented.
13:10:52 <mauke> you can't do anything with "monads"
13:11:08 <edwardk> i usually don't try to start with IO. i start with something like reader. hey you want to pass around one more stinking argument.... go rewrite all your code
13:11:09 <mauke> you always need a specific instance to start
13:11:22 <blackh> My problem was I live in the remotest regions of the Earth and it took three months to get my Haskell textbook, so I learnt everything from tutorials!
13:11:31 <edwardk> then once they have writer i go, ok, now your boss wants you to log stuff....
13:11:32 <jsn> mauke: yeah, but none of us even care -- because monad has become a haskell slang term
13:11:36 <edwardk> er once they have reader
13:11:42 <mauke> starting with IO is important so you can write hello world (and actual programs)
13:11:51 <edwardk> hah
13:11:53 <jsn> mauke: i agree
13:12:02 <jsn> edwardk: hello world is the most important program
13:12:22 <edwardk> jsn: i must have missed it. i don't think i ever wrote hello world in haskell ;)
13:12:23 <paolino> I always thought monads are the easiest metaprogramming for the functional environment, but maybe I'm wrong
13:12:24 <luite_> mauke: it's useful for those simple examples, without explaining the inner workings, but I think there are better starting points for explaining monads
13:12:29 <edwardk> > "Hello World"
13:12:30 <lambdabot>   "Hello World"
13:12:38 <blackh> edwardk: I think: start with hell world, demonstrate how you user Reader, then demonstrate how you use ReaderT, and once those concepts are grasped, then explain how Reader is implemented, then ReaderT.
13:12:41 <mauke> luite_: er. my point is that you should not explain monads.
13:12:43 <edwardk> ok, now i have
13:12:51 <polveroj> You can do a little IO without really explaining it--how long do they wait to tell you what argv and argc are in C?
13:12:59 <jsn> mauke: but how long can that last?
13:13:00 <polveroj> or
13:13:06 <mauke> jsn: pretty much forever
13:13:18 <polveroj> "public static void main", which always gets question marks in intro java classes
13:13:19 <luite_> mauke: hm, but the problem may be that the student/user will ask about them?
13:13:27 <mauke> as soon as you have the base language + IO, you're "program complete"
13:13:41 <jsn> mauke: you're unable to do any architecture, though
13:13:48 <mauke> jsn: not really
13:13:50 <gwern> C-Keen: if read onl takes String, and B.readFile only results in ByteString, then you need ByteString -> String (B.pack), but that forfeits major speed. as bytestring lore goes, pack and unpack are death on performance (in both space and time)
13:13:57 <edwardk> polveroj: which is why i always try to get a place to let me teach java server pages before java ;)
13:14:05 <edwardk> polveroj: the boilerplate is insane to a newbie
13:14:05 <jsn> mauke: well, you have to know what monads are to use them as interfaces :)
13:14:09 <mauke> luite_: tell them to forget about monads :-)
13:14:14 <mauke> jsn: I don't think so
13:14:35 <C-Keen> I think the issue with monads is that is is the only thing that really distinguishes haskell from other languages. Therefore everyone is so keen in pointing out what these monads are
13:14:35 <jsn> mauke: no? you can use them without knowing how they work?
13:14:53 <C-Keen> gwern: right
13:14:53 <mauke> polveroj: er, why introduce argc/argv at all if you're not going to explain them? they're optional in C
13:15:11 <mauke> jsn: you can use every monad instance
13:15:24 <jsn> mauke: oh, you mean, read it as an example?
13:15:30 <C-Keen> and next thing you know is watching yourself writing the True Monad Tutorial
13:15:39 <mauke> jsn: later, after they have experience with various monad instances, you can point out the similarities
13:15:40 <Cale> C-Keen: what about laziness, referential transparency, typeclasses...?
13:15:46 <jsn> mauke: sure
13:15:59 <jsn> mauke: i agree with that -- but it needs to happen eventually
13:16:10 <jsn> so you can program the "inner computer"
13:16:19 <mauke> "oh, and there are two particularly fundamental operations, return and (>>=). they're defined as methods of a class called Monad."
13:16:32 <C-Keen> Cale: the don't stick out that obviously as they are somewhat understood intuitively
13:16:35 <jsn> monad cat is...
13:16:56 <orbitz> i'm not sure laziness is really understood intuitively if you come from a strict language
13:17:07 <orbitz> given what cale had to help me with earlier this week
13:17:13 <edwardk> mauke: color that with >>= gives you a 'programmable semi-colon' and that return lets you turn a normal statement into an action and you can admittedly get pretty far
13:17:43 <mauke> >>= doesn't give you a programmable semi-colon; do-notation does
13:18:07 <edwardk> what i mean is it defines what the programmable semicolon does
13:18:12 <C-Keen> My thesis is that people will first ignore words that they don't fully understand but they sound familiar and stumble over the unfamiliar and unknown words :)
13:18:17 <edwardk> yeah
13:18:31 <mauke> edwardk: wrong order
13:18:34 <cjb> hee hee, http://learnyouahaskell.com/chapters is hilarious
13:18:43 <mauke> you start with >>=, then define do-notation on top of that
13:19:15 <jsn> we should perhaps mysticalize monads
13:19:23 <edwardk> mauke: depends, that requires spending a lot of time introducing lambdas, etc which takes you pretty far afield of hello world
13:19:34 <jsn> refusing to explain them to all but a chosen few in each generation
13:20:02 <mauke> edwardk: well, I kind of assume the student already knows the language itself
13:20:10 <edwardk> jsn: all you have to do is occasionally invoke monadology and a good chunk of the room will smile like they think its all related
13:21:04 <mauke> hello world should come first, but an actual explanation has to wait until later
13:21:28 <edwardk> it even kits you out with the right mystical claptrap. they are atomic ideas that can't be divided up into anything smaller, etc. sounds like something you can't look at too closely. ;)
13:21:32 <vixey> hello world is C cruft we don't need
13:21:37 <jsn> edwardk: hehe
13:21:43 <edwardk> someone should have told Liebniz about adjunctions. He'd have been pissed.
13:22:01 <jsn> vixey: maybe we need "hello, socket client"
13:22:15 <mauke> actually, main = interact (const "Hello, world!\n")
13:22:32 <mauke> you can get pretty far with interact (brainfuck!)
13:22:45 <edwardk> mauke: thats pretty good
13:23:03 <jsn> main = putStrLn "hello world"
13:23:09 <edwardk> it gives an avenue to get data in and out
13:23:13 <conal> @tell lilac I added some notes about your snapshot fix to http://trac.haskell.org/reactive/ticket/14
13:23:13 <lambdabot> Consider it noted.
13:23:17 <edwardk> on the other hand you could just point them to ghci
13:23:20 <geezusfreeek> jsn: that is both evil and brilliant
13:23:27 <mauke> edwardk: ghci doesn't give you real programs
13:23:29 <jsn> geezusfreeek: what is ?
13:23:37 <geezusfreeek> just don't talk about monads
13:23:54 <vixey> real programs .. written by real programmers ?:)
13:23:58 <mauke> edwardk: that's something I really really hated about lisp: no easy way to compile an executable
13:24:05 <jsn> i thought as much -- just wanted to be sure putStrLn wasn't evil for some reason
13:24:14 <edwardk> the first rule of monad club is you don't talk about monad club.
13:24:21 <vixey> mauke, try SBCL or ECL
13:24:47 <jsn> geezusfreeek: i think you can just not talk about them for a couple of weeks
13:24:54 <geezusfreeek> the problem is error messages. how do you explain to a student why (2+) . readLn doesn't work without explaining a bit about monads?
13:25:12 <jsn> you can say something vague about type tags
13:25:17 <mauke> vixey: how do I compile a program with sbcl?
13:25:22 <paolino> OT : how can I obtain the permutation that sorted a list?
13:25:23 <vixey> geezusfreek, I'm sure a beginner is using sections and (.) .. :p
13:25:24 <geezusfreeek> (actually, if (.) was fmap it would work)
13:25:35 <mauke> geezusfreeek: by explaining IO, of course
13:25:38 <vixey> mauke, sb-ext:save-lisp-and-die :executable t or something like that
13:25:48 <geezusfreeek> i meant 2 + readLn
13:25:50 <mauke> vixey: er. you call that easy?
13:25:51 <jsn> geezusfreeek: yeah, unfortunately, (.) got taken by the Category module
13:25:54 <geezusfreeek> my own habits caused that
13:26:09 <jsn> so we are not going to be able to Perlize Haskell with it
13:26:10 <vixey> mauke, I'd have to look up docs to find the right command --- Not much different to any other language
13:26:19 <mauke> vixey: very different
13:26:21 <jsn> but i'm doing fine with <$> for that purpose
13:26:28 <vixey> mauke, what's easy then?
13:26:37 <mauke> vixey: in sh, I just put #!/bin/sh in the source and chmod +x. done.
13:26:41 <geezusfreeek> (.) = fmap seems perfectly intuitive to me
13:26:46 <mauke> vixey: in C, I just say gcc source.c. done.
13:26:55 <geezusfreeek> but this is talked about too often as it is
13:27:02 <vixey> mauke, oh you can do that #!/ crap if you want, I Thought you meant a compiled executable for some reason
13:27:17 <jsn> geezusfreeek: well, yes -- but as i think roconnor pointed out, it probably makes sense for compose to be a method of category, rather than functor
13:27:36 <mauke> vixey: well, when I have a lisp compiler I might as well use it
13:27:51 <vixey> yes :)
13:27:57 <jsn> we need to take some other operator
13:27:59 <lilac> conal: thanks! i'll need to meditate on quicksilver's joinE -- i've not thought about Future-as-a-Monad yet
13:28:00 <lambdabot> lilac: You have 1 new message. '/msg lambdabot @messages' to read it.
13:28:02 <vixey> as in, not create a binary that isn't any longer the real compiler
13:28:16 <paolino> :t compare
13:28:17 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
13:28:28 <jsn> because <$> is big and ugly
13:28:48 <mauke> vixey: what
13:28:51 <conal> lilac: do.  future join is really lovely!  have you read the Future module?  there's almost nothing there.  almost to nirvana.
13:29:04 <jsn> maybe ''
13:29:08 <vixey> mauke, sorry going off on a tangent
13:30:00 <conal> lilac: that Future module began as a denotational semantics for the "real" implementation of futures.  eventually i had the idea of improving values and realized that the semantics could actually be the implementation.
13:30:46 <geezusfreeek> jsn: that would require spaces around it. i usually space such operators anyway, but others might find it problematic
13:30:52 <conal> lilac: not that improving values is my idea.  just using it in this way and implementing via unamb.
13:31:01 <jsn> geezusfreeek: true
13:31:10 <evident23> hi... i've got a stupid question: how do write a "new line" ?
13:31:13 <lilac> conal: ah, i see. the monad is a natural extension of the semantics of the applicative, as one would expect.
13:31:20 <jsn> evident23: "\n"
13:31:24 <conal> lilac: yeah :)
13:31:36 <evident23> I am working with stacks and now i want to exchange the "|" splitter with a new line
13:31:54 <jsn> evident23: the '|' splitter?
13:32:00 <lilac> i hesitate to say 'the' natural extension of the applicative, but i'm not sure whether that's true too
13:32:21 <lilac> is it possible for two monads to embed the same applicative functor?
13:32:34 <oklopol> 23:17 edwardk: mauke: color that with >>= gives you a 'programmable semi-colon' <<< /me likes analogy
13:32:37 <evident23> wiat
13:33:06 <jsn> evident23: ah, you can show us the code, maybe?
13:33:08 <conal> lilac: i don't know, but i appreciate your hesitation with the word 'the'
13:33:51 <evident23> http://hpaste.org/12757
13:33:51 <conal> lilac: i'm off to work outside.  it's a beautiful sunny day, and i've not see much of it.
13:33:54 <evident23> there it is
13:33:54 <evident23> :)
13:34:23 <lilac> conal: good idea :) enjoy
13:34:26 <jsn> replace '|' with '\n'
13:34:28 <evident23> (i've got some more stack functions and definitions etc given...)
13:34:31 <mauke> wait, so data Stack a = EmptyStk | Stk a (Stack a)?
13:34:35 <evident23> and thats it?
13:34:44 <jsn> evident23: well, yes
13:34:47 <evident23> ohh ok
13:34:57 <jsn> i can't see anything tricky about it
13:34:57 <evident23> i was just looking for the "\n"
13:35:01 <jsn> do you?
13:35:02 <evident23> didnt remember...
13:35:06 <jsn> ok
13:35:10 <evident23> (still new with haskell) :D
13:35:27 <mauke> and push x s = Stk x s, I guess
13:36:33 <roconnor> jsn: what would be the consequence of taking $ for map?
13:37:32 <jsn> roconnor: for map specifically? not fmap?
13:37:41 <geezusfreeek> roconnor: mass chaos
13:38:00 <polveroj> death by parentheses
13:38:15 <jsn> you know, i use $ a lot more than i use .
13:38:19 <roconnor> jsn: fmap
13:38:29 * geezusfreeek uses . more than $
13:38:34 <roconnor> (aka map in the other prelude)
13:38:44 <roconnor> oh wait
13:38:46 <jsn> the other prelude?
13:38:47 <roconnor> never mind
13:38:58 <roconnor> $ is totally different than .
13:39:51 <roconnor> http://www.haskell.org/haskellwiki/The_Other_Prelude
13:40:17 <Saizan> i think you want both a prefix and an infix version
13:40:23 <roconnor> is $ totally different than . ?
13:41:43 <Saizan> as much as application is different from composition
13:41:47 <jsn> it would be kind of cool if string were a class of quoted things
13:42:10 <jsn> with the trivial one being     instance String [Char]
13:42:13 <mauke> @hoogle IsString
13:42:13 <lambdabot> Data.String class IsString a
13:42:28 <roconnor> jsn: [Char] can't be an instance of anythin in H98
13:42:36 <Saizan> if you your values A are 1 -> A i guess ($) is the same as (.)
13:42:46 <nathanic> it seems to me that ($) is a version of id with a more specialized type.
13:42:47 <jsn> roconnor: you guys only want H98 ?
13:42:56 <paolino> what kind of structure is a Map where keys are reorderable ?
13:42:57 <nathanic> f `id` x
13:43:03 <roconnor> jsn: I want a decidable type system
13:43:22 <roconnor> decidable and consistent
13:43:24 <roconnor> and sound
13:43:25 <polveroj> nathanic: it is.  (id f x) = ((id f) x) = (f x) = (f $ x)
13:43:31 <mauke> how quaint
13:43:46 <jsn> roconnor: so you are one of those -XNoOverlappInstances folks
13:43:59 <roconnor> probably
13:44:23 <nathanic> polveroj: thanks.  the idea just popped into my head, glad to see i'm not entirely crazy.
13:44:37 <jsn> well, then i guess the trivial one is     instance String ByteString
13:44:56 <roconnor> so is there any a relation between <$> and $ ?
13:45:08 <jsn> or something with phantom types, like    instance String (ByteStream UTF8)
13:45:11 <jsn> roconnor: no
13:45:21 <roconnor> wow
13:45:28 <sjanssen> roconnor: ($) is application, (<$>) is application in a Functor?
13:45:31 <roconnor> so the appicative names are all terrible?
13:45:32 <nathanic> roconnor: i always took the < > to remind me of a box (functor) and ($) is application, so <$> is application inside a box
13:45:51 <wchogg> Ooh...I think nathanic had a succinct way of thinking of it.
13:45:53 <roconnor> nathanic: but <*> is application inside a box
13:46:16 <sjanssen> <*> is application where both the function and the data are inside boxes
13:46:20 <roconnor> <$> is "box this function up and then box apply it"
13:46:39 <sjanssen> roconnor: not necessarily, as some functors don't support boxing things up
13:47:01 <sjanssen> (ie. Functors that are not Applicative or Monad)
13:47:18 <lilac> <$> is apply this function within that box
13:47:30 <b_jonas> so what's the best example of an Applicable that's not a Monad?
13:47:46 <sjanssen> b_jonas: ZipList from Control.Applicative
13:47:58 <wchogg> beat me to it
13:47:59 <lilac> sjanssen: that has a Monad instance, though, iirc
13:47:59 <b_jonas> Applicative I mean, not Applicable
13:48:11 <lilac> sjanssen: as in, there is a possible one
13:48:30 <sjanssen> lilac: the applicative paper uses it as an example because there is not a monad instance
13:48:31 <wchogg> b_jonas:  Have you read the original Applicative Functors paper?
13:48:54 <b_jonas> the default for monads is this, right: pure = return; <*> = ap; liftA = liftM;
13:48:56 <sjanssen> lilac: what is the instance?
13:48:58 <b_jonas> wchogg: no, which one is that
13:49:05 <lilac> sjanssen: iirc, join = diag
13:49:06 <sjanssen> b_jonas: yes
13:49:14 <b_jonas> by the way, there's another more important thing I wanted to ask,
13:49:19 <b_jonas> um, what was it...
13:49:44 <wchogg> b_jonas:  http://strictlypositive.org/IdiomLite.pdf
13:49:56 <wchogg> It's very light & readable
13:50:27 <b_jonas> wchogg: ok, thanks, found it
13:50:38 <b_jonas> the ghc core lib docs also links to a version
13:51:14 <wchogg> b_jonas:  Also, the "Essence of the Iterator" paper is a good example of why you'd use Applicative
13:52:33 <b_jonas> but what I'd like to understand more than Applicative is the higher rank types. could you tell me a good paper that tells about the type system itself? all the ones I found told mostly about the type inference, and taking the type system extension as more or less a given.
13:52:37 <byorgey> lilac: that only satisfies the monad laws if you have infinite lists.
13:52:46 <byorgey> lilac: so it's a monad instance for Stream, but not for List.
13:53:35 <vixey> b_jonas, what about it?
13:54:52 <adimit> damn. I need some help with lazy file I/O (please :-) http://hpaste.org/12759 is my first try of coming up with something that reads in a file line-by-line, accumulates data from it into a data type using foldr.
13:55:27 <b_jonas> vixey: like the definition of a higher rank type, rules when two higher rank types are equal or a higher rank type is more general than another, and what types basic expressions (like function application) are allowed to have at all
13:55:47 <b_jonas> vixey: not just what type (of the multiple possible types) the type system infers
13:55:57 <adimit> but it explodes on large files, before even calling (gatherData), so it must be slurping the thing somewhere, but I'm too much of noob to figure it out. (if that's no help channel, please tell me, I'll consider going somewhere else)
13:56:13 <b_jonas> type inference is important too, but I can't understand the papers about it before I understand what's considered correctly typed first
13:56:51 <lilac> byorgey: do you have a counterexample to it satisfying monad laws to hand?
13:59:03 <byorgey> lilac: not off the top of my head, no
13:59:14 <byorgey> but it's probably a good exercise to try working it out =)
14:00:50 <byorgey> lilac: I'm pretty sure associativity is the problem
14:01:37 <lilac> byorgey: i only ask because i've tried before and i managed to convince myself that it was associative :)
14:02:20 <Mips_> hi
14:02:48 <byorgey> lilac: well, fair enough.  I'd have to think about it more carefully.
14:03:32 <Mips_> can somebody help me read some haskell code, cause I've no clue about haskell and I only need to find out what it does ... would be great and I would sheep beer world wide !!!
14:03:42 <lilac> byorgey: i'll try to construct a proof, maybe that'll show me where my reasoning falls down :)
14:04:00 <Philippa_> b_jonas: there's no direct rule in System F, you just build type lambdas and applications that do the coercion
14:04:10 <mauke> Mips_: where's the code?
14:04:29 <byorgey> lilac: sure, sounds good
14:05:17 <_dolio> b_jonas: Daan Leijen has some good papers on type systems with higher-rank types. They're typically about fixing problems with existing ones (as far as practical implementation goes), but you may be able to glean information from them.
14:05:20 <b_jonas> it's strange how they named it "system F" by the way, I thought they'd know about the rule that appending "calculus" to anything makes it sound cooler
14:05:24 <vixey> what does it mean to would sheep beer world wide?
14:05:29 <b_jonas> so it should be "F calculus"
14:05:49 <mauke> http://rafb.net/p/IVxl2d86.html
14:05:52 <mauke> er, sorry
14:05:56 <b_jonas> dolio: thanks for the info
14:06:00 <Mips_> vixey: sorry typo: I would ship beer world wide ...
14:06:12 <mauke> haskell code is at http://nopaste.info/1da3f459d7.html
14:06:27 <dolio> I really liked First-class Polymorphism with Existential Types. Made me with ghc had them. :)
14:06:52 <mauke> Mips_: hard to tell what z is
14:07:08 <luite_> is there some simple/standard data structure for a queue in haskell?
14:07:16 <vixey> luite_: ([a],[a])
14:07:20 <mauke> luite_: Data.Sequence
14:07:26 <luite_> vixey: not that one ;)
14:07:39 <mauke> oh, might be zipWith
14:07:57 <mauke> Mips_: do you have Params.hs?
14:08:51 <b_jonas> luite_: what vixey says, it's called banker's queue and described in Chris Okasaki's book well, together with a sample implementation
14:08:52 <Mips_> mauke: this is the only code i got
14:09:14 <mauke> Mips_: well, we don't know what z, f and f' are
14:09:52 <mauke> and i and j
14:09:57 <dolio> ([a],[a]) is a bit bare bones. You probably want to wrap that in a module or something. :)
14:10:00 <luite_> b_jonas: yes I know what she meant, and the implementation (at least for the amortized O(1) one
14:10:03 <b_jonas> Mips_: it imports a module called "Params" which probably exports those variables, but I think that's not a well-known module but one that's for your code
14:10:16 <b_jonas> luite_: good
14:10:25 <b_jonas> I learnt about these in #haskell once
14:10:31 <b_jonas> I still have to read that book once I have time
14:10:39 <b_jonas> it's deep
14:11:02 <b_jonas> but often just a Seq works as well
14:11:38 <b_jonas> even if it's a bit heaviweight for a queue, it does offer the same performance guarantees not counting a constant factor
14:11:53 <b_jonas> Seq from Data.Sequence
14:13:27 <Mips_> b_jones: is it still ossible to revert that function while using this variables and "no numbers" ?
14:13:29 <luite_> b_jonas: yes, I was just looking for some standard package. I don't want to start duplicating all those Seq functions
14:13:53 <b_jonas> Mips_: I don't understand your question
14:14:12 <quicksilver> conal: alwaysE is a poor name.
14:14:27 <quicksilver> conal: it refers to one occurrence being always available
14:14:35 <quicksilver> conal: I call that 'always' as a future.
14:14:47 <Mips_> b_jones: I've got an output of that function and I want to know what the input is, therefore "I only need " a reverted function of this hs script
14:17:45 <conal> quicksilver: got it.  i assumed so at first but then doubted.
14:18:11 <quicksilver> conal: I have 'Always' and 'Never' as explicit constructors in Future.
14:18:23 <conal> quicksilver: oh, yeah.
14:18:34 <quicksilver> conal: means that I can make certain `mappend` collapse totally.
14:18:40 <conal> quicksilver: while i have them in the AddBounds type, as used in Future.
14:18:51 <quicksilver> yeah.
14:19:13 <quicksilver> conal: I didn't parameterise over a time type t
14:19:31 <quicksilver> conal: not because I don't think that's a good idea, but simply because it seemed simpler not to ;)
14:19:45 <conal> lilac: with ZipList, join = diag is consistent with the function monad, since lists are functions.  however, finiteness interferes.
14:20:18 <conal> quicksilver: i parameterized over t because i wanted to learn what properties of t frp needs for what.
14:20:23 <quicksilver> good reason.
14:20:36 <conal> quicksilver: i was surprised to learn Ord is almost always enough.
14:20:57 <lilac> conal: i assume the problem is that different orderings give different lengths for the resulting list
14:21:17 <conal> lilac: orderings?
14:21:27 <lilac> associations of >>=
14:22:27 <conal> lilac: gee.  i guess i don't really know.
14:23:46 <byorgey> lilac: quickCheck says the associative law fails =)
14:24:05 <byorgey> lilac: although I couldn't tell you what the counterexample is that it found, since there's no way to print the functions =)
14:24:28 <cpfr> mauke, i use cabal does make install just do what you want, or do i need to write a Makefile that calls Setup.hs in the appropiate ways
14:24:53 <mauke> cpfr: I use this generic makefile: http://mauke.ath.cx/stuff/haskell/Makefile
14:25:03 <b_jonas> ok, thanks for the hints, I'll read that applicative paper some time
14:25:10 <mauke> should work with all normal cabalized packages
14:25:13 <quicksilver> lilac: yes.
14:25:20 <mauke> cpfr: so you don't have to do anything :-)
14:25:21 <quicksilver> lilac: different paths around the cuboid
14:25:33 <quicksilver> lilac: (if you think of 3x4x5 as a cuboid)
14:25:38 <cpfr> mauke, i will add that to mine, thank you :)
14:26:09 <quicksilver> conal: and btw, since join . fmap = >>=, my definition is the same as Cales.
14:26:14 <quicksilver> conal: which makes me hapy :)
14:26:55 <conal> quicksilver: yeah, nice :)
14:26:59 <b_jonas> join . fmap = (>>=) ?
14:27:05 <b_jonas> hmm
14:27:28 <byorgey> well, it's actually (join .) . fmap
14:27:43 <byorgey> ...is (=<<)
14:29:01 <quicksilver> byorgey: yes I was being vague
14:29:13 <quicksilver> (about association)
14:29:31 <romildo> Hi.
14:30:39 <pejo> Can I somehow set variables to be passed on to Makefiles with cabal? (I'd like a DESTDIR equivalent).
14:31:00 <dcoutts> pejo: you can do anything you like in the Setup.hs
14:31:49 <pejo> dcoutts, I'm trying to build a specfile for an rpm of a cabal package
14:31:56 <romildo> I am just starting to look at GADTs and would like to see a complete example where heterogenous lists are accomplished with GADTs instead of existential type variables, as sugested in http://en.wikibooks.org/wiki/Haskell/GADT.
14:32:09 <dcoutts> pejo: oh, what has that got to do with makefiles?
14:32:13 <romildo> Anyone?
14:32:41 <b_jonas> ok, good night
14:32:51 <dcoutts> pejo: you can certainly do ./setup copy --destdir=$imagedir
14:33:19 <pejo> dcoutts, ooh. does install respect --destdir as well?
14:33:30 <blackh> Q: Anyone know of an applicative operator equivalent to "do {x <- m; return f a}", with the f a on the right?  i.e. This would be <$> flipped.
14:34:17 <dcoutts> pejo: no it cannot because install involves registering. You want copy.
14:34:33 <dcoutts> pejo: then the rpm has to register any lib as a post-install action.
14:34:41 <pejo> dcoutts, ah. Bummer.
14:35:05 <dcoutts> pejo: it's not a problem though, copy is exactly what package managers need to make an install image dir
14:36:07 <dcoutts> pejo: or have I missed something?
14:36:38 <dcoutts> pejo: does the package you're building an rpm for use makefiles internally? is that the issue?
14:37:33 <pejo> dcoutts, we're doing some pretty horrendous things internally. But copy brings me a bit further, just need to ponder some more now. :-)
14:37:37 <quicksilver> conal: 0 `Stepper` (let e = joinE . fmap snd $ accumE (0,mempty) ((fmap (\b -> \(a,_) -> (a,alwaysE (a+b))) ev) `mappend` (fmap (\a -> \(_,_) -> (a,mempty)) e)) in e)
14:37:42 <blackh> ...I'm doing a lot of
14:37:42 <blackh>   f = do
14:37:42 <blackh>     x <- getSomething
14:37:42 <blackh>     return $ ...big transformation of x...
14:37:42 <blackh> I just wondered if there was some fancy way of doing it.
14:38:16 <quicksilver> conal: OK, that's a bit nasty :) that's the snapshotWithR inlined, with sumE and catMaybesE inlined too.
14:38:16 <BeastZero> can anyone confirm for me that there is no easy way to access serial ports in Haskell?
14:38:19 <dcoutts> pejo: if you're using build-type: Make then ./setup copy --destdir=$DEST ends up calling make copy destdir=$DEST
14:38:34 <dcoutts> pejo: check Distribution.Make for the details
14:38:37 <quicksilver> blackh: fmap (\x -> big transformation of x) getSomething
14:38:39 <blackh> BeastZero: This IS a library for serial ports. I have used it.
14:38:55 <quicksilver> blackh: also written "(\x -> big x) <$> getSomething"
14:39:34 <blackh> quicksilver: I 'd rather have it on the right so I can eliminate the dangling bit on the end - perhaps this is not done. :)
14:39:47 <BeastZero> Oh really? I just assumed I would have to use FFI and termios or something similar
14:39:54 <quicksilver> blackh: well it can be "big <$> getSomething"
14:39:55 <hydo> ooo, I didn't know about <$>
14:40:00 <quicksilver> blackh: for suitable values of 'big'
14:40:01 <blackh> I could use `flip fmap` but that's not all that readable.
14:40:14 <dolio> romildo: http://hpaste.org/7116#a1
14:40:15 <blackh> hydo: I only learnt about it yesterday, so I know how you feel!
14:40:25 <quicksilver> I'm not aware of a common name for flip fmap.
14:40:49 <blackh> BeastZero: It doesn't support B115200 though which is a serious bug.
14:40:52 <necroforest> Is there a Prelude function that is like map but takes a list of functions, a single value, and outputs a list of that each function applied to that value?
14:41:03 <blackh> BeastZero: ...finding it...
14:41:03 <mauke> necroforest: sequence
14:41:04 <mokus> blackh: getSomething >>= return.big  -- ?
14:41:11 <necroforest> instead of (a->b) -> [a] -> [b] it would be [(a->b)] -> a -> [b]
14:41:15 <geezusfreeek> :t sequence
14:41:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
14:41:18 <blackh> mokus: That's probably the best option
14:41:20 <necroforest> thanks
14:41:20 <BeastZero> blackh: thanks a lot
14:41:20 <quicksilver> necroforest: you can also use map for that.
14:41:28 <necroforest> quicksilver, how?
14:41:32 <quicksilver> > map ($5) [(+1),(*2),(/3)]
14:41:33 <mauke> :t map (flip id)
14:41:34 <lambdabot>   [6.0,10.0,1.6666666666666667]
14:41:34 <lambdabot> forall a c. [a] -> [(a -> c) -> c]
14:41:41 <mauke> :t map . flip id
14:41:42 <lambdabot> forall a c. a -> [a -> c] -> [c]
14:41:51 <quicksilver> necroforest: although mauke is also write when he says it is sequence.
14:41:56 <quicksilver> s/write/right/
14:41:59 <dolio> romildo: Oh. That thing in the wikibook is just showing how to define an existential type using GADT syntax. Everything else would be exactly the same.
14:44:58 * hydo is looking forward to the release of the Monads chapter of "Learn You A Haskell" 
14:45:07 * hydo eyes BONUS...
14:45:09 <neun> :t $
14:45:10 <lambdabot> parse error on input `$'
14:45:17 <blackh> BeastZero: I hope you're not going to say "I am using Windows."
14:45:27 <romildo> dolio, I am not still looking into type families, so I think I will keep your example for later study.
14:45:38 <BeastZero> blackh: haha, no I'm not
14:45:51 * shapr boings cheerfully
14:45:53 <shapr> Wassup folks?
14:46:03 <blackh> BeastZero: I have not found it yet, but I'm still looking - this is for POSIX.
14:46:17 <edwardk1> ack its a shapr
14:46:29 <saml> > "I'm Cool" syntax error!
14:46:29 <shapr> edwardk1: Dude, you succ
14:46:30 <lambdabot>   <no location info>: parse error on input `;'
14:46:39 <romildo> dolio, I am trying to write a complete program using gadts for heterogeneous list. Maybe I will come back with it.
14:46:39 <edwardk1> naturally
14:46:40 <shapr> Er, I mean.. you've been incremented.
14:47:03 <vixey> lol
14:47:12 <BeastZero> blackh: thanks a lot, i've been confused about this all afternoon
14:47:26 <vixey> romildo, ... don't do it!
14:47:29 <dolio> romildo: Yeah. My hpaste example is more of an HList type thing (only less fancy). You could also look at it as inductive tuples/heterogeneous vectors, of course.
14:47:38 <shapr> edwardk: Ah, much beter.
14:48:47 <sbahra> Hi.
14:48:53 <sbahra> Anyone here use lhs2TeX?
14:48:53 <dolio> That's really what HList is, too, I suppose. It's not really a heterogeneous list as far as you usually think of lists in Haskell.
14:48:56 <Nafai> shapr!
14:48:59 <Nafai> @shapr
14:48:59 * lambdabot loves , so no slapping
14:49:00 <sbahra> neun, :t ($)
14:49:03 <sbahra> > :t ($)
14:49:04 <lambdabot>   <no location info>: parse error on input `:'
14:49:15 <sbahra> :t ($)
14:49:16 <lambdabot> forall a b. (a -> b) -> a -> b
14:49:21 <neun> sorry, wrong window
14:49:32 <shapr> yay!
14:49:38 <ziman> @shapr everybody tonight
14:49:38 <lambdabot> I won't; I want to go get some cookies instead.
14:49:40 <shapr> Nafai: Hiya! How's life?
14:49:41 <blackh> BeastZero: Found it but it's slightly more than 5K!
14:49:46 <shapr> @users
14:49:47 <lambdabot> Maximum users seen in #haskell: 568, currently: 539 (94.9%), active: 31 (5.8%)
14:49:50 <shapr> Ah, busy.
14:49:55 <blackh> BeastZero: So it won't fit on pastebin. I'll stick it on the web. One moment.
14:49:57 <Nafai> shapr: Pretty good.  New toy to play with!
14:50:20 <shapr> Yeah, I've seen that, got any new code for your toy?
14:50:23 <BeastZero> blackh: ahh nice, thanks so much
14:50:57 <sbahra> So, no one has played with lhs2TeX?
14:51:01 <blackh> BeastZero: blacksapphire.com/~blackh/jsim.hs
14:51:54 <dolio> > unzip [(5,6),(7,8),undefined]
14:51:55 <lambdabot>   ([5,7* Exception: Prelude.undefined
14:52:14 <saml> > unzip [porn_collection.zip]
14:52:15 <lambdabot>   Not in scope: `porn_collection'
14:52:30 <BeastZero> blackh: this looks like exactly what I'm looking for. thanks a lot, glad I asked in here
14:52:35 <blackh> BeastZero: ghc 6.10.1 seems to have B115200.  Anyway - this is the reason why I am not setting the bit rate in this example - because it wasn't possible in older ghc.
14:53:17 <shapr> sbahra: I haven't played with it recently, 2006 was the last time I think.
14:53:54 <sbahra> It doesn't do anything for me.
14:54:01 <sbahra> lhs2TeX test.hs -o test.tex
14:54:06 <BeastZero> blackh: ahh, alright, understandable...thanks for the help
14:54:11 <sbahra> I just get test.tex, as output.
14:58:16 <sbahra> Screw it, I'll just use the style file.
14:58:21 <deepak> can anyone reverse engg. this code module Message (M,e) where
14:58:21 <deepak> import Data.Char
14:58:21 <deepak> import Params
14:58:21 <deepak> newtype M = M {
14:58:21 <deepak>         t :: String
14:58:22 <deepak> }
14:58:24 <deepak> g = 0 : 1 : z (+) g (tail g)
14:58:26 <deepak> k = (take 1000 g) ++ [mod (op (k!!(f (x-i))) (k!!(f (x-j)))) (2^64) | x <- [1000..]]
14:58:29 <sbahra> deepak, please use hpaste :)
14:58:30 <deepak> e m = z (\n c -> chr (f (op (f' (ord c)) (mod n 255)))) (drop 1000 k) (t m)
14:58:31 <mauke> ops!
14:58:39 <sbahra> deepak, hpaste.org
14:59:05 <vixey> looks dumb
14:59:05 <mauke> deepak == Mips_?
14:59:22 <vixey> deepak, you aren't even using descriptive variable names
14:59:52 <mauke> it's not his code
14:59:56 <mauke> he doesn't know haskell
14:59:58 <vixey> deepak, it's utterly pointless putting 100 g's onto the front of k and then dropping them off again
15:00:27 <vixey> 1000* even more pointless
15:00:51 <deepak> module Message (M,e) where import Data.Char import Params newtype M = M { t :: String}g = 0 : 1 : z (+) g (tail g)k = (take 1000 g) ++ [mod (op (k!!(f (x-i))) (k!!(f (x-j)))) (2^64) | x <- [1000..]]e m = z (\n c -> chr (f (op (f' (ord c)) (mod n 255)))) (drop 1000 k) (t m)
15:01:10 <sbahra> deepak, hpaste.org
15:01:13 <Zero_In_Mood> btw vixey thanks again for ur help :) i think i got it now :)
15:01:14 <deepak> pls. help me i am a newbie
15:01:17 <vixey> deepak, putting it on one line doesn't make it easier to read
15:01:26 <sbahra> deepak, http://www.hpaste.org/
15:01:28 <Zero_In_Mood> i got another task will be hard too thou i think i ll try it with CPS again.. got an idea
15:01:32 <vixey> Zero_In_Mood, good .. :)
15:01:36 <vixey> Zero_In_Mood, what is the other task?
15:01:46 <deepak> i know tat but pls
15:02:01 <Botje> deepak: put it on hpaste. then people will help you.
15:02:06 <vixey> deepak, pls nothing, Start by using descriptive variable names
15:02:12 <Zero_In_Mood> hmm..
15:02:19 <vixey> deepak, change 'g' to 'fibs'
15:02:32 <vixey> oh it's not even fibs
15:02:35 <vixey> I don't know what 'z' is
15:02:39 <romildo> Does the following declaration realy gives a type for an heterogeneous list?
15:02:44 <romildo> data TE2 = forall b. Show b => MkTE2 [b]
15:02:44 <romildo>    data TE2 = forall b. Show b => MkTE2 [b]
15:02:46 <Zero_In_Mood> function which returns every possible Tree combination.. u re just givin it height
15:03:08 <Botje> romildo: not really
15:03:10 <vixey> Zero_In_Mood, oh sounds like a job for nondetermism
15:03:12 <ddarius> romildo: No.  There's no such thing as a heterogeneous list.
15:03:15 <mauke> romildo: that looks like type TE2 = [String], basically
15:03:49 <Zero_In_Mood> what job? Nondetermism? sry dunno that word :)
15:03:56 <romildo> It s put as a type for heterogeneous list at http://en.wikibooks.org/wiki/Haskell/GADT
15:05:23 <romildo> So I think that page needs correction.
15:06:20 <dolio> That's actually a list of some type b that is an instance of the Show class.
15:06:25 <dolio> But they're all the same b.
15:07:12 <dolio> To get a 'heterogeneous' list, you'd do "data Wrap = forall b. Show b => W b" and then [Wrap] would be such a list.
15:07:39 <dolio> Because you can put a value of any type in Show in such a list (after wrapping it).
15:07:40 <ddarius> Except that there is nothing "heterogeneous about it, as clearly evidenced by the type.
15:07:50 <lilac> deepak: where did you get this code?
15:09:08 <gwern> @where+ haiku http://haskell.org/haskellwiki/Haiku
15:09:08 <lambdabot> Done.
15:09:18 <gwern> @where haiku
15:09:18 <lambdabot> http://haskell.org/haskellwiki/Haiku
15:11:31 <sbahra> Ah, I see how lhs2tex works :/
15:11:48 <gwern> any thoughts on http://haskell.org/haskellwiki/Haiku ?
15:11:53 <gwern> does anyone have any I missed?
15:13:23 <ddarius> I like 1.1
15:14:42 <gwern> maybe I'd get more responses on -cafe
15:15:48 * gwern wonders how the heck I got to compiling Haskell haikus from christmas shopping
15:18:04 <thetallgu1> template haskell question: is there something similar to -ddump-splices that actually does the splicing and shows the whole resulting source code?
15:19:50 <thetallgu1> gwern: s/it is like Haiku/Like Haiku itself/   ?
15:20:31 <gwern> thetallgu1: no, that's what the entry reads, capital haiku
15:20:58 <gwern> I waffled on whether this was an typo, a reference to the OS, or some sort of type-related joke
15:21:04 <gwern> and decided to just leave it alone.
15:21:19 <thetallgu1> Oh, I see, yes it seems to pre-exist, so I agree.
15:21:24 <thetallgu1> Too bad.
15:22:09 <gwern> unfortunately, the contest submission seems to be corrupt or something, but at least the haiku survives
15:22:35 <thetallgu1> Maybe I can edit the corrupt copy.. ;-)
15:23:30 <lilac> gwern: take the fixed point of / prepend zero, prepend one / zipWith plus bind tail
15:23:33 <gwern> it's strange, the Haiku.hs seems to be a gzipped file, which uncompresses to HaskellHaiku.hs. or something
15:23:58 <gwern> @quote haiku
15:23:59 <lambdabot> FMota says: Haskell's cryptic form \ is natural to some folks \ and so is Haiku's
15:24:06 <lilac> > fix ((0:).(1:).(zipWith (+) =<< tail))
15:24:08 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:24:09 <gwern> bah. I missed an obvious source >.<
15:24:10 <gwern> bah. I missed an obvious source >.<
15:24:12 <gwern> er.
15:24:15 <gwern> @quote haiku
15:24:15 <lambdabot> FMota says: Haskell's cryptic form \ is natural to some folks \ and so is Haiku's
15:24:17 <gwern> @quote haiku
15:24:17 <lambdabot> FMota says: Haskell's cryptic form \ is natural to some folks \ and so is Haiku's
15:24:35 * exbio  Musik now : (Playing)  Gary Numan - Blind  00:03/07:01  0%  44kHz  stereo  192kbps   || Yeah great sounds!  
15:24:52 <yannikruhs_> geht alle meine spendeseite pls
15:24:55 <yannikruhs_> http://www.pennergame.de/change_please/5339709/
15:25:03 --- mode: ChanServ set +o sjanssen
15:25:07 --- mode: sjanssen set +b *!*=yannikru@*.dip0.t-ipconnect.de
15:25:07 --- kick: yannikruhs_ was kicked by sjanssen (sjanssen)
15:25:14 <lilac> hah, even \b didn't fall for that
15:25:24 --- mode: ChanServ set -o sjanssen
15:25:33 <gwern> thetallgu1: note the Haiku in that one too :)
15:25:36 <ziman> that was quick :)
15:28:17 <thetallgu1> so, no template haskell experts around?
15:30:32 <gwern> thetallgu1: there rarely are.
15:30:42 <gwern> thetallgu1: but iirc can't you look at th expressions in ghci?
15:31:16 <thetallgu1> I can see the expressions with -ddump-splices
15:31:36 <thetallgu1> I just wanted to be able to read the entire resulting source in emacs
15:31:55 <gwern> hm. reminds me of slime's expand-macro features
15:32:15 * kfish wants a "Pointless Haskell" tshirt
15:33:07 <kfish> can has hylomorphism?
15:33:38 <thetallgu1> only if you stop scratching my chair
15:36:00 <gwern> http://haskell.org/haskellwiki/Num_instance_for_functions <-- why is this in humor? I don't get it
15:41:07 <mauke> because it should be generalized to Applicative, not just functions
15:41:16 <Valodim> oh of course
15:41:18 <Valodim> :)
15:45:22 <ehird> I'm a try learn you a haskell for a change. :P
15:46:17 <hydo> ehird: I learned more from that in a night than I had from RWH and the wiki book. Looking forward to the rest of it.
15:46:29 * hydo looks at BONUS again...
15:46:49 <ehird> I basically started with YAHT and random stuff, and I've read like 3 pages of RWH.
15:46:50 <ehird> :P
15:47:51 <hydo> I don't have much of a mathematical background... which probably has something to do with it.
15:47:57 <ehird> ditto
15:48:04 <dolio> You can't really generalize it to Applicative without running into overlapping instances, though.
15:48:07 * ehird skims the start of learn you to check it out
15:48:15 <Aser> hi. do you know a tutorial or something about how to run different applications /commands aviable on the computer out of haskell
15:48:19 <dolio> Unless you invent yet another newtype wrapper.
15:49:20 * Saizan wonders how a pointless haskell t-shirt would look like
15:49:57 <ehird> Saizan: it would be full of text about how unneeded it is
15:49:59 <ehird> instantrimshot.com
15:50:11 <Saizan> Aser: look at System.Cmd and System.Process
15:51:59 <Saizan> ehird: nah, it'll be full of ap/flip/(.) :)
15:52:27 * ehird holds up "you got the joke" sign :D
15:53:21 <ehird> "Also, I think you can do Haskell development with that wacky mouse with one button, although I'm not sure"
15:53:23 <ehird> hahaha :)
15:55:10 * ddarius does Haskell development with that wacky mouse with 101 buttons.
15:55:43 <Zero_In_Mood> vixey maybe u got any idea for an algorithm for me? how i can create every possible tree ? basically  it should be done very well with CPS but i cant come up with anything.
15:56:25 <Zero_In_Mood> for every height 1 u can create 18 different trees. the 2 single tree with S and W n 16 Trees made of V and 16 undertrees...
15:56:31 <ehird> ddarius: hardcore.
15:57:00 <Zero_In_Mood> but i nthe next step.. i have to create for each those 16 V-Trees again those 18 trees...
15:57:42 <Zero_In_Mood> so okay it can be done kinda but i dunno how i should integrate the heigth u just give as Input into the function
15:58:20 <edwardk> gwern: because of the unfortunate definition that it entails when it comes to application of numeric constants
15:59:06 <edwardk> gwern: i tried really really hard to like the Num instance for functions but 2 _|_ = 2 is a little weird
15:59:10 <lilac> in concurrent haskell, how might one implement a broadcast event?
16:00:09 <ddarius> You make a process that broadcasts events.
16:00:17 <gwern> edwardk: weird as in bad, or WEIRD LIKE A FOX
16:00:18 <Saizan> edwardk: (not knowing the context) you can't make a strict version?
16:00:38 <edwardk> saizan: the problem is that 2 (3 + 4) = 2 not 14
16:00:59 <edwardk> saizan: it just leads to some confusing corner cases
16:01:17 <ehird> init takes a list and returns everything except its last element.
16:01:20 <ehird> This I did not know.
16:01:34 <ddarius> So have the Num instance embed into a ring action.
16:02:10 <edwardk> i was just explaining the joke
16:02:12 <lilac> the fromInteger = (*) instance for Num /nearly/ works :-/
16:03:28 <jethr0> wasn't it possible with the "scrap you boilerplate" stuff to create all instances of a data type? (i.e. exhaustively generate all combinations of constructors)?
16:08:17 <lilac> ddarius: "make a process that broadcasts events": can you clarify that?
16:09:11 <AHMAD1NEJAD> ok
16:09:16 <AHMAD1NEJAD> any haskell/opengl experts
16:09:31 <iceWM_is_bestest> does haskell have map-reduce or does it go beyond map-reduce?
16:09:37 <iceWM_is_bestest> for distributed computing?
16:09:44 <ehird> iceWM_is_bestest: depends on the lib.
16:10:18 <aleator> How do you distribute haskell? (SMP stuff is well and nice but..)
16:10:34 <AHMAD1NEJAD> what, like cabal?
16:11:11 <ray> i think he means parallelizing
16:11:12 <aleator> No distribute as in distibute over a cluster.
16:11:24 <AHMAD1NEJAD> ah
16:11:38 <AHMAD1NEJAD> ideally, isn't that built into the cluster itself?
16:11:54 <Saizan> distribution is not built into the language
16:12:08 <Saizan> and there aren't many libraries for it yet
16:12:35 <aleator> I saw some libs that were dead and buried, but nothing current.
16:12:56 <iceWM_is_bestest> hm
16:13:01 <iceWM_is_bestest> liek vs hadoop
16:13:05 <iceWM_is_bestest> what does haskell have?
16:13:14 <iceWM_is_bestest> for multi box text crunching
16:13:26 * ehird *crickets*
16:13:40 <lilac> heh
16:13:48 <orbitz> ou can use hadop
16:13:53 * lilac watches tumbleweed
16:14:10 <kfish> AHMAD1NEJAD, http://www.cs.vu.nl/~ralf/MapReduce/paper.pdf
16:14:18 <mapreduce> Ahem.
16:14:33 <ehird> mapreduce: pick a less generic name :P
16:14:38 <Saizan> see? we've mapreduce on #haskell.
16:14:43 <mapreduce> I'm not moaning. :)
16:14:50 <ehird> @faq Can Haskell map and reduce?
16:14:50 <lambdabot> The answer is: Yes! Haskell can do that.
16:15:08 <AHMAD1NEJAD> heheh
16:15:27 <AHMAD1NEJAD> somebody was talking about that earlier in a different channel, i think
16:15:31 <Saizan> we have super easy parallel mapreduce, still almost nothing on the distributed side
16:15:33 <AHMAD1NEJAD> how haskell would render SQL obsolete
16:15:51 <AHMAD1NEJAD> i had no idea what they were talking about
16:15:57 <mapreduce> AHMAD1NEJAD: You can see a little of that in linq.
16:16:05 <Saizan> or happs
16:16:07 <mapreduce> Admittedly not Haskell, but heavily inspired by Haskell.
16:16:52 <Saizan> happs supports only replication currently
16:20:36 <lilac> is there a good way to implement a broadcast event? all the things i've come up with so far are slow or evil.
16:21:49 <SamB_XP> lilac: in what context ?
16:23:38 <lilac> SamB_XP: i have a value which i want to update, and i have multiple threads waiting for it
16:23:56 <lilac> SamB_XP: some of these threads may decide to wait for the next value instead
16:24:06 <lilac> (and wait again)
16:24:15 <SamB_XP> hmm ?
16:24:42 <SamB_XP> you're still being pretty vague ...
16:24:46 <Saizan> lilac: use a Chan and dupChan?
16:25:07 <lilac> Saizan: that'd work, but it'd leak space (which is what i'm trying to avoid)
16:25:40 <lilac> unless there's some way to empty out the chan i'm duping from
16:27:21 <ddarius> broadcaster inChan outChans = forkIO (forever (readChan inChan >>= forM_ outChans . flip writeChan))
16:29:00 <Saizan> lilac: http://code.haskell.org/~Saizan/hspread/Control/Concurrent/Chan/Closeable.hs <-- Chan with separated Read and Write ends
16:29:03 <lilac> ddarius: i don't know outChans in advance
16:29:11 <eu-prleu-peupeu> hello Hppl
16:29:23 <eu-prleu-peupeu> i am a creative thinker
16:29:24 <eu-prleu-peupeu> (just so you know)
16:29:40 <Saizan> lilac: see if forkChan suits you
16:30:40 <ddarius> lilac: It's easy to have broadcaster hand ones out or accept new ones.
16:31:07 <Zero_In_Mood> hmm damn i really cant come up with  any useful code... may someone can help me ?
16:32:31 <Raevel> Zero_In_Mood: what's your problem?
16:33:34 <Zero_In_Mood> i got a data type : data VTree = S |W |V Vtree Vtree Vtree Vtree
16:34:07 <Zero_In_Mood> the function i have to create with one time list compreheion and oen time without is a functio nwhere u just get the heigth of this tree
16:34:18 <Zero_In_Mood> and the output should be every possible tree...
16:34:27 <Zero_In_Mood> so height 0 = no tree
16:34:51 <Zero_In_Mood> height 1 = 18 trees (s , W and all V x1 x2 x3 x4)
16:35:22 <lilac> Saizan: a Chan-style object seems overcomplicated for my needs
16:35:26 <Zero_In_Mood> height 2 = for each of those 16x V x1 x2 x3 x4 trees there are height 1 trees
16:35:48 <Zero_In_Mood> thats my idea how to create the program thou i dunno exactly how to start.. neither how to integrate the height..
16:35:50 <Saizan> > iterate (concatMap (\l -> do c <- "ab"; return $ c:l)) ["x","y"]
16:35:51 <lambdabot>   [["x","y"],["ax","bx","ay","by"],["aax","bax","abx","bbx","aay","bay","aby"...
16:36:41 <Zero_In_Mood> ah sry heigth 1 ist [S,W]
16:37:12 <Zero_In_Mood> but from height 2 starting u stil lgot for each of those 16x V x1 x2 x3 x4 trees one S and one W tree.. i guess..
16:42:58 <blackh> I have a Rank2Types question... I hope someone can help.  I'm trying to stuff something into a parent that doesn't specify the type of the child...
16:42:59 <blackh> (>>~) :: RequestClass r => Fragment storage -> SubPage r storage -> Fragment storage
16:42:59 <blackh> fragment >>~ subPage = fragment {
16:42:59 <blackh>         getSubPages = [subPage]
16:42:59 <blackh>     }
16:43:00 <blackh> Error is:
16:43:02 <blackh>     Couldn't match expected type `r1' against inferred type `r'
16:43:04 <blackh>       `r1' is a rigid type variable bound by
16:43:06 <blackh>            the polymorphic type
16:43:08 <blackh>              `forall (r1 :: * -> *). (RequestClass r1) => [SubPage r1 storage]'
16:43:10 <blackh>              at XXXX/Widget/Widget.hs:237:23
16:43:12 <blackh>       `r' is a rigid type variable bound by
16:43:14 <blackh>           the type signature for `>>~' at XXXX/Widget/Widget.hs:236:22
16:43:16 <blackh>       Expected type: SubPage r1 storage1
16:43:18 <blackh>       Inferred type: SubPage r storage1
16:43:20 <blackh> It works if I do it straight, but I can't write a function to do it.  Anyone know how to solve this problem without adding the type 'r' to Fragment?
16:43:47 <Zero_In_Mood> Raevel so u got any idea ?
16:44:16 <Saizan> blackh: use hpaste.org next time
16:45:17 <jsn> why does haskell have exceptions? don't they mean well-typed programs can go wrong?
16:45:42 <mauke> Nothing is an exception
16:45:42 <Saizan> blackh: giving it a type like :: Fragment storage -> (forall r. RequestClass r => SubPage r storage) -> Fragment storage
16:46:02 <Saizan> jsn: you mean monadic or "error" ones?
16:46:29 <Saizan> jsn: the latter comes from allowing non-termination
16:46:29 <jsn> Saizan: what is the difference?
16:47:00 <jsn> error ones are <<loop>>, floating point error and the like?
16:47:19 <blackh> Zero_In_Mood: Are you trying to make every permutation of the tree where depth == n?
16:47:35 <Saizan> jsn: that the monadic ones are represented in the type, i.e. IO, Either e, Maybe comprehend exceptions in their effects
16:47:54 <Saizan> > undefined
16:47:55 <lambdabot>   * Exception: Prelude.undefined
16:47:55 <ddarius> jsn: In Haskell 98, you can't catch 'error' exceptions, so they are no different from bottom.
16:48:23 <Zero_In_Mood> yes blackh thats it!
16:48:35 <Zero_In_Mood> thou there is a hint not to try it out for numbers higher than 3 :)
16:48:54 <jsn> Saizan: well, the "monadic" ones are manageable -- you can tell when you are handling them, you get compiler warnings if you don't match all patterns, &c.
16:49:16 <jsn> ddarius: isn't "file not found" such an exception?
16:49:22 <blackh> Saizan: Thank you - that worked.
16:49:27 <ddarius> jsn: No.
16:50:06 <jsn> :t openFile
16:50:08 <lambdabot> Not in scope: `openFile'
16:50:48 <jsn> openFile :: Filepath -> IOMode -> Handle    not     openFile :: Filepath -> IOMode -> Either IOError Handle
16:51:08 <ddarius> I'm very confident that that is IO Handle not just Handle.
16:51:16 <jsn> ddarius: oh, yeah :)
16:51:28 <jsn> so catch catches two kinds of exceptions?
16:51:50 <jsn> oh, IO comprehends exceptions, too
16:51:54 <jsn> interesting
16:52:04 <ddarius> jsn: IOErrors are catchable and there no difficulty understanding them (you can just view IO as having an ErrorT transformer mixed in).
16:52:14 <ddarius> catch in Haskell 98 only catch IOErrors
16:52:22 <jsn> ah
16:52:33 <Raevel> Zero_In_Mood: well, you will need to pass along the depth, and decrement it for each recursive call
16:52:48 <jsn> so the really exceptional exceptions are actually a small group
16:53:09 <Zero_In_Mood> kinda wait i upload paste
16:53:24 <Zero_In_Mood> i tried somethign thou .. i dunno.. and neither dont know how to make without list comprehension
16:54:51 <Zero_In_Mood> http://hpaste.org/12762
16:55:00 <jsn> when a computation that may error is encapsulated with Maybe or Either, i don't have the option not to handle it
16:55:21 <blackh> Zero_In_Mood: Crikey
16:55:39 <Zero_In_Mood> Crikey ?
16:55:41 <jsn> but i can use openFile and not receive any kind of warning, to ensure i handle the exception
16:55:47 <jsn> is not bad?
16:56:19 <jsn> why are exceptions used instead of returning    IO (Either IOError Handle)    ?
16:56:23 <Zero_In_Mood> hmm weird expression.. Crikey for good or bad ? :)
16:56:44 <ddarius> jsn: If you use Maybe or Either as a monad, you get the exact same behavior.  You don't have to handle any "error" immediately, it just propagates outward.
16:56:54 <blackh> Zero_In_Mood: Translation: Oh my God
16:57:12 <ddarius> The only difference with IO is that the RTS is the outermost level.
16:57:15 <Zero_In_Mood> hmm...
16:57:18 <jsn> ddarius: hmm
16:57:30 <blackh> Zero_In_Mood: It must be possible to do it with Data.List.permutations (new in ghc 6.10.1)
16:57:38 <ddarius> Whereas with Maybe or Either (or whatever) you eventually have to actually do a case analysis (if you care about the result)
16:57:45 <Zero_In_Mood> blackh : u can call me by name :) oh blackh sry we re only allowed to use winHugs...
16:57:54 <ddarius> :t try
16:57:55 <lambdabot> Not in scope: `try'
16:58:00 <ddarius> :t System.IO.try
16:58:01 <lambdabot> Not in scope: `System.IO.try'
16:58:04 <Zero_In_Mood> and in that task one time list comprehension and one without :)
16:58:12 <ddarius> :t Control.Exceptions.try
16:58:12 <lambdabot> Couldn't find qualified module.
16:58:15 <ddarius> @hoogle try
16:58:16 <lambdabot> Control.Exception try :: IO a -> IO (Either Exception a)
16:58:16 <lambdabot> System.IO.Error try :: IO a -> IO (Either IOError a)
16:58:16 <lambdabot> Text.Parsec.Prim try :: Stream s m t => ParsecT s u m a -> ParsecT s u m a
16:58:16 <blackh> Zero_In_Mood: Crikey is a NZ/Australian euphemism for "Christ"
16:58:30 <jsn> ddarius: interesting
16:59:25 <jsn> so i could write try in front of every IO operation to ensure i handle the cases
16:59:26 <Zero_In_Mood> yeah i figured that out after the explanation :Oh my god :)
16:59:55 <ddarius> It would be a bit tedious, but otherwise trivial to write a newtype wrapper around IO with a 'run' function that will reify any pending exceptions guaranteeing that you have to handle them.
17:00:12 <iceWM_is_bestest> reify means what?
17:00:26 <iceWM_is_bestest> why is darcs more fun than svn?
17:00:28 <iceWM_is_bestest> ;)
17:00:32 <iceWM_is_bestest> riddle me that
17:00:42 <SamB_XP> svn isn't fun
17:01:12 <ddarius> There's a #darcs channel.  You can troll there if you like.
17:01:48 <Zero_In_Mood> blackh: thou is my function looking okay? or are there some mistakes ? and if not how can i do this in a form without list comprehension ?
17:01:52 <blackh> genBmp h = [S, W]++map (\[a,b,c,d] -> V a b c d) permutations (genBmp (h-1))   (or something
17:02:34 <blackh> I'll try it...
17:02:36 <jsn> so i guess this could be irritating, since you can't handle errors en masse
17:03:10 <Zero_In_Mood> hmm try it.. thou u dont have to n just give me advices or so.. but prolly will be faster if u just do it lol
17:03:11 <jsn> i guess what i'd like it to be forced to handle them before they pass to the RTS, but not be forced to handle them at the call site
17:09:06 <mauke> :t (and .) . zipWith (==)
17:09:07 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
17:13:19 <dmead_> channel
17:13:27 <dmead_> slashdot requires your input
17:13:27 <dmead_> http://tech.slashdot.org/article.pl?sid=08/12/05/2346235
17:14:34 <dmead_> dons, Cale, dcoutts, lispy, http://tech.slashdot.org/article.pl?sid=08/12/05/2346235
17:18:31 <iceWM_is_bestest> so is perl better than haskell?
17:18:37 <iceWM_is_bestest> [shields up]
17:19:10 <mauke> perl is haskell: http://mauke.ath.cx/stuff/haskell/hax.pl
17:19:18 * BMeph slaps iceWM_is_bestest around a bit with a large trout
17:19:27 --- mode: ChanServ set +o Igloo
17:19:34 <dmead_> i weep for the species
17:19:36 --- mode: Igloo set +b *!i=d8cde040@gateway/web/ajax/mibbit.com/x-36b68e8ac39f368e
17:19:39 --- kick: iceWM_is_bestest was kicked by Igloo (Igloo)
17:19:45 <dmead_> haha
17:22:22 <centrinia> Is (unsafePerformIO randomIO) frowned upon?
17:22:35 <dmead_> sort of
17:22:36 <SamB_XP> heck yes
17:22:45 <dmead_> theres no type verification with that
17:22:53 <dmead_> soo use with caution
17:22:54 <dmead_> i've used it
17:22:57 <dmead_> it's not a big deal
17:23:17 <SamB_XP> you don't get referential transparency at all that way, though
17:23:18 <dmead_> oh randomio
17:23:20 <dmead_> wot?
17:23:46 <blackh> Zero_In_Mood: http://hpaste.org/12763
17:23:48 <dmead_> well theres no alternative if you want to have IO without haveing monads everywhere
17:23:58 <blackh> Zero_In_Mood: Does that work?
17:24:13 <mauke> what do you mean by "monads everywhere"?
17:24:40 <mauke> you know strings are a monad, right?
17:24:41 <SamB_XP> I mean, you are always supposed to prove that referential transparency holds whenever you use unsafePerformIO ...
17:25:12 <edwardk> @tell conal damnit i need to stop writing whole screens full of code and then looking over in Reactive and finding them already there!
17:25:12 <lambdabot> Consider it noted.
17:25:15 <blackh> dmead_: I have never seen such a catalogue of imbecility as the comments on that slashdot article!
17:25:36 <centrinia> Which slashdot article?
17:25:42 <dmead_> http://tech.slashdot.org/article.pl?sid=08/12/05/2346235
17:25:50 <dmead_> well their all newbs
17:25:53 <centrinia> Did they pump a bunch of (unsafePerformIO randomIO) values in there? :(
17:26:29 <SamB_XP> blackh: I'm guessing you haven't read much slashdot ;-P
17:27:36 <blackh> SamB_XP: Chip makers are trying to TRICK us into writing parallel software! Don't let them push you around!
17:28:06 <SamB_XP> blackh: hah
17:28:11 <SamB_XP> that IS imbecilic
17:29:44 <Saizan> is there a reactive irc library yet?
17:30:04 <edwardk> blackh: they are! ;)
17:30:08 <Zero_In_Mood> blackh
17:30:18 --- mode: Igloo set -o Igloo
17:30:23 <Zero_In_Mood> blackh: didnt work... for h=1 its correct bit higher then 1
17:30:35 <Zero_In_Mood> there is : Program error: pattern match failure: genBmp 2
17:32:06 <blackh> Zero_In_Mood: I don't get the error.  Anyway - I give up!
17:32:11 <conal> edwardk: :)
17:32:12 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
17:32:40 <Zero_In_Mood> yeah but thanx for the try maybe i ll get it by myself working on the basic on ur program.. since mine sucked even more :D
17:33:05 <edwardk> conal: you'll be pleased to know that i just basically re-entered word for word the code that is in FRP.Reactive.Fun ;)
17:33:42 <edwardk> conal: the only thing i did differently was make use a bunch of Control.Category.* and the category extra bifunctor stuff
17:36:36 <centrinia> What is thermodynamic programming?
17:37:26 <SamB_XP> why don't you tell us ?
17:37:32 <SamB_XP> I've never heard of it before!
17:37:43 <centrinia> I just read it from that slashdot article. :p
17:39:12 <blackh> centrinia: Whatever it is, it's probably stupid. :)
17:39:19 <Saizan> the one where you exploit entropy to solve your problems?
17:39:29 <centrinia> Because the Slashdot article is stupid? :)
17:39:58 <blackh> centrinia: I am in a sillier mood that usual today.
17:40:21 <centrinia> Saizan: Every operation is reversible.
17:40:59 <alexei> is there a way to get rid of concatenation here: subsets n (x:xs) = [ x:ys | ys <- subsets (n-1) xs ] ++ subsets n xs
17:41:05 <SamB_XP> centrinia: oh, we call that "space leak"
17:42:14 <centrinia> Why is it called a "space leak"?
17:42:51 <Saizan> centrinia: you've to store some of the inputs to reverse most of the operations
17:43:25 <centrinia> Oh yeah, there shouldn't be many nontrivial online algorithms.
17:47:28 <FunctorSalad> online algorithms?
17:48:10 <centrinia> Online algorithms spit out the output while you input the input. :)
17:48:19 <gwern> they what?
17:48:44 <george__> entropy from themodinamic is different from information entropy
17:49:36 <centrinia> gwern: They do not need the entire input to be present before returning parts of the output. :)
17:50:04 <pumpkin_> ooh entropy talk in #haskell
17:50:29 <pumpkin_> anyone have a good haskell function for computing sliding-window entropy efficiently? :P
17:50:48 <gwern> centrinia: ah. I was confused by people who speak of an 'offline sort' where some of the data to be sorted is not in ram
17:51:29 <pumpkin_> out-of-core is what I've generally heard that referred to
17:51:34 <centrinia> What is sliding-window entropy?
17:52:39 <pumpkin_> you compute shannon entropy over a sliding window on your data, so basically pass it indices 1..n, 2..(n+1), 3..(n+2) and so on
17:52:55 <SamB_XP> pumpkin_: that terminology sounds positively ancient
17:53:07 <pumpkin_> SamB_XP: which?
17:53:09 <SamB_XP> it's been a LONG TIME since anyone has used core
17:53:10 <pumpkin_> out-of-core? :P
17:53:39 <pumpkin_> I dunno, I'm not that old :P
17:53:47 <pumpkin_> so I must've heard it somewhere, right? :)
17:54:02 <SamB_XP> well, I'm not saying it's not current
17:54:04 <gwern> I learned about 'core' from the Jargon File...
17:54:09 <SamB_XP> it just sounds like an old term
17:54:41 <pumpkin_> what's a more common term?
17:55:08 <gwern> ram?
17:55:10 <pumpkin_> http://www.sciencedirect.com/science?_ob=ArticleURL&_udi=B6TYD-4MYVG41-5&_user=4257664&_rdoc=1&_fmt=&_orig=search&_sort=d&view=c&_acct=C000022698&_version=1&_urlVersion=0&_userid=4257664&md5=8224ba804cf38adf2b6c23e273b18cb0
17:55:12 <centrinia> pumpkin_: Why not do this: slide _ _ [] = []; slide f n as = (take n as):slide f n (tail as);
17:55:13 <gwern> memory?
17:55:33 <centrinia> Oh, slide f n as = (f $ take n as): slide f n (tail as)
17:55:50 <SamB_XP> are tape sorting algorithms good for anything else ?
17:55:52 <pumpkin_> centrinia: yeah I have something like that, but it's recomputing entropy unnecessarily
17:56:00 <centrinia> Of course. :)
17:56:09 * BMeph is prone to position statements.
17:56:27 <gwern> SamB_XP: good for sorting on hard disks?
17:56:29 <pumpkin_> http://www.springerlink.com/content/x513l54426180832/ :o
17:56:35 <gwern> since their random access isn't so hot
18:02:05 <pumpkin_> quiet in here tonight
18:02:12 <pumpkin_> haskellers out partying
18:02:20 <pumpkin_> gettin their monads on
18:02:33 <ikkebr> i guess they are reading slashdot
18:02:42 <ikkebr> and finding a functional way to comment that article
18:03:16 <pumpkin_> lol
18:04:33 <centrinia> > let { slide app rem n acc [] = [];  slide app rem n acc as = acc:(if length as < n then slide app rem n (rem (head a) acc) (tail as) else slide app rem n (app (a!!n) (rem (head a) acc)) (tail as)) } in slide (+) (flip (-)) 3 0 [1..10]
18:04:34 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
18:05:07 <centrinia> > let { slide app rem n acc [] = [];  slide app rem n acc as = acc:(if length as < n then slide app rem n (rem (head a) acc) (tail as) else slide app rem n (app (as!!n) (rem (head a) acc)) (tail as)) } in slide (+) (flip (-)) 3 0 [1..10]
18:05:08 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
18:05:14 <pumpkin_> :o
18:05:27 <centrinia> Sorry. :(
18:05:57 <centrinia> Friday nights are not good times for programming elegant code. :)
18:06:01 <pumpkin_> :P
18:06:15 <pumpkin_> well I can already apply entropy with my sliding window function
18:06:29 <jethr0> "apply entropy"?
18:06:57 <pumpkin_> map my entropy function to each of the sliding windows specified by my slide function
18:08:45 <centrinia> I was just thinking of having an accumulation value that holds the value of the entropy of previous window and successively adding the entropy introduced by the new element and subtracting the entropy of the element that got pushed out of the window.
18:09:14 <pumpkin_> yeah, that's what I'd like
18:09:22 <pumpkin_> but it's hard to do right, because the number of unique elements can change
18:09:52 <pumpkin_> which affects the probabilities for all elements depending on which symbol gets kicked out at the end of the window
18:12:52 <centrinia> Well, the entropy of an element would only be  - (n_i/N) * log (n_i/N) and any movement of a window by one index that both pushes a symbol out and adds a symbol in will only change two n_i values.
18:12:56 <centrinia> The N shouldn't change.
18:13:30 <centrinia> If you are at the end, the N will decrease because you might be running out of symbols to put in the window.
18:13:50 <pumpkin_> I say just stop as soon as your window can't be filled :P
18:14:09 <centrinia> So, just keep along a (Map a Int) to keep the n_i
18:14:24 <centrinia> pumpkin_: That will be easier to have fixed sized windows. :p
18:15:14 <centrinia> If you slide a window by one index, decrement the value for the popped element in the Map and increment the value for the pushed element in the Map.
18:15:41 <pumpkin_> then you still need to go over the map and count the unique elements in it at each iteration
18:15:54 <pumpkin_> I guess it's cheaper than before still :)
18:16:07 <centrinia> No, the Map a Int doesn't allow for duplicate keys.
18:16:20 <pumpkin_> yeah, I know, but if you ask for how many elements in it, it needs to search the map doesn't it?
18:16:26 <pumpkin_> or does it maintain a child count?
18:16:36 <centrinia> The number of elements is supposed to be the window size.
18:16:46 <centrinia> Shouldn't it?
18:16:58 <pumpkin_> well, you care about the number of unique elements
18:17:00 <SamB_XP> wouldn't that be the sum of the values ?
18:17:17 <centrinia> SamB_XP: That's the same thing. :)
18:17:59 <centrinia> Wait, why would the number of unique elements be important?
18:18:33 <pumpkin_> because you care about the possible values of the random variable, not the window size, really
18:18:35 <pumpkin_> right?
18:18:36 <centrinia> The sum of -p(x_i)*log(p(x_i)) is -(n_i/N)*log(n_i/N), right?
18:19:39 <zooko> Dear people of #haskell: I am trying to install ghc on several computers.
18:19:56 <zooko> I started with the ghc-6.10.1 tarball.  On one of the computers it worked, but then I got stuck trying to get cabal-install.
18:20:03 <zooko> On the others, I was unable to build ghc.
18:20:11 <zooko> How do I ask for help?
18:20:30 <saml> like this "halp"
18:20:42 <lilac> Well, what went wrong with cabal-install, and what went wrong building ghc?
18:20:58 <zooko> Okay.
18:20:59 <centrinia> @faq How do I ask for help?
18:20:59 <lambdabot> The answer is: Yes! Haskell can do that.
18:21:03 <centrinia> There.
18:21:20 <pumpkin_> centrinia: so p(x_i) is the probability of the symbol being value i, right? that depends on the number of values it could conceivably take in the current window, right?
18:21:30 <centrinia> pumpkin_: Yes.
18:21:42 <zooko> What went wrong with cabal-install is that I want to install it gnu stow into directories such as /usr/local/stow/HTTP-3001.0.4
18:21:46 <centrinia> Uh, no.
18:22:19 <zooko> and it seems like it needs to share a central database somewhere.
18:22:29 <zooko> So I guess I can get over that by installing in "--user" mode somewhere else.
18:22:31 <centrinia> What is the probability of somehow finding an element x == x_i in a list with n_i instances of each x_i?
18:22:35 <zooko> So let's turn instead to my failures to build ghc.
18:22:45 <lilac> zooko: you want cabal to install its packages with stow, or you want to install cabal with stow?
18:23:19 <zooko> lilac: the latter, but cabal-install apparently requires that I first manually install HTTP-3001.0.4 and a couple of other things,
18:23:24 <zooko> and I was trying to manually install those with stow.
18:23:33 <lilac> zooko: you don't need to do that manually.
18:23:36 <zooko> But I am aware that there is a "--user" mode...
18:23:37 <zooko> Hm.
18:23:45 <zooko> I followed this "quick start for linux":
18:23:48 <lilac> the cabal tarball comes with a bootstrap.sh script which installs most of the prerequisites
18:23:57 <zooko> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
18:24:01 <pumpkin_> centrinia: so say my list has 16 elements in it, and one symbol occurs once, and the other occurs 15 times... the probability of the first symbol is 1/16, and the other is 15/16, right?
18:24:19 <centrinia> Yes.
18:24:32 <zooko> Yes, but I wasn't satisfied with that bootstrap script because it seemed to be mashing multiple separate packages together into some central directory...
18:24:33 <pumpkin_> say that first symbol is at the edge of the window and we slide off it
18:24:54 <pumpkin_> we need to sum over the number of symbols that actually occur in the stream don't we?
18:24:58 <lilac> zooko: yes, it'll do that. but that's necessary in order for ghc to find them
18:25:02 <zooko> So I guess I'll give up on having control over HTTP-3001.0.4 separate from zlib-0.4.0.4 and just let bootstrap.sh mush them together.
18:25:12 <pumpkin_> assuming another of the second symbol enters the stream so 16/16 is that symbol
18:25:14 <pumpkin_> it has 0 entropy
18:25:17 <lilac> zooko: or at least, if you want to go down the stow route, you're in territory for which i have no map
18:25:18 <zooko> As long as it won't need root privileges to write into my system, of course.
18:25:24 * zooko nods.
18:25:26 <centrinia> pumpkin_: I thought you wanted to compute the entropy of each individual window.
18:25:38 <centrinia> ...locally.
18:25:41 <pumpkin_> yeah
18:25:43 <pumpkin_> I do
18:26:00 <pumpkin_> so for the first window there's a low entropy, and then you slide off it, and get 0
18:26:03 <pumpkin_> for the next window
18:26:38 <centrinia> The first window would have -((1/16)*log(1/16) + (15/16)*log(15/16)) entropy.
18:26:44 <pumpkin_> yup
18:26:58 <zooko> Okay, so I decided to accept the ugliness and allow cabal-install's bootstrap.sh script to just write things into -- ugh -- ~/.cabal/bin
18:27:01 <centrinia> The second window would have -((0/16)*log(0/16) + (16/16)*log(16/16)) entropy.
18:27:03 * zooko makes a face.
18:27:14 <centrinia> Wait.
18:27:15 <pumpkin_> centrinia: log of 0? :P
18:27:18 <zooko> So I just followed the quickstart guide of unpacking the tarball and running bootstrap.sh
18:27:32 <centrinia> Okay, we can use the convention that 0*log(x) == 0. :p
18:27:38 <zooko> Bit it failed.
18:27:41 <zooko> But if failed.
18:27:49 <pumpkin_> centrinia: maybe that is simple enough to work... hmm
18:28:20 <lilac> zooko: i'll take the average of those two and assume it failed :)
18:28:23 <zooko> http://codepad.org/eqxgKbWh
18:28:31 <zooko> lilac: :-)
18:28:35 <zooko> I think I'm getting too tired.
18:28:43 <pumpkin_> centrinia: hrm hrm
18:29:10 <lilac> zooko: the root cause is somewhere earlier than the pasted errors
18:29:14 <zooko> That codepad.org link is the output from
18:29:15 <zooko> ok.
18:30:42 <zooko> Here is a paste: http://codepad.org/JbQoHDOp  Looks like I need to use "bash ./bootstrap.sh" instead of just "./bootstrap.sh" ?
18:32:06 <centrinia> Actually, changing the entropy S = -sum_{i \in I} -(n_i/N) log (n_i/N) = -(sum_{i \in I} log(n_i))/N - N log (N) to T = -sum_{i \in I} -(n_i/M) log (n_i/M) would just involve T = (S + N log (N)) * N /M - M log (M)
18:32:12 <zooko> Got further with bash: http://codepad.org/roFVIU5L
18:32:14 <lilac> it's possible that cabal-install 0.5.2 doesn't support ghc6.10; you could try cabal-install 0.6.0
18:32:45 <centrinia> So it is not that difficult to change the number of elements in the sample and still compute the entropy.
18:33:03 <pumpkin_> centrinia: I wonder if this can be done in a single foldl
18:33:15 <lilac> zooko: http://hackage.haskell.org/packages/archive/cabal-install/0.6.0/cabal-install-0.6.0.tar.gz
18:33:18 <pumpkin_> I guess it's hard to keep track of what gets pushed out of the window
18:33:28 <centrinia> Not really.
18:33:55 <centrinia> You could zipWith (update) (symbols) (drop n symbols) :p
18:34:06 <lilac> zooko: right, according to hackage, cabal-install 0.5.2 won't build on ghc-6.10, and you do need 0.6.0
18:34:10 <centrinia> Wait.
18:34:30 <centrinia> foldl update initial (zip symbols (drop n symbols)) :p
18:34:52 <zooko> lilac: so, sorry.  <phonoe>
18:35:35 <pumpkin_> an IntMap would probably be more efficient in conjunction with fromEnum (if we assume symbols are Enum)
18:35:41 <centrinia> I guess initial would be a pair consisting of the entropy and the Map.
18:35:51 <centrinia> pumpkin_: Are the symbols Ints?
18:35:52 <pumpkin_> @instances Enum
18:35:53 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
18:36:04 <centrinia> What the?
18:36:07 <centrinia> > [()..()]
18:36:09 <lambdabot>   [()]
18:36:15 <pumpkin_> lol
18:36:18 <lilac> > [()..]
18:36:19 <lambdabot>   [()]
18:36:31 <lilac> > succ ()
18:36:32 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
18:36:33 <centrinia> Hmm.
18:36:36 <mmorrow> , id id id id id id id id
18:36:41 <lunabot>  luna: No instance for (GHC.Show.Show (a -> a))
18:36:46 <centrinia> > succ 3.1415926
18:36:47 <lambdabot>   4.1415926
18:36:53 <centrinia> > succ True
18:36:54 <lambdabot>   * Exception: Prelude.Enum.Bool.succ: bad argument
18:36:57 <centrinia> > pred True
18:36:58 <lambdabot>   False
18:37:13 <pumpkin_> > fromEnum True :: Int
18:37:15 <mmorrow> > pred False
18:37:15 <lambdabot>   1
18:37:16 <lambdabot>   * Exception: Prelude.Enum.Bool.pred: bad argument
18:37:35 <lilac> > iterate succ LT
18:37:36 <lambdabot>   [LT,EQ,GT,* Exception: Prelude.Enum.Ordering.succ: bad argument
18:37:57 <lilac> > iterate succ 'a'
18:37:59 <lambdabot>   "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137...
18:38:02 <centrinia> > map (fromEnum . (+ 3.1415926535) . (/10.0)) [0..9]
18:38:03 <mmorrow> i dislike how enum error out instead of wraps
18:38:04 <lambdabot>   [3,3,3,3,3,3,3,3,3,4]
18:38:11 <centrinia> Wait.
18:38:14 <pumpkin_> lol
18:38:21 <lilac> mmorrow: i'd prefer succ, pred and head to return Maybe :)
18:38:28 <centrinia> Why is 3.1415926535 the same as 3.2415926535 modulo Enum?
18:38:51 <pumpkin_> > fromEnum 3.652 :: Int
18:38:52 <lambdabot>   3
18:39:03 <pumpkin_> it seems strange for Float and Double to be enumerable
18:39:10 <lilac> it is strange
18:39:12 <centrinia> I agree.
18:39:22 <pumpkin_> I get Bool, Int, etc.
18:39:23 <mmorrow> lilac: that too i suppose. i'd be all for /not/ ever calling error unless the computer is on fire, and only then i fit's out of batteries
18:39:25 <pumpkin_> () is odd
18:39:50 <centrinia> Furthermore, if one were to enumerate Float and Double, each enumeration should include all Floats and Doubles respectively.
18:39:52 <SamB_XP> mmorrow: lol
18:39:52 <lilac> > map (**0.5) [1..10]
18:39:54 <lambdabot>   [1.0,1.4142135623730951,1.7320508075688772,2.0,2.23606797749979,2.449489742...
18:40:02 <lilac> ^ you couldn't do that without Enum Double
18:40:12 <pumpkin_> :o
18:40:15 <pumpkin_> why not?
18:40:20 <mmorrow> and you could just shut down gracefully if you're out of batteries, so i guess there's not ever a reason for error to be called
18:40:39 <lilac> because [1..10] must be [Double] since (**) is a -> b -> a
18:40:44 <lilac> @type (**)
18:40:45 <lambdabot> forall a. (Floating a) => a -> a -> a
18:40:48 <pumpkin_> what would be more interesting is if succ 3.1415124 actually gave me the next smallest float larger than that (given IEEE 754) :P
18:40:50 <lilac> or even that
18:40:52 <mac_wooster>  /join #emacs
18:41:06 <centrinia> > map ((**0.5) . fromIntegral) [1..10]  -- Why can't you just do this?
18:41:06 <mmorrow> pumpkin_: (+eps) -- ?
18:41:07 <lambdabot>   [1.0,1.4142135623730951,1.7320508075688772,2.0,2.23606797749979,2.449489742...
18:41:20 <lilac> centrinia: look at all those extra characters :)
18:41:22 <pumpkin_> mmorrow: yeah, but if the enumeration were based on that
18:41:29 <mmorrow> hehe
18:41:40 <lilac> mmorrow: next representable value /= (+eps)
18:41:52 <centrinia> > fromEnum (1.0/0.0)
18:41:53 <pumpkin_> > succ 3.14
18:41:54 <lambdabot>   0
18:41:54 <lambdabot>   4.140000000000001
18:41:55 <mmorrow> i can't believe there's even a Double Enum instance to begin with..
18:42:00 <pumpkin_> see, that's just silly
18:42:03 <centrinia> > succ (1.0/0.0)
18:42:04 <lambdabot>   Infinity
18:42:09 <mmorrow> lilac: ok, (+2*eps)
18:42:10 <centrinia> > pred (1.0/0.0)
18:42:11 <lilac> > pred (1.0/0.0)
18:42:11 <lambdabot>   Infinity
18:42:12 <saml> > succ 0.000000000000000000000000000001
18:42:12 <pumpkin_> > pi
18:42:12 <lambdabot>   Infinity
18:42:14 <lambdabot>   1.0
18:42:14 <lambdabot>   3.141592653589793
18:42:17 <pumpkin_> > succ pi
18:42:18 <lambdabot>   4.141592653589793
18:42:23 <mm_freak_> dolio: is there any reason to prefer Logic over lists (given that [] is a MonadLogic instance, too)?
18:42:25 <lilac> mmorrow: 1e308 + 2*eps == 1e308
18:42:27 <pumpkin_> > pi succes
18:42:28 <lambdabot>   Not in scope: `succes'
18:42:29 <saml> > succ []
18:42:30 <lambdabot>       No instance for (Enum [a])
18:42:30 <lambdabot>        arising from a use of `succ' at <inte...
18:42:47 <mmorrow> lilac: heh, you know what i mean ;)
18:42:49 <dolio> mm_freak_: Logic should be faster, I think.
18:43:20 <lilac> mmorrow: yep. :) but 'next representable value' in floating point is a /weird/ operation
18:43:24 <mm_freak_> dolio: are there cases, where lists perform better?
18:43:28 <centrinia> > [Infinity..]
18:43:29 <lambdabot>   <no location info>: parse error on input `]'
18:43:36 <pumpkin_> lol
18:43:39 <mmorrow> lilac: indeed
18:43:41 <centrinia> > [1.0/0.0 ..]
18:43:42 <lambdabot>   [Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,In...
18:43:47 <centrinia> That's weird.
18:43:48 <lilac> although i do like the IEEE754-is-1s-complement-integer thing
18:44:04 <mm_freak_> maybe Infinity is not a constructor
18:44:06 <mm_freak_> > Infinity
18:44:07 <lambdabot>   Not in scope: data constructor `Infinity'
18:44:12 <mmorrow> lilac: actually, eps is the smallest /nonzero/ value
18:44:14 <dolio> mm_freak_: I haven't actually benchmarked it. But GHC tends to generate better code for continuation passing implementations of monads than ones based on datatypes.
18:44:15 <mmorrow> octave:2> 2*eps
18:44:15 <mmorrow> ans =  4.4409e-16
18:44:20 <pumpkin_> I don't like that 754 defines two 0s, it seems wasteful... they should've used a 2's complement thingy on the significand or something like that
18:44:48 <centrinia> Wait, shouldn't  fromEnum . pred == (- 1) . fromEnum ?
18:44:52 <pumpkin_> mmorrow: then adding eps doesn't seem to do the job, depending on your magnitude
18:45:08 <mm_freak_> dolio: ok, thanks…  it's just that lists take a special role in GHC…  in many cases, no real lists are computed at all
18:45:10 <dolio> mm_freak_: Although maybe fusion can alleviate some of that.
18:45:16 <lilac> pumpkin_: the representation is actually very neat for a number of reasons. and two zeroes really does help some real numerical problems :)
18:45:16 <mmorrow> octave:3> 0+eps
18:45:16 <mmorrow> ans =  2.2204e-16
18:45:17 <mmorrow> ?
18:45:19 <gwern> @remember BruceTurner It is a little known fact that, just like the programming language Python requires you to be familiar with a few stock Monty Python phrases, Haskell requires you to brush up your knowledge of The Simpsons.
18:45:19 <lambdabot> Okay.
18:45:25 <gwern> @quote Simpsons
18:45:26 <lambdabot> BruceTurner says: It is a little known fact that, just like the programming language Python requires you to be familiar with a few stock Monty Python phrases, Haskell requires you to brush up your
18:45:26 <lambdabot> knowledge of The Simpsons.
18:45:32 <centrinia> > (\x -> (fromEnum . pred $ x) == ((- 1) . fromEnum $ x)) (1.0/0.0)
18:45:32 <pumpkin_> lilac: representing limits to 0 on the left? :P what else?
18:45:33 <lambdabot>       No instance for (Num (Int -> Int))
18:45:33 <lambdabot>        arising from a use of `negate...
18:45:34 <gwern> @flush
18:46:15 <lilac> pumpkin_: anything which depends on signed infinities for a start :)
18:46:18 <dolio> mm_freak_: LogicT is the real point of that package, since it's a proper monad transformer, unlike ListT (and is likely even better performance-wise than a proper ListT than Logic is over []).
18:46:29 <dolio> I put in Logic for completeness.
18:46:58 <centrinia> Wait, knowledge of which television show does Java require?
18:47:13 <dolio> That and the various operations in the MonadLogic class.
18:47:13 <pumpkin_> :o
18:47:17 <mm_freak_> dolio: yeah, that's was my assumption…  and there would be nothing wrong with Logic, but it's quite inconvenient to use
18:47:20 <BMeph> centrinia: (- 1) isn't a function. Sad, but true. :)
18:47:34 <centrinia> :t (- 1)
18:47:35 <lambdabot> forall a. (Num a) => a
18:47:43 <centrinia> Why not?
18:47:45 <pumpkin_> can't we think of constants as functions with 0 arguments?
18:47:46 <mm_freak_> dolio: in fact, i'd end up using 'map return' on lists all the time, anyway, so i could just use lists right away
18:47:50 <centrinia> :t (+ 1) -- This is a function
18:47:51 <lambdabot> forall a. (Num a) => a -> a
18:48:14 <Axman6> pumpkin_: i always did
18:48:33 <dolio> mm_freak_: Yeah. It gets a bit easier if you define something like 'pick :: MonadPlus m => [a] -> m a ; pick = msum . map return'.
18:48:38 <pumpkin_> centrinia: but I heard many people complaining about the special case - before :/
18:48:43 <BMeph> centrinia: "knowledge of which television show does Java require?" -> I'd say "Big Brother" and/or "Lost" ;)
18:48:48 <gwern> centrinia: dunno. perhaps Gilligan's Island, since it's verbose and got a lot of characters who mess things up
18:48:51 <gwern> @quote Java
18:48:52 <lambdabot> lennart says: I would rather lose my left arm than write it in Java
18:49:03 <gwern> @quote Java
18:49:03 <centrinia> @quote Brainfuck
18:49:04 <lambdabot> dons says: my feeling is that the Java programmers will welcome us as liberators
18:49:04 <lambdabot> No quotes match. The more you drive -- the dumber you get.
18:49:06 <dolio> mm_freak_: did my last message get through?
18:49:14 <mmorrow> ,  let (.-) = subtract in fmap (.-4) [0..9]
18:49:17 <lunabot>  [4,3,2,1,0,-1,-2,-3,-4,-5]
18:49:31 <mm_freak_> dolio: yeah, it did, but somehow that 'pick' function would destroy the point of Logic =)
18:49:35 <gwern> @quote Java
18:49:35 <lambdabot> lennart says: I would rather lose my left arm than write it in Java
18:49:41 <gwern> not many java quotes
18:49:44 <gwern> @quote Perl
18:49:44 <lambdabot> olsner says: I've always mostly equated coding perl and trolling
18:49:49 <gwern> @quote Perl
18:49:49 <lambdabot> emu says: people have gotten so used to the sloppy languages like python and perl which are specified by 1 implementation that they forget there is a difference
18:49:55 <gwern> @quote Perl
18:49:55 <lambdabot> olsner says: most everything gives nicer everything than perl
18:50:03 <mmorrow> yeah, it's especially burdensome since you can define arbitrary symbolic "operators" on the fly in haskell :P
18:50:05 * gwern will stop there
18:50:06 <dolio> mm_freak_: I've thought about including that in the logict package, but it really should be in Control.Monad.
18:50:13 <centrinia> @quote Python
18:50:13 <lambdabot> dons says: keroppi: i was thinking of a similar thing recently, on a bus travelling between the hotel and the google summer of code summit, sitting next to guys from apache, python, freebsd, netbsd,
18:50:14 <lambdabot> perl, gentoo... the end of open source was a drunk driver away, with only php goons left to run the show
18:50:21 <mmorrow> @quote pl
18:50:21 <lambdabot> pl says: const (((it hurts :) .) . flip flip [] . ((:) .))
18:50:54 <BMeph>  ,  let (.-) = flip subtract in fmap (.-4) [0..9]
18:51:05 <BMeph> ,  let (.-) = flip subtract in fmap (.-4) [0..9]
18:51:08 <lunabot>  [-4,-3,-2,-1,0,1,2,3,4,5]
18:51:20 <mm_freak_> dolio: honestly i wouldn't find any other use for it than in the logic monad
18:51:27 <centrinia> :t ((-1),(- 1)) -- Why are these the same?
18:51:28 <lambdabot> forall a a1. (Num a1, Num a) => (a, a1)
18:51:28 <dolio> mm_freak_: Well, you often need some way to lift several values into a MonadPlus, and lists are way easier than writing out 'return a `mplus` return b ...'
18:51:36 <lilac> @unpl const (((it hurts :) .) . flip flip [] . ((:) .))
18:51:36 <lambdabot> (\ _ m s -> it hurts : ((:)) (m s) [])
18:51:52 <pumpkin_> centrinia: cause - is an ugly hack? :P
18:52:02 <mmorrow> @pl \argh my eyes -> [it hurts, my eyes]
18:52:03 <lambdabot> const (((it hurts :) .) . flip flip [] . ((:) .))
18:52:16 <centrinia> If I put that space between the dash and the other expression, I am pretty sure that I didn't mean to apply negate to it. :)
18:52:18 <mmorrow> (quoting sw17ch there)
18:52:28 <lilac> that was some terrible @unpl'ing
18:52:45 * mmorrow gets a kick out of reading that out loud
18:52:56 <dolio> mm_freak_: Well, I mean, there's any transformer layered over [] or Logic, too. Although in the former case, I guess you can just 'lift' one or more times...
18:52:58 <mmorrow> "const it hurts ........ flip flip"
18:53:05 <mmorrow> lol
18:53:13 <lilac> the smileys are a nice touch
18:53:25 <mmorrow> yeah, those too :)
18:53:38 * Axman6 read it as 'const it hurts colon flip flip null colon
18:53:40 <mm_freak_> dolio: the only MonadPlus, of which i use mzero/mplus/msum, are lists themselves…  other than in general code, i wouldn't find any use for MonadPlus other than in lists
18:53:52 <centrinia> :t let epic = forever in epic . fail
18:53:53 <lambdabot> forall (m :: * -> *). (Monad m) => String -> m ()
18:54:19 <FunctorSalad> mm_freak_: MonadPlus Maybe?
18:54:29 <mmorrow> @pl \_ -> system "sudo halt"
18:54:29 <lambdabot> const (system "sudo halt")
18:54:46 <mm_freak_> i think, [] is the canonical example for MonadPlus, and except Maybe all others are there just for completeness
18:54:53 <lilac> mm_freak_: MonadPlus Parsec.Parser ?
18:55:12 <mm_freak_> huh?  how's that defined?
18:55:13 <FunctorSalad> [] is canonical in that it's the free monoid
18:55:21 <pumpkin_> centrinia: so how did your zipWith thingy work for the entropy?
18:55:39 <Axman6> :t fail
18:55:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
18:55:43 <pumpkin_> is there a handy queue implementation?
18:55:57 <FunctorSalad> pumpkin_: Data.Sequence?
18:56:01 <pumpkin_> :t epic fail
18:56:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => b -> String -> m a
18:56:09 <centrinia> pumpkin_: I never implemented it. It is a Friday night. ;) I did intend to use foldl over pairs of popped out,pushed in symbols.
18:56:11 <FunctorSalad> :t epic . fail
18:56:12 <lambdabot> forall b (m :: * -> *) a. (Monad m) => String -> b -> m a
18:56:24 <pumpkin_> FunctorSalad: cool, thanks
18:56:26 <BMeph> Is there a name for the type constructor from which a fixpoint is constructed?
18:56:32 <lilac> @type epic
18:56:33 <lambdabot> forall a b. a -> b -> a
18:56:41 <lilac> @type monic
18:56:42 <lambdabot> Not in scope: `monic'
18:56:42 <centrinia> @src epic
18:56:42 <lambdabot> Source not found. You type like i drive.
18:56:43 <pumpkin_> guess what epic does :P
18:56:55 <pumpkin_> [21:55:56] <pumpkin_> @let epic = const
18:56:55 <centrinia> > epic 1 2
18:56:56 <lambdabot>   1
18:56:58 <lilac> @check \a b -> epic a b == const a b
18:56:59 <lambdabot>   Not in scope: `epic'
18:57:05 <mm_freak_> lilac: what's the sum of two parsers?
18:57:13 <BMeph> :t epic!fail
18:57:14 <lambdabot>     Couldn't match expected type `Array i e'
18:57:14 <lambdabot>            against inferred type `a -> b -> a'
18:57:14 <lambdabot>     In the first argument of `(!)', namely `epic'
18:57:15 <centrinia> > epic epic fail
18:57:16 <lambdabot>       Overlapping instances for Show (a -> b -> a)
18:57:16 <lambdabot>        arising from a use ...
18:57:18 <gwern> '    Beautiful Soup uses a class called UnicodeDammit to detect the encodings of documents you give it and convert them to Unicode, no matter what. If you need to do this for other documents (without using Beautiful Soup to parse them), you can use UnicodeDammit by itself.
18:57:47 <centrinia> > epic "Foo" 42
18:57:48 <lambdabot>   "Foo"
18:57:50 <BMeph> gwern: Huzzah! :)
18:58:02 <mm_freak_> > const "Foo" 42
18:58:02 <centrinia> Wait, does epic == fst ?
18:58:03 <lambdabot>   "Foo"
18:58:04 <jeffwheeler> gwern: you read Django-related blogs?
18:58:09 <centrinia> ... or const?
18:58:10 <FunctorSalad> @let monic = flip epic
18:58:11 <pumpkin_> centrinia: it's just const :P I defined it in a pm
18:58:11 <lambdabot>  Defined.
18:58:17 <gwern> jeffwheeler: I was suckered in by the _Good Omens_ quote
18:58:19 <BMeph> @type epic id
18:58:20 <lambdabot> forall a b. b -> a -> a
18:58:29 <gwern> http://www.b-list.org/weblog/2008/dec/05/python-3000/
18:58:35 <Axman6> @check \xs -> (reverse.reverse) xs == xs
18:58:36 <lambdabot>   "OK, passed 500 tests."
18:58:53 <edwardk> what parts of category-extras are folks actually using and what do you think folks wouldn't miss?
18:58:53 <pumpkin_> I still think lambdabot should remember the source of things you @let in it
18:58:55 <centrinia> If pumpkin_ defined epic here, why doesn't @src give its implementation?
18:59:00 <mm_freak_> the oracle that gives the right answer to all questions is actually easy to implement
18:59:06 <mm_freak_> @let oracle = const 42
18:59:07 <lambdabot>  Defined.
18:59:10 <pumpkin_> centrinia: it doesn't remember anything @let does
18:59:11 <centrinia> @src oracle
18:59:12 <lambdabot> Source not found. Wrong!  You cheating scum!
18:59:19 <pumpkin_> centrinia: it be dumb
18:59:21 <mm_freak_> > oracle "Is there a god?"
18:59:23 <lambdabot>   42
18:59:24 <edwardk> > oracle (6*9)
18:59:25 <lambdabot>   42
18:59:39 <mm_freak_> > oracle undefined
18:59:39 <centrinia> @let faq = const "Yes! Haskell can do that!"
18:59:40 <lilac> mm_freak_: i'd guess the sum of two parsers tries each of them; can't imagine what else would have the right type
18:59:40 <lambdabot>   42
18:59:40 <lambdabot>  Defined.
18:59:49 <centrinia> > faq "Can Haskell  do that?"
18:59:50 <lambdabot>   "Yes! Haskell can do that!"
18:59:53 <BMeph> @check \a b -> flip epic a b == epic id a b
18:59:54 <lambdabot>   Not in scope: `epic'Not in scope: `epic'
19:00:08 <mm_freak_> lilac: well, what's the zero parser?
19:00:13 <pumpkin_> that's sad, @check doesn't know about @let?
19:00:20 <mm_freak_> the parser that always fails, maybe
19:00:42 <FunctorSalad> ,type parseTest
19:00:44 <lunabot>  luna: parse error on input `type'
19:00:52 <FunctorSalad> what's the @ for the lunabot? :(
19:01:26 <pumpkin_> don't think it has one
19:01:33 <mmorrow> edwardk: my favorite module so far is Control.Category.Ideas (but i'm experimenting with "this-and-that")
19:01:54 <edwardk> Ideas? =)
19:01:54 <centrinia> Is there an arbitrary precision natural number type?
19:02:10 <gwern> 'If you need to interact with systems which want sequences of bytes in some particular encoding, there’s a separate type — bytes — which lets you do that, and to go from str to bytes you have to encode the string, and to get weird non-default encodings you have to say that you’re going to use a weird non-default encoding. '
19:02:12 <BMeph> edwardk: I'm not using it, but I'd like to see what more we could do with comonads.
19:02:20 <pumpkin_> Control.Allegory
19:02:21 <pumpkin_> :o
19:02:28 <mmorrow> edwardk: hehe, as in i read the haddocks with ghci open next to them and get ideas ;)
19:02:29 <pumpkin_> centrinia: Integer?
19:02:29 <dolio> Parser combinators ala Parsec are, at a first pass, just: 'type Parser a = StateT [Char] [] a', so you can read off what all the MonadPlus operations and such are from that.
19:02:32 <jeffwheeler> gwern: that seems like it'll work great.
19:02:38 <pumpkin_> centrinia: half of it is natural :P
19:02:41 <edwardk> pumpkin: on the keep or dump? i'm mostly just thinking about dumping that and a few of the more esoteric ones
19:02:42 <centrinia> pumpkin_: -1 :: Integer is not a Natural number
19:02:51 <gwern> jeffwheeler: well, it doesn't seem too insane
19:03:00 <gwern> 'Even more Python software simply never bothered, which meant that you could quite easily pass a string into some module you were using and find a UnicodeDecodeError staring back at you out of the abyss. '
19:03:12 <mm_freak_> > parse (char 'a' `mplus` char 'b') "" ""
19:03:12 <mm_freak_> unexpected end of input
19:03:12 <mm_freak_> expecting "a" or "b"
19:03:13 <lambdabot>   Not in scope: `parse'
19:03:26 <Zao> gwern: Hopefully it'll get better now with Python 3000.
19:03:27 <pumpkin_> edwardk: no, I wasn't answering you... I'd just looked up Control.Category and Control.Allegory sounded funny :P (I'm a complete n00b so don't even know what I'd get out of Control.Category :) )
19:03:28 <centrinia> pumpkin_: Roughly half of it is natural, even though there are as many naturals in total as in the entire set. :(
19:03:42 <pumpkin_> centrinia: OMG!
19:03:45 <gwern> (if you gaze too long into the bottoms, you will smell bad)
19:04:01 <edwardk> control.allegory seems to be entirely useless in haskell
19:04:05 <mm_freak> lilac: the sum of two parsers indeed tries both
19:04:05 <BMeph> edwardk: Why dump anything? Why not just break things up into semi-dependent modules? The whole of category-extras seems intimidating to me. :)
19:04:06 <mmorrow> edwardk: but i haven't yet used the pkg in a "real" prog yet, but it's just a matter of time
19:04:19 <mm_freak> and the zero parser always fails
19:04:23 <centrinia> :t dump ()
19:04:24 <lambdabot> Not in scope: `dump'
19:04:40 <edwardk> well, i'm perfectly willing to break up the crazier stuff into category-esoterica or something ;)
19:04:53 <pumpkin_> what's the most esoteric thing you can think of?
19:04:55 <mm_freak> > sequence [[1,2],[3,4],[5,6]]
19:04:56 <lambdabot>   [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
19:04:57 <mmorrow> edwardk: also, it's a large package, so it's not easy to get the "big picture"
19:04:58 <pumpkin_> in terms of Control.Category
19:05:12 <centrinia> Which MonadPlus parser always succeeds?
19:05:20 <mm_freak> centrinia: anyChar
19:05:29 <mm_freak> uhm, no
19:05:34 <mm_freak> anyChar <|> eof
19:05:58 <centrinia> What is (anyChar <|> eof) `mplus` otherParser ?
19:06:00 <edwardk> mmorrow: yeah, the problem is most of the Functor, Monad/Comonad stuff is bound together and can't really be split. The Control.Category stuff can arguably be moved out, and really bolts on at right angles to all except the Control.Functor.Categorical stuff
19:06:14 <mm_freak> centrinia: equivalent to (anyChar <|> eof), i guess
19:06:25 <edwardk> i didn't realize how much crap i accumulated in this 3-4 months while i was working on it
19:06:43 <mmorrow> edwardk: my personal opinion is that it shouldn't necessarily be borken up into regular/esoterica, but 10 more themed/manageable packages, because then you'd be able to focus on a particular target
19:07:28 <dolio> 'return a' always succeeds with a.
19:08:06 <mmorrow> edwardk: i love that it's as extensive as it is, but i never know where to start
19:08:17 <edwardk> mmorrow: one worry there is there is a lot of code sharing as it is. the pieces i see factoring it out into is one package with the comonad/monad set, one package with the morphisms that depends on that one, one package with the control.category stuff, and something else perhaps covering the control.allegory stuff
19:08:28 <edwardk> and control.dyad can hit a dumpster
19:08:30 <dolio> mplus is <|>.
19:08:53 <mm_freak> dolio: that's odd
19:08:57 <edwardk> oh and the control.functor.combinator stuff should probably also factor into something else
19:09:03 <dolio> It is?
19:09:03 <mm_freak> > parse (return 1 `mplus` undefined) "" ""
19:09:03 <mm_freak> *** Exception: Prelude.undefined
19:09:04 <lambdabot>   Not in scope: `parse'
19:09:10 <pumpkin_> on Data.Sequence, do viewr and viewl give me functors going in opposite directions over the sequence?
19:09:25 <mm_freak> is Parser strict?
19:09:34 <mm_freak> in the arguments of mplus, that is
19:09:47 <sjanssen> @yow
19:09:48 <lambdabot> Boys, you have ALL been selected to LEAVE th' PLANET in 15 minutes!!
19:10:00 <mmorrow> edwardk: cool, yeah that sounds nice. i guess the chunks that it naturally lends itself to be decomposed into are the natural ones.
19:10:24 <FunctorSalad> edwardk: what do you think about more general categories where membership is determined by classes "Ob cat a" and "Mor cat a1 a2 m"?
19:10:47 <dolio> I get "Right 1" here.
19:10:53 <mm_freak> huh?
19:11:02 <edwardk> my main frustration is that i'd hoped to make a viable set of combinators for building up functors and bifunctors so i could do things like derivatives, etc. unfortunately that gloms the tarball all back together
19:11:12 <edwardk> FunctorSalad: i started down that path, using type families actually
19:11:20 <edwardk> FunctorSalad: i found i couldn't really define any
19:11:33 <FunctorSalad> edwardk: with type families like in RMonad?
19:11:47 <mm_freak> dolio: i get an exception, if the second argument to mplus is undefined (that is, not 'return undefined', but 'undefined')
19:11:51 <FunctorSalad> hmm. could be, I haven't thought about examples yet :)
19:12:00 <mmorrow> edwardk: and if it turns out to be that it can't be decomposed, then that just means we all have to get to know it more :)
19:12:03 <dolio> What version of parsec are you using?
19:12:04 <edwardk> FunctorSalad: its been a while, i ran into some problems with type families and rules exploding when used together so i shelved all my typefamily code
19:12:27 <mm_freak> dolio: 3.0.0
19:12:36 <mm_freak> you?
19:12:41 <FunctorSalad> edwardk: *nod*, I had my difficulties with it too ;)
19:12:44 <dolio> 2.1.something. Let me install 3...
19:12:56 <dolio> That sounds like a bug.
19:13:07 <mm_freak> maybe they made 3.0 stricter for the sake of performance
19:13:42 * BMeph misses the announce feature of hpaste
19:13:53 * BMeph slaps glguy around a bit with a large trout
19:13:58 <dolio> Could be.
19:14:55 * glguy remembers the good old days when he could recompile hpaste
19:14:57 <mm_freak> dolio: it doesn't make sense, though, considering that Parser is just another state monad
19:15:15 <glguy> anyway, hpaste stopped being able to connect to irc from kakapo
19:15:17 <mm_freak> so being strict on the second argument of mplus shouldn't add anything
19:15:38 <edwardk> hrmm, so far i'm thinking of dumping allegory and dyad, and making an esoterica library and moving things like control.(co)monad.indexed and control.(co)monad.parameterized into that. and then potentially ripping control.category and control.functor.combinators out and throwing those in a third category-purist library or something ;)
19:15:45 <glguy> connection gets refused
19:15:47 <dolio> That's not how it's implemented. The 'StateT [c] []' is just the naive implementation.
19:15:54 <dolio> I don't know what the actual internals are.
19:16:23 <edwardk> the morphisms could move into a separate library, but i don't know that they hurt anyone where they are
19:16:24 <mm_freak> hmm, ok
19:16:30 <Axman6> what's the difference between State and StateT?
19:16:55 <edwardk> Axman6: state is a monad in its own right, just add a ... state... stateT transforms another monad by adding state to it
19:16:59 <mm_freak> Axman6: StateT is a monad transformer, which encodes a state transition of type Monad m => s -> m (a,s)
19:17:18 <mm_freak> while State encodes a transition of type s -> (a,s)
19:17:52 <Axman6> righto. so runStateT could have the type s -> [(s,a)]?
19:17:53 <edwardk> State is isomorphic to StateT applied to the Identity monad, its just a lot less noise to use it directly
19:17:58 <mmorrow> i don't think it's a matter of hurting, but a simple matter of overload of initial options to explore
19:18:12 <mm_freak> Axman6: yeah, StateT s [] adds non-determinism
19:18:27 <Axman6> uh huh
19:18:42 <mmorrow> like, once you've got a hook into any lib, then all of a sudden it unfolds in front of you
19:18:56 <mm_freak> edwardk: "a lot"?  well, just that you need to extract the resulting value from Identity =)
19:19:11 <mm_freak> otherwise no additional noise is added (besides some Ts in your code)
19:19:15 <dolio> @seen ddarius
19:19:16 <lambdabot> ddarius is in #haskell-blah, #haskell-overflow and #haskell. I last heard ddarius speak 2h 18m 4s ago.
19:19:29 <edwardk> mm_freak: extracting that result can be a lot of noise ;)
19:19:56 <mmorrow> but before you get that understanding hook, you're (at least i) am like argh <begin emitting random code into ghci in an attempt at executing a genetic algorithm>
19:20:05 <edwardk> mm_freak: plus it can wind up with a ton of useless Identities in patterns, etc.
19:20:22 <mm_freak> edwardk: runState c = runIdentity . runStateT c
19:20:42 <mm_freak> that's the only noise it adds, unless you prefer to carry the Identity around
19:21:10 <mm_freak> but there is no point in doing so =)
19:21:19 <pumpkin_> how do I dequeue something from a Data.Sequence?
19:21:30 <mm_freak> Identity itself isn't mentioned in the stateful computation at all
19:21:49 <mm_freak> but of course, you can use lift . Identity instead of return ;)
19:21:53 <dolio> mm_freak: Oh. It looks like it's because ParsecT is a data instead of a newtype.
19:22:18 <mm_freak> dolio: ParsecT?  i didn't know it even exists
19:22:49 <mmorrow> parsec3
19:22:50 <dolio> mm_freak: And plus is "parserPlus (ParsecT p1) (ParsecT p2) = ..." which is strict in both tags.
19:22:51 <Axman6> what's the easiest way to make a FIFO like type in haskell?
19:22:54 <mmorrow> ReadP++++++
19:22:55 <edwardk> mm_freak: i'm familiar ;) but it is a slippery slope taken it to the pathological extreme you wind up rolling State it out of ACompF (Coreader e) (Context e) ... and then see
19:23:03 <mmorrow> well, i should say
19:23:06 <mmorrow> ReadP+++
19:23:07 <Axman6> @karma ReadP++++
19:23:08 <lambdabot> ReadP++++ has a karma of 1
19:23:11 <pumpkin_> Axman6: ([a], [a]) ? :P
19:23:15 <mmorrow> , src '(+++)
19:23:30 <lunabot>  Killed.
19:23:30 <edwardk> (which btw- in category-extras actually does let you use get and put) ;)
19:23:33 * edwardk got bored
19:23:45 <pumpkin_> Axman6: I think it's the Data.Sequence I got pointed to earlier
19:23:48 <mm_freak> edwardk: i still wonder what noise you're referring to
19:24:09 <pumpkin_> but I don't understand how to dequeue stuff from a sequence
19:24:18 <Axman6> pumpkin_: yeah, your question got me thinking, even though i didn't know what you meant :P
19:24:47 <mmorrow> Axman6: Data.Sequence is nice
19:24:52 <pumpkin_> it feels ugly to do index followed by drop
19:24:56 <edwardk> mm_freak: in general using transformers over identity leads to a lot of noise in the code that is using it. it may not in this case
19:25:25 <mm_freak> edwardk: with "code", i assume you mean source code…  maybe there's just a misunderstanding
19:25:32 <mmorrow> Axman6: check out the "unfoldForestQ" function (not exported) in Data.Tree for an interesting usage of Data.Sequence
19:25:46 <Axman6> hmm, ok
19:27:03 <mmorrow> http://darcs.haskell.org/libraries/containers/Data/Tree.hs
19:27:40 <edwardk> ok, well, one is every site that says State Foo Bar now says StateT Foo Identity Bar or some type alias thereof, but type aliases are second class, because of the position of the monad parameter meaning that if you want to make type MyState t = StateT t Identity you can no longer partially apply MyState
19:28:13 <edwardk> mm_freak: er s/MyState/MyMonad but you get the idea
19:28:39 <mm_freak> yeah, that would add noise to the source code
19:28:42 <jeffwheeler> Is it okay to install HOC on 6.10.1? I'm having a lot of trouble, especially with Control.Exception => Control.OldException and base-3/base-4 both seemingly necessary, simultaneously.
19:28:45 <edwardk> you can work around that by bolting in a newtype, but now you have the overhead of the NEWTYPE too ;)
19:29:00 <edwardk> and there comes the syntactic noise ;)
19:29:17 <mm_freak> but i prefer to write out the state monad fully anyway, and that would be awkward for StateT over Identity
19:29:30 <edwardk> mm_freak: that too
19:29:42 <pumpkin_> dequeue = (S.index 0 &&& S.drop 1) on a sequence look good?
19:30:26 <mm_freak> isn't disallowing partial application of type synonyms an artifical limitation anyway?
19:30:29 <dolio> Isn't dequeue just viewl?
19:30:56 <edwardk> mm_freak: no there is a good technical reason for it.
19:31:21 <dolio> I mean, it isn't the same as your dequeue, but yours is partial, right? :)
19:31:21 <pumpkin_> dolio: I couldn't figure out how to pull stuff off a ViewL
19:31:42 <edwardk> mm_freak: if all of the type parameters are only used on the right side of the type function you can cut them out yourself, that works wonders, but you can't do that with StateT.
19:31:46 <pumpkin_> dolio: but yeah, it did look appropriate :P
19:32:21 <dolio> case viewl s of EmptyL -> whatever ; h :< s' -> whatever else
19:32:28 <dolio> Or whatever the constructors actually are.
19:32:32 <mm_freak> uh…
19:32:44 <mm_freak> Prelude> [1,2,3] :: [Num a => a]
19:32:44 <mm_freak> ghc: panic! (the 'impossible' happened)
19:32:44 <mm_freak>   (GHC version 6.10.1 for i386-unknown-linux):
19:32:44 <mm_freak>         TcTyFuns.flattenType: unexpected PredType
19:32:46 <pumpkin_> hmm
19:32:55 <edwardk> its funny the fact that haskell isn't symmetric with regards to how it takes its type arguments means you have to choose between supporting stuff like MonadTrans (and my HFunctor) by putting the monad on the later slot or making a lot of monads like reader state, etc. into Bifunctors
19:33:03 <dolio> That looks bad.
19:33:22 <pumpkin_> dolio: oh, cool
19:33:46 <Axman6> mmorrow: works fine here
19:33:50 <pumpkin_> dolio: but can I do those cool arrowy things on :< ? :P
19:34:00 <dolio> View patterns?
19:34:15 <edwardk> mmorrow: an alternative to breaking up category-extras, maybe i should write a tour? ;)
19:34:16 <pumpkin_> like ***
19:34:20 <pumpkin_> and first/second
19:34:25 <dolio> Oh. No.
19:35:00 <pumpkin_> hmm
19:35:04 <dolio> mm_freak: Might want to report that.
19:35:22 <BMeph> pumpkin_: How do you do those "arrowy" thinks on a list? :)
19:35:33 <pumpkin_> BMeph: I was hoping to get a pair :P
19:35:34 <BMeph> *things :)
19:35:48 <pumpkin_> like in the dequeue I wrote above
19:35:58 <BMeph> pumpkin_: Dare I ask, "Get a pair...of what?" ;)
19:36:14 <pumpkin_> of the first element and the rest of the sequence, and yes you certainly did dare :P
19:36:35 <zookophone> lilac: could you give me instructions for installing cabal-install with ghc-6.10.1?
19:37:13 <lilac> zookophone: i was about to go to bed :)
19:37:14 <mm_freak> dolio: just going to do that
19:37:37 <lilac> zookophone: i think it should be relatively straightforward if you use cabal-install 0.6.0
19:37:37 <pumpkin> BMeph: har har ;)
19:37:45 <mm_freak> dolio: i guess, a mail to glasgow-haskell-bugs@haskell.org would suffice?
19:37:53 <BMeph> pumpkin_: So, do you plan to handle empty sequences by something other than an error, someday? :)
19:38:00 * pumpkin shows BMeph his mighty arrow and his pair
19:38:05 <lilac> zookophone: anyway, good luck!
19:38:19 <pumpkin> BMeph: my sequence will never be empty :o
19:38:25 <pumpkin> :D
19:38:56 * edwardk watches pumpkin extend his comonadic action
19:38:57 * BMeph gives pumpkin_ a swift kick in the monads!
19:39:00 <dolio> mm_freak: Usually you'd report it on the trac. I think glasgow-haskell-bugs is just a mailing list that receives mail from the trac.
19:39:01 <pumpkin> lol
19:39:41 <mm_freak> mh…  registering sucks =/
19:39:49 <edwardk> sorry pumpkin he didn't want to duplicate with you and extract your... er.. wait, wrong channel not #haskell-blah ;)
19:39:50 <pumpkin> registering where?
19:39:51 <dolio> There's a way to report as guest...
19:39:51 <pumpkin> what
19:40:02 <pumpkin> edwardk: lol
19:40:20 <dolio> Oh, yeah, says on the front page. user guest, password guest.
19:40:40 <edwardk> one of these days i'll be able to log into that trac as something other than guest ;)
19:41:31 <mm_freak> dolio: i'll register
19:42:02 <mm_freak> hmm
19:42:19 <mm_freak> somehow i was just about to enter ">>= less" instead of "| less" on the shell
19:43:32 <chowmeined> When compiling HAppS-Server i get this error:  Not in scope: type constructor or class `E.EXCEPTION_TYPE'
19:46:22 <mm_freak> > undefined :: [Num a => a]
19:46:23 <lambdabot>       Overlapping instances for Show ((Num a) => a)
19:46:24 <lambdabot>        arising from a use...
19:46:38 <dolio> @version
19:46:38 <lambdabot> lambdabot 4.2.2
19:46:38 <lambdabot> darcs get http://code.haskell.org/lambdabot
19:46:49 <dolio> , undefined :: [Num a => a]
19:46:55 <lunabot>  luna: All of the type variables in the constraint `GHC.Num.Num a'
19:47:34 <solrize> yall seen the fp slashdot thread?
19:49:39 <pumpkin> bah, I'm getting confused by this entropy thingy
19:49:41 <blackh> solrize: It's a bit surprising what some people think, isn't it?
19:49:53 <solrize> i'm just starting to look at it blackh
19:53:50 <pumpkin> bah, I'm trying to foldl with a pair of sequence and intmap
19:53:58 <pumpkin> and it's getting hard to manage :P
19:54:20 <pumpkin> maybe I should give in and write my own recursive function
19:57:18 <FunctorSalad> blackh: what is that? :)
19:59:55 <pumpkin> ooh how handy, someone made a list of functional twitters
20:00:39 <pumpkin> twitterers?
20:01:23 <twb> twits
20:01:54 <pumpkin> tw*ts
20:01:58 <blackh> FunctorSalad: Some of the silly stuff has been moded down since I looked.
20:02:53 <blackh> FunctorSalad: The first post is pretty silly though - "we don't need to do parallel programming - chip makers are trying to push us into it"
20:03:03 <pumpkin> yeah :/
20:03:22 <mm_freak> bug reported
20:03:37 <mm_freak> http://hackage.haskell.org/trac/ghc/ticket/2846
20:03:38 <blackh> FunctorSalad: A few people think it's a mathematical fact that programs can't be made (much more) parallel - which I think is nonsense.
20:04:24 <blackh> FunctorSalad: Also the attitude that FP doesn't contribute anything useful.  This is odd to me, because I feel like my head has been prized open since I learnt Haskell
20:04:43 <JohnnyL> anyone here use haskell and opengl?
20:04:56 <blackh> JohnnyL: I put my hand up - I had a play
20:05:01 <pumpkin> blackh: yeah, that attitude pisses me off :/
20:05:13 <JohnnyL> blackh how did it work out, and beefs?
20:05:19 <pumpkin> also, there was an article I was reading earlier on how to make something that isn't obviously parallizable parallel
20:05:29 <pumpkin> where was that, I think in the digest from planet.haskell.org
20:05:47 <blackh> pumpkin: I have been interested in all sorts of non-mainstream things for years, so imbecilic mainstream views of things don't bother me any more.
20:06:14 <pumpkin> aha http://sigfpe.blogspot.com/2008/11/approach-to-algorithm-parallelisation.html
20:06:17 <blackh> JohnnyL: I was very new to Haskell and OpenGL at the time, so I am not sure how helpful I can be!
20:06:37 <blackh> JohnnyL: It seemed to work fine.  I can send you my code if you like.
20:06:49 <JohnnyL> blackh ok. :) thank you very much.
20:08:02 <pumpkin> "But beyond functional programming is thermodynamic computing. This starts with functional, but requires all operations to be reversible. Ideally, the total electrons are conserved - you can never clear a bit - just exchange bits (and of course more complex operations like add, mul, etc - but all reversible and charge conserving). Of course real hardware will still need to make up for losses, but power consumption and heat go way down."
20:08:09 <pumpkin> :o
20:08:26 <pumpkin> :P
20:09:24 <shapr> pumpkin: Sounds great
20:09:31 <pumpkin> sure thing
20:09:36 <pumpkin> (it's from the slashdot thread"
20:10:14 <FunctorSalad> someone said earlier "we call that a space leak" ;)
20:10:18 <shapr> hah
20:10:33 <FunctorSalad> SamB_XP I think
20:11:53 <pumpkin> B. Programmers continue writing to their platform of choice, e.g. .NET, Java, etc., and the guys writing the virtual machines do the heavy-lifting, making the VM execute more efficiently with multi-cores?
20:11:53 <pumpkin> I'll go with B.
20:11:54 <FunctorSalad> (not sure)
20:11:57 <pumpkin> (grr)
20:11:58 <mm_freak> many people associate functional programming with lisp or scheme
20:11:59 <shapr> @seen bos
20:11:59 <lambdabot> I saw bos leaving #haskell and #ghc 2h 59m 59s ago, and .
20:12:16 <pumpkin> oh I think bos is the person I stole the list of twitter handles from
20:13:26 <blackh> pumpkin: I read on (I think a page about pH) that functional programming isn't a silver bullet, but that imperative code inevitably throws parallelism away.
20:13:38 <blackh> ...throws *potential* parallelism away.
20:14:56 <blackh> pumpkin: Personally I think it would be possible to automatically parallelize Haskell code using an advanced JIT compiler (one that doesn't exist yet).
20:15:08 <blackh> pumpkin: I seem to be in the minority with this opinion, though.
20:16:58 <blackh> pumpkin: I just read the A. / B. post - this is one person who will learn the hard way. :)
20:16:58 <pumpkin> blackh: it would be an interesting experiment (but a rather intense one to get started :P)
20:17:19 <pumpkin> it certainly will be able to help the stubborn people
20:17:56 <pumpkin> but I think in the long run, given how hard (impossible) it is to reason about programs, the more we can tell the computer (in the form of "this is pure") the better it'll make our programs
20:18:18 <blackh> pumpkin: The point about a JIT is that it doesn't have to reason about the program - it can measure it as it runs.
20:18:22 <pumpkin> yeah
20:18:35 <ddarius> It's trivial to automatically parallelize purely functional code.
20:18:48 <pumpkin> yeah, but a JIT can tell when it's worthwhile to do so too
20:19:09 <pumpkin> since branching it into a new thread isn't always a good idea unless it's doing a lot of stuff
20:19:36 <shapr> I miss sethk :-(
20:19:38 <pumpkin> it would be nice to have something that builds on -prof (by filling your code with cost centers) and automatically sticks `par` and such in :P
20:20:31 <necroforest> pumpkin, isn't that what par does? you tell it max # of threads and it figures out how to parallelize stuff to fill up those threads?
20:20:37 <blackh> The big question is, is FP actually necessary for parallelizing code, or will billions of dollars of research funds make imperative code parallelize just as well?
20:20:58 <blackh> I'd like to know the answer to that question, but I can only guess.
20:23:03 <pumpkin> necroforest: I don't think so? I mean, it helps and keeps a pool of threads, but only to a point
20:24:39 <pumpkin> wow, I didn't know ahmadinejad was a hax0r
20:25:59 <orbitz> shapr: know if any of the biohaskell guys hang here?
20:26:08 <shapr> @seen kzm
20:26:09 <lambdabot> I haven't seen kzm.
20:26:20 <pumpkin> what's biohaskell?
20:26:20 <shapr> @go ketil malde
20:26:22 <lambdabot> No Result Found.
20:26:24 <shapr> hmm
20:26:33 <orbitz> pumpkin: bioinformaitcs library
20:26:33 <pumpkin> haskell for computational biology?
20:26:38 <pumpkin> ah
20:26:49 <orbitz> pumpkin: bhlog is th eblog
20:26:53 <shapr> orbitz: http://malde.org/~ketil/
20:27:16 <shapr> Ketil is kzm on #haskell
20:27:21 <shapr> He shows up off and on.
20:27:48 <shapr> I don't remember who else does biohaskell.
20:27:50 <BMeph> blackh: Well, (Erik) Meijer is trying to get VB (and C#) at the head of the line for option B. He does like to talk as if he's subverting those langs to become more like option 'A', though. :)
20:28:08 <orbitz> shapr: someoen naemd sof
20:28:13 <shapr> Oh right
20:28:25 <shapr> I can't remember that person's real name off the top of my head.
20:29:06 <blackh> BMeph: interesting
20:29:12 <orbitz> shapr: that's cool, i'm goign to start reading teh code once classes are over and then start sendign patches in hopefully
20:29:12 <BMeph> shapr: Sigbjorn Finne, perhaps? ;)
20:29:21 <shapr> Oh right!
20:29:23 <shapr> Probably so!
20:29:38 <shapr> BMeph: Oh yeah, he's at Galois now.
20:29:49 <shapr> orbitz: Great! Go for it!
20:30:13 <orbitz> go for the gold!!!!
20:30:31 <sam_ul> > '\0A'
20:30:32 <lambdabot>   <no location info>:
20:30:32 <lambdabot>      lexical error in string/character literal at chara...
20:30:36 <shapr> orbitz: Do you have any classes where you can use biohaskell to do homework/solve problems, etc?
20:30:50 <sam_ul> > '\x0A'
20:30:51 <lambdabot>   '\n'
20:31:00 <shapr> orbitz: Best way to get familiar with something is to use it to accomplish a task that is required of you.
20:31:06 <shapr> Or at least, that's one good way :-)
20:32:03 <orbitz> shapr: not yet, hopefully soon
20:32:13 <orbitz> shapr: haha yes i ten dot learn th ebest htat way myself
20:32:16 <shapr> Go for the lambda!
20:32:20 <orbitz> so far my only computer class has been in perl
20:32:27 <orbitz> and that wasn't specific ot bioinf
20:32:34 <shapr> orbitz: My only computer class was in ROM BASIC.
20:32:43 <orbitz> however i did a number of the assignment sin haskell for myself
20:33:07 <orbitz> shapr: are you an old foagy?
20:33:16 <shapr> Yeah, sorta
20:33:31 <shapr> orbitz: But I bet I can ride a unicycle better than you can ;-)
20:33:46 <orbitz> shapr: how good is yoru juggling?
20:33:53 <shapr> contact juggling?
20:34:02 <orbitz> no, actual throwing
20:34:13 <shapr> Bah, boring ;-)
20:34:22 <shapr> Ok, I admit I never got interested in actual throwing.
20:34:31 <orbitz> shapr: if you ride the unicycle an di sit on your shoudlers and juggle while you contact juggle we coudl ahve qutie teh show
20:34:45 <shapr> That's true.
20:36:30 <BMeph> orbitz: And if you were blonde, shapely and female, we could wager on how much time before shapr fainted... >;)
20:36:48 <shapr> BMeph: You're totally missing out on #haskell-blah
20:36:52 <orbitz> BMeph: ill get in touch with a doctor
20:37:09 <BMeph> shapr: I AM #haskell-blah. ;p
20:37:26 <orbitz> they shoudl change it ot #haskell-bmeph
20:37:40 <shapr> heh
20:38:43 <orbitz> i think Saeglopur has become my favorite Sigur Ros song
20:41:05 <pumpkin> I wish I could spell the names to their songs
20:41:12 <pumpkin> so I could say which I like
20:41:16 <orbitz> i wis i coudl pronounce them
20:41:43 <pumpkin> I like the obvious one with the gay football kids
20:41:56 <shapr> ?
20:42:03 <orbitz> Saeglopur remind sme of Future Sound Of London by Ulver
20:42:12 <shapr> pumpkin: Dude, that totally belongs on -blah
20:42:22 <shapr> Has anyone built ghc for ARM recently?
20:42:29 <pumpkin> shapr: true, sorry :)
20:45:46 <shapr> y0 andyjgill
20:45:56 <andyjgill> hi shapr
20:48:26 <cpfr> for cabal are the filenames suppose to match the module names?
20:51:38 <jsn> cpfr: i think they pretty much always do
20:51:39 <Axman6> can you include extra files in a cabal package? i want to give some example 'assembly' files for the HARM arm emulator i have on hackage
20:52:07 <jsn> Axman6: yes, with 'extra-source-files'
20:52:14 <Axman6> cheers
20:52:45 <Axman6> jsn: where does that go in the file?
20:52:49 <cpfr> jsn, thanks
20:52:57 <blackh> shapr: I had a go at building ghc on arm recently.
20:52:59 <jsn> Axman6: http://github.com/jsnx/system-uuid/tree/master/system-uuid.cabal
20:53:19 <jsn> it's where i put the README and other such things
20:53:24 <shapr> blackh: What sort of results did you get?
20:53:25 <Axman6> god my internet's being slow today
20:54:42 <solrize> anyone remember the paper by that guy who had written a compiler (either an ML compiler or some compiler written in ML), with a mutable structure for expression trees that kept breaking as the program changed, and he eventually replaced it with a zipper and all the hassle went away?
20:54:50 <blackh> shapr: Here's what I did:
20:55:09 <blackh> shapr: I tried ghc on Debian arm, and it worked, but threading was NOT working.
20:55:18 <blackh> shapr: So I thought - hey - I can just turn it on and it'll work.
20:55:43 <blackh> Shapr: This was the 6.8.2 or 6.8.3 or something
20:56:10 <blackh> shapr: Then I discovered that there is something missing somewhere in the thread department for arm.
20:56:31 <blackh> shapr: So I gave up in the end and just used the pre-built debian-arm package and took threads out of my program.
20:56:47 <JohnnyL> haskell I am guessing is the alterative to wolfram's programming environment?
20:56:52 <solrize> ah, found it
20:57:24 <blackh> shapr: Have a look at the debian sources and that'll give you a configure command that makes it work.
20:58:02 <jsn> JohnnyL: there are a lot of alternatives to mathematica
20:59:29 <jfredett> JohnnyL: Axiom and Magma are more like Mathematica, Haskell is more of a general purpose programming language than a Computer-algebra system
21:01:03 <blackh> shapr: My second ever Haskell program is running on an arm box right now: http://blacksapphire.com/antispam/  One at a time, please, it only has 32 MB of RAM.
21:01:12 <shapr> heh
21:01:43 <shapr> blackh: Haskell threads didn't work on ARM? oh, -threaded stuff?
21:02:44 <blackh> shapr: I believe that nothing that uses threads works, unless it's been fixed since I tried it.  Specifically, forkIO doesn't work.
21:04:29 <BMeph> , @ty let loeb xs = fmap (\fs -> fmap fs xs) in loeb
21:04:33 <lunabot>  luna: parse error on input `@'
21:04:40 <shapr> blackh: That's good to know.
21:04:43 <BMeph> :ty let loeb xs = fmap (\fs -> fmap fs xs) in loeb
21:05:46 <cknapp> Evening, all.
21:05:58 <blackh> Evening.
21:07:06 <Axman6> hve i got something wrong here in my ~/.cabal/config?
21:07:08 <Axman6> hackage-username: "AlexMason"
21:07:11 <BMeph> Hola, cknapp! :)
21:07:13 <Axman6> hackage-password: "mypasswordhere"
21:07:18 <cknapp> Anybody know a good place to learn about functors?
21:07:20 <Axman6> a*
21:07:29 <Axman6> it doesn't seem to work :\
21:07:48 <BMeph> cknapp: I'd recommend edwardk or ddarius. ;)
21:07:52 <Axman6> or maybe my internet is just being stupid...
21:08:42 <cknapp> ddarius, you have have been volunteered, it seems. ;)
21:08:49 <shapr> cknapp: Wikipedia has some good stuff on functors.
21:09:03 <cknapp> shapr: Thanks, I'll check it out.
21:10:37 <JohnnyL> jfredett oh ok, thanks.
21:11:02 <jfredett> JohnnyL: no worries.
21:11:50 <BMeph> Axman6: Sari I cnat werk todai, muh intarwebs has teh dumb. ;p
21:12:35 <Axman6> seems to ahve worked, our net's just crap. HARM-0.1.4 is on hackahe now :)
21:12:53 <Axman6> have*
21:36:40 <pumpkin> my sliding entropy thing almost works, I think
21:36:50 <pumpkin> but it's also epicly broken
21:36:53 <dolio> > let loeb fs = fmap (\f -> f $ loeb fs) fs in loeb [const 5 , (!!0) , \l -> 1 + l !! 1 , \l -> 2 * l !! 2]
21:36:54 <lambdabot>   [5,5,6,12]
21:37:34 <pumpkin> it's also pretty ugly
21:37:39 <Axman6> aye
21:37:56 <Axman6> i'm not sure what it's supposed to be doing
21:38:16 <pumpkin> my sliding entropy function?
21:38:30 * BMeph smacks his forehead
21:38:51 <BMeph> dolio: Thank you, I was wondering where the pieces went. :)
21:38:55 <dolio> @type let loeb fs = fmap (\f -> f $ loeb fs) fs in loeb
21:38:56 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
21:39:17 <Axman6> >_<
21:39:50 <Axman6> hackage: *poke*
21:41:31 <dolio> hackage announces on the hour, I think.
21:41:55 <pumpkin> maybe Debug.Trace will come to my rescue
21:42:51 <Axman6> ah, i see
21:43:01 <Axman6> well, HARM-0.1.4 has been released
21:43:10 <pumpkin> ooh
21:43:15 <pumpkin> is that the ARM thing you mentioned?
21:43:25 <dolio> That's why you sometimes get like 5 packages announced all at once.
21:43:42 <Axman6> yeah
21:43:53 <dolio> Or "foo x.y" followed by "foo x.z" with z < y. :)
21:44:02 <Axman6> it;s not very complete. when i get more time, i'll add stuff to it
21:44:10 <pumpkin> Axman6: the link on hackagedb is broken, you're missing //
21:44:20 <pumpkin> http://tinyurl.com/639v6u
21:44:30 <pumpkin> (in the description)
21:44:57 <pumpkin> does it support thumb?
21:46:16 <Axman6> pumpkin: hmm?
21:46:36 <Axman6> oh, do i need to escape URL's?
21:46:39 <pumpkin> the 16-bit ARM instruction set
21:47:02 <pumpkin> oh, not sure about that, just at http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HARM the tinyurl link in the description looks odd
21:47:41 <Axman6> pumpkin: it's not 16-bit, just the offsets are. they're supposed to be 24 bit, but that's hard ;)
21:47:57 <pumpkin> I mean the instructions themselves
21:48:08 <pumpkin> the format uses 2 bytes per instruction for everything but branches
21:48:19 <pumpkin> doesn't it?
21:59:13 <jfredett> So, I want to do some conditional parsing, but I'm confused about how- basically, I need to check if a CRLF is followed by whitespace, and change actions based on that -- is there a pre-existing combinator for this?
21:59:57 <pumpkin> you doing a whitespace-sensitive language?
22:00:03 <jfredett> Email
22:00:13 <jfredett> so-called "long fields"
22:00:49 <jfredett> basically it looks like "FIELD: blah blah <CRLF><TAB|SPACE> blah blah"
22:01:04 <jfredett> but it's terminated with a CRLF with nothing after it
22:01:18 <jfredett> stupidest thing I've seen all week, but I still have to parse it.
22:02:54 <Axman6> sounds like a cabal file
22:03:26 <jfredett> yah- similar, i guess.
22:04:15 <jfredett> I mean, it's like pumpkin said, whitespace sensitive, which means there is probably something that does this already
22:05:12 <pumpkin> I was thinking more along the lines of something like python or haskell, where you often preprocess to make the whitespace easier to parse
22:05:32 <jfredett> ooh- holdup, I was looking at the wrong haddock docs
22:05:48 <jfredett> *stares* this looks _much_ more useful.
22:06:02 <pumpkin> :)
22:07:42 <pumpkin> centrinia: I have a first pass at the sliding entropy but it's broken :P
22:08:06 <centrinia> Okay, since it is not Friday night anymore, maybe I can actually implement it. :p
22:08:10 <pumpkin> lol
22:08:17 <pumpkin> you in EST?
22:08:25 <centrinia> Yes.
22:11:01 <pumpkin> centrinia: shall I paste my fugly broken one or do you want to do yours from scratch?
22:11:19 <centrinia> I'll look at your's first.
22:11:29 <pumpkin> I warn you, you may go blind...
22:11:48 <pumpkin> http://hpaste.org/12768
22:12:00 * pumpkin hides
22:18:20 <centrinia> I don't really understand. :p
22:20:43 <pumpkin> lol
22:20:49 <pumpkin> well, granted, it's wrong
22:20:56 <pumpkin> but I think the idea is correct, at least
22:21:00 <pumpkin> (I hope)
22:22:12 <pumpkin> centrinia: so I use a Data.Sequence to keep a sequence of the window size
22:22:30 <pumpkin> and use it like a queue to determine what symbol I'm losing out the back of the window
22:22:44 <pumpkin> I use an IntMap to keep track of the distribution of symbols across the current window
22:22:55 <pumpkin> I initialize both on the first window to avoid special cases
22:23:31 <pumpkin> then I have a function that treats an IntMap Int as a distribution and gives the entropy for it
22:25:23 <markovChain> so, i am a newb.. i just wrote the game of life in haskell, to make myself learn.  then i wrote it in c, to compare experience.
22:26:05 <pumpkin> markovChain: have you ever been to monte carlo? :P
22:26:11 <jfredett> markovChain: cool.
22:26:19 <markovChain> ghc/haskell is a way better to code.. i mean, ghc was way more helpful than gcc.
22:26:38 <pumpkin> yay
22:26:43 <markovChain> but, the haskell is way slower, it seems.  is that the way it is?
22:27:04 <pumpkin> you can write fast code in haskell and slow code in haskell, just like any other language :)
22:27:06 <markovChain> i could be not using haskell features that would make it faster.
22:27:29 <markovChain> pumpkin, cool.  where would i find examples of each?
22:27:38 <jfredett> markovChain: are you running in an interpreter (ghci?)
22:27:43 <jfredett> that generally slows things down
22:27:54 <markovChain> no, ghc --make gol.hs
22:28:03 <pumpkin> markovChain: http://www.haskell.org/haskellwiki/Performance
22:28:05 <geezusfreeek> markovChain: try with -O2
22:28:11 <markovChain> ooo, cool
22:28:13 <jfredett> on the average, haskell does tend to be slower than C, but there are alot of posts on threading haskell and such
22:28:16 <jfredett> dons does alot of them
22:28:28 <pumpkin> there are some cases in which people have gotten it down to c speed
22:28:29 <jfredett> doesn't -O2 do nothing? I forget...
22:28:35 <pumpkin> it does do stuff
22:28:44 <geezusfreeek> jfredett: -O2 is drastically better
22:28:48 <jfredett> pumpkin: dons does all the crazy fast stuff.
22:28:56 <markovChain> dons?
22:29:01 <pumpkin> don stewart
22:29:04 <jfredett> geezusfreeek: really? maybe it was -O3 i was thinking about
22:29:20 <pumpkin> markovChain: he hangs out in here, but isn't around right now
22:29:30 <geezusfreeek> jfredett: -O3 does very little above -O2 and can even negatively affect performance, just like in gcc
22:29:38 <jfredett> geezusfreeek: it's been a while since I've bothered to compile anything- I just use the interpreter... :/
22:29:42 <jfredett> ahh
22:29:43 <pumpkin> -O7
22:29:48 <jfredett> -O11
22:29:54 <jfredett> thats what GHC needs.
22:29:59 <jfredett> it needs to go to 11.
22:30:11 <pumpkin> -O42 is the answer
22:30:15 <blackh> markovChain: What data type are you using for your game state?
22:30:18 <geezusfreeek> -O1337
22:30:23 <jfredett> pumpkin: it's 47 now, inflation...
22:30:30 <pumpkin> oh dammit :)
22:30:52 <pumpkin> centrinia: does it make any more sense now? or does the ugliness just impede any kind of understanding?
22:30:56 <pumpkin> :P
22:31:32 <markovChain> blackh, type Game = [Bool]
22:31:42 <pumpkin> markovChain: that could be a problem :P
22:31:48 <pumpkin> in fact, most definitely is :)
22:31:51 <blackh> markovChain: How do you address the rows above and below?
22:32:07 <geezusfreeek> that is definitely not the way to go
22:32:22 <geezusfreeek> indexed list access is O(n)
22:32:30 <blackh> It could be the way to go - the point is that every cell has to be updated - I know this particular problem.
22:32:37 <jfredett> markovChain: yahyah, even doing a [[Bool]] would be faster
22:32:40 <markovChain> blackh, i build an [[Int]] of neighbors first
22:32:46 <jfredett> or you could try a sparse array method.
22:33:02 <jfredett> save on memory, certainly.
22:33:31 <geezusfreeek> [:[:Bool:]:] is certainly the way to go ;)
22:33:40 <markovChain> woah, what is that?
22:33:49 <geezusfreeek> a parallel array
22:33:53 <geezusfreeek> well, nested
22:33:59 <jfredett> NDP FTW? :)
22:34:11 <blackh> markovChain: If you are iterating over your list, then that's fast.  So [[Bool]] would work if you iterated over three rows at a time.  Do you see what I mean?
22:34:35 <blackh> The problem comes when you look something up in a list using an index.
22:35:03 <markovChain> blackh, haskell list access is not O(1)?
22:35:08 <pumpkin> nope
22:35:10 <pumpkin> except for head
22:35:13 <blackh> No - it's O(N)
22:35:21 <pumpkin> markovChain: it's just a singly-linked list
22:35:27 <markovChain> woah, i guess i should have known that.
22:35:31 <blackh> But Data.Array fixes that - however, Data.Array can be slow to update - depending on how you do it.
22:36:05 <gustavod> can you profile the thing to find out where time is being spent?
22:37:11 <markovChain> okay, i think that the way for me to proceed is to try and find a way to not iterate over a list with an index, but instead recurse.
22:37:32 <twb> After destroying .cabal by trying to uninstall packages (I only have 4GB of disk), I'm trying to reinstall cabal-install.
22:37:57 <blackh> markovChain: I think that's the best way.
22:38:21 <twb> I get Distribution/Client/Tar.hs:69:17: Could not find module `Codec.Compression.GZip':
22:38:22 <twb> ...even though I have apt-get installed libghc6-zlib-dev 0.4.0.4-1!  What gives?
22:38:36 <geezusfreeek> it is certainly the most functional way
22:39:10 <markovChain> blackh, it's the haskell/pure-functional way.. which is what i am after.  i am trying to think differently more than i am trying to learn a new language.  haskell seems to be the coolest functional around.
22:39:18 <sm> evening all
22:39:27 <geezusfreeek> you got that right ;)
22:40:05 <markovChain> i am a c guy, so i'm still looking around for my for loops.  i feel naked without them.
22:40:39 <geezusfreeek> lists are haskell's for loops ;)
22:41:08 <geezusfreeek> the thing is, why use just lists when you can write even more appropriate structures for your problem? :)
22:41:17 <jfredett> markovChain: map + lists = for loops
22:41:19 <blackh> markovChain: You might find that a foldl or foldr is better than recursion.  I started Haskell about 3 months ago so I know how you feel. :)
22:41:31 <markovChain> so far, list comprehension are my favorite.  i am getting used to them.
22:41:33 <jfredett> err, foldr
22:41:39 <ozy`> markovChain: for-loops can serve so many purposes... Haskell has functions for each of them
22:41:44 <blackh> markovChain: accum might be better still
22:41:46 <jfredett> and map
22:41:49 <jfredett> and scan
22:41:54 <geezusfreeek> unfoldr = while loops :)
22:42:00 <pumpkin> BAH
22:42:09 <jfredett> geezusfreeek: I have never had use for unfolder
22:42:12 <jfredett> unfoldr*
22:42:12 <pumpkin> ghci needs to be less lazy with its ctrl+c signal handler
22:42:29 <dibblego> unfoldr is under-appreciated
22:42:35 <pumpkin> I wrote one tiny thing that ate lots of memory by mistake, evaluated it, and hit ctrl+c almost immediately
22:42:42 <geezusfreeek> jfredett: unfoldr is quite useful to me. it is sometimes hard to spot a good place for it though
22:42:43 <pumpkin> but it proceeded to eat up all my system memory anyway
22:42:46 <blackh> I meant scanl / scanr. :)
22:42:47 <ozy`> GHC could use slightly clearer wording in some of its error messages
22:43:19 <blackh> markovChain: Maybe try feeding three rows at a time into a scanl or scanr.
22:43:44 <geezusfreeek> a nice toy example of using unfoldr http://billmill.org/roman.html
22:43:46 <markovChain> so, map, fold*, accum, scan*, unfold* .. these are what i should read-up on.
22:43:54 <jfredett> markovChain: yep
22:44:05 <jfredett> you might want to check out Real World Haskell
22:44:06 <markovChain> cool, thanks guys.
22:44:07 <ozy`> > map (\x -> [x]) "fresh deleted pizza"
22:44:08 <lambdabot>   ["f","r","e","s","h"," ","d","e","l","e","t","e","d"," ","p","i","z","z","a"]
22:44:12 <blackh> markovChain: Recursion might be easier, because you need three columns and three rows. :)
22:44:23 <jfredett> a google search will bring it up
22:44:34 <jfredett> it's free to read online
22:44:35 <geezusfreeek> @where rwh
22:44:35 <lambdabot> is http://www.realworldhaskell.org/blog/
22:44:44 <jfredett> a good introduction allround
22:46:27 <blackh> markovChain: Another idea: Split the problem into two: 1. Make a special 'map' that splits the world into 3x3 blocks, 2. write the rule for the transformation.
22:47:23 <geezusfreeek> ^ seems similar to a zipper
22:47:33 <ozy`> reverse "a man a plan a canal panama"
22:47:37 <ozy`> d'oh
22:47:39 <ozy`> > reverse "a man a plan a canal panama"
22:47:41 <lambdabot>   "amanap lanac a nalp a nam a"
22:48:41 <ozy`> > foldl1 (,) "pizza"
22:48:42 <lambdabot>       Occurs check: cannot construct the infinite type: a = (a, a)
22:48:42 <lambdabot>        Exp...
22:48:51 <pumpkin> > reverse "aManAPlanACAnalPAnaMa
22:48:51 <ozy`> well fine
22:48:52 <lambdabot>   <no location info>:
22:48:52 <lambdabot>      lexical error in string/character literal at chara...
22:48:52 <pumpkin> > reverse "aManAPlanACAnalPAnaMa"
22:48:54 <lambdabot>   "aManAPlanACAnalPAnaMa"
22:52:24 <pumpkin> okay, I'm clearly doing something very wrong here
22:52:25 <pumpkin> hmm
22:53:23 <jfredett> ... I can't figure out this parser... anyone feel like taking a look?
22:53:32 <jfredett> http://hpaste.org/12769
22:53:57 <ski_> > (reverse . map toLower) "Eva, can I stab bats in a cave ?"
22:53:58 <lambdabot>   "? evac a ni stab bats i nac ,ave"
22:54:07 <pumpkin> lol
22:55:49 * ski_ tries to resist emitting more of them
22:55:52 <pumpkin> centrinia: lol, one of my main problems was that (-) needed to be (flip (-))
22:55:58 <pumpkin> or simply (+) -1
22:56:13 <centrinia> We talked about that with (- 1) being a constant. :p
22:56:37 <pumpkin> that was at a different time :P my issue is that it was subtracting the wrong thing from the wrong thing
22:56:39 <twb> Oh, awesome.  It happens with ./bootstrap.sh, too.
22:56:46 <pumpkin> twb: huh?
22:57:07 <pumpkin> centrinia: but yeah, it's looking more reasonable (still wrong, but fewer NaNs now :D)
22:59:21 <twb> pumpkin: cabal-install is completely broken for me :-(
22:59:36 <pumpkin> twb: what does it say? I was having some trouble a few days ago with it
22:59:38 <twb> It's almost like Cabal is caching somewhere a list of what's installed in ~/.cabal
22:59:50 <pumpkin> twb: oh it is, try ghc-pkg list
23:00:04 <twb> pumpkin: but I rm -rf'd ~/.cabal!
23:00:11 <pumpkin> yeah, but .ghc :P
23:00:14 <jfredett> oh well, I'll tackle parsec tomorrow, time for sleep.
23:00:17 <pumpkin> don't rm that though
23:00:18 <jfredett> goodnight folks.
23:00:18 <twb> Argh!
23:00:26 <conal> i have a question for anyone here interested in FRP in general, and in Reactive in particular.  what makes Reactive or Fran interesting to you, given that there was Yampa in between?
23:00:37 <pumpkin> twb: ghc-pkg unregister each package that shows up under your user dir
23:00:44 <twb> Grr.
23:01:59 <jfredett> conal: I'd love to be interested in FRP, but haven't found a comprehensive "show me what the lard I'm doing because I have no idea" tutorial yet. :)
23:02:23 <conal> jfredett: thx.  those tutorials will come. :)
23:02:27 <jfredett> :)
23:02:37 <pumpkin> oh actually, I think I know what's wrong
23:02:37 <jfredett> it looks pretty neat though.
23:02:58 <pumpkin> I'm trying to use pattern matching in a where statement and I think it's doing the opposite of what I want it to
23:03:08 <pumpkin> maybe not though
23:03:17 <conal> jfredett: meanwhile, you might check out http://conal.net/fran/tutorial.htm .  the details are out of date, but it'll give you a sense.
23:03:23 <jfredett> okay
23:03:36 <jfredett> I'll take it onto my readinglist, thanks.
23:04:11 <pumpkin> conal: you need antialiasing and subpixel measurements!
23:04:21 <pumpkin> otherwise it looks awesome (given that old demo page you just linked to)
23:04:22 <conal> pumpkin: where?
23:04:29 <conal> pumpkin: oh -- the tutorial.
23:04:41 <pumpkin> pat and charlotte look rather aliased :P
23:05:09 <pumpkin> also, you're bouncing around two kids' heads! sounds murderous and terrible to me
23:05:14 <conal> pumpkin: the original animations were *way* nicer.  very smooth in time & space.  i had to reduce the quality tremendously for the animated gifs.
23:05:20 <pumpkin> ah :)
23:05:26 <conal> yeah, too bad.
23:05:47 <pumpkin> lol
23:05:48 <pumpkin> moveXY wiggle waggle pat
23:05:52 <telexicon> happs is so poorly documented
23:05:52 <pumpkin> I love the naming :)
23:06:00 <conal> :)
23:06:39 <telexicon> it has pretty much no docs, plus it barely compiles (it took 4 tries from different sources), and the examples dont compile
23:06:47 <conal> btw, pat is sitting four feet away from me and is now 19.
23:07:07 <pumpkin> ah cool :) is he your son? :o
23:07:23 <conal> yeah.
23:07:37 <conal> my four kids were well-known to functional programming researchers.
23:08:02 <pumpkin> do they know they're famous? :D
23:08:42 <conal> yeah.  they've seen my papers and some video'd talks and heard about the research meetings.
23:09:04 <Saizan> telexicon: did you have problems with the packages on hackage?
23:09:21 <telexicon> Saizan, those were the only ones i was able to compile
23:09:22 <doublec> telexicon, I used the hackage packages without issues
23:09:22 <pumpkin> they'd better go into CS and learn haskell!
23:10:35 <doublec> telexicon, gitit makes a good example too
23:12:13 <doublec> I find quite a few haskell packages lack documentation apart from api docs
23:12:44 <Saizan> there's also "happstutorial"
23:12:53 <doublec> although you could s/haskell/anylanguage/ probably
23:12:57 <Saizan> but yeah, it seriously need documentation
23:12:58 <twb> doublec: it's an endemic problem with programmers :-(
23:13:21 <telexicon> doublec, not really
23:13:42 <telexicon> i mean, a lot of things have poor docs, but not as many have 0 docs
23:14:36 <centrinia> conal: Do your kids do research in functional programming? :)
23:15:17 <conal> centrinia: no.  they all do their own thing.
23:15:34 <centrinia> That thing should be functional programming. :)
23:17:14 <Saizan> telexicon: there's also an happs google groups if you're interested
23:17:30 <doublec> and a #happs channel
23:26:24 <doublec> telexicon, this is fairly up to date with happs: http://softwaresimply.blogspot.com/2008/02/intro-to-happs-part-1.html
23:26:35 <telexicon> doublec, oh nice, thanks
23:27:51 <doublec> a combination of that and this is what I've been learning from: http://www.haskell.org/haskellwiki/HAppS_tutorial2
23:27:56 <doublec> as well as reading gitit, etc
23:32:46 <centrinia> Does an extensive imperative programming background cause so much brain damage that it becomes impossible to write decent functional programs?
23:33:14 <conal> centrinia: it seems to take a lot of mental reconditioning.
23:33:18 <blackh> centrinia: I have an extensive imperative programming background, and my functional programs suck.
23:34:05 <centrinia> Dysfunctional is apt. :)
23:34:07 <blackh> centrinia: Actually I lie: I am in Haskell heaven and I'd never use any of those dreadful imperative languages again.
23:34:10 <conal> maybe it helps to think of imperative and functional programming as being two different kinds of activities, not just two variations on the same activity (programming).
23:34:52 <centrinia> conal: Isn't that a little extreme?
23:34:55 <conal> e.g., one might think of imperative programming as about controlling machines and functional programming as about describing things.
23:34:58 <dibblego> centrinia, yes degenerate programming can cause a hindrance
23:35:09 <Debolaz> What is a good book on type theory that doesn't require an extensive mathematical background?
23:35:14 <conal> doing vs being.
23:35:44 <geezusfreeek> Debolaz: TAPL is nice. it explains the math from a very ground-up perspective
23:35:44 <conal> centrinia: yes.  maybe extreme enough to displace the old mental habits
23:35:58 <pumpkin_> what's TAPL?
23:36:06 <geezusfreeek> Types and Programming Languages
23:36:09 <blackh> My experience is that my code is much much nicer, cleaner and tidier than it is in other languages.  Either I've suddenly become a genius, or I put it down to the language.
23:36:21 <pumpkin_> :t boobs
23:36:22 <lambdabot> Not in scope: `boobs'
23:36:36 <centrinia> :pl (.y.)
23:36:36 <Debolaz> geezusfreeek: Thank you.
23:36:40 <geezusfreeek> :t (.) (.)
23:36:41 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
23:36:47 <pumpkin_> :)
23:36:49 <blackh> Somebody undefined boobs, so you have to go and definte it again, oh dear!
23:37:07 <centrinia> pumpkin_: Look at my annotation of your code.
23:37:08 <pumpkin_> :(
23:37:25 <centrinia> Boobs can be modeled by arrows.
23:37:42 <pumpkin_> centrinia: oh my, it looks scarier now
23:37:48 <conal> i'm off to bed.  catch you all later.
23:38:07 <centrinia> conal: Define boobs for us, okay? :)
23:38:11 <blackh> Good night! I would go a step further:  I have been doing programming every day for years in imperative languages.
23:38:36 <blackh> ....and I have been getting better at it, and this process has made it look more and more like functional programming.
23:39:49 <geezusfreeek> i have actually become less productive in imperative languages that i was before because i keep feeling like i'm doing things inelegantly
23:39:54 <geezusfreeek> *than i was
23:39:54 <centrinia> blackh: Maybe you finally implemented that embedded Scheme interpreter in one of your imperative programs. :)
23:39:58 <blackh> For example: Passing everything through functional arguments.
23:40:17 <blackh> s/functional/function/
23:40:53 <blackh> geezusfreeek: Same here.
23:42:33 <pumpkin_> centrinia: how well does it perform?
23:44:36 <centrinia> pumpkin_: I never timed it. :)
23:44:40 <pumpkin_> :o
23:44:48 <centrinia> It should be much slower for small windows. :)
23:48:31 <pumpkin_> still trying to make sense of it :P
23:52:40 <centrinia> The accumulate_entropy function computes the entropy of a window and updates the Map.
23:52:57 <centrinia> The compute_one_entropy computes the entropy contributed by one symbol.
23:53:15 <centrinia> The compute_entropy computes the entropy of a list.
23:53:35 <centrinia> The sliding_window does the actual sliding window entropy computation.
23:53:50 <pumpkin_> what's the b and n parameters?
23:53:51 <centrinia> The little ref function defined after main is the reference.
23:53:58 <centrinia> B is the logarithm base.
23:54:02 <pumpkin_> ah
23:54:10 <centrinia> And n is the window length.
23:55:41 <centrinia> Oh, the computation of acc' involves taking acc, subtracting the entropy contribution of the pushed and popped symbols w.r.t. the previous map, and adds the entropy contribution of the pushed and popped symbols w.r.t. the new map.
23:55:57 <pumpkin_> I see
23:56:05 <pumpkin_> by push and pop you mean enqueue and dequeue?
23:56:09 <centrinia> Yeah.
23:56:16 <pumpkin_> pretty neat :)
23:56:29 <pumpkin_> rearranging it a bit so it makes more sense to me
23:56:57 <centrinia> It should be a few orders of magnitude slower than the reference if you use small windows. :D
23:57:12 <pumpkin_> even on large input lists?
23:57:26 <centrinia> It should.
23:57:57 <centrinia> The reason why the reference is inferior is because it is O(n * length as)
23:58:11 <pumpkin_> yeah
23:58:21 <centrinia> This sliding window maintains a big map instead.
23:58:26 <pumpkin_> yup
23:58:50 <centrinia> It should be about O((log (length as)) * length as)
23:59:19 <pumpkin_> hmm
23:59:29 <centrinia> Oh, no. It should be O(log (length (nub (sort as))) * length as)
23:59:32 <pumpkin_> shouldn't that be log (nub as)
23:59:39 <pumpkin_> yeah
