00:00:35 <wli> ghc6.6 it looks like.
00:00:42 <jsn> wli: for windows?
00:00:44 <ddarius> It's \f g a -> g a >>= f
00:00:56 <ddarius> @src (>=>)
00:00:57 <lambdabot> Source not found. Maybe if you used more than just two fingers...
00:00:57 <wli> jsn: Yeah. :(
00:01:07 <ddarius> :t (<=<)
00:01:08 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
00:01:18 <wli> jsn: It may very well be too antique to work with a lot of the more modern stuff (e.g. newer cabal).
00:01:47 <dolio> :t \g f -> join . fmap g . f
00:01:48 <lambdabot> forall a a1 (f :: * -> *) a2. (Functor f, Monad f) => (a1 -> f a) -> (a2 -> f a1) -> a2 -> f a
00:02:08 <wli> jsn: And/or recent releases of numerous libs.
00:02:49 <quicksilver> ddarius: the conoing of sequencing as a term to discuss monads was presumably present before the primitive "sequence :: [m a] -> m [a]" got defined, but you're right that it's not in Moggi.
00:03:15 <quicksilver> ddarius: it's fundamental to several of his example monads, though.
00:04:04 <jsn> ddarius: so i guess '<=<'  is the Kliesli composition
00:04:11 <ddarius> quicksilver: I don't deny that sequencing is fundamental to several effects, but if by "several" you mean to imply "not all" then that proves my point that it is not fundamental to the idea itself (even as limited to notions of computation).
00:04:14 <ddarius> jsn: Yes.
00:04:34 <jsn> well, this has been educational
00:04:39 <jsn> i should get to bed
00:04:42 <jsn> thank you all
00:04:57 <quicksilver> ddarius: well, non-commutativity is the general case, and commutativity is a particular property of a restricted class of structures, right?
00:05:15 <quicksilver> that is true for any operation you might discuss.
00:06:26 <wli> Fortunately 6.6 is likely to be enough to keep me occupied.
00:09:03 <soa2ii> Hi there. If you parse a string for line breaks... how do you do that with haskell? scanner sym ('\n':str) = scanner sym str does not match :/
00:09:15 <wli> I can just avoid fooling around with the type system or external libs. Numerical code should do the trick handily.
00:09:42 <quicksilver> soa2ii: "does not match" ?
00:09:45 <ddarius> quicksilver: My point is that nothing about Monad is causing the sequencing (when sequencing occurs.)  Not particularly relevant here, but, in my opinion, the general 2-categorical definition of monad doesn't even seem to naturally even express sequentiality.  It seems that fmap from Cat is a crucial addition for that.
00:09:57 <quicksilver> gives an error? doesn't do what you think?
00:10:10 <soa2ii> quicksilver: Does not do what I think. No error.
00:10:19 <quicksilver> ddarius: the sequencing is the non-commutativity of composition in the kleisli category
00:10:27 <quicksilver> soa2ii: perhaps your file has \r in as well as \n ?
00:10:30 <wli> Data structures for sparse matrices could get a bit hairy but I'm not sure that would be in the type system.
00:10:41 <quicksilver> ddarius: (well that's one of the categorical ways to observe it)
00:10:48 <soa2ii> quicksilver: No Idea.
00:11:01 <soa2ii> Can I find out somehow?
00:11:04 <ddarius> quicksilver: The expression of it is, yes for Monads in Cat.
00:11:06 <quicksilver> soa2ii: try matching over \r as well?
00:11:09 <soa2ii> ok
00:12:12 <quicksilver> ddarius: why does it have to be over cat for composition in the kleisli category to be a sensible question?
00:12:28 <quicksilver> YOu have to have an initial object, I guess.
00:13:08 <soa2ii> quicksilver: Hm...seems not so. This is my code: http://hpaste.org/12960. I now look for \n \r and \t, don't I?
00:13:28 <ddarius> quicksilver: You can make a more general Kleisli construction, but I'm not sure what all it's properties are.  By monads in Cat, I mean the general 2-categorical notion specialized to Cat.  Not monads over Cat.
00:14:21 <quicksilver> ddarius: OK. Probably from my perspective the 2-cat generalisation is a bridge too far :)
00:14:23 <ddarius> The 2-categorical notion applied to a 2-category representing a poset is just a closure operator on the ordering.  How that relates to sequencing and what would be sequenced is completely unclear to me.
00:14:37 <quicksilver> soa2ii: your code is so much easier to read without all the elems ;)
00:14:46 <soa2ii> quicksilver: Yes (:
00:15:02 <ddarius> quicksilver: The 2-categorical definition is the natural level that monads live, but yes, this is less relevant.
00:15:10 <quicksilver> soa2ii: that looks to me like it should wokr, yes. What is the symptom of it not working?
00:15:27 <soa2ii> quicksilver: Look at the otherwise case
00:15:34 <soa2ii> I insert the otherwise!!!!!!!!
00:15:38 <soa2ii> This is my output
00:16:04 <soa2ii> [Game,Idf "Invaders",Lpar,Idf "width",Assign,Number 500,Comma,Idf "height",Assign,Number 500,Comma,Idf "x",Assign,Number 300,Comma,Idf "y",Assign,Number 200,Comma,Idf "speed",Assign,Number 80,Rpar,Int_,Idf "alien_increment",Assign,Number 6,Semi,Int_,Idf "alien_y_increment",Assign,Number 0,Semi,Int_,Idf ...
00:16:11 <soa2ii> And this myinput
00:16:28 <soa2ii> First 4 lines:
00:16:30 <soa2ii> // Set up system variables
00:16:31 <soa2ii> game Invaders(width = 500, height = 500, x = 300, y = 200, speed = 80)
00:16:33 <soa2ii> // Set up some global variables
00:16:34 <soa2ii> int alien_increment = 6;
00:16:55 <soa2ii> So the OTHERWISE!!!! must be the linebreak... not?
00:17:10 <quicksilver> it's got past the first line break
00:17:18 <quicksilver> that's after the Rpar after Number 80
00:17:19 <quicksilver> surely.
00:18:44 <soa2ii> quicksilver: Wait...
00:18:48 <soa2ii> somethings wrong here...
00:18:53 <quicksilver> soa2ii: your paste got chopped but anyway don't paste such large things in channel ;)
00:19:03 <quicksilver> annotate your paste with the input + output
00:19:10 <soa2ii> [Game,Idf "Invaders",Lpar,Idf "width",Assign,Number 500,Comma,Idf "height",Assign,Number 500,Comma,Idf "x",Assign,Number 300,Comma,Idf "y",Assign,Number 200,Comma,Idf "speed",Assign,Number 80,Rpar,Int_,Idf "alien_increment",Assign,Number 6,Semi,Int_,Idf "alien_y_increment",Assign,Numbe
00:19:13 <soa2ii> ?!?!?!
00:19:14 <lambdabot> Unknown command, try @list
00:19:21 <sstangl> hey gentlemen, there is debate in another channel: is there some reason other than cuteness for foldl being (a -> b -> a) ... while foldr is (a -> b -> b) ... ?
00:19:27 <soa2ii> My texteditor here has the OTHERWISE in it and if I paste it is missing?!
00:19:30 <quicksilver> IRC chops lines at a certain number of chars
00:19:36 <quicksilver> annotate the paste
00:19:42 <quicksilver> (click annotate at the top)
00:19:56 <wli> 255 for the protocol, but it includes protocol headers which AIUI vary in length.
00:20:10 <soa2ii> quicksilver: Yeah... umber 80,Rpar,Int_,Idf "alien_increme but here in betweeen is an otherwise...
00:20:23 * soa2ii is confused ... I'll paste correctly
00:21:05 <soa2ii> input_: http://hpaste.org/12961
00:21:29 <soa2ii> weird...
00:21:32 <soa2ii> no it works...
00:21:37 <quicksilver> good.
00:21:44 <soa2ii> My texteditor got a bug...
00:21:55 <quicksilver> soa2ii: no need for a new paste, the annotate button is there for a reason
00:21:59 <soa2ii> the reload won't work or haskells file output is somehow broken...
00:22:14 <soa2ii> quicksilver: Wich button?
00:22:26 <soa2ii> ah on the page
00:22:29 <soa2ii> silly me :P
00:23:14 <intrados> cabal is telling me that it can't find a package which is a dependency for another package any suggestions?
00:24:12 <intrados> even though the package is installed
00:31:18 <wli> Basically I have sets of disjoint regions of pairs of integers. For things like matrix multiplication I'll need to search for intersections.
00:31:40 <wli> There may be a one-dimensional answer here, come to think of it.
00:35:30 <august> :t replicate
00:35:31 <lambdabot> forall a. Int -> a -> [a]
00:35:52 <zeno> whats the reccomended method to get 6.10 on ubuntu?
00:36:13 <dolio> Download the generic linux tarball from the ghc website.
00:36:58 <august> > replicate -1 4
00:36:59 <lambdabot>       No instance for (Num (Int -> a -> [a]))
00:36:59 <lambdabot>        arising from a use of `-...
00:37:13 <august> > replicate 2 4
00:37:14 <lambdabot>   [4,4]
00:37:32 <august> -1 isn't an Int?
00:37:46 <ddarius> (replicate - 1) 4 is what you wrote
00:38:28 <august> oh
00:38:31 <zeno> dolio: ghc unsafe in sources.list?
00:38:41 <zeno> would work also?
00:38:54 <august> > replicate((-1) 4)
00:38:55 <lambdabot>       Overlapping instances for Show (a -> [a])
00:38:55 <lambdabot>        arising from a use of ...
00:38:58 <dolio> Would it? I didn't realize there was such a thing.
00:39:33 <august> overlapping?
00:39:37 <charvey> > replicate (-1) 4
00:39:39 <lambdabot>   []
00:39:47 <dolio> I'm used to installing it manually, because it's always lagged behind.
00:40:16 <zeno> dolio: http://haskell-unsafe.alioth.debian.org/haskell-unsafe.html
00:40:58 <centrinia> Is linear logic a little restrictive?
00:41:00 <dolio> Might as well try it. :)
00:41:02 <august> oh, () aren't just optional for functions
00:41:09 <ddarius> centrinia: It depends.
00:41:09 <august> they're not there at all
00:41:14 <zeno> what vim changes would u guys reccomend for haskell?
00:41:16 <charvey> august: `-' is a function too. You have to do (-1) so it acts like a number.
00:41:33 <centrinia> ddarius: How so?
00:41:37 <august> is (-1) short for (0 - 1)?
00:41:47 <charvey> august: yeah, () should only be used for tuples
00:42:13 <charvey> august: probably, I never really looked into that too closely ;P
00:42:49 <august> that's… annoying
00:42:58 <ddarius> No, -1 is syntax, that means negate 1.  It's just ambiguous (in many cases) with (-) so you need parentheses to disambiguate.
00:43:11 <ddarius> negate may or may not be defined as 0 - x
00:43:14 <ddarius> @src negate
00:43:14 <lambdabot> negate x = 0 - x
00:43:22 <ddarius> That's the default definition.
00:43:30 <centrinia> Wow, it is. :p
00:43:38 <august> > replicate negate 1 4
00:43:39 <lambdabot>   Couldn't match expected type `Int' against inferred type `a -> a'
00:43:50 <august> > replicate (negate 1) 4
00:43:51 <lambdabot>   []
00:44:32 <centrinia> august: There is nothing preventing you from defining some instance of Num that doesn't have negate x = 0 - x
00:44:50 <august> i was just curious
00:45:11 <august> still learning the language
00:45:12 <zeno> > replicate 4 (negate 1)
00:45:14 <ddarius> centrinia: If you include the exponential operators, you can simply embed intuitionistic logic into linear logic.
00:45:14 <centrinia> You can define a data type called Mod7 where arithmetic is done modulo 7 and negate x = (7 - x) `mod` 7 or something.
00:45:14 <lambdabot>   [-1,-1,-1,-1]
00:45:39 <ddarius> You can define negate however you like, though some definitions are more sensible than others.
00:45:44 <august> i was reading learn you a haskell and it implemented:
00:45:45 <august> replicate' :: (Num i, Ord i) => i -> a -> [a]
00:46:37 <august> more restrictive than the default implementation
00:47:14 <Peaker> @type replicate
00:47:15 <lambdabot> forall a. Int -> a -> [a]
00:47:23 <ksf> more general.
00:47:46 <Peaker> should probably use Integral
00:47:49 <ksf> is Int on amd64 64 bit?
00:48:05 <Peaker> yes
00:48:10 <Peaker> (ghc-wise, at least)
00:48:35 <wli> I guess it's basically things defined by inequalities on pairs of integers.
00:49:13 <august> floating point doesn't match Num and Ord?
00:49:22 <ksf> @src replicate
00:49:23 <lambdabot> replicate n x = take n (repeat x)
00:49:27 <ksf> :t take
00:49:29 <lambdabot> forall a. Int -> [a] -> [a]
00:49:32 <ksf> :t repeat
00:49:33 <lambdabot> forall a. a -> [a]
00:49:39 <ksf> @src take
00:49:39 <lambdabot> take n _      | n <= 0 =  []
00:49:39 <lambdabot> take _ []              =  []
00:49:39 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
00:49:59 <ksf> that should default to Integer...
00:50:03 <wli> Most commonly diagonals and square blocks with edges parallel to the coordinate axes.
00:50:09 <august> @src repeat
00:50:09 <lambdabot> repeat x = xs where xs = x : xs
00:50:57 <centrinia> Does linear logic correspond to linear types w.r.t. Curry-Howard?
00:50:59 <august> that took a bit to figure out what it was doing
00:51:04 <august> that's neat
00:51:19 <ksf> laziness ftw.
00:51:44 <august> referencing the variable being defined in the definition
00:51:54 <dolio> replicate should clearly be :: Conat -> [a].
00:52:20 <dolio> Or, Nat in Haskell, since it's the same.
00:52:40 <ksf> dolio, feel free to write CoHaskell.
00:52:42 <dolio> That way replicate infinity = repeat.
00:52:54 <august> nat : natural :: conat : ?
00:52:59 <august> conatural?
00:52:59 <dolio> And there are no negatives to worry about.
00:53:05 <quicksilver> There is only one copy of a CAF, right? If it is referenced from multiple places it is shared, and so are reductions on it?
00:53:06 <dolio> Coinductive naturals.
00:53:29 <ksf> coabstract nonsense.
00:53:33 <dolio> It's the naturals plus infinity, basically.
00:53:39 <august> ah
00:53:56 <august> http://ask.metafilter.com/42858/What-the-heck-is-coinduction
00:54:20 <ksf> basically, anything labelled co-something is the category something with its arrows reversed.
00:54:20 <centrinia> Why not the naturals union its elements with the Von Neumann construction of naturals?
00:54:42 <centrinia> Uh, the set containing the set of naturals and the naturals.
00:55:22 <quicksilver> centrinia: doesn't quite work with the von neumann construction.
00:55:31 <centrinia> Why not?
00:55:36 <Lemmih> @ask dcoutts Why does cabal-install depend on <= Cabal-1.6? It hurts the LHC support.
00:55:36 <lambdabot> Consider it noted.
00:55:44 <quicksilver> in a von neumann construction, if you include omega, then the fixed point also includes succ(omega)
00:55:50 <quicksilver> and so the chain continues ;)
00:55:57 <quicksilver> succ (omega) isn't a conatural.
00:56:09 <dolio> Well, it is. It's omega.
00:56:22 <quicksilver> not in the von neumann construction it isn't.
00:56:28 <dolio> Oh, well, okay.
00:56:29 <quicksilver> VN succ(omega) is omega + 1
00:56:30 <centrinia> No, succ(omega) is the conaturals.
00:56:35 <dolio> Oh, okay.
00:56:44 <quicksilver> slightly different definition of succ in the VN context.
00:56:58 <ksf> august, http://katmat.math.uni-bremen.de/acc/acc.pdf section 3.5
00:57:06 <centrinia> Yeah, succ(x) = {x} union x
00:57:12 <august> Coinductive definitions are the complement of that. Instead of taking the smallest set that satisfies the given constraints, we can take the largest set that is consistent with them, meaning that there is nothing in the set that couldn't possibly be produced by some number of applications (perhaps infinitely many) of the rules.
00:57:39 <quicksilver> august: agree with everything up until your last comma.
00:57:46 <quicksilver> after that I'm afraid that's rubbish.
00:57:55 <quicksilver> there's not such thing as infinitely many applications of a rule :)
00:57:56 <august> that's from the metafilter page
00:58:11 <quicksilver> stop press, somethign wrong on the internet ? ;)
00:58:43 <quicksilver> you don't "apply anything infinitely" to find the infinity in CoNat.
00:58:45 * ksf wonders how you suddenly get a definition of infinity by inverting succ...
00:58:55 <dolio> Yeah. I've come to realize that that's an important distinction for reasong about coinductive programs in languages like Agda.
00:58:57 <quicksilver> you just demonstrate that the infinity of CoNat is in the greatest fixed point.
00:59:01 <august> http://xkcd.com/386/
00:59:14 <quicksilver> dolio: which distinction?
00:59:16 <centrinia> quicksilver: What can one conclude from infinite applications of the rule logical implication p -> p given a proposition q?
00:59:26 <dolio> You don't "produce" coinductive values by building them out of constructors, and that has implications for how they're evaluated.
01:00:04 <quicksilver> dolio: right. at least, not starting from the bottom
01:00:17 <quicksilver> dolio: you're allowed to start anywhere, that's the thing about fixed points ;)
01:00:41 <quicksilver> dolio: but it's often much easier to think about de-structing (for coinductive things)
01:00:56 <centrinia> What if there are two or more fixed points?
01:00:58 <quicksilver> centrinia: it's meaningless. Constructions involving 'rules' are finite.
01:01:00 <dolio> Yes, that seems to be the key for reasoning about their evaluation.
01:01:07 <quicksilver> centrinia: that is the correct question to ask.
01:01:18 <dolio> Because then you can say that coinductive values don't get evaluated, only destructions of them do.
01:01:21 <pumpkin> is there some smart library/method for generating css and tying classes and IDs into (x)html generated with one of the various combinator libraries?
01:01:27 <dolio> And that (to me) clears up a lot of confusion.
01:01:29 <quicksilver> centrinia: the answer is, if A is a fixed point and B is a fixed point, it turns out that A u B is a fixed point (set union)
01:01:44 <quicksilver> centrinia: and because that's true, A u B is larger than A and B
01:01:52 <quicksilver> so neither A nor B was the greatest.
01:01:54 <centrinia> Ah.
01:02:03 <quicksilver> it's only because of this union property that 'greatest' is well defined.
01:02:15 <quicksilver> a priori you can imagine different fixed points with neither 'greater' than the other
01:02:26 <quicksilver> but because of the union property, there really is a greatest one.
01:02:29 <quicksilver> (the union of all of them)
01:03:23 <pumpkin> hmm
01:03:49 <pumpkin> so say I have a simple quadratic that goes through (2,2) and (4,4)
01:04:00 <fasta> Is there a library that implements "run the following list of actions with N threads"?
01:04:16 <pumpkin> quicksilver: how does the A u B work in that case?
01:04:21 <centrinia> Oh, so if we used the Von Neumann construction, there would not be a fixed point because we can indefinitely union an ordinal with its predecessors?
01:05:01 <quicksilver> centrinia: yes, the von neumann construction doesn't have a fixed point. Ordinals carry on forever.
01:05:09 <ksf> fasta, par, functors and something like replicate?
01:05:11 <centrinia> Or a set containing an ordinal with the set containing all of its predecessors. :p
01:05:16 <quicksilver> centrinia: one implication of this is that there is no 'set of all ordinals'
01:05:20 <quicksilver> centrinia: it's a proper class.
01:05:26 <quicksilver> a rather unpleasant foundational mess.
01:05:40 <quicksilver> (if there was a set of all ordinals, it would be an ordinal itself, and larger than all others)
01:05:43 <centrinia> Fixed points are never proper classes then.
01:05:47 <intrados> :q
01:05:49 <quicksilver> yes.
01:05:54 <ksf> fasta, if length list < say 1000k, you can use one thread for each without worries.
01:06:04 <quicksilver> when we say fixed point we generally assume it's a set.
01:06:12 <quicksilver> if it's not a set we say it "doesn't exist"
01:06:16 <quicksilver> probably. depending on context.
01:06:21 <fasta> ksf: every element in the list will call an OS process.
01:06:28 <fasta> ksf: same answer then still?
01:06:44 <quicksilver> fasta: that's fine, the FFI is asynchronous as long as you use the threaded RTS.
01:06:49 <ksf> not if you don't have an os written in haskell or erlang, no.
01:06:52 <pumpkin> you only get as many native threads as the -N you pass to your program
01:06:56 <quicksilver> you can just forkIO it all.
01:06:56 <fasta> quicksilver: no FFI involved here.
01:07:05 <quicksilver> calling an OS process is FFI
01:07:10 <quicksilver> (under the hood)
01:07:14 <fasta> Oh, nice.
01:07:27 <zeno> is ghci 6.10.1 a TON slower than ghc 6.8.2? seeming that way from a few random tests
01:07:27 <quicksilver> in the non-threaded RTS it would block, though.
01:07:39 <zeno> ~4x slower
01:07:41 <fasta> I do remember that there are problems with having too many open files, when using forkIO.
01:07:57 * fasta doesn't understand that silly OS limitation.
01:08:10 <sjanssen> fasta: huh?  I don't think forkIO has anything to do with files
01:08:12 <quicksilver> I imagine it's only intended to protect processes from themselves.
01:08:26 <quicksilver> but like all limits it's annoying hwne you have a legitimate reason to break it.
01:08:28 <ksf> zeno, it's propably the new codegen which isn't completely finished.
01:08:32 <fasta> sjanssen: no, but the process it calls does.
01:08:44 <quicksilver> that's not a problem, fasta
01:08:47 <sjanssen> fasta: forkIO doesn't call processes...
01:08:48 <quicksilver> those files belong to the subprocess
01:08:49 <zeno> ksf: ah ok thanks, so compiled will be slower also then right
01:09:11 <fasta> sjanssen: if I have an IO action which does, then it does.
01:09:14 <ksf> it shouldn't. actually, it should be faster, but you never know.
01:09:32 <sjanssen> fasta: yes, but this doesn't have anything to do with using threads
01:09:45 <fasta> quicksilver: right, and the union of all those processes can still cause a problem, or not?
01:09:47 <dcoutts> @seen Lemmih
01:09:48 <lambdabot> Lemmih is in #haskell-overflow and #haskell. I last heard Lemmih speak 14m 12s ago.
01:09:52 <fasta> It could have been something else last time.
01:09:52 <ksf> it's just the glue from the duct-tape holding 6.10 together that's making it slow.
01:10:07 <sjanssen> mapM (readFile . show) [0 ..] -- will run into the FD limit, and doesn't use threads
01:10:07 <fasta> I know that when I added worker threads myself, it stopped failing.
01:10:07 <pumpkin> ah, is 6.10 some sort of an "interim" release then?
01:10:32 <sjanssen> fasta: the worker threads probably just allowed you to open more threads at once
01:10:34 <Lemmih> dcoutts: Is there a reason why cabal-install shouldn't be used with the only version of Cabal that supports LHC?
01:10:35 <lambdabot> Lemmih: You have 3 new messages. '/msg lambdabot @messages' to read them.
01:10:39 <sjanssen> erm, I mean more files at once
01:10:41 <ksf> I wouldn't call it that, but yes.
01:11:01 <dcoutts> Lemmih: the stable version of cabal-install uses the stable version of the Cabal lib. At some point we'll have the dev version of cabal-install start using the dev version of the Cabal lib but it means that people cannot easily upgrade after that point.
01:11:18 <Baughn_> pumpkin: It's a .1 release. There /will/ be bugs.
01:11:28 <dcoutts> Lemmih: it means it would depend on Cabal >= 1.7. That makes life harder for everyone else.
01:11:29 <pumpkin> ah, didn't know if ghc followed that versioning scheme or not
01:11:36 <wli> I guess I have two problems: first searching for mutual intersection, then second traversing it.
01:11:46 <Baughn_> It's more of a pragmatic statemement than a scheme. :P
01:11:55 <pumpkin> wli: what are you doing?
01:12:02 <wli> pumpkin: Sparse matrices.
01:12:04 <Baughn_> Not too many people followed the 6.9 series, so there are less eyeballs to find bugs
01:12:32 <pumpkin> wli: interesting, I was actually asking about that a week or so ago :)
01:12:41 <pumpkin> Baughn_: I see
01:12:53 <Lemmih> dcoutts: But that means no LHC support until the next stable release even if users get the darcs version of cabal-install :(
01:13:31 <dcoutts> Lemmih: but we have to weigh that up against making it harder for people to test new stuff in the dev version of cabal-install
01:13:37 <wli> pumpkin: Basically things like matrix-vector multiplication, matrix-matrix multiplication, vector-matrix-vector multiplication, and additions and/or linear combinations for all sorts of sparsity patterns. Addition is probably the worst since it needs the full 2D region intersection search.
01:13:57 <dcoutts> Lemmih: at some point we'll switch, I'm not sure that now is the right time yet. There's more work to do for the stable 0.6.x series
01:14:02 <pumpkin> wli: that sounds wonderful... is it going to be public?
01:14:06 <wli> pumpkin: There's also some trouble figuring out ways to index regions.
01:14:24 <pumpkin> wli: I assume you've looked at how other sparse matrix libs (in other languages) deal with these issues?
01:14:27 <wli> pumpkin: If I ever get anywhere (e.g. devising algorithms). Everything I do is public.
01:14:52 <pumpkin> wli: yay :)
01:15:17 <wli> pumpkin: Mostly they restrict things to certain sparsity patterns and don't try too hard AFAIK. I've not intensively reviewed the literature or preexisting codebases.
01:16:26 <pumpkin> wli: ah
01:16:28 <wli> pumpkin: Another (potential) concern is avoiding replication of nonzero patterns (e.g. tridiagonal matrices each of whose nonzero diagonals consists of repetitions of the same value).
01:16:57 <pumpkin> ah yeah
01:17:02 <pumpkin> it sounds like an interesting problem
01:17:07 <pumpkin> I need to run now, but I'll be back a bit later
01:17:33 <wli> I'm not sure. I think it's mostly a repertoire and hairy data structure problem.
01:18:00 <wli> e.g. the 2D search trees are painful to implement.
01:19:06 <Lemmih> dcoutts: That's quite a shame. LHC won't be installable until the new version is out.
01:19:50 <Baughn_> Lemmih: Am I to believe that cabal is the reason LHC won't be online before next summer, now?
01:20:26 <mapreduce> @faq can Haskell delay multi-million pound experiments?
01:20:26 <lambdabot> The answer is: Yes! Haskell can do that.
01:20:41 <Lemmih> Baughn_: Yeah, we worked so hard to replace the Makefile system in Jhc and now its all for nothing.
01:20:54 <dolio> That'll show you.
01:21:28 <wli> One way to view it is as a set of inequalities extended with logical disjunction and conjunction.
01:21:43 <dcoutts> Lemmih, Baughn_: is it really that bad? There's nothing else you can do?
01:21:59 <Baughn_> dcoutts: Well, we could always try reversing the polarity flow
01:22:06 <dcoutts> heh heh
01:22:24 <dcoutts> Lemmih: if you want to check how easy it is to have the current cabal-install build against either Cabal-1.6 or 1.7 then go for it.
01:22:58 <dcoutts> if we can do it without cutting off our supply of testers or making it too hard to backport patches then we can try it
01:23:14 <wli> However, I do want to avoid quadratic blowups of submatrix intersection search times with increasing numbers of regions.
01:23:51 <hydo> and here all I want to do is parse json correctly...
01:25:09 <ivanm> is there any particular reason that lwn.net has HCAR reports but not HWN? after all, it seems to have ocaml, etc. newsletters...
01:25:49 <fasta> ivanm: HWN is not weekly?
01:26:06 <fasta> ivanm: HCAR is regular at least.
01:26:14 <ivanm> fasta: HWN is rougly weekly ;-)
01:26:31 <ivanm> and it wouldn't hurt to have it in LWN whenever it _is_ out...
01:31:59 <mercury^> byorgey: I solved the problem I had yesterday.
01:32:02 <Lemmih> dcoutts: Hm, it's not that bad. For now we can just duplicate some of cabal-install in our Setup.hs.
01:32:05 <mercury^> In case you are interested...
01:32:07 <mapreduce> @go hcar haskell
01:32:10 <lambdabot> http://www.haskell.org/communities/
01:32:10 <lambdabot> Title: Haskell Communities and Activities Report
01:32:13 <centrinia> Is HWN amortized weekly? ;)
01:32:24 <ivanm> centrinia: heh
01:32:31 <ivanm> maybe amortized every 8 days? ;-)
01:32:48 <dcoutts> Lemmih: so what would you have to put in your Setup.hs ?
01:32:57 <centrinia> Ah, amortized long weekly. ;)
01:33:07 <mercury^> byorgey: http://rohanlean.de/pub/76/76.hs
01:33:25 <mercury^> the new g does what I wanted :)
01:34:56 <Lemmih> dcoutts: Flags to make 'runhaskell Setup' behave like 'cabal install'. Right now that just means setting the prefix.
01:44:10 <Lemmih> dcoutts: We still cabal-install to build packages other than base.
01:45:22 <Lemmih> Hm, Hackage wont accept packages with optional hpc support. That's quite annoying.
01:46:31 <solrize> is there something like python's split operation?  split ',' "foo,bar,baz" == ["foo","bar","baz"]
01:47:32 <solrize> hmm, data.bytestring.splitwith
01:51:49 <dcoutts> Lemmih: can you please file a ticket for generic hpc support, what it would involve etc.
01:52:32 <Lemmih> dcoutts: Sure, where's the tracker?
01:52:58 <dcoutts> Lemmih: http://hackage.haskell.org/trac/hackage/
01:56:55 <wli> What's hpc?
01:57:07 <dcoutts> wli: haskell program coverage
01:57:57 <dcoutts> wli: eg to check how much your testsuite covers your code
01:58:08 <wli> Cool.
01:58:21 <wli> quickcheck + hpc sounds nice.
01:58:25 <dcoutts> yeah, it's got pretty html and everything :-)
01:58:30 * Lemmih can't figure out how to add a ticket.
01:58:37 <dcoutts> Lemmih: log in first
01:58:48 <Lemmih> dcoutts: I need to register?
01:59:05 <Lemmih> I don't care that much.
01:59:10 <dcoutts> Lemmih: see the instructions on the home page http://hackage.haskell.org/trac/hackage/#Thebugtracker
01:59:23 <BeelsebobWork> there isn't a class that represents types that have a zero value, is there?
01:59:24 <dcoutts> Lemmih: you do not need to register
01:59:39 <fasta> BeelsebobWork: there is Default
02:00:10 <dcoutts> Lemmih: got it?
02:00:14 <BeelsebobWork> where's that defined fasta?
02:00:24 <fasta> BeelsebobWork: somewhere on hackage
02:00:28 <BeelsebobWork> ah, okay
02:00:31 <fasta> BeelsebobWork: I don't use it/
02:00:44 <Lemmih> dcoutts: Got it.
02:18:29 <Peaker> Can class alises be implemented in TH? Or do they require any change to GHC itself?
02:23:58 <quicksilver> perspectival1:
02:24:05 <quicksilver> Peaker: TH can't add new syntax.
02:24:25 <quicksilver> (at least, not in arbitrary ways: it can control specific syntax)
02:24:33 <quicksilver> I'm sure you could use TH to implement the 'idea' of class aliases.
02:24:46 <quicksilver> with a slightly clunky interface
02:25:15 <perspectival1> quicksilver: ?
02:27:29 <quicksilver> perspectival1: tab complete error, sorry ;)
02:27:41 <wli> There used to be a distinct MonadZero, but it got screwed over and conflated with MonadPlus.
02:27:57 <perspectival1> quicksilver: ;-)
02:27:57 <Deewiant> Haskell 98 screwed everything over compared to 1.4
02:28:10 <Peaker> quicksilver: well, a tiny preprocessor could be added too, I guess
02:28:41 <wli> I wonder if anything's been done about alternative preludes reverting the mistakes in the 1.4 -> 98 transition.
02:29:19 <Deewiant> Everyone talks about their ideas, at least, but I'm not sure if anyone's actually sat down and written even the beginnings of a proper new Prelude :-)
02:30:04 <wli> I very quickly ran into compiler intrinsics problems (as I always do with Prelude hacking).
02:31:38 <dcoutts> Lemmih: did you know that you can use wildcards in the extra-source-files field. Like lib/base/src/Data/*.hs
02:31:54 <wli> Various Prelude alterations very quickly propagate to other areas.
02:33:28 <Lemmih> dcoutts: Neat. That will help quite a bit.
02:33:54 <dcoutts> Lemmih: it's not recursive though, so only things like dir/*.hs, blah/*.arch
02:34:00 <wli> It'd probably be easier in hugs98.
02:36:45 <taruti> How would I express "class W a b | a -> b, b -> a" with type families?
02:40:03 <Peaker> taruti: class W a { data B a }
02:40:05 <dolio> class (One a ~ b, Two b ~ a) => Class w a b where type One a :: * ; type Two b :: *
02:40:26 <dolio> Oops, messed up some capitalization there.
02:40:43 <Peaker> oh, oops, I don't know about type families, only associated types :)
02:40:46 <dolio> And that extra "Class" was misplaced.
02:41:07 <taruti> hmm, the two variable thing seems sensible
02:41:28 <Peaker> dolio: What does the ~ do?
02:41:34 <dolio> That's type equality.
02:41:49 <dolio> So it says that One a equals b, and Two b equals a.
02:42:00 <dolio> Which does the same thing as the fundeps.
02:42:16 <dolio> I think that's right, at least...
02:42:54 <Peaker> Why not use an associated data-type instead of associated synonym, with a single-param class?
02:43:24 <Peaker> If you have:   class W a { data B a }  -- then "a" has bijective correspondence to (B a)
02:43:46 <dolio> That's not what his original class does. It says that there's a class where the first parameter determines the second, and vice versa.
02:44:00 <dolio> And neither has to be a data family.
02:44:08 <Peaker> Yeah, this does something else, but I think it can be used to the same effect
02:44:12 <wli> Ugh. The clock will have to be set back.
02:44:23 <dolio> What if you want "instance W Int Char where ..."?
02:44:53 <Peaker> you'd have to have  Instance W Int where { B Int = B Char }  and always use B around the char
02:45:30 <Peaker> The extension features in ghc are so overlapping, you could do it in so many ways :-(
02:46:01 <dolio> Yeah.
02:48:04 <Peaker> I think these features are pretty expensive, learning wise, and probably compiler-wise.  Do they all have really good use cases behind them (and constantly making sure they aren't better implemented by the other overlapping features?)
02:51:19 <dolio> There are things you can do with type families that you can't with data families, and vice versa.
02:52:16 <Peaker> are type/data families the same as associated types/datas?
02:52:29 <ddarius> No
02:52:33 <Peaker> and what is the name of the type-equality feature?
02:55:02 <dolio> That's part of the type families stuff.
02:56:18 <dolio> Type families are more like a generalization of associated types.
02:56:47 <dolio> Inasmuch as you can use them without classes, and, say, that type equality predicate wasn't in the original associated type formulation to my knowledge.
02:59:41 <Peaker> how do you use type families without classes?
03:04:28 <dolio> type family Foo a :: * ; type instance Foo Int = Char
03:12:33 <BeelsebobWork> Peaker: you available to stare at some reactive code, and help untying a knot?
03:12:40 <BeelsebobWork> or quicksilver if you're about?
03:16:35 <Peaker> BeelsebobWork: I can try
03:17:00 <BeelsebobWork> I'm having a go at what pong would look like, and I realise integral won't work right yet...
03:17:12 <BeelsebobWork> but I'm getting a <<loop>> in my code for computing the ballPosition
03:17:12 <BeelsebobWork> http://hpaste.org/12962
03:17:24 <BeelsebobWork> and I'm not quite sure how to untie the loop
03:33:10 <mjoldfield> Hello
03:33:41 <mjoldfield> Is it appropriate to ask newbie questions in here ?
03:33:49 <BeelsebobWork> very
03:34:40 <mjoldfield> OK, suppose I have a type defined thus: type Score (Int, String) and I want impose some sort of ordering on Scores, how do I do it ?
03:35:18 <ksf> instance Ord Score where (...)
03:35:19 <BeelsebobWork> well, first you'd need type Score = (Int, String)
03:35:31 <BeelsebobWork> and that would automatically gain the ordering defined for tuples
03:35:32 <ksf> where (...) is your definition of the required functions.
03:35:42 <BeelsebobWork> (which is to use the ordering on the first, and when that fails use the ordering on the second)
03:36:03 <BeelsebobWork> if you want to define you own ordering instead, you'd need to use newtype Score = Score (Int, String)
03:36:28 <ksf> (me misread mjoldfield's "type" as "data")
03:36:29 <mjoldfield> ksf : Will that work for a type ... or just data ... ?
03:36:31 <BeelsebobWork> and then define as ksf said instance Ord Score where compare (Score (s,n)) (Score (s',n')) = ...
03:36:34 <mjoldfield> ksf : Ah :)
03:36:47 <BeelsebobWork> mjoldfield: you can define your own instances for newtypes and datas
03:36:51 <BeelsebobWork> but not types
03:36:57 <BeelsebobWork> a type is litterally a synonym
03:37:09 <mjoldfield> BeelsebobWork : Ah, newtype is new to me. I shall go and RTFM now :)
03:37:22 <ksf> I'd use data Score = Score Integer String, anyway...
03:37:29 <mjoldfield> BeelsebobWork : Splendid. Thanks for your help, it's just what I wanted to know
03:37:32 <BeelsebobWork> yeh, I'd do what ksf said too
03:37:53 <ksf> saves precious parens and commas.
03:38:03 <BeelsebobWork> if it turns out that you *do* want the default ordering... then you can do data Score = Score Integer String deriving (Eq, Ord)
03:38:11 <Peaker> BeelsebobWork: where's "roots" from?
03:38:14 <mjoldfield> So is the idea that type gets mainly used when you're just attaching a 'label' ?
03:38:27 <BeelsebobWork> Peaker: oh, that's one of my babies that I haven't sent to conal yet... sec
03:38:29 <mjoldfield> Beelsebob : Yes thanks, I think I knew about deriving
03:38:34 <ksf> type gets used if you're just a lazy typist.
03:38:51 <BeelsebobWork> Peaker: http://hpaste.org/12962#a1
03:39:38 <mjoldfield> Thanks guys, that was quite a splendid answer
03:39:46 <BeelsebobWork> :)
03:41:28 <Peaker> BeelsebobWork: where do I place that, in PrimReactive?
03:42:23 <BeelsebobWork> Peaker: oh, Behavior.hs
03:42:27 <BeelsebobWork> with a few extra imports
03:42:34 <BeelsebobWork> and you'll need to re-export it in FRP.Reactive
03:43:01 <Peaker> BeelsebobWork: I think its weird that Reactive conflates the primitive Event/Reactive/Behavior/etc stuff with higher-level stuff like integrals, etc
03:43:27 <BeelsebobWork> Peaker: hmm? I'm not sure I get what you mean
03:43:54 <Peaker> BeelsebobWork: I think the Reactive library should be split to the bare minimum FRP stuff, and Reactive-extras/such for the vector-space integrals, root-finding behaviors, etc
03:44:11 <BeelsebobWork> Peaker: that would be an interesting way to do it
03:44:17 <BeelsebobWork> might be worth suggesting that to conal
03:44:47 <quicksilver> the problem is that some of the higher-order stuff has to break abstraction barriers
03:44:53 <quicksilver> it can't be implemented on the public interface.
03:45:11 <quicksilver> That does raise the sensible question of what is the minimum extension to the interface to make it implementable, I think.
03:45:29 <BeelsebobWork> indeed
03:47:21 * Peaker is in dependency hell again, accidentally b0rked my ghc install, reinstalling it
03:48:06 <Peaker> If apt had packages for all the Haskell stuff, everything'd be so much easier.  Currently, cabal-install is trying to be too smart for its own good
03:48:50 <BeelsebobWork> :(
03:49:15 <Peaker> (Trying to install newer packages that conflict with the versions ghc was compiled with -- big nono, still preferred by cabal-install)
03:50:24 <Peaker> BeelsebobWork: hmm.. do you have a whole patch or darcs repo I can pull from? Putting that paste into Behavior.hs is not enough
03:50:34 <BeelsebobWork> sec
03:50:36 <Peaker> BeelsebobWork: (not re-exporting problem, its importing a bunch of stuff, etc)
03:54:06 <roderyk> is it perchance safe to read/write an IORef from 2 different gtk2hs timeoutAdd threads running at the same time? Or do I need a global tick that synchronizes everything?
03:54:37 <dcoutts> roderyk: the timeouts happen in the same thread
03:54:43 <BeelsebobWork> Peaker: www.cs.kent.ac.uk/people/rpg/tatd2/behaviors.patch -- unfortunately, you'll get my Monad instance for Behavior too, darcs wasn't playing nice
03:56:33 <roderyk> dcoutts: ah, so there is no issue with 2 timeouts possibly clobbering an IORef?
03:56:52 <dcoutts> roderyk: since the cannot happen in different threads, no
03:56:52 <roderyk> always one or the other will be run at any moment, right?
03:56:57 <roderyk> ok
03:57:11 <dcoutts> (I think)
03:57:11 <Peaker> BeelsebobWork: Missing "tagged 0.10.3"
03:57:21 <BeelsebobWork> darcs pull reactive?
03:57:24 <BeelsebobWork> I got that today
03:57:32 <Peaker> BeelsebobWork: oops, I forgot to do that today :)
03:57:44 <dcoutts> roderyk: it's not much more expensive to use an MVar though, and then that's safe if you've got other users of the var in other threads
03:57:59 <Peaker> BeelsebobWork: a Behavior Monad instance, how can that work?
03:58:13 * ksf thinks the current state of FRP sucks.
03:58:14 <roderyk> dcoutts: will look into MVar, thanks
03:58:16 <BeelsebobWork> like this...
03:58:16 <BeelsebobWork> instance Ord t => Monad (BehaviorG (Improving t) t) where
03:58:17 <BeelsebobWork>   return  = pure
03:58:17 <BeelsebobWork>   b >>= f = (\t v -> sampleB t (f v)) <$> time <*> b
03:58:21 <ksf> I just can't decide what to use.
03:58:40 <BeelsebobWork> ksf: Reactive is *so close* to useable
03:58:51 <BeelsebobWork> in fact, it is useable -- as long as you don't want an integral in there
03:58:57 <BeelsebobWork> a recursive integral more precicely
03:59:16 <ksf> Well I can't even decide whether to go for Yampa or Reactive.
03:59:49 <BeelsebobWork> my impression of Yampa is that it buys you not huge amounts over just using IO
03:59:55 <BeelsebobWork> it still has a sequential non-functional feel
03:59:56 <ksf> ...and I don't really want to wait for conal to finish the one FRP lib that's going to obsolete them all.
04:00:13 <BeelsebobWork> well, the one FRP that will obsolete them all *is* Reactive
04:00:16 <BeelsebobWork> it's just not stable yet
04:00:31 <Peaker> Yampa signal processors are exposed to the sampling rate, and actually update the output signal discretely
04:00:39 <BeelsebobWork> yeh
04:00:42 <BeelsebobWork> which is rather lame
04:00:50 <BeelsebobWork> plus, you're always tied to writing everything in arrows
04:00:52 <BeelsebobWork> which is horrible
04:01:14 <Peaker> with the recursive do notation, which I still don't fully understand :P
04:01:55 <BeelsebobWork> see... I have worrysome time now
04:02:02 <ksf> I think something like the arrow notation would be great for nested monads, but that's beside the point.
04:02:07 <BeelsebobWork> my external examiner for my PhD is gonna be Henrik >.<
04:02:19 <BeelsebobWork> (on a non-FRP subject though)
04:02:52 <ksf> something like foo <- bar -< pull1 and foo <- bar -< pull2
04:03:03 <ksf> ...which just lifts the computation by N steps.
04:03:29 <BeelsebobWork> that sounds a lot like infixApplicative
04:08:21 <Megzlna> So, if one module imports then re-exports modules, is Haskell's ability to have unique namespaces completely lost?
04:08:41 <BeelsebobWork> ability to have unique namespaces?
04:08:46 <BeelsebobWork> I'm not sure I follow what ability that is
04:09:26 <Megzlna> then think
04:10:01 <BeelsebobWork> okay then, I won't have an interesting discussion with you about it :)
04:10:56 <Peaker> Megzlna: what are "unique namespaces"?
04:11:05 <Megzlna> Module.f
04:11:17 <Megzlna> Module2.f
04:11:19 * vixey grits her teeth
04:11:30 <BeelsebobWork> what's unique about them?
04:11:36 <Megzlna> the 2
04:11:47 <Peaker> Megzlna: those are ordinary namespaces
04:11:49 <vixey> it's like fingernails on a blackboard
04:12:09 <BeelsebobWork> vixey: I was thinking pulling teeth actually
04:12:35 <Megzlna> Peaker: Yes, ordinary namespaces which are unique in the context of import Foo  import Bar
04:12:43 <BeelsebobWork> yes... okay
04:12:51 <Megzlna> but, no longer so if one module imports then re-exports another
04:12:51 <BeelsebobWork> and why does re-exporting stop them being unique?
04:12:55 <BeelsebobWork> why not?
04:13:20 <BeelsebobWork> module A (B) where import B
04:13:20 <BeelsebobWork> module B where ...
04:13:26 <BeelsebobWork> I still have two unique module names -- A and B
04:13:41 <Megzlna> does that work via import A ?
04:13:48 <BeelsebobWork> does what work via import A?
04:13:57 <Megzlna> <BeelsebobWork> I still have two unique module names -- A and B
04:14:02 <Peaker> Megzlna: unqualified importing basically copies subsets of namespaces into namespaces, and qualified imports basically create new names that represent namespaces
04:14:16 <BeelsebobWork> Megzlna: yes, I can still import A, and get the contents of A (which includes the contents of B)
04:14:18 <Megzlna> Peaker: ah. How do I properly do a qualified re-export?
04:15:02 <dolio> You do not.
04:15:09 <Megzlna> BeelsebobWork: do you seriously not understand what I am asking...
04:15:21 <BeelsebobWork> Megzlna: no -- that's why I'm trying to get a clear question out of you
04:15:30 <Peaker> Megzlna: You can't re-export qualified module names
04:15:55 <vixey> Megzlna, I'll save you years of trouble. Haskells module system isn't that good :)
04:16:02 <Megzlna> BeelsebobWork: Your answer "which includes the contents of B" is exactly what I just explain 2 or 3 times is what I dont want
04:16:14 <BeelsebobWork> Megzlna: so don't re-export it then >.<
04:16:18 <Megzlna> ugh
04:16:23 <dolio> Re-exporting is just a shorter way of re-exporting every function and type in the module.
04:16:34 <dolio> Exporting a module, that is.
04:17:20 <Peaker> Megzlna: you choose whether to re-export an imported module or not, what's the problem?
04:17:35 <Megzlna> well, this basically makes imports and re-exports on any kind of larger project totally useless
04:17:42 <BeelsebobWork> why is that?
04:17:58 <Megzlna> unless your whole entire project ensures global names for every single function
04:18:27 <BeelsebobWork> Megzlna: are you trying to have module A re-export B and C, where B and C have a name-space clash?
04:19:14 <Megzlna> so you have Graphics module
04:19:20 <Megzlna> an you have Canvas
04:19:24 <Megzlna> and Widget
04:19:37 <Peaker> Megzlna: Use qualified imports
04:19:37 <vixey> Megzlna, you're doing object oriented design..?
04:19:38 <Megzlna> Graphics cannot import Canvas and Widget
04:19:46 <Megzlna> both of which do "draw"
04:19:57 <Deewiant> yes it can
04:19:57 <BeelsebobWork> Megzlna: sure it can -- import qualified Canvas as C
04:20:02 <BeelsebobWork> import qualified Widget as W
04:20:05 <Peaker> Megzlna: unqualified imports suck, though Haskell encourages them :-(
04:20:05 <vixey> Megzlna, This is actually the complete wrong way to structure a haskell program
04:20:11 <Megzlna> Yes, but
04:20:21 <vixey> Megzlna, SYN?
04:20:24 <Megzlna> THat's my point, then Graphics module cannot export stuff for you
04:20:32 <Megzlna> you have to go through the whole list
04:20:33 <BeelsebobWork> Megzlna: yes, that's true
04:20:43 <BeelsebobWork> right -- now that we understand the question...
04:20:43 <Megzlna> and do every module explicitly
04:20:48 <BeelsebobWork> no Haskell can't do that
04:20:52 <BeelsebobWork> it's a shame :(
04:20:58 <Peaker> BeelsebobWork: Can you translate the question for me? I didn't understand it
04:21:00 <BeelsebobWork> as vixey said -- Haskell's module system needs overhaul
04:21:13 <BeelsebobWork> Peaker: suppose you have modules A and B, both of which define f
04:21:17 <Megzlna> well this is a very big problem considering how Haskell is a functional language
04:21:22 <Megzlna> and hence you have an abundance of functions
04:21:24 <vixey> BeelsebobWork, personally I don't see any 'solution' except maybe an object system
04:21:25 <BeelsebobWork> and you want module C which imports both of them, and re-exports their functionality
04:21:26 <Megzlna> and horrible namespace support
04:21:32 <Megzlna> and not even any sub-module namespacing
04:21:37 <BeelsebobWork> Peaker: you then can't... because you can't re-export qualified
04:21:44 <Megzlna> nor Overloading based on type
04:21:45 <Peaker> BeelsebobWork: so I create module C that does qualified imports of A, B   defines whatever I want to re-export, and re-export those symbols?
04:21:49 <Megzlna> so you're screwed
04:21:51 <vixey> Megzlna, too busy explaining why haskell sucks to hear my side of the story?
04:21:56 <Peaker> BeelsebobWork: Right, so I export just the actual symbols
04:22:02 <BeelsebobWork> Peaker: indeed
04:22:13 <dolio> Megzlna: You should go use ML.
04:22:26 <vixey> I think Megzlna should go use Smalltalk or C++ or Java
04:22:35 <dolio> Okay.
04:22:42 <vixey> (if they want to do OO design)
04:22:44 <Peaker> BeelsebobWork: or I use:  module C (A, B, clashA, clashB) ; import A (hiding clash) ; import B (hiding clash) ; import qualified A ; import qualified B ; clashA = A.clash ; clashB = B.blash
04:22:56 <Megzlna> How can a Haskell program be written by more than 1 person?
04:22:57 <BeelsebobWork> Peaker: yeh, indeed
04:23:03 <BeelsebobWork> Megzlna: darcs
04:23:13 <BeelsebobWork> Megzlna: take a look at what Peaker just pasted
04:23:22 <Megzlna> programmer A writes a "draw", and programmer B writes a "draw"
04:23:33 <BeelsebobWork> Megzlna: and then one of them has to deal with the merge
04:23:36 <BeelsebobWork> and realises their mistake
04:23:46 <Megzlna> so they call it
04:23:47 <Peaker> Megzlna: or you can use the draw only via qualified imports
04:24:04 <Deewiant> programmer C imports whichever draw he needs; if he needs both, he imports one as qualified
04:24:05 <Peaker> Megzlna: or you can have disambiguating modules that you import
04:24:22 <Peaker> I think everyone should import as much as possible qualified
04:24:30 <Peaker> (operators get an exception)
04:24:44 <Peaker> (and perhaps very stdlib-ish things like Data.Monoid, etc)
04:24:55 <vixey> Peaker, I don't like that rule of thumb
04:25:10 <Peaker> vixey: do you like reading code that has 15 imports, and you have no idea where names come from?
04:25:33 <Deewiant> Peaker: why qualified, why not just explicit importing of identifiers
04:25:34 <Samy> Peaker, I agree.
04:25:35 <Deewiant> (whatever it's called)
04:25:41 <vixey> Peaker, that's why I don't hack on GHC :P
04:25:41 <Peaker> Deewiant: that's fine too, indeed
04:25:54 <Samy> Peaker, any "production-quality" Haskell I've written I've used qualified imports as much as possible.
04:26:03 <vixey> Peaker, qualifying all your imports doesn't mean you have less than 15
04:26:17 <Peaker> Deewiant: I really just don't like import *'s (Excuse my Python :-), except from very very well-known libraries (stdlib stuff)
04:26:17 <Samy> Peaker, excluding some of the things that are in default Prelude already.
04:26:31 <Samy> vixey, but they tell you where the names come from.
04:26:41 <vixey> so I say that's a way to make complex things manageable, instead of making complex things simple
04:26:46 <vixey> This is exactly OO design instead of function
04:26:46 <Samy> vixey, and they also help namespace, in case people want to import additional things there is less likelihood for namespace collision.
04:26:48 <vixey> al*
04:27:01 <Deewiant> Peaker: I sometimes use them for convenience, but I try to use at most one per module (so if you can't find a name in the file it must have come from that one unqualified one)
04:27:04 <Peaker> vixey: On the contrary, the more modular your code is, the more imports per-line you're going to have
04:27:19 <Peaker> vixey: And functional code allows for more modularity
04:27:28 * ksf has an intuition he can find a good frp primer in ctm but has no idea where.
04:27:47 <vixey> modularity is a term from OO design
04:27:58 <Peaker> Deewiant: remember that there's always one unqualified one already (The Prelude), though hopefully everyone remembers its names
04:28:19 <Deewiant> indeed, I would hope so :-P
04:28:22 <Peaker> vixey: Then use the word composability, if you'd like
04:28:53 <nolrai_East> @hoogle (Maybe a) -> (Maybe a) -> (a -> a -> b) -> (Maybe b)
04:28:53 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
04:28:53 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
04:28:53 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
04:28:54 <Megzlna> the "OO" part of that stuff doesn't matter. It's just practical evolution. Haskell could just as well allow per-value-type namespaces, and better modules support than C langs
04:29:05 <Peaker> vixey: you're going to be composing an Applicative Functor, a Monoid, with a Data.Map and perhaps throw in some category-extras' instances, and ApplicativeInfix, and your 3-line function already has 5 imports
04:29:42 <Peaker> Megzlna: I am satisfied with Haskell's module system, except for its encouragement of crazy unqualified imports
04:29:51 <vixey> Peaker, and I don't know where any of the functions liftA2 <*> and fromList come from?
04:29:54 <Peaker> (Maybe its because I've never used ML's more powerful one)
04:29:54 <Megzlna> I don't understand, Peaker
04:30:03 <Megzlna> "and your 3-line function already has 5 imports"
04:30:09 <Megzlna> and that's a GOOD thing?
04:30:18 <quicksilver> Megzlna: there has been quite a lot of discussion about a good module system for haskell, and even some papers written on it.
04:30:18 <Deewiant> vixey: Hoogle — learn it, use it, it's your friend ;-)
04:30:26 <quicksilver> but no one seems to be able to agree on what they want
04:30:32 <Samy> No. But how is that going to be avoidable Megzlna?
04:30:33 <quicksilver> and no one has tried to implement any of them seriously.
04:30:35 <Peaker> vixey: Sure, Control.Applicative, Data.Monoid and a few others get a free pass, but the lesser known ones are still very useful and just as composable
04:30:50 <nolrai_East> Megzina: how is that a bad thing?
04:31:00 <Megzlna> import Common
04:31:03 <Peaker> Megzlna: yes! It means we're re-using a lot of code, instead of having big balls of mud
04:31:08 <Megzlna> stuff you use all over your project
04:31:13 <Samy> Megzlna, unfortunately, that's very expensive.
04:31:17 <Peaker> Megzlna: "Common" and "Misc" modules are an anti-pattern
04:31:26 <Samy> Megzlna, but not necessary on another project (or another environment).
04:31:29 <Megzlna> Samy: it's not expensive.
04:31:37 <Samy> Megzlna, it is.
04:31:43 <Samy> Megzlna, since things are statically linked.
04:31:50 <Megzlna> It doesn't even need to compile or link anything unused
04:31:57 <Megzlna> Unless it's retarded / broken
04:32:01 <Samy> a 900kB executable turning into 4MB is expensive.
04:32:04 <vixey> Peaker, what I am stressing is that good design is about making complex things simple not manageable
04:32:10 <Megzlna> Samy: Compilers dont do that
04:32:16 <Peaker> Megzlna: namespaces are a good thing and "import Everything" basically gets rid of namespaces
04:32:22 <Megzlna> Not in the past 10 yrs at least
04:32:26 <Samy> Megzlna, what does a compiler have to do with this?
04:32:26 <Megzlna> they did in the 90's
04:32:35 <Samy> Megzlna, yes, this is an issue with the linker phase.
04:32:42 <Megzlna> Samy: by compilers I mean the whle package
04:32:42 <Samy> Megzlna, but we're talking about GHC here.
04:32:48 <Megzlna> gcc's use of ld
04:32:58 <Samy> Megzlna, this has nothing to do with that, really.
04:33:01 <Saizan> Samy: with split-objs that can be solved, afaiu
04:33:15 <Samy> Saizan, it would help, yes.
04:33:18 <Megzlna> Samy: Well I don't even believe GHC doesn't do that, either
04:33:19 <Peaker> vixey: I think there's an important distinction between complex and complicated.  Big systems are inherently complex, where complex merely means comprised of many parts.  Ideally, you can build your complex systems as a simple composition -- but composition of simple parts almost automatically implies a lot of imports
04:33:20 <Samy> Dynamic linking is still superior though.
04:33:52 <Samy> That is, for space/time trade-off, especially over time if your stuff isn't that performance/latency sensitive.
04:34:01 <vixey> Peaker, yes except it doesn't mean you must have a lot of imports
04:34:17 <Samy> Saizan, why isn't this supported by default in GHC?
04:34:25 <Peaker> vixey: the parts you're composing do not come from various modules?
04:35:15 <Peaker> Megzlna: why do you hate namespaces? :)
04:35:21 <Megzlna> No, I love them
04:35:33 <Peaker> Megzlna: then why do you want to import Everything into everything, thereby getting rid of namespaces?
04:35:58 <Peaker> Megzlna: why did you suggest "import Common" which is basically exactly that?
04:35:59 <Megzlna> a great thing C++ popularized, and which is NOT exclusively bound to "object oriented", is the simple concept of namespaces for functions that apply to a certain value type
04:36:13 <Megzlna> Peaker: Because of Qt
04:36:21 <vixey> C++ has taught us a lot about language design :p
04:36:24 <Samy> Qt uses a preprocessor.
04:36:28 <Samy> vixey, haha
04:36:33 <Peaker> about what *not* to do, yeah :)
04:36:47 <Peaker> Megzlna: So you want to get rid of namespaces because of Qt?
04:36:58 <Megzlna> Samy: Qt's preprocessor has nothing to do with that... Qt's MOC (meta object compiler) embeds metadata for reflection into a little static array
04:37:05 <Megzlna> Peaker: No, Qt is an example.
04:37:13 <Megzlna> Look at this diagram:
04:37:26 <Peaker> Megzlna: The problem with the OO approach to name-spacing, is that it makes 3rd-party functions on a type 2nd-class citizens, and that it forces you to choose arbitrarily whether f(A, B) should sit in A or B
04:37:53 <Samy> Megzlna, my point was not so much about that, but more that Qt is not exactly liked in some circles (in design).
04:37:54 <Megzlna> http://doc.trolltech.com/extras/qt43-class-chart.pdf
04:37:58 <Samy> Megzlna, but maybe it's just my circles.
04:38:16 <Peaker> Megzlna: One of the main things I found more elegant about Haskell, is that it has only *one* notion of namespacing (modules) and that whether f :: A -> B  was written by the author of A or not, does not change the way you access its name
04:38:26 <Megzlna> Well, if you see people explicitly importing Qt stuff
04:38:27 <vixey> Megzlna, why do you insist on this OO design approach?
04:38:33 <Megzlna> they import half a page of things
04:38:40 <vixey> Megzlna, is it the only approach to design you've used in practice?
04:39:01 <Megzlna> Vixey: Namespacing is not OO
04:39:07 <Megzlna> Namespacing is Programming Language
04:39:10 <Peaker> Megzlna: the namespace of any specific Qt instance is *so cluttered* that considering it as a good example is ridiculous
04:39:13 <vixey> Megzlna, Everything you have said
04:39:30 <Megzlna> Peaker: Ok, but
04:39:31 <Samy> Peaker, what do you think of GTK+?
04:39:39 <Megzlna> Imagine making a GUI library of Qt's scale.
04:39:42 <vixey> Cocoa is a good example of OO design
04:39:46 <Megzlna> Would Haskell's module system cut it?
04:39:49 <Peaker> Samy: I hate its Tree View :-)
04:39:56 <Samy> Peaker, oh yeah, it is hell :-)
04:40:05 <vixey> Megzlna, I already answered that, no
04:40:21 <vixey> Megzlna, if you paid attention to what I have been saying.. :)
04:40:22 <Megzlna> vixey: why not?
04:40:25 <Peaker> Samy: I wrote a Python tracer and tried using Gtk+'s tree view to present the results, and it took more hours to code the Gtk+ viewer than the tracer itself!  And its impossible to get it to lazily work on the data set in some circumstances
04:40:35 <Samy> Peaker, yes, yes, it is a bitch.
04:40:37 <vixey> Megzlna, all the reasons you've brought up for a strart
04:40:44 <Samy> Peaker, this is why MSVS is nice.
04:40:46 <Megzlna> vixey: I dont know a damn thing
04:40:49 <Megzlna> so tell me
04:40:50 <Samy> Peaker, glade pales in comparison.
04:40:57 <vixey> Megzlna, yes you do, you know a bit about OO design
04:40:58 <Peaker> Samy: I think all conventional GUI toolkits are also bound to create horrible GUI's (I consider an iPhone-like GUI reasonable, and form-based GUI horrible)
04:41:04 <vixey> Megzlna, None of that is relevant here
04:41:07 <Peaker> Samy: I really like Qt's GUI designer though
04:41:13 <Megzlna> It is absolutely relevant
04:41:16 <Samy> Peaker, otherwise, I like their event model (interaction with idle loop) and other than the tree view, it is generally really nice to use. Bounding boxes are nice.
04:41:20 <vixey> Megzlna, That's not how you structure any large haskell program
04:41:31 <Samy> Peaker, yes, it is nice.
04:41:35 <Peaker> Megzlna: Haskell's module system would definitely "cut it"
04:41:36 <Megzlna> Look... Haskell has unique value types
04:41:43 <vixey> no it doesn't
04:41:54 <Peaker> Megzlna: Its a much nicer namespacing system than that of C++ which Qt is based on
04:41:54 <Megzlna> That means it is "OO" as much as C++ is
04:42:00 <vixey> If Haskell has "unique value types" I'd probably have some idea WTF that is :P
04:42:00 <nolrai_East> What is a unique value type?
04:42:32 <Megzlna> A unique value type is a type for which a function signature cannot be overloaded between type A and B
04:42:41 <Peaker> Clean has unique-value types (they guarantee a value processor will get rid of the old copy before generating a new one)
04:43:11 <Peaker> Megzlna: You have a very weird notion about what it means for a language to be "OO"
04:43:31 <vixey> Megzlna, I'm not going to try and drill this into you but the best advice I can give is put adside any OO design principles and intuitions and try to structure a large haskell program in the natural (functional) way
04:43:48 <vixey> Megzlna, (if you are actually interested in seeing how this works)
04:43:59 <Megzlna> OO only means:  (Namespacing of functions to a type)  (Hiding 'self')  (Polymorphism)
04:44:15 <vixey> that's not what I've been using OO it mean :P
04:44:18 <Peaker> Megzlna: OO meaning definitely includes inheritence, and Haskell does not have that
04:44:19 <Megzlna> If you use a Module in Haskell, as a namespace for a bunch of functions working on the type defined in the module
04:44:22 <Megzlna> then that's "OO"
04:44:31 <Megzlna> o `method` x y z
04:44:40 <Peaker> Megzlna: No, that's necessary but not sufficient for "OO"
04:44:43 <Zao> Megzlna: What about "communicating between entities with messages"?
04:44:51 <Megzlna> Zao: FRP ?
04:44:58 <vixey> Zao, that's exactly what I was thinking
04:45:04 <Peaker> Megzlna: Haskell has the good things from OO (encapsulation, data hiding), but not the bad ones (inheritence)
04:45:13 <Peaker> Megzlna: what you mentioned is merely encapsulation
04:45:26 <Peaker> Megzlna: one of the bad things about OO is how it handles class namespaces
04:45:29 <Zao> The C++/Java/whatnot form of "OO" is just a facet of a larger concept.
04:45:33 <Megzlna> Haskell has inheritance.
04:45:37 <Peaker> Megzlna: oh?
04:45:46 <Megzlna> Instance functions vs. Typeclass functions
04:45:54 <Peaker> Megzlna: that's not inheritence
04:46:08 <vixey> Peaker, think data types a la carte
04:46:12 <Peaker> Megzlna: instance declarations and inheritence are both faciltators of polymorphism - but they are not the same thing
04:46:13 <Megzlna> what is it? :P
04:46:14 <nolrai_East> Its a replacement for inheritence.
04:46:24 <vixey> Megzlna, might want to read it
04:46:35 <vixey> @go data types a la carte
04:46:41 <Megzlna> vixey thx
04:46:46 <lambdabot> http://journals.cambridge.org/production/action/cjoGetFulltext?fulltextid=1899160
04:46:46 <lambdabot> Title: CJO - Abstract - Data types à la carte
04:46:51 <Zao> A typeclass resembles the interface concept.
04:46:52 <Samy> I don't like inheritence either. But why do you think inheritence is bad, Peaker?
04:47:02 <vixey> mm that's useless
04:47:09 <vixey> @go citeseer data types a la carte
04:47:13 <lambdabot> http://citeseer.ist.psu.edu/58881.html
04:47:13 <lambdabot> Title: Benchmarking Spatial Joins - CiteSeerX
04:47:19 <vixey> I give up
04:47:26 <Megzlna> Maybe too many papers reference it
04:47:41 <vixey> I know you don't have to pay to read it anyway
04:47:47 * vixey &
04:48:09 <Zao> vixey: http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf
04:48:19 <Peaker> Samy: I think it conflates polymoprhism, datatype extension, namespace mangling and ADT's into one complicated primitive that does all of its jobs poorly
04:48:24 <roderyk> if my gtk2hs app exits with "<<loop>>" that means the main's timeoutAdds all finished and there was nothing left to do, yes?
04:48:47 <Megzlna> so I ask a simple question about an OO feature which would be very easy for you to say NO!! but, I really am curious on why you oppose it:
04:48:48 <Peaker> Samy: instead of having separate namespaces (which most OO languages have anyway), separate ADT's (Only in FP's, mostly), separate polymorphism declarations (instances, mostly FP's)
04:49:24 <Peaker> Megzlna: which OO feature? Namespace mangling of everything that deals with a certain type?
04:49:33 <Peaker> Megzlna: s/everything/everything written by the same author
04:49:56 <Megzlna> What reasons do you have against allowing sub-module Namespaces which namespace-away classes of functions which work on a particular value type?  MyModule.MyTypeNamespace.f
04:49:57 <Megzlna> ?
04:50:06 <Saizan> Samy: split-objs are supported in ghc, cabal has --enable-split-objs, i'm not sure why it's not the default
04:50:10 <Megzlna> Why would that possibly be bad in haskell
04:50:18 <Peaker> Megzlna: we have sub-modules already, which are also namespaces
04:50:21 <Samy> Saizan, I'm talking about dynamic linking
04:50:27 <Megzlna> Peaker: oh?
04:50:29 <Peaker> Megzlna: MyModule.MySubModule.HereAreSomeNames
04:50:43 <Deewiant> Saizan: split-objs on Windows means 10000% compile time increase :-P
04:50:46 <Megzlna> Peaker: but not on the file system, right?
04:51:04 <Peaker> Megzlna: its a separate file in ghc, but obviously a different implementation could allow different layouts
04:51:08 <Megzlna> Peaker: if it's not too much work, would you hpaste me an example of 2 modules in 1 file, namespacing away functions?
04:51:17 <Peaker> Megzlna: why do they have to be in 1 file?
04:51:18 <Samy> Anyone here work on graph display/layout problems?
04:51:45 <Megzlna> Peaker: If they aren't in 1 file, then you are imposing this teutonical FS hierarchy which is sadistic to maintain
04:51:47 <Saizan> Deewiant: yeah, on linux too probably
04:51:54 <Saizan> we have crappy linkers
04:52:00 <Peaker> Megzlna: I disagree, I prefer it that way
04:52:01 <Megzlna> It's too hardcore
04:52:10 <Samy> Aha, I found the survey I was looking for.
04:52:12 <Megzlna> Well, I don't like the filesystem
04:52:19 <Peaker> Megzlna: I like 1 namespace == 1 file
04:52:24 <Megzlna> Ok, but
04:52:24 <Deewiant> Saizan: I was thinking mainly of having to spawn many more processes
04:52:30 <Megzlna> can Haskell do as I asked?
04:52:36 <roderyk> http://hpaste.org/12963  Can someone take a peek at this? Instead of looping over the list (this skeleton code doesn't handle empty lists, but this one doesn't even get that far), it exits after the first iteration with "<<loop>>". Any ideas?
04:52:36 <Peaker> Megzlna: Yes, but not ghc
04:52:40 <Megzlna> argh
04:52:45 <Deewiant> Haskell supports multiple modules per file... for some reason GHC doesn't
04:52:54 <Peaker> Megzlna: for example, a trivial front-end to ghc could split a file into multiple files based on "module Blah where" declarations
04:52:59 <vixey> @remember <Megzlna> It's too hardcore
04:52:59 <lambdabot> It is stored.
04:53:33 <Peaker> Megzlna: they'd still have to explicitly import stuff between their namespaces, as they are separate namespaces
04:53:51 <Megzlna> By too hardcore, I mean I kinda wanna relax a little bit ... module MyMonsters; .. put some good stuff in there
04:53:51 <gal_bolle> this really is a convention i guess
04:53:57 <Megzlna> rather than get all filesystem obsessive
04:54:16 <Peaker> Megzlna: splitting your code into files is not exactly a radical new approach to programming
04:54:25 <Megzlna> in C++ it is
04:54:34 <gal_bolle> Peaker: you could want the splitting to be freeform
04:55:02 <Peaker> gal_bolle: Yes, you can pretty easily.  I think freeform comes at a cost, and it has to justify it. I don't think it does at all here
04:55:27 <vixey> You wont be the first to write a preprocessor that chops and changes about with files to please haskell setup
04:55:37 <Megzlna> You're assuming that individual value types and such will be absolutely used for what they're intended, rather than various perversions and nested usages
04:55:44 <Megzlna> You're thinking
04:55:50 <Megzlna> module Bear
04:55:57 <gal_bolle> i think "no module shared between two files, submodule at lib" would be a better compromise
04:55:59 <Megzlna> module Canvas
04:56:03 <Peaker> Megzlna: I prefer use over perversion, but other than that, I am not sure what you're talking about
04:56:20 <Megzlna> Peaker, good code can't avoid the smaller uses
04:56:29 <Peaker> gal_bolle: the more freeform you have, the less assumptions the reader is allowed to make
04:56:33 <Megzlna> you need types for other stuff besides the highest level constructs
04:56:46 <Megzlna> types are used for implementations
04:56:53 <Megzlna> nested types
04:56:58 <Peaker> Megzlna: example required "perversion"?
04:57:23 <chessguy_work> @pl \f (x,y) -> (f x, f y)
04:57:23 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
04:57:29 <chessguy_work> @yow
04:57:29 <lambdabot> Loni Anderson's hair should be LEGALIZED!!
04:57:32 <gal_bolle> extreme example of bad form: module shared between a version controlled file and a non-vced one
04:58:02 <Megzlna> Peaker: You've got module Foo, and Foo is also a type... inside Foo, it makes use of 15 little types and a few typeclasses to do its work and make haskell useful
04:58:14 <Peaker> @type join (***)
04:58:15 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
04:58:25 <Peaker> chessguy_work: ^^
04:58:33 <Megzlna> However, you still want those smaller types to have automatic namespacing
04:58:54 <roderyk> oops, figured it out. was using readMVar instead of takeMVar...
04:59:05 <chessguy_work> > join (*) (1,2) (3,4)
04:59:06 <lambdabot>   Couldn't match expected type `t -> t1'
04:59:17 <gal_bolle> megzina: in that case you start the UpperLevel file with import UpperLevel.Foo
04:59:23 <chessguy_work> err
04:59:34 <Peaker> > join (***) (*5) (1,2)
04:59:35 <lambdabot>   (5,10)
04:59:37 <Megzlna> gal_bolle: NOT more files
04:59:45 <chessguy_work> oh, yeah, i had the wrong type signature in mind
04:59:46 <wli> My console app exits immediately regardless of input or output.
04:59:47 <dcoutts> roderyk: if you get <<loop>> it is because ghc detected infinite recursion in your prog
04:59:53 <Megzlna> I was giving a reason why you dont want a file per type
05:00:08 <dcoutts> Saizan: --enable-split-objs is slower and goes wrong on too many systems
05:00:09 <chessguy_work> @pl \f (v,w) (x,y) -> (f v x, f w y)
05:00:09 <Zao> dcoutts: Entering a thunk that's already being evaluated or something?
05:00:10 <lambdabot> (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . (flip =<< (((.) . flip . (((.) . (,)) .)) .))
05:00:12 <gal_bolle> and i was explaining why this reason does not hold
05:00:15 <roderyk> dcoutts: ah, thanks. That's good to know
05:00:16 * ksf utterly dislikes the usage of the term "Event" to describe a whole event stream
05:00:17 <vixey> Megzlna, ... so write a script that preprocesses your files like I said
05:00:20 <Peaker> Megzlna: I don't understand your example.  What's the problem? You have Foo with 15 types and typeclasses
05:00:22 <gal_bolle> and how you can do the same with several files
05:00:28 <Peaker> Megzlna: where is the Foo type?
05:00:33 <Saizan> dcoutts: ah, thanks
05:00:34 <Peaker> Megzlna: inside the Foo module or not?
05:00:38 <vixey> Megzlna, just because $language has $restriction doesn't mean *you* are stuck
05:00:40 <matveev> hello, if I have a list of lists  http://en.wikipedia.org/wiki/Special:Search?go=Go&search=1,2],[3,4 how do I form "cartesian product" [ [1,3], [2,3], [1,4], [2,4] ] in general case of any dimension and length?
05:00:51 <Megzlna> Peaker: because you advocated <Peaker> Megzlna: I like 1 namespace == 1 file
05:00:58 <Deewiant> ?ty flip $ \(a,b) -> ($a) &&& ($b)
05:01:00 <lambdabot> forall a b. (a -> b) -> (a, a) -> (b, b)
05:01:05 <Deewiant> chessguy_work: ^^
05:01:07 <vixey> matveev, I think that's impossible, what type would it have?
05:01:12 <dcoutts> Saizan: if we were more confident that it worked reliably then we could enable it. It needs wider testing on more arches or people will just blame cabal :-)
05:01:15 <Peaker> > sequence [ [1,3], [2,3], [1,4], [2,4] ]
05:01:16 <lambdabot>   [[1,2,1,2],[1,2,1,4],[1,2,4,2],[1,2,4,4],[1,3,1,2],[1,3,1,4],[1,3,4,2],[1,3...
05:01:23 <Peaker> matveev: like that ^^ ?
05:01:27 <dcoutts> Zao: yes, something like that
05:01:30 <Megzlna> but who says that those smaller types should not have qualified names?
05:01:49 <Peaker> Megzlna: Where's the contradiction?
05:01:58 <vixey> oh right
05:02:02 <Peaker> Megzlna: import qualified Foo ;  Foo.Silly1 through Foo.Silly15
05:02:09 * ksf thinks "Event" should be renamed to "Wyrd"
05:02:16 <matveev> > sequnece [ [1,2], [3,4] ]
05:02:17 <dcoutts> Saizan: it gets used during ghc bootstrap so we know it works at least a bit but a lot of people use a ghc binary and then use a different incompatible gcc version.
05:02:17 <lambdabot>   Not in scope: `sequnece'
05:02:26 <matveev> > sequenece [ [1,2], [3,4] ]
05:02:27 <lambdabot>   Not in scope: `sequenece'
05:02:36 <Peaker> matveev: 3 times = ice cream
05:02:42 <matveev> > sequence [ [1,2], [3,4] ]
05:02:44 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
05:03:36 <Peaker> Megzlna: you want to "import qualified Foo" and have a type named "Foo" in the *same* module? that's the thing?
05:03:50 <Megzlna> That's one
05:03:51 <Saizan> dcoutts: yeah, i'm probably doing that too here, also compile time on my older machine is already pretty long as it is..
05:04:00 <Peaker> Megzlna: that's not interesting, just rename the qualified import
05:04:08 <Peaker> Megzlna: import qualified Foo as FooModule
05:04:14 * wli tries to remember how to deal with console apps vs. visual studio.
05:04:16 <Megzlna> but I was asking about something different:
05:04:41 <Megzlna> import HumptyDumpty
05:04:52 <Megzlna> humpty and dumpty functions in separate namespaces
05:05:01 <SamB_XP> import AllTheKingsHorses
05:05:10 <SamB_XP> import AllTheKingsMen
05:05:23 <Peaker> BeelsebobWork: only now I got the pong compiled, heh
05:05:28 <matveev> Peaker:  seems to be what I want, why does it have such a strange name "sequence"?
05:05:46 <Peaker> matveev: its a general function for all monads, and in this case it applies to the list monad
05:05:52 <dcoutts> Saizan: it's actually the linker time that increases most
05:06:19 <dcoutts> Saizan: and it's only really worth it with huge libs. Shared libs will make it obsolete.
05:06:46 <Megzlna> the globalness of haskell names must make GUI libs in haskell really, really tough
05:06:47 <Peaker> @type sequence
05:06:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:06:59 <Peaker> Megzlna: names are never global in Haskell, they're always inside a module
05:07:28 <Megzlna> peaker: sure, but:
05:07:29 <Peaker> matveev: sequence applies the list of "actions" in order.  Treating lists as actions is basically "trying" all of the list items with the rest of the computation
05:07:35 <Megzlna> do { UndecoratedButton.press(b);
05:07:37 <Megzlna> vs:
05:07:47 <Megzlna> do { b.press
05:07:57 <Megzlna> *b already contains the namespace*
05:08:05 <Megzlna> you dont need to know more
05:08:07 <Peaker> Megzlna: that's not a good thing
05:08:09 <Peaker> Megzlna: More likely:  Button.press b
05:08:28 <Peaker> Megzlna: as opposed to: MetalTool.press b
05:08:49 <Peaker> Megzlna: where Button.press is a "press" method inside some type-class
05:08:58 <Megzlna> but b is a button. So why not forget which module the function is in?
05:09:15 <Peaker> Megzlna: or the above could be:  import ButtonClasses(Button(..)) ; use Button's typeclass methods freely
05:09:32 <matveev> Peaker: thanks, I'll think on it.
05:09:33 <Peaker> Megzlna: because that makes button processors not written by the toolkit author 2nd class citizens?
05:09:34 <Megzlna> And does that work with scope?
05:09:45 * ksf needs to find out whether or not Event ~= Wyrd and Behaviour ~= Norn
05:10:00 <Peaker> Megzlna: if I write a function that presses the button 3 times, it will be:  MyModule.press3(b), and not b.press3() right?
05:10:01 <Saizan> dcoutts: disabling split-objs during the ghc build can reduce linking time later?
05:10:21 <matveev> an while I am at it, is there is any built-in that for maps over Data.Tree?
05:10:27 <Megzlna> do { let { press = Button.press } in ...
05:10:37 <Beelsebob> matveev: fmap
05:10:38 <Megzlna> you cannot apply imports to a scope
05:10:39 <Beelsebob> as with all functors
05:10:54 <Peaker> Megzlna: so A) You have 2 different namespace mechanisms instead of 1  B) The OO-namespace mechanism is prone for clashes because you share the same namespace with different authors!  C) You outcast non-class authors as 2nd class citizens
05:11:33 <dcoutts> Saizan: a bit, but mainly it substantially reduced linking time while building the lib itself
05:11:34 <Peaker> Megzlna: suppose you inherit Button, and add a blah method() who's to say that "blah" won't clash with a new public method of Button in the future?
05:11:58 <Peaker> Megzlna: and do you not find the asymmetry between MyModule.press3(b) and b.press() ugly?
05:12:03 <dcoutts> Saizan: the downside of course is that without splitobjs you get very large binaries, esp if you don't use it for base and the other core libs
05:12:22 <chessguy_work> matveev, what do you mean by "maps over Data.Tree"?
05:12:42 <Peaker> Megzlna: I can't think of a way in which the single-namespace-mechanism used by Haskell is not superior to the OO namespace mechanism
05:13:04 <matveev> fmap seems to work, where is Functor Tree instance hidden? Not in Data.Tree at least...
05:13:06 <Megzlna> Peaker: by single namespace mechanism, you mean Modules?
05:13:09 <Peaker> Megzlna: Well I guess if you don't have hoogle, that kind of namespacing is a good approximation
05:13:12 <Peaker> Megzlna: Yes
05:13:29 <Megzlna> And by 2 namespace mechanisms, you mean?
05:13:49 <chessguy_work> matveev, yeah, it's listed as an instance of Functor on http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Tree.html but i'm not sure where the source is
05:13:54 <Megzlna> class vs module?
05:14:34 <byorgey> matveev: it's not?
05:14:40 <quicksilver> matveev: http://www.haskell.org/ghc/dist/current/docs/libraries/containers/src/Data-Tree.html
05:14:41 <Peaker> Megzlna: yes
05:14:54 <Peaker> Megzlna: or in the C++ case, class vs namespace
05:15:16 <matveev> right, sorry. It is there (Functor Tree in Data.Tree)
05:15:18 <Megzlna> they're really the same. Namespace is a class without a this pointer
05:16:28 <Megzlna> because you use the same keywords to work with both
05:16:33 <Megzlna> the 'using' declaration
05:16:48 <Megzlna> using BaseClass::f;
05:17:05 <Peaker> Megzlna: no, they're not the same.  Modules are written by different authors. In-module nameclash is not considered a problem, inter-module clash is.  Classes are written by different authors, yet they are in the same namespace!
05:17:36 <Peaker> Megzlna: ideally, you want the different authors/projects to sit in their own namespaces, because these are the entities that clash. In the class-based namespace, the division of namespaces makes no sense
05:17:55 <Peaker> Megzlna: and different authors share the same namespace, despite having no way to communicate to avoid clashing
05:18:30 <Megzlna> but who says my two types in 1 module shouldn't each be allowed a "go" function?
05:18:44 <Megzlna> or some other "common jargon you're using in implementations"
05:18:57 <Megzlna> You have 1 module.
05:18:57 <Peaker> Megzlna: "go" can't be two different things at the same time
05:19:23 <lilac> Peaker: why not?
05:19:36 <Peaker> (in the same namespace)
05:19:45 <quicksilver> well you need some way to manage the clash, at least.
05:19:46 <lilac> ad-hoc overloading doesn't work well with Hindley-Milner, but it can work in other type systems
05:20:01 <Megzlna> The 1 module has a bunch of mini stuff used to implement it, but the programmer doesnt want to have to think up overly creative names for each implementation bits functions
05:20:06 <Megzlna> they have some commonality
05:20:08 <Megzlna> so you say:
05:20:13 <Megzlna> Make a Typeclass Goable
05:20:15 <Peaker> lilac: I don't consider overloading "go" to make it 2 different things, its 1 "thing" (a method) with 2 implementations
05:20:22 <lilac> ... actually, i wonder how far one could get with HM plus union types
05:20:28 <Peaker> Megzlna: Type-classes are beside the point here
05:20:34 <lilac> Peaker: even if they have completely different semantics and authors?
05:20:43 <Peaker> Megzlna: Type classes don't have much to do with namespaces in Haskell
05:20:46 <saml> who wrote http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html   ?   because it's awesome!!
05:20:48 <Megzlna> lilac: well, we are assuming 1 module
05:20:57 <Peaker> lilac: They can't (shouldn't) have different semantics if they're the same method
05:21:16 <Megzlna> Peaker: I know they dont, but I was saying you might say to solve the clash there by using a typeclass to make Go overload
05:21:18 <lilac> Peaker: that's an opinion, and not one shared by everyone
05:21:42 <Peaker> Megzlna: First, lets agree that namespaces are supposed (among other things) to avoid clashes between names of different authors, right?
05:21:54 <Megzlna> disagree
05:21:59 <vixey> I don't agree with that either :p
05:22:05 <Peaker> Megzlna: then how do you avoid these clashes?
05:22:05 <Megzlna> I always do:
05:22:20 <Megzlna> namespace impl {
05:22:25 <Megzlna> etc
05:22:36 <saml> @hoogle (.|.)
05:22:37 <lambdabot> Data.Bits (.|.) :: Bits a => a -> a -> a
05:22:45 <Megzlna> An unexported section of a module is a "impl" namespace
05:22:55 <Peaker> Megzlna: if 2 different authors name their function in the same way (accidentally), do you want them to clash?
05:22:56 <Megzlna> And in that case, a Haskell person might therefore argue its USEFUL!
05:23:06 <quicksilver> Megzlna: but that is exactly what peaker just said?
05:23:13 <quicksilver> Megzlna: (using a namespace to avoid a clash)
05:23:21 <quicksilver> you just used the "namespace impl" to avoid a clash.
05:23:53 <lilac> Peaker: i think the "different authors" part is a red herring. "different semantics" is closer to the mark i think
05:24:33 <Megzlna> Peaker: No, I don't want them to clash
05:24:34 <Peaker> lilac: "authors" is not precise.  Perhaps "entity with internal-clash resolution mechanism" might be more accurate
05:24:53 <Peaker> lilac: which is why I think it makes sense to have module=namespace, is because a module is definitely written by such an entity
05:25:11 <Peaker> Megzlna: right - and in a class-based namespace, do you agree that they can clash?
05:25:15 <Megzlna> I am disagreeing here because I am 1 author and still want namespaces inside of modules
05:25:53 <Megzlna> can Haskell modules have a private nonexported section?
05:26:01 <gal_bolle> sure they can
05:26:06 <Megzlna> That's a sub namespace
05:26:06 <Peaker> Megzlna: The QObject base-class in Qt 4.1 gets a new "activation_count" or whatever name for some QObject mechinsm.  my class is 5 inheritence levels below it had activation_count that means something else, will they not clash?
05:26:12 <Megzlna> Just a non-generalized solution
05:26:14 <gal_bolle> module (exported) where stuff
05:26:18 <lilac> Megzlna: no, it's the same namespace
05:26:26 <Megzlna> it only allows for One predetermined usage
05:26:28 <gal_bolle> all that's not explicitly in exported is private
05:26:35 <Megzlna> lilac: But, it's (same namespace).private
05:26:58 <lilac> Megzlna: from the implementation point of view, its the same space from which names are allocated
05:27:07 <Megzlna> Yes
05:27:18 <Peaker> Megzlna: no, because (same namespace).x would clash with (same namespace).private.x
05:27:20 <lilac> Megzlna: that is, I can't have (namespace).foo /and/ (namespace).private.foo
05:27:25 <vixey> can I poll about syntax for a language that doesn't exist yet
05:27:28 <Megzlna> yes Peaker
05:27:35 <chessguy_work> is there an easy way to tell, for a given package on hackage, what other packages on hackage depend on it?
05:27:46 <Megzlna> It's a different namespace on the outside though
05:27:52 <vixey> would it be good to allow definitions like  infix o  which turns the string 'o' into a symbol
05:27:55 <Peaker> Megzlna: do you agree that class-based namespaces have a clashing problem between 2 different authors, and therefore do not solve one of the problems namespaces need to solve?
05:27:58 <Megzlna> So why not generalize that
05:28:08 <Megzlna> "private" is 1 usage out of 100
05:28:23 <lilac> Megzlna: whether it's the "same" depends on how you define namespace
05:28:43 <Ferdirand> vixey: how would "infix infix" react then ?
05:28:43 <Peaker> Megzlna: a "sub-namespace" is really a separate namespace, there's nothing about it that makes it "sub" of the "parent"
05:28:45 <vixey> I'm just wondering if that would be annoying like there is two choices if you do that
05:29:02 <vixey> x+y parses as the name "x+y", or x+y parses as "x" + "y"
05:29:02 <Peaker> Megzlna: except for a name
05:29:03 <lilac> Peaker: not necessarily. it's common for a 'sub-namespace' to implicitly import the parent namespace
05:29:12 <Samy> In graph theory, what is the formal term for edges that cross/overlap each other?
05:29:24 <Peaker> lilac: I mean Haskell's  Blah.SubModule namespace
05:29:38 <lilac> Peaker: yes, but Megzlna meant in the sense of C++ namespaces
05:29:41 <vixey> Samy, that sounds more like topology
05:29:43 <arw> Samy: there is such a thing?
05:29:47 <maltem> Samy: there are planar and non-planar graphs, maybe that's what you're after?
05:29:51 <quicksilver> Samy: in graph theory edges are abstract and never cross
05:30:00 * Samy is obviously clueless
05:30:07 <lilac> Megzlna: as far as I can see, the feature sets of Haskell modules and C++ namespaces are completely equivalent
05:30:09 <quicksilver> Samy: only in a two-dimensional embedding of a graph, can you observe if they cross.
05:30:17 <arw> Samy: graph theory does not assume any particular layout of a graph, its just nodes and edges, no matter how you place them.
05:30:18 <Peaker> lilac: ah. Well, that's a possible feature, I personally don't think it would be a good one
05:30:20 <Samy> Yes, I guess "planar graphs" is what I'm after.
05:30:22 <quicksilver> Samy: and then there is a choice of embedding :)
05:30:24 <Megzlna> I think the only real argument here, is the argument about whether you like filesystems or 4 modules in 1 file, because the usefulness of submodules A.B.C.X has already been proven since GHC does support that in a filesystem manner
05:30:29 <vixey> Ferdirand, should be fine
05:30:43 <dolio> vixey: Agda would be slightly nicer if it worked that way.
05:30:43 <papermachine> You can observe is graphs are planar or non-planar
05:30:50 <vixey> dolio, which way?
05:30:51 <Megzlna> so the subbing is useful, except someone on GHC thinks I should not be allowed it in my single files.
05:30:56 <quicksilver> Megzlna: although they're not really submodules in a very interesting way.
05:31:01 <Peaker> Megzlna: liking file-based division and liking the "file system" are 2 different things
05:31:09 <Samy> http://www.ti.inf.ethz.ch/ew/courses/GT05/lectures/PDF/lecture1f.pdf is nice.
05:31:11 <dolio> vixey: If declaring [_] as an operator of some kind meant you could write "[a]" instead of "[ a ]"
05:31:11 <papermachine> By a theory of Kuratowski, a graph is non-planar iff it has K_5 or the bipartite graph on six nodes is a subgraph
05:31:15 <quicksilver> Megzlna: they're only submodules in the same sense that "foobar" is a sub-variable of "foo"
05:31:21 <Peaker> Megzlna: but you've completely avoided my argument about class-based namespaces being completely inadequate
05:31:28 <Megzlna> Yes I understand that Foo.Bar is only a string
05:31:35 <Peaker> Megzlna: and they are a completely separate mechanism from C++'s "namespace" clauses
05:31:46 <Megzlna> FooDOTBar
05:32:09 <vixey> ok but I'm wondering if it would be awkward say you defined infix o then you wrote  z + g you  it may parse like  (z + g y) o u
05:32:15 <lilac> papermachine: ... (then some magic happens) ... and hence any planar map is four-colourable
05:32:32 <vixey> maybe this is a non-problem though, because why would someone define o as an operator then be all annoyed about it being an operator...
05:32:53 <dolio> Oh. That is pretty insidious.
05:33:18 <Peaker> Megzlna: so C++ has one namespace mechanism which is adequate and 1 which isn't, but you don't get to choose which one you use, you're forced into using the inadequate one to extend others' code
05:33:28 <vixey> wiffle --> parse error expected _then_
05:33:32 <quicksilver> Megzlna: I've also wondered if Modules within a file would be nice.
05:33:41 <quicksilver> Megzlna: so far I've never *strongly* wanted it.
05:33:48 <vixey> so I can't really decide
05:33:55 <quicksilver> Megzlna: (the module/file mapping is a GHC choice, the haskell standard doesn't say anything about it)
05:33:58 <Peaker> quicksilver: I want to get rid of "module Blah where" because we already have the file name...
05:34:10 <Peaker> quicksilver: but I like 1 module = 1 file
05:34:10 <vixey> and the third option is like haskell, predetermine alphabetic/symbolic characters
05:34:16 <lilac> quicksilver: doesn't that lead to practical problems, when GHC is looking for the defintion of a module, though?
05:34:35 <quicksilver> lilac: yes. But practical problems can be resolved.
05:34:43 <quicksilver> lilac: I don't have a formal suggestion.
05:34:52 <quicksilver> I'm just remarking that I have also wondered about this.
05:35:00 <dolio> vixey: Yeah. I'm not sure I'd want it breaking up words. Although, I probably wouldn't be using single alphabetic characters as operators in the first place.
05:35:26 <vixey> dolio, the if_then_else_ and case_of_ definitions are what makes me worried though
05:35:28 <lilac> quicksilver: i guess a more interesting question would be, (why) did you want it? :)
05:35:48 <vixey> It's a kind of tricky thing
05:35:49 <Peaker> lilac: his C-x C-f key binding is too far away
05:35:52 <quicksilver> lilac: because needing Foo.hs and Foo/Internals.hs to be separate files is mildly annoying.
05:36:02 <quicksilver> lilac: not a big deal, but mildly annoying.
05:36:23 <Peaker> quicksilver: why not just export only a subset, and keep them 1?
05:36:34 <quicksilver> because Bar.hs needs Foo/Internals.hs
05:37:10 <quicksilver> Foo provides the 'truly public' interface whilst Foo.Internals provides the 'semi-private' interface to friends.
05:37:14 <quicksilver> This is a fairly common pattern.
05:37:18 <Peaker> Yeap
05:37:25 <quicksilver> bytestring uses it and so does reactive
05:37:54 <Peaker> When I write C code, I usually have a header that #includes a blah_internal.h header too
05:38:04 <quicksilver> vixey: the annoying thing would be if some library redefined somethign to be an operator, which ffected the parsing of your code even when you didn't use it.
05:38:05 <Peaker> (if there are definitions that can't just sit in the C side)
05:38:05 <fasta> How can I convert 2 to a "0x2"?
05:38:10 <quicksilver> vixey: (because you linked against that library)
05:38:12 <Peaker> @hoogle hex
05:38:13 <lambdabot> Text.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
05:38:13 <lambdabot> Text.ParserCombinators.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
05:38:13 <lambdabot> Text.Parsec.Char hexDigit :: Stream s m Char => ParsecT s u m Char
05:38:13 <quicksilver> > showHex 2 ""
05:38:14 <lambdabot>   "2"
05:38:21 <quicksilver> > showHex 155 ""
05:38:21 <fasta> quicksilver: already tried that :)
05:38:22 <lambdabot>   "9b"
05:38:25 <vixey> that wont happen
05:38:29 <quicksilver> > "0x" ++ showHex 155 ""
05:38:30 <lambdabot>   "0x9b"
05:38:31 <fasta> Ok, so you just need to ad the stuff
05:38:35 <fasta> add*
05:38:36 <vixey> ("0x"++) . flip showHex ""
05:38:42 <fasta> Kind of inconsistent.
05:38:48 <Peaker> fasta: with what?
05:38:49 <quicksilver> yes.
05:38:57 <fasta> > readHex "0x2"
05:38:58 <lambdabot>   [(0,"x2")]
05:39:05 <vixey> lol
05:39:09 <fasta> Or not
05:39:09 <quicksilver> it's not inconsistent with readHex
05:39:12 <vixey> > readHex "9b
05:39:13 <vixey> > readHex "9b"
05:39:13 <lambdabot>   <no location info>:
05:39:13 <lambdabot>      lexical error in string/character literal at chara...
05:39:14 <lambdabot>   [(155,"")]
05:39:17 <quicksilver> but it is inconsistent with what show/read normaly mean
05:39:31 <fasta> Ok, so it's consistent, but just odd.
05:39:57 <Peaker> quicksilver: showBlah usually is ShowS rather than String, or is that not what you mean?
05:40:11 <Peaker> @type (showString, showHex)
05:40:12 <lambdabot> forall a. (Integral a) => (String -> String -> String, a -> String -> String)
05:40:31 <Saizan> i prefer adding "0x" when i need, rather than having to remove it when i don't want it
05:40:37 <Peaker> quicksilver: or do you mean being consistent with Haskell syntax?
05:41:38 <quicksilver> > read "0x80" :: Int
05:41:39 <lambdabot>   128
05:41:42 <Megzlna> Haskell feels C like in this respect, and C's way was traumatic
05:41:55 <quicksilver> Peaker: showHex might be expected to produce somethign that 'read' could read.
05:42:04 <SamB_XP> Megzlna: traumatic ?
05:42:07 <quicksilver> Peaker: it sounds like it might just be a variation on 'show'
05:42:22 <quicksilver> (show but force the output to hex format, since either is equally acceptable)
05:42:25 <Samy> > readHex "ff"
05:42:27 <lambdabot>   [(255,"")]
05:42:34 <quicksilver> however, it isn't.
05:42:34 <Peaker> quicksilver: yeah, indeed
05:42:40 <quicksilver> but that is a possible way to interpret the name :)
05:42:42 <Samy> > readHex "ffffffffffffffff"
05:42:44 <lambdabot>   [(18446744073709551615,"")]
05:42:49 <Samy> > readHex "ffffffffffffffffffff"
05:42:51 <lambdabot>   [(1208925819614629174706175,"")]
05:42:55 <Peaker> it should probably prefix with 0x for those reasons
05:42:55 <Samy> :t readHex
05:42:57 <SamB_XP> I agree that the name leaves something to be desired
05:42:57 <lambdabot> forall a. (Num a) => String -> [(a, String)]
05:43:06 <quicksilver> > readHex "fffffffffffffffffffffffffffffffffffffffffffffffffff"
05:43:08 <lambdabot>   [(25711008708143844408671393477458601640355247900524685364822015,"")]
05:43:14 <quicksilver> it's a mersenne prime!
05:43:21 <quicksilver> OMG I'm going to be rich.
05:43:24 <Samy> haha
05:44:07 <quicksilver> > readHex (replicate 666 'f')
05:44:08 <lambdabot>   [(8788372346144463110347539719818274902841212762151287254420324761787734167...
05:44:25 <SamB_XP> the hex of the beast ?
05:44:47 <byorgey> quicksilver: it, uh, ends with 5?  =)
05:44:54 <vixey> anyone know of   parsing infix operators with correctness proofs?
05:45:21 <SamB_XP> "   " ?
05:45:32 <quicksilver> byorgey: I wasn't speaking entirely seriously ;)
05:45:34 <vixey> (and pretty prninting)
05:45:37 <byorgey> I know =)
05:46:05 <quicksilver> vixey: correctness proofs? Is parsing infix operators hard enough to need a proof?
05:46:09 <Megzlna> So, you guys want to group types and any function which is constrained to that type, into 1 module?
05:46:10 <matveev> labdabot: help oesis
05:46:15 <matveev> lambdabot: help oesis
05:46:25 <quicksilver> Megzlna: no, typically not.
05:46:31 <Megzlna> quicksilver: how?
05:46:34 <quicksilver> Megzlna: I think the suggestion was that that was the C++ way.
05:46:36 <Megzlna> That's the most popular haskell way
05:46:38 <matveev> >oesis [1,1,2,5,12,34,92,277,806,2500,7578,24198,75370,243800,776494]
05:46:42 <quicksilver> (to group all functions with a type)
05:46:45 <Megzlna> S/That/What
05:46:49 <Megzlna>  ?
05:46:51 <vixey> quicksilver yes
05:46:54 <quicksilver> it varies, I think.
05:47:06 <quicksilver> It generally makes sense to group the basic functions with the type.
05:47:08 <byorgey> @oeis [1,1,2,5,12,34,92,277,806,2500,7578,24198,75370,243800,776494]
05:47:08 <Megzlna> I'll stop assuming the Haskell way is wrong
05:47:08 <lambdabot>  Sequence not found.
05:47:16 <Megzlna> but I need some sense of what that Haskell way is
05:47:17 <quicksilver> It often makes sense to put a small number of related types in one module
05:47:26 <quicksilver> and all the functions that relate them.
05:47:32 <byorgey> matveev: I think @oeis is what you're looking for
05:47:32 <quicksilver> Haskell modules are a pretty weak structure.
05:47:42 <quicksilver> They give you a lot of freedom in how you arrange stuff.
05:47:45 <quicksilver> (which is good and bad)
05:47:57 <matveev> byorgey: thanks!
05:48:16 <Megzlna> quicksilver: When you put some related types inside a module, are you saying related so long as there's never a foo_f and a bar_f ?
05:48:29 <nolrai_East> So I have a problem with exesive strictness, could someone look at my hpaste?
05:48:50 <matveev> do I generate all possible reduction strategies for (>1)-ary operation correctly here: http://hpaste.org/12966
05:49:02 <quicksilver> Megzlna: well that's certainly a possible conflict, yes.
05:49:14 <quicksilver> I don't normally think of functions as 'belonging' to types
05:49:27 <quicksilver> I think of them as 'belonging' to a particular module (in the wider sense) or subsystem of a program.
05:49:30 <quicksilver> (or library)
05:49:39 <matveev> e.g.: map showStars $ trees 4 = ["(((**)*)*)","((***)*)","((**)(**))","((**)**)","(****)"]
05:50:08 <vixey> matveev, what's a reduction strategy?
05:50:26 <Megzlna> quicksilver: It "belongs" as far as it's a dependency and thus tight bound
05:50:52 <matveev> vixey: a+b+c+d = (((a+b)+c)+d) or (a+b)+(c+d)
05:50:59 <vixey> matveev, ?
05:51:04 <vixey> matveev, no definition?
05:51:42 <vixey> matveev, so you have N-ary operations and you want to change them into Binary?
05:51:46 <byorgey> matveev: if those were the numbers you were getting [1,1,2,5,12,34...] then no, you're not generating all of them =)
05:51:51 <quicksilver> Megzlna: yeah, that is definitely sometimes true.
05:51:55 <Megzlna> re: Namespace talk
05:51:56 <quicksilver> Megzlna: it's just not always true.
05:52:00 <byorgey> vixey: I think matveev means a bracketing
05:52:00 <Megzlna> we're on #Haskell-overflow now
05:52:11 <quicksilver> Megzlna: when it is true, I would do it that way as you suggest.
05:52:13 <Megzlna> i overstayed my namespace
05:52:15 <byorgey> vixey: i.e. how many ways are there to parenthesize a*b*c*d ?
05:52:18 <quicksilver> ;)
05:52:25 <quicksilver> HELP I ACCIDENTALLY THE WHOLE NAMESPACE
05:52:32 <byorgey> matveev: the 12 should be a 14...
05:52:32 <vixey> byorgey, well I'm hoping they will answer but ..
05:52:45 <SamB_XP> accidentally *what* the whole namespace ?
05:53:43 <Peaker> byorgey: meaningfully-different ways?  I'd expect 4! because there are 4 operations and you can order them in any way you'd like?
05:53:45 <matveev> what is missing then?: "((((**)*)*)*)","(((***)*)*)","(((**)(**))*)","(((**)**)*)","((****)*)","(((**)*)(**))","((***)(**))","(((**)*)**)","((***)**)","((**)(**)*)","((**)***)","(*****)"
05:54:00 <vixey> matveev, I don't even know what you'er doing
05:54:01 <Peaker> oh wait, no
05:54:03 <vixey> matveev, so you have N-ary operations and you want to change them into Binary?
05:54:07 <EvilTerran> quicksilver, is this dangerous?
05:54:39 <matveev> vixey: no a have a flexible (N>=2)-ary operation (think of merge-sort)
05:54:49 <vixey> matveev, ok
05:54:53 <byorgey> matveev: oh, hm, wait, a (>1)-ary operation?
05:55:04 <byorgey> never mind, I was thinking binary operation
05:55:25 <byorgey> matveev: what about (***(**)) ?
05:56:06 <byorgey> still, it seems like there should be *at least* as many reduction strategies using a flexible n-ary operation as there are using a binary operation.
05:56:12 <matveev> byorgey: (***(**)) ~ ((**)***) second from the end
05:56:41 <byorgey> matveev: why are those the same?
05:57:23 <vixey> matveev, yeah this is difficult to do without filtering duplicates at the end
05:57:37 <matveev> byorgey: I do not assign real distinguishable jobs to placeholders (*) yet
05:58:15 <byorgey> matveev: that's fine, I still don't understand why ((**)***) and (***(**)) are supposed to be the same
05:58:25 <byorgey> is the operation commutative?
05:58:47 <byorgey> commutative but not associative?
05:59:28 <byorgey> for example if my operation is +, doing ((1+2)+3+4+5) seems different than (1+2+3+(4+5))
05:59:28 <wli> What would it mean for a ternary operation to be associative?
05:59:52 <byorgey> wli: yeah, I'm not sure...
06:00:24 <matveev> byorgey: it is about grouping tasks for parallel machines, so unless I specify the job sizes I care only about non-equivalent strategies
06:03:18 <byorgey> matveev: ok, now I think I understand.  In that case your code looks good to me.
06:04:48 <vixey> well
06:04:56 <vixey> The code does not make it at all clear what the criteria is
06:05:56 <byorgey> nolrai_East: is 'test' supposed to be 'test2'?
06:06:41 <byorgey> nolrai_East: also, I assume there is a Monad instance for Choice somewhere not shown, with  return = Choice . Just . Leaf ?
06:07:30 <jkff> I'm working through an OpenGL tutorial ( http://www.haskell.org/haskellwiki/OpenGLTutorial1 ) and when I launch an example in GHCI by invoking 'main' and then close the example's window, ghci dies too. Is there a way to make it survive? I've tried 'forkIO main' but the problem persists.
06:08:44 <byorgey> jkff: don't launch it from ghci.  compile it and launch it from another terminal.
06:09:28 <jkff> But why not? Why can't I experiment in ghci?
06:09:50 <jkff> Is the reason 'Because it's not implemented'?
06:10:24 <nolrai_East> byorgey: no, test1. and yes
06:13:16 <byorgey> nolrai_East: ah, ok.  yes, the problem is that choiceSum is too strict.  Note that to evaluate the third case, it must evaluate its second argument far enough to see that it's a  (Choice (Just _))
06:13:36 <byorgey> but since the second argument in this case is another call to choiceSum ...
06:15:26 <quicksilver> jkff: because GLUT is evil and wants to own your entire OS processs
06:15:40 <quicksilver> jkff: and doesn't expect to be run merely as a 'one-off trick' from a long running process.
06:15:44 <chessguy_work> is there an easy way to tell, for a given package on hackage, what other packages on hackage depend on it?
06:15:48 <quicksilver> jkff: (and ghci runs client code in itself)
06:16:22 <byorgey> nolrai_East: and yeah, adding an 'Empty' case to LeafyTree, or switching to LeafyTree (Maybe a)  ought to work, I think
06:17:52 <nolrai_East> Thanks!
06:20:40 <chessguy_work> @type let f = const True :: Char -> Bool; g = const False :: Char -> Bool in f . g
06:20:42 <lambdabot>     Couldn't match expected type `Char' against inferred type `Bool'
06:20:42 <lambdabot>       Expected type: Char -> Char
06:20:42 <lambdabot>       Inferred type: Char -> Bool
06:21:25 <chessguy_work> @pl \f g x -> f x && g x
06:21:25 <lambdabot> liftM2 (&&)
06:23:27 <byorgey> chessguy_work: not that I know of
06:23:33 <byorgey> that would be a nice feature, though
06:23:38 <chessguy_work> indeed
06:28:30 * chessguy_work is excited about where his ideas of general patterns are going
06:28:46 <Peaker> chessguy_work: what are general patterns?
06:29:24 <chessguy_work> descriptions of any kind of container that has elements and how they relate to each other
06:30:17 <Peaker> chessguy_work: "container" being a data constructor?
06:30:29 <chessguy_work> i'm thinking about a library that makes constructing those patterns easily
06:30:44 <chessguy_work> Peaker possibly Functor, though i'm not sure yet
06:30:46 <Peaker> chessguy_work: so something like:  f (Left x) (Right x) = ...  demanding that the Left/Right contents are (==) ?
06:31:02 <chessguy_work> peaker not patterns as in pattern-matching
06:31:17 <chessguy_work> at least not pattern-matching in the haskell sense
06:31:36 <chessguy_work> peaker i'm starting from the idea of patterns in board game positions
06:32:01 <chessguy_work> so patterns describe individual squares/pieces and how they relate to each other
06:33:20 <BeelsebobWork> chessguy_work: <^(&&)^> :P
06:33:32 <Peaker> chessguy_work: so by using some pattern-matching syntax, you want to give point-ful syntax to points-free processors like fmap/etc?
06:33:33 <chessguy_work> ...
06:33:57 <chessguy_work> err
06:34:04 <Peaker> chessguy_work: f (Functor x) = Functor (x*2)  -->  fmap (*2)   ?
06:34:40 <chessguy_work> i'm hoping to be able to eventually write something like match :: Functor f => Pattern a -> f a -> [a]
06:35:03 <chessguy_work> or at least  match :: Functor f => Pattern a -> f a -> Bool
06:35:16 <Peaker> chessguy_work: the former seems to be taking something "out of" the functor?
06:35:38 <Peaker> chessguy_work: Oh, so a Pattern is a value you can use..?
06:35:39 <chessguy_work> yes, it 'selects' elements that are matched by the pattern, like capturing in a regex
06:36:32 <Peaker> chessguy_work: you'd need a Traversable or such for that, not Functor (You can't "extract" from a Functor), or you'd need f a -> f Bool or such
06:36:58 <chessguy_work> ok
06:37:14 <chessguy_work> so Functors are inherently one-way, like monads
06:37:26 <Peaker> chessguy_work: yeah, Functors let you do strictly less things than Monads
06:37:37 <Peaker> (so if you can't extract from a Monad, you definitely can't from a Functor)
06:38:08 <chessguy_work> fair enough. i don't have a particular end result in mind yet
06:38:59 <EvilTerran> you can't get values *into* a functor either, in general
06:39:43 <Peaker> EvilTerran: I wondered why you could get stuff into an applicative.. why "pure" and "<*>" are in the same type-class
06:40:37 <EvilTerran> Peaker, yeah, i'd be inclined to make it "class Functor f => Pointed f where { pure :: a -> f a }; class Pointed f => Applicative f where { (<*>) :: ... }"
06:40:39 <dolio> category-extras has a Pointed (or something like that) class which has just pure, but I'm not sure there are a whole lot of useful examples of just that class.
06:40:55 <dolio> Not that there are a lot of haskell examples of just Functors.
06:41:18 <Peaker> EvilTerran: oh, that's what Pointed is?
06:41:46 <chessguy_work> anyway, at the moment i'm basically just trying to decide on a good syntax for what i want
06:41:58 <dolio> Of course, there are also copointed functors (and comonads) that aren't necessarily pointed (but are functors).
06:42:18 <Peaker> dolio: you don't need something to be only that class for it to be a useful class
06:42:36 <Peaker> dolio: you just need instances of that class to not always come with an instance for another class
06:42:47 <Peaker> EvilTerran: I think pure and <*> should not necessarily subclass Functor...
06:42:49 <EvilTerran> "data Pair a = Pair a a" is a functor, but i don't think it could be reasonably pointed
06:43:06 <Peaker> EvilTerran: why not?  pure = join Pair ?
06:43:20 <dolio> Yeah. it's a vector of size 2.
06:43:24 <Peaker> EvilTerran: Applicative subclasses Functor because (pure and <*>) together form fmap
06:43:31 * EvilTerran tries to work out if that would satisfy the fmap/pure laws
06:43:55 <EvilTerran> *law
06:44:08 <byorgey> EvilTerran: sure it would
06:44:17 <EvilTerran> yeah, i guess it fits "forall f x. f <$> pure x = pure (f x)"
06:45:46 <EvilTerran> Peaker, i'd be inclined to arrange them in that heirarchy because i feel it's only appropriate to define laws that must hold between methods of different classes if one entails the other
06:46:31 <redditbot> mapM, mapM_ and monadic statements
06:46:31 <redditbot> HAppS Tutorial Version 5 Released
06:46:35 <EvilTerran> if one class =>s the other class, i mean
06:46:41 <Peaker> EvilTerran: well, you could define "empty" class (no methods) just for law association
06:46:49 <EvilTerran> i guess
06:47:16 <EvilTerran> it seems a bit weird to have "class (Functor f, Pointed f) => PointedFunctor f" with no methods, but i guess it's the most general approach
06:47:21 <Peaker> So, class HasPure f, Functor f => Pointed f where {} -- has laws!
06:49:00 <dolio> Why are we doing that?
06:50:09 <Peaker> dolio: in case we have  "pure"  for a non-functor?
06:51:22 <cygnus_> whats the difference in philosophy between haskell and ocaml
06:51:50 <quicksilver> purity.
06:51:57 <lilac> laziness.
06:52:04 <opqdonut> modules.
06:52:25 <quicksilver> I don't think modules is a big different in philosophy.
06:52:36 <quicksilver> It's just that ML has a complex module system and we don't, yet.
06:52:39 <quicksilver> maybe one day we will.
06:52:46 <quicksilver> purity / laziness are philosophical.
06:52:58 <opqdonut> well ok, but the module system influences high-level design
06:53:15 <opqdonut> but of course it's not as major as those other two points
06:53:44 <quicksilver> I agree it's a huge difference.
06:53:49 <quicksilver> Just not that it's a philosphical one.
06:54:00 <opqdonut> ok :)
06:54:04 <quicksilver> maybe I'm splitting hairs ;) but cygnus_ asked specifically about philosophy.
06:55:19 <lilac> another one is that haskell generally has a solid theoretical (categorical) underpinning
06:55:19 <pejo> quicksilver, I think it's nice that you mention purity first - because it's a great philosophy.
06:55:50 <quicksilver> lilac: ML shares much of that underpinning.
06:55:59 <quicksilver> they just conveniently forget about it for impurity ;)
06:56:08 <opqdonut> :)
06:56:13 <quicksilver> ML was envisioned as a computer version of System F, wasn't it?
06:56:32 <quicksilver> and System F is certainly a theoretical underpinnning.
06:59:11 <ozy`> who was it who made a blog post about not being able to do some kind of module reflection in Haskell that's supported in OCaml?
06:59:21 <cygnus_> are monads really pure
06:59:24 <quicksilver> cygnus_: yes.
06:59:29 <vixey> ozy`, which post
06:59:36 <ozy`> cygnus_: apart from the IO monad, yes
06:59:43 <quicksilver> the IO monad is really pure.
06:59:45 <Saizan> ozy`: augustss
06:59:57 <ozy`> vixey: don't remember
07:00:03 <pejo> ozy, augustss.
07:00:09 <tromp_> the onl;y impure part is the runtime system executing IO monadic expressions
07:00:26 <cygnus_> what does this mean
07:00:34 <quicksilver> it means that a function "a -> IO b"
07:00:36 <quicksilver> given the same 'a'
07:00:41 <ozy`> Saizan, pejo: yeah, that's the one
07:00:42 <quicksilver> always returns the same 'IO b'
07:00:45 <quicksilver> that's what purity is.
07:00:52 <quicksilver> functions given the same input always return the same output.
07:01:12 <cygnus_> no i mean romp_> the onl;y impure part is the runtime system executing IO monadic expressions
07:01:29 <orbitz> quicksilver: i'm confused woudln't a -> IO b mean it could NOT return teh same?
07:01:35 <quicksilver> orbitz: no.
07:01:37 <quicksilver> given "a"
07:01:41 <quicksilver> you always get the same "IO b"
07:01:42 <orbitz> :t getLine
07:01:43 <lambdabot> IO String
07:01:45 <quicksilver> (which is an action"
07:01:52 <orbitz> lambdabot: ohh "some IO b"
07:01:52 <quicksilver> each time you call "getLine" you get the same IO String.
07:01:55 <orbitz> err
07:01:56 <orbitz> no same?
07:01:58 <quicksilver> (it's called getLine)
07:01:59 <quicksilver> yes.
07:02:01 <quicksilver> getLine is a constant!
07:02:04 <Saizan> ozy`, vixey: http://augustss.blogspot.com/2008/12/somewhat-failed-adventure-in-haskell.html
07:02:04 <orbitz> define 'same'
07:02:07 <orbitz> ok
07:02:12 <Peaker> orbitz: when the IO b is _run_ multiple times, it might yield multiple b's, but this (IO b) value is just a single pure value
07:02:17 <idnar> orbitz: getLine is an IO action that retrieves a string from stdin
07:02:21 <Peaker> orbitz: s/run/executed
07:02:37 <Peaker> quicksilver: you could say an imperative-language-callback is also a "pure value"
07:02:39 <idnar> every time you use "getLine", you get that very same IO action that retrieves a string from stdin
07:02:58 <Peaker> quicksilver: or not, because its result isn't ..
07:02:59 <idnar> now, unsafePerformIO getLine is a totally different matter :P
07:03:07 <tromp_> an IO a is just a *description* of what the runtime system should do to obtain an a
07:03:57 <ozy`> <idnar> every time you use "getLine", you get that very same IO action that retrieves a string from stdin <== honestly, that's about as meaningful a statement as "every time you type 'getLine' you get the same identifier 'getLine' in the file"
07:04:11 <ozy`> but I'll quit trying to sabotage this :p
07:06:05 <quicksilver> ozy`: if you feel that's meaningless, you've totally failed to understand.
07:06:22 <quicksilver> mapM putStrLn ["hello","there","#haskell"]
07:06:26 <idnar> ozy`: yes
07:06:32 <idnar> ozy`: in other words, getLine is pure
07:06:34 <quicksilver> ^^ this function returns an "IO [()]"
07:06:41 <quicksilver> always the exact same "IO [()]"
07:06:45 <quicksilver> and that is the very essence of purity.
07:06:49 <quicksilver> That's what monads give us.
07:06:52 <idnar> ozy`: that's not meaningless, I was just being specific about what "getLine is pure" means
07:07:01 <quicksilver> the ability to use equational reasoning.
07:07:39 <cygnus_> what is the consquence of deferinng the non purity to the runtime environment
07:10:13 <ozy`> cygnus_: well purity in general means you have to carry around any persistent state between one function and the next
07:10:33 <ozy`> if it lasts the entire lifetime of your program, that probably means it will show up in main
07:11:00 <Peaker> cygnus_: you know that the type (a->b) is a pure function, *always*, and that means: A) it will always return the same result, it cannot "break" when the env. changes.  B) The compiler may parallelize it or do other crazy things, easily guaranteeing nothing breaks. C) It may compose with other pure values and you can inductively prove that the composition will work, because there can be no unexpected interactions between them
07:13:05 <Peaker> cygnus_: many other languages have many of these traits locally, when you know functions are pure, but: A) They don't guarantee them, things may change/break in the future B) The compiler cannot know them to optimize/parallelize  C) You can't know this about less local/larger functions, especially from libraries
07:13:32 <Peaker> cygnus_: and use of mutable globals can be "hidden" in there, so its hard to verify purity in those languages
07:14:00 <mapreduce> Haskell doesn't guarantee them either, with things like unsafePerformIO, but it makes it a lot harder to do it wrong by accident.
07:14:36 <ozy`> guys, quit telling people about unsafePerformIO
07:14:43 <ozy`> they'll learn better that way
07:14:58 <mapreduce> Ok, take it out of ghc then. :)
07:15:01 <ozy`> I've been learning Haskell for like two months and only heard about it yesterday
07:15:47 <Peaker> mapreduce: Haskell + unsafePerformIO violations == yet another unpure language
07:16:00 <trofi> :]
07:16:12 <Peaker> mapreduce: unsafePerformIO may be used to create semantically pure machinery with side-effecting machinery
07:16:15 <trofi> and {-# INLINE #-} perhaps
07:16:27 <Peaker> mapreduce: those kinds of unsafePerformIO are ok
07:16:34 <quicksilver> unsafePerformIO is a tool by which you may extend the compiler
07:16:38 <ozy`> isn't there a GHC switch that disallows unsafePerformIO?
07:16:43 <quicksilver> (using a syntax which looks eerily like haskell)
07:16:55 <quicksilver> you can, in fact, use it to break the compiler.
07:16:59 <quicksilver> if you do, it's your fault.
07:17:00 <vixey> Haskell = yet another impure language
07:17:04 <quicksilver> you're not using haskell any more.
07:17:16 <Deewiant> ozy`: I don't see it in the flag reference at least
07:17:37 <cygnus_> lol walmart
07:17:54 <vixey> unsafePerformNotInCansasAnymore
07:22:05 <mapreduce> Peaker: Sure.
07:22:51 <Peaker> mapreduce: and those are the only valid uses of that construct anyway
07:23:41 <athos> hi all
07:23:43 <mapreduce> Is trace not implemented that way?
07:24:22 <bd_> @src trace
07:24:23 <lambdabot> trace string expr = unsafePerformIO $ do
07:24:23 <lambdabot>     hPutStrLn stderr string
07:24:23 <lambdabot>     return expr
07:24:46 <Martijn> @pl \s -> satisfy (== s)
07:24:47 <lambdabot> satisfy . (==)
07:24:54 <Martijn> That was too easy
07:25:10 <bd_> the only reason that works is because you, the developer, interpret the result, and have to untangle things in the output
07:25:20 <bd_> and I'm not sure if it's lock-safe in all cases...
07:26:53 <quicksilver> that's a funny way to write it
07:26:56 <quicksilver> I thought it was
07:27:20 <quicksilver> (unsafePerformIO $ hPutStrLn str) `seq` expr
07:27:26 <quicksilver> that's how I would write it, at least...
07:28:28 <lilac> it'd be nice if we had a way to prove those two to be equivalent
07:29:12 <vixey> prove in terms of what?
07:29:57 <lilac> that's the problem :)
07:30:03 <vixey> you could type some kind of semantics of haskell into a theorem prover and prove it there
07:31:21 <lilac> including semantics for unsafePerformIO?
07:31:25 <lilac> that sounds somewhat nontrivial
07:31:27 <vixey> of course
07:31:35 <vixey> no it would be trivial
07:31:46 <vixey> since we already know what monads are :)
07:31:46 <EvilTerran> unsafePerformIO = undefined :P
07:32:38 <lilac> unsafePerformIO (a >> b) == unsafePerformIO a `seq` unsafePerformIO b?
07:32:53 <lilac> unsafePerformIO (return a) == a?
07:33:16 <lilac> i think the latter is true, but i'm not certain of the former
07:33:23 <vixey> well prove it!
07:33:35 <lilac> in terms of what?
07:33:47 <lilac> those are my suggestions for /definition/ of unsafePerformIO
07:33:55 <vixey> no I don't think that's a good definition
07:34:11 <lilac> you have a better set of axioms?
07:34:14 <vixey> yeah
07:35:09 <lilac> i really meant unsafePerformIO (a >>= f) == let b = unsafePerformIO a in b `seq` unsafePerformIO f b
07:36:30 <dcoutts> lilac: I don't think that is quite right either
07:37:29 <vixey> lilac, imagine a haskell interpreter that worked by taking sucessive WHNFs and happened to be written in an IO monad
07:37:45 <dcoutts> lilac: if 'f' does not read it's arg, then constant action in 'f' can happen before those in 'a'
07:37:57 <dcoutts> lilac: in the second example, but not in the first
07:38:17 <vixey> lilac, that's where I'd give semantics to unsafePerformIO
07:39:07 <dcoutts> of course you cannot really give it a semantics since it can break type safety
07:39:28 <vixey> dcoutts, operational semantics
07:39:30 <dcoutts> at least when used with mutable vars in IO
07:39:44 <lilac> dcoutts: it depends what 'forcing' the result of 'unsafePerformIO a' means, i guess
07:39:53 <dcoutts> vixey: what is the operation semantics of unsafeCoerce "foo" :: Int ?
07:40:12 <vixey> dcoutts, that obviously ends up getting Stuck which is something you can model
07:40:13 <lilac> dcoutts: i'm trying to avoid saying that, and instead just giving a set of axioms which are sufficient to prove what i want to prove :)
07:40:22 <Lemmih> dcoutts: 42?
07:40:26 <vixey> There is really no obstacle
07:40:31 <dcoutts> Lemmih: :-)
07:40:43 <vixey> It's just tedious work which is why nobody does it
07:40:49 <lilac> i think "undefined behaviour" is a reasonable thing to include in operational semantics
07:41:09 <lilac> and it'd be nice to be able to prove that it can't occur outside of IO
07:41:14 <vixey> lilac, that's what I mean by Stuck
07:41:27 <Peaker> I want compilers that open up a Quake session when UB is invoked
07:45:04 <lilac> Peaker: gcc used to do something like that
07:45:17 <lilac> Peaker: on an unknown #pragma it would start nethack AFAIR
07:45:58 <Peaker> hehe
07:48:51 <njbartlett> Has anybody else looked at Google's Native Client? It looks like it could be a platform for running compiled Haskell code in the browser.
07:49:56 <lilac> hmm. bytecode that runs clientside. why has no-one thought of that before? :)
07:49:56 <orbitz> njbartlett: is that what they use for their JS engine?
07:52:02 <Botje> lilac: let's name it after coffee!
07:52:11 <njbartlett_> Oops lost connection
07:52:13 <njbartlett_> lilac: It's not bytecode. It runs native x86 code
07:52:14 <orbitz> name it after a Tree!
07:52:15 <njbartlett_> orbitz: No I think that's called V8
07:52:30 <orbitz> njbartlett_: i think you're confusing it with the tomatoe juice
07:52:54 <njbartlett_> orbitz: I think you're confused about how to spell tomato ;-)
07:53:28 <stoneToad> njbartlett_: but does it run the x86 code directly on the metal, or does it run it in a VM?
07:53:35 <orbitz> tomaaaato
07:54:07 <kalven> stoneToad: it's not a vm
07:54:07 <njbartlett_> stoneToad: Directly, after some kind of static analysis for safety. It's an interesting approach, at least. Check the paper they wrote
07:54:24 <stoneToad> I feel really bad for all the people with old macs then if this catches on
07:55:25 <quicksilver> stoneToad: that was (roughly) my reaction
07:55:27 <ozy`> stoneToad: I appreciate your pity but old-Mac people have long since been left behind by the world :p
07:55:35 <quicksilver> I thought, why put all this effort into x86?
07:55:41 <stoneToad> lol ozy`
07:55:48 <stoneToad> my brother has 2 ^_^
07:55:49 <quicksilver> x86 just happens to be the dominant chip now, it's the first time it's ever held all three platforms at once
07:55:57 <stoneToad> all 3?
07:55:59 <quicksilver> and I'm quite sure it won't continue
07:56:04 <quicksilver> OSX/linux/win32
07:56:13 <ozy`> the PPC architecture has been relegated to console development for the time being
07:56:14 <Samy> Why won't it continue, quicksilver?
07:56:22 <quicksilver> Samy: because stuff moves on. stuff changes.
07:56:23 <stoneToad> linux runs pretty well on ppc and arm
07:56:27 <ozy`> maybe ARM will take over desktops/laptops
07:56:28 <quicksilver> that's the nature of technology.
07:56:37 <Samy> quicksilver, it has been close to 20 years now?
07:56:38 <quicksilver> stoneToad: yeah. I'm just saying dominant, not exclusive.
07:56:41 <stoneToad> I'm looking forward to some heftier ARM subnotbooks
07:56:51 <kalven> it's not inherently tied to x86
07:56:55 <quicksilver> ARM could take some share, sparc could possibly take some share
07:56:56 <quicksilver> who knows.
07:57:05 <Samy> quicksilver, I don't think we'll be moving away from x86 in the next 5 years for general purpose computing.
07:57:10 <quicksilver> it seems sad to develop a new (forward looking) tech based on a single chip.
07:57:28 <cygnus_> everytime someone tries to move away form x86 that chip dies
07:57:31 <quicksilver> Samy: I think you're wrong.
07:57:34 <cygnus_> look at itanium
07:57:37 <quicksilver> look at the iPhone.
07:57:39 <Samy> sun4v would be nice for desktops I bet, but it's too expensive.
07:57:49 <Samy> cygnus_, look at the appliance/embedded market.
07:58:05 <Samy> cygnus_, ARM, doing better. PPC, doing better. MIPS, doing better. The list goes on.
07:58:06 <cygnus_> hey thatas cause theres no legacy code
07:58:37 <Samy> cygnus_, problem with Itanic is that it is non-trivial :) Too complicated to easily support by vendors without a massive investment. It exists only in some markets now.
07:59:01 <Samy> quicksilver, I doubt I am. :-P Want to place a waiger?
07:59:12 <stoneToad> cygnus_: if you're 100% open source you can (hopefully) just recompile :)
07:59:26 <cygnus_> what about all the __asm { ...
07:59:36 <stoneToad> that's why you write haskell?
07:59:44 <cygnus_> the os wont boot then
07:59:52 <stoneToad> os is already ported
08:00:12 <cygnus_> touche
08:05:00 <quicksilver> Samy: I suspect that the iPhone is the beginning of the emergence of viable non-x86 platforms.
08:05:24 <quicksilver> Samy: it has already been phenomenally successful, and other companies will build palmtops and netbooks along the same lines.
08:05:29 <ozy`> quicksilver: I suspect the same
08:06:13 <quicksilver> so, there will be a significant slice of non-x86 web browser use
08:06:46 <p_l> I wonder why the hell people associate "viable non-x86" platforms with iPhone... sure, Windows Mobile haven't had it's browser updated for a long time, but I think it's much more "viable" platform
08:07:15 <kalven> googles sees potential applications like image processing and video codecs, you're not going to run that on the iphone anyway.
08:07:22 <cygnus_> what chip is iphone
08:07:22 <quicksilver> p_l: look at the numbers. There is your answer.
08:07:50 <quicksilver> p_l: the iPhone has brought useful web browsing to vastly more people than any previous hand-sized device.
08:07:55 <ozy`> cygnus_: isn't it ARM?
08:08:02 <quicksilver> (I'm not debating the technology, just the results)
08:08:26 <p_l> quicksilver: Several times bigger Windows Mobile market than the whole iPhone ecosystem. Can't say I didn't look. The only difference is the browser, which is currently reworked (not to mention Opera)
08:09:03 <quicksilver> p_l: yes, but those people are not using their windows mobile device to browse.
08:09:16 <quicksilver> p_l: they are used for email + personal organiser purposes.
08:09:20 <quicksilver> (nothing wrong with that at all)
08:09:27 <quicksilver> it's just being used in different ways.
08:09:36 <kig> i hope iphone's going to move to x86 once intel gets atom small enough
08:09:39 <p_l> quicksilver: I beg to concur. For that, you have blackberry/nokia communicator line
08:09:51 <quicksilver> a small proportion of Win mobile customers browse the web regularly.
08:09:51 <ozy`> kig: now why would you hope for that?
08:10:03 <quicksilver> a large proportion of iPhone customers do
08:10:05 <tromp_> iphone will never be x86
08:10:17 <quicksilver> so even though there are more of one, there are less doing this particular activity.
08:10:38 <p_l> quicksilver: the PIM+email crowd switches the sides all the time, because they don't really need good platform as long as it does PIM+email
08:10:42 <ozy`> tromp_: you're probably right but nothing is ever so certain
08:11:08 <tromp_> apple bought PAsemi to make custom ARM cores for iphone
08:11:20 <quicksilver> p_l: sure. I'm making one point here, and one point only.
08:11:34 <quicksilver> p_l: more people use iPhone browsing than windows mobile browsing.
08:11:39 <quicksilver> and that is a fact, as far as we can tell.
08:11:43 <quicksilver> http://blogs.computerworld.com/iphone_browsing_marketshare_closes_in_on_1
08:11:59 <tromp_> plus, atom cannot compete with arm for power efficiency
08:12:01 <ozy`> after all, if you went back ten years and said "Apple is going to switch from PPC to x86, and MS is going to switch their hardware from x86 to PPC" you'd get modded +5 Funny (since at the time, the only place anyone would care is Slashdot)
08:12:26 <quicksilver> p_l: more recent figures http://mobilebroadbandblog.wordpress.com/2008/08/28/does-iphone-increase-browsing-better-believe-it/
08:12:35 <p_l> quicksilver: It won't change much as "target" platform, though. As long as there's Flash and JS, Web crowd is rather indifferent
08:12:38 <ozy`> never mind that the Xbox hasn't been out for ten years yet
08:12:56 <Deewiant> ozy`: well, MS hasn't exactly switched to PPC
08:13:00 <p_l> quicksilver: I agree though that browsing is quite popular with iPhones
08:13:11 <quicksilver> p_l: well, I think it's significant that iPhone browsing share is growing.
08:13:17 <quicksilver> It's the fastest frowing non-x86 segment.
08:13:30 <quicksilver> and that's relevant to our discussion about google native client.
08:14:05 <quicksilver> I am sure other manufacturers will see this and bring out "iPhone-like" devices, some will be a bit larger, and most will use ARM or similar chips. Who knows, one of them may even be successful ;)
08:14:31 <p_l> quicksilver: I wonder if Apple would allow it though. I think there was this "no ability to load code from 3rd parties" thing in license agreement to load your apps
08:14:47 <quicksilver> they allow javascript.
08:14:52 <kalven> why would you want to run something that is so compute hungry that it has to be a NaCl on something underpowered like the iphone?
08:15:06 <quicksilver> kalven: people always want to do what is possible.
08:15:15 <quicksilver> kalven: and then they always lust after what is 'not quite possible' next :)
08:15:28 <quicksilver> put the possibilityin place and people will find something to do wiht it.
08:15:32 <p_l> Also, the only thing I found useful in iPhone was Safari. And japanese input. I couldn't stand the rest after using Symbian and Windows Mobile :)
08:15:45 <DuClare> iFone?
08:15:51 <p_l> afk
08:15:59 <DuClare> http://www.dealextreme.com/details.dx/sku.5179
08:16:01 <ozy`> p_l: Apple has demonstrated in the recent past that they are willing to loosen up on the utterly draconian iPhone restrictions for the sake of growing the platform
08:19:10 <vixey> epigram 2 isn't going to be out for ages :/
08:19:20 <DuClare> Hi vixey :]
08:19:31 <vixey> hello DuClare
08:20:31 <vixey> "For example, a book like SICP or TAPL isn't exactly something that you lay down on the couch with and just read" o_o
08:20:33 <vixey> news to me
08:20:38 <ozy`> vixey: epigram is terrifying
08:20:55 <vixey> ozy`, Epigram 2 sounds super cool
08:20:56 <DuClare> Amazing join/quit flood these days.
08:21:18 <mauke> vixey: http://dis.4chan.org/read/prog/1208110675/
08:21:21 <Peaker> IRC backwards compatibility
08:22:28 * DuClare hasn't read SICP yet.  Should do it.
08:23:12 <vixey> mauke, I think my cat is Schrödinger
08:25:27 <_albertux_> sorry im noob on haskell im install GHC and i on the GHCi Prelude>
08:26:01 <_albertux_> f x + g y
08:26:16 <roderyk> If I call gtk2hs' onExposeRect twice, only the first signal seems to take effect. Is there a way I can force the new expose signal to be used? (or should it be overwriting it and I'm simply doing something wrong?)
08:26:21 <pejo> vixey, is there a road map/time plan/etc for epigram 2?
08:26:31 <_albertux_> says not in the scope
08:26:32 <ozy`> лолшто
08:26:35 <_albertux_> f,x,g,y
08:26:43 <mauke> _albertux_: what did you expect?
08:26:47 <DuClare> alexsuraci, Did you define f and g
08:26:49 <dcoutts> roderyk: they are combined, the widget gets repainted asynchronously
08:26:53 <DuClare> And x and y
08:27:14 <_albertux_> i don't know i think is like python command line
08:27:17 <vixey> pejo, all I see is a darcs repo with no commits in the last couple months
08:27:19 <_albertux_> im reading  haskell98-report-html/exps.html
08:27:36 <DuClare> ...
08:27:38 <vixey> we should make Anargram2
08:27:51 <vixey> just get a bunch of people that are less lazy than me
08:28:06 <_albertux_> some document to see informal intruduccion ?
08:28:10 <ozy`> Anargram? is that Anagram for pirates?
08:28:30 <DuClare> Google for haskell tutorial?
08:28:31 <vixey> _albertux_: you actually have put definitions of f x g and y in a file?
08:28:55 <_albertux_> vixey im on GHCi Prelude>
08:28:59 <_albertux_> not on file
08:29:17 <vixey> _albertux_: then you must make a file!
08:29:24 <roderyk> dcoutts: a little confused. Both my events theoretically repaint the entire rectangle, but either the second is being called, or it is shadowed by the first. Can I remove the first signal in some way from being called during runtime?
08:29:26 <vixey> put in it
08:29:27 <_albertux_> ok
08:29:31 <vixey> f x = x * x
08:29:33 <vixey> g y = y + y
08:29:35 <vixey> x = 3
08:29:36 <vixey> y = 4
08:29:41 <vixey> -- just put that stuff in it
08:29:42 <roderyk> dcoutts: s/second is/second is not/
08:29:47 <vixey> save it as test.hs
08:29:52 <DuClare> Can be done in the interpreter
08:29:56 <vixey> and then it ghc:  :load test
08:30:00 <vixey> and then it ghci*:  :load test
08:30:22 <_albertux_> ok wait  aminute thanks for the information i want to test, open scite ...
08:30:30 <dcoutts> roderyk: each call schedules the widget to be repainted. If it gets scheduled to be repainted several times before it actually does get repainted then it doesn't matter.
08:31:09 <dcoutts> roderyk: if you find you're fighting against that then you're doing something wrong
08:32:15 <dcoutts> roderyk: the point is you're not asking for it to be repainted now, you're asking for it to be repainted at some time in the near future.
08:32:40 <_albertux_> vixey i made test and run :load test but GHCi says:  target 'test' is not a module name or source file i sabe test file on /bin (on the ghci.exe)
08:32:50 <_albertux_> don;t have extension
08:32:52 <vixey> no
08:32:56 <vixey> save it as test.hs
08:34:05 <roderyk> dcoutts: true. Basically I have a tick (widgetQueueDraw canvas >> return True) running often; and then I have a sequential order of drawings: (updateCanvasUsingX >> ... after a while .. >> updateCanvasUsingY)
08:34:24 <pejo> vixey, making a compiler is a huge project. Considering the scope for Epigram 2 it's not that strange if it takes some time.
08:34:25 <roderyk> maybe I need to reinit the drawingArea?
08:34:38 <DuClare> pejo, It's not neccessarily huge
08:34:40 <_albertux_> ok maybe im doing wrong something, but when i open GHCi and :load test say the same error but doble click on test.hs says [1 of 1 ] compiling main
08:34:54 <_albertux_> ok, modules loades
08:34:56 <DuClare> (Unless you're talking about a specific compiler)
08:35:08 <dcoutts> roderyk: so the (updateCanvasUsingX >> updateCanvasUsingY) happen inside the expose handler? What does "after a while" mean?
08:35:34 <dcoutts> roderyk: does the (updateCanvasUsingX >> updateCanvasUsingY) actually do the painting directly?
08:37:35 <roderyk> dcoutts: yes, inside the expose handler. I wrote a timeoutSeq [(fn,time)], so it will run each of (fn,time) until fn returns False. And then, eg. one of the tuples is: (onExposeRect canvas $ drawTable st canvas) >> return False, 100) (which changes how canvas is rendered next time the tick invalidates the widget)
08:38:11 <roderyk> timeoutSeq being sequential. It won't add another timeoutAdd until the previous exits
08:39:14 <dcoutts> roderyk: are you perhaps blocking the main loop so that it does not get a chance to redraw?
08:39:44 <athos> > error "foobar"
08:39:45 <lambdabot>   * Exception: foobar
08:39:54 <dcoutts> roderyk: I also think that onExpose is cumulative, ie all handlers get run. That might not be what you want.
08:40:11 <dcoutts> roderyk: instead you might want to communicate what to draw next via an IORef or something
08:40:22 <athos> @src error
08:40:23 <lambdabot> error s = throw (ErrorCall s)
08:40:36 <dcoutts> roderyk: and have the onExpose just grab the drawing from the ref and draw it
08:40:37 <pejo> DuClare, I think the context was Epigram 2.
08:40:42 <DuClare> Yeah
08:41:27 <roderyk> dcoutts: yea, I need it not to be cumulative. I just thought there was a way to invalidate a previous onExpose signal. Will rewrite this part the way you're recommending
08:42:06 <dcoutts> roderyk: there is a way to remove previously installed handlers, but that's more complex than just using a single handler and communicating via an IORef
08:42:37 <roderyk> dcoutts: cool, thanks for all the pointers. I sure am making a mess of gtk2hs :)
08:43:05 <_albertux_> excuse what is wrong in this code: http://pastebin.com/d4717e2c4 says: parse error on input 1
08:43:50 <mauke> 1 (line 3) is not aligned with putStr (line 2)
08:43:58 <mauke> readLine is not defined
08:44:04 <mauke> pirnt is misspelled
08:44:10 <mauke> 1 is not a valid variable name
08:44:25 <_albertux_> i take the code on haskelreport documentation :S
08:44:26 <_albertux_> :'(
08:44:32 <mauke> no, you didn't
08:44:43 <_albertux_> haskell98-report-html/syntax-iso.html
08:44:45 <_albertux_> yes
08:44:50 <mauke> no, you didn't
08:44:59 <mauke> the haskell report does not misspell 'print'
08:45:47 <_albertux_> download http://haskell.org/haskellwiki/Language_and_library_specification the haskell98 report revised an check the file i put
08:45:55 <_albertux_> i don't lie
08:45:59 <mauke> dude
08:46:05 <mauke> you fail at copy/paste
08:46:14 <mauke> the haskell report uses l, not 1
08:46:14 <chessguy_work> @yow
08:46:15 <lambdabot> Now I am depressed ...
08:46:23 <mauke> it properly aligns the lines of the do block in main
08:46:30 <fasta> mauke: or maybe someone is doing a man in the middle attack ;)
08:46:32 <mauke> 'print' is not 'pirnt'
08:46:33 <redditbot> Declarative Combinatorics: Isomorphisms, Hylomorphisms and Hereditarily Finite Data Types in Haskell
08:46:54 <mauke> the readLine thing is in the original code, though
08:46:59 <_albertux_> i dont; copy paste
08:47:03 <_albertux_> i read and write
08:47:11 <mauke> _albertux_: that is why you fail
08:47:12 <roderyk> mauke: BOFH: Cosmic ray particles crashed through the hard disk platter
08:47:25 <_albertux_> copy and paste
08:47:29 <_albertux_> > main :: IO ()
08:47:30 <lambdabot>   Not in scope: `main'
08:47:30 <_albertux_> > main = do putStr "Enter a number: "
08:47:31 <lambdabot>   <no location info>: parse error on input `='
08:47:32 <_albertux_> >           l <- readLine
08:47:33 <lambdabot>   <no location info>: parse error on input `<-'
08:47:33 <_albertux_> >           putStr "n!= "
08:47:35 <lambdabot>   * Exception: "<IO ()>"
08:47:35 <_albertux_> >           print (fact (read l))
08:47:36 <lambdabot>   Not in scope: `fact'
08:47:36 <_albertux_>           
08:47:38 <_albertux_>   This is the factorial function.
08:47:39 <_albertux_> > fact :: Integer -> Integer
08:47:41 <lambdabot>   Not in scope: `fact'
08:47:41 <_albertux_> > fact 0 = 1
08:47:42 <lambdabot>   <no location info>: parse error on input `='
08:47:43 <_albertux_> > fact n = n * fact (n-1)
08:47:44 <lambdabot>   <no location info>: parse error on input `='
08:47:48 <Lemmih> ?where ops
08:47:48 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
08:47:50 <byorgey> _albertux_: please don't paste into the channel like that.
08:47:50 <_albertux_> that is the code
08:47:54 <_albertux_> ok sorry
08:48:01 <mauke> _albertux_: why did you paste that?
08:48:15 <_albertux_> ok thanks any way for the helo
08:48:16 <EvilTerran> particularly with the >s on the start, lambdabot will think you're talking to *her*
08:48:30 <_albertux_> i want to learn this language with or without your helo
08:48:40 <EvilTerran> ... our helo?
08:48:56 <chessguy_work> you had me at helo?
08:49:23 <byorgey> mauke: he was being rather daft, but I still think you could have tried to be a bit more gentle.
08:49:32 <roderyk> maybe he was typing on a cyrillic keyboard.. I'm sure I wouldn't manage any better ;-)
08:49:42 <vixey> yeah there are not enough lunatics here
08:49:43 <vixey> :P
08:55:43 * byorgey bakes some lambda and sundried tomato focaccia
09:05:33 <ksf> http://arxiv.org/abs/0808.2953v3 (the thing redditbot failed to give a link to)
09:05:38 <ksf> it's witty.
09:06:09 <visof> how can i do this function, rep 4 [1,2,2,3,3,3,4,4,4,4] ?
09:06:21 <visof> by list comprehension
09:06:30 <vixey> visof, don't use list comprehension
09:06:32 <ksf> data Iso a b = Iso (a -> b) (b -> a) and much stuff on it.
09:06:38 <chessguy_work> by list comprehension? that's a weird way
09:06:56 <visof> why vixey ?
09:07:07 <vixey> > [1..4] >>= join replicate
09:07:08 <lambdabot>   [1,2,2,3,3,3,4,4,4,4]
09:07:17 * chessguy_work = p0wnd
09:07:34 <chessguy_work> i was writing a much longer version of that
09:08:06 <Peaker> > concat [join replicate x | x <- [1..4]]
09:08:08 <lambdabot>   [1,2,2,3,3,3,4,4,4,4]
09:08:09 <chessguy_work> replicate 4 4
09:08:13 <mauke> > [ y | x <- [1 .. 4], y <- replicate x x ]
09:08:14 <lambdabot>   [1,2,2,3,3,3,4,4,4,4]
09:08:31 <vixey> visof, because they suck
09:08:50 <idnar> I wouldn't say they suck, but I don't think they're particularly useful for that
09:08:56 <idnar> particular case
09:08:58 <EvilTerran> > [x | x <- [1..], _ <- [1..x]]
09:09:00 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
09:09:06 <EvilTerran> :D
09:09:08 <idnar> EvilTerran: oh, cute
09:09:15 <vixey> Does parsing infix operators require backtracking?
09:09:36 <EvilTerran> vixey, backtracking or a stack, i think, yes
09:10:09 <vixey> like parsing 2 * 3 + 1 * 5 as  (Plus (Times (N 2) (N 3)) (Times (N 1) (N 5))) you can do it without backtracking?
09:10:12 <chessguy_work> EvilTerran, that's sick or awesome, i can't decide which
09:10:34 <mauke> vixey: yes, preflex's calc module doesn't backtrack
09:10:38 <mauke> it's not even recursive
09:10:43 <mauke> preflex: calc 2*3 + 1*5
09:10:43 <preflex>  11
09:11:03 <vixey> so should I use cps
09:12:26 <paolino> :t join replicate
09:12:27 <lambdabot> Int -> [Int]
09:12:42 <vixey> idk how to do it :/
09:12:44 <camio> Anyone know where I might find more information about the "vertex unit" parameter of GL.matrixMode?
09:13:06 <vixey> other than chopping up the string by the lowest fixity thing and hten parse each branch with the lower level
09:13:38 <EvilTerran> vixey, with Parsec.Expr?
09:13:39 <DrSyzygy> dons: Are you just posting everything I write to proggit nowadays? :-)
09:13:49 <vixey> not parsec
09:13:58 <EvilTerran> okok
09:14:57 <EvilTerran> vixey, parser generators do something complicated and confusing involving state tables
09:15:03 <leimy> GHC is really great
09:15:15 <vixey> I want to prove correctness also
09:15:36 <sstangl> leimy: ghci makes me sad
09:15:40 <leimy> cabal-install is kind of CPANy but unlike CPAN most programs one writes with those developer libraries don't require one to have copies laying around on deployment systems.
09:15:47 <ksf> camio, in the redbook.
09:15:49 <EvilTerran> vixey, IIRC, a push-down automaton is sufficient for parsing infix stuff
09:15:50 <vixey> easiest is probably chopping it up based on the lowest prec operator
09:15:58 <leimy> sstangl: what about it makes you sad?
09:16:06 <vixey> do you know anywhere with a proof that the PDA works?
09:16:13 <ksf> http://www.opengl.org/documentation/red_book/
09:16:17 <EvilTerran> er... i'd start on wikipedia :P
09:16:19 <vixey> that way is better than mine
09:16:28 <sstangl> leimy: inability to declare datatypes, give multiline definitions of things
09:16:34 <sstangl> unless I'm missing something :P
09:16:45 <EvilTerran> sstangl, you can do multi-line definitions with
09:16:46 <EvilTerran> :{
09:16:47 <EvilTerran> ...
09:16:48 <EvilTerran> :}
09:16:49 <leimy> Hmm, well I use it mainly with an editor.
09:16:56 <leimy> and lots of ":l"
09:16:59 <EvilTerran> handy for pasting in
09:17:31 <leimy> I've never tried the inferior Emacs mode for GHC
09:17:35 <leimy> I think it exists.
09:17:50 <sstangl> EvilTerran: leimy: I'm used to SML and Python, where interpreters just keep reading until they receive a complete structure
09:18:26 <vixey> but I can't find any proofs about deterministic pushdown automaton
09:18:27 <vixey> :(
09:18:31 <solrize_> pda's can parse context free languages
09:18:46 <sstangl> it's a bit more difficult with haskell because you can't really be sure when it ends, so ghci if it wanted to support this would have to make some new meaning for "end of statement", like a semicolon.
09:18:54 <sstangl> that's how SML solves it, anyway.
09:19:00 <mauke> ;;
09:19:03 <chessguy_work> hey, i know someone had a collection of error-handling techniques in haskell. anyone recall where it is
09:19:42 <vixey> omg parsing is so hard
09:20:02 <solrize_> http://en.wikipedia.org/wiki/Recursive_descent_parser  <--- if you're trying to hand code one for that
09:20:15 <mauke> no, it isn't: http://mauke.ath.cx/preflex/ext/wcalc.c
09:20:16 <DrSyzygy> vixey: parsing is hard. I love shopping!
09:20:19 <mauke> so easy you can do it in C!
09:20:37 <solrize_> why not use parsec or happy or whatever?
09:21:02 * chessguy_work answers his own question with http://tinyurl.com/568z82
09:21:22 <lilac> christmas shopping is hard! let's go parsing!
09:22:04 <byorgey> hey, it's DrSyzygy!
09:22:08 <byorgey> long time no see =)
09:23:11 <chessguy_work> @remember DrSyzygy parsing is hard. I love shopping!
09:23:11 <lambdabot> I will never forget.
09:23:28 <chessguy_work> DrSyzygy, congrats on the degree, by the way :)
09:24:24 <DrSyzygy> chessguy_work: thanks.
09:24:40 <DrSyzygy> (it's closing in on half a year ago, but still :-)
09:24:48 <chessguy_work> holy cow, really?
09:24:55 <DrSyzygy> Yo byorgey
09:24:58 <chessguy_work> yeesh
09:25:08 <DrSyzygy> byorgey: Did you see the splash I seem to have made on proggit?
09:25:25 <byorgey> DrSyzygy: well, I don't read proggit, so no
09:25:28 <DrSyzygy> (minor for a proggit splash, but pretty major for me - as it gives me highest blog traffic evah!)
09:25:37 <byorgey> DrSyzygy: link?
09:25:47 <DrSyzygy> I posted this:http://blog.mikael.johanssons.org/archive/2008/12/j-or-how-i-learned-to-stop-worrying-and-love-the-matrix/
09:25:52 <DrSyzygy> And it got featured .
09:25:56 <DrSyzygy> Still hangs on second page of proggit.
09:25:58 <byorgey> oh, nice
09:26:05 <byorgey> DrSyzygy: yeah, I read that post.  I like J too =)
09:26:46 <byorgey> I've just been doing some (required) programming in matlab for a course, it made me really wish for J
09:26:58 <byorgey> matlab's handling of matrix types is horribly inconsistent.
09:27:25 <DrSyzygy> byorgey: For my sake one of the reasons I'm looking at J is because I find myself doing a lot of matlab work...
09:27:39 <byorgey> heh, perfect =)
09:27:39 <Ferdirand> matlab's syntax is horribly inconsistent
09:27:39 <Megzlna> How can I shorten zipWith ?
09:27:51 <vixey> z = zipWith
09:27:55 <byorgey> Ferdirand: that too.
09:27:59 <Megzlna> not that, vixey
09:27:59 <lilac> Megzlna: depends on the context
09:28:02 <DrSyzygy> Megzlna: Why would you want to?
09:28:04 <Samy> vixey, "Introduction to the theory of Computation" by M. Sipser
09:28:06 <Megzlna> but all the scaffolding
09:28:18 <DrSyzygy> zipWith op list1 list2
09:28:20 <Samy> vixey, it deals with all this, includes formalism of PDAs and several proofs/etc...
09:28:22 <DrSyzygy> What's the big deal?
09:28:27 <Megzlna> <*> less <$> crap
09:28:43 <leimy> sstangl: Eh, I'm more or less ok with that
09:28:49 <lilac> getZipList (ZipList list1 <^op^> ZipList list2) ? :)
09:28:54 <leimy> I mean, I prefer to edit code in a real editor anyway.
09:29:02 <Megzlna> sorry, I meant in the context of getZipList
09:29:18 <vixey> Megzlna, nobody can read your mind
09:29:29 <byorgey> Megzlna: I'm still not sure what you are asking.
09:29:46 <lilac> Megzlna: can you provide code which you want improved?
09:30:19 <Megzlna> getZipList ((,,) <$> ZipList [1,2,3] <*> ZipList [True,True,False] <*> ZipList ["foo","bar","baz"])
09:30:46 <lilac> > zip3 [1,2,3] [True,True,False] ["foo","bar","baz"]
09:30:48 <lambdabot>   [(1,True,"foo"),(2,True,"bar"),(3,False,"baz")]
09:30:48 <Deewiant> > zip3 [1,2,3] [True,True,False] ["foo","bar","baz"]
09:30:50 <lambdabot>   [(1,True,"foo"),(2,True,"bar"),(3,False,"baz")]
09:30:53 <Megzlna> Not zip3
09:31:02 <Megzlna> for N-sized
09:31:17 <Megzlna> here's what I want:
09:31:23 <Megzlna> Narytuple typeclass
09:31:26 <Deewiant> > sequence [[1,2,3],[True,True,False],["foo","bar","baz"]]
09:31:28 <lambdabot>   Couldn't match expected type `Bool' against inferred type `[Char]'
09:31:29 <Megzlna> for which I can then write:
09:31:34 <Deewiant> oops
09:31:37 <Megzlna> superzip ([1,2,3])
09:31:43 <vixey> @go Conor McBride who needs dependent types
09:31:50 <Megzlna> superzip ([1,2,3],["foo","bar","baz"])
09:31:51 <lambdabot> http://portal.acm.org/citation.cfm?id=968421
09:31:51 <lambdabot> Title: Faking it Simulating dependent types in Haskell
09:31:52 <leimy> You want to zip a list of lists?
09:32:04 <Megzlna> superzip ([1,2,3],["foo","bar","baz"],[-1,-2,-3])
09:32:05 <lilac> Megzlna: why not just use [[a]] and transpose?
09:32:06 <chessguy_work> hm, J looks really interesting
09:32:17 <Megzlna> Because lists are not compile time
09:32:29 <DrSyzygy> chessguy_work: Gotta love the Java-ist trolls I get too. :-P
09:32:30 <Megzlna> Tuples are static offsets in the ASM code
09:32:37 <chessguy_work> lol
09:32:42 <leimy> oy
09:32:44 <Megzlna> lists are a zillion x slower
09:32:47 <vixey> @go de we need dependent types
09:32:54 <lambdabot> http://www.brics.dk/RS/01/10/BRICS-RS-01-10.ps.gz
09:32:56 <vixey> Megzlna, check it out
09:32:59 <vixey> there is a way
09:33:04 <Deewiant> Megzlna: tuples are actually boxed by default so they're slower than you think
09:33:06 <ddarius> chessguy_work: J is fun but has some bizarre parts (not related to the main ideas of the language) that make it... seem less than practical (for general purpose programming)
09:33:09 <DrSyzygy> "Boooo! Compact code isn't everything because I could just encapsulate everything and write 100.getTrailingZeros()"
09:33:14 <leimy> arbitrary sized tuples?
09:33:26 <Megzlna> You only need 15 overloads
09:33:30 <chessguy_work> so...it's functional, but impure, right?
09:33:31 <DrSyzygy> ddarius: Such as?
09:33:34 <lilac> can someone confirm that J is definitely not a joke language?
09:33:37 <Megzlna> since GHC only accepts 15-tups
09:33:40 * lilac tried learning it a while back
09:33:40 <vixey> lilac, J is great
09:33:43 <Deewiant> lilac: it's definitely not a joke language
09:33:46 <ddarius> DrSyzygy: The IO system and the various other primitives.
09:33:47 <DrSyzygy> lilac: It is definitely not a joke language.
09:33:55 <Megzlna> so: a typeclass which includes 2 through 15-tuples
09:33:57 <vixey> lilac, it's like APL but useful without being greek
09:34:02 <Megzlna> and a way of iterating over them
09:34:05 <Megzlna> so I can write superzip
09:34:08 <ddarius> DrSyzygy: The class system seems clunky, but I didn't really mess with that.
09:34:09 <ziman> Megzlna, in fact, tuples are not static offsets unless unboxed.
09:34:14 <DrSyzygy> I'm not all that convinced that it's functional either.
09:34:17 <lilac> vixey: i'm vaguely familiar with it, but it's always seemed... deliberately obfuscated
09:34:28 <Megzlna> ziman: ?
09:34:35 <leimy> I guess I'd like to see the profiling run that proves the tuples are faster enough to make a difference :-)
09:34:38 <byorgey> J is... sort of functional, in a half-assed sort of way.
09:34:41 <vixey> lilac, you can use the full names of things instead of the symbols
09:34:42 <DrSyzygy> pozrovlak was working on a research proposal some time back, where he wanted to work on formal semantics for matrix languages (APL, J, Matlab, et.c.)
09:34:57 <vixey> well J has while loops and mutable state
09:34:59 <ziman> Megzlna, there's difference between (_|_, _|_) and _|_
09:35:03 <vixey> but usually you don't use them
09:35:11 <vixey> so its functional like ocaml
09:35:17 <Megzlna> I think there's no difference at all for runtime cost of   f (x,y) and f x y
09:35:21 <DrSyzygy> byorgey: That's the thing, really. I don't think classifying it as functional is all that good of an idea, because it builds on different fundamental tenets than the "real" functionals do.
09:35:25 <Megzlna> ie: no cost.
09:35:29 <vixey> Megzlna, I think you're wrong
09:35:50 <DrSyzygy> byorgey: I think it's saner to classify matrix languages in one pot. With, as pozorvlak did, putting J, APL and Matlab as the chief representatives.
09:35:50 <vixey> Megzlna, have you met _|_ yet?
09:35:53 <Megzlna> Why would the tuple have any cost? All offsets are knowable at compile time
09:36:01 <leimy> One doesn't have to "think" this stuff, one can measure
09:36:03 <Megzlna> vixey: I've met 'undefined'
09:36:10 <Megzlna> _|_ doesn't work afaik
09:36:10 <DrSyzygy> Megzlna, _|_. _|_, meet Megzlna.
09:36:12 <vixey> Megzlna, undefined is sort of _|_
09:36:26 <vixey> Megzlna, but lets say we define  undefined = undefined  instead of the usual
09:36:32 <vixey> _that_ is _|_ now
09:36:41 <Megzlna> (1, undefined)
09:36:49 <Megzlna> with Maybe
09:37:02 <jeffersonheard> I hate it when I come in in the morning and I've missed messages...  Konversation blinks at me to say someone said something to me, and it doesn't save the history to show me the message
09:37:05 <vixey> Megzlna, anyway, theer is 3 ways  f _|_, f (_|_,_) f (_,_|_) vs two ways f _|_ _  f _|_ _
09:37:06 <Megzlna> undefined only needs the size of 1 thunk
09:37:18 <Megzlna> the tuple can still be static
09:37:19 <DrSyzygy> jeffersonheard: *snerk*
09:37:24 <chessguy_work> DrSyzygy, if you can do "sumsq =: sum @: square", i would call that a pretty functional language
09:37:46 <RayNbow> > let (⊥) = (⊥) in (⊥)
09:37:50 <leimy> this is far too implementation dependent :-)
09:38:00 <DrSyzygy> chessguy_work: It certainly has functional composition. And it probably embeds a functional language. But the functional language part isn't the characteristic part of the language.
09:38:02 <lambdabot>   thread killed
09:38:37 <chessguy_work> ok, but saying that it's not a functional language suggests to me that it lacks support for functions as first-class objects
09:39:16 <Megzlna> Ok, so ignore the performance... lets just say for expostition's sake
09:39:25 <DrSyzygy> chessguy_work: That wasn't what I was trying to say.
09:39:39 <Megzlna> I want to  allow  f (1)  f (1,2)  f (1,2,3)
09:39:39 <DrSyzygy> Though I'm not certain I know what it was that I was trying to say.
09:39:49 <chessguy_work> DrSyzygy,  i understand, i'm just saying how it sounds
09:39:50 <vixey> Megzlna, anyway did you read that link I gave you?
09:39:56 <chessguy_work> at least to a schlub like me
09:40:02 <DrSyzygy> Megzlna: For arbitrary many args, or just for 1,2, and 3 args?
09:40:29 <roconnor> @src sequence
09:40:30 <lambdabot> sequence []     = return []
09:40:30 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
09:40:30 <lambdabot> --OR
09:40:30 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
09:40:32 <Megzlna> Drsyzgy: 1 to 15
09:40:37 <chessguy_work> i would say that if you asked most programmers what a functional language is, they either say "a what?" or "a language that has functions as first class objects"
09:41:07 <Megzlna> vixey: not yet
09:41:15 <jeffersonheard> chessguy_work: yeah, that's the usual definition I've seen.  LISP being functional and all
09:41:17 <roconnor> @src sequence_
09:41:18 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
09:41:20 <vixey> Megzlna, ....ok
09:41:22 <pejo> chessguy, what about first-order functional languages then?
09:41:36 <chessguy_work> pejo, not sure what that is
09:41:46 <roconnor> @src mapM_
09:41:47 <lambdabot> mapM_ f as = sequence_ (map f as)
09:41:52 <Megzlna> > (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
09:41:53 <lambdabot>   (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
09:41:56 <Megzlna> > (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
09:41:57 <lambdabot>       No instance for (Show
09:41:57 <lambdabot>                         (t,
09:41:57 <lambdabot>                      ...
09:41:59 <ddarius> chessguy_work: Single Assignment C (and various languages in that branch) would count.
09:42:07 <chessguy_work> never heard of it
09:42:50 <vixey> > let (*) = (,) in (1*2*3*4*5*6*7*8*9*10*11*12*13*14*15*16)
09:42:52 <lambdabot>   (((((((((((((((1,2),3),4),5),6),7),8),9),10),11),12),13),14),15),16)
09:43:20 <ddarius> http://www.sac-home.org/
09:43:28 <chessguy_work> ddarius,  already there :)
09:44:50 <lilac> Megzlna: /why/ do you want to allow f(1), f(1,2), f(1,2,3)?
09:44:59 <vixey> cool find ddarius!
09:45:05 <ddarius> This page in particular probably answers most questions quickly: http://www.sac-home.org/index.php?p=./11_About/11_About_SAC
09:45:15 <ddarius> vixey: I've known about it for years.
09:45:15 <Megzlna> lilac: so I can make superzip without using lists
09:45:34 <vixey> Megzlna, you can do it without lists or tuples
09:45:40 <Ferdirand> wouldn't this conflict with partial application consistency anyway ?
09:46:12 <vixey> Ferdirand, typeclass or GADT tricks let you do it
09:46:21 <Megzlna> typeclass Ntuple
09:47:22 <lilac> Megzlna: that's what, not why.
09:47:44 <Ferdirand> vixey: ok, but semantically, currying + partial application + that trick feels wrong, no ?
09:49:47 <Samy> > let (*) = (,) in (1*2*3*4*5*6*7*8*9^3*10*11*12/13*14*15*16)
09:49:48 <lambdabot>       No instance for (Integral (((t9, t10), t11), t12))
09:49:48 <lambdabot>        arising from ...
09:50:02 <Samy> > let (*) = (,) in (1*2*3*4*5*6*7*8*9**3*10*11*12/13*14*15*16)
09:50:03 <lambdabot>       No instance for (Floating
09:50:03 <lambdabot>                         ((((((((t, t1), t2), ...
09:50:23 <Megzlna> ..infixr
09:50:41 <ozy`> > let (*) = (,); (/) = (:) in (1*2*3*4*5*6/7*8*9*10)
09:50:42 <lambdabot>       No instance for (Num [(((((t, t1), t2), t3), t4), t5)])
09:50:42 <lambdabot>        arising ...
09:51:07 <ozy`> I tried
09:51:09 <lilac> > let (*) = (,) in (1*2*3*4*5*6*7*8*(9^3)*10*11*(12/13)*14*15*16)
09:51:10 <lambdabot>   ((((((((((((((1,2),3),4),5),6),7),8),729),10),11),0.9230769230769231),14),1...
09:51:17 <idnar> Megzlna: use ZipList :P
09:51:26 <chessguy_work> my syntax for tic-tac-toe patterns is getting even cleaner! http://hpaste.org/12970
09:51:37 <idnar> oh, you started with that
09:51:59 <Megzlna> ziplist has too much scaffolding
09:52:57 <lilac> chessguy_work: your .: operator confuses me
09:53:20 <chessguy_work> .: = liftM2 &&
09:53:56 <lilac> chessguy_work: not .: empty ?
09:54:06 <athos> @hoogle (+:)
09:54:07 <lambdabot> Warning: Unknown type +:
09:54:07 <lambdabot> Prelude undefined :: a
09:54:07 <lambdabot> Data.Array.Base arrEleBottom :: a
09:54:11 <chessguy_work> oh, whoops
09:54:19 <athos> :t (+:)
09:54:22 <chessguy_work> yeah, that one should be a different operator
09:54:23 <lambdabot> Not in scope: `+:'
09:54:46 <athos> j. is the "complex number" function: x j. y is x + iy, or xjy in J notation. This is exactly like Haskell's +: function.
09:54:51 <vixey> Ferdirand, yes
09:54:51 <lilac> @type \a b -> a <^(&&)^> b
09:54:52 <lambdabot> Not in scope: `<^'
09:54:52 <lambdabot> Not in scope: `^>'
09:54:53 <athos> is there still some +: function?
09:55:07 <lilac> > 1 :+ 1
09:55:08 <lambdabot>   1.0 :+ 1.0
09:55:21 <athos> hm, so the text messed it up
09:55:24 <athos> thx
09:55:27 <vixey> Ferdirand, I prefer dependent product for polytypic programming
09:55:41 <Ferdirand> vixey: i have no clue what that means :D
09:55:46 <chessguy_work> lilac, the first two .:'s should just be .'s
09:55:49 <athos> :t 3 :+ 2
09:55:51 <lambdabot> forall t. (RealFloat t) => Complex t
09:55:54 <lilac> chessguy_work: that makes more sense :)
09:56:34 <chessguy_work> lilac, good catch
09:56:47 <vixey> Ferdirand, this style http://www.cs.nott.ac.uk/~txa/publ/wcgp02.pdf
09:56:53 <athos> > (3 :+ 2) :* (3 :- 2)
09:56:54 <lambdabot>   Not in scope: data constructor `:*'Not in scope: data constructor `:-'
09:57:15 <mauke> > (3 :+ 2) * (3 :+ (-2))
09:57:16 <lambdabot>   13.0 :+ 0.0
09:57:27 <athos> ah i see :)
09:57:41 <lilac> > 3 :+ -2
09:57:43 <lambdabot>       precedence parsing error
09:57:43 <lambdabot>          cannot mix `(:+)' [infix 6] and prefi...
09:57:46 <lilac> :(
09:58:16 <Samy> vixey, got my book reference?
09:58:17 <chessguy_work> lilac, out of curiosity, can you tell what this pattern defines?
09:58:28 <vixey> Samy, I don't have the book
09:58:36 <vixey> couldn't find a online version ethire
09:58:43 <lilac> chessguy_work: sure. it's looking for winning moves.
09:58:50 <lilac> chessguy_work: (for either player)
09:58:55 <Samy> vixey, it's online
09:59:05 <vixey> not where I looked :/
09:59:07 <chessguy_work> well, i wouldn't define it in terms of move, but yeah
09:59:16 <lilac> chessguy_work: except that it doesn't work. :)
09:59:21 <chessguy_work> oh?
09:59:23 <lilac> chessguy_work: it'll also find triangles
09:59:32 <chessguy_work> oh bugger
10:00:12 <chessguy_work> you're right, of course
10:00:29 <idnar> > let ($<) = \f x -> f <$> ZipList x; (><) = \x y -> x <*> ZipList y; u = getZipList in u $ (,) $< [1,2,3] >< [4,5,6]
10:00:31 <lambdabot>   [(1,4),(2,5),(3,6)]
10:00:33 <Dynetrekk> hi folks. I'm trying to install cabal on Mac OS X, with ghc installed from fink. it fails spectacularly:  http://hpaste.org/12971   <- anyone have an idea about how to fix this?
10:01:05 <mauke> Dynetrekk: truncated
10:01:18 <Dynetrekk> mauke:  check it now
10:01:32 <kazimir> hey guys...is it possible to call more functions than only one in If-then-else statements? Like if x=0 then putStrln"bla" AND map *
10:01:32 <Dynetrekk> mauke:  a few "all is fine" lines in the middle missing though
10:01:43 <idnar> > let x >< y = zip x y in [1,2,3] >< [4,5,6] >< [7,8,9[
10:01:44 <idnar> er
10:01:44 <lambdabot>   <no location info>: parse error on input `;'
10:01:45 <idnar> > let x >< y = zip x y in [1,2,3] >< [4,5,6] >< [7,8,9]
10:01:46 <mauke> Dynetrekk: apparently you're missing libgmp
10:01:47 <lambdabot>   [((1,4),7),((2,5),8),((3,6),9)]
10:01:48 <vixey> kazimir, you can use ==
10:01:53 <Dynetrekk> mauke:  libgmp?
10:01:58 <chessguy_work> lilac, http://hpaste.org/12970#a1
10:01:59 <vixey> kazimir, >> instead of AND
10:02:21 <chessguy_work> bugger, still wrong
10:02:22 <kazimir> okay, i'll will try...ty
10:02:22 <Megzlna> idnar: You used lists
10:02:33 <Dynetrekk> mauke:  how do you check what libraries you have?
10:02:44 <idnar> Megzlna: hmm?
10:02:53 <mauke> Dynetrekk: with equery, generally
10:03:07 <lilac> chessguy_work: depends what 'allAre' does :)
10:03:08 <idnar> Megzlna: I was just suggesting two different approaches for reducing the boilerplate
10:03:19 <pejo> mauke, would his ghc function without gmp?
10:03:24 <Dynetrekk> mauke: no manual entry for equery
10:03:33 <athos> someone here who's into J?
10:03:43 <chessguy_work> well, it should be ("y","z",are sameColor) for one thing
10:03:59 <Dynetrekk> pejo:  I have the library somewhere
10:04:14 <lilac> chessguy_work: what does 'sameColor' say about two empty squares?
10:04:21 <Megzlna> indar: eh sorry, what you did was fine -- except the ((,),) part
10:04:28 <Dynetrekk> pejo:  mauke: /sw/lib/libgmp.a seems to be it_
10:04:29 <Dynetrekk> ?
10:04:33 <chessguy_work> lilac false
10:04:41 <idnar> Megzlna: nested tuples is the only really sane way to generalise N-tuples
10:04:52 <lilac> chessguy_work: in that case, conditions 2 and 3 are covered by condition 4.
10:05:24 <idnar> *are
10:05:29 <chessguy_work> wow, am i like super out of it today or something?
10:05:35 <Dynetrekk> pejo:  mauke: and ghci works like a charm
10:05:44 <kazimir> vixey, but == is just a boolean operator, or isnt it?
10:05:57 <vixey> I don't know what a boolean operator is
10:06:08 <ozy`> :t (==)
10:06:09 <lambdabot> forall a. (Eq a) => a -> a -> Bool
10:06:17 <Megzlna> idnar: Since ghc only does 15-tuples, it wuld be easy to gen the 1-15 in template haskell
10:06:39 <idnar> Megzlna: easy, but ugly
10:06:41 <Dynetrekk> pejo: mauke: fink reports that libgmp is installed as well...
10:06:51 <idnar> although no more ugly than having N-tuples in the first place, I suppose
10:07:02 <Megzlna> {-# LANGUAGE FlexibleInstances, MultiParamTypeClasses, FunctionalDependencies #-}
10:07:44 <pejo> Dynetrekk, there's probably a -L/sw/lib missing from some flags somewhere.
10:07:49 <vixey> {-@ FlipConcatMap @-}
10:07:50 <vixey> :D
10:07:53 <kazimir> i just want to know if its possible to call 2 different functions in 1 line
10:07:57 <vixey> or
10:08:01 <vixey> {-@ Flip, Concat, Map @-}
10:08:11 <pejo> Dynetrekk, see if you can give extra LDFLAGS when you're installing the failing thing.
10:08:13 <Dynetrekk> pejo: hm... and how do I fix that? :P I did this some time ago, it worked like a charm then... confusing
10:08:18 <vixey> kazimir, there really _is no call_ in haskell
10:08:32 <Dynetrekk> pejo: I just write ./bootstrap.sh at the terminal, in accordance to installation instructions
10:08:34 <kazimir> yeah i know...but dont know how to describe it
10:08:47 <pumpkin> kazimir: probably yes
10:08:51 <vixey> kazimir, There is nothing to describe
10:08:55 <Megzlna> kazimir: you can call 2 functions in 1 line
10:09:00 <Megzlna> > 1 + 1 * 2
10:09:01 <lambdabot>   3
10:09:06 <vixey> kazimir, 1 function application is the same as 2
10:09:06 <athos> :t flip
10:09:08 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
10:09:18 <vixey> kazimir, just like how a \x y -> two arg function is 2 one arg functions
10:09:38 <kazimir> wait
10:09:49 <kazimir> i have this:
10:09:51 * pumpkin waits
10:10:05 <kazimir> x==0 = putStr "bla"
10:10:07 <kazimir> and
10:10:07 <Dynetrekk> pejo: the error shows up when "preprocessing library zlib-...."
10:10:15 <pumpkin> kazimir: behind a guard?
10:10:18 <kazimir> x==0 = map
10:10:22 <Dynetrekk> pejo:  do you think it helps if I install zlib separately_
10:10:23 <Dynetrekk> ?
10:10:38 <kazimir> now i got an if
10:10:44 <kazimir> but also trying with guards
10:11:41 <lilac> > let f x | x == 0 = map | otherwise = (reverse .) . f (x-1) in f 7 (+1) [1,2,3]
10:11:43 <lambdabot>   [4,3,2]
10:12:51 <Dynetrekk> what do I do to the "Setup.hs
10:12:55 <pejo> Dynetrekk, it might have an --extra-lib-dirs option when you configure. Or it might respect LDFLAGS if you "export LDFLAGS=-L/sw/lib". I'm not sure.
10:12:58 <Dynetrekk> " file when installing packages?
10:13:04 <Dynetrekk> pejo:  okay
10:13:45 <Dynetrekk> pejo:  LDFLAGS did not work
10:14:13 <chessguy_work> lilac, ok, fixed the logic and made it more type-check-able while i was at it: http://hpaste.org/12970#a2
10:14:14 <Dynetrekk> pejo: can't find a lib dirs option either
10:15:18 <lilac> chessguy_work: what's the type of 'areAll'?
10:15:25 <lilac> 'allAre' rather
10:17:15 <pumpkin> lilac: that function looks handy!
10:17:28 <lilac> pumpkin: hehe :)
10:17:37 <pumpkin> :)
10:18:18 <chessguy_work> lilac, i'm not sure yet. i don't even know what type "is" and "are" have yet :)
10:19:34 <lilac> chessguy_work: when you use pat1, do you extract the matching "x" by name?
10:19:36 <chessguy_work> maybe something like [String] -> a -> Pattern a Bool
10:20:26 <chessguy_work> lilac, i haven't figured out how to "extract" information from the patterns yet
10:20:49 <chessguy_work> right now i'm just trying to figure out what syntax i want to use to write the patterns :)
10:21:01 <lilac> will you require the values you're matching to be homogenous?
10:21:10 <chessguy_work> yes
10:21:22 <chessguy_work> (if i understand your questioin correctly)
10:23:10 <pumpkin> oh no, the haskell proposals is slowing down!
10:23:12 <lilac> if you had "data X = X; data Y = Y; data Z = Z" etc. you could write "pattern [W `is` turn, W `isColor` X, W `isColor` Y, Z `is` empty, (X,Y,Z) `are` onSameLine]"
10:23:24 <lilac> and type-check it still
10:23:51 <chessguy_work> yeah, but i don't want to create new types
10:25:24 <Dynetrekk> so, I installed Cabal now, but I don't have cabal-install (the command line tool) yet.... how do I proceed?
10:26:04 <Samy> install cabal-install
10:26:05 <pumpkin> Dynetrekk: type cabal update
10:26:10 <pumpkin> oh
10:26:10 <Samy> haha
10:26:11 <pumpkin> :P
10:26:14 <Samy> Puppy is barking in his sleep
10:26:16 <pumpkin> I misread it
10:26:19 <Dynetrekk> pumpkin:  -bash: cabal: command not found
10:26:19 * pumpkin needs to wake up more
10:26:34 <Dynetrekk> pumpkin:  the thing is, i NEED cabal.. I don't have problems with it :)
10:26:35 <pumpkin> hey, I'm still groggy!
10:26:42 <Dynetrekk> \me makes coffee
10:26:50 <pumpkin> nah, don't like coffee, that's my problem
10:26:52 <Samy> Wow, dogs have crazy REM.
10:26:58 * Dynetrekk makes white powder
10:27:01 <pumpkin> lol
10:27:23 <Dynetrekk> pumpkin: but, what do I do to get this stuff to compile etc? :P
10:27:38 <pumpkin> Dynetrekk: unpack the cabal-install folder
10:27:43 <Deewiant> runhaskell Setup.hs
10:27:44 <pumpkin> then type sh bootstrap.sh
10:28:16 <Dynetrekk> ~/Desktop/cabal-install-0.6.0 $ runhaskell Setup.hs
10:28:16 <Dynetrekk> no command given (try --help)
10:28:32 <Deewiant> Dynetrekk: you can follow the instructions, right? try --help :-)
10:29:00 <Dynetrekk> Deewiant: uh... we'll see about that! ;)
10:29:09 <chrisdone> sup
10:29:11 <Deewiant> I was too lazy to type out what exactly you have to do
10:29:20 <chrisdone> anyone tried turbinado?
10:29:25 <Deewiant> even though I could have done it by now in less keystrokes than I've taken to explain myself :-P
10:29:32 <Dynetrekk> Deewiant: configure seems to work?
10:29:33 <Dynetrekk> haha
10:29:38 <Deewiant> configure, build, install
10:29:44 <pumpkin> Dynetrekk: or you could try the bootstrap.sh :P
10:29:46 <pumpkin> even simpler
10:29:52 <Dynetrekk> Could not find module `Codec.Compression.GZip'
10:29:54 <Deewiant> oh, he's on Linux
10:29:56 <Dynetrekk> pumpkin: allright... I'll try
10:30:01 <Dynetrekk> Deewiant: mac os x
10:30:02 <Deewiant> bootstrap.sh works there, I hear
10:30:06 <Deewiant> well, not Windows anyway
10:30:08 <pumpkin> works for mac os too
10:30:18 <Dynetrekk> should think so, but...
10:30:18 <pumpkin> it downloads your dependencies for you and everything
10:30:27 <Dynetrekk> yeah.. compiling etc etc...
10:30:43 <Deewiant> Dynetrekk: what bootstrap.sh does for you is install the 'HTTP', 'zlib', and 'network' packages, IIRC
10:30:51 <erikc> can i just send a cabal.exe to someone if they cant build it themselves?
10:30:53 <Dynetrekk> Deewiant: sounds correct, IIRC too
10:31:05 <Dynetrekk> Deewiant: but that fails somehow
10:31:09 <Deewiant> erikc: yes, I think so
10:31:26 <Dynetrekk> Deewiant: Preprocessing library zlib-0.4.0.4...
10:31:26 <Dynetrekk> ld: library not found for -lgmp
10:31:32 <Deewiant> Dynetrekk: if bootstrap.sh fails you can do it manually... get HTTP, build it using Setup.hs, etc.
10:31:35 <Dynetrekk> seems to be the problem?
10:31:42 <Megzlna> @src otherwise
10:31:42 <lambdabot> otherwise = True
10:31:47 <Dynetrekk> Deewiant: I tried, its zlib that fails, but I can`t do that either
10:32:00 <Megzlna> why does otherwise work?
10:32:06 <Megzlna> If it's 'True'
10:32:17 <mauke> because it's true
10:32:19 <Deewiant> because True is what it's supposed to be, think about it :-P
10:32:29 <Dynetrekk> Deewiant: ~/Desktop/zlib-0.5.0.0 $ ./Setup  build
10:32:29 <Dynetrekk> Preprocessing library zlib-0.5.0.0...
10:32:30 <Dynetrekk> ld: library not found for -lgmp
10:32:31 <Megzlna> fine.
10:32:43 <Deewiant> Dynetrekk: don't know what's up there besides the fact that something wants libgmp and isn't finding it :-P
10:32:58 <Megzlna> so long as it comes last ;)
10:33:01 <Dynetrekk> Deewiant: hm... fuckit
10:33:05 <Deewiant> Dynetrekk: you might be able to mess with the .cabal file
10:33:15 <Deewiant> if you have gmp under a different name
10:33:20 <Dynetrekk> Deewiant: mess, yes... but how does THAT help me :P
10:33:24 <Deewiant> Dynetrekk: you /do/ have GMP, right? ;-)
10:33:28 <Dynetrekk> Deewiant: how do I find out?
10:33:31 <Dynetrekk> Deewiant: I have it yes
10:33:47 <Deewiant> I don't know, ls /usr/lib/libgmp* ?
10:33:52 <Dynetrekk> Deewiant: ~ $ fink list | grep gmp
10:33:52 <Dynetrekk>  i 	gmp	4.2.3-1000	GNU multiple precision arithmetic library
10:34:03 <Deewiant> find / -iname "libgmp*" ?
10:34:25 <Dynetrekk> Deewiant: it's in /sw/lib (default fink install)
10:34:34 <Dynetrekk> Deewiant: and "locate" is a bit faster :P
10:34:48 <Dynetrekk> Deewiant: libgmp.la, right?
10:34:52 <Deewiant> Dynetrekk: maybe add something to the .cabal to make it pass -L/sw/lib
10:35:00 <Deewiant> or add /sw/lib to the relevant environment variable
10:35:07 <Deewiant> so that ld looks there
10:35:14 <Dynetrekk> um... which one is that then :P
10:35:22 <Deewiant> LD_LIBRARY_PATH? not sure, man ld :-P
10:35:27 <ozy`> Deewiant, Dynetrekk: what're you guys building? GHC?
10:35:33 <Dynetrekk> ozy`:  libz
10:35:34 <Deewiant> Dynetrekk: he's building zlib
10:35:41 <Deewiant> dammit
10:35:43 <Deewiant> ozy`: ^
10:35:50 <ozy`> doesn't fink have zlib?
10:35:51 <Dynetrekk> no
10:35:54 <Dynetrekk> zlib is right
10:35:58 <Dynetrekk> ozy`:  I'll check
10:36:06 <Deewiant> ozy`: more to the point, he's building cabal-install
10:36:12 <Deewiant> and is currently stuck on the deps
10:36:26 <Deewiant> ozy`: zlib the Haskell package, not zlib the library
10:36:28 <Dynetrekk> ozy`:  not sure...
10:36:36 <pejo> Deewiant, it's normally LDFLAGS for linktime behaviour.
10:36:38 <Dynetrekk> ozy`:  what he said :P
10:36:55 <Dynetrekk> command was: /usr/bin/gcc -lz -L/sw/lib/ghc-6.8.3/lib/bytestring-0.9.0.1.1 -L/sw/lib/ghc-6.8.3/lib/array-0.1.0.0 -L/sw/lib/ghc-6.8.3/lib/base-3.0.2.0 -L/sw/lib/ghc-6.8.3 -lm -lgmp -ldl dist/build/Codec/Compression/Zlib/Stream_hsc_make.o -o dist/build/Codec/Compression/Zlib/Stream_hsc_make
10:36:58 <Dynetrekk> that was the command
10:37:02 <ozy`> someone ought to package cabal-install for fink
10:37:17 <Deewiant> pejo: what about just for adding directories and not general flags
10:37:26 <Dynetrekk> ozy`:  yep.... it seems very reasonable to include, on the web it says ghc 6.8.3 includes cabal!
10:37:45 <pejo> Deewiant, no idea. Everything built just fine for me with a ghc from macports.
10:37:47 <Deewiant> Dynetrekk: is LIBRARY_PATH set? if not, set it to /sw/lib
10:38:02 <Deewiant> Dynetrekk: well, cabal comes with ghc, cabal-install doesn't :-)
10:38:05 <Dynetrekk> Deewiant: good idea - I guess
10:38:09 <pejo> Dynetrekk. cabal and cabal-install are not the same thing.
10:38:11 <Dynetrekk> Deewiant: ah... eh.. okay
10:38:21 <Dynetrekk> cabal-install is the command line tool I guess
10:39:36 <Dynetrekk> ldflags, librarypath, none of those works
10:41:02 <Dynetrekk> ah, this is too hard. why can't it all be easy :P
10:42:08 <saml> cabal install?
10:42:17 <Dynetrekk> saml:  yep
10:42:32 <Dynetrekk> saml: I can't install cabal-install
10:42:36 <Dynetrekk> how ironic
10:42:37 <saml> if build fails, it's hard
10:42:47 <saml> using mac with fink?
10:42:50 <Megzlna> does Cabal even work? -- the only comments I've seen on #Haskell about it are install problems
10:42:56 <Dynetrekk> saml: it fails, yes. mac with fink.
10:43:17 <pumpkin> worked fine for me, using the ghc .pkg on the haskell site
10:43:23 <saml> i find linux is the only way to go
10:43:28 <pumpkin> mac os 10.5
10:43:29 <Dynetrekk> Megzlna: it worked for me before but I carpet bombed my fink with rm because I had so many problems. now fink is fixed, but...
10:43:34 <pumpkin> saml: works fine on mac os :)
10:43:37 <saml> or windows. it has binary installer which worked painlessly as far as i can remember
10:43:41 <Dynetrekk> 10.5 yep. saml: why only linux?
10:43:50 <Dynetrekk> saml: now you're insulting all of creation
10:43:57 <pumpkin> there's a binary installer that works just as fine on mac os
10:43:58 <pumpkin> officially
10:44:11 <GinYuS> Ciao amici di #haskell !!
10:44:13 <Dynetrekk> pumpkin:  where is it? I don't need to fuck around with this :P
10:44:17 <saml> i'm just saying if build fails, it feels bad
10:44:19 <ushdf> > map chr [73,32,99,97,110,39,116,32,108,101,116,32,121,111,117,32,100,111,32,116,104,97,116,44,32,117,115,104,100,102]
10:44:21 <lambdabot>   "I can't let you do that, ushdf"
10:44:37 <Dynetrekk> saml: it does, I agree, but I have the library - it seems
10:44:40 <pumpkin> Dynetrekk: http://www.haskell.org/ghc/download_ghc_6_10_1.html
10:44:50 <saml> i read many problems with cabal-install build in mailinglist.. so i feel your pain. i just don't use it yet
10:44:57 <Dynetrekk> pumpkin: is there a way I can use my fink install?
10:45:02 <saml> ok let me build it now
10:45:06 <pumpkin> Dynetrekk: probably, but this is easier
10:45:27 <Dynetrekk> pumpkin: but that will create new problems, such as maintaining this alongside fink's ghc :P
10:45:29 <pumpkin> gotta go get me a vaccine now, I'll bbl
10:45:36 <pumpkin> Dynetrekk: then get rid of fink's ghc
10:45:44 <sm> morning all
10:45:46 <Dynetrekk> pumpkin:  well, I guess I can do that
10:45:48 <ushdf> don't take the vaccine
10:45:56 <pumpkin> Dynetrekk: what ver of fink ghc do you have?
10:45:58 <pumpkin> 6.10.1?
10:46:16 <Dynetrekk> i 	ghc	6.8.3-1	Glasgow Haskell Interpreter
10:46:24 <saml> darn build failed for zlib
10:46:24 <vixey> morning noon and night :)
10:46:26 <pumpkin> aha, your fink is out of date or something :P
10:46:29 <Dynetrekk> saml: same for me
10:46:33 <redditbot> ELF 0.1: a parser for ELF object files
10:46:33 <redditbot> GHC 6.10 and web programming
10:46:33 <redditbot> Real World Haskell Book Club - reading group for discussing the book Real World Haskell together
10:46:42 <saml> let me install haskell-zlib first then try again
10:46:44 <pumpkin> Dynetrekk: anyway, just grab yourself a newer version
10:46:44 <Dynetrekk> pumpkin:  I updated my fink today. fink doesn't always have the bleeding edge package
10:46:44 <vixey> ugh
10:46:46 <vixey> god
10:46:54 <vixey> who brought this redditbot in
10:46:55 <vixey> ?
10:46:56 <pumpkin> Dynetrekk: then fink fails ;) even macports has 6.10
10:46:58 <Dynetrekk> pumpkin:  is cabal-install included?
10:46:58 <vixey> please remove it :/
10:46:59 <sm> dcoutts: is there a way to clean out packages cabal-install isn't happy with ? eg cabal list says Couldn't read cabal file "./Glob/0.1/Glob.cabal" and cabal install cgi says Couldn't read cabal file "./cgi/3001.1.7.1/cgi.cabal"
10:47:09 <Dynetrekk> pumpkin: but 6.8 should be fine, I would think
10:47:28 <Dynetrekk> it's not that big a deal for me, I think
10:47:46 <pumpkin> Dynetrekk: well, just saying, I have 6.10 and it works, so you might want to try the latest version
10:47:49 <pejo> sm, ghc-pkg unregister unregisters stuff.
10:47:50 <pumpkin> gotta run now :)
10:48:36 <pejo> pumpkin, his problem is that gmp is located in a non-standard directory, and for some reason it's hard to persuade the configure to find it there.
10:48:37 <sm> ghc-pkg lists neither of those packages
10:48:39 <Dynetrekk> pumpkin: okay... good runing
10:48:54 <saml> so i'm installing haskell-cabal, then haskell-zlib, then cabal-install
10:48:57 <Dynetrekk> pumpkin: is that my problem? you sure? no complaining about other libraries...
10:49:09 <sm> I do have three versions of Cabal installed, maybe I should get rid of a few
10:49:12 <Dynetrekk> saml: I tried the same thing but zlib fails still
10:49:20 <saml> how do you read Cabal?  Cabaaahhl ?
10:49:26 <saml> stress on 2nd syllable?
10:49:46 <Dynetrekk> saml: don't know and don't care. I'm not english ;)
10:49:46 * sm <- Cabble
10:49:49 <saml> for haskell-zlib, you need zlib installed. probablly mac comes with it
10:50:03 <quicksilver> saml: Cuhbahl
10:50:04 <Deewiant> kə-bāl'
10:50:06 <pejo> sm, does "cabal update" update the index to one it is happy with?
10:50:10 <quicksilver> (would be the UK english, at least)
10:50:22 <Dynetrekk> saml:  what is zlib? I have gzip and that command line stuff, if that is what you're talking about
10:50:23 <sm> pejo: no
10:50:56 <saml> Dynetrekk, try to find /usr/lib/libz.a  or something
10:51:13 <saml> and /usr/include/zlib.h   if they are there, you have zlib i think
10:51:23 <Dynetrekk> saml: /usr/lib/libz.dylib
10:51:34 <saml> ay right mac ends with .dylib
10:51:42 <Dynetrekk> saml: for example
10:51:45 <saml> i'm still building CAbal
10:51:55 <Dynetrekk> saml: really? that long?
10:52:01 <saml> how onto haskell-zlib
10:52:17 <pejo> saml, wasn't his problem that it couldn't find gmp though?
10:52:28 <Dynetrekk> yep it was
10:52:49 <saml> <interactive>: internal error: loadObj: can't map `/usr/lib/ghc-6.8.2/lib/unix-2.3.0.0/HSunix-2.3.0.0.o
10:53:10 <saml> darn i get this error sometimes for some haskell packages
10:53:13 <Chip_Grandits> I have a very basic question about the Enum class
10:53:30 <orbitz> Chip_Grandits: only intermediate questions allowed here
10:54:06 <saml> pejo, Dynetrekk ah sorry.
10:54:50 <saml> Chip_Grandits, we can't guess your question. {-# LANGUAGE MindReading #-} not included yet
10:54:53 <sm> hmm, maybe I will have less trouble with ghc 6.10 from this point on
10:55:06 * sm downloads
10:55:20 <Chip_Grandits> In many places it is stated that the dot-dot syntax works by virtue of being a member of enum class (e.g. ['a'..'z'] )
10:55:58 <byorgey> Chip_Grandits: right
10:56:11 <Chip_Grandits> But if I declare my own class deriving enum, it does  not appear to work e.g. data MyEnum One | Two | Three deriving (Show,Enum)
10:56:11 <saml> > [x .. z]
10:56:12 <lambdabot>   * Exception: not a number
10:56:45 <saml> i think you should implement succ function
10:56:55 <Chip_Grandits> If I then try [One..Three] I would expect to get [One,Two,Three] but I get "Failed to load interface "One""
10:57:06 <Dynetrekk> and noone knows how to get the bloody gmp into the cabal's brain, and so on and so on?
10:57:10 <byorgey> failed to load interface!?
10:57:14 <byorgey> that's a strange error
10:57:16 <ksf> try spaces between One and .. ?
10:57:21 <DrSyzygy> > ['x' .. 'z'}
10:57:22 <lambdabot>   <no location info>: parse error on input `}'
10:57:24 <DrSyzygy> > ['x' .. 'z']
10:57:25 <ksf> syntax confusion ho!
10:57:25 <lambdabot>   "xyz"
10:57:30 <byorgey> ah, that must be it!
10:57:35 <ksf> . is the module seperator.
10:57:48 <Chip_Grandits> Thank You ksf! That was the issue!
10:57:56 <dcoutts> Dynetrekk: cabal knows nothing about gmp, it is ghc that is supposed to know.
10:58:13 <dons> ?users
10:58:13 <lambdabot> Maximum users seen in #haskell: 578, currently: 557 (96.4%), active: 23 (4.1%)
10:58:19 <Dynetrekk> dcoutts: okay, but what would your answer be if I asked the question I was supposed to?
10:59:01 <agcorona> peace, people
10:59:14 <dcoutts> sm: easiest thing to do is to upgrade cabal-install, at some point we'll make it deal better with packages that need a newer Cabal version than the one you're using.
10:59:42 <agcorona> I have problems compiling plugins 1.3.1 in windows
10:59:50 <sm> I thought I had the latest, but maybe not.. installing ghc 6.10 now
11:00:08 <agcorona> configure: error  C compiler cannot create executables
11:01:01 <ksf> actually, the parser should be able not to confuse .. as in enum and . as in X.foo, the former can't be a single dot and the latter not two dots.
11:01:01 <saml> if there's windows readline, would ghci on windows have tab completion?
11:01:54 <olsner_> ksf: f Prelude.. g
11:01:55 <dcoutts> Dynetrekk: it's the responsibility of the ghc packaging. Eg if you got ghc from macports then report it, if you got it from the installer then report that. If you installed manually then make sure you set up the environment and ./configured right.
11:02:14 <Chip_Grandits> ksf, so you are saying you think ghc should, in principle be capable of interpreting [One..Three] as [One .. Three] ?
11:02:35 <dcoutts> Dynetrekk: how did you install ghc (OSX I'm guessing?) and where is the gmp lib really?
11:02:36 * ksf read something on the h' pages about changing that to Prelude.(.)
11:02:43 <ksf> makes sense, imo.
11:02:45 <saml> Chip_Grandits, put spaces.
11:02:50 <Dynetrekk> dcoutts: I got ghc from fink. ghc works fine, it seems. gmp lib is also installed by fink and is in /sw/lib
11:03:10 * sm installs 6.10 painlessly. I hereby resolve to install no packages in ~/.cabal
11:03:10 <Dynetrekk> dcoutts: -rw-r--r--  1 root  admin   503K Nov  8 13:43 /sw/lib/libgmp.a
11:03:23 <dcoutts> Dynetrekk: then fink should have set up ghc to use /sw/lib as a default linker dir.
11:03:26 <ksf> qualified infix ops are ugly, anyway.
11:03:33 <proq> the gmp lib built and installed fine for me without fink
11:03:38 <Dynetrekk> dcoutts: sounds perfectly reasonable.
11:03:47 <dcoutts> Dynetrekk: in the mean time you can hack it. Re-register the rts package with that as an extra lib dir.
11:03:51 <Dynetrekk> dcoutts: but, other libraries compile fine
11:04:02 <Chip_Grandits> Thanks all - simply remembering the spaces is a perfectly fine solution for me, see ya..
11:04:07 <Dynetrekk> rts package? lib dir? I'm sorry, but this is over my head :(
11:04:39 <dcoutts> Dynetrekk: ah, hmm. I see, it was Cabal calling hsc2hs that failed.
11:05:00 <Dynetrekk> dcoutts: in fact, to me it seems that zlib installation failed due to a missing gmp library
11:05:02 <chrisdone> dons: hey this turbinado is a pretty cool project, eh?
11:05:14 <dons> yup!
11:05:25 <dcoutts> Dynetrekk: yes, if you look at the failure you see that it is cabal calling hsc2hs and that invocation fails.
11:05:36 <Dynetrekk> dcoutts: ok, wait a sec then..
11:05:46 <chrisdone> glad someone who knows their stuff about the .NET/Rails framework type-ish thingie are working on it
11:06:22 <Megzlna> the poor www
11:06:39 <Dynetrekk> dcoutts: where do you see hsc2hs
11:06:52 <Dynetrekk> what does it do, etc... I know nothing about it :p
11:06:54 <chrisdone> needs documentation which I may write myself if I have time
11:07:12 <chrisdone> Megzlna: ?
11:07:33 <dcoutts> Dynetrekk: the lines below the one where it says cannot find -lgmp
11:08:01 <Dynetrekk> dcoutts: what do I do about it? to me it seems non-causal that the error is not from the _first_ line of errors
11:08:27 <dcoutts> Dynetrekk: and the gcc command that hsc2hs calls is not using -L/sw/lib
11:08:40 <Dynetrekk> dcoutts: I agree with you on that!
11:09:02 <Dynetrekk> dcoutts: in fact I tried to run the command with -L/sw/lib, and that worked, but so what.... I don't know how to fix it, even so
11:09:18 <agcorona> who is the hs-plugins  maintainer now?
11:09:26 <BONUS_> hmm a friend asked me this, pretty interesting problem: make a function that takes as its first parameter a number of params and then that number of params and adds them together
11:09:39 <BONUS_> so, you'd have magic 3 9 8 7 = 9 + 8 + 7
11:09:56 <BONUS_> magic 3 9 8 = error
11:09:58 <BONUS_> etc
11:10:04 <BONUS_> you think this is possible to do with the type system?
11:10:25 <saml> how about magic 3 [9,8,7] ?
11:10:32 <BONUS_> nah, thats trivial
11:10:40 <saml> i'm a trivial person
11:10:43 <BONUS_> haha
11:10:51 <Dynetrekk> dcoutts: do you have any idea how to fix it, then
11:10:53 <Dynetrekk> ?
11:10:54 <ksf> is that friend called oleg and playing tricks on you?
11:11:02 <BONUS_> lol
11:11:06 <BONUS_> haha, maybe in disguise
11:11:06 <Megzlna> why must the  x:xs be parenthesized in f (x:xs) = ...
11:11:15 <mauke> BONUS_: sounds like printf
11:11:15 <ski_> (wouldn't `magic 3 9 8' then be the "add seventeen" function ?)
11:11:26 <mauke> Megzlna: because otherwise it's parsed as (f x) : xs
11:11:31 <BONUS_> ski hmm or that could work too
11:11:36 <BONUS_> it would yes
11:11:47 <dcoutts> Dynetrekk: so it looks like ghc adds -L/sw/lib but the rts package is missing it
11:11:58 <idnar> Megzlna: function application binds more tightly than anything else
11:12:09 <Dynetrekk> dcoutts: could be?.... but I don't understand how to proceed to fix it
11:12:14 <saml> so  (magic n) :: a1 -> a2 -> .... -> aN
11:12:23 <BONUS_> yeah
11:12:27 <ski_> (possibly you could do a version in which `magic () 9 8 :: Int' is `17' and `magic () 9 8 :: Int -> Int' is the aformentioned function ..)
11:12:36 <BONUS_> magic 3 = \a b c d -> a + b + c + d
11:12:44 <Megzlna> k
11:12:49 <BONUS_> i mean 4
11:12:52 <idnar> ski_: sounds like printf
11:13:02 <saml> :src printf
11:13:07 <saml> @src printf
11:13:07 <lambdabot> Source not found. Just try something else.
11:13:08 <BONUS_> yeah but taking the number of parameters is the schtick
11:13:14 <dcoutts> Dynetrekk: what does this report: ghc-pkg field rts library-dirs
11:13:28 <idnar> BONUS_: why bother taking the number of parameters?
11:13:43 <Dynetrekk> dcoutts: ~ $ ghc-pkg field rts library-dirs
11:13:43 <Dynetrekk> library-dirs: /sw/lib/ghc-6.8.3
11:13:55 <Dynetrekk> dcoutts: so seems it misses /sw/lib
11:13:57 <BONUS_> probably so you dont have to terminate it with a type
11:14:11 <ski_> (BONUS_ : maybe you should tell your friend to go take a look at Coq/Epigram/Agda ..)
11:14:18 <saml> how come http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Printf.html#v:printf   these links don't have Source links anymore?
11:14:22 <Dynetrekk> dcoutts: put a symlink in the directory? easy hack, but a hack..
11:14:25 <saml> it was so useful
11:14:35 <idnar> BONUS_: the value of that parameter can't influence type checking, though
11:14:39 <idnar> as far as I can tell
11:14:44 <dcoutts> Dynetrekk: ok, so do ghc-pkg describe rts > rts.pkg; edit the rts.pkg to add the dir and then ghc-pkg update rts.pkg
11:14:46 <BONUS_> yeah thats what im thinking too
11:14:47 <idnar> so all you'd be able to do with it is perform a runtime check, and error out
11:15:02 <ski_> BONUS_ : what should `main = getLine >>= \s -> .. (magic (read s)) ..' do ?
11:15:04 * sm upgrades to cabal-install 0.6.. lovely!
11:15:08 <idnar> which is silly when you could just perform the operation corresponding to the type that ended up being used
11:15:09 <saml> it's maybe dependent typing
11:15:19 <BONUS_> yeah, you're right
11:15:27 <Dynetrekk> dcoutts: where in the file?
11:15:37 <Dynetrekk> library-dirs: /sw/lib/ghc-6.8.3 possibly... but how to add one
11:15:55 <BONUS_> hmm wait why doesnt this work http://hpaste.org/12973
11:16:00 <BONUS_> the magic part
11:16:03 <BONUS_> concat works
11:16:28 <dcoutts> Dynetrekk: yep, library-dirs: just add the extra dir. I think either space or , will do
11:16:37 <xahlee> sorry for a stupid question... how to print 5;?
11:16:38 <Dynetrekk> dcoutts: trying the space then
11:16:39 <Megzlna> if I do,   f (x:xs) = 1   does ghc optimize the xs away the same way as if it had been a _   ?
11:17:09 <Dynetrekk> dcoutts: permission denied. sudo?
11:17:09 <ski_> xahlee : `putStr "5;"'
11:17:12 <idnar> Megzlna: it has to match against the constructor, at least
11:17:13 <xahlee> am trying to test this code: normalize vec = map (/ (sqrt (sum (map (^2) vec)))) vec
11:17:13 <xahlee> print normalize([3,4])
11:17:15 <dcoutts> Dynetrekk: yep
11:17:21 <idnar> Megzlna: so that f [] is a pattern match failure
11:17:27 <Dynetrekk> dcoutts: done
11:17:50 <Dynetrekk> dcoutts: trying the bootstrap script now
11:17:54 <dcoutts> Dynetrekk: check that "ghc-pkg field rts library-dirs" reports what you expect now
11:17:55 <ski_> xahlee : probably that should be `print (normalize [3,4])'
11:18:12 <Dynetrekk> dcoutts: ~/Desktop/tmp $ ghc-pkg field rts library-dirs
11:18:13 <Dynetrekk> library-dirs: /sw/lib/ghc-6.8.3 /sw/lib
11:18:32 <Dynetrekk> dcoutts: allright! cabal successfully installed etc etc victory, man over machine +++
11:18:37 <ksf> let norm = map (/ (sqrt $ sum (map (^2) vec))) in norm [3,4]
11:18:54 <xahlee> ski_: it says parser error at the last char
11:18:55 <ksf> > let norm = map (/ (sqrt $ sum (map (^2) vec))) in norm [3,4]
11:18:56 <lambdabot>   Not in scope: `vec'
11:19:03 <ksf> > let norm vec = map (/ (sqrt $ sum (map (^2) vec))) in norm [3,4]
11:19:05 <lambdabot>       Overlapping instances for Show ([t] -> [t])
11:19:05 <lambdabot>        arising from a use o...
11:19:21 <ksf> > let norm vec = map (/ (sqrt $ sum (map (^2) vec))) vec in norm [3,4]
11:19:23 <lambdabot>   [0.6,0.8]
11:19:23 <ski_> xahlee : the `print ..' part should be inside some action, such as `main = print ..'
11:19:35 <ksf> > let norm vec = map (/ (sqrt $ sum (map (^2) vec))) vec in norm [1,1]
11:19:37 <lambdabot>   [0.7071067811865475,0.7071067811865475]
11:19:45 <ksf> > let norm vec = map (/ (sqrt $ sum (map (^2) vec))) vec in norm [1,0]
11:19:47 <lambdabot>   [1.0,0.0]
11:19:51 <ksf> > let norm vec = map (/ (sqrt $ sum (map (^2) vec))) vec in norm [10,0]
11:19:51 <ski_> (xahlee : or just write the `print ..' in the interactor)
11:19:53 <lambdabot>   [1.0,0.0]
11:19:53 <Dynetrekk> dcoutts: thanks man!
11:19:57 <Megzlna> @src length
11:19:58 <lambdabot> Source not found. Are you on drugs?
11:20:17 <saml> > print 5
11:20:18 <lambdabot>   * Exception: "<IO ()>"
11:20:19 * xahlee ... umm... let me work on it a bit. thanks for all the tips
11:20:31 <Dynetrekk> dcoutts: eh... now this fails: lib/Data/Packed/Internal/Common.hs:25:7:
11:20:32 <Dynetrekk>     Could not find module `Foreign.Storable.Complex':
11:20:32 <Dynetrekk>       Use -v to see a list of the files searched for.
11:20:32 <Dynetrekk> cabal: Error: some packages failed to install:
11:20:32 <Dynetrekk> hmatrix-0.5.0.1 failed during the building phase. The exception was:
11:20:32 <Dynetrekk> exit: ExitFailure 1
11:20:45 <ksf> xahlee, the fastest way to do it is to load the module into ghci and call the fuction from the prompt.
11:21:05 <mauke> grr, why isn't xahlee banned here?
11:21:10 <ski_> xahlee : i.e. i'm assuming you're putting this in a source file .. there you can't put actions at the toplevel .. only definitions and declarations of various kinds
11:21:20 <xahlee> ksf: i'm simply trying to verify that code works...
11:21:30 <xahlee> ski_: k
11:21:32 <dcoutts> Dynetrekk: that's an unrelated error I think
11:21:33 <ksf> it does. move on ;)
11:21:47 <Dynetrekk> dcoutts: I think too, but I thought cabal was supposed to make installation easy :P
11:23:03 <dcoutts> Dynetrekk: So have you got storable-complex installed?
11:23:20 <Dynetrekk> dcoutts: no idea... doesn't cabal tell you if you need other libraries?
11:23:37 <dcoutts> Dynetrekk: my guess is that it is installed but for some reason the files got deleted
11:23:43 <dcoutts> Dynetrekk: ghc-pkg list storable-complex
11:23:54 <Dynetrekk> dcoutts: I installed it, now it works
11:24:04 <dcoutts> hmm
11:24:31 <Dynetrekk> dcoutts: hamtrix worked after installing storable-complex
11:24:44 <dons> Dynetrekk: were you using 'cabal install' ?
11:24:50 <dcoutts> hmatrix depends on storable-complex
11:24:58 <Dynetrekk> cabal install hmatrix
11:25:08 <dcoutts> so it should either have already been installed or it was installed but broken
11:25:20 <Dynetrekk> dcoutts: now it seems ok
11:25:34 <Dynetrekk> dcoutts: remind me: how do I check if it imports correctly in ghci?
11:26:03 <dcoutts> Dynetrekk: so if you do ghc-pkg list storable-complex what versions does it say you've got?
11:26:08 <leimy> What happened to that "haskell platform" thing?
11:26:19 <dcoutts> leimy: dons and I are working on it
11:26:28 <Dynetrekk> dcoutts: ~ $ ghc-pkg list storable-complex
11:26:28 <Dynetrekk>     storable-complex-0.1, storable-complex-0.2
11:26:29 <leimy> dcoutts: cool!
11:26:45 <sm> dcoutts, dons, the world cries out! we need your superpowers yet again! :)
11:27:02 * leimy turns on his lambda signal
11:27:20 <dcoutts> Dynetrekk: so here's my theory. You've had storable-complex-0.1 installed, however you'd accidentally deleted it's files (eg by doing rm -r ~/.cabal ?).
11:27:31 <Megzlna> Why is:
11:27:33 <Megzlna> [a+b | (a,b) <- [(1,1), (1,2), (2,1), (2,2)]] :: (Num t) => [t]
11:27:35 <Megzlna> rather than:
11:27:36 <Heffalump> can anyone point me at any references on solving systems of integer linear constraints?
11:27:55 * Megzlna nix
11:27:56 <Dynetrekk> dcoutts: maybe a little rm-ing, yes... sorry :P
11:28:08 <dcoutts> Dynetrekk: so when you did cabal install hmatrix, cabal thought storable-complex-0.1 was installed, but when ghc tried to use it the files were missing. Then when you did cabal install storable-complex it installed version 0.2 which is thus not broken any more.
11:28:16 <hydo> dcoutts: in that case, I kill ~/.ghc and reinstall the packages I had in ~/
11:28:19 <Dynetrekk> dcoutts: makes sense. thanks!
11:28:27 <dcoutts> hydo: yes, that'll do it
11:28:33 <leimy> nice
11:28:55 <hydo> then again, I've found far less headaches by installing everything --global
11:29:08 <Dynetrekk> dcoutts: how do I check that the package works in GHCI? (in python I would do import modulename)
11:29:15 <dancor> global++
11:29:21 <dcoutts> Dynetrekk: :m ModuleName
11:29:31 <hydo> global++ # agreed.
11:29:40 <jiyunatori> hi there. I've just started playing with hopengl, following the tutorial. It works up to the animation part. at this point, the thing won't move unless I resize the window.
11:29:55 <Dynetrekk> dcoutts: import seems to work as well :P I just used the wrong module name...
11:30:39 <dcoutts> Dynetrekk: oh, 'import' in ghci is new in 6.10. :module was the previous supported syntax
11:30:40 <sm> dcoutts is having to support  a nightmarish system of state - the collective filesystem of haskell users
11:30:46 <vixey> jiyunatori, probably missing some glFlush
11:31:07 <Dynetrekk> dcoutts: I have 6.8 but works here too
11:31:10 <sm> wasn't there some pure/functional package management system ? himerge ?
11:31:11 <dcoutts> sm: the next ghc version will report these bugs better and ghc-pkg check will look for missing package files.
11:31:12 <pejo> Heffalump, as in "Integer Linear Programming"?
11:31:18 <vixey> Heffalump, CLP style solvin?
11:31:33 <dcoutts> sm: himerge is araujo's gtk ui for gentoo's package manager
11:31:45 <vixey> the Oz book it pretty thorough on this
11:32:20 <pejo> sm, I think you're thining of the one used in NixOS, but don't know what the package manager is called.
11:32:20 <Heffalump> I have constraints like a + b >= 0.
11:32:54 <vixey> Heffalump, and you want to write a solver in haskell ?
11:32:58 <Heffalump> vixey: yep
11:33:00 <sm> cool. Might/should ghc-pkg and cabal ever merge a bit ? I am never completely clear on where the boundary of responsibility is
11:33:06 <jiyunatori> vixey: at the end of my display callback there is the command "flush".
11:33:13 <Heffalump> well, not a solver, a simplifier.
11:33:23 <ushdf> that's half a solver
11:33:24 <Dynetrekk> dcoutts: is it possible to "clean out" the install in a reasonable way, to start anew with cabal?
11:33:28 <ushdf> all you need is a complexifier ;)
11:33:30 <dons> Heffalump: can you encode it as a SAT problem or something, and feed it to a generic constraint solver?
11:33:45 <Heffalump> I don't know how to encode it as SAT, since the domain is infinite.
11:34:08 <Heffalump> also, I just want to simplify, not solve; the problems aren't completely constrained
11:34:23 <sm> Dynetrekk: I just did that via: upgrade to ghc-6.10, mv ~/.cabal ~/.cabal.old, follow the bootstrap at http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
11:34:30 <Heffalump> one example of a problem is a >= b + c ; c >= d + a ; b >= 0 ; d >= 0
11:34:46 <vixey> so you just want the propogate part of propogate-and-search
11:34:54 <Heffalump> it's obvious to me that this implies that a = c and b = d = 0, but I need to get a computer to find that out
11:34:58 <Dynetrekk> sm: oh no, I just installed cabal, but it remembers some stuff from previous install
11:35:00 <Dynetrekk> somehow
11:35:14 <ushdf> heffalump: follow your own thought process
11:35:35 <Heffalump> ushdf: that's fine, but I need a general procedure
11:35:43 <ushdf> that's what i mean
11:35:44 <Heffalump> and my thought process is not a general procedure
11:35:47 <ushdf> analyze your thought to create the procedure
11:36:04 <Heffalump> I've tried that. I think it involves exponential complexity.
11:36:15 <Heffalump> I'm sure this must be a well understood problem.
11:36:16 <ushdf> so find a shortcut that always applies ;)
11:36:42 * Heffalump is hoping someone else has already done that, hence my request for literature#
11:37:04 <ushdf> heh
11:37:13 <vixey> Heffalump, you can store domains too, like  b in intersection [[0..inf]], then just bash together enough propagators (like  a >= sum (x,y,z) --> a >= max x y z /\ a >= min x y z etc..)
11:37:20 <pejo> ushdf, he wants to solve a problem, not publish a paper.
11:37:35 <ushdf> same thing
11:37:42 <ushdf> the paper just tells people about your solution
11:37:44 <Heffalump> vixey: that assumes they are confluent
11:37:46 <vixey> ushdf, it's not obvious that you're actually trying to help
11:37:53 <ushdf> oh well, i am
11:38:04 <Heffalump> I don't really need help in learning how to think, thanks.
11:38:20 <ushdf> i can tell you don't, that's why you can solve the problem
11:38:28 <Heffalump> I need concrete advice about this particular problem, either directly or from the literature.
11:38:43 <camio> http://hpaste.org/12974. I'm looking for suggestions between a couple variations of data types or any other ideas with this code snippet.
11:38:48 <vixey> Heffalump, (what I said is just what they outline in CTM)
11:39:01 <ushdf> in that case i have nothing to offer you but ambiguous guidance
11:39:04 <Heffalump> vixey: CTM?
11:39:08 <glguy> Does the /bans
11:39:11 <vixey> except the next stage is to divide up cases and propagate again, until you have solved it
11:39:34 * ushdf frowns
11:39:35 <Dynetrekk> dcoutts: do you know how to clean out my cabal packages and reinstall? I'm getting all sorts of error messages from packages supposed to be installed, presumably from my rm-ing
11:39:41 <vixey> i.e. you can split things like  x in [-inf..inf] to  x in [-inf..0]  or  x in [0..inf]
11:39:42 <ski_> Heffalump : Concepts, Techniques and Models of Computer Programming, iirc
11:39:47 <Heffalump> ushdf: to be honest, your advice so far has consisted of stating the obvious.
11:40:03 <ski_> (Peter van Roy et. al.)
11:40:08 <Heffalump> thanks
11:40:08 <ushdf> ok then
11:40:12 <ushdf> glad we're on the same track
11:40:15 * vixey thinks every time you mention "ushdf" .. they feel compelled to say something (regardless of informational content)
11:41:16 <Heffalump> does anyone know what the precise name for what I'm describing is?
11:41:23 <saml> BONUS_, http://okmij.org/ftp/Haskell/vararg-fn.lhs  maybe this will let you do magic
11:41:28 <vixey> Heffalump, I am not sure if it's CHR (which CLP) is implemented on that ensures confluence .. or if it's the programmer though
11:41:36 <vixey> Heffalump, CLP..
11:41:44 <vixey> or just constraint solving
11:41:45 <Heffalump> vixey: isn't that rather more general?
11:41:54 <vixey> like I said, you're doing the first half
11:41:56 <Heffalump> I know it's constraint solving, I mean the precise domain of my problem :-)
11:42:04 <vixey> it's propogate and search but you are doing just propogate
11:42:08 <Heffalump> constraint solving is a large area
11:42:16 <vixey> over integers.. :)
11:42:31 <Heffalump> yes, thank you :-p
11:43:38 <Dynetrekk> anyone else know how to clean out packages / make cabal forget the installed stuff?
11:44:06 <sm> what's wrong with my suggestion ?
11:44:10 <pejo> Heffalump, do you have other operations than +?
11:44:12 <vixey> Heffalump, but honestly I think it's just straight forward mostly, except for the simplex algorithm
11:44:12 --- mode: ChanServ set +o dons
11:44:15 <Heffalump> pejo: -
11:44:24 --- mode: dons set +b %*!*@syru217-183.syr.edu
11:44:34 <Heffalump> vixey: the simplex algorithm is about maximising a fitness function, isn't it?
11:44:37 --- mode: ChanServ set -o dons
11:44:37 <Heffalump> dons: that seems like overkill
11:44:52 <dons> this was discussed yesterday. its effectively evasion.
11:45:01 <Heffalump> pejo: literals, variables, +, -, >=, =
11:45:06 <Heffalump> and logical connectives
11:45:26 <vixey> Heffalump, I've read that simplex is used in CLP solvers in some book I can't remember the name of..
11:45:40 <Heffalump> ok, I'll dig around some more, thanks for the pointers.
11:45:54 <Heffalump> I have to go for dinner shortly but will be back in a bit and will read scrollback.
11:45:55 <vixey> but I don't think you would need to implement _that_ beast
11:46:04 <Heffalump> yeah, I'd quite like not to need to :_)
11:46:16 <Dynetrekk> Heffalump: simplex? linear programming? check out gnu linear programming kit, possibly?
11:47:02 <paolino> seen that in linear vector machines, or something
11:47:16 <Dynetrekk> I can't use the legendre function in hmatrix package:Loading package hmatrix-0.5.0.1 ... can't load .so/.DLL for: gsl (dlopen(libgsl.dylib, 10): image not found)
11:47:42 <Yokisho> image not found :P
11:48:16 <paolino> support vector machines
11:53:31 <blueonyx> hi
11:55:12 <Dynetrekk> anyone know how to completely clean out single packages / whole install with cabal?
11:56:50 <blueonyx> how should the Build-Depends field look like when i get "...  it is a member of package base-3.0.3.0, which is hidden"?
12:00:41 <tomh> are there special facilities in haskell to talk to c/c++ apps?
12:01:02 <glguy> tomh, Haskell has a C FFI
12:01:07 <Dynetrekk> I am shocked.
12:01:16 <tomh> ok gonna look for that to see how that works
12:01:26 <glguy> Dynetrekk, uninstall isn't part of cabal-install :)
12:01:37 <Dynetrekk> glguy: I knooow... but I want to uninstall
12:01:40 <scoo4114> karma
12:01:42 <Nafai> tomh: The FFI is actually quite easy.
12:01:49 <glguy> Dynetrekk, you'd unregister with "ghc-pkg unregister"
12:01:56 <Dynetrekk> glguy: actually, I want it to Just Work. but it doesn't. it complains and complains.
12:01:56 <glguy> Dynetrekk, and you'd delete files in ~/.cabal
12:02:04 <lucca> Dynetrekk: you can unregister... to uninstall, make sure you install each thing into a different location
12:02:05 <Dynetrekk> glguy: okay, thanks...
12:02:09 <lucca> so that you can just remove the directory
12:02:15 <tomh> you can also talk to c++ or just c?
12:02:22 <tomh> or maybe objective-c :)
12:02:45 <scoo4114> karma scoo4114
12:03:01 <scoo4114> :t 'c'
12:03:02 <lambdabot> Char
12:03:09 <Nafai> tomh: http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html
12:03:16 <Dynetrekk> lucca:  okay, thanks
12:03:18 <Nafai> tomh: Just C, as far as I'm aware, but I could be mistaken
12:03:47 <Gracenotes> hi, problem with my own cabal set-up running bootstrap.sh in Ubuntu 8.04: "Setup: At least the following dependencies are missing: HTTP >=3000 && <3002, network >=1 && <3. Sorry, something went wrong."
12:04:00 <tomh> ok, thanks for the pointer
12:04:07 <scoo4114> modules
12:04:10 <tomh> else i just use thrift :)
12:04:10 <ksf> c++ is a bugger to interface to for lack of binary compability.
12:04:19 <Megzlna> if I use a where clause with a numeric or string literal, will it be constant folded into storage in my executable/lib ?
12:04:20 <Gracenotes> any idea what went awry?
12:04:25 <ksf> the best thing to do is to write a small c wrapper around that c++ stuff.
12:04:34 <tomh> thrift or protocol buffers will solve it in that case
12:05:22 <Megzlna> rather, constant folded OR go into storage
12:05:22 <ksf> Megzlna, how else should it be done?
12:05:34 <Megzlna> one of the two
12:05:43 <ksf> depends on size.
12:05:53 <Megzlna> DWORDS are folded
12:05:56 <Megzlna> all others in storage.
12:05:56 <Megzlna> ?
12:06:06 <Megzlna> (on 32 bit ghc)
12:06:13 <ksf> otoh, you won't ever see a 0 even as a constants, it's xor rax, rax.
12:06:32 <ksf> just go looking at the assembly if you care, that's all implementation-dependant.
12:06:36 <Megzlna> because the ALU pairs better
12:06:40 <Megzlna> but that's not specific to haskell
12:06:48 <Megzlna> all compilers do that
12:07:00 <ksf> ...and if you don't like what you see, hack on ghc.
12:07:02 <pejo> Megz, I think you worry too much about low level details, or do you actually have profiling data that backs this part of the code as a performance problem?
12:07:16 <Megzlna> I'm not worried about anything
12:07:37 <Megzlna> Except newbie questions
12:08:53 <Megzlna> So you might rephrase your question with:
12:09:03 <vixey> nah you're asking interesting questions
12:09:12 <Megzlna> Megzlna, I think you ask questions related to things I don't personally care to know the answer to.
12:09:49 <vixey> Megzlna, I don't think anyone knows.. GHC is so huge and complicated.....
12:09:54 <ksf> I do care about such stuff, but not in general, only in tight loops after i've spotted a hot spot.
12:10:07 <vixey> Megzlna, you can inspect compiler output and build an intuition but I don't think there's guarantees anywhere
12:10:11 <ksf> premature opimisation is the root of all evil.
12:10:42 <Megzlna> It's not really optimization, just... when I learned C, I learned what goes in the COMDAT, etc.
12:11:01 <Megzlna> the use for BSS
12:11:11 <sm> Megzlna: you may find ch. 25 of real world haskell interesting, it tells how to examine ghc core so you can find out such things
12:11:25 <Megzlna> sm: cool
12:11:35 * sm points to dons
12:11:39 <ksf> so, now you're learning haskell, you can learn lazy and eager evaluation inside and out. higher-level language, higher-level low-level details.
12:12:37 <ksf> like finally caring about the difference between O(n^2) and O(2^n), if you didn't already.
12:13:41 <pejo> Megz, your question is about how the simplifier in your compiler behaves. Here's a paper about the GHC one: http://research.microsoft.com/en-us/um/people/simonpj/papers/inlining/inline-jfp.ps.gz
12:13:55 <Megzlna> thx
12:14:15 <scoo4114> :h
12:14:54 <Megzlna> a thunk in your trunk
12:15:26 <ksf> so you can claim that the copper killed the corpse as he opened it...
12:16:17 <Megzlna> ksf: explain? Why?
12:16:23 <Megzlna> does evaluating a thunk invalidate it?
12:17:17 <ksf> dunno what you mean by invalidating, but evaluating it effectively replaces its code with a constant.
12:17:30 <Megzlna> the corpse part
12:17:33 <ksf> yeah.
12:17:48 <ksf> ...and the copper forced the thunk, so he's the killer.
12:18:02 <Megzlna> why do you consider a unevaluated thing to be 'alive' ?
12:18:22 <ksf> now you're stretching the metaphor.
12:18:38 <ksf> it's more of a schroedinger's cat thingie.
12:18:47 <augustss> howdy!
12:19:08 <vixey> hi :)
12:19:10 <ksf> ...which is what can happen when you use FRP.
12:19:26 <geezusfreeek> huh?
12:19:31 <vixey> hey
12:19:36 <vixey> I read your post about ML modules
12:19:42 <ksf> ...where the cat is neither alive nor dead until you open the thunk and have a look.
12:19:45 <vixey> that was very interesting
12:19:48 <vixey> someone mentioned it here
12:20:10 <augustss> I'm the ML lover!
12:20:14 <vixey> haha
12:20:29 <augustss> I'll be banned from #haskell
12:20:31 <geezusfreeek> ksf: why the reference to FRP specifically when talking about thunk evaluation there?
12:21:06 <ozy`> augustss: nah, more likely someone will take your comments and run with them, and write a GHC extension for a more reflexive module system
12:21:10 <Megzlna> #ML has 0 users
12:21:13 <vixey> and not the first ._.
12:21:15 <ksf> because I couldn't figure out, a priori, how to fit a time function like radioactive decay into haskell w/o FRP.
12:21:37 <ozy`> Megzlna: #ocaml has a few
12:21:56 <Megzlna> augustss: Could you please describe how ML modules work and how they nuke on Haskell?
12:22:14 <Megzlna> What is Haskell's module problem.
12:22:19 <vixey> Megzlna, (that's what the post I was talking about was.. about ..)
12:22:24 <Megzlna> link
12:22:30 <vixey> you can google :p
12:22:32 <augustss> Megzlna: Haskell doesn't have proper modules.  Just a name space management.
12:22:36 <vixey> @go augustss blog
12:22:38 <lambdabot> http://augustss.blogspot.com/
12:22:38 <lambdabot> Title: Things that amuse me
12:22:40 <hellige> haskell's module system is that it has no abstraction over modules.
12:23:14 <hellige> in other words: no formal notion of a module signature, and modules providing and requiring signatures (interfaces) rather than a specific implementation.
12:23:15 <augustss> I was disappointed when associated types didn't solve my problem.
12:23:21 <geezusfreeek> haskell's modules are like most other languages' modules. there do exist far better ones, like what ML has
12:23:35 <ozy`> Megzlna: Haskell doesn't let you query a module as to its contents, much less use modules for arguments in a type declaration
12:23:50 <ozy`> yeah, Haskell is maybe middle of the road
12:24:12 <leimy> Just middle of the road or Nothing
12:24:16 <ozy`> did MODULA-n have reflexive modules?
12:24:16 <ozy`> haha
12:24:17 <hellige> if you know java, you might think of the distinction between the package system (primitive, no abstraction, sucks) and the object system (rich abstraction capabilities, interface vs implementation, etc)
12:24:32 <hellige> haskell's modules are like java's packages, ml's modules are (a bit) like java's objects.
12:25:12 <hellige> it's a credit to haskell that it manages to do so well without a decent module system, imho, but sometimes it shows.
12:25:14 <ksf> ...though haskell modules allow more control than java imports, java does namespace protection through objects.
12:25:16 <augustss> hellige: but ML's modules are still static.  You cannot perform module operations at runtime.
12:25:26 <hellige> augustss: right, it's only an analogy, really.
12:25:28 <Megzlna> ksf: What do you mean?
12:25:35 <Megzlna> no per-value type namespaces?
12:25:48 <hellige> ksf: yes, see my comment to augustss. :)
12:26:04 <ksf> haskell modules allow you to hide methods and types, java imports import everything.
12:26:09 <hellige> but i think the analogy shows the basic difference in mindset.
12:26:18 <ksf> then there's re-exporting.
12:26:38 <ksf> in a nutshell, imho haskell's module system is decent and does'nt suffer overkill.
12:26:54 <augustss> ksf: It's ok, until you need more
12:27:00 <Megzlna> Except that you cannot import Graphics
12:27:04 <hellige> imho, there are times when we'd really want signatures and functors.
12:27:06 <Megzlna> and get  Canvas.f
12:27:12 <ozy`> I propose that ML-style modules should not be called modules, but should be referred to (at least in the Haskell community) as something more... inspiring
12:27:22 <ozy`> how about "godules"
12:27:26 <hellige> ozy`: and i guess we can't just say "functors" either. ;)
12:27:29 <Megzlna> Globs
12:27:30 <mauke> monadules!
12:27:40 <hellige> mlules?
12:27:44 <ksf> phackages
12:28:26 <Megzlna> http://onelook.com/?w=*%3Apackage&ls=a
12:28:27 <augustss> It's somewhat ironic that Haskell actually used to have a notion of signatures.
12:28:38 <wchogg> augustss:  how long ago was that?
12:28:43 <hellige> augustss: yeah, what ever happened to that? i remember it, and i disappeared for a few years.
12:28:51 <hellige> when i came back, it had disappeared.
12:28:54 <augustss> It was in the first version
12:29:17 <hellige> hmm, i wasn't around that long ago, i must be thinking of something else... never mind.
12:29:22 <Megzlna> So, I asked this question earlier... Can ML do it?
12:29:25 <jpcooper> what are signatures?
12:29:35 <ozy`> augustss: but that was when it didn't allow nested namespaces, wasn't it?
12:29:40 <Megzlna> there's an instance A which has a module-default list of MyModule
12:29:40 <augustss> Nothing elaborate, but at least it allowed you to talk about what a module exports
12:29:47 * ski_ . o O ( capsules )
12:29:48 <ozy`> (not that that helps)
12:29:48 <Megzlna> there's a value 'v' of type A
12:29:48 <hellige> jpcooper: roughly like a type for an entire module
12:29:55 <Megzlna> in the current module which v is in, there is a function called 'g'
12:30:02 <Megzlna> in MyModule, there is a function called 'f'
12:30:12 <Megzlna> v:g 1  is the same as  g v 1
12:30:17 <Megzlna> v:f 1  is the same as MyModule.f v 1
12:30:20 <augustss> ozy`: Haskell doesn't really have nested name spaces.  It has module names that can contain .
12:30:52 <jpcooper> hellige, thanks
12:30:53 <scoo4114> @help
12:30:53 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:31:03 <scoo4114> @list
12:31:03 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
12:31:38 <scoo4114> @karma
12:31:38 <lambdabot> You have a karma of 0
12:31:42 <Gracenotes> @slap Gracenotes
12:31:42 * lambdabot decomposes Gracenotes into several parts using the Banach-Tarski theorem and reassembles them to get two copies of Gracenotes!
12:32:09 <augustss> well one, lambdabot!
12:32:14 <augustss> well done, even
12:33:00 <scoo4114> @fact
12:33:00 <lambdabot> I can not handle empty facts.
12:33:14 <scoo4114> @topic
12:33:14 <lambdabot> Maybe you meant: topic-cons topic-init topic-null topic-snoc topic-tail topic-tell join oeis todo type
12:33:18 <Gracenotes> what a vacuous thing to say
12:33:27 <scoo4114> @slap
12:33:27 * lambdabot beats up
12:33:39 <scoo4114> @instances
12:33:40 <lambdabot> Couldn't find class `'. Try @instances-importing
12:33:47 <scoo4114> @dict
12:33:47 <lambdabot> Supported dictionary-lookup commands:
12:33:48 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
12:33:48 <lambdabot> Use "dict-help [cmd...]" for more.
12:34:00 <Gracenotes> @instances Ord
12:34:01 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
12:34:02 <mauke> scoo4114: lambdabot responds to /msg, you know
12:34:13 <scoo4114> I'm new here
12:34:18 <scoo4114> just trying
12:34:20 <scoo4114> sorry
12:34:28 <scoo4114> will do the /msg now
12:34:46 <Gracenotes> so, cabal-install doesn't want to install: http://haskell.pastebin.com/d427ed24b
12:35:01 <Gracenotes> it appears I'm missing the 'network' and 'parsec' dependencies
12:35:14 <Gracenotes> is there some way to fix this?
12:35:19 <Megzlna> I'm also wondering why ocamlopt outperforms GHC on the bench's I've seensofar.
12:35:31 <wchogg> Gracenotes:  Just get them from hackage?
12:35:32 <vixey> maybe it's bettter
12:35:47 <Megzlna> vixey: insofar as three t's go
12:36:51 <Gracenotes> wchogg: makes sense. How does one install from hackage? putting them in the /usr/lib/ghc-6.8.2/lib directory?
12:37:01 <ksf> I just bootstrapped cabal-install via portage.
12:37:09 <Gracenotes> (I'm not going to be writing packages any time soon, just using...)
12:38:12 <ksf> you untar the balls and do runhaskell Setup.[l]hs configure [--user], runhaskell Setup.[l]hs build, then runhaskell Setup.[l]hs install [--user]
12:38:58 <ksf> I recommend doing user installations, it keeps stuff safely in .cabal and does'nt mess with your distro's package management's responsibilities.
12:39:53 <ozy`> ksf: that's funny, I was talking with the fink people about how great it would be if installation of Hackage packages was delegated to cabal-install
12:40:11 * chessguy_work isn't getting much work done today, but is getting close to syntax he actually likes on his haskell TicTacToe pattern prototype
12:41:03 <wchogg> chessguy_work:  TicTacToe pattern?
12:41:07 <leimy> > return 1 :: [] Int
12:41:10 <lambdabot>   [1]
12:41:26 <Megzlna> Is this considered poor Haskell programming practice?
12:41:27 <Megzlna> let f x = g x where g x = x + 1
12:41:29 <leimy> > return 1 :: Maybe Int
12:41:31 <lambdabot>   Just 1
12:41:47 <ksf> Megzlna, not if g is longer.
12:41:53 <chessguy_work> wchogg, working on a nice way to represent patterns of tic tac toe pieces, and hoping it extends to other things too
12:41:57 <Megzlna> I mean the shadowing part
12:42:01 <ksf> ...or you do a map g xs or stuff.
12:42:07 <Megzlna> like:
12:42:09 <ksf> just keep your code readable.
12:42:16 <Megzlna> > let f x = g x where g x = x + 1 in f 1
12:42:18 <lambdabot>   2
12:42:27 <Megzlna> > let f x = g where g = x + 1 in f 1
12:42:28 <lambdabot>   2
12:42:40 <augustss> Megzlna: ghc will warn about shadowing, but I don't think it's bad
12:42:46 <Megzlna> > let f x = g x where g y = y + 1 in f 1
12:42:47 <lambdabot>   2
12:42:48 <ksf> > let f = (+1) in f 1
12:42:48 <vixey> > let f = g where g = (+ 1) in f 1
12:42:50 <lambdabot>   2
12:42:50 <lambdabot>   2
12:43:03 <wchogg> chessguy_work:  You mentioned syntax.  Are you working on a pre processor or something?
12:43:13 <dancor> Megzlna: yeah i was just going to say is one benenfit of not doing that is that you can do -Wall and get better error-checking in general
12:43:25 <orbitz> do you guys usually mix where and let like that? i usually have them distinct
12:43:27 <Megzlna> The "poor practice" part was regarding shadowing outer variables on inner where's
12:43:31 <dancor> Megzlna: i don't typically worry about it early on while i'm just try to rapidly get something going tho
12:43:36 <Megzlna> this one:   let f x = g where g = x + 1 in f 1
12:43:38 <chessguy_work> wchogg, no, i just haven't gotten around to actually implementing anything yet. i'm just dreaming about what i would want the syntax to look like
12:43:41 <Megzlna> even though that's not useful
12:43:42 <chessguy_work> wchogg, http://hpaste.org/12970#a3
12:43:50 <Gracenotes> okay, configure/build/install
12:43:57 <ksf> Megzlna, just keep it readable.
12:44:07 <Megzlna> sorry  no that one even, I mean g x
12:44:09 <Gracenotes> argh
12:44:17 <sm> phew, linking gitit takes a while
12:44:21 <ozy`> Megzlna: writing in point-free style helps make it irrelevant ;)
12:44:36 <ozy`> e.g.: f x = g x where g = (+ 1)
12:44:42 <Megzlna> @unpf
12:44:42 <lambdabot> ()
12:44:44 <Megzlna> @unpf f x = g x where g y = y + 1
12:44:44 <lambdabot> f x = g x where { g y = y + 1}
12:44:48 <taruti> How would a functional dependency that has overlapping instances be translated to associated classes?
12:44:51 <Megzlna> @pf f x = g x where g y = y + 1
12:44:51 <lambdabot> Maybe you meant: bf pl
12:45:08 <Megzlna> @bf pl f x = g x where g y = y + 1
12:45:08 <lambdabot>   fd:8: hClose: resource vanished (Broken pipe)
12:45:10 <Megzlna> heh
12:45:16 <orbitz> Megzlna: @pl
12:45:16 <augustss> lol
12:45:20 <ozy`> lolwut
12:45:22 <Megzlna> @pl f x = g x where g y = y + 1
12:45:23 <lambdabot> (line 1, column 21):
12:45:23 <lambdabot> unexpected "="
12:45:23 <lambdabot> expecting variable, "(", operator or end of input
12:45:25 <leimy> > fail "" :: Maybe INt
12:45:26 <lambdabot>   Not in scope: type constructor or class `INt'
12:45:33 <leimy> > fail "" :: Maybe Int
12:45:35 <lambdabot>   Nothing
12:45:45 <leimy> > fail "" :: [] Int
12:45:47 <lambdabot>   []
12:45:53 <taruti> http://hpaste.org/12977 has a simplified example of the issue
12:45:55 <ozy`> @pl (\x -> g x where g y = y + 1)
12:45:55 <lambdabot> (line 1, column 22):
12:45:55 <lambdabot> unexpected "="
12:45:55 <lambdabot> expecting variable, "(", operator or ")"
12:45:57 <augustss> fail should be eradicated from Monad
12:46:05 <wchogg> chessguy_work:  So it looks like you want a general syntax for a series of constraints?  I apologize if I misunderstand.
12:46:23 <wchogg> augustss:  fail is made of fail?
12:46:23 <ozy`> @pl (\x -> (\y -> y + 1) x)
12:46:24 <lambdabot> (1 +)
12:46:24 <leimy> augustss: it's pretty Monad implementation dependent crap yeah
12:46:30 <ozy`> @unpl (\x -> (\y -> y + 1) x)
12:46:31 <lambdabot> (\ x -> x + 1)
12:46:37 <leimy> augustss: it has a fitting name too
12:47:06 <chessguy_work> wchogg, yes, for contraints on compoments of something and how the components relate
12:47:43 <ozy`> @pl const
12:47:44 <lambdabot> const
12:47:47 <ozy`> @unpl const
12:47:48 <lambdabot> (\ a _ -> a)
12:47:49 <ski_> (augustss : amen)
12:48:59 <wchogg> The main thing that annoys me about fail is that monads are supposed to be a mathematical abstraction.  How does fail really fit into that?
12:49:08 <leimy> they don't
12:49:10 <augustss> It doesn't
12:49:12 <chessguy_work> wchogg, i'd like to be able to write something like match :: Container C -> Pattern a -> c a -> [a]
12:49:17 <leimy> right
12:49:21 <leimy> it doesn't!
12:49:39 <vixey> > do Just _ <- Nothing ; return ()
12:49:41 <lambdabot>   Nothing
12:49:42 <chessguy_work> wchogg, (for some sensible Container class)
12:50:07 <vixey> it should be like
12:50:09 <vixey> :t do Just _ <- Nothing ; return ()
12:50:11 <lambdabot> Maybe ()
12:50:11 <ozy`> > do _ <- Nothing; return ()
12:50:12 <lambdabot>   Nothing
12:50:13 <Gracenotes> nice, cabal installed
12:50:20 <Gracenotes> thanks, all
12:50:30 <vixey> well <- pattern match could be in MonadPlus
12:50:37 <leimy> > return () :: [] Int
12:50:39 <lambdabot>   Couldn't match expected type `Int' against inferred type `()'
12:50:40 <vixey> or MonadZero .. I suppose
12:50:45 <augustss> vixey: as it used to be
12:50:55 <leimy> > return () :: Maybe Int
12:50:56 <lambdabot>   Couldn't match expected type `Int' against inferred type `()'
12:51:49 <leimy> yeah fail is pretty bad.. in that I think it means all implementors of modules need to be really clear as to how they implemented fail.
12:51:57 * roconnor uses symlinks to swap between different implementations of a Haskell module
12:52:22 * ozy` uses macros to make Scheme look like Haskell
12:52:37 * leimy once ate black pudding
12:52:41 <leimy> since we're talking about gross stuff :-)
12:52:46 * vixey uses haskell :p
12:53:26 <ozy`> that was in the perfective sense of "uses," not the habitual
12:53:30 <ski_> (leimy : i thought you were supposed to kill it, not eat it .. (er, wait a minute ..))
12:53:30 <augustss> roconnor: symlinks instead of functors.  Yay!
12:53:43 <wchogg> chessguy_work:  so for any Foldable functor you'd translate the Pattern mechanically into guard statements on some auxiliary function?
12:53:56 <chessguy_work> errr
12:54:04 <chessguy_work> run that by me again?
12:54:08 <leimy> symlinks are kind of like lazy filesystem programming
12:54:10 <roconnor> augustss: it seemed to work pretty ok the one time I used it.
12:54:13 * paolino listens to thelonious monk
12:54:27 <wchogg> paolino : nice choice for working
12:54:33 * leimy listens to The Mars Volta
12:54:42 <ksf> hardlinks too, from a different pov.
12:54:42 <chessguy_work> wchogg, i know what a foldable is, but i'm not sure what you mean by 'some auxiliary function'
12:54:56 <augustss> roconnor: but it wouldn't for me.  I want to use the functor applied to different arguments in the same program
12:55:04 <ksf> copy too, on smart fs's.
12:55:24 <roconnor> leimy: I only use symlinks because GHC's instance of mapping the module space directly onto the file system.
12:55:35 <roconnor> augustss: oh!
12:55:49 <roconnor> augustss: I thought you just wanted to try out various implementations
12:56:39 <ksf> augustss, typeclasses?
12:56:39 <wchogg> chessguy_work : Sorry, really all I mean is that you translate the pattern into a predicate function in some mechanical way & use that in a fold to filter the container
12:56:46 <augustss> roconnor: that was my excuse in the blog post.  my real example is something totally different
12:57:01 <roconnor> augustss: that explains my confusion.
12:57:08 <chessguy_work> wchogg, right, and possibly to select some matching elements
12:58:16 <wchogg> chessguy_work :  cool.  Seems like something you could totally do as some kind of combinator language to build up patterns.
12:59:02 <chessguy_work> wchogg, yep, that's what is/are/areAll are, basically. but they translate into State monad operations which build and modify a Pattern object, because, behind the scenes, it's a pretty complex object
12:59:59 <roconnor> hmm, my footnote next to math expression makes the 0 look like 0^4.1
13:00:09 <roconnor> I wonder how I can reformat this
13:00:11 <chessguy_work> so i use those to build the Pattern, use the Pattern constructor to hide the ugliness, and provide some utility functions that do interesting things with the pattern
13:02:19 <ozy`> hmm, does ML have a function infix notation of any kind? (analogous to `...`)
13:02:46 <byorgey> roconnor: reword the sentence so the 0 doesn't come at the end.
13:02:58 <Megzlna> Why is Haskell a research language?
13:03:01 <byorgey> that's the old-fashioned way, and it's still the best =)
13:03:35 <ozy`> Megzlna: because people called it a research language
13:03:41 <byorgey> Megzlna: why are cars a means of transportation?
13:03:47 <wchogg> chessguy_work : sounds like a good idea
13:03:58 <byorgey> that's why it was created.
13:04:05 <chessguy_work> i'll probably shoot out an email to -cafe in the next few days
13:04:41 <roconnor> byorgey: oh, I could try to move the footnote to the end of the sentence
13:04:46 <roconnor> that sounds reasonable
13:04:57 <byorgey> roconnor: oh, even easier.
13:05:02 <ozy`> Megzlna: Haskell was originally a way to bring together different ideas from about a dozen other functional languages, and find interesting ways to apply them
13:05:59 <mauke> http://cgi.4chan.org/r/src/1229027857666.jpg
13:06:02 <roconnor> byorgey++
13:06:32 * scoo4114
13:07:41 <ozy`> Megzlna: and since it turned out to be flexible enough to serve as a testbed for all kinds of weird programming language ideas, it continued to be used for exactly that, even once the syntax and core semantics stopped flying all over the place
13:07:44 <wchogg> I'm looking forward to when there's a 'Haskell' of the dependent type world, combining together a bunch of the various attempts made over the years.
13:07:58 <byorgey> wchogg: me too!
13:08:10 <Megzlna> How does dependent types work?
13:09:12 <byorgey> Megzlna: in dependent type systems, terms (like 6, ['c'], \x -> x, etc.) are allowed to appear in types.
13:09:15 <vixey> Megzlna: :D http://freenode-math.com/index.php/Introduction_to_Type_Theory
13:09:29 <byorgey> more formally, you are allowed to have functions that take terms as input and give types as output.
13:10:01 <byorgey> so, for example, (M :: Int -> Int -> Type) could be the matrix type constructor.
13:10:02 <Megzlna> thanks vixey
13:10:15 <ksf> ...so you can do stuff like type Nat = Integer a => a | a >= 0
13:10:23 <roconnor> I wish there was nice math notation for takeWhile and dropWhile.
13:10:27 <byorgey> and you could write things like   matrixMultiply :: (M m k) -> (M k n) -> M m n
13:10:44 <vixey> with dependent types you can do stuff like
13:11:02 <vixey> data Parse :: String -> AST -> Prop where
13:11:15 <vixey>   <constructors that express the relation between text and abstract syntax>
13:11:40 <vixey> then write a function  pp :: (a :: String) -> { a :: AST | Parse s a }
13:11:56 <Megzlna> but, can anything be truly static?
13:11:58 <vixey> and parse :: (a :: AST) -> { s :: String | Parse s a }
13:12:02 <ozy`> someone posted a rant this one time asking for a game programming language with STM and dependent types
13:12:09 <sm> is john mcfarlane here ? gitit won't recognise my new login
13:12:11 <vixey> and I used the wrong names should have swapped pp and parse :/
13:12:40 <Megzlna> with dependent types, don't you have many more thunks
13:12:41 <byorgey> Megzlna: what do you mean?
13:12:45 <Megzlna> slower
13:12:50 * ksf gets confused by the very notion of "static" since he learned scheme.
13:12:51 <Megzlna>  ?
13:13:06 <vixey> Megzlna, read into the theory a bit more
13:13:09 <byorgey> Megzlna: it's kind of orthogonal to issues of efficiency.
13:13:21 <pejo> ozy, is that someone Tim Sweeney? If so, it was an invited talk for POPL'06 iirc.
13:13:22 <ozy`> Megzlna: this kind of stuff could be resolved at compile time, which is the point
13:13:29 <byorgey> Megzlna: but I suppose in general, the more abstraction you have, the harder it is to make really efficient.
13:13:32 <ozy`> pejo: maybe. I forgot
13:13:55 <Megzlna> <byorgey> Megzlna: in dependent type systems, terms (like 6, ['c'], \x -> x, etc.) are allowed to appear in types.
13:14:02 <Megzlna> constant 6?
13:14:16 <Megzlna> not a range of 6
13:14:25 <byorgey> right, the actual number 6
13:14:27 <ksf> well, obviously nothing that depends on the run-time world.
13:14:33 <Megzlna> so that's easily static.
13:14:33 <wchogg> byorgey:  I don't know if that'll happen with dependent types.  If anything I imagine the even richer type level information might do very cool things for optimization.
13:14:37 <ozy`> Megzlna: for example, a list/array might have length 6
13:14:46 <ozy`> or it might have variable length
13:14:48 <byorgey> wchogg: you may be right.
13:14:52 <vixey> wchogg, I think ATS is a good example of that
13:14:56 <Megzlna> D:
13:15:04 <vixey> wchogg, but I don't think we have enough diversity in implementations
13:15:05 <vixey> yet
13:15:18 <Megzlna> template A(int N) { int x; }
13:15:22 <pejo> wchogg, I don't think we're hitting the limits of type-less optimization currently.
13:15:24 <Megzlna> A!(10).x = 1
13:15:34 <Megzlna> C++:
13:15:52 <orbitz> what is A!(10)?
13:16:08 <Megzlna> template <int N> class X { static int x; }
13:16:08 <jsn_> Megzlna: that's the strangest C++ I've ever seen
13:16:15 <Megzlna> X<10>::x = 1
13:16:18 <ksf> Megzlna likes D.
13:16:21 <orbitz> hah
13:16:24 <jsn_> oh
13:16:26 <orbitz> is Megzlna === googber?
13:16:36 <ksf> nope, ezla.
13:16:43 <jsn_> Megzlna: D isn't purely functional
13:16:43 <Megzlna> That stuff's all done at compile time
13:16:46 <orbitz> is ezla == goober?
13:16:52 <ksf> tr/Mgn//
13:16:57 <Megzlna> jsn_: well, 'D' does have the 'pure' keyword
13:16:59 <orbitz> Megzlna: the assignemnt isn't
13:17:04 <Megzlna> You can mark functions as pure.
13:17:06 <jsn_> ach
13:17:09 <Megzlna> However.
13:17:10 <jsn_> i lost my nick
13:17:25 <orbitz> template literals are also limited to itnegers
13:17:33 <Megzlna> regardless of FP issue, static dependent types is not hardcore
13:17:37 <orbitz> T<"hi"> would be invalid
13:17:44 <Megzlna> is just a parameterized type
13:17:56 <jsn_> Megzlna: can you specify, numbers between 7 and 12 as a type?
13:17:56 <vixey> Megzlna, read the link
13:18:00 <Megzlna> orbitz: That's only a flaw in C++
13:18:17 <ozy`> I'd like to see a less verbose version of Ada with polymorphism and nicer parallelism support
13:18:29 <Megzlna> D does that without issue
13:18:38 <wchogg> ozy`:  what do you want from Ada?
13:18:40 <vixey> ozy`, so code it
13:18:47 <jsn_> Megzlna: that is to say, can D detect statically that you have used a value in such a way that it never is greater than 7 or less than 12, or signal a compile error?
13:18:48 <ozy`> yeah yeah
13:18:51 <Megzlna> D has also static functions, as nontype template parameters.
13:18:59 <Megzlna> ie, parameterized on lambdas
13:19:04 <vixey> Megzlna, you can't reflect programs in D into logical properties
13:19:12 <vixey> Megzlna, You have not read my link :p
13:19:16 <jsn_> oh wait
13:19:21 <Megzlna> was it a .ps ?
13:19:24 <Megzlna> or the Seminar
13:19:24 <jsn_> i mean, less than 7 or greater than 12
13:19:26 <ksf> can you construct a type that subsets Nat into all primes, and write a compiler that can statically prove a function adheres to it?
13:19:28 <vixey> Megzlna, seminar
13:19:40 <vixey> Megzlna, you can skim this first http://www.rosettacode.org/wiki/Evens_Sum_To_Even
13:19:48 <Megzlna> vixey: What does 'reflect into logical properties' mean?
13:20:10 <paczesiowa> ksf: why not?
13:20:17 <Megzlna> you can easily reflect a tuple of aliases
13:20:27 <Megzlna> aliases are terminals in the ast
13:20:33 <ksf> ...I meant in D or C++. I would'nt be surprised to see it in epigram or agda.
13:20:39 <vixey> Megzlna, I don't think me typing all that stuff out _again_ will make it any clearer than you just reading the link :)
13:20:41 <ksf> or coq, fwiw.
13:20:48 <paczesiowa> ksf: sorry then, I meant haskell
13:21:07 <jsn_> Megzlna: dependent types don't just mean, you can use value literals in types
13:21:08 <ksf> then I must add WITHOUT USING PEANO NUMBERS
13:21:32 <paczesiowa> you're mean:)
13:21:41 <Megzlna> well in D templates, you can pattern match upon those types, in order to decompose the types out, etc
13:21:45 <Megzlna> that's about it
13:21:49 <Megzlna> jsn_: what can ya do?
13:21:52 <ksf> nah, I just don't see the point of gluing myself to turing tarpits.
13:22:04 <vixey> Megzlna, Do you understand simply typed lambda calculus as a basis for implicational LJ?
13:22:21 <jsn> Megzlna: dependent types mean you can provide value restrictions that can be statically verified
13:22:35 <jsn> Megzlna: to use literals as types is a kind of cheap punning
13:22:50 <Megzlna> vixey: No
13:23:03 <Megzlna> jsn: isnt that just pattern mactching on the static parameter?
13:23:04 <vixey> Megzlna, ok I'll wait.. :)
13:23:09 <jsn> Megzlna: you could do it in haskell if we allowed 1, 2, 3 ... to be handled specially in type signatures, as a syntax transform
13:23:27 <vixey> jsn, that's totally not the same thing
13:23:28 <Megzlna> jsn: what about with template haskell?
13:23:30 <jsn> Megzlna: pattern matching is done at runtime
13:23:38 <ksf> Megzlna, different example: can you write a D type that checks whether the string a function outputs is a valid xhtml document?
13:23:45 <jsn> Megzlna: no, that won't do dependent types
13:23:51 <ksf> ...at compile time.
13:23:52 <jsn> vixey: what?
13:24:03 <Megzlna> ksf: Yes
13:24:13 <Megzlna> ksf: and you can do that at compile time
13:24:17 <vixey> jsn, ohh sorry I see what you're saying. I  mixed it up
13:24:29 <vixey> jsn, that D/C++ is cheap punning
13:24:33 <jsn> vixey: yes
13:24:48 <jsn> vixey: otherwise, we'd DPP -- the dependent type preprocessor :)
13:25:00 <jsn> s/we'd/we'd have/
13:25:28 <jsn> Megzlna: maybe ksf is not being clear
13:25:42 <ksf> I doubt it. I wanna see that primes example in concrete code.
13:26:02 <orbitz> a type that represents only even numbers.  does that mean the type checker would give a compielr error on 2+1?
13:26:05 <jsn> Megzlna: can you write a D type that assures that a string is always also a valid XHTML document?
13:26:22 <jsn> Megzlna: or do you have to use checks, like parsing it, &c. ?
13:26:24 <vixey> jsn, can you do that in Coq or Agda? I sure as hell couldn't
13:26:27 <Megzlna> orbitz: sure, D can do that
13:26:49 <jsn> Megzlna: we actually know for a fact that it can't
13:26:51 <vixey> we already know D can't do this, there's little point being socratic about it to try and explaining something as deep as this
13:26:55 <orbitz> Megzlna: er i'm not asking if D can do it, i'm just curious as to what ti would meanf or that to be a type
13:27:04 <ksf> Megzlna, show us the code.
13:27:09 <jsn> we are just trying to explain the difference between dependent types and plain parameters that look like values
13:27:24 <Megzlna> template Foo(int N) if (even(N)) { int x; }   Foo!(0).x = 1; // Ok   Foo!(1).x = 2  // Compiler error
13:27:24 <joelr1> good evening
13:27:47 <Gracenotes> > Data.ByteString.pack (map ord "hello")
13:27:49 <lambdabot>   Couldn't match expected type `Word8' against inferred type `Int'
13:28:15 <Gracenotes> > let se = map ord "hello" in Data.ByteString.pack se
13:28:16 <lambdabot>   Couldn't match expected type `Word8' against inferred type `Int'
13:28:23 <ksf> ...and int i << cin; Foo!(1).x = i?
13:28:26 <Gracenotes> :\
13:28:36 <Megzlna> ksf: fine
13:28:37 <vixey> ksf, that's a bad example
13:28:54 <Megzlna> You can write any kind of pure function into the if() block
13:29:02 <Megzlna> to constrain any way you want
13:29:10 <Megzlna> on the type itself
13:29:45 <ksf> Foo!(1).x = rand() ?
13:29:51 <Deewiant> If you want runtime constraints what you want is struct Foo { private int x_; int x() { return x_; } void x(int y) { if (y % 2) error; else x_ = y; } } or something
13:29:56 <ksf> actually, I can't think of a proper example right now.
13:30:00 <Megzlna> ksf: That's illegal
13:30:02 <Megzlna> 1 is odd
13:30:08 <Megzlna> the type doesnt even exist
13:30:17 <Megzlna> the if() is needed for type instanciation
13:30:21 <mlesniak> Is it possible to have (construct) a non-blocking getEvent in Graphics.Vty?
13:30:22 <ksf> ah, wait.
13:30:33 <byorgey> hi joelr1
13:30:37 <Deewiant> Megzlna: I think he wanted a type which ensures the bound at runtime
13:31:02 <Megzlna> well thats easy too
13:31:08 <joelr1> <- sulks. real world haskell is shipped in 10-13 days at amazon uk
13:31:12 <ksf> waaaaait.
13:31:14 <Toxaris> > Data.ByteString.pack (map (fromInteger . toInteger . ord) "hello")
13:31:16 <lambdabot>   "hello"
13:31:20 <orbitz> i dont' think runtime
13:31:21 <byorgey> joelr1: oh, boo =(
13:31:22 <orbitz> runtime is easy
13:31:24 <ksf> you can't constrain x, at all.
13:31:31 <ksf> you only match on N.
13:31:39 <joelr1> of course i can read online but ...
13:31:39 <Gracenotes> Toxaris: *cocks head*
13:31:44 <Deewiant> Megzlna: without proper properties it's not very nice... I posted a working thing above but now you can't do foo.x++
13:31:47 <Megzlna> 1 is a part of the type
13:31:48 <ksf> so you don't have dependent typing, but dependant instancing.
13:31:52 <ksf> which are _way_ different.
13:31:59 <Gracenotes> odd.
13:32:02 <Megzlna> Deewiant: Of course, D has properties
13:32:13 <Deewiant> Megzlna: no it doesn't
13:32:18 <ksf> I want you to restrain the type of _x_.
13:32:31 <vixey> these D example really don't explain what dependent typing means.....
13:32:41 <vixey> I think you should stop trying to invent programming problems that D can't do
13:32:51 <Deewiant> ksf: restrain the type of x based on what?
13:33:01 <vixey> because that method does not explain something as intricate as this
13:34:00 <Megzlna> vixey: A type statically parameterized by a lower and upper bound, which runtime constrains?
13:34:15 <ksf> Megzlna, with static constraints.
13:34:16 <vixey> Megzlna, not a question -- and I don't know what you are asking
13:34:24 <orbitz> is the point of this conversation to just figure out what D can do, or is there some higher one/
13:34:41 <Megzlna> ksf: Static constraints are impossible unless the whole program executes at compile time
13:34:53 <Deewiant> ksf, Megzlna: something which rejects a program at compile time if the value might invalidate the constraints?
13:34:57 <ksf> never say never.
13:34:58 <Megzlna> any appearance of "static constraints" would merely be a runtime implementation
13:35:36 <Deewiant> orbitz: explaining dependent types, I think
13:37:05 <vixey> @quote xahlee
13:37:05 <lambdabot> xahlee says: note to readers: i'm not just interested in functional programing, i'm the world's top expert
13:37:25 <ksf> Megzlna, not if the compiler can infer a constructive proof out of the code you gave him.
13:37:42 <jsn> ksf: gave _it_
13:37:43 <Megzlna> ksf: A constructive proof dependent on the 1238129837192387 i type in?
13:37:55 <vixey> ksf, no need for it to be constructive
13:37:57 <Deewiant> jsn: gave _her_
13:38:14 <jsn> Deewiant: not in teh engrish
13:38:30 <ksf> not?
13:38:31 <Deewiant> @vixen a/s/l
13:38:32 <lambdabot> 19/f/California
13:38:39 <Deewiant> all Haskell programs are female
13:38:57 <wchogg> odd, that
13:39:46 <erikc> as i understand dependent types, a simple example would be a function such as "void index(vector<int> v, (int < v.length && > 0) i))"
13:39:57 <vixey> erikc, did you see my parsing example?
13:39:59 <erikc> and the way to get that type would be to have an if check which checks those conditions
13:40:03 <erikc> sorry i missed it vixey
13:40:08 <vixey> so the idea is like
13:40:18 <vixey> data Parse :: String -> AST -> * where
13:40:30 <erikc> (but basically, the only way to synthesize the type of that index i is within an if check that validated the conditions, so it is statically verified)
13:40:38 <Cale> Deewiant: I'm not sure about that... they seem to be reproducing quite well according to Hackage :)
13:40:42 <vixey>   ParseSymbol :: Parse x s -> Parse ("(" ++ x ++ ")") s
13:40:44 <vixey>   ...
13:40:55 <vixey> you describe the relation between strings and syntax like this
13:41:09 <chessguy_work> if i have a [State a ()] and i want to run them all, but allow for the possibility that the execution could fail, do i want ErrorT?
13:41:09 <Deewiant> Cale: :-D
13:41:20 <vixey> and then write functions prettyprint :: (a :: AST) -> (s :: String, Parse s a)
13:41:33 <vixey> parse :: (s :: String) -> (a :: AST, Parse s a)
13:42:01 <vixey> It's like GADTs on acid
13:42:29 <Megzlna> @src acid
13:42:29 <lambdabot> Source not found. Do you think like you type?
13:42:29 <vixey> I like this example except for that actually writing 'parse' is hard
13:42:34 <chessguy_work> @where acid
13:42:35 <lambdabot> I know nothing about acid.
13:42:36 <erikc> right
13:42:45 <vixey> I don't know how :(
13:42:47 <Deewiant> @where goa
13:42:47 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
13:42:57 <jsn> here is an example of dependent types that i wish i could use right now:
13:42:58 <jsn> http://hpaste.org/12979
13:43:07 <erikc> i always liked tim sweeney's example from his oopsla presentation
13:43:30 <vixey> jsn, why don't you just write partial functions? this is haskell afterall
13:43:31 <erikc> which was an array Foo of indices into array Bar could be statically verified to be valid
13:43:42 <vixey> put assumptions in a comment
13:43:42 <erikc> by propagation of domain constraints
13:43:50 <jsn> vixey: well, that is not my point
13:44:01 <jsn> vixey: my point was only, to present a mundane example
13:44:12 <jsn> vixey: of something dependent types could verify for me
13:44:26 <vixey> jsn, Why don't you program in Agda 2 though?
13:44:45 <jsn> vixey: because i had a hell of a time getting my boss to let me use haskell
13:44:52 <erikc> ibm's xlc/xlf compilers use that kind of flow-sensitive context for optimization already (e.g. within an if block, we used the constrained domain of a value to optimize better)
13:45:00 <jsn> vixey: i don't think i'd ever be able to talk him into AGDA
13:46:19 <ksf> Megzlna, http://www.cs.chalmers.se/~ulfn/darcs/AFP08/LectureNotes/AgdaIntro.pdf
13:46:34 <vixey> ksf, have you read this?
13:46:42 <erikc> the benefit of dependent types as i understand them is it forces error handling prior to performing a computation that would cause an error
13:46:42 <Megzlna> thanx
13:47:12 <ksf> I dunno, I might be confusing it with an epigram tutorial.
13:47:27 <vixey> ksf, it's really good actually
13:47:30 <vixey> you should read it :P
13:48:23 <ksf> To be honest, it's not so much the dependent typing that intrigues me but total fp.
13:49:11 <ksf> ...as guaranteeing termination while still enabling you to express anything you could ever want to code isn't what I'd call trivial.
13:55:02 <walski> hi there
13:55:15 <walski> what's the datatype for passing a function to a function? Function?
13:55:24 <mauke> what?
13:55:37 <ksf> :t map
13:55:39 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
13:55:41 <ksf> like that.
13:55:46 <ozy`> walski: the (a -> b) part
13:55:46 <mauke> what's the type for adding a number to a number? Add?
13:56:03 <ksf> :t (+)
13:56:04 <lambdabot> forall a. (Num a) => a -> a -> a
13:56:20 <walski> thanks!
13:58:04 <thoughtpolice> @seen Lemmih
13:58:05 <lambdabot> Lemmih is in #haskell. I don't know when Lemmih last spoke.
13:58:22 <ksf> any yi developers around?
13:58:29 <ksf> http://www.yudit.org/ <-- inspiration!
13:59:56 <Lemmih> thoughtpolice: Hey.
14:00:28 <walski> is there a function or an idiom to get the first n elements of a sequence?
14:00:55 <ozy`> > take 3 [1,5..]
14:00:56 <lambdabot>   [1,5,9]
14:01:01 <walski> thanks!
14:01:02 <ozy`> > take 12 [1,5..]
14:01:03 <lambdabot>   [1,5,9,13,17,21,25,29,33,37,41,45]
14:01:18 <ksf> ...basically, defining a keymap binding "lambda" -> insertText "λ"
14:02:39 <walski> oh and what about the last n elements of a sequence? i could reverse it, take the first n and reverse it again but that would be... uncool ;)
14:02:46 <thoughtpolice> Lemmih: ok, the lhc you uploaded to hackage is broke (it for some reason imports a nonexistant 'Grin.PointsTo') - I have a tree working here that I have some modifications too, but there's a slight problem
14:03:19 <ksf> "For instance, not:Bool->Bool would not be a valid type signature for the not function, since it is in fact a valid name." -- zomg
14:03:44 <Lemmih> thoughtpolice: Oops.
14:03:54 <thoughtpolice> Lemmih: the problem is, that when we pass '-fwith-base' to the cabal install installation procedure
14:04:16 <thoughtpolice> cabal installs it to a directory that lhc doesn't check
14:04:40 <thoughtpolice> let me paste something right quick
14:06:17 <thoughtpolice> Lemmih: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=561#a561
14:06:30 <Gracenotes> walski: what sort of sequence? [1,5..] is an infinite sequence, so where would you want yours to end?
14:06:51 <walski> ok sorry maybe the name is just wrong
14:07:00 <centrinia> What is a Grin.PointsTo? ;)
14:07:01 <walski> i mean something like [1,2,3,4,5,6,7,8,45,67675,23]
14:07:59 <thoughtpolice> Lemmih: as you can see, cabal installs in ~/.cabal/lib/lhc-0.6.20081211, but as the version (I updated it) is 0.6.20081211.1, cabal doesn't look there
14:08:20 <thoughtpolice> er, lhc doesn't look in ~/.cabal/lib/lhc-0.6.20081211
14:08:44 <thoughtpolice> Lemmih: basically the fix we need is for cabal to use the WHOLE version number, and thus install base into ~/.cabal/lib/lhc-0.6.20081211.1
14:08:52 <centrinia> > let last n xs = drop (length xs - n) xs in last 4 [1..14]
14:08:53 <lambdabot>   [11,12,13,14]
14:09:05 <thoughtpolice> centrinia: some defunct module from an earlier time in lhc's life
14:09:07 <centrinia> It still wouldn't work for infinite lists.
14:09:13 <dcoutts> thoughtpolice: in what sense does it not use the whole version number?
14:09:45 <thoughtpolice> dcoutts: the version is 0.6.20081211.1, but when we use cabal install to install lhc's base, it installs it to ~/.cabal/lib/lhc-0.6.20081211
14:10:04 <Lemmih> thoughtpolice: Hm, lhc should only consider major.minor versions.
14:10:24 <thoughtpolice> Lemmih: well that's part of my patch
14:10:30 <thoughtpolice> is to use the entire version number
14:10:32 <dcoutts> thoughtpolice: perhaps your version parsing code in Cabal is wrong:
14:10:32 <dcoutts>       case words str of
14:10:33 <dcoutts>         (_:ver:_) -> reverse $ drop 1 $ dropWhile (/='.') $ reverse ver
14:10:48 <thoughtpolice> because it seems as if there could be instances in which we might modify the hl format and have some problems
14:11:15 <Lemmih> dcoutts: I thought I fixed that.
14:11:56 <thoughtpolice> e.g if the hl format changes inbetween 0.6.20090101 and 0.6.20090201 and lhc only checks a dir like '~/.cabal/lib/lhc-0.6' then it could potentially pick up libraries it doesn't understand anymore
14:12:00 <walski> centrinia: Danke!
14:12:10 <walski> arg sorry, too much german :)
14:12:11 <walski> thanks
14:12:15 <dcoutts> > case "lhc 0.3.20080208" of (_:ver:_) -> reverse $ drop 1 $ dropWhile (/='.') $ reverse ver
14:12:16 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
14:12:21 <dcoutts> > case words "lhc 0.3.20080208" of (_:ver:_) -> reverse $ drop 1 $ dropWhile (/='.') $ reverse ver
14:12:22 <lambdabot>   "0.3"
14:12:28 <dcoutts> Lemmih: did you push it?
14:12:43 <centrinia> walski: You're welcome. ;)
14:13:30 <Lemmih> dcoutts: 'getLhcLibDirsFromVersion' extracts the relevant parts. Not sure why I made it that way.
14:14:10 <thoughtpolice> Lemmih: I think it's probably safer & less troublesome to use the whole version number rather than just the short identifier, but I can take that part of the patch out
14:14:25 <thoughtpolice> we need to make cabal and lhc agree on where to install & where to look
14:14:37 <Lemmih> thoughtpolice: Our format doesn't change that often.
14:15:17 <Lemmih> But I guess it doesn't hurt to recompile base just to be sure.
14:15:19 <dcoutts> Lemmih: either way, the lhcProgram should be fixed to parse the lhc version number correctly.
14:15:29 <Lemmih> dcoutts: It does parse it correctly.
14:15:37 <Lemmih> The information is just used wrong.
14:15:52 <dcoutts> Lemmih: ah, so 0.6.$date is really just 0.6 ?
14:16:05 * gnuvince_ received RWH
14:16:14 <Lemmih> dcoutts: What?
14:16:17 <gnuvince_> Whose idea was it to put "Code You Can Believe In" at the top of the cover?
14:16:19 <vixey> > words "lhc 0.3.20080208"
14:16:20 <lambdabot>   ["lhc","0.3.20080208"]
14:16:34 <vixey> hehe
14:16:40 <vixey> I was about to say why didn't you use SECOND
14:16:49 <vixey> then I realized which language this is...
14:17:16 <dcoutts> Lemmih: I mean, when lhc --version says 0.6.20081211" then the real version is 0.6 ?
14:17:35 <Lemmih> dcoutts: "1.2.3" is 1.2.3. The program then decides to place libraries under 1.2 because the format isn't likely to change.
14:17:49 <Lemmih> There's no such thing as a real version.
14:17:59 <dcoutts> Lemmih: ok, so the lhcProgram is doing it wrong then
14:18:07 <dcoutts> it drops the last digit
14:19:07 <dcoutts> if you want to define the version of the compiler to be 0.6 then it's probably best to do that in the configure function, just drop the last digit
14:19:22 <Lemmih> dcoutts: Oh, indeed.
14:19:31 <dcoutts> Lemmih: want me to patch that?
14:20:08 <dcoutts> Lemmih: then it'll install things into "lhc-0.6" rather than "lhc-0.6.xxxxxxxx"
14:20:15 <dcoutts> if that's what you want
14:20:26 <Lemmih> dcoutts: I'm not sure what we want.
14:20:36 <dons> gnuvince_: woo!
14:20:36 <thoughtpolice> well I have uncommitted changes
14:20:58 <thoughtpolice> that make lhc look in 'lhc-x.x.x...' where those 'x's represent the entire version
14:21:03 <Lemmih> dcoutts: I'm quite sure it ignores everything except the two first version numbers.
14:21:07 <dcoutts> Lemmih: it also means that in .cabal files, users will only be able to say if impl(lhc >= 0.6) they will not be able to distinguish any finer version distinction
14:21:08 <thoughtpolice> (look at the paste again)
14:21:38 <gnuvince_> "Haskell, for better, faster, stronger code.  Code you can believe in.  I'm Barack Obama, and I approve this message"
14:22:03 <vixey> shouldn't you be busy running america?
14:22:07 <dcoutts> Lemmih: well I'm going to patch Cabal to keep the current behaviour but to do it more sanely
14:22:25 <ozy`> vixey: that's next month
14:22:33 <thoughtpolice> Lemmih: for now I can just not commit that and have lhc look in the short-version directory
14:22:40 <thoughtpolice> i.e. ~/.cabal/lib/lhc-0.6
14:22:48 <thoughtpolice> but we need cabal to install it there, at least
14:23:33 <Lemmih> thoughtpolice: cabal-install installs in lhc-0.6 for me.
14:23:56 <dcoutts> Lemmih: I'll do:
14:23:57 <dcoutts> -- lhc considers only the first two version digits to be significant
14:23:57 <dcoutts> version             = Version (take 2 vs) []
14:24:14 <thoughtpolice> dcoutts: that will work
14:24:24 <thoughtpolice> Lemmih: for me if I 'cabal install -fwith-base' it can't find where base is installed
14:24:38 <thoughtpolice> but if we can agree on the first two digits, e.g. 0.6, that's fine
14:24:43 <Lemmih> dcoutts: We only consider the two first version digits to be significant?
14:25:27 <Lemmih> thoughtpolice: Perhaps 'runghc Setup' acts differently from 'cabal install'.
14:25:28 <dcoutts> Lemmih: ok, what comment would make more sense?
14:25:53 <centrinia> @pl \n -> length . permutations $ [1..n]
14:25:53 <lambdabot> length . permutations . enumFromTo 1
14:26:05 <Lemmih> dcoutts: You tell me. I'm still trying to sort out what exactly we want to do.
14:26:11 <centrinia> Is that a good way to compute the factorial?
14:26:32 <dcoutts> Lemmih: heh, ok. Well the new will be easier to change if you need to change it.
14:26:37 <thoughtpolice> Lemmih: it does, afaict, cabal install automatically prefixes things to ~/.cabal
14:26:42 <augustss> centrinia: no
14:27:00 <thoughtpolice> Lemmih: which is fine, I have lhc looking in the right spots already, but it just can't get the version number part right
14:27:02 <vixey> product . enumFromTo 1
14:27:04 <augustss> centrinia: but it's a cool way
14:27:21 <ddarius> "Let's take an easy problem and make it hard!"
14:28:14 <lament> the official haskell slogan?
14:28:33 <dcoutts> thoughtpolice: ideally it would not matter where the user chooses to register lhc libs
14:28:36 <dons> Let's take an impossible problem and make it happen
14:28:49 <dcoutts> thoughtpolice: I thought it didn't, I thought lhc used ghc-pkg for its package db?
14:28:52 <Lemmih> thoughtpolice: Let's index the libraries with three version digits.
14:29:33 <Lemmih> dcoutts: lhc doesn't use ghc-pkg. Cabal-install uses ghc-pkg for package depdendencies.
14:29:40 <thoughtpolice> Lemmih: ok, so make lhc look in e.g. ~/.cabal/lib/lhc-0.6.20081211 ?
14:29:53 <Lemmih> thoughtpolice: Right.
14:30:20 <thoughtpolice> Lemmih: k, I'll change that in my patch
14:30:35 <thoughtpolice> Lemmih: and we need for cabal to use the first three version digits
14:30:36 <Lemmih> dcoutts: cabal-install needs a bunch of meta information that LHC just doesn't keep around.
14:30:56 <dcoutts> Lemmih: we really only need package ids and dependencies
14:31:04 <Lemmih> (such as which depdendencies a library was compiled against)
14:31:15 * Badger chuckles.
14:31:28 <Badger> large hadron collider - in haskell :)
14:31:29 <augustss> So #haskell has 561 people in it now.  But it's old people who keep up the chatter. :)
14:31:45 <dcoutts> augustss: indeed :-)
14:31:49 <dcoutts> Lemmih: how do you link things then if you don't know the deps ?
14:31:57 <Botje> brute force!
14:31:59 * Lemmih doesn't feel very old.
14:32:19 <augustss> Lemmih: Haskell-old
14:32:24 <dons> augustss: comes in waves. lots of new faces yesterday
14:32:25 * Botje has not even reached 11000 yet
14:32:52 <walski> I've got this list: [(6,Just (TokVar [I,F,A] A [Two,Three]),"."),(2,Just TokIf,"aa23."),(0,Nothing,"ifaa23.")] and would like to build a function similar to maximum
14:33:02 <Lemmih> dcoutts: Link? LHC is a full-program optimizer. We generate a single C file and hand it over to GCC.
14:33:05 <walski> it should take the first element of each tuple into account for ordering
14:33:07 <wjt> dons: what happened yesterday to get them to appear, I wonder.
14:33:15 <Pseudonym> Large Haskell Collider?
14:33:32 <Botje> walski: maximumBy (compare `on` fst)
14:33:33 <chessguy> if i have a [State MyState ()], what's the best way to process them atomically, indicating the right error message if one fails?
14:33:35 <dcoutts> Lemmih: so each library includes all of its dependencies?
14:33:41 <walski> Botje: Thanks!
14:34:11 <Botje> what does fail in the state monad do?
14:34:20 <Lemmih> dcoutts: cabal-install tells us which dependencies to load.
14:34:32 <thoughtpolice> dcoutts: when you compile an application it essentially compiles all the libraries it depends on with it at once, too
14:34:33 <Botje> @src fail (State s)
14:34:33 <lambdabot> Source not found. You type like i drive.
14:34:35 <dcoutts> Lemmih: ahhh
14:35:30 <chessguy> Botje:  i would assume it just calls error
14:35:38 <Botje> that'd be lame
14:35:46 <augustss> fail is lame
14:36:08 <Botje> chessguy: ooh. you could use ErrorT State ?
14:36:20 <Botje> then you can just do sequence
14:36:25 <chessguy> Botje:  what would that look like?
14:37:04 <dcoutts> thoughtpolice, Lemmih: just pushing that lhc version change to darcs Cabal
14:37:09 <thoughtpolice> dcoutts: ok well my patch makes lhc index by the first three version numbers, so can you make cabal install using the first three version digits as well in your patch?
14:37:13 <thoughtpolice> dcoutts: k
14:37:33 <dcoutts> thoughtpolice: oh, I was just using all of them, which is currently 3
14:37:37 <Botje> runErrorT (runState (sequence actions) s)
14:37:43 <thoughtpolice> dcoutts: ah ok then that's fine
14:37:48 <Botje> ehh
14:37:49 <Lemmih> dcoutts: It's four now.
14:37:58 <Botje> i think
14:37:59 <thoughtpolice> well it should just use all of them
14:38:01 <Botje> anybody help?
14:38:01 <dcoutts> ok, and you only want 3 ?
14:38:10 <thoughtpolice> 3 is sufficient, yes
14:38:10 * dcoutts cancels the push
14:38:21 <dcoutts> 3 is more complicated than all :-)
14:38:33 <chessguy> @type sequence []
14:38:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => m [a]
14:38:44 <thoughtpolice> the only reason LHC has 4 digit versions right now is basically just for build fixes when we upload a version to hackage
14:38:53 <chessguy> @type runState (sequence []) ?s)
14:38:54 <lambdabot> parse error on input `)'
14:39:00 <Botje> chessguy: that's the rough shape i think, but i'm a bit brainburned at the moment
14:39:04 <Botje> so i'm very probably wrong
14:39:04 <thoughtpolice> e.g. the only difference between 0.6.20081210 and 0.6.20081210.1 was that I had to fix the cabal file
14:39:12 <chessguy> @type runState (sequence []) ?s
14:39:13 <lambdabot> forall s a. (?s::s) => ([a], s)
14:39:22 <thoughtpolice> well, at least that's why I've been giving it four version numbers...
14:39:26 <thoughtpolice> 3 is perfectly sufficient
14:39:34 <walski> Where do I get maximumBy and `on` from?
14:39:34 <Badger> > sequence []
14:39:36 <lambdabot>       No instance for (Show (m [a]))
14:39:36 <lambdabot>        arising from a use of `show' at <...
14:39:38 <chessguy> @type evalState (sequence []) ?s
14:39:39 <lambdabot> forall s a. (?s::s) => [a]
14:39:42 <walski> just import List seems not to work
14:39:56 <Botje> walski: maximumBy is in Data.List
14:40:03 <Botje> on is a relatively new function
14:40:18 <chessguy> @type runErrorT(execState (sequence []) ?s)
14:40:20 <lambdabot> forall e (m :: * -> *) a. (?s::ErrorT e m a) => m (Either e a)
14:40:46 <chessguy> hm, that doesn't look right
14:40:49 <Botje> indeed
14:41:03 <walski> and `on` should be in the Prelude?
14:41:08 <Botje> @type execState (runErrorT undefined) ?s
14:41:09 <lambdabot> forall s. (?s::s) => s
14:41:15 <Botje> chessguy: that looks better
14:41:17 <chessguy> @hoogle on
14:41:17 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
14:41:17 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
14:41:17 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
14:41:28 <Botje> @src on
14:41:28 <lambdabot> (*) `on` f = \x y -> f x * f y
14:41:55 <ski_> @src off
14:41:55 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
14:42:10 <chessguy> @type runState (runErrorT (sequence [])) ?s -- like this?
14:42:11 <lambdabot> forall e s a. (?s::s, Error e) => (Either e [a], s)
14:42:48 <chessguy> @type execState (runErrorT (sequence [])) ?s -- like this?
14:42:49 <lambdabot>     Ambiguous type variable `e' in the constraint:
14:42:49 <lambdabot>       `Error e' arising from a use of `sequence' at <interactive>:1:22-32
14:42:49 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
14:43:19 <Botje> execstate returns the state, yes
14:43:40 <Botje> but i think you still need the return value
14:45:08 <alexei_> if I want too look at implementation of "sequence" where do I find it? I dont find any sources under http://haskell.org/ghc/docs/latest
14:45:30 <sjanssen> alexei_: try the docs for GHC 6.8.3
14:45:44 <vixey> @src sequence
14:45:45 <lambdabot> sequence []     = return []
14:45:45 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:45:45 <lambdabot> --OR
14:45:45 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
14:46:33 <walski> Is there anything like fst for tuple with more than two elements?
14:46:40 <sjanssen> no
14:46:46 <mrd> its evil!!
14:47:09 <lament> cadadddaddr
14:47:16 <mrd> car
14:47:35 <augustss> mmmmm
14:47:51 <tristes_tigres> Hello
14:47:52 <augustss> Lisp has the best names for those
14:50:04 <kristofer> http://hpaste.org/12981 <- what am I doing wrong with my binding operation?
14:50:16 <alexei_> so, according to @src sequence works only for List monad? Why is it called sequence then?
14:50:30 <Botje> alexei_: it works for all monads
14:50:38 <Botje> @src sequence
14:50:38 <lambdabot> sequence []     = return []
14:50:38 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:50:38 <lambdabot> --OR
14:50:38 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
14:50:44 <Botje> look carefully at the returns
14:50:48 <Botje> or rather
14:50:50 <Botje> :t sequence
14:50:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
14:51:02 <Botje> if m is IO sequence is [IO a] -> IO [a]
14:51:03 <tristes_tigres> http://hpaste.org/12982
14:51:06 <tristes_tigres> why ?
14:51:34 <Botje> tristes_tigres: you can't bind the same variable in a parameter list
14:51:50 <Botje> tst x y | x == infinity && y == infinity = 1
14:51:57 <tristes_tigres> infinity isn't a variable
14:52:10 <Botje> of course it is
14:52:14 <augustss> Wow, that's a bad error message
14:52:23 <Botje> it's not a type constructor, so it must be a variable
14:52:30 <Botje> s/type/data/
14:52:45 <hellige> you can't use pattern matching to test equality like that, either with two patterns or a pattern against a value from someplace else.
14:52:45 <tristes_tigres> Botje: it's a constant
14:52:50 <hellige> in this case, you're trying to do both.
14:52:56 <Botje> tristes_tigres: no, it's a variable :)
14:53:13 <augustss> tristes_tigres: You can only pattern match on constructors, not constants
14:53:15 <Botje> the infinity in the pattern has NOTHING to do with the globally declared infinity
14:53:49 <tristes_tigres> augustus: so I can't say tst 1 1 = True ?
14:54:04 <Botje> kristofer: char '"' >>= \_ -> (many (noneOf "\"")) >>= \x -> char '"' >>= \_ -> return $ String x
14:54:16 <augustss> tristes_tigres: 1 is an "honorary" constructor :)
14:54:21 <Botje> or replace ">>= \_ -> " by >>
14:54:41 <tristes_tigres> augustuss: tst x x = True ?
14:54:47 <hellige> tristes_tigres: nope
14:54:48 <kristofer> Botje, what's the \_ mean in that sense?
14:54:55 <Botje> kristofer: "ignore the result"
14:54:56 <hellige> tristes_tigres: that will result in the same error message.
14:54:58 <alexei_> Botje:  ok, so sequence operates with two monads, one is necessarily the List monad.
14:55:02 <tristes_tigres> hellige : any good reason for that ?
14:55:30 <augustss> tristes_tigres: Not a very good reason, just a design decision
14:55:31 <Botje> alexei_: nah, sequence takes a list of m a's, evaluates them, and returns a list of the results
14:55:38 <Botje> no list monad involved
14:55:49 <hellige> tristes_tigres: well, it would introduce the semantic notion of equality (the Eq class) into pattern matching. you could choose to do it, they chose not to.
14:55:59 <sjanssen> @type sequence
14:56:00 <hellige> tristes_tigres: yep, just a design decision.
14:56:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
14:56:10 <augustss> tristes_tigres: you'd have to say tst x x' | x==x' = True
14:56:54 <ozy`> > f _ = 5 -- kristofer: this function ignores its argument
14:56:55 <augustss> tristes_tigres: btw, comparing infinity in any way will never terminate
14:56:55 <lambdabot>   <no location info>: parse error on input `='
14:57:00 <Apocalisp> @type Data.Traversable.sequence
14:57:02 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Monad m, Data.Traversable.Traversable t) => t (m a) -> m (t a)
14:57:14 <tristes_tigres> ok, thanks. What about lEq _ infinity = True ; lEq a b = a <= b
14:57:17 <Apocalisp> alexei_, ^^^
14:57:20 <ozy`> > (\_ -> 5) -- an anonymous version of the same thing
14:57:21 <lambdabot>       Overlapping instances for Show (t1 -> t)
14:57:21 <lambdabot>        arising from a use of `...
14:57:23 <tristes_tigres> gives warning about overlapping pattern
14:57:35 <kristofer> ozy`, gotcha. thanks
14:57:40 <psnively> Yo.
14:57:47 <Apocalisp> Tu.
14:58:00 <tristes_tigres> augustuss: yes iut will
14:58:07 <augustss> tristes_tigres: any lower case name in a pattern will be bound in the pattern matching.  it has nothing to do with anything else with the same name
14:58:09 <thoughtpolice> dcoutts: did you push that patch?
14:58:34 <alexei_> Apocalisp: so rather "one is necessarily necessarily a Traversable monad" then?
14:58:36 <tristes_tigres> augustuss: don't pattern matchings work in sequence ?
14:58:56 <hellige> tristes_tigres: the problem is the first pattern: it's the same as lEq _ x = True
14:59:03 <augustss> tristes_tigres: yes, left-to-right, top-to-bottom
14:59:06 <hellige> the fact that you use the name infinity is totally irrelevant.
14:59:16 <hellige> so both patterns are basically the same.
14:59:27 <hellige> lEq _ x vs. lEq a b
14:59:28 <Apocalisp> @instances Data.Traversable.Traversable
14:59:28 <lambdabot> Maybe, []
14:59:31 <hellige> they both match everything.
14:59:57 <tristes_tigres> hellige: the definition of infinity doesn't cope into the pattern matching ?
15:00:01 <tristes_tigres> scope
15:00:07 <augustss> no
15:00:15 <hellige> tristes_tigres: no. the pattern matching "shadows" the outer binding
15:00:16 <Cale> augustss: Did you get roconnor's patch for numbers?
15:00:28 <augustss> Cale: yes
15:00:33 <Cale> cool :)
15:01:02 <augustss> Cale: I actually have some new code for the contructive reals from David Lester, but I've not incorporated that yet.
15:01:18 <chessguy> @hoogle ErrorT
15:01:19 <lambdabot> Control.Monad.Error newtype ErrorT e m a
15:01:19 <lambdabot> Control.Monad.Error ErrorT :: m (Either e a) -> ErrorT e m a
15:01:19 <lambdabot> System.IO.Error alreadyExistsErrorType :: IOErrorType
15:01:30 <tristes_tigres> it also seems to me that logical op || does not short-circuit as in C
15:01:40 <Cale> augustss: neat -- does it perform better?
15:01:52 <augustss> Cale: I have no idea
15:01:59 <augustss> He just said it was improved
15:02:03 <vixey> @src (||)
15:02:03 <lambdabot> True  || _ =  True
15:02:03 <lambdabot> False || x =  x
15:02:14 <hellige> tristes_tigres: why does that seem to be the case?
15:02:15 <Cale> augustss: I found that some computations on CReals got prohibitively slow really quickly.
15:02:25 <augustss> Cale: yeah, they do
15:02:28 <Cale> (like, even for getting the first few digits)
15:03:06 <augustss> > True || error "Oh no"
15:03:08 <lambdabot>   True
15:03:11 <Cale> It might just be a hard limitation, but it would be nice if it was practical at practical precisions.
15:03:53 <alexei_> still canot find those nicely html formatted and colored sources for Haskell libraries at haskell.org ... Anybody seen Data.Traversable.sequence?
15:04:04 <augustss> Cale: David's implementation was mostly concered with correctness, I think.  He's proven the algorithms correct using PVS.
15:04:09 <Apocalisp> alexei_, I think that not all monads are Traversable, and not all Traversables are monads either.
15:06:28 <tristes_tigres> hellige : lEq x y  = (y == infinity) || (x <= y) does not terminate
15:06:40 <tristes_tigres> lEq x y  = (y == infinity) || (x <= y)
15:06:44 <tristes_tigres> hangs
15:06:54 <augustss> tristes_tigres: I told you so
15:07:06 <tristes_tigres> *Main> (Succ Zero) < infinity
15:07:06 <tristes_tigres> True
15:07:24 <hellige> tristes_tigres: haha, yeah, he did tell you so...
15:07:34 <tristes_tigres> augustuss: comparison with infinity does terminate
15:07:41 <augustss> tristes_tigres: I meant when comparing two infinities
15:07:44 <hellige> tristes_tigres: trust me, the problem is not with (||)
15:07:53 <ddarius> And equality does not terminate.
15:08:11 <tristes_tigres> that's why I asked why || doe not short-cirsuit
15:08:27 <augustss> tristes_tigres: || does short circuit
15:08:31 <hellige> tristes_tigres: but (||) *does* short-circuit, assuming its first argument terminates.
15:08:31 <vixey> > infinity < infinity + 1
15:08:47 <lambdabot>   thread killed
15:08:48 <vixey> oh I see what you want
15:08:56 <vixey> tristes_tigres, computation monad
15:09:01 <tristes_tigres> (Succ Zero) < infinity does terminate as I said
15:09:12 <tristes_tigres> it is first term in ||
15:09:20 <tristes_tigres> it should short-cirsuit
15:09:30 <vixey> Now True || _ = Now True
15:09:34 <augustss> tristes_tigres: yes, but infinity==infinity will not terminate
15:09:37 <vixey> _ || Now True = Now True
15:09:42 <vixey> x || y = do x <- tick x ; y <- tick y ; x || y
15:10:04 <tristes_tigres> augustuss: so ? it should be a problem in lEq (succ Zero) infinity
15:10:17 <tristes_tigres> should not
15:10:32 <Gracenotes> @info infinity
15:10:33 <lambdabot> infinity
15:10:35 <dons> ?userrrrrs
15:10:35 <lambdabot> Unknown command, try @list
15:10:38 <dons> ?userrs
15:10:38 <lambdabot> Maximum users seen in #haskell: 578, currently: 553 (95.7%), active: 26 (4.7%)
15:10:46 <Gracenotes> hm.
15:10:47 <augustss> tristes_tigres: but y is infinity, so y==infinity will not terminate
15:10:47 <hellige> tristes_tigres: sure it should.
15:10:48 <ddarius> 581 is the actual high
15:11:06 <vixey> that's not as high as 600!
15:11:10 <ski_> infinity = Supremum (Nat.foldNat Zero Succ)
15:11:15 <augustss> ?usseerrrsss
15:11:16 <lambdabot> Unknown command, try @list
15:11:21 <tristes_tigres> oh yes, right. So is it possible to assert that lEq _ inifinity is always true ?
15:11:29 <vixey> infinity = Fix Delay -- too
15:11:53 <vixey> hm ski_ that = Supremem id?
15:11:53 <augustss> tristes_tigres: No
15:11:58 <hellige> tristes_tigres: no
15:12:07 <vixey> tristes_tigres, yes!
15:12:22 <ski_> vixey : `Supremum :: (Natural -> Ordinal) -> Ordinal'
15:12:27 <vixey> ooh ok
15:12:32 <tristes_tigres> opinions differ, I see :-)
15:12:35 <vixey> I think I've saw
15:12:38 <augustss> vixey: Not with the current definition
15:12:47 <vixey> Supremum :: (Ordinal -> Ordinal) -> Ordinal
15:12:52 <Gracenotes> @hoogle Supremum
15:12:53 <vixey> but is that maybe illegal?
15:12:53 <lambdabot> No results found
15:13:00 <ddarius> tristes_tigres: vixey is talking about using a different representation
15:13:03 <vixey> I don't really understand why -> is a number
15:13:05 <Gracenotes> heh. silly me.
15:13:05 <sjanssen> tristes_tigres: it isn't possible to write that anyway, how do you prove the second argument is infinity?
15:13:15 * vixey  I am always talking about something else that people meant.. :/
15:13:22 <hellige> tristes_tigres: well, actually, it's quite possible to write that lEq x _ = True, if x is not infinity.
15:13:27 <hellige> which is *almost* the same thing.
15:13:37 <hellige> what you cannot write, is that lEq infinity _ = False
15:13:54 <ski_> (vixey : `Supremum (\i -> x i)' is meant to represent the smallest ordinal larger than `x i' for all naturals `i')
15:14:23 <tristes_tigres> sjansen : it isnt possible to prove that a value is infinity ?
15:14:46 <ski_> tristes_tigres : `prove' is not the same as `compute'
15:14:47 <hellige> tristes_tigres: how could you, in a finite amount of time?
15:15:05 <tristes_tigres> hellige: I seem to do it just fine by looking at the code
15:15:06 <hellige> tristes_tigres: you never know if the next nested thing will be Zero... you have to keep checking forever.
15:15:20 <vixey> hmm
15:15:22 <hellige> tristes_tigres: you're just relying on the names. that's cheating.
15:15:24 <augustss> tristes_tigres: you could just derive Ord for your data type and it will work as well as can be expected. x < infinity will be true for all finite x
15:15:33 <vixey> that's really bizarre
15:15:38 <tristes_tigres> hellige: but I know that succ inifinity is the same thing as infinity
15:15:46 <vixey> You know this (->) constructor still confuses me
15:16:14 <leimy> are you trying to tell me infinity is a value?
15:16:16 <augustss> tristes_tigres: you know, yes.  but it's a rather complicated argument to show that, involving fixpoint induction
15:16:17 <tristes_tigres> hellige: no. I can say for any name that if Succ x == x, than x is inifinty
15:16:19 <ski_> (<http://blog.jbapple.com/2007/02/countable-ordinals-in-haskell.html> seems to talk some about ordinals)
15:16:20 <hellige> tristes_tigres: but you're cheating again... when inspecting Succ x (for some x), you don't know yet whether x is infinity!
15:16:26 <leimy> in math infinity is merely treated as a number.
15:16:30 <leimy> I don't believe it is a number
15:16:30 <tristes_tigres> leimy: yes it is
15:16:44 <vixey> yes
15:16:50 <leimy> it's not a real
15:16:50 <ski_> leimy : define `number'
15:16:52 <tristes_tigres> hellige : no
15:16:53 <leimy> it's not a num
15:16:54 <augustss> leimy: mostly it's not treated as a number
15:17:01 <hellige> tristes_tigres: sure, but how do you prove that Succ x == x, without actually checking them for equality?
15:17:02 <Philippa> leimy: who said Num => Real?
15:17:02 <vixey> leimy, I've never seen infinity treated like a number in any mathematical presentations
15:17:05 <devragert> i have a question
15:17:07 <leimy> it's usually used in limits
15:17:10 <leimy> aleph numbers
15:17:11 <leimy> etc
15:17:13 <vixey> leimy, it's only these computer science nuts :P
15:17:14 <leimy> but it's not like 3
15:17:16 <leimy> not the same ting.
15:17:17 <devragert> when i have a function like this:
15:17:19 <leimy> er thing
15:17:19 <chessguy> @pl \n -> (e $ r $ b n) x
15:17:20 <lambdabot> flip e x . r . b
15:17:23 <tristes_tigres> vixey: how about IEEE 754 ?
15:17:32 <augustss> vixey: and other nuts too
15:17:40 <leimy> vixey: ever had calculus?
15:17:46 <leimy> if so, you've seen it used where numbers are used
15:17:49 <ddarius> augustss: Like those crazy non-standard analysis nuts.
15:17:53 <augustss> tristes_tigres: IEEE 754 has very little to do with numbers
15:17:55 <tristes_tigres> vixey: it defines all arithmetic operation for Inf
15:17:57 <leimy> limits for instance
15:18:03 <devragert> how do i do something like this:
15:18:04 <tristes_tigres> augustuss: yeah sure
15:18:08 <wjt> bah. i wish cabal install foo would try to satisfy deps from my package manager first
15:18:14 <Philippa> @remember augustss IEEE 754 has very little to do with numbers
15:18:14 <lambdabot> Done.
15:18:21 * ski_ waves the SDG flag
15:18:24 <augustss> tristes_tigres: IEEE 754 is a bunch of rational numbers with bizarre operations defined on them
15:18:27 <Philippa> (because it deserves QotW)
15:18:28 <tristes_tigres> helllige: I don't need to
15:18:40 <Pseudonym> IEEE 754 is a _finite_ set of numbers.
15:18:52 <ddarius> ski_: SDG folks don't use (a notion of) infinity as a number.
15:18:54 <augustss> Pseudonym: but with bizarre operations
15:18:56 <leimy> I'm more inclined to think of infinity in programming as a thunk than a value :-)
15:18:58 <tristes_tigres> augustusss: so it DOES have to do with numbers
15:19:05 <Pseudonym> Indeed.  It's actually a huge lookup table.
15:19:15 <leimy> let infinity = 1 : infinity
15:19:17 <tristes_tigres> hellige: I just need to check that Succ x and x is the same thing
15:19:20 <leimy> or something like that :-)
15:19:25 <leimy> maybe that's just aleph zero
15:19:29 <Pseudonym> To be fair, if Gaussian integers are numbers, if finite groups are numbers, then IEEE 754 is numbers.
15:19:31 <ski_> (ddarius : yes, i know .. a bit related, though)
15:19:41 <augustss> tristes_tigres: yes, it's superficially like numbers.  but almost nothing you expect of numbers hold for floating point
15:19:43 <leimy> or aleph null if you prefer
15:20:04 <tristes_tigres> leimy: definition of infinity in http://darcs.haskell.org/htam/src/Number/PeanoNumber.hs is infinity = Succ infinity
15:20:19 <Pseudonym> Incidentally, drtomc currently has an application where 80-bit floats don't have enough precision in the exponent.
15:20:19 <leimy> tristes_tigres: Makes sense :-)
15:20:21 <dcoutts> thoughtpolice: sorry, yes now pushed
15:20:25 <augustss> Pseudonym: the confusing thing is that named some of the operations add, multiply and so on :)
15:20:33 <jsn> Pseudonym: oh?
15:20:37 <Pseudonym> Yeah.
15:21:21 <Pseudonym> Can't say much more at the moment.
15:21:32 <ddarius> 1:78:1 floating point!
15:21:36 <Pseudonym> But let me put it this way.
15:21:43 <tristes_tigres> hellige : so I should be able to check equality against inifinity
15:22:03 <Pseudonym> Significance tests are usually at the 5% or 1% confidence level.
15:22:20 <vixey> tristes_tigres, exactly what you are doing with infinity?
15:22:21 <hellige> hellige: excuse me?
15:22:25 <Pseudonym> If you're dealing with data sets on the order of 2^64, then even at a 1% confidence intervals, that's a hell of a lot of false matches.
15:22:25 <augustss> tristes_tigres: you can check, but it won't terminate
15:22:37 <Philippa> tristes_tigres: see division by zero. In fact, in the conaturals you get the right answer for it automatically with at least one obvious definition, too
15:22:37 <Pseudonym> So he has to compute some pretty small numbers.
15:22:38 <tristes_tigres> augustuss: In my head it terminates
15:22:39 <devragert> how can i do the following thing:
15:22:41 <devragert> f :: a -> b
15:22:42 <devragert> f x = result1     (look only to this line in case condition1)
15:22:44 <devragert> f x = result2     (look only to this line in case condition2)
15:22:45 <devragert> ... etc
15:22:47 <devragert> (I think I cannot use some kind of ordinary case construction, because then i can't make use of pattern matching on the x-argument)
15:22:55 <hellige> tristes_tigres: you cannot check that Succ x and x are the same thing.
15:22:56 <tristes_tigres> Philippa : in IEEE 754 /10 = Inf
15:22:59 <Cale> f x | condition1 = ...
15:23:00 <vixey> f x | condition1 = result1
15:23:02 <hellige> tristes_tigres: are you thinking of something like pointer equality?
15:23:04 <tristes_tigres> 1/0 i mean
15:23:14 <hellige> tristes_tigres: like, you want to ese if they are the same actual value in memory?
15:23:15 <tristes_tigres> hellige: why not ?
15:23:17 <Botje> devragert: f x | condition1 = ...
15:23:25 <vixey> that's a Scheme thing you want EQ?
15:23:32 <vixey> tristes_tigres, but again ..... exactly what you are doing with infinity?
15:23:36 <chessguy> ok, i'm sure i'm missing something silly here, but can someone help me figure out what this code should be? http://hpaste.org/12984
15:23:41 <Philippa> tristes_tigres: yeah. One obvious definition of division on conats gives you omega for it
15:23:42 <devragert> ah ok, thanks
15:23:45 <augustss> tristes_tigres: pointer equality has a very complicated semantics.  Haskell doesn't have that
15:23:54 <ddarius> tristes_tigres is clearly using an intensional equality that.  Unfortunately, that isn't available in Haskell and doesn't actually solve the problem much.
15:24:03 <chessguy> foo (runBuilder 3) results in "3", which is fine, but foo (runBuilder 2) doesn't
15:24:04 <tristes_tigres> vixey: shecking the orderness of a list of Peano numerals
15:24:13 <Philippa> of course, omega==omega never terminates, but hey
15:24:14 <hellige> ddarius: indeed. that's what i'm trying to get at...
15:24:29 <Philippa> you can still usefully compare smaller values against it
15:24:37 <tristes_tigres> augustuss: Who said anything about pointers ?
15:24:38 <vixey> tristes_tigres, oh right, and can you elaborate a bit more?
15:24:43 <chessguy> err, foo (runBuilder 2) results in "2", rather than an error
15:24:48 <Philippa> tristes_tigres: how else do you spot omega?
15:24:54 <lucca> chessguy: why buildPattern n | n == 2 = ... instead of just buildPattern 2 =
15:25:04 <ciscbrain> I want to "loop" over an array and set values according to the index, and all I could come up with is this:
15:25:05 <ciscbrain> foldl1 (>>) (map (\i -> writeArray arr i (i ^ 2)) [0..4])
15:25:09 <Botje> chessguy: i think you need to check the result of runState
15:25:12 <hellige> tristes_tigres: you say "check that Succ x and x are the same thing"
15:25:12 <tristes_tigres> vixey: trying to improve on definition of isAscending in http://darcs.haskell.org/htam/src/Number/PeanoNumber.hs
15:25:13 <chessguy> lucca:  whatever, this is throw away code
15:25:19 <hellige> tristes_tigres: WHAT DO YOU MEAN BY "SAME THING"?
15:25:19 <Philippa> hint: you can't look at the defining term, because you'd have to normalise it and it's not normalisable
15:25:19 <tristes_tigres> hellige: yes
15:25:24 <hellige> tristes_tigres: that's the whole question.
15:25:30 <sjanssen> ciscbrain: see mapM_
15:25:34 <ciscbrain> is there a simpler way?
15:25:43 <Philippa> hellige: PM?
15:25:50 <hellige> Philippa: sure
15:25:56 <chessguy> Botje:  oh! i need a case in runBuilder?
15:26:03 <vixey> tristes_tigres, got an example list of numbers for which isAscending doesn't work?
15:26:36 <ciscbrain> sjanssen: but I'd still have to fold with >> ?
15:26:45 <sjanssen> ciscbrain: no, mapM_ takes care of that
15:26:48 <ciscbrain> sjanssen: oh, yeah
15:26:56 <ciscbrain> sjanssen: thanks :D
15:26:58 <tristes_tigres> hellige: but I defined a value, for which Succ x is x BY DEFINITION
15:26:59 <sjanssen> ciscbrain: mapM_ (\i -> writeArray ...) [1 .. 4]
15:27:11 <hellige> tristes_tigres: NO. this is exactly the problem.
15:27:24 <ciscbrain> sjanssen: got it, thanks a lot
15:27:32 <tristes_tigres> vixey: look at the sorce of PeanoNumbers ?
15:27:32 <hellige> tristes_tigres: the only "by definition" you could mean would be something like scheme's "eq?", or C's "pointer equality"
15:27:33 <sjanssen> ciscbrain: oh, and #haskell regulations say that I must ask: are you sure you need to use a mutable array here?
15:27:37 <Botje> chessguy: changing execState for runState:
15:27:41 <Botje> Prelude++>runBuilder 2
15:27:41 <Botje> (Left "Bad!",Pattern (Node 0 []))
15:27:46 <Botje> Prelude++>runBuilder 3
15:27:48 <Botje> (Right (),Pattern (Node 3 []))
15:27:54 <hellige> tristes_tigres: haskell doesn't have any of that. so the fact that they are "the same" is NOT available to haskell.
15:28:11 <augustss> tristes_tigres: Haskell doesn't use intentional equality either.  == is defined by recursion
15:28:14 <hellige> tristes_tigres: the only notion of "the same" that is available is *structural* sameness, which means you have to check.
15:28:21 <vixey> tristes_tigres, yes
15:28:46 <vixey> tristes_tigres, ... got an example list of numbers for which isAscending doesn't work?
15:29:03 <ciscbrain> sjanssen: I'm doing some homework for a cryptography course
15:29:15 <tristes_tigres> vixey: isAscending (3:infinity:infinity:[4..] :: [T])
15:29:18 <augustss> tristes_tigres: what if you made two definitions of infinity, infinity1 and infinity2.  would you expect them to be tested as equal by ==?
15:29:29 <vixey> tristes_tigres, ah.. this is absolutely impossible to decide
15:29:46 <tristes_tigres> vixey: I decide it at once by looking at it
15:29:46 <sjanssen> ciscbrain: you don't have to justify it to me :).  It is just a common mistake of new Haskell users to use mutability when it isn't necessary
15:30:01 <vixey> tristes_tigres, you see the text not the data
15:30:21 <tristes_tigres> vixey: also isAscending (3:infinity:infinity:4:[] :: [T]) is decidable
15:30:24 <vixey> tristes_tigres, why don't you write Left 3:Right "infinity":Right "infinity":map Left [4..] to give Haskell a change
15:30:35 <vixey> tristes_tigres, no it's not decidable
15:30:44 <vixey> oh well yes it is actually
15:30:57 <augustss> vixey: yes, just a bit tricky
15:31:01 <vixey> tristes_tigres: ok I see it now
15:31:02 <ciscbrain> is there a (dis)advantage in using UArray instead of Array?
15:31:34 <ciscbrain> I only need it for Word64, I think
15:31:34 <dcoutts> ciscbrain: it's no longer lazy, so no self-referential arrays
15:32:04 <ciscbrain> dcoutts: you mean arrays that contain themselves?
15:32:24 <dcoutts> ciscbrain: I mean arrays that are defined in terms of themselves
15:32:42 <ciscbrain> how can do that?
15:32:42 <augustss> tristes_tigres: how about isAscending xs = and $ zipWith (<) xs (tail xs)
15:33:04 <tromp_> advantage: it can be more efficient
15:33:13 <tromp_> disadv: it can be less efficient:(
15:33:13 <augustss> hmmm, no that wont work
15:33:21 <augustss> need a better and
15:33:28 <ciscbrain> dcoutts: how can you do that? (with "normal" arrays, I mean)
15:33:33 <dcoutts> let arr = array bounds [ (i, arr ! (x+1)) | (i, x) <- something ]
15:33:36 <dcoutts> ciscbrain: ^^
15:33:52 <dcoutts> ciscbrain: that example probably doesn't work, but the point is that you can do things like that
15:33:56 <cjay> @arr
15:33:57 <lambdabot> Keelhaul the swabs!
15:34:03 <sjanssen> ciscbrain: arr = listArray (x, y) (0:[ arr ! (i-1) + 1 | i <- [x + 1 .. i]])
15:34:14 <dcoutts> ciscbrain: it's a nice trick for many dynamic programming problems
15:34:42 <dcoutts> where the definition of the problem involves an array where each element is defined in terms of other elements of the array
15:34:55 <dcoutts> along with a few "starter" elements
15:34:57 <sjanssen> > fix $ \arr -> listArray (0, 5) (0: [arr ! (i-1) + 1 | i <- [1 .. 5]])
15:34:59 <lambdabot>   array (0,5) [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5)]
15:35:43 <sjanssen> > fix $ \arr -> listArray (0, 5) (0 : 1 : [arr ! (i-1) + arr ! (i-2) | i <- [1 .. 5]])
15:35:46 <lambdabot>   array (0,5) [(0,0),(1,1),(2,* Exception: Error in array index
15:35:58 <sjanssen> > fix $ \arr -> listArray (0, 5) (0 : 1 : [arr ! (i-1) + arr ! (i-2) | i <- [2 .. 5]])
15:36:00 <lambdabot>   array (0,5) [(0,0),(1,1),(2,1),(3,2),(4,3),(5,5)]
15:36:12 <tristes_tigres> augustusss: isAscending (fromPosIntegral 3:infinity:infinity:fromPosIntegral 4:[] )
15:36:15 <dcoutts> ciscbrain: with such problems, the normal imperative approach is to work out some clever order in which to work out the array elements. That's quicker in the end, but it's neat that using lazy evaluation one does not need to work out the evaluation order, just let it work in a demand driven way.
15:36:31 <tristes_tigres> augustuss: does not terminate
15:37:08 <augustss> tristes_tigres: yeah.  isAscending is a little tricky.  But it can be done.  It will still not terminate if all elements of the list are infinity
15:37:14 <vixey> tristes_tirgres, I'll show how to do it using computation monad if you like
15:37:46 <tristes_tigres> vixey: yes? it would be interesting,
15:37:51 <ciscbrain> so if I refer to the
15:38:15 <ciscbrain> so if I refer to the array in the list, the array will only be computed once
15:38:30 <ciscbrain> but if I'd to this with recursive list definitions
15:38:34 <ciscbrain> I'd have exponential time?
15:38:51 <chessguy> Botje:  hmm, but i want runBuilder to return me an Either String (Pattern Int)
15:38:55 <ciscbrain> assuming I have multiple references
15:39:12 <sjanssen> ciscbrain: the list will only be computed once also, but an individual lookup would be O(n) instead of O(1)
15:39:22 <tristes_tigres> augustuss: It is not a big deal if it does not terminate when ALL elements are infinity? I think. But for things like (1:2:infinity:[1..]) it ought to terminate
15:39:26 <ciscbrain> I mean the n-th element being computed from n-1 and n-2
15:39:45 <Botje> chessguy: you could do (buildPattern n >> get)
15:39:57 <Botje> and then do evalState
15:40:08 <Botje> then you'll get Either String (Pattern Int) i think
15:40:34 <sjanssen> > fix $ \arr -> 0 : 1 : [arr !! (i-1) + arr !! (i - 2) | i <- [2 ..]] -- with lists
15:40:36 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:40:52 <ciscbrain> alpha a b = zipWith (+) (zipWith (*) (f a b) (1:alpha a b)) (0:1:alpha a b)
15:40:53 <augustss> tristes_tigres: vixey will show you how.  that way i don't have to. :)
15:41:04 <ciscbrain> for example, does the above code have exponential time?
15:41:05 * vixey has got a type error :)
15:41:09 <tristes_tigres> vixey will show us the way !
15:41:16 <tristes_tigres> *bow*
15:41:19 <sjanssen> ciscbrain: with both versions, all computation is shared, but with that list version it is O(n^2) to compute the nth number, while it is O(n) with arrays
15:41:32 <sjanssen> (assuming addition is constant time)
15:41:44 <chessguy> Botje:  nice
15:42:15 <sjanssen> ciscbrain: what is f?
15:42:51 <chessguy> @pl \n -> (e $ r $ b n >> g) x
15:42:52 <lambdabot> flip e x . r . (>> g) . b
15:43:04 <ciscbrain> sjanssen: just a simple function
15:43:41 <sjanssen> ciscbrain: you probably won't see as much sharing as you'd like.  GHC won't notice that "alpha a b" is on both the LHS and the RHS
15:44:27 <ciscbrain> sjanssen: well, the performance was terrible on that one :)
15:44:40 <ciscbrain> sjanssen: is it wrong to say that arrays defined like this actually behave like recursive list, but with memoization?
15:44:42 <sjanssen> ciscbrain: alpha a b = let alph = zipWith (+) (zipWith (*) (f a b) (1:alph)) (0:1:alph) in alph -- this will have the sharing you want
15:45:04 <sjanssen> ciscbrain: the problem in your example isn't the list, it's that you haven't given the value you want to share a name
15:45:33 <vixey> amm
15:45:35 <sjanssen> ciscbrain: you need to make sharing explicit with a let
15:45:40 <vixey> it didn't work immediately..
15:45:57 <tristes_tigres> vixey: if you ever get around to figuring out how to do it, drop a note to me at michael.tristes.tigres@gmail.com and CC to the author of PeanoNumbers.hs at haskell@henning-thielemann.de
15:46:26 <chessguy> Botje:  very cool
15:46:56 <sjanssen> ciscbrain: does that make sense?
15:47:24 <vixey> *Main> isAscending [1,infinity,infinity,1]
15:47:24 <vixey> *** Exception: stack overflow
15:47:27 <vixey> that's what I did wrong
15:47:37 <hugo___> hello Hppl
15:49:00 <ciscbrain> sjanssen: so ghc will try to share computations with a name?
15:49:32 <tristes_tigres> vixey: the orginal author's definition was isAscendingFiniteList
15:49:40 <Botje> chessguy: all hail the state monad! :)
15:49:48 <tristes_tigres> he did not notice that it breaks for infinite lists
15:49:59 <sjanssen> ciscbrain: GHC will always share computations that have been given the same name
15:50:06 <chessguy> Botje:  and ErrorT!
15:50:09 <tristes_tigres> it does handle the [1,infinity ,1 ] though
15:50:11 <ciscbrain> sjanssen: as long as it's not (directly) recursive?
15:50:15 <sjanssen> ciscbrain: this evaluation scheme is known as "laziness"
15:50:19 <sjanssen> ciscbrain: recursion is fine
15:50:33 <Botje> chessguy: and that :)
15:50:40 <vixey> tristes_tigres, I have to program omegarace to make it work :/
15:51:08 <ciscbrain> sjanssen: how does laziness fit into this? :)
15:52:02 <tristes_tigres> vixey: omegarace ? there seems to be a game by this name
15:52:35 <vixey> use omegarace to take the least fixed point instead of direct recursion I think
15:52:52 <vixey> see I thought it would be much easier.. :p
15:53:14 <ciscbrain> sjanssen: for example, if I call "fibonacci 10", "fibonacci" will only be evaluated once for each value of n?
15:53:43 <sjanssen> ciscbrain: what is the definition of fibonacci? (unless your defn. is clever, the answer is probably no)
15:53:54 <tristes_tigres> what is omegarace ?
15:54:15 <sjanssen> ciscbrain: if fibonacci n = fibonacci (n - 1) + fibonacci (n - 2) -- fibonacci will be called many times for each value of n
15:54:19 <tristes_tigres> tsomething from MonadFix ?
15:54:36 <ciscbrain> sjanssen: how does that differ from the definition of "alpha" above?
15:55:06 <sjanssen> ciscbrain: it doesn't differ from the definition of alpha you gave.  Take a closer look at the defn. I showed you
15:55:44 <erikc> quasiquoting is so awesome
15:55:45 <sjanssen> ciscbrain: notice that it uses let to name the self-referential recursion
15:56:12 <ciscbrain> sjanssen: alpha is a lot faster your way; you said that's because giving it a name will share computations
15:56:52 <hugo___> i love you guys
15:56:52 <thoughtpolice> Lemmih: I just added a new regression test (testing CPP) and I also pushed a patch so lhc will look in ~/.cabal/lib for lhc packages now
15:56:58 <thoughtpolice> Lemmih: I just added a new regression test (testing CPP) and I also pushed a patch so lhc will look in ~/.cabal/lib for lhc packages now
15:57:04 <sjanssen> ciscbrain: right
15:57:25 <sjanssen> ciscbrain: but in the recursive fibonacci example, we haven't named anything
15:57:30 <nj32> is this the main haskell channel?
15:58:14 <nj32>  is this the main haskell channel, one mentioned on haskell.org?
15:58:17 <ski_> > fixArr 7 $ \foo i -> smallestPrimeFactor (product [ foo j | j <- [0..i-1]] + 1)  where  fixArr n f = arr where arr = listArray (0,n-1) [ f (arr !) i | i <- range (0,n-1)]
15:58:20 <lambdabot>   array (0,6) [(0,2),(1,3),(2,7),(3,43),(4,13),(5,53),(6,5)]
15:58:24 <Philippa> nj32: yep
15:58:24 <dcoutts> nj32: 548 users, yes probably it is :-)
15:58:32 <nj32> thanks
15:58:49 <sjanssen> ciscbrain: fibonacci n = fibos !! (n - 1) + fibos !! (n - 2); fibos = 0 : 1 : map fibonacci [2 ..] -- will exhibit sharing
16:00:31 <ciscbrain> sjanssen: I think I got it.. thanks a million
16:01:40 <ciscbrain> sjanssen: does ghc ever forget stuff? I mean does it garbage collect any of the computed values?
16:01:46 <pumpkin> yup
16:01:53 <pumpkin> if you can't get at them anymore
16:02:02 <sjanssen> ciscbrain: yes, when there are no more references to them
16:03:02 <thoughtpolice> @tell Lemmih I added a new regression and added a patch that will make lhc look in ~/.cabal/lib for packages; I also bumped the version to 0.6.20081211.2 and uploaded to hackage
16:03:03 <lambdabot> Consider it noted.
16:03:13 <ozy`> ciscbrain: you can memoize--augh
16:04:30 <ski_> chessguy : that `fixArr ...' above is another example where each element in the array is defined directly in terms of every previous one
16:04:56 <ski_> er
16:04:59 <chessguy> ski_:  um...i think you intended that for someone else
16:05:18 <ski_> s/chessguy/ciscbrain/
16:05:42 <ski_> (didn't notice ciscbrain quit)
16:05:54 <nj32> could some one explain currying to me, or give a good reference please?
16:06:04 * chessguy had a panic-y moment for a second there when he thought he was supposed to have a clue what ski was talking about
16:06:10 <jsn> > 1 + 2
16:06:11 <lambdabot>   3
16:06:18 <ciscbrain> sorry, my router randomly closes connections
16:06:22 <jsn> > (1 +) 2
16:06:24 <lambdabot>   3
16:06:30 * Philippa wonders how many other people nj32 just PMed with the question
16:06:37 <Philippa> (don't do it!)
16:06:40 <jsn> Philippa: really?
16:06:41 <jsn> wow
16:07:23 <Philippa> googling "currying" finds the wikipedia article first hit and the haskell wiki article on the third for me
16:07:30 <nj32> Philippa: PMed only to you since you replied to one of my earlier questions
16:07:35 <dibblego> hello nj32, please use the channel for your questions
16:08:02 <chessguy> http://letmegooglethatforyou.com/?q=currying
16:08:16 <nj32> ok, thanks
16:08:59 <Philippa> bear in mind that sometimes the experts are the worst people to explain something to you: they may not think like you at all, in which case they won't make any sense
16:09:01 <llayland> Currying is so simple that it makes you think you must not be getting it.  At least for me
16:09:08 <orbitz> chessguy: i prefer to tinyurl it, so they don't see it coming
16:09:18 <Philippa> llayland: yeah. Haskell's like that a lot actually
16:09:29 <chessguy> orbitz:  but then nobody else gets the joke
16:09:44 <Philippa> mind you, it does take a little longer to get /all/ the consequences
16:09:54 <orbitz> chessguy: a joke can still be funny if nobody hears it!
16:10:04 <nj32> i get it
16:10:24 <nj32> i had some confusion regarding a declaration which was not clear from the wiki article
16:10:36 <llayland> indeed, the ramifications are harder to grasp than the concept
16:10:37 <nj32> may be i read a couple more again
16:11:36 <nj32> (llayland, Philippa), thanks
16:12:10 <Philippa> nj32: declarations in pointless style can be rather annoying like that if you got one of those?
16:12:18 <Philippa> somefunc = f . g, that kind of thing?
16:12:37 <llayland> nj32,   look at it this way.  I can have a function that adds 1 to a number or one that adds 2 to a number, and so on ...  I can create another function that selects one of these functions and applies it to a number.  <- that is the curried versiojn of add a number to a number
16:12:52 <nj32> no it's simpler
16:13:04 <nj32> i am like 2 days old to the language
16:13:16 <nj32> and got impatient (i guess)
16:13:46 <Philippa> heh, fair enough
16:13:58 <Philippa> right at the stage where you need the explanations regardless, then
16:16:03 <nj32> llayland: in a declaration like:  plus :: Int->(int -> Int)       plus x y = x + y
16:16:28 <nj32> i can see the (plus x) being replaced by the new function
16:16:48 <nj32> but how does this new function applied to y gets instantiated
16:17:02 <nj32> since we never declared such a function in the first place?
16:17:51 <llayland> because haskell knows that it has to exist, it creates it
16:18:24 <nj32> you mean a function of type: Int -> Int is created on the fly?
16:20:25 <stoneToad> nj32: you actually have already created it by your definition
16:20:42 <stoneToad> you only named the "outermost" function though
16:21:20 <nj32> it's intuitive for the types, but what about the pattens and the definitions
16:21:37 <stoneToad> foo x y = (x,y) is equivalent to foo = \x -> \y -> (x,y)
16:22:31 <stoneToad> you mean the syntax sugar that lets you write foo Just x = x and foo Nothing = 0 say?
16:23:03 <nj32> what's \x ?
16:23:16 <orbitz> \ create an anonymous func
16:24:10 <nj32> can you just tell me how the definition is created for the curryied function (by haskell)
16:24:16 <stoneToad> nj32: I just did
16:24:53 <nj32> you mean through anonymous functions taken out of my definition?
16:25:22 <stoneToad> you can name the others if you want to
16:25:31 <nj32> what do you say..
16:25:38 <nj32>  plus :: Int->(int -> Int)       plus x y = x + y
16:25:40 <stoneToad> with your "plus" function
16:25:41 <nj32> in this... show me
16:25:46 <stoneToad> plus5 = plus 5
16:25:58 <stoneToad> plus5 5 -- this prints 10
16:26:01 <nj32> just that?
16:26:04 <stoneToad> yup
16:26:28 <stoneToad> you should check out the tutorials on haskell.org
16:26:38 <nj32> there are so many.. i get lost
16:26:54 <nj32> i don't want to pick up too easy (gets boring) or too hard
16:27:24 <nj32> but i got (mostly) what you said
16:27:34 <stoneToad> hmm well if you're willing to buy a book, I'm really liking the Haskell School of Expression book
16:27:47 <nj32> for a noob?
16:27:56 <nj32> i have programmed in C for 4-5 years
16:28:06 <nj32> just taken up Haskell
16:28:06 <stoneToad> yea it should be good then
16:28:09 <nj32> k
16:28:22 <nj32> great thanks
16:28:34 <stoneToad> it assumes you've had some programing experience, but it teaches haskell from the start using multimedia applications
16:28:40 <stoneToad> <3 pretty pictures :D
16:28:43 <nj32> hehe
16:29:44 <stoneToad> you might also try taking a look at http://www.haskell.org/~pairwise/intro/intro.html
16:29:50 <nj32> k
16:29:57 <stoneToad> it claims to be a "Haskell Tutorial for C Programmers"
16:30:22 <nj32> Oh this one, I tried
16:30:25 <dancor> @let plus = (+)
16:30:27 <lambdabot>  Defined.
16:30:30 <dancor> @let plus5 = plus 5
16:30:31 <lambdabot>  Defined.
16:30:35 <dancor> > plus5 100
16:30:37 <lambdabot>   105
16:30:48 <dancor> > (+ 5) 100
16:30:50 <lambdabot>   105
16:30:53 <nj32> but midway i got bored
16:30:53 <dancor> > 100 + 5
16:30:55 <lambdabot>   105
16:31:15 <dancor> lambdabot is never boring
16:31:24 <nj32> the expression book seems nice
16:31:26 <llayland> nj32 I am also having a difficult time switching from imperative languages to haskell.  It helps me to remind myself that I am not creating functions but describing functions to the compiler.
16:31:51 <pjdelport> SoE is nice
16:32:00 <nj32> care to explain.. not defining functions..
16:32:42 <dancor> sounds like llayland to kind of talking about the difference between a function and a computation (things happening in order)
16:32:44 <pjdelport> spends more effort getting you to "think Haskell" than covering stuff you can go lookup in reference works
16:32:48 <nj32> if that's so.. what goes in the object file?
16:32:54 <pjdelport> which is great
16:33:28 <llayland> yes pjdelport - a critical distinction
16:33:35 <nj32> hmm
16:33:42 <Pseudonym> The weird part is that in Haskell, you say less.
16:33:51 <Pseudonym> You have to force yourself not to micromanage things.
16:33:58 <pjdelport> you type less, but say more :)
16:34:11 <Pseudonym> Almost.
16:34:18 <Pseudonym> The same amount of typing gives you more.
16:34:29 <nj32> one noob question? if there is no side effect (i have heard) how does anything happen
16:34:41 * dancor waits for a pun about "typing"
16:34:42 <Zao> Monads save the day.
16:34:43 <Pseudonym> By means of Warm Fuzzy Things.
16:34:55 <Pseudonym> Which we call "Monads", but you should think of them as Warm Fuzzy Things.
16:34:57 <nj32> i did I/O with putStr.. that's a side effect
16:34:59 <stoneToad> pjdelport: which is exactly what is needed for crossing over to haskell from an imperative language (being able to "think Haskell")
16:35:15 <Pseudonym> Monads are friendly, cute, cuddly and not the slightest bit scary.
16:35:27 <augustss> nj32: there are no side effect, but there effects :)
16:35:28 <llayland> lol
16:35:28 <stoneToad> nj32: it's a result
16:35:40 <augustss> there are effects, even
16:35:46 <stoneToad> nj32: 5 + 5 resulting in 10 isn't a side effect
16:36:00 <nj32> but I/O is a side effect, isn't it?
16:36:10 <stoneToad> not if you look at it the right way
16:36:22 <nj32> what's the right way?
16:36:23 <pjdelport> nj32: I/O doesn't need to happen "on the side"
16:36:27 <Pseudonym> nj32, if you're ready to actually know this stuff, there are plenty of monad tutorials.
16:36:27 <pjdelport> you can describe it explicitly
16:36:30 <augustss> nj32: people have started misusing the words "side effect"
16:36:34 <pjdelport> that's what Haskell does
16:36:40 <Cale> nj32: Executing (putStr "hello") has a side effect of printing "hello" on the screen. Evaluating it has none.
16:36:41 <Pseudonym> However, if you want to get familiar with the type system first, just believe it that it works.
16:37:01 <pjdelport> nj32: in other words, Haskell has first-class effects, instead of "side" effects
16:37:03 <Cale> nj32: (putStr "hello") is a value which *represents* printing hello on the screen, but normal evaluation doesn't make it happen
16:37:26 <nj32> Cale: normal eval does not make it happen?
16:37:31 <pjdelport> right
16:37:34 <nj32> then how will it print?
16:37:37 <Cale> Instead, you end up defining a value called main, which describes what to do, and the runtime system just executes that.
16:37:40 <dancor> i'm confused; haskell's i/o is very much side-effect-ful.  putStr "hello" doesn't have type World -> World, it has type IO ()
16:37:54 <pjdelport> nj32: it prints when the effect is executed by the runtime
16:37:59 <pumpkin> moo
16:38:00 <Pseudonym> nj32: You can think of it this way.  Generating a shell script is not the same thing as running it.
16:38:03 <stoneToad> dancor: because IO hides the world -> world thing
16:38:03 <ski_> > length (replicate 5 (putStrLn "hello !"))
16:38:04 <lambdabot>   5
16:38:06 <dibblego> dancor, IO () stands for World -> (World, ())
16:38:19 <pjdelport> nj32: which you usually arrange by assigning to "main"
16:38:22 <nj32> is run time independent of haskell's implementation (semantically)?
16:38:29 <Cale> dibblego: I hate that description ;)
16:38:32 <augustss> nj32: a totally different way of saying (and thinking) is that Haskell allows you exactly the same (side) effects as C.  But things will have different types in Haskell.
16:38:33 <dancor> stoneToad: sure.  but it seems simpler to me to explain IO () as () with i/o side effects allowed.
16:38:40 <dibblego> Cale, I do too actually :)
16:38:41 <pjdelport> nj32: more or less
16:39:04 <stoneToad> dancor: but it's not...
16:39:05 <Cale> It's easier to think of a value of type (IO t) as being the code for a program which might do some IO before producing a value of type t.
16:39:17 <Pseudonym> BTW, I happen to agree that the term "side-effects" should be banished from all Haskell tutorials and documentation except by contrast.
16:39:30 <Cale> Evaluating what this code is doesn't make it run, any more than loading some source code into a text editor makes the program run.
16:39:35 <dancor> stoneToad: then why isn't main implemented with State
16:39:45 <Pseudonym> Side-effects are effects that happen in an uncontrolled way.
16:39:51 <wagle> Cale, your text editor is too stupid then..  8)
16:39:54 <augustss> Pseudonym: the term is ok when used properly, which it almost never is
16:40:10 <Cale> In order to make the code run, you need an interpreter to carry it out.
16:40:14 <Pseudonym> Effects in Haskell don't happen on the side.
16:40:24 <stoneToad> dancor: why would it be?
16:40:33 <mokus> unsafePerformIO! ;-)
16:40:39 <stoneToad> lol mokus
16:41:12 * wagle looks for a turing complete refactoring engine
16:41:26 <ski_> (Pseudonym : amen)
16:41:28 <Philippa> augustss: I tend to be a little narked by the current definition of "pure" (that isn't short for "purely functional"), for that matter
16:41:30 <nj32> Is this discussion valid only for Interpreter or even for compilation?
16:41:42 <Philippa> I suspect the two go hand in hand
16:41:44 <dancor> main :: State World  seems like the right tool for the job of what you describe.  but it doesn't work bc world has to be magical
16:41:46 <stoneToad> nj32: haskell code runs the "same" in both
16:41:53 <stoneToad> compiler is just faster
16:42:02 <pjdelport> nj32: perhaps the simplest way to explain it is with the following:
16:42:02 <pjdelport> effects = [(print "hello"), (print "world")]
16:42:02 <pjdelport> main = effects !! 0
16:42:03 <Philippa> nj32: compilation too. Conceptually, the RTS or the OS does the execution
16:42:25 <pjdelport> nj32: that shows the difference between defining an effect, and having it executed
16:42:28 <Cale> nj32: You can *think* of the haskell runtime as interpreting the value main of type IO () and carrying out the instructions, even if that's not actually what GHC does ;)
16:42:30 <pjdelport> and how effects are first-class
16:42:46 <Pseudonym> The fore-runner of Hugs used to do that.
16:42:51 <Philippa> Cale: especially because it's actually not so difficult to see how what it actually does can be reached from that spec
16:42:52 <dancor> wagle: what about haskell + Language.Haskell.Exts.Parser
16:42:56 <pjdelport> the first line creates a list containing two objects, but doesn't print anything
16:43:14 <pjdelport> the second one arranges for the first object (effect) to be executed
16:43:18 <Philippa> Cale: consider that return is itself an effect :-)
16:43:22 <pjdelport> so the above program will print "hello"
16:43:35 <mokus> pjdelport: perhaps it would be even more illustrative if main started with do { effects <- return [...
16:43:37 <pjdelport> if you say main = effects !! 1, it would print "world" instead
16:43:52 <pjdelport> mokus: that just obscures it, IMHO
16:43:57 <wagle> dancor, hmm..  probably..  i was thinking along the lines of a partial evaluator
16:44:05 <pjdelport> the whole point is that there isn't magic
16:44:07 <dons> this guy could do with introduction to the broader community, http://eduard-munteanu.blogspot.com/2008/12/learning-haskell-part-2.html
16:44:17 * dancor thinks Monad's are hard because it's not clear what "effect" means.  it's not clear what counts as an effect
16:44:25 <nj32> k
16:44:38 <pjdelport> dancor: an IO object is an effect, basically
16:44:40 <dancor> but particular Monads are easy bc you are told what the effect is
16:44:46 <dons> doing something other than just computing a result?
16:45:01 <dancor> pjdelport: but there are effects with the List Monad as well
16:45:14 <pjdelport> not in the sense of I/O
16:45:21 * mokus thinks monads are hard because people think that it's the monad doing the magic, when in actuality it's the conceptual reification of the effects
16:45:44 <pjdelport> the list monad is just the list monad
16:45:44 <ski_> (because I/O is not (angelic) nondeterminism ..)
16:45:45 * dibblego doesn't think monads are hard
16:45:46 <mokus> the monad-ness is just a handy observation about what happens when you do that
16:45:50 <Pseudonym> Because "conceptual reification" sounds so much less scary than "monad".
16:45:58 <pjdelport> some people call all monads "effects" but this is just meaningless and confusing, i think
16:46:08 <mokus> well, I'm summarizing for #haskell, not for th eworld ;-)
16:46:16 <dancor> ok maybe it's better to say that monads encapsulate computations instead of effects
16:46:24 <Pseudonym> dibblego, it's like x = x + 1 in Basic.  It's not hard in retrospect.
16:46:31 <wagle> () >> ()
16:46:32 <mokus> dancor: monads in general don't
16:46:35 <redditbot> Martin Sulzmann's Blog: Equality, containment and intersection among regular expressions via symbolic manipulation
16:46:35 <mokus> the IO type does
16:46:39 <mokus> and it happens to be a monad
16:46:40 <dibblego> Pseudonym, completely agree
16:46:40 <pjdelport> dancor: monads *can*
16:46:46 <pjdelport> different monads do different things
16:47:11 <stoneToad> I think that the main problem is that monads are like c pointer arithmetic, you can use them for *anything*
16:47:11 <ski_> (pjdelport : why call just some monads "effects" ?)
16:47:19 <stoneToad> (nearly anything)
16:47:31 <pjdelport> ski_: because some monads are, like IO :)
16:47:45 <dancor> what distinguishes computations?  just that there are steps which can be ordered?
16:48:00 <pjdelport> define "computation" :)
16:48:04 <pjdelport> it's a vague word
16:48:16 <dancor> pjdelport: well what do monads encapsulate
16:48:30 <pjdelport> dancor: basically, the monad laws, and nothing more
16:48:37 <pjdelport> they're a general, non-specific pattern
16:48:44 <pjdelport> in the same way that say, monoids are
16:48:53 <ski_> pjdelport : and state and exceptions and continuations and (demonic) nondeterminism ? but not (angelic) nondeterminism and parsing and .. ?
16:48:55 <mokus> pjdelport: almost exactly the same way ;-)
16:49:06 <pjdelport> mokus: right
16:49:13 <pjdelport> dancor: do you know monoids?
16:49:33 <dancor> pjdelport: yes, and they have a much better conceptual reality to me
16:49:37 <pjdelport> right
16:49:41 <pjdelport> so basically, monads are like that
16:49:48 <pjdelport> they don't encapsulate anything specific
16:50:06 <pjdelport> their whole point is to be general and abstract
16:50:17 <dancor> a monoid is tied very closely to an operation to me
16:50:23 <dancor> and more clearly useful
16:50:25 <pjdelport> so just like you get many different things that can be treated as monoids
16:50:28 <dancor> a priori
16:50:35 <pjdelport> you get many different things that can be treated as monads
16:51:03 <augustss> monads are monoids
16:51:14 <pjdelport> that too
16:51:49 <ski_> monoids induce monads
16:51:56 <dancor> i would still like to have a better intuitive sense for what kinds of things can be described by monads
16:52:23 <Pseudonym> dancor: There are three standard things which are useful to know about.
16:52:27 <augustss> dos: I had to post a comment in eduard's blog :)
16:52:32 <pjdelport> dancor: i find the best way is to start with functors
16:52:35 <Pseudonym> But I should say by way of disclaimer that monads are what they are.
16:52:41 <Pseudonym> And these three are but examples.
16:52:48 <Pseudonym> 1. Overloaded semicolon operator.
16:52:52 <mokus> dancor: join is the Monad version of mappend
16:52:52 <pjdelport> dancor: Monads are a special case of Functors
16:53:07 <Pseudonym> The semicolon operator in Algol-like languages can, essentially, be overloaded.
16:53:11 <Pseudonym> And that forms a monad.
16:53:26 <Pseudonym> Can you picture that, dancor?
16:53:34 <dancor> yes
16:53:35 <ski_> (augustss : s/eduard/edwardk/ ?)
16:53:37 <Pseudonym> OK.
16:53:42 <Pseudonym> 2. Containers.
16:53:42 <athos> is there a "general" width for one tabstop that has prevailed for haskell?
16:53:48 <Pseudonym> List comprehensions are monads.
16:54:03 <stoneToad> athos: everything I've seen says use spaces
16:54:07 <Pseudonym> > [ x+y | x <- [1..3], y <- [2,4] ]
16:54:07 <augustss> ski_:  eduard munteanu
16:54:08 <lambdabot>   [3,5,4,6,5,7]
16:54:09 <Philippa> athos: "whatever looks good to the author", and soft tabs
16:54:12 <stoneToad> though I think the complier sees tabs as 8 chars
16:54:18 <athos> soft tabs for sure
16:54:19 <augustss> ski_: from dons link
16:54:19 <Pseudonym> > do { x <- [1..3]; y <- [2,4], return (x+y) }
16:54:20 <lambdabot>   <no location info>: parse error on input `,'
16:54:24 <stoneToad> 8 spaces
16:54:26 <Pseudonym> > do { x <- [1..3]; y <- [2,4]; return (x+y) }
16:54:27 <lambdabot>   [3,5,4,6,5,7]
16:54:31 <Pseudonym> dancor: Got it?
16:54:38 <Philippa> athos: it's pretty common to line things up, which leads to different indentation for different constructs
16:54:44 <athos> ah ok
16:54:47 <pjdelport> > (+) <$> [1..3] <*> [2,4]
16:54:48 <lambdabot>   [3,5,4,6,5,7]
16:54:52 <pjdelport> whee
16:54:58 <dancor> Pseudonym: yes
16:55:01 <Pseudonym> Right.
16:55:07 <Pseudonym> 3. Term substitution.
16:55:14 <Pseudonym> This one is a little trickier to visualise.
16:55:27 <Pseudonym> But the basic idea is, consider a term with "variables".
16:55:32 <athos> Philippa: so it's more like "hmm, this little thing directly placed under the = sign looks good" than "the only indention is: for every tab put 8 spaces!"
16:55:53 <Pseudonym> Say: data Expr b = Add (Expr b) (Expr b) | Var b
16:56:13 <Pseudonym> Uhm.
16:56:21 <Pseudonym> Say: data Expr b = Add (Expr b) (Expr b) | Lit Int | Var b
16:56:22 <Pseudonym> OK
16:56:27 <Pseudonym> So b is the type of a variable.
16:56:39 <Pseudonym> dancor: You're happy with that declaration?
16:57:03 <dancor> Pseudonym: sure
16:57:06 <Pseudonym> Right.
16:57:19 <Pseudonym> Now think about what it means to substitute an expression for a variable.
16:57:37 <Pseudonym> Let's say that you represent variables as Strings, say.
16:57:38 <Philippa> athos: yep
16:57:55 <Pseudonym> Now think of an operation which takes an expression, and performs a variable substitution.
16:58:14 <Pseudonym> It takes an Expr String, and a function String -> Expr String, and returns an Expr String
16:58:20 <Pseudonym> Right?
16:58:31 <dancor> yes
16:58:34 <Pseudonym> That's monad bind.
16:58:51 <Pseudonym> return x = Var x
16:59:07 <Pseudonym> (Add e1 e2) >>= k = Add (e1 >>= k) (e2 >>= k)
16:59:16 <Pseudonym> (Var v) >>= k = k v
16:59:32 <Pseudonym> So monads are terms with variable substitution.
16:59:35 <Pseudonym> In a sense.
16:59:44 <Pseudonym> So those are the three main places where you'll find them.
16:59:44 <dancor> would you say that most useful monads that have been discovered are similar to t
16:59:47 <dancor> hese three?  but they are not similar to each other in a way that can be usefull
16:59:50 <dancor> y generalized conceptually?
17:00:05 <Pseudonym> I'd say that over 99.9% of the uses of monads in Haskell are related to one of these three things.
17:00:28 <Pseudonym> You might need to squint a bit to get the last 0.9%.
17:01:06 <dancor> so it's kind of a cosmic coincidence that List and IO happen to satisfy the same laws?
17:01:19 <Pseudonym> No.
17:01:26 <Pseudonym> Because you can think of lists in two ways.
17:01:31 <Pseudonym> They're containers, from one point of view.
17:01:47 <Pseudonym> But they're also execution-with-nondeterminism from another point of view.
17:02:34 <Pseudonym> And you can also think of lists as a term substitution algebra.
17:02:47 <Pseudonym> That's been done more than once.
17:03:04 <Pseudonym> So lists are, I guess, the universal example in some sense.
17:03:07 <dancor> so do monads only do a "each line can affect all subsequent lines" control flow
17:03:51 <mokus> dancor: that's partially an artifact of the do-notation
17:04:09 <dancor> if i wanted a structure where "each line" could affect something crazy like only two lines later, would i use something not a monad
17:04:10 <mokus> which is essentially using the bind operator to compose the lines end to end
17:04:14 <stoneToad> are all the definitions in Data.List that also exist in the prelude identical?
17:04:26 <Philippa> dancor: mostly, yeah. You can think of >>= as an MLish let statement
17:04:34 <stoneToad> or should I be qualifying the import?
17:04:37 <dancor> "each line" is what-is-between-my->>=-like-things
17:04:53 <dancor> >>== probably
17:04:55 <dancor> (lol)
17:05:22 <mokus> dancor: >>= is a form of composition, and as such inherits the basic direction-of-flow of parameters to outputs
17:05:24 <centrinia> If you run ((>>) ((>>) (print "Hello")  (print " ")) (print "World!") ), can it be evaluated by first computing (\x -> (>>) x (print "World!")) and then evaluating ((>>) (print "Hello") (print " ")) with it?
17:05:52 <mokus> although of course what that "really" means can be much different
17:06:01 <dancor> mokus: yeah isn't that, the closure-ness, where the power of monads lies?
17:06:06 <mokus> for example in Control.Monad.Cont
17:06:34 <dancor> Closureads
17:06:55 <mokus> yea, it's a part of what makes the monads
17:07:13 <dibblego> the power of monads lies in the fact that you can write many useful functions across the abstraction
17:07:19 <mokus> but what I'm really getting at is that you're still doing the same operation, just in a different category
17:07:24 <mokus> (the kleisli category)
17:07:56 <mokus> and because it's a composition, the 'effects' move downstream
17:07:58 <dancor> dibblego: of course.  but i need a little more meaning in my life
17:08:02 <mokus> like function composition
17:08:09 <dancor> beyond the post-hoc
17:08:29 <dibblego> dancor, I'm not sure how much more meaning you can get
17:08:46 <augustss> This should be added somewhere: instance (Monad m) => Monoid (a -> m a) where mempty = return; mappend = (<=<)
17:09:19 <dancor> this closure-as-source-of-monad-power idea seems potentially meaningful
17:09:31 <centrinia> Is it possible to evaluate the function (>>= f) and then evaluate its argument?
17:10:29 <dancor> centrinia: so do you want like (>>= f) with :: m (m a)  ?
17:10:33 <augustss> centrinia: depends on the monad
17:12:08 <centrinia> I think (>>= f) :: (Monad m) => m a -> m b
17:12:44 <mokus> centrinia: given that f :: a -> m b, yes
17:13:36 <mokus> I don't quite understand what you meant by your question though
17:13:50 <centrinia> If I want to run (g >>= f), isn't it up to the compiler to decide if it should evaluate g or (>>= f) first?
17:14:11 <mokus> yea
17:14:11 <ski_> (augustss : possibly abstract into `newtype MEndo m a = ME (a -> m a)' ..)
17:14:24 <mokus> although 'evaluation' may not mean what you think in that context
17:14:57 <mokus> if m is IO, for example, "evaluation" would mean construction of the IO action composed of both
17:15:05 <centrinia> If the compiler decides to evaluate (>>= \x -> print "World!") before evaluating (print "Hello "), wouldn't the output be "World!Hello "?
17:15:20 <mokus> the execution of that composed action has g before f, by definition
17:15:30 <mokus> nope
17:15:44 <centrinia> How does one define the sequence?
17:15:48 <mokus> "execution" of an IO action is ordered by definition
17:16:01 <mokus> in IO, you could just about think of >>= as a data constructor
17:16:23 <mokus> that the runtime deconstructs to "execute" the actuon
17:16:32 <Philippa> you can actually implement other monads that way, too
17:16:45 <Philippa> it's often easier than the alternative, not least to get you started
17:16:55 <mokus> when you say main = putStr "hello " >> putStr "world", the "evaluation" of it has no effects
17:17:07 <mokus> the evaluation of main is just a value of type IO ()
17:17:17 <Philippa> also, you'll be glad to know that I've actually implemented an interpreter that way too and it works fine :-)
17:17:19 <mokus> which describes the ordered execution of those steps
17:18:03 <mokus> everything beyond that is optimization
17:19:12 <mokus> which is essentially "principled cheating" anyway
17:19:15 <mokus> ;-)
17:19:30 <athos> :t sortBy
17:19:32 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
17:19:40 <centrinia> So the IO monad is similar to a list monad containing IO actions and nothing gets executed until the head is available?
17:19:47 <mokus> yep
17:20:05 <mokus> now, ghc doesn't implement it that way - but that's because it's cheating
17:20:14 <mokus> it implements it in a faster way that behaves the same
17:20:35 <dcoutts> one can implement it that way in Haskell code
17:20:43 <dcoutts> as a kind of interpreter layer
17:21:00 <dcoutts> that lets you introspect the IO actions, eg for logging or security
17:21:30 <dcoutts> data IOAction = ReadFile FilePath (String -> IOAction) | ... other primitive action
17:23:12 <dcoutts> thoughtpolice: btw, are you planning on doing several lhc releases per-day long term? I might have to re-evaluate the algorithms we use which assume the number of releases is relatively small.
17:25:01 <thoughtpolice> dcoutts: well no, the last couple of days have just been build fixes and stuff
17:26:33 <dibblego> how would one pronounce <=< ?
17:27:02 <skorpan> less than or equal to less than
17:27:23 <dibblego> @type (<=<)
17:27:24 <ikkebr> smaller or equal the smallest?
17:27:25 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
17:27:43 <dibblego> (>>=) is to bind as (<=<) is to?
17:28:27 <Philippa> "composeM"
17:28:40 <dibblego> hmm yes nice thanks
17:29:05 <JohnnyL> anyone here have a cl.exe that compiles exes?
17:29:12 <JohnnyL> or a gcc that works under cygwin?
17:29:20 <Zao> JohnnyL: link.exe does the linking step.
17:29:47 <JohnnyL> Zao: cygwin complains that my cl.exe doesn't create an exectuable so that needs replacing too.
17:30:02 <JohnnyL> takes *alot* of work to get haskell stuff to work on my system.
17:30:39 <Zao> JohnnyL: You shouldn't need to use Visual Studio at all.
17:30:51 <Zao> Ensure that your gcc is properly setup, if any.
17:31:39 <Zao> Any reason you're not just using a binary ghc dist?
17:31:46 <JohnnyL> Zao: I can't seem to find a gcc binary for cygwin
17:32:01 <JohnnyL> Zao, i am , i'm just compiling OpenGL.
17:32:19 <Zao> I got moderate success using mingw and msys.
17:32:32 <Zao> Oh right, they removed that from the base nowadays. Silly move imo.
17:32:45 <Zao> (err, extralibs)
17:33:22 <BMeph> dibblego: Most folks I know (that know it) just call it "Kleisli composition". Then they go on to mention how they always use the flipped version, (>=>).  :)
17:34:12 <mokus> BMeph: a standard flipped (.) operator would be pretty nice too ;-)
17:34:19 <athos> @src sortBy
17:34:20 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
17:34:55 <BMeph> mokus: Well, it's "standard" now... ;p
17:35:36 <JohnnyL> Zao where cna I get the gcc binary for windows (or cygwin)?
17:35:40 <JohnnyL> s/cna/can
17:42:42 <pumpkin> athos: that's not the real sortBy
17:42:46 <pumpkin> just FYI
17:47:01 <centrinia> sort cmp = elems . foldr insert empty
17:47:16 <centrinia> Uh, sort = elems . foldr insert empty; :p
17:49:09 <sjanssen> also not the real sort :)
17:49:37 <pumpkin> the mysterious missing sort!
17:49:47 <pumpkin> the famous five must tackle it
17:49:55 <pumpkin> or nancy drew or hardy boys, or something like that
17:56:57 <athos> pumpkin: what is the real sortby? :>
17:57:07 <pumpkin> not an insertion sort :P
17:57:28 <pumpkin> I'm not sure why @src claims it is
17:57:32 <pumpkin> @src insertBy
17:57:33 <lambdabot> insertBy _   x [] = [x]
17:57:33 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
17:57:33 <lambdabot>                                  GT -> y : insertBy cmp x ys'
17:57:33 <lambdabot>                                  _  -> x : ys
17:58:05 <ozy`> the real sort is a mergesort, isn't it?
17:58:24 <ozy`> (since quicksort doesn't work so well on lists...)
17:58:44 <mokus> I think that depends whether you consider the "real" one to be the one in the haskell report or the one in the ghc base package
17:59:18 <mokus> IIRC, the report calls for an insert sort but ghc uses a merge sort
17:59:37 <pumpkin> maybe
18:00:44 <necroforest> Quick Question: Can a pure functional language implement any algorithm with the same asymptotic complexity that a C implementation takes?
18:01:31 <pumpkin> I'd assume so, if you're given primitive arrays
18:01:33 <necroforest> or are there algorithms/problems that take, say, O(n) time in C and O(n log n) or O(n^2) in a pure functional implementation (i.e, Haskell)
18:02:00 <pumpkin> has anyone in here built lambdabot on 6.10?
18:02:02 <athos> ozy`: hmm.. why does quicksort fails on lists? i thought complexity theory tells us nothing about the data type the algorithm is operating on
18:02:21 <sjanssen> necroforest: there are problems that require mutable state to get certain bounds
18:02:43 <necroforest> athos, i think quicksort assumes random access in O(1) time
18:02:54 <athos> ah!
18:02:56 <necroforest> athos, Haskell lists have random access in O(n) time
18:02:57 <athos> that's the point, thanks
18:03:07 <necroforest> sjanssen, ok
18:03:33 <sjanssen> necroforest: depth-first search is a classic example
18:03:45 <pumpkin> hmm
18:03:51 <sjanssen> necroforest: of course Haskell has ways of cheating, such as ST and DiffArray
18:04:09 <pumpkin> depth-first?
18:04:19 <sjanssen> pumpkin: yes, on graphs
18:04:28 <necroforest> sjanssen, that was my next question :)
18:04:29 <pumpkin> oh I see what you mean
18:06:04 <ozy`> athos: sorry, was AFK. I see you have your answer :p
18:07:01 <sjanssen> athos: you can write a quicksort that is O(n log n) on lists, but it doesn't have the excellent constant factors that in-place array quicksort does
18:07:15 <ozy`> quicksort additionally prefers to operate on mutable data structures to keep the memory down
18:08:15 <ozy`> so it's perfect for in-place sorting a C/Java/Ruby/AndrewLloydWeberScript array
18:08:59 <necroforest> what about an LOLCODE array?
18:09:26 <ozy`> necroforest: I'll assume LOLCODE uses flat, mutable arrays like every other imperative language ever, and just say yes
18:09:44 <ozy`> (in reality... does it have any arrays at all?)
18:09:45 <Riastradh> One can write a deforested tree sort; quick sort is a specialization of deforested tree sort that requires in-place exchanges.
18:14:19 <orbitz> what is deforestation
18:14:27 <pumpkin> you cut down trees
18:14:30 <pumpkin> sorry :P
18:14:40 <orbitz> to make paper or for fun
18:14:41 <Cale> orbitz: removing intermediate datastructures
18:15:18 <Cale> orbitz: When you have some code that produces a datastructure, and some code which consumes it, you can imagine compiling them together into a program that doesn't actually allocate the memory for that intermediate thing
18:16:25 <pumpkin> has anyone had trouble with cabal-installing readline on os x?
18:17:08 <pumpkin> (apart from me)
18:17:42 <Axman6> pumpkin: i think i did. download the package, and point it to /opt/local/include/readline/
18:17:52 <Axman6> if you used macports to install it
18:18:00 <Axman6> run configure --help
18:18:16 <orbitz> Cale: does that tak ea lot of knowledge of both ends to do?
18:18:53 <Cale> orbitz: Well, generally you need access to the actual code. ;)
18:19:11 <orbitz> Cale: so no shared objects?
18:20:04 <Cale> hmm....
18:20:20 <Cale> I don't know how it would work.
18:20:32 <Cale> But I'm not sure how to rule out the possibility :)
18:20:55 <pumpkin> Axman6: looks like that did it, thanks :)
18:20:57 <orbitz> Cale: for good optimization, is haskell restricted to compiling the entire project form source, or can you get something liek java where even the executables are modular?
18:21:10 <Axman6> pumpkin: now... help me with ma hacports!
18:21:12 <Axman6> >_>
18:21:15 <pumpkin> :P
18:21:25 * pumpkin axes axman
18:21:55 * Axman6 pumpkin cannon's pumpkin 
18:22:37 <Cale> orbitz: Well, you have RULES, which let you encode optimisations in your libraries which rewrite code into something more efficient.
18:23:06 <orbitz> Cale: but does the compiler still need to see all the actual source code?
18:23:23 <Cale> It needs to see the source for the code which it is compiling...
18:23:40 <Cale> Once you've defined RULES, they apply to future modules anyway.
18:24:03 <Cale> So at that point it doesn't need to look at the module it already compiled.
18:24:14 <Cale> This is how stream fusion works.
18:24:49 <pumpkin> my lambdabot install is failing :(
18:24:56 <Cale> Operations on lists, say, are translated into fromStream . streamOperation . toStream, where streamOperation is the corresponding operation on streams
18:25:19 <Cale> and then there's a rule which eliminates adjacent  toStream . fromStream calls
18:25:41 <Cale> and then the stream operations are all things which inline and are not recursive
18:26:16 <Megzlna> can you "freeze collections" on the haskell GC?
18:26:27 <Megzlna> on GHC i mean
18:26:42 <Cale> What do you mean by that?
18:26:44 <orbitz> Cale: i don't see stream fusion on the wiki, any good documentation?
18:26:48 <Megzlna> preallocate memory
18:26:51 <Megzlna> a pool
18:27:01 <Megzlna> so that my threads dont get stopped
18:27:04 <Cale> orbitz: I'll find you a paper
18:27:15 <orbitz> Cale: preferably soething as layman as possible please
18:27:19 <Megzlna> say you were making a FPS game
18:27:23 <Cale> http://www.cse.unsw.edu.au/~dons/papers/CLS07.html
18:27:29 <Megzlna> and you did not want the FPS to dip down to 0 sometimes
18:27:36 <JuanDaugherty> or more generally, is there a "real time" haskell pkg?
18:27:40 <orbitz> Cale: thanks
18:28:20 <Philippa_> Megzlna: there isn't a 'stack' in the sense you're used to, so it'd be more complicated than that
18:28:40 <Cale> Megzlna: Well, you can't turn off GC, nor would you want to, given the way in which lots and lots of short-lived objects are generally created.
18:28:44 <Philippa_> a lot of GCed FPLs use the heap in place of the stack and allocate continuations there
18:28:58 <JuanDaugherty> A: no.
18:29:12 <Megzlna> can I "force collection" periodically?
18:29:15 <Philippa_> yes
18:29:22 <Philippa_> there's an IO operation that does that
18:29:22 <JohnnyL> do any of you know why I get: http://rafb.net/p/Ce76us63.html   ??
18:29:44 <Philippa_> you may get away with that, minor collections're fast
18:29:51 <Megzlna> I have to connect my Haskell to a dsp library which gets callbacks in the audio interrupt
18:30:02 <Megzlna> every 0.75 ms
18:30:08 <Cale> JohnnyL: Apparently your C compiler is broken?
18:30:42 <JohnnyL> Cale, i just installed cynwin gcc so I don't know.
18:30:45 <Megzlna> It's only calls to the library (which is C++)
18:30:47 <Megzlna> so I have to go
18:31:03 <Megzlna> (C++ -> C -> Lock Free Queue -> FFI -> Haskell)
18:31:14 <Cale> JohnnyL: oh, this is on windows, hmm..
18:31:54 <Megzlna> with the queue, the gc would be allowed to halt threads
18:32:10 <pumpkin> @hoogle HsModule
18:32:11 <lambdabot> Language.Haskell.Syntax data HsModule
18:32:11 <lambdabot> Language.Haskell.Syntax HsModule :: SrcLoc -> Module -> Maybe [HsExportSpec] -> [HsImportDecl] -> [HsDecl] -> HsModule
18:32:59 <Megzlna> is there no better way to get "realtime haskell" ?
18:33:08 <JohnnyL> cale yah
18:34:19 <Megzlna> I could force collection on a modulo of the callback
18:34:26 <Megzlna> But that isn't smooth
18:34:32 <Megzlna> It need "partial collect"
18:34:51 <JuanDaugherty> Megzlna, it's a misconception, so the solution is instantaneous.
18:34:52 <Megzlna> incremental collection
18:35:00 <Philippa_> depending on your structures, a major GC may not be that bad
18:35:14 <pumpkin> hmm, unknown symbol `_haskellzmsrczm1zi0zi1zi3_LanguageziHaskellziSyntax_lvl39_closure'
18:35:29 <Megzlna> JuanDaugherty: Come again?
18:36:21 <Cale> pumpkin: compiling with --make ?
18:36:28 <JuanDaugherty> ♪ revechy du printemp ♪
18:36:30 <pumpkin> cabal install :)
18:36:33 <Cale> pumpkin: (you should be, if you're not using Cabal)
18:36:33 <Cale> ah
18:36:40 <Cale> hmm
18:36:44 <pumpkin> ah, different error this time
18:36:57 <pumpkin> HsModule and stuff again, but I installed haskell-src :/
18:37:11 <Axman6> doublec: http://articles.bluishcoder.co.nz/Haskell/NotAHAppSTutorial is yours isn't it?
18:37:44 <Cale> Megzlna: Of course, if you never have too much garbage it's not so much of a problem.
18:38:02 <JohnnyL> cale the config.log reads (after runghc Setup.hs configure: http://rafb.net/p/inj9NT71.html
18:38:20 <Megzlna> Cale: That's the neatest part of C++
18:38:39 <Megzlna> no garbage ever
18:38:48 <Cale> Like, in an FPS game for instance, there's a lot less stuff to GC on each collection than you might think, so long as the program is designed sanely, and you can usually get smooth framerates.
18:38:51 <doublec> Axman6, yes. that's mine
18:38:59 <pumpkin> Axman6: I guess you had the same HsModule issue I had
18:39:04 <Cale> There's plenty of garbage in C++, it's just not collected for you.
18:39:08 * Megzlna retreats re: memory leaks
18:39:17 <Axman6> doublec: it's very nice, well done :) just one tiny suggestion, could you add what the files should be called in the code examples?
18:39:24 <Axman6> pumpkin: i can't remember :\
18:39:35 <pumpkin> Axman6: did you succeed in installing lambdabot though?
18:39:40 <Philippa_> Cale: the game sim's often got a lot of stuff that's a bitch to GC unless you hide the indirections from the collector, though
18:39:47 <Axman6> Megzlna: languages without garbage collection mean you have to be the garbage man
18:39:49 <pumpkin> the only reference I found to my error was you asking about the same error in the irc logs (on google)
18:39:50 <doublec> Axman6, sure, I'll do that
18:39:55 <Axman6> pumpkin: not that i recall :\
18:40:02 <Axman6> doublec: cheers :)
18:40:07 <doublec> np :)
18:40:10 <Megzlna> Axman6: I don't have that problem in C++, honestly.
18:40:23 <Philippa_> Axman6: in this particular case, he's more than happy to
18:40:31 <Axman6> so you don't deallocate objects and such then?
18:40:36 <Philippa_> Megzlna: it's one of those things where some tasks're easier than others
18:40:48 <Philippa_> a lot of the code I write, you pretty much have to GC one way or another
18:40:48 <pumpkin> doublec: one question I had about that: "Notice the weird HTML formatting. This is to ensure that there is no additional whitespace in the HTML elements for formatting."
18:40:48 <Megzlna> There's two ways that deallocating objects isnt a big deal
18:41:16 <Megzlna> You always code in a manner where construction acquires resources and destruction of the object releases them -- RAII
18:41:23 <Megzlna> your delete and new will be near to eachother
18:41:55 <doublec> pumpkin, basically it's to avoid newlines in the contents of the elements.
18:41:59 <Axman6> i don't like having to worry about memory tbh, i want it handled for me, so i can get on with writing code
18:42:05 <Megzlna> Then the stack kills off the object and its dtor is called -- or the container its in destructs, which in turn destructs the object
18:42:08 <pumpkin> doublec: ah
18:42:10 <doublec> so if you were to parse the html with an htlm parser, you'd get text nodes that contain the newlines
18:42:15 <doublec> s/htlm/html
18:42:17 <Megzlna> Its always balanced
18:42:24 <pumpkin> doublec: I see
18:42:32 <Megzlna> However, sometimes you "freely flow" objects through your codebase
18:42:43 <Philippa_> and the other's to build your own half-arsed GC system
18:42:55 <Megzlna> passing around a pointer to 10 subsystems or whatever
18:43:06 <Megzlna> And You're not sure how long it needs to live for.
18:43:20 <Megzlna> Well, then a reference counted pointer comes in handy. It just wraps RAII
18:43:22 <Axman6> Megzlna: how well does all this work on highly concurrent and/or parallel programs?
18:43:40 <Philippa_> reference counting = half-arsed GC. I'm sure you know the problem with cycles, too
18:43:44 <Megzlna> of course, reference counted pointers can have a cyclic reference, but you can easily design your program to make that impossible
18:43:55 <Philippa_> not always, you can't
18:44:15 <Philippa_> sometimes, that cycle's part of the underlying data
18:45:09 <Megzlna> If you have a graph, you can allocate into a pool
18:45:23 <Megzlna> when you need, pull the lever on the pool and the objects go into the rancor pit
18:45:49 <JohnnyL> cale are you here?
18:45:55 <Megzlna> the deallocation is instantaneous
18:46:04 <Philippa_> *nod* - another example of half-arsed GC, of course. This time, a copying collector
18:46:14 <Cale> JohnnyL: yes, but I really don't know anything about getting stuff to work on Windows.
18:46:18 <pumpkin> lol, rancor pit
18:46:27 <JohnnyL> argh
18:46:27 <Megzlna> but, Philippa, the GC still has to stop threads.
18:46:28 <Megzlna> all of em'
18:46:36 <JohnnyL> i guess I'll stick to c++ then.
18:46:40 <Megzlna> its only "half arsed" insofar as you dont need realtime
18:46:41 <athos> gn9
18:46:42 <athos> gn8
18:46:46 <JohnnyL> i was going to attempt to write a game in haskell.
18:46:49 <pumpkin> I never did get the gn8 thing
18:46:59 <Cale> JohnnyL: I'm sure someone else here uses windows and can help :)
18:47:11 <Philippa_> Megzlna: nah, it also leaves you with a larger heap footprint than full GC provides
18:47:12 <JohnnyL> but man is it hard to get stuff configured with haskell. like most scripting languages.
18:47:18 <JohnnyL> cale , that'd be nice.
18:47:37 <pumpkin> gwern: you around?
18:47:45 <Philippa_> Megzlna: that's not to say that there aren't tradeoffs
18:47:53 <Megzlna> Philippa_: Not when you code on the stack, and the heap is your last resort (how i code)
18:48:09 <Megzlna> in C++, the heap is a paranoia
18:48:14 <Philippa_> Megzlna: that doesn't work in all problem domains
18:48:17 <gwern> pumpkin: a little
18:48:28 <Megzlna> OH NO THE HEAP. How can I solve this on the stack? descend a poiner all the way down through the arguments?
18:48:29 <Megzlna> etc
18:48:56 <Megzlna> Philippa_:  It works on a surprisingly lot of them that coders use the heap erroneously for ;)
18:49:04 <Megzlna> but in Haskell, I forget all that.
18:49:15 <Megzlna> since you need a Thunk in your trunk
18:49:36 <Philippa_> yeah. If you start writing large chunks of compiler code you'll realise why nobody in their right mind wants to /have/ to code like that though
18:49:45 <gwern> pumpkin: what's up?
18:50:08 <Megzlna> Philippa_: not that hard. On #C++ efnet if newbies post Pastebins, the ops will go
18:50:11 <Philippa_> the design's seriously affected by data lifetime, which makes your code a tad volatile
18:50:13 <pumpkin> gwern: in this irc log ( http://tuukka.iki.fi/tmp/haskell-2008-11-28.html ) , you mentioned that haskell-src-exts broke the API with justification, citing an announcement on cafe, but I can't find the announcement, and am trying to work out what version that happened at
18:50:15 <Megzlna> "you have an error on line 42. use of the heap"
18:50:37 <gwern> pumpkin: well, maybe it wasn't cafe but haskell proper?
18:50:43 <pumpkin> oh hmm
18:50:46 <Philippa_> yeah yeah. I learned my C++ coding around the smarter gamedev folks at the time
18:50:57 <Cale> JohnnyL: Scripting languages?
18:51:01 <JuanDaugherty> a thunk in your trunk, that's the ticket. Really.
18:51:12 <Philippa_> again, you don't want to have to do it in compiler development
18:51:19 <Philippa_> it's not that it can't be made to work
18:51:34 <Philippa_> it just massively screws up your development process unless you're willing to put up with a crap heap footprint
18:51:40 <pumpkin> 0.4.1 I think
18:51:42 <Philippa_> (the pool approach)
18:52:07 <Pseudonym> Sometimes, the pool approach really does work.
18:52:07 <gwern> pumpkin: http://www.haskell.org//pipermail/haskell-cafe/2008-November/050634.html
18:52:10 <gwern> i Think
18:52:16 <pumpkin> yeah :)
18:52:17 <Pseudonym> If you know you're not going to delete memory in pieces, but just in one go.
18:52:18 <pumpkin> thanks
18:52:18 <gwern> 'This is a new "major" release, the first of the 0.4 branch, and as
18:52:20 <gwern> such it is not backwards compatible with the releases in the 0.3
18:52:20 <gwern> branch. This is due to two major changes to the design of the library:
18:52:24 <JohnnyL> cale, or rather 'managed code' makers.
18:52:25 <Pseudonym> You can dispose of the pool as a whole.
18:52:25 <JohnnyL> lol
18:52:27 <JuanDaugherty> your design perspective must be on the C side of the FFI as there is no real time haskell.
18:52:32 <Cale> JohnnyL: huh?
18:52:40 <Philippa_> Pseudonym: yeah, I'm aware. Mind you, having the option to run GC within a pool (as a GCed region, if you like) can be good too
18:52:47 <JohnnyL> cale, thats what I said when I see an error.
18:52:55 <JuanDaugherty> (as far as the real-time aspect/concern is concerned)
18:53:10 <Cale> JohnnyL: Haskell is a static language and GHC compiles it to machine code ;)
18:53:16 <Philippa_> all I'm arguing is that there're situations where you really don't want the typical C++ approaches
18:53:18 <Megzlna> Once, I was really embarrassed about using the heap
18:53:26 <Pseudonym> Definitely.
18:53:33 <Cale> JohnnyL: http://netsuperbrain.com/blog/posts/freeglut-windows-hopengl-hglut/
18:53:38 <Pseudonym> I hate writing compilers in C++.
18:53:40 <Philippa_> GHC'd be an awful lot suckier if it were written in C++
18:53:44 <Cale> JohnnyL: That seems to describe how to get things working.
18:53:49 <Pseudonym> The memory management is just a really poor fit.
18:53:58 <Cale> JohnnyL: with MinGW and msys rather than cygwin though
18:55:11 <Philippa_> Megzlna: dunno if you ever read flipCode back when it was running?
18:55:24 <JohnnyL> cale, oh ok
18:55:34 <Megzlna> A long time ago, I went through every flipcode article and copied the good bits
18:55:42 <Megzlna> I remember one thing:
18:56:17 <Megzlna> Foo::Foo() { memset(this, 0, sizeof(*this)); }
18:56:19 <JohnnyL> cale, just as long as it works.
18:56:20 <JohnnyL> :)
18:56:34 <Pseudonym> Yow.
18:56:39 <Pseudonym> Let's hope there's no vtables there.
18:56:47 <Megzlna> Pseudonym: That's what the article said.
18:56:48 <Cale> JohnnyL: Well, I can't speak from personal experience, but if that guy bothered to write all that up, I should hope it works :)
18:57:09 <Philippa_> heh. Yeah, well... compare&contrast with some of the other 'all-areas' sites at the time?
18:57:25 <Philippa_> ...then again, I remember the minor shitstorm when someone did exactly that on the IRC chan
18:57:43 <Philippa_> Per and Kurt's nicks were a little confusable
18:58:28 <Megzlna> heh, I've been through a bunch of channels, and by far the worst I've ever seen was #asm efnet
18:58:47 <pumpkin> hmm, I'm trying to foce this cabal build to use base-3.0.3.0 but I get the impression it isn't
18:58:51 <pumpkin> *force
18:58:51 <Philippa_> hah, that figures
18:59:12 <Philippa_> #flipcode was... well, not the fluffiest gamedev chan, but good fun if you got the local mindset
18:59:24 <Cale> pumpkin: Look in the .cabal file
18:59:34 <pumpkin> yeah, that's what I'm doing
18:59:36 <Philippa_> admittedly I never spent much time on effingnet
18:59:40 <pumpkin> I added a base < 4.0.0.0 to it
18:59:44 <Cale> okay
18:59:44 <Megzlna> guy on #asm efnet: http://redwing.hutman.net/~mreed/warriorshtm/propellerhead.htm
19:00:01 <Megzlna> highly: a little mystified that you don't :)
19:00:01 <Cale> pumpkin: Does it do any dependency chasing?
19:00:08 <Megzlna> *highlight
19:00:09 <pumpkin> chasing?
19:00:32 <Cale> pumpkin: Like, is it compiling just the package you're telling it to, or is it downloading another one and building that first?
19:00:40 <pumpkin> it's compiling the one I'm telling it to
19:00:43 <Cale> okay
19:00:44 <Cale> hmm
19:00:47 <pumpkin> I already have all the dependencies
19:00:51 <Megzlna> which flame warrior is Cale?
19:00:52 <Cale> What error are you getting?
19:01:27 <Megzlna> http://redwing.hutman.net/~mreed/warriorshtm/ent.htm
19:01:28 <Philippa_> I don't see Cale flame much
19:01:43 <pumpkin> looks like it's telling it to use base-3.0.3.0, which should be fine
19:01:43 <pumpkin> but it's still giving the same error
19:01:43 <pumpkin> hrmmm
19:02:13 <Philippa_> eh, Cale's not /that/ much old-guard
19:02:40 <Philippa_> at least... well, to be fair I've been here something like half the chan's life now: my perspective may be warped by this :-)
19:03:13 <Cale> I wonder when I first joined this channel...
19:03:18 <pumpkin> Cale:     Module `GHC.IOBase' does not export `Exception(NoMethodError)'
19:03:29 <Cale> Probably sometime in 2001 or 2002.
19:03:37 <pumpkin> it looks like that isn't in base-4, but it's in 3
19:03:41 <pumpkin> which is why I wanted to force it to use 3
19:05:39 <Cale> pumpkin: hmm...
19:05:59 <stoneToad> is it normal that my HGL using program freezes part way through drawing a list of 1521 items?
19:06:22 <stoneToad> it's kinda weird cause if I wave my mouse over the window it generally restarts
19:07:11 <pumpkin> Cale: I tried pulling out the plugin that used that, but got Plugin.Base trying to use that too (this is for lambdabot)
19:07:53 <Philippa_> Cale: I remember a time when I was explaining monads more than you were :-)
19:08:09 <pumpkin> back in my day, I was young
19:08:18 <pumpkin> :)
19:09:28 <pumpkin> I'm so near the end of this lambdabot install
19:09:30 <gwern> man. it must've been painful to be a haskeller back in 2001
19:09:43 <lament> you mean more painful than now?
19:09:58 <Philippa_> lament: much. Especially if you're a windows user
19:10:03 <gwern> far moe painful
19:10:05 <pumpkin> I enjoy the pain
19:10:09 <lament> does SPJ use windows?
19:11:11 <orbitz> he wrote windows
19:11:23 <gwern> gates wrote windows
19:11:25 <gwern> hence the name
19:11:32 <Philippa_> nah, that was Oleg. He wrote it in the type system, duh
19:13:23 <pumpkin> woohoo, I haz lambdabot compiled on 6.10... now I need to figure out how to use it
19:14:00 <Megzlna> can every single haskell mechanism for binding a value with a name be used for pattern matching?
19:14:50 <Philippa_> think so. case, where, let, do, list comprehensions, top-level bindings...
19:15:10 <Megzlna> top level bindings?
19:15:40 <Philippa_> the ones you put in a module
19:15:51 <Philippa_> "top level" as in "outermost scope"
19:18:02 <pumpkin> how do I ask lambdabot to join an irc server and channel?
19:18:12 <Philippa_> @join
19:18:12 <lambdabot> Not enough privileges
19:18:59 <pumpkin> hmm, my lambdabot is broked!
19:19:11 <pumpkin> ah well, I'll be satisfied that it compiled
19:19:15 <Megzlna> is 'let' some sugar around monads?
19:19:22 <pumpkin> nope
19:19:27 <Megzlna> or a monadic idea
19:19:30 <Megzlna> not literal monads
19:19:40 <araujo> hello
19:19:53 <dibblego> Megant, no, nothing to do with monads
19:20:10 <Philippa_> if you had a proper identity monad with mfix, mdo'd be equivalent to let
19:20:28 <dibblego> sorry, Megzlna^
19:20:38 <Philippa_> (Haskell's let is equivalent to ML's letrec, if you're thinking of my statement earlier about MLish let)
19:25:11 <Megzlna> why is this invalid?
19:25:24 <Megzlna> > :t let { x = 1 }
19:25:25 <lambdabot>   <no location info>: parse error on input `:'
19:25:26 <Megzlna> oops
19:25:28 <Megzlna> :t let { x = 1 }
19:25:30 <lambdabot> <no location info>: not an expression: `let { x = 1 }'
19:25:42 <Megzlna> But, a let is supposed to be an expression.
19:25:51 <Cale> because let { x = 1 } is an incomplete expression
19:25:58 <Cale> :t let { x = 1 } in x
19:25:59 <lambdabot> forall t. (Num t) => t
19:26:04 <Philippa_> only when it's complete with the in part
19:26:05 <Cale> :t let { x = 1 } in "hello"
19:26:07 <lambdabot> [Char]
19:26:11 <Megzlna> k
19:27:27 <Philippa_> there are let statements in do blocks as well, was that what confused you?
19:27:45 <Megzlna> so lack of 'in' on GHCI is just a hack
19:27:59 <Philippa_> no
19:28:06 <Philippa_> well, it's not the hack you think it is
19:28:16 <Philippa_> you can feed GHCi statements as if you were in the middle of a do block
19:28:17 <Megzlna> Philippa: I was confused because of GHCI and because of do
19:28:47 <Megzlna> okay
19:30:27 <ozy`> Megzlna: do-notation is kind of a hack as it stands... the "in" is added in the desugaring process, so it's still implicitly there
19:32:11 <JohnnyL> Cale, I got all the the way up until the teapots.hs and I get:http://rafb.net/p/WrotFD65.html after I type ghc teapots.hs
19:32:53 <Megzlna> Will the actions in a do block have any locality in memory so that EIP/RIP isn't going utterly mad?
19:33:33 <Megzlna> for the L1's sake
19:34:43 <sjanssen> Megzlna: there are way too many variables in your question to give a reasonable answer
19:34:43 <Cale> JohnnyL: add --make
19:34:47 <Megzlna> With C, you have a sequential set of instructions, but I'm wondering how the actions, being heap allocated, can be at all local
19:35:01 <Cale> JohnnyL: that is,  ghc --make teapots.hs
19:35:17 <sjanssen> Megzlna: GHC is an optimizing compiler, most of your code won't actually be heap allocated
19:35:37 <Megzlna> so all the actions get inlined?
19:35:44 <sjanssen> maybe, maybe not
19:35:57 <sjanssen> again, too many variables to answer your question
19:36:00 <Philippa_> bind and the 'atomic' ones do, yeah
19:37:03 <Megzlna> the atomic ones?
19:37:29 <JohnnyL> Cale, wow, it actually works. Can I put an installer/configurer over all those steps?
19:38:37 <Philippa_> Megzlna: the primitive operations
19:38:44 <Cale> JohnnyL: Well, hopefully your compiled program should be okay to move around...
19:38:57 <Cale> JohnnyL: But I'm not certain about that.
19:39:01 <Megzlna> I suppose that includes everything in Prelude with a ...
19:39:20 <Philippa_> more generally, GHC picks up where functions are "fully applied"
19:39:39 <Philippa_> (this is one of those moments where thinking through the currying isomorphism is important)
19:39:55 <pumpkin> anyone have any new haskell proposals? :D
19:40:05 <Philippa_> those get compiled to the equivalent of an ordinary C function call
19:40:09 <sjanssen> pumpkin: I do!  Write code!
19:40:23 <pumpkin> sjanssen: lol, I'm trying to get more people to contribute to the new reddit :P
19:40:24 <Megzlna> pumpkin: I propose that modules shall henceforth allow nested modules.
19:40:26 <Philippa_> pumpkin: nah, though I guess my girlfriend is learning the language...
19:40:44 <pumpkin> lol :)
19:40:47 <sjanssen> pumpkin: personally, I don't find much use in that sort of thing
19:41:00 <Cale> JohnnyL: I think it statically links freeglut and such though.
19:41:00 <pumpkin> sjanssen: that's because you aren't looking for stuff to work on :D
19:41:02 <sjanssen> is someone really going to go down the list and just write one of the things?
19:41:02 <JohnnyL> Cale, ah ok, sweet.
19:41:08 <Axman6> doublec: still around?
19:41:19 <doublec> Axman6, yep
19:41:22 <pumpkin> sjanssen: it allows people to get an idea of what the community is looking for and thinks is needed, at least
19:41:32 <Megzlna> currying isomorphism?
19:41:33 <pumpkin> the community that participates at least *nudge nudge*
19:41:42 <Philippa_> Megzlna: you know what currying is?
19:41:45 <Megzlna> Yep
19:41:54 <pumpkin> it involves coriander, turmeric
19:41:55 <Megzlna> f x y = x + y ;)
19:41:56 <Axman6> doublec: seems the 'instance ToMessage Html where' stuff isn't necessary anymore. ghc whinges about duplicate instances
19:41:59 <Philippa_> okay. That relationship between tuples and functions is an isomorphism
19:42:15 <JohnnyL> :t IO
19:42:16 <lambdabot> Not in scope: data constructor `IO'
19:42:21 <doublec> Axman6, yes I mention that in the tutorial
19:42:24 <Philippa_> a two-way mapping such that going there-and-back-again doesn't change anything in either direction
19:42:30 <JohnnyL> what is the difference between 'type' and 'data'?
19:42:34 <Philippa_> or to put it another way, "the same thing"
19:42:38 * Axman6 rereads
19:42:51 <Megzlna> Philippa: Isn't that the same for   :: a -> [a]
19:42:54 <Megzlna> and [a] -> a
19:42:54 <doublec> "Actually I lied. You get a compile error with this code about a duplicate instance of ToMessage Html. "
19:43:05 <doublec> I wrote the code like that originally and it worked
19:43:06 <Megzlna> or (a,a) -> a
19:43:12 <doublec> And later, after an update, I got the duplicate error
19:43:19 <Philippa_> no. You can't go from bigger to smaller and back there
19:43:24 <doublec> but it was a useful exercise learning about it so I kept it in
19:43:43 <Philippa_> 1 -> [1] -> 1 works, but [1,2] -> WTF?
19:43:45 <dibblego> Megant, forall a. [a] -> a is not even true let alone isomorphic
19:43:48 <Megzlna> how can you go from bigger to smaller and back with a tuple and a function
19:44:12 <Philippa_> @src curry
19:44:13 <lambdabot> curry f x y = f (x, y)
19:44:15 <Philippa_> @src uncurry
19:44:15 <lambdabot> uncurry f p = f (fst p) (snd p)
19:44:22 <Axman6> doublec: heh, so you do, my bad
19:44:25 <Philippa_> they're not "bigger" or "smaller" in that context
19:44:29 <Philippa_> they're "the same"
19:44:42 <Megzlna> an isomorphism
19:44:48 <Megzlna> alright
19:44:55 <dibblego> forall a b c. ((a, b) -> c) <-> (a -> b -> c)
19:45:26 <Philippa_> right. So sometimes it makes sense to talk about "2 parameter functions" in haskell
19:45:36 <Philippa_> despite the fact that at the most literal level it only has single-parm ones
19:46:00 <Megzlna> > (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
19:46:00 <Philippa_> foo (1,2,3) only passes one parm too, of course :-)
19:46:01 <lambdabot>   (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
19:46:03 <Megzlna> > (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
19:46:04 <lambdabot>       No instance for (Show
19:46:04 <lambdabot>                         (t,
19:46:04 <lambdabot>                      ...
19:46:37 <sjanssen> tuples suck :(
19:46:44 <Megzlna> why?
19:46:56 <Axman6> doublec: is 'method GET $ ok $ toResponse $ page' supposed to render the page in the browser? (where page :: Html) it still shows the source for me
19:47:08 <Philippa_> if you have a 16-parm tuple, you probably missed some :-)
19:47:09 <Megzlna> they are constant offsets
19:47:25 <sjanssen> Megzlna: GHC has to manually define the Show instances for each tuple size
19:47:28 <Axman6> they're also very anoying when you have more than three things in them
19:47:32 <sjanssen> and they're only defined up to a certain size
19:47:38 <Megzlna> sjanssen: desn't GHC make use of its own extensions? :)
19:47:58 <Megzlna> TH
19:48:07 <sjanssen> Megzlna: I'm not aware of any extensions that allow you to write inductive instances on tuples
19:48:08 <Philippa_> you still have to call the splices
19:48:30 <sjanssen> Megzlna: oh, even with TH you have to choose how many instances to generate
19:48:32 <Philippa_> though HList does much the same thing via another isomorphism
19:48:41 <Philippa_> one between nested 2-tuples and n-tuples
19:49:37 <Axman6> doublec: huh, never mind. i did reload the source in ghci and start it again, but needed to do it twice for some reason
19:49:40 <Cale> It's very rare to have 16 differently-typed pieces of data and not have good names for them.
19:49:59 <Cale> (you should probably be defining your own record type if you're using tuples that large)
19:50:04 <Philippa_> and even rarer to be in that position and still be able to think effectively about the code
19:50:06 <Megzlna> but, we could have a Tuple typeclass
19:50:13 <Philippa_> no, we couldn't
19:50:26 <Philippa_> the closest you can get is something like HLit
19:50:27 <Axman6> Megzlna: just accept, large tuples are not nice
19:50:28 <Philippa_> *HList
19:50:32 <Megzlna> tupleGet (Const 3) (1,2,3)
19:50:34 <Philippa_> a complete redesigning of tuples
19:50:47 <Philippa_> that isn't typeable
19:51:05 <Philippa_> rather, tupleGet isn't
19:51:11 <Philippa_> that'd require dependent types
19:51:26 <dolio> You could make some template haskell to do it. But it will be ugly.
19:52:04 <Megzlna> it's not typeable, because I can only find out that it's a Tuple typeclass
19:52:06 <ddarius> It won't be pretty, but I wouldn't say it would be ugly.
19:52:07 <Megzlna> but not the arity?
19:52:24 <Philippa_> you can't feed the 3 into the type system
19:52:32 <Megzlna> Well, you could:
19:52:57 <Megzlna> http://hackage.haskell.org/packages/archive/type-level/0.2.2/doc/html/Data-TypeLevel-Num-Ops.html
19:53:27 <sjanssen> Megzlna: even if we could write tupleGet, you still can't define it for all tuple types
19:53:39 <Philippa_> Megzlna: you can't feed /that/ 3 in
19:53:58 <dolio> sjanssen: You could define it for every tuple type that GHC doesn't crash on. :)
19:54:06 <sjanssen> dolio: true
19:54:11 <Megzlna> ...
19:54:12 <Philippa_> sjanssen: right. The thing I've said a few times about n-tuples vs nested 2-tuples (which you can define it on)
19:54:13 <sjanssen> what is that right now?  256?
19:54:32 <dolio> Well below that, last I checked. Unless they improved it recently.
19:54:40 <Philippa_> Megzlna: there's no structure to the tuple type constructors at the moment
19:54:47 <dolio> I thought it was 60-some.
19:54:51 <Megzlna> Philippa_: But do you want (1,1,1,1) to be sugar for (1,(1,(1,(1,)))) ?
19:55:19 <sjanssen> Megzlna: there is some controvery about that
19:55:45 <sjanssen> I'd be happy if Haskell had a type function to convert between normal tuples and nested 2-tuples
19:55:54 <Philippa_> urgh, yeah, they're not... well, strictly isomorphic in a lazy language
19:56:02 <Philippa_> yeah, likewise
19:56:10 <Philippa_> isomorphism rather than equality
19:56:11 <Megzlna> why can't that be written?
19:56:13 <Megzlna> for N at least
19:56:22 <Philippa_> for a given N, it can
19:56:36 <Philippa_> for any N, it can't because there's no common structure to the tuple type constructors
19:56:37 <sjanssen> Megzlna: it can be written for N tuples, but then we're back at the initial problem with tuples :)
19:57:12 <Megzlna> but, Tuples are fast, with static offsets, their offset can be encoded right into the LEA/MOV
19:57:14 <Philippa_> you can view this as a weakness in the language
19:57:25 <Megzlna> so 1000 of them is kind of, well, prickly
19:57:36 <Philippa_> that's a matter for an optimiser
19:57:50 <Philippa_> you're assuming that the type implies a representation
19:57:55 <Philippa_> it doesn't in Haskell
19:58:06 <pumpkin> if one does use nested pairs instead of n-tuples, is the convention to do the nesting in the fst, or snd?
19:58:11 <pumpkin> or isn't there one?
19:58:13 <sjanssen> pumpkin: snd
19:58:19 <Philippa_> for example, pairs often end up passed in registers on platforms with a decent number available
19:58:30 <Megzlna> but, tuple does have some practical implementation connection -- otherwise, why not have ONLY arrays?
19:58:32 <sjanssen> (1, ('a', ())) -- is the convention
19:58:43 <pumpkin> cool
19:58:45 <Megzlna> just drop the tuple altogether
19:58:49 <Philippa_> Megzlna: because arrays don't have the type structure
19:58:58 <pumpkin> sjanssen: so "()-terminated"?
19:58:59 <Philippa_> arrays are homogenous collections
19:59:11 <Philippa_> tuples are heterogenous
19:59:11 <sjanssen> Megzlna: you probably mean lists rather than arrays
19:59:26 <sjanssen> but yes, ('a', 1) -- can't write this with lists!
19:59:26 <Philippa_> sjanssen: he doesn't. Low-level thinking there
19:59:55 <Philippa_> low-level in the hardware sense rather than the mathematical one
20:00:06 <Philippa_> in the mathematical sense, Haskell is pretty low-level :-)
20:00:09 <sjanssen> Philippa_: yes, working on re-education :)
20:00:35 <Megzlna> welcome to he functional re-education camp
20:00:38 <dolio> I'm kind of conflicted. Are large tuples used enough that the performance difference between inductive and primitive tuples would matter?
20:01:04 <sjanssen> dolio: I'm more concerned about the semantic difference
20:01:05 <dolio> Or do you think it'd matter even with small tuples?
20:01:08 <Philippa_> Megzlna: don't worry, you'll be released into the real world again when you're ready :-)
20:01:27 <Philippa_> dolio: yes. As Megzlna's questions show, some people care
20:01:45 <Philippa_> in fact, GHC goes rather further - it does strictness analysis and unboxes an awful lot of tuples
20:01:46 <dolio> It's not difficult to make them semantically the same, I think, given the right machinery.
20:01:50 <dons> ?users
20:01:50 <lambdabot> Maximum users seen in #haskell: 578, currently: 501 (86.7%), active: 15 (3.0%)
20:02:08 <sjanssen> dolio: I think strictness in the second component is enough
20:02:45 <dolio> That, and if you make tuples a GADT, you prevent them from being used in odd ways (like a * non-tuple).
20:02:56 <dolio> If that matters.
20:02:58 <sjanssen> and if GHC supported unpacking polymorphic components, we could even regain the performance of non-nested tuples in some cases
20:03:40 <dolio> Yeah, I suppose that's the rub. You'd lose a lot of tuple unboxing as it currently stands.
20:05:01 <Philippa_> Megzlna: is all this making some sense as far as "not what you thought" goes?
20:05:33 <Philippa_> I'm guessing the bit about tuples sometimes just ending up in multiple registers was a pleasant surprise :-)
20:05:42 <dons> strict tuples will unbox. but not "all the way" (i.e. on returns)
20:05:47 <dons> and you won't avoid a heap check.
20:05:51 <dons> so its not all bad, but not perfect.
20:06:01 <Megzlna> everything in Haskell makes sense but sometimes in a half-sense state and dependent on further knowledge which is dependent also on the previous half-sense
20:06:12 <dolio> Of course, maybe tuples could be special cased in the optimizer. They'd already need to be special cased syntax wise.
20:06:12 <dons> data T = T !Double !Int -- much better. into registers we go. no heap checks
20:06:22 <sjanssen> dons: you also pay for more memory when storing the data
20:06:37 <dons> sjanssen: well, depends on how they're used.
20:06:55 <Megzlna> lots of dependencies so I just go forward
20:06:56 <dons> but custom types are a sensible approach to *very* performance sensitive code
20:06:58 <Philippa_> dons: thanks for the info
20:07:02 <Philippa_> *nod*
20:07:02 <sjanssen> (1, ('a', ()) -- will always take more memory than (1, 'a') in GHC
20:07:03 <dons> where the 3 heap check instructions matter
20:07:15 <dons> sjanssen: oh yes. definitely not flattening
20:07:16 <dolio> dons: That gets unpacked all the way. But 'data T a b = T !a !b' doesn't.
20:07:18 <sjanssen> (when stored in some polymorphic container)
20:07:27 <dons> dolio: right. you won't get the return unpacked
20:07:30 <Megzlna> the bigger problem is not being able to work do:
20:08:03 <Megzlna> template <int N> struct MakeT { typedef char[N] type; };
20:08:20 <Megzlna> MakeT<100>::type x;
20:08:27 <dons> size of array fixed at compile time?
20:08:37 <sjanssen> Megzlna: tricky, but possible in Haskell
20:08:44 <dons> certainly possible.
20:08:46 <Megzlna> How?
20:08:52 <dons> type level decimals
20:09:01 <dons> there's examples on the wiki
20:09:09 <sjanssen> Megzlna: the biggest hurdle is that Haskell doesn't have "int" types built in, you have to write them yourself
20:09:09 <Megzlna> lol you cant write 100
20:09:11 <Megzlna> what do you write
20:09:14 <dons> advanced though. but then again, so is MakeT<100>
20:09:15 <Megzlna> Foo One Zero Zero
20:09:20 <dons> yeah
20:09:29 <Megzlna> MakeT<100> isnt advanced
20:09:35 <Philippa_> MakeT<100> is pretty simple if you don't consider templates voodoo shit outright
20:09:48 <dons> well, its voodoo shit type system-wise
20:09:57 <Megzlna> for C++ its in newb books
20:10:05 <pumpkin> my main gripe about c++ is non-const byref function arguents changing their callers' local variables
20:10:06 <Megzlna> Haskell just lacks here
20:10:16 <sjanssen> Megzlna: yes, towards the back of the book :)
20:10:17 <Philippa_> and even back in 2000 I didn't need a year's experience to be happy writing that level of template
20:10:21 <Megzlna> You can also pattern match on the type system
20:10:33 <Philippa_> sjanssen: nevertheless...
20:10:43 <dons> explaining how it type checks is interesting.
20:10:49 <dons> that's something you won't see.
20:10:50 <sjanssen> Megzlna: and there are little weird things about C++'s int types -- can I write MakeT<10*10>?
20:10:56 <Axman6> doublec: just finished going through your tutorial, it's really good. just wish it went on to show you how to say write a blog or something (or just demonstrate how/if you can use external dynamic pages)
20:11:11 <ddarius> Megzlna: There are serious issues with C++'s template system which is why they're planning on stealing ideas from Haskell for C++ in the next standard.
20:11:16 <dons> MakeT<read "100">
20:11:16 <Megzlna> template <class _, class N> struct Foo<_[N]> { static const int value = N; }
20:11:27 <Megzlna> Foo<int[100]>::value == 100
20:11:27 <pumpkin> dons: it would be nice to take one of those type-level integer schemes and add syntactic sugar to haskell to make it easier to use, to simulate dependent types
20:11:36 <Megzlna> and 100 is a constexpr
20:11:42 <Megzlna> usable for other compiletime things
20:11:55 <dons> Megzlna: recall that the haskell type system ghc implements is turing complete
20:12:22 <Axman6> dons: what's that mean exactly?
20:12:27 <dons> e.g. type level quicksort, http://haskell.org/haskellwiki/Type_arithmetic#An_Advanced_Example_:_Type-Level_Quicksort
20:12:27 <sjanssen> it would be nice to have an "Int" kind
20:12:32 <Cale> Megzlna: That would be one thing that dependent typing would overcome relative to the situation with templates -- arbitrary code would be allowed in value parameters to type constructors.
20:12:36 <dons> Axman6: things that are computable can be encoded in the type checker
20:12:50 <Philippa_> rather, /all/ things that are computable...
20:12:52 <Axman6> ah
20:12:52 <Megzlna> How do I do pattern matching in the type system?
20:12:56 <Megzlna> like C++ example
20:12:59 <dons> i mean, encoding lambda calc in haskell is a beginner example.
20:13:04 <dons> in the  type system :)
20:13:06 <sjanssen> Megzlna: the C++ example is not doing full pattern matching
20:13:06 <pumpkin> c++'s type system is turing equivalent too isn't it?
20:13:10 <dolio> Cale: Although, people don't always use dependent typing to mean that. :)
20:13:20 <Philippa_> dons: different value of 'beginner example'
20:13:22 <ddarius> pumpkin: Yes.
20:13:23 <dons> :)0
20:13:30 <dons> ok. 10 lines of code.
20:13:39 <dons> http://haskell.org/haskellwiki/Type_arithmetic#A_Really_Advanced_Example_:_Type-Level_Lambda_Calculus
20:13:39 <sjanssen> Megzlna: type system programming in Haskell is done via type classes and fundeps or type families
20:13:53 <ddarius> pumpkin: C++'s template system is a Turing complete lazy functional programming language.  (GHC) Haskell's is a Turing complete first order logic programming language.
20:13:58 <dons> Megzlna: yes, see the examples for  type arithmetic above (or the type arithmetic libraries on hackage.haskell.org)
20:14:01 <pumpkin> ah
20:14:02 <dons> its an interesting area.
20:14:15 <roconnor> @type runWriter
20:14:16 <ddarius> With associated types and such, it is a bit more functional.
20:14:17 <lambdabot> forall w a. Writer w a -> (a, w)
20:14:17 <dons> bos31337: portland powell's sold out of RWH, btw.
20:14:27 <dons> so all gone in 4 days.
20:14:29 <bos31337> woo!
20:14:44 <dons> they should have ordered more copies..
20:14:52 <gwern> how many did they sell?
20:14:56 <Megzlna> heheh Cale tried to drop the dependent types bomb
20:14:57 <dons> 5 :)
20:15:06 <roconnor> > take 10 $ snd (runWriter (sequence_ (repeat (tell "x")))
20:15:07 <lambdabot>   <no location info>: parse error on input `;'
20:15:13 <bos> They probably didn't know they were in Haskell Central for the West Coast.
20:15:15 <Cale> Megzlna: Well, that's basically what you're asking for.
20:15:16 <roconnor> > take 10 $ snd (runWriter (sequence_ (repeat (tell "x"))))
20:15:17 <lambdabot>   "xxxxxxxxxx"
20:15:28 <gwern> dons: why, that's slightly more than 1 a day!
20:15:29 <Philippa_> Megzlna: in one sense dependent types're really simple
20:15:31 <Cale> Megzlna: Dependent types are types which depend on values.
20:15:42 <Philippa_> it's just that in another they completely change programming
20:15:48 <Philippa_> at least, if you want to really take advantage
20:15:49 <roconnor> @src sequence_
20:15:49 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
20:15:59 <Megzlna> Looking at the dependent type paper, some researcher really was wanking
20:16:02 <dolio> At least you guys have Haskell books in your bookstores.
20:16:03 <roconnor> > take 10 $ snd (runWriter ((foldl (>>) return ())(repeat (tell "x"))))
20:16:04 <Cale> (As opposed to our more usual kind of type constructors, which are types that depend on types)
20:16:04 <lambdabot>   Couldn't match expected type `[a -> m a]'
20:16:10 <Philippa_> templates /would/ be dependent types if the values were still present
20:16:11 <Megzlna> (s)
20:16:13 <pumpkin> Megzlna: lol
20:16:14 <roconnor> > take 10 $ snd (runWriter ((foldl (flip (>>)) return ())(repeat (tell "x"))))
20:16:16 <dons> dolio: you should ask your bookstore.
20:16:16 <lambdabot>   Couldn't match expected type `[a1 -> a]' against inferred type `()'
20:16:19 <Philippa_> Megzlna: "the dependent type paper"?
20:16:20 <dolio> :)
20:16:20 <vijay4114> bos31337 and dons: i've read first 5 chapters and I've learnt a lot. Good work, gentlemen!!
20:16:25 <Philippa_> it's a whole, large field
20:16:26 <dons> vijay4114: yay!
20:16:26 <Megzlna> Philippa_: Paper(s)
20:16:28 <roconnor> > take 10 $ snd (runWriter ((foldl (flip (>>)) (return ()))(repeat (tell "x"))))
20:16:46 <dolio> dons: I know I could have them order it for me. It's just a luxury to have them carrying it already.
20:16:47 <vijay4114> very new here so just trying to soak all the conversation going on
20:16:53 <Megzlna> in C++ they just say "oh. Parameterized types? Useful. Array<100>? Can do..."
20:17:02 <Axman6> dons: did you expect RWH to sell anywhere near this well?
20:17:11 <roconnor> @botsnack
20:17:12 <lunabot>  :)
20:17:18 <lambdabot> :)
20:17:19 <sjanssen> Megzlna: those are not nearly as powerful as dependent types
20:17:23 <Axman6> heh
20:17:24 <roconnor> um
20:17:28 <roconnor> dare I try again
20:17:28 <roconnor> > take 10 $ snd (runWriter ((foldl (flip (>>)) (return ()))(repeat (tell "x"))))
20:17:41 <pumpkin> does the third (non-dons, non-bos13317) author of RWH hang out in here?
20:17:49 <Philippa_> Megzlna: in C++, they don't know that a good dependent type system is also a proof checker
20:17:51 <sjanssen> hey, would it be possible to use the new quasiquoting stuff to generate types from Num literals?
20:18:09 <ddarius> sjanssen: Of course.
20:18:14 <Megzlna> sjanssen: uBLAS in Boost boils down matrix operations
20:18:20 <Philippa_> that has consequences: you can't write C++ code that would generate new types at run-time
20:18:31 <lambdabot>   thread killed
20:18:33 <ddarius> sjanssen: You don't even need the new quasi-quotation stuff.
20:18:38 <Megzlna> sjanssen: with C++ templates, so that the removable factors are at compile time
20:18:51 <dolio> sjanssen: Yeah, you could just write a template haskell function.
20:18:54 <sjanssen> ddarius: yeah, $(numType 32)
20:19:03 <sjanssen> somebody write it!
20:19:08 <Megzlna> there we go
20:19:17 <Megzlna> $(numType 32) produces Three Two ?
20:19:22 <dons> its called "Template Haskell" for a reason.
20:19:22 <Megzlna> etc
20:19:31 <sjanssen> Megzlna: it isn't dependent programming until types *depend* on values.  C++ does not do this
20:19:34 <roconnor> @hoogle Writer w a -> w
20:19:53 <Megzlna> sjanssen: Depend in which ways?
20:19:53 <centrinia> Doesn't Template Haskell have an undecidable compilation problem?
20:19:59 <roconnor> is there a writer comand that just gives me the writer output?
20:20:02 <Philippa_> Megzlna: as in, the values are part of the type
20:20:14 <Philippa_> the way other types are part of it in Haskell, but aren't in C++
20:20:20 <Megzlna> Foo<1> -- the value is part of the type
20:20:22 <Philippa_> because in C++ the templates get compiled away
20:20:33 <sjanssen> Megzlna: perhaps you should re-read the paper by that wanking researcher :)
20:20:39 <Philippa_> no, it's not. That compiles down to a type, say, Foo_1
20:20:41 <Megzlna> the N does not get compiled away if you use it
20:20:54 <Philippa_> but it's not part of the type itself, either
20:20:54 <sjanssen> Megzlna: that is a value depending on a type
20:20:54 <roconnor> @type execWriter
20:21:02 <Philippa_> it's part of the values of that type
20:21:03 <centrinia> Megzlna: The 2x2 Int matrices are of a different type than the 3x3 Int matrices.
20:21:06 <Megzlna> Philippa_: it is part of the type itself
20:21:07 <roconnor> ,type execWriter
20:21:09 <erikc> Megzlna: http://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf
20:21:12 <erikc> slides 31 and 32
20:21:14 <lunabot>  luna: parse error on input `type'
20:21:23 <erikc> and 34
20:21:26 <Philippa_> Megzlna: no it bastard well isn't. It gets fed into the rest of the template generation, that is /not/ the same thing
20:21:39 <roconnor> > take 10 $ execWriter (sequence_ (repeat (tell "x")))
20:21:44 <Megzlna> How is that any different than 'int' ?
20:21:46 <erikc> give a real example that cannot be done in c++
20:21:48 <Philippa_> C++ has no notion of parameterised types, it /only/ has templates
20:21:49 <roconnor> , take 10 $ execWriter (sequence_ (repeat (tell "x")))
20:21:52 <lunabot>  "xxxxxxxxxx"
20:21:54 <Philippa_> that's rather my point
20:21:57 <Megzlna> 'int' doesnt exist on the CPU
20:22:18 <centrinia> erikc> Everything can be done with the C++ template system.
20:22:55 <Philippa_> Megzlna: it does during typechecking. Foo<Bar> doesn't, thoughh
20:22:58 <centrinia> Philippa_> The C++ template system can be used to construct the S and K combinators.
20:23:02 <erikc> ok, lets say instead that it is synctactically infeasible to do :)
20:23:21 <Megzlna> Philippa_: Foo<Bar> doesn't what during typechecking?
20:23:24 <Philippa_> centrinia: I know it's turing complete. That's not what I'm complaining about
20:23:25 <roconnor> , take 10 $ execWriter (sequence (repeat (tell "x")))
20:23:25 <ddarius> centrinia: That the type level can compute arbitrary functions does not mean that it makes available arbitrary type abstractions.
20:23:27 <lunabot>  "xxxxxxxxxx"
20:23:35 <maxote> does exist Lazy P-Code Pascal?
20:23:37 <Philippa_> Megzlna: doesn't exist. It only exists during template expansion
20:23:49 <Megzlna> k, which typechecking?
20:24:34 <Philippa_> ...remind me of the relevant process?
20:24:43 <Philippa_> It won't actually affect my point, it'll just help me explain it to you
20:24:53 <Megzlna> I'm actually not sure
20:24:56 <Philippa_> it's easier not to, though...
20:24:57 <dons> maxote: those words don't make a sentence
20:25:09 <dolio> @keal
20:25:09 <Megzlna> void f(Foo<int, 10> const& x);
20:25:11 <Axman6> heh
20:25:26 <Philippa_> rather to tell you: the typechecker for the standard dependently-typed instances of the lambda cube /actually evaluates terms during typechecking/
20:25:34 <Axman6> bleh, i don't want to use C++ because it's so damn ugly
20:25:36 <Megzlna> f(Foo<int, 10>()); // pass a temporary Foo<int 10> type to f
20:25:50 <centrinia> What about C-- ?
20:25:52 <Axman6> i don't care what i can write in it, or how efficient it is, i hate ugly code
20:26:13 <roconnor> > foldl f e [a,b,c]
20:26:24 <Philippa_> Megzlna: rather, pass the result of instantiating Foo<int 10>
20:26:28 <roconnor> I killed lambdabot
20:26:40 <Megzlna> () was an instanciation
20:26:42 <sjanssen> @botsnack
20:26:43 <lunabot>  :)
20:26:52 <Philippa_> no, () is a construction
20:26:56 <Axman6> , foldl f e [a,b,c]
20:26:58 <lunabot>  luna: Not in scope: `f'
20:26:58 <Philippa_> <> is template instantiation
20:27:13 <Axman6> wut? no f? :\
20:27:16 <Megzlna> well, object instance, template instance, etc
20:27:19 <erikc> megzlna: dependent types would let you do foo(int n, Foo<int, n>)
20:27:23 <erikc> where n is a runtime value
20:27:29 <erikc> thats the difference
20:27:30 <dolio> Axman6: lunabot doesn't have the reflection stuff.
20:27:44 <Axman6> it should :(
20:27:52 <dolio> Talk to mmorrow.
20:28:01 <dolio> He's got everything else in there. :)
20:28:03 <Axman6> yeah, i was planning to, but he's not here
20:28:07 <Megzlna> erikc: so they're runtime types?
20:28:07 <Axman6> heh, indeed
20:28:19 <Philippa_> Megzlna: *no*, they're still separately checkable
20:28:21 <Philippa_> beautiful, huh?
20:28:35 <Axman6> anyone have any ice quasiquoting examples? all i know of so far is [$ty|f|]
20:28:37 <Megzlna> typechecking is at compile time?
20:28:42 <erikc> yes
20:29:04 <Megzlna> I don't see how that's different, still.
20:29:15 <Philippa_> then code it in C++
20:29:17 <Cale> Megzlna: One example of something which dependent types could do is give you a type-safe sprintf, where the format string is something you pass in the type system, and it gives you a function of the appropriate value parameters to a String.
20:29:18 <Philippa_> you'll find you can't
20:29:30 <Megzlna> Cale: D does that
20:29:36 <Philippa_> C++'ll insist on knowing foo at compile time
20:29:39 <Cale> Megzlna: Generically?
20:29:46 <Megzlna> Cale: Yes.
20:29:49 <Cale> Megzlna: Like, that's something you could write for yourself.
20:29:57 <Philippa_> Cale: D probably uses the old ML encoding
20:29:59 <Megzlna> Foo!("%d")(x)
20:30:04 <Megzlna> equivalent of:
20:30:10 <Megzlna> Foo<"%d">(x)
20:30:18 <Megzlna> string nontype template parameters
20:30:32 <Philippa_> okay. Now generate the format string at run-time too?
20:30:35 <sjanssen> Cale: but even that isn't really dependent typing, is it?
20:30:38 <dons> has someone written quicksort in C++'s types?
20:30:44 <sjanssen> dons: I'm sure
20:30:45 <Philippa_> dons: probably
20:30:46 <roconnor> Cale: I killed lambdabot
20:30:46 <dolio> Changing the parentheses from angled to round doesn't change things.
20:30:47 <ddarius> dons: Probably.
20:30:49 <Megzlna> Philippa_: Generate the format string at compile time?
20:30:50 <Cale> roconnor: oh?
20:30:52 <ddarius> dons: It wouldn't be hard at all.
20:30:57 <centrinia> Megzlna: Can the D printf accept an runtime generated format string and still type the other arguments appropriately?
20:31:06 <Philippa_> Megzlna: no. Run-time. Based on user input.
20:31:11 <dons> ddarius: i guess they don't have the advantage of :t to run the code
20:31:12 <roconnor> Cale: I kept asking it to compute  take 10 $ snd (runWriter ((foldl (flip (>>)) (return ()))(repeat (tell "x"))))
20:31:43 <Cale> roconnor: I can't ssh in to codersbase.com at the moment.
20:31:58 <Cale> Or at least, it's very slow.
20:32:00 <sjanssen> dons: the first demonstration of C++ templates' Turing completeness was a program that printed the prime numbers in compiler error messages :)
20:32:00 <roconnor> okay
20:32:07 <roconnor> I can always kill lunabot instead
20:32:13 <Megzlna> well, that's not a problem in the first place in D, since there's no runtime type tags like Haskell data ctor
20:32:19 <Megzlna> since it knows the type of x
20:32:20 <roconnor> , take 10 $ snd (runWriter ((foldl (flip (>>)) (return ()))(repeat (tell "x"))))
20:32:23 <Cale> roconnor: Out of interest, why?
20:32:24 <lunabot>  luna: out of memory (requested 1048576 bytes)
20:32:36 <sjanssen> Megzlna: Haskell doesn't have runtime type tags
20:32:47 <Philippa_> Megzlna: no. Haskell has no type tags. That's a union type, not the same thing
20:32:49 <roconnor> Cale: I was verifying my comment before posting: http://www.reddit.com/r/haskell/comments/7itbi/mapm_mapm_and_monadic_statements/c06s9bs
20:32:55 <sjanssen> Megzlna: data constructors are tags of the value, not the type
20:32:58 <Cale> ah
20:33:07 * Philippa_ takes a different tack...
20:33:19 <roconnor> Cale: why sequence_ uses foldr instead of foldl
20:33:21 <Philippa_> Megzlna: provide a C++ program that is a proof that 1+1 = 2
20:33:24 <Cale> yes :)
20:33:38 <Megzlna> Philippa_: at compile time?
20:33:44 <roconnor> lots of people stuck in the idea that monads order evaluation
20:33:52 <Cale> roconnor: yeah
20:33:54 <roconnor> that concept needs to be squashed
20:33:58 <Philippa_> Megzlna: a program that is a proof. Take that statement entirely literally
20:34:00 <ddarius> roconnor: I agree.
20:34:05 <Megzlna> http://h3.team0xf.com/ctrace/
20:34:19 <Axman6> "it had three volumes, the first of which took 400 pages to prove that 1+1=2" you know you're in for a good time when you hear that in a talk
20:34:25 <Cale> It's troubling. Also, a lot of people still think they have something to do with IO.
20:34:27 * ddarius has managed to convert people to his crusade over the years.
20:34:46 <Philippa_> Megzlna: showing me piles of compile-time computation is missing the point
20:35:04 <Philippa_> I don't want you to encode 1+1==2 in the type system and show it evaluates to True
20:35:05 <roconnor> Cale: even those who know monads beyond IO think that it sequences evaluation in other monads
20:35:19 <roconnor> Cale: and, as we both know, even the IO doesn't really sequence evaluation
20:35:21 <Cale> roconnor: right.
20:35:36 <Cale> evaluation of the actions is independent of their execution.
20:35:48 <roconnor> heck, I'll go all out and say that IO *doesn't* sequence evaluation period.
20:36:03 <jsn> Cale: how is evaluation distinct from execution?
20:36:08 <dolio> > (sequence_ $ replicate ask) 5
20:36:13 <Cale> Apart from the fact that output causes pattern matching, which demands evaluation
20:36:15 <dolio> , (sequence_ $ replicate ask) 5
20:36:17 <lunabot>  luna: Couldn't match expected type `GHC.Types.Int'
20:36:30 <dolio> , (sequence_ $ repeat ask) 5
20:36:30 <Cale> jsn: evaluation is the reduction of expressions to values
20:36:32 <roconnor> dolio: does that even typecheck?
20:36:33 <lambdabot> Control.Monad.Writer.Lazy execWriter :: Writer w a -> w
20:36:34 <Philippa_> Megzlna: I'm guessing the question makes no sense to you
20:36:36 <lunabot>  Killed.
20:36:42 <Axman6> , [$ty| ask |]
20:36:42 <Philippa_> "how can a program be a proof"?
20:36:45 <jsn> Cale: and execution would be what?
20:36:49 <lambdabot> Plugin `hoogle' failed with: thread killed
20:36:50 <roconnor> Cale: ah, lambdabot is back
20:36:55 <lunabot>  forall a b . MonadReader a b => b a
20:36:59 <Megzlna> Philippa_: is 1 runtime?
20:37:04 <Cale> jsn: Well, for IO specifically, execution is the carrying out of IO actions.
20:37:08 <dolio> roconnor: (->) r is a MonadReader instance.
20:37:18 <Philippa_> Megzlna: you're looking at utterly the wrong level of abstraction here
20:37:24 <roconnor> dolio: I'm happier with repeat :)
20:37:31 <jsn> Cale: in that particular case, do we not execute them to evaluate them?
20:37:34 <dolio> Yeah. I get those two swapped sometimes.
20:37:44 <Philippa_> calculi like the calculus of constructions (or, to be fair, the simply-typed lambda calculus) are also formal logics
20:37:47 <Cale> jsn: No, evaluating an IO action doesn't cause anything at all to happen.
20:37:55 <Cale> jsn: That is, it doesn't cause any I/O
20:38:05 <roconnor> jsn: in execution is stuff like printing on the screen or getting characters from the terminal.
20:38:09 <Cale> jsn: But we do need to evaluate an IO action to execute it.
20:38:14 <Philippa_> it's quite common for add in a dependently-typed language to have a type that actually says that it's addition
20:38:15 <Megzlna> Philippa_: Show how the 1+1==2 proof is done in Very few loc
20:38:21 <jsn> Cale: okay
20:38:31 <Cale> jsn: It's just that the order in which the action gets evaluated is somewhat independent of the order in which the steps happen.
20:38:40 <Philippa_> Megzlna: nah, it's half four in the morning here
20:38:55 <Cale> jsn: If it helps, you could think of an IO action as being the source code for a program.
20:39:00 <Cale> jsn: (a C program, say)
20:39:00 <roconnor> jsn: but we only need to evaluate an IO action as far as needed to execute it.
20:39:02 <Philippa_> however, if you want to understand what I'm talking about, the keyword is "curry-howard isomorphism"
20:39:03 <Axman6> Philippa_: weak effort, you're going to lose!
20:39:28 <jsn> Cale: yes
20:39:29 <Philippa_> Axman6: it's damn late. I can't be arsed. If anyone else can, they're welcome to explain what I'm talking about
20:39:30 <Megzlna> I want to know how it's useful in an app
20:39:36 <Cale> jsn: Evaluating the source code gives you a string or abstract syntax tree which is a bunch of instructions to carry out, but doesn't actually *do* anything.
20:39:40 <roconnor> jsn: because "return (big_expr) :: IO Int" has no actions associated to it, big_expr is not evalutated (at this point)
20:39:44 <Philippa_> Megzlna: it lets the type system prove that the app is correct
20:39:45 <jsn> Cale: oh
20:40:03 <jsn> roconnor: ah
20:40:10 <Philippa_> you can actually encode the whole of a function's contract in its type
20:40:18 <Axman6> Cale: ah, that's a nice explanation
20:40:36 <roconnor> jsn: it may be evaluated if bound (y <- return (big_expr)) and that y is demanded at some point in time
20:40:47 <roconnor> jsn: essetailly that code is a let
20:40:48 <jsn> so, consider this:    do {  h <- openFile "rubbish" Read Mode ; putStrLn "bleah" }
20:40:56 <Megzlna> Philippa_: So, it's a protocol, not just an enabling feature
20:41:10 <jsn> even though the h is not used, the file is still opened
20:41:38 <Axman6> :t openFile
20:41:40 <lambdabot> Not in scope: `openFile'
20:41:44 <sjanssen> Megzlna: sure it is, it enables you to write correct programs, and be sure of it
20:41:45 <erikc> does dependent typing require losing turing completeness?
20:42:09 <dolio> Depends.
20:42:13 <Philippa_> erikc: no. However, there's the minor question of whether you want the typechecker to always terminate
20:42:21 <Cale> jsn: Right, which is another difference from evaluation -- the steps that an IO action describes are ordered and when carried out, each of them occurs predictably.
20:42:22 <erikc> ah, right
20:42:36 <jsn> Cale: ah, yeah
20:42:39 <Megzlna> a programmer who is smoking crack can still write an incorrect program which proves itself to be correctly incorrect
20:43:00 <Cale> Also, if evaluation caused IO actions to fire, it would be a major security problem for lambdabot
20:43:04 <Philippa_> no, they can't
20:43:08 <maxote> GHC is a incorrect program
20:43:15 <jsn> Cale: ah
20:43:15 <Cale> Because you could say   deleteHarddrive `seq` 5
20:43:25 <Megzlna> ^----
20:43:44 <jsn> so, we have said a bunch of stuff
20:43:49 <jsn> monads do not sequence
20:43:52 <centrinia> > launchMissiles 100 SovietRussia
20:43:53 <lambdabot>   Not in scope: `launchMissiles'Not in scope: data constructor `SovietRussia'
20:43:54 <jsn> evaluation is not execution
20:44:01 <jsn> the IO monad does not sequence things
20:44:05 <Philippa_> Megzlna: the type system would show such a proof to be invalid
20:44:15 <jsn> but, how does the sequencing in the IO monad happen?
20:44:17 <Cale> The IO monad does help you sequence effects, actually.
20:44:18 <Philippa_> unless you just mean the specification problem?
20:44:26 <Megzlna> the intent of the program
20:44:27 <jsn> parameter dependence, right?
20:44:30 <erikc> so for say, "real application development", you'd probably want a non-total top layer of your program that drives provably correct parts?
20:44:33 <Cale> By explicitly representing the order in which they're to occur.
20:44:43 <Philippa_> right. If you can't spec, you're screwed regardless
20:44:45 <Philippa_> so?
20:44:49 <Cale> It's just that the IO action doesn't express anything about the order of *evaluation*
20:44:56 <Axman6> how would one run forkIO only when a certain condition is true?
20:44:58 <jsn> ah
20:45:10 <Megzlna> How does this differ from contracts?
20:45:12 <Cale> It does have something to say about the order of execution of those steps.
20:45:21 <jsn> Axman6: using if?
20:45:25 <Philippa_> it's completely checkable at compile-time
20:45:27 <jsn> Cale: aha
20:45:41 <Axman6> jsn: think it'll be an ugly if statement, but i'll give it a go i guess
20:45:43 <Megzlna> well it sounds really nuts.
20:45:54 <roconnor> jsn: you may be intrested in what I wrote at
20:45:55 <sjanssen> Axman6: when foobar (forkIO stuff)
20:45:57 <Philippa_> it would do to you
20:46:00 <roconnor> @wiki IO_Semantics
20:46:01 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics
20:46:11 <Megzlna> it would do to me bad things
20:46:13 <Philippa_> there are some really deep connections involved in making it work that you don't presently understand
20:46:14 <Axman6> sjanssen: i want to run it without forkIO if it's falce
20:46:17 <Axman6> se*
20:46:23 <Philippa_> eh, you'd just want to use looser types
20:46:52 <sjanssen> Axman6: if foobar then forkIO stuff >> return () else stuff
20:47:08 <Axman6> yeah that'll do
20:47:16 <Megzlna> a dependent typed language would be good for NASA's rovers
20:47:30 <Philippa_> it'd be good for a lot more with the right libraries
20:47:40 <Philippa_> see, you wouldn't just put code in them: you'd put proofs in
20:47:44 <Philippa_> (actually, same thing)
20:47:52 <erikc> philippa, did my earlier question make sense
20:47:52 <Philippa_> now, consider what "generic" means there
20:48:06 <maxote> Megzlna, yes, one kernel panic is sufficient to kill the NASA's rover
20:48:29 <Philippa_> erikc: oops. That's one option - really what you want is a productive program though
20:48:34 <Philippa_> (that's the dual of terminating)
20:49:30 <Philippa_> Megzlna: I'd want to use it for anything financial too, myself. Yep, that includes web apps
20:49:42 <dolio> erikc: That's the direction some people are looking into (although I'm not sure how hard at the moment). You have a non-total monad at the outer level like Haskell's IO monad.
20:49:42 <centrinia> How much does a Mars rover on Mars cost?
20:49:47 <Philippa_> libraries're the important bit - nice general proofs
20:50:00 <maxote> Obama wanna Mars Rovers on Mars
20:50:04 <erikc> dolio: right, i was about to say 'totality will be the next purity'
20:50:13 <erikc> the next hot topic
20:50:30 <jsn> Megzlna: i guess the question is how much you value knowing that your program works
20:50:44 <jsn> if it's big enough, mechanical proof is really vital
20:51:14 <Philippa_> jsn: the fact you don't have to prove everything is relevant though. You can just use dependent typing in a 'better haskell' vein without trying to prove eg termination
20:51:24 <jsn> yes
20:51:33 <erikc> whenever i look at dependent typd stuff i always wonder how they'll do real numbers
20:51:47 <Philippa_> erikc: like any other programming language: they won't
20:51:53 <jsn> what good are real numbers
20:51:58 * roconnor wrote his thesis on doing real numbers with dependent types
20:52:03 <jsn> rationals seems to be pretty good
20:52:10 <erikc> roconnor: o rly? link pls :)
20:52:16 <Philippa_> roconnor: ah, feel free to yell at me then :-)
20:52:23 <centrinia> Rationals can not encode an infinite number of bits.
20:52:34 <roconnor> erikc: Actually I'm not done editing my thesis yet
20:52:40 <erikc> ah hehe
20:52:43 <jsn> Cale: so, if i understand correctly, the way the monadic do notation is setup enforces the ordering of the steps
20:52:45 <roconnor> erikc: I'll point you to my publications though
20:52:48 <dolio> > pi :: CReal
20:52:49 <lambdabot>   3.1415926535897932384626433832795028841972
20:52:50 <Cale> centrinia: Individual computable reals aren't actually allowed to either...
20:53:00 <Cale> jsn: yeah
20:53:14 <jsn> Cale: so the sequencing has nothing to do with monads per se
20:53:17 <maxote> is there any constructive method to find the quintic problem?
20:53:18 <Cale> jsn: But in various monads, the order in which the results are evaluated can be very different
20:53:19 <jsn> just with do notation?
20:53:23 <jsn> oh
20:53:26 <roconnor> erikc: http://arxiv.org/abs/0805.2438
20:53:27 <jsn> even with do notation
20:53:30 <Cale> jsn: yes
20:53:37 <Cale> jsn: Have a look at the list monad...
20:53:38 <roconnor> and more at http://dblp.uni-trier.de/db/indices/a-tree/o/O=Connor:Russell.html
20:53:47 <jsn> Cale: fair enough :)
20:53:50 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
20:53:51 <lambdabot>   [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2...
20:53:53 <erikc> i figured, practically, that you'd model real numbers by encoding a proof of ieee754 or some such
20:54:06 <Megzlna> Even, without, dependent types, Haskell should be able to parameterize a type by a type or by a nontype
20:54:12 <roconnor> > showCReal 100 pi
20:54:13 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
20:54:25 <erikc> but its one of those glossed over areas whenever i read up on dependent types
20:54:29 <jsn> Megzlna: haskell is able to parameterize a type by a type
20:54:36 <Megzlna> jsn: or by a nontype
20:54:48 <dolio> Even without dependent types, haskell should have dependent types.
20:54:50 <centrinia> Is there a programming language that support types whose cardinality is that of the power set of the reals?
20:54:56 <Philippa_> no, only by types
20:55:13 <maxote> symbols{a,b,c,d}, variables{x}, solve me x^5+ax^3+bx^2+cx^1+d=0
20:55:18 <Megzlna> should be -> meaning it cannot
20:55:20 <jsn> dolio: i think in a more limited fashion -- paramaterization by 1, 2, ...
20:55:26 <jsn> dolio:  it could be done
20:55:29 <dons> :k (->)0
20:55:30 <lambdabot> Only unit numeric type pattern is valid
20:55:30 <dons> :k (->)
20:55:31 <lambdabot> ?? -> ? -> *
20:55:33 <Megzlna> but should be able to, even without the heavy duty dependent types
20:55:35 <dons> :k (->) Int
20:55:36 <lambdabot> ? -> *
20:55:39 <dons> :k (->) Int Bool
20:55:39 <Cale> centrinia: well... programs are usually finite in length
20:55:40 <lambdabot> *
20:55:46 <roconnor> centrinia: yes, all of them
20:55:48 <dolio> jsn: Yeah. You could give nicer syntax to type-level analogues to various values.
20:55:49 <centrinia> maxote: Do you accept hypergeometric functions?
20:55:50 <roconnor> more or less
20:55:53 <Cale> centrinia: which means there's only a finite amount of information in any given value
20:55:54 <Philippa_> Megzlna: the problem there is that you end up shooting yourself in the foot for later
20:55:55 <dons> :k 1
20:55:56 <lambdabot> *
20:55:59 <Megzlna> because type parameterization doesn't need to even bind to the type
20:56:01 <jsn> dolio: right, it would be a pun
20:56:02 <maxote> symbols{a,b,c,d}, variables{x}, solve me x^5+ax^3+bx^2+cx^1+d=0 using constructive methods assisted by computer
20:56:04 <dolio> spj's proposed some, I think.
20:56:05 <Megzlna> or nontype param
20:56:08 <dons> :t undefined :: 1
20:56:09 <Cale> centrinia: Which effectively means that there are only countably many values...
20:56:10 <lambdabot> Unit
20:56:13 <roconnor> centrinia: Int, Int -> Int, (Int -> Int) -> Int, ...
20:56:14 <dons> > undefined :: 1
20:56:15 <lambdabot>       No instance for (Show Unit)
20:56:15 <lambdabot>        arising from a use of `show' at <int...
20:56:22 <maxote> centrinia, what are the hypergeometric functions?
20:56:26 <Philippa_> there /is/ some work being done, but it needs treating with a lot more care than you're talking about
20:56:33 <Cale> However, it is a *bit* of a philosophical question when you involve user input.
20:56:48 <centrinia> maxote: Look them up.
20:56:49 <Philippa_> because we already have the means to try to compute with it at type-level once you've got it there
20:56:55 <Megzlna> template (int N) {  int x; int y; class Foo {}; alias bool t1; typedef int t2; void f() {}   }
20:57:00 <roconnor> centrinia: Cale lies,  they are only as uncontable in the same way that all mathematical expressions are countable.
20:57:05 <Cale> xs <- getContents -- how many possible values could xs have, given that the program might run forever?
20:57:07 <centrinia> maxote: There was also a poster called "Solving the Quintic" from a while back.
20:57:07 <Megzlna> rather,
20:57:09 <Philippa_> templates are not a valid analogue
20:57:12 <Megzlna> template Foo(int N)
20:57:25 <Megzlna> Philippa: ah, but:
20:57:30 <roconnor> which is a unfair way of thinking about it
20:57:39 <Philippa_> look, if it gets to type level then it interacts with type classes
20:57:54 <Cale> roconnor: hm?
20:58:01 <Cale> roconnor: What did I lie about?
20:58:06 <nolrai_East> @pl f a b = g $ m a b
20:58:06 <lambdabot> f = (g .) . m
20:58:16 <jsn> Megzlna: honestly, i share some of your frustration, with having to define vectors via peano numbers and such
20:58:19 <Megzlna> template Foo(int N) { static const int Foo = N; }       int x = Foo!(1);   // if Foo has the same name as the template which surrounds it, then the template itself *is* the value 1 given Foo(1)
20:58:27 <nolrai_East> :t (. (.) .)
20:58:29 <lambdabot> parse error on input `)'
20:58:32 <Cale> The ZFC-definable reals and the computable reals are both countable sets.
20:58:44 <roconnor> Cale: you keep saying that there are only a countable number of constructive objects,  but that is analogous to saying that there are a countable number of mathematical expression, and that set theory has a countable model.
20:59:05 <Megzlna> Foo!(1) == 1
20:59:19 <Cale> roconnor: It does have a countable first order model :)
20:59:22 <Philippa_> Megzlna: yeah. That /doesn't work/ in Haskell
20:59:23 <centrinia> Cale, that means that there are a lot of sets of real numbers.
20:59:34 <Philippa_> because you can't compare it to, say, 2
20:59:37 <roconnor> Cale: but on the other hand, you usually say there are an uncountable number of (classical) real numbers
20:59:40 <Megzlna> There's no reason why haskell has to bind the parameters to the type
20:59:48 <Cale> roconnor: right.
21:00:06 <jsn> Megzlna: in principal, you might be right
21:00:07 <nolrai_East> :t ((.) (.) (.))
21:00:09 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
21:00:11 <jsn> Megzlna: but so what?
21:00:22 <Philippa_> and frankly, go write the paper if you're so smart
21:00:23 <jsn> Megzlna: you want to go use Agda?
21:00:23 <roconnor> Cale: You sould be use a comparable interpretation when comparting constructive and classical mathematics
21:00:24 <Cale> roconnor: The way I think about it is that a computable real is a program for computing approximations to a real number, and there are only countably many of those.
21:00:53 <Philippa_> if you're right, SPJ et al will be plenty happy to work with you to implement it in GHC
21:00:53 <roconnor> Cale: cantor's proof of the uncountability of the real numbers is just as much constructive argument as it is a classical one
21:00:54 <jsn> Megzlna: type inferencing languages with nice libs and decent syntax do not grow on trees
21:00:54 <Cale> roconnor: I guess it stems from my unrelentingly turning everything into ZFC in my head.
21:00:57 <nolrai_East> @pl f g h = (g .) . h
21:00:58 <lambdabot> f = (.) . (.)
21:01:08 <nolrai_East> :t ((.) . (.))
21:01:10 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
21:01:11 <roconnor> Cale: you are using a deep embeding :)
21:01:22 <Cale> roconnor: So when I talk about constructive objects, I'm thinking of an embedding of those things in ZFC.
21:01:25 <Cale> yes
21:01:26 <centrinia> Cale> You support the axiom of choice? ;)
21:01:30 <Cale> centrinia: yes.
21:01:39 <jsn> Cale: so, in your example of the list monad, there was sequencing of a kind
21:01:41 <roconnor> Cale: that would explain why you state things the way you do.
21:01:46 <Cale> centrinia: I'm Pro (axiom of) Choice
21:01:58 <jsn> ack
21:02:02 <Cale> jsn: yes
21:02:09 <roconnor> Cale:  do you have the shirt? :)
21:02:21 <centrinia> Where can I get a shirt? :p
21:02:25 <Cale> roconnor: I don't unfortunately... I should drop by and get one :)
21:02:25 <jsn> Cale: so, what is puzzling to me, is people will monads sequence nothing
21:02:38 <Megzlna> Haskell won't go back on that now
21:02:41 * roconnor made the first of those shirts
21:02:42 <jsn> or monads have nothing whatever to do with sequencing
21:02:54 <jsn> Megzlna: go back on what?
21:03:04 <jsn> what do they actually mean?
21:03:06 <Cale> jsn: It's sequencing these nondeterministic selections, but that doesn't directly correspond to the order in which the resulting list is evaluated.
21:03:13 <roconnor> centrinia: organise a club of math students and make a group order
21:03:16 <jsn> Cale: ah , isee
21:03:19 <Philippa_> Megzlna: it won't if it means breaking something
21:03:20 <Cale> jsn: Of course, it has an impact on it...
21:03:27 <roconnor> centrinia: apparently you can do this with as few as 20 or 30 shirts
21:03:34 <roconnor> centrinia: actually we have cafe press now
21:03:38 <jsn> Cale: so there is this business of sequence effects
21:03:39 <Philippa_> it also won't /if it means breaking something we're working towards/
21:03:44 <roconnor> centrinia: so I guess anyone can make any shirt any time
21:03:48 <jsn> s/sequence/sequencing/
21:03:56 <Cale> jsn: and we separate it from the matter of sequencing evaluation
21:03:58 <Cale> right
21:04:03 <jsn> what is an "effect" in the list monad?
21:04:12 <Philippa_> given that you only just discovered today what dependent typing is and can do, you should assume that you don't know the full consequences of what you're advocating
21:04:14 <centrinia> Our group order is around 60 or so. ;)
21:04:46 <Megzlna> Philippa_: I'm not advocating dependent typing
21:04:49 <jsn> in the Parsec monad, is getting a char from the input an "effect"?
21:05:04 <Cale> jsn: In the list monad, it's a nondeterministic selection between choices.
21:05:07 <jsn> Philippa_: he just wants type level puns for 1, 2, 3...
21:05:07 <Megzlna> but, something more practical relative to the current state of Haskell
21:05:24 <jsn> he or she, i guess
21:05:26 <Megzlna> jsn: Well, I was also talking about creating instances
21:05:34 <roconnor> jsn: the list [1,2,3] is the non-deterministic (simultanious) choice of 1 2 and 3.
21:05:35 <Megzlna> Of all nested types
21:05:42 <Megzlna> inside of a type parameterization block
21:05:42 <jsn> assume makes an ass out of u & me
21:05:57 <roconnor> > do x<-[1,2,3]; y<-[4,5,6]; return (x,y)
21:05:59 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
21:06:02 <Megzlna> which binds to anything
21:06:15 <Philippa_> jsn: yeah. That wants handling with care though - consider Omega as a point in the design space
21:06:24 <Philippa_> "type parameterisation block"?
21:06:30 <jsn> Philippa_: omega?
21:06:35 <Megzlna> it would be like this, in Haskell:
21:06:49 <Philippa_> jsn: Tim Sheard's language
21:07:02 <nolrai_East> :t fmap . second
21:07:03 <lambdabot> forall (f :: * -> *) b c d. (Functor f) => (b -> c) -> f (d, b) -> f (d, c)
21:07:09 <erikc> hrm, im having a really rough time with parsec on what should be a simple lexing job, can someone give me a hand in a private chat?
21:07:13 <Philippa_> so named because the type-term-kind-etc sequence is unbounded
21:07:40 <roconnor> jsn: by because of the "back-tracking search" method that is employed by the list monad, the various nondeterministic choices are evaulated back(tracking) and forth
21:07:50 <roconnor> > take 3 $ do x<-[1,2,3]; y<-[4,5,6]; return (x,y)
21:07:52 <lambdabot>   [(1,4),(1,5),(1,6)]
21:07:59 <dolio> Is it? I thought it just had datakinds...
21:08:01 <roconnor> > take 3 $ do x<-1:undefined; y<-[4,5,6]; return (x,y)
21:08:02 <lambdabot>   [(1,4),(1,5),(1,6)]
21:08:06 <dolio> I guess I should go back a look.
21:08:20 <roconnor> > take 6 $ do x<-1:2:undefined; y<-[4,5,6]; return (x,y)
21:08:21 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6)]
21:08:35 <dolio> I guess once you have those, you want something higher than that and so on.
21:08:35 <roconnor> >  do x<-1:2:undefined; y<-[4,5,6]; return (x,y)
21:08:36 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6)* Exception: Prelude.undefined
21:08:53 <Megzlna> parameterize g X { f :: (X a) => a -> a; f x = x + x }
21:08:55 <jsn> roconnor: okay
21:09:04 <jsn> roconnor: so, that does not look nondeterministic
21:09:07 <Megzlna> g Num. f 1
21:09:21 <jsn> which is to say, i'm pretty sure of the order it's going to evaluate in
21:09:29 <roconnor> jsn: it is deterministic (backtracing search) externally
21:09:42 <roconnor> but it is a non-deterministic programming language internally.
21:09:48 <jsn> roconnor: why is it "search" ?
21:10:00 <Megzlna> parameterize g type X nontype Y { f :: (X a) => a -> a; f x = x + Y }
21:10:05 <Megzlna> well, 'y'
21:10:20 <nolrai_East> :t fmap
21:10:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:10:39 <jsn> Megzlna: well that is more than puns, i guess
21:10:51 <roconnor> jsn: because branches can be cut off by guards
21:11:00 <jsn> roconnor: ah, i see
21:11:07 <Megzlna> param g (class X, int Y) { f :: (X a) => a -> a; f x = x + y }
21:11:16 <roconnor> >  do x<-[1,2,3]; guard (odd x); y<-[4,5,6]; return (x,y)
21:11:17 <lambdabot>   [(1,4),(1,5),(1,6),(3,4),(3,5),(3,6)]
21:11:26 <Megzlna> you need separate 'class', 'type' and 'int'
21:11:29 <jsn> sweet
21:11:41 <roconnor> jsn: so when you ask for the head (or next element of a list) it has to search for a solution satifiying the guards
21:11:45 <Megzlna> Anthing inside the block gets an instance
21:11:50 <conal> nolrai_East: playing with semantic editor combinators?
21:11:50 <roconnor> jsn: guard isn't special though
21:11:53 <roconnor> @src guard
21:11:53 <lambdabot> guard True  =  return ()
21:11:53 <lambdabot> guard False =  mzero
21:11:55 <Megzlna> Then you can do:
21:11:58 <jsn> right
21:12:01 <jsn> it's mzero
21:12:11 <jsn> could be []
21:12:11 <xpika> is there a funtion that turns ('x','y') -> ('y','x')?
21:12:12 <roconnor> @src mzero []
21:12:12 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
21:12:18 <roconnor> @src [] mzero
21:12:19 <lambdabot> mzero = []
21:12:32 <jsn> roconnor: so, what is sequenced here is searching branches
21:12:34 <Megzlna> param g (class X, class Y, Y y) { f :: (X a) => a -> a; f x = x + y }
21:12:34 <Megzlna> g Num Int 10. f 1
21:12:44 <roconnor> jsn: not really
21:12:46 <jsn> roconnor: and the order in which it happens is, nominally, unspecified
21:12:48 <jsn> roconnor: oh
21:13:01 <roconnor> jsn:  what is being sequences is the series of non-deterministic choices
21:13:09 <jsn> choices from the list?
21:13:14 <roconnor> yes
21:13:16 <Megzlna> now: *if*
21:13:18 <roconnor> first chose x
21:13:21 <roconnor> then guard
21:13:23 <roconnor> then chose y
21:13:27 <jsn> ah
21:13:30 <Megzlna> the nested parameterized type has the same name as the parameter class itself
21:13:43 <roconnor> this is a internal "non-deterministic" programming langauge
21:13:47 <roconnor> similar to prolog
21:13:48 <jsn> well, that seems like the obvious sequencing
21:14:11 <jsn> so what is all this business of things not being sequenced by the monads?
21:14:14 <roconnor> but externally, it is deterministic by running this backtracking-search algorithm as more and more solutions are demanded from the output
21:14:20 <Megzlna> param g (class X, class Y, Y y) { g :: (X a) => a -> a; g x = x + y }
21:14:21 <Megzlna> g Num Int 10. 1     -- it becomes an instance for the value itself
21:14:28 <roconnor> jsn: oh things are sequenced
21:14:34 <roconnor> jsn: the effects are sequences
21:14:38 <jsn> right
21:14:44 <roconnor> jsn: but evaluation is basically never sequences
21:14:47 <Megzlna> no '.f 1'
21:14:51 <Megzlna> just '. 1'
21:14:55 <jsn> roconnor: sure
21:15:07 <jsn> so, if i put that code in the debugger
21:15:14 <Megzlna> also, the (   ) part supports pattern matching
21:15:16 <jsn> first it would evaluate the list
21:15:25 <Megzlna> upon types
21:15:30 <jsn> and then it would jump to x
21:15:30 <roconnor> first it would ask for the head of the list
21:15:52 <roconnor> then it would has for the first element half of the first element of the list
21:16:04 <roconnor> which would force the first element of x to be checked
21:16:10 <roconnor> then the gaurd condition
21:16:18 <roconnor> then make sure that y is nonempty
21:16:27 <Megzlna> g Num Int 10. f  there is unique function
21:16:31 <roconnor> then demand the first element of y
21:16:40 <roconnor> then it would output [(1,4)
21:16:47 <roconnor> and then it would continut
21:16:49 <roconnor> and then it would continue
21:17:01 <roconnor> asking for the second "solution" to the output
21:17:07 <jsn> and you could make it evaluate y first instead of x
21:17:10 <roconnor> which would demand the second elemnet of y
21:17:17 <jsn> just by pairing (y, x)
21:17:27 <roconnor> jsn: nope
21:17:30 <jsn> no?
21:17:42 <roconnor> >  do x<-[1,2,3]; guard (odd x); y<-[4,5,6]; return (y,x)
21:17:44 <lambdabot>   [(4,1),(5,1),(6,1),(4,3),(5,3),(6,3)]
21:17:46 <mmorrow> , [$tyQ| undefined |]
21:17:49 <roconnor> in this example
21:17:52 <lunabot>  ForallT [a] [] (VarT a)
21:17:55 <roconnor> it still evaluates x first
21:17:58 <jsn> oh, not in this example
21:18:05 <jsn> because of the guard
21:18:06 <roconnor> because it needs to make sure it is not empty
21:18:14 <roconnor> >  do x<-[1,2,3]; y<-[4,5,6]; return (y,x)
21:18:15 <lambdabot>   [(4,1),(5,1),(6,1),(4,2),(5,2),(6,2),(4,3),(5,3),(6,3)]
21:18:29 <roconnor> again, it needs to check first that x is not null
21:18:36 <jsn> oh
21:18:39 <jsn> interesting
21:18:44 <roconnor> then it checks y is not null
21:18:53 <roconnor> then it gets the head if y
21:18:57 <roconnor> then it gets the head of x
21:19:02 <jsn> ah
21:19:04 <Axman6> mmorrow: i was going to ask earlier, do you have any plans to add the SimpleReflect stuff lambdabot has to lunabot? ( > foldr f x [a,b,c])
21:19:06 <roconnor> and output [(4,1)
21:19:30 <mmorrow> Axman6: oh nice, that's a good idea. is that on hackage?
21:19:32 <jsn> when you say head of y, head of x -- i am interpreting x and y as the list elements, not as the lists, themselves
21:19:33 <roconnor> jsn: of course, you relaize it could even output "[(4" before evaluating the head of x
21:19:41 <roconnor> jsn: I was just glossing over some details
21:19:45 <Axman6> mmorrow: no idea :\
21:19:52 <Axman6> @hoogle SimpleReflect
21:19:53 <lambdabot> No results found
21:19:55 <jsn> roconnor: right, i just wanted to clarify my meaning
21:19:58 <Axman6> :t f
21:19:59 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
21:20:04 <mmorrow> Axman6: i'll try to dig it up
21:20:09 <Axman6> @hoogle t)]
21:20:09 <lambdabot> Parse error:
21:20:09 <lambdabot>   --count=20 t)]
21:20:09 <lambdabot>               ^
21:20:11 <roconnor> jsn: by head of x I meand the head of [1,2,3]
21:20:12 <Axman6> whoops
21:20:19 <roconnor> jsn: you are right, this is a bad way of saying it
21:20:19 <jsn> roconnor: right,
21:20:20 <Axman6> @hoogle FromExpr
21:20:20 <lambdabot> No results found
21:20:26 <roconnor> the head of the list bound to x
21:20:32 <roconnor> but that is a mouthfull
21:20:32 <jsn> roconnor: so, the choices must be done in order
21:20:39 <roconnor> jsn: yes
21:20:46 <jsn> roconnor: because that is the semantics of the list monad
21:20:47 <roconnor> because you need to check for the nulls
21:20:52 <roconnor> yes
21:20:56 <jsn> okay
21:21:09 <roconnor> the (>>=) and return functions define this behaviour
21:21:17 <jsn> right
21:21:24 <roconnor> especially (>>=)
21:21:31 <jsn> so monads don't sequence _everything_
21:21:32 <roconnor> @src [] (>>=)
21:21:33 <lambdabot> xs >>= f     = concatMap f xs
21:21:43 <jsn> but they do sequence certain monad-specific things
21:21:43 <roconnor> jsn: monads only sequence effects
21:21:51 <roconnor> jsn: and effects are the things sequenced by monads
21:21:56 <jsn> aye
21:22:07 <jsn> so in parsec, an effect is getting a char?
21:22:07 <roconnor> such is the nature of the definition of effect
21:22:28 <roconnor> jsn: I'm not as familiar with parsec
21:22:32 <jsn> hmm
21:22:34 <jsn> okay
21:22:48 <jsn> roconnor: thank you for your time
21:22:49 <roconnor> jsn: I assume it sequences getting tokens and some (non?) deterministic choices
21:22:51 <Philippa_> jsn: yep, that'd be one
21:23:03 <jsn> Philippa_: oh, getting a char is definitely it?
21:23:15 <Philippa_> roconnor: mildly more complicated, because backtracking is optional
21:23:23 <MyCatVerbs> Philippa_: oi, get some sleep!
21:23:33 <Philippa_> MyCatVerbs: working on it, honest...
21:23:37 <mmorrow> jsn: an "effect" would be doing (Parser a -> a) via "<-"
21:23:38 <MyCatVerbs> Philippa_: you're on the same clock as me. This can't be good for you. ;)
21:23:52 <MyCatVerbs> Philippa_: well good luck.
21:23:54 <Philippa_> eh, it's not as if there's any daylight to be had anyway
21:23:58 <llayland> Thanks roconnor, that was helfpul for me as well
21:23:58 <jsn> ?localtime Philippa_
21:23:59 <lambdabot> Local time for Philippa_ is Fri Dec 12 05:23:57
21:24:05 <roconnor> jsn: monads can have multiple kinds of effects to be sequences.  Think how monad transformers allow you to create new monads that have effects of more than one monad
21:24:06 <jsn> ?localtime MyCatVerbs
21:24:08 <lambdabot> Local time for MyCatVerbs is Fri Dec 12 05:24:07 2008
21:24:10 <MyCatVerbs> Lies! It's 05:24 now.
21:24:25 <MyCatVerbs> Oh wait, time passes. Lulz.
21:24:39 <roconnor> jsn: so you might sequence state changes, writer outputs, and nondeterministic choices.
21:24:50 <roconnor> if your monad supports all these effects.
21:24:58 <jsn> roconnor: interesting
21:25:12 <roconnor> and how these effects interact with each other potentially depends on the order you apply the monad transformers
21:25:46 <jsn> when you say, how they interact, you mean, the order in which they are evaluated relative to one another?
21:26:06 <mmorrow> ooh, this looks interesting: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/typehash
21:26:17 <roconnor> the usual example I think of is combining the error monad with the state monad
21:26:25 <mmorrow> > "are you among the living?"
21:26:26 <lambdabot>   "are you among the living?"
21:26:40 <roconnor> jsn: one way, you get the state along with the exception
21:26:51 <mmorrow> ah, url titles must be off
21:26:55 <Megzlna> a type parameterization block is really just a "type function"
21:26:59 <roconnor> jsn: the other way the state is tossed away with the result and it doesn't appear with the exception.
21:27:31 <Megzlna> you use the same invokation method as functions, except the arguments are types and nontypes
21:27:48 <roconnor> jsn: so the meaning of exception in the presence of state is defined by the order of the monad transformers
21:27:50 <Megzlna> and the result is a set of declarations / definitions
21:28:00 <jsn> roconnor: hmm
21:28:14 <roconnor> jsn: probably best to play with that example to understand it
21:28:17 <Megzlna> g Int 1. f     -- . f because it can have multiple results
21:28:23 <jsn> aye
21:28:47 <roconnor> jsn: I have an slide to show you
21:28:52 <jsn> oh?
21:29:26 <roconnor> jsn: do you want open office persenation, or pdf?
21:29:36 <roconnor> http://r6.ca/Haskell/FPI.pdf  is the pdf
21:29:46 <Megzlna> it requires, also, first class type tuples
21:29:56 <jsn> PDF
21:29:56 <Megzlna> and type+nontype tuples
21:30:59 <roconnor> jsn: page 21 and 22
21:31:18 <roconnor> this is one of the problems from the ICFP 2006 contest
21:31:21 <Megzlna> Now:
21:31:25 <Megzlna> Haskell could do this.
21:31:32 <Megzlna> with 'newtype'
21:31:39 <roconnor> jsn: you want to build something from a pile of junk in the room
21:31:41 <Megzlna> but, how do you do that for 'f' ?
21:31:49 <Megzlna> (newtype + template haskell)
21:31:52 <roconnor> jsn: some of the items are broken
21:32:01 <roconnor> example:
21:32:20 <Philippa_> Megzlna: nobody's paying any attention
21:32:23 <roconnor> The motherboard is well-used.
21:32:23 <roconnor> Also, it is broken: it is a motherboard missing a A-1920-IXB and
21:32:23 <roconnor> a screw.
21:32:26 <Megzlna> how do I 'newtype' equivalent on a function?
21:32:33 <Philippa_> I'm definitely not - 'night, everyone
21:32:34 <roconnor> other example:
21:32:41 <roconnor>  The A-1920-IXB is an exemplary instance of part number A-1920-IXB.
21:32:41 <roconnor>  Also, it is broken: it is (a A-1920-IXB missing a transistor)
21:32:42 <roconnor>                                            
21:32:42 <roconnor>  missing (a radio missing an antenna) and a processor and a bolt.
21:33:01 <roconnor> notice that the A-1920-IXB is broken in a strange way
21:33:12 <roconnor> it requires a broken radio in order to be repaired
21:33:20 <roconnor> so things are broken in higher-order ways
21:33:24 <Megzlna> well, I'm asking template haskell people now.
21:33:31 <roconnor> and you can fix things by blindly repairing everything
21:33:51 <roconnor> because you may a) run out of parts, or b) fix something that you need to be broken
21:34:01 <roconnor> jsn: page 22 shows my code to solve this problem
21:34:10 <Megzlna> if I have 'Int' , how do you generate a new function instance?
21:34:32 <roconnor> jsn: NDS is a monad that has both non-determism (list) and state
21:34:46 <jsn> roconnor: sorry, my dad just called on the fine
21:34:56 <roconnor> np
21:35:11 <dons> ah A-1920-IXB
21:35:14 <dons> memories!
21:35:30 <roconnor> mm
21:37:05 <dons> such a great icfp
21:37:09 <roconnor> dons: check out my sweet code :)
21:37:10 <wli> I wonder what various people (e.g. conal) do on Windows.
21:37:16 <Megzlna> If you're using template Haskell, how do you encode 'Int' and f x = x + 1  into a unique 'f' instance?
21:37:17 <MyCatVerbs> Philippa_: sleep well.
21:37:26 <wli> Visual Haskell isn't really very up-to-date.
21:37:33 <dons> Megzlna: what are you trying to do?/
21:38:05 <erikc> wli: i just suffer with mingw and vim
21:38:44 <MyCatVerbs> wli: IIRC Conal did some GPU stuff on top of DirectX at one point.
21:38:57 <Axman6> how is mingw pronounced anyway?
21:39:07 <erikc> min-gee-double-you
21:39:24 <Megzlna> dons: I have a  name "Foo", a type "Int" and inside of a block a f x = x + 1, and with template haskell, I want to produce a unique 'f' which has encoded uniquely with the identifer "Foo", and the type Int   - and which can be re-identified using those same two parameters
21:39:51 <dons> oh, sounds like a little bit of TH hacking eh?
21:40:08 <Megzlna> with types you could just do newtype
21:40:23 <Megzlna> but for functions, the only way I know of to "encode" those types into the 'f'
21:40:29 <Megzlna> would be to generate some junky function called
21:40:37 <Megzlna> f__mangle_Foo_Int
21:40:44 <sjanssen> Megzlna: you want to generate a version of f that only works on Int?
21:40:50 <dons> ?pl \x -> x * x
21:40:51 <lambdabot> join (*)
21:41:05 <mmorrow> Axman6:
21:41:06 <mmorrow> , foldl f z [0..9]
21:41:09 <conal> MyCatVerbs: http://conal.net/Vertigo
21:41:10 <lunabot>  f (f (f (f (f (f (f (f (f (f z 0) 1) 2) 3) 4) 5) 6) 7) 8) 9
21:41:21 <Axman6> mmorrow: whoot :)
21:41:21 <Megzlna> sjanssen: I want to create a version of 'f' that's parameterized on X
21:41:25 <mmorrow> it's on hackage in the "show" package :)
21:41:32 <Axman6> mmorrow: damn, you're quick :)
21:41:38 <mmorrow> heh
21:41:40 <conal> ivan tomac is updating that GPU work.
21:41:46 <sjanssen> Megzlna: you mean you want to apply it to an argument?
21:41:58 <mmorrow> just had to change a few lines and recompile
21:42:01 <MyCatVerbs> conal: see? Scary! On top of DirectX! =D
21:42:07 <Megzlna> sjanssen: I want to give a new 'f' a unique identity based on the 'Int'
21:42:10 <Megzlna> so that
21:42:25 <sjanssen> Megzlna: on a particular value of type Int, or on the type?
21:42:30 <conal> MyCatVerbs: the new version won't be on DirectX.
21:42:32 <Megzlna> on the type, or on values
21:42:33 <sjanssen> Megzlna: don't do that, it's the compiler's job
21:42:34 <Axman6> dons: that annoys me somewhat. i'd rather it turned that into (^2)
21:42:44 <Megzlna> sjanssen: But I want to do it with template haskell
21:42:45 <sjanssen> Megzlna: see "specialization" in compiler literature
21:43:12 <MyCatVerbs> conal: remind me at some point to get a bigger disk for my Windows partition so I'll have room for VS. =)
21:43:14 <sjanssen> also {-# SPECIALIZE f :: Int -> Int #-}
21:43:25 <wli> Basic stuff like hammering in faster Fibonacci computation algorithms and dumping them to a console is the level of things I need.
21:43:49 <wli> I don't know what to install or what.
21:43:56 <sjanssen> Megzlna: if you really insist on doing this by hand, you'd have to quote the function definition, then add an explicit type signature
21:44:04 * conal is still delighted to be off of Windows.
21:44:08 <Megzlna> sjanssen: Haskell can't do it not-by-hand
21:44:18 <sjanssen> Megzlna: no, you're wrong.
21:44:28 <sjanssen> Megzlna: specialization is an optimization that GHC does
21:44:28 <Megzlna> Haskell downright lacks the feature
21:44:37 <Megzlna> Not as optimization
21:44:45 <mmorrow> Megzlna: (although with ghc's SPECIALIZE this is easily done) i pasted a (simplistic) example of doing this for Ezla the other day, lemme find it
21:44:46 <Axman6> conal: heh, i've been lucky enough to never be on it (on my ow computers at least)
21:44:49 <mmorrow> (with TH)
21:44:49 <Axman6> own*
21:44:53 <dons> Megzlna: you want to reflect the polymorphic version into an Int-specialiesd one?)
21:45:13 <dons> as {-# SPECIALIZE f :: Int -> Int #-} does?
21:45:18 <conal> Axman6: i switched to ubuntu a few weeks ago.  it's been a hugely liberating experience!
21:45:18 <sjanssen> evidence that C++ can damage your brain...
21:45:23 <mmorrow> heh
21:45:35 <dons> well, you can lift the code into the AST and process it with TH
21:45:39 <dons> modifying the type.
21:45:45 <Axman6> conal: if you want some fun, try Arch, it's the only linux distro i'll tollerate these days
21:45:46 <dons> yielding the new version to splice back in.
21:45:48 <wli> About the only thing I really want out of more modern ghc's is compatibility testing with the latest and greatest, esp. std. lib structure.
21:45:50 <dons> kind of wacky, but doable.
21:45:51 <MyCatVerbs> conal: whyso? Aside from the lack of X11-style cut buffer and the somewhat under-engineered keyboard handling (doesn't seem to be any easy equivalent to xmodmap :/), it's not -entirely- painful.
21:46:05 <MyCatVerbs> Er, selection buffer.
21:46:10 <mmorrow> Megzlna: http://hpaste.org/12806
21:46:17 <wli> I heard someone say mingw and something else.
21:46:23 <dons> Megzlna: specialisation is entirely doable via TH. (was one of the original motivators, for domain-specific specialisations)
21:47:22 <mmorrow> , [ty| $((\ty -> newName "n" >>= \n -> lamE [varP n] [|1 + $(sigE (varE n) ty)|]) [|Int|]) |]
21:47:24 <lunabot>  luna: parse error on input `|]'
21:47:25 <Megzlna> parameterize [|.|class X|type N|N n|] { f :: (X a) => a -> a; f x = x + n }
21:47:31 <mmorrow> , [ty| $((\ty -> newName "n" >>= \n -> lamE [varP n] [|1 + $(sigE (varE n) ty)\|]) [|Int\|]) |]
21:47:31 <Megzlna> as end-user syntax
21:47:32 <Megzlna> Now:
21:47:33 <lunabot>  luna: parse error on input `]'
21:47:49 <mmorrow> , $((\ty -> newName "n" >>= \n -> lamE [varP n] [|1 + $(sigE (varE n) ty)|]) [|Int|])
21:47:51 <lunabot>  luna: Not in scope: data constructor `Int'
21:47:55 <dons> Megzlna: right, so reflect and specialise.
21:47:56 <mmorrow> oh
21:48:03 <Megzlna> param [|.|Num|Int|10|]: f  'is a unique instance of f
21:48:07 <dons> the end user would use the SPECIALISE pragma.
21:48:17 <Megzlna> so my first question was: How to encode those types and nontypes into the unique f
21:48:24 <dons> but its all TH-able (you can process the AST arbitrarily)
21:48:34 <mmorrow> , [$ty| $((\ty -> newName "n" >>= \n -> lamE [varP n] [|1 + $(sigE (varE n) ty)\|]) [t|Int\|]) |]
21:48:39 <lunabot>  Int -> Int
21:48:40 <mmorrow> , [$ty| $((\ty -> newName "n" >>= \n -> lamE [varP n] [|1 + $(sigE (varE n) ty)\|]) [t|Double\|]) |]
21:48:42 <dons> mmorrow: nice
21:48:45 <lunabot>  Double -> Double
21:48:50 <mmorrow> TH++
21:48:50 <Megzlna> mmorrow: What's the best end user syntax I can get?
21:48:50 <dons> good to see TH back in the bot
21:48:57 <Megzlna> Closest to:
21:49:05 <Megzlna> parameterize [|.|class X|type N|N n|] { f :: (X a) => a -> a; f x = x + n }
21:49:08 <mmorrow> err, what interface to you want to provide?
21:49:13 <mmorrow> ok, hmm
21:49:16 <Megzlna> where 'N n' depends on the 'type N'
21:49:16 <dons> is parameterize a keyword?
21:49:38 <sjanssen> dons: Megzlna is trying to write C++ in Haskell
21:49:41 <dons> heh
21:49:46 <Megzlna> its not C++
21:49:51 <Megzlna> a lot of langs do this
21:50:19 <mmorrow> Megzlna: well in that example, you could have a function foo :: Name -> Name -> err, wait
21:50:23 <Megzlna> dons: parameterize is a keyword yea
21:50:25 <mmorrow> what is "N n"?
21:50:33 <Megzlna> gets replaced with the type
21:50:34 <Megzlna> becomes
21:50:36 <Megzlna> Int n
21:50:39 <Megzlna> and takes the nontype n
21:50:41 <wli> I'm so Windows-clueless I'm not even sure what to ask.
21:50:41 <dons> yeah, some of the terminology is a bit foreign. makes it harder
21:50:47 <sjanssen> Megzlna: n :: N would be more Haskellish
21:50:47 <mmorrow> oh ok, so:
21:50:59 <dons> n :: n :)
21:51:08 <dons> since 'n' is presumably a type variable?
21:51:08 <Megzlna> k
21:51:08 <sjanssen> yeah
21:51:16 <Megzlna> n is a literal
21:51:23 <dons> of type N
21:51:29 <sjanssen> dons: a type variable, but I guess Megzlna wants to manage the type lambda
21:51:30 <dons> which is a type variable.
21:51:31 <Megzlna> an compile time Int in this case
21:51:39 <Megzlna> because I used:
21:51:45 <Megzlna> param [|.|Num|Int|10|]. f
21:51:48 <monochrom> How do I use Text.Regex.Posix.Wrap? I mean its nice =~ operator.  Like "c+" =~ "occur" ?
21:51:56 <dons> still not quite sure what we're really trying to do here.
21:52:06 <Megzlna> dons: 'f' is unique based upon those parameters
21:52:10 <dons> type class instances from a polymorphic definitionn?
21:52:19 <sjanssen> dons: I don't think Megzlna knows GHC's optimizer can do all of things automatically
21:52:21 <Megzlna> dons: multple function signatures
21:52:21 <dons> using TH to unfold them?
21:52:24 <mmorrow> Megzlna: well in that example, you could have a function foo :: Name -> Name -> ExpQ, where the first Name is a class name, the second Name is the type name for "N", and $(foo cls ty) would splice to the type you want
21:52:33 <Megzlna> sjanssen: GHC doesnt do multiple signatures
21:52:43 <sjanssen> Megzlna: "multiple signatures"?
21:52:44 <Megzlna> this just generates multiple signatures and encodes a unique identifier
21:52:45 <dons> Megzlna: but that's what ghc does by default to the polymorphic functions
21:52:46 <Megzlna> yes
21:52:54 <Megzlna> Haskell functions can only have one signature
21:52:55 <mmorrow> but you'd have to construct the ast for that decl with the TH AST (by hand)
21:52:58 <Axman6> Megzlna: ok, i've been watching for an hour or so, and i think you've missed one of the biggest features of haskell
21:53:01 <dons> ah, i see, like f_Int, f_Double
21:53:05 <dons> from each specialisation?
21:53:17 <Megzlna> but when you encode a unique identifier, each one accessed by the 'param' keyword with the appropriate set of parameters
21:53:19 <maxote> doing P-Code Pascal always generates smaller code than e.g. Haskell
21:53:22 <Megzlna> resolves to the correct 'f'
21:53:29 <Megzlna> with its own base signature
21:53:33 <dons> is that just type class dispatch?
21:53:39 <Megzlna> dons: static
21:53:42 <dons> yeah.
21:53:51 <Megzlna> but parameterized on whatever
21:53:52 <mmorrow> that's funny you mention that, because Ezla the other day (he's coming from C++ also) was asking the /exact/ same thing and talking about f_foo, f_bar, ...
21:53:54 <Megzlna> int if you willl
21:54:06 * mmorrow hasn't used C++ extensively
21:54:21 <Megzlna> mmorrow: well ignore C++ for now, C++ is crap anyways ;)
21:54:28 <mmorrow> that must be a common thing/concept/pattern/whatever  or something
21:54:38 <mmorrow> Megzlna: :)
21:54:44 <Megzlna> so how close can you get:
21:54:47 <dons> so it is type classes + deriving?
21:54:47 <Megzlna> there's 2 functions
21:54:52 <Megzlna> errr 2 keywords here
21:54:58 <dons> Megzlna: could you code up the haskell result?
21:55:03 <dons> and some haskell pseudocode?
21:55:09 <dons> your terminology is making this harder i think
21:55:13 <Axman6> maxote: care to explain what you mean?
21:55:21 <Megzlna> param_class [|.|class X|type N|N n|] { f :: (X a) => a -> a; f x = x + n }     --- create a set of encoded 'f' types
21:55:24 <Megzlna> and then
21:55:25 <dons> Axman6: he's a bot i think
21:55:30 <dons> maxote: are you a bot?
21:55:36 <maxote> no dons
21:55:36 <Megzlna> param [|.|Num|Int|10|]. f 1      // result 11
21:55:40 <Megzlna> which is 'use'
21:55:42 <Axman6> heh
21:55:57 * dons has no idea what Megzlna is trying to do now.
21:56:02 <mmorrow> what's the significance of the "." in the "|.|" part?
21:56:04 <dons> partial application?
21:56:08 <maxote> Axman6, a time ago, it was a PDP-10 ...
21:56:11 <Megzlna> mmorrow: Nothing
21:56:15 <mmorrow> heh
21:56:20 <Axman6> maxote: what?
21:56:20 <dons> maxote: do you have a haskell question?
21:56:21 <Megzlna> only cause Template haskell is bitchy on the first type
21:56:24 <Megzlna> first param
21:56:26 <sjanssen> dons: produce a specialized version of "f" that works on a specific type and a specific value for 'n'
21:56:33 <maxote> Haskell didn't exist on PDP-10
21:56:38 <Axman6> dons: sounds like a not very good troll to me...
21:56:38 <mmorrow> Megzlna: hehe, fair enough
21:56:43 <dons> maybe.
21:56:52 <sjanssen> maxote: you're not really making sense
21:56:53 <mmorrow> i see what you're doing with the "." now..
21:57:01 <dons> Megzlna: so partially applied, and type-classed
21:57:08 <dons> a weird pattern indeed!
21:57:12 <dons> no closures in C++ ?
21:57:17 <Megzlna> D has closure
21:57:21 <dons> so kind of faked with templating?
21:57:22 <Megzlna> I dont really use C++ anymore
21:57:37 <mmorrow> Ezla was talking about D's metaprogramming also
21:57:38 <Megzlna> D replaced it and destroys it in every possible way
21:57:54 <erikc> dons: it is more akin to typeclassing where you use peano-numbers as a 'int', except in c++ you can just use int literals
21:57:55 <Megzlna> except library avail
21:57:56 <mmorrow> i think you two are after the same thing (i'm not sure what it is yet though)
21:58:04 <sjanssen> dons: it's just like C++ templates, basically
21:58:06 <Axman6> :t let f x = x+ 1 in f -- Megzlna: i'm still failing to see what's wrong with this
21:58:08 <lambdabot> forall a. (Num a) => a -> a
21:58:08 <dons> erikc: right.
21:58:23 <Axman6> @instances Num
21:58:25 <lambdabot> Double, Float, Int, Integer
21:58:29 <xpika> is there a function for (1,2) => (2,1)
21:58:32 <Megzlna> Axman6: Haskell functions have 1 signature
21:58:45 <Megzlna> mmorrow: So I'm curious, how close could the end user interface be?
21:58:45 <Axman6> Megzlna: well.. yeah
21:58:56 <sjanssen> Megzlna: you keep mentioning signatures, what do you mean by that?
21:59:01 <dons> Megzlna: hmm. well, they're already overloaded.
21:59:02 * Axman6 still doesn't see any problem there
21:59:05 <dons> you instantiate the 'a' part
21:59:16 <Megzlna> sjanssen:   f :: (Num x) -> x -> x
21:59:22 <dons> and the numeric literals would be done via type level numbers, as erikc said
21:59:24 <Megzlna> where the individual f definitions
21:59:28 <Megzlna> can only be Num instances
21:59:32 <Megzlna> that's "1 signature"
21:59:49 <Megzlna> there's only an single f for one typeclass
21:59:55 <Axman6> Megzlna: do you want f to act differently if it takes an Int instead of a Double?
21:59:56 <Megzlna> not a set of f's per parameterized typeclass
22:00:01 <dons> this C++ type system business isn't healthy for thinking about types/ metaprogramming and polymorphism, is my conclusion.
22:00:06 <Megzlna> Axman6: I'd use instance for that
22:00:08 <Megzlna> not applicable here
22:00:19 <dons> the concepts are all ad hoc and arbitrarily implemented, that it becomes hard to disentangle
22:00:25 <Axman6> Megzlna: can i ask what the point of what you want is?
22:00:32 <Megzlna> dons: It is good
22:00:37 <dons> sure. just not well defined.
22:00:42 <dons> kind of a  jumple of concepts.
22:00:44 <Megzlna> dons: If Haskell had it natively, people would say its a great feature
22:00:50 <dons> had what?
22:00:51 <erikc> megzlna: there are multiparameter type classes in haskell
22:00:58 <dons> "this thing of which you describe via examples"? :)
22:01:03 <sjanssen> Megzlna: I don't think it makes sense to parameterize a function by the type class
22:01:11 <mmorrow> Megzlna: so what are the haskell syntactic entities you want to be the result of the TH function that did just what you want?
22:01:21 <dons> sjanssen: well, we've got some proto type class families now
22:01:24 <Megzlna> mmorrow: 2
22:01:35 <sjanssen> Megzlna: how could the same function defintion support two different classes?  The set of operations is different for each type class
22:01:49 <Megzlna> mmorrow: param_class [|.|class X|type N|N n|] { f :: (X a) => a -> a; f x = x + n }      and     param [|.|Num|Int|10|]. f 3 == 13
22:01:52 <mmorrow> like e.g.  a declaration   f_T  for every type T i give as input
22:01:54 <dons> so just type level integer literals to represent type level numbers?
22:02:09 <erikc> dons: that would do it
22:02:26 <dons> and the f_T business seems a non-sequitor. that's straight out metaprogramming
22:02:35 <sjanssen> dons: Megzlna also seems to want to reify the type level numbers as value level numbers
22:02:37 <dons> others have asked for nice type syntax for numbbbres
22:02:49 <dons> sjanssen: well, its kind of like () :: ()
22:03:06 <dons> > 1 :: 1 no no
22:03:08 <lambdabot>       Kind error: `1' is applied to too many type arguments
22:03:08 <lambdabot>      In the type ...
22:03:21 <sjanssen> dons: it's more like valueOf (undefined :: 1)
22:03:28 <dons> == 1 ?
22:03:30 <Axman6> Megzlna: i still can;t see how that's useful
22:03:32 <mmorrow> Megzlna: oh, ok. one thing though is that since you're defining the function "f" on a single value "3", if you did "f 42" you'd crash. are you planning on defining other cases for "f", or are you implicitly assuming that "f" will become "f_Int" (or something) ??
22:03:32 <sjanssen> dons: yeah
22:03:39 <dons> singleton types ftw!
22:03:57 <dons> so, there's a bunch of different ideas at play here.
22:03:58 <erikc> mmorrow: the program fails to compile cause the instance for 42 isnt found
22:04:06 <sjanssen> dons: if we had numbers-as-types, it actually makes lots of sense to have a function to reify them as values
22:04:06 <mmorrow> but 42 is a value
22:04:08 <Megzlna> mmorrow: Ah, the f 3 == 13 isnt a definition
22:04:13 <mmorrow> oh, ok
22:04:21 <Megzlna> that's unmangling the f
22:04:23 <Megzlna> and calling it
22:04:29 <Axman6> >_<
22:04:30 <Megzlna> (param [|.|Num|Int|10|]. f 3) + 2
22:04:31 <dons> singleton types, type level numeric /literals/, polymorphism and overloading
22:04:34 <dons> maybe some specialisation
22:04:54 <Megzlna> The param_class is the definition of the parameterization collection
22:04:59 <Axman6> Megzlna: again, how is that useful?
22:04:59 <mmorrow> ohh, i just parsed your syntax
22:05:07 <Megzlna> mmorrow: makes sense now? :)
22:05:10 <sjanssen> dons: all of want Megzlna wants to do in this example is covered by specialization and constructor specialization :)
22:05:12 <dons> what does the . do again?
22:05:18 <Megzlna> dons: . was arbitrary
22:05:20 <dons> sjanssen: and maybe type dispatch
22:05:27 <dons> using numeric literals for the indexing
22:05:34 <dons> e.g. (foo :: 1)
22:05:39 * sjanssen prefers general compiler optimizations over changing the language
22:05:41 <Megzlna> its like
22:05:41 <mmorrow> dons: i think it's a placeholder for the {t,d,-} in [t| .. |]  [d| .. |] [| .. |]
22:05:43 <Megzlna> forall a b.
22:05:53 <mmorrow> (or maybe not)
22:06:01 <Megzlna> mmorrow: You're right
22:06:04 <Megzlna> placeholder for t and d
22:06:10 <dons> forall is like 'let' for type variables
22:06:13 <Megzlna> There's 2 differnet . usages in there
22:06:24 <Megzlna> by the 2nd one I meant delimeter
22:06:30 <Megzlna> "10|]. f 3) "
22:07:00 <wli> Well, ghc10 is installing, though it may take a while.
22:07:13 <erikc> what he wants is to be able to make functions and types like: data CArray t n, where n is an int, and be able to have a concat :: CArray t n -> CArray t -> m -> CArray t (n+m)
22:07:42 <Megzlna> it just packs template haskell away into an easy to use interface for common usage then it creates unique names inside
22:07:54 <Megzlna> so that your f is not global
22:07:58 <Megzlna> but is f for only those params
22:09:29 <mmorrow> one thing about that (i just realized this writing a paste) is it doesn't make sense to pass in "Num" since you'd be specializing it to "Int" anyway. is this what you meant?
22:09:45 <Megzlna> the Int didnt get used
22:09:49 <Megzlna> except to pass n
22:10:01 <Megzlna> the Int was only for template haskell to use at compile time somehow
22:10:09 <glguy> Does GHC require gcc specifically? Is it possible that Sun's cc would work?
22:10:09 <mmorrow> but what's the point of the Num then?
22:10:10 <Megzlna> n :: N
22:10:24 <Megzlna> mmorrow: to replace X
22:10:29 <mmorrow> meta-expressions are of type Exp
22:10:33 <mmorrow> (all of them)
22:10:33 <Megzlna> the 'f' inside wasnt the best function
22:10:40 <Megzlna> but the param instance should produce a unique:
22:10:48 <Megzlna> f :: (Num a) => a -> a; f x = x + 10
22:11:03 <mmorrow> so it would /actually/ be called "f" then, right?
22:11:07 <Megzlna> it cant
22:11:09 <Megzlna> or it would be global
22:11:11 <mmorrow> ok, gotcha
22:11:24 * Axman6 can only see an attempt to make perfectly readable beautiful well defined haskell onto some ugly mess that doesn't help make anything more clear.
22:11:30 <dons> glguy: hmm.. possible.
22:11:40 <dons> glguy: non-trivial, about the same as doing a port.
22:11:45 <Megzlna> Axman6: I'm learning... chill
22:12:12 <glguy> dons, oh, GCC it is then
22:12:17 <Axman6> Megzlna: i've been asking what the point of all this is, and the more i read, the less i can see it leading to anything at all useful, sorry :(
22:12:47 <erikc> if i was still at ibm with access to aix boxes i'd volunter for that ghc maintenance spot, i miss having access to big metal
22:12:55 <dons> glguy: good idea.
22:12:59 <dons> glguy: so moving to solaris?
22:13:08 <Megzlna> Axman6: k dont worry
22:13:28 <dons> glguy: i tried using sgi's cc , was painful. gcc was easier.
22:13:39 <dons> since ghc assumes some optimisations and extensions are available
22:13:52 <Megzlna> perhaps what they said about
22:13:53 <Megzlna> <dons> as {-# SPECIALIZE f :: Int -> Int #-} does?
22:13:59 <glguy> dons, what about gcc 2 3 or 4?
22:14:03 <Megzlna> dons: would that let me make a unique 'f' ?
22:14:14 <dons> Megzlna: that generates specialised versions of the polymorphic function for each type.
22:14:25 <dons> the compiler then dispatches to them statically when you use 'f' at that type.
22:14:28 <Megzlna> dons: base signatures?
22:14:32 <Megzlna> or instance specials
22:14:40 <dons> there's only one type, f :: a -> a , for example.
22:14:45 <Megzlna> ah
22:14:48 <dons> when you use it as f (1 :: Int)
22:14:51 <Megzlna> so its a level of indirection
22:14:53 <dons> it calls the f_Int one
22:14:56 <Megzlna> gotcha
22:14:57 <dons> well, its resolved statically
22:15:01 <Megzlna> h
22:15:03 <dons> so there's no actual indirection
22:15:03 <Megzlna> ah
22:15:14 <Megzlna> cool
22:15:15 <dons> (becaues all the type info is known, so it just inlines f_Int
22:15:26 <dons> basically remove any polymorphism penalty
22:15:31 <Megzlna> yeah
22:15:49 <Megzlna> thats part of it
22:15:50 <dons> if you look in the core, you actually see the generated versions called, e.g. f_Int
22:15:56 <wli> How do I use :cd in ghci on Windows?
22:16:30 <wli> :cd "My Documents" is failing.
22:16:36 <Megzlna> dons: works on nontypes?
22:16:45 <Megzlna> f_Int_1 ?
22:17:00 <sjanssen> wli: perhaps :cd MyDocu~1, perhaps?
22:17:17 <wli> Thanks! That worked.
22:17:25 <sjanssen> Megzlna: for non-types, there is a thing called "constructor specialization"
22:17:40 <Megzlna> sjanssen: yeah.. but
22:17:48 <Megzlna> constructor specialization is not compile time
22:17:54 <sjanssen> Megzlna: yes, it is!
22:17:58 <dons> Megzlna: it is compile time.
22:18:06 <sjanssen> please don't try to refute until you know the terminology
22:18:09 <dons> it spots application to particular constructors and generates specialised versions
22:18:11 <Megzlna> I was thinking of this:
22:18:32 <dons> so, e.g. f 1 = ... f 1 .. will generate a custom, f_1 at compile time to call instead
22:18:41 <dons> avoiding that penalty of reboxing the argument
22:18:52 <Megzlna> data Expr t where
22:18:55 <dons> this is called "constructor specialisation" and ghc does it automatically, for arbitrary data structure arguments
22:18:57 <Megzlna>   Const :: Integer -> Expr Integer
22:19:07 <Megzlna>   IsZero :: Expr Integer -> Expr Bool
22:19:08 <Megzlna> etc
22:19:12 <Megzlna> on GADTs
22:19:19 <sjanssen> @google peyton jones constructor specialisation
22:19:25 <lambdabot> http://portal.acm.org/citation.cfm?id=154633
22:19:25 <lambdabot> Title: Constructor specialization
22:19:39 <nanothief> Is there a way to catch errors using the function read? For example recovering from read "hello" :: Integer
22:19:55 <Axman6> nanothief: reads
22:20:11 <purple__> > print "hi" >>= \_ -> print "there" >>= \_ -> return ()
22:20:11 <Axman6> > reads "hello" :: [(Integer,String)]
22:20:12 <lambdabot>   * Exception: "<IO ()>"
22:20:13 <lambdabot>   []
22:20:17 <Megzlna> sjanssen: If it works at compile time, then why all the extracrapulation regarding passing Integrals in encoded types in Base 10?
22:20:36 <sjanssen> Megzlna: that is an entirely different question
22:20:51 <sjanssen> Megzlna: here is a great paper about the constructor specialization system in GHC: http://research.microsoft.com/en-us/um/people/simonpj/papers/spec-constr/index.htm
22:21:07 <Megzlna> like on Data.TypeLevel.Num
22:21:08 <erikc> sjanssen: interesting, is there user-directed constructor specialization?
22:21:12 <dons> Megzlna: this was the confusion we were talking about: your examples mixed all sorts of things, so disentangling the fundamentals takes time :)
22:21:18 <sjanssen> erikc: no, I think it is only automatic
22:21:24 <dons> erikc: yeah, {-# SPEC_CONSTR ... #-}
22:21:29 <erikc> hot
22:21:38 <mmorrow> Megzlna: here's an example of something you might do http://hpaste.org/12992  (i'm wasn't sure what place the "Num" had in there, so i may have missed something essential)
22:21:39 <dons> but i'm not sure i've used it since we played with the idea.
22:21:53 <dons> ghc's smart enough that i've not needed it
22:21:56 <erikc> we had a similar feature in xlf/xlc, but only for literals
22:22:08 <sjanssen> dons: whoa, didn't know about that
22:22:09 <dons> well, this is for arbitrary constructed data.
22:22:15 <sjanssen> I'll have to remember SPEC_CONSTR
22:22:18 <dons> sjanssen: we needed it early on when ghc wasn't smart enough
22:22:22 <erikc> and only if the literal would fold a branch that was heuristically deeemed "important", etc
22:22:52 <nanothief> Axman6, thanks
22:22:54 <dons> erikc: yeah. there's heuristics. but generally, repeatedly inspected and rebuilt data yields a custom version without the rebuidling
22:23:08 <Axman6> > reads "10484hello" :: [(Integer,String)]
22:23:09 <lambdabot>   [(10484,"hello")]
22:23:16 <Axman6> nanothief: ^^ handeh :)
22:23:40 <dons> Megzlna: the other confusion was that you were specifically talking about literals, and doing the transform by hand
22:23:44 <Megzlna> So when you guy say that 'constructor specialisation' is static, and yet it cannot be used to parameterize  GADTs...
22:23:46 <dons> while ghc does the general case, and automatically
22:24:02 <Megzlna> Why cant it be used?
22:24:03 <dons> Megzlna: now /that/s where you're talking about type level numeric parameters
22:24:04 <sjanssen> Megzlna: the type level number is for when you really do need type parameterized on numbers, which you don't usually need.  If you just want to make sure your function is optimized for a given argument, you use other things
22:24:12 <Megzlna> dons: Yes
22:24:27 <sjanssen> Megzlna: constructor specialization is a thing applied to functions, not types
22:24:41 <dons> they're different concepts. and there is no special type level numeric syntax, though you can certainly do type level numbers (and there are libraries for this)
22:24:43 <mmorrow> yeah, where TH really starts to do something useful is when it is actually manipulating the structure of code to specialize it with info the compiler can't know
22:24:52 <dons> once you have type level numbers, you can do static dispatch on those types.
22:25:04 <wli> Any vim plugins I should install?
22:25:04 <Megzlna> So to make it generate unique instances
22:25:14 <Megzlna> It needs various different things
22:25:17 <Megzlna> one approach for functions
22:25:19 <dons> Megzlna: all automated via the existing specialisation infrastructure
22:25:20 <Megzlna> another for types
22:25:25 <erikc> and just to emphasize sjanssen's point: the same is true in c++, where a good c++ compiler can do the specialization for you without needing to resort to intege rtemplate paramters
22:25:42 <erikc> separate issues
22:26:14 <mmorrow> like for instance, a TH function i wish i'd already written would make a type, say [t|ReaderT r (WriterT w (State s)) a|] and spit out a instance Monad, instance Functor, newtype .... for:
22:26:14 <Megzlna> erikc its not about optimization
22:26:19 <mathy> Hi, I'm having trouble understanding how the recursive fibonacci algorithm is as such: http://en.literateprograms.org/images/math/4/c/4/4c42de46d22d22305c59b9ba88e387e9.png
22:26:23 <dons> Megzlna: so i think we're good. the kinds of specialisation are all supported.
22:26:24 <mmorrow> @unmtl ReaderT r (WriterT w (State s)) a
22:26:25 <lambdabot> r -> s -> (a, w, s)
22:26:26 <wli> I found the Haskell "plugin" (?) but am not sure how to install it.
22:26:26 <mmorrow> that
22:26:31 <Megzlna> the compiler cannot "do it for you" to figure out that you want statically a 1000 element array
22:26:38 <mathy> Trying to improve my recursive cognition... a lot of definitions seem very similar
22:26:41 <Megzlna> Array<100> a;
22:26:43 <dons> there isn't type level numeric literal syntax, but otherwise, all the other bits are there.
22:26:51 <dons> mostly automatic, and in full generality
22:27:03 <erikc> it can if you support c99 dynamic arrays
22:27:08 <mmorrow> *... written would _T_ake a type, say ...
22:27:09 <dons> you can write type level RSA for example
22:27:13 <erikc> (and xlc, ibm's c compiler, will do that)
22:27:24 <Megzlna> erikc: remember that structs can be allocated on the stack
22:27:38 <Megzlna> we're allocating 100 bytes statically on the stack. I must specify '100'
22:27:43 <erikc> no
22:27:46 <Megzlna> Not an optimization issue.
22:27:50 <erikc> the stack can be dynamically adjusted
22:27:57 <Megzlna> I'm not talking about 'alloca'
22:28:00 <mmorrow> Megzlna: yeah, TH is great for handling massive n-tuples
22:28:03 <erikc> with alloca, and that code is inserted in the function prologue
22:28:04 <Megzlna> Alloca dynamically adjusts the stack
22:28:11 <Megzlna> erikc: does not matter.
22:28:17 <maxote> as in P-Code Pascal
22:28:19 <Heffalump> monochrom: except that GHC barfs when n gets too high (close to 100)
22:28:29 <mmorrow> the only time i'd ever use n-tuples where n > 3 is with metaprog help
22:28:30 <sjanssen> Megzlna: in Haskell, we don't worry about allocating on the stack.  Life is too short.
22:28:32 --- mode: ChanServ set +o dons
22:28:41 --- mode: dons set +b %maxote!*@*
22:28:44 <mmorrow> Heffalump: heh, 63
22:28:46 <Megzlna> You're arguing that a very general compile time specialization solution can be somehow solved with compiler-dependent alloca
22:29:09 --- mode: ChanServ set -o dons
22:29:12 <erikc> alloca is required by c99's dynamic array support
22:29:14 <Megzlna> Array<100> is the same everywhere
22:29:23 <Megzlna> sizeof(Array<100>) == 100
22:29:24 <erikc> void foo(int n) { int a[n]; }
22:29:24 <Axman6> dons: heh, yeah he was getting pretty annoying. also, he's still in here, need to kick if you want him to leave
22:29:26 <wli> > let fib 0 = 0 ; fib 1 = 1 ; fib n = fib (n - 1) + fib (n - 2) in fib 15
22:29:27 <lambdabot>   610
22:29:31 <Megzlna> its not just some arbitrary Alloca thing
22:29:32 <erikc> is valid code
22:29:32 <mmorrow> , $(tupE (fmap lift [1..63::Int]))
22:29:33 <dons> Axman6: nah, just want to mute him.
22:29:35 <lunabot>  luna: A 63-tuple is too large for GHC
22:29:39 <mmorrow> , $(tupE (fmap lift [1..62::Int]))
22:29:41 <erikc> and can be specialized for a constant literal
22:29:42 <lunabot>  luna: No instance for (GHC.Show.Show
22:29:46 <Axman6> i see :)
22:29:54 <dons> nicer policy
22:29:56 <Megzlna> erikc: you could have an Array of Array<100>'s
22:30:01 <mmorrow> i think a 12-tuple is the highest Show instance in the stdlibs too
22:30:06 <mmorrow> , $(tupE (fmap lift [1..13::Int]))
22:30:10 <lunabot>  (1,2,3,4,5,6,7,8,9,10,11,12,13)
22:30:12 <mmorrow> , $(tupE (fmap lift [1..15::Int]))
22:30:15 <lunabot>  (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
22:30:18 <mmorrow> , $(tupE (fmap lift [1..17::Int]))
22:30:21 <lunabot>  luna: No instance for (GHC.Show.Show
22:30:24 <mmorrow> , $(tupE (fmap lift [1..16::Int]))
22:30:26 <lunabot>  luna: No instance for (GHC.Show.Show
22:30:29 <Axman6> from earlier i thought it was 15
22:30:31 <mmorrow> 15
22:30:35 * Axman6 was right!
22:30:35 <erikc> megzlna: sure, you can come up with cases it doesnt work on
22:30:43 <wli> I wonder how to represent band diagonal matrix blocks.
22:30:54 * monochrom is not mmorrow
22:31:04 <Megzlna> erikc: I'm talking about a generalized type system construct and you're talking about a function in c99
22:31:12 <Megzlna> for subtracting ESP
22:31:57 <Megzlna> erikc: Cases: It doesn't work anywhere.
22:32:03 <Megzlna> alloca is one usage in 100
22:32:24 <dons> ok. so back to haskell
22:32:33 <Megzlna> mmorrow, I'm sorry
22:32:41 <Megzlna> did you see his code :)
22:32:52 <Megzlna> putStrLn . pprint =<< runQ (foo "Bar" [t|Int|] [|42|])
22:32:52 <Megzlna> f_Bar = \n_0 -> (n_0 :: GHC.Types.Int) GHC.Num.+ 42
22:33:22 <Megzlna> mmorrow: Where's the parameters being created there?
22:33:47 <erikc> k, i give up, but we've answered your questions, you're just trolling at this point
22:33:48 <mmorrow> so i passed the type in as [t|Int|] and the 42 in as [|42|]
22:34:27 <wli> Is there an AVL tree (or better yet, integer interval tree) in the std. libs?
22:34:36 <mmorrow> putStrLn . pprint =<< runQ (foo "Bar" [t|Double|] [|pi|])        would give
22:34:59 <dons> wli, yeah, on haakcage.
22:35:01 <dons> hackage.haskell.org
22:35:05 <mmorrow> f_Bar = \n_0 -> (n_0 :: GHC.Types.Double) GHC.Num.+ pi
22:35:05 <jml> hello
22:35:09 <Megzlna> but where was f?
22:35:13 <sjanssen> wli: both of those are on hackage, actually
22:35:20 <mmorrow> (i think, you could get the pi to expand though if you wanted)
22:35:21 <dons> jml: hello!
22:35:26 <dons> welcome.
22:35:29 <jml> thanks. :)
22:35:35 <mmorrow> Megzlna: i just created that name
22:35:47 <wli> Looking.
22:35:52 <dons> jml: learning haskell?
22:35:59 <mmorrow> , (\uniq -> mkName ("f_"++uniq)) "Bar"
22:36:00 <jml> dons: slowly :)
22:36:01 <lunabot>  f_Bar
22:36:14 <dons> jml: awesome. well, feel free to ask questions and soak up the lambdas
22:36:28 <jml> dons: :)
22:36:44 <Megzlna> mmorrow: What about encoding the Int and 42 in ?
22:36:54 <mmorrow> Megzlna: and (in a different module) you'd splice that decl inj at the top level by just doing:
22:36:54 <jml> so, actually, I'm implementing a network protocol in haskell, mostly for my own education.
22:37:09 <mmorrow> $(foo "Bar" [t|Int|] [|42|])
22:37:12 <dons> oh nice. which protocol?
22:37:23 <dons> and i hope you're planning to release it on hackage :)
22:37:28 <jml> I'm up to the bit where I'm thinking, gosh, I need a state machine to parse these incoming bytes.
22:37:43 <dons> are you using something like Data.Binary to parse input?
22:37:46 <jml> dons: AMP, it's a generic-ish protocol developed by the Twisted community.
22:37:47 <Megzlna> mmorrow: What does the \n_0 correspond to?
22:37:57 <Megzlna> Int ?
22:37:59 <mmorrow> Megzlna: i spliced those in in the inner [| .... |]  with    [| ... $( ... in here ... )  .. or ... $here ... |]
22:38:00 <dons> maybe a parser combinator library?
22:38:10 <wli> I don't see interval trees.
22:38:15 <jml> well, mostly what I want is to see an example.
22:38:20 <dons> wli, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/AvlTree ?
22:38:25 <mmorrow> Megzlna: the same thing as "x" in (\x -> x + 1)
22:38:27 <dons> jml: of stateful parsing?
22:38:34 <jml> dons: right. I mean, even something that took in bytes and generated lines would be interesting to me.
22:38:44 <sjanssen> wli: called Ranged-sets
22:38:52 <dons> lines as in structured data broken on \n ?
22:38:55 <sjanssen> wli: at least I think that's supposed to be an interval tree
22:39:09 <Megzlna> mmorrow: Where did the [t|Int|] get iinserted ?
22:39:13 <mmorrow> Megzlna: i just used a lambda because it happened to be more convenient than doing "f_Bar n = ... "
22:39:19 <Megzlna> ah
22:39:20 <mmorrow> , src 'SigE
22:39:23 <jml> dons: basically, yes.
22:39:26 <lunabot>  data Exp = ... | SigE Exp Type | ...
22:39:26 <lunabot>  infixl 9
22:39:29 <Megzlna> sigE
22:39:32 <dons> ok. some simple examples. gimme a sec.
22:39:37 <Megzlna> mmorrow: Can you stringize the 'Int' ?
22:39:40 <wli> sjanssen: Checking.
22:39:40 <Megzlna> is that possible
22:39:41 <Axman6> mmorrow: that's nice src output :)
22:39:42 <jml> dons: I don't know what your Python is like, but something like http://paste.ubuntu.com/84235/
22:39:42 <mmorrow> , [$ty| sigE |]
22:39:48 <lunabot>  ExpQ -> TypeQ -> ExpQ
22:39:59 <Megzlna> is  f_Bar_Int_42 possible?
22:40:00 <mmorrow> Axman6: :)
22:40:12 <dons> oh, just splitting lines?
22:40:15 <mmorrow> Megzlna: sure, you can call it whatever you want
22:40:25 <jml> dons: no, that's not quite the same thing.
22:40:25 <Megzlna> mmmorrow: But by parsing "Int"
22:40:30 <Megzlna> on your template parameter
22:40:32 <mmorrow> , ''Int
22:40:35 <jml> because you get data in dribs and drabs :)
22:40:35 <lunabot>  GHC.Types.Int
22:40:43 <mmorrow> , nameBase ''Int
22:40:46 <mmorrow> :: Striong
22:40:46 <lunabot>  "Int"
22:40:48 <Megzlna> nameBase!
22:40:52 <Megzlna> lol
22:41:00 <mathy> Hi, I wish to invocate a function 'infinite' times in order to produce an infinite list, how can I do that?
22:41:05 <mmorrow> , nameBase ''Data.Tree.Tree
22:41:07 <sjanssen> jml: if you've got a Handle, you could just use hGetLine and let Handle buffering take care of it
22:41:08 <lunabot>  "Tree"
22:41:24 <jml> sjanssen: that's good to know.
22:41:30 <sjanssen> > iterate (+1) [0 ..]
22:41:32 <lambdabot>       No instance for (Num [t])
22:41:32 <lambdabot>        arising from the literal `1' at <inter...
22:41:41 <sjanssen> > iterate (+1) 0 -- like this, mathy?
22:41:43 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
22:41:46 <Megzlna> mmorrow: This really does almost do it...
22:41:46 <wli> sjanssen: Ranged sets is it.
22:41:49 <mathy> Oh, I see, just ..
22:41:49 <jml> sjanssen: although I'm actually more interested in *how* that would be implemented, so I can learn about stateful parsers in haskell.
22:41:57 <mmorrow> Megzlna: so how you get the Name of an identifier is either
22:41:57 <Axman6> > let f x  = f : f x in f 1
22:41:58 <lambdabot>       Occurs check: cannot construct the infinite type: t = [t1 -> t]
22:41:59 <lambdabot>        ...
22:42:00 <mmorrow> , 'fmap
22:42:03 <lunabot>  GHC.Base.fmap
22:42:04 <erikc> hrm, i cant figure out how to make this rule with parsec at all, i want to say 'many foo' where foo is all characters until a #{ sequence is reached
22:42:05 <mmorrow> (if it's not a type)
22:42:05 <Axman6> > let f x  = x : f x in f 1
22:42:06 <mmorrow> or
22:42:07 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
22:42:11 <mmorrow> , ''()
22:42:14 <lunabot>  GHC.Unit.()
22:42:15 <mmorrow> if it's a type
22:42:17 <jml> actually, that leads me to another question.
22:42:19 <Axman6> > let f x  = x : f x in f ' '
22:42:21 <lambdabot>   "                                                                          ...
22:42:25 <Megzlna> mmorrow: But... [|42|] has no parameter name
22:42:25 <mmorrow> one ', or two ''
22:42:30 <dons> jml: http://hpaste.org/12993
22:42:32 <jml> hmm, no, wait, dpkg can answer that one for me.
22:42:32 <Megzlna> and same for [t|Int|]
22:42:33 <mmorrow> it's an expression
22:42:35 <Axman6> mwahaha! invisible result!
22:42:41 <dons> simple example using bytestrings to read input lazily
22:42:41 <Megzlna> how can [t|Int|] be 'X' ?
22:42:43 <mmorrow> , [t|Int|]
22:42:46 <lunabot>  ConT Int
22:42:46 <dons> it'll block waiting on data to arrive
22:42:55 <mmorrow> , ConT (mkName "Int")
22:42:57 <lunabot>  ConT Int
22:43:09 * wli is clueless as to how to install a cabal pkg on Windows.
22:43:10 <dons> jml: the Data.Binary package provides precise low level byte and bit parsing
22:43:16 <dons> so suitable and common for network stuff
22:43:23 <Megzlna> mmorrow: lets look at original interface for a sec
22:43:25 <dons> but you might be ok with just lazy IO and bytestrings for now
22:43:32 <Megzlna> param_class [|.|class X|type N|N n|] { f :: (X a) => a -> a; f x = x + n }
22:43:37 <Axman6> erikc: i'd like to see how you go if you get it, looks like something i'd need for hacports to parse portfiles :)
22:43:40 <mmorrow> so you could alternatively either (1) take a Name as a param instead, or (2) do ConT name <- [t|Int|]; ....
22:44:02 <mmorrow> , do ConT name <- [t|Int|]; return (nameBase name)
22:44:06 <lunabot>  Int
22:44:20 <erikc> axman6: im just writing my own, its annoying that i can write the parser states out on paper but cant figure out how to get parsec working on em :)
22:44:23 <Megzlna> so how would the param_class there be changed?
22:44:38 <mmorrow> (bear in mind that pattern match doesn't take into account all of the possibilities, so you'd probably want to do that or something)
22:44:56 <Axman6> erikc: yeah i need to get into parsec sometime. don't really want to, but kind of need to if i want to get this hacports thing started :\
22:44:59 <Megzlna> param_class ConT X<-[t|class|]   -- highly invalid ;)
22:45:05 <erikc> im making a ruby string interpolation quasiquoter so i can do [$rubystr| yay the value of v is #{v} and the value of a+b is #{a+b}|]
22:45:12 <mmorrow> Megzlna: but at this point the class is irrelevant, because we already know the type
22:45:27 <mmorrow> (because it's explicitly passed in)
22:45:29 <Megzlna> mmorrow: We were explicitly passing 'X'
22:45:36 <Megzlna> because the function 'f' was a throwaway function
22:45:38 <Megzlna> just for example
22:45:44 <Megzlna> it could have been something more useful
22:45:52 <wli> sjanssen: Well, I found it, I'm now blocked on how to install cabal stuff on Windows.
22:46:01 <mmorrow> @type (\n -> (n::Int) + 1) :: (Num a) => a -> a
22:46:02 <lambdabot>     Couldn't match expected type `Int' against inferred type `a'
22:46:02 <lambdabot>       `a' is a rigid type variable bound by
22:46:02 <lambdabot>           the polymorphic type `forall a. (Num a) => a -> a'
22:46:07 <mmorrow> ^^^
22:46:12 <dons> erikc: sounds usefull
22:46:40 <erikc> yup, i'll upload when im done, it will make my lua code generator very pretty :)
22:46:47 <Megzlna> mmorrow: ah
22:46:50 <sjanssen> wli: runghc Setup {configure,build,install} doesn't work?
22:46:54 <erikc> and then ill package up my dwarf parser, elf parser went up yesterday
22:47:30 <Megzlna> mmorrow: so how about
22:47:43 <Megzlna> param_class [|.|class X|n|]
22:47:44 <quicksilver>  /win 26
22:47:56 <Megzlna> no 'Int'
22:48:01 <wli> sjanssen: I'm at a loss to get started on that.
22:48:06 <mathy> What's the difference between:   filter (predicate) (map _fib [0 .. ])    and filter (predicate) . map _fib [0 .. ]
22:48:11 <Axman6> , $((tupleReplicate 10) 'a')
22:48:14 <mmorrow> Megzlna: yes, that'd work (and we don't even have to change any of the code from that example). Just do:
22:48:14 <lunabot>  luna: Not in scope: `tupleReplicate'
22:48:31 <mmorrow> $(foo "Bar" [t|forall a. Num a => a|] [|42|])
22:48:41 <sjanssen> wli: sorry, I don't actually use Windows
22:48:57 <Megzlna> mmorrow: it has to make a unique type called
22:49:13 <wli> sjanssen: Neither do I. :(
22:49:34 <Megzlna> f_Bar_"foralla.Numa=>a"_42
22:49:55 <Megzlna> none of the params can be discarded in the identity
22:50:03 <mmorrow> do you really mean "type" there?
22:50:13 <Megzlna> s/type/function signature/
22:50:17 <Megzlna> errr
22:50:22 <Megzlna> s/type/function NAME/
22:50:26 <Megzlna> or other encoding thereof
22:51:16 <mmorrow> ok, so you could just have some hash function of something (point being some way to take arbitrary txt that'd be in a type name to a valid identifier name) and append that to "f_"
22:51:37 <Megzlna> isnt the 'forall a.' default ?
22:51:39 <Megzlna> in GHC anyways
22:51:50 <mmorrow> , [t|Num a => a|]
22:51:53 <lunabot>  ForallT [a_0] [AppT (ConT Num) (VarT a_0)] (VarT a_0)
22:51:58 <mmorrow> interesting
22:52:04 <mmorrow> , [t|Maybe a|]
22:52:06 <lunabot>  luna: Not in scope: type variable `a'
22:52:17 <mmorrow> i guess the class constraint serves to bind the "a"
22:52:24 <mmorrow> good to know :)
22:52:36 <mmorrow> , [t|forall a. Maybe a|]
22:52:38 <lunabot>  ForallT [a_0] [] (AppT (ConT Maybe) (VarT a_0))
22:53:09 <mmorrow> Megzlna: look at the Language.Haskell.TH.* haddocks to get going
22:53:19 <Megzlna> mmorrow: How do you remove the hardcoded 'foo' ?
22:53:25 <Megzlna> so that it takes a block
22:53:41 <Megzlna> { f :: (X a) => a -> a; f x = x + n }
22:53:45 <Megzlna> where 'X' is replaced
22:54:06 <Megzlna> hence you dont need 'Num a => a'
22:54:16 <Megzlna> only X
22:54:23 * Axman6 likes Num a => a :(
22:54:24 <mmorrow> the way to figure out what you have to build is to let TH show you. like:
22:54:28 <mmorrow> (in ghci)
22:54:43 <Megzlna> But the pattern doesnt involve manual building
22:54:44 <mmorrow> runQ [d| f :: (Num a) => a -> a; f x = x + n |]
22:54:48 <mathy> What's the difference between:   filter (predicate) (map _fib [0 .. ])    and filter (predicate) . map _fib [0 .. ]
22:54:52 <mmorrow> , [d| f :: (Num a) => a -> a; f x = x + n |]
22:54:53 <Megzlna> it has to somehow take the {   } block or a where clause
22:54:55 <lunabot>  SigD f (ForallT [a_0] [AppT (ConT Num) (VarT a_0)] (AppT (AppT ArrowT (Va...
22:54:55 <lunabot>  FunD f [Clause [VarP x_1] (NormalB (InfixE (Just (VarE x_1)) (VarE +) (Ju...
22:54:56 <Megzlna> or some other enclosure
22:55:01 <Megzlna> that'd work
22:55:09 <mathy> I thought . effectively executed its right-most function and passed output to the one of the left, alike the bracketing
22:55:13 <mmorrow> you'd have to build what just was outputted (one way or another)
22:55:46 <smarmy> Megzlna: you're trying to parameterize the Num class, but there is a dependence on it in the function body
22:56:00 <Megzlna> , [d| f :: (X a) => a -> a |]
22:56:02 <lunabot>  luna: The type signature for `f' lacks an accompanying binding
22:56:10 <wli> sjanssen: I don't think the runghc sequence worked.
22:56:22 <Megzlna> , [d| f :: (X a) => a; f = 1 |]
22:56:25 <lunabot>  luna: Not in scope: type constructor or class `X'
22:56:32 <Megzlna> Thats the problem
22:56:39 <Megzlna> how do you leave 'X' as undefined
22:56:45 <mmorrow> using TH sucks at first because trying to do even the littlest thing turns into an epic, but once you memorize all the constructors of the various AST dataypes and start to see what's happening by copious messing around in ghci it's friggin great
22:57:05 <mmorrow> i think you just have to mess around in ghci at this point
22:57:34 <mmorrow> Megzlna: you can't leave the "X" as "undefined"
22:57:43 <Megzlna> lol i gotta finish learning newb Haskell, I just started a few days ago ;/
22:58:07 <Axman6> TH is not something for noobs to be playing with imo
22:58:19 <Megzlna> Axman6: Unless you're a SuperNewb
22:58:22 * Megzlna is SuperNewb
22:58:42 <mmorrow> if splicing types into decl brackets (or any brackets for that matter) were supported, it'd be a hell of a lot easier to replace that "X"
22:58:56 <mmorrow> but at the moment you have to do it the hard way
22:59:00 <Axman6> i'd suggest you try getting some experience with Haskell, then come back to this TH stuff
22:59:08 <Megzlna> mmorrow: so you pass it in a [t| |] instead?
22:59:15 <Megzlna> can you convert [t| |] to [d| |] ?
22:59:33 <mmorrow> welll you'd do that either way, the "hard way" is having to explicitly construct the code with the AST
22:59:46 <Megzlna> but the X is still a prob.
22:59:57 <mmorrow> the X wouldn't ever actually be there
23:00:05 <mmorrow> just a "hole"
23:00:09 <Megzlna> mmorrow: You need to put the X for the end user
23:00:13 <Megzlna> to use it easily
23:00:17 <mmorrow> which you'd plug the [t|Num a|] into
23:01:04 <mmorrow> Megzlna: i dunno what to tell you :)
23:01:08 <Megzlna> i think as many [t|'s should be avoided as possible
23:01:22 <mathy> Somebody please help :(
23:01:24 <Megzlna> since you need no 'a'
23:01:25 <mathy> What's the difference between:   filter (predicate) (map _fib [0 .. ])    and filter (predicate) . map _fib [0 .. ] ?
23:01:44 <dolio> mathy: The first is right, the second is wrong.
23:01:46 <Megzlna> mmorrow: Ok, thx :P
23:01:47 <smarmy> mathy: the latter isn't valid
23:01:59 <mmorrow> Megzlna: yeah, there'd be some things to work out/iron out etc.
23:02:03 <mmorrow> Megzlna: np :)
23:02:22 <Megzlna> mmorrow: I'll have much better / more specific TH questions
23:02:23 <mathy> smarmy: but why is it not valid?  Doesn't it simply compose output to have the map output to go to the filter ?
23:02:35 <Axman6> :t filter (predicate :: a -> Bool) (map (_fib::Num b => b - ) [0 .. ])
23:02:36 <lambdabot> parse error on input `-'
23:02:40 <Axman6> :t filter (predicate :: a -> Bool) (map (_fib::Num b => b -> a ) [0 .. ])
23:02:42 <lambdabot> Not in scope: `predicate'
23:02:42 <lambdabot> Not in scope: `_fib'
23:02:43 <smarmy> filter
23:03:14 <smarmy> filter predicate . map _fib $ [1..10]
23:03:28 <Megzlna> , [t| f :: (X a) => a; f = 1 |]
23:03:30 <Axman6> mathy: usually if you compose functions, you's either do f.g.h $ x or (f.g.h) x. they're the same thing, the $ just saves a (
23:03:30 <lunabot>  luna: parse error on input `::'
23:03:45 <mmorrow> Megzlna: just check out the haddocks and start experimenting. also, take a look at the source to Language.Haskell.TH.Syntax (for the comments) and read a bunch of TH papers
23:03:49 <Megzlna> mmorrow: Which one consumes the most freely?
23:04:07 <Megzlna> d typechecks, t only takes tokens
23:04:20 <Megzlna> what's the free-est one
23:04:24 <mmorrow> what if "consumes the most freely"
23:04:27 <mmorrow> oh, err
23:04:46 <mmorrow> [d| .. declaration .. |] , [t| .. type .. |], [| .. expression .. |]
23:05:02 <mmorrow> where decl/type/exp are defined as in Language.Haskell.TH.Syntax
23:05:14 <mmorrow> you really need to read some stuff at this point
23:05:15 <mathy> Axman6: I might be confusing the purpose of .  Doesn't a . b c effectively mean a (b c) ?
23:05:25 <mathy> Axman6: documentation makes it look like $ does that
23:05:28 <Axman6> mathy: not really
23:05:30 <smarmy> mathy: no
23:05:30 <Megzlna> mmorrow: Wanna pass a string but not quoted and fake it looking like a [| block -- possible?
23:05:38 <Axman6> @src (.)
23:05:38 <lambdabot> (f . g) x = f (g x)
23:05:42 <Axman6> @src ($)
23:05:43 <lambdabot> f $ x = f x
23:05:51 <smarmy> mathy: a (b c) computes the value of b c, and feeds it to a
23:06:13 <mmorrow> Megzlna: not without parsing it to the TH AST, but you're in luck ;)  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskell-src-meta
23:06:18 <smarmy> mathy: a . b c assumes that a and b c are functions, and composes them into a new function
23:06:20 <mathy> smarmy: yeah, got that much, I unfortunately thought that use of . (alternatively to bracketing) did that
23:06:25 <mathy> oh
23:06:26 <smarmy> mathy: which still expects a value
23:06:26 <Megzlna> oh goodness
23:06:27 <Axman6> :t f . g x
23:06:28 <lambdabot>     Ambiguous type variable `b' in the constraints:
23:06:28 <lambdabot>       `SimpleReflect.FromExpr b'
23:06:28 <lambdabot>         arising from a use of `g' at <interactive>:1:4-6
23:06:32 <Axman6> bah
23:06:41 <Megzlna> exactly what I needed:  "Parse source to template-haskell abstract syntax"
23:06:47 * Megzlna got's problems by the number
23:06:49 <Megzlna> lol
23:06:49 <mmorrow> very handy :)
23:06:56 <smarmy> mathy: a . b $ c is the same as a (b c), but a . b c is not
23:07:14 <mmorrow> ok, i've gotta step away. good luck :)
23:07:17 <Megzlna> mmorrow: Does this imply preprocessing?
23:07:18 <Megzlna> k
23:07:30 <mmorrow> there are functions like
23:07:34 <Axman6> (a.b) c is the same as a (b c)
23:07:37 <mmorrow> parseExp :: String -> Either String Exp
23:07:40 <mmorrow> parseDec
23:07:41 <mmorrow> ...
23:07:46 <Axman6> :t (.)
23:07:48 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
23:07:49 <Axman6> :t ($)
23:07:50 <lambdabot> forall a b. (a -> b) -> a -> b
23:07:51 <mmorrow> Left "some error"
23:07:52 <mathy> The actual functioning of . confuses me now
23:08:01 <Megzlna> k
23:08:09 <Axman6> mathy: yeah, me too, you just get used to it :0
23:08:11 <Megzlna> mmorrow: thanks
23:08:11 <Axman6> :)*
23:08:40 <mathy> a $ b c   -- is this a (b c) ?
23:08:53 <smarmy> mathy: (.) composes two functions into a new one.  given a f :: a -> b, and g :: b -> c, then g . f :: a -> c.  in other words (.) build a new function with f and g, that takes an a, feeds it to f, takes the resulting b and feeds it to g, then returns a c
23:09:51 <mathy> smarmy: aha, gotcha
23:09:58 <smarmy> mathy: so a . b c is really a . (b c) due to precedence rules.  for (.) to work, a must be a function, and (b c) must be a function.  this would mean that b is a binary function, taking two values
23:10:27 <Axman6> mathy: you can think of $ as bracketing all the stuff to the right of it up. so f $ g x y == f (g x y), f $ g x $ h y == f (g x (h y)) etc
23:10:38 <mathy> Beauty :)
23:11:00 <Axman6> hmm, that made it a lot clearer for me too :)
23:11:54 <Axman6> mathy: generally, when you're using (.) you'll do something like sum . map f . replicate n $ x, which is the same as (sum . map f . replicate n) x
23:12:20 <smarmy> best to use parens at first and learn the semantics.  then use $ to cheat once you're familiar
23:12:54 <Axman6> yeah, sounds about right
23:13:43 <mathy> btw, is there any way of making numbers look nicer in Haskell, e.g. in Perl you can use 2_000_000 ?
23:13:59 <smarmy> mathy: i rather like them in their birthday suite
23:14:00 <Axman6> not that i know of
23:14:11 <smarmy> s/suite/suit/
23:14:34 <dons> mathy: not built into the language.
23:15:24 <mathy> sum $ filter (even) $ map _fib [0 .. 4000000 ] -- think this should work alright :)
23:15:36 <Megzlna> dons: I screwed something up.
23:15:41 <Axman6> > sum $ filter (even) $ map _fib [0 .. 4000000 ]
23:15:43 <lambdabot>   Not in scope: `_fib'
23:15:43 <mathy> But due to lack of memoization, it'll take some time!
23:16:05 <smarmy> mathy: map fib xs is probably a slow way to get the desired effect ;)
23:16:19 <Megzlna> When detaching my #Haskell window, I lost the log of the last few hours. What was the module / paper you said to use for nontype specialization on 'f' signatures ?
23:16:21 <mathy> smarmy: ooh, what's a better way?
23:16:34 <Axman6> _fib, is that even allowed as a function name?
23:16:59 <mmorrow> , let fib m n = m : fib n (m+n) in fib 0 1
23:17:04 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
23:17:06 <smarmy> mathy: off the top of my head, build a fib that returns the list, rather than recomputing fib for every possible n
23:17:06 <Axman6> Megzlna: /topic
23:17:09 <mathy> Axman6: it is, yes - I used _ as a notation to indicate that it's an internal function to not be invocated by the user (it'll be used interactively)
23:17:28 <Axman6> mathy: f' is probably more common
23:17:43 <Megzlna> heh those logs probably dont get created for a while
23:17:45 <Axman6> say f x = f' x 0 where f' x n = ...
23:17:55 <helgi> I then have a question: (i(o(q(2)))) is equal to $i.o.q $ 2 ? I would've thought it'd turn out as (i.o.q(2))
23:17:59 <mathy> Axman6: though ' often implies change, and this isn't necessarily differentiated
23:18:01 <Axman6> Megzlna: they're very up to date in my experience
23:18:19 <mmorrow> yeah, only a minute or two lag tops
23:18:29 <Megzlna> I'm terrified of logs
23:18:36 <Axman6> helgi: (i.o.q) 2
23:19:02 <smarmy> mathy: it's often used as "next iteration", which fits that usage in an abstract way
23:19:03 <mmorrow> 23:18:29 <Megzlna> I'm terrified of logs
23:19:03 <mmorrow> 23:18:36 <Axman6> helgi: (i.o.q) 2
23:19:06 <helgi> that doesn't run, while $i.o.q $ 2 does
23:19:06 <mmorrow> (from the logs)
23:19:09 <Megzlna> k
23:19:13 <pumpkin> mathy: there are some "public" functions that have _ in them
23:19:21 <pumpkin> (suffixes)
23:19:21 <mathy> smarmy: hmm, indeed, that'd be _much_ quicker.
23:19:23 <Megzlna> the problem with logs is people figure out what your nick is
23:19:55 <mathy> pumpkin: I come from a Perl background, so I'm used to the convention of using _ as a /prefix/ to indicate that it is only for internal use
23:20:02 <pumpkin> ah
23:20:18 <dons> Megzlna: constructor specialisation
23:20:21 <dons> http://tunes.org/~nef/logs/haskell/08.12.11
23:20:22 <Axman6> mathy: f' is more common in haskell, that's all i'm saying
23:20:28 <Megzlna> dons: I got it
23:20:29 <Megzlna> {-# SPECIALIZE f :: Int -> Int #-}
23:20:43 <Megzlna> thx
23:21:11 <Axman6> ghc: panic! (the 'impossible' happened)
23:21:11 <Axman6>   (GHC version 6.10.1 for i386-apple-darwin):
23:21:11 <Axman6> 	RegAllocLinear.getStackSlotFor: out of stack slots, try -fregs-graph
23:21:11 <dons> oh, that's just the specialise pragma
23:21:16 <Axman6> oh noes :(
23:21:26 <Axman6> trying to install crypto
23:21:33 <Megzlna> dons; 2 separate things?
23:21:35 <dons> Megzlna: http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#specialize-pragma
23:21:38 <mathy> Axman6: do you know how I might be able to print out each returned value of the map in filter (even) $ map _fib [0 .. 4000000 ] ?
23:21:50 <mathy> Axman6: this is a long process and seeing progress would be nice :p
23:21:57 <mmorrow> Axman6: maybe edit the .cabal to be less aggressive with ghc optim flags?
23:22:03 <dons> Megzlna: the one based on values, http://research.microsoft.com/en-us/um/people/simonpj/papers/spec-constr/index.htm
23:22:14 <Megzlna> thanks, now heres the funny part
23:22:17 * Axman6 removes -O2 from the command line
23:22:27 <mmorrow> oh noes, don't do that :)
23:22:35 <mmorrow> are there any other ones?
23:22:37 <Axman6> Megzlna: you really have been trolling us for the last 3 hours? :)
23:22:42 <Axman6> i kid ;)
23:22:52 <mmorrow> if -O2 is doing that you've got problems :)
23:22:53 <dons> note you can specialize instances
23:22:54 <dons> instance (Eq a) => Eq (Foo a) where {  {-# SPECIALIZE instance Eq (Foo [(Int, Bar)]) #-}
23:23:01 <Megzlna> I talk to people on Haskell, they tell me haskell cannot do it, the way the type system works can't support multiple sigs, etc
23:23:07 <Megzlna>  s/Haskell/#Haskell/
23:23:08 <mathy> How could I print out each returned value of the map in:  filter (even) $ map _fib [0 .. 4000000 ] ?
23:23:08 <Axman6> Megzlna: well i'l see how no -O2 goes
23:23:11 <dons> Megzlna: you just use weird terminology
23:23:16 <Megzlna> And then, I see this
23:23:19 <dons> and gave us a dozen concepts with unusual syntax.
23:23:27 <Megzlna> dons: not tonight
23:23:29 <dons> so it was hard to work out what precise language features you needed
23:23:34 <Megzlna> 2 days back
23:23:43 <Megzlna> I was saying I really really needed f_Int to get generated
23:23:46 <Axman6> mathy: map print might do it...
23:23:51 <Megzlna> "noooooooooooooooooooo!"
23:23:53 <Megzlna> lol.
23:24:02 <smarmy> mathy: print $ filter (even) $ map _fib [0 .. 4000000]
23:24:16 <sjanssen> Megzlna: the problem with your question is "_Int"
23:24:16 <dons> the bit about requiring a callable f_Int function (i.e. that name) is very unhaskell
23:24:21 <Axman6> Megzlna: the problem is that GHC does that for you
23:24:23 <dons> we'd just let the compiler call f :: Int
23:24:35 <dons> so people freak that you'd want to break the automation
23:24:45 <mathy> smarmy: cool, thanks.  Out of interest, how could I have it print specifically for every map, instead of just every filtered result?
23:25:02 <smarmy> mathy: print $ map _fib [0 .. 4000000]
23:25:11 <dons> so cultural issues :)
23:25:43 <mathy> smarmy: oh no, what I'm trying to get at is that I'd like to preserve the algorithm, but output progress
23:25:47 <smarmy> mathy: it only gets hard when you want to compute the answer and use it elsewhere while at the same time printing results
23:26:07 <mathy> yeah
23:26:16 <mathy> fib :: Int           fib = sum $ filter (even) $ map _fib [0 .. 4000000 ]
23:26:33 <mathy> Somehow gotta print each map whilst using its return value.. maybe I need do { }
23:26:42 <Megzlna> did you guys ever write a GHC extension?
23:27:06 <pumpkin> :o
23:28:02 <mathy> http://pastebin.com/d595d4dcc -- couldn't I achieve something like this?
23:28:09 <mathy> Unfortunately that type errors
23:28:25 <smarmy> mathy: you need a fib in the IO monad. not hard, but maybe a brain bender if you're just learning
23:29:19 <mathy> smarmy: most of my haskell experience is really with primitive recursion.  I'm learning a few funkier syntaxes etc. right now, but don't have much IO experience or monad experience
23:29:22 <smarmy> mathy: no.  you need to propogate the monad in both directions.  down into the map and up to encompass filter and sum
23:29:55 <smarmy> mathy: once you're in IO, you're stuck there.  passing a computation in the IO monad to a pure function to be evaluated is (usually) a no no
23:30:53 <mathy> ooh
23:31:17 <mmorrow> has anyone used TIMBER?
23:31:27 <mathy> smarmy: could you possibly show me a piece of example code which achieves what I need (assuming it's short & sweet for someone who knows what they're doing)?
23:31:45 <mathy> Or just something that indicates the syntax or such
23:34:29 <jsn> @msg roconnor thanks for your discussion earlier, i will look over the slides
23:34:30 <lambdabot> Not enough privileges
23:34:42 <smarmy> mathy: take a look (sorry... forgot it erases existing text)
23:34:46 <mmorrow> awesome, another ELF parser: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/elf
23:34:46 <jsn> @message roconnor thanks for your discussion earlier, i will look over the slides
23:34:47 <lambdabot> Maybe you meant: messages messages?
23:35:04 <jsn> lambdabot: help
23:35:13 <jsn> @help
23:35:13 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:35:28 <pumpkin> you're looking for @tell I think
23:35:30 <smarmy> mathy: that's just fib.  filter and sum need to be encompassed by the monad as well
23:35:42 <jsn> @tell roconnor thanks for your discussion earlier, i will look over the slides
23:35:43 <lambdabot> Consider it noted.
23:35:48 <jsn> pumpkin: thank you
23:35:52 <pumpkin> :)
23:37:42 <smarmy> mathy: map would just become mapM, so the next level up is easy.  there's a filterM too, but the predicate has to change a wee bit
23:38:08 <mathy> smarmy: hmm, is it not possible to integrate a print into my already existing code, though?
23:39:25 <smarmy> mathy: sure it is.  i've been shortcutting, but we can work out a specific example.  at what level exactly do you want data printed?
23:40:05 <mathy> Sorry, what you mean by level?
23:40:18 <mathy> All I know is that I need each return value of the map to be printed
23:40:38 <Axman6> ok, i'm not happy, i can't get crypto installed at all with cabal-install
23:43:17 <thoughtpolice> ghc 6.10?
23:43:17 <lambdabot> thoughtpolice: You have 1 new message. '/msg lambdabot @messages' to read it.
23:43:22 <smarmy> mathy: so i posted the simplest method.  it doesn't change the code, but requires you to break up the outer function into two steps in main
23:43:22 <Axman6> yep
23:43:23 <ziman> mathy, how about: print $ map _fib [0 .. 4000000 ] ?
23:43:28 <thoughtpolice> only problem I remember having is that the compiler craps out on one of the test executables
23:43:35 <thoughtpolice> since it stresses the register allocator pretty bad apparently
23:43:59 <thoughtpolice> but it compiles the library fine, you may have to download and manually change the cabal file to not include the executables, though
23:44:21 <Axman6> ziman: he wants to sum the result after the map bit
23:44:31 <Axman6> but watch the progress of map _fib
23:45:12 <smarmy> Axman6: yeah... that's pretty brutal ;)
23:45:54 <mathy> Oh, and sorry for all the questions smarmy, but have you any thoughts as to how I could implement that optimization you mentioned?
23:46:12 <smarmy> mathy: someone was already kind enough to post it earlier
23:46:33 <ziman> i think `progress' is a ridiculous concept in pure haskell; however, you can still do let mapped = map _fib [0 .. 4000000 ] in print mapped >> print sum . filter even $ mapped
23:47:07 <Axman6> > let fibs = 1:1:[fibs !! n-2 + fibs !! n-1|n<-[2..]] in fibs
23:47:14 <smarmy> mathy: morrow had it: let fib m n = m : fib n (m+n) in fib 0 1
23:47:23 <lambdabot>   thread killed
23:47:39 <Axman6> > let fibs = 1:1:[(fibs !! (n-2)) + (fibs !! (n-1))|n<-[2..]] in fibs
23:47:41 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
23:47:47 <Axman6> > let fibs = 1:1:[(fibs !! (n-2)) + (fibs !! (n-1))|n<-[2..]] in fibs !! 1000
23:47:49 <lambdabot>   703303677114228158218352548771835497701812698363587327426049050871545371181...
23:47:54 <Axman6> > let fibs = 1:1:[(fibs !! (n-2)) + (fibs !! (n-1))|n<-[2..]] in fibs !! 5000
23:47:56 <lambdabot>   627630280048895708603525310834968405547852870273645743902582444892793725681...
23:48:02 <Axman6> > let fibs = 1:1:[(fibs !! (n-2)) + (fibs !! (n-1))|n<-[2..]] in fibs !! 40000
23:48:07 <pumpkin> o.O
23:48:17 <lambdabot>   thread killed
23:48:18 <Axman6> hmm, that seems to be semi efficient...
23:48:25 <Axman6> > let fibs = 1:1:[(fibs !! (n-2)) + (fibs !! (n-1))|n<-[2..]] in fibs !! 10000
23:48:30 <lambdabot>   544383731135652813387342609937503801353891845546959670262477158412085828656...
23:48:34 <smarmy> > let fib m n = m : fib n (m+n) in fib 0 1
23:48:36 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
23:49:00 <smarmy> mathy: do you see why your current implementation is slow?
23:49:34 <Axman6> > let fibs = 1:1:[(fibs !! (n-2)) + (fibs !! (n-1))|n<-[2..]] in fibs !! 20000
23:49:43 <lambdabot>   409550667084212509197492036759335074992840743265840116213317525939589358561...
23:50:14 <Axman6> > let fibs = 1:1:[(fibs !! (n-2)) + (fibs !! (n-1))|n<-[2..]] in filter even.take 40000 $ fibs
23:50:16 <lambdabot>   [2,8,34,144,610,2584,10946,46368,196418,832040,3524578,14930352,63245986,26...
23:50:25 <Axman6> > let fibs = 1:1:[(fibs !! (n-2)) + (fibs !! (n-1))|n<-[2..]] in sum . filter even.take 40000 $ fibs
23:50:30 <mmorrow> haha, http://bitworking.org/projects/critters/
23:50:40 <lambdabot>   thread killed
23:50:48 <Axman6> > let fibs = 1:1:[(fibs !! (n-2)) + (fibs !! (n-1))|n<-[2..]] in sum . filter even.take 4000 $ fibs
23:50:51 <lambdabot>   322874422454740867656884745076847978222069503200756713542037887990886051795...
23:51:13 <jml> ok. I think I'm getting Data.Binary
23:51:49 <mmorrow> , fix ((0:) . scanl (+) 1)
23:51:51 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
23:52:02 <Axman6> mmorrow: yuck
23:52:10 <jml> but I still am not sure how I'd build a stateful parser out of same
23:52:20 <mmorrow> yuck? that's one of my favorites! ;)
23:52:45 <smarmy> yeah, that's pretty slick actually
23:52:58 <Axman6> :t ((0:) . scanl (+) 1)
23:52:59 <lambdabot> forall a. (Num a) => [a] -> [a]
23:53:09 <Axman6> :t (scanl (+) 1)
23:53:11 <lambdabot> forall a. (Num a) => [a] -> [a]
23:53:19 <jml> hmm
23:53:22 <Axman6> > (scanl (+) 1) [1]
23:53:24 <lambdabot>   [1,2]
23:53:27 <Axman6> > (scanl (+) 1) [0]
23:53:29 <lambdabot>   [1,1]
23:53:50 <mmorrow> , fix (scanl (+) 1)
23:53:52 <lunabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,13107...
23:53:59 <mmorrow> , fix ((1:) . scanl (+) 1)
23:54:01 <lunabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
23:54:11 <Axman6> mathy: i just tried running sum . filter even . take 40000 $ fibs in ghci with my definition of fibs, and it takes seconds :)
23:55:50 <mmorrow> , foldl' (+) 0 . filter even . take 40000 $ let fib m !n = m : fib n (m+n) in fib 0 1
23:55:53 <lunabot>  1158997879999727672946417013062336891791160667328280503727448433093874774...
23:56:21 <mmorrow> , foldl' (+) 0 . filter even . take 400000 $ let fib m !n = m : fib n (m+n) in fib 0 1
23:56:28 <lunabot>  Killed.
23:56:39 <Axman6> death
23:56:41 <mmorrow> heh, got too greedy there :)
23:57:02 <mmorrow> "ooh, maybe 10x as many'll work!!@"
23:57:29 <Axman6> > let fibs = 1:1:[let l = (fibs !! (n-2)); r = (fibs !! (n-1)) in par l (r+l)|n<-[2..]] in fibs !! 10000
23:57:32 <lambdabot>   544383731135652813387342609937503801353891845546959670262477158412085828656...
23:57:33 <Axman6> >_>
23:57:35 <Axman6> ha
23:57:42 <Axman6> didn't think par would work in lambdabot
23:57:48 <smarmy> > foldl' (+) 0 . take 40000 $ let fibs = let fib0 m n = m : fib1 n (m+n); fib1 m n = fib0 n (m+n) in fib1 0 1
23:57:49 <lambdabot>   <no location info>: parse error on input `;'
23:57:55 <BeelsebobWork> Axman6: it probably isn't threaded
23:58:02 <Axman6> meh :P
23:58:07 <BeelsebobWork> remember -- par just hints to the interpretter that it *can* parallelise if it likes
23:58:27 <mmorrow> , (let fib m !n = m : fib n (m+n) in fib 0 1) !! 1000000
23:58:31 <lunabot>  luna: out of memory (requested 1048576 bytes)
23:58:49 <mmorrow> , (let fib m !n = m : fib n (m+n) in fib 0 1) !! 100000
23:58:52 <lunabot>  2597406934722172416615503402127591541488048538651769658472477070395253454...
23:58:56 <smarmy> > foldl' (+) 0 . take 40000 $ let fib0 m n = m : fib1 n (m+n); fib1 m n = fib0 n (m+n) in fib1 0 1
23:58:57 <lambdabot>   458917898454169424284040487009900919285422578647082215324012671952169440059...
23:59:01 <mmorrow> , (let fib m !n = m : fib n (m+n) in fib 0 1) !! 400000
23:59:05 <lunabot>  luna: out of memory (requested 1048576 bytes)
