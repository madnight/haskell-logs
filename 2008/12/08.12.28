00:01:44 <ksf> haskell should allow symbols in the middle and at the end of function names.
00:02:15 <CakeProphet> > pi :: Int
00:02:16 <lambdabot>       No instance for (Floating Int)
00:02:16 <lambdabot>        arising from a use of `pi' at <in...
00:02:27 <CakeProphet> :t floor
00:02:28 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
00:02:32 <Gracenotes> hm. >>> is somewhat like functional composition, but in the opposite direction?
00:02:37 <ksf> so that you can differentiate between "linear" (makes something linear) and "linear!" (requires something to be linear)
00:02:40 <CakeProphet> how do you change a Double to an Int?
00:02:50 <ksf> :t round
00:02:52 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
00:03:10 <ksf> otoh, we could all code in agda.
00:03:32 <ksf> :t floor
00:03:34 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
00:03:38 <ksf> :t ceil
00:03:40 <lambdabot> Not in scope: `ceil'
00:03:46 <ksf> uhhhhhmmmm...
00:03:55 <ksf> :t floor + 1
00:03:56 <lambdabot> forall a b. (Num (a -> b), Integral b, RealFrac a) => a -> b
00:04:58 <ksf> > round pi
00:05:00 <lambdabot>   3
00:05:12 <Gracenotes> > first (arr negate) (1,2)
00:05:14 <lambdabot>   (-1,2)
00:05:21 <Gracenotes> > second (arr negate) (1,2)
00:05:22 <lambdabot>   (1,-2)
00:05:29 <Gracenotes> oh, hm.
00:06:28 <pumpkin> does lambdabot need a massive machine to run on efficiently? it's going pretty slowly on mine
00:06:29 <CakeProphet> > randomRs 1000
00:06:30 <lambdabot>       Overlapping instances for Show (g -> [a])
00:06:31 <lambdabot>        arising from a use of ...
00:06:40 <CakeProphet> > randomRs (1,10) 1000
00:06:41 <lambdabot>   Add a type signature
00:06:53 <CakeProphet> > randomRs (1,10) 1000 :: [Double]
00:06:54 <lambdabot>   Add a type signature
00:07:22 <CakeProphet> :t randomRs
00:07:23 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> [a]
00:07:30 <Saizan_> > randomRs (1,10) (mkStdGen 1000) :: [Double]
00:07:31 <lambdabot>   [5.199414682271754,2.166647463260835,7.194965971097109,9.910105640164137,3....
00:07:37 <CakeProphet> o rite.
00:07:49 <CakeProphet> > randomRs (1,10) (mkStdGen 1000)
00:07:50 <lambdabot>   [4,8,5,6,10,9,2,7,5,1,5,9,10,7,2,10,4,4,1,4,2,9,4,9,5,3,5,9,3,8,8,6,4,9,5,9...
00:12:32 <CakeProphet> > 10.0 :: Int
00:12:33 <lambdabot>       No instance for (Fractional Int)
00:12:33 <lambdabot>        arising from the literal `10.0'...
00:12:40 <CakeProphet> > round 10.0
00:12:41 <lambdabot>   10
00:12:42 <pumpkin> I have a whole bunch of "defunct" muevals that won't die
00:13:34 <ivanm> pumpkin: kill -9 does wonders! ;-)
00:13:40 <pumpkin> not in this case :P
00:13:42 <pumpkin> it doesn't die
00:15:07 <CakeProphet> :t show
00:15:08 <lambdabot> forall a. (Show a) => a -> String
00:15:23 <CakeProphet> :t show 'a'
00:15:24 <lambdabot> String
00:17:21 <CakeProphet> :t show 1
00:17:23 <lambdabot> String
00:17:35 <CakeProphet> my code is saying that a show of an Int is a Char
00:17:49 <CakeProphet> putStrLn ("    population = " ++ (show defaults!!0))
00:17:55 <CakeProphet> where defauls is a [Int]
00:18:29 <CakeProphet> hmmm... is it taking the 0th character of "show defaults"?
00:19:53 <Cale> CakeProphet: yes
00:20:41 <chylli> where can I find the API of gtk2hs ? I didn't find it in homepage
00:20:44 <Cale> move the ( just before show to just after it.
00:22:12 <Cale> chylli: http://www.haskell.org/gtk2hs/documentation/
00:30:56 <xEpicFailGuyx> y helo thar, #haskell
00:35:32 <chylli> Cale: thanks.
00:47:00 <mmorrow> self-modifying code via a symtab of mvars of IO (): http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=693#a693
00:47:17 <mmorrow> main = jmp _main
00:47:24 <mmorrow> yesh!
01:11:58 <ydo> how can I get an inf. seq of random numbers?
01:12:29 <ivanm> @type randoms
01:12:30 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
01:12:32 <ivanm> ydo: ^^
01:12:49 <ivanm> > randoms (mkStdGen 1) :: [Int]
01:12:50 <lambdabot>   [7917908265643496962,-1017158127812413512,-1196564839808993555,128524678767...
01:16:32 <ydo> ok, don't I need to save some state for the next sequence?
01:16:48 <ydo> and I need bounds too
01:16:58 <ydo> ivanm
01:17:37 <ivanm> ydo: for bounds, use randomRs
01:17:44 <ivanm> if you need another state, split the generator first
01:17:46 <ivanm> @type split
01:17:48 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
01:19:38 <ydo> where would I use randomRs in that first forall line (which I don't understand since I am a newbie on haskell)
01:20:11 <ivanm> > randomRs (mkStdGen 1) (1,2)
01:20:12 <lambdabot>   Couldn't match expected type `(a, a)'
01:20:15 <ivanm> @type randomRs
01:20:16 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> [a]
01:20:21 <ivanm> > randomRs (1,10) (mkStdGen 1)
01:20:23 <lambdabot>   [8,9,8,10,1,10,7,8,3,1,4,8,7,4,9,6,5,3,9,7,7,10,3,7,10,4,8,7,4,9,9,10,9,2,7...
01:20:52 <Gracenotes> is haskell.org down for anyone else?
01:21:21 <ivanm> Gracenotes: looks like it :(
01:21:38 <jeffwheeler_> Gracenotes: yep
01:21:56 <ydo> ivanm: ok, ty, what is the 1 in mkStdGen, a seed?
01:22:04 <jeffwheeler_> http://downforeveryoneorjustme.com/haskell.org
01:22:11 <ivanm> ydo: (mkStdGen1 ) makes a seed, yes
01:22:28 <ivanm> normally you would use newStdGen inside the IO monad, and then pass it through to your computations
01:24:13 <pumpkin> @hoogle [b] -> Int -> b
01:24:13 <lambdabot> Prelude (!!) :: [a] -> Int -> a
01:24:13 <lambdabot> Data.List (!!) :: [a] -> Int -> a
01:24:13 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
01:24:22 <francis> ah
01:27:31 <francis> @hoogle [Integral a] -> a -> a
01:27:31 <lambdabot> Warning: Unknown type Integral
01:27:31 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
01:27:31 <lambdabot> Language.Haskell.TH.Syntax qRecover :: Quasi m => m a -> m a -> m a
01:27:51 <pumpkin> @hoogle (Integral a) => a -> a
01:27:52 <lambdabot> Prelude div :: Integral a => a -> a -> a
01:27:52 <lambdabot> Prelude gcd :: Integral a => a -> a -> a
01:27:52 <lambdabot> Prelude lcm :: Integral a => a -> a -> a
01:27:57 <ivanm> francis: that type sig didn't really make sense...
01:28:09 <francis> :O a troll?
01:28:14 * francis winks at pumpkin
01:28:15 <pumpkin> lol
01:28:32 <pumpkin> (he's just learning)
01:33:32 <ydo> odd.. of every new sequence (at least the first 30 sequences), all first numbers are odd
01:34:16 <ivanm> ydo: how are you generating your seeds?
01:34:33 <ivanm> > randomRs (1,10) (mkStdGen 14325623)
01:34:34 <lambdabot>   [8,2,2,3,6,4,3,1,3,10,4,7,1,8,3,2,9,2,3,1,1,3,9,6,6,10,9,7,6,7,6,10,2,1,3,2...
01:34:41 <ydo> ivanm: for now I'm just passing 1 to 30
01:34:43 <ivanm> ydo: ^^ not odd to me! ;-)
01:34:58 <ivanm> ydo: use newStdGen to get a "really random" seed :s
01:35:16 <ydo> well.. I still want it to be deterministic
01:35:42 <ivanm> ydo: then why do you want them to be random? :o
01:36:01 <ivanm> isn't "deterministacally random" an oxymoron?
01:36:16 <ydo> I don't believe in random ;)
01:37:03 <ivanm> ydo: then why did you ask for a way of generating random numbers?
01:37:35 <ydo> oh, just short for psuedo-random
01:37:44 <ivanm> of course, there's always the xkcd random number generator: xkcdRandom :: (RandomGen g, Num a) => g -> a; xkcdRandom _ = 4
01:37:45 <ivanm> ;-)
01:37:55 <ydo> hehe
01:38:25 <b_jonas> yeah, that's a good one
01:38:29 <b_jonas> pity it's not original
01:38:33 <ivanm> but it's guaranteed to be random by a dice throw! :o
01:38:44 <ivanm> b_jonas: there's always the dilbert version, which returns 2 IIRC...
01:38:53 <b_jonas> Knuth asks in the introduction of the random chapter whether 2 is a random number
01:38:56 <b_jonas> iirc
01:41:57 <sjanssen> of course it isn't
01:42:04 <sjanssen> 7 is much more random
01:42:28 <pumpkin> lol
01:43:02 <sjanssen> but even 7 isn't completely random, they don't use those kind of numbers at NSA
01:43:12 * beelsebob pokes about for an oper
01:43:17 <sjanssen> beelsebob: wut?
01:43:30 <b_jonas> that reminds me to http://noentropy.net
01:43:40 <b_jonas> for not random numbers
01:43:53 <beelsebob> could you temporarily ban BeelsebobWork please -- I have no way to fix the pinging in and out until I go back there, and it's getting somewhat anoying ;)
01:45:16 <Raynes> Ghost 'em
01:45:33 <beelsebob> Raynes: it'll just ping in again
01:45:49 <Raynes> Stab him to death with a screwdriver!
01:45:55 <Raynes> That'll show him.
01:45:57 <beelsebob> I would love to do that ;)
01:48:05 <sjanssen> beelsebob: how long should BeelsebobWork be banned?
01:48:08 <schme_> g'day
01:48:21 <beelsebob> sjanssen: until the 1st or so
01:49:51 --- mode: ChanServ set +o sjanssen
01:52:14 --- mode: sjanssen set +b BeelsebobWork!*@*
01:52:26 --- mode: ChanServ set -o sjanssen
02:01:06 <pumpkin> @check \xs -> (reverse xs == xs)
02:01:07 <lambdabot>   "OK, passed 500 tests."
02:01:11 <pumpkin> what's up with that?
02:01:28 <beelsebob> pumpkin: it will have chosen [()] as the type to test on
02:01:34 <pumpkin> ah, I see
02:01:47 <beelsebob> same reason that it says forall x . mempty == x `mappend` x
02:01:57 <pumpkin> @check \xs -> (reverse (xs :: (Num a) => [a]) == xs)
02:01:58 <lambdabot>       Inferred type is less polymorphic than expected
02:01:58 <lambdabot>        Quantified type ...
02:02:06 <pumpkin> being too polymorphic?
02:02:07 <ivanm> beelsebob: how do you know it didn't choose a palindromic list? ;-)
02:02:09 <sjanssen> pumpkin: -fextended-defaulting in ghci
02:02:27 <beelsebob> ivanm: well evidently it did ;)
02:02:42 <ivanm> *a non-empty palindromic list
02:02:43 <beelsebob> thing is, it's easy to chose 500 palindromic lists of type [()]
02:02:50 <ivanm> since you said it chose an empty list...
02:02:55 <beelsebob> no I didn't
02:03:05 <beelsebob> I said it used the type list of units
02:03:06 <ivanm> ahhh, my mistake.... its a list of type [()]
02:03:12 <sjanssen> it's harder not to choose a non-palindromic list of type [()] (disregarding _|_)
02:03:39 <b_jonas> @check \xs -> (reverse (xs :: [Int]) == xs)
02:03:41 <lambdabot>   "Falsifiable, after 7 tests:\n[2,3,5]\n"
02:04:20 <b_jonas> @check \xs -> (reverse (reverse xs :: [Int]) == xs)
02:04:22 <lambdabot>   "OK, passed 500 tests."
02:05:14 <sjanssen> @check \xs -> reverse (xs :: [Bool) == xs -- simplest breaking example
02:05:15 <lambdabot>   Parse error at ")" (column 28)
02:05:21 <sjanssen> @check \xs -> reverse (xs :: [Bool) == xs
02:05:21 <lambdabot>   Parse error at ")" (column 28)
02:05:27 <sjanssen> @check \xs -> reverse (xs :: [Bool]) == xs
02:05:28 <lambdabot>   "Falsifiable, after 5 tests:\n[True,False]\n"
02:05:30 * sjanssen is stupid
02:06:08 <b_jonas> @check \xs -> reverse (xs :: [Complex Double]) == xs
02:06:09 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Arbitrary
02:06:09 <lambdabot>          ...
02:06:17 <b_jonas> @check \xs -> reverse (xs :: [Double]) == xs
02:06:19 <lambdabot>   "Falsifiable, after 8 tests:\n[0.75,-5.25,-5.25,6.0,-4.0,-5.0]\n"
02:11:52 <pumpkin> my lambdabot hates me
02:12:29 <francis> > intersection [1..] [1,3..10]
02:12:30 <lambdabot>   Not in scope: `intersection'
02:12:39 <pumpkin> it still hates me
02:12:49 <pumpkin> > second (+1) (2,6)
02:12:50 <lambdabot>   (2,7)
02:12:58 <pumpkin> that doesn't work on mine :(
02:13:03 <pumpkin> but I have arrow
02:16:06 <xEpicFailGuyx> yo what's the best tutorial on monads
02:16:31 <pumpkin> there are so many
02:16:31 <xEpicFailGuyx> I just reached that point
02:16:34 <xEpicFailGuyx> Yeah
02:16:55 <pumpkin> I'd read as many monad tutorials as you can find
02:16:57 <xEpicFailGuyx> In your opinion, what would be the best for a dimwitted engineering major
02:16:58 <xEpicFailGuyx> Ok
02:17:07 <xEpicFailGuyx> Sound advice
02:17:09 <xEpicFailGuyx> Thanks
02:33:09 <Axman6> xEpicFailGuyx: http://blog.tmorris.net/20-intermediate-haskell-exercises/ is what got me understanding the,
02:33:27 <xEpicFailGuyx> Thanks Axman6
02:36:38 <pumpkin> those look fun Axman6
02:36:41 <pumpkin> thanks!
02:36:43 <Axman6> they are :)
02:36:53 <Axman6> screw with your brain a little, but still
02:36:58 <pumpkin> although having less abstract names of things to implement might help
02:37:48 <xEpicFailGuyx> ah
02:38:29 <xEpicFailGuyx> As far as I can tell, the /essence/ of monads is that they are for sequencing actions
02:40:53 <pumpkin> not sure I'd say that
02:41:35 <xEpicFailGuyx> pumpkin: What would you say
02:41:45 <mm_freak_> IO, ST s and to some point State s are about the only monads i know, which do sequencing
02:41:54 <mm_freak_> [] and Maybe are completely non-sequencing
02:42:09 <pumpkin> you can still call "sequence" on them but that's not the same
02:42:14 <mm_freak_> > do x <- [1,2,3]; y <- [4,5,6]; return (x,y)
02:42:16 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
02:42:24 <mm_freak_> there is no sequencing here
02:42:32 <pumpkin> I'd say on the broadest sense that a Monad allows you to redefine what it means to pass your value to someone
02:42:37 <mm_freak_> pumpkin: just about as you can sequence with lets =)
02:42:59 <beelsebob> mm_freak_: no, but the do notation makes it look like there is
02:43:20 <beelsebob> > [1,2,3] <^(,)^> [4,5,6] -- is a much nicer way to express it
02:43:20 <lambdabot>   Not in scope: `<^'Not in scope: `^>'
02:43:25 <mm_freak_> in a broadest sense a monad allows you to incorporate a (maybe structureful) result of a computation into another one
02:43:48 <mm_freak_> that's why it can act as sequencing, because it can require that source computation to be run first
02:44:15 <beelsebob> deterministically actually i's exactly sequencing
02:44:20 <beelsebob> but not necessarily operationaly
02:44:49 <mm_freak_> sequencing dependence?
02:45:01 <beelsebob> that's a nice way to put it, yeh
02:45:29 <beelsebob> which actually encapsulates why I hate the use of monads for stuff like what you did above -- there's no dependancies involved
02:45:36 <beelsebob> so applicative is a better interface on it
02:46:24 <mm_freak_> well, i don't view monads that way…  i use the above often
02:46:36 <mm_freak_> IMO the 'do' keyword is very misleading
02:47:00 <beelsebob> yeh -- that's why I don't like using it ;)
02:47:01 <mm_freak_> it should probably be called 'comp' for 'compute' or something
02:47:25 <beelsebob> I don't see a reason to use bind at all in the example you're showing
02:47:34 <mm_freak_> honestly i prefer the monadic syntax even over list comps
02:47:37 <beelsebob> if there's no dependancy to express, don't write it
02:47:52 <beelsebob> you prefer the monadic one over the applicative one?
02:47:53 <pumpkin> liftM2 better?
02:47:56 <pumpkin> or liftA2?
02:47:58 <beelsebob> liftA2
02:48:05 <beelsebob> or <^ and ^>
02:48:08 <pumpkin> yeah
02:48:10 <mm_freak_> there _is_ a dependency
02:48:14 <pumpkin> but would you be against liftM2?
02:48:14 <beelsebob> no there isn't
02:48:20 <beelsebob> otherwise applicative wouldn't work ;)
02:48:21 <pumpkin> in the same way you're against the do notation
02:48:21 <mm_freak_> return (x,y) depends on x and y =)
02:48:35 <Armored_Azrael> @hoogle getDataFileName
02:48:36 <lambdabot> No results found
02:49:22 <mm_freak_> beelsebob: really, "dependency" in the context of monads is artifical
02:49:28 <mm_freak_> it appears like an arbitrary term
02:49:52 <beelsebob> yeh, I was just trying to formalise in my head exactly what it is that makes a dep in monadic terms different
02:49:59 <mm_freak_> just think of the 'guard' function =)
02:50:43 <mm_freak_> > do x <- [1..5]; y <- [1..5]; guard (x /= y); return (x,y)
02:50:44 <lambdabot>   [(1,2),(1,3),(1,4),(1,5),(2,1),(2,3),(2,4),(2,5),(3,1),(3,2),(3,4),(3,5),(4...
02:51:05 <beelsebob> sure -- but I'm trying to formalise exactl why that's not possible in an applicative
02:51:33 <mm_freak_> because applicative allows _only_ sequencing of computations, while monads allow passing the result along the way
02:52:05 <pumpkin> how does Data.Map.assocs differ from toList ?
02:52:08 <beelsebob> yep, that makses sense
02:52:09 <mm_freak_> in a sense, applicative is the same as monad without the binding operator
02:52:23 <beelsebob> well yeh, that's exactly whan an applicative is ;)
02:52:37 <beelsebob> but with a specific part of bind retained
02:52:38 <beelsebob> namely ap
02:53:07 <mm_freak_> yeah
02:53:10 <b_jonas> so does applicative still have join?
02:53:30 <beelsebob> no
02:53:38 <mm_freak_> @hoogle Applicative s => s (s a) -> s a
02:53:39 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
02:53:39 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
02:53:39 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
02:53:45 <beelsebob> join/bind is exactly what makes a monad more powerful than an applicative
02:53:58 <b_jonas> because they say you can write bind from join
02:54:01 <mm_freak_> however, i gotta go
02:54:02 <b_jonas> though I can't really see how
02:54:16 <Axman6> b_jonas: i thought it was the other way around
02:54:23 <beelsebob> its both ways round
02:54:25 <b_jonas> Axman6: both ways
02:54:30 <b_jonas> @src join
02:54:30 <lambdabot> join x =  x >>= id
02:54:31 <Axman6> o.O
02:55:12 <b_jonas> so with do notation that would be: join a = do { r <- a; r }
02:55:34 <b_jonas> @src foldr'
02:55:34 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
02:56:06 <pumpkin> so how do you write bind in terms of join?
02:56:27 <b_jonas> dunno, let's try to write it
02:56:42 <b_jonas> so we have join and ap and return
02:58:18 <beelsebob> x >>= f = join (fmap f x)
02:58:45 <b_jonas> fmap f x = (pure f) <*> x
02:59:05 <b_jonas> let's see
02:59:19 <beelsebob> so join ((return f) `ap` x) if you want only monadic bits
02:59:25 <hugo___> hello
02:59:30 <pumpkin> that's neat
02:59:32 <beelsebob> but as you can guarentee functor and applicative with monad, it's rather redundant
02:59:32 <Axman6> :t let g x f = join (fmap f x) in g
02:59:33 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => m a -> (a -> m a1) -> m a1
02:59:40 <b_jonas> let me typecheck that by hand
03:00:00 <b_jonas> x :: m a; f :: a -> m b; x >>= f :: m b;
03:01:10 <b_jonas> pure f :: m (a -> m b); (pure f) <*> x :: m (m b); join ((pure f) <*> x) :: m b;
03:01:13 <b_jonas> the types work
03:03:12 <pumpkin> > let f >>= x = join (fmap f x) in [1,2,3] >>= \x -> [4,5,6] >>= \y -> return (x, y)
03:03:13 <lambdabot>   Couldn't match expected type `a -> m a1'
03:03:21 <ski_> mm_freak_ : `do x <- [1,2,3]; y <- [4,5,6]; return (x,y)' is all about sequencing
03:03:37 <pumpkin> > let f >>= x = join ((return f) `ap` x) in [1,2,3] >>= \x -> [4,5,6] >>= \y -> return (x, y)
03:03:38 <lambdabot>   Couldn't match expected type `a -> m a1'
03:04:03 <pumpkin> hmm, where did I go wrong?
03:04:18 <pumpkin> > 1,2,3] >>= \x -> [4,5,6] >>= \y -> return (x, y)
03:04:19 <lambdabot>   <no location info>: parse error on input `,'
03:04:20 <pumpkin> > [1,2,3] >>= \x -> [4,5,6] >>= \y -> return (x, y)
03:04:21 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
03:04:40 <baaba> :t join ((return f) `ap` x)
03:04:41 <lambdabot>     Couldn't match expected type `m a' against inferred type `Expr'
03:04:41 <lambdabot>     In the second argument of `ap', namely `x'
03:04:41 <lambdabot>     In the first argument of `join', namely `((return f) `ap` x)'
03:05:04 <baaba> :t \f x -> join ((return f) `ap` x)
03:05:06 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a -> m a1) -> m a -> m a1
03:05:41 <beelsebob> pumpkin: you put the function on the wrong side of the bind ;)
03:06:12 <pumpkin> hmm?
03:06:21 <beelsebob> x >>= f, not f >>= x
03:06:24 <baaba> > let x >>= f = join ((return f) `ap` x) in [1,2,3] >>= \x -> [4,5,6] >>= \y -> return (x, y)
03:06:25 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
03:06:30 <pumpkin> oh duh
03:06:37 <pumpkin> lol
03:07:00 <pumpkin> I'll excuse myself by saying it's 6am and I've been awake too long
03:07:05 <pumpkin> (but really I just fail)
03:26:52 <vefjun> I am trying to use HXQ, the Compiler from XQuery to Haskell
03:27:14 <vefjun> Here is an example.
03:27:14 <vefjun> module Main where
03:27:14 <vefjun> import Text.XML.HXQ.XQuery
03:27:14 <vefjun> main = do a <- $(xq (" ... some xquery "))                                                        "))
03:27:14 <vefjun>           putXSeq a
03:27:15 <vefjun> The result is displayed on stdout.
03:27:17 <vefjun> Can anyone tell me how to put the result in a file?
03:28:30 <Cale> vefjun: Probably, let me check the documentation
03:33:51 <Cale> vefjun: Oh, odd, showXS isn't documented, though it appears to be exported from the module
03:34:33 <Cale> vefjun: putXSeq just uses showXS to turn the XSeq into a String
03:35:10 <Cale> (which it then prints with putStrLn)
03:35:41 <Cale> vefjun: you should be able to use something like  writeFile "foo" (showXS a)
03:36:30 <ivanm> Cale: maybe it isn't documented because there's no explicit type signature?
03:36:35 <ivanm> and as such, haddock ignores it?
03:37:01 <Cale> http://hackage.haskell.org/packages/archive/HXQ/0.14.0/doc/html/src/Text-XML-HXQ-XTree.html#showXS
03:37:06 <Cale> well, there appears to be.
03:38:30 <vefjun> thanks a lot
03:38:34 <RayNbow> Cale: if unfoldr is the dual of foldr, does something like unfoldl exists as a dual of foldl?
03:39:57 <galdor> hi, I'd like to know if it's possible to 'show' a haskell expression
03:40:05 <galdor> I mean, like quoting in lisp
03:40:23 <Cale> galdor: With Template Haskell, perhaps.
03:40:27 <ivanm> galdor: you can't show functions
03:40:29 <Cale> RayNbow: hmm...
03:40:36 <galdor> ivanm: expression only
03:40:36 <ivanm> (unless you use TH, like Cale says...)
03:40:42 <RayNbow> Cale: I did find a definition of unfoldl somewhere on the hawiki
03:40:43 <ivanm> galdor: as in "2 * 3"?
03:40:49 <ivanm> that's a function with two arguments!
03:40:50 <Cale> (if you have a TH syntax tree, you could show it before you splice it in)
03:40:52 <thotypous> hi :)
03:40:53 <galdor> it's for unit tests
03:41:05 <galdor> i'd like each test to have its expression as name
03:41:22 <ivanm> galdor: uhhhh..... it's "name"? as in what gets printed out?
03:41:27 <galdor> so the tests which run (parseString "(a b)") will have the title "(parseString "(a b)")"
03:41:31 <RayNbow> Cale, http://www.haskell.org/haskellwiki/The_Fibonacci_sequence#Fastest_Fib_in_the_West <-- here, unfoldl just reverses the resulting list
03:41:56 <galdor> in HUnit each test has a name
03:42:16 * ivanm has never used HUnit before
03:42:29 <galdor> It's really cumbersome to use a manual name for each test
03:42:54 <galdor> so I'd like the name to be just the printed expression I test
03:42:55 <Cale> RayNbow: It should also probably be (b -> Maybe (b,a)) rather than (b -> Maybe (a,b))
03:43:00 <Cale> (the first parameter)
03:43:15 <galdor> would be so easy in lisp (troll inside :/)
03:43:58 <Cale> galdor: You could use TH, but typically, we express tests as functions with their own names.
03:44:27 <Cale> (often people use the convention that properties start with "prop" or "prop_")
03:45:00 <Cale> Oh, HUnit, hmm...
03:45:02 <galdor> I'm trying to write a small lisp interpreter in haskell, just to learn
03:45:04 <Cale> yeah, I haven't used that
03:45:26 <galdor> testing the parseString or evalExpr functions requires lot of tests
03:45:28 <Cale> QuickCheck is generally nicer.
03:45:34 <galdor> but labelling each test is really boring
03:45:55 <ivanm> what would be the advantage of HUnit over QC? (note that I haven't used either of these...)
03:46:28 <galdor> ivanm: it seems quickcheck is nice to test for properties
03:46:32 <Cale> ivanm: Well, it appears to associate strings with the tests, so presumably it has a bit more of a framework for running collections of tests.
03:46:35 <galdor> I need to tests for individual cases
03:46:48 <Cale> QuickCheck can handle individual cases as well though
03:46:58 <Cale> They're just properties with no parameters.
03:47:31 <galdor> for example, does parseString "(a)" returns TList [TAtom "a"]
03:50:05 <RayNbow> @let toBase base n = case n of { 0 -> [0]; _ -> unfoldr (\x -> case x `quotRem` base of {(0,0) -> Nothing; (q,r) -> Just (r,q)}) n}
03:50:06 <lambdabot>  Defined.
03:50:15 <pejo> RayNbow, the dual of the foldr/build rule is the destroy/unfoldr
03:52:00 <maltem> galdor: fwiw in quickcheck you would typically do something like \c -> isAlpha c ==> parseString "(" ++ c ++ ")" == TList [TAtom [c]]
03:52:49 <RayNbow> > toBase 2 16
03:52:50 <lambdabot>   [0,0,0,0,1]
03:54:09 <RayNbow> > toBase 3 30
03:54:11 <lambdabot>   [0,1,0,1]
03:54:17 <galdor> maltem: thank you, but I found a work around
03:54:35 <galdor> I defined a specialized test function just to teste parseString
03:54:49 <galdor> so I directly have the name of the string I wanna test
03:54:55 <galdor> and I can use it as a name :)
03:55:55 <Cale> galdor: Typically a good way to test a parser is to test the code which shows expressions at the same time, and check that their composite is the identity (at least in one direction)
03:56:46 <Cale> (that is, write a quickcheck property which takes an expression tree, shows it, then parses it, and checks that it's what you started with)
03:57:35 <galdor> that makes sense
03:57:46 <galdor> don't know why I didn't think about it
03:57:49 <galdor> thank you !
03:59:46 <galdor> and then I just have to write an expression generator
03:59:59 <galdor> and let quickcheck generates the tests, right ?
04:00:04 <Cale> yeah
04:00:12 <RayNbow> pejo: I'm not familiar with build and destroy (except that I remember the names from the stream fusion paper)
04:00:17 <Cale> right, if you look at the Arbitrary instance for another algebraic datatype, it'll probably follow about the same pattern
04:00:30 <galdor> Cale: thank you, now I'm gonna spend lot of times playing with QuickCheck :p
04:00:53 <boegel> zever: gezever!
04:01:09 <zever> lol
04:01:26 <boegel> zever: ;-)
04:04:19 * arno5270 is compiling ghc for his Mac.. which takes *forever*.
04:05:31 <ivanm> arno5270: no it doesn't! proving that Haskell is better to a Java fanboi, however... ;-)
04:05:53 <boegel> arno5270: which type of Mac? and how long?
04:07:18 <arno5270> G4 MacBook, I think... I started the install.. hmm.. three hours ago, I think.
04:07:28 <arno5270> But that's ok, I am in no hurry. :)
04:07:51 <boegel> arno5270: there's no MacBook G4 afaik... it sounds like you might have a PowerBook G4, and then, yes, it might take long
04:08:04 <boegel> arno5270: you could also use the binaries instead of compiling from scratch
04:08:37 <arno5270> PowerBook G4, that sounds about right.
04:09:46 <arno5270> Use the binaries?? Where's the fun in that?
04:11:34 <boegel> arno5270: it lets you play with GHCi in a matter of minutes... :)
04:11:49 <boegel> arno5270: I guess it depends on how experienced you are already with Haskell
04:14:25 <arno5270> I played around with it before, on my Windows PC - doing some of the Project Euler problems, and then feeling really humbled when I saw someone who managed to do in 4 lines of code what took me at least 20.
04:17:14 <maltem> arno5270: that's what anyone starting on Haskell, or even very adeptly programming in it, experiences
04:22:08 <arno5270> What really bit me in the ass (and still does, now and then) is my experience with imperative languages. It took a while for me to wrap my head around the whole functional concept..
04:23:14 <francis> how does one map a division to a list?
04:23:32 <ziman> > map (/3) [1..10]
04:23:34 <lambdabot>   [0.3333333333333333,0.6666666666666666,1.0,1.3333333333333333,1.66666666666...
04:23:38 <ziman> > map (`div` 3) [1..10]
04:23:39 <lambdabot>   [0,0,1,1,1,2,2,2,3,3]
04:23:54 <RayNbow> > map (`quot` 3) [1..10]
04:23:56 <lambdabot>   [0,0,1,1,1,2,2,2,3,3]
04:23:56 <ziman> you have either integral division or fractional division
04:24:35 <francis> ah, thanks
04:28:15 <PeakerWork> Hey, I just had an idea - a hash table whose bins is a binary search tree -- does this kind of structure have a name? (You get the worst case of binary search trees with the average case of hash tables!)
04:58:17 <francis> how does one "source" functions from an external file from ghci?
04:58:36 <philipp__> :l ?
04:59:19 <francis> is that a smiley or a command? :P
05:00:09 <philipp__> :l <file>  and a `?' to ask whether thats what you want
05:00:23 <francis> oh, aye, it is :D
05:00:33 <francis> thanks
05:00:37 <philipp__> np
05:00:54 <b_jonas> PeakerWork: see exercise 38. in chap 6.4. in Knuth
05:03:18 <PeakerWork> b_jonas: I don't have the book - is it basically that structure?
05:03:44 <iagoabal> hi, someone knows a way to do a function like (MonadState s m, MonadState (s,w) m) => m s a -> m (s,w) a
05:03:50 <b_jonas> PeakerWork: yes, but it doesn't write much about it and says it's probably not worth
05:04:26 <b_jonas> (because basically you have two pieces of code doing the same thing when just hashing done right could work)
05:04:51 <PeakerWork> b_jonas: hashing "done right" can never guarantee worst-case, which is a good reason to use maps instead of hash tables..
05:05:09 <PeakerWork> b_jonas: why is Haskell so oriented towards search trees (Map) and not towards hash tables, like Python?
05:05:26 <PeakerWork> because they're more easily implemented as persistent functional data structures, I'd suppose...
05:05:54 <iagoabal> something like http://hpaste.org/13379 but for any MonadState
05:06:30 <PeakerWork> iagoabal: why the semicolons?
05:06:55 <dmwit> :t runState
05:06:56 <lambdabot> forall s a. State s a -> s -> (a, s)
05:07:16 <dmwit> ?src MonadState
05:07:16 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
05:07:17 <iagoabal> custom
05:07:24 <dmwit> ?docs MonadState
05:07:24 <lambdabot> MonadState not available
05:07:30 <dmwit> ?hoogle runState
05:07:30 <lambdabot> Control.Monad.State.Lazy runState :: State s a -> s -> (a, s)
05:07:30 <lambdabot> Control.Monad.State.Strict runState :: State s a -> s -> (a, s)
05:07:30 <lambdabot> Control.Monad.State.Lazy runStateT :: StateT s m a -> s -> m (a, s)
05:07:38 <b_jonas> PeakerWork: two reasons, the lesser is that on complicated structures Ord is easier to define than a hash function, the greater is how a tree can work well persistently (so every operation is fast even if it creates a modified copy of the tree with the original still being there)
05:07:39 <PeakerWork> iagoabal: this seems like "first" for state computations
05:07:52 <b_jonas> PeakerWork: so yeah, what you're saying
05:08:44 <iagoabal> Peaker, yep
05:08:46 <dmwit> ?index MonadState
05:08:46 <lambdabot> Control.Monad.State, Control.Monad.RWS
05:08:50 <PeakerWork> stateFirst :: MonadState m => m s a -> m (s, ignoredState) a
05:09:19 <iagoabal> it's justs what I need
05:09:22 <PeakerWork> iagoabal: could be cool if you could create semantic editor combinators on state computations like http://conal.net/blog/posts/semantic-editor-combinators/
05:09:39 <dmwit> iagoabal: It may not be possible in general.
05:09:59 <dmwit> iagoabal: However, it is certainly possible for any StateT, if that's good enough.
05:10:36 <dmwit> iagoabal: (Since MonadState guarantees only a get and put operation, and what you need is a run operation.)
05:10:52 <dmwit> :t runStateT
05:10:53 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
05:11:21 <iagoabal> dmwit, no well, I don't need a run operation
05:11:34 <iagoabal> it's something like local but executed after instead of before
05:11:38 <iagoabal> :t local
05:11:40 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
05:11:46 <iagoabal> uhmmm
05:11:50 <iagoabal> is not local so
05:12:28 <dmwit> iagoabal: I am pretty sure you do, indeed, need a run operation.
05:12:32 <iagoabal> :t withReader
05:12:34 <lambdabot> forall r' r a. (r' -> r) -> Reader r a -> Reader r' a
05:12:50 <dmwit> iagoabal: In any case, you need more information about the monad's structure than just get and put.
05:12:59 <iagoabal> dmwit, sure
05:13:12 <iagoabal> well, is not very bad, but it's a bit restricted
05:13:21 <iagoabal> I need some StateT in the top of the stack
05:13:34 * dmwit nods
05:14:53 <dmwit> :t \m -> do { (s, s') <- get; (a, newS) <- lift (runStateT m s); put (newS, s'); return a }
05:14:54 <lambdabot> forall t s (m :: * -> *) a (t1 :: (* -> *) -> * -> *). (Monad m, MonadTrans t1, MonadState (s, t) (t1 m)) => StateT s m a -> t1 m a
05:15:35 <dmwit> Is that close enough?
05:17:48 <dmwit> (Note that the wrapped monads "m" are the same in both cases, and that the first argument must have StateT as the top of the stack.  These are both more specific than your first request.)
05:19:52 <iagoabal> dmwit, yep
05:20:41 <iagoabal> well, but is more general than what I have
05:20:44 <iagoabal> thanks
05:25:24 <mercury^> wtf
05:26:22 <mercury^> What can cause ghci to correctly return f a in no time, but eat up all memory and stop responding when asked for let m = f a in m?
05:27:05 <cizra> laziness?
05:27:16 <cizra> o, wait
05:27:34 <cizra> let m = f a in m asks f to return a function and then execute it, I believe
05:27:47 <mercury^> No...
05:27:49 <cizra> but f a doesn't execute that function, it just returns it
05:27:56 <cizra> .. No? OK, I'm a newb anyway
05:29:05 <mercury^> Actually, let m = fa in m works, but having m defined defined in a file that ghci is run on causes problems.
05:30:09 <Lemmih> Paste the code?
05:30:32 <mercury^> m = t (10^100)
05:30:43 <mercury^> Seems pretty irrelevant...
05:31:12 <Lemmih> mercury^: Does 'm' retain a lot of memory?
05:31:28 <mercury^> No.
05:31:48 <mercury^> The problem is there when compiling with main = print m also.
05:31:54 <Lemmih> mercury^: Is 'f' polymorphic?
05:32:23 <mercury^> Yes.
05:32:26 <cpfr_> hey how does xmonad use haskell for its configuration files?
05:32:42 <Lemmih> Types and liveliness are the only things that could have changed, afaik.
05:33:15 <mercury^> When I do main = print $ t (10^100) the type should be the same
05:34:15 <mercury^> Lemmih: I really suspect a bug here.
05:34:26 <asgaroth> cpfr_: The xmonad.hs contains the main function and is then used to compile the actual xmonad executable.
05:34:43 <Lemmih> mercury^: Not without -XNoMonomorphismRestriction.
05:35:04 <cpfr_> asgaroth, but how is its behavior able to be modified at runtime
05:35:06 <Lemmih> mercury^: Paste the code and I'll see if I can duplicate the behavoir.
05:35:43 <asgaroth> cpfr_: It is recompiled in the background and restarted while passing the current state along as a parameter.
05:35:52 <cpfr_> oh
05:36:12 <asgaroth> Try restarting and look at the output of ps for the xmonad command
05:36:25 <mercury^> Lemmih: http://hpaste.org/13380
05:38:01 <Lemmih> mercury^: 'print m' and 'print $ t (10^100)' perform identically on my box.
05:38:56 <mercury^> Well here trying to access m either in ghci or in a compiled program makes the program/ghci stop responding and allocate more and more memory
05:39:02 <mercury^> :s
05:40:46 <PeakerWork> are there nice high-level GUI libraries around ncurses?
05:41:20 <Lemmih> mercury^: Everything works fine on my box with ghc-6.10.1 on an AMD64.
05:41:28 <mercury^> same setup
05:42:00 <PeakerWork> @type runStateT
05:42:01 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
05:42:08 <PeakerWork> @type result
05:42:09 <lambdabot> Not in scope: `result'
05:42:39 <PeakerWork> @let result f = (f.) ; argument f = (.f) ; infixr 2 ~> ; f ~> g = argument f . result g
05:42:40 <lambdabot>  Defined.
05:42:48 <PeakerWork> @type length ~> length ~> id
05:42:49 <lambdabot> forall a a1 b. (Int -> Int -> b) -> [a] -> [a1] -> b
05:46:10 <PeakerWork> @type \act (s, ign) -> (\(res, ns) -> (res, (ns, ign))) `fmap` (runStateT act s)
05:46:11 <lambdabot> forall t t1 t2 (f :: * -> *). (Functor f) => StateT t2 f t1 -> (t2, t) -> f (t1, (t2, t))
05:48:24 <PeakerWork> @type get
05:48:25 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
05:50:04 <PeakerWork> something like "local" could be nice for state too
05:51:16 <PeakerWork> withState remains in the same state monad..
05:53:20 <PeakerWork> transformState :: (s -> ns) -> (ns -> s) -> StateT s m a -> StateT ns m a   could do it
06:16:54 <cnwdup> @pl (\f g xs -> map g (map f xs))
06:16:54 <lambdabot> flip ((.) . map) . map
06:17:27 <cnwdup> @pl \(f g xs -> (map (g . f) xs)
06:17:27 <lambdabot> (line 1, column 5):
06:17:27 <lambdabot> unexpected "g"
06:17:27 <lambdabot> expecting operator or ")"
06:17:30 <cnwdup> @pl \(f g xs -> (map (g . f) xs))
06:17:30 <lambdabot> (line 1, column 5):
06:17:30 <lambdabot> unexpected "g"
06:17:30 <lambdabot> expecting operator or ")"
06:23:16 <beelsebob> @pl \f g -> map g . map f
06:23:16 <lambdabot> flip ((.) . map) . map
06:23:25 <beelsebob> although map g . map f seems rather nicer ;)
06:23:39 <beelsebob> or map (g . f)
06:25:08 <b_jonas> oh yeah, but then
06:25:16 <b_jonas> @pl \f g -> map (g . f)
06:25:16 <lambdabot> (map .) . flip (.)
06:28:23 <Martijn> @pl \getC -> do c <- getC; c arg
06:28:23 <lambdabot> (line 1, column 22):
06:28:23 <lambdabot> unexpected ";"
06:28:23 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
06:28:43 <Martijn> @pl \getC -> do { c <- getC; c arg }
06:28:43 <lambdabot> (line 1, column 13):
06:28:43 <lambdabot> unexpected "{"
06:28:43 <lambdabot> expecting variable, "(", operator or end of input
06:28:54 <Martijn> Hrm
06:29:02 <beelsebob> Martijn: (<*> .) . pure?
06:29:05 <beelsebob> I think
06:29:06 <b_jonas> I want to write haskell functions that are used as :def macros in ghci.  If I want to keep some state between the invocations of such macros, what's the best way to do that?
06:29:18 <beelsebob> but rather nicer as \f x -> f <*> (pure x)
06:29:22 <twanvl> @@ @pl @undo \getC -> do { c <- getC; c arg } -- the pl plugin doesn't understand do notation
06:29:23 <lambdabot>  (($ arg) =<<)
06:29:28 <Olathe> > div maxBound 1000000 :: Int
06:29:30 <lambdabot>   9223372036854
06:30:00 <Martijn> Thanks guys
06:30:01 <b_jonas> (I'm still thinking of writing a macro that lets you add import-as and data/type/newtype/instance/class declarations to a temp module and load it.)
06:30:02 <baaba> :t \getC -> do { c <- getC; c arg }
06:30:04 <lambdabot> Not in scope: `arg'
06:30:19 <baaba> :t \arg getC -> do { c <- getC; c arg }
06:30:21 <lambdabot> forall t (t1 :: * -> *) t2. (Monad t1) => t -> t1 (t -> t1 t2) -> t1 t2
06:30:26 <beelsebob> @type \getC -> do { c <- getC; c arg? }
06:30:27 <lambdabot> parse error on input `}'
06:30:31 <beelsebob> @type \getC -> do { c <- getC; c ?arg }
06:30:32 <lambdabot> forall (t :: * -> *) t1 t2. (Monad t, ?arg::t1) => t (t1 -> t t2) -> t t2
06:30:42 <beelsebob> @type (<*> .) . pure
06:30:43 <lambdabot> parse error on input `.'
06:30:51 <beelsebob> @type ((<*> .) . pure)
06:30:52 <lambdabot> parse error on input `.'
06:31:02 <beelsebob> @type (((<*>) .) . pure)
06:31:03 <lambdabot> forall (f :: * -> *) a b a1. (Applicative f) => f (a -> b) -> a1 -> f a -> f b
06:31:16 <beelsebob> not quite
06:31:26 <beelsebob> close though
06:31:31 <baaba> what's ?arg
06:31:40 <beelsebob> baaba: it asks it to get the type of arg too
06:31:45 <baaba> ah
06:31:50 <beelsebob> it certainly doesn't need Monads though -- it's def an applicative thing
06:32:04 <beelsebob> it's fmap, but in reverse essentially
06:32:06 <Olathe> @index Word64
06:32:07 <lambdabot> Data.Word, Foreign
06:32:55 <Olathe> @instances-importing Random
06:32:56 <lambdabot> Couldn't find class `Random'. Try @instances-importing
06:33:06 <Olathe> Yeah, I'll...try that.
06:33:34 <francis> can you reverse ints? or at least separate the digits in the int into a list and reverse that?
06:33:43 <Olathe> Yes.
06:33:51 <Martijn> sure: reverse (show int)
06:34:34 <francis> well show wont work for me because i need to use the result in a mathematical operation :(
06:34:48 <Martijn> then read it too?
06:34:57 <Martijn> > (read . reverse . show) 92753
06:34:58 <Olathe> > let digits 0 = [0]; digits n = f' [] n where f' ds 0 = ds; f' ds n = f' (d:ds) n' where (d:n') = divMod n 10 in map digits [1..20]
06:34:59 <lambdabot>   * Exception: Prelude.read: no parse
06:35:00 <lambdabot>   Couldn't match expected type `[t]' against inferred type `(t1, t1)'
06:35:06 <Olathe> > let digits 0 = [0]; digits n = f' [] n; f' ds 0 = ds; f' ds n = f' (d:ds) n' where (d:n') = divMod n 10 in map digits [1..20]
06:35:08 <lambdabot>   Couldn't match expected type `[t]' against inferred type `(t1, t1)'
06:35:11 <Olathe> Bah.
06:35:25 <Martijn> > (read . reverse . show) 92753 :: Int
06:35:27 <lambdabot>   35729
06:35:38 <francis> fantastic, thanks!
06:36:11 <b_jonas> isn't there a base and antibase function somewhere
06:36:15 <Olathe> @let digits 0 = [0]; digits n = f' [] n where f' ds 0 = ds; f' ds n = f' (d:ds) n' where (n', d) = divMod n 10
06:36:15 <b_jonas> to decompose to digits?
06:36:16 <lambdabot>  Defined.
06:36:25 <Olathe> > map digits [0..20]
06:36:26 <b_jonas> also, take care with negatives
06:36:27 <lambdabot>   [[0],[1],[2],[3],[4],[5],[6],[7],[8],[9],[1,0],[1,1],[1,2],[1,3],[1,4],[1,5...
06:36:40 <b_jonas> > (read . reverse . show) (-92753)
06:36:42 <lambdabot>   * Exception: Prelude.read: no parse
06:36:44 <Martijn> > read "002" :: Int
06:36:45 <lambdabot>   2
06:37:08 <francis> b_jonas: im not worried about negatives, not in this usage scenario anyway
06:37:14 <Olathe> > foldl1 ((+).(*10)) [1, 2, 3]
06:37:17 <lambdabot>   123
06:37:21 <francis> (im controlling the input)
06:37:25 <Olathe> @let undigits = foldl1 ((+).(*10))
06:37:27 <lambdabot>  Defined.
06:37:38 <Olathe> > undigits.reverse.digits $ 123
06:37:40 <lambdabot>   321
06:37:43 <dons> ?users
06:37:44 <lambdabot> Maximum users seen in #haskell: 568, currently: 537 (94.5%), active: 9 (1.7%)
06:38:06 <[1]sh> Hello.
06:38:11 <Olathe> Hello.
06:38:16 <Martijn> Olá
06:38:36 <b_jonas> Olathe: great
06:39:08 <Olathe> @hoogle (Integral a) => a -> [a]
06:39:09 <lambdabot> Prelude repeat :: a -> [a]
06:39:09 <lambdabot> Data.List repeat :: a -> [a]
06:39:09 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
06:39:18 <Lemmih> lambdabot is quite forgetful, it seems.
06:41:25 <b_jonas> > let { rev x = rev1 0 x; rev1 r x | x <= 0 = r | True = rev1 (10 * r + mod x 10) (div x 10); } in rev 92753
06:41:27 <lambdabot>   35729
06:41:39 <[1]sh> ghci evaluates the following expression to True: (1,undefined)<(2,undefined). But when loading a Haskell script containing the line "test = (1,undefined)<(2,undefined)", I get a compilation error. Can someone please explain this compilation error to me? Thanks.
06:42:14 <b_jonas> [1]sh: defaulting is my guess. what's the compile error you get?
06:42:17 <Heffalump> can you tell us what the error is?
06:42:55 <[1]sh> Ambiguous type variable 'a' in the constraint: 'Ord a' arising from the use of <
06:43:19 <[1]sh> Probable fix: add a type signature that fixes these type variable(s)
06:43:39 <Martijn> Have you tried adding a type signature?
06:43:41 * [1]sh is a newby
06:44:12 <[1]sh> Yes, I tried that but I was too dumb
06:44:28 <b_jonas> [1]sh: of what type is (1,undefined) in that expression?
06:44:32 <[1]sh> You mean like test:: Bool
06:45:03 <Olathe> test = (1, undefined) < ((2, undefined) :: (Int, String))
06:45:06 <[1]sh> Pair of Int and every type?
06:45:07 <Olathe> Something like that.
06:45:22 <Olathe> It needs to know which specific type the second element is.
06:45:35 <b_jonas> yes, but you can't just have every type if you're actually doing a computation
06:45:44 <Olathe> This is another way: test = (1, undefined) < (2, undefined :: String)
06:45:57 <[1]sh> Cool, now I think I get the problem
06:46:11 <paolino> :t undefined
06:46:13 <lambdabot> forall a. a
06:46:23 <Olathe> The type is...undefined.
06:46:31 <[1]sh> And why doesn't the compiler complain about the undefined in the first tuple?
06:46:36 <Olathe> It does.
06:46:47 <b_jonas> @type (<)
06:46:49 <lambdabot> forall a. (Ord a) => a -> a -> Bool
06:46:52 <Olathe> a < b says that a and b are the same type.
06:47:06 <Olathe> So, if you tell it that b is (Int, String), it knows what a is.
06:47:31 <dons> woo, http://www.reddit.com/r/programming/comments/7m209/complete_twitter_bindings_for_haskell_tweet_from/
06:47:33 <Olathe> So, it complained when you didn't tell it at all.
06:47:40 <dons> sigbjorn is a web 2.0 library machine.
06:47:47 <Olathe> But not so much when you tell it what both are like you did.
06:48:04 <[1]sh> Olathe, thanks for this detailed explanation!
06:48:11 <b_jonas> (if only you could answer my question so easily too)
06:48:13 <Olathe> You're welcome.
06:49:09 <paolino> well, the compiler could be wrong that you are counscious of it's deductions, so it's better signing
06:49:29 <paolino> *its
06:51:12 <b_jonas> what?
06:51:14 <francis> is there a way to get the value of a certain index in a list?
06:51:27 <xEpicFailGuyx> francis: !!
06:51:32 <xEpicFailGuyx> l !! index
06:51:54 <dons> dcoutts: you should comment on SAT solvers for package systems here, http://www.reddit.com/r/programming/comments/7m08d/opensuse_is_using_a_bsd_licensed_sat_solver_for/
06:51:58 <francis> thanks :)
06:52:11 <paolino> jonas, nm, I thought too loud really
06:54:50 <paolino> Olathe: thanks for the distance matrix code of yesterday
06:56:29 <Olathe> paolino: You're welcome.
06:58:55 <paolino> Olathe: it would be nice to find the 2-partition of the list that minimize the sum of the "errors"
06:59:12 <Martijn> @pl \p _ -> action p
06:59:12 <lambdabot> const . action
07:00:07 <redditbot> MuMer: an online trading game using HAppS and Haskell
07:00:48 <augustss> @seen thotypous
07:00:49 <lambdabot> thotypous is in #haskell. I last heard thotypous speak 3h 19m 57s ago.
07:01:07 <thotypous> hi augustss :)
07:01:16 <Martijn> Hehe
07:03:21 <NameAlreadyInUse> what is a good haskell IDE for windows?
07:03:59 <Axman6> why do you need an IDE?
07:04:19 <[1]sh> Just a little detail that I do not understand: why does ghci accept the expression from above when I enter it interactively in a session?
07:04:23 <NameAlreadyInUse> i don't need one
07:05:27 <sbahra> [1]sh, which expression?
07:05:41 <[1]sh> (1,undefined)<(2,undefined)
07:05:45 <paolino> [1]sh: probably defaults undefined to Int or whatever
07:05:58 <NameAlreadyInUse> i am using scite to write haskell at the moment and i thought that there might be a good IDE available instead
07:06:07 <[1]sh> paolino, this sounds very reasonable, thanks!
07:06:29 <Axman6> NameAlreadyInUse: anything wrong with a text editor and ghci?
07:06:38 <sbahra> paolino, undefined isn't evaluated.
07:07:05 <sbahra> paolino, undefined is undefined, it is "special" (doesn't default to Int)
07:07:18 <paolino> I ssuspect the type is assigned not the value
07:07:31 <Olathe> ghci probably doesn't type check unless it needs to.
07:07:33 <sbahra> > ('b', 0) < ('a', 1)
07:07:34 <lambdabot>   False
07:07:51 <NameAlreadyInUse> Axman: nothing at all, but i prefer a good IDE to a text editor
07:08:16 <sbahra> [1]sh, sorry, my response was targeting you.
07:08:25 <sbahra> [1]sh, I responded to paolino for some reason.
07:09:18 <paolino>  Olathe: it does type defaulting to some expressions, though
07:10:31 <paolino> Olathe: also I don't know if typechecking can be interleaved with evaluation
07:10:38 <PeakerWork> Axman6: an IDE is useful in that it has more information about the code you are writing than a simple text editor, and can thus help you edit
07:11:10 <Martijn> I wish I could write: st = State { runState input = ... }
07:11:22 <Martijn> But record syntax won't allow that.
07:11:45 <PeakerWork> Martijn: can you initialize record values at all?
07:12:06 <Martijn> Yes
07:12:15 <Martijn> st = State { runState = \input -> ... } is fine
07:12:31 <[1]sh> sbahra: A script containing the line "test = (1,undefined)<(2,undefined)" results in a compilation error (see discussion above). Now I was wondering why entering the expression "(1,undefined)<(2,undefined)" interactively evaluates to True. And in this context, both the explanations of Paolino and Olathe really make sense.
07:12:42 <PeakerWork> Martijn: oh, whoops, that's not defining a record, but instantiating one
07:13:12 <PeakerWork> Martijn: why are you creating the function manually?
07:13:41 <Martijn> PeakerWork: that I used State here is just for example.
07:14:08 <PeakerWork> Martijn: well, there's always the PL alternative, or writing the function separately and using that
07:14:47 <sbahra> [1]sh, yes. That is what I said :-)
07:14:56 <Martijn> PeakerWork: PL alternative?
07:14:59 <sbahra> [1]sh, undefined is not evaluated.
07:15:00 <b_jonas> [1]sh: the difference is because ghci uses wider defaulting rules
07:15:08 <PeakerWork> Martijn: Points-free style (also called point-less, or PL)
07:15:10 <b_jonas> [1]sh: it's written down in the ghc users' manual
07:15:21 <vixey> point free monadic notations?
07:15:25 <b_jonas> [1]sh: normal h89 defaulting can't default the undefined there because it doesn't have a numeric class
07:15:32 <Martijn> PeakerWork: yes, can you show what the PL version looks like in this specific case?
07:15:41 <b_jonas> [1]sh: but ghci can because it has the Ord class and that's enough for it
07:15:45 <PeakerWork> Martijn: it depends what the function itself is..
07:16:06 <b_jonas> both defaulting rules are quite complicated
07:16:42 <sbahra> Hey abbe
07:17:13 <[1]sh> b_jonas, thanks
07:17:37 <b_jonas> look them up in the ghc user manual, really
07:18:02 <vixey> so curry style is like haskell kinda,
07:18:09 <vixey> you write \x -> \y -> x :: a -> b -> a
07:18:20 <vixey> but church style is \(x::a) -> \(y::b) -> x
07:18:38 <sbahra> hm
07:19:02 <vixey> but is there actually any significant difference?
07:19:12 <mm_freak> ski_: how is that sequencing?  or better, in what way?
07:19:20 <mm_freak> the only sequencing i see there is dependency
07:28:26 <maltem_> vixey: with church style, the question arises if a and b should be in scope on the rhs
07:29:07 <maltem_> (if allowing for introduced type variables)
07:29:10 <b_jonas> vixey: one difference is that if you use the church style to qualify _every_ lambda, the type inferencing gets really simple
07:31:56 <vixey> well I don't think that lambda should be binding a type variable
07:32:23 <vixey> I guess it's like  /\a -> /\b -> \(x::a) -> \(y::b) -> x written out long
07:32:37 <augustss> vixey: exactly!  That's how it should be.
07:33:18 <vixey> but it seems to me that given any church term you can rewrite it as a curry term and vice versa
07:33:19 <augustss> Or to be more precise \ (a :: a) -> \ (b :: *) -> ...
07:33:21 <maltem_> vixey: Well that *is* just binding a type variable?
07:33:27 <vixey> maybe there's some system that is not the case though?
07:33:31 <augustss> \ (a :: *), I mean
07:40:25 <gour> hi, what would you recommend for writing database app with postgresql back-end?
07:40:33 <gour> (for desktop app)
07:40:55 <gour> the other option would be to use python/django with some js kit...
07:53:08 <centrinia> gour, try HAppS. :)
07:54:16 <gour> centrinia: ahh, that's too much for me atm, lack of docs is insurmountable
08:06:04 <idnar> @src ($!)
08:06:05 <lambdabot> f $! x = x `seq` f x
08:07:06 <Olathe> @src seq
08:07:07 <lambdabot> Source not found. Wrong!  You cheating scum!
08:07:13 <Olathe> @src [] seq
08:07:14 <lambdabot> Source not found.
08:07:30 <geezusfreeek> :t seq
08:07:32 <lambdabot> forall a t. a -> t -> t
08:07:49 <geezusfreeek> ^ evaluates the first argument then returns the second argument
08:08:30 <idnar> is that different to "f $! !x = f x"?
08:08:47 <vixey> evaluates
08:08:59 <vixey> @src ($!)
08:09:00 <lambdabot> f $! x = x `seq` f x
08:09:08 <vixey> idnar, yeah I thought your def was nonstandard
08:09:35 <vixey> I'm not sure if it's different but I think there was a case when bang patterns alone was different to a use of seq
08:10:08 <centrinia> > undefined `seq` 42
08:10:10 <lambdabot>   * Exception: Prelude.undefined
08:10:49 <baaba> > const 42 undefined
08:10:50 <lambdabot>   42
08:11:22 <geezusfreeek> > 0 `seq` 42
08:11:23 <lambdabot>   42
08:13:19 <idnar> > 1:undefined `seq` 42
08:13:20 <lambdabot>   42
08:13:24 <idnar> > (1:undefined) `seq` 42
08:13:25 <lambdabot>   42
08:13:41 <idnar> > (undefined:undefined) `seq` 42
08:13:42 <lambdabot>   42
08:16:28 <vixey> this is very confusing
08:17:16 <geezusfreeek> ^ is because seq only evaluates to weak head normal form and lists don't have strict elements
08:17:23 <PeakerWork> _|_ `seq` ... == _|_, but a value that has bottoms in it is just a value
08:17:28 <vixey> there's this rewrite rule:   \x:A, M  -->k  \x : s0, M  (A /= s0)
08:17:38 <vixey> k is actually kappa
08:17:50 <vixey> but what on earth does that mean??
08:18:16 <vixey> it changes the A to s0 when A is not equal to s0 .. doesn't that break things?
08:18:18 <centrinia> How do you make lists strict?
08:18:25 <idnar> geezusfreeek, PeakerWork: yeah, was just demonstrating something to someone, and wanted to make sure my examples were actually correct :P
08:18:31 <vixey> centrinia, use bang patterns in the definition
08:18:38 <geezusfreeek> centrinia, would require a new data type
08:18:59 <paper_cc> geezusfreeek: isn't [!String] a strict list&
08:19:04 <idnar> data List a = Cons !a !(List a) | Nil
08:19:06 <idnar> or something
08:19:11 <vixey> paper_cc, no don'tthink that's even valid haskell
08:19:13 <idnar> paper_cc: no, that's a syntax error
08:19:31 <geezusfreeek> what they said
08:19:59 <vixey> is there something obvious/implicit I am missing about this rewrite rule?
08:20:13 <chylli> I want to install xmonad-contrib with ghc 6.10, but I got an error: http://hpaste.org/13382
08:20:22 <chylli> can someone help me?
08:21:02 <geezusfreeek> chylli, yeah, the xmonad-contrib release is broken in 6.10. use the version in darcs
08:21:21 <chylli> geezusfreeek: THANKS !
08:22:10 * vixey I guess it's just type erasure without making up a new syntax
08:26:44 <chylli> geezusfreeek: I think I meet several things like that: for example, I cant install gtk2hs stable version, but I can install darcs version.
08:27:13 <dcoutts> chylli: that's because you're using ghc-6.10.1 which was only recently released.
08:27:42 <chylli> dcoutts: oh, yeah, thanks.
08:30:23 <geezusfreeek> chylli, in fact, i believe the hackage page for each package shows build errors for failing packages
08:32:44 <chylli> geezusfreeek: really ? oh , I find it. thanks
08:32:59 <chylli> dcoutts: then it shows that ghc is not perfectly backward-compatible ?
08:34:20 <dcoutts> chylli: indeed, it is not perfectly backwards compatible, though most of the changes are in library APIs and in packaging issues. Since gtk2hs uses a custom build system then it is affected by the packaging changes.
08:35:10 <dcoutts> chylli: where as packages that use cabal get better forwards compatibility because Cabal itself can be updated to understand the packaging changes in a new ghc version
08:36:02 <chylli> dcoutts: that's great. I will insist to use cabal system.
08:39:03 <chylli> dcoutts: I remembered that slogan :avoid success at all costs. So I had thought those are the evidence of that slogan...
08:44:43 <chylli> geezusfreeek: another error again for darcs version : http://hpaste.org/13383
08:44:47 <chylli> headache
08:47:34 <geezusfreeek> chylli, i am not sure about this, but perhaps you must also use the darcs version of xmonad?
08:47:56 <chylli> geezusfreeek: fetching now. thanks
08:47:59 <geezusfreeek> that is what i had to do on my computer at work
08:49:09 <cizra> Martijn: hey
08:49:47 <cizra> MudTypes.hs:6:7: Could not find module `Data.Accessor.Template':
08:50:02 <cizra> Martijn: Where do I get that thing? Or does it perhaps require GHC 6.10 to run?
08:50:41 <maltem> cizra: cabal install data-accessor-templatex, I guess
08:50:59 * cizra tries
08:56:02 <cizra> maltem: yes, it worked
09:05:20 <cizra> Martijn: in Text.hs, the type MatchResult conflicts with Text.Regex.Posix.MatchResult. I resolved it by renaming MatchResult.
09:05:32 <Rui> is anyone here that can help me with some Haskell questions
09:05:49 <cizra> There are lots o' people here
09:05:54 <Rui> active and not afk :p
09:06:04 <cizra> The second part is the tougher question.
09:06:29 <Rui> well, I'm a university student at the University of Minho in Portugal
09:06:44 <Rui> I have a project to make a connect 4 type game, in haskell
09:06:58 <Rui> and obviously have ran into some deadends and headaches xD
09:07:50 <roconnor> Rui: don't get sued
09:07:55 <Rui> xD
09:07:55 * cizra pats Rui on the cheek comfortingly
09:08:00 <roconnor> like people at Waterloo did
09:08:11 <roconnor> or was it some other university
09:08:12 <Rui> its not exactly connect 4
09:08:14 <gour> anyone uses postgresql with haskell?
09:08:14 <Rui> its more of a... um
09:08:26 <Heffalump> who sued them?
09:08:37 <roconnor> owners of connect 4
09:08:47 <Rui> let say, your playing on a 7x7 board... you make moves and then the person who has the longest set of lines etc, gets certain points
09:09:00 <dmwit> Maybe you should just ask your question.
09:09:01 <idnar> connect 7? :P
09:09:10 <Rui> xD not really
09:09:18 <Rui> let me try to make an example uh
09:09:25 <Rui> [ X   X   X    O]
09:09:30 <vixey> roconnor, wow lol
09:09:38 <Rui> actually its a bit confusing ><
09:09:51 <vixey> that's horrible though
09:10:10 <Rui> basically, if you make a line that consists of two "coins", its worth lets say 4 points, 3 coins, 5 ... and so on
09:10:24 <Rui> so instead of winning by making a set line of 4 or so... its racking up points
09:10:58 <Rui> anyways, thats not important
09:12:01 <Rui> well, one thing that is giving me a headache is this:
09:12:36 <Rui> I want to make a program that, receives a list of moves, and a number
09:12:37 <Rui> example:
09:12:53 <Rui> [[Null,X,X,O],[X,X,X,X],[O,O,O,O]]
09:13:01 <Rui> thats my "board" per say, written out
09:13:12 <idnar> (it's spelled "per se", just by the way)
09:13:16 <Rui> and now a number, that corresponds to the colums
09:13:27 <Rui> columns*
09:13:30 * vixey lets __ = Null
09:13:31 <Rui> before you correct me again :p
09:13:42 <vixey> = [[__,X,X,O],[X,X,X,X],[O,O,O,O]]
09:13:46 <Rui> leave it null :p
09:13:50 <Rui> "Null"
09:13:56 <Rui> its just how i put the date type for Moves
09:14:02 <Rui> type Lines = [Moves]
09:14:02 <Rui> type Board = [Lines]
09:14:02 <Rui> data Moves = Null
09:14:02 <Rui>             | X
09:14:02 <Rui>             | O
09:14:13 <vixey> __ = Null
09:14:19 <Rui> made a program to graphically show the board with null already etc
09:14:23 <Rui> -.-
09:14:24 <Rui> anyways~
09:14:29 <vixey> hehe
09:14:39 <Rui> I want it to take the head of the list, which in this case is [Null,X,X,O] since its the top of the board
09:15:01 <Rui> with the number I put in
09:15:08 <Rui> lets say 1
09:15:25 <vixey> I wonder why you put Board after Lines?
09:15:31 <Rui> I want it to give me a bool and tell me if the first element i nthe list, in this case is Null, is == Null
09:15:43 <dmwit> vixey: Shut up, he's having enough difficulty coming to the point as it is.
09:15:47 <dmwit> ;-)
09:15:58 <Rui> if I had number 3, to check if the 3rd element of the list which is X and tell me if its == Null
09:16:03 <Rui> catch my drift? :/
09:16:06 <vixey> dmwit: maybe you want a break from the computer
09:16:18 <dmwit> Rui: Check out (!!) and the "deriving" keyword.
09:16:31 <vixey> Rui, so you want an operator that takes a list an index and gives the element at that index?
09:16:33 <Rui> basically a program to verify if I'm allowed to play the coin in the selected column
09:16:55 <Rui> yes
09:16:57 <dmwit> Derive an Eq instance for Moves.
09:17:04 <vixey> Rui, (!!) does it, you could define it by recursion on the index though
09:17:08 <Rui> instance Eq Moves where
09:17:08 <Rui>       Null == Null = True
09:17:08 <Rui>       X    == X    = True
09:17:08 <Rui>       O    == O    = True
09:17:08 <Rui>       _    == _    = False
09:17:18 <vixey>  data Moves = Null
09:17:18 <vixey>              | X
09:17:18 <vixey>              | O
09:17:20 <dmwit> Rui: You can have the compiler generate that for you.
09:17:21 <vixey>          deriving Eq
09:17:23 <vixey> also works
09:17:31 <vixey> but these are equivalent
09:17:55 <Martijn> > let n = 3 in ((== 0) . (!! n)) [1,2,3,0,5]
09:17:56 <lambdabot>   True
09:18:20 <dmwit> I would suggest moving away from lists for this application, too, but I'd leave that to last.
09:23:56 <ozy`> here's a great idea: write an office suite in haskell
09:24:17 <b_jonas> tic-tac-toe is so popular
09:24:25 <ozy`> by the way, do you guys say "HASkell," or "hasKELL?"
09:24:36 <ozy`> b_jonas: yeah, now we just need solitaire
09:24:47 <cizra> ozy`: HAS
09:24:48 <b_jonas> ozy`: or reversi
09:25:00 <b_jonas> or minesweeper
09:25:08 <b_jonas> (I wrote a minesweeper once)
09:26:19 <ozy`> does it use the original minesweeper music? if not, it sucks
09:26:25 <ozy`> oh wait that's tetris
09:27:30 <ozy`> (I just realized how much the current haskell logo reminds me of Purple Tentacle from the Maniac Mansion games)
09:27:47 <ozy`> (they should just make that the logo)
09:28:08 <cizra> ozy`: hahaha
09:28:14 <b_jonas> I also wrote mazes twice
09:28:35 <b_jonas> one of them generates surprisingly good mazes given the simplicity of its algorithm
09:29:10 <b_jonas> I should rewrite that once because the results are good but the code sucks
09:29:15 <ozy`> heh
09:29:16 <vixey> b_jonas, I know an algorithm that generates _perfect_ mazes :p
09:29:55 <b_jonas> vixey: lots of them or only one?
09:30:23 <vixey> b_jonas: every perfect maze (it's a formal term)
09:31:15 <mib_lg6afw> does anyone know how I can complete the right side of this function?  combine . mapBtree (mapBtree f) = ...  . combine
09:31:20 <mib_lg6afw> where mapBtree :: (a -> b) -> Btree a -> Btree b
09:31:22 <mib_lg6afw> and combine :: Btree (Btree a) -> Btree a (works like concat over lists of lists: takes a tree of trees and returns a tree)
09:31:49 <vixey> mib_lg6afw: :t mapBtree f
09:32:02 <stu8ball> There's an IOCCC program that generates mazes, and the code is shaped like a maze itself.
09:32:14 <stu8ball> Or maybe it was a maze solver, don't recall.
09:32:29 <ozy`> did they use that algorithm to generate the maze?
09:32:29 <ozy`> ah
09:32:53 <luqui> oh perfect mazes look like they wouldn't be very good mazes
09:32:58 <vixey> @free whatever :: Btree (Btree a) -> Btree a
09:32:58 <lambdabot> $map_Btree f . whatever = whatever . $map_Btree ($map_Btree f)
09:33:43 * ksf is thinking of a declarative befunge that has its semantics defined by maze-solving
09:34:31 <b_jonas> stu8ball: yes, and jhallen also has an obfu-c program that generates mazes, though I think it was never on ioccc
09:34:40 <ksf> actually, any and every non-strict eval is surprisingly similar to maze solving.
09:35:17 <memento> `
09:35:32 <centrinia> Theseus was the original lazy evaluator. :)
09:35:56 <vixey> ksf: How did you get that?
09:36:33 <mib_lg6afw> thanks :)
09:36:53 <ksf> vixey, I guess by ignoring A*.
09:37:05 <vixey> ksf: i.e. are you just making this up or is there actually a link?
09:37:14 <luqui> is there an A* for non-strict eval? :-)
09:37:35 <ksf> A* is non-strict. djikstra would be strinct.
09:38:18 <luqui> ksf, I second vixey's question.  In the former case, more details please.
09:38:23 <vixey> lazy eval is nothing like A* and it's not fair to call A* maze-solving
09:38:24 <ksf> vixey, nope, I'm just making up similies.
09:39:29 <ksf> the key point is "* ksf is thinking of a declarative befunge that has its semantics defined by maze-solving"
09:40:08 <centrinia> Can anyone access projecteuler.net ?
09:40:30 <Raevel> centrinia: doesn't look like it
09:41:18 <centrinia> That sucks. :(
09:43:40 <ksf> http://downforeveryoneorjustme.com/projecteuler.net
09:43:44 <ksf> dns fuckup.
09:45:45 <centrinia> ksf, thanks for that URL. :D
09:46:48 <Martijn> @pl \v a -> m v (const . a)
09:46:49 <lambdabot> (. (const .)) . m
09:48:52 <PeakerWork> @type \v a -> m v (const . a)
09:48:53 <lambdabot>     Couldn't match expected type `t1 -> (a -> b1 -> b) -> t'
09:48:53 <lambdabot>            against inferred type `Expr'
09:48:53 <lambdabot>     In the expression: m v (const . a)
09:49:21 <PeakerWork> @type \m v a -> m v (const . a)
09:49:22 <lambdabot> forall t b b1 a t1. (t -> (a -> b1 -> b) -> t1) -> t -> (a -> b) -> t1
09:49:35 <PeakerWork> @type (~>)
09:49:36 <lambdabot> forall a a1 b c. (a -> a1) -> (b -> c) -> (a1 -> b) -> a -> c
09:50:02 <PeakerWork> @type \m -> id ~> (const .) ~> m
09:50:03 <lambdabot> forall a b b1 a1 b2 c. (b2 -> c) -> (a -> (a1 -> b1 -> b) -> b2) -> a -> (a1 -> b) -> c
09:50:15 <ksf> in fact, everything is isomorphic to everything else.
09:50:21 <PeakerWork> @type \m -> (id ~> (const .) ~> id) m
09:50:22 <lambdabot> forall a b b1 a1 b2. (a -> (a1 -> b1 -> b) -> b2) -> a -> (a1 -> b) -> b2
09:50:27 <ksf> that's a generalisation of the law of fives.
09:51:02 <ksf> ...isomorphic in some way or the other, that is.
09:51:17 <PeakerWork> So: (id ~> (const .) ~> id) m     ====  argument (const .) . m  ==== \v a -> m v (const . a)
09:51:31 <PeakerWork> @type \m -> (id ~> (const .) ~> m) id
09:51:32 <lambdabot> forall b b1 a b2 c. (b2 -> c) -> ((a -> b1 -> b) -> b2) -> (a -> b) -> c
09:51:38 <ksf> the trick is not to make the isomorphisms up, but to spot them at distance and then figure out what they are.
10:07:03 <dmwit> ?seen Rui
10:07:03 <lambdabot> Rui is in #haskell. I last heard Rui speak 49m 55s ago.
10:07:16 <dmwit> Rui: Did you get sorted?
10:07:19 <PeakerWork> @type replicateM
10:07:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
10:07:25 <PeakerWork> @type repeatM
10:07:26 <lambdabot> Not in scope: `repeatM'
10:07:58 <PeakerWork> if lazy I/O is frowned upon, and reading entire files at once is inefficient, is there any   readNextLine :: Handle -> IO String   or some such?
10:08:04 <PeakerWork> (for efficient strict I/O)
10:08:04 <dmwit> repeatM would probably never return
10:08:16 <dmwit> ?hackage strict
10:08:16 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/strict
10:09:01 <Martijn> repeatM is forever
10:09:06 <Martijn> @type forever
10:09:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
10:09:13 <cizra> Martijn: Did you get my bug reports?
10:09:27 <Martijn> cizra: I don't think so. In what context?
10:09:32 <cizra> custard
10:09:40 <PeakerWork> strict is not quite it - how can I efficiently process the file in O(small) space, instead of O(whole file) space?
10:10:01 <cizra> Martijn: Basically, in Text.hs type MatchResult conflicts with something from standard libs.
10:10:09 <cizra> Martijn: Want the diff?
10:10:27 <Martijn> cizra: Hmm, I don't remember telling anyone about Custard :-P
10:10:46 <dmwit> PeakerWork: Eh?  Isn't that what lazy IO is all about?
10:10:52 <Martijn> cizra: Unless you're Andres
10:10:56 <cizra> Martijn: Google betrayed you. And I'm not.
10:11:32 <PeakerWork> dmwit: Yes,  but lazy I/O is frowned upon. I want something like:   forEachLine $ \line -> do ...       that does not use unsafePerformIO/unsafeInterleaveIO
10:11:35 <dmwit> PeakerWork: readFile "foo" >>= mapM_ someFunctionThatDealsWithASingleLine . lines
10:11:36 <Martijn> cizra: Sure, diff is fine. It's nice to know people are interested.
10:11:54 <PeakerWork> dmwit: lazy I/O is probleamtic
10:12:08 <dmwit> PeakerWork: In what way?  What are you worried about?
10:12:26 <dmwit> (It is true that there are problems.)
10:12:42 <PeakerWork> dmwit: quicksilver and others suggest completely avoiding its use, everywhere (at least where it matters) - it can cause memory leaks, convert I/O exceptions to problematic pure exceptions, and more
10:12:49 <dmwit> (But you shouldn't throw away the idea of using lazy IO without making sure those problems will bite you.)
10:13:41 <dmwit> PeakerWork: Well, this obviously isn't a serious project, so I'd go ahead and use lazy IO and worry about things when they come up.
10:13:42 <vixey> PeakerWork, are you using Iteratee
10:13:52 <PeakerWork> @hoogle Iteratee
10:13:53 <lambdabot> No results found
10:13:55 <PeakerWork> vixey: what's that?
10:13:59 <dmwit> PeakerWork: If it were serious, you'd be using ByteString, and then it would be easy to swap lazy and strict. ;-)
10:14:32 <PeakerWork> dmwit: I want the operational effect of laziness (reading one line at a time) but without the fuzzy semantics of unsafeInterleaveIO underneath
10:14:42 <PeakerWork> dmwit: is that not possible except with my own custom readLine-based solution?
10:14:54 <vixey> not in hoogle
10:16:13 <dmwit> PeakerWork: I believe that is basically correct.
10:17:41 <PeakerWork> vixey: not in Cabal either :(
10:17:58 <mib_19ty9w> applyAll :: [a -> b] -> a -> b
10:17:58 <mib_19ty9w> map g . applyAll fs = applyAll ... ?
10:18:11 <vixey> @free yourTeacherSucks :: [a -> b] -> a -> b
10:18:11 <lambdabot> (forall h. (forall k p. g . k = p . f                        =>                         h k = p)           =>            $map h xs = ys) => g . yourTeacherSucks xs = yourTeacherSucks ys . f
10:18:51 <vixey> someones being paid to put you through all this @free theorem crap
10:19:02 <dmwit> mib_19ty9w: That type looks wrong.
10:19:11 <dmwit> mib_19ty9w: Are you sure it isn't [a -> b] -> a -> [b]?
10:19:31 <mib_19ty9w> dmwit: you're right
10:19:47 <dmwit> ?free sequence :: [a -> b] -> a -> [b]
10:19:47 <lambdabot> (forall h. (forall k p. g . k = p . f                        =>                         h k = p)           =>            $map h xs = ys) => $map g . sequence xs = sequence ys . f
10:20:25 <mib_19ty9w> thanks
10:20:31 <dmwit> :t sequence
10:20:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:21:02 <dmwit> You don't need this ridiculous "applyAll" name when "sequence" will do and comes for free in the standard libraries. ;-)
10:21:25 <PeakerWork> what does "free" do?
10:21:30 <BONUS_> @pl \xs y -> map ($ y) xs
10:21:30 <lambdabot> flip (map . flip id)
10:21:37 <dmwit> PeakerWork: It generates theorems based on types.
10:21:49 <PeakerWork> Same as djinn?
10:21:52 <dmwit> PeakerWork: By applying the parametric polymorphism concept.
10:21:54 <vixey> no
10:21:59 <dmwit> PeakerWork: No, djinn writes code based on types.
10:22:06 <vixey> djinn doesn't take a type and produce equations
10:22:16 <PeakerWork> @djinn a -> a
10:22:16 <lambdabot> f a = a
10:22:23 <dmwit> ?free a -> a
10:22:23 <lambdabot> Extra stuff at end of line
10:22:29 <dmwit> ?free x :: a -> a
10:22:30 <lambdabot> f . x = x . f
10:22:50 <PeakerWork> Ah, why this theorem of all possible ones?
10:23:40 <vixey> how come you haven't seen @free before??
10:23:51 <PeakerWork> vixey: I've seen it a few times, but I haven't understood what it did
10:24:11 <vixey> I read the paper on how it works 3 times and I don't understand it either :/
10:24:15 <dmwit> PeakerWork: I believe it just does the simplest of all possible free theorems.
10:24:30 <dmwit> Where "simplest" means "free". ;-)
10:24:39 <PeakerWork> ?free x :: a -> b -> (b -> a)
10:24:39 <lambdabot> f . x y z = x (f y) (g z) . g
10:24:51 <Olathe> > let quiet f n = fun (if f n then show n else "\001") :: Expr in quiet even 2
10:24:53 <lambdabot>   2
10:24:54 <PeakerWork> ?free x :: (a -> b) -> (b -> a)
10:24:54 <lambdabot> g . h = k . f => f . x h = x k . g
10:24:56 <Olathe> > let quiet f n = fun (if f n then show n else "\001") :: Expr in quiet even 1
10:25:26 <dmwit> Olathe: cute
10:25:30 <Olathe> @let quietIf f n = fun (if f n then "\001" else show n) :: Expr
10:25:32 <lambdabot>  Defined.
10:25:36 <PeakerWork> Except for the  a -> a     theorem, I didn't understand any of the @free theorems here
10:25:38 <Olathe> > quietIf even 1
10:25:40 <lambdabot>   1
10:25:43 <Olathe> > quietIf even 2
10:25:46 <dmwit> PeakerWork: Try to understand the types you wrote.
10:25:58 <dmwit> PeakerWork: You'll see why the theorems are confusing then. =)
10:26:15 <PeakerWork> dmwit: Well, the first type forces it to create a (const a) func
10:26:17 <dmwit> (Try writing down a value with the type (a -> b) -> (b -> a) and you'll see what I mean.)
10:26:28 <dmwit> PeakerWork: Try again...
10:26:29 <PeakerWork> dmwit: the latter is just impossible
10:26:39 <dmwit> a -> b -> (b -> a) -- this is also impossible.
10:26:52 <dmwit> ?djinn a -> b -> (b -> a)
10:26:52 <lambdabot> f a _ _ = a
10:26:52 <PeakerWork> dmwit: why?  blah x y = const x
10:26:59 <dmwit> Ah, fine.
10:27:21 <PeakerWork> g . h = k . f => f . x h = x k . g       what does the "=>" mean here?
10:27:28 <dmwit> "implies"
10:27:29 <vixey> logical implication
10:27:40 <PeakerWork> what part of that is impossible? :-)
10:27:44 <dmwit> Rui: Hey.
10:27:57 <vixey> assume: g . h = k . f
10:28:04 <vixey> now: f . x h = x k . g
10:28:24 <Rui> dmwit: how can I change the error on (!!) to something else
10:28:35 <PeakerWork> vixey: how do you prove that's impossible?
10:28:45 <vixey> What's impossible?
10:28:50 <dmwit> Rui: What error?  Did you paste the code and error?
10:28:55 * Debolaz places his order for Real World Haskell.
10:29:06 <mpeter> i pirated real world haskell
10:29:18 <dmwit> mpeter: That was dumb, it's available for free on their website.
10:29:19 <PeakerWork> vixey: oh wait, if the type is uninhabitable, the theorem is just free to say whatever it wants?
10:29:25 <dmwit> PeakerWork: exactly
10:29:27 <Rui> actually nevermind dmwit ^^
10:29:35 <dmwit> =)
10:29:48 <vixey> ?free forall a. a
10:29:48 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
10:29:53 <Debolaz> I can't pirate it, because what I need is a paper copy. :-)
10:29:55 <PeakerWork> ?free x :: a -> b -> a
10:29:55 <lambdabot> f . x y = x (f y) . g
10:30:12 <vixey> ?free u :: forall a. a
10:30:12 <lambdabot> f u = u
10:30:39 <vixey> > const True undefined
10:30:40 <lambdabot>   True
10:30:42 <vixey> > undefined
10:30:43 <lambdabot>   * Exception: Prelude.undefined
10:30:51 <vixey> PeakerWork: ^ does that help ??
10:31:32 <dmwit> ?free const :: a -> b -> a
10:31:32 <lambdabot> f . const x = const (f x) . g
10:31:35 <PeakerWork> vixey: sorry, I still don't understand why "f u = u" holds, or why it chose to show that, or how it relates to (const True undefined = True)
10:31:50 <vixey> PeakerWork, I just showed that it didn't hold, f = const True, is my counterexample)
10:31:51 <PeakerWork> dmwit: what is g?
10:31:59 <oshyshko> what is the difference between (f1 $ f2 $ f3) and (f1 . f2 . f3)?
10:32:09 <luqui> Peaker, any function whatever
10:32:10 <dmwit> PeakerWork: Any function you like that makes that expression well-typed.
10:32:11 <PeakerWork> vixey: ah, so if the theorems it generates are non-true, you know the type is uninhabitable?
10:32:20 <vixey> luqui, now you are ignoring _|_ :P
10:32:33 <dmwit> oshyshko: the types ;-)
10:32:35 <vixey> PeakerWork, I wouldn't phrase it that way
10:32:36 <luqui> vixey, sorry, I just walked in
10:32:42 <maltem> oshyshko: the second one only works if f3 is a function (and works differently)
10:32:48 <dmwit> oshyshko: (f1 $ f2 $ f3) -> f1 (f2 (f3))
10:33:06 <dmwit> oshyshko: (f1 . f2 . f3) x -> f1 (f2 (f3 x))
10:33:07 <luqui> vixey, ah yes, of course.
10:33:07 * maltem cries about his dumb, dumb Java homework
10:33:15 <ttt--_> @type f $ a $ b
10:33:17 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Expr'
10:33:17 <lambdabot>     In the first argument of `($)', namely `a'
10:33:17 <lambdabot>     In the second argument of `($)', namely `a $ b'
10:33:22 <luqui> maltem, write a java code generator library for haskell
10:33:29 <luqui> I'd use it :-)
10:33:39 <dmwit> oshyshko: ($) is function *application*; (.) is function *composition*.
10:33:43 <ttt--_> @type f $ g $ a
10:33:45 <lambdabot>     Ambiguous type variable `b' in the constraints:
10:33:45 <lambdabot>       `SimpleReflect.FromExpr b'
10:33:45 <lambdabot>         arising from a use of `g' at <interactive>:1:4
10:33:50 <vixey> maltem, write an abstract class Animal with a method int legs(), define a Dog and a Pelican class that extend Animal
10:33:55 <luqui> @type ?f $ ?g $ ?a
10:33:57 <lambdabot> forall b a b1. (?a::a, ?g::a -> b1, ?f::b1 -> b) => b
10:34:08 <dmwit> oshyshko: One last way to say it: in the first, you are applying f2 to the value f3; in the second, you are applying f2 to the return value of f3.
10:34:14 <maltem> luqui: oh the problem is not only dumb Java but also the dumb tasks
10:34:23 <ttt--_> what does ?f do?
10:34:33 <dmwit> Ugh, you don't want to know.
10:34:38 <dmwit> Implicit parameters are gross.
10:34:42 <maltem> vixey: right, that's how these tasks look like, but it goes like that over 6 pages
10:34:44 <dmwit> ?go haskell implicit parameters
10:34:46 <vixey> luqui, I sketched out a very simple transform from haskell to java
10:34:51 <lambdabot> http://cvs.haskell.org/Hugs/pages/users_guide/implicit-parameters.html
10:34:51 <lambdabot> Title: Implicit parameters
10:34:51 <luqui> maltem, I know what you mean.  I can relate with a java class I took for dumb credit in a few years ago.
10:34:55 <dmwit> Now that we have the Reader monad...
10:35:05 <vixey> maltem, do you have a .txt of the problems?
10:35:06 <PeakerWork> it seems that:  f . const x = const (f x) . g      is a very convoluted way to say:  "const throws away its second argument" :)
10:35:22 <vixey> maltem, might be fun challenge to write a thing that automatically solves all of them
10:35:31 <ttt--_> > foldr f b [x,y,z]
10:35:34 <lambdabot>   f x (f y (f z b))
10:35:49 <luqui> Peaker, yep.  in the case of const, the free theorem tells you everything (in a seqless language)
10:36:07 <vixey> PeakerWork: that's the essence of it I think
10:36:16 <maltem> luqui: good to know this is not the only class of that style :)
10:36:30 <vixey> PeakerWork: the algorithm is pretty much convolvution on a relation that's trivially proved
10:36:41 <luqui> what, you thought stupid computer science classes with stupid problems were rare or something?
10:36:45 <maltem> vixey: http://verify.rwth-aachen.de/programmierungWS08/uebungen/blaetter/Uebung9.pdf
10:37:16 <luqui> lol, I don't speak that language :-)
10:37:19 <vixey> maltem, ah too hard
10:37:33 <maltem> heh
10:37:42 <luqui> public interface Weihnachtsartikel {
10:37:58 <luqui> UNREADABLE CODE!  =P
10:38:12 <luqui> it must be java
10:38:28 <maltem> That language mixture is unbearable even if you do know German
10:39:21 <nolrai_East> So if I wanted a data type to represent a checker board where things can lay either on the squares or the edges, how would I do that?
10:40:03 <luqui> nolrai_East, uh, a 2D array?
10:40:19 <Olathe> I'd have a 15x15 board and a function that tells you whether it's an edge or not.
10:40:23 <BONUS_> you couldjust use a 2D list and have the edges be the first/last row/column
10:40:42 <nolrai_East> Olathe: the edges between squares.
10:40:50 <BONUS_> ah
10:40:51 <BONUS_> oh
10:40:53 <Olathe> Right.
10:41:01 <Olathe> 8 squares, 7 edges.
10:41:15 <Olathe> Not sure if you want the meetings of edges to count.
10:41:30 <nolrai_East> Olathe:?
10:41:39 <nolrai_East> the vertexes?
10:41:56 <Olathe> Yes.
10:42:08 <nolrai_East> No
10:42:52 <Olathe> Ahh, then I'd probably use two boards, one for squares, one for edges.
10:43:11 <nolrai_East> Oh That totaly works Thanks!
10:43:13 <Olathe> Hmm, maybe three.
10:43:23 <nolrai_East> three?
10:43:25 <Olathe> One for horizontal edges, one for vertical.
10:43:41 <Olathe> Since there are eight horizontal per row, seven vertical.
10:43:55 <nolrai_East> yeah that makes sense.
10:44:00 <Olathe> And seven rows of horizontal, eight rows of vertical.
10:46:23 <nolrai_East> Thanks!
10:51:26 <Rui> is there a way to make a program insert :quit or :q into haskell and execute, causing haskell to close?
10:52:59 <maltem> Rui: how do you mean, insert :q into haskell?
10:53:02 <stepcut> Rui: :q is really just an interactive GHCi feature. To quit you would use System.Exit.exitWith
10:53:24 <maltem> ahh the ghci :q
10:53:29 * maltem was thinking of the vi one
10:53:50 <stepcut> maltem: similar effect ;)
10:53:59 <maltem> quite so
10:54:42 <ozy`> I'm sure the GHCi people didn't have vi in mind at all when they used :q for that purpose
10:55:00 <Rui> for a menu in a haskell based game I need to make. I have the option 4) Quit
10:55:09 <vixey> Rui, just return
10:55:09 <ozy`> total coincidence, naturally
10:55:19 <Rui> no way to actually shut down haskell? :p
10:55:23 <maltem> ozy`: naturally :)
10:55:25 <vixey> Rui, if you compile and run the actual program:  main = print "hello"
10:55:32 <vixey> Rui, once it printed "hello", it quits
10:55:44 <vixey> Rui, so you don't need any function for it
10:55:55 <stepcut> Rui: either design your program so it finishes normally, or use something from System.Exit like exitWith
10:56:12 <vixey> System.Exit is a C idiom isn't it
10:56:17 <dnul> im looking for an efficient way to know if a number its linear combination of others. if number is X and the factors are 5 7 13 then i want to know if there are x,y,z such that 5*x+7*y+13*z=X
10:56:37 <maltem> vixey: a Unix idiom I'd say
10:56:44 <stepcut> vixey: dunno, I think it throws an exception though to do it's dirty work
10:57:14 <maltem> Prelude> System.Exit.exitSuccess -- *** Exception: ExitSuccess
10:57:31 <Olathe> dnul: x = y = z = 1
10:57:51 <Rui> viexey: printing hello just prints it for me, it closes the program I was using, but I want the same effect that :q does, closes the actual terminal
10:57:58 <Olathe> dnul: If you mean that X factors to 5*7*13.
10:58:03 <stepcut> maltem: exactly. You only get the printed exception if you are using ghci though. Compiled programs don't do that
10:58:13 <Olathe> dnul: If not, you can take the gcd of the three and see if X is a multiple of it.
10:58:24 <stepcut> Rui: are you on Windows per chance?
10:58:26 <maltem> stepcut: yeah that was for demonstration, sort of
10:58:27 <dnul> Olathe: im sorry, i didnt mean factors
10:58:41 <dnul> Olathe: lets say, 5 7 13 are unrelated to X
10:58:52 <Rui> stepcut: yes
10:59:00 <maltem> dnul: you mean x, y, z are supposed to be integers?
10:59:06 <Olathe> > let omgDoesIt x = mod x (foldr1 gcd [5,7,13]) == 0 in omgDoesIt 20
10:59:08 <lambdabot>   True
10:59:11 <vixey> dnul, can't think of anything more efficient than repeated divMod'ding
10:59:11 <Olathe> Something like that.
10:59:12 <stepcut> Rui: closing the terminal is something windows specific I suspect.
10:59:24 <Olathe> dnul: So, there is a linear combination.
10:59:26 <dnul> Olathe: possitive integers such that 3*x+5*y..= X
10:59:41 <Olathe> dnul: Right.
10:59:55 <Olathe> dnul: Does my solution not fit what you're looking for ?
11:00:22 <vixey> > 5*3 + 7*0 + 13*0
11:00:24 <lambdabot>   15
11:00:28 <Olathe> > let omgDoesIt x = mod x (foldr1 gcd [2,20,40]) == 0 in omgDoesIt 3
11:00:30 <lambdabot>   False
11:00:38 <vixey> I think the solution should be  Just [4,0,0]
11:00:45 <ozy`> http://en.wikipedia.org/wiki/Linear_type <== wow that actually looks useful
11:00:46 <Olathe> So, 3 isn't a linear combination of 2,20,40.
11:00:51 <maltem> 0 is not a positive integer...
11:00:57 <ozy`> though not as useful as dependent types
11:01:01 <Olathe> You can get the actual combination fairly easily if you're looking for that.
11:01:04 <vixey> > let omgDoesIt x = mod x (foldr1 gcd [2,20,40]) == 0 in omgDoesIt 22
11:01:06 <lambdabot>   True
11:01:25 <vixey> > let omgDoesIt x = mod x (foldr1 gcd [2,5,7]) == 0 in omgDoesIt (2+5+7)
11:01:27 <lambdabot>   True
11:01:38 <vixey> > foldr1 gcd [2,5,7]
11:01:39 <lambdabot>   1
11:01:50 <vixey> > let omgDoesIt x = mod x (foldr1 gcd [2,5,7]) == 0 in omgDoesIt 3
11:01:52 <lambdabot>   True
11:01:55 <vixey> hah!
11:02:01 <ozy`> > (\x -> 0 == mod x $ foldr1 gcd [2,5,7]) (2 + 5 + 7)
11:02:03 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `Bool'
11:02:07 <ozy`> whoops
11:02:15 <vixey> Olathe, it's buggy right?
11:02:15 <Olathe> > let linComb xs y = zip xs (tail (scanr1 (*) xs)) in linComb [2, 20, 40] 2
11:02:17 <lambdabot>   [(2,800),(20,40)]
11:02:18 <Olathe> What is ?
11:02:25 <vixey> > let omgDoesIt x = mod x (foldr1 gcd [2,5,7]) == 0 in omgDoesIt 3
11:02:27 <lambdabot>   True
11:02:32 <vixey> that should be False shouldn't it?
11:02:34 <Olathe> What is ?No.
11:02:35 <Gracenotes_away> checks if all the numbers are relatively prime, essentially?
11:02:39 <Olathe> 5 - 2 = 3
11:02:47 <Gracenotes_away> oh hai..
11:02:50 <vixey> oh I see
11:02:50 <ozy`> @pl let omgDoesIt x = mod x (foldr1 gcd [2,5,7]) == 0 in omgDoesIt 3
11:02:50 <lambdabot> mod 3 (foldr1 gcd [2, 5, 7]) == 0
11:02:58 <vixey> I didn't consider negatives
11:03:38 <ozy`> @pl mod x (foldr1 gcd [2, 5, 7]) == 0
11:03:38 <lambdabot> mod x (foldr1 gcd [2, 5, 7]) == 0
11:03:41 <ozy`> grrr
11:03:53 <dnul> Olathe: hahah , i cant keep up
11:03:55 <dmwit> Maybe add a point:
11:04:08 <dmwit> ?pl \x->  mod x (foldr1 gcd [2, 5, 7]) == 0
11:04:08 <lambdabot> (0 ==) . flip mod (foldr1 gcd [2, 5, 7])
11:04:14 <ozy`> ((==0) . (`mod` (foldr1 gcd [2,5,7]))
11:04:19 <ozy`> > ((==0) . (`mod` (foldr1 gcd [2,5,7])) 3
11:04:20 <lambdabot>   <no location info>: parse error on input `;'
11:04:35 <ozy`> > ((==0) . (`mod` (foldr1 gcd [2,5,7]))) 3
11:04:37 <lambdabot>   True
11:04:39 <ozy`> cool
11:04:41 <maltem> compiz
11:04:43 <maltem> sry
11:05:15 <dnul> (0 ==) . flip mod (foldr1 gcd [2, 5, 7]) does not include 10*2 +0*5 + 0*7 , does it?
11:05:29 * maltem should install xmonad now to have a stable window manager again
11:05:44 <Olathe> > (0 ==) . flip mod (foldr1 gcd [2, 5, 7]) $ 20
11:05:46 <lambdabot>   True
11:05:48 <Olathe> Yes.
11:06:10 <Olathe> @hoogle (Integral a) => a -> a -> (a, a)
11:06:11 <lambdabot> Prelude divMod :: Integral a => a -> a -> (a, a)
11:06:11 <lambdabot> Prelude quotRem :: Integral a => a -> a -> (a, a)
11:06:11 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
11:06:19 <Olathe> Hmm...I wonder if it has extGCD.
11:07:24 <dmwit> #cerebrum looks like a failed experiment
11:07:48 * dmwit is just jealous that he didn't get invited
11:07:59 <cizra> dmwit: Not intelligent people?
11:08:04 <dnul> (0 ==) . flip mod (foldr1 gcd [2, 5, 7]) 1
11:08:16 <dnul> (0 ==) . flip mod (foldr1 gcd [2, 5, 7]) $ 1
11:08:24 <dmwit> cizra: Those people might be intelligent, but there sure isn't intelligent, open conversation going on there. =P
11:08:26 <vixey> you have to use >
11:08:26 <PeakerWork> flip f x = (`f` x)
11:08:37 <PeakerWork> dmwit: what is that channel?
11:08:39 <dnul> > (0 ==) . flip mod (foldr1 gcd [2, 5, 7]) $ 1
11:08:40 <lambdabot>   True
11:08:41 <cizra> dmwit: haha
11:08:43 <vixey> flip f y x = f x y
11:08:48 <dmwit> flip (+) x = (+x)
11:09:02 <Olathe> > let extGCD a b = if m == 0 then (0, 1) else (y, x - div a b) where m = mod a b; (x, y) = extGCD b m in extGCD 5 25
11:09:03 <dmwit> PeakerWork: Join it and find out.
11:09:04 <dnul> > foldr1 gcd [2,5,7]
11:09:05 <lambdabot>   (1,0)
11:09:07 <lambdabot>   1
11:09:14 <Olathe> > let extGCD a b = if m == 0 then (0, 1) else (y, x - div a b) where m = mod a b; (x, y) = extGCD b m in extGCD 5 27
11:09:17 <lambdabot>   (-4,-2)
11:09:22 <Olathe> Eww.
11:10:10 <Olathe> > let extGCD a b = if m == 0 then (0, 1) else (y, x - y*(div a b)) where m = mod a b; (x, y) = extGCD b m in extGCD 5 27
11:10:12 <lambdabot>   (11,-2)
11:10:18 <vixey> dmwit how did you hear about it
11:10:20 <Olathe> There we go.
11:10:23 <PeakerWork> dmwit: hah, so its a social experiment to see if people have, on average >=1 person that they think is smarter than them? :)
11:10:25 <Olathe> @let extGCD a b = if m == 0 then (0, 1) else (y, x - y*(div a b)) where m = mod a b; (x, y) = extGCD b m in extGCD 5 27
11:10:25 <lambdabot>   Parse error
11:10:28 <Olathe> @let extGCD a b = if m == 0 then (0, 1) else (y, x - y*(div a b)) where m = mod a b; (x, y) = extGCD b m
11:10:29 <lambdabot>  Defined.
11:10:38 <dmwit> vixey: /whois emma
11:10:42 <Olathe> Right, now to get extGCD for more than one argument.
11:10:50 <dmwit> vixey: I also learned about #sparkling-ponies that way! =D
11:11:23 <Olathe> > let extGCD' xs = zip xs (tail (scanr1 (*) xs)) in extGCD' [2, 20, 40] 2
11:11:26 <lambdabot>   Couldn't match expected type `t1 -> t'
11:14:20 <dnul> Olathe: I cant even understand what you are trying to do
11:15:12 <dnul> Olathe: i dont get what the GCD has to do with this...
11:16:57 <dmwit> dnul: Any set of numbers whose gcd is 1 can form any other number via linear combination.
11:17:27 <dmwit> (Assuming only integer coefficients.)
11:17:31 <dnul> dmwit: holy shit
11:17:36 <dnul> dmwit: haha , thx
11:20:41 <dnul> ah , i see it now
11:21:17 <dnul> any co-prime numbers can form the number 1 via linear combination and therefore any number ?
11:21:58 <dmwit> That is correct.
11:22:10 <vixey> dnul, proof?
11:22:27 <dnul> vixey: homework
11:22:30 <dnul> vixey: :P
11:22:34 <vixey> what ?
11:22:54 <dmwit> vixey: "left as an exercise for the energetic reader" ;-)
11:23:11 <vixey> dnul, wondering if you have got a proof of that
11:23:40 <dnul> vixey: haha , no way, i can try...
11:24:07 <dmwit> vixey: If no linear combination forms the number 1, then they are not coprime; the least positive linear combination will be a common factor.
11:24:08 <dnul> vixey: any coprime numbers GCD is 1
11:24:15 <PeakerWork> dmwit: does emma win some award for that channel list?
11:24:23 <dmwit> PeakerWork: I think she does!
11:24:39 <dmwit> "longest list of auto-joined ubuntu-related channels"
11:24:48 <Olathe> > let extGCD' xs = map fst rs ++ [snd $ last rs] where rs = scanl1 (\(a, b) (c, d) -> (b*c, b*d)).map (uncurry extGCD).zip xs.tail.scanr1 gcd $ xs in extGCD' [2*11, 2*13, 2*17]
11:24:49 <lambdabot>   [0,4,-3]
11:25:01 <Olathe> > 4*2*13 - 3*2*17
11:25:03 <lambdabot>   2
11:25:16 <dmwit> PeakerWork: Also, "flakiest connection," apparently.
11:25:19 <Olathe> @let extGCD' xs = map fst rs ++ [snd $ last rs] where rs = scanl1 (\(a, b) (c, d) -> (b*c, b*d)).map (uncurry extGCD).zip xs.tail.scanr1 gcd $ xs
11:25:21 <lambdabot>  Defined.
11:25:30 <vixey> dnul, and any numbers GCD is in their span?
11:26:06 <sbahra> wow @ emma
11:26:07 <dnul> vixey: sorry, what do you mean with span
11:26:21 <dmwit> dnul: "span" is the set of linear combinations
11:26:40 <vixey> dnul, span is the set of all linear combinations
11:26:41 <dmwit> vixey meant s/numbers/numbers'/
11:27:08 <vixey> dnul, should have just said, the for any set of numbers the GCD is a linear combination?
11:28:32 <Olathe> > let linComb xs y = if (null xs || rem y g /= 0) then Nothing else map (*(div y g)) (extGCD' xs) where g = foldr gcd 1 xs in linComb [5, 7, 13] 250
11:28:34 <lambdabot>   Couldn't match expected type `Maybe a' against inferred type `[a1]'
11:28:41 <Olathe> > let linComb xs y = if (null xs || rem y g /= 0) then Nothing else Just $ map (*(div y g)) (extGCD' xs) where g = foldr gcd 1 xs in linComb [5, 7, 13] 250
11:28:43 <lambdabot>   Just [0,500,-250]
11:29:03 <Olathe> > 0*5 + 500*7 - 250*13
11:29:06 <lambdabot>   250
11:29:10 <dnul> Olathe: ah now i understand... i dont know, i may the assumption that if you have 2 numbers x and y coprimes.... then if you start doing 2*x-y, 3*x-y you will get to 1 eventually....
11:29:26 <dnul> sorry, that vas for vixey,dmwit
11:29:32 <Olathe> Sure, but the function I just made will do it for noncoprimes, too, if it's possible.
11:29:37 <vixey> dnul, shouldn't it be x-y, then 2x-y, then x-2y, then ...
11:29:44 <Olathe> > let linComb xs y = if (null xs || rem y g /= 0) then Nothing else Just $ map (*(div y g)) (extGCD' xs) where g = foldr gcd 1 xs in linComb [2, 4, 8] 7
11:29:47 <lambdabot>   Just [7,0,0]
11:29:50 <Olathe> Eww.
11:30:06 <PeakerWork> why does it need to be wrapped in a list and in a Maybe?
11:30:12 <Olathe> > foldr gcd 1 [2, 4, 8]
11:30:14 <lambdabot>   1
11:30:16 <Olathe> Ahh.
11:30:20 <Olathe> > gcd 0 2
11:30:22 <lambdabot>   2
11:30:22 <vixey> PeakerWork, you know something that would work better?
11:30:29 <dnul> vixey: im just guessing , i think you eventually get to 1 both ways
11:30:30 <Olathe> > let linComb xs y = if (null xs || rem y g /= 0) then Nothing else Just $ map (*(div y g)) (extGCD' xs) where g = foldr gcd 0 xs in linComb [2, 4, 8] 7
11:30:32 <lambdabot>   Nothing
11:30:35 <Olathe> There :)
11:30:35 <vixey> dnul, I don't
11:30:37 <PeakerWork> vixey: I am just asking
11:30:43 <Olathe> > let linComb xs y = if (null xs || rem y g /= 0) then Nothing else Just $ map (*(div y g)) (extGCD' xs) where g = foldr gcd 0 xs in linComb [2, 4, 37] 7
11:30:45 <lambdabot>   Just [0,-63,7]
11:30:48 <PeakerWork> vixey: Do Nothing and Just []   mean distinct things?
11:30:49 <Gracenotes> does it use Euler's algorithm?
11:30:54 <vixey> PeakerWork, yes
11:31:00 <dnul> ok , thx u then
11:31:02 <Olathe> > -63*4 + 7*37
11:31:05 <lambdabot>   7
11:31:08 <sbahra> For the interested, http://www.dcbsdcon.org/
11:31:08 <Olathe> There we are.
11:31:09 <vixey> dnul, try 3 and 7
11:31:20 <Gracenotes> @src gcd
11:31:20 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
11:31:20 <lambdabot> gcd x y = gcd' (abs x) (abs y)
11:31:20 <lambdabot>    where gcd' a 0  =  a
11:31:20 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
11:31:22 <vixey> dnul, you get -1 going that way 3-7, 6-7, ..., but never 1
11:31:24 <dnul> 7 - 2*3
11:31:33 <Olathe> @let linComb xs y = if (null xs || rem y g /= 0) then Nothing else Just $ map (*(div y g)) (extGCD' xs) where g = foldr gcd 0 xs
11:31:36 <lambdabot>  Defined.
11:31:47 <dnul> vixey, ahh ok , you are right ....
11:32:09 <vixey> dnul, but still not sure whether the ghc of some numbers is always a linear combination
11:32:19 <vixey> gcd
11:32:28 <vixey> > gcd 4 6
11:32:29 <lambdabot>   2
11:32:39 <vixey> > gcd 7 8
11:32:40 <lambdabot>   1
11:32:46 <vixey> > gcd 10 20
11:32:48 <lambdabot>   10
11:34:31 <Olathe> vixey: The GCD of some numbers is always a linear combination of them.
11:34:48 <dmwit> vixey: Check the algorithm for computing the GCD.
11:34:57 <dmwit> vixey: It should be clear from there that it's a linear combination.
11:34:58 <vixey> Olathe, yeah I guess I got a proof of it now
11:34:59 <dmwit> ?src gcd
11:34:59 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
11:34:59 <lambdabot> gcd x y = gcd' (abs x) (abs y)
11:34:59 <lambdabot>    where gcd' a 0  =  a
11:34:59 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
11:35:17 * ski_ thinks `gcd 0 0' ought to be defined ..
11:35:22 <Olathe> extGCD' will give you it.
11:35:29 <Olathe> > extGCD' [5, 6, 7, 8]
11:35:30 <ski_> @index extGCD'
11:35:31 <lambdabot> bzzt
11:35:31 <lambdabot>   [0,0,-1,1]
11:35:37 <Olathe> Oh, I made it.
11:35:39 <vixey> ski_, as ?
11:35:51 <ski_> vixey : zero, of course :)
11:35:53 <Olathe> -- @let extGCD' xs = map fst rs ++ [snd $ last rs] where rs = scanl1 (\(a, b) (c, d) -> (b*c, b*d)).map (uncurry extGCD).zip xs.tail.scanr1 gcd $ xs
11:35:55 <dmwit> Well, there's an algorithm that uses a and (b - a) instead of a and (b `rem` a), which makes it even more obvious.
11:35:57 <vixey> what's the meaning of gcd x y = k,  largest k s.t. x|k and y|k ?
11:36:12 <Olathe> -- @let extGCD a b = if m == 0 then (0, 1) else (y, x - y*(div a b)) where m = mod a b; (x, y) = extGCD b m
11:36:19 <ski_> (zero is, after all, the largest element in the divisibility order on the naturals)
11:36:31 <dmwit> vixey: k|x and k|y, but otherwise yes.
11:36:57 <twanvl> > (1 `gcd` 0) `gcd` 0
11:36:59 <lambdabot>   1
11:37:03 <twanvl> > 1 `gcd` (0 `gcd` 0)
11:37:06 <lambdabot>   * Exception: Prelude.gcd: gcd 0 0 is undefined
11:37:09 <ski_> > let extGCD a b = if m == 0 then (0, 1) else (y, x - y*(div a b)) where m = mod a b; (x, y) = extGCD b m  in  extGCD 0 0
11:37:11 <lambdabot>   * Exception: divide by zero
11:37:13 <dmwit> vixey: Unless I've got those flipped around, as usual, in which case you're right.  I always get that one confused.
11:37:17 <ski_> > mod 5 0
11:37:17 <dnul> vixey , thats true
11:37:19 <lambdabot>   * Exception: divide by zero
11:37:35 <ski_> Olathe : obviously, `mod x 0' ought to be `x', too
11:38:15 <Olathe> Well, gcd 0 0 should be 0, I think.
11:38:32 <Olathe> You can't really go to wrong with that.
11:38:56 <nolrai_East> hey I cant build zlib-0.5.0.0. I get this error:
11:38:59 <nolrai_East> Preprocessing library zlib-0.5.0.0...
11:38:59 <nolrai_East> /usr/bin/ld: cannot find -lgmp
11:39:11 <nolrai_East> Any Ideas?
11:39:19 <vixey> install gmp
11:39:41 <ski_> mm_freak_ : compare `do x <- [1,2,3]; y <- [4,5,6]; return (x,y)' with `do y <- [4,5,6]; x <- [1,2,3]; return (x,y)'
11:40:10 <nolrai_East> vixey: How? What is gmp?
11:40:19 <sbahra> @google libgmp download
11:40:22 <ski_> (Olathe : maybe you could, if you assume the standard ordering instead of the divisibility ordering, in `largest' ..)
11:40:30 * sbahra spanks lambdabot 
11:40:37 <lambdabot> Plugin `search' failed with: thread killed
11:40:54 <ttt--_> @go libgmp download
11:40:59 <paper_cc> hm, libgmp is required by ghc
11:41:02 <lambdabot> http://gmplib.org/
11:41:02 <lambdabot> Title: The GNU MP Bignum Library
11:43:14 <nolrai_East> but I have installed ghc.
11:43:38 <vixey> nolrai_East, tried installing gmp yet?
11:43:52 <nolrai_East> doing so
11:46:57 <ski_> mm_freak : i call the differing results of those two to be due to "sequencing" of the "generators" ("nesting" of the "loops", if the syntax wasn't so associative)
11:47:49 <chrisdone> in a project do you typically import all the modules you use for a specific file, or import one module in every file which itself imports all the things you could possibly need in all the files?
11:48:55 <sbahra> Any good blogs/etc... for incorrect reasons as to why Haskell sucks?
11:49:08 <chrisdone> sbahra: most of them?
11:49:12 <sbahra> Pieces claiming it isn't ready for the real world, etc...
11:49:23 <sbahra> chrisdone, I am looking for something exceptionally stupid
11:55:07 <strandmp> Is there a fuction that takes a regex and returns a regex that matches the reverse strings that the orginal one did?
11:55:19 <vixey> what??
11:55:28 <vixey> oh
11:55:46 <vixey> the "reverse strings" like literally if the regex matches "foo" you want one that matches "oof"?
11:56:00 <vixey> or did you mean every string except "foo"?
11:56:06 <strandmp> yea
11:56:10 <strandmp> the first one
11:56:44 <strandmp> well what a *really* want is to be able to get the left most match in the first place. Matching reverses is the only thing i can think of
11:57:33 <vixey> left most match ?
11:57:37 <chrisdone> you mean nongreedy?
11:57:43 <strandmp> vixey: err right most match
11:57:47 <chrisdone> oh
11:57:49 <vixey> ok what's that?
11:57:53 <strandmp> but i would like it to be greedy
11:58:09 <vixey> yeah reversing seems like a good way
11:58:23 <vixey> and how do you represent regex?
11:58:35 <sbahra> Where can I get stats on how many times people have downloaded ghc from haskell.org?
11:58:53 <sbahra> s/people have downloaded ghc/ghc was downloaded/
12:01:36 <strandmp> vixey: Well just however the Regex.Posix library represents it.
12:01:47 <strandmp> vixey: Which is pretty much just a String in my case
12:02:29 <vixey> String ??
12:02:31 <vixey> ugh
12:03:03 <vixey> use data Regex = C Char | Seq Regex Regex | Alt Regex Regex | Kleene Regex
12:03:32 <mauke> good luck representing [ -~] with that
12:03:41 <vixey> what's [ -~]?
12:03:49 <mauke> a character class
12:03:53 <vixey> oh like .
12:04:10 <mauke> also, ^ and $ and capturing groups
12:04:12 <vixey> foldr1 Seq . map Char $ [minBound .. maxBound]
12:04:21 <wefwefj> Is there way to hide my IP address at IRC?
12:04:25 <mauke> yeah, that looks really efficient
12:04:31 <vixey> wefwefj, ask #freenode
12:04:32 <cizra> wefwefj: yes, cloaks
12:04:37 <Martijn> I would like regexes on things other than Chars
12:04:48 <vixey> ughhhhh
12:04:52 <vixey> anyway the point is:
12:05:10 <vixey> rev (C c) = C c; rev (Seq u v) = Seq (rev v) (rev u); ...
12:05:17 <vixey> it's possible to reveres
12:05:28 <mauke> the hardest part is probably writing the regex parser
12:05:43 <vixey> why would you do that? there is already an implementation
12:05:53 <mauke> where?
12:06:05 <vixey> ?where Regex.Posix
12:06:05 <lambdabot> I know nothing about regex.posix.
12:06:32 <PeakerWork> ?where Text.Regex.Posix
12:06:33 <lambdabot> I know nothing about text.regex.posix.
12:06:38 <PeakerWork> @hoogle regex
12:06:38 <lambdabot> package regex-base
12:06:38 <lambdabot> package regex-compat
12:06:38 <lambdabot> package regex-dfa
12:07:06 <dmwit> I have a regex representation and Posix-regex parser lying around here somewhere...
12:07:33 <b_jonas> @let rev x = rev1 0 x; rev1 r x | x <= 0 = r | True = rev1 (10 * r + mod x 10) (div x 10)
12:07:35 <lambdabot>  Defined.
12:07:38 <dmwit> But it seems like overkill to match in reverse.
12:07:44 <dmwit> Just reverse the string, then check for a match.
12:07:45 <strandmp> Hrm
12:07:52 <vixey> > rev 1235142
12:07:53 <mauke> dmwit: huh?
12:07:54 <lambdabot>   2415321
12:07:56 <dmwit> (i.e. don't reverse the regex... reverse the thing you're matching)
12:08:04 <mauke> dmwit: you need to reverse both
12:08:10 <dmwit> Oh?
12:08:24 <dmwit> I'm not sure I see why.
12:08:34 <mauke> how would you get the rightmost match?
12:09:11 <dmwit> Oh, I didn't see that part; I jumped in the middle.
12:09:22 <dmwit> Well, just use the standard libraries.
12:09:32 <dmwit> One of the overloadings returns a list of matches.
12:09:42 <dmwit> That and the "last" function ought to get you the right-most match, no?
12:09:47 <dmwit> Or am I oversimplifying again?
12:10:01 <dmwit> I probably am; probably earlier matches modify what matches later.
12:10:02 <vixey> ...
12:10:04 <dmwit> Man, that sucks.
12:10:05 <Plouj> yo guys
12:10:08 <cizra> Hey, how to search for old versions with cabal?
12:10:20 <Plouj> is there an online answers page for the Real World Haskell exercises?
12:11:10 <strandmp> vixey: So you are saying that this problem would be something id need to just roll my own regex reverser then right?
12:11:23 <strandmp> vixey: Itd be pretty easy if I restrict to just String
12:11:26 <cizra> Plouj: Not that I know of, but if you want the answers for the first couple of chapters, I could give you mine (=
12:11:35 <rwbarton> strandmp: how about something like  map (match regex) (reverse $ tails string)
12:11:47 <rwbarton> > tails "hello"
12:11:49 <lambdabot>   ["hello","ello","llo","lo","o",""]
12:11:52 <Plouj> cizra: chapters 1-4?
12:11:53 <mauke> heh, brute force
12:12:05 <vixey> strandmp, sounds liket hat would work wouldn't it
12:12:18 <rwbarton> strandmp: maybe add '^' to the beginning of the regex
12:12:23 <cizra> Plouj: 1-3, rather
12:12:26 <vixey> rwbarton, doesn't that give the _least greedy_ rightmost match
12:12:32 <Plouj> cizra: ok, that's cool too
12:12:38 <rwbarton> vixey: nobody has said what rightmost means :)
12:12:45 <Plouj> cizra: can you email them to ploujj at gmail.com?
12:12:59 <rwbarton> vixey: starting as far as possible to the right? ending as far as possible to the right? a match could be entirely contained within another match...
12:13:06 <cizra> Plouj: Um, won't IRC spamming do?
12:13:06 <vixey> rwbarton: I guessed:  if the regex is r  .*;r  is rightmost when .* is the longest possible
12:13:14 <Plouj> cizra: umm, sure
12:13:16 <Plouj> privately
12:13:33 <vixey> rwbarton, oh good point yeah
12:13:34 <rwbarton> vixey: In that case, I think that's what my pseudo-code does...
12:14:30 <rwbarton> vixey: also, you just provided a solution: replace r by .*(r) :)
12:26:19 <Plouj> how about this solution to the lastButOne exercize in RWH: lastButOne xs = if (null (tail (tail xs))) then head xs else lastButOne (tail xs) ?
12:26:46 <vixey> I don't like it
12:26:53 <cizra> Looks complicated
12:26:56 <cizra> My version is:
12:27:01 <cizra> penult l = head (drop 1 (reverse l))
12:27:07 <vixey> butOne (_:e:_) = Just e ; butOne _ = Nothing
12:27:15 <vixey> lastButOne = butOne . reverse
12:27:22 <Gracenotes> one hasn't been introduced to pattern matching yet at this point?
12:27:30 * vixey has :p
12:28:02 <Gracenotes> cizra: you'll need to reverse the list again
12:28:17 <cizra> Gracenotes: um, why?
12:28:19 <vixey> I think cizras one is fine
12:28:27 <Gracenotes> oh, wait, never mind.
12:28:40 <Gracenotes> I'm confusing this with the reimplentation of init
12:28:46 <roconnor> butOne l = do {(_:e:_) <- l; return l}
12:28:53 <roconnor> er
12:28:53 <roconnor> return e
12:28:55 <roconnor> butOne l = do {(_:e:_) <- l; return e}
12:29:25 <Olathe> > let penult [a, _] = a; penult (_:xs) = penult xs in penult [1..50]
12:29:27 <ziman> > let penult l = head (drop 1 (reverse l)) in penult [4]
12:29:29 <lambdabot>   49
12:29:29 <lambdabot>   * Exception: Prelude.head: empty list
12:29:32 <Gracenotes> cizra: yeah, it's fine
12:29:43 <Gracenotes> sorry :3
12:30:00 <cizra> What's that :3 smiley? Large moustache?
12:30:02 <vixey> oh right even better
12:30:14 <vixey> but n = "safe"Head . drop n
12:30:22 <vixey> lastButOne = but 1 . reverse
12:32:26 <dmwit> :t take 1 . drop 1 . reverse
12:32:27 <lambdabot> forall a. [a] -> [a]
12:32:41 <Olathe> > foldr (\(n, _) x = (n + 1, x)) (0, undefined) [1..5]
12:32:44 <lambdabot>   <no location info>: parse error on input `='
12:32:44 <Gracenotes> cizra: it's... hm, you can I describe it
12:32:48 <Plouj> cizra: the problem I have with your solution is that it uses funtions not introduced in the book up to that point
12:32:54 <Olathe> > foldr (\(n, _) x -> (n + 1, x)) (0, undefined) [1..5]
12:32:56 <lambdabot>       Occurs check: cannot construct the infinite type: b = (t, b)
12:32:56 <lambdabot>        Exp...
12:33:09 <Olathe> > foldr (\x (n, _) -> (n + 1, x)) (0, undefined) [1..5]
12:33:11 <lambdabot>   (5,1)
12:33:17 <Olathe> > scanr (\x (n, _) -> (n + 1, x)) (0, undefined) [1..5]
12:33:20 <lambdabot>   [(5,1),(4,2),(3,3),(2,4),(1,5),(0,* Exception: Prelude.undefined
12:33:31 <cizra> Plouj: http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
12:34:04 <Gracenotes> cizra: http://i42.tinypic.com/jl2oah.jpg
12:34:06 <Plouj> cizra: yes, I realize those function are all in Prelude
12:34:07 <Gracenotes> that kind of :3
12:34:16 <Olathe> > let dropR n = map snd.takeWhile ((<n).fst).scanr (\x (n, _) -> (n + 1, x)) (0, undefined)
12:34:18 <lambdabot>   <no location info>: parse error on input `;'
12:34:22 <Gracenotes> kittens can do :3 as well
12:34:22 <Olathe> > let dropR n = map snd.takeWhile ((<n).fst).scanr (\x (n, _) -> (n + 1, x)) (0, undefined) in dropR 2 [1..5]
12:34:24 <cizra> Plouj: It's (for me) the most logical way to write them. If I didn't have the standard functions, I'd write them myself (easy).
12:34:24 <lambdabot>   []
12:34:36 <Olathe> > let dropR n = map snd.takeWhile ((>n).fst).scanr (\x (n, _) -> (n + 1, x)) (0, undefined)
12:34:39 <lambdabot>   <no location info>: parse error on input `;'
12:34:48 <Olathe> > let dropR n = map snd.takeWhile ((>n).fst).scanr (\x (n, _) -> (n + 1, x)) (0, undefined) in dropR 2 [1..5]
12:34:51 <lambdabot>   [1,2,3]
12:35:07 <Plouj> cizra: of course it's more logical than mine :)
12:35:08 <Gracenotes> cizra: so much stuff is embedded into the language, duplicating the standard libraries isn't really that bad
12:35:12 <Olathe> @let dropR n = map snd.takeWhile ((>n).fst).scanr (\x (n, _) -> (n + 1, x)) (0, undefined)
12:35:14 <lambdabot>  Defined.
12:35:33 <Olathe> > let lastButOne = last.drop 1 in lastButOne [1..5]
12:35:36 <lambdabot>   5
12:35:37 <Olathe> > let lastButOne = last.dropR 1 in lastButOne [1..5]
12:35:40 <lambdabot>   4
12:35:57 <Gracenotes> not duplicating exactly, but mirroring the way built-in functions do something... sort of.
12:36:35 <Gracenotes> > last lbo = last . init in lbo [1..10]
12:36:36 <lambdabot>   <no location info>: parse error on input `='
12:36:41 <Gracenotes> > let lbo = last . init in lbo [1..10]
12:36:43 <lambdabot>   9
12:37:09 <vixey> Plouj, sort of weird/unproductive being so sequential imo
12:37:13 <Gracenotes> it does go through the list twice, and it's possible to implement it without doing so.
12:38:25 <sjanssen> Gracenotes: it doesn't really traverse the list twice
12:38:39 <Gracenotes> oh, I suppose I'm not thinking lazily enough
12:38:47 <sjanssen> yep
12:39:15 <sjanssen> this would probably be a bit more efficient: lastButOne [x, _] = x; lastButOne (x:xs) = lastButOne xs
12:39:36 <Olathe> Ahh, yes, init is nice.
12:39:48 <sjanssen> @src init
12:39:49 <lambdabot> init [x]    = []
12:39:49 <lambdabot> init (x:xs) = x : init xs
12:39:49 <lambdabot> init []     = undefined
12:40:01 <sjanssen> @src last
12:40:01 <lambdabot> last [x]    = x
12:40:01 <lambdabot> last (_:xs) = last xs
12:40:01 <lambdabot> last []     = undefined
12:40:37 <Gracenotes> so last would prompt the evaluation of xs, which would be init xs
12:41:00 <vixey> weird idea occured to me,
12:41:11 <Gracenotes> and the evaluations would go back and forth, in a sense
12:41:16 <vixey> you could have lazy evaluation on terms of kind *, and strict eval on terms of kind []
12:41:25 <sjanssen> Gracenotes: yeah
12:41:42 <vixey> so you define things like,  Integer :: []
12:41:42 <sjanssen> vixey: [] isn't a kind
12:41:51 <vixey> sjanssen, that's why I'm inventing it
12:41:53 <sjanssen> oh, you're overloading that
12:42:08 <sjanssen> vixey: choose something other than [], so we don't confuse it with the list type/data constructor
12:42:11 <vixey> let's call it @ or something then, I forgot that [] is confusingly similar to list
12:42:18 <Gracenotes> sometimes I wish ghci told you about what gets evaluated when
12:42:19 <vixey> yeah sorry about that
12:42:27 <ddarius> sjanssen: She is probably using an asciification of a square.
12:42:44 <sjanssen> Gracenotes: you can use the ghci debugger to do that, to some extent
12:42:48 <vixey> [] is the best I can do for a box
12:42:59 <Gracenotes> sort of, but it might get tedious for large programs
12:43:22 <vixey> anyway , I wonder if this would fly, maybe you could totally erase strictness annotations with it
12:43:45 <sjanssen> vixey: I'm not really sure how that would work
12:43:49 <sjanssen> what is the kind of Int?
12:43:58 <vixey> well currently we have
12:43:59 <sjanssen> (answer: it now has two kinds)
12:44:00 <vixey> :k Integer
12:44:01 <lambdabot> *
12:44:11 <vixey> but if you *instead* had Integer :: @
12:44:35 <sjanssen> would this be a property of all Integer, or can you pick and choose?
12:44:37 <vixey> then an application Integer -> a, would be forced to fully evaluated the Integer before applying it
12:44:52 <vixey> yes every Integer, and every data type you define in @
12:44:52 <sjanssen> eg. (1 :: Integer :: @), or data Integer :: @ = ...?
12:44:57 <Gracenotes> > let loop [] = return []; loop (x:xs) = do { (i, j) <- get ; put (i+1, j+1) ; x1 <- loop xs ; return ((x, i):x1) }; (r, (k, len)) = runState (loop "order") (len, 0) in r
12:45:00 <lambdabot>   [('o',5),('r',6),('d',7),('e',8),('r',9)]
12:45:00 <vixey> 1 :: Integer :: @
12:45:04 <sjanssen> hmm
12:45:20 <Gracenotes> this example was given yesterday, but its order of evaluation is somewhat cryptic
12:45:21 <vixey> so for something like length :: [a] -> Integer, you'd not have to write bang patterns I suspect
12:45:26 <sjanssen> what about container types, which have kind * -> *?
12:45:39 <Gracenotes> at one point there's a thunk of (len+1+1+...+1), where the number of 1's is the length of the list
12:45:40 <vixey> container ?
12:45:46 <vixey> ok like [] :: * -> * ?
12:45:54 <sjanssen> vixey: well, any higher kinded thing
12:45:55 <Gracenotes> rather confuzzling.
12:46:07 <sjanssen> can they contain both kinds of data?
12:46:26 <vixey> sjanssen, well currently [Integer] would be a kind error, but I suppose you could define list like:
12:46:34 <vixey> data [] :: k -> k where
12:46:38 <vixey>  [] :: [k]
12:46:42 <sjanssen> hmm
12:46:54 <vixey> hm... that shouldn't be a k
12:46:58 <vixey>  [] :: [a]
12:47:00 <sjanssen> IIRC, kind polymorphism causes problems with decidability in the type checker
12:47:29 <vixey> if kind polymorphism does cause decidability you'd just be forced to define []' :: @ -> @
12:47:44 <cizra> Hey, how to use the Ordering data type? I'd like my function to return (a <=> b) :: Ordering
12:48:11 <vixey> undecidability*
12:48:16 <sjanssen> > LT -- use it like so
12:48:16 <mauke> cizra: that function is called 'compare'
12:48:16 <cizra> I can do a case, of course, but…
12:48:17 <lambdabot>   LT
12:48:29 <sbahra> Ordering == Ord?
12:48:37 <Saizan> ?src Ordering
12:48:38 <lambdabot> data Ordering = LT | EQ | GT
12:48:40 <sjanssen> sbahra: Ordering is a data type used in the Ord class
12:48:42 <mauke> @src Ord
12:48:42 <lambdabot> class  (Eq a) => Ord a  where
12:48:42 <lambdabot>     compare      :: a -> a -> Ordering
12:48:42 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
12:48:42 <lambdabot>     max, min         :: a -> a -> a
12:48:44 <cizra> mauke: Thanks!
12:48:52 <sbahra> Ah, ok.
12:49:50 <Gracenotes> cizra: all you need to implement is compare, though
12:50:42 <cizra> Gracenotes: Why implement it. I just called it.
12:51:42 <mauke> cizra: btw, are you a perl programmer?
12:51:47 <Gracenotes> ah, my mind is really on short circuit today
12:52:16 <Gracenotes> if you want to make a data type available to be used with >, <=, and so on, then you need to implement compare for it
12:52:48 <Gracenotes> or have it derive Ord, if the order isn't special or anything
12:52:56 <cizra> mauke: no, why?
12:53:02 <Gracenotes> but it seems you're not actually doing that, but rather using an already-implement compare method. nvm...
12:53:05 <cizra> mauke: Do I look bearded and depressed?
12:53:15 <cizra> mauke: Oh, <=>. Ruby has it.
12:53:38 <mauke> how does ruby's sort() work?
12:53:56 <Botje> magic!
12:54:34 <mauke> consider sort { length $b <=> length $a || $a cmp $b } @foo
12:54:38 <cizra> mauke: I dunno, but <=> on strings returns values like strcmp()
12:54:45 <mauke> I don't think that'd work in ruby because 0 is true there
12:57:00 <vixey> I wonder if anyone has notes on kind polymorphism?
12:57:52 <chrisdone> @hoogle maybeTolist
12:57:53 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
12:58:05 <chrisdone> @hoogle listToMaybe
12:58:05 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
12:58:13 <vixey> sjanseen, any idea if you read that result in some paper or .?
12:58:18 <chrisdone> > listToMaybe [1..3]
12:58:20 <lambdabot>   Just 1
12:58:25 <vixey> sjanssen*
12:58:29 <sjanssen> vixey: I have no idea where I read it
13:00:16 <Gracenotes> > (maybeToList Nothing, maybeToList $ Just 4)
13:00:20 <lambdabot>   ([],[4])
13:00:38 <vixey> sjanssen, ah I bet it was about polymorphism in the style  k could be * or * -> *
13:00:41 <vixey> or (* -> *) -> * etc
13:01:19 <sjanssen> vixey: possibly
13:01:22 <sjanssen> @kind (->)
13:01:23 <vixey> I'd not be surprised if that way lies undecidability
13:01:24 <lambdabot> ?? -> ? -> *
13:01:51 <sjanssen> vixey: you could do something like ??, which can either be # or *
13:02:01 <sjanssen> GHC can handle that, at least
13:02:06 * vixey nod
13:02:28 * vixey just checking how does DDC do lazy/strict
13:02:34 <sjanssen> DDC?
13:02:43 <vixey> http://www.haskell.org/haskellwiki/DDC
13:02:45 <ddarius> vixey: The Omega paper should have some information on kind polymorphism and references to other papers.
13:02:57 <vixey> ddarius, aha good idea thanks
13:03:23 <vixey> (DDC uses SICP style DELAY without the FORCE)
13:03:30 <vixey> implicit FORCE
13:03:45 <sjanssen> what's the type of delay?
13:04:12 <vixey> in Scheme, no type but it shoves the thing in a lambda-box and puts that inside a vector-box
13:04:23 <sjanssen> right, but in DDC
13:05:39 <vixey> I can't see any types on this page but I don't think it's doing anything observable language-level
13:06:08 <vixey> there's no user manual
13:06:51 <chrisdone> @hoogle (b -> c) -> (a -> m b) -> a -> m c
13:06:52 <lambdabot> No results found
13:07:14 <cizra> interspers :: a -> [[a]] -> [a]
13:07:14 <cizra> interspers _ [] = []
13:07:21 <chrisdone> @hoogle Monad m => (b -> c) -> (a -> m b) -> a -> m c
13:07:22 <cizra> -- Why doesn't this kind of thing work? )=
13:07:22 <lambdabot> No results found
13:07:50 <dmwit> cizra: What are you talking about?
13:08:02 <dmwit> (What doesn't work?)
13:08:03 <cizra> dmwit:     Occurs check: cannot construct the infinite type: a = [a]
13:08:04 <chrisdone> is there a short-hand for this?
13:08:11 <chrisdone> maybe for Functor?
13:08:26 <dmwit> cizra: The error is in your other branch, then.
13:08:48 <sjanssen> @pl \f g x -> fmap f (g x)
13:08:48 <lambdabot> (.) . fmap
13:09:04 <chrisdone> :t \f g x -> fmap f (g x)
13:09:06 <lambdabot> forall t a b (f :: * -> *). (Functor f) => (a -> b) -> (t -> f a) -> t -> f b
13:09:10 <cizra> dmwit: a sec…
13:09:12 <dmwit> > let interspers :: a -> [[a]] -> [a]; interspers _ [] = [] in interspers "hey" []
13:09:14 <lambdabot>   []
13:10:04 <chrisdone> sjanssen: I just wrote `(foo <$>) . bar' but it seems there should be one like `foo <^$> bar' or something, you know?
13:10:06 <ik> cizra: real world haskell?
13:10:23 <vegai> mm, cabal installing HDBC-postgresql on ghc-6.10 is nasty
13:10:36 <vegai> it demands version 1.2 of cabal ;-/
13:11:04 <cizra> ik: yes
13:11:12 <ik> cizra: that kept bothering me.
13:11:22 <chrisdone> sjanssen: or not?
13:11:26 <ik> I was confused about types I guess.
13:11:39 <sjanssen> chrisdone: doesn't seem like such a common pattern
13:11:46 <vixey> ?where implementations
13:11:46 <lambdabot> I know nothing about implementations.
13:11:49 <vixey> ?wiki implementations
13:11:50 <lambdabot> http://www.haskell.org/haskellwiki/implementations
13:12:24 <ik> cizra: what's your other branch look like?
13:13:03 <ik> interspers t (x:xs) = x ++ [t] ++ interspers t xs
13:13:16 <chrisdone> sjanssen: mmkay
13:13:25 <vixey> @src intersperse
13:13:25 <lambdabot> intersperse _   []     = []
13:13:25 <lambdabot> intersperse _   [x]    = [x]
13:13:25 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
13:13:29 <dmwit> x ++ t : interspers t xs
13:13:37 <dmwit> oops
13:14:35 <cizra> @type intersperse
13:14:36 <lambdabot> forall a. a -> [a] -> [a]
13:14:46 <cizra> Note that this intersperse is different than the one RWH wants!
13:16:12 <ik> inconveniently, they gave it the same name ^_^
13:17:49 <cizra> > interspers :: a -> [[a]] -> [a]
13:17:49 <cizra> > interspers _ [] = []
13:17:49 <cizra> > interspers c (x:xs) = x ++ [c] ++ (intersperse c xs)
13:17:51 <lambdabot>   <no location info>: parse error on input `='
13:17:52 <lambdabot>   <no location info>: parse error on input `='
13:17:52 <lambdabot>   Not in scope: `interspers'
13:18:14 <cizra> Gah. Well, for some weird reason the second line gives the a = [a] error )=
13:19:01 <Botje> cizra: you need to define it all at once
13:19:10 <cizra> Botje: )=
13:19:14 <cizra> Why?
13:19:30 <Botje> ghci is just weird like that.
13:19:31 <cizra> Botje: ik shew me a version that worked, defined with guards.
13:20:24 <baaba> > let intersp' _ [] = []; intersp' c (x:xs) = x ++ [c] ++ (intersp' c xs) in intersp' ',' "hello"
13:20:25 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
13:20:42 <Botje> oh?, :/
13:20:56 <vixey> > let intersp' _ [] = []; intersp' c (x:xs) = x ++ [c] ++ (intersp' c xs) in intersp' "," "hello"
13:20:58 <lambdabot>   Couldn't match expected type `[[Char]]'
13:21:10 <Botje> oh.
13:21:11 <baaba> oh
13:21:11 <baaba> duh
13:21:17 <baaba> > let intersp' _ [] = []; intersp' c (x:xs) = [x] ++ [c] ++ (intersp' c xs) in intersp' ',' "hello"
13:21:19 <lambdabot>   "h,e,l,l,o,"
13:21:32 <baaba> you'd probably want instead:
13:21:38 <cizra> baaba: that's the wrong intersperse
13:21:38 <baaba> or wait
13:21:44 <ik> Not the same thing as what rwh is asking for, though.
13:21:49 <cizra> > let intersp' _ [] = []; intersp' c (x:xs) = [x] ++ [c] ++ (intersp' c xs) in intersp' ',' [[1, 2], [3, 4]]
13:21:50 <lambdabot>   Couldn't match expected type `Char' against inferred type `[a]'
13:21:53 <baaba> that's what you tried to define :P
13:21:58 <cizra> > let intersp' _ [] = []; intersp' c (x:xs) = [x] ++ [c] ++ (intersp' c xs) in intersp' 9 [[1, 2], [3, 4]]
13:21:59 <lambdabot>       No instance for (Num [t])
13:21:59 <lambdabot>        arising from the literal `9' at <inter...
13:22:16 <cizra> > let intersp' _ [] = []; intersp' c (x:xs) = x ++ [c] ++ (intersp' c xs) in intersp' 9 [[1, 2], [3, 4]]
13:22:17 <ik> RWH basically wants concat but with a separator in there
13:22:17 <lambdabot>   [1,2,9,3,4,9]
13:22:42 <ik> intersp ',' ["foo","bar","baz"]   -
13:22:44 <ik> d'oh
13:22:47 <baaba> oh right
13:22:51 <ik> -- should be "foo,bar,baz"
13:22:52 <cizra> OK, that's what I want
13:23:09 <cizra> So you say it can't be written with pattern matching and type declarations?
13:24:01 <dmwit> Uh, what?
13:24:08 <Elly> what?
13:24:08 * ik thinks the topic is a parse error :(
13:24:18 <vixey> > ["Real World Haskell: out now", "Haskell News: http://reddit.com/r/haskell" "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]
13:24:19 <lambdabot>   Couldn't match expected type `t -> [Char]'
13:24:25 <dmwit> cizra: You just defined it with pattern matching and type declarations.
13:24:29 <ik> Isn't there a comma missing?
13:24:33 <vixey> > ["Real World Haskell: out now", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]
13:24:34 <cizra> dmwit: lemme paste my code
13:24:35 <lambdabot>   ["Real World Haskell: out now","Haskell News: http://reddit.com/r/haskell",...
13:24:38 <Elly> yeah, there is a comma missing
13:24:39 <vixey> well noticed
13:24:39 <cizra> interspers :: a -> [[a]] -> [a]
13:24:39 <cizra> interspers _ [] = []
13:24:39 <cizra> interspers c (x:xs) = x ++ [c] ++ (intersperse c xs)
13:24:42 <ik> ^_^
13:25:02 <baaba> @let intersperse' :: a -> [[a]] -> [a]; intersperse' _ [] = []; intersperse' c (x:xs) = x ++ [c] ++ (intersperse' c xs)
13:25:03 <cizra> dmwit: This one doesn't work, for some weird reason.
13:25:04 <lambdabot>  Defined.
13:25:11 <baaba> :t intersperse'
13:25:12 <lambdabot> forall a. a -> [[a]] -> [a]
13:25:18 <mauke> seems to work here
13:25:32 <baaba> > intersperse' 9 [[1, 2], [3, 4]]
13:25:33 <dmwit> cizra: Are you sure?
13:25:34 <lambdabot>   [1,2,9,3,4,9]
13:25:35 <cizra> GHC 6.8, gives this error message:
13:25:46 <cizra> or, rather, :l in ghci
13:25:54 <cizra>     Occurs check: cannot construct the infinite type: a = [a]
13:25:54 <cizra>     When generalising the type(s) for `interspers'
13:26:03 <dmwit> Check that you've written your type annotation correctly.
13:26:09 <mauke> cizra: you misspelled "interspers"
13:26:13 <dmwit> ah
13:26:17 <dmwit> yup =)
13:26:19 <cizra> doh.
13:26:23 * cizra feels dumb now
13:26:34 <Gracenotes> ++ is right associative, right?
13:26:55 <Gracenotes> er, has right infixity
13:27:07 <pumpkin> infixr 5 ++
13:27:07 <Gracenotes> apparently it does.
13:27:29 <Gracenotes> good, so it's as effective as it can be
13:27:41 <rgr> Reading "learnyouhaskell" it says that haskell has to step through each element on the left side of "++" when appending strings. Why is that?
13:27:55 <pumpkin> becaue it's a linked list
13:27:55 <baaba> well you might do x ++ (c:(intersperse' c xs))
13:28:06 <baaba> i guess the outer parens are redundant
13:28:12 <ozy`> rgr: because lists are immutable. you can build onto the left side, but not the right side
13:28:15 <rgr> pumpkin: so what? it doesnt maintain a pointer to last?
13:28:23 <sbahra> rgr, stepping through doesn't mean things are not lazily evaluated.
13:28:23 <pumpkin> rgr: nope
13:28:27 <vixey> ozy`, hehe "lists" are immutable
13:28:49 <baaba> rgr, each node has a pointer to the next node
13:28:56 <sbahra> rgr, no, it doesn't...ifyou want O(1) append look at "dlist" on hackage.haskell.org
13:29:01 <Gracenotes> Haskell really can't keep an internal pointer to the last element of a list, which would be more efficient if Haskell were not lazy
13:29:12 <rgr> I know how linked lists work, was just wondering why.
13:29:29 <vixey> Gracenotes: what do you mean? (list, last list)
13:29:30 <rgr> Interesting answers.
13:29:32 <pumpkin> rgr: well lists can be infinite, so it's hard to keep a pointer to the last element
13:29:35 <baaba> it's always this way when you have a singly linked immutable list
13:29:36 <sbahra> rgr, Haskell is lazy. Do you know what this means?
13:29:39 <rgr> "can be".
13:29:44 <rgr> anyway, thanks.
13:29:55 <vixey> rgr, "can be".?
13:29:58 <sbahra> rgr, for example, [1 ..] is a valid type in Haskell.
13:30:06 <sbahra> s/type//
13:30:07 <baaba> value you mean
13:30:15 <vixey> even if you had a pointer to the last element... .what would you do it with it?
13:30:17 <rgr> and you would not be able to append to an infinite list anyway.
13:30:20 <sbahra> baaba, yes.
13:30:22 <rgr> what?
13:30:28 <vixey> baaba
13:30:28 <sbahra> rgr, that isn't my point...
13:30:50 <baaba> vixey
13:30:56 <sbahra> rgr, and you can for sure append to infinity (look at mathematical operations on omega). But my point was really about laziness.
13:30:59 <vixey> baab, even if you had a pointer to the last element... .what would you do it with it?
13:31:01 <cnwdup> @src break
13:31:01 <lambdabot> break p =  span (not . p)
13:31:03 <baaba> huh?
13:31:05 <pumpkin> rgr: but it's not always possible to tell on the fly whether a list is "infinite" or not, so it's not as easy as saying "well, if it's infinite, don't keep pointer to last element, otherwise do"
13:31:06 <cnwdup> @src span
13:31:06 <lambdabot> Source not found. Sorry.
13:31:09 <sbahra> rgr, so do you know what laziness is?
13:31:11 <baaba> i wasn't talking about a pointer to the last element
13:31:16 <rgr> vixey: I guess if I had a pointer to the last element I would not want to step through a million elemetns to find the last one :-; Just at a guess ..
13:31:22 <rgr> sbahra: yes.
13:31:23 <sbahra> pumpkin, sometimes better to have 1 cook in the kitchen.
13:31:31 <rgr> But I see what you mean, thanks!
13:31:35 <sbahra> rgr, ok, so that is one reason why lists work this way.
13:31:40 <baaba> i just mentioned that doing list concatenation means you have to copy the left side whenever you have an immutable singly linked list type
13:31:45 <sbahra> rgr, you might be interested in checking out Arrays and dlist.
13:31:49 <Gracenotes> vixey: hm, you're right. sometimes I forget how simple lists really are, i.e. a:b:c:d:e:[]
13:32:13 <rgr> sbahra: but lazy does not mean not instantiated. if it HAS been evaluated I dont see why a last pointer can not be kept. But I will look at that again when I know about haskell some more.
13:32:14 <Gracenotes> in other programming languages with mutable pointers, it would make more sense...
13:32:17 <sbahra> gonads of monads
13:32:25 <pumpkin> sbahra: he originally asked me :P not sure it's justified to ask me to shut up
13:32:36 <sbahra> pumpkin, I asked you to shut up?
13:32:51 <dmwit> rgr: Lists are immutable.
13:32:56 <rgr> I think he was referring to the cooks in the kitchen comment
13:33:03 <dmwit> rgr: So, for sharing.
13:33:10 <dmwit> rgr: You can share the end of a list, but not the beginning.
13:33:28 <dmwit> rgr: Because each element can point to *exactly* one next element -- and this includes the termination indicator.
13:33:55 <dmwit> rgr: So, for appends, you must copy right up to the termination indicator... but *not* copy the link to the termination indicator.
13:34:17 <dmwit> rgr: If you were to do immutable linked-list append in any other language, strict or otherwise, you would run into this exact same problem.
13:34:23 <dmwit> rgr: There's nothing special about Haskell here.
13:34:54 <sbahra> That's mostly right. :-P You could implement immutable lists with O(1) append.
13:35:08 <dmwit> sbahra: eh?
13:35:16 <Saizan> you'd have to do something like DiffArray
13:35:18 <sbahra> If you're willing to waste a page of memory (or multiple of) for every single item you insert and are willing to grant whoever is managing the linked list ring 0 access.
13:35:19 <dmwit> O(1) amortized time?
13:35:23 * sbahra nods at Saizan 
13:35:38 <dmwit> ah
13:35:57 <dmwit> That's just shoving the mutable linked-list bit down into the OS. =)
13:36:01 <Saizan> but you don't want that extra overhead by default
13:36:22 <dmwit> Also, ring 0?  Who uses Windows?
13:36:34 <sbahra> dmwit, what does ring 0 have to do with Windows?
13:36:34 <alsonk> anyone know why I get "cabal: There is no installed version of ghc-prim" on "cabal install"?
13:36:38 <alsonk> using 6.8
13:36:56 <alsonk> Saizan: thanks for the reply on the cabal install post.  helpful stuff.
13:36:57 <sbahra> dmwit, what do you like to call "ring 0"? :-P
13:36:59 * dmwit admits that he merely assumed it was a Windows thing because he had heard it used in conjunction with Windows, but not with *nix.
13:37:15 <sbahra> I see.
13:37:26 <Saizan> alsonk: np :)
13:38:17 <Saizan> alsonk: isn't ghc-prim new in ghc-6.10 ?
13:38:18 <PeakerWork> that what is a Windows thing?
13:38:24 <sbahra> dmwit, but don't even need so much OS to handle it in a single application.
13:38:37 <ddarius> dmwit: Ring 0 is an x86 term.
13:38:40 <alsonk> Saizan: I think that it is new in 6.10.  I guess that I can't use Cabal 1.6 with 6.8...
13:38:41 <sbahra> dmwit, you can implement them using TLS, too.
13:39:01 <sbahra> ddarius, are you sure? I recall seeing it in some UltraSPARC documentation a long time ago.
13:39:15 <Saizan> alsonk: Cabal 1.6 still supports ghc-6.4.2
13:39:27 <ddarius> sbahra: Well, it's probably used several places for similar things.
13:39:38 <Saizan> alsonk: maybe the particular package you're trying to install is 6.10 only?
13:39:56 <sbahra> ddarius, yes.
13:40:02 <alsonk> Saizan: I've tried on a couple of packages.  None are 6.10 specific
13:40:30 <alsonk> I'm using 6.8.2, Cabal 1.6 and cabal-install 0.6.1 on Debian
13:40:31 <alsonk> weird
13:40:41 <alsonk> "cabal build" works fine
13:40:49 <alsonk> "cabal configure" works fine, too
13:41:08 <PeakerWork> Does anyone use Rings 1,2?  Does anyone use Intel's "segments"?
13:41:49 <Saizan> alsonk: can you try cabal clean and then cabal install -v, pasting the output somewhere?
13:42:03 <alsonk> Saizan: will do
13:42:14 <sbahra> Peaker, well, the concepts...yes (of Rings 1,2).
13:42:32 <sbahra> Peaker, I'm not sure if I'm able to call them "Intel terms" or "x86 terms" though, not sure of their origins.
13:42:44 * sbahra is too young to have had practical experience dating that far back ;-p
13:44:00 <alsonk> Saizan: hpaste here http://hpaste.org/13389
13:46:33 <Martijn> Is it true that only pattern matching triggers evaluation?
13:47:00 <vixey> Martijn, it's not clear what evaluation means
13:47:03 <mauke> I think it's the runtime system (specifically, output) that triggers evaluation
13:47:04 <ddarius> Peaker: I think segments are used a tiny bit somewhere.  I don't think anything of note uses rings 1 and 2, but I'm far from an expert on such things.
13:47:05 <sbahra> Martijn, could you restate your question?
13:47:12 <Saizan> alsonk: so that's trying to build cabal-install with cabal-install? and yeah "cabal configure" works because it merely checks if the dependencies are installed rather than trying to see if you can install them from hackage
13:47:18 <Martijn> Perhaps I should say reduction instead
13:47:44 <Martijn> Does that help?
13:48:11 <sbahra> Any modern processor that provides some sort of protected environment implements the concept of rings (some better than others).
13:48:32 <sbahra> Martijn, well, what do you mean "only patterm matching"?
13:48:47 <ddarius> sbahra: The 286+ has specific protection levels 0-3.
13:49:12 <Martijn> sbahra: for example in f (x:xs) = ...
13:49:36 <vixey> Martijn: reduction is not only pattern matching
13:49:49 <sbahra> ddarius, yes.
13:49:56 <vixey> Martijn: (\x -> x) () reduces to () but uses no pattern matching
13:50:04 <sbahra> Ohhhh :) He's asking if any software uses rings 1, 2.
13:50:24 <sbahra> I thought he was asking if other processors implemented similar concepts ;-p
13:50:35 <Martijn> vixey: that only reduces to () if the result of "(\x -> x) ()" is needed
13:50:41 <Saizan> alsonk: ok, i get the same bug with cabal-install-0.6.1 and ghc-6.8.2, the good news is that the bug is absent from cabal-install-0.6.0 :)
13:50:56 <vixey> Martijn: I needed the result ;)
13:51:08 <alsonk> Saizan: I guess that's excellent, but sorta bad...
13:51:16 <alsonk> Saizan: so I should downgrade?
13:51:43 <Martijn> vixey: yes, so I guess my question is: when is the result needed? only in a pattern match and at the top level in main :: IO (), right?
13:52:21 <Martijn> I don't think I can state my question any clearer.
13:53:04 * vixey still doesn't actually understand what you are wondering about
13:53:08 <Saizan> alsonk: well, until the bug is fixed at least, there may be a workaround, but i'm not sure what might be
13:53:10 <roconnor> vixey: (\x -> x) () won't be reduced unless it occurs in a case expression
13:53:36 <vixey> > (\x -> x) ()
13:53:38 <lambdabot>   ()
13:53:51 <ozy`> @pl (\x -> x) ()
13:53:51 <lambdabot> ()
13:54:00 <roconnor> there was a case expression in the implicit print there
13:54:01 <Gracenotes> vixey: what? how could lambdabot allow that to happen!
13:54:09 <roconnor> @src () show
13:54:09 <lambdabot> Source not found. The more you drive -- the dumber you get.
13:54:24 <vixey> I don't think this case expression stuf is right
13:54:33 <ozy`> > show ()
13:54:35 <lambdabot>   "()"
13:54:50 <ddarius> roconnor: case xs of [] -> []; _:xs' -> xs' won't be reduced unless it occurs in a case expression
13:54:51 <dmwit> ?src show ()
13:54:51 <lambdabot> Source not found. I am sorry.
13:54:53 <alsonk> Saizan: I see where the issue is in the code, so will file a bug.
13:55:03 <Gracenotes> @instances Show
13:55:04 <ozy`> > case () of () | 12 == 2 -> 3 | "pizza" == "pizza" -> 9
13:55:04 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
13:55:06 <lambdabot>   9
13:55:12 <roconnor> ddarius: yes
13:55:15 <Olathe> @src [] Show
13:55:15 <lambdabot> Source not found. Do you think like you type?
13:55:26 <vixey> ddarius, ty
13:55:34 <vixey> turtles all the way/case expressions all the way down
13:56:11 <ddarius> roconnor: (\x y -> x) 3 4, the first application will be reduced even though it does not occur in case expression (though the whole expression won't be reduced until it is analyzed)
13:56:30 <Saizan> alsonk: yeah, found too :)
13:56:48 <Gracenotes> > show (1,2,3,4,5,6,7,8,9,10)
13:56:49 <lambdabot>   "(1,2,3,4,5,6,7,8,9,10)"
13:56:53 <roconnor> evaluation is driven by the (partial) normalization of IOTree.
13:56:56 <roconnor> @wiki IO_Semantics
13:56:57 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics
13:57:23 <sbahra> @src [a] show
13:57:24 <lambdabot> Source not found. My pet ferret can type better than you!
13:57:46 <vixey> I can define a restriction of beta reduction and take the closure and make claims like  (\x -> x) ()  reduces to  ()  without any IO or case expressions involved though
13:58:13 <ddarius> > (\x -> x) () `seq` ()
13:58:14 <lambdabot>   ()
13:58:49 <roconnor> ddarius: interesting
13:59:05 <roconnor> seq is cheating
13:59:13 <sbahra> :t seq
13:59:15 <lambdabot> forall a t. a -> t -> t
14:00:00 <mercury^> Is there a way to express that x == _|_ if a == _|_ and y == _|_ if b == _|_ where (x,y) = f (a,b)?
14:00:12 <roconnor> (\x -> x) () `seq` () should really be written as case (\x-> x) () of () -> (), but we are lazy
14:00:30 <vixey> mercury^, confusing use of (==) instead of (=)
14:00:46 * roconnor wants the Seq typeclass back
14:00:48 <rwbarton> mercury^: it all depends on the strictness of f
14:00:53 <mercury^> rwbarton: yes.
14:00:56 <vixey> how about f = id though
14:00:58 <cizra> Hey, cabal could be used to search for older versions of a package. How? I've forgotten the syntax.
14:00:58 <sbahra> roconnor, what do they provide?
14:00:59 <PeakerWork> mercury^: isn't f==id?
14:01:07 <mercury^> And I want to tell the compiler that property of f.
14:01:23 <PeakerWork> mercury^: oh, I misunderstood your question
14:01:24 <mercury^> No, f is some function that takes and returns tuples.
14:01:24 <vixey> so that it can do what?
14:01:52 <rwbarton> What does it even mean to "tell the compiler that x is _|_ if a is _|_ where x = f a"?
14:02:45 <ddarius> rwbarton: I think he wants to specify that f is strict in the components of the tuple
14:03:01 <PeakerWork> mercury^: you could tell your readers that by composing your function with (***)
14:03:12 <PeakerWork> mercury^: But not the compiler/type system, afaik
14:03:48 <PeakerWork> > (***) id id (5, undefined)
14:03:49 <lambdabot>   (5,* Exception: Prelude.undefined
14:04:03 <sbahra> :t (***)
14:04:04 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
14:04:16 <pumpkin> > let moo = (***) id id (5, undefined) in fst moo
14:04:18 <lambdabot>   5
14:06:13 <PeakerWork> in the function arrow: (***) :: (a->b) -> (a'->b') -> (a,a') -> (b,b')
14:08:08 <Botje> get better readers
14:09:01 * sbahra needs to install arrows here
14:10:28 <vixey> given simple typed lambda terms t and t' and you can decide if t
14:10:31 <vixey> t = t' ?
14:11:04 * vixey wonders about how to check: \f -> \x -> f x = \f -> f
14:11:40 <paper_cc> does anyone know of a way to redirect GHC output (when it is used as a library)?
14:11:41 <ddarius> vixey: If you don't have fix and friends, just reduce to eta-long beta-normal form
14:12:06 <Olathe> @pl \f -> \x -> f x
14:12:07 <lambdabot> id
14:12:10 <Olathe> @pl \f -> f
14:12:11 <lambdabot> id
14:12:19 <vixey> ddarius, but primitive recursion is ok?
14:12:43 <ddarius> vixey: Primitive recursion shouldn't be a problem.  It should simply lead to more normal forms.
14:16:04 <ahr> is anyone using haskell on opensolaris?
14:16:10 <vixey> to calculate eta-long beta-normal form
14:16:27 <vixey> you beta normalize, then eta expand (as much as possible wrt. keeping the term having the same type)?
14:16:44 <ddarius> vixey: More or less, yes.
14:16:53 <vixey> do know who introduced it ?
14:17:07 <ddarius> vixey: No.  Maybe Per Martin-Loef
14:25:17 <ydo> is there any library to read context-free grammars, in bnf or similar?
14:25:50 <ydo> I don't need the parser, just String -> Grammar
14:26:03 <vixey> ydo, I don't understand
14:26:13 <pumpkin> what's the grammar representation?
14:26:17 <vixey> Grammar is like a list of production rules?
14:26:18 <pumpkin> a simple graph?
14:26:45 <ydo> vixey: yes
14:27:13 <dmwit> Write a grammar parser in Parsec. ;-)
14:27:19 <vixey> ydo, but do you have no set format on the String?
14:27:43 <ydo> I have now a couple of data statements that does it for now.. but I guess I will have to write them external outside the haskell program
14:27:50 <Olathe> In private, @users is quite nice.
14:27:53 <dmwit> ...and then specify the grammar of the grammar specification in your grammar specification, eat your own tail, and poop out two copies of yourself!!
14:28:08 <dmwit> ?help users
14:28:08 <lambdabot> users [chan]. Report the maximum number of users seen in a channel, and active users in the last 30 minutes
14:28:09 <Olathe> (16:27.26) (lambdabot) Maximum users seen in olathe: 1, currently: 0 (0.0%), active: 0 (NaN%)
14:28:10 <vixey> lol Olathe
14:28:15 <mauke> see Parse::RecDescent
14:28:47 <vixey> ydo, I haven't found a working Peg Implementation, but there is a parser of Peg Grammars in the paper
14:28:56 <ydo> parsec, is that like yacc/bison + lex?
14:29:09 <vixey> yuck ...  YHC says Failed to load interface for `TokenId':
14:29:11 <pumpkin> vixey: didn't j of jhc havea peg implementation?
14:29:27 <vixey> pumpkin, if it did I haven't seen it
14:29:41 <mm_freak> ski_: there are monads, for which binding is commutative, like Reader
14:29:43 <pumpkin> I thought I saw that, let me look
14:29:54 <mm_freak> in Reader, there is no sequencing, not even of dependency
14:30:21 <mm_freak> in a general sense, monads don't resemble sequencing, but they can be used to implement it
14:30:31 <pumpkin> vixey: http://repetae.net/computer/frisby/
14:30:51 <vixey> pumpkin, You have sucessfully built this?
14:31:04 <pumpkin> nope :P I just saw it once and when you talked about PEGs in haskell, thought of it
14:31:11 <psygnisfive> guys, completely random question: have any of you gotten IMs from *coho?
14:31:16 <vixey> pumpkin, you are linking me to broken software
14:31:32 <pumpkin> ah :)
14:31:52 <pumpkin> anyway, that's what I meant when I said j of jhc's PEG parser
14:32:00 <dmwit> ydo: Parsec fills the same hole that flex/yacc fill, but they are not similar.
14:32:13 <dmwit> ydo: If you want something similar to those, you might like alex/happy.
14:35:40 <psygnisfive> guys, anyone?
14:35:48 <vixey> psygnisfive: no
14:35:54 <psygnisfive> weird dude
14:35:59 <psygnisfive> vixey, theres a CONSPIRACY
14:36:04 <pumpkin> o.O
14:36:11 <vixey> psygnisfive, only one? :)
14:36:30 <psygnisfive> ive discovered this weird online mystery
14:36:44 <psygnisfive> all sorts of people seem to be getting random messages from people named SomethingSomethingCoho
14:36:49 <psygnisfive> e.g. DealBreakingCoho
14:36:52 <psygnisfive> or ReformedCoho
14:36:52 <psygnisfive> etc
14:37:04 <psygnisfive> and at first they just seem like completely random people messaging you
14:37:14 <psygnisfive> but if you talk to them, they claim to have never messaged you
14:37:20 <pumpkin> sounds like an advertising scheme
14:37:22 <psygnisfive> and they say they're not using that screenname at all
14:37:28 <psygnisfive> pumpkin: it does, but heres the thing
14:37:31 <psygnisfive> they're not SPAMMING
14:37:42 <psygnisfive> whats actually going on is that some server is message forwarding
14:37:50 <psygnisfive> so that it randomly pokes people
14:37:59 <psygnisfive> and then starts forwarding one persons messages to someone else
14:38:05 <psygnisfive> so now im talking to you, you're talking to me
14:38:13 <psygnisfive> but we BOTH see messages coming from *Coho
14:39:59 <pumpkin> weird
14:40:18 <pumpkin> probably some sort of eavesdropping system gone awry :P
14:40:41 <psygnisfive> apparently its an online social experiment called The Great Hatsby
14:41:02 <francis> learn you a haskell
14:41:04 <francis> for great good
14:41:08 <psygnisfive> http://en.wikipedia.org/wiki/TheGreatHatsby
14:43:57 <dmwit> That's what you get for using LiveJournal, I guess.
14:44:11 <psygnisfive> i use twitter D:
14:45:15 <BONUS_> w00t. twiter owns
14:45:25 <pumpkin> onoes
14:47:22 <Cale> I don't understand twitter. How is it not just a slower version of IRC?
14:47:33 <pumpkin> it's persistent
14:47:39 <pumpkin> and each person gets his own channel :P
14:47:40 <Saizan> it's easier to get the logs.. yeah that
14:47:42 <pumpkin> to fill up with crap
14:48:28 <pumpkin> Cale's just bitter someone took his nick
14:48:29 <Cale> The pattern I keep seeing is that people try to use Twitter to talk to specific other people.
14:48:42 <BONUS_> yeah thats kind of not what twitter is about
14:48:52 <BONUS_> basically i use it to post stupid inane jokes i come up with
14:49:56 <BONUS> w00t, deadline almost up for logo competition
14:50:01 <BONUS> i can't wait to see which one gets accepted
14:50:29 <memento> i dont't understand twitter too
14:51:01 <memento> how the hell wants to share everything about their life with everybody
14:51:17 <memento> or not everybod
14:51:17 <memento> y
14:51:27 <BONUS> well millions of people obviously haha
14:51:57 <BONUS> anyone got any ideas for some good problems that i can solve and explain how they're solved in LYAH
14:52:08 <BONUS> so far i have "how to implement a RPN calculator"
14:52:29 <BONUS> and im going to make a section about finding a shortest path on this specific graph
14:52:33 <BONUS> any other ideas?
14:52:35 <mauke> how to kill a mockingbird
14:52:43 <BONUS> haha
14:53:04 <memento>  BONUS: and is there some kind of tech blogs in twitter too? or it's far away from that?
14:53:21 <RayNbow> @google Twitter site:wikipedia.org
14:53:23 <lambdabot> http://en.wikipedia.org/wiki/Twitter
14:53:23 <lambdabot> Title: Twitter - Wikipedia, the free encyclopedia
14:53:28 <BONUS> well i dont know, lots of people tweet about tech stuff
14:53:43 <BONUS> there's also cool stuff like http://twitter.com/rwhbook
14:53:44 <vixey> BONUS, how to do infix parsing (and hook it up with the RPN calculator)
14:54:28 <BONUS> vixey: you mean like dijkstra's shuntyard algorithm?
14:54:32 <BONUS> or wossname
14:54:51 <vixey> dunno shuntyard is a funny thing
14:55:01 <BONUS> but yeah that's definitely a good idea
14:55:11 <BONUS> although maybe i'll do parsing after introducing monads
14:55:11 <vixey> it doesn't pass my criteria for correctness
14:55:45 <BONUS> i wanted to also write how to make that fault tolerant RPN calculator
14:55:51 <BONUS> that's String -> Maybe Float
14:55:52 <vixey> BONUS, oh nice extended example .. write a simple parser monad
14:55:57 <vixey> and the parser in that
14:56:05 <BONUS> but it's really tedious to do without monads
14:56:07 <BONUS> hmm yeah
14:56:17 <BONUS> i'll definitely make a chapter about parsing, that's a good idea
14:56:26 <BONUS> should i do a parser monad by using StateT
14:56:35 <BONUS> or should i just make a new monad from zero
14:56:42 <BONUS> i wonder what's easier to understand for the reader
14:56:59 <Cale> Probably starting from scratch in that particular case...
14:57:10 <Cale> Though it might be a good idea to compare the two.
14:57:57 <BONUS> yeah. one interesting difference is `mplus`
14:58:19 <BONUS> usually in parser monads you only check if the first character parses against the input
14:58:41 <BONUS> but when using like StateT s (Either String) m, a `mplus` b is like try a `mplus` try b
14:59:10 <pumpkin> I wish we could abolish the expression "industrial strength"
14:59:13 <Cale> Hm? I was thinking  newtype Parser a = P (String -> [(String, a)])
14:59:34 <Cale> Which is equivalent to StateT String [] a
14:59:43 <BONUS> that's also good yeah
14:59:43 <BONUS> like in hutton's book
14:59:43 <BONUS> if im not mistaken
15:00:22 <Cale> pumpkin: good point, that is an annoying term
15:00:45 <Cale> It doesn't really mean anything at all.
15:01:02 <BONUS> apart from: it doesn't crash all the time
15:01:15 <BONUS> but yeah it's become sort of a buzzword
15:01:16 <Saizan> isn't parsec the exception in that behaviour? i.e. other parse monads i've seen have a fair mplus and maybe a way to explicit commit to a branch
15:01:55 <Cale> The industry in general tends to use the weakest, cheapest things they can get away with using. ;)
15:02:11 <BONUS> ah
15:02:29 <BONUS> i've seen pretty much just parsec and hutton's example and the StateT one
15:03:12 <Cale> So perhaps it would be more appropriate for 'industrial strength' to mean 'not all that strong after all'.
15:03:30 <pumpkin> http://www.haskell.org/haskellwiki/Parsec
15:03:30 <pumpkin> :D
15:04:12 <pumpkin> I guess that's just taken from the official parsec site though
15:05:16 <cizra> Hey, cabal could be used to search for older versions of a package. How? I've forgotten the syntax.
15:05:28 <cizra> .. and install, of course
15:05:50 <Cale> The industry would be lucky to use such a well-designed parser library. Don't they typically use broken, poorly implemented regex libraries to do parsing?
15:05:52 <Cale> hehe
15:07:38 <Cale> cizra: cabal install foo-1.2.0.6
15:07:56 <cizra> Cale: How to search for older versions?
15:08:00 <Cale> search?
15:08:01 <cizra> Cale: .. older than the last one, I meant.
15:08:13 <Cale> Look on hackage to see what's available.
15:08:23 <cizra> Um, OK
15:08:33 <Cale> at least, that's what I do
15:08:53 <cizra> Ha! Gotcha! Thanks, Cale
15:10:01 <Cale> you could also use  cabal list --simple-output along with grep
15:10:52 <cizra> Oh, useful
15:15:25 <mreha> does anyone that programmes scheme know what they are talking about?
15:15:57 <vixey> mreha: no see for example Oleg who uses Scheme
15:17:07 <vixey> @go pobox Oleg
15:17:09 <lambdabot> http://okmij.org/ftp/
15:17:09 <lambdabot> Title: This FTP site
15:17:27 <vixey> mreha, ^ check out some of the stuff on here it's good stuff
15:20:11 <Gracenotes> @type forever
15:20:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
15:20:24 <Gracenotes> ..how would one use that?
15:20:51 <pumpkin> @src forever
15:20:51 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
15:21:05 <Saizan_> lambdabot = forever listenToASocketAndRespondToCommands
15:21:05 <ziman> for example, main = forever (readInput >>= processEvent)
15:21:19 <Gracenotes> oh, IO
15:21:24 <MarcWeber> Which excpetion would you throw to indicate failing writing all bytes to a socket?
15:21:32 <pumpkin> what other contexts does that make sense in, other than IO?
15:21:36 <vixey> Saizan, hehe is that the actual code?
15:21:55 <ziman> > forever [1]
15:21:58 <Saizan> it should be
15:21:58 <lambdabot>   * Exception: stack overflow
15:22:08 <ziman> > take 20 $ forever [1]
15:22:10 <lambdabot>   * Exception: stack overflow
15:22:15 <Gracenotes> oh, that's where I saw it before, in the make-yourself-an-IRC-bot tutorial
15:22:24 <Gracenotes> makes sense :)
15:22:45 <Gracenotes> although might not make sense for anything not IO-like
15:23:42 <Saizan> forever can make sense when you care only about the side-effects, like using a short-cutting monad like Either e
15:23:47 <Saizan> or Writer
15:24:01 <Saizan> if you only look at the resulting monoid
15:24:18 <hugo___> hi
15:30:09 <vixey> mreh, well?
15:32:00 <jeltsch> Hi, anyone here who was able to build Gtk2Hs with GHC 6.10.1?
15:32:38 <pejo> jeltsch, you need the darcs version
15:32:47 <michaelcdever> jeltsh: i have it built with 6.10.something, on fedora, no building needed, if you use fc, theres a package for it
15:33:01 <jeltsch> I use Debian.
15:33:02 <michaelcdever> ghc-gtk2hs
15:33:11 <michaelcdever> ahh... there used to be a package for debian
15:33:19 <jeltsch> But not for GHC 6.10.1
15:33:33 <jeltsch> For GHC 6.6.
15:33:38 <michaelcdever> maybe find the fedora rpm, and convert it using alien?
15:33:39 <hugo___> is there any way to get a bundle of the hackagedb with all the associated dependecies ?
15:34:18 <cizra> hugo___: like.. cabal?
15:34:32 <jeltsch> Is the Fedora RPM Gtk2Hs 0.9.13? Or the darcs version?
15:34:33 <hugo___> cizra: nop, like a giant tar.gz :P
15:34:44 <cizra> oh. dunno.
15:34:47 <hugo___> i have no internet on my windows pc
15:35:00 <vixey> is there any sort of list of programs which you have to use bang patterns or seq or such for?
15:35:01 <hugo___> and ill have to do a large ammount of development on it
15:35:26 <vixey> I doubt someone would make a compilation of that but it would be handy
15:35:41 <rgr> (noob, reading tutorial) If I have a comprehension like "myComp = [x*2 | x <- [1..10], x*2 >= 12]" then can I query if myComp has been calculated? Or would it be called expanded?
15:35:44 <michaelcdever> geltsh: 0.9.13
15:36:05 <vixey> @let myComp = [x*2 | x <- [1..10], x*2 >= 12]
15:36:05 <luqui> vixey, I'm not really sure what you mean?  you mean a list of modules on hackage which need them?
15:36:07 <lambdabot>  Defined.
15:36:07 <vixey> > myComp
15:36:09 <lambdabot>   [12,14,16,18,20]
15:36:10 <jeltsch> michaelcdever: How did they manage to build this with GHC 6.10.1?
15:36:21 <vixey> luqui, just short programs for a kind of benchmark I mean
15:36:32 <vixey> luqui, (wondering how many real world situations my idea would apply to)
15:36:39 <luqui> oh to observe the difference?
15:36:42 <michaelcdever> jeltsh: no idea, i just installed the rpm
15:36:44 <rgr> vixey: was that an answer?
15:36:52 <vixey> rgr, I hope so
15:37:01 <rgr> I'm not sure it is.
15:37:04 <vixey> rgr, but I didn't fully understand you
15:37:10 <jeltsch> Will there a Gtk2Hs release soon which fixes the GHC 6.10.1 build problems?
15:37:10 <rgr> ok, then its not.
15:37:21 <vixey> rgr, like there's no  <compute this>  thing you have to use to use myComp
15:37:37 <rgr> if I have a really, really heavy comprehension assigned to myComp, can I know if its been evaluated?
15:38:05 <vixey> rgr, you could reduce it to normal form at the start of your program then the answer is,  it is computed
15:38:06 <luqui> rgr, pretty much no
15:38:17 <rgr> luqui: thanks.
15:38:24 <blackdog> rgr: you can apply a strategy to it
15:38:28 <blackdog> to make sure it's evaluated
15:38:32 <MisterN> Noober: go for it
15:38:33 <luqui> rgr, esp. since comprehensions are calculated incrementally.  what it means to be "fully calculated" would involve calculating some of it :-)
15:38:39 <blackdog> but you can't test it. that would destroy referential transparency
15:38:44 <vixey> rgr, oh you're satisfied with that , ok
15:39:12 <rgr> schroedingers cat ...
15:39:48 <Olathe> Oh dear...
15:40:01 <rgr> was wondering if there was some sort of runtime catalog which could tell someone if the "work had been done" in the lazy system.
15:40:33 <vixey> rgr, in GHC or Haskell 98 or what?
15:40:45 <EvilTerran> forcedYet :: a -> Bool; forcedYet x = x `seq` True -- :P
15:41:34 <luqui> rgr, well, using lots of hacks and the debugger api you could figure it out.  but... yuck.   may i ask what you have in mind for this feature?
15:41:37 <luqui> (if anything?)
15:42:13 <rgr> luqui: as I said, I was just reading the tutorial and wondered if one could detect such things. Call it idle curiosity.
15:42:32 <luqui> ah ok.  then the answer is emphatically no!  :-)
15:42:41 <vixey> luqui, not sure why you keep saying on, http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=84
15:42:47 <vixey> luqui, not sure why you keep saying no*
15:43:04 <luqui> well, modulo EvilTerran's "solution" :-)
15:43:21 <Olathe> @faq was wondering if there was some sort of runtime catalog which could tell someone if the "work had been done" in the lazy system.
15:43:22 <lambdabot> The answer is: Yes! Haskell can do that.
15:43:40 <vixey> that was my first suggestion but rgr seemed to be rupulsed by it and refused to talk to me further :p
15:43:51 <Olathe> Of course.
15:44:01 <luqui> vixey, that falls under "lots of hacks", I'd say :-)
15:44:09 <MisterN> Noober: do it do it!
15:44:10 <luqui> certainly not everyday usage
15:44:29 <luqui> or even once-a-year usage
15:44:30 <rgr> I did? I have no idea what you mean. You didnt suggest anything that I saw.
15:44:37 <Olathe> He's here to tell us about himself more than to find out about Haskell.
15:45:17 <luqui> ?
15:45:23 <rgr> Olathe: you have lsot. It seems aperfectly reasonable thing to ask.
15:45:30 <rgr> ugh.
15:45:32 <rgr> "lost me"
15:45:41 <vixey> rgr: <vixey> rgr, you could reduce it to normal form at the start of your program then the answer is,  it is computed
15:45:53 * luqui agrees, and is curious why Olathe said that
15:46:21 <rgr> vixey: I am a beginner reading the tutorial. That means not a lot to me. Maybe I need a more basic group to ask silly quetions in?
15:46:37 <vixey> rgr, sorry will back off
15:46:44 <Noober> MisterN: No, sorry. I wil not highlight everybody in this channel. It doesn't matter how intense your request is. :-)
15:46:52 <rgr> vixey: no problems, its hard to judghe experience I guess.
15:47:03 <vixey> didn't mean to answer your question *too thoroughly* :p
15:47:31 <MisterN> Noober: you already promised it :(
15:47:33 <EvilTerran> rgr, basically, vixey said "do the work before anyone has a chance to ask whether it's been done yet, then always say it's been done without checking"
15:47:43 <MisterN> Noober: don't you want to find out christoph's identity?
15:47:44 <rgr> heh :-;
15:47:55 <vixey> rgr, (just occured to me, btw if I am using weird vocabulary you didn't encounter before just ask me what I'm saying)
15:48:18 <rgr> vixey: thanks, but was just a quick question. I need to read more. Thanks for your time.
15:48:21 <vixey> rgr, (I sometimes forget that beta-normal form isn't used in everyday conversation)
15:48:36 <rgr> really? Wow! I am surprised :-)
15:48:46 <Noober> MisterN: I didn't promise anything. :-P And I will find another way to find out  about his identity. :-)
15:49:43 <MisterN> Noober: he's evil, isn't he?
15:52:08 <MisterN> Noober: we have to find some subtle, evil way to reveal his identity.
15:52:22 <MisterN> you can't beat evilness without evilness
15:52:37 <vixey> I can only think of one example where !/seq/$! is used
15:52:53 <vixey> that's summing the elements of a really long list
15:53:38 <Cale> In general, operations which collapse large structures into small ones will need a bit of strictness to avoid creating large thunks which will just be immediately evaluated afterward.
15:53:59 <Olathe> @src sum
15:53:59 <lambdabot> sum = foldl (+) 0
15:54:10 <Olathe> Why doesn't that use seq ?
15:54:21 <MisterN> why would it
15:54:23 <Cale> It might be better off using foldl'
15:54:28 <vixey> Cale, do you think there's any list of examples where strictness are used?
15:55:19 <Cale> vixey: hmm, I don't know.
15:56:04 <francis> if i have a list containing lists, and i wanted to apply a function to each value in the smaller lists
15:56:18 <cizra> francis: map . map
15:56:21 <vixey> francis, you can use (map . map f) instead of map f
15:56:37 <vixey> oh
15:56:42 <vixey> I'm wrong about that amn't I
15:56:44 <EvilTerran> > (map.map) f [[a,b,c],[d,e,f],[g,h,i]] :: [[Expr]]
15:56:46 <vixey> :t map . map ?f
15:56:46 <lambdabot>   [[f a,f b,f c],[f d,f e,f f],[f g,f h,f i]]
15:56:48 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[b1]'
15:56:48 <lambdabot>     Probable cause: `map' is applied to too many arguments
15:56:48 <lambdabot>     In the second argument of `(.)', namely `map ?f'
15:56:52 <vixey> yeah sorry
15:57:04 <EvilTerran> vixey, i remember 'cos it's (fmap fmap fmap) :P
15:57:18 <francis> the thing is, i have to use both (there are 2) values in the smaller lists for this function
15:57:25 <francis> ok hold on lemme explain it better lol
15:57:39 <francis> i have a function "a" that takes 2 parameters
15:57:49 <Cale> francis: zipWith f ?
15:57:56 <Cale> er...
15:58:00 <EvilTerran> kinda
15:58:18 <francis> i'd like to apply "a" to each sub-list such that [1,2] gives me a 1 2
15:58:19 <francis> etc
15:58:30 <Cale> francis: what if the list has 3 elements?
15:58:34 <francis> it doesnt
15:58:37 <francis> im generating the list
15:58:51 <Cale> Should it just take the first 2?
15:59:16 <vixey> francis, why don'tt you generate (a,a) instead of [a]
15:59:17 <Cale> I suppose if it doesn't matter, you can just map (\[x,y] -> f x y)
15:59:18 <EvilTerran> francis, why not use a pair instead of a list?
15:59:21 <francis> this is how im generating the list
15:59:26 <francis> > map ( take 2 ) . tails $ [1..5]
15:59:27 <lambdabot>   [[1,2],[2,3],[3,4],[4,5],[5],[]]
15:59:54 <Olathe> > zip xs (tail xs) where xs = [1..5]
15:59:56 <Cale> and you don't care about the shorter lists at the end?
15:59:56 <lambdabot>   [(1,2),(2,3),(3,4),(4,5)]
16:00:13 <francis> Cale, nope
16:00:21 <Cale> Look at Olathe's example
16:00:28 <Cale> You can use zipWith f instead of zip
16:00:29 <EvilTerran> > zipWith f xs (tail xs) where xs = [1..5]
16:00:30 <lambdabot>   Add a type signature
16:00:33 <francis> those are tuples right?
16:00:35 <EvilTerran> > zipWith f xs (tail xs) where xs = [1..5] :: [Expr]
16:00:36 <Cale> yeah
16:00:37 <lambdabot>   Add a type signature
16:00:41 <EvilTerran> ...
16:00:42 <Olathe> Ahh, yes zipWith is an excellent idea.
16:00:55 <Cale> > zipWith f xs (tail xs) :: [Expr] where xs = [1..5]
16:00:57 <lambdabot>   [f 1 2,f 2 3,f 3 4,f 4 5]
16:01:03 <EvilTerran> ah, that's the one
16:01:08 <francis> ^ thats exactly what i need!
16:01:10 <Cale> I don't even know why 'where' works there.
16:01:14 <ddarius> @seen conal
16:01:14 <lambdabot> conal is in #haskell and #ghc. I don't know when conal last spoke.
16:01:17 <EvilTerran> ... wwwwaaaaiiiitaminute, "where"?
16:01:19 <Cale> It shouldn't.
16:01:35 <EvilTerran> ah, i know why
16:01:45 <Cale> It's probably a possible injection attack waiting to happen.
16:01:53 <EvilTerran> doesn't lambdabot's evaluator splice the expression into "let v = ... in v"?
16:01:59 <EvilTerran> (for some random variable name instead of v)
16:02:03 <Cale> I don't know what it does anymore
16:02:08 <Cale> It uses hint.
16:02:28 <rgr> Just to be sure I am heading in the right direction .. If I have a list of lists and one element of the list is assigned a comprehension, that compreshension is not evaluated until I access an element or property of that list?
16:02:47 <Cale> rgr: right
16:03:02 <Cale> rgr: and it's only evaluated insofar as the elements of that list are required.
16:03:22 <EvilTerran> rgr, when you're saying "comprehension", are you sure you don't mean "computation" or something?
16:03:28 <EvilTerran> ?wn comprehension
16:03:37 <rgr> Cale: could you expand on that a bit? e.g It would eavluate differently if all I needwas was the length of that comprehension?
16:03:39 <lambdabot> *** "comprehension" wn "WordNet (r) 2.0"
16:03:39 <lambdabot> comprehension
16:03:39 <lambdabot>      n 1: an ability to understand the meaning or importance of
16:03:39 <lambdabot>           something (or the knowledge acquired as a result); "how
16:03:39 <lambdabot>           you can do that is beyond my comprehension"; "he was
16:03:41 <lambdabot> [4 @more lines]
16:03:43 <Cale> So if you just want to know the first element of the list generated by the list comprehension, it won't generate everything
16:03:46 <ddarius> @tell conal You might find this 1980 paper by Luca Cardelli interesting: http://lucacardelli.name/Papers/AnalogProcesses%20300dpi.pdf
16:03:46 <lambdabot> Consider it noted.
16:03:47 <rgr> EvilTerran: Not sure.
16:03:49 <EvilTerran> ?wn computation
16:03:50 <lambdabot> *** "computation" wn "WordNet (r) 2.0"
16:03:50 <lambdabot> computation
16:03:50 <lambdabot>      n 1: the procedure of calculating; determining something by
16:03:51 <lambdabot>           mathematical or logical methods [syn: {calculation}, {computing}]
16:03:53 <lambdabot>      2: problem solving that involves numbers or quantities [syn: {calculation},
16:03:55 <lambdabot>          {figuring}, {reckoning}]
16:03:58 <Cale> and yes, if all you needed was the length, it wouldn't evaluate the function part
16:04:00 <francis> Cale: ghci doesnt like the "where"
16:04:08 <Olathe> > let xs = map (\x -> [a <- [1..x]]) [1..5] in xs
16:04:10 <lambdabot>   <no location info>: parse error on input `<-'
16:04:10 <Cale> francis: I know. That's what we were talking about
16:04:12 <EvilTerran> > length [undefined, undefined, undefined]
16:04:13 <lambdabot>   3
16:04:15 <rgr> EvilTerran: "[x*2 | x <- [1..10]]" is a comprehension right?
16:04:17 <Olathe> > let xs = map (\x -> [a | a <- [1..x]]) [1..5] in xs
16:04:19 <Cale> francis: It's strange that lambdabot accepts it.
16:04:19 <lambdabot>   [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
16:04:20 <EvilTerran> rgr, yes
16:04:28 <Cale> francis: where is part of the syntax of declarations
16:04:41 <Cale> francis: You could use let instead
16:04:43 <Olathe> rgr: You can see this pretty clearly in ghci.
16:05:00 <Cale> > let xs = [1..5] in zipWith f xs (tail xs) :: [Expr]
16:05:02 <lambdabot>   [f 1 2,f 2 3,f 3 4,f 4 5]
16:05:02 <rgr> fire away
16:05:03 <Olathe> rgr: When you evaluate a list like that, it'll print off the elements as it computes them, which can be slow.
16:05:10 <Cale> Of course, ghci won't like that either
16:05:22 <Cale> Because it uses the simple-reflect package.
16:05:29 <Cale> (to display those f's)
16:05:51 <francis> hm
16:06:02 <Cale> > let xs = [1..5] in zipWith (+) xs (tail xs)
16:06:05 <lambdabot>   [3,5,7,9]
16:06:08 <francis> well i have access to another lambdabot so i could use that
16:06:08 <Cale> that'll work though
16:06:26 <Cale> > let xs = [1..5] in zipWith (\x y -> 10*x + y) xs (tail xs)
16:06:29 <lambdabot>   [12,23,34,45]
16:06:48 <luite_> where is the Expr type defined?
16:06:55 <Olathe> @index Expr
16:06:55 <lambdabot> bzzt
16:07:01 <Olathe> In bzzt.
16:07:04 <EvilTerran> ?hackage simple-reflect
16:07:05 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/simple-reflect
16:07:20 <francis> does this look kosher to you?
16:07:27 <francis> let xs = [1..10] in zipWith (\x y -> a x y + b x y + c x y) xs (tail xs)
16:07:36 <francis> a b and c are my own functions
16:07:38 <luite_> EvilTerran: ah
16:07:41 <Cale> yeah, sure
16:07:44 <francis> awesome
16:12:34 <luqui> francis, another way to say that is [ a x y + b x y + c x y | (x,y) <- zip xs (tail xs) ].  I like that better because it keeps the zip xs (tail xs) close together
16:12:52 <luqui> i.e. it's easier to see that it's working on adjacent pairs
16:14:13 <Tobsan> :t mapM_
16:14:16 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
16:14:23 <Tobsan> skorpan: there it is
16:14:39 <skorpan> ? surely you mistabbed the nick. i never asked about that.
16:15:17 <conal> ddarius: thanks for the pointer.  i haven't read that paper.  i'll check it out.
16:15:17 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
16:15:26 <Tobsan> skorpan: lol
16:28:34 <wabash> Hey, does Haskell have a unit test framework?
16:28:45 <pumpkin> quickcheck sort of counts
16:28:50 <pumpkin> there are more traditional ones to
16:28:51 <pumpkin> too
16:29:30 <wabash> any mocking/stubbing stuff too?
16:29:59 * blackdog read that as "stabbing"
16:30:11 * blackdog thinks you may work for optus too...
16:30:14 <wabash> blackdog: only when it won't parse...
16:31:26 <luqui> wabash, I wonder what mocking means in FP...
16:31:46 <mreh> laughing at c programmers
16:31:51 <wabash> luqui:  I suppose make a function return an arbitrary value.
16:32:13 <pumpkin> I never liked that word
16:32:15 <wabash> so that you can test different levels of some function call stack.
16:32:15 <luqui> wabash, yeah, I guess if you use typeclasses liberally then mocking would be easy
16:32:34 <pumpkin> make a mockup, maybe, but mocking already has a meaning and it's not the right one :P
16:32:57 <ddarius> luqui: In pure code, there's much less need/use for mocking/stubbing.
16:32:58 <mreh> mocking is a unit testing methodology
16:33:05 <pumpkin> yeah, I know
16:33:06 <luqui> ddarius, yeah, that's the impression I got
16:33:11 <pumpkin> I just don't like the word they use for it :P
16:33:31 <luqui> ddarius, especially for the abundant functions which have only one implementation that typechecks :-)
16:33:31 <mreh> i just call them mock objects
16:33:39 <mreh> different from a stub
16:33:49 <luqui> wabash, but quickcheck is da bomb.
16:34:04 <luqui> but you kind of have to change how you think about testing (is this unexpected? :-)
16:34:04 <mreh> when you say pure code, what do you mean
16:34:31 <luqui> mreh, side-effect free.
16:34:38 <mreh> i see
16:34:59 <mreh> can you write pure scheme code?
16:35:30 <Cale> mreh: Yes, given enough care.
16:37:06 <mreh> how does one go about designing a large system in FP?
16:37:16 <mreh> surely you can only go bottom up
16:37:29 <luqui> mreh, yeah pretty much.  break it into modules until the system isn't large anymore.
16:37:30 <Cale> mreh: Top-down works as well.
16:37:32 <mreh> if everything is functionally dependent on fixed values
16:38:11 <mreh> how do you test it going top down
16:38:15 <jefu> if you do a lookup that returns a Maybe, what is the best way to test to see if the maybe worked and then (maybe) do another lookup?
16:38:16 <Cale> Start by designing the high-level interface to functionality, and then go about implementing the core of it, and work your way outwards, filling in more details.
16:38:29 <jefu> I'm doing "ifJust" now in an if, but that seems ugly
16:38:33 <luqui> jefu, using the Maybe monad... I think.
16:38:42 <luqui> jefu, but I'm not that sure what you're asking
16:39:05 <augustss> jefu: perhaps you want the 'maybe' function?
16:39:09 <mbz> @go hcurses
16:39:11 <lambdabot> No Result Found.
16:39:18 <jefu> the maybe function?
16:39:22 <luqui> :t maybe
16:39:24 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:39:36 <Cale> > do x <- lookup 3 [(3,"hello")]; y <- lookup x [("hello", "world")]; return (x,y)
16:39:39 <lambdabot>   Just ("hello","world")
16:39:50 <Cale> Maybe monad :)
16:40:29 <afabian> Good for nothing lay-about programming languages these days.  Back in my day, every expression got evaluated, whether you needed the result or not!
16:40:53 <luqui> if you don't want it to be evaluated, don't write it!  :-)
16:41:07 <jefu> I want something like do x <- lookup ... ; (if the lookup did not succeed) y <- lookup...
16:41:10 <Gabbie> Haskell isn't exactly brand new.
16:41:11 <mreh> back in your day, everything took forever
16:41:18 <luqui> jefu, that's exactly what Cale's code does
16:41:25 <luqui> oh did *not* succedd
16:41:35 <Cale> ah, then you want mplus
16:41:35 <luqui> jefu, you can use mplus for that.
16:41:49 <jefu> ah, mplus!
16:41:55 <Cale> > lookup 3 [(3,"hello")] `mplus` lookup x [("hello", "world")]
16:41:57 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[Char]'
16:42:04 <jefu> ok.   now I see
16:42:04 <Cale> > lookup 3 [(3,"hello")] `mplus` lookup "hello" [("hello", "world")]
16:42:07 <lambdabot>   Just "hello"
16:42:12 <Cale> > lookup 4 [(3,"hello")] `mplus` lookup "hello" [("hello", "world")]
16:42:14 <lambdabot>   Just "world"
16:42:57 <jefu> now, just a step more complicated.  I'm trying to expand my haskell-fu by building a small interpreter.
16:43:31 <jefu> It should have a global store (I figure of type Reader) and a stack of local stores (each of type Reader - or ReaderT)
16:43:47 <wabash> anyone here come from the Ruby world?
16:43:48 <jefu> but I can't quite figure out how to structure them and do a lookup
16:43:55 <Cale> jefu: errr...
16:44:05 <Cale> jefu: You might not understand what the Reader type is...
16:44:11 <pumpkin> wabash: me
16:44:33 <Cale> jefu: A value of type  Reader e a  is a computation which reads from an environment of type e before producing a value of type a
16:44:50 <wabash> pumpkin: et. al.: How is Haskell's ability to work with strings? Is it also fluid and easy?
16:44:56 <wabash> chop, chomp, substring, etc.
16:45:15 <pumpkin> sort of
16:45:17 <mreh> strings are lists of type char
16:45:25 <Cale> wabash: reasonably so. Most of the string operations are list operations.
16:45:29 <pumpkin> byorgey's split lib is helpful
16:45:31 <jefu> ok, maybe reader is not the right thing - i want a mapping of names to values and it should be lexically structured (like scheme) with a global environment and a list of local environments
16:45:49 <blackdog> mreh: oi. you're gonna have to learn bytestring anyway, why not start off in a state of grace?
16:45:53 <Cale> jefu: You might write your interpreter in the Reader monad...
16:46:06 <augustss> jefu: you might only want one "store"
16:46:08 <Cale> jefu: But the mapping of names to values will probably be a Data.Map
16:46:52 <jefu> data.map is ok too  - i've used that before, but not quite in this context
16:46:54 <Cale> jefu: Will there be mutation?
16:46:59 <mreh> blackdog: i am confuse
16:46:59 <luqui> Cale, why don't you say:  Reader e a  is  e -> a ?
16:47:00 <mreh> d
16:47:03 <jefu> there will be mutation :)
16:47:06 <Cale> luqui: Well, it is.
16:47:22 <pumpkin> beware of the mutations, you might get ninja turtles or giant rats
16:47:23 <luqui> obviously with more elaboration, but why obfuscate only with "reads from environment before ..."
16:47:24 <Cale> luqui: Or at least, that's an implementation of it.
16:47:30 <mreh> i am new to haskell :) i was just trying to simplify the problem
16:47:32 <augustss> jefu: you get the lexical structure for free, since you never modify values in Haskell.  So as you pop out of recursion (or whatever you're using) the only mapping is still there.
16:47:33 <wabash> how about regexp?
16:48:02 <EvilTerran> wabash, well, we have parser combinators
16:48:10 <EvilTerran> they're like regexp only human-readable
16:48:18 <blackdog> mreh: oh, i'm just being grumpy :) i suppose strings as lists is ok for a bit. inevitably you hit this point with textmunging where you realise you need something faster, and you have to convert your code to ByteStrings. Not that it's that hard, it's just a little unnecessary roadbump
16:48:31 <jefu> but I'm trying to build a small language which will itself do mutation - think "(let...)" in scheme/lisp
16:48:35 <cads> Hello, I'd like to write some numerical code that needs to use vectors and do dot products, vector addition, and scalar multiplication with them. Do you guys have a suggestion for what module I should use?
16:48:37 <augustss> jefu: actually, what i said might or might not apply, depending o what kind of language you're interpreting :)
16:48:56 <jefu> augustss - ???
16:48:59 <Cale> cads: There are some good linear algebra packages on Hackage...
16:49:25 <Axman6> cads: there's hmatrix, and others
16:49:26 <augustss> jefu: are you you going to have a split environment and store?
16:49:28 <Cale> cads: In the past, I've usually just written my own linear algebra stuff.
16:49:55 <augustss> jefu: I.e., will the environment map identifiers to locations, and then you have a store that maps locations to values?
16:50:13 <jefu> not sure I understand.   I'd like to have a set of nested environments and a global environment that is a fallback
16:50:18 <cads> Cale, should I just write those functions using Arrays? I'm a little confused by arrays so far..
16:50:34 <Cale> But iirc, Conal has a good vector-space package that looks nice.
16:50:51 <Cale> http://hackage.haskell.org/packages/archive/vector-space/0.5.1/doc/html/Data-VectorSpace.html
16:51:09 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vector-space
16:51:10 <jefu> hmm.  I'd thought of just doing an identifier -> value mapping, but maybe with an identifier -> vector-location -> value mapping if I ended up building a quasi-compiled version
16:51:20 <cads> thanks cale
16:51:34 <augustss> jefu: if your language allows any kind of pointer like things, yu need the split environment/store model.  Otherwise you can make do with and environment mapping identifiers to values.
16:52:03 <jefu> I don't need pointer-like things, just name->value lookups
16:52:16 <augustss> jefu: objects?
16:52:51 <mreh> does anyone have anything cool they're done in haskell to show me?
16:53:10 <augustss> mreh: what's cool?
16:53:24 <mreh> that's very uncool
16:53:29 <mreh> dont you know?
16:53:32 <jefu> not objects - just values (it's a simple language, really only numbers and strings)
16:53:45 <augustss> mreh: i know what I think is cool. :)
16:54:10 <mreh> again, uncool
16:54:30 <arw> hm, why didn't anybody tell me about Data.ByteString.* earlier? :)
16:54:31 <augustss> jefu: then you can map directly to values, and you might want a stack of maps as you suggest.  And as Cale said, a stack of Data.Map might be the right thing.
16:54:42 <pumpkin> > text . cool $ "mreh"
16:54:44 <lambdabot>   cool
16:54:52 <mreh> i knew it
16:54:58 <jefu> thanks.   I'll try that and see how it goes.
16:55:04 <blackdog> arw: we wanted you to experience the joy of discovery
16:55:20 <cads> hey, what version of GHC do you guys rub? I'm here with 6.8.2, but this package requires 6.9.. i'm running the most up to date version according to ubuntu, but I'm guessing they're behind.
16:55:24 <arw> blackdog: how considerate of you :)
16:55:30 <conal> one nice thing about vector-space is that dimensionality of its linear maps is captured in static types, unlike (most) explicit array representations.
16:55:32 <cads> should I install ghc from cvs?
16:55:55 <Axman6> cads: just download 6.10 from haskell.org/ghc
16:56:12 <cads> cads, you're behind the times
16:56:15 <mreh> can you write event driven code in haskell? can you write GUIs?
16:56:22 <augustss> cads: 6.10 is advisable
16:56:23 <Axman6> mreh: yes
16:56:38 <arw> but seriously, is there a good tutorial on writing fast haskell?
16:56:40 <Cale> mreh: Yes, in a number of ways.
16:56:52 <Axman6> arw: check out dons' blog
16:57:01 <pumpkin> or conal
16:57:05 <conal> what i really mean is that it both (a) handles arbitrary dimensionality and (b) captures dimension statically.
16:57:15 <jefu> on a different note, i'm running ubuntu (hardy).  where might i find the deb file for source code for haskell libraries?
16:57:26 <pumpkin> conal: you mean the hackage package?
16:57:27 <Cale> mreh: The more traditional GUI bindings available in Haskell at the moment - Gtk2Hs and wxHaskell - give a somewhat standard approach to binding events to actions.
16:57:29 <arw> everybody just keeps mentioning that it is almost as fast as c, but the trivial approaches suck mostly :)
16:57:33 <conal> pumpkin: yes
16:57:46 <arw> Axman6, pumpkin thx, i'll have a look
16:57:53 <mreh> i saw, computation is cheap
16:57:55 <Cale> mreh: Conal and a number of others are working on designing a more compositional approach to interactivity.
16:57:56 <mreh> say*
16:58:05 <augustss> mreh: but the traditional way of doing GUIs is not cool.  what conal does is cool.
16:58:17 <mreh> that's the most important part
16:59:07 <Cale> arw: The most common sources of slowness in beginner Haskell programs, I'd say, are using the wrong data structures, and not understanding the evaluation model properly.
16:59:16 <Cale> More toward the first of those two.
16:59:34 <mreh> buy yourself a good book
16:59:39 <Cale> If you use a list when you really need a Data.Map or Data.Set, you're going to pay for it :)
16:59:46 <arw> Cale: agreed. using ByteString instead of [Char] alone gives a factor of two or more...
17:00:03 <pumpkin> Cale: also, it's really easy to accidentally keep around a huge list that you don't need, and eat up all your memory :P
17:00:07 <mreh> i thought singly linked lists are the only datastructures in haskell, how do you make a map?
17:00:15 <pumpkin> that's my main slowdown and I'm a noob
17:00:17 <Cale> pumpkin: That would be the 'not understanding the evaluation model' bit :)
17:00:18 <lucca> see Data.Map
17:00:20 <EvilTerran> pumpkin, i'd call that an evaluation model problem
17:00:28 <pumpkin> ah ok
17:01:08 <mreh> i remember once, i was shown an implementation of a list made of functions
17:01:10 <Cale> Of course, even experts manage to make mistakes, but it's really hard to fix the performance in cases like that if you're not clear about how things are getting evaluated.
17:01:11 <Axman6> mreh: heh, of course they're not
17:01:17 <EvilTerran> ?src Maybe
17:01:17 <lambdabot> data Maybe a = Nothing | Just a
17:01:21 <EvilTerran> there's a data structure :)
17:01:23 <mreh> all i could think was "why is that useful?"
17:01:26 <Axman6> @stc Either
17:01:27 <lambdabot> Source not found.
17:01:42 <mbz> augustss: cool way of doing GUI? could you please give a link?
17:01:43 <cads> grr, my difficulty in programming in haskell is that I have the feeling that I'm not doing it "the haskell way" while I'm programming.. like I missed reading all the papers showing how and why to use certain functions, idioms, and constructs
17:01:49 <EvilTerran> tuples are another
17:01:52 <lucca> mreh: you can use functions instead of numbers too...
17:01:54 <Cale> > [(+2),(*2),(^2),(2^)] <*> [5,6]
17:01:57 <lambdabot>   [7,8,10,12,25,36,32,64]
17:02:00 <pumpkin> you can also use arrays
17:02:04 <mreh> yeah, Church numbers
17:02:12 <pumpkin> and heaven forbid, hash tables
17:02:15 <Cale> mreh: ^^ a list of functions like that one? :)
17:02:35 <mreh> Cale: no, the list was constructed out of functions
17:02:37 <pumpkin> > digits 56
17:02:39 <lambdabot>   [5,6]
17:02:41 <pumpkin> interesting
17:02:46 <mreh> and there was a higher order function to extract data from this list
17:03:01 <Cale> mreh: As in the implementation of lazy lists in a strict language?
17:03:05 <Cale> Or...
17:03:08 <EvilTerran> cads, don't worry, there's no one haskell way; i've seen quite a lot of aguing about whose way is more haskell-y in here ;)
17:03:15 <Cale> Oh, like the representation of a list as its right fold?
17:03:34 <augustss> mbz: http://conal.net/
17:03:36 <Cale> :t (\c n -> foldr c n [1,2,3,4,5])
17:03:38 <lambdabot> forall a b. (Num a) => (a -> b -> b) -> b -> b
17:03:46 <Cale> :t (\c n -> foldr c n [1,2,3,4,5]) (:) []
17:03:48 <lambdabot> forall a. (Num a) => [a]
17:03:50 <Cale> (\c n -> foldr c n [1,2,3,4,5]) (:) []
17:03:51 <Cale> > (\c n -> foldr c n [1,2,3,4,5]) (:) []
17:03:53 <lambdabot>   [1,2,3,4,5]
17:03:58 <mbz> augustss: thanks, I'll check
17:03:58 <Cale> > (\c n -> foldr c n [1,2,3,4,5]) (+) 0
17:04:00 <mreh> Cale: let me get hte slides
17:04:00 <lambdabot>   15
17:04:08 <Axman6> Cale: that's build right?
17:04:12 <Cale> Axman6: yeah
17:04:28 <Axman6> whoot! see, i read papers too :)
17:04:31 <augustss> > (\c n -> foldr c n [1,2,3,4,5]) f x
17:04:33 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 x))))
17:04:35 <lucca> makeCons x y = \q -> case q of Car -> x; Cdr -> y
17:04:55 <Cale> ah, in that sense.
17:05:05 <Cale> There are lots of ways for lists to be functions ;)
17:05:07 <EvilTerran> makeCons x y Car = x; makeCons x y Cdr = y
17:05:37 <Cale> Of course, that one has a strange type...
17:05:58 <kpreid> @remember EvilTerran forcedYet :: a -> Bool; forcedYet x = x `seq` True -- :P
17:05:59 <lambdabot> Nice!
17:06:01 <baaba> :t f
17:06:03 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
17:06:45 <EvilTerran> kpreid, heh, that's a way up in the scrollback
17:07:10 <kpreid> EvilTerran: I have a neat one-hour gap such that it isn't...
17:07:35 <EvilTerran> ah, cunning :)
17:08:11 <mreh> does anyone know where i can read the lambda papers in pdf?
17:08:36 <mreh> google scholar is nope hope
17:09:37 <roconnor> mreh: ftp://ftp.cs.ru.nl/pub/CompMath.Found/lambda.pdf
17:10:15 <kpreid> > let t i 0 = i; t i (d+1) = let (l,i') = t i d; (r,i'') = t i' d in (f l r, i'') in t 0 2
17:10:18 <lambdabot>       Occurs check: cannot construct the infinite type: t = (t1, t)
17:10:18 <lambdabot>        Ex...
17:11:16 <kpreid> huh?
17:14:50 <luqui> kpreid, the first case, "t i 0" is not returning a tuple as it should
17:15:02 <kpreid> yeah, just figured that out myself...duh
17:15:22 <kpreid> > let t i 0 = (i,succ i); t i (d+1) = let (l,i') = t i d; (r,i'') = t i' d in (f l r, i'') in fst $ t 0 2
17:15:24 <lambdabot>   Add a type signature
17:15:43 <luqui> kpreid, it's complaining about succ from Enum.  succ i :: Int should do the tricl
17:15:54 <kpreid> > let t i 0 = (i,succ i); t i (d+1) = let (l,i') = t i d; (r,i'') = t i' d in (f l r, i'') in fst $ t (0::Int) 2
17:15:56 <lambdabot>       No instance for (SimpleReflect.FromExpr Int)
17:15:56 <lambdabot>        arising from a use ...
17:16:02 <luqui> forgive me if I'm being too noobfriendly.
17:16:07 <kpreid> er, no...
17:16:34 <kpreid> > let t i 0 = (i,succ i); t i (d+1) = let (l,i') = t i d; (r,i'') = t i' d in (f l r, i'') in fst $ t (0 :: Expr) (2 :: Int)
17:16:37 <lambdabot>   f (f 0 (succ 0)) (f (succ (succ 0)) (succ (succ (succ 0))))
17:16:55 <kpreid> > let t i 0 = (i,i+1); t i (d+1) = let (l,i') = t i d; (r,i'') = t i' d in (f l r, i'') in fst $ t (0 :: Expr) (2 :: Int)
17:16:57 <lambdabot>   f (f 0 (0 + 1)) (f (0 + 1 + 1) (0 + 1 + 1 + 1))
17:17:06 <kpreid> hmf
17:17:08 <kpreid> ah
17:17:36 <kpreid> > let t i 0 = (fromIntegral i,succ i); t i (d+1) = let (l,i') = t i d; (r,i'') = t i' d in (f l r, i'') in fst $ t (0 :: Int) (2 :: Int)
17:17:39 <lambdabot>   Add a type signature
17:17:45 <arw> is it possible to instruct ghc to use the simd-registers of certain processors? like, i've got 4 int32-calculations which i would like to be packed into a single sse register?
17:17:50 <kpreid> > let t i 0 = (fromIntegral i :: Expr,succ i); t i (d+1) = let (l,i') = t i d; (r,i'') = t i' d in (f l r, i'') in fst $ t (0 :: Int) (2 :: Int)
17:17:52 <lambdabot>   f (f 0 1) (f 2 3)
17:17:56 <kpreid> there we go
17:18:03 <luqui> arw, yow.  maybe with DPH.
17:18:40 <kpreid> > let t i 0 = (fromIntegral i :: Expr,succ i); t i (d+1) = let (l,i') = t i d; (r,i'') = t i' d in (f l r, i'') in fst $ t (0 :: Int) (4 :: Int)
17:18:42 <lambdabot>   f (f (f (f 0 1) (f 2 3)) (f (f 4 5) (f 6 7))) (f (f (f 8 9) (f 10 11)) (f (...
17:18:45 <luqui> very, *very* experimental stuff, of course
17:19:10 <arw> luqui: yes, i guess so. many c compilers don't get it right :)
17:19:27 <Cale> You could write it in assembly and use the FFI.
17:19:32 <arw> the current implementation is handoptimized asm :)
17:19:49 <Axman6> arw: well use the FFI to access it :)
17:19:54 <arw> problem is, its not portable and unreadable :)
17:20:11 <luqui> I don't think anything which says "use the SIMD registers" is going to be portable
17:20:24 <luqui> and it's not going to be readable to anyone who doesn't know what SIMD registers are.. :-)
17:20:46 <luqui> (eg. most haskellers will prefer a state of ignorance to that sort of thing :-)
17:20:51 <arw> luqui: the intel c compiler inserts some detection code which switches between a simple and a simd code path
17:20:55 <sw17ch> it might not be readable by people who *do* know what they are :P
17:21:21 <arw> luqui: but that would be a feature for later :)
17:23:32 <conal> mbz: also see http://conal.net/papers/Eros/ and http://haskell.org/haskellwiki/TV
17:23:49 <conal> augustss: thanks for the plugs
17:24:44 <augustss> arw: you could use the LLVM interface
17:24:51 <mbz> conal: thanks for the links
17:25:31 <conal> :)
17:26:35 <sclv__> conal -- are you running the tests with two actual cpus?
17:27:01 <sclv__> the brackAsync versions work fine on the machine I'm on, but it only has once cpu
17:27:12 <xmux> Chapter 10 of RWH is too hard :(   I had previously not paid much attention to it because I thought it was really about parsing a bitmap and that seemed kind of boring
17:28:01 <conal> sclv__: i think i am.
17:28:21 <arw> augustss: there is a llvm-interface? nice.
17:28:25 <xmux> Is there somewhere else that I can read about the ideas introduced at about the same time as the ==> operator?
17:28:40 <sclv__> hmm... i'll play around more later. i feel confident that there has to be some magic combination of blocks and unblocks that solves all this.
17:28:43 <pumpkin> conal: that TV wiki page looks really cool
17:29:00 <conal> pumpkin: thanks :)
17:29:04 <xmux> I guess 'implicit state' is what I'm having trouble with
17:29:18 <augustss> arw: you'll have to generate your own llvm code, but the llvm has vector ops that map to real vector instructions
17:29:30 <pumpkin> one thing that's always bugged me about cross-platform GUI toolkits is that they might translate one widget to the equivalent widget on the other platform, but they retain the same "paradigms" across platforms, which is annoying and makes the app feel non-native
17:29:31 <conal> sclv__: i think it'll work out also.  i don't yet understand the resume-after-killed trick.
17:30:05 <Cale> pumpkin: I've never cared about my apps feeling native.
17:30:40 <sclv> the rts is strange and wonderful
17:30:41 <pumpkin> Cale: it's just annoying to have to deal with Windows-y stuff in mac os which doesn't fit
17:31:19 <sclv> i recall there are a number of open tickets on the bugtracker regarding asynchronous exceptions and their behavior, but I don't remember what all they said about the quirks.
17:31:56 <conal> sclv: oh.  i didn't know about the async bugs.  hm.
17:36:06 <augustss> conal: it sounds like what you need is the Erlang concept of linked processes.  When one of them die, they all die.
17:39:17 <sclv> conal: they're half bugs, half feature requests
17:39:19 <conal> augustss: yeah.  something like that.
17:40:00 * sclv goes to look some things up
17:44:30 <sclv> conal: http://hackage.haskell.org/trac/ghc/ticket/418
17:45:09 <luqui> pumpkin, TV is way cool.  wxhaskell blows though, so the current implementation is shaky.  The concept itself is quite powerful, though.
17:45:11 <sclv> also, by 6.12, salvation reputedly at hand: http://hackage.haskell.org/trac/ghc/ticket/2558
17:45:25 <pumpkin> luqui: yeah, I like the idea :)
17:45:37 <luqui> in particular, TV + FRP is a very neat prospect :-)
17:46:40 <sclv> oh and finally: http://hackage.haskell.org/trac/ghc/ticket/1657
17:46:40 <sclv> I think that covers it, but there may be others
17:47:33 <pumpkin> we either need a darcshub or we need more haskellers on github :P
17:49:46 * luqui is on github :-)
17:50:40 <luqui> I'm not that proud of it.  It's like shouting "the Haskell version control system isn't good enough for me"
17:51:30 <Philippa> a certain frog-like troll tried that line, that darcs not working out as well as hoped was a failure on the part of the language
17:51:40 <pumpkin> yeah, I'm not sure I buy that
17:51:41 <Philippa> it's bull - darcs was and is an experimental project
17:51:49 <pumpkin> I like darcs but I like github's social aspect
17:51:54 <pumpkin> and being able to keep track of projects easily
17:52:09 <pumpkin> so we need a darcshub I guess :P
17:52:16 <luqui> I like darcs but... no I don't.
17:52:28 <jeffz`> pumpkin: iirc someone was working on that
17:52:41 <luqui> Philippa, yes, that is important to remember.  I'm not too comfortable with it being a Haskell flagship.
17:53:11 <pumpkin> does darcs have an "api" that a haskell-based webapp could use?
17:53:27 <Saizan> no
17:53:34 <Saizan> that's the main problem
17:53:36 <Philippa> luqui: yeah, that's a mixed bag. Haskell /is/ good for experimental projects, cf Pugs
17:53:53 <arw> you need an api for that? git doesn't have one beyond the usual commands.
17:53:57 <Saizan> buy we still have darcs web
17:54:02 <pumpkin> yeah, you don't need an api
17:54:06 <pumpkin> but it'd make things easier
17:54:34 <Saizan> http://blitiri.com.ar/p/darcsweb/ <- so, some of the wrapping work has been done
17:54:45 <luqui> arw, what?  wasn't git designed as an API, upon which a real VCS would be built (and that never happened :-)
17:55:25 <arw> luqui: if you consider the initial bunch of shellscripts an api, maybe. but there is nothing one would usually call an api.
17:55:57 <Saizan> git's ui hasn't probably got any better from those scripts? ;)
17:56:01 <arw> luqui: of course you can call all the commands and parse their output, but there is no library you can link to and no spec.
17:56:19 <luqui> arw, hmm.  I was mistaken, I could have sword there was a man 3 git
17:56:24 <luqui> *sworn :-)
17:56:52 <luqui> yeah, thankfully that nice backend and total lack of ui is giving my company a good project :-)
17:56:54 <arw> luqui: there are some projects implementing a libgit. but none were really successful up to now.
17:57:27 <arw> and the man 3 git over here is for the perl module :)
17:59:17 <Saizan> how does github works for pushing? do they give you ssh access?
17:59:50 <luqui> Saizan, yeah.
17:59:56 <luqui> Saizan, kinda.  i.e. just barely.
18:01:40 <pumpkin> how does http://hackage.haskell.org/cgi-bin/hackage-scripts/package/stream-fusion compare to http://hackage.haskell.org/cgi-bin/hackage-scripts/package/uvector ?
18:02:40 <luqui> aren't they... totally different?
18:02:48 <pumpkin> I don't know, both mention stream fusion :P
18:02:50 <Saizan> well, they are different frontends for the same mechanism
18:05:19 <pumpkin> hmm
18:06:34 <Saizan> so if your computations totally fuse you're probably going to get the same code whatever of the two you use
18:08:26 <pumpkin> what's a good namespace for machine learning algorithms?
18:08:38 <pumpkin> Data.Learning.Blah?
18:08:44 <luqui> pumpkin, ew Data
18:08:48 <pumpkin> guess not
18:09:05 <pumpkin> Algorithm.Learning.Blah? :P
18:09:11 <Cale> Learning.* ?
18:09:23 <pumpkin> I'm scared of a new "root" but if you say so
18:09:26 <luqui> I'm starting to use a new convention, because the taxonomic structure of hackage is gross
18:09:35 <pumpkin> luqui: I agree :P
18:09:42 <pumpkin> what's your new convention?
18:09:45 <luqui> wherein I use PackageName.Module(.Module2...)
18:09:54 <luqui> so it's be MachineLearning.
18:10:11 <pumpkin> hmm
18:10:27 <luqui> it's not a great solution, but it seems more logical.  my project "udon" is the better solution, if I ever start working on it again.
18:10:32 <Saizan> org.machine.learning.foo
18:10:36 <luqui> haha
18:10:37 <pumpkin> lol
18:10:46 <luqui> heh, foo.learning.machine.org
18:11:11 <Saizan> never heard of the foo learning machine?
18:11:13 <luqui> I always wondered why java didn't just stay consistent and use gro.enimhcam.gninrael.oof
18:11:19 <pumpkin> yay, there are two Data.Stream s
18:11:25 <Cale> Com.Microsoft.Www.Learning.Machine
18:11:33 <pumpkin> lol
18:11:46 <pumpkin> I have Data.Stream from stream-fusion-0.1.2.1 Stream-0.2.6
18:11:47 <Cale> See how ugly we can make the qualified names :)
18:12:03 <pumpkin> Cale: I think you should _require_ alternating caps, at the least
18:12:26 <luqui> alternating caps = "
18:12:26 <pumpkin> CoM.mIcRoSoFt.WwW.lEaRnInG.mAcHiNe
18:12:27 <luqui> *?
18:12:32 <luqui> ohh! lol
18:12:43 <ddarius> Why don't we adopt Microsoft's strong naming approach then we can name modules whatever we want.
18:12:56 <Saizan> @elite org.machine.learning.foo
18:12:57 <lambdabot> or9.MAC|-|in3.|e4RninG.fOO
18:12:57 <pumpkin> and if you want to disambiguate between two things with the "same name" they can invert their caps
18:13:01 <pumpkin> or have different cap schemes
18:13:15 <Saizan> strong naming approach?
18:13:23 <luqui> ddarius, sounds like what udon is trying.  I'll look into strong names.
18:13:23 <pumpkin> in fact, I think all packages should be different arrangements of caps on "The quick brown fox..."
18:13:29 <pumpkin> *all names
18:13:41 <luqui> pumpkin, sure, 15 bits should be enough for a while
18:13:48 <pumpkin> only 15?
18:13:54 <luqui> or 35 for the whole phrase
18:13:56 <pumpkin> I meant the full sentence
18:13:57 <pumpkin> yeah
18:13:58 <luqui> which is surely enough
18:14:01 <pumpkin> 35 should keep us going for a while
18:14:14 <pumpkin> and it would improve legibility as it contains all letters in the alphabet!
18:14:15 <pumpkin> ;)
18:14:30 <pumpkin> import ThEquickbrownFOx
18:14:41 <pumpkin> import thEqUIcKBrowNFoX
18:14:47 <pumpkin> and so on
18:14:50 <ddarius> http://msdn.microsoft.com/en-us/library/wd40t7ad(VS.80).aspx
18:14:52 * luqui looks for a good test case of FRP without having to dive into OpenGL...
18:14:53 <pumpkin> everyone will know what you're talking about
18:17:29 <pumpkin> is there a "standard" order of imports?
18:17:49 * luqui doesn't know of one.  "the order I think of them" is the one I use.
18:17:51 <luqui> so just ask me :-)
18:18:21 <luqui> (If I'm messing with the Prelude I put it at the top, usually)
18:19:32 <pumpkin> will ghc-pkg unregister get rid of unused stuff?
18:19:38 <pumpkin> or just take a package out of the list?
18:19:54 <Saizan> out of the list
18:20:04 <pumpkin> is there a good way of getting rid of a package?
18:20:05 <Saizan> you need to rm the files manually
18:20:07 <pumpkin> ah
18:20:22 <pumpkin> I guess in the haskell world people only ever install stuff
18:20:36 <Saizan> unistalling is impure
18:20:55 <ddarius> See NixOS
18:21:51 <Saizan> (there's actually an open ticket on cabal-install about this)
18:22:10 <Olathe> Well, it's impure if you don't create a whole new image of your system without the thing installed in order to get the new value of your system.
18:22:13 <pumpkin> it seems like a strange omission
18:22:59 <ddarius> Okay, NixOS wins points by having a Commander Keen screenshot.
18:23:07 <cads> do you guys remember that functional linux system, where a system's packages and dependencies are represented as a single expression that evaluates into a configured running system?
18:23:27 <Saizan> wasn't that NixOS?
18:42:06 <pumpkin> I have a large set of data streams from sensors and am doing computations on them... what makes more sense, the stream-fusion lib, or the uvector on them? I don't (or rarely do) need to seek, so I don't really need an O(1) indexing structure which I think uvector is, but are there any other advantages to uvector over the stream-fusion lists?
18:52:10 <Olathe> > genRange (mkStdGen 5) undefined
18:52:12 <lambdabot>   Couldn't match expected type `a -> t'
18:52:25 <Olathe> > genRange (mkStdGen 5) undefined :: Int
18:52:27 <lambdabot>   Couldn't match expected type `a -> Int'
18:52:29 <EvilTerran> ?type genRange
18:52:30 <lambdabot> forall g. (RandomGen g) => g -> (Int, Int)
18:52:36 <EvilTerran> ?type mkStdGen
18:52:38 <lambdabot> Int -> StdGen
18:52:42 <Olathe> > genRange (mkStdGen 5)
18:52:44 <lambdabot>   (0,2147483562)
18:53:04 <Olathe> > genRange undefined
18:53:05 <lambdabot>   Add a type signature
18:53:11 <EvilTerran> > genRange (undefined :: StdGen)
18:53:12 <lambdabot>   (0,2147483562)
18:55:43 <pumpkin> @docs Data.Map
18:55:44 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
18:55:50 <pumpkin> hmm
18:55:57 <pumpkin> @docs Data.Set
18:55:57 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html
18:56:02 <pumpkin> ookay
18:56:16 <Olathe> Neat.
18:56:23 <Olathe> @docs Omg.Hi
18:56:24 <lambdabot> Omg.Hi not available
18:57:09 <Olathe> @docs Prelude
18:57:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
18:57:42 <pumpkin> why is Data.Map and Set broken?
18:57:45 <pumpkin> @docs Arrow
18:57:45 <lambdabot> Arrow not available
18:57:49 <pumpkin> @docs Control.Arrow
18:57:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html
18:57:57 <pumpkin> @docs Control.Monad.Instances
18:57:57 <lambdabot> Control.Monad.Instances not available
19:01:09 <jeffz`> pumpkin: looks like they have moved to containers from base
19:01:34 <pumpkin>  but that url has them in base?
19:01:44 <jeffz`> http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Set.html
19:03:46 <rwbarton> I usually find those pages through Hoogle
19:08:19 <jeffz`> I always use my local docs
19:16:14 <Olathe> > let f undefined = True; f _ = False in f 5
19:16:16 <lambdabot>   mueval: Prelude.read: no parse
19:16:16 <lambdabot>  mueval: UnknownError "GHC reported errors a...
19:16:23 <pumpkin> so can anyone go over when to use uvector vs. stream-fusion? is one just a "stream fusion" array, and the other a "list"? or is that oversimplifying?
19:16:26 <Olathe> (21:15.56) (lambdabot) mueval: UnknownError "GHC reported errors and also gave a result!"
19:16:27 <Olathe> Heheh
19:17:04 <pumpkin> lol
19:17:13 <izzy1> is there a standard function for rounding with the num of decimal places specified?
19:17:32 <Olathe> No, but it's easy enough to make.
19:18:06 <mauke> :t showFFloat
19:18:08 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
19:18:23 <Saizan> see Data.Fixed, also
19:19:00 <izzy1> cool, ill just look these up
19:19:05 <izzy1> thanks!
19:19:31 <Olathe> > let fTo f prec a = f (n*p)/p where p = 10**prec; roundTo = fTo round in roundTo 5 pi
19:19:33 <lambdabot>   Not in scope: `roundTo'
19:19:53 <Olathe> > let fTo f prec a = let p = 10**prec in f (n*p)/p; roundTo = fTo round in roundTo 5 pi
19:19:55 <lambdabot>       No instance for (RealFrac Expr)
19:19:55 <lambdabot>        arising from a use of `round' at...
19:20:16 <Olathe> > let fTo f prec a = let p = 10**prec in f (n*p)/p; roundTo a = fTo round a in roundTo 5 pi
19:20:18 <lambdabot>       No instance for (RealFrac Expr)
19:20:18 <lambdabot>        arising from a use of `round' at...
19:20:21 <Olathe> Bah.
19:20:37 <andyjgill> Does cabal install ignore minor version numbers?
19:20:43 <luqui> Olathe, you didn't define "n"
19:21:03 <luqui> > let fTo f prec a = let p = 10**prec in f (a*p)/p; roundTo a = fTo round a in roundTo 5 pi
19:21:05 <lambdabot>   Add a type signature
19:21:10 <luqui> bah! :-)
19:21:17 <luqui> > let fTo f prec a = let p = 10**prec in f (a*p)/p; roundTo a = fTo round a in roundTo 5 pi :: Double
19:21:19 <lambdabot>       No instance for (Integral Double)
19:21:19 <lambdabot>        arising from a use of `roundTo...
19:21:21 <luqui> oifjh[r n[o-r
19:22:04 <Saizan> ?type (**)
19:22:07 <lambdabot> forall a. (Floating a) => a -> a -> a
19:30:59 <Axman6> @src Floating
19:30:59 <lambdabot> class  (Fractional a) => Floating a  where
19:30:59 <lambdabot>     pi                                                      :: a
19:30:59 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
19:30:59 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
19:31:02 <lambdabot>     (**), logBase                                           :: a -> a -> a
19:33:40 <Olathe> > let fTo f prec a = let p = 10.0**(fromIntegral prec) in f (a*p)/p; roundTo = fTo (fromIntegral.round) in roundTo 5 pi
19:33:42 <lambdabot>   3.14159
19:33:56 <roconnor> > showCReal 5 pi
19:33:58 <lambdabot>   "3.14159"
19:34:59 <roconnor> @hoogle CReal -> Rational
19:35:00 <lambdabot> Warning: Unknown type CReal
19:35:00 <lambdabot> Prelude toRational :: Real a => a -> Rational
19:35:00 <lambdabot> Data.Ratio approxRational :: RealFrac a => a -> a -> Rational
19:35:04 <Olathe> > let fTo f prec a = let p = 10.0**(fromIntegral prec) in (fromIntegral.f) (a*p)/p; roundTo = fTo round; floorTo = fTo floor in floorTo 5 pi
19:35:05 <lambdabot>   3.14159
19:36:01 <Olathe> > approxRational pi 0.1
19:36:03 <lambdabot>   16%5
19:36:06 <Olathe> Oh.
19:36:14 <Olathe> @src approxRational
19:36:14 <lambdabot> Source not found. Just what do you think you're doing Dave?
19:36:20 <Olathe> > approxRational pi 0.01
19:36:22 <lambdabot>   22%7
19:36:34 <Olathe> > toRational pi
19:36:36 <lambdabot>   884279719003555%281474976710656
19:36:41 <Olathe> > toRational (pi :: CReal)
19:36:42 <lambdabot>   * Exception: CReal.toRational
19:36:54 <Olathe> How irrational.
19:37:19 <Olathe> > approxRational 0.0000000000000000000000000000001 pi::CReal
19:37:20 <lambdabot>   Couldn't match expected type `CReal'
19:37:22 <Olathe> > approxRational 0.0000000000000000000000000000001 (pi::CReal)
19:37:24 <lambdabot>   0%1
19:37:35 <Gracenotes> Olathe: what a transcendental experience that must be for lambdabot
19:37:35 <Olathe> > approxRational (pi::CReal) 0.0000000000000000000000000000001
19:37:37 <lambdabot>   * Exception: CReal.toRational
19:37:40 <Olathe> Yes :)
19:37:49 <Olathe> Bah, it can't do approxRational :(
19:38:20 <Olathe> So, approxRational uses toRational. How sneaky.
19:39:22 <roconnor> > floor (pi*10^5 :: CReal )/10^5 :: Rational
19:39:24 <lambdabot>       No instance for (Integral Rational)
19:39:24 <lambdabot>        arising from a use of `floor...
19:39:43 <roconnor> > fromIntegral (floor (pi*10^5 :: CReal))/10^5 :: Rational
19:39:44 <lambdabot>   314159%100000
19:40:18 <roconnor> read (showCReal 5 pi) :: Rational
19:40:32 <Gracenotes> > map (\a -> (1+(1/a))**a) [1..]
19:40:33 <lambdabot>   [2.0,2.25,2.37037037037037,2.44140625,2.4883199999999994,2.5216263717421135...
19:41:07 <llayland> before I roll my own, does anybody know of a generic implementation of genealogical comparison functions for mutually recursive datatypes?
19:41:57 <llayland> ie, isAncestor or isDescendent
19:42:40 <Axman6> > (\a -> (1+(1/a))**a) 1000000
19:42:42 <lambdabot>   2.7182804690957534
19:42:44 <Axman6> > (\a -> (1+(1/a))**a) 10000000
19:42:46 <lambdabot>   2.7182816941320818
19:42:52 <Axman6> > e
19:42:53 <lambdabot>   e
19:42:57 <Axman6> bah
19:43:03 <Axman6> > exp 1
19:43:04 <lambdabot>   2.718281828459045
19:43:12 <Axman6> > (\a -> (1+(1/a))**a) 1000000000
19:43:13 <lambdabot>   2.7182820520115603
19:43:17 <pumpkin> fail
19:44:23 <Olathe> > showCReal 100 $ (\a -> (1+(1/a))**a) 10000000
19:44:24 <lambdabot>   "2.718281692544966271198550225777813273153508271284404063885495379144352752...
19:44:36 <Olathe> > showCReal 100 $ exp 1
19:44:37 <lambdabot>   "2.718281828459045235360287471352662497757247093699959574966967627724076630...
19:44:41 <pumpkin> epic fail
19:44:51 <Gracenotes> :type scanl
19:44:58 <Gracenotes> *poke*
19:45:02 <pumpkin> :t scanl
19:45:03 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
19:45:05 <Olathe> @type scanl
19:45:07 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
19:45:07 <Gracenotes> oh. lols.
19:45:22 <Olathe> :m +Data.Ratio
19:45:59 <pumpkin> > (\a -> (1+(1/a))**a) 1000000000 :: Rational
19:46:00 <lambdabot>       No instance for (Floating (Ratio Integer))
19:46:00 <lambdabot>        arising from a use of...
19:46:10 <pumpkin> > (\a -> (1+(1/a))^^a) 1000000000 :: Rational
19:46:11 <lambdabot>       No instance for (Integral (Ratio Integer))
19:46:11 <lambdabot>        arising from a use of...
19:46:32 <roconnor> > (\a -> (1+(1/a))^a) 1000000000 :: Rational
19:46:34 <lambdabot>       No instance for (Integral (Ratio Integer))
19:46:34 <lambdabot>        arising from a use of...
19:46:48 <roconnor> > (\a -> (1+(1/fromIntegral a))^a) 1000000000 :: Rational
19:47:04 <lambdabot>   thread killed
19:47:07 <roconnor> oops
19:47:08 <pumpkin> aw
19:47:15 <Olathe> arising from a use of `^' at <interactive>:1:115-125
19:47:24 <Olathe> @type (^)
19:47:27 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
19:47:49 <pumpkin> :t (^)
19:47:51 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
19:47:52 <pumpkin> :t (^^)
19:47:54 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
19:48:04 <roconnor> you can't take rational to the power a rational
19:48:10 <pumpkin> :(
19:48:16 <roconnor> > (\a -> (1+(1/fromIntegral a))^^a) 1000000000 :: Rational
19:48:23 <pumpkin> what's the most general power function?
19:48:32 <lambdabot>   thread killed
19:48:34 <Gracenotes> **, isn't it?
19:48:42 <roconnor> (^) is the most general
19:48:43 <rwbarton> If there was one, we wouldn't have ^, ^^, and **, would we? :)
19:48:44 <Olathe> @type (**)
19:48:47 <lambdabot> forall a. (Floating a) => a -> a -> a
19:48:53 <pumpkin> > (1 :+ 2)**(2 :+ 4)
19:48:57 <lambdabot>   3.937155597696145e-2 :+ (-4.481901904875275e-2)
19:49:05 <roconnor> well
19:49:15 <Gracenotes> I'm not exactly so familiar with the entirety of Haskell's numerical system :)
19:49:16 <Olathe> @type (1 :+ 2)**(2 :+ 4)
19:49:18 <roconnor> maybe the generality of the different power functions isn't a total order
19:49:19 <lambdabot> forall t. (RealFloat t) => Complex t
19:49:39 <rwbarton> it's a tradeoff between generality in the base and the exponent variables.
19:49:41 <pumpkin> yeah
19:51:08 <Olathe> @hoogle (Num a) => a -> b
19:51:09 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
19:51:09 <lambdabot> Foreign.Marshal.Utils toBool :: Num a => a -> Bool
19:51:09 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
19:51:15 <pumpkin> lol
19:51:30 <arw> @src sum
19:51:30 <lambdabot> sum = foldl (+) 0
19:51:49 <pumpkin> why is sum a foldl and not a foldr?
19:52:45 <Gracenotes> iirc, a foldr thunk can take up a lot of space
19:53:09 <Olathe> Is there anything to take a Num to a Real ?
19:53:47 <_ar> i don't understand why it's not foldl'
19:53:51 <arw> not sure. and the most annoying thing is, it isn't strict so it eats up the stack...
19:54:02 <arw> _ar: exactly.
19:54:03 <pumpkin> _ar: I think that's because foldl' isn't standard
19:54:12 <Gracenotes> the simplest solution might be to define a sum'
19:54:20 <Gracenotes> @type sum'
19:54:22 <lambdabot> Not in scope: `sum''
19:54:23 <Saizan> ?src Real
19:54:24 <lambdabot> class  (Num a, Ord a) => Real a  where
19:54:24 <lambdabot>     toRational      ::  a -> Rational
19:54:25 <Gracenotes> yeah.
19:54:37 <Gracenotes> :/
19:58:07 <Gracenotes> @pl \a -> (1+(1/a))**a
19:58:08 <lambdabot> (**) =<< (1 +) . (1 /)
19:58:18 <Gracenotes> oops, not what I meant to paste. argh, terminals
19:58:29 <Gracenotes> @pl \a b -> log (b - a)
19:58:29 <lambdabot> (log .) . subtract
19:58:50 <Gracenotes> @pl \a b -> log (a - b)
19:58:50 <lambdabot> (log .) . (-)
19:59:06 <Gracenotes> hrm
19:59:35 <Olathe> @pl flip subtract
19:59:36 <lambdabot> (-)
19:59:41 <Olathe> @pl flip (-)
19:59:41 <lambdabot> subtract
20:02:00 <Axman6> subtract is there so that you can actually do things like (-x) right?
20:02:06 <Axman6> and use it as a function
20:02:31 <Olathe> @pl (flip (-) x)
20:02:31 <lambdabot> subtract x
20:02:47 <Olathe> Yeah.
20:07:15 <cads> you guys, which OS do you guys think is friendliest to a mathematician/computer scientist?
20:07:22 <cads> yous guys*
20:07:52 <wli> cads: IRIX
20:08:03 <arw> in my personal opinion it is debian or ubuntu
20:08:24 <jeffz`> which OS is friendliest to men who wear tophats?
20:08:29 <cads> i'd say that, because of all the esoteric math packages
20:08:51 <cads> wli, irix was pretty pimp back in the day
20:09:29 <arw> your question is not really answerable. its always a matter of taste.
20:09:31 <Adamant> jeffz`: STEAMIX v. 0.02
20:10:10 <cads> arw, true, I even suppose some might say windows because of the availability of certain high end maths packages
20:10:45 <pumpkin> if windows is a possible answer to any positive question, you know the question has a problem
20:10:46 <Adamant> I think most actual mathematicians just stick to their Mathematica section
20:11:09 <Adamant> as opposed to the computationally-oriented sort
20:11:13 <wli> Adamant: Depends on what kind of math.
20:11:22 <arw> cads: there is mathematica/maple/matlab for linux too. many of those packages are java-based nowadays.
20:12:02 <cads> I am trying to think of what the criterion really is
20:12:09 <arw> cads: and regarding specialized software you are in trouble anyways, there are areas of science where you would never find any windows-software.
20:12:13 <jeffwheeler> pumpkin: what about negated questions?
20:12:23 <jeffwheeler> pumpkin: err, I didn't read your message
20:12:54 <Adamant> arw: the reverse is also true for Unix though
20:13:06 <cads> for example I can feel my inner mathematician cringing if I run a linux where I have to manually tune configuration files for the system. it feels like details like that should be abstracted
20:13:22 <arw> Adamant: yes. it really depends on the things you want to do.
20:14:03 <arw> cads: try ubuntu, most of the time it needs less tuning than windows.
20:14:32 <cads> ubuntu makes me pretty darn happy
20:14:34 <arw> cads: but in the end, its a matter of taste and you can only judge by yourself.
20:15:43 <cads> arw, part of me really wants to play around with some research kernel
20:16:39 <arw> cads: try l4, they have a neat livecd, at least for x86.
20:17:00 <cads> something really exotic, not designed by committee... but things like that tend to spend little resources on the lowest common denominator, so you dont expect to have the niceties of your graphical desktops, etc.
20:17:12 <arw> but the more 'research' it gets, the more manually tuning the configuration/build/boot-files you will need.
20:17:43 <cads> yeah, been looking at l4 for a while, I'd like to see where that'd take off to
20:17:57 <cads> didn't know about the livedisk
20:18:07 <wli> cads: There's always k42.
20:18:15 <cads> arw, have you heard of l4.verified?
20:18:47 <arw> nope. i did a talk about 2 years ago about l4, but i didn't look at it again.
20:19:16 <arw> the concept of l4 looks really nice, the problem is the reality of its implementation.
20:19:50 <cads> I think it's an implementation of l4 using the Coq proof assistant and haskell to create a mathematically correct kernel
20:20:16 <cads> then translated into c (raises eyebrows)
20:20:31 <arw> sounds interesting. do they have performance measurements of that?
20:20:43 <cads> they're still implementing
20:20:50 <arw> ah, k.
20:21:13 <cads> i don't know if it'd go as fast as the linux kernel
20:21:30 <cads> but the idea of a kernel with absolutely zero bugs is interesting
20:21:48 <arw> yes, but keep in mind, its a microkernel.
20:22:01 <cads> yeah
20:22:05 <arw> it doesn't do much beyond message passing and memory management.
20:22:35 <cads> each server component would have to be implemented in the same way
20:22:56 <arw> not sufficient.
20:23:13 <arw> you also need to prove, that the interaction of your components is correct.
20:23:59 <arw> don't know if that wouldn't be a little more complicated.
20:24:17 <wli> Compared to little or nothing being proven correct with no component boundaries to cordon off anything into manageable proof burdens ...
20:24:53 <cads> well if each component was correct, then that'd just leave the possibility of your overall specifications being inconsistent, no?
20:25:16 <arw> cads: that and concurrency issues.
20:25:40 <cads> yow..
20:25:56 <Adamant> lambdabot: zippy
20:26:01 <cads> I'm gonna look up that l4 livecd
20:26:06 <Saizan> @yow
20:26:07 <lambdabot> America!!  I saw it all!!  Vomiting!  Waving!  JERRY FALWELLING into
20:26:07 <lambdabot> your void tube of UHF oblivion!!  SAFEWAY of the mind ...
20:26:11 <cads> wonder if it runs gnome or anything fun
20:26:37 <Adamant> forgot #haskell is not #scheme
20:26:49 <arw> cads: http://demo.tudos.org/
20:27:15 <arw> cads: it runs linux with l4 serving as a vmm
20:28:06 <arw> cads: but there is also a quake somewhere, and a raytraced homebrew gui :)
20:28:06 <cads> read about that being used to run realtime code along with linux
20:28:35 <cads> haha, diffuse interreflections on my UI elements
20:29:31 <cads> i'd like that
20:35:05 <rwbarton> What does it mean when a package name is wrapped in {} in the output of ghc-pkg list?
20:36:22 <chessguy> SamB:  ping?
20:36:51 <thoughtpolice> rwbarton: it's broken
20:36:57 <thoughtpolice> run `ghc-pkg check`
20:37:17 <thoughtpolice> it will probably tell you that some package it depends on is not registered or something
20:37:36 <rwbarton> Yep
20:37:38 <thoughtpolice> if there is no output, then it's likely the .conf file for the package that is used with ghc-pkg was broken
20:37:42 <rwbarton> Thanks
20:38:01 <chessguy> anybody know what this is? i don't get it. http://hackage.haskell.org/cgi-bin/hackage-scripts/package/StrategyLib
20:39:17 <thoughtpolice> chessguy: after a look and a google this might be of interest - http://www.cs.vu.nl/Strafunski/
20:40:00 <chessguy> aha, thanks
20:42:26 <rgr_> Could someone help me read this type : "product[1..5] :: (Num t, Enum t) => t"
20:43:02 <rwbarton> Hmm, I cabal installed the missing package, and now xmonad segfaults on startup...
20:43:27 <rgr_> (from ghci - :t product[1..5])
20:43:44 <British0zzy> does anyone know where i can find an implementation of bit vectors?
20:44:36 <rwbarton> rgr_: "any type t which is an instance of the Num and Enum classes"
20:44:47 <British0zzy> i need them to be arbitrary length and i don't require bitwise operations between vectors
20:44:54 <rwbarton> rgr_: basically, any type t where [1..5] makes sense as a value of type [t]
20:44:54 <British0zzy> i'm just using them for storage
20:45:11 <rgr_> os "or", not "and" ?
20:45:24 <wli> British0zzy: Data.Bits maybe? ByteString might do it too.
20:45:54 <rwbarton> British0zzy: a UArray of Bools might be one bit per entry... not sure
20:49:54 <Cale> it is
20:50:04 <pumpkin> wow, that's seriously unboxed
20:50:12 <pumpkin> :P
20:50:54 <pumpkin> I bet it only uses O(kolmogorovComplexity(array)) bits too
20:51:35 <roconnor> even though reader is a monad, I find the applicative functor interface nicer to use
20:51:56 <roconnor> I wonder if the applicative function interface is generally nicer for commutative monads.
20:52:31 * rgr_ sometimes wonders if the  contributors are bots ....
20:53:00 <roconnor> contributors?
20:53:04 <Saizan_> which other commutative monads do we have?
20:53:04 <thoughtpolice> #haskell - by bots, for bots
20:53:15 <roconnor> Saizan_: maybe
20:53:22 <roconnor> I argue that MonadRandom is one
20:53:22 * rgr_ thinks its confirimed :-;
20:53:54 <ik> @src last
20:53:55 <lambdabot> last [x]    = x
20:53:55 <lambdabot> last (_:xs) = last xs
20:53:55 <lambdabot> last []     = undefined
20:56:05 <dmwit> rgr_: Classes are always "and"ed.  There is no concept of class alternatives.
20:56:27 <Saizan_> for reader the restriction imposed by the applicative interface doesn't really apply because of laziness, but for Maybe that's different
20:57:05 <roconnor> Saizan_: I'm not following you
20:57:29 <idnar> > last []
20:57:31 <lambdabot>   * Exception: Prelude.last: empty list
20:59:08 <Saizan_> roconnor: with applicative i can't write "ifM mb m n = mb >>= \b -> if b then m else n", but only "liftM3 (\b x y -> if b then x else y)"
20:59:29 <Saizan_> roconnor: with reader they are semantically the same though
21:00:33 <ik> DAYCHANGE!
21:00:35 <roconnor> Saizan_: ah, the iffy miffy difference.
21:01:21 <roconnor> Saizan_: maybe that is why the applicative interface is nice to the reader monad
21:02:40 <roconnor> I wonder if I should mention this is my thesis...
21:04:29 <chessguy> hm, didn't somebody do some work on a propositional or predicate logic library in haskell?
21:04:38 <Saizan_> yeah, you get back the nice function application feel, without losing anything, so it's nearer to working in a dedicated language
21:05:14 <roconnor> I shall at least make a note in my research blog
21:06:33 <Saizan_> also nice that f (a -> b) and a -> f b are just a flip apart when f = (->) r
21:07:31 <dibblego> heh never noticed that before
21:13:38 <chylli> I want to get a url's contents, which package should I use ?
21:13:38 <lambdabot> chylli: You have 1 new message. '/msg lambdabot @messages' to read it.
21:15:51 <Saizan_> chylli: HTTP?
21:16:31 <kabny> Pure Devil Haskell
21:16:34 <kabny> awesome
21:21:14 <Lemonator> What are type families?
21:22:35 <pumpkin> they're like Citrus
21:22:38 <chessguy> Lemonator:  just ran across this the other day: http://www.haskell.org/haskellwiki/GHC/Indexed_types
21:23:19 <Orangeator> oh, that :)
21:24:18 <thoughtpolice> Lemonator: they allow you to have types indexed by other types, much like how you have functions which are indexed by values (meaning a function applied to something gives a result, so if f x = y, then you can say 'f' indexed at 'x' results in 'y')
21:24:36 <thoughtpolice> well, I think that's more the case for associated type synonyms, anyway
21:24:48 <Lemonator> so they're type-level functions?
21:25:00 <thoughtpolice> pretty much
21:26:00 <thoughtpolice> type families allow you to express type-level things very nicely, and are more 'functional' than 'functional dependencies' - despite the name - because fundeps express a /relation/, type families express an actual /function/ on types
21:26:46 <Cale> Well, multiparameter typeclasses express a relation, and functional dependencies say that relation happens to be a function
21:26:46 <Lemonator> huh.
21:27:17 <thoughtpolice> Cale: that's a better explanation, yeah.
21:27:42 <thoughtpolice> i like type families a lot more than fundeps. they are easier to grok IMO
21:30:08 <chylli> Saizan_: reading . thanks
21:31:01 <arw> gah, i hate surprises :)
21:31:36 <arw> my system just seemed to hang. turns out, it was swapping.
21:31:57 <arw> it seems, mapM print [1..1000000] is not always a good idea.
21:32:13 <Cale> Try mapM_
21:32:16 <dibblego> arw, mapM_ perhaps?
21:32:20 <roconnor> arw: I can give you more examples to screw with your system
21:32:32 <roconnor> oh wait
21:32:39 <roconnor> my examples are the same example
21:32:41 <BMeph> arw: Hmm, maybe you should try 'mapM_' instead of 'mapM... ;p
21:32:43 <roconnor> god damn mapM
21:33:17 <arw> thanks :)
21:33:47 <arw> .oO( stuff like mapM should carry an 'unsafe' prefix ;)
21:33:57 <Cale> arw: It's not unsafe
21:34:03 <arw> i know.
21:34:06 <Cale> arw: It's just that it collects a list of the results.
21:34:14 <Cale> arw: That list might be long :)
21:34:49 <Cale> and will generally be constructed whether or not you're interested in it
21:35:08 * roconnor 's mapM comment thread: http://www.reddit.com/r/haskell/comments/7itbi/mapm_mapm_and_monadic_statements/c06rvry
21:35:38 <Gracenotes> okay, halfway through to 100000 with mapM...
21:36:09 <kabny> who created the logo pure devil haskell?
21:36:10 <kabny> it is so friggin awesome
21:36:59 <Cale> kabny: hm?
21:38:16 <roconnor> kabny: putting the ask back in haskell
21:38:34 <Gracenotes> I can't help thinking how some of logos look more like gimels than lambdas :)
21:39:27 <thoughtpolice> i like Cale's logo
21:39:38 <thoughtpolice> i think it is the one i will probably vote for :)
21:40:57 <Gracenotes> ..how is the voting run? it is preferential?
21:41:00 <thoughtpolice> this one is cute though: http://www.haskell.org/haskellwiki/Image:Lenny2.png
21:41:51 <thoughtpolice> http://galois.com/~dons/images/logos/Haskell_logo.png <- the bottom one here is good too
21:42:32 <roconnor> Gracenotes: I think people are working on some Condorcet method
21:42:47 <roconnor> although I don't know who is elegable to vote
21:43:16 <roconnor> without a membership list, voting doesn't make much sense to me
21:43:25 * roconnor dislikes democracy
21:43:33 <roconnor> hrmph
21:43:36 <roconnor> :)
21:44:09 <Gracenotes> democracy dilutes responsibility :P
21:45:17 <Gracenotes> wow... mapM_ is so much faster than mapM for printing numbers from 1 to 100000. there's not even a comparison
21:45:56 <Axman6> @src mapM
21:45:56 <lambdabot> mapM f as = sequence (map f as)
21:46:00 <Axman6> @src mapM_
21:46:00 <lambdabot> mapM_ f as = sequence_ (map f as)
21:46:10 <Axman6> @src sequence_
21:46:10 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
21:46:21 <Axman6> @src sequence
21:46:22 <lambdabot> sequence []     = return []
21:46:22 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
21:46:22 <lambdabot> --OR
21:46:22 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
21:47:48 <dmwit> HASKELL... YEAHHH!
21:48:07 <arw> why doesn't the compiler notice that the return values are unused?
21:48:15 <BMeph> dmwit: "HASKELL       it works, bitches" ;)
21:48:28 <Cale> Gracenotes: How about putStrLn . lines . map show ?
21:48:43 <roconnor> arw: I think it is because of the recursive definition of sequence
21:48:48 <roconnor> @src sequence
21:48:48 <dmwit> arw: Good question.  What should it do if it does notice that?
21:48:48 <lambdabot> sequence []     = return []
21:48:48 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
21:48:48 <lambdabot> --OR
21:48:48 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
21:49:13 <dmwit> arw: (I ask this with the intention of asking for a general principle, one that isn't specific to mapM.)
21:49:20 <arw> dmwit: as any good compiler, discard it and not eat up space.
21:49:49 <dmwit> arw: Discard it how?  I think if you try to specify what you are suggesting a bit more precisely, you might find it's not so easy as you think. ;-)
21:49:59 <arw> dmwit: as a general principle, unused values should never be computed or stored if possible.
21:50:05 <Gracenotes> Cale: unlines?
21:50:08 <dmwit> arw: After all, (mapM f xs >> return ()) also discards its result. ;-)
21:50:29 <dmwit> (Yet is nowhere near as efficient as mapM_ f xs, as noted before.)
21:51:08 <francis> dmwit: http://www.grabup.com/uploads/595c4f9f020ad621b071f1e1d57372ca.png?direct < roflmfao
21:51:28 <dmwit> francis: exactly =)
21:51:40 <roconnor> dmwit: I understand what you are getting at
21:51:42 <arw> dmwit: isn't the difference that the first calculates the result, builds a list and then discards it, whereas the second immediately discards it?
21:51:44 * roconnor stands with arw
21:51:54 <dmwit> arw: Yes.
21:51:58 <dmwit> That is exactly the difference.
21:52:19 <dmwit> However, I don't see a good way to go from the source of mapM to the source of mapM_ in a clean, general way.
21:52:32 <dmwit> That's not to say such a way doesn't exist, of course.
21:52:37 <Gracenotes> Cale: in an unscientific experiment, mapM_ does about 0.13, map/show does about .14
21:52:42 <Gracenotes> seconds
21:53:07 <arw> dmwit: ./generate-nums 1000000 > /dev/null  37,86s user 0,16s system 96% cpu 39,583 total
21:53:21 <arw> the version with mapM_ instead of mapM takes 1s.
21:53:31 <dmwit> arw: I think you're misunderstanding me.
21:53:32 <roconnor> dmwit: change sequence into sequence (x:xs) = do v <- x; vs <- sequence xs; return undefined when the result of squence isn't used.
21:53:51 <dmwit> roconnor: Hm.  Doesn't that have the exact same problem?
21:53:55 <dmwit> It still builds the list.
21:54:03 <Gracenotes> how do we know the result isn't used...?
21:54:12 <dmwit> Gracenotes: I think that part is actually pretty easy.
21:54:13 <rwbarton> Doesn't that require some knowledge about the definition of 'return' for the IO monad?  (Or the monad laws?)
21:54:20 <roconnor> dmwit: not it doesn't.  I removed the (:)
21:54:32 <Gracenotes> dmwit: in what sense?
21:54:32 <dmwit> Gracenotes: (>>) throws away the result of its first argument.
21:54:53 <dmwit> Gracenotes: Then we can chase the call graph, throwing away results.
21:55:07 <Gracenotes> oh, no, I get sequence_
21:55:09 <dmwit> roconnor: You're right.
21:55:24 <dmwit> roconnor: Does it work?
21:55:26 <Gracenotes> but not so much roconnor's comments about sequence
21:55:32 * dmwit tests
21:55:54 <roconnor> Gracenotes: essentially the source of (>>) has a (\_ -> foo) bar in it, and here we can tell that bar is unused.
21:56:13 <Gracenotes> ahm.
21:56:15 <Gracenotes> this function: sequence (x:xs) = do v <- x; vs <- sequence xs; return undefined
21:56:43 <rwbarton> As far as that local piece of code (source of sequence) is concerned, return might be strict, so we'd need to inline it before concluding anything about how the parameter to return is used
21:56:44 * roconnor awaits dmwit's test
21:56:48 <Gracenotes> when the result of the sequence isn't used -- so we know in advance it won't be used
21:57:03 <Gracenotes> is that right? Do I seem slightly insane? :/
21:57:16 <arw> the general way i would imagine would be to detect the unused values. then trace back those values to their origins and, if possible, removing those calculations.
21:57:42 <rwbarton> and that in turn would require specializing sequence in the IO monad
21:58:25 <arw> so the compiler would first detect the values to be unused in the end, then detect an array of unused values which can be removed along with its generation.
21:59:14 <rwbarton> @undo do v <- x; vs <- sequence xs; return (v:vs)
21:59:15 <lambdabot> x >>= \ v -> sequence xs >>= \ vs -> return (v : vs)
21:59:48 <dmwit> ?index hPrint
21:59:48 <lambdabot> System.IO
22:00:34 <roconnor> dmwit: how is the test?
22:00:50 <dmwit> dmwitSequence is waaay slower than sequence_
22:01:10 <dmwit> it hasn't returned yet =/
22:01:10 <dmwit> I must have a bug.
22:01:24 <roconnor> a bug?
22:01:39 <roconnor> did you -O2 ?
22:01:41 <dmwit> http://hpaste.org/13396
22:02:29 <dmwit> Okay, with -O2, dmwitSequence is about 2x slower than sequence_.
22:02:32 <dmwit> Still not that great.
22:02:45 <Axman6> :t mapM (\x -> print x >> return x)
22:02:46 <lambdabot> forall a. (Show a) => [a] -> IO [a]
22:02:52 <roconnor> only 2x slower
22:02:58 <roconnor> that's good enough for me
22:03:15 <rwbarton> try changing dmwitSequence to the definition of sequence?
22:03:27 <dmwit> ?src sequence
22:03:27 <lambdabot> sequence []     = return []
22:03:27 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
22:03:27 <lambdabot> --OR
22:03:27 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
22:03:58 <roconnor> rwbarton: I think we all understand that sequence takes 1000000x longers
22:04:12 <rwbarton> roconnor: Just as a sanity check...
22:04:22 <roconnor> fair
22:04:57 <Axman6> :t \f xs -> mapM (\x -> print x >> return (f x))) xs
22:04:58 <lambdabot> parse error on input `)'
22:05:10 <dmwit> preludeSequence is slower yet
22:05:10 <Axman6> :t (\f xs -> mapM (\x -> print x >> return (f x))) xs
22:05:12 <lambdabot> Not in scope: `xs'
22:05:14 <dmwit> (@rwbarton)
22:05:22 <Axman6> :t (\f xs -> mapM (\x -> print x >> return (f x)) xs)
22:05:23 <lambdabot> forall a b. (Show a) => (a -> b) -> [a] -> IO [b]
22:05:33 <rwbarton> dmwit: like 2x, or zillionx?
22:05:39 <dmwit> 0.14s sequence_, 0.28s dmwitSequence, 0.39s preludeSequence
22:05:53 <dmwit> so 3x
22:06:42 <roconnor> dmwit: I'm more interested in memmory usage
22:06:49 <dmwit> oh
22:06:56 <dmwit> Go for it. ;-)
22:07:05 <roconnor> I'll think about it
22:07:12 <roconnor> maybe I'll go to bed instead
22:12:07 <rwbarton_> dmwit: also try adding a type signature  preludeSequence :: [IO a] -> IO [a]
22:12:59 <dmwit> ah
22:13:16 <dmwit> I'll stick a NoMR in instead.
22:13:37 <Gracenotes> @quote
22:13:37 <lambdabot> foot says: On a warm Saturday afternoon, sitting by the pool with a margarita, you casually sit up from your chaise lounge chair, reach over and pick up a gun, aim at your foot, and lazily pull the
22:13:37 <lambdabot> trigger.
22:13:52 <dmwit> rwbarton_: Basically the same times.
22:13:58 <dmwit> up to measurement error
22:14:00 <rwbarton_> Well, I want to specialize to IO to try to get return inlined
22:14:05 <rwbarton_> Maybe NoMR will do that also
22:14:25 <dmwit> Oh, specialize.  I thought you wanted it generalized. =)
22:14:27 <dmwit> okay
22:14:37 <rwbarton_> oh, oops.  I guess it was that way already, huh.
22:14:53 <dmwit> Still no change.
22:14:54 <rwbarton_> Wait, no, there are parameters on the LHS.
22:15:26 <rwbarton_> Oh well.
22:21:27 <sjanssen> dmwit: it doesn't seem surprising that dmwitSequence is slow
22:21:40 <sjanssen> that slowness in sequence is mostly the O(n) stack use
22:22:43 <dmwit> mm
22:22:56 <sjanssen> dmwitSequence also uses O(n) stack, as GHC isn't able to tell that (... >> return undefined) >> return undefined is just return undefined
22:23:26 <dmwit> I'm a long way away from finding Haskell's behavior predictable, though many times I can figure out why it happens after the fact. =)
22:23:46 <dmwit> And yeah, that makes a lot of sense.
22:24:00 <sjanssen> this is just your usual recursive function without tail recursion
22:24:55 <arw> so would the compiler be able to optimize this if it was tail recursive?
22:25:24 <sjanssen> sure
22:26:03 <arw> so one would just need to use some reverse_mapM which just happens to do the sequence reversed.
22:26:06 <sjanssen> drop the "return undefined" at the end, and you've got a function mostly equivalent to sequence
22:26:16 <sjanssen> arw: reverseMapM would also be slow
22:26:22 <sjanssen> O(n) heap isn't cheap either
22:26:32 <sjanssen> moral of the story: use sequence_ when possible
22:31:21 * luqui finds the cgi-undecidable package funny
22:31:49 <luqui> CGI and decidability are on opposite ends of the compsci spectrum
22:32:04 <luqui> (at least until now!)
22:32:06 <ddarius> The opposite ends of CS meet in the Haskell world.
22:34:05 <Gracenotes> > join (***) (join (***) show) $ ((1, 2), (3, 4))
22:34:06 <lambdabot>   (("1","2"),("3","4"))
22:34:31 <dmwit> , everywhere (mkT show) ((1, 2), (3, 4))
22:34:38 <lunabot>  ((1,2),(3,4))
22:34:48 <Gracenotes> > join (***) (join (***) (join (***) show)) $ (((1, 2), (3, 4)), ((5, 6), (7, 8)))
22:34:49 <lambdabot>   ((("1","2"),("3","4")),(("5","6"),("7","8")))
22:34:57 <dmwit> :t everywhere
22:34:59 <lambdabot> forall a. (Data a) => (forall a1. (Data a1) => a1 -> a1) -> a -> a
22:35:04 <sjanssen> @remember ddarius The opposite ends of CS meet in the Haskell world.
22:35:04 <lambdabot> Okay.
22:35:10 <dmwit> :t mkT
22:35:11 <lambdabot> forall b a. (Typeable b, Typeable a) => (b -> b) -> a -> a
22:35:29 <dmwit> whoops
22:35:30 <Gracenotes> @instances Typeable
22:35:31 <lambdabot> Couldn't find class `Typeable'. Try @instances-importing
22:35:47 <Gracenotes> @instances Data
22:35:47 <lambdabot> Couldn't find class `Data'. Try @instances-importing
22:35:47 <dmwit> ?instances-importing Data.Typeable Typeable
22:35:48 <lambdabot> s a
22:36:02 <dmwit> That's a lot less meaningful without the class restrictions. =P
22:36:04 <Gracenotes> ah
22:36:30 <dmwit> , everywhere (mkT (+1)) ((1, 2), (3, 4))
22:36:32 <lunabot>  ((2,3),(4,5))
22:44:52 <NameAlreadyInUse> the wikibooks page on monads gives "M a = s -> (a,s)" as an example of a monad that models mutable state
22:45:00 <NameAlreadyInUse> are there any other examples like that?
22:45:48 <Cale> Other examples of monads?
22:45:53 <NameAlreadyInUse> yeah
22:46:02 <Cale> Well, there's the list monad
22:46:11 <NameAlreadyInUse> what is that like?
22:46:11 <Cale> Which models nondeterminism.
22:46:24 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
22:46:26 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
22:47:23 <Cale> There's the monad (->) e
22:47:24 <NameAlreadyInUse> i mean, if "M a = s -> (a,s)" describes a monad for mutable state, what would that look like for the list monad?
22:47:31 <Cale> M a = [a]
22:47:36 <Axman6> , [$ty|everywhere|]
22:47:46 <lunabot>  forall a . Data a => (forall a . Data a => a -> a) -> a -> a
22:47:47 <Cale> Then there's the function/reader monad
22:47:52 <Cale> M a = e -> a
22:48:13 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
22:48:15 <lambdabot>   ("hello","olleh","HELLO")
22:49:03 <Cale> Or a parser monad,  M a = String -> [(String, a)]
22:51:00 <NameAlreadyInUse> so M a = [a], is that what they call the "type construction"?
22:51:25 <Cale> Well, you wouldn't write that literally as Haskell code.
22:51:40 <Cale> But yeah, M is a type constructor here, as are the brackets around the a
22:51:54 <Cale> You can write the list type constructor as [] and use it prefix as well.
22:52:02 <Cale> > [1,2,3] :: [] Integer
22:52:04 <lambdabot>   [1,2,3]
22:52:37 <NameAlreadyInUse> but what does the "<-" mean in "x <- [1, 2, 3]", for instance?
22:52:51 <Cale> Oh, that's part of do-notation.
22:53:24 <Cale> do {v <- x; <stmts>} = x >>= \v -> do {<stmts>}
22:53:29 <Cale> is the translation rule
22:53:34 <Cale> along with
22:53:48 <Cale> do {x} = x -- the base case
22:53:50 <Cale> and
22:54:04 <Cale> do {x; <stmts>} = x >> do {<stmts>}
22:54:09 <Cale> as well as:
22:54:31 <Cale> do {let <decls>; <stmts>} = let <decls> in do {<stmts>}
22:54:38 <RayNbow> NameAlreadyInUse, are you familiar with list comprehensions?
22:54:40 <Cale> So...
22:54:48 <Cale> @undo do x <- [1,2,3]; y <- [4,5]; return (x,y)
22:54:49 <lambdabot> [1, 2, 3] >>= \ x -> [4, 5] >>= \ y -> return (x, y)
22:54:58 <Cale> That's how it desugars.
22:54:59 <NameAlreadyInUse> RayNbow: no, everything in this language has been totally new for me
22:55:27 <Cale> >>=, along with return, is one of the basic monad operations which is defined separately for each monad
22:55:42 <RayNbow> oh, because list comprehensions also use the '<-' symbol
22:55:43 <Cale> and so whenever you have a monad, the do-notation becomes meaningful
22:56:07 <NameAlreadyInUse> and the "\x -> [4, 5]" is a lambda function?
22:56:19 <Cale> yeah, though it continues to the end of the line
22:57:11 <RayNbow> > [(x,y) | x <- [1,2,3], y <- "ab"]
22:57:12 <lambdabot>   [(1,'a'),(1,'b'),(2,'a'),(2,'b'),(3,'a'),(3,'b')]
22:57:50 <RayNbow> > do { x <- [1,2,3]; y <- "ab"; return (x,y) }
22:57:51 <lambdabot>   [(1,'a'),(1,'b'),(2,'a'),(2,'b'),(3,'a'),(3,'b')]
23:00:05 <Gracenotes> > sequence_ (replicate 2 [1,2])
23:00:07 <lambdabot>   [(),(),(),()]
23:02:01 <NameAlreadyInUse> so bind in that example is something like "List a -> (a -> List b) -> List b", and List is like "List a = [a]"?
23:05:15 <Cale> yeah
23:05:46 <Cale> So if you try to think of a function of type  [a] -> (a -> [b]) -> [b]  there aren't so many things you could guess.
23:06:40 <RayNbow> @djinn [a] -> (a -> [b]) -> [b]
23:06:40 <lambdabot> Error: Undefined type []
23:06:42 <Cale> You have a list of a's, and a function from a's to lists of b's, and you want a list of b's. You can map the function over the list, to get a list of lists of b's, and then you need to combine those somehow, so you can concatenate them.
23:06:51 <Cale> and that's exactly what bind does in the list monad
23:07:02 <Cale> That is,  xs >>= f = concat (map f xs)
23:07:24 <Cale> djinn is not smart enough to derive functions on recursive types
23:07:31 <mbz> concat? why not join?
23:07:33 <faXx> Any haskell gurus are awake at this early hour to help a lost sheep find his way to enlightenment?
23:08:00 <Cale> mbz: concat is in fact the join of the list monad.
23:08:07 <NameAlreadyInUse> and "\x -> [4, 5] >>= \ y -> return (x, y)" is the function from a's to lists of b's?
23:08:19 <Cale> NameAlreadyInUse: yeah
23:08:32 <Cale> NameAlreadyInUse: Might want to start with a simpler example...
23:08:32 <idnar> mbz: you can either define join and fmap, or (>>=)
23:08:46 <geezusfreeek> :t \x -> [4, 5] >>= \ y -> return (x, y)
23:08:47 <lambdabot> forall t t1. (Num t1) => t -> [(t, t1)]
23:08:55 <mbz> idnar: yep I know
23:09:08 <geezusfreeek> @pl \x -> [4, 5] >>= \ y -> return (x, y)
23:09:08 <lambdabot> (`fmap` [4, 5]) . (,)
23:09:12 <idnar> mbz: so, mixing and matching seems a bit weird
23:09:14 <NameAlreadyInUse> Cale: is there a simpler example?
23:09:27 <Cale> [1,2,3] >>= \x -> [x,x*10]
23:09:27 <idnar> mbz: unless you just meant xs >>= f = join (fmap f xs)
23:09:28 <Cale> > [1,2,3] >>= \x -> [x,x*10]
23:09:30 <lambdabot>   [1,10,2,20,3,30]
23:09:33 <mbz> the question was why not to use join since join is far more generic
23:09:48 <Cale> mbz: Because he probably doesn't know about join yet.
23:09:51 <idnar> mbz: join isn't defined yet :P
23:10:04 <mbz> oops.
23:10:29 <Cale> and yeah, if we want to actually write the Monad instance, the way things are set up, we have to define >>=
23:10:43 <Cale> So using join would make it circular.
23:10:52 <idnar> Cale: couldn't it default to the join/fmap definition?
23:10:57 <idnar> Cale: kinda like (==) and (/=) in Eq
23:11:05 <Cale> idnar: If things were set up correctly, yes.
23:11:11 <idnar> ah well
23:11:25 <mbz> I thought it is possible to define a monad usign return, map and join
23:11:52 <Cale> mbz: It is, just not directly using the Haskell 98 Prelude.
23:12:20 <Cale> mbz: Once you have appropriate definitions of those three, you get a definition of >>=
23:12:28 <Cale> (well, just from map and join)
23:13:25 <mbz> yep
23:13:28 <Cale> and we unfortunately call the generalised map function fmap
23:14:01 <mbz> since every monad is a functor?
23:14:06 <BMeph> faXx: As we like to say in #haskell, "Don't ask to ask, just ask." :)
23:14:16 <faXx> BMeph: oh okey then
23:14:24 <Cale> mbz: Well, that's another fact which is not represented.
23:14:50 <Cale> Every monad is a functor, but the only evidence we have for that in the Haskell libraries is the presence of liftM
23:14:59 <idnar> oh right, monad doesn't subclass functor
23:14:59 <Cale> (which is always an appropriate definition for fmap)
23:15:01 <idnar> I forgot about that
23:15:33 <Cale> There's a lot of small annoying deviations from the ideal there.
23:16:07 <faXx> I Basically got something like this : ... hGetContents a >>= (\b -> hClose a >> return b). This just gives me "" when i run it. Question: Is there a to force hGetContents to eval before i do hClose?
23:16:17 <faXx> way to *
23:16:28 <Cale> faXx: You should never ever hClose a handle that has had hGetContents applied to it.
23:17:00 <Cale> There is a way to force the contents, but it probably isn't what you actually want to do.
23:17:13 <Cale> You should probably just not close the handle. It'll be closed when you use up the file.
23:17:32 <Cale> (and the GC collects the string)
23:17:55 <Cale> If for some reason you need to close the handle in a timely fashion, then hGetContents is not what you want.
23:18:19 <Cale> (you might want the hGetContents for Strict bytestrings or something)
23:18:25 <idnar> @src hGetContents
23:18:25 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
23:18:37 <Cale> hGetContents is magic anyway
23:18:41 <faXx> In this case hClose will also result in the Socket which the Handle represents to close (at least according to the doc)
23:19:57 <Cale> import qualified Data.ByteString.Char8 as B, and then use B.hGetContents, and possibly B.unpack
23:21:01 <faXx> Cale: okey thanks will try that
23:21:42 <NameAlreadyInUse> is let f x = [x] equivalent to let f = \x -> [x]?
23:21:52 <British0zzy> hi, i'm slightly confused about constructors
23:21:56 <Cale> NameAlreadyInUse: yes
23:22:06 <Cale> British0zzy: In what way?
23:22:11 <British0zzy> is there a way to put guards on a contructor?
23:22:32 <Cale> British0zzy: No? I'm not sure exactly what you mean.
23:23:11 <Cale> Constructors are functions which are used to build values of a datatype, and in pattern matching to deconstruct them again.
23:23:19 <British0zzy> well, here's the code i'm using and i want to make sure that the size of bits is less than length^2
23:23:22 <British0zzy> http://hpaste.org/13397
23:23:44 <Cale> You can add guards after a pattern
23:23:55 <British0zzy> i want to limit the values of bits, depending on the value of length
23:24:02 <British0zzy> do you see what i mean?
23:24:21 <sjanssen> British0zzy: to do that, you can use what is called a "smart constructor"
23:24:25 <British0zzy> BitVector 3 16 should be illegal
23:24:54 <Cale> British0zzy: "Of course", that condition can't be statically checked, but you can dynamically check it and produce an error.
23:25:01 <British0zzy> yea
23:25:07 <British0zzy> thanks
23:25:12 <Cale> British0zzy: But it requires that you write a function which constructs values of type BitVector
23:25:34 <Cale> Also, you should note that UArrays of Bool will behave as bitvectors rather nicely.
23:25:45 <British0zzy> will i be able to pattern match a 'smart  constructor'?
23:25:47 <Cale> and they already have dynamic bounds checking
23:25:50 <Cale> No.
23:26:19 <NameAlreadyInUse> "let f x y z = [x, y, z]" and "let f = \x -> \y -> \z -> [x, y, z]", are they equivalent?
23:26:30 <Cale> There have been a number of proposals and extensions to ameliorate that situation though.
23:26:55 <Cale> You can define a function which deconstructs a value of your type, and then use view patterns.
23:27:46 <Cale> Or just export the length and bits fields, but not the BitVector data constructor
23:28:05 <Cale> Which means you can't pattern match, but at least you can apply those functions to extract the appropriate values.
23:28:29 <Cale> Also, it should be noted that 'length' clashes with the Prelude definition.
23:28:30 <British0zzy> ok, will do. thanks
23:28:36 <Cale> bvLength or something would work.
23:28:36 <sjanssen> NameAlreadyInUse: yes
23:33:39 <British0zzy> oh, is there anyway for me to be able to use setBit on a BitVector?
23:34:14 <British0zzy> i've tried using an instance of Bits, but it doesn't work
23:36:26 <sjanssen> British0zzy: you'd have to write your own instance
23:36:36 <sjanssen> British0zzy: also, have you considered using a UArray of Bool instead of Integer?
23:38:13 <British0zzy> i get an error when i make an instance
23:38:32 <British0zzy> No instance for (Num BitVector)
23:38:32 <British0zzy>       arising from the superclasses of an instance declaration
23:38:32 <British0zzy>     Possible fix: add an instance declaration for (Num BitVector)
23:38:32 <British0zzy>     In the instance declaration for `Bits BitVector'
23:39:36 <sjanssen> British0zzy: oh, that's because Num is a superclass of Bits
23:39:36 <sjanssen> so you'd have to write that instance too
23:39:56 <British0zzy> what do i need to change? here's the code http://hpaste.org/13397#a1
23:42:09 <rwbarton_> I don't think you really want to go down that path
23:42:13 <rwbarton_> just use UArray Int Bool
23:46:16 <sjanssen> British0zzy: you have to write instance Num BitVector where ...
23:46:26 <sjanssen> British0zzy: but UArray Bool is going to be much nicer here, methinks
23:46:27 <NameAlreadyInUse> i do not understand how "[1, 2, 3] >>= \x -> [x]" is [1, 2, 3] instead of [[1], [2], [3]]
23:47:23 <ddarius> That's equivalent to [1,2,3] >>= return which, by a monad law, is required to be [1,2,3]
23:48:08 <NameAlreadyInUse> so the "return" is implicit?
23:48:22 <RayNbow> NameAlreadyInUse: [1,2,3] :: [Int]
23:48:27 <Gracenotes> @src [] return
23:48:27 <lambdabot> return x    = [x]
23:48:28 <ddarius> No, return for [] is \x -> [x]
23:48:32 <RayNbow> \x -> [x] :: Int -> [Int]
23:48:47 <RayNbow> (>>=) :: [Int] -> (Int -> [Int]) -> [Int]
23:48:49 <idnar> NameAlreadyInUse: [1, 2, 3] >>= \x -> [x] = concat (map (\x -> [x]) [1,2,3] = concat [[1], [2], [3]] = [1, 2, 3]
23:49:16 <sjanssen> > map (\x -> [x]) [1 .. 3]
23:49:16 <sjanssen> > concat $ map (\x -> [x]) [1 .. 3]
23:49:16 <sjanssen> NameAlreadyInUse: (>>=) on lists maps, then concatenates the result
23:49:16 <sjanssen> lambdabot: @botsnack
23:49:16 <lambdabot> :)
23:49:18 <lambdabot>   [1,2,3]
23:49:18 <lambdabot>   [[1],[2],[3]]
23:55:28 <NameAlreadyInUse> so the list monad looks something like, "type List a = [a]", "(>>=) :: List a -> (a -> List b) -> List b", "(>>=) x f = concat (map f x)"
23:56:16 <ddarius> NameAlreadyInUse: You have to define return as well.
23:56:55 <NameAlreadyInUse> what would that look like?
23:57:03 <ddarius> @src [] return
23:57:03 <lambdabot> return x    = [x]
23:57:54 <NameAlreadyInUse> ah, i see
23:58:33 <citizen_earth> i just  posted http://www.reddit.com/r/programming/comments/7m694/online_store_recommendation/ ... and was wondering, in light of the recent real world haskell  books, if anyone knows of a good ecommerce softwware package written in haskell?
23:58:42 <citizen_earth> lookking for the xmonads of online stores
23:59:27 <NameAlreadyInUse> @src []
23:59:27 <lambdabot> data [] a = [] | a : [a]
