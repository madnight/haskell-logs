00:00:57 <Axman6> is ghci totally written in haskell? (and support RTS options?)
00:01:00 <Axman6> english++
00:01:18 <mmorrow> the actual bytecode interpreter loop is written in C
00:02:29 <mmorrow> but it calls into C--/compiled haskell/whatever code for everything that isn't bytecode (which is a lot if you think about it)
00:03:21 <mathy> smarmy: how comes in that code you can start printing xs before it's all been calculated?
00:03:21 <mathy> smarmy: doesn't the next line not get evaluated until the first one is?
00:04:21 <Axman6> :t iterate
00:04:23 <lambdabot> forall a. (a -> a) -> a -> [a]
00:04:43 <Axman6> > iterate (join (^)) 2
00:04:59 <lambdabot>   thread killed
00:05:09 <pumpkin> :o
00:06:46 <smarmy> mathy: well, because i cheated ;)
00:06:57 <mathy> smarmy: :o
00:07:04 <smarmy> mathy: you'd want to limit the amount printed, or translate all of the functions into the IO monad
00:07:12 <Axman6> hmm, i think that may be a way of writing tetration...
00:07:45 <Axman6> also a goog way to male ghci unresponsive
00:07:47 <Axman6> make*
00:08:34 <mathy> smarmy: still, how does that work though?  It's meant to print the whole of xs (surely), but xs isn't even assigned yet
00:08:47 <smarmy> mathy: sorry.  let me draw up the full version.  it would be more helpful to you to look at
00:09:39 <mathy> let xs = map _fib [0 ..  4000000]           print xs
00:09:49 <mathy> That prints out elements of xs as they're assigned, which doesn't make sense to me!
00:10:06 <Axman6> mathy: you know about laziness?
00:14:54 <erikc> how can i reify a string to an ExpQ in TH?
00:16:05 <smarmy> mathy: actually, this version is probably better to analyze.  less cruft in the way.  so a Axman6 asked... how familiar are you with lazy evaluation?
00:16:23 <smarmy> s/a/as/
00:17:47 <mmorrow> erikc: you can't directly with the TH pkg, but there's a pkg on hackage to do that (via parsing with haskell-src-exts, then translating that ast to TH's): http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskell-src-meta
00:18:40 <mmorrow> erikc: if you try that pkg, you've gotta have a NONcurrent haskell-src-exts pkg since the API just changed in it and i haven't updated haskell-src-meta yet
00:19:44 <mmorrow> this haskell-src-exts (copied to a darcs repo) is known to work with it http://moonpatio.com/repos/haskell-src-exts/
00:19:58 <mmorrow> err, so that's haskell-src-exts-0.3.8
00:20:02 <erikc> k
00:20:05 <Axman6> "GHC 6.10.1 cannot compile Crypto-4.1.0" well that's just awesome isn't it
00:20:08 <erikc> ill give it a shot
00:20:20 <mmorrow> erikc: i find it super handy :)
00:20:50 <jml> dons: so Data.Binary already has instances for a whole bunch of types, right?
00:20:57 <mmorrow> Axman6: just modify the .cabal and compile manually
00:21:05 <erikc> hehe yea, i need it to support arbitrary expressions, otherwise ill have to limit myself to just variable names most likely
00:21:10 <sjanssen> jml: yes, basically all of the Prelude types
00:21:11 <jml> dons: how would I take advantage of them inside an instance I'm defining?
00:21:17 <Axman6> mmorrow: what should i change?
00:21:31 <mmorrow> Axman6: what are the ghc-options:?
00:21:34 <olsner> jml: just use 'get' and 'put' in a context where the result type is determined by something else
00:21:41 <Axman6>   Ghc-options:     -fglasgow-exts
00:21:55 <mmorrow> Axman6: oh wait, thoughtpolice said it was just one of the test executables
00:22:04 <mmorrow> so just zap any mention of those maybe
00:22:11 <Axman6> http://hackage.haskell.org/trac/ghc/ticket/2753
00:22:35 <jml> olsner: do you know where I could find an example of that?
00:23:54 <mmorrow> oops, just killed my window by accident
00:24:09 <mmorrow> Axman6: it's the crypto pkg from hackage, right?
00:24:14 <Axman6> yes
00:24:23 <olsner> jml: hmm, there are a couple of examples at http://hackage.haskell.org/packages/archive/binary/0.4.4/doc/html/Data-Binary.html
00:24:23 * mmorrow looks at the .cabal
00:25:01 <Axman6> adding "  Ghc-options:     -fregs-graph -fglasgow-exts" to Executable      SHA1Test helped
00:25:30 <Axman6> i think...
00:25:52 <mmorrow> Axman6: ok, looks like you need to delete (at least)
00:25:54 <mmorrow> Executable      SymmetricTest
00:25:54 <mmorrow> ...
00:25:59 <mmorrow> (that section)
00:26:18 <erikc> mmorrow: hrm, i get a build error cause data.generics is in base and syb
00:26:37 <mmorrow> erikc: ugh, i hate that. add "syb" to the "build-depends:"
00:27:07 <mmorrow> oh wait, is it already there?
00:27:11 <Axman6> mmorrow: adding that line made everything build and instal just fine, no need to remove anything
00:27:13 <mmorrow> if so, delete it
00:27:20 <mmorrow> Axman6: nice :)
00:27:30 <erikc> k
00:28:18 <Axman6> whoot, got happs-tutorial installed finally
00:28:21 <mmorrow> erikc: from what i understand, if you're using 6.10 and base-4, you want the syb dep, but if base-3 and/or any other ghc you don't want it
00:28:22 <jml> olsner: ok, so the thing I don't quite understand from those examples is how it knows when to stop getting "s"
00:28:26 <jml> olsner: if that makes sense.
00:29:55 <Axman6> "using Haskell is like a premature optimization -- maybe you wouldn't need any paralelization because code will run fast enough, but you're already paying for it in code complexity"
00:30:04 <mmorrow> erikc: let me know how the build goes :)
00:30:52 <olsner> jml: you can also reuse the Binary instance for lists... generally, you have to write some kind of header that determines how many items you want to get or indicates end-of-data if you have a variable-size structure
00:31:32 <jml> olsner: right. so I understand that -- that's language neutral.
00:31:36 <mmorrow> or you can do a "chunked" encoding
00:31:41 <olsner> so it's not a general parser, 'get' just reads what you ask it to read
00:32:03 <jml> olsner: but that example has a get that feeds into a String, but it doesn't define how the String is encoded.
00:32:25 <jml> so, it's not clear if it's length-prefixed or null-terminated or something else.
00:32:41 <olsner> String = [Char], so by default it writes/reads it as a list of chars
00:33:01 <jml> yeah, but how does it know to stop reading the list.
00:33:20 <olsner> I would guess it has a length prefix
00:33:57 <olsner> if you need to read a specific format you may have to leave the Binary instances and write your own getters and setters
00:33:58 <jml> ok, so the example dodges the question by not defining the encoding for a list of characters.
00:34:01 <olsner> *putters
00:34:40 <jml> I'll go back to mucking around then.
00:34:53 <erikc> mmorrow: yea, i need to change the cabal to use an explicit base version and then drop/keep syb
00:35:03 <erikc> is base-3 or base-4 the default with ghc10?
00:35:23 <erikc> without an explicit base version it fails either way
00:36:29 <mmorrow> erikc: it ships with both, so i don't think one or the other is the default (which makes stuff like this happen :)
00:36:40 <mmorrow> good to know, i've really gotta update that pkg.
00:37:01 * mmorrow bumps it's todo-priority a few notches
00:37:22 <sjanssen> jml: since you're interfacing with an existing protocol, you'll probably need to write your own serialization
00:37:55 <mmorrow> erikc: so you got it built then i take it?
00:37:59 <erikc> yup
00:38:02 <mmorrow> cool. :)
00:38:07 <sjanssen> jml: the Binary class just choses some arbitrary serializations to make it easy to serialize Haskell tyeps
00:38:27 <jml> sjanssen: ok, thanks.
00:39:04 <jml> part of the thing I'm trying to figure out is how I can build my serializer one layer at a time, so to speak. I think I'm figuring it out.
00:39:10 <jml> slowly.
00:39:26 <Dynetrekk> hi folks. could anyone tell me how to completely uninstall cabal, ghc and all its packages? I've been playing around a bit too much I think, so I'm completely unable to even understand the error messages I get :P (and there's a lot of diferent ones, mostly regarding libraries)
00:39:33 <Dynetrekk> the alternative is to not use haskell, sadly ...
00:40:26 <sjanssen> Dynetrekk: see "ghc-pkg unregister -f"
00:40:30 <Axman6> Dynetrekk: why don't you try asking for help in here first?
00:40:42 <Dynetrekk> Axman6: I did, and it didn't quite help :(
00:40:53 <sjanssen> Dynetrekk: also, if you put some error messages on hpaste, we can probably at least diagnose the problem
00:41:04 <Dynetrekk> yeah, I tried to yesterday
00:41:10 <Dynetrekk> but I just got more and more of them
00:41:13 <Axman6> wel what are your problems? if you're having library issues, that's usually fixed by using --make with ghc...
00:41:36 <Dynetrekk> Axman6: hmm... okay... let's try this error message then
00:42:21 <Dynetrekk> http://hpaste.org/12995?lines=true
00:43:08 <Axman6> sounds like you need ghc 6.10 instaled, what version of ghc do you have>?
00:43:10 <Dynetrekk> and this http://hpaste.org/12996
00:43:13 <sjanssen> Dynetrekk: you've got GHC 6.8, right?
00:43:14 <Dynetrekk> 6.8.3
00:43:16 <Dynetrekk> yep
00:43:26 <sjanssen> Dynetrekk: okay, you just have to use an older version of syb
00:43:27 <Dynetrekk> I use the one from fink, and was hoping to stay with that
00:43:33 <Dynetrekk> sjanssen:  how?
00:43:44 <Dynetrekk> and what is syb? I never installed it cosciously
00:43:54 <Axman6> Dynetrekk: ah, if you're on a mac, install macports and use that, it's up to date, fink is slowly dying
00:44:03 <sjanssen> Dynetrekk: oh, actually, you don't need syb at all
00:44:04 <Dynetrekk> Axman6: dying? seriously?
00:44:08 <Axman6> yes
00:44:19 <Dynetrekk> wtf. I was so happy with it :P
00:44:19 <Axman6> afaik it's barely supported on leopard
00:44:23 <sjanssen> Dynetrekk: in older GHC packages, syb is included in base
00:44:32 <Dynetrekk> Axman6: works like a charm in every other sense than ghc
00:44:39 <Dynetrekk> and I'm on leopard etc etc
00:44:43 <sjanssen> Dynetrekk: the second error message means you don't have the C library "libgsl" installed, or it is somehow misconfigured
00:44:54 <Axman6> Dynetrekk: obviously it's not up to date though
00:44:56 <Dynetrekk> sjanssen:  misconfigured? no, it works with pygsl
00:44:59 <Dynetrekk> i.e. python
00:45:10 <sjanssen> Dynetrekk: Haskell can't find it
00:45:11 <Dynetrekk> Axman6: sure... I'm glad to hear about such things, by all means
00:45:25 <Dynetrekk> sjanssen:  yeah, sure, and there's a lot of these messages, though some things seem to work'
00:45:31 <Dynetrekk> hence I figured uninstall, reinstall...
00:45:32 <sjanssen> Dynetrekk: maybe try re-installing hmatrix and see if it makes GHC happy?
00:45:38 <Dynetrekk> sjanssen:  been there done that
00:45:42 <Dynetrekk> :P
00:45:48 <sjanssen> Dynetrekk: got any more errors?
00:45:58 <Axman6> hmatrix is a pain on OS X. you need to install it by hand and point it to gsl
00:46:10 <erikc> mmorrow: works great too, boggle, it blows my mind that it works that easily :)
00:46:11 <Dynetrekk> Axman6: allright...
00:46:21 <Dynetrekk> Axman6: even using macports? :P
00:46:24 <Axman6> even then, runTests (n>10) causes a segfault
00:46:36 <Axman6> Dynetrekk: yes
00:46:38 <Dynetrekk> Axman6: hm, okay
00:46:46 <erikc> is 'report' the way to fail compilations in TH?
00:46:54 <Dynetrekk> Axman6: maybe haskell is too much work. I spent several hours yesterday trying to fix these things
00:46:56 <sjanssen> Axman6: oh, is hmatrix simply just broken on OS X, then?
00:47:02 <Dynetrekk> (with the help of the cunning people here)
00:47:15 <Axman6> sjanssen: sort of. it works, but the tests they tell you to run segfault
00:47:16 <sjanssen> Dynetrekk: it sounds like you're just having trouble with a few specific packages
00:47:19 <Axman6> for me at least
00:47:20 <Dynetrekk> Axman6: I wouldn't trust a library that segfaults?
00:47:26 <Dynetrekk> a few...?
00:47:43 <Axman6> Dynetrekk: have you tried to actually learn haskell yet?
00:48:17 <Axman6> because all you need is ghc. you shouldn't need any extra packages to learn the basics (which is where you should start, playing with things like hmatrix will get you confused)
00:48:32 <Dynetrekk> Axman6: to some extent.... but I don't want to put energy into it unless I am able to use it for stuff I work with... right?
00:48:42 <Dynetrekk> Axman6: hehe, could be :)
00:49:00 <Axman6> Dynetrekk: well, if you started out like same people do and use macports, you'd be  in a better position ;)
00:49:20 <Axman6> you'd at least have ghc-6.10
00:50:02 <lispy> mac ports is not a good thing
00:50:07 <Dynetrekk> Axman6: you're serious about macports being better than fink? could you give any reason?
00:50:19 <Dynetrekk> lispy:  sure, but I don't want 5 package managers (not even 2 in fact)
00:50:20 <Axman6> Dynetrekk: it's maintained for one ;)
00:50:21 <lispy> it builds binaries that break whenever apple makes a new security release
00:50:29 <Dynetrekk> Axman6: so is fink, to some extent?
00:50:32 <Axman6> lispy: um wut?
00:50:37 <Dynetrekk> lispy: what breaks?
00:50:55 <Axman6> Dynetrekk: it's dying, trust me. come to #macosx and ask, you'll get the same response from any number of people
00:50:59 <lispy> every time I've used macports to install emacs it starts segfaulting on startup as soon as apple makes an OS patch
00:51:20 <Axman6> i've never had any problems like that with macports, and i have... sec
00:51:24 <Dynetrekk> Axman6: okay, thanks for letting me know, anyway
00:51:59 <Dynetrekk> Axman6: it works like fink in that it makes its own directory tree?
00:52:02 <lispy> Another annoyance with macports is that they insist on installing to a non-standard location so you have to change all your environment variables to make things build against things installed with macports
00:52:11 <Axman6> lispy: i'd blame that on emacs personally, doesn't happen to anything else
00:52:29 <Axman6> Dynetrekk: yes
00:52:49 <lispy> I've also seen people who use the darcs macport have problems with darcs that don't affect people who build darcs from source on the same machine
00:52:52 <mmorrow> erikc: awesome! great to hear :)
00:53:06 <Dynetrekk> Axman6: lispy seems to disagree with you somehow :P I'd like it if it was LESS work, not more, using than fink... if you catch my drift
00:53:13 <Axman6> i have 599 packages instaled with macports, and none have broken after OS X updates that i know of (exccpt erlang, which was basically exploiting a security hole to run anyway)
00:53:27 <lispy> Dynetrekk: fink is worse than macports any day of the week :)
00:53:29 <Dynetrekk> Axman6: impressive
00:53:44 <Dynetrekk> lispy:  all right, I'm pretty happy with fink, so... sounds good
00:54:02 <Dynetrekk> I almost never had problems after changing to unstable, source installs.
00:54:05 <sjanssen> sounds like you guys need to switch to a proper platform :)
00:54:14 <Dynetrekk> sjanssen: window$?
00:54:16 <Axman6> Dynetrekk: i'm not going to argue. macports is hosted by apple, and by far more popular than fink, for very good reasons. if you want broken ghc, then stick with fink, if you want it to al work, use macports
00:54:19 <sjanssen> I hear they give Linux away for free!
00:54:28 <Dynetrekk> Axman6: I'll try out macports at least
00:54:50 <Dynetrekk> sjanssen: I have linux as well, but I don't like the user interface as much
00:55:14 <lispy> if you do, and suddenly you can't find the man pages for things, it's a known bug and the work around is to update env variables
00:55:22 <Axman6> sjanssen: what, like one of the BSD's? linux is not a proper platform...
00:55:53 <sjanssen> Axman6: I'm sure we could make silly arguments about why one platform or another sucks :)
00:56:05 <sjanssen> but it is factual that GHC works very well on Linux
00:56:08 <mathy> The Mac should have been called MacBSD xD
00:56:28 <Axman6> sjanssen: it works very well on OS X too :)
00:56:34 <mathy> That'd suck dongs re: product differentiation etc. for Apple's marketing
00:56:41 <Dynetrekk> there's a ton of good ideas in mac os x. of course, some things are better in linux, but not everything...
00:56:54 <Axman6> mathy: plus it wouldn't be all that correct afaik
00:57:17 <mathy> Axman6: aww.  Isn't Mac based upon BSD, though?  (Or a `bastardization' of it? :p)
00:57:42 <Axman6> i've never found anything in any linux distro that's made me want to use it. any of the BSD's can do all the things i want, and i find them far better organised
00:57:58 <august> bsd and the mach microkernel
00:57:59 <Dynetrekk> Axman6: interestingly, there are twice as many folks in the #macports as the #fink channels
00:58:08 <Axman6> mathy: it is based on FreeBSD's userland, but a that's about it for BSDishness
00:58:28 <Axman6> Dynetrekk: well yes, i told you it was a) more popular, and b) better supported ;)
00:58:40 <lispy> So my top 2 gripes with macports is: 1) things break in new ways distinct to macports; 2) They purposefully do not integrate with the rest of the OS which forces users to tweak tons of settings
00:58:42 <Dynetrekk> Axman6: in open source, those are ususally connected
00:58:43 <Axman6> Dynetrekk: a lot of the people in #macports work for Apple too, which is nice
00:58:51 <Dynetrekk> Axman6: jolly good
00:59:20 * Dynetrekk is installng macports by popular demand
00:59:29 <sjanssen> lispy: don't you have to install separately from the OS when you don't have real control of upstream (Apple)?
00:59:43 <Dynetrekk> sjanssen:  so what?
00:59:50 <olsner> lispy: integrates pretty seemlessly in the shell/X11 part of mac os though :)
00:59:53 <Axman6> Dynetrekk: the instaler will sit there for a long time like it's stuck, it's not. it's doing the initial rsync sync
01:00:05 <Dynetrekk> Axman6: I seem to be at that point
01:00:15 <lispy> olsner: until you try to build something against a macport installed library and ld can't find it
01:00:23 <erikc> hurray, interpolated strings!! http://hpaste.org/12997
01:00:30 <lispy> olsner: so you type man to see the man page and man says it's not there
01:00:36 <olsner> hmm, that hasn't happened to me
01:00:44 <Dynetrekk> Axman6: done? didn't take too long
01:00:44 <Axman6> lispy: well, yeah. they're doing the right thing by using their own directory tree
01:01:09 <Axman6> good
01:01:10 <Dynetrekk> Axman6: now what?
01:01:10 <lispy> and why don't the builds cleanup after themselves?
01:01:22 <olsner> hmm, maybe I just hacked in the right macports paths in the right environment variables, forgot about it, and thought everything just worked :P
01:01:27 <Axman6> Dynetrekk: onlt other thing you need to do is add /opt/local/bin to your path, and you'll be right
01:01:34 <Axman6> lispy: they do in 1.7 i think
01:01:38 <Dynetrekk> Axman6: allright...
01:01:38 <lispy> olsner: yeah, that's what they force you to do to make it work
01:02:11 <Axman6> lispy: also, if you dislike macports so much, want to give me a hand in writing a haskell replacement?
01:02:27 <Axman6> probably wouldn't fix your issues, but it should fix many others
01:02:40 <mmorrow> olsner: i hate when that happens! then you reinstall and are like wtf!!?!
01:03:03 <mmorrow> then you realize how epic it was and that you've forgotten /everything/ you had to do
01:03:34 <olsner> heh, yeah
01:04:08 * Axman6 doesn't find ./configure LDFLAGS="-L/opt/local/lib -I/opt/local/include" is that hard to remember
01:04:13 * mmorrow had this happen recently with a few things
01:04:58 <lispy> env variables are like globals
01:05:27 <olsner> more like dynamic binding
01:05:30 <Axman6> hmm, i'd really like it if the happs-tutorial actually worked...
01:05:44 <lispy> Axman6: why on earth would you reimplement it in Haskell?  That seems like it would be contributing to the proliferation of square wheels instead of addressing the problems
01:06:03 <Axman6> i just get "Server error: templates: getDirectoryContents: does not exist (No such file or directory)" when i try and run it, either the executable or in ghci
01:06:29 <Axman6> lispy: i find it works quite well, no issues here. what's your problem with it?
01:06:34 <lispy> sounds like you need a directory named templates?
01:06:46 <lispy> Axman6: I think I've just named a few
01:07:16 <Axman6> the fact that emacs is crap and breaks? that's not a macports issue afaict
01:07:41 <lispy> check your scroll back
01:07:46 <lispy> I get sick of repeating myself
01:08:34 <C-Keen> hi lispy! relax :)
01:09:14 <Axman6> well about installing in /opt... well that makes good sense. /opt is a pretty standard directory in unix systems, and using it stops you from breaking things instaled by the system in /usr (and leaves /usr/local/ for things you compile from source)
01:10:33 <Dynetrekk> Axman6: I agree, even if I don't know as much about this stuff as you :) and aquamacs emacs seems more reasonable on a mac, btw.. I use it a little...
01:10:49 <Dynetrekk> Axman6: no man page for port?
01:11:01 <sjanssen> Axman6: macports' usage of /opt is not at all standard
01:11:15 <Axman6> Dynetrekk: need to add /opt/local/share/man/ i think, to your MANPATH
01:11:46 <quicksilver> conal: Aha. I have tracked down the most serious memory leak in my semantics.
01:12:10 <Dynetrekk> Axman6: seems right, yes
01:13:13 <Dynetrekk> Axman6: woho, it works.
01:13:19 <Axman6> good :)
01:13:25 <Axman6> now, sudo port install ghc
01:13:39 <lispy> then wait 6-10 hours
01:13:52 <lispy> hope you get a valid build :)
01:13:53 <Axman6> (one feature i liked about fink was it asked you for your password if it needed it
01:14:24 <Axman6> they've done a lot of work to make sure ghc works fine on OS X, and it does. lispy is just being difficult
01:14:28 <C-Keen> I installed ghc by building it without mac ports
01:14:37 <Dynetrekk> Axman6: yep, like that. ports is doing its magic now...
01:15:06 <Dynetrekk> Axman6: does ports do source or binary installs? I had less problems when using source in fink
01:15:10 <Dynetrekk> (except more time spent)
01:15:14 <Axman6> source
01:15:20 <Dynetrekk> Axman6: always?
01:15:24 <Axman6> yep
01:15:32 <Dynetrekk> fair enough, but takes time
01:16:05 <Dynetrekk> what about darwinports? is that something else?
01:16:09 <Axman6> yes, and ghc takes a long time to compile. i'd go get some food ;)
01:16:19 <Axman6> darwinports turned into macports
01:16:29 <Axman6> when apple took it over and started macosforge
01:16:33 <Dynetrekk> Axman6: I have integrals to calculate, no problem
01:16:39 <Dynetrekk> and food
01:16:42 <Axman6> good work
01:17:44 <Dynetrekk> Axman6: but now I guess I should delete ~/.cabal ?
01:18:03 <Dynetrekk> advice appreciated :P I got in trouble last time i rm'ed that dir
01:18:05 <Axman6> i don't think so, i'm not an expert on cabal
01:18:18 <Dynetrekk> Axman6: nothing in there works now, anyway....
01:18:27 <Axman6> heh
01:18:52 <Axman6> a lot of common packages are instalable from macports too. but cabal install is the best wy
01:18:55 <Axman6> a*
01:19:15 <Dynetrekk> I see
01:19:24 <Dynetrekk> so get cabal once ghc is in place
01:19:47 <Axman6> yeah. cabal update; cabal upgrade might work
01:20:27 <Dynetrekk> I think I want to rm in some way. I would prefer to start from scratch when there is no indication that it works properly
01:23:46 <Axman6> fair enough
01:24:45 <yakov> I need CORBA for Haskell, do we have it? I found hdirect and i'm on it's user manual at the moment but i don't see CORBA there..
01:26:18 <Dynetrekk> Axman6: does port compile with optimizations? it would be nice if it did by default
01:26:51 <Axman6> depends on the port i think, but i believe you can tell it to in the config. (telling make to use -j3 or so is very useful)
01:27:11 <Dynetrekk> Axman6: -j3? okay. sudo port config, or similar?
01:27:34 <Axman6> no, it's in /opt/ somewhere. i'll see if i can find it
01:27:46 <jml> what's the difference between these two statements?
01:27:47 <jml> data Foo = MkFoo String
01:27:47 <jml> newtype Foo = MkFoo String
01:28:20 <sjanssen> jml: the difference is very subtle
01:28:24 <Jarvis> Does anyone know when the next version of Haskell will be released?
01:28:26 <Dynetrekk> Axman6:  /opt/local/etc/macports $ ll macports.conf
01:28:26 <Dynetrekk> -rw-r--r--  1 root  admin   2.9K Dec 17  2007 macports.conf
01:28:26 <Dynetrekk> ?
01:28:26 <jml> oh goodie :)
01:28:45 <Axman6> sounds like it to me
01:29:00 <sjanssen> jml: with data "MkFoo undefined" is not undefined, but with newtype it is undefined
01:29:01 <jml> sjanssen: luckily, I am subtle and quick to hunger.
01:29:09 <Dynetrekk> Axman6: um, now what to do with it? the -j3 and so on? (not -O3?)
01:29:37 <sjanssen> jml: to simplify the example, lets use "data D = D String; newtype N = N String"
01:29:49 <jml> sure.
01:29:51 <sjanssen> N undefined `seq` () == undefined
01:29:59 <sjanssen> D undefined `seq` () == ()
01:29:59 <Axman6> Dynetrekk: http://trac.macports.org/wiki/howto/ParallelBuilding
01:30:08 <Dynetrekk> thanks
01:30:09 <sjanssen> case undefined of D _ -> () == undefined
01:30:10 <Jarvis> I would like to know when version 6.12 will be released?
01:30:19 <sjanssen> case undefined of N _ -> () == ()
01:30:27 <Jarvis> Anyone know?
01:30:42 <sjanssen> Jarvis: GHC 6.10 just came out, so 6.12 will be a while
01:30:42 <Axman6> Jarvis: when it's finished :)
01:30:49 <Dynetrekk> Axman6: it's okay to edit it while building?
01:30:58 <Axman6> Dynetrekk: i wouldn't
01:31:24 <sjanssen> jml: newtypes have no run-time representation -- they're like type synonyms in that respect
01:31:29 <Jarvis> I'm looking forward to the better code generator
01:31:42 <Dynetrekk> Axman6: okay. so, I add the use_parallel_builds yes line somewhere at "random" ?
01:31:48 <pjdelport> jml: intuitively, "data Foo" exists at run-time, while "newtype Foo" exists only at type-time
01:32:18 <Axman6> Dynetrekk: i think so. follow that page. i don't think you can tell it to use optimisation by default, but most things compile with -O2 anyway
01:32:37 <fasta> Jarvis: why?
01:32:39 <Dynetrekk> Axman6: okay, that's not bad, I'll just leave it at that, then. but it
01:32:43 <jml> ok. so what's the basis for choosing one over the other?
01:32:49 <Dynetrekk> s nice if it could work twice as fast :P (2 cores)
01:32:58 <Dynetrekk> thanks a lot for the hint!
01:33:05 <Axman6> Dynetrekk: make syre you add buildmakejobs       <number of CPU cores +1>
01:33:16 <sjanssen> jml: use newtype for single constructor, single component types -- use data for everything else
01:33:16 <Dynetrekk> Axman6: yeah, I got that one
01:33:20 <Jarvis> fasta: for my protein folding project
01:33:36 <fasta> Jarvis: on how many machines do you do that?
01:33:37 <Dynetrekk> Axman6: I have seen that one job doesn't really fill up one cpu always
01:33:48 <Dynetrekk> (one core if you want)
01:34:02 <Axman6> Dynetrekk: yeah n+1 is uaualy the best way to make sure it uses all cores
01:34:15 <jml> sjanssen: what's the rationale for that?
01:34:16 <Dynetrekk> Axman6: sounds reasonable
01:34:17 <Jarvis> fasta: about 20
01:34:29 <Dynetrekk> Axman6: but I guess you have to install several packages at once to make it happen
01:34:41 <Jarvis> fasta: it's for university
01:34:49 <fasta> Jarvis: oh, that's kind of cool. Are there any standard algorithms for that?
01:35:06 <sjanssen> jml: newtype can only be used as a single constructor with a single component, and since it has no run time overhead you should use it whenever possible
01:35:08 <Jarvis> fasta: not really it's just brute force
01:35:08 <Axman6> Dynetrekk: no, make knows how to do it, if you;re compiling somethign from source, and you use make -j3 say, it'll run three jobs at once, instead of one
01:35:31 <Dynetrekk> Axman6: okay... interesting.
01:35:44 <fasta> Jarvis: you need to define somehow how the different molecules and so interact, no?
01:35:53 <fasta> Jarvis: what piece of software does that?
01:36:10 <Jarvis> fasta: yes
01:36:19 <jml> sjanssen: ok thanks
01:36:29 <Jarvis> gtg
01:40:03 <Axman6> Dynetrekk: if you have any more macports questions, #macports is a better place to ask
01:40:30 <Dynetrekk> Axman6: thanks, I'll remember!
01:40:49 <Dynetrekk> Axman6: but short haskellian question: do you prefer installing via cabal vs macports?
01:40:58 <Dynetrekk> haskell packages I mean
01:41:15 <Axman6> cabal usually, it has everything on hackahe, macports only has the major packages
01:43:40 <Dynetrekk> Axman6: thanks!
01:46:50 <jml> how could I put this code more succinctly?
01:46:51 <jml> get = do payload <- get
01:46:51 <jml>          return (f payload)
01:47:51 <Axman6> get >>= return . f i think
01:48:02 <Axman6> "get >>= return . f" that is
01:48:15 <jml> thanks.
01:48:20 <sjanssen> jml: fmap f get
01:48:30 <Axman6> @undo do {x <- get; return (f x)}
01:48:31 <lambdabot> get >>= \ x -> return (f x)
01:48:46 <sjanssen> @. pl undo do x <- get; return (f x)
01:48:46 <Axman6> @pl get >>= \ x -> return (f x)
01:48:47 <lambdabot> f `fmap` get
01:48:47 <lambdabot> f `fmap` get
01:48:53 <Axman6> heh
01:49:27 <Axman6> sjanssen: ah, how handy. never knew about @. does it just work with two @x's?
01:49:41 <sjanssen> Axman6: you can do more, but I can't remember the syntax
01:49:55 <Axman6> @.
01:49:56 <lambdabot> Not enough arguments to @.
01:50:01 <Axman6> dang
01:50:03 <Axman6> @
01:50:08 <Axman6> @,
01:50:08 <lambdabot> Maybe you meant: . ? @ v
01:50:11 <sjanssen> @. elite @quote
01:50:11 <lambdabot> Plugin `compose' failed with: Unknown command: "@quote"
01:50:15 <sjanssen> @. elite quote
01:50:15 <lambdabot> MM0rRow sAYs: In l4N9$ wITh dEpeNd3nT tYpES, YOu (an Jus7 /\/\aP nUmb3rz0rz DIrEC+lY to typez0rz iNz734D oph hA\/ING 7o RId3 4 unICycLE aloN9 4 TigHTROp3 while Ba++1In9 An UNrUlY 9Ang 0ph /\/\OnkeY
01:50:15 <lambdabot> wI7H xNIvE$
01:50:51 <Axman6> ha
01:52:30 <jml> haskell seems like a very succinct language
01:52:35 <pjdelport> haha, typez0rz
01:53:03 <Axman6> jml: yup, it can be
01:53:38 * pjdelport points at the above example as another argument for teaching Functor first
01:53:56 <pjdelport> (before Monad)
01:54:11 * Axman6 &
01:54:29 <jml> pjdelport: interesting.
01:54:55 <jml> my current learning strategy is to get myself as confused as possible as quickly as possible and then sit down and make sense of it all.
01:55:13 <pjdelport> i stayed confused about monads for a long time
01:55:32 <jml> this sounds not unusual.
01:55:32 <pjdelport> until i got functors
01:55:38 <pjdelport> and then monads were pretty obvious
01:55:59 <pjdelport> functors lay exactly the right foundation IMHO
01:56:24 <pjdelport> monads are just a warm fuzzy flavor of them
01:57:05 <pjdelport> applicative functors, too
01:57:50 <pjdelport> learning should go Functor -> Applicative -> Monad
01:57:55 <pjdelport> since each includes the previous
02:00:32 <paolino> @src Functor
02:00:33 <lambdabot> class  Functor f  where
02:00:33 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
02:02:24 <paolino> @src Applicative
02:02:25 <lambdabot> class Functor f => Applicative f where
02:02:25 <lambdabot>     pure  :: a -> f a
02:02:25 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
02:02:59 <pjdelport> @scr Monad
02:03:00 <lambdabot> Maybe you meant: arr rc src
02:03:05 <pjdelport> bluh
02:03:09 <pjdelport> @src Monad
02:03:09 <lambdabot> class  Monad m  where
02:03:10 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
02:03:10 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
02:03:10 <lambdabot>     return      :: a -> m a
02:03:10 <lambdabot>     fail        :: String -> m a
02:03:34 <pjdelport> fmap == pure == return
02:03:54 <pjdelport> <*> == `ap`
02:04:12 <pjdelport> (and fail is just madness)
02:05:03 <pjdelport> ack, i mean fmap == (<$>) == liftM
02:05:04 <pjdelport> of course
02:05:37 * pjdelport is too tired for this :P
02:05:38 <paolino> that is more sane
02:09:27 <paolino> @src (<$>)
02:09:28 <lambdabot> f <$> a = fmap f a
02:11:31 <Kerris7> is HIDE (Haskell IDE) still active?
02:12:20 <dolio> Can't say I've heard about it in a while.
02:16:06 <nanothief> The code Right 3 >> Right 4 fails, saying that there is no instance for Monad (Either a). Is there a definition in the standard libs somewhere, or will I have to define my own?
02:16:24 <dolio> It's in Control.Monad.Error.
02:16:50 <nanothief> dolio: thanks!
02:28:07 <solrize_> >:k
02:28:11 <solrize_> > :k
02:28:13 <lambdabot>   <no location info>: parse error on input `:'
02:30:35 <Dynetrekk> Axman6: done compiling :) 6 hours my ass...
02:35:25 <quicksilver> RWH dispatched! :)
02:42:25 <mapreduce> Is the online version available as a single-file download?
02:44:51 <quicksilver> no.
02:44:59 <quicksilver> twb wrote a script to PDF it up though
02:49:59 <Kerris7_> what's the most promising Haskell IDE at the moment?
02:50:35 <Lemmih> Kerris7_: HIDE isn't active anymore.
02:51:09 <Kerris7_> We're a bunch of kids in a Java school starting up a Haskell study group, the best we've found so far is Kent University's HEAT
02:52:21 <pejo> quicksilver, if they wanted PDF's of it out I think they would have made one available though.
02:52:40 <quicksilver> pejo: yes, they could have made that choice and they didn't.
02:53:01 <quicksilver> pejo: I don't know whether it was because it was work, and they didn't feel like doing the work, or if it was a deliberate decision not to make available.
02:53:48 <quicksilver> pejo: however, the CC license permits other people to make PDFs if they want.
02:53:56 <quicksilver> And I haven't seen a request not to do so.
02:54:12 <pejo> Oh, RWH is under a CC license?
02:54:16 <quicksilver> Yupp
02:54:29 <quicksilver> "Copyright 2007, 2008 Bryan O'Sullivan, Don Stewart, and John Goerzen. This work is licensed under a Creative Commons Attribution-Noncommercial 3.0 License"
02:56:31 <mapreduce> quicksilver: Thanks.
02:58:08 <quicksilver> Kerris7_: emacs
02:58:27 <quicksilver> there are no good haskell IDEs, depending how you define 'IDE'.
02:58:47 <quicksilver> Yi is making interesting progress towards becoming a good editor, but it has some way to go.
03:05:01 <vixey> @seen tristes_tigres
03:05:01 <lambdabot> I saw tristes_tigres leaving #haskell 2m 1d 12h 44m 22s ago, and .
03:05:23 <vixey> preflex seen tristes_tigres
03:05:23 <preflex>  tristes_tigres was last seen on #haskell 11 hours, 10 minutes and 47 seconds ago, saying: tsomething from MonadFix ?
03:13:39 <vixey> preflex tell tristes_tigres http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=562#a562
03:13:40 <preflex>  Consider it noted.
03:18:41 <jml> so, I just wrote this: http://hpaste.org/12999
03:19:08 <jml> It seems like something that someone else should have already written for me.
03:27:07 <vixey> I guess that continuation passing and mutual recursion is equivalent to having a stack and a transition table
03:27:39 <vixey> the question is which one is simpler
03:32:00 <daf> jml: you could do something like: sequence (repeat action) >>= \xs -> return $ takeWhile predicate xs
03:32:16 <vixey> daf I kind of doubt that's going to work
03:32:47 <daf> oh, sequence isn't what I want
03:33:08 <mmorrow> vixey: are you sure that a single stack + a (finite?) transition table is as powerful as (arbitrary) mutual recursion and continuation passing?
03:33:49 <mmorrow> dolio showed that this is general recursion:  mutual f g a = f a (\b -> g b (\a -> mutual f g a))
03:34:16 <mmorrow> (i might not be barking up the right tree here :)
03:35:07 <vixey> not sure
03:35:18 <mmorrow> me neither
03:35:41 <vixey> I think that it's not
03:35:47 <daf> jml: so yes, it does seem like something that should already exist, and I don't see a simpler way of writing it
03:35:54 <mmorrow> vixey: i've been working on neutron. it's going to _crush_ ;)
03:36:40 <vixey> oh cool neutron in great
03:36:44 <vixey> is
03:36:46 <quicksilver> jml: it gets written from time to time
03:36:54 <quicksilver> jml: there are a couple of choices in how to write it
03:37:05 <quicksilver> jml: I suspect that's partly why there isn't a canoncial standard one.
03:37:16 <jml> quicksilver: what sort of choices?
03:37:23 <quicksilver> jml: whetehr the 'predicate' is also monadic
03:37:49 * jml nods
03:37:56 <quicksilver> whether when the predicate fails you return the current value, or stop
03:37:57 <jml> doUntilM? :P
03:38:10 <quicksilver> I've seen them called whileM and untilM, yes
03:38:11 <mmorrow> i'm making it (useable for) real, and trying to put a nice interface on it while keep it nice and compact
03:38:30 <quicksilver> jml: there is also the choice of whether you pass the value to the predicate at all
03:38:35 <mmorrow> i should have it fully working in a few days tops :)
03:38:36 <quicksilver> if it's a monadic predicate you don't need to.
03:38:42 <jml> right, that makes sense
03:39:27 <quicksilver> so, at least "(a -> Bool) -> m a -> m [a]" "(a -> m Bool) -> m a -> m [a]" and "m Bool -> m a -> m [a]" are options
03:39:35 <quicksilver> (multiply by two for the while/until difference)
03:41:07 <Beelsebob> I did something similar to this -- there's satisfiesM in checkers
03:41:16 <Beelsebob> it's (a -> Bool) -> m a -> m a
03:41:31 <Beelsebob> (repeatedly run the monad until it satisfies the condition, and give back the final result)
03:42:05 <lilac> mmorrow: a single stack plus a finite transition table sounds like a turing machine to me :)
03:42:16 <vixey> oh I thought it was a PDA
03:43:08 <quicksilver> another possibility has (a -> m a) in the middle
03:43:15 <quicksilver> if you want to access the last loops value.
03:43:21 <vixey> "Parsing arbitrary infix expressions, respecting the rules of operator precedence and parenthesizing is far from being simple"
03:43:48 <jml> quicksilver: the implementation I have has the last loop's value.
03:43:49 <quicksilver> jml: so, it's a sensible thing to want, but it's not obvious what the most convenient/general combinators are.
03:43:53 <Beelsebob> quicksilver: yeh, my variant couldn't have each loop affect the next itteration
03:44:11 <jml> quicksilver: ok. that's ultimately reassuring.
03:44:32 <quicksilver> so monads let you store the a anyway, of course
03:44:34 <quicksilver> but others don't.
03:44:54 <quicksilver> "a -> m a" is just "n ()"
03:44:56 <Beelsebob> yeh, the particular one mine was designed for was random
03:44:58 <quicksilver> where n = StateT a m
03:45:37 <vixey> maybe I need to parenthesise as stage 1 and _then_ deal with infix operators
03:46:36 <quicksilver> there are some of these lightweight monads in our standard lib
03:46:40 <quicksilver> :t mapAccumR
03:46:41 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
03:46:51 <quicksilver> that is "secretly" just mapM in State acc
03:46:58 <quicksilver> :t foldM
03:46:59 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
03:47:17 <Beelsebob> quicksilver: btw, I discovered that my roots function needs access to the internals of a behavior to get any sort of sensible semantics
03:47:34 <quicksilver> that one is secretly mapM_ in StateT a m
03:47:49 <Beelsebob> because ofc, the linear approx assumes a continuous function, which the `Stepper`s in the Reactive are not
03:47:55 <quicksilver> Beelsebob: that's a shame but I'm not entirely suprised.
03:48:02 <Beelsebob> so it needs to break on both the event, and the internal reactive
03:48:17 <quicksilver> Beelsebob: on the other hand, isn't it Ok to assume continuity and say it's the user's fault if their function is discontinuous?
03:48:22 <quicksilver> that's certainly OK for some cases :)
03:48:42 <quicksilver> after all the FunTime can be discontinuous too
03:48:49 <quicksilver> and there is nothing you can do about that, at all.
03:48:52 <Beelsebob> quicksilver: yeh -- but it would be much nicer if you say "it's the users fault if any of the steps in the behavior are discontinuous"
03:50:20 <quicksilver> Beelsebob: of course, a newtype for continuous behaviours would be nice
03:50:27 <quicksilver> Beelsebob: with some safe combinators for building them.
03:50:30 <Beelsebob> true true
03:50:50 <quicksilver> with a newtype for a restricted class of behaviours you can do much cleverer stuff
03:50:54 <quicksilver> automatic differentiaion
03:50:59 <quicksilver> interval arithmetic to find roots
03:51:04 <lilac> piecewise linear behaviours might be useful for various things
03:51:11 <quicksilver> definitely.
03:51:15 <Beelsebob> yeh, that would indeed be very nice
03:51:23 <quicksilver> I defined 'switcherFold' (my name) to make it easier to make piecewise behaviours
03:51:42 <jml> is there a fast linter for haskell?
03:51:42 <Beelsebob> hmm? I tend to use accumB for that
03:51:44 <quicksilver> switcherFold :: Behaviour a -> Event (a -> Behaviour a) -> Behaviour a
03:52:09 <quicksilver> in this use case you have a bunch of behaviours but they are all 'waiting for' initial values
03:52:22 <quicksilver> switcherFold passes in as the 'a' parameter the final value of the last phase
03:52:27 <quicksilver> so they magically knit.
03:56:59 <mmorrow> lilac: oh sweet :)
03:57:12 * mmorrow needs to read up on this whole turing machine business ;)
03:57:55 <mmorrow> oh wait, so is that a yes or no?
03:58:07 <mmorrow> yeah, i thought it was a PDA as well
03:58:19 * mmorrow is reading scrollback
03:59:04 <jml> can you run ghc non-interactively on a .hs file that doesn't have a main?
03:59:58 <vixey> up ('o':xs) k = k O xs
03:59:58 <pejo> jml, ghc -c Foo.hs?
03:59:58 <vixey> up ('(':xs) k = up xs $ \left ('+':xs) -> up xs $ \right (')':xs) -> k (Add left right) xs
04:00:07 <vixey> down O xs = 'o':xs
04:00:08 <vixey> down (Add p q) xs = '(':down p ('+':down q (')':xs))
04:00:23 <jml> pejo: I always get "The function `main' is not defined in module `Main'"
04:00:52 <ToRA|MSR> jml: does your .hs file have a module Blah .. declaration at the top?
04:01:07 <jml> ToRA|MSR: no -- I guess it should?
04:01:26 <ToRA|MSR> maybe, -no-hs-main may also be helpful
04:02:11 <vixey> does anyone see that?
04:02:23 <vixey> look how similar they are
04:03:37 <vixey> :t In (Left (In (Right ()), In (Right ()))))
04:03:38 <lambdabot> parse error on input `)'
04:03:41 <vixey> :t In (Left (In (Right ()), In (Right ())))
04:03:42 <lambdabot>     Couldn't match expected type `Mu (Either a)'
04:03:42 <lambdabot>            against inferred type `()'
04:03:42 <lambdabot>       Expected type: Either a (Mu (Either a))
04:04:17 <vixey> how do I getbinary trees
04:04:26 <vixey> oh with Mu it wouldn't even have show
04:06:09 <vixey> I don't think the way 'up' works can be suitable for the case of multiple fixity levels
04:06:29 <vixey> but maybe I am overlooking something?
04:08:00 <mokus> vixey: you'd need a newtype to merge the 2 parameters of Either into 1 to be able to use Mu to 'fix' it
04:08:14 <vixey> mokus can't do thatin lambdabot
04:08:22 <mokus> I know
04:08:30 <mokus> you can on mine ;-)
04:08:38 <pejo> vixey, what are you trying to do?
04:08:40 <mokus> but she's not on this sirver
04:09:15 <vixey> cool!
04:09:35 <vixey> pejo, did you see the up and down functions
04:09:55 <mmorrow> vixey: ooh, i have show for Mu
04:10:04 <vixey> , fix (In . Just)
04:10:05 <lunabot>  Killed.
04:10:05 <mmorrow> , muT [0..3]
04:10:05 <lunabot>  Killed.
04:10:08 <vixey> lol
04:10:14 <mmorrow> oh, i'm relinking
04:10:17 <mmorrow> forgot
04:10:29 <mmorrow> linking takes sooooo long on lunabot's computer
04:10:49 <mmorrow> like, exhorbitantly long
04:10:55 <mmorrow> , muT [0..3]
04:10:59 <lunabot>  luna: Failed to load interface for `Language.Haskell.Meta.Vars':
04:11:02 <mmorrow> grr
04:11:04 <vixey> , fix (In . Just)
04:11:06 <lunabot>  luna: Failed to load interface for `Language.Haskell.Meta.Vars':
04:11:10 <pejo> vixey, yes.
04:11:11 * mmorrow undoes his breaking mod
04:11:21 <vixey> pejo, 2 things
04:11:41 <vixey> 1) I want to extend it to support various fixity levels and infixl and infixr
04:11:48 <vixey> 2) have it correct
04:11:55 <mmorrow> , muT [0..3]
04:12:07 <lunabot>  Mu (T (Mu (T (Mu (Tip 0)) (Mu (Tip 1)))) (Mu (T (Mu (Tip 2)) (Mu (Tip 3)))))
04:12:07 <vixey> demonstratably
04:12:47 <mmorrow> vixey: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=552
04:12:59 <vixey> , let up ('o':xs) k = k (Mu (Tip ())) xs; up ('(':xs) k = up xs $ \left ('+':xs) -> up xs $ \right (')':xs) -> k (Mu (T left right)) xs in up "(o+o)+o" const
04:13:05 <lunabot>  Mu (T (Mu (Tip ())) (Mu (Tip ())))
04:13:06 <mmorrow> heh, nice
04:13:14 <mmorrow> one step ahead of me i guess
04:13:44 <vixey> , let down (Mu (Tip ())) xs = 'o':xs; down (Mu (T p q)) xs = '(':down p ('+':down q (')':xs)) in down (Mu (T (Mu (Tip ())) (Mu (Tip ())))) ""
04:13:49 <lunabot>  "(o+o)"
04:13:53 <mmorrow> hehe
04:13:58 <vixey> oh
04:14:01 <vixey> yes I forget
04:14:19 <vixey> "(o+o)+o" didn't parse you have to write "((o+o)+o)"
04:14:20 <dolio> , [$ty| cata |]
04:14:26 <lunabot>  luna: Exception when trying to run compile-time code:
04:14:29 <pejo> vixey, so some kind of generic programming?
04:14:41 <vixey> no
04:14:45 <vixey> just parsing infix operators
04:15:13 <mmorrow> dolio: hmm
04:15:16 <mmorrow> , cata
04:15:18 <lunabot>  luna: Ambiguous occurrence `cata'
04:15:21 <mmorrow> grr
04:15:43 <mmorrow> Control.Morphism.cata
04:15:49 <mmorrow> (is getting the chop)
04:16:15 <mmorrow> , ana
04:16:17 <lunabot>  luna: Ambiguous occurrence `ana'
04:16:23 <dolio> What's it getting confused with?
04:17:40 <vixey> do you think that like
04:17:49 <vixey> "((o+o)+o)" <-- in this
04:18:00 <vixey> each character you go along you can make up one fragment of a zipper
04:18:25 <vixey> I don't think that works really
04:19:57 <mokus> anyone know offhand what adjunction gives the [] monad?
04:20:08 <mmorrow> dolio: Control.Morphism.{Ana,Cata}
04:20:18 <mmorrow> just fixed..
04:20:28 <mmorrow> , [$ty| cata |]
04:20:35 <lunabot>  Killed.
04:20:40 <mmorrow> , [$ty| cata |]
04:20:46 <lunabot>  forall a b . Functor b => ((b a) -> a) -> (Mu b) -> a
04:20:51 <mmorrow> , [$tyQ| cata |]
04:20:58 <lunabot>  ForallT [a,b] [AppT (ConT Functor) (VarT b)] (AppT (AppT ArrowT (AppT (Ap...
04:22:22 <mmorrow> dolio: i've got to figure out how to catch those "Exception when trying to run compile-time code:", or at least get the informative part of the error to be spit out on the first line
04:22:38 <mokus> mmorrow: is lunabot a lamdbabot or something new?
04:22:52 <mmorrow> there's so many levels of calling back and forth into ghc i'm starting to lose track what's happening where
04:23:31 <mmorrow> mokus: it's a bot-shell on some code that makes use of the ghc-api
04:23:43 <mokus> cool
04:23:56 <mmorrow> mokus: i have a darcs repo at http://moonpatio.com/repos/luna/
04:24:23 <mokus> ah, thanks - I'll probably take a look at it this evening
04:24:44 <tyfon> hi guys.. i've been programming for 20ish years in procedural/oo languages... any pointers for me where to start? ;)
04:24:55 <mmorrow> disclaimers: it only works with 6.10.1 exactly, and you need haskell-src-exts <= 0.3.8 (although haskell-src-exts depenendent part isn't really essential to the package)
04:24:59 <tyfon> this seems to be a very diffrent beast indeed
04:25:07 <mokus> mmorrow: ok, good to know
04:25:34 <ToRA|MSR> tyfon: probably real world haskell
04:25:36 <mmorrow> mokus: let me know if you have any problems building it or whatnot :)
04:25:50 <mokus> mmorrow: will do, thanks
04:26:00 <mmorrow> np
04:26:11 <pejo> tyfon, Graham Hutton's book is supposed to be good for beginners. You shouldn't have a problem with "Real World Haskell" either (it's available online).
04:26:23 <tyfon> oh nice =)
04:26:27 <Spark> amazon recommended real world haskell to me
04:26:28 <tyfon> i'll check it out
04:26:44 <Spark> that and some goth poetry
04:27:04 <tyfon> lol
04:27:30 <tyfon> i've done some ((((lisp)))) .. but just very basic hacks on emacs extentions
04:27:36 <quicksilver> Spark: you should probably read both together
04:27:52 <quicksilver> Spark: for true enlightenment
04:29:40 <dolio> I've had Amazon recommend me tampons before.
04:30:14 <dolio> Evidently they know something I don't.
04:31:17 <ziman> Big Brother's watching you.
04:31:50 <dolio> Also a book on how to pick up Asian women.
04:32:06 <Spark> maybe male haskell programmers frequently buy tampons from amazon
04:32:16 <dolio> And, as I recall, a book for Asian men on how to pick up White women.
04:32:31 <Spark> i think someone at amazon has a sense of humour
04:32:35 <Spark> and has probably been fired as a result
04:33:10 <mmorrow> , ppDoc `fmap` foldT [|0|] (\a b -> [|($a,$b)|]) (muT . fmap lift $ [0..7::Int]) id
04:33:15 <lunabot>  (((0, 1), (2, 3)), ((4, 5), (6, 7)))
04:33:35 <tyfon> heh does the bot speak haskell? :)
04:33:43 <tyfon> you're scaring med with that syntax lol
04:33:48 <mmorrow> heh
04:34:04 <tyfon> well hmm
04:34:45 <mmorrow> , [|\x -> x|]
04:34:48 <lunabot>  LamE [VarP x_0] (VarE x_0)
04:35:01 <mmorrow> it's template-haskell syntax
04:35:07 <ziman> > reverse $ map succ " mnexs\USnkkdG"
04:35:09 <lambdabot>   "Hello tyfon!"
04:35:15 <tyfon> lol
04:35:16 <solrize_> > let 8=9 in 8
04:35:18 <lambdabot>   8
04:35:30 <tyfon> well i got to learn this ;)
04:35:32 <tyfon> ordered the book
04:35:46 <tyfon> ghc is the best tool right?
04:35:53 <pejo> tyfon, don't worry about template haskell for now - that's definitely a part of the advanced stuff that you can save for later.
04:35:53 <mmorrow> definitely
04:36:41 <tyfon> pejo: looks like magic atm anyway :)
04:36:54 <mmorrow> at least now you can identify it :)
04:36:58 <tyfon> yep
04:37:14 * byorgey waves good morning
04:38:05 <byorgey> welcome, tyfon
04:38:28 <tyfon> thanks :)
04:38:42 <byorgey> tyfon: just out of curiosity, how did you hear about Haskell, or how did you decide you needed to learn it?
04:39:18 <tyfon> slashdot actually
04:39:21 <tyfon> :o
04:39:30 <tyfon> there was a big article about functional programming there the other day
04:39:39 <mokus> uh oh, are we in for a big rush here? ;-)
04:39:57 * vixey hopes so
04:39:58 <tyfon> also i am fed up with managing threads
04:40:16 <tyfon> :p
04:40:40 <mmorrow> nice, i thought that article's tone on haskell would've discouraged people from getting into haskell
04:41:18 <tyfon> mmorrow: some people like challenges
04:41:24 <mmorrow> tyfon: :)
04:41:41 <tyfon> http://tech.slashdot.org/article.pl?sid=08/12/05/2346235
04:42:24 <tyfon> It's an exaggeration but a useful one: When you move to FP, all your algorithms break.'
04:43:14 <mokus> I have found in my fairly limited experience that it's usually easier to teach FP to a person with no programming experience than a person with a moderate amount ;-)
04:44:08 <mmorrow> "all your algorithms break"... i'd say that's true in the sense that you have to write them a completely different way (usually)
04:44:15 <byorgey> tyfon: heh, it's not *algorithms* that break, it's your brain (temporarily)
04:44:19 <byorgey> =)
04:44:19 <tyfon> lol
04:44:42 <mmorrow> but "different" there doesn't mean "worse" (or better, but somtimes it can be either)
04:44:56 <pejo> tyfon, learning fp will give you more tools for solving the problems you bump into every day, so it's a really nice thing to do.
04:45:04 <tyfon> well after getting pumped on functinal programming i researched diffrent languages.. and haskell seemed to be the most pure FP language
04:45:07 <mokus> mmorrow: for me it was also true in the sense that when I went back to the OO languages it took a *long* time to quit trying to write haskell in them
04:45:40 <tyfon> haha
04:45:50 <mmorrow> mokus: yeah, totally. it's like your brain gets completely rewired.
04:47:12 <quicksilver> mokus: why did you try to quit trying to write haskell in them?
04:47:19 <mmorrow> heh
04:47:25 <quicksilver> within reason, the lessons you learn in haskell are applicable to all languages.
04:47:59 <osfameron> but not necessarily vice versa
04:48:46 <quicksilver> I learnt a lesson from PHP which was perfectly applicable to Haskell.
04:48:53 <quicksilver> I've followed it religiously ever since.
04:48:55 <mokus> quicksilver: I didn't completely, but I cut out the stuff that other people would never be able to read ;-)
04:49:06 <mokus> like building folds in C#
04:49:07 <mokus> ;-)
04:49:59 <osfameron> quicksilver: what lesson?  (The only think I ever learnt from PHP was to avoid programming in PHP...)
04:50:15 <quicksilver> osfameron: Coincidence. That was the exact same lesson I learnt!
04:50:24 <dolio> Hah.
04:50:25 <mokus> hey, me too!
04:50:52 <osfameron> ;-)
04:51:39 <mapreduce> I learned that writing incredibly small web apps doesn't have to be hard.
04:51:42 <maltem> Heh, today study collegues had trouble understanding recursion on lists (Java lecture), so I showed them what lists look like in Haskell, and they said, now that's much clearer.
04:51:51 <tyfon> i wrote exactly one application in PHP then ran away screaming
04:52:09 <mapreduce> I also learned that PHP was unreadable and ran away $creaming.
04:52:39 <tyfon> i've seen a few php apps with ok readability.. but they were 100% OO
04:53:53 <mapreduce> That's awful.
05:13:13 * BeelsebobWork ponders if lilac or quicksilver or Peaker or wchogg are about to discuss recursive integral -- I think I've discovered the bug
05:15:49 <quicksilver> Beelsebob: in a kind of halfway-here sense
05:16:18 <BeelsebobWork> I'll try and explain what I think the bug is, and see if it resonates with you
05:16:57 <BeelsebobWork> so, my understanding of what should be happening is that we should produce a Reactive (inside the behavior) that changes value, every time our "timer" event ticks
05:17:15 <BeelsebobWork> and that when we sample that Reactive on the tick time, we should get back the value from before the tick
05:17:42 <BeelsebobWork> the problem is -- we don't know what *that* value is
05:18:02 <BeelsebobWork> because while we know that there is a step in the reactive at the time point of the Event occurance
05:18:10 <BeelsebobWork> we don't know yet that there aren't any steps before that time point
05:18:50 * BeelsebobWork hopes that makes sense
05:19:42 <quicksilver> yes.
05:20:00 <quicksilver> that resonates.
05:20:12 <quicksilver> the need to communicate 'non-occurrences' is part of this
05:20:13 <vixey> you can't left factor this kind of grammar
05:20:15 <BeelsebobWork> so, what I don't see yet is how to convince reactive that the time of the event really *is* the next step in the reactive value
05:20:26 <BeelsebobWork> yeh
05:21:01 <quicksilver> separate the calculation of occurrences from values
05:21:05 <quicksilver> (is another way to look at it)
05:21:15 <BeelsebobWork> hmm, *thinks*
05:21:18 <quicksilver> because the timing of these occurrences is not dependent on the values they take
05:21:23 <quicksilver> you can work out the timings "first"
05:21:23 <BeelsebobWork> yep
05:21:30 <BeelsebobWork> hmm, that's true
05:21:37 <quicksilver> then work out the values when the timings are set in stone.
05:21:51 <BeelsebobWork> I might go through looking at why the occurance time can't be lazily computed
05:22:08 <quicksilver> in otherwords, "snapshot _|_ e" should produce an event with all the times of e
05:22:08 <quicksilver> but _|_ values
05:22:17 <quicksilver> [(t0,_|_),(t1,_|_),...]
05:22:22 <quicksilver> rather than simply _|_
05:22:23 <BeelsebobWork> yep
05:22:32 <BeelsebobWork> that makes sense to me
05:22:41 <BeelsebobWork> wait no
05:22:50 <BeelsebobWork> yes, no, maybe
05:22:55 <quicksilver> (if snapshot _|_ e = _|_, then r = snapshot r e can never work, because _|_ is the l.f.p)
05:23:03 <BeelsebobWork> yeh, that makes sense to me
05:23:12 <quicksilver> and these recursive examples ultimately reduce to r = snapshot r e
05:23:18 <BeelsebobWork> cool, and that should produce a test too :)
05:23:19 <quicksilver> although there is normally some fmaps around too :)
05:23:25 <quicksilver> otherwise it's rather boring.
05:35:03 <vixey> @src MonadPlus
05:35:04 <lambdabot> Source not found.
05:35:07 <vixey> @src MonadFix
05:35:07 <lambdabot> class (Monad m) => MonadFix m where
05:35:07 <lambdabot>     mfix :: (a -> m a) -> m a
05:35:25 <vixey> I think I can define then MonadFix Computation
05:37:17 <quicksilver> most monads turn out to have monadfix instances.
05:37:30 <quicksilver> I can't entirely get my head around "why" that should be.
05:37:40 <vixey> @instances MonadFix
05:37:40 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
05:38:00 <vixey> > mfix Just
05:38:01 <lambdabot>   Just * Exception: stack overflow
05:38:16 <vixey> > mfix (:[])
05:38:17 <lambdabot>   [* Exception: stack overflow
05:38:21 <vixey> this is good :P
05:38:30 <vixey> > mfix (const)
05:38:31 <lambdabot>       Overlapping instances for Show (b -> a)
05:38:31 <lambdabot>        arising from a use of `s...
05:38:42 <vixey> > mfix (const) ()
05:38:43 <lambdabot>   * Exception: stack overflow
05:39:02 <vixey> mfix f = f (error "stack overflow")
05:39:43 <saml> data A = A !Int !Char     what's ! ?
05:39:50 <quicksilver> saml: strictness
05:39:51 <saml> is it strict evaluation thingy?
05:39:59 <Axman6> > let mfix = flip f (error "Stack overflow") in mfix const ()
05:40:00 <lambdabot>       Overlapping instances for Show (a -> b -> a)
05:40:00 <lambdabot>        arising from a use ...
05:40:03 <quicksilver> marks those fields as always strict
05:40:03 <saml> ah thanks quicksilver
05:40:19 <quicksilver> so "A i c" is equivalent to "i `seq` c `seq` A i c"
05:41:20 <saml> oh cools
05:41:42 <Axman6> can be quite useful
05:41:59 <Axman6> but i've learned it can do nasty things if used incorrectly
05:42:14 <Axman6> mainly huge memory usage (2+GB
05:43:02 <blueonyx> hi
05:43:24 <vixey> hi
05:45:49 <BeelsebobWork> IT WORKS!
05:45:58 <blueonyx> may i ask a pandoc question: what should ~~~ {.haskell .numberLines} \n ... \n ~~~ do when not create numbered lines?
05:46:19 <BeelsebobWork> quicksilver: http://hpaste.org/13005
05:46:30 <BeelsebobWork> also, my boss says he owes you a pint and a blow job if you want
05:46:38 <blueonyx> it just creates pre and code tags and the class numberLines, but no line numbers :/
05:47:27 * quicksilver laughs.
05:47:35 <quicksilver> Now *that's* not something you hear too often.
05:47:38 <BeelsebobWork> where abouts are you from quicksilver?
05:47:44 <BeelsebobWork> he's serious about the pint at least
05:49:08 <quicksilver> is "snap" defined in mutual recursion with that?
05:49:27 <quicksilver> or alternatively, have you made the same change to snap? :)
05:49:32 <BeelsebobWork> no, but snap genuinely is supposed to produce results when the reactive changes
05:49:42 <BeelsebobWork> so it can't produce it's times until it sees the reactive
05:50:03 <quicksilver> ah right.
05:50:15 <quicksilver> I don't have 'snap' in my formulation at all, I misunderstood.
05:50:32 <quicksilver> I work in London, to answer your earlier question.
05:51:07 <quicksilver> this certainly an advantage of the explicit time-tuple formulation over mine
05:51:07 <BeelsebobWork> he says he may be around there soon, so look out for pint buying dutch men
05:51:09 * quicksilver ponders
05:53:17 <maltem> blueonyx: the manual references optional hightlighting, maybe the line numbering is (which would still be badly surprising) with the hightlighting code?
05:53:24 <maltem> highlighting, even
05:56:45 <maltem> yeah, a google search for "pandoc highlighting" finds Text.Pandoc.Highlighting
05:56:54 <lilac> BeelsebobWork: that looks suspiciously like a fully-working snapshotWith :)
05:56:59 <maltem> er, "pandoc numberlines" I mean
05:57:46 <blueonyx> okay i try compiling it with highl*
05:58:26 <BeelsebobWork> lilac: :D
05:58:27 <lilac> BeelsebobWork: except i don't see how it avoids the space leak
05:58:37 <blueonyx> maltem: oh yea http://johnmacfarlane.net/highlighting-kate/ shows which languages got 'lines' :D
05:58:40 <saml> blueonyx, using latest version of pandoc?
05:59:10 <blueonyx> 1.1
05:59:34 <lilac> BeelsebobWork: suppose the event never happens, but the time of it is never fully-known (let's say it's a keypress event which never occurs)
05:59:40 <saml> oh i was using 0.4
05:59:48 <lilac> BeelsebobWork: then v' never gets forced and the contents of the Behaviour never get GC'd
05:59:57 <BeelsebobWork> >.<
06:00:09 <BeelsebobWork> arses indeed
06:01:07 <maltem> blueonyx: oh, I strongly hope these "yes/no" in the "lines" column relate only to the linked examples?
06:01:24 <BeelsebobWork> right okay, now I see why people were able to solve it, but introduce a space leak at the same time
06:02:24 <BeelsebobWork> lilac: is that though a space leak that can be fixed?
06:02:24 <lilac> BeelsebobWork: FWIW, i think taht solution is the same as this one: http://hpaste.org/12528#a4
06:02:45 <BeelsebobWork> ah, cool
06:02:50 <BeelsebobWork> I hadn't realised you'd looked at it
06:02:51 <quicksilver> did BeelsebobWork really introduce that space leak?
06:02:57 <quicksilver> I thought the space leak was always there.
06:03:00 <BeelsebobWork> quicksilver: yeh -- that's what Im' wondering
06:03:05 <BeelsebobWork> surely that space leak *has* to be there
06:03:18 <quicksilver> I think that space leak is present in almost all the implementations of snapshot you make.
06:03:22 <quicksilver> it's certainly present in mine.
06:03:39 <camio> In the old version, computing the new events required going through the old ones in the mappend due to joinMaybes so the space leak was eliminated.
06:03:43 <lilac> BeelsebobWork: some thoughts here: http://trac.haskell.org/reactive/ticket/14
06:04:13 <lilac> BeelsebobWork: the space leak isn't necessary. if you force the value of the result to get improved when the time of the result is, you can avoid it
06:04:17 <lilac> but it's hard to formulate that
06:04:39 <BeelsebobWork> hmm *ponders that*
06:04:52 <BeelsebobWork> yeh, that makes sense
06:05:07 <lilac> check out the snapshotWith in this: http://trac.haskell.org/reactive/attachment/ticket/14/reactive-snapshot-patches.bundle
06:05:13 <quicksilver> as with all space leaks there is also an interaction with how the values are demanded.
06:05:27 <quicksilver> ...which is actually done by your IO scaffold.
06:05:42 <camio> I wonder if it can be done with some trickery like in splitB (http://netsuperbrain.com/blog/posts/why-is-the-reactive-behavior-tutorial-taking-so-long-splitb/)
06:05:46 <quicksilver> Since my IO scaffold is very different from conal's I blame my version of this leak on slightly different code.
06:06:28 <BeelsebobWork> camio: I'm not sure it can be -- when would you split the event?
06:06:30 <BeelsebobWork> i.e. on what event
06:07:02 <camio> I'm not saying use splitB, but the trick used in the final formulation might work here.
06:07:20 <blueonyx> where does 'cabal install ' install packages to?
06:07:25 <camio> It's a wild guess though.
06:08:01 <BeelsebobWork> lilac: I take it that one is trying to do the improving value thing? I'm not certain I can see how it goes together in the patch
06:08:02 <fasta> There was some post which explained how easy it was to use the FFI in Haskel. I am only interested in the URL, not the contents. Does anyone know it?
06:08:10 <fasta> Haskell*
06:08:15 <BeelsebobWork> don't suppose you have a copy of PrimReactive with the patch applied?
06:09:15 <ksf> blueonyx, by default into .cabal, you can change it in your .cabal/config.
06:09:28 <pejo> fasta, it's probably the online chapter from RWH you're thinking of?
06:09:38 <lilac> BeelsebobWork: skipToR t r produces (t, <reactive from r containing time t>)
06:09:44 <fasta> pejo: no, I think dons posted it on his blog once.
06:09:46 <blueonyx> ksf: ah thanks
06:09:55 <lilac> but the 't' is incrementally computed as the max of all the times in r before t and t
06:10:12 <lilac> so that improving the times of the r causes r to be walked
06:10:19 <BeelsebobWork> that makes sense
06:10:35 <BeelsebobWork> so is there a problem with this fix then?
06:10:51 <BeelsebobWork> (i.e. is there a reason that conal hasn't rolled it in)
06:11:12 <lilac> however, you also need t `max` t' at the top-level (in snapshotWith) otherwise if the event hits MaxBound the time never becomes complete
06:11:23 <BeelsebobWork> yep
06:11:38 <lilac> conal's Ord (Bounded a) instance wasn't lazy enough
06:11:51 <lilac> i added laziness, but it caused weirdness in fieldtrip
06:12:03 <BeelsebobWork> ah :/
06:12:49 <lilac> also, it's not completely clear that it fixes the space leak
06:13:04 <lilac> i put together a test harness, and there was a leak both before and afterwards
06:13:14 <BeelsebobWork> hmm, okay
06:13:17 <lilac> although the leaks did look a ilttle different, so it's possible there's another leak
06:13:37 <lilac> i wonder whether i need more strictness in skipToR
06:13:59 <BeelsebobWork> well, there's the known leak with unused UI events
06:14:05 <lilac> it might be accumulating a large thunk for the r' values
06:14:17 <BeelsebobWork> hmm, that's also plausable
06:15:03 <lilac> FWIW, i've been working on an alternative (ugly) implementation which should eliminate the leaks
06:15:10 <BeelsebobWork> hmm okay
06:15:12 <lilac> but it really is ugly
06:15:18 <BeelsebobWork> I may spend part of the weekend staring at this
06:15:20 <lilac> unsafePerformIO left right and center :)
06:15:25 <BeelsebobWork> although my wife may beat me up for that
06:15:31 <BeelsebobWork> I have no problem with that :P
06:15:45 <BeelsebobWork> (I'm a verifyItsSafeYourselfIO lover)
06:15:47 <camio> lilac: Do you spawn another thread to pull the behavior steps?
06:15:47 <daf> the unsafePerformIO or your wife beating you up?
06:16:10 <BeelsebobWork> daf: either of them come to think of it >.>
06:16:31 <daf> heh
06:17:10 <BeelsebobWork> I think for the moment I'll stick to my current implementation -- it's exposing a different bug now
06:17:29 <BeelsebobWork> so I'll go hunting that one if lilac is hunting the snapshotWith one
06:18:48 <lilac> camio: no, but that's not a bad idea at all :)
06:21:22 <vixey> can anyone show me a infix parser?
06:21:36 <vixey> I mean without backtracking
06:21:50 <quicksilver> vixey: readsPrec?
06:21:57 <vixey> no
06:22:04 <BeelsebobWork> vixey: surely it's not possible without backtracking?
06:22:06 <vixey> I mean something I can read
06:22:15 <quicksilver> what's wrong with readsPrec?
06:22:21 <BeelsebobWork> there's no way to know if the value on the left is being applied or having something applied to it
06:22:26 <quicksilver> is it unreadable code?
06:23:20 <wjt> dons et al: you were talking about a gallery of "my RWH arrived!" images a while back; does it exist?
06:23:20 <lilac> vixey: do you want something with precedence levels and both left- and right-associative operators, or something simpler?
06:23:28 <vixey> lilac, yes
06:23:40 <vixey> that or simpler
06:23:54 <quicksilver> vixey: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Text-Read.html
06:32:09 <vixey> "If you were writing an interpreter, this output would be tokenized and written to a compiled file to be later interpreted"
06:32:16 <vixey> wikipedia is so dumb...
06:33:39 <Japsu> so fix it
06:33:43 <Riastradh> The blame for its dumbness lies in its users, vixey.
06:33:58 <vixey> you guys don't know how it works
06:34:23 <vixey> if you fix wikipedia someone is going to revert it
06:34:54 <blueonyx> what to pass to 'cabal install ..' to install globally?
06:35:06 <Riastradh> If you believe the situation to be so hopeless, why do you read it, vixey?
06:35:12 <Japsu> I sure as hell know how it works, I'm a moderator of the Finnish wikipedia ;)
06:35:28 <vixey> maybe it's better in Finnish wikipedia
06:36:16 <Japsu> yeah, as long as you don't participate in certain topics such as nuclear power, compulsory Swedish in comprehensive school etc. :)
06:37:17 <saml> blueonyx, maybe cabal help install ? i bet it's --user
06:37:53 <saml> ah globally. probably --global
06:38:29 <blueonyx> duh oversaw the help command
06:39:07 <vixey> does anyone have Shunting yard algorithm in haskell?
06:41:13 <Megzlna> Why would you actually need a case expression rather than regular pattern matching?
06:41:39 <quicksilver> when you don't feel like naming a new function
06:42:24 <Megzlna> why would you not want to name a new function
06:42:32 <quicksilver> case expr of pat -> ...  is equivalent to defining "f pat = ..." and then calling "f expr"
06:42:49 <quicksilver> because sometime you don't want to give a name to every single expression in your code
06:42:57 <quicksilver> sometimes you just want to write expressions.
06:43:29 <quicksilver> same reason you might prefer  z = 1 + 2 * (3 + 4) to x = 3+4;y = 2*x; z = 1+y;
06:43:29 <EvilTerran> vixey, have you looked at "shift-reduce parsers" in particular?
06:43:34 <vixey> no
06:44:22 <earthy> lalr!
06:44:26 <EvilTerran> they're the ones used by parser generators
06:44:38 <earthy> such as bison and antlr
06:44:43 <earthy> not all parser generators, mind you
06:46:34 <Megzlna> Quicksilver: Maybe you'd use 'case' because you introduced a bunch of where bindings
06:46:55 <Megzlna> and didnt want to redo that over and over
06:46:57 <Megzlna> ?
06:47:13 <blueonyx> maltem: pandoc with highlighting creates now linenumbers :/
06:49:00 <quicksilver> Megzlna: I normally use case on expressions
06:49:02 <quicksilver> like:
06:49:13 <quicksilver> f x = case (blah blah x blah x) of ....
06:49:22 <quicksilver> it would be, to my mind, pointlessly verbose to do
06:49:29 <quicksilver> f x = g y
06:49:33 <ksf> Megzlna, if you have e.g. a twenty-element ADT and want to pattern match of it, you don't want to write the function name 20 times, just once.
06:49:34 <quicksilver> f x = g (blah blah x blah x)
06:49:34 <quicksilver> rather
06:50:27 <Megzlna> so you're saying you combine multiple different uses of 'case' in a single func ?
06:50:36 <ksf> cabal should differentiate between normal and profiling dependencies.
06:50:37 <Megzlna> not multiple cases
06:50:40 <Megzlna> but multiple uses of case
06:51:24 <Megzlna> The thing I don't understand about case:
06:51:41 <Zero_In_Mood> hi guys
06:51:42 <Zero_In_Mood> http://hpaste.org/13009
06:51:54 <Zero_In_Mood> problem n explanation is under the hpaste. i dont find the mistake :(
06:52:43 <Megzlna> foo xs = "zoooo" + (match1 xs) + "zarrrr" + (match2 match1) where match1 [] = ...
06:52:54 <Megzlna> If you just use where bindings instead of 'case'
06:53:06 <Megzlna> then you dont need to immediately put the 'of' afterwards
06:53:11 <Megzlna> the 'of' is intrusive
06:53:45 <Axman6> huh?
06:54:03 <ksf> you're confused you don't need an of in case you don't write a case?
06:54:19 <Megzlna> Not confused, I'll show what I mean
06:54:26 <ksf> are you also confused that you don't need an else if you don't write an if?
06:55:35 <Megzlna> > let foo xs = "! " ++ (match1 xs) ++ " !" where match1 [] = "hi"; match1 x = "ho"
06:55:36 <lambdabot>   <no location info>: parse error on input `;'
06:55:46 <Megzlna> > let foo xs = "! " ++ (match1 xs) ++ " !" where match1 [] = "hi"
06:55:48 <lambdabot>   <no location info>: parse error on input `;'
06:55:54 <quicksilver> Megzlna: yes, certainly if you use it twice, like  you use match1 twice, it's worth naming it.
06:55:56 <Megzlna> > let foo xs = "! " ++ match1 xs ++ " !" where match1 [] = "hi"
06:55:58 <lambdabot>   <no location info>: parse error on input `;'
06:56:08 <quicksilver> lambdabot evaulates expressions.
06:56:21 <quicksilver> that wasn't an expression ;)
06:56:28 <Megzlna> > let foo xs = "! " ++ (match1 xs) ++ " !" where match1 [] = "hi"; match1 x = "ho" in foo ""
06:56:29 <lilac> Zero_In_Mood: what's sortBMP supposed to do?
06:56:30 <lambdabot>   "! hi !"
06:56:36 <Megzlna> > let foo xs = "! " ++ (match1 xs) ++ " !" where match1 [] = "hi"; match1 x = "ho" in foo "..."
06:56:38 <lambdabot>   "! ho !"
06:56:39 <quicksilver> on the other hand, using a where block moves the code out of line
06:56:45 <quicksilver> which may be harder to read.
06:56:48 <Zero_In_Mood> it helps to sort the bitmap..
06:56:50 <quicksilver> Either is fine, just use which you prefer.
06:57:04 <Zero_In_Mood> so the highest y and smallest x is at first place
06:57:18 <Zero_In_Mood> its the efficiently way if u wanna IO() it
06:57:29 <lilac> my preference is to avoid let, case and if, and just use where, patterns and guards
06:57:43 <Megzlna> quicksilver: Ah... the crazy part about the 'case' was that people kept on using it on multiple lines
06:57:56 <Megzlna> in which case it's useless relative to 'where binding matching'
06:58:00 <Axman6> Megzlna: what's wrong with that?
06:58:11 <quicksilver> Megzlna: doesn't seem useless to me.
06:58:20 <quicksilver> it's just a choice about which order you prefer to write things
06:58:25 <Axman6> it makes it clear, and just about every language you'd usually write a case statement over multple lines
06:58:26 <quicksilver> and how many things you like to give names to.
06:58:36 <Axman6> i write where statements over multiple lines too
06:58:39 <Megzlna> quicksilver: So you'd keep on with some ++ right after the final case?
06:58:53 <quicksilver> yup.
06:59:04 <Megzlna> that's the part that's weird :P
06:59:57 <Megzlna> makes sense when you 1 line it, of course
06:59:57 <quicksilver> Megzlna: http://hpaste.org/13010
06:59:57 <quicksilver> here is some code using case
06:59:57 <hallongrottan> @pl \x -> \y -> x*y
06:59:57 <lambdabot> (*)
06:59:58 <quicksilver> I see absolutely no benefit in moving those two functions into a where clause and forcing myself to make up a stupid name for them.
07:00:14 <Axman6> "a <- nonblockingReadFuture f" what is the witchcraft? :O
07:00:16 <Varan> I get this error when trying to use Data.Set: (.text+0x3022): undefined reference to `containerszm0zi1zi0zi1_DataziSet_fromList_closure'
07:00:21 <Varan> seems like a linker error
07:00:27 <Varan> but i dont see whats wrong
07:00:31 <Megzlna> quicksilver: i see
07:00:33 <hallongrottan> @pl \x -> \y -> (fst x)*(snd y)
07:00:33 <lambdabot> (. snd) . (*) . fst
07:00:55 <Axman6> Varan: add --make to ghc: ghc --make -o fkb ...
07:01:26 <orbitz> :t (snd .)
07:01:27 <lambdabot> forall a b a1. (a1 -> (a, b)) -> a1 -> b
07:01:27 <Megzlna> quicksilver: where was 'ft' introduced?
07:01:33 <orbitz> :t (. snd )
07:01:34 <lambdabot> forall c a b. (b -> c) -> (a, b) -> c
07:01:49 <Varan> Axman6, it needs to search for the libs or something. It doesn't do it it self?
07:01:51 <Zero_In_Mood> hmm lilac i guess i wont get it with just where and guards :( too hard..
07:01:52 <Megzlna> can't be seen?
07:02:12 <Axman6> Varan: well --make will tell it to, did that work?
07:02:14 <lilac> Zero_In_Mood: that wasn't addressed to you :)
07:02:38 <lilac> Zero_In_Mood: sortBMP, maxBH and wegh can be replaced by a call to sortBy
07:02:58 <vixey>     o1 is associative or left-associative and its precedence is less than (lower precedence) or equal to that of o2, or
07:03:00 <vixey> should that be
07:03:03 <vixey>     o1 is non-associative or left-associative and its precedence is less than (lower precedence) or equal to that of o2, or
07:03:03 <vixey> ?
07:03:43 <Varan> Axman6, yes seems to work, thanks
07:03:46 <Megzlna> (was wondering if the 'ft' actually gets introduced by a pattern match on tuple to Just)
07:04:03 <lilac> Zero_In_Mood: something like: sortBMP = sortBy (comparing (second negate))
07:05:38 <lilac> Zero_In_Mood: maybe sortBMP = sortBy (comparing (swap . second negate)) where swap (a,b) = (b,a)
07:06:06 <quicksilver> Megzlna: in an enclosing scope, I didn't quite paste everything
07:06:11 <Megzlna> k
07:06:12 <quicksilver> Megzlna: ft was bound as a function parameter.
07:07:36 <vixey> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=563#a563
07:07:39 <vixey> This is the algorithm
07:07:43 <vixey> ^
07:08:03 <Megzlna> ViewPatterns?
07:08:28 <vixey> Does anyone know the correctness argument of it please?
07:08:30 <Zero_In_Mood> sortBy !`
07:08:31 <Zero_In_Mood> !?
07:08:54 <lispy> ?src sortBy
07:08:54 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
07:09:14 <Zero_In_Mood> ?src cmp
07:09:14 <lambdabot> Source not found. Just what do you think you're doing Dave?
07:09:17 <Axman6> @src insertBy
07:09:18 <lambdabot> insertBy _   x [] = [x]
07:09:18 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
07:09:18 <lambdabot>                                  GT -> y : insertBy cmp x ys'
07:09:18 <lambdabot>                                  _  -> x : ys
07:10:02 <Axman6> Megzlna: ^^ appropriate case starement usage! :P
07:10:18 <lispy> hmm...is that merge sort?
07:10:28 <vixey> nobody knows...
07:10:29 <Axman6> seems so
07:10:39 <orbitz> insetBy?
07:10:52 <Megzlna> Axman6: cool
07:11:34 <Zero_In_Mood> i still aint get the function.. so i guess i ll have to search by myself
07:13:30 <lilac> Zero_In_Mood: sortBy is in Data.List
07:13:33 <vixey> Nobody knows where to find Dijsktras proof?
07:13:44 <Zero_In_Mood> not in mine.. i have to use winHugs
07:13:45 <lispy> grammatically you mean, "I still ain't got the function..."
07:13:58 * vixey ain't got the proof
07:14:07 <lispy> Zero_In_Mood: http://en.wikipedia.org/wiki/Ain’t
07:14:28 <Zero_In_Mood> u re mean. sorry english isnt my mother tongue language
07:14:41 <vixey> Zero_In_Mood, You are mean
07:14:51 <Zero_In_Mood> why ? btw thanks again vixey..
07:15:01 <vixey> Zero_In_Mood, :p not *you*
07:15:41 <lispy> Zero_In_Mood: Yeah, just being the grammar police, nothing personal
07:15:42 <Zero_In_Mood> ah no for real. my lil program we wrote together now is the new standard solution for the following years. it was even better than the programm the prof wrote
07:15:52 <vixey> hehehe
07:15:53 <mmorrow> haha
07:15:56 <lispy> he
07:15:58 <lispy> nice
07:15:58 <vixey> Zero_In_Mood, fabulous!
07:16:07 <mmorrow> #haskell++
07:16:27 <lispy> ?quote *.lambdabot
07:16:27 <lambdabot> Plugin `quote' failed with: regex failed: (ReturnCode 13,"Invalid preceding regular expression")
07:16:40 <Megzlna> I haven't had the flu in a long time, but I'm learning Haskell with the flu... In between trying to stop my head from flooding with snot
07:16:47 <Zero_In_Mood> yeah but i have my last haskell sheet now. then we ll start with c++, but i think im gonan idle here. maybe frome time to time i can learn something useful here :)
07:16:59 <vixey> Megzlna, it's gonna be soo gross when your head explodes!
07:17:04 <Megzlna> ;/
07:17:07 <xenoblitz> Guys is it possible to use a fold and one-liner this? http://hpaste.org/13011
07:17:14 <mmorrow> Zero_In_Mood: can you paste your solution? i'd love to see it
07:17:22 <Megzlna> well, I'll remember that time when I was sick and learned Haskell
07:18:18 <Zero_In_Mood> the one from last time ? hmm yeah lemme search it
07:18:30 <mmorrow> xenoblitz: the more-that-a-2-tuple aspect'll prevent all oneliners other that template-haskell ones
07:18:38 <lispy> xenoblitz: that looks more like State than fold to me
07:19:19 <Zero_In_Mood> mmorrow : http://hpaste.org/13012
07:19:22 <Zero_In_Mood> here u go
07:19:24 <xenoblitz> mmorrow: I need to replicate that  behaviour for a up to (a,b,c,d,e) so i guess the templates should be enough
07:19:38 <xenoblitz> lispy: it is kind of a state but i don't want to make use of it for this simple function
07:19:39 <lispy> runState $ takeM 5 (replicate vars_n) $ 0, or some weirdnes
07:19:45 <mmorrow> Zero_In_Mood: nice and clean :)
07:20:07 <vixey> xenoblitz: (a:b:c:d:_) =iterate (fst . vars_n) 0
07:20:25 <vixey> actually that's not the same, sor
07:20:27 <vixey> sorry
07:20:35 <xenoblitz> vixey: yeah its not a list :)
07:20:43 <vixey> no
07:20:52 <vixey> not what I meant
07:21:10 <mmorrow> , [|\(a:b:xs) -> ()|]
07:21:16 <lispy> Well, actually, a = b = c = d = e, if we type check it right?
07:21:20 <lunabot>  LamE [InfixP (VarP a_0) : (InfixP (VarP b_1) : (VarP xs_2))] (ConE ())
07:21:24 <lispy> So it could be a list?
07:21:24 * mmorrow figures out how to build the pattern
07:21:39 <xenoblitz> lispy: no they might be different for what i need it :)
07:21:48 <vixey> @pl let (x,xs) = f o in x : f xs
07:21:49 <lambdabot> (line 1, column 5):
07:21:49 <lambdabot> unexpected "("
07:21:49 <lambdabot> expecting "()", natural, identifier or "in"
07:22:06 <lispy> xenoblitz: well, I think given the code snippet you showed they would be equal
07:22:26 <xenoblitz> lispy: yes i guess you're right
07:22:30 <lispy> vars_n :: Num t => t -> a
07:22:38 <lispy> I guess maybe a could be different
07:23:00 <lispy> oh wait
07:23:06 <lispy> vars_n :: Num t => t -> (a, t)
07:23:08 <mmorrow> , ppDoc `fmap` (\n -> replicateM n (newName "x") >>= \xs -> lamE (foldr (\p q -> infixP p '(:) q) wildP (fmap varP xs)) (tupE (fmap varE xs))) 5
07:23:10 <lunabot>  luna: Couldn't match expected type `[Language.Haskell.TH.Lib.PatQ]'
07:23:26 <mmorrow> , ppDoc `fmap` (\n -> replicateM n (newName "x") >>= \xs -> lamE [foldr (\p q -> infixP p '(:) q) wildP (fmap varP xs)] (tupE (fmap varE xs))) 5
07:23:29 <lunabot>  \(x_0 : (x_1 : (x_2 : (x_3 : (x_4 : _))))) -> (x_0,
07:23:29 <lunabot>                                                 x_1,
07:23:29 <lunabot>                                                 x_2,
07:23:29 <vixey> g f (x,xs) = x : g f (f xs) then (a:b:c:d:e:_) = g vars_n (vars_n 0)
07:23:41 <vixey> xenoblitz, that way works
07:23:49 <mmorrow> , $((\n -> replicateM n (newName "x") >>= \xs -> lamE [foldr (\p q -> infixP p '(:) q) wildP (fmap varP xs)] (tupE (fmap varE xs))) 5) [0..]
07:23:51 <lunabot>  (0,1,2,3,4)
07:23:53 <vixey> see how g is not quite iterate
07:24:20 <xenoblitz> vixey: thanks :)
07:24:20 <mmorrow> so vixey's solution + that TH code'll do it i guess
07:24:25 <xenoblitz> mmorrow: hmmm nice as well
07:24:40 <vixey> the best is like
07:24:56 <vixey> mmorrow if you have a way to take the first n elements from a list into a n-tuple
07:25:03 <vixey> then you just compose that with the list I made
07:25:04 <lispy> vixey: oh could you write it with scanl?
07:25:04 <mmorrow> heh
07:25:10 <mmorrow> , $((\n -> replicateM n (newName "x") >>= \xs -> lamE [foldr (\p q -> infixP p '(:) q) wildP (fmap varP xs)] (tupE (fmap varE xs))) 9) [0..]
07:25:12 <lunabot>  (0,1,2,3,4,5,6,7,8)
07:25:16 <mmorrow> , $((\n -> replicateM n (newName "x") >>= \xs -> lamE [foldr (\p q -> infixP p '(:) q) wildP (fmap varP xs)] (tupE (fmap varE xs))) 14) [0..]
07:25:18 <vixey> lispy, ah! I have not learned these ones like scanl
07:25:18 <lunabot>  (0,1,2,3,4,5,6,7,8,9,10,11,12,13)
07:25:24 <lispy> :t scanl
07:25:26 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
07:25:37 <lispy> vixey: just fold with intermediates
07:25:51 <vixey> hmmiterate (vars_n . snd) (vars_n 0)
07:25:56 <xenoblitz> lispy: that's basically what i need
07:25:57 <vixey> map fst . iterate
07:25:59 <lispy> > scanl (+) 0 [1..10]
07:26:00 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55]
07:26:40 <lispy> ?oeis 0 1 3 6 10 15
07:26:41 <lambdabot>  Triangular numbers: a(n) = C(n+1,2) = n(n+1)/2 = 0+1+2+...+n.
07:26:41 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
07:26:46 <xenoblitz> lispy: scanl seems the thing :)
07:27:10 <vixey> so I can't find any shunting yard proof
07:27:16 <vixey> I have to figure it out from scratch
07:27:19 <vixey> gonna take ages.....
07:28:12 <lispy> > scanl (-) 0 [1..10]
07:28:14 <lambdabot>   [0,-1,-3,-6,-10,-15,-21,-28,-36,-45,-55]
07:28:19 <lispy> > scanr (-) 0 [1..10]
07:28:20 <lambdabot>   [-5,6,-4,7,-3,8,-2,9,-1,10,0]
07:29:20 <lispy> ?oeis -5 6 -4 7 -3 8
07:29:21 <lambdabot>  A002260 * A097807.
07:29:21 <lambdabot>  [1,1,2,2,1,3,2,3,1,4,3,2,4,1,5,3,4,2,5,1,6,4,3,5,2,6,1,7,4,5,3,6,2,7,1,8,5,4...
07:29:38 <lispy> lambdabot: yeah, not so much
07:31:37 <mmorrow> xenoblitz: here's that TH function cleaned up and some sample usage in ghci  http://hpaste.org/13011#a1
07:32:10 <xenoblitz> mmorrow: thanks a bunch :)
07:32:23 <mmorrow> no problem
07:35:05 <u_quark> what the best way to update a list at n'th element, like: update list n item
07:35:36 <mmorrow> not really any, lists are bad at that
07:35:43 <saml> @src update
07:35:44 <lambdabot> Source not found. I feel much better now.
07:35:50 <saml> use array
07:36:02 <mmorrow> yeah, that's probably your best bet
07:36:15 <twanvl_> case splitAt n list of (before,x:after) -> before++myModify x:after
07:36:49 <saml> > listArray "hello" // 'a'
07:36:50 <lambdabot>   Couldn't match expected type `(i, i)'
07:37:00 <saml> > listArray "hello" // (2,'a')
07:37:01 <lambdabot>   Couldn't match expected type `(i, i)'
07:37:22 <mmorrow> , listArray (0,4) "hello"
07:37:24 <lunabot>  luna: No instance for (Data.Array.Base.IArray a GHC.Types.Char)
07:37:37 <mmorrow> , listArray (0,4) "hello" :: Array Int Char
07:37:40 <lunabot>  array (0,4) [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
07:38:48 <u_quark> tnx all
07:42:50 <quicksilver> I'm not convinced array is his best bet.
07:42:57 <quicksilver> It would seldom be my first choice ;)
07:43:03 <mmorrow> mine neither
07:43:03 <quicksilver> I'd go for Map or Seq
07:43:32 <mmorrow> ah yeah, funny that that didn't even cross my mind
07:44:19 <mmorrow> (although i'd probably have used IntMap)
07:44:26 <saml> > unsafeReplace [(2, 'r'), (3, 'r')] (array (0,4) "hello")
07:44:27 <lambdabot>   Not in scope: `unsafeReplace'
07:45:00 <u_quark> IntMap sound good :)
07:45:17 <EmielRegis> Maps are vil
07:46:23 * mmorrow never uses arrays other than STUArray once every long time or so
07:48:45 <mmorrow> vixey: oh cool (shunting yard algorithm). so that does precedence parsing?
07:49:12 <quicksilver> mmorrow: I have used arrays occasionally for genuinely square or cuboid blocks of n-dimensional data which is immutable once created.
07:49:20 <vixey> mmorrow, I don't know yet :)
07:49:24 <quicksilver> mmorrow: for that purpose, their interface is a good fit.
07:49:26 <mmorrow> vixey: heh
07:49:28 <vixey> mmorrow, I'm trying out figure this algorithm out
07:49:32 <vixey> :/
07:49:33 <quicksilver> mmorrow: (that is, the readonly IArray interface is OK)
07:49:35 <vixey> I'm trying to*
07:50:16 <mmorrow> quicksilver: yeah, that does sound like it'd be a perfect fit. i'm not sure that's come up for me in haskell, but good to know ;)
07:50:42 <quicksilver> mmorrow: comes up occasionally in spatial work. I had a 3D grid of evaluations of a function and I was tesselating it.
07:51:33 <mmorrow> that's a cool mental picture
07:53:55 <mmorrow> vixey: i've been meaning to look this over for a long time now, but just remembered it, maybe it's applicable to something: http://code.haskell.org/lambdabot/lambdabot-utils/Lambdabot/FixPrecedence.hs
07:56:41 <raxas> should lambdabot be compilable on ghc 6.10.1 and did I missed something? http://hpaste.org/13013
07:58:50 <nj32> How can i automatically comment a block in emacs? I mean, {- ... -} type. I am using haskell mode.
07:59:41 <thoughtpolice> raxas: not yet I don't think so, no
07:59:43 <pejo> nj32, doesn't M-x comment-region work?
08:00:19 <leimy> nj32: you sure don't like to read documentation do you?
08:00:24 <thoughtpolice> raxas: that error looks like a problem with haskell-src-exts; there were api-breaking changes in the last few releases that lambdabot hasn't caught up with yet
08:00:25 <leimy> :-)
08:00:41 <nj32> pejo: thanks
08:00:49 <nj32> leimy: googled but failed
08:00:53 <leimy> Doh
08:01:03 <leimy> a really good resource for that is "http://www.emacswiki.org"
08:01:11 <leimy> at least I find it has lots of cool customizations.
08:01:16 <nj32> ok
08:07:17 <devragert> i have a question
08:09:25 <devragert> do which class does the ^ operator belong? i want to define ^ for a self made type, but i don't know to which class it belongs
08:09:44 <Philippa_> > :t (^)
08:09:45 <lambdabot>   <no location info>: parse error on input `:'
08:09:53 <Philippa_> @t (^)
08:09:53 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
08:09:53 <wchogg> :t (^)
08:09:55 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
08:10:04 <Philippa_> ah, thanks
08:10:21 <Philippa_> looks like Num
08:10:25 <wchogg> So you probably want to look in the Num class.
08:11:12 <Riastradh> (^) is not a method that can be implemented in an instance of a type class.
08:11:22 <saml> (^) :: (Num a, Integral b) => a -> b -> a
08:11:27 <devragert> it's not in Num
08:11:35 <Riastradh> It is a function defined by repeated multiplication.
08:12:08 <devragert> but how to define it for my own type then?
08:12:20 <saml> make your type instance of Num or Integral
08:12:30 <Riastradh> You can't, unless its definition corresponds with what you want for your type according to your type's definition of multiplication.
08:12:33 <saml> or both. depending on where your value of your type should apppear
08:13:23 <Riastradh> That is:  Either there is some definition of multiplication so that the existing definition of (^) means what you want, or you can't do this.
08:14:12 <devragert> hmm...
08:14:22 <saml> `^' is not a (visible) method of class `Num'
08:15:32 <devragert> and can I shadow/not import the '^' from the Prelude or something? (i'm not very experienced in such kind of things)
08:15:40 <Riastradh> Yes, you can.
08:15:42 <Riastradh> import Prelude hiding (^)
08:15:54 <Riastradh> What do you want to define (^) to be?
08:16:25 <devragert> just some sort of symbolic interpertation
08:16:33 <leimy> To use useful exception handling I hide catch from Prelude all the time :-)
08:16:34 <devragert> x ^ y = x :^: y
08:16:36 <vixey> > x^6
08:16:38 <leimy> Riastradh: howdy!
08:16:38 <lambdabot>   x * x * (x * x) * (x * x)
08:16:42 <vixey> > x^8
08:16:43 <vixey> > x^12
08:16:43 <lambdabot>   x * x * (x * x) * (x * x * (x * x))
08:16:45 <lambdabot>   x * x * (x * x) * (x * x * (x * x)) * (x * x * (x * x))
08:17:02 <saml>     a * b = MyInt (unMyInt a * unMyInt b)   how do I shorten this?
08:17:12 <saml> (*) = MyInt . ( ?? )
08:17:20 <saml> @pl     a * b = MyInt (unMyInt a * unMyInt b)
08:17:20 <lambdabot> (line 1, column 7):
08:17:20 <lambdabot> unexpected "="
08:17:20 <lambdabot> expecting variable, "(", operator, "*", "/", "`quot`", "`rem`", "`div`", "`mod`", ":%", "%" or end of input
08:17:34 <saml> @pl    \a b -> MyInt (unMyInt a * unMyInt b)
08:17:34 <lambdabot> (MyInt .) . (. unMyInt) . (*) . unMyInt
08:19:38 <devragert> import Prelude hiding (^) doesn't work, it gives a parse error
08:21:08 <raxas> thoughtpolice: I see, thanks for the tip
08:21:27 <wchogg> devragert:  try hiding ((^))
08:21:38 <wchogg> one set of parens for the hiding statement, one set for the operator
08:21:47 <RayNbow> @let a +- b = a - b
08:21:49 <lambdabot>  Defined.
08:21:55 <BMeph> tromp: Looks like you could have a slew of options for your codings: binary <--> LC, binary <--> CL, CL-binary <--> LC-binary. Mind if mmorrow and/or I tinker with it some? :)
08:22:01 <RayNbow> > map (+-4) [1..10]
08:22:03 <lambdabot>   [-3,-2,-1,0,1,2,3,4,5,6]
08:22:19 <RayNbow> there, solved the (-) operator section problem :p
08:22:23 <luite> hehe
08:22:45 <luite> > map (*-1) [1..10]
08:22:46 <lambdabot>   Not in scope: `*-'
08:22:48 <luite> fail
08:23:01 <RayNbow> just introduce (*-) ;)
08:23:26 <luite> waarom niet gewoon negatieve getallen verbannen
08:23:32 <luite> als je geen appels hebt kun je er ook geen opeten
08:23:39 <RayNbow> wrong language, luite :p
08:24:01 <RayNbow> and you just revealed to Haskell that you're a Dutchie :p
08:24:05 <RayNbow> * #haskell
08:24:23 <BMeph> mmorrow: BTW, have you poked around in tromp's code yet? :)
08:24:42 <luite> oh sorry :(
08:25:00 <nominolo|msr> @hoogle m Bool -> m () -> m ()
08:25:01 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
08:25:01 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
08:25:01 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
08:25:14 <leimy> I thought a Dutchie was a pan
08:26:13 <saml> devragert, http://hpaste.org/13014
08:26:22 <mmorrow> BMeph: i haven't but i'd love to check it out
08:27:04 <nominolo|msr> @hoogle m Bool -> m a -> m a -> m a
08:27:05 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
08:27:05 <lambdabot> Text.ParserCombinators.ReadP between :: ReadP open -> ReadP close -> ReadP a -> ReadP a
08:27:05 <lambdabot> Control.Exception catch :: IO a -> Exception -> IO a -> IO a
08:27:06 <saml> is c2hs good?
08:27:24 <devragert> thanks saml, i think i know how to proceed now
08:27:34 <maltem> Is there some standard function for breaking up a string the way a shell would break it up? That is, like 'words', but respecting quotes and backslash-escaped spaces
08:28:16 <devragert> btw: do i have to make a definition for all the sign, abs etc. stuff, which i won't use anyway?
08:28:23 <quicksilver> maltem: lex will do it the way haskell would
08:28:29 <quicksilver> maltem: (which is not the same, although it's related)
08:28:38 <mmorrow> maltem: not in the stdlibs, but if you write one and paste it you get ++ from me :)
08:29:04 * mmorrow has meant to write such a function for ages
08:29:35 <maltem> quicksilver: hm, I think lex is not enough for me
08:29:37 <mmorrow> i bet we can golf if with the bots
08:29:43 <maltem> mmorrow: heh
08:29:59 * mmorrow would find such a function extremely handy
08:30:11 <saml> devragert, do you use GHC?
08:30:40 <saml> if you use GHC, you can do newtype MyInt = MyInt {unMyInt :: Int}  deriving (Show, Eq, Ord, Num, Integral, Enum, Real)   and put {-# LANGUAGE GeneralizedNewtypeDeriving #-}  at the top of source code and forget about manually instantiating MyInt
08:32:12 <devragert> yes
08:32:44 <saml> http://hpaste.org/13014#a1
08:32:45 <quicksilver> > lex "\"hi \\" there\" this is not quoted"
08:32:46 <lambdabot>   <no location info>: parse error on input `\'
08:32:56 <quicksilver> > lex "\"hi \\\" there\" this is not quoted"
08:32:57 <lambdabot>   [("\"hi \\\" there\""," this is not quoted")]
08:33:12 <quicksilver> maltem: well, it deals with nested quotes and backslash escapes
08:33:24 <quicksilver> but it doesn't deal with it entirely the way a bourne shell would.
08:33:33 <devragert> i don't really understand, but it's fine, i am making progress
08:33:33 <mmorrow> , let q [] = []; q ('\\':cs) = "\\\\" ++ q cs; q ('`':cs) = "\\`" ++ q cs; q ('"':cs) = "\\\"" ++ q cs; q (c:cs) = c : cs in q "echo 'eval tree `dirname \`which ghc\``/../lib'"
08:33:35 <lunabot>  luna: lexical error in string/character literal at character 'w'
08:33:45 <mmorrow> , let q [] = []; q ('\\':cs) = "\\\\" ++ q cs; q ('`':cs) = "\\`" ++ q cs; q ('"':cs) = "\\\"" ++ q cs; q (c:cs) = c : cs in q "echo 'eval tree `dirname \\`which ghc\\``/../lib'"
08:33:47 <lunabot>  "echo 'eval tree `dirname \\`which ghc\\``/../lib'"
08:33:56 <mmorrow> hmm
08:33:59 <devragert> another question: how do u comment multiple lines at the same time?
08:34:07 <mmorrow> , let q [] = []; q ('\\':cs) = "\\\\" ++ q cs; q ('`':cs) = "\\`" ++ q cs; q ('"':cs) = "\\\"" ++ q cs; q (c:cs) = c : cs in text $ q "echo 'eval tree `dirname \\`which ghc\\``/../lib'"
08:34:09 <lunabot>  echo 'eval tree `dirname \`which ghc\``/../lib'
08:34:10 <devragert> does (*    *) work, or what?
08:34:14 <saml> devragert, {- line \n alsdafj f -}
08:34:17 <quicksilver> {-  -}
08:34:25 <devragert> ah ok
08:34:25 <quicksilver> although I normally just -- every line
08:34:32 <quicksilver> then you can uncomment lines one by one if you want to.
08:34:32 <saml> devragert, are you from ocaml?
08:35:01 <devragert> no, ocaml?
08:35:05 <mmorrow> um, it's hard to tell what's happening in those strings since there's haskell-string-escaping on top of it..
08:35:15 <orbitz> is 'if' syntax in haskell?
08:35:22 <saml> if is keyword
08:35:29 <saml> :t (if)
08:35:30 <orbitz> it could just be a function right?
08:35:30 <lambdabot> parse error on input `)'
08:35:36 <orbitz> err i mean
08:35:41 <orbitz> we could implement if via a function
08:35:54 <quicksilver> orbitz: it's a strange special case syntax on 'case' for Bool
08:35:55 <maltem> quicksilver: hm I think what is missing is just escaped space
08:36:05 <quicksilver> I'm quite fond of it though
08:36:10 <orbitz> if true trex _ = trex...
08:36:15 <orbitz> quicksilver: ok
08:36:26 <orbitz> haskells if is a bit better than Erlangs
08:36:44 <mmorrow> maltem: oh yeah, good point
08:37:02 <maltem> quicksilver: and removal of quotes
08:37:11 <saml> orbitz, maybe this: http://pozorvlak.livejournal.com/95054.html
08:37:24 <pejo> orbitz, how does Erlangs if behave?
08:37:37 <devragert> and is there a way to make MyType an instance of Fractional for example, without having to define all operators I don't use? or is there a way to suppress the warnings i get because of not doing it?
08:38:06 <orbitz> pejo: more like a case
08:38:21 <orbitz> pejo: you get teh asme effect, the syntax is just a bit clunky in erlang
08:41:14 <wchogg> Syntax is about the only thing I've ever seen complaints about in Erlang.
08:42:26 <orbitz> i, for the msot part, dont' have a problem with it.  so far i prefer haskelsl though
08:42:42 <orbitz> what ist he difference between newtype and type?
08:43:11 <saml> type is like typedef in C. alias. newtype introduces completely new type
08:43:16 <wchogg> newtype is a truly new type so you can declare it to be instances of a class
08:43:46 <mauke> syntactically newtype is like data with only one constructor
08:43:49 <saml> compiler doesn't complain when you mix  A and B  given type A = B.
08:43:53 <mauke> and one argument
08:43:54 <orbitz> ok
08:44:17 <orbitz> so with type i can do type Name = String, and clearly i can use "this is a name", but with newtype i would have to use a constructor since it *really* is a new type
08:44:19 <wchogg> but the at runtime the newtype adds no overhead
08:44:29 <orbitz> newtype Name = Name String
08:44:44 <mauke> yes
08:45:10 <chessguy_work> orbitz, and with a newtype, you can write functions that can take Strings, but not Names
08:45:23 <chessguy_work> (or vice versa)
08:45:36 <orbitz> right
08:45:51 <devragert> Can I do something like this:
08:46:04 <orbitz> i can't play with newtype on the shell can i?
08:46:16 <mauke> orbitz: declarations need to go in files
08:46:25 <mauke> but see :l
08:46:39 <orbitz> right
08:46:46 <orbitz> i cannot do
08:46:56 <orbitz> newtype Address = Address Int String right?
08:47:02 <orbitz> (i get a parse error)
08:47:11 <mauke> right, because that's not a simple wrapper
08:47:14 <chessguy_work> you want data for that
08:47:16 <orbitz> ok
08:47:23 <chessguy_work> data Address = Address Int String
08:47:37 <mauke> newtype Address = Address (Int, String)  -- pointless but valid
08:47:55 <devragert> Can I do something like this:
08:47:57 <devragert> data Maybe a = Just a | Nothing
08:47:58 <devragert> type MM = Maybe Maybe ?
08:48:03 <mauke> devragert: no
08:48:19 <mauke> that's a kind error
08:48:32 <saml> maybe
08:48:36 <BMeph> mmorrow: FYI, http://homepages.cwi.nl/~tromp/cl/Lambda.lhs
08:48:39 <orbitz> http://www.boingboing.net/2008/12/12/comfort-with-meaning.html
08:48:53 <wchogg> wait, he could do type MM a = Maybe (Maybe a), yes?
08:48:55 <orbitz> what is a 'kind'
08:49:13 <chessguy_work> wchogg, or type MM = Maybe (Maybe Int)
08:49:22 <Asgaroth> orbitz: Sortof of a type argument
08:49:23 <mauke> orbitz: the "type" of a type constructor
08:49:33 <mauke> :k Int
08:49:34 <lambdabot> *
08:49:36 <mauke> :k Maybe
08:49:37 <lambdabot> * -> *
08:49:41 <mauke> :k Maybe Int
08:49:42 <lambdabot> *
08:49:43 <devragert> it does work when i do:
08:49:45 <devragert> Maybe = Just Maybe | Nothing,
08:49:47 <devragert> but i want to split it into two pieces, so that i can make the Maybe thing a functor
08:49:52 <vixey> * ~ *
08:50:06 <vixey> Maybe, Just Maybe
08:50:09 <wchogg> and you can sometimes leave off parameters in a type synonym.  In a few games I had something like type Game = StateT IO GameState and then I could use Game () or Game a in signatures.
08:50:29 <vixey> why not curry that function!
08:50:38 <leimy> mmm currry
08:50:45 <orbitz> so Maybe maps any type to any type?
08:50:47 <mauke> newtype Fix t = Fix (t (Fix t))
08:50:49 <orbitz> is that what that means?
08:50:51 <devragert> the problem of type synonyms is that it cannot have any recursion like data
08:50:55 <saml> devragert, data Maybe a = Just (Prelude.Maybe a) | Nothing
08:50:56 <mauke> type MM = Fix Maybe
08:51:04 <leimy> Maybe contains a value of any type or Nothing.
08:51:18 <wchogg> orbitz : right, it's a mapping from the set of types to the set of types.
08:51:34 <saml> how easy is it to write haskell binding to C library?
08:51:36 <orbitz> i'm not sure i understand why Maybe is a mapping though
08:51:44 <mauke> orbitz: because it takes an argument
08:51:44 <leimy> saml: surprisingly?
08:51:45 <wchogg> saml : pretty easy.
08:51:46 <Megzlna> Other common a's, besides a, b?
08:51:48 <devragert> well, the Maybe thing was just an example (my actual goal is slightly more complex)
08:51:54 <leimy> FFI is pretty cool
08:51:57 <Asgaroth> Therefore the Maybe constructors might be considered Functors in theory, right?
08:52:01 <saml> so, write me a haskell binding to LLVM C binding
08:52:02 <wchogg> saml : I've been doing a lot of ffi lately, so feel free to ask any questions.
08:52:11 <leimy> saml: already a package
08:52:12 <wchogg> what's llvm?
08:52:18 <leimy> saml: see hackage
08:52:21 <leimy> someone beat you to it.
08:52:23 <nominolo|msr> the low-level virtual machine
08:52:25 <orbitz> mauke: what is it mapping though?
08:52:26 <wchogg> Oh!
08:52:29 <saml> leimy, llvm in hackaeg is outdated. and i can't compile darcs version
08:52:30 <mauke> orbitz: types
08:52:45 <leimy> saml: I'm sure the author will accept patches
08:53:12 <orbitz> mauke: if i do Just 3, have i mapped an Int to a Maybe Int?
08:53:20 <leimy> Also, I believe LLVM is C++ right?
08:53:31 <leimy> :t Just 3
08:53:33 <lambdabot> forall t. (Num t) => Maybe t
08:53:34 <wchogg> orbitz : yes.
08:53:41 <mauke> orbitz: yes
08:53:45 <orbitz> ok
08:53:49 <leimy> :t Just (3 ::Int)
08:53:50 <saml> leimy, they do have C headers though..  include/llvm-c  . but i'm not sure how that works.
08:53:50 <lambdabot> Maybe Int
08:53:57 <Zero_In_Mood> yo guys need to write endless list which is starting with [0,1,1,...] n the following integer are build through the 3 in front of the one im doing right now ..
08:53:58 <Zero_In_Mood> http://hpaste.org/13015
08:54:02 <Zero_In_Mood> but i kinda got small mistake
08:54:07 <leimy> saml:  I'm sure they just extern "C" wrapped up a slightly different interface
08:54:23 <leimy> you can pass pointers to C++ objects around in a C library, just not pointers to member functions :-)
08:54:25 <orbitz> data Address = Address Int String, it's kind woudl eb Int -> String -> Address ?
08:54:40 <Megzlna> Is pattern matching on function arguments and pattern matching on guard the same exact speed?
08:54:41 <mauke> orbitz: no, the kind of Address is *
08:55:01 <Megzlna> a.k.a: does guard have an overhead
08:55:03 <orbitz> what does * mean in this context?
08:55:04 <saml> leimy, i don't understand C/C++ because it's hard
08:55:10 <mauke> orbitz: "this is a type"
08:55:17 <quicksilver> Megzlna: you can't pattern match in a guard.
08:55:23 <orbitz> mauke: so the kind is * -> * -> * ?
08:55:24 <Megzlna> quicksilver: let me rephrase
08:55:29 <quicksilver> Megzlna: a guard is a boolean expression, which is quite different from a pattern match :)
08:55:30 <orbitz> err
08:55:33 <orbitz> i'm nto mapping anything right?
08:55:34 <mauke> orbitz: of what?
08:55:42 <Megzlna> quicksilver: does patern matching _ and then using a guard with a conditonal
08:55:43 <orbitz> an Address is just an Address?
08:55:46 <Megzlna> have an overhead
08:55:48 <mauke> orbitz: yes, exactly
08:55:52 <saml> orbitz, kind is type of types. type is type of values. sort is type of kinds. i'm sure there is type of sorts. and type of type of sorts... etc n-dimensions
08:55:54 <quicksilver> Megzlna: compared to what?
08:56:03 <mauke> orbitz: kinds are only about the part left of the =, basically
08:56:05 <athos> hi all
08:56:22 <orbitz> if i had data Useless a = Useless a
08:56:25 <orbitz> is that * -> * ?
08:56:28 <mauke> yes
08:56:31 <Asgaroth> Zero_In_Mood: f doesn't produce a list. The easiest fix is to remove the :f (n+1) in the last line and write ulc= map f [0..]
08:56:34 <mauke> :k Identity
08:56:35 <lambdabot> * -> *
08:56:51 <Megzlna> quicksilver: for example    f x | x == 1 =   vs.  f 1 =
08:57:00 <Megzlna> is what I meant
08:57:01 <wchogg> saml : are there really benefits to going up to higher 'dimensionality'?
08:57:04 <mauke> Megzlna: those mean _exactly_ the same thing
08:57:07 <orbitz> mauke: is it possible to have * -> * -> * or are my otpion * or * -> *?
08:57:15 <mauke> :k ContT
08:57:16 <lambdabot> * -> (* -> *) -> * -> *
08:57:18 <saml> wchogg, no idea. it probably lets you have ph.d
08:57:22 <quicksilver> Megzlna: ok, so what you really want to ask is "is pattern matching faster than =="
08:57:26 <Megzlna> mauke: They will be equal after optimizer?
08:57:27 <quicksilver> Megzlna: that's the key difference here.
08:57:30 <orbitz> @src ContT
08:57:30 <lambdabot> newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }
08:57:33 <mauke> Megzlna: no, after desugaring
08:57:37 <Megzlna> quicksilver: yes ;)
08:57:41 <quicksilver> Megzlna: unfortunately numbers are a bad example
08:57:43 <wchogg> saml : well I meant other than the obvious one :p
08:57:47 <baaba> wchogg, kinds already exist implictly when you have parameterized types
08:57:48 <quicksilver> because number pattern matches desugar to ==.
08:57:57 <saml> i think at some point type checking becomes turing complete when you go one dimension higher than current haskell type system
08:58:06 <quicksilver> Megzlna: for a general user defined type it should be the same speed, but if anything pattern matching will be faster.
08:58:11 <Asgaroth> Zero_In_Mood: Or use "ulc = 0 : 1 : 1 : zipWith3 (\a b c -> a + b + c) ulc (tail ulc) (tail $ tail ulc)"
08:58:36 <Zero_In_Mood> wtf.. thats pretty hard to understand right away asgaroth^^
08:58:37 <vixey> saml, I don't think so
08:58:43 <quicksilver> Megzlna: the (==) implementation might check things in a particular order which is less optimal.
08:59:20 <Asgaroth> Zero_In_Mood: Look at the fibonacci example on the wikipedia article on haskell, it's the same principle and explained there very well.
08:59:35 <Megzlna> quicksilver: thx
08:59:55 <Megzlna> I guess I'll very slightly try to prefer pattern matches
09:00:26 <vixey> >  0 : 1 : 1 : 0+1+1 : 1 + 1 + (0+1+1) : []
09:00:27 <Megzlna> the real concern was if 'x' gets introduced as something on the heap
09:00:28 <lambdabot>   [0,1,1,2,4]
09:00:41 <Megzlna> whereas with pattern match, never des
09:00:49 <pejo> wchogg, Tim Sheard has a language called Omega. I think there are papers by him describing how sorts and other things can be used in Omega.
09:01:13 <vixey> > let y 0 = 0; y 1 = 1; y 2 = 1; y n = y (n-1) + y (n-2) + y (n-3) in map y [0..]
09:01:28 <lambdabot>   thread killed
09:01:29 <wchogg> pejo : Didn't realize Omega did that.  Cool.
09:01:38 <vixey> > let y 0 = 0; y 1 = 1; y 2 = 1; y n = y' (n-1) + y' (n-2) + y' (n-3) ; y' n = ys!!n; ys = map y [0..] in map y [0..]
09:01:40 <lambdabot>   [0,1,1,2,4,7,13,24,44,81,149,274,504,927,1705,3136,5768,10609,19513,35890,6...
09:01:50 <Asgaroth> besides, I could have made it worse via (((+) .) . (+)) instead of (\a b c -> a+b+c)
09:01:54 <vixey> Zero_In_Mood: why did the second work but not the first! :)
09:02:26 <Zero_In_Mood> how should i know ? ^^
09:02:38 <vixey> just a puzzle to think about
09:02:39 <Zero_In_Mood> maybe cause u started using variables instead of numbers :)
09:02:51 <vixey> I mea
09:02:52 <vixey> <vixey> > let y 0 = 0; y 1 = 1; y 2 = 1; y n = y (n-1) + y (n-2) + y (n-3) in map y [0..]
09:02:56 <vixey> vs
09:02:57 <quicksilver> Megzlna: naming a parameter never introduces a new object on the heap
09:02:58 <vixey> <vixey> > let y 0 = 0; y 1 = 1; y 2 = 1; y n = y' (n-1) + y' (n-2) + y' (n-3) ; y' n = ys!!n; ys = map y [0..] in map y [0..]
09:03:02 <Zero_In_Mood> oh ^^
09:03:13 <quicksilver> Megzlna: naming a parameter is merely applying a new name (zero-overhead) to an object which already existed.
09:03:28 <quicksilver> Megzlna: let x = y in .... is zero overhead as well.
09:03:51 <Zero_In_Mood> it must be that u used the variable y for two numbers .. but that aint allowed right!? :) or isnt it the reason?^^
09:04:01 <vixey> hehe
09:05:16 <Asgaroth> vixey: Actually that first example works fine for me. Don't know why it doesn't here though.
09:05:40 <vixey> Asgaroth, both programs are equivalent it's just that one runs a few million times slower
09:06:03 <Zero_In_Mood> hmm asgaroth.. i dont know what ulc "(tail ulc) (tail $ tail ulc)" this part is kidna doing :(
09:06:31 <Asgaroth> It just starts taking elements from the beginning, then from the first and then from the second position.
09:06:34 <vixey> @let initial = (0,1,1)
09:06:36 <lambdabot>  Defined.
09:06:40 <jeffersonheard> so one of the things I ended up writing the other day in my pursuit of a pure functional Cairo interface was writing functions with arbitrarily ordered default arguments.  That is, currying was impractical, because all arguments were potentially default or not.
09:06:43 <vixey> @let next (x,y,z) = (y,z,x+y+z)
09:06:44 <lambdabot>  Defined.
09:07:02 <Asgaroth> thereby one avoids "triple recursion"(computing every value 3 times), which makes vixey's first version slow.
09:07:06 <jeffersonheard> So my solution was to write a record type and use the record syntax to fill-in arguments
09:07:07 <vixey> > let fst' (i,_,_) = i in map fst' (iterate next initial)
09:07:08 <lambdabot>       Ambiguous occurrence `next'
09:07:08 <lambdabot>      It could refer to either `L.next', def...
09:07:17 <skorpan> what is the most significant difference between let and where?
09:07:21 <vixey> > let next (x,y,z) = (y,z,x+y+z); fst' (i,_,_) = i in map fst' (iterate next initial)
09:07:22 <lambdabot>   [0,1,1,2,4,7,13,24,44,81,149,274,504,927,1705,3136,5768,10609,19513,35890,6...
09:07:26 <skorpan> or is one of them syntactic sugar for the other one?
09:07:38 <jeffersonheard> has anyone considered doing a labels-like system for Haskell (similar to labels in OCaml)
09:07:40 <vixey> skorpan, where goes after and let comes before
09:07:40 <jeffersonheard> ?
09:07:41 <Zero_In_Mood> damn u sure are some pros^^
09:08:04 <Asgaroth> skorpan: you can't use where in monadic notation the way you can use let.
09:08:23 <Asgaroth> s/monadic notation/do-notation
09:08:26 <mauke> jeffersonheard: http://okmij.org/ftp/Haskell/types.html#keyword-args
09:08:49 <skorpan> Asgaroth: then again, the "normal" let syntax is not the same as the "do" let syntax
09:08:57 <Asgaroth> yes
09:09:31 <Saizan> jeffersonheard: yes, http://www.haskell.org/haskellwiki/Extensible_record
09:09:39 <pejo> jeffersonheard, http://neilmitchell.blogspot.com/2008/04/optional-parameters-in-haskell.html
09:09:53 <pejo> Heh. Three different answers.
09:09:56 <Zero_In_Mood> instead of the $ i can write : (tail (tail ulc)) right ?
09:09:56 <Asgaroth> But I'd bet that they compile to the same code, therefore there should be no significant difference.
09:10:07 <Zero_In_Mood> instead of (tail $ tail ulc)
09:10:08 <Asgaroth> Zero_In_Mood: yes
09:10:12 <Zero_In_Mood> okay.
09:10:45 <jeffersonheard> hah.  three different incompatible implementations!  It must be my favorite language :-)
09:10:46 <Asgaroth> using . and $ just is more readable for a non-lisper for longer functions.
09:11:32 <Zero_In_Mood> so ulc is always a list of 3 elements right ?
09:11:47 <Asgaroth> No, ulc is a list of infinite elements
09:12:13 <Asgaroth> It builds itself as it goes along so to speak, therefore the three constants at the beginning
09:12:22 <Asgaroth> the rest is built via the zipWith3
09:12:40 <Zero_In_Mood> yeah but.. the zipwith helps with it using ulc, tail ulc and tail & tail ulc right ?
09:13:04 <Zero_In_Mood> but i dont get this combination or well i get it a lil bit but not as if i could explain it kinda..
09:13:26 <Asgaroth> Zero_In_Mood: Did you read http://en.wikipedia.org/wiki/Haskell_(programming_language)#More_complex_examples
09:13:30 <Asgaroth> Zero_In_Mood: the fibonacci example
09:13:43 <Zero_In_Mood> yes i did... on german but i read it
09:14:11 <Asgaroth> Zero_In_Mood: The English one is more verbose, perhaps it helps
09:14:31 <maltem> mmorrow: http://hpaste.org/13018 -- it's quite verbose and probably completely wrong
09:14:46 <vixey> Zero_In_Mood: you know the fibonacci sequence?
09:14:56 <nolrai_East> Hey I just updated to ghc 6.10 and now in ghci, the arrowkeys and backspace dont work? Whats up with that?
09:15:12 <Zero_In_Mood> fibonacci sequence ?
09:15:22 <maltem> mmorrow: I tried to make it behave like what I get from "echo" in bash
09:15:36 <Asgaroth> Zero_In_Mood: The same thing that you're trying to build, just with the sum of the _two_ previous numbers instead of 3
09:16:36 <Zero_In_Mood> hmm yeah i think i get it a lil bit more now after readign the english site.. thou it nearly was the same as the german one
09:16:54 <mauke> nolrai_East: ghci dropped readline
09:17:32 <nolrai_East> mauke: any way to fixit, it makes it almost unusible.
09:17:34 <BMeph> @oeis 0 1 1 2 4 7
09:17:35 <lambdabot>  Tribonacci numbers: a(n) = a(n-1) + a(n-2) + a(n-3).
09:17:35 <lambdabot>  [0,0,1,1,2,4,7,13,24,44,81,149,274,504,927,1705,3136,5768,10609,19513,35890,...
09:17:44 <Asgaroth> Zero_In_Mood: There's a table describing how this concept with zipWith fibs (tail fibs) evaluates
09:18:02 <vixey> fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
09:18:04 <mauke> nolrai_East: well, I hacked it back in but I don't remember the exact steps I took
09:18:16 <vixey> = 1 : 1 : zipWith (+) (1 : 1 : zipWith (+) fibs (tail fibs)) (tail (1 : 1 : zipWith (+) fibs (tail fibs)))
09:18:23 <mauke> nolrai_East: the official replacement is editline, which sucks IMHO
09:18:25 <vixey> = ...
09:18:55 <Zero_In_Mood> hmm
09:19:02 <Zero_In_Mood> okay thats cool.. with the table.. pretty useful :)
09:19:19 <Saizan> nolrai_East: http://www.nabble.com/ghci-haskeline-(was:-Re:-ANNOUNCE:-GHC-version-6.10.1---EditLine---terminal-incompatibility-)-td20617763.html
09:19:27 <Megzlna> quicksilver: sorry was away.. so.. naming a parameter never introduces a new name, but doesn't _ afford the ability to never even MOV the parameter in the first place. Just plain drop the cpu instructions for it
09:20:03 <Zero_In_Mood> k two tasks left now.. one just finding my mistake *haha :(* and another ugly one..
09:20:24 <blueonyx> selfsim?
09:21:15 <quicksilver> Megzlna: parameters don't get MOVed
09:21:23 <quicksilver> Megzlna: they're just an illusion in the frontend.
09:21:35 <Zero_In_Mood> hmm lol :D
09:21:40 <Megzlna> an illusion.. what's going on?
09:21:45 <Zero_In_Mood> yh lol blueonys one of em is called selfsim
09:22:08 <quicksilver> Megzlna: the code is just transformed so that it has access to that value.
09:22:13 <quicksilver> nothing needs ot be moved.
09:22:24 <quicksilver> Read the STG book if you want the details, it's slightly surprising at first.
09:22:36 <Megzlna> stg book?
09:22:44 <vixey> Migzlna, I linked you it yesterday.....
09:22:48 <Megzlna> k
09:23:00 <vixey> Megzlna, honestly I don't know why I give you all those references..
09:23:22 <Megzlna> vixey: I have a Stack
09:23:37 <Megzlna> I cannot possibly read 10 papers a day
09:23:55 <Asgaroth> Zero_In_Mood: I told you the mistake:
09:23:59 <Asgaroth> 17:56 < Asgaroth> Zero_In_Mood: f doesn't produce a list. The easiest fix is to remove the :f (n+1) in the last line and write ulc= map f [0..]
09:24:23 <Asgaroth> but this approach has the performance issues described earlier
09:24:26 <Megzlna> Once I've popped all this basic haskell stuff, then i'll read papers.
09:24:52 <quicksilver> Megzlna: for example, consider these two functions: g x = f x + 1 ; f y = y + 4
09:25:10 <quicksilver> Megzlna: when "f" "calls" "g", x isn't actually copied to y.
09:25:19 <Zero_In_Mood> na na lol.. it aint this task another task i was talking about... there is some damn asshole mistake in it :) but i guess i have to rewrite it
09:25:20 <quicksilver> f is just called in such a way that it has acces to x
09:25:39 <Megzlna> it's actually a closure ?
09:25:47 <quicksilver> yes.
09:25:52 <quicksilver> everything's a closure.
09:25:59 <quicksilver> (at least that's one way of imagining it)
09:26:10 <quicksilver> of course implementations vary.
09:26:16 <quicksilver> and sometimes stuff gets compiled down in a surprising way.
09:26:29 <quicksilver> but the key point is parameter passing is never copying, in haskell.
09:26:48 <Megzlna> what about copying of the reference
09:29:07 <quicksilver> orbitz: yes, Bornat rocks.
09:29:43 <quicksilver> Megzlna: when you enter a closure, you might already have your registers in the right plce, in which case nothing happens, or you might have to change a register or a closure pointer to point to a parameter.
09:29:56 <quicksilver> but it's not always obvious from the source what will end up being entering a closure.
09:30:09 <quicksilver> the Core generated by GHC bears only a passing resemblance to the haskell :)
09:30:17 <athos> someone here who's into J?
09:31:04 <vixey> athos why do you keep asking that
09:31:49 <athos> why do you keep remembering the only case which was yesterday
09:31:50 <athos> 8)
09:31:58 <vixey> fine
09:33:44 <thomashartman1> Is there a way to write this using list comprenhensions? ys = map ((\x -> map (\y -> (x,y)) [1..10])) xs
09:33:52 <nolrai_East> Saizen: darcs is giving me an Invalid repository Error.
09:34:22 <Saizan> nolrai_East: update your darcs
09:34:36 <Lemmih> thomashartman1: [ [ (x,y) | y <- [1..10] ] | x <- xs ] ?
09:34:39 <mauke> > [ [ (x,y) | y <- [1 .. 10] ] | x <- [a,b,c,d] ]
09:34:40 <lambdabot>   [[(a,1),(a,2),(a,3),(a,4),(a,5),(a,6),(a,7),(a,8),(a,9),(a,10)],[(b,1),(b,2...
09:35:08 <vixey> thomashartman1: yes but there's a better way without
09:35:23 <vixey> thomashartman1: since [] is a monad, this is really  liftM2 (,)
09:35:30 <Lemmih> thomashartman1: Or: [ (x,y) | x <- xs, y <- [1..10] ] ?
09:35:46 <mauke> vixey: I don't believe you
09:36:21 <vixey> ok
09:36:22 <mauke> :t [ [ (x,y) | y <- [1 .. 10] ] | x <- ?xs ]
09:36:23 <lambdabot> forall t t1. (Enum t1, Num t1, ?xs::[t]) => [[(t, t1)]]
09:36:25 <vixey> I lied
09:36:36 <mauke> :t liftM2 (,) [1 .. 10] ?xs
09:36:37 <lambdabot> forall a1 a2. (?xs::[a2], Enum a1, Num a1) => [(a1, a2)]
09:36:51 <thomashartman1> duh, thx
09:37:17 <thomashartman1> don't use list comprehensions much :)
09:38:40 <lilac> > liftM (flip map [1..10] . (,)) ["Foo", "Bar"]
09:38:41 <lambdabot>   [[("Foo",1),("Foo",2),("Foo",3),("Foo",4),("Foo",5),("Foo",6),("Foo",7),("F...
09:41:02 <thomashartman1> Lemmih: actually that wasn't quite right, I wanted ten lists of ten elements,  [ (x,y) | x <- xs, y <- [1..10] ] is 1 list of 100
09:42:13 <jganetsk> how interested would folks be in an Erlang library, which would wrap Haskell concurrency stuff to make it look like Erlang... for the hell of it
09:42:40 <thomashartman1> lemmih: uh, well at least 1 was right ;)
09:44:28 <lilac> > map.(,) <$> ["Foo", "Bar"] <*> return [1..10]
09:44:30 <lambdabot>   [[("Foo",1),("Foo",2),("Foo",3),("Foo",4),("Foo",5),("Foo",6),("Foo",7),("F...
09:48:16 <thomashartman1> [ [ (show x) ++ (show y) ++ ".gif" | y <- [1..10] ] | x <- [1..10] ]
09:48:47 <lilac> > ([1..10] <^) . (,) <$> ["Foo","Bar"]
09:48:49 <lambdabot>   [[("Foo",1),("Foo",2),("Foo",3),("Foo",4),("Foo",5),("Foo",6),("Foo",7),("F...
09:48:51 <devragert> question: when I evaluate
09:48:53 <devragert> show (1/3) , then the result is "0.33333333333"
09:48:54 <devragert> is there a simple way to get just "0.333" as result?
09:49:10 <lilac> > take 5 $ show (1/3)
09:49:12 <lambdabot>   "0.333"
09:49:26 <mauke> > printf "%.5f" (1/3) :: String
09:49:27 <lambdabot>   "0.33333"
09:50:16 <devragert> does the printf command take 5 digits then?
09:50:33 <devragert> actually, i always want just 3 digits
09:51:04 <devragert> but not that show (1000000) becomes "10000"
09:51:13 <Megzlna> Is there a better way than:
09:51:14 <Zao> > printf "%.3f" (10042.35791) :: String
09:51:15 <Megzlna> take n _ | n <= 0 = []
09:51:16 <lambdabot>   "10042.358"
09:51:32 <Megzlna> Everything like this needs a single guard for <0
09:51:43 <Megzlna> otherwise it'd just be take 0 _
09:51:47 <devragert> ok, thanks, i will try it out
09:51:57 <Zao> > printf "%.03f" (10042.3) :: String
09:51:58 <lambdabot>   "10042.300"
09:52:06 <Zao> devragert: man printf  if on any sane platform.
09:52:23 <mauke> Zao: man 3 printf
09:52:34 <int-e> > let take' (n+1) (x:xs) = x : take' n xs; take' _ _ = [] in (take' 2 [1..], take' (-2) [1..])
09:52:35 <lambdabot>   ([1,2],[])
09:52:41 <blueonyx> speaking of erlang, are you doing heavily parallel stuff with haskell and do you know disadvantages compared to erlang?
09:52:47 <devragert> not in scope printf
09:53:00 <int-e> Megzlna: this works, but imho it's ugly. (n+k patterns should die ;-)
09:53:00 <mauke> @index printf
09:53:01 <lambdabot> Text.Printf
09:53:04 <Megzlna> int-e: what the hell
09:53:11 <vixey> n+k is great
09:53:19 <Zao> mauke: Depending on system.
09:53:25 <vixey> It's so much more positive !
09:53:25 <augustss> n+k musy die
09:53:33 <augustss> must
09:53:36 <Zao> mauke: You need -s on slowlaris.
09:53:43 <mauke> perldoc -f sprintf  # works everywhere :-)
09:53:45 <vixey> @let plus = (-)
09:53:46 <lambdabot>  <local>:14:0:
09:53:46 <lambdabot>      Multiple declarations of `L.plus'
09:53:46 <lambdabot>      Declared at: <loca...
09:53:53 <Megzlna> Why must that way of doing it die?
09:54:06 <vixey> , let plus = (-);  f (plus 3 -> x) = x in f 7
09:54:06 <devragert> i'm sorry, i don't understand
09:54:08 <lunabot>  -4
09:54:15 <vixey> , let plus = flip (-);  f (plus 3 -> x) = x in f 7
09:54:17 <lunabot>  4
09:54:29 <int-e> Megzlna: as you can see, the issue of n+k patterns is a little contentious :)
09:54:38 <mauke> devragert: you need to import Text.Printf
09:54:45 <Megzlna> so why do they oppose it?
09:54:48 <devragert> ok, thanks
09:54:56 <int-e> Megzlna: for some people it's the best invention since sliced bread, while others don't like it one bit.
09:55:19 <ozy`> blueonyx: Erlang is good for programs where a lot of threads exchange small amounts of data. Haskell is good for programs where a small number of threads all need lots of access to the same data.
09:55:28 <ozy`> that's my understanding anyway
09:56:36 <int-e> Megzlna: I oppose it because the inherint comparison (n+1) matches integral numbers >=1) seems too much to hide. I like n patterns (0, 1, 2...) though, which are basically just as bad for the compiler.
09:56:55 <vixey> to hide?
09:57:06 <int-e> @type \(n+1) -> n
09:57:07 <lambdabot> forall t. (Integral t) => t -> t
09:57:08 <Megzlna> >  let f (x+1) = x in f 7
09:57:09 <lambdabot>   6
09:57:16 <devragert> ok, now i have the printf thing working, but it's not what i need
09:57:29 <vixey> +k is a view pattern for -k :P
09:57:30 <Megzlna> Well, I'd better add that to my pattern matching section ;)
09:57:36 <devragert> it has not string as output type
09:57:38 <Megzlna> that n+k way is way better!
09:57:46 <mauke> devragert: how so?
09:57:52 <vixey> > (-1) 7
09:57:53 <lambdabot>       No instance for (Num (t -> a))
09:57:53 <lambdabot>        arising from a use of `negate' at...
09:57:54 <int-e> vixey: (n+1) desugars to somehting like  n' | n >= 0 ... where n = n' - 1
09:58:00 <mauke> > subtract 1 7
09:58:01 <lambdabot>   6
09:58:02 <devragert> i want a string as result
09:58:11 <mauke> devragert: yes, I got that
09:58:15 <int-e> vixey: you know it isn't.
09:58:21 <int-e> vixey: that's my point, I think.
09:58:31 <vixey> , let plus = flip (-);  f (plus 3 -> x) = x in f 7
09:58:33 <lunabot>  4
09:58:40 <Megzlna> vixey why don't youo like n+k ?
09:58:40 <int-e> vixey: x+1 only matches for x >= 0
09:58:47 <augustss> devragert: you need a string, you get a string
09:58:54 <vixey> you can use Maybe for the conditional
09:59:00 <Megzlna> > let f (x+1) = x in f 1
09:59:02 <lambdabot>   0
09:59:04 <Megzlna> > let f (x+1) = x in f 0
09:59:05 <lambdabot>   * Exception: /tmp/9194843236436961516:71:44-54: Non-exhaustive patterns in ...
09:59:10 <vixey> Megzlna, I don't really like it it's not especially good or bad
09:59:12 <Megzlna> why not -1 ?
09:59:12 <blueonyx> has anyone else an oppinion about haskell vs erlang? :)
09:59:22 <Zao> blueonyx: Both suck.
09:59:27 <vixey> lol
09:59:29 <blueonyx> :)
09:59:51 <Megzlna> how is 0 not -1 + 1 ! ?
10:00:00 <devragert> is there an easy search tool for lists?
10:00:11 <int-e> Megzlna: because there's an implicit condition that x must be at least 0 for the pattern to match.
10:00:20 <Megzlna> where?
10:00:22 <Zao> devragert: Skim Data.List_
10:00:22 <saml> > 0 == (-1) + 1
10:00:23 <lambdabot>   True
10:00:28 <Zao> s/_/?/
10:00:32 <int-e> Megzlna: in the haskell report (which defines a desugaring for those patterns)
10:00:33 <devragert> ok, thanks
10:00:45 <Megzlna> int-e: so it's a special case scenario
10:00:54 <Zao> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#13
10:00:59 <saml> > succ (-1)
10:01:00 <lambdabot>   0
10:01:15 <augustss> n+k is super special, that's why it must die
10:01:22 <devragert> so what command in Data.List do i have to use then, Zao?
10:01:23 <Megzlna> augustss: ?
10:01:46 <orbitz> devragert: do you mean function?
10:02:04 <Zao> devragert: It depends on what you want to achieve.
10:02:24 <quicksilver> conal: ping
10:03:03 <orbitz> devragert: are yo utryign to search for a pattern in a list?
10:03:12 <thoughtpolice> heheh
10:03:13 <thoughtpolice> http://www.mail-archive.com/haskell@haskell.org/msg01261.html
10:03:14 <devragert> i want something like:
10:03:17 <devragert> place '.' ("343.3553")
10:03:19 <devragert> which then evaluates as 4
10:03:24 <thoughtpolice> ^^ augustss has been head of the ban n+k patterns movement for a while I guess? :)
10:03:37 <augustss> I and many others
10:03:38 <vixey> devragert:  place c (c:_) = ?
10:04:13 <devragert> ?
10:04:17 <vixey> devragert: ....... 0
10:04:21 <orbitz> devragert: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#16
10:04:32 <vixey> devragert:  place c (d:xs) | d /= c = ?
10:04:33 <thoughtpolice> you know with my recent work on LHC I noticed that if I used haskell-src-exts for the parser eventually, then LHC wouldn't support n+k patterns (as haskell-src-exts currently stands, anyway)
10:04:41 <devragert> place c (c:_) should evaluate as 0 (or 1) doesn't matter that much
10:04:43 <thoughtpolice> i wonder how many people really care, though
10:04:54 <augustss> devragert: elemIndex
10:05:16 <orbitz> thoughtpolice: you workon LHC?
10:05:36 <orbitz> is that antoher haskell compiler?
10:05:40 <thoughtpolice> orbitz: http://lhc.seize.it <- that one, yes :)
10:05:44 <Megzlna> > let f (x*2) = x in f 8
10:05:45 <lambdabot>   <no location info>: Parse error in pattern
10:05:49 <Megzlna> lol
10:05:55 <orbitz> thoughtpolice: i thoguhti was teh cooler oen :(
10:05:57 <vixey> , let plus = flip (/);  f (times 3 -> x) = x in f 7
10:05:58 <lunabot>  luna: Not in scope: `times'
10:06:02 <vixey> , let times = flip (/);  f (times 3 -> x) = x in f 7
10:06:05 <lunabot>  2.3333333333333335
10:06:05 <thoughtpolice> orbitz: !!! lhc is really cool. :(
10:06:07 <int-e> Megzlna: see http://haskell.org/onlinereport/exps.html#case-semantics figure 4, last item. (if you care)
10:06:14 <vixey> , let times = flip (/);  f (times 3 -> x) = x in f 999
10:06:16 <lunabot>  333.0
10:06:18 <orbitz> thoughtpolice: i didn't say it wasn't
10:06:25 <Megzlna> it's kinda pussy it only works on +
10:06:41 <Megzlna> > let f (x-1) = x in f 8
10:06:42 <augustss> Megzlna: very, very special case :)
10:06:43 <lambdabot>   <no location info>: Parse error in pattern
10:06:52 <vixey> yeah, it should be able to find the inverse of arbitrary functions :P
10:06:55 <mfp> blueonyx: Erlang sucks at performance, Haskell sucks at distributed programming(?)
10:07:12 <blueonyx> xD
10:07:27 <cjb> mfp: but it rocks at parallel programming, at least
10:07:37 <dons> hehe. mfp we gotta get deutsche bank's haskell/otp released
10:08:04 <orbitz> they have a haskell otp?
10:08:04 <blueonyx> dons: ?
10:08:04 <augustss> before they go barkrupt
10:08:14 <augustss> bankrupt!  I can't type today
10:08:15 <dons> augustss: work harder !
10:08:30 <dons> i wonder: would a failed bank auction off its haskell code?
10:08:34 <dons> what would happen to it?
10:08:42 <augustss> it would die
10:08:50 <orbitz> hopefully someone would stael it
10:08:52 <augustss> unless someone working there steals it
10:08:56 <dons> the code would just be locked up on a disk somewhere?
10:09:06 <dons> shredded or melted down
10:09:17 <augustss> all those lovely bits
10:09:26 <dons> yeah
10:09:36 <mfp> dons, what's this?  http://www.reddit.com/r/programming/comments/7j33q/kibro_on_shared_hosting/   I want my money back :-P
10:09:49 <dons> mfp: i meant to submit it to the haskell  reddit.
10:09:55 <dons> only just noticed it went to the wrong one.
10:10:04 <dons> you know kibro?
10:10:16 <mfp> this is very weak even for the specific reddit
10:10:24 <mfp> yes, I saw the code some time ago
10:10:30 <dons> haskell reddit does haskell news, so appropriate there.
10:10:40 <dons> i'm actually surprised it got votes on normal reddit. interesting
10:11:37 <mfp> "PHP sucks, I can compile Haskell on the shared host yay. uh I can use the Haskell process with FastCGI I guess uh, did I say PHP sucks"
10:11:39 <dons> mfp: in general, 'what people are blogging about today' always goes to [haskell]
10:11:59 <quicksilver> you always get votes for PHP sucks
10:12:05 <dons> ah maybe that's it.
10:12:28 <mfp> so the "new" info is roughly   "Provided I can keep a process open on the server (a cron job should do it), I can probably use PHP as a kind of proxy to the FastCGI process."
10:12:29 <dons> jeffersonheard: any pictures from your 2d scenegraph lib yet?
10:12:37 <dons> mfp: so vote it down, sheesh.
10:14:28 <mfp> dons: I did, but I'm also trying to influence you if only slightly so that I don't have to do so in the future ;-)
10:14:44 <dons> i already said that it went to the wrong reddit, which i only noticed once i got into work.
10:14:47 <dons> so apologies.
10:15:05 <dons> here, have some sulzmann, http://www.reddit.com/r/programming/comments/7j3xl/symbolic_regular_expressions_via_gadts_no/
10:15:56 <Megzlna> is there any possible way to pattern match on an "last element"   (xs:>x)   -- I know that haskell lists can be infinite so it could possibly not make sense
10:15:59 <thomashartman1> what is otp?
10:16:08 <dons> Megzlna: hmm. view patterns could do it.
10:16:11 <jeffersonheard> dons, nothing special, but there's a smiley face sample program
10:16:15 <dons> f (last xs -> y) .. ?
10:16:19 <jeffersonheard> could do something fancy if someone had a task
10:16:20 <quicksilver> Megzlna: 'Seq' permits matching at both ends.
10:16:21 <Megzlna> dons: cool
10:16:22 <dons> jeffersonheard: i think some images would be compelling.
10:16:29 <quicksilver> Megzlna: through a slightly clumsy syntax
10:16:41 <Megzlna> quicksilver: how does that look? (if its not too long to bug ya)
10:16:44 <vixey> Megzlna, reverse the list
10:16:46 <quicksilver> case viewR sq of xs :> x ->
10:16:48 <quicksilver> I think
10:16:57 <vixey> (viewR -> xs :> x)
10:17:00 <quicksilver> 'viewR' == "view from the Right"
10:17:02 <Megzlna> lol I just guessed :>
10:17:07 <jeffersonheard> dons: I agree -- just feeling uninspired.  Working hard on ThousandWords and my wife's dessert shop, and haven't put anything together as a "demo" per se
10:17:08 <Saizan> viewr btw
10:17:12 <quicksilver> what vixey and dons posted are 'view patterns'
10:17:16 <dons> mfp, enjoy. http://www.reddit.com/r/programming/comments/7j3yf/the_self_hosting_happs_web_framework_tutorial/
10:17:17 <quicksilver> which is a haskell extension.
10:17:30 <quicksilver> plain old case viewr ss of... is plain haskell.
10:17:33 <dons> i'm glad the happs user base is gettting into the tutorial writing business.
10:17:56 <thomashartman1> I worked on the deutsche haskell project for a bit. I think the code will be ok and if deutsche hits difficulties they will do the right thing :)
10:17:56 <Megzlna> would there be any problem with an extension that just allows  (xs:>x) outright?
10:18:18 <dons> thomashartman1: oh, i didn't know you also worked for them (for a time?)
10:18:20 <roconnor> @type take 10 $ execWriter ((foldl (flip (>>)) (return ())) (repeat (tell "x")))
10:18:22 <lambdabot> [Char]
10:18:23 <thomashartman1> yep
10:18:29 <roconnor> @type take 10 $ execWriter ((foldl (>>) (return ())) (repeat (tell "x")))
10:18:31 <lambdabot> [Char]
10:18:35 <dons> thomashartman1: i need a good argument for them to open source
10:18:40 <roconnor> > take 10 $ execWriter ((foldl (>>) (return ())) (repeat (tell "x")))
10:18:50 <quicksilver> Megzlna: well, pattern matching contains a promise that it's an efficient thing.
10:18:58 <Megzlna> ah
10:19:04 <lambdabot>   thread killed
10:19:04 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
10:19:05 <quicksilver> Megzlna: a "pattern match" which was O(n) because it had to skip the end of the list would be surprising.
10:19:06 <thomashartman1> what do you think they have that would be the most valuable?
10:19:15 <Megzlna> quicksilver: gotcha
10:19:27 <dons> i think "interesting" is the typed db layer, and the "otp" support code
10:19:29 <thomashartman1> if I recall (and this has been said publicly) it's mainly a happs app with a traditional db backend (no macid)
10:19:34 <mfp> dons: ? I took a look at it a couple(?) days ago (was interested in the was HAppS does DBs and read about macid), didn't you submit it?
10:19:43 <dons> nope?
10:19:49 <mfp> maybe it was another submission and I found it indirectly
10:19:54 <int-e> Megzlna: :< is also a valid data constructor. The extension might break code.
10:20:09 <mfp> or I found it through the haskell reddit? dunno
10:20:11 <salty-horse> hi. any idea who maintains the official vim haskell syntax file? the header says it's the haskell-cafe mailing list, but it seems odd: http://vim.svn.sourceforge.net/viewvc/vim/vim7/runtime/syntax/haskell.vim?view=markup
10:20:23 <dons> oh perhaps. typhoon might have put it there.
10:20:29 <dons> salty-horse: hmm
10:20:33 <thomashartman1> from what I recall, a lot of the codebase is just sugar over interacting with various financial databases, which woudn't be particularly valuable in the public domain
10:20:36 <dons> i don't think there is an official maintainer.
10:20:36 <conal> quicksilver: pong
10:20:57 <quicksilver> conal: I have fixed all my important outstanding memory leaks. ;)
10:21:01 <dons> thomashartman1: the replication and failover stuff, and the typed sql things i think. but hard to say.
10:21:02 <int-e> @index (:<)
10:21:02 <lambdabot> bzzt
10:21:04 <quicksilver> conal: although one I had to fix by a terrible hack.
10:21:05 <salty-horse> dons, I found a bug: comments after imports don't highlight correctly. "import Foo --comment"
10:21:23 <roconnor> @src (++)
10:21:23 <lambdabot> []     ++ ys = ys
10:21:23 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
10:21:23 <lambdabot> -- OR
10:21:23 <lambdabot> xs ++ ys = foldr (:) ys xs
10:21:32 <roconnor> @src concat
10:21:32 <lambdabot> concat = foldr (++) []
10:21:52 <conal> quicksilver: i'd love to get a list of your leaks and fixes.  i have a hard time chasing these things down.
10:22:18 <int-e> @type Data.Sequence.(:<)
10:22:21 <lambdabot> Couldn't find qualified module.
10:22:35 <roconnor> > concat [1]:[2,3]:undefined
10:22:38 <lambdabot>       No instance for (Num [a])
10:22:38 <lambdabot>        arising from the literal `1' at <inter...
10:22:39 <quicksilver> conal: I still have some minor leaks but they're two orders of magnitude slower and I don't have the energy to chase them right now.
10:22:49 <Megzlna> int-e: What's the use for :< ?
10:22:49 <thomashartman1> one thing they might have that comes to my mind is a good knowledge base on using haskell with odbc (everything's on windows)
10:22:50 <salty-horse> dons, nm. I'll just email Bram with a fix, then. btw, I found it by reading the *unadvertised* example code for RWH :)
10:22:54 <Megzlna> looks sad
10:22:57 <quicksilver> conal: I have made notes on most of what I've done.
10:23:01 <roconnor> > concat ([1]:[2,3]:undefined)
10:23:04 <lambdabot>   [1,2,3* Exception: Prelude.undefined
10:23:07 <conal> quicksilver: great!  willing to share?
10:24:12 <int-e> Megzlna: for a Data.Sequence.Seq value xs, you can use  case viewr xs of xs' :> x -> ...
10:24:24 <conal> quicksilver: i'd also love to hear how you figured out where to look and what to try.
10:24:41 <int-e> Megzlna: and case viewl xs of x :< xs' -> ...
10:25:18 <Megzlna> int-e: just so you can have symmetrical cases?
10:25:18 <int-e> Megzlna: which will do pretty much what you asked for, except for Data.Sequence.Seq instead of lists.
10:25:25 <Megzlna> oh
10:25:40 <mauke> @pl handleOnce r h = mfix (\d -> handle r (\e -> d >> h e)) >> def
10:25:41 <lambdabot> handleOnce = flip flip def . (((>>) . mfix) .) . (. flip ((.) . (>>))) . (.) . handle
10:25:54 <dons> salty-horse: hm. didn't we announce the code?
10:26:06 <dons> it was all over twitter earlier this week.
10:26:21 <salty-horse> dons, well, not in the blog :)
10:26:34 <dons> ah
10:27:17 <roconnor> mauke: does that typecheck?
10:27:29 <roconnor> @type \r h -> mfix (\d -> handle r (\e -> d >> h e)) >> def
10:27:31 <lambdabot> Not in scope: `def'
10:27:32 <mauke> roconnor: sure
10:27:38 <roconnor> @type \def r h -> mfix (\d -> handle r (\e -> d >> h e)) >> def
10:27:40 <lambdabot> forall e ex (m :: * -> *) b b1. (ArrowError ex (->), Monad m) => (e -> b1) -> (e -> m b) -> ((e, ex) -> m b) -> e -> b1
10:28:02 <mauke> :t \r h -> mfix (\d -> ?handle r (\e -> d >> h e)) >> ?def
10:28:04 <lambdabot> forall t (m :: * -> *) t1 (m1 :: * -> *) a b b1. (?def::m b1, MonadFix m, Monad m1, ?handle::t -> (t1 -> m1 b) -> m (m1 a)) => t -> (t1 -> m1 b) -> m b1
10:28:38 <mauke> haha, when did I write this:   oops :: (Typeable a, Typeable b) => String -> a -> b -> wheee
10:29:04 <roconnor> @type mfix
10:29:06 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
10:29:25 <roconnor> mauke: oh, you have two monads
10:29:35 <mauke> no, it's all IO
10:29:46 <roconnor> then you have nested monads
10:29:53 <roconnor> ?handle::t -> (t1 -> m1 b) -> m (m1 a)
10:29:54 <lambdabot> Unknown command, try @list
10:29:58 <mauke> :t \r h -> mfix (\d -> ?handle r (\e -> d >> h e)) >> ?def :: IO ()
10:30:00 <lambdabot> forall t t1 (m :: * -> *) a b. (?handle::t -> (t1 -> m b) -> IO (m a), Monad m, ?def::IO ()) => t -> (t1 -> m b) -> IO ()
10:30:23 <roconnor> mauke: IO (m a),
10:30:26 <mauke> handle :: (Event a) => Registry -> (a -> IO ()) -> IO (IO ())
10:30:37 <roconnor> ahhhhhhhh
10:30:48 * roconnor 's head explods
10:30:55 <mauke> wat
10:31:06 <roconnor> IO (IO ())
10:31:18 <mauke> don't worry, it doesn't bite
10:31:38 <mauke> handle takes an event registry and a handler
10:31:49 <roconnor> and returns?
10:31:58 <mauke> it puts the handler into the registry and returns a removal action
10:31:59 <quicksilver> conal: yes, I plan to send some of them to the reactive list,
10:32:08 <roconnor> ah a removal action
10:32:10 <roconnor> cool
10:32:13 <quicksilver> conal: the short answer is by trying all the different kinds of heap profile out :)
10:32:49 <quicksilver> conal: anyhow I wanted to share with you my insight into the problem my implementation has with snapshot. It is worse than your implemntation in this respect, because it's harder to fix.
10:32:50 <mauke> roconnor: the original C interface for remove() takes a function pointer, but you can't compare functions in haskell
10:32:52 <roconnor> mauke: so the first the the handler does is remove itself
10:33:01 <roconnor> mauke: doesn't sound threadsafe though.
10:33:16 <roconnor> mauke: but still pretty cook
10:33:17 <roconnor> cool
10:33:19 <mauke> roconnor: so my first idea was to create artificial tags for functions and make handle return a tag (and remove :: Tag -> IO ())
10:33:34 <Megzlna> http://my.opera.com/Mathilda/albums/show.dml?id=82778
10:33:37 <mauke> but then I noticed that I had no other operations on Tags, so I could simply make remove = id
10:33:44 <roconnor> :)
10:34:44 <roconnor> don't show the IO (IO ()) to n00bs :P
10:34:56 <leimy> roconnor: don't show that to ANYONE
10:34:58 <leimy> :-)
10:35:50 <roconnor> mauke: what's up with the >> def ?
10:35:57 <sw17ch> @seen dons
10:35:57 <lambdabot> dons is in #darcs, #concatenative, #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 9m 22s ago.
10:36:13 <mauke> roconnor: http://hackage.haskell.org/packages/archive/data-default/0.2/doc/html/Data-Default.html
10:36:39 <leimy> I need to spend some time with this reactive thing
10:36:50 <leimy> looks interesting as all heck.
10:37:14 <conal> quicksilver: i'd like to hear about your insight.
10:37:14 <roconnor> mauke: still seems strange
10:37:33 <mauke> roconnor: it's shorter than 'return ()' :-)
10:38:20 <roconnor> mauke: you don't want to return the removal handler?
10:38:44 <mauke> hmm, not yet
10:38:52 <roconnor> ok
10:38:53 <mauke> maybe when I need it
10:38:57 <mfp> life's unfair --- I don't see how the kibro post could be +4 despite my downvote and the HAppS tutorial is -2
10:39:38 <quicksilver> conal: you have to work back to scaffold that is actually demanding the data in io
10:40:29 <mfp> based on this evidence, it might be a good idea to begin further web framework tutorials with a "PHP sucks" statement
10:40:34 <mauke> roconnor: what do you think about http://hpaste.org/13021 ? :-)
10:41:08 <luite> mfp: where can I find this HAppS tutorial?
10:41:19 <roconnor> mfp: use http://www.reddit.com/r/haskell/ instead
10:41:19 <mfp> http://www.happstutorial.com/tutorial/home
10:41:22 <quicksilver> from that perspective their is mutration
10:41:43 <luite> mfp: thanks
10:42:22 <quicksilver> Reactive a -> IO (Reactive a,a)
10:43:26 <quicksilver> it is returninh the aged version. you need that to GC the past
10:46:45 <redditbot> Kibro on shared hosting
10:46:57 <quicksilver> and, in particular, my interface for Event is "nonblockingGetOccurrence :: IO (Maybe (a,Event a))"
10:47:14 <quicksilver> that means that, in the event of a non-occurence, you don't get the aged event!
10:47:36 <quicksilver> so any calculations which are carried out to conclude non-occurrence are wasted, and will be carried out again next time you ask.
10:47:42 <quicksilver> that's a waste of space AND time.
10:48:44 <conal> quicksilver: oops!
10:49:16 <quicksilver> I'm not suggesting this is insoluble, but it's certainly a bit of an impedance mismatch with the primitives I chose.
10:49:26 <conal> yeah
10:49:36 <quicksilver> there is a hack I use tho: convert that even to an Event (Maybe a)
10:49:46 <quicksilver> and use some mechanism to ensure a fairly steady stream of Nothings
10:49:54 <quicksilver> they don't do any harm, and they keep things aging nicely :)
10:50:12 <conal> quicksilver: sigh.  i've done that one in the past also.
10:50:23 <mmorrow> fixed, by a whole bunch of Nothing!
10:50:29 <conal> :)
10:50:32 <quicksilver> mmorrow: precisement.
10:50:37 <quicksilver> mmorrow: meticulously timed Nothing.
10:51:04 <mauke> o/` nothing going on, nothing going on, I got a whole lot of nothing, nothing going on o/`
10:51:36 <quicksilver> conal: anyhow, my program now has a working mixture of continuous and discrete behaviours and I hope to upload it and write a letter of introduction about it to the reactive list this weekend if time permits.
10:51:54 <conal> quicksilver: that'd be great.
10:52:30 <quicksilver> it runs at 60fps on about 50% CPU time and uses about 25M of memory, leaking about 1M every few minutes.
10:52:36 <quicksilver> not great, but usable :)
10:52:38 <conal> those nothings impose a painful tradeoff between machine burden and responsiveness (low latency).  this time i was determined to get minimal response latency and minimal compute burden during non-activity.
10:52:47 <conal> quicksilver: yeah.  not bad.
10:55:28 <erikc> hrm, i assume cause i cant find anything in the docs, that there is no way to get the type of an Exp in TH?
11:02:05 <saml> @hoogle dlopen
11:02:06 <lambdabot> No results found
11:03:06 * mauke swears
11:03:28 <mauke> looks like I'll have to FFI the C socket api myself
11:04:32 <erikc> woo grunt work
11:05:34 <Megzlna> I was tracing the recursion of  take 3 (repeat 5)
11:05:39 <Megzlna> to see how Lazy eval works.
11:05:48 <Megzlna> Is this right?
11:05:49 <Megzlna> http://hpaste.org/13022
11:06:05 <vixey> yes except you need more ()'s
11:06:11 <Megzlna> wheree
11:06:19 <vixey> > take 3 (repeat 5)
11:06:21 <lambdabot>   [5,5,5]
11:06:24 <vixey> > take 3 5:(repeat 5)
11:06:25 <lambdabot>       No instance for (Num [a])
11:06:25 <lambdabot>        arising from the literal `5' at <inter...
11:06:32 <vixey> > 5:take 2 (repeat 5)
11:06:33 <lambdabot>   [5,5,5]
11:06:38 <vixey> > 5:take 2 5:(repeat 5)
11:06:39 <lambdabot>       No instance for (Num [a])
11:06:39 <lambdabot>        arising from the literal `5' at <inter...
11:06:41 <orbitz> take 5
11:06:49 <Megzlna> > take 3 (5:(repeat 5))
11:06:51 <lambdabot>   [5,5,5]
11:07:04 <vixey> > take 3 (5:repeat 5)
11:07:05 <lambdabot>   [5,5,5]
11:07:18 <Megzlna> so remove the inner () ?
11:07:54 <Megzlna> http://hpaste.org/13023
11:08:02 <saml> I want to do this:   import CoolDynamicFFI;   L = load("libMyCLib.so");   L.print.type = ["const char*"];  L.print "hello world"  and it marshalls [Char] to const char* and calls my C print function
11:08:29 <Megzlna> > take 3 (5:repeat 5)
11:08:31 <lambdabot>   [5,5,5]
11:08:43 <vixey> saml, use lisp
11:08:58 <mauke> saml: why use runtime loading if you want to bind it to a global symbol?
11:10:17 <dons> saml, you could use ghc-api
11:11:03 <jsn> so, type inference in system F is undecidable, according to wikipedia
11:11:19 <jsn> but GHC uses System F with some extensions?
11:11:52 <dons> even more undecidable extensions, yes :)
11:11:56 <vixey> jsn, have you used ST?
11:12:14 <jsn> vixey: not beyond the elementary tutorials, no
11:13:00 <jsn> dons: so we are just lucky when our program compiles?
11:13:17 <dons> hm.. no. it isn't like it is non-deterministic
11:13:25 <dons> when you fall in the holes, it is obvious.
11:13:38 <roconnor> haskell is not system F
11:13:39 <chrisdone> there's usually an error like “this is undecidable”, IIRC
11:13:40 <vixey> haskell isn't based on System F
11:13:56 <dons> and ghc requires type annotations anyway, for some undeciable things, so we don't fall in so many
11:14:04 <jsn> ah
11:14:09 <jsn> okay
11:14:30 <dons> if you think about the typical program in haskell, it is full of explicit type informationn
11:14:31 <edwardk> heh lambdabot needs a twitter interface ;)
11:14:37 <jsn> dons: yes
11:14:49 <sw17ch> is there a list shuffling function anywhere?
11:15:13 <roconnor> GHC uses system F internally, but I presume by that time all the types are already there.
11:15:19 <jsn> i mean, i haven't had any trouble or anything, in the past ~year of using haskell regularly
11:15:47 <jsn> roconnor: so haskell's restrictions act as a filter of a kind?
11:16:15 <roconnor> I understand that type inference is decidable in Haskell 98
11:16:44 <roconnor> for a suitable definition of type inference
11:17:08 <roconnor> I mean, obviously show . read doesn't work by itself
11:17:34 <roconnor> but I don't think I'd call that a type inferernce problem
11:20:22 <Megzlna> Is there basically a whole replacement for the Prelude for when working on Data.Sequence ?
11:21:03 <vixey> :t show . read
11:21:04 <lambdabot> String -> String
11:21:21 <mmorrow> it'd be great if you could maps "x:xs"-ish pattern matching onto ByteString or Sequence or whatever stuff
11:21:25 <mmorrow> (the syntax)
11:21:30 <orbitz> show $ read "hi"
11:21:34 <orbitz> > show $ read "hi"
11:21:35 <lambdabot>   "* Exception: Prelude.read: no parse
11:21:42 <orbitz> > show $ read ""
11:21:43 <Megzlna> This is a big problem with Haskell! The fact that you need algorithms for each data type
11:21:44 <lambdabot>   "* Exception: Prelude.read: no parse
11:21:48 <Megzlna> lack of genericism
11:21:59 <vixey> Megzlna, this is what datatypes *are*
11:22:11 <Megzlna> [ ] should have been an iterator concept interface for whatever container
11:22:18 <mdmkolbe> Off-topic, but does anyone know if the problem of finding the shortest path that visits every edge at least once has a tractable solution?
11:22:18 <orbitz> datatypes are algorithms
11:22:18 <mmorrow> like "x:xs" ===> s | (not . B.null) s = let x = unsafeHead s; xs = unsafeTail s in ...
11:22:18 <lucca> Megzlna: so use classes
11:22:19 <mdmkolbe> ** each edge of a graph
11:22:40 <roconnor> is Megzlna talking about the lack of generic programming in Haskell?
11:22:45 <vixey> hameltonian cycle?
11:23:21 <mmorrow> you could do that with a QuasiQuoter /if/ the TH ast Pat type included pattern guards (or view patterns)..
11:23:22 <mdmkolbe> vixey: hameltonian cycle I think visited each *vertex* once.  I need each edge
11:23:31 <vixey> oh right
11:23:33 <Megzlna> However, when we're talking about IO based containers that use contiguous memory chunks and literal lengths, the exact same Prelude functions should be able to work on those, or any container which implements the [ ] interface -- any other design is an error
11:23:40 <vixey> no I haven't heard of this
11:24:02 <vixey> Megzlna, sounds like OO
11:24:05 <Megzlna> it's not OO
11:24:13 <vixey> Megzlna, sounds very much like OO..
11:24:16 <Megzlna> it's just genericism
11:24:19 <orbitz> what is the [] interface?
11:24:31 <Megzlna> a typeclass
11:24:39 <mmorrow> yuk
11:24:47 <orbitz> [] is a typeclass? i thought ti was a type constructor...
11:24:52 <mmorrow> i'd rather just translate the syntax
11:24:52 <mdmkolbe> The Euerian path problem would be the same except there you can visit edges only once, in my case you can visit edges more than once, you just want to minimize the number of re-visits
11:24:54 <Megzlna> You only say Yuck cause Haskell screwed it up
11:25:08 <mmorrow> i say yuk because i don't like type classes particularly :)
11:25:15 <vixey> Megzlna, haskell screwed up the numbers
11:25:15 <orbitz> Megzlna: can you give a specific example of the problem you are referring to? I'm nto following
11:25:17 <Megzlna> orbitz: Obviously I'm not saying [] is a typeclass
11:25:24 <mmorrow> (except Monad, Functor, and those guys..)
11:25:31 <mikiael> hi
11:25:31 <vixey> Megzlna, stuff like  average list = sum list / length list
11:25:33 <orbitz> Megzlna: oh, that is what it looked liek to me
11:25:50 <mikiael> hum
11:25:56 <vixey> hi
11:26:03 <mikiael> is there any french channel for haskell please?
11:26:08 <mmorrow> i'm saying my preferred solution to that would be to map the syntax somehow to the corresponding operations for a particular type
11:26:21 <Megzlna> orbitz: The point here is that algorithms aren't generic! They don't work on whatever is of typeclass "Idx" or whatever which utilizes [] .. instead, the Prelude is all hard coded for [] lists, which is an oversight
11:26:42 <vixey> you can have
11:26:46 <roconnor> <Megzlna> However, when we're talking about IO based containers that use contiguous memory chunks and literal lengths, the exact same Prelude functions should be able to work on those, or any container which implements the [ ] interface -- any other design is an error
11:26:53 <vixey> view :: List a => a -> a ::: a
11:26:58 <vixey> oops
11:27:01 <lispy> Megzlna: and yet no one uses the libraries that make this generic, see Edison
11:27:03 <roconnor> Megzlna: Haskell knows nothing about contiguous memory and literal lengths
11:27:05 <saml> @djinn (a -> b) -> c -> b
11:27:06 <lambdabot> -- f cannot be realized.
11:27:06 <vixey> view :: List x => x a -> a ::: x a
11:27:19 <Megzlna> Sure vixey you can do it on your own and your own typeclass for it
11:27:24 <roconnor> Megzlna: how [] is implemented is upto the implementor
11:27:25 <Megzlna> but Prelude does not work generically
11:27:31 <vixey> Megzlna, there's two reasons nobody does this
11:27:36 <Megzlna> roconner: Of course, I was proposing a change
11:27:38 <vixey> Megzlna, oh Prelude isn't that good
11:27:42 <Megzlna> and saying Haskell is flawed
11:27:53 <Megzlna> I was saying [] should be used on anything of typeclass Idx
11:27:56 <vixey> Megzlna, almost all my code starts with  import qualified Prelude (i.e. hides the whole thing)
11:28:47 <vixey> the main purpose of prelude is to stun people with one liners so they learn haskell :p
11:28:50 <Megzlna> roconner:  Haskell doesn't have to know anything about contiguous memory or literal lengths
11:28:59 <Megzlna> it only has to know you provided an Idx instance
11:29:08 <mauke> Megzlna: what does Idx look like?
11:29:13 <mmorrow> Megzlna: bear in mind that pattern matching is _syntactic_, so no typeclass can enable you to pattern match with list syntax
11:29:34 <mauke> mmorrow: hey, it worked with numbers
11:29:45 <vixey> it didn't work with numbers :/
11:29:50 <vixey> that's the worst part of haskell
11:29:53 <mmorrow> totally, but it would have to be worked into the compiler
11:29:57 <Megzlna> Those syntactic extensions can be provided by your generic container -- indexable wires into the pattern matching system
11:30:17 <lispy> Megzlna: how do you index an infinite stream?
11:30:22 <jberg-> hmm, i sort of like a guard in a list comprehension.. like if n - x < 0 then tail xs
11:30:23 <vixey> Megzlna, you've invented view patterns...
11:30:27 <mmorrow> Megzlna: sure, if TH had a slightly extended Pat ast datatype we could do it for ourselves :)
11:30:28 <jberg-> is that possible?
11:30:44 <vixey> jberg-, yes
11:30:45 <lispy> ?quote lispy.infinite
11:30:46 <lambdabot> No quotes match. My mind is going. I can feel it.
11:30:53 <lispy> ?quote lispy.*infinite
11:30:54 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
11:30:54 <jberg-> vixey, how?
11:30:59 <lispy> ?quote lispy infinite
11:30:59 <lambdabot> lispy says: one thing that's funny about programming in haskell is, it's the only language i know where i sometimes rewrite code so it will work on 'infinite' datastructures
11:31:11 <Megzlna> lispy: That's why you have a difference between input ranges, output ranges, bidirectional ranges, random access ranges, and contiguous (move semantics) ranges, each which provide the functionality of the previous
11:31:13 <Megzlna> it's a chain
11:31:23 <Megzlna> sorry, it's:
11:31:33 <mauke> you sound like a C++ programmer
11:31:41 <orbitz> he is
11:31:54 <saml> @djinn (t1 -> t2) -> (t -> t1) -> t -> t2
11:31:54 <lambdabot> f a b c = a (b c)
11:32:01 <Megzlna> (input range, output range)  ,  (forward range, bidirectional range, random access, contiguous[move])
11:32:05 <mauke> that makes all his arguments invalid
11:32:07 <lispy> Megzlna: whats an output range?
11:32:08 <Megzlna> No, C++ didn't have contiguous
11:32:28 <Megzlna> nor does it have ranges
11:32:31 <Megzlna> they use iterators
11:32:45 <lispy> Megzlna: sounds like you want zippers not lists
11:32:55 <Megzlna> And it does not make the argument invalid because that hierarchy is the perfect hierarchy
11:33:03 <mauke> haha
11:33:06 <mmorrow> hehe
11:33:12 <lispy> oh boy
11:33:13 <orbitz> perfect?
11:33:14 <mauke> lispy: he wants a tower of sequences
11:33:15 <lispy> I'm going back to work
11:33:18 <saml> marshall f converter a = f (converter a) ..    can I implement   marshall f a = ... ?
11:33:26 <Megzlna> perfect in that there's no other way to arrange it
11:33:37 <Megzlna> it's option A .. there's no option B
11:33:40 <orbitz> wha tif you just dont' have it?
11:33:43 <Megzlna> for indexable ranges
11:33:48 <mmorrow> assuming you choose option A to begin with ...
11:33:51 <mauke> lists aren't really indexable
11:33:52 <saml> or marshall f a = f (converter a)      can I implement that converter function?
11:34:03 <jberg-> can someone please tell me how i can add "guards" to list comprehensions?
11:34:09 <Megzlna> mauke: Lists in Haskell are Forward Ranges
11:34:22 <saml> @djinn a -> b
11:34:22 <lambdabot> -- f cannot be realized.
11:34:30 <saml> nooooooooooooooooooooooooo!
11:34:49 <erikc> hrm, is there something in System for a portable newline (\n vs \r\n)?
11:34:54 <mmorrow> , [ (x,y) | x <- [0..9], y <- [0..], x < 4 || 7 < x, y `elem` [0,42,1029,3]]
11:34:55 <mauke> erikc: yes, \n
11:35:01 <lunabot>  Killed.
11:35:07 <rgr_> I have xmobar installed but it does not show up in "ghc-pkg list". So how can I query the version? Should it appear in that list?
11:35:07 <mmorrow> , [ (x,y) | x <- [0..9], y <- [0..], x < 4 || 7 < x, y == 3]
11:35:14 <lunabot>  Killed.
11:35:16 <mmorrow> um
11:35:23 <mmorrow> , [ (x,y) | x <- [0..9], y <- [0..], x < 4]
11:35:24 <lunabot>  [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10),(0,11...
11:35:27 <vixey> , [ (x,y) | x <- [0..9], y <- [0..], x < 4 || 7 < x, y == 3]
11:35:28 <Megzlna> lispy: an output range is something you can push values into forever
11:35:29 <erikc> mauke: hrm, can you give an example?
11:35:33 <Megzlna> it's the output part of IO
11:35:34 <lunabot>  Killed.
11:35:34 <cajun-rat> when does \n get turned into \r\n?
11:35:39 <mauke> erikc: putStr "Hello, world!\n"
11:35:41 <mauke> cajun-rat: never
11:35:44 <vixey> > [ (x,y) | y <- [0..], x <- [0..9], x < 4 || 7 < x, y == 3]
11:35:46 <dons> JaffaCake: talking about pinned arrays would be good on the ghc blog
11:35:59 <lambdabot>   thread killed
11:36:02 <baaba> it has to check every member in the list
11:36:02 <baaba> duh
11:36:06 <erikc> oh...should i never see \r's then?
11:36:14 <mauke> erikc: huh?
11:36:18 <baaba> the information that the list is in fact the list of natural numbers isn't actually present
11:36:20 <jberg-> thanks
11:36:21 <mmorrow> vixey: hmm, i'm missing why that's not giving any results
11:36:33 <baaba> the list comprehension can't know that there won't be any more 3s
11:36:35 * vixey too
11:36:46 <vixey> > take 1 [ (x,y) | y <- [0..], x <- [0..9], x < 4 || 7 < x, y == 3]
11:36:48 <lambdabot>   [(0,3)]
11:36:48 <Megzlna> lispy: for an infinite stream, you use an input range...
11:36:50 <vixey> > take 3 [ (x,y) | y <- [0..], x <- [0..9], x < 4 || 7 < x, y == 3]
11:36:52 <lambdabot>   [(0,3),(1,3),(2,3)]
11:36:54 <vixey> > take 5 [ (x,y) | y <- [0..], x <- [0..9], x < 4 || 7 < x, y == 3]
11:36:56 <lambdabot>   [(0,3),(1,3),(2,3),(3,3),(8,3)]
11:37:01 <vixey> > take 10 [ (x,y) | y <- [0..], x <- [0..9], x < 4 || 7 < x, y == 3]
11:37:03 <mmorrow> ohhh
11:37:06 <erikc> mauke: i have a quasiquote for perl/ruby-style heredocs which can be multiline strings, on windows, those strings get passed to the TH with \r\n's
11:37:13 <mauke> erikc: no
11:37:17 <lambdabot>   thread killed
11:37:17 <vixey> *booooooom*
11:37:34 <mauke> erikc: they might get passed with CRLF, but never \r\n
11:37:43 <devragert> can you define a data type within ghci?
11:37:46 <erikc> maybe this is a bug with quasiquoting then
11:37:53 <erikc> cause they get \r\n :)
11:37:59 <mauke> no, it's a bug in your thinking
11:38:09 <mmorrow> erikc: yuk, you could always  filter (/='\r')
11:38:14 <erikc> mmorrow: yea, im going too
11:38:30 <jberg-> but how are they applied?
11:38:34 <Megzlna> So what are you guys advocating exactly? Write different algorithms for every single container type? Don't even try to have a unified Typeclass for container interfacing, simply because Haskell 98 forgot that?
11:38:39 * mmorrow gets a sick pleasure out of killing '\r's
11:38:45 <vixey> Megzlna, yes
11:38:57 <Megzlna> that's highly unacceptable
11:39:02 <erikc> mauke: http://hpaste.org/13024, test passes
11:39:06 <vixey> Megzlna, you don't have to accept it hahaha
11:39:14 <jberg-> say i want [x | x <- lst, n - x < 0, tail xs] i want to do tail xs if n - x < 0
11:39:17 <Megzlna> well it's beneath my standards
11:39:18 <mauke> \n is the portable newline abstraction for your platform, so what you get is "\13\10" (undecoded)
11:39:30 <Megzlna> because the solution is easy.
11:39:36 <mauke> erikc: you're abusing \r and \n
11:39:47 <vixey> Megzlna, I'm not stopping you implementing the solution, but I know I am not going to use it
11:40:26 <Megzlna> I don't want to have to veer away from libraries/base
11:40:43 <cajun-rat> oh right, so length "\n" == 2?
11:40:49 <cajun-rat> (on windows)
11:40:54 <daf> er
11:41:00 <daf> does \n get resolved at compile time?
11:41:02 <u_quark> s  eikona
11:41:07 <mauke> cajun-rat: no
11:41:15 <mauke> \n is a single character
11:41:54 <Megzlna> I don't see how this is any different from 'Eq' or 'Ord'
11:41:58 <vixey> mmorrow, I can prove for every valid parse there's a shunting yard execution .. but that's useless.. I need for every shunting yard execution there's a valid parse (or an unparseable string)
11:42:15 <vixey> Megzlna, just write the code then
11:42:38 <Megzlna> hijack what operator?
11:42:49 <Megzlna> x:xs only works on lists
11:42:54 <vixey> data a ::: b = Nil | a ::: b
11:44:48 <devragert> why does this not work:
11:44:50 <devragert> MyDouble = MyDouble Double
11:44:52 <devragert> instance Num MyDouble where
11:44:54 <devragert>   fromInteger x = MyDouble x
11:44:57 <devragert> ?
11:45:24 <devragert> data MyDouble = MyDouble Double ... etc.
11:45:38 <conal> devragert: missing "data" or "newtype" in the MyDouble type def.
11:45:42 <ziman> devragert, what does the compiler tell you?
11:45:46 <conal> oh -- nm
11:45:52 <erikc> mauke: hrm, ok...well the string that gets passed to my quasiquote function (with the newline from the file has \r\n), so thats just something to keep in mind when writing quasiquote code in windows
11:46:07 <mauke> devragert: x :: Integer; MyDouble :: Double -> MyDouble; therefore MyDouble x is a type error
11:46:08 <devragert> mismatch double and integer, but i thought it would just be overloaded
11:46:31 <Lemmih> devragert: fromInteger x = MyDouble (fromInteger x)
11:46:45 <redditbot> The interaction between GC and arrays in GHC
11:47:40 <devragert> fromInteger x = MyDouble (fromInteger x)  , isn't that a cycle?
11:47:56 <vixey> no
11:47:57 <mauke> devragert: no, that's a different fromInteger
11:48:56 <erikc> guess thats what i get for forgetting to :set fileformat=unix in my .vimrc
11:49:18 <devragert> ah, ok, thanks
11:50:58 <vixey> "C is low level enough that it'll be easy to convert to another language should the need arise."
11:50:59 <vixey> wtf
11:51:58 <erikc> heh, whats that from
11:52:04 <vixey> http://stackoverflow.com/questions/28256/equation-expression-parser-with-precedence
11:53:04 <erikc> i dunno why i find the premise of stack overflow so revolting
11:53:44 <znutar_> I don't find it any worse than public-access television
11:53:46 <erikc> maybe its that programming shouldnt be a sort of tribal lore
11:53:46 <edwardk> i mostly stopped using it once i realized I could quadruple my karma by posting something airheaded like "What is so great about functional programming?"
11:54:04 <edwardk> erikc: i can see that
11:54:17 * vixey I am just sifting through google
11:55:57 <orbitz> what do you guys think of the argument that imperative langaugse are easier ot think in? i can see the argument, many people are used to thinking about things in terms of mutating part of it (they keep the same bookshelf but repalc ehte books), but i'm not sure that means it's more intuitive or any other word
11:57:29 <jsn> orbitz: well, sometimes i like to use the maybe monad with do
11:57:39 <jsn> it seems simpler that way
11:57:47 <mauke> orbitz: I think it's all a matter of what you're used to
11:58:30 <mauke> for example, I usually find myself unable to clearly think in OCaml after not using it for a while, only Haskell
11:58:53 <orbitz> mauke: do you stick mostly to programming in haskell these days?
11:58:58 <mauke> I get confused by evaluation order, eta expansion and stuff (and I tend to forget that OCaml has while loops)
11:59:09 <mauke> orbitz: Perl, C and Haskell
12:03:48 <BMeph> orbitz: It depends on what you mean by easier. After all, if someone can go from functional thinging to imperative easier than the reverse, it suggests to me that the latter takes up more thought processing, and that the first one is easier to grasp. :)
12:08:19 <orbitz> BMeph|lunch: i was thinking more a logn the liensof someone new to programmign
12:09:47 <devragert> does anyone know how to change the standard working directory of ghci permanently?
12:10:18 <thoughtpolice> put something like ":cd <dir>" in your ~/.ghci file?
12:11:10 <devragert> i dont have a .ghci file
12:13:18 <thoughtpolice> then create it and put stuff there :)
12:14:01 <devragert> lets see whether that works
12:16:21 <devragert> yes, it works, thank you
12:17:31 <jsn> where is there a library to get, for example, the gaussian distribution
12:26:41 <mmorrow> vixey: " I need for every shunting yard execution there's a valid parse (or an unparseable string)"
12:26:52 <mmorrow> vixey: what would be the third possibility?
12:27:22 <mmorrow> or am i misunderstanding what your saying
12:27:33 <mmorrow> you're
12:27:45 <vixey> that the algorithm isn't correct
12:29:02 <mmorrow> oh
12:29:06 <mmorrow> :)
12:29:58 <orbitz> i <3 php
12:30:12 <orbitz> just spent 2 horus trying to track down a problem only to find a u should have been a U
12:31:12 <maltem> orbitz: My opinion is that data types and recursive algorithms are easier understood in a functional language
12:32:35 <_roconnor> @src foldr
12:32:35 <lambdabot> foldr f z []     = z
12:32:35 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:32:51 <orbitz> @src foldl
12:32:51 <lambdabot> foldl f z []     = z
12:32:51 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:33:10 <_roconnor> @src (++)
12:33:11 <lambdabot> []     ++ ys = ys
12:33:11 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
12:33:11 <lambdabot> -- OR
12:33:11 <lambdabot> xs ++ ys = foldr (:) ys xs
12:33:21 <maltem> orbitz: because you can "see" your data (it's just terms) and you can quite easily follow reduction (it's just term rewriting)
12:39:45 <Apocalisp> @hoogle Maybe (a, b) -> (Maybe a, Maybe b)
12:39:45 <lambdabot> No results found
12:40:48 <Apocalisp> @hoogle (Monad m) => (m a, m b) -> m (a, b)
12:40:48 <lambdabot> No results found
12:41:19 <ziman> :t liftM2 (,)
12:41:20 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
12:41:35 <ziman> :t uncurry $ liftM2 (,)
12:41:36 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
12:41:39 <Apocalisp> uncurry!
12:41:40 <Deewiant> ?ty uncurry mplus
12:41:41 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => (m a, m a) -> m a
12:41:47 <Deewiant> ?ty uncurry (<|>)
12:41:48 <lambdabot> forall (f :: * -> *) a. (Alternative f) => (f a, f a) -> f a
12:41:52 <Apocalisp> sweet, thanks
12:42:00 <BMeph> orbitz: Oh, and your bookshelf analogy sounds more like functional programming to me. Imperative programming would scrape off the ink, pulp the book, then recreate the new book from the old book's parts. Probobly including the instructions to the machines that do those tasks too, what power source they use, how much noise is too much noise, how much is not enough noise, etc... ;)
12:42:04 <Deewiant> results vary depending on monad in question
12:42:25 <BMeph> *Probably
12:44:43 <quicksilver> Megzlna: if that is a flaw, it is a flaw in the prelude, rather than the language
12:44:57 <quicksilver> Megzlna: damn, replying to a 2 huor old message, ifnore me :)
12:47:06 <mmorrow> maltem++    -- for the shellLex
12:49:07 <BMeph> quicksilver: Funny, though, sounds like Megz is re-hashing the type family argument, eh? :)
12:49:23 <maltem> mmorrow: oh I had found at least one mistake in the meantime, this is what I'm using now: http://hpaste.org/13025
12:50:10 <quicksilver> BMeph: well it's a valid discussion.
12:50:13 <Deewiant> Megzlna: see Data.Foldable and Data.Traversable for more generic versions of stuff
12:50:13 <mmorrow> maltem: awesome.
12:50:20 <quicksilver> I'm a bit bored of it but only because it's happened so often.
12:50:43 <quicksilver> some parts of the answer take quite a lot time to explain, too.
12:51:35 <Deewiant> Write an article or something about it somewhere, and just point to that? :-)
12:51:52 <quicksilver> maybe I shuld.
12:52:01 <quicksilver> The problem is that taht would take a long time ;)
12:52:16 <quicksilver> whereas explaining something piecemeal in IRC feels like it will take less time
12:52:24 <quicksilver> (although only in the short run)
12:52:32 <Deewiant> quicksilver: Writing an article is O(1), re-explaining each time is O(n) ;-)
12:52:49 <mmorrow> but then constant is large for the article
12:53:04 <mmorrow> and each time in irc is O(1) no constant
12:53:13 <mmorrow> the eternal dilemma
12:53:17 <Deewiant> heh
12:56:47 <BMeph> quicksilver: Cut -n- Paste it, it'd be a great excuse to get you blogging... ;)
12:57:00 <BMeph> (Oops, did I type that, too? ;)
12:57:40 <Saizan> quick! write a lambda
13:00:46 <mmorrow> , text . utf8enc $ "\x03bb"
13:00:48 <lunabot>  λ
13:01:48 <Spark> αβψδεφγηιξκλμνοπρστθωςχυζ
13:02:04 <mmorrow> wow, how'd you manage that ordering?
13:02:26 <Spark> dunno it just happened
13:02:29 <mmorrow> heh
13:02:40 <Spark> i have no idea what the actual ordering is
13:02:50 <mmorrow> ah, i see
13:02:59 <arussel> I defined this function: mypp [a] n = mypp (tail [a]) (n-1)
13:03:10 <arussel> with: mypp (x:xs) 0 = x
13:03:45 <arussel> I don't understand mypp [3,3,3,3,3] 1 gives me an error when mypp [3,3,3,3] 0 doesn't
13:04:00 <mmorrow> , text . utf8enc . take 25 $ ['α'..]
13:04:02 <lunabot>  αβγδεζηθικλμνξοπρςστυφχψω
13:04:31 <Lemmih> arussel: is mypp defined as: mypp _ 0 = ... ?
13:04:59 <Lemmih> arussel: Tsk, didn't see your definition.
13:05:35 <joe_b> cabal error: "Could not find module `Data.Generics':       it is a member of package base-3.0.3.0, which is hidden"
13:05:56 <Lemmih> arussel: '[a]' is wrong. You just want 'a'.
13:06:19 <joe_b> how do i get my library to find base-3... even though its hidden?
13:06:34 <quicksilver> BMeph: don't like the idea of blogging.
13:06:41 <Lemmih> joe_b: Data.Generics is also in 'syb', iirc.
13:06:46 <quicksilver> BMeph: I might write something wrong, and people would make smarmy comments ;P
13:06:58 <arussel> Lemmih: got it, thanks for your help
13:07:05 <joe_b> Lemmih: syb?
13:07:12 <Lemmih> joe_b: syb!
13:07:53 * mmorrow wishes now more than ever he had the hex of the interrobang memorized
13:08:19 <tyfon> , text . utf8enc . take 3 $ ['æ'..]
13:08:22 <lunabot>  æçè
13:08:26 <tyfon> hmm
13:08:37 <tyfon> i tried 'a'..'c' in ghci earlier but i didn't get a list
13:08:45 <tyfon> maybe i typed something wrong
13:09:09 <mmorrow> tyfon: ah, ever since ghci recently switched to editline entering unicode into ghci has become impossible
13:09:24 <mmorrow> editline--
13:09:38 <gp> I have come to the conclusion that functional programming just is better. I t is not just incrementally better or better at some things. Functional programming is better in every single way!
13:09:40 <tyfon> oh.. so it should work if i compile it?
13:09:46 <mmorrow> tyfon: yes
13:09:49 <tyfon> cool :)
13:10:02 <tyfon> it seems a bit counter-intuitive that i couln't generate a list of chars
13:10:06 <tyfon> seemed*
13:10:30 <mmorrow> you can always specify em numerically too
13:10:40 <mmorrow> , 'æ'
13:10:42 <lunabot>  '\230'
13:10:49 <BMeph> quicksilver: Well, sure they would, why should you have all the fun? ;p
13:10:51 <tyfon> oh
13:10:52 <mmorrow> , utf8enc "\230"
13:10:54 <lunabot>  "\195\166"
13:11:01 <mmorrow> , text . utf8enc $ "\230"
13:11:04 <lunabot>  æ
13:11:09 <tyfon> cool :)
13:11:12 <quicksilver> BMeph: well, I have right not to write a blog ;)
13:11:42 <mmorrow> , showHex 230
13:11:44 <lunabot>  luna: No instance for (GHC.Show.Show
13:11:47 <mmorrow> , showHex 230 []
13:11:49 <lunabot>  "e6"
13:11:56 <mmorrow> , text . utf8enc $ "\xe6"
13:11:59 <lunabot>  æ
13:12:53 <BMeph> quicksilver: You cannot stay on the -cafe list forever; resistance is futile. Your individuality will enhance the power of the Blog. ;)
13:14:53 <athos> ho
13:15:22 <_roconnor> @wiki IO_Semantics
13:15:23 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics
13:15:49 <roconnor> who is http://www.kroesen.net/ ?
13:16:45 <roconnor> @whois www.kroesen.net
13:16:45 <lambdabot> Unknown command, try @list
13:16:49 <roconnor> damn
13:16:51 <roconnor> :)
13:18:33 <mmorrow> @kroesen
13:18:33 <lambdabot> Unknown command, try @list
13:18:37 <mmorrow> @nixon
13:18:37 <lambdabot> You won't have Nixon to kick around anymore, because, gentlemen, this is my last press conference.
13:18:46 <mmorrow> @nixon
13:18:47 <lambdabot> Any lady who is first lady likes being first lady. I don't care what they say, they like it.
13:18:48 <vixey> @noxon
13:18:48 <lambdabot> A man is not finished when he is defeated. He is finished when he quits.
13:19:06 <mmorrow> @noxonomicron
13:19:07 <lambdabot> Unknown command, try @list
13:19:11 <sjanssen> @. elite nixon
13:19:12 <lambdabot> tHi5 I5 4 9reA7 day F0R phR4Nc3!
13:19:20 <mmorrow> lol
13:19:35 <vixey> @. elite nixon
13:19:35 <lambdabot> t|-|e PResz i5 tHE En3My.
13:19:41 <vixey> @. elite nixon
13:19:41 <lambdabot> V0TeRz quI(klY phoRGeT \/\/H4t A Man saYs.
13:19:42 <sjanssen> yes!
13:19:51 <mmorrow> @. vixen elite nixon
13:19:52 <lambdabot> so, what made you want to message me?
13:19:58 <vixey> @. elite elite nixon
13:19:58 <lambdabot> NIxoN
13:20:01 <vixey> lol
13:20:04 <mmorrow> haha
13:20:21 <sjanssen> @. elite . elite nixon
13:20:22 <lambdabot> ipH yOu 7|-|Inx 7H3 uNI73d 574+3S ha$ 57ood s7I11, wh0 8UI1T 7|-|3 l4rg3z7 sH0PPInG CEn+3R In 7|-|3 w0rlD?
13:20:25 <mmorrow> ah
13:20:29 <joe_b> im trying to build a library that depends on Data.Generics (which can be found in base-3... and syb-...; both installed) but i get this error: "Could not find module `Data.Generics':       it is a member of package base-3.0.3.0, which is hidden"
13:20:33 <joe_b> anyone have ideas?
13:20:34 <mmorrow> @. vixen . elite nixon
13:20:35 <sjanssen> @. elite . elite . elite . elite nixon
13:20:35 <lambdabot> have you ever scubadived?
13:20:35 <lambdabot> PE0p|3 r34(7 +O F34r, n0t |0\/3; T|-|3Y D0n'+ 734c|-| 7|-|47 in ZunDaY 5C|-|o0|, 8U+ i+'s +rU3.
13:20:57 <quicksilver> joe_b: the package you're trying to build has its dependencies wrong.
13:21:09 <nolrai_East> @pl spark a b = forkIO a >> forkIO b
13:21:09 <lambdabot> spark = (. forkIO) . (>>) . forkIO
13:21:16 <mmorrow> @. remember . elite . elite . elite . elite nixon
13:21:16 <lambdabot> Okay.
13:21:23 <joe_b> so i need to modify 'library'.cabal?
13:21:27 <mmorrow> heh, we'll never know
13:21:31 <quicksilver> joe_b: It either needs to use base 3, or base 4 and syb
13:21:34 <quicksilver> yeah.
13:21:52 <mmorrow> @quote |\/0
13:21:52 <lambdabot> NormanRamsey says: Type annotations in OCaml are completely broken and always have been.
13:22:01 <mmorrow> @quote E0
13:22:01 <lambdabot> desrt says: man... there's this whole dark side to haskell that dr. kahl didn't teach us in 3e03
13:22:11 <BMeph> Wut? no "tEH En3My"? Wut! ;p
13:22:40 <mmorrow> @elite all yore base are belong to m3
13:22:40 <lambdabot> aLL YOre ba$3 arE be10ng To M3
13:22:58 <joe_b> quicksilver: awesome, that got me passed that error ... to another :P
13:23:10 <vixey> @zippy
13:23:10 <lambdabot> Unknown command, try @list
13:23:14 <vixey> @yow
13:23:14 <lambdabot> if it GLISTENS, gobble it!!
13:23:18 <vixey> @. elite yow
13:23:18 <lambdabot> I'D like my dAt4-BasE JUlIeNnED 4ND S+Ir-FrIeD!
13:23:21 <vixey> @. elite yow
13:23:22 <lambdabot> sOmEwH3Re iN +EN4f1y, N3W JersEY, 4 cHIROpr4(TOr Is VIE\/\/iN9 "LE4vE I7 t0 8eA\/Er"!
13:24:26 <mmorrow> we need some higher order plugins so we can pipe in @nixon, @yow, and zip that thing with @elite
13:24:40 <vixey> @@ (@show @yow)
13:24:40 <lambdabot>  "CHUBBY CHECKER just had a CHICKEN SANDWICH in downtown DULUTH!\n"
13:24:52 <vixey> @@ (@show @yow) ++ (@show @nixon)
13:24:53 <lambdabot>  "My NOSE is NUMB!\n" ++ "The second point is that coming out--coming back and saying that black Americans aren't as good as black Africans--most of them , basically, are just out of the trees.  Now,
13:24:53 <lambdabot>  let's face it, they are."
13:24:56 <mmorrow> whoa
13:25:05 <vixey> @@ @run fst ( (@show @yow) , (@show @nixon) )
13:25:06 <lambdabot>   "I'm also against BODY-SURFING!!\n"
13:25:11 <vixey> @@ @run snd ( (@show @yow) , (@show @nixon) )
13:25:13 <lambdabot>   "I've never canceled a subscription to a newspaper because of bad cartoons ...
13:25:24 <mmorrow> is there any TFM for this syntax
13:25:26 <mmorrow> ?
13:25:41 <mmorrow> (manual)
13:25:43 * vixey is presenting a typed lambda calculus with products and funny quotes
13:25:44 <vixey> :P
13:26:18 <mmorrow> delightful
13:26:34 <FunctorSalad> @(@fortune,@fortune)
13:26:35 <lambdabot> Unknown command, try @list
13:26:39 <FunctorSalad> :(
13:26:47 <athos> @list
13:26:48 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
13:26:52 <athos> :(
13:26:55 <mmorrow> oh, i just "saw" how it works
13:27:17 <orbitz> @bf
13:27:17 <lambdabot>  Done.
13:27:20 <orbitz> @bf hi
13:27:20 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
13:27:29 <nolrai_East> @@ @elite "I am elite"
13:27:29 <lambdabot>  "i a/\/\ 1337"
13:27:36 <FunctorSalad> in my defense, I hadn't seen vixey's demonstration above
13:27:55 <orbitz> @vixen
13:27:55 <lambdabot> Do you think you would pass a Turing test?  I have.
13:28:02 <orbitz> @vixen oh have you?
13:28:03 <lambdabot> understand now?
13:28:04 <mmorrow> @@ @run (\x -> @run (@show x)) 42
13:28:06 <lambdabot>   <no location info>: parse error on input `<'
13:28:13 <orbitz> @listchans
13:28:13 <lambdabot> ##freebsd ##hrg ##logic #arch-haskell #concatenative #darcs #dreamlinux-es #friendly-coders #gentoo-haskell #gentoo-uy #ghc #haskell #haskell-overflow #haskell.hr #haskell.jp #haskell.no #haskell.se
13:28:13 <lambdabot> #haskell_ru #jhc #jtiger #macosxdev #perl6 #rosettacode #scala #scannedinavian #unicycling #xmonad
13:28:18 <mmorrow> @@ @run (@show 42)
13:28:19 <lambdabot>   "42"
13:28:19 <orbitz> lambdabot is hot
13:28:29 <mmorrow> @@ @run repeat (@show 42)
13:28:31 <lambdabot>   ["42","42","42","42","42","42","42","42","42","42","42","42","42","42","42"...
13:28:38 <vixey> @@ @run replicate 10 ','
13:28:40 <lambdabot>   ",,,,,,,,,,"
13:28:40 <tyfon> rofl
13:28:49 <tyfon> there is no other than me on #haskell.no and lambdabot :(
13:28:51 <vixey> @@ @run ("("++ replicate 10 ',' ++ ")")
13:28:52 <lambdabot>   "(,,,,,,,,,,)"
13:28:52 <mmorrow> @@ @run (\x -> (@show x)) (@show 42)
13:28:54 <lambdabot>   "x"
13:28:58 <mmorrow> aww
13:28:59 <vixey> @@ @run var ("("++ replicate 10 ',' ++ ")")
13:29:00 <lambdabot>       Ambiguous occurrence `var'
13:29:00 <lambdabot>      It could refer to either `Data.Number.S...
13:29:03 <vixey> @@ @run expr ("("++ replicate 10 ',' ++ ")")
13:29:04 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[Char]'
13:29:10 <vixey> @@ @run (var ("("++ replicate 10 ',' ++ ")") :: Expr)
13:29:11 <lambdabot>       Ambiguous occurrence `var'
13:29:11 <lambdabot>      It could refer to either `Data.Number.S...
13:29:15 <vixey> @@ @run (Expr.var ("("++ replicate 10 ',' ++ ")") :: Expr)
13:29:16 <lambdabot>       Failed to load interface for `Expr':
13:29:17 <lambdabot>        Use -v to see a list of the...
13:29:23 <vixey> @@ @run (Data.Number.Symbolic.var ("("++ replicate 10 ',' ++ ")") :: Expr)
13:29:24 <lambdabot>   Couldn't match expected type `Expr' against inferred type `Sym a'
13:29:30 <vixey> @@ @run (Data.Number.Symbolic.var ("("++ replicate 10 ',' ++ ")"))
13:29:32 <lambdabot>   (,,,,,,,,,,)
13:29:38 <mmorrow> nice
13:29:42 <vixey> @@ @type @run (Data.Number.Symbolic.var ("("++ replicate 10 ',' ++ ")"))
13:29:44 <lambdabot>  forall a b c d e f g h i j k. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> (a, b, c, d, e, f, g, h, i, j, k)
13:29:49 <mmorrow> @djinn!!!
13:29:50 <lambdabot> Unknown command, try @list
13:30:02 <mmorrow> @@ @djinn @type @run (Data.Number.Symbolic.var ("("++ replicate 10 ',' ++ ")"))
13:30:05 <lambdabot>  f a b c d e f g h i j k = (a, b, c, d, e, f, g, h, i, j, k)
13:30:10 <vixey> :D
13:30:13 <mmorrow> heh
13:31:07 <FunctorSalad> Data.Number.Symbolic.var?
13:31:17 <FunctorSalad> lambdabot internals?
13:31:41 <roconnor> > sin (exp(1)+1)^3 :: CReal
13:31:43 <lambdabot>   -0.16210288435959880593595447893402644161
13:31:44 <mmorrow> , [$ty| var |]
13:31:54 <roconnor> > sin ((exp(1)+1)^3) :: CReal
13:31:54 <lunabot>  String -> Expr
13:31:55 <lambdabot>   0.909495241057266247185547219452174268894
13:32:11 <FunctorSalad> ty? :o
13:32:22 <FunctorSalad> is that teh quasiquoter? :o
13:32:24 <mmorrow> , [$ty| \x -> x |]
13:32:26 <mmorrow> yeah
13:32:29 <lunabot>  forall a . a -> a
13:32:31 <mmorrow> , [$tyQ| \x -> x |]
13:32:35 <lunabot>  ForallT [a] [] (AppT (AppT ArrowT (VarT a)) (VarT a))
13:32:39 <roconnor> > sin ((exp(1)+1)^3)
13:32:40 <lambdabot>   0.9094952410572636
13:33:12 <roconnor> > exp (exp (exp (0.5)) :: CReal
13:33:14 <lambdabot>   <no location info>: parse error on input `;'
13:33:14 <FunctorSalad> that last one seems useful when writing TH functions
13:33:26 <roconnor> > exp (exp (exp 0.5)) :: CReal
13:33:27 <lambdabot>   181.3313036085456935150575745126539838088637
13:33:32 <roconnor> > exp (exp (exp 0.5))
13:33:34 <lambdabot>   181.33130360854574
13:34:19 <FunctorSalad> I've found the normal [d| ... |] mechanism not so useful because the quoted declaration has to be completely legal already...
13:34:38 <FunctorSalad> so I couldn't implement superclass defaulting, for example :(
13:35:51 <erikc> hrm, where does cabal keep its package database of whats installed?
13:36:03 <quicksilver> it's not really cabal's
13:36:05 <quicksilver> it's ghc's
13:36:10 <erikc> so package.conf?
13:36:11 <quicksilver> ghc-pkg list
13:37:08 <erikc> hrm, weird, i manually installed haskell-src-meta cause the .cabal needs tweaking, its in my ghc-pkg list, but when i cabal install my package that depends on it, cabal tries to get it from hackage and build it (failing)
13:37:27 <FunctorSalad> different versions?
13:37:31 <erikc> same version
13:39:03 <vixey> > (12::CReal) * (-6*5*4*3*2)(13591409+545140134)/(3*2*(640320**(3+3/2)))
13:39:04 <lambdabot>       No instance for (Num (t -> CReal))
13:39:04 <lambdabot>        arising from a use of `negate...
13:39:09 <vixey> > (12::CReal) * (-6*5*4*3*2)*(13591409+545140134)/(3*2*(640320**(3+3/2)))
13:39:11 <lambdabot>   -0.000000000000005981069938657074052378697
13:39:20 <mmorrow> erikc: ugh, i mostly install pkgs manually on account of that exact thing
13:39:24 <athos> :i CReal
13:39:25 <mmorrow> , ppDoc $ (\(ForallT (n:_) _ t) -> substT [(n,unQ[t|Int|])] [] t) $ [$tyQ| \x -> x |]
13:39:30 <lunabot>  Int -> Int
13:39:40 <vixey> > (12::CReal) * (13591409+545140134)/(640320**(3+3/2))
13:39:41 <lambdabot>   0.0000000000000000498422494888089504364891
13:39:51 <vixey> > (12::CReal) * (13591409+545140134)/(640320**(3/2))
13:39:53 <lambdabot>   13.0854552209875433304772632299159815057994
13:39:53 <FunctorSalad> it becomes really evil when some dependency contradicts what ghc wants :(
13:39:58 <quicksilver> erikc: difference between user and global perhaps?
13:40:30 <FunctorSalad> (I couldn't manage to build the ghc-included libraries with changed dependencies yet)
13:40:37 <erikc> i only have stuff installed global, a totally random unfounded guess is maybe something to do with base-3.0.3.0 vs base-4, but ive tried both ways
13:41:10 <FunctorSalad> I've had base-3 vs. base-4 related trouble with syb
13:41:14 <mmorrow> it seems that if you hack at least a few packages before installing them, cabal-install is unusable because you can't afford it messing with your setup
13:41:14 <quicksilver> erikc: could be a diamond dependency conflict.
13:41:42 <mmorrow> the dreaded
13:41:47 <quicksilver> A depends on B,C, which both depend on D, but B depends on the base-3 version of D and C depends on the base-4 version of D
13:41:59 <quicksilver> often 'D' is bytestring, but it could be syb,
13:42:25 <mmorrow> echo 'digraph { a -> {b,c}; {b,c} -> d }' | dot -Tpng | display
13:42:33 <JohnnyL> haskell has da bugzz0rs.
13:43:23 <quicksilver> @faq Can haskell kill the bugzz0rs?
13:43:23 <lambdabot> The answer is: Yes! Haskell can do that.
13:43:46 <FunctorSalad> mmorrow: http://graph.gafol.net/sRZetuBO :)
13:43:59 <mmorrow> FunctorSalad: heh, nice
13:46:49 <mmorrow> erikc: i'll update haskell-src-meta on hackage within a few hours.
13:48:05 <erikc> mmorrow: sweet, that'll solve it hopefully, i just have no idea why cabal thinks it needs to pull something that's already installed, and dont know how to go about debugging it
13:49:08 <FunctorSalad> erikc: you could go to ~/.cabal/packages/.../haskell-src-meta , unpack the zip, and look at the .cabal
13:49:17 <mmorrow> erikc: also, the haskell-src-exts author asked me about splitting the (haskell-src-exts->TH) and the (TH specific stuff) into two packages and i said i would. if you have a package that deps on meta, i'll keep src-meta as a pkg (and deprecate it), and upload the split packages as well. either way, i'll let you know how i end up doing it.
13:49:49 <FunctorSalad> (on my system the packages are downloaded to that directory, not sure if that's the standard)
13:50:38 <mmorrow> or hmm. i'm going to keep src-meta as a whole pkg, and upload a haskell-src-exts-th pkg which is just the src-exts -> TH translation part of src-meta.
13:50:48 <mmorrow> so src-meta will be there to stay
13:50:58 <erikc> mmorrow: k
13:51:30 <mmorrow> (and i'll update everything to use the current haskell-src-exts)
13:51:52 <JohnnyL> quicksilver see 'frag'.
13:52:01 <JohnnyL> gc and random buggzz0rrs.
13:59:14 <roconnor> @seen fej
13:59:16 <lambdabot> I haven't seen fej.
14:01:43 <Debugger> Just got my book :D
14:02:12 <ozy`> RWH?
14:02:22 <Debugger> Yes :)
14:02:30 <ozy`> cool
14:02:35 <Debugger> Pre-ordered from amazon :/
14:02:39 <Debugger> I hate delays
14:02:54 <erikc> also interesting, if i import System.Cmd in my Setup.hs, when i runhaskell it i get a 'ghci runtime linker duplicate definition for symbol _runInteractiveProcess'
14:03:23 <thoughtpolice> erikc: yeah you probably have process-1.0.1.0 and 1.0.1.1 installed (i think)
14:03:38 <thoughtpolice> erikc: upgrading process has got my quite a few issues like that
14:03:54 <thoughtpolice> because so many things link against process, if you upgrade it you pretty much need to do it right after install
14:04:18 <thoughtpolice> if you do it after e.g. 2 months of installation, lots of stuff turns out to not work so you just can't upgrade it basically :[
14:04:26 <erikc> ah
14:04:27 <thoughtpolice> at least cabal-install helps that problem a bit
14:05:19 <erikc> guess that 'cabal upgrade' i did yesterday was a bad idea heh
14:05:34 <thoughtpolice> erikc: but yeah GHCi is just loading two libraries and one of them depends on one version of process, and the other depends on the other version of process, so it loads both of the object files - the runtime linker isn't in any way idempotent, so if you load two object files that have the same symbol it will fail
14:05:46 <erikc> yea
14:06:01 <thoughtpolice> the same happens with bytestring a bit too
14:06:12 <thoughtpolice> that certainly caused me lots of dumb grief in the past
14:06:53 <thoughtpolice> erikc: yeah I would say just always do 'cabal update; cabal install ...' instead of cabal upgrade
14:07:05 <erikc> there we go, bye bye process-1.0.1.1
14:07:10 <thoughtpolice> it can very easily break lots of future code from building for things like that
14:07:17 <erikc> yea
14:07:44 <erikc> once i understand a bit better maybe ill be the one to write the 'how to deciper dependency hell' document
14:08:24 <thoughtpolice> and stuff that cabal upgrade can break (see: building any code in the future) is hard to detect
14:08:36 <thoughtpolice> and frustrating as shit to get fixed sometimes
14:13:42 <tibbe> do we have a function to encode a Char to UTF-8 anywhere in base?
14:13:49 <Deewiant> nope
14:13:54 <tibbe> meh
14:15:06 <devragert> is it possible to mutually import modules?
14:15:25 <devragert> i mean, to import A in B and B in A?
14:15:51 <vixey> why would you want to do that :(
14:16:40 <devragert> to keep things clear
14:16:45 <erikc> devragert: if you have that situation, then you really only have one module
14:16:48 <devragert> i want to seperate parts of my code
14:17:00 <devragert> hmm.. ok
14:17:45 <ciscbrain> I thought you could do that in ghc
14:17:47 <erikc> you can break the dependency by passing functions from one to the other for 'callbacks', of course
14:19:36 <devragert> yes, but the code is that much intertwined, that i would still end up with just one module
14:19:56 <devragert> but it's fine, i will just put everything in one module
14:21:49 <walski> Hi there
14:22:17 <walski> I've got something like: data Token = TokElse | TokIf | Tok Bla
14:22:21 <nolrai_East> @t maybe
14:22:22 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
14:22:37 <nolrai_East> @type maybe
14:22:39 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:22:57 <walski> and now I would like to model another datatype like this: data Expr = IfExpr TokIf Expr TokThen Expr TokElse Expr | ....
14:23:01 <walski> how can I do that?
14:23:11 <walski> How can I insert a constructor "in" a constructor
14:25:29 <osfameron> any suggestions for more efficient ways of doing this: http://hpaste.org/13027 ?
14:25:30 <baaba> why would you want to insert fixed values there?
14:25:40 <Zero_In_Mood> is there a possibility to control if a point is already into the new created list so that he wont do any recursion ?
14:26:05 <baaba> walski, why not just, data Expr = IfExpr Expr Expr Expr | ...
14:27:36 <Zero_In_Mood> ?src foldr
14:27:36 <lambdabot> foldr f z []     = z
14:27:36 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:28:45 <walski> baaba: Is there no other way than using the datatype itself?
14:29:07 <baaba> i'm not sure what you want "data Expr = IfExpr TokIf Expr TokThen Expr TokElse Expr | ...." to mean exactly
14:29:41 <baaba> what actual data would something like that contain? ie. how would you construct a value of type Expr using the IfExpr constructor
14:31:21 <walski> ah ok. you mean that the TokIf etc does not transport any data?
14:31:36 <Zero_In_Mood> ?sry abs
14:31:36 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
14:31:39 <baaba> it would be entirely redundant
14:31:44 <Zero_In_Mood> ?src abs
14:31:45 <lambdabot> Source not found.
14:32:05 <walski> baaba: Didn't thought that way :) Thanks for the hint!
14:32:20 <baaba> > data X = Y Int | Y Int Int
14:32:21 <lambdabot>   <no location info>: parse error on input `data'
14:32:47 <baaba> er, can you declare datatypes in lambdabot?
14:33:49 <Zero_In_Mood> damn is there any possibility to check if a (x,y) tupel is already into my new created list ?
14:35:13 <luite> Zero_In_Mood: elem?
14:35:29 <Zero_In_Mood> yeah but the new list aint saved alrdy..  im creating it atm
14:35:54 <Zero_In_Mood> so can i really check it with elem then ? i mean.. what i wanna do is.. he is checkin some things and in the end he should add it to my new list
14:36:22 <Zero_In_Mood> but only if it aint alrdy in it.. if it is in it then he shouldnt do any recursion n start with the next (x,y)
14:36:22 <luite> Zero_In_Mood: hm, not sure what you mean. you can remove duplicates afterwards using nub
14:36:36 <Zero_In_Mood> no.. its infinite like this ^^
14:38:34 <luite> Zero_In_Mood: how do you build or generate your list?
14:38:50 <Zero_In_Mood> with guards and recursion :)
14:39:17 <Zero_In_Mood> pretty stupid function atm im askin for every possible case cause i was too lazy to think about something lemme hpaste it
14:39:17 <orbitz> @src nub
14:39:18 <lambdabot> nub = nubBy (==)
14:39:27 <orbitz> @src nubBy
14:39:27 <lambdabot> nubBy eq []             =  []
14:39:27 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
14:39:57 <Zero_In_Mood> http://hpaste.org/13028
14:40:06 <Zero_In_Mood> the infinite things are happening in the hilfe function
14:40:22 <Zero_In_Mood> when there is somethin like (4,5),(5,5) for example in my list
14:40:26 <luite> wow that's quite a function :P
14:40:55 <Zero_In_Mood> yeah i know that there is a possibility with higher order function to get it in 5 lines.. i saw it alrdy but anyway i dont wanna copy it
14:41:20 <Zero_In_Mood> neither do i get it at all.. so i tried to correct my mistake n started to asking every possible case out.. just got the last lil problem left
14:41:46 <vixey> hilfe isn't good
14:42:03 <tromp_> > nubBy (==0.flip mod) [2..]
14:42:05 <lambdabot>   Couldn't match expected type `(a -> c) -> Bool'
14:42:07 <vixey> I would delete that one
14:42:17 <Zero_In_Mood> i know vixey is piece of crap.. neither i couldnt come up with any cool and am sick of it too so i tried it the most stupid way :)
14:42:37 <Zero_In_Mood> oh sry there is a , missing i know vixey, it is a piece of crap
14:42:41 <Zero_In_Mood> omg^^
14:43:28 <tromp_> > nubBy (\x y->y`mod`x==0) [2..]
14:43:30 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
14:43:55 <tromp_> @pl (\x y->y`mod`x==0)
14:43:56 <lambdabot> flip flip 0 . ((==) .) . flip mod
14:43:57 <Zero_In_Mood> oh nice all prime numbers hu?^^
14:44:20 <tromp_> @pl (\x y->0==y`mod`x)
14:44:21 <lambdabot> ((0 ==) .) . flip mod
14:45:23 <tromp_> now wherer does that name "nub" come from?
14:47:32 <Megzlna> what's the easiest way to do...
14:48:16 <Megzlna> let a = [222,_,333,_,111]
14:48:39 <Megzlna> something a 223 334 == [222,223,333,334,111]
14:48:54 <pumpkin> hmm?
14:49:00 <Megzlna> and with tuples and functions too, in a uniform way
14:49:08 <pumpkin> oh, you want to inject those values into an existing list?
14:49:18 <Megzlna> ya
14:49:48 <pumpkin> you could have a designated "replace me" value
14:49:52 <pumpkin> maybe a Nothing
14:50:05 <pumpkin> but in general, that 223, 334 would need to be in a list, I'd guess
14:50:23 <Megzlna> > let x = Nothing :: Int
14:50:24 <lambdabot>   <no location info>: parse error on input `;'
14:50:25 <pumpkin> assuming you wanted n replacements
14:50:30 <Megzlna> > let x = Nothing :: Int in x
14:50:32 <lambdabot>   Couldn't match expected type `Int' against inferred type `Maybe a'
14:50:45 <Raevel> > Nothing :: Maybe Int
14:50:47 <lambdabot>   Nothing
14:50:47 <Philonous> > let x = Nothing :: Maybe Int
14:50:48 <lambdabot>   <no location info>: parse error on input `;'
14:50:58 <pumpkin> parens
14:50:59 <Philonous> > let x = Nothing in x :: Maybe Int
14:51:01 <lambdabot>   Nothing
14:51:12 <Zero_In_Mood> damnit vixey so u got any idea to rewrite hilfe ?
14:51:22 <Megzlna> isnt there some pre-defined Nothing ?
14:51:22 <llayland> I the comma in (,) a function or just some sugary goodness?
14:51:26 <Megzlna> thats shorter
14:51:30 <llayland> >(,,) 1 2 3
14:51:31 <luite> Zero_In_Mood: what exactly does hilfe need to do?
14:51:31 <Megzlna> and looks like _
14:51:32 <pumpkin> llayland: it's a data constructor
14:51:37 <llayland> >(,,3) 1 2 3
14:51:58 <llayland> ah
14:52:02 <Stephan202> > (,,) 1 2 3
14:52:04 <lambdabot>   (1,2,3)
14:52:05 <Zero_In_Mood> hmm
14:52:16 <Zero_In_Mood> creating bitmaps out of the neighbours of a list
14:52:18 <Megzlna> well that doesnt work
14:52:19 <Megzlna> > (,,3) 1 2
14:52:20 <lambdabot>   <no location info>: parse error on input `3'
14:52:28 <Megzlna> and thats tuples only
14:52:30 <ehird> > 1 ,, 2
14:52:31 <lambdabot>   <no location info>: parse error on input `,'
14:52:33 <ehird> :(
14:52:48 <Zero_In_Mood> neighbours are which x == x' && abs (y-y') == 1 or y == y' && (x-x') == 1
14:53:17 <Megzlna> > [1,2,Nothing,3]
14:53:18 <lambdabot>       No instance for (Num (Maybe a))
14:53:18 <lambdabot>        arising from the literal `1' at ...
14:53:26 <erikc> megzlna: you can just do __ = Nothing if you want, but the other elements in your original list need to be constructed with Just
14:53:26 <Megzlna> > [1,2,Nothing :: Maybe Int,3]
14:53:28 <lambdabot>       No instance for (Num (Maybe Int))
14:53:28 <lambdabot>        arising from the literal `1' a...
14:53:32 <Megzlna> And that's too long
14:53:34 <erikc> [Just 1, Just 2, Nothing]
14:53:46 <Megzlna> erikc that makes the list unusable
14:54:04 <luite> Zero_In_Mood: ah, so the original tuples shouldn't be in the list? (unless they are neighbours of other tuples)
14:54:06 <chrisdone> who's wearing fingerless gloves right now?
14:54:11 <vixey> Zero_In_Mood, no
14:54:23 <vixey> Zero_In_Mood, I don't read it so I on't know what it does (or is supposed to do)
14:54:26 <Raevel> Megzlna: unusable?
14:54:32 <vixey> Zero_In_Mood, I do know that rewriting it is stage 1 though :p
14:54:35 <Megzlna> yes, I'll explain...
14:54:44 <pumpkin> "it's a pain to write Just every time"?
14:54:45 <Zero_In_Mood> well in the end every tuple need to be in the new list
14:54:46 <Megzlna> I'm writing a big nested table of Ontology stuff, of notes and such
14:55:02 <Megzlna> if I have to write "Just" its unusable
14:55:02 <Zero_In_Mood> just that neighbour tuples are getting their own bitmaps
14:55:09 <Zero_In_Mood> so that we get [Bitmap] instead on Bitmap..
14:55:19 <Zero_In_Mood> Single Tuples should be saved as a own bitmap too
14:55:25 <dons> ?users
14:55:25 <lambdabot> Maximum users seen in #haskell: 576, currently: 557 (96.7%), active: 21 (3.8%)
14:55:40 * ziman pretends activity
14:55:43 <ziman> ?users
14:55:43 <lambdabot> Maximum users seen in #haskell: 576, currently: 557 (96.7%), active: 21 (3.8%)
14:55:47 <ziman> :\
14:55:49 <Raevel> Megzlna: you could write it in a custom format, and parse it
14:55:57 <luite> Zero_In_Mood: it looks like something I'd do with some: nub . concatMap (\(x,y) -> [(x,y+1),(x+1,y),(x-1,y),(x,y-1)]) l
14:56:24 <erikc> megzlna: you can map Just across the list of known integers, but then you have to poke the Nothing's into the right spots in your list
14:56:26 <Megzlna> Raevel: Trying to avoid that because there's an elegance in the structure being the same as the one you express
14:56:44 <luite> Zero_In_Mood: nub may be too slow, so you can use a  (map head).group.sort  instead of nub
14:56:48 <Megzlna> [1,2,3,4,__,6,7]   -- possible?
14:56:55 <Megzlna> I make a typeclass for:
14:56:58 <Raevel> Megzlna: well the structure would be the same, it would just look a little different
14:57:00 <erikc> only if __ :: Num t => t
14:57:01 <Megzlna> NumOrPlaceholder
14:57:16 <Megzlna> but lists can only be of a type
14:57:18 <vixey> > let __ =__ in [1,2,3,4,__,6,7]
14:57:18 <Megzlna> not a typeclass
14:57:19 <ziman> how about making an instance Num a => Num (Maybe a) ? would that make sense?
14:57:24 <Megzlna> no polymorphic lists
14:57:28 <Zero_In_Mood> i dont even now nub so (map head).group.sort !?
14:57:31 <vixey> > let __ =__ in length [1,2,3,4,__,6,7]
14:57:32 <wli> > let [1,2,3,4,_,6,7] = [1..7] in True
14:57:32 <lambdabot>   7
14:57:33 <lambdabot>   thread killed
14:57:33 <lambdabot>   True
14:57:42 <luite> Zero_In_Mood: I don't see an easy way to do it without removing duplicates, unless you use a set as temporary storage and convert it to a list afterwards
14:57:46 <vixey> lambdabot is learning to write haikus
14:57:54 <Raevel> go lambdabot
14:58:12 <Megzlna> Can we go back to square 1: How do you write a polymorphic list?
14:58:14 <luite> the sort method wouldn't work for infinite lists, obviously
14:58:19 <vixey> @src []
14:58:20 <lambdabot> data [] a = [] | a : [a]
14:58:24 <vixey> ^^^ like that
14:58:38 <erikc> he means heterogenous list
14:59:07 <luite> Zero_In_Mood: do you really need it to work for infinite lists?
14:59:22 <erikc> megzlna: you'd need to make a GADT that has the operations you need
14:59:27 <erikc> or you can use Data.Dynamic
14:59:32 <Zero_In_Mood> no.. i dont have to work for infinite lists..
14:59:37 <erikc> to get dynamic typing
14:59:41 <luite> Zero_In_Mood: i'd probably use a foldr then, and keep a set of tuples that are already produced
14:59:52 <Zero_In_Mood> just for any list.. i just told u that i created a infinite list by chance ^^
14:59:57 <Zero_In_Mood> damn how i hate foldr :(
15:00:04 <luite> Zero_In_Mood: ah sorry
15:00:10 <vixey> Megzlna, yeah I guess I don't know what you mean by polymorphic list
15:00:21 <vixey> Zero_In_Mood, foldr is absolutely wonderful
15:01:14 <Zero_In_Mood> yh well its okay if u can work with it but i still have problems with most of the higher order functions :(
15:01:44 <vixey> Zero_In_Mood, welly ou know how lists are made up ? like [1,2,3] is actualy  1 : (2 : (3 : []))
15:02:06 <Zero_In_Mood> i know that
15:02:14 <luite> > let hilfe = (map head).group.sort.concatMap (\(x,y) -> [(x+1,y),(x-1,y),(x,y+1),(x,y-1)]) in hilfe [(2,3),(4,5)]
15:02:15 <lambdabot>   [(1,3),(2,2),(2,4),(3,3),(3,5),(4,4),(4,6),(5,5)]
15:02:18 <vixey> Zero_In_Mood: foldr is so simple:  foldr (*) x (1 : (2 : (3 : []))) ~~> (1 * (2 * (3 * x)))
15:02:32 <vixey> Zero_In_Mood: it's just like pulling a tablecloth out from under something
15:02:48 <vixey> every (:) is replaced with (*) and the [] with x
15:03:26 <roconnor> Megzlna: lists, along with maybe, either, and a few other prelude types are fundamental types for interfacing code in different libraries.
15:03:30 <vixey> Zero_In_Mood: for example  foldr (:) []  just gives you the original list back
15:03:54 <vixey> Zero_In_Mood: foldr (+) 0 will sum everything in the list
15:04:12 <Zero_In_Mood> yeah i know that with foldr (+) 0 == sum
15:04:14 <vixey> Zero_In_Mood: foldr (\x ys -> f x : ys) [] = map f ....
15:04:30 <vixey> Zero_In_Mood: and you can see how write stuff like length with foldr?
15:04:41 <luite> Zero_In_Mood: I think you were thinking the wrong way around in your original hilfe function. every element in the original list should return 4 neighbours (minus duplicates), you don't need to pattern match on anything
15:05:28 <Zero_In_Mood> length with foldr ?
15:05:51 <luite> think of length as (1+(...))
15:06:05 <vixey> well a fun thing to do is write it like
15:06:12 <vixey> sum . map (const 1)
15:06:17 <vixey> except sum nd map as foldr
15:06:17 <Zero_In_Mood> yh i came up with somethin like that luite
15:06:30 <Zero_In_Mood> but i didnt come up how i can count any element in the list
15:06:50 <vixey> sum . map (\x -> if x == element then 1 else 0)
15:07:16 <ddarius> vixey: Are you an APL programmer or something?
15:07:25 <vixey> I wish :p
15:07:40 <Zero_In_Mood> for what is the . between sum and map ?
15:07:41 <vixey> I got obsessed with J for a while
15:07:47 <ddarius> J is fun.
15:07:57 <Zero_In_Mood> J?
15:08:04 <ziman> Megzlna, http://hpaste.org/13029 ;)
15:08:42 <ozy`> Zero_In_Mood: ASCII APL
15:08:50 <Zero_In_Mood> okay..
15:09:30 <ozy`> don't know what APL is?
15:09:58 <ozy`> people have sometimes said that you can write anything in one line of perl
15:09:59 <ddarius> Such uncultured people these days.
15:10:08 <Zero_In_Mood> i just read it on wikipedia.. sorry im pretty new in this kinda stuff.. i was chilling before enterin university :)
15:10:36 <ozy`> but that's actually a better description of APL.... it puts perl to shame for terseness and impenetrability
15:10:43 <ozy`> no worries :p
15:11:11 <BMeph> I <3 old-school PL's... :)
15:12:10 <Zero_In_Mood> oh APL seems nice^^
15:12:13 <vixey> (⍢)
15:12:34 <Zero_In_Mood> would have loved to do that at university...
15:12:36 <vixey> ⍴⍴⍴ of rank, always equals 1
15:12:42 <BMeph> I think I first heard of tensors from APL. :)
15:13:39 <Zero_In_Mood> k but enough i ll try to finish my shit ^.^
15:14:22 <vixey> hehe
15:15:04 <Zero_In_Mood> so u think im totally wrong with my way and i should start from 0 ?
15:18:03 <pumpkin> is there an accepted way to separate your presentation from your "logic" in happs+(x)html
15:18:16 <gp> hiw is state a monad?
15:18:20 <gp> how
15:18:30 <gp> i eman if iw ere to write a monad in clojure?
15:18:34 <gp> how would I write state?
15:18:40 <gp> clojure=lisp
15:19:08 <ddarius> The exact same way you'd write it in Haskell, only with more brackets.
15:19:10 <luite> Zero_In_Mood: sorry I was away for a few minutes. did you see my lambdabot example?
15:19:23 <Zero_In_Mood> no sorry didnt
15:19:39 <luite> > let hilfe = (map head).group.sort.concatMap (\(x,y) -> [(x+1,y),(x-1,y),(x,y+1),(x,y-1)]) in hilfe [(2,3),(4,5)]
15:19:41 <lambdabot>   [(1,3),(2,2),(2,4),(3,3),(3,5),(4,4),(4,6),(5,5)]
15:19:50 <Zero_In_Mood> hmm..
15:20:03 <luite> the first part (up to the sort) is just for removing duplicates
15:20:10 <Zero_In_Mood> thats not 100% right.. the problem is that lemme show it how the result should be
15:20:15 <luite> the rest is generating the neighbours
15:20:40 <ddarius> luite: Why wouldn't you just use nub?
15:20:50 <pumpkin> nub is quadratic isn't it?
15:20:53 <luite> ddarius: nub would be extremely slow for larger lists
15:21:03 <ddarius> luite: Is that a problem here?
15:22:03 <nolrai_East> @ty maybe mzero return
15:22:04 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
15:22:05 <luite> ddarius: don't know, I already suggested nub, but explained that this would probably be faster. he calls the data structure Bitmap ( = [(Int,Int)] ), so I have the feeling that it might be larger
15:22:24 <vixey>  [(Int,Int)] ???
15:22:36 <pumpkin> :o
15:22:55 <Zero_In_Mood> [[(1,3)],[(2,2)],[(2,4)],[(3,3)],[(3,5)],[(4,4)],[(4,6)],[(5,5)]]
15:23:04 <vixey> what's a bitmap
15:23:04 <nolrai_East> @ty maybe mzero return . listToMaybe
15:23:06 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [a] -> m a
15:23:07 <Zero_In_Mood> the list should be like this.. sry hat to check it twice..
15:23:17 <Zero_In_Mood> bitmap = [(Int,Int)] that right ixey
15:23:19 <pumpkin> Zero_In_Mood: then map a :[] to it :P
15:23:25 <vixey> :t maybe mzero return
15:23:26 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
15:23:39 <vixey> :t maybe
15:23:40 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:24:26 <Zero_In_Mood> since well cause non of the tuples is fittin the neighbour definitons : x == x' && abs (y-y')==1 || y==y' && abs (x-x')== 1  if thats the case the tuples (x,y) and (x',y') are neighbours
15:27:30 <Request> Free Programming ebooks With Direct Links & Request ebooks Here : http://request-ebooks.blogspot.com/
15:28:08 <pumpkin> bah
15:28:39 <BMeph> Zero_In_Mood: What if (x1,y1) is a neighbor to (x2,y2), and (x2,y2) is a neighbor to (x3,y3), but (x1,y1) is not a neighbor to (x3,y3). How would that list look?
15:29:04 <vixey> idk what is a bitmap??
15:29:14 <Zero_In_Mood> with all 3 tuples in it since (x3,y3) is neighbour to (x2,y2) so indirectly neighbour to (x1,y1)
15:29:16 <ziman> probably a sparse bitmap
15:29:18 <vixey> lol@ K-lines
15:29:20 --- mode: ChanServ set +o dibblego
15:29:27 <Zero_In_Mood> a bitmap is [(Int,Int)]
15:29:34 <Zero_In_Mood> a list of tuples
15:29:38 <vixey> and what is the meaning of it?
15:29:38 --- mode: dibblego set -o dibblego
15:29:46 <pumpkin> isn't it a set of bits normally?
15:29:48 <pumpkin> :P
15:30:12 <vixey> bits?
15:30:17 <Zero_In_Mood> hmm well actually
15:30:32 <Zero_In_Mood> we wrote a program where we can paitn those bitmaps in winHugs^^
15:30:33 <pumpkin> "packed booleans"?
15:30:44 <Zero_In_Mood> there is no point behind that kinda.. just for practice i guess :)
15:31:10 <Beelsebob> Zero_In_Mood: not R^2 -> a?
15:31:21 <Zero_In_Mood> R^2 -> a ?
15:31:32 <Beelsebob> (R,R) -> a
15:31:38 <pumpkin> a mapping from 2d space to a value
15:31:57 <Beelsebob> notably a polymorphic value
15:32:04 <vixey> hehe Beelsebob is using dependent types
15:32:04 <Beelsebob> not just some arbitrary notion of colour
15:32:08 <Zero_In_Mood> i still didnt get it what should the "a" be ? ^^
15:32:15 <vixey> (^) :: * -> Nat -> *
15:32:16 <Beelsebob> vixey: no
15:32:23 <vixey> you are just admit it!
15:32:30 <SamB_XP> heh
15:32:45 <SamB_XP> but * isn't a type constructor
15:32:46 <vixey> we all saw :p
15:32:50 <ziman> Zero_In_Mood, and I'd recommend using more descriptive names for values than `hilfe'; i'd use `iterate' or something similar so that you can infer what the function does from its name -- no need to look up the definition in order to read and understand the code.
15:32:51 <Beelsebob> Zero_In_Mood: an example -- suppose I have an image of translations
15:32:53 <vixey> * is a _value_
15:33:05 <vixey> actually that's horrible terminology
15:33:07 <vixey> misuse of
15:33:14 <BMeph> Zero_In_Mood: Ah, wading through the code.
15:33:22 <Beelsebob> I can now do photoshop filters by using the Image applicative to apply an image of transforms to an image of colours
15:33:30 <SamB_XP> that is, there's no Num * instance
15:33:56 <SamB_XP> so we can't use ^ on types
15:34:53 <vixey> doesn't matter
15:35:04 <athos> what's the average traffic/day on haskell-cafe?
15:35:18 <vixey> thought that counts
15:35:23 * BMeph thinks Haskell should just hurry up and get first-class types already
15:35:33 <Zero_In_Mood> oh sry were on the toilet for a minute.. lemme read the posts ^.^
15:35:37 <pumpkin> :o
15:36:02 <Axman6> tmi
15:36:03 <SamB_XP> Beelsebob: you can ?
15:36:19 <Beelsebob> SamB_XP: if you use conal's version of what an image is, yes
15:36:24 <Zero_In_Mood> hmm yh ziman german ppl would kinda see from the name what it should do^^
15:36:34 <SamB_XP> Beelsebob: I mean you have a photoshop plugin for that ?
15:36:43 <Beelsebob> SamB_XP: oh, lol
15:36:44 <Zero_In_Mood> and maybe u wanna the hpaste of the function which shows a bitmap as IO() ?
15:36:53 <Beelsebob> yes -- but usually speciallised one
15:37:00 <Beelsebob> e.g. there's a twirl photoshop filter
15:37:10 <Beelsebob> which is a specialised version ofthat
15:37:24 <SamB_XP> Beelsebob: well, get cracking then
15:37:40 <SamB_XP> so you can actually use the Image applicative in Photoshop!
15:37:56 <Beelsebob> hehehehe
15:38:32 <BMeph> Zero_In_Mood: Thank you for not naming any of those 'funktion'... ;p
15:38:51 <vixey> we put the funk in funktion
15:39:28 * Axman6 takes a break from funkytown to get breakfast
15:39:40 <Zero_In_Mood> i ll hpaste the normal unefficient function since u need for the efficient version another function to much work^^
15:39:42 <Zero_In_Mood> gimme a second
15:39:49 <ziman> Zero_In_Mood, it's not the language; it's the meaning of the word -- way too general so that it says nothing at all. You could as well use a number to identify that function. :)
15:40:06 <Zero_In_Mood> hmm i mean hilfe = help so its a help function
15:40:17 <ksf> it's english that pronounces func and funk the same way, german differentiates between funk and funk.
15:40:19 <Zero_In_Mood> wegh= is the deleting function for the helfunction ... weg = away
15:40:30 <Zero_In_Mood> weg = deleting function for my main function ^^
15:40:31 <vixey> @remember ksf german differentiates between funk and funk.
15:40:31 <lambdabot> It is stored.
15:40:59 <Zero_In_Mood> http://hpaste.org/13028#a1
15:41:06 <ksf> fanktschn.
15:42:55 <ziman> yes and that's what's wrong -- you don't say what the function *is* but you say how important it is and that's really of no use when reading the code.
15:43:28 <Zero_In_Mood> hmm
15:43:28 <ziman> i should've put the emphasis on *what*, i guess
15:43:45 <Zero_In_Mood> k i ll keep it in mind :)
15:43:56 <ksf> I'd interpret "weg" as "path", anyway.
15:44:10 <BMeph> ksf: Gesundheit! ;p
15:44:12 <ksf> ...and then wonder about the type.
15:44:26 <ziman> :)
15:44:36 <Zero_In_Mood> yeah..okay.. i ll give em better names next time
15:44:51 <Zero_In_Mood> sorry didnt thought about it 1to1 translation :)
15:45:07 <BMeph> ziman: Coulb be worse; he could've named it 'bestimmung'... ;p
15:45:35 <SamB_XP> Axman6: but it's suppertime!
15:45:53 <ksf> ...and I guess you wanna abstract those thousands of (x+n,y+m) into some kind of list of permutations.
15:45:55 <Axman6> it's 10:45AM, of course it's early breakfast time!
15:46:08 * BMeph loves having breakfast at suppertime
15:46:17 <Raevel> isn't there a function combining takeWhile and dropWhile?
15:46:30 <ziman> BMeph, :)
15:46:35 <Axman6> BMeph: i'm more partial to late lunch time these days
15:46:47 <ziman> :t break
15:46:48 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
15:46:48 <Zero_In_Mood> its 00:46 am here :)  ... hmmm no not at all i wanna sort a bitmap into [bitmap] so that neighbours are one bitmap in the return lit
15:46:50 <ziman> :t span
15:46:52 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
15:46:52 <Axman6> yay for 3 months off uni!
15:47:01 <SamB_XP> it would be span
15:47:06 <Zero_In_Mood> so single tuples are bitmaps as well
15:47:15 <Raevel> yep! span, thanks
15:47:23 <Raevel> (thought i tried it already)
15:47:26 * jeffwheeler is going to college!
15:47:44 * ksf usually has breakfast a couple at phase relative tea-time.
15:47:45 <SamB_XP> jeffwheeler: but it's either saturday or friday evening
15:47:50 <SamB_XP> you should be going home now!
15:47:58 <SamB_XP> or staying there
15:48:02 <jeffwheeler> But Illinois just said I could come!
15:48:05 <pumpkin> jeffwheeler: good for you!
15:48:10 <pumpkin> jeffwheeler: which il?
15:48:14 <ksf> s/a couple//
15:48:21 <jeffwheeler> University of Illinois at Urbana-Champaign
15:48:22 <ksf> never reformulate.
15:48:30 <hellige> jeffwheeler: nice! my alma mater.
15:48:31 <nolrai_East> is there a way to change (f a -> f b) into (f (m a) -> f (m b)) where f is a functor and m is a monad?
15:48:36 <pumpkin> jeffwheeler: ooh, good CS program there (for grad at least, I'd assume that works nicely for undergrads too)
15:48:40 <jeffwheeler> hellige: awesome; I'm excited
15:48:50 <jeffwheeler> pumpkin: seems like it; they're ranked 3rd in EE
15:49:06 <pumpkin> :)
15:49:08 <hellige> jeffwheeler: where do you live now?
15:49:12 <jeffwheeler> hellige: Austin
15:49:19 <elliottt> nolrai_East: sequenceA in Data.Traversable looks workable
15:49:23 <Axman6> > sortBy (compare`on`fst).sortBy (sompare`on`snd) $ zip ([1..10]++[0..10]) (reverse [1..10]++[0..10])
15:49:25 <lambdabot>   Not in scope: `sompare'
15:49:31 <Axman6> > sortBy (compare`on`fst).sortBy (compare`on`snd) $ zip ([1..10]++[0..10]) (reverse [1..10]++[0..10])
15:49:33 <lambdabot>   [(0,0),(1,1),(1,10),(2,2),(2,9),(3,3),(3,8),(4,4),(4,7),(5,5),(5,6),(6,5),(...
15:49:39 <elliottt> nolrai_East: Applicative f => t (f a) -> f (t a)
15:49:52 <elliottt> (where t is Traversable)
15:49:55 <hellige> jeffwheeler: cool.
15:49:59 <pumpkin> map Just [1,2,3]
15:50:00 <pumpkin> > map Just [1,2,3]
15:50:02 <lambdabot>   [Just 1,Just 2,Just 3]
15:50:04 <hellige> jeffwheeler: accustom yourself to winter weather. ;)
15:50:13 <jeffwheeler> hellige: That's what I'm scared of. :P
15:50:14 <pumpkin> how cold does it get there?
15:50:25 <jeffwheeler> pumpkin: in Austin? Every few years it'll snow.
15:50:33 <pumpkin> I mean urbana-champaign :P
15:50:49 <jeffwheeler> pumpkin: I think hellige knows better than I.
15:50:50 * wli hunts for IRC channel logs.
15:50:55 <hellige> cold enough... occasionally below zero (fahrenheit)
15:51:05 <pumpkin> hellige: ah, peanuts!
15:51:15 <hellige> it's 23 right now!
15:51:19 * jeffwheeler will die.
15:51:21 <Axman6> wli: /topic
15:51:33 <hellige> of course, it has been a very unusually cold december in illinois. :(
15:52:21 <teko> sup peeps
15:52:31 <teko> TGIF and all that
15:52:33 <hellige> jeffwheeler: BUT the snow is really lovely, and the other three seasons are very nice. you'll live. might even learn to enjoy it. ;)
15:52:42 <Jarvellis> Friday sucks
15:52:52 <hellige> jeffwheeler: anyway congratulations! time for me to get out of here...
15:53:06 <Axman6> but it's saturday...
15:53:17 <teko> for me its saturday too
15:53:31 <Axman6> where's .za?
15:53:33 <Jarvellis> It's saturday in seven minutes, the busyest day of the week, sorry i'm just bitching
15:53:35 <BMeph> jeffwheeler: It's not too late - quick, transfer to UCSD! ;)
15:53:37 <teko> south africa
15:53:48 <Axman6> thought it must be africa
15:53:56 <jeffwheeler_> An elf parser on Hackage? Neat!
15:54:06 <Axman6> i was thinking zambire (or however it's spelt)
15:54:06 <jeffwheeler_> BMeph: I sent my transcript to Stanford today, just in case.
15:54:09 <teko> whats the shortest haskell code for counting the amount of 'x's in a string ?
15:54:18 <Axman6> zambia probably...
15:54:40 <teko> no the country south africa not the region southern africa
15:54:42 <Axman6> length.filter (==x)?
15:54:53 <Axman6> teko: yeah i gathered that :)
15:54:58 <elliottt> length [()|'x'<-str]
15:55:13 <teko> k ta
15:55:18 <Axman6> > filter (=='1') "142436341151"
15:55:20 <lambdabot>   "1111"
15:55:33 <Badger> ooh
15:55:41 <BMeph> jeffwheeler: Bah, Stanford's almost as bad as Berkeley; come down where 50 F (10 C) is considered unseasonably cold! ;)
15:55:55 <teko> but ure traversing the list twice
15:55:56 <Axman6> elliottt: things not matching 'x' don't get bound then? how interesting
15:56:00 <teko> for length and filter
15:56:02 <Badger> > filter (=='A') "ABCDAbaCBdA"
15:56:04 <lambdabot>   "AAA"
15:56:08 <teko> isnt that slower than traversing once ?
15:56:09 <elliottt> Axman6: cool, eh? :)
15:56:11 <Badger> awesome.
15:56:15 <Axman6> indeed :)
15:56:36 <Axman6> so you can do [x|Just x <- list] then?
15:56:50 <Badger> :t filter
15:56:52 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
15:57:09 <Axman6> iesahin: concatMaybies
15:57:38 <Axman6> urgh, i hate that in irssi, you type ie then colon and it completes it -_-
15:58:00 <Raevel> does a++b execute in theta(length a)?
15:58:17 <sjanssen> Raevel: yes
15:58:17 <pumpkin> ooh theta
15:58:19 <Axman6> @src (++)
15:58:20 <lambdabot> []     ++ ys = ys
15:58:20 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
15:58:20 <lambdabot> -- OR
15:58:20 <lambdabot> xs ++ ys = foldr (:) ys xs
15:58:22 <pumpkin> haven't seen that in a while
15:58:42 <sjanssen> Raevel: assuming you demand the entire result
15:59:03 <Megzlna> Given:
15:59:08 <Megzlna> f :: (a -> a) -> a -> a
15:59:08 <Zero_In_Mood> lol i guess i ll give up for today :(
15:59:13 <Megzlna> f (+ (1 :: Int)) 1
15:59:16 <Megzlna> f (+ 1) (1 :: Float)
15:59:21 <Megzlna> Any 'explicitly defined' type will be given a higher precedence than any derived types in cooperating in the determination for the type of 'a'?
15:59:25 <Raevel> sjanssen: do you mean it's lazy?
15:59:31 <sjanssen> Raevel: yes
15:59:38 <Raevel> okay, great, thanks
15:59:54 <sjanssen> Megzlna: 1 :: forall a. Num a => a
16:00:04 <Axman6> Megzlna: i think i get what you mean, and yes
16:00:11 <pumpkin> > take 5 $ [1..100000000] ++ [1] -- Raevel
16:00:12 <lambdabot>   [1,2,3,4,5]
16:00:13 <sjanssen> (+ 1) :: forall a. Num a => (a -> a)
16:00:32 <Raevel> for some reason i thought it wasn't lazy, but i have no idea why
16:00:47 <sjanssen> Megzlna: type inference doesn't really have a concept of defined/derived types
16:00:47 <pumpkin> that took 4 seconds, maybe it was so lazy
16:01:02 <Raevel> :-o
16:01:04 <Megzlna> but does it "listen to the  (1 :: Int) moreso than (1) ?
16:01:15 <sjanssen> Megzlna: there is no "moreso"
16:01:23 <Axman6> foldr (:) ys xs is just as lazy as the standard definition right?
16:01:24 <sjanssen> it is a unification algorithm
16:01:29 <orbitz> :t 1
16:01:31 <lambdabot> forall t. (Num t) => t
16:01:41 <sjanssen> Megzlna: the (1 :: Int) thing will eventually cause the entire expression to have that type, yes
16:01:45 <Raevel> > take 5 $ [1..100000000000000000000] ++ [1]
16:01:47 <lambdabot>   [1,2,3,4,5]
16:02:04 <pumpkin> looked more eager to answer you Raevel
16:02:05 <Axman6> Megzlna: i think you'tr thinking too hard about the concepts of haskell for someone who's just learing it. just play with it, and find out how awesome the type system is ;)
16:02:07 <pumpkin> than me :(
16:02:12 <sjanssen> Axman6: it is a standard defn. yes
16:02:16 <Badger> uhh
16:02:20 <orbitz> > take 5 $ [1..] ++ [1]
16:02:21 <lambdabot>   [1,2,3,4,5]
16:02:25 <Megzlna> Axman6: I've hardly even begun thinking
16:02:28 <Badger> is it me, or did that lop off the ++ bit
16:02:34 <pumpkin> Badger: ?
16:02:37 <Axman6> Megzlna: how much haskell have you done?
16:02:38 <Badger> > take 5 [1..]
16:02:40 <lambdabot>   [1,2,3,4,5]
16:02:55 <Raevel> Badger: it "saves it for later"
16:03:02 <Badger> oh.
16:03:05 <pumpkin> Badger: that was the point of the example :P
16:03:05 <Megzlna> Axman6: As usual with languages, I'll write a (~20,000 line) .txt file of every possible aspect of the language organized to perfection
16:03:16 <Raevel> i could probably have removed the quotes there
16:03:21 <pumpkin> Megzlna: are you Ezla?
16:03:28 <orbitz> he is
16:03:36 <pumpkin> ah
16:03:46 <Badger> wait, wait
16:03:47 <Axman6> it would be nice if you stuck to a single nick Megzlna
16:03:51 <Badger> if it was fully evaluated
16:03:58 <orbitz> isnt' ezla == goober as well?
16:04:01 <Badger> what would it come out as?
16:04:02 <Axman6> yes
16:04:07 <Zero_In_Mood> damn.. i think i cant sleep like this ^^
16:04:07 <Axman6> but he refused to admit it
16:04:17 <orbitz> Axman6: he's easy to pick out, who else in here even knows what D is?
16:04:21 <luite_> Zero_In_Mood: still need something fixed? :P
16:04:24 <orbitz> much less talks about it non stop
16:04:25 <Axman6> i do...
16:04:29 <Raevel> Badger: [1..] ++ [1]? It would never terminate
16:04:41 <Badger> Raevel: technically, if it did
16:04:41 <Axman6> orbitz: about useless topics? yes, no one :P
16:04:48 <orbitz> Axman6: haha
16:04:55 <pumpkin> Badger: only because you didn't ask for all of it
16:04:57 <pumpkin> but only the first 5
16:04:57 <Badger> would it have the very last number, n
16:04:59 <sjanssen> Raevel: take 10 $ [1 ..] ++ [1] does terminate
16:05:11 <Axman6> > last [1..] ++ [1] :: Int32
16:05:12 <lambdabot>   Couldn't match expected type `Int32' against inferred type `[a]'
16:05:14 <Raevel> sjanssen: yes that i know
16:05:18 <pumpkin> Badger: not sure that makes much sense :P
16:05:18 <Axman6> > last [1..] ++ [1] :: [Int32]
16:05:20 <lambdabot>       No instance for (Enum [Int32])
16:05:20 <mapreduce> > let ones = 1 : ones in ones
16:05:20 <lambdabot>        arising from the arithmetic seque...
16:05:21 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:05:25 <Badger> pumpkin: I mean
16:05:28 <pumpkin> Badger: it's saying inifinity + 1's last digit would be x
16:05:37 <Badger> pumpkin: [1,2,3...n,1]
16:05:38 <pumpkin> which doesn't make much sense :P
16:05:45 <pumpkin> Badger: that's assuming n is a number
16:05:47 <mapreduce> Badger: I suggest understanding my above code.
16:05:48 <Badger> yes
16:05:49 <Badger> it is
16:05:52 <Raevel> Badger: [1..reallyLargeN] ++ [1] would terminate, yes, and it would have made a list that long
16:05:54 <mapreduce> It helped me to grasp it.
16:06:00 <sjanssen> Axman6: function application binds more tightly than (++)
16:06:15 <Axman6> ah yes
16:06:27 <Axman6> > last ([1..] ++ [1]) :: Int32
16:06:29 <orbitz> > length [1..]
16:06:37 <pumpkin> Axman6: it would be funny if that did return 1
16:06:43 <lambdabot>   thread killed
16:06:45 <lambdabot>   thread killed
16:06:47 <Axman6> > last ([1..] ++ [1]) :: Int16
16:06:56 <teko> orbitz!!!!!!!!!!
16:07:05 <orbitz> hi teko
16:07:08 <lambdabot>   1
16:07:14 <sjanssen> pumpkin: it will, eventually
16:07:15 <Badger> haha
16:07:23 <luite_> wow, just before the thread killed, probably ;)
16:07:30 <sjanssen> > last ([1 ..] ++ [1]) :: Word8
16:07:30 <pumpkin> sjanssen: lol, for some definitions of eventually :P
16:07:32 <Megzlna> sjanssen: In the unification algorithm for "a's", there can never before more than two types radiating from any single expression anywhere, applying to a given 'a', But there can be, multiple conjoint typeclasses.
16:07:33 <Megzlna> ?
16:07:34 <lambdabot>   1
16:07:49 <Megzlna> it just reduces it
16:07:54 <Zero_In_Mood> luite_ still need my problem fixed :D
16:07:57 <pumpkin> sjanssen: how did that work?
16:08:02 <Megzlna> There could be ten a :: Int's, so long as they agree
16:08:05 <Zero_In_Mood> i wont try the other program .. when i finish this i ll finish the sheet :D
16:08:10 <sclv> > last ([9223372036854775800..] ++ [1]) :: Int
16:08:13 <sjanssen> Megzlna: there can be multiple different type variables in a single expression
16:08:14 <lambdabot>   1
16:08:18 <pumpkin> oh I see
16:08:19 <Megzlna> sjanssen: Of course
16:08:22 <pumpkin> because it's a finite type
16:08:22 <Zero_In_Mood> i didnt get it with some crazy foldr action dunno how... exactly.
16:08:26 <Megzlna> sjanssen: But that'd be 'b' :)
16:08:29 <Axman6> Megzlna: just learn haskell then ask difficult questions later when you know what the language is all about
16:08:42 <Megzlna> Axman6, you're a newbie
16:08:46 <pumpkin> lol
16:08:49 <sclv> bah sjanssen beat me to it
16:08:52 <Axman6> so are you, what's your point?
16:08:54 <orbitz> Axman6: <insert I don't learn like that excuse here>
16:09:12 <pumpkin> Megzlna: you really are Ezla?
16:09:12 <Megzlna> Well, since I've been here, Axman6 has told me each day to stop learning.
16:09:14 <sjanssen> Megzlna: the question doesn't make particularly much sense
16:09:16 <Megzlna> In a different way.
16:09:29 <orbitz> i think Axman6 has told you TO learn
16:09:33 <orbitz> but that's just me
16:09:38 <sjanssen> Megzlna: it's like solving an algebra equation, you substitue variables until the whole thing makes sense
16:09:47 <Axman6> i don't see how trying to learn how to apply C++ to haskell is helping learn the language at all
16:10:00 <Badger>  < Megzlna> Well, since I've been here, Axman6 has told me each day to stop learning.
16:10:04 <Megzlna> Axman6: You're not smart enough for me, because you're not one of the guys with answers.
16:10:04 <Badger> < Axman6> Megzlna: just learn haskell
16:10:07 <Axman6> > "just learn haskell" == Stop learning!"
16:10:11 <lambdabot>   <no location info>:
16:10:11 <lambdabot>      lexical error in string/character literal at chara...
16:10:14 <pumpkin> Megzlna: you don't need to know why the area of a circle is pi*r^2 to apply the formula :P
16:10:17 <Axman6> > "just learn haskell" == "Stop learning!"
16:10:20 <Megzlna> Your only comments are "just learn haskell" etc
16:10:21 <lambdabot>   False
16:10:24 <Megzlna> not like Cale or anything
16:10:29 <Megzlna> or any of these great guys
16:10:35 <Megzlna> who are highly articulate and helpful
16:10:43 <orbitz> pumpkin: Ezla [i=megzlna@cpe-76-172-169-17.socal.res.rr.com] has joined #Haskell
16:11:03 <Badger> Megzlna: which doesn't particularly help you
16:11:15 <Axman6> Megzlna: ok, put it this way, is trying to figure out integration with multiple variables the best way to teach someone basic maths?
16:11:29 <luite_> Megzlna: type classes just constrain the types, multiple type classes just constrain it more (not sure if this answers your question)
16:11:36 <Axman6> you're making life far harder for yourself, and others in here, by not learning the basics
16:11:48 <Megzlna> Axman6: I have my ways. Don't worry about how I learn, unless you have a specific area of insight.
16:11:55 <Megzlna> To teach.
16:12:05 <pumpkin> orbitz: it's funny that I could tell who it is even without that info :P
16:12:06 <Axman6> experience will teach you far more than asking questions about things you don't know how to use
16:12:17 <SamB_XP> Megzlna: have you got hello world to work yet ?
16:12:32 <Debugger> Megzlna: If you come from C++.. if you didn't do lots of metaprogramming then forget everything you know.
16:12:36 <Badger> > "Hello, world!"
16:12:40 <lambdabot>   "Hello, world!"
16:12:53 <pumpkin> Badger++
16:12:55 <orbitz> > "get me outta these damed quotes!"
16:12:56 <sjanssen> Debugger: even the metaprogramming is almost entirely different
16:12:59 <lambdabot>   "get me outta these damed quotes!"
16:13:04 <SamB_XP> if you DID do lots of megaprogramming, forget everything but how to write a turing machine in the template system
16:13:09 <Megzlna> C++ is only one language
16:13:14 <Debugger> sjanssen: True, metaprogramming is primitive
16:13:16 <orbitz> i heard its'
16:13:17 <orbitz> 4
16:13:29 <orbitz> now now, let' sbe fair. Megzlna has done D as well
16:13:30 <Megzlna> orbitz: Kinda true
16:13:31 <sjanssen> Megzlna: out of curiousity, what source are you using to learn Haskell?
16:13:40 <orbitz> sjanssen: #haskell
16:13:42 <luite_> I'd say #haskell
16:13:43 <Debugger> RWH! :D
16:13:44 <pumpkin> lol
16:13:57 <luite_> bah orbitz is too fast, not fair ;)
16:14:01 <Badger> @where lyah
16:14:02 <lambdabot> www.learnyouahaskell.com
16:14:03 <Badger> :)
16:14:10 <orbitz> luite_: i used tab complete!
16:14:11 <SamB_XP> Megzlna: could you PLEASE read some tutorials and *work through them*?
16:14:12 * Axman6 doesn't like being the evil character in the book of #haskell, but he's getting annoyed
16:14:18 <Badger> come on, who doesn't like pretty pictures!
16:14:27 <mapreduce> Me.
16:14:29 <pumpkin> Axman6: I don't think you're the only one :)
16:14:35 * pumpkin reduces mapreduce
16:14:37 <mokus> Megzlna: I think what rubs a lot of these people the wrong way is not anything about how you learn, but rather about how you seem to start your analysis of every aspect of the language with the assumption that it is majorly deficient
16:14:41 * mapreduce unfolds.
16:14:46 <Axman6> yes, i've persuaded others over to the dark side@
16:14:48 * elliottt har's
16:14:48 <Axman6> !*
16:14:54 * BMeph knows Walter Bright personally.
16:15:03 <Megzlna> mokus, asking how 'a' derivation works isn't inclusive of deficiency
16:15:04 <SamB_XP> Axman6: actually that was Megzlna's doing ;-P
16:15:08 * BMeph 's first name is also Walter
16:15:09 <orbitz> Axman6: to be fair, it' snot him asking questions that can be bothersome, it's that everytime it's not like C++ or D, i tis clearly wrong
16:15:18 <mokus> Megzlna: I'm not talking about this case
16:15:32 <pumpkin> many of them are interesting questions and I like hearing the answers
16:15:36 <pumpkin> because I'm learning too
16:15:36 <mokus> I just mean over the past several days as I've watched
16:15:39 <Axman6> orbitz: indeed
16:15:50 <pumpkin> but they do feel rather pointed
16:15:59 <mokus> I personally thing some of them are being too harsh on you, but I can see why they react that way too
16:16:01 <SamB_XP> pumpkin: do you by some chance mean barbed ?
16:16:12 <Axman6> pumpkin: i guess you missed the whole TH discussion yesterday then
16:16:14 <Megzlna> I'm not worried about how people react.
16:16:18 <pumpkin> SamB_XP: possibly :)
16:16:25 <Axman6> i don't think anyone learned anything
16:16:26 <pumpkin> Axman6: yup :(
16:16:27 <Megzlna> The best you can do is ask questions
16:16:32 <Megzlna> And have opinions sometimes
16:16:33 <Megzlna> and be yourself
16:16:46 <SamB_XP> no, you should also work through tutorials!
16:16:48 <Axman6> Megzlna: well ask them after you have some experience
16:16:55 <luite_> I don't mind the questions and I try being helpful.... but this way of learning surely costs lots of questions, and therefore lots of people's time
16:17:00 <Badger> Megzlna: the best you can do is rtfm, then ask questions :)
16:17:07 <daf> questions are good, but they are expensive
16:17:08 <SamB_XP> rtftt
16:17:11 <teko> Megzlna :  haskell new!!!  c++ old!!!  thats all ye need to know
16:17:13 <Badger> tt?
16:17:18 <SamB_XP> TuTorial
16:17:22 <Badger> Ah.
16:17:24 <pumpkin> Megzlna: granted, all this information is written down in plenty of places, so a fair amount of RTFM is due after a point
16:17:27 <Axman6> not, "oh hey, does haskell have objects with static variables that are threadsafe? java does, why not haskell? btw, i don't know any haskell"
16:17:30 <eu-prleu-peupeu> hello
16:17:42 <SamB_XP> of course Haskell has that
16:17:48 <Badger> @faq
16:17:49 <lambdabot> The answer is: Yes! Haskell can do that.
16:17:49 <SamB_XP> all variables are static, that is, unchanging
16:17:51 <Megzlna> Axman6: My questions are more thoughtful than that. That's why you fail.
16:17:53 <SamB_XP> and therefore threadsafe
16:17:54 <pumpkin> @ oh hey, does haskell have objects with static variables that are threadsafe?
16:17:54 <SamB_XP> duh
16:17:59 <pumpkin> @faq oh hey, does haskell have objects with static variables that are threadsafe?
16:18:00 <lambdabot> The answer is: Yes! Haskell can do that.
16:18:23 <sjanssen> everyone, it is probably time to stop badgering Megzlna.  You've all made your opinions known, but it is ultimately Megzlna's decision what to do
16:18:29 <Axman6> Megzlna: i was giving an example. and your questions are, as pumpkin pointed out, documented elsewhere, very likely in the tutorials you refuse to follow
16:18:36 <SamB_XP> okay
16:18:40 <SamB_XP> but one last thing
16:18:50 * Badger stops sjanssening.
16:18:51 <SamB_XP> people HAVE actually been banned from this channel, believe it or not!
16:18:53 <SamB_XP> so be carefull
16:18:56 <pumpkin> Badger: lol
16:19:00 <sjanssen> Badger: sorry, didn't mean to discriminate :)
16:19:06 <Badger> :P
16:19:08 <luite_> hehe
16:19:18 <Axman6> heh
16:19:38 <Viniceos> "be yourself" <- that was beautiful
16:19:44 <sjanssen> Badger: in fact, it is probably your fault my subconscious chose "badgering" rather than any number of synonyms
16:19:44 <pumpkin> I did shed a tear
16:19:59 <SamB_XP> foto?
16:20:03 <Badger> I am a plague of badgers. :(
16:20:08 * Axman6 finally gets breakfast
16:20:10 <pumpkin> Viniceos: not sure you can put a literal on the left side of that arrow though
16:20:22 <SamB_XP> Axman6: but I told you -- it's time for SUPPER
16:20:24 <Viniceos> pumpkin: oops
16:20:41 <Axman6> nuh uh!
16:20:43 <pumpkin> you might be able to actually
16:20:46 <Megzlna> Regarding the 'a' question, I was soliciting insights about the reduction process. I expect other stuff to crop up, side points, and interesting stuff.
16:20:53 <SamB_XP> Axman6: uh huh!
16:21:04 <Axman6> 'damn, my mum's gingerbread is awesome
16:21:11 <Axman6> and fuck, now i don't have time for breakfast!
16:21:14 <pumpkin> Megzlna: what do you think of haskell so far?
16:21:23 <Megzlna> pumpkin: great
16:21:36 <pumpkin> :)
16:21:39 <luite_> Megzlna: btw, is your question answered now?
16:21:47 <SamB_XP> what is this "reduction process" you speak of ?
16:21:52 <Axman6> :t (+1)
16:21:55 <lambdabot> forall a. (Num a) => a -> a
16:21:58 <SamB_XP> I don't remember type inference involving reduction, honestly
16:21:59 <Axman6> :t (+(1::Float))
16:22:01 <lambdabot> Float -> Float
16:22:03 <BMeph> Axman6: Solution: Eat more gingerbread!  It's a Win-Win! :)
16:22:04 <Axman6> :t (+(1::Double))
16:22:07 <lambdabot> Double -> Double
16:22:13 <Axman6> :t (+(1::Complex Double))
16:22:15 <pumpkin> Axman6: ORLY
16:22:15 <lambdabot> Complex Double -> Complex Double
16:22:21 <Megzlna> <Megzlna> sjanssen: In the unification algorithm for "a's", there can never before more than two types radiating from any single expression anywhere, applying to a given 'a', But there can be, multiple conjoint typeclasses.
16:22:24 <erikc> megzlna: the type inferencing is performed by unification, i highly recommend this book http://www.cis.upenn.edu/~bcpierce/tapl/ which goes over the details
16:22:25 <Megzlna> Is there any other rule?
16:22:27 * Axman6 is done now, hopes that helped
16:22:47 <SamB_XP> @where report
16:22:48 <lambdabot> http://www.haskell.org/onlinereport/
16:22:49 <Raevel> i've almost finished tapl now, yay
16:22:50 <luite_> why the two types?
16:22:56 <SamB_XP> Megzlna: the basic rules are all there!
16:23:05 <sjanssen> Megzlna: the rules are a bit involved, see Hindley-Milner type inference
16:23:40 <sjanssen> Megzlna: the best advice is to use intuition from algebra, solve for the variables involved and make sure they're consistent
16:23:59 <thoughtpolice> if you want a pretty down to earth explanation, spj's book is pretty damn good I think.
16:24:09 <Megzlna> yeah its a Common reduction: But there can be some other stuff:
16:24:10 <thoughtpolice> @go the implementation of functional programming languages
16:24:13 <lambdabot> http://research.microsoft.com/~simonpj/Papers/slpj-book-1987/index.htm
16:24:13 <lambdabot> Title: The Implementation of Functional Programming Languages
16:24:14 <Megzlna> data Foo t =
16:24:19 <thoughtpolice> ^ online
16:24:23 <Megzlna> where the 'a' is a foo, but has a dependent t
16:24:34 <thoughtpolice> it made the unification and type checking process much more clear to me
16:25:02 <Megzlna> thoughtpolice, erikc: thx
16:25:11 <Megzlna> and re: Hindley Milner
16:25:15 <hoopy> does GHC usually take eons to compile?
16:25:24 <pumpkin> hoopy: exactly three of them
16:25:25 <thoughtpolice> but yeah you can basically view it just as a system of equations and solving them - it really is just an algebraic process
16:25:26 <sjanssen> hoopy: it does take a while, yes
16:25:41 <pumpkin> hoopy: there may be precompiled binaries for your platform though, on haskell.or
16:25:42 <pumpkin> .org
16:25:43 <thoughtpolice> hoopy: depends on the build settings, for a release build and without a parallel build, it can take a while, yeah
16:25:55 <hoopy> i'm installing it via macports
16:26:09 <hoopy> w/ whatever settings that has
16:26:09 <pumpkin> hoopy: there is a .pkg for mac os :)
16:26:12 <pumpkin> if you don't want to wait
16:26:14 <BMeph> Megzlna: Ooh, and Damas! Can't forget about Damas! :)
16:26:15 <Axman6> hoopy: yeah it takes it's time
16:26:20 <thoughtpolice> hoopy: ah, I use os x but I always just use source tarballs for haskell-related stuff
16:26:20 <hoopy> i've already invested a lot of time
16:26:25 <Megzlna> BMeph: Damas?
16:26:28 <hoopy> i'm going to ride this one out
16:26:32 <pumpkin> also, 6.10 is quite recent, so if you want that make sure you update macports before you do it or you'll have 6.8
16:26:34 <thoughtpolice> hoopy: if you build from source though I recommend something like 'make -j3' though
16:26:43 <thoughtpolice> makes the build so much more fast
16:26:46 <BMeph> Hindley and Milner thought up the inference system; Damas and Milner proved that it works. :)
16:26:51 <hoopy> what does the -j3 switch do?
16:27:01 <pumpkin> three concurrent compilations
16:27:04 <erikc> hoopy: spawns 3 processes; i like to gnumake -j16 it, it makes the room warm
16:27:05 <hoopy> hmm
16:27:06 <pumpkin> or "operations" within the makefile
16:27:16 <thoughtpolice> hoopy: it parallelises the build
16:27:23 <hoopy> wouldn't it makes sense to do -j2 if you have 2 cores?
16:27:27 <lucca> no
16:27:32 <Badger> erikc: owch
16:27:34 <BMeph> Well, Hindley and Milner independently thought up two systems that are isomorphic, yada, yada, yada. ;)
16:27:37 <pumpkin> hoopy: http://trac.macports.org/wiki/howto/ParallelBuilding
16:27:39 <lucca> you want to slightly exceed your core count
16:27:41 <Axman6> ou usually use n+1
16:27:42 <teko> can i write programs in an OO style with haskell and is it a good idea ?
16:27:44 <thoughtpolice> yeah
16:27:45 <thoughtpolice> n+1
16:27:45 <lucca> to get more overlapping IO
16:27:53 <jsn> teko:  no and no
16:28:02 <thoughtpolice> hoopy: even on a single core, running with at least -j2 is a good idea, since IO overlaps
16:28:18 <lucca> jsn: well you probably Could, it'd just be fairly hideous :p
16:28:32 <Megzlna> teko: Yes and Yes :)  just s/Object/value/ though
16:28:42 <pumpkin> you could build up a huge ugly object system "overlay" on haskell if you really wanted to
16:28:46 <luite_> teko: are you Megzlna? ;)
16:28:52 <hoopy> that page even says cores+1
16:28:55 <luite_> sorry :P
16:28:58 <hoopy> i set my buildmakejobs to 3
16:29:03 <hoopy> thanks for the tip
16:29:08 <pumpkin> hoopy: port install $portname build.jobs=N also
16:29:21 <sjanssen> teko: you can write in an OO style, but it is not the native style in Haskell (meaning it can be a bit involved)
16:29:32 <pumpkin> hoopy: I think if you ctrl+c out of the port install, change that stuff, and run it again, it'll resume where you left off
16:29:40 <hoopy> excellent
16:29:42 <hoopy> i'll tr
16:29:53 <pumpkin> hoopy: but I can't guarantee it ;)
16:29:55 <teko> but i if i dont structure my code into objects then how do i do it ?
16:30:03 <Megzlna> on a basic level, working with "objects" -- lets call them values instead, would be a Module which includes functions for working on a particular value type. A key difference being that in Haskell, you can keep extending the functions that work on the value type, outside of the value's "class"
16:30:05 <Megzlna> it's open
16:30:20 <hoopy> i do wonder though why the build is on sed for long periods of time
16:30:25 <sjanssen> teko: into functions, and data types, and modules containing functions and types
16:30:40 <kig> > let x.f = f x in "hello".take(4).reverse
16:30:42 <erikc> on the topic of macs, does anyone have any strong opinions on the latest macbook vs macbook pros, im buying one this weekend
16:30:43 <lambdabot>   "lleh"
16:30:46 <teko> sjanssen but then those modules are like classes
16:30:49 <sjanssen> Megzlna: in most cases, Haskell modules really don't align with OO objects
16:30:54 <sjanssen> teko: no, they're not like classes
16:31:02 <hoopy> erikc: if you don't care about the screen or beefy graphics i'd get a regular macbook
16:31:06 * hoopy just bought a macbook pro
16:31:11 <lucca> erikc: on the previous line, the pros were much better constructed, but I suspect that matters less now
16:31:19 <pumpkin> erikc: they're pretty
16:31:21 <sjanssen> modules are just namespaces -- an organizing structure to categorize your code
16:31:22 <Megzlna> the module isn't a class literally, but its a collection of methods for working on a value
16:31:24 <hoopy> a few people i work with just bought unibody macbooks, they are beautiful machines
16:31:29 <Megzlna> and with no implicit 'this' parameter
16:31:37 <sjanssen> Megzlna: this is not necessarily true
16:31:47 <eu-prleu-peupeu> brain's response to fear: http://derrenbrownart.com/blog/?p=225
16:31:49 <Megzlna> sjanssen: For his proposed questional usage
16:31:53 <erikc> ok, thats what i figured, ill get a macbook then, i want an iphone sdk machine, will be my first mac
16:31:53 <sjanssen> Megzlna: what you say is similar to say, the Data.Map module, but doesn't really apply to Data.Monoid
16:31:57 <Megzlna> of course you could do a zillion other things with modules
16:31:59 <sjanssen> or Prelude
16:32:06 <pumpkin> Megzlna: if you're a bad programmer like me, you'll have all sorts of different stuff in one module, completely unrelated :P
16:32:11 <pumpkin> PumpkinsStuff
16:32:25 <teko> no1 can argue that OO represented a huge step forwards for software development.  if haskell cant do OO arent we taking a step back ?
16:32:34 <Megzlna> well the point is to let the guy know that he can indeed work with methods and values
16:32:35 <pumpkin> teko: that's fairly loaded ;)
16:32:38 <luite_> teko: are you really not Megzlna?
16:32:39 <Megzlna> its not /that/ far out
16:32:39 <sjanssen> @wn no1
16:32:40 <lambdabot> No match for "no1".
16:32:51 <sjanssen> teko: we like to use proper words in #haskell :)
16:33:00 <teko> o
16:33:03 <teko> i mean oh
16:33:04 <Megzlna> Even:   val `method` arg1 arg2
16:33:04 <pumpkin> teko: that logical statement is broken :P
16:33:06 <luite_> teko: maybe a step forward in a different direction :P
16:33:10 <Megzlna> there's your "implicit this"
16:33:12 <daf> teko: perhaps OO was an improvement on what preceded it
16:33:27 <sjanssen> Megzlna: val `method` arg1 arg2 does not mean what you think it does
16:33:30 <daf> though I think that's debatable
16:33:31 <SamB_XP> teko: no one can argue that, unless they can at least say what OO was ...
16:33:32 <Megzlna> sorry rather
16:33:36 <sjanssen> Megzlna: method val (arg1 arg2)
16:33:36 <Megzlna> val `methos` (arg1 arg2)
16:33:47 <daf> that doesn't mean that other things can't be better and different
16:33:55 <sjanssen> Megzlna: you probably mean: method val arg1 arg2
16:34:53 <Megzlna> depends on style sj
16:35:12 <sjanssen> Megzlna: it does not depend on style, that is how Haskell works
16:35:21 <Megzlna> sjanssen: Why do you say that val `method` arg doesnt mean what I think it does?
16:35:32 <Megzlna> > (elem 1) [3,2,1]
16:35:34 <lambdabot>   True
16:35:36 <Megzlna> > (`elem` [3,2,1]) 1
16:35:40 <lambdabot>   True
16:35:54 <sjanssen> Megzlna: were you trying to write the equivalent of "val.method(arg1, arg2)"?
16:36:28 <luite_> > zip3 [1,2,3] [3,4,5] [5,6,7]
16:36:29 <luite_> > [1,2,3] `zip3` [3,4,5] [5,6,7]
16:36:32 <lambdabot>   [(1,3,5),(2,4,6),(3,5,7)]
16:36:32 <lambdabot>   Couldn't match expected type `t -> [b]' against inferred type `[a]'
16:36:42 <Megzlna> o `m` (a1, a2) works similarly
16:36:59 <Megzlna> ecept that you have to no "namespace importation"
16:37:00 <sjanssen> Megzlna: yes, with the tuple (if you really want to write in the non-curry style)
16:37:06 <Megzlna> o `Foo.m` (a1,a2)
16:37:07 <Raevel> > ([1,2,3] `zip3` [3,4,5]) [5,6,7]
16:37:11 <lambdabot>   [(1,3,5),(2,4,6),(3,5,7)]
16:37:14 <sjanssen> but o `m` a1 a2 means something entirely different
16:37:15 <Megzlna> whereas, in OO, the o implies a namespace
16:37:30 <sjanssen> just wanted to be clear on that fact
16:37:32 <twanvl_> > [1,2,3] `zip3` [3,4,5] `id` [5,6,7]
16:37:35 <lambdabot>   [(1,3,5),(2,4,6),(3,5,7)]
16:37:42 <Megzlna> sjanssen: The first one without the tuple was a typo cause I was typing too quickly
16:37:52 <Megzlna> I added the tuple 2 seconds later
16:37:57 <Megzlna> it doesnt matter
16:38:06 <mokus> > let (#) = flip ($) in [1..10] # map show
16:38:08 <lambdabot>   <no location info>: parse error on input `)'
16:38:20 <mokus> eh?
16:38:41 <sjanssen> Megzlna: if you look more closely, you wrote a version missing ',' two seconds later, then you wrote the right thing two minutes later :)
16:38:53 <sjanssen> Megzlna: but no big deal, just a mis-communication
16:38:58 <mapreduce> > let a . b = b a in "oo".length <= length "fp"
16:39:02 <lambdabot>   True
16:39:08 <sjanssen> mapreduce--
16:39:09 <dibblego> mokus, no (#)
16:39:10 <Megzlna> sjanssen:  I know how to write tuples...
16:39:18 <Megzlna> why are you worrying about some typo of ,
16:39:33 <sjanssen> Megzlna: I didn't know it was a typo until just now
16:39:42 <mokus> dibblego: my ghci has (#), and HOC used it
16:39:52 <sjanssen> (and, in fact, all the versions you wrote until the last were incorrect)
16:39:55 <luite_> Megzlna: without the , it stil meant function application
16:40:07 <dibblego> mokus, yeah, but lambdabot doesn't; I don't know why either
16:40:13 <mokus> oh well
16:40:23 <luite_> Megzlna: I didn't know that it was a typo either
16:41:00 <Megzlna> jeez people
16:41:45 <sjanssen> Megzlna: sorry, we can't read your mind, and since there are so many people learning in this channel we try to keep everything correct
16:42:12 <twanvl_> mokus: perhaps -XMagicHash or -fglasgow-exts
16:42:18 <SamB_XP> twanvl_: that doesn't seem a magic usage though ...
16:42:30 <mokus> twanvl_ : I was wondering that too, bit it works with and without magic hash in my ghc
16:42:30 <SamB_XP> I thought it was kosher in opnames already!
16:42:40 <mokus> which is 6.8.3
16:42:51 <Megzlna> <Megzlna> sorry rather
16:42:51 <Megzlna> <sjanssen> Megzlna: method val (arg1 arg2)
16:42:51 <sjanssen> SamB_XP: I think it only is if MagicHash is on
16:42:57 <SamB_XP> really ?
16:43:00 <SamB_XP> why's that?
16:43:17 <Megzlna> how could you forget the , sjanssen?
16:43:28 <sjanssen> SamB_XP: oh, sorry "op"name
16:43:34 <chrisdone> preflex: be poppavic
16:43:34 <preflex>  well, I also am known to on occasion ask sex/age priv - so I can figure out someones headspace, or what might offend.
16:43:37 <Saizan> i think it's just a bug in haskell-src-exts
16:43:42 <sjanssen> Megzlna: I was showing you what you wrote in another form, to clarify
16:43:47 <mokus> http://hpaste.org/13031
16:43:48 <twanvl_> SamB_XP: but it doesn't work if -fglasgow-exts is on
16:43:50 <Megzlna> sjanssen: riiight
16:43:52 <Megzlna> lol
16:44:07 * sjanssen will not be trolled
16:44:44 <Saizan> i guess MagicHash doesn't enable unboxed tuples?
16:45:10 <mokus> it does, but that's not unboxed tuple syntax
16:45:32 <mokus> i think anyway, I guess I could be wrong
16:45:34 <twanvl_> there is -XUnboxedTuples
16:45:52 <sjanssen> mokus: (#) will work with MagicHash on and off, but you'll get different results with "foo# 10" depending
16:46:14 <mokus> yea, but I had spaces
16:46:21 <mokus> and the parse error is on )
16:46:31 <mokus> I think it's trying to parse it as a magic tuple
16:46:37 <mokus> but failing
16:46:45 <twanvl_> > let ( # ) = flip ($) in [1..10] # map show
16:46:48 <sjanssen> mokus: what was the failing code again?
16:46:48 <lambdabot>   ["1","2","3","4","5","6","7","8","9","10"]
16:47:08 <mokus> that one :)
16:47:13 <mokus> without the spaces around #
16:47:47 <nolrai_East> @ty maybe
16:47:49 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:48:26 <mokus> sjanssen: http://hpaste.org/13031#a2
16:48:44 <mokus> ghci has the same problem, apparently
16:48:48 <teko> > [1..10]
16:48:50 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
16:49:16 <sjanssen> mokus: hmm, I guess UnboxedTuples turns (# into a single lexeme
16:49:25 <nolrai_East> @pl fmap f = maybe (ChoiceT Nothing) (fmap $ fmap f) . unChoiceT
16:49:25 <lambdabot> fmap = fix (flip flip unChoiceT . (((.) . maybe (ChoiceT Nothing)) .) . join (.))
16:49:26 <mokus> could be
16:49:32 <mokus> seems inappropriate to me ;-)
16:49:38 <teko> > let x = "meh"
16:49:40 <lambdabot>   <no location info>: parse error on input `;'
16:49:41 <teko> > x
16:49:43 <lambdabot>   x
16:49:48 <augustss> flip flip!
16:49:49 <sjanssen> mokus: meaning the code is interpreted as "(#" ")", so GHC is confused when you close a ")" without opening one
16:50:08 <mokus> sjanssen: yea, that was my theory too - I still call it wrong ;-)
16:50:10 <sjanssen> @type flip flip
16:50:12 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
16:50:23 <nolrai_East> ow
16:50:33 <sjanssen> @. pl . djinn type flip flip
16:50:34 <physique> haskell is a ridiculous language, ridiculously brilliant
16:50:36 <lambdabot> f = flip flip
16:50:41 <mokus> extensions are supposed to accept a superset of the code ;-)
16:50:59 * teko 'troll' sjanssen
16:51:19 <sjanssen> mokus: there are a few that don't.  TH, MagicHash, and UnboxedTuples.  Perhaps there are more
16:51:20 <augustss> mokus: that's very difficult in practice
16:53:45 <hoopy> > 8
16:53:48 <lambdabot>   8
16:54:08 <mokus> augustss: difficult bugs are still bugs ;-)
16:54:16 <hoopy> 3 `mod` 10
16:54:22 <hoopy> > 3 `mod` 10
16:54:25 <lambdabot>   3
16:56:01 <augustss> > pi `approxRational` 0.01
16:56:04 <lambdabot>   22%7
16:56:27 <hoopy> > `approxRational` 0.001
16:56:29 <lambdabot>   <no location info>: parse error on input ``'
16:56:33 <Megzlna> So to rephrase the original statement about 'a's:
16:56:34 <Megzlna> Any 'explicitly defined' type will be given a higher precedence than any literal's default type in cooperating in the determination for the type of 'a'.
16:56:34 <hoopy> > pi `approxRational` 0.001
16:56:36 <lambdabot>   201%64
16:56:45 <hoopy> *that* is cool
16:56:55 <Megzlna> because 1 has a default type
16:57:03 <guenni> hi, how can I arrange for "aborts" or early exists from the IO Monad?
16:57:04 <hoopy> > (/) 201 64
16:57:07 <lambdabot>   3.140625
16:57:19 <Megzlna> but the real question here is...
16:57:25 <mokus> guenni: as in you want to exit the whole program?
16:57:39 <Gracenotes> "
16:57:43 <Gracenotes> Italian TV cuts gay scenes from Brokeback Mountain"
16:57:44 <Megzlna> when I do: Any 'explicitly defined' type will be given a higher precedence than any literal's default type in cooperating in the determination for the type of 'a'.
16:57:48 <Megzlna> Sorry fuck pasted.
16:57:58 <guenni> mokus: no, not quite, just to stop evaluating the rest of the sequence
16:58:04 <Gracenotes> hrm
16:58:14 <tyfon> hmm will the compiler automatically paralellize my code or do i have to tell it to?
16:58:17 <mokus> guenni: like an exception?
16:58:21 <Megzlna> let f x y = x + y    // and you pass a 1 1 through, it's a 'Num' the whole entire time
16:58:26 <jamii> I just got the most useless error trying to buld darcs. Can anyone shed some light on this (pasted)?
16:58:34 <SamB_XP> tyfon: we gave up on automatic paralellization a LONG time ago
16:58:42 <mokus> guenni: Control.Exception has stuff for exception handling
16:58:45 <tyfon> oh ok ;)
16:58:50 <Megzlna> :t 1
16:58:51 <guenni> mokus: something rather less drastic
16:58:53 <lambdabot> forall t. (Num t) => t
16:58:59 <jamii> Huh. No paste announcement. http://hpaste.org/13032
16:59:12 <chrisdone> jamii: yeah, hpaste has been gone from IRC for months
16:59:27 <mokus> guenni: in that case, the answer might be no
16:59:37 <jamii> chrisdone: Any idea why? It was really useful
16:59:40 <chrisdone> I think the guy who maintains it has defected to Caml
16:59:40 <Megzlna> So at what point does printing cause    forall t. (Num t) => t  of '1' to print as an integer?
16:59:56 <jamii> The scandal!
17:00:11 <mokus> guenni: generally you could achieve that sort of thing by putting the conditionally executed parts as sub-dos in an if or a case expression
17:00:26 <chrisdone> jamii: well, he probably hasn't. but I was trying to think of something worse than death
17:00:36 <guenni> mokus: I aggree
17:00:40 <mokus> guenni: or just another function, possibly in a let or where
17:00:40 <Megzlna> If it's 'Num' till the very end, and 'read 1' is not enough type information
17:00:51 <jamii> Anyway, does anyone know what caused this http://hpaste.org/13032 ? It doesnt exactly give much information.
17:01:02 <jamii> chrisdone: Surely theres worse fates than ocaml
17:01:08 <SamB_XP> Megzlna: defaulting
17:01:14 <jamii> chrisdone: He could have defected to, say, Java
17:01:16 <Megzlna> SamB_XP Where does the default exist?
17:01:28 <SamB_XP> @report
17:01:28 <lambdabot> ()
17:01:32 <SamB_XP> @where report
17:01:32 <lambdabot> http://www.haskell.org/onlinereport/
17:01:54 <chrisdone> jamii: now you're just being ridiculous
17:02:09 <jamii> chrisdone: It could totally happen.
17:02:14 <chrisdone> ;_;
17:02:30 <jamii> chrisdone: Maybe just to the JVM, with something funky like clojure or scala
17:02:30 <chrisdone> that is indeed a useless error
17:02:38 <chrisdone> i'e
17:02:45 <daf> jamii: look in configure.log?
17:02:51 <SamB_XP> darnit
17:02:52 <chrisdone> err. I mean, I approve of clojure and scala
17:02:54 <jamii> daf: Good point
17:02:56 <SamB_XP> I can't remember who wrote hpaste
17:03:09 <chrisdone> got to stop speaking lojban in english conversations
17:03:12 <sclv> glguy did
17:03:16 <sclv> he's still haskell
17:03:30 <chrisdone> he also wrote hpaste2, which is one EXPERT WEB APPLICATION
17:03:39 <pumpkin> who owns hpaste.org?
17:03:42 <chrisdone> for example: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=39#a39
17:03:43 <pumpkin> could it just be updated to hpaste2?
17:03:51 <chrisdone> isn't it shapr who runs hpaste?
17:03:56 * pumpkin registers hpaste2.org :P
17:03:57 <Megzlna> What is the official name for a value which is in an indeterminate type state?
17:03:57 <chrisdone> shapr: ping
17:04:09 <Megzlna> In D, they're called "polysemous values"
17:04:21 <BONUS> you mean type constructor?
17:04:24 <jamii> configure: failed program was:
17:04:26 <jamii> main = putStr "Hello world!\n"
17:04:26 <Megzlna> BONUS: 1
17:04:28 <jamii> Not promising...
17:04:35 <SamB_XP> I think she means like []
17:04:37 <BONUS> (Either a)
17:04:40 <Megzlna> 1 :: (Num t) => t
17:04:42 <sclv> dunno why we haven't moved to #2 yet... it still needs some tweaks I think.
17:04:44 <Megzlna> :t []
17:04:46 <lambdabot> forall a. [a]
17:04:47 <Megzlna> or that, too
17:06:31 <devragert> can someone help me:
17:06:48 <devragert> ?
17:06:56 <pumpkin> devragert: we'll know once we know what you need help with
17:07:48 <devragert> i have made some function, which should rewrite all expressions in a general formula, but it doesnt work
17:07:56 <hoopy> oh holy yay
17:07:56 <devragert> i will explain:
17:08:02 <hoopy> ghc is finally done compiling
17:08:07 <Megzlna> "polysemous: Having or characterized by many meanings: highly polysemous words such as play and table."
17:08:11 <jamii> Huzzah. It works. Thanks daf
17:08:17 <sclv> devragert: can you paste to hpaste
17:08:26 <mokus> Megzlna: typeclass-bounded polymorphic
17:08:32 <daf> jamii: welcome
17:08:32 <devragert> ok
17:08:41 <Megzlna> mokus: lol is that official?
17:08:53 <hoopy> what module is `approxRatio` in?
17:08:54 <pumpkin> Megzlna: in this case, it's not the meaning that's changing, but the types? it seems that the "meaning" of 1 is consistent across all types it could be bound to
17:08:56 <mokus> Megzlna: more or less, I think
17:09:25 <mokus> Megzlna: or more often just "polymorphic" which also covers just plain ':: a'
17:09:28 <Megzlna> pumpkin: the interesting part is how you can even perform operations while it retains the polymorphism
17:09:33 <Megzlna> (1 + 1) :: (Num t) => t
17:09:37 <pumpkin> Megzlna: yeah
17:10:19 <daf> Megzlna: well, operations are always on concrete types
17:10:36 <Megzlna> daf: so how does 1 + 1 happen?
17:10:37 <devragert> i have put it on hpaste
17:10:51 <nolrai_East> does liftm === fmap ?
17:11:01 <devragert> (it's the rewriting stuff)
17:11:09 <Megzlna> Is that really somehow lazy in a way, until the 'a' is introduced somewhere
17:11:11 <Asztal> nolrai_East, yes
17:11:20 <jamii> Megzina: It doesnt happen until you give it a concrete type
17:11:25 <pumpkin> Megzlna: yeah
17:11:29 <Megzlna> nuts ;)
17:11:38 <pumpkin> Megzlna: you see that with the "empty" types too
17:11:45 <pumpkin> in Data.Map for example
17:12:04 <pumpkin> the map doesn't have a real key/value type until you stick something into it
17:12:10 <pumpkin> (same with list, obviously)
17:12:17 <Megzlna> But is it 'lazy' on the same level as we normally refer to lazy?
17:12:22 <Megzlna> or lazy on the type level
17:12:37 <devragert> can someone look at http://hpaste.org/13033 for me
17:12:38 <daf> it's lazy until you compile it
17:12:40 <pumpkin> Megzlna: it just likes to retain its generality as long as possible, I guess?
17:12:47 <daf> is one way to think of it
17:13:49 <jamii> It would be a lot easier to build stuff if I could convince my laptop to stop translating things into russian.
17:14:07 <luite_>  /whois jamii
17:14:09 <luite_> oops
17:14:10 <mokus> Megzlna: most (all?) current implementations work by passing an invisible parameter which is a dictionary pointer that gives the implementation for all the typeclass methods
17:14:27 <daf> jamii: export LANG=C?
17:14:30 <luite_> jamii: was wonderingif you actually know russian :)
17:14:36 <llayland> No joke, I just found a inspection sticker from Haskell Termite and Pest Control under my kitchen sync.
17:14:42 <Megzlna> mokus: And you pay that price even on Int's eh
17:14:54 <Megzlna> and you must use a GHC extension
17:14:54 <mokus> Megzlna: often the compiler can optimize that out, but sometimes it can't and that's how the function can still be polymorphic after separate compilation
17:14:58 <Megzlna> to get native Numbers
17:15:19 <mokus> Megzlna: Ints are "native", they're just boxed
17:15:25 <Megzlna> what's the unpolymorphic numbers extension called?
17:15:26 <SamB_XP> mokus: well, JHC does NOT work by passing a representation of each typeclass parameter to the code ... but that's only because it doesn't work -- it would work that way if it worked at all ;-P
17:15:28 <Megzlna> Rather
17:15:30 <Megzlna> Unboxed numbers
17:15:39 <Megzlna> Ah
17:15:43 <Megzlna> Unboxed types extension ;)
17:15:48 <jamii> luite_: No. A russian friend borrowed my laptop and somehow messed up i8ln. Even with everything set back to english and after reinstalling all the language packages, random russian translations persists
17:15:52 <jamii> *persist
17:16:22 <thoughtpolice> yeah the way jhc/lhc handle typeclasses is interesting.
17:16:33 <daf> hmm
17:16:37 <Megzlna> mokus: So rather than saying "typeclass bounded polymorphic", wouldn't a "boxed 1" do?
17:16:47 <daf> does compiled code that uses existentials preserve the dictionaries?
17:16:52 <jamii> daf: No luck with LANG
17:17:04 <devragert> can someone help me with this: http://hpaste.org/13033#a2
17:17:10 <daf> jamii: does the "locale" command mention ru?
17:17:16 <mokus> Megzlna: not really - boxed refers to special handling of a native type
17:17:28 <Megzlna> so it's not general enough
17:17:33 <mokus> Megzlna: a Num doesn't have to be a native type
17:17:34 <mokus> right
17:17:44 <SamB_XP> Megzlna: boxed means that it goes on the heap
17:17:48 <SamB_XP> just like in LISP
17:18:00 <jamii> daf: Nope. And both gnome and kde are set to english everywhere. Both gnome and kde apps are broken
17:18:18 <daf> jamii: that's... different
17:18:20 <Megzlna> SamB_XP: Whereas unboxed types can go into the static code
17:18:20 <luite_> devragert: did you forget some 'tmap'? so (tmap f x) instead of (f x) ?
17:18:20 <thoughtpolice> SamB_XP: why are jhc/lhc's typeclasses broken, fwiw (i'd like to know since I'm working with lhc)
17:18:24 <SamB_XP> jamii: checked your environment ?
17:18:35 <SamB_XP> thoughtpolice: well, I don't know
17:18:47 <Megzlna> And an unboxed type cannot be   (Num t) => t, right?
17:18:51 <SamB_XP> but I look at the archives of the jhc list on gmane to see how
17:18:53 <mokus> Megzlna: "unboxed" usually means passed in registers without pointers
17:18:53 <devragert> hmm.. maybe
17:18:57 <SamB_XP> s/I //
17:19:08 <jamii> daf: Yep. The worst part is I reinstalled the os, leaving /home untouched, and its still in russian. So the problem is lurking somewhere in /home
17:19:15 <mokus> Megzlna: right, uunboxed values in haskell can't participate in any kind of polymorphism
17:19:16 <daf> hmm, I guess all typeclass-using code needs to go through dictionaries
17:19:17 <luite_> devragert: your tmap looks an awful lot like fmap, you probably already know that :)
17:19:33 <Megzlna> ok, great insights there ;)
17:19:33 <thoughtpolice> SamB_XP: hm
17:19:39 <daf> jamii: binary search time!
17:19:52 <SamB_XP> thoughtpolice: some kind of mismatch between caller and callee in terms of what order to pass the types in iirc
17:19:53 <mokus> Megzlna: at least, in ghc - and afaik the hskell repord doesn't have unboxed types at all
17:19:56 <daf> jamii: repeatedly delete half your home directory until the problem goes away!
17:20:05 <thoughtpolice> SamB_XP: ah
17:20:26 <jamii> daf: Learning russian might be easier...
17:20:52 <jamii> daf: I only have to survive until my XO arrives.
17:20:55 <SamB_XP> thoughtpolice: I didn't see any issues until I tried to build Control.Arrow (or was it Control.Category?)
17:21:01 <daf> jamii: haha
17:21:07 <devragert> yes, but i had to define tmap because my Term is not a functor
17:21:07 <daf> jamii: I hope you have an external keyboard
17:21:19 <jamii> daf: I have small fingers?
17:21:25 <Megzlna> Does GHC's optimizer do unboxing when it sees you, for example, passing :: Int explicitly ?
17:21:26 <SamB_XP> (and that was after getting the RULES into JHC-friendly syntax)
17:21:37 <luite_> devragert: that's why I mentioned it, you can make it a functor
17:21:38 <daf> jamii: tell me that again in a month
17:21:56 <SamB_XP> Megzlna: it does unboxing when strictness analyis suggests that it would be appropriate, basically
17:21:58 <devragert> btw: (tmap f x) instead of (f x) doesn't work either...
17:22:17 <devragert> how?
17:22:25 <devragert> i don't think so
17:22:41 <mokus> Megzlna: what SamB_XP said brings up another thing unboxed types can't do in ghc - they can't be lazy
17:22:54 <SamB_XP> they can't ever be lazy
17:22:57 <jamii> daf: Also, during a random seminar I learned a really good way to handle small keyboards. Changing the keyboard driver to ignore fast (say <100ms) sequences of key presses massively increases accuracy
17:22:58 <Megzlna> ah
17:23:00 <SamB_XP> lazyness requires indirection
17:23:06 <devragert> i will put the data type of Term there as well
17:23:26 <daf> jamii: I got better at them with practice
17:23:35 <SamB_XP> there are even some boxed, but unlifted, types in GHC that can't be lazy
17:23:35 <daf> jamii: but I still found them pretty frustrating
17:23:46 <daf> jamii: but I think my hands are pretty big
17:24:06 <mokus> SamB_XP : an implementation could use the extra 2 bits that the haskell report graciously gives us in Ints to have an "indirect" flag ;-)
17:24:09 <luite_> devragert: what goes wrong?
17:24:16 <pumpkin> I'm confusing myself with types
17:24:17 <jamii> daf: I actually find my laptop keyboard too big. I cant reach it all without moving my hands
17:24:32 <SamB_XP> mokus: oh, well, sokay, so it could unbox Ints too in some cases
17:24:43 <athos> is there some standard datatype for arbitrary large floating point numbers?
17:24:52 <athos> so what Integer is for ints
17:24:52 <SamB_XP> athos: arbitrarily ?
17:24:55 <Megzlna> pumpkin: What part of types confused?
17:25:01 <SamB_XP> you mean with Integer for the exponent ?
17:25:13 <mokus> athos: not in the standard library, although there's Rational
17:25:14 <augustss> athos: there's a crap implemetation in the numbers package
17:25:14 <SamB_XP> (what about the small ones?)
17:25:15 <jamii> daf: I think corrective drivers will make a big difference. The slideshow said that they got people up to 60fps on a blackberry after a couple hours practice.
17:25:16 <thoughtpolice> SamB_XP: oi, for lhc to use haskell-src-exts I think the entire frontend will need to be rewritten. :( although hopefully it should iron out some parsing bugs
17:25:18 <pumpkin> Megzlna: how to structure a rather complicated type situation, trying to work it out on my own first
17:25:33 <devragert> when i apply rewrite to a function, it looks like he applies rewritingRules just on the uppermost level, it doesn't go in nested expressions
17:25:39 <daf> jamii: if I speead one of my hands, it's nearly as wide as my laptop :P
17:25:47 <SamB_XP> thoughtpolice: it could certainly use some lovin'
17:25:55 <SamB_XP> does HSX have a type checker ?
17:26:01 <devragert> (when i apply rewrite to an expression i mean)
17:26:04 <jamii> daf: Um ... wow. Those are big hands
17:26:13 <pumpkin> or a small laptop
17:26:21 <Megzlna> So I originally said:
17:26:22 <BMeph> athos: CReal is the most popular one. :)
17:26:29 <athos> BMeph: thx
17:26:41 <Megzlna> "Any 'explicitly defined' type will be given a higher precedence than any literal's default type in cooperating in the determination for the type of 'a'."    <--- WRONG
17:26:42 <thoughtpolice> SamB_XP: no, but at least we have a working parser to build on (and a lot of literature.) i've got a branch sitting around with some attempt at replacing HsParser.y with haskell-src-exts, but it's kind of nasty
17:26:52 <jamii> Oh dear...
17:26:54 <jamii> [02:26] [Whois] daf is a user on channels: #haskell
17:26:55 <jamii> [02:26] [Whois] daf на связи через irc.freenode.net (http://freenode.net/).
17:26:56 <jamii> [02:26] [Whois] daf идентифицирован.
17:26:58 <Megzlna> only 'show' happens to pick 'Int' for 'Num'
17:26:58 <jamii> [02:26] [Whois] daf идентифицирован.
17:26:59 <thoughtpolice> and will at the very least require a shitload of manual changes to change the data type names
17:27:00 <jamii> [02:26] [Whois] End of WHOIS list.
17:27:00 <luite_> devragert: hm, I think that with the (tmap f x) everywhere it should work... and I guess you'll also want: tmap f x = f x
17:27:01 <thoughtpolice> :(
17:27:01 <jamii> Not helpful
17:27:12 <Megzlna> because otherwise it would be Fractional
17:27:18 <Megzlna> :t show 1
17:27:20 <lambdabot> String
17:27:39 <mokus> Megzlna: there's a very specific and very limited set of rules for defaulting
17:27:45 <mokus> it's outlined in the haskell report
17:27:52 <luite_> devragert: you can make it an instance of Functor by saying instance Functor Term where fmap = ...
17:27:53 <mbz> jamii, it is time to start learning russian ;)
17:27:59 <roconnor> CReal isn't floating point
17:28:18 <SamB_XP> roconnor: is it fixed point ?
17:28:27 <augustss> roconnor: No, but BigFloat is
17:28:28 <devragert> no, because Term is not of the form Term a
17:28:30 <jamii> mbz: I wouldnt actually mind. It does sound cool. I think I can get free language lessons too
17:28:32 <jsn> jamii: maybe you're stuff got compiled that way?
17:28:41 <jsn> s/you're/your/
17:28:52 <luite_> devragert: oh ok, sorry
17:28:53 <augustss> SamB_XP: CReal are real numbers
17:28:55 <roconnor> SamB_XP: no, but augustss has a fixed point implementation
17:28:57 <jamii> jsn: No, it persisted when I reinstalled my os. So its something in my home dir
17:29:02 <jsn> hmm
17:29:17 <SamB_XP> augustss: only some of them, as I gather
17:29:17 <jamii> jsn: beagle search for 'ru' doesnt find anything relevant though
17:29:31 <SamB_XP> since apparantly there are a lot of them that aren't constructive
17:29:36 <augustss> SamB_XP: depends what you believe in
17:29:38 <devragert> i already tried with alternative tmap definition, but it still didn't work
17:29:39 <jamii> jsn: Although I dont think my beagle index is properly up to date
17:29:46 <jsn> jamii: ah
17:29:50 <devragert> but anyway thanks for your help
17:29:51 <SamB_XP> well, okay, I actually don't believe in those ones myself ;-P
17:29:53 <luite_> devragert: that's what I assumed, Term a, and f::a->a, but I now see it isn't
17:29:53 <roconnor> SamB_XP: whether CReal contains all real numbers is a matter of philosophy
17:30:04 <jsn> i was going to say, could try brutally egrepping everything
17:30:13 <jamii> Actually, is russian abbreviated to ru *in russian*. To the internet...
17:30:22 <SamB_XP> so ... what's an uncomputable thing ?
17:30:34 <roconnor> There is a classical isomorphism between CReals and classical reals
17:30:46 <roconnor> but the isomorphism isn't constructive
17:30:52 <SamB_XP> jamii: what does locale(1) have to say ?
17:31:08 <jsn> jamii: the locale codes are set by some ISO
17:31:10 <daf> SamB_XP: he said it didn't mention ru
17:31:21 <jsn> jamii: they don't vary by locale
17:31:25 <SamB_XP> did he delete all the russion locale files ?
17:31:25 <pumpkin> I'm going back to this problem http://hpaste.org/13034 ... I'm trying to find a type-level way to express endiannesses and address sizes of individual architectures, but am having trouble doing that
17:31:44 <jsn> jamii: what OS is it?
17:32:00 <daf> SamB_XP: that would seem a bit like attacking symptoms
17:32:04 <jamii> SamB_XP: All C
17:32:10 <jamii> jsn: Both ubuntu and opensuse
17:32:16 <shapr> chrisdone: y0
17:32:22 <pumpkin> whoops, that paste is inconsistent
17:32:35 <BMeph> pumpkin: Did you get any inspiration for that from Data.Binary? :)
17:32:38 <shapr> So, where's hpaste moving?
17:32:48 <jamii> SamB_XP: I dont think all the locale files were deleted. I certainly cant find them, but I dont see what else would cause this
17:32:51 <luite_> devragert: I still don't see how tmap would actually work... the way you implemented it can either only work on the top level (without tmap), or rewrite the leafs
17:32:55 <pumpkin> BMeph: I'm using it to read stuff in, if that's what you're asking :P http://hpaste.org/13035 is the new one
17:33:33 <SamB_XP> jamii: I was suggesting that you delete the russion ones so that stuff reverts to the non-translated strings ;-P
17:34:57 <pumpkin> scratch the maybe in Architecture
17:35:36 <mokus> pumpkin: looks like a kind error on CpuType
17:35:44 <mokus> or is that why you're scratching the maybe?
17:36:04 <necroforest> Does GHC come bundled with any math libraries (i.e, Matrices and vectors)
17:36:22 <pumpkin> BMeph: I'm trying to find the most elegant way to represent that this file format can be big-endian, little-endian, have 64-bit addresses, 32-bit addresses, and have a set of CPU designations (which I'd like to be consistent with the address bit size and endianness)
17:36:27 <jamii> necroforest: No, but there are plenty on hackage
17:36:30 <devragert> let me see
17:36:34 <devragert> wait
17:36:51 <pumpkin> mokus: hmm
17:37:22 <SamB_XP> pumpkin: are you trying to implement ELF ?
17:37:37 <pumpkin> SamB_XP, nope, trying to implement MachO, which is more complicated than ELF
17:37:38 <pumpkin> :P
17:37:45 <SamB_XP> suckage!
17:38:06 <jamii> necroforest: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Math
17:38:31 <augustss> pumpkin: you seem to have some confusion about what you are trying to represent on the type level and what on the value level
17:38:39 <pumpkin> augustss: you're right :)
17:38:44 <devragert> the way it works is as follows: first it checks the top level: if rewritable, then it is rewritten, and applies again the rewrite function to the whole formula, else it goes on with the next level, and does the same there etc.
17:38:47 <SamB_XP> augustss: can you blame him?
17:38:52 <SamB_XP> that stuff is HARD
17:38:52 <Adamant> pumpkin: trying to do universal binaries?
17:39:01 <pumpkin> Adamant: among other things, yes
17:39:01 <augustss> pumpkin: I'd skip type parameters in a first try
17:39:03 <jamii> necroforest: I havent used any of those myself but I think the blas bindings have received a lot of attention, they're probably your best bet
17:39:43 <pumpkin> augustss: well, I already know how to do it except for this :P I was trying to use types in a more sophisticated manner but ended up getting myself confused :P
17:40:06 <jamii> necroforest: If you just want to do something simple use Data.Array
17:40:21 <mokus> pumpkin : are you basically just looking to get that compiling?
17:40:24 <pumpkin> I originally had it simply parametrized by "address type", with an Either Word32 Word64
17:40:35 <augustss> pumpkin: well, you need to decide what you are trying to accomplish on the type level
17:41:30 <pumpkin> augustss: from a high level, I'd like to make sure all the types are consistent (in terms of endianness and address size), including the enumerated cpu types
17:41:43 <pumpkin> it seemed like a good idea at the time to use fancy types
17:41:47 <pumpkin> :)
17:41:51 <erikc> pumpkin: why does it have to be encoded in types (i struggled with a similar issue for Data.Elf and just punted)
17:41:59 <pumpkin> erikc: it doesn't have to
17:42:08 <pumpkin> erikc: it was just a challenge for myself :P
17:42:12 <erikc> ah hehe
17:42:17 <erikc> i just promote everything to host order 64-bit when reading it
17:42:18 <augustss> pumpkin: it sounds like a plan, indeed. :)
17:42:31 <pumpkin> erikc: yeah, I saw the elf one :) looks neat
17:42:37 <pumpkin> but machO adds even more complexity
17:42:38 <luite_> devragert: but at the moment, the tmap is only applied to the top level. unless your f also calls tmap itself, the rest will never be rewritten
17:42:55 * pumpkin ponders
17:43:09 <erikc> yea, i dont have to deal with multiple uh, what are they called, fat executables or wahtever
17:43:21 <pumpkin> erikc: yeah... it really is a huge mess
17:43:37 <pumpkin> there's no indication until you open the file whether it actually contains multiple executables
17:43:47 <luite_> devragert: ah I now see what you do
17:43:55 <Adamant> pumpkin: it's hard to write 0xCAFEBABE
17:44:03 <luite_> devragert: it's late here ;)
17:44:09 <pumpkin> Adamant: huh? :)
17:44:19 <Adamant> pumpkin: the constant
17:44:22 <devragert> you see?
17:44:23 <pumpkin> why is it hard?
17:44:24 <augustss> 0xDEADBEEF
17:44:33 <devragert> (it's late here too)
17:44:37 <saml> >  0xDEADBEEF
17:44:38 <pumpkin> they use a bunch of those to indicate endianness and fatness
17:44:39 <lambdabot>   3735928559
17:44:47 <Adamant> yeah
17:44:49 <luite_> devragert: yeah you seem to be in the same country as I am ;)
17:44:50 <Adamant> CAFEBABE is one
17:44:51 <pumpkin> and word size
17:44:53 <pumpkin> yup
17:44:55 <pumpkin> I mean, why is it hard?
17:45:02 <Adamant> I was joking
17:45:05 <pumpkin> oh :P
17:45:20 <Adamant> it's the interwebs, there is no context in these pipes
17:45:34 <pumpkin> I mean, structurally, based on what you read at the beginning, the file could be composed of multiple mach-o structures, of different endiannesses, address sizes, and other nastiness
17:45:42 <devragert> i think i already have seen an error, but fixing it still didn't solve the problem (namely the second line: see newest version on hpaste)
17:45:52 <pumpkin> there's no guarantee the different binaries are even doing the same stuff (and there can't be of course)
17:46:10 <hoopy> > ['f','o','o']
17:46:12 <lambdabot>   "foo"
17:46:24 <pumpkin> > 'f':'o':'o':[]
17:46:26 <lambdabot>   "foo"
17:46:58 <hoopy> so 'o' is a list with one element?
17:47:03 <pumpkin> hoopy: nope
17:47:06 <pumpkin> it's a Char
17:47:17 <pumpkin> I get the feeling I'll need GADTs and existential types for this, if I keep trying
17:47:18 <hoopy> 1:9:[] will blow up right?
17:47:24 <hoopy> > 1 : 9 : []
17:47:26 <lambdabot>   [1,9]
17:47:26 <pumpkin> hoopy: nope?
17:47:28 <BMeph> hoppy: No, that's fine. :)
17:47:37 <hoopy> alright that's why i was confused
17:47:47 <BMeph> ?
17:48:11 <hoopy> > "" == []
17:48:13 <lambdabot>   True
17:48:19 <augustss> pumpkin: To do it right I think you need dependent types.
17:48:49 <pumpkin> augustss: hmm, I've only ever heard of those in the context of ints, how would I need it here?
17:49:07 <mpeter> > (fix (1:)) == [1..1]
17:49:08 <lambdabot>   False
17:49:26 <hoopy> > [1..1]
17:49:27 <lambdabot>   [1]
17:49:28 <augustss> pumpkin: The type of subsequent parts of the file depends on the value of something in the header.
17:49:32 <pumpkin> > (fix (1:)) == [1,1..1]
17:49:33 <mpeter> no wonder
17:49:40 <roconnor> True
17:49:43 <hoopy> > fix (1:)
17:49:45 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:49:45 <augustss> pumpkin: types depending on values == dependent types
17:49:48 <lambdabot>   thread killed
17:49:53 <hoopy> infinite?
17:50:02 <roconnor> er
17:50:03 * hoopy is nubbish
17:50:09 <roconnor> [1,1..1]
17:50:11 <pumpkin> augustss: hmm that makes sense... does it also make it impossible to do in haskell currently?
17:50:15 <roconnor> > [1,1..1]
17:50:17 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:50:31 <roconnor> intresting
17:50:34 <BMeph> augustss: Why couldn't we have first-class types in Haskell? Since you're a Founder, I blame YOU! ;p
17:50:42 <roconnor> I guess that is right
17:50:47 <pumpkin> > length [(1 :: Word8) ..]
17:50:49 <lambdabot>   255
17:50:57 <erikc> pumpkin: a similar problem occurs with ELF if i wanted to fully parse the meaning of the ELF for the osabi/machine (since many fields have reserved meanings based on processor/os)
17:50:59 <hoopy> the difference between 1 and 1 is 0
17:51:03 <augustss> pumpkin: yeah, but you can probably get pretty close.  But it will be messy
17:51:08 <roconnor> > length [(minBound :: Word8) ..]
17:51:10 <lambdabot>   256
17:51:17 <hoopy> so 1,1..1 would be incrementing 1 by zero and moving to the next element
17:51:20 <pumpkin> erikc: yeah :/ these ugly file formats straining our poor types!
17:51:27 <roconnor> hoopy: incrementing by 0
17:51:33 <roconnor> yes
17:51:33 <erikc> the way i'd do it from there is make a higher level rep for each processor/osabi and parse the more general version to one of those
17:51:35 <augustss> BMeph: I was not!  I take no blame!  I got on the committee later.
17:51:36 <roconnor> sorry
17:52:29 <BMeph> augustss: Ha-ha, sure blame it on "the committee", why don't ye? ;)
17:52:30 <erikc> i think ELF (and DWARF) are pretty elegant binary file formats :), well normalized
17:52:40 <hoopy> > e
17:52:42 <lambdabot>       Ambiguous occurrence `e'
17:52:42 <lambdabot>      It could refer to either `L.e', defined a...
17:52:50 <roconnor> @undefine
17:52:52 <augustss> > exp 1
17:52:54 <lambdabot>   2.718281828459045
17:53:06 <roconnor> > showCReal 100 (exp 1)
17:53:08 <lambdabot>   "2.718281828459045235360287471352662497757247093699959574966967627724076630...
17:53:09 <augustss> > exp 1 :: CReal
17:53:11 <lambdabot>   2.7182818284590452353602874713526624977572
17:53:17 <devragert> i'm going to sleep, maybe i gan fix the problem tomorrow
17:54:27 <pumpkin> erikc: probably nicer than the fat mach-o monster, but it doesn't take much :)
17:56:23 <hoopy> > it
17:56:25 <lambdabot>   Not in scope: `it'
17:56:35 <hoopy> is `it' just for ghci?
17:56:50 <int-e> hoopy: yes
17:57:02 <hoopy> so it's like _ in irb
17:57:24 <Megzlna> is there a better way to get the size of types than  > length [(minBound :: Word8) ..]  ?
17:58:12 <Megzlna> > (maxBound :: Word8)
17:58:14 <lambdabot>   255
17:58:16 <int-e> > fromIntegral (maxBound :: Word8 - minBound :: Word8) + 1
17:58:18 <lambdabot>   <no location info>: parse error on input `-'
17:58:44 <int-e> > fromIntegral (maxBound - minBound :: Word8) + 1
17:58:46 <lambdabot>   256
17:58:52 <roconnor> > bitsize (undefined::Word8)
17:58:53 <lambdabot>   Not in scope: `bitsize'
17:58:54 <pumpkin> it only works on bounded types though
17:58:58 <roconnor> > bitSize (undefined::Word8)
17:59:00 <lambdabot>   8
17:59:18 <int-e> > fromIntegral (maxBound - minBound :: Ordering) + 1
17:59:20 <lambdabot>       No instance for (Integral Ordering)
17:59:20 <lambdabot>        arising from a use of `fromI...
17:59:23 <Megzlna> how do you get the size of a type at compile time, so you can use it with TH?
17:59:31 <pumpkin> @instances Integral
17:59:33 <lambdabot> Int, Integer
18:00:12 <int-e> > fromIntegral (fromEnum (maxBound :: Ordering) - fromEnum (minBound :: Ordering)) + 1 -- hmm.
18:00:14 <lambdabot>   3
18:00:22 <pumpkin> is there some way I can ask for all typeclasses Int falls into?
18:00:51 <int-e> pumpkin: :i Int  on ghci helps if the right modules are loaded.
18:01:01 <int-e> s/on/in/
18:01:39 <erikc> megzlna: what do you mean by the size of a type?
18:02:06 <Megzlna> the unsigned range, and also the size in bytes
18:02:37 <int-e> @index sizeOf
18:02:37 <lambdabot> Foreign.Storable, Foreign
18:03:13 <Megzlna> ah... FFI does some work here eh
18:03:40 <erikc> only for foreign language interaction though
18:03:47 <int-e> Megzlna: it lies. it'll tell you the size of the corresponding C data type (if the instance is correctly implemented)
18:04:49 <Megzlna> then, well, how do you properly implement for example an IO based containeer that allocated contiguous memory of the size of some type, rather than a contiguous array of pointers to the real values elsewhere on the heap
18:05:21 <pumpkin> you really like that contiguous memory :)
18:05:44 <Megzlna> pumpkin only cause I asked a few times but the answer to that one slipped through cracks
18:05:49 <augustss> Megzlna: you want the FFI for that kind of low level nastiness
18:06:04 <Megzlna> augustss: so don't implement it in Haskell?
18:06:08 <BMeph> Megzlna: If you're that obsessed with implementation details, you should ask the compiler developers - i.e., ask this on #ghc. We're not strictly theoretical here, but it is encouraged. ;)
18:06:20 <erikc> you'll have to dig around in Foreign to find the APIs for that, and be careful of its gc interaction and such, then build around that
18:06:28 <augustss> Megzlna: nono, it has all kinds of functions to do what you want
18:06:33 <int-e> Megzlna: you use Storable to store these values - http://hackage.haskell.org/cgi-bin/hackage-scripts/package/storablevector comes to mind.
18:06:48 <Megzlna> and I have to make a lock free queue for haskell hence the contiguous need -- else cannot use haskell
18:07:01 <Megzlna> coz for dsp
18:07:17 <pumpkin> @wn coz
18:07:18 <lambdabot> No match for "coz".
18:07:23 <roconnor> Megzlna: why not use STM?
18:07:26 <Megzlna> BMeph, erikc, augustss, int-e: thanks
18:07:28 <Megzlna> STM?
18:07:34 <Megzlna> software trans mem in haskell?
18:07:37 <Megzlna> is that a lib
18:07:38 <pumpkin> software-transactional memory
18:07:40 <roconnor> yes
18:07:41 <roconnor> yes
18:07:41 <BMeph> @go Peyton STM
18:07:44 <lambdabot> http://research.microsoft.com/~simonpj/papers/stm/
18:07:44 <lambdabot> Title: Papers on transactional memory
18:08:00 <BMeph> Woot! It worked! :)
18:08:16 <teko> @wn map
18:08:17 <hoopy> > :type 3 + 2
18:08:17 <lambdabot> *** "map" wn "WordNet (r) 2.0"
18:08:17 <lambdabot> map
18:08:17 <lambdabot>      n 1: a diagrammatic representation of the earth's surface (or
18:08:17 <lambdabot>           part of it)
18:08:17 <lambdabot>      2: a function such that for every element of one set there is a
18:08:19 <lambdabot> [15 @more lines]
18:08:21 <lambdabot>   <no location info>: parse error on input `:'
18:08:48 <teko> :t (3 + 2)
18:08:49 <lambdabot> forall t. (Num t) => t
18:08:58 <Megzlna> has Simon Peyton J ever been on this chan
18:09:07 <roconnor> no
18:09:29 <roconnor> but you can watch videos of him talking about STM
18:09:50 <dons> Megzlna: yes.
18:09:55 <dons> but very rarely.
18:09:56 <roconnor> he has?
18:09:59 <Megzlna> I'm a bit afraid of watching videos of him talk about anything at this point
18:10:00 <dons> yup
18:10:00 <roconnor> cool
18:10:06 <dons> Megzlna: he's inspiring
18:10:12 <dons> i recommend the oscon videos on the wiki
18:10:24 <Nafai> I love watching videos of SPJ
18:10:28 <pumpkin> augustss: with my question, simplifying it a bit, is it possible for me to have something a bit like data Moo = forall a. Integral a => ConstructorOne Int | ConstructorTwo Integer (that syntax doesn't work, but is there some way to make something that conceptually works like that?)
18:10:32 <augustss> Megzlna: afraid?
18:10:32 <Nafai> His enthusiasm is contagious
18:10:39 <sjanssen> Megzlna: why afraid?
18:10:47 <dons> he'd be hooked
18:10:52 <dons> and have to write a monad tutorial
18:10:52 <Megzlna> Cause he was speaking so fast that it drove me nuts
18:10:54 <pumpkin> lol
18:11:16 <augustss> pumpkin: what's the purpose of the type variable a?
18:11:18 <pumpkin> Megzlna: I've heard people refer to use as he and she... is there a correct one?
18:11:28 <Nafai> dons: Heh!
18:11:32 <pumpkin> augustss: good question :P
18:11:37 * pumpkin thinks some more
18:11:38 <dons> roconnor: 06.07.13:09:15:57 <simonpj> Shapr, edwardk, Thank you for nice comments about papers. I enjoy writing them
18:11:52 <Megzlna> neat
18:11:55 <roconnor> neat
18:12:07 <augustss> pumpkin: you can do something like that, but without the a somewhere it's pointless
18:12:18 <Megzlna> re: his speed of speech, it would be nice in person
18:12:18 <pumpkin> augustss: yeah, I just realized that the a isn't used
18:12:59 <pumpkin> this is hard to think about :P
18:13:35 <pumpkin> augustss: I guess I'm trying to use it a bit like "type pattern matching"
18:13:46 <pumpkin> but that still doesn't make much sense
18:13:49 <augustss> pumpkin: maybe you want data Moo = forall a . Integral a => Constructor a
18:14:08 <Megzlna> f :: (Num a) => a -> a    // do you ever call it a typeclass variable, or always a type variable?
18:14:14 <hoopy> so... how does one exit ghci?
18:14:16 <pumpkin> augustss: I do sort of, but eventually I want to "attach" that a to a concrete type
18:14:18 <pumpkin> hoopy: :q
18:14:38 <hoopy> thanks
18:14:42 <mokus> Megzlna: not a typeclass variable, because it doesn't stand for a typeclass
18:14:43 <roconnor> I would always call it a type variable
18:14:48 <augustss> pumpkin: hmmm, I don't understand what that means
18:15:02 <pumpkin> augustss: neither do I :P
18:15:09 * pumpkin 's head explodes
18:15:13 <pumpkin> (just for a change)
18:15:24 <int-e> @ghc
18:15:24 <lambdabot> ghc says: Occurs check: cannot construct the infinite kind
18:15:24 <sjanssen> Megzlna: always a type variable
18:15:46 <augustss> pumpkin: it must have been the lantern inside that exploded
18:15:57 <idnar> infinite kind, wow
18:16:06 <Megzlna> doesn't stand for a typeclass, is rather only constrained by
18:16:12 <sjanssen> how the heck do you construct the infinite kind?
18:16:13 <augustss> mmmm, infinite kinds
18:16:23 <pumpkin> augustss: probably, it happens sometimes :/
18:16:23 * sjanssen boggles
18:16:27 <augustss> sjanssen: don't ask ghc
18:16:28 <mokus> sjanssen: I don't remember but I've done it ;-)
18:16:32 <idnar> sjanssen: you can't, didn't you read the message?!
18:16:35 <idnar> :D
18:17:09 <sjanssen> oh, I gues "a a" might do it?
18:17:40 <augustss> :k a a
18:17:41 <lambdabot> Not in scope: type variable `a'
18:17:41 <lambdabot> Not in scope: type variable `a'
18:17:49 <augustss> :k forall a . a a
18:17:52 <lambdabot>     `a' is not applied to enough type arguments
18:17:54 <lambdabot>     Expected kind `k', but `a' has kind `k -> k1'
18:17:55 <teko> i want to do this :   map (makeNeg a = -a) [1,2,3]         and then want [-1,-2,-3] as output but it doesnt work
18:17:56 <lambdabot>     In the type `a a'
18:17:59 <sjanssen> no, kind inference will give a * -> *
18:18:34 <sjanssen> teko: (makeNeg a = -a) is not a valid expression, it is a declaration
18:18:41 <augustss> > map negate [1,2,3]
18:18:42 <lambdabot>   [-1,-2,-3]
18:18:44 <sjanssen> teko: perhaps map negate [1, 2, 3]?
18:18:50 <teko> k
18:19:20 <pumpkin> teko: if you really wanted to write it yourself, you could've done
18:19:23 <idnar> map (\a -> -a) [1,2,3]
18:19:25 <orbitz> teko: read realworldhaskell
18:19:27 <idnar> but negate reads nicer
18:19:35 <pumpkin> idnar: dammit you completed my sentence :P
18:19:41 <roconnor> @pl (\a -> -a)
18:19:42 <lambdabot> (line 1, column 8):
18:19:42 <lambdabot> unexpected "-"
18:19:42 <lambdabot> expecting lambda abstraction or expression
18:19:45 <idnar> pumpkin: I know, I was trying to figure out how to say what you said
18:19:49 <roconnor> @pl (\a -> (-a))
18:19:50 <lambdabot> negate
18:19:51 <augustss> Does anyone if the book stores in the UK have RWH yet?
18:19:54 <idnar> pumpkin: so when you went ahead and said it for me, I just let the rest roll :)
18:20:03 <idnar> pumpkin: (I'm evil like that)
18:20:19 <pumpkin> :)
18:20:20 <phao> can I do generic programming in haskell?
18:20:29 <pumpkin> phao: ?
18:20:35 <sjanssen> phao: yes
18:20:35 <orbitz> what's that mean?
18:20:37 <pumpkin> @faq can I do generic programming in haskell?
18:20:38 <lambdabot> The answer is: Yes! Haskell can do that.
18:20:40 <idnar> Megzlna: I talk a lot faster than SPJ when I get excited >:)
18:20:42 <pumpkin> sure appears to be the case
18:20:49 <Megzlna> orbitz: it means writing a spreadsheet or a calendar
18:21:01 <idnar> that sounds more like general-purpose programming
18:21:04 <Megzlna> lol
18:21:33 <orbitz> Megzlna: dont' for get an MMORPG!
18:21:48 <Megzlna> ah yes everyone wants to be god
18:21:55 <sjanssen> phao: there is actually a lot of research done on generic programming in Haskell, so you can take your choice of approaches
18:22:02 <mlesniak> Does the prelude support utf-8, i.e. should a simple putStrLn "öäüß" (german umlauts) work by displaying öäüß?
18:22:23 <sjanssen> mlesniak: it doesn't, see utf8-string on hackage
18:22:35 <sjanssen> (this is bug #1, IMO)
18:22:36 <mlesniak> sjanssen: Ah, that explains a lot :) Thanks
18:23:02 <idnar> orbitz: ITYM "MMO"
18:23:19 <idnar> orbitz: most of them have pretty thoroughly ditched the "RPG" :P
18:23:20 <sjanssen> mlesniak: strings support Unicode, but all of the IO functions print only the lowest byte of each Char
18:23:47 <orbitz> idnar: hah
18:23:47 <sjanssen> the input functions are similarly encoding oblivious
18:24:03 <mlesniak> sjanssen: ah, ok, thanks
18:24:03 <pumpkin> at least they had the foresight to make char unicode-aware :)
18:24:36 <idnar> how is Char unicode-aware?
18:24:46 <sjanssen> idnar: it supports the full range of Unicode
18:24:51 <augustss> pumpkin: I insisted on it :)
18:24:56 <pumpkin> yay
18:24:57 <sjanssen> augustss++
18:25:21 <dons> yay!
18:25:23 <pumpkin> so is each char actually represented as a 32-bit int behind the scenes?
18:25:27 <idnar> sjanssen: as far as I can tell, it just supports a certain range of ordinals which happens to be big enough to contain Unicode; there's no reason why you couldn't use it with another character set
18:25:45 <idnar> or am I missing something?
18:25:47 <sjanssen> idnar: the report does explicitly mention Unicode
18:25:51 <pumpkin> idnar: it contains exactly the number of defined unicode codepoints
18:25:57 <idnar> pumpkin: so it's not 32-bit?
18:26:05 <dons> :t Foreign.Storable.sizeOf (undefined :: Char)
18:26:06 <lambdabot> Int
18:26:09 <dons> > Foreign.Storable.sizeOf (undefined :: Char)
18:26:11 <lambdabot>   /tmp/2815650077881938020:70:32:
18:26:11 <lambdabot>      Not in scope: `Foreign.Storable.sizeOf'
18:26:13 <augustss> idnar: implementations typically use 32 bits
18:26:15 <dons> Prelude Foreign.C> Foreign.Storable.sizeOf (undefined :: Char)
18:26:15 <dons> 4
18:26:22 <sjanssen> pumpkin: in GHC, each Char is the size of an Int on your machine
18:26:28 <idnar> pumpkin: Unicode only goes up to 0x10FFFF >:)
18:26:32 <Megzlna> Why does this work...
18:26:33 <sjanssen> but I guess it is limited to 32 bit when using the FFI
18:26:34 <Megzlna> (1:) [1]
18:26:35 <dons> > maxBound :: Char
18:26:36 <lambdabot>   '\1114111'
18:26:37 <Megzlna> > (1:) [1]
18:26:38 <lambdabot>   [1,1]
18:26:43 <pumpkin> idnar: so does haskell's Char :P
18:26:45 <dons> :t (1 :)
18:26:46 <lambdabot> forall t. (Num t) => [t] -> [t]
18:26:46 <idnar> oh, cute
18:26:47 <dons> :t (:) 1
18:26:48 <Megzlna> if @src is hardcoded
18:26:48 <lambdabot> forall t. (Num t) => [t] -> [t]
18:26:52 <Megzlna> i mean
18:26:53 <Megzlna> if : is hc'd
18:27:03 <Megzlna> or isn't it?
18:27:16 <augustss> > ord maxBound
18:27:17 <lambdabot>   1114111
18:27:27 <pumpkin> that's neat
18:27:34 <augustss> > printf "%x" (ord maxBound) :: String
18:27:35 <sjanssen> Megzlna: (:) is a first-class function, just like any other
18:27:35 <idnar> > '\1114112'
18:27:36 <lambdabot>   "10ffff"
18:27:37 <lambdabot>   <no location info>:
18:27:37 <lambdabot>      lexical error in string/character literal at chara...
18:28:04 <idnar> guess that works
18:28:05 <int-e> Prelude Foreign Foreign.C> sizeOf (undefined :: CChar)  ---->  1
18:28:15 <Megzlna> sjanssen: : is literally not builtin to GHC whatsoever?
18:28:18 <idnar> although of course you can create a bogus Char with unsafeCoerce
18:28:38 <Megzlna> it's purely a symptom of the pattern matching abilities
18:28:38 <int-e> while  sizeOf (undefined :: CWchar)  is 4 again.
18:28:39 <Megzlna> ?
18:28:52 <idnar> @src (:)
18:28:53 <lambdabot> Source not found. There are some things that I just don't know.
18:28:56 <idnar> heh
18:28:58 <sjanssen> Megzlna: I think (:) actually has source code in GHC (you can't normally define list in Haskell syntax)
18:29:06 <sjanssen> Megzlna: you're not really making sense
18:29:18 <augustss> Megzlna: : is not really built in, but it has reserved syntax
18:29:35 <pumpkin> > let (*) = (+) in 5 * 4
18:29:36 <pumpkin> > let (:) = (+) in 5 : 4
18:29:36 <lambdabot>   9
18:29:36 <idnar> bar.hs:1:14: Illegal binding of built-in syntax: :
18:29:37 <lambdabot>       Constructor `:' should have 2 arguments, but has been given 0
18:29:37 <lambdabot>      In t...
18:29:52 <int-e> ghc-prim/GHC/Types.hs: data [] a = [] | a : [a]
18:29:54 <int-e> cute :)
18:29:56 <idnar> so you can't define your own constructor called (:)
18:30:06 <idnar> and I guess [a] is special syntax
18:30:16 <sjanssen> idnar: as is []
18:30:24 <idnar> but : itself shouldn't need anything special
18:30:39 <sjanssen> idnar: except that the report says it is reserved
18:30:47 <Megzlna> perhaps it's for a shortcut optimization?
18:30:52 <sjanssen> Megzlna: no
18:30:56 <idnar> sjanssen: sure; but I mean, under the hood, it's just a normal constructor
18:30:58 <pumpkin> anyone around here ever implemented (or heard of an implementation of) a directed acyclic word graph in haskell?
18:31:02 <sjanssen> idnar: oh yes, definitely
18:31:08 <idnar> pumpkin: that sounds like a really awful pun
18:31:23 <pumpkin> idnar: dawg? :P
18:31:29 <idnar> pumpkin: GOT N E UPDAWG?
18:31:34 <pumpkin> lol
18:31:41 <pumpkin> it's what people call a trie with shared suffixes
18:31:42 <luite_> hehe
18:31:48 <pumpkin> suffices?
18:31:49 <pumpkin> lol
18:32:26 <mlesniak> I'd like that System.IO.UTF8 "overwrites" the standard prelude functions but am unsure (ok, to be honest, I've no idea ;)) about the import syntax. import System.IO.UTF8 obviouslly gives a warning from ghc. Is the only option to import it as qualified?
18:32:28 <pumpkin> a trie is almost trievial to implement
18:32:31 <pumpkin> ;)
18:32:37 <pumpkin> but the DAWG bit makes it more involved
18:32:51 <sjanssen> mlesniak: yeah, usually you import qualified as UTF8
18:32:51 <pumpkin> mlesniak: you can remove implicit prelude
18:33:18 <mlesniak> pumpkin: which is what i probably want (not knowing about the negative side effecte yet ;))
18:33:35 <pumpkin> I think -fno-implicit-prelude
18:33:43 <pumpkin> but then you'll need to import the parts of prelude you do need
18:33:53 <pumpkin> or import it qualified
18:34:12 <augustss> mlesniak: you can do 'import Prelude hiding (putStrLn)' etc
18:34:15 <sjanssen> pumpkin: import Prelude () -- works too
18:34:33 <pumpkin> sjanssen: what does that do?
18:34:33 <mlesniak> augustss: Ah, this seems to be nice :)
18:34:34 <roconnor> does that import ()?
18:34:38 <Megzlna> How do I define a  % which does the same thing as : ?
18:34:41 <augustss> pumpkin: -fno-implicit-prelude does something else
18:34:46 <Megzlna> just for exposition sake
18:34:57 <pumpkin> augustss: hmm, what does it do?
18:34:59 <sjanssen> pumpkin: imports nothing from Prelude, hence overriding the implicit import
18:35:04 <pumpkin> ah
18:35:10 <sjanssen> Megzlna: x % xs = x : xs
18:35:21 <idnar> Megzlna: you can't, infix constructors need to start with :
18:35:23 <sjanssen> Megzlna: but you can only use this in expressions, not patterns
18:35:23 <Megzlna> sjanssen: without usiing :
18:35:38 <sjanssen> Megzlna: you can't do that, (:) is the name of (:)
18:35:50 <idnar> data List a = a :% List a | Nil
18:35:55 <augustss> pumpkin: It make things like the implicit fromInteger applied to literals be whatever fromInteger is in scope at that point and not Prelude.fromInteger
18:35:58 <sjanssen> data List a = Nil | Cons a (List a) -- a datatype that is isomorphic to []
18:36:10 <pumpkin> augustss: ah
18:36:30 <Megzlna> idnar, why does it have to start with : ?
18:36:50 <idnar> Megzlna: to differentiate it from an infix function that is not a constructor
18:36:58 <idnar> Megzlna: the same way prefix constructors have to start with a capital letter
18:37:11 <Megzlna> idnar: So, that's why we have
18:37:12 <Megzlna> :>
18:37:22 <Megzlna> and :< on Data.Sequence
18:37:31 <pumpkin> cute smiley faces!
18:37:44 <idnar> unfortunately I don't think you can define Nil as an infix constructor
18:38:31 <dons> yo, generalised tries to appear on hackage tonight. http://www.reddit.com/r/haskell/comments/7j6sz/musings_zombified_gmap/
18:38:35 <dons> stay tuned for more info!
18:38:54 <dons> we need to set a hard requirement for public repos next SoC
18:41:16 <pumpkin> anyone know much about DAWGs then? :)
18:41:23 <pumpkin> beyond "what's up dawg"
18:41:37 <augustss> what's up dawg
18:41:48 <Megzlna> pumpkin: I do.
18:41:53 <dons> yo dawg, what's up with your DAWGs?
18:41:58 <pumpkin> lol
18:42:26 <pumpkin> Megzlna: know of any implementations in haskell? I just need simple strings :)
18:42:34 <pumpkin> I wrote an ugly ruby implementation a while back
18:43:14 <orbitz> what is DAWGs?
18:43:20 <Megzlna> dawg: Data.Map from vertices to Data.Sets of vertices
18:43:27 <pumpkin> directed acyclic word graph :P
18:43:27 <Megzlna> since it's acyclic
18:43:34 <orbitz> k
18:43:37 <pumpkin> it's a trie with shared suffixes
18:43:42 <pumpkin> (on strings)
18:43:48 <pumpkin> (of human language)
18:43:49 <pumpkin> ;)
18:44:00 <orbitz> (())
18:44:00 <dons> a patch compressed trie?
18:44:01 <luite_> pumpkin: you want to build an immutable one with shared thunks?
18:44:09 <Megzlna> a DAWG is a graph which has only terminal endpoints
18:44:15 <Megzlna> and no feedback loops
18:44:20 <pumpkin> luite_: basically
18:44:22 <dons> s/path/
18:44:29 <Megzlna> And flows in one single direction
18:44:41 <pumpkin> Megzlna: where's the W come into play?
18:45:05 <Megzlna> pumpkin: that's the more fiddly part, the rest is generic
18:45:09 <pumpkin> yeah, I know :P
18:45:18 <pumpkin> DAGs are pretty common, DAWGs less so :)
18:45:28 <pumpkin> and building them is the hard bit
18:46:20 <Megzlna> pumpkin: What problem did you want to solve with a dawg?
18:46:41 <idnar> SUP DAWG, WE HEARD YOU LIKE DAWGS SO WE PUT A DAWG IN YOUR HASKELL SO YOU CAN TRIE WHILE YOU TRY
18:46:49 <redditbot> Musings: Zombified GMap
18:46:49 <redditbot> A brief look at fingertrees
18:46:55 <pumpkin> Megzlna: it's a nice compact representation for a dictionary of words, as well as allowing for easy prefix and suffix matching
18:47:08 <pumpkin> mostly just curiosity though
18:47:41 <Megzlna> pumpkin: A btree is a dag
18:47:57 <pumpkin> ..
18:48:00 <sjanssen> all trees are DAGs
18:48:14 <pumpkin> such perls of wisdom tonight :P
18:48:17 <pumpkin> pearls, lol
18:48:21 * pumpkin kicks self
18:48:26 <Megzlna> For a dictionary you don't need much more than that
18:48:30 <dons> idnar: hah
18:48:39 <Megzlna> i think they were just using a flowery term
18:48:49 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/interpolatedstring-qq-0.1 "QuasiQuoter for Ruby-style multi-line interpolated strings"
18:48:52 <luite_> Megzlna: unless you want a dawg, for coolness reasons
18:49:30 <pumpkin> Megzlna: I actually want a DAWG
18:49:39 <orbitz> goto the pound then
18:49:39 <pumpkin> for coolness reasons
18:49:42 <luite_> :)
18:49:59 <orbitz> i'm more of a CAT fan myself
18:50:09 <pumpkin> Megzlna: and also beacause I'm not sure how you get DAWG-like properties from a btree, without making it a DAWG :P
18:50:50 <Megzlna> pumpkin: Hackage it when you're done!
18:51:17 <pumpkin> maybe :)
18:51:25 <luite_> hm, now pumpkin has me thinking about daws the rest of the night...
18:51:26 <luite_> dawgs
18:51:43 <pumpkin> http://www.urbandictionary.com/define.php?term=dawg
18:51:53 <idnar> http://encyclopediadramatica.com/SUP_DAWG
18:52:01 <pumpkin> http://en.wikipedia.org/wiki/Directed_acyclic_word_graph
18:52:48 <Gracenotes> pumpkin: oh dear, I was just making a joke about that the other day
18:52:51 <pumpkin> :P
18:53:32 <Gracenotes> namely: Yo dawg, I heard you liked directed acyclic word graphs, so we put a DAWG in your problem so you can optimize subproblems while you optimize problems.
18:54:04 <pumpkin> lol
18:54:09 <pumpkin> this is terrible
18:54:26 <luite_> hehe
18:54:34 <pumpkin> if I ever release it, I'm going to rename it to acyclic directed word graph
18:54:41 <pumpkin> :P
18:55:03 <luite_> adwg, that's unprouneceable :(
18:55:13 <luite_> +on
18:55:25 <luite_> or something to make it correct spelling
18:55:32 <idnar> directed word acyclic graph
18:55:49 <pumpkin> acyclic digraph for words
18:55:51 <Gracenotes> the dawg joke being based on, of course, http://i37.tinypic.com/21cvt2.jpg
18:55:52 <smarmy> or a graph of words, acyclically directed.  a gwad
18:55:53 <idnar> graph of acyclic words in direction?
18:56:24 <idnar> Gracenotes: YO DAWG I HERD YOU LIKE CARS SO WE PUT A PAIR IN YO CAR SO YOU CAN CAR WHILE YOU CAR
18:58:22 * pumpkin facepalms
18:58:35 <Gracenotes> Directed graph without cyclic paths consisting of words. DGWCPCOW, how's that?
18:59:04 <idnar> Gracenotes: you need to get BBQ in there somehow
18:59:34 <smarmy> and WTF
19:00:35 <pumpkin> and OMG, DUH
19:01:00 <BMeph> pumpkin: SUP DAWG I HERD U LIEK GWAD SO I PUT A GWAD IN YO GWAD SO U CAN GWAD WHIEL YO GWAD
19:01:26 <Philippa_> eh? I only remember IWADs and PWADs
19:01:33 * BMeph runs because there's a mad meme on the loose!
19:01:41 <smarmy> Philippa_: ;)
19:02:30 <smarmy> a haskell WAD editor would be a fun project
19:02:54 <Philippa_> someone already built an FPL for generating WADs though
19:04:08 <idnar> WAD as in Where's All the Data?
19:06:42 <pumpkin> what have I done :(
19:07:21 <idnar> I wonder if you could use a DAWG in a WAD editor
19:07:32 <pumpkin> DAWGs are useful everywhere
19:07:46 <idnar> even when you don't have any words?
19:07:50 <Gracenotes> I've never used one myself
19:08:15 <BMeph> pumpkin: So, was it you? Did YOU let the DAWGs out? ;p
19:08:22 <pumpkin> oh GAWD
19:08:32 <idnar> hahaha
19:08:45 <idnar> it just gets worse and worse
19:09:39 <Gracenotes> I wonder, what's the largest dawg that's ever been made
19:09:58 <Gracenotes> i.e., have people tried dictionaries?
19:10:03 <idnar> an English Mastiff, apparently
19:10:16 <Gracenotes> I anticipated that...
19:10:49 * BMeph gives idnar a rimshot
19:11:14 <Gracenotes> perhaps I'll implement one and run it on my Firefox dict.
19:12:29 <Megzlna> How do you 'unpack' a tuple such that you can consume multiple  a -> a -> a ?
19:12:43 <Megzlna> i've got   f :: Int -> Int -> Int
19:12:51 <Megzlna> and let t = (1,2)
19:12:57 <Megzlna> I'd like to apply the tuple to f
19:12:58 <idnar> @type let f = (+) in uncurry f
19:12:59 <lambdabot> forall a. (Num a) => (a, a) -> a
19:13:14 <idnar> > let f = (+) in uncurry f (1,2)
19:13:15 <lambdabot>   3
19:13:30 <idnar> obviously you can also write something like
19:13:47 <idnar> > let f (x, y) = x + y in f (1,2)
19:13:49 <lambdabot>   3
19:14:04 <Megzlna> :t let f x y = x + y in uncurry f (1,2)
19:14:06 <lambdabot> forall a. (Num a) => a
19:14:42 <pumpkin> > let f x y = x + y in uncurry f (1,2)
19:14:43 <lambdabot>   3
19:14:55 <Megzlna> idnar: Well with the f (x,y) pattern matching version, you know it's a Pair -- but what if you don't know the size of the tuple
19:15:11 <Megzlna> or rather you do but don't want to write the (x,y) part to match
19:15:12 <pumpkin> oh, doing stuff with different-sized tuples is a pain
19:15:15 <idnar> Megzlna: if you don't know the size of the tuple, then you can't know the type of the function
19:15:39 <Megzlna> idnar: Maybe you just have a "Tuples" typeclass
19:16:00 <idnar> okay, but you still have to write or generate an instance for each size of tuple
19:16:20 <idnar> presumably you could automate that with some TH magic, but I don't think there's anything more Haskell can do to help you out there
19:16:21 <Megzlna> yeah, TH 0 to 15 instances each Forall'd
19:16:42 <Megzlna> 0 being no tuple, but matching 'a'
19:16:46 <idnar> sounds like tuple abuse, though :P
19:16:50 <Megzlna> s/0/1
19:16:55 * idnar reports Megzlna to the SPCT
19:17:05 <orbitz> Megzlna: you really wnat to have some sort of tuple magic don't you?
19:17:11 <Megzlna> Society for the Protection of Clumsy Tuples?
19:17:17 <mpeter> > fix (fix (3:):)
19:17:19 <lambdabot>   [[3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
19:17:22 <idnar> Society for the Prevention of Cruelty to Tuples
19:17:49 <Megzlna> orbitz I like them ;)
19:18:14 <Megzlna> so, I was wondering if it's possible to unpack the tuple, if you only know it's of typeclass Tuples
19:18:27 <orbitz> Megzlna: homie don't play dat
19:18:57 <idnar> Megzlna: well, presumably you'd add an uncurry-like method ("apply") to the typeclass
19:19:10 <idnar> er, that meant to read ("apply?")
19:19:10 <BMeph> Megzlna: You can use nested tuples to the same effect, but then, you risk starting another "SUP DAWG" incident... ;p
19:19:24 <pumpkin> Megzlna: there is no typeclass Tuples afaik
19:19:25 <idnar> BMeph: oh man, don't tempt me
19:19:32 <Megzlna> without use of nested
19:19:32 <idnar> pumpkin: doesn't stop you defining one :)
19:19:33 <pumpkin> Megzlna: n-tuples are kinda ugly
19:19:37 <Megzlna> pumpkin: Yeh i made the typeclasas
19:19:41 <pumpkin> idnar: yeah, but it's hard to do something useful with it
19:20:17 <gwern> wait, typeclass Tuples?
19:20:18 <idnar> pumpkin: you can give it an uncurry-like function and use it to apply curried functions to an N-tuple; but maybe that's not useful ;)
19:20:20 * gwern scrolls up
19:20:23 <Megzlna> so an apply method in the instances.. interesting
19:20:28 <BMeph> data TupleF a b = () | (a,b); type Tuple a = Mu (TupleF a)
19:20:44 <BMeph> Ta-da. ;p
19:22:51 <idnar> hmm, I thought you couldn't distinguish values of Mu a
19:23:05 <idnar> or something
19:23:25 <idnar> thinking about Mu makes my head hurt, I'm going to bed instead
19:23:30 <sjanssen> Megzlna: I'd do this in two steps: first turn (a, b, c) into (a, (b, (c, ())), then write a transformer on functions that consumes a nested tuple
19:24:30 <Megzlna> sjanssen: ah
19:24:33 <Megzlna> good
19:24:47 <sjanssen> to write both generic functions, you'll need fundeps or associated types
19:26:15 <Megzlna> and that makes it work with the instances polymorphism and only know 'Tuples'
19:33:15 <sjanssen> hmm, I really need to upgrade to 6.10.  Type families are too buggy on 6.8
19:34:40 <ozy`> doesn't 6.10 introduce all manner of fun new bugs to mangle your programs with?
19:34:54 * ozy` exaggerates slightly
19:35:27 <sjanssen> ozy`: well, type families are supposed to actually work
19:38:00 <sjanssen> Megzlna: http://hpaste.org/13036
19:42:02 <Megzlna> sjanssen: :)
19:42:15 <sjanssen> Megzlna: I don't suppose you have GHC 6.10 and can tell me whether it works?
19:42:50 <Megzlna> I do.
19:42:58 <sjanssen> example: uncurry' (:) ('a', "b")
19:43:12 <pumpkin> ok first step to DAWG complete, I wrote a simple trie in haskell
19:43:23 <Megzlna> sjanssen: What were the language exts required?
19:43:31 <Megzlna> There's none in the paste
19:43:45 <dons> anyone looked at putting paradox or equinox on hackage? http://www.cs.chalmers.se/~koen/folkung/
19:44:04 <sjanssen> Megzlna: oh, you can just turn on -fglasgow-exts
19:44:12 <sjanssen> Megzlna: otherwise it's a laundry list of options
19:44:13 <Megzlna> k
19:44:35 <sjanssen> TypeFamilies, KindSignatures, TypeOperators at least
19:44:57 <luite_> pumpkin: I was thinking about generating a dawg using a trie built from the reverse of each word, but only so far as there are nodes that are shared between more than one word. then when building the forward trie, check for each word whether its suffix is found in the reverse trie. don't know whether this generates optimal daws though
19:45:21 <pumpkin> luite_: there should only be one DAWG for each set of words, I think
19:46:49 <redditbot> Paul's Pontifications: Is Functional Programming the new Python?
19:46:49 <redditbot> QuasiQuoter for Ruby-style multi-line interpolated strings
19:46:59 * pumpkin tries to think of a good way of enumerating his trie
19:47:16 <pumpkin> DFS seems simplest, but let's see
19:47:30 <Megzlna> sjanssen: Worked
19:47:40 <sjanssen> Megzlna: great, thanks
19:47:49 * sjanssen grabs GHC 6.10 tarball
19:50:56 <Megzlna> sjanssen: problem,
19:51:14 <Megzlna> http://hpaste.org/13037
19:51:24 <Megzlna> I guess Haskell doesn't try to instanciate everything till you use it
19:51:56 <sjanssen> Megzlna: and you uncommented the function instance?
19:52:34 <Megzlna>     Type indexes must match class instance head
19:52:34 <Megzlna>     Found a -> t but expected a :*: t
19:52:34 <Megzlna>     In the associated type instance for `Result'
19:52:34 <Megzlna>     In the instance declaration for `Apply (a -> f) (a :*: t)'
19:52:37 <pumpkin> how does this make sense? GHC says the two patterns overlap:
19:52:37 <pumpkin>                  enumerateTrie_ word acc (Node False []) = ...
19:52:37 <pumpkin>                  enumerateTrie_ word acc (Node True []) = ...
19:53:25 <Megzlna> to use it, I did:  main = putStrLn (show (uncurry' (:) ("a", "b")))
19:53:29 <sjanssen> Megzlna: does the line read "type Result (a -> f) (a -> t) = Result f t"?
19:53:39 <sjanssen> Megzlna: oh, that's a type error
19:53:49 <sjanssen> > "a" : "b"
19:53:50 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
19:54:01 <Megzlna> k will add []
19:54:04 <sjanssen> Megzlna: GHC is just taking a roundabout way of saying [Char] doesn't match Char
19:56:18 <Megzlna> sjanssen: Which main func do you recommend?
19:57:17 <sjanssen> main = print (uncurry' (:) ('a', "b"))
19:57:36 <Megzlna> same error
19:57:50 <pumpkin> aha, figured it out
19:57:53 <pumpkin> whee, I can enumerate my trie now
19:57:54 <Megzlna> i'd changed the 'a' before to "a" just trying to get error to stop
19:58:01 <pumpkin> it's inefficient though, ah well
19:59:14 <thoughtpolice> @seen Lemmih
19:59:15 <lambdabot> Lemmih is in #haskell. I don't know when Lemmih last spoke.
19:59:30 <orbitz> @seen thoughtpolice
19:59:31 <lambdabot> thoughtpolice is in #ghc and #haskell. I last heard thoughtpolice speak 16s ago.
20:02:31 <pumpkin> @seen orbitz
20:02:32 <lambdabot> orbitz is in #haskell. I last heard orbitz speak 3m 1s ago.
20:04:08 <Megzlna> sjanssen: lol, I see what it's doing sjanssen.. the nest part is cool
20:04:13 <gwern> http://www.reddit.com/r/programming/comments/7j4br/id_rather_keep_myself_away_from_gems_flaws_in/ <-- cabal mentioned favorably
20:04:23 <pumpkin> @hoogle fromList
20:04:24 <lambdabot> Data.HashTable fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
20:04:24 <lambdabot> Data.IntMap fromList :: [(Key, a)] -> IntMap a
20:04:24 <lambdabot> Data.IntSet fromList :: [Int] -> IntSet
20:05:11 <pumpkin> @src fromList
20:05:12 <lambdabot> Source not found. I feel much better now.
20:05:18 <pumpkin> @src IntMap fromList
20:05:19 <lambdabot> Source not found. You speak an infinite deal of nothing
20:05:28 <pumpkin> I wonder if it's possible to construct those things lazily
20:11:46 <dons> gwern: good find.
20:14:49 <nanothief> I never knew the benefits of the haskell cabal system, until I started using archlinux and found a huge amount of haskell packages created automatically
20:15:07 <roconnor> nanothief: what are the benifits of archlinux?
20:15:35 <gwern> nanothief: are there lots of ruby gems packages in arch?
20:16:01 <gwern> dons: it'd be interesting perhaps if cabal vs gems could be expanded into a real critique/article
20:16:11 <nanothief> gwern: not really, only the big ones. You can of course use rubygems, but I like the integration having all packages managed by the same program
20:17:19 <gwern> although I suspect the person familiar enough with cabal and gems to write such a critique is a rare bird indeed
20:17:38 <pumpkin> ˙http://paulspontifications.blogspot.com/2008/05/is-functional-programming-new-python.html wow the first comment
20:19:31 <gwern> pumpkin: somehow I suspect python is much weaker than scheme at doing schemey things
20:19:43 <pumpkin> gwern: yeah
20:19:53 <pumpkin> I wouldn't really call python functional by any definition
20:19:55 <pumpkin> you can approximate it
20:19:58 <gwern> at least, I can't remember the last time I saw a pythoner seriously employing tons of hygienic macros, juggling continuations, and so on
20:20:48 <dolio> How would they? By using Scheme?
20:21:58 <mpeter> the trick to OO programming is encapsulating every object even thought about in your program in one giant object
20:22:04 <dolio> Oh, right. See a few lines up. :)
20:22:05 <mpeter> and calling it "program object"
20:22:07 * dolio just got here.
20:22:12 <Megzlna> if you try to do:
20:22:15 <mpeter> and then the methods can just apply to anything
20:22:18 <Megzlna> let f :: (a -> b -> c) -> d; f x = x
20:22:28 <mpeter> so that the results of your code aren't even remotely applicable to what you intended the code to do
20:22:37 <Megzlna> 'd' cannot become "unrigid" and take the whole form of the type for (a->b->c) ?
20:24:42 <jberg> can someone explain what's so special about seq? the type is a -> t -> t and it is used to force a to evaluate, but how? is that type special?
20:25:05 <pumpkin> jberg: yeah, I don't think you could write it yourself
20:25:18 <llayland> @src seq
20:25:19 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
20:25:26 <Megzlna> so the derivation rule doesn't allow multiple type variables for a single parameter regardless of how it's distributed
20:25:33 <dibblego> jberg, yes it is handled specially by the compiler
20:25:42 <dolio> It doesn't force the a to evaluate, exactly.
20:25:51 <jberg> ok i see
20:25:52 <dolio> It forces the a to be evaluated before the t is.
20:26:00 <jberg> aha okay
20:26:47 <dolio> Or, if you like to think of evaluation as being demand driven, x `seq` y is the same as y, but when the former is demanded, so is x.
20:26:53 <pumpkin> is there a more elegant way to do: prependIf b word acc = if b then word:acc else acc
20:27:16 <pumpkin> other than pattern matching
20:27:32 <dolio> prependIf b word = if b then (word:) else id ? :)
20:27:42 <pumpkin> lol
20:27:46 <pumpkin> fair enough
20:28:20 <dolio> If there were a bool catamorphism, it'd be 'prependIf word = bool (word:) id', which would be nice.
20:28:40 <pumpkin> aha, there's that word again
20:28:50 <dolio> bool :: a -> a -> Bool -> a
20:28:52 <pumpkin> is that similar to maybe?
20:28:58 <dolio> Right. Or foldr.
20:29:03 <pumpkin> I see
20:29:21 <dibblego> what is id' ?
20:29:27 <dibblego> oh wait
20:29:29 <pumpkin> :P
20:30:21 <pumpkin> so now I need to move from my trie to a DAWG
20:30:49 <dolio> jberg: Note that by "demand" it means only to the outermost constructor. So seq won't evaluate, say, an entire lazy list.
20:30:57 <pumpkin> can I call quickcheck easily from ghci?
20:31:24 <dolio> People have come up with things to put into .ghci to do so. I have one that I never use.
20:31:36 <dolio> I'm not sure if it actually still works.
20:31:47 <dolio> :def qc \c -> return $ ":m + Test.QuickCheck \nTest.QuickCheck.quickCheck (" ++ c ++ ") \n:m -Test.QuickCheck"
20:31:51 <dolio> That's what it says, though.
20:34:56 <Cale> pumpkin: usually I just do what that ghci macro does manually ;)
20:35:10 <Megzlna> good evening Cale
20:35:13 <Cale> hi
20:35:18 <Megzlna> question:
20:35:33 <llayland> catamorphism is just a general fold?
20:35:37 <Cale> llayland: yep
20:35:43 <pumpkin> sounds so fancy
20:35:58 <pumpkin> maybe those fancy terms you guys throw around so much aren't as crazy as they seem :P
20:36:06 <Cale> llayland: It's a function which replaces each of the constructors of a datatype with an appropriate supplied function or value
20:36:20 <Cale> So foldr is the catamorphism for lists
20:36:30 <Cale> maybe is the catamorphism for Maybe
20:36:35 <dolio> Most aren't.
20:37:18 <Megzlna> let f :: a -> b; f x = x   -- ilegal, 'x' cannot type unify to both a and b... However!    let f :: (a -> b -> c) -> Int; f x = x   and   f (+)  *IS* allowed, even though the 'a' in (+) :: (Num a) => a -> a -> a   is being distributed to  'a', 'b', and 'c'
20:37:19 <Megzlna> why?
20:37:37 <llayland> ty
20:37:54 <Cale> that doesn't seem right...
20:38:08 <Megzlna> I'll do it on the both
20:38:10 <Megzlna> *bot
20:38:11 <Cale> > let f :: (a -> b -> c) -> Int; f x = x in f (+)
20:38:12 <lambdabot>   Couldn't match expected type `Int'
20:38:31 <dolio> @type let f :: (a -> b -> c) -> Int ; f x = x in f
20:38:32 <lambdabot>     Couldn't match expected type `Int'
20:38:32 <lambdabot>            against inferred type `a -> b -> c'
20:38:32 <lambdabot>     In the expression: x
20:38:52 <Megzlna> > let f :: (a -> b -> c) -> Int; f x = 1 in f (+)
20:38:53 <lambdabot>   1
20:39:01 <Megzlna> that!
20:39:26 <dolio> (a -> a -> a) is a specialization of (a -> b -> c).
20:39:37 <dolio> As is the case for a constrained a.
20:39:39 <Megzlna> then why doesnt it work on Cale's first example?
20:40:01 <dolio> Int is not the same as (a -> b -> c).
20:40:02 <pumpkin> Megzlna: because (+) isn't of type Int
20:40:43 <Megzlna> the only difference was  f x = 1  vs  f x = x
20:41:03 <dolio> The type of 'f x = x' is a -> a.
20:41:23 <Megzlna> but, we specified -> Int on the end
20:41:40 <Megzlna> which I'd expect to cause it to not care for the derived type of f x =
20:41:42 <pumpkin> is there a notion of "replace all occurrences of x with a single "canonical" x (by some comparison function)"?
20:41:52 <dolio> It doesn't matter what you tell it the type is. It won't accept it unless it's a valid type for the function.
20:42:31 <dolio> And (a -> b -> c) -> Int doesn't work for the identity function.
20:43:31 <dolio> Haskell doesn't let you arbitrarily give the obviously wrong type to functions.
20:43:35 <Megzlna> well yeah you're saying that:
20:43:38 <Megzlna> > let f :: a -> Int; f x = x
20:43:39 <lambdabot>   <no location info>: parse error on input `;'
20:43:45 <dolio> Unless you use some special primitives.
20:43:46 <Megzlna> > let f :: a -> Int; f x = x in f 1
20:43:47 <lambdabot>   Couldn't match expected type `Int' against inferred type `a'
20:43:48 <Megzlna> is illegal,
20:44:09 <Megzlna> I was just weirded out about a, b, and c, working on Num a
20:44:21 <dolio> (Which technically aren't part of the official Haskell specification.)
20:44:25 <Megzlna> whereas a -> Int doesnt work on  x = x
20:44:50 <dolio> You can say f :: Int -> Int, since Int is an instantiation of a.
20:45:18 <dolio> But you cannot say f :: a -> Int, because that means given an a of any type, you'll return an Int, but you're just returning what's passed in.
20:45:59 <Megzlna> dolio: in the same logic you used to describe the previous justification, how do you justify this:
20:46:05 <Megzlna> > let f :: (a -> b -> c) -> Int; f x = 1 in f (+)
20:46:06 <lambdabot>   1
20:46:29 <Megzlna> because there can be no consequence of a -> b -> c all being a forall  of Num ?
20:46:53 <dolio> Well, it's probably easiest to see if we use another variable.
20:46:58 <dolio> Suppose we have some Num d.
20:47:06 <dolio> Then set a = d, b = d, and c = d.
20:47:18 <dolio> Then you get: f :: Num d => (d -> d -> d) -> Int.
20:47:30 <llayland> > let f _ = 1 in f (+)
20:47:31 <lambdabot>   1
20:47:38 <dolio> So it's fine to pass (+) to that function.
20:47:46 <dolio> And it always returns 1, which is fine as an Int.
20:48:53 <Megzlna> so this would not work:
20:48:59 <Megzlna> > let f :: (a -> b -> c) -> Int; f x = (x 1 1) in f (+)
20:49:00 <lambdabot>   Couldn't match expected type `Int' against inferred type `c'
20:49:29 <Megzlna> or
20:49:31 <Megzlna> > let f :: (a -> b -> c) -> d; f x = (x 1 1) in f (+)
20:49:32 <lambdabot>   Couldn't match expected type `d' against inferred type `c'
20:49:48 <dolio> "f :: ... -> d"
20:49:51 <jberg> http://hpaste.org/13038 im not sure if my function mkOctTree is correct, could someone look at it just for a moment?
20:49:51 <dolio> Oops.
20:49:57 <Megzlna> the a b and c were only allowed to be of Forall Num because we didnt use it
20:50:03 <dolio> "f :: ... -> d" means it can return any type d that the caller chooses.
20:50:26 <dolio> Whereas f always returns a c there.
20:51:22 <dolio> Also, x is not allowed to be called with 1s, because you're not guaranteed that a and b are in the Num class.
20:51:48 <dolio> I could pass in a function of type Char -> Char -> String.
20:52:26 <Megzlna> so why not...
20:52:33 <Megzlna> > let f :: (a -> a -> a) -> a; f x = x 1 1 in f (+)
20:52:35 <lambdabot>       Could not deduce (Num a) from the context ()
20:52:35 <lambdabot>        arising from the li...
20:52:49 <dolio> That also doesn't say that the as are guaranteed to be in Num.
20:52:59 <Megzlna> because  a forall Num won't match a single a
20:53:05 <dolio> > let f :: Num a => (a -> a -> a) -> a ; f x = x 1 1 in f (+)
20:53:06 <lambdabot>   2
20:53:47 <dolio> > let f :: (Num a, Num b) => (a -> b -> c) -> c ; f x = x 1 1 in f (+)
20:53:48 <lambdabot>   2
20:54:03 <Megzlna> dolio: I know you need Num there, but was comparing that with when it works  for -> Int and f x = 1
20:54:09 <Megzlna> in that instance, 'a' works for Num.
20:56:34 <Megzlna> <dolio> Then you get: f :: Num d => (d -> d -> d) -> Int.
20:56:49 <dons> Heffalump: any update on rwh from amazon.co.uk?
20:56:53 <Megzlna> how is that possible?
20:57:26 <Megzlna> you're saying its a magic appearance of  Num d => ?
20:57:38 <Megzlna> only because all 3 types are of Num
20:57:50 <dons> no magic.
20:57:51 <dolio> It's a specialization of the type.
20:58:10 <dolio> If something works forall a, then it works forall a. Class a => ...
20:59:29 <dolio> So you specialize both a b and c to the same constrained type.
20:59:31 <Megzlna> sorry... let me just make sure I understood the basis :)
20:59:33 <Megzlna> f :: (a -> b -> c) -> Int       TURNS INTO (unmagically)    f :: (Num d) => (d -> d -> d) -> Int     when I pass in (+)
21:00:04 <Megzlna> right?
21:00:30 <dolio> That's the specialization that allows you to pass (+), yes.
21:01:59 <Megzlna> same as
21:02:00 <Megzlna> > let f :: a -> b -> Int; f x y = 1 in f (+) (+)
21:02:02 <lambdabot>   1
21:04:39 <llayland> does the specialization argument hold up passing undefined instread of (+)
21:05:06 <dolio> undefined has type forall a. a, so it can take on any type.
21:05:29 <llayland> duh, sorry
21:05:47 <dolio> It's specialization, but of a different thing.
21:06:07 <ozy`> aaaargh
21:06:19 <sclv> http://www.haskell.org/tutorial/classes.html
21:06:27 * ozy` rips cabal-install's lungs out
21:06:30 <sclv> read up on principal types a bit mayb
21:06:31 <sclv> maybe
21:06:37 <Megzlna> so it allows all possibilities in the forall direction, and restricts all possibilities in the unification direction
21:07:18 * dolio needs to go eat something. Someone else will have to pick this up.
21:07:41 <Megzlna> dolio: thanks
21:07:48 <dolio> No problem.
21:09:02 <jberg> anyone use haskell in vim?
21:09:28 <ddarius> jberg: About half the people who program in Haskell (and are active members of the community) use vim.
21:09:49 <jberg> is there something similar to C-c C-l in emacs where you got a big window with ghci where you could load your code
21:10:44 <Cale> jberg: I just use a second terminal window
21:10:54 <Cale> (and keep ghci running)
21:11:03 <jberg> yea i suppose i could
21:11:09 <Cale> :r will reload whatever file is loaded
21:11:42 <jberg> but emacs had better indentation layout because you could press multiple times on tab and choose the right one
21:11:51 <jberg> you can't in vim (i think?)
21:11:59 <ddarius> That would piss me off.
21:12:18 <ddarius> I don't think any of the haskell modes do that for vim, but I don't use any of them.
21:12:20 <sclv> i tend to use ghci less these days. I write cold and then build from the command line until I get something that compiles, at which point I only use ghci for a bit of testing.
21:12:56 <sclv> and of course debugging.
21:13:25 <jberg> but will anyone please look at my function for a moment? im not sure if it's correct..
21:13:27 <jberg> http://hpaste.org/13038
21:13:59 <dons> jml: did you make progress on your protocol parser?
21:16:57 <Cale> jberg: Supposing that it typechecks, it looks correct to me.
21:18:35 <Cale> (and that the things it relies on are correct, of course :)
21:20:15 <llayland> what is the type of objectsInside and maxObjects - I would assume maxObjects is an Num and I'm (probably incorectly) reading objectsInside as an []
21:20:28 <jberg> Cale, it almost worked. i tried it in ghc now. but, what is div used for? ghci complains that i use div on integers
21:20:30 <mpeter> i don't think i've ever experienced a type error that wasn't related to inexperience
21:20:35 <Cale> objsInside must be a list because it's the result of filter
21:21:02 <Megzlna> > fix ("questions":)
21:21:04 <lambdabot>   ["questions","questions","questions","questions","questions","questions","q...
21:21:04 <Cale> mpeter: I've had type errors catch flaws in my reasoning.
21:21:30 <jberg> right, i forgot objsInside was a list
21:21:33 <jml> dons: yes I did!
21:21:53 <Cale> jberg: hmm... what's the actual error message regarding div?
21:22:48 <Cale> ah, I see what llayland was saying :)
21:22:58 <Cale> You probably want the length of that list.
21:23:29 <jml> dons: I've got a Haskell type that represents the basic message type, and have it serializing and deserializing. No actual network stuff yet, but I can feed the output to a Python-implemented peer using nc and it works just fine.
21:23:48 <jberg> Cale, don't remember, changed div to /
21:24:12 <llayland> woohoo got something right for a change :)
21:24:21 <Cale> jberg: okay. (/) is for fractional types (like Float, Double, Rational, etc.) and div is for integral types
21:24:43 <jberg> Cale, okay. they were probably doubles then
21:26:20 <Megzlna> Can flip f = g where g x y = f y x  be done without a where binding?
21:26:36 <orbitz> use a let binding
21:26:38 <Cale> flip f x y = f y x
21:26:39 <orbitz> ?
21:26:52 <Megzlna> Cale: supposed to return a new function
21:26:56 <Cale> Megzlna: it does
21:26:58 <dons> jml: great!
21:26:59 <Megzlna> ah
21:27:01 <dons> well done.
21:27:02 <Megzlna> cause of the currying
21:27:03 <Megzlna> haha
21:27:04 <jml> thanks.
21:27:05 <orbitz> Megzlna: currying
21:27:32 <jml> next step is networking, and then building on top of the wire protocol to provide a more useful API.
21:27:43 <orbitz> Megzlna: if you are doing flip f = g where g... , you can always jsut repalc ethe g with whatever you do in the where
21:27:49 <Cale> Another definition I rather like the looks of is:
21:27:55 <Cale> (f . g) x = f (g x)
21:29:14 <Megzlna> Cale: but you can't curry the (a -> b -> c) ->    part
21:29:31 <Cale> hm?
21:29:35 <orbitz> Megzlna:  that's just teh function...
21:29:40 <Cale> :t (.)
21:29:41 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
21:30:00 <Megzlna> > let flip :: (a -> b -> c) -> (b -> a -> c); flip f = g where g x y = f y x in (flip (/)) 1 4
21:30:01 <lambdabot>   4.0
21:30:23 <Cale> If it wasn't curried, it'd be something like (b -> c, a -> b) -> (a -> c)
21:30:28 <Cale> or I suppose it could be:
21:30:29 <Megzlna> > let flip f x y = f y x in (flip (/)) 1 4
21:30:31 <lambdabot>   4.0
21:30:37 <Cale> (b -> c, a -> b, a) -> c
21:30:41 <Cale> But that would be silly :)
21:30:51 <Cale> :t flip
21:30:52 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
21:31:11 <Megzlna> not needed because
21:31:20 <Megzlna> forall a b c. (a -> b -> c) -> (b -> (a -> c)
21:31:25 <Cale> You can read that as either saying that flip takes a function of two parameters, and gives another function of two parameters
21:31:26 <Megzlna> )
21:31:58 <Cale> Or you can read it as saying that it takes a function of two parameters (a -> b -> c), and a value of type b and a value of type a, and gives a c
21:33:06 <Megzlna> oh weird
21:33:46 <Cale> (those are the same thing)
21:36:19 <Megzlna> When you allow the type system to derived the type on flip
21:36:22 <Megzlna> it comes up with:
21:36:29 <Megzlna> flip :: (t1 -> t -> t2) -> t -> t1 -> t2
21:36:36 <Megzlna> Why does it choose that, rather than:
21:36:47 <Megzlna> flip :: (t -> t1 -> t2) -> t1 -> t -> t2
21:38:00 <Megzlna> given   flip f x y = f y x
21:38:00 <jml> I guess it's an implementation detail.
21:38:53 <Megzlna> well it's reversed  -- the f y x  ordering goes onto the parameter side
21:39:14 <Megzlna> of course it has no idea what y means, but it's reversed relative to the parameters
21:41:28 <glguy> Megzlna, the next of the types don't matter
21:41:32 <glguy> names*
21:42:54 <Megzlna> yeah, but I thought it might lead towards a reasoning regarding: "the return types must be unified in reverse order and innermost first"
21:44:22 <jml> well, it could just as easily say 'flip :: (purple -> orange -> goat) -> orange -> purple -> goat'
21:44:35 <orbitz> i love goat
21:45:41 <jml> orbitz: hi
21:45:46 <llayland> Could go for some curried goat
21:46:02 <orbitz> jml: hai
21:49:32 <thoughtpolice> @src trace
21:49:32 <lambdabot> trace string expr = unsafePerformIO $ do
21:49:32 <lambdabot>     hPutStrLn stderr string
21:49:32 <lambdabot>     return expr
21:50:04 <jberg> hm, i have one value of a type in a list, how can i extract that and give the value to a function?
21:50:41 <dons> a list of length 1?
21:50:47 <dons> > ['x'] -- for example?
21:50:48 <lambdabot>   "x"
21:50:50 <jberg> yes
21:50:54 <dons> in general, via pattern matching
21:51:13 <dons> > let f (z:_) = z + 2 in f [1..10]
21:51:14 <lambdabot>   3
21:51:19 <ozy`> > let [x] = "\NUL" in x
21:51:20 <lambdabot>   '\NUL'
21:51:46 <dons> you pattern matching on the data based on its shape, and use that to bind variables to the internals
21:54:08 <jberg-> sorry i was disconnected. can you lift a single value out of the list monad?
21:54:56 <jberg-> wait, maybe you lift values into the list monad
21:55:16 <ozy`> jberg-: you can lift a value out of any type (monadic or otherwise) that lets you pattern match on the constructor
21:55:37 <ozy`> > let (x:xs) = "pizza" in (x, xs)
21:55:39 <lambdabot>   ('p',"izza")
21:56:07 <Megzlna> Ok, this is highly odd.
21:56:15 <Megzlna> @let flip f x y = f y x
21:56:16 <lambdabot>  Defined.
21:56:17 <Megzlna> @let foo = flip (+)
21:56:18 <lambdabot>  <local>:2:6:
21:56:18 <lambdabot>      Ambiguous occurrence `flip'
21:56:18 <lambdabot>      It could refer to either ...
21:56:50 <ozy`> monomorphism restriction?
21:56:56 <Megzlna> However.
21:57:02 <Megzlna> It doesn't break on my GHCI
21:57:08 <Megzlna> and it literally does this:
21:57:10 <Megzlna> :t foo
21:57:11 <lambdabot> Not in scope: `foo'
21:57:13 <ozy`> @let foo x y = y + x
21:57:14 <lambdabot>  Defined.
21:57:17 <Megzlna> foo :: Integer -> Integer -> Integer
21:57:23 <Megzlna> It picks Integer
21:57:29 <Megzlna> even though Integer was never used anywhere
21:57:34 <ozy`> @let foo x = (x +)
21:57:35 <lambdabot>  <local>:2:0:
21:57:35 <lambdabot>      Equations for `foo' have different numbers of arguments
21:57:35 <lambdabot>   ...
21:57:43 <ozy`> @unlet foo
21:57:44 <lambdabot>   Parse error
21:57:49 <ozy`> @desu
21:57:49 <lambdabot> Unknown command, try @list
21:57:52 <pumpkin> Megzlna: not on mine
21:58:01 <Megzlna> I'll hpaste it
21:58:39 <jberg-> ozy` yep
21:58:58 <august> @list
21:58:58 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
21:59:50 <august> no even let in there
21:59:54 <Megzlna> http://hpaste.org/13039    <--- wtf?
22:00:14 <august> @protontorpedo
22:00:15 <lambdabot> cmon Im asking cool questions
22:00:42 <roconnor> Megzlna: defaulting
22:00:51 <Megzlna> roconnor: why?
22:01:14 <Megzlna> are you sure yours didnt default pumpkin
22:01:37 <roconnor> I'm not your pumpkin
22:01:40 <roconnor> :P
22:01:41 <pumpkin> lol
22:01:55 <august> @pumpkin
22:01:56 <lambdabot> Unknown command, try @list
22:02:01 <pumpkin> Megzlna: ah, I thought you were talking about x + y, not flip (+)
22:02:05 <pumpkin> yeah flip (+) defaults
22:02:33 <august> @let pumpkin = "2 + 2 = 5"
22:02:34 <lambdabot>  Defined.
22:02:40 <august> > pumpkin
22:02:41 <lambdabot>   "2 + 2 = 5"
22:03:14 <Megzlna> do I have to use  * -> * ?
22:03:14 <nanothief> Is there a better way than "length fileStr `seq` hClose handle" to force haskell to read an entire file with hGetContents before it is closed?
22:05:44 <roconnor> nanothief:  I believe hGetContents closes the handle after all the data is read
22:06:29 <roconnor> so doing something like "evaluate (length fileStr)"should be sufficent
22:06:52 <nanothief> roconnor, the problem I was having with that is I'm writing to the same file shortly afterwards in a different function, and if I don't close it now I get permission denied errors
22:07:48 <nanothief> but evaluate is much nicer :)
22:07:54 <roconnor> http://hackage.haskell.org/packages/archive/strict/0.3.2/doc/html/src/System-IO-Strict.html#hGetContents
22:08:04 <Megzlna> also, why did GHCI allow it, but lambdabot does not.
22:08:05 <roconnor> er
22:08:14 <roconnor> http://hackage.haskell.org/packages/archive/strict/0.3.2/doc/html/System-IO-Strict.html#v%3AhGetContents
22:09:14 <nanothief> roconnor, thats exactly what I need :D
22:09:39 <roconnor> @hackage strict
22:09:39 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/strict
22:11:47 <thoughtpolice> @seen Lemmih
22:11:47 <lambdabot> Lemmih is in #haskell. I don't know when Lemmih last spoke.
22:12:07 <thoughtpolice> @tell Lemmih I noticed that you found a pure haskell integer lib, I got lhc to compile it but it is not fairing so well :>
22:12:08 <lambdabot> Consider it noted.
22:12:56 <roconnor> > foldr (flip const) () [1..10]
22:12:57 <lambdabot>       Ambiguous occurrence `flip'
22:12:58 <lambdabot>      It could refer to either `Data.Functio...
22:13:11 <roconnor> @undefine
22:13:13 <roconnor> > foldr (flip const) () [1..10]
22:13:14 <lambdabot>   ()
22:13:19 <roconnor> > foldr (flip const) () [1..]
22:13:55 <roconnor> nanothief: the pure person inside me wants to do evaluate (foldr (flip const) () fileStr)
22:14:12 <roconnor> because integers shouldn't be involved
22:15:42 <nanothief> roconnor, true, although I would prefer evaluate (MAKE_THIS_STRICT_DAMMIT fileStr) :P
22:15:51 <mriou> hi, I think I have the dumbest question of the day but I have to ask
22:16:04 <mriou> I'm in the ST monad and I want to do: if expr1 then expr2 else expr3
22:16:31 <mriou> all expr in ST, so I know I can't do that as is (expr1 has to be boolean mostly)
22:17:11 <roconnor> mriou: http://hackage.haskell.org/trac/haskell-prime/wiki/DoAndIfThenElse
22:18:02 <roconnor> ``When I explain that they have to indent the else at least one more step, they invariably stare at me in disbelief and vow to henceforth stay far away from languages where layout has semantic significance.
22:18:32 <mriou> I never vow, it's against my religion :)
22:18:45 <dolio> We should just make else always have to be indented more.
22:18:47 <joed> Heh
22:19:08 <dolio> Problem solved.
22:19:36 <smarmy> i'll admit that when i first started haskell, if always threw me for a loop.  my first newbie aha moment was realizing i needed the else every time ;)
22:19:48 <jml> hmm.
22:20:16 <smarmy> imperative programming infects the brain
22:20:21 <roconnor> mriou: was that your problem?
22:20:28 <jml> how does one best restrict function domains in haskell
22:21:01 <roconnor> jml: what do you mean?
22:21:04 <jml> like, for a celsius to fahrenheit converter, raising an error if given a temperature below -273
22:21:10 <jml> something like that.
22:21:19 <roconnor> make a new data type
22:21:24 <mriou> roconnor: I think so although my if is nested in a lambda and it seems to cause some: parse error (possibly incorrect indentation)
22:21:34 <roconnor> make "smart constructors" that enforce the conditions
22:21:35 <mriou> trying to figure out the correct indentation
22:21:45 <jml> roconnor: ok, that makes sense.
22:21:54 <jml> roconnor: where can I find an example of that?
22:22:18 <roconnor> @wiki Smart_constructors
22:22:18 <lambdabot> http://www.haskell.org/haskellwiki/Smart_constructors
22:22:31 <jml> three cheers for internet :)
22:22:33 <llayland> why not just use gaurds on the function definition?
22:23:01 <lucca> llayland: and do what if the guards aren't met?
22:23:14 <lucca> you don't want to fall through a pattern match
22:23:26 <roconnor> jml:  you could also have smart constructors return Maybe Foo
22:23:31 <roconnor> if you don't want to generate a run time error
22:23:50 <jml> ok.
22:23:59 <jml> how does one handle a run time error in any case?
22:24:09 <dibblego> @type error
22:24:12 <lambdabot> forall a. [Char] -> a
22:24:17 <roconnor> run time errors can only be cause inside IO
22:24:22 <roconnor> caught
22:24:33 <jml> ok, I can see why that would be the case.
22:24:57 <mriou> roconnor: still can't figure out the correct indentation, can you tell me what's wrong here: http://pastie.org/338217
22:25:01 <roconnor> If you want to "catch" errors in pure code you have to use Maybe, or some MonadError
22:25:32 <smarmy> mriou: the else needs additional indentation
22:25:36 <roconnor> mriou: you need to indent the else by one
22:26:02 <lucca> or Either
22:26:08 <roconnor> I fear you copied the example from the page, which illustrates the error, and not the solution
22:26:23 <roconnor> right, Either e is an instance of MonadError.
22:26:24 <mriou> doh
22:26:43 <mriou> silly me
22:26:59 <mriou> smarmy, roconnor: thanks guys!
22:27:12 <smarmy> mriou: you can think of the 'then' and 'else' as both being subordinate to the if, so they must both be indented.  putting the then on the same line makes it non-obvious
22:27:13 <roconnor> @instances MonadError
22:27:14 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
22:28:00 <jml> so, presumably having some sort of branching (if or pattern match or something) that does different things based on how the Maybe turns out
22:28:15 <roconnor> wow, that list is very unclear
22:28:30 <roconnor> jml:
22:28:32 <roconnor> jml: yes,
22:29:01 <roconnor> jml: or you can use monad operations if you want to propagate the errors in the standard way.
22:29:08 <jml> *nod*
22:38:12 <nanothief> Is there something wrong with "read . show <$> getZonedTime :: IO ZonedTime" ? When I run it I get "Exception: Prelude.read: no parse"
22:39:33 <Cale> Maybe ZonedTime doesn't read the same way it shows?
22:40:17 <nanothief> Is that a bug, or is it just a convention that it read and show normally work in the same way
22:40:39 <Megzlna> Cale: http://hpaste.org/13039
22:40:39 <Megzlna> ?
22:41:25 <Cale> Megzlna: Ah, the ever-annoying monomorphism restriction.
22:41:58 <Megzlna> How does that restriction work?
22:42:07 <roconnor> Cale: once in my life the monomorphism restriction worked for me!
22:42:19 <roconnor> in that it did good
22:42:27 <roconnor> as opposed to the evil it ususally does
22:42:53 <Cale> Megzlna: When you make a definition which is a pattern binding (rather than a function binding), that is, you define something without parameters, and you don't explicitly give it a type signature, and that thing would normally be typeclass polymorphic, it's not allowed to be.
22:43:22 <Cale> Megzlna: Remember how typeclasses are translated by adding extra parameters to functions which take the dictionary?
22:43:27 <pumpkin> Cale: are there plans to fix that?
22:44:17 <Cale> Megzlna: Well, that also is capable of turning things which look like constants into functions -- causing something which you might have thought would only be computed once and retained to be computed every time it's needed.
22:44:28 <Cale> (at least, if you're not paying attention)
22:45:13 <mpeter> @slap Cale
22:45:14 <Cale> So the compiler forces the type to either be defaulted (in the case that it's a numeric thing), or just throws an error. Luckily this can be turned off.
22:45:14 * lambdabot places her fist firmly on Cale's jaw
22:45:19 <Cale> (I usually turn it off)
22:45:21 <mpeter> lambdabot is a girl??
22:46:05 <Cale> -XNoMonomorphismRestriction  or  {-# LANGUAGE NoMonomorphismRestriction #-} will turn it off.
22:46:41 <Cale> If you hate it as much as I do, you can also add a line to your .ghci which says :set -XNoMonomorphismRestriction
22:48:23 <roconnor> lambdabot has a webpage??
22:48:37 <roconnor> @where lambdabot
22:48:38 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
22:50:49 <Megzlna> sorry. network died.... reading log of what you said, Cale
22:51:02 <pumpkin> muahahaha, I got past the redirect
22:53:14 <pumpkin> GOA> :pl (concat .) . map
22:53:14 <pumpkin> (=<<)
22:53:17 <pumpkin> o.O
22:53:26 <pumpkin> @pl  (concat .) . map
22:53:26 <lambdabot> (=<<)
22:53:44 <pumpkin> ah
22:53:51 <Megzlna> Cale: So when you turn it off, you simply get an error, but it doesn't allow 'foo' to be polymorphic?
22:54:08 <Megzlna> @let foo = flip (+)
22:54:09 <lambdabot>  Defined.
22:54:15 <Megzlna> :t foo
22:54:16 <lambdabot> forall a. (Num a) => a -> a -> a
22:54:20 <Megzlna> hrm.
22:54:26 <Megzlna> :t flip
22:54:27 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
22:54:34 <Megzlna> @let flip f x y = f y x
22:54:35 <lambdabot>  <local>:1:6:
22:54:35 <lambdabot>      Ambiguous occurrence `flip'
22:54:35 <lambdabot>      It could refer to either ...
22:54:43 <Megzlna> @let flip_ f x y = f y x
22:54:44 <lambdabot>  Defined.
22:54:50 <Megzlna> @let foo = flip_ (+)
22:54:50 <lambdabot>  <local>:3:0:
22:54:50 <lambdabot>      Multiple declarations of `L.foo'
22:54:50 <lambdabot>      Declared at: <local>...
22:54:57 <Megzlna> arg :P
22:55:00 <Megzlna> @let foo_ = flip_ (+)
22:55:01 <lambdabot>  Defined.
22:55:05 <Megzlna> :t foo_
22:55:06 <lambdabot> forall t. (Num t) => t -> t -> t
22:55:23 <Megzlna> Great.
22:55:49 <Megzlna> Cale: what can go wrong if I turn off the monomorphism restriction?
22:56:11 <Megzlna> s/the/the no/
22:56:13 <Cale> Megzlna: Type signatures can affect the performance of your program.
22:56:43 <Cale> (if you turn it off)
22:57:44 <Cale> Megzlna: If you have a (Num a) => a, it will be computed every time it's needed. If instead, you have an Integer constant, say, it will be computed once so long as it remains in scope.
22:57:52 <Megzlna> Cale: What made it look like a constant?
22:58:08 <Cale> Well, the fact that it has no explicit parameters
22:58:16 <Cale> foo x y = flip (+) x y
22:58:28 <Cale> Is a function binding
22:58:29 <Megzlna> argh
22:59:04 <Megzlna> So when you turn off the no monomorphism restriction it throws the baby out with the bathwater and won't elide the dictionary on REAL constants?
22:59:16 <Megzlna> because it simply cannot tell the difference
22:59:57 <Cale> hm?
23:00:18 <Cale> Well, with foo, it doesn't actually likely affect performance, because foo is a function anyway
23:00:49 <Megzlna> yeah I mean for genuine places it should optimize
23:00:55 <Megzlna> <Cale> Megzlna: Remember how typeclasses are translated by adding extra parameters to functions which take the dictionary?
23:01:24 <Megzlna> re: my question   re: your hm?    -> I was asking if that dictionary isnt present in those not having explicit parameters
23:01:25 <Cale> If something is typeclass polymorphic, it is not really a constant.
23:02:12 <Megzlna>   (is my last q true?)
23:02:36 <Cale> Anything which is typeclass polymorphic has a dictionary parameter.
23:02:39 <Megzlna> Cale: why can't it figure out it's not really a constant due to the 'a' being presently unresolved?
23:02:55 <Cale> The MR simply forces certain bindings not to be typeclass polymorphic unless you explicitly say they should be
23:03:03 <mpeter> > error "hello cale!"
23:03:06 <lambdabot>   * Exception: hello cale!
23:03:28 <Cale> hi
23:03:46 <Megzlna> What word do you use for unresolved a's
23:04:32 <Megzlna> I wanted to say: So, it's useful someplaces, to have constants, with unresolved a's ?
23:06:18 <Cale> Megzlna: Yes.
23:06:23 <Megzlna> Where?
23:06:41 <Cale> Well, where you might have a constant that's needed at different types.
23:06:43 <Cale> :t pi
23:06:44 <lambdabot> forall a. (Floating a) => a
23:06:49 <Cale> :t 5
23:06:50 <lambdabot> forall t. (Num t) => t
23:07:25 <vininim> :t x
23:07:26 <lambdabot> Expr
23:07:40 <Megzlna> ah, the wonderful polymorphic 5
23:08:27 <Megzlna> Does NoMonomorphismRestriction affect '5' at all?
23:08:32 <vininim> :t x + 5
23:08:33 <lambdabot> Expr
23:08:37 <vininim> wat
23:08:58 <vininim> :t (+) x
23:08:59 <lambdabot> Expr -> Expr
23:09:22 <Cale> Megzlna: Well, if you make a pattern binding like:
23:09:23 <Cale> x = 5
23:09:49 <vininim> > (1 + 5) :: Expr
23:09:50 <lambdabot>   1 + 5
23:10:02 <Cale> Then x isn't allowed to be typeclass polymorphic without a type signature, and so defaulting will kick in and make it an Integer
23:10:14 <Cale> But it doesn't *directly* affect 5.
23:10:30 <vininim> :t (+) (1::Expr)
23:10:31 <lambdabot> Expr -> Expr
23:11:04 <Megzlna> @let x = 5
23:11:05 <lambdabot>  Defined.
23:11:08 <Megzlna> :t x
23:11:09 <lambdabot>     Ambiguous occurrence `x'
23:11:09 <lambdabot>     It could refer to either `L.x', defined at <local>:4:0
23:11:09 <lambdabot>                           or `SimpleReflect.x', imported from SimpleReflect at /home/cale/.lambdabot/State/L.hs:72:0-32
23:11:16 <ski_> @type L.x
23:11:18 <lambdabot> forall t. (Num t) => t
23:11:31 <lucca> now try 3.5*x
23:11:38 <Megzlna> yeah, it changes
23:11:41 <Cale> (The monomorphism restriction is turned off in lambdabot)
23:11:52 <Megzlna> the typesystem itself is lazy
23:12:05 <Cale> The typesystem isn't lazy...
23:12:14 <vininim> if the typesystem was lazy I think it wouldn't be static. =P
23:12:32 <jeffz`> what's the syntax to pattern match on multiple cases of function arguments in a lambda?
23:12:45 <Megzlna> not lazy in the sense of how the actual runtiime behaviour is lazy :)
23:12:46 <Megzlna> but..
23:12:54 <lucca> jeffz`: case?
23:12:56 <Cale> It's just that x :: (Num a) => a, and then 3.5 :: (Floating a) => a, and so 3.5 * x :: (Floating a, Num a) => a, but Floating is a subclass of Num, so it elides that.
23:12:59 <jeffz`> lucca: without case?
23:13:09 <Megzlna> Cale: What do you call this "don't determine your real type until the endgame" behaviour of 'x' ?
23:13:27 <lucca> that's what I use; lemme know if you find a better one
23:13:29 <Cale> Megzlna: Well, it's typeclass polymorphism.
23:13:41 <Megzlna> just applied to even primitives
23:13:41 <jeffz`> lucca: I thought one existed like you can with named functions, maybe I'm mistaken
23:13:51 <Megzlna> unless it's  1#
23:13:59 <Megzlna> Unboxed
23:14:26 <ski_> Megzlna : overloading
23:15:27 <ski_> iirc, Ada also allows overloading where resolution might depend only result type
23:15:35 <ski_> s/only/only on/
23:18:51 <jsn> earlier, we talked about how monads sequence effects
23:19:11 <jsn> the effect that the Parsec monad sequences is getting a char
23:19:32 <jsn> the effect that the list monad sequences is nondeterministic choice from a list
23:19:41 <jsn> (or any number of lists)
23:19:56 <jsn> what effect does the IO monad sequence?
23:20:22 <lucca> the real world
23:25:04 <jsn> hmm
23:25:27 <jsn> maybe it sequences some computational effect with the GHC runtime, though?
23:25:35 <jsn> s/with/within/
23:25:48 <jsn> or in other haskell system's runtimes
23:28:34 <ski_> jsn : what effect does the `Reader r' monad sequence ?
23:28:36 <Cale> jsn: The IO monad sequences input/output effects
23:29:04 <dons> jsn: yeah, it orders the execution of operations on input and output
23:29:06 <ski_> morning #haskell
23:29:11 <dons> (aka "the world")
23:29:22 <dons> like imperative languages do with ';'
23:30:04 <jsn> but even if there are no operations
23:30:13 <jsn> it still sequences something, right?
23:30:35 <jsn> do { x <- return 0 ; y <- return 1 ; return 2 }
23:31:10 <Cale> jsn: Well, the monad laws let you reduce that to  return 2
23:31:32 <dolio> Didn't we just have this conversation a day or two ago?
23:31:36 <Cale> Actually, the IO monad is more than just a monad...
23:31:48 <dons> we're having these a lot recently , dolio :) new people!
23:31:57 <dolio> I think it was the same people. :)
23:32:10 <jsn> dons: i have been on this topic for awhile, actually
23:32:18 <Cale> It has, for instance,  forkIO :: IO a -> IO ThreadId  which lets you express that something is to happen concurrently.
23:32:38 <Cale> as well as exceptions
23:32:49 <dons> jsn: on sequencing and monads?
23:32:54 <jsn> dons: yes
23:33:02 <dons> well, its an interesting topic.
23:33:06 <Cale> and perhaps some other combinators related to sequencing which not just any monad would have...
23:33:22 <Cale> Oh, the IO monad has evaluate, which is interesting.
23:33:26 <dolio> Just throw any old thing in there. :)
23:33:27 <Cale> :t evaluate
23:33:28 <lambdabot> Not in scope: `evaluate'
23:33:37 <Megzlna> length [1,2,3] :: Int
23:33:39 <Cale> :t Control.Exception.evaluate
23:33:40 <lambdabot> forall a. a -> IO a
23:33:44 <Megzlna> why is that Int ?
23:33:53 <Cale> It lets you sequence evaluation with IO actions :)
23:33:58 <dolio> You can use unsafeInterleaveIO to get results that are only explainable by spooky nondeterminism effects. :)
23:34:07 <jsn> interesting
23:34:22 <Cale> Megzlna: Not any particularly good reason.
23:34:45 <jsn> the ubiquity of signed types in haskell is a great frustration
23:34:53 <Megzlna> it would make working with Integer annoying
23:34:53 <Cale> Megzlna: The justification is that Int is fast and if computing the length of a list terminates, the length probably fits in an Int
23:35:03 <Megzlna> ok
23:35:07 <Cale> Yes, it does, which is why I hate it.
23:35:12 <solrize_> that is not a good bet, it actually seems like a bug that length returns an int
23:35:23 <Cale> There is  genericLength  in Data.List, but it's really not a good situation.
23:35:23 <dolio> Megzlna: Lots of Prelude (and other) functions are monomorphic because there was a contingent of monomorphism lovers back when Haskell 98 was standardized. :)
23:35:36 <solrize_> for example the length could be the length of a disk file which very often won't fit in a 32-bit int these days
23:35:42 <Cale> solrize_: People actually did think about it though, when writing up Haskell 98.
23:35:46 <ski_> (Cale : well, most monads are "more than just a monad" ..)
23:35:51 <Cale> ski_: Yes.
23:35:57 <Megzlna> What did they argue for the monomorphism?
23:36:14 <dolio> Megzlna: Less confusing compiler errors for students.
23:36:15 <Cale> ski_: But in the sense of having additional things related to the order of execution.
23:36:21 <Megzlna> dolio: lol
23:36:31 <Cale> ski_: and not just extra effects.
23:36:34 <solrize_> cale i think in 1998, 2gb may have been a large disk
23:36:41 <Cale> solrize_: Right.
23:36:49 <Megzlna> The fact that stuff was monomorphic at all was what I found most confusing
23:36:53 <ski_> Cale : is there a strict difference ?
23:37:03 <solrize_> but, ints are just evil through and through
23:37:11 <Cale> ski_: I'm not sure :)
23:37:50 <solrize_> i can understand avoiding the overhead of boxing all the integers if you expect the value to fit in a machine word, but the default int type ought to signal an exception on overflow
23:37:55 <solrize_> even if it's unboxed
23:38:14 <Cale> The Int type shouldn't even be in the Prelude as far as I'm concerned.
23:38:20 <solrize_> int overflow is no different from buffer overflow
23:38:21 <Cale> It should be in Data.Int.
23:38:21 <solrize_> right
23:38:50 <Megzlna> Cale you're such an extremist
23:39:07 <dons> hehe
23:39:08 <Cale> I've had Int bite me more times than I've needed it for performance.
23:39:31 <dons> militant puritan.
23:39:48 <dons> won't leave our fmaps alone, and now Int isn't safe!
23:39:54 * wli hammers out a sieve of Eratosthenes.
23:39:57 <Cale> I usually try to use Integer, but occasionally I'll write something while leaving type signatures out, and an Int will sneak in, and I've had that cause results to be incorrect.
23:40:24 <dons> Cale: you could upload a Prelude.Done.Right
23:40:34 <dons> with genericLength instead of length
23:40:40 * wli uses integer almost exclusively except for where base/Prelude/Library API's (e.g. take/drop/etc.) demand such.
23:40:41 <dons>  and no monomorphism restriction by default
23:41:05 <Cale> dons: I've been thinking a little about how we could reasonably work with more than one base package.
23:41:19 <wli> monad comprehensions trip hard over compiler intrinsics
23:41:37 <Cale> I think we have a bit of a problem in that people don't want to implement stuff which breaks compatibility with the standard, and don't want to standardise stuff which is unimplemented.
23:41:37 <wli> The numerical affairs do so in like fashion.
23:41:49 <Megzlna> I guess because of the way the type system works, a single Int could propagate
23:41:54 <Cale> Megzlna: right.
23:42:00 <Megzlna> through a whole chain of unifications
23:42:04 <Cale> Megzlna: That's where most of my issues with it come from.
23:42:05 <solrize_> i don't think genericlength is necessarily the answer.  on a 64-bit machine (or sometimes 32-bit) i really do expect all the integers to fit in machine words, so they may as well be unboxed.  but in that case i think the compiler should generate overflow checks on arithmetic just like it generates bounds checks on array lookups
23:42:12 * wli is wearing too much makeup.
23:42:12 <solrize_> safeInt rather than genericInt
23:42:35 <wli> ergh, means for #haskell-blah
23:42:44 <mpeter> yeah yeah
23:42:47 <nyingen> there's a haskell-blah?
23:43:28 <jsn> it would be nice if (+) and such just didn't overflow things
23:43:32 <solrize_> @seen lambdabot
23:43:32 <lambdabot> Yes, I'm here. I'm in ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosxdev, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.it, #
23:43:32 <lambdabot> haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, ##freebsd, #gentoo-uy, #gentoo-haskell, #friendly-coders, #
23:43:32 <lambdabot> dreamlinux-es, #darcs, #concatenative, #arch-haskell, #xmonad, #ghc, ##logic, #haskell-overflow and #haskell
23:43:37 <august> better question: goth or sorority chick?a
23:43:39 <jsn> (+andHoldIt)
23:43:39 <august> -a
23:43:41 <dons> jsn: well, (+) doesn't on the right type.
23:43:52 <jsn> dons: which is Integer?
23:43:55 <dons> yeah
23:43:57 <dons> or Rational or ...
23:44:05 <jsn> well, i mean, on fixed width types
23:44:15 <jsn> what good is overflow?
23:44:22 <jsn> who needs it?
23:44:29 <dons> so error?
23:44:34 <jsn> no
23:44:36 <Cale> Well, Integer is like safeInt so long as you don't use values which are too large.
23:44:38 <jsn> do nothing
23:44:40 <solrize_> some algorithms expect to do arithmetic in z//2**32
23:44:47 <jsn> maxBound + 1 == maxBound
23:44:51 <solrize_> cale, aren't integers always heap allocated?
23:44:54 <dons> do nothing? make it a static error?
23:44:59 <jsn> no
23:45:01 <dons> ?src Integer
23:45:01 <lambdabot> data Integer = S# Int#
23:45:01 <lambdabot>              | J# Int# ByteArray#
23:45:13 <solrize_> raise an exception similar to an array oob error
23:45:13 <Cale> solrize_: So are Ints, modulo possible optimisations...
23:45:19 <dons> construct specialisation on integer seems interesting..
23:45:19 <jsn> making it a static error would require dependent types
23:45:23 <Cale> ?src Int
23:45:24 <lambdabot> data Int = I# Int#
23:45:30 <dons> jsn: well, not nec. dependennt.
23:45:40 <jsn> dons: no?
23:46:00 <dons> we can do type math, so we can do type overflow checking. just not fun.
23:46:23 <jsn> i don't see how you would handle    do { (i :: Word) <- read ; return $ i + 1 }
23:46:33 <solrize_> how are those sum types represented in memory?  with a tag bit?  a cons cell saying what type constructor made the number?
23:46:39 <dons> it would be Word n
23:46:46 <sjanssen> jsn: that sort of thing requires dependent typing
23:46:53 <mpeter> dons, are you a tenth as much of a scenester as your south park character picture leads me to believe
23:46:54 <jsn> right
23:47:05 <jsn> dons: a Word n?
23:47:06 <dons> south park character?
23:47:11 <jsn> Word 32?
23:47:18 <dons> jsn: peano encoding of  the number, for example
23:47:36 <dons> so the type depends on the value, making 'read' non-trivial to type.
23:47:44 <sjanssen> jsn: you can provide a primitive that checks a number to make sure it fits into the static type
23:47:45 <jsn> oh, dear
23:47:58 <jsn> yes
23:47:59 <sjanssen> eg. Int -> Maybe RestrictedInt
23:48:11 <jsn> sjanssen:  but even if it does fit, i'm talking about +
23:48:16 <dons> mpeter: no?
23:48:31 <Cale> It would be quite interesting to see if my conjecture is true though.
23:48:40 <jsn> also, what is the deal with succ and pred throwing errors?
23:48:47 * mpeter loses interest
23:48:56 <Cale> (That checked Ints are equivalent in performance to Integer so long as they remain in bounds.)
23:48:58 <sjanssen> jsn: I suppose (+) :: Int Max1 -> Int Max2 -> Int Max3
23:49:11 <sjanssen> where Max3 = Max1 + Max2
23:49:18 <jsn> sjanssen: well, then it changed width, though
23:49:27 <sjanssen> jsn: yes, possibly
23:49:39 <sjanssen> jsn: but this is more a problem with addition than anything else
23:49:40 <jsn> but that's not what i want with   Word32 + Word32
23:49:50 <jsn> well, minusification, also
23:49:59 <jsn> 0 - 1 :: Word
23:50:06 <jsn> should be 0
23:50:07 <sjanssen> jsn: or you could choose that (+) overflow does modulus of max
23:50:19 <dons> sjanssen: remember when we used GADTs to type the length of lists in xmonad?
23:50:22 <jsn> sjanssen: that is what overflow is, yeah?
23:50:32 <sjanssen> dons: when did we do that?
23:50:43 <sjanssen> jsn: well, max + 1 == max is not sane either
23:50:53 <jsn> sjanssen: why not?
23:50:54 <sjanssen> dons: actually, I don't remember that at all
23:51:10 <sjanssen> jsn: because a + b == a only when b == 0 :)
23:51:19 <dons> Did you mean: site:xmonad.org gadgets static
23:51:21 <jsn> maybe fixed width types should not have (+) then
23:51:29 <dons> sjanssen: i do :
23:51:30 <dons> )
23:51:32 <dons> let me find the code.
23:51:42 <jsn> sjanssen: well, what about   3 + maxBound  ?
23:51:50 <jsn> is that situation sane?
23:52:00 <jsn> > 3 + maxBound :: Word
23:52:02 <lambdabot>   2
23:52:06 <solrize_> """
23:52:06 <solrize_> I find it amusing when novice programmers believe their main job is
23:52:06 <solrize_> preventing programs from crashing.  I imagine this spectacular failure
23:52:06 <solrize_> argument wouldn't be so appealing to such a programmer.  More
23:52:06 <solrize_> experienced programmers realize that correct code is great, code that
23:52:07 <solrize_> crashes could use improvement, but incorrect code that doesn't crash is
23:52:09 <solrize_> a horrible nightmare.
23:52:11 <solrize_> """ --- cds
23:52:24 <sjanssen> jsn: it does match a certain mathematical structure (integers modulus 2^32)
23:52:32 <sjanssen> jsn: really the only sane type is Integer
23:52:48 <sjanssen> jsn: everything else is a compromise, choose the compromise that fits your situation best
23:52:57 <jsn> well, the only type that actually follows the laws of addition, yeah
23:53:26 <erikc_> solrize: whats that from
23:53:29 <sjanssen> the new haddock really sucks.  I'm trying to build GHC 6.10, tell me again why a documentation system needs 400MB of RAM?
23:53:44 <jsn> solrize: who is cds?
23:53:44 <dons> sjanssen: just using,
23:53:44 <dons> +data List x y where
23:53:44 <dons> +     Nil  :: List Empty x
23:53:44 <dons> +     Cons :: x -> List y x  -> List NonEmpty x
23:53:53 <sjanssen> dons: why?
23:53:55 <dons> so not length, just the non-emptiness
23:54:02 <dons> sjanssen: to rule out not supplying a layout.
23:54:02 <jsn> solrize: overflow does not crash the program
23:54:16 <dons> http://www.haskell.org/pipermail/xmonad/2007-May/000171.html
23:54:21 <sjanssen> dons: that was actual code in the repo?
23:54:25 <sjanssen> or just a proposal?
23:54:33 <dons> "And a patch, just so its archived somewhere."
23:54:35 <sjanssen> IIRC, we finally went with some tuple encoding
23:54:40 <dons> looks like it didn't get committed
23:54:58 <dons> the 'non-empty' list type looks useful enough to be on hackage
23:54:59 <sjanssen> I think we had: (Layout, [Layout])
23:55:03 <dons> yeah
23:55:09 <dons> bah. not gadt-ish enough :)
23:55:26 <sjanssen> it is certainly Haskell 98-ish enough :)
23:55:44 <dons> bah, pragmatism
23:56:00 <jsn> i think alternative list types will be useful when there is syntactic support for them
23:56:05 <dons> jsn: so interesting bit of haskell programming. we had a bug report, so we solved it in the type system, http://www.haskell.org/pipermail/xmonad/2007-May/000172.html
23:56:06 <solrize_> jsn, cds (should have said cdsmith) = chris smith who comes around here sometimes.  the quote is from his type system article
23:56:19 <dons> jsn: no need.   x .:. y .:. z
23:56:21 <dons> good enough
23:56:24 <solrize_> jsn: http://www.pphsg.org/cdsmith/types.html
23:56:27 <dons> since we can define infix ops.
23:56:43 <sjanssen> this is beyond ridiculous.  Anyone know what switch to flip to turn off building docs in GHC?
23:56:54 <jsn> dons: well, can you use list comprehensions with that stuff?
23:57:05 <sjanssen> (also, will the switch take effect even after building stage 2?)
23:57:07 <dons> nope. only by flattening to a list.
23:57:12 <dons> list comps aren't general enough.
23:57:32 <dons> hmm. we'd need to support Foldable, Traversable, Monoid, ConcatMap-able I guess.
23:57:38 <dons> then other sequences could be list-comp-ified
23:57:40 <sjanssen> it is also hard to prove that a list comprehension will return a non-empty result
23:57:47 <dons> actually, just stream fusible.
23:57:51 <sjanssen> (in the type system)
23:58:00 <jsn> mmm
23:58:05 <dons> pretty hard. list comps are arbitrary groupings of bindings, filter, concat,
23:58:06 <jsn> yeah, because of conditionals
23:58:13 <sjanssen> filter is the problem
23:58:21 <sjanssen> and the pattern matching
23:58:39 <dons> are mutually recursive bindings allowed in list comps?
23:58:53 <sjanssen> I don't think so
23:59:05 <sjanssen> but maybe they could?  Is list an instance of MonadFix?
23:59:26 <sjanssen> @instances MonadFix
23:59:28 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
23:59:31 <sjanssen> yep
23:59:38 <dons> > [ z | x <- [1..10], let y = x : z ; z = x : y ]
23:59:39 <lambdabot>   [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
