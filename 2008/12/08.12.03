00:03:31 <pumpkin_> can anyone see a really efficient way of finding the best separation between two lists of values?
00:04:01 <pumpkin_> I'm doing it the exhaustive way now and it's really slow :/
00:04:28 <pumpkin_> seems like I should be able to sort both lists and take advantage of that somehow, but I'm not sure if that'll be faster than partition
00:04:38 <dmwit> Are you still doing decision stumps?
00:04:59 <pumpkin_> dmwit: yup :) I have code that works but it's insanely slow, and most of the time is spent in that partition function
00:05:02 <dmwit> It should be an O(n) operation.  O(n log n) if the values aren't in order and you have to sort first.
00:05:44 <pumpkin_> hmm
00:06:12 <pumpkin_> if it's O(n) it either has a really big constant in the one I have, or I'm doing something stupid
00:06:25 <pumpkin_> probably both :P
00:06:45 <dmwit> It should be doable in two passes.  "2" is not a big constant
00:07:15 <pumpkin_> oh, mine is stupid and is doing n^2
00:07:21 <pumpkin_> lol
00:07:50 <pumpkin_> wow, what the hell was I thinking
00:08:56 <dibblego> is there an abstraction of Either (Maybe a) (Maybe b) -> Maybe (Either a b)?
00:10:30 <jkff> @seen vixey
00:10:30 <lambdabot> I saw vixey leaving #perl6, ##logic and #haskell 7h 54m 58s ago, and .
00:16:31 <sbahra> dons, ping
00:19:14 <pumpkin_> dmwit: hmm, still can't seem to get it right
00:20:00 <pumpkin_> would you mind giving me a couple more hints?
00:20:50 <dolio> Looks like some kind of bisequence or something. I'd look in category-extras, but I don't know if it actually has anything.
00:21:01 <dmwit> Consider the difference between the misclassification errors when you move the boundary one element to the right.
00:21:15 <grom358> any suggestions for improvements, http://hpaste.org/12657
00:21:54 <dolio> dibblego: ^^
00:22:07 <quicksilver> Beelsebob: interesting lesson learnt. commenting out debug prints can cause serious memory leaks
00:22:14 <d2dchat> is haskelldb the most popular SQL library?
00:22:50 <dolio> grom358: Is this the one where you have to find the shortest path down the triangle?
00:22:57 <grom358> yeah
00:23:16 <dolio> grom358: You're going to feel bad when you see the short solution someone came up with. :)
00:24:13 <solrize> @hoogle evaluate
00:24:13 <lambdabot> Control.Exception evaluate :: a -> IO a
00:24:13 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
00:24:16 <dolio> It's 1 or 2 lines, not counting parsing the triangle. :)
00:24:32 <grom358> dolio: oh... show me please
00:24:52 <dolio> Did you get the answer? It should be in the discussion somewhere.
00:25:07 <grom358> dolio: yeah.. okay I'll go looking
00:25:19 <quicksilver> d2dchat: I would guess not. I would guess HDBC or takusen. I could be wrong.
00:25:38 <dolio> Searching pages for zipWith should make it easier to find.
00:25:50 <grom358> dolio: do you know if this 2 line solution works with the real big triangle
00:25:57 <dolio> Yes, it does.
00:26:44 <d2dchat> quicksilver: which one do you prefer?
00:26:56 <quicksilver> d2dchat: I've not used any of them.
00:27:19 <quicksilver> I think HDBC probably has the best docs and is well supported. I think takusen is 'cleverer' in its API.
00:27:32 <quicksilver> d2dchat: I woudl recommend you read the DB chapter in "real World Haskell"
00:27:38 <quicksilver> (book, but it's availble online for free)
00:28:02 <dolio> grom358: Don't feel too bad, though. I'd been doing Haskell for some time before trying that problem, and I didn't come up with that solution either. I just used some boring old dynamic programming.
00:34:09 <dolio> @type \t -> foldr1 (\r r' -> zipWith (+) r $ zipWith min r' (tail r'))
00:34:11 <lambdabot> forall t a. (Ord a, Num a) => t -> [[a]] -> [a]
00:34:13 <dolio> @type \t -> foldr1 (\r r' -> zipWith (+) r $ zipWith min r' (tail r')) t
00:34:14 <lambdabot> forall a. (Ord a, Num a) => [[a]] -> [a]
00:34:23 <dolio> @type foldr1 (\r r' -> zipWith (+) r $ zipWith min r' (tail r'))
00:34:24 <lambdabot> forall a. (Ord a, Num a) => [[a]] -> [a]
00:34:57 <pumpkin_> the the merge step from merge sort available anywhere as a function?
00:35:38 <pumpkin_> @hoogle (Ord a) => [a] -> [a] -> [a]
00:35:39 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
00:35:39 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
00:35:39 <lambdabot> Data.List insert :: Ord a => a -> [a] -> [a]
00:36:23 <dibblego> dolio, thanks
00:37:26 <grom358> dolio: OMG
00:38:10 <dolio> pumpkin_: Sadly, no.
00:39:00 <pumpkin_> ah well
00:39:29 <pumpkin_> how expensive is reversing a haskell list? is it doubly linked with a pointer to the end?
00:39:37 <pumpkin_> I guess it can't be
00:39:54 <dmwit> Reversing is O(n).
00:39:55 <dibblego> pumpkin_, if there were a pointer at the end, it wouldn't be infinite then innit?
00:39:55 <dolio> Huh, base still doesn't use the improved mergesort from (I think) yhc.
00:40:09 <pumpkin_> dibblego: yeah :P
00:40:23 <BeelsebobWork> pumpkin_: even if it were doubly linked, it would still need the next and previous pointers swapped for all elements
00:40:29 <BeelsebobWork> so it would still be O(n)
00:41:14 <pumpkin_> BeelsebobWork: well, if you could have a little wrapper that said "I'm going through it forwards or backwards" and just duplicated that when you reversed it, it could be faster than that
00:41:25 <pumpkin_> as long as whatever iterating over it knew which it was iterating over
00:41:38 <pumpkin_> but infinite lists don't fit well with a "pointer to the end" :P
00:41:56 <harblcat> I'm trying to figure out how to use getChar... I have a simple loop, where I want to get a character, do something, get another character, etc. but it doesn't do anything till I enter a newline. Any ideas?
00:41:57 <dolio> grom358: Yeah, it's pretty mind blowing.
00:42:30 <dmwit> harblcat: Turn off buffering.
00:43:59 <harblcat> hSetBuffering stdin NoBuffering ?
00:44:35 <dmwit> correct
00:45:18 <harblcat> Alright! I must be getting better at this whole "thinking different" thing.
00:45:32 <harblcat> Or maybe I just used hoogle...
00:45:41 <hydo> Ok, I have to tell someone and everyone else here who would appreciate it is asleep.  I just 'got' curried functions after many many years in Perlsville.  I mean, they haven't fully congealed yet, and i'll definitely read over the chapter on them I've been reading but... ho-lee-shit... what a technique.
00:46:10 <dmwit> hydo: Awesome. =)
00:48:12 <jkff> hydo: Grats :) Just to make your understanding better: how would you explain what a curried function is, and what is it good for?
00:48:21 <hydo> dmwit: :)  I haven't felt this sort of power since I was taught the *{} operator in perl.  (injects a code ref into a package pragmatically)
00:48:50 <jsn> hydo: power _and_ safety :)
00:49:13 <hydo> Oh man, I can't answer that yet... I need a quick smokey treat... let me do that, come back and skim over the chapter, and then I'll attempt it if you are still here.
00:49:51 <grom358> dolio: I still don't see the magic of this yet.. Mainly the zipWith max (init cs) (tail cs) part
00:49:57 <jkff> I'll be here for approximately the next 8 hours
00:51:37 <jkff> ...And, in the meantime: Anyone proved Reynolds parametricity for polylambda in Coq?
00:51:55 <opqdonut> what's reynold parametricity?
00:51:58 <dmwit> There's a fellow here who has.
00:52:01 <dmwit> I think.
00:52:21 <dmwit> If Reynold's parametricity is the usual parametricity and polylambda is system F.
00:52:36 <olsner> wow, perl has an three-char operator for magically breaking code from other packages?
00:52:50 <jkff> opqdonut: See Wadler, "Theorems for free"
00:52:58 <grom358> does ghci have something that can show the expansion of how a function evaluates?
00:53:06 <wkh> how do you use lambdabot's pointfree converter thing?
00:53:17 <jkff> dmwit: I am actually trying to coqize Wadler's paper to play with its ideas, so I mean the parametricity that he uses
00:53:42 <dmwit> jkff: Yep, there's a guy here (at UPenn) who just finished coq-ifying that.
00:53:49 <jkff> I got stuck while expressing the type-relation for type universal quantifier.
00:54:03 <wkh> > 2 + 3
00:54:04 <lambdabot>   5
00:54:21 <wkh> > pl \a b -> sum $ zipWith (*) a b
00:54:21 <jkff> dmwit: Do you know his nick?
00:54:22 <lambdabot>   <no location info>: parse error on input `\'
00:54:31 <dmwit> This guy: http://www.seas.upenn.edu/~jianzhou/
00:54:32 <lambdabot> Title: 100011
00:54:40 <dmwit> Isn't his web page so informative?
00:54:44 <wkh> > pl dotProduct a b = sum $ zipWith (*) a b
00:54:45 <lambdabot>   <no location info>: parse error on input `='
00:54:53 <dmwit> He's not even a first-year any more. ^_^
00:54:53 <jkff> Cool, thanks. I'll try to do that myself but if I don't succeed I'll contact him.
00:54:55 <wkh> i suck at lambdabot
00:55:04 <baaba> @pl \a b -> sum $ zipWith (*) a b
00:55:04 <lambdabot> (sum .) . zipWith (*)
00:55:08 <wkh> oh
00:55:10 <jkff> Wow, his page says a lot
00:55:31 <jkff> Probably googling his nick will say more.
00:55:47 <dmwit> probably not
00:56:07 <jkff> Googling his nick said me that there are a lot of people whose name is jianzhou
00:56:17 <dmwit> But emailing him should work; use seas.upenn.edu as your domain.
00:56:32 <jkff> Ok, thanks
00:56:39 <wkh> is there an elegant way to do a naive dot-product that's point-free and roughly along the lines of "sum $ zipWith (*)"?
00:56:53 <sbahra> UPenn is better than GWU.
00:57:01 <sbahra> That is, CS. By far :-(
00:57:43 <jkff> wkh: Why are you not satisfied with (sum.).zipWith (*) ?
00:58:03 <wkh> @jkff "sum ." seems weird
00:58:03 <lambdabot> Unknown command, try @list
00:58:11 <wkh> er. jkff: rather. whatever
00:58:32 <dmwit> I suggest either using a pointful notation or getting used to weirdness.
00:58:57 <dmwit> Point-free notation can be very unclear sometimes.
00:59:00 <wkh> \a b -> sum $ zipWith (*) a b is still pretty good, i think
00:59:04 <dmwit> (But when it works... it *really* works.)
00:59:06 <jkff> wkh: I doubt you can do anything point-free and useful without using function composition.
00:59:40 <jkff> @type on
00:59:41 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
00:59:58 <jkff> > @type (`on` zipWith (*))
00:59:59 <lambdabot>   <no location info>: parse error on input `@'
01:00:05 <jkff> @type (`on` zipWith (*))
01:00:06 <lambdabot> forall c a. (Num a) => (([a] -> [a]) -> ([a] -> [a]) -> c) -> [a] -> [a] -> c
01:00:10 <jkff> Ouch
01:00:47 <jkff> @type (zipWith (*) `on`)
01:00:48 <lambdabot> forall a a1. (Num a) => (a1 -> [a]) -> a1 -> a1 -> [a]
01:00:56 <grom358> dolio: just found this one liner version
01:01:00 <grom358> > let reduce a b = zipWith (+) a (zipWith max b (tail b)) in foldr1 reduce [[75],[95,64],[17,47,82]]
01:01:01 <lambdabot>   [221]
01:01:56 <dolio> Yeah, that's the one I was thinking of.
01:03:04 <grom358> so.. is this working from bottom to top?
01:03:59 <jkff> @pl \f g x y -> f (g x y)
01:03:59 <lambdabot> (.) . (.)
01:04:18 <wkh> is that the so-called boob combinator
01:04:40 <jkff> At least it's easy to remember
01:04:45 <hydo> boob combinator... god, I love this language.
01:05:38 <jkff> It's nice that you can compute a dot product using a boob combinator.
01:06:14 <jkff> > (((.) . (.)) sum (zipWith (*))) [1,2,3] [4,5,6]
01:06:15 <lambdabot>   32
01:06:19 * BeelsebobWork prefers to use (fmap . fmap) rather than boobs
01:06:26 <BeelsebobWork> it's the fabled fap fap operator!
01:07:47 <BeelsebobWork> having said that -- I need to find a use for the owl combinator...  <^((.) . (.))^>
01:08:03 <jkff> @type (<^)
01:08:04 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f a -> (a -> b) -> f b
01:08:10 <jkff> @type (^>)
01:08:11 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
01:08:19 <BeelsebobWork> jkff: it's liftA2 boobs
01:08:44 <jkff> @type liftA2
01:08:46 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
01:08:50 <jkff> Ah
01:11:24 <hydo> My subconscious really isn't liking this whole idea of curried functions.  "Calling a function with less arguments than it's defined for to 'seed' it somehow?  What's next?  Cats and dogs living together?  Mass hysteria?"
01:11:41 <pumpkin_> *fewer ;)
01:11:41 <hydo> I must unlearn...
01:11:47 <hydo> yes, fewer,
01:12:01 <pumpkin_> :)
01:12:13 <ksf> hydo, it might be easier if you accept the fact that _no_ function has more than one argument, _ever_.
01:12:40 <hydo> That's gotta be one of the bigger roadblocks for newbs like myself... the brain screams "That will throw an error!".  The unlearn is much harder than the learn.
01:12:44 <pumpkin_> dammit, my mind is so out of it
01:12:48 <jkff> hydo: Think of a function as of a black box with some inputs and one output. Then, if you stick one of its inputs with a particular value, you will get another black box that has one less inputs, but still is a black box.
01:12:55 <pumpkin_> I almost have this damn separation function I think
01:12:58 <ksf> actually, inside a hypothetical thing called the function monad, every function may well be nullary.
01:13:08 <jkff> Once you've filled all the inputs of the box, you end up with a box that only has an output. Such a box is the same as a regular value.
01:14:02 <jkff> The difference between Haskell and C (for instance) is that in Haskell you can fill the inputs one-by-one, whereas in C you always have a black box with only one input, but into that input you have to stick a whole bunch of values.
01:15:03 <ksf> in c, all functions are of the form foo (a,b,c,d) = bar
01:15:08 <jkff> Precisely
01:15:13 <ksf> 'xept varargs, of course.
01:16:56 <hydo> So let me make 100% sure I'm clear on this.  In ghci, :t max gives back "max :: (Ord a) => a -> a -> a" which reads, literally, max takes something of typeclass Ord and returns a function that takes a thing of the same type as 'a' and returns a function that takes a thing ... and so on.
01:17:26 <Axman6> it only returns one function afaik
01:17:27 <jkff> Don't confuse => with ->
01:17:27 <jkff> Better start with some simpler function
01:17:48 <Axman6> :t (+)
01:17:50 <lambdabot> forall a. (Num a) => a -> a -> a
01:18:06 <Axman6> or better yet...
01:18:08 <Axman6> :t id
01:18:09 <lambdabot> forall a. a -> a
01:18:20 <ksf> basically, yes. Ord a constrains a to all a that have Ord instances.
01:18:21 <Axman6> actually no.. damn, this is difficult :P
01:18:48 <dmwit> hydo: I think you have one too many "returns a function" clauses there.
01:18:53 <ksf> that is, the a is matched first, then checked on whether or not the concrete type inserted has an Ord instance
01:18:54 <dmwit> :t const
01:18:56 <lambdabot> forall a b. a -> b -> a
01:19:01 <dmwit> Axman6: How about that one? ;-)
01:19:09 <PeakerWork> :t flip const
01:19:10 <lambdabot> forall a b. b -> a -> a
01:19:12 <ksf> you shouldn't think "returns" but "is".
01:19:17 <Axman6> hydo: basically, it takes an a, and returns a function that takes another a, and returns an a
01:19:17 <jkff> :t map
01:19:18 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
01:19:19 <grom358> @src foldr1
01:19:19 <lambdabot> foldr1 _ [x]    = x
01:19:20 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
01:19:20 <lambdabot> foldr1 _ []     = undefined
01:19:23 <Axman6> dmwit: perfect
01:19:26 <jkff> :t map (+1)
01:19:28 <lambdabot> forall a. (Num a) => [a] -> [a]
01:19:31 <jkff> :t map (+1) [1,2,3]
01:19:32 <lambdabot> forall a. (Num a) => [a]
01:19:44 <Axman6> :t max
01:19:45 <lambdabot> forall a. (Ord a) => a -> a -> a
01:19:46 <Axman6> :t max 1
01:19:46 <jkff> See how I filled the inputs one by one
01:19:48 <lambdabot> forall t. (Ord t, Num t) => t -> t
01:19:51 <Axman6> :t max 1 3
01:19:52 <lambdabot> forall t. (Ord t, Num t) => t
01:20:17 <pumpkin_> dmwit: the other issue is that I want to give the smaller of my two classes more weight, or the other will "win" the separator allocation without any effort
01:20:50 <dmwit> Weights should not be a problem.
01:21:07 <dmwit> ...unless I'm severely misunderstanding the problem space.
01:21:08 <ksf> hydo, one of the most important things to grok is that a -> a -> a -> a -> a means (a -> ( a -> ( a -> ( a  -> a)))
01:21:20 <hydo> oh
01:21:39 <hydo> where each () is a separate and distinct operation?
01:21:45 <jkff> Yes
01:21:59 <quicksilver> BeelsebobWork: so, I had a debugging print displaying an event of interesting diagnostics.
01:21:59 <Axman6> :t max (a :: Ord a => a)
01:22:00 <lambdabot>     Couldn't match expected type `a' against inferred type `Expr'
01:22:00 <lambdabot>       `a' is a rigid type variable bound by
01:22:00 <lambdabot>           the polymorphic type `forall a. (Ord a) => a' at <interactive>:1:5
01:22:05 <jkff> Note the "means": not "may be interpreted as", but actually "means". It's the same thing.
01:22:07 <Axman6> :t max (x :: Ord a => a)
01:22:09 <lambdabot>     Couldn't match expected type `a' against inferred type `Expr'
01:22:09 <lambdabot>       `a' is a rigid type variable bound by
01:22:09 <lambdabot>           the polymorphic type `forall a. (Ord a) => a' at <interactive>:1:5
01:22:10 <Axman6> bah
01:22:16 <quicksilver> BeelsebobWork: comment out the print, and the Even piles up - memory leak. Oops ;)
01:22:20 <ksf> well yes and no, it's the same as saying a + b * c = a + (b * c)
01:22:22 <pumpkin_> how so? with my naive one I have one class with a few thousand samples and the other class with a few dozen... the basic way of doing this means that the big class can set its boundary as the threshold and satisfy all its constraints even if it makes the small class fail all of its ones
01:22:40 <BeelsebobWork> quicksilver: yep -- known bug -- any event with nothing looking at it piles up in the channel
01:22:51 <pumpkin_> and I care about the smaller class more (but it's a rarer occurrence)
01:22:57 <BeelsebobWork> unfortunately, it isn't easily fixed, thanks to a bug in GHC
01:22:59 <ksf> function application is not distributive.
01:23:12 <BeelsebobWork> conal was playing with making weak references to the channel
01:23:38 <BeelsebobWork> but thanks to unboxing happening in the wrong places, that results in it disapearing before anything can latch onto the channel at all
01:23:46 <pumpkin_> dmwit: does that make sense?
01:23:47 <quicksilver> BeelsebobWork: as it happens there was a reactive involved here.
01:24:00 <quicksilver> BeelsebobWork: and you can certainly see why that will pile up
01:24:08 <quicksilver> BeelsebobWork: `Stepper` is a concrete constructor.
01:24:24 <quicksilver> BeelsebobWork: (anyhow this is my implementation not conal's, but it's comforting to rediscover the same issues ;)
01:24:27 <dmwit> pumpkin_: I'm confused; are you asking me how to choose the weights, or how to deal with already-chosen weights?
01:24:41 <dmwit> I can't help you choose the weights.
01:24:43 <BeelsebobWork> quicksilver: ah, are you using channels to dump things into events?
01:25:00 <dmwit> But I can tell you that once you've chosen them, there's an efficient algorithm for choosing a decision boundary.
01:25:02 <BeelsebobWork> it may be interesting if you fix this in the common part -- it may help fix conal's implementation too
01:25:11 <quicksilver> BeelsebobWork: well, I'm using a reimplementation of Chan
01:25:21 <quicksilver> BeelsebobWork: I couldn't use Chan directly because I needed to get under the hood slightly.
01:25:26 <BeelsebobWork> oh?
01:25:30 <BeelsebobWork> what change did you need to make?
01:25:32 <pumpkin_> dmwit: well, I just want to weight it such that a larger class doesn't have undue influence over the smaller one... in my naive one I just multiply the cost of an error on one class by the size of the other to balance them out
01:25:53 <quicksilver> BeelsebobWork: I've forgotten. Let me see.
01:25:54 <conal> quicksilver: i do also, to get channels to be GC'd when there are no readers.
01:26:14 <harblcat> help
01:26:18 <BeelsebobWork> conal: oh, have you successfully fixed that nasty?
01:26:21 <quicksilver> BeelsebobWork: Oh, I needed 'peekChan' and 'tryPeekChan'
01:26:29 <quicksilver> BeelsebobWork: to non-blocking read a channel safely.
01:26:31 <harblcat> er.. Sorry, wrong channel
01:26:48 <grom358> @src max :: Int
01:26:49 <lambdabot> Source not found. You untyped fool!
01:26:55 <grom358> how do you get lambdabot to show the src for instance method? eg.. I want to see the src for max on [Int]?
01:26:57 <BeelsebobWork> quicksilver: ah, that makes sense -- because your futures are a pair of a blocking and non-blocking read, aren't they?
01:26:59 <conal> BeelsebobWork: no.  i've been obsessing over comonadic, relative-time frp.
01:27:06 <BeelsebobWork> ah, okay
01:27:11 <Axman6> @src Int compare
01:27:11 <lambdabot> Source not found. I feel much better now.
01:27:15 <Axman6> @src Integer compare
01:27:16 <lambdabot> Source not found. I've seen penguins that can type better than that.
01:27:19 <Axman6> :\
01:27:49 <conal> BeelsebobWork: i'm confident that the GC solution will work.  it's just the Right Thing (tm)
01:28:06 <grom358> trying to figure out what this snippet means zipWith max b (tail b)
01:28:31 <conal> grom358: do you know what zipWith is?
01:28:49 <ksf> > let f = zipWith max b (tail b) [1..]
01:28:51 <lambdabot>   <no location info>: parse error on input `;'
01:28:52 <grom358> conal: yes
01:28:59 <ksf> > let f = zipWith max b (tail b) in [1..]
01:29:00 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
01:29:03 <opqdonut> it makes big values "spread"
01:29:16 <ksf> > let f = zipWith max b (tail b) in f [1..]
01:29:17 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
01:29:24 <opqdonut> if the neighbour of a number is bigger than the number, it gets replaced by the neighbour
01:29:34 <ksf> > let f b = zipWith max b (tail b) in f [1..]
01:29:34 <opqdonut> of cours for an ordered list it shifts it by one
01:29:35 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
01:29:50 <ksf> > let f b = zipWith max b (tail b) in f [1,5,3,4,1,5,4,3,3]
01:29:52 <lambdabot>   [5,5,4,4,5,5,4,3]
01:30:11 <opqdonut> just as i said :)
01:30:15 <ksf> > let f b = zip b (tail b) in f [1,5,3,4,1,5,4,3,3]
01:30:16 <lambdabot>   [(1,5),(5,3),(3,4),(4,1),(1,5),(5,4),(4,3),(3,3)]
01:30:25 <ksf> > let f b = map max $ zip b (tail b) in f [1,5,3,4,1,5,4,3,3]
01:30:26 <lambdabot>       Overlapping instances for Show ((t, t) -> (t, t))
01:30:26 <lambdabot>        arising from a...
01:30:37 <opqdonut> ksf: could you cut down the spam please :)
01:30:38 * conal heads to bed.   see you all later.
01:30:43 <ksf> > let f b = map (uncurry max) $ zip b (tail b) in f [1,5,3,4,1,5,4,3,3]
01:30:45 <lambdabot>   [5,5,4,4,5,5,4,3]
01:30:50 <ksf> I'm explaining.
01:30:53 <ksf> grom358, grok?
01:31:11 <opqdonut> he said he knows what zipWith is
01:31:11 <grom358> ksf: yeah.. so its picking the max number behind neighbours
01:31:20 <grom358> between*
01:31:25 <mmorrow> sweet!
01:31:45 <mmorrow>  a="b=\$((1+\`cat\`));echo \$b; echo \$b | eval \$a"; echo 42 | eval $a
01:32:05 <ksf> the important thing is that zipWith f = map (uncurry f) $ zip
01:32:06 <mmorrow> dolio: i got caught up for a bit there
01:32:08 <ksf> @src zip
01:32:08 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
01:32:08 <lambdabot> zip _      _      = []
01:32:09 * mmorrow scrolls back
01:32:11 <ksf> @src zipWith
01:32:12 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
01:32:12 <lambdabot> zipWith _ _      _      = []
01:32:23 <opqdonut> mmorrow: aww
01:32:48 <mmorrow> opqdonut: ? about the sh one-liner?
01:33:01 <mmorrow> i was thoroughly amused by it :)
01:33:12 <opqdonut> yes
01:33:14 <quicksilver> BeelsebobWork: right.
01:33:16 <mmorrow> hehe
01:33:20 <opqdonut> old trick but in a new suit
01:33:29 <quicksilver> BeelsebobWork: plus some special cases for Never and Always.
01:33:30 <mmorrow> ooh, what's the old suit?
01:34:02 <mmorrow> opqdonut: i've been trying for about 10 minutes to make it properly tail recursive with exec, but to no avail
01:34:07 <opqdonut> well the old suit is :(){:|:&};:
01:34:14 <mmorrow> ohh, ha
01:34:28 <mmorrow> awesome, i've seen that guy before
01:34:33 <opqdonut> of course that's binary, your's is unary
01:34:38 <opqdonut> that's a classic fork bomb
01:34:46 <mmorrow> heh
01:35:15 <MyCatVerbs> opqdonut: it vaguely annoys me that that no longer looks special to me.
01:35:22 <opqdonut> me too :/
01:35:37 * mmorrow has never spent the time to actually parse that
01:35:40 <opqdonut> i re-read "the evolution of a haskell programmer" and I understood all of the weird solutions
01:35:44 * mmorrow does it now
01:35:48 <opqdonut> i felt disillusioned
01:35:53 <MyCatVerbs> opqdonut: ever since I forced myself to understand bash a little better, now I just read it roughly the way a CFG parser would. :)
01:36:05 <opqdonut> yeh
01:36:09 <PeakerWork> who controls trac.haskell.org?
01:36:09 <MyCatVerbs> opqdonut: even the origami stuff? =)
01:36:32 <grom358> ah I think I understand this one liner now.. the zipWith max b (tail b) is making a list the same size as the row above, using the maximum of the two adjancent cells (euler #18 btw)
01:36:46 <opqdonut> MyCatVerbs: yeah
01:36:47 <MyCatVerbs> opqdonut: I used Evolution of a Haskell programmer as a benchmark while I was learning Haskell at first. Every couple months I'd hit it up and count how many more of the solutions I could understand. =)
01:37:37 <opqdonut> mostly because i've been reading up on type theory and categories
01:37:50 <ksf> grom358, the resulting list is one shorter than the input as that's how many neighbours there are.
01:38:06 <ksf> > zip [1,2] [1]
01:38:07 <lambdabot>   [(1,1)]
01:38:38 <grom358> yeah.. it all makes sense now.. it also help when I realised you can work from bottom to top of the triangle too.
01:38:41 <opqdonut> ah
01:38:44 <ksf> or, more precisely, because length (tail b) +1 = length b
01:38:47 <opqdonut> that's project euler
01:38:49 <opqdonut> just realised :)
01:39:29 <ksf> ...which completely breaks down standard algebra for infinite lists ;)
01:39:56 <ksf> nah, it doesn't, i'm sucking at math, again.
01:40:06 <MyCatVerbs> opqdonut: I get everything up to but not including Cartesianally-inclined... and obviously the Tenured, but whatever. =)
01:40:32 <MyCatVerbs> opqdonut: albeit the Origamist takes about fifteen minutes or so to convince myself that it's correct, as does the one using foldr to simulate foldl. :)
01:41:58 <quicksilver> BeelsebobWork: anyhow it was a very good exercise in heap profiling to track it down :)
01:43:18 <ksf> :t uncurry
01:43:20 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
01:43:45 <ksf> it's a shame that there's no generic tuple type.
01:44:19 <ksf> maybe oleg coded one.
01:44:42 <quicksilver> well HList is a generic tuple type
01:44:44 <quicksilver> in some sense.
01:44:50 <dolio> MyCatVerbs: I think using the techniques in A Tutorial on the Universality and Expressiveness of Fold is instructive for the foldr --> foldl one.
01:45:35 <quicksilver> hundreds of people have written various senses of 'generic tuple' using various different kinds of typeclass
01:46:53 <MyCatVerbs> dolio: thanks.
01:47:36 <MyCatVerbs> ksf: there are various formulations that don't actually fit into Haskell's type system, if that's fine by you. :)
01:48:10 <ikaros> is there a way to define a data type in GHCI ?
01:49:18 <BeelsebobWork> quicksilver: hehe, fun fun
01:49:30 <dolio> Specifically, although the 'foldl f z [] = z' case works, the 'foldl f z (x:xs) = foldl f (f z x) xs' clearly doesn't.
01:49:32 <MyCatVerbs> ikaros: 'fraid not.
01:49:34 <BeelsebobWork> quicksilver: bet you're wishing I'd finished the heap profile half of Hsark now
01:49:50 <dolio> So you have to invent some cleverness to get it to fit in the foldr-universality mold.
01:50:07 <MyCatVerbs> ikaros: easy thing to do is have a text editor open on a file that you :reload when you want to change the definitions.
01:50:40 <MyCatVerbs> ikaros: other than that... make use of the universality of Maybe, [] and (,) ? =)
01:51:01 <ikaros> hehe ok thats what i do but its kinda strange that i cant just define a type
01:51:23 <MyCatVerbs> (Since Maybe a = a+1, (a,b) = a*b, and [a] = a^(forall n. n)) =)
01:51:26 <ikaros> well im following the real world haskell book.
01:51:47 <MyCatVerbs> (Of course that wouldn't get you GADTs... heh.)
01:52:13 <ikaros> thank you
01:52:27 <ikaros> i will stay with the editor for now :)
01:58:20 <quicksilver> BeelsebobWork: nah, the hp2ps graphs were fine for this case.
02:02:31 <ksf> MyCatVerbs, oleg fits everything into everything.
02:04:05 <ksf> @remember ksf Oleg is so good, curry = uncurry holds for him
02:04:05 <lambdabot> Done.
02:05:30 <dmwit> quoting yourself?
02:09:16 <hydo> is there any way to get ghc to reindex its base packages?  I'm assuming something's messed up with it, I'm getting "Could not find module `Data.Data':" building containers with cabal.
02:09:44 <hydo> which, according to the error messages, is in the base package.
02:11:45 <quicksilver> hydo: I highly doubt that is caused by a broken index.
02:12:08 <quicksilver> hydo: I believe it is probably caused by a confusion between the two versions of base, or something.
02:12:15 <quicksilver> possibly it's a bug in the containers package you have.
02:12:59 <hydo> Ok, thanks.  I'll keep poking at it.
02:13:44 <Saizan> which version of ghc are you using?
02:14:00 <hydo> 6.10.1
02:14:39 <BeelsebobWork> @type (***)
02:14:40 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
02:15:16 <BeelsebobWork> anyone see a neater way of doing filter (uncurry (&&) . (isForAll *** (not . isVar)) ?
02:15:18 <Saizan> hydo: and compiling with runghc Setup configure? if so try passing --constraint="base < 4" to it
02:15:31 <jkff> :t isVar
02:15:32 <lambdabot> Not in scope: `isVar'
02:15:35 <hydo> heh... blew away ~/.cabal and ~/.ghc and then now it's happier.
02:15:44 <BeelsebobWork> @hoogle (a -> Bool) -> (b -> Bool) -> (a,b) -> Bool
02:15:44 <lambdabot> No results found
02:15:57 <BeelsebobWork> @hoogle (a -> c) -> (b -> c) -> (a,b) -> c
02:15:57 <lambdabot> No results found
02:16:00 <hydo> saizan: naw, I'm simply doing calbal install yi  ... taking a break from learnery to play with the editor.
02:16:14 <BeelsebobWork> @hoogle (a -> c) -> (b -> c) -> (a,b) -> (c -> c -> c) -> c
02:16:14 <lambdabot> No results found
02:16:40 <jkff> @hoogle (a -> c) -> (b -> c) -> a -> b -> (c,c)
02:16:40 <lambdabot> No results found
02:17:04 <jkff> :t (\f g a b -> (f a,g b))
02:17:06 <lambdabot> forall t t1 t2 t3. (t -> t2) -> (t1 -> t3) -> t -> t1 -> (t2, t3)
02:17:11 <jkff> @pl (\f g a b -> (f a,g b))
02:17:11 <lambdabot> flip . (((.) . (,)) .)
02:17:24 <jkff> ... How do you call THAT combinator?
02:17:47 <BeelsebobWork> the wonky boobie with a tumor?
02:18:24 <BeelsebobWork> @pl (\f g c (a,b) -> c (f a) (g b))
02:18:24 <lambdabot> flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . flip . ((flip . ((.) .)) .) . flip (.)
02:18:24 <osfameron> the-combinator-that-would-benefit-from-not-being-pointsfree ?
02:18:24 <BeelsebobWork> ahahahahahahahahaha
02:18:27 <BeelsebobWork> osfameron: no, that's mine
02:18:29 <BeelsebobWork> :D
02:18:31 <osfameron> yeah :-)
02:18:35 <jkff> lol
02:19:03 <osfameron> abuse of flip is an obfu technique
02:19:09 <PeakerWork> Going points-free is half a step towards being more general.  Once you're points-free, you can replace all these specific calls to (.), const, etc  with generic calls to <$>, pure, etc.  I think this should be the true advantage of PL style
02:19:40 <BeelsebobWork> PeakerWork: I think that's a falacy
02:19:43 <PeakerWork> BeelsebobWork: why?
02:20:08 <PeakerWork> BeelsebobWork: For example, code that is specific to composing functions can instead compose arrows, or whatever else
02:20:10 <BeelsebobWork> because I've never seen an example where you can get useful generality out of the point free version, but can't get it out of the pointful version easily
02:20:28 <BeelsebobWork> hmm, that's true actually
02:20:32 <BeelsebobWork> *** is an example in itself
02:20:40 <BeelsebobWork> but I'm not sure that's because it went point free
02:20:47 <PeakerWork> if you use \(x, y) -> ....
02:21:01 <BeelsebobWork> exactly
02:21:11 <PeakerWork> then you're building a very specific data-type, whereas if you use *** you can use any data structure, and perhaps compile it to the GPU instead of building a Haskellish function :-)
02:21:23 <BeelsebobWork> true true
02:21:28 <osfameron> surely that's equivalent to the points-free version, so can be dropped into the same places the PL version could be?
02:21:54 <Saizan> osfameron: no, it'll have a more general type
02:22:01 <Saizan> (sometimes)
02:22:10 <PeakerWork> \ is magic, combinators are user-implementable, and language power comes from replacing magic with user-implementable things :-)
02:22:47 <jkff> :t flip flip flip flip
02:22:49 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
02:23:03 <quicksilver> PeakerWork: that path leads to lisp if you're not careful :P
02:23:04 <Saizan> we want to overload \ :) it'll make a nice notation for arrows
02:23:11 <PeakerWork> I think maybe specific data types (even functions!) could be discouraged and instead replaced with general data types (e.g arrows)
02:23:17 <PeakerWork> quicksilver: how come?
02:23:25 <osfameron> PeakerWork: getting things done > language power  (except inasmuch as language power is often useful to get things done)
02:23:28 <PeakerWork> quicksilver: oh, I see, but Lisp does it at the syntactic level, rather than the semantic one
02:23:54 <quicksilver> experience shows that "first-class everything" is hard to achieve
02:24:00 <quicksilver> and so far impossible to do well.
02:24:01 <PeakerWork> osfameron: Well, I don't think going more general in Haskell makes getting things done harder, at least after the learning curve :)
02:24:39 <PeakerWork> quicksilver: I'm just advocating the possible use of arrows/some other type-class when functions are used, as a special case of using type-classes rather than specific types where possible
02:24:58 <opqdonut> we need a nicer syntax for type classes
02:24:58 <osfameron> PeakerWork: the PL examples with flip, ., and parens are somewhat opaque
02:24:59 <opqdonut> imo
02:25:25 <quicksilver> PeakerWork: I wasn't commenting on that. I was commentng on " \ is magic, combinators are user-implementable, and  language power comes from replacing magic ... "
02:25:38 <quicksilver> PeakerWork: not that I disagree entirely with your idea.
02:25:54 <quicksilver> just saying that if you go much further than haskell already has down that path, you start to lose things.
02:26:18 <PeakerWork> osfameron: PL style can be more readable if you give some higher-level combinators nice names.. For example, if you call   f x = (x.)  combinator "result", and the g x = (.x) combinator "argument", rather than using (f.) . (.g)  you use: result f . argument g -- suddenly PL becomes a whole lot more readable
02:27:03 <quicksilver> osfameron: you're absolutely right (about opacity), but opacity is of course subjective.
02:27:07 <PeakerWork> quicksilver: I think maybe those who tried that path, tried doing it at the syntactic level, maybe?
02:27:11 <quicksilver> everything is hard to read until you know when to read it.
02:27:15 <quicksilver> s/when/how/;
02:27:26 <daf> true that
02:27:38 <quicksilver> I find as I spend more time programming haskell I start to use idioms I would previously have found opaque.
02:27:50 <daf> absolutely
02:27:50 <fasta> How can I make a Haskell complex value available in C? Is the mapping from data definitions to C structs implemented somewhere?
02:28:09 <quicksilver> fasta: the simplest way is probably to use its storable instance
02:28:29 <PeakerWork> I found that its easier for me to read much of the (simpler) PL stuff than the Pointful stuff
02:28:38 <Saizan> and hsc2hs should be able to write one for you?
02:28:45 <PeakerWork> (when I first saw PL stuff, I said: "this is horribly complex, people can't really be using this...")
02:28:47 <quicksilver> fasta: one of the c-to-has bridges will build struct/data type mappings
02:28:49 <quicksilver> or help you do so.
02:28:56 <Saizan> it's simple with c2hs anyway
02:29:33 <fasta> quicksilver: ok, but I only need to go from Haskell to C, so that won't be needed.
02:29:42 <osfameron> PeakerWork: I find PL more readable sometimes.  Far less so at other times...  it just seems like insisting on doing everything PL is a mental challenge rather than necessarily practical/readable.  But then I'm only on baby-haskell :-(
02:30:02 <osfameron> quicksilver: yeah, true
02:30:16 <PeakerWork> osfameron: I agree that some _crazy_ PL stuff are just totally unreadable.  But I think we just need to invent new PL combinators and perhaps visualizations of PL style to make it readable
02:30:40 <PeakerWork> osfameron: because PL style is more conductive to generalization
02:30:44 <osfameron> could be
02:31:42 <BeelsebobWork> > (f,g) <*> (a,b) :: (Expr,Expr)
02:31:43 <lambdabot>       No instance for (Monoid Expr)
02:31:43 <lambdabot>        arising from a use of `<*>' at <in...
02:31:49 <BeelsebobWork> oh, bugger
02:31:53 <PeakerWork> osfameron: did you see: http://conal.net/blog/posts/semantic-editor-combinators/
02:32:03 <lambdabot> Title: Conal Elliott Â» Semantic editor combinators
02:32:09 <PeakerWork> Expr should be a monoid!
02:32:26 <PeakerWork> how can we fix Expr in lambdabot to be a monoid?
02:32:50 <quicksilver> how would you define mappend?
02:32:59 <quicksilver> just freely, as a new constructor?
02:33:19 <osfameron> PeakerWork: saw but didn't grok... I'll add to toread...
02:33:56 <BeelsebobWork> > (id, const True) <*> (5,10)
02:33:57 <lambdabot>       No instance for (Num (a -> a))
02:33:57 <lambdabot>        arising from the literal `5' at <...
02:34:08 <BeelsebobWork> aww :(
02:34:43 <quicksilver> > (Sum 5, const True) <*> (Sum 5, 10)
02:34:44 <BeelsebobWork> oh, duh
02:34:44 <lambdabot>   (Sum {getSum = 10},True)
02:38:17 <PeakerWork> quicksilver: yeah, like all the Expr instances
02:38:27 <PeakerWork> quicksilver: I thought that's what basically Expr does with all the type-classes
02:38:39 <quicksilver> PeakerWork: yes, I was being somewhat slow.
02:38:59 <quicksilver> PeakerWork: although you'd probably want to wire in the algebraic laws for MEmpty
02:39:32 <ksf> PeakerWork, http://www.first.fraunhofer.de/owx_download/002.pdf came to mind as you mentioned editor commands.
02:39:33 <PeakerWork> quicksilver: wouldn't you want to see the whole expr?
02:39:35 <lambdabot> Title: cache:http://www.first.fraunhofer.de/owx_download/002.pdf - Google Search
02:40:07 <PeakerWork> ksf: except my link isn't scary :-)
02:40:19 <PeakerWork> > 0*(a+b+c)
02:40:20 <lambdabot>   0 * (a + b + c)
02:40:28 <PeakerWork> quicksilver: would you want this Expr to become 0?
02:41:42 <PeakerWork> quicksilver: could be nice to have something like: rewriteExpr :: Expr -> Expr  that applies rewrite-laws for all the simplifications it can
02:41:51 <PeakerWork> quicksilver: maybe could be a nice way to show rewrite laws in action, too
02:44:08 <fasta> What is a "renamed datatype of a marshallable
02:44:08 <fasta> foreign type
02:44:08 <fasta> "?
02:44:21 <fasta> A newtype?\
02:44:48 <quicksilver> PeakerWork: I meant, extend Expr with two new construcots, MEmpty and MAppend
02:45:03 <quicksilver> PeakerWork: Now, you could just define "mappend a b = Mappend a b"
02:45:30 <quicksilver> PeakerWork: but, it might be nicer to defined "mappend MEmpty b = b; mappend a MEmpty = a; mappend a b = MAppend a b"
02:45:46 <opqdonut> mhmm
02:52:33 <hydo> I'm so tempted to call in sick tomorrow and pound away at this tutorial...
02:54:03 <PeakerWork> quicksilver: I understood, yeah, but I don't think you want to "rewrite" these mempties, just like you don't want to rewrite 0*(a+b+c) to 0
02:54:25 <quicksilver> PeakerWork: *shrug* 0*x = 0 is not a documented rule of the Num class
02:54:38 <quicksilver> PeakerWork: mempty `mappend` x = x *is* a documented rule of the Monoid class.
02:54:42 <PeakerWork> quicksilver: surely its a rule nonetheless? :)
02:54:48 <quicksilver> no, it's not.
02:54:59 <quicksilver> haskell Num classes can be arbitrarily sick
02:55:04 <quicksilver> > 0 * (0/0)
02:55:06 <lambdabot>   NaN
02:55:16 <PeakerWork> quicksilver: okay, I still think the purpose of Expr is to show what expression built up, not its final value, so I don't think any reductions should take place implicitly, even ones allowed by rules
02:55:29 <quicksilver> yes, that's fair enough.
02:55:41 <PeakerWork> (though its surely useful to have such reduction available as an Expr->Expr function)
02:55:48 <quicksilver> although it does reduce function composition
02:55:54 <quicksilver> > (f.g) $ x
02:55:55 <lambdabot>   Add a type signature
02:55:59 <quicksilver> > (f.g) $ x :: Expr
02:56:01 <lambdabot>   Add a type signature
02:56:18 <quicksilver> > (((f::Expr->Expr).(g::Expr->Expr)) $ x) :: Expr
02:56:20 <lambdabot>   f (g x)
02:56:21 <PeakerWork> quicksilver: it has no choice, its not polymorphic
02:56:30 <quicksilver> I don't understand your point.
02:56:35 <quicksilver> why is "." different from "mappend"
02:56:44 <PeakerWork> "." is not controlled by Expr code
02:56:54 <quicksilver> it could be, if we wanted it to be.
02:56:57 <PeakerWork> How?
02:57:13 <Botje> fairies
02:57:20 <quicksilver> by hiding it and making it fmap, and having a functor instance for Expr
02:57:25 <opqdonut> :)
02:57:32 <quicksilver> or fairies.
02:57:37 <PeakerWork> quicksilver: Then you have a bazillion other functions which aren't methods...
02:57:43 <quicksilver> sure.
02:57:50 <quicksilver> just trying to nail down your point, precisely ;)
02:58:13 <quicksilver> to me, obeying the laws for (.) and ($) - which is rather useful - is exactly like obeying the laws for mempty and mappend
02:58:15 <PeakerWork> quicksilver: I think ideally, the expr would be exactly what you wrote down (kind of useless on its own)
02:58:43 <grom358> http://hpaste.org/12657#a2
02:58:45 <PeakerWork> quicksilver: the usefulness would be from specifying what you want to reduce, and what you want to keep. Currently, it arbitrarily reduces functions and keeps methods
02:58:53 <quicksilver> > foldl1 (+1) [1..5]
02:58:55 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a
02:58:55 <lambdabot>      Proba...
02:58:59 <quicksilver> > foldl1 (+) [1..5]
02:59:01 <lambdabot>   15
02:59:09 <quicksilver> > foldl1 (+) [x,y,z]]
02:59:11 <lambdabot>   <no location info>: parse error on input `]'
02:59:12 <quicksilver> > foldl1 (+) [x,y,z]
02:59:14 <lambdabot>   x + y + z
02:59:29 <PeakerWork> quicksilver: Yeah, it reduces the foldl1 (function) and keeps the (+) (method)
02:59:34 <pumpkin_> :t foldl'
02:59:35 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
02:59:42 <quicksilver> > foldl1 (+) [1..5] :: Expr
02:59:43 <lambdabot>   1 + 2 + 3 + 4 + 5
02:59:46 <grom358> do my explanations in that make sense?
02:59:52 <quicksilver> PeakerWork: bug in your theory.
02:59:57 <quicksilver> PeakerWork: enumFromTo is a method.
03:00:07 <PeakerWork> quicksilver: well, bug in Expr! :-)
03:00:11 <PeakerWork> quicksilver: its lacking instances
03:00:22 <PeakerWork> @type enumFromTo
03:00:23 <lambdabot> forall a. (Enum a) => a -> a -> [a]
03:00:31 <PeakerWork> oh wait, no its not
03:00:39 <quicksilver> hey, you can't make a theory about the behaviour of Expr and then say it's a bug when Expr doesn't obey your theory, that's cheating :P
03:00:58 <PeakerWork> > foldl1 (+) [1::Expr .. 5] :: Expr
03:00:58 <quicksilver> that's like Einstein calling quantum mechanics a bug in reality.
03:00:59 <lambdabot>   1 + 2 + 3 + 4 + 5
03:01:14 <PeakerWork> How does this work?  What's the Enum instance of Expr?
03:01:21 <PeakerWork> @src Enum
03:01:22 <lambdabot> class  Enum a   where
03:01:22 <lambdabot>     succ                     :: a -> a
03:01:22 <lambdabot>     pred                     :: a -> a
03:01:22 <lambdabot>     toEnum                   :: Int -> a
03:01:22 <lambdabot>     fromEnum                 :: a -> Int
03:01:24 <lambdabot> [3 @more lines]
03:02:07 <PeakerWork> @type foldl1 (+) [1::Expr .. 5] :: Expr
03:02:08 <lambdabot> Expr
03:02:13 <quicksilver> PeakerWork: I don't know, I haven't looked at the code ;)
03:02:14 <PeakerWork> @type [1::Expr .. 5]
03:02:15 <lambdabot> [Expr]
03:02:21 <quicksilver> > succ 1 :: Expr
03:02:22 <lambdabot>   succ 1
03:02:29 <PeakerWork> oh!
03:02:37 <quicksilver> > enumFromTo 1 5 :: Expr
03:02:39 <PeakerWork> quicksilver: enumFromTo must return a list
03:02:39 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[t]'
03:02:43 <quicksilver> > enumFromTo 1 5 :: [Expr]
03:02:45 <lambdabot>   [1,2,3,4,5]
03:02:49 <quicksilver> indeed.
03:03:01 <quicksilver> it could return [1,succ 1,succ (succ 1)...] though
03:03:06 <quicksilver> and it chooses not to.
03:03:06 <PeakerWork> quicksilver: I guess I ought to correct my theory from func/method to polymorphic/not
03:03:44 <PeakerWork> hmm, interesting, its probably actually reducing "succ" specifically
03:03:51 <hugo___> hi
03:03:59 <PeakerWork> I would expect the succ-succ-... one
03:04:05 <grom358> dolio: you still around?
03:04:20 <PeakerWork> quicksilver: I guess augustuss (or who wrote that) decided to reduce things that are likely to flood the expression
03:04:52 <Clockwork> BONUS: Hey, you used JavaScript to color your syntax of your Tutorial "Learn Haskell For A Greater Good?"
03:04:55 <Botje> > succ (succ 1) "" Expr
03:04:57 <lambdabot>   Not in scope: data constructor `Expr'
03:04:59 <Botje> > succ (succ 1) :: Expr
03:05:01 <lambdabot>   succ (succ 1)
03:09:41 <BONUS> Clockwork: yeah
03:09:58 <Clockwork> I am looking for an editor to code Haskell will the same color scheme
03:10:01 <Clockwork> any advices?
03:10:01 <basvandijk> Hello, Is it more efficient to lift non changing arguments of a recursive function into a closure like so 'map f = go where go (x:xs) = f x (go xs)' instead of 'map f (x:xs) = f x : map f xs'? And can you rely on the compiler to optimize it?
03:10:15 <Clockwork> as I fall in love with this style <3 :)
03:10:19 <BONUS> Clockwork: that color scheme on the site basically emulates my vim setup :]
03:10:36 <Clockwork> ok, so vim it is : )
03:10:53 <BONUS> it's vim's default haskell mode with a custom color scheme, let me upload it for you
03:11:24 <Clockwork> oh, that would be awesome
03:11:43 <BONUS> http://pastie.org/329665
03:11:44 <lambdabot> Title: #329665 - Pastie
03:11:57 <BONUS> just save that as wombat.vim and put it in your vim/colors/ folder
03:12:33 <Clockwork> okay, big thanks :-)
03:12:38 <BONUS> haha, np!
03:12:57 <Lemmih> basvandijk: GHC doesn't perform that optimization, I'm afraid.
03:17:47 <Botje> the first thing GHC will do is lambda lift that go back to the main level :)
03:17:49 <basvandijk> Lemmih: yes I noticed when looking at the core output.
03:17:53 <solrize> >  [0.1, 0.3 .. 1 ]
03:17:55 <lambdabot>   [0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]
03:18:10 <solrize> @src fromToEnum
03:18:11 <lambdabot> Source not found. Where did you learn to type?
03:18:15 <hugo___> i have some happs questions...
03:18:53 <hugo___> ...i have these html+css+javascript files on a dir, and i want to know how to serve them ? if i use the fileserve handler it will only serve one file, making it look preatty ugly :/
03:19:04 <hugo___> do i have to generate the files in haskell ?
03:19:25 <Lemmih> hugo___: Generate the files?
03:20:23 <hugo___> yes, like "generateIndexHTML = "<html>..." ++ generateIndexCSS ++ generateIndexJS ++ "<body>..." and call it on a methodSP Get ?
03:20:45 <hugo___> it would probably be much faster than going to the file system :P, but harder to maintain
03:20:55 <quicksilver> Botje: not quite the first thing.
03:21:02 <quicksilver> Botje: the first thing it will do is inline it, if it wants to
03:21:14 <quicksilver> Botje: (which is the purpose of that style - to permit a recursive function to be inlined)
03:21:28 <Botje> that's good too :P
03:21:34 <Lemmih> hugo___: I usually use lighttpd to server static content.
03:22:00 <hugo___> hmm
03:22:31 <hugo___> im writing a comercial app that must allow user login (the index has the form), and afterwards it must run several webbots already coded in haskell
03:22:48 <hugo___> its a price comparison platform, for hotels
03:23:19 <hugo___> so it would be nice to have it all on a single package
03:24:23 <hugo___> probably the webbots will be on a different server, with happs answering control requests for them, because of the traffic they generate
03:24:35 <hugo___> currently they are command line only
03:24:40 <hugo___> or ghci :P
03:25:26 <Lemmih> hugo___: You'll have to write generateIndexHTML yourself, then.
03:25:33 <hugo___> hmm ok
03:26:19 * Lemmih is out. Further questions can be directed to the #happs channel and/or the HAppS mailing list.
03:26:27 <hugo___> allright, thanks dude
03:29:23 <solrize> :t replicate
03:29:25 <lambdabot> forall a. Int -> a -> [a]
03:34:05 <Clockwork> BONUS: I saved it and loaded it as Vim-Script, but for some reason, it's still just White on Black Text :o
03:34:22 <BONUS> hmmm, really?
03:34:50 <BONUS> try typing in
03:34:54 <BONUS> :colorscheme wombat
03:36:00 <quicksilver> BeelsebobWork: the heap profile helped me discover another interesting bug.
03:36:23 <Clockwork> where? I guess not in the first line, because that's the txt field? Sorry I am new to Unix-like programs
03:36:38 <BONUS> hehe yeah just press escape first
03:36:42 <BONUS> and then just type :colorscheme wombat
03:36:58 <BONUS> what you're typing should appear on the bottom line
03:37:10 <Clockwork> E185: Line wombat could not be found
03:37:14 <Clockwork> yes it did
03:37:23 <BONUS> hmm are you on windows
03:37:43 <Clockwork> no, KDE/Linux
03:38:14 <BONUS> ah, strange. you have to place it with your other color schemes, although i dont know where they're kept in your system
03:38:57 <BONUS> what if you try some of the default color schemes, like :color desert
03:39:22 <Clockwork> changes
03:39:34 <BONUS> to a dark greyish theme, right?
03:39:39 <Clockwork> yep
03:39:51 <BONUS> alright then just do: locate desert.vim
03:39:52 <BONUS> in your terminal
03:40:14 <Clockwork> and replace it by the wombat.vim?
03:40:21 <BONUS> nah, just put wombat.vim in that folder
03:41:01 <Clockwork> it is, wombat.vim and desert.vim are both in Vim\Runtime\Color\
03:41:03 <BONUS> and then try doing :color wombat
03:41:44 <BONUS> hmmm, you sure that's the only folder with a copy of desert.vim?
03:43:29 <Clockwork> Maybe not, because I replaced desert.vim with wombat.vim and it's still not working
03:43:52 <BONUS> really? wow thats strange
03:44:09 <mmorrow> this scares me: http://hpaste.org/12662
03:44:12 <BONUS> could be something with the wombat.vim file itself
03:44:17 <BONUS> maybe if you ask around in #vim or something
03:44:25 <BONUS> those guys know their vim
03:44:25 <mmorrow> can any one think of whytf that would happen?
03:44:33 <mornfall> Hm, anyone know what's wrong here? package ghc-6.8.2 requires bytestring-0.9.0.1
03:44:43 <mornfall> (Trying to cabal configure yi...)
03:44:44 <mmorrow> i hope i'm just missing something obvious
03:45:05 <mmorrow> or else that's a serioush problem
03:45:08 <opqdonut> mmorrow: wow
03:45:13 <Clockwork> yeah I'll try, thanks for the help anyway :)
03:45:19 <mornfall> I do have a newer bytestring installed...
03:45:20 <BONUS> hehe hope you get it :)
03:46:26 <tomh> hey, anyone know how you can pattern match on a type IO (Maybe String)
03:46:26 <quicksilver> mornfall: you're in big trouble.
03:46:35 <mornfall> quicksilver: Awesome.
03:46:40 <quicksilver> mornfall: yi links against ghc-api, so it must be compiled against the same version of bytestring as ghc is.
03:46:49 <mornfall> Ah. Oops. : - )
03:46:54 <opqdonut> tomh: fmap something on it
03:46:54 <BONUS> Clockwork: if desert.vim works but wombat.vim doesnt, you can compare these two files to see what they have different
03:46:57 <opqdonut> or then just run an action
03:46:58 <mornfall> It configured fine a few moments ago, but failed to build anyway.
03:47:05 <quicksilver> mornfall: you shuold be able to force Yi to compile against the old bytestring
03:47:08 <BONUS> or as a last resort you can just copy the colors from wombat to desert :D
03:47:14 <quicksilver> mornfall: try hiding the new one, for the purpose of this compilation.
03:47:15 <mornfall> quicksilver: It requires half dozen packages that link bytestring.
03:47:18 <tomh> opqdonut: how do you mean?
03:47:26 <Clockwork> I did that, too
03:47:29 <quicksilver> mornfall: well, they've all got to agree with each other, and with ghc-api
03:47:31 <mornfall> I wish I could cabal install ghc.
03:47:32 <yitz> tomh: inside a do block, say Just x <- foo
03:47:40 <tomh> ok thanks
03:47:47 <quicksilver> mornfall: this is dcoutts_ most notorious diamond dependency problem
03:47:59 <opqdonut> tomh: what yitz said, or then "fmap (\x -> case x of Just y -> ......) foo"
03:48:21 <mornfall> quicksilver: This one's probably pretty hard to crack, too.
03:48:23 <tomh> and foo is the the IO (Maybe String) ?
03:48:45 <opqdonut> tomh: yep
03:49:09 <tomh> ok
03:53:07 <mmorrow> quicksilver: what do you think is happening here? http://hpaste.org/12662
03:53:35 <mmorrow> should i take that to be a serious bug?
03:53:58 <quicksilver> mmorrow: you're poking ints at byte offsets
03:54:03 <mmorrow> ohhhhh
03:54:06 <mmorrow> thank god
03:54:11 <quicksilver> mmorrow: with a little thought, you can deduce the endian-ness of your architecture this way ;)
03:54:13 <mmorrow> :)
03:54:31 <mmorrow> pheww, i was crapping myself for a few minutes there
03:54:56 <quicksilver> > 10794 `div` 42
03:54:58 <lambdabot>   257
03:55:01 <quicksilver> ^^ a clue.
03:55:24 <quicksilver> > 42 + (42*256)
03:55:25 <lambdabot>   10794
03:56:22 <mmorrow> neat
03:56:50 <trofi> :]
03:57:22 <trofi> :t unfoldr
03:57:24 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
03:57:32 <mmorrow> for some reason i thought that "Byte" there meant "sizeOf (a::(Storable a)=>a)"
03:57:53 * mmorrow has only ever used Ptr Word8s with these functions
03:58:26 <trofi> @where luna
03:58:27 <lambdabot> I know nothing about luna.
03:58:42 <mmorrow> @help where
03:58:42 <lambdabot> where <key>. Return element associated with key
03:58:56 <mmorrow> how do you add something to @where?
03:59:13 <trofi> +
03:59:21 <mmorrow> @where + http://moonpatio.com/repos/luna/
03:59:22 <lambdabot> I know nothing about +.
03:59:25 <mmorrow> heh
03:59:28 <trofi> @where+ where is where
03:59:28 <lambdabot> I will never forget.
03:59:36 <mmorrow> woohoo
03:59:44 <mmorrow> @where+ http://moonpatio.com/repos/luna/
03:59:44 <lambdabot> Done.
04:00:29 <trofi> @where+ luna http://moonpatio.com/repos/luna/
04:00:29 <lambdabot> I will remember.
04:00:32 <trofi> @where+ lunabot http://moonpatio.com/repos/luna/
04:00:33 <lambdabot> Done.
04:00:35 <|styx|> @where luna
04:00:36 <lambdabot> http://moonpatio.com/repos/luna/
04:00:40 <|styx|> (^
04:01:15 <Clockwork> BONUS: It's running now, I forgot to activate Haskell as type language *shrug* stuipid me :)
04:01:26 <BONUS> haha
04:01:28 <BONUS> awesome
04:01:29 <mmorrow> trofi: oh heh. i'm still a little shaken from thinking pokeByteOff was trashing memory at will ;)
04:01:45 <Clockwork> anyway looks greta and of course I will write now better code
04:01:49 <mmorrow> @where hpaste2
04:01:51 <lambdabot> I know nothing about hpaste2.
04:01:53 <BONUS> haha cool :)
04:02:03 <tomh> ok i got that do thing working, but there is no way to just return the Maybe a from an IO (Maybe a) ?
04:02:08 <mmorrow> @where+ hpaste2 http://moonpatio.com:8080
04:02:09 <lambdabot> I will remember.
04:02:18 <tomh> if i use the do method it results in type IO()
04:02:59 <trofi> :t fromMaybe
04:03:00 <lambdabot> forall a. a -> Maybe a -> a
04:03:02 <trofi> :t fromJust
04:03:03 <lambdabot> forall a. Maybe a -> a
04:03:09 <trofi> :t lift
04:03:11 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
04:03:30 <tomh> O_o
04:03:30 <quicksilver> tomh: No.
04:03:40 <quicksilver> tomh: you can work with it, but in some sense you will always be in IO
04:03:44 <quicksilver> this doesn't matter, though.
04:04:03 <quicksilver> you can just have a thin IO shell which calls everything else which is pure.
04:04:18 <solrize> @hoogle (a,b)->(b,a)
04:04:19 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
04:04:19 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
04:04:19 <lambdabot> Control.Arrow (<<<) :: Arrow a => a c d -> a b c -> a b d
04:04:31 <tomh> ye thats probably too much for me, im just a haskell noob :p
04:04:40 <trofi> :t flip
04:04:41 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
04:04:44 <trofi> :t uncurry
04:04:45 <quicksilver> tomh: on the contrary it's very easy
04:04:46 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
04:04:54 <quicksilver> tomh: and something all haskell noobs should do
04:05:03 <quicksilver> tomh: can you paste what you're trying to do?
04:05:04 <tomh> write a thin IO shell?
04:05:07 <quicksilver> yes.
04:05:18 <tomh> eh sure
04:05:19 <quicksilver> I just mean "shell" in the sense of the shell of an egg
04:05:22 <mmorrow> main = putStr . unlines . my1000LineFunctionOnLines . lines =<< getContents
04:05:23 <quicksilver> not a technical term.
04:05:32 <quicksilver> I just mean that 'main' has to be in IO, sure, but nothing else does
04:05:39 <quicksilver> so almost all of your program is not IO.
04:06:06 <mmorrow> my1000LineFunctionOnLines :: [String] -> [String]
04:06:36 <tomh> mm im not sure if its going to help if i paste my code, it requires a lot of libs
04:07:41 <mmorrow> main = do args <- getArgs; inp <- getContents; let res = everyThingElse args inp; print r; exitWith ExitSuccess
04:09:12 <quicksilver> tomh: Ok, well take my word for it that just because you have one thing stuck in IO it doesn't mean everything will be.
04:09:20 <quicksilver> tomh: and ask if you have any specific problems with this ;)
04:09:36 <trofi> :t print
04:09:38 <lambdabot> forall a. (Show a) => a -> IO ()
04:09:38 <tomh> ye thanks for the help, atleast i know how to mess around now with it :)
04:41:45 <quicksilver> BeelsebobWork: D'oh. Stupid bug resolved.
04:41:53 <BeelsebobWork> quicksilver: oh?
04:42:10 <quicksilver> BeelsebobWork: I thought I had a bug in my snapshotWithR
04:42:15 <quicksilver> BeelsebobWork: and it wasn't updating often enough.
04:42:28 <quicksilver> turns out I was using snapshot when really I wanted to use <*> ;)
04:42:37 <quicksilver> of course a snapshot only updates each time the event fires
04:42:40 <quicksilver> (that's what it's for!)
04:42:43 <BeelsebobWork> hehe
04:42:47 <quicksilver> if you want to update continuously you want <*>
04:51:01 <quicksilver> BeelsebobWork: however I do have a cute bug with another snapshot (which really should be a snapshot)
04:51:10 <BeelsebobWork> oh?
04:51:18 <quicksilver> BeelsebobWork: if the event only comes rarely the reactive/behaviour leaks space
04:51:23 <quicksilver> until the arriving of the next event
04:51:27 <quicksilver> which 'clamps it down to size'
04:51:30 <BeelsebobWork> hmm, that's interesting
04:51:36 <quicksilver> since the even in this case is keyboard/mouse
04:51:44 * BeelsebobWork wonders why that's the case
04:51:44 <quicksilver> I have a heap profile that grows until I click/type
04:51:59 <quicksilver> BeelsebobWork: I think it's probably a bug in my implementation.
04:52:16 <quicksilver> the work that it does to establish that no event is currently available (in the snapshot)
04:52:22 <BeelsebobWork> have you tried with conal's version?
04:52:25 <quicksilver> should be doing enough forcing to clamp the reactive down.
04:52:41 <quicksilver> Not yet. We're not quite source-compatible yet although that is a goal for me.
04:52:55 <quicksilver> and I was hoping to wait for the haskell platform before getting 6.10
04:53:16 <BeelsebobWork> oh, course
04:53:46 <quicksilver> I'm very close to putting my code up on the reactive list though
04:53:56 <quicksilver> I have just one more feature I wanted to add first
04:54:03 <quicksilver> and I've just fixed the bug which was blocking that ;)
04:54:10 <BeelsebobWork> :)
04:54:17 <quicksilver> so if someone else fancies trying to make it work with conal-reactive they can.
04:54:34 <quicksilver> I wanted to have non-trivial examples of most of the semantics
04:54:54 <quicksilver> (joinE, applicative <*> for behaviour, event polling, keyboard / mouse interaction)
04:55:20 <BeelsebobWork> that makes sense
04:56:12 <BeelsebobWork> btw, do you have time to go into the reasons for Monad Behavior not being possible?  I think I missunderstood some of the reasoning last time, because I can't properly reconstruct it myself now
04:58:05 <quicksilver> BeelsebobWork: because the explicit representation as "Reactive FunTime" means we need to explicitly know where the "discontinuities" are
04:58:25 <quicksilver> "discontinuity" is, actually, not the right word. but the "discrete change" parts.
04:58:44 <quicksilver> and when you have Reactive FunTime Reactive FunTime
04:58:52 <BeelsebobWork> yeh -- that's the part I'm missing -- surely the discrete changes are at the union of the times where there are discrete changes in either
04:59:00 <quicksilver> the inner Reactive can change arbitrarily because it's a funTime
04:59:13 <BeelsebobWork> ah, duh
04:59:22 * BeelsebobWork ponders
04:59:26 <quicksilver> so from one instant to the next, the inner reactive could go from one which changes 100 times over eternity to one which changes a million.
04:59:35 <quicksilver> Your argument explains why Reactive is a monad ;)
04:59:39 <quicksilver> which is easy to do.
04:59:47 <BeelsebobWork> yeh
04:59:59 <quicksilver> one argument is that it "doesn't matter"
05:00:09 <BeelsebobWork> what doesn't matter?
05:00:11 <quicksilver> you could just lose the ability to inspect the inner discreteness
05:00:22 <quicksilver> bundle the inner discreteness "into" the outer FunTime
05:00:31 <BeelsebobWork> yeh -- which in all uses of the Monad instance I've come across really doesn't matter
05:00:32 <quicksilver> (after all a FunTime can be arbtrarily complex anyway)
05:00:39 <BeelsebobWork> because the things really *are* continuously changing
05:00:54 <quicksilver> however that turns out to be not something we can write with the primtives we have
05:01:11 <quicksilver> we don't have "sampleR :: t -> Reactive t a -> a"
05:01:22 <BeelsebobWork> ah, no
05:01:29 <quicksilver> to "sample the inner reactive at this time t, which is the time our FunTime gives us"
05:01:39 <quicksilver> although somehow morally such a thing is not impossible to imagine.
05:02:00 <quicksilver> when you're "inside" a Behaviour there is a notion of current time.
05:02:00 <BeelsebobWork> wait -- surely that's needed for Monad Reactive?
05:02:09 <quicksilver> funnily enough, it isn't.
05:02:18 <quicksilver> the "hard work" for Monad Reactive is done by Future `mappend`
05:02:32 <quicksilver> Future mappend is a primitive which lets us compute which thing happens first
05:02:34 <BeelsebobWork> hmm, yes
05:02:36 <BeelsebobWork> so it is
05:02:38 <quicksilver> without actualy checking.
05:03:36 <quicksilver> I actually prefer my definition of joinR to conal's
05:03:44 <quicksilver> his goes via mutual recursion with switcher
05:03:51 <BeelsebobWork> yeh, I think actually sampleR is exactly the function I was missing in my attempt at an implementation
05:04:21 <quicksilver> sampleR should somehow be only permissible when you are already inside a Behaviour
05:04:29 <quicksilver> you shouldn't be able to give it arbitrary times
05:04:32 <quicksilver> only "the current time"
05:04:47 <quicksilver> where "current" only has any meaning for code which is already inside.
05:04:47 * BeelsebobWork ponders what that makes unsafe
05:04:56 <BeelsebobWork> it would actually allow for timeshifting
05:05:05 <quicksilver> unfortunately, that boils down to saying sampleR is implemented trivially with a monad instance for behaviour
05:05:12 <quicksilver> which takes us back to where we started ;)
05:05:18 <BeelsebobWork> heh
05:05:35 <quicksilver> this whole notion of "only working inside" is precisely the abstraction that monadic join represents
05:05:37 <BeelsebobWork> it would ofc have the posibility of creating Behaviors which don't have a value at the time they state they do
05:05:44 <BeelsebobWork> yeh
05:06:25 <quicksilver> the reason sampleR would be unsafe "outside" is that it would block
05:06:32 <quicksilver> (if you tried to sample the future, it would have to block)
05:06:40 <quicksilver> so it would be horribly deadlock prone if you used it badly.
05:06:54 <quicksilver> and of course, if you tried to sample the past, you'd have to keep the past around
05:07:01 <quicksilver> which is not desirable for boring operational reasons.
05:07:17 <BeelsebobWork> yeh, I don't see the problem with blocking there actually
05:07:27 <quicksilver> whether you could have a sampleR which is only safe when you call it for the current time, I'm not sure.
05:07:30 <quicksilver> perhaps you could.
05:07:31 <BeelsebobWork> and keeping the past around sounds like exactly something I'd like to do
05:07:39 <quicksilver> keeping the past around is really cool
05:07:56 <quicksilver> but if you make it a default, then all reactive programs are O(time) space complexity
05:08:00 <quicksilver> that's probably not a good thing ;)
05:08:28 <BeelsebobWork> well no, they're O(k) space complexity, where k is the largest time-lag you introduce
05:08:43 <quicksilver> only if it's statically detectable (k)
05:08:50 <BeelsebobWork> yep
05:08:50 <quicksilver> that sounds hard. But clever.
05:08:58 <quicksilver> I was assuming you'd have to keep it all around by default.
05:09:08 <BeelsebobWork> ah, okay
05:09:14 <quicksilver> you can always use accumE to keep as much of the past around as oyu want.
05:09:24 <BeelsebobWork> oh, good point
05:09:26 <quicksilver> accumE [] (:) -- works, but leaks space
05:09:42 <quicksilver> let fps = 0 `Stepper` ((/5) . sum . take 5 <$> history lastFrameTime)
05:09:48 * BeelsebobWork ponders...
05:09:53 <quicksilver> ^^ automatic sliding average for FPS
05:10:00 <quicksilver> (history = accumE [] (:))
05:10:07 <quicksilver> and yes, that's a space leak.
05:10:11 <quicksilver> quite a small one, though ;)
05:10:37 <quicksilver> BeelsebobWork: higher level combinators which let you decide how much of the past to keep around
05:10:46 <quicksilver> BeelsebobWork: seem to be very muh in the spirit of conal's reacent ideas
05:10:54 <quicksilver> (about higher level combinators to manage sliding and aging)
05:11:26 <BeelsebobWork> sampleR t r = head . listE (r `snapshot` (atTime t))
05:11:29 <BeelsebobWork> DOOM!
05:11:31 <BeelsebobWork> :D
05:12:09 <quicksilver> ;)
05:12:25 <BeelsebobWork> that works, no?
05:12:33 <quicksilver> should do, yes.
05:12:34 <Clockwork> Was wÃ¤re das Ergebnis fÃ¼r \produkt_{i=1}^(2n) i?
05:12:43 <Clockwork> 2*4*6*8*10 ?
05:12:48 <BeelsebobWork> so woot *goes and writes Monad Behavior*
05:12:50 <quicksilver> why not experiment with using that to implement monad for behaviour
05:12:51 <BeelsebobWork> :P
05:12:51 <quicksilver> ;)
05:12:59 <Clockwork> oops, wrong channel
05:20:24 <pk> why is there so many build problems on ghc 6.10 ?
05:21:00 <mc__> pk:  "are" not "is"
05:21:08 <pk> thx
05:21:11 <mc__> np
05:25:20 <grom358> can u turn a tuple into a list? I have tuple with all Integer and want to find the product of the tuple
05:25:23 <ksf> because exceptions aren't haskell98?
05:25:48 <quicksilver> grom358: \(x,y,z) -> [x,y,z]
05:27:01 <ksf> when you've got a uniform tuple, then why didn't you use a list in the first place?
05:27:10 <BeelsebobWork> @type extract
05:27:11 <lambdabot> Not in scope: `extract'
05:27:21 <SamB_XP> ksf: what because of that ?
05:27:26 <grom358> ksf: filter (\(a,b,c) -> a^2 + b^2 == c^2) [(a, b, s - a - b) | a <- [1..(s - 3) `div` 3], b <- [a+1..(s - 1 - a) `div` 2]]
05:28:03 <quicksilver> grom358: you could have done that with lists if you wanted
05:28:08 <ksf> you can do that with lists, too.
05:28:24 <ksf> just replace () by []
05:28:27 <quicksilver> filter (\[a,b,c] -> a^2 + b^2 == c^2) [[a, b, s - a - b]  | a <- [1..(s - 3) `div` 3], b <- [a+1..(s - 1 - a) `div` 2]]
05:28:34 <grom358> oh.. I see
05:29:15 <ksf> don't ever be afraid of using lists, they're fast as irons on a glacier.
05:29:35 <grom358> ksf: yeah I was just having brain fart it seems
05:31:14 <quicksilver> ksf: and they don't have the annoying power-cord either
05:31:38 <SamB_XP> power chord ?
05:32:06 * SamB_XP wishes his cat would stop peeing on his pants
05:32:17 <ksf> SamB, you come out of a country without electricity but with coal-heated irons?
05:32:19 * SamB_XP wonders if he should just put them on as soon as he gets up ...
05:32:21 <quicksilver> stop wearing pants
05:32:36 <SamB_XP> quicksilver: I dunno if they'd let me on the bus if I did that
05:32:41 <SamB_XP> plus, wouldn't I get cold ?
05:32:54 <byorgey> you could wear kilts instead
05:33:11 <ksf> you can take your coal-heated iron with you, works even on public transport.
05:33:26 <byorgey> it depends on whether your cat pees on pants in particular, or on your clothing in general
05:33:36 <SamB_XP> oh, I misread power cord as power chord
05:33:59 <SamB_XP> I guess I *am* an aural learner ???
05:34:00 <byorgey> lists definitely come with a power chord.
05:34:13 <ksf> Do kilts need to be ironed?
05:34:24 <SamB_XP> I thought maybe it was a reference to a videogame
05:34:34 <SamB_XP> and I didn't realize what was meant by "irons", either
05:34:35 <ksf> there's tuxracer.
05:34:52 <hoelzro> is there a standard module that one can use to control the garbage collector?
05:35:00 <hoelzro> I don't see a System.GC or anything...
05:35:06 <SamB_XP> and maybe a power chord was something made with an electric guitar
05:35:21 <SamB_XP> hoelzro: in what way do you want to control it ?
05:36:18 <SamB_XP> well ?
05:36:33 <hoelzro> SamB_XP: well, control is really the right word I guess, but I'd like to view statistics about it, maybe learn how to pause/restart it
05:37:07 <SamB_XP> hoelzro: you could try passing +RTS --help to your program ...
05:37:24 <Clockwork> is there a brother of sum [a] for product?
05:37:27 <ksf> not only maybe, power chords are frighteningly commonplace in guitar music.
05:37:57 <ksf> :t product
05:37:58 <lambdabot> forall a. (Num a) => [a] -> a
05:37:59 <MyCatVerbs> ksf: but they are necessary!
05:38:33 <MyCatVerbs> ksf: also, I'm unclear on how one would tell a wrinkly kilt from a pressed one... =)
05:39:01 <SamB_XP> heh
05:39:45 <grom358> > product . head $ let n = 1000 in filter (\[a,b,c] -> a^2 + b^2 == c^2) [[a,b,c] | a <- [1..(n-3) `div` 3], b <- [a+1..(n-1-a) `div` 2], let c = n - a - b]
05:39:47 <lambdabot>   31875000
05:40:07 <ksf> hmmm. I spend two hours implementing simplex noise, and all I get is zeroes.
05:40:58 <ksf> gotta start off with 1d, this time.
05:41:48 <ksf> haskell's cool for such stuff though, as in defining
05:41:56 <ksf> dot as bs = sum $ zipWith (*) as bs
05:43:39 <ksf> @src assert
05:43:40 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
05:43:41 <ksf> blast.
05:44:47 <ksf> how does it get hold of its source loc?
05:46:19 <yitz> ksf: I think it's all preloaded in the bot.
05:46:21 <mmorrow> , let convolve (<>) xs ys = fmap (\x -> fmap (\y -> x <> y) ys) xs in convolve (+) [0..4] [-1,0,1]
05:46:24 <lunabot>  [[-1,0,1],[0,1,2],[1,2,3],[2,3,4],[3,4,5]]
05:47:07 <mmorrow> @pl \xs ys -> fmap (\x -> fmap (\y -> x <> y) ys) xs
05:47:08 <lambdabot> flip (fmap . flip (fmap . (<>)))
05:47:12 <mmorrow> sweet
05:47:51 <mmorrow> @pl \f xs ys -> fmap (\x -> fmap (\y -> f x y) ys) xs
05:47:51 <lambdabot> flip . (fmap .) . flip . (fmap .)
05:52:52 <naradapuri> _MaK_: (and others who helped me) if you are interested: A few days ago we were discussing a memoization exercise. Eventually I found a nice solution: To define recursive functions from a to b as (a -> m b) -> (a -> m b) for a generic monad, then combining them with a memoization combinator of choice (i.e. State (Map a b), IO, StateT (IntMap b) IO, State (Array a (Maybe b)), etc) and then just applying "fix".
05:52:52 <naradapuri> http://hpaste.org/12658
05:54:36 <Saizan> naradapuri: very nice
06:02:49 <dons> ?users
06:02:49 <lambdabot> Maximum users seen in #haskell: 561, currently: 546 (97.3%), active: 16 (2.9%)
06:13:09 <swiert> dons: isn't it much too early for you to be up?
06:13:35 <quicksilver> dons never sleeps
06:13:42 <quicksilver> he just evaluates more lazily, for a time.
06:13:51 <cpfr> hey i have some ugly haskell are does anyone want to help me learn haskell by making it pretty?
06:14:20 <swiert> quicksilver: kind of like chuck norris.
06:14:30 <quicksilver> swiert: dons is a lot like chuck norris, yes.
06:14:49 <gwern> hm. why does 'do True' work in ghci...
06:15:28 <BeelsebobWork> quicksilver: http://hpaste.org/12663
06:15:34 <BeelsebobWork> that works nicely actually :)
06:16:18 <gwern> 'do True == True' is True. interesting
06:16:23 <gwern> > do True == True
06:16:23 <lambdabot>   Couldn't match expected type `t t1' against inferred type `Bool'
06:16:24 <BeelsebobWork> it's obviously not as efficient as it should be though
06:16:38 * gwern ponders 6.10's behaivour. is this a bad thing?
06:16:50 <quicksilver> gwern: there is some debate about what kind of type "do x" is supposed to infer for x
06:17:06 <quicksilver> gwern: either "a" "b a" or "Monad b => b a"
06:17:15 <quicksilver> admittedly it doesn't seem terribly important.
06:17:29 <quicksilver> the report appears to suggest "do x" desugars to "x", in which case "a" is the right type.
06:17:57 <quicksilver> BeelsebobWork: you shouldn't need to sample the outer one
06:18:09 <BeelsebobWork> oh, neither I should
06:18:10 <gwern> I always assumed do x was sort of equivalent to return x
06:18:11 <quicksilver> BeelsebobWork: you should be able to preserve the existing structure of the outer and just sample the inner
06:18:18 <quicksilver> gwern: certainly not.
06:18:44 <quicksilver> gwern: 'do putStrLn "hi"' is a lot different from 'do return (putStrLn "hi")'
06:18:55 <BeelsebobWork> quicksilver: hmm, what I'm pondering from that though is how you get the "current time" out of the outer one?
06:19:11 <quicksilver> BeelsebobWork: currentTime
06:19:45 <cpfr> http://hpaste.org/12664
06:19:46 <quicksilver> (\t v -> sampleB t) <$> currentTime <*> b
06:20:04 <quicksilver> BeelsebobWork: or 'withTimeB' if conal botheres to define that combinator.
06:20:05 <BeelsebobWork> quicksilver: where is currentTime defined?
06:20:14 <quicksilver> maybe conal has a different name from it.
06:20:22 <quicksilver> it's just pure (FunTime id)
06:20:31 <BeelsebobWork> oh, yeh, that's a plan
06:20:32 <quicksilver> lets you observe the current time.
06:20:40 <Axman6> cpfr: data Entry String [(String,String)] needs an = in there somewhere
06:20:48 <BeelsebobWork> yeh, his name for it is just time
06:20:48 <cpfr> oops
06:21:27 <cpfr> Axman6, that was just so the rest of the code made sense
06:21:39 <dons> swiert: i'm on the east coast this week.
06:21:43 <dons> so resetting my timezones
06:21:46 <bos> http://www.reddit.com/r/programming/comments/7h3zl/the_real_world_haskell_book_club/
06:21:49 <lambdabot> Title: The Real World Haskell Book Club : programming, http://tinyurl.com/56os44
06:21:53 <dons> yay
06:22:30 <Axman6> cpfr: in break (\(k,v)->old==key) fs, you're not using k or v....
06:22:54 <swiert> dons: ah - that makes sense.
06:23:25 <cpfr> Axman6, s/key/k/
06:23:28 <dons> bos, do you want to mention this club on the blog?
06:23:33 <bos> ooh, good idea.
06:24:09 <gwern> bos: no, not another RWH proggit post!
06:24:18 * gwern breaks out in allergic hives from overexposure
06:24:53 <bos> heh
06:25:06 <Axman6> "Real World Haskell: the first review"
06:25:21 <dons> i don't think we've been that visible on proggit actually. only the release was announced there. a couple of articles were on [haskell] reddit
06:25:25 <Axman6> "Real World Haskell: Does it suck? (No!)"
06:25:42 <dons> hey, that's a good one.
06:25:59 <Axman6> "ZOMG i just got my RWH copy, vote up if you have it!"
06:26:21 <gwern> dons: well, maybe it's haskell then. I subscribe to both I think
06:26:25 <mmorrow> , let convolve (<>) fltr = let go r (xs:xss) = takeWhile (not . null) . dropWhile null . snd . foldl (\(n,xs) ys -> let n' = n+r in (n', zipWith (++) xs (replicate n' [] ++ fmap (:[]) ys ++ repeat []))) (r, replicate r [] ++ fmap (:[]) xs ++ repeat []) $ xss in go (length fltr `div` 2) . fmap (\y -> fmap (\x -> x <> y) fltr) in convolve (*) [-0.25,0.5,0.25] [3,12,1]
06:26:27 <lunabot>  [[-0.75],[1.5,-3.0],[0.75,6.0,-0.25],[3.0,0.5],[0.25]]
06:26:38 <mmorrow> @let convolve (<>) fltr = let go r (xs:xss) = takeWhile (not . null) . dropWhile null . snd . foldl (\(n,xs) ys -> let n' = n+r in (n', zipWith (++) xs (replicate n' [] ++ fmap (:[]) ys ++ repeat []))) (r, replicate r [] ++ fmap (:[]) xs ++ repeat []) $ xss in go (length fltr `div` 2) . fmap (\y -> fmap (\x -> x <> y) fltr) in convolve (*) [-0.25,0.5,0.25] [3,12,1]
06:26:38 <lambdabot>   Parse error
06:26:49 <mmorrow> @let convolve (<>) fltr = let go r (xs:xss) = takeWhile (not . null) . dropWhile null . snd . foldl (\(n,xs) ys -> let n' = n+r in (n', zipWith (++) xs (replicate n' [] ++ fmap (:[]) ys ++ repeat []))) (r, replicate r [] ++ fmap (:[]) xs ++ repeat []) $ xss in go (length fltr `div` 2) . fmap (\y -> fmap (\x -> x <> y) fltr)
06:26:50 <lambdabot>  Defined.
06:26:52 <EvilTerran> "convolve"?
06:27:06 <Axman6> :t convolve
06:27:07 <lambdabot> forall a a1 b. (a -> a1 -> b) -> [a] -> [a1] -> [[b]]
06:27:17 <mmorrow> convolution, like the inneficient algo you'd do if you didn't use a fft
06:27:30 <Axman6> > convolve (*) [1..10] [1..5]
06:27:32 <lambdabot>   [[1],[2],[3],[4],[5],[6,2],[7,4],[8,6],[9,8],[10,10],[12,3],[14,6],[16,9],[...
06:27:36 <mmorrow> for instance, filtering digital images
06:27:42 <mmorrow> or any digital filter
06:28:02 <luite_> it's not that bad if your kernel is separable :)
06:28:18 <Axman6> ok, bed time. i'm doing a networking job tomorrow, should be fun. (and my first paid job!)
06:28:28 <cpfr> nite Axman6
06:28:32 <mc__> gn8
06:28:32 <mmorrow> luite_: heh, true
06:28:55 <mmorrow> > fmap sum $ convolve (*) [-0.25,0.5,0.25] [3,12,1]
06:28:56 <lambdabot>   [-0.75,-1.5,6.5,3.5,0.25]
06:29:42 <mmorrow> > fmap sum . init . tail $ convolve (*) [-0.25,0.5,0.25] [3,12,1]
06:29:44 <lambdabot>   [-1.5,6.5,3.5]
06:30:49 <BeelsebobWork> @src convolve
06:30:50 <lambdabot> Source not found. It can only be attributed to human error.
06:31:34 <Axman6> @pl convolve (<>) fltr = let go r (xs:xss) = takeWhile (not . null) . dropWhile null . snd .  foldl (\(n,xs) ys -> let n' = n+r in (n', zipWith (++) xs (replicate n' [] ++ fmap (:[]) ys ++  repeat []))) (r, replicate r [] ++ fmap (:[]) xs ++ repeat []) $ xss in go (length fltr `div` 2)  . fmap (\y -> fmap (\x -> x <> y) fltr)
06:31:34 <lambdabot> (line 1, column 20):
06:31:34 <lambdabot> unexpected "="
06:31:34 <lambdabot> expecting variable, "(", operator or end of input
06:31:46 <Axman6> lame
06:32:16 <mmorrow> @pl \x -> let y = z in x
06:32:16 <lambdabot> id
06:32:22 <mmorrow> @pl \x -> let y = z in z
06:32:22 <lambdabot> const z
06:32:27 <mmorrow> cool, lets
06:32:54 <mmorrow> @pl \f fltr -> let go r (xs:xss) = takeWhile (not . null) . dropWhile null . snd .  foldl (\(n,xs) ys -> let n' = n+r in (n', zipWith (++) xs (replicate n' [] ++ fmap (:[]) ys ++  repeat []))) (r, replicate r [] ++ fmap (:[]) xs ++ repeat []) $ xss in go (length fltr `div` 2)  . fmap (\y -> fmap (\x -> f x y) fltr)
06:32:57 <lambdabot> flip flip (flip ap tail . (. head) . ((takeWhile (not . null) .) .) . ((dropWhile null .) .) . ((snd .) .) . ap ((.) . foldl . flip ap snd . (. fst) . (const .) . (flip (ap (,) . ap ((.) . zipWith (+
06:32:57 <lambdabot> +)) (flip ((++) . flip replicate []) . (++ repeat []) . fmap return)) .) . (fix .) . (const .) . (+)) (ap ((.) . (,)) ((. ((++ repeat []) . fmap return)) . (++) . flip replicate []))) . ap (flip . ((
06:32:57 <lambdabot> .) .) . flip id . (`div` 2) . length) . (fmap .) . flip . (fmap .) . flip
06:32:57 <lambdabot> optimization suspended, use @pl-resume to continue.
06:33:52 <Stephan202> @pl-resume
06:33:59 <lambdabot> flip flip (flip ap tail . (. head) . (((takeWhile (not . null) . dropWhile null . snd) .) .) . ap ((.) . foldl . flip ap snd . (. fst) . ((const . flip (ap (,) . ap ((.) . zipWith (++)) (flip ((++) .
06:33:59 <lambdabot>  flip replicate []) . (++ repeat []) . fmap return))) .) . (+)) (liftM2 (.) (,) ((. ((++ repeat []) . fmap return)) . (++) . flip replicate []))) . ap (flip . ((.) .) . flip id . (`div` 2) . length)
06:33:59 <lambdabot> . (fmap .) . flip . (fmap .) . flip
06:33:59 <lambdabot> optimization suspended, use @pl-resume to continue.
06:34:03 <Stephan202> @pl-resume
06:34:11 <lambdabot> flip flip ((`ap` tail) . (. head) . (((takeWhile (not . null) . dropWhile null . snd) .) .) . ap ((.) . foldl . (`ap` snd) . (. fst) . ((const . flip (ap (,) . ap ((.) . zipWith (++)) (flip ((++) .
06:34:11 <lambdabot> flip replicate []) . (++ repeat []) . fmap return))) .) . (+)) (liftM2 (.) (,) ((. ((++ repeat []) . fmap return)) . (++) . flip replicate []))) . ap (flip . ((.) .) . flip id . (`div` 2) . length) .
06:34:11 <lambdabot>  (fmap .) . flip . (fmap .) . flip
06:34:15 <Stephan202> hmm...
06:36:52 <mapreduce> Ah, right, the guy in #emacs talking about line noise must have meant to say it here.
06:38:36 <BONUS> haha guys ok check out this horrible visual pun i made
06:38:37 <BONUS> http://learnyouahaskell.com/input-and-output#command-line-arguments
06:38:43 <lambdabot> Title: Learn You a Haskell for Great Good! - Input and Output, http://tinyurl.com/5kr757
06:39:55 <Saizan> hahahah
06:40:33 <BONUS> :]
06:45:30 <Igloo> http://www.reddit.com/r/programming/comments/7h46q/what_makes_the_camp_and_darcs_vcss_unique/
06:45:32 <lambdabot> Title: What makes the camp and darcs VCSs unique : programming, http://tinyurl.com/55ddv4
06:51:23 <mmorrow> here's that @pl output for convolve prettyprinted and HsColoured http://moonpatio.com/repos/Convolve.html
06:51:28 <lambdabot> Title: Haskell code
06:51:51 <mmorrow> either @pl didn't preserve proper typing or i didn't get all of the output
06:52:58 <mmorrow> i'm pretty sure i got all of it though
06:53:28 <mmorrow> ghci was complaing about an infinite type [[a]] = [[[a]]]
06:53:36 <Zao> Igloo: Neato.
06:53:48 <mmorrow> err, i think it wasn't infinite type but expected/inferred
06:55:53 <Zao> So this is what, a new darcs-like VCS?
06:56:01 <Zao> Just what the world needs, another version control system :P
06:56:57 <BeelsebobWork> Zao: ?
06:57:04 <BeelsebobWork> what is a new darcs-like VCS?
06:57:12 <C-Keen> Zao: you are talking in the wrong channel
06:57:16 <Zao> BeelsebobWork: See Igloo's line about `camp' above.
06:57:18 <C-Keen> BeelsebobWork: camp
06:57:28 <vixey> @pl 1 +0 * Partial evaLuate + 1
06:57:28 <lambdabot> 2
06:57:34 <C-Keen> Zao: camp may be the foundation for darcs3
06:57:50 <Zao> C-Keen: Before the link there, I'd never heard of it.
06:58:22 <C-Keen> Zao: well it is not ready for anything yet and a framework for Igloo to try his ideas
06:59:32 <Igloo> BeelsebobWork: http://projects.haskell.org/camp/
06:59:34 <lambdabot> Title: Camp
06:59:43 <Igloo> Zao: Hopefully it will become darcs3
06:59:44 <BeelsebobWork> just watching the video now
06:59:49 <Igloo> Oh, C-Keen said that, sorry
07:02:44 <BeelsebobWork> Igloo: neat -- how stable is it?
07:03:44 <Igloo> BeelsebobWork: It's not a usable VCS yet
07:04:02 <BeelsebobWork> ah, kk
07:04:28 <BeelsebobWork> Igloo: does (will?) it deal with file moves correctly
07:04:45 <BeelsebobWork> i.e. will it actually treat them as moves, and retain the history of the file, rather than treating them as delete and create
07:04:47 <Igloo> BeelsebobWork: Yes, in the same way that darcs does
07:04:50 <Igloo> Yes
07:04:58 <BeelsebobWork> eh, that's not what darcs does
07:07:19 <Igloo> BeelsebobWork: Hmm? darcs definitely treats them as renames. It's possible that the annotate command doesn't show what you want or something?
07:07:54 <BeelsebobWork> Igloo: if I create a file called jam
07:07:56 <BeelsebobWork> add it
07:07:59 <BeelsebobWork> modify it and record
07:08:04 <BeelsebobWork> darcs move it and record
07:08:07 <BeelsebobWork> modify again and record
07:08:11 <BeelsebobWork> and then ask for the history of the file
07:08:17 <BeelsebobWork> I get told created, then modified once
07:09:14 <Igloo> BeelsebobWork: OK, so perhaps darcs is giving you the history of the filename. It definitely knows it's a move internally, e.g. you can pull the two modification patches without the move patch and it'll DTRT
07:09:24 <BeelsebobWork> yep
07:09:34 <BeelsebobWork> it would be nice to get the move (and prior patches) in the history too
07:09:39 <bastl> hello. is there a parser framework that can read other grammar-formats (e.g. lex/yacc, sablecc, antlr) I just need parsers for a couple of given languages and dont want to develop everything on my own ...
07:09:53 <Igloo> OK, that's just a UI issue; nothing deep
07:09:56 <bastl> insert a '?' somewhere above ...
07:09:57 <BeelsebobWork> bastl: happy/alex
07:10:32 <BeelsebobWork> they use yacc format files, but with (unsurprisingly) Haskell code to tell it what to do with the parts of the rule
07:10:57 <bastl> ok, thanks. ill look into that
07:13:09 <mmorrow> BONUS: lol, command-line args
07:14:06 <pk> @src convolce
07:14:06 <lambdabot> Source not found. Wrong!  You cheating scum!
07:14:10 <pk> @src convolve
07:14:10 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
07:14:37 <Zao> Igloo: Good luck to you then :)
07:14:54 <Igloo> Zao: Thanks!
07:16:47 * quicksilver contemplates a bzr-compatible haskell VCS tool
07:16:51 <quicksilver> just to further muddy the waters.
07:19:06 <Saizan> oh, typo "worth spending time one"
07:20:37 <Igloo> Ooops, thanks, fixed
07:22:31 <sw17ch> @seen conal
07:22:31 <lambdabot> I saw conal leaving #haskell and #ghc 5h 50m 21s ago, and .
07:22:50 <mmorrow> @let blur t = fmap sum . init . tail . convolve (*) [t/2,1-t,t/2]
07:22:52 <lambdabot>  Defined.
07:23:00 <sw17ch> @src convolve
07:23:01 <lambdabot> Source not found. There are some things that I just don't know.
07:23:02 <mmorrow> > blur 0.2  [0,1,0,1,0,1,0]
07:23:03 <lambdabot>   [0.1,0.8,0.2,0.8,0.2,0.8,0.1]
07:23:04 <sw17ch> morrow?
07:23:19 <sw17ch> what is convolve?
07:23:23 <mmorrow>   @let convolve (<>) fltr = let go r (xs:xss) = takeWhile (not . null) . dropWhile null . snd . foldl (\(n,xs) ys -> let n' = n+r in (n', zipWith (++) xs (replicate n' [] ++ fmap (:[]) ys ++ repeat []))) (r, replicate r [] ++ fmap (:[]) xs ++ repeat []) $ xss in go (length fltr `div` 2) . fmap (\y -> fmap (\x -> x <> y) fltr)
07:23:25 <mmorrow> :)
07:23:34 <sw17ch> XO
07:23:51 <sw17ch> mmorrow: do i dare ask what it does?
07:24:04 <mmorrow> it does convolution in one dimension
07:24:25 <sw17ch> ...now what does that achieve?
07:24:25 <sw17ch> :)
07:24:37 <mmorrow> the first arg::[a]  is the filter and the second::[a]  is the vector
07:24:51 <mmorrow> so you can use it to apply digital filters
07:25:03 <mmorrow> blur would blur a digital image for instance
07:25:03 <sw17ch> I guess i mean to ask waht the process of convolution is
07:25:28 <sw17ch> besides what your one-liner did to my face
07:25:42 <mmorrow> ah, polynomial multiplication is an example of it
07:25:45 <jkff> The video is cool
07:26:02 <mmorrow> convolve your grill!
07:26:29 <sw17ch> heh
07:26:57 <mmorrow> and if you fourier transform the vectors, convolution maps to simple multiplication, then you can apply and inverse fft and arrive at the same result as if you had done the convolution
07:27:31 <sw17ch> mmorrow: most of those things are things i've never had the chance to work with
07:27:35 <sw17ch> :)
07:27:37 <mmorrow> but doing   ifft . (*) . fft  is in most cases much more efficient than doing convolution
07:27:42 <sw17ch> unfortunately, most of it went over my head :)
07:28:05 <MyCatVerbs> BONUS_: what's up with the Cartoon Network obsession, anyway?
07:28:15 <MyCatVerbs> BONUS_: (sheep in the city FTW)
07:28:28 <mmorrow> essentially you could write most of image magick (efficiency aside) with that convolve function
07:28:41 <sw17ch> oh, very nice
07:28:49 <sw17ch> see, that makes sense to me now :)
07:28:49 <mmorrow> blur, sharpen, edge detect, ...
07:29:04 <mmorrow> or filter wav files
07:29:11 <mmorrow> :)
07:29:14 <sw17ch> mmorrow: you haven't worked with image recognition, have you?
07:29:24 <sw17ch> ah, now filtering wav files is something i *have* needed to do
07:29:28 <sw17ch> but didn't do it successfully
07:29:29 <sw17ch> :)
07:29:33 <pumpkin_> yo ho ho and a bottle of rum
07:29:33 <MyCatVerbs> mmorrow: efficiency aside? R U SRS? Convolutions have *very* efficient implementations. =)
07:29:33 <mmorrow> i haven't but i've read a little bit here and there. it sounds interesting
07:29:40 <sw17ch> the horribly broken portaudio package on hackage is mine :\
07:29:58 <mmorrow> MyCatVerbs: i said with the /above/ convolve function as a one-liner ;)
07:30:02 <sw17ch> my ffi-foo wasn't as strong when i was working on that
07:30:36 <mmorrow> sw17ch: hehe
07:30:57 <MyCatVerbs> mmorrow: oh, but it will when GHC 12 comes out! =D
07:30:59 <mmorrow> i'll have to check it out, i haven't done anything with audio in haskell
07:31:08 <pumpkin_> mmorrow: wow, that convolve looks epic :P
07:31:08 <mmorrow> MyCatVerbs: duh
07:31:10 <MyCatVerbs> mmorrow: 12.1 will add the feature that overclocks your CPU a little bit too ;D
07:31:17 <sw17ch> mmorrow: well, there really doesn't seem to be a good way to *play* audio in haskell :\
07:31:25 <sw17ch> which is why i worked on that in the firstp lace
07:31:30 <pumpkin_> mmorrow: my naive autocorrelation function was around that long, and yours is way more general :P
07:31:46 <sw17ch> but i got very *very* lost in some of the more interesting pieces of the FFI at that point.. (like how to do callbacks)
07:31:54 <mmorrow> sw17ch: writeFile "/dev/dsp" =<< .... -- ?
07:31:56 <mmorrow> ;)
07:32:11 <sw17ch> mmorrow: hhehe, that was my first thought
07:32:15 <sw17ch> but i wanted cross platform
07:32:22 <sw17ch> portaudio is the library behind audacious
07:33:05 <mmorrow> sw17ch: yeah, the depths of the ffi sounds treacherous indeed
07:33:18 <sw17ch> mmorrow: actually, if you do end up playing with it, and figuring out how to use it, you'll notice that it works *most of the time*
07:33:20 <mmorrow> sw17ch: oh cool, i've played with audacious a bit
07:33:31 <sw17ch> once in a while it does goofy stuff and flips bits, or shifts the channels  ... or something
07:33:36 <sw17ch> it just comes out as garbage
07:33:39 <sw17ch> and i'm nto sure why :)
07:33:43 <mmorrow> heh
07:33:56 <sw17ch> but i have successfully recorded audio and played it back with that library ... i should revisit it
07:34:07 <mmorrow> it gives it "character" i'm sure
07:34:20 <mmorrow> (random ejection of garbage ;)
07:34:37 <pumpkin_> that's why people like valve amplifiers
07:34:41 <pumpkin_> and vinyl
07:35:55 <mmorrow> pumpkin_: my first thought on that convolve function is to start dumping some of those []s incrementally from within the foldl
07:36:12 <mmorrow> because they just build up as it is
07:36:28 <pumpkin_> mmorrow: it'd be interesting to see how efficient (and elegant) you can get it, even if it isn't the best way to do it
07:36:47 <mmorrow> well, only (length fltr `div` 2) empty ones, but once you start moving down the list you could start dumping results
07:37:21 <mmorrow> pumpkin_: i've got that in my "too-mess-with-asap" scratch file
07:37:36 <pumpkin_> :)
07:51:35 <hugo___> how do i do optional arguments in haskell ?
07:52:16 <quicksilver> hugo___: arguments of type (Maybe a)
07:52:22 <quicksilver> hugo___: is probably the simplest idiom
07:52:26 <BeelsebobWork> or you partially apply functions
07:52:31 <hugo___> allright, thanks
07:52:59 <BeelsebobWork> myFunctionWithLotsOfArguments option jam ham spam = ...; simplerFunction = myFunctionWithLotsOfArguments defaultValue
07:53:29 <FunctorSalad> ghc should have speech output... <deep voice> "we require more instance declarations!"
07:54:04 <mmorrow> <robot voice> cannot construct the infinite type ...
07:54:45 <BeelsebobWork> you mean ghc myFile | say?
07:54:51 <BeelsebobWork> OS X only I'm afraid
07:55:30 <mmorrow> oh, what's the linux one called... i can't remember but i know i have it installed
07:55:41 <BeelsebobWork> oh fail
07:55:45 <BeelsebobWork> need to pipe stderr
07:55:51 <mmorrow> hah
07:56:17 <quicksilver> BeelsebobWork: ghc myFile 2>&1 | say
07:57:11 <BeelsebobWork> quicksilver: wow, alex pronounces : as cologne
07:59:09 <quicksilver> BeelsebobWork: haha ;)
07:59:53 <FunctorSalad> why does it do that?
07:59:53 <ksf> festival?
08:00:25 <Apocalisp> BeelsebobWork, does he also call @ "strudel"?
08:01:10 <mmorrow> festival!
08:01:11 <mmorrow> $ echo beetelgeuse beetelgeuse beetelgeuse | festival --tts
08:07:55 <mmorrow> haha
08:07:57 <mmorrow> ghc -e "replicate 78 '-'" | festival --tts
08:08:04 <mmorrow> "line of hyphens"
08:08:09 <mmorrow> (in a robot voice)
08:08:17 <trofi> :]
08:10:26 <dancor> ghc has -e, that's amazing
08:10:33 <FunctorSalad> news to me too
08:11:08 <FunctorSalad> but I guess you can't do much without import decls
08:11:32 <leimy> wow
08:12:19 <dancor> ghc -e 'print $ first (+1) (4, 5)'
08:12:25 <dancor> works, but runghc on that doesn't
08:13:02 <dancor> no Data.Map afaict
08:13:10 <MyCatVerbs> "FunctorSalad:!nac uoy esruoc fo ,yllis eb t'noD"
08:14:01 <FunctorSalad> > reverse "FunctorSalad:!nac uoy esruoc fo ,yllis eb t'noD"
08:14:03 <lambdabot>   "Don't be silly, of course you can!:dalaSrotcnuF"
08:14:12 <MyCatVerbs> <interactive>:1:31:
08:14:12 <MyCatVerbs>     Couldn't match expected type `[Char]'
08:14:12 <MyCatVerbs>            against inferred type `String -> String'
08:14:12 <MyCatVerbs>     In the second argument of `(++)', namely
08:14:12 <MyCatVerbs>         `unwords . map reverse . words'
08:14:17 <MyCatVerbs>     In the first argument of `($)', namely
08:14:17 <MyCatVerbs>         `"FunctorSalad: " ++ unwords . map reverse . words'
08:14:20 <MyCatVerbs>     In the second argument of `($)', namely
08:14:22 <MyCatVerbs>         `"FunctorSalad: " ++ unwords . map reverse . words
08:14:24 <MyCatVerbs>      $ "Or you can engage in even more frivolous activities."'
08:14:30 <MyCatVerbs> Bugger.
08:14:32 <MyCatVerbs> Erk. Sorry everyone. x_x
08:14:34 <dancor> can i call you srotch for short
08:14:47 <DalaSrotcnuF> :)
08:15:01 <mmorrow> [m@ganon ~]$ ghc -e 'Unsafe.Coerce.unsafeCoerce id :: IO ()'
08:15:01 <mmorrow> Segmentation fault
08:15:02 <MyCatVerbs> FunctorSalad: rO uoy nac egagne ni neve erom suolovirf .seitivitca
08:15:02 <pumpkin_> surely you mean (:
08:15:32 <mmorrow> [m@ganon ~]$ ghc -e 'System.system "killall -9 ghc"'
08:15:32 <mmorrow> Killed
08:15:50 <MyCatVerbs> mmorrow: I DARE YOU to try that on a Solaris machine.
08:15:51 <dancor> hope you didn't have any other scripts running :/
08:16:05 * MyCatVerbs smacks mmorrow with a rolled up copy of pkill(1)'s man page.
08:16:10 <DalaSrotcnuF> ghc -e 'System.system "cat | cat | cat | cat | cat | cat"'
08:17:16 <orbitz> someone needs to add a special -e easter egg that will bring them to a vieo of a rick aisley video
08:17:17 <mmorrow> dancor, MyCatVerbs: hehe
08:17:29 <FunctorSalad> (useless use of cat was the only left over missing feature in Haskell)
08:17:31 <hugo___> is there an equivalente to the *nix "file" command for haskell functions ?
08:17:42 <hugo___> i want to know the filetype before i read it...
08:17:47 <pumpkin_> useless cat is useless
08:17:48 <vixey> hugo__: :t
08:17:49 <pumpkin_> sorry
08:18:09 <hugo___> vixey: i explained myself wrong, im sorry
08:18:11 <Lemmih> hugo___: Just look at the extension.
08:18:28 <hugo___> hehehe
08:18:30 <Lemmih> hugo___: See System.FilePath.takeExtension
08:18:32 <FunctorSalad> hugo___: readProcess "file" [myfilepath] ""
08:18:33 <dancor> hugo___: well.. you could use HSH and do  run ("file", fileName)
08:18:37 <pumpkin_> hugo___: :t ?
08:18:41 <hugo___> yes, extensions are not always trustworthy
08:18:42 <pumpkin_> :P
08:18:57 * dancor is really too much of a HSH fanboi
08:19:11 <pumpkin_> high school haskell?
08:19:17 <Lemmih> hugo___: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/magic
08:19:18 <lambdabot> Title: HackageDB: magic-1.0.7
08:19:32 <hugo___> oh, very swweeet
08:19:38 <hugo___> thanks :)
08:20:00 <FunctorSalad> don't ask me why it's called 'readProcess' if it supports both the stdin and stdout of the process
08:20:08 <MyCatVerbs> pumpkin_: Haskell SHell. :)
08:20:15 <pumpkin_> ooh
08:20:25 <idnar> MyCatVerbs: not HASH?
08:23:23 <FunctorSalad> , echo "bot has HSH module"
08:23:25 <lunabot>  luna: Not in scope: `echo'
08:27:50 <FunctorSalad> how does reverse.reverse==id eliminate bottoms? only for infinite lists?
08:27:59 <Ezla> is it easy to use haskell with C++ ?
08:28:13 <Ezla> do you guys ever write "half and half" codebases?
08:28:15 <Zao> Ezla: You've generally have to go via C.
08:28:18 <Lemmih> FunctorSalad: Right, reverse.reverse is strict in the spine.
08:28:24 <quicksilver> FunctorSalad: it eliminates spine bottoms
08:28:25 <gwern> Ezla: dunno. it's hard to cabalize c++ bindings though, I can tell you that
08:28:29 <quicksilver> FunctorSalad: it doesn't touch the values
08:28:38 <FunctorSalad> spine?
08:28:45 <gwern> eg. there's a reason no one has touched qthaskell
08:28:59 <Ezla> Qthaskell?
08:29:11 <Ezla> does that even exist
08:29:13 <quicksilver> FunctorSalad: you know the jokey imagine of a fish skeleton having been eaten by a fish?
08:29:36 <gwern> Ezla: it does. you know why I'm the only one here who knows it does
08:29:40 <gwern> ?
08:29:41 <quicksilver> FunctorSalad: a haskell list is one of those. the actual values hang off the bottom of the lateral bones
08:29:49 <hugo___> ok, i have a noob question
08:29:50 <Ezla> gwern: coz you're making it?
08:29:52 <quicksilver> FunctorSalad: the 'spine' part is just the (:) constructors.
08:29:57 <quicksilver> and the [] at the end.
08:30:05 <gwern> Ezla: because it binds to c++ and has this horriblly fragile build process which I spent an hour or two looking at and then gave up on
08:30:18 <Ezla> "binds to C++" how?
08:30:26 <hugo___> i have done this line in ghci to test the magic haskell functions: do { mgc <- magicOpen [MagicNone]; magicLoadDefault mgc; s <- magicFile mgc "teste.png"; putStrLn s}   how do i change this to liftIO's ? and if i do, will it become easier to read ?
08:30:28 <gwern> after that and Bullet, I decided to not bother with any bindings to c++
08:30:44 <sw17ch> c++ is hard to  writing bindings for in *any* language
08:31:00 <quicksilver> except C, if your C compiler is also a C++ compiler.
08:31:01 <Ezla> unlike D, which has standard name mangling, and is as fast as C++
08:31:11 <Ezla> and reflection
08:31:14 <Ezla> D <-> haskell in full OO would be easy
08:31:25 <quicksilver> name mangling is not the whole problem, actually.
08:31:38 <quicksilver> data layout of objects is part of the C++ ABI too.
08:31:39 <Ezla> sure, exceptions as well
08:31:52 <quicksilver> and how references/pointers/literal objects get passed
08:32:01 * sw17ch thinks exceptions shouldn't be in C++...
08:32:07 <FunctorSalad> quicksilver: maybe one needs to have seen the image to get that picture :)
08:32:17 <Ezla> sw17ch: why?
08:32:23 <FunctorSalad> but how is there a bottom in the spine... it's just infinite
08:32:49 <FunctorSalad> @src reverse
08:32:50 <lambdabot> reverse = foldl (flip (:)) []
08:32:54 <quicksilver> FunctorSalad: there might be a bottom in the spine.
08:32:57 <wjt> > (reverse . reverse) (1:undefined)
08:32:59 <lambdabot>   * Exception: Prelude.undefined
08:33:04 <quicksilver> wjt was faster than me.
08:33:05 <wjt> > id (1:undefined)
08:33:06 <lambdabot>   [1* Exception: Prelude.undefined
08:33:09 <wjt> ^^
08:33:11 <sw17ch> void f() { void * v = malloc(0x4000); someFunThatThrowsException(); free(v); }
08:33:14 <sw17ch> Ezla: ^^
08:33:14 <cpfr> hey im running sequence to turn a bunch of monadic actions into one action that returns a list of my results, but only the first one pops out
08:33:26 <sw17ch> i know you can use auto_ptr and whatnot...
08:33:34 <cpfr> so in my attempt to trun [IO String] into IO [String]
08:33:39 <cpfr> i lose my strings
08:33:44 <sw17ch> ...but i still think it's evil evil bad juju
08:33:49 <quicksilver> cpfr: careless. Did you check behind the fridge?
08:34:02 <ttt--> hi, is it possible to make a function that shows dynamic values of type (Show a => a) ?
08:34:04 * cpfr no just cockroaches
08:34:17 <FunctorSalad> > head $ (reverse . reverse) [1..]
08:34:38 <vixey> 1
08:34:40 <quicksilver> ttt--: no. but that's not the type you meant. It is possible to do what you want with an existential.
08:34:42 <ttt--> something like "show (fromDyn (toDyn 3)"
08:34:43 <Lemmih> cpfr: see 'sequence'.
08:34:44 <FunctorSalad> wtf :)
08:34:55 <cpfr> Lemmih, i am using sequence
08:35:01 <cpfr> and im losing the Strings
08:35:05 <FunctorSalad> oh nevermind. vixey, you have the samer color as teh bot :)
08:35:17 <quicksilver> vixey++ # camouflage
08:35:21 <roconnor> *LOL*
08:35:23 <ttt--> quicksilver, can you show me how? i dont know about existentials
08:35:28 <gwern> man, M-x in yi is so broken I am no longer amused by it
08:35:32 <Lemmih> cpfr: Then you're doing it wrong (: Paste the code somewhere online.
08:35:42 <quicksilver> ttt--: define a type data Showable = forall a . Show a => Showable a
08:36:00 <quicksilver> ttt--: then instance Show Showable where show (Showable x) = show x
08:36:03 <Ezla> sw17ch: that's irrelevant
08:36:10 <Ezla> you wrote exception unsafe code
08:36:18 <quicksilver> Ezla: it's not irrelevant.
08:36:20 <Ezla> ... don't do that
08:36:24 <ttt--> hm, i see. thanks
08:36:32 <quicksilver> the point (which you may not agree with) is that C++ makes it too easy to write exception unsafe code.
08:36:40 <quicksilver> so it's a poor language for exceptions.
08:36:42 <FunctorSalad> @botsnack still there?
08:36:42 <lunabot>  :)
08:36:49 <lambdabot> :)
08:36:51 <quicksilver> you don't have to agree, but it's highly not irrelevant.
08:37:13 <Ezla> quicksilver: programming require "some brains".. you don't go arbitrarily  int* x = rand(max); *x = 1; either
08:37:14 <sw17ch> Ezla: it's relevant because it's way to easy to miss something like that
08:37:22 <Ezla> sw17ch: No it's not.
08:37:28 <Ezla> maybe if you're a haskell programmer.
08:37:39 <quicksilver> Ezla: of course. Programming requires brains so we should all just use assembly, right?
08:37:40 <cpfr> Lemmih,
08:37:42 <cpfr> http://hpaste.org/12667
08:37:48 <vixey> IT's easy to make mistakes in haskell too
08:38:01 <quicksilver> Ezla: despite the fact that programming requires brains, it's still perfectly relevant to discuss features which make programming in particular languages better
08:38:11 <quicksilver> in the sense of easier to write bug free code, or easier to write fast code
08:38:14 <sw17ch> Ezla: perhaps you were endowed from the heavens with the ability to make full use of your brain at all times and never write code with latent problems that show up *only when rare exceptions are thrown*, but i wasn't
08:38:17 <quicksilver> or any number of other metrics.
08:38:19 <sw17ch> so perhaps, for me, C++ is evil...
08:38:44 <Ezla> alright, except there's no alternative to exceptions, they're highly useful and remove the need to snake thousands of condition variables through a codebase just to catch resources problems
08:38:45 <boingoboingo> hello haskell people
08:38:51 <Ezla> it simplifies your functions
08:38:53 <boingoboingo> what is going down
08:39:04 <quicksilver> cpfr: you're collecting "bibs" as the result of the sequence command
08:39:09 <quicksilver> cpfr: but you're not doing anything with bibs?
08:39:12 <Ezla> without exceptions, simple functions which do foo(bar) end up needing foo(bar, EXTRA)
08:39:14 <quicksilver> cpfr: so, in that sense, you lose it.
08:39:16 <cpfr> quicksilver, i use it later
08:39:21 <Ezla> which have nothing to do with their functionality
08:39:22 <sw17ch> Ezla: i can buy that if you decide you'll always use autoptr and never explicitly use "new" or "malloc"
08:39:29 <Ezla> not having exceptions ruins the whole codebase
08:39:37 <quicksilver> cpfr: well then in what sense do you lose it?
08:39:39 <sw17ch> I never use exceptions... and it works fine :)
08:39:49 <Ezla> sw17ch: because you don't know how they work
08:39:56 <quicksilver> Ezla: don't be an idiot.
08:39:58 <Lemmih> cpfr: When you call the program with multiple arguments, 'bibs' only contain a single value?
08:39:59 <cpfr> quicksilver, when i pull the contents out of bibs i see only one entry
08:40:05 <Ezla> oro perhaps don't know how to write exception safe code
08:40:15 <quicksilver> Ezla: don't tell sw17ch what he does or doesn't know.
08:40:20 <boingoboingo> guys, could you explain me what is going on here: http://pastebin.com/d5631209a
08:40:24 <Ezla> more specifically, you use the pattern of RAII
08:40:33 <Ezla> and exception safety is always confined to 1 place
08:40:35 <quicksilver> cpfr: maybe args only has one entry?
08:40:41 <Ezla> your construction
08:40:46 <quicksilver> cpfr: element, I mean.
08:40:58 <cpfr> quicksilver, the odd thing is getArgs always returns a list
08:41:02 <Ezla> quicksilver: He doesn't
08:41:03 <quicksilver> cpfr: yes, it does.
08:41:09 <cpfr> and the line with rawbibs on it always worked
08:41:13 <FunctorSalad> ,src MonadError
08:41:14 <sw17ch> Ezla: do you control every aspect of every project you're on, or do you work with other people who occasionally make mistakes?
08:41:16 <lunabot>  luna: Not in scope: data constructor `MonadError'
08:41:20 <cpfr> and all my maps should work for singeltons
08:41:22 <quicksilver> Ezla: sw17ch already explained that he knew what RAII is.
08:41:29 <Ezla> sw17ch: the former
08:41:30 <Lemmih> cpfr: Make sure 'rawbibs' and 'args' both contain more than a single item.
08:41:33 <quicksilver> Ezla: please do not tell other people what they know.
08:41:35 <vixey> Ezla, in haskell, we generally (at least try) to express these sort of safety rules in te type system, which totally ensures that you adhere to them
08:41:40 <sw17ch> Ezla: see, i work with other people, and ther people work with me
08:41:44 <quicksilver> cpfr: yes, but you're not using a map
08:41:48 <quicksilver> cpfr: you're using a zipwith
08:41:52 <quicksilver> cpfr: do you understand what zipwith does?
08:41:56 <cpfr> yes
08:41:59 <sw17ch> and i make a ton of mistakes that only show up in corner cases
08:42:07 <quicksilver> cpfr: if args only has one element, then you will only get one result.
08:42:11 <cpfr> i meant on the rawbibs line
08:42:13 <quicksilver> cpfr: which is what you are describing.
08:42:18 <pumpkin_> only imperfect men make mistakes, I never make mistakes
08:42:23 <sw17ch> and C++'s exceptions only exacerbate the problem when we're hunting down the memory leak
08:42:31 <vixey> Ezla, which makes programming something like C++ terrifying if you used haskell too long
08:42:35 <cpfr> quicksilver, ah! i see what i did wrong
08:42:38 <lilac> pumpkin_: i never make mistaeks either :)
08:42:39 <cpfr> thanks quicksilver :)
08:42:41 <quicksilver> cpfr: ;)
08:42:46 <pumpkin_> lilac: yay
08:42:56 <pumpkin_> #perfection
08:43:12 <sw17ch> vixey: actually, that's probably it... i've used Haskell too long and am used to it showing me my imperfections :)
08:43:21 <vixey> sw17ch, yes
08:43:25 <sw17ch> Haskell: it shows you how much you suck at programming
08:43:30 <vixey> same with mutable state
08:44:02 <vixey> you go back to ALGOL and you forgot how to use :=
08:46:01 <boingoboingo> BASIC, kthx
08:46:06 <sw17ch> vixey: i write C code for embedded environments... since learning haskell, the amount of "const" usage in my code has risen very sharply :)
08:46:25 <sw17ch> (and oddly enough, my bug rate has gone down....)
08:46:42 <vixey> I only ever saw const in C++
08:47:02 <sw17ch> the sad thing is that you can strip const off anything without too much effort :(
08:47:03 * lilac wonders how many people here write C, C++ or similar to pay the bills and use haskell for fun
08:47:11 * quicksilver writes Perl to pay the bills.
08:47:19 <lilac> quicksilver: i'm so sorry.
08:47:26 <osfameron> ;-)
08:47:28 <quicksilver> It's quite all right. I'm not.
08:47:34 <lilac> hehe :)
08:47:34 <quicksilver> The bills are large, and it pays them well.
08:47:37 <quicksilver> ;)
08:47:44 <sw17ch> lilac: I do, but i've been pushing to get more Haskell usage to generate C code. I already have one success story with that. (Haskell to generate C, that is)
08:48:07 * osfameron considers getting haskell to write the cobol he's currently having to write
08:48:20 <lilac> sw17ch: at work, i've managed to achieve widespread Python usage, but Haskell's going to be a push
08:48:40 <sw17ch> lilac: i'm the only one here that knows it, but i've impressed a few people with what i can *do* with it
08:48:44 <gwern> @hoogle getClockTime
08:48:44 <lambdabot> No results found
08:48:53 * Beelsebob was very glad to get hired specifically as a Haskeller
08:48:54 <sw17ch> so, i'm making inroads
08:49:32 <lilac> sw17ch: there's an internal project here currently to replace make with something less rubbish, and it would be /so much easier/ if we were doing it haskell rather than python
08:50:10 <Beelsebob> lilac: yeh, you'd just use cabal >.<
08:50:20 <sw17ch> lilac: I used it to generate 10K lines of C code to test software requirements :)
08:50:41 <lilac> sw17ch: hehe, neat :)
08:50:56 <dcoutts> Beelsebob: where are you working now?
08:51:00 <lilac> Beelsebob: i suspect it'd be easier to adapt cabal to meet our requirements at least
08:51:11 <Beelsebob> dcoutts: anygma
08:51:17 <dcoutts> Beelsebob: ah right
08:52:00 <sw17ch> does anygma bathe you in money like the other Haskell shops do? :P
08:52:07 <quicksilver> lilac: would I rather be doing this job in haskell? Probably, yes. But when I started about 3 years ago, I did not think the haskell web frameworks could realistically compete with Catalyst.
08:52:30 <hugo___> isn't there any faster way of doing this (IO monad): do { t <- func "teste.png"; return $ head t}   ????
08:52:40 <FunctorSalad> quicksilver: but now they can?
08:52:45 <Beelsebob> sw17ch: they pay me enough
08:52:54 <hugo___> thats a lot of typing for a head of a list :/
08:52:57 <Beelsebob> and I get to live in a lovely city with awesome food
08:52:57 * ziman writes C to pay the bills ans uses Haskell for fun
08:53:00 <gwern> hugo___: faster? you mean shorter?
08:53:03 <hugo___> yes, shorter
08:53:08 <hugo___> sorry for the mistake
08:53:09 <hugo___> hehe
08:53:28 <gwern> hugo___: there's a way to desugar that into something like 'func 'teste.png' >>= head', I think
08:53:32 <lilac> hugo___: liftM head $ func "teste.png"
08:53:35 <FunctorSalad> hugo___: head <$> func "teste.png"
08:53:41 <hugo___> it should be possible to be able to do this:  IO (head (func "blah.jpg))
08:53:43 <sw17ch> Beelsebob: what's the city?
08:53:57 <hugo___> oh
08:53:58 <quicksilver> FunctorSalad: I'm not entirely sure, because I haven't tried.
08:54:00 <hugo___> let me try it :)
08:54:06 <Beelsebob> sw17ch: Antwerpen
08:54:14 <FunctorSalad> hugo___: you need to import Control.Applicative for that operator
08:54:17 <quicksilver> FunctorSalad: I think one can probably get the job done, but would find some libraries missing.
08:54:20 <hugo___> olraite
08:54:50 <hugo___> >:t <$>
08:54:56 <hugo___> :t <$>
08:54:58 <lambdabot> parse error on input `<$>'
08:55:04 <hugo___> (i never get this right)
08:55:09 <lilac> @hoogle Functor f => f (a -> b) -> a -> f b
08:55:10 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
08:55:10 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
08:55:10 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
08:55:15 <sw17ch> Beelsebob: nice
08:55:19 <lilac> :t (<$>)
08:55:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:55:21 <ttt--> quicksilver, im stuck here http://hpaste.org/12668 :/
08:55:23 <quicksilver> hugo___: <$> is just a name for fmap
08:55:27 <quicksilver> hugo___: but, it looks nicer IMO
08:55:37 <hugo___> so <$> = fmap ?
08:55:41 <quicksilver> ttt--: you can't do it with Dynamic.
08:55:46 <quicksilver> ttt--: only with Showable.
08:55:49 <lilac> hugo___: (<$>) == fmap, <$> == `fmap` :)
08:55:54 <Beelsebob> hugo___: yep, so does liftM, and liftA
08:55:55 <hugo___> oh yes
08:55:55 <quicksilver> ttt--: Dynamic has lost the information that it's Show-able.
08:55:58 <hugo___> ok
08:55:58 <boingoboingo> :t Show
08:56:00 <lambdabot> Not in scope: data constructor `Show'
08:56:08 <boingoboingo> uhm
08:56:22 <Beelsebob> hugo___: the other useful one is <*>
08:56:31 <Beelsebob> which can be used to create liftAn nicely...
08:56:32 <boingoboingo> okay, so what I have is the definition of a species
08:56:44 <Beelsebob> > (+) <$> [1,2,3] <*> [4,5,6]
08:56:48 <lambdabot>   [5,6,7,6,7,8,7,8,9]
08:57:16 <lilac> @type flip (fmap . flip ($))
08:57:17 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
08:57:19 <ttt--> quicksilver, but i get the value as a dynamic from dynCompileExpr.
08:57:31 <hugo___> that is powerfull
08:57:35 <quicksilver> ttt--: then the answer to your question is "No."
08:57:40 <quicksilver> ttt--: it can't be done.
08:57:41 <lilac> is there a builtin for that?
08:57:47 <quicksilver> ttt--: (unless you happen to know what the type is, statically)
08:58:32 <ttt--> can i get around it with an unsafe cast somehow?
08:58:49 <ttt--> to Show a => a
08:58:57 <quicksilver> no.
08:59:07 <quicksilver> What you are asking for is flat-out impossible.
08:59:13 <boingoboingo> guys, how many String comparison functions has Haskell?
08:59:17 <quicksilver> The compiler has to know statically what type it is.
08:59:26 <quicksilver> to pick the right show instance.
08:59:46 <quicksilver> ttt--: dynCompileExpr on its own is not very useful. For exactly this kind of reason ;)
08:59:49 <hugo___> i can apply <$> because monads are functor containers, right ?
08:59:50 <quicksilver> ttt--: what are you really trying to do?
09:00:01 <quicksilver> hugo___: all monads are also functors, yes.
09:00:09 <hugo___> sweet
09:00:17 <Beelsebob> hugo___: yeh -- you can apply it because if it's a monad, it defines liftM, and fmap is just liftM
09:00:22 <SKuhn1> which IDE would you suggest for haskell under linux/ubuntu?
09:00:32 <Beelsebob> similarly, if it's a monad, you can use <*> because it's just ap
09:00:39 <Beelsebob> and pure, because it's just return
09:00:39 <hugo___> i should really spend some time meditating on that :)
09:00:50 <lilac> > let infixl 4 >*<; (>*<) = flip (fmap . flip id) in zipWith <$> [(*), (+), (-)] >*< [10,20,30] <*> [[1,2,3],[4,5,6]]
09:00:52 <lambdabot>   [[10,40,90],[40,100,180],[11,22,33],[14,25,36],[9,18,27],[6,15,24]]
09:00:53 <quicksilver> ttt--: did you consider compiling the expression ("show (" ++ s ++ ")") ?
09:01:02 <quicksilver> ttt--: that makes the 'inner compiler' work out the type.
09:01:19 <ttt--> oh right!
09:01:40 <quicksilver> ttt--: and the 'outer compiler' just has to deal with the type being string ;)
09:01:42 * Badger is convinced people just spend their time coming up with impressive-looking Haskell to feed to lambdabot
09:01:49 <quicksilver> ttt--: so you can just use fromDyn with type String.
09:02:25 <quicksilver> ttt--: dynCompileExpr is mostly useful when you know the type the expression will be, or you know it's one of a finite number of types.
09:04:25 <ttt--> i see, thanks again
09:04:55 <quicksilver> not at all.
09:05:00 <quicksilver> Dynamic is fiddly.
09:05:05 <quicksilver> It's not generally the right answer ;)
09:05:12 <quicksilver> although it is a good answer for ghc-api.
09:05:16 <SKuhn1> which graphical Editor in linux has syntax highlighting for haskell?
09:05:23 <quicksilver> SKuhn1: vim and emacs both do.
09:05:37 <SKuhn1> quicksilver: I hate both ;)
09:05:41 <vixey> @src fromDynamic
09:05:41 <lambdabot> fromDynamic (Dynamic t v) = case unsafeCoerce v of
09:05:41 <lambdabot>     r | t == typeOf r -> Just r
09:05:41 <lambdabot>       | otherwise     -> Nothing
09:05:48 <gwern> yi has haskell syntax highlighting
09:05:51 <quicksilver> SKuhn1: then you're sadly misguided :P
09:05:58 <mc__> SKuhn1: give JEdit a try
09:06:10 <ziman> :t fromDynamic
09:06:11 <SKuhn1> mc__: ahh, right - thanks
09:06:12 <lambdabot> forall a. (Typeable a) => Dynamic -> Maybe a
09:06:20 <mc__> SKuhn1: you're welcome
09:06:22 <vixey> fromDynamic is really clevec
09:06:38 * Badger fires up pico
09:06:48 <b\6> ghc 6.10, cabal 1.6. not sure how to fix this: Could not find module `Data.Ratio': it is a member of package base-3.0.3.0, which is hidden
09:07:13 <SKuhn1> quicksilver: no, I started programming with Eclipse.  vim & emacs  for me are relicts from the 20th century ;)
09:07:31 <ziman> what's the use of Dynamic?
09:07:48 <dcoutts> b\6: does your .cabal file specify build-depends: base ?   does it specify any version constraint?
09:07:54 <gwern> SKuhn1: amusing 'relict' is a real word with a different meaning from 'relict', which could actually be appropriate in this context
09:07:59 <quicksilver> ziman: it's an infinite sum type, indexed by all the types in your program
09:08:11 <quicksilver> ziman: it's not useful very often.
09:08:14 <quicksilver> occasionally it is.
09:08:18 <gwern> 'An organism or population that is geographically isolated from other conspecifics or closely related tax' <-- certainly emacs is far isolated from its MIT or lisp machine brethren
09:08:24 <b\6> dcoutts: i have build-depends: base. i've tried stuff like base == 3.0.3.0.
09:08:29 <flux> quicksilver, does it include functions, btw?
09:08:33 <quicksilver> yup.
09:08:42 <pumpkin_> b\6: try == 4 maybe?
09:08:53 <quicksilver> but not polymorphism, as such.
09:09:06 <quicksilver> because polymorphism isn't really first class in haskell98
09:09:14 <quicksilver> there are hacks to get that working though.
09:09:14 <b\6> pumpkin_: no effect. :(
09:09:27 <vixey> heh gwern
09:09:34 <pumpkin_> b\6: does it have multiple choices for dependencies?
09:09:42 <pumpkin_> b\6: make sure you're changing the right one, if so
09:09:43 <dcoutts> b\6: Data.Ratio is in both base 3 and 4
09:10:12 <b\6> pumpkin_: i only specify one thing in build-depends.
09:10:53 <dcoutts> b\6: if you load ghci and say :browse Data.Ratio does that work?
09:11:03 <b\6> dcoutts: yes.
09:11:42 <dcoutts> b\6: when you configure -v, what version of base does it say it's using?
09:13:17 <b\6> dcoutts: hmm. cabal clean && cabal configure -v isn't mentioning base.
09:13:54 <dcoutts> b\6: so it lists all the other packages that your package depends on but not base?
09:14:06 <lilac> is fromDynamic equivalent to 'fromDynamic (Dynamic t v) | t == typeOf r = Just r | otherwise = Nothing where r = unsafeCoerce v'?
09:14:18 <dcoutts> b\6: perhaps you could use hpaste for your .cabal file and for the output of configure -v
09:14:21 <quicksilver> lilac: that looks right, yes.
09:14:31 <b\6> dcoutts: ok, sec.
09:14:37 <lilac> i wonder why it's written in the mindbending way it is :)
09:15:34 <quicksilver> lilac: the definition you gave is pretty much what I have
09:15:54 <quicksilver> lilac: it just unwraps hte unsafecoerce in a case not a where
09:18:12 <b\6> dcoutts: http://hpaste.org/12669
09:19:12 <lilac> quicksilver: right. it's the using-a-case-as-a-let thing which raised my eyebrow
09:19:53 <Twey> Isn't let just a single-branch case?
09:20:10 <Saizan>  Twey it's lazier than that
09:20:16 <quicksilver> in certain cases
09:20:16 <Twey> let x = y in z is equivalent to case y of x -> z
09:20:18 <Twey> Ah
09:20:18 <quicksilver> but not all ;)
09:20:26 <quicksilver> if you don't match any constructors they are exactly the same.
09:20:37 <quicksilver> so Twey's equivalent holds
09:20:51 <quicksilver> but supposing you replace "x" with "Just x" it doesn't any more
09:20:57 <Saizan> yeah, it's equivalent to case y of ~p -> z, for whatever p
09:21:08 <yitz> > case undefined of _ -> 42
09:21:09 <lambdabot>   42
09:21:29 <yitz> > case undefined of Just _ -> 42
09:21:30 <lambdabot>   * Exception: Prelude.undefined
09:22:05 <yitz> > let Just _ = undefined in 42
09:22:06 <lambdabot>   42
09:22:31 <dcoutts> b\6: ok, so the problem is that the build-depends should be in the library section
09:23:01 <dcoutts> b\6: basically you found a corner case that is not handled well. I've filed a ticket for it: http://hackage.haskell.org/trac/hackage/ticket/424
09:23:07 <lambdabot> Title: #424 (build-depends in global section in new-style .cabal files are ignored) - H ...
09:24:16 <dcoutts> b\6: make sense?
09:24:21 <vixey> lilac, I think not
09:24:35 <vixey> lilac, Doesn't that give errors (?)
09:24:49 <vixey> since you take the typeOf 'r' which was casted
09:24:56 <b\6> dcoutts: ah, thank you. sorry about that.
09:25:11 <vixey> oh... even the other definition did that
09:25:13 <dcoutts> b\6: not your fault, it should have behaved better.
09:25:26 <vixey> yeah I don't understand how either version works then
09:25:39 <vixey> @src typeOf
09:25:40 <lambdabot> Source not found. Sorry.
09:25:43 <vixey> :t typeOf
09:25:44 <lambdabot> forall a. (Typeable a) => a -> TypeRep
09:26:00 <vixey> how can typeOf x = typeOf (unsafeCoerce x) ?
09:33:23 <madnificent> simple question, I guess.  I have an Int.  I want to do something like: [1 .. (floor (val / 2))], but that gives my typing issues...
09:33:41 <madnificent> I've searched as to how I could resolve that, but I can't really wrap my head around it
09:33:53 <ToRA|MSR> > let val = 10 :: Int in [ 1 .. (val `div` 2)]
09:33:54 <lambdabot>   [1,2,3,4,5]
09:34:11 <madnificent> doh!
09:35:32 <ToRA|MSR> > let val = 10 :: Int in [1::Int .. fromRational (fromIntegral $ floor (val / 2))]
09:35:34 <lambdabot>       No instance for (RealFrac Int)
09:35:34 <lambdabot>        arising from a use of `floor' at ...
09:35:56 <ToRA|MSR> @hoogle (Floating a, Num b) => a -> b
09:35:57 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
09:35:57 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
09:35:57 <lambdabot> Data.List genericLength :: Num i => [b] -> i
09:36:06 <ToRA|MSR> mmm, ok less helpful
09:44:23 <loriel> I am trying to do something similar to "filterM (not . doesFileExist) myListOfFiles", but I cannot seem to figure out how to negate doesFileExist.
09:50:22 <Zao> loriel: liftM it, maybe?
09:51:40 <ToRA|MSR_> @pl \x -> doesFileExist x >>= return . not
09:51:40 <lambdabot> (not `fmap`) . doesFileExist
09:51:51 <loriel> Zao: Thanks, that works.
09:52:17 <loriel> I was trying to make it work as (return . note) =<< doesFileExist
09:52:59 <sebaseba> ?users
09:53:00 <lambdabot> Maximum users seen in #haskell: 564, currently: 564 (100.0%), active: 18 (3.2%)
09:54:00 <araujo> filterM = ((=<<) (return . not) . doesFileExist)
09:54:11 <araujo> loriel, if you want it point free
09:54:16 <Badger> 3.2% active
09:54:20 <Badger> heh.
09:54:57 <loriel> Ah
09:55:06 <loriel> Yeah, that was stupid of me
09:55:59 <loriel> Thanks :))
10:02:11 <Pellwurst> I'd like to split a string (which contains a key-substring" into two parts: the part before the key-substring and the part after the key-substring....does anyone kwow a good solution for that?
10:02:48 <Twey> :t break
10:02:49 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
10:03:11 <quicksilver> :t splitAt
10:03:11 <Twey> :t break (==undefined)
10:03:13 <lambdabot> forall a. Int -> [a] -> ([a], [a])
10:03:13 <lambdabot> forall a. (Eq a) => [a] -> ([a], [a])
10:03:37 <Pellwurst> i dont know the position of the substring
10:03:39 <Twey> @hoogle (Eq a) => [a] -> ([a], [a])
10:03:40 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
10:03:40 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
10:03:40 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
10:03:56 <Twey> @hoogle (Eq a) => a -> [a] -> ([a], [a])
10:03:57 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
10:03:57 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
10:03:57 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
10:04:05 <Twey> Hmph, I did think that there was one already defined
10:04:35 <Twey> @hoogle (Eq a) => [a] -> [a] -> ([a], [a])
10:04:36 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
10:04:36 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
10:04:36 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
10:04:40 <Twey> Hmn
10:04:42 <Twey> Apparently not.
10:05:03 <ddarius> Twey: Use break/span.
10:05:06 <Twey> Yeah
10:05:17 <Twey> What does span do?
10:05:25 <quicksilver> > head . filter (isPrefixOf "joy" . snd) $ map (\n -> splitAt n "happyhappyjoyjoy") [0..]
10:05:26 <Twey> I was about to write one with break and isPrefixOf.
10:05:27 <lambdabot>   ("happyhappy","joyjoy")
10:05:33 <ddarius> The same thing as span just negating the predicate.
10:05:34 <quicksilver> Pellwurst: ^^ like that
10:05:40 <Twey> Oh
10:05:41 <quicksilver> but slightly more robust.
10:05:42 <ddarius> s/span/break
10:05:47 * Twey nods.
10:05:54 <quicksilver> break/span don't let you take into account more than one char.
10:06:21 <Pellwurst> quicksilver: thx, i'll give it a try
10:06:53 * gwern feels slightly silly reading RWH and posting comments *after* it was published
10:07:17 <Saizan> >  (\subs str -> fmap (flip splitAt str . fst) . find (isPrefixOf subs . snd) . (zip [0..] . tails $ str) "joy" "happyhappyjoyjoy"
10:07:18 <lambdabot>   <no location info>: parse error on input `;'
10:07:40 <Saizan> ";"?
10:07:57 <Saizan> > (\subs str -> fmap (flip splitAt str . fst) . find (isPrefixOf subs . snd) . zip [0..] . tails $ str) "joy" "happyhappyjoyjoy"
10:07:58 <lambdabot>   Just ("happyhappy","joyjoy")
10:08:07 <quicksilver> yup, that's a bit better.
10:08:46 <Saizan> if we had zipper and comonad for list things like these would be simpler :)
10:27:51 <vixey> @src typeOf
10:27:52 <lambdabot> Source not found. Sorry.
10:27:55 <vixey> > typeOf 3
10:27:57 <lambdabot>   Integer
10:28:00 <vixey> > typeOf (unsafeCoerce 3)
10:28:01 <lambdabot>   Not in scope: `unsafeCoerce'
10:28:17 <vixey> @hoogle typeOf
10:28:18 <lambdabot> Data.Typeable typeOf :: Typeable a => a -> TypeRep
10:28:18 <lambdabot> package typeof
10:28:18 <lambdabot> Data.Typeable typeOf1 :: Typeable1 t => t a -> TypeRep
10:28:34 <vixey>     Ambiguous type variable `b' in the constraint:
10:28:35 <vixey>       `Typeable b' arising from a use of `typeOf' at <interactive>:1:0-22
10:28:35 <vixey>     Probable fix: add a type signature that fixes these type variable(s)
10:28:49 <vixey> @src fromDynamic
10:28:49 <lambdabot> fromDynamic (Dynamic t v) = case unsafeCoerce v of
10:28:49 <lambdabot>     r | t == typeOf r -> Just r
10:28:49 <lambdabot>       | otherwise     -> Nothing
10:29:05 <vixey> typeOf r is the return type
10:29:18 <vixey> it's not really the type of 'v' at all
10:29:52 <athos> hi
10:29:55 <vixey> hiii
10:32:41 <tomh> hey
10:33:29 <lilac> why is there Monoid, MonadPlus /and/ Alternative? isn't just one of them enough?
10:34:25 <Saizan> monadplus/alternative require some form of naturality over 'a'
10:36:36 <bos> Wow, Matt Podwysocki's RWH book club has 37 members now.
10:36:45 <BMeph> lilac: Monoid (Maybe a) acts differently from MonadPlus Maybe. Some people want both behaviors. Alternative is just MPlus transferred to AFs, though. :)
10:44:19 <lilac> BMeph: the usual haskell solution for multiple sane instances of a class is newtypes, not multiple classes :)
10:45:21 <BMeph> lilac: newtypes are for types that are identical, not for classes that are not. :)
10:45:23 <lilac> it's interesting that the Monoid instance for Maybe uses the fact that Maybe is an Applicative, and the Alternative and MonadPlus instances don't...
10:45:49 <BMeph> lilac: s/Monoid/Alternative/ :)
10:46:17 <lilac> BMeph: i don't follow
10:46:26 <BMeph> lilac: Alternative is an Applicative that would also be a MonadPlus if it were a Monad. :)
10:46:53 <lilac> > let a = Just (Sum 1); b = Just (Sum 2) in (a `mappend` b, a `mplus` b, a <|> b)
10:46:55 <lambdabot>   (Just (Sum {getSum = 3}),Just (Sum {getSum = 1}),Just (Sum {getSum = 1}))
10:47:27 <lilac> i would have expected those to all be the other way around :)
10:47:56 * lilac hesitates
10:51:12 <lilac> no, i get it now :) presumably fmap / liftM distributes over <|> / mplus?
10:51:52 <lilac> although that doesn't explain why the Monoid instance is different
10:53:17 <Saizan> because it's not that useful to have multiple names for the same thing?
10:53:28 <Saizan> Monoid is not related to Monad
10:53:44 <Cale> (Except that they're examples of the same idea in different categories.)
10:53:48 <lilac> we have newtypes for First and Last; why is the Monoid a => Monoid (Maybe a) the non-newtype one?
10:53:54 <conal> except that monads are monoids over other monoids
10:53:54 <Saizan> (yeah, i was going to add that :)
10:53:58 <conal> and probably other connections.
10:54:12 <BMeph> lilac: M-Plus and <|> just give back the first non-Nothing value. Monoid goes into both values and applied the monoid to those. :)
10:54:14 <conal> e.g., i use the IO *monoid*
10:54:33 <Saizan> monads are monoids where the tensor product is functor composition, right?
10:54:43 <lilac> BMeph: sure, i understand what they do, but not why that particular Monoid instance for Maybe is the designated special one
10:54:47 <Cale> Monads are monoid objects in the category of endofunctors on a category (and natural transformations between them).
10:54:56 <Cale> yes
10:55:21 * lament 's head explodes as he tries to make sense of cale's definition
10:55:24 <conal> Saizan: i mean mempty = return mempty ; mappend = liftA2 mappend
10:55:36 <Saizan> conal: that's another thing
10:55:37 <lament> Cale: endofunctors on which category?
10:55:52 <Cale> lament: On whatever category the monads are supposed to be over.
10:56:33 <Cale> That is, a monad on C is a monoid object in the category of endofunctors C -> C, with the tensor product taken to be functor composition.
10:56:48 <Saizan> conal: that's not really special to Monoid, you can lift other operations in the same way
10:57:05 <lament> Cale: the category is the category of types a in Maybe a or something?
10:57:46 <Cale> lament: Well the category of endofunctors on Hask would have Maybe, IO, Either e, (->) e, etc. as objects.
10:58:26 <Cale> lament: Arrows between them are natural transformations... which are more or less polymorphic functions
10:58:42 <lament> and monads are monoid objects in that category?
10:58:45 <Cale> forall a. Either e a -> Maybe a
10:58:49 <lilac> Cale: so the mappend is (>>)
10:58:49 <Cale> Yes.
10:58:55 <lilac> ?
10:58:57 <conal> Saizan: yes
10:58:58 <Cale> lilac: no, it's join
10:59:03 <Cale> :t join
10:59:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
10:59:05 <lilac> Cale: d'oh. of course
10:59:24 <Cale> :t mappend
10:59:25 <lambdabot> forall a. (Monoid a) => a -> a -> a
10:59:49 <BMeph> Cale: I.e., "mu" (not "Mu")? :)
10:59:59 <Cale> Instead of going  AxA -> A,  it goes from  M . M -> M
11:00:46 <Cale> And instead of the unit being 1 -> A, it's a map from the identity functor to M,
11:00:48 <Cale> :t return
11:00:49 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
11:01:33 <BMeph> (M,unit,mult) (monoid) <=> (M,unit,join) (monad) ? :)
11:01:48 <Cale> yeah
11:01:57 <BMeph> Er, (M,unit,mult) (monoid) <=> (M,return,join) (monad) ? :)
11:02:07 <Cale> http://en.wikipedia.org/wiki/Monoid_object
11:03:41 <Trinithis> Is there a function like dropWhile, but the predicate takes the current list?
11:04:01 <Cale> Of course, the monoidal operation on the objects of the category is different as well -- Cartesian product in the first case, and composition in the second
11:04:11 <Trinithis> @src dropWhile
11:04:12 <lambdabot> Source not found. You type like i drive.
11:04:16 <Cale> Trinithis: the current list?
11:04:26 <thetallgu1> Trinithis: look at inits
11:04:28 <Cale> Trinithis: Perhaps you mean dropWhile f . tails ?
11:04:32 <Saizan> if you use cartesian product for endofuctors you get applicatives?
11:04:38 <Trinithis> ah yes
11:04:40 <Trinithis> thats what i want
11:05:09 <Stephan202> > tails [1..]
11:05:11 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
11:05:19 <Cale> Saizan: good question...
11:05:22 <Stephan202> > tails [1..4]
11:05:23 <lambdabot>   [[1,2,3,4],[2,3,4],[3,4],[4],[]]
11:06:02 <BMeph> > inits [1,2,3,4]
11:06:04 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4]]
11:06:28 <BMeph> Mmm...anamorphisms! :)
11:08:18 <thetallgu1> Is there a ghc option to get it to recognize the old flat module system?
11:08:48 <geezusfreeek> there's a new module system?
11:09:17 <BMeph> thetallgu1: Is that -lobotomize? ;)
11:09:17 <thetallgu1> by new I mean the hierarchical module system
11:09:35 <thetallgu1> BMeph: that would be an appropriate name...
11:10:03 <thetallgu1> There's an older library that I'm looking at using, but it uses the old style.
11:11:23 <BMeph> thetallgu1: Have you tried to just compile it anyway? There are "old-school" modules included (in GHC, at least).. :)
11:11:51 <geezusfreeek> you mean modules are imported like they are specified in haskell98?
11:11:57 <thetallgu1> yes
11:11:59 <geezusfreeek> as far as i know ghc is haskell98 compatible by default, no?
11:12:00 <thetallgu1> and yes
11:12:02 <Cale> Saizan: It just looks like a lifted form of ordinary monoids.
11:12:03 <BMeph> thetallgu1: E.g., Monad, List, and such.
11:12:21 <thetallgu1> I had thought that, but it wasn't working.
11:12:28 <Cale> Something like Alternative without the Applicative axioms.
11:12:33 <thetallgu1> Perhaps something else is wrong
11:13:25 <thetallgu1> Oh, okay, it is something else.
11:14:34 <Saizan> Cale: ah, i see, the "result" has to be uniform with the operands
11:25:34 <thetallgu1> It was a lack of ghc --make flag.
11:26:17 <thetallgu1> On a related note, are hackage submissions required to use the hierarchical form?
11:26:26 <thetallgu1> Certianly seems preferable.
11:26:49 <thetallgu1> Not just for imports, but for modules provided by the library, I can't think of any way around that.
11:28:14 <Twey> I don't think it's required, since AFAIK Hackage isn't limited to just GHC
11:29:15 <eu-prleu-peupeu> hello Hppl
11:29:39 <Twey> Hey there ugo
11:29:44 <Twey> We seem to have stolen your H
11:29:45 <Twey> Sorry about that
11:29:50 <thetallgu1> Twey: good point.
11:30:03 <Twey> But hierarchical is definitely neater.
11:38:25 <Cale> I don't know if there's any Haskell implementation these days which doesn't support hierarchical modules.
11:39:06 <vixey> are there enough ideas for a language that isn't haskell?
11:39:08 <Saizan> even base is hierarchical, so..
11:40:57 <thetallgu1> Is there a generics chat room?
11:41:38 <gwern> you think there are so many people who want to discuss generics?
11:42:16 <thetallgu1> gwern: no, but perhaps they've been growing like mushrooms, quietly and out of sight?
11:42:42 <mercury^> vixey: how do you mean?
11:42:48 <gwern> thetallgu1: sunlight is the best disinfectant for that
11:43:09 <thetallgu1> gwern: or like caribou, social, large numbers, but off by themselves...
11:43:23 <gwern> thetallgu1: and tasty?
11:43:24 <BMeph> The light, it BURNS!
11:44:27 <thetallgu1> gwern: I think the generics workshop should put your name on a security list
11:44:51 <gwern> thetallgu1: I can't help it. my whole family is made of meat.
11:45:17 <thetallgu1> gwern: boneless?
11:45:18 * gwern also notes that this isn't my meatspace name, so they can ban gwern all they want
11:46:22 <gwern> thetallgu1: no, they come with shells and intestines I have to remove. they're a lot like shrimp.
11:46:25 <gwern> big shrimp
11:46:29 <ksf> @remember bucky Each lobe of a baseball is simply a precessed triangle of a tetrahedron. The baseball is yin-yang, not in a plane but in Universe: it is telling us that complementarities interprecess omnidirectionally and not just in a plane, as the planar yin-yang suggests.
11:46:29 <lambdabot> It is stored.
11:46:31 <ksf> scnr.
11:46:49 <glguy>  diff <(git show master:Setup.hs) <(git show origin/master:cdrss-db-backend.cabal)
11:46:55 <glguy> err
11:47:11 <gwern> @quote lobe
11:47:11 <lambdabot> bucky says: Each lobe of a baseball is simply a precessed triangle of a tetrahedron. The baseball is yin-yang, not in a plane but in Universe: it is telling us that complementarities interprecess
11:47:11 <lambdabot> omnidirectionally and not just in a plane, as the planar yin-yang suggests.
11:47:30 <gwern> bucky could be hard to understad, especially when he got onto geometry
11:47:54 <ksf> yeah.
11:48:24 <ksf> i'm scanning synergetics to find out whether or not he has anything to say about 4 tetrahedrons making up a cube or 6.
11:49:26 <gwern> how could 4 tetrahedrons make a cube?
11:49:56 <ksf> lining up d4's its suggestive, at least if you take skewing into account.
11:50:25 <jkramar> anyone know how to color a Geometry2 in reactive-fieldtrip? colors seem to be useful only to create materials, which only modify Geometry3s, but flatG::Geometry2->Geometry3 doesn't seem to solve the problem
11:50:35 <ksf> anyway, the tao symbol represents a third and fourth dimension by inclusion of one-into-the-other.
11:51:19 <sbahra> newsham == Timothy Newsham?
11:51:51 <ksf> I need squeezable d4 or a better imagination.
11:52:09 <jkramar> sorry, I didn't really mean reactive-fieldtrip, just fieldtrip.
11:52:19 <ksf> ...or I could try to cut one of those d6's.
11:52:46 <sbahra> Yes
11:53:00 <Cale> jkramar: Can't you apply a colour to the resulting Geometry3?
11:53:03 <ehird> I've forgotten, how do data and newtype diffe?
11:53:05 <ehird> differ
11:53:24 <jkramar> wait, 4 tetrahedrons whose union is a cube? doesn't sound nice
11:53:28 <gwern> newtype takes constructors with one argument
11:53:32 <gwern> and gets compiled away
11:53:38 <gwern> data doesn't, and takes more. iirc
11:53:46 <sbahra> ehird, newtype incurs no compile-time overhead.
11:53:49 <sbahra> gwern, it can take 1.
11:53:53 <vixey> does GHC promise that?
11:53:57 <sbahra> But you can have multiple constructors.
11:54:00 <ehird> ah yes, only one argument
11:54:01 <sbahra> err
11:54:07 <sbahra> vixey, I meant, run-time overhead.
11:55:48 <ksf> well i know that 6 work, but i can't get 4 out of my head.
11:56:59 <newsham> sbahra: yes
11:57:12 <eu-prleu-peupeu> http://www.ddj.com/development-tools/212201710;jsessionid=Z2EE14U5SJ5HMQSNDLOSKH0CJUNN2JVN?pgno=2
11:57:12 <eu-prleu-peupeu> ehhh
11:57:17 <lambdabot> Title: Dr. Dobb's | It's Time to Get Good at Functional Programming | December 3, 2008, http://tinyurl.com/6cqjqe
11:57:23 <eu-prleu-peupeu> how can someone write this on 2008 ? :/
11:57:28 <eu-prleu-peupeu> about haskell, i mean
11:57:42 <gwern> eu-prleu-peupeu: it's Dr. Dobb's. they go into orgasms over java and c++
11:58:49 <gwern> we should be happy they didn't say something like 'an interesting research language, but no industrial-strength implementations'
11:59:12 <eu-prleu-peupeu> "It presently has no commercial implementations."
11:59:13 <gwern> although that comment about commercial implementations comes close... did I mentioned dr. dobbs is institutionally biased in favor of commercial stuff?
11:59:18 <naradapuri> \h set color
11:59:25 <eu-prleu-peupeu> i see :/
11:59:28 <eu-prleu-peupeu> closed minds
11:59:56 <gwern> actually, I wouldn't've been surprised at a comment like 'Haskell has weak support for Microsoft Windows, and so is useless' :)
12:00:10 <ksf> @remember bucky Energy is finite. Physical Universe is finite. Physical Universe is just as finite as the triangle of 180 degrees.
12:00:10 <lambdabot> I will never forget.
12:00:31 <erikc> is there a monad that is the inverse of the maybe monad (returns the first Just value)
12:00:31 <eu-prleu-peupeu> i follow the feed on multicoreinfo.com
12:00:42 <centrinia> Is the universe really finite?
12:00:42 <eu-prleu-peupeu> no haskell articles ever appear, and when one does, it comes out like this :/
12:00:52 <vixey> I don't think that's possible erikc
12:00:57 <vixey> wouldn't that be a type error
12:01:01 <gwern> centrinia: well, infinite universes involve you in problems
12:01:03 <vixey> :t (>>=)
12:01:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:01:20 <gwern> ie. how do we see a dark night sky if the universe is infinite?
12:01:22 <vixey> There's the Either a Monad.. which always returns the first  Left A if there was one
12:01:53 <gwern> and let's not even get into issues like 'how is science (and induction in general) even possible in an infinite universe?'
12:01:56 <vixey> gwern, light gets sucked round corners
12:02:20 <Saizan> erikc: there's the First monoid
12:02:30 <centrinia> It takes longer for very distant light to come here. :)
12:02:52 <gwern> centrinia: but the light has had all eternity to get here
12:03:43 <vixey> @hoogle First
12:03:44 <lambdabot> Data.Monoid newtype First a
12:03:44 <lambdabot> Data.Monoid First :: Maybe a -> First a
12:03:44 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
12:04:13 <lament> gwern: why eternity?
12:04:26 <lament> gwern: or does the universe have to be infinite in time as well as space?
12:04:34 <gwern> lament: you want to suggest an infinite universe was created a finite time ago?
12:04:39 <lament> gwern: sure
12:04:44 <lament> poof, just like that
12:04:51 <lament> six thousand years aog
12:04:54 <lament> ago
12:04:57 <centrinia> This isn't correct: "Monads are one such trick: Impure functions that have side effects and that can call pure FP functions but can't be called by them."
12:05:22 <lament> it's a good layman description of the most salient thing about monads
12:05:52 <gwern> lament: in a sense, space and time are interchangeable, so if you have infinite time, you might as well have infinite space and vice versa
12:06:11 <Saizan> except "side effects" means something different for every monad
12:06:18 <gwern> but the real killer for infinite spatial universes is the quantum foam
12:06:19 <lament> gwern: not if we assume an infinite universe that was created finitely long ago, then they're not
12:06:37 <sbahra> eu-prleu-peupeu, yeah :-/
12:06:39 <sbahra> eu-prleu-peupeu, "You want a pure (not hybrid) FP experience and you aren't expecting to get productive work out of the exploration. Is there a best language for simply learning functional programming? A good case can be made for Haskell."
12:06:42 <pizza_> depends on your definition of infinity
12:06:42 <sbahra> eu-prleu-peupeu, hehe
12:06:58 <vixey> infinity = 12
12:07:02 <gwern> since there's a non-zero change of the quantum foam spontaneously created a complex structure, in an infinite universe, there will be an infinite number of any given complex structure. this includes your brain.
12:07:12 <Corun> 13 = 12
12:07:24 <vixey> "this is your brain on quantum theory"
12:08:37 <gwern> and of course, as each brain dies horribly, it will observe different things from our earth-bound brains; given that we have no way to distinguish our earth-bound brains with a history from the infinitely many space-brains, we should logically expect each moment to begin hallucinating as we die; science should be impossible
12:08:56 <BMeph> gwern, lament: I thought space and time were inversely interchangeable? ;)
12:09:27 <gwern> BMeph: well, you get this anti-result regardless of whether you assume infinite time and finite space, or infinite space and finite time
12:09:33 <ksf> dammit. now i got an algebraic proof in my head but still no visuals.
12:10:12 <geezusfreeek> my latest shell alias: alias :wq='exit'
12:10:43 <gwern> BMeph: since in one, you have an infinite number of brains produced in a short time period, and in the other you have one small region producing an infinite number of brains over all eternity; the same result obtains - an infinite number of versions of you dying horribly
12:10:45 <geezusfreeek> i did it enough by accident already
12:10:49 <mauke> I never use :wq
12:10:56 <mauke> it's always :q, :x or :xa
12:11:20 <centrinia> Why is gwern being so morbid? :)
12:11:23 <geezusfreeek> heh
12:11:25 <pizza_> :x being a more optimized version of :w?
12:11:53 <gwern> centrinia: infinite time is a morbid topic. look up Nietzsche's Eternal Recurrence for a good time
12:12:03 <centrinia> Okay.
12:12:09 <ksf> :x is wq iirc.
12:13:15 <ksf> @quote energy is finite
12:13:16 <lambdabot> No quotes for this person. :(
12:13:21 <ksf> @quote bucky
12:13:21 <lambdabot> bucky says: Energy is finite. Physical Universe is finite. Physical Universe is just as finite as the triangle of 180 degrees.
12:13:25 <ksf> see?
12:13:33 <ksf> there's no infinity in the universe.
12:13:59 <erikc> First works perfectly
12:14:04 <erikc> getFirst $ mconcat $ map (First . (!?) (infoAttrs di)) [kDW_AT_name, kDW_AT_specification]
12:14:05 <jkramar> ksf: what are you proving?
12:14:06 <erikc> hottt
12:14:17 <ksf> that time is finite, but unending.
12:14:31 <ksf> but then, you might look up _that_ bucky quote for yourselves.
12:14:37 <vixey> getFirst $ mconcat $ map (First . f) ... ?
12:14:41 <jkramar> what does that even mean?
12:14:50 <vixey> can this be be similar to f . head ?
12:14:54 <vixey> @src First
12:14:54 <lambdabot> Source not found. I've seen penguins that can type better than that.
12:14:57 <vixey> :t First
12:14:59 <lambdabot> forall a. Maybe a -> First a
12:15:15 <vixey> ok I guess you need filter too, or listToMaybe
12:15:36 <erikc> vixey: the issue is i have a property bag which is Map Int Dynamic, and a variety of properties can correspond to the "name"
12:15:39 <ksf> in his view, the universe is the only existing perpetuum mobile, the only perfect equilibrium and some kind of y combinator.
12:15:42 <erikc> in a preferred order
12:15:56 <centrinia> @faq Can Haskell compute every possible state of an infinite universe?
12:15:56 <lambdabot> The answer is: Yes! Haskell can do that.
12:15:59 <vixey> ksf, time cube ...
12:16:16 <erikc> (not my design, just how the DWARF file format is implemented)
12:16:27 <wchogg> I think I've come in on the tail end of a rather odd meta-physics discussion.
12:17:23 <gwern> wchogg: infinite universes make for very interesting discussions on identity and knowledge
12:17:49 <centrinia> Wow, ontology and epistemology.
12:18:51 <ksf> the problem with bucky is that most of the time you can't tell whether or not he's insane or you don't get his genie.
12:19:41 <wchogg> gwern:  I don't quite get the point.  It seems like you're using terms like quantum foam a bit loosely.
12:20:52 <centrinia> ksf: That is true of any genius/whacko. :)
12:21:02 <gwern> wchogg: no, I think it's a valid use
12:22:51 <blueonyx> ahoi
12:23:02 <wchogg> gwern:  I think I'm not being very clear, sorry.  I meant that it wasn't clear above what you mean mathematically by quantum foam.
12:24:44 <ksf> @remember bucky The invention of the game of limited and terminal local awareness that we call "life" is in contradistinction to the concept of eternally total cosmic knowledge, intellect, and wisdom, whose totality of comprehensive comprehension would answeringly cancel out all questions and all problems, which would result in the eternally timeless, sublime 0=0 equation of absolute perfection.
12:24:44 <lambdabot> It is stored.
12:25:14 <gwern> wchogg: ok. the key assumption is that there is a non-zero possibility, at every time and at every point that something will be randomly created. we can go by volume, and say the 'something' is some aggregation of atoms; if we calculate out the unlikelihood of all the atoms in air clumping together to form me, we find that it is incredibly close to zero - but not zero. and thus, anything non-zero times infinity is infinity...
12:26:01 <ksf> gwern, you're not taking information into account.
12:26:03 <wchogg> gwern:  but things aren't just 'created' out of the vaccum.  Any particles are off mass shell and are thus virtual.
12:26:25 <ksf> it's got a gravity all of its own, see terry pratchett.
12:26:56 <gwern> wchogg: alright. then would you prefer we toss in another restriction, we only consider space around blackholes so we are working off hawking radiation? <begins the line of reasoning again>
12:27:33 <gwern> (you can toss in as many restrictions as you like; as long as the chance is still nonzero, we're in business)
12:28:10 <ksf> You cannot limit your analysis to any subpart of the general mishmash and still make sense.
12:28:12 <ksf> it won't work.
12:28:41 <FunctorSalad> :)
12:29:51 <centrinia> Don't you have to assume the Axiom of Choice to assert that any configuration of an infinite number of random events with nonzero probability will have a nonzero probability?
12:30:52 <gwern> centrinia: I'm not sure. I've thought it out and it seems that there are only so many distinct arrangements of matter because of planck and hubble limits
12:31:02 <geezusfreeek> centrinia, that doesn't sound right to me. even a single one of those events has nonzero probability. i don't have to even assume infinite
12:32:50 <ksf> Thou hast no Right but to do thy Will
12:33:10 * gwern goes and reads about the [[PoincarÃ© recurrence theorem]]
12:33:34 <gwern> ('The Recurrence theorem apparently contradicts the Second law of thermodynamics, which says that large dynamical systems evolve irreversibly towards the state with higher entropy, so that if one starts with a low-entropy state, the system will never return to it.')
12:34:14 <gwern> not quite applicable to our discussion, but interesting in a context of the Eternal Recurrence
12:34:15 <centrinia> Didn't someone refuse a Field's medal for proving that theorem?
12:34:26 <wchogg> No, that's something else.
12:34:40 <gwern> centrinia: no, I think that was Poinare's conjecture, not the theorem
12:34:50 <gwern> if it doesn't have a proof, it's not much of a theorem :)
12:35:13 <Cale_> Which theorem?
12:35:44 <gwern> Cale: you'll never know! bwa ha ha
12:36:07 <Cale> I suppose I could go look at the logs :)
12:36:09 <FunctorSalad> maybe you need AC to even show the existence of a measure on teh infinite product space
12:36:14 * FunctorSalad is not teh sure
12:36:40 <Cale> On Hilbert's cube?
12:36:41 <FunctorSalad> no wait, I think that was for showing existence of non-measurable sets
12:37:10 <FunctorSalad> Cale: just a sequence of independent variables here, I'd think
12:37:42 <FunctorSalad> (I was replying to what centrinia asked earlier)
12:38:01 <centrinia> If the cross product of nonempty sets is nonempty, then the Axiom of Choice is true. :)
12:38:24 <centrinia> *cartesian product.
12:38:51 <Cale> And not just a finite Cartesian product, but an arbitrary one :)
12:39:27 <FunctorSalad> you don't need AC for making an element of {0,1}^Integers or so ;)
12:40:10 <centrinia> What about the cartesian product of {0,1} indexed by reals?
12:40:25 <FunctorSalad> but for showing that not every set is measurable in the "product" sigma algebra or how it's called
12:40:36 <Cale> That's easy too.
12:40:52 <centrinia> What about indexing over the power set of the reals?
12:41:24 <Cale> You only really need the axiom of choice when there isn't a rule which you can use to specify an element.
12:41:47 <centrinia> Oh, so indexing over the set of all sets that are not members of themselves would be a problem?
12:41:56 <FunctorSalad> centrinia: "you don't need AC to choose a shoe from each pair of infinitely many pairs of shoes, but for pairs of socks you do" :)
12:42:00 <Cale> That's not a set.
12:42:30 <Cale> Right, for the shoes, you can just say always pick the left one.
12:43:09 <centrinia> I don't need to invoke the Axiom of Choice when I can index over any set?
12:43:27 <Cale> I'm not sure what you mean by that...
12:43:30 <ksf> you can't choose without having a rule, the axiom of choice just conjures one up. it's paradoxical in itself.
12:43:43 <Cale> The axiom of choice isn't really paradoxical.
12:44:14 <vixey> choice is usually provable in specific case
12:44:15 <Cale> I'm pretty sure it's been shown that the consistency of ZFC is equivalent to the consistency of ZF.
12:44:19 <ksf> you can't even choose the axiom of choice from the set of all axioms without having a rule.
12:44:40 <Cale> So it's not really a problem.
12:44:52 <Cale> I like global well-ordering :)
12:44:59 <centrinia> Is the ZF axioms consistent?
12:45:01 * BMeph boggles
12:45:19 <BMeph> There's an official website for Robert Picardo?!?
12:45:26 <Cale> centrinia: We hope that ZF can't prove its own consistency.
12:45:35 <Cale> centrinia: Because if it can, then it's inconsistent.
12:45:38 <eu-prleu-peupeu> it would be nice to have a monad "goto" operator :D
12:45:40 <eu-prleu-peupeu> in haskell
12:45:50 <arw> buah.
12:45:52 <eu-prleu-peupeu> just to say that haskell has gotos
12:45:53 <Cale> eu-prleu-peupeu: Continuation monads can do that.
12:45:54 * gwern sics the raptors on eu-prleu-peupeu 
12:45:57 <centrinia> eu-prleu-peupeu: Try the mdo construction.
12:46:52 <Cale> centrinia: So if you want to prove that ZF is consistent, you need to use another system to examine it, the consistency of which is going to be just as hard to verify.
12:47:08 <centrinia> Too bad Haskell doesn't allow self-modifying code.
12:47:32 <centrinia> Cale, what if I find another system to verify the system that was used to verify ZF?
12:48:08 <FunctorSalad> centrinia: the problem is if your cartesian product isn't in the form A^B
12:48:11 <Cale> centrinia: Well, you can do that as well. But there's no way to know that the outermost system is consistent.
12:48:26 <FunctorSalad> centrinia: a general cartesian product is of the form product{i in I} A_i
12:49:16 <centrinia> What if I = \product_{i \in I} A_i ?
12:50:11 <Cale> centrinia: er...
12:50:19 <centrinia> Cale?
12:50:27 <FunctorSalad> that's unpossible if |A_i| >= 2 for all i ;)
12:53:59 <Trinithis> For some reason, when I use getLine and use backspace, the backspace doesn't work properly. Instead it prints backspace characters. How would I fix this?
12:54:33 <Badger> IIRC, getLine doesn't do non-letters
12:55:01 * Badger shoots Corun.
12:55:05 <FunctorSalad> Trinithis: I don't really know, maybe it is something about your ghc being compiled without editline?
12:55:06 <Corun> Aargh!
12:55:10 <Cale> Trinithis: line buffering is off?
12:55:19 <Trinithis> i turned of buffering
12:55:25 <Badger> orite
12:55:30 * FunctorSalad still gets annoying ^J's in emacs ghci :(
12:55:35 * Badger irrelevant
12:55:52 <Cale> Trinithis: stdin must be line buffered for backspace to work
12:55:54 <FunctorSalad> (since 6.10)
12:56:05 <Trinithis> oh
12:56:11 <Trinithis> works now... thakns
12:57:42 * Nafai is excited for the RWH book club
12:57:50 <Nafai> But I suppose I should order the dead-trees version :)
12:58:04 <FunctorSalad> book club?
12:58:21 <Axman6> http://groups.google.com/group/real-world-haskell-book-club
12:58:22 <lambdabot> Title: Real World Haskell Book Club | Google Groups
12:58:26 <idnar> the first rule of book club is, you do not talk about book club
12:58:36 <Nafai> idnar: Dang it, I always forget that rule
12:58:59 <wchogg> Hah...turns out that all three authors are actually the same person, trying to start an anarchistic cult.
12:59:38 <gwern> wchogg: that's absurd. I've seen two of them here at the same time chatting
13:00:12 <pizza_> lol
13:00:47 <Axman6> gwern: or have you
13:00:48 <ksf> so you're basically saying that forall a. exists a -> b | obj (a) >= obj (b). which might work well if you want to convince yourself of your own ability to construct such a function, but won't help you if you're writing a compiler.
13:00:50 <FunctorSalad> gwern: pre-scripted.
13:01:13 <ksf> you're freely crossing the borders between potential and concrete foos without even typing them.
13:01:14 <gwern> FunctorSalad: no - it couldn't be! it was one person controlling them both?
13:01:39 <Axman6> gwern: it's too late for you, i'm sorry
13:03:00 <ksf> furthermore, if a is uncomputable, how can you _ever_ be sure that a -> b isn't just const $ any obj(b)?
13:03:44 <Cale> ksf: What is this in reply to?
13:04:01 <ksf> all that axiom of choice talk.
13:04:18 <Cale> I'm not sure I understand what you mean by forall a. exists a -> b | obj (a) >= obj (b)
13:04:26 <vixey> @remember <ksf> you're freely crossing the borders between potential and concrete foos without even typing them.
13:04:27 <lambdabot> Nice!
13:04:27 <vixey> hahaha
13:05:31 <ksf> Cale, just replace it with your favourite definition of the axiom of choice.
13:05:42 <FunctorSalad> ksf: I don't get that syntax either
13:05:44 <ksf> in fact, i couldn't make the > round as i wanted to.
13:05:53 <lament> )
13:06:00 <FunctorSalad> lol
13:06:02 <Cale> What's the | ?
13:06:10 <Cale> also, b is free.
13:06:18 <ksf> where
13:06:22 <FunctorSalad> lament is our resident round-brackets peddler
13:06:26 <mauke> it's a freebie
13:06:37 <idnar> the first b is free, the next one will cost you
13:06:52 <lament> open brackets are free
13:06:54 <vixey> (âx : A.ây : B.R(x, y)) â âf : A â B.âx : A.R(x, f x)
13:07:02 <ksf> yeah, should be forall a b.
13:08:13 <Cale> So you have  forall a b. exists a -> b -- you mean there exists a function from a to b?
13:08:16 <tehgeekmeister> how do i read a file into a bytestring nonstrictly?
13:08:30 <ksf> forall a b | obj a )= obj b. exists a -> b
13:08:33 <vixey> which reads,  for any relation R that is surjective, there is a functional version of R
13:08:45 <Cale> What's obj?
13:08:48 <vixey> ? sort of, I am sort of abusing the term 'surjective'
13:09:39 <ksf> obj (foo) are the thingies in a category.
13:09:41 <vixey> (that's the form of typed axiom of choice I've seen)
13:09:55 <ksf> as opposed to the pointy thingies that connect them.
13:10:08 <tehgeekmeister> oh; maybe i should use Data.ByteString.Lazy instead of Data.ByteString...
13:10:24 * kowey wonders if there is any news on hac5
13:10:36 <Cale> Here's my favourite axiom of choice (of today): If f: A -> B is surjective, that is, for every b in B, there is some a in A for which f(a) = b, then there exists g: B -> A such that f . g = id.
13:10:42 <FunctorSalad> the functional version would be forall f. f surjective -> exists g: f . g = id
13:10:52 <FunctorSalad> ^^
13:10:53 <Cale> Heh.
13:11:04 <ksf> couldn't think of a better way to say "the data constructors of a resp. b, instantiated"
13:11:16 <Cale> ksf: This is set theory, there are no data constructors.
13:11:24 <vixey> wow
13:11:36 <vixey> Cale FunctorSalad .. you didn't set that up beforehand? :p
13:11:41 <ksf> I don't like set theory.
13:11:41 <Cale> vixey: no
13:12:03 <FunctorSalad> vixey: it would even have been synchronous if I didn't have to ponder "f.g or g.f" so long
13:12:19 <vixey> f.g g;f
13:12:35 <Cale> "Every surjective function has a right inverse." to put it elegantly :)
13:12:44 <vixey> is that really choice though?
13:12:47 <Cale> Yes.
13:12:49 <FunctorSalad> yeah
13:12:53 <vixey> the one I pasted took a relation in account
13:13:03 <vixey> but if you use a function.. does it have the same strength?
13:13:03 <FunctorSalad> you can make a function from a relation
13:13:11 <Cale> The right inverse selects one element of every fiber (which is nonempty because it's surjective)
13:13:14 <ksf> that distaste is basically rooted in the fact that i grokked lambda calculus years before i got my first taste of discrete mathematics.
13:13:32 <FunctorSalad> A x B ~ A -> Powerset(B)
13:13:38 <ksf> as in "lambdas are just a fun way to write programs"
13:13:39 <Cale> Lambda calculus functions aren't really functions though.
13:14:01 <vixey> huhh?
13:14:07 <ksf> scheme functions even less.
13:14:09 <vixey> how are they not
13:14:20 <vixey> FunctorSalad, ahh yeah i see
13:15:03 <Cale> vixey: Well, typed lambda calculus functions can be given real corresponding functions.
13:15:06 <vixey> it is because of non terminations?
13:15:58 <Saizan_> also, in LC you can define only computable functions
13:16:35 <tromp> that's the very definition of computable function:)
13:16:39 <Cale> that too :)
13:16:48 <FunctorSalad> vixey: hmm though it doesn't look like what I just said is the way to prove relational AC from the functional
13:18:31 <Cale> To prove the relational AC from the functional one, just take the projection map (which is surjective given the conditions), and find its right inverse.
13:18:50 <FunctorSalad> oh, right
13:19:37 <FunctorSalad> also I should have written P(A x B) ~ A -> P(B)
13:19:45 <FunctorSalad> (the left P wasn't there)
13:22:14 <Cale> Another rather interesting form of AC is the property that for any two sets, either there is an injective map A -> B or an injective map B -> A. That is, cardinalities are comparable.
13:22:40 <Cale> So without AC, you end up with sets that are "differently shaped", neither one fitting into the other.
13:24:16 <Cale> (you can restate that with surjective as well)
13:24:48 <tehgeekmeister> how do i ask lambdabot things again?
13:25:34 <Cale> > 2^2000
13:25:36 <lambdabot>   114813069527425452423283320117768198402231770208869520047764273682576626139...
13:25:48 <Cale> @where lyah
13:25:49 <lambdabot> www.learnyouahaskell.com
13:26:03 <tehgeekmeister> > :i >>=
13:26:04 <lambdabot>   <no location info>: parse error on input `:'
13:26:17 <Cale> It has no equivalent of ghci's :info
13:26:21 <tehgeekmeister> okay
13:26:47 <tehgeekmeister> i really shouldn't have neglected haskell for so long, i'm forgetting the simplest things
13:26:55 <Cale> :t (>>=)
13:26:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:27:02 <Cale> You can ask it for types though.
13:27:22 <byorgey> welcome back, tehgeekmeister =)
13:27:29 <tehgeekmeister> i needed fixity info, but i already opened ghci and got it, i was just hoping lambdabot would be quicker
13:27:40 <tehgeekmeister> byorgey: thanks!
13:27:57 <Cale> It's a good idea to keep a ghci window running alongside your texteditor.
13:29:09 <vixey> Does anyone read that PEG paper? About the parser?
13:29:35 <vixey> I still didn't understand this part, It's not clear if this relation is computable or not
13:29:55 <zachk> i tried hugs first, and didnt try haskell for another 2 years because i didnt like it. I tried ghc/ghci and boy did i fall in  love with those zen koan like error messages
13:30:12 <tehgeekmeister> Cale: used to do that, lost all my terminal setup and such when my system crashed recently, so screen doesn't autostart the way it used to anymore.  gotta go reconfigure it soon now that i'm programming again.
13:30:25 <gwern> hee hee. 'I'm not a techy...(remember, I worked in development at Apple Computer too.)' http://www.rebol.com/article/0381.html
13:30:30 <lambdabot> Title: Productivity. As simple as that.
13:30:35 <gwern> I wonder sometimes whether people even read what they write
13:32:29 <guenni> I have a sequence of IO actions (DB-Queries) the first of which is very expensive (takes about 11 secs) and need to use them repeatedly. Is it possible to have the 1st one run only once, and have the rest run with the results of the 1st whenever called?
13:34:32 <intrados> how do you remove a package that has been installed with cabal?
13:35:05 <gwern> intrados: you don't, really. you hide it or otherwise renmove it from the package database
13:36:33 <byorgey> guenni: sure.  are you having trouble making it work?
13:36:42 <byorgey> it doesn't sound that hard on the face of it.
13:37:08 <FunctorSalad> intrados: ghc-pkg unregister somepackage (that won't remove it from the HD though)
13:37:41 <guenni> byorgey: yep, I sure do
13:37:49 <intrados> there's no good way to remove it from the hard drive though without just individually rming things?
13:38:20 <gwern> no more than for make; once you make install, what do you do to remnove it?
13:38:35 <guenni> byorgey: If it wasn't some moand stuff I could kinda use closures or something
13:38:56 <gwern> what about binding the first item with 'let'?
13:39:07 <byorgey> guenni: for example, you could do something like this:
13:39:12 <guenni> byorgey: but right now I don't even know undere which subject to look that up
13:39:39 <guenni> byorgey: monad transformers, state monad, just not sure
13:39:49 <byorgey> x <- reallyExpensiveThing; let actions = [f x, g x, h x, ...]; other code which repeatedly selects actions to run...
13:39:58 <byorgey> guenni: I don't think you should need either of those
13:40:39 <tehgeekmeister> any recommendations of an excellent parallel haskell tutorial?  all i want is two threads running at the same time, nothing fancy.
13:40:50 <byorgey> guenni: does the code above look like it's something along the lines of what you want?  or am I misunderstanding your problem?
13:40:58 <Cale> tehgeekmeister: Are the threads computing something pure?
13:41:01 <guenni> it might
13:41:10 <tehgeekmeister> Cale: no, both doing IO
13:41:33 <Cale> tehgeekmeister: Okay, so you're looking for concurrency. :)  Control.Concurrent has most of the useful stuff.
13:41:38 <byorgey> guenni: the basic idea is to bind the result of the expensive computation to a name, then use that name everywhere the result is needed.
13:41:46 <Cale> tehgeekmeister: forkIO :: IO a -> IO ThreadId
13:41:48 <byorgey> then it will only be computed once.
13:41:49 <Cale> :t forkIO
13:41:51 <lambdabot> Not in scope: `forkIO'
13:41:57 <Cale> :t Control.Concurrent.forkIO
13:41:58 <lambdabot> IO () -> IO GHC.Conc.ThreadId
13:42:02 <guenni> byorgey: I'll try it right away
13:42:04 <Cale> ah, IO (), my mistake :)
13:42:06 <byorgey> guenni: note this is a general technique that applies to anything, not just monads =)
13:42:47 <aconbere> I'm not finding very good articles on importing functions from your own files, do you just define your own module declartions (I found one article that discussed that)
13:42:51 <Cale> tehgeekmeister: Executing the IO action  forkIO x  will cause a new thread to be created in which the IO action x is run.
13:43:00 <guenni> byorgey: well I had hoped to be returned a function that I then can call repeatedly
13:43:25 <Cale> aconbere: And you should name the files the same as the module name in the declaration, so that GHC can find the modules automatically.
13:43:29 <ksf> ok, let's try out non-constructive mathematics.
13:43:31 <byorgey> guenni: I'm not sure what you mean.  you mean the expensive IO computation computes a function?
13:43:34 <aconbere> Cale: awesome
13:43:40 <ksf> > there exists the program i wanna write
13:43:41 <lambdabot>   Not in scope: `there'Not in scope: `exists'Not in scope: `the'Not in scope:...
13:44:00 <ksf> Q.E.D.
13:44:05 <vixey> and constructive math,
13:44:11 <tehgeekmeister> Cale: and is there a way to communicate from one thread to another?  i'm going to be parsing an xml file with hexpat in one thread, and sending the parsed data to another thread to be added to the db, because as far as I can figure right now that's the easiest way, so i need to be able to communicate from thread to thread.
13:44:21 <guenni> no, it delivers a result which I can then use for other IO stuff
13:44:29 <vixey> ?
13:44:46 <byorgey> guenni: ok, so I'm not sure what you mean by saying you hoped to get a function that you can call repeatedly
13:44:47 <ksf> well, actually, I got no idea what i wanna write.
13:44:49 <byorgey> can you give an example?
13:44:50 <Cale> tehgeekmeister: There are a number of ways. MVar and Chan are probably the simplest to start with.
13:45:08 <tehgeekmeister> Cale: okay, thanks, i'll look into that.  =]
13:45:15 <Cale> tehgeekmeister: For designing more complex abstractions, STM can help a great deal.
13:45:26 <Cale> Let's start with MVars
13:45:43 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-MVar.html
13:45:44 <lambdabot> Title: Control.Concurrent.MVar, http://tinyurl.com/2ykhtj
13:45:48 <ksf> > there exists no idea of a program i want to write
13:45:49 <lambdabot>   <no location info>: parse error on input `of'
13:46:05 <guenni> byorgey: well the 1st expensive function is one that delivers a result that I need to feed the other functions with, but it needs to run only once
13:46:07 <ksf> see? lambdabot correctly tells me that it isn't a program.
13:46:09 <Cale> An (MVar t) is a mutable cell which either holds a value of type t, or is empty.
13:46:10 <roconnor> @bab nl en inhoudingsplichtige
13:46:12 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
13:46:15 <roconnor> damn
13:46:34 <Cale> Putting something in a full MVar, or taking something from an empty MVar will cause your thread to block.
13:46:48 <byorgey> guenni: right
13:46:50 <Cale> (and wait for it to become empty/full respectively)
13:47:00 <tehgeekmeister> okay
13:47:04 <roconnor> Anyone from .nl?
13:47:06 <guenni> byorgey: but the other functions I wish to be able to call arbitarily often
13:47:27 <Cale> There's also Chan: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-Chan.html
13:47:28 <lambdabot> Title: Control.Concurrent.Chan, http://tinyurl.com/3953km
13:47:41 <guenni> without having to run the whole sequence that would include the 1st one
13:47:48 <byorgey> guenni: right, so these other functions will take several inputs, right?  one of the inputs will be the result from the first computation, and the others might be different each time?
13:48:28 <tehgeekmeister> Cale: and the main difference there seems to be that you can write theoretically unlimited values into a chan without it blocking until the other thread empties the chan?
13:48:32 <guenni> byorgey: their inputs will always the same, but their outputs will differ
13:48:36 <Cale> right.
13:48:52 <byorgey> guenni: oh, because they aren't actually functions, but IO computations?
13:48:53 <vixey> ksf, you should try to come up with a more motivating example
13:48:55 <tehgeekmeister> cool, that's just what i want.
13:49:01 <Cale> You can write as much as you want into a Chan and it will never block. Reading from an empty Chan will block though.
13:49:14 <guenni> byorgey: yes, sry
13:49:21 <tehgeekmeister> good, that's exactly what i want.
13:49:25 <Cale> You should be careful, however, it's easy to write programs which consume lots of memory with Chans.
13:49:27 <guenni> byorgey: db queries
13:49:48 <byorgey> guenni: ok, so you have something like  reallyExpensiveComputation :: IO Result
13:50:00 <byorgey> and some other things like  someOtherComputation :: Result -> IO Foo
13:50:10 <byorgey> right?
13:50:18 <guenni> byorgey: yep
13:51:09 <byorgey> guenni: ok, well, there's no problem then.  If you say  do { result <- reallyExpensiveComputation; let f = someOtherComputation result; ... }
13:51:09 <guenni> I managed to isolate the expensive computation from the less expensive one on the database side
13:51:10 <ksf> > SELECT fittest FROM permutations
13:51:11 <lambdabot>   Not in scope: data constructor `SELECT'Not in scope: `fittest'Not in scope:...
13:51:14 <Cale> tehgeekmeister: I should also point out a handy idiom: if you want to control the permissions of threads with respect to Chans and MVars, it's convenient to partially apply things like writeChan and readChan to the channel, and pass the resulting function/action to the thread which is doing the reading/writing.
13:51:18 <byorgey> guenni: then you can use 'f' as many times as you want in the ...
13:51:25 <byorgey> and reallyExpensiveComputation will only be run once
13:51:44 <Axman6> with dupChan, do things ony get taken out once? or is there a 'copy' in each dup'd chan?
13:51:59 <tehgeekmeister> Cale: nice!
13:52:07 <byorgey> guenni: does that make sense?
13:52:15 <Axman6> actually, reading the docs does imply that there is copies (hence the broadcast bit)
13:52:22 <guenni> byorgey: I think you might be right, this could work, but if it does I will really be embarassed that I didn't figure that myself :)
13:52:36 <byorgey> guenni: hehe, no worries =)
13:52:43 <roconnor> ah inhoudingsplichtigen -> people-responsible-for-making-deductions-at-source
13:52:45 <byorgey> but I do think it's a lot simpler than you're making it out to be
13:53:04 <guenni> byorgey: from down under?
13:53:26 <byorgey> no, why?  oh, because I said 'no worries'?
13:53:29 <guenni> byorgey: and thanks
13:53:34 <guenni> byorgey: yes
13:53:36 <byorgey> you're welcome =)
13:53:51 <byorgey> hehe, I don't know where I picked that up
13:54:10 <byorgey> maybe from some aussies, who knows =)
13:54:22 * Axman6 is from down under
13:56:20 <byorgey> Axman6: do you say 'no worries'?
13:56:31 <Axman6> occasionally
13:57:33 <Badger> she'll be right
13:58:15 <ksf> > SELECT mostInteresting FROM map combine $ P(atoms knowledge)
13:58:16 <lambdabot>   Not in scope: data constructor `SELECT'Not in scope: `mostInteresting'Not i...
13:58:28 * BMeph says "no worries" many times, and gets funny looks. The funny looks probably aren't from /that/ saying, though... ;p
13:59:12 <vixey> > 10 PRINT "LOL" 20 GOTO 10
13:59:13 <lambdabot>   Not in scope: data constructor `PRINT'Not in scope: data constructor `GOTO'
13:59:30 <BMeph> roconnor: Gesundheit! ;)
13:59:35 <vixey> @IDENTIFICATION DIVISION
13:59:36 <lambdabot> Unknown command, try @list
13:59:58 <Badger> hahaha
14:00:05 <BMeph> vixey: You forgot the period. ;p
14:00:26 <Badger> > STOP RUN.
14:00:27 <lambdabot>   <no location info>: parse error on input `;'
14:02:13 <mm_freak> IMO there should be a List type, and the [] notation should be syntactic sugar for it
14:03:48 <BMeph> Hm, I have a dilemma: a VB-using fellow at work has given me twenty minutes and a soap-box to explain Haskell. I'm cribbing a lot of Meijer papers, but nothing stands out so far as a good start. Anyone have any ideas? :)
14:04:52 <Cale> BMeph: hmm. You might have a look at SPJ's intro video to get some ideas.
14:05:48 <athos> a taste of haskell?
14:05:52 <Cale> yeah
14:05:59 <athos> yeah, good one
14:06:01 <athos> :)
14:06:55 <aconbere> Cale: so I'm trying do define a module and import other functions and running into some issues
14:06:58 <aconbere> http://paste.pocoo.org/show/93763/
14:07:19 <aconbere> actually.. nevermind
14:07:22 <aconbere> just failing in a new way
14:07:23 <aconbere> :P
14:07:49 <Cale> er, okay
14:08:03 <aconbere> Cale: it just changed errors when compiling and I didn't realize :P
14:08:17 <athos> :t orderBy
14:08:18 <lambdabot> Not in scope: `orderBy'
14:09:06 <nn-main> hi all
14:12:03 <BMeph> athos, Cale: Sounds like a wise move - thank ye both! :)
14:13:21 <athos> BMeph: if you enjoy videos in general/need more input, just have a look at http://haskell.org/haskellwiki/Video_presentations
14:13:22 <lambdabot> Title: Video presentations - HaskellWiki
14:15:14 <byorgey> hi nn-main
14:15:17 <shepheb> athos: sortBy, btw.
14:15:41 <athos> :t sortBy
14:15:43 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
14:16:12 <athos> shepheb: thanks :)
14:19:20 <guenni> byorgey: works like a charm, thanks!
14:19:35 <byorgey> guenni: great! you're welcome.
14:20:24 <andypls1> hey i have a question
14:20:26 <andypls1> can anyone help me please?
14:20:40 <Corun> We have no idea if we can or not until you ask :-).
14:20:52 <andypls1> ok i call a function
14:21:00 <andypls1> and there is an infinite recursion
14:21:04 <andypls1> but i can't see why
14:21:13 <andypls1> i have my base cases set up correctly
14:21:17 <vixey> I think "call" is a misnomer by the way
14:21:19 <andypls1> is there a way to debug?
14:21:26 <hellige> please don't paste the code!
14:21:29 <Corun> http://hpaste.org
14:21:31 <hellige> our brains might loop... :(
14:21:38 * BMeph starts cribbing from the /other/ partner-in-crime
14:21:55 <BMeph> Don't just paste, hpaste(pat. pend.)! :)
14:22:02 <vixey> you might call a *procedure*
14:22:20 <andypls1> are you sure you want me to paste?
14:22:44 <byorgey> andypls1: sure, paste your code on hpaste.org and we can have a look
14:22:50 <andypls1> ok
14:23:58 <tehgeekmeister> Cale: how does a thread kill itself?
14:25:03 <andypls1> http://hpaste.org/12670
14:25:20 <andypls1> I call the function step
14:25:35 <andypls1> and there is a case where i get infinite recursion
14:25:45 <hellige> looks a lot like homework...
14:25:50 <tehgeekmeister> Cale: oops, nevermind, i figured it out.
14:25:52 <hellige> but maybe that's ok, in this case.
14:26:08 <Corun> Well, haskell's only used for homework ;-)
14:26:56 <andypls1> any idea about the recursion thing?
14:27:09 <byorgey> hellige: generally speaking, the policy is that *helping* with homework is just fine, when it's clear that the person has done some work (as andypls1 clearly has) and is having a specific problem
14:27:19 <hellige> makes sense
14:27:21 <byorgey> it's doing people's homework for them that we won't do =)
14:27:36 <byorgey> andypls1: I'm looking at it
14:27:40 <andypls1> thx
14:27:44 <hellige> it's hard to imagine a prof assigning this as "please debug this code..."
14:27:54 <byorgey> right =)
14:28:01 <andypls1> it's about lamda expressions
14:28:29 <andypls1> what step does is evaluate a lamda expression
14:28:37 <andypls1> it's doing just the first step
14:28:56 <andypls1> substs is doing the substitution when we want to evaluate an expression
14:29:17 <byorgey> andypls1: can you give a specific example of an expression that exhibits an infinite loop?
14:29:20 <hellige> can you give an example input where it loops?
14:29:28 <andypls1> and i want to see the stack trace when i run it... to see why the recursion doesn't sto[
14:29:32 <andypls1> yes
14:29:51 <byorgey> stack trace is hard, because the Haskell runtime doesn't use a traditional stack-based model
14:29:54 <byorgey> it uses graph reduction
14:30:14 <hellige> the last case of step is interesting: we usually don't look for redexes underneath a lambda. but it's probably not your problem.
14:30:15 <byorgey> there are tools to help you trace execution, such as hat
14:30:22 <andypls1> p :: Term; p = lam [ "x" ] (( lam ["a", "x"] a) # z)
14:30:25 <andypls1> this works
14:30:29 <andypls1> and gives:
14:30:30 <byorgey> hellige: it depends what reduction strategy you are using.
14:30:37 <vixey> andypls1, I found your problem
14:30:42 <andypls1> Lam "x" (Lam "x" (Var "z"))
14:30:46 <andypls1> ok go on
14:30:47 <vixey> andypls1, You're using strings to represent variables
14:31:01 <vixey> andypls1, This is the absolute most tremendously terrible thing you could have done
14:31:08 <gwern> ouch
14:31:12 <hellige> haha
14:31:14 <andypls1> ??
14:31:28 <byorgey> andypls1: ignore vixey.
14:31:30 <vixey> andypls1, heads or tails??
14:31:37 <hellige> byorgey: sure, that's why i said "usually"... :)
14:31:39 <vixey> byorgey, I'm actually right about this
14:31:46 <andypls1> ok the case that doesn't work:
14:31:55 <byorgey> vixey, is that what is causing andypls1's infinite recursion?
14:32:05 <andypls1> App (App (App (App (Lam "f" (App (Lam "x" (Var "f")) (App (Var "x") (Var "x")))) (App (Lam "x" (Var "f")) (App (Var "x") (Var "x")))) (Lam "f" (Lam "n" (Lam "m" (App (App (App (Lam "x" (Lam "y" (Lam "z" (App (App (Var "x") (Var "y")) (Var "z"))))) (App (Lam "x" (App (Var "x") (Lam "x" (Lam "y" (Var "x"))))) (Lam "x" (App (Lam "a" (Lam "z" (Var "a"))) (Var "z"))))) (Lam "z" (App (Lam "a" (Lam "z" (Var "a"))) (Var "z")))) (App (Lam "x"
14:32:05 <andypls1> (Lam "z" (App (App (Var "z") (Lam "x" (Lam "y" (Var "y")))) (Var "x")))) (App (App (Var "f") (App (Lam "x" (App (Var "x") (Lam "x" (Lam "y" (Var "y"))))) (Lam "x" (App (Lam "a" (Lam "z" (Var "a"))) (Var "z"))))) (Lam "z" (App (Lam "a" (Lam "z" (Var "a"))) (Var "z")))))))))) (Lam "z" (App (App (Var "z") (Lam "x" (Lam "y" (Var "y")))) (Lam "z" (App (App (Var "z") (Lam "x" (Lam "y" (Var "y")))) (Lam "z" (App (App (Var "z") (Lam "x" (Lam
14:32:05 <andypls1> "y" (Var "y")))) (Lam "x" (Var "x"))))))))) (Lam "z" (App (App (Var "z") (Lam "x" (Lam "y" (Var "y")))) (Lam "z" (App (App (Var "z") (Lam "x" (Lam "y" (Var "y")))) (Lam "z" (App (App (Var "z") (Lam "x" (Lam "y" (Var "y")))) (Lam "z" (App (App (Var "z") (Lam "x" (Lam "y" (Var "y")))) (Lam "z" (App (App (Var "z") (Lam "x" (Lam "y" (Var "y")))) (Lam "z" (App (App (Var "z") (Lam "x" (Lam "y" (Var "y")))) (Lam "z" (App (App (Var "z") (Lam
14:32:10 <andypls1> "x" (Lam "y" (Var "y")))) (Lam "z" (App (App (Var "z") (Lam "x" (Lam "y" (Var "y")))) (Lam "x" (Var "x"))))))))))))))))))
14:32:12 <vixey> byorgey, stuff like that ^
14:32:13 <oklopol> cool paste
14:32:16 <Corun> OH NOES.
14:32:20 <hellige> oh wow
14:32:23 <hydo> blort!
14:32:24 <vixey> byorgey, see how many strings there are ...
14:32:26 --- mode: ChanServ set -v andypls1
14:32:29 <vixey> there should be zero
14:32:54 <andypls1> ok
14:33:05 <vixey> andypls1, Do you really want to write single step evaluation?
14:33:10 <andypls1> # <- this is the operator , overloaded for the App thing
14:33:11 <vixey> andypls1, not big step normalization
14:33:18 <byorgey> vixey: I agree Strings are not a particularly nice way to represent names in an interpreter.  but if that isn't what is causing andypls1's problems with infinite recursion, I don't think it's particularly helpful at the moment.
14:33:25 <andypls1> i have another function for normalization, that uses step
14:33:37 <vixey> byorgey, it is definitely helpful
14:33:55 <andypls1> it's part of the specification to use those functions, and those data structures
14:34:16 <vixey> byorgey, I am not exaggerating one bit when I say "absolute most tremendously terrible thing"
14:34:38 <andypls1> is there something you don't understand in my code?
14:34:48 <vixey> andypls1, thing of the string rep as a static picture of the code -- you can transform it back and forth to reasonable representations easily
14:35:09 <andypls1> that is part of the spec
14:35:14 <andypls1> i can't change it
14:35:39 <vixey> andypls1, you can write a normalizer that turns the stringy version into a sensible rep and back
14:35:44 <byorgey> vixey: I know you are not exaggerating.  But from a pedagogical point of view it is not helpful.
14:36:12 <vixey> byorgey, I guess the difference is,  1) Getting ones homework done ASAP and  2) leaning how to program
14:36:21 <vixey> so if andy wants (1) then I will shut up
14:36:47 <byorgey> vixey: no, the difference is  1) starting out simple  and  2) trying to do too much at once.
14:36:58 <andypls1> guys let's not argue now
14:37:09 <byorgey> andypls1: so you are saying that if you call 'step' on that godawful looking multi-line thing above, it goes into an infinite loop?
14:37:12 <andypls1> my initial question was how to trace the recursion
14:37:19 <vixey> byorgey, I disagree, It's a thousand times harder to write programs that operate on alpha syntax than de bruijn or hoas
14:37:20 <andypls1> yes
14:37:55 <byorgey> andypls1: now, my question is, how do you know it is in an infinite loop, as opposed to just taking a Really Long Time?
14:38:09 <vixey> andypls1, here's some crap code that shows step evaluation http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=379
14:38:13 <vixey> roughly what you're trying ot write
14:38:19 <byorgey> vixey: having written all of the above, I am not disagreeing with you there.
14:38:38 <andypls1> because i waited for it too long to finish
14:38:47 <andypls1> it shouldn't take that long
14:39:06 <byorgey> andypls1: where did you get that big term?
14:39:40 <poliquin> Newbie question .. Are let pattern matches evil? Incomplete ones are apparently not caught until run time  http://hpaste.org/12671
14:39:51 <poliquin> Even with -Wall
14:39:57 <vixey> andypls1, (you saw the paste?)
14:40:10 <andypls1> yes
14:40:20 <vixey> andypls1, and you see the bug? :)
14:40:22 <andypls1> that big term comes from another fucntion
14:40:25 <byorgey> poliquin: yes, they are evil =)
14:40:32 <vixey> poliquin, incomplete pattern matches in general aren't noticed until runtime
14:40:36 <andypls1> i don't want to mess with your code vixey
14:40:42 <andypls1> i want to find the bug in my code
14:40:45 <byorgey> well, unless you like pattern-match failure at run time.
14:40:56 <poliquin> I assume case is better then?
14:41:01 <hackage> Uploaded to hackage: HSHHelpers 0.17
14:41:01 <hackage> Uploaded to hackage: PBKDF2 0.3
14:41:01 <hackage> Uploaded to hackage: HAppSHelpers 0.5
14:41:13 <vixey> andypls1, You should write your program in a different way
14:41:18 <byorgey> poliquin: case, or just define the function via pattern-matching
14:41:22 <andypls1> guys How do i trace the recursion?
14:41:23 <vixey> andypls1, what's the exact specification?
14:41:33 <andypls1> can i use the "trace" function?
14:41:53 <poliquin> Ok .. Thanks very much .. !
14:42:16 <byorgey> andypls1: sure, you can use Debug.trace -- a bit clunky but that should let you see what's going on
14:42:19 <byorgey> @type trace
14:42:20 <lambdabot> Not in scope: `trace'
14:42:24 <byorgey> @type Debug.trace
14:42:26 <lambdabot> Couldn't find qualified module.
14:42:29 <byorgey> erm
14:42:29 <tehgeekmeister> http://hpaste.org/12672 <== why does this code only print a newline and exit?
14:42:32 <byorgey> @index trace
14:42:32 <lambdabot> Debug.Trace
14:43:14 <andypls1> how do i add it?
14:43:21 <andypls1> :include Debug.Trace ?
14:43:24 <byorgey> @type Debug.Trace.Trace
14:43:25 <lambdabot>     Not in scope: data constructor `Debug.Trace.Trace'
14:43:32 <Peaker> @type Debug.Trace.trace
14:43:33 <byorgey> andypls1: put 'import Debug.Trace' at the top of your program
14:43:34 <lambdabot> forall a. String -> a -> a
14:43:42 <andypls1> ok
14:43:47 <byorgey> then you can replace any expression x  with  'trace "Message" x'
14:43:56 <byorgey> which will evaluate to x, and print "Message" on the screen
14:44:13 <gio123> is here somebody whose mother language is an english?
14:44:39 <byorgey> poliquin: vixey has a good point though, any incomplete pattern matching causes failure at runtime
14:44:44 <andypls1> when i run it in trace()
14:44:48 <andypls1> it doesn't run
14:44:52 <byorgey> poliquin: but using a case or defining a function via pattern-matching will let you list alternatives
14:44:57 <andypls1> because trace is getting a string as argument
14:45:04 <andypls1> what should i do?
14:45:10 <byorgey> andypls1: what do you mean?
14:45:16 <vixey> andypls1, You should answer my earlier question...
14:45:21 <vixey> andypls1, (repeat) what's the exact specification?
14:45:35 <andypls1> the exact spec is too long
14:45:48 <andypls1> trace( step (add # (num 3) # (num 8)))
14:45:50 <vixey> ok yeah I am definitely not able to help yo
14:45:52 <vixey> you
14:45:53 <byorgey> andypls1: for example, you could replace the 'Var x' on the rhs of the first step equation with   trace "Var case" (Var x)
14:46:00 <andypls1> # is overloaded for the App data constructor
14:46:14 <byorgey> andypls1: oh, that's not where you add the trace
14:46:18 <andypls1> ok
14:46:23 <byorgey> andypls1: you need to add trace messages inside your step function
14:46:30 <andypls1> ok
14:46:34 <byorgey> or whatever function you want to trace execution of
14:46:47 <byorgey> then you can see in what order things are getting evaluated
14:46:56 * ksf concurs with vixey, you need to wrap the strings up in something to represent any kind of sensible, or at least hygienic, scoping. having symeq? = instance Eq String doesn't help there. 
14:48:03 <ksf> am I using scheme as axiom, again?
14:48:09 * byorgey agrees that getting substitution right with Strings as names is very, very tricky
14:48:21 * byorgey personally prefers a locally nameless style
14:48:47 <byorgey> with names for free vars and de Bruijn indices for bound vars
14:48:52 * vixey thinks it's silly to help people that are too lazy to write out an exact specification ...
14:49:24 <adityam> @pl f s a = sum $ map cost $ nextState s a
14:49:25 <lambdabot> f = ((sum . map cost) .) . nextState
14:49:32 * byorgey thinks vixey is being a bit harsh.
14:49:47 <hellige> i have a question
14:49:57 <hellige> wait, maybe not..
14:49:59 <Beelsebob> adityam: I think I'd make that f s = sum . map const . nextState s
14:50:00 <hellige> lemme think.
14:50:08 <zachk> Just Question hellige
14:50:20 <vixey> well it bugs me it's like saying "you should put effort and years of learning things into helping me but I can't be bothered to explain what I need help with"
14:50:50 <andypls1> guys.........
14:50:56 <zachk> and girls
14:50:57 <vixey> maybe I do have a skewed perception but I can't tell
14:51:05 <andypls1> it's the subst function that never ends
14:51:10 <andypls1> not the step function
14:51:19 <byorgey> aha
14:51:23 <hellige> ok, i do have a problem
14:51:24 <adityam> Thanks Beelsebob
14:51:37 <hellige> i have a problem with the way you compute newvar in subst.
14:51:40 <olsner> hmm, does haskell have currying of types? like data Bar a b c = [...]; type Foo = Bar?
14:51:50 <andypls1>  vixey : the exact spec is a pdf doc 2 pages long that you don't need
14:51:50 <olsner> or do I have to write type Foo a b c = Bar a b c?
14:51:51 <hellige> but maybe byorgey found the actual probleM?
14:52:01 <ksf> actually, i used string eq in my java code, but that one uses term rewriting, so stuff's safe.
14:52:03 <Beelsebob> olsner: I think that works, yes
14:52:14 <vixey> andypls1, I don't need it and I refuse to help yo
14:52:16 <vixey> you
14:52:17 <ksf> dunno what would've happened if i had allowed recursion.
14:52:25 <ksf> most likely, terrible things.
14:53:02 * tehgeekmeister is at an impasse
14:53:18 <yitz> tehgeekmeister: you need to wait for your threads to finish
14:53:24 <hellige> don't you need to be sure that newVar is not free in n?
14:53:38 <tehgeekmeister> yitz: huh?
14:54:15 <yitz> tehgeekmeister: you fork 2 threads - then your program immediately exits, killing the threads
14:54:31 <tehgeekmeister> yitz: oh, i figured it would wait on them to exit.
14:54:40 <byorgey> andypls1: one possibility that occurs to me is if alphaEq and newVar are chosen incorrectly, when you recurse you will not have solved the problem of variable clash and you will do the same thing over again.
14:54:58 <yitz> tehgeekmeister: read the docs for Control.Concurrent, it explains how to do it
14:55:12 <tehgeekmeister> yitz: thanks!
14:55:13 <ksf> actually, noone should ever help anyone figuring out his first lambda eval.
14:55:17 <hellige> byorgey: that's what i'm worrying about too.
14:55:23 <ksf> there are much too important lessons to be learned.
14:56:23 <byorgey> andypls1: ok, so if 'name' is one of the free vars in n, you choose a new name... but the code that chooses a new name doesn't reference n at all!  that doesn't make sense to me.
14:56:44 <hellige> right
14:56:46 <hellige> here's the problem
14:56:52 <hellige> subst (Lam "x" (Var "y")) "y" (Var "x")
14:56:56 <hellige> that will never return.
14:57:05 <vixey> hellige, you're in the same class as andypl1 then?
14:57:13 <hellige> vixey: eh?
14:57:19 <andypls1> ok
14:57:19 * ksf recommends env passing and env nesting for the first try, though.
14:57:20 <vixey> hellige, nevermind
14:57:21 <andypls1> one thing
14:57:30 <andypls1> fresh isn't correct yet
14:57:38 <andypls1> but it should work for most of the cases
14:57:42 <hellige> andypls1: really, look at my example. i suspect this is your problem...
14:57:48 * vixey recommends not whacking yourself in the head with a frying pan repeatedly^H^H^H^H^H^H^Husing alpha syntax
14:57:57 <byorgey> andypls1: well, if fresh isn't correct, all bets are off =)
14:57:57 <hellige> andypls1: subst (Lam "x" (Var "y")) "y" (Var "x")
14:58:05 <andypls1> ok
14:58:08 <nn-main> 649+7
14:58:15 <byorgey> andypls1: but even if it was correct, I don't think you're calling fresh on the right set of names.
14:58:18 <andypls1> hellige gimme a sec
14:58:32 <nn-main> lambdabot, 6997+8
14:58:35 <byorgey> > 649 + 7
14:58:36 <lambdabot>   656
14:58:36 <hellige> byorgey: right. assuming fresh is correct, the call is still wrong.
14:58:42 <ksf> alpha syntax?
14:58:46 <nn-main> oh
14:58:52 <nn-main> > 7885+99
14:58:53 <lambdabot>   7984
14:58:58 <nn-main> ah thats how
14:59:04 <hellige> vixey: yes, we all agree that using strings for bound variables sucks.
14:59:06 <vixey> ksf, data Alpha = Lam String Alpha | ...
14:59:07 <hellige> vixey: no question.
14:59:18 <olsner> Beelsebob: nice, it did work :)
14:59:26 <andypls1> hellige yeah that's the problem
14:59:30 <andypls1> gimme a sec to fix it
14:59:48 <hellige> well, i won't be here. but good luck!
14:59:48 <vixey> hellige, it's well known that agreeing something sucks doesn't mean progress
14:59:54 <adityam> Is there a predefined function which flips a tuple? f (a,b) = (b,a)
15:00:01 <hellige> vixey: it's not *my* homework. ;)
15:00:34 <idnar> @pl f (a,b) = (b,a)
15:00:35 <lambdabot> f = uncurry (flip (,))
15:00:41 <idnar> @type swap
15:00:42 <lambdabot> Not in scope: `swap'
15:00:49 <idnar> @hoogle (a, b) -> (b, a)
15:00:50 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
15:00:50 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
15:00:50 <lambdabot> Control.Arrow (<<<) :: Arrow a => a c d -> a b c -> a b d
15:01:06 <centrinia> :t \(x,y) -> (y,x)
15:01:07 <nn-main> Im compileing ghc .... when it compleates how do i complie lambdabot ?
15:01:07 <lambdabot> forall t t1. (t, t1) -> (t1, t)
15:01:10 <yitz> @type uncurry (flip (,))
15:01:11 <lambdabot> forall b a. (a, b) -> (b, a)
15:01:14 <ksf> vixey, there are other ways to do it?
15:01:22 <vixey> ksf, yes
15:01:35 <ksf> you don't mean [String] or Sym, do you?
15:02:03 <ksf> gadt's?
15:02:17 <andypls1> newVar = fresh (getBoundVars (Lam name term))
15:02:26 <andypls1> this is how it should be
15:02:26 <adityam> I think I will just define swap. It is easier to read than uncurry (flip (,)) :-)
15:02:36 <andypls1> not newVar = fresh (getBoundVars  term)
15:02:38 <andypls1> that's the prob
15:03:06 <alexei_> where do I start if I want to optimally schedule N independent prallelizable tasks of various size on M processors in an optimal way?
15:03:09 <byorgey> andypls1: that still doesn't mention n.
15:03:12 <Beelsebob> adityam: it suggests you defined one of your data types the wrong way round if you need to do that
15:03:29 <vixey> ksf, http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=330 and if you want GADTs, data DeBruin free where Vz :: DeBruijn (Maybe a); Vs :: DeBruijn a -> DeBruijn (Maybe a); App :: DeBruijn a ->DeBruijn a ->DeBruijn a; Lam :: DeBruijn (Maybe a) -> DeBruijn a
15:03:39 <byorgey> andypls1: you check to see if 'elem name (getFreeVars n [])' is true
15:03:41 <hellige> andypls1: i'm with byorgey, that still isn't right.
15:03:54 <byorgey> andypls1: and if it is true, then you do  'subst alphaEq x n'
15:03:57 <hellige> andypls1: you need to be sure that the new variable is not free in n
15:04:01 <adityam> Beelsebob: I need to use a library function which returns things in the wrong order.
15:04:16 <byorgey> andypls1: so if the same case is not going to hold in that recursive call, you had better make sure that alphaEq takes n into account
15:04:16 <hellige> anyway, quitting time... night all.
15:04:35 <adityam> Beelsebob: I am using argminsWithMin
15:04:36 <byorgey> night hellige
15:04:43 <adityam> :t argminsWithMin
15:04:44 * byorgey is going home too
15:04:44 <lambdabot> Not in scope: `argminsWithMin'
15:04:47 <byorgey> andypls1: good luck!
15:04:49 <andypls1> that's a start now i don't have infinite recursion
15:05:06 <olsner> hmm, does TypeSynonymInstances have any surprising extra semantics, or can it be used to just save typing on class instances?
15:05:19 <adityam> :m Data.List.Extras.Argmax
15:05:21 <quicksilver> it just saves typing, olsner
15:05:25 <olsner> nice
15:05:35 <quicksilver> it doesn't let you actually create two instances for the same type ;)
15:05:45 <quicksilver> and it doesn't let you use partially applied type synonyms
15:05:52 <quicksilver> (because that would give you type lambda)
15:06:45 <olsner> but I have: type ConstantGetter = ReaderT [Constant] Get; instance Applicative ConstantGetter where ...
15:06:56 <olsner> isn't that a partially applied type synonym?
15:07:00 <quicksilver> no
15:07:10 <quicksilver> it would be partially applied if it was ConstantGetter a b
15:07:17 <quicksilver> and instance Applicatve (ConstantGetter a)
15:08:22 <olsner> hmm, so if I had made the extra parameter to ReaderT explicit in my type synonym, it would have been partially applied?
15:08:59 <opqdonut> yep
15:09:21 <olsner> but shouldn't that be the same thing?
15:09:28 <opqdonut> well it's eta-equivalent
15:09:44 <opqdonut> but we like to keep away from the full power of lambda-calculus in our type system
15:09:50 <opqdonut> thus no type-level-lambdas and so on
15:09:53 <andypls1> 	newVar = fresh (getBoundVars (Lam name term) ++ getFreeVars n [])
15:09:54 <olsner> meh :)
15:10:04 <andypls1> i still don't get the correct output for:
15:10:13 <olsner> I want lambdas all the way!
15:10:16 <andypls1> subst (Lam "x" (Var "y")) "y" (Var "x")
15:11:10 <Saizan_> olsner: implement higher order unification in GHC
15:11:18 <andypls1> no
15:11:23 <andypls1> actually i am
15:11:23 <andypls1> !!
15:11:31 <vixey> andypls1, it's so obvious what you are doing wrong.. and It's like fingernails on blackboard seeing this..
15:11:33 <andypls1> give me a sec to remove all the "trace" shit
15:11:43 <andypls1> vixey, i solved it
15:11:54 <vixey> andypls1, somehow that doesn't really make me happy
15:12:16 <vixey> andypls1, it's like 'I solved world peace by blowing up all the small countries!'
15:12:47 <Saizan_> vixey: you're too emotional about a LC interpreter :)
15:13:06 <andypls1> let me show you the output to that HUGE expression i posted earlier
15:13:08 <ksf> vixey, i'll give it a try as soon as i get around to do something sensible with an AST i already got a parser for.
15:13:13 <ddarius> vixey: That's a great idea.
15:14:49 <andypls1> anyway it's working now
15:14:53 <andypls1> thanks everybody! :)
15:15:27 <timthelion> Where can I ask a simple question about quantum mechanics?
15:15:47 <ksf> if we don't see it, will you have thought of it?
15:16:34 <timthelion> ksf: If that thought of mine has a chaotic effect which becomes signficant, and thus effects something you do see.
15:17:22 <ksf> all good and well, but if i don't see any effects, will you have thought of it?
15:18:37 <timthelion> ksf: that was my question, if anything can have a chaotic effect, then how can anythings location and speed be inderterminant at any given time?  I think I can prove that anything that either has mass(and thus bends space time) or creates an EMR feild, will have some effect, and thus a chaotic effect, thus a significant effect.
15:19:57 <ksf> so you clam that all energy propagates, and no subsystem in the "objective reality" is closed?
15:20:07 <ksf> i'd say that's most likely.
15:20:15 <ksf> *claim
15:20:29 <ksf> maybe s/energy/information
15:21:05 <cjb> timthelion: #physics?
15:21:49 <ksf> not really, my experience is that quantum mechanical discussions are highly applicable to computing
15:22:31 <ksf> you could, for example, try to figure out an isomorphism to frp.
15:23:52 <timthelion> ksf: my theory came from haskell, which is why I asked here.  I want to prove internal determinacy, by chaotic effect.  So I can relate an atom, to a haskell structure who's existence and future is determinant, except for unevaluated monads(the effect of other systems upon it).  If I can prove that each system is determinant, then I can prove that in agrigate all system are.  Then I can prove that the universe does not exist.
15:23:54 * ksf forgot heisenberg's daemon.
15:24:16 <Phyx-> hi, does anyone know why i get a prelude.head error when i pass a content with newline to the stdin and try to read it? my code is http://hpaste.org/12674
15:25:04 <adityam> @pl f a b = not (g a b)
15:25:05 <lambdabot> f = (not .) . g
15:25:05 <ksf> the universe doesn't exist until you pull the plug, then it will cease to exist ;)
15:26:08 <timthelion> ksf: do you get what I'm saying though?
15:26:12 <ksf> yeah.
15:26:42 <Cale> timthelion: I'm not 100% sure what you're talking about, but, supposing that QM is correct, there can't exist a single deterministic model of the universe.
15:26:52 <Botje> Phyx-: which function are you calling and how?
15:27:31 <sclv> pyhx -- the error must be outside the code you pasted.
15:27:36 <ksf> the main point is that it's unknown whether or not speed and location are indeterminant or determinant, but in an unknown way, see black boxen.
15:27:50 <ksf> inherently unknown to the observer, that is.
15:28:07 <Cale> You can show that they're not just unknown quantities.
15:28:16 <Cale> Hidden variables don't result in QM.
15:28:55 <Peaker> Cale: are you sure? I think bigshot physicists abscribed to the hidden-variables theories..
15:29:02 <timthelion> Cale: Yes, but I dissagree with heisenburg.  I say that System A has a small effect on system B, which is magnified by chaos.  Such an effect as the rippling caused by the movement of a massios ellectron, becomse signficant through chaos theory, thus the location of the electron in system A, IS determinant, since system C has effects that rely on both location and velocity
15:29:03 <Cale> (that is, supposing that QM is true, there's no "classical" explanation which gives rise to that behaviour)
15:29:05 <Phyx-> Botje, sclv but if that was the case, i would have gotten a parse error from my parser, i now get a vague head error, but i don't recall ever using head so it must be a function that's defined using head
15:29:14 <Phyx-> but if i ommit the newline it works fine
15:29:21 <ksf> Cale, yes, but a program doesn't change chaotically if you look at it.
15:29:35 <sclv> none of those functions look partial to me -- try writing a driver that just uses the code you have
15:29:37 <gwern> Cale: I thought you could treat the universe as a single wave-function and then just update with the shrodinger equation
15:30:43 <Cale> gwern: You can, but that's more or less many-worlds -- you have a superposition of many states all the time.
15:30:46 <Phyx-> Botje, sclv http://hpaste.org/12675 i was expecting the same error from both
15:30:49 <Botje> Phyx-: can you show all of your code?
15:31:13 <timthelion> I'm just sick and tired of having, every time I start an argument about nihilism, people saying "because of QM, the univers is indeterminant, ergo there is free will."
15:31:24 <Botje> the code you pasted shows no use of fromJust or head.
15:31:30 <Botje> ergo, the error is in another bit of code.
15:31:32 <ksf> timthelion, you might want to think of upsetting near-equibrila: there's a defined maximum energy that B can further propagate, that cannot be influenced by A.
15:31:36 <gwern> Cale: oh. but I thought MW involved many classical universes exfoliating off every planck-second; if the wave-function just updates normally, then what's the problem with MW?
15:31:39 <Peaker> I think linking free will to QM indeterminism is silly
15:31:55 <ksf> (that description seperates systems waaaay too much)
15:31:58 <Cale> timthelion: If humans have free will, and some easily accepted assumptions from QM are true, then particles have free will.
15:32:01 <Peaker> compatibilism is the only way to go :P
15:32:21 <Phyx-> Botje: the full source spans multiple files and methods, but they all fail gracefully. i can paste how i read it in though
15:32:23 <gwern> Peaker: I and Denett agree :)
15:32:24 <SKuhn> hey, I have a problem with guards I can't name. In Birds book P.280 a guard looks like
15:32:24 <SKuhn> | otherwise=(union xt yt,zs)
15:32:24 <SKuhn> where (xt,ys) = mkTwo m xs
15:32:24 <SKuhn> (yt, zs) = mkTwo (n-m)ys
15:32:24 <SKuhn> I don't understand the guards in tuple notation, how are they called or where are they explained?
15:32:53 <gwern> SKuhn: guards in tuple notation?
15:32:54 <Cale> gwern: I think that's a misconception of M-W....
15:32:58 <Phyx-> Botje: http://hpaste.org/12676
15:33:29 <tehgeekmeister> since everyone seems to be on physics already: is anyone familiar with this series of books http://tinyurl.com/5bdqu2 ?  are they relatively suitable for getting into physics?
15:33:45 <SKuhn> gwern: hmm, or this where (xt,ys) = mkTwo m xs
15:34:14 <Phyx-> Botje: the handleRequest can handle newlines in the content fine, since the one where i read from the disk works
15:34:30 <gwern> SKuhn: oh, that's relatively unusual. but you need to read it backwards, thinking of it as being akin to '(xt,ys) <- mkTwo m xs'
15:34:32 <SKuhn> I don't get it how haskell can reduce the xt to a value, if it's specified by (xt,ys) = ...
15:34:40 <ksf> Cale, that's the point where some not-so easily accepted thoughts about QM, like influence of consciousness, become more easily acceptable :)
15:34:41 <gwern> I think
15:35:16 <Cale> gwern: Many-worlds is basically just the idea that there's no notion of the waveform 'collapsing'. The universe is a superposition of states, and doesn't throw away information arbitrarily. The idea that the waveform collapses can be explained by the observer's state becoming entangled with the state of the observed system.
15:35:20 <timthelion> Cale, so if you have photon a, and ellectron b, and a passes by b, and it's path is bent by b's weight, then a is effected by both b's location, and it's velocity at the same time, therefore at that time b's location and velocity where both determinant.  At all times at which the ellectron exists, there are a huge number of photons which are affected by b's weight.
15:35:43 <Cale> In each of the worlds, the observer observes a definite outcome.
15:35:52 <timthelion> Cale: so therefore b's location and speed have collapsed at all times.
15:35:57 <SKuhn> gwern: hmmm, so what does '(xt,ys) <- mkTwo m xs' mean? :(
15:36:21 <BMeph> Does anyone have a copy of that function that extrapolates a sequence?
15:36:42 <Cale> I think this is just really hard to explain without looking at the mathematics directly...
15:36:47 <centrinia> BMeph: Which extrapolation?
15:37:14 <gwern> SKuhn: well that's just do notation, it means mkTwo :: a -> b -> (c,d) if you follow, where xt :: c and ys :: d
15:37:46 <BMeph> centrinia: (...)
15:38:05 <gwern> SKuhn: suppose you saw it as 'let xt = fst (mkTwo m xs) in let ys = snd (mkTwo m xs) in | ....; would that be clearer?
15:38:20 <Cale> To get a sense for what M-W, collapse of the waveform and such mean, it doesn't suffice to read a bunch of plain-English descriptions, because you'll almost certainly get the wrong idea.
15:38:21 <Botje> Phyx-: i'm still not seeing a head in that code :)
15:38:57 <gwern> Cale: well, I have a copy of penrose's _Road to Reality_ which I guess I'll read/work-through some day...
15:39:19 <timthelion> Cale: does it require mathematics to agree that if einstiens strech theory is correct than if a = a <- EffectsofB, and a collapses, then b has collapsed?  Since according to einstien, b allways has a current on future effect on a givin that b has mas, that b has collapsed at all times?
15:40:06 <centrinia> Does the many-worlds interpretation mean that the universe splits into two equally massive universes for each way that a particle can change?
15:40:11 <ksf> I prefer to solve all that by assuming that higher levels of interpretation of data are inherently more powerful at influencing lower ones. As my Kung Fu master used to say: Spirit triumphs over body: If we assume that spirit is a function of the body, and parts of the body cannot only be influenced by the root of that function but also by its result, then any entity capable of exhibiting such a meta-structure has inherently more free will as one
15:40:11 <ksf> that doesn't, eg. a rock.
15:40:25 * ksf wins line-wrapping.
15:40:25 <SKuhn> gwern: I'm going to read some more basics ...it gave me a hint what to look for, that's all I wanted
15:40:26 <BMeph> centrinia: That's the symbol we used for it. It's just...er, I forget the technical term for it, but it's just taking differences between sequential members until you get a constant, then reconstructing the sequence from those constants.
15:40:27 <Cale> timthelion: collapses never really happen. They're something which we can do as observers to simplify calculations once our state has become entangled with the state of the system we're observing.
15:40:28 <Phyx-> Botje: myeh. i just found it myself in someone else's code :) it seems the always assume a successful parse :P, fixing that now, other than that, will my readStdIn function read everything send to the stdin from the file?
15:40:32 <vixey> usually I have some clue what #haskell is on about ....
15:40:43 <centrinia> Arithmetic sequence?
15:41:06 <centrinia> That function should be in the Enum class interface.
15:41:07 <timthelion> Cale: So would you agree that at all times the system we are observing is ACTUALLY determinant?
15:41:31 <Botje> Phyx-: is there a good reason why you didn't just use hGetContents?
15:41:52 <ksf> CS folks tend to be determinists.
15:41:56 <Botje> it is, admittedly, lazy.
15:42:01 <opqdonut> ksf: oh?
15:42:19 <Cale> timthelion: Well, it depends on what you mean by that. Once we're entangled with the system, we observe a definite outcome which seems to be a perfectly random choice, distributed in a particular way.
15:42:32 <ksf> at least judging by the distribution i witnessed.
15:42:42 <Phyx-> Botje: that, and because i use the same method to read from files and i want the reading to be eager
15:42:58 <Botje> Phyx-: you can make it eager by forcing the read
15:43:03 <Cale> timthelion: But of course, our other selves in the other parts of the formal sum which is the state of the universe, we've observed all the other definite outcomes.
15:43:19 <centrinia> @faq Can Haskell emulate a quantum computer?
15:43:19 <lambdabot> The answer is: Yes! Haskell can do that.
15:43:22 <timthelion> Cale: Where can the choice take place?  If the velocity and location of an ellectron have an effect at all times, then they are determinant at all times, and einstien would sugest that they DO have a gravitational effect at all times...
15:43:23 <Botje> do { contents <- hGetContents fh; return (length contents `seq` contents)
15:43:29 <gwern> timthelion: my understanding is that the whole MW is determinant, but what branches we see is no more than statistically determinant; but then I get confused by things like bell's inequality
15:43:41 <Botje> Phyx-: and hGetContents can work on stdin or a random filehandle.
15:44:07 <ksf> Cale, I think you could cut out MW from that by saying that all other states are witnessed by something else than yourself, in the same world.
15:44:12 <Cale> timthelion: For purposes of simplicity, let's do a finite and concrete example.
15:44:12 <Phyx-> Botje: yeah i know, i read that :) i'll change it once i fix this parser
15:44:45 <timthelion> Cale: like?
15:44:47 <centrinia> Do many-world forks merge?
15:45:08 <Botje> good
15:45:28 <Cale> timthelion: Let's suppose that we have a particle whose spin in the x direction is 1/sqrt(2) (|up> + |down>)
15:45:55 <centrinia> I don't understand the ket notation. :(
15:46:05 <timthelion> Neither do I.
15:46:20 <timthelion> |up>+ |down>?
15:46:21 <Cale> centrinia: Just ignore the ket brackets, they just mean that up and down are vectors. Unit vectors in this case.
15:47:27 <timthelion> Cale: OK, I'm thinking conceptually.  That ellectron has mass, so it's made a dent in space time.
15:48:24 * ksf thinks something wiggled in a certain way in the general mish-mash
15:48:38 <timthelion> Cale: is that not correct?  Is that Dent, which ripples outwards, as the ellectron moves, essentially an observer, at all times.  Can that dent not rend testimony which woud prove that the ellectron's location is singular and determinant?
15:49:19 <Cale> timthelion: There's not just one dent.
15:49:41 <aconbere> Cale: there is as soon as you test for it
15:49:43 <timthelion> Cale: Really?  So is there a half dent in each of two places the ellectron could be?
15:49:45 <Cale> Well, it's dangerous to mix QM and our current explanations of gravity.
15:49:56 <timthelion> Cale: Why?
15:50:05 <ksf> because they break down.
15:50:06 <aconbere> timthelion: there no dent until you test, and until then there is a probabiltiy that the dent exists at many locations
15:50:36 <Cale> Let's just use this particle for a moment. What that state means is that if we observe the particle, there's a 1/2 probability we see that its spin in the x direction is up, and a 1/2 probability we see that it's down.
15:50:41 <timthelion> aconbere: But if that dent effects system C, and you observe system C, is there then only one dent?
15:50:42 <Cale> But that's not the whole story.
15:51:01 <andypls1> hey
15:51:03 <Cale> We're quantum mechanical systems too.
15:51:38 <FunctorSalad> is wxhaskell the way to go currently?
15:51:44 <FunctorSalad> gtk2hs doesn't work on 6.10 for me
15:51:58 <ksf> that or one of the reactive libraries.
15:52:06 <ksf> ...or gtk2hs, yes.
15:52:13 <Cale> Let's put an observer in with the particle, and have him observe it, and the state we'll get will be in a particular tensor product. It will be, essentially:
15:52:38 <Cale> 1/sqrt(2) (|up, observed up> + |down, observed down>)
15:52:44 <timthelion> Cale: Is it QM or Gravitational theorys that are only now hypothesis?  AT no time in math, can two theorys not safely be mixed, that is what sepparates math and physics from faith.
15:53:15 <ddarius> Cale: http://bayes.wustl.edu/etj/articles/cmystery.pdf http://bayes.wustl.edu/etj/articles/prob.in.qm.pdf http://bayes.wustl.edu/etj/articles/predictive.pdf
15:53:16 <lambdabot> Title: E. T. Jaynes Wayman Crow Professor of Physics Washington University, St. Louis M ...
15:53:17 <Cale> timthelion: QM and General relativity are inconsistent.
15:53:45 <Cale> timthelion: They're both useful models of the universe, and they're both the best thing we have for various tasks.
15:53:54 <timthelion> Cale: OH, I see.  Here I thought I was finding something new.  So which ones right?  When will we know which one is right?
15:54:49 <Cale> timthelion: Both are right, and neither is. The only measuring stick we can use to determine if something is right is to see if it matches our observation and makes useful predictions.
15:55:13 <ksf> how far's string theory, btw?
15:55:24 <Cale> They both make useful predictions in a variety of circumstances, but there's nothing to rule out that one or both of them fail to predict something correctly.
15:55:40 <Cale> String theory is not yet a science.
15:56:02 <Cale> (It has yet to make a useful prediction beyond what we can do with other simpler theories.)
15:56:07 <Cale> bbiab, dinner
15:56:29 * ddarius highly recommends the three papers he referred Cale to (and pretty much anything else by E. T. Jaynes)
15:56:47 <timthelion> Cale: So this is like when the greeks where trying to create a model for the planets in which they all obrited the earth.  They could create usefull mathematical models for prediction, but not representative models for exploration?
15:57:38 <ksf> well, they could predict stuff, but it didn't match observation.
15:58:43 <Botje> yawn
15:58:58 <Botje> i was hoping to procrastinate my reading for quantum computation
15:59:00 <FunctorSalad> err. cabal install wx fails with what appears to be a C++ syntax error?
15:59:02 <Botje> seems i was wrong
15:59:07 <BMeph> Has anyone else had any trouble in defining a postfix (unary) operator?
15:59:21 <Botje> FunctorSalad: random guess: do you have the libwx-dev libraries installed?
15:59:24 <FunctorSalad> wxc/src/eljdc.cpp:577: error: expected constructor, destructor, or type conversion before â*â token
15:59:37 <Botje> s/libraries/package/
15:59:48 <FunctorSalad> Botje: I just installed everything wx-ey I could find in aptitude, yes ;)
15:59:56 <FunctorSalad> before that it failed with another error
16:00:29 <Botje> i'll give it a whirr
16:00:29 <blackh> BMeph: I didn't even know that was possible.
16:00:37 <ksf> that's one of g++'s one-catches-all errors, it happens for various reasons.
16:00:58 <FunctorSalad> ksf: *nod*, there are more errors after that line
16:01:39 <ksf> maybe a stray macro or something?
16:02:08 <ksf> missing typedef/outdefined include?
16:02:10 <FunctorSalad> oh wait, there's an error above that
16:02:49 <FunctorSalad> error: no matching function for call to âwxMemoryDC::wxMemoryDC(wxBitmap&)â
16:03:00 <FunctorSalad> wrong wx version, I'd guess
16:06:14 <lazyshark> Is the H3D project active? (http://www.haskell.org/haskellwiki/H3D)
16:06:15 <lambdabot> Title: H3D - HaskellWiki
16:06:49 <ksf> wx 2.8 w/ ghc6.8.3 seems to work fine.
16:07:08 <FunctorSalad> ksf: 6.10.1 here
16:07:37 <Cale> Oh, timthelion is gone...
16:07:54 <ksf> good to know, so i'm going to procrastinate upgrading even further ;)
16:08:12 * ksf is still listening.
16:08:24 <FunctorSalad> ksf: with several wx-dev debian packages installed, dunno which one is being used
16:08:26 <Cale> Heh, I was going to say, there are perfectly acceptable models in which the Earth is at the centre of the coordinate system. They're just a little more complicated to use.
16:08:40 <ksf> wut?
16:08:55 <aconbere> that's right, the math is just harder :)
16:09:24 <ksf> you mean they work by mathematically projecting the sun-centric model into an earth-centric?
16:09:30 <FunctorSalad> there are also models that don't *have* a coordinate system
16:09:49 <Cale> The Sun *does* go around the Earth. Anyone who can't think of a coordinate system in which it does should take a look out the window from time to time :)
16:10:00 * ksf wonders if there are infinite isomorphisms to everything.
16:10:04 <FunctorSalad> having an origin is precisely the difference between vector spaces and affine spaces
16:11:14 <Cale> ksf: Well, that would probably be the easiest way to construct them now. But in the old days, they didn't know about the model with the Sun at the centre and the planets in elliptical orbits, so the other planets followed somewhat more complicated curves.
16:12:12 <Cale> Those curves are just a little harder to work with, but by no means impossible to describe mathematically.
16:12:32 * ksf suddenly understands what those strange people that say "everything is relative" actually mean
16:13:04 <Cale> You could also say that the Earth and Sun remain on a fixed line, and everything else moves around.
16:13:11 <Philippa> some of them, at least? Some are just idiots using it as an excuse to call any old shit true
16:13:32 <ksf> that's why I used the term "strange".
16:14:12 <ksf> there's a metaphysical school that claims that no human is able to tell complete lies.
16:14:32 <centrinia> This statement is a lie. :)
16:14:39 <FunctorSalad> that's why we made computers
16:14:43 <Cale> One thing that I find really funny is that if you go up to a random person on the street and ask them if the Earth goes around the Sun or if it's the other way around, most people will vehemently assert that the Earth goes around the Sun as if it could not be any other way.
16:14:59 <Cale> This despite the fact that they observe the Sun going around the Earth every day.
16:15:33 <centrinia> There is no Sun.
16:15:34 <Cale> It gives one a sense of the power of propaganda ;)
16:16:05 <Sartak> the word propaganda implies deception
16:16:08 <FunctorSalad> if there are many possiblities and you tell the exact opposite of the truth (imagine antipodes on a sphere), you are really saying a lot of truth as in giving information
16:16:23 <FunctorSalad> maybe that's the idea behind what ksf said
16:16:28 <ksf> well, if they claimed otherwise they couldn't hide their fundamental backwardness by asserting you that they aren't _that_ backward.
16:16:52 <FunctorSalad> so you need a random generator for lying properly :)
16:17:26 <centrinia> Is the negation of a lie always true? ;)
16:17:30 <ksf> the aborigines have it wrapped up quite succinctly: we live in a dream, the only question is whether we dream the others or the others dream us.
16:18:25 <Cale> Sartak: It is somewhat deceptive to tell people that the Earth goes around the Sun and just to leave it at that. The real answer is that you can pick any number of viewpoints from which to observe the solar system, and it just happens that if you put the Sun at the centre of your view, things are simpler to describe.
16:18:32 <centrinia> ksf: Maybe we dream the others and the others dream us. :)
16:18:50 <blackh> I have a question. It's about Haskell, sort of. Does anyone know of any Haskell people in New Zealand?
16:18:55 <FunctorSalad> centrinia: sounds correct
16:19:17 <centrinia> @google New Zealand Haskell User Group
16:19:20 <lambdabot> http://www.physics.otago.ac.nz/research/ice/publications.html
16:19:20 <lambdabot> Title: Publications, Sea Ice Group, University of Otago, Dunedin, New Zealand
16:19:30 <pjdelport> Cale: the correct answer is that they go around each other, of course
16:19:30 <Cale> blackh: hmm... I know there are quite a few in Australia, but I'm not sure about NZ.
16:19:46 <FunctorSalad> blackh: I don't - maybe ask on the mailing lists?
16:19:53 <FunctorSalad> in cafe I suppose
16:20:06 <ksf> All affirmations are true in some sense, false in some sense, meaningless in some sense, true and false in some sense, true and meaningless in some sense, false and meaningless in some sense, and true and false and meaningless in some sense.
16:20:12 <pjdelport> Cale: you have to stretch "around" to a breaking point to say the sun goes around the earth, though
16:20:25 <Cale> pjdelport: hm?
16:20:26 <FunctorSalad> ksf: but never none of these three?
16:20:52 <Cale> pjdelport: You just have to place the centre of your coordinate frame at the centre of the Earth, or somewhere on its surface.
16:20:54 <pjdelport> Cale: it does only in the sense as building "goes around" you if you spin around on a spot
16:20:57 <ksf> wouldn't be an affirmation then, would it?
16:21:20 <Cale> pjdelport: It does :)
16:21:39 <pjdelport> Cale: but people don't speak or think of the building moving
16:21:43 <SKuhn> gwern: what I don't get is where does ys come from
16:21:43 <SKuhn> mkTwo n xs ...
16:21:43 <SKuhn>  | otherwise=(union xt yt,zs)
16:21:43 <SKuhn>  where 	(xt,ys) = mkTwo m xs
16:21:43 <SKuhn> 		(yt, zs) = mkTwo (n-m)ys
16:21:55 <pjdelport> they speak and think of the reference frame moving :)
16:21:59 <blackh> I forgot about Google. Thanks.
16:22:02 <centrinia> If you go around telling people that the Earth is (locally) flat, they will think that you are strange. :)
16:22:22 <gwern> SKuhn: desguar that  into let bindings like I showed you
16:22:38 <ksf> the very word "meaningless" in itself is a paradox.
16:22:42 <Cale> SKuhn: it's bound by (xt, ys) = mkTwo m xs
16:23:00 <gwern> Cale: he doesn't get that because it looks backward to him
16:23:02 <FunctorSalad> centrinia: doesn't it have some pointy nondifferentiable points? :o
16:23:21 <ksf> I'm drifting off into zen, it seems.
16:23:23 <gwern> Cale: I tried to show him what it looked like forwards, but I guess it didn't take
16:23:27 <centrinia> FunctorSalad: Where? :O
16:23:39 <FunctorSalad> here *ouch!*
16:23:45 <Cale> ksf: Here's how I look at it. Statements are true or false according to how we decide to label them as such. We typically do so based on how useful they are to us, in describing and predicting what we observe.
16:23:51 <gwern> ksf: zen is a fine place to drift off to. a withered pine tree shows the way, and flying geese preach the truth!
16:23:55 <SKuhn> d'oh, is there another term for let? (it's not in the index of birds book)
16:24:08 <centrinia> where?
16:24:24 <ksf> the problem is that drifting and zen are mutually exclusive.
16:24:28 <Cale> SKuhn: 'where' clauses go after a declaration, and define things used inside it.
16:24:44 <ksf> zen implies attentiveness.
16:24:58 <Cale> SKuhn: So for example, you could write:
16:25:10 <centrinia> let x = foo in bar x := (\x -> bar x) foo
16:25:15 <Cale> circleArea radius = pi * square radius
16:25:16 <FunctorSalad> SKuhn: the 'ys' comes from the pattern binding in the where clause
16:25:22 <Cale>   where square x = x * x
16:25:23 <gwern> ksf: psh!
16:25:27 <gwern> ksf: ''Where are you going?' asked the one. 'I am going wherever my feet go.' the other responded. This reply puzzled the first child who went to his teacher for help. âTomorrow morning,' the teacher told him, 'when you meet that little fellow, ask him the same question. He will give you the same answer, and then you ask him: "Suppose have no feet, then where are you going!" That will fix him.' The children met again the following ...
16:25:28 <ksf> Cale, that's the same, but not as good a koan.
16:25:30 <Cale>         pi = 3.1415
16:25:33 <gwern> ... morning. 'Where are you going?' asked the first child. âI am going wherever the wind blows,' answered the other. This again nonplussed the youngster, who took his defeat to his teacher. 'Ask him where he is going if there is no wind,' suggested the teacher. The next day the children met a third time. 'Where are you going?' asked the first child. âI am going to market to buy vegetables,' the other replied. '
16:25:47 <Cale> Thanks for interleaving my code, guys ;)
16:25:51 <FunctorSalad> > a where (a,b) = (2,3)
16:25:53 <lambdabot>   2
16:25:59 <gwern> Cale: any time!
16:26:04 <Cale> FunctorSalad: That's deceptive...
16:26:11 <Cale> In fact, why does that even work?
16:26:16 <FunctorSalad> hehe
16:26:28 <FunctorSalad> it doesn't in ghci?
16:26:41 <Cale> 'where' is not an expression form.
16:26:50 <Cale> It's part of the syntax of declarations.
16:26:58 <FunctorSalad> oh, right
16:26:58 <gwern> hm. good question, how can it work in mueval but not ghci?
16:27:01 <Cale> (and let syntax)
16:27:09 <centrinia> :t a where (a,b) = ("Hello World!",42)
16:27:11 <lambdabot> parse error on input `where'
16:27:16 <ksf> The answer? Refinement of will and increasing consciousness are indiscernible.
16:27:27 <FunctorSalad> maybe the bot writes "f = $input" to a file and then evaluates f, Cale ?
16:27:36 <FunctorSalad> no idea
16:28:02 <gwern> FunctorSalad: ah, that must be it, yes. hint has to write to a file because of the ghc improt bug in 6.8
16:28:09 <Cale> FunctorSalad: yeah, it looks like the sort of thing which would suggest an injection attack :)
16:28:42 <FunctorSalad> > drop database
16:28:44 <lambdabot>   Not in scope: `database'
16:28:45 <FunctorSalad> ;)
16:28:47 <Saizan_> nah, it's the GHC-API
16:29:03 <Cale> Saizan_: The GHC API allows where in expressions?
16:29:13 <Saizan_> Cale: it's like "let foo = $input" in ghci
16:29:44 <ksf> > f
16:29:45 <lambdabot>   Add a type signature
16:29:49 <ksf> nope.
16:29:54 <SamB_XP> > foo
16:29:55 <lambdabot>   Not in scope: `foo'
16:29:58 <Cale> @v
16:29:58 <lambdabot> "\"#$%&'()*+,\""
16:30:07 <SamB_XP> > f x
16:30:08 <lambdabot>   Add a type signature
16:30:09 <ksf> > f :: (a->a)
16:30:10 <lambdabot>       Overlapping instances for Show (a -> a)
16:30:10 <lambdabot>        arising from a use of `s...
16:30:15 <ksf> > f :: a
16:30:16 <lambdabot>       Could not deduce (SimpleReflect.FromExpr a) from the context ()
16:30:16 <lambdabot>        ...
16:30:20 <ksf> ouch.
16:30:28 <SamB_XP> > f :: ()
16:30:29 <lambdabot>       No instance for (SimpleReflect.FromExpr ())
16:30:30 <lambdabot>        arising from a use o...
16:30:46 <SamB_XP> > f ()
16:30:47 <lambdabot>   Add a type signature
16:30:50 <Cale> > fix (map succ . show)
16:30:51 <lambdabot>   "#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]]^^__``aabbccd...
16:31:00 <ksf> > (\x -> f) 1
16:31:02 <lambdabot>   Add a type signature
16:31:14 <FunctorSalad> > f :: Expr
16:31:16 <lambdabot>   f
16:31:19 <ksf> > ((\x -> f) 1) :: a
16:31:20 <lambdabot>       Could not deduce (SimpleReflect.FromExpr a) from the context ()
16:31:20 <lambdabot>        ...
16:31:22 <FunctorSalad> \o/
16:31:24 <ksf> > ((\x -> f) 1) :: Int
16:31:25 <lambdabot>       No instance for (SimpleReflect.FromExpr Int)
16:31:25 <lambdabot>        arising from a use ...
16:31:30 <Saizan_> > show __expr
16:31:32 <lambdabot>   Not in scope: `__expr'
16:31:33 <ksf> > ((\x -> f) 1) :: Expr
16:31:34 <lambdabot>   f
16:31:37 <ksf> grrr
16:31:43 <cknapp> What's going on? I'm so confused...
16:31:54 <FunctorSalad> ksf: bot's answer is correct, isn't it
16:32:05 <gwern> __expr?
16:32:07 <Cale> f is a predefined value in the bot's Prelude
16:32:20 <Cale> (not really a Prelude, but L.hs)
16:32:28 <Cale> :t f
16:32:29 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
16:32:41 <Cale> :t x
16:32:41 <lambdabot> Expr
16:32:44 <Cale> > f x
16:32:46 <lambdabot>   Add a type signature
16:32:48 <Cale> > f x :: Expr
16:32:49 <lambdabot>   f x
16:32:56 <Cale> > map f [x,y,z] :: [Expr]
16:32:57 <lambdabot>   [f x,f y,f z]
16:33:20 <Cale> > foldr f z [a,b,c]
16:33:21 <lambdabot>   f a (f b (f c z))
16:33:26 <Cale> > foldl f z [a,b,c]
16:33:28 <lambdabot>   f (f (f z a) b) c
16:33:34 <Botje> hmm
16:33:35 <Saizan_> > show __cmCompileExpr
16:33:36 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
16:33:39 <Cale> > scanr f z [a,b,c]
16:33:40 <lambdabot>   [f a (f b (f c z)),f b (f c z),f c z,z]
16:33:42 <Botje> for a second there i misread Cale as Cake
16:33:44 <Cale> > scanl f z [a,b,c]
16:33:46 <lambdabot>   [z,f z a,f (f z a) b,f (f (f z a) b) c]
16:34:02 <gwern> Botje: the Cale is a lie?
16:34:05 <Botje> i might just go to bed now
16:34:09 <centrinia> >  System.IO.Unsafe.unsafePerformIO $ System.IO.openFile "/usr/bin/ghci" System.IO.ReadMode
16:34:10 <lambdabot>   /tmp/7006488955752387747:70:32:
16:34:10 <lambdabot>      Not in scope: `System.IO.Unsafe.unsafe...
16:34:16 <centrinia> Hmm.
16:34:28 * gwern feels mildy insulted centrinia thought that might work :)
16:34:31 <Botje> gwern: this cale is so delicous and moist
16:34:44 <gwern> Botje: I'm so happy for you
16:34:57 <Cale> I'm still alive.
16:35:00 <tibbe> I'm trying to write a Functor instance for Oleg's Iteratee but I'm a bit lost, could someone offer some help?
16:35:01 <Botje> i actually had cake today \o/
16:35:17 <Cale> tibbe: What's the data declaration?
16:35:20 <gwern> Cale: but we tore you into pieces and threw you into the fire!
16:35:26 <tibbe> @paste
16:35:27 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:36:44 <tibbe> Cale: http://hpaste.org/12677
16:37:59 <Cale> tibbe: First write a Functor instance for Iteratee m
16:37:59 <gwern> > [True..]
16:38:00 <lambdabot>   <no location info>: parse error on input `]'
16:38:04 <ksf> > show $drop 80 __cmCompileExpr
16:38:08 <gwern> > [T1..]
16:38:10 <lambdabot>   <no location info>: parse error on input `]'
16:38:12 <gwern> > [1..]
16:38:14 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
16:38:17 <tibbe> Cale: ok, I'll try that
16:38:19 <lambdabot>   thread killed
16:38:22 <Cale> fmap f (Done x s) = Done (f x) s
16:38:25 <ksf> > show $drop 40 __cmCompileExpr
16:38:36 <gwern> hm. I guess there's no instance for Bool
16:38:40 <lambdabot>   thread killed
16:38:46 <ksf> > show $drop 20 __cmCompileExpr
16:38:47 <Cale> tibbe: Oh, you have to do them simultaneously
16:38:54 <Cale> tibbe: Because of the mutual recursion
16:39:01 <lambdabot>   thread killed
16:39:02 <tibbe> Cale: :/
16:39:04 <gwern> maybe 'cycle' would be sensible as a defition
16:39:05 <centrinia> > System.Exit.exitFailure -- I wonder if this works.
16:39:06 <ksf> > show $drop 0 __cmCompileExpr
16:39:06 <lambdabot>   Add a type signature
16:39:07 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
16:39:10 <gwern> > cycle True
16:39:11 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Bool'
16:39:12 <ksf> > show $drop 10 __cmCompileExpr
16:39:17 <gwern> > repeat True
16:39:19 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
16:39:23 <ksf> > show $drop 1 __cmCompileExpr
16:39:24 <lambdabot>   "\"\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\...
16:39:26 <centrinia> :t repeat repeat
16:39:27 <lambdabot> forall a. [a -> [a]]
16:39:28 <lambdabot>   thread killed
16:39:29 <ksf> > show $drop 5 __cmCompileExpr
16:39:33 <Cale> fmap f (Cont g) = Cont (fmap f . g)
16:39:45 <lambdabot>   thread killed
16:39:48 <Cale> Where the fmap on the rhs is the one for IterateeM
16:39:56 <Cale> Then you'll have:
16:40:15 <ksf> > show $drop 3 __cmCompileExpr
16:40:22 <ksf> > show $drop 2 __cmCompileExpr
16:40:23 <lambdabot>   "\"\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\...
16:40:28 <Cale> fmap f (IM x) = IM (fmap (fmap f) x)
16:40:31 <lambdabot>   thread killed
16:40:40 <centrinia> > System.Exit.exitFailure :: IO ()
16:40:42 <lambdabot>   /tmp/5855321392888238671:70:32:
16:40:42 <lambdabot>      Not in scope: `System.Exit.exitFailure'
16:40:48 <gwern> ksf: any point to alll this drop stuff?
16:40:50 <centrinia> Epic fail. :(
16:41:02 <hackage> Uploaded to hackage: GHood 0.0.2
16:41:02 <hackage> Uploaded to hackage: GHood 0.0.1
16:41:24 <gwern> centrinia: better #haskellers than you've worked on exploiting lambdabot :)
16:41:30 <Cale> tibbe: Oh! You already have a monad instance.
16:41:37 <Cale> tibbe: That makes it trivial
16:41:47 <Cale> tibbe: fmap f x = liftM f x
16:41:53 <tibbe> Cale: is there any drawbacks to define it in terms of the monad instance?
16:42:15 <Cale> tibbe: Potentially performance, but I'm not sure if it's really a problem.
16:42:36 <centrinia> gwern: Was I being insulting for thinking that those exploits would work? :(
16:42:41 <tibbe> Cale: it's pretty important in my case, could you step me through it?
16:43:04 <Cale> Through how liftM works?
16:43:14 <Cale> Or how my instance of Functor would work?
16:43:19 <Cale> (the direct one)
16:43:23 <ksf> gwern, no, i could have started successive approx earlier.
16:43:30 <gwern> centrinia: just a wee bit - if your attempts had been clever, like using runST or show, then that would've said 'I will assume the devs took care of the obvious holes'
16:43:48 <ksf> actually, i was curious what was behind all those \'s, but there's only bottom.
16:43:51 <tibbe> Cale: how your instance would work
16:43:57 <tibbe> Cale: the direct one
16:43:59 <gwern> ksf: no I mean what did you think was in there?
16:44:31 <Cale> tibbe: Okay...
16:44:44 <Cale> tibbe: Perhaps let's just start with the definition for IterateeM
16:44:53 <tibbe> Cale: sure
16:44:59 <ksf> I even _knew_ what's there.
16:45:04 <ksf> the unknown.
16:45:15 <Cale> tibbe: Suppose for now that m is a Functor, and so is Iteratee m
16:45:24 <ksf> one of the greatest attractive forces in the universe.
16:45:27 <tibbe> Cale: ok
16:45:47 <Cale> Then to fmap f over IM x, all we have to do is fmap (fmap f) over x, and reapply the IM constructor.
16:45:53 <Goober> hi
16:45:58 <Cale> hello!
16:46:07 <cknapp> Hi
16:46:07 <tibbe> Cale: ok
16:46:16 <tibbe> Goober: hi
16:46:17 <Goober> can you teach me Haskell
16:46:22 <Goober> if I am a good student
16:46:27 <luite_> @where lyah
16:46:27 <lambdabot> www.learnyouahaskell.com
16:46:34 <gwern> @faq can haskell teach Goober haskell?
16:46:34 <lambdabot> The answer is: Yes! Haskell can do that.
16:46:34 <Cale> Goober: We can answer questions, and point you at resources.
16:46:50 <Cale> tibbe: So all we have to do is make Iteratee m into a Functor.
16:47:06 <Cale> (on the assumption that m is as well)
16:47:16 <tibbe> Cale: ok
16:47:23 <Cale> fmap f (Done x s) = ...
16:47:30 <Goober> I had a haskell teacher in my university but I got in a fist fight with him cause he was trying to bone his student, who is a hot chick I liked
16:47:40 <Goober> so now, I have to do it on my own
16:47:42 <gwern> ok...
16:47:45 <Cale> Well, just by the type, we're forced to apply f to x, and the obvious thing is to leave the stream alone.
16:48:15 <Cale> fmap f (Done x s) = Done (f x) s
16:48:20 <tibbe> Cale: But you can't write fmap f (Done x s) for the IterateeM instance since it's wrapped
16:48:23 <blackh> Goober: I find it's easier to bone fully grown chickens.
16:48:31 <tibbe> Cale: I've written the Iteratee instance
16:48:36 <Cale> tibbe: This is the Iteratee instance.
16:48:40 <Goober> my first question, is
16:48:43 <tibbe> Cale: ok :)
16:49:11 <Cale> The IterateeM instance is just  fmap f (IM x) = IM (fmap (fmap f) x)
16:49:20 <Goober> can you actually get work done in Haskell, or is it mostly for math nerds
16:49:31 <Cale> Goober: yes, you can actually get work done.
16:49:39 <cknapp> You can get real work done.
16:49:43 <Cale> Goober: It's a serious, general purpose language.
16:49:43 <blackh> Goober: As New Zealand's main Haskell expert, I can say without reservation that you can get work done in it
16:49:45 <cknapp> Check out real world haskell
16:49:51 <Cale> blackh: :)
16:50:03 <Cale> @where RWH
16:50:04 <lambdabot> is http://www.realworldhaskell.org/blog/
16:50:05 <tibbe> Cale: cool!
16:50:12 <ksf> haskell even has a data type that passes the real world around.
16:50:13 <Goober> Ok, but, when I lurked on this channel, I do see a ton of discussion about set theory and math
16:50:14 <tibbe> Cale: let me wrap my head around that for a sec
16:50:30 <cknapp> Goober: Math nerds can get real work done too!
16:50:37 <Goober> rather than discussions of the sort you'd see on a C++ chan
16:51:09 <FunctorSalad> Nerd pride!
16:51:10 <blackh> Goober: I'm writing a web app - 11,000 lines so far - and the work is much much more pleasant since I switched from Python to Haskell.
16:51:10 <ksf> is haskell passing the world around isomorphic to the world passing haskell around?
16:51:15 <tibbe> Cale: now I just need an ApplicativeFunctor and I then I can write applicative parsers
16:51:27 <Botje> Goober: yeah, haskell people don't really argue about the semantics of (void)(()*[])
16:51:53 <Goober> eye of the beholder, botje
16:52:04 <Goober> Your Haskell code looks like that to me!
16:52:19 <Botje> how do you know? you haven't seen my code yet :)
16:52:29 <Cale> Goober: Well, Haskell programmers have a tendency to acquire mathematical interests, since there's a lot of mathematics which is directly applicable to Haskell, but you don't actually need to know it to use Haskell.
16:52:43 <ksf> @pl (\x y z -> z y x)
16:52:44 <lambdabot> flip (flip . flip id)
16:52:55 <ksf> @pl (\x y z -> z x y)
16:52:55 <lambdabot> flip . flip id
16:53:00 <Goober> I like math, but my project upcoming big project doesnt make use of math really
16:53:05 <Goober> its a general purpose app
16:53:05 <cknapp> ksf: what's @pl do?
16:53:16 <ksf> making stuff pointless.
16:53:21 <cknapp> Ah!
16:53:27 <cknapp> fun!
16:53:43 <Botje> Goober: there's math in every program :)
16:53:48 <blackh> Goober: I write big programs for a living every day and I've been doing it for years.  I learnt Haskell about six months ago and I would not choose anything else for any new project.
16:53:51 <FunctorSalad> why did you need to stop your teacher from fscking your friend? as long as she wanted it too...
16:53:53 <Goober> is this senseless: "write fast functions in C++ code, embed in haskell" ?
16:53:57 <ksf> @pl (x -> x x) (x -> x x)
16:53:57 <lambdabot> (line 1, column 4):
16:53:57 <lambdabot> unexpected ">"
16:53:57 <lambdabot> expecting variable, "(", operator or ")"
16:54:04 <SamB_XP> FunctorSalad: male rivalry
16:54:06 <ksf> @pl (\x -> x x) (\x -> x x)
16:54:09 <lambdabot> ap id id (ap id id)
16:54:09 <lambdabot> optimization suspended, use @pl-resume to continue.
16:54:18 <ksf> @pl-resume
16:54:25 <lambdabot> ap id id (ap id id)
16:54:25 <lambdabot> optimization suspended, use @pl-resume to continue.
16:54:28 <Goober> blackh: sounds like you went off the deep end and jumped into the kool aid pool
16:54:34 <Cale> FunctorSalad: He has an undying dedication to university policy?
16:54:36 <Goober> and even drowned swallowing iit
16:54:42 <FunctorSalad> :)
16:54:43 <Goober> granted, that could happen to me
16:54:57 <blackh> Goober: It's like this:
16:55:07 <blackh> Goober: 1. Start writing some code
16:55:26 <ksf> 2. goto 1
16:55:40 <ksf> 3. learn to do reverse cps
16:55:40 <blackh> Goober: 2: Say "Why the hell did I ever think Haskell was a good language? I have to jump through hoops to manage state. This would be much easier in a normal language."
16:55:42 <cknapp> ksf gotos are badd!
16:55:45 <sjanssen> Goober: Haskell's foreign function interface is useful, but there are also not many applications where Haskell isn't fast enough
16:55:49 <ksf> 4 come from -1
16:56:10 <SamB_XP> cknapp: you silly
16:56:12 <blackh> Goober: 3. Some while later.. a very sore head and some very very neat tidy beautiful code. How did this happen?
16:56:19 <SamB_XP> but numeric labels, yes, bad
16:56:26 <blackh> Goober: 4. Fix compile errors. Repeat.
16:56:34 <Cale> Goober: The languages which the mainstream are using are by and large 30 years old as far as their fundamental design goes. In fact, many of them manage to do things worse than they were done 30 years ago. Haskell is a modern language that incorporates more recent research directly, and it shows.
16:56:38 <tibbe> Cale: it's interesting how both instances required the other as Functor context.
16:56:40 <blackh> Goober: 5. Run program.  It works!!  (How did that happen?)
16:56:53 <Ezla> without completely learning haskell, is there any way that you can show me the single "Aha!" moment in how it can be superior?
16:57:05 <Ezla> there has to be some way of demonstrating that
16:57:05 <ksf> continuations are the revenge of people who can cope with gotos.
16:57:06 <SamB_XP> blackh: well, I started learning Haskell because what I took purely functional to mean sounded like it couldn't be of any use
16:57:23 <Cale> tibbe: yeah :)
16:57:23 <SamB_XP> (I was wrong, both in what I took it to mean, and thinking it couldn't be of any use!)
16:57:27 <cknapp> Ezla: What sort of "Aha!" are you looking for?
16:57:33 <cknapp> That's in the eye of the beholder...
16:57:36 <Ezla> Cale: isn't haskell 15 years old?
16:57:38 <Cale> tibbe: The types are mutually recursive, so it makes sense for the instances to be.
16:57:42 <ksf> for every programming idiom forbidden, a newer, moar evil version will be invented.
16:57:43 <cknapp> I think [1..] is a great example.
16:57:44 <tibbe> Cale: right
16:57:48 <ddarius> SamB_XP: You were thinking of something like the pure lambda calculus or what?
16:57:54 <Cale> Ezla: Yes, but it's been changing since then.
16:57:57 <blackh> Ezla: In my experience it's difficult to put your finger one - but it's really all the parts of Haskell working together - not just one particular "killer feature" that makes it better.
16:58:03 <Ezla> cknapp: an illustration of what blackh was trying to say
16:58:15 <SamB_XP> ddarius: I guess so
16:58:19 <ksf> Ezla, implement the pq formula.
16:58:21 <tibbe> Cale: IterateeM is needed to be able to write a monad instance
16:58:27 <SamB_XP> Lazy K killed that second misconception
16:58:45 <Cale> Ezla: There are fundamental changes to things like the type system, though we're almost due for a new language that more comprehensively incorporates everything.
16:58:46 <ksf> there's a pleasant surprise lurking there.
16:59:00 <Ezla> Cale: a "new language" ?
16:59:03 <ksf> (for non-imaginary solutions)
16:59:04 <cknapp> Ezla: quicksort is a great example.
16:59:09 <cknapp> http://en.literateprograms.org/Quicksort_(Haskell)
16:59:14 <Ezla> cknapp: thx
16:59:19 <ksf> quicksort in haskell sucks.
16:59:27 <sjanssen> mergesort ftw
16:59:28 <cknapp> But it's pretty!
16:59:32 <cknapp> And it's clear
16:59:39 <ksf> it's slow as hell, quicksort is optimised for in-place mutation.
16:59:43 <Cale> Ezla: Or at least a proper new version of Haskell.
16:59:47 <blackh> Ezla: Here is one of my aha moments: When I implemented a widget library and the design naturally came out very composable.
17:00:11 <Ezla> is everything in haskell immutable?
17:00:17 <BMeph> Does anyone get how to declare and use a postfix operator, a la http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#postfix-operators
17:00:22 <cknapp> ksf: I agree. But it's great for showing why haskell looks so much better
17:00:31 <SamB_XP> Ezla: ... no
17:00:45 <blackh> Ezla: Generally everything is immuatable, but you can use mutable variables if you need them. They are not the norm.
17:00:45 <Cale> Ezla: All variables are immutable. There are mutable arrays and references accessible in specific monads though.
17:01:00 <SamB_XP> @doc Data.Array.ST
17:01:08 <Ezla> does haskell have a stack?
17:01:12 <blackh> Ezla: I used an IORef to implement caching.
17:01:13 <Cale> In Haskell, a variable does not refer to a box which holds a value, it refers to a value directly.
17:01:14 <ksf> Ezla, mu.
17:01:18 <Ezla> mu?
17:01:20 <ksf> wrong question, move on.
17:01:28 <Cale> Ezla: Haskell is a language.
17:01:32 <Ezla> I know!
17:01:33 <Ezla> but.
17:01:34 <SamB_XP> C doesn't have a stack
17:01:41 <Cale> Ezla: Particular implementations of it use stacks in particular ways :)
17:01:47 <SamB_XP> (though it makes more sense to think about one when writing C code ;-)
17:01:55 <Ezla> SamB_XP: locals in C are on the stack
17:01:57 <Cale> Ezla: But there's no specific need to have anything which looks like a stack
17:02:00 <SamB_XP> Ezla: are not
17:02:05 <ksf> others use piles, fishing rods or other kind of stuff.
17:02:08 <SamB_XP> they are in the activation record ... maybe!
17:02:30 <Ezla> in Haskell asm code
17:02:31 <Cale> Ezla: GHC uses a stack to traverse expressions and find the outermost leftmose reducible expression.
17:02:34 <Ezla> what ends up on the stack?
17:02:39 <Cale> > foldl (+) 0 [1..10000000]
17:02:40 <BMeph> SamB_XP, Ezla: I thought they were in registers. <ducks>
17:02:46 <ksf> Ezla, you can allocate all c locals on the heap, no problem.
17:02:48 <SamB_XP> Ezla: a bunch of junk that would make no sense
17:02:56 <Cale> d'oh, that'll probably get me a thread killed ;)
17:03:00 <lambdabot>   thread killed
17:03:03 <Cale> > foldl (+) 0 [1..1000000]
17:03:05 <Ezla> ksf: Those are pointer types
17:03:15 <SamB_XP> Ezla: no ...
17:03:17 <ksf> imagine, as example, a c implementation running on a lisp machine.
17:03:25 <Cale> Oh, come on... the machine must be busy :)
17:03:31 <ksf> (whyever one would want to do that)
17:03:38 <Cale> Ezla: let me show an example directly...
17:03:41 <nominolo_> Ezla: function arguments land on the stack, just like in C
17:03:42 <Ezla> when you allocate on the heap in C, they are pointer types. there's no "C" about it.
17:03:50 <Ezla> they do not have value semantics
17:03:50 <SamB_XP> ksf: the Lisp Machine users decided they actually wanted to get something done ?
17:04:03 <Ezla> you can't say  p*2 meaningfully
17:04:03 <Cale> Ezla: 'value semantics'?
17:04:05 <SamB_XP> Ezla: you aren't understanding
17:04:21 <SamB_XP> the implementation can store activation records however it likes
17:04:25 <nominolo_> Ezla: if the called function is a known function they may be passed in registers for efficiency
17:04:38 <SamB_XP> it can render them as cheese sculptures if it so desires
17:04:48 <Ezla> nominolo_: Not "may"
17:04:50 <Ezla> but rather, "will"
17:04:57 <Ezla> depending on the calling convention.
17:05:03 <blackh> Ezla: Haskell data types are values, but there are some pointers being used behind the scenes to make "pass by value" efficient.
17:05:08 <nominolo_> Ezla: i'm talking about (GHC) Haskell
17:05:15 <Ezla> ah
17:05:23 <Cale> Ezla: Perhaps more interesting for you would be to see how lazy evaluation works...
17:05:27 <Ezla> yes
17:05:37 <Ezla> I'd rather not argue about C 101
17:05:38 <Cale> I'll do my usual example
17:05:41 <blackh> Ezla: Haskell data types work like the Java String class
17:05:47 <Cale> Consider the function  double x = x + x
17:05:48 <SamB_XP> Ezla: anyway, what ends up on the stack in a given haskell implementation doesn't actually have much to do with the way you think about the code usually ...
17:05:48 <blackh> (if that's any help)
17:05:50 <ksf> I'm going to tell you about it, ezla.
17:05:54 <Cale> and the expression  double (double 5)
17:06:02 <SamB_XP> that is, it doesn't reflect the calls you write directly
17:06:12 <SamB_XP> due to laziness
17:06:15 <ksf> Any questions? Otherwise we're finished.
17:06:17 <Cale> Under strict evaluation, which is the usual sort of evaluation you're probably familiar with, expressions are evaluated innermost-first.
17:06:20 <Ezla> is Double same as double in haskell?
17:06:24 <Ezla> I keep seeing those capped
17:06:29 <Cale> no, I defined a function double there.
17:06:33 <Cale> oh!
17:06:37 <Cale> Double is, yes
17:06:43 <nominolo_> Ezla: all datatypes are uppercase in haskell
17:06:46 <SamB_XP> the C one is called CDouble, actually ...
17:06:48 <ksf> :t 1.0
17:06:49 <Cale> Double is the double-precision IEEE floating point type
17:06:50 <lambdabot> forall t. (Fractional t) => t
17:06:54 <ksf> hmmm
17:06:54 <SamB_XP> @hoogle CDouble
17:06:55 <lambdabot> Foreign.C.Types data CDouble
17:06:58 <ksf> :t 1.0::Double
17:06:59 <lambdabot> Double
17:07:00 <SamB_XP> Cale: MIGHT be
17:07:11 <Ezla> ok Cale maybe that example you used was confusing name wise ;)
17:07:13 <SamB_XP> only isIEEE can tell you
17:07:25 <ksf> > 1%3::Double
17:07:25 <Cale> Ezla: Well, the idea is that this function doubles a number....
17:07:26 <lambdabot>   Couldn't match expected type `Double'
17:07:26 <SamB_XP> > isIEEE (1::Double)
17:07:28 <lambdabot>   True
17:07:39 <Ezla> k, go on
17:07:52 <Cale> Okay, so under strict evaluation, we reduce it like this:
17:07:55 <SamB_XP> and, I suppose it could still maybe not be an IEEE double ...
17:07:56 <Cale> double (double 5)
17:07:58 <Cale> -> double (5 + 5)
17:08:04 <Cale> -> double 10
17:08:07 <Cale> -> 10 + 10
17:08:09 <Cale> -> 20
17:08:14 <Ezla> so far so good
17:08:18 <SamB_XP> Cale: now don't forget the let !
17:08:25 <Ezla> let is lazy?
17:08:32 <Cale> I'm going to do outermost first evaluation next
17:08:35 <Cale> and then lazy
17:08:48 <Cale> So under outermost (leftmost) first evaluation, we get:
17:08:53 <Cale> double (double 5)
17:08:55 <cknapp> Ezla: everything in Haskell is lazy
17:08:59 <Cale> -> (double 5) + (double 5)
17:08:59 <ksf> and somewhere along the line you're going to understand why haskell heads are weak.
17:09:06 <Cale> -> (5 + 5) + (double 5)
17:09:13 <Cale> -> 10 + (double 5)
17:09:18 <Cale> -> 10 + (5 + 5)
17:09:20 <Cale> -> 10 + 10
17:09:23 <Cale> -> 20
17:09:41 * SamB_XP smashes some heads together
17:09:50 <Ezla> you lost me on the first step
17:10:00 <Cale> double x = x + x
17:10:01 <Ezla> how can that take place, when it has to "get the 5"
17:10:02 <Cale> So:
17:10:11 <Cale> double (double 5) = (double 5) + (double 5)
17:10:14 <nominolo_> Ezla: it's _outermost_
17:10:32 <Cale> double (foo 5) = foo 5 + foo 5
17:10:48 <Cale> for any function foo :)
17:10:51 <Ezla> ah k
17:11:21 <Cale> But notice that we ended up evaluating double 5 twice
17:11:30 <Ezla> yes
17:11:37 <Cale> This is because it got duplicated, because x occurred more than once in the body of double.
17:12:14 <Cale> So lazy evaluation is an optimisation of this: if a parameter to a function occurs more than once in the body, the result of evaluating it (if it ever gets evaluated) is shared between the copies.
17:12:28 <Cale> I'm going to use  let ... in ...  to represent the sharing.
17:12:32 <Ezla> and that's automatic?
17:12:34 <Cale> yes
17:12:41 <Ezla> but
17:12:44 <Ezla> the last example
17:12:48 <Cale> In a machine implementation, it would be multiple pointers pointing to the same thing.
17:12:50 <Ezla> was "not right haskell" ?
17:13:01 <Ezla> that's NOT how haskell does it?
17:13:07 <Cale> The last example isn't *quite* how Haskell does it.
17:13:09 <Ezla> Or you mean you have to use let to get lazy
17:13:13 <Ezla> oh
17:13:16 <cknapp> It's almost lazy...
17:13:17 <Cale> I'm about to show how lazy evaluation does it.
17:13:26 <ksf> it's not how any self-respecting haskell implementation would do it.
17:13:32 <Cale> It just saves you from doing the repeated work.
17:13:39 <SamB_XP> ksf: I don't think it's even legal ???
17:13:42 <Cale> double (double 5)
17:13:47 <Ezla> as long as x is pure
17:13:48 <Cale> -> let x = double 5 in x + x
17:13:54 <ksf> haskell is only specified as non-strict, not as lazy.
17:13:55 <Cale> -> let x = 5 + 5 in x + x
17:13:59 <Cale> -> let x = 10 in x + x
17:14:04 <Cale> -> 20
17:14:42 <Ezla> weird
17:14:48 <Cale> ksf: Right, and for that reason, it *could* use plain outermost-first evaluation, but all present serious implementations do lazy evaluation.
17:14:50 <BMeph> Okay, NM, GHC did some conventional, but inconvenient stuff in  .10.1
17:15:07 <Cale> Ezla: Now let's have a look at an example where laziness helps a bit.
17:15:39 <Cale> Ezla: Do you know about 'map'?
17:15:45 <Ezla> yes
17:15:47 <Cale> okay
17:15:58 <cknapp> I love this channel... I learn so much... I'm like Pinocchio "Someday I'm gonna be a real haskell programmer"
17:16:25 <Cale> So let's look at something like computing   length (map factorial [100,200,300])
17:16:48 <Cale> I'll use the naive definition of length:
17:16:52 <Cale> length [] = 0
17:16:58 <Cale> length (x:xs) = 1 + length xs
17:17:04 <Ezla> lost me
17:17:07 <Ezla> what's [] ?
17:17:11 <Cale> the empty list
17:17:15 <Ezla> and = 0 ?
17:17:21 <ksf> equals zero.
17:17:25 <Cale> length [] = 0  means that the length of an empty list is 0
17:17:26 <_pizza_> hehe
17:17:28 <Ezla> empty list equals 0 ?
17:17:37 <Ezla> why state that?
17:17:39 <_pizza_> no, length [] = 0
17:17:42 <nominolo_> the "length of an empty list equals 0"
17:17:46 <Cale> Ezla: Because it's the recursive base case.
17:17:55 <Ezla> Cale: gotcha
17:18:09 <Ezla> so you're saying
17:18:15 <Cale> (x:xs) means a nonempty list whose first element is x and whose tail is called xs
17:18:16 <Ezla> length[] is a *function*
17:18:18 <Ezla> returning 0
17:18:20 <Cale> length is a function
17:18:36 <cknapp> when applied to [] it returns 0
17:18:36 <Cale> length, when applied to [], gives 0
17:18:44 <Ezla> (length) or (length []  // with a list) is a function?
17:18:54 <nominolo_> Ezla: haskell allows you to write multiple definitions of a function if they apply to different cases
17:19:03 <Ezla> right
17:19:06 <Cale> Applying a function to its parameters in Haskell is just done by writing them next to the function name.
17:19:08 <nominolo_> Ezla: it's still the same function
17:19:22 <Cale> length [] is a number
17:19:28 <Cale> (in particular, the number 0)
17:19:36 <ksf> > length []
17:19:37 <lambdabot>   0
17:19:38 <Ezla> ok
17:19:52 <BMeph> cknapp: Have you seen the SAPL ('continuationy') style for lists? ;)
17:20:08 <Cale> So the next part of the definition:
17:20:12 <Cale> length (x:xs) = 1 + length xs
17:20:15 <pjdelport> Ezla: read "length [] = 0" as "define the length of [] to be 0"
17:20:16 <Ezla> which was the parameter?
17:20:17 <Ezla> [] ?
17:20:22 <Cale> Ezla: yeah
17:20:27 <cknapp> BMehp: No. I haven't... I'm afraid... in a "can't look away" kind of way...
17:20:31 <Ezla> how can a parameter be a constant?
17:20:40 <ksf> > length 1:2:[]
17:20:41 <lambdabot>       No instance for (Num [a])
17:20:41 <lambdabot>        arising from the literal `1' at <inter...
17:20:44 <_pizza_> it's a pattern
17:20:48 <pjdelport> Ezla: it's a pattern match
17:20:55 <ksf> hep
17:20:57 <ksf> hey
17:21:08 <cknapp> Think of it like a function in math.... f(x) = {if x=0, 0, else {something}}
17:21:12 <ksf> > length (1:2:[])
17:21:12 <Cale> Ezla: Haskell will match the list which length is applied to against each of the cases we write, and the first one which applies gets to produce its result.
17:21:13 <lambdabot>   2
17:21:14 <_pizza_> if you call length with one list parameter and that list is empty, the function returns the number 0
17:21:18 <Ezla> what's (x:xs) ?
17:21:30 <ksf> look at what i told lambdabot.
17:21:33 <_pizza_> another pattern
17:21:34 <Cale> Ezla: (x:xs) means a nonempty list whose first element is x, and whose tail is another list called xs
17:21:44 <Ezla> where did x come from?
17:21:45 <Cale> > 1 : [2,3,4,5]
17:21:47 <lambdabot>   [1,2,3,4,5]
17:21:47 <Ezla> and xs
17:21:55 <Ezla> are those arbitrary?
17:21:55 <Cale> > let f (x:xs) = x in f [1,2,3,4,5]
17:21:57 <lambdabot>   1
17:22:00 <Cale> they're arbitrary
17:22:21 <Cale> We could write  length (firstElement : restOfList) = 1 + length restOfList
17:22:26 <BMeph> cknapp: In SAPL, they take ADTs, and convert 'em to functions that take multiple arguments based on the constructors, like this:
17:22:42 <ksf> > let f (x:xs) = (x,xs) in f [1,2,3,4,5]
17:22:44 <lambdabot>   (1,[2,3,4,5])
17:22:56 <nominolo_> BMeph: it's called Church encoding, or Scott encoding
17:23:11 <Ezla> what does :  mean?
17:23:27 <ksf> @src :
17:23:27 <lambdabot> Source not found. Maybe you made a typo?
17:23:30 <nominolo_> add to beginning of list
17:23:30 <ksf> @src (:)
17:23:31 <lambdabot> Source not found. I am sorry.
17:23:33 <nominolo_> pronounced "cons"
17:23:34 <ksf> :t (:)
17:23:35 <lambdabot> forall a. a -> [a] -> [a]
17:23:37 <_pizza_> Ezla: it's going to be hard to learn the entire language through irc; i suggest reading a tutorial
17:23:41 <Cale> Ezla: It's an infix operator which adds an element to the start of the list.
17:23:43 <ksf> :t (:[])
17:23:44 <BMeph> nil :: List a; nil = \f g -> f; cons :: a -> List a -> List a; cons x xs = \f g -> g x xs
17:23:45 <lambdabot> forall a. a -> [a]
17:23:54 <ksf> :t (1:)
17:23:55 <lambdabot> forall t. (Num t) => [t] -> [t]
17:23:59 <Cale> Ezla: for example:
17:24:00 <pjdelport> Ezla: see http://hpaste.org/12679
17:24:03 <Cale> > 1 : [2,3,4,5]
17:24:04 <lambdabot>   [1,2,3,4,5]
17:24:04 <ksf> :t (1:[])
17:24:05 <BMeph> nominolo_: Right, Scott encoding.
17:24:06 <lambdabot> forall t. (Num t) => [t]
17:24:23 <nominolo_> BMeph: what is SAPL?
17:24:24 <cknapp> BMeph: hold on a minute, I'm doing like 10 things at once right now...
17:24:40 <Cale> Ezla: Every list in Haskell is either the empty list [], or it is a nonempty list obtained by adding an element to the start of another list with :
17:25:06 <Cale> Ezla: So functions which act on lists can be defined in terms of these two cases.
17:25:26 <Ezla> can you append, or does the base case have to go right->left ?
17:25:40 <Cale> Adding to the end of a list is costly.
17:25:44 <Ezla> why
17:25:47 <Cale> But of course you can do it.
17:25:54 <Cale> Because the whole list has to be rebuilt.
17:26:03 <ksf> because cale didn't import stream fusion.
17:26:32 <Cale> If you add to the start of a list, then the new list that you get can be represented in memory as a structure with a pointer to the first element and a pointer to the tail.
17:26:41 <Cale> (which is just the original list)
17:26:46 <cknapp> BMeph: Ok. that makes sense.
17:26:47 <BMeph> nominolo_: It's an intermediate language that Clean folks use. They also use it to convert Haskell and Clean to a common "Core" - just more friendly to the Clean way of doing things. :)
17:26:52 <ksf> ...in naive implementations.
17:26:54 <Ezla> cant it be the same
17:26:55 <Ezla> on the end
17:26:59 <Cale> If you add to the end, then you need to rebuild all the cells.
17:27:28 <Cale> Well, not only that, but it takes many steps to find your way to the end of the list:
17:27:36 <cknapp> Ezla: since the end is empty, you'd get the empty list somewhere in the middle...
17:27:36 <nominolo_> BMeph: ah, so they convert each data constructor into a closure and each case into an application
17:27:39 <Cale> addToEnd x [] = [x]
17:27:49 <Cale> addToEnd x (y:ys) = y : addToEnd x ys
17:28:05 <Cale> It would look something like that.
17:28:10 <Ezla> I may be asking adequate questions, but I thought, maybe I'll ask a few things on #Haskell before I pass out. I am literally falling over in the middle of this lesson and I think I'll be asleep within 60 seconds
17:28:17 <Cale> Of course, more generally, we have a function which appends two lists.
17:28:18 <nominolo_> BMeph: i wonder how that works out if you have lots of constructors
17:28:18 <Ezla> to be continued!
17:28:28 <Cale> Ezla: Okay!
17:28:34 <cknapp> Ezla! Good night
17:28:56 <nominolo_> @localtime Ezla
17:28:57 <lambdabot> Local time for Ezla is Wed Dec 03 17:28:54 2008
17:28:59 <BMeph> cknapp: This is the definition for length :: List a -> Int; length xs = xs 0 (\y ys -> 1 + length ys). Freaky-sneaky, eh? ;)
17:29:32 <Cale> BMeph: That's just the usual Church encoding then?
17:29:58 <Cale> Er, is it also called Scott encoding?
17:29:59 <cknapp> Cale: that's what it looks like to me... is that right?
17:30:00 <nominolo_> :t fix $ \length xs = xs 0 (\y ys -> 1 + length ys)
17:30:02 <lambdabot> parse error on input `='
17:30:04 <ksf> wwwwawait, where's the fold?
17:30:09 <nominolo_> :t fix $ \length xs -> xs 0 (\y ys -> 1 + length ys)
17:30:10 <lambdabot>     Occurs check: cannot construct the infinite type:
17:30:10 <lambdabot>       t = t1 -> (t2 -> t -> t3) -> t3
17:30:10 <lambdabot>     Probable cause: `xs' is applied to too many arguments
17:30:18 <nominolo_> right, that's the problem
17:30:26 <BMeph> nominolo_: You get a lot of high-argument functions! Whoo! ;)
17:30:28 <Cale> ah, that's the difference.
17:30:45 <nominolo_> BMeph: is SAPL typed?
17:31:07 <BMeph> Cale, cknapp: Yes, it's Scott encoding. I just found that out from a footnote on one of "the Dutchmen"'s papers. :)
17:31:12 <nominolo_> looks like they need equirecursive types instead of isorecursive
17:31:17 <BMeph> nominolo_: I think not. :)
17:32:17 <cknapp> BMeph: what's so "sneaky about it?" that it turns everything around on us?
17:32:31 <cknapp> *"sneaky" : rest
17:33:06 <Cale> I think Haskell should steal Charity's generalised catamorphism construct.
17:33:42 <BMeph> cknapp: I just like HOF making things all concise and clear at once. :)
17:34:19 <nominolo_> a case would be just as clear
17:34:38 <nominolo_> but it's almost just a syntactic transformation
17:35:01 <Cale> (though perhaps not with quite the same syntax as Charity uses)
17:35:19 <gwern> 'Whenever two programmers meet to criticize their programs, both are silent.'
17:37:59 <nominolo_> http://instantcrickets.com/
17:38:04 <lambdabot> Title: Instant Crickets
17:38:16 <cknapp> If I'm constructing a list, and I just want an arbitrary element, is it best to take the head and throw away the tail, or the last, and throw away init?
17:38:38 <skorpan> cknapp: the head
17:39:28 <cknapp> Ok, I figured, but I wasn't sure if it built the list from the bottom...
17:40:13 <cknapp> Oh! It goes f(x) : f(xs)... and it doesn't need f(xs), so trows it out?
17:40:24 <Cale> cknapp: Because functions are applied outermost-first, it's always the first element which is available first.
17:41:06 <cknapp> (where f is a magic function that applies to both lists and elements, and trow means throw :D )
17:41:12 <Cale> for example, let's say we evaluate map f [1,2,3] -- this reduces to f 1 : map f [2,3]
17:41:24 <Cale> and the map f [2,3] might never be computed if you only need the head of the list
17:41:26 <ksf> gnnnnnargh
17:41:34 <ksf> just use stream fusion and don't care.
17:41:39 <cknapp> Cale: So what I already said? :)
17:41:49 <ksf> it moves all the y's outermost.
17:42:38 <Cale> ksf: Even with stream fusion, it's important to understand evaluation in order to know how things are going to perform :)
17:42:59 <Cale> and the head of a stream is still more quickly accessible than its last element.
17:43:14 <ksf> sure, but you don't pay high prizes for append and the like.
17:43:41 <nominolo_> stream fusion still has some problems with concatMap
17:43:53 <ksf> gotta have a look at the source, though.
17:46:46 <ksf>     next (Left s1)  = case next0 s1 of
17:46:46 <ksf>                           Done        -> Skip    (Right s02)
17:46:57 <ksf> yeah it gets completely... erm... "inlined".
17:47:23 <Cale> Most of the useful functions on streams are not recursive.
17:47:32 <Cale> So they inline nicely.
17:50:07 <ksf> even recursive ones inline, they're aggregated.
17:56:50 <BMeph> Cale: Do you think think in Haskell would be improved by specifying use of coinductive types? :)
17:57:16 <wchogg> BMeph:  It would certainly be cool mathematically to make that type level distinction.
17:57:53 <BMeph> wchogg: Would it? Isn't that what comonads do, in a way? :)
17:58:09 <BMeph> Or is that what comonads /are/? :)
17:59:16 <wchogg> BMeph:  Well, in CPO there's an identification between data & codata that you don't get if you move to the Set topos instead, y'know?
18:00:20 <Saizan_> the Stream comonad is a coinductive type, but many others aren't
18:01:17 <Saizan_> and Stream is also a monad btw
18:02:40 <BMeph> Saizan_: Well, if you chuck the empty lists, that works as a subset of streams, right? :)
18:03:29 <BMeph> wchogg: Interesting. I'm about two years of really getting what CPO implies, though. :)
18:03:40 <Saizan_> uh? streams are infinite lists
18:04:40 <SamB_XP> are we not all talking about the same Stream ?
18:04:45 <BMeph> Saizan_: Streams are infinite lists, but some forms of streams let you do more things than you can with lists, e.g., Skip. :)
18:06:23 <Saizan_> i just don't find a strong connection between codata and comonads
18:06:45 <BMeph> Is Stream based on a fixpoint of Either, vice Maybe, is that how it works?
18:07:36 <BMeph> Saizan_ I can't help but see it, but I really need to sit down and learn CT and its basis subjects, so my opinion is normal (i.e., worthless). :)
18:08:22 <cknapp> What's the point of mapMonotonic in Data.Set?
18:09:32 <Saizan_> cknapp: that the implementation doesn't have to rebuild the internal representation from scratch
18:09:48 <Saizan_> cknapp: so it's O(n) instead of O(n log n)
18:09:52 <cknapp> Ah!
18:10:45 <cknapp> Why does it only work on a monotonic function?
18:11:11 <wchogg> So it doesn't screw up the ordering?
18:11:56 <Saizan_> since if you apply a monotonic function to sorted elements they will remain sorted
18:12:23 <Saizan_> and Set is implemented as a balanced search tree
18:12:41 <cknapp> That makes sense
18:15:55 <cknapp> If I have a set of (x,y) pairs, is there a clever way to get the element with the smallest y, or is "findMin.map snd set" the best way?
18:16:07 <ksf> I'm still looking for a book titled "Categories for programmers".
18:16:21 <cknapp> Wait...d oes that even work?
18:16:29 <ksf> One that doesn't use abstract numerical nonsense as examples.
18:17:04 <wchogg> Not a math guy?
18:17:17 <ksf> not an analysis guy.
18:17:26 <ksf> I'm fine with discrete math.
18:17:49 <wchogg> The Handbook of Categorical Algebra series doesn't really use a lot of analysis in its examples.
18:18:13 <wchogg> Also, did you try reading Pierce's Category Theory primer?
18:18:39 <ksf> In fact, I judged all mathematicans insane as the lecturer said "...so our result equals infinite times zero and therefore, no, not everything, but the thing we were looking for"
18:19:03 <ksf> smells like teabag-swinging to me.
18:19:35 <cknapp> ksf: where did the infinity comefrom and where did the zero?
18:19:41 <cknapp> Which was "bigger"?
18:19:44 <lament> proof by undefined behaviour
18:19:53 <lament> cknapp: i'm pretty sure the infinity was bigger :)
18:19:54 <ksf> integrals.
18:20:02 <SamB_XP> ah, so, if my code summons a daemon I can claim that it works ?
18:20:08 <QtPlatyp1s> ksf: That doesn't sound right as no mathematican would say that unless they where sort of joking.
18:20:17 <cknapp> By bigger, I meant which approached the limit faster.
18:20:23 <wchogg> SamB_XP:  I think you can claim anything you want when you can summon daemons
18:20:38 <lament> SamB_XP: if your code sumons a daemon, and you live to tell the tale...
18:20:52 <Saizan_> cknapp: minimum . map snd . toList $ set, would be more efficient
18:21:00 <SamB_XP> what if it is just a mail daemon ?
18:21:11 <cknapp> Saizan: Thanks
18:21:15 <lament> then you should stone it with a rubber chicken
18:21:23 <wchogg> SamB_XP:  is that the kind that fills my box with catalogs?
18:21:31 <SamB_XP> how about just hitting it with a scroll of mail ?
18:21:44 * ksf hopes that those google previews are complete.
18:22:31 <lament> SamB_XP: that would be a waste of a daemon
18:25:21 <ksf> well it's a mathematician trying to beat analysis into heads of people who don't care about math.
18:26:10 <wchogg> I spent a few semesters beating physics into the heads of people who didn't care about that, so it's a position I sympathize with.
18:26:31 <SamB_XP> it seems like rather a waste to do that sort of thing
18:26:39 <ksf> he was even more fun in microcontrollers, him being used to face electronic guys and trying to explain to us how to program.
18:27:12 <ksf> we listened for two hours, mouths gaping at how painfully explicit you can explain the most obvious stuff.
18:27:38 <wchogg> SamB_XP:  it's the wonders of required intro classes
18:28:25 <SamB_XP> now ENGR 111 ... that's really a waste ...
18:33:09 <ksf> actually, I have to check whether tales of me are still told on campus.
18:34:13 <SamB_XP> of you ?
18:34:21 <SamB_XP> why would they tell tales of you ?
18:35:01 <ksf> as in "the guy who told the assembly instructor of x86 instructions he didn't know"
18:35:51 <bd_> ksf: That doesn't sound overly difficult.
18:35:59 <ksf> as in "the guy who managed to make the sociology instructor admit that we actually live in an anarchy and not a constitutional state"
18:36:30 <cknapp> Admit?
18:37:09 <nn-main> SamB_XP, hi
18:37:26 <ksf> well there's the ideal of the ideal state, incorporated by the system of the federal republic that he wanted us to learn about, and then there's... a lot of stuff.
18:37:51 <ksf> as we say around here, a fish starts to stink at the head.
18:38:07 <SamB_XP> nn-main: what brings you here ?
18:38:09 <cknapp> Where is "here"?
18:38:22 <cknapp> (that was for ksf)
18:38:25 <wchogg> ksf:  So what books on categories did you try & not like?
18:38:45 <ksf> here is next to hamburg.
18:39:12 <ksf> it's an idiom anywhere in germany more or less near the coast.
18:39:12 <nn-main> SamB, Bordum and the fact that I have gotten my site in shape and would like to chat
18:39:25 <SamB_XP> ksf: hmm, why is it surprising if you tell the x86 teacher about instructions he doesn't know ?
18:39:33 <SamB_XP> there are a heck of a lot of x86 instructions!
18:39:49 <cknapp> Deustchland ist eine Anarchie? I'd live to hear more.... but now probably isn't the best time.
18:39:52 <ksf> I've got the joy of cats and actually like it, but can't really learn the cs applications from it without grokking the whole book.
18:40:09 <ksf> it was "enter" and "leave".
18:40:48 <ksf> he was also asking what "xor eax, eax" does.
18:41:03 <pizza_> heh
18:41:24 <ksf> the point is mainly that out of those who surpassed him, i was the one who didn't have any pity.
18:45:34 <nn-main> Yay my old gentoo celeron fianlly finished compileing ghc so now how do I go about making lambdabot
18:46:30 <Cale> nn-main: Why did you compile GHC yourself?
18:46:59 <nn-main> gentoo, does it automatically
18:47:08 <BMeph> ksf: You mean he was asking to make sure the students knew it, of course... o.O
18:48:02 <Cale> nn-main: Basically, compiling GHC is usually a waste of time unless you're working on it. There are nice binaries available for a lot of platforms, and you need GHC to be able to compile it anyway.
18:48:37 <ksf> cknapp, bavaria, smoking clubs, and the recent new law that a) "put an end to them" (headlines, csu pov) b) made them unnecessary again (everybody's, and also csu pov, but on administrative and legislative levels)
18:48:49 <Cale> nn-main: I would recommend getting cabal-install from Hackage
18:49:02 <Cale> nn-main: Once you have that, you should be able to cabal install lambdabot
18:49:29 <ksf> at the end of the day, everyone just does what he get's away with.
18:52:11 <cknapp> ksf, I don't follow. Sorry, I'm not German, nor do I follow current events. Could you explain more?
18:53:24 <nn-main> SamB, SamB_XP,,, You Here ?
18:55:27 <nn-main> !test
18:55:42 <nn-main> lambdabot, help
18:55:53 <nn-main> > help
18:55:54 <lambdabot>   Not in scope: `help'
18:56:20 <nn-main> @help
18:56:20 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:56:25 <nn-main> @help list
18:56:25 <lambdabot> list [module|command]
18:56:26 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
18:56:42 <nn-main> @help list command
18:56:43 <lambdabot> list [module|command]
18:56:43 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
18:56:45 <nn-main> @help list commands
18:56:46 <lambdabot> list [module|command]
18:56:46 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
18:57:29 <nn-main> @dict hellow
18:57:30 <lambdabot> Supported dictionary-lookup commands:
18:57:30 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
18:57:30 <lambdabot> Use "dict-help [cmd...]" for more.
18:57:47 <nn-main> @all-dict hellow
18:57:48 <lambdabot> No match for "hellow".
18:57:51 <nn-main> @all-dict hi
18:57:52 <lambdabot> *** "HI" gcide "The Collaborative International Dictionary of English v.0.48"
18:57:52 <lambdabot> Hydriodic \Hy`dri*od"ic\, a. [Hydr- + iodic: cf. F.
18:57:52 <lambdabot>    hydriodique.] (Chem.)
18:57:52 <lambdabot>    Pertaining to, or derived from, hydrogen and iodine; -- said
18:57:52 <lambdabot>    of an acid ({HI}) produced by the combination of these
18:57:54 <lambdabot> [37 @more lines]
18:58:04 <nn-main> wow this bot is cool
18:58:27 <BMeph> nn-main: You ain't seen nothin' yet! ;)
18:58:38 <BMeph> @oeis 1 1 2 4 9 20
18:58:39 <lambdabot>  Number of rooted trees with n nodes (or connected functions with a fixed poi...
18:58:39 <lambdabot>  [0,1,1,2,4,9,20,48,115,286,719,1842,4766,12486,32973,87811,235381,634847,172...
18:59:23 <FunctorSalad> ksf: I agree you probably judged all mathematicians insane by a joke the lecturer was making
18:59:34 <BMeph> nn-main: Not that that was representative, or anything, I just like the sequence. ;)
18:59:53 <ksf> ah. bavaria passed a law that forbade smoking in pubs and restaurants completely if they weren't big enough to seperate smoking/non-smoking areas, innkeepers and their customers didn't like it and transformed the inns into clubs, with membership and everything, to work around it, the administration actually gave them the hint... the local party then saw that nothing made any sense and sensed a good opportunity, rewrote the law to allow small inns
18:59:53 <ksf> to be designated as smoking inns (prohibiting minors to enter even if accompanied by a guardian), portrayed themselves as harsh law-and-order, stomping all those clubs.
19:00:55 <ksf> FunctorSalad, wanna argue about the existence of pi?
19:01:05 <FunctorSalad> nah
19:01:10 <kynky> if pi doesnt exist e doesnt exist too
19:01:33 * Cale works only in Q[e]
19:01:33 <ksf> the golden ratio neither, which'd be a graver loss.
19:01:46 <FunctorSalad> but regarding that infinity thing... you can think whatever you like about math, but what we *do* get right is definitions
19:01:48 <cknapp> ksf: the golden ratio is aglebraic. :)
19:01:55 <ikkebr> @oeis 0 1 1 2 3 5
19:01:57 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
19:01:57 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
19:02:02 <ikkebr> @oeis 0 1 1 2 3 5 10 20 50
19:02:03 <lambdabot>  Sequence not found.
19:02:07 <ikkebr> ahw :p
19:02:10 <cknapp> So, I disagree that it gets thrown out with pi and e
19:02:21 <FunctorSalad> if the lecturer used infinity in a funny handwavy way, he was joking or considered it not relevant to the lecture
19:02:59 <lament> the only numbers that exist are odd positive integers, except 15
19:03:09 <BMeph> @oeis 1 2 3 5 9 15 25
19:03:09 <lambdabot>  Smallest label f(T) given to a rooted tree T with n nodes in Matula-Goebel l...
19:03:09 <lambdabot>  [1,2,3,5,9,15,25,45,75,125,225,375,625,1125,1875,3125,5625,9375,15625,28125,...
19:03:18 <cknapp> lament: Not closed under addditoin
19:03:26 <lament> cknapp: it's not meant to be.
19:03:28 <Axman6> lament: 15 doesn't exist? makes sense to me
19:03:31 <ksf> well... areas get smaller, so they lim->0, their number gets bigger so they lim->Infinity, what comes out of it is the area under that wiggly line on the blackboard.
19:03:38 <kynky> lament, that sentance doesnt make sense, what is 15 ?
19:03:57 <FunctorSalad> ksf: limits have a precise definition
19:04:06 <lament> kynky: 15 is a made-up mathematical object, just like pi, e, and Hask
19:04:10 <BMeph> kynky: MU! ;p
19:04:17 <FunctorSalad> don't confuse the intuition help he's trying to give with the actual formalism
19:04:19 <lament> 13, on the other hand, actually exists.
19:04:26 <pizza_> whew
19:05:31 <lament> ksf: is that complex analysis?
19:05:45 <ksf> still, I'm constructivist. the abstraction isn't lossless, therefore bunk... it might be sufficiently defined for this case, though, i have no idea.
19:06:12 <lament> what abstraction isn't lossless?
19:06:18 <lament> limits??
19:06:18 <ksf> lament, integrals.
19:06:20 <lament> um.
19:06:25 <FunctorSalad> loss is the whole point of abstraction.
19:06:27 <cknapp> ksf: looked into non-standard analysis?
19:06:28 <lament> i'm not sure what you mean by that, but you're wrong
19:06:35 <ksf> nah, encapsulation is the point.
19:06:37 <FunctorSalad> I think it's even in the etymology of the word
19:06:54 <ddarius> I think by "lossless" he means "leaky"
19:06:59 <Cale> If you don't lose structure by abstracting, then you haven't abstracted.
19:07:19 <FunctorSalad> wiki: "Abstraction is the process or result of generalization by reducing the information content of a concept or an observable phenomenon, typically in order to retain only information which is relevant for a particular purpose."
19:07:27 <ddarius> Actually, I have no idea.
19:07:36 <ddarius> I'm going to go back to burning myself.
19:07:42 <lament> ksf: you got a bunch of mathematicians confused
19:07:42 <FunctorSalad> have fun :)
19:07:51 <ksf> well, without further info, lim->0 * lim->Infinity is anything you want.
19:08:15 <dons> Igloo: awesome work on the darcs/camp post today
19:08:18 <dons> excellent work.
19:08:22 <FunctorSalad> again, limits have a watertight definition (unless you're going to question FOL itself)
19:08:28 <cknapp> ksf: but the problem at hand probably had extra information...
19:08:29 <lament> ksf: that's like saying, without further info a+b is anything you want
19:08:30 <lament> ksf: DUH!
19:08:41 <ksf> the question is whether or not there's enough info _behind_ the abstraction left to still instanciate concrete things.
19:08:54 <cknapp> ksf: There is.
19:09:05 <kynky> so a limit being defined as a positive result, is a defined limit ?
19:09:06 <lament> ksf: the nice thing about math is that it's quite easy for you to just go and check.
19:09:23 <cknapp> that infinity and that zero didn't just apear out of nowhere, they were the value of some function
19:09:40 <kynky> and you have orders of inifinity too
19:09:41 <nn-main> @poll-list
19:09:41 <lambdabot> ["test"]
19:09:48 <lament> i think he's talking about infinity and zero in the definition of the integral
19:09:59 <ksf> lament, yes.
19:10:09 <cknapp> kynky: that's not entirely relevant
19:10:47 <kynky> i had fun typing it :)
19:10:50 <Cale> The one true definition of the Riemann integral is Darboux's :)
19:10:57 <Cale> http://en.wikipedia.org/wiki/Darboux_integral
19:10:59 <lambdabot> Title: Darboux integral - Wikipedia, the free encyclopedia
19:11:19 <lament> ksf: if you don't understand why limits work (and they do), just read about limits.
19:11:43 <lament> in say wikipedia.
19:11:49 <Cale> You don't even need limits. You just need sup and inf
19:12:07 <cknapp> ksf: Saying that infinity * zero doesn't make sense in math, like saying that [1..] doesn't work in Haskell, because it's an infinite type.
19:12:08 <Cale> (of a set of real numbers)
19:12:20 <lament> Cale: hopefully if you understand one you understand the other
19:12:35 <FunctorSalad> ksf: the details of integration have been studied in extreme detail. it's called measure theory
19:12:38 <Cale> well, yes, but I see sup and inf as more fundamental
19:12:55 <FunctorSalad> (well, measure theory is the fundament I mean)
19:12:58 <lament> Cale: ohh, i think that's the definition we had in real analysis
19:13:02 <ksf> well we learned it in a semester, without any backing theory.
19:13:28 <Cale> lament: Yeah, that was (quite thankfully) our Calc 1 definition :)
19:13:34 <FunctorSalad> for my taste the detail is almost excessive
19:13:34 <nn64> hi
19:13:45 <nn64> I'm what was nn-main
19:13:58 <cknapp> hello again
19:14:00 <FunctorSalad> (you figure out just how weird and pathological a function can still be in order to be able to define the integral ;))
19:14:02 <lament> ksf: that's the problem with many math courses, yes
19:14:12 <nn64> I installed cabel but it seems to be a library not a application
19:14:44 <nn64> *cabal
19:14:48 <lament> ksf: it's probably rather important to understand limits, though
19:14:58 <gwern> nn64: indeed.
19:15:04 <Cale> nn64: It's both. Cabal is the library, cabal-install is the application.
19:15:09 <gwern> nn64: cabal = the library, cabal-install = the app
19:15:10 <Axman6> nn64: you want cabal-install
19:15:26 <ksf> lament, yes. basically, I was unable to admit that I understand the stuff as I couldn't express it as a terminating sum.
19:15:27 <gwern> nn64: people are very loose with their phrasing however, so usually the difference isn't clear
19:15:43 <FunctorSalad> ksf: you're right that (some limit that is infinity) * (some limit that is zero) doesn't make sense. it's sloppy notation
19:16:02 <FunctorSalad> actually you just have one limit with products under the limit
19:16:15 <FunctorSalad> and you can't multiply it out if they don't both converge
19:16:30 <lament> ksf: so you don't understand real numbers either, just because their representations tend to be infinite?
19:17:24 <nn64> well acording to gentoo there is no ebuild in there emerge system called cabal-install? so Im a bit confused
19:17:34 <lament> ksf: even when it's something like 0.333... ?
19:17:45 <ksf> not in the same way I understand integers, no.
19:18:00 <lament> well. That's not really a problem with math :)
19:18:15 <ksf> 0.333... * 3 is an interesting case, already thought about it in primary school.
19:18:21 <gwern> nn64: maybe the gentoo devs just haven't gotten to it; there are not many
19:18:27 <Cale> It's rather obnoxious when people deny that various mathematical objects exist, when there are formal proofs of their existence, and outside those formal systems their existence doesn't actually mean anything.
19:18:49 <nn64> they had the package called cabal
19:19:03 <nn64> just not cabal-install
19:19:08 <ksf> Cale, as long as you type them such I won't call you a heretic.
19:19:09 <FunctorSalad> Cale: aren't you declaring victory for formalist philosophy there?;)
19:19:14 <gwern> Cale: whence the platonists then? if one asserts they have independent existence, the flip side would seem to be denying their existence...
19:19:31 <lament> the platonists are equally obnoxious.
19:19:32 <Cale> Platonism is dead.
19:19:42 <FunctorSalad> but cognitivism isn't ;)
19:19:49 <gwern> but - but netcraft hasn't confirmed it yet!
19:19:50 <ddarius> Cale: See Penrose.
19:20:06 <roconnor> ghc doesn't exist
19:20:25 <loriel> Not according to netcraft, anyway.
19:20:26 <ksf> So... There's a conspiracy ruling my life that's proven to exist because I can't prove it?
19:20:58 <FunctorSalad> ksf: if you like a more pragmatic argument, integration has been of great usefulness in the sciences
19:21:17 <gwern> ksf: well, a conspiracy good enough to rule your life would ensure you couldn't prove it
19:21:22 <FunctorSalad> continuity is a convenient fiction if nothing else
19:21:57 <centrinia> You don't really need real numbers to evaluate a lot of useful definite integrals. :)
19:22:06 <Cale> FunctorSalad: Well okay, what does it mean for, say, sqrt(2), to "exist", if not in the formal mathematical sense?
19:22:06 <ksf> exactly. newton is dead, plank units rule the universe, so what's continuity for?
19:22:11 <lament> it's hard to get anywhere without real numbers
19:22:42 <kynky> think its cool that the tower of powers of sqrt(2) = 2
19:22:44 <lament> ksf: to be able to evalute integrals, duh.
19:22:46 <centrinia> lament: What is wrong with jumping the irrational gaps between rational numbers? :)
19:23:04 <Cale> ksf: L^2(R)
19:23:40 <lament> L^2(R) does have the same properties regardless of whether newton is dead or alive
19:23:43 <ddarius> @google "Discrete analysis"
19:23:46 <lambdabot> http://www.math.rutgers.edu/~zeilberg/mamarim/mamarimhtml/real.html
19:23:46 <lambdabot> Title: "Real" Analysis is a Degenerate Case of Discrete Analysis
19:24:04 <gwern> ksf: a perfect conspiracy would render you unable to prove their existence, as that is a logical extension of secrecy; it is more perfect for a conspiracy to exist than not; therefore the conspiracy exists.
19:24:10 <centrinia> Cale: The square root of 2 is said to exist as the distance between opposite vertices on an unit square. :)
19:24:20 <lament> gwern: perfect
19:24:37 <Cale> centrinia: Oh? What's a unit square, if not a formal mathematical object?
19:24:51 <ksf> gwern, so you admit that formalists are tinfoil-hat wearing crackpots?
19:24:59 <gwern> lament: no, what's perfect is that I can prove the conspiracy exists, but ksf can't even if he uses my proof, since he proving their existence would contravene their perfection
19:25:04 <FunctorSalad> Cale: admittedly, "existence" in natural language is a messy topic so we'd better just use that word inside formalisms ;(
19:25:13 <FunctorSalad> s/;(/;)
19:25:22 <lament> gwern: yes, that's beautiful indeed
19:25:41 <Cale> And now... CARROTS! http://upload.wikimedia.org/wikipedia/commons/3/32/Carrots_of_many_colors.jpg
19:25:43 <lambdabot> http://tinyurl.com/kd9u8
19:25:46 <ksf> maybe I might just be refusing to form an opinion about a thing i can't prove.
19:25:48 <lament> gwern: can the conspiracy create a rock that it couldn't lift?
19:26:10 <ksf> to avoid ending up running around on cons, wearing a tinfoil hat.
19:26:18 <gwern> lament: but the same logic applies to me as well; and to everyone. therefore we must believe, though we cannot prove, that everyone is pursued by a perfect conspiracy
19:26:19 <FunctorSalad> ksf: quantum mechanics didn't abolish analysis, quite the opposite, it motivated functional analysis
19:26:23 <centrinia> Cale, in what sense do carrots exist?
19:26:46 <ksf> carrots are at least as real as bugs bunny.
19:26:52 <ksf> and that's a hell a lot of reality.
19:26:59 <kynky> its good to challange given things, sometimes its daft to always make assumptions
19:27:00 <lament> carrots are monoid objects in the category of endofunctors on Hask
19:27:41 <FunctorSalad> so carrots are warm and fuzzy?
19:27:58 <lament> they are on that pic!
19:28:32 <kynky> they are compared to nitrogen in its solid state
19:28:45 <lament> most things are...
19:28:45 <ksf> bugs bunny pwns both james bond and chuck norris.
19:29:08 <Cale> centrinia: In a number of ways...
19:29:08 * roconnor invites to #constructive-math
19:29:56 <Cale> centrinia: One is just that we have a bunch of properties that should be satisfied by carrots, and we observe things which satisfy those properties.
19:30:14 <nn64> I can't seem to find cabal-install in gentoo can some one direct me to the site I need to go to to download it?
19:30:30 <gwern> @where cabal-install
19:30:30 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
19:30:53 <ksf> Cale, so we got a set of all carrots that does'nt even need the AC.
19:30:58 <Cale> centrinia: Another is as a specific string of DNA which we can observe in plants :)
19:31:23 <Cale> ksf: I don't know man, maybe carrots form a proper class ;)
19:31:25 <FunctorSalad> carrots exist because other people say so
19:31:36 <FunctorSalad> :)
19:31:41 <kynky> cabal-install and cabal-install-darcs, are both in the gentoo haskell overlay, get layman for that
19:31:42 <centrinia> Maybe a point mutation in that specific string of DNA will still result in what would be equivalent to a carrot. :)
19:32:06 <Cale> Basically, when it comes to matters of science, statements are made true by corresponding to a set of predictions of what will be observed.
19:32:23 <gwern> centrinia: but if we assume an infinite universe, we will observe all possible sequences of poin mutations... :)
19:32:39 <Cale> (and if those predictions seem to work, then the statement is true -- at least for the time being)
19:32:56 <ksf> can we really ascertain that there's a zero possibility of say new york evolving into a carrot?
19:33:11 <ksf> if so, do we have to include new york in the set of all carrots?
19:33:12 <FunctorSalad> gwern: btw, about your package problem... why not just unregister everything first? (after you've saved the list)
19:33:12 <kynky> infinite multi-dimensional multiverse ?
19:33:27 <gwern> FunctorSalad: pardon?
19:33:28 <centrinia> Multi Infinite-dimensional multiverse. :)
19:33:43 <FunctorSalad> gwern: maybe I'm confusing you with someone else (was yesterday)
19:34:13 <FunctorSalad> someone wanted to reinstall all their cabal packages with profiling enabled
19:34:22 <Cale> centrinia: Right, there's probably a whole class of strings of DNA which produce things we'd generally call carrots.
19:34:42 <centrinia> ksf: Do you call carbon dioxide a carrot?
19:35:08 <kynky> well a carrot contains carbon-dioxide
19:35:08 <ksf> can you prove that it never was one?
19:35:12 <FunctorSalad> if the criterion is "what we'd generally call carrots", why the DNA red herring?
19:35:36 <nn64> anyone know of a good haskell beginners guide ?
19:35:41 <centrinia> Plant matter is made mostly from carbon dioxide.
19:35:49 <kynky> yaht - yet another haskell tutorial
19:36:00 <ksf> @where rwh
19:36:00 <lambdabot> is http://www.realworldhaskell.org/blog/
19:36:29 <kynky> and the haskell wiki book
19:37:08 <nn64> I don't know a thing ab@where yaht
19:37:16 <ksf> if you plant a carrot with the intention to eat it, but don't eat it, will it have been planted?
19:37:17 <nn64> oups
19:37:22 <ddarius> centrinia: And both Linux and Windows are made from bits.
19:37:24 <ksf> y combinators are fun.
19:37:24 <nn64> @where yaht
19:37:25 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
19:37:28 <Cale> FunctorSalad: Well, there are a number of criteria you could use to determine if something is a carrot.
19:38:08 <FunctorSalad> :)
19:38:13 <kynky> define it by whats it isnt ?
19:38:29 <FunctorSalad> carrotscore = sum{t in tests} carrotscore_t
19:38:32 <ksf> ddarius, aren't they made of ideas?
19:38:41 <ksf> (at least linux, that is)
19:38:52 <centrinia> ddarius: That supports my point. :)
19:39:19 <Cale> You could take a bunch of plants which you'd like to call carrots, and then figure out what part of their DNA they have in common, and define a carrot as anything which has a small enough edit distance to that. :)
19:40:10 <FunctorSalad> but if a new mutation comes up that looks like a carrot new, you'd need Carrot v1.1
19:40:12 <centrinia> Edit distance is not a good indicator of which mutations are tolerable. :(
19:40:16 <kynky> given infinite carrots and infinite rabbits, how many rabbits would starve?
19:40:29 <cknapp> You could see if it tastes, feels, smells and looks like a carrot.
19:40:40 <cknapp> kynky: are they both countable?
19:40:49 <centrinia> kynky: If you can construct a bijection between the carrots and rabbits, then zero. :)
19:40:59 <ksf> "Continuous analysis and geometry are just degenerate approximations to the discrete world, made necessary by the very limited resources of the human intellect."
19:41:03 <ksf> I like that one.
19:41:19 <gwern> Cale: you could, but what if you wrote a DNA to DNA conversion protein, and then rewrote the genome such that when it got fed through the protein, it spat out the original carrot dna and produced the same proteins? the edit distance could be as large as possible, but it still acts like a carrot in every way
19:41:29 <cknapp> ksf: I'm a formalist, so I resent that statement
19:41:32 <FunctorSalad> ksf: applies to every concept
19:41:37 <kynky> centrinia, is that assuming the rabbits dont do what rabbits do best ?
19:41:41 <FunctorSalad> (in addition, it's begging the question)
19:42:07 <Cale> gwern: But perhaps it shouldn't just be called a carrot, since it's also doing this astounding extra thing ;)
19:42:20 <centrinia> kynky: Yes. :)
19:43:10 <centrinia> The natural numbers N and the union (N x {0}) union (N x {1}) are equipotent. :)
19:43:18 <gwern> Cale: it's not astounding extra thing; it's just another layer of indirection. if I compile my haskell to run on the JVM, I don't say 'look at my astounding non-haskell codes!' just because they turn into jvm stack ops
19:43:27 <ksf> well witty insults never make people transcend their own pov's, that's for sure. They only serve the function of boosting morale inside the target audience.
19:44:12 <Cale> gwern: But it's not Haskell anymore, it's JVM code...
19:44:41 <centrinia> Isn't Haskell the alias for the most recent Haskell standard (Haskell 98)?
19:44:45 <Cale> gwern: It just does the same thing as a particular Haskell program :)
19:45:10 <kynky> cknapp, for something to taste like a carrot and smell, surely you need to compare it to a carrot, but what if you were duped, and it was really a beetroot, would that mean that a beetroot is a carrot ? or that anything is a carrot, because you always need to compare
19:45:11 <Cale> centrinia: Not just that.
19:46:16 <Cale> How about: Something is a carrot if it's useful for me to describe it to you that way.
19:46:23 <gwern> kynky: there is an identical twin to Earth, Earth-2; they even have 'water', but their water is atomically not the same as our water - it's heavy water, say, and they're used to it. if I ask an Earth-2 person for a glass of water, what do they bring me?
19:46:38 <centrinia> Is there an empty finite dictionary where no word is defined in terms of itself?
19:46:48 <centrinia> *nonempty finite dictionary
19:48:02 <cknapp> cknapp: What if carrots don't really exist, and we've all been fooled all along?
19:48:04 * ksf is now going to discover whether or not beer from rostock is any good
19:48:11 <keseldude> > intercalate " <3 " (repeat "Cale")
19:48:12 <cknapp> by cknapp, I meant kynky...
19:48:13 <lambdabot>   "Cale <3 Cale <3 Cale <3 Cale <3 Cale <3 Cale <3 Cale <3 Cale <3 Cale <3 Ca...
19:48:16 <centrinia> If there was an anti-Solar System where everything was the same as this solar system except that every subatomic particle is the antiparticle of what we have, is it still this Solar System?
19:48:41 <Cale> centrinia: It's our solar system travelling backwards in time ;)
19:48:41 <gwern> ksf: if a person from Earth-2 offered you 'rostock beer' would it really be beer?
19:48:46 <nn64> ACK!! I fallowed the cable instructions exactly still no executable file what is wrong !!!!
19:48:46 <kynky> cknapp, then are we fools if we never find out we are fooled ?
19:49:17 <cknapp> Or are we only fools if we continue to be fooled, after finding out we've been fooled?
19:49:22 <cknapp> Or should we want to be fools?
19:49:24 <Cale> nn64: What are you building?
19:49:41 <Cale> nn64: Executables go in ~/.cabal/bin
19:50:20 <kynky> guess we must assume we are fools till we know everything
19:50:21 <nn64> ah here is the error ::: Setup: At least the following dependencies are missing:
19:50:21 <nn64> HTTP >=3000 && <3002, network >=1 && <3
19:50:35 <nn64> how do I accuire them
19:50:59 <Saizan_> if you got your ghc by your distro network should be there too
19:51:02 <cknapp> kynky: can we know everything? If we can definite a well-ordering on knowledge, there's always a bigger ordinal...
19:51:10 <Saizan_> HTTP is on hackage
19:51:32 <Cale> nn64: What program are you building?
19:51:33 <Saizan_> ?hackage HTTP
19:51:33 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HTTP
19:51:36 <ksf> not bad at all, quite similar to jever, even a bit more bitter.
19:51:47 <Cale> nn64: The bootstrap script for cabal-install will install those things for you, I think.
19:51:48 <kynky> cknapp, its a great paradox
19:52:02 <Saizan_> Cale: not network, iirc
19:52:09 <cknapp> Also... I need to get a lot of programming done, so I'm going to stop talking for a while...
19:52:22 <nn64> thanks
19:52:35 <Cale> Oh, perhaps nn64 has the cut-down version of GHC?
19:52:45 <Cale> Yeah, you can get the other stuff on hackage.
19:52:49 <ksf> gwern, my definition of beer is quite exclusive, in the mathematical sense.
19:53:08 <centrinia> Beer is a substance that gets you drunk but not too drunk. ;)
19:53:21 <nn64> well i found the dependancys they were both indipendant emerges
19:53:25 <ksf> american budweiser, for example, is _not_ a beer, but a soft drink.
19:53:32 <kynky> lol
19:53:54 <ksf> same goes for any beer from berlin or bavaria.
19:53:56 <centrinia> I usually call American Budweiser and Diet Sprite the same thing. :)
19:54:16 <Saizan_> hah, the power of abstraction
19:54:51 <dons> ?users
19:54:51 <lambdabot> Maximum users seen in #haskell: 525, currently: 509 (97.0%), active: 18 (3.5%)
19:55:14 <ksf> actually, most ales fall into my definition of beer.
19:57:42 <kynky> anything above 10% ?
19:58:24 <ksf> usually there's not any taste left then.
19:58:31 <wchogg> I tend to be a fan of any good porter or stout.  Deep coffee/chocolate undertones are always nice.
19:59:55 <ksf> http://www.dithmarscher.de/ http://www.jever.de/
19:59:56 <ddarius> dons: Was 564 earlier this day.
19:59:57 <lambdabot> Title: Dithmarscher Pilsener - naturfrisch vom Lande
20:01:11 * shapr boings quietly
20:02:12 <shapr> Cale: Semi-#math question, could I use the idea of a fixed point to get a file that includes a hash of itself?
20:02:34 <shapr> It seems perfectly sensible after three beers...
20:02:55 <Cale> shapr: You can try for it. You might end up in a cycle rather than a fixed point.
20:03:29 <shapr> I wonder if I could frob the file until I do find a fixed point?
20:03:38 <ksf> I bet it breaks at least N security invariants of the hash.
20:03:54 <shapr> But then, the whole point of a hash is that you can't frob it.. hmm.
20:04:01 <wchogg> ksf:  for any N?
20:04:23 <orbitz> is there an equivalen tof 'tracing' a function in lisp so i can see how this function is recursively being called?
20:05:28 <shapr> er, lisp?
20:05:41 <orbitz> err
20:05:41 <orbitz> sbcl
20:05:43 <ksf> forall n m. m>n, yes.
20:05:52 <shapr> ok, I was about to say, there are several flavors of lisp...
20:06:01 <orbitz> yeah my bad
20:06:01 <shapr> Sadly, I don't know.
20:06:09 <ddarius> Time to go to sleep, shapr, 'don't you think?
20:06:13 <orbitz> i believ ein sbl, you can do somethign like (trace 'myfuncname)
20:06:15 <nn64> any intresting programs writen in haskell that I should look into ?
20:06:17 <shapr> ddarius: Why do you say that?
20:06:20 <orbitz> and then it puts litlte hooks on there for ou
20:06:41 <ksf> i'd like a brewery and carrot patch in haskell.
20:06:43 <wchogg> orbitz:  you could try using the trace function in ghci's debugger.  It will give you a semi-readable execution flow.
20:07:04 <wchogg> orbitz:  you need to play a bit with breakpoints though
20:07:11 <orbitz> wchogg: thanks
20:07:30 * orbitz is trying ot grok the funky fibonacci sequence in haskell 
20:07:42 <heatsink> nn64: There are some on hackage.haskell.org
20:08:24 <ksf> > let fibs = 0:1:[sum $ take 2 n | n <- tails fibs ] in take 20 fibs
20:08:26 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
20:08:30 <wchogg> orbitz:  I think part of the problem with creating something nifty for Haskell like trace in Common Lisp is non-strict evaluation.
20:08:55 <orbitz> ok
20:09:12 <orbitz> ksf: the oen i'm looking at is fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
20:09:41 <heatsink> Is there a guide to making a Cabal package from Haskell/C++ code?
20:09:43 <ksf> yeah, but that one doesn't use comprehensions.
20:10:02 <ksf> orbitz, wanna have a walkthrough?
20:10:50 <orbitz> yours seem sto be workign on a somewhat similar principle to the oen i ahve right?
20:11:07 <ksf> yes, basically because of the take 2.
20:11:37 <heatsink> For example, it would help if there were a portable way to query which libstdc++.so g++ uses.
20:12:14 <Cale> orbitz: The easiest way is often just to evaluate by hand
20:12:24 <ksf> zipWith f as bs = map (uncurry f) $ zip as bs
20:12:48 <Cale> @src zipWith
20:12:48 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
20:12:48 <lambdabot> zipWith _ _      _      = []
20:13:21 <ksf> list-monadic <- equals concatMap, which, in this case, works just as map.
20:13:41 <wchogg> That's a nice thing about lazy evaluation:  it's much easier to calculate by hand.
20:13:51 <ksf> Cale, mine's moar elegant.
20:13:56 <shapr> Bah, I let my computer calculate lazy evaluation!
20:14:01 <shapr> And then it eats all my memory some days.
20:14:25 <ksf> it's just like when I'm lazy: Stuff tends to pile up.
20:14:45 <ddarius> ksf: No it isn't.
20:15:15 <glguy> but which is more *beautiful*?
20:15:21 <shapr> Having my computer do it!
20:15:32 <nn64> cabal: cannot configure haskell-src-exts-0.4.3.1. It requires base >=4
20:15:32 <nn64> There is no available version of base that satisfies >=4 ?? What does this mean
20:15:41 <shapr> Probably means you need ghc 6.10 ?
20:15:42 <wchogg> glguy:  I think the more important question is 'which would you hit on in a bar?'.
20:15:42 <ksf> sure it is. I'm still holding a reference to a continuation of me tidying up, so stuff can't be gc'ed.
20:15:47 <dons> umm. aweseom. http://wiki.cs.pdx.edu/forge/riviera.html
20:15:50 <dons> go pdx!
20:15:52 <lambdabot> Title: riviera
20:16:02 <shapr> ooh, neat
20:16:03 <dons> "Riviera is a Seaside-style web app development framework written in about 100 lines of Haskell"
20:16:24 <dons> we should get  the author to give a galois tech talk.
20:16:32 <dons> one minute per line.
20:16:37 <nn64> shapr, i have dev-lang/ghc-6.8.2 installed
20:16:42 <ddarius> 2009 The Year of 100 100-line Haskell Web App Frameworks
20:16:45 <dons> hehe
20:16:49 <dons> bring it on!
20:16:58 <glguy> > fix $ (0:) . scanl (+) 1
20:17:00 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
20:17:30 <shapr> nn64: Instaling ghc-6.10.1 will likely give you base >= 4
20:18:01 <orbitz> i think it is weir dto think of recursive data structures being evalauted lazily, if that makes sense
20:18:04 <orbitz> still getting th ehang of it
20:18:15 <dons> shapr: i think the rate of good news about haskell is growing
20:18:19 <shapr> I agree!
20:18:28 <shapr> RWH group 0-60 in .. 24 hours?
20:18:33 <dons> yeah.
20:18:34 <dons> wow.
20:18:43 <shapr> Actually, I don't know if it's 60 yet
20:18:49 <ksf> you shouldn't care about evaluation, anytime, but about semantics read data flow.
20:18:54 <orbitz> RWH group?
20:18:54 <dons> i'm getting surprised on a daily basis
20:19:06 <shapr> Oh, it's 63 members.
20:19:11 <orbitz> where is the group?
20:19:15 <shapr> dons: Hey, we've been pushing for years, the momentum is building up
20:19:16 <dons> http://www.realworldhaskell.org/blog/2008/12/03/the-real-world-haskell-book-club/
20:19:17 <shapr> http://groups.google.com/group/real-world-haskell-book-club
20:19:18 <nn64> I didn't have this installed dev-haskell/haskell-src-exts-0.2 would that be causing the problem ?
20:19:19 <lambdabot> Title: Real World Haskell Book Club | Google Groups
20:19:20 <shapr> bah, beat me to it
20:19:22 <lambdabot> Title: Real World Haskell Â» Blog Archive Â» The Real World Haskell Book Club, http://tinyurl.com/5jz84y
20:19:26 <orbitz> cool
20:19:39 <shapr> nn64: You need to install version 6.10 of GHC
20:19:49 <dons> shapr: right. i had dinner with some ocaml guys last night, and they commented on how it looks like haskell has won.
20:19:55 * shapr shrugs
20:19:57 <orbitz> do more companies seem to be picking up haskell?
20:19:58 <dons> all through community and efficiency.
20:20:08 <dons> orbitz: not as fast as i'd like, but yes.
20:20:34 <orbitz> i do enjoy haskell so far, but to be honest i do think it seems to take a more intelligent programmer to grok it.  I don't know many java-guys who can shift their thoughts
20:20:42 <nn64> shapr, is it possible to get an older version of lambdabot ?
20:20:51 <shapr> Oh, you're building lambdabot?
20:21:40 <nn64> shapr, ya ... i run my own chat (irc) server it would come in as a big help
20:23:14 <ksf> orbitz, it's just unfamiliar concepts, you gotta unlearn a couple of things and learn a few others, but then it's gonna make more sense than you can imagine right now.
20:24:41 <orbitz> i can see that being a turn off to a lot of companies
20:24:57 <shapr> It's also a turn-on for a lot of smart companies.
20:25:04 <nn64> ok how do i go about getting and installing ghc 6.10 or greater>?
20:25:15 <orbitz> that's good
20:25:19 <orbitz> like ocaml is for jane st
20:25:21 <ksf> and why should we care about pointy-haired bosses?
20:25:26 <shapr> nn64: My mistake, I believe that lambdabot *requires* 6.8
20:26:03 <orbitz> i'm not saying you should, i'm just curious as to how popular haskell is among companies when there is a big learning curve for a lot of people
20:26:15 <dons> http://twitter.com/lauraplybon/statuses/1037289450
20:26:16 <lambdabot> Title: Twitter / lauraplybon: wonders when her fears of ...
20:26:21 <dons> haskell is officially cool.
20:26:44 <orbitz> hah
20:26:46 <nn64> whats going wrong in this build ???? http://pastebin.linuxmain.net/view.php?id=32
20:27:27 <shapr> orbitz: It's good to hire people who have already rounded that Haskell learning curve on their own, because they are likely to be able to round any learning curve you can throw at them.
20:27:40 <ksf> soon we're going to see "Real programmers use unsafeCoerce"
20:27:42 <orbitz> yeah
20:27:52 <orbitz> most of the ocmpanei siv'e worked at have been java shops
20:28:02 <wchogg> shapr: I wish I could throw that line when I'm looking for new jobs.
20:28:07 <shapr> So, for now, Haskell is a big turn-on for several companies because it's a great intelligence test.
20:28:17 <shapr> wchogg: So, why not throw it?
20:28:20 <orbitz> any of them biotech? :)
20:28:42 <ksf> wchogg, start off by writing a job ad that fits you perfectly, including all dreams and weirdnesses.
20:28:43 <orbitz> i'm in an unfortnate position as my field of desire seems dominated by perl, which makes me cry
20:28:48 <shapr> I did hear about a spiffy biotech / speech synthesis job opening today, but it doesn't have anything to do with Haskell.
20:29:02 <shapr> orbitz: You've learned the Haskell biotech libs already?
20:29:10 <orbitz> shapr: no, still learning haskell
20:29:16 <orbitz> (and busy learning bioinf)
20:29:22 <dons> you could go and work at Amgen.
20:29:26 <dons> they're hiring haskell peoples
20:29:27 <shapr> orbitz: If you write some cool Haskell biotech tools, it's always possible you'll be contacted out of the blue and asked to write code for money.
20:29:30 <shapr> It's happened to me.
20:29:32 <orbitz> where is amgen?
20:29:33 <shapr> (not with biotech)
20:29:45 <dons> orbitz: they're big, so multiple places. check out the cufp notes
20:29:54 <orbitz> shapr: yeah, i plan on doing some stuff this winter break
20:29:58 <joed> Last formal gig I had was a voip/speech recognition place, primarily Java but if it had solved the problems we looked at Haskell (Or anything for that matter) would have been used.
20:29:58 * orbitz just started masters program
20:30:00 <shapr> Good idea!
20:30:20 <shapr> joed: Svensk?
20:30:35 <joed> shapr: Jajjamansan, Living in CO though.
20:30:42 <shapr> .co or .co.us ?
20:30:46 <eyeris> In parsec there is many, which matches 0 or more. Am I missing an obvious function in the documentation that matches 1 or more?
20:30:52 <joed> Denver.
20:30:55 <shapr> ah, spiffy
20:31:01 <wchogg> I'm doing the same process during my unemployment:  working on a number of projects so I have better leverage when I start looking again.
20:31:03 <eyeris> I find I'm doing a lot of 'do { space; many space }'
20:31:11 <dibblego> eyeris, many1?
20:31:23 <ksf> eyeris, feel free to write it.
20:31:24 <shapr> @index many1
20:31:25 <lambdabot> Text.ParserCombinators.Parsec.Combinator, Text.ParserCombinators.Parsec, Text.ParserCombinators.ReadP, Distribution.Compat.ReadP
20:31:30 <shapr> :t many1
20:31:32 <lambdabot> Not in scope: `many1'
20:31:32 <eyeris> dibblego Ahh, thanks!
20:31:33 <dons> wchogg: investing in your skill set eh?
20:31:37 <ksf> the combinator, not the repetition.
20:31:38 <eyeris> I see it now
20:31:40 <shapr> :t Text.ParserCombinators.Parsec.Combinator.many1
20:31:41 <lambdabot> forall tok st a. Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st [a]
20:31:45 <orbitz> "To break developers out of their software development rut by giving them a new way to think about software."
20:31:48 <orbitz> i like that
20:31:49 <joed> shapr: I think we spoke about that company a long time ago, was in Indiana.
20:31:58 <shapr> Parsec type sigs can look crappÃ©
20:32:03 <shapr> joed: Oh yeah!
20:32:12 <wchogg> dons:  Pretty much.  I made good money in my old job, so I can afford to take a couple of months & do that.
20:32:32 <wchogg> dons:  Although I _might_ end up entering the PhD program at PSU.
20:32:40 <dons> oh. interesting..
20:32:47 <dons> go PSU. Haskell central is Portland now.
20:32:49 <ksf> HAppS is much, much worse.
20:33:07 <Cale> http://cale.yi.org/share/fibs.png
20:33:10 <shapr> Truly, Gothenburg -> Portland
20:33:15 <Cale> orbitz: ^^
20:33:18 <dons> ksf?
20:33:30 <dons> oh,type sigs?
20:33:34 <ksf> concerning unparsable types.
20:33:42 <shapr> Yeah, I've seen some HAppS source code....
20:33:45 <wchogg> dons:  I've already sent in the application.  I spent almost a week talking with a few professors who seemed to like me...now I just have to wait _weeks_ to find out if I'm accepted.
20:34:50 <Cale> orbitz: If you want, I can add some more evaluation steps :)
20:35:14 <shapr> Cale: Whatever happened to those cool animated GIFs you had? Were those from HOPS?
20:35:16 <orbitz> Cale: you should make a functino that does this :)
20:35:19 <Cale> shapr: yeah
20:36:03 <orbitz> Cale: i think my mental block is this: i'm used to a strict language where teh list is static, and in this it is being built off itself
20:36:11 <Cale> yeah
20:36:35 <Cale> So, it's something new to get used to. So long as you never need more of the structure than is already determined, you can define something in terms of itself.
20:36:36 <orbitz> it's starting to sink in though
20:36:38 <shapr> let ones = 1:ones
20:36:44 <wchogg> orbitz:  it really does help to work some of it out by hand.  I had a mental block about laziness for awhile till I started doing more simple examples that way.
20:36:47 <nn64> shapr, how do I go about this lamdabot install if cabel dosent like it
20:37:02 <shapr> nn64: I don't know, I haven't installed lambdabot in many years :-/
20:37:13 <orbitz> shapr: how does that typecheck?
20:37:22 <shapr> :t let ones = 1:ones in ones
20:37:23 <Cale> :t (:)
20:37:24 <lambdabot> forall t. (Num t) => [t]
20:37:24 <lambdabot> forall a. a -> [a] -> [a]
20:37:37 <shapr> > let ones = 1:ones in take 5 ones
20:37:39 <lambdabot>   [1,1,1,1,1]
20:37:48 <Cale> > let ones = 1 : ones in ones
20:37:49 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
20:38:12 <shapr> nn64: Lemme try installing lambdabot with 6.8 here.
20:38:18 <Cale> > let fix f = x where x = f x in fix (1:)
20:38:20 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
20:38:35 <wchogg> just unrolling the definitionones = 1:ones -> ones = 1 : 1 : ones -> ... it's all kosher, it just never terminates with a []
20:38:45 <heatsink> Hmm.  I can compile module M, but if I try to compile module N, I get an error in module M...
20:39:04 <shapr> heatsink: using --make?
20:39:07 <heatsink> And the error is "Could not find module `Set'", even though I don't import 'Set' anywhere.
20:39:10 <heatsink> shapr: yea
20:39:12 <Cale> orbitz: ones is a nonempty list whose head is 1 and whose tail is ones, that very same list
20:39:12 <shapr> heatsink: Tried removing .hi and .o files?
20:39:12 <alt> Hi folks, I have an ADT (abstract data type) representing an AST (abstract syntax tree) and I need to annotate the tree.  Each node gets a type expression.  I could change the ADT (as in http://hpaste.org/12681), but that is not a good solution
20:39:29 <heatsink> shapr: I tried -fforce-recomp, is that good enough?
20:39:34 <alt> is there some trick I can use to 'lift' the existing ADT
20:39:35 <alt> ?
20:39:36 <shapr> heatsink: That's pretty thorough :-)
20:39:48 <FunctorSalad> alt: Map AST Label?
20:40:06 <orbitz> so i think ksf's example makes more sense to me now
20:40:09 <shapr> heatsink: What's the error? Can you hpaste it?
20:40:19 <orbitz> it's funny to think about the list buing built AND calling tails on it at teh same time
20:40:30 <alt> FunctorSalad:  then you only label the top level
20:40:43 <Cale> alt: You could instead add an arbitrary type parameter, which you then fill with the Type type.
20:40:44 <alt> that AST still have unannotated asts as its children
20:40:48 <FunctorSalad> alt: the lower levels are instances of AST too, no?
20:40:58 <alt> FunctorSalad: yes
20:40:59 <FunctorSalad> I was thinking something like Data.Tree
20:41:00 <Cale> alt: That would allow you to extend the nodes of the AST with other things later if you need.
20:41:09 <shapr> > let x = [1,1/0] in head x
20:41:10 <lambdabot>   1.0
20:41:22 <Cale> alt: By the way, what you have is more properly called an algebraic data type.
20:41:25 <shapr> @quote cookie
20:41:26 <lambdabot> vegai says: Hey Haskell! Give me that File! -Naah, I'm too lazy. *thinks* I'll give you a cookie if you tell me how many letters that file has! -Oh, ok!
20:41:26 <alt> Cale: I like it, it at least quarantines the damage
20:41:29 <Cale> (rather than abstract)
20:41:30 <FunctorSalad> alt: I don't see why you couldn't map each node of the tree to a label then
20:41:35 <alt> Cale: of course, that is what I meant :)
20:41:37 <orbitz> in ksf's version, the first entry int ails will look like [0, 1, ..], which he takes 2 and sums, the next entry in tails will be [1, 1, ...], takes 2, sums, etc etc
20:42:02 <alt> FunctorSalad: then each part of the tree would be a key in the map?
20:42:09 <FunctorSalad> alt: yes
20:42:12 <alt> FunctorSalad:  I can't see how that will work
20:42:14 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in evens
20:42:15 <heatsink> LowLevel.hsc:47:32: Could not find module `Set': Use -v to see a list of the files searched for.
20:42:15 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
20:42:34 <Cale> orbitz: ^^ that one is rather fun too :)
20:42:40 <shapr> heatsink: That's odd, missing an include?
20:42:41 <FunctorSalad> alt: I don't know whether it'd be less work than what Cale suggested
20:43:04 <alt> FunctorSalad:  thanks for the suggestion, I will ponder it more while I implement the other suggestion :)
20:43:12 <alt> Cale: thanks
20:43:19 <shapr> nn64: Yeah, I'm having problems building lambdabot myself.
20:43:21 <orbitz> is tehre any way for a compiel to prove that: fibs = 0:1:[sum $ take 3 n | n <- Data.List.tails fibs ] is wrong
20:43:41 <orbitz> Cale: that is quite fun
20:43:47 <shapr> nn64: My build is dying in oeis, same for you?
20:44:22 <heatsink> shapr: I don't understand how would a missing include file cause that.
20:44:38 <Cale> orbitz: Well... it can try to evaluate it, but that's cheating ;) The loop can potentially be detected at runtime though.
20:44:53 <orbitz> Cale: i ge ta stack overflow at run time (in ghci at least)
20:45:02 <orbitz> just curious if that is the kidn of thing a compiler could detect
20:45:05 <Cale> orbitz: Yeah, loop detection isn't perfect.
20:45:13 <shapr> heatsink: Do you have a Set.hs file? Does it really say "module Set where" at the top? Did you use -v to see if it's looking in the right dir?
20:45:23 <shapr> heatsink: Something confusing going on, that's for sure.
20:45:52 <heatsink> shapr: I have a Set.hs file, it says "module Data.Omega.Set where" at the top.
20:46:24 <shapr> heatsink: Are you explicitly importing Data.Omega.Set ?
20:46:26 <orbitz> Cale: your evens example.  so evens is [0, ...], odds is [1, ..], so evens is then [0, 2, ..], odds is [1, 3, ..], am i following that right?
20:46:28 <heatsink> shapr: I'm not importing it in LowLevel.hsc.
20:46:34 <Cale> orbitz: yeah
20:46:35 <shapr> err
20:47:00 <orbitz> Cale: is that somethign that is just fascinating to write or is there a rpatical example
20:47:12 <shapr> heatsink: Ok.. is this a public piece of software I can try to build myself?
20:47:24 <Cale> Well, there's a rather nice isPrime/list of primes by mutual recursion
20:47:44 <heatsink> shapr: I'm trying to cabalize this software.  It'll be a little difficult to build because it interfaces with a C++ library.
20:47:53 <heatsink> shapr: I'd like to make it public...
20:48:42 <shapr> I think cabal has to do something picky with .hsc files, have you looked at dons' et al ByteString lib for that sort of pickiness?
20:48:56 <heatsink> Hm, no.
20:49:00 <shapr> I've never cabalized anything with an .hsc file, not that I can remember at least.
20:49:03 <orbitz> does real world haskell code end up looking like this?  it seems like in a number of languages the naive approach ends up being nothign like you'd want to implement it in a produciton application
20:49:26 <Cale> > let primes = 2 : [y | y <- [3,5..], isPrime y]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p^2 <= n) primes) in primes
20:49:27 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
20:50:05 <Cale> orbitz: Well, value recursion doesn't typically show up all over the place. It's a specialised technique, but it's good to know that it works.
20:50:09 <shapr> orbitz: It's been my experience that RWH code I've written starts out large and clumsy on the first pass, and quickly boils down to nothing.
20:50:21 <Cale> orbitz: Infinite data structures are quite handy though.
20:50:35 <shapr> Specifically multidimensional infinite data structures.
20:50:51 <shapr> Infinite streams in lisp/scheme aren't multidimensional.
20:50:53 <Cale> orbitz: For example, in a game AI, you might define the whole, possibly infinite, game tree, and then decide what parts of it you're going to look at.
20:50:58 <orbitz> i like lazy lists because you can write code to handle both a strictly evalauted string and a lazily (i/o) one
20:50:58 <heatsink> shapr: I don't see any hsc files in the bytestring library from hackage.
20:51:04 <shapr> oh
20:51:11 <shapr> oops
20:51:22 <Cale> orbitz: Laziness also very much changes what code is idiomatic.
20:51:36 * shapr looks for a lib that has .hsc files
20:51:37 <Cale> orbitz: It tends to give you more ways to break a problem down.
20:51:39 <orbitz> Cale: yeah, i like it, but it takes some mental gymanstics
20:51:58 <orbitz> Cale: is doing your game tree example something i would practically want to do thouhg?  for instanc eif performance is important?
20:52:07 <Cale> orbitz: Sure.
20:52:16 <shapr> heatsink: HFuse?
20:53:11 <orbitz> gott head to bed, cale, shapr, ksf thanks
20:53:30 <shapr> orbitz: Come back sooon!
20:53:34 * shapr boings confusedly
20:53:42 <orbitz> shapr: i never really leave!
20:53:46 <shapr> yay!
20:53:48 <Cale> orbitz: Oh, one other idiom before you go:  zip [0..] is a good way to label the elements of a list with their position
20:53:55 <shapr> Neither do I, not even when I'm gone for months at a time.
20:54:01 <Cale> and it involves an infinite list ;)
20:54:10 <Cale> > zip [0..] "hello"
20:54:11 <lambdabot>   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
20:54:32 <shapr> What's that crazy powerset snippet that sjanssen came up with?
20:54:35 <Cale> > [c | (n,c) <- zip [0..] "hello", even n]
20:54:36 <orbitz> Cale: little thign sliek that are something that i probably would not think of at first at all
20:54:36 <lambdabot>   "hlo"
20:54:46 <heatsink> Yeah, that has ah hsc file.  I don't see anything obvious there... I'll try removing stuff from my code to see if I can narrow down the problem.
20:54:50 <orbitz> Cale: sucha different way to go abotu things
20:54:56 <shapr> heatsink: Sorry I can't help more.
20:55:06 <Cale> shapr: filterM (const [True, False]) ?
20:55:09 <shapr> yeah!
20:55:13 <shapr> That's pretty :-)
20:55:14 <orbitz> Cale: thanks
20:55:15 <heatsink> That's okay, it's nice to know you caaaare.
20:55:20 <shapr> :-)
20:55:35 <Cale> orbitz: no problem!
20:55:44 <Cale> > filterM (const [True,False]) "hello"
20:55:46 <lambdabot>   ["hello","hell","helo","hel","helo","hel","heo","he","hllo","hll","hlo","hl...
20:55:49 <shapr> yay!
20:55:59 <FunctorSalad> @type filterM
20:56:00 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
20:56:07 <shapr> That's like a Zen FP koan.
20:56:22 <orbitz> > tails $ zip [0..] "hello"
20:56:23 <lambdabot>   [[(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')],[(1,'e'),(2,'l'),(3,'l'),(4,'o')...
20:57:28 <cknapp> shapr: what is?
20:57:51 <Cale> > mapM (\k -> [1..k]) [3,2,4]
20:57:52 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,1,4],[1,2,1],[1,2,2],[1,2,3],[1,2,4],[2,1,1],[2...
20:57:53 <shapr> > filterM (const [True,False]) "hello"
20:57:54 <FunctorSalad> I'd just call it insane ._.
20:57:54 <lambdabot>   ["hello","hell","helo","hel","helo","hel","heo","he","hllo","hll","hlo","hl...
20:57:56 <shapr> cknapp: That
20:58:11 <cknapp> shapr: I figured. How does it work?
20:58:15 <Cale> > mapM (\k -> [0..k]) [2,1,3]
20:58:17 <lambdabot>   [[0,0,0],[0,0,1],[0,0,2],[0,0,3],[0,1,0],[0,1,1],[0,1,2],[0,1,3],[1,0,0],[1...
20:58:20 <shapr> cknapp: Figure it out ;-) It's great fun.
20:58:39 <Cale> cknapp: For each element, take it, or don't.
20:58:39 <FunctorSalad> filterM (const Nothing) [1,2,3]
20:58:44 <FunctorSalad> > filterM (const Nothing) [1,2,3]
20:58:46 <lambdabot>   Nothing
20:58:47 <cknapp> Hahah
20:58:51 <shapr> Took me ten minutes of heavy thinking the first time I sat down and stared it that.
20:59:03 <cknapp> Now for me to understand how...
20:59:03 <Cale> cknapp: That's essentially what the filterM (const [True, False]) is saying.
20:59:08 <FunctorSalad> > filterM (if x > 1 then Nothing else Just True) [1,2,3]
20:59:10 <lambdabot>   Couldn't match expected type `a -> m Bool'
20:59:18 <Cale> The const just means 'regardless of the value'
20:59:18 <FunctorSalad> > filterM (\x -> if x > 1 then Nothing else Just True) [1,2,3]
20:59:20 <lambdabot>   Nothing
20:59:26 <FunctorSalad> what is this :(
20:59:36 <Cale> So it's saying, for each element of the list, regardless of its value, keep it, or throw it away.
20:59:40 <FunctorSalad> I guess it liftM's the (:)
20:59:49 <Cale> And the list monad ensures that this is done in all possible ways.
21:00:12 <shapr> Every which way but...
21:00:24 * shapr turns into a pumpkin at midnight
21:00:26 <cknapp> The list monad: in the (const [True,False]) or in "hello"?
21:00:40 <Saizan> ?type filterM
21:00:42 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
21:00:54 <Cale> cknapp: filterM works with an arbitrary monad
21:01:10 <Saizan> "hello" is just considered as an input list
21:01:14 <Cale> cknapp: In this case, m = [], so we have  (a -> [Bool]) -> [a] -> [[a]]
21:01:16 <cknapp> Yeah. Got that
21:01:19 * dons turns into a pumpkin
21:01:20 <dons> night all
21:01:31 <FunctorSalad> nights
21:01:59 <Cale> So the parts which are genuinely monadic are the result of the function we gave, that is, [True,False], and the outer layer of the resulting list
21:02:15 <Cale> The other lists are just lists :)
21:02:43 <FunctorSalad> it's weird in that it depends on the order of the list much more than vanilla filter
21:02:52 <FunctorSalad> if I'm understanding correctly
21:02:55 <Cale> er...
21:03:03 <Cale> oh, well, yes
21:03:12 <FunctorSalad> e.g., for m = State Something
21:03:16 <Cale> Because there are 'effects' which can happen in a different order
21:03:51 <Cale> Which is why I think Disciple is a little bit misguided...
21:03:59 <Cale> (though not a terrible idea)
21:04:50 <Cale> It's good to know which functions take the order of effects into account in their design and which ones don't.
21:05:20 <Cale> map and mapM are kind of similar in construction, but mapM makes a choice about execution order which map doesn't have to.
21:06:03 <Saizan> and in Disciple?
21:06:45 <Cale> In disciple, things are polymorphic over what type of effects are supported.
21:06:58 <FunctorSalad> Disciple?
21:07:35 <Cale> But since this happens by default, it's hard to know when you look at a random function in a big program whether that matters or not, and whether you'll damage it by various refactorings you might want to make.
21:08:09 <heatsink> shapr: Bleh, I figured it out.  My Data.Omega.Set was importing LowLevel instead of Data.Omega.LowLevel.  And I had an old version of LowLevel.hs sitting around in the project root directory!  And it imported Set, which was not stting around in the project root directory!
21:08:13 <Cale> @go Haskell DDC
21:08:23 <Cale> http://www.haskell.org/haskellwiki/DDC
21:08:28 <lambdabot> Plugin `search' failed with: thread killed
21:08:38 <FunctorSalad> > runState ( filterM (do { x <- get; put False } ) [1,2,3] ) True
21:08:39 <lambdabot>   Couldn't match expected type `State s Bool'
21:09:00 <FunctorSalad> > runState ( filterM (const do { x <- get; put False } ) [1,2,3] ) True
21:09:19 <cknapp> Going back to the original expression: so it works kind of like do{x<-[True,False];y<-"hello"; if x then y else ""}... but there's more happening... how do we get every combination, and why doesn't my "explanation" give the whole thing?
21:09:31 <FunctorSalad> > runState ( filterM (const (do { x <- get; put False } )) [1,2,3] ) True
21:09:35 <Cale> cknapp: mm... not quite like that...
21:09:57 <aconbere> is there a good function / module for doing things like filePath normalization (stripping "/"
21:09:59 <FunctorSalad> @botsnack
21:10:00 <lunabot>  :)
21:10:02 <aconbere> 's when necessary for instance)
21:10:07 <FunctorSalad> , runState ( filterM (const (do { x <- get; put False } )) [1,2,3] ) True
21:10:14 <lunabot>  luna: Ambiguous occurrence `get'
21:10:24 <FunctorSalad> oh well
21:10:47 <FunctorSalad> , runState ( filterM (const (do { x <- get; put False; return x } )) [1,2,3] ) True
21:10:49 <lunabot>  luna: Ambiguous occurrence `get'
21:10:54 <Cale> combs (x:xs) = do b <- [True, False]; ys <- combs xs; if b then return (x:ys) else return ys
21:11:08 <Cale> ^^ more like that
21:11:15 <cknapp> Ok... let me figure that out...
21:11:44 <heatsink> aconbere, it would probably be in System.FilePath
21:11:58 <FunctorSalad> @hoogle get
21:12:12 <FunctorSalad> I broke the bots :(
21:13:22 <Saizan> is haskell.org working?
21:13:43 <jeffz`> yes, it's just slow
21:13:44 <heatsink> yes, but very slowly.
21:14:07 <ksf> http://www.angelfire.com/mt/marksomers/40.html
21:15:14 <cknapp> Hmm... I need to learn how Moands work... but I need to finish my project first.
21:15:53 <ksf> snarf a monad tutorial, forget about it, finish your project, then snarf it again while grokking it.
21:16:27 <cknapp> Project due in12 hours and 45 minutes...
21:16:40 <cknapp> I need to finish an algorithm, write up some test cases, and do some profiling...
21:17:05 <joed> Plenty of time.
21:17:07 <Cale> That link reminds me that I meant to look for Coxeter's book...
21:17:12 <cknapp> since I normally go to bed by midnight... and it's 11:15, I'm going to be up for several hours after I normally go to bed...
21:17:21 <cknapp> Oo... Coxeter...
21:17:28 <cknapp> Also... this keeps happening.
21:17:33 <joed> So a normal workday, welcome to real life.
21:17:37 <cknapp> :)
21:17:43 <ksf> it's 6:20 around here, usually I get up at that time.
21:17:54 <solrize> projective geometry?
21:18:18 <ksf> bucky geometry.
21:18:48 <Cale> solrize: For one :) I'd like to have something on polyhedra and polytopes though. I know far less than I'd like to about them.
21:19:06 <solrize> yeah i was looking at that book recently, it's old fashioned but looks way cool
21:19:43 <solrize> very combinatorial, nothing to speak of about analysis or optimization if that's what you're interested in that stuff for
21:20:05 <Cale> That sounds good for me :)
21:20:31 <Cale> I don't really care for optimisation so much, but I love combinatorics.
21:20:39 <solrize> it's nice, dover paperback
21:21:30 <cknapp> Hmm... sounds like I need to get that.
21:21:31 <solrize> i think just about all 3-dimensional, not much about higher dimensions
21:21:38 <cknapp> Hmm...
21:21:43 <cknapp> Maybe not :)
21:22:06 <solrize> i don't remember really though
21:22:20 <Cale> Do you recall if it talks about Wythoff's construction?
21:22:23 <solrize> it had nice diagrams about stellated rhombicosihedrons and that sort of thing
21:22:24 <solrize> no idea
21:22:29 <solrize> you can probably find the toc online
21:23:18 <Cale> Coxeter's books are generally all quite good, from what I've heard. :)
21:23:24 <vaskaren> is it completely impossible to change a static syste while running? like updating a module?
21:23:48 <solrize> there's a biography of him out that's also pretty good
21:24:00 <solrize> "the man who saved geometry"
21:24:04 <Cale> vaskaren: Well, there are libraries to allow for dynamic loading of Haskell code.
21:24:07 <solrize> i looked at it in the store
21:24:53 <Cale> I went to what turned out to be his last birthday party, at the Fields institute in Toronto. (On a trip with the Waterloo mathematics club)
21:25:31 <doublec> vaskaren, see hs-plugins or the ghc api
21:25:37 <Cale> Conway was also there (H)
21:25:47 <solrize> nice
21:25:54 <solrize> i've met conway, he is awesome
21:26:16 <cknapp> Envy...
21:26:47 <Cale> He pointed out some interesting things in a giant wireframe model of the 120-cell that had been donated to the institute on account of Coxeter's birthday.
21:26:48 <cknapp> Winning Ways and ONAG have been 2 of my  favorite books since high school... Not that I understand them....
21:27:03 <Cale> and gave a talk about operations on polytopes
21:27:35 <Cale> (Conway did, that is)
21:28:16 <Cale> Coxeter gave a bit more of an autobiographical talk
21:30:19 <Cthulhon> What's the technical difference between an applicative functor and a monad that prevents every applicative from yielding a monad via ap being equivalent to <$> and return being equivalent to pure?  It seems like we should be able to derive binding from ap, but it also seems to require some ugly hacks, which tends to indicate it shouldn't really be possible, at least conceptually.
21:30:40 <Cale> I can't parse your question...
21:30:56 <Cale> It's not possible to get bind from ap
21:31:00 <joed> 42
21:31:16 <Cthulhon> Why not?
21:31:17 <Cale> Try to get join from ap
21:31:33 <Cale> ap doesn't change the nesting depth of the functor applications
21:31:40 <Cale> pure increases it
21:32:01 <Cale> So there's no way to go from f (f a) to f a using just those
21:33:01 <Cale> Also, there are functors which are applicative, but not monads.
21:33:10 <Cthulhon> Hm, the hack I had in mind was fromJust, so that makes sense.
21:33:27 <Cale> fromJust only works for Maybe...
21:33:36 <centrinia> Wait, how did someone make a giant wireframe model of a 4 dimensional polytope?
21:33:41 <Cthulhon> Well, yeah.
21:33:56 <Cale> centrinia: By making a model of its projection to a 3-dimensional space.
21:33:59 <Cthulhon> I was thinking about Maybes.
21:34:07 <centrinia> That's no fun.
21:34:11 <Cthulhon> As a conrete exampe.
21:34:21 <Cthulhon> *concrete
21:34:28 <centrinia> I need a Klein bottle of booze. :(
21:35:05 <solrize> but you could never get to the contents :(
21:35:12 <cknapp> How about some of Ye Olde Fortran?
21:35:28 <Cale> centrinia: They took a projection which exactly doubled all of the edges -- that is every edge in the projection corresponds to 2 edges of the original one (one from the "front" and another from the "back")
21:35:49 <Cthulhon> So the conceptual difference is that an applicative just can't remove a level of nesting?
21:35:59 <Cale> Cthulhon: yeah, that's a start :)
21:36:52 <Cale> Can't necessarily, anyway.
21:37:00 <Cthulhon> Right.
21:39:43 <Saizan> Cthulhon: from another pov, with an applicative the actions to perform are indipendent of intermediate results
21:40:53 <Cthulhon> That's never true of a monad?
21:41:14 <Saizan> while with (>>=) :: m a -> (a -> m b) -> m b, the second argument has the freedom to construct the "m b" by looking at "a"
21:41:58 <Saizan> well, it can be true for certain expressions
21:42:51 <Saizan> those that you write with only ap and return, for example :)
21:43:09 <Cthulhon> Ah.
21:44:53 <Saizan> so, the Monad interface is more expressive, but if you restrict yourself to Applicative you know more about your expressions before starting to "execute" them
21:46:56 <Saizan> which is exploited by some parsing libraries to auto-optimize the parsers you define, for example
21:47:35 <Cthulhon> Neat.
21:54:04 <nn64> >777+777
21:54:12 <dmwit> needs more space
21:54:15 <dmwit> > 777+777
21:54:31 <dmwit> Also, needs more \bot.
21:54:33 <dmwit> ?bot
21:54:34 <lament> lambdabot just needs some space
21:55:02 <nn64> > 777+789+777
21:55:19 <dmwit> Sorry, but lambdabot seems to be out of commission for now.
21:55:27 <dmwit> Time to fire up ghci. =)
21:56:05 <nn64> dmwit, lets test my bot then
21:56:07 <grom358> @src rem
21:56:25 <nn64> join the irc at linuxmain.net and join #linux
21:56:31 <dmwit> grom358: It's a class function, and for many types the implementation is just a call to some primitive builtin.
21:58:14 <grom358> > -6 `rem` 2
21:58:29 * Cale wonders if lambdabot is dead.
21:58:31 <Cale> @bot
21:58:31 <lunabot>  :)
21:58:35 <Cale> hmm
21:58:58 * ksf suddenly remembers himself in the first grade, thinking about circles and whether or not they got zero or infinite corners. he decided on infinite and now corrects that to finite.
21:59:20 <Cale> ah, url module failed in contextual handler: thread killed
21:59:31 <lament> circles have FOUR corners you stupid fool.
21:59:34 <grom358> ksf: what?
21:59:48 <ksf> circle? four?
21:59:49 <Cale> > -6 `rem` 2
21:59:53 <ksf> it's bounding box has.
21:59:55 <lambdabot>   0
22:00:02 <Cale> > -1 `rem` 2
22:00:05 <nn64> Cale, every time i do somthing like > 88844 +3882 on my bot it returns <lambdabot>  Terminated
22:00:06 <grom358> > -6 `mod` 2
22:00:09 <lambdabot>   -1
22:00:11 <dmwit> ksf: Define corner.
22:00:11 <Cale> > (-1) `rem` 2
22:00:15 <lambdabot>   0
22:00:19 <lambdabot>   -1
22:00:22 <nn64> > 888 + 999
22:00:28 <Cale> nn64: Do you have mueval?
22:00:29 <lambdabot>   1887
22:00:30 <ksf> a thing between two edges.
22:00:32 <lament> time has four corners. Time is a circle. Therefore, circles have four corners
22:00:37 <grom358> ah.. woops
22:00:40 <travisbrady> is there an easy translation for the following python snippet: [(y,x) for (x,y) in [(1,2),(3,4),(5,6)]]?
22:00:44 <dmwit> ksf: Circles have two sides... inside and outside. ;-)
22:00:52 <nn64> @where mueval
22:00:53 <grom358> > (-6) `mod` 2 == (-6) `rem` 2
22:00:59 <lambdabot> I know nothing about mueval.
22:01:01 <lambdabot>   True
22:01:08 <lament> circles have one edge, you can balance a coin on it
22:01:08 <ksf> CIRCLES ARE NOT. let's talk about spheres.
22:01:21 <nn64> Caelum, what is mueval
22:01:24 <ksf> or tori, if you prefer.
22:01:28 <grom358> > (-1) `mod` 2 == (-1) `rem` 2
22:01:35 <lambdabot>   False
22:01:49 <Cale> nn64: The program which evaluates expressions for lambdabot
22:01:54 <ksf> lament, how big a coin do you need to approximate pi to n digits?
22:02:03 <Cale> nn64: You'll find it on hackage.
22:02:07 <lament> ksf: two dollars
22:02:39 <ksf> at current exchange rates?
22:03:07 <nn64> ../.cabal/bin/cabal install mueval  -bash: ../.cabal/bin/cabal: No such file or directory
22:03:08 <lament> you don't believe in exchange rates, because they're continuous
22:03:39 <ksf> they aren't, ask the next guy who implements them.
22:04:07 <ksf> both over time and over values.
22:04:30 <ksf> basically, yes, you won't ever see pi dollars.
22:05:01 <nn64> oups that error was my falt
22:08:48 <nn64> now it returns this :: <lambdabot>       Could not find module `Control.Arrow.Transformer.All':
22:08:49 <nn64> <lambdabot>        Use -v to...
22:11:32 <nn64> any idea how to fix that
22:12:02 <ksf> if you oppose two mirrors, do they reflect photons infinitely?
22:12:28 <ksf> strangely enough, but in that case, infinity is limited by at least light speed.
22:13:09 <nn64> ah .... :( its getting to late I will have to work on this tomarrow
22:13:10 <joed> Me claps with one hand for ksf's brilliant koans...
22:14:16 <lazyshark> Hi, does anyone know if the H3D project is active? (http://www.haskell.org/haskellwiki/H3D)
22:14:17 <lambdabot> Title: H3D - HaskellWiki
22:16:07 <ksf> furthermore, a photon that you can observe can't possibly be reflected infinite many times.
22:16:48 <ksf> therefore, mirror recursion is finite from any observers system.
22:16:48 <joed> Awesome... Have you ever tried astroglide?
22:17:57 <dmwit> wut
22:18:22 <grom358> I understand the difference between quotRem and divMod . But what are some examples of when would you want to use one or the other?
22:19:09 <ksf> reminds me of a placebo song.
22:19:47 <joed> You don't blog do you? If not, might be something you'd want to get going on...
22:21:18 <dibblego> > 1 `divMod` (-6) == 1 `quotRem` (-6)
22:21:19 <lambdabot>   False
22:22:43 <ksf> I don't believe in blogs.
22:22:49 <ksf> to continuous.
22:22:51 <ksf> *too
22:24:01 <centrinia> @check (\a b -> (\(q,r) -> q*b+r == a) (a `divMod` b))
22:24:02 <lambdabot>   "* Exception: divide by zero
22:24:19 <centrinia> @check (\a b -> (b /= 0) && ((\(q,r) -> q*b+r == a) (a `divMod` b)))
22:24:20 <lambdabot>   "Falsifiable, after 0 tests:\n0\n0\n"
22:24:35 <centrinia> @check (\a b -> if b /= 0 then ((\(q,r) -> q*b+r == a) (a `divMod` b)) else True)
22:24:36 <lambdabot>   "OK, passed 500 tests."
22:24:45 <centrinia> Hmm.
22:24:56 <centrinia> @check (\a b -> if b /= 0 then ((\(q,r) -> q*b+r == a) (a `quotRem` b)) else True)
22:24:57 <lambdabot>   "OK, passed 500 tests."
22:25:04 <centrinia> That's odd.
22:25:19 <centrinia> > (\a b -> if b /= 0 then ((\(q,r) -> q*b+r == a) (a `quotRem` b)) else True) -5 3
22:25:20 <lambdabot>       No instance for (Num (a -> a -> Bool))
22:25:20 <lambdabot>        arising from a use of `-'...
22:25:31 <centrinia> > ((\a b -> if b /= 0 then ((\(q,r) -> q*b+r == a) (a `quotRem` b)) else True) -5 3)
22:25:32 <lambdabot>       No instance for (Num (a -> a -> Bool))
22:25:32 <lambdabot>        arising from a use of `-'...
22:25:47 <centrinia> > ((\a b -> if b /= 0 then ((\(q,r) -> q*b+r == a) (a `quotRem` b)) else True) (-5) 3)
22:25:49 <lambdabot>   True
22:25:55 <centrinia> > ((\a b -> if b /= 0 then ((\(q,r) -> q*b+r == a) (a `divMod` b)) else True) (-5) 3)
22:25:57 <lambdabot>   True
22:37:58 <juhp> anyone tried to build libHSbase-4.0.0.0-ghc6.10.1.so?
22:38:16 <juhp> or better succeeded :)
22:40:24 <juhp> I don't really understand why cabal can't build base?
22:42:39 <juhp> runhaskell Setup.hs configure --enable-shared
22:42:40 <juhp> <command line>: module `Prelude' is not loaded
22:43:00 <juhp> (well --enable-shared is irrelevant)
22:43:27 <sjanssen> juhp: are you not happy with the version of base you've got already?
22:44:51 <juhp> sjanssen: I was a shared library :)
22:44:54 <juhp> want
22:44:58 <sjanssen> juhp: also, Prelude is implicitly imported in all modules, so the Prelude.hs in base's directory will clash with the Prelude module you've got installed
22:45:12 <juhp> ok
22:45:16 <sjanssen> juhp: basically, you can only build base as part of the GHC build process
22:45:22 <juhp> hmm
22:45:33 <juhp> I see
22:45:34 <juhp> thanks
22:47:07 <juhp> sjanssen: could one not hide the install Prelude then?
22:47:11 <juhp> installed
22:47:37 <sjanssen> you'll still run into problems
22:47:42 <juhp> ok
22:48:01 <juhp> guess ghc needs to be fixed then...
22:48:27 <sjanssen> upgrading base is pretty explicitly not supported
22:48:35 <vegai> why do you want a shared library, btw?
22:48:57 <juhp> vegai: why not? :)
22:49:23 <juhp> shared library are the norm these days...
22:50:09 <juhp> I still surprised how long it has taken to get even this far, but guess I should not complain since I have not helped to work on it
22:51:05 <vegai> being a norm doesn't mean it's good...
22:51:23 <juhp> vegai: what is the advantage of static libs?
22:51:57 <vegai> less deployment headaches
22:52:03 <juhp> hmm
22:52:31 <quicksilver> well, neither of the major user platforms has ever adopted anythign like a useful system for shared libs
22:52:42 <quicksilver> they work fine on Linux and *BSD, of course.
22:52:48 <vegai> I suppose this is a slightly controversial opinion these days... but it seems to me that there was a short span of time where shared libs were a good idea
22:53:02 <juhp> vegai: we're in the 21st century now :)
22:53:03 <vegai> when hd space (and RAM a bit) was precious
22:53:16 <quicksilver> vegai: if you have 45 applications on your hard disk which all depend on libopenssl
22:53:19 <vegai> juhp: indeed, so we should strip all that silly shared lib package away :)
22:53:25 <quicksilver> and there is a critical security fix in libopenssl
22:53:28 <Beelsebob> quicksilver: hmm? You wouldn't say that OS X's system for dylibs works?
22:53:33 <quicksilver> do you really want to upgrade all 45 of them?
22:53:45 <juhp> I don't anyway :)
22:53:54 <vegai> quicksilver: well, that works both ways
22:53:57 <quicksilver> Beelsebob: there is no system for managing the dependencies of applications and simultaneous installation of multiple versons etc...
22:54:02 <vaskaren> share dlibs between proglangs?
22:54:03 <vegai> a new version of libopenssl might have a new security bug
22:54:06 <Beelsebob> quicksilver: sure there is
22:54:13 <juhp> heh
22:54:23 <Beelsebob> that's why a .framework's first level directory contains Versions
22:54:28 <vegai> but I don't need to convince anyone about this. Just say I'm wrong, stupid and ugly :P
22:54:33 <juhp> vegai: so then you just rebuild all 45 packages again ;-P
22:54:37 <Beelsebob> and inside that you find various past versions, and then a Current symlink
22:54:41 <quicksilver> Beelsebob: sure
22:55:03 <quicksilver> Beelsebob: but there's no system for "install application 'foo', together with whatever shared libs it needs which I don't already have, but not the ones I do"
22:55:15 <Beelsebob> no
22:55:16 <quicksilver> Beelsebob: so in practice OSX only shares the shared libs for system libs
22:55:27 <quicksilver> apps tend to bundle their own shared libs inside their bundle
22:55:32 <Beelsebob> true true
22:55:36 <quicksilver> because they don't know which versions might be present on the system.
22:55:45 <quicksilver> the technology is all in place ;)
22:55:46 <Beelsebob> which in all honesty -- works very well for managing the versions they need
22:55:52 <juhp> shrug that is osx's problem
22:55:52 <quicksilver> but the pieces aren't quite joined together.
22:56:11 <quicksilver> Beelsebob: it works fine. But morally it might as well be static linking at that point.
22:56:20 <juhp> anyway for ghc it is just a question of when...
22:56:21 <quicksilver> Beelsebob: in a sense, it is static linking, just at a slightly different level of abstraction.
22:56:38 <Beelsebob> quicksilver: the rule isn't static linking (assuming we're talking LGPL here)
22:56:48 <quicksilver> I'm not talking LGPL at all.
22:56:48 <Beelsebob> the rule is that the end user has to be able to replace the LGPLed component
22:57:02 <quicksilver> I'm just remarking on how little shared libs are used by the major two platforms
22:57:05 <Beelsebob> which they certainly can
22:57:06 <quicksilver> no license agenda ;)
22:57:10 <Beelsebob> ah, I see
22:57:28 <quicksilver> juhp was asking why GHC doesn't support shared libs (yet)
22:57:39 <quicksilver> I was just remakring that the major platforms don't really use them properly anyway
22:57:41 <juhp> quicksilver: that is true (major platforms)
22:57:46 <vegai> plan 9 decided not to support them either. They must have a good reason :P
22:57:55 <juhp> hmm
22:58:06 <Beelsebob> quicksilver: at a guess, the reason that windows has used them less and less is that for a long time it gained the reputation for DLL hell
22:58:12 <juhp> they seem to work pretty well on Linux anyway
22:58:13 <quicksilver> Beelsebob: yeah.
22:58:24 <Beelsebob> and I think probably the same problem exists on linux
22:58:24 <quicksilver> juhp: yes, but mainly because of the existence of kick-ass package management systems
22:58:33 <juhp> indeed
22:58:35 <quicksilver> juhp: like apt-get and its competitors
22:58:39 <Beelsebob> if you let idiots use it
22:58:51 <quicksilver> there is a more serious problem with the Linux ld.so, as well
22:58:58 <quicksilver> it doesn't know about diamond dependencies
22:59:09 <quicksilver> really soname isn't enough, you need a hash of all the sonames in the dependency tree
22:59:32 <juhp> I don't see any reason why linux compromise because of other system's deficiencies
22:59:46 <quicksilver> agreed
22:59:49 <quicksilver> there is no reason it should
22:59:53 <quicksilver> but someone has to do the work
22:59:57 <juhp> :)
23:00:05 <quicksilver> I was sketching (possible) reasons why people might not have prioritised the work.
23:00:15 <quicksilver> people certainly work on it from time to time, though
23:00:17 <juhp> seems just last mile is left iiuc
23:00:30 <quicksilver> yup, it's nearly there from what I understand.
23:00:43 <vegai> "shared libraries are obviously a good idea until youâve actually used them. then whether itâs obvious or not that theyâre a bad idea is mostly a matter of how close you are to trying to get them to work." -- Rob Pike
23:00:55 * quicksilver nods
23:01:09 <quicksilver> the diamond dependency problem first became visible to me when I was working on gnome
23:01:20 <quicksilver> before gnome it was relatively unusual to find a library depending on a library
23:01:28 <quicksilver> but gnome took library modularisation to a new place ;)
23:01:34 <juhp> quicksilver: what is the problem?
23:01:52 <Saizan> ghci-haskeline++
23:01:52 <quicksilver> juhp: application depends on libfoo, which is compiled against libbar version X
23:02:06 <juhp> ah you mean conflicts?
23:02:11 <quicksilver> juhp: applicatoin also depends on libbam which is compiled against libbar version Y
23:02:16 <juhp> hmm
23:02:25 <quicksilver> juhp: although libbar.so.X and libbar.so.Y are simultaneously installable
23:02:33 <quicksilver> thanks to versioned sonames and versions packages
23:02:40 <quicksilver> and libfoo and libbam both work separately
23:02:45 <juhp> I think ghc's version will use hashes anyway, no?
23:02:49 <quicksilver> they will segfault when you link the application.
23:03:03 <juhp> ok
23:03:24 <quicksilver> GHC uses abi hashes to detect conflicts internally, which is smart
23:03:34 <quicksilver> I haven't heard they were plannign to use them as sonames, though
23:03:39 <Saizan> ghc gives you a type error, actually
23:03:40 <quicksilver> (maybe they are, but I hadn't heard that)
23:04:09 <quicksilver> Saizan: ghc versions every symbol, I think?
23:04:16 <quicksilver> (which general C libraries certainly do no do)
23:04:22 <Saizan> yeah
23:04:43 <quicksilver> even versioned symbols don't save you from this though.
23:04:57 <sjanssen> quicksilver: every symbol is tagged with package name and version in GHC
23:05:07 <quicksilver> you need symbol versioning which incorporates the versions of all implicitly and explicitly depended sub library too
23:05:17 <sjanssen> true
23:05:41 <quicksilver> versioned symbols only save you from the first-order version of the problem.
23:05:57 <quicksilver> type errors also only save you from the first-order version, as far as I know
23:06:06 <sjanssen> shared libraries are dangerous in GHC, rebuilding a library with different optimization flags can produce totally incompatible results
23:06:12 <quicksilver> GHC can detect that foo-0.1:Foo and foo-0.2:Foo are different types.
23:06:40 <quicksilver> but GHC can't detect that base-1:Data.Map and base-1:Data.Map (same type!) secretly depend on different Ord instances
23:06:48 <quicksilver> based on different versions of some deeply buried sub library.
23:07:39 <jsn> i am trying to use existentials
23:07:40 <jsn> http://github.com/jsnx/parstream/tree/master/Control/ParStream.hs
23:07:42 <lambdabot> Title: Control/ParStream.hs at master from jsnx's parstream â GitHub
23:07:48 <jsn> but i am "doing it wrong"
23:07:50 <quicksilver> sjanssen: you could say "GHC is a whole program compiler trying really really HARD to pretend it supports separate compilation"
23:08:49 <jsn> when i build it, the error is "can not match IO to m1, a rigidly bound type variable..."
23:09:09 <ski_> jsn : `next :: (Monad m) => forall m . s -> m o' looks very strange .. maybe you wanted `next :: forall m. Monad m => s -> m o' ?
23:09:10 <quicksilver> jsn: no existentials there, by the way.
23:09:22 <Saizan> jsn: you're using an universale there
23:09:33 <jsn> oh, you are right
23:09:48 <jsn> for some reason i get confused, because they use the same notation
23:09:51 <quicksilver> ski_: I'm suprised that GHC accepts it but it must mean the same thing?
23:10:15 <ski_> quicksilver : it oughtn't
23:10:23 <quicksilver> jsn: your problem is that you have promised that the 'next' method of ParStream will support any monad
23:10:29 <quicksilver> jsn: (that's what forall m means)
23:10:33 <jsn> ski_: it fails the same
23:10:44 <sjanssen> quicksilver: the forall'ed m will shadow the outer m
23:10:46 <quicksilver> jsn: and yet you've written code which suggests that in fact it only supports IO
23:10:47 <jsn> oh
23:10:52 <jsn> oh
23:10:58 <jsn> yeah, you're right
23:11:08 <jsn> that instance is only valid for IO
23:11:12 <quicksilver> jsn: I imagine you want m to be (another) parameter of the class
23:11:20 <quicksilver> class ParStream s o m where ..
23:11:21 <ski_> jsn : what is it you want here ? to use different monads in different instances ? .. in the two instances you've given, you are using `IO'
23:11:29 <quicksilver> instance ParStream Handle (Maybe Int) IO where ....
23:12:32 <jsn> aha, now it works
23:12:53 <jsn> ski_: yeah, i guess only some instances will be "cross monadic"
23:13:01 <jsn> xmonadic
23:13:35 <ski_> "it works" means ?
23:13:52 <Saizan> btw, the existential version would be data AnyMonad a = forall m. Monad m => AnyMonad (m a), next :: s -> AnyMonad o, but something of type AnyMonad is pretty much useless
23:13:54 <jsn> i added a third parameter and now it loads
23:14:08 <ski_> jsn : but was it what you wanted ?
23:14:11 <noob_hs> there're no debian packages for ghc 6.10 yet, so what is "the right way" to install it ?
23:14:14 <jsn> yes
23:14:28 <jsn> ski_: basically
23:14:34 <Saizan> noob_hs: download the binary dist. from www.haskell.org/ghc
23:14:42 <jsn> i'm still sorting it out, but this seems right, yeah
23:15:05 <noob_hs> Saizan: yes, but where do i untar it to without cluttering my installation ?
23:15:15 <luqui> noob_hs, I installed it in a local prefix, so I don't have to go through pain when the debian package is released
23:15:20 <ski_> (jsn : if that's what you want, then possibly you want `class Monad m => ParStream s o m')
23:15:21 <noob_hs> ah ok
23:15:28 <luqui> noob_hs, eg. /home/luqui/lib
23:15:34 <noob_hs> okay, tanks
23:15:48 <jsn> ski_: right, that's what i did
23:15:59 <Saizan> the default is /usr/local, which worked fine for me
23:16:07 <juhp> has noone really package ghc-6.10.1 for debian/ubuntu yet?
23:16:13 <juhp> -d
23:16:23 <noob_hs> juhp: not that i'm aware of
23:16:31 * juhp boggles
23:16:33 <juhp> ok
23:16:35 <jsn> is there such a thing as reverse <$> ?
23:16:49 <luqui> jsn, you mean flip (<$>) ?
23:16:50 <Saizan> in what sense?
23:16:54 <juhp> there used to be some haskell repos
23:17:00 <jsn> luqui: yeah
23:17:12 <luqui> @hoogle f a -> (a -> b) -> f b
23:17:13 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
23:17:13 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
23:17:13 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
23:17:29 <luqui> hmm...
23:18:08 <luqui> I don't know of one in common use
23:19:07 <luqui> I'd consider spelling it ($>>) maybe, as a combination of $ and >>>.
23:19:18 <jsn> >$<
23:19:26 <luqui> why symmetric?
23:19:37 <juhp> ghci does need .hi files for packages it loads?
23:19:40 <juhp> doesn't
23:19:49 <luqui> juhp, it just compiles them on the fly
23:19:50 <jsn> looks like an inverted <$>
23:20:07 <juhp> luqui: the .o you mean?
23:20:08 <jsn> i wonder if we have >.> or <.< as operators yet
23:20:18 <luqui> heh
23:20:24 <jsn> ^_^ >_> <_<
23:20:28 <luqui> >.> seems almost like the right spelling of >>>
23:20:47 <luqui> :t let (^_^) = (+) in 1 ^_^ 2  -- don't think this parses
23:20:48 <lambdabot> parse error on input `)'
23:20:58 * juhp is pondering to split .o files from .hi and .a for fedora
23:21:35 <jsn> luqui: oh heck
23:21:42 <jsn> the _ can be in identifiers
23:21:48 <dmwit> :t let (^.^) = (+) in 3
23:21:50 <lambdabot> forall t. (Num t) => t
23:22:13 <jsn> i better claim these operators with a library, quick
23:22:13 <juhp> (^_^ might be a Asian emoticon :)
23:22:22 <juhp> heh
23:22:24 <jsn> juhp: it is, yeah
23:22:32 <jsn> as is ^.^
23:22:34 <luqui> Debug.NamespaceClutter
23:22:38 <juhp> yeah
23:22:38 <jsn> and all the rest
23:23:02 <jsn> luqui: i want it to be something people really want to use alot
23:23:12 <juhp> luqui: so was that a "no"? (ghci)
23:23:21 <luqui> jsn, good luck.  hackage libraries have a tendency to get created pretty fast
23:23:28 <jsn> so that haskell will gain mad cred for having >.> as an operator :)
23:23:36 <luqui> juhp, what?  ghci needs only the source file.
23:23:49 <luqui> juhp, but it will use the .o if it exists
23:23:55 <juhp> luqui: I am asking about installed packages
23:23:56 <luqui> (and .hi)
23:24:06 <chipdude> class ROFL where...
23:24:10 <luqui> juhp, oh!  what exactly are you asking?
23:24:38 <juhp> luqui: does "ghci -package zlib" require the .hi files?
23:24:45 <juhp> it seems to load fine without them
23:25:01 <luqui> jsn, how about (>.>) :: (a -> b) -> a -> Bool   -- f >.> x  returns True if f halts when given input x, False otherwise
23:25:27 <jsn> luqui: oh, that's a good idea
23:25:43 <luqui> juhp, oh, I'm not sure about that.  It probably needs them, because .hi is where type signatures and whatnot are stored
23:25:47 <jsn> i really need that for debugging, actually
23:25:47 <luqui> I have never used -package
23:25:58 <juhp> luqui: ok yeah
23:26:02 <mauke> f >.> x = f x `seq` True
23:26:18 <luqui> mauke, sorry, doesn't meet specification.
23:26:28 <jsn> i should just generalize it over all x, it'll be so much more useful...
23:26:40 <juhp> luqui: but it is showing the signature even though I moved the .hi files away
23:26:54 <luqui> juhp, are the source files around?
23:27:28 <luqui> jsn, but you needed a binary operator.
23:28:15 <luqui> mauke, that reminds me of (==) on computable reals.  will only ever return False, if it returns :-)
23:28:28 <luqui> how... useful
23:29:18 <BeelsebobWork_> luqui: o.O
23:29:38 <juhp> luqui: not in the current directory
23:29:56 <luqui> juhp, well you said it was installed right?
23:30:02 <juhp> yep
23:30:21 <luqui> so... not in the installed directory either?  no .hs or .os to be found anywhere?
23:30:28 <luqui> er, .his i mean
23:31:07 <juhp> luqui: we try to move them further but I changed the dir name so can't see how it could find the .hi files
23:31:11 <juhp> ugh
23:31:17 <juhp> we -> let me
23:35:40 <ski_> (jsn : `(>.>) = flip (.)' has been used before ..)
23:35:44 <juhp> oops I may be doing something silly
23:38:21 <juhp> luqui: sorry I had personal copy installed in home too... doh
