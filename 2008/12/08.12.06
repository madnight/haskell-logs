00:00:04 <pumpkin_> you don't need to sort before nubbing do you?
00:00:07 <pumpkin_> it's not like uniq
00:00:08 <centrinia> No.
00:00:17 <centrinia> I sort anyways because it should be faster.
00:00:22 <pumpkin_> ah
00:00:34 <pumpkin_> gottam ake sure that big-O evaluates quickly :P
00:00:44 <centrinia> I think nub :: (Eq a) => [a] -> [a]
00:00:54 <pumpkin_> :t nub
00:00:55 <lambdabot> forall a. (Eq a) => [a] -> [a]
00:00:58 <pumpkin_> :)
00:01:31 <centrinia> I don't think you can make a nub on general lists faster than O(n^2)
00:01:37 <centrinia> Can you?
00:01:49 <pumpkin_> unless the nub sorts, I doubt it
00:01:55 <centrinia> It shouldn't sort.
00:01:56 <pumpkin_> actually
00:02:10 <pumpkin_> you could just have it insert into a hashtable
00:02:22 <centrinia> Oh.
00:02:24 <pumpkin_> with a good hash function it should be O(n)
00:03:10 <centrinia> Wait, how do you hash an instance of Eq?
00:03:25 <pumpkin_> oh, in the context of Eq, I don't know :P
00:03:34 <pumpkin_> but in general
00:03:37 <ivanm> pumpkin_: ummm..... last time I checked, hash maps and functional programming don't mix too well
00:03:37 <lambdabot> ivanm: You have 1 new message. '/msg lambdabot @messages' to read it.
00:03:51 <pumpkin_> ivanm: probably not :) just saying in general though
00:03:54 <ivanm> and even in imperative programming, it's often recommended to use a tree (e.g. red-black) rather than a hash table
00:04:19 <ivanm> grrr.... lambdabot has just given me the same message for the third time :s
00:04:37 <centrinia> I was looking at the nubBy function implementation.
00:04:48 <ivanm> can someone with privileges please @flush lambdabot?
00:05:23 <Saizan> nubBy doesn't take advantage of any sortedness
00:06:04 <centrinia> Here: http://hpaste.org/12770
00:06:08 <ivanm> lambdabot still doesn't seem to like Data.Map :s
00:06:11 <centrinia> That really looks slow.
00:06:37 <pumpkin_> I guess it's the best they can do with only Eq
00:07:10 <centrinia> I still think that (nub . sort) is better than nub if you happen to work on Ord instances. :)
00:07:14 <ivanm> centrinia: it's O(n^2)... AFAIK, there's no faster/more efficient way of removing duplicates from an unsorted list without sorting
00:07:28 <ivanm> except comparing every element with every other element
00:07:35 <Saizan> centrinia: why? you're only making it less lazy
00:07:37 <ivanm> centrinia: nub . sort is slower than nub
00:07:50 <blackh> ivanm: so you sort it, then it's O(n logn)
00:07:53 <ivanm> since it has to sort it first, and then nubs on it
00:08:04 <ivanm> blackh: no, nub will still run the same
00:08:13 <blackh> ...then you re-write nub. :)
00:08:16 <ivanm> unless you want nub . sort == map head . group . sort
00:08:19 <centrinia> I thought nubbing a sorted list can be done in O(n) time.
00:08:24 <pumpkin_> but if you rewrite nub to sort, then it needs Ord
00:08:24 <ivanm> but as Saizan said, that lazy
00:08:29 <ivanm> centrinia: n log n
00:08:41 <pumpkin_> centrinia: you need uniq
00:08:41 <ivanm> centrinia: it won't work on infinite lists
00:08:42 <centrinia> No, the sorting can take O(n log n).
00:08:44 <pumpkin_> like the unix util uniq
00:08:47 <ivanm> since sort fails on infinite lists ;-)
00:08:48 <Saizan> ivanm: an already sorted list can be done in O(n)
00:08:55 <ivanm> Saizan: with nub? :o
00:09:03 <Saizan> ivanm: no, in general
00:09:10 <ivanm> well, yeah
00:09:17 <Saizan> nub is O(n^2) regardless of the list
00:09:19 <ivanm> except he's saying to use nub still
00:09:27 <centrinia> Oh.
00:09:33 <ivanm> sorting is log n at best (or is that n log n... I can't recall)
00:09:40 <papul> hi
00:09:44 <ivanm> hey papul
00:09:52 <pumpkin_> @let uniq = map head $ group
00:09:53 <lambdabot>  Couldn't match expected type `[[a]]'
00:09:54 <centrinia> Sorting can be done in O((log n)^2) time at best.
00:09:54 <blackh> ivanm: n if it's already sorted, otherwise n log n
00:09:57 <papul> hi ivanm
00:10:11 <pumpkin_> @let uniq xs = map head $ group xs
00:10:12 <lambdabot>  Defined.
00:10:12 <centrinia> @let uniq = (map head) . group . sort
00:10:13 <lambdabot>  <local>:6:0:
00:10:13 <lambdabot>      Equations for `uniq' have different numbers of arguments
00:10:13 <lambdabot>  ...
00:10:17 <papul> hello
00:10:19 <pumpkin_> :(
00:10:19 <ivanm> centrinia: where is the squared from?
00:10:21 <papul> hello
00:10:22 <papul> hello
00:10:24 <papul> hello
00:10:25 <papul> hello
00:10:27 <papul> hello
00:10:28 <pumpkin_> centrinia: now it's just like the uniq from unix :P
00:10:29 <papul> hello
00:10:31 <papul> hello
00:10:32 <pumpkin_> papul: please
00:10:33 <centrinia> ivanm: I don't know.
00:10:34 <Saizan> papul: stop
00:10:34 <ivanm> papul: you can stop spamming the channel now! ;-)
00:10:45 --- mode: ChanServ set +o Saizan
00:10:55 <papul> will anyone chat with me?
00:11:04 <pumpkin_> papul: not if you piss everyone off like that
00:11:05 <blackh> papul: no
00:11:09 * Smokey` thinks papul is a bot...
00:11:17 <pumpkin_> Smokey`: he's signed in with a real account
00:11:30 <Smokey`> and real accounts can't be compromised?
00:11:33 <Smokey`> heh.
00:11:39 <papul> i m not a bot
00:11:39 <centrinia> ivanm: You need to do the sorting in parallel to get anything faster than O(n).
00:11:40 <pumpkin_> :P
00:11:43 <Saizan> btw, a fast nub with an Ord context is not onw that sorts
00:11:56 <ivanm> centrinia: AFAIK, all comparison sorts are n log n
00:11:58 <ivanm> at best
00:12:01 <pumpkin_> yup
00:12:02 <papul> how many bots r here??????????????????????????????????????????????????????????????????????????????????????????????????????????/
00:12:07 <Saizan> but rather that stores the elements seen so far in a tree
00:12:11 <pumpkin_> papul: do you have any interest in haskell?
00:12:13 <ivanm> papul: only if you want to chat about haskell
00:12:25 <papul> what is haskell?
00:12:30 <pumpkin_> papul: you'll just get kicked if you continue to be obnoxious
00:12:43 <ivanm> papul: if you don't know, you probably shouldn't be in this channel ;-)
00:12:45 <papul> bye :p
00:12:45 <ivanm> see the topic
00:13:04 <ivanm> weird :s
00:13:06 --- mode: Saizan set -o Saizan
00:13:19 <Saizan> someone with too free time :)
00:13:23 <Saizan> +much
00:13:25 <ivanm> Saizan: heh, he never noticed you getting it ;-)
00:13:30 <ivanm> it == chanop
00:15:37 <Saizan> ?src sortBy
00:15:38 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
00:16:01 <Saizan> btw, isn't foldr the wrong one to use there?
00:16:37 <centrinia> ?src insertBy
00:16:38 <lambdabot> insertBy _   x [] = [x]
00:16:38 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
00:16:38 <lambdabot>                                  GT -> y : insertBy cmp x ys'
00:16:38 <lambdabot>                                  _  -> x : ys
00:16:50 <centrinia> Wow, that's slow.
00:16:54 <Saizan> (insertBy cmp) is strict in the second argument
00:17:08 <Saizan> centrinia: the real implementation of sortBy is a mergesort
00:17:18 <ivanm> centrinia: slow? O(n), isn't it (assuming comparisons are O(1) )
00:17:39 <ivanm> centrinia: oh, you mean sortBy? yeah, that would be O(n^2)
00:17:50 <Saizan> sortBy cmp = foldr (insertBy cmp) [] is from prelude
00:17:55 <pumpkin_> mmm insertion sort
00:17:57 <pumpkin_> :P
00:18:01 <Saizan> err, the haskell report i mean
00:20:10 <blackh> Did you say "insertion sort" ??
00:20:35 <centrinia> No, he said "stupid sort"
00:20:47 <bd_> reference implementation != efficient implementation
00:20:53 <centrinia> Stupid sort is still faster than enumeration sort.
00:21:27 <blackh> Apparently it's a mergesort in ghc 6.10.1.
00:21:28 <Saizan> hey, it's still better than selection sort
00:22:05 <pumpkin_> blackh: given @src sortBy, yeah :P
00:22:16 <Saizan> it has been a mergesort at least since base-2
00:22:24 <blackh> Well, thank goodness for that!
00:22:26 * ivanm thinks we should use bogosort for sortBy! ;-)
00:22:46 <pumpkin_> I once found a page of someone trying to find the slowest possible sort
00:22:50 <pumpkin_> even slower than bogosort
00:23:01 <ivanm> pumpkin_: bozosort maybe?
00:23:08 <pumpkin_> nah, slower than that
00:23:08 <dolio> sort l = sort l
00:23:10 <dolio> Done.
00:23:12 <ivanm> since you only randomly flip two elements in each iteration? :o
00:23:13 <pumpkin_> it was something like (n!!)^2 or something
00:23:27 <ivanm> dolio: umm..... that will never sort AFAICT, unless of course it's already sorted...
00:23:33 <pumpkin_> maybe randomly permute the list, then check if sorted, and if not randomly permute again?
00:23:40 <dolio> Yep. Takes forever. :)
00:24:11 <pumpkin_> ivanm: that way it takes longer, and consumes more randomness
00:24:15 <centrinia> @let enumsort as = let { remove x = filter (/= x); permutations [] = [[]]; permutations xs = [x:p | x <- xs, p <- permutations (remove x xs)]; sorted (x:y:xs) = if x>y then False else sorted (y:xs); sorted _ = True; } in head $ filter sorted $ permutations as
00:24:16 <lambdabot>  Defined.
00:24:26 <centrinia> > enumsort [5,2,1,4]
00:24:27 <lambdabot>   [1,2,4,5]
00:24:29 <pumpkin_> lol
00:24:34 <ivanm> pumpkin_: ummm.... that _is_ bogosort AFAICT...
00:24:51 <centrinia> I wouldn't recommend using enumsort on anything larger than 4 elements. :)
00:24:57 <pumpkin_> oh it is, you're right
00:25:06 <pumpkin_> > enumsort [5,4,2,3,1]
00:25:07 <lambdabot>   [1,2,3,4,5]
00:25:10 <pumpkin_> whee
00:25:16 <pumpkin_> > enumsort [5,4,2,3,14,2,5]
00:25:17 <lambdabot>   [2,3,4,5,14]
00:25:19 <pumpkin_> whee
00:25:24 <pumpkin_> wait, it's broken!
00:25:28 <ivanm> > enumsort [16,4,5,7,3,3,7,2,5,2,7,21,534]
00:25:33 <lambdabot>   [2,3,4,5,7,16,21,534]
00:25:38 <pumpkin_> it's broken!!
00:25:42 <centrinia> > enumsort [1,1,2]
00:25:43 <lambdabot>   [1,2]
00:25:48 <dolio> @type delete
00:25:49 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
00:25:53 <ivanm> pumpkin_: WORKSFORME, except for removing duplicates :@
00:25:58 <pumpkin_> yeah :)
00:26:06 <dolio> delete won't remove duplicates, if I recall correctly.
00:26:16 <ivanm> dolio: only first one
00:26:19 * araujo just got working the factorial in his small concatenative language!
00:26:24 <ivanm> you need to use a filter to remove all IIRC
00:26:45 <dolio> Right. He wants to remove one, though.
00:27:13 <centrinia> @let enumsort as = let { permutations [] = [[]]; permutations xs = [x:p | x <- xs, p <- permutations (delete x xs)]; sorted (x:y:xs) = if x>y then False else sorted (y:xs); sorted _ = True; } in head $ filter sorted $ permutations as
00:27:14 <lambdabot>  <local>:7:0:
00:27:14 <lambdabot>      Warning: Pattern match(es) are overlapped
00:27:14 <lambdabot>               In...
00:27:28 <centrinia> @unlet enumsort
00:27:28 <lambdabot>   Parse error
00:27:37 <centrinia> Uh, how do I unlet enumsort?
00:27:44 <centrinia> @let enumsort2 as = let { permutations [] = [[]]; permutations xs = [x:p | x <- xs, p <- permutations (delete x xs)]; sorted (x:y:xs) = if x>y then False else sorted (y:xs); sorted _ = True; } in head $ filter sorted $ permutations as
00:27:45 <lambdabot>  Defined.
00:27:53 <centrinia> > enumsort2 [1,1,2]
00:27:55 <lambdabot>   [1,1,2]
00:27:58 <pumpkin_> whee
00:28:09 <centrinia> > enumsort2 [3,1,4,1,5,9,2,6,5,3,5[
00:28:10 <lambdabot>   <no location info>: parse error on input `;'
00:28:12 <centrinia> > enumsort2 [3,1,4,1,5,9,2,6,5,3,5]
00:28:16 <centrinia> Wow.
00:28:27 <lambdabot>   thread killed
00:28:28 <blackh> a tumbleweed rolls by
00:28:29 <pumpkin_> > enumsort2 [5,2,4,1,5,6,7,1,2,4,7]
00:28:44 <lambdabot>   thread killed
00:28:49 <centrinia> > enumsort2 [3,1,4,1,5,9]
00:28:51 <lambdabot>   [1,1,3,4,5,9]
00:33:15 <centrinia> @let slowadd a b = if a < 0 then (slowadd (a+1) b) - 1 else if a > 0 then (slowadd (a-1) b) + 1 else b
00:33:16 <lambdabot>  Defined.
00:33:52 <centrinia> @let slowmultiply a b = if a<0 then -slowmultiply (-a) b else if b<0 then -slowmultiply a (-b) else if a == 0 then 0 else if b == 0 then 0 else slowadd a (slowmultiply (a-1) b)
00:33:53 <lambdabot>  Defined.
00:33:59 <centrinia> > slowmultiply 5 6
00:34:01 <lambdabot>   15
00:34:06 <centrinia> Wait.
00:34:08 <Smokey`> lol
00:34:23 <centrinia> > slowadd 5 6
00:34:24 <lambdabot>   11
00:34:57 <centrinia> @let slowmultiply2 a b = if a<0 then -slowmultiply2 (-a) b else if b<0 then -slowmultiply2 a (-b) else if a == 0 then 0 else if b == 0 then 0 else slowadd b (slowmultiply2 (a-1) b)
00:34:58 <lambdabot>  Defined.
00:35:05 <centrinia> > slowmultiply2 5 6
00:35:06 <lambdabot>   30
00:35:16 <centrinia> > slowmultiply2 1234 5678
00:35:18 <lambdabot>   * Exception: stack overflow
00:35:23 <centrinia> Okay.
00:35:36 <centrinia> > slowmultiply2 12 56
00:35:38 <lambdabot>   672
00:39:28 <blackh> Here's my inefficient function for the evening: \idx photo photos -> take idx photos ++ [photo] ++ drop (idx+1) photos
00:40:57 <pumpkin_> how do I get epsilon for floats in haskell?
00:42:04 <Saizan> > exp 1
00:42:05 <lambdabot>   2.718281828459045
00:42:29 <pumpkin_> I mean the smallest representable value in a float
00:42:37 <pumpkin_> > exp 1 :: CReal
00:42:39 <lambdabot>   2.7182818284590452353602874713526624977572
00:43:05 <centrinia> > let ep x = if x / 2 == 0 then x else ep (x/2) in ep 1.0 :: CReal
00:43:07 <lambdabot>   0.0
00:43:41 <Saizan> > let ep x = if x / 2 == 0 then x else ep (x/2) in ep 1.0 :: Float
00:43:42 <centrinia> > let ep i x = if x / 2 == 0 then i else ep (i+1) (x/2) in fst $ ep 0 (1.0 :: CReal)
00:43:42 <lambdabot>   1.0e-45
00:43:43 <lambdabot>       No instance for (Num (a, b))
00:43:43 <lambdabot>        arising from a use of `ep' at <inte...
00:44:12 <centrinia> > let ep i x = if x / 2 == 0 then i else ep (i+1) (x/2) in ep 0 (1.0 :: CReal)
00:44:14 <lambdabot>   138
00:44:34 <centrinia> > let ep i x = if x / 2 == 0 then i else ep (i+1) (x/2) in ep 0 (1.0 :: CFloat)
00:44:35 <lambdabot>       Not in scope: type constructor or class `CFloat'
00:44:39 <centrinia> > let ep i x = if x / 2 == 0 then i else ep (i+1) (x/2) in ep 0 (1.0 :: Float)
00:44:40 <lambdabot>   149
00:44:49 <centrinia> That doesn't make sense.
00:45:24 <pumpkin_> CReal ?
00:45:25 <centrinia> > let ep i x = if 1.0 + (x / 2) == 1.0 then i else ep (i+1) (x/2) in ep 0 (1.0 :: Float)
00:45:26 <lambdabot>   23
00:45:31 <centrinia> That's more like it. :)
00:45:49 <centrinia> > let ep x = if 1.0 + (x / 2) == 1.0 then x else ep (x/2) in ep (1.0 :: Float)
00:45:50 <lambdabot>   1.1920929e-7
00:46:16 <centrinia> > let ep x = if 1.0 + (x / 2) == 1.0 then x else ep (x/2) in ep 1.0 :: Double
00:46:18 <lambdabot>   2.220446049250313e-16
00:46:23 <centrinia> > let ep x = if 1.0 + (x / 2) == 1.0 then x else ep (x/2) in ep 1.0
00:46:24 <lambdabot>   2.220446049250313e-16
00:46:35 <pumpkin_> ooh
00:46:35 <centrinia> > let ep x = if 1 + (x / 2) == 1 then x else ep (x/2) in ep 1
00:46:36 <lambdabot>   2.220446049250313e-16
00:46:49 <centrinia> @let eps = let ep x = if 1 + (x / 2) == 1 then x else ep (x/2) in ep 1
00:46:50 <lambdabot>  Defined.
00:46:54 <centrinia> > eps :: Float
00:46:55 <lambdabot>   Couldn't match expected type `Float' against inferred type `Double'
00:47:00 <centrinia> Weird.
00:47:12 <pumpkin_> fail
00:47:14 <Saizan> Monomorphism Restriction strikes again
00:47:42 <centrinia> I don't think it is the monomorphism restriction.
00:47:51 <Saizan> it is
00:47:58 <Saizan> :t L.eps
00:48:00 <lambdabot> forall t. (Fractional t) => t
00:48:32 <Saizan> uhm
00:48:48 <Saizan> > typeOf eps
00:48:49 <lambdabot>   Double
00:49:13 <Saizan> @let eps :: Fractional t => t
00:49:15 <lambdabot>  Defined.
00:49:21 <Saizan> > eps :: Float
00:49:22 <lambdabot>   1.1920929e-7
00:49:26 <pumpkin_> hmm
00:49:26 <Saizan> it was :)
00:49:35 <pumpkin_> > eps :: Double
00:49:36 <lambdabot>   2.220446049250313e-16
00:49:42 <pumpkin_> > eps :: CReal
00:49:42 <pumpkin_> :o
00:49:44 <lambdabot>   0.0
00:49:47 <pumpkin_> !
00:50:14 <pumpkin_> > 1.1920928e-7 :: Float
00:50:15 <lambdabot>   1.1920928e-7
00:50:18 <pumpkin_> ahem
00:50:24 <pumpkin_> > 1.1920028e-7 :: Float
00:50:26 <lambdabot>   1.1920028e-7
00:50:31 <pumpkin_> fail.
00:50:51 <Saizan> why?
00:51:02 <pumpkin_> :t 1.1920028e-7 :: Float
00:51:03 <lambdabot> Float
00:51:12 <centrinia> :t eps
00:51:13 <lambdabot> forall t. (Fractional t) => t
00:51:14 <ManateeLazyCat> How do a string replace in exist string?
00:51:25 <pumpkin_> so I just represented a number smaller than supposed eps of a type in that same type?
00:51:35 <pumpkin_> ManateeLazyCat: returning a new string?
00:51:50 <centrinia> ManateeLazyCat: If you want to replace the occurrence of "foo" in a string, here is how:
00:52:08 <pumpkin_> > (eps :: Float) * 0.9 :: Float
00:52:09 <lambdabot>   1.0728836e-7
00:52:16 <pumpkin_> > (eps :: Float) * 0.1 :: Float
00:52:17 <lambdabot>   1.1920929e-8
00:52:41 <ManateeLazyCat> pumpkin_: I just want replace a part of string, and return a new string
00:52:54 <Cthulhon> eps is defined wrong... The 1.0+x==1.0 thing messes it up.
00:53:09 <Cthulhon> Er, +(x/2)
00:53:12 <centrinia> > let { repfoo t ('f':'o':'o':xs) = t++(repfoo t xs); repfoo t (a:as) = a:repfoo t as } in repfoo "bar" "what up fool!"
00:53:13 <lambdabot>   "what up barl!* Exception: /tmp/1283905071427860078:71:38-114: Non-exhausti...
00:53:29 <centrinia> > let { repfoo t ('f':'o':'o':xs) = t++(repfoo t xs); repfoo t (a:as) = a:repfoo t as; repfoo t [] = [] } in repfoo "bar" "what up fool!"
00:53:30 <lambdabot>   "what up barl!"
00:53:35 <centrinia> See. :)
00:53:37 <pumpkin_> lol
00:53:44 <pumpkin_> now that's a good general technique ;)
00:53:50 <centrinia> > let { repfoo t ('f':'o':'o':xs) = t++(repfoo t xs); repfoo t (a:as) = a:repfoo t as; repfoo t [] = [] } in repfoo "bar" "what up fol!"
00:53:51 <lambdabot>   "what up fol!"
00:54:28 <Cthulhon> Because floats don't step in constant intervals.  Saizan had it right with the eps that gave 1e-45.
00:55:18 <centrinia> pumpkin_: You can generalize my technique with Template Haskell. :)
01:01:24 <ManateeLazyCat> Have a exist Haskell library to handle String?
01:04:03 <dibblego> ManateeLazyCat, Data.List
01:04:14 <ManateeLazyCat> dibblego: Thanks
01:27:21 <pumpkin_> is there some way of forcing something like +RTS -N2 command-line parameter from inside my program?
01:27:50 <Lemmih> pumpkin_: Yes, but it's not pretty.
01:28:15 <pumpkin_> :(
01:28:30 <pumpkin_> nothing like setThreads 2 I guess? :P
01:29:05 <Lemmih> Nope, it involves C files. I'll find the docs.
01:29:25 <pumpkin_> ah, don't worry about it if it's a pain
02:17:17 <mbz> j #xmms2
02:29:24 <filcab42> hi all
02:32:08 <blackh> hello there
02:32:34 <filcab42> I was wondering...
02:32:52 <filcab42> is there any document that explains how GHC workd on the inside?
02:33:01 <filcab42> the several compilation phases, the optimizations, etc?
02:33:30 <blackh> I saw that recently... let me see.
02:36:42 <filcab42> k, tanks
02:36:44 <filcab42> *thanks
02:37:09 <blackh> ...searching....
02:37:17 <filcab42> yes, take your time ;-)
02:37:49 <Saizan> filcab42: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/HscMain
02:37:57 <Saizan> that's a short summary
02:38:10 <blackh> http://www.haskell.org/haskellwiki/The_Monad.Reader
02:38:12 <filcab42> nice
02:38:14 <filcab42> thanks :-D
02:38:24 <blackh> The latest Monad reader has an article on the subject - #12
02:39:06 <filcab42> thanks both of you... Maybe I'll ping back later :-)
02:39:56 <filcab42> Are there any whole-program optimizations?
02:40:06 <filcab42> by reading that HscMain page, it doesn't seem so
02:41:00 <filcab42> But I'll read this and then ask some more questions ;-)
02:48:28 <Saizan> filcab42: well, it does inline across modules by storing some of the definitions in the .hi files
02:52:28 <filcab42> nice
03:51:24 <chowmeined> what do you do if you want to override typeclass instance functions?
03:52:24 <chowmeined> or, can you hide a typeclass instance when importing a module?
03:53:11 <Saizan> chowmeined: no, you can't
03:53:28 <Saizan> chowmeined: the usual solution is to make a newtype and declare your instance on that
03:54:18 <eugene`> what labdabot command is to use ginn or jinn? (forgot the name and the command lol)
03:54:28 <chowmeined> Saizan, oh ok
03:54:52 <Saizan> @djinn a -> a
03:54:52 <lambdabot> f a = a
03:55:00 <eugene`> Saizan: thanks
03:56:19 <eugene`> @djinn (a, Either b c) -> Either b (a,c)
03:56:20 <lambdabot> f (a, b) =
03:56:20 <lambdabot>     case b of
03:56:20 <lambdabot>     Left c -> Left c
03:56:20 <lambdabot>     Right d -> Right (a, d)
03:58:09 <eugene`> clunky
03:58:23 <RWolf> is it possible to use Haskell in embedded systems? I mean limitations on dynamic memory usage.
03:59:27 <eugene`> RWolf: i'd assume one would have serious problems there because of laziness
04:00:01 <Saizan> nhc has that as one of its goals, iirc
04:01:03 <eugene`> i propose to include djinn as a pipeline in ghc ;) let the compiler derive implementation
04:01:30 <eugene`> i mean in the compilation pipeline
04:02:55 <eugene`> hmm, should not be that hard to wire a custom preprocessor even in perl heh
04:03:07 <ksf> @faq can haskell run on embedded systems?
04:03:07 <lambdabot> The answer is: Yes! Haskell can do that.
04:04:11 <eugene`> @faq can haskell do my laundry, wash my dishes, mop my floors, and go to work for me?
04:04:12 <lambdabot> The answer is: Yes! Haskell can do that.
04:04:45 * eugene` is euphoric!
04:06:31 <p_l> eugene`: The hardware side is not finished yet for that :P
04:06:56 <lilac> @faq Can Haskell leak space for no obvious reason?
04:06:56 <lambdabot> The answer is: Yes! Haskell can do that.
04:07:48 <mauke> @where oleg
04:07:48 <lambdabot> http://okmij.org/ftp/
04:08:11 <ivanm> @quote laundry
04:08:11 <lambdabot> Randroid says: I just wrote a monad that does my laundry. It threads it round and round until it's washed. Now I'm going to work on the Dryer monad.
04:08:14 <mauke> eugene`: http://okmij.org/ftp/Haskell/types.html#de-typechecker
04:08:18 <ivanm> eugene`: ^^ ;-)
04:11:00 <eugene`> mauke: you must be kidding me!  why is this not widely used?!
04:11:57 <blackh> @quote lightbulb
04:11:58 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
04:12:18 <blackh> How can there be no Haskell lightbulb joke?
04:13:03 <eugene`> this was it
04:13:08 <ivanm> @go haskell lightbulb
04:13:10 <lambdabot> No Result Found.
04:13:27 <eugene`> another one! lambdabot is hilarious
04:14:18 <ivanm> eugene`: I think you should cut back on the coffee a bit... ;-)
04:17:33 <eugene`> ivanm: on one hand, you might be right.
04:17:54 <byorgey> RWolf: I know many people have also had success using Haskell to build DSLs that generate code to run on embedded systems.  Not quite what you were asking, but... =)
04:33:42 <RWolf> byorgey: well, my question was more about if there were any compilers and coding agreements to keep Haskell code less memory-consuming
04:34:59 <metaperl> how do you 'Ask Reddit' something?
04:36:28 <byorgey> RWolf: right, I know, I just thought I would answer a different question =)
04:36:34 <metaperl> never mind. figured it out - http://www.reddit.com/r/programming/comments/7hrn9/where_should_i_post_my_resume_besides_dice_for_an/
04:40:17 <ma1c01m> hi! what is the biggest haskell project that solves some problem from real life (i mean not a compiler or some tool for programmers)?
04:43:18 <Beelsebob> ma1c01m: well, first, why not a compiler or programmer's tool, haskell's biggest strength is arguably writing compilers.
04:43:34 <Beelsebob> but I guess xMonad would be the answer
04:44:53 <eugene`> how do i qualify an import function again? import M qialify a as b?
04:44:57 <ma1c01m> ok and if also consider programmer's tools? i want to see how real world haskell project looks like
04:45:28 <blackh> e.g. import qualified Data.Map as M
04:45:37 <Saizan> ma1c01m: GHC, darcs
04:45:45 <Heffalump> I'd guess that some of the corporate users have proprietary code that isn't a compiler or programmers tool and is much larger than xmonad.
04:46:07 <blackh> GHC is a seriously impressive bit of code.
04:46:38 <kfish> ma1c01m, check out the projects and commercial users listed in http://www.haskell.org/communities/11-2008/html/report.html
04:46:43 <Beelsebob> ma1c01m: pugs too
04:47:16 <eugene`> @go haskell qualified import
04:47:23 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Modules
04:48:34 <ma1c01m> kfish: thanks!
04:50:19 <ma1c01m> Saizan, Beelsebob: already heard about them but nevertheless thank you
04:57:39 <boegel> I assume most Haskellers have seen the /. article on the rise of FP?
04:57:47 <ikkebr> ye
04:57:51 <ikkebr> it's always the same story
04:57:52 <ikkebr> year of linux
04:57:54 <ikkebr> year of fp
04:58:45 <Cthulhon> The comments on that were horrible.
04:59:23 <blackh> My secret weapon will remain secret for slightly longer, then. :)
04:59:27 <eugene`> :i MonadError
04:59:46 <eugene`> @i MonadError
04:59:46 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
05:00:01 <eugene`> :t MonadError
05:00:02 <lambdabot> Not in scope: data constructor `MonadError'
05:00:13 <Cthulhon> TFA was horrible too, but the comments moreso.
05:05:37 <eugene`> haven't used haskell in a while, would somebody help me a bit? how do i stop evaluation of mapping Eithers once i encounter Left? I remember something about MonadError
05:06:16 <blackh> You've lost me a bit
05:07:01 <eugene`> @djinn [Either a b] -> Either a [b]
05:07:01 <lambdabot> Error: Undefined type []
05:07:28 <mauke> :t sequence
05:07:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:08:43 <Toxaris> > sequence [Right 1, Right 2, Left "error", Right 3]
05:08:44 <lambdabot>   Left "error"
05:08:54 <eugene`> yeah, that beings me to a question, how does m a represent Either b c?
05:09:05 <eugene`> since either takes two type parameters
05:09:11 <zooko> lilac: so, maybe the instructions on this page should be updated to reflect the newer version of cabal-install?  http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
05:09:11 <Toxaris> m = Either b
05:09:22 <zooko> In any case, cabal-install-0.6.0 doesn't install cleanly for me either.
05:09:33 <eugene`> Toxaris: aha, thanks
05:09:53 <zooko> Or at all, actually.  It fails with http://codepad.org/WXrOqhvW
05:10:04 <eugene`> > sequence [Right 1, Left "a", Left "b"]
05:10:06 <lambdabot>   Left "a"
05:10:28 <eugene`> > sequence [Right 1, Right 2]
05:10:29 <lambdabot>   Add a type signature
05:10:49 <eugene`> > sequence [Right 'a', Right 'b']
05:10:50 <lambdabot>   Add a type signature
05:10:51 <mauke> > sequence [Right 1, Right 2] :: Either String Int
05:10:53 <lambdabot>   Couldn't match expected type `Int' against inferred type `[t]'
05:11:04 <mauke> > sequence [Right 1, Right 2] :: Either String [Int]
05:11:05 <lambdabot>   Right [1,2]
05:11:07 <eugene`> aha, it doesnt know the Either instance
05:11:30 <Toxaris> it can figure out [Int], but not String
05:11:30 <eugene`> mauke: thanks
05:11:32 <mauke> > sequence (tail [Left "", Right 1, Right 2])
05:11:33 <lambdabot>   Right [1,2]
05:13:11 <eugene`> :t (&&&)
05:13:12 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
05:14:17 <eugene`> i remember a trick to narrow down the type signature, forexample to show Arrow (->).  How one would do that?
05:14:43 <eugene`> that is instead of Arrow a
05:15:30 <eugene`> :t const (&&&) const
05:15:31 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
05:15:47 <lilac> zooko: hmm. do you have ghc-pkg in your path? if so, can you paste the output of "ghc-pkg list"
05:23:54 <Saizan> :t (id .) $ const (&&&) const
05:23:55 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
05:24:05 <byorgey> zooko: looks like you're missing the 'network' and 'parsec' packages.  those usually come bundled with ghc, unless you used some sort of minimal ghc install.
05:24:10 <byorgey> zooko: how did you install ghc?
05:24:15 <byorgey> and what version of ghc is it?
05:24:21 <eugene`> @djinn a -> (a,a)
05:24:22 <lambdabot> f a = (a, a)
05:24:30 <eugene`> nice. what's the arrow for that?
05:24:48 <byorgey> > (id &&& id) a
05:24:49 <lambdabot>   (a,a)
05:24:59 <eugene`> ah id!, thanks i was looking for that
05:25:02 <eugene`> was trying const
05:25:26 <byorgey> yeah, 'const x' is the function which ignores its input and returns x
05:25:33 <byorgey> 'id' is the identity function
05:26:22 <mauke> flip const == const id
05:27:11 <EvilTerran> > (,) `join` 1
05:27:13 <lambdabot>   (1,1)
05:27:22 <eugene`> :i join
05:27:31 <EvilTerran> ?hoogle join
05:27:31 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
05:27:31 <lambdabot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
05:27:31 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
05:27:32 <eugene`> @info join
05:27:33 <lambdabot> join
05:28:29 <EvilTerran> eugene`, it's using the "instance Monad ((->) e)"
05:29:28 <eugene`> my mind has not yet abstracted the concepts to think in terms of Monad a and more so Arrow a clearly. :(
05:30:54 <eugene`> hope more concrete and practical examples will make it fall into pieces while i write code
05:31:14 <zooko> lilac: http://codepad.org/HGNRl8Nb
05:31:23 <zooko> byorgey: from the source tarball, 6.10.1.
05:31:29 <eugene`> like what the Arrow a => a b c actually means
05:31:42 <boegel> man, I should really freshen up my Haskell-fu
05:32:32 <zooko> Maybe I need to install the extras tarball.
05:32:32 <eugene`> it's easy to say 'computation composition'
05:32:39 <lilac> zooko: right, i assume you didn't install the extralibs tarball
05:32:58 <lilac> the easiest way to get cabal-install working would probably be to install just parsec and network from hackage
05:32:59 <EvilTerran> eugene`, i disagree, that's quite a mouthful :P
05:33:00 <byorgey> zooko: yup, that ought to do it
05:33:08 <byorgey> zooko: that's where all the bundled libs are
05:33:15 <boegel> is there a decent set of Haskell benchmarks already?
05:33:51 <zooko> Thanks.
05:33:54 <lilac> zooko: http://hackage.haskell.org/packages/archive/parsec/3.0.0/parsec-3.0.0.tar.gz http://hackage.haskell.org/packages/archive/network/2.2.0.1/network-2.2.0.1.tar.gz
05:34:11 <byorgey> eugene`: yup, concrete examples help.
05:34:29 <byorgey> eugene`: and hopefully an article I am planning to write for the next Monad.Reader will help too =)
05:34:51 <eugene`> @gjinn [a,Maybe b] -> Maybe [a,b]
05:34:52 <lambdabot> Cannot parse command
05:35:33 <byorgey> eugene`: something of type  Arrow a => a b c  represents a computation that has an input of type b and produces an output of type c.
05:35:39 <EvilTerran> eugene`, the list type constructor "[]" only takes one parameter
05:35:59 <byorgey> eugene`: I actually prefer writing it as  Arrow (~>) => b ~> c
05:36:00 <EvilTerran> eugene`, you're confusing it with the list *value* syntactic sugar
05:36:01 <eugene`> @gjinn Maybe (a,Either b c) -> Either b (Maybe (a,c))
05:36:01 <lambdabot> f a =
05:36:01 <lambdabot>     case a of
05:36:01 <lambdabot>     Nothing -> Right Nothing
05:36:01 <lambdabot>     Just (b, c) -> case c of
05:36:01 <lambdabot>                    Left d -> Left d
05:36:03 <lambdabot>                    Right e -> Right (Just (b, e))
05:38:27 <eugene`> ok, what i need now is [String,IO (Either Error Result)]->IO (Either Error (String,Result))
05:38:44 <byorgey> eugene`: [String, IO (Either Error Result)] doesn't make sense
05:38:57 <byorgey> you can't have a list with two types of things in it
05:39:13 <byorgey> did you mean (String, IO (Either Error Result)) ?
05:39:48 <vixey> heh [String,IO (Either Error Result)]
05:39:55 <vixey> what does it mean?
05:40:28 <byorgey> vixey: I think it means a list which alternates between Strings and IO (Either Error Result)'s
05:41:24 <byorgey> eugene`: but anyway, this sounds like a job for conal's semantic editor combinators!
05:41:29 <eugene``> electricity went off
05:41:43 <byorgey> heh, whoops
05:41:46 <vixey> data Intercalist p q where Nil :: Intercalist p q; Cons :: p -> Intercalist q p -> Intercalist p q
05:42:11 <byorgey> eugene``: did you get my earlier messages?
05:42:19 <byorgey> vixey: exactly! =D
05:42:29 <eugene``> yeah, i meant [(String,IO (Either Error Result))] -> IO (Either Error [(String,Result)])
05:42:36 <eugene``> byorgey: nope ... :(
05:42:53 <olsner> @unpl (((. head . uncurry zip . splitAt 1 . repeat) . uncurry) .) . (.) . flip
05:42:54 <lambdabot> (\ k ac af -> uncurry (\ e h -> k h (ac e)) (head (uncurry zip (splitAt 1 (repeat af)))))
05:42:59 <olsner> @pl (((. head . uncurry zip . splitAt 1 . repeat) . uncurry) .) . (.) . flip
05:42:59 <lambdabot> (((. (head . uncurry zip . splitAt 1 . repeat)) . uncurry) .) . (.) . flip
05:43:00 <byorgey> eugene``: oh, never mind, I was just saying your type seemed wrong
05:43:37 <pyNem> I am trying to do a problem from Project Euler
05:43:41 <pyNem> http://hpaste.org/12776
05:43:50 <pyNem> running into type issues with Integer Floating, Real Frac, et al
05:43:53 <pyNem> can anyone help me out?
05:43:59 <pyNem> or link me?
05:44:13 <zachk1> there are a bunch of different operators pay close attention to your types
05:44:45 <zachk1> like there is (/) and div, one is for integers the other is for the rest
05:44:47 * vixey s/Intercallist/Swizzalist/
05:45:01 <zachk1> try sprinkling your code with fromIntegral num
05:45:29 <pyNem> zachk1, sure
05:45:50 <pyNem> zachk1, can I read about this heirarchy's why's and how's somewhere?
05:45:57 <byorgey> @type uncurry (fmap . fmap . zip) . second (sequence . sequence) . unzip
05:45:58 <lambdabot> forall b a. [(a, [[b]])] -> [[[(a, b)]]]
05:46:14 * jkff resists the temptation of visiting project euler and solving another problem or two instead of doing more important things
05:46:18 <zachk1> pyNem: i dont know the location i picked up it piece by piece
05:46:30 <pyNem> zachk1, ok .. :)
05:46:33 <zachk1> pyNem: use ghci and the :t command to check types
05:46:45 <pyNem> zachk1, yeah :)
05:48:25 <byorgey> @type uncurry (\ss -> fmap (fmap (zip ss))) . second (fmap sequence . sequence) . unzip
05:48:27 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *) a1. (Monad m1, Monad m, Functor m1, Functor m) => [(a1, m1 (m a))] -> m1 (m [(a1, a)])
05:48:39 <byorgey> eugene``: ^^^
05:48:44 <zooko> Sigh.  Some weird ghc-pkg error after I untarred extralibs over the top and remade.
05:48:49 <byorgey> but there has GOT to be an easier way to do that... =P
05:48:53 <zooko> So now I did make clean and now it will be an hour or something before I can try again.
05:48:56 <eugene``> byorgey: m wow. how did you come up wioth that
05:49:12 <byorgey> eugene``: lots of practice =)
05:49:24 <byorgey> and good intuition
05:50:53 <pyNem> zachk, I got around the problem, by definining my function completely differently.. :) .. Not sure if that was a good thing .. but yeah .. for now it works :D
05:51:03 <drbean> @hoogle [[a]]->[[a]]
05:51:04 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
05:51:04 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
05:51:04 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
05:53:27 <byorgey> wow, I just realized how quickly 'sequence' blows up if you iterate it on a list of lists
05:53:31 <zachk> pynem: sweet, ive slammed my head into the wall quite a few times with Haskell's num tree. but for the pickiness of it compared to say mzscheme, you get really fast compiled code so i think its a decent trade off
05:53:34 * byorgey boggles
05:54:06 <eugene``> byorgey: :( i dont have Monad (Either Error) defined... that's Text.Yahoo.Types
05:54:09 <zachk> byorgey: i think you would be generating alot of permuations, not sure, but those things blow up very fast
05:54:27 <pyNem> zachk :) .. I dont know too much about mzscheme .. quite new to func prog.. just the little haskell and the little lisp
05:54:35 <byorgey> zachk: well, more like combinations then permutation, but yes =)
05:56:23 <byorgey> eugene``: oh, yeah, that's super-annoying.  something to do with MonadError, the 'fail' method, and other such nonsense.
05:56:38 <byorgey> eugene``: well, it's easy enough to make your own Monad instance for (Either Error)
05:57:18 <byorgey> instance Monad (Either Error) where  return = Right; (Left e) >>= _ = Left e; (Right a) >>= f = f a
05:57:29 <zachk1> pynem: scheme is like the minimalist child of lisp, but its syntax gets boring and old
05:58:26 <pyNem> zachk1, will look into it soon .. planning on doing some structure and interpretations of computer programs this winter from the mit vid lecs .. it uses scheme, right?
05:58:47 <byorgey> running 'sequence' on an n-element list containing m-element lists results in an m^n-element list containing n-element lists
05:59:25 <byorgey> so iterating it gives  (n,m),  (m^n,n),  (n^(m^n), m^n),  ((m^n)^(n^(m^n)), n^(m^n))...
05:59:51 <byorgey> > ((3^2)^(2^(3^2))
05:59:52 <lambdabot>   <no location info>: parse error on input `;'
05:59:58 <byorgey> > ((3^2)^(2^(3^2)))
05:59:59 <lambdabot>   373391848741020043532959754184866588225409776783734007750636931722079040617...
06:00:00 <mathijs> Can someone please explain (or point me to an explaination) why someFunc (x:xs) = someFunc' x ++ someFunc xs isn't tail-recursive?
06:00:03 <byorgey> yeesh
06:00:20 <mauke> mathijs: because the final call is to (++), not someFunc
06:01:11 <mathijs> mauke: and ++ won't start until it has both arguments fully evaluated?
06:01:23 <mauke> irrelevant
06:01:29 <eugene``> how do i include -XFlexibleInstances? {- GHC_OPTIONS ... -} right?
06:01:44 <mauke> eugene``: {-# LANGUAGE FlexibleInstances #-}
06:02:28 <byorgey> mathijs: ++ can, in fact, start doing useful work before both arguments are fully evaluated.  but laziness or lack thereof has no bearing on tail recursion.
06:02:31 <eugene``> mauke: yeah thanks :)
06:02:45 <eugene``> haskell-mode does not recognise that syntax
06:03:11 <byorgey> let sequenceStep (n,m) = (m^n, n) in take 5 (iterate sequenceStep (2,2))
06:03:15 <mathijs> mauke: I don't get it.. when somefunc (x:xs) = somefunc' x : somefunc xs is used, it's not tail-recursive either, since the last call is to (:) right?
06:03:18 <byorgey> > let sequenceStep (n,m) = (m^n, n) in take 5 (iterate sequenceStep (2,2))
06:03:31 <mauke> mathijs: right
06:03:34 <lambdabot>   thread killed
06:03:52 <eugene``> thanks for the function byorgey!  if i could only look inside your mind how you came up with it :P
06:04:21 <byorgey> eugene``: well, hopefully if I get this Monad.Reader article written, you will be able to =)
06:04:42 <eugene``> byorgey: another question, just to be sure (you never know), it's lazy, right?
06:04:52 <eugene``> byorgey: please do
06:05:04 <byorgey> I plan to write on exactly that topic: gaining intuition for various type classes and how to use/manipulate them.
06:05:07 <byorgey> or something like that.
06:05:16 <eugene``> super
06:06:13 <byorgey> eugene``: hmm, it's not very lazy
06:06:24 <byorgey> first of all, IO is involved, and you can
06:06:36 <byorgey> *can't interleave evaluation of the IO action with its execution
06:06:44 <eugene``> byorgey: i must not execute another IO if Left is reached
06:06:45 <byorgey> unless you use something magical like unsafeInterleaveIO
06:07:23 <byorgey> secondly, since the IO action evaluates to an Either Error blah, the blah can't be lazily computed since you need to know whether it is an error or not
06:08:00 <byorgey> eugene``: oh, hmm, let me think about that
06:08:12 <eugene``> well yeah, but once we know it's an error, we can, but should not look any further
06:09:19 <eugene``> because the ultimate return type is one Either, not many
06:09:35 <byorgey> eugene``: oh, hrm, I see, the code I gave you will not do what you want
06:09:45 <eugene``> ah, you're concatenating all errors
06:09:47 <byorgey> or, hmm, maybe it will
06:09:51 <byorgey> I am not sure!
06:10:07 <eugene``> all i need is first, then i need to abort
06:10:15 <eugene``> keeping what i got so far
06:10:25 <byorgey> the question is whether it will evaluate all the IO actions
06:10:34 <eugene``> yeah
06:10:59 <byorgey> eugene``: well, try it with a list of three IO actions: the first and third should print "blah" and then return successfully, and the second should return an error
06:11:08 <byorgey> and see if it prints "blah" once or twice
06:16:00 <byorgey> eugene``: ah, yup, as I feared
06:16:15 <byorgey> it doesn't lazily evaluate the IO actions
06:16:22 <byorgey> since I used 'sequence'
06:16:37 <byorgey> well, you can still do what you want, it will just be a little more complex
06:17:45 <eugene``> my initial intuition was to use arrows
06:17:57 <jkff> > putStrLn "Does lambdabot perform IO actions?"
06:17:59 <lambdabot>   * Exception: "<IO ()>"
06:22:48 <byorgey> http://hpaste.org/12777
06:22:50 <byorgey> eugene``: ^^^
06:23:08 <byorgey> I don't think arrows would necessarily help.
06:24:44 <eugene``> byorgey: great! thanks for your help and explanation :)
06:27:26 <eugene``> byorgey: so you think there's no builtin way of doing it?  I assume arrows must be able to solve that since it's similar to circuit.  Just dont know how yet.
06:27:41 <telexicon> its too bad Text.Xhtml isnt stronger typed
06:27:53 <eugene``> it's very interesting that even manual recursion seems to be a form of "manual labor" with Haskell
06:28:06 <eugene``> telexicon: i have the same feeling
06:28:25 <eugene``> telexicon: check out oleg's SXML
06:28:46 <telexicon> like it'd be nice if it made sure blocks and inlines were only allowed in the right places
06:29:02 <eugene``> telexicon: oleg's SXML
06:29:07 <eugene``> @go SXML
06:29:08 <lambdabot> http://okmij.org/ftp/Scheme/SXML.html
06:29:09 <lambdabot> Title: SXML
06:29:13 <telexicon> ok ...
06:29:26 <eugene``> ah sorry
06:29:31 <eugene``> @go HSXML
06:29:33 <lambdabot> http://okmij.org/ftp/Scheme/xml.html
06:29:33 <lambdabot> Title: XML and Scheme
06:29:44 <eugene``> telexicon: it's HSXML
06:30:27 <byorgey> eugene``: it might be possible somehow using foldM, perhaps
06:30:46 <byorgey> but at this point the "manual" way seems easiest
06:31:07 <byorgey> and yes, it is interesting how explicit recursion is seen as a form of "manual labor" =)
06:31:08 <eugene``> byorgey: yeah, the type signature is almost as long
06:31:39 <byorgey> there are so many great recursion combinators that 99% of the time, if you write some manual recursion, chances are you're reinventing the wheel
06:31:57 <eugene``> agreed
06:32:15 <byorgey> but in my opinion this is one of the other 1% =)
06:33:41 <vixey> I've never found ______morphisms that work for tearing down two structures at one
06:34:00 <vixey> joinTrees ((p1,t1) : (p2,t2) : freqs) = joinTrees (insertBy (comparing fst) (p1 + p2,Branch t1 t2) freqs)
06:34:00 <vixey> joinTrees [(_,tree)] = tree
06:34:06 <vixey> like that, .. for example
06:34:31 <vixey> ugh that was not the example I meant
06:35:05 <ski_> the `p's being weights ?
06:35:07 <vixey> this http://hpaste.org/12778
06:35:27 <vixey> yes ski
06:36:41 <olsner> byorgey: for the other 1% maybe you can use a zygohistomorphic prepromorphism :P
06:36:45 <vixey> thinking about it now.. might just be a fold
06:37:33 <h0tzenpl0tz> hello, how do i "all" a "IO [Bool]" List to "IO Bool" ?
06:37:46 <ski_> vixey : i was thinking that :)
06:37:47 <byorgey> olsner: that's true =)
06:37:50 <lilac> h0tzenpl0tz: liftM all
06:38:10 <lilac> h0tzenpl0tz: sorry, liftM and
06:38:19 <byorgey> h0tzenpl0tz: in general you can use liftM (or equivalently, fmap) to apply a function 'inside' a monad/functor.
06:38:41 <h0tzenpl0tz> already tried that, seems im using it the wrong way...
06:38:42 <byorgey> so if  f :: a -> b,  then  liftM f :: (Monad m) => m a -> m b
06:38:51 <h0tzenpl0tz> return (liftM all) (==True) (mapM (\fe -> fe2T fe f) fl)
06:39:10 <lilac> h0tzenpl0tz: liftM and (mapM (\fe -> ...))
06:39:13 <byorgey> h0tzenpl0tz: you don't want the 'return' there
06:39:29 <byorgey> also, (==True) is the identity function =)
06:39:30 <lilac> h0tzenpl0tz: also, liftM is only for unary functions
06:40:07 <lilac> h0tzenpl0tz: if you wanted to use 'all', you'd have to do something like "liftM2 all (return id) (mapM ...)"
06:40:23 <lilac> or liftM (all id) (mapM ...)
06:40:23 <byorgey> think you need more parens there
06:40:24 <h0tzenpl0tz> i think i just got it, thanks alot!
06:40:30 <eugene``> i wonder if it's possible with current extensions to write a polyvariadic liftM
06:40:44 <byorgey> h0tzenpl0tz: great!
06:41:05 <Saizan> eugene``: it is
06:41:23 <olsner> I tried to build a polyvariadic liftM, but ended up copy-pasting together the liftM17 I needed
06:41:27 <h0tzenpl0tz> hard to get into these monads... works now, thanks alot guys
06:41:32 <vixey> and = all id ?
06:41:37 <byorgey> olsner: gah, use Applicative!
06:41:55 <byorgey> liftM17 f a b c d ....  === f <$> a <*> b <*> c <*> .....
06:41:56 <eugene``> olsner: heh
06:42:02 <vixey> where is the liftM^n ?
06:42:20 <byorgey> vixey: yes, and = all id
06:42:43 <mbz> wtf is zygohistomorphic prepromorphism?
06:42:49 <eugene``> :t and
06:42:50 <lambdabot> [Bool] -> Bool
06:42:53 <vixey> @go zygohistomorphic prepromorphism
06:42:55 <lambdabot> No Result Found.
06:43:00 <vixey> :(
06:43:08 <vixey> @go real world #haskell
06:43:10 <lambdabot> http://www.realworldhaskell.org/
06:43:11 <lambdabot> Title: Real World Haskell
06:43:12 <byorgey> mbz: http://haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms
06:43:29 <byorgey> mbz: it's kind of a joke =)
06:43:33 <vixey> http://haskell.org/haskellwiki/Real_World
06:43:35 <vixey> http://haskell.org/haskellwiki/Real_World#Haskell
06:43:35 <byorgey> but also kind of not
06:43:46 <ehird> how could it be a joke
06:43:58 <eugene``> > and <$> [True,Ture] <*> [True,False]
06:43:59 <lambdabot>   Not in scope: data constructor `Ture'
06:44:03 <ehird> zygohistomorphicisms are the best transformation for prepromorphisms, which lets you code purely functional monads.
06:44:10 <mbz> oh
06:44:16 <ehird> duh.
06:44:18 <ehird> :P
06:44:19 <eugene``> > and <$> [True,True] <*> [True,False]
06:44:20 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `Bool'
06:44:25 <vixey>  (&&)
06:44:26 <olsner> ehird: *obviously*
06:44:29 <vixey> instead of and
06:44:35 <eugene``> ah right
06:44:57 <eugene``> > (&&) <$> [True,True] <*> [True,False]
06:44:58 <lambdabot>   [True,False,True,False]
06:45:01 <ehird> @quote caleskell
06:45:01 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
06:45:09 <ehird> i forget who coined that term. i know i witnessed it.
06:46:18 <vixey> > 190^061
06:46:19 <lambdabot>   100918237733446385429901686330429259345784694966621585759393953165826465278...
06:47:07 <lilac> > Just 42 <^(+)^> Just 76
06:47:08 <lambdabot>   Not in scope: `<^'Not in scope: `^>'
06:47:16 <Asgaroth> If I have a monadic computation of type m Bool, how can I run it until it returns true in a non-stack-overflowing manner(so no explicit recursion)?
06:47:41 <vixey> Asgaroth, explicit recursion isn't what causes the stack overflow..
06:48:12 <vixey> :t whileM
06:48:13 <lambdabot> Not in scope: `whileM'
06:48:17 <vixey> :t while
06:48:18 <lambdabot> Not in scope: `while'
06:48:26 <vixey> I thought that there was one of these already
06:48:27 <Asgaroth> vixey: It's not? Well the function this occurs in isn't tail-recursive, so it should create problems, right?
06:48:32 <vixey> :t untilM
06:48:33 <lambdabot> Not in scope: `untilM'
06:48:44 <vixey> Asgaroth, no that's not relevant in haskell
06:48:52 <mbz> almost all compilers can optimize tail recursion to a plain loop
06:49:01 <mbz> even gcc can
06:49:07 <vixey> ok but we're not using gcc :)
06:49:13 <mauke> or tail recursion
06:49:19 <vixey> or chicken scheme or ocamlc..
06:49:23 <Asgaroth> Yes, but my function isn't tail-recursive, therefore I figured that might be the cause.
06:49:34 <byorgey> in a lazy language, the important thing is not tail recursion but so-called "guarded recursion"
06:49:35 <lilac> untilM = fix (unless =<< action)
06:49:55 <byorgey> as long as all recursive calls are "guarded" by one or more constuctors, the function can evaluate lazily
06:50:08 <byorgey> for example:  repeat x = x : repeat x
06:50:18 <byorgey> the recursive call to 'repeat x' is guarded by the : constructor
06:50:43 <byorgey> so it will lazily produce x's, they will be consumed by another function in parallel, and the GC will come along behind and clean up
06:50:49 <byorgey> voila! constant space.
06:51:13 <lilac> "repeat x = let xs = x:xs in xs" is even better
06:51:24 <byorgey> indeed.
06:51:33 <byorgey> then the GC doesn't even need to get involved.
06:51:53 <Asgaroth> Currently I'm realizing it this way: http://hpaste.org/12780 . Could this be the cause for a stack overflow?
06:52:49 <Asgaroth> where swapRound is of type State foo Bool.
06:53:19 <olsner> byorgey: btw, I looked, apparently I wrote my liftM17 as read17 = return f `ap` trimRight readP `ap` ...
06:53:44 * byorgey is not surprised =)
06:54:56 <byorgey> Asgaroth: it probably has more to do with exactly what swapRound and isValid are doing.
06:55:02 <olsner> instance (Parse a, ... Parse q) => Parse (a,,...,q) where readP = read17 (,,,,,,,,,,,,,,,,)
06:55:09 <vixey> Angaroth, I can't even understand it :(
06:55:31 <vixey> why does solvePerm' exist?
06:55:33 <r3m0t_> :type read5
06:55:37 <byorgey> Asgaroth: for example, perhaps swapRound builds a big thunk which is never actually executed until evaluated by isValid, which blows the stack.
06:56:01 <olsner> r3m0t_: custom function :)
06:56:17 <byorgey> Asgaroth: you might want to try using Control.Monad.State.Strict .
06:56:34 <byorgey> just change the import and it will use a strict version of the State monad.
06:57:05 <Asgaroth> byorgey: Thanks, it works!
06:57:13 <byorgey> Asgaroth: great!
06:57:23 <Saizan> just by changing the import?
06:57:34 <byorgey> in general, if something overflows the stack, it is usually due to too much laziness
06:57:41 <olsner> Asgaroth: solvePerm' _ = gets isValid
06:57:49 <Asgaroth> byorgey: I'm going to look more closely for the cause anyway though, so I'll figure similar issues out on my own next time.
06:58:02 <byorgey> some huge thunk is being built but not evaluated because it is not needed until the end
06:58:26 <byorgey> then when it is finally needed, a whole bunch of stuff gets pushed on the stack when evaluating this huge thunk
06:58:52 <ski_>   xs@(repeat x) = x : xs  -- /me 'd like to write this
06:59:05 <vixey> heh
06:59:10 <byorgey> Asgaroth: read the stack overflow page on the wiki, it has a really good explanation of all this
06:59:13 <byorgey> http://haskell.org/haskellwiki/Stack_overflow
06:59:24 <Asgaroth> Thanks, I will.
07:00:02 <byorgey> Asgaroth: also, note that  if p then True else False == p
07:00:05 <ski_>   frob@(map f) (x:xs) = f x : frob xs  -- another example
07:00:23 <Asgaroth> byorgey: Yes, I saw that after I posted the quote too.
07:00:28 <byorgey> ok =)
07:00:35 <vixey> x@(fix f) = f x ?
07:01:11 <Asgaroth> byorgey: The code is a just a quick prototype-implementation anyway and will need much more optimization anyway.
07:01:26 <olsner> ski_: ooh, interesting :)
07:01:46 <byorgey> Asgaroth: sure
07:02:39 <ski_> vixey : indeed
07:03:45 <ski_> hm .. or maybe
07:03:53 <ski_>   fix f = x @ (f x)
07:04:02 <ski_> (does that look weird ?)
07:04:06 <vixey> yes very
07:04:13 * ski_ smiles
07:05:05 <mbz> ?src fix
07:05:05 <lambdabot> fix f = let x = f x in x
07:05:22 <Saizan> x@(fix f) = f x == fix f = let x = fix f in f x ?
07:05:49 <Saizan> ?let fix' f = let x = fix' f in f x
07:05:51 <lambdabot>  Defined.
07:05:56 <Saizan> > fix' (1:)
07:05:57 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:07:28 <ski_> (vixey : a larger example of that variant is at <http://hpaste.org/12201#a4>)
07:13:12 <ski_> (Saizan : rather, i think `forall f x. x@(fix f) = f x  <=>  forall f. fix f = let {x = f x} in x  <=>  forall f. fix f = x where {x = f x}')
07:14:11 <Saizan> does that work in the map case?
07:14:51 <ski_> hm
07:15:06 <ski_>   frob@(map f) (x:xs) = f x : frob xs
07:15:11 <Saizan> ah, i guess it becomes frob@(map f) = \(x:xs) -> f x : frob xs, and then you apply the same
07:15:24 <ski_>   frob@(map f) = \xs0 -> case xs0 of ...; (x:xs) -> f x : frob xs
07:15:39 <ski_>   map f = frob where frob xs0 = case xs0 of ...; (x:xs) -> f x : frob xs
07:15:52 <ski_>   map f = frob where ...; frob (x:xs) = f x : frob xs
07:15:54 <ski_> i suppose
07:17:29 <ski_> (maybe it gets more complicated if different defining equations use `@' on different "prefixes" of the definiendum)
07:17:51 <Saizan> (yeah)
07:18:43 <vixey> cool
07:18:44 <vixey> cabal: dependencies conflict: ghc-6.11.20081031 requires Cabal ==1.5.5 however
07:18:45 <vixey> Cabal-1.5.5 was excluded because plugins-1.3.1 requires Cabal ==1.4.*
07:18:48 <ski_> (yet another way of stating the `fix' one would be to allow `fix f = x = f x' ..)
07:20:05 <Saizan> plugins probably doesn't work on ghc-6.10+ anyhow
07:26:22 <shapr> bos: I picked up 15 or so new followers after your blog post, you got da fame!
07:28:36 <zooko> http://codepad.org/sKLZfJGs <-- ghc-6.10.1 won't build on my GNU/OpenSolaris server
07:28:49 <zooko> I worked around it by replacing the contents of mkdirhier with "mkdir -p $*"
07:28:55 <zooko> How should I report this issue ?
07:29:15 <p_l> zooko: It called mkdirhier?
07:30:34 <zooko> p_l: utils/mkdirhier/mkdirhier
07:30:41 <zooko> which is created at some point in the build process from utils/mkdirhier/mkdirhier.sh
07:30:51 <p_l> zooko: ... weird
07:30:53 <zooko> replaceing the body of the latter -- mkdirhier.sh -- with "mkdir -p $*"
07:30:55 <zooko> works-around the problem.
07:31:08 <zooko> So, aside from wanting help to compile ghc-6.10.1 myself.
07:31:29 <zooko> I would also like to contribute the knowledge of this error to the ghc folks so that future versions of ghc compiled on GNU/OpenSolaris will work.
07:31:31 <zooko> How do I do that?
07:31:48 <mauke> file a bug, I guess
07:31:55 <mauke> but consider using mkdir -p "$@" instead
07:32:23 <zooko> Hm.  It suddently occurs to me that maybe ghc-6.10.1 requires ghc 6.10 to compile?  Or something?
07:32:29 <zooko> Mayb ethis would explain why it fails on some of my boxes.
07:32:31 <mauke> no, 6.10.1 is 6.10
07:32:36 <shapr> Hiya zooko!
07:32:45 <zooko> Hi there, shapr!  How's it going?
07:32:49 <zooko> Yes, this box has ghc-6.6.
07:32:50 <shapr> Life is exciting!
07:33:01 * zooko looks for "What is required to build ghc-6.10.1..."
07:33:11 <zooko> What's up with you nowadays?
07:33:31 <Heffalump> zooko: anything from ghc 6.4 should do it
07:33:46 <Heffalump> there was some discussion on some list (glasgow-haskell-users?) about this a few days ago
07:33:47 <shapr> zooko: C# for work, Haskell & Cell assembly for fun. What about you?
07:33:50 <p_l> anyway, why use some weird script instead of mkdir -p ?
07:33:56 <Heffalump> it ought to be on the wiki somewhere but wasn't at that point, I think
07:34:11 <zooko> "The source distribution needs an installed GHC (version 6.4.2 at least)."
07:34:14 <zooko> Yeah, right.
07:34:27 <zooko> Here's what I get when compiling with ghc-6.6.:
07:35:00 <zooko> http://codepad.org/leBbvqZn
07:35:25 <zooko> Maybe this has nothing to do with the haskell compiler.
07:35:49 <zooko> Looks like it is trying to eval a bash script with spaces in it or something...
07:36:36 <zooko> shapr: I work in Python all the time, and occasionally C++, and I am happy.
07:36:57 <shapr> Lexer.x is an Alex lexer.
07:37:24 <shapr> zooko: I bought two interesting computers recently, a BUG from BUGlabs, and an IBM BladeCenter. They're both profiles I've not tried before.
07:37:53 <shapr> Looks like I'll be using Jython on the BUG.
07:38:03 <SamB_XP> why?
07:38:10 <shapr> Why what?
07:38:16 <SamB_XP> why Jython ?
07:39:08 <zooko> shapr: what are you doing with Cell assembly?
07:39:12 <shapr> Oh, because the BUG is primarily written in Java with a layer of C underneath that, so I want to try the idiomatic approach first.
07:39:23 <zooko> I looked at that recently, investigating embedded CPUs for the SHA-3 project.
07:39:54 <zooko> shapr: oh my goodness.  A little embedded thingie primarily uses Java?  How sad.
07:40:05 <shapr> zooko: I have seven dual 3.2 GHz Cell blades for my IBM BladeCenter.
07:40:29 <shapr> zooko: Do you have Alex installed? If so, can you try explicitly setting it in configure?
07:40:51 <zooko> shapr: I'm not aware of having Alex installed, so I probably don't.
07:41:17 <zooko> So, I have some questions about Cell assembly.  How many registers for general use, and how big are they?
07:41:30 <zooko> And is it super-fast at SIMD?
07:42:14 <p_l> zooko: Its SPUs are vector CPUs. SIMD is their default way of working
07:42:33 <shapr> Agda has a Lexer.x, and it's an Alex lexer file, and the Makefile rule for it is $(OUT)/%.hs : %.x  \n $(ALEX) $(ALEX_FLAGS) -o $@ $< Thus leading me to believe that your build thinks g is the alex command.
07:43:21 <shapr> zooko: Yes, it's super fast at SIMD, but it's somewhat a pain to get the data in there without stalls.
07:43:25 <Heffalump> shapr: I was wondering that, but the next line where it tries to use Happy is even weirder.
07:43:32 <Heffalump> perhaps it thinks '' is the happy command
07:43:49 <zooko> shapr: that's interesting.  I'm thinking of a secure hash function.
07:44:15 <zooko> So, maybe I did something wrong?  I just unpacked ghc tarball, configure, make, then later added extralibs tarball, make clean, configure, make./
07:44:26 <tomh> hey, why does the hashtable in Data result in an IO?
07:44:39 <Heffalump> you're supposed to do sh boot at some point I think
07:44:40 <lilac> zooko: 'make clean' is the issue, i think
07:44:47 <Heffalump> though I wouldn't expect that error from failing to do so
07:44:59 <shapr> Heffalump: Yeah, if it's confused about alex, it could easily be confused about Happy.
07:45:10 <lilac> zooko: it will probably have removed the packaged alex-generated output
07:45:18 <shapr> zooko: What sort of secure hash function?
07:45:20 <lilac> zooko: you could try untarring the ghc tarball on top again :)
07:46:50 <zooko> Okay, I'm starting over with pristine tarballs.
07:46:59 <zooko> Give me a couple of hours to find out if the build succeeds or fails.  :-/
07:47:05 <shapr> zooko: I have similar interests for the Cell, I installed distributed.net on my desktop, my laptop(s) and my PS3. My PS3 does 170+ million keys per second, my dual core AMD64 laptop does 11 million keys per second.
07:47:17 <zooko> shapr: Oh, just for fun.  I've been following the SHA-3 project, and I've been learning a bit about secure hash functions.
07:47:34 <zooko> shapr: is that testing symmetric block cipher keys?
07:48:56 <shapr> Yeah, RC5
07:49:11 * zooko nods.
07:49:27 <sdubois92> can anyone see why dzen is showing my wifi percentage as 142%
07:49:29 <zooko> So, I wish I had a time machine and could go back in time and submit a hash function design for the SHA-3 contest.
07:49:31 <sdubois92> http://pastebin.com/m12cf3777
07:49:46 <zooko> But I might experiment with inventing one anyway just for my self-education.
07:49:52 <shapr> zooko: If you want lots of random details on the Cell, you could join #haskell-blah for a moment and I could braindump :-)
07:49:58 <zooko> :-)
07:50:05 <zooko> Ok!
07:50:08 <tomh> are there data structures with O(1) lookup in haskell?
07:50:22 <lilac> tomh: Maybe :)
07:50:38 <tomh> i mean more like arrays, hashtables etc :)
07:50:48 <lilac> yes, absolutely.
07:50:56 <Heffalump> no data structure has O(1) lookup..
07:51:00 <lilac> Array, UArray, STArray, ...
07:51:07 <arw> we've had that discussion before...
07:51:08 <Heffalump> (in any language)
07:51:17 <tomh> Heffalump: what makes you think that
07:51:18 <oklopol> Heffalump: you know what he means
07:51:33 <tomh> ok i will look up Array
07:51:34 <oklopol> and if you set word size, sure you can have O(1) lookup
07:51:42 <lilac> Heffalump: Array does if you bound the key space to just Int, right?
07:51:55 <Heffalump> tomh: because you run out of memory
07:51:59 <Heffalump> lilac: then so does IntMap
07:52:05 <arw> data access in O(1) does not exist, true, because its a limit for an infinite amount of data, therefore the word size can not be limited.
07:52:11 <lilac> Heffalump: i wouldn't argue with that :)
07:52:29 <tomh> Heffalump: well for inifite collections yes
07:52:44 <Heffalump> well, O notation is all about asymptotic behaviour
07:52:44 <lilac> Heffalump: but for Map from Integer, the lookup isn't O(1)
07:52:58 <Heffalump> hi bringert
07:53:08 <Heffalump> lilac: agreed. And Array from Integer doesn't exist at all :-)
07:53:13 <lilac> right :)
07:53:32 <lilac> it is implementable, but not with O(1) lookup
07:53:54 <lilac> at least, not without additional primitives or similar
07:54:18 <Heffalump> yeah, ok.
07:54:43 <Axman6> arw: isn't big O notation usually taken as the average time to perform an action?
07:55:01 <jkff> No
07:55:02 <lilac> Axman6: no. it has a precise definition, and that's not it.
07:55:27 <lilac> well, i say 'precise' but it depends on what you consider to be O(1)
07:55:30 <Axman6> so is it worse case?
07:55:34 <Axman6> worst*
07:55:39 <lilac> it's an upper bound
07:55:44 <arw> Axman6: no. O(f) means that lim_{n -> \infty} operation(n) = f
07:56:03 <oklopol> no it doesn't
07:56:07 <arw> Axman6: you always assume an infinitely large dataset with O-notation.
07:56:08 <SamB_XP> arw: the equals sign looks totally wrong
07:56:10 <jkff> The definition is as follows: "The notation f(x) ={x->infinity}= O(g(x)) means that there exists a constant 'c' and an x0 such that for all x > x0, f(x) < c*g(x)".
07:56:31 <SamB_XP> jkff is correct
07:56:42 <arw> SamB_XP: right, constant was missing, my bad.
07:56:50 <SamB_XP> not that that's the only definition, necessarily, there can be others
07:56:51 <lilac> arw: also, it's not = it's <
07:57:00 <jkff> In case where g(x) = 1, this means that f(x) is upper-bounded
07:57:10 <Axman6> arw: well you make assumptions like that, you could also assume you have infinite storage, with O(1) retrival for all elements no?
07:57:12 <oklopol> arw: you were going for omega
07:57:16 <SamB_XP> other EQUIVALENT ones
07:57:20 <arw> lilac: wasn't that \Omega(something)?
07:57:26 <SamB_XP> Axman6:
07:57:27 <SamB_XP> no
07:57:30 <oklopol> ordo is just an upper bound
07:57:38 <SamB_XP> you can't have O(1) retrieval from infinite storage!
07:57:47 <Axman6> sure you can
07:57:49 <lilac> SamB_XP: it really depends on your primitives :)
07:57:59 <SamB_XP> no, you can't
07:58:00 <Axman6> you also can;t have infinite datasets right?
07:58:09 <SamB_XP> the addresses would have to be infinitely long!
07:58:11 <arw> Axman6: nope, you need at least calculate an address, and that alone is killing your O(1).
07:58:14 <Axman6> SamB_XP: so?
07:58:18 <oklopol> SamB_XP: of course you have have a primitive that does that in O(1) time
07:58:22 <jkff> Yes, in any case, all these O(1) denote numbers of *primitive* operations
07:58:29 <oklopol> the problem is every algorithm will dramatically drop in time complexity
07:58:31 <Axman6> arw: not if it takes constant time to calculate it
07:58:36 <lilac> SamB_XP: no, the addresses would not need to be infinite
07:58:44 <arw> Axman6: yes, but that is impossible.
07:58:52 <lilac> SamB_XP: unless we're talking aleph_C space not aleph_0
07:58:52 <jkff> So, however long the primitive 'fetch array' operation might be, it's primitive, so it's O(1) primitive operations :)
07:58:52 <SamB_XP> lilac: well, they could be unboundedly long too
07:59:01 <SamB_XP> but that OBVIOUSLY kills the O(1) so ;-P
07:59:06 <Axman6> and technically so are infinite datasets, so...
07:59:14 <arw> Axman6: if you assume that absolutely everything takes constant time then you don't need to worry about anything.
07:59:28 <jkff> If, however, we talk about O(1) actual time on an actual machine, then we need *quite* different theory for computing complexity
07:59:33 <lilac> SamB_XP: the problem is that asymptotic notation only tells you how many of some primitives you'll use, and not how long those primitives take
07:59:37 <Axman6> now you're taking a big leap from what i said
07:59:44 <Axman6> i said nothing of the sort
07:59:48 * ski_ . o O ( Blum-Shub-Smale )
07:59:56 <vixey> "infinite storage" lol
07:59:59 <jkff> To talk about things like 'In our physical world, there can't exist a machine that does O(1) addressing for an infinite array'
08:00:14 <Axman6> vixey: you need that for infinite datasets right? :)
08:00:21 <SamB_XP> lilac: does it ?
08:00:34 <arw> Axman6: there are only two things to accessing an array: a) address calculation and b) data access.
08:00:35 <SamB_XP> I was thinking primitives that take constant time ;-P
08:00:48 <saml> on windows, cabal installs scripts to C:\Program Files\Haskell  .. can I change that to somewhere else? vista is bitching
08:00:52 <lilac> SamB_XP: that depends on implementation :)
08:00:57 <jkff> Of course there can't, at least because the dataset should take infinite space, it would have two infinitely distant points, and the ability to transfer information between them in O(1) would mean an infinite speed of information transfer
08:01:00 <SamB_XP> jkff: we don't have to limit it to OUR physical world
08:01:06 <jkff> Which violates laws of relativity :)
08:01:07 <arw> Axman6: we assumed for the discussion that a) is O(1). if b) is also O(1) then the discussion is pointless :)
08:01:15 <SamB_XP> we could limit it to worlds that are consistant with certain laws of physics
08:01:17 <jkff> Well, under which assumptions should we work then?
08:01:32 <Saizan> saml: yeah see cabal --help for --prefix or such flags
08:01:46 <SamB_XP> I mean, we don't need to include such open questions as "is our world infinitely expanding?"
08:01:53 <Axman6> arw: ok, well are lookups in hashtables now O(1) then?
08:02:06 <ski_> (jkff : i don't see how infinite space implies infinite distance)
08:02:07 <Axman6> not*
08:02:38 <Saizan> saml: or maybe you could just pass --user, which won't install things system-wide
08:02:38 <arw> Axman6: for sparsely populated hash-tables with the hash-calculation beeing O(1), yes.
08:02:40 <jkff> Otherwise we'd have infinite information in a bounded space. I suspect that this also means infinite mass, doesn't it?
08:02:45 <oklopol> ski_: space is discrete, so isn't that kinda trivial, unless you actually mean infinitely extending
08:02:45 <jkff> I'm not a physicist, though
08:03:05 <arw> Axman6: otherwise its very much dependent on the implementation.
08:03:27 <SamB_XP> I didn't assume that a) was O(1)
08:03:33 <SamB_XP> why would you assume that ?
08:03:37 <jkff> Does the universe has continuous values, at all? If it does, an infinite amount of information can be transferred by any such value.
08:03:44 <lilac> the real question is, does this algorithm work within reasonable time/space bounds for the set of data it's designed to process? asymptotic notation is a tool to help answer that.
08:03:56 <oklopol> jkff: no
08:04:00 <SamB_XP> jkff: there's a lot of evidence that it doesn't
08:04:06 <SamB_XP> certainly not in a practical sense
08:04:16 <oklopol> yeah, of course, add "according to current knowledge bout physics"
08:04:18 <lilac> the behaviour in the limit is irrelevant because we're never working in the limit, but the behaviour on large datasets is often important
08:04:21 <arw> oklopol: wether spache is discrete is still a matter of discussion among physicists, the only thing that is assumed is, that planck-scale is the smallest scale we can reason about with current laws of physics.
08:04:33 <Saizan> it helps when you use it correctly, for example when you count operations of comparable cost
08:04:34 <ski_> (oklopol : i was just thinking of the (metric) space of real numbers .. no two points with infinite distance, however arbitrarily large distances exist)
08:04:48 <oklopol> ski_: ah yeah okay
08:04:49 <jkff> Are mass and wave length discrete?
08:05:03 <arw> jkff: mass is, wavelength is not.
08:05:11 <oklopol> arw: i see, i don't really know physics, may have misunderstood.
08:05:16 <arw> jkff: and mass only in the case of certain particles.
08:05:26 <SamB_XP> certainly you can only stuff a certain amount of matter into a certain amount of space on a given energy budget
08:06:02 <arw> jkff: photons are obviously defined by their wavelength, so their mass can't be discrete.
08:06:06 <jkff> arw: So, if we had the ability to create arbitrarily precise wavelengths, we'd be able to transfer infinite information in a single particle
08:06:23 <lilac> SamB_XP: once you put enough matter in a small space, you get more matter for free :)
08:06:28 <arw> jkff: nope, only down to planck-scale. what happens there is unknown.
08:06:36 <SamB_XP> lilac: doesn't it take energy though ?
08:06:46 <jkff> Well, that means we don't have the ability to create arbitrarily precise wavelengths.
08:06:51 <Saizan> e.g. retrieving an element form a Map requires O(log n) _comparisons_, array indexing is hardware accelerated..
08:07:17 <Axman6> jkff: within a range it can be done though
08:07:17 <lilac> SamB_XP: i guess it depends how you measure it
08:07:19 <Axman6> afaik
08:07:28 <arw> jkff: the other problem is, even if we can create such wavelengths, we certainly can't measure them, again due to evil mr. planck :)
08:07:40 <arw> jkff: (with some help from heisenberg :)
08:07:42 <jkff> Oh yes :)
08:07:50 <SamB_XP> lilac: I'm not thinking about black holes, because I'm under the impression that there's nothing all that special, locally, about a black hole
08:08:03 <SamB_XP> it's just that space is shaped in a really wierd way around one
08:08:22 <SamB_XP> plus black holes are probably a really bad place to store information ;-P
08:08:24 <Axman6> planck broke my infinite Mbps internet, what a dick
08:08:32 <jkff> Also, the set of all wavelengths that one may ever encounter in the real world is continuous only under the assumption that the real world has an infinite number of particles, I think
08:09:12 <arw> jkff: right. since we assume the universe is finite, there can only be a finite number of states.
08:09:13 <jkff> Axman6: Heisenberg broke packet sniffers, I guess
08:09:18 * ksf hands out teabags for everyone to swing
08:09:58 * SamB_XP pulls the string off his, removes the staple, puts the tea in a teapot, unfolds it completely, puts it on a tray, and sets it on fire
08:10:07 <eugene``> SamB_XP: does info dissapear forever in BH?
08:10:32 <eugene``> there's something logically special about them
08:10:34 <Axman6> ok, quick question. you're in a space craft traveling at the speed of light, exactly (ignore the impossibility of that) and you shine a torch out the back. do the photons sit still? (your speed is relative to earth, so is the torch photon's speed)
08:10:42 * SamB_XP also speaks in what must be some kind of english accent the whole time
08:10:42 <arw> eugene``: still a matter of debate among theorists.
08:10:53 <jkff> "Recover data from black holes! Satisfaction guaranteed!"
08:11:03 <ksf> photons don't move, ever.
08:11:11 <ksf> its the rest that moves.
08:11:13 * SamB_XP is referencing a youtube video
08:11:16 <SamB_XP> ksf: huh ?
08:11:21 <SamB_XP> how do they hit eachother ?
08:11:28 <ksf> they're to fast to move.
08:11:34 <ksf> by bending space?
08:11:45 <arw> Axman6: c is constant for every observer. so you would observe your photons to travel at c.
08:11:52 <eugene``> ksf: that's interesting way to think of thar
08:11:55 <SamB_XP> too ... fast ... to move ?
08:11:59 <jkff> Axman6: Relative velocities don't add up as a = b + c
08:12:03 <SamB_XP> I think ksf might possibly be right
08:12:11 <eugene``> ksf: how about dual photons? how they fit in there?
08:12:12 <Axman6> arw: yeah, i remember that. t'was messed up -_-
08:12:15 <SamB_XP> but I don't think he understands it much better than I do
08:12:38 <ksf> If I do, I certainly can't explain it better.
08:12:49 <Axman6> we watched a video in physics of what it would look like to travel at 0.998xC toward saturn
08:13:15 <eugene``> a footage would be better to swallow as a demo
08:13:26 <arw> the weird thing about speed is that it changes the perception of time and space.
08:13:43 <SamB_XP> wouldn't it be more cool to see a trolly traveling at 0.998xC ?
08:14:00 <eugene``> a trolly with a mass of thr sun
08:14:15 <arw> by that mechanism, c beeing constant is somewhat trivial, but hard to imagine if you didn't calculate it on paper at least once :)
08:14:36 <eugene``> hm woudlt it make it an instand black hole?
08:14:40 <eugene``> instant*
08:14:44 <SamB_XP> arw: even if you did the trolly would look quite odd
08:15:03 <ksf> eugene``, I think space and time are themselves quantum phenomena, so all that weird stuff is independent of it in the sense that the weird stuff gives raise to less weird stuff.
08:15:22 <Axman6> ok, this is well worth watching: http://au.youtube.com/watch?v=fIEBu9ouUpA
08:15:31 <SamB_XP> @spell trolly
08:15:37 <eugene``> mhm, like questions about validity of casuality
08:17:28 <Axman6> another thing that screwed with my brain in physics was the fact that a 2π rotation is not an identity
08:17:35 <Axman6> but 4π is
08:17:43 <SamB_XP> what the heck ???
08:17:48 <ksf> there is no pi in physics.
08:17:56 <ksf> it's always "approximate".
08:18:18 <Axman6> http://webct.anu.edu.au/PHYS1101_Sem_1_2008/Resources/ruban%20belt%20trick%20movie.mpg if you can view it
08:18:21 <ksf> try to arrange ping-pong balls in a circle and you'll see what i mean.
08:19:14 <ksf> ...buckyballs aren't round, too.
08:19:17 <sdubois92> can anyone see why dzen is showing my wifi percentage as 142%
08:19:19 <sdubois92> http://pastebin.com/m12cf3777
08:19:48 <vixey> sdubois92, I thought I was in #haskell
08:19:51 <Axman6> SamB_XP: does that video load?
08:20:51 <sdubois92> vixey: well, a lot of xmonad users use dzen so i thought it would be good to ask here
08:21:08 <Axman6> #xmonad might be better
08:22:31 <SamB_XP> Axman6: wants me to login
08:22:41 <Axman6> ah lame. i should upload it to youtube
08:23:28 <ski_> (SamB_XP : "trolley" ?)
08:23:58 <SamB_XP> ski_: I thought probably that was how it was supposed to be spelled ...
08:26:06 <SamB_XP> darnit why does chrome display PDFs in-browser ...
08:26:22 <Axman6> because browsers that can;t do that suck
08:26:23 <smtms> SamB_XP, doesn't Firefox do the same?
08:26:37 <SamB_XP> smtms: not for me
08:26:43 <smtms> SamB_XP, what's your OS?
08:26:45 <SamB_XP> I made it stop
08:26:49 <SamB_XP> or something
08:26:52 <smtms> oh
08:27:05 <geezusfreeek> firefox doesn't do that for me on windows, os x, or linux...
08:27:17 <geezusfreeek> i'm sure i could make it to it, but i never bothered
08:27:22 <SamB_XP> hmm, isn't there supposed to be a toolbar or something ?
08:35:51 <saml> what is another way of doing runhaskell Setup install  ??   copy and register ?
08:37:05 <SamB_XP> A, this looks like what I was looking for ... http://www.anu.edu.au/Physics/Searle/
08:37:42 <Axman6> ah yes, they showed us that too.
08:44:46 <saml> --datadir on windows defaults to --datadir (library)	C:\Program Files\Haskell   it's not using $prefix. is this intentionall?
08:44:56 <Axman6> SamB_XP: uploading this video, if you
08:45:03 <Axman6> re interested*
08:45:48 * zooko reads recent log of #haskell.
08:46:06 <zooko> The obvious conclusion is that since we all have finite-sized hard-drives, all of our algorithms run in O(1).
08:46:27 <zooko> (A joke, I mean a deep truth, that I learned form Nathaniel J. Smith.)
08:48:57 <saml> is there an environment variable that cabal looks at?  like CABAL_CONFIGURE_FLAGS
08:48:59 <Axman6> SamB_XP: does http://au.youtube.com/watch?v=Nat-EsReXtQ work?
08:49:06 <gwern> 'Commencing this month, Microsoft will be providing every CPAN author with free access to a centrally-hosted virtual machine environment containing every major version of Windows.' http://use.perl.org/~Alias/journal/38036
08:49:27 <saml> so that I don't have to type runghc Setup.lhs configure --prefix=C:\Users\sam\haskell --datadir=$prefix\share    over and over
08:50:55 <duaneb> hi geezusfreeek
08:50:55 <lilac> Axman6: doesn't work here
08:50:57 <SamB_XP> Axman6: not yet
08:51:16 <Axman6> ok, well guess it needs reviewing
08:51:41 <SamB_XP> Axman6: oh, I was assuming it just needed to wait for the DB to settle down
08:51:54 <Axman6> "This video is not yet processed."
08:52:11 <adimit> question: when using ByteString.Lazy.Char8.splitWith, (BS -> [BS]) is the resulting list a list of copies, or does it still reference the function's argument?
08:52:48 <Koazure> Hello,, guys what i can do with this language? can i working on desktop or web? where i can look a beginner ebook? thx for some help ^^
08:53:13 <SamB_XP> Koazure: well, lets see ... an english primer ...
08:53:16 <Axman6> @go RWH
08:53:18 <lambdabot> No Result Found.
08:53:27 <SamB_XP> does anyone know a good online english primer ?
08:53:28 <Axman6> @go real world haskell book online
08:53:30 <lambdabot> http://book.realworldhaskell.org/
08:53:30 <lambdabot> Title: Real World Haskell
08:53:31 <gwern> @where real
08:53:31 <lambdabot> http://book.realworldhaskell.org/read/ <-- the comprehensive xmonad configuration syntax reference
08:53:40 <SamB_XP> lol
08:53:43 <vixey> @where lyah
08:53:43 <lambdabot> www.learnyouahaskell.com
08:53:47 <vixey> ^^^^^^^^^^^^^^^^
08:53:48 <gwern> @where+ rwh http://book.realworldhaskell.org/read/
08:53:48 <lambdabot> Good to know.
08:54:17 <duaneb> so
08:54:34 <SamB_XP> xmonad configuration syntax reference ... hehehe
08:54:38 <duaneb> I wrote a simple list reader in parsec
08:54:38 <duaneb> http://hpaste.org/12781
08:54:58 <duaneb> except, it doesn't work for "()" and "(5)", but works for "(5 . 5)"
08:55:06 <duaneb> how can I fix this? :P
08:55:12 <SamB_XP> duaneb: have you PASTED it ?
08:55:12 <Axman6> SamB_XP: http://au.youtube.com/watch?v=Nat-EsReXtQ should work now
08:55:42 <SamB_XP> is that an easal?
08:55:54 <vixey> duaneb, by.. thinking and then writing better code...
08:56:16 <duaneb> oh, right
08:56:18 <duaneb> http://hpaste.org/12781
08:56:28 <duaneb> vixey: yes, but I don't understand what I did wrong ;)
08:56:38 <vixey> that's part (1) thinking
08:57:00 <duaneb> vixey: well, I'm asking for help. I've been thinking for the past hour
08:57:09 <Saizan> vixey: try to be a little less obnoxious :)
08:57:56 <duaneb> anyway, can anyone take a look and hazard a guess as to where I might have gone wrong?
08:58:06 <duaneb> I think I might be using `try` wrong, but...
08:58:26 <chessguy> howdy ya'all
08:58:26 <SamB_XP> why are you using try at all ?
08:58:38 <chessguy> try/catch/finally blocks are great!
08:58:56 <chessguy> oh, wrong channel :)
08:59:08 <vixey> duaneb, have a look at http://research.microsoft.com/users/daan/download/parsec/parsec.html
08:59:15 <Axman6> chessguy: closet java programmer?
08:59:29 <Raevel> *busted*
08:59:29 <vixey> they actually show you how to parse parens here..a
08:59:29 <chessguy> Axman6, more like practicing c# programmer
08:59:36 <Axman6> ew
09:00:24 <vixey> and here http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
09:00:25 <chessguy> c#'s not so bad, for an OOP language
09:01:04 <SamB_XP> Axman6: okay, so a ribbon twisted by 4pi can easily be untwisted without rotation ... what's that got to do with physics ?
09:01:29 <skorpan> Understand Nothing in 48 Hours!
09:01:32 <Axman6> SamB_XP: baically, if you make a 2pi rotation, you aren't the same as you were before the rotation
09:01:52 <vixey> Axman6, why not
09:02:10 <eugene``> ? Monad Writer
09:02:46 <Axman6> it's been 6 months since i found out why, but trust me when i say some very intelligent (and somewhat well known) physists told us this in a lecture
09:02:56 <eugene``> do we have a page about Writer?
09:03:00 <vixey> duaneb, have a look at http://research.microsoft.com/users/daan/download/parsec/parsec.html
09:03:03 <vixey> and here http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
09:03:03 <eugene``> how to use it
09:03:07 <duaneb> vixey: I understand
09:03:12 <duaneb> BUT that DOES NOT HELP
09:03:15 <vixey> yes it does
09:03:20 <duaneb> vixey: no, it really doesn't
09:03:20 <Saizan> http://sigfpe.blogspot.com/2007/03/curious-rotational-memory-of-electron_31.html <- Axman6, SamB_XP
09:03:23 <vixey> Both pages show exactly how to parse balanced parenthesis
09:03:37 <duaneb> vixey: I don't like the scheme in 48 hours' version
09:03:49 <vixey> the read the parsec page
09:04:03 <chessguy> vixey, why do you keep repeating yourself?
09:04:19 <vixey> chessguy, he left before I posted the links first time around
09:04:35 <Saizan> duaneb: for the () case you can see that since you call parseListCons inside parseList, and parseListCons doesn't match the empty string, you're effectively requiring that there's something between the two parentheses
09:04:37 <duaneb> vixey: I *know* the parsec documentation. I wouldn't come on to the channel if I wasn't sure I couldn't diagnose the problem myself
09:05:10 <duaneb> Saizan: I thought that using `try` would eliminate that problem?
09:05:25 <chessguy> duaneb, got code?
09:05:35 <Saizan> duaneb: no, try does something different
09:05:40 <eugene``> :i ask
09:05:48 <eugene``> :t ask
09:05:49 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
09:06:01 <Axman6> SamB_XP: yeah that looks like it's related
09:06:02 <Saizan> duaneb: try just makes the parser backtrack if it fails
09:06:10 <Saizan> duaneb: you want option there, iirc
09:06:10 <duaneb> http://hpaste.org/12781
09:06:15 <Saizan> ?hoogle option
09:06:15 <lambdabot> Distribution.Simple.Command option :: SFlags -> LFlags -> Description -> get -> set -> MkOptDescr get set a -> OptionField a
09:06:15 <lambdabot> Text.Parsec.Combinator option :: Stream s m t => a -> ParsecT s u m a -> ParsecT s u m a
09:06:15 <lambdabot> Text.ParserCombinators.ReadP option :: a -> ReadP a -> ReadP a
09:06:25 <duaneb> Saizan: thanks, I'll look into it
09:06:52 <vixey> duaneb; (this is actually explicitly mentioned in both documents I linked fyi)
09:07:03 <Saizan> duaneb: so, same problem in val2 <- (try parseDottedCons) <|> (try parseListCons)
09:07:37 <Saizan> vixey: we're not a RTFM channel yet, i hope :)
09:07:38 <duaneb> Saizan: yea, I understand it now :/
09:07:42 <duaneb> thanks!
09:08:05 <chessguy> Saizan, let's hope not.
09:11:27 <eugene``> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Writer-Lazy.html -- where do i see how to use it?
09:12:03 <Axman6> SamB_XP: this article is excellent :)
09:12:18 <orbitz> Axman6: which article?
09:12:26 <Axman6> http://sigfpe.blogspot.com/2007/03/curious-rotational-memory-of-electron_31.html
09:12:34 <gwern> hm, why are there two curl bindings...
09:14:38 <Saizan> eugene``: http://www.haskell.org/all_about_monads/html/writermonad.html
09:15:59 <saml> how do you build an sdl application on windows? I get linker error
09:15:59 <gwern> http://haskell.org/haskellwiki/Haiku <-- yay now we have 14 haikus!
09:16:02 <gwern> @where haiku
09:16:03 <lambdabot> http://haskell.org/haskellwiki/Haiku
09:16:05 <gwern> @where haikus
09:16:05 <lambdabot> I know nothing about haikus.
09:16:11 <gwern> @where+ haikus http://haskell.org/haskellwiki/Haiku
09:16:12 <lambdabot> I will remember.
09:16:15 <saml> C:\MinGW\lib/libSDLmain.a(SDL_win32_main.o)(.text+0x409):SDL_win32_main.c: undefined reference to `SDL_main'
09:17:02 <eugene``> i don tunderstand why we need a Writer monad and a MonadWriter monad?
09:18:03 <haskell-newbie> Hello, is there some kind soul who wont mind helping a newbie in a project hes doing?
09:18:06 <Saizan> eugene``: so that we can make other monads that have the same interface
09:18:32 <jfredett> haskell-newbie: ask away, someone will try to help, I'm sure.
09:18:42 <Axman6> haskell-newbie: fell free to ask questions, you'll almost always get an answer. but we won't do your homework for you ;)
09:18:59 <jfredett> unless it's _really_ interesting homework...
09:19:01 <jfredett> :)
09:19:05 <haskell-newbie> :)
09:19:07 <Axman6> heh, that too
09:19:22 <Axman6> my first haskell homework was really interesting i thoughy
09:19:24 <Axman6> t*
09:19:48 <Saizan> eugene``: Writer is a type, while MonadWriter is a typeclass, if you only need the Writer functionality stick to that, the class is mostly there so we can build richer monads with transformers easily
09:20:27 <eugene``> Saizan: which one of them is the interface and did you run into any custom writer monad implementation?
09:21:29 <Saizan> eugene``: the interface is the typeclass: MonadWriter
09:22:14 <haskell-newbie> So basically it's this, I have a type created (using 'data') made of strings and lists of strings and I'm loading from some files these strings 'inside' the 'do' statement. In the end I want to return the new instance of that type but some strange errors pop up.
09:22:44 <jfredett> haskell-newbie: can you paste the code at hpaste.org?
09:22:57 <Saizan> eugene``: and yes, i've seen quite a few
09:23:32 <Saizan> eugene``: especially since we usually build custom monads out of the simpler ones, but we still want to use the same interface
09:23:54 <eugene``> Saizan: aha, thanks for trying to explain. i've worked with transformers before, ReaderT in particular.  Just did not code any haskell in a while and the concepts evaided me :(
09:24:30 <eugene``> s/evaided/escaped/
09:25:29 <Saizan> eugene``: welcome back ;)
09:25:59 <eugene``> thanks. work, life, all of that :)
09:26:32 <saml> where are darcs repo for hackage packages?
09:26:54 <Zao> Depends on the package.
09:27:00 <dons> we got slashdotted, did anyone else notice? http://tech.slashdot.org/article.pl?sid=08%2F12%2F05%2F2346235
09:27:49 --- mode: ChanServ set +o dons
09:27:54 --- mode: dons set -b *!*n=ush@*.syr.edu
09:28:03 --- mode: ChanServ set -o dons
09:29:00 <saml> maybe developing on windows is just too painful
09:29:09 <saml> i can't build SDL hello world
09:30:10 <jfredett> dons: cool
09:32:37 <haskell-newbie> http://hpaste.org/12782#a0
09:33:17 <haskell-newbie> jfredett: Ok, the link to the code is up. I commented it to be more understandable.
09:33:44 <haskell-newbie> It's about a world with creatures called Snu.
09:33:57 <haskell-newbie> So, it *is* very interesting, wink wink
09:34:14 <jfredett> okay, :) is this homework? just so I know how much to help. :)
09:34:20 <Saizan> haskell-newbie: return is not a keyword, but a normal function
09:34:41 <jfredett> yah-
09:34:49 <Saizan> haskell-newbie: so in the last line you need to parentheses around Nature ...
09:34:49 <haskell-newbie> it's actually a project to deliver (the 2nd one this semester)
09:34:57 <jfredett> okay,
09:35:14 <Saizan> s/to/to put/
09:35:41 <haskell-newbie> Saizan: wow, it loaded without errors!!
09:35:51 <haskell-newbie> Saizan: with the parentheses!|
09:36:11 <jfredett> hehe
09:36:16 <jfredett> which means it probably works now
09:36:35 <Saizan> heh, before they all were parsed as arguments to "return"
09:36:41 <jfredett> the trick to writing haskell, mostly, is getting it to compile, usually after that it works. :)
09:36:47 <haskell-newbie> :)
09:37:01 <jfredett> the trick to getting it to compile is understanding the type errors ghc gives you. :P
09:37:11 <dons> kinda amazing. 130+ people on RWH bookclub, in 4 days, http://groups.google.com/group/real-world-haskell-book-club
09:37:42 <jfredett> you could have also done: return $ Nature ... -- same line as you had before
09:37:52 <haskell-newbie> jfredett: ok
09:38:22 <jfredett> iirc, thats the standard stylistic practice. or- at least- thats what I like. :)
09:38:35 <jfredett> less cluttered up parens, we aren't writing lisp here!
09:38:45 <haskell-newbie> jfredett: :)
09:38:50 <haskell-newbie> thanx a lot guys
09:44:36 <byorgey> haskell-newbie: do you mean (head (words file_sounds)) at the end there?
09:44:47 <byorgey> you have  file_noises three times and file_sounds only once
09:45:38 <gwern> @quote
09:45:38 <lambdabot> mIRC says: %03^_^
09:45:53 <gwern> ? that one is not funny at all
09:47:02 <jfredett> haskell-newbie: another style note, usually the "deriving" clause is on a line below the type. that is, put a newline between "Dump String Int" and "deriving Eq"
09:47:22 <jfredett> err, newline + some whitespace, a tab'll do. :)
09:47:43 <gwern> @seen dcoutts_
09:47:43 <lambdabot> dcoutts_ is in #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I don't know when dcoutts_ last spoke.
09:48:11 <jfredett> you might also use a newtype instead of a data for the Nature type.
09:48:15 <gwern> @tell dcoutts_ None of the template-haskell people have responded about scrapping packedstrings. how long do we have to wait?
09:48:15 <lambdabot> Consider it noted.
09:48:48 <byorgey> haskell-newbie: also, you might want to have Snu derive Show as well as Eq, unless there was some reason you really wanted to write the Show instance yourself =)
09:48:55 <byorgey> deriving (Eq, Show)
09:49:14 <jfredett> it does look like a pretty neat little project though...
09:49:26 <byorgey> indeed =)
09:49:41 <byorgey> haskell-newbie: what school do you attend?
09:50:40 * byorgey wonders if Nature will end up being turing-complete
09:51:51 <dons> ?users
09:51:52 <lambdabot> Maximum users seen in #haskell: 568, currently: 543 (95.6%), active: 14 (2.6%)
09:51:55 <nilecirb> I'm trying to write an application with gtk2hs, but I'm confused as how to "store" something.
09:52:07 <nilecirb> I already wrote a function that loads stuff into an array, but I don't know how to pass it to other functions.
09:52:07 <dons> nilecirb: read the RWH chapter on gtk2hs?
09:52:20 <jfredett> I annotated you paste with some style cleanup, haskell-newbie, for reference. :)
09:52:20 <dons> oh, just pass the array to those functions explicitly?
09:52:28 <dons> or use a State monad
09:52:48 <dons> 568 is a new high score, btw
09:52:50 <nilecirb> dons: How do I pass it though, if it's called via onClicked or something like that?
09:53:14 <dons> so it needs to be in scope for your signal handling functions?
09:53:20 <dons> so perhaps partially apply them to the array?
09:53:26 <dons> let g = myfun myarr
09:53:31 <dons> then use 'g' in the handlers?
09:53:37 <dons> you might need to paste the code on hpaste.org
09:54:11 <Saizan> if you need to comunicate to the rest of your program from inside a callback you want to use an IORef
09:54:18 <nilecirb> dons: I'll try using let, and if that fails, I'll paste it.
09:54:44 <nilecirb> Saizan: That might be what I'm trying to do. I'm still trying to get my head around gtk2hs in general.
09:55:49 <haskell-newbie> byorgey: Yeah, I made a typo (I had to translate the name of the variables to english)
09:57:47 <haskell-newbie> byorgey:  I attend the Science Faculty of University of Lisbon in Portugal
09:58:03 <byorgey> haskell-newbie: cool
09:58:10 <jfredett> cool, portuguese haskellers!
09:58:13 <haskell-newbie> :)
09:58:16 <jfredett> I used to speak a little portuguese
09:58:26 <jfredett> I mostly remember the profanities... :)
09:58:26 <haskell-newbie> jfredett: really ? :)
09:58:30 <haskell-newbie> aha
09:58:38 <jfredett> and obrigado (which is thank you, iirc)
09:58:45 <haskell-newbie> yeah :)
09:59:14 <haskell-newbie> yeah, its thank you, allright
09:59:15 <jfredett> I worked in a mcdonalds with a fair number of brazillians when I was younger.
09:59:24 <haskell-newbie> ehe
10:00:09 <dons> oleg publishes new libraries via his site, http://okmij.org/ftp/Haskell/misc.html#sys_open
10:00:19 <dons> should we ask him to put them on hackage, or help him do so?
10:00:31 <jfredett> dons: both?
10:00:41 <im_maciek> is haskell a good language to learn programming?
10:00:41 <dons> yes
10:00:46 <tomh> yes
10:00:57 <dons> im_maciek: yeah, it's used as a language for teaching programming at many universities.
10:01:02 <Axman6> im_maciek: it's an excellent language for it :)
10:01:02 <jfredett> I mean- oleg is a bit like jesus, you really don't want to advise him on best practices for his religion. :)
10:01:06 <dons> im_maciek: you're a beginner programmer?
10:01:16 <im_maciek> I'm at one of those universities
10:01:24 <tomh> which
10:01:33 <dons> ok. that's a good thing. :)
10:01:37 <im_maciek> and we are just finishing first semester with haskell and starting java
10:01:47 <im_maciek> and I'm wondering how painful it's going to be
10:01:52 <dons> it'll be a change
10:01:54 <im_maciek> it's edinburgh
10:01:59 <dons> oh, good.
10:02:03 <tomh> trust me the other way around will be more painfull
10:02:09 <tomh> we started with java, then haskell
10:02:13 <dons> tomh: not if you start with haskell.
10:02:21 <dons> java looks crazily verbose and limited.
10:02:31 * dons started with haskell, then C, then Java.
10:02:34 <tomh> dons: yes, thats what i said, its better to start with haskell..
10:02:44 <dons> ah i c.
10:03:01 <dons> im_maciek: ediburgh's a great university for the production of good programmers. you'll be fine.
10:03:14 <im_maciek> I'm not really happy with our haskell book tho
10:03:16 <dons> and you can keep up the haskell hacking at the same time.
10:03:19 <skorpan> dons: was haskell the first programming language you learned?
10:03:20 <dons> im_maciek: oh, which one is it?
10:03:27 <dons> skorpan: well, at university, yes.
10:03:28 <tomh> dons: what university are you on then?
10:03:33 <im_maciek> craft of functional programming
10:03:34 <olsner> otoh, if you start with haskell, every new language will feel like a downgrade
10:03:36 <dons> i was at UNSW in Sydney.
10:03:36 <skorpan> dons: oh, then same here i guess.
10:03:37 <im_maciek> thompson I guess
10:03:43 <tomh> ok cool
10:03:44 <skorpan> <- chalmers
10:03:44 <dons> im_maciek: ah ok. that's what I used 10 years ago :)
10:04:00 <im_maciek> and I bought our java textbook
10:04:05 <dons> im_maciek: 'Programming Haskell' is also a good intro. I think CoFP is ok. but maybe not practical enough for these days.
10:04:05 <im_maciek> it's head first java
10:04:16 <im_maciek> and it's cooompletely different
10:04:19 <dons> interesting. quite a different style of boook
10:04:22 <tomh> we used stuff made by our teachers
10:04:34 <tomh> freely downloadable
10:04:39 <dons> yes. you might want to read "Real World Haskell" or one of the other more practical haskell things online
10:04:44 <dons> to really round out your haskell skills
10:04:53 <im_maciek> I'm using real world haskell instead
10:05:06 <tomh> maybe learn you a haskell is nice too
10:05:08 <dons> hehe. awesome.
10:05:15 <im_maciek> my brain turns off when I start reading thompson
10:05:25 <dons> im_maciek: sounds like you're pretty self reliant. that's a good sign.
10:05:28 <tomh> i think i got the thompson book
10:05:51 <tomh> i just bought it to quickly remember all the haskell stuff again after not using it for 2 years
10:06:16 <dons> it's important to keep up practice in languages, i find, or you lose that ability
10:06:17 <mapreduce> im_maciek: If you have to learn Java then you might want to, while learning Haskell, work out how you'd do something in Java.  You'll usually find that you have to add 4 to the number of lines, then square that number.
10:06:22 <dons> so keep writing little haskell thiings (or big ones)
10:06:38 <im_maciek> mapreduce: and loads of }}}}}
10:06:40 <im_maciek> :)
10:06:46 <mapreduce> im_maciek: Yep.
10:06:56 <im_maciek> syntax is so messy to me
10:07:04 <tomh> dons: well i think you dont really lose the ability if the languages are the same style like c#,java etc
10:07:12 <dons> it's an historical syntax.
10:07:24 <tomh> the more i write in java also helps me when coding c# apps
10:07:29 <dons> tomh: if they're essentially the same, maybe not, but you'll forget APIs
10:07:47 <tomh> thats why java and c# have excellent tools for that :)
10:07:51 <mapreduce> tomh: Yes, but there's quite a bit in C# that is a leap ahead of Java.
10:08:00 <tomh> ye true
10:08:22 <tomh> thats why i have resharper, it helps me reminding of those features :)
10:08:31 <mapreduce> I found C# very easy to pick up, knowing Java and a sizeable subset of Haskell.
10:08:57 <tomh> it is
10:09:17 <tomh> many of c#'s new features are made by a haskell programmer ;)
10:09:23 <gwern> wonderful. the 6.10 versions of mueval and hint let in a 'let x = x + 1 in x' DoS attack
10:10:19 <mapreduce> tomh: Yes, that's very very healthy.
10:10:51 <mapreduce> It's getting a 'dynamic' keyword in the next version, which is arguably a small step backwards, but it'll be easy enough to ignore.
10:11:35 <tomh> ye
10:11:48 <tomh> well it can be nice for testing
10:11:50 <im_maciek> I can't understand what does 'newtype' do or rather where is it used. :(
10:12:08 <ksf> instead of aliasing a type, you get a new type.
10:12:15 <tomh> but normally i would avoid it, just like overuse of 'var'
10:12:34 <ksf> so you could e.g. stop haskell from allowing you to mix [Char] and String
10:13:52 <ciscbrain> tomh: what's wrong with var? There are a lot of people who agree with you, and I don't understand why
10:14:08 <ksf> I don't recommend wasting much time thinking of where you could use it if you still got some haskell to learn.
10:14:47 <im_maciek> that's a piece of haskell I learn
10:15:07 <im_maciek> or rather have to learn
10:15:56 <ksf> ah. see, but while learning java, you don't really have to grok "protected", as "public" gets your code running, too.
10:16:56 <im_maciek> good point :)
10:17:01 <tomh> ciscbrain: imo its just the same as not provide a type definition in haskell, it just makes your code more unmaintainable
10:17:05 <ksf> imagine you've got a type Window Int Int Int Int Int ... id, x, y, width, height.
10:17:32 <ksf> that kinda sucks, 'cos you can add an id to a coordinate, which doesn't make sense.
10:17:36 <geezusfreeek> type = type alias, newtype = new type from existing type, data = algebraic data type
10:17:54 <tomh> i actually wonder if code which has all correct typing compiles faster than ones that use 'var'
10:17:55 <ksf> so you do two newtypes, and define it as Window WId Dim Dim Dim Dim
10:19:28 <ciscbrain> tomh: in both cases, the compiler always evaluates the type of the right-side expression, so I guess it's gonna be just as fast
10:20:18 <tomh> ok
10:20:36 <ciscbrain> tomh: about the maintainability issue, in haskell all you have are functions so I understand how it's important to have the definition
10:20:37 <tomh> type systems etc are the next subject in my compiler course, haven't learned about them yet
10:20:55 <ciscbrain> but you can only use "var" for local variables
10:21:04 <tomh> yes you can
10:21:42 <tomh> but if you do everything as var you don't know the type of the objects from reading the code
10:22:43 <tomh> for example if you edit c# code w/o visual studio I think you will have issues
10:23:04 <ciscbrain> I use emacs :P
10:23:10 <tomh> for c#?
10:23:13 <ciscbrain> yes
10:23:19 <tomh> hehe ok
10:23:24 <gwern> argh, my watchdog threads aren't working in mueval. why why
10:23:26 <ciscbrain> isn't declaring the type of local variables in C# like declaring the type in "let" or "where" expressions in haskell?
10:23:55 <tomh> i guess so, but you can declare function definitions aswell for them
10:24:04 <tomh> i mean type definitions
10:24:16 <ciscbrain> yes, but you usually don't
10:24:26 <ksf> ciscbrain, in haskell there isn't a real distinction between lets and top-level decls.
10:24:28 <tomh> usually not
10:24:39 <gwern> wait, it works with -N2
10:24:49 <gwern> oh noes, did I run into the insuficient-sparks thread bug?
10:24:54 <tomh> but i think its good practice if its any complicated
10:25:12 <ksf> hmm... can you write (main, foo) = (... , ...)?
10:26:25 <ksf> indeed, you can.
10:27:04 * ksf adds it to his list of haskell features noone knows nor uses
10:27:27 <ciscbrain> ksf: what I'm trying to say is that just like you wouldn't declare the type of an let expression with a very small scope, local variables in C# don't usually need to have type declarations
10:28:14 <chessguy> 'ello
10:28:39 <ksf> whether or not i declare a type usually depends on the complexity of the type and whether or not i have to track down a typing error or not.
10:28:45 <ksf> ...not so much on scope.
10:28:46 <tomh> ciscbrain: maybe you are right, but I will wait it out till it gets generally accepted :P
10:29:20 <ksf> 'specially in 20-let functions types can come in handy.
10:29:35 <chessguy> conal:  you around?
10:31:28 <gwern> anyone know the number of the ghc 6.10 thread spark bug?
10:32:10 <conal> chessguy: yeah
10:32:17 <conal> i'm working on a blog post
10:32:39 <chessguy> oh ok. i can catch up with you later. i thought you might be interested in some thinking i've been doing on composable patterns
10:32:55 <tomh> ciscbrain: actually MS recommends to only use var for anonymous types or collections of those, they also use the readability argument for it like i brought up
10:33:54 <conal> chessguy: now's a good time.
10:34:06 <chessguy> oh ok.
10:34:17 <mapreduce> tomh: So why did they make var work for non-anonymous types?
10:34:41 <chessguy> so i've been trying to come up with simple ways of representing patterns for chess positions in a composable way
10:34:52 <dons> gwern: hmm. check with jaffacake
10:35:37 <tomh> mapreduce: ye well, it is MS you know :) they change their mind all the time, kill new projects and libs after 1 release etc
10:35:37 <chessguy> conal:  one could imagine a simple DSL, in which you name particular pieces and describe how they relate to each other
10:35:52 <gwern> @seen jaffacake
10:35:52 <lambdabot> I saw jaffacake leaving #ghc and #haskell 7h 17m 53s ago, and .
10:36:06 <chessguy> http://hpaste.org/12783
10:36:19 <gwern> dons: does jaffacake handle all issues with threading and throwing/catching exceptions?
10:36:43 <conal> chessguy: oh -- chess patterns.  now i'm with you.
10:36:46 <chessguy> conal:  for example, i have described 2 patterns on this hpaste. they correspond to 2 patterns from the first board at the site mentioned there
10:36:59 <chessguy> oh yes, sorry :)
10:37:07 <conal> np
10:37:10 <chessguy> doesn't everybody think about chess all the time? :)
10:37:22 <ksf> go > chess
10:37:36 <znutar_> s/chest/chests, female/
10:38:44 <ciscbrain> tomh: I'm not saying that you should *always* use var
10:39:09 <chessguy> conal:  now there are some clear possibilities for composition, just in those two patterns
10:39:29 <tomh> ciscbrain: I know
10:39:30 <ciscbrain> tomh: but I tend to use a lot of simple generic types
10:39:39 <conal> chessguy: for decomposing them, to reveal reusable commonality?
10:39:45 <ciscbrain> tomh: like Dictionary<string, List<Pair<string, int>>>
10:40:01 <chessguy> conal:  well yes
10:40:08 <tomh> ciscbrain: hehe ye ok, i can understand why you want to write var in that case
10:40:16 <conal> chessguy: gotta go.  more later?
10:40:23 <chessguy> conal:  sure
10:44:15 <dons> gwern: he's the goto guy for runtime stuff
10:46:55 <ciscbrain> I'm currently getting linking errors like this: (.text+0x562): undefined reference to `mtlzm1zi1zi0zi0_ControlziMonadziStateziLazzy_zdf14_closure'
10:47:10 <ciscbrain> I tried reinstalling ghc, but nothing
10:47:24 <ciscbrain> do you have any ideas what might be causing it?
10:48:11 <bos> ciscbrain: use "ghc --make"
10:48:31 <ciscbrain> bos: thanks
10:48:58 <dons> i wonder if ghc should trap linker errors that contain Z encoded things and suggest --make
10:49:04 <Feuerbach> why does not Language.Haskell.Syntax have representation for comments/pragmas?
10:49:36 <dons> Feuerbach: so you can write IDEs and so on that parse the source, preserving comments
10:49:59 <dons> i love python, TypeError: value is of wrong type for this column
10:50:40 <dons> wait. no i don't. that's just a stupid error to ship.
10:51:07 <yitz> dons: never saw that one. what did you do wrong?
10:51:33 <Feuerbach> dons: didn't get it. What's the problem with parsing source AND comments? You can always ignore them if you want.
10:51:51 <yitz> dons: Feuerbach said that it does *not* preserve comments. It should.
10:53:34 <gwern> @tell Cale darcs (mueval and hint) are updated for 6.10, but it's probably better to wait for 6.10.3 because of a threading bug (covered in the README)
10:53:35 <lambdabot> Consider it noted.
10:53:46 <ciscbrain> bos: so.. I got these errors because I started using stuff which is in an external library? and there .o files were not in ld's path?
10:54:20 <ciscbrain> *their
10:54:30 <bos> ciscbrain: you either have to tell ghc which packages you're using, or get it to determine it automatically with --make
10:55:08 <ciscbrain> bos: ah, ok, thanks again
10:55:37 <dons> yitz: oh, in gpooder. not my code.
10:55:57 <dons> Feuerbach: oh, right. around the wrong way. ghc-api's parser preserves comments
11:02:31 <Feuerbach> but there's nothing about comments at http://www.haskell.org/ghc/docs/latest/html/libraries/haskell-src/Language-Haskell-Syntax.html ...
11:06:35 <gwern> I know I shouldn't find this amusing, but I do: 'I am giving birth to a website with some examples:...'
11:13:32 <arw> how easy / complicated is it to link haskell and c++?
11:13:57 <arw> i have a c++ framework for which i would like to build some modules in haskell.
11:14:11 <sbahra> arw, http://www.haskell.org/haskellwiki/FFI_Introduction
11:14:12 <dons> so call into haskell from C++?
11:14:19 <arw> dons: yes.
11:14:26 <dons> you use the FFI, and you'll need a C stub to call to. otherwise, easy.
11:14:57 <dons> http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
11:15:09 <dons> from C. your C++ needs to call C. (since C++ doesn't have standard name mangling)
11:15:28 <arw> ok, so i'll always need some c in between.
11:15:34 <gwern> @seen edwardk
11:15:34 <lambdabot> edwardk is in #haskell-blah and #haskell. I last heard edwardk speak 15h 34m 54s ago.
11:15:35 <arw> sounds acceptable.
11:15:45 <dons> yeah. until C++ compilers agree on what names they use for symbols.
11:15:57 <dons> the QtHaskell bindings are this way, for example.
11:15:58 <arw> dons: that'l be the day...
11:16:08 <dons> you can even generate the C stubs from C++, with a script, if you're doing it a lot
11:16:13 <gwern> @ask edwardk I am cleaning out http://haskell.org/haskellwiki/Wanted_libraries#Libraries_to_package - is http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.html superseded by your category-extras?
11:16:14 <lambdabot> Consider it noted.
11:16:29 <arw> dons: c++-compilers are even incompatible with different versions of themselves, so there isn't much hope in that aspect :)
11:16:32 <olsner> if it's only mangling, "C" can also mean C++ with functions marked as extern "C"
11:18:04 <arw> olsner: representation of objects and classes in memory is also somewhat unstandardized, as are the calling conventions.
11:18:25 <arw> thanks dons, sbahra, olsner.
11:19:43 <gwern> (holy cow yi's getting a lot of vi/vim patches)
11:20:29 <rio> hi, i just tried haskell, and its awesome! :)
11:22:17 <mm_freak> rio: welcome to the underworld of evil functional programmers =)
11:22:39 <rio> heh ;)
11:22:43 <ciscbrain> mm_freak: evil, but pure
11:22:50 <zuff> yeah, i kill goats.
11:22:55 <zuff> :|
11:23:02 <zuff> with mondas.
11:23:04 <zuff> *monads
11:23:09 <rio> can you recommend the wikibooks tutorial on haskell?
11:23:41 <Saizan> @where LYAH
11:23:42 <lambdabot> www.learnyouahaskell.com
11:24:04 <mm_freak> i'd consider it a book rather than a tutorial…  if you want a quick entrypoint, you better use something else
11:24:16 <arw> rio: i would recommend http://www.realworldhaskell.org/
11:24:19 <sbahra> shiu
11:24:31 <sbahra> where the ladies at?
11:25:00 <ciscbrain> I found http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours most helpful
11:25:00 <sbahra> any babes from dc?
11:25:40 <mm_freak> i learned haskell mainly through The Haskell Road to Logic and Yet Another Haskell Tutorial
11:25:45 <mm_freak> @where YAHT
11:25:46 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
11:25:57 <sbahra> Sorry, asshole cousin stole my laptop.
11:26:15 <haskell-newbie> I'm going, thanx for the help guys.
11:28:22 <rio> ciscbrain: thats cool, im interested in scheme too, would kill two birds with one stone
11:29:57 <taari> read the text: Audience: People who already know Lisp or Scheme and want to learn Haskell.
11:31:26 <mm_freak> are there cases, where lisp or scheme are preferable over haskell?
11:31:45 <mm_freak> something should justify their ugly syntax =)
11:33:29 <dons> mm_freak: hmm. i'd say no. that's why we see only erlang, haskell and ocaml at cufp. mostly the former 2.
11:33:54 <dons> there's some convergence from the dozens of FP langs 20 years ago
11:33:59 <Asgaroth> mm_freak: Well their syntax is at least better than C/Java in my opinion.
11:34:22 <mm_freak> Asgaroth: sometimes
11:34:32 <mm_freak> dons: what happened to function-level programming?
11:34:58 <dons> we just program in functions?
11:35:35 <mm_freak> i've heard a lot of theory about it, but it never made it into a real program…  i couldn't even name a compiler for, say, FP or FL
11:36:12 <opqdonut> joy is function-level programming
11:36:13 <opqdonut> and cat too
11:36:18 <opqdonut> or at least they claim to be
11:36:24 <dons> mm.
11:37:23 <mm_freak> i can't imagine writing a program without referring to values
11:37:57 <dons> hey. we do it in haskell sometimes.
11:38:01 <dons> but its hard on the brains
11:38:13 <geezusfreeek> conal: i have a question. does your accumE make an event for the initial value or just the updates?
11:38:30 <mm_freak> sometimes…  in fact, we do it a lot, since monadic programming is just that, but at some point you want to refer to a result directly
11:39:20 <yitz> dons: there are still plenty of lisp fanatics who will disagree.
11:39:38 <dons> sure. but they're not writing papers or getting jobs.
11:39:41 --- mode: ChanServ set +o glguy
11:39:43 <dons> :)
11:39:46 --- mode: glguy set -b *!*@cpe-76-172-169-17.socal.res.rr.com
11:39:53 <mm_freak> lisp is still used a lot in AI programming
11:40:00 <yitz> dons: ita software's core app is in lisp
11:40:05 <dons> it is? they should come to CUFP.
11:40:31 <dons> i'd love to hear about new projects too
11:40:45 <yitz> dons: could be the lisp guys still look down their noses at that. :(
11:40:47 <mm_freak> but i can't imagine how lisp is any better than haskell in AI (particularly neural networks)
11:40:57 <dons> there's a difference in the places that are using say, lisp or cobol, because they have 25 years of code to deal with
11:41:06 <dons> and those who're using it now for new stuff, because it is more productive or whatever
11:41:10 <dons> and the latter class i don't see
11:41:21 <yitz> ita's stuff is new.
11:41:36 <dons> good!
11:41:36 <yitz> their main problem is that they can't hire fast enough. only a few hundred so far.
11:41:42 <dons> heh
11:42:03 <dons> yeah, why don't lisp people come to icfp?
11:42:13 <dons> they're too fragmented after the commercial lisp wars of the 80s?
11:42:13 <yitz> most of their hires now don't work on the lisp stuff tho
11:42:42 <yitz> rather with huge amounts of integration with various airlines
11:43:02 <edwardk> @tell gwern yes it is
11:43:02 <lambdabot> Consider it noted.
11:43:16 <ciscbrain> I'm currently learning both common lisp and haskell
11:43:23 <ciscbrain> (trying to)
11:43:33 <dons> which implementation are you using, ciscbrain ? and which set of libraries ?
11:43:58 <yitz> dons: they had some regret about lisp when they weren't getting the support they needed from their compiler vendor.
11:44:01 <dons> btw, we went over 900 libs on hackage this week. i was hopeful to hit 1k by end of month, but might be hard now.
11:44:07 <ciscbrain> and frankly, there's a lot of similarity between common lisp programmers and haskell programmers
11:44:20 <dons> yitz: yeah, you'd want something MS sized to mitigate the risk, or else a big open source project.
11:44:34 <ciscbrain> dons: sbcl
11:44:38 <kig> http://fhtr.blogspot.com/2008/12/hexagons-with-haskell.html have at thee, knaves
11:44:39 <edwardk> @tell gwern in fact if you go onto hackage you'll find menendez's package as category-extras 0.1
11:44:39 <lambdabot> Consider it noted.
11:44:48 <yitz> dons: truth is, you can't do much better than ghc support
11:45:12 <yitz> dons: but those MIT guys are pretty die-hard about lisp.
11:45:19 <dons> yes. i was talking to jane street about this last week, and them lamenting ocaml support from inria. while we're spoiled with open, easy access to ghc
11:45:25 <geezusfreeek> conal: nevermind, i will just work it out myself
11:45:30 <dons> which means we don't need an MS to fund the support as much
11:45:37 <dons> yitz: ah yes of course.
11:45:51 <yitz> dons: actually we do have MS funding the support
11:45:56 <dons> in a way, yep.
11:46:09 <dons> not like say F#, with books and sales people and support lines
11:46:10 <ciscbrain> dons: as for the libaries, whatever I can find on CLiki
11:46:24 <dons> ciscbrain: ok. interesting. and you're using ghc + hackage.haskell.org here?
11:46:32 <yitz> dons: right. but irc is more fun than all that.
11:47:11 <ciscbrain> dons: I have't written that much haskell yet to need libraries :(
11:48:43 <Philippa__> yitz: IRC only scales so far though. We can't make it to 5000 active clients
11:49:27 <yitz> Philippa__: true. I guess we'll have to find a way to distribute it more... :)
11:50:12 <Philippa__> well, the wiki's a good start :-)
11:50:22 <yitz> Philippa__: yeah
11:51:01 <yitz> Philippa__: 10 channels could handle 5000. we'd need a way to make sure that knowledgeable people are distributed among them at all times.
11:51:47 <yitz> Philippa__: are useful irc channels for python perl and the like?
11:51:53 <yitz> *are there
11:52:07 <gdsx> 14:45:12 < yitz> dons: but those MIT guys are pretty die-hard about lisp.
11:52:13 <gdsx> yitz: that's not really true any more
11:52:23 <yitz> gdsx: oh no?
11:52:25 <gdsx> and it was scheme anyway
11:52:32 <Philippa__> I can't really comment. But it's not as simple as 10 channels, either
11:52:58 <Philippa__> part of it is that we're approaching the point where we can't know all the faces in the community, as it were
11:53:00 <yitz> gdsx: ita was founded by a group from mit. they never considered anything besides cl.
11:53:17 <Philippa__> simply forking doesn't work
11:53:19 <gdsx> yitz: 6.001, the legendary Scheme class, was replaced with 6.00, which is taught in python
11:53:47 <gdsx> yitz: same with AI (6.034); you can do problem sets in python or in scheme
11:54:09 <yitz> gdsx: but haskell won't pass i suppose
11:54:30 <p_l> yitz: If they kicked out Scheme for Python....
11:54:35 <gdsx> yitz: I have no idea, but certainly not any time in the next couple years
11:54:50 <gdsx> yitz: the EECS department completely revamped the organization of their core courses
11:55:27 <p_l> gdsx: Is it still possible to take the older, Scheme based courses instead of Python ones? (including 6.001?)
11:55:49 <gdsx> p_l: 6.001 is gone for good
11:55:54 <svref> I want a Int -> Int -> Rational division function...how?
11:55:59 <gdsx> p_l: GJS is still around, though :o)
11:56:05 <mauke> %
11:56:07 <yitz> @type (%)
11:56:08 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
11:56:18 <svref> thx!
11:56:29 <p_l> gdsx: ... R.I.P. 6.001
11:56:37 <gdsx> p_l: yeah
11:57:02 <yitz> svref: if it's really Int and not Integer, you'll need to apply fromIntegral to the arguments though.
11:57:25 <gdsx> p_l: http://hacks.mit.edu/Hacks/by_year/2008/lambda/
11:57:26 <svref> yitz: What's the dif between Int and Integer again?
11:57:36 <p_l> A big reason for me to go to MIT was the use of Scheme (and other "unpopular" langs) for teaching...
11:57:51 <p_l> Seems like it was good for me I didn't make it
11:57:53 <yitz> svref: Int are machine native fixed precision. Integer are arbitrary precision.
11:58:58 * jkff chuckles upon seeing that a library DrHylo for deriving hylomorphisms has been released and wonders how come that such a library hasn't yet been released for PHP or Java
11:59:21 <Zao> jkff: Because no-one else than academics care about *morphisms.
11:59:26 <jkff> I know :)
11:59:58 <jkff> I just thought that the existence of such a library tells *a lot* about the Haskell community :)
12:00:09 <gdsx> p_l: I'm only speculating, but I think a big part of it was that in addition to teaching folks _how_ to program, it's also good for students to have had experience in a language that folks outside of MIT use
12:01:15 <gdsx> p_l: that's not to say you couldn't use whatever language to do assignments for other classes.  and GJS still teaches an "advanced magic in scheme" class
12:01:41 <p_l> gdsx: A good programmer can "get up to speed" with python quite fast. The 6.001 way seemed to me better to root out certain kinds of people (though hopefully there are not many of those at MIT)
12:04:14 <gdsx> p_l: definitely true.  Still, there's something to be said for having experience with a language.  Different languages do things differently, and not having to hit that learning curve, even if you're good at it, can help someone jump into the mix at a new job (for instance)
12:04:26 <svref> grr...how do I convert 9%25 to floating point?
12:04:45 <mauke> :t fromRational
12:04:46 <lambdabot> forall a. (Fractional a) => Rational -> a
12:04:52 <yitz> > realToFrac (9%25)
12:04:53 <lambdabot>   0.36
12:06:14 <yitz> @type realToFrac
12:06:16 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
12:06:21 <p_l> gdsx: I think it's easier to make good programs after being exposed to let's say both assembly/C and some HLL, like Lisp or Haskell (especially since Scheme favored FP). And there's a lot of time to learn additional stuff during those 3 years...
12:07:47 <yitz> p_l: if the python course gives them a solid background in generators, then it will also suffice.
12:08:03 <p_l> yitz: I hope so.
12:08:43 <yitz> p_l: assuming, of course, that it's only a start, and that they'll move onward and upward from there in any case. then it doesn't matter so much.
12:10:22 <gdsx> p_l: not as much time as one might suspect, I don't think.  I didn't do EECS, but it's one of the majors with the most requirements.  And then folks typically spend their time taking various classes that aren't about programming at all.  So part of the problem is that time is limited, I think
12:10:42 <svref> One thing I've never understood about fromRational etc. are how it knows what you want it to convert it TO? I mean, if I type "fromRational 5" at the top level of ghci, it appears to correctly guess that the "a" I want is Float...how?
12:11:11 <p_l> gdsx: Well, I ended at a place where the only programming class I have is to catch-up on sleep or chatting on IRC (read: a Java class)
12:11:18 <ksf> :t fromRational 4
12:11:20 <lambdabot> forall a. (Fractional a) => a
12:11:32 <yitz> svref: they worked for a long time on that mind-reading module in the compiler.
12:11:37 <ksf> :t show
12:11:38 <lambdabot> forall a. (Show a) => a -> String
12:12:11 <gdsx> p_l: aah :o/
12:12:11 <mauke> svref: defaulting
12:12:33 <yitz> svref: usually, the type checker can figure out what type is needed to make it compile. at the top level, there is a default type in certain classes.
12:12:34 <mauke> svref: it chooses Double for fractions and Integer for other numbers
12:13:20 <svref> ah
12:14:43 <svref> apologies for being such a nimrod. I'm on p22 of my book.
12:15:14 <yitz> svref: no prob, ask away.
12:15:27 <yitz> svref: what are you reading?
12:20:28 <svref> yitz: I am swapping between two, one has "craft" in the title, and the other has "school of expression" in the title. They both are kinda annoying me.
12:21:28 <svref> yitz: in the past I penetrated deeper than p22, but Monads never sunk in. Forgot a lot in the interim.
12:22:38 <yitz> svref: those were the two standards in the past. now there are more choices.
12:23:06 <yitz> svref: never read either of them, but they're reputed to be pretty good.
12:23:23 <yitz> svref: now all of the buzz is about Real World Haskell, just came out from O'
12:23:27 <yitz> O'Reillley
12:24:00 <yitz> svref: you can try it for free online
12:24:22 <opqdonut> school of expression is nice
12:24:36 <opqdonut> but it's more about functional design than haskell
12:24:49 <gwern> opqdonut: I have it, but I haven't gotten very far since the example programs don't seem to quite work with the released libraries
12:24:49 <lambdabot> gwern: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:24:55 <gwern> which is discouraging
12:24:57 <gwern> @messages
12:24:58 <lambdabot> edwardk said 41m 55s ago: yes it is
12:24:58 <lambdabot> edwardk said 40m 18s ago: in fact if you go onto hackage you'll find menendez's package as category-extras 0.1
12:25:17 <opqdonut> gwern: yeah it's abit outdated
12:25:47 <svref> yitz: I added Real World to my gift registry. :)
12:26:18 <sm> boy, http://www.haskell.org/hood looks great. Why no updates in so long, does it work with modern ghc ?
12:27:04 <gwern> edwardk: ok then I'll remove it from the listing
12:27:24 <gwern> sm: hood? I've never heard of anyone actually using it in the last 2 years or so I've been hanging out in haskell circles
12:27:27 <yitz> sm: now there's an integrated debugger in ghci
12:27:50 <sm> oh I know, but this looks to be useful in some cases ghci wouldn't be
12:28:08 <sm> also there's this great visualiser: http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/GHood/
12:28:37 <sm> & good morning all
12:29:17 <yitz> sm: hood is post-mortem, ghci let's you debug live in the runtime
12:33:16 <yitz> miranda is an IM client? funny, I always thought it was a programming language.
12:34:04 <smtms> funny, I've always thought Haskell is (was) a mathematician
12:35:16 <yitz> smtms: it's a university. and a county in Texas.
12:37:16 <zooko> So, I fail to build ghc-6.10.1: http://codepad.org/87UIolX7
12:38:34 <zooko> And on a diferent machine I fail in a differnet way: http://codepad.org/C5FWQO3s
12:38:41 <zooko> But on a third machine I succeeded.
12:38:56 <bjrn> Quote of the day: "When you move to FP, all your algorithms break" :)
12:39:13 <Igloo> zooko: Your first paste doesn't look like it includes the first failure
12:40:04 <zooko> Igloo: there is a lot of output.  I will search for the first thing that looks wrong...
12:41:25 <jethr0> bjrn: i see you've been reading slashdot ;)
12:41:37 <zooko> configure looks ghood...
12:42:16 <bjrn> jethr0: we all got our weaknesses :)
12:42:20 <jethr0> I think the author of that comment got too much criticism. It is indeed true that in order to gain real benefits from a different programming paradigm you will have to completely rewrite your code
12:42:43 <jethr0> but, at least in haskell you can port your imperative code into the IO monad and replace it piece by piece
12:43:33 <mathijs> Does anyone know if the published version of 'real world haskell' is on par with the online-version? I've been trying to work through the online version, but in almost all chapters I get lost somewhere. The presented code just doesn't work, or it's not clear to me why certain things are done.
12:44:19 <jethr0> mathijs: can you give an example? i would expect the authors to be pretty meticulous that the code is working...
12:44:56 <mathijs> Looking at the comments, there are more people who get stuck, and a lot of helpful comments that got me back on track. Is the online version still being worked on? will the helpful comments get into a future revision?
12:45:02 <pumpkin_> I noticed that some of the code boxes are just showing code in one of the ghc libraries rather than expecting you to write it yourself
12:45:38 <dons> bjrn: haha
12:45:48 <zooko> Igloo: hm, well the very first line of output says "grep: packages: No such file or directory"
12:45:53 <dons> ?users
12:45:53 <lambdabot> Maximum users seen in #haskell: 568, currently: 543 (95.6%), active: 17 (3.1%)
12:46:18 <bjrn> dons: Context http://tech.slashdot.org/article.pl?sid=08/12/05/2346235
12:46:33 <jethr0> mathijs: hmm, i just ordered the book myself. are you relatively new to haskell programming?
12:46:55 <dons> bjrn: yeah, i know. those threads are a mixed blessing
12:47:06 <dons> the uninformed make lots of noise, but at least we get some visibility
12:47:24 <mathijs> jethr0: yup relatively new... I'm looking for examples... also some places the text just stops (online), and judging by the comments, there used to be more info in some places.
12:47:24 <dons> mathijs: the online version is the draft prior to being sent to proof reading
12:47:35 <dons> we'll be getting back the final version with all the typos fixed and putting that online again soon
12:47:41 <dons> then archiving the old comments, and collecting new ones
12:48:03 <zooko> Abd the final failure seems to have to do with mossing packages...
12:48:07 <dons> the published version (pdf, paper etc) is the full thing atm.
12:48:11 <dons> zooko: yes.
12:48:16 <dons> actually, we can fix that.
12:48:16 <jethr0> mathijs: from what i expect the book to be it might not be ideal as an introduction to haskell. but as I haven't looked at the draft lately I might be wrong
12:48:26 <dons> its an intro to haskell for programmers
12:48:29 <dons> not for non-programmers
12:48:38 <dons> it only assumes you already can program in one other language, probably imperative
12:48:39 <AHMAD1NEJAD> hahahaha
12:48:46 <AHMAD1NEJAD> smerdyakov is banned from #haskell
12:48:52 <AHMAD1NEJAD> for what, murdering fyodor?
12:48:59 <jethr0> ok, strike my last comment. whatever dons says ^_^
12:49:03 <dons> do you have a question, AHMAD1NEJAD ?
12:49:08 <mathijs> dons: Ok, so it contains fixes that are not in the online version? in that case I'll order it... The book is good I think, just those show-stoppers make me go nuts, while I know they are probably very small
12:49:08 <dons> or a less noisy nick, btw?
12:49:11 <AHMAD1NEJAD> that was my question
12:49:19 <AHMAD1NEJAD> if you've read that book
12:49:22 <dons> mathijs: yes. there was about 400 commits by o'reilly
12:49:23 <AHMAD1NEJAD> you'll understand why it's funny ;)
12:49:46 <mathijs> dons: that's a lot :)
12:49:56 <dons> yep
12:49:58 <pumpkin_> AHMAD1NEJAD: we can understand why it's funny, but still not think it's terribly relevant to haskell :)
12:50:03 <dons> they did lots of good work.
12:50:51 <mathijs> dons: also, in chapter 8, many examples seem to error out... are the examples being run in ghci on the fly or something? I suppose they worked before, but some ghc upgrade b0rked them
12:50:57 <dons> i've been really happy with the reviews of RWH so far. "this book will ignite the already growing haskell community. 10/10! " is my favourite i htink
12:51:08 <AHMAD1NEJAD> RWH=?
12:51:12 <Raevel> yes! number 10!
12:51:16 <pumpkin_> AHMAD1NEJAD: real world haskell
12:51:21 <zooko> Hm, so does the fact that there is no directory or file named "packages" mean that my ghc-6.10.1 source tree is corrupt?
12:51:22 <dons> mathijs: yes, most of the examples are in ghci, so if they error, that is usually due to missing libs on the production machine
12:51:29 <dons> zooko: no?
12:51:33 <AHMAD1NEJAD> can you get it online?
12:51:37 <dons> AHMAD1NEJAD: yes.
12:51:41 <dons> google will tell you
12:51:41 <Gracenotes> dons: hey, I'm somewhat of a novice myself, following the online version
12:51:45 * AHMAD1NEJAD already googled it
12:51:47 <mathijs> dons: so they are put into the text on-the fly?
12:51:49 <Gracenotes> considerably informative
12:51:51 <pumpkin_> AHMAD1NEJAD: are you the same syr.edu guy who got banned yesterday?
12:51:51 <dons> mathijs: yeah
12:52:03 <dons> pumpkin_: yes
12:52:05 <zooko> dons: Hm, okay.
12:52:07 <pumpkin_> ah
12:52:08 <AHMAD1NEJAD> :/
12:52:09 <dons> AHMAD1NEJAD: change your nick. pick one. and stick to it.
12:52:15 <dons> and stay on topic.
12:52:34 <Badger> Nick censoring.
12:52:38 <mathijs> dons: nice... what software is used for the online book? I like the commenting (and code example stuff). is it open-source?
12:52:38 <dons> stupid capital nicks that change from day to day aren't productive, and are likely to alienate people who might help you.
12:52:51 <AHMAD1NEJAD> namely you, right? ;)
12:52:56 <dons> right.
12:53:01 <pumpkin_> heh
12:53:42 <dons> notice we're trying to maintain a community here. people tend to use their real names, speak openly, and have some trust. silly behaviour undermines that.
12:53:42 <Igloo> zooko: That's normal
12:53:48 <Igloo> zooko: (missing packages files)
12:54:08 <dons> so there's some conformity to the expected norms of the channel, or you'll just find yourself not able to achieve much
12:54:53 <AnalogHole> Question abotu monads... when you "lift" a function into a monad, how is it determined what monad you're talking about? Or is this a nonsensical question?
12:54:54 <ahmad1nejad> oh shit, RHW is the one with the comments
12:55:00 <ahmad1nejad> i've been trying to find this
12:55:11 <blackh> AnalogHole: Type inference
12:55:22 <dons> ahmad1nejad: so i'd suggest sticking to 'ushdf' or whatever your whatever your normal nick is. making some honest contributions, and attempt to stay on topic. life will be much more pleasant.
12:55:37 <Ezla> I wish there was a book about Haskell patterns
12:55:37 <AnalogHole> blackh: So, if you happen to be in main, for exampl,e it lifts it into the IO monad because that's what main returns?
12:55:43 <dons> yep
12:55:45 <ahmad1nejad> i'll contribute as soon as i know haskell
12:56:02 <mathijs> Ezla: as in 'design patterns' like the GOF have for OO languages?
12:56:14 <dons> Ezla: hmm.. RWH does talk about main idioms for designing programs in small and large
12:56:22 <Ezla> Yes mathijs, including all those patterns and also haskell specific idioims
12:56:23 <dons> sprinkled through the code. see e.g. the monad transformers chapter
12:56:30 <Ezla> I suppose Monad would be one
12:56:38 <blackh> > :t liftM
12:56:40 <lambdabot>   <no location info>: parse error on input `:'
12:56:46 <dons> well, particular monads encapsulate particular patterns explicitly
12:56:47 <Botje> :t liftM
12:56:48 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:56:52 <Ezla> dons: How thorough is RWH at that?
12:57:04 <mathijs> Ezla: 'normal' OO patterns won't work... they don't have a haskell equivalent, and if they do, it's probably not the best way to do it.
12:57:16 <Ezla> I'd disagree mathijs
12:57:19 <dons> well, design patterns are implicit. it's not the main goal, but i'd argue RWH is thorouugh. 710 pages of thorough
12:57:29 <pumpkin_> Ezla: how can you disagree when you don't have any experience with haskell?
12:57:31 <Ezla> I think most of them likely have a haskell equivalent, even if Haskell simplifies it to 2 lines of code
12:57:44 <dons> there are patterns though. when to use the Reader monad, say
12:57:57 <blackh> AnalogHole: Type inference can happen based on return type, so if your return type for liftM is "some monad", it'll match
12:57:58 <zooko> Okay, here is the complete output from "make" in my ghc-6.10.1 tree which I got from unpacking the src tarball and the src-extralibs tarball:
12:58:00 <zooko> http://127.0.0.1:8123/uri/URI%3ACHK%3Arujvwuy7m2susdcol4m73cae74%3A4bnx2lc4v45hgi7k47vka2iwtqnkiznomfp4dg2hsyvbsxss2vpa%3A3%3A10%3A135012
12:58:03 <Ezla> every one of the patterns in GoF will translate directly to haskell in some way
12:58:06 <zooko> Oops, localhost link, sorry.
12:58:10 <Ezla> for example,
12:58:15 <dons> Ezla: oh sure. Turing says so. just not usefully so sometimes
12:58:24 <dons> many of the OO ones are about managing mutable state that we don't even care about
12:58:25 <Ezla> How do you make a good observer in Haskell?
12:58:28 <Botje> Ezla: not really. the command pattern is only there because C++ does not have lambdas.
12:58:36 <Botje> likewise for the strategy pattern
12:58:40 <mathijs> Ezla: nope, most GOF patterns are really bound to objects, delegation, and separating state... Haskell, and FP in general, is built from the ground up so you don't _have_ to use those patterns to keep your code clean
12:58:45 <dons> so some of them fall out trivially. so trivial we'd never even think of them
12:58:58 <Ezla> Ok, here's the ones I think apply in haskell:
12:58:59 <dons> and instead we have different idioms.
12:59:00 <zooko> http://testgrid.allmydata.org:3567/uri/URI%3ACHK%3Arujvwuy7m2susdcol4m73cae74%3A4bnx2lc4v45hgi7k47vka2iwtqnkiznomfp4dg2hsyvbsxss2vpa%3A3%3A10%3A135012
12:59:09 <ciscbrain> dons: RWH has 710 pages?!
12:59:18 <dons> nice gtk2hs demo, http://fhtr.blogspot.com/2008/12/hexagons-with-haskell.html
12:59:26 <dons> dcoutts_: you should link to it on your gtk blog
12:59:28 <dons> ciscbrain: yah
12:59:35 <ciscbrain> dons: I was going to order the printed version, but at 710 pages I think I'll get the pdf
12:59:36 <dons> serious business, this haskell. we're not faking.
12:59:37 <Botje> should've ade it 709 or 719
12:59:41 <dons> ciscbrain: heh.
12:59:42 <AnalogHole> blackh: can you be explicit about the monad it returns?
12:59:58 <jethr0> there are those who argue that patterns are really abstractions waiting to happen. I.e. with higher order functions you can implement a pattern once and use it as a library call (in many cases)
12:59:58 <pumpkin_> AnalogHole: yup, in your type definition
13:00:00 <dons> ciscbrain: well, go for whatever you think is best. there are photos on the site so you can get a sense of the size.
13:00:07 <Igloo> zooko: What version is /usr/bin/ghc?
13:00:19 <luite_> Botje: that would be for the real world haskell-prime book
13:00:25 <zooko> Igloo: The Glorious Glasgow Haskell Compilation System, version 6.6
13:00:28 <blackh> AnalogHole: Yes you can - you can use the :: operator to specfy a type somewhere
13:00:33 <Botje> luite_: heh :))
13:00:55 <jethr0> > 4 + (5 :: Integer)
13:00:56 <lambdabot>   9
13:01:26 <Ezla> Abstract factory, factory, singleton, prototype, flyweight, observer, memento, visitor, iterator, multiple dispatch, RAII, state
13:01:27 <dons> this is nice, http://www.reddit.com/r/programming/comments/7hu1a/hexagon_graphics_with_haskell_using_gtk2hs_and/
13:01:29 * Botje really hates design patterns because the only people who like them are java drones
13:01:38 <dons> yay for gui stuff. i wonder if he's reading the gtk chapter in RWH.
13:02:09 <sm> a nice image!
13:02:09 <Igloo> zooko: OK, and do you have 2 versions of filepath installed? (ghc-pkg list filepath)
13:02:12 <jethr0> Somewhere in the functional community patterns were categorized as a language design smell ;)
13:02:19 <jethr0> forgot where i read that
13:02:19 <ahmad1nejad> when does type inference fail
13:02:28 <mathijs> Ezla: observer? as in an object that notifies another object when its state changes? In haskell there is no state to change
13:02:30 <pumpkin_> ahmad1nejad: when it's inconsistent?
13:02:31 <Botje> ahmad1nejad: when your code is wrong :)
13:02:36 <ahmad1nejad> good
13:02:38 <glguy> mathijs, sure there is
13:02:38 <Ezla> saying that Haskell doesn't do "command" doesn't matter, because you can, instead, say: Here's how we do command in an *extra* special way
13:02:42 --- mode: glguy set -o glguy
13:02:45 <Ezla> and show the more articulated Haskell forms
13:02:54 <Ezla> rather than just the simple "functor" approach
13:03:13 <Igloo> zooko: Is this the log from a clean build, by the way?
13:03:34 <Ezla> mathijhs: I don't believe the part about "haskell has no state"
13:03:35 <Ezla> more like:
13:03:36 <blackh> agmadinejad: floor . read <- type inference fails for something like this because it doesn't know what 'real' type to use for the intermediate value
13:03:42 <Ezla> Haskell does state differently.
13:03:46 <zooko> Igloo: I guess that log must not have been a clean build.  Sorry.
13:03:56 <Toxaris> mathijs: I think one could consider Observer (and Model-View-Controller) as a poor man's FRP
13:03:57 <zooko> I've launched a fresh attempt from the src tarballs but it will take quite a while.
13:03:58 <sm> speaking of guis.. am I right in thinking vty is a bit higher-level than (nano,h)curses ? And cannot go quite as fast as the latter, because it always updates a screenful at a time ?
13:04:16 <Igloo> zooko: do you have 2 versions of filepath installed? (ghc-pkg list filepath)
13:04:29 <zooko> gloo: in answer to your question, I have only FilePath-0.11,
13:04:33 <Ezla> Also don't discount my motivations
13:04:58 <Ezla> Maybe I'm one of those Java newbies you describe, and want to "practice implement" on a common ground
13:04:59 <Igloo> Hmm, OK
13:05:00 <ahmad1nejad> char is automatically unicode :D:D
13:05:00 <sm> I looked at your hmp3 and tried to get a nanocurses app going, dons, but found vty simpler
13:05:02 <glguy> Ezla, I think that the visitor pattern is largely dealt with by ADTs and pattern matching
13:05:13 <dons> sm, yeah, vty is simpler.
13:05:24 <dons> i think we can do a pure ncurses gui layer, via pretty printing
13:05:28 <dons> but haven't got back to it yet.
13:05:29 <Ezla> glguy: Can that be shown in a tiny example?
13:05:51 <blackh> ahmad1nejad: floor . read doesn't fail, but I've had things *like* that fail. :)
13:06:16 <Ezla> or does it really require a working system to show
13:06:23 <sm> interesting. I guess I should say tui here
13:06:28 <mathijs> Ezla: just try to write some blogpost about GoF patterns translated into FP. It just won't map... the whole paradigm is different, the way you think about stuff is different. Of course you want to get the same stuff done, but GoF patterns talk about how to get something done (imperative), while in FP you just declare what the result should be.
13:06:33 <glguy> Ezla, well, foldr is the trivial example
13:06:38 <ahmad1nejad> the more i learn the more all other languages seem like shitty emulations of haskell
13:06:45 <glguy> Ezla, it lets you define w hat to do in the cons and null cases
13:07:00 <glguy> @src foldr
13:07:00 <lambdabot> foldr f z []     = z
13:07:01 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:07:06 <Botje> ahmad1nejad: yeah, that's an unfortunate side-effect (heh) of haskell.
13:07:19 <ahmad1nejad> are lists still based on cdr and car
13:07:26 <Ezla> glguy: When does "type" get erased in haskell?
13:07:35 <glguy> Ezla, generally at compile time
13:07:52 <glguy> but the constructors persist
13:07:55 <ahmad1nejad> er, cons and the other X$
13:07:59 <zooko> Oh and I succeeeded at building ghc-6.10.1 on a fourth system, with one patch needed to the build scripts.
13:08:06 <Ezla> In OO languages, you can lose the derived type when you pass around references of base types, except that the objects behave as their deriveds
13:08:11 <Ezla> what is the direct haskell analogue?
13:08:23 <glguy> we don't have subtyping
13:08:29 <glguy> but
13:08:39 <glguy> you can see some effects with weird typeclass interactions
13:08:51 <glguy> that are somewhat like you describe
13:09:00 <Botje> Ezla: you can implement visitor with functors or boilerplate libraries
13:09:22 <ahmad1nejad> :t floor 236.3
13:09:23 <lambdabot> forall b. (Integral b) => b
13:09:43 <Ezla> the way I think of Visitor in Haskell, well what comes to mind at least would be
13:09:58 <ahmad1nejad> > floor 236.3
13:09:59 <lambdabot>   236
13:10:04 <Toxaris> visitor is a design pattern, its not a design. you can't implement it, you can instantiate it in a design, then implement that design
13:10:07 <ahmad1nejad> heh
13:10:14 <Ezla> A tuple, of a certain typeclass, which has a bunch of specific types. Inside of each tuple element, there's another tuple of functions
13:10:17 <dons> isn't visitor some super trival fmap-py or one of the other traversal classes thing?
13:10:24 <Ezla> the elements correspond to types
13:10:53 <zooko> Igloo: so on the two machines where bulding ghc-6.10.1 failed, the other one failed in an entirely different way.
13:11:00 <zooko> Here is the complete output from make of a clean build:
13:11:32 <Ezla> Although, this leads to another question
13:11:33 <glguy> Ezla, when you say of a specific typeclass, do you mean data type?
13:12:03 <Ezla> glguy: a tuple constrained to being to only hold elements of typeclass X
13:12:11 <Ezla>  *able
13:12:56 <Ezla> The interesting part on visitor, though:
13:13:18 <Ezla> is that visitor allowed you to add functionality to object types without modifying their implementation
13:13:27 <Ezla> it let you made uncoupled methods
13:13:32 <Ezla> but haskell is like that _by default_ !
13:13:41 <Botje> yay for haskell!
13:14:19 <sereven> http://omploader.org/venRt -- lambdakitty 4 ur lo\z
13:14:26 <Ezla> the reason I used the Tuple example
13:14:39 <Ezla> is if you wanted to group them together, it seems Visitor would only exist then
13:15:02 <ahmad1nejad> sereven: my kitten can play with xmonad
13:15:18 <ahmad1nejad> i mean all he does is resize windows
13:15:29 <Ezla> How do you typeclass functions?
13:15:53 <Ezla> Not classes of types
13:15:57 <Ezla> but functionclasses
13:16:31 <glguy> Ezla, I'm not sure what you mean
13:16:55 <glguy> maybe provide a simple instance of the visitor you are familiar with
13:17:00 <glguy> and we can try to write that as haskell code?
13:17:01 <Ezla> I have types x and y, and functions f and g
13:17:17 <Ezla> I can classify x and y with a typeclass
13:17:21 <Ezla> how do I classify f and g ?
13:17:40 <glguy> f and g are functions that need to operator on X and Y?
13:17:48 <Ezla> Nope, they could be:
13:17:52 <Ezla> f x = x
13:17:57 <Ezla> g x = "evil"
13:18:02 <Toxaris> visitors are not only about adding operations to fixed data structures, but also about abstracting over recursion schemes: http://hpaste.org/12787
13:18:13 <Ezla> Toxaris: exactly
13:18:18 <Ezla> thats why I wanted to use the Tuple
13:18:23 <Ezla> or classify the functions together somehow
13:18:25 <Cale> Hi Ezla
13:18:26 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
13:18:26 <blackh> Ezla: You can wrap a function in a newtype and typeclass that
13:18:34 <Ezla> That way the Tuple can descend the datastructure
13:18:42 <glguy> class Thing a where f :: a -> a ; g :: a -> String
13:18:51 <zooko> Igloo: okay, here is the output from a clean build on one of my Ubuntu Hardy boxes: http://testgrid.allmydata.org:3567/uri/URI%3ACHK%3Aluugwmtb4br2t7kvqgyyza3mei%3Aqnrsbd3tqkqbquvckctg64byuktsuqogoggzq2qpo2mjak5ml7ka%3A3%3A10%3A4460465
13:18:56 <Ezla> blackh: Does "Functor" generalize that?
13:18:57 <Ezla> hey Cale
13:19:04 <glguy> instance Thing X where f x = x ; g x = "evil"
13:19:07 <Toxaris> Ezla: well, instead of using (eval number plus = ...) you could use (eval (number, plus) = ...), then you have your tuple
13:19:09 <mathijs> dons: do you know of an online store that ships RWH to europe and allows paypal-transactions? My usual bookstore doesn't have RWH yet.
13:19:39 <zooko> Interestingly, one of the machines where it succeeded to build was also Ubuntu Hardy with ghc-6.8.2.  Hm.
13:19:44 <blackh> blackh: I don't know.
13:19:57 <blackh> Ezla: Now I am talking to myself.
13:19:59 <Ezla> Toxaris: Can you fit that on 1 loc?
13:20:02 <Toxaris> Ezla: Functor is connected to the visitor pattern, because the visitor pattern is based on Sigma algebras, which can express the same things as Functor algebras, which can be expressed with Functor
13:20:06 <ciscbrain> mathijs: can't you use Amazon?
13:20:13 <Ezla> blackh: I read what you said about wrapping
13:20:17 <Toxaris> Ezla: but I'm not sure whether that helps you ;)
13:20:20 <Ezla> I meant the Functor question for you
13:20:51 <mathijs> ciscbrain: nope, it needs a credit-card. I don't have one. Where I live (holland) we have our own online-payment system, and for most non-local stuff I can use paypal.
13:20:58 <Ezla> Toxaris: Would you typeclass those Functors to get the set which operates on the Ie, tree?
13:20:59 <Toxaris> Ezla: what do you want on one line of code?
13:21:01 <Ezla> or would you tuple them?
13:21:03 <Cale> Toxaris: do you mean the same sigma algebras I'm thinking of?
13:21:29 <Toxaris> Cale: I mean a signature sigma of function symbols, and an algebra which interpretes each symbol with a function, etc.
13:21:35 <ciscbrain> mathijs: oh.. I thought is was more of a shipping problem :(
13:21:42 <Cale> Oh, okay, that's quite different :)
13:21:47 <mathijs> ciscbrain: nope, payment only
13:22:04 <dons> mathijs: hmm. paypal eh/
13:22:10 <Toxaris> Cale: I think some people call them Omega algebras, and I have no clue what area of mathematics they come from or whatever
13:22:55 <Cale> Toxaris: They sound like algebras in the sense of universal algebra.
13:23:02 <Ezla> ill give some pseudo code
13:23:03 <Igloo> zooko: Haven't seen that before AFAICR
13:23:17 <mathijs> dons: That would be great, amazon doesn't support the dutch system (iDeal), so I either have to ask a friend with a credit-card, or wait for my normal bookstore to ship RWH
13:23:19 <arussel> in ghci, is there a way to have a look at the doc of a function ?
13:23:30 <Cale> http://en.wikipedia.org/wiki/Universal_algebra
13:23:33 <dons> mathijs: have you gone through the online stores?
13:24:05 <mathijs> dons: O'Reilly and Amazon
13:24:11 <dons> arussel: no. you have to try hoogle
13:24:21 <dons> mathijs: ok. i don't know of any that use paypal. i imagine some must.
13:24:27 <dons> and there are lots of other bookstores shipping rwh
13:24:34 <dons> if you find out one that does, please let me know.
13:24:39 <dons> and i'll add it to the website
13:24:45 <ahmad1nejad> what's the actual opposite of head?
13:24:49 <ahmad1nejad> i.e., last element of a list
13:24:53 <arussel> dons: ok, thanks
13:24:56 <mathijs> ok... I'll look around for one that supports paypal
13:25:07 <jfredett> ahmad1nejad: last?
13:25:10 <dons> mathijs: might be something to 'ask reddit' ?
13:25:11 <jfredett> > last [1,2,3,4]
13:25:12 <lambdabot>   4
13:25:27 <ahmad1nejad> > first [1,2,3,4]
13:25:28 <lambdabot>   Couldn't match expected type `a b c' against inferred type `[a1]'
13:25:36 * ahmad1nejad scowls
13:25:39 <jfredett> you want head there
13:25:40 <pumpkin_> ahmad1nejad: avoid using it though, cause it takes time proportional to the length of the list
13:25:42 <jfredett> > head [1,2,3,4]
13:25:44 <lambdabot>   1
13:25:51 <ahmad1nejad> so what does first do :O
13:25:52 <jfredett> head is O(1)
13:25:54 <jfredett> last is O(n)
13:26:06 <Ezla> class Branch { void accept(BranchVisitor v) { v.apply(this); } }  class Foo : Branch {}  class Bar : Branch {}  /* blah blah */  class Print : BranchVisitor { void visit(Foo) {... do stuff};  void visit(Bar) {...do stuff};  } }   ....
13:26:11 <Botje> > (first (+1)) (5,5)
13:26:12 <lambdabot>   (6,5)
13:26:24 <Ezla> Print is a *function class*
13:26:27 <jfredett> first is from the arrow libraries
13:26:28 <Ezla> like a typeclass is for types
13:26:29 <jfredett> :t first
13:26:30 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
13:26:34 <Ezla> its a class of Print functions
13:26:43 <Ezla> constrained to the Instances of Branch
13:26:46 <Botje> Ezla: data Branch = Foo .. | Bar ..
13:26:55 <Toxaris> is there a newtype Fix = Fix ... in the libraries somewhere \bot can find it?
13:26:56 <Botje> you can then write an instance of Functor for Branch and fmap over it.
13:27:12 <jfredett> the wiki has a tutorial on it (arrows and first), ahmad1nejad
13:27:14 <Toxaris> hmm no need for \bot, actually, more like  someone wanting to try out my code from hpaste can find it
13:27:32 <Ezla> Botje: That makes the types, but
13:27:40 <Ezla> doesnt help classify a functionclass together
13:28:11 <byorgey> @seen CosmicRay
13:28:11 <lambdabot> I saw CosmicRay leaving #haskell-blah and #haskell 22h 36m 3s ago, and .
13:28:20 <Ezla> in my example s/apply/visit/
13:28:30 <byorgey> hmm, sequence.complete.org seems to be down
13:31:07 <zooko> Igloo: it seems like the fatal error is in building docs, which I didn't request and don't need.
13:31:14 <zooko> IS there a make target that explicitly builds just the compiler?
13:33:13 <dons> zooko: cd compiler ; make
13:33:13 <dons> ?
13:35:06 <Ezla> visitor can just be called multiple dispatch
13:35:49 <Toxaris> Ezla: but then you do not have the abstracting over recursion part of visitor
13:36:03 <Ezla> No I couldnt fit that on 1 loc
13:36:07 <Ezla> but its easy to imagine
13:36:13 <Ezla> How do you xlate my LOC into Haskell?
13:36:28 <Toxaris> btw, here is the F-Algebra version of my little Expr-Interpreter, this time using Functor: http://hpaste.org/12787#a1
13:36:36 <Ezla> I'll shorten / fix it once
13:37:29 <zooko> dons: cd compiler && make worked
13:37:52 <zooko> Hm, it left something in stage1-inplace.
13:38:25 <Toxaris> Ezla: Do you mean "class Branch ..." with your line of code? I have already given similiar code in Haskell in hpaste, not in one line, because I use shorter lines, but feel free to remove the line breaks
13:38:55 <Toxaris> my example has the additional advantage of working (well, it compiles, I didnt run it), and doing something semi-usefull
13:39:59 <Ezla> class Branch { void accept(BranchVisitor v) = 0; } class Foo:Branch { void accept(BranchVisitor v) { v.visit(this); } } class Bar:Branch { void accept(BranchVisitor v) { v.visit(this); } } class Print:BranchVisitor { void visit(Foo) {/*stuff*/}; void visit(Bar) {/*stuff*/}; } }
13:40:11 <Ezla> so :
13:40:20 <Ezla> class Print:BranchVisitor  // the functionclass
13:40:29 <Ezla> which would be a typeclass of functors in Haskell
13:40:32 <Ezla> or something else?
13:40:43 <Toxaris> Ezla: Maybe you misunderstand Functor
13:40:54 <Toxaris> Ezla: it means something different in Haskell as e.g. in C++
13:41:05 <Ezla> I undestood functor in this context to be a means to wrap a function in a type
13:41:05 <zooko> Hm, can I just install stage1-inplace/ghc into my bin directory and call it good, I wonder...
13:41:08 <Ezla> so that I can typeclass it
13:41:18 <Toxaris> Ezla: that's not it
13:41:19 <Ezla> since there's no functionclasses
13:41:25 <Toxaris> there is no need to typeclass functions
13:41:26 <Ezla> Toxaris: oh?
13:41:30 <Toxaris> you just, well, use them
13:41:37 <Ezla> toxaris: Why not? What if I want to typeclass them?
13:41:45 <Toxaris> what do you want to express?
13:41:53 <Ezla> For visiting a tree, it doesnt matter eh?
13:42:02 <Ezla> Toxaris: can you xlate my LOC into tiny Haskell code?
13:42:23 <Toxaris> Ezla: have you looked at my hpaste?
13:42:32 <zooko> Oh wait, stage2-inplace has a ghc, too!
13:42:36 <Ezla> I was too busy typing and missed it ;)
13:42:41 * Ezla scrolls up
13:43:25 <Ezla> Toxaris: that's perfect
13:43:43 <Ezla> The top one, is what I was talking about
13:43:47 <mathijs> dons: you can add barnesandnoble.com they have paypal. too bad it takes up to 3 weeks to get here, and a whopping $12 just for shipping :)
13:44:02 <Toxaris> Ezla: yeah I guessed so, so I was wondering why you kept asking for it :)
13:44:26 <Ezla> cool
13:44:45 <Toxaris> Ezla: the bottom one is more advanced, but it has some cool features, e.g. visit works for all (!) data structures
13:45:11 <Toxaris> (if you express them as the fixpoint of a functor, which is always possible for algebraic data types)
13:45:42 <Toxaris> but the top one is more similiar to what you do in OO
13:45:43 <Ezla> I guess use of typeclass constraints can express every possible scenario which I could imagine to, coming from the other direction, require a functionclass set of constraints?
13:46:03 <Ezla> It only needs to resolve one direction
13:46:05 <Ezla> one flow
13:46:31 <Toxaris> I'm not sure what you mean with functioncalls, but you can express *which* functions you want by types
13:47:00 <Toxaris> e.g. my visit method in the hpaste (top one) says that it only accepts (Int -> a) and (a -> a -> a) functions, for the type a the caller has choosen
13:47:30 <Toxaris> these types match the structure of the datastructure, of course, so everything works out in the end
13:47:41 <Ezla> Toxaris: Only accepts is what I meant by "one direction"
13:48:16 <Ezla> what do you mean by all (!) structures ?
13:48:23 <Ezla> I'm not familiar with !
13:48:37 <Toxaris> Ezla: by all I mean all, and (!) is like (sic!), to highlight this point because I consider it cool
13:48:44 <Toxaris> Ezpa
13:48:45 <Ezla> lol
13:48:46 <Ezla> ok
13:48:53 <Ezla> I thought (!) was a function
13:49:22 <Toxaris> oh it is, but I didn't meant that one
13:49:53 <jkff> ...And in the meantime... I'm exercising in writing a fast prime generator - http://hpaste.org/12790 . Any thoughts on why does mult' eat 15.5% CPU and why the whole program spends 56% in GC?
13:49:58 <Ezla> Toxaris: You already had this prepared. Did you put together your collection of a bunch of haskell patterns like that?
13:50:05 <Ezla> unless you wrote it on the spot !?
13:50:36 <Ezla> and If the former...
13:50:42 <Ezla> what else is in that bag of tricks?
13:50:43 <Toxaris> > array (0, 2) [(1, 27), (0, 42), (2, 13)] ! 0 -- here is the ! function
13:50:44 <lambdabot>   42
13:50:53 <dons> mathijs: ah ok. good to know
13:50:55 <Ezla> since I asked how many patterns xlate
13:52:04 <gwern> is hwn down for anyone else?
13:52:19 <Toxaris> Ezla: I wrote it on the spot, but the top one is just basic Haskell code, and the bottom one is a well-known technique too
13:52:32 <sereven> gwern: yes
13:52:37 <gwern> drat
13:52:39 <Toxaris> Ezla: the interesting point is just to call visit visit instead of fold
13:52:42 <Ezla> Where are Haskell well known techniques collected?
13:52:54 <Ezla> How do I dig up all the Haskell idioms?
13:52:57 <jkff> In the wiki
13:53:00 <Toxaris> Ezla: to highlight the similarity to OO's visitor pattern
13:53:17 <jkff> For example, http://www.haskell.org/haskellwiki/Performance has a lot about performance
13:53:28 <jkff> And http://www.haskell.org/haskellwiki/Category:Idioms has a lot about idioms
13:53:29 <Toxaris> Ezla: haskell wiki, research papers, collective mind of haskell-cafe@haskell.org and #haskell
13:53:38 <Ezla> im concerned about Software design overall
13:54:13 <Toxaris> Ezla: unfortunately (imho), many people here don't like the notion of design patterns, so stuff is often not explained in similar terms to how similiar stuff is explained for OO languages
13:54:30 <Ezla> but it's great Toxaris
13:54:30 <jkff> Ah, good old design patterns. Let me find the paper.....
13:54:35 <Ezla> I thinkt hey're being reactionary
13:54:39 <pumpkin_> Ezla: heh
13:54:41 <Ezla> Because of some kind of OO trauma
13:54:59 <Ezla> whereas your example is helpful and steps aside from pedagogical reactions
13:55:09 <Ezla> and thats what the patterns are supposed to truly be
13:55:25 <Toxaris> Ezla: actually, I don't see a point in "translating" most OO design patterns, but we should have our own, explained in similiar words
13:55:48 <Toxaris> visitor is an example, because it actually shows up in FP, but one should call it fold, because, well, that's our word for it
13:55:50 <zooko> Oops, just copying stage2-inplace/ghc and stage2-inplace/libexec doesn't seem to be sufficient.
13:55:54 <zooko> $ ghc --version
13:55:55 <zooko> exec: 3: /home/zooko/playground/ghc/ghc-6.10.1/ghc/stage2-inplace/libexec/ghc: not found
13:56:03 <Ezla> and that's what glguy was saying
13:56:08 <Toxaris> no, visitor is a *counter*-example, because it should be translated, unlike many others
13:56:10 <Ezla> at the start
13:56:40 <Ezla> he told me fold but I didnt see it cause I was thinking about the functionclassing
13:57:01 <Ezla> How about "observer" ?
13:57:22 <Toxaris> well, as I said somewhere above, I see it very loosely connected to FRP
13:57:28 <Toxaris> (functional reactive programming)
13:57:44 <Ezla> FRP is similar to signals?
13:58:23 <Toxaris> yeah, somehow. the trick being that FRP is declarative, not imperative
13:58:32 <Ezla> hmm
13:58:39 <Ezla> can Yampa do thread safe reactions?
13:59:08 <Toxaris> but I haven't looked at it, so I cannot answer detailed questions. Its on my read-about-it-and-try-it-out list, however, so ask me in two years :)
13:59:21 <Ezla> ye olde stack
13:59:54 <Ezla> 2 years when you finally pop
14:00:29 <pumpkin> Ezla: in the traditional sense of threadsafe, I'd assume so
14:00:38 <Ezla> heh
14:00:42 <Ezla> what's the nontraditional sense?
14:01:44 <pumpkin> well, I just mean that since people don't typically program statefully, you don't run into typical issues with global variables being mangled by multiple threads without locks
14:02:00 <pumpkin> having said that, I've never touched yampa :)
14:02:06 <Ezla> However
14:02:12 <Ezla> Signal tends to create a graph
14:02:16 * zooko sighs.
14:02:47 <Ezla> Not having things hard bound to a global
14:02:56 <Ezla> but nonetheless a loose graph connection
14:03:33 <Ezla> it's inherently unthreadsafe without some extra work
14:03:54 <pumpkin> you mean in terms of resource contention?
14:04:21 <Ezla> that's possible
14:04:58 <Ezla> in C++ it wasnt even easy to get Signal to be threadsafe in and of itself
14:05:03 <Ezla> they only figured that out... last month
14:05:12 <Ezla> re: boost anyways
14:05:39 <pumpkin> I think conal knows the most about FRP around here, but I may be wrong :) I'm definitely not an expert by any means, though
14:06:39 <Ezla> isn't Conal the guy who organized the protest against FRP
14:07:31 <Ezla> Thanks for help, bbl ;)
14:07:36 <Toxaris> I was under the impression that conal is the guy who organized FRP
14:08:01 <roconnor> The FRP is a terrorist organization!
14:08:13 <roconnor> :P
14:08:34 <Ezla> I need help with something really basic
14:08:48 <Ezla> when you have a Typeclass
14:09:20 <Toxaris> roconnor: oh, didn't know, should I?
14:09:38 <Ezla> and a set of types of that Typeclass... Each of the types adheres to the interface --- and you have a list values of Typeclass foo
14:09:48 <Ezla> do the type Instances get "erased"
14:09:51 <roconnor> Toxaris: I'm probably confusing them with the FLQ
14:09:51 <Ezla> inside that list?
14:10:21 <Ezla> if the List is constrained to typeclass whatever
14:10:27 <Ezla> you never lose the type of the elements?
14:10:31 <ahmad1nejad> is there some good primer to threads in haskell
14:10:43 <JohnnyL> C:\downlow\sl.hi:1:0: lexical error (UTF-8 decoding error)
14:10:45 <pumpkin> Ezla: I'm not sure I understand... can you give a snippet in haskell?
14:10:50 <conal> Ezla: i'm glad to see you back here.  i wanted to pass on a reference for you learn what frp is about: http://conal.net/fran/tutorial.htm
14:10:54 <Toxaris> Ezla: you never lose the types of the elements, because you cannot but elements of different types into a list, even if these types are instances of the same typeclass
14:11:00 <Toxaris> s/but/put
14:11:14 <Ezla> conal: thx
14:11:18 <ahmad1nejad> frp is very simple
14:11:26 <conal> :)
14:11:26 <ahmad1nejad> deceptively so
14:11:27 <Ezla> conal: can FRP reactions be threadsafe?
14:11:47 <Ezla> Toxaris: how do you do what I wanted then?
14:11:47 <conal> yes
14:11:51 <Ezla> a polymorphic list
14:11:56 <dons> ahmad1nejad: RWH?
14:12:04 <dons> see the parallelism and concurrency chapter
14:12:08 <mauke> Ezla: you could make an existential wrapper
14:12:10 <pumpkin> Ezla: you can do it, but you probably don't want to (with existential types, I think)
14:12:19 <Ezla> an existential type?
14:12:19 * ahmad1nejad looks
14:12:36 <Toxaris> Ezla: for a finite and small number of different options, you can create a data type: data Everything = SomeOption Type1 | OtherOption Type2 | SomeThingElse Type3 ...
14:12:36 <Ezla> pumpkin: Why don't I want to?
14:12:47 <dons> particular focus on multicore in RWH, fwiw.
14:13:00 <pumpkin> Ezla: because you can't do much with the contents of the list, as far as I know, once you do that (at least not easily)
14:13:09 <Ezla> That was my original question
14:13:12 <Toxaris> Ezla: for a larger collection, or when you want to add things later, you can use a so-called existentiel wrapper: data Wrapper = MyTypeClass a => Wrapper a
14:13:16 <Ezla> are the unique types lost
14:13:21 <pumpkin> they aren't lost
14:13:39 <conal> Ezla: everything in FRP is thread-safe.  it's purely functional.
14:13:44 <byorgey> pumpkin: you can do as much with the contents of the list as you allow with whatever type class you want to use.
14:13:50 <Ezla> conal: ok.
14:13:54 <Ezla> Toxaris: thats like a linked list of data defs?
14:13:54 <Toxaris> Ezla: in the first case, the types are not lost (you pattern match to find out which one it is), in the second case, the types are lost (the only information about the element of Wrapper you have is that its type support MyTypeClass)
14:13:55 <pumpkin> byorgey: ah, okay
14:14:44 <Ezla> Toxaris: so given the "lost types", how do you implement a polymorphic function?
14:14:54 <Ezla> on those types typeclass Instance
14:15:11 <jkff> :t Data.Array.accumArray
14:15:12 <lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
14:15:13 <Toxaris> Ezla: you have to put all operations you need to use in the typeclass
14:15:21 <Ezla> yes thats fine
14:15:25 <Ezla> but
14:15:30 <Ezla> how to make it polymorphic?
14:15:37 <mauke> Ezla: how do you make it not polymorphic?
14:15:38 <ahmad1nejad> is it possible that i'm the first person to ever BOTH a) learn haskell b) play in a grindcore band
14:15:42 <Ezla> It already is, I know
14:15:43 <Ezla> but
14:15:49 <Ezla> there's no Extra care needed here
14:15:52 <Ezla> it just works
14:15:58 <Ezla> In the existential types example
14:15:59 <Ezla>  ?
14:16:10 <Ezla> because you arent actually doing anything odd
14:16:15 <Ezla> only the name is odd
14:16:22 <JohnnyL> http://nopaste.com/p/a26SyyzCY
14:16:27 <pumpkin> ahmad1nejad: it is possible :P but given over 500 people in here, it's hard to say for sure ;)
14:16:31 <Toxaris> Ezla: well, the concept of existential types *is* odd, but since you have it in OO, too, it doesn't feel odd :)
14:16:32 <Philippa__> pretty much. You have to put it in and out of the existential "box" type but that's it
14:16:46 <mauke> Philippa__: you could also make the wrapper an instance
14:17:04 <Toxaris> Ezla: they just don't talk about in OO, so you never realizes how odd it is, but of course, everything in OO is existential, because you never know which type you have (it could always be a subtype)
14:17:24 <Toxaris> existential means: there is a type, but you don't know which
14:17:30 <Ezla> that's interesting you call it existential
14:17:41 <Philippa__> because it corresponds to an existential quantifier in logic
14:17:46 <Ezla> The values cannot ponder their own existence? :P
14:18:33 * ahmad1nejad smacks his head
14:18:35 <pumpkin> it's more of the ∀∃ kind :P
14:18:38 <ahmad1nejad> awful
14:18:39 <Ezla> Toxaris. what is the interface for appending stuff to the wrapper lists?
14:18:47 <Ezla> can be anything
14:18:51 <mauke> ++
14:18:55 <Toxaris> Ezla: oh, the list is just a list
14:18:57 <Ezla> well I mean
14:19:01 <Ezla> not in the cast of list
14:19:02 <Toxaris> [Wrapper]
14:19:04 <Ezla> for all stuff besides list
14:19:13 <Toxaris> or Data.Map String Wrapper
14:19:14 <Ezla> like some Memory optimized structure
14:19:16 <Toxaris> or whatever you want
14:19:20 <pumpkin> you treat it like anything else, wrap it up and stick it in
14:19:20 <Ezla> which would still just boil down to lists eh?
14:19:30 <pumpkin> lol, that sounded bad
14:19:32 <Ezla> How do I get contiguous memory in Haskell?
14:19:39 <Ezla> No linked list
14:19:41 <Philippa__> mostly, you don't bother trying
14:19:46 <Philippa__> there are array types
14:19:47 <dons> Ezla: with one of the Foreign.Array.* interfaces? you want a Ptr ?
14:19:48 <Ezla> How do I get O(1) push?
14:19:57 <dons> Ezla: or just a mutable array? i.e. STUArray Int Int ?
14:20:02 <Philippa__> you /have/ O(1) push
14:20:03 <pumpkin> Ezla: if you mean push, you can use a list as a stack
14:20:10 <pumpkin> with no extra effort
14:20:14 <Toxaris> Ezla: you cannot easily have polymorphism (that means: values of different sizes are treated the same) *and* contiguous data blocks at the same time
14:20:17 <Ezla> push_back
14:20:19 <Ezla> not front
14:20:20 <Philippa__> allocations are constant time with a generational GC
14:20:21 <Ezla> not head
14:20:23 <pumpkin> Ezla: Sequence
14:20:25 <luite_> Ezla: Data.Sequence
14:20:32 <Ezla> Sequence does that in O(1) ?
14:20:33 <luite_> but it's not exactly O(1) I think
14:20:34 <Toxaris> Ezla: if you really want that, you need to write your own serialization function or something like that -- in every language, I think
14:20:35 <luite_> but close
14:20:41 <Philippa__> Ezla: amortised O(1), yeah
14:20:47 <Ezla> OK so
14:21:03 <Ezla> Data.Sequence -> how to use it with my existential type?
14:21:09 <Ezla> a sequence of existentials
14:21:16 <Philippa__> again, same as you use it with anything
14:21:17 <pumpkin> you make a sequence of the existential wrapper
14:21:17 <Toxaris> Ezla: but you can have an array of pointers to your Wrapper values, just like Object[] in Java is an array of pointers to instances of possibly different classes
14:21:24 <Ezla> pumpkin: cool
14:21:25 <mlesniak> Hi, I'm interested in your opinion of classical papers of functional programming, i.e. those which you'd say are the top 3 you have to read. Any suggestions welcome :)
14:22:01 <Ezla> How does sequence implement literal storage?
14:22:14 <Ezla> it cant use lists
14:22:21 <pumpkin> a 2-3 finger tree, apparently :P
14:22:28 <Philippa__> Ezla: that's a bit complicated. It's a really smart structure under the surface, there's a research paper somewhere
14:22:45 <Philippa__> (I saw ~half a talk on it at the london HUG a while back)
14:22:51 <pumpkin> Ezla: the doc page on Data.Sequence gives you time complexities for each operation
14:23:00 <Ezla> does any haskell sequence type use contiguous memory?
14:23:07 <Ezla> pumpkin: k
14:23:11 <luite_> Ezla: no, in general not
14:23:18 <Ezla> why not?
14:23:25 <ahmad1nejad> ok, best haskell IDE/something that isn't emacs?
14:23:30 <Philippa__> because you can never tell if you did or not
14:23:31 <ahmad1nejad> i'm just using vi right now
14:23:40 <Philippa__> thinnk about it: how would a pure function know?
14:23:59 <Ezla> Philippa__: but can't it be....
14:24:02 <Ezla> an IO
14:24:10 <Ezla> wrapped in a Functional interface
14:24:10 <pumpkin> Ezla: the idea of FP is to be divorced from the underlying architecture and computation model (or one of the ideas, anyway)
14:24:24 <pumpkin> Ezla: at least that's what it seems
14:24:25 <ahmad1nejad> ideally, something with tab completition and autoindent, at the very least?
14:24:32 <ahmad1nejad> completion
14:24:54 <mlesniak> ahmad1nejad: vim with SnippetsEmu is quite nice
14:24:54 <Philippa__> Ezla: if you don't mind that you'd be copying arrays left, right and centre
14:25:00 <Philippa__> you don't actually want that structure
14:25:07 <Ezla> left right and center?
14:25:08 <Philippa__> there /are/ IO arrays, and arrays in ST
14:25:09 <Ezla> why?
14:25:13 * arw uses vim. if you really need something more complicated the libs are unusable imho.
14:25:18 <arw> see java for example :)
14:25:29 <gwern> ahmad1nejad: visual haskell, vim, and yi
14:25:32 <Philippa__> what happens when you "update" an array? Well, the old version could be live still
14:25:36 <Ezla> is Ahmad on windows?
14:25:47 <luite_> Philippa__: you can't
14:26:00 <Philippa__> luite_: "quotes" for a reason :-)
14:26:04 <luite_> Philippa__: unless you use one of the special types, that live in a monad or DiffArray
14:26:08 <luite_> oh
14:26:27 <daf> contiguous arrays are only O(1) only if realloc is O(1)
14:26:37 <luite_> Philippa__: oh I see now that you were explaining it to Ezla, sorry :)
14:26:45 <daf> which I very much doubt it is
14:27:20 <mlesniak> gwern: is yi usable?
14:27:24 <Philippa__> daf: extending the array isn't normally the operation people're worried about
14:27:28 <sbahra> It could be, if you're very very very lucky :-P
14:27:31 <gwern> mlesniak: relatively
14:27:31 <Ezla> can a single haskellbot example show why you can't update an IO array?
14:27:37 <mlesniak> gwern: define this ;)
14:27:48 <luite_> Ezla: no, because you can't use arrays with lambdabot :(
14:27:49 <Philippa__> Ezla: those you can. You just can't then call them pure
14:27:50 <sbahra> And are located right across a page boundary (and frame is mapped).
14:27:56 <daf> Philippa__: oh, what is it?
14:27:56 <Philippa__> and lambdabot won't do IO
14:27:58 <gwern> mlesniak: its haskell-mode is on par with emacs haskell-mode or better, but you need to assign keybindings yourself
14:28:05 <sbahra> luite_, why can't you do arrays?
14:28:07 <Ezla> Can't call them Pure?
14:28:08 <daf> Philippa__: I was under the impression that that was what Ezla was worried about, anyway
14:28:11 <Philippa__> daf: reads, in-place updates
14:28:13 <Ezla> what does "calling them" mean
14:28:15 <Philonous> in "all about monads" the writer monad is defined as "newtype Writer w a = Writer { runWriter :: (a,w) }" but runWriter is later used as a function, is this an error or am I missing something?
14:28:16 <luite_> sbahra: it thinks they're unsafe
14:28:21 <sbahra> Are they?
14:28:27 <mlesniak> gwern: that sounds not too bad, will give it a try tomorrow
14:28:28 <luite_> > fromList (1,10) [1..10]
14:28:28 <Philippa__> you're assuming that there's no max stack size :-)
14:28:29 <lambdabot>   Not in scope: `fromList'
14:28:29 * sbahra hasn't used arrays yet
14:28:35 <luite_> euh
14:28:37 <Botje> Philonous: that's an oddity of haskell record syntax
14:28:41 <luite_> wait that was not the right function
14:28:47 <Botje> Philonous: you can define a record Foo { bar :: String, baz :: Int }
14:28:48 <luite_> > listArray (1,10) [1..10]
14:28:49 <lambdabot>   array (1,10) [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
14:28:52 <Ezla> No max stack size? No I assumed you'd allocate contiguous memory on the heap!
14:28:52 <Botje> and then bar :: Foo -> String
14:28:53 <luite_> oh it does work here
14:29:02 <Philippa__> Ezla: IO operations can't be used in pure code
14:29:18 <Ezla> is do { -- not pure?
14:29:20 <Botje> Philonous: so it means runWriter :: Writer w a -> (a,w)
14:29:25 <Philippa__> yep
14:29:32 <daf> Ezla: do {} does not imply IO
14:29:33 <Philippa__> well, it's more complicated than that
14:29:33 <Ezla> What else isnt pure besides do ?
14:29:45 <Botje> Ezla: IO is not pure. other monads are.
14:29:47 <luite_> sbahra: ok, so it does support the regular non-IO arrays, which are not unsafe
14:30:05 <Ezla> More complicated how?
14:30:11 <Philippa__> Ezla: do itself is just syntactic sugar, and you can view the IO monad as pure right up until you try to run the program...
14:30:26 <Philippa__> this is the part of haskell that tends to confuse people most, btw
14:30:27 <pumpkin> Ezla: it's not that do isn't pure, it's IO that isn't... do is just syntactic sugar for a couple of monad operations
14:30:36 <Philippa__> and Monad is just a typeclass
14:30:48 <ahmad1nejad> phillipa: what is, the IO monad?
14:31:01 <pumpkin> ahmad1nejad: it's how you speak to the outside world
14:31:07 <Philippa__> ahmad1nejad: monads as a whole, partly because the IO monad is a really weird example
14:31:07 <ahmad1nejad> no, no
14:31:09 <ahmad1nejad> the coma
14:31:14 <ahmad1nejad> comma*, look at the comma ;)
14:31:28 <pumpkin> oh :P
14:31:32 <luite_> sbahra: I have my own lambdabot on another network, and apparently the default configuration is not to accept the listArray example, but I'm not sure why
14:31:35 <Ezla> syntactic sugar for a chain of actions as interfaces of the Monad, and adhering to the >>=, <<, result protocol in order to build an sexpr of functions for passing state in a procedural way, and resulting in a single Monad, which can work with the IO op
14:31:59 <Ezla> s/result/return
14:32:01 <mauke> yes, except without sexpr or passing state
14:32:04 <JohnnyL> are there templated in haskell?
14:32:07 <JohnnyL> are there templates in haskell?
14:32:13 <sbahra> JohnnyL, Template Haskell
14:32:14 <pumpkin> JohnnyL: there's template haskell :)
14:32:16 <JohnnyL> ok
14:32:16 <Ezla> mauke: "simulation" of passing state
14:32:23 <mauke> Ezla: no
14:32:27 <Philippa__> JohnnyL: There are actually two separations
14:32:28 <Ezla> explain?
14:32:41 <Ezla> I only mean from a procedural viewpoint
14:32:44 <Ezla> not literally
14:32:48 <Ezla> since the Monad hides it
14:32:50 <mauke> Ezla: newtype Id a = Id a; is a monad
14:32:51 <Philippa__> Ezla: the IO monad "builds" programs, and then they're run. They're impure as all hell
14:32:57 <mauke> Ezla: what hidden state is there?
14:33:07 <Philippa__> the IO monad can happily format your HD, that's no simulation
14:33:17 <Philonous> Botje: Ah, does that mean that the field names in records act as selector functions?
14:33:28 <Botje> yeah
14:33:31 <ahmad1nejad> ok, so let me get this straight
14:33:33 <Ezla> and that's what I meant by state, Philippa
14:33:33 <ahmad1nejad> happs and the like
14:33:36 <Ezla> but mauke says no ?
14:33:42 <Philonous> That even makes sense, thank you.
14:33:44 <Ezla> mauke: None there, I guess
14:33:46 <ahmad1nejad> they all work by sending output out through the IO monad
14:33:51 <ahmad1nejad> which FCGI or something intercepts?
14:33:52 <Philippa__> most monads are entirely pure
14:33:53 <Ezla> except the  fact that
14:34:00 <Ezla> "constancy" is a state itself
14:34:06 <mauke> I think people should stop talking about "the IO monad"
14:34:09 <Ezla> immutable state
14:34:14 <ahmad1nejad> ok, a function with type IO
14:34:15 <Ezla> why?
14:34:17 <Philippa__> that's word games
14:34:17 <mauke> it's IO that's magic, not the monadic parts
14:34:50 <conal> mauke: exactly!
14:34:58 <conal> call it "the IO type" or just "IO"
14:34:59 <Philippa__> Ezla: you're playing word games there :-)
14:35:01 <daf> Ezla: the state is the real world; it's not something you can pass
14:35:08 <Ezla> Philippa__: Roger
14:35:26 <Philippa__> daf: erm. Actually, that's /exactly/ one model of IO :-)
14:35:35 <Ezla> programming *is* a word game ;)
14:35:40 <ahmad1nejad> ezla++
14:35:45 <Philippa__> however, I don't want to see the computer that can actually implement it that way
14:36:23 <daf> well, I was trying to say that you can't actually represent all the state that you can modify
14:36:29 <Toxaris> One can imagine IO as a datatype which describes programs. Such programs are looked at, and evaluated, by the runtime system, which is written in c, impure, and allowed to do whatever it does. So you (pure) haskell program creates a description of an impure IO program which is interpreted by the runtime system to do bad things (or hopefully, only good ones)
14:36:30 <dibblego> I tihnk "the IO type constructor" since I find calling it a type leads to confusion
14:36:42 <Toxaris> of course, all of that happens at once due to laziness
14:36:58 <ahmad1nejad> i don't think about programming in english
14:37:07 <ahmad1nejad> in fact i think that's most people's biggest obstacle
14:37:18 <ahmad1nejad> i think about programs strictly in terms of discrete functionality
14:37:20 <Ezla> since there's no state in haskell, what does GHC do to avoid the overhead of endless copies? If I just splice a list and insert an element, but do not wish for the overhead of a whole list copy. It doesn't matter in the first place since !! would only check lazily?
14:37:21 <daf> well, I think that understanding that IO is a type that has no public constructor can be helpful
14:37:35 <Philippa__> Ezla: it just GCs the dead ones
14:37:46 <Ezla> Well the GC isnt the issue, I mean,
14:37:53 <Ezla> How are the copies avoided
14:37:55 <dibblego> Ezla, consider inserting an element at the start of the list; since the list has no state, it can reuse the old one
14:37:57 <Philippa__> it /just/ GCs the dead ones :-)
14:38:02 <Ezla> I have a 10,000 element list, and its immutable
14:38:05 <dolio> If you don't want copy overhead for inserting in the middle, you shouldn't use a list.
14:38:09 <Ezla> I change 1 element
14:38:10 <daf> Philippa__: are you still in Cambridge, by the way? I'm wondering if there's critical mass for a Haskell Curry at some point
14:38:11 <Ezla> I do not want a copy
14:38:32 <Philippa__> daf: I never was except for a day or two at a time. I'm in Nottingham
14:38:37 <mauke> Ezla: you can't change an element
14:38:43 <Ezla> mauke: I know
14:38:47 <Ezla> but I can make a new list
14:38:48 <daf> Philippa__: ah, for some reason I thought you were
14:38:59 <Cale> Ezla: If you change an element near the beginning, the tails are shared.
14:39:09 <Ezla> constructed [0..n]++[x]++[m..]
14:39:10 <Ezla> however
14:39:15 <Cale> Ezla: But the heads are not. Lists are a bad structure if you want to do many random updates.
14:39:16 <Ezla> I don't want that overhead
14:39:20 <Ezla> so how does GHC avoid it
14:39:21 <Heffalump> daf: in principle I'm interested in a Haskell curry though in practice I won't be available for one for a couple of months at least
14:39:23 <Philippa__> don't use a list, then
14:39:27 <Philippa__> GHC doesn't avoid it
14:39:31 <daf> Heffalump: sure, I understand :)
14:39:33 <Cale> Ezla: It doesn't avoid it. You're just using the wrong datastructure then.
14:39:47 <daf> Heffalump: I don't suppose you've any leads for potential HUG speakers?
14:39:52 <Toxaris> Ezla: GHC will not avoid that overhead for you, you have to avoid it yourself. Just as in every other language, if you don't want a linked immutable list, don't use one :)
14:39:54 <Cale> There's Data.Sequence which supports O(log n) updates/splitting/access
14:40:04 <Cale> and is immutable
14:40:10 <Cale> (but can't be infinite)
14:40:24 <Heffalump> Lennart has something tutorial-y lined up which we'll probably do in January. Nothing else, but when I get some time and energy I'll do a bit more prodding to see what can be found.
14:40:27 <Cale> It doesn't make quite as efficient a structure for representing loops though.
14:40:54 <sm> conal, a quick question ? thanks for your (exciting, hard to keep up with) string of FRP libs. Which of them might be useful for apps with curses-style ui ?
14:40:56 <Ezla> Good for loops, but does it have an Unpainful syntax ?
14:41:02 <Ezla> [ ] is so unpainful
14:41:02 <Heffalump> I ought to arrange a pub-meet for December but it requires having a couple of people who'll guarantee to go, as I can't.
14:41:19 * Heffalump disappears
14:41:24 <daf> Heffalump: I might be away for much of the spring, but in principle I think wjt and I are happy to take on some organizing
14:41:25 <Cale> Ezla: Well, you can turn a list into a Data.Sequence using fromList
14:41:27 <Ezla> Can Data.Sequence be wielded via operators?
14:41:32 <Ezla> to emulate something like []
14:41:48 <Cale> There are a number of operations to manipulate them...
14:41:55 <Ezla> Cale: But, you might not want the initial turning-into cost
14:42:04 * Heffalump undisappears again for a bit
14:42:09 <Cale> Well, of course, there are other ways to build them.
14:42:13 <Heffalump> daf: oh, that'd be good, thanks!
14:42:17 <Philippa__> daf: if it helps any, my parents live the other end of cambs
14:42:18 <conal> sm: :).  curses -- hm.  i've never thought about it.  Reactive would probably be the best fit.  Someone would have to build an adapter to hide the imperative nature of curses.
14:42:31 <daf> Philippa__: would they be interested in a Haskell curry?
14:42:35 <Heffalump> Philippa__: which end is that? The south?
14:42:40 <sm> oh, dons was talking about that
14:42:49 <sm> I see what you mean
14:42:49 <Philippa__> daf: one of these days my dad might
14:42:58 <Philippa__> Heffalump: they're just outside P'boro
14:43:05 <daf> Philippa__: then that does help ;)
14:43:09 <Heffalump> ah, right
14:43:19 * Heffalump lives in St Neots now
14:43:28 <Ezla> So is 'do' itself impure, or is 'do' only impure given what people usually use it fr
14:43:30 <Ezla> for
14:43:31 <sm> I'm using vty which is also imperative. Reactive then, good to know, thanks
14:43:34 <mauke> Ezla: neither
14:43:38 <mauke> 'do' is completely pure
14:43:39 <daf> Ezla: do itself is not impure
14:43:42 <Cale> Ezla: Only the IO monad is really impure.
14:43:45 <Ezla> k
14:43:57 <daf> do is just synax sugar for >>= and >>
14:44:00 <pumpkin> > liftM2 (+) [1,2,3] [2,3,4] -- liftM2 is implemented with a do, but I'm not doing anything impure
14:44:02 <lambdabot>   [3,4,5,4,5,6,5,6,7]
14:44:04 <Heffalump> do is just a means of propagating existing impurity in a convenient way
14:44:20 <Ezla> isnt it >>= and <<  ?
14:44:22 <Cale> Heffalump: If any...
14:44:22 <pumpkin> @src liftM2
14:44:23 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
14:44:29 <daf> @src (<<)
14:44:29 <lambdabot> Source not found. Where did you learn to type?
14:44:44 <Cale> @undo do { x1 <- m1; x2 <- m2; return (f x1 x2) }
14:44:44 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
14:44:46 <pumpkin> Ezla: yes, pretty much
14:45:02 <daf> Ezla: (>>) is a member of the Monad class; (<<) is just a backwards version
14:45:15 <Ezla> oh,
14:45:18 <daf> wait, no it isn't
14:45:19 <glguy> << isn't defined to match >> in the Prelude
14:45:20 <Ezla> that's not automatic is it?
14:45:26 <daf> I'm thinking of =<<
14:45:26 <Ezla> where did >> become <<
14:45:28 <daf> >> doesn't exist
14:45:31 <glguy> << is used in the xhtml library though :)
14:45:32 <daf> er, << doesn't
14:45:37 <Heffalump> =<< does though
14:45:47 <daf> @src (=<<)
14:45:47 <lambdabot> f =<< x = x >>= f
14:45:48 <glguy> =<< it monadic function application
14:45:52 <glguy> makes code look pretty
14:45:52 <Ezla> does Haskell do any automatic operator generation
14:46:00 <Cale> Ezla: nope
14:46:00 <daf> <3 palindromic definitions
14:46:09 <Ezla> where it maps ->>- to -<<- or whatever
14:46:11 <Cale> You have to define them all yourself.
14:46:16 <Ezla> k
14:46:32 <Ezla> can I have a <3 operator?
14:46:34 <Ezla> lol
14:46:37 <Ezla> no :(
14:46:38 <daf> sadly not
14:46:47 <daf> you can't use numbers in operator names
14:46:47 <Cale> But you can have...
14:46:47 <pumpkin> you can have certain smiley faces though :)
14:46:49 <Cale> :t (<3)
14:46:51 <lambdabot> forall a. (Ord a, Num a) => a -> Bool
14:46:52 <daf> perhaps you could have ♥
14:47:03 <Cale> > (<3) 5
14:47:04 <lambdabot>   False
14:47:09 <Heffalump> we use ? as an operator at work
14:47:10 <Cale> > (<3) 0
14:47:12 <lambdabot>   True
14:47:16 <Heffalump> (for an overloaded if-then-else)
14:47:16 <Ezla> Are there any freaks out there writing UNICODE RICH haskell?
14:47:29 <daf> > let ♥ = (+) in 3 ♥ 5
14:47:30 <lambdabot>   <no location info>: parse error on input `♥'
14:47:32 <Ezla> aw
14:47:33 <daf> aww
14:47:48 <Heffalump> let (?) = (+) in 3 ? 5
14:47:49 <Heffalump> > let (?) = (+) in 3 ? 5
14:47:51 <lambdabot>   8
14:48:11 <ahmad1nejad> what are you guys doing over there
14:48:18 <daf> > let (♥) = (+) in 3 ♥ 5
14:48:19 <lambdabot>   8
14:48:22 <daf> excellent
14:48:23 <Ezla> wow
14:48:29 <Heffalump> over where?
14:48:38 <ahmad1nejad> above when i wrote "what are you guys doing over there"
14:48:42 <pumpkin> lol
14:48:43 <Cale> (♥) = (+)
14:48:43 <Cale> x = 3 ♥ 5
14:48:46 <Cale> works in a file
14:48:49 <Heffalump> testing the use of ? as an operator
14:48:51 <pumpkin> it works in lambdabot too
14:48:58 <Ezla> that's awesome
14:49:00 <Heffalump> although I know for certain it works, due to the above mentioned reasons :-)
14:49:03 <ahmad1nejad> please don't use ? as an operator
14:49:11 <ahmad1nejad> unless it does something like the ? boxes in mario
14:49:16 <arw> why not?
14:49:17 <Ezla> for programming in Haskell
14:49:18 <pumpkin> someone approximated the ternary operator in haskell didn't they?
14:49:19 <Ezla> get one of these
14:49:20 <Ezla> http://www.xkeys.com/xkeys/xkpro.php
14:49:33 <bjrn> That unicode character is a good name for a function that checks if two numbers are friendly or amicable :)
14:49:33 <Heffalump> pumpkin: the problem is that : is already taken
14:49:36 <Ezla> with symbols on each
14:49:41 <Heffalump> what we do is just use a tuple for the second argument to ?
14:49:45 <pumpkin> Heffalump: yeah, they used something else
14:49:52 <daf> they used $ for :
14:49:53 <pumpkin> ah
14:50:08 <daf> as in; they didn't use a special operator
14:50:11 <Heffalump> you could use any operator you like, really, you just need to make it do something simple like building a tuple
14:51:49 <daf> ah yes, it was:
14:52:04 <Ezla> Am I missing something, with being annoyed by the data definitions syntax making it unclear that in a list of types, only the first one will be the type instance?
14:52:05 <daf> a ? b = if a then const b else id
14:52:21 <Ezla> there's no operator separating it
14:52:46 <daf> what do you mean by a list of types?
14:53:34 <Philippa__> Ezla: y'mean, the first item always being the constructor but not being marked by anything but being first?
14:53:41 <Ezla> yep
14:53:43 <Ezla> exactly
14:53:45 <Philippa__> it matches the syntax for using the constructor
14:53:52 <Ezla> ah
14:54:02 <Ezla> that makes sense
14:54:17 <Philippa__> Foo Int String, Foo 42 "bar"
14:54:52 <Cale> If you really don't like it, there's a new GADT syntax for defining types which would look like:
14:54:57 <Cale> data MyType where
14:55:04 <Cale>   Foo :: Int -> String -> MyType
14:55:26 <Ezla> Cale: lol? Isnt that way better?
14:55:36 <Cale> It is nicer, and more general.
14:55:46 <Cale> But it only works in GHC.
14:55:55 <Ezla> The 'data' looks like they didnt understand the best solution yet
14:56:04 <Ezla> feels wrong somehow
14:56:11 <Philippa__> eh, for what it covers it's right
14:56:22 <Philippa__> it just wasn't designed for the extensions that followedd
14:56:25 <Ezla> GADT ?
14:56:36 <Cale> Generalised Algebraic Data Type
14:56:41 <Ezla> ok
14:57:06 <Heffalump> the H98 syntax is nice and compact
14:57:16 <Heffalump> which is a significant advantage
14:57:25 <Cale> This new syntax allows you to write things which are quite tricky for a compiler to deal with, but they have worked out the details.
14:57:29 <Ezla> Are there any very cobwebby syntax features?
14:57:30 <Philippa__> and the | does help highlight the fact they're alternatives
14:57:37 <Cale> For example, you can write things like
14:57:41 <Ezla> I think the data one will become cobwebby for me personally
14:57:45 <Cale> data Expr a where
14:57:54 <Cale>   Const :: Integer -> Expr Integer
14:57:56 <Heffalump> ezla: the layout rule is kind of tricky
14:58:07 <Ezla> layout rule? tabs?
14:58:08 <Cale>   IsZero :: Expr Integer -> Expr Bool
14:58:09 <Heffalump> as is the precedence of record update notation
14:58:10 <Ezla> what do you mean
14:58:18 <Heffalump> the fact that indentation is significant
14:58:37 <ahmad1nejad> what's the haskell equivalent of (load "file.hs")
14:58:56 <Ezla> Cale: was that special because 'a' applied universally?
14:59:03 <Cale> ahmad1nejad: You mean for importing a module into another module, or loading it in ghci?
14:59:09 <ahmad1nejad> loading it into ghci
14:59:16 <Cale> ahmad1nejad:  :l file.hs
14:59:21 <ahmad1nejad> nice
14:59:21 <ahmad1nejad> ok
14:59:23 <Philippa__> yeah, the layout rule's a bitch if you have to write a parser
14:59:25 * Heffalump disappears
14:59:43 <Ezla> what was the tricky part
14:59:52 <Cale> Ezla: Yeah, so for instance, here, Const only builds Expr Integer values
15:00:05 <Cale> Ezla: Which is not something you could do with the old syntax.
15:00:41 <Botje> Philippa__: count leading whitespace and group lines by their whitespace count?
15:01:02 <Cale> This sort of lets you steal the Haskell type system for your own purposes.
15:01:13 <Cale> (you can write data types which are like typechecked languages)
15:01:20 <Ezla> Cale: like a dsel?
15:01:23 <Cale> yeah
15:01:42 <ahmad1nejad> hahah
15:01:43 <ahmad1nejad> http://en.wikibooks.org/wiki/Programming:Haskell_indentation
15:01:53 <ahmad1nejad> scroll down to "not valid Haskell", look at the <pre> below that
15:02:56 <Botje> :)
15:04:13 <Cale> I like how they qualified that with "probably"
15:04:24 <cpfr> hey in ghc how do i statically link in gmp and readline?
15:05:02 <Philippa__> Botje: there's more to it than that - read the report
15:05:22 <Philippa__> there's an "add a } if there'd be a parsing error without it" rule
15:05:35 <Botje> yeah
15:05:42 <Botje> i saw the rules just now
15:05:51 <Cale> cpfr: Is it really necessary? They're usually dynamically linked because of licensing issues that result from statically linking them.
15:06:09 <glguy> Freedom isn't free
15:06:32 <cpfr> Cale, i have a friend who i want to try out the binary, my software is gpl and its just so they dont have to install ghc
15:06:51 <glguy> cpfr, if you have him install readline and gmp he won't need to install ghc
15:06:55 <Cale> Oh, they won't have to install ghc, just those libraries.
15:07:04 <cpfr> glguy, he is on x64 im on x32
15:07:24 <daf> cpfr: shouldn't make a difference
15:07:27 <glguy> cpfr, then he'll need to install the i386 versions of those libraries
15:07:41 <arw> one thing i especially like about haskell is that layout is optional :)
15:07:50 * arw is one of those brace-using perverts
15:08:01 <Ezla> is template haskell "lifted above" the type system, or does it work with the type system?
15:08:27 <Ezla> for example,
15:08:41 <Ezla> if I wanted to generate N functions based upon the ordinal of an data being used as an Enum
15:08:47 <Cale> Ezla: The TH code is largely itself Haskell code, and the code resulting from the macros is typechecked.
15:08:58 <jsn> Ezla: yeah, it works with the type system
15:09:21 <cpfr> glguy, i wont rather just know how to statically link it
15:10:05 <mafo> cpfr: I've statically linked against gmp in the past, first you need a file libgmp.a
15:10:11 <Heffalump> ezla: you could do that
15:10:25 <Ezla> Cale: (infinity - largely) == what lets it do the magic? Or do the functions only "work like" they should, but aren't actually f x1 x2 x3 x4 = ...
15:10:36 <nzeh> Hi folks.  I have a weird problem writing some code using the Maybe monad.  I have two computations that should not fail, but otherwise I don't care about their output.  The third one is the one whose result I return if the first two succeed, like so:  comp1 >> comp2 >> return something.  When I try to compile this with ghc, it just hangs keeping my CPU 100% busy.  Any idea where this may come from?
15:10:57 <jsn> Ezla: why do you come in here, asking so many questions, trying to understand it with your mind?
15:10:59 <Ezla> sorry I guess  i-largely==the compiler hooks  is a bit abstract
15:11:08 <cpfr> mafo i have a libgmp.so but im sure i can make one
15:11:10 <mafo> cpfr : use ghc-v to see how ghc calls the linker
15:11:11 <Cale> jsn: Don't turn away valid questions.
15:11:11 <pumpkin_> nzeh: can you paste the broken piece of code?
15:11:17 <Ezla> Jsn: ?
15:11:22 * jsn was joking
15:11:33 * jsn apologizes if it wasn't funny
15:11:37 <nzeh> Here it is:
15:11:39 <nzeh> ((M.lookup tailid $ graphVertices graph) :: Maybe (Vertex vl eid)) >>
15:11:39 <nzeh>       ((M.lookup headid $ graphVertices graph) :: Maybe (Vertex vl eid)) >>
15:11:39 <nzeh>       return Graph { graphVertices = updatedVertexMap
15:11:39 <nzeh>                    , graphEdges    = M.insert id edge $ graphEdges graph
15:11:50 <pumpkin_> nzeh: I meant a paste service :)
15:11:50 <dibblego> nzeh, don't you mean comp1 >>= \something -> comp2 >> return something? also, you might want to post some code so we can see where the infinite loop is
15:11:58 <Cale> Ezla: TH code builds a Haskell syntax tree when executed, which is spliced in place.
15:12:04 <Ezla> Cale: Got it
15:12:08 <Ezla> perfect
15:12:13 <Heffalump> dibblego: using >> is equivalent to useing >>= \something -> and then not using something
15:12:33 <nzeh> pumpkin_:  What's a paste service?
15:12:37 <dibblego> Heffalump, right, but his description was not that
15:12:39 <mafo> cpfr : you meight have to recompile gmp from the sources to generate a libgmp.a
15:12:40 <Heffalump> http://hpaste.org
15:12:41 <pumpkin_> nzeh: something like http://hpaste.org
15:12:52 <Heffalump> dibblego: yse it was
15:12:55 <nzeh> Ah, thanks.
15:13:00 <Heffalump> or at least, in what way wasn't it?
15:13:02 <glguy> nzeh, that code is probably fine. also, rather than using lookup and ignoring part of the result, you can use Data.Map.member
15:13:08 <dibblego> Heffalump, I see
15:13:11 <cpfr> mafo, i figured as much
15:13:20 <Ezla> How do you make a single value of a certain type, then stop the type from ever being used to make a second value?
15:13:34 <Ezla> do globals matter in haskell?
15:13:35 <Cale> Ezla: data Foo = A
15:13:40 <nzeh> Thx, glguy:  Stupid me, didn't even think about that.  That should make it much cleaner.
15:13:54 <dibblego> Ezla, () is a once-inhabited type ignoring bottoms
15:13:55 <Heffalump> it'd still be good to track down the GHC problem though
15:14:09 <Ezla> dibblego: ?
15:14:25 <Cale> Ezla: If there's only one value of your type, then it might as well be the empty tuple.
15:14:30 <mafo> cpfr: then remove -lgmp from the linker command-line and append /usr/lib/libgmp.a
15:14:34 <Ezla> Cale: I see
15:14:43 <cpfr> thanks!
15:14:45 <Ezla> but
15:15:04 <Philippa__> Ezla: there are no singletons, if that's what you're after
15:15:04 <pumpkin_> Ezla: what what
15:15:10 <Ezla> how do I stop module B from coming and doing data Bar = A ?
15:15:13 <Cale> Ezla: You'll know before the program is even compiled what the value is.
15:15:22 <Philippa__> you don't, but it'll be a different A
15:15:22 <glguy> Ezla, you don't have to export the constructors
15:15:36 <Cale> Ezla: data declarations define closed types. You can't go and add new cases in future modules.
15:15:37 <Ezla> export the ctors?
15:15:51 <Ezla> Cale: what if I *wanted* to add more types
15:15:55 <Ezla> for extension
15:15:56 <Philippa__> yeah. If you don't export them, nothing outside the module can see them to use
15:16:00 <Ezla> and lack of centralized coupling
15:16:12 <Ezla> say I have a bunch of "Monsters"
15:16:16 <Ezla> in different modules each
15:16:17 <Cale> Ezla: Then you have to plan ahead, or define a completely new type and use that instead.
15:16:18 <dibblego> data C = CA A | New N
15:16:25 <Ezla> and I want them in the same data ctor
15:16:34 <jsn> Ezla: you can't add more consuctors later
15:16:35 <Philippa__> you can't have it. Best you can do it existentials
15:16:41 <Ezla> jsn: But what if I want to?
15:16:42 <ahmad1nejad> all flow control is just an abstraction of (sometimes multiparameter) piecewise functions :D
15:16:45 <Ezla> There's some other way
15:16:45 <ahmad1nejad> !:!:!:!
15:16:49 <glguy> typeclasses all you to add new types to the typeclass out of the module, data types allow you to add new functions on the type outside of the module
15:16:56 <jsn> Ezla: you can create a typeclass
15:16:57 <ahmad1nejad> yes?
15:17:04 <jethr0> Ezla: you can define a type class and make your constructors instances of that type class
15:17:04 <Cale> Ezla: Well, you think about what it is about those different monsters that they all have in common.
15:17:31 <Cale> Ezla: Then you can define a type which expresses that commonality, and a way to turn monsters into that.
15:17:39 <Cale> (individually)
15:17:42 <Ezla> Ok, then monster is a bad example
15:17:48 <Ezla> But there's other patterns
15:17:55 <Asgaroth> jethr0: Actually, you make the datatype an instance of the typeclass, not the constructors</nitpicking>
15:17:59 <Ezla> Where you'd want to keep extending the constructor
15:18:02 <Philippa__> that's what you do for everything. Sometimes, the interface includes "give me more info"
15:18:04 <pumpkin_> Ezla: really?
15:18:12 <jsn> Ezla: like?
15:18:13 <Philippa__> pumpkin_: really
15:18:18 <jethr0> Asgaroth: excuse my incorrectness
15:18:29 <Ezla> I do this in C++ with extern template specializations
15:18:35 <Philippa__> jsn: like every last good use case for extensible variants. If you're playing with ASTs enough, it happens
15:19:05 <jsn> Philippa__: extensible variants are also called extensible records?
15:19:14 <Philippa__> jsn: no, they're not
15:19:16 <Cale> jsn: They're closely related.
15:19:22 <jsn> ah
15:19:23 <Philippa__> but what Cale just said
15:19:32 <pumpkin_> Ezla: it still sounds to me like you're trying to apply your language a programming techniques to language b :P it's like saying "but why can't I say 'the cat's out of the bag' literally translated into italian and have people understand me???"
15:19:34 <Philippa__> variant:sums::records:products
15:19:38 <ahmad1nejad> the funny thing about haskell is that the language itself is so concise and simple
15:19:41 <jsn> hmm
15:19:42 <ahmad1nejad> but then you guys
15:19:46 <ahmad1nejad> invent a whole language to describe haskell ;)
15:20:11 <Ezla> pumpkin_: doesn't matter -- the example Philippa gave is good
15:20:11 <jsn> Philippa__: so basically, it is a means of sub-typing?
15:20:12 <Philippa__> heh. We don't, but there's a big pile of related concepts that aren't from programming so it sticks out
15:20:26 <Cale> ahmad1nejad: Because we're not just interested in Haskell, but a lot of different languages.
15:20:29 <Philippa__> jsn: you'd hope to have structural subtyping, yes
15:20:34 <ahmad1nejad> that's the beauty of it, huh?
15:20:34 <Philippa__> but you keep the pattern-matching
15:20:35 <jsn> ah
15:20:49 <blackh> Can some kind person explain 'fix' to me?
15:20:57 <Cale> blackh: sure
15:21:02 <pumpkin_> Ezla: I just think you're going at this from the wrong direction, but who knows :)
15:21:03 <Philippa__> blackh: it's a magic cloning box
15:21:09 <Cale> blackh: You've seen the definition, yeah?
15:21:10 <jethr0> @src fix
15:21:11 <lambdabot> fix f = let x = f x in x
15:21:14 <blackh> Yes.
15:21:23 <Philippa__> pumpkin_: I hope you wouldn't tell me the same
15:21:30 <Philippa__> some tasks /do/ warrant extensible variants
15:21:37 <jsn> Ezla: with a more specific example, i might be able to show you a way to handle it without extending the constructor
15:21:51 <Cale> So what it's doing is looking for an x for which  x = f x  which is called a fixed point of f.
15:21:54 <Philippa__> (the "monster" example is worse - in a game you actually need to be able to query for supported interfaces such as "damageable", "pickup" etc)
15:22:06 <ahmad1nejad> oh wait
15:22:07 <Ezla> How about Tree
15:22:12 <pumpkin_> Philippa__: I'm not talking about that example in particular, but every question asked so far is "I can do this in c++, why can't I do it in haskell" and it seems like an attempt to literally translate language idioms
15:22:14 <ahmad1nejad> > fix (^2)
15:22:15 <Philippa__> Ezla: there are encodings of extensible variants available, btw
15:22:17 <Cale> In particular, it's going to find what's called the least (defined) fixed point
15:22:21 <jsn> Philippa__: in a game, you basically need dynamic types if that is the case
15:22:29 <lambdabot>   thread killed
15:22:29 <jsn> Ezla: uhm well
15:22:30 <Ezla> Philippa: Implemented via?
15:22:32 <Cale> If undefined is a fixed point of the function, then that's what you'll get.
15:22:35 <Philippa__> pumpkin_: it's not, the questions're almost surprisingly divorced from C++ much of the time)
15:22:39 <Ezla> jsn: Keep adding not just Terminals
15:22:42 <Ezla> but new Non terminals
15:22:43 <ahmad1nejad> fix ^2 should equal [1,-1], right?
15:22:49 <ahmad1nejad> or am i not understanding
15:22:50 <Ezla> and not be coupled to a module
15:22:57 <Cale> However, if the function sends undefined to something which is not completely undefined, then fix will produce an interesting result.
15:23:02 <Cale> For example
15:23:03 <ahmad1nejad> er, just 1
15:23:05 <Philippa__> Ezla: most of them construct some flavour of type-level list of things it /could/ be
15:23:09 <jsn> Ezla: so you mean, the tree can have elements of any type in it?
15:23:09 <Cale> > head ((1:) undefined)
15:23:10 <lambdabot>   1
15:23:11 <koninkje> blackh: 'fix' generates the least fixed point of the function you pass in. I.e. you can think of f as taking in a partially specified value and returning a more-specified version of it. Eventually f x == id x for some x, so that's what you return
15:23:21 <Philippa__> if you really want some fun, look at HList
15:23:27 <Cale> Note that (1:) when applied to undefined gives a list which is not completely undefined
15:23:34 <Ezla> jsn: various modules implement new branch types
15:23:35 <Cale> (because it has a head)
15:23:36 <jkff> No. The only way in which fix can be computed automatically is by taking an undefined value and applying the function to it in hope that the function will make it more defined
15:23:38 <Cale> So:
15:23:41 <Cale> > fix (1:)
15:23:42 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
15:23:43 <jsn> Ezla: ah
15:23:47 <Ezla> not just terminals which can use the typeclass
15:23:48 <Philippa__> expect to spend a while getting your head round it though: last time I tried to implement the functionality myself (a couple of years back, admittedly) I got stuck
15:23:56 <jsn> Ezla: but branches have some uniform interface?
15:23:58 <pumpkin_> Philippa__: fine ;)
15:24:06 <Ezla> jsn: no
15:24:07 <jkff> That's the reason why you can't sensibly use fix in case where it is NOT a transform from a function type to a function type.
15:24:08 <Cale> This is a fixed point of the function which adds one to the start of the list, because adding another 1 to the start won't change what you have.
15:24:16 <Ezla> perhaps not
15:24:20 <jkff> fix (2*) is bad.
15:24:28 <Cale> blackh: does that make sense so far?
15:24:31 <jsn> Ezla: so what makes it all one type that has to fit under the same definition, then?
15:24:32 <ahmad1nejad> :t 1:
15:24:33 <lambdabot> parse error (possibly incorrect indentation)
15:24:37 <Cale> :t (1:)
15:24:37 <jkff> Because you get 2*2*2*2*...*undefined, which can't be computed
15:24:38 <lambdabot> forall t. (Num t) => [t] -> [t]
15:24:45 <Ezla> jsn: s/no/yes/
15:24:48 <ahmad1nejad> ??
15:24:52 <jsn> Ezla: i don't see how this is one actual type, instead of many
15:24:53 <jkff> Yes, I was mistaken. With *strict* types, not with non-functional
15:24:54 <Ezla> I wanted to see what you said about NO first
15:24:55 <ahmad1nejad> @src :
15:24:55 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
15:24:58 <Philippa__> jsn: because the type Ezla wants is the (disjoint) union of those separate types
15:25:00 <ahmad1nejad> :/
15:25:13 <Cale> blackh: Actually, come to #haskell-overflow perhaps :)
15:25:21 <ahmad1nejad> what does (1:) mean?
15:25:27 <jkff> \x -> 1:x
15:25:32 <jkff> > (1:) [2,3,4]
15:25:33 <Cale> ahmad1nejad: (1:) xs = 1:xs
15:25:34 <lambdabot>   [1,2,3,4]
15:25:34 <pumpkin_> ahmad1nejad: the function that prepends 1 onto a list
15:25:41 <Philippa__> Cale: we're the less-newbie conversation, we should probably be the ones moving
15:25:42 <ahmad1nejad> oh right
15:25:44 <ahmad1nejad> i knew that already
15:25:58 <ahmad1nejad> so what is fix (1:) appending it to
15:26:01 <Philippa__> Ezla: -> #haskell-overflow
15:26:13 <Cale> ahmad1nejad: fix (1:) = let x = (1:) x in x
15:26:15 <Ezla> min coffee 1st
15:26:19 <Philippa__> np
15:26:24 <jkff> fix f is computed as the limit of the sequence: undefined, f undefined, f (f undefined) etc.
15:26:26 <Cale> So  fix (1:) = let x = 1:x in x
15:26:35 <ahmad1nejad> neither hugs nor prelude on my box has fix defined
15:26:43 <jkff> So fix (1:) = 1:(1:(1:(...)))
15:26:45 <pumpkin_> @hoogle fix
15:26:45 <lambdabot> Data.Function fix :: (a -> a) -> a
15:26:46 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
15:26:46 <lambdabot> module Control.Monad.Fix
15:26:53 <jkff> And somewhere infinitely deep there is the undefined.
15:27:18 <jkff> But the whole value is still defined and queryable: for example, head (1:...) is 1 even if inside ... there is an undefined
15:27:33 <jethr0> > fix id
15:27:34 <lambdabot>   * Exception: stack overflow
15:27:57 <pumpkin_> > head $ fix (1:)
15:27:59 <lambdabot>   1
15:28:13 <pumpkin_> > take 5 $ fix (1:)
15:28:15 <lambdabot>   [1,1,1,1,1]
15:28:19 <ahmad1nejad> so fix (x:) means make an infinite list of x
15:28:20 <jkff> Whereas fix (^2) is the value undefined^2^2^2^2^...^2, which is a number and which is not queryable until fully evaluated.
15:28:42 <jkff> I personally think that it's best to watch the SICP lecture on fixpoints
15:28:43 <pumpkin_> ahmad1nejad: not quite, it means prepend an infinite list of x onto its parameter, I think
15:28:53 <pumpkin_> :t fix
15:28:54 <lambdabot> forall a. (a -> a) -> a
15:29:02 <blackh> OK - I'm with ya. It's the magic cloning box.
15:29:08 <ahmad1nejad> hehe
15:29:21 <pumpkin_> :t fix (1:)
15:29:22 <lambdabot> forall t. (Num t) => [t]
15:29:26 <pumpkin_> oh I am wrong :)
15:29:32 <blackh> It takes a function and gives you f . f . f . f . f . f . f . f . ....
15:29:35 <ahmad1nejad> :t (||)
15:29:36 <lambdabot> Bool -> Bool -> Bool
15:29:46 <jkff> So, the thing is that you can't just stick any 'a->a' in there and get a nice value out. 'fix' finds the *least defined* fixpoint.
15:30:01 <ahmad1nejad> > error "boobies"
15:30:01 <jkff> In many cases, the least defined fixpoint is simply the undefined value.
15:30:02 <lambdabot>   * Exception: boobies
15:30:11 <pumpkin_> lol
15:30:31 <blackh> I understand what it does now but I don't understand what the "least defined fix point" is.
15:30:32 <jkff> However in case of (1:), 'undefined' is not a fixed point, because undefined != 1:undefined
15:30:40 <jfredett> > fix (\x -> x + 1 `mod` 10)
15:30:51 <jfredett> *wonders if that will work.
15:30:52 <jfredett> *
15:30:55 <lambdabot>   thread killed
15:31:01 <jfredett> aww..
15:31:03 <jkff> For example, '1:2:3:undefined' is less defined than '1:2:3:4:5:undefined'
15:31:09 <byorgey> jfredett: it worked perfectly.
15:31:14 <byorgey> it found the least fixed point =)
15:31:18 <jkff> And 'undefined' is less defined than any other value
15:31:30 * Philippa__ points out that the whole boobies thing doesn't particularly make the chan woman-friendly
15:31:37 <jfredett> perhaps I'm just misunderstanding the whole notion
15:31:39 <jkff> So, to find a fixed point of a function 'f', you take 'undefined' and infinitely apply f to it
15:31:43 <jfredett> I'm but a lowly undergrad
15:31:45 <dons> mm :/
15:31:56 <ahmad1nejad> and then dons pops out
15:31:59 <jfredett> the wonders of the least fixed point elude me.
15:32:04 <ahmad1nejad> :%s/dons/cons/g
15:32:12 <kristofer> what does >>= do? sequencing of some sort.. but I don't know how it works
15:32:17 <SamB> okay, I'm asking around for a decent C++ IO library
15:32:17 <dons> btw, i just personally sighted 5 copies of RWH on a bookshelf at powell's. it is actually in shops.
15:32:19 <jkff> Hmm, I'll try to explain..
15:32:25 <Heffalump> mine hasn't arrived yet :-(
15:32:25 <SamB> nobody answered in ##c++
15:32:31 <Philippa__> dons: cool!
15:32:32 <blackh> Thanks for your help there, everyone.
15:32:34 <jkff> First, do you intuitively understand what 'A is less defined than B' means?
15:32:39 <jfredett> dons: I'm gonna check my local bookstore in the near future.
15:32:39 <ahmad1nejad> samb: opengl :)
15:32:46 <SamB> should I go ask it in ##c just for lulz?
15:32:52 <blackh> jkff: Not entirely
15:32:58 <pumpkin_> SamB: you'll need armor
15:33:02 <SamB> ahmad1nejad: you know, to use instead of <iostream>
15:33:03 <ddarius> SamB: Here's not the place to ask it.
15:33:13 <dons> there was a stack at the front desk, and then in the languages sectoin under H, between CofFP and SoE
15:33:19 <daf> dons: congrats :)
15:33:21 <ahmad1nejad> i only know the windows API libraries
15:33:25 <dons> yeah, it was cool :)
15:33:29 <ahmad1nejad> er
15:33:39 <ahmad1nejad> windows.h or whatnot
15:33:45 <Heffalump> is [F#|OCaml] for Scientists in any bookstores, OOI?
15:33:56 <dons> i've not seen it.
15:34:03 <blackh> kristofer: >>= gets two monadic operations and feeds the output of one into the next.  There are lots of ways to explain it.
15:34:07 <jkff> blackh: Suppose you have a value X that has an undefined somewhere inside. Then, if you replace that undefined by any other value, X will become *more* defined
15:34:18 <kristofer> blackh, gotcha
15:34:26 <Philippa__> Heffalump: can you imagine not seeing "in stores now!" everywhere if it was?
15:34:27 <daf> Heffalump: haha
15:34:33 <jkff> For example, [1,2,undefined,3,undefined,5] will become more defined if you make it [1,2,100,3,undefined,5]
15:34:34 <dons> also, a ridiculous number of copies have shipped now. way more than o'reilly expected. haskell for the masses is right.
15:34:42 <jkff> Is this clear?
15:34:49 <luite_> dons: how many?
15:34:51 <dons> let's hope that leads to more jobs in 09 :)
15:34:56 <Heffalump> dons: did they print enough?
15:34:58 <blackh> jkff: Yes - clear
15:34:59 <ahmad1nejad> haskell for the masses is probably the end of civilization as it exists
15:35:11 <dons> luite_: i've not got final numbers, but in the thousands.
15:35:17 <jkff> blackh: As a trivial case, 'undefined' will become more defined if you replace it with absolutely anything.
15:35:22 <Cale> :t let fix' f = f . fix' f in fix'
15:35:23 <dons> i'm not sure what the actual print run is, so no idea if they'll run out.
15:35:23 <lambdabot> forall c a. (c -> c) -> a -> c
15:35:31 <Cale> Not quite the right type ;)
15:35:39 <adimit> hello. suppose I have a big lazy byteString, and split something out of it, say x. Now I want to look x up in a a map M and if the map doesen't contain it, *copy* x into M, so the gc doesn't think I'm still referencing x. How do I do that (efficiently?)
15:35:41 <Cale> But it does actually work, if you ignore that extra parameter
15:35:44 <jkff> So, A is less defined than B if B is more defined than A :)
15:35:47 <ahmad1nejad> @hoogle fix
15:35:48 <lambdabot> Data.Function fix :: (a -> a) -> a
15:35:48 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
15:35:48 <lambdabot> module Control.Monad.Fix
15:35:53 <jkff> Now, about the 'least defined fixed point'.
15:35:53 <dons> adimit: using the 'copy' function
15:36:04 <blackh> > let mylist = [1,2,undefined]
15:36:05 <lambdabot>   <no location info>: parse error on input `;'
15:36:05 <dons> but that only works on strict bytestrings, iirc, soyou'll need to copy the chunks
15:36:12 * ahmad1nejad tries to figure out cabal
15:36:13 <dons> probably the keys should be strict bytestrings anyway
15:36:17 <Cale> :t let fix' f = (f . fix' f) undefined in fix'
15:36:18 <lambdabot> forall b a. (b -> a -> b) -> a -> b
15:36:24 <blackh> > take 3 mylist
15:36:25 <lambdabot>   Not in scope: `mylist'
15:36:28 <Cale> nope :)
15:36:34 * ahmad1nejad has no idea how to use cabal
15:36:35 <jkff> If you take an undefined and apply the function 'f' to it, it will become more defined.
15:36:38 <koninkje> :t let fix' f = f . fix' in fix' undefined
15:36:39 <lambdabot>     Occurs check: cannot construct the infinite type: b = (b -> c) -> c
15:36:39 <lambdabot>     Probable cause: `.' is applied to too few arguments
15:36:39 <lambdabot>     In the expression: f . fix'
15:36:42 <adimit> dons: you brought great insight. I knew about the copy function, but it didn't seem to work on my lazy byte string.
15:36:52 <Cale> :t let fix' f = f . fix' in flip fix' undefined
15:36:53 <adimit> so I better declare the map with strict byte strings?
15:36:54 <lambdabot>     Occurs check: cannot construct the infinite type: b = (b -> c) -> c
15:36:54 <lambdabot>     Probable cause: `.' is applied to too few arguments
15:36:54 <lambdabot>     In the expression: f . fix'
15:37:01 <Cale> odd
15:37:06 <ahmad1nejad> oh right, so where's that big haskell package db?
15:37:09 <jkff> blackh: Suppose that Y is a fixpoint of f.
15:37:12 <Cale> :t let fix' f = f . fix' f in flip fix' undefined
15:37:13 <lambdabot> forall c. (c -> c) -> c
15:37:16 <Cale> duh :)
15:37:23 <daf> ahmad1nejad: http://hackage.haskell.org/packages/hackage.html
15:37:33 <jkff> blackh: Then, Y = f (Y), Y = f (f Y) etc.
15:37:38 <koninkje> :t let fix' f = f . fix' f in fix' undefined
15:37:39 <lambdabot> forall c a. a -> c
15:37:47 <koninkje> heh!
15:38:06 <Cale> > const (fix undefined)
15:38:07 <lambdabot>       Overlapping instances for Show (b -> a)
15:38:08 <lambdabot>        arising from a use of `s...
15:38:11 <Cale> :t const (fix undefined)
15:38:12 <lambdabot> forall a b. b -> a
15:38:14 <dons> adimit: so maybe strictify the keys before you put them in the map? does  that sound feasible?
15:38:17 <Heffalump> :t const undefined
15:38:20 <lambdabot> forall a b. b -> a
15:38:20 <dons> then you can copy and get rid of the original chunks
15:38:27 <Heffalump> I win!
15:38:53 <daf> Heffalump: what did you win?
15:38:56 <adimit> dons: feasible? Well, I'm a newbie. I'll do my best.
15:39:03 <dons> ok :)
15:39:11 <Heffalump> I don't know. A quiet baby would be nice, but seems infeasible right now.
15:39:12 <dons> sounds like you're doing well though
15:39:16 <dons> Heffalump: hehe
15:39:22 <blackh> jkff: Thanks
15:39:36 <jkff> blackh: Oh. I guess I can't prove the fixpoint theorem right here. But all in all, the theorem says that if you take an undefined and repeatedly apply 'f' to it, then you'll get the least defined of all values satisfying x=f(x)
15:39:41 <ahmad1nejad> http://hackage.haskell.org/cgi-bin/hackage-scripts/archive.tar :D:D:D:D:D
15:39:44 <daf> Heffalump: perhaps reading baby Haskell would soothe it
15:39:54 <jkff> The theorem is not easily proved, but it is true.
15:40:05 <adimit> one more question: does lookup return a reference or copy of the value? (I wouldn't want to copy/strictify the byteString just for looking it up every time)
15:40:11 <dons> daf, that's right. gotta start 'em young. dibblego and chillix do that.
15:40:35 <Heffalump> he was born knowing Haskell, it's just that he can't communicate it yet
15:40:42 <dons> he
15:40:51 <jkff> blackh: Well, it's 2:40am in my timezone, so I need to go to sleep, and in the meantime I'd recommend you to watch the SICP lecture where they mention the Y combinator
15:40:51 <ahmad1nejad> heffalump++
15:40:54 <dons> :) yes. i wonder.
15:41:00 <jkff> Regretfully, I don't remember which one exactly it is.
15:41:02 <Cale> blackh: Let's take a look at another example
15:41:12 <jabberwocky> ooh, i like this one
15:41:13 <jkff> Probably the one about *implementing* recursion
15:41:19 * jkff goes to sleep
15:41:23 <jabberwocky> heffalump, we're going to have a faceoff, to the death, jabberwocky vs heffalump
15:41:29 <jabberwocky> at madison square garden
15:41:31 <Cale> fix (\fac n -> if n == 0 then 1 else n * fac (n-1))
15:41:51 <jabberwocky> lambda factorial function? :(O
15:41:54 <Cale> -> let x = (\fac n -> if n == 0 then 1 else n * fac (n-1)) x in x
15:41:55 <Heffalump> my weapon of choice is this screaming baby here
15:42:12 <Cale> -> let x = \n -> if n == 0 then 1 else n * x (n-1)) in x
15:42:25 <Cale> oops, lost a paren there
15:42:26 <dons> you guys holding up, Heffalump ?
15:42:29 <Cale> But you get the idea.
15:42:40 <Heffalump> barely :-)
15:43:07 <dons> Heffalump: i remember bringert & angela were sleeping in shifts
15:43:44 <Cale> blackh: Do you see how that works?
15:44:05 <Cale> blackh: It shows how fix is good enough to be able to define any recursive function.
15:44:32 <adimit> Another stupid question: M.insertWith f (g arg) v map. How do I strictly apply g to arg? g `seq` arg doesn't seem to work…
15:44:49 <Heffalump> dons: if I don't have work the next day, I basically stay up until I can get him to sleep
15:45:02 <Cale> adimit: let u = g arg in u `seq` M.insertWith ...
15:45:22 <dons> adimit: or would using insertWith' help?
15:45:24 <blackh> Cale: OK - I see. It gets a function and passes the recursive call to it. So it's equivalent to defining it directly.
15:45:33 <Heffalump> you probably mean g $! arg not g `seq` arg, though what Cale suggests is what you actually want in this case
15:45:33 <pumpkin_> @src seq
15:45:33 <lambdabot> Source not found. :(
15:45:34 <dons> Cale: strictifying a partial function?
15:45:42 <adimit> dons: typo, I was already using insertWith'
15:45:42 <dons> yeah, you'd want to force the arg, not the result of application
15:45:53 <dons> arg `seq` g arg
15:46:01 <Cale> dons: ah
15:46:03 <dons> and since it is partially applied, you can force it at the start.
15:46:07 <Heffalump> g `seq` arg forces g, not anything else
15:46:12 <dons> seems an odd case though.
15:46:17 <adimit> woah.
15:46:19 <Heffalump> and it produces arg, which is probably the wrong type too
15:46:28 <adimit> I need to process that. Brain hurts.
15:46:29 <pumpkin_> :t seq
15:46:31 <lambdabot> forall a t. a -> t -> t
15:46:31 <Cale> dons: Well, evaluating a partial application can work out in some cases :)
15:46:43 <Cale> dons: But to be honest I didn't really think too hard about it
15:46:54 <dons> there we go, RWH on shelves, http://www.facebook.com/photo.php?pid=1581288&l=0af10&id=660195979
15:47:14 <dons> next to CoFP, the book i learned to program with. cool :)
15:47:23 <Cale> and SoE
15:47:37 <blackh> Cale: the example I'm looking at is using it exactly this way: http://hackage.haskell.org/packages/archive/scgi/0.1/doc/html/src/Network-SCGI.html#runSCGI
15:47:59 <dons> generational transition :)
15:48:00 <ray> that's a nice insect dons
15:48:03 <Cale> blackh: that's actually a little strange style wise :)
15:48:07 <adimit> dons: RWH is great. I'm at chapter 11 right now :-). But lazy I/O is killing me. I never seem to get where my dangling references pop up
15:48:12 <Cale> blackh: But I suppose it works :)
15:48:22 <dons> adimit: interesting!
15:48:42 <dons> yes, gaining a handle on laziness is one key new skill to learn.
15:48:46 <dons> (pun :)
15:48:59 <blackh> Cale: Cale: forever would be better, I suppose
15:49:16 <blackh> Cale: Clear, that is. Thanks!
15:49:16 <jabberwocky> wtf@jyte.com
15:49:24 <jabberwocky> http://jyte.com/cl/haskell-is-the-best-programming-language-that-exists-today
15:49:25 <Cale> blackh: no problem :)
15:49:42 <adimit> heh. So far I got everything besides using lazy folds into mutable datastructures (like a map) over large files.
15:50:23 <adimit> that's my only problem with lazy IO for now. It'll sure as hell not be the last, though.
15:51:46 <dons> did you work out how to do strict IO ?
15:51:58 <dons> i.e. with System.IO.Strict or Data.ByteString?
15:52:26 <glguy> ~.
15:52:46 * Heffalump sends terminating vibes at glguy's shell
15:52:48 <Cale> Let's all pwn that jyte poll :)
15:52:54 <pumpkin_> lol, I just voted
15:52:55 <adimit> yes, I read through the chapter in RWH, but didn't really do a lot on it yet. I'm trying to use Haskell for corpus linguistics, where files are too big to fit into memory (therefore I'm trying lazy IO for it.)
15:53:06 <glguy> when the computer comes back from suspend
15:53:15 <glguy> sometimes I can send keystrokes but not see them
15:54:15 <dons> Cale: url?
15:54:27 <Cale> http://jyte.com/cl/haskell-is-the-best-programming-language-that-exists-today
15:54:34 <dons> adimit: right. so this is hard in general. you'll want lazy IO to stream the results. but then, not too many handles open
15:54:41 <dons> the title sounds reasonable :)
15:54:51 <pumpkin_> you gotta vote!
15:54:51 <Cale> dons: but we're currently losing
15:55:01 <dons> weird.
15:55:13 <dons> 'best' is subjective enough to piss people off
15:55:19 <blackh> I want to see what the disagreers said was better.  If there's a better language than Haskell, then I want to know about it!
15:55:35 <dons> oh, the polls been up for 2 years?
15:55:38 <pumpkin_> lol http://jyte.com/cl/people-smarter-than-they-think-they-are-are-always-smarter-than-those-who-believe-they-are-dummer-than-they-think-they-are
15:56:16 <pumpkin_> sorry, not haskell :)
15:56:38 <dons> blackh: just a few silly comments. FP isn't practical. Lisp is better. monads are scary
15:56:47 <dons> ancient memes
15:56:56 <dons> all >1 year old comments
15:57:00 <oklopol> how does lambda refer to lisp more than haskell
15:57:15 <dons> yeah. it's in the freaking logo
15:57:18 <dons> :)
15:57:23 <oklopol> yeah, and also
15:57:35 <oklopol> in haskell it's much closer to the original lambda
15:57:41 <ray> lisp's logo should really be ()
15:57:48 <ddarius> oklopol: More people have heard "lambda calculus + lisp" than "lambda calculus + haskell" (/me leaves it as an exercise to guess why)
15:57:50 <Adamant> kalven: it's been used for Lisp much longer
15:58:16 <Adamant> err, oklopol
15:58:23 <jabberwocky> dons: what?
15:58:26 <mauke> ray: no, )))))
15:58:27 <dons> what?
15:58:36 <jabberwocky> FP isn't practical?
15:58:39 <dons> hah
15:58:52 <ray> haha, )))))
15:58:55 <glguy> he means that it isn't "real world"
15:59:01 <glguy> its for researchy things
15:59:05 <jabberwocky> oh, fuck that
15:59:08 <dons> yeah. like for jobs and stuff. and doing things to stuff
15:59:10 <jabberwocky> it's for people who need a full-featured language
15:59:11 <jabberwocky> !
15:59:16 <jabberwocky> and concisenessity
15:59:19 <dons> making things do stuff. nah. wouldn't fly. you need objects.
15:59:31 * jabberwocky frowns
15:59:39 <dons> jabberwocky: confused?
15:59:43 <jabberwocky> not confused
15:59:45 <jabberwocky> dismayed
15:59:48 <dons> ?
16:00:24 <jabberwocky> i'm programming my game in haskell right now specifically to transcend the limitations of OO
16:00:31 <dons> it's a joke. since it's so ludicrous. there's a background of obviousness here that makes it silly. but i think you missed the joke :)
16:00:38 <dons> so it's ok. we don't really think that. please write more games.
16:00:38 <ziman> jabberwocky, your irony detector's broken ;)
16:00:44 <jabberwocky> oh ok, ood
16:00:47 <jabberwocky> +g
16:00:59 <dons> jabberwocky: glguy and i both work at a company that uses haskell for everything :)
16:01:02 <jabberwocky> my game's gonna kick ass
16:01:04 <jabberwocky> what company?
16:01:10 <dons> so it would be kinda funny if we were sitting here agreeing that it wasn't practical. mwhaha
16:01:15 <dons> galois.
16:01:19 <geezusfreeek> jabberwocky: what kind of game you making?
16:01:27 * jabberwocky writes a bitchy letter to your boss
16:01:39 <dons> jabberwocky: why? for using too much haskell?
16:01:43 <dons> glguy: btw, how's the cold?
16:01:45 <jabberwocky> no, i'm kidding
16:01:55 <jabberwocky> geezusfreeek: somewhere between simcity, abstract expressionism and MMORPG
16:02:06 <Ezla> have you guys ever seen Faust?
16:02:07 <dons> oh, did you see that french startup doing cityscapes for games in haskell?
16:02:14 <dons> what was their name. hmm
16:02:19 <Ezla> FRP reminds me a lot of Faust
16:02:21 * dons hopes he added it to the wiki
16:02:26 <geezusfreeek> Faust?
16:02:26 <joe_b> question about data constructors: can i extend a data type declared in a library in my own code?
16:02:37 <ddarius> joe_b: No
16:02:39 <Ezla> http://www.grame.fr/pub/faust-den-haag-april-2006-v6.pdf
16:02:49 <dons> jabberwocky: http://gamr7.com/
16:02:58 <glguy> joe_b, if you did that, then you'd have to update everyone else's functions to handle that new case
16:03:00 <dons> haskell stuff for games with city landscapes
16:03:01 <Ezla> Faust uses Arrows for DSP
16:03:08 <dons> EDSL, Ezla ?
16:03:16 <Ezla> Yes
16:03:21 <Ezla> Its not embedded
16:03:25 <dons> oh
16:03:27 <Ezla> but it converts to C++
16:03:30 <dons> ah
16:03:43 <dons> but the users write haskell? or they write some custom language that uses arrows ?
16:03:49 <geezusfreeek> ah yeah, seems similar in concept
16:03:55 <Ezla> Faust is not related to Haskell
16:04:00 <Ezla> its for musicians really
16:04:07 <Ezla> Just flip through those slides real fast
16:04:12 <Ezla> it has a big set of Arrows
16:04:19 <Ezla> I use it for music
16:04:21 <joe_b> ddarius: how is that normally handled in haskell?
16:04:26 <jabberwocky> what's the name of that sound manipulation language/scripting dealio
16:04:33 <Ezla> it makes throwing together DSP stuff really fast
16:04:43 <dons> haskore
16:04:44 <jabberwocky> holy shit i need to use haskell for audio DSP
16:04:46 <joe_b> glguy: but my code would be the only code with the added definitions?  who else would see it?
16:04:56 <jabberwocky> and video granular synthesis O.O
16:04:58 <dons> jabberwocky: there's a bunch of guys doing that. see henning thielmann's work
16:05:03 <dons> he's putting lots of dsp stuff on hackage
16:05:23 <jabberwocky> are there people doing video granular synth yet?
16:05:28 <jabberwocky> i don't even know if that exists
16:05:30 <dons> no idea.
16:05:36 <jabberwocky> as a discipline
16:05:49 <pumpkin_> the dsp I saw had n^2 convolution though
16:05:52 <pumpkin_> :(
16:06:02 <pumpkin_> maybe I just looked at the wrong one though
16:06:23 <olsner> joe_b: it really depends on what you're trying to do, why do you need to add stuff to data types from another library?
16:06:25 <ddarius> joe_b: There is nothing that you can do after the fact, but you can make your own type that wraps the other, e.g. Either MyStuff LibStuff or handle it in a variety of other ways.
16:06:36 <Ezla> Fause is designed for absolute performance
16:06:43 <Ezla> *Faust
16:06:46 <glguy> joe_b, if you were to extend the Maybe a  type to not only have Just a and Nothing, but to add Two a a
16:07:00 <Heffalump> joe_b: the existing functions that consume that type would have to know about your additions
16:07:03 <glguy> joe_b, then all of the functions that were written knowing that Maybe has Just and Nothing would break
16:07:15 <joe_b> ah, i see
16:07:35 <dons> Cale: there's a lot of 'newbie'-ish questions starting to appear on the rwh-bookclub list.
16:07:37 <joe_b>  <-- still getting used to functional data types
16:07:38 <dons>  http://groups.google.com/group/real-world-haskell-book-club
16:07:44 <dons> i wonder how we should connect that back to the core community
16:08:00 <dons> it is mostly non-haskellers learning haskell through rwh. so they'd benefit from getting pulled in
16:08:18 <ddarius> dons is in Borg mode
16:08:21 <dons> joe_b: oh, 'algebraic types'
16:08:21 <Ezla> dons I'm gonna read your book, and I'm a newb :)
16:08:32 <dons> ddarius: damns straight. momentum. this is the big push time.
16:09:14 <dons> joe_b: yeah, its kinda of cool to see all the usual data structure concepts elegantly packaged into a single 'data' keyword
16:09:32 <dons> so you can easily encode options, recursion, structures, generic types, all sorts of things.
16:10:06 <dons> ddarius: we traditionally get a peak around the end of year, but i'm hoping it is really a surge this year. more code , more jobs, more haskell for all :)
16:10:49 <olsner> disband the book club and make people go to #haskell and haskell-cafe/haskell-help/whatever?
16:11:23 <dons> i thought about that, but it asks specific questions about the book, which not everyone has. but there should be some clear link.
16:11:41 * jabberwocky is staying the hell away from google
16:11:43 <dons> also, we didn't set it up (hence not a @haskell.org thing, an F# guy who really likes it did)
16:12:10 <jabberwocky> for incriminating things, at least
16:12:12 <dons> so its a completely different flavour of haskeller
16:12:15 <jabberwocky> ;)
16:12:27 <olsner> hmm, I guess it's difficult to combine getting book-people integrated and keeping book-specific issues separated
16:12:56 <pumpkin_> start a #rwh maybe and have people go there?
16:13:08 <dons> yes.
16:16:02 <sereven> and advertise #haskell, -cafe, HWN in channel msg for #rwh
16:19:11 <pumpkin_> onoes!
16:19:20 <dons> ?users
16:19:21 <lambdabot> Maximum users seen in #haskell: 568, currently: 520 (91.5%), active: 22 (4.2%)
16:19:24 <dons> feels busy today.
16:19:42 <dons> 568 was yesterday's all time high score. i wonder if we can get 600 ... hmm
16:19:47 <pumpkin_> I wonder if it's possible to generalize the concept of a function that can be applied efficiently to a sliding window
16:20:04 <dons> pumpkin_: a sliding window of values onto some data structure?
16:20:09 <dons> or a sequence/
16:20:13 <pumpkin_> oh, I mean
16:20:45 <pumpkin_> the naive way computes each window and computes the function on each of those generated window (a slidingMap or something), but it can be done more efficiently than applying to each window, in the case of entropy, or mean
16:21:00 <pumpkin_> is there some way of automaitcally getting that efficiency in a general slideMap
16:21:27 <pumpkin_> bah, my english skills are bad today :P
16:21:48 <ddarius> pumpkin_: Express the transformation as an IIR filter.
16:21:54 <pumpkin_> IIR?
16:22:03 <ddarius> Infinite Impulse Response
16:22:14 <pumpkin_> hmm
16:22:20 <joe_b> ddarius: returning to extending data types, if i create a type class then make my data type and the old data type derive that class, will that have the effect of "extending" the old data type?
16:22:29 <ddarius> No.
16:22:32 <pumpkin_> ddarius: so I could express entropy and mean as an IIR?
16:23:12 <pumpkin_> it would be nice to think of sliding window entropy as convolution
16:24:26 <ddarius> pumpkin_: By mean, do you mean windowed mean, i.e. the mean of the last 5 elements, or running mean, i.e. a stream of means of all preceding elements?
16:24:35 <pumpkin_> last 5
16:24:37 <pumpkin_> or n
16:25:29 <pumpkin_> so they'd all have in common an "update by adding this new value and removing this old value"
16:25:36 <ddarius> pumpkin_: Then that's a common filter called the running mean and has a very simple IIR representation.
16:26:10 <pumpkin_> hmm
16:26:46 <pumpkin_> so I'd want something like runningMean 3 [1,2,3,4,5,6] => [2, 3, 4, 5]
16:28:00 <pumpkin_> I can do that easily in the special case of mean
16:28:12 <pumpkin_> and centrinia and I were working on a sliding entropy yesterday
16:28:21 <dons> i'm so happy about martin sulzmann's recent move to blog+release on hackage all his prodigious output, http://sulzmann.blogspot.com/2008/12/parallel-join-patterns-with-guards-and.html
16:28:34 <dons> we just need oleg to enter the 21st century now. blog + hackage, instead of .hs and ftp.
16:28:59 <pumpkin_> (and irc)
16:29:11 <pumpkin_> (and twitter)
16:29:14 <ryanakca> Which book do you recommended to a newcommer (previous programming experience: Python and a bit of C++)? I've read the Books list on the HaskellWiki, but I don't know which one to pick. ``Haskell: The Craft of Functional Programming'' and ``Real World Haskell'' look like the best bet. I'm not too sure about ``Programming in Haskell'' since it's destined to an audience who has never programmed before. What I'm looking for is a book that shows ...
16:29:16 <pumpkin_> oleg 2.0
16:29:20 <ryanakca> ... *HOW* to program is Haskell, not just ``You can use foo to do this and that and bar can do this and that'' without showing how it would be used in the real world... Same style as ``Accelerated C++'' if it helps.
16:29:27 <ryanakca> Ouch, sorry, that was long
16:29:44 <pumpkin_> ryanakca: try RWH?
16:29:48 <pumpkin_> or learn you a haskell
16:29:57 <pumpkin_> (which isn't a book, but is cool too)
16:30:02 <Cale> ryanakca: Well, you can check out RWH online and see if you like it
16:30:10 <Cale> ryanakca: The whole book is open :)
16:30:18 <ddarius> > let iir as bs xs = fix ((replicate (length bs) 0 ++) . iir' xs) where iir' xs ys = sum (zipWith (*) as xs) + sum (zipWith (*) bs ys) in iir [1,0,0,-1] [1] [1..6]
16:30:18 <adimit> ryanakca: I really like Real world haskell. Plus it's freely available.
16:30:19 <lambdabot>       Occurs check: cannot construct the infinite type: t = [t]
16:30:20 <lambdabot>        Expect...
16:30:25 <dons> ryanakca: CoFP is for beginners too. it is an older Programming in Haskell, basically
16:30:46 <dons> if you already know how to program, RWH is probably the only choice (?). or does SoE also satisfy that?
16:31:02 <pumpkin_> SoE doesn't look too basic, but I haven't looked too closely
16:31:08 <dons> yay, sulzmann, http://www.reddit.com/r/programming/comments/7husr/parallel_join_patterns_with_guards_and/
16:31:09 <ddarius> > let iir as bs xs = fix ((replicate (length bs) 0 ++) . iir' xs) where iir' xs ys = (sum (zipWith (*) as xs) + sum (zipWith (*) bs ys)) : drop (length bs) ys in iir [1,0,0,-1] [1] [1..6]
16:31:10 <daf> I was disappointed by SoE
16:31:10 <lambdabot>   [0,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,...
16:31:11 <Cale> ryanakca: Also, don't hesitate to ask any questions which come to mind here.
16:31:23 <dons> its also almost a decade old, like CofFP
16:31:29 <ryanakca> Cale: thanks
16:31:30 <dons> pre-ghc essentially.
16:31:34 <daf> it was missing out on a lot of stuff that you use in practice
16:31:35 <Cale> ryanakca: We can often answer things more quickly than the documentation or looking through tutorials can :)
16:31:45 <pumpkin_> ddarius: how does that work?
16:31:45 <ryanakca> :)
16:32:02 <ddarius> > let iir as bs xs = fix ((replicate (length bs) 0 ++) . iir' xs) where iir' xs ys = (sum (zipWith (*) as xs) + sum (zipWith (*) bs ys)) : drop (length bs) ys in iir [-1/3,0,0,1/3] [1] [1..6]
16:32:04 <lambdabot>   [0.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1....
16:32:34 <ryanakca> Looks like I'll look through the online version of RWH, and if it's to my liking, I'll buy a printed copy (1. Support the authors, 2. It's much easier on my eyes)
16:32:51 <ray> coming soon to a bookseller near you?
16:33:06 <jethr0> Ray: should already be there ;)
16:33:06 <ray> i'd really prefer the dead tree, too
16:33:10 <Japsu> oh, cool
16:33:18 <ray> i haven't looked in like a week :)
16:33:20 <dons> it arrived in stores 2 days ago, fwiw.
16:33:20 <ddarius> > let iir as bs xs = fix ((replicate (length bs) 0 ++) . iir' xs) where iir' xs ys = (sum (zipWith (*) as xs) + sum (zipWith (*) bs ys)) : iir' (tail xs) (tail ys) in iir [-1/3,0,0,1/3] [1] ([1..6] ++ repeat 0)
16:33:20 <Japsu> my iir's a lot more verbose
16:33:21 <lambdabot>   [0.0,1.0,2.0,3.0,1.6666666666666667,2.220446049250313e-16,-1.99999999999999...
16:33:27 <Japsu> let's see,
16:34:05 <ddarius> Japsu: That one can be improved efficiency-wise.
16:34:34 <pumpkin_> ddarius: hrmm
16:34:47 <Japsu> http://hpaste.org/12796 <-- there, discrete convolution and iir
16:36:50 <ddarius> Actually, maybe it can't be improved much efficiency-wise at a high-level.
16:37:46 <ddarius> Switching to arrays of some sort and using a sparse representation of coefficients could improve this particular use-case.
16:38:29 <pumpkin_> hmm
16:40:41 <Ezla> Why does show bindings produce:
16:40:42 <Ezla> f :: (Num a) => a -> a = _
16:40:52 <Ezla> the _ ?
16:40:57 <mauke> looks unevaluated
16:41:29 <Ezla> where did 'it' come from?
16:42:28 <Ezla> 'it' is a binding
16:43:11 <Ezla> it appears when I eval a function
16:43:17 <twanvl> 'it' is the name given to the last expression entered in ghci, so if you type  "1+1" then 'it' becomes 2
16:43:23 <Cale> Ezla: 'it' is bound by GHCi to the result of the last evaluation
16:43:27 <Ezla> k
16:43:38 <pumpkin_> my it seems stuck
16:43:46 <Ezla> when doing
16:43:55 <Ezla> foo -> (bar -> baz) -> a
16:44:01 <Ezla> the only use for ( ) is to set eval order
16:44:07 <Ezla>  ?
16:44:14 <Ezla> How is that possible when its curried
16:44:16 <mauke> ( ) doesn't influence evaluation order
16:44:23 <Ezla> what does it do
16:44:25 <mauke> especially not in C
16:44:41 <mauke> overrides default precedence
16:44:43 <pumpkin_> -> is right-associative, so you need to do that if you want to pass functions around
16:44:58 <mauke> a -> b -> c is parsed as (a -> (b -> c))
16:45:09 <mauke> (a -> b) -> c gets you the other interpretation
16:45:16 <Ezla> k
16:46:02 <Cale> Well, it does *sort of* influence evaluation order, but only because it changes how the expression is built up.
16:48:29 <daf> Ezla: a -> (b -> c) -> d is a function that takes two arguments, not three
16:48:44 <Ezla> yeah
16:49:00 <pumpkin_> or a function that takes one argument, that returns a function that takes one function argument, that then returns a d?
16:49:11 <daf> pumpkin_: equivalently, yes
16:49:23 <pumpkin_> ok
16:49:25 <Ezla> if you tried to do it with 3, it would be less polymorphic than expected
16:49:36 <ciscbrain> I have this function for primality testing
16:49:37 <arw> i want to puke: http://www.boost.org/doc/libs/1_37_0/doc/html/lambda/s03.html
16:49:37 <ciscbrain> isprime n = not $ any ((== 0).mod n) [2..n-1]
16:49:39 <daf> Ezla: er, what?
16:49:41 <adimit> is there any better way to strictify ((a+b),(c+d)) than (c+d) `seq` (a+b) `seq` (,) (a+b) (c+d)?
16:49:53 <pumpkin_> ciscbrain: that looks efficient :)
16:49:57 <ciscbrain> :)
16:50:01 <ciscbrain> yeah, I know
16:50:11 <ciscbrain> but I think it works too slow
16:50:17 <ciscbrain> wanted to understand why
16:50:18 <Ezla> arw: That's old hat
16:50:24 <Ezla> arw: Nobody uses that anymore
16:50:35 <Ezla> You're looking at 1997 stuff
16:50:43 <pumpkin_> ciscbrain: it's trying every possible factor, which is silly :)
16:50:50 <ciscbrain> yeah, I know :)
16:50:55 <arw> Ezla: and the new stuff? does it look as bad?
16:51:11 <mauke> (,) $! (a+b) $! (c+d)
16:51:13 <Ezla> http://spirit.sourceforge.net/dl_docs/phoenix-2/libs/spirit/phoenix/doc/html/index.html#phoenix.preface
16:51:21 <ciscbrain> I was only fooling around
16:51:25 <ciscbrain> but still
16:51:28 <pumpkin_> ciscbrain: you want to get a modern primality test, or just make the naive one faster?
16:51:29 <ciscbrain> it's reaaaly slow
16:51:44 <ciscbrain> no, I want to understand why this is so slow
16:51:47 <ciscbrain> for example
16:51:52 <ciscbrain> for 43214231
16:51:56 <dons> anyone tried setting up gitit for a local/personal wiki?
16:52:01 <ciscbrain> it takes a few seconds
16:52:09 <pumpkin_> ciscbrain: that's going to iterate 43214230 times :P
16:52:12 <dons> i'm thinking of wiki-fying my life, and considering gitit.
16:52:13 <ciscbrain> ~10
16:52:48 <ciscbrain> pumpkin_: 10 seconds for 10M iterations seems like a lot
16:52:58 <ciscbrain> ok, 43M
16:53:00 <QtPlatypus> ciscbrain: You only have to iterate up to the square root of your test number.
16:53:19 <pumpkin_> it's doing a mod at each iteration, too, but maybe you're right
17:01:59 <Ezla> why does Haskell have such a strong culture of unifying libraries?
17:02:38 <dons> good question.
17:02:44 <daf> very good question
17:03:02 <dons> we made a intentional decision to push for unifiication and federation to improve the efficiency of our community.
17:03:17 <dons> avoiding some of the pitfalls of a fragmented community that we've seen in other projects
17:03:25 <dolio> We don't. There are too many array libraries!
17:03:26 <dons> the culture becomes self-sustaining after a while
17:03:26 <daf> dons: are you referring to hackage?
17:03:29 <dons> but it takes work.
17:03:36 <dons> daf, in general.
17:04:02 <Ezla> Is that really your decision? Or was it the languages conscience
17:04:09 <daf> well, it seems to have caught on culturally
17:04:15 <dons> the language was born as an open source response to miranda
17:04:19 <dons> that shaped much of the early culture
17:04:32 <dons> and early on 'fptools' was created, a single shared library base for all compilers
17:04:41 <dons> also, it was all academics used to collaborating initially.
17:04:50 <dons> rather than, say, distrusting commercial groups as with lisp.
17:04:53 <dons> so that helped shape things too
17:04:58 <Ezla> My hunch is that...
17:05:26 <dons> that fed in to the late 90s realisation we were doing what was then being called "open source"
17:05:49 <Ezla> In a language like C++, it's extremely difficult to get people to write libraries that play well together, because the type system is bound inside the classes, and only presses outwards from there
17:05:51 <dons> and now we actively work on improving the efficiency of the open source project. federating distributed work. unifying projects. linking and reusing.
17:05:58 <Ezla> whereas Haskell is additive and subtractive
17:06:00 <dons> oh, and there's definitely technical reasons, yes!
17:06:07 <dons> it is *easy* to compose pure, typed code.
17:06:12 <Ezla> and extension methods aren't bound to the objects
17:06:23 <dons> so easy to reuse. and we gain efficiencies in the long term construction of libraries
17:06:42 <daf> ooh
17:06:43 <dons> so now we're starting to see those technical and cultural effects at play
17:06:45 <dons> and it is awesome.
17:06:45 <daf> that is interesting
17:07:00 <dons> daf, right? you can import a pure function and know it won't break your code *at all*
17:07:02 <daf> social consequences of technical properties are always fascinating
17:07:18 <dons> yeah. and unpredictable.
17:07:23 <Philippa__> yeah. We do get the odd legacy refit problem, but having parametric polymorphism ubiquitous is a big deal
17:07:33 <ciscbrain> soo.. i wrote an even slower primality checker :)
17:07:34 <ciscbrain> isprime2 n d = (d == n-1) || ((n `mod` d > 0) && (isprime2 n (d + 1)))
17:07:41 <ciscbrain> which is *a lot* slower
17:07:48 <ciscbrain> shouldn't they be around the same speed? :(
17:07:51 <pumpkin_> ciscbrain: yay! how much slower can you make it? :D
17:07:53 <dons> the other thing we have is a huge community
17:08:01 <dons> so even if we're only 5% efficient, we produce a lot of code anyway
17:08:03 <ciscbrain> yes, I know they're really bad
17:08:08 <dons> and we try to be just that little bit more efficient than our competitors
17:08:13 <dons> (as well as being bigger)
17:08:16 <daf> I was wondering about this the other day
17:08:22 <daf> specifically with regards to F#
17:08:24 <Ezla> Why Haskell from the set of functional languages?
17:08:29 <ciscbrain> pumpkin_: I can write it in ruby
17:08:29 <daf> I get the impression that Microsoft is promoting it a bit
17:08:34 <Ezla> why did you pick haskell as ultimate?
17:08:37 <dons> the only pure one that has a chance, Ezla. purity is the key thing.
17:08:39 <daf> but don't really have any idea of how much it's caught on
17:08:46 <Ezla> for "real" use
17:08:47 <daf> or what kind of a community it has if any
17:08:47 <ciscbrain> but still.. why is the second one a lot slower?
17:08:49 <dons> that's what makes say, parallelism easy. what makes reuse easy.
17:09:16 <dons> MS is pushing F#. it's like a haskell-lite for .NET library uuesrs.
17:09:20 <daf> or whether it has its own libraries or just borrows .NET ones, and if the latter whether it is a problem
17:09:25 <ciscbrain> isn't the tail call optimized? or is there something I'm missing :(
17:09:29 <dons> though you can use the Haskell .NET bridge too.... just not many people have tried.
17:09:38 <daf> ciscbrain: I see no tail call here
17:09:59 <centrinia> I thought F# was Ocaml.NET :p
17:10:09 <pumpkin_> ooh it's centrinia!
17:10:11 <bjrn> ciscbrain: http://en.wikipedia.org/wiki/Wilson%27s_theorem :)
17:10:18 <ciscbrain> daf: hm.. aren't && and || lazy? I thought that counted as tail
17:10:23 <centrinia> Hi pumpkin.
17:10:25 <johnnowak> dons: do you see any possibility for success for something like clojure?
17:10:37 <johnnowak> it's "pure enough" i'd say
17:11:02 <dons> johnnowak: maybe. the jvm is a niche. and there's a core group in the US receptive to Lisp.
17:11:14 <dons> but i'm skeptical. I think it is too niche. It's too early to say though. Ask me in 2 years.
17:11:19 <ciscbrain> bjrn: yes, that's a start.. now if I could only find a really bad way of computing factorial
17:11:28 <pumpkin_> centrinia: you think it's possible to build a general slidingWindowMap that works efficiently, that takes an "update by removing these symbols and adding these to your state" kind of function?
17:11:28 <johnnowak> aye. i feel similarly. though, being in the US, I am partial to lisp.
17:11:38 <centrinia> ciscbrain: What does there existing some integer k such that (p-1)!+1 = k p for all primes p>2 have to do with anything?
17:12:01 <ddarius> daf: From what I hear, F# does a decent job integrating with the .NET libraries reasonably naturally.
17:12:04 <bjrn> ciscbrain: Some kind of randomized algorithm perhaps. Simply multiply together integers randomly
17:12:18 <centrinia> pumpkin_: It depends on what kind of operation you use.
17:12:37 <dons> johnnowak: it's too early to say though. seems like some of the pieces are in place for early growth (charismatic leader, interop, some new innovations).
17:12:44 <daf> ddarius: ok. I can see that that would help some people cross over.
17:12:57 <ciscbrain> look, I know the above functions are *really* bad and they should *never* be used in a real program :)
17:13:01 <daf> ddarius: but I imagine it's not nearly as nice as having native libraries
17:13:04 <dons> but we've not seen anything done with it yet, so its just impossible to say, imo.
17:13:16 <daf> ciscbrain: I don't think the laziness helps make it a tail call
17:13:22 <centrinia> If you can't somehow "subtract" from the accumulator, then I doubt that you can do a sliding window with updates. :)
17:13:58 <dons> johnnowak: it reminds me a little of the groovy buzz (but here with a lisp slant, which adds bonus points)
17:14:27 <centrinia> ciscbrain: Are you computing factorials?
17:14:33 <pumpkin> centrinia: that's what I mean though... take the sliding entropy and compartamentalize it in such a way that you can call it from a general higher-order function
17:14:51 <johnnowak> dons: well, it's also not total shit, which may help
17:14:51 <dons> to really suceed there has to be some investment (i.e. like a 10 year research program at INRIA, or a decade of MSR funding, or Sun pushing it, or a buzz-like niche (concurrency, web apps)). those have worked in the past.
17:15:00 <dons> but just running on a platform hasn't been enough in the past alone.
17:15:23 <ciscbrain> centrinia: no, I not doing anything, really, just trying various things
17:15:38 <centrinia> pumpkin: I think that (scanl op initial (zip data (drop n data)) should do it for appropirate op and initial. :)
17:15:39 <Ezla> > [0..]
17:15:40 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
17:15:42 <johnnowak> i suppose success is a relative notion anyway.
17:15:45 <Ezla> where does the bot detect it?
17:15:46 <dons> predicting the future is hard. i think its more likely than not clojure won't make it (it'll be just another lisp) atm, but i might be wrong.
17:16:02 <Ezla> can I get that behavour in ghci?
17:16:11 <dons> oh, the take n $ ...
17:16:12 <pumpkin> centrinia: hmm, maybe... the only thing I can bring myself to think about scanl for is computing successive squares :P
17:16:19 <dons> hmm. that would make a useful little library, Ezla
17:16:25 <dons> or a useful default to ghci :)
17:16:26 <Ezla> dons: Helps learning
17:16:36 <dons> hmm. can't we set a printing funciton. i think we can..
17:16:49 <Ezla> a printing function would be fine
17:17:13 <Ezla> How do you detect an infinite list in the first place?
17:17:13 <dons> well, that's just take 10 $ [1..]
17:17:22 <dons> > take 10 [1..]
17:17:23 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
17:17:29 <dons> with a bit of pretty printing involved for lambdabot
17:17:34 <centrinia> > let { xs = [1..100]; n = 10} in scanl (\(o,i) acc -> acc - o + i) (sum $ take n xs) (zip xs (drop n xs))
17:17:35 <lambdabot>       Occurs check: cannot construct the infinite type: b = (b, b)
17:17:35 <lambdabot>        Exp...
17:17:37 <dons> Ezla: it doesn't detect. that's laziness at work.
17:17:43 <dons> only what the printing requires will be computed.
17:17:49 <centrinia> > let { xs = [1..100]; n = 10} in scanl (\acc (o,i) -> acc - o + i) (sum $ take n xs) (zip xs (drop n xs))
17:17:50 <lambdabot>   [55,65,75,85,95,105,115,125,135,145,155,165,175,185,195,205,215,225,235,245...
17:17:52 <Ezla> Yeah, I understand, but
17:18:07 <centrinia> Hmm.
17:18:11 <Ezla> Now that you said it's take 28 or whatever
17:18:18 <dolio> It calls show and then takes the first N characters.
17:18:19 <Ezla> but if I _wanted_ to detect an infinite list?
17:18:34 <gwern> sounds like a halting problem to me
17:18:34 <pumpkin> what are reasonable uses for fix other than fix (n:) ? (that give defined answers)
17:18:35 <dons> you couldn't (easily)
17:18:45 <mauke> pumpkin: recursive functions
17:18:52 <roconnor> > fix bitSize
17:18:53 <lambdabot>   64
17:18:57 <pumpkin> o.O
17:19:01 <pumpkin> > bitSize
17:19:02 <dolio> You could, maybe, detect certain infinite lists with reallyUnsafePointerEquality#
17:19:02 <lambdabot>       Overlapping instances for Show (a -> Int)
17:19:02 <lambdabot>        arising from a use of ...
17:19:06 <pumpkin> > bitSize 5
17:19:07 <lambdabot>   Add a type signature
17:19:10 <Ezla> dolio: ?
17:19:11 <pumpkin> > bitSize 5 :: Int
17:19:12 <lambdabot>   Add a type signature
17:19:15 <Philippa__> Ezla: you can't detect it reliably in pure code
17:19:17 <pumpkin> > bitSize (5 :: Int)
17:19:18 <lambdabot>   64
17:19:24 <mauke> > fix error
17:19:26 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
17:19:33 <roconnor> okay, so it isn't a reasonable use of fix
17:19:44 <ddarius> Philippa: You can't detect it reliably period.
17:19:47 <pumpkin> it does make sense
17:19:52 <pumpkin> I don't get the point of doing fix error though
17:20:09 <pumpkin> > fix (\x -> x)
17:20:19 <mauke> bottom
17:20:22 <pumpkin> :P
17:20:24 <lambdabot>   thread killed
17:20:25 <zooko> Igloo: did you get my uploads of the output from "make" when I was trying to build ghc-6.10.1 on two different machines and it failing in two different ways?
17:20:28 <dolio> Ezla: isInfinite l@(_:t) = reallyUnsafePointerEquality# l t ; isInfinite _ = False.
17:20:44 <Ezla> wtf
17:20:44 <zooko> If so, could you please send those URLs back to me?  :-)  I'm trying to report a bug on the ghc trac about this.
17:20:49 <dolio> But that doesn't really detect many infinite lists.
17:20:50 <centrinia> > let { xs = [1..100]; n = 10; slide op d n xs = scanl op (foldl (\acc x -> op acc (d,x)) d (take n xs)) (zip xs (drop n xs)) } in slide (\acc (o,i) -> acc - o + i) 0 20 [1..40]
17:20:52 <lambdabot>   [210,230,250,270,290,310,330,350,370,390,410,430,450,470,490,510,530,550,57...
17:20:54 <dolio> If any at all.
17:20:58 <Ezla> lol
17:21:03 <centrinia> Okay, I think slide does the job. :)
17:21:04 <Ezla> If any at all.
17:21:12 <zooko> Igloo: actually I already have this one: http://testgrid.allmydata.org:3567/uri/URI%3ACHK%3Alu4jyzcuktl7zkwazpgfotao6i%3Ar2olzx7x6ga2y5sbd533xi7qe24xd7k2wjr35vxzsywdzks33bpa%3A3%3A10%3A985759
17:21:33 <centrinia> > let { xs = [1..100]; n = 10; slide op d n xs = scanl op (foldl (\acc x -> op acc (d,x)) d (take n xs)) (zip xs (drop n xs)) } in slide (\acc (o,i) -> i:(delete o acc)) [] 20 [1..40]
17:21:34 <lambdabot>       Occurs check: cannot construct the infinite type: b = [b]
17:21:35 <lambdabot>        Expect...
17:21:43 <mauke> isInfinite = liftM2 (==) length (length . tail)
17:21:51 <pumpkin> lol
17:21:58 <zooko> Hm, seems to be the same error as this person had: http://www.nabble.com/Trouble-installing-ghc-6.10.1-on-linux-tt20419532.html#a20419532
17:22:20 <pumpkin> centrinia: so I was thinking about other "running" operations, mean, median, variance, etc.
17:22:23 <Ezla> If I have an infinite list, using the 'length' function will hang. How can I check for "max recurse depth"
17:22:38 <mauke> Ezla: no.
17:22:38 <Ezla> I only care to know if it's more than 1000 elements
17:22:44 <Ezla> Impossible?
17:22:45 <mauke> null . dro 1000
17:22:49 <mauke> null . drop 1000
17:22:56 <Ezla> k
17:23:03 <SamB> not . null . drop 1000
17:23:06 <SamB> actually ;-P
17:23:09 <Ezla> good
17:23:21 <dons> > null . drop 1000 $ [1..]
17:23:23 <lambdabot>   False
17:23:26 <dons> > null . drop 1000 $ [1..999]
17:23:28 <lambdabot>   True
17:23:39 <SamB> > null . drop 1000 $ [1..1000]
17:23:41 <lambdabot>   True
17:23:45 <SamB> > null . drop 1000 $ [1..1001]
17:23:46 <lambdabot>   False
17:23:49 <dons> yay for doing the minimal amount of evaluation possible
17:23:50 <Ezla> I wonder what the bots threshhold for pain is :P
17:23:58 <dons> it has a good tolerance
17:24:04 <SamB> > null . drop 10000000 $ [1..]
17:24:04 <Ezla> > null . drop 10000000 $ [1..1001]
17:24:07 <lambdabot>   True
17:24:14 <Cale> Or you could get the nat library from Hackage and use the length it provides.
17:24:18 <Ezla> oops
17:24:19 <zooko> Igloo: you suggested appending "-v" or "-v 3" to the cabal-bin command.  The former doesn't change the behavior, the latter says "cabal-bin: Unrecognised flags: 3".
17:24:26 <centrinia> > let { slide op d n xs = scanl op (foldl (\acc x -> op acc (d,x)) d (take n xs)) (zip xs (drop n xs)) } in slide (\acc (o,i) -> i:(delete o acc)) 0 20 [1..40]
17:24:28 <Cale> (but it would be a bit much just for that ;)
17:24:33 <SamB> damn incoherent ordering
17:24:43 <Ezla> did your result ever come?
17:24:52 <centrinia> Hmm.
17:24:53 <Ezla> > null . drop 10000000 $ [1..]
17:24:53 <lambdabot>   mueval: Prelude.read: no parse
17:24:59 <lambdabot>       Occurs check: cannot construct the infinite type: b = [b]
17:24:59 <lambdabot>        Expect...
17:25:10 <SamB> I think that "no parse" was mine, yes ?
17:25:32 <Ezla> Cale: What length would Nat provide for [1..]
17:25:32 <centrinia> > null . (drop 1000) $ [1..]
17:25:59 <Cale> Ezla: an infinite lazy Nat.
17:26:16 <daf> lazy lengths for lazy lists
17:26:20 <Ezla> k
17:26:25 <mauke> length = id
17:26:34 <daf> (desperate times call for desperate measures?)
17:26:43 <centrinia> pumpkin: The median will require another map.
17:26:57 <ddarius> Desoparate  measures call for desparate times.
17:26:58 <centrinia> Or another search tree.
17:27:47 <centrinia> So which came first: desparate measures or disparate times?
17:27:56 <centrinia> ... or desparate times?
17:28:10 <Ezla> E = disparate times
17:28:45 * pumpkin lost his mandelbrot :(
17:28:52 <centrinia> You had a mandelbrot?
17:28:56 <pumpkin> yeah :(
17:29:00 <lambdabot>   thread killed
17:29:08 <pumpkin> I @let it in here but it got undefined :(
17:29:13 <centrinia> Okay, whose expression killed the thread?
17:29:14 * pumpkin iz sad
17:29:22 <SamB> pumpkin: have you checked the logs ?
17:29:46 <pumpkin> SamB: I'll live, I can write it again :)
17:29:51 <pumpkin> but are there centralized logs somewhere?
17:30:03 <pumpkin> I might've @let it in a pm though
17:30:05 <pumpkin> can't remember
17:30:27 <lambdabot>   False
17:30:37 <pumpkin> wow lambdabot's lagged
17:31:56 <joelr1> good evening
17:32:09 <centrinia> > let mandel i n (x',y') (x,y) = if (x^2+y^2 > 4.0) || (i>=n) then i else mandel (i+1) (x',y') (x^2-y^2+x',2.0*x*y+y') in [mandel 0 255 (x',0.02) (0.0,0.0) | x' <- [-2.0,-1.9..-1.5]]
17:32:10 <lambdabot>   Not in scope: `..-'
17:32:15 <zooko> Okay, I attempted to post to haskell-cafe about my problems.
17:32:19 <zooko> Later, folks!
17:32:23 <centrinia> > let mandel i n (x',y') (x,y) = if (x^2+y^2 > 4.0) || (i>=n) then i else mandel (i+1) (x',y') (x^2-y^2+x',2.0*x*y+y') in [mandel 0 255 (x',0.02) (0.0,0.0) | x' <- [(-2.0),(-1.9)..(-1.5)]]
17:32:24 <lambdabot>   Couldn't match expected type `(t, t)'
17:32:24 <pumpkin> centrinia: mine was cooler, I was proud for using iterate
17:32:34 <centrinia> :t iterate
17:32:35 <lambdabot> forall a. (a -> a) -> a -> [a]
17:32:56 <centrinia> Wait, what were you generating?
17:33:04 <joelr1> dons: hi don! would you know lennart's current email address?
17:33:17 <pumpkin> centrinia: just telling you if a given complex was in the set or not
17:33:34 <centrinia> > let mandel i n (x',y') (x,y) = if (x^2+y^2 > 4.0) || (i>=n) then i else mandel (i+1) n (x',y') (x^2-y^2+x',2.0*x*y+y') in [mandel 0 255 (x',0.02) (0.0,0.0) | x' <- [(-2.0),(-1.95)..(-1.7)]]
17:33:35 <pumpkin> actually, it may have been between 1 or 0, can't remember
17:33:35 <lambdabot>   [1,5,7,6,8,13,9]
17:33:55 <Ezla> Why can't lists support reversed ranges?
17:34:00 <centrinia> > let mandel i n (x',y') (x,y) = if (x^2+y^2 > 4.0) || (i>=n) then i else mandel (i+1) n (x',y') (x^2-y^2+x',2.0*x*y+y') in [mandel 0 255 (x',0.0002) (0.0,0.0) | x' <- [(-2.0),(-1.95)..(-1.7)]]
17:34:02 <lambdabot>   [1,13,14,17,16,255,17]
17:34:08 <mauke> > [10, 9 .. 3]
17:34:10 <lambdabot>   [10,9,8,7,6,5,4,3]
17:34:10 <Ezla> > [10 .. 0]
17:34:11 <lambdabot>   []
17:34:21 <pumpkin> Ezla: you need to give it a negative delta
17:34:36 <centrinia> > let mandel i n (x',y') (x,y) = if (x^2+y^2 > 4.0) || (i>=n) then i else mandel (i+1) n (x',y') (x^2-y^2+x',2.0*x*y+y') in [mandel 0 255 (x',0.000002) (0.0,0.0) | x' <- [(-2.0),(-1.98)..(-1.9)]]
17:34:38 <lambdabot>   [1,18,22,27,20,26]
17:34:53 <centrinia> > let mandel i n (x',y') (x,y) = if (x^2+y^2 > 4.0) || (i>=n) then i else mandel (i+1) n (x',y') (x^2-y^2+x',2.0*x*y+y') in [mandel 0 255 (x',0.000002) (0.0,0.0) | x' <- [(-2.0),(-1.99)..(-1.9)]]
17:34:54 <Ezla> pumpkin: why does that matter?
17:34:55 <lambdabot>   [1,17,18,19,22,19,27,21,20,21,26]
17:35:13 <pumpkin> Ezla: it assumes the range is increasing unless you specify otherwise, dunno why :)
17:35:27 <mauke> pumpkin: basic sanity
17:35:32 <Ezla> sanity how?
17:35:40 <mauke> so you can get an empty list
17:35:44 <dons> joelr1: yeah. gimme a sec.
17:35:50 <Ezla> mauke: ?
17:36:01 <daf> it's less surprising when the second bound is a variable
17:36:26 <centrinia> Can you even determine if two instances of instances of the Enum class are in some partial order?
17:36:37 <pumpkin> didn't someone define a ... in here once that did neat pattern extension for polynomial sequences?
17:36:54 <Ezla> :t ...
17:36:55 <lambdabot> parse error on input `...'
17:36:59 <Ezla> heh
17:37:03 <centrinia> :t enum
17:37:04 <lambdabot> Not in scope: `enum'
17:37:14 <centrinia> @info Enum
17:37:15 <lambdabot> Enum
17:37:22 <centrinia> That's useful. :)
17:37:37 <Ezla> mauke: Why would assuming increasing order matter for [] ?
17:37:49 <gwern> ew. man yi's build is now ugly as hell w/r/t -wall
17:37:57 <mauke> Ezla: huh?
17:38:16 <Ezla> > [1,9..13]
17:38:17 <lambdabot>   [1,9]
17:38:30 <Ezla> Why can't you use multiple ranges without ++ ?
17:38:46 <Toxaris> Ezla: multiple ranges?
17:38:58 <mauke> probably because they wanted to keep the desugaring simple
17:39:05 <centrinia> > ([1..7] ++ [8..14]) == [1..14]
17:39:06 <Ezla> > [1..5,6..10]
17:39:07 <lambdabot>   True
17:39:07 <lambdabot>   <no location info>: parse error on input `,'
17:39:34 <centrinia> > ([1..5] ++ [6..10]) == [1..10]
17:39:35 <lambdabot>   True
17:39:39 <Ezla> <Ezla> sanity how?
17:39:39 <Ezla> <mauke> so you can get an empty list
17:39:43 <centrinia> I don't understand the problem?
17:39:46 <Ezla>  how would this influence "getting an empty list"
17:39:49 <Ezla> what Do you mean.
17:39:52 <mauke> > [2 .. 1]
17:39:54 <lambdabot>   []
17:40:06 <mauke> otherwise you could never get an empty list from [x .. y]
17:40:18 <Ezla> why would I want that?
17:40:20 <Ezla> for sets?
17:40:34 <centrinia> @let definiteRange a b = [a..b] ++ [b..a]
17:40:36 <lambdabot>  Defined.
17:40:44 <centrinia> > definiteRange 2 1
17:40:45 <lambdabot>   [1,2]
17:40:48 <Toxaris> > let f x = [1 .. x] in [f 2, f 1, f 0]
17:40:50 <lambdabot>   [[1,2],[1],[]]
17:40:51 <mauke> why would you not want that?
17:40:59 <Ezla> mauke: Need use case
17:41:01 <centrinia> > definiteRange True False
17:41:02 <lambdabot>   [False,True]
17:41:08 <mauke> Ezla: you first
17:41:13 <Toxaris> Ezra: see how [1 .. 0] = [] makes sense in my example?
17:41:20 <centrinia> > definiteRange 1 0
17:41:22 <lambdabot>   [0,1]
17:41:26 <Ezla> yes, thanks Toxaris
17:41:52 <pumpkin> > [1, 3 ..]
17:41:53 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
17:42:00 <pumpkin> > scanl (+) 0 [1, 3 ..]
17:42:01 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,...
17:42:02 <Ezla> However
17:42:15 <pumpkin> I always enjoy doing that
17:42:21 <pumpkin> dunno why, probably because I'm simple
17:42:23 <centrinia> @let definiteStepRange a s b = [a,s..b] ++ [b,s..a]
17:42:24 <lambdabot>  Defined.
17:42:29 <Ezla> Toxaris: In your example, it could have been [[1,2],[1],[1,0]]
17:42:40 <centrinia> > definiteStepRange 1 3 10
17:42:41 <lambdabot>   [1,3,5,7,9,10,3]
17:42:45 <centrinia> > definiteStepRange 10 3 1
17:42:46 <lambdabot>   [10,3,1,3,5,7,9]
17:42:52 <Toxaris> Ezla: indeed, which would make sense, too
17:42:54 <centrinia> Weird.
17:43:04 <Toxaris> Ezla: so one has to chose one of them
17:43:08 <centrinia> Okay, definiteStepRange is bad.
17:43:28 <Ezla> Toxaris: But that doesn't prove the rationale for Plan A
17:43:28 <ddarius> > let f ^ n = foldr (.) id $ replicate n f in (scanl (+) 0 ^ 2) [1,3..]
17:43:30 <lambdabot>   [0,0,1,5,14,30,55,91,140,204,285,385,506,650,819,1015,1240,1496,1785,2109,2...
17:43:44 <Ezla> I need the canon proof
17:43:54 <mauke> Ezla: it's compatible with perl
17:43:56 <Toxaris> Ezla: I like the choice, it gives clean semantics to array-slicing like things. [a .. b] gives me all indices which are bigger then a and smaller then b
17:43:58 <Ezla> oh god
17:44:07 <Toxaris> Ezla: independently of a and b
17:44:55 <Ezla> perl can still eat food and survive for weeks even with its head removed
17:45:17 <Toxaris> Haskell too, the head is lazy, and as long as it is not needed for functioning there is no problem
17:45:26 <mauke> preflex: quote preaction
17:45:26 <preflex>  <preaction> [in #perl] don't be too proud of that syntactical terror you've constructed
17:45:41 <Ezla> Toxaris: Sure, but
17:45:44 <Ezla> It seems less generic
17:45:56 <Ezla> If you know there's going to be a reverse possible case
17:46:02 <Ezla> you have to write some branch
17:46:03 <shapr> heh
17:46:10 <mauke> now we're in PHP territory
17:46:34 <mauke> why have both arrays and dictionaries? IT'S LESS GENERIC
17:46:37 <Toxaris> Ezla: if you want the "your" behaviour with the current semantics?
17:46:39 <adimit> hm. How can it be that +RTS -p reports 350 MB allocated, while -s reports 2 MB allocated?
17:46:58 <Ezla> "your" behaviour?
17:47:00 <centrinia> > head $ (sum $ repeat 1):[1..10]
17:47:10 <adimit> and -hd says 400 KB
17:47:14 <Toxaris> Ezla: the behaviour you proposed, with [1..0] == [1, 0]
17:47:19 <centrinia> > tail $ (sum $ repeat 1):[1..10]
17:47:21 <lambdabot>   mueval: Prelude.read: no parse
17:47:26 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
17:47:36 <Ezla> > [1,0]
17:47:37 <lambdabot>   [1,0]
17:47:50 <Gracenotes> silly novice question: why does ghci accept "let X = A in Y", but not "Y where X = A"?
17:47:52 <Ezla> Toxaris: ?
17:48:28 <ddarius> Gracenotes: Because the former is an expression, the latter is a syntax error.
17:48:35 <centrinia> Ezla: Use ( definiteRange a b) if you want (definiteRange a b == definiteRange b a)
17:48:59 <johnnowak> > let x = a where a = 5
17:48:59 <centrinia> Where does one use where?
17:49:00 <lambdabot>   <no location info>: parse error on input `;'
17:49:10 <johnnowak> argh
17:49:15 <centrinia> > let x = a in x where { a = 5 }
17:49:16 <lambdabot>   5
17:49:20 <pumpkin> > let (...) = definiteRange in 5 ... 1
17:49:21 <Toxaris> Ezla: My understanding is that you asked: "why is [1 .. 0] == [] instead of [1, 0]", so I'm calling a definition of [ .. ] where [1 .. 0] == [1, 0] Ezra's behaviour
17:49:21 <centrinia> > let x = a in x where a = 5
17:49:22 <lambdabot>   [1,2,3,4,5]
17:49:22 <lambdabot>   5
17:49:31 <centrinia> Hmm.
17:49:31 <mauke> > a where a = b; b = 2
17:49:33 <lambdabot>   2
17:49:37 <pumpkin> centrinia: it'd be nice if it did it backwards
17:49:47 <johnnowak> > let x = a where a = 5 in x
17:49:49 <lambdabot>   5
17:49:49 <centrinia> pumpkin: Do what backwards?
17:49:51 <Toxaris> Ezla: hmm, sorry, Ezla's, of course, whatever
17:49:55 * Toxaris looks confused around
17:50:03 <adimit> Gracenotes: in GHCi you're basically inside an IO monad. so just saying foo = bar doesn't workfor the same reasons it doesn't inside an IO monad.
17:50:22 <pumpkin> > let (...) a b = [a..b] ++ [b, b - 1 .. a] in 5 ... 1
17:50:23 <lambdabot>   []
17:50:25 <centrinia> @check \x y -> definiteStep x y == definiteStep y x
17:50:26 <lambdabot>   Not in scope: `definiteStep'Not in scope: `definiteStep'
17:50:27 <pumpkin> whee, I fail
17:50:44 <pumpkin> > let (...) a b = [a..b] ++ [a, a - 1 .. b] in 5 ... 1
17:50:45 <lambdabot>   [5,4,3,2,1]
17:50:47 <Ezla> Toxaris: yes I understand.. but what were you saying?
17:50:48 <Gracenotes> okay. Still working on monads, but this helps. thanks :)
17:50:50 <pumpkin> > let (...) a b = [a..b] ++ [a, a - 1 .. b] in 1 ... 5
17:50:51 <mauke> s/IO monad/do block/
17:50:52 <lambdabot>   [1,2,3,4,5]
17:51:06 <Ezla> re: that behaviour
17:51:18 <Gracenotes> hm.
17:51:22 <pumpkin> > let (...) a b = [a..b] ++ [a, a - 1 .. b] in 10...5
17:51:24 <Toxaris> seems like the semantical notion of monad became a syntactical notion: being inside a monad meaning being in the scope of do
17:51:24 <lambdabot>   [10,9,8,7,6,5]
17:51:32 <ddarius> Gracenotes, adimit: That's not particularly relevant.  GHCi accepts expressions (and statements).  x = a is a declaration, not an expression or a statement.
17:51:43 <adimit> mauke: uh, yes. Thanks for the correction. I should probably be going to bed, instead of profiling code.
17:51:58 <johnnowak> > let x = a where a = x where x = 5 in x
17:52:00 <lambdabot>   5
17:52:01 <pumpkin> centrinia: like that :)
17:52:42 <adimit> ddarius: ok, thanks for the clarification. :-)
17:53:07 <Gracenotes> ddarius: okay. so in the case of "let X = A in Y", the phrase in its entirely is a statement, but not the X = A subpart?
17:53:18 <Toxaris> Ezla: actually, I don't know what I was saying.
17:53:25 <Ezla> k
17:53:29 <centrinia> > let { a ... b = \i -> filter ( a # b ) map (*i) ([a..b] ++ [b..a]); a # b = if a > b then b # a else \x -> a <= x && x <= b } in 1 ... 100 $ 5
17:53:31 <lambdabot>   Couldn't match expected type `[a]'
17:53:39 <centrinia> > let { a ... b = \i -> filter ( a # b ) map (*i) ([a..b] ++ [b..a]); a # b = if a > b then b # a else \x -> a <= x && x <= b } in (1 ... 100) $ 5
17:53:40 <lambdabot>   Couldn't match expected type `[a]'
17:53:41 <Gracenotes> an expression, rather. still juggling terminology
17:53:42 <ddarius> Gracenotes: The phrase in its entirety is an expression, the X = A part is a declaration within that expression.
17:53:57 * Gracenotes nods
17:54:14 <centrinia> :t let { a ... b = \i -> filter ( a # b ) map (*i) ([a..b] ++ [b..a]); a # b = if a > b then b # a else \x -> a <= x && x <= b } in (1 ... 100)
17:54:17 <lambdabot>     Couldn't match expected type `[a]'
17:54:17 <lambdabot>            against inferred type `(a1 -> b) -> [a1] -> [b]'
17:54:17 <lambdabot>     In the second argument of `filter', namely `map'
17:54:24 <ddarius> "let x = a" would be a statement as would "a <- m".
17:54:44 <centrinia> > let { a ... b = \i -> filter ( a # b ) $ map (*i) ([a..b] ++ [b..a]); a # b = if a > b then b # a else \x -> a <= x && x <= b } in (1 ... 100) $ 5
17:54:46 <lambdabot>   [5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100]
17:54:50 <centrinia> Yay!
17:55:02 <pumpkin> centrinia: does it go backwards? :P
17:55:07 <centrinia> > let { a ... b = \i -> filter ( a # b ) $ map (*i) ([a..b] ++ [b..a]); a # b = if a > b then b # a else \x -> a <= x && x <= b } in (1 ... 100) $ (-5)
17:55:09 <lambdabot>   []
17:55:11 <centrinia> No. :(
17:55:17 <pumpkin> centrinia: I mean 100 ... 1
17:55:21 <Ezla> why doesnt this work?
17:55:24 <pumpkin> @let (...) a b = [a..b] ++ [a, a - 1 .. b]
17:55:26 <lambdabot>  Defined.
17:55:27 <Ezla> > let f x y = if x <= y then [x .. y] else [y .. x] in f 10 1
17:55:27 <centrinia> > let { a ... b = \i -> filter ( a # b ) $ map (*i) ([a..b] ++ [b..a]); a # b = if a > b then b # a else \x -> a <= x && x <= b } in (100 ... 1) $ (10)
17:55:29 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
17:55:29 <lambdabot>   [10,20,30,40,50,60,70,80,90,100]
17:55:35 <pumpkin> centrinia: fail1
17:55:40 <centrinia> Hmm.
17:55:49 <pumpkin> > epic fail
17:55:50 <lambdabot>       Overlapping instances for Show (b -> String -> m a)
17:55:50 <lambdabot>        arising from...
17:55:57 <Ezla> Obviously, its not "supposed" to work
17:56:04 <Ezla> but should produce empty set
17:56:08 <Ezla> however, it will not do so
17:56:08 <pumpkin> > (100..90)
17:56:10 <lambdabot>   <no location info>: parse error on input `..'
17:56:11 <pumpkin> > (100...90)
17:56:13 <lambdabot>   [100,99,98,97,96,95,94,93,92,91,90]
17:56:48 <Toxaris> Ezla: the code you posted seems to work
17:56:54 <centrinia> I think the (#) operator is more useful. :)
17:57:01 <pumpkin> centrinia: I like my tripledot
17:57:07 <pumpkin> kthx
17:57:31 <mbz> :t (#)
17:57:32 <lambdabot> parse error on input `)'
17:57:51 <centrinia> :t let { a # b = if a > b then b # a else \x -> a <= x && x <= b } in ( # )
17:57:52 <lambdabot> forall a. (Ord a) => a -> a -> a -> Bool
17:58:28 <Ezla> what's the "precursor" form of 'succ'
17:58:31 <pumpkin> pred
17:58:40 <Ezla> Ok, how do I find that out without asking on IRC
17:58:50 <centrinia> Too bad (pred . succ), (succ . pred), and id are not the same. :(
17:58:57 <Toxaris> Ezla: do you know hoogle?
17:59:01 <Ezla> hop
17:59:10 <centrinia> @hoogle pred
17:59:11 <lambdabot> Prelude pred :: Enum a => a -> a
17:59:11 <lambdabot> Test.HUnit.Base class AssertionPredicable t
17:59:11 <lambdabot> Test.HUnit.Base type AssertionPredicate = IO Bool
17:59:15 <Ezla> where h is for haskell
17:59:17 <Ezla> hope
17:59:18 <Ezla> nope
17:59:21 <johnnowak> centrinia: why would they be the same?
17:59:24 <pumpkin> @hoogle (Enum a) => a -> a
17:59:24 <lambdabot> Prelude pred :: Enum a => a -> a
17:59:25 <lambdabot> Prelude succ :: Enum a => a -> a
17:59:25 <lambdabot> Prelude id :: a -> a
17:59:26 <Toxaris> Ezla: http://haskell.org/hoogle/
17:59:29 <centrinia> johnnowak: No reason.
17:59:35 <Toxaris> Ezla: you can search for types, or for function names
17:59:51 <Ezla> > let f x y = if x <= y then [x .. y] else [x, pred x .. y] in f 10 1
17:59:52 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
17:59:53 <centrinia> @hoogle a -> a
17:59:53 <lambdabot> Prelude id :: a -> a
17:59:53 <lambdabot> Data.Function id :: a -> a
17:59:53 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
18:00:10 <Toxaris> Ezla: e.g. you can search for succ, look at its documentation and see pred right next to it
18:00:26 <Ezla> Toxaris: k neat
18:00:34 <pumpkin> searching by types is really fun though
18:00:49 <shapr> truly
18:01:02 <Toxaris> Ezla: or you search for pred's type, Enum a => a -> a, and find pred as first result
18:01:16 <pumpkin> that's what I did up there :)
18:01:23 <Ezla> How do you make ranges with an increment value?
18:01:31 <Toxaris> ohh yeah soory.
18:01:34 <pumpkin> > [1,3 .. 20]
18:01:35 <Ezla> transform the list?
18:01:36 <lambdabot>   [1,3,5,7,9,11,13,15,17,19]
18:01:38 <Ezla> k
18:01:47 <pumpkin> so the increment is implicit
18:02:02 <Ezla> So thats why you need to do so for reversed
18:02:05 <pumpkin> yeah
18:02:13 <Cale> It would be cool if it took more elements at the beginning and did polynomial interpolation
18:02:36 <pumpkin> Cale: that's what I was asking earlier... I vaguely remember someone having defined a ... in here (with @let) at one point that did that
18:02:36 <Toxaris> Cale: well, more like whatever-is-appropriate interpolation
18:02:47 <pumpkin> Toxaris: that sounds harder :P
18:02:50 <Toxaris> Cale: depends on the Enum instance, I would say
18:03:02 <Toxaris> pumpkin: not appropriate for the given values, just for the given types
18:03:05 <pumpkin> oh
18:03:06 <Cale> Toxaris: Oh, I suppose that is true.
18:03:24 <Ezla> Can .. do anything that would be impossible with a library version?
18:03:27 <Cale> Toxaris: Could have another typeclass to handle the more complex cases.
18:03:28 <Toxaris> but then we want newtypes to select other interpolations for numbers
18:03:51 <Cale> Toxaris: Since polynomial interpolation is probably not appropriate for non-Fractional stuff.
18:04:05 <Toxaris> Ezla: no
18:04:21 <Toxaris> Ezla: well, you can't have the [ .. ] syntax, but otherwise, its just library
18:04:25 <Ezla> So your own version could 'play' in pattern matches?
18:04:52 <Toxaris> Ezla: ? you cannot use .. in patterns
18:05:19 <Toxaris> and then we are in newtype hell once again
18:05:20 <Ezla> Why not?
18:05:33 <Toxaris> because its basically a function call, and you cant pattern match against functions
18:05:40 <Ezla> However
18:05:47 <Ezla> How would your Owntype be able to do
18:05:55 <Ezla> A, B ... C
18:06:04 <Ezla> if its infix for B and C
18:06:11 <mauke>      you can't have the [ .. ] syntax
18:06:14 <Ezla> k
18:06:16 <Toxaris> yeah, that syntax would not be possible
18:06:39 <mauke> @undo [a, b .. c]
18:06:39 <lambdabot> [a, b .. c]
18:06:39 <Ezla> didnt someone emulate  "unbalanced infix" somehow?
18:06:54 <Toxaris> but you could use two infix operators, which together implement   [a, b .. c]
18:07:15 <Ezla> [(a, b) ... c]
18:07:33 <Toxaris> or that one, without brackets, though
18:07:38 <Cale> Is this the whole "remove special meaning of commas" thing again? :)
18:08:01 <Ezla> Cale: I didn't know that was a thing
18:08:13 <Ezla> sounds good though
18:08:15 <Ezla> Perhaps
18:08:19 <Ezla> a good minefield
18:08:20 <Toxaris> there is   forall a . Special a => remove special meaning of a   thing
18:08:46 <SamB> I want to remove the special meaning of
18:08:51 <Ezla> haha
18:08:53 <Cale> Oh, someone suggested removing the list syntax [1,2,3] in favour of just writing 1:2:3:[], but that means that things like list comprehensions and this interpolation syntax are a bit out of place.
18:09:38 <Ezla> But, [1,2,3] "feels" good in that visually it appears to enclose the set
18:09:42 <centrinia> > [1 ... 5] -- Hmm.
18:09:44 <lambdabot>   [[1,2,3,4,5]]
18:09:54 <centrinia> Why is the triple period still defined? :|
18:10:13 <pumpkin> centrinia: cause I defined it!
18:10:14 <Cale> centrinia: Someone defined it?
18:10:15 <SamB> @type (...)
18:10:16 <lambdabot> forall a. (Enum a, Num a) => a -> a -> [a]
18:10:24 <Cale> We could @undefine
18:10:30 <Toxaris> why does (...) needs Num?
18:10:34 <centrinia> @undefine definiteRange
18:10:43 <SamB> good question
18:10:43 <pumpkin> don't undefine my ... :(
18:10:47 <pumpkin> I'll be sad
18:10:51 <Toxaris> I don't think @undefine takes arguments
18:10:54 <centrinia> Toxaris: pumpkin used the subtraction operator to compute the step. :(
18:10:58 <pumpkin> oh
18:10:59 <Cale> centrinia: That'll just undefined everything. @undefine doesn't take args.
18:11:00 <pumpkin> sowwy
18:11:01 <centrinia> > [1 ... 6] -- Hmm.
18:11:02 <lambdabot>   Not in scope: `...'
18:11:06 <Cale> er, s/That'll/That/
18:11:17 <centrinia> Sorry pumpkin. :)
18:11:24 <pumpkin> it was wrong anyway
18:11:27 <pumpkin> I shouldn't have done - 1
18:11:50 <centrinia> @let a ... b = [a..b] ++ [b..a]
18:11:51 <lambdabot>  Defined.
18:11:55 <centrinia> @type (...)
18:11:56 <lambdabot> forall a. (Enum a) => a -> a -> [a]
18:12:00 <centrinia> Better. :)
18:12:04 <Toxaris> > 0 ... 0
18:12:05 <lambdabot>   [0,0]
18:12:10 <centrinia> Or worse. :(
18:12:25 <pumpkin> centrinia: that fails
18:12:29 <pumpkin> mine was special
18:12:30 <Ezla> proper ... should accept a ... b  or  (a, b) ... c
18:12:49 <Ezla> or  a ... (b, c)
18:13:06 <pumpkin> centrinia: mine gave the list in descending order if b < a
18:13:08 <centrinia> @let (a,c) .... b = [a,c..b] ++ [b,c..a]
18:13:09 <lambdabot>  Defined.
18:13:10 * pumpkin weeps
18:13:12 * mauke hands Ezla (=~)
18:13:24 <Toxaris> that would be possible using typeclasses, but its no longer a \bot oneliner :)
18:13:25 <centrinia> > (1,3) .... 10
18:13:26 <lambdabot>   [1,3,5,7,9,10,3]
18:13:34 <Ezla> mauke:  =~ ?
18:13:51 <mauke> it's a regex operator
18:14:00 <Ezla> cool
18:14:20 <arw> looks like you stole that from perl, give it back! :)
18:14:31 <Ezla> haskell reminds me of the future
18:14:37 <centrinia> @let a ..... b = if a == b then [a] else [a..b] ++ (reverse [b..a])
18:14:37 * pumpkin 's head explodes
18:14:38 <lambdabot>  Defined.
18:14:45 <centrinia> > 10 ..... 1
18:14:46 <ozy`> @doc (=~)
18:14:46 <lambdabot> (=~) not available
18:14:47 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
18:14:49 <mauke> arw: Haskell's =~ is even more flexible than Perl's
18:14:50 <centrinia> > 1 ..... 1
18:14:51 <lambdabot>   [1]
18:14:53 <centrinia> > 1 ..... 10
18:14:54 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
18:14:55 <Toxaris> @type (.....)
18:14:56 <lambdabot> forall a. (Eq a, Enum a) => a -> a -> [a]
18:15:02 <Toxaris> centrinia: Eq bad :(
18:15:02 <SamB> @type (=~)
18:15:03 <lambdabot> forall source1 source target. (Text.Regex.Base.RegexLike.RegexContext Regex source1 target, Text.Regex.Base.RegexLike.RegexMaker Regex CompOption ExecOption source) => source1 -> source -> target
18:15:35 <mauke> > "a" =~ "b"
18:15:37 <lambdabot>       No instance for (Text.Regex.Base.RegexLike.RegexContext
18:15:37 <lambdabot>                ...
18:15:41 <mauke> > "a" =~ "b" :: Bool
18:15:43 <lambdabot>   False
18:16:03 <mauke> > "abc" =~ "(.)" :: Bool
18:16:04 <lambdabot>   True
18:16:06 <SamB> > (1, 2) =~ 3 :: Bool
18:16:07 <lambdabot>       No instances for (Text.Regex.Base.RegexLike.RegexMaker
18:16:07 <lambdabot>                 ...
18:16:14 <mauke> > "abc" =~ "(.)" :: [String]
18:16:16 <lambdabot>   ["a","b","c"]
18:16:38 <mauke> > "abc" =~ "(.)" :: (String, [String])
18:16:39 <lambdabot>       No instance for (Text.Regex.Base.RegexLike.RegexContext
18:16:39 <lambdabot>                ...
18:16:42 <mauke> aww
18:16:55 <pumpkin> there, there
18:17:12 <mauke> > "abc" =~ "(.)" :: (String, String, String)
18:17:13 <lambdabot>   ("","a","bc")
18:17:15 <arw> hu? why doesn't "abc" =~ "(.)" :: [String] just return true?
18:17:25 <mauke> arw: because true isn't a list of strings
18:17:35 <Toxaris> arw: because :: [String] asks for a list of strings
18:17:54 <arw> i thought polymorphism on the return type doesn't work?
18:18:03 <Toxaris> arw: sure it does
18:18:07 <mauke> :t read
18:18:08 <lambdabot> forall a. (Read a) => String -> a
18:18:09 <arw> nice.
18:18:18 <mauke> :t return
18:18:19 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
18:18:25 <mauke> :t mempty
18:18:26 <SamB> arw: you must be thinking of C++
18:18:26 <lambdabot> forall a. (Monoid a) => a
18:18:27 <centrinia> @let a ...... b = let { xs = [a..b]; ys = reverse [b..a]; f [] bs = bs; f as bs = as; } in f xs ys
18:18:28 <lambdabot>  Defined.
18:18:33 <Toxaris> arw: even the jvm supports return-type polymorphism
18:18:38 <mauke> :t 0
18:18:39 <lambdabot> forall t. (Num t) => t
18:18:39 <centrinia> @type (......)
18:18:40 <lambdabot> forall a. (Enum a) => a -> a -> [a]
18:18:47 <centrinia> > 1 ...... 10
18:18:47 <gwern> @hoogle MonadInteract
18:18:48 <lambdabot> No results found
18:18:48 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
18:18:50 <centrinia> > 1 ...... 1
18:18:51 <lambdabot>   [1]
18:18:54 <centrinia> > 10 ...... 1
18:18:56 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
18:18:59 <centrinia> There. :)
18:19:00 <Toxaris> (well, return-type method choosing at compile-time)
18:19:35 <Ezla> C++ has something called 'covariant return types'
18:19:39 <arw> SamB: maybe.
18:19:52 <Toxaris> Ezla: Java too.
18:20:11 <Ezla> It only works when you're actually wielding the derived type
18:20:12 <Toxaris> centrinia: [b, pred b .. a] should be bette then reverse [b..a], I guess
18:20:21 <Ezla> not from the baseclass reference/ptr though
18:20:34 <centrinia> Toxaris: Why?
18:20:52 <Toxaris> centrinia: reverse has to read through the whole result list before returning the a
18:20:56 <Ezla> pred b doesnt detect the span
18:21:02 <Ezla> that's not enough
18:21:06 <centrinia> > let { a = 10; b = 1} in let { xs = [a..b]; ys = reverse [b,(pred b),..a]; f [] bs = bs; f as bs = as; } in f xs ys
18:21:07 <lambdabot>   <no location info>: parse error on input `..'
18:21:08 <Toxaris> centrinia: so returning the head of the list becomes linear in the size of the list
18:21:13 <centrinia> > let { a = 10; b = 1} in let { xs = [a..b]; ys = reverse [b,(pred b)..a]; f [] bs = bs; f as bs = as; } in f xs ys
18:21:14 <lambdabot>   []
18:21:33 <centrinia> > let { a = True; b = False} in let { xs = [a..b]; ys = reverse [b,(pred b)..a]; f [] bs = bs; f as bs = as; } in f xs ys
18:21:34 <lambdabot>   * Exception: Prelude.Enum.Bool.pred: bad argument
18:21:38 <centrinia> Epic fail. :(
18:21:45 <centrinia> > True ...... False
18:21:46 <lambdabot>   [True,False]
18:22:06 <ozy`> @type replicate
18:22:07 <lambdabot> forall a. Int -> a -> [a]
18:22:07 <Cale> > zipWith (+) [1..20] [20,19..1]
18:22:08 <lambdabot>   [21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21]
18:22:20 <Toxaris> centrinia: oh I see, bad idea about pred, but using reverse like that in real code would be bad, too
18:22:22 <Cale> > zipWith (+) [1..20] [20,19..1] == replicate 20 21
18:22:23 <lambdabot>   True
18:23:18 <centrinia> @check \n -> (zipWith (+) [1..n] [n..1]) == n*(n+1)
18:23:19 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
18:23:19 <lambdabot>        Expect...
18:23:25 <centrinia> @check \n -> sum (zipWith (+) [1..n] [n..1]) == n*(n+1)
18:23:26 <lambdabot>   "Falsifiable, after 3 tests:\n-3\n"
18:23:50 <centrinia> @check \n -> n < 1 || sum (zipWith (+) [1..n] [n..1]) == n*(n+1)
18:23:51 <lambdabot>   "Falsifiable, after 4 tests:\n2\n"
18:23:52 <Cale> @check \n -> sum (zipWith (+) [1..n] [n,n-1..1]) == n*(n+1)
18:23:54 <lambdabot>   "Falsifiable, after 0 tests:\n-2\n"
18:24:01 <pumpkin> is there a hackage package that factors numbers?
18:24:04 <Toxaris> Ezla: of course covariant return types only work when the static type is below or at the level where the return type was covaried (can one say that?)
18:24:09 <centrinia> @check \n -> n < 1 || sum (zipWith (+) [1..n] [n,n-1..1]) == n*(n+1)
18:24:09 <lambdabot>   "OK, passed 500 tests."
18:24:12 <centrinia> Oh.
18:24:49 <Toxaris> Ezla: because if you have some base type as static type, how can you know whether the instance at runtime will belong to the subhierarchy with the covariantly changed return type, or not?
18:24:51 <Cale> @check \n -> n >= 2 ==> sum (zipWith (+) [1..n] [n,n-1..1]) == n*(n+1)
18:24:52 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
18:24:52 <lambdabot>           ...
18:25:05 <Cale> odd.
18:25:31 <centrinia> @info (==>)
18:25:32 <lambdabot> (==>)
18:25:36 <centrinia> :t (==>)
18:25:37 <ozy`> > \n x -> map n [x..x]
18:25:38 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
18:25:38 <lambdabot>       Overlapping instances for Show ((a -> b) -> a -> [b])
18:25:38 <lambdabot>        arising fr...
18:26:33 <centrinia> @check \n -> True ==> False
18:26:35 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
18:26:35 <lambdabot>           ...
18:26:43 <centrinia> @check \n -> True ==> (\m -> False) m
18:26:44 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
18:26:45 <lambdabot>           ...
18:26:47 <centrinia> @check \n -> True ==> (\m -> False) n
18:26:48 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
18:26:48 <lambdabot>           ...
18:26:53 <centrinia> What?
18:27:02 <centrinia> @check \n -> True ==> (\m -> False)
18:27:03 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
18:27:03 <lambdabot>           ...
18:27:12 <centrinia> I don't understand.
18:27:21 <jfredett> :t (==>)
18:27:21 <Ezla> Toxaris: Whether you know or not, it doesnt matter
18:27:22 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
18:27:26 <Ezla> And you can know, of course.
18:27:44 <jfredett> > True ==> (\m -> False)
18:27:45 <lambdabot>       No instance for (Show Property)
18:27:45 <lambdabot>        arising from a use of `show' at ...
18:27:51 <jfredett> oops
18:27:51 <Ezla> Toxaris: You could fetch a reflection map from the Class, which is a tuple of RTTI template tags
18:27:56 <jfredett> @check True ==> (\m -> False)
18:27:56 <centrinia> :t \n -> True ==> False
18:27:57 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
18:27:58 <lambdabot>           ...
18:27:58 <lambdabot> forall t. t -> Property
18:28:04 <Toxaris> Ezla: know at compile time, of course
18:28:05 <Ezla> At runtime...
18:28:08 <Ezla> However
18:28:17 <Ezla> no matter what happens, you can never cross the compile time divide
18:28:21 <Ezla> without time travel
18:28:24 <shapr> Eh?
18:28:55 <centrinia> > property True
18:28:56 <lambdabot>       No instance for (Show Property)
18:28:56 <lambdabot>        arising from a use of `show' at ...
18:29:07 <Ezla> so, it can't polymorph on returns while working with base T
18:29:42 <SamB> not without /P
18:30:35 <Toxaris> Ezla: return-type polymorphism /= covariant return types
18:30:42 <centrinia> > quickcheck True
18:30:43 <lambdabot>   Not in scope: `quickcheck'
18:30:49 <centrinia> > quickCheck True
18:30:51 <lambdabot>   * Exception: "<IO ()>"
18:31:03 <centrinia> > print "Hello World!"
18:31:04 <lambdabot>   * Exception: "<IO ()>"
18:31:13 <centrinia> Why can't we print anymore? :(
18:31:20 <Ezla> how does Haskell approach to solve this -- haskell has no subtyping
18:31:25 <Toxaris> Ezla: afaik, return-type polymorphism means a form of ad-hoc polymorphism, where the behaviour of the callee depends on the return type the caller wants to get
18:31:34 <centrinia> Haskell has "subtyping."
18:32:04 <Toxaris> Ezla: as in read, for example:
18:32:10 <Toxaris> > read "42" :: Int
18:32:12 <lambdabot>   42
18:32:19 <Toxaris> > read 42 :: Double
18:32:20 <lambdabot>       No instance for (Num String)
18:32:20 <lambdabot>        arising from the literal `42' at <i...
18:32:21 <Cale> Not really subtyping...
18:32:24 <Toxaris> > read "42" :: Double
18:32:25 <lambdabot>   42.0
18:32:32 <centrinia> > read "42" :: String
18:32:33 <lambdabot>   "* Exception: Prelude.read: no parse
18:32:48 <Toxaris> Ezla: depending on the type context at the call site, a different method was called.
18:33:08 <Toxaris> Ezla, centrinia: there are no subtypes in Haskell, just more or less general types
18:33:22 <Toxaris> > read "\"42\"" :: String
18:33:24 <lambdabot>   "42"
18:33:34 <centrinia> > read "\"42\"" :: Integer
18:33:35 <lambdabot>   * Exception: Prelude.read: no parse
18:33:52 <Toxaris> > read (read "\"42\"") :: Integer
18:33:53 <lambdabot>   42
18:34:05 <centrinia> > (return 42) `mplus` (return 0) :: [Int]
18:34:06 <lambdabot>   [42,0]
18:34:10 <centrinia> > (return 42) `mplus` (return 0) :: Maybe Int
18:34:11 <lambdabot>   Just 42
18:35:20 <Ezla> Why can't Haskell detect this problem?
18:35:22 <Ezla> > [ x | x <- [0..], x < 5 ]
18:35:24 <centrinia> > (return 42) `mplus` (return 0) :: ReadP Int
18:35:26 <lambdabot>       Not in scope: type constructor or class `ReadP'
18:35:37 <lambdabot>   thread killed
18:35:39 <centrinia> > (return 42) `mplus` (return 0) :: ReadPrec Int
18:35:41 <lambdabot>       Not in scope: type constructor or class `ReadPrec'
18:36:08 <Ezla> > [ x | x <- [0..], x < 5 ]
18:36:23 <lambdabot>   thread killed
18:36:42 <centrinia> > filter ( < 5) [x | x <- [0..]]
18:36:45 <Ezla> Is there any way to change the order on that?
18:36:48 <dolio> Why can't C++ detect all of your infinite loops?
18:36:57 <lambdabot>   thread killed
18:36:58 <EvilTerran> Ezla, to what?
18:37:12 <centrinia> > takeWhile ( < 5) [x | x <- [0..]]
18:37:15 <lambdabot>   [0,1,2,3,4]
18:37:18 <Ezla> EvilTerran: check each  <5 before evaluatiing the list
18:37:20 <centrinia> Better. :)
18:37:26 <EvilTerran> , [x | x <- [0..], x < 5]
18:37:35 <Toxaris> Ezla: note that the behaviour of that expressions depends on the implementation of the numeric types, so for a somewhat broken implementation, the result list may be different from 0:1:2:3:4:undefined
18:37:38 <lunabot>  Killed.
18:37:50 <EvilTerran> Ezla, how can it check the property without evaluating the elements?
18:38:00 <Ezla> lazyily
18:38:03 <centrinia> Ezla: How does the compiler know that there [x | x <- [5..]] is supposed to be empty?
18:38:05 <EvilTerran> an unevaluated element is abstract
18:38:16 <Toxaris> Ezla: it is lazy
18:38:19 <EvilTerran> (< 5) is abstract at runtime
18:38:37 <Toxaris> > take 4 [x | x <- [0 ..], x < 5]
18:38:40 <lambdabot>   [0,1,2,3]
18:38:45 <EvilTerran> you can't pass an abstract thing to another abstract thing without getting through the abstractions - by evaluating them
18:38:51 <Toxaris> > take 5 [x | x <- [0 ..], x < 5] -- lambdabot evaluates first, prints then
18:38:54 <lambdabot>   [0,1,2,3,4]
18:39:02 <Ezla> can't GHC reduce these list comprehensions when they don't involve any external value?
18:39:06 <Toxaris> > take 6 [x | x <- [0 ..], x < 5] -- lambdabot evaluates first, prints then, and toxaris cannot count
18:39:22 <lambdabot>   thread killed
18:39:22 <EvilTerran> Ezla, not in general
18:39:26 <Ezla> why not?
18:39:27 <Toxaris> Ezla: no it can't, because they are return-type polymorphic
18:39:34 <Ezla> hah
18:39:45 <EvilTerran> Ezla, because program equivalence is undecidable
18:39:48 <Toxaris> Ezla: and how does ghc knows you didn't want to write 0:1:2:3:4:undefined for some stupid reason?
18:40:07 <centrinia> > let {fermat n = null [x^n+y^n == z^n,x<-[2..],y<-[2..],z<-[2..]} in and [fermat n | n <- [3..]]
18:40:10 <lambdabot>   <no location info>: parse error on input `<-'
18:40:15 <centrinia> > let {fermat n = null [x^n+y^n == z^n,x<-[2..],y<-[2..],z<-[2..]]} in and [fermat n | n <- [3..]]
18:40:17 <Ezla> Toxaris: but all known types are known at compile time
18:40:18 <lambdabot>   <no location info>: parse error on input `<-'
18:40:21 <EvilTerran> Ezla, and, if you programmed it to spot common special cases, well, those'd be obvious to do by hand anyway
18:40:24 <Ezla> so what does it matter if its return polymorphic
18:40:28 <centrinia> > let {fermat n = null [x^n+y^n == z^n | x<-[2..],y<-[2..],z<-[2..]]} in and [fermat n | n <- [3..]]
18:40:31 <lambdabot>   False
18:40:39 <centrinia> What the?
18:40:44 <EvilTerran> Ezla, not if it's used in a module separate to where it's defined, and they're compiled separately
18:40:53 <centrinia> > let {fermat n = null [x^n+y^n /= z^n | x<-[2..],y<-[2..],z<-[2..]]} in and [fermat n | n <- [3..]]
18:40:55 <Ezla> ok.
18:40:56 <lambdabot>   False
18:40:59 <Toxaris> EvilTerran: You sound like static analysis and program optimization would be a totally stupid idea :)
18:41:18 <EvilTerran> Toxaris, only that this'd be taking it too far
18:41:19 <Ezla> yeah
18:41:25 <EvilTerran> and it'd only make the semantics more complicated
18:41:45 <Ezla> whole program optimization pre-symbol stripping isnt high science
18:42:03 <centrinia> Ezla: It is.
18:42:22 <Ezla> well, the optimization part is
18:42:41 <Ezla> not the "combine modules during intermediary compilation pass" part
18:43:48 <Toxaris> Ezla: even in a whole-program setting, you can't specialize all polymorphic values at compile-time, because Haskell supports polymorphic recursion
18:43:58 <Ezla> http://google-opensource.blogspot.com/2008/11/whopr-scalable-whole-program-optimizer.html
18:44:42 <Ezla> Toxaris: What's polymorphic recursion?
18:45:29 <Ezla> s/polymorphic recursion/insanity/ in "Haskell supports polymorphic recursion"
18:45:37 * Ezla supports the arts
18:46:27 <mauke> > let f :: Show a => Int -> a -> String; f 0 x = show x; f n x = f (n - 1) (a,a) in f 3 'x'
18:46:30 <lambdabot>   "(a,a)"
18:46:40 <mauke> > let f :: Show a => Int -> a -> String; f 0 x = show x; f n x = f (n - 1) (x,x) in f 3 'x'
18:46:43 <lambdabot>   "((('x','x'),('x','x')),(('x','x'),('x','x')))"
18:47:35 * Toxaris just puzzled together the very same example in the other window ...
18:48:49 <geezusfreeek> ?users
18:48:50 <lambdabot> Maximum users seen in #haskell: 568, currently: 506 (89.1%), active: 19 (3.8%)
18:50:35 <Toxaris> Ezla: the fact that some people are working on something and promising prototypes for sometimes in the futures seems to suggest that this something is high science
18:50:46 <Ezla> Toxaris: :P
18:53:19 <centrinia> Ezla: How can inlining help decide if [x | x <- [5..], x < 5] is empty?
18:53:38 <Ezla> inlining doesnt even make any sense to me in haskell
18:53:43 <Ezla> given the heap thunks
18:54:02 <Ezla> So I can't parse your question at this early stage
18:55:44 <centrinia> > let { f i j = i * (i-j); g x y = x - y } in and [ g (f i j) (f j i) `mod` (i+j) == 0 | i <- [1..], j <- [0..]]
18:55:59 <lambdabot>   thread killed
18:56:04 <centrinia> That doesn't help.
18:56:43 <ozy`> but is that compiled or interpreted?
18:56:44 <dons> Ezla: inlining can really help expose the structure of code to the compiler.
18:56:54 <dons> and since it's pure, the compiler is really aggressive about inlining.
18:57:11 <dons> so that say, the arguments of higher order functions get inlined into the bodies, yielding a tight loop
18:57:16 <dons> with no indirection
18:59:30 <Ezla> I'd like to see a timeline of results for a benchmark suite of the same test compiled in GHC versions circa 1999 through 2008
19:00:01 <Ezla> is it linear?
19:00:27 <centrinia> No, it is quadratic. :p
19:01:06 <luqui> it's exponential, actually, because of moore's law (computers from 1999 were very slow)  ;-)
19:01:15 <Ezla> luqui: Same cpu.
19:01:22 <luqui> twas a joke
19:01:41 <centrinia> Ezla: It should be constant.
19:01:50 <zooko> Folks, when I try to compile darcs it says: http://buildbot.darcs.net/builders/zooko%20yukyuk%20Linux-2.6.24%20Ubuntu-8.04%20amd64/builds/214/steps/configure/logs/stdio
19:01:57 <zooko> checking for module Test.QuickCheck.Test ( quickCheck )... no; and neither in package QuickCheck
19:01:58 <zooko> configure: error: Cannot find Test.QuickCheck.Test; try installing version 2.1 of the Haskell package quickcheck?
19:02:03 <Ezla> centrinia that would not be a good sign
19:02:18 <zooko> When I do "cabal install --user QuickCheck" it says that it is happily installing quickcheck v0.1.2.
19:02:18 <ozy`> centrinia: you don't think any optimization has been introduced to GHC between 1999 and 2008?
19:02:33 <centrinia> It took 0 seconds to complete any task with a program compiled by GHC in 1999. It still takes 0 seconds to complete any task with a program compiled by GHC in 2008. :)
19:02:33 <zooko> But this doesn't change the error message from darcs's ./configure.
19:02:52 <Saizan> zooko: see, darcs wants 2.1, while cabal is installing 0.1.2
19:02:56 <ozy`> centrinia: ...................... wat
19:03:12 <Saizan> zooko: so, ask cabal install for that version
19:03:27 <centrinia> @faq Can any task be completed by a program compiled by GHC in 0 seconds or less?
19:03:28 <lambdabot> The answer is: Yes! Haskell can do that.
19:03:34 <centrinia> See.
19:04:00 <Ezla> s//
19:04:10 <ozy`> s///gm
19:04:30 <zooko> Well, "cabal install --help" doesn't explain the syntax of versioning.  I guessed and tried "cabal install --user --reinstall QuickCheck>=2.1"
19:04:45 <zooko> and it happily reinstalled 0.1.2!  So I guess my syntax guess must have been wrong and it blithely ignored it.
19:05:02 <luqui> or maybe reinstall is busted
19:05:29 <luqui> zooko, you did quote "QuickCheck>=2.1" to avoid a shell redirection, right?
19:05:50 <zooko> oops
19:06:20 <zooko> Indeed -- I redirected stdout into a file named "=2.1".  Thanks, luqui.
19:06:25 <luqui> =)
19:06:35 <zooko> Now it works.  :-)
19:07:58 <dons> zooko: interesting that you figured the cabal binary should explain the syntax of versions. hmm. maybe it should
19:09:27 <Gracenotes> @faq Can I use try/catch blocks?
19:09:28 <lambdabot> The answer is: Yes! Haskell can do that.
19:09:35 <Gracenotes> worth trying >_>
19:10:00 <Saizan> Gracenotes: try is redundant, we only have catch
19:10:08 <ozy`> @faq Can your mom program in Haskell?
19:10:09 <lambdabot> The answer is: Yes! Haskell can do that.
19:10:27 <centrinia> @faq Can Haskell program your mom?
19:10:27 <lambdabot> The answer is: Yes! Haskell can do that.
19:11:07 <Gracenotes> Saizan: heh. I'll see
19:11:46 <centrinia> Is there a way to catch unmatched pattern errors?
19:12:02 <Ezla> > let f x = x + 1 :: (Num a) => a -> a
19:12:03 <lambdabot>   <no location info>: parse error on input `;'
19:12:06 <Ezla> ?
19:12:29 <centrinia> > let f x = x + 1 :: (Num a) => a -> a in f 1
19:12:30 <lambdabot>       Inferred type is less polymorphic than expected
19:12:30 <lambdabot>        Quantified type ...
19:12:43 <centrinia> > let f x = x + 1 in f 1
19:12:44 <lambdabot>   2
19:12:48 <centrinia> :t let f x = x + 1 in f 1
19:12:49 <lambdabot> forall t. (Num t) => t
19:12:50 <Saizan> centrinia: you shouldn't need that, e.g. you could make your function return a Maybe type
19:12:51 <centrinia> :t let f x = x + 1 in f
19:12:53 <lambdabot> forall a. (Num a) => a -> a
19:12:55 <Ezla> why "less polymorphic than expected" ?
19:13:10 <centrinia> > let f x = x + 1 :: forall a. (Num a) => a -> a in f 1
19:13:11 <lambdabot>       Inferred type is less polymorphic than expected
19:13:11 <lambdabot>        Quantified type ...
19:13:18 <centrinia> :t let f x = x + 1 :: forall a. (Num a) => a -> a in f
19:13:19 <lambdabot>     Inferred type is less polymorphic than expected
19:13:19 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
19:13:19 <lambdabot>         x :: a -> a (bound at <interactive>:1:6)
19:13:20 <Ezla> I keep getting that error over and over
19:13:25 <Ezla> on half the stuff I try to do
19:13:26 <Saizan> centrinia: however with Control.Exception.catch you can, but you have to be careful about forcing enough of the value to trigger the error if it's there
19:13:43 <centrinia> :t let f x = x + 1 :: forall a. (Num a) => a in f
19:13:44 <lambdabot>     Inferred type is less polymorphic than expected
19:13:44 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
19:13:44 <lambdabot>         x :: a (bound at <interactive>:1:6)
19:13:47 <Ezla> and stuff thats extremely simple like use of ::
19:13:54 <Ezla> on same line
19:14:16 <Saizan> Ezla: if you use variables in type annotations you probably want ScopedTypeVariables
19:14:26 <centrinia> > let { f :: (Num a) => a -> a; f x = x+1}  in f 1 -- Try this
19:14:27 <lambdabot>   2
19:14:29 <Ezla> oh I see
19:14:33 <Ezla> I forgot...
19:14:33 <Saizan> Ezla: if not they are new implicitly universal quantified variabels
19:14:50 <Ezla> k
19:15:15 <Ezla> However
19:15:46 <Ezla> what if you *want* the same effect of having multiple Signatures which use typeclasses
19:16:03 <goalieca> i gotta figure out some way to incorporate haskell into my work because i'm stuck doing c++ for some open source project and when i get home i'm burnt out and don't want to program more.. even if its haskell
19:16:17 <centrinia> I think there is a typo here: http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#v%3Acatch
19:16:30 <Saizan> Ezla: can you elaborate?
19:17:15 <Saizan> centrinia: where, precisely?
19:17:33 <Ezla> f x = x + 1 :: (Num a) => a -> a
19:17:41 <Ezla> f x = 0 :: (Foo a) => a -> a
19:17:59 <centrinia> catch :: Exception e => IO a -> (e -> IO a) -> IO a, not catch :: Exception e => IO a -> e -> IO a -> IO a
19:18:06 <Ezla> I want the typeclass to cooperate in the pattern
19:18:33 <Saizan> Ezla: you can't match on the typeclass like that, directly at least
19:18:45 <Ezla> why not?
19:18:47 <centrinia> The typo is in the type specification for catch in its own section.
19:19:22 <Saizan> centrinia: ah, yeah, it's actually a bug in haddock's prettyprinter
19:19:47 <Saizan> Ezla: what type would f have? as a whole?
19:19:50 <centrinia> I thought so.
19:20:05 <Ezla> Saizan: a polymorphic type
19:20:13 <Ezla> of the set of all possible typeclass dependent results
19:20:14 <Saizan> Ezla: yeah, but which?
19:20:44 <Saizan> ok, haskell doesn't quantify over typeclasses
19:21:05 <Ezla> I need the anti-rationale canon
19:21:53 <jsn> Saizan: what is an "implicitly universal quantified" variable? i haven't found anything on google, yet...
19:22:03 <zooko> dons: I'm not sure if it "should" or not.
19:22:37 <dolio> jsn: Probably like the type signatures in Hindley-Milner/H98?
19:22:55 <dolio> Where 'a -> b -> c' means 'forall a b c. a -> b -> c'?
19:23:00 <Saizan> jsn: an universal quantified variable is just one introduced by forall a., it's implicitly if the forall is assumed rather than declared
19:23:04 <jsn> dolio: but Saizan says they are "new"
19:23:18 <Saizan> jsn: in the sense of fresh
19:23:20 <jsn> oh
19:23:29 <Saizan> jsn: i.e. not related to any previous variable in scope
19:23:32 <jsn> aha
19:23:50 <jsn> i though there was a new feature that somehow replaced the old one
19:23:58 <olsner> @ty (<*>)
19:23:59 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:28:57 <Saizan> i'm not sure on what to google for something like polymorphism over typeclasses
19:31:59 <centrinia> Okay, this results in the same error for Haddock: http://hpaste.org/12797
19:32:47 <Saizan> yeah, i think it's a known bug, but check on the bug tracker
19:32:51 <Saizan> ?where haddock
19:32:51 <lambdabot> http://www.haskell.org/haddock/
19:33:06 <chessguy> anybody played around with graphs in haskell where you could have different kinds of edges?
19:33:20 <dolio> Oh yeah. That's been around.
19:34:12 <Saizan> it may even be a bug in the ghc-api, iirc
19:35:22 <chessguy> like, if nodes of a graph were the different places on a game map, one type of edge might mean they were connected with a door, and another might mean they were connected with a bridge
19:35:42 <chessguy> (thoroughly contrived)
19:35:54 <Toxaris> sounds like colored edges to me
19:36:35 <Saizan> why not use an union type for the edges?
19:36:52 <jsn> Saizan: what is a union type in haskell?
19:37:08 <Saizan> data Foo = A .. | B .. | C .. | ..
19:37:14 <jsn> ah
19:37:22 <chessguy> Toxaris:  that would work
19:37:32 <chessguy> Toxaris:  heard of any implementations in haskell?
19:37:42 <Saizan> also called discriminated union, or sum type
19:38:05 <chessguy> (or similar)
19:38:51 <Toxaris> chessguy: no, but afaik graphs in Haskell are fairly standard with respect to underlying data structures, using either a adjacence matrix (you could store the color in the matrix) or a adjacence lists (you could store the color in the lists)
19:39:14 <Toxaris> chessguy: so I have no clue whether existing libraries support that, but it shouldn't be a problem, I guess
19:39:27 <chessguy> ok. just wanted to make sure i wasn't missing something obvious
19:40:02 <Saizan> have you looked at Data.Graph.Inductive?
19:40:07 <chessguy> i see Data.Graph is basically Array Vertex [Vertex]
19:40:24 <chessguy> i could just turn that into Array Vertex [(Edge, Vertex)]
19:40:47 <Saizan> (it already supports labels)
19:41:27 <chessguy> Saizan:  oh? i'm not seeing that support.
19:41:30 <chessguy> what am i missing?
19:43:28 <chessguy> actually, i don't see the .Inductive module
19:44:02 <Saizan> oh
19:44:08 <Saizan> they stopped shipping fgl
19:44:13 <Saizan> ?hackage fgl
19:44:13 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fgl
19:44:52 <Toxaris> chessguy: there is a type LEdge with documentation "Labeled Edges"
19:44:54 <chessguy> darn commies
19:44:55 <Saizan> http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/Data-Graph-Inductive-Graph.html#t%3AGraph
19:45:12 <chessguy> gotcha
19:45:28 <chessguy> yeah, i was looking for it on data.graph, thought i'd gone blind for a minute there
19:48:52 <hydo> omg pleac.sf.net/pleac_haskell .. perl cookbook all haskell style.  f-ing bookmarked!
19:52:35 <scrote> lo
19:53:03 <scrote> http://rafb.net/p/aTyVm760.html
19:53:26 <gwern> @pl \_ _ -> return ()
19:53:27 <lambdabot> const (const (return ()))
19:53:42 * gwern doesn't think that's clearer :)
19:53:48 <conal> aka mempty
19:53:54 <gwern> @hoogle mempty
19:53:54 <lambdabot> Data.Monoid mempty :: Monoid a => a
19:53:55 <scrote> like i said, http://rafb.net/p/aTyVm760.html
19:54:09 <gwern> conal: well then I'd need to add an import, which would cost even more chars
19:54:10 <conal> if you have the io monoid instance, e.g., from TypeCompose
19:54:23 <conal> gwern: oh -- don't do that.
19:55:30 <gwern> it's funny how '\_ -> ' costs almost as much as 'const $ '
20:01:41 <chessguy> conal:  :)
20:03:59 <chessguy> conal, i think i've got my representation of patterns with re-usable components. not sure the patterns themselves are all that composable, but that's ok
20:05:02 <shapr> @seen edwardk
20:05:02 <lambdabot> edwardk is in #haskell-blah and #haskell. I last heard edwardk speak 8h 20m 23s ago.
20:07:08 <gwern> @pl \_ _ a -> a
20:07:08 <lambdabot> const (const id)
20:07:21 <gwern> @pl \_ _ _ _ -> []
20:07:21 <lambdabot> const (const (const (const [])))
20:07:25 <gwern> ick
20:08:08 <pumpkin> :t iterate const
20:08:09 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
20:08:09 <lambdabot>     Probable cause: `const' is applied to too few arguments
20:08:09 <lambdabot>     In the first argument of `iterate', namely `const'
20:08:14 <pumpkin> oh boo
20:08:28 <pumpkin> :t iterate $ const 5
20:08:29 <lambdabot> forall a. (Num a) => a -> [a]
20:08:32 <Axman6> :t iterate (const id)
20:08:33 <lambdabot> forall a. (a -> a) -> [a -> a]
20:08:58 <Axman6> > iterate (const id) (+1)
20:08:59 <lambdabot>       Overlapping instances for Show (a -> a)
20:09:00 <lambdabot>        arising from a use of `s...
20:09:09 <Axman6> > iterate (const id) (+1) :: [Expr}
20:09:10 <Axman6> > iterate (const id) (+1) :: [Expr}]
20:09:10 <lambdabot>   <no location info>: parse error on input `}'
20:09:11 <lambdabot>   <no location info>: parse error on input `}'
20:09:12 <Axman6> > iterate (const id) (+1) :: [Expr]
20:09:13 <lambdabot>   Couldn't match expected type `Expr' against inferred type `a -> a'
20:09:16 <Axman6> -_-
20:09:21 <pumpkin> aw
20:09:38 <pumpkin> > iterate (const id) (+x) :: [Expr]
20:09:39 <lambdabot>   Couldn't match expected type `Expr' against inferred type `a -> a'
20:09:43 <Axman6> :t iterate (+1)
20:09:44 <lambdabot> forall a. (Num a) => a -> [a]
20:09:52 <Axman6> > iterate (+1)
20:09:53 <lambdabot>       Overlapping instances for Show (a -> [a])
20:09:54 <lambdabot>        arising from a use of ...
20:10:03 <pumpkin> > iterate (+2) 0
20:10:05 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
20:10:30 <Axman6> > iterate (+1) 0
20:10:32 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
20:11:20 <mbz> ?src iterate
20:11:21 <lambdabot> iterate f x =  x : iterate f (f x)
20:12:23 <Axman6> > iterate f x :: [Expr]
20:12:24 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
20:13:28 <pumpkin> @src fix
20:13:28 <lambdabot> fix f = let x = f x in x
20:13:56 <pumpkin> is fix f the last element of iterate f? :P
20:14:20 <pumpkin> > fix f == last $ iterate f
20:14:21 <pumpkin> :D
20:14:21 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `Bool'
20:14:49 <pumpkin> meaniebot
20:15:41 <roconnor> @type \f -> last . iterate f
20:15:42 <lambdabot> forall a. (a -> a) -> a -> a
20:20:00 <centrinia> > fix (\x -> x - (x^2-2.0) / (2 * x))
20:20:15 <lambdabot>   thread killed
20:20:21 <centrinia> Too bad.
20:20:55 <centrinia> Wait, what is fix good for?
20:21:20 <centrinia> > fix (^2)
20:21:36 <lambdabot>   thread killed
20:21:37 <Riastradh> Generally for nothing but the fixed points of function-generating functions.
20:21:50 <Zao> centrinia: You can make recursive lambdas, which is mind-twistingly fun.
20:21:56 <mbz> > fix (\f n -> if n <= 0 then 1 else n * f(n - 1)) $ 5
20:21:56 <pumpkin> > fix (1:) -- will work
20:21:57 <lambdabot>   120
20:21:58 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
20:21:59 <Riastradh> > fix (\factorial -> \n -> if n < 2 then 1 else n * factorial (n - 1)) 5
20:22:00 <lambdabot>   120
20:22:17 <pumpkin> lol
20:22:56 <centrinia> > fix (\newton -> \x -> if x^2 == 2.0 then x else x - (x^2-2.0) / (2*x) ) 1.0
20:22:57 <lambdabot>   1.5
20:23:15 <centrinia> > fix (\newton -> \x -> if x^2 == 2.0 then x else newton (x - (x^2-2.0) / (2*x) )) 1.0
20:23:30 <lambdabot>   thread killed
20:23:49 <centrinia> > fix (\newton -> \x -> if abs(x^2 - 2.0) < 1e-5 then x else newton (x - (x^2-2.0) / (2*x) )) 1.0
20:23:51 <lambdabot>   1.4142156862745099
20:23:54 <centrinia> There. :)
20:25:15 <mbz> centrinia, http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.15.1543
20:25:35 <centrinia> Thanks.
20:28:48 <mriou> hey, noobie question
20:29:07 <mriou> I'm trying to debug a program I've just written that exits in flames with:
20:29:08 <mriou>  Illegal use of non identifier value in equal ASTBlock [ASTStmt [ASTId "a"]]
20:29:25 <mriou> I have no real clue where this happens
20:29:45 <mriou> any way I can get more information? I run it with runghc
20:30:00 <mriou> would hugs give a line number or something?
20:30:42 <centrinia> > fix (\rho f' n x y -> let { f = (`mod` n) . f' ; d = gcd (abs $ x-y) n } in if d /= 0 then d else rho f n (f x) (f (f y)) ) (\t -> t^2 + 3) 123456789 2 2
20:30:44 <lambdabot>   123456789
20:31:04 <centrinia> > fix (\rho f' n x y -> let { f = (`mod` n) . f' ; d = gcd (abs $ x-y) n } in if (d /= 0) && (d /= n) then d else rho f n (f x) (f (f y)) ) (\t -> t^2 + 3) 123456789 2 2
20:31:06 <lambdabot>   9
20:31:11 <centrinia> Yay. :)
20:31:19 <centrinia> > fix (\rho f' n x y -> let { f = (`mod` n) . f' ; d = gcd (abs $ x-y) n } in if (d /= 0) && (d /= n) then d else rho f n (f x) (f (f y)) ) (\t -> t^2 + 3) 123456791 2 2
20:31:21 <lambdabot>   1
20:31:30 <centrinia> > fix (\rho f' n x y -> let { f = (`mod` n) . f' ; d = gcd (abs $ x-y) n } in if (d /= 1) && (d /= n) then d else rho f n (f x) (f (f y)) ) (\t -> t^2 + 3) 123456791 2 2
20:31:45 <lambdabot>   thread killed
20:32:13 <centrinia> > fix (\rho f' n x y -> let { f = (`mod` n) . f' ; d = gcd (abs $ x-y) n } in if (d /= 0) && (d /= n) then d else rho f' n (f x) (f (f y)) ) (\t -> t^2 + 3) 123456791 2 2
20:32:15 <lambdabot>   1
20:32:55 <fortitude> mriou: if you run the program in ghci, it should give you a line number
20:33:02 <fortitude> though I've noticed that sometimes it can be a bit misleading
20:33:57 <mriou> fortitude: thanks but I tried and I get the exact same error, no line number or anything
20:35:12 <fortitude> mriou: there should be a part that looks like "filename.hs:8:10"; the 8 is the line number
20:35:25 <fortitude> right before the actual error messag
20:35:27 <fortitude> *message
20:35:49 <mriou> *** Exception: Illegal use of non identifier value in equal ASTBlock [ASTStmt [ASTId "a"]]
20:35:56 <mriou> that's the whole thing
20:36:16 <fortitude> I haven't run into one of those yet :/
20:36:49 <mriou> darn. still, thanks for your help
20:37:29 <fortitude> are ASTBlock etc. your types, or could this be a weird "you broke the interpreter" thing?
20:38:22 <mriou> no it's my type
20:39:00 <mriou> the thing is I don't even know if 'equal' in the message refers to '=' or '=='
20:39:30 <mriou> that doesn't help narrowing it down :)
20:40:22 <luqui> mriou, probably '=', why would it be illegal to use a non identifier in '=='?
20:41:01 <mriou> luqui: right but for '=' it would only make sense if it's a lvalue
20:41:34 <lpjhjdh> how can I tell cabal to use a certain version of a package on the command line?
20:42:06 <mriou> and the compiler wouldn't let me use such a funky expr as a lvalue
20:42:47 <luqui> mriou, by "the compiler" you mean the compiler you are currently implementing?
20:43:16 <luqui> mriou, anyway, if you go into ghci and type :set -fbreak-on-error you should get some more info
20:43:25 * luqui looks for dons's thing about the ghci debugger
20:43:47 <Cale> mriou: That looks like a message given by calling 'error' in your own program... you could add more context to the message so as to get some idea as to what's going on.
20:44:57 <mriou> Cale: mmh I don't have that string in my prog
20:45:27 <Cale> mriou: Are you sure? Are you using any supporting libraries that you didn't write?
20:45:36 <mriou> Cale: yes
20:45:45 <Cale> So it's got to be from one of those...
20:46:02 <mriou> mmh ok
20:46:04 <Cale> Using 'error' to produce exceptions is rather evil.
20:46:15 <Cale> Is the library publically available?
20:46:33 <mriou> unfortuantely noy
20:46:48 <mriou> or maybe fortunately
20:46:51 <Cale> Do you have its source code? You could grep that for the message.
20:47:24 <mriou> I'll try that and I'll try the option provided by luqui
20:47:51 <mriou> Cale, luqui, fortitude: thanks a ton for the help
20:47:52 * luqui can't find that tutorial on the ghci debugger
20:48:40 <luqui> oh here it is. mriou: http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/14
20:49:24 <mriou> ah thanks
20:49:47 <mriou> I'll have a look
20:49:58 <mriou> and I found the error in the library I'm using so I should be able to figure it out eventually
20:50:42 <mriou> thanks again!
21:06:33 <scrote> do you want to Fuck with me?
21:06:37 * scrote pulls out a big knife.
21:06:50 <glguy> scrote, wrong channel
21:07:11 <scrote> glguy: you talk'n to me?
21:07:15 <CoryDambach> ???
21:07:27 <luqui> scrote, see #vim-vs-emacs
21:07:31 <glguy> scrote, yeah, this channel is focused on the Haskell prrogramming language
21:07:32 <scrote> glguy: are you talk'n... to me?
21:07:38 --- mode: ChanServ set +o glguy
21:07:40 --- mode: glguy set +b %scrote!*@*
21:07:46 <pumpkin> I guess he was
21:07:48 <CoryDambach> rofl
21:08:39 <pumpkin> lol
21:09:18 <SamB> glguy: you seem to have messed up
21:09:29 <SamB> he rejoined the channel with no problem!
21:09:34 <glguy> SamB, I didn't ban him
21:09:54 <SamB> glguy: yeah. that's what I said!
21:09:57 <luqui> ... ?   *glguy sets ban on %scrote!*@*
21:10:24 <glguy> I added a +q so he could stay in channel and see how things worked
21:10:31 <luqui> ahh
21:10:50 <SamB> doesn't seem to have worked out that way
21:11:04 <glguy> nope, oh well
21:11:06 <glguy> I tried
21:11:40 <SamB> but between you and me (and the other 400 people here), I think he was probably an idiot anyway
21:13:24 <dejones> Is there a cross-platform way I can get the CPU clock-speed from inside a Haskell program?  I know in linux I could parse the output from /proc/cpu, but what about in Windows...?
21:13:26 --- mode: glguy set -ob glguy %scrote!*@*
21:17:26 <cjb> dejones: that's an odd thing to want cross-platform :)
21:17:32 <chessguy> SamB:  ya think? :)
21:17:44 <chessguy> @users
21:17:44 <lambdabot> Maximum users seen in #haskell: 568, currently: 506 (89.1%), active: 13 (2.6%)
21:17:48 <dejones> cjb: Yea, I was hoping maybe there is a command from a Haskell library.  ;)
21:18:05 <dejones> cjb: I guess I may have to write that library myself, heh.
21:18:14 <Asztal> if you can access the windows registry, it's in HKEY_LOCAL_MACHINE\HARDWARE\DESCRIPTION\System\CentralProcessor\0\~MHz .
21:18:27 <Asztal> (there's doubtless better ways to get it)
21:19:24 <dejones> Asztal: Hmm, not sure if the registry is available from a user-space program.  Maybe there is system call?
21:19:50 <Asztal> it's available from userland :)
21:20:05 <chessguy> gotta love windows :)
21:20:15 <dejones> lol
21:20:23 <dejones> Asztal: That's frightening...
21:20:32 <chessguy> "sure, why not let any program that wants to mess with the registry?"
21:21:00 <Asztal> it does have ACLs, though I'm not sure how well they're set up by default.
21:21:12 <Zao> It has permissions.
21:21:39 <repnop> yeah there are branches you won't be able to change as a normal user
21:21:40 <Zao> The default set is something along the lines of you having full access to your hive, but read only for hklm and none for other users hives.
21:21:58 <dejones> Thanks for the help Asztal, cjb.
21:22:21 <bd_> Asztal: Does that key record max clock rate or current clock rate...?
21:22:56 <Asztal> bd_: are you talking about speedstep-type technologies? I think it's just the maximum.
21:23:20 <bd_> Asztal: yeah, I'm referring to clock scaling stuff - most CPUs support it these days, so it's important to consider it :)
21:23:23 <chessguy> even read-only access to the registry seems like a bad idea to me, but whatever
21:23:39 <dejones> bd_: Good point...  that does affect my problem.
21:24:06 <bd_> Note that on linux, /proc/cpuinfo has the raw model name, which may or may not contain the actual frequency, depending on the mfr
21:24:23 <dejones> I think I am going to have to use something in GHC to get the CPU clock-speed and save it in the GHC parallel profiling log file to know what clock-speed was used during parallel profiling.
21:24:23 <bd_> If your cpu supports scaling, you can find information about its current clockrate in /sys/devices/system/cpu/cpuN/cpufreq
21:24:29 <Asztal> WMI, which provides a CurrentClockSpeed property on Win32_Processor
21:24:36 <bd_> dejones: well, more importantly, you'll have to lock the clock speed
21:24:44 <bd_> since the kernel can change it while the program is running
21:25:09 <bd_> (on linux this requires root access, I suppose windows probably requires admin too)
21:25:24 <dejones> bd_: lol.  That sucks...  My parallel profiling output tells me how many ticks of the processor occurred between each parallel profiling event, and I was wanting to convert that into time (seconds or what not).
21:25:37 <bd_> dejones: RDTSC ticks or something?
21:25:47 <dejones> bd_: RDTSC?
21:26:09 <bd_> ReaD TimeStampCounter - it's a cpu instruction on recent x86 cpus that reads a counter that increments with every clock cycle
21:26:33 <bd_> however if the clock rate changes, the timestamp counter's frequency may or may not change as well
21:27:01 <dejones> bd_: I'm not sure what GHC uses.  I use a function inside GHC to get the ticks...
21:27:04 <chessguy> > do { x <- [1,2,3,4]; y <-[1,2,3,4]; guard (y > x); return (x, y); }
21:27:05 <lambdabot>   [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
21:27:11 <bd_> dejones: that's probably not anything to do with cpu speed
21:27:31 * bd_ downloads ghc source
21:28:24 <dejones> bd_: Hmm.  I'm looking at the GHC source also to see what it is using...
21:28:31 <bd_> hm, first glance suggests itimer_interval might have the ms between ticks
21:28:51 <bd_> that's posix-only and static though
21:29:02 <chessguy> @pl \x y -> guard (y > x)
21:29:02 <lambdabot> (guard .) . flip (>)
21:29:25 <bd_> RtsFlags.MiscFlags.tickInterval ?
21:30:25 <ozy`> @pl (guard .) . flip (>)
21:30:26 <lambdabot> (guard .) . flip (>)
21:30:38 <dejones> bd_: I'm using stat_getElapsedTime() from rts/Stats.c
21:30:41 <ozy`> @unpl (\x y -> guard (y > x))
21:30:41 <lambdabot> (\ x y -> guard (y > x))
21:30:46 <ozy`> huh
21:31:20 <chessguy> @pl \p -> p x y
21:31:20 <lambdabot> flip ($ x) y
21:32:01 <bd_> dejones: ... which in turn just calls gettimeofday and converts the result to ticks
21:32:30 <bd_> dejones: so, why not just use gettimeofday? :)
21:32:37 <bd_> or on windows GetSystemTimeAsFileTime I guess
21:32:47 <chessguy> @type \xs ps -> do { x <- xs; y <- xs; guard (all (map (\p -> p x y) ps)); }
21:32:48 <lambdabot>     Couldn't match expected type `a -> Bool'
21:32:49 <lambdabot>            against inferred type `[b]'
21:32:49 <lambdabot>     In the first argument of `all', namely `(map (\ p -> p x y) ps)'
21:32:54 <dejones> bd_: Well, I use the GHC function for the cross-platform aspect.  ;)
21:33:03 <chessguy> @type all
21:33:04 <dejones> bd_: My parallel profiling work is a modification to the GHC compiler.
21:33:05 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
21:33:38 <chessguy> @type \xs ps -> do { x <- xs; y <- xs; guard (and (map (\p -> p x y) ps)); }
21:33:40 <lambdabot> forall (t :: * -> *) t1. (MonadPlus t) => t t1 -> [t1 -> t1 -> Bool] -> t ()
21:33:42 <bd_> dejones: oh, so patching the RTS is okay, then? If so, maybe add a ticksToSeconds interface to the various RTS backends?
21:33:42 <dejones> bd_: But yea, I see that it calls gettimeofday.
21:33:47 <chessguy> eeps
21:34:14 <jabberwocky> you college types
21:34:29 <dejones> bd_: Yep, I've modified the RTS, so more modifications are possible.
21:34:47 <dejones> jabberwocky: college types?
21:36:05 <dejones> bd_: I think it is probably better for me to just convert the ticks into seconds in the visualizer, and in the RTS keep the ticks in the parallel profiling log output.
21:36:21 <chessguy> ok, i should probably try again to go to bed, though i'm still probably too excited to sleep
21:36:38 <dejones> chessguy: Like chess a lot?
21:36:47 <psygnisfive> guys
21:36:50 <psygnisfive> i just want you to know
21:36:57 <chessguy> dejones:  hmm?
21:37:04 <bd_> dejones: yeah, but since the conversion rate is not a visible portion of the API (it's a static variable on POSIX), you need to expose that somehow
21:37:07 <psygnisfive> that i have great respect for your ability to program purely functionally
21:37:30 <dejones> chessguy: Well, I will soon be working on a neural network Haskell implementation of a chess player, want to play against it some time next week?  :)
21:37:50 <dejones> psygnisfive: Practice makes perfect.  :)
21:38:00 <chessguy> why would you want it to play me? hook it up to an ICS
21:38:03 <chessguy> it's easy enough
21:38:06 <psygnisfive> i'm currently working on a computational linguistics program in scheme, and even in scheme i have to use non-functional designs for it to be clear and sensible to me.
21:38:11 <psygnisfive> hats of to you all, seriously.
21:38:16 <dejones> chessguy: Just thought it might be something fun for you to do, if you wanted.  :)
21:38:17 <hydo> dejones: I'd love to see the code for it.
21:38:35 <chessguy> dejones:  i second the code request :)
21:38:38 <dejones> hydo: the NN chess player?
21:38:46 <hydo> dejones: affirmative
21:38:54 <chessguy> dejones:  are you using the NN to evolve weights?
21:39:02 <dejones> hydo, chessguy: Will do.  I have to work on it still... but I'll let you guys know when I have something functional, heh.
21:39:16 <dejones> hydo, chessguy: Might turn out that my chess player is terrible though, lol.
21:39:28 <hydo> dejones: NNs are my "ray-sawn d-entruh" to learning haskell...
21:39:44 <pumpkin> entruh?
21:39:46 <chessguy> dejones:  i'm doing a lot of thinking about pattern-based chess-playing agents
21:39:49 <pumpkin> etruh? :P
21:39:56 <dejones> chessguy: Cool.
21:39:59 <hydo> yea, I can't remember how to spell reason d'entre
21:40:06 <chessguy> raison
21:40:08 <pumpkin> raison d'être
21:40:12 <pumpkin> :)
21:40:14 <hydo> there we go
21:40:23 <dejones> hydo, chessguy: This is for an AI class project, so I have no experience with writing NN programs.  Thus, the disclaimer that my chess player may be terrible, hehe.
21:40:46 <chessguy> dejones:  are you evolving weights for static evaluation and then feeding that to alpha beta?
21:40:56 <dejones> chessguy: I've not started yet, lol.
21:41:06 <dejones> sorry.
21:41:06 <chessguy> uh...ok
21:41:15 <dejones> :)
21:41:19 <chessguy> and you think it's going to be done next week?
21:41:40 <dejones> chessguy: As I said, it may be a terrible chess player.  It is the only thing I -must- work on for the next week though, so yes I expect to get something working.  ;)
21:41:42 <chessguy> i hope you've got a lot of red bull stashed away :)
21:41:46 <dejones> lol
21:41:52 <dejones> I don't drink caffeine.
21:42:07 <chessguy> well in that case you're screwed :)
21:42:10 <jql> snort it?
21:42:11 <dejones> Well, I drink some tea, but not much caffeine.
21:42:12 <dejones> lol
21:42:15 * jql couldn't resist
21:42:20 <dejones> jql: Yep, much more effective that way.  :P
21:42:33 <dejones> chessguy: Or my chess player will just be very, very bad, haha.
21:42:45 <jql> caffeine also works in lozenge form and... I hear.... suppository
21:42:50 <dejones> lol
21:42:53 * chessguy flashes back to scenes from Airplane ("That, as much as anything, was the beginning of my drinking problem...")
21:43:45 <psygnisfive> jql, ofcourse it works in suppository form
21:43:56 <psygnisfive> its just a drug. all that matters is that it gets into your bloodstreem
21:43:57 <chessguy> dejones:  just getting a standard alpha beta engine that plays legal moves could take much of that time, much less involving Neural Nets, much less doing the necessary research
21:43:57 <dejones> bd_: You are correct.  I think I am forced to write a conversion function, as you suggested.  Thanks for the help.
21:44:12 <psygnisfive> your intestines absorb nutrients from food into your blood, why wouldn't they absord caffeine?
21:45:36 <dejones> chessguy: I may have to purchase some Red Bull.  ;)
21:45:41 <psygnisfive> it works in intradermal form, even, hence the caffeine soap.
21:45:48 <psygnisfive> red bull is disgusting
21:45:56 <psygnisfive> bawls is the best
21:45:57 <dejones> lol, I agree...
21:45:58 <repnop> caffeine pills are cheap and 200mg :P
21:45:59 <dejones> ha
21:46:00 <bd_> psygnisfive: does it /really/ work in intradermal form?
21:46:04 <bd_> or is that just marketing? :)
21:46:06 <hydo> I like good ol' coffee.
21:46:09 <dejones> Anyway, I gotta get back to work.  :)
21:46:11 <dejones> Cya everyone.
21:46:13 <repnop> like $4 for 90 200mg pills hehe
21:46:16 <chessguy> good idea :)
21:46:20 <hydo> see ya, dejones.
21:46:31 * chessguy goes off to dream about composable chess patterns
21:46:40 <psygnisfive> bd_: ofcourse. anything absorbs through the skin, granted, intradermal consumption is very stupid, since the absorption-to-applicaiton rate is damn small
21:46:48 <psygnisfive> i doubt you absorb even a tenth of what you apply
21:46:52 <psygnisfive> but even so, it does occur
21:47:35 <psygnisfive> btw, just a fair warning to everyone, i'm probably drunk, so i might seem either excessively talkative for extremely incoherent.
21:47:39 <psygnisfive> please forgive.
21:49:19 * hydo files a ghc bug report... whee
22:05:25 <nemik> hi. i'm getting an "Illegal signature in pattern" error for this code: http://hpaste.org/12799 does anyone know what might be wrong? sorry i'm very new to this language
22:08:55 <ozy`> nemik: hmm, which line?
22:09:18 <nemik> 23
22:09:39 <nemik> tutorial.hs:23:5: Illegal signature in pattern: [Person] people
22:10:14 <ozy`> nemik: are you using four-space tabs by any chance? :p
22:10:57 <ozy`> if you are, the parser will think that "people = ..." is part of the type signature for people
22:11:25 <nemik> ahhh that might be it. i'll modify it. thank you
22:11:38 <ozy`> they may seem to you like they're both indented to the right place, but the parser uses 8-space tabs always
22:12:06 <ozy`> I suggest switching to spaces, for what it's worth
22:16:51 <nemik> ozy`: i tried spaces. and my tabs are 8-space. no luck on either
22:18:17 <ozy`> nemik: http://hpaste.org/12799#a1
22:20:18 <nemik> thanks! so 2 spaces normally then 4 for inside the let?
22:20:46 <ozy`> 2 spaces is just my personal preference
22:20:54 <ozy`> you could use 88 if you felt like it
22:21:10 <ozy`> but the contents of the let block absolutely have to be lined up properly
22:22:13 <nemik> aha, i see. perfect. i didn't know the let contents had to line up the way they di
22:22:20 <ozy`> let blocks use the same layout rules as do blocks
22:22:22 <nemik> *do. thanks you again
22:22:27 <ozy`> ditto where, IIRC
22:22:30 <ozy`> no sweat
22:32:43 <jfredett> anyone up to date on the status of ghc 6.10 on arch?
22:32:57 <jfredett> and is there an arch-haskell channel where this question would be better suited?
22:33:53 <jfredett> it appears there is...
22:34:00 <jsn> can someone help me to understand why the haddock for this module is only half there?
22:34:00 <jsn> http://hackage.haskell.org/packages/archive/system-uuid/1.1.0/doc/html/System-UUID-V1.html
22:35:01 <jsn> click on source code to see the haddock inside (the code is very short)
22:35:42 <pumpkin> is there a simple sign function that returns +1, -1, or 0 depending on the number passed in?
22:36:05 <pumpkin> > compare 5 0
22:36:06 <lambdabot>   GT
22:36:10 <pumpkin> > compare -1 0
22:36:11 <lambdabot>       No instance for (Num (a -> a -> Ordering))
22:36:11 <lambdabot>        arising from a use of...
22:36:13 <jeffwheeler> > signum 5
22:36:14 <lambdabot>   1
22:36:16 <pumpkin> aha
22:36:19 <pumpkin> thanks :)
22:36:25 <ozy`> >compare (-1) 0
22:36:25 <jeffwheeler> http://haskell.org/hoogle/?hoogle=sign :)
22:36:37 <pumpkin> thanks :)
22:38:39 <AzraPrime> Is it possible to set a variable in a .cabal file?
22:39:09 <AzraPrime> It's not strictly necessary, but I've got a library and an executable in a package that will always have the same dependencies, and would like to have them be in the same place
22:44:46 <AzraPrime> Additionally, is there any good way to cross-compile?
22:44:51 <pumpkin> is there a function like *** that applies the same function to both first and second of a pair?
22:45:31 <intrados> is there a reason that cabal doesn't install yampasynth-gtk but it does install yampasynth-openal and yampasynth-wav?
22:45:44 <jsn> AzraPrime:  you mean, set a CPP variable?
22:46:00 <jsn> AzraPrime: oh, wait, no
22:46:04 <jsn> i see what you mean
22:46:21 <jsn> :t (&&&)
22:46:22 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
22:46:42 <jsn> pumpkin: that's not quite right
22:47:03 <pumpkin> yeah, I knew about &&& but I need sort of the opposite of it
22:47:11 <AzraPrime> jsn: My goal is essentially a very simple macro over the course of a .cabal file there
22:47:20 <pumpkin> like
22:47:31 <jsn> AzraPrime: yeah, i honestly don't know how to do that
22:47:41 <_dolio> @type join (***)
22:47:42 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
22:47:44 <AzraPrime> jsn: The other thing I'm looking to do is to cross build for different archs, or (while I don't expect this is possible) building for other OSes
22:47:49 <jsn> pumpkin: i fear there is only    f *** f
22:48:08 <pumpkin> > let ^^^ f x = (f *** f) x in (+1) ^^^ (1, 2)
22:48:09 <lambdabot>   <no location info>: parse error on input `^^^'
22:48:15 <pumpkin> > let (^^^) f x = (f *** f) x in (+1) ^^^ (1, 2)
22:48:16 <lambdabot>   (2,3)
22:48:57 <pumpkin> > join (***) (+1) (1, 2)
22:48:58 <lambdabot>   (2,3)
22:49:03 <pumpkin> <3 dolio
22:49:13 <jsn> :t join
22:49:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
22:49:58 <jsn> i am trying to figure out how that works and i can't :)
22:50:33 <jsn> AzraPrime: i remember reading something about cross-compilation "coming soon"
22:50:37 <pumpkin> :t (***)
22:50:38 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
22:51:02 <jsn> :i Arrow
22:51:15 <jsn> @info arrow
22:51:15 <lambdabot> arrow
22:51:18 <pumpkin> lol
22:51:26 <jsn> @info Arrow
22:51:26 <lambdabot> Arrow
22:51:33 <jsn> :(
22:52:13 <pumpkin> _dolio: I sent you <3 earlier
22:52:18 <pumpkin> but you weren't there to receive it (
22:52:32 <pumpkin> now jsn and I are trying to figure out why that works :P
22:52:37 <jsn> AzraPrime: i have not seen anything about it since then
22:52:42 <jsn> @source join
22:52:43 <lambdabot> join not available
22:52:47 <pumpkin> :t join
22:52:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
22:52:49 <_dolio> Yeah, I seem to disconnect a lot for no apparent reason.
22:52:56 <pumpkin> @src Arrow join
22:52:57 <lambdabot> Source not found. Do you think like you type?
22:53:09 <dolio> It's the (->) r monad.
22:53:18 <AzraPrime> jsn: OK. I was mostly just hoping not to have to run n VMs just to test compilation validity
22:53:21 <dolio> join :: (r -> r -> a) -> (r -> a)
22:53:27 <jsn> AzraPrime: yeah
22:53:35 <jsn> AzraPrime: i actually have VMs just for that
23:01:02 <pumpkin> :t join (***) (+1)
23:01:03 <lambdabot> forall c. (Num c) => (c, c) -> (c, c)
23:01:10 <pumpkin> :t join (***)
23:01:11 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
23:01:51 <pumpkin> I'm almost getting it
23:01:57 <pumpkin> :t (***)
23:01:58 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
23:02:15 <dolio> > join (+) 1
23:02:16 <lambdabot>   mueval: Prelude.read: no parse
23:02:40 <dolio> @type join (+)
23:02:41 <lambdabot> forall a. (Num a) => a -> a
23:02:47 <dolio> @type join (+) 2
23:02:48 <lambdabot> forall a. (Num a) => a
23:02:53 <dolio> > join (+) 2
23:02:55 <lambdabot>   4
23:03:59 <dolio> @djinn (r -> r -> a) -> r -> a
23:04:00 <lambdabot> f a b = a b b
23:04:41 <hydo> What's the preferred way to uninstall a package installed with the cabal command line tool?
23:06:23 <hydo> ah, ghc-pkg unregister
23:06:40 <hydo> then I'm assuming you can just delete the directory for said module.
23:06:52 <dolio> I think that's as good as it gets.
23:33:51 <doublec> everytime I install gitit from source it insists on rebuilding pandoc without the -fhighlighting option
23:33:56 <doublec> anyone know what I might be doing wrong?
23:34:11 <doublec> I do a : cabal install -fhighlighting pandoc
23:34:16 <doublec> then in the gitit source directory
23:34:23 <doublec> cabal install
23:34:30 <doublec> it then rebuilds pandoc without the highlighting
23:34:42 <mmorrow> doublec: wanting to rebuild stuff is part of why i'm not a fan of cabal install
23:35:17 <doublec> So build/install gitit without using cabal?
23:35:23 <mmorrow> but if doing it manually is too much of a pain, then i'm not sure what to do
23:36:04 <mmorrow> doublec: that should work i guess, but i don't know why it's rebuilding pandoc in the first place?
23:36:36 <doublec> yeah, I don't know why it's doing that
23:36:42 <mmorrow> weird
23:41:17 <doublec> ok, using runghc Setup.lhs configure/build/install worked around the problem
23:43:08 <mmorrow> nice
23:43:48 <Lemmih_> doublec: Cabal-install will tell you why if you give it -v.
23:44:34 <Lemmih> doublec: gitit (or some of its dependencies) probably depend on parsec-2.
23:44:57 <Lemmih> If you're doing a plain 'cabal install pandoc', cabal feels free to use parsec-3.
23:45:47 <doublec> pandoc-1.1 (reinstall) changes: highlighting-kate-0.2.3 removed
23:45:52 <doublec> that's what I get with -v
23:46:53 <doublec> I originally install pandoc with: caba instal -fhighlighting pandoc
23:48:01 <mmorrow> Lemmih: is parsec3's interface completely compatible with parsec3's?
23:48:03 <Lemmih> doublec: try 'cabal-install install --reinstall gitit pandoc -f highlighting'.
23:48:16 <mmorrow> s/parsec3's?/parsec2's?/
23:48:47 <doublec> with that build/install the version of gitit in the current directory or pull it from cabal?
23:48:51 <Lemmih> mmorrow: I don't know. gitit uses parsec2 because it is faster than parsec3.
23:48:51 <doublec> s/with/will
23:49:20 <Lemmih> It'll take the hackage version, I think.
23:49:28 <mmorrow> because i'm not sure it is, and in the case where you need to depend on pkgs that depend on both, will cabal-install just refuse to install?
23:49:49 <mmorrow> that's one of the problems i've had using it
23:50:43 <Lemmih> mmorrow: GHC will not allow you to mix the two, I think.
23:51:04 <mmorrow> using Setup.lhs configure/build/install works fine
23:51:13 <mmorrow> (with a warning)
23:51:41 <Lemmih> mmorrow: Then the uses of parsec2 and parsec3 are probably isolated.
23:51:53 <mmorrow> exactly
23:52:15 <Lemmih> That's perfectly fine.
23:52:19 <mmorrow> but cabal-install seems to assume that this is never the case (that they're isolated)
23:52:23 <mmorrow> really?
23:53:14 <mmorrow> (cabal-install is able to determine if they're isolated, rather than just trying to rebuild a package with parsec3 that depends of < parsec3 and failing to resolve deps?)
23:53:24 <Lemmih> It is rarely the case. And reinstalling the packages should fix it.
23:54:04 <mmorrow> but i'm saying though, that since parsec3 is not compatible (interface-wise) with parsec2 and if a package /needs/ parsec2, it can't be built with parsec3
23:54:06 <Lemmih> No, you have to type-check the program to determine that.
23:54:50 <mmorrow> (my question was mostly rhetorical :)
23:55:45 <mmorrow> but yeah, there doesn't seem to be an easy strategy that cabal-install could use in these cases
23:56:06 <Lemmih> If package 'A' needs parsec2 and package 'B' is built against parsec3 but doesn't depend on it, cabal-install will reinstall package 'B' against parsec2.
23:56:24 <mmorrow> yes
23:57:17 <Lemmih> The exact reasons for the reinstalls are usually difficult to discover as cabal-install isn't too chatty.
23:57:37 <mmorrow> package A needs parsec < 3    package B needs parsec > 2     package C needs A and B       ==> cabal-install will give up
23:57:40 <mmorrow> (?)
23:58:16 <Lemmih> It think it's throw a warning and then go ahead.
23:58:30 <mmorrow> oh really? cool.
23:58:59 <mmorrow> my info may not be up-to-date :)
