00:04:57 <jkff> @seen jianzhou
00:04:57 <lambdabot> I haven't seen jianzhou.
00:05:09 <semka> jkff: wow
00:05:14 <jkff> Hi
00:05:16 <semka> jkff: nice to meet you (:
00:05:18 <semka> hi
00:05:32 <jkff> Same to you :)
00:05:44 <semka> *shame, hehe
00:06:03 <jkff> Haven't you accidentally read and understood Wadler's Free Theorems?
00:06:17 <semka> jkff: not yet
00:06:25 <jkff> That's a pity :(
00:08:20 <semka> jkff: fast prime generator so cute (:
00:09:17 <jkff> Thx :) I'd recommend to read the ONeillPrimes, probably you will understand it in its entirety - I didn't, but it's cooler
00:11:23 * Debolaz needs a project to learn Haskell with.
00:12:24 <jkff> Debolaz: Take a chapter title from  RWH and write it without looking into the book
00:12:53 <jkff> For example, write a Bloom filter library, or a barcode recognizer
00:13:27 <jkff> Or write a regular expressions library. This seems to be interesting in all aspects.
00:13:43 <pumpkin> pure regexes maybe at first
00:13:46 <jkff> A lot of potential for architecture and optimization.
00:13:50 <jkff> Yes, those implementable with DFA
00:14:01 <pumpkin> or an NFA simulator
00:14:09 <pumpkin> using lists as monads
00:14:13 <hydo> ghc is throwing an error on "$(deriveSerialize ''SessionData)"  - from http://hpaste.org/5957  From reading the top of the file, I tried -fglasgow-exts to no avail.  I've never seen $ used like this, but then again I'm still learning...
00:14:39 <pumpkin> hydo: that's template haskell
00:14:47 <jkff> This is Template Haskell. Probably you need some flag to enable it
00:15:01 <pumpkin> stick {-# OPTIONS_GHC -XTemplateHaskell #-} at the top of your file
00:15:10 <hydo> ah, ok... i'll poke around and learn what the hell Template Haskell is :)
00:15:18 <jkff> Like LISP macros
00:15:20 <hydo> oh, thanks pumpkin
00:15:22 <hydo> !
00:15:26 <hydo> really?  damn
00:15:31 <pumpkin> hydo: it's super cool
00:15:33 <hydo> I've got a lot to learn apparently.
00:17:00 <hydo> Thanks again for the info, guys.
00:17:10 <hydo> err.. and girls... heh..
00:17:12 <jkff> np :)
00:22:25 <pumpkin> what's the best way to deal with things I'd typically (justifiably) use a for loop for in an imperative language... I have a (relatively) expensive learning algo that I can want to run for N iterations
00:22:50 <pumpkin> is it worth mapping/folding over [1..n] or should I just write a recursive function that decrements n each time?
00:24:29 <dibblego> pumpkin, take/iterate?
00:24:39 <pumpkin> yeah, I actually just thought of that
00:24:43 <pumpkin> maybe that's most elegant
00:25:18 <pumpkin> thanks :)
00:33:18 <mmorrow> i've been using a function "nce" recently for that:
00:33:36 <mmorrow> one sec..
00:35:06 <mmorrow> ok back
00:35:55 <mmorrow> nce 0 _ !a = a; nce !n f !a = nce (n-1) f (f a)
00:36:12 <mmorrow> pretty simple, but the bangs really make a difference
00:36:14 <mmorrow> oops
00:36:20 <mmorrow> nce 0 _ !a = a; nce n f !a = nce (n-1) f (f a)
00:36:46 <mmorrow> don't need a ! on n since it has to be eval'ed every time to test it against 0
00:37:11 <JoshTriplett> lookup takes a key and an association list and returns the matching value, if any.  Does some function like lookup exist which returns the list of matching values?
00:37:48 <JoshTriplett> Given that the association list might have more than one entry with a given key, and possibly with different values.
00:37:58 <mmorrow> but it take/iterate actually fuses, the only diff then'd be whether the f(f ...(f a)) is one or n levels deep then
00:38:27 <mmorrow> JoshTriplett: you could use filter for that
00:38:41 <Saizan> JoshTriplett: filter (==value)
00:39:03 <mmorrow> lookups k = fmap snd . filter ((==k) . fst)
00:39:26 <JoshTriplett> mmorrow: Yeah, that works.  I just wondered if a function existed for it.
00:39:35 <mmorrow> heh, that one :)
00:39:35 <JoshTriplett> mmorrow: If I have to write it by hand I'll probably use a list comprehension.
00:39:43 <mmorrow> ooh, that too
00:40:19 <JoshTriplett> mmorrow: lookups k assoc = [value | (key, value) <- assoc, key == k]
00:40:33 <JoshTriplett> And I think I'll just inline that right where I need it.
00:40:39 <mmorrow> look(up)s good to me
00:40:41 <mmorrow> ;)
00:40:55 * mmorrow couldn't help himself
00:41:51 <JoshTriplett> Groan.
00:42:15 <JoshTriplett> mmorrow, Saizan: Thanks for the quick confirmation that I haven't reinvented something in a standard module.
00:42:30 <mmorrow> noprob
00:42:53 <JoshTriplett> #haskell works really well for a quick "Oh yeah, you want Data.Structure.Obscure.exactlyTheFunctionYouWant".
00:43:10 <JoshTriplett> Or a quick check that such doesn't exist.
00:43:18 <mmorrow> #haskell :: String ->  Data.Structure.Obscure.exactlyTheFunctionYouWant
00:43:43 <mmorrow> err
00:43:47 <JoshTriplett> mmorrow: #haskell :: String -> [Data.Structure.Obscure.exactlyTheFunctionYouWant], clearly. :)
00:43:49 <mmorrow> #haskell :: String -> Maybe Data.Structure.Obscure.exactlyTheFunctionYouWant
00:44:01 <ddarius> mmorrow: Incidentally, nce is a (strict) left fold on the naturals and goes into a loop given negative input.
00:44:04 <mmorrow> ah yeah, that's better
00:44:13 <mmorrow> ddarius: yes and yes
00:45:11 <mmorrow> nce n f a | n < 0 = a | otherwise = let go 0 _ !a = a; go n f !a = go (n-1) f (f a) in go n f a
00:45:26 <ido> what...is that?
00:45:27 <pumpkin> mmorrow: cool, thanks :) what do the bangs do?
00:45:52 <mmorrow> the same thing as in foldl'. they make sure your accumulator is always evaluated
00:45:57 <pumpkin> ah
00:46:15 <pumpkin> I thought the bangs only worked for type constructors
00:46:22 <mmorrow> and as ddarius pointed out, nce is essentially foldl' over [0..n]
00:46:30 <Saizan> i'd write a consumeStrictly and use "consumeStrictly . iterate f"
00:46:42 <Saizan> oops
00:46:46 <Saizan> with a take n
00:47:17 <mmorrow> seqList [] = []; seqList (!x:xs) = x : seqList xs
00:47:36 <ddarius> mmorrow: That's true, but not what I was saying.
00:47:56 <mmorrow> what were you saying?
00:48:21 <ddarius> (Except that you'd have to reverse the list)
00:48:25 <mmorrow> oops, i meant
00:48:26 <mmorrow> yeah
00:48:39 <mmorrow> [n,n-1..0]
00:48:54 <ddarius> mmorrow: I was saying that it is "the" foldl' for naturals, not that it is foldl' over a list of naturals.
00:49:19 <mmorrow> ahh, i gotcha
00:49:57 <mmorrow> pumpkin> I thought the bangs only worked for type constructors
00:50:00 <mmorrow> @src Int
00:50:01 <lambdabot> data Int = I# Int#
00:50:04 <mmorrow> ;)
00:50:27 <JoshTriplett> I find myself wishing I could write this: [value | Just desiredKey <- maybeKey , (key, value) <- assoc , key == desiredKey]
00:50:33 <JoshTriplett> And end up with an empty list if I have a Nothing.
00:50:37 <JoshTriplett> maybeToList, maybe?
00:50:48 <JoshTriplett> desiredKey <- maybeToList maybeKey ?
00:51:02 <JoshTriplett> Argh, sigh.
00:51:03 <ddarius> JoshTriplett: You can write that.
00:51:13 <ddarius> Oh, nevermind
00:51:18 <JoshTriplett> I know I *can*.  I wondered if I *should*. :)
00:51:27 <JoshTriplett> ddarius: nevermind?
00:52:52 <ddarius> You could simply write Just desiredKey <- [maybeKey]
00:53:10 <ddarius> That's a bit abusive though
00:54:01 <JoshTriplett> ddarius: I don't see how that would help.
00:54:26 <mornfall> With what?
00:54:31 <JoshTriplett> ddarius: It doesn't strip off the Just, and it generates an element even if I have a Nothing.
00:54:55 <ddarius> JoshTriplett: Yes it does and no it doesn't.
00:54:56 <mmorrow> ,  [ x | Just x@37 <- [Just 42, Nothing, Just 37, Just 99, Nothing]]
00:54:57 <ddarius> Try it.
00:55:04 <lunabot>  [37]
00:55:18 <JoshTriplett> ddarius: *ah*, I didn't see the Just there.
00:55:32 <JoshTriplett> ddarius: I thought you just wrote "desiredKey <- [maybeKey].
00:55:45 <JoshTriplett> ddarius: The "Just" blended into your sentence. :)
00:55:52 <JoshTriplett> ddarius: Darn English. :)
00:56:02 <pumpkin> that newfangled generalized SQL-like comprehensions in 6.10 look funky
00:56:33 <JoshTriplett> I think I'll go with maybeToList.  It seems more explicit.
00:56:36 <mmorrow> pumpkin: oh yeah, i'd almost forgot about that.
00:56:46 * mmorrow make note to play around with them
00:57:03 <pumpkin> they sort of look out of place though, to me
00:57:08 <pumpkin> maybe I'll grow to love them
00:57:14 <pumpkin> cause their functionality does seem cool
00:59:11 <mmorrow> yeah, it does seem cool
00:59:25 * dolio isn't very enthused.
00:59:38 <dolio> Until someone generalizes them to all monads.
00:59:41 <mmorrow> dolio: about the syntax or the functionality?
00:59:46 <pumpkin> and to Set!
00:59:49 <pumpkin> :D
00:59:50 <mmorrow> dolio: heh
01:00:05 <mmorrow> Set.toList ?
01:00:12 <pumpkin> no fun :P
01:00:18 <mmorrow> heh
01:00:29 <pumpkin> a Set comprehension would be super purty
01:02:13 <mornfall> Even a Set constant syntax would be nice-ish, I guess.
01:02:29 <mornfall> (But that's trivial if you have comprehensions.)
01:02:49 <mornfall> It has some conflict potential with record syntax though.
01:03:22 <pumpkin> I'm not a fan of the record syntax
01:04:46 <ivanm> pumpkin: the record syntax is a compromise
01:04:55 <ivanm> _no one_ is a fan of the record syntax ;-)
01:05:09 <pumpkin> :)
01:05:26 * ivanm _is_ a fan of records though
01:06:09 <ivanm> if you could pass around record accessors as normal functions and use them that way, it'd almost be perfect
01:06:38 <mmorrow> erm, you can
01:07:08 <mmorrow> fmap rootLabel [Node 42 [], Node 3 [Node 1 []]]
01:07:12 <mmorrow> , fmap rootLabel [Node 42 [], Node 3 [Node 1 []]]
01:07:15 <lunabot>  [42,3]
01:07:22 <mmorrow> or did you mean something different?
01:07:53 <ivanm> mmorrow: I mean being able to have a function f :: (a -> Record) -> a -> Record -> Record, f c a r = r { c = a }
01:08:00 <ivanm> something like that
01:08:18 <mmorrow> ah, so like a lens-ish thing
01:08:39 <mmorrow> looks like the perfect thing to auto-generate with TH
01:08:45 <ivanm> mmorrow: lens?
01:09:03 <mmorrow> a -> (b, b -> a)
01:09:14 <mmorrow> or something along those lines
01:09:25 <ivanm> how is that a lens?
01:09:34 <Saizan> ?google FRef haskell
01:09:35 <lambdabot> No Result Found.
01:10:13 <sjanssen>  @google sucks, for some reason
01:10:27 <mmorrow> i think the name-rationale is that it's kinda like a "lense" that gives you a different view on 'a'
01:10:43 <mmorrow> e.g. maybe a magniying glass
01:10:47 <Saizan> it borks on "Did you mean: .." probably
01:10:47 <ivanm> ahhh
01:10:48 <mmorrow> magnifying
01:11:01 <sjanssen> ivanm: good search terms are "functional references", "frefs" and "lenses"
01:11:15 <sjanssen> ivanm: I believe twanvl had some useful blogs on the subject
01:11:54 <ivanm> sjanssen: *nod*
01:12:49 <ivanm> but I've found records inordinately useful when I had to pass values around deep into a function chain, especially large number of values... much easier than a ten-line long type sig! ;-)
01:12:51 <Saizan> we should have a trac for lambdabot, maybe?
01:13:04 <Saizan> (/me has no commit power)
01:13:05 <sjanssen> Saizan: that would be nice
01:13:16 <sjanssen> supposedly we have trac for free on community.haskell.org
01:13:31 <ivanm> well, you _can_ have a trac
01:13:54 <sjanssen> I don't know how to set it up, but I know it is an option.  We should look into that for lambdabot
01:13:57 <pumpkin> is the indexing operator for lists !! just to warn you it's very bad!! ?
01:14:13 <sjanssen> pumpkin: good question
01:14:23 <pumpkin> ;)
01:14:36 <sjanssen> (!!) is somewhat bad, it is usually an indication that you're "doing it wrong"
01:14:38 <ivanm> heh
01:14:58 <pumpkin> I bring it up because I'm doing it wrong
01:15:04 <ivanm> I supose because its an accessor... it seems vaguely mathematical, but for the life of me I can't think of what its reminding me of
01:15:05 <pumpkin> but I'm too lazy to fix it right now
01:17:52 <Saizan> sjanssen: http://community.haskell.org/admin/using_project.html <- it says one just needs to login and run "createtrac lambdabot"
01:19:56 <pumpkin> same question I asked yesterday, but is there a way to get the positive value closest to 0 for a given Floating type that isn't 0?
01:20:08 <pumpkin> in a standardish way
01:20:22 <mmorrow> too bad haskell doesn't have an "eps"
01:20:30 <pumpkin> that's what I was hoping for
01:20:31 <mmorrow> (in Prelude)
01:20:56 <Saizan> well Float and Double aren't even guaranteed to be IEEE754 floats
01:21:13 <pumpkin> ah, that seems reasonable
01:21:14 <mmorrow> seriously?
01:21:33 <mmorrow> wtfx10
01:21:36 <Saizan> > isIEEE 1.0
01:21:37 <lambdabot>   True
01:21:42 <mmorrow> ohh, ok.
01:21:43 <pumpkin> :t isIEEE
01:21:43 <Saizan> you can check :)
01:21:44 <lambdabot> forall a. (RealFloat a) => a -> Bool
01:21:50 <Saizan> that might be False
01:21:54 <pumpkin> @instances RealFloat
01:21:54 <lambdabot> Double, Float
01:22:24 <ivanm> Saizan: they're not? :o
01:22:38 <ivanm> I thought they were....
01:22:44 <pumpkin> the existence of that function seems to imply they aren't :P
01:22:46 <ivanm> any particular reason for _not_ having it as IEEE?
01:22:51 <solrize_> hardware
01:22:57 <ivanm> pumpkin: well, CREAL isn't IEEE AFAIK...
01:22:59 <ivanm> solrize_: ahhh
01:23:04 <pumpkin> more of the "divorce yourself from particular computational models" thing?
01:23:23 <solrize_> you might be running on a machine with non-ieee floating point hardware
01:24:55 <mmorrow> pumpkin: ok, the formula for epsilon is:
01:24:59 <mmorrow> @let eps b p = fromIntegral (b::Int) ** (1 - fromIntegral (p::Int))
01:25:00 <lambdabot>  Defined.
01:25:02 <mmorrow> where:
01:25:21 <mmorrow> b = base   and p = digits in mantissa
01:25:26 <pumpkin> ah
01:25:34 <pumpkin> binary digits in mantissa?
01:25:41 <mmorrow> i think base b digits
01:25:48 <pumpkin> yeah
01:25:58 <pumpkin> I guess you could drop the b bit since we can assume it's binary
01:26:25 <pumpkin> > eps 2 53
01:26:26 <lambdabot>   2.220446049250313e-16
01:26:31 <pumpkin> > eps 2 24
01:26:32 <lambdabot>   1.1920928955078125e-7
01:27:13 <pumpkin> > eps 2 113
01:27:14 <lambdabot>   1.925929944387236e-34
01:27:27 <pumpkin> hrm
01:27:34 <pumpkin> :t eps 2 113
01:27:35 <lambdabot> forall b. (Floating b) => b
01:27:53 <pumpkin> > eps 2 24 :: Float
01:27:54 <lambdabot>   1.1920929e-7
01:27:56 <mmorrow> i got that formula from this page, which has good info that's relevant beyond that formula http://en.wikipedia.org/wiki/Machine_epsilon
01:27:58 <pumpkin> > eps 2 53 :: Float
01:27:59 <lambdabot>   2.220446e-16
01:29:11 <Saizan> > 1.1920928955078125e-8
01:29:12 <lambdabot>   1.1920928955078126e-8
01:29:20 <Saizan> :)
01:29:32 <pumpkin> > 1.1920928955078125e-8 :: Float
01:29:33 <lambdabot>   1.1920929e-8
01:29:47 <mmorrow> in particular (related to another def other than that formula) "both the GNU libc manual[2] and Microsoft Visual C++ documentation[3] define the constant FLT_EPSILON in this way, in conflict with the ISO C standard"
01:29:48 <pumpkin> > 2.220446049250313e-17 :: Double
01:29:50 <lambdabot>   2.220446049250313e-17
01:29:54 <pumpkin> hmm
01:30:17 <mmorrow> the iso C standard way is via that formula
01:30:29 <mmorrow> (apparently)
01:30:50 <mmorrow> > 2.2e-260
01:30:52 <lambdabot>   2.2e-260
01:31:07 <mmorrow> eps is somewhere near there iirc
01:31:08 <mbz> ?src eps
01:31:08 <lambdabot> Source not found.
01:31:17 <mmorrow> let eps b p = fromIntegral (b::Int) ** (1 - fromIntegral (p::Int))
01:31:22 <mmorrow> where b = base   and p = digits in mantissa
01:31:30 <pumpkin> ?src is not smart enough to remember @lets
01:31:30 <lambdabot> Source not found. Take a stress pill and think things over.
01:32:48 <mmorrow> hmm, interesting. i think there's a distinction between eps and /machine/ eps
01:33:11 <mmorrow> octave:7> eps
01:33:11 <mmorrow> ans =  2.2204e-16
01:33:11 <mmorrow> octave:8> eps ^ 10
01:33:11 <mmorrow> ans =  2.9134e-157
01:33:38 <mmorrow> i think machine eps is somewhere in the -200s
01:33:50 <pumpkin> hmm
01:33:52 <mmorrow> (at least on x86 puters)
01:34:07 <pumpkin> well, there's a smallest exponent
01:34:41 <mmorrow> yeah, i'm slightly confused right now
01:35:00 <pumpkin> me too
01:35:23 <Saizan> denormals aren't in the 1.mantissa * e^exponent form
01:35:38 <pumpkin> e^ ;)
01:35:47 <mmorrow> ah, that's it
01:35:49 <Saizan> heh, 10^
01:36:09 <Saizan> or 2? i don't recall
01:36:35 <pumpkin> 10
01:36:47 <pumpkin> I think :P
01:36:53 <pumpkin> too many bases being juggled around here
01:36:57 <pumpkin> (all two of them)
01:37:04 <mmorrow> all your bases are belong to me!
01:37:06 <pumpkin> lol
01:37:33 <mmorrow> hehe
01:40:24 <Saizan> (i still have to pass the real analysis final, i should remember this :\)
01:41:11 <mmorrow> um, you mean as in math-department real analysis? or numerical analysis?
01:41:25 <Saizan> numerical
01:41:33 <mmorrow> ah
01:41:51 <mmorrow> i was about to be like whoa that's a crazy real analysis class ;)
01:42:15 <pumpkin> lol
01:42:40 <mmorrow> Saizan: can you use any language, or is there a required on for the class?
01:42:47 <Saizan> matlab
01:42:56 <pumpkin> mmm
01:43:11 <Saizan> but i've already written the code
01:43:11 <pumpkin> one of the handiest, ugliest languages I know :P
01:43:39 <mmorrow> heh, i took one that was any lang and one that was matlab-only (but i used octave)
01:44:15 <pumpkin> is octave just an open source replacement for matlab?
01:44:19 <mmorrow> the little differences between octave and matlab are a huge pain
01:44:22 <Saizan> what i find weird about using matlab is that we freak out about reusing the space of matrixes and then functions are pass by value
01:44:27 <pumpkin> cause I'm getting rather infuriated at its disgustingly slow GUI in OS X
01:44:53 <pumpkin> Saizan: yeah, but they explain that they don't bother copying the value unless you actually change it
01:45:05 <mmorrow> pumpkin: yeah, but there are little differences here and there that you have to find out about if you want the octave code to run under matlab
01:45:15 <pumpkin> ah
01:45:22 <Saizan> pumpkin: ah, where?
01:45:40 <pumpkin> Saizan: can't remember, some matlab faq I came across once [citation needed, I guess]
01:45:42 <pumpkin> :P
01:45:51 <pumpkin> but they said explicitly that they were doing a COW thing
01:46:07 <pumpkin> http://www.mit.edu/~pwb/cssm/matlab-faq.html
01:46:20 <pumpkin> pretty ancient, but I doubt they'd have changed that
01:47:28 <Saizan> ah, but i do modify the input variable most of the time
01:47:44 <Saizan> it's less bad than i thought anyway
01:52:34 <sony_ericsson> !book
01:52:39 <sony_ericsson> `book
01:52:49 <sony_ericsson> how do u use the bo
01:52:50 <sony_ericsson> bot
01:52:58 <ziman> @where rwh
01:52:58 <lambdabot> http://book.realworldhaskell.org/read/
01:53:07 <Japsu> in soviet #haskell the bot use YOU !!
01:53:26 <mmorrow> > [0..]
01:53:27 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
01:53:32 <mmorrow> , [0..]
01:53:37 <lunabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
01:54:16 <sony_ericsson> are there any tutorials?
01:54:24 <sony_ericsson> or you recommend books?
01:54:34 <mmorrow> about using the bot?
01:54:40 <sony_ericsson> @book
01:54:40 <lambdabot> Unknown command, try @list
01:54:43 <mmorrow> (or haskell?)
01:54:46 <pumpkin> @go rwh
01:54:47 <lambdabot> No Result Found.
01:54:54 <pumpkin> @go real world haskell
01:54:54 <sony_ericsson> @list
01:54:56 <lambdabot> http://www.realworldhaskell.org/
01:54:56 <lambdabot> Title: Real World Haskell
01:54:56 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
01:54:59 <mmorrow> @src map
01:55:00 <lambdabot> map _ []     = []
01:55:00 <lambdabot> map f (x:xs) = f x : map f xs
01:55:14 <mmorrow> @type \f -> let x = f x in x
01:55:16 <lambdabot> forall t. (t -> t) -> t
01:55:29 <mmorrow> @nixon
01:55:29 <lambdabot> Don't get the impression that you arouse my anger. You see, one can only be angry with those he respects.
01:55:42 <ziman> sony_ericsson, you might want to have look at http://haskell.org/haskellwiki/Books_and_tutorials
01:55:45 <mmorrow> > 42 * 100000000000000000
01:55:46 <lambdabot>   4200000000000000000
01:55:53 <sony_ericsson> @list books
01:55:53 <lambdabot> No module "books" loaded
01:56:04 <sony_ericsson> @go book
01:56:06 <lambdabot> http://www.barnesandnoble.com/
01:56:08 <pumpkin> sony_ericsson: um
01:56:09 <mmorrow> books for what?
01:56:18 <sony_ericsson> @go tutorial
01:56:20 <lambdabot> http://en.wikipedia.org/wiki/Tutorial
01:56:21 <lambdabot> Title: Tutorial - Wikipedia, the free encyclopedia
01:56:27 <mmorrow> @help go
01:56:28 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:56:29 <pumpkin> sony_ericsson: can't we just tell you?
01:56:33 <sony_ericsson> okok
01:56:45 <pumpkin> the realworldhaskell.org I linked you to is a good book
01:56:47 <pumpkin> also
01:56:49 <sony_ericsson> real world haskell is the most popular here?
01:56:51 <pumpkin> @go learn you a haskell
01:56:55 <lambdabot> http://learnyouahaskell.com/
01:56:55 <lambdabot> Title: Learn You a Haskell for Great Good!
01:57:23 <pumpkin> sony_ericsson: it's pretty good, and is available for free online
01:57:38 <olahol> isn't it a little advanced?
01:58:02 <mmorrow> i guess it depends on what the reader is looking for
01:58:34 <mmorrow> if they're someone that needs to learn haskell asap so they can use it for work, then nothing's too advanced
01:58:54 <mmorrow> but if their a student learning it for a class, then maybe
01:59:00 <mmorrow> s/their/they're/
01:59:11 <sony_ericsson> they're*
01:59:15 <sony_ericsson> use *, it's shorter
01:59:22 <mmorrow> i refus!
01:59:24 <mmorrow> *refuse
01:59:26 <mmorrow> ;)
01:59:27 <pumpkin> ;)
01:59:44 <sony_ericsson> we are not in a sed terminal. This is an irc channel
01:59:56 <mmorrow> sony_ericsson: life is a sed terminal!!
01:59:56 <sony_ericsson> immutable
01:59:57 <pumpkin> sony_ericsson: tell most freenode people that then :P
02:00:45 <Saizan> i guess using * in a #c channel might be confusing
02:00:50 <Saizan> ;)
02:00:58 <olahol> nice point
02:01:01 <mmorrow> er
02:01:18 <sony_ericsson> syntax error
02:01:32 <mmorrow> preflex: help
02:01:33 <preflex>  try 'help help' or see 'list' for available commands
02:01:39 <mmorrow> preflex: list
02:01:39 <preflex>  Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; ZCode: [zdec, zenc]
02:02:00 <pumpkin> preflex rot13: abc
02:02:07 <pumpkin> preflex: rot13: abc
02:02:18 <sony_ericsson> it doesn't like you
02:02:20 <pumpkin> :(
02:02:34 <pumpkin> sony_ericsson: way to rub it in
02:02:42 <sony_ericsson> you have to add 'please' on the end
02:04:39 <Saizan> preflex: rot13 abc
02:04:40 <preflex>  nop
02:04:51 <agemo> i
02:04:56 <pumpkin> anyone getting 504s on reddit.com?
02:04:56 <sony_ericsson> hehe MIPS no operation instruction
02:05:05 <pumpkin> not just mips :)
02:05:12 <sony_ericsson> meh, I know mips
02:05:16 <mmorrow> preflex: nickometer z0mG331337
02:05:16 <preflex>  z0mG331337 is 98.94% lame
02:05:17 <pumpkin> preflex: rot13 abcd
02:05:18 <preflex>  nopq
02:05:28 <pumpkin> preflex: nickometer mmorrow
02:05:29 <preflex>  mmorrow is 0% lame
02:05:32 <pumpkin> o.O
02:05:39 <pumpkin> preflex: nickometer pumpk1n
02:05:40 <preflex>  pumpk1n is 31% lame
02:05:42 <mmorrow> preflex: nickometer sony_ericsson
02:05:42 <preflex>  sony_ericsson is 14% lame
02:05:49 <ziman> preflex, nickometer ziman
02:05:50 <preflex>  ziman is 0% lame
02:05:50 <sony_ericsson> D:
02:05:52 <pumpkin> preflex: nickometer pumpkin
02:05:53 <preflex>  pumpkin is 0% lame
02:05:56 <pumpkin> yay
02:06:08 <nanothief> preflex: nickometer nanothief
02:06:08 <preflex>  nanothief is 0% lame
02:06:09 <mmorrow> i think any non-alpha chars get lame points
02:06:13 <pumpkin> yeah
02:06:15 <faXx> preflex: nickometer faXx
02:06:15 <preflex>  faXx is 27% lame
02:06:16 <nanothief> yay
02:06:18 <Asztal> preflex: nickometer Asztal
02:06:18 <preflex>  Asztal is 0% lame
02:06:19 <faXx> :(
02:06:28 <mmorrow> non-lower alpha that is..
02:06:31 <pumpkin> oh, uppercase-lowercase mix too?
02:06:40 <faXx> preflex: nickometer preflex
02:06:40 <mmorrow> ooh, yeah
02:06:40 <preflex>  preflex is 0% lame
02:06:42 <mmorrow> hmm
02:06:44 <Asztal> I was expecting something for the uppercase A
02:06:54 <nanothief> preflex: nickometer 1337HaX0R_lol
02:06:55 <preflex>  1337HaX0R_lol is 99.3998% lame
02:06:58 <mmorrow> maybe since it's at the beginning, it's not lame
02:07:05 <mmorrow> haha
02:07:12 <sony_ericsson> preflex: nickometer aSztal
02:07:12 <preflex>  aSztal is 18% lame
02:07:15 <mmorrow> 99.3998%
02:07:25 <sony_ericsson> preflex: nickometer pwned
02:07:25 <preflex>  pwned is 0% lame
02:07:28 <pumpkin> wow, we've hijacked the channel with nickometer
02:07:31 <sony_ericsson> preflex: nickometer ZOMG
02:07:32 <preflex>  ZOMG is 69% lame
02:07:50 <Centrinia> preflex: nickometer dons
02:07:50 <preflex>  dons is 0% lame
02:07:57 <sony_ericsson> preflex: nickometer nickometer
02:07:57 <preflex>  nickometer is 0% lame
02:08:06 <sony_ericsson> of course you would say that about yourself
02:08:13 <sony_ericsson> lying nickometer
02:08:15 <takinitez> preflex: nickometer preflex
02:08:16 <preflex>  preflex is 0% lame
02:08:17 <Centrinia> preflex: nickometer lambdabot
02:08:18 <preflex>  lambdabot is 0% lame
02:08:21 <nanothief> preflex: nickometer your_mum
02:08:21 <preflex>  your_mum is 14% lame
02:08:25 <nanothief> :(
02:08:27 <Saizan> err..
02:08:34 <Centrinia> preflex: nickometer Saizan
02:08:35 <preflex>  Saizan is 0% lame
02:08:42 <sony_ericsson> preflex: nickometer PHP
02:08:42 <preflex>  PHP is 27% lame
02:08:44 <pumpkin> I think this is enough :)
02:08:55 <Saizan> yeah.
02:08:55 <takinitez> preflex: nickometer perl
02:08:55 <preflex>  perl is 0% lame
02:08:57 <ziman> preflex, nickometer C++
02:08:58 <preflex>  C++ is 40% lame
02:08:59 <takinitez> see?
02:09:01 <Centrinia> preflex: nickometer VB.NET
02:09:02 <preflex>  VB.NET is 97.97% lame
02:09:03 <ziman> (sorry, i had to : ))
02:09:07 <takinitez> heh heh
02:09:11 <Centrinia>  :p
02:09:15 <sony_ericsson> preflex: nickometer C
02:09:15 <preflex>  C is 8% lame
02:09:17 <faXx> preflex: nickometer C#
02:09:18 <preflex>  C# is 15% lame
02:09:19 <Centrinia> preflex: nickometer C#.NET
02:09:20 <preflex>  C#.NET is 90.87% lame
02:09:24 <sony_ericsson> preflex: nickometer MIPS
02:09:24 <preflex>  MIPS is 69% lame
02:09:34 <olahol> preflex: nickometer Haskell98
02:09:35 <preflex>  Haskell98 is 19% lame
02:09:37 <blackh> 1001 uses, this preflex
02:09:48 <Saizan> if you want to spam at least write some fixpoints or so :)
02:09:59 <pumpkin> > fix (1:) -- yay
02:10:00 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
02:10:02 <Centrinia> preflex: nickometer 1rTeHl33th4x0rz
02:10:03 <preflex>  1rTeHl33th4x0rz is 99.951272% lame
02:10:05 <sony_ericsson> preflex: nickometer Microsoft
02:10:06 <preflex>  Microsoft is 0% lame
02:10:19 <sony_ericsson> preflex: nickometer Sun Micrososystems
02:10:20 <preflex>  Sun Micrososystems is 14% lame
02:10:21 <pumpkin> > fix (1:2:) -- yay
02:10:22 <lambdabot>       The operator `:' [infixr 5] of a section
02:10:22 <lambdabot>          must have lower prece...
02:10:24 <mmorrow> preflex: nickometer 99.1%
02:10:24 <preflex>  99.1% is 57% lame
02:10:30 <mmorrow> preflex: nickometer 57%
02:10:31 <preflex>  57% is 28% lame
02:10:36 <mmorrow> preflex: nickometer 12%
02:10:36 <preflex>  12% is 34% lame
02:10:38 <pumpkin> > fix ((1:) . (2:)) -- yay
02:10:39 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
02:10:42 <sony_ericsson> preflex: nickometer Leeroy Jenkins
02:10:42 <preflex>  Leeroy Jenkins is 14% lame
02:10:43 <nanothief> > fix const "I'm not that good with fix"
02:10:44 <lambdabot>       Occurs check: cannot construct the infinite type: a = b -> a
02:10:44 <lambdabot>      Proba...
02:10:54 <sony_ericsson> preflex: nickometer freenode
02:10:54 <preflex>  freenode is 0% lame
02:10:54 * nanothief sighs
02:10:56 <pumpkin> mmorrow: smart ;)
02:11:02 <Centrinia> preflex: nickometer [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
02:11:02 <preflex>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,... is 99.99145207% lame
02:11:08 <mmorrow> i'm trying to take Saizan's advice
02:11:14 <pumpkin> mmorrow: yeah, I saw :P
02:11:16 <sony_ericsson> preflex: nickometer ZING
02:11:16 <preflex>  ZING is 69% lame
02:11:17 <mmorrow> heh
02:11:31 <pumpkin> mmorrow: of course, it should contain itself... ;)
02:11:40 <mmorrow> ah true
02:11:50 <pumpkin> preflex: nickometer 57% is 57% lame
02:11:51 <preflex>  57% is 57% lame is 99.8910% lame
02:11:55 <pumpkin> oh no
02:11:57 <pumpkin> it can't :(
02:12:01 <mmorrow> looks like
02:12:02 <mmorrow> yeah
02:12:04 <pumpkin> THERE ARE NO FIX POINTS :(
02:12:16 <mmorrow> <<loop>>
02:12:40 <mmorrow> that's a great error msg btw
02:13:01 <mmorrow> the first time that happened to me i was like wuhhhh!?>
02:13:04 <pumpkin> <<loop>> ?
02:13:12 <pumpkin> how do you get that?
02:13:25 <mmorrow> if you re-enter a thunk that's currently being evaluated you get that
02:13:41 <pumpkin> you have a concise example?
02:13:59 <mmorrow> main = fix id        should do it (in compiled code)
02:14:27 <mmorrow> in ghci it just locks up until you ^Z and kill -9
02:14:37 <pumpkin> dammit you should've said that earlier :P
02:14:41 <mmorrow> hahah
02:15:11 <ziman> "kill -9, no more cpu time!"
02:15:35 <mmorrow> it also tries to eat all your mem in ghci too
02:15:42 <pumpkin> yeah, I hate it when that happens
02:15:45 <pumpkin> (quite often)
02:16:34 * mmorrow loves the little gnome-panel realtime sysmonitor graphs
02:17:21 <mmorrow> you can watch exactly how diff expressions/progs are behaving wrt mem/cpu/net/load/disk/(swap)
02:17:45 <pumpkin> :o
02:17:51 <mmorrow> the swap graph though only shows activity when all hell has borken loose though..
02:18:38 <mmorrow> if you're running gnome-panel, just right click on a panel -> add to panel, and select (i forget the name)
02:19:03 <pumpkin> I'm a mac dude :P
02:19:05 <Centrinia> preflex: nickometer warezpron
02:19:05 <mmorrow> ah, it's just called "System Monitor"
02:19:06 <preflex>  warezpron is 99.7172% lame
02:19:11 <pumpkin> I only run linux in a vm
02:19:16 <mmorrow> pumpkin: ah, dang
02:19:23 <mmorrow> i'm sure there's sometihng equiv for mac
02:19:42 <mmorrow> i can't imagine using a computer without having the equivalent graphs going
02:19:47 <pumpkin> :P
02:20:02 <pumpkin> you must pity poor deprived me
02:20:06 <mmorrow> (they update every 500 ms (configurable))
02:20:15 <mmorrow> pumpkin: indeed i do :)
02:21:57 <pumpkin> dammit, I'm still up and my gf is waking up for the day
02:22:20 <mmorrow> super
02:23:04 <Saizan> yeah, the irc-timezone-shifting effect
02:23:19 <pumpkin> :P
02:23:27 <pumpkin> I don't even know what time zone I'm in these days
02:23:29 <pumpkin> hawaii maybe?
02:26:00 <Centrinia> preflex: nickometer pr0nwarezpron
02:26:00 <preflex>  pr0nwarezpron is 99.7678% lame
02:27:02 <Centrinia> preflex: nickometer pr0n123456789warezpron
02:27:02 <preflex>  pr0n123456789warezpron is 99.8794% lame
02:27:21 <Centrinia> I can't find a 100% lame nick. :(
02:28:38 <pumpkin> I can't even find a more relaxed fixpoint, just by considering the number
02:29:20 <Centrinia> Here is how the lameness measurement is  performed: http://www.koders.com/perl/fid20938ADC99D3B903473710D75153DDB8252BB9D8.aspx?s=md5
02:31:46 <pumpkin> lol, pi?
02:32:15 <pumpkin> # Punish k3wlt0k
02:32:22 <pumpkin> preflex: nickometer k3wlt0k
02:32:23 <preflex>  k3wlt0k is 99.4000% lame
02:32:34 <pumpkin> :P
02:32:47 <Centrinia> preflex: nickometer k3wlt0kwarezpr0n[][]
02:32:47 <preflex>  k3wlt0kwarezpr0n[][] is 99.943343% lame
02:32:50 <pumpkin> preflex: nickometer pron
02:32:50 <preflex>  pron is 94.78% lame
02:33:04 <pumpkin> preflex: nickometer pr0n
02:33:05 <preflex>  pr0n is 31% lame
02:33:05 <Centrinia> preflex: nickometer k3wlt0kwarezpr0n)(][
02:33:07 <preflex>  k3wlt0kwarezpr0n)(][ is 99.957552% lame
02:33:19 <Centrinia> preflex: nickometer Centrinia
02:33:20 <preflex>  Centrinia is 0% lame
02:33:22 <Centrinia> Yay. :)
02:33:52 <pumpkin> lol, they use a hyperbolic tan in the nick coolness
02:34:04 <pumpkin> I'm sure that's rigorously motivated
02:35:17 <pumpkin> preflex: nickometer pronwarezr0
02:35:17 <preflex>  pronwarezr0 is 99.7522% lame
02:35:40 <pumpkin> preflex: nickometer pronwarezr0lord
02:35:41 <preflex>  pronwarezr0lord is 99.8173% lame
02:35:59 <pumpkin> someone needs to find the maximum of that function :P
02:36:28 <Centrinia> Yeah.
02:36:37 <sereven> nickometer k3Wld00dloOz3r
02:36:47 <paulvisschers_> preflex: nickometer preflex
02:36:48 <preflex>  preflex is 0% lame
02:36:55 <paulvisschers_> obviously
02:37:06 <sereven> preflex: nickometer k3Wld00dloOz3r
02:37:07 <preflex>  k3Wld00dloOz3r is 99.930555% lame
02:37:21 <Adamant> preflex: nickometer Adamant
02:37:22 <preflex>  Adamant is 0% lame
02:37:28 <Centrinia> preflex: nickometer ]pron0k3wlt0kwareZZ(
02:37:28 <preflex>  ]pron0k3wlt0kwareZZ( is 99.938563% lame
02:37:32 <PeakerWork> I think the max is 100-(1/min(positive_floats))
02:37:34 <Gracenotes> preflex: nickometer Gracenotes
02:37:35 <preflex>  Gracenotes is 0% lame
02:37:37 <Gracenotes> \o/
02:37:40 <paulvisschers_> preflex: nickometer paulvisschers
02:37:41 <preflex>  paulvisschers is 0% lame
02:37:45 <mmorrow> # Use an appropriate function to map [0, +inf) to [0, 100)
02:37:54 <Centrinia> PeakerWork: It does diminish.
02:38:07 <mmorrow> there is no maximum
02:38:22 <mmorrow> but it's bounded
02:39:39 <Centrinia> preflex: nickometer k3wlt0kwarezpr0n)(][69DeTHk3wlt0kwarezpr0n)(][
02:39:39 <preflex>  k3wlt0kwarezpr0n)(][69DeTHk3wlt0kwarezpr0n)(][ is 99.987891% lame
02:40:04 <Centrinia> I'll change my legal surname to that. :)
02:40:33 <pumpkin> best I can find is
02:40:38 <pumpkin> preflex: nickometer a1B!c2D@e3F#g4H$i5J%k6L^m7N&o8P*q9R(s0T)u1V-w2X+y3Z/
02:40:39 <preflex>  a1B!c2D@e3F#g4H$i5J%k6L^m7N&o8P*q9R(s0T)u1V-w2X+y3Z/ is 99.99590993% lame
02:40:51 <Centrinia> preflex: nickometer '; drop database database();
02:40:51 <preflex>  '; drop database database(); is 99.925301% lame
02:40:57 <mmorrow> haha
02:41:03 <pumpkin> :P
02:42:07 <mmorrow> i guess the maximum could be considered to be 99.99999999% lame
02:42:29 <mmorrow> ooh, maybe you can make it overflow to 100%?
02:42:46 <pumpkin> my $percentage = 100 *
02:42:46 <pumpkin> 		(1 + &Math::Trig::tanh(($score-400)/400)) *
02:42:46 <pumpkin> 		(1 - 1/(1+$score/5)) / 2;
02:43:04 <pumpkin> does that make any sense whatsoever?
02:43:17 <ziman> how did you get the formula? :)
02:43:28 <pumpkin> Centrinia linked to the source code earlier
02:43:51 <pumpkin> preflex: nickometer dark
02:43:52 <preflex>  dark is 49% lame
02:43:57 <mmorrow> @let nickometer score = 100 * (1 + tanh ((score - 400 :: Double)/400)) * (1 - 1/(1+score/5)) / 2
02:43:58 <lambdabot>  Defined.
02:44:23 <mmorrow> > nickometer 1000000
02:44:24 <lambdabot>   99.99950000249999
02:44:28 <mmorrow> > nickometer 10000000000000000
02:44:29 <lambdabot>   99.99999999999994
02:44:33 <mmorrow> > nickometer 100000000000000000000000000000
02:44:34 <lambdabot>   100.0
02:44:38 <mmorrow> woohoo
02:44:52 <mmorrow> > nickometer (1/0)
02:44:54 <lambdabot>   100.0
02:45:06 <mmorrow> heh, teh only way
02:46:24 <mmorrow> the comment above the formula says:
02:46:26 <mmorrow> # Use an appropriate function to map [0, +inf) to [0, 100)
02:47:02 <mmorrow> so Inf |-> 100
02:47:08 <pumpkin> :(
02:47:27 <mmorrow> those clever bastards
02:50:34 <ziman> what about simple 100 * (1 - 1/(1 + x))? :)
02:51:25 <mmorrow> @let nickometer' x = 100 * (1 - 1/(1 + x :: Double))
02:51:26 <lambdabot>  Defined.
02:51:33 <mmorrow> > nickometer 10000000000000000
02:51:34 <lambdabot>   99.99999999999994
02:51:36 <mmorrow> > nickometer' 10000000000000000
02:51:38 <lambdabot>   99.99999999999999
02:51:43 <pumpkin> one more one more
02:51:52 <mmorrow> > nickometer' 10000000000000001
02:51:54 <lambdabot>   99.99999999999999
02:51:59 <pumpkin> (digit)
02:52:04 <mmorrow> heh
02:52:10 <mmorrow> > nickometer' 100000000000000000
02:52:11 <lambdabot>   100.0
02:52:13 <pumpkin> whee
02:52:14 <mmorrow> boom
02:52:39 <pumpkin> you can tell it's late at night
02:52:49 <mmorrow> haha
03:07:18 <Centrinia> preflex: nickometer }:|)|[)[
03:07:18 <preflex>  }:|)|[)[ is 99.985496% lame
03:07:21 <Centrinia> Yay. :)
03:07:36 <Badger> heh
03:08:37 <Centrinia> preflex: nickometer [{,[
03:08:38 <preflex>  [{,[ is 99.8695% lame
03:08:54 <Centrinia> Short lame nicks are better than long lame nicks. :)
03:09:02 <Centrinia> preflex: nickometer ))[{
03:09:02 <preflex>  ))[{ is 99.901231% lame
03:09:22 <Badger> preflex: nickometer CAPS
03:09:23 <preflex>  CAPS is 69% lame
03:09:39 <Badger> capitalisation isn't so lame at all :)
03:09:48 <Centrinia> preflex: nickometer CaPS
03:09:48 <preflex>  CaPS is 18% lame
03:09:51 <Centrinia> Weird.
03:09:54 <Badger> hah
03:10:01 <Centrinia> preflex: nickometer C4PS
03:10:01 <preflex>  C4PS is 45% lame
03:10:04 <PeakerWork> preflex: nickometer PeAkEr
03:10:05 <preflex>  PeAkEr is 99.8268% lame
03:10:11 <Badger> owch
03:10:15 <Centrinia> Yeah.
03:10:28 <Centrinia> preflex: nickometer CeNtRiNiA
03:10:29 <preflex>  CeNtRiNiA is 99.957789% lame
03:10:34 <Centrinia> Ouch. :(
03:10:52 <Badger> must wonder
03:11:00 <Badger> preflex: nickometer Centrinia
03:11:00 <preflex>  Centrinia is 0% lame
03:11:05 <Badger> :o
03:11:21 <Badger> preflex: nickometer Anythinglikethis
03:11:22 <preflex>  Anythinglikethis is 0% lame
03:11:24 <Badger> Ah.
03:11:28 <ksf> preflex, nickometer |<51'
03:11:29 <preflex>  |<51' is 92.80% lame
03:11:45 <ksf> @elite ksf
03:11:45 <lambdabot> xzf
03:11:50 <ksf> @elite ksf
03:11:50 <lambdabot> x$ph
03:12:03 <ksf> preflex, nickometer x$ph
03:12:04 <preflex>  x$ph is 14% lame
03:12:14 <Badger> poor $.
03:14:18 <RayNbow> preflex, nickometer %eax
03:14:19 <preflex>  %eax is 14% lame
03:14:22 <RayNbow> poor accumulator
03:16:15 <ksf> yeah, rax > eax
03:16:57 <ksf> in fact, xor rax, rax utterly pwns eax.
03:17:20 <RayNbow> :p
03:18:37 <mmorrow> @remember ksf rax utterly pwns eax.
03:18:40 <lambdabot> Nice!
03:19:04 <pumpkin> @remember mmorrow @remember ksf rax utterly pwns eax.
03:19:04 <lambdabot> Nice!
03:19:11 <mmorrow> @quote pwn
03:19:11 <lambdabot> mmorrow says: @remember ksf rax utterly pwns eax.
03:19:15 <mmorrow> @quote pwn
03:19:15 <lambdabot> ksf says: rax utterly pwns eax.
03:19:17 <pumpkin> sorry :P
03:19:19 <mmorrow> heh
03:19:33 <mmorrow> meta-@remember
03:19:42 <ksf> you're quoting me out of context! how dare you! ;)
03:19:54 <mmorrow> ksf: haha :)
03:20:00 <Centrinia> preflex: nickometer (]mbGM[q9eFlmZ,}Tfd>>vDw#[,(j}AI)gAv'&(=}+}OetCt
03:20:01 <preflex>  (]mbGM[q9eFlmZ,}Tfd>>vDw#[,(j}AI)gAv'&(=}+}OetCt is 99.99578009% lame
03:20:19 <pumpkin> Centrinia: sorry, mine was better
03:20:19 <ksf> is that perl or malbolge?
03:21:09 <pumpkin> we're trying to find the lamest nick
03:21:22 <pumpkin> but mmorrow went and ruined it by showing there is no lamest nick
03:21:35 <papermachine> How did it show that?
03:21:44 <pumpkin> it?
03:21:49 <papermachine> mmorrow
03:22:05 <Centrinia> preflex: nickometer )l($+~+.#]<!?#>}{o:3y8Z$Qp1&;Q;-*a2Y#)o.'[fSn~,0`!>`IMpGe/{/
03:22:06 <preflex>  )l($+~+.#]<!?#>}{o:3y8Z$Qp1&;Q;-*a2Y#)o.'[fSn~,0`!>`IMpGe/{/ is 99.99694371% lame
03:22:08 <Centrinia> Lame.
03:22:09 <Centrinia> See. :)
03:22:22 <papermachine> ah.
03:22:35 <pumpkin> Centrinia: omg you beat my lameness :(
03:22:41 <pumpkin> it was only a matter of time, I guess
03:22:47 <Centrinia> I was just generating random nicks.
03:22:50 <mmorrow> papermachine: the function they use is from [0,+inf) -> [0,100)
03:22:56 <pumpkin> someone should figure out the lamest nick within the constraints of the freenode ircd
03:23:00 <pumpkin> that should be possible
03:23:00 <mmorrow> so only:
03:23:08 <mmorrow> > nickometer (1/0)
03:23:09 <lambdabot>   100.0
03:23:11 <papermachine> mmorrow: Oh, okay.
03:23:26 <pumpkin> Centrinia: there's a new challenge for you ;)
03:23:54 <Centrinia> Find the lamest nick that is a valid FreeNode name?
03:23:59 <pumpkin> yup
03:24:12 <Badger> > 1 / 0
03:24:13 <pumpkin> apparently longest nick is 16 chars
03:24:13 <lambdabot>   Infinity
03:24:29 <pumpkin> not sure what the allowed chars are
03:25:03 <Badger> hmmm
03:25:06 <Badger> welll
03:25:57 <pumpkin> whee I hit 200 twitter followers :D
03:26:30 <Badger> Do you twitter about haskell?
03:26:47 <pumpkin> only a tiny bit, so far (I'm still just a beginner)
03:26:58 <pumpkin> mostly things like "omg haskell's so cool"
03:27:08 <Badger> enlightening. :P
03:27:22 <pumpkin> yup, certainly
03:34:24 <blackh> Haskell is so cool!  I just wish I could stop getting mired in FFI bindings and writing so much C!
03:36:10 <QtPlatyp1s> Why do you have do that?
03:37:17 <PeakerWork> pumpkin: what are "twitter followers"?
03:37:32 <blackh> I'm doing a web application, and so I'm doing some image processing among other things.
03:37:34 <PeakerWork> pumpkin: are they fans of a "micro blog"? If so, what are you pasting there?
03:38:14 <blackh> Not all that worth releasing since it's about 3 functions out of hundreds.  Was using DevIL but I had the strangest crash bug and I've switched to GraphicsMagick++ which is much easier to use.
03:38:44 <pumpkin> PeakerWork: twitter allows you to subscribe to other people's tweets, and when you do that you become that person's "follower"
03:39:25 <pumpkin> PeakerWork: I'm not putting anything interesting on it, but I'm involved in a rather popular "movement" and lots of people "follow" me in the hopes they'll catch something interesting (which I don't provide)
03:42:13 <mmorrow> blackh: have you tried the ImageMagick bindings on hackage?
03:42:47 <mmorrow> (i haven't, but i looked at the code and it appears to be pretty thorough)
03:43:33 <blackh> The only binding I found was Codec-Image-DevIL but that only has 1 function and that isn't thread safe.
03:43:45 <blackh> Oh - bollocks - there it is hsmagick
03:44:06 <mmorrow> heh, if you use it i'd love to hear how it turns out
03:44:13 <blackh> I completely missed it.
03:44:32 <blackh> Thanks - that could save me some trouble.
03:44:40 <mmorrow> np :)
03:44:42 <blackh> All I'm doing at present is scaling, but I'll use that library if I do anything more fancy.
03:45:15 <blackh> Also I did a Berkeley DBXML binding.  I hate SQL that much.
03:45:21 <mmorrow> cool. are you using a function that'll resample for you if you're scaling by non-integral amounts?
03:45:55 <mmorrow> (well, amounts which the current image x and/or aren't divisible by)
03:46:10 <mmorrow> *x and/or y ...
03:46:13 <blackh> ...which is almost all the time in this case - yes, the scaled images look really nice.
03:46:20 <mmorrow> nice :)
03:47:04 <blackh> Great. That's working. Now a bit more actual Haskell before I call it a day!
03:47:37 <mmorrow> good luck
03:51:06 <PeakerWork> pumpkin: sounds addictive
03:51:20 <pumpkin> PeakerWork: you should get a twitter account and tweet about haskell :P
03:51:31 <PeakerWork> pumpkin: I am not sure I need another addiction
03:52:47 <Centrinia> I have an idea.
03:53:00 <PeakerWork> pumpkin: what are some example tweets about Haskell?
03:53:07 <ag`A[`}}}`{Z{PNU> preflex: nickometer ag`A[`}}}`{Z{PNU
03:53:08 <preflex>  ag`A[`}}}`{Z{PNU is 99.986634% lame
03:53:12 <ag`A[`}}}`{Z{PNU> I'm pretty lame. :(
03:53:36 <mmorrow> blackh: oh nice on the berkeley dbxml binding. maybe consider putting it on hackage at some point :)
03:53:46 <Badger> Centrinia: impressive fail :P
03:54:00 <Centrinia> Thank you. :)
03:54:07 <mauke> preflex: quote
03:54:08 <preflex>  <impulze> thinking is the first step towards failure
03:54:11 <blackh> Yes - I put it on hackage with a little adventure game as an example.  Anyone that uses it, let me know.  I've been testing it a lot so it does work.
03:54:30 <mmorrow> blackh: ah nice, you're one step ahead of me.
03:55:03 <blackh> mmorrow: Also a tutorial http://www.haskell.org/haskellwiki/BerkeleyDBXML
03:55:20 <pumpkin> blackh: ooh dbxml is cool
03:55:23 <mmorrow> blackh++
03:55:38 <mmorrow> i've really gotta use the wiki more (than never)
03:55:42 <pumpkin> PeakerWork: dunno, dons and conal use it, but conal mostly announces his blog posts on it rather than using it as a haskell venue itself
03:55:49 <blackh> :) I like the HXT picklers.  Lovely!
03:57:25 <pumpkin> only issue with bdbxml is that the build process sucks
03:57:56 <blackh> pumpkin: Strangely I have found that I just type './buildall.sh' and ... some while later ... it's all there.
03:58:11 <pumpkin> blackh: yeah, it's easy, but I don't like it
03:58:21 <pumpkin> they include their own packaged forms of a bunch of stuff
03:58:35 <pumpkin> and it builds them all at once
03:59:03 <blackh> I gave some instructions on how to built it against your OS's version of db4.x - otherwise it gets a little annoying.
03:59:21 <PeakerWork> blackh: HXT picklers?
03:59:47 <blackh> I like DbXML - I've used it for several projects and it does the trick.
03:59:58 <PeakerWork> blackh: I'm looking for/want to build a pickler combinator library so that I can easily describe things like the CSV format once, and derive both decoders and encoders from it. So when I hear "pickler" I am interested (maybe someone already solved the problem)
03:59:59 <pumpkin> I like bdb in general too :)
04:00:31 <blackh> PeakerWork: HXT is one of the Haskell XML libraries and it has some nice data structure picklers (serializers).
04:01:15 <blackh> PeakerWork: See http://www.haskell.org/haskellwiki/HXT/Conversion_of_Haskell_data_from/to_XML
04:01:40 <PeakerWork> blackh: oh, I saw plenty of picklers that can work for existing data types with almost no work (e.g even Data.Binary), but none that can easily describe yucky data structures (e.g csv)
04:04:37 <blackh> Another thing I need to investigate later on is getting a bit more speed out of XML processing.  HXT doesn't have much ByteString support.
04:04:45 <Centrinia> There are 250451070959311884057971014440 valid IRC nicknames.
04:05:05 <mauke> Centrinia: depends on the case mapping used
04:05:16 <Centrinia> Oh.
04:05:36 <pumpkin> also, do they have any rules beyond just "16 of the allowed characters?"
04:05:48 <pumpkin> i.e., no swear words, no starting with char x, maybe?
04:05:55 <pumpkin> e.g., whoops
04:06:09 <PeakerWork> Centrinia: Clearly IRC is not scalable enough
04:07:09 <blackh> We need IRCv6.  Right - goodnight y'all.
04:07:27 <Centrinia> Here is the RFC: http://www.faqs.org/rfcs/rfc2812.html
04:14:07 <Heffalump> what's the standard name for the data type that's like lists but has a statically known length using type-level nats?
04:16:52 <jkff> I don't think it has a standard name
04:17:11 <Heffalump> I'd call it vector but some fools have made array libraries called that ;-)
04:18:27 <mmorrow> heh
04:18:39 <Saizan> Vec n a is what i've usually seen
04:18:57 <Saizan> e.g. in agda intros
04:19:41 <mmorrow> the word "vector" though makes me think of being able to (cheaply) get components of it
04:19:55 <mmorrow> (cheaply := O(1))
04:20:42 <Saizan> in principle it could be optimized so that's true, when n is statically known
04:20:42 <mmorrow> , ppDoc `fmap` tupE (fmap lift [0..9::Int])
04:20:56 <lunabot>  (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
04:21:09 <Heffalump> n isn't really statically known, it's just sort of in the type system
04:22:00 <mmorrow> , ppDoc `fmap` foldr (\x y -> [|($x,$y)|]) [|()|] (fmap lift [0..9::Int])
04:22:03 <lunabot>  (0, (1, (2, (3, (4, (5, (6, (7, (8, (9, ()))))))))))
04:23:05 <Saizan> that's what i meant, but with existentials or polyrec you can build vectors of runtime-dependent size i think
04:23:17 <pumpkin> @pl \(x, y) -> (y, x)
04:23:17 <lambdabot> uncurry (flip (,))
04:23:31 <Heffalump> yeah
04:23:41 <Heffalump> that's precisely the distinction I meant
04:23:57 <mmorrow> Heffalump: what method are you using to get the type-level nats?
04:24:16 <Heffalump> data Zero , data Succ n
04:24:31 <mmorrow> ah, nice and simple :)
04:24:44 <Heffalump> what else might I be doing?
04:24:53 <Heffalump> well, I guess they could be binary
04:24:58 <Heffalump> but then the vectors would be trees
04:25:06 <mmorrow> i've seen people use GADTs, type classes, ... other hackery
04:25:19 <Heffalump> well, the Vectors are defined as a GADT
04:25:27 <Saizan> you can use a decimal representation and use classes for addition
04:25:45 <Saizan> (for example)
04:26:07 <mmorrow> i messed with doing data _0, _1, _2, _3, ... _9 , then (e.g.)  (_4,(_2, _9)) once
04:26:31 <mmorrow> was just playing with it though
04:26:34 <Saizan> _ is valid?
04:26:43 <mmorrow> i think
04:26:53 <mmorrow> (or maybe i did N0, N1, ... N9)
04:27:13 <mmorrow> , [d| data _1 |]
04:27:15 <lunabot>  luna: Malformed head of type or class declaration
04:27:21 <mmorrow> , [d| data _1 = _1|]
04:27:23 <lunabot>  luna: Malformed head of type or class declaration
04:27:26 <mmorrow> guess not
04:32:59 <roderyk> building a small gtk app. I have a rotating image that needs to be updated ~100ms to seem fluid. Currently I'm just using SVG and gtk2hs to render the new image every 100ms. It works, but it does create flicker effects. If I switch over to using primitive Render() effects (instead of svg), will it be enough to not have visible flickers with these frequent updates? Or do I need to look into converting this to opengl?
04:42:17 <arjanb> @hoogle (s -> s) -> State s ()
04:42:18 <lambdabot> Control.Monad.State.Lazy withState :: (s -> s) -> State s a -> State s a
04:42:18 <lambdabot> Control.Monad.State.Strict withState :: (s -> s) -> State s a -> State s a
04:42:18 <lambdabot> Control.Arrow arr :: Arrow a => (b -> c) -> a b c
04:43:07 <PeakerWork> State is also an arrow?
04:43:28 <arjanb> i don't think so
04:43:31 <PeakerWork> It would need to be Kleiskli'd for that, wouldn't it?
04:43:43 <PeakerWork> Why would hoogle return that then?
04:45:11 <Saizan> i don't think hoogle takes instances into consideration
04:45:39 <Saizan> @google Char -> Char -> Char
04:45:47 <Saizan> @hoogle Char -> Char -> Char
04:45:47 <dolio> It just thinks that "(b -> c) -> a b c" matches "(s -> s) -> State s ()".
04:45:51 <lambdabot> http://www.chachachar.com.au/
04:45:52 <lambdabot> Title: Cha Cha Char Wine Bar & Grill
04:45:52 <lambdabot> Prelude max :: Ord a => a -> a -> a
04:45:52 <lambdabot> Prelude min :: Ord a => a -> a -> a
04:45:52 <lambdabot> Data.Ord max :: Ord a => a -> a -> a
04:46:01 <dolio> Which it does in a roundabout way, I guess.
04:46:11 <dolio> Depending on how much you fuzz it.
04:46:49 <dolio> @type modify
04:46:50 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
04:48:19 <arjanb> thanks dolio
04:48:40 <arjanb> why didn't hoogle find that one?
04:48:56 <dolio> It's matching is less than stellar.
04:50:04 <dolio> Apparently it doesn't like matching "m" with "State s".
04:50:44 <dolio> But replacing 'c' with 's' in one case and '()' in another is fine. :)
04:53:43 <dolio> Hayoo produces even less relevant results.
04:54:12 <Ezla> Why does haskell need its own "Hayoo" ?
04:55:08 <Ezla> ah, it's an API search
05:04:59 <mmorrow> here's a quicky IRC msg parser http://hpaste.org/12802
05:05:09 <mmorrow> ReadP++
05:05:14 <mmorrow> @karma ReadP
05:05:14 <lambdabot> ReadP has a karma of 4
05:05:18 <mmorrow> heh
05:05:45 <Saizan> (there's an irc package on hackage)
05:06:12 <mmorrow> Saizan: what's "hackage"?
05:06:28 <mmorrow> ;)
05:06:29 <mmorrow> does it use ReadP?
05:06:46 <Saizan> parsec i think
05:06:54 <mmorrow> bah!
05:06:59 <Saizan> ReadP++
05:07:01 <mmorrow> :)
05:07:12 <Saizan> do we have a ReadP over bytestring?
05:08:01 <mmorrow> Saizan: yeah, there's actually a bytestringreadp pkg on hackage that someone modded ReadP to work on ByteStrings
05:08:13 <mmorrow> i looked at the src and he did a good job too
05:08:32 * mmorrow has been hacking around with ReadP a bunch lately
05:08:58 <mmorrow> it's has a really cool datatype `P'
05:09:01 <mmorrow> *it
05:09:42 <mmorrow> then  ReadP a = R {unR :: forall b. (a -> P b) -> P b}
05:10:21 <Saizan> ah, the good old forall r. ContT r
05:10:43 <mmorrow> data P a = Get (Char -> P a) | Look (String -> P a) | Result a (P a) | Fail
05:11:08 <mmorrow> (there's another constructor for ReadS backwards compat, but i deleted this one in my version ;))
05:11:51 <mmorrow> it's only a source of possible inefficiency and is only needed if you want to do readS_toP anyway
05:12:45 <Saizan> Get is the one that let's you run the alternatives in parallel?
05:13:27 <mmorrow> the combo of P + the mplus for P
05:13:32 <mmorrow> P'
05:14:01 <mmorrow> s mplus makes it breadth first
05:14:03 <mmorrow> Get f1     `mplus` Get f2     = Get (\c -> f1 c `mplus` f2 c)
05:14:19 <mmorrow> Result x p `mplus` q          = Result x (p `mplus` q)
05:14:21 <mmorrow> etc
05:14:39 * mmorrow just so happens to have it open..
05:15:22 * Saizan opens it too
05:15:50 <mmorrow> it's such a neat little module
05:16:50 <ksf> meh I don't wanna upgrade to 6.10.
05:17:17 <mmorrow> accept teh future
05:19:12 <ksf> but, but... stuff is gonna break!
05:20:16 <PeakerWork> if you upgrade to 6.10, forget about mueval and its dependents
05:23:34 <doublec> the most common breakage seems to be anything to do with run time evaluation
05:23:44 <Saizan> PeakerWork: the darcs version has been updated
05:25:44 <PeakerWork> Saizan: mueval works on 6.10?
05:25:55 <PeakerWork> Saizan: can lambdabot run on 6.10?
05:27:20 <Centrinia> @faq Can lambdabot run on 6.10?
05:27:20 <lambdabot> The answer is: Yes! Haskell can do that.
05:27:27 <Saizan> PeakerWork: haven't tried personally, but if mueval does, it should
05:27:37 <ksf> well, luckily i got a xmonad binary in my $HOME, so I won't be utterly lost.
05:28:12 <ksf> sed: can't read /var/tmp/portage/dev-lang/ghc-6.10.1/work/usr/bin/ghc-6.10.1: No such file or directory
05:28:14 <ksf> wut?
05:28:15 <PeakerWork> @faq Can Haskell lift a stone so heavy, that even Haskell can't lift it?
05:28:15 <lambdabot> The answer is: Yes! Haskell can do that.
05:28:43 <Ezla> Dr.Dobb's has this article "It's Time to Get Good at Functional Programming", and they look at Erlang, F#, and Scala positively... yet, about Haskell
05:28:45 <Ezla> http://www.ddj.com/development-tools/212201710
05:28:48 <Ezla> They say:
05:28:58 <ksf>  * The die message:
05:28:59 <ksf>  * Relocating ghc from /usr to workdir failed
05:29:03 <Ezla> "Finally, what if you just want to learn this different way of programming? You understand that to get really good at thinking in FP mode you'll need to go back to school (figuratively). You want a pure (not hybrid) FP experience and you aren't expecting to get productive work out of the exploration. Is there a best language for simply learning functional programming?"
05:29:20 <Ezla> "A good case can be made for Haskell."
05:29:49 <Ezla> "and you aren't expecting to get productive work out of the exploration"
05:29:54 <ksf> Haskell is the best imperative language there is.
05:30:09 <Ezla> Why would they claim that?
05:30:36 <ksf> note: oneself not expecting isn't oneself not being.
05:30:51 <Centrinia> You usually don't get a lot of productive work out of the exploration of any programming language that you are not familiar with. :)
05:30:54 <ksf> actually, it's more common to be the other way round.
05:32:09 <Ezla> they claim something like F# will lead to productive work
05:32:29 <Centrinia> Too bad.
05:32:43 <PeakerWork> Ezla: perhaps the learning curve before becoming productive in Haskell is bigger than in those languages (though it probably pays off, with bigger producitvity)
05:32:53 <mmorrow> Ezla: heh, i read that part and quickly realized the author doesn't know anything about haskell
05:33:12 <Ezla> mm: eh?
05:33:20 <Centrinia> mmorrow: How did you realize that?
05:33:35 <mmorrow> and on top of that, he seems to be slightly "those academics and their cute little games"
05:33:41 <Ezla> well I'm wondering if microsoft's paying Dobb's
05:33:44 <Ezla> or owns dobbs
05:33:55 <mmorrow> Centrinia: because if he did know about it, he would never have said what he did :)
05:34:09 <Centrinia> Fair enough. :)
05:34:11 <mmorrow> err, i should say, wouldn't have phrased it the way he did
05:35:34 <Centrinia> What is a "commercial implementation"?
05:36:31 <mmorrow> one whose backers can exert financial pressure on authors of such writeups to look favorably upon them?
05:37:23 <mmorrow> one that that has a  on the end of it's name?
05:37:34 <Ezla> It was interesting to me cause not-actually-getting-work-done is my fp fear.
05:38:04 <mmorrow> Ezla: and it seems to me that pandering to that fear is exactly what that author was doing :)
05:39:04 <mmorrow> but, at the same time, haskell isn't a "silver bullet" as they say (nor is anything)
05:39:49 <mmorrow> and if you don't have a functional programming background already (and even if you do) it'll take longer to learn how to use effectively than a language similar to the ones you already do know
05:39:55 <mmorrow> </my 2cents> :)
05:40:35 <Centrinia> Ezla: It is sometimes better to not get some work done because the work to maintain faulty code is much more expensive than simply not having the code in the first place. :)
05:42:57 <mmorrow> did this come through mangled to anyone , or is it just me?
05:43:09 <Ezla> looks fine
05:43:15 <mmorrow> ok, nice
05:43:15 <Ezla> I use Fixedsys Excelsior
05:43:32 * mmorrow looks what font he's using
05:43:34 <Ezla> http://www.fixedsysexcelsior.com/information/scripts.gif
05:43:47 <mmorrow> courier 10 pitch
05:43:59 <mmorrow> cool, i'll check it out
05:44:11 <ksf> bitstream works, too.
05:44:32 <mmorrow> it's odd, because i coulda sworn that same sym came through fine the other day
05:45:20 <skorpan> Ezla: is it just me or does the color of the text change?
05:45:22 <jaj> you might want to try terminus, I love that font
05:45:42 <Ezla> skorpan: They just applied some gimp filter or whatever
05:45:52 <Ezla> to make the example look neater
05:46:01 <skorpan> jaj: i use the smallest terminus but made my own bold version
05:46:08 <Ezla> No, you aren't having psychedelic flashbacks
05:48:37 <PeakerWork> why does "reset" on the tty/terminal take _seconds_? :-(
05:49:01 <ksf> I don't like fixed fonts.
05:49:17 <PeakerWork> ksf: maybe you haven't tried the nice ones yet?
05:49:31 <PeakerWork> ksf: Anti-aliased "DejaVu Sans Mono" is great
05:49:33 <ksf> monospace yes, but not those that you can't scale.
05:49:40 <PeakerWork> oh
05:54:11 <Ezla> How do I make a tuple of types?
05:54:36 <Ezla> or even a type list
05:54:54 <PeakerWork> Ezla: Types are not values, you can't put them in a value-container like a list or tuple
05:55:01 <Ezla> don't care
05:55:10 <PeakerWork> Ezla: What do you want to do?
05:55:18 <Ezla> A tuple / list of types
05:55:23 <PeakerWork> Ezla: what for?
05:56:17 <Ezla> Peaker, I don't approach it from the perspective of "gee, I'm trying to build a program, and I need X"
05:56:26 <Ezla> I find out every possibilty first
05:58:11 <Saizan> Ezla: data Cons a b; data Nil; then type Foo = Cons Int (Cons Bool Nil)
05:58:44 <Ezla> so it's a recursive datastructure ?
05:58:48 <Saizan> however lists of types are not exactly standard procedure
05:59:09 <Ezla> Is there a library for working with type tuples?
05:59:32 <twb> Cabal can auto-detect things like "should I use libcurl or libwww?".  But by default, "cabal configure" doesn't tell me what it has auto-detected, so it's not until I finish compiling that I realize that cabal never found libcurl.
05:59:52 <twb> Is there anything like "cabal configure --summary" to tell me what dependencies have been found?
06:00:10 <Saizan> Ezla: you probably want to read the HList paper to get a feeling on this kind of type-level programming
06:00:16 <twb> Hmm, --verbose works, but is a bit overwhelming
06:00:48 <Ezla> In C++ and D template metaprogramming, working with type lists is common fair. It used to be implemented the way you just did it, with vec<T, vec<T2, vec<T3, Nil>>>
06:01:08 <Ezla> however, some years back, people couldnt stand that anymore
06:01:20 <Ezla> and so C++0x implements typelists natively
06:01:38 <Ezla> template <class... X> class Foo : X {
06:01:45 <Saizan> we're not there yet, probably since typelists are not common/needed enough
06:01:46 <Ezla> Foo inherits from all of X
06:02:10 <twb> Saizan: maybe people don't use them because they can't, rather than because they aren't useful :-)
06:02:18 <twb> Saizan: sapir-whorf and all that :P
06:02:19 <Ezla> twb: no
06:02:26 <Ezla> They are useful.
06:02:31 <twb> Ezla: that's my point
06:02:50 <Ezla> You said they're not.
06:02:52 <Saizan> C++ templates and haskell typeclasses are quite different frameworks i think
06:02:55 <twb> C'mon, feature creep!
06:02:59 <Ezla> Typelists are useful in template programming
06:03:11 <Ezla> Needed for compile time programming
06:03:26 <Ezla> I doubt Templae Haskell would be usable without proper Type tuples
06:03:30 <Ezla> *template haskell
06:03:58 <Ezla> Saizan: "class" there doesn't matter
06:04:10 <Ezla> class isnt being used in an OO sense
06:04:10 <int-e> sigh
06:04:22 <Saizan> Ezla: i realize that
06:04:31 <twb> Remind me, are C++ templates just a shitty backport of Lisp macros?
06:04:32 <Ezla> class is used to contain a single member
06:04:40 <Ezla> which is pure
06:04:43 <Saizan> Ezla: it's just that compile time programming is done via typeclasses in haskell
06:04:45 <Ezla> ie:
06:04:53 <PeakerWork> Ezla: Template Haskell works at the AST level..
06:04:56 <mm_freak> i have a (State s a) function  if i force the result of that function to evaluate inside of that function, it's slow  if i force the evaluation outside of that function (in the caller), it's fast  any explanation for this?
06:05:01 <Ezla> template <class X> class Foo { typedef X* type; }
06:05:24 <Ezla> In c++ template metaprogramming, its pure / functional
06:05:36 <PeakerWork> Ezla: you can hold a list of type names, for example, in Template Haskell, but that's not where a Haskell beginner should be diving
06:05:41 <Saizan> Ezla: i'm just saying that maybe we solve the same problems C++ templates do, but differently?
06:05:54 <Ezla> Saizan: No, you're talking about runtime stuff
06:05:57 <Saizan> Ezla: or maybe we don't
06:06:07 <Saizan> Ezla: no, i'm talking about compile time.
06:06:12 <kfish> Ezla, maybe you want to play with type classes and type families, not template haskell
06:06:24 <Ezla> not type classes
06:06:30 <Ezla> but a Compile time type list
06:06:32 <PeakerWork> Ezla: Its probably more productive to learn a language as those who know it think it should be learned, rather than trying to map some already-known language's concepts one-by-one to the target language, they may not map well
06:06:50 <mm_freak> http://hpaste.org/12803  here's the code
06:06:53 <mmorrow> , ppDoc `fmap` foldr (\x y -> [|($x,$y)|]) [|()|] (fmap lift [0..9::Int])
06:06:54 <Ezla> doesn't matter Peaker
06:07:02 <lunabot>  (0, (1, (2, (3, (4, (5, (6, (7, (8, (9, ()))))))))))
06:07:03 <mmorrow> , foldr (\x y -> [|($x,$y)|]) [|()|] (fmap lift [0..9::Int])
06:07:05 <Ezla> it's Univerasal
06:07:05 <lunabot>  TupE [LitE (IntegerL 0),TupE [LitE (IntegerL 1),TupE [LitE (IntegerL 2),T...
06:07:09 <Ezla> *universal
06:07:14 <skorpan> Ezla: which font was scripts.gif of?
06:07:15 <Saizan> Ezla: in haskell, the only way to do computations at compile time, is either using TemplateHaskell which is a macro system, or use typeclasses as a form of prolog
06:07:16 <PeakerWork> Ezla: very few things about PL's are truly universal
06:07:18 <mmorrow> you're manipulating the abstract syntax tree with template-haskell
06:07:27 <mmorrow> , [|\x -> x|]
06:07:30 <lunabot>  LamE [VarP x_0] (VarE x_0)
06:07:32 <Saizan> Ezla: i recommend you the HList paper, it does a lot of that
06:07:37 <twb> PeakerWork: untyped lambda calculus? :-)
06:07:44 <Ezla> I want to do half my work at compile time
06:07:58 <mm_freak> with the (x `seq` return (x:xs)), it runs about five times as fast as with forcing the return value in the nextRC4 function
06:08:02 <EvilTerran> "compile time" is an implementation detail :P
06:08:06 <Ezla> In D, any function you write, can be used at compile time and runtime
06:08:13 <twb> Programming is not something done in front of a computer.
06:08:15 <mmorrow> Ezla: what would be one of the things you'd want to do at compile-time?
06:08:17 <kfish> Saizan, or type families in newer ghc :-)
06:08:19 <Ezla> if it's used at compile time, it must be pure
06:08:34 <PeakerWork> Ezla: then use either: A) TH B) Prolog-style type-class solutions (as Saizan mentioned) C) rewrite rules D) simple separate code/data generator
06:08:39 <Ezla> and compile time functions can for example work with type lists
06:08:43 <EvilTerran> write normal haskell, push it through supero, and it'll do some of the work at compile time :)
06:08:45 <Ezla> as well as regular code
06:08:47 <EvilTerran> ?where supero
06:08:47 <kfish> Ezla, http://www.haskell.org/haskellwiki/Category:Type-level_programming
06:08:47 <lambdabot> I know nothing about supero.
06:09:02 <EvilTerran> ?where+ supero http://www-users.cs.york.ac.uk/~ndm/supero/
06:09:02 <lambdabot> Done.
06:09:05 <Saizan> Ezla: ok, that's something that you can't do in haskell
06:09:23 <mmorrow> Ezla: well, you can have a list of type Exp at compile-time, where the types of the expressions those Exp's represent are different.
06:09:51 <mmorrow> do in ghci:
06:09:53 <mmorrow> :i Language.Haskell.TH.Syntax.Exp
06:09:59 <mmorrow> to see what that datatype is
06:10:24 <Ezla> Saizan: Why not?
06:10:30 <mmorrow> (but that's a list of type :: [Exp])
06:10:31 <Ezla> I was SURE haskell could do this stuff
06:10:32 <Ezla> goddamnit
06:10:41 <mmorrow> heh
06:10:47 <mmorrow> you can have a [Type] too
06:10:57 <Saizan> haskell functions only work on values
06:11:14 <PeakerWork> Ezla: compile-time programming is rare enough that the somewhat inadequate solutions I mentioned above are good enough
06:11:15 <Saizan> and at compile time there only types
06:11:16 <Ezla> Sure, but why not allow functions at compile time as well?
06:11:17 <mmorrow> , [[t|Int|], [t|forall a b c d. ((a -> b) -> c) -> d]]
06:11:18 <lunabot>  luna: parse error on input `]'
06:11:28 <mmorrow> , [[t|Int|], [t|forall a b c d. ((a -> b) -> c) -> d|]]
06:11:30 <lunabot>  [ConT Int,ForallT [a_0,b_1,c_2,d_3] [] (AppT (AppT ArrowT (AppT (AppT Arr...
06:12:04 <Saizan> Ezla: because we like to keep our typesystem decidable
06:12:06 <PeakerWork> Ezla: Functions can be executed at compile-time by ghc, but I don't think you can guarantee it
06:12:12 <Saizan> Ezla: rather than turing-complete
06:12:19 <mmorrow> Ezla: i'm sure what you want can be done, i'm just trying to figure out exactly what it is :)
06:12:48 <Saizan> Ezla: if you want metaprogramming like in lisp you can use Template Haskell
06:12:50 <mmorrow> like, what would be a concrete example of something you'd want to do (at compile-time)
06:13:49 <Saizan> or you can look at Agda, which is dependently typed, so you have values inside types
06:13:51 <mmorrow> you can programmatically construct code with template-haskell (can't create module sadly at current time)
06:14:11 <Ezla> How does template haskell do type lists?
06:14:19 <mmorrow> what is a type list?
06:14:34 <mmorrow> (i'm not sure exactly what you're refering to)
06:14:36 <Ezla> The type list system should be unified, so that at compile time, Types are values
06:14:43 <PeakerWork> Ezla: you can hold a list of AST entities that _represent_ types in some way. What would you do with a list of types?
06:14:45 <Ezla> and you can use the same old haskell syntax
06:14:48 <mmorrow> oh, i see what you're saying
06:15:15 <mmorrow> if you want type info to be preserved at runtime, you'll have to create and preserve that info yourself
06:15:28 <Ezla> int-e actually left the channel cause he was so upset I said that classes aren't for OO
06:15:31 <mmorrow> this is kinda done with Dynamic and Typeable
06:15:42 <mmorrow> but they can't do polymorphic types
06:16:11 <Ezla> what's dynamic and typeable?
06:16:22 <mmorrow> Data.Dynamic and Data.Typeable
06:16:26 <mmorrow> , typeOf 42
06:16:28 <lunabot>  Integer
06:16:35 <mmorrow> , toDynamic 42
06:16:35 <Ezla> does that produce fake typeid values
06:16:37 <lunabot>  luna: Not in scope: `toDynamic'
06:16:40 <Ezla> which are keyable
06:16:40 <mmorrow> , toDyn 42
06:16:42 <lunabot>  <<Integer>>
06:16:43 <mmorrow> yes
06:16:47 <Ezla> Ok, thats different
06:16:56 <mmorrow> @src Typeable
06:16:56 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
06:17:01 <mmorrow> , src ''Typeable
06:17:09 <lunabot>  class Typeable a where
06:17:09 <lunabot>          typeOf :: a -> TypeRep
06:17:11 <mmorrow> lunabot's slow today
06:17:13 <Ezla> It's useful at runtime for ie, factories, but typeid values can't be used to produce static code
06:17:19 <mmorrow> , src ''Dynamic
06:17:24 <lunabot>  data Dynamic = Dynamic TypeRep Obj
06:17:29 <mmorrow> , src ''TypeRep
06:17:34 <lunabot>  data TypeRep = TypeRep !Key TyCon ([TypeRep])
06:17:39 <mmorrow> Key = Int
06:17:39 * EvilTerran notes that int-e could've sighed and/or left the channel for completely different reasons
06:17:54 <mmorrow> , src ''TyCon
06:17:59 <lunabot>  data TyCon = TyCon !Key String
06:18:20 <EvilTerran> , src ''Obj
06:18:20 <Ezla> EvilTterran: nope
06:18:21 <Ezla> <int-e> you don't know just how ridiculous and annoying you are.
06:18:22 <lunabot>  luna: Not in scope: type constructor or class `Obj'
06:18:42 <EvilTerran> Ezla, er, i don't see that in the scrollback
06:18:43 <mmorrow> EvilTerran: i think Obj is GHC.Exts.Any
06:18:46 <Ezla> msg
06:18:48 <Saizan> Ezla: i think trying to port techniques from C++ or D templates to haskell won't be very productive, understanding the fundamentals of Haskell's type system directly is surely easier
06:18:53 <mmorrow> (or is that GHC.Prim.Any ..)
06:18:59 <Ezla> Saizan, it's not "Trying to port techniques"
06:19:01 <Ezla> It's universal.
06:19:05 <Ezla> Writing compile time code.
06:19:26 <Saizan> yeah, but why do you need to write compile time code?
06:19:27 <Ezla> I'm not "stupid' and just a dumbass trying to use C++ templates in haskell
06:19:30 <PeakerWork> Ezla: writing compile-time code is a performance-oriented feature, why would it be universal? Some languages don't even have performance as a goal at all
06:19:34 <Ezla> My assertion is pointed
06:19:36 <EvilTerran> as i said earlier
06:19:44 <EvilTerran> <EvilTerran> "compile time" is an implementation detail
06:19:55 <PeakerWork> indeed
06:20:01 <EvilTerran> what about interpreters?
06:20:03 <Ezla> Peaker: because, it can still be useful where the type system isnt perfect
06:20:04 <PeakerWork> it may be an important one, for performance reasons
06:20:09 <Ezla> I'll give an example
06:20:47 <Ezla> you cannot write individual signatures using different typeclasses for each function definition
06:21:07 <EvilTerran> ... pardon?
06:21:08 <Ezla> > let f x = x + 1 :: (Num a) => a -> a
06:21:09 <lambdabot>   <no location info>: parse error on input `;'
06:21:10 <mmorrow> Ezla: maybe if i'd used C++ templates before i could help translate the concepts, but (not having used them) it just seems to me like you're trying to use runtime-type-info in haskell, which isn't designed into the lang and isn't really that helpful because of this
06:21:26 <Ezla> functions only support a base typeclass
06:21:49 <EvilTerran> a what?
06:21:55 <Ezla> So, you write compile time stuff to get around this kind of thing, where you need to make generations from a type tuples
06:22:20 <Ezla> Mmorrow: There's nothing to translate
06:22:21 <mmorrow> ooh, there's a page on the wiki that maps OO classes/concepts onto haskell typeclasses and vice-versa
06:22:33 <Ezla> That's not what I'm talking about, mmorrow
06:22:33 <EvilTerran> ah, you want typeclasses as first-class types?
06:22:46 <EvilTerran> types parameterised by typeclasses or sometihng?
06:22:47 <Ezla> this is not OO
06:22:51 <mmorrow> Ezla: heh
06:23:29 <Saizan> Ezla: http://okmij.org/ftp/Haskell/types.html <-- this page has a lot of examples of type programming in haskell
06:23:35 <Ezla> It has absolutely nothing to do with OO, it's compile time programming in C++ using template classes to emulate functional programming pure functions which work with tuples of types
06:23:42 <mmorrow> so what is the type of a "type tuple"?
06:23:48 <PeakerWork> Ezla: What do you mean by "<Ezla> functions only support a base typeclass"
06:23:51 <mmorrow> (Type, forall a. a) ?
06:24:15 <Ezla> And what I just said is a workaround
06:24:22 <PeakerWork> Ezla: workaround for what?
06:24:28 <PeakerWork> Ezla: what's the problem?
06:24:31 <EvilTerran> Ezla, that sounds like the sort of thing oleg does (at the link Saizan just gave)
06:24:43 <Ezla> not having a pure FP language at compile time
06:24:53 <LeoD> filter (\i -> i `mod` 3 == 0 || i `mod` 5 == 0) [1..1000-1] -- is there a better way to write this?
06:24:55 <PeakerWork> Ezla: "compile-time" is an implementation detail, as EvilTerran pointed out
06:24:58 <EvilTerran> <EvilTerran> <EvilTerran> "compile time" is an implementation detail
06:25:12 <Ezla> It's not a implementation detail
06:25:21 <Ezla> Compile time is "beyond syntax"
06:25:21 <mmorrow> hmm, i'm still unclear of what problem we;re trying to solve
06:25:24 <EvilTerran> LeoD, [i | i <- [1..1000-1], i `mod` 3 == 0, i `mod` 5 == 0] ?
06:25:25 <PeakerWork> Ezla: implementation details are important when you're trying to optimize performance, but that is less important
06:25:28 <Ezla> I'll give you another example
06:25:34 <LeoD> EvilTerran: ah, right :)
06:25:35 <LeoD> thanks
06:25:42 <Ezla> In D, a pure function which returns a string can be evaluated at compile time
06:25:44 <EvilTerran> Ezla, type-checking as distinct from evaluation is not an implementation detail
06:25:51 <Ezla> and that string is compiled cde
06:25:53 <Ezla> *code
06:26:08 <EvilTerran> Ezla, but compile-time is not a well-defined concept in haskell
06:26:09 <mmorrow> Ezla: ok, that can be done in haskell, but s/String/Exp/
06:26:12 <EvilTerran> the report doesn't talk about it
06:26:23 <Botje> LeoD: filter (\x -> all (\i -> x `mod` i == 0) [3,5]) [1..999]
06:26:26 <Ezla> EvilTerran: Doesn't matter
06:26:30 <Botje> not _that_ much clearer, but ..
06:26:31 <EvilTerran> why not?
06:26:43 <Ezla> Building code out of a string is compile time even if the report doesnt talk about "compile time"
06:26:46 <LeoD> Botje: heh, that one's nice too :P
06:26:54 <LeoD> but i was wondering if you could write it without a lambda
06:26:56 <mmorrow> the type `Exp' represents expressions
06:26:57 <EvilTerran> Ezla, what's an interpreter meant to do then?
06:27:14 <mmorrow> likewise, `Dec' represents declarations, `Type' types, `Stmt' stmts
06:27:15 <mmorrow> ..
06:27:25 <Ezla> EvilTerran: build code from strings.
06:27:31 <EvilTerran> when?
06:27:38 <Ezla> At runtime
06:27:42 <ziman> @pl \p q -> map (\x -> map (*x) q) p
06:27:42 <lambdabot> flip (map . flip (map . (*)))
06:27:44 <mmorrow> oh
06:27:55 <EvilTerran> so why bother with this compile/run-time distinction, if some implementations'll have to break it?
06:27:55 <ziman> @pl \q p -> map (\x -> map (*x) q) p
06:27:56 <lambdabot> map . flip (map . (*))
06:27:56 <Botje> LeoD: then you're probably best off with that list comprehension EvilTerran showed you
06:27:59 <mmorrow> so you're talking about essentially having the compiler linked into your program then
06:28:02 <LeoD> Botje: aye
06:28:12 <Ezla> mmorrow, that's what the interpreter requires
06:28:19 <Ezla> but not with compile time programming
06:28:22 <Ezla> it only happens once
06:28:25 <EvilTerran> LeoD, ah, i got it slightly wrong, the , between the two == clauses should be a ||
06:28:40 <mmorrow> Ezla: ok, then you can do that with template-haskell
06:28:43 <EvilTerran> a , there would act more like &&
06:28:47 <LeoD> right
06:28:55 <Ezla> does template-haskell have type lists?
06:28:58 <mmorrow> , [|\x -> x|]
06:29:01 <lunabot>  LamE [VarP x_0] (VarE x_0)
06:29:03 <mmorrow> , $([|\x -> x|]) 42
06:29:06 <lunabot>  42
06:29:08 <EvilTerran> Ezla, what is a "type list"?
06:29:12 <PeakerWork> Ezla: Template Haskell can guarantee the code runs at compile-time. The only reason for such a guarantee to be useful, is for performance.  Performance is considered a secondary issue in Haskell (until proven problematic by a profile)
06:29:21 <mmorrow> the $(....) turns an Exp into the expression it represents
06:29:21 <Saizan> , ['Int,'Float,'Bool]
06:29:23 <Ezla> EvilTerran; what you'd expect it to be
06:29:24 <lunabot>  luna: Not in scope: data constructor `Int'
06:29:28 <mmorrow> ''
06:29:30 <EvilTerran> > [[t|Int|], [t|Bool|], [t|Char|]]
06:29:32 <Saizan> , [''Int,''Float,''Bool]
06:29:35 <lunabot>  [GHC.Types.Int,GHC.Types.Float,GHC.Bool.Bool]
06:29:36 <lambdabot>   <no location info>: parse error on input `]'
06:29:38 <EvilTerran> , [[t|Int|], [t|Bool|], [t|Char|]]
06:29:40 <Ezla> Peaker: I disagree
06:29:42 <lunabot>  [ConT Int,ConT Bool,ConT Char]
06:29:49 <EvilTerran> is that a "type list"?
06:29:52 <Saizan> Ezla: [''Int,''Float,''Bool] is a typelist
06:29:56 <Ezla> As I said before, at compile time steps out of the syntax bounds
06:29:57 <mmorrow> , $(sigE [|\x -> x|] [t|forall a. a -> a|]) 42
06:30:00 <lunabot>  42
06:30:01 <mmorrow> , $(sigE [|\x -> x|] [t|forall a. a -> Int|]) 42
06:30:08 <lunabot>  luna: Couldn't match expected type `GHC.Types.Int'
06:30:12 <Ezla> because your template haskell stuff would expand into a whole generation of functions
06:30:22 <Ezla> which are *usable* in the rest of your codebase
06:30:27 <Ezla> of non compile time code
06:30:31 <Ezla> it's not just about performance
06:30:38 <Ezla> it's about Ie, library generation
06:30:38 <mmorrow> but the code has to be /valid/ code
06:30:53 <Ezla> Of course
06:31:02 <Ezla> At compile time, you generate valid code
06:31:05 <Ezla> which is used elsewhere.
06:31:05 <PeakerWork> Ezla: If your language is powerful enough, you don't have to generate code
06:31:10 <mmorrow> for instance, doing this is illegal under haskell's type system:
06:31:11 <Saizan> yeah, it's just a macro system them
06:31:12 <mmorrow> , foldr (\x y -> [|($x,$y)|]) [|()|] (fmap lift [0..9::Int])
06:31:12 <PeakerWork> Ezla: for libraries
06:31:14 <Ezla> You generate valid code from templating upon said type list
06:31:15 <lunabot>  TupE [LitE (IntegerL 0),TupE [LitE (IntegerL 1),TupE [LitE (IntegerL 2),T...
06:31:17 <Ezla> and use it elsewhere.
06:31:21 <mmorrow> but is possible with template-haskell
06:31:26 <mmorrow> , ppDoc `fmap` foldr (\x y -> [|($x,$y)|]) [|()|] (fmap lift [0..9::Int])
06:31:28 <EvilTerran> Ezla, why not just "at some time, you generate code, and use it elsewhere"?
06:31:28 <lunabot>  (0, (1, (2, (3, (4, (5, (6, (7, (8, (9, ()))))))))))
06:31:34 <kfish> Ezla, does D have currying?
06:31:41 <EvilTerran> why bother with this compile vs runtime distinction?
06:32:00 <mmorrow> , fst $(foldr (\x y -> [|($x,$y)|]) [|()|] (fmap lift [0..9::Int]))
06:32:03 <lunabot>  0
06:32:06 <Ezla> kfish: not atomically
06:32:10 <mmorrow> , (snd . snd . snd) $(foldr (\x y -> [|($x,$y)|]) [|()|] (fmap lift [0..9::Int]))
06:32:13 <lunabot>  (3,(4,(5,(6,(7,(8,(9,())))))))
06:32:37 <EvilTerran> the TH specification explains things in terms of "stages", which is necessary to keep things coherent
06:32:39 * Saizan wonders what horrible thing c++ templates are then, a hybrid of macros on types from hell?
06:32:55 <Ezla> The templates arent what you think
06:32:58 <Ezla> let me explain
06:32:58 <Saizan> *and types
06:33:09 <mmorrow> and you don't have to keep track of types with template-haskell, because the compiler turns your Exp/Dec/Type into code which then is typechecked/infered and compiled
06:33:13 <Ezla> Templates didn't actually do much of anything except parameterize a class by Type
06:33:25 <Ezla> template <class X> class Vector { ...
06:33:27 <Ezla> now you use
06:33:29 <Ezla> Vector<int>
06:33:34 <PeakerWork> Saizan: templates used to be a macro-expansion system (I don't know what they are considered to be now).  Type-arguments would be implemented by macro-expansion, basically
06:33:37 <EvilTerran> Ezla, er, we have parameterised types
06:33:47 <Ezla> However, templates were perverted into a pure functional language at compile time
06:33:58 <maltem> Saizan: I thougth they're just a funny syntax for basic parametric polymorphsim
06:33:59 <Ezla> like this:
06:34:19 <mauke> maltem: they're neither parametric nor polymorphic :/
06:34:20 <Ezla> template <int N> class Foo { static const int result = N + 1; }
06:34:33 <Saizan> maltem: i think the way that's implemented leads to weird abuses that end up being a macro system
06:35:06 <PeakerWork> Ezla: how is the "compile-time-ness" of Foo<N>::result not an implementation detail?
06:35:22 <Ezla> PeakerWork: because that's impossible at runtime
06:35:22 <PeakerWork> Ezla: what denotational semantics differ if its generated in run-time, instead?
06:35:23 <maltem> mauke: ok but I should be right about the other points? :)
06:35:27 <Ezla> For example
06:35:39 <mmorrow> , $((\ty -> sigE [|\n -> n + 1|] ty) [|Int|])
06:35:41 <lunabot>  luna: Not in scope: data constructor `Int'
06:35:44 <mmorrow> , $((\ty -> sigE [|\n -> n + 1|] ty) [t|Int|])
06:35:46 <lunabot>  luna: The lambda expression `\ n[a79W] -> (n[a79W] GHC.Num.+ 1)'
06:35:49 <maltem> Saizan: I must admit I don't know them good enough yet to discuss them
06:35:50 <mmorrow> heh
06:35:50 <Ezla> void main() { char myarray[Foo<9>]; } // build a static array on the stack of size 10
06:35:57 <mauke> void main is wrong
06:35:58 <Ezla> void main() { char myarray[Foo<9>::result]; }
06:36:01 <mmorrow> , $((\ty -> sigE [|\n -> n + 1|] ty) [t|Int|]) (42 :: Integer)
06:36:03 <Ezla> mauke: Not in D
06:36:04 <lunabot>  luna: The lambda expression `\ n[a79X] -> (n[a79X] GHC.Num.+ 1)'
06:36:06 <mauke> oh, oops
06:36:16 <Ezla> mauke: dont comment on minor quibbles pls
06:36:18 <Ezla> srsly
06:36:29 <Saizan> Ezla: ok, we see
06:36:30 <PeakerWork> Ezla: In a language where you don't have "compile-time-values-here-only-please", how does it differ?
06:36:47 <mauke> (gcc actually allows runtime values in array sizes)
06:37:04 <Ezla> PeakerWork: because you have other things that are compile time only
06:37:27 <mauke> the real test is switch (0) { case Foo<9>::result: ; }
06:37:35 <Ezla> mauke: sure
06:37:43 <Ezla> however the runtime arrays are just using "alloca"
06:37:47 <Ezla> or some heap extension
06:37:55 <EvilTerran> Ezla, well, given that haskell doesn't have a concept of "compile time", we trivially *don't* have things that're compile-time only
06:37:59 <Ezla> I was specific in "static stack array"
06:38:12 <Ezla> EvilTerran: I disagree.
06:38:17 <EvilTerran> Ezla, "on the stack" is an implementation detail
06:38:17 <Ezla> Going back to the previous point:
06:38:19 <PeakerWork> Ezla: I don't think Haskell has any "compile-time-only" values
06:38:27 <Saizan> EvilTerran: instances declaration are compile-time
06:38:28 <mauke> what about patterns?
06:38:32 <Ezla> > let f x = x + 1 :: (Num a) => a -> a
06:38:33 <PeakerWork> Ezla: so there's no meaningful distinction. In C++ its not an implementation detail, but in Haskell, it is
06:38:33 <lambdabot>   <no location info>: parse error on input `;'
06:38:44 <EvilTerran> Saizan, well, they've got to happen before typechecking
06:38:45 <Ezla> Haskell doesn't have typeclasses as first class types
06:38:51 <mmorrow> got it
06:38:53 <mmorrow> , $((\ty -> newName "n" >>= \n -> lamE [varP n] [|$(sigE (varE n) ty) + 1|]) [t|Int|]) (42 :: Int)
06:38:55 <lunabot>  43
06:38:55 <Ezla> Therefore, it's something you might do at compile time
06:38:56 <mmorrow> , $((\ty -> newName "n" >>= \n -> lamE [varP n] [|$(sigE (varE n) ty) + 1|]) [t|Int|]) (42 :: Integer)
06:38:58 <lunabot>  luna: Couldn't match expected type `GHC.Types.Int'
06:38:58 <mauke> you can't have runtime patterns
06:39:02 <Ezla> generate a family of 'f's for each typeclass
06:39:04 <PeakerWork> Ezla: Type-classes are not types at all
06:39:10 <Ezla> Peaker: of course they arent
06:39:11 <mmorrow> that's the same thing as that template you gave earlier
06:39:16 <Ezla> hence generate the family of F's
06:39:17 <EvilTerran> Ezla, er, what would this family do?
06:39:19 <Saizan> Ezla: yeah, that's exactly the thing you'll do with template-haskell
06:39:22 <mmorrow> , $((\ty -> newName "n" >>= \n -> lamE [varP n] [|$(sigE (varE n) ty) + 1|]) [t|Double|]) (42 :: Integer)
06:39:24 <lunabot>  luna: Couldn't match expected type `GHC.Types.Double'
06:39:27 <mmorrow> , $((\ty -> newName "n" >>= \n -> lamE [varP n] [|$(sigE (varE n) ty) + 1|]) [t|Double|]) pi
06:39:30 <lunabot>  4.141592653589793
06:39:34 <PeakerWork> Ezla: what "f"s would I want to generate for each type-class?
06:40:16 <mmorrow> that TH code would look a lot prettier if i didn't have to do it in one line also..
06:40:33 <Ezla> So, its *NOT* an implementation detail, it deals with generation of things which have to map onto the non-impl-detail part of haskell
06:40:52 <Ezla> rather, map onto the impl detail part of haskell
06:41:11 <EvilTerran> Ezla, what exactly is "it" in that sentence?
06:41:12 <Ezla> Does that make sense Peaker?
06:41:29 <Ezla> Evil: It == peakers claim that it doesnt matter cause its impl details
06:41:43 <EvilTerran> er
06:41:59 <Ezla> it == ability to have compile time code
06:42:27 <EvilTerran> ok
06:42:37 <EvilTerran> there are things in haskell that happen, in ghc, at compile-time
06:42:43 <EvilTerran> that doesn't mean they have to happen at compile-time
06:42:52 <EvilTerran> they could happen at other times without affecting the semantics
06:43:09 <EvilTerran> this seems to be the kind of thing your talking about
06:43:16 <Ezla> <PeakerWork> Ezla: I don't think Haskell has any "compile-time-only" values
06:43:20 <EvilTerran> *you're
06:43:34 <Ezla> Not being able to generate a family of f's is a  Compile Time Only value
06:43:52 <PeakerWork> Ezla: huh?
06:43:53 <EvilTerran> "Not being able to generate a family of f's" is a property of reality, not a value
06:43:58 <Ezla> The semantic impossibility is the value
06:44:03 <EvilTerran> fnord!
06:44:04 <PeakerWork> Ezla: ????
06:44:14 <PeakerWork> Ezla: I think you are confused about what a "value" is
06:44:19 <Ezla> No
06:44:20 <Saizan> Ezla: a family of function is not a value
06:44:24 <Saizan> *functions
06:44:26 <mmorrow> you can generate the abstract syntax that represents them at any time, but if you want to turn that into code you either have to (1) do it at compile-time, or (2) link the compiler in to your prog (which is also possible)
06:44:32 <Saizan> it's a bunch of code
06:44:34 <Ezla> It's not a literal phrase
06:44:42 <Ezla> Its a different meaning of value, like:
06:44:46 <Ezla> "for all values of evil"
06:44:46 <Saizan> in fact we talk about code-generation, or meta-programming
06:44:49 <EvilTerran> hail eris!
06:45:01 <mmorrow> yeah, template-haskell is code /generation/
06:45:02 <Saizan> rather than compile-time programming
06:45:31 <Saizan> but afaiu they are pretty much the same thing
06:45:42 <mmorrow> which you happen to be able to do with the same language as that you're generating
06:45:59 <PeakerWork> Ezla: if you want to generate code at compile-time, use TH. In Haskell, things that require code-generation are generally TH.  "Compile-time" values are unnecessary, so generally speaking, compile time computation is just an implementation detail, which might be important, but rarely. It doesn't deserve that much focus in Haskell
06:46:06 <Ezla> I'm trying to understand Mmorrows template haskell code
06:46:21 <mmorrow> Ezla: i'll paste it cleaned up, on sec..
06:46:31 <Ezla> can you do a typelist one please?
06:46:54 <mmorrow> hmm, i'm still not exactly clear on what that'd be, but i'll try to guess
06:47:09 <Ezla> simple example
06:47:15 <Ezla> and I know you'd use a Typeclass for it, however
06:47:37 <Ezla> actually, heres a better one
06:48:50 <kfish> Ezla, is the purpose of all this that you want to generate, at compile time, lots of different functions with customized behaviors for the different parts of the problem you're solving?
06:50:06 <Ezla> given a tuple of (Int, Bool, String, Bool, Char, Bool)
06:50:14 <Ezla> it generates a function signature
06:50:39 <Ezla> sorry
06:50:47 <Ezla> given a tuple of (Int, String, Char)
06:51:09 <Ezla> f a b c d e :: Int -> Bool -> String -> Bool -> Char -> Bool
06:51:36 <Ezla> so the definition of Type Tuple there, is only whatever is required to store (Int, String, Char)
06:51:45 <Ezla> in a highly usable manner
06:52:04 <Ezla> such that it can be indexed without the end user having to implement on the spot recursion
06:52:46 <Saizan> , filter (== ''Char) [''String,''Bool,''Int,''Char,''Char]
06:52:49 <lunabot>  [GHC.Types.Char,GHC.Types.Char]
06:53:08 <Saizan> (silly example)
06:54:15 <Saizan> then you can e.g. use a list like that to generate a datatype which has one field of each type
06:54:20 <PeakerWork> Ezla: what are you still asking? You got your answer, its TH
06:54:25 <Saizan> or a function that takes a parameter, etc..
06:54:40 <Saizan> s/a parameter/a parameter for each type/
06:55:37 <mmorrow> Ezla: http://hpaste.org/12806
06:55:39 <Saizan> it's like lisp macros, but also deals with the typesystem
06:56:14 <mmorrow> ah, ok so wrt those typelists:
06:58:13 <mmorrow> , ppDoc `fmap` (\(t:ts) -> foldl (appT . appT arrowT) t ts) [[t|Int|], [t|Double|], [t|(String,Maybe ())|]]
06:58:16 <lunabot>  (Int -> Double) -> (String, Maybe ())
06:58:22 <mmorrow> , ppDoc `fmap` (\(t:ts) -> foldl (appT . appT arrowT) t ts) [[t|[Int]|], [t|()|], [t|(String,Maybe ())|]]
06:58:25 <lunabot>  (([Int]) -> ()) -> (String, Maybe ())
06:58:30 <mmorrow> , ppDoc `fmap` (\(t:ts) -> foldl (appT . appT arrowT) t ts) [[t|[Int]|], [t|()|], [t|Bool|]]
06:58:33 <lunabot>  (([Int]) -> ()) -> Bool
06:58:41 <mmorrow> you can construct /any/ syntax with TH
06:58:49 <Ezla> what's
06:58:57 <mmorrow> oops, i should done a foldr
06:59:01 <Ezla> [t|()|] ?
06:59:03 <Ezla> wait
06:59:07 <Ezla> not a big example
06:59:10 <Ezla> how do you just do
06:59:14 <Ezla>  (Int, Bool, String, Bool, Char, Bool)
06:59:17 <mmorrow> so, [|.....an expression in here ... |]
06:59:17 <Ezla> nothing else
06:59:23 <mmorrow> [t|.... a type ... |]
06:59:32 <mmorrow> [d| ... a declaration ... |]
06:59:39 <mmorrow> , [d| data A = A |]
06:59:42 <lunabot>  DataD [] A [] [NormalC A []] []
06:59:52 <mmorrow> , [d| class Foo a where foo :: a -> (a, String) |]
06:59:55 <lunabot>  ClassD [] Foo [a_0] [] [SigD foo (AppT (AppT ArrowT (VarT a_0)) (AppT (Ap...
06:59:57 <Ezla> [t|Int|Bool|String|Char]  <-- valid?
07:00:13 <Ezla> with an extra |
07:00:17 <mmorrow> so you mean that to be "..or..or..."?
07:00:27 <Saizan> Ezla:  [''String,''Bool,''Int,''Char,''Char]
07:00:28 <Ezla> hrm, No ;)
07:00:35 <paulvisschers_> Is there a compiler flag to compile something other that the main function?
07:00:42 <Saizan> am i on ignore?
07:00:46 <Ezla> Saizan: what's '' ?
07:00:59 <mmorrow> oh yeah, so to get the name of something
07:01:04 <mmorrow> , src ''Name
07:01:09 <lunabot>  data Name = Name OccName NameFlavour
07:01:15 <mmorrow> '<a non-type's name here>
07:01:20 <mmorrow> ''<a type's name here>
07:01:24 <mmorrow> , 'map
07:01:25 <Ezla> mmorrow: why were you using | if | is or?
07:01:25 <Saizan> Ezla: it's how you tell the macro system that you want to quote that, so you can use in code-generation as a value
07:01:27 <lunabot>  GHC.Base.map
07:01:36 <Ezla> Saizan: ah
07:01:46 <mmorrow> Ezla: because i wasn't sure what [t|Int|Bool|String|Char] was supposed to mean
07:01:58 <Saizan> Ezla: it's shorthand syntax for [t|Bool|]
07:02:00 <mmorrow> , [t|Int|]
07:02:03 <lunabot>  ConT Int
07:02:11 <mmorrow> well, you need to add the conT
07:02:12 <Ezla> Ok, so how does:
07:02:14 <mmorrow> , ''Int
07:02:16 <lunabot>  GHC.Types.Int
07:02:18 <mmorrow> , conT ''Int
07:02:21 <lunabot>  ConT Int
07:02:32 <mmorrow> conT ''Int ==== [t|Int|]
07:02:47 <Saizan> ah, i was wrong then, but not by far..
07:02:58 <Ezla> compiletimevar = [''String,''Bool,''Int,''Char,''Char]   ->   compiletimevar = [t|String|],WhatWhat?
07:03:12 <mmorrow> lunabot has an instance of Show for TypeQ, ExpQ, etc, so ghci would complain about "No instance of Show for (Q Type)" ..
07:03:18 <Ezla> How do you make a sequence with the [t|Foo|] syntax?
07:03:30 <mmorrow> runQ [t|Int|] -- this'd show you it in ghci
07:03:39 <Saizan> ''Foo gives you the name, [t|Foo|] gives you the representation of the type
07:04:01 <mmorrow> , [ [t|Int|]  , [t|Bool|]  ]
07:04:04 <lunabot>  [ConT Int,ConT Bool]
07:04:10 <Ezla> mmorrow: THAT
07:04:11 <Ezla> yes
07:04:15 <Ezla>  finally ;)
07:04:15 <mmorrow> yeah
07:04:17 <mmorrow> heh
07:04:24 <mmorrow> ohh, i see what you meant now
07:04:33 <mmorrow> yeah, just the regular list syntax
07:04:44 <mmorrow> because, after all, you're still using haskell
07:04:54 <Ezla> so it really is haskell at compile time?
07:05:02 <Saizan> yes
07:05:03 <Ezla> Saizan: is the '' really a string?
07:05:22 <Ezla> what is it really
07:05:26 <Ezla> ''Foo
07:05:28 <Saizan> ''Foo gives you a Name, which internally a String, yes
07:05:32 <mmorrow> you're using haskell to construct representations of haskell code which ghc then compiles with your regular code
07:05:39 <Saizan> s/a/is a/
07:05:42 <Ezla> so ''Foo stuff cant cooperate in "type safety"?
07:05:51 <Ezla> template haskell is "lifted" above the type system
07:06:02 <Ezla> for example, you could not detect if ''Foo was in a given typeclass?
07:06:16 <Ezla> ?
07:06:17 <mmorrow> Ezla: well, the /representations/ of two different typed expressions are bot of type Exp
07:06:23 <mmorrow> *both
07:06:25 <Ezla> what's Exp ?
07:06:31 <mmorrow> in ghci, do:
07:06:36 <Saizan> it's the type of expressions
07:06:38 <mmorrow> :i Language.Haskell.TH.Exp
07:06:51 <mmorrow> it's the abstract representation of expressions
07:07:06 <Saizan> Ezla: from template-haskell you can query the typecheker for various infos
07:07:11 <mmorrow> [| ... |] contructs that for you
07:07:16 <Ezla> <Saizan> Ezla: ok, that's something that you can't do in haskell
07:07:17 <Saizan> i don't recall if you can ask for the members of a class
07:07:19 <Ezla> take that back? :)
07:07:33 <mmorrow> but TH also lets you splice other expressions into a [| .... $(... here ... ) ... |]
07:07:39 <mmorrow> which makes it powerful
07:07:49 <Saizan> Ezla: i wasn't thinking you meant code-generation
07:07:50 <Ezla> Saizan what were you saying you actually can't do?
07:07:56 <Ezla> oh
07:08:12 <Saizan> Ezla: but rather using functions in the _types_
07:08:21 <Ezla> functions in the types?
07:08:27 <Saizan> Ezla: since there are more expressive type systems that let you do that.
07:08:32 <mmorrow> Ezla: yeah, unfortunately that info isn't provided by ghc (because it depends on what modules happen to be imported (but it's not impossible, it's just chosen not to be done :())
07:08:47 <Ezla> mmorrow: example in code?
07:08:57 <Ezla> I guess I gotta see a failed attempt
07:09:00 <Ezla> to parse it
07:09:06 <mmorrow> err, i was responding to "if you can ask for the members of a class"
07:09:24 <mmorrow> so you can "reify" names and get all their info
07:09:32 <Ezla> ah
07:09:38 <Ezla> s/can/cant/ ?
07:09:39 <mmorrow> , ppDoc $(lift =<< reify ''IO)
07:09:41 <lunabot>  newtype IO a_0 = IO ((State# RealWorld) ->
07:09:41 <lunabot>                       (#,#) (State# RealWorld) a_0)
07:09:46 <mmorrow> , $(lift =<< reify ''IO)
07:09:49 <lunabot>  TyConI (NewtypeD [] GHC.IOBase.IO [a_1627415602] (NormalC GHC.IOBase.IO [...
07:09:58 <Ezla> does all their info include "corresponds to said typeclass" ?
07:10:11 <mmorrow> yes, if the Name reps a typeclass you get that info too
07:10:14 <mmorrow> , $(lift =<< reify ''Monad)
07:10:16 <lunabot>  ClassI (ClassD [] GHC.Base.Monad [m_1627417292] [] [SigD GHC.Base.>>= (Fo...
07:10:19 <mmorrow> , ppDoc $(lift =<< reify ''Monad)
07:10:22 <lunabot>  class Monad m_0
07:10:22 <lunabot>      where >>= :: forall m_0 . Monad m_0 => forall a_1 b_2 . (m_0 a_1) ->
07:10:22 <lunabot>                                                              (a_1 -> m_0 b...
07:10:37 <mmorrow> but as of now, you /don't/ get info on the instances of that class
07:10:39 <mauke> missing ( )! :-)
07:10:42 <Ezla> mmorrow: Now I'm confused -- you said you cant do it because the type could cross module bouonds... but you say you can if you reify?
07:10:47 <Ezla> what's the distinction here
07:10:50 <mmorrow> mauke: the prettyprinter is borked :)
07:11:17 <Saizan> mmorrow: so you can get all the types that instance a typeclass if you reify the typeclass?
07:11:21 <mmorrow> Ezla: err, forget what i said about that, it wasn't really relevant to anything :)
07:11:37 <Ezla> forget about not being able?
07:11:41 <mmorrow> Saizan: that's the thing ghc /doesn't/ currently support
07:11:47 <Saizan> ok.
07:11:50 <Ezla> Oh
07:11:57 <Ezla> only "the top down" -- get ALL of them
07:11:59 <Ezla> not check
07:12:00 <mmorrow> Ezla: heh. no, forget about the cross-module thing, it wasn't re.lated.
07:12:01 <Ezla> ?
07:12:06 <SamB_XP> Saizan: you wouldn't be able to do that anyway ... since some of the instances might be in modules not imported!
07:12:30 <mmorrow> SamB_XP: yeah, the best you could get is all instances /currently in scope/
07:12:44 <Saizan> yeah, i was talking about the ones in scope
07:13:28 <Ezla> GHC should be able to generate "half compiled" files
07:13:30 <mmorrow> Saizan: i was reading something in a ticket i believe talking about whether TH should/could support that, and it /could/ but just isn't (currently)
07:13:37 <Ezla> ones which are in a heisenberg state
07:13:50 <SamB_XP> you mean schrodinger?
07:14:02 <Ezla> heh
07:14:04 <mmorrow> both of them at once
07:14:09 <Ezla> yea
07:14:21 <SamB_XP> or perhaps you mean mobius-hofstaedter?
07:15:16 <Ezla> saizan & mmorrow, do you think template haskell is really complete / powerful / doesnt run into any fundamental limitations?
07:15:25 <Ezla> can it truly modify the ast in any imaginable way?
07:15:54 <Ezla> what cant it do
07:16:17 <Saizan> well, template haskell is developed in a demand-driven way
07:16:19 <mmorrow> Ezla: it's still a work in progress, as in i doubt anyone thinks it's "complete", but it's not finalized by any means either.
07:16:33 <mmorrow> one thing it can't do yet is imports or whole modules for that matter
07:16:46 <Ezla> C++ templates were an outrage because of the language evolution philosophy
07:16:51 <mmorrow> and it needs to be updated to handle some newer lang extensions
07:17:03 <Ezla> and I don't understand yet how haskell manages to support the evolving manner of GHC extensions, but
07:17:15 <mmorrow> but, yeah haskell and ghc move fast
07:17:16 <Ezla> c++ templates were finalized back in 1998
07:17:18 <Ezla> and never changed
07:17:26 <Ezla> And they hardly did anything and you were screwed.
07:17:31 <mmorrow> ghc's haskell changes weekly :)
07:17:56 <mmorrow> (well, maybe that's a stretch, but not by much ;)
07:18:03 <Ezla> Anything which is literally incompatible with haskell98 in base GHC's use of the lang?
07:18:27 <mmorrow> not so much "incompatible" as haskell98 just doesn't have that
07:18:36 <Ezla> so it's additive, not subtractive
07:18:40 <Saizan> yeah
07:18:40 <mmorrow> yes
07:18:50 <Ezla> would you consider
07:18:56 <Ezla> > [10..0]
07:18:58 <lambdabot>   []
07:19:05 <Ezla> to be subtractive :P
07:19:08 <mmorrow> > [10,9..0]
07:19:09 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0]
07:19:10 <Ezla> if that was fixed
07:19:12 <mmorrow> heh
07:19:22 <PeakerWork> Ezla: "fixed" assumes there's something broken
07:19:25 <qwr> Prelude Data.Function> fix id
07:19:25 <qwr> *** Exception: stack overflow
07:19:35 <Ezla> PeakerWork: feels broken to me
07:19:37 <qwr> why stack overflow?
07:19:37 <opqdonut> "fixing that" would break a lot of h98 code
07:19:46 <mauke> qwr: infinite recursion
07:20:04 <Lemmih> qwr: 'fix id' is 'id (id (id ...'.
07:20:05 <qwr> mauke: shouldn't this be tail-recursive recursion?
07:20:11 <opqdonut> no
07:20:18 <opqdonut> fix (id.) might be
07:20:28 <mmorrow> Ezla: so yeah, if a change would break code, it'll at least have a flag to turn it on and not be on by default
07:20:30 <qwr> hm.
07:20:35 <PeakerWork> Ezla: not to me
07:20:48 <qwr> fix (\a -> a) won't get the overflow though
07:20:59 <Saizan> well, each extension to h98 has its own flag to enable it
07:21:02 <Ezla> Peaker: Yesterday I was asking for the usefulness of negative ranges not being able to assume  'pred'
07:21:13 <Ezla> what is the use case?
07:21:43 <mauke> what is the use case of reverse ranges by default?
07:21:50 <PeakerWork> Ezla: [firstIndex..lastIndex]
07:21:50 <opqdonut> qwr: hmm, interesting
07:21:51 <mauke> it just looks cute
07:22:10 <Ezla> Peaker: Why do you want that to fail for flipped idx range?
07:22:17 <PeakerWork> Ezla: virtually always, IME, if lastIndex is smaller, you want it to do nothing
07:22:17 <Lemmih> qwr: Try compiling 'fix id' with -O2.
07:22:36 <Ezla> IME == ?
07:22:42 <PeakerWork> Ezla: In My Experience
07:22:58 <PeakerWork> Ezla: if you do want to support flipping, then its easy, however if it "auto-flips", how can you get the current behavior?
07:23:35 <Ezla> good point, but, conversely:
07:23:51 <qwr> Lemmih: <<loop>> ;)
07:23:59 <Ezla> [SomeLong x y z Thing Here :: Foo .. 0]
07:24:09 <Ezla> How do you get the 'pred' behaviour there
07:24:47 <Ezla> s/Some/some/ ;)
07:25:14 <PeakerWork> Ezla: let s = SomeLong x y z Thing Here :: Foo in [s, pred s..0]
07:25:24 <Ezla> And I think you absolutely can get that behaviour with my example
07:25:49 <Ezla> [if x > y then [] else x .. y]
07:25:53 <Ezla> errr
07:25:59 <Ezla> then . or something
07:26:45 <mauke> Ezla: too complicated
07:27:14 <adekoba> hi, is it possible to have multople logHook's?
07:27:27 <mauke> yes, combine them with >>
07:27:44 <Ezla> > [if True then 111 else 222]
07:27:45 <lambdabot>   [111]
07:27:51 <Ezla> why too complicated ?
07:28:03 <mauke> Ezla: because [0 .. x] is simpler
07:28:22 <mornfall> What's the way to go if I want to peek/poke things from/to C structures? hsc2hs?
07:28:45 <mauke> mornfall: that's how I do it
07:29:04 <adekoba> mauke: thanks, worked
07:29:18 <Ezla> Alright, onward.
07:29:27 <Saizan> so hsc2hs writes you a corresponding haskell type and a Storable instance?
07:29:38 <mauke> Saizan: no, it's much more basic
07:31:02 <mauke> Saizan: it gives you access to C constants, sizeof, alignment, and struct member accessors
07:31:48 <Saizan> mauke: ah, i see, #peek essentially sets the right offset before calling peek
07:32:37 <Ezla> I want:  f x = True :: (Num a) => a -> Bool  ;  f x = False :: (Enum a) => a -> Bool
07:32:39 <Ezla> how?
07:32:55 <mauke> Ezla: impossible
07:33:00 <mauke> True is not a function
07:33:03 <Ezla> But why?
07:33:13 <mauke> True :: Bool, not :: (Num a) => a -> Bool
07:33:16 <opqdonut> and f has to have a single type
07:33:25 <Ezla> Why does f have to have a single type
07:33:27 <mmorrow> mauke: i think he meant (\x -> ....) :: a -> Bool
07:33:30 <opqdonut> can't be Enum a => in some cases and Num a => in others
07:33:36 <Ezla> I want polymorphic typeclass cooperation
07:33:48 <Ezla> Multi-signatures
07:33:50 <mmorrow> why don't you just make it of type :: a -> Bool
07:33:51 <opqdonut> how could the compiler verify those typings?
07:33:55 <mmorrow> then you can passit anything
07:34:01 <mmorrow> oh
07:34:04 <Ezla> mmorrow: No
07:34:18 <Ezla> you could only pass it what fits in its typeclass set
07:34:18 <mmorrow> you want to be able to determine /if/ it's a Num or Enum
07:34:26 <Ezla> yes
07:34:28 <opqdonut> Ezla: you could make something like that with type families, I guess
07:34:46 <opqdonut> or then just make a custom typeclass F with only that member
07:34:49 <mmorrow> Ezla: that should be statically figure-out-able for sure
07:34:52 <opqdonut> and add instances for Num and Enum
07:34:57 <Ezla> however that was a basical example
07:34:59 <opqdonut> but that'd be undecideable
07:35:01 <Ezla> what I really care about
07:35:07 <opqdonut> as most things are both Num and Enum
07:35:12 <Ezla> is having multiple typeclass overloads on signatures
07:35:22 <opqdonut> i'm not following you.
07:35:42 <mmorrow> Ezla: remember that types are *erased* once compile-time is over
07:35:43 <Ezla> the Num Enum thing did it
07:35:45 <opqdonut> if you want to dispatch on type, (or type-class), use type classes or some extension of them
07:35:52 <Ezla> mmorrow: thats OK
07:35:55 <Ezla> it can be static
07:35:59 <Ezla> why would this need to be runtime?
07:36:08 <mmorrow> Ezla: yeah totally, i think you can do it statically
07:36:11 <Ezla> f 1
07:36:13 <Ezla> f MyEnum
07:36:18 <Ezla> type is known at compile time
07:36:26 <mmorrow> in which case i'm sure some hackery exists to get it done :)
07:36:29 <Ezla> mmorrow: how?
07:36:40 <Saizan> Ezla: you can do it if f is not a function but a macro
07:36:41 <mmorrow> off the top of my head, i'm not sure
07:36:47 <Ezla> MACRO NO NO
07:36:48 <PeakerWork> Ezla: I think you're misunderstanding what a type-class is supposed to represent and how it is supposed to be used
07:36:51 <Ezla> hear no
07:36:51 <opqdonut> yes
07:36:52 <Ezla> speak no
07:36:53 <Ezla> evil
07:37:02 <Saizan> Ezla: not a macro in the CPP sense
07:37:03 <opqdonut> this is not very haskellish design
07:37:09 <Saizan> Ezla: but in the TH sense as before
07:37:11 <haskell_newbie> Hello, does anyone know  how to check that some substring appears inside a string, for example how to check if "one" appears 3 times in the begining of the string "oneoneoneblablabla"?
07:37:15 <PeakerWork> Ezla: if you have a bunch of type-classes that you want to be able to use -- then they should all be subclassing something, and you should use just that one instead
07:37:18 <Ezla> Before I ask this question
07:37:23 <mmorrow> @type isInfixOf
07:37:25 <Ezla> Theres one thing that matters
07:37:25 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
07:37:32 <Ezla> can you make a Typeclass typeclass?
07:37:36 <Ezla> a Class of typeclasses?
07:37:36 <PeakerWork> Ezla: why would you want to have a function-per-typeclass?
07:37:41 <mmorrow> > "rty" isInfixOf "qwertyuiop"
07:37:42 <lambdabot>   Couldn't match expected type `t1 -> t2 -> t'
07:37:42 <PeakerWork> Ezla: you make a base class
07:37:42 <Saizan> Ezla: no
07:37:44 <Ezla> Peaker: Not per typeclass
07:37:48 <mmorrow> > "rty" `isInfixOf` "qwertyuiop"
07:37:49 <Ezla> Saizan: why not?
07:37:50 <lambdabot>   True
07:37:51 <opqdonut> no higher level classes
07:37:57 <mmorrow> that was an ironic error
07:37:58 <opqdonut> because the type system doesn't support them
07:38:04 <Ezla> why not?
07:38:12 <mmorrow> forgot the `` in   "rty" isInfixOf "qwertyuiop"
07:38:14 <opqdonut> because there's no theory for such things
07:38:17 <opqdonut> (that I know of)
07:38:17 <Ezla> The reason I ask why not, is cause I expect you to say
07:38:25 <Ezla> "we dont need it cause we can do the exact same thing via:"
07:38:28 <mmorrow> haskell_newbie: try isInfixOf
07:38:32 <PeakerWork> Ezla: why do you need a class of type-classes? It doesn't sound useful to me
07:38:40 <opqdonut> you have to see that haskell's type system is just a bunch of random useful things thrown together
07:38:45 <PeakerWork> Ezla: it sounds like you're looking for a base class, instead
07:38:46 <Ezla> PeakerWork: To satisfy my previous Question
07:38:49 <opqdonut> it is a whole, with theoretical background
07:38:54 <Ezla> without rewriting a bunch of instances
07:38:56 <Ezla> Example
07:39:00 <opqdonut> that's exactly why type inference and all the cool stuff works
07:39:00 <Ezla> typeclass NumOrEnum
07:39:09 <Ezla> without having to Duplicate any code
07:39:19 <Ezla> from the defs of Num and Enum
07:39:26 <opqdonut> what would that class contain?
07:39:40 <Ezla> The joint of Num and Enum
07:39:42 <opqdonut> what code do you wish to avoid duplicating=
07:39:43 <opqdonut> ?
07:39:57 <PeakerWork> Ezla: The Joint of Num and Enum is supposed to be a base-class of Num and Enum
07:39:58 <Ezla> Avoid rewriting the implementation of Num and Enum in typeclass NumOrEnum
07:40:03 <opqdonut> "joint" in what sense? have both compare and (+) there?
07:40:17 <opqdonut> are you sure you don't mean NumAndEnum
07:40:18 <Ezla> OR
07:40:30 <opqdonut> what are the semantics?
07:40:31 <haskell_newbie> mmorrow: thanks I'm gonna try using that
07:40:32 <PeakerWork> @info Num
07:40:32 <lambdabot> Num
07:40:35 <opqdonut> what types would belong to that?
07:40:35 <PeakerWork> @src Num
07:40:36 <lambdabot> class  (Eq a, Show a) => Num a  where
07:40:36 <lambdabot>     (+), (-), (*)           :: a -> a -> a
07:40:36 <lambdabot>     negate, abs, signum     :: a -> a
07:40:36 <lambdabot>     fromInteger             :: Integer -> a
07:40:41 <opqdonut> Num and Enum don't share stuff
07:40:47 <opqdonut> so you can't take their intersection really
07:40:56 <PeakerWork> opqdonut: pred/succ vs (subtract 1) and (+1)
07:41:07 <opqdonut> well okay, those
07:41:22 <mmorrow> but those don't necessarily intersect
07:41:25 <PeakerWork> you could have a base-class with just those operations and have Num and Enum both subclass those
07:41:26 <mmorrow> > False + True
07:41:27 <lambdabot>       No instance for (Num Bool)
07:41:27 <lambdabot>        arising from a use of `+' at <interac...
07:41:31 <mmorrow> > pred False
07:41:33 <lambdabot>   * Exception: Prelude.Enum.Bool.pred: bad argument
07:41:34 <Ezla> f :: (NumOrEnum a) => a;    f x = True :: (Num a) =:> a -> Bool  ;  f x = False :: (Enum a) =:> a -> Bool
07:41:37 <mmorrow> > pred True
07:41:38 <lambdabot>   False
07:41:47 <opqdonut> Ezla: what would you do with that f?
07:41:50 <opqdonut> why would you need it?
07:41:58 <mauke> Ezla: you're still using :: wrong
07:42:00 <Saizan> Ezla: can you give a non-trivial problem that such a class would solve?
07:42:05 <int-e> Ezla: besides, what would you do with all the types that are both Num and Enum?
07:42:08 <Ezla> mauke: Its invented syntax duh
07:42:09 <int-e> instances.
07:42:13 <Ezla> course its wrong
07:42:15 <Saizan> Ezla: or a similar class of class
07:42:16 <mauke> Ezla: no, :: already exists
07:42:29 <opqdonut> Ezla should spend a few months coding haskell and then come back
07:42:30 <opqdonut> IMO
07:42:36 <Ezla> No.
07:42:49 <opqdonut> well then i'm just going to ignore you
07:42:51 <opqdonut> cya!
07:42:53 <Ezla> i learn via finding flaws.
07:42:53 <mmorrow> Ezla: he means, ==>    f = (\x -> False) :: (Enum a) => a -> Bool
07:43:12 <mmorrow> because    f x = False :: Bool
07:43:26 <ziman> may i quote this? :)
07:43:29 <int-e> @instances Int
07:43:30 <lambdabot> Couldn't find class `Int'. Try @instances-importing
07:43:31 <Saizan> Ezla: that's an extremely annoying way to learn for everyone else in the room, though
07:43:37 <Ezla> opqdonut, if you have to put a newbie on ignore because they ask questions about how the Haskell type systems works, you've got a very restricted and uncurious mind
07:44:29 <Ezla> Saizan: Doesn't matter
07:44:32 <Saizan> asking what something is, rather than what something isn't, usually it's more productive for both parts
07:44:43 <int-e> Ezla: trust me on this one, it's not because you're a newbie.
07:44:55 <Ezla> Saizan: Doesn't matter what direction you come from
07:45:00 <Ezla> You build the language in your mind
07:45:02 <Ezla> additively
07:45:09 <Ezla> Language does nothing, lets find out what it does
07:45:12 <Ezla> subtractively
07:45:18 <PeakerWork> Ezla: if you do that, concepts like "compile-time programming" would never spring up in your mind
07:45:19 <Ezla> Language does everything, lets find out what it cannot do
07:45:24 <Ezla> in Haskell's case, I assume it does everything
07:45:28 <Ezla> Because I have faith
07:45:34 <Ezla> And I ask you to disprove possibilities
07:45:45 <Ezla> Or provide a justification for alternative thinkings for impossibilities
07:46:05 <PeakerWork> Ezla: learning additively is better, as "everything" is quite meaningless
07:46:10 <Ezla> I disagree
07:46:19 <Saizan> Ezla: just reading a book/tutorial that gives you an overview of what haskell is about would at least avoid confusion like earlier
07:46:27 <mauke> Ezla: yeah, but you're wrong, so it doesn't matter
07:46:42 <mauke> in general, I assume you're wrong and wait for you to prove otherwise
07:46:43 <Ezla> There's nothing to be "wrong" about, its personal style
07:46:47 <PeakerWork> Ezla: does Haskell have "ON ERROR" from BASIC? Nope.. Why not? Let's explain why each feature X of language Y does not exist in its exact form in Haskell?
07:46:48 <Ezla> my style is everything's possible
07:47:03 <mauke> your style is wrong, though
07:47:05 <Ezla> PeakerWork: That's not an analogue
07:47:13 <Ezla> This is fine points of the type system
07:47:34 <Ezla> Some practicality is required
07:47:43 <Philippa> guys, that's not everything as in a formal universal quantification
07:47:52 <PeakerWork> Ezla: It seems to me like you're enumerating every feature you know from some languages and asking for the Haskell equivalent
07:48:04 <PeakerWork> conal: hey
07:48:05 <Ezla> Do any languages do what I asked?
07:48:07 <Ezla> No.
07:48:10 <EvilTerran> any sane programming language would be defined additively
07:48:15 <Ezla> You assume wrongly, Peaker.
07:48:28 <EvilTerran> Ezla, he didn't assume anything
07:48:30 <Ezla> most languages don't even have Concepts
07:48:36 <EvilTerran> "even" lol
07:48:48 <PeakerWork> Concepts as in "Class Context Restrictions", right?
07:49:06 <Ezla> Concepts as in a subtractive type system
07:49:10 <Philippa> PeakerWork: it seriously doesn't strike me that way. It's close, but more subtle
07:49:54 <Philippa> EvilTerran: that doesn't necessarily make it the fastest way to understand a language well enough for one's own purposes though
07:50:26 <PeakerWork> Philippa: a language that is so different, definitely
07:50:53 <Saizan> the problem with assuming it can do everything and asking why it can't do X, it's that if there hasn't been research on X we don't have much of a clue on how it could be implemented
07:51:09 <Saizan> and defining X in a rather informal way over irc doesn't help
07:51:10 <Ezla> Saizan: That's placing to little faith in the future
07:51:24 <Ezla> We're not absolutely evolved
07:51:44 <Ezla> It also lacks self confidence about the possibility of invention
07:51:49 <Saizan> i'm just saying that evolution can't happen in the limited scope of an irc conversation :)
07:52:00 <Ezla> maybe it's baby steps
07:52:09 <Ezla> doesn't matter
07:52:16 <Ezla> anyways!
07:52:42 <Ezla> onto the original point
07:53:25 <Saizan> about classes of classes i can say that a) there hasn't been any noticeable pressure on needing them
07:53:32 <Ezla> Haskell provides the possibility to write multiple function signatures, so why should it not support multiple typeclass matchings over the same pattern applied to different function instances?
07:54:00 <mauke> haskell does not provide multiple function signatures
07:54:02 <Philippa> multiple function signatures don't lead to multiple types
07:54:11 <Ezla> mauke: typo
07:54:15 <Ezla> I mean multiple function defs
07:54:24 <Philippa> they're not multiple function definitions though
07:54:25 <Ezla> Needing multiple sigs is what I'm asking for
07:54:35 <mauke> it's a single definition in multiple cases
07:54:42 <conal> PeakerWork: hi
07:54:46 <Philippa> it desugars to a case statement
07:54:57 <Ezla> So essentially I'm asking for "overloading the meaning of f"  ?
07:55:00 <Ezla> UNLESS
07:55:05 <Ezla> you have Typeclass superclasses
07:55:06 <PeakerWork> Ezla: Because that implies that there are at least 2 type-classes that are providing semantically equivalent features, and if that is the case, then there should be a 3rd more fundumental type-class that they both extend, and that can be used instead.
07:55:09 <Ezla> whereby it does not overload the meaning
07:55:13 <Ezla> hence the example:
07:55:38 <Ezla> f :: (NumOrEnum a) ===> a;    f x = True :: (Num a) => a -> Bool  ;  f x = False :: (Enum a) => a -> Bool
07:55:39 <PeakerWork> Ezla: your  doesHaveNumInstance  function is not useful with the current meaning of type-classes
07:55:45 <Ezla> where ===> is for a typeclass superclass
07:55:47 <int-e> "how to make ad-hoc polymorphism less ad hoc", http://homepages.inf.ed.ac.uk/wadler/topics/type-classes.html is the relevant paper, isn't it?
07:55:51 <Ezla> hence it's specialization all the way down
07:56:28 <PeakerWork> Ezla: if you used type-classes in real programs, I think you might appreciate why that function makes little sense
07:56:31 <ksf> How to shoot yourself into the foot using Haskell: You load the gun, pull the trigger and nothing happens. As soon as you look at your foot, you hear the gun firing, try to rescue your foot by moving it away and, full of awe, watch the bullet homing towards your foot no matter what.
07:56:36 <Philippa> Ezla: you can fake it, but it's fugly and a consequence of something that initially surprised people
07:56:50 <Ezla> Philippa: How to fake it?
07:56:56 <Philippa> and as people are saying, you're at the point where you should sit down and write some code
07:57:13 <Philippa> the typeclass system amounts to a type-level logic language. You turn on the relevant flags and write the logic program
07:57:27 <EvilTerran> you should be familiar with something before you start asserting that you're right about it and other people aren't
07:57:30 <Philippa> however, it won't buy you what you're trying to do, which looks a lot more like something you'd do with GADTs
07:58:16 <Ezla> EvilTerran: Saying "Why doesn't language do X, can you prove the unjustification" and when people need a little extra Nudging to Unprove it, doing so, does not mean  "before you start asserting you're right"
07:58:23 <Ezla> It means
07:58:32 <Ezla> trying to find out what's right
07:58:53 <Philippa> yeah, but the short answer is "because it's an utter conceptual mismatch"
07:59:00 <PeakerWork> Ezla: Type-classes are not designed to do what you want them to do
07:59:15 <Ezla> So why's it a conceptual mismatch?
07:59:17 <Saizan> data NumOrEnum a where ANum :: Num a => a -> NumOrEnum a; AnEnum :: Enum a => a -> NumOrEnum a; f (ANum _) = True; f (AnEnum _) = False
07:59:18 <Philippa> typeclasses are /not/ classes ala OO. They're vaguely analogous to Java's interfaces and that's /it/
07:59:29 <PeakerWork> Ezla: There are different features that can do what you want, probably (Though your examples are too un-realworldly to know)
07:59:32 <Ezla> OO doesn't do any of this
07:59:34 <Ezla> in the first place
07:59:41 <int-e> @quote OO
07:59:42 <lambdabot> slava says: haskell.org really needs a hit counter and a guest book ... maybe a marquee too
07:59:42 <Ezla> C++ stole Concepts from Haskell only... just now
07:59:51 <baaba> it did?
07:59:58 <haskell_newbie> mmorrow:  thanx for helping, but what I'm trying to do is a bit tricky. I want to see if "ola" is in another string, but I only have the string with "ola" repeated 3 times, like this->"olaolaola". So I have to take out one of the repeated "ola"'s first.
08:00:12 <baaba> the original stl from 94 already used concept specifications, even if they weren't in the actual language
08:00:23 <Philippa> eh, there are OO encodings of what you're talking about given a sufficiently smart type system. C++'s isn't it
08:00:44 <Ezla> baaba: As quoted by Douglas Gregor
08:00:51 <Philippa> similarly: the semantics of typeclasses simply have nothing to do with specialisation
08:01:17 <Philippa> in fact, the existance of polymorphic recursion prevents a specialisation-only implementation
08:01:24 <Ezla> Philippa:  typeclass A includes B and C doesn't mean specialization necessarily
08:01:37 <Philippa> nor did I say it did
08:02:21 <Philippa> do we have subclassing? Yes. Do we have "superclassing"? No, it turned out to be a malformed concept
08:02:35 <Ezla> subclassing is what?
08:02:54 <Philippa> Do you need to sit down and actually try stuff rather than expecting the chan to answer everything without you having apparently written a single line? Hell yes
08:03:25 <Ezla> Philippa, they're valid questions
08:03:31 <Philippa> they're also hard work to answer
08:03:34 <haskell_newbie> Hi guys, can anyone help me? I want to see if a certain string is in another string, but I only have the string with the term repeated 3 times, like this for example: "olaolaola". So I have to take out one of the repeated "ola"'s first.
08:03:38 <Ezla> Why hard work?
08:03:39 <Philippa> you don't get to have every "valid question" answered
08:03:50 <ziman> Ezla, to me it seems like you act as the most competent programming language expert, constantly abusing attempts of others to constructively answer your questions, spamming the channel, annoying people, ... You're stealing too much time from the others only for yourself (because noone else benefits from it, hardly even you) and I'm really surprised they're still willing to answer.
08:04:14 <Ezla> ziman: That's a meta argument
08:04:18 <Philippa> precisely because of the subtractive approach you're taking. We have to work out the conceptual universe that applies and work from there
08:04:21 <Philippa> we're talking about manners
08:04:28 <Philippa> so damn right it's meta
08:05:07 <ciscbrain> haskell_newbie: so.. you have a string that repeats a string three times?
08:05:10 <Philippa> you do not have a right to an answer to every "valid question"
08:05:34 <ciscbrain> haskell_newbie: and you want to test whether another string is part of one of those three?
08:05:47 <Philippa> you do not, in fact, have a right to have anyone even listen to them
08:06:03 <Philippa> therefore, the issue is about whether people want to, and why
08:06:24 <Philippa> people are telling you that the way you behave makes them not want to put the effort into answering. You might want to consider what you can do about this
08:07:33 <Philippa> in the meantime, don't mistake "you're being unpleasant and I don't wish to continue this discussion" for "you're being unpleasant and that makes your line of argument wrong"
08:07:39 <Ezla> I don't see it that way.
08:07:58 <Philippa> people rarely see eye to eye. That's something you have to get used to in order to interact with others
08:08:06 <Ezla> I actually see it as a train of clear questions about specific things, being habitually On-topic, curious, free flowing and open minded
08:08:14 <Philippa> yes, I know you do
08:08:21 <Ezla> and then various people repeatedly turning towards "You"
08:08:26 <Ezla> And saying Ezla, "You"
08:08:39 <Ezla> Whereas all I spoke of was typeclasses
08:08:53 <Philippa> yes. That's because you're ignoring how much of other people's time you're taking up and the possibility that you might in fact be being highly rude without recognising it
08:09:13 <danj> Hi All, is anyone familiar enough with emacs/haskell-mode to help me understand why haskell-ds-forward-decl isn't getting bound to a key
08:09:15 <Ezla> Philippa, so let them opt-out
08:09:26 <Philippa> that isn't how we've chosen to run this channel
08:09:42 <mauke> server-side ignore > client-side ignore
08:09:44 <Ezla> How can the channel have a policy of needing to answer 100% of questions?
08:10:04 <Philippa> human psychology doesn't work that way
08:10:13 <ciscbrain> danj: how are you trying to bind it?
08:10:24 <Ezla> This is insane! I was asking about typeclassing in Haskell. Why do you guys give me all this meta garbage?
08:10:29 <Philippa> there is in fact a limited amount of "space" here, and people do actually try to do their best by you
08:10:36 <Ezla> Lets speak in Code
08:10:38 <Ezla> not english
08:10:42 <Philippa> because you're pissing people off, and we'd rather do this than just kickban you
08:10:52 <Ezla> I don't like the ego
08:10:55 <haskell_newbie> ciscbrain:  I've got this string (which I know has a term repeated 3 times, **besides** other characters ) and I want to see if that term is  equal to another string.
08:10:56 <mauke> haha
08:11:08 <danj> ciscbrain: I've added (add-hook 'haskell-mode-hook 'turn-on-haskell-decl-scan) to .emacs
08:11:10 <Philippa> *we* don't like the ego either. You're showing an awful lot behind the "I don't have any" rhetoric
08:11:26 <Ezla> Ok, Philippa, I have an idea
08:11:33 <Ezla> I concede to your point
08:12:14 <Ezla> Will you scroll up, to my questions about why haskell doesn't have typeclass typeclasses, and paste me the line where I went off-kilter.. so that I can learn for next time?
08:12:20 <Saizan> haskell_newbie: how are you going to recognize which part of this string is the term?
08:12:20 <danj> ciscbrain: the definition of 'haskell-decl-scan-mode in haskell-decl-scan.el appears to bind it to \M-\C-e
08:12:25 <Ezla> Show me the flaw in my question asking
08:12:27 <Philippa> it's not a single line, I'm afraid - it's more subtle than that
08:12:34 <Ezla> Starting from:
08:12:39 <MyCatVerbs> Ezla: please go hit the mailing lists instead.
08:12:44 <Ezla> <Ezla> I want:  f x = True :: (Num a) => a -> Bool  ;  f x = False :: (Enum a) => a -> Bool
08:12:45 <haskell_newbie> Saizan: I guess it's the one repeated 3 times...
08:13:06 <Ezla> Philippa: I think the subtlety is in people's fears
08:13:08 <Philippa> okay, that one's easy: every term has one type, f is a term like any other
08:13:11 <mmorrow> Ezla: http://hpaste.org/12808
08:13:25 <Ezla> BRAVO mmorrow
08:13:28 <Ezla> that's more like it.
08:13:29 <Saizan> haskell_newbie: ah, so like "olaabcolayhzola" should give you ola?
08:13:30 <Philippa> I think you're wrong. But you also need to accept that others' fears are often based on experience and entirely rational
08:13:52 <haskell_newbie> Saizan: yeah, thats it :)
08:13:54 <MyCatVerbs> Ezla: you'll get better responses that way, people will be able to take longer.
08:14:19 <Ezla> Philippa: I cannot base my curiosity around the potential for somebody else to find fears in the subtlety of my questions
08:14:20 <Philippa> the single biggest fear people have about you right now is that you're hard work and lead to a lot of noise in here. I'd say that's turning out true, regardless of notions like "trolling"
08:14:38 <Ezla> Because it's not constant amongst humans
08:14:54 <Saizan> haskell_newbie: quite weird, you don't have any other info on how that string is structured?
08:15:04 <Philippa> it's not in the subtlety of your questions. It's aspects of your behaviour that require a picture over time to point out
08:15:09 <Philippa> and incidentally: yes, yes you can
08:15:17 <Ezla> Philippa: So what, I am myself
08:15:23 <Ezla> I'm not perfect
08:15:29 <Ezla> For your given value
08:15:33 <Philippa> we don't expect perfection
08:15:41 <Philippa> I'm not, far from it
08:15:44 <Ezla> I could say the same thing that you're not perfect in providing language justifications
08:15:46 <ciscbrain> danj: if you run C-h C-k, M-C-e
08:15:54 <Ezla> this comes from solips
08:16:00 <MyCatVerbs> Ezla: please, please, please take this discussion over to mailing lists instead.
08:16:01 <ciscbrain> danj: does it report your function?
08:16:12 <Philippa> OTOH, we do expect work. And you've been getting a lot of work for free without so much as acknowledging it
08:16:25 <ciscbrain> danj: sorry, C-h k, M-C-e
08:16:27 <haskell_newbie> Saizan:   I don't think so...
08:16:41 <Ezla> I have acknowledged it.
08:16:50 <Ezla> What did I just say to mmorrow?
08:17:03 <Philippa> all of it?
08:17:06 <Ezla> I was overjoyed.
08:17:08 <mauke> <Ezla> that's more like it.
08:17:13 <danj> csicbrain: C-M-a and C-M-e are still bound to the standard beginning-of-defun and end-of-defun functions
08:17:18 <mauke> YOU ALL SHOULD WORK HARDER TO SATISFY ME
08:17:21 <Philippa> yeah, that's not even an acknowledgement
08:17:23 <MyCatVerbs> For the love of Pete. Fire up mutt and get a mailman subscription.
08:17:29 <int-e> we need #haskell-ezla
08:17:33 <int-e> :P
08:17:49 <Philippa> Ezla: you were given the name of a paper earlier btw, you'll find that helps as a starting point in understanding typeclasses firmly
08:17:58 <Philippa> it's not particularly tough to read either, from memory
08:18:02 <eu-prleu-peupeu> hello Hppl
08:18:13 <skorpan> you're *still* on about compile time stuff?
08:18:18 <kfish> hi eu-prleu-peupeu
08:18:24 <MyCatVerbs> Ezla: http://www.haskell.org/mailman/listinfo/haskell-cafe <- will be much more useful for the kinds of questions you're asking than IRC.
08:18:32 * Philippa seconds what MyCatVerbs is saying
08:18:54 <Ezla> > fix ("meta":)
08:18:55 <lambdabot>   ["meta","meta","meta","meta","meta","meta","meta","meta","meta","meta","met...
08:19:43 <MyCatVerbs> > fix ("meta-"++)
08:19:43 <Philippa> Ezla: damn right it's meta. Because it's that or boot you. If you aren't willing to put in some effort over time to not piss everyone off, then you shouldn't be here. Same goes for anyone, myself included
08:19:44 <lambdabot>   "meta-meta-meta-meta-meta-meta-meta-meta-meta-meta-meta-meta-meta-meta-meta...
08:19:53 <Philippa> mushroom mushroom
08:20:02 <LeoD> snaaaaaaake
08:20:04 <conal> i have an idea.  people can respond to Ezla when they enjoy doing so and not when they don't.  and if Ezla wants more feedback about how he can encourage more response from people, he can ask.  (which people will respond to when they want.)
08:21:00 <Philippa> conal: human nature's such that that doesn't actually work, unfortunately. Not without masses of effort on the part of everyone who has contact with Ezla, not least because people actually try to be nice
08:21:39 <kfish> i think Ezla should help haskell_newbie with the string matching problem :-)
08:21:47 <haskell_newbie> :)
08:22:37 <conal> Philippa: might be human nature.  my experience points to nurture/habit.  and habit is hard enough change that the difference might be moot.
08:23:52 <conal> Philippa: and i'd add that if ops believe that the value of the channel is sufficiently diminished by Ezla's presence, then they might take action accordingly.
08:25:06 <conal> just a thought.  i'm cool with people handling these things as they like.
08:25:16 <Saizan> haskell_newbie: i'm afraid you've to try each substring in turn and see which appears exactly three times, paying attention to overlapping matches, it's a bit of work but functions from Data.List should help
08:26:57 <int-e> Saizan: sorting the tails of the string would be a good start, I think
08:27:11 <haskell_newbie> Saizan: ok, thanx....I'll see what  I can do.
08:27:22 <int-e> Saizan: (we really want a suffix trie, but Data.List doesn't provide one *g*)
08:28:04 <int-e> > sort (tails "olaabcolayhzola")
08:28:05 <lambdabot>   ["","a","aabcolayhzola","abcolayhzola","ayhzola","bcolayhzola","colayhzola"...
08:28:22 <int-e> > drop 10 $ sort (tails "olaabcolayhzola")
08:28:24 <lambdabot>   ["layhzola","ola","olaabcolayhzola","olayhzola","yhzola","zola"]
08:28:38 <int-e> see how all three occurences of 'ola' occur together :)
08:28:58 <Saizan> ah, nice
08:29:37 <Saizan> so you just have to find three consecutive strings with the same prefix
08:30:46 <Saizan> if not for overalling
08:30:54 <Saizan> *overlapping
08:33:43 <int-e> so looking for common prefixes of strings would be a useful building block.  commonPrefix :: Eq a => [a] -> [a] -> [a]
08:37:37 <arw> common_prefix_length (a, b) = length $ takeWhile equal_pair $ zip a b
08:38:08 <arw> with equal_pair (a, b) = a == b
08:38:27 <int-e> @type uncyrry (==)
08:38:28 <lambdabot> Not in scope: `uncyrry'
08:38:30 <int-e> @type uncurry (==)
08:38:31 <lambdabot> forall a. (Eq a) => (a, a) -> Bool
08:38:55 <int-e> > let cP (x:xs) (y:ys) | x == y = x : cP xs ys; cP _ _ = [] in maximumBy (compare `on` length) . foldr1 (zipWith cP) . take 3 . tails . sort . tails $ "olaabcolayhzola" -- fun :)
08:38:57 <lambdabot>   "ola"
08:40:49 <int-e> Yes, commonPrefix as bs = map fst . takeWhile (uncurry (==)) $ zip as bs. But for some reason I prefer the direct recursive definition for that function.
08:40:50 <Saizan> > take 3 . tails . sort . tails $ "olaabcolayhzola"
08:40:51 <lambdabot>   [["","a","aabcolayhzola","abcolayhzola","ayhzola","bcolayhzola","colayhzola...
08:41:15 <int-e> > take 3 . tails $ [1..4]
08:41:16 <lambdabot>   [[1,2,3,4],[2,3,4],[3,4]]
08:41:35 <haskell_newbie> wow, I wasn't seeing the messages and now I just saw your answers. I'm still digesting them though
08:42:09 <int-e> Saizan: that's just for grouping each element with the next two, ready for digesting by 'zipWith'.
08:43:44 <int-e> ah, that code doesn't work for strings shorter than 2 characters... and ...
08:44:00 <int-e> > let cP (x:xs) (y:ys) | x == y = x : cP xs ys; cP _ _ = [] in maximumBy (compare `on` length) . foldr1 (zipWith cP) . take 3 . tails . sort . tails $ "xxxxxx" -- this result may be somewhat unexpected
08:44:01 <lambdabot>   "xxxx"
08:44:40 <eu-prleu-peupe2> my copy of the real world haskell is taking a long time to arrive :/
08:45:40 <Saizan> int-e: nice code, it feels like you're organizing a tournament between strings :)
08:46:39 <litb> is there a ready yi for archlinux?
08:49:18 <Ezla> mmorrow: Why was 'id' needed on withClass Num = id ?
08:49:51 <int-e> @type id
08:49:52 <lambdabot> forall a. a -> a
08:49:54 <int-e> @src id
08:49:54 <lambdabot> id x = x
08:50:15 <Ezla> Are there any problems with this approach?
08:50:21 <int-e> Ezla: it wasn't needed per se - you could also write  withClass Num   x = x  and withClass Enum  = id
08:50:29 <int-e> err. withClass Enum   x = x
08:50:38 <Ezla> ah
08:50:49 <Ezla> How isn't this solution perfect?
08:51:42 <mmorrow> Ezla: yeah, it wasn't that it was needed, just that it seemed the best thing to put there
08:51:44 <int-e> Ezla: when you try to use it for, say, an Int, you have to decide at some point whether you want to use it as an Enum instance or as a Num instance.
08:51:57 <int-e> Ezla: that is, if I understand your question correctly.
08:52:39 <mmorrow> yeah, with classes being what they are in haskell's type system, i'm not sure how useful / what use that function would be, but that's not to say there isn't one
08:53:08 <Ezla> Can I do this on returns?
08:53:19 <Ezla> and not explicitly specify
08:53:42 <mmorrow> but that example nicely show's what GADTs do
08:54:39 <Ezla> so that Num or Enum is picked based on the signature of another function
08:54:44 <Ezla> which is constrained to one of those
08:54:46 <mmorrow> Ezla: the thing about haskell's type system is that this isn't necessary, because it's all infered/determined by the types of everything else in the program (or by the explicit signature you give something)
08:55:06 <mmorrow> you can just do for instance
08:55:06 <Ezla> mmorrow: If you've got elephants all the way up
08:55:16 <mmorrow> @type id :: (Enum a) => a -> a
08:55:17 <lambdabot> forall a. (Enum a) => a -> a
08:55:41 <mmorrow> @type id :: Tree (Maybe [Either Int ()]) -> Tree (Maybe [Either Int ()])
08:55:42 <lambdabot> Tree (Maybe [Either Int ()]) -> Tree (Maybe [Either Int ()])
08:55:57 <mmorrow> the type is constrained by the constraints you put on it
08:56:24 <mmorrow> (whether that be explicitly via type signature(s) or implicitly by the values it gets handed)
08:56:41 <mmorrow> @type id
08:56:42 <lambdabot> forall a. a -> a
08:57:07 <mmorrow> > return 42 :: [Int]
08:57:08 <lambdabot>   [42]
08:57:11 <mmorrow> > return 42 :: Maybe Double
08:57:12 <lambdabot>   Just 42.0
08:57:19 <mmorrow> > return 42 :: IO Float
08:57:20 <lambdabot>   * Exception: "<IO Float>"
08:57:31 <mmorrow> @type return
08:57:32 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
08:57:36 <C-Keen> is there an easy way to build a statically linked version of a cabal package (if it is an application=
08:57:39 <C-Keen> )
08:58:11 <Ezla> "you have to decide at some point whether you want to use it as an Enum instance or as a Num instance."
08:58:21 <Ezla> What's an example?
08:58:34 <ksf> *** Exception: user error (unknown GLUT call glutSetOption, check for freeglut)
08:58:42 <mmorrow> i'm not sure exactly he had in mind with that
08:58:45 <ksf> that's reactive-glut, do I really need freeglut?
08:59:38 <Ezla> mmorrow: what does a function using this 'Class' look like?
08:59:48 <litb> is coding a First Person Shooter possible with haskell ?
08:59:53 <Ezla> or rather an overloaded function
09:00:08 <litb> something like doom or HL or so?
09:00:12 <Ezla> The hpaste didnt have an application of it
09:00:36 <mm_freak> http://hpaste.org/12803#a1  this code needs 800 ms, while the corresponding C version needs only 30 ms
09:00:54 <int-e> Ezla: if you have an Int value x :: Int, you can write both  withClass Num x and withClass Enum x
09:00:57 <mm_freak> any way to optimize this further without needing explicit destructive update?
09:01:03 <ksf> we already got a shooter.
09:01:30 <ksf> http://www.haskell.org/haskellwiki/Frag
09:01:33 <conal> ksf: i'd like your help fixing that bug.
09:01:33 <mmorrow> Ezla: so that's the thing, because there really isn't a useful function using withClass that can't be done by just giving `id' the type sig you want it to have
09:01:58 <conal> ksf: there's a trac ticket with a suggested fix.  i don't have non-free glut to test it out with.
09:02:06 <Kamina> ksf: wow :-)
09:02:30 <Saizan> mm_freak: i'd try if importing Control.Monad.State.Strict makes any difference
09:02:38 <Ezla> mmorrow: Does it bother you if I ask for another example?
09:02:39 <Ezla> if not
09:02:52 <mmorrow> Ezla: go ahead
09:03:00 <mmorrow> err, example of what?
09:03:01 <mm_freak> Saizan: that would make rc4List strict, too
09:03:11 <Ezla> Can you show me   option A "which isnt really needed"  side by side with option B (just giving `id` the type sig)
09:03:15 <mm_freak> i'd need individual runState calls for each result
09:03:24 <conal> ksf: http://trac.haskell.org/FieldTrip/ticket/8
09:03:27 <Ezla> so I can compare them
09:03:36 <mmorrow> withClass Num :: (Num a) => a -> a
09:03:48 <mmorrow> @type (id :: (Num a) => a -> a)
09:03:50 <lambdabot> forall a. (Num a) => a -> a
09:03:53 <conal> ksf: interested?
09:03:55 <mmorrow> same type
09:04:16 <Saizan> mm_freak: are you sure?
09:04:24 <mm_freak> Saizan: i tried it
09:04:28 <Ezla> mmorrow: Ah, but
09:04:30 <mmorrow> and withClass is /restricting/ the type of id
09:04:35 <Ezla> Even if it is the same type or not
09:04:46 <Ezla> I want to restrict to Only enum, or Only num
09:04:46 <ksf> yeah.
09:05:12 <mmorrow> Ezla: yes, so  (id :: (Num a) => a -> a) -- this id has just been restricted to only Num
09:05:29 <mmorrow> > (id :: (Num a) => a -> a) True
09:05:30 <lambdabot>       No instance for (Num Bool)
09:05:30 <lambdabot>        arising from instantiating a type sig...
09:05:33 <Ezla> However
09:05:59 <ksf> arg they're just using userError.
09:06:04 <Ezla> f :: (NumOrEnum a) ===> a;    f x = True :: (Num a) => a -> Bool  ;  f x = False :: (Enum a) => a -> Bool
09:06:14 <ksf> ...anyway, I should look at the reactive-glut source.
09:06:47 <mmorrow> Ezla: but what if `a' is an instance of /both/ Num /and/ Enum?
09:06:56 <conal> ksf: thx :)
09:07:04 <Ezla> mmorrow: Lexical match
09:07:06 <Ezla> first one wins
09:07:36 <mmorrow> Ezla: matching what from where though?
09:07:37 <Ezla> Just like all haskell func sigs
09:07:39 <mm_freak> Saizan: i speeded it up a little bit by precalculating s ! i' and s ! j', but not much
09:07:41 <conal> ksf: please let me know what you learn.  and if you decide not to pursue it, i'd like to know that also, and then i'll send a note to the FieldTrip mailing list.
09:07:46 <mm_freak> i'd love to see GHC do CSE
09:08:13 <Ezla> mmorrow: matching the type of the argument to f
09:08:16 <mm_freak> sometimes common subexpressions are just much nicer than names
09:08:21 <mmorrow> Ezla: but haskell doesn't keep that info around
09:08:22 <Ezla> to a typeclass
09:08:33 <Ezla> mmorrow: It does at compile time
09:08:36 <mmorrow> you'd need a dependently typed language to do that
09:09:02 <Ezla> what do you mean by dependently typed language
09:09:04 <mmorrow> Ezla: so when the code is /actually/ getting compiled, that function wouldn't (couldn't!) have that type
09:09:33 <Ezla> mmorrow: couldn't have that typeclass?
09:09:34 <Ezla> or type
09:09:57 <mmorrow> Ezla: someone may know of a good overview of what a dependently typed lang is
09:10:14 <mmorrow> Ezla: what would be the type of that function as a whole?
09:10:19 <PeakerWork> Ezla: I think the long name is "Value-dependent types", but everybody says "Dependent types". They are types that are allowed to depend on runtime values. In effect, its a type-system that allows proving more things about the execution of a program than a completely static type system
09:10:27 <Ezla>  mmorrow: that's why I used ===>
09:10:40 <PeakerWork> @quote dependent types head
09:10:41 <lambdabot> No quotes for this person. The more you drive -- the dumber you get.
09:10:43 <Ezla> NumOrEnum  is a typeclass typeclass of (Num, Enum)
09:10:51 <mmorrow> Ezla: exactly, that function can't be typed under haskell's type system
09:11:00 <PeakerWork> Ezla: there's a quote about the main defining property of dependent types: "If you manage to get the type system to catch the error in   head []   you nailed the dependent types problem"
09:11:01 <iagoabal> PeakerWork, a type is a value too
09:11:02 <iagoabal> ;P
09:11:07 <mmorrow> @type id :: (Num a, Enum a) => a -> a
09:11:08 <lambdabot> forall a. (Enum a, Num a) => a -> a
09:11:10 <Ezla> mmorrow: Ah, I see however
09:11:13 <Ezla> It's syntax sugar
09:11:15 <PeakerWork> iagoabal: in a dependent type system, you mean?
09:11:16 <Ezla> it generates:
09:11:20 <Ezla> f_0
09:11:21 <Ezla> f_1
09:11:31 <Ezla> Which is statically resolved
09:11:32 <iagoabal> PeakerWork, yep, all type have a type, so a type is itself a value of some type
09:11:44 <iagoabal> in type theory at least
09:11:44 <Ezla> depending on the terminal resolution
09:11:48 <PeakerWork> iagoabal: ah, I don't know much about dependent typing
09:11:51 <mmorrow> Ezla: ah, you could do that with template-haskell someway, but it'd be up to you to implement
09:12:05 <mmorrow> ghc would provide no help
09:12:10 <Ezla> mmorrow: thats just stuff the user never sees though
09:12:16 <ksf> conal, I changed the actionOnWindowClose call and it works.
09:12:19 <Ezla> But..
09:12:21 <ksf>      catch (actionOnWindowClose $= MainLoopReturns)
09:12:21 <ksf>            (\e -> return ())
09:12:25 <int-e> > let id1 :: Num a => a -> a; id1 = id; id2 :: Enum a => a -> a; id2 = id in id1 (id2 (1 :: Int))
09:12:27 <lambdabot>   1
09:12:35 <Ezla> even if 'f' generates various overloads... why would it matter / change the rest of code elsewhere, ever?
09:12:45 <Ezla> if everything ELSE is automatically typed too
09:12:57 <ksf> but then... shouldn't that be done in some kind of event loop?
09:13:14 <mmorrow> Ezla: i think you're thinking haskell typeclasses are sometihng they're not
09:13:29 <mmorrow> what exactly that is though, i'm not sure
09:13:50 <conal> ksf: oh -- so simple.  thanks a zillion!
09:14:04 <ksf> as right now, I'm tempted to switch to freeglut as I don't want my ghci to exit...
09:14:07 <Ezla> I think typeclasses are the subtractive type system, a set of constraints upon the interface of a type, and a set of Instances upon the specific typeclass to specialize further upon those constraints
09:14:13 <ksf> np
09:14:17 <iagoabal> PeakerWork, well, I only know Coq, at least in Coq is like I said. For example, the function id :: a -> a, in Coq is id :: forall (A:Type), A -> A, A is a type, but a value of type Type :P. Types like "Type" are called sorts or universes
09:14:40 <Ezla> mmorrow: what thought did I have that leads you to think I'm seeing it awry?
09:14:42 <PeakerWork> iagoabal: do they also have kinds?
09:15:45 <int-e> Ezla: There's a type system extension that allows overlapping instances, which is related to your question. (ghc documentation here: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-overlap -- is there a paper?) In my personal opinion it's a mess, but some people find it useful.
09:15:59 <Ezla> int-e: thanks
09:16:31 <mmorrow> Ezla: because instead of trying to determine an outcome based on the particular class a type happens to be an instance of, one wants to assume a type is an instance of a particular class in order to have available functions on that type to get to that outcome
09:16:51 <iagoabal> PeakerWork, uhm, I'm not a Coq expert but I think no, they don't need it, in Haskell a kind describes a type no? But in Coq a type is a value of other type, there is always a type for any object
09:17:01 <conal> ksf: if you don't mind, i'll add you to the contributors list for reactive-glut.  i can say "ksf" or another name.  /whois says "unknown"
09:17:09 <iagoabal> Type_0 has type Type_1, Type_i has type Type_(i+1)
09:17:10 <iagoabal> ...
09:17:12 <int-e> "a mess", because it's tricky to get right, and extremely tricky to get the compiler pick the instances that you want in nontrivial cases (polymorphic functions mostly).
09:17:30 <iagoabal> N (Nat) is of type Set, and Set is of type Type_0
09:17:33 <Ezla> mmorrow: Yes, I understand haskell works the way you said, and that I'm trying to go the opposite direction, which causes the function signatures to split off into a huge pyramid of derivations
09:17:34 <ksf> Achim Scheider
09:17:37 <Ezla> and bloats the static code
09:17:42 <ksf> fuck now I outed myself ;)
09:17:45 <Ezla> makes big executables
09:18:02 <conal> ksf: i'm happy to say "ksf" if you prefer.  or nothing.
09:18:07 <Ezla> But, not all things need not be used sparingly
09:18:08 <ksf> I don't care.
09:18:43 <conal> ok.  i really appreciate the help.
09:19:29 <mmorrow> Ezla: the only thing is that because of how typeclasses are designed/implemented, it's impossible to do what you say (maybe possibly to mimic it with heavy hackery, but impossible in the general case)
09:19:42 <Ezla> int-e: what language tried to get it right in the core lang?
09:20:10 <Ezla> mmorrow: I think its possible if you just keep making more static code
09:20:17 <PeakerWork> iagoabal: so why call them "sorts" or "universes" and not "kinds"?
09:20:30 <mmorrow> Ezla: it's definitely possible, just not with the current implem of typeclasses :)
09:20:42 <mattam> iagoabal: Set, Type_i etc... are "sorts" which roughly correspond to kinds.
09:20:42 <iagoabal> PeakerWork, is different, see that
09:20:58 <mmorrow> so you'd have to /not use the typeclass mechanism/ and perhaps do it manually with TH or something
09:20:58 <iagoabal> Prelude> :k []
09:20:58 <iagoabal> [] :: * -> *
09:20:59 <iagoabal> but
09:21:13 <iagoabal> Type list.
09:21:21 <Ezla> mmorrow: Ok, approached from a very pragmatic approach.. let me give a use case
09:21:24 <iagoabal> list : Type -> Type
09:21:41 <Ezla> Library X wishes to provide a 'verb' which has an overloaded meaning, saving the user convenience
09:21:41 <PeakerWork> iagoabal: why is that so different?
09:21:48 <iagoabal> But I have define a type list' : Set -> Set
09:21:53 <iagoabal> I can*
09:21:58 <Ezla> and it needs to change its typeclass use depending on the type they input
09:22:21 <Ezla> So, not in the derivation form, but just the high level end user use for this
09:22:28 <mmorrow> Ezla: yes, this is not what typeclasses are. i think you'd find this wiki page /very/ interesting:
09:22:30 <PeakerWork> Ezla: sacrifice type safety/type system semantics for "convenience"? I doubt a more complicated type system will end up with more "convenience"
09:22:32 * mmorrow finds link
09:22:43 <iagoabal> PeakerWork, in Coq a type is a first-order value
09:22:51 <PeakerWork> iagoabal: I understand
09:22:53 <Ezla> Peaker, it doesn't stop type safety
09:22:58 <mmorrow> http://haskell.org/haskellwiki/OOP_vs_type_classes
09:22:59 <iagoabal> a polymorphic function is a function that have the type like an argument
09:23:00 <Ezla> because you still run into constraints at every turn
09:23:15 <mmorrow> i found that page very interesting (and this was last week)
09:23:23 <Ezla> mmorrow: cool thx
09:23:30 <iagoabal> if you have id : forall (A:Set), A -> A a way to call id is: id nat 0
09:23:33 <mmorrow> anyhow, i've gotta run. you really should read that wiki page :)
09:23:38 <mmorrow> np
09:23:45 <Ezla> later :)
09:23:46 <PeakerWork> Ezla: overloading multiple types on a function in yet another way (that seems to be more complicated than type classes!) sounds like a bad idea if all it buys you is some "convenience" (which is doubtful, IMO, because using different names for different types sounds more convenient to me)
09:24:17 <Ezla> not just convenience
09:24:26 <Ezla> But it buys you more type safety
09:24:47 <Ezla> You can make more atomic restrictions rather than having "do all" typeclasses
09:24:51 <Ezla> and compose them
09:26:07 <Ezla> haskell typeclasses feel very global
09:26:07 <iagoabal> PeakerWork, in Haskell a type has a kind, but what is the type/kind of the kind of a type? In Coq list have Type -> Type, and (Type -> Type) has the type Type, and Type has a type...
09:26:16 <conal> ksf: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/reactive-glut
09:27:00 <conal> z
09:27:00 <PeakerWork> iagoabal: like Python :-)
09:27:02 <conal> oops
09:27:22 <iagoabal> PeakerWork, in Python all has a type? :O
09:27:35 <Saizan> i think peaker has misunderstood
09:27:36 <PeakerWork> iagoabal: yeah
09:27:51 <iagoabal> but types aren't first order values, or yes?
09:28:01 <PeakerWork> iagoabal: they are.. though there are other differences
09:28:20 <PeakerWork> iagoabal: well, Python types are not truly types, perhaps, but if they were... :-)
09:28:47 <iagoabal> uhm, yeah, python is dynamic typed
09:29:06 <ksf> conal, I meant "I don't care for the attribution" as I didn't actually did anything, not "I don't care about the name"...
09:29:07 <PeakerWork> yeah, but its similar in the sense you can take the type() of anything in Python, including type
09:29:20 <Saizan> iagoabal: Type -> Type is of type Type? not Type1 or what else the higher one in the hierarchy is called?
09:29:33 <ksf> and I said "outing myself" because ppl might know me from the cafe.
09:29:44 <Ezla> Having no ability to require two typeclasses at once for a single 'a' cause it to be that you always write functions which only perform exactly one Job and only depend on one behaviour of that type
09:29:48 <Ezla> which may be a good thing
09:30:08 <ksf> that is, if you attribute, then take the name, not the nick, please.
09:30:19 <conal> ksf: oh.  if you're indifferent, i'll leave the acknowledgement, since i enjoy it.  if you'd prefer, i'll remove your name.
09:30:29 <RayNbow> > let nfibs n = replicate (n-1) 0 ++ 1 : 1 : zipWith ((-).(2*)) (drop n (nfibs n)) (nfibs n) in nfibs 2  -- luite_
09:30:36 <iagoabal> Saizan, if I don't remember bad the typing rules, Type->Type has the type Type, altought in practice Coq don't made difference between Type_i's, is only at internal level
09:30:40 <RayNbow> @bot
09:30:41 <lambdabot> :)
09:30:41 <lunabot>  :)
09:30:44 <lambdabot>   thread killed
09:30:48 <RayNbow> hmm
09:31:13 <iagoabal> Saizan,
09:31:13 <iagoabal> Coq < Type (Type -> Type).
09:31:13 <iagoabal> Type -> Type
09:31:13 <iagoabal>      : Type
09:31:20 <ksf> I long since gave up to stay anonymous on the net.
09:31:48 <int-e> RayNbow: there's no base case?
09:31:57 <Saizan> iagoabal: ah, so you won't get a Type_i at the user-level?
09:31:59 <int-e> RayNbow: nm
09:32:02 <int-e> RayNbow: I misread
09:32:11 <mattam> Saizan: it's just hidden.
09:32:19 <RayNbow> int-e: there is, but I just found it's slow
09:32:23 <RayNbow> *found out
09:32:25 <iagoabal> Saizan, no, the Type_i : Type_i+1 is only an internal trick to have consistence, since all value must have a type
09:32:25 <mattam> You can't manipulate type indices explicitely.
09:32:26 <conal> ksf: glad to use your name.  what is it?
09:32:33 <ksf> Achim Schneider
09:32:54 <conal> ksf: oh!  thanks :)
09:32:59 <maltem> iagoabal: ah that's interesting... the Agda people have Set, Set1, ... at the language level
09:33:14 <iagoabal> but in practice, you only work with the universes Set (of programs), Prop (of properties) and Type (both Set and Prop are members of Type universe).
09:33:26 <int-e> > let nfibs n = let r = replicate (n-1) 0 ++ 1 : 1 : zipWith ((-).(2*)) (drop n r) r in r in nfibs 2
09:33:28 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
09:34:11 <int-e> RayNbow: I guess lambdabot doesn't enable optimization, so the common subexpression (nfibs n) isn't recognized.
09:34:17 <mattam> iagoabal: just to be clear, even if types are first-class values, you should add that you can't do anything with them but pass them around.
09:34:48 <maltem> int-e: what, there are cases where ghc does CSE?
09:35:06 <iagoabal> well, the fact that types are first-class values give you for free lot of things that Haskell have to add with extensions
09:35:14 <RayNbow> int-e: ah
09:35:25 <Ezla> I have a sort function, and I want it to be constrained by BOTH typeclasses at once: Sortable and Important..    Important stuff will go to the front of the sort.
09:35:27 <Ezla> How do you do that?
09:35:41 <int-e> maltem: http://www.haskell.org/haskellwiki/GHC:FAQ#Does_GHC_do_common_subexpression_elimination.3F
09:35:58 <mattam> [(Sortable a, Important a) =>] ?
09:36:24 <Ezla> is that even valid syntax?
09:36:59 <maltem> int-e: well yeah, so how does this apply to two occurences of (nfibs n)?
09:37:12 <mattam> The brackets are meta-syntax to delimit code, otherwise I think it's a valid type signature excerpt. :)
09:37:22 <Ezla> hmm
09:37:48 <Ezla> (Sortable a, Important b) =>  is ok too?
09:38:00 <maltem> int-e: oh wait
09:38:11 <maltem> int-e: I looked at the wrong line of code
09:38:48 <mattam> Ezla: I think so.
09:39:01 <RayNbow> preflex: @karma int-e
09:39:02 <preflex>  karma for int-e: 5
09:39:09 <RayNbow> preflex: int-e++
09:39:11 <RayNbow> preflex: @karma int-e
09:39:11 <preflex>  karma for int-e: 6
09:39:41 <int-e> maltem: hmm, you're right though, it doesn't catch that case.
09:40:44 <int-e> maltem: (I believe it could in principle - all that needs to happen is that the compiler, during compilation, introduces a  let  binding for 'nfibs n' and floats it out to the front of the definition of  nfibs n)
09:42:23 <Ezla> > let f x = 1 :: (Num a) => a -> a
09:42:24 <lambdabot>   <no location info>: parse error on input `;'
09:42:41 <int-e> maltem: it works in this case, for example: fibs n = 0 : 1 : zipWith (+) (fibs n) (tail (fibs n))
09:43:49 <Ezla> why doesn't that line work?
09:44:13 <Ezla> > let f x = 1 :: (Num a) => a -> a
09:44:14 <lambdabot>   <no location info>: parse error on input `;'
09:44:14 <Ezla> sorry
09:44:39 <Ezla> > let f x = 1 :: (Num a) => a -> a in f 1
09:44:40 <lambdabot>       Overlapping instances for Show (a -> a)
09:44:40 <lambdabot>        arising from a use of `s...
09:44:45 <int-e> maltem: I'm not sure what the difference between that and RayNbow's slightly more complex definition is. The ghc optimizer is not really predictable :)
09:44:45 <Saizan> > let f :: Num a => a -> a; f x = 1 in f 2
09:44:46 <lambdabot>   1
09:44:58 <Ezla> Saizan: Why can't you do it on one line?
09:45:58 <Saizan> Ezla: f x = 1 :: Num a => a -> a is parsed as f x = (1 :: Num a => a -> a)
09:46:09 <Saizan> so you're saying that the type of 1 is a function
09:46:12 <maltem> int-e: The reason that it doesn't do cse (although it could in principle) is that it's hard to tell whether more sharing is appropriate from an automatic analysis. The programmer can always introduce sharing via let bindings, but with CSE, she couldn't reduce sharing when she knows better than the compiler
09:46:13 <gwern> @quote lifting
09:46:13 <lambdabot> shapr says: < shapr> the snow falls slowly / the lambdas are lifting - / weak head normal form.
09:46:36 <int-e> maltem: I know that. In fact I had a case where even ghc's opportunistic CSE was too much.
09:46:45 <Ezla> wht about
09:47:03 <Ezla> > (let (f x = 1) :: (Num a) => a -> a) in f 1
09:47:04 <lambdabot>   <no location info>: parse error on input `='
09:47:56 <Elly> > let f x = 1 in f 1
09:47:57 <lambdabot>   1
09:48:25 <int-e> maltem: see http://hackage.haskell.org/trac/ghc/ticket/947 if you're curious
09:48:34 <Ezla> why should my parenthesized version be inavlid?
09:48:35 <mapreduce> @hoogle (t -> u) -> (t -> u) -> (t -> t -> t) -> (t -> u)
09:48:35 <lambdabot> No results found
09:48:41 <neko> hi everyone
09:48:57 <mapreduce> Is there such a function with the above type?  What is it called, or if you were inventing it, what would you call it?
09:48:57 <gwern> 'Without a kigo / or requisite syllables / haiku don't typecheck'
09:48:58 <gwern> hee hee
09:49:45 <neko> is it the proper place to ask for explanation regarding compilation error messages ?
09:50:05 <mauke> @hoogle (t -> u) -> (t -> u) -> (u -> u -> u) -> (t -> u)
09:50:06 <lambdabot> No results found
09:50:08 <cknapp> Yes, you can ask here... there are people who know things... *gasp!*
09:50:10 <mauke> @djinn (t -> u) -> (t -> u) -> (u -> u -> u) -> (t -> u)
09:50:11 <lambdabot> f a b c d = c (b d) (a d)
09:50:17 <mauke> @. pl djinn (t -> u) -> (t -> u) -> (u -> u -> u) -> (t -> u)
09:50:18 <lambdabot> f = flip (flip . (ap .) . flip (.))
09:50:54 <cknapp> neko: not that I'll be much help, but what is your problem?
09:51:00 <maltem> int-e: ahh I'm a little blind this evening. Your last (fibs n) example's compiled behaviour is news to me
09:51:12 <mapreduce> > let that = \f g m -> \t -> m (f t) (g t) in that (*3) (*4) (+) 5
09:51:13 <lambdabot>   35
09:51:40 <mapreduce> (I know the last "-> \" is redundant)
09:52:18 <Ezla> why doesn't parenthesizing work to disambiguate which part applies to the function signature?
09:52:33 <cknapp> Ezla: What do you mean?
09:52:49 <int-e> Ezla: parenthesized bindings don't exist in the haskell syntax.
09:52:53 <Ezla> (let (f x = 1) :: (Num a) => a -> a) in f 1
09:52:57 <mapreduce> Ezla: The syntax is: let x in y, not let x in ) y
09:52:59 <Ezla> int-e: why not?
09:53:04 <int-e> > let (f x = 1) in f 1 -- invalid
09:53:05 <lambdabot>   <no location info>: parse error on input `='
09:53:38 <Ezla> mapreduce: I realize that's not the syntax and hence why I ask "why doesn't"
09:54:04 <int-e> Ezla: that's not a constructive question, unless you want to get involved in the Haskell' effort.
09:54:18 <mapreduce> What would be the difference in meaning between (let foo = bar) in foo * foo and let foo = bar in foo * foo?
09:54:20 <Ezla> int-e: Ok, but it's constructive, because I expect you to say:
09:54:35 <gwern> @hoogle otherwise
09:54:35 <lambdabot> Prelude otherwise :: Bool
09:54:35 <Ezla> "No! You can't do that, because it breaks  A, B, and C"
09:54:35 <lambdabot> Data.Bool otherwise :: Bool
09:54:39 <Ezla> at which point
09:54:48 <Ezla> I learn the error in my thinking of that possibility
09:55:35 <int-e> Ezla: I haven't thought about it. I don't feel it's needed, and I suspect that it would make the language harder to parse.
09:56:20 <gal_bolle> > let {f x = 1} in f 1
09:56:22 <lambdabot>   1
09:56:30 <Ezla> gal_bolle:  !
09:56:31 <Ezla> :)
09:56:50 <gal_bolle> {} instead of () allows you to use indentation
09:56:57 <gal_bolle> which is really useful
09:56:58 <Ezla> > {let {f x = 1} :: (Num a) => a -> a} in f 1
09:57:01 <lambdabot>   <no location info>: parse error on input `{'
09:57:11 <cknapp> gal_bolle... thanks for pointing out the obvious... that we all missed
09:57:32 <Ezla> for a moment it looked nice
09:57:47 <Saizan> {} just disables layout rules
09:58:01 <gal_bolle> > let {f ::(Num a) => a -> a; f x = 1} in f 1
09:58:03 <lambdabot>   1
09:58:13 <Ezla> without ;
09:58:24 <int-e> > let { ; ; f x = 1 ;; ; } in f 1 -- you may think this is crazy, but this can probably? actually happen when layout is translated to explicit { and ;
09:58:25 <lambdabot>   1
09:58:38 <cknapp> > let {f x= 1; g x = 2} in g 2
09:58:39 <lambdabot>   2
09:58:53 <neko> cknapp: I'm trying to build the haskelldb-hsql-0.10 cabal package and I get that puzzling error: Ambiguous type variable `e' in the constraint: `GHC.Exception.Exception e' arising from a use of `throwIO' at Database/HaskellDB/HSQL.hs:181:54-62
09:59:02 <Ezla> Is there a form of 'in' which won't work with multiple statements there, and which doesn't requrie you to write 'f' ?
09:59:17 <Heffalump> neko: it probably needs to use Control.OldException
09:59:21 <cknapp> neko: Sorry, I can't help there. :) Someone else here probably knows what's going on
09:59:23 <Saizan> neko: pass --constraint="base < 4" to configure
09:59:34 <Ezla> { f x = 1 } __in 2
09:59:36 <neko> I understand that it stems from e being underspecified, but since I'm a complete newb I can't do much
09:59:42 <Ezla> but not a lambda
09:59:47 <cknapp>  (\x -> x+2) 2
09:59:48 <Ezla> one which still introduces the new function
09:59:50 <cknapp> Nevermind
10:00:13 <gal_bolle> you want a new function, but without a name?
10:00:17 <gal_bolle> why is that
10:00:18 <gal_bolle> ?
10:00:20 <Ezla> With a name
10:00:24 <cknapp> do notation?
10:00:26 <Ezla> Just not writing  in f 2
10:00:27 <Ezla> but
10:00:30 <Ezla> __in 2
10:00:35 <neko> Heffalump: I guess that Control.OldException is kind of obsoleted though ?
10:00:40 <gal_bolle> i don't understand
10:00:43 <cknapp> Ezla: not with in.
10:00:47 <Heffalump> yeah, as is base < 4 (which is a better suggestion)
10:00:51 <Ezla> cknapp: how?
10:01:02 <Heffalump> but unless you feel like making the necessary changes yourself, it's the easiest way to proceed for now
10:01:18 <mauke> > (fix \f x -> x + 2) 2
10:01:19 <lambdabot>   <no location info>: parse error on input `\'
10:01:21 <mauke> > (fix $ \f x -> x + 2) 2
10:01:22 <lambdabot>   4
10:01:24 <neko> Heffalump: I feel like making the changes myself
10:01:24 <neko> :)
10:01:28 <cknapp> I'm not entirely sure what you mean, Ezla
10:01:43 <cknapp> You want to create a new function, like what a lambda does, right?
10:01:44 <Ezla> > (fix $ \f x -> x + 2); f 1
10:01:46 <lambdabot>   <no location info>: parse error on input `;'
10:02:01 <Ezla> "still introduce f"
10:02:09 <mauke> Ezla: it does introduce f
10:02:11 <gwern> @pl \_ b _ -> foo b
10:02:11 <lambdabot> const (const . foo)
10:02:12 <Heffalump> neko: I think in that case you need to use catchAny rather than catch.
10:02:12 <mauke> Ezla: in its own body
10:02:31 <Saizan> ?type catchAny
10:02:32 <Heffalump> neko: because onError is trying to just introduce a "finally" style construct, so it wants to catch any error and then do something before rethrowing it
10:02:33 <lambdabot> Not in scope: `catchAny'
10:02:43 <Heffalump> ?type Control.Exception.catchAny
10:02:44 <lambdabot> Not in scope: `Control.Exception.catchAny'
10:02:46 <Heffalump> ?type Control.Exception.catchAll
10:02:47 <lambdabot> Not in scope: `Control.Exception.catchAll'
10:02:56 <cknapp>  > do {f x = x+2; return f 2}
10:03:17 <int-e> @type Control.Exception.catches
10:03:18 <lambdabot> Not in scope: `Control.Exception.catches'
10:03:20 <Saizan> Heffalump: i thought you'd have to use "catch (\e -> ... (e :: SomeException))" for that
10:03:25 <int-e> catches :: IO a -> [Handler a] -> IO a
10:03:27 <int-e> mm
10:03:29 <cknapp> Right
10:03:29 <Heffalump> oh, apparently it's called onException now
10:03:34 <Heffalump> ?type Control.Exception.onException
10:03:35 <lambdabot> Not in scope: `Control.Exception.onException'
10:03:38 <Heffalump> hmph
10:03:39 <int-e> ah.
10:03:41 <int-e> onException :: IO a -> IO b -> IO a
10:03:41 <Saizan> ah, wait
10:03:50 <Saizan> lambdabot is on 6.8.x
10:04:03 <Heffalump> Saizan: the point is that you really do want to catch everything in this case.
10:04:12 <Heffalump> but it sounds like onException actually does what onError is trying to do
10:04:26 <Heffalump> so the right answer is to have onError = onException, or to replace all uses appropriately
10:05:05 <Ezla> Why aren't numbers functions?
10:05:14 <Ezla> > do { x = 1; return x; }
10:05:16 <lambdabot>   <no location info>: parse error on input `='
10:05:48 <mauke> Ezla: they can be
10:05:54 <neko> Heffalump: ok, I'm looking at the Control.Exception doc, trying to make sense of it and what you said :)
10:05:58 <Ezla> can I use = notation there?
10:06:04 <mauke> Ezla: there is no = notation
10:06:15 <Heffalump> neko: make sure you're looking at the 6.10 docs
10:06:21 <Ezla> I mean if I made a number function
10:06:22 <int-e> > do { let { x = 1 }; return x; } :: [Int]
10:06:24 <lambdabot>   [1]
10:07:01 <mauke> Ezla: ?
10:07:22 <Ezla> int-e: why does that result in a parse error without the  {  } on let?
10:08:06 <Ezla>  is  ; actually an infix ?
10:08:08 <Saizan> Heffalump: yeah, SomeException is the root of the hierarchy of exceptions so it will catch all of them, however i see that onException is the needed combinator here
10:08:27 <Heffalump> Saizan: ah, SomeException wasn't a place holder, sorry I misunderstood you :-)
10:09:05 <Saizan> heh, i find it a bit funny name too :)
10:09:39 <Ezla> mauke: how do you make a number a function
10:09:59 <neko> Heffalump: the link points to the "latest" folder so I guess that's probably 6.10
10:10:07 <mauke> Ezla: by writing an appropriate instance Num definition for functions
10:10:17 <Heffalump> neko: yeah
10:10:19 <int-e> Ezla: because then the layout rules turn it into do { let { x = 1; return x; } }
10:10:41 <ksf> conal, http://haskell.org/haskellwiki/FieldTrip#Problems_and_solutions
10:10:55 <ksf> you can delete 6.2
10:11:01 <int-e> Ezla: don't ask why. it's a minor wart, and not really a problem when you're using layout instead of actual braces, in my experience.
10:11:06 <Ezla> do the layout rules HAVE to work that way?
10:11:13 <Ezla> would a 'var' keyword be possible?
10:11:26 <ksf> ...or mention that freeglut is needed to return to the repl.
10:11:54 <mauke> could haskell use base-11 numerals by default?
10:12:02 <Ezla> int-e: where are the layout rules working that warted-way useful?
10:12:10 <mauke> do the keywords have to be in English?
10:12:24 <ksf> mauke, do you prefer minbari?
10:12:30 <mauke> no, latin
10:12:34 <Ezla> mauke: the question is given an extension or keyword
10:12:44 <Ezla> without changing the rest of the layout/breaking code
10:12:51 <mauke> {-# LINGUA Latina #-}
10:12:52 <Ezla> I mean can layout rules be context dependent
10:12:56 <Ezla> in current haskell
10:13:02 <Ezla> so that:
10:13:08 <Ezla> do { var x = 1; return x; } // valid
10:13:08 <mauke> Ezla: just read the H98 report
10:13:15 <mauke> it tells you everything about current haskell
10:13:46 <Lemmih> mauke: The would defeat the purpose of trolling in #haskell.
10:13:47 <MyCatVerbs> Bottom-up, no less.
10:14:29 <Ezla> can you guys provide the "proof" example for why:  do { let { x = 1; return x; } }
10:14:33 <Ezla> is a very good thing?
10:14:47 <Ezla> or rather, for let x = 1; return x; turning into that
10:15:12 <MyCatVerbs> Ezla: no. It isn't a good thing. It's a wart.
10:15:19 <Ezla> hmm
10:15:37 <mauke> yeah, and why do we have to write the } anyway
10:15:42 <mauke> it's obvious where they belong
10:15:52 <MyCatVerbs> Ezla: fortunately, it almost never comes up in practice, provided you keep to the rule of either using { ; } or using whitespace layout but not mixing the two in random and silly ways.
10:16:07 <mauke> preflex: calc (2 * (3 + 4
10:16:07 <preflex>  14
10:16:16 <mauke> see?
10:16:26 <Lemmih> MyCatVerbs: I think it's a good thing.
10:16:32 <Ezla> Lemmih: why ?
10:17:04 <MyCatVerbs> Lemmih: the only upside that I can see is that it doesn't make the parser baloon in size.
10:17:06 <Lemmih> Ezla: Because ';' is used to separate the definitions in the 'let'.
10:17:15 <MyCatVerbs> *balloon
10:17:24 <Ezla> Lemmih: so ?
10:17:25 <dons> Lemmih: notice this Factor site running in gitit. http://articles.bluishcoder.co.nz/Factor/WebFrameworkNotes
10:17:26 <int-e> Ezla: if it didn't do that, this code: http://hpaste.org/12811#a1  would turn into  do { let { a = 1 }; b = 1; return (a+b); } and fail to work.
10:17:32 <Lemmih> MyCatVerbs: It also makes the compilers errors much more sensible.
10:17:35 <MyCatVerbs> Ezla: it's very rare that anyone actually uses { ; } in code anyway. Usually they're only useful when you want to push short things all onto one line.
10:17:40 <dons> Lemmih: had you seen this 'happs cookbook' http://articles.bluishcoder.co.nz/Haskell/NotAHAppSTutorial ?
10:17:56 <MyCatVerbs> Lemmih: I suppose; which is more or less a natural result of keeping the parser simpler. :)
10:18:01 <Ezla> int-e: thanks
10:18:21 <dons> shapr: gitit is popping up here and there. yay!
10:18:25 <Lemmih> dons: Yes, NotAHAppSTutorial is pretty neat.
10:18:30 <Ezla> int-e: so the second example wouldnt be valid?
10:18:40 <dons> when do we switch haskell.org over to gitit :)
10:19:11 <Ezla> The second example is valid today, only because of the "wart" (not a wart)
10:19:13 <Ezla> ?
10:19:17 <Lemmih> Right after we install House on the server.
10:19:50 <Saizan> and convert gitit to darcsit
10:20:09 <dons> Lemmih: heh. well gitit seems to be getting picked up in the wild now.
10:20:23 <shepheb> is Data.List.transpose new in 6.10?
10:20:28 <int-e> shepheb: no
10:20:45 <shepheb> oh, its permutations that's new, right.
10:21:01 <shepheb> thanks
10:21:26 <dons> yay gitit. http://www.reddit.com/r/programming/comments/7hy6g/a_happs_cookbook_advanced_haskell_web_framework/
10:21:28 <Ezla> int-e: was the 2nd one malformed or well formed?
10:21:38 <dons> shapr, i think gitit might be our xmonad this year... maybe
10:22:04 <dons> Lemmih: are you aggregating all the happs tutorials in a list on happs.org ?
10:22:05 <int-e> shepheb: that function has been in Data.List for ages. (6.4.2 is the oldest ghc version I can check, but it was there before that. it's part of the H98 List module after all)
10:22:07 <Heffalump> dons: what do you think is the name of the type that's like lists but is indexed with a type-level nat to give a static length?
10:22:11 <dons> would be good to link them all in one place.
10:22:27 <dons> Heffalump: hmm. vector?
10:22:41 <dons> Heffalump: what do they call that type in the proof carrying code papers?
10:22:44 <Heffalump> dons: sounds like a nice name to me. See any problems with that?
10:22:47 <dons> just a statically-checked list?
10:23:01 <dons> well, there's growable array types already called Vector and UVector
10:23:05 <dons> but that doesn't matter so much
10:23:08 <Heffalump> yes, precisely.
10:23:11 <Heffalump> Why doesn't it matter
10:23:12 <Heffalump> ?
10:23:21 <dons> well, we have qualified imports.
10:23:29 <dons> you don't have to pick a unique name.
10:23:30 <Heffalump> how does that help?
10:23:39 <Heffalump> it needs a unique name in (a) hackage and (b) the hierarchical modules
10:23:44 <int-e> Ezla: it's well-formed now. but I'm not interested in pursuing this syntax discussion further.
10:23:44 <dons> the only requirement is the module and package
10:23:46 <dons> not the type.
10:23:49 <Lemmih> dons: I would if I could. happs.org is a pain to modify. Hopefully it'll be infected with gitit "soon".
10:23:54 <dons> maybe, nat-list ?
10:24:10 <dons> Lemmih: cool.  like xmonad.org, its important to gather all knowledge in one place
10:24:13 <dons> so others can find it
10:24:18 <opqdonut> yep
10:24:30 <dons> all these new tutorials and demos
10:24:42 <Heffalump> and Data.NatList?
10:24:42 <int-e> Saizan: what advantage does darcs have, over git, for purposes of tracking the history of a wiki? darcs is all about ignoring the history.
10:24:55 <Ezla> int-e, there's no more to it if it is well-formed, because that proves it
10:25:09 <Heffalump> darcs does merges better (at least when there are no conflicts)
10:25:09 <dons> Heffalump: maybe?
10:25:12 <opqdonut> int-e: wow, hadn't thought about it that way
10:25:14 <dons> int-e: auto-merge
10:25:19 <dons> which is important in a wiki
10:25:25 <Heffalump> dons: hmm. I don't like it much :-)
10:25:36 <opqdonut> int-e: kinda sums up why I don't like darcs :>
10:25:47 * Heffalump decides not to break it out into a library for now
10:25:50 <dons> Heffalump: well, names shmames. static-list ?
10:25:50 <Saizan> mine was mostly a joke about haskell-made software, btw :)
10:26:34 <Ezla> What commonplace impertive stuff does do have trouble emulating?
10:26:37 <dons> i swear there's a downmod bot that hits every submission. http://www.reddit.com/r/programming/comments/7hy6g/a_happs_cookbook_advanced_haskell_web_framework/ go gitit! our flagship web app?
10:26:48 <mauke> Ezla: a SNES
10:27:04 <Heffalump> dons: http://www.reddit.com/r/programming/user/jdh30/disliked/
10:27:10 <dons> Ezla: hmm? with IO it introduces an imperative environment, so none?
10:27:20 <Ezla> dons: Syntax wise
10:27:27 <dons> Heffalump: oh?
10:27:27 <Ezla> common imperative syntax
10:27:28 <opqdonut> int-e: do you mind if I quote you on my blog? :)
10:27:37 <dons> huh
10:27:40 <int-e> opqdonut: not at all.
10:27:48 <Heffalump> dons: not really, but there is a definite pattern to the downmods there :-)
10:28:01 <mauke> Ezla: L: goto L;
10:28:05 <Ezla> lol
10:28:11 <Heffalump> darcs isn't exactly about throwing away history, it's more about making it as irrelevant as possible
10:28:19 <Ezla> how do you do a "switch" in do?
10:28:24 <int-e> dons: perhaps, although I see no fundamental reason why a three-way merge as git does should fare worse than darcs' merges. but I'm biased, I don't like darcs too much either.
10:28:29 <Ezla> do you have "constrained goto" ?
10:28:45 <mauke> Ezla: have you read the report yet?
10:28:54 <Heffalump> int-e: it doesn't fare worse, except that it produces a new commit
10:30:00 <Ezla> Mauke, I've had it open lately
10:30:06 <Ezla> althugh I havent seen every edge
10:30:29 <dons> Heffalump: everything by bos or me. something of a pattern.
10:32:11 <int-e> Heffalump: I was exaggerating, of course.
10:34:19 <dons> i'm so impressed by gitit. fast, clean, in happs. this is happs second age.
10:34:43 <jkr> Ahoy
10:35:28 <jkr> I'm having a problem with Network.Socket. I'm trying to recv something from a UNIX socket, but it' blocking forever.
10:35:41 <jkr> I tried to set a timeout with setSocketOption, but it seems to be broken
10:35:53 <dons> hmm.
10:36:06 <jkr> I found this: http://markmail.org/message/gi4wxwsbxo4wxbbc#query:haskell%20setSocketOption+page:1+mid:wb2l53ei3bzazhr4+state:results
10:37:18 <jkr> I'm not sure if that is really the problem though. The recv should get a response within max 1 sec
10:37:46 <Ezla> f :: (typeclassof (g Int Int) a) => a -> a
10:37:49 <Ezla> how do you do that?
10:38:00 <dons> where typeclassof is a variable?
10:38:04 <Ezla> no
10:38:17 <dons> and 'g' is free?
10:38:21 <dons> looks complicated.
10:38:24 <Ezla> so that it uses the same typeclass of g's signature
10:38:26 <Ezla> automatically
10:38:32 <Ezla> of g's result
10:38:45 <dons> highly unusual.
10:38:48 <Ezla> Why?
10:38:57 <mauke> what do you mean by "why"?
10:39:20 <dons> the constraint is just very strange.
10:39:22 <Ezla> mauke: Why --> "because in Haskell, we have a way that makes that totally unnecessary, EVER, and it is: "
10:39:47 <dons> you can do it, say by passing in a value of g's type and using annotations to say the types are the same
10:39:48 <mauke> Ezla: no, how is "why?" a useful question in response to "highly unusual"?
10:39:51 <Ezla> dons: typeclassof could also be a variable
10:39:56 <mattam> So you don't know the result of (g Int Int) here?
10:39:58 <Ezla> can I do it in that situation?
10:40:03 <dons> what are you trying to do though?
10:40:15 <dons> where's the code. this looks like a design problem.
10:40:17 <dons> ?hpaste
10:40:17 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:40:22 <Ezla> mattam: it would read (g Int Int)'s signature
10:40:23 <dons> heads are being scratched!
10:40:34 <dons> can you just leave the constraint off?
10:40:36 * Badger scratches dons' head.
10:40:38 <Ezla> yes, Dons
10:40:43 <dons> so do so :)
10:40:48 <Ezla> No but
10:40:51 <int-e> the function can't be useful :)
10:40:53 <Ezla> I want it to use the same as g
10:41:09 <dons> it could be more general though.
10:41:11 <Ezla> how do I classify function's use of typeclasses
10:41:15 <Ezla> so they all keep using the same one
10:41:19 <jkr> Any ideas on the recv problem?
10:41:20 <Ezla> Like:
10:41:24 <int-e> Ezla: it's not a useful contraint - you won't be able to do anything with thos 'a'.
10:41:26 <Ezla> I want a  {    } of typeclass a
10:41:29 <dons> jkr: i think you'll need to ask on the haskell-cafe@ list
10:41:30 <Ezla> and put various functions inside
10:41:33 <int-e> Ezla: you might just as well use an unconstraint id.
10:41:41 <dons> so that more eyes can see it (eyes that have played with recv recently)
10:41:53 <mattam> Uhoh. Well, you can read it just as well.
10:41:55 <int-e> Ezla: and you're still thinking about type classes wrong. They have very little to do with OO classes.
10:41:56 <dons> Ezla: the main way to construct those constraints is to use methods from g's clsas.
10:42:10 <Ezla> int-e: No, I'm not thinking of it like OO
10:42:13 <dons> but if you're not using any such methods, let it have the most general type possible
10:42:20 <Ezla> I'm thinking of it correctly.
10:42:20 <int-e> Ezla: for example, the set of classes that a type is an instance of is open, due to separate compilation of modules.
10:42:36 <int-e> Ezla: I wouldn't be so sure. Have you written any code that uses them?
10:42:36 <mattam> Ezla: Haskell guarantees that the instances used for the same constraint will always be the same, so you can copy it safely.
10:42:38 <gwern> 'Even if an enemy managed to sink all Euriskos sitting ducks, the program had a secret weapona tiny, unarmed extremely agile vessel that was, Lenat wrote, "literally unhittable by any reasonable enemy ship." The usefulness of such a ship was discovered during a simulated battle in which a lifeboat remained afloat round after round, even though the rest of the ships in the fleet had been destroyed. To counter opponents using the ...
10:42:40 <dons> Ezla: what do you gain by constraining it further? esp. if you're not using methods in the body of the function?
10:42:44 <gwern> ... same strategy, Eurisko designed another ship equipped with sophisticated guidance computer and a giant accelerator weapon. Its only purpose was killing enemy lifeboats.'
10:42:54 <gwern> eurisko sounds like a lot of fun; too bad the source is nowhere to be found
10:42:55 <Ezla> dons: composability
10:43:10 <dons> if its more general, it'll still be composable
10:43:17 <Ezla> dons: example?
10:43:23 <int-e> @src id
10:43:24 <lambdabot> id x = x
10:43:24 <dons> :t id
10:43:26 <lambdabot> forall a. a -> a
10:43:27 <int-e> example :P
10:43:38 <dons> > (id :: Int -> Int) 7
10:43:39 <lambdabot>   7
10:43:55 <dons> the compiler gives it the correct type based on all available type context information
10:44:07 <Ezla> int-e: Before you again say / assume I'm thinking of it in OO terms, the only thing they have to do with OO is that C++0x got typeclasses as concepts
10:44:07 <dons> but at the definition site, id has no constraints really
10:44:26 <neko> what would you guys suggest as a good introduction to the ">>" operator/function/stuff ? it's absolutely impossible to google that term
10:44:31 <dons> so your function should have the most general type at the definition site
10:44:37 <StoneToad> neko: monadic bind?
10:44:47 <dons> later, in use, it will pick up additional constraints which will be handled nicely
10:44:49 <hydo> Dear Crypto, please stop making ghc do "the impossible!" on my machine.  love, hydo
10:44:59 <dons> neko: `then`
10:45:10 <dons> neko: but you should look for monads
10:45:12 <int-e> neko: haskell monads tutorial
10:45:25 <StoneToad> oh woops, bind is >>=
10:45:32 <int-e> @src (>>)
10:45:32 <lambdabot> m >> k      = m >>= \_ -> k
10:45:32 <neko> ok, that helped, thanks
10:46:14 <neko> @src (>>=)
10:46:15 <lambdabot> Source not found. You speak an infinite deal of nothing
10:46:24 <neko> no cookie
10:46:37 <mauke> @src Maybe (>>=)
10:46:37 <lambdabot> (Just x) >>= k      = k x
10:46:38 <lambdabot> Nothing  >>= _      = Nothing
10:46:50 <Ezla> int-e: Perhaps you read:
10:46:52 <neko> thanks mauke
10:46:56 <Ezla> I want a {    } of typeclass a
10:47:06 <Ezla> to mean "like an OO class"
10:47:14 <Ezla> However, that's not at all what I was saying
10:47:17 <Ezla> I was saying:
10:47:26 <mauke> the enter key
10:47:27 <mauke> is not
10:47:30 <mauke> punctuation
10:47:43 <dons> heh
10:47:52 <Ezla> (Num a) => { f :: a -> a -> a; g :: a -> a -> a }
10:47:59 <newsham> ?faq can ghc do "the impossible!"?
10:47:59 <lambdabot> The answer is: Yes! Haskell can do that.
10:48:27 <Ezla> I dont know why people assume the "stupidest possible OO misunderstanding" by default
10:48:37 <Ezla> too little faith
10:48:47 <mauke> ask better questions
10:48:49 <int-e> Ezla: your question is very odd.
10:48:57 <mattam> Ezla: it's unnecessary, you can have both f and g taking the Num a constraint and they will share it automagically.
10:49:27 <Ezla> Mattam: For syntax reasons
10:49:36 <Ezla> I want want to write the word Num two times
10:49:50 <Ezla> How do you do that?
10:49:57 <mauke> just don't write type signatures
10:49:57 <Ezla> I want hierarchies of constraints
10:50:18 <Ezla> mauke: That avoids the whole thing and is another style, but I dont want to avoid it
10:50:32 <newsham> foo :: (Num a, Num b) -> a -> b -> c?
10:50:42 <newsham> (or do you need a and b to be the same)
10:50:46 <Ezla> no, f ang g
10:50:49 <mauke> f, g :: (Num a) => a -> a -> a
10:50:52 <mattam> Ezla: It's possible to parameterize a set of functions by such constraints in Coq's typeclasses for example, writing the constraint only once. I had supposed you could do it in Haskell's inner bindings...
10:50:55 <mauke> f = ...; g = ...
10:51:00 <Ezla> Mauke: wtf?
10:51:08 <Ezla> > f, g :: (Num a) => a -> a -> a
10:51:09 <lambdabot>   <no location info>: parse error on input `,'
10:51:25 <kpreid> Ezla: lambdabot doesn't take top-level declarations to eval
10:51:26 <mattam> Take g to be a -> a
10:51:49 <kpreid> you can indeed give multiple things the same signature that way
10:52:01 <Lemmih> > let {f, g :: Num a => a -> a -> a; f = (+); g = (-)} in (g 10 20, f 10 20)
10:52:02 <lambdabot>   (-10,30)
10:52:07 <Ezla> What about the scope way though?
10:52:09 <Deewiant> > let f, g :: Num a => a -> a -> a; f = (+); g = (-) in g 1 (f 1 2)
10:52:10 <lambdabot>   -2
10:52:16 <Deewiant> d'oh, too slow
10:52:17 <Ezla> What if I want nested layers of typeclass use
10:52:23 <mattam> But they have to share the exact same signature right?
10:52:42 <Ezla> (Num a, Enum b) => { f :: a -> b -> a;  g :: b -> a -> b }
10:52:43 <Ezla> like that.
10:52:59 <Ezla> They cannot use   "f,g"
10:53:10 <kpreid> Ezla: if you write that as a record, you can say that...
10:53:16 <Ezla> kpreid: /
10:53:33 <mauke> (f, g) = (...) :: (Num a, Enum b) => (a -> b -> a, b -> a -> b)
10:53:44 <Ezla> mauke: wtf. lol
10:53:46 <newsham> whats wrong with writing two lines   f :: (Num a, Enum b) => a -> b -> a; g :: (Num a, Enum b) => b-> a -> b ?
10:53:46 <Lemmih> Ezla: Write the signatures by hand or use CPP. There is no shorthand.
10:53:49 <int-e> mauke: err, no
10:53:54 <mauke> no?
10:54:02 <int-e> mauke: oh, wait. sorry.
10:54:13 <kpreid> mauke: hah! perfect!
10:54:19 <int-e> mauke: the (...) part would be lambdas. ugly :)
10:54:20 <mattam> mauke: almost. You have to group the defs.
10:54:21 <Holle_> could anybody help me? my problem: define Eq, Ord, Show, Read for MyType = Apple | Melone | Pear
10:54:29 <mauke> > let { (f, g) = (const, const id) :: (Num a, Enum b) => (a -> b -> a, b -> a -> b) } in f 1 2
10:54:30 <lambdabot>   Couldn't match expected type `b' against inferred type `a'
10:54:43 <newsham> holle: can you derive them or do you need custom definitions?
10:54:54 <mauke> > let { (f, g) = (const, const) :: (Num a, Enum b) => (a -> b -> a, b -> a -> b) } in f 1 2
10:54:55 <lambdabot>   1
10:55:09 <Holle_> deriving is not allowed.
10:55:11 <kpreid> you could write (f,g) = (f0,g0) where <new line> f0 = ... <new line> g0 = ...
10:55:12 <newsham> holle: do you have a specific question about it?
10:55:14 <mauke> int-e: or variables defined in 'where'
10:55:20 <newsham> (I take it this is a homework problem)
10:55:58 <Ezla> Is it possible for me to extend Haskell to get some variation of (Num a, Enum b) => { f :: a -> b -> a;  g :: b -> a -> b } ?
10:56:04 <Ezla> Can I change fundamental syntax?
10:56:12 <mauke> sure, write your own compiler
10:56:16 <Holle_> i started with Eq and it works: instance Eq MyType where
10:56:18 <Holle_> 	Apple == Apple = True
10:56:19 <Ezla> with a ghc ext and without an own compiler
10:56:19 <Holle_> 	Melone == Melone = True
10:56:21 <Holle_> 	Pear == Pear = True
10:56:22 <Holle_> 	_ == _ = False
10:56:39 <newsham> sounds like a good start.
10:56:50 <newsham> "show" should be even easier.
10:56:56 <Lemmih> Holle_: Don'
10:57:07 <Lemmih> t paste multiline code in the #haskell channel.
10:57:42 <rio> bad position for splitting that sentence :P
10:57:43 <mattam> Ezla: probably with
10:58:04 <mattam> template haskell you can do that?
10:58:10 <Ezla> but thats template haskell syntax
10:58:15 <Ezla> to extend base haskell
10:58:47 <Ezla> to use template haskell extensions, you have to use template haskell operators
10:58:54 <Ezla> not your own
10:59:35 <Lemmih> Ezla: No, you cannot extend the Haskell syntax.
11:00:34 <gwern> doesn't quasiquoting do that?
11:00:44 <Ezla> quasiquoting?
11:00:50 <Holle_> newsham: i opened a query
11:01:04 <Lemmih> gwern: Not in the way he wants it.
11:01:17 <int-e> http://darcs.haskell.org/ghc/compiler/parser/Parser.y.pp  doesn't look /that/ scary *ducks*
11:01:19 <PeakerWork> neko: did you get an answer to your question?
11:01:44 <PeakerWork> I think there's #haskell-overflow for these kind of overflow conversations?
11:02:46 <int-e> Ezla: 1) please don't private message people without invitation. 2) you expect others to not make assumptions about what you think. maybe it's time you do the same.
11:03:56 <jkr> Ahoy again
11:04:26 <jkr> How can I catch an EOF when recv'ing from a socket?
11:04:38 <jkr> hIsEOF doesn't seem to work on sockets in Haskell
11:04:46 <mauke> it'll probably throw an exception
11:05:04 <jkr> How can I catch it?
11:05:34 <mauke> Control.IO.Error
11:06:04 <Lemmih> jkr: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO-Error.html#v%3AisEOFError
11:06:16 <mauke> er
11:06:23 <mauke> where did that Control come from?
11:06:30 <mauke> it's System of course
11:06:31 <neko> I don't understand how >>= can enforce sequentiality by just passing the result to the second term, it seems to me that lazyness will just make it fail
11:06:32 <jkr> Thanks
11:06:49 <mauke> neko: it doesn't enforce sequentiality
11:07:03 <jkr> How can I change the prompt of ghci permanently?
11:07:08 <jkr> Is there a configuration file?
11:07:14 <mauke> jkr: ~/.ghci
11:07:19 <jkr> Thans
11:07:20 <neko> mauke : but : "in the IO monad, x >>= y performs two actions sequentially"
11:07:22 <jkr> *ks
11:07:33 <mauke> neko: oh yes, in IO it does
11:07:42 <neko> but how ?
11:07:50 <mauke> by performing x first, then calling y on the result
11:08:21 <neko> but there's no guarantee that x is going to be performed first, for example, if y does not use its input
11:08:29 <maltem> neko: IO is not defined directly in Haskell
11:08:32 <mauke> yes, there is
11:08:39 <mauke> x is always performed first
11:08:57 <mokus> neko: it sequences the effects, not necessarily the values
11:09:00 <newsham> neko: it is up to the primitives to exhibit some strictness if they want the IO sequencing to really order the side effects.
11:09:04 <PeakerWork> neko: The IO type implements >>= so it gets to say what the action order will be, the order is not determined by the evaluation order (not related to laziness)
11:09:09 <gwern> > let foo a _b = a in foo 1
11:09:10 <lambdabot>       Overlapping instances for Show (t1 -> t)
11:09:10 <lambdabot>        arising from a use of `...
11:09:14 <newsham> some IO actions are lazy and do not happen strictly in the order implied by the IO actions
11:09:17 <gwern> > let foo a _b = a in foo 1 0
11:09:18 <lambdabot>   1
11:09:23 <gwern> man, that's so weird
11:09:31 <newsham> for example, the whole file is not read when you do "xs <- hGetContents h"
11:09:49 <jdavis> is "error" the only non-pure function that can be called from a pure function?
11:09:56 <PeakerWork> gwern: why is that weird?
11:10:05 <mauke> jdavis: how is error non-pure?
11:10:05 <maltem> neko: how effects take place is implemented by the run-time system
11:10:07 <StoneToad> jdavis: error isn't pure?
11:10:10 <neko> maltem: ok, so IO is hardcoded in the compiler then
11:10:19 <mauke> neko: the runtime, but yes
11:10:22 <PeakerWork> neko: yep
11:10:29 <newsham> jdavis: unsafePerformIO, Debug.Trace.trace, etc.
11:10:29 <gwern> PeakerWork: I always thought the ignored-wildcard was just '_', not 'anything prefixed with "_"'
11:10:35 <jdavis> StoneToad: isn't the error itself a side-effect?
11:10:41 <neko> ok, that makes more sense now
11:10:45 <PeakerWork> gwern: I don't think that was the ignore wildcard above?
11:10:49 <mauke> jdavis: then f = f is also a side effect
11:10:57 <PeakerWork> > let foo a _b _b = a in foo 1 0 2
11:10:58 <lambdabot>       Conflicting definitions for `_b'
11:10:58 <lambdabot>      In the definition of `foo'
11:11:04 <StoneToad> jdavis: it's equivalent to non termination no?
11:11:08 <PeakerWork> gwern: its not ignored, its just a valid symbol in names
11:11:20 <gio123> Cale:hi
11:11:29 <gio123> Cale: hi
11:11:40 <mokus> StoneToad: non-termination can't be "caught" and hondled
11:11:42 <jdavis> mauke, StoneToad: but doesn't the behavior of error depend on when it's evaluated?
11:11:53 <mauke> jdavis: so does that of f = f
11:11:57 <gwern> PeakerWork: no, you can verify this in ghci with -Wall on
11:12:02 <StoneToad> jdavis: you mean the text of the error string?
11:12:16 <neko> but how is it possible to know what is a language construct (such as IO) and what is pure haskell ?
11:12:21 <mauke> StoneToad: in ghc, it can
11:12:21 <gwern> PeakerWork: if you write 'foo a b = a', -Wall complains about b being unusued. but if you replace b with _, or _b, the complaint disapears
11:12:22 <jdavis> mauke: can you explain that one to me? I don't understand the point.
11:12:26 <mauke> er
11:12:29 <mauke> mokus: in ghc, it can
11:12:39 <PeakerWork> gwern: ah, what a hack :-)
11:12:43 <neko> without learning the whole haskell spec by heart ?
11:12:47 <mokus> mauke: ghc solves the halting problem?
11:12:53 <mauke> mokus: parts of it :-)
11:12:54 <jdavis> StoneToad: yeah, if you have two stub functions which throw an error, and one is evaluated before the other, you'll get that error string.
11:12:55 <mokus> news to me
11:13:12 <StoneToad> mokus: I don't follow your comment about "in ghc, it can", it can what?
11:13:14 <PeakerWork> gwern: note you can use _blah values
11:13:15 <gwern> PeakerWork: I guess. it confused the hell out of me when I was workingon Yi - I assumed I was making typos
11:13:21 <Lemmih> neko: Why does it matter?
11:13:27 <StoneToad> mokus: nm, just noticed your correction
11:13:35 <StoneToad> GEH
11:13:39 <mauke> StoneToad: excellent tab error
11:14:01 <mokus> too many ms in here I guess
11:14:04 <StoneToad> hehe
11:14:12 <StoneToad> at least you're different colours
11:14:26 <StoneToad> xchat
11:14:50 <neko> Lemmih: in the case of the IO "version" of >>= it's important since if you mistake it for a real function then you'll do the same mistake I just did
11:14:53 <maltem> too many ms? cannot be
11:15:51 <PeakerWork> neko: >>= is just a pure/real function.. it just happens to return an IO type that describes the effects in a certain order
11:15:53 <Lemmih> neko: It isn't a real function?
11:16:55 <StoneToad> neko: there's nothing special about IO in the grand scheme of things, the opengl monad works (more or less) the same way for specifying rendering operations
11:16:59 <PeakerWork> neko: consider   data IO a where GetChar :: IO Char ; PutChar :: Char -> IO () ; Bind :: IO a -> IO b -> IO b
11:17:02 <maltem> neko: You can say that with IO, the effects are in the values (of type IO something), not the functions
11:17:18 <mokus> neko: perhaps if you think of >>= as a function strict in the "IO" type, similar to >>= being strict in the list structure when you're using it in the list monad?
11:17:52 <neko> PeakerWork: oki, and ?
11:18:36 <maltem> neko: Otherwise it's a fine rule of thumb that IO, seq, Array are special. That list enhances as you add pretty extensions and libraries
11:18:48 <neko> StoneToad: maltem : I have to admit I only partially understand this
11:18:53 <qwr> neko: ghc optimising IO don't make >>= semantically special
11:19:20 <qwr> neko: you can think about >>= as a code constructor
11:19:42 <newsham> neko: IO isn't entirely a "language construct".
11:19:47 <qwr> neko: you build an imperative structure, that will be given to the runtime as main
11:19:50 <neko> qwr: I see it as a pipeline constructor
11:20:03 <qwr> neko: and then the runtime interpretates it
11:20:15 <qwr> neko: of course, the ghc don't really work that way ;)
11:20:31 <jkr> Can someone please point to a good example on how to use try/catch?
11:20:32 <qwr> neko: but this can be used as abstraction
11:20:49 <maltem> neko: that's a fine analogy. you describe the pipeline (pure code), and the run-time system runs it (effects)
11:20:51 <qwr> neko: to avoid the lazyness/nonlazyness confusion...
11:21:23 <qwr> neko: yep, pipeline constructor works too
11:21:59 <neko> maltem: ok, so there's no semantic difference between say "f.g x" and g x >>= f ?
11:22:39 <qwr> neko: of course there is. function composition and >>= are different beasts
11:23:05 <Lemmih> neko: 'g x >>= f' doesn't actually execute anything. It creates an action which when executed will run 'g' and 'f'.
11:23:48 <qwr> neko: yeah. there are two steps - building the monad structure and running it
11:23:51 <Ezla> I'm still uncertain on how you do   f :: (Foo a, Bar a) => a -> a
11:24:00 <maltem> neko: g x >>= f is just the function (>>=) applied to the expressions (g x) and f
11:24:07 <Ezla> multiple constraints on 'a'
11:24:17 <Lemmih> Ezla: You just did it (:
11:24:20 <newsham> lemmih: (f.g) doesnt actually execute anything.
11:24:28 <Ezla> Lemmih: Oh hah
11:24:30 <Ezla> that's valid !?
11:24:33 <newsham> it creates a function that when executed will evaluate g then f.
11:24:39 <Lemmih> newsham: I think he meant '(f.g) x'.
11:24:42 <Deewiant> Ezla: yes, that's valid.
11:24:44 <qwr> neko: the first is done when evaluating main (lazyly). the second one happens after that. of course, since main is evaluated lazyly, parts of it's evaluation will mix with the running/interpretation
11:24:48 <Ezla> oh.
11:24:48 <maltem> neko: That's why your examples are different - those are probably different functions
11:24:51 <Ezla> Great
11:24:53 <neko> I can feel my neurons disintegrating
11:25:06 <cknapp> neko: Haskell does that...
11:25:19 <Lemmih> newsham: Otherwise I don't see how 'f.g x' is related to 'g x >>= f'
11:25:42 <Ezla> Is this good too?
11:25:51 <Ezla> f :: (Foo a, Bar a, Bar b) => b -> a
11:26:02 <Lemmih> Perfectly valid.
11:26:05 <neko> but yes I meant (f.g) x, I'm not yet at ease with priorities
11:26:47 <Trafalgard> is there actual good documentation anywhere?
11:26:53 <mokus> neko: rule 1 on priorities is that nothing trumps function application
11:27:02 <mokus> except parens of course
11:27:16 <Trafalgard> like, say, this doesn't explain how to use Maybe at all --> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Maybe.html#v%3AJust
11:27:18 <newsham> (f.g) x = let y = g x in f y;   g x >>= f = monadlet y = g x in f y (if there was a "monadlet")
11:27:19 <cknapp> Trafalgard: Depends on your definition of good... Any documentation is undecipherable until you know a little bit about the language
11:27:30 <cknapp> On the other hand, I find the documentation rather helpful
11:27:33 <newsham> g x >>= f = do { y <- g x; f y }
11:27:45 <newsham> neko: they're similar but not the same thing
11:28:02 <Trafalgard> I'm trying to do the "Define a tree type that has only one constructor, like our Java example. Instead of the Empty constructor, use the Maybe type to refer to a node's children." exercise on http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html
11:28:16 <Trafalgard> and it sort of somewhat explained Maybe but not how to do anything remotely like that with it
11:28:45 <neko> newsham: I just can't understand why they're different
11:28:46 <qwr> neko: (f . g) x is same as f (g x). g x >>= f means that g x results in monadic value, where the "boxed" value is taken out of monad and given to f, which returns new monadic value. and this happens only when the monadic value resulting from >>= is runned.
11:28:49 <Trafalgard> so I tried messing around with it and stuck it inside the Tree declaration and just got errors
11:29:05 <newsham> neko: they're different in that one is "let" and the other is "monadlet" ;-)
11:29:23 <cknapp> Trafalgard: give me a minute.... I need to do something, and I'll be back.
11:29:25 <StoneToad> Trafalgard: so like data MyTree a = MyTree (Maby a) (Maby b)?
11:29:32 <StoneToad> maybe*
11:29:48 <Trafalgard> I'm probably doing it wrong, hold on
11:29:54 <StoneToad> urr, both of those should be Maybe a btw
11:29:54 <newsham> neko: they're also different in that (f.g) x is completely defined, and g x >>= f has different behaviors depending on how (>>=) is defined
11:30:05 <Trafalgard> hmm.
11:30:21 <Trafalgard> The original tree had data Tree a = Node a (Tree a) (Tree a)
11:30:22 <newsham> > (show . (+1)) 5
11:30:24 <lambdabot>   "6"
11:30:28 <StoneToad> I'm pretty sure I saw something just like you're asking about in one of the datatype tutorials
11:30:30 <Trafalgard> so I changed them from (Tree a) to (Maybe Tree a)
11:30:37 <neko> newsham: that distinction would be true of any function defined for a type class though no ?
11:30:39 <mauke> Trafalgard: (Maybe (Tree a))
11:30:39 <Trafalgard> and it went Kind error: `Maybe' is applied to too many type arguments
11:30:44 <Trafalgard> okay
11:31:05 <Trafalgard> aha
11:31:16 <qwr> > Just 5 >>= (return . (+1))
11:31:18 <lambdabot>   Just 6
11:31:18 <StoneToad> Maybe Tree a ---> ((Maybe Tree) a)
11:31:26 <newsham> neko: ok.
11:31:55 <neko> qwr: I can understand what you mean but you'll have to define what the adjective "monadic" means :)
11:32:17 <qwr> neko: like IO Int or Maybe Int
11:32:46 <byorgey> a monadic value is a value of type  m a,  where m is a Monad  and a is any type
11:33:03 <newsham> :)
11:33:44 <neko> that's cheating, you're defining monads recursively
11:34:18 <byorgey> neko: sorry, I came in the middle =)
11:34:25 <byorgey> neko: what are you having trouble understanding?
11:34:49 <neko> I still can't grasp the practical interest of having a "monad" thing which nobody seems to be able to define without invoking that same "monad" :)
11:35:59 <neko> I'm certain that it has some though
11:36:27 <qwr> neko: monad is like a box that hides something in it. and it has interpretator that knows how to poke in the box. :) >>= makes a box transformer, that tells to interpretator "take old value out and give it to the function"
11:36:53 <qwr> neko: but the result is still a box.
11:37:18 <RayNbow> http://www.haskell.org/haskellwiki/Monads_as_Containers
11:37:27 <Baughn> > [1..4]  >>= (+3)
11:37:28 <lambdabot>       No instance for (Enum [b])
11:37:28 <lambdabot>        arising from the arithmetic sequence ...
11:37:34 <mauke> needs more return .
11:37:46 <Baughn> ..at least you didn't say "moar"
11:37:48 <neko> ok, that makes sense in relation with the IO monad, the box is the outside world, but would one be able to define monads without explicit hardcoding in the compiler ?
11:37:58 <neko> (to qwr)
11:38:21 <mauke> Baughn: no, "moar" is used when directly requesting more, not in conjunction with "needs"
11:38:23 <qwr> neko: yes. they just can't interact with the outside world on they own
11:38:31 <qwr> s/they/their/
11:38:33 <arw> neko: most monads can be implemented without the compiler knowing. but for IO you need a compiler that knows about it.
11:38:34 <hydo> RayNbow: thanks for that link, it's starting to make sense now.
11:38:48 <Baughn> mauke: ..that you know this, scares me.
11:39:09 <RayNbow> > [1..4] >>= needs moar return (+3)
11:39:10 <lambdabot>   [4,5,6,7]
11:39:12 <cknapp> Baughn: I concur....
11:39:24 <neko> ok, so a monad is nothing else than a class of higher order functions ?
11:39:28 <RayNbow> @undefine needs
11:39:29 <RayNbow> @undefine moar
11:39:31 <RayNbow> :p
11:39:37 <mauke> RayNbow: @undefine doesn't take arguments
11:39:41 <RayNbow> oh
11:39:49 <byorgey> neko: right. if you want to know what a monad "is", the real answer is "an abstract structure with certain operations that satisfy certain algebraic laws".  if you want to know why that particular structure is a useful pattern for organizing computation, you just have to start looking at examples.
11:40:01 <RayNbow> mauke: @undefine undefines everything?
11:40:09 <qwr> neko: usually monads are more like some data types
11:40:12 <byorgey> neko: one *particular* use for this structure is in organizing/separating effectful operations.
11:40:13 <mauke> RayNbow: yes
11:41:06 <newsham> its useful for (among other things) organizing programs into one part that yields a result that is used by the other part.
11:41:08 <neko> byorgey: with the help of the runtime/compiler
11:41:13 <byorgey> neko: and yes, in Haskell the Monad type class (and many particular monads, like the list monad, Maybe, Cont, etc.) are implemented just as libraries, with no special support from the compiler.
11:41:18 <neko> (for that particular use)
11:41:31 <byorgey> neko: right, IO is the only thing that needs special runtime/compiler support.
11:41:33 <byorgey> yup.
11:41:59 <newsham> ie:    (program with side effect) >>= \intermediateValue -> (program that uses intermediate value and makes use of the earlier side effects)
11:42:00 <byorgey> there is also special compiler support for do-notation, which is just syntactic sugar for the monad operations.
11:42:37 <neko> byorgey: yes, I understand that, since do dictates the sequence of events
11:43:09 <qwr> > do { x <- [1..3]; return (x * 2) }
11:43:11 <lambdabot>   [2,4,6]
11:43:46 <qwr> neko: works since list is monad
11:43:59 <newsham> > runState (do {x <- get; put (x+1); y <- get; return (y*5)}) 10
11:44:01 <lambdabot>   (55,11)
11:45:52 <neko> byorgey: I definitely like that "a particular structure which is a useful pattern for organizing operations" definition
11:46:05 <newsham> with the State monad, the do-block glues together a big "State" program, and the "runState" interpretter runs that program
11:46:16 <newsham> and its all written in haskell with no special magic in the compiler to support it
11:46:31 <byorgey> neko: yup.  there are many metaphors which are helpful intuition for thinking about monads, but none of them really captures what a monad *is*
11:46:34 <dons> ?users
11:46:34 <lambdabot> Maximum users seen in #haskell: 568, currently: 555 (97.7%), active: 27 (4.9%)
11:46:38 <byorgey> for that you just have to go to the definition =)
11:46:42 <newsham> someone just wrote the definitions of (>>=) and return for the State monad, and wrote definitions for get, put and runState
11:47:15 <newsham> byorgey: "no one can be told what the Monad is.  You have to see it for yourself." ?
11:47:26 <byorgey> hehe, that's one way of putting it =)
11:48:10 <newsham> shoulda took the blue pill :(
11:48:22 <StoneToad> there is no monad?
11:48:30 <qwr> neko: yes, the thing that makes monads somewhat hard to get, is that they are just a abstract pattern for organizing computations, defined by monad laws (that are inherited from mathematics)
11:48:31 <newsham> if you see the monad on the road, kill the monad.
11:49:49 <qwr> newsham: :)
11:50:13 <cknapp> newsham: How do you kill the monad, without side-effects?
11:50:31 <cknapp> please ignore the comma...
11:51:23 <qwr> cknapp: const () monad ?
11:52:01 <cknapp> qwr: Hmm...
11:52:20 <neko> but if I understand correctly, >>= can be defined differently depending on the types of its parameters ?
11:52:34 <qwr> neko: that's the point of it :)
11:53:05 <qwr> neko: every monad defines it's own >>=
11:53:38 <cknapp> StoneToad: Actualy, I think it's "There is no state."
11:53:43 <neko> but semantically they're still supposed to be equivalent ?
11:53:48 <StoneToad> cknapp: very nice!
11:53:50 <Trafalgard> <cknapp> newsham: How do you kill the monad, without side-effects?
11:53:55 <Trafalgard> we haven't invented phasers yet
11:54:14 <StoneToad> cknapp: I'd put that as my new email sig, but I think it would freak out all my non techi friends
11:54:55 <qwr> nekoniaow: they are supposed to act like a monad together with monads definition of return ;)
11:54:59 <cknapp> StoneToad: Anarchy, Monads... they're sort of the same, right?
11:55:17 <mauke> Monarchy
11:55:26 <Toxaris> neko: no they are not equivalent, but there are some laws which >>=, >> and return have to follow for every monad
11:55:50 <cknapp> mauke: nice.
11:55:54 <Toxaris> neko: an easy example is that (a >> b) should always be the same as (a >>= const b), no matter which monad the >> and >>= belong to
11:55:58 <StoneToad> cknapp: hardly, monads are the kings of order!
11:56:20 <StoneToad> and mauke, that was a horrible horrible pun
11:56:28 <Toxaris> neko: that's similiar to how for all numeric types, (a + 0) should be the same as (a), independently of whether we are talking about Int, Integer, ...
11:56:55 <mokus> StoneToad: "kings of order" wasn't a horrible, horrible pun?
11:56:55 <nekoniaow> Toxaris: yes, I am just reading something like this in "a gentle introduction to haskell: aboutmonads" :)
11:57:01 <mokus> ;-)
11:57:09 <StoneToad> mokus: I didn't notice the pun...
11:57:21 <StoneToad> oh right, monarchy, I hadn't actually read the line when I typed it
11:57:35 <dons> interesting. http://www.reddit.com/r/programming/comments/7hymd/f_from_a_haskell_perspective/
11:57:42 <StoneToad> it was an accident, honest :)
11:57:45 <leimy> dons: I have to say... this book is really great.
11:57:54 <leimy> you all did a great job
11:57:56 <dons> leimy: yay!
11:58:10 <dons> now, write some code! :)
11:58:25 <mokus> StoneToad: the monad forgives you, and you may kiss its ring
11:58:42 <StoneToad> leimy: which book
11:59:07 <leimy> Real World Haskell
11:59:09 <leimy> dons: I did
11:59:15 <StoneToad> ahh, I'm waiting for my copy to ship
11:59:18 <cknapp> @where RWH
11:59:19 <leimy> I took my ugly Bowling score code stuff
11:59:19 <lambdabot> http://book.realworldhaskell.org/read/
11:59:22 <nekoniaow> Toxaris: I actually recall now having read something similar in "the haskell school of expression" about type classes I think (not sure)
11:59:36 <Toxaris> wasn't "monad" a name for elementary thoughts or concepts or something like that in the 17th century?
11:59:38 <leimy> and then figured out how to make it pure using stuff like interact and point free styles
11:59:43 <nekoniaow> Toxaris: I mean the notion of "laws" that the code ought to respect but the compiler can't enforce
12:00:18 <StoneToad> leimy: sounds neat, is the code up somewhere?
12:00:42 <nekoniaow> I have to thank you guys for the neural training I just received :)
12:00:57 <leimy> yeah I'm about to post it.
12:01:16 <leimy> http://hpaste.org/12814
12:01:26 <leimy> ballList and showBalls (terrible name) are point free :-)
12:01:49 <leimy> but they show how you can write an interact loop, still get line based input as if you were asking for it line by line, and do stuff with it.
12:02:09 <leimy> and then a lot of your program doesn't have to be in the IO monad.
12:02:16 <leimy> interact is definitely awesome.
12:03:07 <mlesniak> leimy: s/interact/Haskell/ ;-)
12:03:11 <leimy> yes
12:03:44 <nekoniaow> if I sum up what I learned, if I want to understand what `Control.Exception.catch` (\e -> h >> throwIO e) does, I'll have to look for the definition of >> in the exception monad(s) right ?
12:03:48 <leimy> interact is just totally living up to it's name for me.  It's like saying "I want this IO behavior, and to deal with the data in an "event" style"
12:04:01 <leimy> er its not it's
12:04:06 <leimy> good thing I don't write books.
12:04:24 <nekoniaow> wait, this is nonsense
12:04:42 <Ezla> How do you    f :: (Foo a, not Bar a) => a -> a   ?
12:04:49 <newsham> neko: you can sidestep that and just think abstractly of ">>" being like a semi-colon in C.
12:05:06 * leimy has to run...
12:05:08 <flux> leimy, I don't know.. I think a more suitable name would be 'react', because there's no way to carry information between function invocations
12:05:09 <newsham> ie. "it catches an exception, binds it to e, calls h, then throws e again"
12:05:15 <Ezla> How do you    f :: (Foo a xor Bar a) => a -> a   ?
12:05:22 <mokus> Ezla: haskell can't do that
12:05:25 <Ezla> why not?
12:05:29 <Toxaris> nekoniaow: yes you have to, but that >> is always from the IO monad
12:05:34 <Ezla> Are you sure?
12:05:35 <newsham> the ">>" is just the "and then" of that description
12:05:36 <qwr> nekoniaow: catch is in IO :)
12:05:36 <mokus> because it belives in the openness of the world of typeclases
12:05:46 <mokus> a future user cat declare instance Bar a
12:06:07 <Ezla> mokus: so ?
12:06:14 <mokus> causing an expression typed based on "not Bar a" no longer valid
12:06:28 <mokus> it would be unsound
12:06:36 <nekoniaow> newsham: which means guessing that the semantics of >> in that case are the same as for the IO monad
12:06:56 <Ezla> mokus: How would that break  f :: (Foo a xor Bar a) =>     ?
12:07:03 <newsham> ?type Control.Exception.catch
12:07:04 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
12:07:08 <Ezla> You can already do OR
12:07:08 <mokus> the same way
12:07:12 <Ezla> or rather
12:07:13 <newsham> you can assume IO since catch does :)
12:07:14 <Ezla> you can do AND
12:07:16 <mokus> XOR is OR and not AND
12:07:17 <Toxaris> nekoniaow: no guessing involved. This *is* the >> from IO, so it has the semantics of the >> of IO
12:07:23 <qwr> nekoniaow: they are since catch lives in IO
12:07:25 <Ezla> mokus: No, I mean
12:07:32 <nekoniaow> ah
12:07:35 <Ezla> (Foo a, Bar a)  // can already do AND
12:07:39 <Ezla> so why not xor?
12:07:45 <mauke> Ezla: because that doesn't make sense
12:07:50 <mokus> Because XOR has a Not-AND part
12:08:04 <StoneToad> Ezla: how is xor useful for in typeclasses?
12:08:13 <nekoniaow> true http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#4
12:08:15 <StoneToad> s/for//
12:08:16 <Peaker> Ezla: you don't know that "a" has Foo's methods, and you don't know that it has Bar's methods, so what do you know?
12:08:28 <qwr> nekoniaow: and especially since catch argument results in IO action.
12:08:29 <Ezla> (not Foo a)
12:08:29 <Toxaris> Ezla: because a formula which contains XOR is not monotone in the sense that, when I add more instances, it can become invalid even if it was valid with less instances
12:08:40 <Toxaris> Ezla: that's totally confusing: you add code, and existing code breaks => bad
12:09:03 <Toxaris> Ezla: so all rules are carefully formulated so that you can add whatever you want without breaking what you already have => good
12:09:06 <Ezla> Ok, so whats wrong with OR ?
12:09:14 <Ezla> (Foo a or Bar a) =>
12:09:16 <Peaker> Ezla: "AND" is useful because you know it has both the methods of Foo and Bar,  any other combination does not guarantee any method
12:09:28 <Peaker> Ezla: the whole point of having the context, is making some methods available
12:09:30 <StoneToad> Ezla: can you give an example?
12:09:39 <mauke> Ezla: what's the use case?
12:09:49 <Ezla> I think Or would break nothing
12:09:52 <Peaker> Ezla: (Foo a or Bar a) does not let know any method exists
12:09:56 <Ezla> I see what you're saying about the others though
12:10:02 <Heffalump> Ezla: feel free to implement it
12:10:02 <mokus> Ezla: or wouldn't break anything but it gives you no power
12:10:06 <Peaker> Ezla: So it is pointless
12:10:13 <Ezla> How is it pointless?
12:10:17 <Peaker> Ezla: its a semantically-void statement
12:10:20 <Toxaris> Ezla: I think you are right, Or wouldn't break anything *for empty classes*, but if the classes have methods, it makes a difference which one is chosen
12:10:22 <mauke> <Peaker> Ezla: (Foo a or Bar a) does not let know any method exists
12:10:23 <StoneToad> <Ezla> (Foo a or Bar a) => -- the only way I see this making sense is if Foo and Bar are really both subclasses of Baz, but then you should just use Baz directly
12:10:27 <Toxaris> Ezla: so how do you decide that?
12:10:35 <nekoniaow> qwr: ok; that's logical, its type is determined at least partially by that of throwIO
12:10:39 <Ezla> Not let know any method exists...
12:10:42 <Ezla>  I don't understand
12:10:46 <Heffalump> well, if you could conditionalise code on which class is present, you could use it
12:10:48 <Peaker> Ezla: does not let us know...
12:10:51 <qwr> nekoniaow: that is one interesting thing in haskell - function return type affects what function does. catch argument is a function which return IO a, so if the function value is result of >>, then the >> must be IO's >>
12:11:02 <Heffalump> but typically typeclasses *are* the mechanism for run-time type-based dispatch
12:11:04 <Peaker> Ezla: The meaning of (Blah a) =>    is that the "a" type has certain methods (from Blah) available
12:11:13 <Ezla> peaker: what Heffalump said
12:11:28 <Ezla> However.
12:11:28 <StoneToad> Ezla: also, isn't this the same question you asked a while earlier today?
12:11:32 <Peaker> Ezla: if you add conditionals on type-classes, then you totally change what type-classes are
12:11:34 <Toxaris> Ezla: lets say class Foo where foo : a -> Int, and class Bar where bar : a -> Int, so the point of Foo and Bar is to provide foo and bar, but with (Foo a OR Bar a) => a, you can't neither call foo a, nor bar a, so what's the point?
12:11:43 <mokus> Ezla: the critical thing is that without reflection (which haskell doesn't have), Or does't let you know which one you actually have
12:11:44 <Heffalump> Ezla: so feel free to implement it.
12:11:44 <Ezla> Who says you shouln't have two typeclasses which implement the same exact methods?
12:11:51 <Peaker> Ezla: and there's no need to do that, because there are other mechanisms to do that already
12:11:55 <Heffalump> Ezla: what's the point?
12:12:00 <Ezla> But you use them by differnet names for the sake of unique identities
12:12:01 <nekoniaow> qwr: ok
12:12:02 <Peaker> Ezla: that's what base classes are for
12:12:33 <Ezla> Wait up...
12:12:35 <nekoniaow> I can understand that types are extremely powerful, but I lack the theoretical foundations
12:12:35 * Heffalump sees what the complains about Ezla earlier were about now
12:12:44 <Heffalump> s/complains/complaints/
12:12:56 <Ezla> You have Foo, and Bar... Foo and Bar each have the same methods, but they implement them differently
12:13:10 <Toxaris> Ezla: ok, so you want class Foo a where foo : a -> Int; class Bar a where foo : a -> Int; test :: (Foo a OR Bar a) => a -> Int; test = foo?
12:13:11 <Peaker> Ezla: no, classes don't define implementation, just interfaces
12:13:12 <Ezla> So you want a function constrained to either of them
12:13:16 <Ezla> it doesn't matter which one resolves
12:13:28 <Ezla> Peaker: I know
12:13:35 <Peaker> Ezla: Are Foo and Bar classes or types?
12:13:37 <mauke> Ezla: what if both do?
12:13:41 <Ezla> Peaker: rather, the types of that typeclass implement them different
12:13:56 <Peaker> Ezla: that's not the right way to do it
12:14:04 <mokus> Ezla: you can achieve something like that with some of the extensions in ghc
12:14:08 <Peaker> Ezla: you don't duplicate class code just so types implement it differently, you use newtype
12:14:11 <Ezla> mokus: which?
12:14:15 <dons> this is the first good comparison of haskell to F# from an expert's perspective, guys, http://www.reddit.com/r/programming/comments/7hymd/f_from_a_haskell_perspective/
12:14:16 <qwr> nekoniaow: fortunately you can most of the time write working haskell code without thinking about those foundations :)
12:14:19 <dons> very interesting
12:14:25 <mokus> Ezla: by defining a new class Baz, with instance Foo a => Baz a and instance Bar a = Baz a
12:14:37 <Peaker> Ezla, mokus, Toxaris, Heffalump, can we move it to #haskell-overflow ?
12:14:38 <mauke> mokus: ouch
12:14:39 <mokus> actualyl, I'm wrong
12:14:45 <mokus> that's an overlap
12:15:07 * Heffalump has lost interest in the topic due the above realisation
12:15:36 <Heffalump> dons: I was about to say that we at Credit Suisse have plenty of experience of F# from a Haskellers perspective :-)
12:16:02 <nekoniaow> qwr: doesn't one miss huge expressivity gains though if he doesn't grasp reasoning on types ? this is what I'v understood by reading various articles on types and haskell (by which I mean I didn't understand the reasoning, but that there were huge advantages in these reasonings)
12:16:28 <dons> Heffalump: right. but you don't blog about it!!
12:16:41 <dons> Heffalump: i visited the NY team last week. very impressive.
12:16:44 <qwr> nekoniaow: yes, it is _useful_ to know how it works, but you don't have to learn everything at once
12:16:46 <Heffalump> "we" i.e. including Neil even though he's not there any more.
12:17:02 <Heffalump> dons: yeah, I heard.
12:17:02 <dons> Heffalump: and i assume he gathered that experience over the summer with you
12:17:21 <qwr> nekoniaow: i don't know the haskell typesystem corner cases either
12:18:03 <Ezla> when you say
12:18:05 <Ezla> "subclasses"
12:18:11 <Ezla> <StoneToad> <Ezla> (Foo a or Bar a) => -- the only way I see this making sense is if Foo and Bar are really both subclasses of Baz,
12:18:15 <Ezla> what does that mean?
12:18:28 <mauke> Peaker: apparently not :(
12:18:38 <qwr> nekoniaow: and i suspect that most haskell users don't understand the typesystem 100%
12:18:38 <nekoniaow> qwr: you know enought to help me, that seems a lot to me :)
12:19:03 <Peaker> Ezla: The discussion is way overflowed, please move it to #haskell-overflow ? Its repetative...
12:19:28 <Cale> qwr: Depends on what you mean by "the Haskell typesystem"
12:19:42 <Cale> and "understand" ;)
12:20:01 <qwr> Cale: all the rules that the typeinferencer follows for example?
12:20:11 <Cale> The Haskell 98 typesystem is fairly simple.
12:20:34 <Cale> There are a lot of extensions in GHC with fairly complicated rules and interactions though.
12:21:21 <qwr> Cale: ghc certainly does some magic that i don't understand. and for example I have never bothered to understand, why exactly haskell98 has some restrictions (like the monomorphism one)
12:21:48 <MyCatVerbs> Cale: oh gods rank 2 types fill me with woe. :)
12:21:53 <cknapp> qwr: "The monomorphism one"?
12:22:17 <Cale> Oh, the MR is basically there because some people expect pattern bindings to only ever be computed once
12:22:42 <Cale> That is, if you write  foo = ...  and it's not a function, you expect it to be computed once and stored thereafter.
12:23:07 <Cale> But typeclasses secretly make things into functions whose results won't be cached in this way.
12:23:35 <Cale> So some people on the H98 committee thought it would be a good idea to try and prevent that from happening, rather than just making it a compiler warning.
12:24:31 <Cale> For example, suppose I write...
12:24:46 <Cale> big = factorial 10000
12:25:14 <Cale> One might expect that if my program used 'big' in more than one place, since it's a constant, it's not recomputed.
12:25:32 <Cale> But suppose the inferred type is   big :: (Num a) => a
12:25:55 <qwr> Cale: yes i can see it. but its logical that for different types there is different value...
12:26:03 <Peaker> Cale: these mini-tutorials you give on #haskell are great, do you have a little faq/blog where they can be found?
12:26:27 <Cale> Yes, it's just somewhat unexpected at times, which is why it should be a warning, but they went too far in making it an error.
12:26:42 <Cale> Peaker: not really...
12:27:17 <Peaker> Cale: If you use <Tut> </Tut> tags or such, maybe it'll be greppable in the logs later at least :-)
12:27:30 <Cale> http://cale.yi.org/ -- there are a few links to things I wrote here
12:27:59 <Cale> Unfortunately, you can't sort reddit comments by score anymore, or I'd just get you to do that for my user.
12:28:48 <Cale> http://www.reddit.com/user/cgibbard/
12:30:11 <nekoniaow> so if I sum up what this means : onError :: IO a -> IO b -> IO a
12:30:12 <nekoniaow> onError a h = a `Control.Exception.catch` (\e -> h >> throwIO e)
12:30:12 <nekoniaow> -> a and b are two functions which modify the "world" box of the IO monad, onError calls a, if it raises an exception, it calls the lambda function which in order calls the b function then re-raises the exception. So this is most probably an exception logging mechanism.
12:30:30 <StoneToad> Cale: ooh so THAT's what that webpage was trying to say about the monomorphisim restriction
12:30:35 <Heffalump> do you mean a and h?
12:30:51 <StoneToad> and wow, monomorphism isn't in my spellcheck dictionary
12:30:58 <nekoniaow> I mean onError, but I'm wrong since the lambda doesn't pass e to h
12:32:08 <Heffalump> I mean "do you mean a and h, not a and b before "are two functions"
12:32:14 <nekoniaow> and this still doesn't explain me why ghc finds the type of e to be ambiguous since it's imposed by throwIO to be an Exception
12:32:31 <Cale> StoneToad: It unfortunately has more than one meaning. It's both the opposite of polymorphism, and the general term for a structure-preserving map which has a left inverse.
12:32:32 <Heffalump> it's probably a "finally" mechanism, not a logging mechanism
12:32:40 <nekoniaow> Heffalump: oh, true, I meant a and h
12:32:46 <Heffalump> are you sure throwIO forces it to be an Exception in 6.10?
12:32:59 <Cale> nekoniaow: a and h are not functions
12:33:14 <Heffalump> well, they are in the way that everything in Haskell is a function
12:33:15 <nekoniaow> Heffalump: http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#2 seems to imply it no ?
12:33:23 <Heffalump> and if you think of IO as State RealWorld then they are too
12:33:45 <Cale> Not everything in Haskell is a function.
12:33:45 <Heffalump> nekoniaow: no, it says that if e is a member of Exception then it can be raised
12:33:49 <Heffalump> Exception there is a class, not a type name
12:33:50 <StoneToad> Cale: I just meant that my irc client's spell checker didn't recognize monomorphisim as a word
12:33:58 <nekoniaow> damn
12:34:01 <nekoniaow> thanks :)
12:34:02 <Cale> and State RealWorld is a horrible way of explaining IO :)
12:34:21 <StoneToad> it recognizes polymorphism though
12:34:29 <Heffalump> I think it's a very good way :-p
12:34:38 <mapreduce> StoneToad: monomorphism is the correct spelling.
12:34:47 <mapreduce> monomorphisim is less so.
12:35:12 <Heffalump> nekoniaow: I'm pretty certain that onException is the right way to implement onError now.
12:35:17 <nekoniaow> Heffalump: and you're right that's probably a finally mechanism, you said that when I asked my first question, but I couldn't decipher why at that time :)
12:35:40 <nekoniaow> Heffalump: I trust you, I just want to understand why :)
12:35:40 <StoneToad> mapreduce: it doesnt recognize it anyway :)
12:35:46 <Heffalump> sure :-)
12:35:49 <Cale> The problem is that in order for State RealWorld to work, either (->) must have effects encoded in it somehow (which it's not supposed to, but at lower levels, in GHC this is what happens), or else RealWorld has to be an impossible and ill-defined type.
12:35:51 <StoneToad> I should probably add it though
12:36:12 <Heffalump> unfortunately onException seems not to have any docs there.
12:36:27 <Peaker> Anyone has any idea how long the Class Aliases proposal has existed?
12:36:28 <Cale> A much easier way to think of (IO t) values is that they're simply descriptions of steps to be carried out which would result in a value of type t.
12:36:30 <Heffalump> but if you google a bit for the discussion surrounding the new Exception library you'll probably find an explanation
12:37:03 <Heffalump> RealWorld is an imaginary type that would encapsulate the entire state of the world, were such a thing possible on a computer that itself lives in the real world.
12:37:06 <Cale> Like the source code, or abstract syntax for an imperative programming language.
12:37:24 <Heffalump> it's nothing to do with -> having effects encoded in it.
12:37:30 <Cale> Heffalump: It is in GHC.
12:37:41 <Cale> Note the 'either' there.
12:37:44 <Heffalump> it has to do with being able to (supposedly) treat the state of the world like any other value.
12:38:01 <Heffalump> it's an unimplementable type, but it's conceptually not hard to understand, IMO
12:38:11 <Cale> That model also doesn't admit concurrency very well.
12:38:25 <Heffalump> you have to give RealWorld some structure then
12:38:49 <Heffalump> the "defines an imperative language" idea is a good one too that I'm also happy to use sometimses.
12:38:52 <Cale> I'm not saying it's completely unworkable, I think it's really just very confusing to beginners.
12:39:13 <Cale> It's much easier to think of an IO action as just a description of some stuff to do.
12:39:15 <Heffalump> I think the set of commands is more confusing to beginners, because it becomes hard to understand where decisions get taken.
12:39:43 <Cale> Personally, I think of them somewhat like:
12:39:46 <Cale> data IO a where
12:39:56 <Cale>   ReturnIO :: a -> IO a
12:40:04 <Cale>   BindIO :: IO a -> (a -> IO b) -> IO b
12:40:15 <Cale>   PutStr :: String -> IO ()
12:40:22 <Cale>   GetLine :: IO String
12:40:26 <Cale> etc.
12:40:42 <Cale> (for all the primitive IO actions)
12:41:03 <Heffalump> that's all very well, but once you have a function embedded in BindIO it becomes quite hard to see it as "just a sequence of commands to run"
12:41:05 <nekoniaow> Cale: I actually find it easier to understand IO a , as an operation which modifies the world-outside-of-the-program
12:41:08 <Cale> The Haskell runtime then just reads this description and actually carries out the steps.
12:41:22 <Ezla> So what's desugaring?
12:41:38 * Heffalump rarely sees eye-to-eye with Cale on philosophical or pedagogical things of this nature
12:42:02 <Cale> Ezla: Translating some syntax feature into simpler Haskell code which doesn't involve it.
12:42:10 <Ezla> ex. ?
12:42:21 <kpreid> Heffalump: Let's say it's a command to "Ask me what to do next"...
12:42:27 <Cale> Heffalump: Well, okay, sequence wasn't really the word to use. Abstract syntax for a program is more like it.
12:42:50 <Ezla> what is a common thing getting desugared
12:42:53 <Peaker> @undo do { a; x<-b ; c }
12:42:53 <lambdabot> a >> b >>= \ x -> c
12:42:54 <dons> haha
12:42:55 <dons> !
12:42:57 <Heffalump> kpreid: sure, but then you don't have such a clean separation between Haskell and the IO interpreter.
12:42:58 <roconnor> why is mapM a space leak in ``do mapM f xs; return 1'' ?
12:42:59 <dons> "haskell it is" --> http://markwatson.com/blog/2008/12/haskell-it-is.html
12:43:02 <Peaker> Ezla: That's a desugaring of "do"
12:43:03 <dons> thanks to the shootout and RWH.
12:43:05 <Heffalump> Which is obvious really, since such a separation doesn't exist.
12:43:10 <dons> *that's* what i like to see.
12:43:12 <Heffalump> But it weakens the value of that mental model, IMO.
12:43:24 <Heffalump> Cale: yeah, but abstract syntax with embedded functions is kind of odd.
12:43:33 <Cale> Not that odd :)
12:43:46 <Heffalump> not to us, no
12:44:07 <twxnf> @src do
12:44:07 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
12:44:17 <twxnf> :/
12:44:29 <ziman> twxnf, do is syntax
12:44:30 <Heffalump> twxnf: the H98 report has the desugaring.
12:44:31 <Cale> Heffalump: I often just ask beginners to think of (IO t) values as executable programs which create a value of type t.
12:44:51 <Heffalump> Cale: yes, so do I. I'm just pointing out the difficulties in the model.
12:45:03 <Cale> Heffalump: Most people have some idea of what executable programs are capable of doing, so that works quite well.
12:45:30 <Cale> Then you just need to explain what >>= does, and it doesn't particularly matter *how* it does it.
12:46:04 <qwr> nekoniaow: IO a is an action that can modify the world - when executed. the haskell code itself never executes it directly. and the Cale's description of it as steps to do for getting value is also good - it's somewhat similar what i meant with telling that runtime interpretates the IO monad "boxes"
12:46:21 <roconnor> @src mapM_
12:46:21 <lambdabot> mapM_ f as = sequence_ (map f as)
12:46:30 <roconnor> @src sequence_
12:46:30 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
12:46:35 <roconnor> @src sequence
12:46:35 <lambdabot> sequence []     = return []
12:46:36 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:46:36 <lambdabot> --OR
12:46:36 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
12:46:49 <qwr> nekoniaow: so the runtime follows the steps when running IO action ;)
12:47:06 <gwern> @undo main = do putStrLn "What's your name?"; name <- getLine; putStr ("Hello, " ++ name ++ "!\n")
12:47:07 <lambdabot> main = putStrLn "What's your name?" >> getLine >>= \ name -> putStr ("Hello, " ++ name ++ "!\n")
12:47:51 <Cale> nekoniaow: Basically, the 'main' action of your program is what the runtime system carries out, and in turn it'll be built up from simpler IO actions, as well as pure functions.
12:48:30 <Cale> Evaluating IO actions doesn't cause them to execute, any more than evaluating a string which is the source code for a program would cause it to be carried out.
12:48:47 <nekoniaow> qwr: but the sequencing of operations is a side effect (not the haskell meaning) of having to step out of the pure haskell code into the runtime "outside world" interpretor right ?
12:49:26 <Cale> nekoniaow: The IO actions represent the order in which the actions they're made of are to occur directly.
12:49:39 <Erik__> where can I find the cairo graphics package?
12:49:59 <kpreid> if you don't care about the order, there's always forkIO :)
12:50:08 <Erik__> http://tuukka.iki.fi/tmp/haskell-2008-01-31.html here I find it is in gtk2hs
12:50:19 <Erik__> cabal: There is no package named gtk2hs
12:50:21 <Cale> Erik__: Yes, it's part of gtk2hs
12:50:28 <Cale> Erik__: It's not on Hackage.
12:50:34 <Erik__> ahh
12:50:37 <Erik__> that explains
12:50:57 <Erik__> oke, back to manual install
12:52:37 <nekoniaow> I think you guys managed to confuse me :)
12:52:47 <qwr> nekoniaow: the "real" sequencing happens when runtime runs the IO action... >>= just composes actions into new actions, which _should_ be somehow sequenced when runned
12:52:56 <mlesniak> nekoniaow: Welcome to my life on #haskell ;)
12:53:21 <nekoniaow> mlesniak: :)
12:53:35 <Cale> nekoniaow: If x and y are actions, then x >> y is the action which, when run, will run x, and then run y
12:53:49 <Cale> nekoniaow: and whose result is the result of y
12:53:54 <nekoniaow> Cale: only if x and y are of type IO right ?
12:54:20 <Cale> Well, in a more general monad, you have to change your definition of "run", but yeah, I'm talking about IO
12:54:30 <nekoniaow> ok
12:54:45 <dons> Erik__: it's part of gtk2hs
12:54:49 <Cale> So it explicitly represents that ordering.
12:54:55 <Erik__> dons: already found it
12:55:04 <Erik__> dons: compiling it now
12:55:07 <Cale> It's not related to the order in which the IO action gets evaluated.
12:55:12 <dons> sweet. what distro are you on?
12:55:17 <dons> there might already be binaries for gtk2hs
12:55:19 <Erik__> freebsd
12:55:23 <dons> ah ok. prob. not.
12:55:40 <dons> there was a cute gtk tut yesterday, http://fhtr.blogspot.com/2008/12/hexagons-with-haskell.html
12:55:57 <Erik__> that's why is was installing it
12:57:06 <Cale> nekoniaow: Basically, there are two processes being carried out as a Haskell program runs: Evaluation, which turns Haskell expressions into values, and execution, which carries out the instructions specified by IO actions (specifically, starting from the IO action called main)
12:57:15 <mafo> has anybody already built gtk2hs with ubuntu + ghc6.10.1 ?
12:58:00 <Cale> nekoniaow: Does that help?
12:58:21 <nekoniaow> Cale: ok and evaluation order is not guaranteed because of lazyness, but execution is
12:58:31 <nekoniaow> ?
12:59:03 <Cale> Well, because of non-strictness. If you assume lazy evaluation, you're specifying an evaluation order (but it's one which is not usually so useful for dealing with IO)
12:59:13 <qwr> nekoniaow: execution order is specified in the actions
12:59:20 <nekoniaow> ok
12:59:26 <Cale> But yes, execution has a particular order, which the IO actions themselves specify.
12:59:45 <Cale> (to agree with qwr :)
12:59:48 <conal> ksf: thx for the FieldTrip wiki reminder.  i've removed that section.
12:59:58 <nekoniaow> I still don't understand what strictness is, but I think I somehow manage to grasp its implications in your reasoning :)
13:00:03 <Cale> Okay
13:00:07 <dons> > head [1..]
13:00:08 <lambdabot>   1
13:00:21 <dons> we didn't evaluate the infinite list. we lazily evaluated on the amount we needed to compute 'head'
13:00:30 <StoneToad> > !head [1..]
13:00:31 <lambdabot>   <no location info>: parse error on input `!'
13:00:32 <dons> if we were strict, we'd evaluate all of [1..] first.
13:00:39 <Cale> Strict evaluation means that when you evaluate a function applied to an argument, you evaluate the argument, then pass the value you get to the function.
13:00:40 <dons> like in say, python
13:00:45 <StoneToad> > head ![1..]
13:00:46 <lambdabot>   Couldn't match expected type `Array i e'
13:00:56 <dons> StoneToad: no, bang patterns work on variable bindings
13:00:58 <Cale> I'll use my favourite example :)
13:01:02 <Cale> Suppose we have:
13:01:04 <StoneToad> dons: ahh
13:01:06 <Cale> double x = x + x
13:01:17 <Cale> and we want to evaluate  double (double x)
13:01:30 <Cale> Er,  double (double 5)  rather
13:01:36 <geezusfreeek> > sum [1..]
13:01:38 <nekoniaow> dons: ok, but that means that strictness is incompatible with lazyness then ?
13:01:46 <Cale> Strict evaluation says that we do this innermost-first
13:01:49 <Cale> So:
13:01:53 <Cale> double (double 5)
13:01:56 <Cale> -> double (5 + 5)
13:01:58 <Cale> -> double 10
13:02:01 <Cale> -> 10 + 10
13:02:02 <Cale> -> 20
13:02:04 <geezusfreeek> :o
13:02:12 <geezusfreeek> sorry lambdabot!
13:02:40 <Cale> By contrast, we could do outermost-first evaluation:
13:02:43 <Cale> double (double 5)
13:02:49 <Cale> -> double 5 + double 5
13:02:52 <dons> nekoniaow: they're the two ends of the evaluation strategy world.
13:02:55 <Cale> -> (5 + 5) + double 5
13:02:59 <Cale> -> 10 + double 5
13:03:03 <Cale> -> 10 + (5 + 5)
13:03:07 <Cale> -> 10 + 10
13:03:08 <Cale> -> 20
13:03:12 <dons> you can do the minimal amount of work, or you can eagerly do too much work. or something in between.
13:03:14 <conal> newsham: ping.
13:03:22 <Cale> But you can see here that this is wasting time computing double 5 twice!
13:03:38 <Cale> Why is it doing that? Well, x occurred twice in the body of double
13:03:53 <Cale> So the parameter gets duplicated, and has to be evaluated more than once.
13:03:54 <rlk> quick q: a 2D Data.Array.Storable is NOT contiguous on the C heap?  Calling TIFFReadRGBAImage works with 1D W*H but bus errors with 2D (W,H).
13:03:59 <Cale> So lazy evaluation refines this
13:04:15 <dons> rlk: you'll need to check the instance to see how it is laid out
13:04:21 <dons> likely it is two arrays side by side.
13:04:23 <Cale> It says that if a parameter to a function occurs more than once in the body, the results of evaluating it are shared between the copies.
13:04:26 <Ezla> Why is let required someplaces?
13:04:36 <newsham> conal: hi
13:04:38 <rlk> No matter.  I'll just load tiffs to 1D arrays.  JUst wanted to confirm.
13:04:39 <Cale> Ezla: 'required'?
13:04:43 <conal> newsham: thanks for the blog comment.  i'd like to fix what i think is a typo: "... and never make the reasoning implicit".  did you mean "explicit"?
13:04:43 <nekoniaow> ok
13:04:55 <newsham> yes, explicit
13:04:57 <newsham> sorry
13:04:59 <Cale> So if I can use let ... in ... to represent the sharing:
13:05:03 <Cale> double (double 5)
13:05:08 <Cale> -> let x = double 5 in x + x
13:05:14 <Cale> -> let x = 5 + 5 in x + x
13:05:18 <Cale> -> let x = 10 in x + x
13:05:21 <Cale> -> 20
13:05:34 <Ezla> why wouldn't  x = 5 + 5 in x + x  // be sufficient?
13:05:35 <howling_mad> hi, how do I convert an unsigned in to a signed float?
13:05:46 <newsham> i dont know how much of what i mentioned has already been pointed out by semantic design blog posts already but some of it seemed new to me or just clicked for the first time
13:05:47 <conal> newsham: thx.  fixed.  i appreciate your remarks. :)
13:06:00 <nekoniaow> is it possible to force evaluation as some point when one knows that it produces better machine code ?
13:06:16 <Cale> Ezla: Well, the syntax would likely end up being more ambiguous, and it would be nearly impossible to use layout.
13:06:24 <roconnor> nekoniaow: use evaluate or seq
13:06:27 <Ezla> so its just a layout issue?
13:06:37 <newsham> ty for your blog.  always a pleasure to read
13:06:42 <conal> newsham: i'm glad you made these points.  it may take a while for it to click for a lot of readers.  your comment may trigger some to take another look.
13:06:48 <conal> newsham: :) :)
13:07:09 <roconnor> nekoniaow: there is even more sophisticated stuff in Control.Strategies
13:07:17 <StoneToad> conal: link?
13:07:26 <Ezla> 'let' has absolutely no other use than to allow for {   } to fix grouping issues on lines ?
13:07:37 <Ezla> if so, then why do you need it for  let f x = x + 1   in ghci?
13:07:42 <conal> StoneToad: http://conal.net/blog
13:07:46 <StoneToad> thx
13:07:58 <geezusfreeek> Ezla: let allows you to bind a variable locally...
13:08:07 <nekoniaow> Is it correct to say that >> is different from . in the sense that it allows to convey additional information along the sequence without changing the parameters of the functions of the "pipeline" ?
13:08:18 <geezusfreeek> > let x = 5 + 5 in x + x
13:08:23 <nekoniaow> s/sequence/pipeline
13:08:23 <lambdabot>   20
13:08:53 <newsham> > let x = 1 : x in x
13:08:55 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
13:09:05 <conal> nekoniaow: (>>) communicates purely via side-effects.  (.) communicates purely functionally
13:09:06 <geezusfreeek> oh wow i didn't realize Cale just did the exact same example
13:09:11 <roconnor> > fix (1:)
13:09:13 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
13:09:25 <newsham> ?src fix
13:09:26 <lambdabot> fix f = let x = f x in x
13:09:30 <newsham> let!
13:09:32 <Cale> nekoniaow: Well, it's different in a lot of ways
13:09:39 <roconnor> damn
13:09:46 <geezusfreeek> Ezla: let and case are duals, in a sense. let creates a thunk and case evaluates it.
13:10:05 <Cale> nekoniaow: For one, >> doesn't take functions, and it ignores the result of the action on its left.
13:10:28 <nekoniaow> ah
13:10:33 <Cale> Well... I shouldn't say that it doesn't take functions as parameters, because there is one monad in which it does...
13:10:50 <Cale> > ((\x -> x^2) >> (\x -> x+1)) 5
13:10:52 <lambdabot>   6
13:11:01 <geezusfreeek> but that monad _is_ functions :P
13:11:03 <Cale> It's kind of useless in that monad though :)
13:11:09 <Cale> > ((\x -> x^2) . (\x -> x+1)) 5
13:11:10 <geezusfreeek> no it's not
13:11:10 <lambdabot>   36
13:11:14 <geezusfreeek> it's Reader
13:11:21 <Cale> geezusfreeek: >> is useless in Reader
13:11:26 <geezusfreeek> oh... right
13:11:36 <geezusfreeek> i was approaching that statement the wrong way
13:12:13 <Cale> So, that monad is really the only one where the two can be compared, and they're different.
13:12:30 <newsham> > runState (put 5 >> gets (*2) 100
13:12:31 <lambdabot>   <no location info>: parse error on input `;'
13:12:32 <Cale> (f >> g) ignores the result of f
13:12:33 <newsham> > runState (put 5 >> gets (*2)) 100
13:12:35 <lambdabot>   (10,5)
13:12:43 <nekoniaow> I think I understand what you mean, but what I meant . as an analogy in this case
13:12:55 <nekoniaow> s/what I/I/g
13:12:59 <idnar> perhaps a better analogy would be const
13:13:04 <idnar> or something like that
13:13:20 <Ezla> geezusfreak: What does locally mean?
13:13:27 <Cale> nekoniaow: What is true is that if x and y are actions, then when x >> y runs, the effect of x running (if any) is preserved when y runs.
13:13:47 <Ezla> What's the difference between making a local variable and a global one in haskell
13:13:48 <Ezla> example?
13:14:00 <mauke> Ezla: just start coding in haskell
13:14:08 <mauke> the questions will answer themselves
13:14:09 <Cale> Ezla: I suppose it's the difference between defining the variable at the top level, and defining it in a let or where.
13:14:16 <idnar> nekoniaow: I think what you're getting at is more a property of monads in general, than (>>) specifically
13:14:18 <roconnor> global = let local = 5 in local*local
13:14:37 <nekoniaow> say I have a pipeline of functions each taking the output of the previous one as output, if I want to be able to convey additional data throughout this pipeline without having to change the functions, I can use a monad x instead, make the functions of type "x old-type" and use >> instead of .
13:14:43 <Ezla> so the "let" doesnt persist past that line?
13:14:50 <Cale> Ezla: right.
13:14:58 <kynky> local to that function block
13:15:00 <Cale> Ezla: Since all variables are constant as long as they remain in scope, all global variables are constants.
13:15:02 <nekoniaow> then I'll be able to change the information conveyed without touching the code of the actions (ex functions)
13:15:02 <nekoniaow> ?
13:15:04 <mauke> nekoniaow: >>=
13:15:08 <Ezla> why does it work in GHCI that i can use my letted functions then?
13:15:11 <roconnor> Ezla: it doesn't persist past the expression after "in"
13:15:29 <kynky> well every variable is a constant i thought
13:15:39 <roconnor> Ezla: that is a different let
13:15:44 <Ezla> A different let!?
13:15:46 <chrisdone> eery variable is a variable!!
13:15:48 <Ezla> There's 2?
13:15:49 <roconnor> do { let x = 5; return x }
13:15:50 <Ezla> or more?
13:15:51 <Cale> nekoniaow: A more direct translation would be to switch to using <=< instead.
13:15:55 <chrisdone> preflex: be poppavic
13:15:55 <preflex>  you know? I think is another context where you share an interface. How many wrenches you own? Metric? Ansi? blind? Ever rivet or weld?
13:16:08 <kynky> as in no side effects i mean
13:16:11 <roconnor> Ezla: the scope of a let statment in a do clause extends to the end of the do clause
13:16:13 <Ezla> Why does it need that  "different let"
13:16:21 <qwr> nekoniaow: function != action in haskell :)
13:16:24 <roconnor> Ezla: note the lack of "in"
13:16:29 <Ezla> roconnor: yes I understand that use of let
13:16:39 <Cale> Ezla: The let-without-in which do-notation supports is just a convenience
13:16:41 <Ezla> however
13:16:51 <Cale> Ezla: It lets you make local bindings which scope over the rest of the block
13:16:56 <Ezla> isnt do { let x = 5; return x; } an error?
13:17:00 <Cale> Otherwise, you'd end up splitting blocks in two
13:17:02 <Cale> no
13:17:06 <mauke> yes
13:17:14 <Cale> mauke: why?
13:17:22 <mauke> > do { let x = 5; return x; }
13:17:23 <lambdabot>   <no location info>: parse error on input `;'
13:17:31 <Ezla> do { let { x = 5; return x; } }
13:17:45 <roconnor> > do { let x = 5; return x }::[Integer]
13:17:46 <lambdabot>   <no location info>: parse error on input `}'
13:17:56 <chrisdone> it's a parser error not a type error
13:17:59 <Cale> > do { let {x = 5}; return x; }
13:18:00 <lambdabot>       No instance for (Show (t1 t))
13:18:00 <lambdabot>        arising from a use of `show' at <i...
13:18:00 <ddarius> do let {x = 5}; return x
13:18:06 <Cale> > do { let {x = 5}; return x; } :: [Integer]
13:18:08 <lambdabot>   [5]
13:18:08 <Ezla> Yeah I was saying
13:18:12 <nekoniaow> Cale: but is it ok to say that a monad allows to transport additional state ?
13:18:15 <Cale> > do { let {x = 5}; return x } :: [Integer]
13:18:16 <lambdabot>   [5]
13:18:18 <Ezla> let x = 5; return x; converets to the enclosed form
13:18:26 <Cale> right
13:18:34 <Cale> So, if you had something like...
13:18:41 <roconnor> > do { let x = 5; return x } :: [Integer
13:18:42 <lambdabot>   <no location info>: parse error on input `}'
13:18:44 <roconnor> > do { let x = 5; return x } :: [Integer]
13:18:46 <lambdabot>   <no location info>: parse error on input `}'
13:18:49 <Cale> do { x <- getLine; let {y = reverse x}; putStrLn y }
13:18:50 <roconnor> :(
13:18:52 <roconnor> ok
13:19:02 <Ezla> so why the need for the GHCI let?
13:19:04 <roconnor> stupid braces
13:19:05 <ddarius> roconnor: It's parsing 'return' as the beginning of a new definition.
13:19:06 <Cale> Without that let notation, you'd need to write
13:19:13 <roconnor> ddarius: oh
13:19:14 <roconnor> thanks
13:19:42 <skorpan> :t curry
13:19:45 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
13:19:48 <Cale> well, basically what it desugars into
13:19:49 <skorpan> :t uncurry
13:19:49 <Cale> getLine >>= \x -> let y = reverse x in putStrLn y
13:19:51 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
13:20:05 <Ezla> Cale: k
13:20:13 <Cale> So it's quite convenient.
13:20:23 <roconnor> @undo do { let {x = 5}; return x }
13:20:24 <lambdabot> let { x = 5} in return x
13:20:29 <Cale> GHCi pretends a bit that you're writing the inside of a do-block
13:20:33 <Cale> So it mimics that syntax.
13:20:54 <Ezla> ah
13:21:12 <Cale> (it also automatically adds 'print' to the beginning of things which aren't IO actions)
13:21:32 <roconnor> so the scope of a let statement in GHCi extends to the the "do block", which is basically forever as far as you are concerned.
13:21:34 <Ezla> pretends, or it actually is in a do block?
13:21:41 <roconnor> pretends
13:22:01 <Cale> pretends. It has lots of extra syntax, and does convenient things like adding that print.
13:22:05 <roconnor> that actions in GHCi's do block are more strict than they would be in a main function
13:22:34 <Cale> Well, if only because they're carried out and their results printed as soon as you type them.
13:25:13 <Ezla> is it common practice to only use "do" for very small functions of stuff closely bound directly to IO,
13:25:18 <Ezla> or do people use it more generally?
13:25:25 <Ezla> is do ever used for non IO ?
13:25:31 <Ezla> just because somebody wants the syntax
13:25:56 <Heffalump> it's used much more generally
13:25:58 <chrisdone> I use `do' for expressions longer than a few `>>' or `>>='
13:26:32 <roconnor> I rarely use IO, and use do notation a lot
13:26:44 <chrisdone> `a >> b >> c >> d' vs `do a; b; c; d'
13:27:25 <takinitez> i do quite a lot of STM/IO stuff, all in do notation
13:28:01 <takinitez> it's just that much more convenient
13:28:19 <roconnor> chrisdone: sequence [a,b,c,d]
13:28:20 <roconnor> er
13:28:25 <roconnor> sequence_ [a,b,c,d]
13:28:37 <takinitez> :t sequence_
13:28:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
13:29:30 <roconnor> I guess a,b,c, and d might not all have the same type
13:29:38 <roconnor> but usually they are all m ()
13:29:57 <takinitez> same monad m
13:30:18 <takinitez> a is forall'd
13:30:20 <roconnor> well they must all be in the same monad to be sequenced in any case
13:30:21 <yitz> Ezla: list comprehensions are "almost" do notation for the list monad.
13:30:36 <yitz> Ezla: and sometimes you use do itself for lists
13:30:50 <takinitez> uh... wait
13:30:52 <foo17y> I'm
13:31:02 <yitz> Ezla: do is very handy for some Maybe expressions, and for other common monads like the State monad.
13:31:21 <calvins> the Control.Exception handle function changed signature between ghc 6.8 and 6.10, due to Exception becoming a type class.
13:31:28 <yitz> Ezla: all of those are usages of do notation for expressions that are completely pure.
13:31:29 <takinitez> roconnor, to be in a list it has to be the same a too
13:31:59 <roconnor> takinitez: yes, that is the key difference between sequence_ [a,b,c] and a >> b >> c
13:32:25 <takinitez> :t (>>)
13:32:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
13:32:30 <Ezla> yitz: but what if you want to avoid the 'return' there?
13:32:38 <calvins> Is there some way to get something to compile on both 6.8 and 6.10 that uses handle? I get an error on 6.10 of "Ambiguous type variable `e' in the constraint", and if I add the constraint, it won't compile on 6.8 anymore.
13:32:40 <Ezla> because it's useless
13:32:57 <yitz> Ezla: you don't always need return
13:33:02 <Ezla> really?
13:33:03 <Ezla> hmm
13:33:42 <yitz> Ezla: if the last expression of the do block has the right type
13:33:43 <RayNbow> > [[1,2,3,4],[5,6,7,8]] >>= id
13:33:45 <lambdabot>   [1,2,3,4,5,6,7,8]
13:34:01 <Ezla> >  do { let x = 1; x } :: Int
13:34:02 <lambdabot>   <no location info>: parse error on input `}'
13:34:07 <roconnor> do print "Look ma, no return"
13:34:23 <roconnor> > do { let x = [1]; x}
13:34:24 <lambdabot>   <no location info>: parse error on input `}'
13:34:31 <roconnor> > do { let {x = [1]}; x}
13:34:33 <lambdabot>   [1]
13:35:06 <roconnor> > do { let {x = [1]; y=[2]}; x `mplus` y}
13:35:08 <lambdabot>   [1,2]
13:35:35 <wagle> if i want to parse any C program GCC can, what would I use in haskell?
13:35:57 <foo17y> *proud haskell beginner* Writing this using my own irc client in haskell :)
13:36:09 <wagle> foo17y, woot!
13:36:13 <roconnor> foo17y++
13:36:17 <foo17y> wagle: its just a 50 liner
13:36:30 <foo17y> and i thought starting with something interesting :)
13:36:35 <Lemmih> wagle: Didn't someone write Langauge.C.Parser once.
13:37:03 <takinitez> parsing c is painful
13:37:08 <hydo> Hrm, maybe i'm not "getting it" as well as I thought.  I don't understand how to get x out of "Just x"?
13:37:14 <calvins> ah, to answer the handle question and API change on Exception from 6.8 and 6.10, I found http://haskell.org/haskellwiki/Upgrading_packages#Exception_handling_changes in case anybody reads the logs later...
13:37:25 <wagle> seems to me that everyone write their own parser, then finds that gcc does very weird and unexpected things
13:37:30 <hydo> err, I meant how do I get x out of "Just x"?
13:37:45 <roconnor> hydo: what do you want to do in case of Nothing?
13:37:53 <Lemmih> hydo: case mbVal of Just x -> ...
13:38:19 <glguy> There was some work on a GCC compatible C parser lately
13:38:21 <foo17y> /msg nickserv help
13:38:22 <hydo> oh, hence the whole reason for Maybe and Just, etc.
13:38:30 <qwr> > fromMaybe -1 (Just 5)
13:38:32 <lambdabot>       No instance for (Num (a -> Maybe a -> a))
13:38:32 <lambdabot>        arising from a use of ...
13:38:39 <roconnor> \msg nickserv help
13:38:49 <takinitez> the whole point of Maybe is the Nothing
13:38:52 <wagle> glguy, any google tips?
13:38:57 <dibblego> > fromMaybe (-1) (Just 5)
13:38:59 <lambdabot>   5
13:39:35 <roconnor> > maybe "error" show (Just 5)
13:39:37 <lambdabot>   "5"
13:39:44 <roconnor> > maybe "error" show Nothing
13:39:45 <lambdabot>   "error"
13:40:07 <dons> wagle: use Language.C ?
13:40:21 <dons> gcc compat. parser developed for c2hs, now a standalone library
13:40:35 <glguy> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/language-c
13:41:12 <ttt--_> fail "hi" >>= (++ "hi")
13:41:14 <ttt--_> > fail "hi" >>= (++ "hi")
13:41:16 <lambdabot>   ""
13:41:20 <ttt--_> woo
13:41:36 <pumpkin> > epic fail
13:41:38 <lambdabot>   Not in scope: `epic'
13:41:40 <pumpkin> :(
13:41:41 <ksf> The meaning of each method corresponds to the same method for the meaning.
13:41:48 <ksf> That's way to much zen for me.
13:41:50 <dons> glguy: did you see the doublec's gitit set up for factor stuff? http://articles.bluishcoder.co.nz/Haskell/NotAHAppSTutorial ?
13:41:54 <yitz> foo17y: can you make your irc client launch each channel in a separate X window?
13:42:07 <glguy> dons, nuh uh
13:42:09 <dons> i'm pleased to see happs getting its tires kicked.
13:42:09 <ksf> conal, what did you smoke and where can I get some?
13:42:28 <dons> glguy: site running in gitit, on happs.
13:43:08 <dons> so git-backed storage.
13:44:10 <ttt--_> i found the happstutorial package very useful to get started
13:44:26 <wagle> neato
13:44:29 <dons> yeah. Lemmih : we need all this happs stuff on one giti wiki at happs.org!
13:44:41 <dons> so we can add refs. to tutorials, new sites, new adopters etc.
13:44:48 <dons> get that momentum going.
13:45:10 <dons> Lemmih: i.e. mention that deutsche bank has a group using happs for everything... seriously, happs is so undersold.
13:45:33 <calvins> is there a way to specify the version of base to use as a pragma in a source file? I have changed a cabal file to use the correct base version, but that doesn't help when I'm interactively playing around with the module in ghci.
13:45:38 <dons> mention that you can use the server as a standalone tool for your web apps, without the surrounding infrastructure, for example.
13:45:47 <calvins> i checked the ghc pragmas page and didn't see any way there of doing that.
13:45:54 <dons> calvins: in the command line to ghci
13:46:00 <dons> -package base-1.2.3.4
13:46:12 <dons> you can't specify link options (like packages) in pragams
13:46:21 <dons> really though, that's asking for a 'cabal ghci' mode
13:46:24 <dons> which is also reasonable
13:46:27 <calvins> dons: but then i have to change the command line with every different module i use in emacs.
13:47:13 <conal> ksf: :)
13:47:20 <calvins> i want to use the same ghci command for all modules if that's possible
13:47:44 <dons> yeah, you want: cabal ghci
13:47:51 <dons> which would have ghci set up using the .cabal info
13:48:01 <dons> since that's wheere all the metadata is specified
13:48:31 <calvins> is that a newer ghci? I'll search online for it. Thanks a lot..
13:49:00 <dons> calvins: no, that doesn't work yet.
13:49:06 <dons> i'm saying "you'd want that, if it existed" :)
13:49:07 <Lemmih> dons: I wish more people were of your mind. If they were, perhaps I could get a job (:
13:49:30 <dons> Lemmih: the over-caffeinated mind?
13:49:34 <dons> let's do this!!
13:50:03 <dons> Lemmih: you knew that jeff and sterling at deutsche were using happs, didn't you?
13:50:13 <Lemmih> dons: I had no idea.
13:50:19 <dons> oh. they talked about it at CUFP.
13:50:34 <calvins> dons: oh :-( I found http://hackage.haskell.org/trac/hackage/ticket/382 . Is that the latest status of that?
13:50:45 <dons> seriously. we can really make a case for happs now. wanna do a happs hackathon sometime?
13:51:00 <dons> yes. calvins, its a proposal.
13:52:28 <dons> Lemmih: http://cufp.galois.com/2008/slides/PolakowJeff.pdf
13:52:42 <calvins> dons: thanks! Maybe I'll make a wrapper around ghci for now that starts ghci with the appropriate base depending on which project I'm working on.
13:52:48 <dons> that should be on the happs.org front page. "Deutsche Bank uses Happs". "Gitit uses HAppS" "Read this tutorial" etc.
13:53:03 <dons> Lemmih: see the system architecture on page 7
13:53:28 <dons> Lemmih: maybe you can talk to sclv and do some consulting :)
13:53:31 <earthy> is the happs doc situation better already?
13:53:44 <dons> earthy: seems so. i think it improved a lot this last 6 months.
13:53:51 <earthy> ah, then it must be
13:53:54 <dons> e.g. today a cookbook was posted, http://articles.bluishcoder.co.nz/Haskell/NotAHAppSTutorial
13:54:01 <dons> (cookbook hosted in gitit, running on happs :)
13:54:01 <earthy> haven't looked at it for about that long
13:54:02 <Lemmih> earthy: There's a bunch of tutorials + haddock docs.
13:54:35 <earthy> good to know
13:54:47 <dons> Lemmih: i'd like happs.org to be as clean and nice as xmonad.org (easy to modify, points to docs, use cases, examples, screenshots)
13:55:01 <earthy> I might want to upgrade a little internal thingy I've written to happs then
13:55:21 <dons> earthy: main development: cabal install happs-server works
13:55:24 <dons> so life gets super easy.
13:55:39 <luite_> would it be a good idea to add a wiki page and reactions to each package on hackage? I often find myself looking for some usage examples of packages, but the documentation often does not help much. I think room for some discussions (reactions) and code samples (wiki) could help, as samples now often end up scattered on blogs and pastebins
13:55:40 <dons> that's led to the recent growth, i think. gitit, the factor guy's site, etc
13:55:49 <dons> the tutorials and helpers hosted on hackage too.
13:55:56 <dons> that kind of synergy we only get thanks to hackage+cabal.
13:56:01 <dons> luite_: yes!
13:56:09 <dons> luite_: every package should have an editable page.
13:56:12 <dons> a 'talk' page.
13:56:21 <dons> the new hackage server should support this.
13:56:26 <dons> (even embedding gitit inside it)
13:56:27 * earthy nods in full agreement
13:56:35 <Erik__> luite_: code samples would be very welcome
13:57:31 <dons> seems like pressure is growing for the new hackage server to go up.
13:57:40 <dons> i wonder how much time it would take to get that up.
13:57:45 <dons> dcoutts_: finsihed with jury duty yet?
13:59:46 <dons> waern_: hey!
14:00:15 <foo17y> another test
14:00:27 <foo17y> hmmmmmmmmmmmm
14:00:46 <int-e> > test
14:00:47 <lambdabot>   Not in scope: `test'
14:00:50 <int-e> :(
14:00:52 <dons> we can hear you foo17y. you shouldn't need to 'test' irc channels. esp. when 500 people are watching
14:01:25 <mlesniak> dons: sorry, wrong test channel, normally hanging around in #hstest ;)
14:01:28 <dons> hehe
14:01:34 <dons> i see! test bot?
14:01:37 <waern_> dons: hey! :)
14:01:51 <mlesniak> dons: yes, trying to get more practice in haskell
14:02:37 <gwern> 'Haskell could learn some things from F#. Every statement in F# must either be bound to a value or evaluate to (). In Haskell it is possible to write do mapM f xs; return 1. Any experienced Haskell programmer should spot that the mapM is a space leak (it should be mapM_), but the type system doesn't enforce it. In F# the type system does. The change in Haskell is simple, and in my opinion, desirable.'
14:02:44 <gwern> http://neilmitchell.blogspot.com/2008/12/f-from-haskell-perspective.html <-- sounds reasonable to me
14:04:26 <dons> not sure it makes sense with laziness
14:04:28 <kpreid> why is it a space leak?
14:04:30 <dons> it isn't.
14:04:39 <dons> it constructs a value only to throw it away
14:04:44 <dons> e.g.   foo >>= \_ -> bar
14:04:53 <dons> so if foo builds some result, we don't use it, and it gets deallocated
14:05:00 <dons> that's not a leak. so ndm used the wrong word.
14:05:15 <luite_> couldn't the optimizer remove it entirely?
14:05:17 <dons> *but* we often use _ to ensure things don't get evaluated in other contexts
14:05:25 <dons> luite_: yes, i think it is more of an optimisation issue
14:05:43 <dons> if the result isn't needed, then the compiler could see that the side effect is all we care about, perhaps, and give us mapM_ for free
14:05:56 <dons> ghc might even do that already ....
14:06:18 <gwern> dons: I think it makes sense as a reflection of the programmer's intent - if I say mapM where I don't use the results, then I should be warned about not using it
14:06:18 <dons> its a small optimisation issue. and probably one that could be automated.
14:06:36 <dons> gwern: what if ghc would just replace mapM with mapM_ when the result isn't needed?
14:06:42 <yitz> speaking of small optimization issues...
14:06:50 <dons> the existence of mapM_ is an odd one.
14:06:52 <yitz> an old nagging question in the back of my mind:
14:07:24 <yitz> ghc *does* optimize away the test when you use otherwise as the last guard. doesn't it?
14:07:38 <gwern> dons: well, then we'd be in the same situation as when I define an unused function or variable - sure, the compiler may/will optimize it away in the end-binary, but it quite likely reflects an omission or error on the programmer's part
14:07:53 <gwern> and it's the latter part I care about, not any possible optimization
14:08:41 <yitz> no one knows?
14:08:45 <geezusfreeek> mapM_ does alleviate the need to say return () after a mapM just to get a m () type, i guess
14:08:56 <dons> yitz: yes.
14:09:00 <Deewiant> yitz: considering that it becomes essentially "if True" it quite likely does
14:09:03 <dons> yitz: it turns into _DEFAULT_ -> ...
14:09:11 <yitz> dons: thanks. whew!
14:09:15 <dons> yitz: just check the core if you ever worry.
14:09:17 <dons> ghc-core Foo.hs
14:09:47 <RayNbow> if only ghc-core was available for Windows :p
14:09:56 <yitz> dons: how about the same pattern repeated on the same argument in pattern matching?
14:10:12 <dons> maybe we should ask spj why mapM foo doesn't turn into mapM_
14:10:17 <dons> i'd have thought inlining would reveal it.
14:10:23 <dons> yitz: in some cases.
14:10:24 <ksf> http://www.youtube.com/watch?v=MVUt4BrLV9A&feature=related
14:10:25 <dons>  check the core.
14:10:27 <Baughn> Interesting. Handing a program +RTS -A8k makes it loop the GC forever without ever actually doing any work
14:10:36 <yitz> ok. tnx.
14:10:36 <dons> Baughn: thrashing.
14:10:40 <Baughn> Oh, and I can see the parallel GC working. Both cores are pegged.
14:10:42 <dons> Baughn: totaally not surprising.
14:10:48 <dons> Baughn: try -A1G instead
14:10:50 <dons> to see progress
14:11:03 <dons> Baughn: oh. that's a good trick
14:11:15 <dons> yes. "is my parallel GC working? set -A8k and find out"
14:12:13 <yitz> but keep your fingers on ^C in case it is.
14:12:44 <gwern> 'are my threads actually running? start a watchdog thread and try to print the result of 'let x = x + 1 in x'!'
14:13:57 <pumpkin> it seems like it would be nice to be able to annotate individual variables bang-style inline, to avoid strings of `seq`s, which I think impair readability
14:14:08 <Baughn> dons: Right. It refuses to use 4k (odd error message), so I'd think it'd make sense to refuse 8k as well. Well, no biggie.
14:14:30 <Baughn> More interesting is what happens if you set the max heap size lower than the default allocation size. ^^;
14:15:33 <dons> Baughn: well, at some point the thread context is so small you can't get started. but  then its a slippery slope up to a useful heap size.
14:15:46 <dons> you planning to run ghc apps on a machine with 8k of ram and several cores? :)
14:16:07 <Baughn> dons: No, I'm just trying to prove to someone that GHC doesn't /need/ to be a big in memory use
14:16:20 <dons> :)
14:16:22 <gwern> dons: well he figured 'with such big processor caches, why bother with ram'?
14:16:24 <dons> it isn't big!
14:16:31 <JoshTriplett> If I have a list l, doing l `seq` [... | foo <- l, ...] will only ensure that the outermost thunk of l gets evaluated before the list comprehension, right?
14:16:33 <yitz> dons: I once worked on a machine that was essentially that
14:16:34 <dons> Baughn: it has one of the smallest footprints on the shootout. xmonad has a tiny footprint.
14:16:36 <Baughn> dons: s/big/pig
14:16:49 <JoshTriplett> If I want to force the whole list l first, I need something like (last l) `seq` [...]?
14:16:52 <Baughn> dons: I know, but a megabyte for opengl hello, world is still a bit much
14:16:52 <dons> where'd this 'memory use' meme come from? people assuming that the standard lazy tail call space leak is actually representative??
14:17:01 <JoshTriplett> (assuming I know the list l has elements)
14:17:03 <dons> Baughn: 1M is what you'll pay for the runtime.
14:17:12 <dons> Baughn: that's roughly the constant k.
14:17:21 <Baughn> dons: That's what the heap size ends up as, actually
14:17:25 <dons> you might get it down to 500k i guess
14:17:31 <Baughn> Then again, it only GCs once in a blue moon
14:17:33 <dons> if you're super tricky.
14:17:45 <Baughn> Oh, wait. 512k, not 1m
14:17:50 <yitz> it was four Z80's on one board, the bottom 1K was shared, then each had maybe 32K or so.
14:17:55 <dons> but you'll just have to deal with the ~1M thing. given your typical laptop has 4G now, i think that shouldn't matter.
14:18:07 <dons> JoshTriplett: last is partial though.
14:18:14 <Baughn> Intriguingly with -A12k -M16k it runs, but gives a bus error if I press C-c
14:18:15 <dons> JoshTriplett: so length xs `seq` ...
14:18:17 <dons> would be ok.
14:18:19 <dons> JoshTriplett: or use 'rnf'
14:18:24 <dons> from Control.Parallel.Strategies
14:18:25 <JoshTriplett> rnf?
14:18:31 <dons> reduce to normal form
14:18:34 <dons> (not weak head normal form)
14:18:47 <dons> i'll make a wiki page...
14:18:48 <JoshTriplett> I think "length xs `seq` ..." will work nicely.
14:19:03 <JoshTriplett> dons: In this particular case I happen to know that xs != [], so last ought to work.  But length seems sane.
14:19:20 <Baughn> One thing I'm missing from Strategies is a strategy that will evaluate list items in order, but not evaluate item N before it is actually requested
14:19:25 <dons> Prelude Control.Parallel.Strategies> let xs = [1,2,undefined]
14:19:25 <dons> Prelude Control.Parallel.Strategies> head xs
14:19:25 <dons> 1
14:19:25 <dons> Prelude Control.Parallel.Strategies> rnf xs
14:19:28 <dons> *** Exception: Prelude.undefined
14:19:32 <Baughn> I /was/ using seqList, which worked fine until I tried it on an infinite list. Oops.
14:19:37 <JoshTriplett> Baughn: Effectively a fold of seq?
14:19:40 <mafo> dons: rnf is this a primitive or can it be expresse in Haskell ?
14:19:51 <dons> mafo: it's built in terms of `seq`
14:19:51 <opqdonut> mafo: yes, it's coded in haskell
14:19:53 <Baughn> JoshTriplett: Yep. It's a one-liner once you realize it isn't already there.
14:20:45 <yitz> @src rnf
14:20:45 <lambdabot> Source not found. Where did you learn to type?
14:20:49 <yitz> figured
14:20:50 <Baughn> @src NFData
14:20:51 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
14:20:51 <JoshTriplett> dons: Oh, rnf does the wrong thing for me then.
14:21:02 <JoshTriplett> dons: I don't actually want it to force the elements, just the list.
14:21:16 <JoshTriplett> dons: Primarily because I generated the list by processing another list, and I want the elements of that other list thrown away ASAP.
14:21:43 <JoshTriplett> dons: I guess I want length xs `seq` xs, then.
14:22:48 <Baughn> Probably a bit premature, but is anyone working on an opencl binding yet?
14:24:11 <mafo> so if I want to use rnf on some datatype I have to make it an instance of NFData ?
14:24:12 <FunctorSalad> any news about how to handle this error? (with cabal install) cabal: dependencies conflict: ghc-6.10.1 requires process ==1.0.1.1 however process-1.0.1.1 was excluded because ghc-6.10.1 requires process ==1.0.1.0
14:24:33 <FunctorSalad> :(
14:24:47 <Baughn> FunctorSalad: What are you trying to install?
14:25:00 <FunctorSalad> Baughn: haddock, but I've had the error with other packages too
14:25:29 <Baughn> FunctorSalad: It does look like something messed up when you compiled ghc
14:25:36 <dons> whnf then Josh
14:25:53 <dons> ?users
14:25:53 <lambdabot> Maximum users seen in #haskell: 568, currently: 541 (95.2%), active: 21 (3.9%)
14:26:01 <FunctorSalad> Baughn: I think I installed the binary, but maybe I did somewhat mess up my package.conf ;)
14:26:24 <Baughn> FunctorSalad: Try deleting ~/.ghc first. You never know.
14:26:30 <nekoniaow> is anyone knowledgeable regarding cabal ? I don't understand why it tries to rebuild a package I just manually built and installed
14:26:30 <FunctorSalad> this problem really needs a better error message though :)
14:26:43 * Baughn desperately hopes FS hasn't been installing hackage packages system-wide
14:26:54 <dons> nekoniaow: hmm. usually because something else depends on that version, which needed to be compiled.
14:27:01 <dons> nekoniaow: you can make reports of this to dcoutts.
14:27:15 <FunctorSalad> Baughn: I used to install the system-wide, then with --user, then with --global, --prefix=~/local ;)
14:27:33 <yitz> Baughn: are you thinking of an opencl binding via YHC core?
14:27:35 <nekoniaow> dons: I'm pretty sure I'm doing something wrong and cabal is fine :)
14:27:38 <FunctorSalad> Baughn: what would be bad about installing system-wide?
14:27:54 <joelr1> good day
14:28:00 <Baughn> yitz: No.. how is yhc related?
14:28:47 <Baughn> yitz: My thought was that it'd be neat to have an OpenCL monad on hackage, really. I haven't even found the spec yet, but it should be doable
14:28:52 <yitz> Baughn: well that's how they compiled Haskell for a GPU in the past
14:28:59 <dons> i go away for a week, and there's 70 packages on hackage to port to arch.
14:29:02 <dons> good thing tihs is automated.
14:29:20 <dons> we don't we just have an opencl edsl?
14:29:31 <dons> we've done it for things like harpy / asm in the past.
14:29:50 <dons> have the edsl emit opencl code that gets linked back in (a la hsc2hs)
14:29:52 <Baughn> That's the idea.. I'm not sure what would fit best
14:30:08 <dons> and then take over the world with the only efficient, high level gpu programming lang
14:30:11 <yitz> Baughn: you want to be able to say f `par` g `par` ... and have it go to separate cores in the GPU
14:30:11 <Baughn> Well, if someone finds the opencl spec, let me know. ;)
14:30:19 <Baughn> yitz: Not particularily.
14:30:48 <yitz> Baughn: so you're thinking of something more low level
14:30:50 <Baughn> yitz: OpenCL is better than CUDA, but it's still /very/ low-level code, and a great deal of programmer control is needed
14:30:51 <dons> [: f x | x <- ar :] -- < put ar on the gpu, and 'f' is a gpu function
14:31:22 <dons> you can surely write 'map' in CUDA
14:31:32 <Baughn> Oh, sure
14:31:34 <dons> use fusion to combine the loops
14:31:36 <dons> and away we go
14:35:10 <ksf> instance Functor IO where
14:35:10 <ksf>    fmap f x           =  x >>= (return . f)
14:35:24 <ksf> why am I thinking that it should be defined the other way round?
14:36:30 <halberd> is there a stack-based language that offers static typing?
14:37:13 <ksf> oehm... java assembly?
14:37:38 <ronny> hi
14:38:11 <ksf> a monad doing it wouldn't be hard to implement, either.
14:38:19 <nekoniaow> dons: should I use the trac reporting system for that purpose ?
14:40:08 <ddarius> halberd: Cat
14:40:42 <roconnor> it should be instance Functor IO where fmap = liftM
14:46:16 <mlesniak> Simple beginner question: I have do {a <- f handle str; b <- g h a}. Is there a way to combine both to b <- <some magic with f and g> h a?
14:46:27 <mlesniak> h = handle
14:47:49 <dobblego> mlesniak, kind of, but notice that 'a' is not of the same type as 'f handle str'
14:48:23 <dobblego> mlesniak, it might help to write that expression out without the do-notation
14:48:28 <mlesniak> dobblego: I know, f handle str has return type IO <sometype>
14:48:43 <dobblego> f handle str >>= \a -> g h a >>= \b -> [missing]
14:48:46 <mlesniak> dobblego: ah, good idea, getting out his >>=
14:49:02 <mlesniak> dobblego: thanks, I'll puzzle out the rest by myself :)
14:49:08 <dobblego> ok :)
14:49:18 <Riastradh> Perhaps liftM will come in handy.
14:49:27 <mlesniak> dobblego: if you'd write everything down, where is the fun in learning ;)
14:49:29 <dobblego> you might also consider writing it using liftM2 or ap/fmap
14:49:35 <mlesniak> Riastradh: hmm, sounds good, too, thanks
14:53:23 <ksf> if you don't care for execution order of f and g, you can do (a,b) <- (f ... , g ...)
14:53:27 <halberd> thanks ddarius
14:53:57 <mlesniak> ksf: also in the IO monad?
14:54:07 <ksf> even on the top level.
14:54:13 <mlesniak> ah, cool
14:54:21 <ksf> (main, foo) = (print "hello", undefined)
14:54:22 <ksf> try it.
14:55:08 <gwern> dons: did you see this email to yi-devel about the terminfo package being broken on Arch Linux due to ncurses?
14:55:46 <ddarius> (a,b) <- (f ..., g ...) won't work, even if it did it wouldn't do what he wants.
14:56:38 <FunctorSalad> (a,b) <- liftM2 (,) (f ...) (g... )
14:57:39 <mriou> hi, question about a type declaration that would take a function
14:57:47 * mlesniak must have a hidden masochistic fetish because he likes how haskell squeezes his imperative && oop-mind
14:57:54 <mriou> and said function manipulates stuff in the ST monad
14:58:08 <mriou> I've tried:
14:58:09 <mriou> data WyPrimitive = WyPrimitive String [String] ([ASTType] -> STRef s WyEnv -> ST s WyType)
14:58:30 <mriou> ASTType, WyEnv and WyType or others of my types
14:58:54 <mriou> this errors with 's' not being in scope
14:59:18 <mriou> I know I should declare the type variable somehow, only I haven't found a proper way, any idea?
15:00:13 * gwern mumbles half-understood phrases at mriou: Azrael, existential type variables, ewige blumenkraft, ignoti et quasi occulta
15:00:33 <FunctorSalad> data WyPrimitive s = ... ?
15:01:12 <FunctorSalad> gwern: how does this ewige blumenkraft extension work? :)
15:02:16 <FunctorSalad> mriou: this is assuming that the type s should be a parameter of WyPrimitive
15:02:24 <mriou> the "data WyPrimitive s = ..." doesn't seem to help, thing is the s is a type var of the ST monad
15:02:26 <gwern> FunctorSalad: well, first you need to satisfy the proof obligation that the caller is the fascist type, then you need to call getNewWorldOrder...
15:02:34 <Philippa_> FunctorSalad: I hear it has something to do with rose trees
15:03:50 <mriou> what I know is that the type signature of the functions I want to give to that WyPrimitive type is ([ASTType] -> STRef s WyEnv -> ST s WyType)
15:04:31 <FunctorSalad> gwern: ? :o
15:04:54 <mriou> I've tried to play with existentional types and do [forall s.  ...] but it didn't quite cut it
15:05:03 <mriou> darn, existential
15:05:28 <mriou> existentional sounds good too though ;)
15:05:40 <idnar> haha
15:06:55 <FunctorSalad> mriou: why won't 'WyPrimitive s' work?
15:08:12 <mriou> I don't have any type to give it, I just want to be able to do:
15:08:17 <nekoniaow> I just can't believe someone is doing the exact same thing as me at the same moment : http://passingcuriosity.com/index.php/2008-12/installing-hsql-hdbc-ghc-6-10-1/
15:08:39 <mriou> WyPrimitive "foo" ["bar"] some_function_with_said_signature_here
15:09:38 <FunctorSalad> mriou: you don't need to fix the type s - if you make it a parameter of WyPrimitive, the polymorphism is just "passed through" WyPrimitive
15:09:45 <FunctorSalad> (don't know how to express it better)
15:10:17 <harblcat> What use is mapM?
15:10:31 <FunctorSalad> mriou: alternatively, if your some_function always has s instantiated with some fixed type, you could fix the s in WyPrimitive too
15:10:37 <centrinia> It is more general than map.
15:11:06 <pumpkin> how does mapM compare to fmap?
15:11:13 <pumpkin> :t mapM
15:11:14 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:11:23 <centrinia> :t fmap
15:11:24 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:11:25 <pumpkin> ah
15:11:42 <pumpkin> > mapM Just [1,2,3]
15:11:43 <lambdabot>   Just [1,2,3]
15:11:45 <mriou> FunctorSalad: ok thanks, I'll give it a quick try to see how that works
15:11:46 <FunctorSalad> mapM f xs = sequence (map f xs)
15:12:13 <pumpkin> > mapM (:[]) [1,2,3]
15:12:15 <lambdabot>   [[1,2,3]]
15:12:22 <pumpkin> funky :)
15:12:36 <FunctorSalad> @src ListT
15:12:37 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
15:12:46 <pumpkin> > join [[1,2],[3,4]]
15:12:47 <lambdabot>   [1,2,3,4]
15:12:58 <centrinia> Why does lambdabot have to be so insulting? :(
15:13:07 <pumpkin> aha, the name join makes much more sense in the context of lists
15:13:39 <centrinia> @check \x -> (concat x) == (join x)
15:13:41 <lambdabot>   "OK, passed 500 tests."
15:13:49 <FunctorSalad> > join (*) 5 -- most confusing 8-character command ever?
15:13:50 <lambdabot>   25
15:13:53 <roconnor> > join $ Just (Just 5)
15:13:55 <lambdabot>   Just 5
15:14:15 <pumpkin> FunctorSalad: it's a bit mind-bending but makes sense after last night for me :P
15:14:22 <FunctorSalad> :)
15:14:38 <pumpkin> > join (***) (^2) (1,2)
15:14:39 <lambdabot>   (1,4)
15:14:41 <dobblego> @type concatMap
15:14:43 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
15:14:46 <dobblego> @type concatMap id
15:14:48 <lambdabot> forall b. [[b]] -> [b]
15:14:55 <ronny> >  do { x <- [1,2,3];y <- [ 4,5,6]; return (x,y)}
15:14:56 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
15:14:58 <dobblego> > concatMap id [[1,2], [3,4]]
15:14:59 <lambdabot>   [1,2,3,4]
15:15:03 <roconnor> @type concat
15:15:04 <lambdabot> forall a. [[a]] -> [a]
15:15:17 <mriou> FunctorSalad: the type parameter passing worked, thank a lot!
15:15:19 <pumpkin> @src concat
15:15:22 <lambdabot> concat = foldr (++) []
15:15:22 <FunctorSalad> np :)
15:17:28 <gwern> centrinia: lambdabot is so insulting because openbsd's sudo is so insulting, and dons found it funny
15:18:41 <harblcat> what would 'a <- action' be called?
15:18:51 <nekoniaow> I assume the rationale behind prefixing Control.OldException with 'Old' is that it's going to be obsoleted at some point ?
15:19:03 <RayNbow> harblcat: it binds the result of action to the name a
15:19:14 <RayNbow> so you could call it a binding, I guess
15:19:40 <harblcat> okay. How do you perform an action on an entire list?
15:19:46 <harblcat> like map?
15:19:52 <gwern> nekoniaow: no, it's a reflection of our respect for the venerable module
15:19:55 <gwern> mapM?
15:20:02 <RayNbow> :t mapM
15:20:03 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:20:06 <FunctorSalad> nekoniaow: I think it's because there's already a new Control.Exception
15:20:25 <gwern> nekoniaow: you must be some sort of ageist to draw the connection between 'old' and 'obsolete'!
15:20:39 <pumpkin> harblcat: what's wrong with map?
15:20:52 <nekoniaow> Wasn't it possible to identify it in a more functional way ?
15:21:20 <harblcat> I've got an IO action that I need to apply to a series of arguments. I tried map and it didn't work...
15:21:31 <pumpkin> harblcat: what do you want to get out of it?
15:21:37 <pumpkin> harblcat: maybe sequence_ is what you want?
15:21:45 <pumpkin> :t sequence_
15:21:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
15:21:46 <nekoniaow> gwern: well, "old" does not describe a functionality to me, and the only one I can associate with it is of obsolescence :)
15:21:57 <pumpkin> nekoniaow: or great wisdom!
15:22:02 <pumpkin> ;)
15:22:24 <nekoniaow> Control.WiseException ? :)
15:22:38 <RayNbow> :t mapM_
15:22:39 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
15:22:40 <pumpkin> Control.WiseAndVenerableException
15:23:29 <FunctorSalad> nekoniaow: I suppose that it is obsolete in favour of Control.Exception, but I don't know for certain
15:24:05 <dons> ?users
15:24:05 <lambdabot> Maximum users seen in #haskell: 568, currently: 542 (95.4%), active: 23 (4.2%)
15:24:13 <nekoniaow> FunctorSalad: that's what I would assume as well, but I can't seem to googlefind any discussion about that
15:25:39 <harblcat> I'm getting some weird type IO [IO [Int]]..
15:26:55 <harblcat> replicating an IO action gets a list of IO actions.
15:27:39 <nekoniaow> FunctorSalad: I'm trying to have HDBC compile with ghc 6.10 and my dilemna is essentially to determine whether I should just import Control.OldException in order for "throwDyn" to be found, or if I should modify the code to replace throwDyn by some kind of new official successor to it
15:27:59 <FunctorSalad> sigh... I rm -rf'ed ~/.ghc and ~/local/lib/ghc and still I get the "ghc needs process==1.0.1.0 but ghc needs process==1.0.1.1" with some packages upon cabal-install (but not with all packages)
15:30:15 <FunctorSalad> nekoniaow: the first one sounds easier :)
15:30:45 <FunctorSalad> nekoniaow: I mean, if you're a user... if you're the author/maintainer you might consider the new Exception
15:30:53 <qwr> harblcat: what did you expect? ;)
15:31:39 <nekoniaow> FunctorSalad: I'm the kind of user who feels bad hardcoding a solution instead of cleaning the code he is going to rely on :)
15:31:59 <nekoniaow> but who doesn't know enough to do it, being a complete haskell newb
15:32:18 <harblcat> Well, I'm just confused. I've got a function a :: Double -> IO Bool
15:32:43 <harblcat> I want a function a :: Double -> Int -> IO [Bool]
15:33:00 <nekoniaow> FunctorSalad: this being said, I see that maintainers of other libs have just used OldException without any apparent remorses
15:33:14 <pumpkin> harblcat: what would the Int do?
15:33:19 <nekoniaow> this feels wrong
15:33:24 <FunctorSalad> nekoniaow: I don't know what was changed either :(
15:33:28 <pumpkin> harblcat: you want to repeat it?
15:33:47 <qwr> harblcat: replicateM ?
15:33:59 <mriou> FunctorSalad: mmh the type parameter on "data WyPrimitive s = ..." is kicking me in the nuts
15:34:14 <harblcat> I looked at replicateM, but I'm probably not using it right...
15:34:18 <mriou> sorry if I bother again
15:34:25 <FunctorSalad> -XBallProtectors
15:34:26 <FunctorSalad> ;)
15:34:40 <mriou> mmh I'll try that :)
15:35:02 <FunctorSalad> what's the problem?
15:35:04 <mriou> thing is, that type is used in another which is itself used as a key in a map
15:35:07 <olsner> @src subtract
15:35:07 <lambdabot> subtract x y = y - x
15:35:12 <mriou> which are all used here and there
15:35:29 <harblcat> Er. I got it. I didn't need to use return, oddly enough.
15:35:30 <FunctorSalad> and it is complaining about no Ord instance?
15:35:37 <pumpkin> wow, what's subtract for?
15:35:42 <pumpkin> @src add
15:35:43 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
15:35:43 <mriou> no, I fixed that
15:35:56 <mriou> but that type parameter starts "polluting" all of my code when really, only ST cares about it
15:36:28 <mriou> it gets nasty
15:36:37 <qwr> harblcat: b x n = replicateM n (a x)
15:36:38 <mriou> see what I mean?
15:36:45 <FunctorSalad> mriou: you could use an existential, but then you won't be able to do anything with the s
15:37:02 <FunctorSalad> (unless you also add some contexts for s)
15:37:07 <harblcat> qwr: Exactly what I figured out. Thanks :)
15:37:26 <mriou> add some context?
15:38:14 <FunctorSalad> mriou: the existential version would look like this (shortened): data Wy where Wy :: forall s. ST s Something -> ...(other params)... -> Wy
15:38:43 <FunctorSalad> a context would be, for example,
15:38:53 <FunctorSalad> data Wy where Wy :: forall s. (Show s, Read s) => ST s Something -> ...(other params)... -> Wy
15:39:20 <FunctorSalad> ("Something" because I don't remember what you had there :))
15:39:43 <mriou> I have the following with the existential:
15:39:52 <mriou> data WyPrimitive = WyPrimitive String [String] [forall s. [ASTType] -> STRef s WyEnv -> ST s WyType]
15:40:32 <FunctorSalad> I think that makes it a universal rather than an existential, but I'm not sure
15:40:47 <FunctorSalad> (you need the forall at the front of the constructor)
15:40:56 <nekoniaow> I don't understand why throwDyn is in OldException, it seems it would be fine in the new one : throwDyn exception = throw (DynException (toDyn exception))
15:40:58 <mriou> ah, it's probably what I'm missing
15:41:23 <FunctorSalad> it is like in math, where " (forall x, P(x)) => Q " is different from " forall x, (P(x) => Q) "
15:41:34 <mriou> got it
15:42:06 <mriou> so the forall should be before the '=' ?
15:42:14 <mriou> I'm just unsure of the syntax
15:42:44 <FunctorSalad> I find the existential syntax with '=' weird so I gave you the GADT syntax above ;)
15:42:59 <FunctorSalad> but should be something like "data Wy = forall s. Wy ..."
15:43:04 <mriou> ah I see, I couldn't get what was this where
15:43:44 <mriou> sweet, GHC is happy with it
15:44:30 <mriou> and I can build the type and reuse it in another, exactly what I was looking for
15:44:34 <nekoniaow> forget what I said, I clearly don't understand that code enough to make any useful judgement
15:44:46 <nekoniaow> I'll go for the easy fix
15:45:16 <mriou> FunctorSalad: perfect, thanks for showing me the distinction between existential and universal
15:46:11 <harblcat> Is there a way to do message-passing in Haskell?
15:49:53 <dons> harblcat: there are many libraries for message passing like operations.
15:50:04 <dons> harblcat: you want to do async message passing on shared memory machines?
15:52:17 <harblcat> Well, I'm trying to understand Monads, and how they can have mutable state and such.
15:52:23 <harblcat> So I
15:52:44 <harblcat> I'd like to figure out if I could use something like the Actor model for programming.
15:52:53 <harblcat> Where a bunch of Actors talk with each other.
15:53:24 <pumpkin> they don't really have mutable state
15:53:28 <pumpkin> they sort of simulate it
15:53:29 <FunctorSalad> do I need "darcs get" rather than "darcs get --partial" if I'd like to send patch suggestions via darcs?
15:53:29 <litb> i found it's all based on tricks. they do not really mutate
15:54:07 <pumpkin> and by simulate, I mean make it seem like you have mutable state, not that they're performing some sort of simulation of state mutation :P
15:54:10 <litb> you get a bunch of >>= and fun calls and then you get other values out of previous ones
15:56:15 <dons> harblcat: yeah, actors are easy.
15:57:22 <harblcat> Can someone point me in the right direction?
15:58:30 <gwern> FunctorSalad: no
16:00:05 <FunctorSalad> ok
16:02:43 <dons> Lemmih: ok. posted to happs group on what i think should happen.
16:05:36 <mlesniak> @source join
16:05:37 <lambdabot> join not available
16:05:45 <mlesniak> @source Control.Monad.join
16:05:46 <lambdabot> Control.Monad.join not available
16:05:51 <byorgey> @src join
16:05:52 <lambdabot> join x =  x >>= id
16:06:01 <mlesniak> byorgey: thanks
16:06:04 <byorgey> sure =)
16:06:30 <byorgey> in some sense, join is more fundamental than >>=
16:06:54 <byorgey> you can implement >>= in terms of join and fmap (liftM) like so:  m >>= f = join (fmap f m)
16:06:55 <cknapp> In category theory, isn't it the functor that's definied?
16:07:10 <byorgey> cknapp: hmm?
16:07:25 <cknapp> join... isn't that one of two functors required for a monad?
16:07:35 <cknapp> (In category theory)
16:07:45 <cknapp> Functors... natural transformations
16:07:47 <cknapp> whatever...
16:08:05 <byorgey> cknapp: oh, I see
16:08:13 <byorgey> it's... not a functor, it might be a natural transformation
16:08:27 <byorgey> but yes, it's one of the three elements of a "triple" (which is another word for "monad")
16:08:32 <byorgey> return, fmap, and join
16:09:07 <greenrd> Why does this stop matching at the hyphen:
16:09:08 <cknapp> I see...
16:09:10 <greenrd> ("http://sulzmann.blogspot.com/2008/12/parallel-join-patterns-with-guards-and.html" =~ "^(http|https|ftp)\\://[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,3}(:[a-zA-Z0-9]*)?/?([a-zA-Z0-9\\-\\._\\?\\,\\'/\\\\\\+&%\\$#\\=~])*") :: String
16:09:24 <greenrd> I'm not a regex expert
16:10:05 <greenrd> and I guess this is not a haskell question actually, because it's just calling glibc's POSIX regex API (I think)
16:10:10 <gwern> wow. I guess you'd need to be to understand that
16:10:15 <greenrd> hehe
16:10:20 <greenrd> just found it on a regex site
16:10:24 <gwern> greenrd: I think most haskellers would at this point wipe out their thing
16:10:28 <gwern> by which I mean parsec
16:10:34 <gwern> *whip
16:11:12 <luite_> greenrd: hm, that doesn't seem to allow .info domains
16:11:26 <ksandstr> or .museum
16:11:44 <gwern> we have .museum now? good grief
16:12:19 <ksandstr> also .shop and .web
16:12:23 <luite_> and I haven't even tried to make sense of the last part ;)
16:12:32 <cknapp> Hmm?
16:12:48 <ksandstr> wait, no. those were only proposals. .coop, .aero and .name do exist
16:13:17 <mlesniak> I'm still confused, maybe someone has a hint: s <- join $ liftM (g h) (f h str) with types s,str :: String, f :: a -> String -> IO String and g :: a -> String -> IO String. My solution looks so ugly... Esp, since I'd like to chain a third function h with the same type signature after g. Is this the time to read about Monad readers?
16:13:39 <mlesniak> after \equiv before ;)
16:13:48 <mlesniak> argh: to the left of g
16:14:06 <FunctorSalad> halp, dependency weirdness http://hpaste.org/12818
16:14:44 <gwern> FunctorSalad: sure, but does it blend?
16:16:12 <FunctorSalad> blend?
16:16:40 <gwern> build, I meant
16:17:34 <FunctorSalad> hmm, that message intimidated me from even trying
16:17:59 <gwern> FunctorSalad: I mean, heck I see warnings like that all the time and nothing bad has happened to me (except to a few fingers)
16:19:19 <FunctorSalad> gwern: yes, it does build :)
16:19:48 <FunctorSalad> but sometimes you get some weird "the impossible happened" error only once you try to load the module
16:20:05 <FunctorSalad> I'm not sure whether that's caused by this
16:20:23 <gwern> FunctorSalad: I'd ignore those. the impossible by definition can't happen
16:20:43 <FunctorSalad> gwern: it's a fatal error, you can't ignore ;)
16:21:01 <mm_freak> is there any way to define defaults for constructor parameters?  especially in records
16:21:24 <gwern> just watch me! `Control.Exception.catch` (\_ -> tryTryAgain)
16:21:25 <greenrd> luite_: thanks
16:21:57 <greenrd> something stirred in the back of my brain "if you want to match - in a character class, it must be the first character"
16:22:09 <greenrd> and that seemed to fix my hyphen matching problem
16:22:58 <greenrd> I probably don't mean character class
16:26:12 <ddarius> mlesniak: s <- g h =<< f h str
16:26:39 <mlesniak> ddarius: ok, thanks, never saw =<<, where is it defined?
16:26:53 <ddarius> In Control.Monad.  It's just flip (>>=)
16:27:04 <mlesniak> *g* argh :) Thanks
16:27:05 <ddarius> You could just as well write: s <- f h str >>= g h if you preferred
16:27:24 <mlesniak> ddarius: at least this looks familiar :)
16:27:27 <gwern> > (read . show) $ "!@#%$^DFD"
16:27:29 <lambdabot>   * Exception: Prelude.read: no parse
16:27:51 <gwern> > ((read . show) $ "!@#%$^DFD" :: String)
16:27:53 <lambdabot>   "!@#%$^DFD"
16:28:03 <gwern> well, that makes sense
16:28:24 <FunctorSalad> is it possible to set up "cabal install" so it always does the haddock with --hoogle and --hyperlink-source?
16:29:20 <gwern> FunctorSalad: runhaskell Setup haddock can, so cabal-install should be able to eventually
16:29:48 <FunctorSalad> gwern: for that I need to cd, unpack etc. manually though :(
16:39:13 <gwern> FunctorSalad: cabal-install has internal support for --hoogle and --hyperlink, but I do not see it asa config or cli option
16:39:28 <gwern> FunctorSalad: is it possible that the --enable-documentation field covers those already?
16:42:09 <FunctorSalad> gwern: the --hoogle and --hyperlink-source are cli options of "cabal haddock", but there doesn't seem to be a  "caba install" or config option
16:42:24 <gwern> interesting
16:42:28 <FunctorSalad> gwern: not sure about hoogle, but my local haddocks don't have source code links :(
16:43:29 <gwern> FunctorSalad: quite
16:45:47 <redditbot> Neil Mitchell's Haskell Blog: F# from a Haskell perspective
16:45:47 <redditbot> Haskell it is. Or why I chose Haskell over Scala.
16:45:47 <redditbot> A HAppS Cookbook (hosted in gitit running on HAppS)
16:45:48 <redditbot> Haskell protocol-buffers version 1.2.2
16:45:50 <redditbot> Adding "deriving Functor " to GHC
16:46:43 <JuanDaugherty> redditbot: version
16:47:08 <dons> redditbot: help
16:47:14 <dons> i should make rss2irc support that.
16:47:20 <dons> it's the 'rss2irc' tool on hackage.haskell.org
16:47:28 <dons> which publishes new items from an rss feed to an irc channel
16:47:45 <JuanDaugherty> Acknowledged.
16:48:16 <dons> :)
16:50:02 <chessguy> @seen conal
16:50:02 <lambdabot> conal is in #haskell and #ghc. I last heard conal speak 3h 2m 49s ago.
16:50:12 <dons> everyone wants a bit of conal
16:50:35 <chessguy> yeah, i just wanted to finish a conversation with him that we started yesterday
16:51:12 <pumpkin> it would be nice to see a protocol-buffer based message-passing distributed computing framework in haskell
16:51:52 <gwern> redditbot seems a little strange. why only the title of a posting, and no link?
16:53:45 <pumpkin> it doesn't want you getting too lazy
16:53:53 <dons> gwern: yeah. i know.
16:54:03 <dons> i need to tweak rss2irc to by defualt print    the link
16:54:15 <dons> its just a command line tool. i accept patches.
16:54:23 <dons> hackagebot is the same tool
16:54:30 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/rss2irc
16:56:18 <dons> gwern: i accept patches (should be *trivial*)
16:56:39 <kfish> redditbot could just print the url, then lambdabot can print the title and tinyurl ;-)
16:56:47 <dons> oh, composition. woot
16:56:50 <gwern> dons: is doing something else right now
16:56:57 <gwern> kfish: I like the way you think!
16:56:59 <dons> gwern: you fixing wikipedia for me?
16:57:20 <dons> the current haskell page is the suxors. we should have one of the wonderful authors in the community work on it.
16:57:41 <gwern> dons: no, puzzling over some nasty recursive java; besides, I don't really see what's so bad about the current entry
16:58:06 <dons> people keep reading it and thinking hugs + research are what haskell is about.
16:58:22 <dons> which i don't think is accurate in 2009.
16:59:09 <gwern> well, you couldn't really ask for more from the introduction
16:59:18 <gwern> it's basically pure boosterism
16:59:48 <dons> the intro's fine.
16:59:57 <gwern> it ought to be, we wrote it...
17:00:00 <dons> but usual wiki issue: built up bit by bit without editorial oversight.
17:00:11 <dons> so lots of *ancient* stuff mixed in with bits of modernity
17:00:19 <gwern> hm. hugs and ghc are the de facto standard?
17:00:24 <gwern> is hugs still that popular?
17:00:37 <dons> no. when was the last time you saw someone write an app with hugs?
17:00:49 <gwern> 'strue
17:00:51 <dons> the wikipedia page retains legacies of its circa 2001..2 origin.
17:00:58 <kfish> i thought haskell was all about happs and gitit? what's this "research" thing you speak about?
17:01:07 <dons> kfish: i love you.
17:01:10 <chessguy> heh
17:01:22 <chessguy> yeah, and C++ is all about boost :)
17:01:36 <centrinia> I thought Haskell was all about monads and more monads.
17:01:45 <dons> centrinia: well, ok. i'll accept that.
17:01:56 <sjanssen> gwern: GHC is the de facto standard, IMO
17:01:59 <dons> i wonder if we can just take the structure from the history of haskell.
17:02:06 <sjanssen> gwern: though I don't know where you could find a citation for that
17:02:18 <gwern> sjanssen: maybe RWH says something like that
17:02:24 <dons> sjanssen: history of haskell paper or RWH.
17:02:43 <dons> the overview in RWH would make a decent structure
17:02:55 <dons> but overall what's the structure
17:03:00 <centrinia> Will there be a sequel to the paper, "A History of Haskell"?
17:03:24 <dons> we want to talk about: origins, current state, implementations, examples, open source, industry , research, criticisms, future, furthe rreading?
17:03:35 <dons> and community?
17:03:40 <dons> centrinia: in 20 years ?
17:03:45 <sjanssen> the list of characteristic features is a bit strange
17:03:46 <centrinia> Sure. :)
17:04:07 <centrinia> What would the Haskell community be like in 20 years?
17:04:10 <gwern> fibs = 0 : 1 : [ a+b | a <- fibs | b <- tail fibs ]
17:04:19 <gwern> does that really need parallel list comprehensions?
17:04:25 <dons> i think some of the primes examples are better stubs
17:04:29 <dons> fibs is too hackneyed
17:04:33 <gwern> > let fibs = 0 : 1 : [ a+b | a <- fibs, b <- tail fibs ] in fibs
17:04:33 <sjanssen> gwern: no, use zip
17:04:35 <lambdabot>   [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:04:49 <pumpkin> fail
17:04:59 <gwern> hm. that's interesting. chalk up another feature I could stand to learn
17:05:15 <sjanssen> > let fibs = 0 : 1 : zipWith (\a b -> a + b) fibs (tail fibs) in fibs -- the translation is fairly straightforward
17:05:17 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:05:28 <gwern> dons: well, there are other examples like one that defines Hamming numbers
17:05:29 <sjanssen> gwern: I wouldn't bother, nobody uses them
17:05:39 <FunctorSalad> http://hpaste.org/12821 -- emacs command for inserting the standard haskell file preamble, if anyone likes ;)
17:06:05 <gwern> dons: I agree the article could be better - the coverage of monads is poor for example
17:06:09 <nekoniaow> dons: If I'm allowed to voice my opinion I don't think that the wikipedia page on haskell is going to have any influence on its future, if anything is going to help haskell take off, it's the quality of the packaging that is presented to end users
17:06:10 <dons> gwern: is the CC license of rwh compat with wikipedia?
17:06:12 <Riastradh> pumpkin, list comprehensions don't diagonalize.  You need pairwise product, not a cartesian product (whether diagonalized or not), anyway.
17:06:20 <pumpkin> ?
17:06:21 <dons> gwern: i.e. we could use nice examples from RWH without legal issues?
17:06:23 <gwern> dons: no. the NC clause makes that impossible.
17:06:26 <dons> ah i see.
17:06:41 <gwern> that's why I told you guys to avoid NC, but I guess o'reilly insisted on it
17:06:50 <dons> well, we kinda have to. they spent money.
17:06:52 <skorpan> NC? nerd center?
17:07:04 <sjanssen> the RPN example is good
17:07:05 <dons> non-commercial
17:07:19 <olsner> btw, I built a JVM in haskell this weekend... anyone have a use for a JVM? :P
17:07:21 <gwern> dons: what CC does buy us, however, is that the wikipedia community has a sort of tacit, unspoken consensus that we can quote extensively CC stuff
17:07:24 <dons> so you can translate RWH for example, but you can't sell it.
17:07:30 <dons> gwern: ah interesting.
17:07:33 <kpreid> olsner: is it fast? :)
17:07:35 <nekoniaow> dons: I'm working in a field where functional programming would make huge sense, however, unless I can setup the equivalent of the F# environment for people to give it a try, there's no way they are going to use it
17:07:37 <dons> olsner: serious?
17:07:41 <dons> jvm bytecode interp?
17:07:46 <olsner> it's not quite done yet though
17:07:47 <FunctorSalad> couldn't you just grant a special license to WP?
17:07:54 <FunctorSalad> (re RWH)
17:07:56 <dons> nekoniaow: ok. so what do you need?
17:08:01 <gwern> dons: normally quotes would be fair use and we couldn't do more than a line or 3 unless really justified, but if it's from a CC work, editors will quietly tolerate up to 10 or more lines
17:08:03 <dons> nekoniaow: you asked earlier about something, what was that?
17:08:19 <dons> FunctorSalad: well, i'm not sure we care or it is that important.
17:08:26 <centrinia> > take 15 $ let linrec coeffs initials = let elements = initials ++ (zipWith (\coeff es -> map (* coeff) es) coeffs (scanl1 tail elements)) in elements in linrec [1,1] [0,1]
17:08:27 <lambdabot>   Couldn't match expected type `[a] -> [a]'
17:08:28 <kpreid> FunctorSalad: iiuc that doesn't work because WP content is supposed to be usable in non-WP works (under the GFDL)
17:08:30 <olsner> method calls aren't completely implemented, and it can't create instances yet :)
17:08:32 <gwern> dons: the idea being, 'why would someone licensing under any CC license want to sue us?' which is obviously not true for commercial fair use stuff...
17:08:43 <dons> yep
17:08:49 <kpreid> FunctorSalad: i.e. they don't want stuff licensed *uniquely to WP*
17:08:58 <FunctorSalad> kpreid: hmm...
17:08:59 <dons> o'reilly would get pissed if someone started selling the content they invested in
17:09:34 <centrinia> > take 15 $ let linrec coeffs initials = let elements = initials ++ (map sum $ zipWith (\coeff es -> map (* coeff) es) coeffs (scanl1 tail elements)) in elements in linrec [1,1] [0,1]
17:09:34 * sjanssen notes that the word "static" appears only once in the WP article, and isn't even in a proper sentence
17:09:35 <lambdabot>   Couldn't match expected type `[a] -> [a]'
17:09:37 <gwern> FunctorSalad: we reject stuff which is only allowed to wikipedia. this was laid down years ago; in '05 we banned photos licensed for wikipedia only. it's either GFDL compatible, or fair use
17:09:39 <olsner> kpreid: it is most definitely not fast :) maybe when I rebuild the interpreter part into some kind of compiler or llvm frontend
17:09:41 <centrinia> Damn.
17:09:53 <dons> so what do you think gwern, sjanssen ? just refactor bit by bit?
17:10:04 <dons> maybe i can put up a proposed structure on haskell.org's wiki for us to work towards
17:10:13 <dons> the spine of a decent article
17:10:32 <Botje> "haskell is full of win and awesome"
17:10:36 <gwern> dons: refactoring is best. one underhanded technique would be to add assertions to RWH, and then use RWH as the ref...
17:10:41 <Botje> too bad that falls under non-NPOV.
17:10:46 <gwern> since you guys have control of RWH, I take it
17:11:04 <nekoniaow> dons: my last question was related to the OldException module, but it's not quite relevant to the subject. But my current struggle is coming up with a working version of haskelldb for ghc 6.10. This being said, I'm slowly getting there
17:11:07 <dons> gwern: yes. refactoring. i want a goal to work towards. each key piece of the haskell world should be covered
17:11:10 <pumpkin> I saw a ruby talk today that mentioned haskell and monads (and tried to emulate them a bit)
17:11:16 <dons> nekoniaow: oh , haskelldb?
17:11:29 <dons> it is a bit unmaintained. i'd recommend hdbc , sqlite or takusen. all used commercially
17:11:34 <gwern> pumpkin: actually, reginald braithwait had a nice blog post in which he implemented monads in ruby, and then did Data.Maybe, iirc
17:11:38 <dons> galois has tried all over them, fwiw
17:11:43 <pumpkin> gwern: that's who gave the talk :)
17:11:52 <pumpkin> gwern: he seems like a cool guy
17:11:58 <gwern> pumpkin: oh. yes, that'd explain it
17:12:00 <pumpkin> one of the better talks I've seen
17:12:10 <dons> nekoniaow: by 'an F# environment' what did you mean?
17:12:12 <gwern> wonder why he hasn't blogged in forever?
17:12:14 <pumpkin> is he active in haskell too?
17:12:41 <gwern> raganwald? not epescially
17:12:50 <pumpkin> not a clue why he hasn't blogged, I hadn't even heard of him before seeing the talk
17:12:54 <pumpkin> a friend of mine blogged about it
17:12:58 <gwern> ah, it'd seem he's started a new blog
17:13:08 <gwern> http://github.com/raganwald/homoiconic/tree/master <-- strange
17:13:23 <nekoniaow> dons: well, the reason I selected haskelldb is that it allows to interface to the database without risking to form incorrect SQL queries
17:13:33 <dons> nekoniaow: right.
17:13:43 <dons> nekoniaow: so you get lots of safety. but at a pain of complexity
17:14:01 <nekoniaow> complexity ? how so ?
17:14:18 <dons> well, its more complex library, and harder  to build.
17:14:50 <nekoniaow> that's what the entity framework gives for c# and it provides a huge boost in productivity
17:14:57 <doublec> using github as a blog is interesting
17:15:40 <dons> nekoniaow: type safe SQL?
17:15:50 <gwern> doublec: I don't think it works well though - I haven't seen a single one on reddit or mentioned there
17:16:00 <nekoniaow> we're using it at my company and if I could present an equivalent on haskell that could help me sell functional programming through haskell
17:16:15 <pumpkin> gwern: that is strange
17:16:16 <dons> excellent. well also ask in haskell-cafe@
17:16:24 <dons> there are other libraries for type safe sql (deutsche bank has a nice one)
17:16:29 <dons> so you can ask around for more help to support your case.
17:16:31 <nekoniaow> dons: exactly
17:17:08 <nekoniaow> dons: is their library freely available ?
17:17:38 <dons> no, not as far as I know.
17:17:42 <dons> it is hard for them to release code.
17:17:58 <dons> but talk about your problem on haskell-cafe@ and ask for help.
17:18:00 <dons> you'll get lots of help
17:18:02 <JuanDaugherty> but not to use other peoples freely contributed
17:18:10 <nekoniaow> dons: I sent a mail yesterday already :)
17:18:41 <dons> JuanDaugherty: they support haskell in many ways (including code).
17:18:43 <nekoniaow> dons: I'll probably send patches when I get something working
17:19:27 <JuanDaugherty> dons: Acknowledged.
17:20:16 <nekoniaow> dons: but one thing I'm sure might be putting off lots of potential users is the fact that many libraries advertised on hackage don't build with ghc 6.10 or 6.8, that's certainly discouraging for professionals who would like to give the language a try
17:21:00 <dons> well, an awful lot do (more than hackage lists).
17:21:12 <dons> probably around 85% build (that's roughly what I have building)
17:21:17 <JuanDaugherty> but how much stuff requires 6.8 or greater?
17:21:20 <dons> but to help support people we can make that clearer.
17:21:33 <dons> JuanDaugherty: unknown. not much. the language hasn't changed significatnly
17:21:34 <JuanDaugherty> you don't have real churn with that
17:21:57 <dons> nekoniaow: so about 750 libs and apps build off hackage on arch linux, for example
17:22:42 <nekoniaow> dons: ok, that's impressive. I wasn't aware that so many existed. From haskell.org it looks like hackage is the only reference
17:22:54 <JuanDaugherty> *without
17:23:02 <dons> nekoniaow: "the only reference" ?
17:23:15 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/stats
17:23:24 <dons> >900 packages this week.
17:23:51 <Zero_In_Mood> yo some guys upto some nice action ? got a lil problem. n need to finish it before goign to bed.. i ll hpaste right now
17:24:02 <nekoniaow> oh, my bad. I need to get better at volume estimation
17:24:26 <dons> nekoniaow: i'm not sure i understand. you didn't realise how big hackage was? or what the break percentage was?
17:24:31 * JuanDaugherty feels better now about having 6.6.1 on every machine checked and wonders why the build process mentioned doesn't use an earlier and presumably common compiler.
17:24:37 <nekoniaow> I guess it's my bad luck that the packages I selected to try were the ones with building problems :)
17:24:40 <dons> people seem to be overestimating the instability, i've noticed.
17:25:02 <nekoniaow> dons: both actually
17:25:04 <dons> well, perhaps people select very large things since they look exciting?
17:25:06 <centrinia> > let linrec coeffs initials = let elements = initials ++ (map sum $ transpose $ zipWith (\coeff es -> map (* coeff) es) coeffs (iterate tail elements)) in elements in take 20 $ linrec [1,1] [0,1] -- Fibonacci numbers
17:25:07 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
17:25:08 <dons> they also tend to be harder to build
17:25:32 <ushdf> dons
17:25:47 <pumpkin> oh it's another nick for the syr.edu dude :o
17:25:54 <ushdf> you know the main function in the first example in chapter 3
17:26:02 <ushdf> it's not "another," this was the first nick
17:26:03 <Zero_In_Mood> http://hpaste.org/12824
17:26:05 <nekoniaow> it makes sense, anyway, that won't put me off, I really want to try haskell and haskelldb so I'll get there eventually :)
17:26:05 <pumpkin> aha :)
17:26:21 <Zero_In_Mood> as explained in the hpaste i need to write this function without list-comprehension and i cant come up with anythin good :(
17:26:32 <dons> nekoniaow: also look at takusen. it's nice. we use it at work.
17:26:46 <gwern> Zero_In_Mood: use 'filter'
17:26:49 <gwern> @hoogle filter
17:26:49 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
17:26:50 <lambdabot> Data.ByteString filter :: (Word8 -> Bool) -> ByteString -> ByteString
17:26:50 <lambdabot> Data.IntMap filter :: (a -> Bool) -> IntMap a -> IntMap a
17:26:50 <dons> that's a complicated list comprehension
17:27:02 <Zero_In_Mood> filter?
17:27:04 <gwern> he just has to break it down into filters one by one
17:27:19 <jsn> this works surprisingly well: http://github.com/jsnx/haskell-demos/tree/master/classes/Collapsible.hs
17:27:21 <gwern> which obviously must be possible, since aren't list comprehensions desugared into filters?
17:27:31 <nekoniaow> dons: I have it in my visor as well :)
17:27:36 <centrinia> Zero_In_Mood: [f a | a <- as] == map f as
17:27:39 <jsn> but didn't there use to be a restriction against partial application against type constructors?
17:27:52 <jsn> or is that only type synonyms?
17:27:55 <Zero_In_Mood> map...
17:27:56 <nekoniaow> got to go, thanks for the help everyone
17:27:59 <olsner> gwern: I thought they desugared into list-monady stuff
17:28:05 <Zero_In_Mood> hmm yh maybe i can do it with map
17:28:11 <olsner> since they were monad comprehensions before someone crippled them
17:28:18 <dons> jsn, you can't assign values to partially applied types
17:28:22 <gwern> olsner: dunno
17:28:37 <jsn> dons: aha
17:28:49 <jsn> dons: that seems reasonable
17:28:51 <dons> Prelude> let x :: Either Int ; x = undefined
17:28:52 <dons> <interactive>:1:9: `Either Int' is not applied to enough type arguments Expected kind `?', but `Either Int' has kind `* -> *'
17:28:52 <ushdf> in this bit right here dons
17:28:53 <ushdf>           case args of
17:28:53 <ushdf>             [input,output] -> interactWith function input output
17:28:53 <ushdf>             _ -> putStrLn "error: exactly two arguments needed"
17:28:59 <ushdf> uh
17:29:05 <jsn> dons: ah
17:29:07 <ushdf> is the putStrLn in the case
17:29:11 <ushdf> where args has no value
17:29:25 <dons> ushdf: it always has a value. it is for the case where it isn't a list of 2 elements.
17:29:26 <jsn> dons: but it's okay to have class instances with partially applied types, as in my example
17:29:27 <ushdf> or i mean, the else for where it has two acceptable values
17:29:29 <dons> so when the [x,y] pattern fails
17:29:33 <dons> the _ case is used.
17:29:34 <ushdf> yeah
17:29:37 <ushdf> ok
17:29:42 <FunctorSalad> ghci echoes every command, followed by ^J, in emacs, but not when called from the shell?
17:30:25 <ushdf> so _ means, when every other switch fails?
17:30:28 <ushdf> er, case
17:30:41 <dons> well, it is a pattern that matches any shape
17:30:54 <ushdf> so just "else," really
17:31:13 <dons> yes. it is the final match-all case
17:31:26 <pumpkin> "match anything and I don't care what it is" kind of thing
17:31:31 <Zero_In_Mood> centrinia : would be for genBmp1 = [V (map (genBmp 0)) (map (genBmp 0)) (map (genBmp 0)) (map (genBmp 0))] kinda liek that ?
17:31:44 <centrinia> No,
17:32:10 <jsn> dons: it seems i was really luck in this case
17:32:20 <Zero_In_Mood> dammn sry still have a lil problem with higher array
17:32:27 <jsn> dons: if the type were constructed in the opposite order, i couldn't do it
17:33:19 <jsn> is that surmise correct?
17:33:31 <centrinia> genBmp 1 = map (\t4 -> map (\t3 -> map (\t2 -> map (\t1 -> V t1 t2 t3 t4) (genBmp 0)) (genBmp 0)) (genBmp 0)) (genBmp 0)
17:33:54 <Zero_In_Mood> looking weird... that will take me a moment ^.^
17:34:59 <Zero_In_Mood> thou there is a lil problem..
17:35:08 <Zero_In_Mood> *** Type           : Int -> [[[[VTree]]]]
17:35:08 <Zero_In_Mood> *** Does not match : Int -> [VTree]
17:35:12 <centrinia> > (take 20 $ [a - b | a <- [1..6], b <- [1..5]], map (\b -> map (\a -> a - b) [1..6]) [1..5])  -- Here is an easier example
17:35:13 <lambdabot>   ([0,-1,-2,-3,-4,1,0,-1,-2,-3,2,1,0,-1,-2,3,2,1,0,-1],[[0,1,2,3,4,5],[-1,0,1...
17:35:38 <centrinia> > (take 20 $ [a - b | a <- [1..6], b <- [1..5]], take 20 $ concatMap (\b -> map (\a -> a - b) [1..6]) [1..5])  -- Here is an easier example
17:35:39 <lambdabot>   ([0,-1,-2,-3,-4,1,0,-1,-2,-3,2,1,0,-1,-2,3,2,1,0,-1],[0,1,2,3,4,5,-1,0,1,2,...
17:35:52 <centrinia> Okay, my desugaring is wrong. :(
17:36:09 <centrinia> > (take 20 $ [a - b | a <- [1..6], b <- [1..5]], take 20 $ concatMap (\a -> map (\b -> a - b) [1..6]) [1..5])  -- Here is an easier example
17:36:10 <lambdabot>   ([0,-1,-2,-3,-4,1,0,-1,-2,-3,2,1,0,-1,-2,3,2,1,0,-1],[0,-1,-2,-3,-4,-5,1,0,...
17:36:35 <pumpkin> can @undo undo list comprehensions too, or just do statements?
17:36:48 <pumpkin> @undo [x * 2 | x <- [1,2,3]]
17:36:49 <lambdabot> concatMap (\ x -> [x * 2]) [1, 2, 3]
17:36:49 <Zero_In_Mood> na no list-comprehension..
17:36:56 <centrinia> @undo [a - b | a <- [1..6], b <- [1..5]]
17:36:56 <lambdabot> concatMap (\ a -> concatMap (\ b -> [a - b]) [1 .. 5]) [1 .. 6]
17:37:00 <centrinia> Thanks. :)
17:37:22 <ushdf> :t concatMap
17:37:24 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
17:37:35 <pumpkin> @src concatMap
17:37:35 <lambdabot> concatMap f = foldr ((++) . f) []
17:37:40 <ushdf> :t foldl
17:37:41 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
17:38:57 <centrinia> @undo [(V t1 t2 t3 t4) | t1 <- (genBmp 0), t2 <- (genBmp 0), t3 <- (genBmp 0), t4 <- (genBmp 0)]
17:38:58 <lambdabot> concatMap (\ t1 -> concatMap (\ t2 -> concatMap (\ t3 -> concatMap (\ t4 -> [(V t1 t2 t3 t4)]) (genBmp 0)) (genBmp 0)) (genBmp 0)) (genBmp 0)
17:39:03 <centrinia> There. :)
17:39:41 * pumpkin barfs :P
17:40:01 <pumpkin> @pl concatMap (\ t1 -> concatMap (\ t2 -> concatMap (\ t3 -> concatMap (\ t4 -> [(V t1 t2 t3 t4)]) (genBmp 0)) (genBmp 0)) (genBmp 0)) (genBmp 0)
17:40:02 <lambdabot> (genBmp 0 >>=) . flip flip (genBmp 0) . ((=<<) .) . flip flip (genBmp 0) . ((flip . ((=<<) .)) .) . flip flip [] . ((flip . ((flip . ((:) .)) .)) .) . V =<< genBmp 0
17:40:03 <centrinia> Zero_In_Mood: I don't think that your definitions of genBmp 2 and genBmp h are correct.
17:40:05 * pumpkin barfs some more
17:40:17 <Zero_In_Mood> genBmp 2 is correct
17:40:19 <Zero_In_Mood> 100% sure..
17:40:25 <Zero_In_Mood> about genBmp h im still unsure too
17:40:34 <ushdf> > concatMap (enumFromTo 3) [1..10]
17:40:36 <lambdabot>   [3,3,4,3,4,5,3,4,5,6,3,4,5,6,7,3,4,5,6,7,8,3,4,5,6,7,8,9,3,4,5,6,7,8,9,10]
17:40:37 <Zero_In_Mood> thou i cant control cause i cant calculate the length of genBmp 3
17:40:48 <Zero_In_Mood> neither can count it by myself^^
17:40:56 <Zero_In_Mood> should be something around 2^64 or so^^
17:41:06 <pumpkin> Zero_In_Mood: what are you generating? all possible 4-branch trees with two leaves or something?
17:41:31 <Zero_In_Mood> na alle 4-branch trees where the leaves are all the same height far away from the root
17:41:36 <centrinia> Zero_In_Mood: Does the tree (V S S S (V S S S)) have a height of two?
17:41:40 <Zero_In_Mood> so height 0 = [S,W]
17:41:43 <pumpkin> ah
17:41:54 <pumpkin> what do S and W stand for?
17:41:56 <Zero_In_Mood> yes it has. but (V S S S (V S S S S)) aint possible..
17:42:00 <Zero_In_Mood> S = Schwarz = Black
17:42:00 <centrinia> Why not?
17:42:03 <pumpkin> ah
17:42:04 <Zero_In_Mood> W = Wei = white
17:42:09 <pumpkin> mmm 
17:42:19 <Zero_In_Mood> since the first 3 leaves are just 1 height away from the root sorry.. guess i didnt mention at all
17:42:40 <Zero_In_Mood> so height 2 trees are only (V (V x1 x2 x3 x4) (V ...... ) (V ....) (V .....))
17:43:09 <Zero_In_Mood> kinda like that. this thing had irritatin me all the time too my tutor just helped me today so that i understood that right
17:43:21 <centrinia> Zero_In_Mood: genBmp 3 can generate a tree (V (V S S S) (V S S S) (V S S S) (V (V S S S) (V S S S) (V S S S) (V S S S))
17:43:39 <ushdf> > concatMap (\x->(x,intToDigitX,x/2)) [1..10]
17:43:40 <Zero_In_Mood> nope...
17:43:41 <lambdabot>   Not in scope: `intToDigitX'
17:43:45 <ushdf> > concatMap (\x->(x,intToDigit x,x/2)) [1..10]
17:43:47 <lambdabot>   Couldn't match expected type `[b]'
17:43:52 <centrinia> Your definition of it can generate that tree.
17:44:06 <ushdf> oh yeah
17:44:18 <orbitz> is a 'localised state monad' just a nice tool if you want to write writ ea block of imperative code for whatever reason?
17:44:18 <Zero_In_Mood> genBmp 3 would be: (V (V (V...) (V...) (V...) (V...)) (V (V...) (V...) (V...) (V...)) ....)
17:44:19 <pumpkin> ushdf: you get what concatMap does?
17:44:23 <ushdf> yes, i do
17:44:30 <pumpkin> :)
17:44:42 <Zero_In_Mood> hmm which definition my genBmp h ? if yes i may have to edit it..
17:44:49 <Zero_In_Mood> i wasnt that sure with genBmp h.. :(
17:44:52 <centrinia> Zero_In_Mood: Your definition can generate a tree with a few height 1 branches and a few height 2 branches.
17:45:06 <ushdf> > concatMap (\x->2 mod x) [1..100]
17:45:08 <lambdabot>       No instance for (Num ((a1 -> a1 -> a1) -> a -> [b]))
17:45:08 <lambdabot>        arising fro...
17:45:12 <Zero_In_Mood> damn :(
17:45:38 <redditbot> Compact data types : Luke Palmer
17:45:42 <ushdf> i don't remember what i was trying to do now
17:45:55 <centrinia> Zero_In_Mood: Here you should just use a single definition for heights greater than zero: genBmp h = [(V t1 t2 t3 t4) | t1 <- (genBmp (h-1)), t2 <- (genBmp (h-1)), t3 <- (genBmp (h-1)), t4 <- (genBmp (h-1))]
17:45:58 <dons> so we really need the url there. ok.
17:46:07 <ushdf> map (\x->intToDigit x) [1..100]
17:46:24 <ushdf> > map (\x->intToDigit x) [1..100]
17:46:26 <lambdabot>   "123456789abcdef* Exception: Char.intToDigit: not a digit 16
17:46:29 <ushdf> hehe
17:47:11 <pumpkin> that seems rather narrow of intToDigit
17:47:18 <pumpkin> > intToDigit 15
17:47:19 <lambdabot>   'f'
17:47:27 <pumpkin> it should take a base, imo :P
17:47:37 <pumpkin> > intToDigit 16
17:47:38 <lambdabot>   * Exception: Char.intToDigit: not a digit 16
17:47:59 <Zero_In_Mood> hmm yeah okay.. so i had a mistake in my normal with list comprehension :(
17:48:34 <ushdf> > map (x->chr x) [1..26]
17:48:35 <lambdabot>   <no location info>: parse error on input `->'
17:48:40 <ushdf> > map (\x->chr x) [1..26]
17:48:41 <lambdabot>   "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SYN\E...
17:49:36 <ushdf> @src Maybe
17:49:37 <lambdabot> data Maybe a = Nothing | Just a
17:50:10 <ushdf> so let me guess, the way to capture an input stream is through the maybe type
17:50:38 <centrinia> > concatMap intToDigit [13,14,10,13,11,14,14,15]
17:50:40 <lambdabot>   Couldn't match expected type `[b]' against inferred type `Char'
17:51:23 <centrinia> > map intToDigit [13,14,10,13,11,14,14,15]
17:51:24 <lambdabot>   "deadbeef"
17:51:43 <pumpkin> ushdf: all those (\x -> f x) you've been writing can be written more legibly as just f :)
17:52:15 <pumpkin> > map chr [1..26]
17:52:17 <lambdabot>   "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SYN\E...
17:52:17 <centrinia> @pl (\x -> f x)
17:52:17 <lambdabot> f
17:52:31 <pumpkin> > map chr ['a'..'z']
17:52:31 <centrinia> pumpkin: That's pointless. :)
17:52:32 <lambdabot>   Couldn't match expected type `Int' against inferred type `Char'
17:52:46 <pumpkin> centrinia: oh no! I always knew my existence was pointless
17:52:58 <ushdf> > map chr [66,79,79,66,73,69,83]
17:52:59 <lambdabot>   "BOOBIES"
17:53:02 <pumpkin> lol
17:53:14 * pumpkin hopes Philippa_ isn't watching :)
17:53:16 <centrinia> I meant that your reduction of (\x -> f x) to f was pointless. :)
17:53:27 <pumpkin> centrinia: :'(
17:53:38 <ushdf> i know if f is defined, i can do that fine
17:53:42 <Philippa_> pumpkin: now there's a way to summon someone
17:53:46 <ushdf> just trying to grind the lambda into my mind
17:53:54 * pumpkin hides, sowwy
17:54:38 <centrinia> Haskell functions accept only single arguments. :)
17:54:51 <Gracenotes> > map ord "test"
17:54:53 <lambdabot>   [116,101,115,116]
17:55:00 <ushdf> if you define the combination of several arguments as one argument
17:55:01 <ushdf> sure ;)
17:55:09 <centrinia> ushdf: No.
17:55:21 * ushdf coughs
17:55:22 <Philippa_> ushdf: please don't throw terms for female anatomy around. It doesn't exactly help the channel's gender balance or reputation
17:55:26 <centrinia> The addition operator only accepts one argument.
17:55:34 <ushdf> how's that
17:55:50 <centrinia> :t (+) 1
17:55:51 <lambdabot> forall t. (Num t) => t -> t
17:55:52 <ushdf> i didn't say it, lambdabot did
17:55:55 <centrinia> That's a function.
17:55:57 <Zero_In_Mood> got it :)
17:56:24 <pumpkin> ushdf: a type of a -> b -> c -> d is interpreted as a -> (b -> (c -> d)), if that helps
17:56:30 <Philippa_> ushdf: right, clearly that had absolutely nothing whatsoever to do with your having encoded it in the code you fed the bot
17:56:58 <Philippa_> oh, wait, now I think about it...
17:57:00 <Zero_In_Mood> ill hpaste it maybe u wanna look over it centrinia
17:57:13 <centrinia> Okay.
17:57:23 <lucca> :t unsafeInterleaveIO
17:57:25 <lambdabot> Not in scope: `unsafeInterleaveIO'
17:57:40 <Zero_In_Mood> http://hpaste.org/12824#a1
17:58:03 <Zero_In_Mood> i just fixxed in concatMap to ur first diea to get rid of thopse [[[[VTree]]]] shit :D
17:58:14 <ushdf> what are we arguing about again
17:58:41 <ushdf> i know when people say "penis" i get all offended at the bias of the chatroom against males
17:58:57 <ushdf> > map (+1) [1..3]
17:58:59 <lambdabot>   [2,3,4]
17:59:04 * ushdf rocks out
17:59:30 <Philippa_> it's not equivalent, and even if it were: it doesn't matter whether you'd be fine with it, just whether the people on the receiving end are
17:59:43 <pumpkin> ushdf: the issue is, would you say boobies in the presence of women you barely knew, normally? you might say it in a room full of only guys, but this isn't a room full of only guys, and we don't want people who aren't guys to feel that everyone assumes they don't exist
17:59:48 <centrinia> Zero_In_Mood: You don't really need the definition of genBmp 1
18:00:06 <ushdf> i'm not responsible for your insane social constructs
18:00:17 <Zero_In_Mood> hmm yeah i know centrinia..
18:00:22 <Zero_In_Mood> it was just for help...
18:00:23 <Philippa_> actually, you're contributing to them right now
18:00:30 <ushdf> i don't buy that
18:00:38 <ushdf> i preach equality
18:00:43 <pumpkin> blah blah blah
18:00:56 <Zero_In_Mood> bah thx for ur help centrinia
18:01:04 <Zero_In_Mood> this two function are 4points out of 12 :)
18:01:04 <Philippa_> yeah, I've heard that before. It tends to be equality on the person who says its' terms, conveniently optimised for them
18:01:32 <Philippa_> that said: if people start saying "penis" in the same way and someone complains, I'll act on that too
18:01:33 <centrinia> > concatMap (\n -> (show n) ++ " bottles of beer on the wall, " ++ (show n) ++ " bottles of beer. Take one down, pass it around, " ++ (show (n-1)) ++ " bottles of beer on the wall\n") [99,98..1]
18:01:34 <lambdabot>   "99 bottles of beer on the wall, 99 bottles of beer. Take one down, pass it...
18:02:07 <Zero_In_Mood>  concatMap (\n -> (show n) ++ " bottles of beer on the wall, " ++ (show n) ++ " bottles of beer. Take one down, pass it around, " ++ (show (n-1)) ++ " bottles of beer on the wall\n") [98..1]
18:02:12 <Zero_In_Mood> like this ? ^.^
18:02:23 <mauke> <olegfink> if I handle everything correctly, I'll get the haskell version
18:02:27 <centrinia> Yes.
18:02:33 <mauke> from #ocaml, slightly out of context :-)
18:02:43 <centrinia> Except that you should apply it to [99,98..1]
18:03:14 <Zero_In_Mood> hmm didnt get it now ^.^ hmm maybe
18:03:22 <Zero_In_Mood>  concatMap (\n -> (show n) ++ " bottles of beer on the wall, " ++ (show n) ++ " bottles of beer. Take one down, pass it around, " ++ (show (n-1)) ++ " bottles of beer on the wall\n") [98,97..1]
18:03:29 <Zero_In_Mood> na not at all ^^
18:03:42 <Zero_In_Mood> or the bot aint like me :(
18:03:43 <centrinia> What happened to the 99th bottle of beer? :(
18:03:49 <Zero_In_Mood> u took it^^
18:03:54 <centrinia> You should start your comment with a '>'
18:04:10 <centrinia> > 1+1
18:04:11 <lambdabot>   2
18:04:30 <Zero_In_Mood> 2+2
18:04:36 <Zero_In_Mood> aww so mean :(
18:04:46 <centrinia> > 2+2
18:04:47 <lambdabot>   4
18:04:49 <Beelsebob> , 2+2
18:04:50 <Zero_In_Mood> :f concatMap
18:04:57 <lunabot>  4
18:04:57 <Zero_In_Mood> nvm i ll use winhugs for that^^
18:05:34 <pumpkin> btw, http://jyte.com/cl/oleg-should-start-a-blog-and-get-into-haskell
18:05:42 <mriou> hey, I'm having some headaches again with an existential type
18:05:45 <mriou> data WyPrimitive = forall s. WyPrimitive String ([ASTType] -> STRef s WyEnv -> ST s WyType)
18:05:56 <mriou> when I pattern match on that sucker
18:06:08 <mriou> applyPr (WyPrimitive n fn) ps env = fn ps env
18:06:26 <mriou> I get the irritating "Inferred type is less polymorphic than expected"
18:06:53 <mauke> s leaks out of the expression
18:07:05 <pumpkin> leaky s-expressions??
18:07:18 <mriou> heh
18:07:45 <mriou> could you elaborate a little?
18:08:00 <centrinia> It is offensive to talk about Sexpressions.
18:08:18 <pumpkin> that's why people tend to add the hyphen :)
18:08:35 <mauke> well, my intuition says you can unwrap existentials with pattern matching as long as the result type looks normal, i.e. you box it back up
18:08:38 <Philippa_> centrinia: yeah, that's what Beautiful Agony is for
18:08:55 <pumpkin> wow, people have heard of that site :o
18:09:07 <qwr> pumpkin: add where? :P
18:09:18 <pumpkin> qwr: sex-pressions, of course
18:09:24 <pumpkin> oh wait...
18:09:27 <qwr> that i thought :)
18:09:40 <mauke> data T = forall s. C s;  ... case x of C x -> x  -- invalid, the type of x contains the hidden existential s
18:10:35 <mriou> so how can you box it back?
18:10:42 <mauke> data T = forall s. (Num s) => C s;  ... case x of C x -> C (x * 2)  -- ok, C hides s behind T
18:11:10 <mauke> data T = forall s. (Show s) => C s;  ... case x of C x -> show x  -- also ok
18:11:29 <heatsink> Can you wrap the result in another WyPrimitive?
18:12:03 <centrinia> Yeah, you can show a list such as [C "Hello World!", C False, C 42, C [C "Hello World!", C True, C 69]]
18:12:16 <blackh> Philippa_: How about a website with videos of people programming Haskell from the neck down?
18:12:22 <mriou> mmh that's not really the goal
18:13:14 <mriou> but what I'm returning is supposed to still carry the existential type
18:13:19 <lucca> Control.Concurrent.Chan has a getChanContents, but STM's TChan has nothing equivalent.
18:13:28 <ushdf> ugh
18:13:30 <ushdf> what were we arguing about
18:13:34 <ushdf> somebody jammed my cat in a door
18:13:35 <centrinia> Isn't videos of Haskell programming a little too risque?
18:13:46 <mriou> if you look at the type definition:
18:13:46 <mriou> data WyPrimitive = forall s. WyPrimitive String ([ASTType] -> STRef s WyEnv -> ST s WyType)
18:14:08 <mriou> applying that function should return ST s WyType
18:14:21 <ushdf> and we can all just forget about expert sexchane
18:14:24 <mauke> it returns exists s. ST s WyType
18:14:26 <ushdf> sexchange
18:14:29 <centrinia> ushdf: Here are the Joy of Cats: http://katmat.math.uni-bremen.de/acc/acc.pdf
18:14:58 <heatsink> mriou: Mauke is right, and you can't run that.  If anything, you want a forall s. ST s WyType.
18:14:58 <mriou> right
18:15:11 <mauke> mriou: are you sure you don't want WyPrimitive String (forall s. [ASTType] -> STRef s WyEnv -> ST s WyType) instead?
18:15:22 * centrinia thinks that "expert sexchange" is a more appropriate description of "experts exchange" :)
18:15:48 * ushdf hoped to imply that
18:15:51 <Philippa_> what, you'd let the people there near your crotch with a knife?
18:16:13 <mriou> I've tried that but I've been told earlier that it wasn't existential but universal or something
18:16:29 <mriou> and had some other problems with it
18:16:41 <pumpkin> experts exchange is not my favorite website
18:16:48 <lucca> further, atomically won't mesh with unsafeInterleaveIO... hm
18:17:15 <ushdf> language is the consensus upon what its terms mean
18:17:26 <ushdf> "penis" refers to the appendage in the male genital area
18:17:30 <lucca> how do you Lazily pull committed things from a TChan?
18:17:39 <ushdf> "boobies" refers to the devices used for nursing on the female chest
18:17:47 <lucca> please stop this.
18:17:53 <ushdf> it does NOT mean, however
18:17:58 <ushdf> "women are inferior to men"
18:18:03 <ushdf> or "haskell is meant for women"
18:18:19 <ushdf> or any such PRESCRIPTIVE as opposed to DESCRIPTIVE statements
18:18:29 * ushdf stops that
18:18:34 <roconnor> > do {mapM_ (replicate 100000 [1..10000]); return 1}
18:18:35 <lambdabot>   Couldn't match expected type `a -> m b'
18:18:40 <pumpkin> bah
18:18:48 <roconnor> > do {sequence_ (replicate 100000 [1..10000]); return 1}
18:18:53 <Philippa_> ushdf: I don't believe your poor attempts to justify your misbehaviour are on-topic for this channel. I'm in a position to enforce my beliefs. You may wish to bear that in mind
18:19:03 <lambdabot>   mueval: Prelude.read: no parse
18:19:17 <ushdf> but we're all in a position where our beliefs are malleable in the face of reason
18:19:24 <roconnor> > do {sequence_ (replicate 1000 [1..1000]); return 1}
18:19:29 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:19:38 <ushdf> > fix (1:)
18:19:39 <roconnor> ah ooops
18:19:40 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:19:46 --- mode: ChanServ set +o Philippa_
18:19:54 <roconnor> > do {sequence_ (replicate 1000 [1]); return 1}
18:19:54 * ushdf frowns
18:19:55 <lambdabot>   [1]
18:20:00 <mriou> mauke: trying againWyPrimitive String (forall s. [ASTType] -> STRef s WyEnv -> ST s WyType) gives me an "Illegal polymorphic or qualified type"
18:20:06 <roconnor> > do {sequence_ (replicate 1000000 [1]); return 1}
18:20:08 <lambdabot>   * Exception: stack overflow
18:20:22 <roconnor> damn it
18:20:46 <Philippa_> ushdf: drop it. Without any further attempts to knock people for disagreeing with you.
18:20:55 <roconnor> @undo do {sequence_ (replicate 1000000 [1]); return 1}
18:20:56 <lambdabot> sequence_ (replicate 1000000 [1]) >> return 1
18:21:37 <ushdf> i didn't pick it up to begin with
18:21:39 <roconnor> damn it.  why a stack overflow?
18:21:41 <ushdf> i just want to use lambdabot
18:21:52 <pumpkin> ushdf: you can use lambdabot in pm as much as you want :)
18:21:58 <heatsink> mriou: maybe you need -XRankNTypes?
18:22:30 <ushdf> i can use prelude too
18:22:39 <mauke> mriou: {-# LANGUAGE RankNTypes #-}
18:23:09 <pumpkin> > map chr [112,108,101,97,115,101,32,100,111,110,39,116,32,115,97,121,32,116,104,105,110,103,115,32,112,101,111,101,112,108,101,32,102,105,110,100,32,111,102,102,101,110,115,105,118,101,32,105,110,32,35,104,97,115,107,101,108,108]
18:23:10 <lambdabot>   "please don't say things peoeple find offensive in #haskell"
18:23:22 <pumpkin> see, even lambdabot agrees :)
18:23:32 <mriou> mauke, heatsink: trying
18:24:02 <pumpkin> > think
18:24:04 <lambdabot>   "think twice"
18:24:36 <pumpkin> > think >> think
18:24:37 <lambdabot>   "think twicethink twicethink twicethink twicethink twicethink twicethink tw...
18:24:39 <pumpkin> oh no
18:25:06 <ushdf> i take offense to nearly everything operators say
18:25:24 <pumpkin> :(
18:25:43 <centrinia> ushdf: Try to get the operators to take offense at everything you say. :)
18:25:44 <Philippa_> ushdf: like I said, drop it
18:25:52 <Philippa_> pumpkin: you should leave it here too
18:25:59 <pumpkin> yup :)
18:26:39 <ushdf> naturally it boils down to "might is right"
18:26:58 <ushdf> as in any situation of disparity
18:27:17 <ushdf> if you think my notions of semantics are purely self-serving, Philippa_, explain why i've spent the last 5 years writing abstract poetry
18:27:17 <pumpkin> maybe take it to #haskell-blah?
18:27:32 --- kick: ushdf was kicked by Philippa_ (#haskell You've been warned)
18:28:06 <ushdf> you may be the op in #haskell, Philippa_, but now i'm the op in #Philippa
18:28:24 <Philippa_> this isn't a case of might is right, but you don't appear to be acting in good faith. The next one has a +b attached.
18:28:42 <Philippa_> oh boo hoo. Clearly that will ruin me.
18:28:47 <ushdf> you don't appear to be able to evaluate what quality my faith possesses!
18:28:50 <ushdf> * orwell.freenode.net sets mode: +ns
18:29:33 <pumpkin> ushdf: can't you just get back to playing with lambdabot and asking occasional haskell questions? :)
18:29:50 <ushdf> that's what i was doing
18:30:21 <pumpkin> @users
18:30:22 <lambdabot> Maximum users seen in #haskell: 568, currently: 513 (90.3%), active: 16 (3.1%)
18:30:39 <pumpkin> oooh almost an integer power of 2
18:30:58 <heatsink> Um.  slightly in excess of an integer power of two.
18:30:59 <centrinia> Well, at least syr.edu doesn't use bad ASP for its web site. :)
18:31:13 <Philippa_> hah. By the time I actually read Snow Crash I didn't actually have that issue any more
18:31:15 <ushdf> (they do, actually)
18:31:31 <ushdf> maybe not the main one
18:31:47 <ushdf> the whole American educational infrastructure uses bad ASP
18:31:52 <centrinia> Is ChanServ one of the users?
18:32:20 <Elly> we do not use bad ASP
18:32:22 <pumpkin> our site doesn't even use ASP, afaik
18:32:22 <centrinia> ushdf: I agree.
18:32:31 <Elly> mostly because we own a grand total of zero windows servers
18:32:34 <ushdf> it was a metaphor
18:34:29 <pumpkin> is Happs its own http server? or does it leverage something else for that?
18:35:05 <ushdf> i think it's more like a framework
18:35:14 <bos> It's both.
18:35:49 <pumpkin> ah ,there's happs-http right near the top of their site
18:36:01 <centrinia> Can HAppS be used with the Gopher protocol?
18:36:19 <pumpkin> are there even any clients for gopher anymore?
18:36:48 <ushdf> http://happs.org/repos/happs.org/src/Main.hs
18:36:49 <centrinia> Everyone uses port 70. :)
18:37:01 <repnop> pumpkin: firefox ;p
18:37:23 <pumpkin> :o
18:37:41 <doublec> repnop, gopher was removed from firefox
18:38:18 <repnop> works on my system
18:38:21 <ushdf> well really
18:38:23 <ushdf> other way around
18:38:25 <repnop> firefox 3
18:38:31 <ushdf> mosaic -> netscape -> mozilla -> firefox
18:38:40 <doublec> oh right, sorry, there's a bug for it
18:38:45 <doublec> https://bugzilla.mozilla.org/show_bug.cgi?id=388195
18:38:48 <centrinia> It works here as well. :)
18:39:01 * ushdf used mosaic
18:39:15 * centrinia uses lynx.
18:39:25 * ushdf uses dillo
18:39:34 * ushdf stares intently at centrinia
18:39:36 <pumpkin> I use netcat
18:39:48 <repnop> yeah that request hasn't gone anywhere yet it appears
18:39:53 <pumpkin> y'all are too high-level for m
18:40:20 <ushdf> i write out my packets by hand
18:40:23 * mokus taps the dsl cable with his tongue
18:40:25 <Philippa_> pumpkin: wimp. You should breed your own pigeons and use TCP/IP over avian carrier so you can hand-crank the rest
18:40:29 <ushdf> and throw them at strangers until one of them reads it and delivers it
18:40:43 <ushdf> that RFC is old news
18:40:46 <centrinia> Lynx supports gopher too. :)
18:40:47 <ushdf> mine is much cooler
18:41:03 <pumpkin> Philippa_: don't be silly, that'd just be making unnecessary work for myself ;)
18:41:18 <Philippa_> yeah, but you'd get the odd fried egg too
18:42:08 <centrinia> Is there an IP over snail mail, or does IP over avian carrier handle that?
18:43:25 <ushdf> concatMap lines ["hellohow\nareyou\n\doing","hellohow\nareyou\n\doing","hellohow\nareyou\n\doing"]
18:43:30 <ushdf> > concatMap lines ["hellohow\nareyou\n\doing","hellohow\nareyou\n\doing","hellohow\nareyou\n\doing"]
18:43:31 <lambdabot>   <no location info>:
18:43:32 <lambdabot>      lexical error in string/character literal at chara...
18:43:39 <ushdf> screw you lambdabot
18:43:45 <pumpkin> you have \d in there
18:43:55 <nzeh> Hi folks, is there any way to access a function not exported by a package?  The reason why I would like this is to write test code that includes unit tests for the internals of my package, and I would like to keep it separate from the actual package implementation.  Any help would be appreciated.
18:43:58 <ushdf> > concatMap lines ["hellohow\nareyou\ndoing","hellohow\nareyou\ndoing","hellohow\nareyou\ndoing"]
18:43:59 <lambdabot>   ["hellohow","areyou","doing","hellohow","areyou","doing","hellohow","areyou...
18:44:07 <dons> ushdf: are you being very noisy again?
18:44:23 * ushdf throws up on pumpkin
18:44:32 <pumpkin> :o
18:44:40 <ushdf> it's not my fault, it's society's
18:44:42 * pumpkin ,being just a squash, doesn't really mind
18:44:44 --- mode: ChanServ set +o dons
18:44:50 --- mode: dons set +b *!*=ushdfgak@*.syr.edu
18:44:50 --- kick: ushdf was kicked by dons (try again in 2 days)
18:45:06 <mokus> nzeh: what I've seen done before to solve that issue is to make an additional build target in a cabal package for the tests which has both the test dir and the main src dir listed as the source dirs
18:45:08 --- mode: ChanServ set -o dons
18:45:34 <mokus> then pack up the non
18:45:37 <dons> he has a long history of refusing to 'moderate'. that is, he feels it is his philosophical right to go off topic and disrupt. very problematic :/
18:45:41 <mokus> -exportable stuff in a non-exported module
18:46:00 <nzeh> mokus: And how does this solve my problem?  Sorry if I'm being thick.
18:46:26 <ddarius> dons: It would be slightly less of a problem if he was remotely constructive in the meantime, but that is not the case.
18:46:40 <mokus> nzeh: it may or may not, depending whether you can effectively expose everything you want to in a module that doesn't get exported to the rest of the world
18:47:00 <dons> ddarius: right. glguy and i've been looking at him for about 6 months.
18:47:08 <mokus> nzeh: basically, rather than trying to get into the non-exported functions, you get at the exported functions of a non-exported module
18:47:16 <dons> ddarius: but yes, very poor signal/noise
18:47:48 <nzeh> mokus: Ah, that might be a workable solution.  Thanks.
18:48:40 <centrinia> He has been here for at least six months and doesn't regularly get banned? :O
18:48:58 <dons> centrinia: no. he's been banned mostly.
18:49:01 <centrinia> Oh.
18:49:04 <dons> centrinia: but similar issues in other channels
18:49:16 <dons> he has an ideological belief in not moderating.
18:49:24 <twxnf> that's absolutely true
18:49:26 <dons> which causes problems. that and making no authentic contributions
18:49:29 <twxnf> and you can see why
18:49:37 --- mode: ChanServ set +o dons
18:49:40 <twxnf> i'll make contributions once i actually learn the language
18:49:55 <twxnf> and now i get banned for 'ban-evading'
18:50:15 --- mode: ChanServ set +o glguy
18:50:21 --- mode: glguy set +b *!*@syru217-183.syr.edu
18:50:39 --- mode: glguy set -b *!*=ushdfgak@*.syr.edu
18:50:43 <dons> thanks.
18:50:44 --- mode: ChanServ set -o dons
18:51:04 <pumpkin> was that his /part message, or does someone have /sapart or equivalent around here?
18:51:20 <dons> so i think we just keep him out for a few days and see. but i'm not hopeful, sadly.
18:51:37 <ddarius> Why would you think anything would change?
18:51:51 <dons> well, some percent of the human population can learn with training.
18:52:04 --- mode: Philippa_ set -o Philippa_
18:52:11 <dons> we've had 13.5k nicks in here. of which about 5 were unresponsive to training
18:52:16 <centrinia> That's optimistic. :)
18:52:17 <dons> > 5 / 13500 * 100
18:52:18 <lambdabot>   3.7037037037037035e-2
18:52:26 <dons> so he might be in the 'untrainable' bag.
18:52:59 <centrinia> @karma ushdf
18:52:59 <lambdabot> ushdf has a karma of 0
18:53:24 <JuanDaugherty> does moderate in this context mean moderate ones opinion?
18:53:25 <mokus> I'd be interested to know the conditional probability of untrainability given behavior like that
18:53:27 <glguy> sad day for syr.edu
18:53:38 --- mode: glguy set +b *!*@*.syr.edu!#haskell-ops
18:53:49 <dons> glguy: ok.
18:53:57 <dons> i'll check the logs for who else is there.
18:54:03 <Philippa_> mokus: it's not 1
18:54:45 <centrinia> Syracuse University will be without FreeNode #haskell. :(
18:54:49 <dons> glguy: looks like just him. getting banned since august.
18:54:56 <mokus> Phillipa_: yea, I wouldn't expect it to be - I have my own optimistic tendencies.  but I'm pretty sure it's a lot worse than the 0.4 lawbdabot just showed us
18:55:03 <pumpkin> JuanDaugherty: I'd assume so, or to be less obnoxious in the face of people obviously not liking what you have to say
18:55:09 <dons> centrinia: no, that's a redirect ban. it sends them elsewhere to get a talking to
18:55:18 <centrinia> Oh.
18:55:24 <mokus> 0.4% that is
18:55:53 <ddarius> mokus: He already multiplied by 100
18:56:00 <JuanDaugherty> pumpkin, Acknowledged. Seems unfair to lock out syracuse uni in it's entirety.
18:56:34 <pumpkin> JuanDaugherty: as they said, it's a redirect ban, so the good guys can still talk to the ops and be let in
18:56:37 <mokus> ddarius: right, I was just converting back to raw probability since Phillipa_ mentioned a 1
18:57:12 <mokus> ddarius: that is to say, I was only correcting myself
18:57:14 <ddarius> mokus: It's 0.04% or 0.0004
18:57:42 <mokus> ddarius: oh well, I guess I just can't do math on the weekends ;-)
18:57:46 <dons> heh
18:57:49 <JuanDaugherty> back to the matter of some distros failing to build because 6.8 and later cause the packages not to
18:58:29 <JuanDaugherty> why in fact isn't there a well known stable level that build could use (e.g. 6.6)?
18:58:57 <JuanDaugherty> or isn't just a matter of they didn't?
18:59:04 <JuanDaugherty> but could have.
18:59:28 --- mode: glguy set -ob glguy *!*@syru217-183.syr.edu
18:59:42 <JuanDaugherty> s/isn't/is it/
19:00:38 <JuanDaugherty> because forward and not backward compatibility is the norm
19:01:31 <JuanDaugherty> or actually it's the reverse, but that seems to be acknowledge to be not applicable here
19:01:33 <dons> JuanDaugherty: well, .cabal files should now let us get backwards compat.
19:01:42 <dons> do you know about the .cabal versioning system we use?
19:01:47 <JuanDaugherty> *acknowledged
19:02:28 <JuanDaugherty> (i.e. empirically attested by the failed build in question)
19:06:10 <JuanDaugherty> dons, ah I see. So it's lib/pkg changes not ghc itself.
19:10:27 <JuanDaugherty> *distro
19:12:58 <wy> hello
19:13:15 <blackh> hello!
19:13:59 <wy> I'm looking at darcs' theory of patches. Anyone familiar with that?
19:14:01 <byorgey> hi wy!
19:14:11 <byorgey> ooh, pick me, pick me! =)
19:15:06 <wy> It reminds me of some database theories, but I'm not sure whether they are related
19:15:26 <byorgey> hmm, I don't know enough about database theories to make the comparison
19:17:58 <byorgey> wy: http://byorgey.wordpress.com/2008/02/13/patch-theory-part-ii-some-basics/
19:19:02 <wy> byorgey: wow! I ran into the right person!
19:19:18 <cjs> Ooo...implicit parameters.
19:19:29 <byorgey> yeah, I've spent some time thinking about this in the past
19:19:42 <cjs> There really ought to be a book that covers all this new and groovy post-Haskell-98 stuff.
19:19:52 <byorgey> wy: Igloo, Heffalump, and lispy are also good people to talk to (all of them know more than I do)
19:23:18 <byorgey> cjs: well, there are plenty of academic papers that cover it =)
19:25:42 <cjs> True, but I'm thinking about something for working programmers to give an overview of basic extensions that are quite useful in daily life.
19:27:31 <cjs> Implicit parameters just fixed a rather annoying problem for me, Pattern guards fixed another one a while back. Existential types fixed a major problem and entirely changed the organization of my program for the better.
19:28:37 <cjs> In fact, I'd say as a professional programer, you're crippled in a certain way without existential types.
19:28:48 <wy> I guess the extensions are still temporary so they don't really want to publicize them?
19:29:29 <cjs> Some are. Dependent types and so on are still a big research area. But the stuff I'm talking about is not, I think; it's basically stuff that is certain to be in Haskell', I think.
19:29:34 <Cale> cjs: Well, I think most of the time with existential types you could instead just create a type which holds the methods of your interface.
19:30:23 <cjs> Cale: the problem is, at least when I use them, the methods are the same, but they take different kinds of data values.
19:30:40 <Cale> hmm
19:30:46 <Cale> Can you give an example?
19:31:09 <byorgey> wy: well, they're plenty publicized, just not in a book =)
19:31:34 <wy> byorgey: but only to those who are eager to know :)
19:31:35 <cjs> Yes. I read messages from a market data feed in a format specific to that feed, and then convert them to a standard set of internal messages within my trading/simulation/whatever engine.
19:31:50 <Cale> okay
19:31:58 <cjs> Each different type of feed has a different set of state that it needs to keep, depending on the format of it.
19:32:16 <Cale> So what's the interface like?
19:32:16 <wy> so they don't really mind whether there is a book
19:32:30 <byorgey> true
19:32:36 <cjs> The interface is basically "readMessage connectionState".
19:32:46 <byorgey> well, I don't know how much of the stuff cjs is talking about is covered in RWH
19:32:51 <byorgey> probably some of it
19:33:17 <Cale> The idea is that you could more or less partially apply the functions in the interface to the actual values, and store those instead.
19:33:23 <cjs> So, I can keep a ConnectionState in my generic processor internal state, and yet still easily chose, at runtime, which particular readMessage I'm going to use.
19:34:04 <cjs> Ah, but then I need to use IORefs or something to deal with changing state.
19:34:23 <Cale> are you sure? You can't just have a function which produces a new value of the datatype?
19:34:28 <Cale> (which is one of the methods)
19:35:53 <cjs> The function produces a new ConnectionState, but I can't store it in my overall system state without exisential types, because it could be a GLTCPConnectionState, or a GLSLCConnectionState, or one of many others.
19:36:23 <cjs> Basically, existential types give you opaque values, which I find quite useful.
19:37:28 <Cale> I'm still not sure why you can't just take the methods those have in common and package them into a structure.
19:37:28 <wy> byorgey: Is it the case that darcs has less conflicts than other version control programs?
19:37:37 <cjs> Well, more than that: opaque values that can have different structures, depending on which implementation of some module you're using.
19:37:45 <Cale> (though I agree existential types make it simpler to do that)
19:38:13 <cjs> Maybe I'm just too mired in OO to see a better solution for these things. Though this does seem to me to be remarkably clean, and brilliant in that it still does preserve full type-checking.
19:38:58 <Cale> As a stupid example, you could have an existential type  data Showable = forall a. S (a -> String)
19:39:10 <Cale> er
19:39:12 <Cale> As a stupid example, you could have an existential type  data Showable = forall a. S (a, a -> String)
19:39:25 <Cale> But that's not really different from a String
19:39:48 <cjs> I suppose what I particularly value about it is that, as with ADTs, they give me the opaqueness, but they also give the ability to do multiple different implementations of what, to the client, is essentially the same thing. That type of modularity appeals to me very much.
19:40:01 <lucca> is anyone familiar with how to use STM and Parsec together?
19:40:27 <Cale> lucca: I can't think of a good reason why it would be different from using them separately.
19:40:32 <wagle> how do you load a package module in ghci?
19:40:46 <lucca> I'd like to have a mesh of TChans with threads moving tokens between them and consume them using Parsec to track the overall state
19:40:46 <wagle> nm
19:40:46 <Cale> wagle :m + The.Module.Name
19:40:51 <lucca> but parsec needs a List
19:41:00 <cjs> I hope I'm being reasonably clear here. I'm starting to realize that this is getting a bit difficult to explain, which means I'm probably thinking about it with less than perfect clarity.
19:41:29 <lucca> Chan and hGetContents use sneaky magic (unsafeInterleaveIO) to generate a lazy list of reads on Chans and Handles, respectively
19:41:35 <Cale> cjs: It's also possible to hide the way that things are stored in the construction of functions.
19:41:47 <wagle> Cale, thanks
19:41:49 <lucca> but STM doesn't offer the same with TChan, and atomically won't work easily inside of unsafeAnything
19:42:27 <cjs> Cale: with partial application: yes. That was one of the early tricks I learned. But it doesn't work when you need to return state.
19:43:09 <lucca> is STM just the wrong solution here?
19:43:34 <cjs> lucca: It does sound a bit odd, this implementation. What are you trying to do overall?
19:44:04 <Cale> So, for instance, you have something like:
19:44:05 <cjs> Oh, but you might just consider writing your own monadic parser. It's pretty easy, actually.
19:44:47 <Cale> data MyExistential = forall s. ME (s, s -> s) -- simplified, but is this the idea?
19:44:51 <lucca> I have a daemon that services various network connections, using threads; was hoping to use Parsec on the tokens the lower-level parser produces to handle higher-level protocol concepts
19:44:58 <lucca> i.e. have-they-authenticated, etc
19:45:14 <Cale> Or even...
19:45:16 <lucca> seems more elegant to encode these things using Parsec or similar
19:45:31 <Cale> data MyExistential a = forall s. ME (s, s -> (s, a))
19:45:39 <redditbot> permutation-0.2
19:45:52 <wagle> trying to call Data.ByteString.mmapFile..  did :m + Data.ByteString, but I'm not finding mmapFile in my namespace?
19:46:39 <Cale> data NotExistential a = NE (NotExistential a, a)
19:47:04 <wy> byorgey: Thanks. You blog post is very intuitive
19:47:28 <byorgey> wy: thanks, glad you enjoy it =)
19:47:43 <byorgey> wy: I don't know whether darcs has less conflicts as compared to other version control systems
19:48:16 <cjs> cale: http://hpaste.org/12837
19:48:23 <byorgey> it's probably about the same.
19:49:32 <wy> byorgey: Because I never saw such a theory, so I guess it might bring some advantages?
19:50:16 <byorgey> wy: I think the advantages are the ease with which you can cherry-pick which changes you want to record, and be able to apply them in any order
19:50:28 <byorgey> and the fact that it's distributed
19:51:03 <wy> byorgey: nice. I hope my editor can do that too
19:51:04 <byorgey> and in general, having a nice theory as the basis means you can make stronger guarantees about the behavior of the program
19:52:09 <wagle> oh, thats because mmap is commented out..  where do i find mmap?
19:52:41 <dons> wagle:  you wannt an mmap bytestring?
19:52:58 <dons> wagle: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring-mmap ?
19:53:24 <Cale> cjs: http://hpaste.org/12837#a1
19:53:45 <Cale> cjs: Of course, if you still want the class, the field names can't be named the same...
19:54:18 <wy> byorgey: yes. It seems to be a more advanced theory than the database theory I just learned
19:55:46 <wagle> yeah..  slowly inching in on wrapping my brain around functional approaches to processing my 8G disk image..
19:55:53 <cjs> Cale: ah, I see!
19:56:15 <lucca> mmapping 8G isn't going to work on 32bit architectures
19:56:34 <wagle> dons..  so no mmap in standard haskell?
19:57:04 <cjs> For some reason I'd not thought about return the whole lot of the functions.
19:57:40 <cjs> Still, I wonder if the actual implementation doesn't end up a bit more awkward than with existential types.
19:57:49 <wagle> hmm..  System.IO.Posix.MMap
19:58:07 <gwern> oh. my. god. I finally finished my java function. 7 hours to write it and debug it against the test suite. and it's about 100 lines. the haskell version would take 1/10th as much and I'd be surprised if it took me an hour.
19:58:11 * gwern *hates8 java
19:58:22 <byorgey> gwern: yikes
19:59:04 <dolio> 100 lines is a lot for a function in any language.
19:59:10 <pizza_> what does the function do?
19:59:14 <gwern> java doesn't do recursion well
19:59:50 <gwern> pizza_: it takes a telephone number, and returns every possible alphabetic variation - as in you know how '2' can mean A, B, or C?
19:59:58 <cjs> gwern: No big surprise there. My trading system and market simulator are currently about 4000 lines of Haskell, and that's doing what last time took many tens of thousands of lines of Java, from what I understand.
20:00:22 <gwern> I'm not a good java programmer at all, but ~100 lines and my entire fricking day is just ridiculous
20:01:00 <pizza_> sounds like it should be about 10 lines
20:01:20 <cjs> If that.
20:02:06 <pizza_> (in java)
20:02:07 <centrinia> gwern: Isn't your problem just generating all elements of a Cartesian product?
20:02:22 <Cale> cjs: Well, perhaps a little, it looks something like a combination of the instance you would have written, and the initial value.
20:02:57 <Cale> So the existential saves you a bit of mess, especially when you already have an appropriate typeclass.
20:03:05 <gwern> centrinia: not quite. there are also a number of other restrictions - it must be accomplished via primitive recursion, it must be id on anything not 2-9, and it must leave a supplied prefix alone
20:03:20 <Cale> But once you're used to this trick, it's not absolutely necessary. :)
20:03:43 <cjs> Well, as you can see from the necessity of the (otherwise unneeded) FeedConnection_ class, the existential is not entirely clean, either.
20:03:59 <gwern> and there's some null handlign too
20:04:09 <cjs> Hm. Ok, I think I take back what I said about existentials being vital.
20:07:31 <centrinia> gwern: That should still be possible with a function that generates all possible elements of a cartesian product composed with a function that generates the factors of the cartesian product.
20:07:48 <centrinia> The number 1 will map to a list [1] for example.
20:07:57 <centrinia> The number 2 will map to the list "abc"
20:08:45 <centrinia> You should also assume that 1:"abc" is valid. :D
20:09:31 <gwern> centrinia: I only have the one method, so I can't define new functions
20:09:44 <gwern> although I suppose I could use inner methods, I think they'recalled
20:10:03 <gwern> (the poor man's lambda)
20:10:56 <centrinia> How do you do a poor man's curry in Java?
20:11:19 <ivan> factories?
20:14:08 <wagle> dons:
20:14:11 <wagle> Prelude> System.IO.Posix.MMap.unsafeMMapFile "rh61disk.dd"
20:14:11 <wagle> *** Exception: System.IO.Posix.MMap.mmapFile: unable to mmap file
20:14:48 <wagle> anyone: why is mmap unsafe?
20:16:28 <pumpkin> because it can change
20:16:43 <pumpkin> if the file changes on disk, your mmapped region will change
20:16:54 <pumpkin> (I assume)
20:17:28 <gwern> it does other bad things, which is why darcs intends to eliminate all uses of mmap
20:17:44 <gwern> (iirc, it inherits all the issues of lazy io and then some)
20:17:50 <lucca> if you truncate the file, for example, accessing things in the mmap region results in SEGV, etc
20:18:57 <pumpkin> wagle: unsafeMMapFile will give you an IO ByteString, so if you do x <- unsafeMMapFile, you'd assume x to be a ByteString that won't change (the IO's already been "performed")
20:19:07 <pumpkin> however, x can change at any time, despite being "pure"
20:19:19 <roconnor> @src sequence
20:19:19 <lambdabot> sequence []     = return []
20:19:19 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
20:19:19 <lambdabot> --OR
20:19:19 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
20:19:23 <pumpkin> if that makes any sense (also, I've never used it, so I'm just talking out of my ***)
20:19:25 <roconnor> @src mapM
20:19:26 <lambdabot> mapM f as = sequence (map f as)
20:20:22 <mtp> say, what is the points-free refactorer gadget?
20:20:33 <roconnor> @pl
20:20:34 <lambdabot> (line 1, column 1):
20:20:34 <lambdabot> unexpected end of input
20:20:34 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
20:20:59 <mtp> @pl x `elem` "aeiou"
20:20:59 <lambdabot> x `elem` "aeiou"
20:21:20 <roconnor> \x -> x `elem` "aeiou"?
20:21:46 <roconnor> mtp: I think you want \x -> ...
20:21:54 <pumpkin> it still won't get any simpler, right?
20:22:00 <mtp> @pl \x -> x `elem` "aeiou"
20:22:01 <lambdabot> (`elem` "aeiou")
20:22:02 <dolio> You can only eliminate points if there are points to eliminate.
20:22:14 <mtp> hm
20:22:15 <mtp> ok
20:22:26 <mtp> pumpkin: i'm just aksing out of curiosity :)
20:22:47 <roconnor> @src sequence_
20:22:48 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
20:22:51 <pumpkin> @pl \x -> "aeiou" `elem` x
20:22:52 <lambdabot> ("aeiou" `elem`)
20:23:14 <roconnor> > sequence_ (replicate 10000 (Just 1))
20:23:16 <lambdabot>   Just ()
20:23:28 <roconnor> > sequence (replicate 10000 (Just 1)) >> return ()
20:23:30 <lambdabot>   Just ()
20:23:37 <roconnor> > sequence_ (replicate 100000 (Just 1))
20:23:38 <lambdabot>   Just ()
20:23:41 <mtp> @pl \x -> elem x "aeiou"
20:23:42 <lambdabot> flip elem "aeiou"
20:23:59 <roconnor> > sequence_ (replicate 10000000 (Just 1))
20:24:02 <lambdabot>   Just ()
20:24:13 <roconnor> > sequence (replicate 10000000 (Just 1)) >> return ()
20:24:14 <lambdabot>   * Exception: stack overflow
20:24:29 <roconnor> so strange
20:24:30 * Philippa_ wonders if (`foo` bar) is syntactically valid
20:24:43 <pumpkin> I've used something like it before
20:24:45 <roconnor> it is
20:24:57 <Philippa_> > (`map` [1,2,3]) (+1)
20:24:57 <pumpkin> > map (`mod` 5) [1..20]
20:24:59 <lambdabot>   [2,3,4]
20:24:59 <lambdabot>   [1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0]
20:25:36 <mtp> > (`elem` "aeiou") "a"
20:25:38 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
20:25:44 <mtp> erp
20:25:48 <mtp> > (`elem` "aeiou") 'a'
20:25:50 <lambdabot>   True
20:27:04 <centrinia> > let wilson p = foldl1 (\a b -> (a*b) `mod` p) [1..p-1]) in wilson 23
20:27:05 <lambdabot>   <no location info>: parse error on input `)'
20:27:10 <centrinia> > let wilson p = foldl1 (\a b -> (a*b) `mod` p) [1..p-1] in wilson 23
20:27:11 <lambdabot>   22
20:27:29 <pumpkin> > let wilson p = foldl1 (\a b -> (a*b) `mod` p) [1..p-1] in map wilson [1..20]
20:27:30 <lambdabot>   [* Exception: Prelude.foldl1: empty list
20:27:40 <pumpkin> > let wilson p = foldl1 (\a b -> (a*b) `mod` p) [1..p-1] in map wilson [2..20]
20:27:41 <lambdabot>   [1,2,2,4,0,6,0,0,0,10,0,12,0,0,0,16,0,18,0]
20:27:50 <pumpkin> :o
20:28:36 <roconnor> @type runContT
20:28:37 <lambdabot> forall r (m :: * -> *) a. ContT r m a -> (a -> m r) -> m r
20:28:42 <centrinia> > let wilson p = foldl1 (\a b -> (a*b) `mod` p) [1..p-1]) in map snd $ filter fst $ map (\n -> ((wilson n)+1 == n,n))  [2..20]
20:28:43 <lambdabot>   <no location info>: parse error on input `)'
20:28:55 <centrinia> > let wilson p = foldl1 (\a b -> (a*b) `mod` p) [1..p-1] in map snd $ filter fst $ map (\n -> ((wilson n)+1 == n,n))  [2..20]
20:28:57 <lambdabot>   [2,3,5,7,11,13,17,19]
20:29:01 <centrinia> Wow. :O
20:29:06 <centrinia> > let wilson p = foldl1 (\a b -> (a*b) `mod` p) [1..p-1] in map snd $ filter fst $ map (\n -> ((wilson n)+1 == n,n))  [2..100]
20:29:07 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
20:29:13 <centrinia> Prime!
20:29:17 <pumpkin> zomg
20:29:44 <roconnor> @index runContT
20:29:45 <lambdabot> Control.Monad.Cont
20:31:04 <pchiusano> hello
20:31:50 <pchiusano> does anyone know of a good haskell library for generating bitmaps and other image formats?
20:34:21 <pumpkin> I thought I saw one on hackage
20:35:40 <shapr> I've seen something, there's at least a JPEG library.
20:35:54 <shapr> I think Igloo wrote an xbm lib long ago
20:38:20 <wy> byorgey: congratulations for the admission. How do you like UPenn?
20:38:21 <wagle> how do you get errno from a stem.IO.Posix.MMap.unsafeMMapFile?
20:38:44 <roconnor> dons: I tried it, and it is a memmory leak!
20:40:29 <roconnor> dons: http://www.reddit.com/r/programming/comments/7hymd/f_from_a_haskell_perspective/c06pnx6
20:43:13 <wy> byorgey: It seems that you haven't written part III yet? Any way you gave me a good start :)
20:43:42 <pumpkin> byorgey: yes, please write part 3 :) I'm interested too
20:45:30 <roconnor> @tell vixey I have an answer to your question about R -> N.
20:45:31 <lambdabot> Consider it noted.
20:46:54 <ddarius> roconnor: What's the question?
20:47:17 <roconnor> "How could you conceivably prove, in constructivist logic, that *no* map from R -> N is injective?"
20:48:28 <roconnor> well, it isn't directly her question
20:48:37 <roconnor> but is it the question I am refering to
20:51:21 <dolio> roconnor: How would that contradict classical math?
20:51:43 <roconnor> classical math says there are
20:51:46 <roconnor> oh
20:51:50 <roconnor> crap
20:51:57 <roconnor> sorry
20:52:01 <roconnor> heh
20:52:12 <roconnor> good think vixey wasn't around to read my nonsense reply
20:52:15 <roconnor> thing
20:52:16 <dolio> :)
20:52:48 <roconnor> the correct answer is, the same way you prove it in classical math. :P
21:01:54 <wagle> can you construct R?
21:02:13 <roconnor> there is a constructive defintion of R
21:02:35 <wagle> ok
21:03:32 <roconnor> there are several constructive definitions of R :) but I think something equivalent to Cauchy sequences are usually what is refered to, rather than Dedekind cuts.
21:03:36 <roconnor> both have their uses
21:06:45 <dons> roconnor: how is it a leak?
21:07:25 <dons> it's just going to allocate a lot.
21:07:44 <dons> i mean: we expect this result.
21:10:21 <wagle> dons, apparently, i cant mmap the file because of errno 12, "Cannot allocate memory"..  you happen to already know what the problem might be?
21:10:26 <dolio> Simple to fix.
21:10:37 <dolio> Change (>>) :: m () -> m a -> m a
21:10:47 <dons> wagle: too big?
21:11:29 <wagle> 8G file, 4G real memory, but i thought it treated the file as swap
21:11:53 <dons> check man mmap
21:11:56 <Cale> But the constructive definitions of R aren't really the same as the usual one.
21:11:59 <Cale> (ones)
21:12:07 <dons> or try mmapping a lazy bytestring, wagle ?
21:12:22 <wagle> i want random access,
21:12:34 <wagle> have the whole thing in memory
21:14:14 <wagle> not asking for you to figure it out for me..  i was just hoping you'd already been burned by whatever's burning me
21:16:07 <dons> nope.
21:16:33 <roconnor> dons: well, I guess it is a leak if you are expecting the result to be tossed away before it is accumulated in it's entirety.
21:16:59 <roconnor> dons: I guess I got caught expecting too much from GHC again. >:(
21:17:02 <Cale> You end up with something a little different, because the usual definition of a Cauchy sequence is altered.
21:18:03 <bos> is the ghc source tree still managed with darcs?
21:18:08 <roconnor> Right, the definition of the constructive reals use a constructive existential, which doesn't exist in classical math.
21:18:13 <bos> dons: what's happening with the haskell platform?
21:20:19 <Cale> Actually, I think there is an injective map from the computable reals to N, but it's perhaps not itself computable.
21:20:23 <solrize_> you should be able to mmap a file that's bigger than memory, but in my experience it's painful
21:20:41 <roconnor> Cale: it is not computable.
21:20:55 <Cale> right
21:21:05 <mjrosenb> Cale: enumerate every algorithm for computing reals, then give each of them every possible finite sequence as inut
21:21:09 <cjs> solrize_: What's painful about it? I assume you mean bigger than physical memory, and not virtual.
21:21:35 <Cale> So the computable reals are countable but not computably countable, whatever that means :)
21:21:55 <solrize_> yeah, bigger than physical memory, but when i've done it, it has resulted in bad thrashing even though my access patterns were serial
21:22:08 <polveroj> wagle: you're on a 64-bit platform, right?
21:22:20 <solrize_> computably countable?
21:22:31 <roconnor> yes
21:22:44 <dons> bos, dcoutts is on jury duty, so we're stalled for till sometime this week
21:22:47 <Cale> solrize_: The required map exists in classical mathematics, but fails to be computable.
21:22:49 <solrize_> there's no computable bijection from N to [BB(1),BB(2),BB(3),...] is that such a big deal?
21:22:53 <cjs> solrize_: Which OS? Did you try the linear access hint?
21:22:54 <solrize_> BB=busy beaver
21:22:55 <dons> plan to put out a 0th release before xmas
21:22:59 <roconnor> mjrosenb: the tricky bit is assigning the same number to equivalent real numbers
21:23:07 <roconnor> ie making the mapping well-defined
21:23:20 <solrize_> cjs, 32 bit linux with 1gb of ram and a 2gb file, no i didn't try an access hint
21:24:09 <solrize_> dons that's great, platform will be a big help for those of us who are install-impaired
21:24:28 <jsn> is every typeclass a category? if we assume that 'id' is in it and it has 'haskell composition' ?
21:24:30 <solrize_> bordersstores.com is down for me, can anyone else reach it?
21:24:46 <dons> lots of people mentioning how hard it is to pick good libs
21:24:57 <cjs> Hm. 2GB is slightly over the amount of VM available to you, I believe, unless you have a kernel with the user/kern boundary pushed up. But still, even without a hint, thrashing seems odd; performance should be no different than just reading the file, really.
21:26:10 <solrize_> i have some bigger machines now and am trying to get my boss to buy some flash drives
21:26:53 <polveroj> jsn: there's a subcategory of Hask whose objects are types with an instance of the class and whose morphisms are the Hask-morphisms between them
21:27:39 <solrize_> but, for some reason i couldn't find the doc about madvise (it used to be called vadvise) so i figured it was a bsd-ism that linux didn't implement
21:28:23 <jsn> polveroj: so for Show, for example, the terminal object is String, the identity is 'id', composition is '.' and the other morphisms are various instances of Show
21:28:43 <solrize_> posix_fadvise, that's what i want
21:28:48 <Cale> Suppose we had an oracle for testing computable reals for equality. What problems would still be intractable?
21:29:46 <solrize_> that sounds equivalent to a halting oracle, so the halting problem for the oracle machine would be intractable
21:30:15 <solrize_> well let's see
21:30:53 <dolio> How are we defining this category?
21:30:55 <polveroj> jsn: the other morphisms are functions of type less general than (Show a, Show b) => a -> b
21:30:58 <solrize_> what's a computable real again?  i.e. how many quantifiers can it have?
21:31:03 <dolio> Because there are multiple functions :: String -> String.
21:32:38 <jsn> polveroj: wouldn't the other morphisms be only those functions 'show :: a -> String' ?
21:33:30 <Cale> solrize_: There's a computable function which, given any positive rational error bound, produces a rational number within that error bound of the real.
21:33:33 <jsn> polveroj: i am honestly vexed by your comment
21:34:09 <solrize_> eh?  all reals are computable by that definition, it sounds like
21:34:25 <roconnor> Cale: deciding equality on the real numbers solves all arithmetic statements.
21:34:49 <solrize_> oh, you mean given a description of the real as some formula
21:34:51 <roconnor> Cale: but probably doesn't decide anaylict statements.
21:34:55 <Cale> solrize_: There are only countably many such computable functions.
21:34:56 <polveroj> jsn: for an arbitrary typeclass the result of the typeclass functions might not be in the class
21:35:11 <solrize_> cale yes but there are only countably many rationals
21:35:24 <Cale> roconnor: Yes, I wonder if statements about sets of reals are equivalent to the machine-with-oracle halting problem :)
21:35:25 <jsn> polveroj: sure, but you can extend the category with it
21:35:26 <dolio> If you want to define a category out of a type class, you're probably better off taking types in the class as objects, and morphisms that respect the operations of the class.
21:35:37 <jsn> polveroj: i think
21:35:39 <solrize_> but i remember chaitin's constant as being an example of an uncomputable real
21:36:00 <solrize_> i.e. it's defined by some formula that doesn't let you determine its value within closer than some finite amount
21:36:03 <roconnor> Cale: I suspect so.  I suspect the anylictic heirarchy acts like the arithmetic heirarchy under that oracle.
21:36:04 <dolio> But I'm not sure that works well for Show.
21:36:20 <jsn> so here, say we have Roundable
21:36:25 <roconnor> Cale: but I'm not sure.  Often things are more interesting than I expect.
21:36:35 <solrize_> so you have to be a little careful with definitions
21:36:43 <jsn> Roundable Double, Roundable Float
21:36:53 <Cale> solrize_: http://en.wikipedia.org/wiki/Computable_real has a few equivalent definitions
21:37:02 <jsn> round :: r -> Word
21:37:03 <Cale> (you might like one of them better)
21:37:23 <dolio> So your morphisms would be f : A -> B with show a = show (f a) for all a in A.
21:37:46 <Cale> solrize_: The important point is that while it's true there are only countably many rational numbers, there are not countably many sequences of rationals.
21:38:24 <polveroj> jsn: (checks wikipedia) I think what I'm talking about would be the full subcategory induced by the typeclass.  The class is a subset of types (objects in Hask), and the full subcategory on those objects has all the morphisms between them
21:38:32 <dolio> But show isn't a morphism in that category, because show (show a) /= show a for any a (I think).
21:39:21 <jsn> dolio: i don't understand how you got that category
21:40:09 <dolio> Consider (a simplified) Ord instead, where the only method is (<=).
21:40:19 <jsn> dolio: aye
21:40:20 <dolio> So, your objects are types that belong to ord.
21:40:47 <dolio> And your morphisms are f : A -> B such that if a <= a' then f a <= f a'.
21:40:54 <dolio> So, order preserving functions.
21:41:15 <polveroj> (which are what Conal Elliott would call "Ord-morphisms", I believe)
21:41:18 <jsn> why aren't my morphisms just the implementations of <= ?
21:41:24 <solrize_> cale but for any rational r, there are countably many equivalence classes of sequences that converge to some point within r
21:41:27 <Cale> That's a more suitable definition of a subcategory induced by a typeclass, but you can also take the full subcategory.
21:41:35 <solrize_> dons, borders now claims RWH should arrive december 11
21:42:01 <Cale> solrize_: hmm?
21:42:37 <solrize_> for any real number r, there is a rational number q within any epsilon of r
21:42:44 <Cale> sure.
21:42:52 <jsn> for a category to be a category, do you have to be able to compose any morphism with any other morphism?
21:43:07 <dolio> If the types are correct.
21:43:11 <polveroj> Cale: Yeah, that's a more interesting category.  In some sense it arises from the *laws* on the typeclass operations.
21:43:12 <jsn> okay
21:43:13 <Cale> solrize_: But that rational number might not be computable for all epsilon.
21:43:28 <solrize_> so minsky's definition is clearer than describing computability as sequences of rationals
21:43:31 <jsn> so as long as they aren't, you don't
21:43:40 <solrize_> cale, every rational is computable, it's a pair of finite integers ;)
21:43:42 <wahnnfrieden> hi
21:43:47 <wahnnfrieden> is haskell not useless?
21:43:57 <Cale> solrize_: The function from epsilon to the rational, might not be a computable function.
21:43:59 * jsn looks for ops
21:44:03 <dons> do you have a specific question, wahnnfrieden
21:44:04 <wahnnfrieden> sorry i mean
21:44:09 <Ezla> jsn: Why do you look for ops?
21:44:10 <wahnnfrieden> where is haskell being used in production?
21:44:11 <Cale> solrize_: Do you get what I'm saying?
21:44:17 <wahnnfrieden> or is it primarily theoretical
21:44:20 <wahnnfrieden> /academic
21:44:25 <dons> check haskell.or
21:44:27 <dons> haskell.org
21:44:32 <dabblego> wahnnfrieden, http://www.haskell.org/haskellwiki/Haskell_in_industry
21:44:38 <dons> there are numerous open source and industrial users.
21:44:42 <dons> some researchers too
21:44:44 <wahnnfrieden> haskell is related to erlang?
21:44:45 <dons> but mostly open source
21:44:48 <dons> yes.
21:44:52 <Cale> wahnnfrieden: not closely related.
21:44:53 <jsn> dolio: so, i do not want to seem overly thick
21:45:00 <wahnnfrieden> i heard facebook used erlang for the IM system. do you know why?
21:45:06 <Ezla> When people come in here who are highly skeptical of Haskell, and there brains aren't yet cracked, they may simply say things they'd say to their buddy in a bar. If you were sitting at a bar discussing Haskell, you might say "is haskell useless" ?
21:45:14 <Ezla> People are resistant to change, and learning totally new things.
21:45:17 <solrize_> cale, it's a little bit unpersuasive since it's completely unclear what "within epsilon" means (because exactly how to identify the real is unspecified)
21:45:18 <dons> no. you should ask in #erlang
21:45:18 <Ezla> You shouldn't expect anything else.
21:45:26 <Ezla> So don't threaten them with "Ops" when they come in here
21:45:29 <wahnnfrieden> hi cale.
21:45:33 <Cale> wahnnfrieden: hi
21:45:34 <Ezla> Because coming in here is a tiny effort already
21:45:40 <jsn> Ezla: i apologize for my comment to you earlier
21:45:43 <wahnnfrieden> cale will you unban me from #japanese?
21:45:46 <Ezla> They must have some curiosity
21:45:52 <jsn> Ezla: it was intended to be funny, i'm sorry if it was not
21:45:52 <Cale> wahnnfrieden: I don't have ops there
21:45:52 <dons> Ezla: yes, that's just silly. sometimes there are very naive arrivals though that are hard to distinguish from noise.
21:46:00 <wahnnfrieden> can you ask?
21:46:06 <Cale> wahnnfrieden: You'll have to talk to Twey, or one of the other ops.
21:46:09 <solrize_> anyway what this is really getting at is, an uncomputable real is one whose exact location on the line cannot be pinned down
21:46:17 <wahnnfrieden> twey has something against me, even though i dont troll or spam or anything
21:46:17 <jsn> Ezla: there are more than a few people who come in here to start fights
21:46:20 <dons> wahnnfrieden: if you've not got haskell questions, better take it to another channel.
21:46:23 <jsn> Ezla: well, only a few
21:46:25 <wahnnfrieden> sorry
21:46:29 <Ezla> jsn: what did you say to me earlier that you're sorry about?
21:46:42 <jsn> Ezla: oh, never mind if it didn't bother you
21:46:53 <jsn> i'd have to dig through the logs to find it
21:47:15 <dons> Ezla: its an interesting tasks to keep 500+ people on topic and with good signal.
21:47:35 <solrize_> so 1/BB(1) + 1/BB(2) + 1/BB(3) + ...  pretty obviously converges but not to a computable value, i'd say
21:48:13 <solrize_> now if you had a halting oracle you could sum that series to arbitrary precision
21:48:25 <wy> byorgey: It seems that your cap-camp-cramp-crap example doesn't work in practice? Is darcs line based?
21:48:36 <solrize_> but without an oracle you're hosed as soon as you hit an undecidable term
21:48:41 <jsn> dolio: so, say i have a, uhm, structure that is just the various 'show :: a -> String', the 'a' and that can be shown, String, 'id' and '.'
21:49:04 <jsn> does that fall short of a category somehow?
21:49:27 <Cale> solrize_: right.
21:50:19 <jsn> Ezla: i remember i was reprimanded by other channel members for it, so it stands out in my mind :)
21:50:26 <jsn> the event, i mean
21:50:29 * bos builds ghc HEAD from darcs for the first time in a while. hold your breath, kids!
21:50:32 <Cale> jsn: So only the arrows down to String given by show, and the identities?
21:50:40 <jsn> Cale: right
21:50:44 <dons> huh. my comp1A lecturer (the guy who taught me haskell) now has his lectures on youtube. (no haskell ones though?) http://in.youtube.com/watch?v=XP4o0ArkP4s
21:50:47 <Cale> jsn: It's a category, but it's a little boring...
21:50:49 <Ezla> jsn: Thanks, everyone hates me, glad to see some forgiveness :)
21:50:53 <dons> amazing lecturer.
21:51:01 <polveroj> jsn: that's a category, but the only meaningful compositions are with identities and with show :: string -> string
21:51:09 <jsn> okay, neat
21:51:22 <dolio> jsn: That's a category, but String still isn't terminal, if there is show :: String -> String.
21:51:26 <dolio> Because that's not id.
21:51:29 <Cale> jsn: Oh, I suppose it's not *quite* the discrete category + a terminal, since you have show :: String -> String, yes :)
21:51:31 <wagle> polveroj, yeah..
21:51:34 <jsn> dolio: aha
21:51:40 <Cale> Heh, we thought of the same thing :)
21:51:44 <dolio> It's "weakly terminal" I guess.
21:51:45 <jsn> interesting
21:51:50 <dolio> At least, I think that's what that means.
21:51:55 <polveroj> wagle: just making sure. (way up there, for confused people)
21:52:05 <wagle> model name      : Intel(R) Core(TM)2 CPU          6400  @ 2.13GHz
21:52:34 <wagle> hitting kernelnewbies, but its dead
21:52:44 <Cale> I'm not sure what weakly terminal means...
21:52:45 * dolio hasn't found any specific definition of that yet.
21:53:06 <dons> bos, trying out the new parallelism stuff in the head?
21:53:16 * Cale finds a paper "Weakly Terminal Objects in Quasicategories of SET Endofunctors"
21:53:19 <wagle> cant do it in C either, so its not a haskell thing..  though raspberries to the lack of errno/perror in the exception
21:53:25 <bos> dons: hoping to make the IO manager scale better.
21:53:35 <dons> sweet. so planning on doing some hacking?
21:53:39 <bos> dons: i don't actually know what new parallelism stuff is in head.
21:53:49 <bos> yeah, finally feeling the hacking mojo leaking back in.
21:53:51 <dons> oh, work stealing + cheaper `par`
21:53:54 <dolio> Cale: I think it's existence but not uniqueness. But none of the papers I've read involving it define it very excplicitly.
21:53:55 <bos> oh, right.
21:53:58 <pumpkin> wagle: what OS you running?
21:54:05 <Ezla> Did you guys ever try building haskell / haskell's GC with Asmlib?
21:54:20 <wagle> 2.6.25.18-0.2-pae #1 SMP
21:54:21 <dons> yeah, me too. want to get uvector done and dusted. it's 90% there, but needs some more IO stuff
21:54:24 <wagle> linux
21:54:32 <dons> Ezla: ?
21:54:34 <Ezla> Asmlib is Agner Fog's SSE2 optimized memmove, memset, strcpy, strlen, strcat, etc
21:54:44 <pumpkin> wagle: is it a 64-bit one?
21:54:54 <Ezla> On one of my projects, the memmove totally helped.
21:55:16 <wagle> pumpkin, should be, but how would you tell?
21:55:34 <Ezla> I was thinking it might be good for the moving collector
21:55:38 <pumpkin> wagle: write a simple c program that prints sizeof(void *) maybe? :P
21:55:42 <pumpkin> not sure, with linux
21:55:47 <dons> Ezla: would be interesting to see if that helped, Ezla
21:55:49 <dolio> Cale: I think because the papers I've read are about coinductive types, and equality on such things is extensional (not to mention on functions), so they avoid the proof.
21:56:02 <Ezla> the Asmlib uses a "one time" fixup
21:56:06 <solrize_> anyone know if it would be feasible to hack the ghc runtime to remember the max recursion depth and max depth of unreduced closures at every term in the program?  then you'd run something like hpc at the end and it would immediately tell you where all your space leaks were.
21:56:09 <Ezla> detects your CPU then updates thunk
21:56:12 <dolio> Since extensional equality has a bad rep.
21:56:25 <Ezla> it's faster than inlined REPNE MOVS / etc
21:56:31 <Cale> dolio: That's how I would define it, just hearing the word, but I'm curious :)
21:56:47 <Ezla> http://www.agner.org/optimize/#asmlib
21:57:08 <wagle> yow
21:57:13 <pumpkin> wagle: ?
21:57:17 <wagle> @yow
21:57:17 <lambdabot> With YOU, I can be MYSELF ...  We don't NEED Dan Rather ...
21:57:25 <wagle> 4
21:57:34 <wagle> schtupid suse 11
21:57:51 <pumpkin> wagle: that's actually your compiler... trying to think of how to ask the OS
21:57:57 <pumpkin> wagle: maybe /proc/cpuinfo ?
21:58:05 <pumpkin> I haven't done anything adminny in linux in a while
21:58:59 <pumpkin> wagle: but that would definitely prevent you from mmapping an 8 gig file, if you were running a 32-bit OS
21:59:23 <cjay> http://hpaste.org/12841 -- any ideas? :)
21:59:41 <Ezla> is there any haskell extension that can provide contiguous memory non-infinite list,  but using really simple syntax like   <[    ]>   ?
21:59:59 <Ezla> well that'd be ambiguous
22:00:00 <Ezla> but something
22:00:01 <dons> Ezla: no. contiguous memory is done via various array libraries.
22:00:06 <dons> there's no special syntax for it
22:00:11 <dons> so, e.g. x <- newArray 100
22:00:19 <Ezla> yeah a library, I just wanted an list-like syntax
22:00:32 <Heffalump> we need MonadPlus list comprehensions back :-)
22:00:34 <pumpkin> you can do fromList I think
22:00:34 <dons> you could write some template haskell macros for the syntax i guess
22:00:41 <centrinia> Ezla: You will need to sequence the operations on the array.
22:00:42 <cjs> So I'm guessing the GHC 6.8.3's FFI supports ccall and stdcall, since the first is required and I've seen the second used. But is there a list somewhere of all of the calling conventions it supports on the various platforms?
22:00:43 <Cale> dolio: Oh, I suppose an alternate definition would be that T is weakly terminal if every map T -> T is an isomorphism, and for any A, there exists a map A -> T, and any two such maps differ by composition by one of the isomorphisms on T.
22:01:18 <Ezla> what does isomorphisms mean in that context?
22:01:21 <Ezla> of haskell
22:01:29 <Cale> Invertible functions
22:02:02 <Ezla> invertible as in they return to their exact previous state when you imply some anti-function ?
22:02:07 <Ezla> *apply
22:02:44 <Cale> A function f is invertible if there is some function g for which f (g x) = x and g (f x) = x for any x
22:03:01 <Cale> Another way to write that is that f . g = id and g . f = id
22:03:03 <pumpkin> for any x in f's domain
22:03:05 <centrinia> Cale: Are all inverse functions in Haskell defined for bottom?
22:03:22 <Ezla> How are invertible functions useful?
22:03:26 <pumpkin> centrinia: don't be rude!
22:03:26 <Ezla> Undo comes to mind
22:03:31 <pumpkin> centrinia: "rear end"
22:03:41 <centrinia> pumpkin: I wasn't talking about that bottom. :(
22:03:52 <pumpkin> get your mind out of the gutter!
22:03:55 <Cale> Ezla: Well, if you recall highschool algebra, you use them all the time to rearrange formulas.
22:04:18 <Cale> centrinia: If f is invertible, I'm pretty sure that f _|_ = _|_
22:04:28 <bos> Jeepers, building GHC barely causes this laptop's fan to whisper.
22:04:29 <Cale> hmm
22:04:49 <pumpkin> bos bovis
22:04:52 <centrinia> Cale, what about g?
22:05:20 <Cale> f and g are symmetric -- g is f's inverse, and f is g's.
22:05:34 <centrinia> > id (fix id)
22:05:35 <lambdabot>   * Exception: stack overflow
22:05:39 <centrinia> Too bad.
22:05:46 <Ezla> are traditional mutexes used in haskell around IO stuff?
22:06:07 <bos> Ezla: no.
22:06:13 <Ezla> bos: really? how then?
22:06:24 <bos> Ezla: we use things called MVars instead.
22:06:31 <Ezla> what's that?
22:06:33 <bos> you can construct a mutex using MVars.
22:06:43 <pumpkin> MagicVar *cough*
22:06:51 <centrinia> Cale, does id . id == id?
22:06:55 <Cale> centrinia: yes
22:07:07 <dons> Ezla: memory that threads will block on pending filling or emptying of the variable
22:07:18 <dons> very easy synchronisation system.
22:07:40 <dons> or use TVars if you decide you don't want deadlocks, and get transactional memory with rollback instead
22:07:51 <Ezla> Is there any point in regular functional haskell programming which is not IO, that's /ever/ unthreadsafe?
22:08:14 <dons> pure code is threadsafe by default, yes.
22:08:29 <dons> this is part of the reason we like purity :)
22:08:55 <Ezla> I'm imagining a future where, haskell is 30% slower than C++, but Haskell is faster :P
22:09:06 <dons> well, that's kinda where we are now.
22:09:19 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all
22:09:48 <dons> so you pay a hit for not being a low level language, then make that up with more paralleism
22:10:02 <wy> It seems that darcs doesn't work as well as what I imagined... I tried to put three lines in a file and record after add each of them. And then I tried to "unrecord" the second line. That doesn't work and when I answer "no" to the unrecording of the third line, it just skipped all the patches.
22:10:02 <dolio> Cale: Hmm, that could be.
22:10:20 <centrinia>  (id (id (unsafePerformIO randomIO))) == id (unsafePerformIO randomIO)
22:10:23 <Ezla> dons: Do you happen to know why the K-nucleotide consumed so much memory in haskell?
22:10:29 <dolio> Cale: Although I doubt that'd be any better to prove in an intensional type theory.
22:10:42 <wy> Is there a way to make that work?
22:10:50 <dons> the benchmark demands a mutable hashtable, so it has some ad hoc one that i hacked up ages ago.
22:11:05 <dons> seems like something broke though
22:11:05 <dmwit> wy: unrecording is not darcs-y
22:11:13 <dons> it was on par with the others last i checked.
22:11:13 <solrize_> if you count nehalem hyperthreading as hardware threads, then we're dealing with commodity desktop machines with 8 threads now
22:11:22 <wy> dmwit: what do you mean?
22:11:22 <dons> yes, definitely looks like something broke, http://shootout.alioth.debian.org/u64q/benchmark.php?test=knucleotide&lang=all
22:11:33 <dons> 'twas around 300M before.
22:11:36 <dmwit> wy: I mean, although unrecord is available, you should never use it.
22:11:44 <cjs> wy: Darcs user interface is occasionally not entirely intuitive or safe. But your questions might fare better on the #darcs channel.
22:11:47 <dons> probably should just implement the ocaml one
22:11:52 <wy> dmwit: uhh... how do I remove a change?
22:12:06 <jsn> dmwit: isn't it essential for trimming a large repo, though?
22:12:12 <dmwit> wy: Your options: record an UNDO patch (darcs can do this automatically, but I can't remember the name of the command) or get a copy of the repo, and refuse that patch.
22:12:18 * dons adds knuc to the ones to reimplement.
22:12:30 <wy> cjs: I doubt anybody was there, so I just asked here since many people use darcs here
22:12:45 <dmwit> wy: But it is likely that a patch to change line 3 will depend on a patch to change line 2.
22:12:47 <cjs> Oh. I've had very good luck there in the past.
22:12:49 <dmwit> Just because of the proximity.
22:12:56 <centrinia> This is not good: id (id (unsafePerformIO randomIO)) == id ((unsafePerformIO randomIO) :: Int)     evaluates to False. :(
22:13:11 <dmwit> centrinia: Why is that bad?
22:13:21 <dmwit> centrinia: What part of "unsafe" makes you think that would work? =P
22:13:32 <Ezla> Are any of the GHC extensions used by practically everyone and ya' can't live without it?
22:13:33 <dmwit> (It's evaluating randomIO twice.)
22:13:33 <pumpkin>  lol
22:13:43 <wy> dmwit: yes. because now line 3 is line 2...
22:13:59 <dons> Ezla: hmm. FFI ?
22:14:03 <dmwit> centrinia: Try "foo = unsafePerformIO randomIO; id (id foo) == id foo".
22:14:07 <wy> dmwit: But if this doesn't work, I don't see anything special in darcs
22:14:19 <pumpkin> centrinia: why not use quickcheck?
22:14:29 <dmwit> wy: The special part comes when you edit line 2, then edit line 4.
22:14:35 <Ezla> it says "approved addendum"
22:14:55 <jsn> Ezla: UndecidableInstances, ScopedTypeVariables, MultiParamTypeClasses
22:14:56 <centrinia> This is True:  let foo = (unsafePerformIO randomIO) :: Int in id (id foo) == id foo
22:15:01 <wy> dmwit: You mean I edit, and not delete the lines?
22:15:01 <dmwit> Ezla: I would say different people use different extensions.
22:15:15 <dmwit> Ezla: There are several extensions that are pretty uncontroversial, though.
22:15:23 <Ezla> Thouoght Undecidable was controversy :)
22:15:27 <dmwit> NoMR, MultiParamTypeClasses, etc.
22:15:36 <jsn> no, Overlapping is controversial
22:15:40 <Ezla> ah k
22:15:48 <dmwit> Undecidable is probably controversial.  But I guess some people can't live without controversy. ;-)
22:15:59 <centrinia> Is overlapping worse than undecidable?
22:16:08 <jsn> ah, yeah, i forgot about the dreaded monomorphism restriction
22:16:19 <jsn> centrinia: worse only because it is so much better :)
22:16:47 <Ezla> undecidable is the pussy version of overlapping?
22:16:59 <dolio> Undecidable becomes less necessary with type families.
22:17:23 <Ezla> overlapping does type families?
22:17:30 * centrinia runs arbitrary SK combinator expressions in compile time with Template Haskell. :)
22:17:34 <dolio> And even less necessary than that with total type families.
22:17:38 <jsn> Ezla: i don't understand how that analogy could work with Haskelly language features
22:17:57 <dolio> Overlap isn't supported with type families. It's potentially unsound.
22:18:18 <Ezla> dolio: how would you break it?
22:18:30 <centrinia> Isn't overlap similar to inconsistency while undecidability is similar to incompleteness?
22:18:44 <pumpkin> centrinia: is there an easy way to get the output of template haskell, before compilation? a bit like running -E to get the preprocessed output on gcc
22:18:58 <centrinia> pumpkin: I don't know.
22:19:09 <Ezla> pumpkin: I was told it doesn't work that way
22:19:20 <Ezla> not a macro system
22:19:23 <dolio> Ezla: type family Foo a :: * ; type instance Foo a = Int {- in one module -} ; type instance Foo Float = Float {- in another -}
22:19:24 <Ezla> works directly on the AST
22:19:26 <pumpkin> Ezla: I think it generates an AST, but that AST could output code, I assume?
22:19:37 <wy> dmwit: I see... As long as I don't change their line numbers, I can undo patches.
22:19:53 <dolio> Then, import both modules. One treats Foo Float as Int and the other treats Foo Float as Float.
22:20:12 <Cale> Ezla: It is a macro system, *and* it works directly on the AST.
22:20:13 <Ezla> dolio: thanks
22:20:24 <Ezla> Cale: sorry.. let me rephrase that:
22:20:37 <Ezla> "not a text macro system like the crappy C preprocessor"
22:20:42 <pumpkin> :)
22:20:49 <centrinia> Of course it is not a crappy text based macro system. :)
22:20:59 <centrinia> You should still be able to pretty print the AST.
22:21:17 <Cale> pumpkin: -ddump-splices
22:21:26 <Ezla>  cool
22:21:31 <Cale> pumpkin: Will output the spliced expressions and what they evaluated to.
22:21:41 <pumpkin> Cale: thanks :)
22:21:53 <wy> dmwit: That's a weird dependency. Line 3 can exist without creating line 2. Why does it depend on line 2?
22:22:35 * dmwit shrugs
22:22:41 <dmwit> It's probably not fundamental, but incidental
22:22:43 <dmwit> .
22:23:18 <wy> Maybe a next version would do it?
22:24:13 <centrinia> How does double negation correspond to the continuation passing style?
22:25:40 <dmwit> ?unmtl Cont r a
22:25:41 <lambdabot> (a -> r) -> r
22:26:51 <dmwit> ~a is roughly forall r. a -> r
22:26:56 <Cale> If you think of r as an uninhabited type you get the usual meaning of negation, and if you imagine effects in -> then you get the usual idea of CPS.
22:26:59 <dmwit> (since forall r. r is roughly false)
22:28:37 <centrinia> So that proves that r -> (a -> r) ?
22:29:08 <Cale> :t const
22:29:09 <lambdabot> forall a b. a -> b -> a
22:32:02 <pumpkin> > let x = x + 1 in x
22:32:17 <lambdabot>   thread killed
22:32:25 <pumpkin> > let x = 1:x in x
22:32:25 <centrinia> Oh, is there a way to get programs for free?
22:32:27 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
22:33:16 <dmwit> centrinia: Yup!
22:33:21 <dmwit> ?djinn a -> b -> a
22:33:22 <lambdabot> f a _ = a
22:33:30 <dmwit> centrinia: ...but not very complicated programs. =/
22:33:44 <dmwit> ?djinn (a -> b) -> ([a] -> [b])
22:33:44 <lambdabot> Error: Undefined type []
22:34:11 <centrinia> ?djinn (a -> r) -> r
22:34:12 <lambdabot> -- f cannot be realized.
22:34:18 <centrinia> Damn.
22:34:48 <dmwit> ?djinn Not (Not a)
22:34:48 <lambdabot> -- f cannot be realized.
22:34:54 <dmwit> ?djinn (Not (Not (Not a)))
22:34:54 <lambdabot> -- f cannot be realized.
22:35:11 <dmwit> ?djinn (a -> b) -> (Not b -> Not a)
22:35:11 <lambdabot> f a b c = b (a c)
22:35:14 <dmwit> hehe
22:36:05 <centrinia> ?djinn (c -> (Either a b)) -> Either (u -> a) (v -> b)
22:36:06 <lambdabot> -- f cannot be realized.
22:36:18 <dmwit> u? v?
22:36:25 <centrinia> ?djinn (c -> (Either a b)) -> Either (c -> a) (c -> b)
22:36:26 <lambdabot> -- f cannot be realized.
22:36:35 <centrinia> Shouldn't that be De'Morgan's law?
22:36:43 <dmwit> I don't think so.
22:36:47 <centrinia> Oh, sorry.
22:37:10 <centrinia> ?djinn (c -> (Either a b)) -> (c -> a,c -> b)
22:37:10 <lambdabot> -- f cannot be realized.
22:37:23 <centrinia> Shouldn't that be it?
22:37:36 <ddarius> @djinn (Either a b -> c) -> (a -> c, b -> c)
22:37:36 <lambdabot> f a = (\ b -> a (Left b), \ c -> a (Right c))
22:37:51 <dmwit> ?djinn (c -> Either a b -> d) -> Either (c -> a -> d) (c -> b -> d)
22:37:52 <lambdabot> f a = Right (\ b c -> a b (Right c))
22:37:52 <centrinia> Oh.
22:38:13 <Cale> centrinia: That said "If c implies a or b, then c implies a and c implies b"
22:39:10 * ddarius has been so corrupted by category theory that he doesn't even care about the logical intepretation; it's just continuity of homs (or left adjoints.)
22:39:12 <centrinia> ?djinn Either a (a -> b)
22:39:12 <lambdabot> -- f cannot be realized.
22:39:46 <centrinia> That should be the law of the excluded middle, shouldn't it?
22:40:08 <ddarius> Yes, and it's not true in intuitionistic logic.
22:40:31 <dolio> @djinn Not (a , Not a)
22:40:31 <lambdabot> f (a, b) = b a
22:41:05 <centrinia> ?djinn (Either a (a -> b)) -> c
22:41:06 <lambdabot> -- f cannot be realized.
22:41:19 <centrinia> ?djinn (a, (a -> b)) -> c
22:41:20 <lambdabot> -- f cannot be realized.
22:41:48 <dmwit> centrinia: Nothing implies false.
22:41:50 <dolio> If you want to negate something, you should really use Not or -> Void. Making up random names isn't going to work well.
22:42:08 <centrinia> Oh.
22:42:47 <dolio> @djinn a -> Not a -> b
22:42:47 <lambdabot> f a b = void (b a)
22:43:00 <centrinia> ?djinn (Not b,a -> b) -> a
22:43:00 <lambdabot> -- f cannot be realized.
22:43:08 <centrinia> ?djinn (Not b,a -> b) -> Not a
22:43:09 <lambdabot> f (a, b) c = a (b c)
22:43:11 <centrinia> Ah.
22:44:03 <centrinia> Wait, doesn't false imply false?
22:44:14 <centrinia> ?djinn Not a -> Not a
22:44:14 <lambdabot> f a = a
22:44:31 <centrinia> ?djinn Void -> Void
22:44:31 <lambdabot> f a = a
23:02:43 <pumpkin> *crickets*
23:04:19 <jsn> @src (<*>)
23:04:20 <lambdabot> Source not found. I feel much better now.
23:04:32 <jsn> curses
23:04:42 <pumpkin> I think you need it for a particular type
23:04:57 <pumpkin> @hoogle isNaN
23:04:57 <lambdabot> Prelude isNaN :: RealFloat a => a -> Bool
23:05:14 <jsn> @hoogle (<*>)
23:05:14 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
23:05:32 <pumpkin> @src [] (<*>)
23:05:32 <lambdabot> (<*>) = ap
23:05:36 <pumpkin> @src Maybe (<*>)
23:05:37 <lambdabot> (<*>) = ap
23:05:47 <jsn> :t ap
23:05:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
23:05:59 <dmwit> Guess where the Applicative class got its name? ;-)
23:06:28 <pumpkin> > (,,) <$> [1,2,3] <*> [4,5,6] <*> [7,8,9,10]
23:06:29 <lambdabot>   [(1,4,7),(1,4,8),(1,4,9),(1,4,10),(1,5,7),(1,5,8),(1,5,9),(1,5,10),(1,6,7),...
23:06:49 <jsn> :t fmap
23:06:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:07:33 <pumpkin> can I pattern match against NaN?
23:07:33 <markovChain> > take 10 [1..]
23:07:34 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
23:07:44 <pumpkin> can I even write NaN actually?
23:07:50 <jsn> (+ 1) <$> [0..9]
23:07:58 <dolio> > 0/0
23:08:00 <lambdabot>   NaN
23:08:00 <Cale> pumpkin: You can write 0/0, you can use isNaN to detect it
23:08:04 <Cale> > isNaN (0/)
23:08:05 <Cale> > isNaN (0/0)
23:08:05 <lambdabot>       No instance for (RealFloat (t -> t))
23:08:06 <lambdabot>        arising from a use of `isNa...
23:08:07 <jsn> > (+ 1) <$> [0..9]
23:08:07 <lambdabot>   True
23:08:08 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
23:08:09 <pumpkin> but no pattern matching?
23:08:18 <jsn> :r <$>
23:08:22 <jsn> :t <$>
23:08:23 <lambdabot> parse error on input `<$>'
23:08:31 <jsn> :t (<$>)
23:08:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:08:49 <scodil> > case 0/0 of x | isNaN x -> "it's nan!"
23:08:50 <lambdabot>   "it's nan!"
23:09:03 <scodil> can't really pattern match floats at all, can you
23:09:10 <scodil> er, non-integral ones
23:09:16 <pumpkin> true
23:09:22 <pumpkin> are guards any more expensive than an if statement?
23:09:27 <scodil> no
23:09:53 <pumpkin> cause I have a huge matrix that's polluted with a couple of NaNs that's ruining my day, and I want to convert them to zeroes :P
23:09:56 <dmwit> > case 3.1 of 3.1 -> "really?"
23:09:57 <lambdabot>   "really?"
23:09:57 <jsn> case 1.2 of 1.2 -> "true"
23:10:03 <jsn> > case 1.2 of 1.2 -> "true"
23:10:05 <lambdabot>   "true"
23:10:12 * dmwit wins
23:10:26 <jsn> dmwit: oh, darn it
23:10:31 <scodil> you guys are asking for trouble
23:10:57 <jsn> > case 1.2 of 1.2 -> "ya rly"
23:10:58 <lambdabot>   "ya rly"
23:10:59 <dmwit> > case pi of 3.141592653589793238462643383279502884197169399375105 -> "I know a few digits of pi.  I stopped because typing digits is hard.  Let's go shopping."
23:11:00 <lambdabot>   "I know a few digits of pi.  I stopped because typing digits is hard.  Let'...
23:11:17 <jsn> > case 1.2 of 1.2 -> "no wai!"
23:11:18 <lambdabot>   "no wai!"
23:11:22 <jsn> i win again
23:11:27 <jsn> i always win that game
23:11:31 <pumpkin> > case 0/0 of 0/0 -> "orly?" --nan != nan
23:11:32 <lambdabot>   <no location info>: Parse error in pattern
23:11:41 <pumpkin> > case (0/0) of (0/0) -> "orly?" --nan != nan
23:11:41 <dmwit> 0/0 is not a pattern
23:11:42 <lambdabot>   <no location info>: Parse error in pattern
23:11:44 <pumpkin> boo :P
23:11:50 <dmwit> > 0/0 == 0/0 -- you mean this?
23:11:51 <lambdabot>   False
23:11:53 <geezusfreeek> > case sqrt 2 * sqrt 2 of 2 -> "yay"
23:11:54 <lambdabot>   "* Exception: /tmp/138363090999858699:71:44-77: Non-exhaustive patterns in ...
23:11:55 <pumpkin> it makes sense, but I'm sad
23:12:16 <dmwit> > sqrt 2 * sqrt 2
23:12:17 <lambdabot>   2.0000000000000004
23:12:21 <jsn> The reals are junk
23:12:28 <jsn> just say no!
23:12:30 <pumpkin> I even got the wrong not equals symbol for haskell :( I fail epicly
23:12:39 <sbahra> :(
23:12:41 <dmwit> That's what jsn stands for!
23:13:17 <jsn> just make sure to nudge the data till it's all perfect squares
23:13:25 <jsn> then you can use integral types
23:14:12 <olsner> > sqrt 9 * sqrt 9 - 9
23:14:14 <lambdabot>   0.0
23:15:48 <pumpkin> > sqrt -1
23:15:49 <lambdabot>       No instance for (Num (a -> a))
23:15:49 <lambdabot>        arising from the literal `1' at <...
23:15:57 <pumpkin> > sqrt (-1)
23:15:59 <lambdabot>   NaN
23:16:06 <pumpkin> > sqrt (-1) :: Complex
23:16:08 <lambdabot>       `Complex' is not applied to enough type arguments
23:16:08 <lambdabot>      Expected kind `?...
23:16:11 <pumpkin> > sqrt (-1) :: Complex Double
23:16:13 <lambdabot>   (-0.0) :+ 1.0
23:17:03 <dmwit> -0
23:17:06 <dmwit> That's new.
23:17:09 <dmwit> > -0
23:17:10 <lambdabot>   0
23:17:17 <pumpkin> why?
23:17:36 <geezusfreeek> > -0 :: Double
23:17:38 <lambdabot>   -0.0
23:17:45 <pumpkin> ieee 754 defines a negative 0
23:17:49 <geezusfreeek> floating zero can be positive and negative
23:18:10 <geezusfreeek> since it is just a bit to specify the sign
23:22:11 <wy> My last question about darcs (nobody active in #darcs) tonight and I really need to sleep :p. Since rollback does the "undo", there seems to be no point to have unrecord at all? I'm quite used to emacs' undo mechanism, so is rollback the emacs way of doing undo, but unrecord is the VIM way of doing it?
23:26:57 <dmwit> unrecord and amend-record are similar: they modify the repository in unsafe ways.
23:27:21 <dmwit> In particular, if people have pulled patches that you unrecord or amend, bad things will happen.
23:28:06 <dmwit> However, they are very useful for what they do: modifying the repository in unsafe ways. =)
23:28:27 <dmwit> Sometimes it just makes more sense to add on stuff to an old patch than it does to record an additional patch.
