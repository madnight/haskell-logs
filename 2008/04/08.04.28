00:01:46 <dons> Cale: hehe, http://reddit.com/info/6hcj3/comments/
00:01:53 <Cale> leandrom: a good convention sometimes is to vertically align the parameters to a function you're calling -- so you just start the second in the same column as the first did, but on the following line.
00:02:19 <Cale> dons: haha
00:02:48 <dons> that's the first time i've ever used guards on 'main'
00:03:13 <leandrom> so for instance: fastAdd = gAndPs ->- fork ->- dropG ->- dropP ->- sums
00:03:32 <leandrom> could be write as: fstAdd = gAndPs ->- fork ->- dropG ->- dropP
00:03:40 <leandrom>                                ->- sums
00:03:46 <leandrom> more or less
00:03:51 <Cale> dons: Yeah, that's a nice example of a guarded pattern binding :)
00:04:19 <Cale> leandrom: yeah
00:04:29 <leandrom> thank you all :)
00:04:31 <geezusfreeek> wow, a guarded main... it almost hurts my brain
00:05:06 <dons> geezusfreeek: aren't all your programs constants?
00:05:14 <dons> IO is for the impure!
00:05:58 <geezusfreeek> i must be quite corrupted then
00:05:59 <dons> it'd be kinda useful if we had monadic pattern guards :)
00:06:20 <dons> main | [x] <- getArgs = print 7 | otherwise = fail
00:06:43 <geezusfreeek> hmm
00:06:55 <geezusfreeek> i have wanted something like that occasionally
00:07:37 <Cale> It's kind of scary, but also would be useful :)
00:08:11 <geezusfreeek> i think that syntax doesn't quite express the idea correctly, but something similar would still be nice
00:08:35 <Cale> dons: btw, "math and haskell work"
00:08:39 <dons> yeah
00:08:56 <Cale> (as opposed to works)
00:09:02 <geezusfreeek> your english is broken
00:09:12 <dons> i originally had, "math works, haskell works. as expected"
00:09:20 <dons> then tried to make the strings the same length. ah wellllll
00:09:42 <Cale> geezusfreeek: The claim could be made that English is broken to begin with :)
00:10:08 <Cale> The distributive law doesn't *quite* hold as nicely as one might want ;)
00:10:08 <dons> i didn't realise Rational was visible from the Prelude, either.
00:10:14 <geezusfreeek> that too
00:10:22 <Cale> Yeah, that's nice isn't it? :)
00:11:00 <geezusfreeek> waitaminute... last year i had to import it myself! i remember it distinctly because it was when i was first getting started with haskell
00:11:17 <Cale> geezusfreeek: Perhaps you needed something specific from that module.
00:11:33 <Cale> The basic type is visible from the prelude, but many of the operations on it are not.
00:11:35 <geezusfreeek> the (%) operator, perhaps? seems that would have been made available already
00:11:53 <dons> ?hoogle Rational
00:11:53 <lambdabot> Prelude.Rational :: type Rational
00:11:53 <lambdabot> Data.Ratio.Rational :: type Rational
00:11:53 <lambdabot> Language.Haskell.TH.PprLib.rational :: Rational -> Doc
00:11:55 <Cale> Prelude> 3 % 4
00:11:55 <Cale> <interactive>:1:2: Not in scope: `%'
00:11:55 <Cale> Prelude> 3 / 4 :: Rational
00:11:55 <Cale> 3%4
00:12:13 <geezusfreeek> @hoogle (%)
00:12:13 <lambdabot> Data.Ratio.(%) :: Integral a => a -> a -> Ratio a
00:12:15 <geezusfreeek> hmm
00:12:22 <geezusfreeek> okay that must have been it
00:12:27 <desegnis> Yeah, it may be a little unintuitive that (/) works properly for Ratios
00:12:35 <Cale> desegnis: heh
00:12:41 <zeno_> > (%) 3 4
00:12:42 <lambdabot>  3%4
00:12:54 <geezusfreeek> > 6%8
00:12:55 <lambdabot>  3%4
00:13:13 <Cale> > 18%16
00:13:14 <lambdabot>  9%8
00:13:14 <desegnis> "Ratio" isn't in the Prelude either btw.
00:13:37 <zeno_> > 18 'mod' 6
00:13:37 <lambdabot>  Improperly terminated character constant at "'mod'" (column 4)
00:13:45 <Cale> > 18 `mod` 6
00:13:46 <lambdabot>  0
00:13:55 <zeno_> found it =p
00:14:06 <Cale> Yeah, backticks
00:14:07 <geezusfreeek> > 18%6
00:14:07 <lambdabot>  3%1
00:14:43 <Cale> http://www.evilmadscientist.com/article.php/fractalcookies -- this is awesome
00:14:45 <lambdabot> Title: Evil Mad Scientist Laboratories - Sierpinski Cookies
00:15:11 <geezusfreeek> wow
00:15:33 <geezusfreeek> that is amazing
00:16:47 <Cale> You could also do it with hard candy, I bet.
00:18:03 <zeno_> i remember someone making a really big (non-edible) sierpinski cube with a 3d printer
00:18:52 <Cale> http://www.flickr.com/photos/themadlolscientist/2421967468/in/pool-evilmadscience -- ahaha
00:18:54 <lambdabot> Title: Fractal wrongness on Flickr - Photo Sharing!, http://tinyurl.com/5kqzsf
00:19:42 <solrize_> hah, recursive pizza
00:20:44 <Cale> http://www.flickr.com/photos/jocafa/2405002882/in/pool-evilmadscience
00:20:45 <lambdabot> Title: sierpinski cookies on Flickr - Photo Sharing!, http://tinyurl.com/5hyzkj
00:21:07 <Cale> more cookies, this time triangular Sierpinski gaskets
00:21:14 <geezusfreeek> the triforce fractal
00:21:26 <Cale> haha
00:38:11 <cjs> So what's the deal with "show" returning parsable Haskell code? It doesn't do so for, e.g., UTCTime.
00:39:13 <shachaf> cjs: It returns a readable String.
00:39:58 <abrasive> it's only meant to be human-readable; sometimes it's just more convenient to make it valid Haskell.
00:40:33 <cjs> So when would one normally return something parsable, and when not? E.g., I have a Timestamp type; is there any reason I'd want it showing as "Timestamp { microseconds = 12345 }" rather than, say, "1.2345ms"?
00:40:45 <cjs> Oops. "12.345ms".
00:42:41 <TSC> You get the former for free with automatic deriving
00:42:52 <TSC> The latter requires a bit of manual work
00:43:30 <cjs> So it's not at all unreasonable for me to want to have it printing out in the 12.345ms format.
00:44:09 <glguy> that's not what show is typically for
00:44:15 <glguy> but you are free to do whatever you want with it
00:44:50 <cjs> What is it typically for?
00:45:54 <glguy> generating the Haskell-like code including constructors used in ghci
00:47:08 <cjs> Hm. So why doesn't UTCTime do this?
00:47:18 <glguy> I imagine that there isn't a good reason
00:48:42 <vixey> what abrasive said
00:54:30 <siti> @seen Lemmih
00:54:31 <lambdabot> Lemmih is in #haskell. I don't know when Lemmih last spoke.
00:55:15 <zeno_> whats the way to eleminate all identical entries in a list?
00:55:25 <glguy> nub
00:55:31 <zeno_> oh, thanks :)
00:55:39 <siti> lol I thought you were cooling him a noob for a second :D
01:15:05 <quicksilver> cjs: You always want something parseable.
01:15:14 <quicksilver> cjs: if it isn't parseable it's an abuse of Show.
01:15:22 <quicksilver> cjs: in my personal opinion :)
01:15:33 <quicksilver> cjs: show is slightly overloaded, unfortunately.
01:15:44 <cjs> Well, mine is parsable. Just not by the Haskell compiler. :-)
01:16:44 <sauxdado> Functional programming is understandable. Just not by humans.
01:17:09 <Vq^> sauxdado: what programming is understandable by humans then?
01:17:24 <cjs> PHP!
01:17:53 <cedricshock> Functional programming is actually particularly understandable by humans (at least for me). It's hard at first just because it's different.
01:18:03 <Vq^> cjs: even the interpeters are confused by PHP :P
01:18:33 <cedricshock> After  a while you have difficulty understanding other things because you have no idea what things are actually happening to.
01:18:34 <siti> I don't think functional languages are simple to learn... but they are much easier to programme well with IMO
01:18:51 <siti> you could argue scheme is simple to learn... but haskell is one of the more complex languages IMO
01:19:03 <siti> but once you learn it.. it is awesome
01:19:13 <Plareplane> when did ghci get multiline commands
01:20:09 <dmwit> It has always had them via \
01:20:23 <dmwit> Err...
01:20:28 <Vq^> whats simple in comparison then?
01:20:31 <dmwit> I *thought* it had always had them via \.
01:20:50 <siti> risc assembly is pretty simple ;)
01:20:56 <siti> to learn.
01:20:58 <siti> not to use
01:21:31 <Vq^> the basics of Haskell is very simple to learn
01:21:44 <Vq^> you could just exclude the entire Prelude and you have a quite simple language
01:22:03 <quicksilver> I think haskell is about one million times easier to learn than Java.
01:22:07 <quicksilver> and about one billion times easier than C++.
01:22:10 <siti> heh maybe.. but the standard library is almost important as the language itself these days IMO
01:22:14 <quicksilver> it's just a question of what you learn first.
01:22:22 <b_jonas> quicksilver: I don't think so
01:22:40 <b_jonas> the problem with C++ is that there are lots of bad (or old) books and websites and teachers trying to teach it
01:22:41 <Vq^> siti: even more so for Haskell
01:22:47 <b_jonas> but it's actually not so bad
01:23:01 <b_jonas> so not a billion times
01:23:04 <osfameron> if you want to get something done in an imperative language, not knowing how to do it doesn't prevent you :-)
01:23:33 <Vq^> osfameron: no, it just wont prevent you from trying
01:24:51 <Vq^> b_jonas: thats certainly not the only problem with C++
01:25:08 <b_jonas> Vq^: it's not the only one, sure
01:25:28 <b_jonas> but I think it's the biggest problem
01:25:32 <b_jonas> still, it's not a billion
01:26:08 <cedricshock> The problem with haskell is I always want to write a new language for every user interface, and then work in the trace of that language.
01:26:26 <quicksilver> b_jonas: I think you might appreciate that I was indulging in a bit of hyperbole :)
01:26:43 <Vq^> probably not a billion, but C (and C++) code can be surprisingly hard to reason about
01:26:44 <quicksilver> but I do genuinely think haskell is easier to learn than Java or C++ if you are starting from scratch.
01:26:59 <quicksilver> and I say this with some experience of teaching programming ab initio.
01:27:20 <pejo> Vq, but so is Haskell.
01:27:34 <dolio> I remember it taking me a while before I really got Java.
01:27:42 <Vq^> pejo: no, i don't think so
01:40:45 <zeno_> getClockTime returns an IO ClockTime, how do i extract the ClockTime?
01:41:18 <rentboy> you don't
01:41:47 <vegai> unsafeThisAndThat?
01:41:52 <dmwit> Now that's a koan.
01:42:05 <dmwit> Zen masters, pay attention, rentboy is here!
01:42:17 <dmwit> zeno_: In general, you must use the ClockTime within the IO monad from then on.
01:42:30 <zeno_> doesnt work : extract (IO x) = x
01:42:49 <dmwit> zeno_: You can pass it out to a pure function from within the monad, but what you actually do is pull the pure function into the monad.
01:42:57 <dmwit> For example:
01:43:16 <dmwit> do { x <- getLine; let y = reverse x; print y }
01:43:29 <dmwit> Here, "reverse" is a pure function, and we've passed 'x' out to it.
01:43:41 <dmwit> But the result, y, is back in the IO monad, whether you like it or not.
01:43:48 <zeno_> ah ok
01:44:04 <dmwit> The pattern will be similar for your getClockTime and friends.
01:44:33 <dmwit> Have people suggested any monad tutorials for you?
01:45:02 <zeno_> nope
01:45:12 <dmwit> Would you like us to? =P
01:45:15 <zeno_> sure =p
01:45:23 <dmwit> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
01:45:25 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
01:45:34 <dmwit> http://www.haskell.org/all_about_monads/html/index.html
01:45:34 <lambdabot> Title: All About Monads
01:45:41 <zeno_> (i was jsut trying to get an example ClockTime for testing pourposes)
01:45:43 <dmwit> Those two are my favorites.
01:46:07 <zeno_> dmwit: thanks :)
01:46:09 <dmwit> I also enjoy this one, it's good if you just want to get up and running ASAP:
01:46:13 <dmwit> http://sigfpe.blogspot.com/2007/11/io-monad-for-people-who-simply-dont.html
01:46:14 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care, http://tinyurl.com/yplmwx
01:46:21 <dmwit> Good luck. =)
01:50:42 <cpoucet> haha
01:50:44 <cpoucet> I love the url
01:51:02 <cpoucet> "io-monad-for-people-who-simply-dont. *html*
01:51:11 <dmwit> Yeah, just *one* more word... =P
01:51:35 <cpoucet> at first it didn't make sense :)
01:52:39 <zeno_> for people who don't io-monad!
01:52:44 <zeno_> =p
01:54:12 <Vq^> ah, good ol whats-my-String-doing-in-that-IO-closet :)
02:00:35 <cedricshock> Do any of you know of a really good state machine monad example with a data type for the transitions between states?
02:03:22 <cjs> I seem to be heading into this hole where I want to take half my data types and centralize them in a single module containing only them to avoid import loops. Is this normal sometimes?
02:03:53 <quicksilver> yes
02:04:49 <cjs> Phew.
02:05:12 <quicksilver> it's quite sensible to put datatypes and "simple operations" on them in a nice basic module
02:05:16 <Saul_> I have a suggestion
02:05:19 <quicksilver> sometimes there are no simple operations.
02:05:40 <Saul_> there are these new things for constructing tuples, like (,) (,,) (,,,) etc
02:06:24 <Saul_> wouldn't it be nice if you could partly insert values, like this (,,3,) 1 2 4 would yield (1,2,3,4)
02:07:04 <Saul_> I think that would be nice and it would be a pretty minor and self-contained extension
02:09:24 <quicksilver> Saul_: sections for (,,,) basically
02:09:28 <quicksilver> yes, it would be quite nice
02:09:29 <scook0> I know I've seen it suggested before
02:09:44 <quicksilver> most people probably just don't consider it worth the effort :)
02:09:45 <scook0> the biggest objection seems to be the potential for accidentally admitting typos
02:09:56 <scook0> but I guess the type system would catch most of those
02:10:35 <Saul_> quicksilver: yes
02:11:50 <osfameron> it would be nice at least for pairs.  But it's not really the haskell way to make an exception for one class of thing...
02:11:56 <b_jonas> eek no
02:12:08 <b_jonas> not with that syntax
02:12:20 <b_jonas> it could work the sml way where
02:12:33 <b_jonas> tuples have an implicit record syntax
02:12:59 <b_jonas> with named fields with names like #0 and #1 or something
02:13:37 <Saul_> osfameron: That is true
02:14:17 <sioraiocht> how are values of unboxed types allocated?
02:14:27 <sioraiocht> the ghc manual says they aren't allocated on the heap?
02:20:34 <Boney> sioraiocht: if they are unboxed they will typically be a machine word size, so they fit in registers, so it's easier to pass them arround, than to pass a pointer and have a heap cell somwhere.
02:20:47 <sioraiocht> Boney: ahhhh, thanks
02:20:57 <cpoucet> sioraiocht: and in data-strcutures they're stored inline
02:21:09 <sioraiocht> cpoucet: AH! thanks makes sense, okay thanks
02:42:06 <Baughn> http://xkcd.com/416/ <-- Ubuntu uses haskell for some of the setup tools, doesn't it?
02:42:07 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
02:42:48 <osfameron> really?
02:42:53 <gal_bolle> wasn't it linspire ?
02:43:06 <dmwit> Yeah, you're probably thinking of linspire.
02:43:08 <atsampson> yes, I think it's Linspire you're thinking of
02:43:10 <Baughn> Could be. I know it's /some/ distribution
02:43:15 <osfameron> I think ubuntu is mainly targeting python for setup tools
02:43:24 <Baughn> But the complexity of code suggested in that comic also suggests haskell
02:43:27 <sioraiocht> @seen dcouts
02:43:27 <lambdabot> I haven't seen dcouts.
02:43:32 <sioraiocht> @seen dcoutts
02:43:32 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #ghc and #haskell. I don't know when dcoutts last spoke.
02:43:37 <sioraiocht> @seen dcoutts_
02:43:37 <dcoutts_> @yarr!
02:43:37 <lambdabot> Gangway!
02:43:37 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #ghc and #haskell. I last heard dcoutts_ speak just now.
02:43:47 <sioraiocht> dcoutts_:  ping?
02:43:56 <dcoutts_> sioraiocht: pong?
02:43:56 <lambdabot> dcoutts_: You have 1 new message. '/msg lambdabot @messages' to read it.
02:45:35 <quicksilver> dcoutts_: why does cabal default to prefix /usr on linux?
02:45:40 <quicksilver> dcoutts_: that seems a bit odd.
02:45:59 <dcoutts_> quicksilver: it doesn't, it defaults to /usr/local
02:46:07 <quicksilver> oh.
02:46:15 <quicksilver> then maybe it's something wrong with the debian packaging
02:46:17 <quicksilver> Igloo: ?
02:47:59 <Igloo> I didn't change it
02:49:25 <quicksilver> Igloo: I will have to investigate more when I get back home.
02:49:33 <quicksilver> I installed ghc6 debian packages for the first time on a linux machine.
02:49:40 <quicksilver> I installed wx from source, using cabal
02:49:51 <quicksilver> it appeared to default the prefix to /usr/
02:50:00 <dcoutts_> quicksilver: ohh, well that uses make underneath
02:50:02 <quicksilver> but I may have misundersttod something, or it may even be a bug in the wx source.
02:50:06 <dcoutts_> we don't get much control over that
02:50:14 * quicksilver nods
02:50:20 <quicksilver> could be a wx issue although it didn't happen on this OSX machien.
02:50:33 <quicksilver> but it may be that wx (haskell) takes the prefix from wx (the C library)
02:50:45 <quicksilver> and on the debian machine the C library wx was installed as a package so into /usr
02:50:59 <dcoutts_> naughty, it should use the supplied --prefix
02:51:02 <quicksilver> will do more investigation and let you know if turns out to be your bug.
02:51:13 <quicksilver> dcoutts_: I'm only guessing. And don't have access to that machine from work so can't check.
02:51:16 <quicksilver> Will check.
03:00:32 <Japsu> @quote smalltalk
03:00:33 <lambdabot> Korollary says: I don't subscribe to smalltalk's "+" is a message you send to a number object argument
03:00:41 <Japsu> @quote out-perl
03:00:41 <lambdabot> No quotes match.
03:00:57 <Japsu> @quote out-python
03:00:57 <lambdabot> LoganCapaldo says: ruby isn't trying to out-python python, its trying to out-smalltalk perl :)
03:00:59 <Japsu> <3
03:01:01 <Saizan> dcoutts_: have you noticed that dependencies don't really form a DAG? dynamic deps are created depending on a node, but once generated we don't represent this so it's a problem when persisting the graph
03:02:10 <dcoutts_> Saizan: I'm not sure I follow
03:03:48 <quicksilver> dcoutts_: I was also a bit sad that Setup.lhs doesn't have an 'uninstall' target
03:03:58 <quicksilver> dcoutts_: after I thought it had installed int he wrong dir
03:04:23 <aleator> Another string&performance related question: http://hpaste.org/7231
03:04:29 <dcoutts_> quicksilver: we do not track what we installed so we cannot uninstall yet, there's an open bug to do with tracking installed files
03:05:06 <quicksilver> dcoutts_: *nod*
03:05:18 <quicksilver> dcoutts_: but even without tracking installed files
03:05:30 <quicksilver> dcoutts_: surely the bit of code which knows which files its going to install and where
03:05:35 <quicksilver> could just reverse the process
03:05:59 <Saizan> dcoutts_: well e.g. if module A imports B, we create a dep from B.hi to A.hi, but that very dependency (which is an arc in the DAG) depends on A.hs, since if you change A.hs that dep can change, so it's like we have an arc from A.hs to the B.hi -> A.hi arc
03:06:01 <dcoutts_> quicksilver: not easily
03:06:52 <dcoutts_> quicksilver: you assume the install code is well structured :-) and decides what it's going to install and then installs it. It doesn't :-) it just installs various bits without any one piece of code knowing every file that will be installed.
03:07:36 <dcoutts_> quicksilver: so the thing to do is to restructure it into two phases, gathering the list of files to install and then installing that list. That'd make it easy to generate a manifest of what we're going to install which we can use to uninstall.
03:08:25 <dcoutts_> Saizan: right, the rule which generates the A.deps depends on A.hs
03:10:01 <Saizan> dcoutts_: yeah, but when we splice A.dep among the deps for A.hi we don't track which deps we're adding, and so which can become invalid if A.dep later changes
03:10:28 <b_jonas> is there some document which compares different XML modules for haskell and tells me which I should use if I want what?
03:11:57 <quicksilver> b_jonas: tagsoup is great for a non-structured approach.
03:12:15 <quicksilver> b_jonas: HaXML is great for a nice combinator library for XML transformations
03:12:26 <quicksilver> b_jonas: HXT is HaXML taken further into the world of arrows.
03:12:44 <dcoutts_> Saizan: you're right, we should track them so we can back them out when A.dep gets re-generated
03:13:19 <b_jonas> I like XML::Twig for perl because it's 1. fast, 2. supports both loading the whole tree to memory or streaming filtering, and 3. has a nice large interface
03:13:47 <malcolmw> quicksilver: care to extend your comparison to include the newly released Galois XML library?
03:13:57 <quicksilver> malcolmw: I've not even looked at it.
03:14:04 <malcolmw> quicksilver: nor me
03:14:14 <b_jonas> wait, tagsoup is a library?
03:14:19 <quicksilver> it is indeed
03:14:27 <b_jonas> oh, I confused it with those tagclouds
03:14:36 <b_jonas> it does sound similar
03:14:51 <b_jonas> which, of course, has not much to do with xml
03:15:21 <quicksilver> 'tagsoup parsing' is what browser engine writers use to refer to the business of doing the best you can with illformed html
03:15:35 <quicksilver> the tagsoup library is supposed to be able to parse similarly illformed stuff
03:15:38 <b_jonas> non-structured sounds good, but I'm not sure it really means what I want
03:15:59 <cjs> Is there an export something along the lines of "module Bar ( Foo (..) ) where import Foo" to export everything you imported from Foo?
03:16:05 <b_jonas> I see
03:16:11 <b_jonas> so it's the html thingy
03:16:29 <Deewiant> cjs: module Bar (module Foo (..))
03:16:34 <b_jonas> I think parsing of html should be separated from the interface you use to manipulate the xml tree you get
03:19:30 <Saizan> b_jonas: tagsoup is the haskell equivalent of a stax/sax library
03:19:51 <Saizan> with less validity checking maybe
03:20:23 <quicksilver> b_jonas: perhaps, but why bother?
03:20:36 <quicksilver> b_jonas: (tagsoup has nothing do with HTML, that was an analogy)
03:20:46 <quicksilver> the actuall business of parsing html/xml is totally trivial.
03:20:54 <quicksilver> why bother to separate the parser from the interface?
03:21:12 <quicksilver> anyhow the big question you have to decide if you want to stream it or build a valid tree.
03:21:33 <b_jonas> quicksilver: what I mean is that there shouldn't be a separate interface for searching and inserting nodes in a html document than from doing the same in an xml, if that's possible
03:21:42 <b_jonas> which is the problem with the HTML::Tree module for perl
03:22:14 <b_jonas> luckily, you can use HTML::Tree for parsing and then use another xml module (like XML::Twig) to manipulate the resulting tree, and use HTML::Tree again to dump the output as html
03:24:30 <b_jonas> quicksilver: as for stream, I actually need both, because once I had to work with a very large xml file from which I need only some of the data, so then I needed streaming, but usually I want a tree
03:25:14 <b_jonas> and the fun thing is, XML::Twig allows both with the api being similar enough (because parts of the stream are kept in memory as an incomplete tree) which makes it easier to learn
03:26:04 <quicksilver> b_jonas: tagsoup is your basic streaming thingy.
03:26:13 <quicksilver> I'm not sure any of the alternatives support 'incomplete trees'
03:26:16 <quicksilver> malcolmw: ?
03:27:11 <malcolmw> if your access pattern is streamed, then HaXml offers lazy on-demand parsing, so the whole tree does not need to be in memory
03:28:10 <quicksilver> you don't get 'explicitly incomplete' trees, though, do you
03:28:22 <quicksilver> you get 'implicitly incomplete' with haskell thunks
03:28:30 <quicksilver> which automatically complete themselves as you access them
03:28:41 <quicksilver> of course, this may be what b_jonas wants, but it ain't quite the same.
03:28:41 <b_jonas> I see
03:29:08 <b_jonas> I'm not sure what I want
03:29:16 <b_jonas> probably complete trees are enough in most of the cases
03:45:17 <solrize_> > let m2 = map head . group . scanl1 max in m2 [1,2,5,4,2,5,1,9,3,4,1]
03:45:19 <lambdabot>  [1,2,5,9]
03:46:51 <trez> > let m2 = map head . group . scanl1 max in m2 [a,b,c,d,e] :: [Expr]
03:46:52 <lambdabot>  [a,max a b,max (max a b) c,max (max (max a b) c) d,max (max (max (max a b) c...
03:49:58 <solrize_> it iterates down the list emitting the biggest element seen so far
03:52:27 * quicksilver nods
03:52:31 <quicksilver> scanl max is very handy
03:52:46 <quicksilver> finds the increasing subsequences
03:52:52 <quicksilver> leftmost increasing subsequnce, I guess
03:53:37 <DRMacIver> Isn't that nub . scanl max ?
03:53:54 <DRMacIver> scanl max isn't a subsequence.
03:56:28 <DRMacIver> Hm. As an idle observation, I've only just noticed that show does the right thing for infinite lists. I don't know why I'm surprised by that, but I am.
03:57:16 <quicksilver> DRMacIver: how isn't it a subsequence?
04:00:19 <Twey> > show [1..]
04:00:20 <lambdabot>  "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
04:00:36 <Twey> 'The right thing?'
04:01:42 <aleator> Another string&performance related question: http://hpaste.org/7231
04:01:57 <Arnar_> morning folks..
04:02:16 <Botje> hello!
04:02:38 <Arnar_> beautiful day today.. I have a good feeling about it
04:02:50 <vixey> good morning :)
04:02:50 <Botje> today is a good day to hack some tyeps
04:03:20 <Arnar_> I was wondering if anyone could hint me where to find the C parts of the stm system.. namely atomically# and friends
04:03:36 <Arnar_> ?index atomically
04:03:36 <lambdabot> GHC.Conc, Control.Concurrent.STM
04:03:39 <Arnar_> ?src atomically
04:03:39 <lambdabot> Source not found. Are you on drugs?
04:03:43 <Arnar_> heh
04:03:44 <DRMacIver> quicksilver: It repeats elements that might not be repeated in the original list.
04:04:28 <Arnar_> atomically (STM m) = IO (\s -> (atomically# m) s )  -- where is atomically# defined?
04:04:29 <DRMacIver> Hm
04:04:35 <DRMacIver> Maybe I'm wrong. One second.
04:05:25 <DRMacIver> Oh, no I'm not.
04:05:54 <Jaak> atomically# looks very much like a primitive
04:05:56 <DRMacIver> > scanl max 0 $ [0..5] ++ [5, 4..0]
04:05:57 <lambdabot>  [0,0,1,2,3,4,5,5,5,5,5,5,5]
04:06:00 <Arnar_> Jaak: yes.. it is
04:06:07 <Arnar_> Jaak: I'm looking for the source code
04:06:25 <DRMacIver> Twey: Does the right thing in the sense of "Is sufficiently lazy"
04:06:38 <quicksilver> DRMacIver: oh, good ponit.
04:06:43 <Twey> Aha
04:06:47 <quicksilver> DRMacIver: solrize was using map head . group and I didn't notice :)
04:06:59 <DRMacIver> Isn't map head . group == nub ?
04:07:11 <quicksilver> no
04:07:16 <quicksilver> nub finds even non-local repears
04:07:21 <quicksilver> so it's quadratic time
04:07:32 <quicksilver> map head . group is amortized linear under certain assumptions.
04:07:33 <DRMacIver> Really?
04:07:41 <quicksilver> > nub [1,2,2,1]
04:07:42 <lambdabot>  [1,2]
04:07:47 <quicksilver> > map head . group $ [1,2,2,1]
04:07:49 <lambdabot>  [1,2,1]
04:08:00 <DRMacIver> Oh, so it does.
04:08:06 <DRMacIver> Oops.
04:08:14 <quicksilver> > @check \l -> nub l == map head . group $ (l :: [Int])
04:08:15 <lambdabot>  Parse error at "@chec..." (column 1)
04:08:17 <quicksilver> @check \l -> nub l == map head . group $ (l :: [Int])
04:08:18 <lambdabot>  Couldn't match expected type `[f [a]]'
04:08:28 <quicksilver> @check \l -> nub l == (map head . group $ (l :: [Int]))
04:08:29 <lambdabot>  Falsifiable, after 5 tests: [0,-1,5,0]
04:08:41 <quicksilver> DRMacIver: I should have used quick-checked the first time :)
04:08:48 <quicksilver> quite a nice example of a non-trivial counter example
04:09:50 <DRMacIver> Yeah. :)
04:10:55 <DRMacIver> I'm going to claim that I was confusing nub with unix's uniq as an attempt to look less silly now. :)
04:11:29 <DRMacIver> haskell and unix are basically isomorphic anyway. :)
04:13:01 <osfameron> though isn't the implementation of nub rather less efficient?
04:13:15 <quicksilver> as I said
04:13:19 <quicksilver> nub is quadratic time :)
04:13:25 <quicksilver> map head . gropu is linear
04:13:42 <quicksilver> however, nub can't do any better without making more assumptions than Eq a =>, I don't believe.
04:13:56 <osfameron> does a Map need more than Eq?
04:14:03 <osfameron> oh, Ord I guess
04:14:41 <osfameron> or "Hashable" but that's not very popular in haskell
04:14:51 <quicksilver> leksah-- # daft version numbering, apparently.
04:16:07 <eugman|college> So, when providing one of the arguments, why does an infix operator need to be in parens with the argument, like (+3)?
04:16:22 <DRMacIver> quicksilver: Indeed. It seems pretty clear that with just Eq nub has to run through every pair of elements in the list to determine equality
04:16:26 <sioraiocht> eugman|college: that's syntactic sugar
04:16:33 <sioraiocht> for (+) 3
04:16:35 <vixey> (+3) = (\x -> x + 3)
04:16:45 <DRMacIver> With Ord you can of course do map head . group . sort
04:16:54 <sioraiocht> > ((+) 3) 4
04:16:55 <lambdabot>  7
04:17:07 <sioraiocht> > ((+3) 4)
04:17:08 <lambdabot>  7
04:17:17 <sioraiocht> > (\x -> x + 3) 4
04:17:17 <lambdabot>  7
04:17:41 <sioraiocht> it's just a lot easier, esp when using higher order functions
04:17:42 <vixey> > (/ 3) 9
04:17:43 <lambdabot>  3.0
04:17:53 <vixey> > (\x -> x / 3) 9
04:17:54 <lambdabot>  3.0
04:17:59 <sioraiocht> > map (+3) [1..5]
04:18:00 <lambdabot>  [4,5,6,7,8]
04:18:05 <vixey> > (/) 3 9
04:18:06 <lambdabot>  0.3333333333333333
04:18:12 <eugman|college> ah ok, So the parens are requires to make it prefix and it is nice and allows you to sneak in an argument?
04:18:22 <vixey> so (+) 3 is probably a bad way to think of it
04:18:50 <sioraiocht> eugman|college: well, (+) is a way of making an infix function prefix
04:19:02 <sioraiocht> (+3) is different
04:19:05 <sioraiocht> as vixey just showed you
04:19:09 <sioraiocht> cuz i'm zomg dumb ;)
04:19:24 <vixey> :P
04:19:30 <vixey> what you said was correct though..
04:19:38 <vixey> since x+y = y+x
04:19:45 <maltem> eugman|college, (+) is prefix notation, (+3) is a so-called section
04:19:46 <sioraiocht> right, for commutative functions it works
04:20:54 <maltem> eugman|college, in both cases the parentheses express that + is not used ordinarily as a binary operator
04:21:15 <osfameron> and we prefer not to talk about (-1)
04:21:57 <vixey> hehe
04:22:12 <vixey> @remember osfameron and we prefer not to talk about (-1)
04:22:12 <lambdabot> Okay.
04:22:56 <sioraiocht> haha
04:23:06 <sioraiocht> > map (-1) [1..5]
04:23:06 <lambdabot>   add an instance declaration for (Num (a -> b))
04:23:09 <sioraiocht> heh
04:23:10 <maltem> we could talk about i² instead
04:23:11 <sioraiocht> o i c
04:25:04 <vixey> > map (subtract 1) [1..5]
04:25:05 <lambdabot>  [0,1,2,3,4]
04:25:23 <vixey> > [(subtract 1 1)..(subtract 1 5)]
04:25:24 <lambdabot>  [0,1,2,3,4]
04:26:35 <maltem> discovering distributive laws :)
04:27:01 <eugman|college> oh... you can distribute with lists like that?
04:27:35 <eugman|college> gah! I forgot to put take before my infinite list
04:28:39 <sioraiocht> eugman|college: are they teaching you haskell in college?
04:28:46 <maltem> eugman|college, which wouldn't be that annoying if ghc handled interrupts gracefully
04:29:15 <maltem> (you press C-c all the time and nothing happens)
04:29:59 <sioraiocht> maltem: as i understand (i could b ewrong) ghc cannot interrupt a call to C, right?
04:30:58 <cjs> atoi :: ByteString -> Int; atoi = read . unpack
04:31:16 <cjs> What's a good way to make this print a better error message than "no parse"?
04:32:19 <maltem> sioraiocht, ah, is that the reason for such problems? That would be a proper explanation
04:32:32 <sioraiocht> maltem: it's the case in lua, at least.
04:32:44 <maltem> ok
04:33:20 <maltem> cjs: You would have to write your own read
04:33:34 <maltem> cjs, maybe with the help or reads
04:33:40 <maltem> s/or/of
04:34:07 <eugman|college> sioraciocht, ironically the opposite. I'm teaching haskell in college. Basically the result of a comp lang class and misdirected enthusiasm.
04:34:25 <eugman|college> Still, getting to teach my classmates should be really cool
04:34:30 <cjs> Hm.
04:34:31 <johnnowak> ack
04:35:25 <sioraiocht> eugman|college: very cool.  I was taught haskell in undergrad, proved invaluable
04:35:46 <czakey> noope
04:35:59 <czakey> I fonund Haskell on my university
04:39:26 <sioraiocht> eugman|college: what are you planning to cover?
04:39:27 <eugman|college> Yeah, haskell was one of those languages that is super crazy and supposed to teach you something about other ones like lisp or prolog do. Actually i'm probably going to start using gneerators slightly more in my python coding.
04:39:49 <eugman|college> let me pastebin the outline.
04:40:10 <czakey> Prolog was my problem
04:40:38 <czakey> I like the idea... but doesnt realy like the rest ;>
04:41:07 <b_jonas> eugman|college: how many groups have you done yet?
04:41:12 <czakey> when I find haskell I find that everything is in the right place
04:41:53 <eugman|college> b_jonas, none. It's a one time sort of thing
04:42:02 <b_jonas> I see
04:42:36 <vixey> I don't understand why so many people find Prolog so hard
04:43:20 <b_jonas> vixey: I don't find it hard in that I can write programs in it in the functional style,
04:43:23 <vixey> can't be sure if it's along the lines of what Dijkstra's said or something else
04:43:26 <b_jonas> only I don't understand its point,
04:43:35 <b_jonas> I don't get what the backtracking style is good for
04:43:55 <eugman|college> http://pastebin.com/d72f5cc63 is the general outline as it stands
04:44:23 <czakey> vixey: not so hard
04:44:25 <czakey> but so hmm
04:44:35 <czakey> so useless
04:44:38 <czakey> ;p
04:44:40 <vixey> ok
04:45:08 <eugman|college> I'm hoping to cover jsut enough to show how to make working functions/programs in the interpreter and the really cool stuff you can do with ahskell
04:45:15 <vixey> by hard I mean, people find it impractical due to e.g. not understanding how to use it properly
04:45:51 <vixey> (maybe it's the thinking/code-writing ratio is too high)
04:45:59 <czakey> I dont like reading Prolog programs
04:46:31 <b_jonas> it's probably because I had to learn it for a university course
04:46:44 <b_jonas> which required that I write a few programs but didn't really tell what it's unique in
04:46:52 <johnnowak> eugman|college: is that an entire course?
04:46:55 <czakey> ie something([H|T],X,W,L,K,S,R,[O,I]):- A, !, D, K is 3, somethingelse.
04:47:01 <czakey> blee
04:47:01 <czakey> ;)
04:47:11 <czakey> yup
04:47:16 <czakey> I have same thing
04:47:20 <b_jonas> czakey: that's not so bad. the bad part is when you have higher-order functions
04:48:20 <czakey> I had to write battleships game solver in Prolog
04:48:26 <czakey> uch, that was fun
04:48:27 <czakey> ;)
04:48:42 <eugman|college> johnnowak, No. I've basically got one class period so I am going to be lightly touching on everything and might have to take some parts out.
04:49:07 <johnnowak> yikes. that's quite a bit for one class.
04:49:15 <czakey> (Im glad that my teacher isnt here right now ;d)
04:49:53 <johnnowak> eugman|college: is it a class to teach the basics of haskell?
04:51:17 <eugman|college> Yeah. It's a general comp lang course so we've be jumping from language to language and it sort of got turned into an honors option for me so for one class I'll be covering as much of the basics as I can.
04:51:50 <czakey> don't even try to teach Monads
04:51:51 <czakey> ;p
04:52:12 <czakey> i've made a mistake
04:52:24 <johnnowak> eugman|college: so you'll be starting them with scheme, ys?
04:52:29 <eugman|college> Of course that'd be madness. I'm jsut going to explain that they act as containers and the io monad is needed for stringing functions together
04:52:30 <czakey> I wrote "monadic" program on one of my lessons
04:53:20 <eugman|college> Actually the teacher hasn't really covered anything functional except when we were doing history at the start
04:53:53 <eugman|college> And I've only got one period
04:54:30 <johnnowak> you'd do well if you just got the basics of recursion into their heads
04:54:42 <czakey> yup
04:55:04 <Arnar_> and foldl, foldr
04:55:04 <eugman|college> good point
04:55:08 * vixey wishes more people would make apparent that recursion *is* induction
04:55:21 <czakey> "to understand recursion you must firts understand recursion"
04:55:23 <eugman|college> lol, i doubt they'd know what induction is
04:55:38 <cpoucet> vixey: I thought only codata recursion was induction
04:55:54 <mauke> to understand recursion, you must first understand recursion or know someone who understands recursion
04:56:01 <czakey> yup
04:56:03 <czakey> :>
04:56:09 <Arnar_> eugman|college: I remember a particularly useful excercise (in either scheme or haskell, or even both) from my comp lang class: write a function that reverses a list using fold
04:56:18 <johnnowak> eugman|college: actually, you'd do well if you just got lexical scoping and closures across. in either case, you should be using scheme. :)
04:56:51 <cpoucet> johnnowak: or LC
04:57:03 <vixey> aren't codatas the biggest fixed points
04:57:07 <vixey> so not inductive
04:57:11 <ski> cpoucet : s/codata/data/ (alternatively s/induction/coinduction/ if you prefer)
04:57:22 <cpoucet> ski: thanks for the correction
04:57:25 <eugman|college> johnnowak, perhaps but this all happened because I show an interest in writing my final in some crazy language
04:57:33 <cpoucet> ski: then what is it that dependentn languages use to ensure termination?
04:57:39 <johnnowak> cpoucet: nah, then you have to get into currying
04:57:41 <Jaak> > let rev xs = foldr (\x k -> k . (x:)) id xs [] in rev [1,2,3]
04:57:42 <lambdabot>  [3,2,1]
04:58:06 <pozorvlak> Hello everyone. In Template Haskell, is it possible to use splices in [d| |] - style quasiquotes? I can't get them to work whatever I try :-(
04:58:09 <Deewiant> @src reverse
04:58:10 <lambdabot> reverse = foldl (flip (:)) []
04:58:29 <vixey> coinduction in dependent typed languages?
04:58:44 <vixey> all I know is it takes an entire PDF to write filter :(
04:59:01 <vixey> and I still have no clue how it works.
04:59:45 <eugman|college> @src map
04:59:46 <lambdabot> map _ []     = []
04:59:46 <lambdabot> map f (x:xs) = f x : map f xs
04:59:57 <eugman|college> hooray recursion
05:00:02 <ski> > (\as -> foldr (\a f as -> f (a:as)) id as []) [0,1,2]  -- leaning so far right you come back from the left
05:00:04 <lambdabot>  [2,1,0]
05:00:22 <vixey> map f = foldr (\x ys -> f x : ys) [] -- ?
05:00:26 <b_jonas> lol
05:00:46 <Jaak> > let map f = foldr (\x -> (f x :)) [] in map (+1) [0,0,0,1]
05:00:47 <ski> vixey : yes
05:00:47 <lambdabot>  [1,1,1,2]
05:01:04 <vixey> yikes ski :o
05:01:16 <eugman|college> so when do you use the id function?
05:01:20 <vixey> that's a cool def of reverse :D
05:01:26 <ski> eugman|college : see above
05:01:45 <Jaak> > zipWith id [(+1)] [1]
05:01:46 <lambdabot>  [2]
05:01:47 <ski> vixey : works for any `foldl'
05:02:01 <eugman|college> that's just barely too much for me to parse.
05:02:10 <vixey> yeah I saw hutton showing that foldl is implementable with foldr
05:02:35 <czakey> @let reverse_recursion (x:xs) = reverse_recursion xs ++ [x]
05:02:36 <lambdabot> Defined.
05:02:50 <czakey> > reverse_recursion [1,2,3,4,5]
05:02:51 <lambdabot>  Exception: <local>:20:0-53: Non-exhaustive patterns in function reverse_recu...
05:02:56 <czakey> yup
05:02:59 <czakey> []
05:03:03 <czakey> is missing ;)
05:03:13 <idnar> @let reverse_recursion [] = []
05:03:14 <lambdabot> Defined.
05:03:16 <czakey> @let reverse_recursion [] = []
05:03:17 <lambdabot> <local>:20:0:     Warning: Pattern match(es) are overlapped              In t...
05:03:22 <idnar> oops
05:03:24 <czakey> oops ;)
05:03:31 <czakey> > reverse_recursion [1,2,3,4,5]
05:03:32 <lambdabot>  [5,4,3,2,1]
05:03:44 <czakey> best recursion example
05:04:11 <czakey> @help let
05:04:12 <lambdabot> let <x> = <e>. Add a binding
05:04:12 <cpoucet> > fibs 5
05:04:13 <lambdabot>   Not in scope: `fibs'
05:04:24 <czakey> @help undefine
05:04:25 <lambdabot> undefine. Reset evaluator local bindings
05:04:31 <vixey> @let revappend [] ys = ys
05:04:31 <lambdabot> Defined.
05:04:34 <vixey> @let revappend (x:xs) ys = revappend xs (x:ys)
05:04:35 <lambdabot> Defined.
05:04:36 <ski> @help unlet
05:04:37 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:04:41 <czakey> @undefine reverse_recursion
05:04:41 <vixey> > revappend [1,2,3,4,5] []
05:04:42 <lambdabot> Undefined.
05:04:43 <lambdabot>  /tmp/MvshB17613.o: unknown symbol `L_revappend_info'
05:04:43 <lambdabot> user error (resolvedObj...
05:04:54 <czakey> @botsnack
05:04:54 <lambdabot> :)
05:05:12 <kaol> @let reverse_reverse = id
05:05:13 <lambdabot> Defined.
05:05:20 <czakey> lol
05:05:23 <vixey> > let revappend [] ys = ys ; revappend (x:xs) ys = revappend xs (x:ys) in revappend [1..10] []
05:05:24 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
05:05:34 <vixey> reverse = flip revappend []
05:05:49 <vixey> o(1)
05:05:56 <czakey> n
05:05:59 <[1]eugman|colleg> brb
05:08:41 <ski> > let rev as = reset (loop as) where {loop [] = []; loop (a:as) = shift c -> a : c (loop as)} in rev [0,1,2]
05:08:41 <lambdabot>  Parse error at "->" (column 73)
05:08:44 <ski> > let rev as = loop as id where {loop [] k = k []; loop (a:as) c = loop as (\sa -> a : c sa)} in rev [0,1,2]
05:08:45 <lambdabot>  [2,1,0]
05:10:41 <vixey> > let rev as = loop as id where {loop [] k = k []; loop (a:as) c = loop as (\sa -> (a : c sa) ++ [a])} in rev [0,1,2]
05:10:42 <lambdabot>  [2,1,0,0,1,2]
05:11:12 <vixey> > let rev as = loop as id where {loop [] k = k []; loop (a:as) c = loop (as ++ [a]) (\sa -> a : c sa ++ [a])} in rev [0,1,2]
05:11:18 <lambdabot> Terminated
05:11:24 <ski> now try to get `[0,1,0,2,0,1,0]' or `[2,1,2,0,2,1,2]'
05:15:10 <pozorvlak> Hey, does anyone know anything about templates?
05:15:11 <ski> (er, s/k/c/ .. that's what you get for not having editor-supported scope-respecting renames ..)
05:15:34 <vixey> > let rev as = loop as id where {loop [] k = k []; loop (a:as) c = loop as (\sa -> a : (loop (c sa) (a:)))} in rev [0,1,2,3,4]
05:15:39 <lambdabot>  [4
05:15:45 <Jaak> what...
05:15:48 <vixey> :P
05:15:53 <ski> ?
05:15:54 <vixey> best I can do :/
05:16:01 <ziman> pozorvlak, (OT) how did you get that name? :)
05:16:06 <b_jonas> hmm
05:16:12 <b_jonas> > reverse [0..4]
05:16:12 <lambdabot>  [4,3,2,1,0]
05:16:13 <ski> vixey : for what ?
05:16:19 <pozorvlak> ziman: from the sign on a Czech level crossing :-)
05:16:22 <vixey> trying to get [0,1,0,2,0,1,0]
05:16:43 <vixey> oh wait a sec
05:17:04 <pozorvlak> ziman: I thought it sounded like an excellent name for a sinister supervillain :-) And yes, I know what it means.
05:17:57 <ziman> pozorvlak, :)
05:18:04 <vixey> > let q [] c = c [] ; q (x:xs) c = c (x : q xs (\k -> x : c k)) in q [0,1,2] id
05:18:05 <lambdabot>  [0,0,1,1,0,2,2,1,0]
05:18:27 <ski> shall i give a solution ?
05:18:28 <vixey> > let q [] c = c [] ; q (x:xs) c = x : c (q xs (\k -> x : c k)) in q [0,1,2,3] id
05:18:29 <lambdabot>  [0,1,0,2,1,0,3,2,1,0,3,2,1,0]
05:18:33 <b_jonas> > let { f 0 = []; f x = let { y = x - 1; z = f y; } in z ++ y : z } in f 4
05:18:34 <lambdabot>  [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0]
05:19:19 <ski> b_jonas : yes .. though for (an arbitrary list and) using nqCPS
05:20:03 <b_jonas> oh, it gets easier if you want an arbitary list actually
05:20:58 <b_jonas> > let { f [] = []; f s = let { y : r = s; z = f r; } in z ++ y : z; } in f (enumFromTo 0 3)
05:21:00 <lambdabot>  [3,2,3,1,3,2,3,0,3,2,3,1,3,2,3]
05:21:16 <b_jonas> > let { f [] = []; f s = let { y : r = s; z = f r; } in z ++ y : z; } in f (reverse (enumFromTo 0 3))
05:21:18 <lambdabot>  [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0]
05:21:29 <b_jonas> the problem is that mine isn't lazy enough
05:21:30 <b_jonas> that is
05:21:33 <ski> vixey : still thinking about it ?
05:21:36 <b_jonas> > let { f [] = []; f s = let { y : r = s; z = f r; } in z ++ y : z; } in f (reverse (enumFrom 0))
05:21:41 <b_jonas> this doesn't work
05:21:42 <lambdabot> Terminated
05:21:44 <vixey> yes
05:22:03 <b_jonas> I wonder, does it work with yours?
05:22:12 * ski tries
05:22:42 <ski> apparently not
05:23:44 <b_jonas> let's try to write it that way
05:24:01 <vixey> > let q [] c = c [] ; q (x:xs) c = q xs (\k -> c k ++ x : c k) in q "abc" id
05:24:02 <lambdabot>  "abacaba"
05:24:02 <vixey> :D
05:24:10 <vixey> > let q [] c = c [] ; q (x:xs) c = q xs (\k -> c k ++ x : c k) in q ".-^" id
05:24:11 <lambdabot>  ".-.^.-."
05:24:43 <ski> vixey : fine :)
05:25:19 <pozorvlak> @help Num
05:25:21 <luqui> > let q [] c = c [] ; q (x:xs) c = q xs (\k -> c k ++ x : c k) in q [0..] id
05:25:25 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:25:27 <lambdabot> Terminated
05:25:42 <pozorvlak> @src Num
05:25:43 <lambdabot> class  (Eq a, Show a) => Num a  where
05:25:43 <lambdabot>     (+), (-), (*)           :: a -> a -> a
05:25:43 <lambdabot>     negate, abs, signum     :: a -> a
05:25:43 <lambdabot>     fromInteger             :: Integer -> a
05:26:17 <johnnowak> is anyone aware of code that makes use of HList?
05:26:36 <quicksilver> HAppS I think?
05:26:52 <quicksilver> I've seen other code which re-implements small portions of HList as needed.
05:27:02 <quicksilver> it's not been something I've ever needed or wanted in practical code though.
05:27:14 <johnnowak> aye.
05:27:55 <b_jonas> > let { i [] _ = []; i (x : r) s = x : i s r; f [] = []; f (a : r) = i (repeat a) (f r); } in f (enumFrom 0)
05:27:58 <lambdabot>  [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1...
05:28:20 <vixey> > let q [] c = c [] ; q (x:xs) c = q xs (\k -> c k ++ x : c k) in map (\n -> (1+) . length $ q [1..n] id) [0..]
05:28:23 <b_jonas> is something like that i function in the prelude?
05:28:28 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
05:28:38 <b_jonas> > let { i [] _ = []; i (x : r) s = x : i s r; } in i "foo" "bar"
05:28:39 <lambdabot>  "fboaor"
05:29:55 <vixey> > concat $ zipWith (\x y->[x,y]) "foo" "bar"
05:29:56 <lambdabot>  "fboaor"
05:30:02 <luqui> b_jonas, uh, no.
05:30:29 <vixey> @src (\x y->[x,y])
05:30:29 <lambdabot> Source not found. My mind is going. I can feel it.
05:30:33 <vixey> @pl (\x y->[x,y])
05:30:33 <lambdabot> (. return) . (:)
05:30:37 <vixey> @pl (\x y z->[x,y,z])
05:30:38 <lambdabot> (. ((. return) . (:))) . (.) . (:)
05:30:41 <vixey> @pl (\x y z w->[x,y,z,w])
05:30:42 <lambdabot> (. ((. ((. return) . (:))) . (.) . (:))) . (.) . (.) . (:)
05:31:07 <EvilTerran> er. maybe not.
05:31:19 <ski> > let f = foldr (\a as -> a : foldr (\a' as -> a' : a : as) [] as) [] in take 15 $ f [0..]  -- vixey,b_jonas
05:31:20 <lambdabot>  [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0]
05:31:53 <b_jonas> ski: looks better
05:31:55 <johnnowak> vixey: that last one is 'roll [] [swons] i4' in joy.
05:33:24 <johnnowak> oh. read that wrong. just '[] [swons] i4'.
05:33:33 <ski> b_jonas : hm, i tried almost your approach first, but didn't work (i had `i [] s = s' for some reason, i see)
05:33:37 <vixey> :t (f . (.) . (.) . g)
05:33:39 <lambdabot> forall b (f :: * -> *) a b1 (f1 :: * -> *) (f2 :: * -> *). (Functor f2, SimpleReflect.FromExpr (f2 (a -> b1)), Functor f1, Functor f, SimpleReflect.FromExpr b, Show (f (f1 a) -> f (f1 b1))) => f2
05:33:39 <lambdabot> b
05:33:45 <johnnowak> ...
05:33:47 <vixey> :t (?f . (.) . (.) . ?g)
05:33:49 <lambdabot> forall b (f :: * -> *) a b1 (f1 :: * -> *) (f2 :: * -> *). (Functor f2, ?g::f2 (a -> b1), Functor f1, Functor f, ?f::(f (f1 a) -> f (f1 b1)) -> b) => f2 b
05:34:13 <vixey> :t (f.(.).(.).(.).(.).(.).(.).(.).(.).g)
05:34:14 <ski> @type let (.) = (P..) in \f g -> (f . (.) . (.) . g)
05:34:16 <lambdabot> forall b (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *) (f4 :: * -> *) (f5 :: * -> *) (f6 :: * -> *) a b1 (f7 :: * -> *) (f8 :: * -> *). (Functor f8, SimpleReflect.FromExpr (f8 (a -> b1))
05:34:16 <lambdabot> , Functor f7, Functor f6, Functor f5, Functor f4, Functor f3, Functor f2, Functor f1, Functor f, SimpleReflect.FromExpr b, Show (f (f1 (f2 (f3 (f4 (f5 (f6 (f7 a))))))) -> f (f1 (f2 (f3 (f4 (f5 (f6 (
05:34:16 <lambdabot> f7 b1))))))))) => f8 b
05:34:17 <lambdabot> forall c a b c1 a1 a2. (((a -> a1 -> b) -> a -> a1 -> c1) -> c) -> (a2 -> b -> c1) -> a2 -> c
05:34:18 <johnnowak> vixey: what's with the crazy type?
05:35:01 <ski> johnnowak : (CalePrelude..)
05:35:08 <b_jonas> > let { i [] _ = []; i (x : r) s = x : i s r; f s = foldr (i . repeat) [] s; } in f " .-^|" -- this is the same as mine but shorter
05:35:10 <lambdabot>  " . - . ^ . - . | . - . ^ . - . "
05:35:12 <johnnowak> ah, right.
05:35:38 <luqui> johnnowak, what is joy?
05:35:49 <quicksilver> we should answer that with a poem
05:35:52 <ski> (johnnowak : oh, and the reflection hack)
05:35:58 <quicksilver> @go joy concatenative
05:36:07 <lambdabot> http://groups.yahoo.com/group/concatenative/
05:36:08 <lambdabot> Title: concatenative : Discuss the concatenative variety of computer languages: Joy, Fo ...
05:36:17 <quicksilver> that's close enouguh, I'm sure you can find it from ther :)
05:36:26 <johnnowak> luqui: http://www.latrobe.edu.au/philosophy/phimvt/joy.html
05:36:30 <lambdabot> Title: Main page for the programming language JOY
05:36:35 <ski> @where joy
05:36:36 <lambdabot> I know nothing about joy.
05:36:46 <luqui> aww :-(
05:36:47 <ski> @where+ joy http://www.latrobe.edu.au/philosophy/phimvt/joy.html
05:36:49 <lambdabot> Good to know.
05:36:57 <quicksilver> @remember lambdabot I know nothing about joy.
05:36:57 <lambdabot> I will remember.
05:37:01 <quicksilver> tragic, really.
05:37:08 <johnnowak> joy is a function-level programming language where programs are formed only through function composition
05:37:23 <quicksilver> it's not really composition in the haskell sense
05:37:38 <quicksilver> it's more like sequencing them over a shared state
05:37:42 <johnnowak> it's the composition of unary functions (stack -> stack)
05:37:43 <quicksilver> (Which is a kind of composition)
05:37:47 <quicksilver> yeah
05:38:19 <johnnowak> quicksilver: it's not really a shared state though in joy; you can save/restore it. many combinators do. so it's not the same as forth where you're clobbering some shared array really.
05:39:37 <johnnowak> 1 2 3 stack [ + + ] dip
05:39:38 <johnnowak> ==> [3 2 1] 6
05:39:40 <luqui> sounds like forth...ish
05:40:14 <johnnowak> luqui: it's more like a pointfree lisp really
05:40:35 <vixey> It's not like lisp :/
05:40:37 <quicksilver> johnnowak: true
05:40:56 <quicksilver> you can embed it in haskell or ocaml and make it typed, too.
05:41:00 <johnnowak> vixey: garbage collection, higher order functions, everything is a list... not like lisp?
05:41:03 <quicksilver> modulo syntax, of course
05:41:13 <vixey> johnnowak: Is data code ?
05:41:16 <johnnowak> even the stack in joy is a list. even *functions* are lists.
05:41:29 <tirpen> What is the proper way to remove a haskell package on GHC+Linux? I've removed the corresponding directories from /usr/local but do I have to unregister them with ghc somehow?
05:41:41 <johnnowak> vixey: yes.
05:41:51 <johnnowak> vixey: eval and apply are the same thing in joy
05:41:57 <EvilTerran> ghc-pkg unregister foo
05:42:20 <ddarius> > transpose ["foo","bar"]
05:42:21 <lambdabot>  ["fb","oa","or"]
05:42:22 <tirpen> Thanks
05:42:28 <ddarius> > concat $ transpose ["foo","bar"]
05:42:28 <lambdabot>  "fboaor"
05:42:41 <eugman|college> bwuh?
05:42:47 <Syzygy-> > transpose ["foo","bar","baaz"]
05:42:48 <lambdabot>  ["fbb","oaa","ora","z"]
05:42:56 <eugman|college> What magic is this?
05:42:59 <EvilTerran> tirpen, or, if you installed with cabal...
05:42:59 <johnnowak> vixey: in Joy, [$A] i = $A, where $A is some series of functions. so '[1 2 +] i' is the same as '1 2 +'. and '[1 2 +]' is just a list.
05:43:06 <pozorvlak> > concat $ ["foo", "war"]
05:43:06 <lambdabot>  "foowar"
05:43:08 <sclv> @src transpose
05:43:08 <lambdabot> transpose []             = []
05:43:08 <lambdabot> transpose ([]   : xss)   = transpose xss
05:43:08 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
05:43:11 <ddarius> > transpose $ tails [0..]
05:43:12 <lambdabot>  [[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
05:43:14 <EvilTerran> runhaskell Setup unregister
05:43:14 <pozorvlak> > concat $ transpose ["foo", "war"]
05:43:15 <lambdabot>  "fwoaor"
05:43:20 <pozorvlak> Better.
05:43:20 <EvilTerran> in the folder you installed from
05:43:35 <Syzygy-> > [0..] == first . transpose . tails $ [0..]
05:43:36 <lambdabot>  Couldn't match expected type `a b' against inferred type `[]'
05:43:40 <EvilTerran> > transpose [[a,b,c],[x,y,z]]
05:43:41 <lambdabot>  [[a,x],[b,y],[c,z]]
05:43:51 <EvilTerran> ?src transpose
05:43:51 <lambdabot> transpose []             = []
05:43:51 <lambdabot> transpose ([]   : xss)   = transpose xss
05:43:51 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
05:43:55 <EvilTerran> no magic, eugman|college
05:44:56 <EvilTerran> ... altho i'm sure there are nicer ways of writing the body of transpose there
05:45:40 <EvilTerran> i guess it's relying on the pattern-match fail behaviour of list comprehensions to get a certain behaviour. yuck.
05:46:38 <luqui> EvilTerran, actually that was one of the more magic things I've seen
05:46:41 <luqui> > a
05:46:42 <lambdabot>  a
05:46:45 <luqui> > :t a
05:46:45 <lambdabot>   parse error on input `:'
05:46:47 <luqui> er
05:46:47 <luqui> :t a
05:46:49 <lambdabot> Expr
05:46:55 <luqui> @src Expr
05:46:55 <lambdabot> Source not found. I feel much better now.
05:47:53 <luqui> > [aa]
05:47:54 <lambdabot>   Not in scope: `aa'
05:48:11 <EvilTerran> dammit, fire alarm
05:48:13 <luqui> ok, so someone just defined the single letters then
05:48:27 <ddarius> @let aa = var "aa"
05:48:28 <lambdabot> Defined.
05:48:31 <ddarius> > [aa]
05:48:33 <lambdabot>  [aa]
05:48:51 <johnnowak> (define (transpose . x) (apply map list x))
05:48:59 <sclv> I don't see why using pattern-match fail behavior is a yuck?
05:50:47 <sclv> the two traversals of xss are maybe a bit yucky, but they do give you lots of laziness...
05:50:59 <ski> > foldr (zipWith (:)) (repeat []) [[0,1,2],[3,4,5],[6,7,8]]  -- good enough ?
05:51:01 <lambdabot>  [[0,3,6],[1,4,7],[2,5,8]]
05:51:58 <johnnowak> B+
05:52:13 <sclv> the worst part of transpose is just that it doesn't give you transpose . transpose x = x
05:52:15 <ddarius> > getZipList . foldr (<*>) (pure []) $ map ZipList [[0,1,2],[3,4,5],[6,7,8]]
05:52:16 <lambdabot>   add an instance declaration for (Num ([a] -> [a]))
05:52:19 <sclv> because its not padded.
05:52:47 <ddarius> sclv: There's no way to pad it other than with undefined.
05:53:01 <sclv> ddarius: well, on a per-case basis :-)
05:53:33 <sclv> padded_trans :: a -> [[a]] -> [[a]]
05:53:59 <ski> sclv > padded_trans 0 []
05:54:00 <maltem_> A "safe" transpose makes sense mainly for Arrays/matrices
05:54:19 <sclv> ski: that should be []
05:54:36 <ski> sclv > padded_trans 0 [[],[],[]]
05:55:39 <ddarius> Even if you do pad, transpose . transpose won't be id in general.
05:55:56 <sclv> right, but with more transposes it would be at least.
05:56:29 <sclv> ski: hmm, my implementation gives me [] for that too -- but at least in my specific use case that's the right think.
05:56:40 <sclv> s/think/thing/
05:56:50 <ddarius> sclv: With more transposes, the relation will hold for the current transpose.
05:56:57 <sclv> right.
05:57:24 <quicksilver> EvilTerran: that's not yuck at all.
05:57:33 <quicksilver> EvilTerran: that's one of the best things about list comps
05:57:35 <ski> sclv : right, but `transpose []' could usefully be `replicate n []' for differing values of `n' depending on circumstances ..
05:57:42 <quicksilver> (using the pattern match failure behaviour)
05:58:10 <sclv> hmm... i wonder if it would break anything if i tried to implement that.
05:58:53 <b_jonas> not if you give it another name
06:00:57 <sclv> paddedTrans n as = take (maximum . map length $ as) . trans $ as
06:00:57 <sclv>     where trans ([] : xss)  = (n : map h xss) :  trans ([n] : (map t xss))
06:00:57 <sclv>           trans ((x : xs) : xss) = (x : map h xss) : trans (m xs : (map t xss))
06:00:57 <sclv>           trans _ = [];
06:00:58 <sclv>           h (x:_) = x; h _ = n; t (_:y:xs) = (y:xs); t _ = [n];
06:00:58 <sclv>           m (x:xs) = (x:xs); m _ = [n];
06:01:56 <sclv> list comprehensions might make that a little nicer actually...
06:04:05 <luqui> johnnowak, learning a bit... still think it looks like forth.  Kind of like forth with (reverse) currying
06:04:34 <ski> forth is also concatenative, yes
06:04:56 <luqui> okay good
06:05:13 <johnnowak> forth is mostly concatenative. things like DO...LOOP are not functions and cannot be split.
06:09:40 <luqui> :t (.)
06:09:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:10:19 <ziman> @src (.)
06:10:19 <lambdabot> (f . g) x = f (g x)
06:10:38 <ziman> ^^ this might be more comprehensible ;)
06:15:37 <luqui> I was just observing caleprelude
06:33:10 <ivanm> has anyone here tried leksah?
06:33:26 <ivanm> especially within xmonad?
06:41:13 <EvilTerran> hm... regarding the earlier discussion, transpose.transpose.transpose = transpose, right? even if it doesn't work if you take one off each side
06:41:48 * EvilTerran randomly noticed a parallel with constructive logic and felt compelled to mention it
06:43:53 <mauke> @check liftM2 (==) (transpose.transpose.transpose) transpose
06:44:08 <lambdabot>  thread killed
06:44:12 <mauke> :(
06:44:26 <ivanm> lol
06:44:38 <EvilTerran> @check liftM2 (==) (transpose.transpose.transpose) transpose
06:44:40 <lambdabot>  OK, passed 500 tests.
06:44:45 <ivanm> do I dare ask why you wanted to do that?
06:44:52 <EvilTerran> @check ap (==) (transpose.transpose)
06:44:53 <lambdabot>  Falsifiable, after 4 tests: [[]]
06:44:53 <ivanm> so why didn't it work for mauke?
06:45:21 <EvilTerran> @vixen do you not like mauke?
06:45:21 <mauke> @scheck liftM2 (==) (transpose.transpose.transpose) transpose
06:45:21 <lambdabot> sure, i definitely don't hate
06:45:22 <lambdabot>   Completed 1957 test(s) without failure.
06:46:06 <EvilTerran> ivanm, sometimes lambdabot randomly gets stuck and terminates a command. dunno why.
06:46:24 <ivanm> ahhh
06:46:48 <bens> ...maybe it's trying to transpose [[1..]]
06:47:03 <ivanm> I thought it stuck to _finite_ data...
06:47:11 <EvilTerran> > transpose [[1..]]
06:47:13 <lambdabot>  [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17]...
06:47:21 <EvilTerran> > transpose.transpose $ [[1..]]
06:47:22 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
06:47:37 <EvilTerran> > transpose.transpose $ iterate tail [[1..]]
06:47:38 <lambdabot>  [[[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
06:47:42 <EvilTerran> er
06:47:46 <EvilTerran> > transpose.transpose $ iterate tail [1..]
06:47:47 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
06:47:49 <bens> it probably does, but finite can be really big
06:47:56 <EvilTerran> infinite data doesn't seem to be a problem
06:48:11 <bens> hmm
06:48:12 <ivanm> EvilTerran: for quickcheck though?
06:48:16 * bens shrugs
06:48:28 <EvilTerran> ivanm, good point, it'd need to do the == test
06:48:34 <ivanm> exactly
06:48:37 <Saizan> i don't think quickcheck generates infinite data
06:48:37 <EvilTerran> but i doubt it produces infinite data for that, anyway
06:48:47 <EvilTerran> precisely because it'd be likely to get stuck
06:56:19 <quicksilver> EvilTerran: lambdabot has wallclock time limits
06:56:34 <quicksilver> if the machine is heavily loaded sometimes they click on before it's finished even rather simple things
07:39:47 <danchoi> could anyone here help me install xmonad on os x leopard? I think I'm about halfway through the whole process but just hit a wall
07:40:45 <takamura> danchoi: probably it's better to ask in #xmonad
07:40:51 <danchoi> ok thanks
07:41:24 <opqdonut> i'm trying to represent an AST with a GADT
07:41:55 <vixey> why GADT rather than normal algebraic type?
07:42:04 <opqdonut> is "data Expr; data Stmt; data AST a where If :: AST Expr -> AST Stmt -> AST Stmt ..." the right way to do this?
07:42:15 <opqdonut> vixey: additional type safety
07:42:42 <opqdonut> or is it unecessary?
07:44:43 <cpoucet> opqdonut: yes
07:44:51 <opqdonut> yes to which question
07:44:59 <cpoucet> right way one
07:45:04 <opqdonut> ok :)
07:45:19 <cpoucet> @google bringert composop
07:45:21 <lambdabot> No Result Found.
07:45:43 <cpoucet> http://www.google.be/url?sa=t&ct=res&cd=1&url=http%3A%2F%2Fwww.cs.chalmers.se%2F~bringert%2Fpubl%2FcomposOp%2FcomposOp.pdf&ei=DeMVSJrjLIKW0gTE0NSVAg&usg=AFQjCNFufCsATVZiCedlXnvu57H5Q901Cw&sig2=chi2wcSUxDoyTPAtjIehWA
07:45:47 <lambdabot> http://tinyurl.com/6lfu8w
07:45:47 <cpoucet> That
07:46:02 <cpoucet> That's a useful pper for writing generic folds for GADTs
07:46:05 <cpoucet> s/pper/paper
07:46:14 <cpoucet> quite accessible, code-wise
07:46:31 <bringert> opqdonut: yeah, you
07:46:34 <bringert> eh
07:46:37 <EvilTerran> http://www.cs.chalmers.se/~bringert/publ/composOp/composOp.pdf ?
07:46:40 <bringert> are on the right track
07:47:02 <EvilTerran> ... or was there a reason for the hairy google redirect link?
07:47:02 <cpoucet> EvilTerran: gracias senor
07:47:17 <cpoucet> EvilTerran: yeas, easy copy pasting :)
07:47:28 <bringert> opqdonut: depends on what you want to do though, if you just want an AST, the normal way is to use several data types
07:47:33 <EvilTerran> ... i see.
07:47:37 <cpoucet> bringert: which is a pain to traverse over
07:47:58 <cpoucet> bringert: hence your paper :)
07:48:05 <bringert> opqdonut: that gives you all the type safety you want. but as cpoucet points out, needs a lot of boilerplate to traverse
07:48:11 <opqdonut> okay
07:48:29 <opqdonut> in what situation would i get real benefit from an AST?
07:48:33 <bringert> opqdonut: but if this is the first time you are doing this, I would suggest using multiple data types first
07:48:33 <opqdonut> *GADT
07:48:50 <bringert> opqdonut: read the paper :-)
07:49:04 <opqdonut> okay
07:51:48 <opqdonut> i guess i'll go with the GADT solution and see how it feels
07:53:05 <macron> opqdonut: otherwise there is Neil Mitchell's Uniplate, which works very nicely for without the need for a GADT.
08:00:06 <quicksilver> tehre are various tricks you can do to make the boilerplate less painful.
08:00:13 <quicksilver> but ultimately they reduce the problem don't solve it.
08:00:41 <opqdonut> hmm, now i have to make a boilerplate Show-instance for the GADT
08:01:35 <bringert> yeah, that sucks
08:01:44 <bringert> opqdonut: have you looked at bnfc?
08:02:00 <opqdonut> no, what is it?
08:02:02 <bringert> it can generate a GADT AST with Show, Eq, Ord
08:02:09 <opqdonut> ah
08:02:11 <bringert> you give it a labelled BNF grammar
08:02:20 <opqdonut> i'll have a look
08:02:22 <bringert> and it gives you lexer, parser, pretty printer, AST
08:02:32 <cpoucet> bringert: for haskell?
08:02:54 <bringert> cpoucet: haskell, java, C++, O'Caml etc
08:03:05 <opqdonut> hmm
08:03:14 <cpoucet> spiffy
08:03:22 <pejo> bringert, is that stuff suitable to write "any" compiler?
08:03:46 <bringert> pejo: no, only for "well-haved
08:03:50 <bringert> damnit
08:03:51 <cpoucet> bringert: what are the syntax-restrictions?
08:03:55 <bringert> well-bhaved languages
08:04:03 <opqdonut> LALR(k) probably?
08:04:03 <cpoucet> Left-factoring?
08:04:34 <bringert> cpoucet: LALR(1), but BNFC doesn't enforce that, it just generates the input for happy, yacc, cup etc
08:04:52 <cpoucet> noice
08:05:12 <bringert> it's mainly useful for when you are designing your onw language
08:05:39 <opqdonut> yeah this is a compilers course project i'm doing
08:05:51 <bringert> opqdonut: it's perfect for that
08:05:57 <opqdonut> :)
08:06:01 <bringert> opqdonut: we use it in our compilers courses
08:06:07 <opqdonut> ok, sweet
08:06:16 <bringert> depends on the course of course
08:06:17 <cpoucet> bringert++
08:06:41 <bringert> that is, it depends on the language that you are working with
08:07:20 <bringert> but we find that using bnfc frees up time for the students to work on the parts that are more interesting that lexing, parsing, pretty printing and ASTs
08:07:22 <cpoucet> bringert: and the nice thing is, happy supports GLR
08:07:31 <bringert> cpoucet: true
08:07:46 <cpoucet> I wonder if this would work with a BNF of c++
08:07:53 <bringert> yikes
08:08:04 <bringert> C++ isn't context-free is it
08:08:15 <quicksilver> no, it's not.
08:08:22 <quicksilver> but there is probaly a context-free superlanguage
08:08:23 <cpoucet> b	you can parse c++ with glr
08:08:29 <quicksilver> which you can post-process.
08:08:33 <cpoucet> and then do the disambiguation at namesspace-lookup-time
08:08:43 <cpoucet> quicksilver: yes, but it's inherently ambiguous, hence the need for GLR
08:09:09 <quicksilver> could be worse. It could be Perl.
08:09:11 <cpoucet> that's what elsa/elkhound does
08:10:41 <mauke> perl is easier than c++
08:11:19 <quicksilver> mauke: practicaly maybe it is
08:11:23 <quicksilver> btu techcnically it isn't
08:11:28 <quicksilver> parsing perl is halting-complete.
08:11:36 <mauke> so is C++
08:11:38 <quicksilver> you actually can't do it, except by runnin the code.
08:11:45 <quicksilver> really?
08:11:55 <vixey> parsing perl requires a perl implementation, doesn't mean it's harder or easier than implementing C++
08:11:55 <mauke> A<B>::c(d);
08:11:55 <quicksilver> you need to do template resolution even to parse it?
08:12:06 <mauke> is ::c a typename or a function?
08:12:21 <quicksilver> well you build a big namespace and then look it up.
08:12:41 <quicksilver> but are their halting problem problems in building the namespace?
08:13:31 <quicksilver> I didn't think there were, but my C++ knowlege is a bit shallow.
08:13:38 <ABoyNamedWooh> Does anyone know a good source of information on a so-called system.process.runInteractiveProcess? It was mentioned on h-cafe but I can't find anything on it...
08:14:00 <quicksilver> ABoyNamedWooh: well  the docs would be a good place to start :)
08:14:11 <mauke> template<size_t N> struct A; template<size_t N> struct A<N> : A<N % 2 ? N * 3 + 1 : N / 2> {}; template<> struct A<1> { typedef int c; };
08:14:12 <quicksilver> ABoyNamedWooh: http://www.haskell.org/ghc/docs/latest/html/libraries/
08:14:14 <ABoyNamedWooh> haha I can't find the docs!
08:14:27 <ABoyNamedWooh> ah, there it is
08:14:29 <ABoyNamedWooh> thank you quick
08:14:36 <ABoyNamedWooh> I really need to buff up my haskell bookmarks
08:14:58 <quicksilver> mauke: interesting. I didn't know you could put typedefs into specialisations like that.
08:15:01 <quicksilver> mauke: nice.
08:15:12 <quicksilver> mauke: (or nasty, depending how you look at it)
08:15:30 <mauke> quicksilver: you could also make one specialization with ::c being a type and another with ::c being a method
08:15:41 <quicksilver> mauke: yes, I understood the implication.
08:15:48 <mauke> sizeof can be used in template arguments. that means you need to do struct layout in the lexer
08:15:48 <quicksilver> mauke: that's the thing I didn't realise was possible :)
08:16:03 <mauke> including a complete inheritance implementation
08:16:04 <quicksilver> mauke: do 'real' C++ compilers handle this correctly?
08:16:15 <mauke> I'd hope so
08:16:32 <mauke> I'm pretty sure there's code that relies on this
08:17:45 <cpoucet> bah
08:17:52 <cpoucet> c++ standard-compliance is borky
08:18:01 <cpoucet> even today I had issues with a compiler on redhat, cause it was 3.2.3
08:18:14 <mauke> oh, and "export"
08:18:15 <cpoucet> template <typename A> class B : public C<A> { ..};
08:18:35 <cpoucet> not to mention if you go to the very recent c++ ccompiler
08:18:42 <cpoucet> suddenly they need a whle bunch more "typename" annotations
08:18:53 <cpoucet> the funny thing is, if you leave it out, the compiler says "error need 'typename'"
08:19:03 <cpoucet> Instead of just filling it in :)
08:19:10 <cpoucet> Compilers that make you work
08:19:51 <quicksilver> mauke: if you hide non-termination in there they just hang at compile time?
08:20:05 <mauke> quicksilver: I think they just limit the recursion stack
08:20:09 <cpoucet> Yep
08:20:11 <cpoucet> 17
08:20:19 <cpoucet> IS the official number iirc
08:20:22 <quicksilver> ah, fair enough.
08:20:25 <mauke> there is no official number
08:20:26 <quicksilver> 17 is a good number.
08:20:31 <cpoucet> mauke: yes there is
08:20:41 <quicksilver> I bet given the number 17 you can do a trick which makes it 17^17
08:20:48 <quicksilver> by back-and-forthing between two or something
08:20:56 <cpoucet> quicksilver: no that's generic template depth
08:21:16 <quicksilver> and then 17^^^^....17 times ^^^^^16
08:22:50 <mauke> cpoucet: 17 is the minimum recommended depth in Annex B (informative)
08:23:02 <cpoucet> quicksilver: there's a simple flag in g++ to change it
08:23:12 <cpoucet> mauke: correct, which makes it a std number
08:23:17 <mauke> "However, these quantities are only guidelines and do not determine compliance"
08:23:20 <cpoucet> mauke: i.o.w. you're note guaranteed to get more
08:23:32 <mauke> you're also not guaranteed to get 17
08:23:35 <cpoucet> I wonder whree they got 17 tho
08:23:43 <vixey> 17 is prime
08:23:50 <cpoucet> so is 23
08:24:00 <vixey> hmm true
08:24:11 <cpoucet> or most arbitrary primes :)
08:24:13 <ski> 17 is a fermat prime
08:24:30 <cpoucet> ski: what does being a fermat prime have to do with template-depth
08:24:38 <ski> no idea :)
08:24:41 <vixey> so is 127 though?
08:24:45 * cpoucet would've picked something sane like , 4096
08:24:45 <ski> 357
08:24:51 <ski> s/3/2/
08:24:57 <vixey> darn
08:25:06 <cpoucet> 65537 (:
08:29:15 <ABoyNamedWooh> does anyone know of a good user input library? like, some sort of listening and time based execution library?
08:35:48 <Dafra> hi
08:35:57 <Dafra> neewbie needs help with profiling
08:35:59 <pavizard> @Dafra Hey
08:36:00 <lambdabot> Unknown command, try @list
08:36:18 <Dafra> I have a function in a comprehension list
08:36:28 <Dafra> and it doesnt appear i profiling
08:36:37 <Dafra> any solution ?
08:37:07 <pavizard> You can paste your code here : Paste: http://hpaste.org
08:38:15 <Dafra> hpaste ? is it for me ?
08:38:20 <pavizard> yes
08:38:23 <Dafra> ok
08:39:48 <Dafra> done : profiling
08:40:51 <Dafra> "play" does not appear in the profiling file
08:42:43 <Saizan> have you compiled with -auto-all?
08:43:06 <Dafra> ghc -O6 -prof -auto-all --make test.hs
08:43:25 <Saizan> the maximum is -O2
08:43:50 <Dafra> for profiling you mean ?
08:44:07 <Saizan> for ghc in general
08:44:57 <Dafra> same result with -O2
08:46:40 <jorick> is anyone familiar with programs such as traktor, reason, ableton etc? im wondering if haskell is "fast enough" (i know...) to create a program like that. seems like an awesome 5 year plan
08:47:09 <vixey> hey jorick
08:47:34 <jorick> hey
08:47:36 <vixey> I'd like to work with you if you're planning on writing a synth
08:47:41 <jorick> everything ok?
08:47:49 <jorick> yeah awesome ! i would like that a lot !! :D
08:48:00 <vixey> I've been planning on it for a week or two anyway
08:48:27 <jorick> it will take a loooong time though
08:48:33 <vixey> I don't mind if it's Haskell or not, but GHC does have Sound.OpenAL.. (which I didn't get a working example yet)
08:49:24 <jorick> me neither ... im tired of performing with traktor (so little you can do)... not quite satisfied with ableton, i just want to make my own program
08:49:26 <pejo> Dafra, does it appear if you compile without optimization?
08:50:30 <jorick> i've been thinking about this for a pretty long time now, i already have an idea of how i want to operate (kind of like how reason operates, only i want a command line interface)
08:51:54 <Dafra> thanks pejo, it appears with -O0
08:52:23 <cjs_> Hm. Getting enough speed to do real-time waveform synthesis would be an interesting thing to try.
08:53:02 <quicksilver> 44kHz gives you 22ms per frame, doesn't it?
08:53:22 <quicksilver> 22ms is quite a long time.
08:53:26 <quicksilver> erm
08:53:30 <quicksilver> I meant microseconds
08:53:31 <quicksilver> ;)
08:54:24 <quicksilver> 22us is quite a long time.
08:56:44 <cjs_> The thing is, with stuff like this, you need to do a lot of transforms and FFTs and things.
08:57:17 <quicksilver> but you don't need to redo them every 'sound frame' do you? Or do you?
08:57:22 * quicksilver doesn't know much about it.
08:57:39 <cjs_> But I bet that that trick that they use for combining functions in ByteString could come in handy.
08:58:09 <cjs_> quicksilver: usually you do, since you've got lots of different control inputs, all moving at different rates, when you want interesting sounds.
08:58:27 <pejo> Dafra, so either it's optimized away at higher levels, or profiling is inaccurate.
08:58:38 <cjs_> And filters, etc., are usually run against arbitrary waveforms.
09:02:53 <Dafra> pejo, it is not optimized away, because when I make "play" slower, the whole program becomes slower
09:03:27 <Dafra> but optimizing makes it invisible
09:05:52 <cjs_> Hm, _The Little MLer_ is kind of fun, although the reversed syntax for parameterized data types makes my head hurt.
09:06:31 <vixey> my favorite from that series is The Reasoned Schemer
09:07:20 <Dafra> I started FP with the little lisper. I liked it.
09:11:17 <tac-tics> I have the Little Schemer, and I thought it was cute when I bought it, but reading it really hurt my head
09:13:20 * gwern  finds the bytestring API kind of impoverished
09:14:40 <Dafra> anyone knows an Array library tuned for backtracking ?
09:15:14 <Dafra> if I use Array.ST, I have to write the whole program in a monad
09:15:20 <tac-tics> Dafra: you mean tuned for using an Array monad, analogous to the List monad?
09:15:48 <Dafra> and with Array.Diff, you cant go back the old version
09:16:21 <Dafra> I need to model the state of the board game with an array
09:16:48 <Dafra> but coppying the array is too costly
09:16:51 <zooko> https://zooko.com/log-2008.html#d2008-04-28-multiple_cores_considered_wasteful
09:16:53 <lambdabot> http://tinyurl.com/6fn5r4
09:17:00 <zooko> ^-- Donald Knuth, and Zooko, commenting about multiple cores
09:17:15 <quicksilver> Dafra: you might find Data.Sequence useful.
09:17:32 <quicksilver> Dafra: it achieves good sharing between old and new versions whilst still have good update performance
09:17:51 <XGas> <zooko> https://zooko.com/log-2008.html#d2008-04-28-multiple_cores_considered_wasteful <--- What about those GPUs?
09:17:53 <lambdabot> http://tinyurl.com/6fn5r4
09:19:23 <Dafra> Don Knuth is right : it's up the software engineer to write parralel apps now
09:19:24 <tac-tics> Articles with a title of the form "X considered Y" considered unoriginal.
09:19:32 <dons> Dafra: hmm, sounds like you need a purely functional structure with lots of sharing
09:19:40 <ABoyNamedWooh> is there a way to dervive Sort on a record such that I can sort via one of the parameters?
09:19:56 <quicksilver> ABoyNamedWooh: no, but Ord is extremely easy to write.
09:20:03 <quicksilver> ABoyNamedWooh: so it's no burden to write it ourself.
09:20:03 <ABoyNamedWooh> gotcha
09:20:06 <dons> ABoyNamedWooh: hmm, no, no partial deriving Ord, but its trivial to write, as quicksilver says.
09:20:12 <ABoyNamedWooh> I'd just dervive Ord based on the record I care about, right?
09:20:13 <quicksilver> instance Ord Foo where compare = compare . fieldName
09:20:17 <dons> sortBy (comparing field1) ?
09:20:21 <ddarius> Hasn't it always been up to the software engineer?
09:20:22 <quicksilver> instance Ord Foo where compare = compare `on` fieldName
09:20:39 <dons> :t comparing
09:20:42 <ABoyNamedWooh> agh, thanks
09:20:42 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
09:20:43 <ABoyNamedWooh> ahh*
09:20:43 <dons> :t on
09:20:45 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
09:20:57 <dons> > sortBy (comparing snd) (zip [1..10] "haskell")
09:21:03 <quicksilver> instance Ord Foo where compare = comparing fieldName
09:21:04 <quicksilver> if you like
09:21:05 <lambdabot>  [(2,'a'),(5,'e'),(1,'h'),(4,'k'),(6,'l'),(7,'l'),(3,'s')]
09:21:07 <quicksilver> but I prefer `on`
09:21:14 <dons> > map fst $ sortBy (comparing snd) (zip [1..10] "haskell")
09:21:14 <quicksilver> comparing === (compare `on`)
09:21:15 <lambdabot>  [2,5,1,4,6,7,3]
09:21:19 <ABoyNamedWooh> on is pretty elevant
09:21:21 <ABoyNamedWooh> elegant*
09:21:26 <Deewiant> @src comparing
09:21:26 <lambdabot> Source not found. Take a stress pill and think things over.
09:21:41 <dons> equating and comparing are applied versions of `on`
09:21:50 <dons> > map fst $ sortBy (compare `on` snd) (zip [1..10] "haskell")
09:21:52 <lambdabot>  [2,5,1,4,6,7,3]
09:21:58 <dons> > map fst $ sortBy ((==) `on` snd) (zip [1..10] "haskell")
09:21:59 <Arnar_> :t comparing
09:21:59 <lambdabot>  Couldn't match expected type `Ordering'
09:22:00 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
09:22:02 <dons> ah well
09:22:12 <tac-tics> @src on
09:22:12 <lambdabot> (*) `on` f = \x y -> f x * f y
09:22:19 <Dafra> Data.Sequence seems optimized for adding at the ends
09:22:27 <Dafra> for random access, it is just a tree
09:23:28 <luqui> map fst $ groupBy ((==) `on` snd) (zip [1..] "haskell curry")
09:23:32 <Dafra> yes, Ocaml and Mercury have such a structure
09:23:35 <luqui> > map fst $ groupBy ((==) `on` snd) (zip [1..] "haskell curry")
09:23:36 <lambdabot>  Couldn't match expected type `(a, b)'
09:23:38 <quicksilver> Dafra: that is not true.
09:23:48 <quicksilver> Dafra: it is fast for update in the middle too.
09:23:49 <ABoyNamedWooh> do you know what package `on` is in?
09:23:50 <Dafra> they assume that when you backtrack, you never need the later versions again
09:23:53 <ABoyNamedWooh> can lambda bot tell us/
09:23:58 <luqui> > map (map fst) $ groupBy ((==) `on` snd) (zip [1..] "haskell curry")
09:23:59 <lambdabot>  [[1],[2],[3],[4],[5],[6,7],[8],[9],[10],[11,12],[13]]
09:24:00 <byorgey> @index on
09:24:00 <lambdabot> bzzt
09:24:06 <byorgey> ABoyNamedWooh: it's in Data.Function
09:24:23 <byorgey> ABoyNamedWooh: but only in ghc 6.8.1 and onwards
09:24:39 <ABoyNamedWooh> and sort is in Data.Sort right/
09:24:40 <Arnar_> quicksilver: (a little offtopic) I often confuse your nick with lambdabot's.. always surprised at the advanced conversations it can handle.. :)
09:24:47 <byorgey> ABoyNamedWooh: no, Data.List
09:24:50 <quicksilver> Dafra: (and it's not jsut a tree, it's something quite a bit cleverer than a Tree)
09:24:52 <ddarius> @hoogle on
09:24:57 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
09:24:57 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
09:24:57 <lambdabot> Data.Function :: module
09:25:04 <quicksilver> Arnar_: why do you confuse my nick with lambdabot?
09:25:06 <Dafra> OK, I have to try it
09:25:17 <ddarius> quicksilver: You've failed the Turing test.
09:26:01 <quicksilver> ddarius: I appear to have passed the reverse-turing-test
09:26:23 <Vulpyne> It's a natural mistake. The "quicksilver" key is right next to the "lambdabot" key.
09:27:08 <edwardk> gah, found an annoying issue that might be classifiable as a glitch in the semantics. If you define type (f :*: g) a = something then there are cases where (:*:) f g a are legal but (f :*: g) a isn't because it reads the latter as a partial application of a type alias, even though its immediately applied
09:27:29 <gwern> > 5 * 60
09:27:30 <lambdabot>  300
09:27:32 <ABoyNamedWooh> holy god my program seems to be working haha
09:27:55 <edwardk> @hpaste
09:27:55 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:28:07 <byorgey> ABoyNamedWooh: =D
09:28:08 <quicksilver> edwardk: that sounds like exactly the kind of bug SPJ likes :)
09:28:11 <quicksilver> edwardk: you should report it.
09:28:28 <ABoyNamedWooh> byorgey: you'd think writing a music maker would be easy in haskell? you'd be wrong :P
09:28:30 <edwardk> quicksilver: k, writing up a small test case, will hpaste
09:28:51 <byorgey> ABoyNamedWooh: hehe, probably easier than in a lot of other languages though =)
09:28:55 <quicksilver> it would be easier in haskell than any other language
09:28:55 <quicksilver> ;)
09:28:57 <byorgey> ABoyNamedWooh: what sort of music maker?
09:29:07 <quicksilver> of course that's not enough to make something which is fundamentally hard, easy.
09:29:25 <ABoyNamedWooh> well, it loops every 6 seconds, takes your input during that time, then layers it
09:29:30 <ABoyNamedWooh> so you can sort make a beat in one loop
09:29:32 <ABoyNamedWooh> then add a melody
09:29:33 <ABoyNamedWooh> and so on
09:29:39 <ABoyNamedWooh> undoing certain edits and whatnot
09:29:47 <ABoyNamedWooh> it's build on haskore which is in of itself hideous
09:32:12 <ddarius> quicksilver: If it's any consolation, I have difficulty with the Turing test apparently, and I doubt Alan Turing would pass the Turing test.
09:32:13 <ABoyNamedWooh> I mean the abstraction of haskell lends itself to music well but the inherently stateful nature of music makes it a bit nasty
09:32:55 <byorgey> ABoyNamedWooh: cool, that sounds neat!
09:33:00 <ddarius> Music is inherently stateful?
09:33:10 <zooko> tac-tics: good point.  I changed it to "multiple cores are wasteful".  :-)
09:33:11 <eugman|college> livecoding is crazy
09:33:56 <ABoyNamedWooh> ddarius: I may be using the wrong term
09:33:57 * byorgey really needs to try out some computer music/livecoding stuff at some point.
09:34:11 <ABoyNamedWooh> ddarius: I mean that like the act of making music is intricately tied with the world
09:34:20 <byorgey> as a jazz pianist and programmer, it seems sort of natural... dunno why I've never tried it yet =)
09:34:31 <ddarius> luqui: You have a typo in your blog post.
09:34:58 <quicksilver> ABoyNamedWooh: I think if you're viewing music as inherently stateful, you are viewing it quite wrongly.
09:35:09 <quicksilver> at one level of abstraction, music is a function Time -> [Note]
09:35:15 <ABoyNamedWooh> oh, well, right
09:35:15 <ddarius> luqui: Also, to answer your question, natural transformations can be generalized to dinatural transformations which should be able to handle all of the polymorphic functions.
09:35:20 <quicksilver> (that's list of Notes, which presumably include timbre etc)
09:35:26 <ABoyNamedWooh> I mean Haskore does all that... I meant the action of making music involves lots of nasty stuff
09:35:27 <ABoyNamedWooh> sorry
09:35:31 <quicksilver> at a different level it's Time -> Amplitude
09:35:36 <skorpan>     Could not find module `System.Directory':
09:35:36 <skorpan>       it is a member of package directory-1.0.0.0, which is hidden
09:35:41 <quicksilver> (that's once you've done all your encoding and it's just a signal)
09:35:42 <Baughn> quicksilver: That's a very mechanical view. Have you played music?
09:35:44 <skorpan> how do i solve that? building BNFC
09:35:53 <quicksilver> skorpan: add directory to the cabal
09:35:56 <quicksilver> (in the depends field)
09:36:05 <Baughn> skorpan: -package directory, or add it to cabal (which will do that for you)
09:36:06 <quicksilver> Baughn: of course, yes, but we are talking about mechanical music.
09:36:07 <ddarius> At a different level it's Time -> SensoryImpressions.
09:36:18 <ABoyNamedWooh> haha
09:36:19 <quicksilver> Baughn: and it was a fairly simple abstraction.
09:36:22 <skorpan> thanks
09:36:29 <ABoyNamedWooh> drugs are CrackDealer -> Divorce
09:36:35 <Baughn> quicksilver: I think you were talking past each other. Well, that aside..
09:36:57 <quicksilver> Baughn: you can imagine slightly more complex ones which are a better model of music
09:36:58 <quicksilver> but data Emotion; is hard to model ;)
09:37:02 <quicksilver> notoriously so.
09:37:02 <Baughn> Is it possible to write an instance Show a, Read a => Binary a such that it only takes effect if there is no /other/ instance for a particular type?
09:37:13 <Arnar_> quicksilver: sorry.. left, re: why I confuse your nick with lambdabot.. erhm, I have *no* idea
09:37:18 <quicksilver> Or we'd have replaced concert pianists with computers.
09:37:31 <quicksilver> Baughn: I think you can do that using overlaps and/or undecidables, yes.
09:37:33 <Baughn> quicksilver: Oh, but Emotion is quite simple compared to Thought. It's the oldest, after all. ;)
09:37:58 <Arnar_> isn't data Emotion just a simple enumeration?
09:38:01 <Baughn> quicksilver: I was hoping to add "priority 1" or somthing. Well, that'll do; I've got a guide for that here.
09:38:10 <Baughn> It just seems horribly complex for the effect
09:38:28 <Baughn> Arnar_: Okay, not /that/ simple, but it /is/ the cognitive equivalent of a global variable
09:38:40 <Arnar_> Baughn: true
09:39:09 <Arnar_> Baughn: are there any cognitive "local" variables?
09:39:22 <Baughn> Arnar_: Yes. Mostly we aren't aware of them.
09:39:29 <Arnar_> ok.. ic
09:39:37 <Baughn> ANything that doesn't affect the /entire/ brain, really..
09:39:55 <Arnar_> emotion does not necessarily affect the entire brain
09:39:59 <tuxagb> I have this declaration: data Term = Con Int | Div Term Term
09:40:20 <tuxagb> and this function: eval (Con x) = x
09:40:22 <Baughn> Arnar_: No, but it affects enough to be instantly noticable
09:40:33 <tuxagb> eval (Div x y) = eval x / eval y)
09:40:42 * Baughn thinks emotions would probably get removed if we kept evolving for another couple million years (and didn't lose our intelligence instead). It's just not a good match for intelligence, and has bad results half the time
09:40:56 <tuxagb> why ghci says: no instance of (Fractional Int)????? Help me!!!!!
09:41:00 <Arnar_> Baughn: so your really just treading the line between conscious and unconcsious thougts?
09:41:06 <Deewiant> tuxagb: use `div` instead of /
09:41:14 <EvilTerran> ?type (/)
09:41:15 <lambdabot> forall a. (Fractional a) => a -> a -> a
09:41:16 <Deewiant> @ty ((/), div)
09:41:17 <EvilTerran> ?instances Fractional
09:41:18 <lambdabot> forall a a1. (Integral a1, Fractional a) => (a -> a -> a, a1 -> a1 -> a1)
09:41:19 <lambdabot> Double, Float
09:41:30 <Baughn> tuxagb: / operates on fractional numbers, which doesn't include ints
09:41:36 <EvilTerran> tuxagb, you can only use / on types where the result can be a fraction
09:41:39 <EvilTerran> ?type di
09:41:41 <lambdabot> Not in scope: `di'
09:41:42 <EvilTerran> ?type div -- er
09:41:43 <lambdabot> forall a. (Integral a) => a -> a -> a
09:41:56 <tuxagb> thank you!
09:41:59 <EvilTerran> div rounds off, so you can use it on any integral type
09:42:24 <Baughn> Arnar_: I don't feel very comfortable talking about that; it's poorly understood by /anyone/, and I'm not a cognitive science person.
09:42:47 <Arnar_> Baughn: well neither am I (but I'm reading GEB :P  )
09:43:54 <ddarius> Baughn: Why did emotions evolve in the first place?  Are the pressures that led to them gone now?
09:44:06 <Baughn> Arnar_: It's just.. I understand /why/ we have emotions. I also understand that if I'm f.ex angry, it affects my actions towards far more than just the original object of the anger, which seems counterproductive. Cold reason wouldn't do that - because that reason knows what it's doing and why
09:44:44 <Baughn> ddarius: They're not gone, but they're being diluted, and the counter-pressures are still in place
09:45:08 <Arnar_> ddarius: the best example of it came from Gil Grissom in CSI (dunno from where they got it).. consider two ancient humans, one sees a motion in the corner of his eyes and thinks it is a cheetah and runs. The other thinks its just the wind
09:45:12 <quicksilver> I would argue that emotions are more primtive than thoughts
09:45:16 <quicksilver> but I think we're offtopic :)
09:45:16 <Arnar_> ddarius: which kind do you think survived?
09:45:22 <ddarius> Arnar_: That's not emotion.
09:45:25 <Arnar_> highly
09:45:28 <Arnar_> ddarius: fear?
09:45:55 <Baughn> quicksilver: Far more primitive, far older, very well integrated with the rest of our minds. Doesn't mean they'd last when evolution finds a better trick.
09:46:10 <Baughn> It's almost a pity we'll never see what evolution would do to us, now. :P
09:46:24 <ddarius> Arnar_: You fear the cheetah that you think you saw which is perfectly reasonable, but the odd thing is seeing a cheetah that isn't there in the first place.
09:46:43 <Arnar_> ddarius: you don't see it.. but you fear it anyways
09:46:55 <Arnar_> the fear is an autonomous emotinal response
09:47:01 <ddarius> Arnar_: I didn't say anything about seeing it.
09:47:11 <Arnar_> right.. sorry
09:47:42 <quicksilver> ddarius: but the cheetah is there. It's right behind Arnar, getting ready to jump. Can't you see it?
09:47:53 <Arnar_> gaaahh
09:48:08 <Baughn> Arnar_: Don't turn around. Besides, it might just want to play.
09:48:28 <ddarius> quicksilver: Arnar will slow him down.  I have plenty of time.
09:48:35 * Arnar_ tries to remember the velociraptor xkcd results
09:48:49 * Baughn can almost certainly run faster than Arnar_, so he's fine
09:49:09 * quicksilver searches for 'quicksilver "suspected cheetah sympathizer"'
09:49:45 * Arnar_ injects cheetah with quicksilver.. killing it immediately
09:50:11 <Baughn> Now, now. Mercury isn't actually that lethal...
09:50:32 <Baughn> People survived using it to kill bacteria, after all. At least for a while.
09:50:43 <Arnar_> so the cheetah is faking it?
09:50:49 <Baughn> MOst likely
09:51:05 <Arnar_> I /really/ should do some work
09:51:07 <Arnar_> :)
09:51:51 <Arnar_> but this is fun (while the cheetah is out of it at least)
09:52:48 <edwardk> I started ripping the stuf out of my Control.Category stuff to make it just work in Hask. http://comonad.com/haskell/ctl/dist/doc/html/ctl/ no weird category/6.9 dependencies. Any thoughts? (i still have to finish up StateCT)
09:54:42 <edwardk> i'm not fixated on the namespace structure, but i'm not quite sure whats considered 'taken' in Control.* these days
09:57:52 <edwardk> i also need to dig up some more comonads to throw in
10:00:19 <bos> sioraiocht: how goes unicode?
10:00:32 <sioraiocht> bos: pretty good, just started 2 weeks ago
10:00:41 <bos> sioraiocht: what's your plan?
10:00:55 <sioraiocht> bos: that's a rather open question =p
10:01:29 <sioraiocht> I plan to do the unicode encoding/decoding simultaneous in with streaming
10:01:34 <bos> well, let's limit it then :-)  what do you plan to use as an internal representation?
10:02:21 <bos> what encodings do you plan to support, and what types do you expect to talk to?  just strict/lazy ByteString?
10:02:48 <sioraiocht> bos: initially i will do UTF-8, but I hope to finish supporting UTF-16 and UTF-32 as well
10:03:24 <sioraiocht> bos: There will initially only be a strict version, but like ByteString the lazy version will be a chunked lazy list
10:03:33 <sioraiocht> the issue there, though, is making sure divisions aren't spilling characters
10:03:36 <sioraiocht> *splitting
10:04:11 <bos> are you going to use some sort of vector of Word32 internally?
10:04:26 <sioraiocht> bos: not necessary word32, but something
10:04:38 <sioraiocht> word32 is a bit inefficient
10:04:43 <bos> something more than 20 bits wide, is really what i'm getting at
10:05:02 <bos> i.e. i hope it won't be a 16-bit internal representation.
10:05:07 <sioraiocht> why?
10:05:45 <Baughn> On the assumption that that would involve not supporting all of unicode, I suppose
10:05:51 <bos> because it's messy, due to not being able to support the astral planes
10:05:59 <Baughn> It might be good to have more than 20 bits, though. Future-proofing.
10:06:28 <bos> yes, a 32-bit representation would make sense for uniformity and performance.
10:06:54 <sioraiocht> Baughn: I don't see the unicode standard widening very soon...
10:07:04 <Baughn> If not that, then how about utf-16?
10:07:19 <bos> aah! noooO!
10:07:47 <bos> java and c# have already demonstrated that that's a mistake.
10:07:58 <bos> we don't need to remake other people's mistakes.
10:08:45 <sioraiocht> there will likely be 8/16/32 bit versions tested for performance purposes
10:09:59 <bos> are you going to provide library-based fusion?
10:10:03 <sioraiocht> yes
10:10:16 <sioraiocht> there will be the expected list of fusible functions
10:10:19 <bos> cool.
10:10:25 <sioraiocht> using stream fusion
10:10:39 <bos> i'm looking forward to this getting done. it's been a gaping hole for a while.
10:10:42 <sioraiocht> yeah
10:11:06 <sioraiocht> well, I have to submit my dissertation in sept, so expect a FINISH product no later than the end of july, and probably much more much much earlier
10:11:12 <bos> how long is your timescale to finishing it as an MS project?  ok, cool.
10:11:44 <bos> i think you'll be swarmed by people submitting patches at that point :-)
10:11:51 <sioraiocht> yeah, undoubtedly =p
10:12:36 <bos> are you using Data.Stream to provide fusion, or just importing the ideas?
10:13:19 <sioraiocht> the ideas
10:17:55 <sioraiocht> i'm going for a completely strict version, at first
10:18:03 <sioraiocht> which is necessary for any lazy implementation, anyway
10:18:18 <sioraiocht> and if I don't implement it, undoubtedly someone else will =p
10:21:11 <lispy> does haskell have a nice streaming IO library?
10:21:29 <lispy> preferably one where the memory usage O(1)?
10:23:35 <sioraiocht> lispy: ByteString?
10:24:21 <lispy> sioraiocht: I could be mistaken, but I don't think bytestring does this
10:24:28 <glguy> lispy: either lazy list IO or lazy bytestring io
10:24:52 <sioraiocht> yeah, either will use a lazy representation
10:24:55 <lispy> I'd like to avoid lazy IO and use actual streams
10:25:09 <sioraiocht> lispy: meaning...?
10:25:48 <sioraiocht> what have you got against lazy IO? ;)
10:26:04 <lispy> one of the problems with lazyIO is that you can't control the bound on memory usage, one accidentally strict thing and bam, you're done
10:26:10 <lispy> sioraiocht: a lot :)
10:26:21 <sioraiocht> lispy: there's handle based I/O
10:27:35 <lispy> So what I want, is to have a fixed size buffer, with a streaming api thingy on top.  so you say, "I want the next bit" and you get it, the IO happens then and you only get so many bytes loaded into memory and that buffer gets reused
10:27:47 <lispy> lazyIO doesn't let you control the bucket size
10:27:52 <dons> bos, do you know who the fedora haskell packagers are?
10:28:00 <lispy> it also is too easy to accidentally request too much at once
10:28:07 <dons> there's a new release of fedora coming up, and still no xmonad package :(
10:28:08 <glguy> dons:  I thin kthat bos is
10:28:16 <dons> ah ha
10:28:17 <glguy> or at least he's a ghc one
10:28:45 <lispy> sioraiocht: so I want an explicit stream instead of an implicit one, does that make sense?
10:28:51 <sioraiocht> lispy: yes
10:28:55 <glguy> zomg 15 days until release
10:29:01 <glguy> X-D
10:29:04 <dons> http://fedoraproject.org/wiki/PackagingDrafts/Haskell
10:29:05 <sioraiocht> i just dunno if you'll find it =p
10:29:05 <lambdabot> Title: PackagingDrafts/Haskell - Fedora Project Wiki
10:29:23 <dons> glguy: yeah, 15 days is a bit tight. i imagine we can't get a package in by then, without special powers
10:29:32 <lispy> sioraiocht: right it's not a very Haskell-ish api.
10:29:40 <dons> it was massively useful to get into the most recent ubuntu stable, though.
10:29:47 <dons> immediate jump in users
10:29:50 <lispy> sioraiocht: but I think C++ style streams would actually be pretty okay here.
10:30:32 <dons> oh, loupgaroublond is also involved, and he's an xmonad user
10:30:32 <sioraiocht> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
10:30:33 <lambdabot> http://tinyurl.com/sbkmj
10:30:36 <sioraiocht> that's the best you'll get, i think
10:30:38 <lispy> I guess I should check hackage
10:30:54 <dons> sjanssen: 100 ubuntu installs  now :)
10:31:34 <sioraiocht> lispy: System.IO has buffered i/o, does that help? =p
10:32:18 <lispy> sioraiocht: well, I want something on top of buffered, but yeah it would be a place to start.  I also see streamproc on hackage
10:38:10 <dcoutts_> @yarr!
10:38:10 <lambdabot> Arrr!
10:38:28 * dcoutts_ needs rehab after teaching UML and Object Oriented Design
10:38:34 <gwern> 'It should be noted that if nonstandard causality is allowed, information processing could turn extremely strange. The halting problem could be solved7 and all calculations could be done in O(1) time8. Inconsistent programs (receive X from the future, send back X+1) would force an outside error (such as transmission noise or circuit breakdown) to keep the universe consistent. '
10:38:56 <byorgey> dcoutts_: yeesh
10:39:22 <Baughn> gwern: Moravec? I thought his /couldn't/ be used for solving the halting problem
10:40:25 <byorgey> @pl \f g x y -> (f g x, g y)
10:40:26 <lambdabot> (flip . (((.) . (,)) .) =<<)
10:40:30 <byorgey> dcoutts_: there you go =)
10:40:31 <gwern> http://ftp.nada.kth.se/pub/home/asa/Work/Brains/Brains2/node20.html#tex2html10 'the computer would simply report if it received a signal from the future or not, and then start running the program. If the program halts, the computer will send a signal back in time to itself. '
10:40:32 <lambdabot> Title: Wormholes, http://tinyurl.com/5uu96w
10:40:36 <Deewiant> > fix (((0:).)<$>((1:).)<$>zipWith(+)<*>tail)
10:40:37 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
10:40:41 <dcoutts_> byorgey: thanks :-)
10:41:08 <ski> lispy : an interface like <http://www.standardml.org/Basis/stream-io.html> (the `instream' part) wouldn't do ?
10:41:14 <Baughn> gwern: Yes, but that requires infinite time
10:41:31 <Baughn> gwern: Sure you can get the answer immediately, but you then have to keep the computer running forever or you might get a false negative
10:41:31 <Deewiant> @pl \f g x y -> first f . join (***) g $ (x, y)
10:41:32 <lambdabot> flip flip (,) . (((.) . (.)) .) . (. join (***)) . (.) . first
10:41:57 <byorgey> dcoutts_: do you use slides?  if so, you should insert slides that say "Haskell is awesome" with pictures of robot ninjas, which only appear for 2 ms
10:42:02 <mrd> if you get the signal and stop the computer, then you create a paradox:)
10:42:14 <lispy> ski: looking now
10:42:17 <dcoutts_> byorgey: they already know haskell is awesome
10:42:25 <byorgey> oh!  well in that case =)
10:42:38 <lispy> ski: sneaky you, this isn't haskell!
10:42:40 <dcoutts_> byorgey: we teach that first, then we inflict UML on them and they start to appreciate Haskell
10:42:47 <byorgey> hehe
10:42:51 <byorgey> sneaky
10:42:55 <dcoutts_> @arr!
10:42:55 <lambdabot> Ahoy mateys
10:43:35 <dcoutts_> dons: who's organising that fedora packaging thing, bos? I've got some suggestions
10:44:07 <Baughn> gwern: http://www.frc.ri.cmu.edu/~hpm/project.archive/general.articles/1991/TempComp.html <-- Here, have details. Very fun article there..
10:44:10 <lambdabot> Title: TempComp.ht, http://tinyurl.com/2jhdv5
10:44:27 <lispy> I see streamproc, but there doesn't appear to be any documentation :(
10:45:15 <dons> dcoutts_: i'm trying to determine this.
10:45:30 <dons> though i suspect the window for getting xmonad into the new fedora is closed (?)
10:45:49 <quicksilver> byorgey: there's no such thing as a picture of a robot ninja. Ninjas move so fast that no one has ever taken a picture of them...
10:45:53 <dcoutts_> dons: much of the stuff on that page we want to automate using cabal and cabal-rpm
10:46:13 <dcoutts_> dons: and do the QA centrally, like getting the descriptions up to scratch etc
10:46:25 <byorgey> quicksilver: good point.  I guess I meant a *drawing* of a robot ninja.  You know, one of those "artist's conceptions"
10:46:32 <dons> dcoutts_: yep. sure.
10:46:35 <gwern> Baughn: I've read that. it's great, but it can be awfully difficult to understand
10:46:55 <dons> its really important to have the haskell apps on people's machines now though, or we wait another year for the next stable fedora
10:47:01 <Baughn> gwern: It makes more sense if you treat it as a prolog program. ;)
10:47:05 <dons> this kills adoption -- a *lot* of people use stable releases
10:47:12 <quicksilver> @tell cosmicray I have another comment on your ConfigFile API, if you're intrested.
10:47:13 <lambdabot> Consider it noted.
10:47:22 <lispy> Oh, the Stream library looks promising
10:47:35 <lispy> gives you the standard list api over a "stream" abstraction
10:47:42 <dcoutts_> dons: yes, we want both, releases now and low ongoing maintenance
10:48:07 <dons> yep
10:48:16 <dons> we're getting there.
10:48:26 <dons> i'd like to see more of the *apps* on hackage end up in distros
10:49:02 <lispy> and block-oriented I/O looks promising too
10:53:38 <ski> gwern,Baughn : <http://www.sfu.ca/philosophy/swartz/time_travel1.htm> might be interesting, too
10:54:31 <Socrates`> jorick: You should look at some of Henrik Nilsson's papers
10:54:42 <Socrates`> He wrote a modular synthesizer in Yampa
10:54:49 <dons> dcoutts_: did you know ocaml has a dedicated debian packaging list, http://news.gmane.org/gmane.linux.debian.devel.ocaml/cutoff=12575
10:54:51 <lambdabot> Title: Gmane Loom
10:54:52 <dons> that's ridiculously active
10:55:07 <bos31337> dons: the debian haskell list is pretty busy, too
10:55:09 <Socrates`> Tho', I believe it was rather proof of concept
10:55:16 <dons> bos31337: ah, good.
10:55:21 <dons> yes, i've had a few emails from there.
10:55:31 <dcoutts_> bos31337: hia, I've a bunch of comments about that page but I cannot edit as I'm not a fedora bod
10:55:41 <bos> dcoutts_: send 'em to me
10:55:46 <dons> bos: what's the situation with fedora/xmonad packages, (or do you know who I should ask?)
10:55:49 <dcoutts_> bos: ok
10:55:55 <dons> has the fedora release freeze begun?
10:56:00 <bos> i'd be a reasonable contact point for that.
10:56:05 <bos> yes, fedora 9 is frozen.
10:56:11 <dons> doh.
10:56:12 <dons> oh well
10:56:36 <bos> i have this small matter of a book to finish off, otherwise i'd be a bit more active about packaging stuff.
10:56:51 <lispy> small matter, eh? ;)
10:56:56 <glguy> dons: That's no reason not to provide an RPM on the xmonad.org downloads page
10:56:57 <Socrates`> @seen jorick
10:56:57 <dons> yeah :) that why i wondered if someone else does this stuff
10:56:58 <lambdabot> jorick is in #haskell. I last heard jorick speak 2h 6m 27s ago.
10:57:19 <dons> glguy: right, we do (or at least, there's a link to loupgaroublond's page)
10:57:29 <bos> dons: it's just jens petersen and me, but he's not terribly responsive.
10:57:53 <dons> ok, good to know. dcoutts_ -- we need a wiki page of distros and contact points
10:58:00 <dons> with the state of packaging on those distros
10:58:13 <dons> marking off those that have reached 'minimum haskell platform support'
10:58:17 <Socrates`> Hmm, can I get lambdabot to relay a message for me?
10:58:20 <dcoutts_> dons: yes, we should do
10:58:24 <glguy> @help tell
10:58:24 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
10:58:26 <EvilTerran> ?help ask
10:58:27 <lambdabot> ask <nick> <message>. When <nick> shows activity, ask them <message>.
10:58:28 <dons> oh, a statement about what minimum haskell platform support is too
10:58:28 <Socrates`> Cheers
10:58:35 <dcoutts_> dons: heh, yes
10:58:39 * EvilTerran pokes sioraiocht
10:58:44 <sioraiocht> =p
10:58:50 <dons> clearly, X11 + ghc68 + xmonad :)
10:58:51 <dcoutts_> dons: for the moment that's not so hard, it's ghc+ core tools + extralibs
10:58:57 <Socrates`> @tell jorick http://events.cs.bham.ac.uk/mgs2008/switched-on-yampa.pdf May interest you
10:58:57 <lambdabot> Consider it noted.
10:59:03 <dons> dcoutts_: right.
10:59:22 <dons> then phase 2: haddock, happy, alex, binary, haxml, etc ...
10:59:35 <dcoutts_> dons: I count haddock, happy, alex as core tools
10:59:48 <dcoutts_> dons: since you need them to build many other core packages
10:59:49 <dons> i think if we just have a page suggesting what you're "supposed" to support, that should help maintainers a lot
11:00:00 <dcoutts_> dons: yes, we could easily make that right now
11:00:59 <dcoutts_> dons: how about http://haskell.org/haskellwiki/Packaging
11:01:22 <tic> kolmodin, moo
11:01:53 <bos> augh, the thing i hate to see from a haskell app: "Prelude.head: empty list"
11:02:06 <bos> i wish we could print backtraces in cases like this.
11:02:24 <dcoutts_> bos: in ghci you can
11:02:44 <bos> dcoutts_: yeah, but.
11:02:58 <nburlett> hello all
11:03:02 <nburlett> long time no chat
11:03:44 <nburlett> anyone care to recommend web-programming haskell resources?
11:04:07 <saml> @wheare web
11:04:07 <lambdabot> I know nothing about web.
11:04:30 <nburlett> something with documentation would be cool :->
11:04:35 <dons> nburlett: familiarise yourself with the cgi/fastcgi lib, string-template, utf8-string, the xhtml lib
11:04:38 <saml> Network.CGI?
11:04:55 <dons> if you know cgi/fastcgi, its pretty easy from there.
11:05:35 <nburlett> dons: you think the roll-your-own approach is better than using a pre-made framework?
11:05:45 <dons> well, there's frameworks too :)
11:05:53 <bos> nburlett: the only pre-made one is HappS, and it's not exactly taking over the world.
11:06:05 <nburlett> HAppS looks awesome, but I can never get it to function
11:06:11 <dons> happs, stringtemplate+fastcgi is also pretty much a framework
11:06:15 <nburlett> WASH looks useful, but the documentaiton sucks
11:06:37 <nburlett> although, HAppS has been worse for docs, as far as I can tell
11:06:53 <sauxdado> ehird will write the killer framework
11:07:03 <bos> oh?
11:07:06 <kolmodin> tic: yarr
11:07:42 <jmelesky> wasn't there another web framework released recently?
11:07:48 <jmelesky> am i imaging that?
11:07:56 <nburlett> galois open-sourced some stuff
11:08:00 <geezusfreeek> yeah i don't remember what it was called
11:08:01 <nburlett> didn't look like a "framework"
11:08:06 <nburlett> maybe Dons can shed some light
11:08:07 <geezusfreeek> it looked very simple
11:08:14 <vixey> jorick: come to the cafe or sicp?
11:08:18 <geezusfreeek> not the galois stuff
11:08:19 <dons> if a framework is just a collection of libraries for getting stuff done
11:08:44 <jmelesky> hvac
11:08:51 <nburlett> a framework is a collection of connected libraries that are designed to work together, along with documenation and examples
11:08:58 <tic> kolmodin, yarr indeed!
11:08:59 <sclv_> yep :-)
11:08:59 <nburlett> (At least, that's my definition)
11:09:03 <jmelesky> http://groups.google.com/group/fa.haskell/browse_thread/thread/85e3e52cd6e39735/c08976358c5d3de7#c08976358c5d3de7
11:09:03 <dons> sounds reasonable
11:09:05 <lambdabot> Title: ANN (2 Libs) -- hvac 0.1b, a lightweight web framework and HStringTemplate 0.3 - ..., http://tinyurl.com/585kkm
11:09:28 <jmelesky> glad i didn't make it up
11:09:29 * nburlett reads about hvac
11:09:36 <sclv_> although the documentation is still quite weak
11:09:59 <sclv_> dbpatterson moved his site to hvac though, which shows that its at least semi-usable for development.
11:10:24 <jmelesky> hsp had a recent release, too (for the first time in forever)
11:13:30 <nburlett> gah, darcs is still broken on my gentoo box
11:14:52 <sclv_> my work on hvac proper got sidetracked by an orm-like project (data access layer, whatever the heck you want to call it, embedded sql dsl maybe) but its in decent shape except for some atomicity issues i'm meaning to get to.
11:17:23 <bos> dcoutts_: got time for a cabal question?
11:17:41 <dcoutts_> bos: sure
11:17:59 <bos> ok. i'm looking at the buildDepends for binary.
11:18:37 <bos> and it looks like all of the dependencies are in there, regardless of whether they're flag-dependent.
11:18:38 <MyCatVerbs> Hrmnnnn... I need to recover a file I darcs remove'd a loooong time back from a darcs repo. What's the sanest way of doing that, please? Recording thousands of rollback patches is painful and tends to fail anyway.
11:18:46 <bos> so e.g. i see a dependency on base 2.0 and base 3.0
11:19:12 <dcoutts_> bos: what flag assignment would give us a dependency on both?
11:19:19 <bos> dcoutts_: none, afaict.
11:19:32 <bos> dcoutts_: so maybe i'm generating the package description the wrong way?
11:19:45 <dcoutts_> bos: you're not still flattening right?
11:19:46 <bos> dcoutts_: i'm using finalizePackageDescription
11:19:52 <dcoutts_> ok, that should work
11:20:11 <dcoutts_> bos: unless you were using Cabal HEAD from last week
11:20:18 <bos> dcoutts_: no, cabal 1.2 only.
11:20:39 <dcoutts_> bos: ok, so I'm not clear what you're asking
11:21:27 <bos> dcoutts_: this is in the context of cabal-rpm. i need to generate a set of dependencies for rpmbuild, which means that i need to figure out what the real dependencies are.
11:21:34 <dcoutts_> bos: are you saying finalizePackageDescription gives a package description with buildDepends that are impossible to satisfy?
11:21:46 <bos> i.e. i don't want both sides of the "if bytestring-in-base" dependency, just whichever one is relevant to me.
11:22:35 <dcoutts_> bos: right, and that's what finalizePackageDescription does, it picks a flag assignment according to your environment and gives a package description according to those flags
11:23:01 <bos> dcoutts_: no, it seems to be giving me something that's just wrong: i get the "base > 2.0 and <= 2.2" side, instead of the one i'd expect.
11:23:10 <maltem> MyCatVerbs, one single rollback patch should do?
11:23:10 <maltem> And should indeed work in a non-partial repository
11:23:19 <edwardk> Hrmm, anyone care to give an opinion of which of these two versions is clearer? http://comonad.com/haskell/ctl/src/Control/Comonad/Cofree.hs
11:23:49 <dcoutts_> bos: ok, so that is a bug
11:24:07 <dcoutts_> bos: it's fixed in Cabal-1.4
11:24:07 <bos> dcoutts_: yes, i'm just not sure whether the bug is mine or not.
11:24:27 <bos> dcoutts_: http://hpaste.org/7233 contains the package description that i print.
11:24:27 <MyCatVerbs> maltem: except that I get "skipping depended-upon patch".
11:24:45 <dcoutts_> bos: nominolo realised that multiple constraints on the same package were not checked for consistency so in different conditions we could place inconsistent constraints on the same package
11:25:17 <bos> dcoutts_: but why would this be affecting cabal-rpm, but not a regular cabal build?
11:25:39 * nominolo reads backlog
11:25:40 <dcoutts_> bos: I think that's a good example of the bug, now instead of just checking if each constraint is individually satisfiable we gather constraints per package name and make sure they're all simultaneously satisfiable
11:25:42 <maltem> MyCatVerbs, ah, so it's hard to isolate the patches to rollback, hm...
11:26:07 <dcoutts_> bos: because you're telling finalizePackageDescription that all packages are available by passing Nothing for the set of available packages
11:26:13 <bos> oh!
11:26:20 <edwardk> the main devil's advocate between them is i think the latter may wind up running a little faster if you don't revisit terms and doesn't support pattern matching, while the former doesn't require rank-2 types, but the former has a superfluous bottom floating around because of the pair
11:26:23 <bos> dcoutts_: do i have to tell it what packages i believe are installed?
11:26:30 <dcoutts_> bos: if you listed all the available packages in the environment then you'd get a different answer
11:26:35 <MyCatVerbs> maltem: no worries. I just drudged up the contents with darcs changes -i and copied and pasted.
11:26:40 <dcoutts_> bos: yes, that helps
11:26:42 <bos> dcoutts_: ah, so i must query ghc to find out what's present?
11:26:55 * bos goes to figure out how to do that
11:27:12 <dcoutts_> bos: that's what cabal does, but you might decide that you want to include all the packages that are part of your distro set
11:27:15 <MyCatVerbs> Still, it's kinda disappointing that there isn't any single command to get a view of the tree as how it was at the point a particular patch was introduced. :/
11:27:40 <dcoutts_> bos: for example cabal-install considers all packages on hackage to be available
11:27:48 <bos> dcoutts_: i see.
11:27:59 <dcoutts_> bos: where as Setup.hs configure just considers those installed to be available
11:28:02 <MyCatVerbs> I guess that's probably somewhat nontrivial, given that the patches form a DAG rather than being strictly chronologically ordered, but still. It's one of those features you'd kinda hope to have in a *version control* system, after all.
11:28:18 <maltem> MyCatVerbs, yeah, I'd somehow favour a merge history in darcs, but that's not what the developers think would be useful
11:28:21 <mux> I hear cabal-install is working fine nowadays? with the base ghc 6.8.2 packages?
11:28:28 <bos> dcoutts_: i see.
11:28:38 <dcoutts_> bos: so really you want to list all the other haskell rpm packages since those are things that they could actually depend on
11:28:47 <dcoutts_> mux: yep
11:28:52 <dcoutts_> mux: I use nothing else
11:29:08 <dcoutts_> mux: ie I never runghc Setup.hs anymore
11:29:12 <MyCatVerbs> maltem: what *do* the developers think would be useful?
11:29:38 <MyCatVerbs> maltem: at the moment it seems like the answer must be "nothing", because that's roughly all the support that seems to be available for schlepping back in time.
11:30:27 <mux> dcoutts_: well I guess it's time for me to switch as well :)
11:30:31 <dcoutts_> @arr!
11:30:32 <lambdabot> Smartly me lass
11:30:36 <maltem> MyCatVerbs, about right. the only exact points in time you may check out are those states that have been tagged
11:31:56 <bos> dcoutts_: yeah
11:33:39 <dcoutts_> bos: do source rpms have a way to represent optional features that change dependencies?
11:34:20 <dcoutts_> bos: many cabal configurations should really be translated as such (though not the ones that are just conditional on package versions like the base split ones)
11:34:39 <bos> dcoutts_: no, rpms have fixed dependencies.
11:34:48 <dcoutts_> bos: binary ones sure, but source ones?
11:34:55 <bos> dcoutts_: yes, source ones too.
11:35:05 <dcoutts_> bos: ok, so you have to pick a flag assignment up front
11:35:09 <bos> right.
11:35:29 <dcoutts_> for ebuilds we can generate conditional dependencies controlled by 'USE' flags
11:36:01 <MyCatVerbs> maltem: ahhh, tags, of course.
11:36:08 <dcoutts_> bos: we ought to be able to share more code between these distro tools, like cabal-rpm, hackport and the debian thing too
11:36:18 <bos> dcoutts_: yes, probably.
11:36:21 <MyCatVerbs> maltem: the easy solution is obviously to adapt my habits to the tool, and set many many tags all the time. ;)
11:37:37 <dcoutts_> bos: I'd like to get more involved with this issue in future, doing more distro stuff centrally and automating as much as possible of generating distro packages
11:37:53 <bos> dcoutts_: yes, i'd like that, too.
11:38:17 <dcoutts_> bos: it's best use of resources to do QA centrally for example
11:38:20 <bos> dcoutts_: when i have cycles, i intend to set up an automatically maintained fedora package repository containing whatever is in hackage.
11:38:31 <maltem> MyCatVerbs, a la `darcs tag "Sorry, just felt like tagging today"`
11:38:44 <Twey> Hahaha
11:38:49 <dcoutts_> bos: it's easier said than done, I'm not sure there is a consistent way of installing everything that's in hackage
11:39:01 <dcoutts_> bos: I'm trying to do the same thing atm, from a cabal-install pov
11:39:23 <bos> dcoutts_: i'm sure you're right.
11:39:50 <MyCatVerbs> maltem: heh.
11:39:52 <dcoutts_> bos: it amounts to the problem of constructing an InstallPlan including every package (and InstallPlan is an abstraction in cabal-install that defines a bunch of strict validity conditions)
11:40:07 <dcoutts_> and/an
11:40:57 <dcoutts_> bos: but if we can construct one, it's the perfect thing for cabal-rpm since an install plan tells you exactly what package versions you need and exactly what flag assignment and dependencies to use
11:41:35 <byorgey> sjanssen, Heffalump: there is now a darcs repo for oeis, darcs get http://code.haskell.org/oeis/
11:41:36 <lambdabot> Title: Index of /oeis
11:42:14 <sjanssen> byorgey: great
11:42:21 * sjanssen tries to remember what he wanted to add
11:42:45 <byorgey> sjanssen: hehe, yeah, it took a while for someone to get around to giving me the directory... and then they didn't tell me about it =P
11:43:08 <byorgey> I just randomly went on c.h.o today and noticed that the 'oeis' directory was created 5 days ago
11:43:27 <byorgey> unless the notification went in my spam folder or something, I don't know
11:46:09 <byorgey> @seen Heffalump
11:46:09 <lambdabot> Heffalump is in #haskell-hac4, #haskell-soc, #darcs and #haskell. I don't know when Heffalump last spoke.
11:46:24 <byorgey> @tell Heffalump there is now a darcs repo for oeis, darcs get http://code.haskell.org/oeis/
11:46:24 <lambdabot> Consider it noted.
11:57:51 <dcoutts_> dons, bos: I'd appreciate a quick review of http://haskell.org/haskellwiki/Packaging
11:57:59 <byorgey> > let phi = (1 + sqrt 5)/2 in phi^38
11:58:00 <lambdabot>  8.740380299999999e7
11:58:17 <bos> dcoutts_: ok, will take a look
11:58:26 <luqui> I found a wonderfully tautological-looking definition for ($):     ($) ($) x = (x $)
11:58:46 <edwardk> did a canonical 'Bottom' type with no constructors ever get added to the prelude?
11:58:52 <edwardk> or rather to any of the major libraries
11:59:18 * luqui doesn't think so
11:59:41 <edwardk> k just checking
11:59:43 <byorgey> edwardk: I've usually seen it called 'Void', it's in Djinn but don't think it's standard
11:59:54 <edwardk> i added it to djinn a while back to test stuff
12:00:11 <byorgey> oh =)
12:00:39 * luqui likes the name Absurd...
12:00:41 <edwardk> basically just trying to make sure that i can give a canonical 'identity' for (,) as a bifunctor
12:01:30 <edwardk> something nice about a source file named Data.Void with a single declaration 'data Void' ;)
12:01:44 <Deewiant> is that standard H98 though?
12:01:45 <byorgey> edwardk: yes, very Zen =)
12:01:55 <edwardk> Deewiant: fraid not, needs an extension
12:01:58 <Deewiant> I seem to recall that constructorless data types need extensions...
12:02:01 <Deewiant> ya, thought so
12:02:16 <luqui> interesting use of the word "extension"...
12:02:23 <byorgey> EmptyDataDecls
12:06:56 <lispy> If it's already in a module by itself you don't need that extension
12:07:11 <edwardk> just that module does, no?
12:07:31 <lispy> I was tihnking you just don't export any constructors
12:07:33 <edwardk> and you can 'fake' it by just not exporting its constructor for H98
12:07:35 <edwardk> yeah
12:08:49 <edwardk> aww. the documentation for Data.Void picked up its instance declarations, so its not empty ;)
12:10:48 <byorgey> aww, too bad
12:10:57 <bos> > listToMaybe [1,2]
12:10:58 <lambdabot>  Just 1
12:11:30 <RayNbow> hmm, is this really called parabolic growth in English? http://img95.imageshack.us/img95/8468/selflimit4gb.gif
12:11:57 <edwardk> ray: no, we usually talk about the carrying capacity of the population
12:12:05 <ray> not ray
12:12:15 <edwardk> hah, too many people on here ;)
12:12:16 <ski_> edwardk : also `void :: Void -> a'
12:12:18 <RayNbow> :p
12:12:24 <edwardk> ski: true
12:13:03 <Heffalump> byorgey: ta
12:13:03 <edwardk> ski: now the dilemma: should that be strict in its undefinedness? =)
12:13:04 <lambdabot> Heffalump: You have 1 new message. '/msg lambdabot @messages' to read it.
12:13:12 <edwardk> ski: void _ = undefined or void = undefined ? =)
12:13:27 <edwardk> heh even 'void' has two implementations
12:13:48 <byorgey> what is 'ta' an abbreviation for?
12:13:54 <ski_> void v = case v of {}  -- requires another, unimplemented and unspecified, extension
12:13:54 <maltem> edwardk, or void x = x
12:14:07 <maltem> oh wait
12:14:07 <lispy> edwardk: but, I thouht definitions were eta eqeuivalent in haskell?  What gives?
12:14:07 <mauke> ThAnk you
12:14:11 <byorgey> from context I assume it means 'thanks' but that makes no sense.
12:14:20 <byorgey> why not 'th' or 'ty'?
12:14:21 <maltem> I'm an untyped fool, as SHE would say.
12:14:22 <edwardk> maltem: that would require the (forall a. a) definition of Void.
12:14:29 <maltem> right
12:14:29 <edwardk> but that precludes me using it in a typedef =)
12:14:33 <edwardk> er class
12:15:30 <edwardk> lispy: http://sigfpe.blogspot.com/2008/02/how-many-functions-are-there-from-to.html
12:15:32 <lambdabot> Title: A Neighborhood of Infinity: How many functions are there from () to ()? (Updated ..., http://tinyurl.com/2s68d2
12:15:50 <edwardk> seq screws that up basically
12:16:08 <ski_> hm, <http://web.cecs.pdx.edu/~mpj/pubs/RR-1004.gs> looks interesting
12:16:25 <ski_> class Composer c where
12:16:26 <ski_>     open  :: c f g x -> f (g x)
12:16:26 <edwardk> void `seq` ()      can inspect and tell them apart sorta =)
12:16:27 <ski_>     close :: f (g x) -> c f g x
12:17:19 <edwardk> ski: hrmm
12:18:07 <edwardk> yeah i've been using Pointed for its 'Premonad'
12:20:22 <edwardk> hrmm i suppose i'll steal the composer stuff and extend it to handle the pointed/copointed stuff  i have
12:23:17 <bos> dcoutts_: ok, i've got the dependency calculation for cabal-rpm on firmer ground. it's still not nearly as sophisticated as it could be (it would be great to be able to use some of cabal-install's logic), but at least it actually works with configurations again.
12:23:23 <bos> er, s/again/at all/
12:24:14 <ski_> edwardk :)
12:24:32 <dcoutts_> bos: yes, much of cabal-install should be a library
12:24:42 <edwardk> ski: this way we get a similar construction for copointed endofunctors and comonads
12:24:53 <dcoutts_> bos: and I think you should probably be using the Cabal-1.4 api for cabal-rpm
12:25:29 <ski_> edwardk : hm, any example of the former which isn't an example of the latter ?
12:25:33 <dcoutts_> bos: at least once that stops being a moving target
12:25:36 <bos> dcoutts_: maybe, but i've had trouble tracking changes in the cabal API in the past, and the 1.2 API is good enough.
12:25:50 <edwardk> ski: copointed?
12:25:53 <bos> i don't need perfect, just workable :-)
12:26:05 <ski_> yes
12:26:14 <LordBrain> If i distribute a binary compiled with GHC, are there any legal requirements due to GHC's license? Do i have to reproduce the copyright notice that ghc has because say the rts is technically a partial redistribution?
12:27:00 <LordBrain> i am aware of the libgmp issue... i'm talking specially about requirements of the ghc license tho
12:27:11 <dcoutts_> bos: make sure you specify the right Cabal dependency btw, build-depends: Cabal >= 1.2.3 && < 1.3
12:27:20 <edwardk> ski: hrmm, well, just need to find something that permits extraction but not duplication or extension. lets see
12:27:55 <edwardk> well, i can come up with an ExpFunctor that is Copointed, but that doesn't help =)
12:28:20 <bos> dcoutts_: there's no way to specify that in the "cabal-version" field, i notice
12:28:35 <dcoutts_> bos: hmm?
12:28:41 <edwardk> just compose two comonads that lack a distributive law between them
12:28:58 <dcoutts_> bos: you can use the same predicates in cabal-version afaik
12:29:03 <bos> dcoutts_: there are two fields for Cabal-related info
12:29:39 <bos> dcoutts_: no, it's more weirdly restricted
12:29:41 <svat> byorgey: I think "ta" is a word and pronounced as such, not an abbreviation.
12:29:54 <bos> dcoutts_: e.g. build-depends accepts 1.2.3.0, but cabal-version does not
12:29:58 <byorgey> svat: really?
12:30:31 <svat> byorgey: see http://forum.wordreference.com/showthread.php?t=44476 : I have never heard it myself, but it's apparently common in parts of England :)
12:30:32 <lambdabot> Title: do people actually say "ta"? - WordReference Forums
12:30:50 <dcoutts_> bos: build-depends accepts "foobar == 1.2.3.0", cabal-version accepts "== 1.2.3.0"
12:31:06 <mauke> read more Hellblazer :-)
12:31:14 <bos> dcoutts_: it might syntactically accept it, but it doesn't work
12:31:21 <dcoutts_> bos: in what sense?
12:31:44 <bos> dcoutts_: with "Cabal-version: >= 1.2.3.0" i get "setup: Error: This package requires Cabal version: >=1.2.3.0."
12:31:58 <bos> dcoutts_: but that doesn't happen with "Cabal-version: >= 1.2"
12:32:19 <dcoutts_> bos: and what version of cabal are you using?
12:32:34 <edwardk> gah. i really wish there was a clean way to take the derivative of a functor in haskell
12:32:37 <bos> dcoutts_: Cabal-1.2.3.0
12:33:28 * dcoutts_ tries to reproduce
12:33:31 <dcoutts_> erm
12:33:35 * dcoutts_ tries to reproduce that error
12:33:36 <dcoutts_> :-)
12:33:38 <byorgey> svat: ta =)
12:35:21 <LordBrain> Anyone here ever distributed or worked for a company which distributes programs in binary form which were compiled with ghc?
12:35:44 <dcoutts_> bos: it works for me, "Cabal-Version: >= 1.2.3.0" using a Setup.hs built with -package Cabal-1.2.3.0
12:35:58 <dcoutts_> bos: and "Cabal-Version: >= 1.2.3.1" gives the appropriate error message
12:36:08 <bos> dcoutts_: how odd.
12:36:13 <dcoutts_> bos: I wonder if you've just got a Setup built using an older Cabal
12:36:13 * bos must go for a bit
12:40:59 <LordBrain> hmmm
12:41:01 <LordBrain> nobody knows huh
12:57:21 <jaj> Hi! Wouldn't it be a good idea to make SqlValue an instance of the Stringable class from HStringTemplate so that you can immediately pass data from the database to a template?
13:00:54 <sclv_> jaj: the instance for that is defined in hvac code.
13:01:10 <sclv_> i didn't want it in the main hstringtemplate code, as it would introduce a dependency on hdbc.
13:01:50 <sclv_> i was considering splitting it into an optional module for hstringtemplate but that didn't necessarily seem correct.
13:02:28 <sclv_> in any case, if you want it, you can just browse the hvac source tree and grab the code for yourself.
13:02:47 <jaj> sclv_: ok thanks, I was just implementing it myself
13:03:20 <jaj> sclv_: where can I find the hvac code?
13:04:04 <sclv_> http://code.haskell.org/~sclv/hvac/Network/Frameworks/HVAC/Database.hs
13:04:04 <lambdabot> http://tinyurl.com/5566qx
13:04:27 <jaj> sclv_: thanks a lot!
13:04:56 <Valodim_> http://hpaste.org/7236
13:04:56 <sclv_> I should really get some well organized and documented pages together for all this.
13:05:02 <Valodim_> ...anyone? kinda stuck there.
13:05:39 <sclv_> jaj: btw, the code makes it an instance of ToSElem, rather than Stringable, which is the appropriate way to do it.
13:06:10 <sclv_> Stringable is for internal formats, ToSElem for data to be converted.
13:06:10 <byorgey> @type hSeek
13:06:12 <lambdabot> Not in scope: `hSeek'
13:06:22 <byorgey> Valodim_: what is the type of hSeek?
13:06:24 <Valodim_> it's IO so lambdabot doesn't know it :)
13:06:31 <Valodim_> hSeek :: Handle -> SeekMode -> Integer -> IO ()
13:06:35 <Valodim_> it's IO ()
13:06:36 <byorgey> lambdabot knows some IO things
13:06:39 <byorgey> @type putStrLn
13:06:41 <lambdabot> String -> IO ()
13:06:55 <Valodim_> ah
13:07:09 <byorgey> @hoogle hSeek
13:07:09 <lambdabot> System.IO.hSeek :: Handle -> SeekMode -> Integer -> IO ()
13:07:10 <jaj> sclv_: ok thanks! I'm still a beginner in haskell and it took me some time to figure out how to use HStringTemplate correctly
13:07:48 <byorgey> Valodim_: oh, it must have decided that your do block is in the list monad.
13:07:54 <jaj> especially the fact that where the java version uses objects, the haskell version uses Data.Map
13:08:05 <Valodim_> ...what?
13:08:15 <byorgey> Valodim_: what type is (h # get_sff_subheader)?
13:08:21 <Valodim_> HAH
13:08:21 <byorgey> I don't even know what that means
13:08:41 <Valodim_>         read_sprite :: Handle -> Int -> Maybe ACTPalette -> [SFFSprite]
13:08:41 <Valodim_> I didn't include the IO () return type in the type of the function :)
13:08:55 <byorgey> hehe
13:08:56 <Valodim_> that should do it. thanks guys
13:08:59 <sclv_> jaj: well, the haskell version can use records too, if you decide to work with Generics... but that's a bit fancier.
13:09:00 <byorgey> np =)
13:11:05 <opqdonut> what phases does ghc have?
13:11:10 <opqdonut> how are they ordered?
13:11:56 <opqdonut> does type checking become before or after converting into the internal language
13:12:40 <mauke> I think ghc typechecks sugar for better error messages
13:12:41 <augustss> before is better
13:13:17 <augustss> opqdonut: ghc has many, many passes
13:14:12 <opqdonut> but the order is something like typecheck-desugar into ir-optimize?
13:14:39 <augustss> yeah
13:14:41 <jaj> sclv_: first I will have to understand what Generics actually are ;)
13:15:16 <augustss> but before tc you have, lex, parse, module&name resolution
13:21:40 <sclv_> eventually ghc core is untyped, no?
13:22:00 <duschendestroyer> is there a better way to fold an array than calling toList .. casting big arrays to lists can get expensive I'm afraid
13:22:11 <EvilTerran> sclv_, i believe so, yes, as by that point newtypes have gone
13:23:47 <lispy> duschendestroyer: hmm...I don't know all the details, but I wolud have guessed that toList followed by a fold would actually compile down to iteration
13:24:50 <augustss> sclv: the representation called core is never untyped
13:24:54 <sclv_> ?instances Foldable
13:24:54 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
13:25:02 <augustss> newtypes are represented via coercions
13:25:40 <augustss> sclv: The stg representation is less strongly typed, more like C
13:27:39 <duschendestroyer> yeah .. array is Foldable .. did not see it in haddock .. should have tried it :/
13:27:39 <dons> duschendestroyer: you could use ST arrays and write a manual fold
13:27:47 <dons> duschendestroyer: we've new array libraries on the way though
13:30:48 <sclv_> zounds: of course core is typed. i has the dumb today. i forget what representation is untyped that i was thinking of...
13:32:26 <dons> typed compilation by transformation, ftw!
13:32:27 <sclv_> maybe something somebody was telling me about ocaml the other day.
13:33:07 <sclv_> they were explaining that you can't do the equiv of Haskell's Typeable because there's no dictionary-passing at runtime and all types are fully statically known, I think.
13:33:37 <eu-prleu-peupe1> hello
13:33:43 <eu-prleu-peupe1> haskell people from space
13:34:43 <shachaf> eu-prleu-peupe1: Hello.
13:40:54 <geezusfreeek> eu-prleu-peupe1: hello again
13:41:24 <eu-prleu-peupe1> hey jesus
13:41:27 <eu-prleu-peupe1> respect
13:41:41 <eu-prleu-peupe1> im thinking on changing my code base from C to haskell
13:43:43 <user317> i cant figure out why hmatrix wont build documents http://hpaste.org/7238  any ideas?
13:49:44 <sclv_> user317: looks like you're running the wrong haddock?
13:50:06 <user317> i have 0.9 installed, do i need some other version?
13:50:20 <sclv_> there's a 2.0 as I recall.
13:51:12 <sclv_> on the other hand, you could just use the online docs: http://perception.inf.um.es/%7Earuiz/darcs/hmatrix/doc/html/index.html
13:51:16 <lambdabot> http://tinyurl.com/5uues5
13:52:38 <user317> thats kind of a pain
13:54:27 <monochrom> If it is a parse error, you may need haddock 2.
13:59:05 <user317> well, why would ghc be build with a different version of haddock then the one i have installed
14:02:52 <eu-prleu-peupe1> can haskell generate functions at run-time ?
14:03:09 <dons> yes
14:03:19 <byorgey> @faq  can haskell generate functions at run-time ?
14:03:19 <eu-prleu-peupe1> how ?
14:03:20 <lambdabot> The answer is: Yes! Haskell can do that.
14:03:26 <kolmodin> ?tell malcolmw you might be interested in http://www.haskell.org/~gentoo/gentoo-haskell/dev-haskell/haxml/files/haxml-1.19.2-intercalate.patch
14:03:26 <lambdabot> Consider it noted.
14:04:06 <byorgey> > let newfunc x = x + someInputWeGotFromSomewhere  in otherFunc newfunc   -- and so on
14:04:07 <lambdabot>   Not in scope: `otherFunc'
14:04:15 <byorgey> oh, didn't mean to put a > in front of that
14:04:36 <byorgey> eu-prleu-peupe1: no special tricks, you just... define a function =)
14:04:46 <byorgey> you can also use lambda notation
14:04:49 <EvilTerran> eu-prleu-peupe1, that sort of thing's fairly fundamental to the idea of functional programming languages - in order for functions to be first-class, you have to be able to mess about with them at runtime
14:04:54 <byorgey> like \x -> x + y
14:04:57 <dons> possibly you want an `eval` though, i suspect.
14:05:00 <sauxdado> eu-prleu-peupe1: interesting nickname.
14:05:01 <eu-prleu-peupe1> but how is that run-time ?
14:05:09 <dons> you want to generate a function from runtime data?
14:05:17 <eu-prleu-peupe1> for me a compiler can easily generate all that at compile time
14:05:30 <byorgey> eu-prleu-peupe1: it can use input data acquired at runtime.
14:05:43 <dons> you'll need to give an example of what you want done at runtime
14:05:48 <mauke> that's like saying x + y is computed at compile time because the compiler already knows it uses an ADD instruction
14:06:01 <EvilTerran> in map (\x y -> ...) [...], a load of functions expecting a second parameter are made at runtime
14:06:16 <agcorona> hi i have this error  compiling HSX: " Could not find module `HSX.Transform'"
14:06:46 <EvilTerran> well, insofar as we distinguish between runtime and compiletime, anyway
14:06:48 <agcorona> the last version of Hackage
14:07:11 <eu-prleu-peupe1> hmm
14:07:26 <eu-prleu-peupe1> i can do all that in C, and in C functions are not first class citizens
14:07:39 <geezusfreeek> eu-prleu-peupe1: currying is a simple example of how this works at runtime
14:07:45 <eu-prleu-peupe1> specially with gcc nested functions
14:07:52 <geezusfreeek> eu-prleu-peupe1: say you have a function f :: a -> b -> c
14:08:11 <EvilTerran> ok then. let's see your C for "map (\x y -> x + x * y)"
14:08:17 <geezusfreeek> when you do (f x), you get back a function that takes another parameter
14:08:30 <geezusfreeek> that function was created at runtime
14:08:35 <mauke> eu-prleu-peupe1: you can't return nested functions in C
14:08:44 <eu-prleu-peupe1> gcc can
14:08:49 <mauke> no, it can't
14:08:56 <EvilTerran> we can simplify its type to ([Int] -> [Int -> Int]) if you like.
14:08:58 <geezusfreeek> eu-prleu-peupe1: no, it most definitely cannot
14:09:08 <eu-prleu-peupe1> all you need is an executable stack, and gcc will do the trampolin for you
14:09:17 <mauke> no
14:10:16 <EvilTerran> if you're thinking of "int foo (int x) { int bar (int y) { return x + x * y; }; return bar; }", i guarantee you that will not work in C
14:10:34 <mauke> EvilTerran: yeah, the return type is wrong :-)
14:10:58 <eu-prleu-peupe1> :D
14:11:27 <eu-prleu-peupe1> you can't return an int, if the function is to return a function pointer :P
14:11:30 <EvilTerran> ok, "int (*) (int)" ...
14:11:38 <mauke> int (*foo(int x))(int) { ...
14:11:41 <EvilTerran> it still won't work
14:11:50 <eu-prleu-peupe1> like mauke wrote it will work
14:11:55 <eu-prleu-peupe1> it works for me at least :)
14:11:58 <mauke> eu-prleu-peupe1: no, it won't
14:12:01 <geezusfreeek> eu-prleu-peupe1: it won't
14:12:07 <EvilTerran> have you actually tried it? that very bit of code?
14:12:08 <geezusfreeek> eu-prleu-peupe1: c lacks lexical closures
14:12:15 <EvilTerran> calling it repeatedly with different values of x?
14:12:28 <eu-prleu-peupe1> i didnt try that EvilTerran
14:12:38 <mauke> eu-prleu-peupe1: did you RTFM?
14:12:41 <eu-prleu-peupe1> geezusfreeek: arent nested functions a way of closure ?
14:12:50 <EvilTerran> it may be working by sheer luck that the appropriate bits of the stack haven't been clobbered yet
14:13:02 <ziman> in C, you can't have a function that works as a `function factory' -- let's say i wanted a function that takes an integer (say, X) and returns a function that takes an integer (Y) and returns X+Y
14:13:06 <geezusfreeek> eu-prleu-peupe1: what happens if you use that function elsewhere in the program after x has been popped from the stack?
14:13:27 <EvilTerran> but x is allocated on the stack in that code, so it's no longer allocated after the function returns
14:13:37 <geezusfreeek> eu-prleu-peupe1: a nested function in the c sense is not a true closure
14:13:41 <jaj> you can also have a function in a struct in C. you put a void pointer in the struct and attribute it the address of the function
14:13:55 <mauke> http://gcc.gnu.org/onlinedocs/gcc-4.3.0/gcc/Nested-Functions.html - If you try to call the nested function through its address after the containing function has exited, all hell will break loose. If you try to call it after a containing scope level has exited, and if it refers to some of the variables that are no longer in scope, you may be lucky, but it's not wise to take the risk.
14:13:56 <lambdabot> Title: Nested Functions - Using the GNU Compiler Collection (GCC)
14:14:01 <geezusfreeek> jaj: sure, but that isn't creating functions at runtime
14:14:09 <eu-prleu-peupe1> thats what i do jaj, i use struts to encapsulate return types
14:14:15 <mauke> jaj: fail. void * can't point to functions in standard C
14:14:29 <user317> you can compile it, and dlopen the object :)
14:14:35 <EvilTerran> mauke, jaj: but you can use a funptr type or a typedef thereof
14:14:44 <jaj> mauke: ok I'm talking about gcc here, I never read ANSI C specs
14:15:07 <mauke> I bet even gcc would fail if the underlying machine uses 64-bit code pointers and 32-bit data pointers
14:15:16 <geezusfreeek> eu-prleu-peupe1: if you don't believe us i strongly encourage you to prove us wrong with working code
14:15:27 * EvilTerran wanders off
14:15:56 <mauke> also, you need to use more warnings: warning: ISO C forbids initialization between function pointer and ‘void *’
14:16:03 <eu-prleu-peupe1> mauke: i did try it on a amd
14:16:04 <user317> oh, yea if anyone cares, you need haddock-2.0 to build hmatrix
14:16:15 <eu-prleu-peupe1> oh, i dont use void*
14:16:17 <eu-prleu-peupe1> void* is evil
14:16:47 <eu-prleu-peupe1> anyway, even without the gcc extension, i can also code the trampoline by hand
14:16:51 <eu-prleu-peupe1> and it will also work
14:16:58 <mauke> but you can't return it
14:17:02 <eu-prleu-peupe1> so i dont see the point
14:17:08 <geezusfreeek> eu-prleu-peupe1: yuck! and no, it's still not lexically scoped
14:17:10 <eu-prleu-peupe1> offcourse i can, thats the point of having a trampoline
14:17:11 <mauke> unless you manually create the closure in dynamically allocated memory
14:17:11 <eu-prleu-peupe1> :P
14:17:15 <mauke> eu-prleu-peupe1: wrong
14:17:32 <mauke> the point of having a trampoline is being able to pass the function pointer to stuff like qsort
14:17:42 <mauke> existing interfaces that need a normal-looking function pointer
14:17:55 <geezusfreeek> eu-prleu-peupe1: seriously, implement that function that was given earlier and test it
14:18:01 <mauke> that doesn't mean you can use it after its surrounding function has returned
14:18:03 <geezusfreeek> and i want to see a paste of your code
14:18:52 <sjanssen> eu-prleu-peupe1: try writing the composition operator in C
14:19:10 <eu-prleu-peupe1> yes i even did that...
14:19:32 <geezusfreeek> eu-prleu-peupe1: please show the code. clearly we are talking about different things
14:19:47 <eu-prleu-peupe1> no we are not
14:21:15 <mauke> eu-prleu-peupe1: try this one: http://rafb.net/p/YWsDhQ74.html
14:21:16 <lambdabot> Title: Nopaste - No description
14:21:27 <mauke> that is, think about what it should print, then run it
14:23:21 <geezusfreeek> "A language implementation cannot easily support full closures if its run-time memory model allocates all local variables on a linear stack. In such languages, a function's local variables are deallocated when the function returns. However, a closure requires that the free variables it references survive the enclosing function's execution. Therefore those variables must be allocated so that they persist until no longer needed.
14:23:27 <geezusfreeek> ^ http://en.wikipedia.org/wiki/Closure_(computer_science)
14:23:33 <mauke> for comparison: http://rafb.net/p/kk4De867.html
14:23:33 <lambdabot> Title: Nopaste - No description
14:25:22 <gvdm> lol, too late, i' moving out
14:27:58 <bos> @seen cosmicray
14:27:58 <lambdabot> Last time I saw cosmicray was when I left ##logic, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books, #haskell-hac07, #haskell-hac4,
14:27:58 <lambdabot>  #haskell-overflow, #haskell-soc, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #
14:27:58 <lambdabot> jtiger, #parrot, #perl6, #rosettacode, #scala, #scannedinavian, #thunks, #unicycling and #xmonad 5d 3h 10m 22s ago, and .
14:28:07 <bos> auieugh!
14:28:08 <mauke> oh god
14:28:11 <Bonus> lol
14:28:14 <Bonus> that is a lot of channels
14:28:15 <bos> overshare from lambdabot.
14:28:21 <Bonus> #unicycling
14:28:37 <mauke> preflex: seen cosmicray
14:28:37 -preflex(n=preflex@d83-191-170-55.cust.tele2.de)- cosmicray was last seen on #haskell 5 days and 27 seconds ago, saying: pejo: of course there is perl6 at some point too
14:28:48 <eu-prleu-peupe1> http://pastebin.com/m562cffde
14:28:56 <eu-prleu-peupe1> this outputs 2
14:28:56 <sauxdado> at least #horseporn is not among these channels
14:28:59 <eu-prleu-peupe1> compiles without warnings
14:29:00 <eu-prleu-peupe1> :)
14:29:07 <mauke> eu-prleu-peupe1: did you try my code?
14:29:18 <Bonus> oh man
14:29:18 <eu-prleu-peupe1> not yet
14:29:24 <Bonus> i forgot how much i dislike c
14:29:37 <geezusfreeek> okay, now how much work to make it work for floats? ;)
14:29:49 <monochrom> geezusfreeek beats me to it.
14:30:15 <eu-prleu-peupe1> the same work to make it work for any other type
14:30:22 <mauke> eu-prleu-peupe1: DO IT
14:30:30 <monochrom> There is also the question of what about functions with several parameters.
14:30:30 <geezusfreeek> eu-prleu-peupe1: then it's not comparable to haskell's composition operator
14:30:46 <geezusfreeek> and it certainly took a lot more work
14:30:53 <geezusfreeek> @src (.)
14:30:53 <lambdabot> (f . g) x = f (g x)
14:31:26 <Bonus> @src length
14:31:26 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:31:29 <Bonus> wtf
14:31:38 <geezusfreeek> @hoogle length
14:31:39 <lambdabot> Prelude.length :: [a] -> Int
14:31:39 <lambdabot> Data.List.length :: [a] -> Int
14:31:39 <lambdabot> Data.ByteString.length :: ByteString -> Int
14:31:47 <geezusfreeek> @src Data.List.length
14:31:48 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
14:31:54 <mauke> eu-prleu-peupe1: btw, your program throws 5 warnings here
14:32:11 <Bonus> oh man oh man oh man
14:32:20 <monochrom>  @src does not know all source code.
14:32:26 <geezusfreeek> :(
14:32:30 <Bonus> ;'(
14:32:50 <eu-prleu-peupe1> you are compiling with -pedantic and -ansi or whatever for sure
14:32:51 <monochrom> length is highly optimized code using internal types like Int#. It's in one of those GHC.* module.
14:32:52 <Bonus> i just wanted to see if it was gonna say something like foldl (\acc _ -> acc+1) 0
14:32:54 <jaj> eu-prleu-peupe1: is that ISO C?
14:32:59 <eu-prleu-peupe1> jaj: no
14:33:03 <eu-prleu-peupe1> its gcc C
14:33:06 <jaj> k
14:33:27 <monochrom>  @src is unlikely to know about GHC.*
14:33:36 <sjanssen> eu-prleu-peupe1: you do realize that implementation is broken, right?
14:33:44 <eu-prleu-peupe1> sjanssen: yes :)
14:34:01 <eu-prleu-peupe1> i was just trolling a bit
14:34:03 <sjanssen> eu-prleu-peupe1: it isn't really the composition operator then, is it?
14:34:06 <geezusfreeek> eu-prleu-peupe1: i really don't see what you are defending :P
14:34:13 <ziman> eu-prleu-peupe1, segfault here
14:34:29 <eu-prleu-peupe1> ziman: now i will have access to all your computer muahaha
14:34:48 * ziman has quit ["omg"]
14:34:59 <sjanssen> eu-prleu-peupe1: you asked about creating functions at runtime: the composition operator creates functions at runtime
14:35:34 <sjanssen> eu-prleu-peupe1: C can't really do this (of course it can be emulated, Turing tarpit and all that)
14:35:42 <monochrom> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-List.html  has the source code of length.
14:35:43 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/6nneom
14:36:31 <jaj> eu-prleu-peupe1: you could define it for void* so you wouldn't have type constraints on the arguments. then you could perhaps use va_list to get rid of the constraint on the number of arguments
14:36:58 <eu-prleu-peupe1> i avoid void*
14:37:01 <monochrom> It is close to foldl', but foldl' cannot be used because foldl' is polymorphic but Int# is an unboxed type. unboxed type cannot be passed to polymorphic functions.
14:37:21 <eu-prleu-peupe1> and va_args also, because of its strange casting rules
14:37:34 <mauke> there are no casting rules
14:37:41 <eu-prleu-peupe1> in va_args there are
14:37:44 <mauke> no
14:37:48 <eu-prleu-peupe1> hehehe
14:38:01 <eu-prleu-peupe1> have you RTFM ?
14:38:02 <eu-prleu-peupe1> ;)
14:38:05 <monochrom> You are invited to argue over this in #c.
14:38:05 <mauke> yes
14:38:16 <solrize>     len :: [a] -> Int# -> Int
14:38:27 <solrize> it's using int# just to run faster?
14:38:32 <sjanssen> solrize: yes
14:38:34 <monochrom> Very faster.
14:38:48 <geezusfreeek> monochrom: that'd be a fun experiment. see what everybody in #c has to say about all this! ;)
14:38:54 <monochrom> Int# is bare naked machine int.
14:38:58 <sjanssen> of course it might be possible for ghc -O to generate the unboxed version
14:38:59 <solrize> hmm, shame that the compiler doesn't specialize it itself
14:39:01 <saml> > len 2345
14:39:02 <lambdabot>   Not in scope: `len'
14:39:08 <solrize> sjanssen, oh ok, that's what i was wondering
14:39:17 <solrize> saml that was from that src file
14:39:18 <eu-prleu-peupe1> just try to pass it a float
14:39:23 <eu-prleu-peupe1> it will upcast it to a double
14:39:24 <eu-prleu-peupe1> ;)
14:39:35 <eu-prleu-peupe1> thats how va_args works
14:39:54 <mauke> eu-prleu-peupe1: want to join #free-c?
14:39:57 <mauke> this is off-topic here
14:40:02 <mauke> er, ##free-c
14:40:34 <eu-prleu-peupe1> ok, ill stop reasoning with you
14:40:43 <dons> ooh ooh, what foldy stuff are we specialising now?
14:40:51 <monochrom> length.
14:41:10 <monochrom> I think you have been there done that. :)
14:41:20 <geezusfreeek> eu-prleu-peupe1: if you're just a troll you're pretty good at it
14:41:32 <dons> lengthU . enumFromToU 1 $ (100000000 :: Int)
14:41:33 <dons> -->
14:41:45 <geezusfreeek> eu-prleu-peupe1: there was supposed to be a wink there ;)
14:41:52 <eu-prleu-peupe1> geezusfreeek: :) i am
14:42:21 <geezusfreeek> i think i have done enough troll feeding for toda
14:42:22 <geezusfreeek> y
14:42:31 <eu-prleu-peupe1> but i plan on using haskell sometime
14:42:32 <eu-prleu-peupe1> i think
14:42:51 <dons> wfold :: Int# -> Int# -> Int#
14:42:51 <dons> wfold x y = case ># y 100000000 of False -> wfold (x +# 1) (y +# 1) True -> x
14:42:55 <dons> yay streams
14:43:06 <monochrom> I think this is a good description of the dispute. "id works for every type. that's how id works. that's a rule about id."  "no, that's due to polymorphism, that's a rule about polymorphism, not about id"
14:45:44 <monochrom> That's indeed a nice tight loop.
14:46:32 <dons> the ndp-based vector streams get compiled insanely well
14:46:59 <dons> not a box or GC point in sight
14:48:55 <ziman> eu-prleu-peupe1, suppose we had a function in C that returns a function that appends a 1k-char string to its argument; however, all functions in your code are represented as pointers only, therefore the code: f = mkFunc("...1024..."); would effectively compress the 1k string into a word-sized pointer (decompression would be f("")) because you remember nothing else about the functions except the pointers. And that'd certainly be a revolutionary ...
14:49:01 <ziman> ... compression algorithm. ;)
14:49:40 <eu-prleu-peupe1> :)
14:49:57 <monochrom> well, mutation not fair.
14:51:26 <mrsolo_> how does runhaskell work? does it compile haskell code on the fly?
14:52:25 <dons> mrsolo_: it runs it in the bytecode interpreter
14:52:30 <dons> its compiled to bytecode on the fly
14:53:09 <mrsolo_> i see.. thanks :-)
14:53:10 <ddarius> For GHC...
14:53:37 <dons> runhaskell for the hugs case just runs hugs, which compiles bytecode on the fly
14:53:38 <monochrom> It does the something processing as ghci.
14:53:51 <monochrom> s/something/same/
14:56:26 <dons> ?pl primNewMU n = return . mkMUVPrim =<< newSTUVector n
14:56:27 <lambdabot> primNewMU = (mkMUVPrim `fmap`) . newSTUVector
14:56:39 <mrsolo_> nice hello world is slightly faster than ruby version
14:56:43 <mrsolo_> at least comparable
14:56:55 <dons> try compiling it :)
14:57:05 <dons> ghc -O2 hello.hs
14:57:18 <mrsolo_> oh no comparison
14:57:29 <mrsolo_> but i am checking to see if haskell is good for scripting
14:58:04 <sjanssen> why does pl choose that version rather than "fmap mkMUVPrim . newSTUVector"?
14:58:26 <dons> its not smart?
14:58:36 <sjanssen> or too smart
15:05:37 <sjanssen> @pl fmap mkMUVPrim . newSTUVector
15:05:37 <lambdabot> fmap mkMUVPrim . newSTUVector
15:06:03 <sjanssen> @pl primNewMU n = newSTUVector >>= return . mkMUVPrim
15:06:03 <lambdabot> primNewMU = const (mkMUVPrim `fmap` newSTUVector)
15:06:12 <sjanssen> @pl primNewMU n = newSTUVector n >>= return . mkMUVPrim
15:06:12 <lambdabot> primNewMU = (mkMUVPrim `fmap`) . newSTUVector
15:17:42 <nejucomo> I want to define a type which is like [a] except it has a fixed length.  Is this possible?
15:17:58 <ddarius> (a,a,a)
15:18:02 <nejucomo> A tuple would work, but would be very cumbersome for long lengths.
15:19:28 <edwardk> What does it mean when haddock puts in ???'s like: (Show i, ??? e i) => Show (Pointer i a)
15:19:33 <nejucomo> I suppose a list with runtime length checking is best...
15:19:50 <xd> what about an array?
15:19:53 <ddarius> nejucomo: It's probably the simplest answer.
15:24:08 <nejucomo> Is it possible to specify "non-negative" Integer as a type?
15:25:46 <dons> it is possible, but not trivial,  if you want it to be a nice instance of Num
15:27:04 <Cale> Well, there are definitions like  data Nat = Zero | Succ Nat
15:27:06 <ddarius> dons: How would it ever be a nice instance of Num?  Almost all the operations would be partial.
15:28:07 <dons> yes, that's to separate sentences.
15:28:20 <dons> its possible but not trivial, to make it useful. forget about Num.
15:29:26 <ddarius> newtype Natural = Natural Integer deriving (Eq, Ord, Show)
15:30:11 <gwern> 'Let’s take a look into functional and modular modern languages such as Haskell. Its arch-fathers Simon Peyton-Jones, Paul Hudak  and Philip Wadler neutralize one each other, so, it’s very hard to predict it’s fortune. However if we’ll normalize their hair we can get very good chances for Haskell.' http://blogs.microsoft.co.il/blogs/tamir/archive/2008/04/28/computer-languages-and-facial-hair-take-two.aspx
15:30:14 <lambdabot> http://tinyurl.com/6ydcjt
15:31:42 <Cale> Nothing could possibly neutralise Wadler's beard!
15:33:13 <gwern> Cale: peyton-jones is practically hairless!
15:34:07 <Botje> SimonPJ doesn't change. ever. that's why he's so good at what he does :)
15:36:17 * ddarius much preferred the old photo on his MSR page.
15:36:38 <monochrom> SimonPJ doesn't have state mutation? Is that why he's into pure functional programming?
15:37:01 <ivanm> Botje: he doesn't even change _for_ the better? :p
15:37:45 <Botje> occasionally he copies himself and lets the old simonpj get garbage collected
15:37:46 <ddarius> Just an infinite structure being reduced to normal form.
15:37:57 <Botje> this is all a grand scheme to simulate the effect of aging.
15:38:10 <ivanm> ahhh
15:42:08 <takamura> hi
15:42:49 <nejucomo> I've defined a parameterized type with record syntax.  What's the syntax for constructing such a thing?
15:43:09 <sjanssen> Record { field1 = x, field2 = y }
15:43:15 <sjanssen> or Record x y
15:43:36 <nejucomo> sjanssen: Thanks.  And it determines the type based on the types of x and y?
15:43:55 <sjanssen> nejucomo: yep, regular type inference applies
15:44:15 <eu-prleu-peupe1> is it possible to get a job coding haskell ?
15:44:27 <eu-prleu-peupe1> and get payed for it...
15:44:30 <sauxdado> the short answer is no.
15:44:36 <augustss> yes!
15:44:39 <ddarius> There are plenty of people with Haskell jobs right here right now.
15:44:43 <sauxdado> the long answer is yes :)
15:44:59 <tromp> 50% longer in fact
15:45:03 <ivanm> @faq haskell jobs
15:45:03 <lambdabot> The answer is: Yes! Haskell can do that.
15:45:07 <ivanm> :p
15:45:08 <nejucomo> I'm writing haskell right now for work.  ;-)
15:45:23 <glguy> short answer no??
15:45:28 <eu-prleu-peupe1> i mean, without having to build my own company
15:45:30 * glguy visits payroll
15:45:35 <nejucomo> Of course, that's because I'm writing a little tool and there are no other developers I have to haggle over design issues with.
15:45:38 <edwardk> lennart here is the exception to the rule ;)
15:45:48 <tromp> lambdabot, can Haskell go down in flames?
15:46:05 <nejucomo> -but one of my coworkers recommended the language to me, and that's why I'm learning it.
15:46:10 <sjanssen> edwardk: and dons, glguy, Heffalump, ...
15:46:12 <edwardk> shapr was doing haskell for a living before I stole him with offers of comparatively vast quantities of cash.
15:46:15 <sauxdado> glguy: it's possible to get a haskell job, similar to how it's possible to become a rock star or a photographer for national geographic
15:46:30 * glguy is Haskell rockstar ;)
15:47:00 <edwardk> sjanssen: yeah, but as a percentage of the channel its still vanishingly small ;) of course it helps that argument that the channel keeps growing so fast
15:47:12 <tromp> are you colleagues with shapr now, edwardk?
15:47:17 <takamura> Somebody here uses yi? I'm trying to install it from source, but there is something strange.
15:47:17 <edwardk> tromp: yeah
15:47:21 <monochrom> I think it is well-known that "short answer" is inaccurate and not worth disproving.
15:47:27 <sjanssen> @users
15:47:28 <lambdabot> Maximum users seen in #haskell: 468, currently: 430 (91.9%), active: 23 (5.3%)
15:47:28 <dons> nejucomo: woot!
15:47:31 <augustss> edwardk: and how many here have tried getting a job doing haskell?
15:47:49 <dons> a dozen maybe
15:47:52 <eu-prleu-peupe1> i just dont see any job offers in my country
15:48:13 <eu-prleu-peupe1> i see lots of C# and java :)
15:48:25 <dons> live the dream!
15:48:32 <dons> programming can be fun!
15:48:40 <eu-prleu-peupe1> yes dons, but it can also be torture
15:48:43 <augustss> eu-prleu-peupe1: you have to seek them out.  the haskell jobs
15:48:46 <shapr> yarr!
15:49:02 <nejucomo> Haskell wasn't mentioned for this job description, but what was included was "authoring small tools".
15:49:03 <edwardk> lenart: well, i think shapr tried it once over at credit suisse, no? ;)
15:49:06 <shapr> tromp: We should meet.
15:49:09 <eu-prleu-peupe1> augustss: like needle on the haystack
15:49:09 <augustss> @yarr
15:49:10 <lambdabot> Smartly me lass
15:49:28 <shapr> Yeah, I wanted to hook up with credit suisse, but they were shocked to discover that I have no degree at all.
15:49:30 <eu-prleu-peupe1> i think it would help if there was some kind of haskell on rails
15:49:53 <augustss> @yarr
15:49:54 <lambdabot> Arr! Me ship be the biggest brig in the port!
15:50:10 <monochrom> No, it would not help to parrot existing things.
15:50:10 <solrize> is the hackage pkg-list.html page generated automatically from the cabal files?  the description strings don't always seem to match.
15:50:12 <ivanm> eu-prleu-peupe1: but haskell goes fast enough as it is, without having to be put onto railroad-tracks! ;-)
15:50:34 <eu-prleu-peupe1> ;)
15:50:39 <ivanm> monochrom: oh, so you mean my parrot backend for ghc is useless now? :p
15:50:48 <eu-prleu-peupe1> ok, then a simple apache mod_haskell would help
15:50:50 <dcoutts> solrize: yes, and it uses the synopsis in preference to the description
15:51:32 <solrize> hmm, then the page about the package itself doesn't seem to show the synopsys?
15:51:38 <augustss> ivanm: parrot backend for ghc.  hmmmmmm
15:51:44 <augustss> @yarr
15:51:44 <lambdabot> Gangway!
15:51:49 <monochrom> It's like: "linux would be more popular if it looked like windows".  That's wishful thinking.  If linux looks just like windows, why not use windows?  linux has to surpass windows by several magnitude in order to be popular.
15:52:08 <dcoutts> @seen bos
15:52:08 <lambdabot> I saw bos leaving #haskell and #ghc 29m 15s ago, and .
15:52:33 <ivanm> augustss: I'm kidding...
15:52:45 <ivanm> monochrom: but it already does!
15:52:46 <augustss> ivanm: phew
15:52:52 <takamura> people doesn't use windows because it is good, only because all the other people is using it :S
15:52:56 <ivanm> I would have no idea even where to start :p
15:52:56 <solrize> the concept of an apache mod_haskell is mind wobbling. i think there is a haskell fastcgi library, which makes more sense
15:53:02 <monochrom> "haskell on rails" will not help haskell because it's just copying from ruby --- so why not just use ruby?  What you need is haskell on steroid and it totally blows ruby on rails.
15:53:09 <shapr> monochrom: Still, there's the idea of "least surprise"
15:53:11 <eu-prleu-peupe1> i use windows because it works
15:53:14 <dcoutts> @tell bos you didn't put any version constraint on the Cabal version in build-depends for cabal-rpm. You said it works with 1.2.x, so you should use build-depends: Cabal >= 1.2 && < 1.3
15:53:14 <lambdabot> Consider it noted.
15:53:19 <eu-prleu-peupe1> i dont use linux because it doesnt work
15:53:26 <solrize> haskell on steroids  hey i like that
15:53:29 <ivanm> how can it not work?
15:53:39 <eu-prleu-peupe1> lame proprietary drivers
15:53:46 <monochrom> IMO least-surprise is bunk.
15:53:47 <dcoutts> @tell bos otherwise it *will* break when I release Cabal-1.4
15:53:47 <lambdabot> Consider it noted.
15:53:52 <shapr> I think a powerful and intuitive Haskell web dev platform would be a great community benefit.
15:53:55 <ivanm> eu-prleu-peupe1: that's not the OS's fault
15:54:01 <eu-prleu-peupe1> i know...
15:54:05 <shapr> monochrom: In my experience, least surprise is a powerful thing.
15:54:05 <solrize> shapr, happs isn't intuitive enough?  :)
15:54:10 <eu-prleu-peupe1> ...but its a reason for me not be on linux right now :(
15:54:10 <augustss> I don't use Windows or Linux unless I'm forced to.
15:54:11 <shapr> solrize: Well, it could be better.
15:54:25 <ivanm> monochrom: then again there's the theory of suprise in Terry Pratchett's "Thief of Time"... ;-)
15:54:29 <shapr> solrize: I don't think HAppS acts much like other Haskell code.
15:54:34 <solrize> i'm joking, happs is pretty baffling to me
15:54:48 <ivanm> augustss: what _do_ you use then? Mac? BSD? DOS? :p
15:55:04 <solrize> i think i understand the main ideas in it from alexj's talk, and it's brilliant, but the actual implementation and how to use it is like opaque.
15:55:09 <shapr> monochrom: Did you see the girlfriend test for ubuntu today on slashdot?
15:55:11 <augustss> ivanm: I use NetBSD and MacOS
15:55:17 <ivanm> ahhh
15:55:28 <monochrom> Yes, I did, and I have my own thoughts.
15:55:40 <augustss> ivanm: one is pretty on the inside and the other on the outside
15:55:45 <shapr> monochrom: In that article, the girlfriend attempts to use the same windows patterns to do things on Linux. That seems to support the principle of least surprise to me.
15:55:45 <ivanm> lol
15:55:45 <eu-prleu-peupe1> augustss: which one do you prefer ?
15:55:55 <monochrom> Part of it shows there is valid room for improvement.
15:56:13 <augustss> eu-prleu-peupe1: NetBSD when I'm writing device drivers. :)
15:56:27 <ivanm> heh
15:56:28 <monochrom> Part of it shows that it is not ubuntu's fault, it's microsoft's fault for monopolizing and brainwashing.
15:56:48 <monochrom> I mean what do you mean you don't know that besides MSN there are other choices for IM?
15:56:49 <ivanm> shapr: then consider how many people hate vista/office '07...
15:56:57 <shapr> monochrom: Whether that's true or not, it does show that people try to use what patterns they've used before to accomplish the same things elsewhere.
15:57:00 <ivanm> monochrom: you're joking, right? :p
15:57:57 <solrize> @seen dons
15:57:57 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc and #haskell. I last heard dons speak 9m 25s ago.
15:57:58 <monochrom> Should Pidgin just look like the MSN client?  By that logic, Haskell should look like C++ too.
15:58:06 <solrize> dons i wonder if you could add the word "unicode" to the utf8-string cabal description and synopsis somehow.  that would help find it when searching for unicode libraries.
15:58:22 <monochrom> I think all of us are into Haskell precisely because it is the greatest surprise.
15:58:24 <shapr> monochrom: Most successful languages do look like C.
15:58:28 <ivanm> monochrom: why C++, rather than just C?
15:58:48 <shapr> monochrom: Actually, I'm into Haskell because it does satisfy my viewpoint on the principle of least surprise.
15:58:55 <ivanm> shapr: but is that because it's the best coding style, or because people who design new languages generally only know about C-style ones?
15:59:30 <monochrom> Least surprise to a newborn infant, I support that.
15:59:32 <augustss> It's because the unwashed masses only know C-like languages.
15:59:35 <shapr> ivanm: I think it's because people (in general) don't change easy, and so many people already know C-style languages. Once again, least surprise.
15:59:53 <solrize> python is doing pretty well without curly braces
16:00:08 <shapr> Yeah, but it does act a lot like C :-)
16:00:09 <monochrom> Least surprise to a brainwashed grow-up? That's just succumbing to the monopoly.
16:00:29 <shapr> monochrom: How do you know if someone has been brainwashed?
16:00:30 <sauxdado> "least surprise to a newborn infont" means K&R style, 8-space tabs and words in variables names separated by underscores.
16:00:33 <solrize> it's more c-like than haskell, for sure
16:00:39 <ivanm> I know that when they started up teaching scheme as a first year language at uni here, a lot of people hated it (especially since for that first year we'd just finished introductory java)...
16:00:55 <monochrom> By observing how he/she responds to diversity and alternatives.
16:00:57 <eu-prleu-peupe1> haskell is preatty c-like
16:01:08 <ivanm> has anyone done any studies, etc. to compare how many people on first experience to list/haskell/etc. like it based upon whether they've programmed before or not?
16:01:09 <monochrom> A brainwashed person passionately attacks alternatives.
16:01:21 <sauxdado> emacs sucks!!!
16:01:27 <ivanm> @slap sauxdado
16:01:27 * lambdabot submits sauxdado's email address to a dozen spam lists
16:01:33 <ivanm> monochrom: blob language?
16:01:35 <augustss> emacs rox!
16:01:53 <shapr> monochrom: I think part of that is that humans tend to integrate their tools into their self-image, and thus when alternatives to that tool are presented, those people feel attacked.
16:01:54 <takamura> vim rox!
16:02:02 <mrsolo_> what is wrong with haskell on rails?  does haskell have something superior?
16:02:03 <eu-prleu-peupe1> my doctor said that i could not use emacs anymore because of the tendinite i got from doing all those shortcuts
16:02:11 <solrize> i tend to like new languages when i try them, maybe because i think all languages suck so i'm desperately seeking alternatives to what i'm used to :)
16:02:12 <monochrom> See also http://www.vex.net/~trebla/weblog/intuitive.html
16:02:13 <lambdabot> Title: What Is Intuitive?
16:02:17 * ivanm doesn't use rox... :p
16:02:20 <shapr> solrize: I agree with you.
16:02:34 <sauxdado> monochrom: is it an article about nipples? Cause that would be pretty cool.
16:02:39 <shapr> heh
16:02:53 <sauxdado> programming languages should be more like nipples.
16:03:53 <shapr> monochrom: I don't disagree with that essay on intuitive.
16:04:16 <ivanm> but do you agree with it?
16:04:23 <eu-prleu-peupe1> nipples are good
16:04:31 <shapr> I do think that people will be more likely to learn Haskell if they can use it to solve their problems. Since a lot of people have or want websites, I think Haskell on Steroids would be a good thing.
16:04:49 <shapr> ivanm: Yeah, I agree with it.
16:04:51 <monochrom> Yes, that's my point.
16:05:06 <eu-prleu-peupe1> Haskell on vitamin C
16:05:10 <Botje> haskell on hacksaws!
16:05:12 <eu-prleu-peupe1> :D
16:05:24 <shapr> Haskell on Hanggliders!
16:05:31 <solrize> what's the cabal configure option to compile profiled versions of the library?
16:05:35 <sauxdado> Haskell on Harlots
16:05:36 <ddarius> This was all done before.
16:05:40 <solrize> lol
16:05:40 <shapr> sauxdado: ew
16:05:41 <dcoutts> solrize: -p
16:05:48 <solrize> dcoutts thanks
16:05:51 <dcoutts> solrize: see configure --help for a reference
16:05:54 <sauxdado> shapr: "More intuitive than the nipple!"
16:05:58 <shapr> sheesh
16:06:01 <geezusfreeek> lol
16:06:17 <solrize> i looked there, it doesn't mention -p, the wiki page doesn't mention it either,  if it were up to me i'd make it enabled by default.
16:07:24 <solrize> wiki doesn't let me edit without logging in
16:09:14 <geezusfreeek> "[Hans] Reiser is guilty of first-degree murder, the jury has found. He killed Nina with premeditation and deliberation and now faces 25 years to life in prison." :(
16:09:21 <eu-prleu-peupe1> is haskell going to overthrown C# ?
16:09:23 <eu-prleu-peupe1> ah yes
16:09:25 <dcoutts> solrize: cabal configure --help says:
16:09:25 <dcoutts>  -p --enable-library-profiling     Enable Library profiling
16:09:30 <eu-prleu-peupe1> he was found guilty ?
16:09:37 <geezusfreeek> http://www.sfgate.com/cgi-bin/blogs/sfgate/detail?blogid=37&entry_id=26050
16:09:38 <eu-prleu-peupe1> :(
16:09:40 <ddarius> eu-prleu-peupe1: C# is going to become Haskell.
16:09:41 <dcoutts> solrize: and you get the same from runghc Setup.hs --help
16:09:46 <lambdabot> Title: The Chronicle Local News Blog : Hans Reiser Trial: April 28, 2008, http://tinyurl.com/6hgd8k
16:10:19 <dcoutts> solrize: and with cabal-install you can set a default in the config file
16:10:23 <solrize> dcoutts aha, i used runghc Setup.hs --help configure
16:10:46 <dcoutts> solrize: ah, that'll give you help about the top level commands
16:10:48 <solrize> oh cool, i haven't been using cabal-install, didn't realize it was around
16:10:59 <solrize> i guess i should download it
16:11:16 <ddarius> cabal install cabal-install
16:11:22 <dcoutts> solrize: you can use the darcs versions for the moment we'll be making a full release sometime soon
16:11:30 <dcoutts> ddarius: that'll work once it's on hackage :-)
16:11:43 <solrize> wow, reiser convicted.  missed that earlier.
16:12:05 <MyCatVerbs> solrize: not really surprising.
16:12:08 <solrize> dcoutts thanks
16:12:31 <jberryman> I'm a little confused. Why is the prelude's 'maxumum' defined in such a way that 'maximum [1..1000000]' causes Hugs to die?
16:12:37 <jberryman>  I've tried defining some other functions to do this simple thing, but none are "lazy enough" apparently.
16:12:55 <solrize> > foldl1' max [1..1000000]
16:12:57 <lambdabot>  1000000
16:13:13 <dolio> How does it die?
16:13:21 <solrize> > maximum [1..1000000]
16:13:22 <lambdabot>  1000000
16:13:25 <solrize> stack overflow i presume
16:13:28 <jberryman> segfaults? let me check
16:13:34 <solrize> i think i encountered that too a while back
16:13:59 <jberryman> yeah, segmentation falut
16:14:23 <ddarius> jberryman: That's Hugs' way of saying stack overflow.
16:15:25 <jberryman> with maximum [1..10000], I get "ERROR - control stack overflow" but Hugs doesn't croak
16:15:56 <jberryman> I'm just wondering why it's not just working from left to right and keeping the highest value, you know?
16:16:10 * jberryman is a newbie
16:16:14 <ddarius> jberryman: Because that's not how maximum is defined in the report.
16:17:04 <jberryman> ddarius, why not? I guess it's not for a case like this of course. I was just puzzled
16:18:21 <ddarius> The Report uses foldl/foldl1 rather than foldl'/foldl1'.  Really, in my opinion, the Report should define foldl/foldl1 as foldl'/foldl1'.
16:19:15 <dolio> Does it use seq anywhere besides ($!)?
16:19:30 <monochrom> The report is not obliged to teach efficient algorithms IMO. It should use simple code, even if it is slow, to show what is the right answer.
16:19:36 <ddarius> dolio: I think I looked at one time and it doesn't.
16:20:11 <monochrom> Afterall, the report doesn't even say how to do non-strict evaluation efficiently.
16:20:14 <ddarius> monochrom: foldl is a different function from foldl'
16:21:04 <monochrom> How different?
16:21:18 <ddarius> monochrom: By using foldl1 in maximum, implementations are required to support an arguably broken definition rendering maximum (and minimum and sum and product) useless for serious work.
16:21:38 <ddarius> monochrom: foldl is slightly lazier
16:21:40 <monochrom> If there is a difference, the difference can be used as justification for co-existence of both, but definitely not replacing the former by the latter unilaterally.
16:22:46 <ddarius> monochrom: There is almost no reason to have foldl or foldl-based definitions.  If you -do- want it, write it.  foldl' is the right default, I shouldn't have to reimplement half the Prelude because it's using the wrong default.
16:23:15 <ddarius> Currently, if you want the reasonably behaviour, you have to reimplement standard functions.
16:23:18 <MyCatVerbs> monochrom: foldl builds up a huge chain of thunks, using O(N) space for the thunks allocated as it runs down the list alone, whereas foldl' evaluates each intermediate step immediately, consuming only O(1) space along the way.
16:23:45 <monochrom> MyCatVerbs: see my comment on simple code, right answer, and even if it means slow code.
16:24:05 <ddarius> monochrom: A language report is not a textbook or a tutorial.
16:24:13 <MyCatVerbs> monochrom: complexity classes matter a lot more than constants.
16:24:19 <bd_> ddarius: since maximum is strict on its list anyway, wouldn't replacing foldl1 with foldl1' be a legal optimization?
16:24:22 <monochrom> A language report is not a library.
16:24:26 <MyCatVerbs> monochrom: foldl is effectively useless by comparison to foldl' (unlike foldr and foldr') since foldl can't ever act lazily *anyway*.
16:24:45 <MyCatVerbs> (Can't take advantage of laziness, I mean.)
16:25:03 <monochrom> The report doesn't even talk about laziness.
16:25:37 <monochrom> Do you know that foldl for maximum is wrong if a compiler generates eager non-strict code, for example?
16:25:38 <ddarius> bd_: maximum isn't necessarily strict on it's elements, but yes, strictness analysis can lead to foldl becoming foldl' (which is what happens in GHC with sum between -O0 and -O)
16:26:29 <monochrom> The report is not obliged to provide code striving for the best possible complexity class.
16:26:35 <bd_> ddarius: hm, for maximum to be nonstrict on its elements, compare would always have to return a constant for that type - and moreover, EQ, since anything else would produce an inconsistent ordering
16:26:47 <bd_> which I guess is a legal definition of compare, but not a very useful one
16:27:25 <dons> woot, code coverage for darcs, http://www.downstairspeople.org/darcs-hpc/hpc_index.html
16:27:28 <monochrom> It cannot. It doesn't say "it must be lazy evaluation". If you don't pin down evaluation, you cannot say what complexity class a piece of code is in.
16:27:42 <Saizan> monochrom: the problem is how much you have to adhere to the result of the implementation in the report to clain you've implemented the right answer
16:27:44 <dons> maximum is strict for atomic types, fwiw.
16:27:46 <dons> via a specialisation
16:27:59 <ddarius> monochrom: The issue is that the Report definitions -preclude- efficient implementation.
16:28:25 <dons> i've spoken to a couple of the H98-ers, and as there was no foldl' at the time, the intention was that foldl would 'just work'
16:28:35 <dons> so interpretation over the years has changed things.
16:28:43 <monochrom> Sorry, I don't see how. Is there a clause that says "all implementations must be slower than the given code"?
16:28:49 <dons> note also that ghc gets foldl -> foldl' most of the time now, with atomic types.
16:29:03 <ddarius> monochrom: They must support the semantics and strictness analysis is undecideable in general.
16:29:27 <sm> dons: that is pretty nice! (code coverage)
16:29:34 <monochrom> My understanding is the implicit "gives the same strictness and non-strictness, gives the same return value", and how much time and memory to use is up to implementations.
16:29:41 <dons> not my work, sm. chris lane
16:29:42 <sm> is that coverage by quickcheck properties ?
16:29:58 <dons> sm, that looks like quickcheck, plus the test suite of unit tests
16:30:03 <sm> code exercised by..
16:30:10 <ddarius> monochrom: It can't, in general, reasonably give the same memory/time usage and preserve the non-strictness.
16:30:12 <dons> 75% top level coverage is excellent
16:30:33 <sm> it's more than I would have guessed
16:30:45 <clanehin_> I think it doesn't include quick check
16:31:09 <dons> oh , you might be right.
16:31:16 <dons> the qc's for darcs are compiled in , aren't they?
16:31:21 <dons> and that module's not present?
16:31:35 <dons> though i'm not sure you can tell from the graph
16:31:40 <clanehin_> No, 'make test', to my surprise, doesn't include test_unit.
16:31:51 <sm> right.. that's make unit
16:32:03 <clanehin_> And it takes all night to run hpc sum, so I just posted what I had.
16:32:25 <dons> clanehin_: still, 75% is really good. so  now there's no excuses for bugs in darcs
16:32:28 <dons> :)
16:32:33 <sm> ha
16:32:43 <dons> the hpc sum issue can be reported to andyjgilllllllll
16:32:47 <dons> without so many ls
16:34:47 <clanehin_> I think I can at least multiprocess it in a shell script.
16:35:09 <nejucomo> Is the idiom for appending to a list just "l ++ [a]" ?
16:35:37 <ddarius> nejucomo: Possibly, but probably not.  It depends on what you are doing.
16:35:56 <ddarius> (++) has to recreate it's left argument so it is O(length l)
16:37:03 <dons> if you're doing appends a lot, a dlist makes more sense (i.e for pretty printing), otherwise its a fine example
16:37:15 <nejucomo> What's a dlist?
16:37:21 <dibblego> ?where DList
16:37:22 <lambdabot> http://www.cse.unsw.edu.au/~dons/dlist.html
16:37:46 <dons> ?hackage dlist
16:37:47 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist
16:37:59 <dons> but only if you've identified snoc or append as a bottleneck
16:39:44 <nejucomo> Is there a stdlib function to convert a Word64 into a binary byte array of big-endian encoding?
16:41:59 <dons> in the Data.Binary library
16:42:03 <dons> putWord64_be
16:42:08 <nejucomo> thanks.
16:42:17 <dons> :t Data.Binary.Put.putWord64be
16:42:18 <lambdabot> Word64 -> Data.Binary.Put.Put
16:42:43 <nejucomo> Hmm... I don't see Data.Binary in my library docs.
16:43:36 <nejucomo> -and that :t expression doesn't work in my ghci.  Bummer.
16:43:41 <MyCatVerbs> It suddenly occurs to me that exceptions have to be just about the single dumbest method of error handling ever invented that actually happen to just about work.
16:44:26 <dons> ?hackage binary
16:44:27 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
16:44:33 <dons> nejucomo: its in the 'binary' package
16:46:32 <nejucomo> Thanks again.
16:47:46 <efdetonator> I've installed gtk2hs and when I try to compile the Hello World example, it says: Compilation is not required  hello.o: In function `r2Jl_info':   and a lot of messages like this one
16:48:10 <dcoutts> efdetonator: rm the .hi and .o files
16:48:24 <sjanssen> efdetonator: how are you compiling it?
16:48:39 <sjanssen> efdetonator: you probably need to use --make or add appropriate -package flags
16:48:43 <efdetonator> my fault =/
16:48:50 <efdetonator> I was just used with gcc
16:48:54 <efdetonator> I tried without --make -_-
16:49:00 <efdetonator> sorry
16:50:12 <sjanssen> efdetonator: no problem, it is a frequent pitfall
16:50:36 <sjanssen> efdetonator: the error is similar to forgetting an -l flag to gcc
16:51:00 <efdetonator> I see =] thanks
16:54:33 <monochrom> MyCatVerbs: what works better for error handling?
16:54:48 <Cale> I think perhaps --make should be default.
16:55:22 * monochrom read David Parnas's original paper on exception, and is pretty convinced it is nice.
16:59:11 <dons> sjanssen: zipWithU works now :)
16:59:39 <dons> needs an associated type, but seems to optimise well
17:00:48 <MyCatVerbs> monochrom: I'm thinking exactly the same thing, but with a continuation attached so that you can return to the point you just leapt away from if it turns out that the error is correctable.
17:02:01 <MyCatVerbs> monochrom: or maybe not. Either way, surely there's *some* method of abusing continuation-passing that could be used to make things more pleasant to work with than error codes or exceptions?
17:04:09 <efdetonator> When I import Graphics.UI.Gtk it doesn't give an error but if I import Graphics UI.Gtk.Glade it gives this error Could not find module `Graphics.UI.Gtk.Glade'       Where do I find the glade module to install?
17:04:22 <MyCatVerbs> monochrom: it's annoying that throwing an exception causes you to completely lose the scope the exception was thrown from. Surely there has to exist a scheme which doesn't involve chucking local bindings out the window.
17:04:58 <monochrom> If you use an attached continuation, and you don't plan to correct errors - you plan to just escape, that's exactly exception. If you plan to correct error and resume, that's better than exception.
17:07:49 <efdetonator> sjanssen: I've tried to use the module Graphics.UI.Gtk.Glade but it couldn't find it, do you know what I must do?
17:11:50 <solrize> woo hoo, found that parnas paper.  http://home.comcast.net/~patrickdlogan/parnas.pdf
17:11:56 <MyCatVerbs> monochrom: eh, ignore me, I'm just kvetching. In practice people just fit the catches appropriately tightly to the exception-throwing code and there's no problem.
17:12:38 <monochrom> Unix has signals. Most CPUs have "traps". Whenever a designated event or error occurs, you escape, and you can choose to resume too. This is implemented using something equivalent to continuation, i.e., switch to a different stack, switch back to the original stack.
17:13:02 <MyCatVerbs> monochrom: still. It's vaguely tempting to have a go and see if maybe resumable-exceptions could be implemented by abusing GHC's implicit parameters support.
17:13:44 <monochrom> Yes, if you don't need resume, except is just right. Of course some people misuse it, but when it's used correctly it follows the right structure.
17:14:49 <MyCatVerbs> Come to think of it, the other irritation is how almost every catch block immediately ends up turning into an explicit loop structure if you want to be able to retry via another path.
17:15:00 <monochrom> I misspoke about switching stacks. But I'm still right about doing the same thing as continuation: stack manipulation.
17:15:20 <MyCatVerbs> While that suffices, the loop structure starts to pervade and distract from the real intent of the code.
17:15:25 <monochrom> stack and execution-context manipulation.
17:15:59 <monochrom> Yes, it is not good for retry.
17:16:00 <MyCatVerbs> Heheheh. man 2 getcontext
17:16:39 <MyCatVerbs> It took me several minutes to cease laughing evilly when I first discovered that POSIX C has first-class continuations. ;)
17:17:04 <MyCatVerbs> (Well, contexts, but they're just as good semantically, even if they are perhaps an awful lot slower sometimes.)
17:17:54 <Plareplane> efdetonator, did you install gtk2hs via ubuntu's packaging system?
17:18:41 <efdetonator> no
17:18:57 <efdetonator> I use ubuntu but I didn't installed through apt-get
17:19:15 <dcoutts> efdetonator: so you built gtk2hs from source?
17:19:20 <efdetonator> yes
17:19:25 <Plareplane> oh. i was about to say that you'd need both libghc6-gtk-dev as well as libghc6-glade-dev :(
17:19:33 <dcoutts> efdetonator: when you ./configure gtk2hs it tells you which bits it'll install
17:19:56 <dcoutts> efdetonator: you can go try it again and see what it probably installed last time
17:20:20 <dcoutts> efdetonator: if glade is not there it's almost certainly because you don't have the libglade header files etc installed
17:20:30 <efdetonator> yeah it didn't installed it for glade =/
17:20:42 <efdetonator> but I'm with glade installed :P
17:21:01 <dcoutts> efdetonator: you can install that using apt by installing the libglade-dev package, or some package with a similar name, perhaps -devel I don't recall.
17:21:18 <monochrom> In retrospect it's actually pretty easy for the C people to support first-class continuations. Afterall they're so close to the low level. In fact they have had setjmp-longjmp for decades, not a big leap to go full-blown continuation.
17:21:20 <efdetonator> ok thanks :)
17:22:08 <solrize> there's been a bunch of C coroutine libraries, but C traditionally uses the hardware stack without any bounds checking
17:22:22 <monochrom> So, both implementors and users should have little problem embracing it.
17:22:53 <MyCatVerbs> monochrom: well, they have to hack their compilers to turn a whole pile of optimizations off, but gcc will do that quite happily these days with the appropriate __attribute__s set, AFAIK.
17:23:49 <MyCatVerbs> monochrom: setjmp() isn't really a function so much as a language primitive, considering the amount of work that has to be done on the compiler to prevent it emitting incorrect code around it.
17:25:24 <monochrom> "Delimited Continuation for C Dummies!"  Not sure if the C people get offended. :)
17:26:11 <monochrom> Subtitle is "Olegology for The Rest of Us!" :)
17:26:50 <MyCatVerbs> Is that "Olegology" as in the study of people whose brains run Hindley-Milner as a background thread?
17:28:00 <monochrom> Oleg has hardware acceleration for types and continuations.
17:31:09 <MyCatVerbs> monochrom: one of the best things about continuation-passing, IMO, is the fact that it's isomorphic to gotos and labels.
17:31:36 <MyCatVerbs> monochrom: so not only do you get your nice arbitrarily-structured call graph, but you also get to piss EWD off while you're at it!
17:32:45 <TomMD> For the academically minded: is there recent work/research in strictness analysis?  It seems to have dried up ten years ago judging by the papers I am finding.
17:32:48 <gwern> holy cow. Hans Reiser was convicted
17:32:53 <Saizan_> do you think delimited continuations are easier to understand in CPS or direct style?
17:34:28 <Riastradh> MyCatVerbs, on your desire to do `exceptions' without throwing out local bindings: if you are not familiar with Common Lisp's condition system, then you should be.
17:34:33 <dcoutts> TomMD: I think people realised that the strictness analysis was good enough, at least for most compilation purposes, there's not much use for the more detailed info from the more sophisticated analyses
17:36:14 <MyCatVerbs> gwern: what do you mean "holy cow"? His defense sounded about as convincing as a five year old's explaination of why they should have the ice cream even though they haven't eaten their brocolli.
17:36:17 <TomMD> dcoutts: I see.  And as far as GHC history is concerned, it looks like the strictness analyzer got most its love from Peytons 1993 work.  Anyone know if it has changed much since? (disclaimer: I haven't read Peyton93)
17:36:32 <MyCatVerbs> gwern: mind, I've only heard thirdhand descriptions of it, not the actual defense itself.
17:37:00 <dcoutts> TomMD: I don't know, you can look at the code and see if it credits any paper
17:37:12 <solrize> i don't understand how they figured premeditation.  if he planned it out ahead of time he'd have done a much more careful job, and left the country immediately instead of waiting around for months.
17:37:20 <MyCatVerbs> Riastradh: It's just one of many things that I should be familiar with but aren't (sic?).
17:37:25 <monochrom> My current mental model of delimited continuation is still at the operational level of "here are the remaining instructions to run, but save this interval away, stick that other interval in, now run it".  I have not found an effective model at a more mathematical level.  There is of course translation to the lambda calculus, but I find the result of the translation unworkable.
17:37:50 <gwern> MyCatVerbs: I was surprised he was convicted of 1st degree; manslaughter wouldn't've surprised me
17:38:24 <monochrom> However, if you use delimited continuation to implement a higher-level feature X, you can more easily give a mathematical and workable model to X.
17:38:29 <MyCatVerbs> Riastradh: anywhere in particular I should look for information? Or should I just grub up "Practical Common Lisp" and browse for the relevant chapter?
17:38:44 <solrize> for CL conditions?  cltl2 is online
17:38:47 <gwern> I mean, I look at local trials where people beat the 1st degree rap and get manslaughter or something - and the evidence against them are far more damning than for reiser; for example, in this trials usually it's clear that someone was murdered, for starter
17:38:50 <MyCatVerbs> gwern: ah, fair 'nuff. Perhaps the jury decided they don't like him?
17:38:53 <Riastradh> MyCatVerbs, Kent Pitman's article about it is good; you can also find CLtL2.
17:39:37 * MyCatVerbs looks up Kent Pitman.
17:40:04 <MyCatVerbs> Nice beard. Probably couldn't found a Unix with one of those, but more'n sufficient to start a language. :)
17:40:39 <MyCatVerbs> Riastradh: http://www.nhplace.com/kent/Papers/Condition-Handling-2001.html <-- this one?
17:40:41 <lambdabot> Title: ``Condition Handling in the Lisp Language Family'' c by Kent Pitman (2001)
17:40:46 <Riastradh> MyCatVerbs, yes, that's it.
17:42:10 <MyCatVerbs> Danke.
17:44:03 * MyCatVerbs conses another item onto his to-read list. ;)
17:44:12 <MyCatVerbs> Er, cell, even.
17:44:39 <solrize> emacs lisp has a cheesy version of it built in
17:45:09 <MyCatVerbs> Emacs lisp has dynamic scoping, though.
17:45:33 <solrize> yeah, hmm, i'm not sure how much difference that makes
17:45:43 <solrize> CL doesn't have real continuations
17:45:58 <solrize> condition-case for both lisps is just a glorified catch/throw
17:46:06 <MyCatVerbs> I'm not sure *why* that scares me, but apparently the Lisp community as a whole has decided that it's more trouble than it's worth, considering how neither CL nor Scheme have it as default (though CL, as with damn near every other language feature on Earth, gives you forms of it optionally.)
17:49:07 <gwern> MyCatVerbs: it's kind of sad though that emacs uses emacs lisp
17:49:38 <Pseudonym> I think it made sense in 1984.
17:49:41 <gwern> (I did some digging on this, and it seems the reason stallman didn't use scheme was that at the time lexical scoping was apparently too inefficient)
17:50:00 <gwern> I mean, just dynamic scoping makes parallel stuff hard to add to emacs
17:50:12 <Riastradh> No, that's false, gwern -- both the myth about its inefficiency, and the myth about the myth about its inefficiency.
17:50:35 <monochrom> meta myth!
17:50:52 <monochrom> "this statement is a myth"
17:51:17 <Riastradh> Dynamic scope lent itself to a certain flexibility and extensibility that Emacs's designers (notably Mr Stallman) found very useful and valuable when building Emacs.
17:51:21 <solrize> i think he used dynamic scoping because he was used to it from maclisp, but for a while wanted to eventually switch it to scheme
17:51:56 <Riastradh> The Maclisp compiler implemented lexical scope for local variables.  They had known that this was the only sensible way to do things for over a decade before GNU Emacs.
17:52:34 <solrize> the emacs lisp compiler may have been sort of an afterthought
17:52:52 <solrize> to the recursive evaluator
17:54:29 <Riastradh> (Dynamic scope is also not the only barrier to concurrency in Emacs.)
17:57:33 <MyCatVerbs> What?
17:57:40 <MyCatVerbs> Concurrency? In a text editor?
17:58:16 <MyCatVerbs> Why?
17:58:41 <MyCatVerbs> I honestly cannot apprehend why somebody would need that. Maybe occasionally coroutines, sure, but concurrency?
17:58:42 <Riastradh> Concurrency in a general work environment.  It's nice to have one's work not blocked by the process of fetching mail, for instance.
17:58:45 <solrize> so you can run background tasks etc
17:58:54 <solrize> in emacs you tend to do that stuff by launching subprocesses
17:59:23 <monochrom> Concurrency in Windows? Why?
17:59:26 <solrize> there's sort of grotty hacks to do redisplay concurrently with lisp computation
18:00:13 <MyCatVerbs> Riastradh: fair 'nuff, good example.
18:01:12 <MyCatVerbs> Methinks coroutines would usually suffice in practice, but sure, I can see how concurrency would make IO-facing code easier to write nonblockingly.
18:01:33 * MyCatVerbs was thinking parallelism at first. Hence the immediate "WTF?" response.
18:02:39 <solrize> parallelism is useful
18:03:06 <solrize> e.g. if you're editing formatted text you might do something that makes the formatter munch through a long document
18:03:11 <solrize> and you want to keep editing while that is happening
18:03:28 <dcoutts> technically that's concurrency not parallelism
18:04:05 <solrize> well ok, it doesn't necessarily have to use parallell hardware
18:05:13 <gwern> hm. does anyone know what a .hc file is?
18:06:03 <tromp> is that haskell core?
18:06:18 <gwern> I don't know, why I'm asking
18:06:57 <tromp> hmm, that would be .hcr
18:08:43 <gwern> http://hackage.haskell.org/trac/ghc/wiki/Building/Porting 'Bootstrapping GHC on a system without GHC already installed is achieved by taking the intermediate C files (known as HC files) from another GHC compilation, compiling them using gcc to get a working GHC. '
18:08:45 <lambdabot> Title: Building/Porting - GHC - Trac
18:09:26 <tromp> so they are intermediate c files
18:14:11 <eu-prleu-peupe1> i think haskell and C might give a preatty good combination
18:14:20 <eu-prleu-peupe1> but i dont know a thing about haskell
18:14:24 <eu-prleu-peupe1> and very little about C
18:14:25 <eu-prleu-peupe1> :)
18:15:26 <nooblz> the only problem with that combination is that some haskellers are sticklers about keeping things purely functional.
18:15:57 <nooblz> there are advs. to either line of reasoning
18:15:59 <solrize> so i have a type inference question.  let's say i have a program with a type error, i.e. unification finds two conflicting terms.  if it just treats both of those as undefined, does it generally have a good chance of typing the rest of the program?  i'm asking because it would help diagnose errors a lot, if i could see the inferred types for terms near where the error is.
18:16:25 <MyCatVerbs> solrize: undefined unifies with anything, if that's what you're asking.
18:16:53 <MyCatVerbs> solrize: e.g. I can easily write unsafeCoerce :: a -> b, as unsafeCoerce = const undefined
18:17:16 <EvilTerran> solrize, it wouldn't make it impossible to type the rest of the program, but you might make a lot of things made undefined in the process
18:17:16 <tromp> that's like asking, if i fix one bug, is the result generally bugfree?
18:17:17 <MyCatVerbs> solrize: personally I prefer unsafeCoerce = const (error "OI! YOU! GET BACK IN THE TYPE SYSTEM!")
18:17:17 <solrize> mycatverbs, yeah, i'm just wondering if having undefined terms in important places is likely to leave everything else excessively polymorphic
18:17:26 <solrize> evilterran, yeah, that's what i mean
18:17:38 <solrize> the idea otherwise seems pretty obvious
18:17:48 <solrize> i have a lot of trouble figuring out ghc error messages sometmies
18:18:04 <solrize> and i end up putting annotations all over the place to narrow down the problem
18:18:08 <EvilTerran> certianly, i've heard an idea to replace type mismatches with error "type <...> found, <...> expected at $line"
18:18:30 <solrize> ghc already has messages that are basically like that.  the question is why did it expect <...>
18:18:40 <solrize> i.e. what did it infer for the nearby terms?
18:18:54 <EvilTerran> mmhmm
18:19:02 <tromp> it generally helps to annote the functions in question yourself
18:19:40 <solrize> tromp, yeah, i find i have to break apart expressions in order to annotate individual terms in them, etc.
18:19:55 <EvilTerran> i meant replacing the type error at compile time with an undefined term of the right type, ie a call to "error" detailing the location and mismatch
18:20:10 <tromp> i find that annotating all toplevel expressions usually suffices
18:20:16 <EvilTerran> but it seems that's not what you're talking about
18:20:29 <solrize> evilterran, oh, i see what you mean, yeah, i've seen that suggested but it doesn't seem that useful.
18:33:23 * SamB wonders if anyone knows of some good Coq resources...
18:34:05 * SamB knows it's off-topic, but doesn't want to get beat up by smerdy in #coq...
18:34:49 <SamB> ChanServ: perhaps you might know of some nice Coq resources?
18:34:56 <SamB> or maybe roconnor ?
18:42:07 <ivanm> SamB: why would ChanServ know anything?
18:42:20 <ddarius> ChanServ knows all.
18:42:46 <ivanm> just doesn't talk much...
18:42:55 <lambdabot> ChanServ: How many fingers am I holding up?
18:44:49 <SamB> ivanm: 'twas a joke
18:44:55 <SamB> ChanServ is in #coq, see ;-)
18:45:08 <ivanm> ChanServ gets around
18:45:10 <SamB> and also here
18:45:18 <SamB> as is roconnor
18:45:51 <dolio> SamB's humor is too avant-garde.
18:46:13 * SamB wishes he knew more french
18:46:24 <dolio> I don't know French.
18:46:35 <dolio> I've just read every Calvin and Hobbes strip ever.
18:46:51 <SamB> @dict-all avant-garde
18:46:51 <lambdabot> Unknown command, try @list
18:46:57 <SamB> @web19 avant-garde
18:46:59 <lambdabot> No match for "avant-garde".
18:47:05 <SamB> @wordnet avant-garde
18:47:07 <lambdabot> Unknown command, try @list
18:47:14 <SamB> @help dict
18:47:15 <lambdabot> I perform dictionary lookups via the following 13 commands:
18:47:15 <lambdabot> all-dicts ... Query all databases on dict.org
18:47:15 <lambdabot> devils ...... The Devil's Dictionary
18:47:15 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
18:47:15 <lambdabot> elements .... Elements database
18:47:16 <lambdabot> [9 @more lines]
18:47:19 <SamB> @dict
18:47:19 <lambdabot> Supported dictionary-lookup commands:
18:47:20 <ddarius> @babel fr en avant garde
18:47:21 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
18:47:22 <lambdabot> Use "dict-help [cmd...]" for more.
18:47:24 <lambdabot>   before guard
18:47:34 <SamB> ddarius: that did NOT help
18:47:43 <ddarius> SamB: I blame the French.
18:47:43 <ivanm> what? lambdabot's help is actually _helpful_ now? :o
18:47:49 <SamB> @all-dicts avant-garde
18:47:49 <lambdabot> *** "avant-garde" gcide "The Collaborative International Dictionary of English v.0.48"
18:47:49 <lambdabot> avant-garde \a*vant`-garde"\ ([.a]*v[aum]nt"-g[aum]rd`), a.
18:47:49 <lambdabot>    1. Of, pertaining to, or belonging to the avant-garde.
18:47:49 <lambdabot>       [PJC]
18:47:49 <lambdabot>  
18:47:51 <lambdabot> [20 @more lines]
18:47:55 <ivanm> ddarius: yeah.... and what are they doing in England?
18:47:57 <SamB> that does not help either
18:48:00 <ivanm> :p
18:48:08 <SamB> @web avant garde
18:48:09 <lambdabot> *** "Avant" web1913 "Webster's Revised Unabridged Dictionary (1913)"
18:48:09 <lambdabot> Avant \A*vant"\, n. [For avant-guard. Cf. {Avaunt}, {Van}.]
18:48:09 <lambdabot>    The front of an army. [Obs.] See {Van}.
18:48:09 <lambdabot> No match for "garde".
18:48:29 <ddarius> SamB: lambdabot mocks you
18:48:34 <SamB> ah, front guard?
18:49:32 <ddarius> Now You Know
18:51:13 <dolio> SamB: You're like an off-off-Broadway show that we're all too mainstream to appreciate.
18:51:26 <SamB> dolio: what, you ?
18:51:29 <SamB> mainstream?
18:51:50 <SamB> I daresay you do yourselves a disservice to consider yourselves as mainstream ;-)
18:52:08 <SamB> ... despite the climbing channel membership...
18:52:34 <dolio> Is it climbing these days?
18:52:35 <dolio> @users
18:52:35 <lambdabot> Maximum users seen in #haskell: 468, currently: 419 (89.5%), active: 10 (2.4%)
18:52:41 <dolio> We're well below maximum.
18:55:14 <eu-prleu-peupe1> when i learn haskell i will definetly be a smarter person
18:55:24 <dolio> Maybe Haskell's popularity is tapering off.
18:55:32 <dolio> And we'll be able to change ($) after all.
18:55:42 <dibblego> the scaredy cats came and went
18:55:48 <saml> type Subst = [(String, Type)];  newtype TI a = TI (Subst -> Int -> (Subst, Int, a));   getSubst = TI (\s n -> (s, n, s));     how come getSubst :: TI Subst ??
18:55:51 <eu-prleu-peupe1> my friends seem to prefer lisp and ruby over haskell though
18:56:02 <dibblego> eu-prleu-peupe1, do they know what Haskell is?
18:56:37 <dolio> :t (&)
18:56:38 <lambdabot> Not in scope: `&'
18:57:53 <dolio> > let infixl 9 & ; f & x = f x in (f :: Expr -> Expr -> Expr) & g x & h y
18:57:54 <lambdabot>  f (g x) (h y)
18:58:32 <eu-prleu-peupe1> isnt it a programming language ?
18:59:00 <dibblego> eu-prleu-peupe1, anyone can say that; I mean are they qualified to comment on what they think they prefer? quite often (in my observations), it's not the case
19:00:03 <eu-prleu-peupe1> nobody really is
19:00:06 <glguy> especially when they think they prefer ruby?
19:00:12 <dibblego> yeah, especially that :)
19:00:34 <eu-prleu-peupe1> ruby is better than haskell for web programming
19:00:44 <dibblego> eu-prleu-peupe1, usually, it's a bubble of ignorance, not a meaningful comment to make
19:01:06 <dibblego> eu-prleu-peupe1, nonsense; Ruby is not suited for web programming at all
19:01:30 <dibblego> we'll be rewriting our Ruby web application soon (thank goodness)
19:01:35 <eu-prleu-peupe1> well it surelly managed to fool a lot of people
19:01:41 <dibblego> sure, so has Java
19:01:53 <eu-prleu-peupe1> but java is cool for enterprise stuff
19:02:00 <tromp> dont forget php
19:02:00 <eu-prleu-peupe1> struts2
19:02:02 <dibblego> what is "cool" is not under discussion
19:02:13 <dibblego> I'm aware of industry trends and what is popular
19:02:22 <dibblego> we're talking about what is good for programming
19:02:28 <eu-prleu-peupe1> and haskell can make a go in web programming ?
19:02:32 <dibblego> sure
19:02:36 <eu-prleu-peupe1> with what ?
19:02:41 <dibblego> Haskell
19:02:41 <eu-prleu-peupe1> there aint even a mod_haskell
19:02:46 <eu-prleu-peupe1> for apache
19:02:51 <dibblego> why would you want that?
19:03:20 <ddarius> @google mod_haskell
19:03:22 <lambdabot> http://losser.st-lab.cs.uu.nl:8080/
19:03:22 <lambdabot> Title: Welcome to losser.st-lab.cs.uu.nl
19:03:26 <eu-prleu-peupe1> i would want that so i can use my fav web server
19:03:35 <dibblego> Haskell does not appeal to emotions
19:03:40 <dibblego> it's more interested in solving programming tasks
19:03:54 <eu-prleu-peupe1> ok
19:03:54 <glguy> eu-prleu-peupe1: you can use your favorite web server with Haskell via fastcgi
19:04:01 <eu-prleu-peupe1> so ill just write an entire web server
19:04:11 <eu-prleu-peupe1> why not just code the OS, since im on to it ...
19:04:12 <eu-prleu-peupe1> :P
19:04:13 <dibblego> Haskell composes because it is pure and lazy
19:04:13 <eu-prleu-peupe1> News                 18 Apr 2002:
19:04:27 <dibblego> writing an "entire web server" is not that hard
19:04:35 <dibblego> and importantly, once you've done it, you don't do it again
19:04:40 <eu-prleu-peupe1> ya
19:04:45 <eu-prleu-peupe1> but mod_cgi is slowwwwww
19:04:47 <dibblego> in fact, others have already done it for you
19:05:22 <ddarius> and the operating system
19:05:33 <ddarius> Well, "systems" these days
19:06:01 <glguy> eu-prleu-peupe1: sure, but fastcgi is fastttt
19:06:32 <ddarius> eu-prleu-peupe1: If you don't want to use Haskell, no one is forcing you.
19:09:15 <dolio> > let infixl 9 & ; f & x = f x in catchError & do { throwError & strError "foo" } & \e -> return 5 :: Either String Int
19:09:16 <lambdabot>   Not in scope: `strError'
19:10:41 <dolio> Is haskell.org down?
19:10:59 <dibblego> working for me
19:11:13 <eu-prleu-peupeu> anyway
19:11:20 <eu-prleu-peupeu> what options do i have for haskell on the web ?
19:11:22 <dolio> Oh, yeah, it's working here now, too. Must have been a momentary hiccup.
19:11:24 <eu-prleu-peupeu> is there any framework ?
19:11:26 <eu-prleu-peupeu> like rails ?
19:11:38 <dibblego> there are others, unlike rails, thankfully
19:11:41 <dibblego> such as HAppS
19:11:43 <dibblego> and Hope
19:11:49 <eu-prleu-peupeu> Hope
19:12:04 <dibblego> ?where Hope
19:12:04 <lambdabot> http://hope.bringert.net/
19:13:26 <eu-prleu-peupeu> what i really dont like about these haskell stuff, is the documentation
19:13:28 <eu-prleu-peupeu> or the lack of...
19:13:37 <dibblego> and you prefer Ruby?
19:13:45 <eu-prleu-peupeu> no, i prefer C
19:13:57 <dibblego> Haskell's type system provides a lot of documentation
19:14:13 <dibblego> it's just not written in English, which is preferable
19:14:36 <eu-prleu-peupeu> yes, but im not a biological haskell parser
19:14:42 <eu-prleu-peupeu> so i prefer to read documentation
19:14:57 <eu-prleu-peupeu> before i decide whether to try or not to try
19:15:00 <dibblego> that's slow. cumbersome and error prone
19:15:25 <dibblego> I'm not sure you "prefer" it; you're just not yet ready for alternatives
19:16:01 <dibblego> "forall a. a -> a" that is great documentation
19:16:04 <eu-prleu-peupeu> okey... ill look into crazy monads and arrows and what else may come and read thousands of academic papers written by people who never left the university
19:16:11 <eu-prleu-peupeu> then i think ill be ready
19:16:22 <glguy> eu-prleu-peupeu: oops, you've gone right off the other end
19:16:25 <dibblego> you jump around a lot
19:16:50 <eu-prleu-peupeu> so i prefer to read documentation in english
19:16:55 <dibblego> no you don't
19:17:00 <dibblego> you just don't know there are alternatives
19:17:24 <eu-prleu-peupeu> haskell being one of them, right ?
19:17:28 <SamB> I prefer to read documentation in english as well
19:17:37 <dibblego> you can't say you prefer anything, if you're not aware of what you're comparing to
19:17:49 <SamB> I find I don't get much out of documentation written in german, french, or especially japanese...
19:18:25 <Pseudonym> I get a lot out of automatically-translated Japanese.
19:18:31 <Pseudonym> aka Engrish
19:18:59 <eu-prleu-peupeu> i like ocaml
19:19:04 <eu-prleu-peupeu> i has good documentation
19:20:29 <glguy> i can has cheezburger?
19:20:40 <sjanssen> glguy: only if you troll
19:20:43 <eu-prleu-peupeu> :D
19:21:02 <glguy> sjanssen: *sigh* fine, I'll start trolling
19:21:07 <glguy> (though I'd prefer just to have one)
19:21:38 <jaredj> http://hpaste.org/7242
19:22:04 <jaredj> OI YOU THERE GET OUT O MY SIGHT
19:22:35 * jaredj drinks a glass of water. troll impressions are taxing on the throat
19:23:01 <sjanssen> jaredj: I think you could use Show here
19:23:38 <zeno_> some guy at my college did a paper on trolling as an art =p
19:23:39 <jaredj> oo
19:23:45 <jaredj> er
19:23:50 <dolio> He's parsing, isn't he? Not printing.
19:24:08 <jaredj> yes, but show POS == "POS"; that's something to go on perhaps
19:24:20 <zeno_> it was at least partly satire but the prof loved it lol
19:25:03 <zeno_> http://cale.yi.org/index.php/Fold_Diagrams wow that really helped me
19:25:04 <lambdabot> Title: Fold Diagrams - CaleWiki
19:25:23 <zeno_> although it seems foldr is folding to the LEFT and vise versa...
19:25:47 <dolio> Although I guess those are all 'do { string (show t) ; return t }'
19:26:08 <dolio> More or less.
19:26:14 <sjanssen> jaredj: how does that look?
19:26:21 <glguy> zeno_: foldr starts at the right and moves left (in one way of looking at it)
19:26:39 <zeno_> glguy: thats not confusing to you :?)
19:26:46 <zeno_> seems they should swap names
19:26:59 <glguy> > foldr f z [a,b,c]
19:27:01 <glguy> ?bot
19:27:01 <lambdabot> :)
19:27:04 <lambdabot>  f a (f b (f c z))
19:27:34 <zeno_> i know how it works now, but it just seems untuitive for new users
19:28:26 <zeno_> learned figuring out how to make foldl act like foldr at the end
19:28:55 * SamB tries to prove the 2nd arrow law from laws 1 and 3-9
19:29:03 <zeno_> > foldl (flip f) (last [1, 2, 3]) (init [1, 2, 3])
19:29:04 <lambdabot>  Add a type signature
19:29:14 <zeno_> > foldl (flip f) (last [1, 2, 3]) (init [1, 2, 3]) :: Expr
19:29:15 <lambdabot>  f 2 (f 1 3)
19:29:28 <zeno_> nvr mind i had it earlier =p
19:29:47 <zeno_> > foldl (flip f) (g (last [1, 2, 3])) (init [1, 2, 3]) :: Expr
19:29:48 <lambdabot>  f 2 (f 1 (g 3))
19:44:44 <SamB> User error: The "at" syntax isn't available yet for the rewrite/replace tactic
19:44:51 * SamB thinks that looks more like implementor error!
19:46:55 <jaredj> sjanssen: supper :: IO [mmm]
19:49:56 <dolio> SamB: I've gotten a user error before.
19:50:04 <dolio> http://hpaste.org/6471
19:50:24 <jaredj> sjanssen: wewt! it works
19:50:54 <dolio> Or is that a Coq user error?
19:51:03 <dolio> Yours, that is.
19:52:09 <jaredj> sjanssen: oh, you commented. yours is nicer looking
19:52:16 <SamB> dolio: indeed
19:52:47 <dolio> I guess the fact that it wasn't a bunch of intermediate language looking giberish was the clue that it wasn't jhc. :)
19:52:55 <dolio> And "tactic" of course.
19:53:36 <SamB> yeah, I think I've only used one unicode character in this file actually
19:54:12 <SamB> namely "·", as in "f · g"
19:54:16 <jaredj> hmm
19:54:23 <jaredj>             where enumParser en = do try . string $ show en
19:54:23 <jaredj>                                      return en
19:54:29 <SamB> because . was taken already
19:54:44 <jaredj> can't i make that into a >>=?
19:54:57 <sjanssen> a >>, more likely
19:55:24 <jaredj> i want the value though..
19:57:39 <jaredj> ah -
19:57:42 <jaredj> :t \x -> do { try . string $ show x; return x }
19:57:44 <lambdabot> Not in scope: `try'
19:57:44 <lambdabot> Not in scope: `string'
19:57:50 <jaredj> dooh
19:57:59 <jaredj> anyway try . string . show is the same type
19:59:13 <jaredj> oh oops no it's not
20:00:43 <sclv> eu-prleu-peupeu: sorry I'm late to the game here, but use hvac!
20:01:04 <sclv> limited documentation, but no funny arrows and all that, just nice clean simple dispatch and templating at on-the-metal speed.
20:01:21 <sclv> plus sexy controller combinators, and atomicity!
20:02:12 <sclv> c'mon, give ol' Gil's framework a chance.
20:02:30 <eu-prleu-peupeu> :)
20:02:34 <eu-prleu-peupeu> ok
20:09:51 <zeno_> is there a haskell-specific ide?
20:10:20 <darinm> sort of
20:10:35 <darinm> but it depends on what you mean by "haskell-specific" exactly
20:11:00 <dolio> There's leksah, but that's in progress.
20:11:23 <darinm> there's also yi, but I don't know how usable it is
20:11:36 <darinm> and there used to be visual haskell on windows, don't think it's up to date though
20:11:43 <dolio> I don't think yi counts as an IDE.
20:11:47 <dolio> Yet, anyway.
20:12:14 <darinm> yeah, maybe not
20:12:47 <solrize> http://shinola.org/shinola_pages/posts/free-hans-t-shirts175.php?p=20  sheesh
20:12:48 <lambdabot> Title: ..::shinola:dot:org::.. - New Shinola, http://tinyurl.com/6lsot4
20:15:34 <sclv> zeno_: emacs' haskell-mode has lots of ide-like features.
20:20:55 <pavizard> >?
20:22:50 <zeno_> thanks all :) i really just want 1. hightlighting 2. autocomplete, 3. the function eclipse has that highlights compilation errors
20:23:15 <zeno_> oh and 4. a click to go to function thing :)
20:23:26 <gwern> @where collections
20:23:26 <lambdabot> I know nothing about collections.
20:23:38 <zeno_> ill try out emacs'haskell-mode, thanks
20:23:46 <solrize> it would REALLY be nice to be able to float the mouse over a term and see it's type
20:23:58 <zeno_> ooo yeah that would be nice too
20:26:51 <zeno_> dolio: does leksah have any of those?
20:27:08 <dolio> It has highlighting, and pretty printing of certain operators.
20:27:18 <dolio> Not sure about the rest. I haven't used it much.
20:51:47 <sclv> zeno_: you get the forst for free with emacs, the second with hippie-expand and friends, and you can get the third with flymake haskell mode, but I find its more trouble than its worth due to the way haskell errors work
20:52:05 <sclv> i.e. with type problems you only really get one useful error at a time.
20:52:10 <sclv> at least the way I code.
20:52:18 <mrd> and you can hit C-x ` to jump to it
20:52:55 <SamB> hmm, if I did this right, Coq agrees with Lindly, Wadler, and Yallop...
20:53:00 <sclv> haskell-mode also shows types of functions you've defined with types, and can insert inferred type signatures.
20:53:06 <SamB> the second arrow law really is redundant.
20:53:17 <gwern> did you know Irix is being EOL'd? one less unix to worry about porting stuff to!
20:53:18 <sclv> but it doesn't interface in any fancy way to give partial typing.
20:53:36 <gwern> sclv: the prolem with flymake is that it litters your system with files and looks butugly
20:54:04 <sclv> its also not worth the effort when you have a nice repl like ghci.
20:54:15 <sauxdado> you know you're a functional programmer when you misspell contact as concat
20:55:59 <SamB> ... and your spellchecker doesn't catch it
20:57:07 <gwern> or it suggests 'concatMap' for your misspelling 'concat $ map'
20:57:34 <SamB> gwern: but that isn't a misspelling
20:57:45 <SamB> that's two valid words and a punctuation mark
20:57:46 <dolio> Who uses concat, anyway?
20:58:00 <dibblego> people who don't want to join in, haha!
20:58:03 * gwern does
20:58:26 <gwern> I find it more readable than abusing list monad stuff!
20:58:37 <SamB> indeed
20:58:53 <dolio> @type concat
20:58:55 <lambdabot> forall a. [[a]] -> [a]
20:58:59 <SamB> my main reason to avoid using it would be if I were using concatMap
20:59:01 <dolio> Cale hasn't gotten to that one, eh?
20:59:15 <gwern> maybe lambdabot crashed again
20:59:17 <SamB> what do you mean?
20:59:19 <sclv> ?ty (++)
20:59:21 <lambdabot> forall m. (Monoid m) => m -> m -> m
20:59:24 <sjanssen> dolio: ssh, he'll hear you
20:59:40 * gwern supposes it's a good thing we no longer promote lambdabot as an exampler of things haskelly
20:59:45 <dolio> concat shoudl be (Foldable t, Monoid m) => t m -> m, clearly.
20:59:53 <SamB> dolio: that's true, you shouldn't spell his name out plaintext like that
20:59:57 <zeno_> whats wrong with lambdabot?
21:00:08 <SamB> zeno_: what do you mean?
21:00:09 <sclv> its like beetlejuice.
21:00:16 <dolio> What if I want him to hear me? :)
21:00:27 <zeno_> hows it "not haskelly"
21:00:43 <SamB> zeno_: well, Cale keeps replacing bits of Prelude...
21:00:48 <gwern> zeno_: well, it crashes, for starters
21:00:50 <sjanssen> zeno_: lambdabot is full of cruft and half finished rewrites
21:01:01 * gwern thinks that pretty much says it right there; all the rest is footnotes
21:01:05 <zeno_> ah ok
21:01:06 <SamB> ... and not writing a library package
21:04:26 <zeno_> is this not legal? class X g where;method1 :: (Y s) => g -> s
21:04:46 <zeno_> i keep getting Ambiguous type variable `s' in the constraint
21:05:05 <zeno_> arising from a use of `check' (at some other line)
21:05:52 <SamB> @paste
21:05:52 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:06:55 <dolio> It's legal, otherwise you'd be getting an error at the line where method1 is.
21:07:00 <zeno_> http://hpaste.org/7244
21:07:34 <zeno_> ghci output: http://hpaste.org/7245
21:09:32 <zeno_> adding a type signature to check didnt help
21:09:46 * SamB wonders if these erasers with "A&W" on them are root-beer flavoured
21:11:49 <dolio> zeno_: You're creating a game state and then using it without ever specifying what concrete type it should have.
21:12:17 <dolio> So, GHC claims that it's ambiguous.
21:12:27 <dolio> Instead of picking one arbitrarily or something.
21:12:59 <solrize> so now that the UTF8 module is on hackage, what's missing from the bytestring/utf8 combination that we're waiting for UnicodeString for?
21:13:16 <solrize> well, other encodings, i guess... anything else?
21:13:23 <zeno_> dolio: i want this to work for any GameState, not just one
21:14:12 <dolio> I don't think the types say what you wan them to say.
21:14:52 <dolio> 'startingState :: (GameState s) => g -> s' says that, given a g, it can generate any type of s, so long as it's a GameState.
21:15:29 <dolio> Where the caller chooses the concrete instantiation of s.
21:17:20 <zeno_> well, depending on what instance of Game, it will generate a different GameState from startingState ya
21:17:50 <dolio> So when you do, say, 'getStatus (startingState g)', you have '(Game g) => g -> GameStatus', which goes through a GameState s, but there's nothing that sets the intermediate type.
21:18:27 <dolio> zeno_: Then the type of startingState is wrong.
21:18:56 <dolio> What version of GHC are you running?
21:19:06 <zeno_> 6.8.somethign
21:19:36 <dolio> Well, there are two ways I can think of to get the right type.
21:19:37 <bos> @seen dons
21:19:38 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc and #haskell. I last heard dons speak 1h 50m 45s ago.
21:20:26 <dolio> One is to use existential types, to give startingState a type of, essentially, 'startingState :: exists s. GameState s => g -> s'.
21:20:46 <zeno_> getStatus (StartingState g) is of type (GameState g) => g -> GameStatus
21:20:47 <dolio> Or, to give each Game an associated type of GameState.
21:21:25 <zeno_> ah ok thanks
21:21:42 <dolio> Which you can do with functional dependencies or actual associated types in 6.8.
21:25:19 <cjs> Whee.
21:26:25 <dolio> http://hpaste.org/7244#a1
21:30:48 <zeno_> so i can use either?
21:31:13 <dolio> Associated types are more likely to be what you want, if I had to guess.
21:33:59 <zeno_> what does the first one do?
21:34:08 <zeno_> (man i guess i need to read up more on the type system)
21:35:23 <zeno_> thx a ton btw
21:39:13 <dolio> The first one does the same thing as the second one, only with an older type system extension.
21:41:04 <zeno_> ah ok, yeah the first one compiles, im guessing thats Associated Types right?
21:41:19 <dolio> The first one is functional dependencies.
21:41:41 <sclv> ooh -- just came up with a cool way to implement file r/w locks in stm.
21:44:11 <cjs> Hey, what's the refactoring called when you take a function from the top level and move it to a let or where within another function?
21:45:17 <zeno_> changing scope? (a guess)
21:46:30 <cjs> Hm. "Scope move."
21:48:38 <int-e> cjs: float in? (ghc calls the opposite floating out)
21:49:14 <SamB> JHC does both things
21:51:53 <cjs> Is there a standard vocabulary for this stuff, maybe a catalog of it somewhere?
21:53:08 <cjs> Hm. The book http://www.amazon.com/Advanced-Functional-Programming-International-Lectures/dp/3540285407/ has a paper called Refactoring Functional Programs, which seems a little odd for a book with "Advanced" in the title.
21:53:16 <lambdabot> http://tinyurl.com/5bwxfh
21:54:13 <zeno_> ghc can refactor stuff?
21:54:30 <cjs> I think ghc calls it "optimization." :-)
21:57:34 <cjs> Hm. I wonder if "push down function" makes sense, to parallel "push down method."
21:58:50 <Heffalump> I think that's a reasonable name
21:59:11 <Heffalump> the AFP lectures tend to be a bit of a mishmash of topics
21:59:28 <Heffalump> being in practice based on current research rather than a coherent curriculum
22:02:05 <cjs> Refactoring doesn't strike me as an "advanced" topic, unless it's automated refactoring.
22:02:50 <cjs> Ah, there's HaRe, a Haskell refactoring too, and it's got a list of refactorings here: http://www.cs.kent.ac.uk/projects/refactor-fp/hare/README_16092004.txt
22:02:52 <Heffalump> I would guess that it was.
22:02:53 <lambdabot> http://tinyurl.com/6xfdfv
22:02:56 <Locky> DCC SEND startkeylogger 0 0 0
22:03:26 <Heffalump> almost certainly it was given by the HaRe people
22:03:34 <Heffalump> almost certainly it was given by the HaRe people
22:03:50 <cjs> Given that it's in their README, I'd guess so. :-)
22:09:28 <dibblego> does lambdabot have a rot13 or similar function?
22:09:39 <dibblego> to give an obfuscated answer to a noob question
22:10:42 <sauxdado> not sure how that's useful
22:11:01 <dibblego> because they can cheat if they want to, but not by force
22:11:08 <cjs> Especially when the n00b quesiton is, "How do I write a rot13 decoder in Haskell?" :-)
22:11:29 <sauxdado> just don't give them the direct answer
22:11:37 <sauxdado> make them beg for it
22:11:42 <sauxdado> then they can cheat by begging :)
22:12:13 <SamB> would be cool if you could give them an rot13-encoded rot13 implementation that would work as the identity function ...
22:12:29 <SamB> (before they managed to decode it, I mean)
22:13:19 <solrize> i think there is a way to do it with hylomorphisms
22:13:43 <solrize> ;)
22:13:45 <SamB> solrize: I don't think hylomorphisms would help
22:14:01 <SamB> you'd effectively need to write a polyglot
22:15:25 <sarehu> nah
22:15:37 <sarehu> you just need a few extra names for things
22:15:54 <sarehu> znc = map
22:15:58 <solrize> http://www.willamette.edu/~fruehr/haskell/evolution.html#comonadic   something like this maybe
22:15:59 <lambdabot> Title: The Evolution of a Haskell Programmer, http://tinyurl.com/3swhu
22:18:16 <cjs> Ok, after reading a lot of source code, I figured out that it's called "demoting (a function)".
22:40:29 <solrize> demoting??
22:41:03 * ski_ . o O ( .. `startingState :: g -> exists s. GameState s *> s' ..)
22:43:06 <allbery_b> <cjs> Hey, what's the refactoring called when you take a function from the top level and move it to a let or where within another function?
22:43:15 <allbery_b> (for solrize)
22:43:27 <solrize> oh
22:43:31 <solrize> ic thanks
22:44:03 <solrize> lambda lifting in reverse
22:44:05 <solrize> lambda lowering
22:44:41 <cjs> Hm? I'm not sure about that, this is about scoping; when I hear "lifting," I think monads.
22:45:24 <solrize> lambda lifting means getting all the functions to the top level for ease of compilation
22:45:31 <allbery_b> cjs: hence *lambda* lifting
22:45:44 <ivanm> cjs: strange, when I hear "lifting" I think of someone picking something heavy up :p
22:45:56 * cjs bricks ivanm
22:46:30 <allbery_b> .oO { brainwashing? }
22:46:40 <ivanm> nah, I've got enough bricks out back thanks
22:46:54 <cjs> Hm. Actually, they do use "lift one level" and "lift to top level" as refactoring names.
22:46:57 <ski_> `\x -> \y -> x*x + y*y' => `let f = \(xx,y) -> xx + y*y) in \x -> (x*x,f)'
22:46:59 * Cale wakes up and does some lambda push-ups
22:47:18 <cjs> I wonder why "lift" instead of "promote", or "demote" instead of "drop"?
22:48:25 <solrize> lifting is a traditional math word
22:48:49 <solrize> http://en.wikipedia.org/wiki/Lift_%28mathematics%29
22:49:15 <dibblego> ?type \x y -> any (\x' -> any (x' ==) y) x -- can this function be written to be more efficient (does it require Ord?)?
22:49:17 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
22:49:58 <solrize> what is that doing?
22:50:13 <dibblego> checks if the two lists intersect anywhere
22:50:18 <Cale> Checking if any element of x is equal to any element of y.
22:50:38 <solrize> if it's ord you can use sets
22:51:02 <Cale> Right.
22:51:08 <Cale> Which is asymptotically faster.
22:52:24 <cjs> solrize: That stuff still makes my head hurt, and I've been re-reading the first chapter of my category theory book every other month  for like a year now.
22:52:32 <solrize> if you can  hash the items you can use data.hash
22:53:22 <Cale> It can be really hard to approach category theory if you don't have a lot of examples under your belt.
22:53:53 <Cale> Category theory is sort of the game which mathematicians play with other branches of mathematics as the building blocks. :)
22:53:55 <solrize> cjs, the haskell wikibook article on category theory is a good starting point
22:55:46 <solrize> wow i had no idea that the hensel lifting algorithm was from the early 1900's.  i thought it was from the macsyma era.
22:56:47 <solrize> in fact it's about rootfinding in p-adic fields.  i thought it had something to do with multivariate factoring.
22:56:48 <Cale> The one about polynomials?
22:56:56 <solrize> i'm looking at wikipedia
22:57:12 <solrize> i had a class where they went over it but i sort of slept through it or something
23:04:01 <Cale> solrize: Well, it appears the multivariate extension is what is new.
23:04:22 <cjs> solrize: Yeah, that book is on my list of ones to go through in the near future.
23:04:41 <cjs> At least I've figured out the Maybe monad. :-)
23:05:46 <Cale> solrize: Er... oh, that was done by Bourbaki, so not quite "new" per-se.
23:06:51 <solrize> interesting
23:07:04 <solrize> too hairy for me really though
23:09:50 <Cale> Yeah, it sneakily involves some concepts from algebraic geometry to really understand the context, it seems. I'm not awake enough for it :)
23:15:44 <solrize> l8r
23:54:51 <paolino> @type flip const
23:54:52 <lambdabot> forall a b. b -> a -> a
23:56:26 <ski_> @type const id
23:56:28 <lambdabot> forall a b. b -> a -> a
23:57:04 <paolino> same meaning ?
23:58:47 <ski_> @check \(x :: Int) (y :: Bool) -> flip const x y == const id x y
23:58:48 <lambdabot>  Parse error in pattern at "(y" (column 13)
23:59:15 <ski_> @check \x y -> flip const x y == const id (x :: Int) (y :: Bool)
23:59:17 <lambdabot>  OK, passed 500 tests.
23:59:34 <vixey> @src flip
23:59:34 <lambdabot> flip f x y = f y x
23:59:37 <vixey> @src const
23:59:38 <lambdabot> const x _ = x
23:59:40 <vixey> @src id
23:59:41 <lambdabot> id x = x
