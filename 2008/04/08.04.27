00:02:51 <newsham> visof: works for me in freebsd.
00:18:51 <visof_> newsham install it from source code?
00:19:00 <newsham> visof: yes.
00:19:35 <visof_> newsham okay, thanks
00:24:53 <OceanSpray> I've been trying to use yi, but to no avail.
00:25:23 <DuClare> Hmm.  Can I write my own 'showFoo' function and instance it like 'instance Show MyFoo where show = showFoo' ?
00:25:36 <lament> yes.
00:25:40 <lament> just don't derive show as well
00:25:40 <DuClare> Cool. :)
00:26:18 <geezusfreeek> ah, i love that feeling you get after you fuss over a problem, make a big deal about it, and then suddenly discover that one simple pretty solution that should have been obvious the whole timeâ€¦ no wait, i don't love that feelingâ€¦ why the heck did it take me so long to get this?!
00:26:38 <lament> because you're really stupid :D
00:26:52 <DuClare> Although since I'm doing it for printing something neat,  I wonder if it's just better to leave show as it is (and derive), and instead create sth like printFoo :o
00:26:54 <geezusfreeek> you're a regular motivational speaker
00:27:07 <lament> DuClare: yes.
00:27:21 <lament> DuClare: show/read is for serialization of data structures, as i understand
00:27:29 <geezusfreeek> eh
00:27:43 <geezusfreeek> generally show/read is basically for what you would do in GHCI and such
00:28:19 <geezusfreeek> you could use it for other purposes, but most of the time you want show/read to work with strings that reflect the haskell code that would build the structure
00:28:32 <lament> right
00:28:36 <lament> which you achieve by deriving
00:28:40 <geezusfreeek> right
00:28:41 <DuClare> Yeah, I figured that show normally prints out something that could be used in code, not something pretty & formatted you'd use as final output
00:28:44 <DuClare> Yeah.
00:28:51 <geezusfreeek> which meansâ€¦ i rarely have a reason to derive show/read
00:29:02 <lament> for debugging
00:29:12 <geezusfreeek> *not to derive show/read
00:29:15 <lament> right
00:29:19 <geezusfreeek> i always leave out those key words
00:29:21 <lament> i assumed that's what you meant :)
00:29:27 <lament> hehe
00:29:51 <lament> the deriving thing is nice. It's description is a significant portion of the haskell report :D
00:29:56 <lament> *its
01:01:49 <quicksilver> does ghc 6.8.2 have subtly different defaulting rules to 6.6?
01:02:05 <quicksilver> I have some code which compiles under 6.6 but under 6.8 it has ambiguous type classes
01:02:17 <quicksilver> (involving Random and Num)
01:34:42 <vixey> Haskell has latent typing ../
01:34:46 <vixey> ?
01:49:25 <desegnis> wha, changing defaulting rules?
01:50:24 <quicksilver> desegnis: well, I'm not sure. Could be a bug, perhaps.
01:50:30 <quicksilver> (perhaps a bug in 6.6)
01:52:33 <desegnis> ah
01:54:35 <desegnis> vixey, it hasn't, unless you practice a very lax definition of latent typing
01:55:05 <vixey> I don't really have watertight definitions for any of the terms regarding typing in programming languages :/
01:55:22 <quicksilver> :t randomR
01:55:26 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
01:55:26 <desegnis> vixey, perhaps related Haskell concepts are type classes and type inference
01:55:41 <quicksilver> > randomR (0,10) (mkStdGen 0)
01:55:44 <lambdabot>  (0,40014 40692)
01:55:52 <quicksilver> ^^ that's the question, desegnis
01:56:01 <quicksilver> is it correct that that defaults to Int for (0,10), or not.
01:57:01 <desegnis> quicksilver, off-hand I'd say that defaulting to Int is the obvious thing to do here
01:57:15 <quicksilver> yes, but the report rules are subtle.
01:57:22 <desegnis> I'll have a look
01:57:32 <quicksilver> YOu're only allowed to default if all the type classes are Prelude type classes.
01:57:41 <quicksilver> So the question is, is Random a prelude type class
01:57:43 <quicksilver> I think it is
01:57:52 <quicksilver> in which case 6.6. is correct and 6.8 is buggy.
01:59:01 <DuClare> Can I somehow declare multiple types in one go, instead of putting each 'type x = c' on it's own line :o
01:59:15 <vixey> DuClare: No
01:59:19 <desegnis> quicksilver, wait, this sentence:
01:59:23 <DuClare> Okay
01:59:58 <desegnis> ... is defaultable if ... at least one of these classes is a numeric class, (that is, Num or a subclass of Num), and
02:01:00 <desegnis> do we have an implicit constraint due to the numeric literal, or are the constraints in the type signature for randomR the only constraints to consider?
02:03:14 <desegnis> Alright, I suppose we have a (Num a) constraint due to the literal, so please ignore this
02:03:53 <FordCortina> my yi darcs clone seems to need cabal 1.5.1 to build, but the latest i can find seems to be 1.3.10
02:04:45 <FordCortina> any idea where i can get 1.5?
02:05:16 <takamu> I have a problem with a little program I wrote: http://hpaste.org/7201?lines=true
02:05:33 <takamu> it's a program that implements an alarm
02:05:44 <takamu> but it doesn't work as expected
02:05:51 <Bourbaki> hidiliho
02:06:04 <takamu> can somebody see what is wrong?
02:06:36 <takamu> the user enters the time of the alarm in minutes
02:06:53 <takamu> if the time is reached, a bell rings, and the program stops
02:07:08 <takamu> but if the user presses enter, program stops
02:07:16 <takamu> that is the expected behaviour
02:07:37 <takamu> but the program continues running after the time has elapsed
02:08:19 <dmwit> Does putting 'main = system "aplay bell.wav"' work as expected?
02:08:32 <dmwit> (ie "main = ring")
02:08:39 <takamu> i will check
02:09:00 <takamu> now the bell rings, but only when user press enter
02:09:15 <takamu> let me compile
02:09:56 <takamu> yes, main = ring works
02:10:12 <dmwit> Huh.
02:10:35 <takamu> when user press enter after time has elapsed, the bell rings
02:10:47 <dmwit> I see from the comments that when you replace (system "...") with (putStrLn "ring"), everything works.
02:10:53 <takamu> yes
02:10:54 <dmwit> So I don't know where to point on this one.
02:11:10 <dmwit> Maybe aplay is waiting for input for some reason?
02:11:21 <takamu> mmm
02:11:34 <takamu> mplayer also has the same problem
02:11:46 <dmwit> mplayer requires a terminal.
02:11:48 <dmwit> =/
02:12:05 <dmwit> (i.e. you can't safely fork it from programs, etc.)
02:12:35 <dmwit> Try (system "echo ring"). ;-)
02:12:37 <takamu> ah
02:13:46 <DRMacIver> Hm. So the basics of my qdbm bindings seem to work, and now I'm thinking about how to expose the iteration functionality. I'd like to have it work as a sort of fold left with early abort interface, but I'm not sure how that should look in Haskell.
02:13:47 <takamu> it's really strange :S
02:13:58 <dmwit> takamu: I agree. *frown*
02:14:02 <DRMacIver> Any suggestions? Preferably not too arcane. :)
02:14:35 <dmwit> :t unfold
02:14:36 <lambdabot> Not in scope: `unfold'
02:14:42 <dmwit> ?hoogle unfold
02:14:43 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
02:14:43 <lambdabot> Data.ByteString.unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
02:14:43 <lambdabot> Data.ByteString.unfoldrN :: Int -> (a -> Maybe (Word8, a)) -> a -> (ByteString, Maybe a)
02:14:44 <takamu> is there some place on the wiki to put request for help?
02:14:59 <dmwit> Maybe you should write to haskell-cafe?
02:15:06 <takamu> yes, good idea
02:15:57 <DRMacIver> Hm. Using Maybe for the abort might work.
02:20:17 <desegnis> takamu, my first guess was to compile with -threaded as to avoid blocking, but that won't work either.
02:22:21 <takamu> I tried -threaded with forkOs, but the result is the same
02:26:42 <takamu> also, if I comment the keyPressed thread, it works fine
02:26:45 <quicksilver> dmwit: not true, by the way.
02:26:52 <quicksilver> dmwit: I have a haskell program which drivers mplayer quite happily.
02:27:40 <quicksilver> takamu: I haven't looked at your code yet, but when you run a process you must keep reading its stdout and stderr or it will lock up.
02:27:59 <takamu> oh
02:28:31 <takamu> i will try something
02:29:01 <quicksilver> hmm. however you're using system, not any of the clever subprocess commands.
02:29:15 <quicksilver> system is supposed to be synchronous.
02:29:19 <quicksilver> and simple.
02:29:57 <quicksilver> DRMacIver: doForEach :: (row -> IO Bool) -> IO ()
02:30:11 <quicksilver> DRMacIver: is the simplest such. The "row handling callback" can return false for an early exit.
02:30:26 <quicksilver> DRMacIver: things get successively more complex as you support more choices.
02:30:57 <quicksilver> doForEach :: statement -> (row -> IO Bool) -> IO ()
02:31:00 <quicksilver> is slightly more realistic
02:31:42 <DRMacIver> Yeah. I realise that's the most basic I can support, and I'll almost certainly include that, but I'd like to support some sort of chaining of values.
02:32:18 <DRMacIver> And actually the library doesn't support any sort of querying. It's an all or nothing thing. So no statements. :)
02:32:27 <DRMacIver> (If I get around to writing the Villa bindings it will, but this is just Depot)
02:32:37 <quicksilver> DRMacIver: MonadIO m => (row -> m Bool) -> m ()
02:32:51 <Heffalump> DRMacIver: have you looked at what Takusen does?
02:33:01 <quicksilver> DRMacIver: allows the callback to, e.g., store state by being a state monad.
02:33:07 <Heffalump> also, have you considered using IO exceptions for the early abort?
02:33:33 <DRMacIver> Heffalump: I was just looking at takusen but got sidetracked. I'll take another look.
02:33:42 <Heffalump> if you go with quicksilver's solution you don't need the Bool return since you could put an exception monad in the stack
02:34:07 <DRMacIver> And I sortof considered exceptions but thought that surely there must be a better approach. :)
02:34:36 <desegnis> takamu, actually I'd also suspect getLine of blocking globally
02:34:52 <takamu> Heffalump, I didn't tried IO Exceptions
02:35:06 <takamu> I will try
02:35:08 <quicksilver> getLine doesn't block.
02:35:14 <quicksilver> well, it's not supposed to.
02:35:21 <quicksilver> it blocks that thread, but not globally.
02:35:25 <quicksilver> unless something is broken somewhere.
02:35:32 <desegnis> hm yeah
02:35:34 <Heffalump> DRMacIver: I think exceptions are a very good of managing control flow.
02:35:37 <DRMacIver> ok
02:35:43 <Heffalump> it's just we are conditioned by languages where they are expensive not to use them
02:36:05 <vixey> I thought the problem was more like
02:36:07 <Heffalump> (they might well be expensive in Haskell too, I don't know, but I don't care :-)
02:36:19 <vixey> the exception systems in Java are not very expressive
02:36:33 <DRMacIver> Oh, I'm perfectly happy to  use them for control flow. It was more that it didn't feel very Haskelly. :)
02:36:35 <vixey> not everyone has seen e.g. the CL condition system
02:36:58 <olsner> but haskell exceptions are pretty much IO-only, right?
02:36:59 <DRMacIver> (After all, 90% of the code I write lives on the JVM, which has blindingly fast exceptions if you know what you're doing)
02:37:28 <DRMacIver> ok. Heathen question: What's the advantage of a stack of MonadIO plus some Exception monad. etc. over just doing it in IO?
02:37:33 <desegnis> quicksilver, but it will work if you omit the getLine call, so I suppose that getLine and system interfere in a bad way
02:38:20 <olsner> the debug printouts in VS make a notable dent in performance of the Xerces xml library, since it uses exceptions for control flow in its parser :P
02:38:32 <DRMacIver> (Actually, 90% is probably a conservatively low estimate)
02:39:05 <DRMacIver> I'm under the impression that .NET has particularly expensive exceptions
02:39:10 <Heffalump> yes, it does
02:39:10 <DRMacIver> Because they have to be able to travel through native code
02:39:15 <DRMacIver> Or something like that
02:39:36 <Heffalump> DRMacIver: same as the distinction between StateT IO and IORefs
02:39:38 <Heffalump> (roughly)
02:40:07 <FordCortina> how do i replace my working copy with a previous version in darcs? ( I dont want to change the repository/database)
02:40:07 <olsner> hmm, has anyone been working on a recursive monad (like the assembler monad) for LLVM code generation?
02:40:11 <DRMacIver> Ok. But what's the advantage of using StateT IO over using IORefs?
02:40:12 <Heffalump> in the exceptions case you have stronger type-checking (since you don't need to use dynamic exceptions) but there's more visibility
02:40:28 <Heffalump> in the state case you don't need to pass around the STRef token
02:40:30 <Heffalump> s/ST/IO/
02:41:01 <olsner> DRMacIver: maybe a StateT IO program would be rewritten into StateT m and then be extracted entirely from its I/O?
02:41:21 <olsner> which would be quite hard to do for an excessively IORef'd program
02:41:38 <DRMacIver> In the abstract, plausibly. In the specific, this code is *not* going to be extractable from IO. :)
02:42:34 <olsner> maybe if you also abstract the "inner" IO parts into some other thing
02:42:48 <DRMacIver> Hm
02:43:03 <DRMacIver> Actually, I take it back given that I remembered I had plans to do exactly that.
02:43:23 <olsner> but otoh, I'm not entirely sure of the gain in doing all this rewriting and abstraction :)
02:44:01 <DRMacIver> (I was thinking of bringing dbm operations into their own monad so that if/when I do the Villa bindings the operations can be made transactional)
02:45:10 <DRMacIver> I think I'm going to stick with the simplest approach I can for now. But I'll have a think about the different suggestions and may use one of them later. Thanks.
02:45:38 <desegnis> FordCortina, as for the cabal question, it seems that version is only available from darcs. Yi developers don't care about dependency hell :-/
02:45:54 <olsner> haskell is too concrete... every part of a haskell program should be trivially replacable by an isomorphic counterpart without rewriting the other stuff
02:47:09 <olsner> things like lists vs sequences and strings vs bytestrings and the lack of views... monad transformers are a step on the way I guess, but only does it for monads
02:47:12 <FordCortina> desegnis: yes I've got the darcs repo now. I'm just trying to work out how to revert the working copy to 1.5.1. (I suppose its not essential, i'm just curious about darcs)
02:48:09 <solrize_> what are views?  i've heard of them and sort of remember looking at some paper and not understanding it.
02:48:09 <olsner> what mtl does for control flow abstraction, we should have for all kinds of data structures
02:48:45 <olsner> solrize_: allowing data to be "viewed" as another kind of data (like sequences being viewable and pattern matched as lists)
02:49:01 <solrize_> hmm ok
02:49:52 <olsner> there's a page on the haskell prime wiki about it that I don't remember the link to
02:49:58 <desegnis> FordCortina: darcs get cabal -t 1.5.1 cabal-1.5.1
02:50:04 <desegnis> or similar
02:50:30 <desegnis> It will check out the specified tag into another directory
02:50:35 <FordCortina> desegnis: thanks
02:54:17 <StacyC> I've been toying around with overloading ordinary unary functions with combinator variants. http://hpaste.org/7202
02:55:16 <StacyC> It's just for fun but might be useful for building the odd DSL or two. I'm stumped with how to do something similar for functions of more than one argument
02:57:43 <StacyC> The code has my sketch of a BinaryCombinator type class and some instances but it fails even for application to non-functional arguments
03:06:37 <Baughn> StacyC: Well, multi-parameter typeclasses?
03:07:26 <Baughn> StacyC: You might try studying the examples. I haven't used them myself, so..
03:08:50 <StacyC> Yeah, I haven't studied them much. From all the options I had to add (FlexibleInstances, etc.) I can see I'm wading into dodgy territory.
03:09:47 <Baughn> How about if you say "add a b = add' (a,b)" instead, and put add' in the typeclass?
03:10:05 <Baughn> I suppose that's approximately what it's doing, but you might get rid of some extensions
03:12:05 <StacyC> Well the core idea I'm experimenting with is whether I can have expressions like:   [square 3, square double 3] be valid Haskell, so 'square' has be applicable to either a number or another function.
03:12:30 <StacyC> For 'add' that would mean trying to get [add 3 4, add double 3 4, add 3 double 4, add double 3 double 4] to work.
03:12:36 <vixey> why don't you just write square (double 3)
03:12:50 <StacyC> Yes, or square $ double 3
03:12:52 <Baughn> Or (square . double) 3?
03:13:03 <vixey> ummmmm
03:13:03 <Baughn> You /could/, but I suppose that would defeat the purpose of the exercise. ;)
03:13:10 <StacyC> It's not about getting the result, it's about experimenting with expressing things differently.
03:13:35 <vixey> I still don't understand -why-
03:13:53 <Baughn> @let plus a b = a+b
03:13:54 <lambdabot> Defined.
03:14:04 <Baughn> ...hey, lambdie's back. And cheiron's gone. Drat.
03:14:27 <Baughn> > (+) $ 2 $ 3
03:14:28 <lambdabot>   add an instance declaration for (Num (a -> b))
03:17:01 <visof> ping newsham
03:17:19 <Baughn> @tell Cale Don't forget to reverse the polarity of $ in lambdabot. ;)
03:17:20 <lambdabot> Consider it noted.
03:18:08 <olsner> heh, has Cale further corrupted lambdabot's Prelude? ;-)
03:18:16 <Baughn> No, not yet
03:18:22 <Baughn> He should, though. ;)
03:21:41 <glguy> then he could rot13 all of the function names for bonus points
03:22:04 <glguy> and default number literals to octal
03:22:17 <mauke> sznc svk erghea
03:22:24 <Baughn> Now, now. A left-associative $ /makes sense/.
03:22:25 <TSC> ... implemented with lazy naturals
03:22:38 <glguy> Baughn: /not in this context/
03:23:17 <glguy> it's as dumb as changing (.) and (++)
03:23:34 <glguy> on a bot primarily used for teaching new people
03:23:57 <dibblego> +1
03:24:17 <olsner> anyone have good examples of where a left-associative ($) is awesome/useful?
03:24:27 <TSC> Why not have two modes?  Normal Haskell (>) and Cale-mode (>>)?
03:24:42 <glguy> TSC: because no one has implemented one yet
03:24:46 <mauke> olsner: a function with >=2 arguments
03:25:09 <mauke> f $ g x $ h y
03:25:34 <vixey> Haskell++
03:25:55 <olsner> hmm, so that's f (g x) (h y)?
03:26:06 <mauke> right
03:26:47 <glguy> I can't wait when people join and ask "Hi, what does $ mean in this code I'm reading" and then we can't run examples on lambdabot because its broken
03:27:29 <Baughn> Oh, but you can. Most examples would still work
03:28:19 <mauke> which library did (.) x f = f x so it could say [...].sort?
03:29:12 <glguy> Baughn: sure, examples with a single $ would work, but that's not an acceptable limitation
03:30:02 <TSC> Perhaps we could define â‚¬ as the left-associative version
03:30:05 <olsner> seems it would be useful with a separate prompt for the modified prelude and a > that only includes out-of-the-box stuff
03:30:25 <glguy> and until then > should be correct stuff
03:30:52 <glguy> (as it doesn't seem anyone intends on writing the dual mode)
03:30:57 <mauke> unfortunately some people think the H98 versions are "incorrect"
03:31:10 <glguy> that is unfortunate
03:36:42 <visof> i have an error when i try to configure ghc6.8.2 at netbsd
03:36:53 <visof> can anyone help me?
03:37:17 <glguy> visof: no telling, but your best shot is ot explain your problem and wiat
03:37:30 <visof> the bootstrap compiler is producing executables that the system doesn't understand
03:38:02 <visof> @paste
03:38:02 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:40:03 <visof> http://hpaste.org/7203
03:40:07 <visof> this the error
03:42:52 <allbery_b> hm.  does your netbsd install actually support ELF?  (that collection of errors is a classic "unrecognized executable file handed off to /bin/sh")
03:43:05 <olsner> @info lift
03:43:05 <lambdabot> lift
03:43:18 <olsner> ehm, fail :(
03:44:02 <visof> what is ELF?
03:44:09 <allbery_b> and, what are you configuring?  trying to build a pkgsrc/port manually?  binary package?  (if so, is it for the right system?)  source package?
03:44:32 <allbery_b> "Extensible Linker Format" aka the modern binary executable / object file format
03:44:58 <allbery_b> but older *BSD may not speak ELF and will expect a.out-style flat executables
03:47:05 <visof> allbery_b yes
03:47:15 <visof> net bsd    supports  ELF
03:47:42 <visof> netbsd   supports ELF
03:47:46 <Heffalump> automatically, or is it possible to configure it out?
03:48:16 <allbery_b> it's also possibe that it is an ELF file for the wrong architecture or OS
03:48:31 <chris2> i'm looking for a purely functional data structure that is a finite map which can be merged very efficiently, any ideas?
03:49:30 <Heffalump> what are your keys?
03:49:41 <chris2> strings
03:50:19 <Heffalump> a Trie?
03:50:20 <chris2> but interned probably, so comparison is constant
03:50:35 <chris2> i want to build a spaghetti stack with it
03:50:38 <visof> Heffalump automatically,
03:51:06 <Heffalump> interned?
03:51:23 <visof> what do you mean?
03:51:53 <Heffalump> visof: I was asking chris2 what "interned" means.
03:52:02 <chris2> think symbols
03:52:10 <visof> okay
03:52:16 <chris2> you can order and compare them, but they are just pointers to their name
03:52:29 <chris2> or hash them or whatever
03:52:30 <DRMacIver> chris2: If you can represent them as Ints, this is more or less what IntMap is designed to do.
03:52:35 <chris2> yeah, okay
03:52:45 <allbery_b> I'm thinking that's not the right object file format; the first tokeb Heffalump: like in lisp.  strings hashed or mapped to identical pointers for identical strings or etc. for fast comparison
03:52:57 <DRMacIver> i.e. it's designed for very efficient merging
03:53:00 <allbery_b> oops
03:53:06 <allbery_b> nothing liek crossed wires :)
03:53:06 <chris2> will look at the impl, thanks
03:53:41 <allbery_b> visof:  what does "file utils/pwd/pwd" say?
03:54:03 <DRMacIver> Yet another FFI question. I'm trying to get access to something defined as "extern int dpecode". Reading the FFI document suggests that the right way to do this is with foreign import ccall "&" dpecode :: Ptr CInt. This seems to compile and link find, but when I use it from ghci it gives me an unknown symbol when I try to use it.
03:55:05 <DRMacIver> ok. Technically that wasn't a question. The implicit question is "What's the right way to do this?" :)
03:56:32 <allbery_b> you need to give ghci a .o file or -llibrary containing the symbol
03:57:20 <DRMacIver> allbery_b: I'm using the same linking instructions that I used for compiling it with ghc. Previously that worked fine.
04:01:48 <DRMacIver> w
04:01:51 <DRMacIver> Oops
04:05:12 <visof> allbery_b is "file utils/pwd/pwd" command ??
04:05:33 <allbery_b> it is a shell command.  run it from the directory you ran ./configure from
04:06:29 <DRMacIver> Interesting.
04:06:35 <DRMacIver> Ok, in conclusion I'm not doing it wrong
04:06:45 <DRMacIver> It works fine if I compile with fvia-c
04:06:45 <visof> allbery_b  utils/pwd/pwd: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), for GNU/Linux 2.6.4, dynamically linked (uses shared libs), stripped
04:07:43 <allbery_b> visof: that would be your problem.  missing linux emulation, or you need to grab a netbsd package instead of a linux one
04:08:54 <allbery_b> DRMacIver: argh, yes, have heard of that but thought it was fixed (is this 6.8.2?)
04:09:20 <DRMacIver> Yep, 6.8.2
04:09:49 <visof> allbery_b i386-linux: Cross-compile environment for iX86 Linux, libc v6
04:09:57 <visof> is this ?
04:11:39 <allbery_b> visof: that's for building.  your problem is more fundamental, you need to be able to run already-built programs.  and I don't know how you do that on netbsd
04:11:56 <allbery_b> and, is there some reason you are using a linux package instead of a native netbsd one?
04:12:07 <DRMacIver> Hm. It still fails when I try to load the compiled .o in ghci
04:12:13 <DRMacIver> This is sad. :(
04:12:29 <visof> allbery_b no
04:13:11 <allbery_b> ...
04:13:25 <visof> i use pkgsrc
04:13:26 <Spockz> wow, two thirds of the students didn't make the course..
04:13:27 <Spockz> http://mirrored.spockz.nl/file/fp/fp_gemtoetsen.png
04:13:28 <lambdabot> Title: Mirrored.Spockz.nl - fp/fp_gemtoetsen.png
04:13:44 <allbery_b> and pkgsrc is using a linuxx binary?
04:14:29 <DRMacIver> Any comments on http://hpaste.org/7204 ?
04:14:44 <DRMacIver> It's basically a set of really trivial bindings to QDBM's Depot library
04:15:33 <DRMacIver> (Oops. One comment. I've just noticed it's impossible to create a database from within it currently)
04:15:41 <allbery_b> visof: really, at this point you need to find someone who knows netbsd and preferably how the ghc pkgsrc is set up
04:16:07 <mauke> DRMacIver: is it possible that dpecode is a macro?
04:16:32 <visof> allbery_ i can install ghc but old version
04:16:39 <DRMacIver> mauke: I don't think so
04:16:51 <visof> install ghc from pkgsrc
04:17:11 <DRMacIver> Oh
04:17:18 <DRMacIver> mauke: I do think so.
04:17:20 <DRMacIver> Thanks
04:18:38 <allbery_b> visof: so you downloaded a binary package to install?  is it a binry package for netbsd?  (if so, why is it creating executables for linux 2.6 kernels?)
04:19:46 <allbery_b> er, not creating. if it's a binary package then utils/pwd/pwd was prebuilt.  but it's for linux, not netbsd.  you sure you downloaded the *netbsd* binary package?
04:20:07 <DRMacIver> mauke: Yeah, that fixed it. Thanks.
04:20:46 <visof> allbery_b   no
04:21:33 <visof> allbery_b  this package i can install it in debian and ubuntu
04:21:42 <allbery_b> debian and ubuntu are linux
04:21:47 <allbery_b> you said you are on netbsd
04:21:53 <visof> yes
04:21:54 <allbery_b> netbsd *is* *not* *linux*
04:22:03 <visof> i tried it before in lnux
04:22:09 <visof> linux
04:22:14 <visof> and now i use netbsd
04:22:28 <visof> moved from linux to netbsd
04:22:30 <mauke> visof: what's your point?
04:22:34 <visof> netbsd is unix
04:22:39 <allbery_b> fine.  install the *netbsd* version
04:22:42 <allbery_b> not the linux version
04:22:49 <allbery_b> the linux version will just cause you pain
04:22:56 <visof> okay
04:23:33 <allbery_b> they are not the same, they are not compatible without weird kernel-mode emulation stuff that in my experience is somewhat fragile.
04:25:07 <visof> allbery_b avaliable binary distributions don't have one for netbsd
04:25:13 <visof> try freebsd
04:25:14 <visof>  ?
04:25:21 <visof> http://www.haskell.org/ghc/download_ghc_682.html#binaries
04:25:22 <lambdabot> Title: GHC: Download version 6.8.2
04:26:41 <allbery_b> if there isn't one for netbsd, I think you'll have to stick with the older one in pkgsrc.  or install the pkgsrc one and then build 6.8.2 from source
04:27:02 <allbery_b> (...but I think that will make you very unhappy as well, it's not for the inexperienced)
04:27:38 <visof> oh
04:27:53 <visof> i don't leave netbsd
04:28:06 <visof> and i want to use ghc6.8.2
04:28:31 <visof> i don't want*
04:29:00 <allbery_b> then I would say you have a problem
04:30:15 <visof> yep
04:32:56 <ilyak> I'm trying to build HXT and it requires HUnit.
04:33:12 <ilyak> The problem is that HUnit comes with nothing which resembles makefile
04:33:22 <ilyak> How would I install it? I did build it.
04:33:36 <allbery_b> does it have a Setup.hs or Setup.lhs?
04:33:41 <ilyak> Nope
04:34:53 <ilyak> Never mind, debian seems to have a package of this
04:37:39 <Baughn> ilyak: Does it have a HUnit.cabal?
04:37:57 <ilyak> Nope it does not
04:39:51 <Bonus> if i do getLine
04:39:54 <Bonus> and then getContents
04:40:02 <Bonus> will the result of getContents have all the contents
04:40:07 <Bonus> or all of it sans the first line
04:40:18 <mauke> all the remaining contents, i.e. not the first line
04:40:25 <Bonus> aha kewl
04:41:23 <Baughn> Bonus: (And don't even think of doing it the other way around)
04:42:35 <Bonus> haha
04:42:39 <Bonus> what other way would that be
04:42:50 <ilyak> Baughn: getContents then getLine
04:43:05 <Bonus> ah yeah of course
04:44:29 <olsner> wow, removing my type annotation made my program take 4 times less memory (based on when it runs out of heap due to the space leak)
04:48:23 <olsner> wait, no, that was replacing Monad.Writer.Lazy with Monad.Writer.Strict
04:52:04 <Baughn> Wouldn't fixing the space leak work better? ;)
04:54:31 <FordCortina> how do you build a package the requires a more recent version of cabal than the one that ghc-6.8.2 supports and depends apon?
04:54:40 <FordCortina> i keep getting this:
04:54:47 <FordCortina> Warning: This package indirectly depends on multiple versions of the same
04:54:47 <FordCortina> package. This is highly likely to cause a compile failure.
04:54:47 <FordCortina> package ghc-6.8.2 requires Cabal-1.2.3.0
04:54:47 <FordCortina> package yi-0.4 requires Cabal-1.5.1
04:55:04 <olsner> Baughn: yes... working on it :)
04:59:21 <ilyak> Please help me with http://hpaste.org/7205 - I can't get how to make a type monad if it have more than one parameter.
04:59:28 <ilyak> Is it possible at all?
05:00:28 <ilyak> I see how Parsec does that, they declare instance Monad (GenParser tok st)
05:00:51 <ilyak> But how would I do that if I need to preserve second parameter, not first?
05:01:06 <ilyak> Or should I rewrite Collector, changing parameter order?
05:01:49 <ilyak> (It works that way, but I wonder how good is that
05:03:05 <twanvl> ilyak: Yes, you must change the parameter order
05:03:33 <ilyak> twanvl: I did and it works, thx
05:03:42 <twanvl> You could also use the standard type "Writer [b] a"
05:07:46 <ilyak> I'll look at it
05:10:17 <ilyak> But now I'm trying to carve something which I understand fully
05:15:07 <DRMacIver> What's wrong with this cabal file? http://hpaste.org/7206
05:15:20 <DRMacIver> I'm getting an error of "Parse of field 'license' failed:"
05:15:54 <olsner> eh, profiling doesn't work with limited heap size? then how am I supposed to find this space leak?
05:18:58 <olsner> it seems that the out-of-heap exception preempts the write-profiling-file handler
05:19:17 <twanvl> DRMacIver: MIT is not a known license type, use OtherLicense instead (or switch to BSD3, AFAIK it is essentially equivalent)
05:19:51 <DRMacIver> That's a bit shit. :) But ok.
05:20:09 <olsner> cabal does not support unknown licenses? that's... weird
05:21:36 <twanvl> data License = GPL | LGPL | BSD3 | BSD4 | PublicDomain | AllRightsReserved | OtherLicense
05:22:31 <pejo> Hm, what license is BSD4?
05:22:54 <olsner> heh, not OtherLicense String?
05:23:02 <twanvl> pejo: the 4 clause BSD license
05:23:04 <DRMacIver> My "that's a bit shit" comment is as much intended to be regarding the totally opaque error message as the overly restrictive set of licenses.
05:23:06 <ivanm> pejo: the original 4-clause BSD license?
05:23:46 <DRMacIver> Oh well, OtherLicense it is (as I've just realised I don't want it under MIT or BSD anyway)
05:27:00 <StacyC> By messing around with Typeable I've been able to get the following to work: [add 3 4, add square 3 4, add 3 square 4, add square 3 square 4] (http://hpaste.org/7202#a1)
05:27:43 <olsner> hmm, unsafeInterleaveIO . runInBoundThread = safe?
05:27:46 <vixey> StacyC: that's a neat trick
05:32:12 <StacyC> The code looks horrible but the kinds of expressions it allows might come in handy for a DSL. I realise the expressions may not look 'Haskelly' but IMHO that's the point of DSLs.
05:33:25 <vixey> I'd probably write it like,  [Add, N 3, N 4], [Add, Square, N 3, N 4], ... though
05:33:28 <vixey> if I was doing this
05:35:59 <Heffalump> StacyC: have you seen Chris Okasaki's work on forth-style (i.e. postfix) combinators in Haskell?
05:36:19 <StacyC> Nope, I'll go take a look
05:38:08 <mux> mmm, too bad I can't use xhtml with bytestrings
05:52:10 <clanehin_> Anyong else perk up at this Knuth interview: "If people do discover nice ways to use the newfangled multithreaded machines, I would expect the discovery to come from people who routinely use literate programming."
05:55:32 <olsner> hmm, is there a commentz-walter multiple-keyword search algorithm for haskell?
05:56:44 <olsner> *implementation I mean...
06:07:20 <aleator> Hmm.. How hard is it to do foo in 'let x = 5; y=2 in x + $(foo "y")' which evaluates to 7?
06:07:40 <vixey> aleator: totally impossible
06:08:14 <mauke> vixey: why?
06:08:50 <vixey> mauke: Because foo _ = 2 is not a valid solution
06:09:11 <mauke> yeah, 2 has the wrong type
06:09:32 <mauke> but why does it rule out other solutions?
06:10:48 <aleator> Wrong type? Did I mess up TH notation or something?
06:11:05 <vixey> thought you were talking about Haskell, sorry
06:11:19 <aleator> Well, template haskell is approximately haskell?
06:11:44 <allbery_b> yes and no
06:12:01 <aleator> Well, enough to be on-topic of the channel?
06:12:01 <allbery_b> haskell itself doesn't allow that kimnd of introspection
06:12:21 <allbery_b> point is, you didn't specify so people assumed non-template haskell
06:12:36 <aleator> Ah sorry. I thought $ would give it away.
06:12:38 <mauke> $(foo ...) is pretty obviously template haskell
06:13:11 * vixey never used template haskell...
06:13:19 <aleator> Me neither..
06:13:30 <allbery_b> in any case, I think iti something like 'y (think lisp) but i don't kno enough TH to say for certain.
06:13:44 <Philippa> mauke: only once you look at the overall expression
06:14:34 <Philippa> aleator: it's generally a good idea to mention TH if you're using it. Yes, it can be done
06:14:41 <Philippa> it's not a good idea, but it can be done
06:15:17 <aleator> Ok, I'll try to be more specific next time.
06:15:36 <aleator> It just came up when I was meddling with string templates, which are pain with haskell.
06:16:00 <allbery_b> I think the preferred way is to use a State or Reader monad with a map from String to a "variable"
06:16:25 <aleator> Yes, but that is pain :)
06:16:38 <allbery_b> and TH isn't?!
06:16:58 <aleator> Well, I was kinda asking that.
06:17:00 <mauke> $(return (VarE (mkName "y")))
06:17:10 <aleator> mauke: Thanks!
06:17:20 * allbery_b thinks haskell is high level enough that you can wrap it nicely
06:19:48 <aleator> allbery_b: Templates might be nice for doing stuff like 'latexLine title nums = $(t "$title & `intercalate '&' nums \\")'
06:21:08 <Philippa> aleator: you know that TH is strictly compile-time, right?
06:21:49 <aleator> Yes, but does that need to cause a problem here?
06:22:51 <aleator> t above could evaluate into ++ and suitably split strings.
06:23:59 <aleator> I know that I should probably stick with HStringtemplate, but..
06:41:33 <DuClare> Hiya, Toxaris \o/
06:42:08 <Toxaris> DuClare: hello! and how is your Haskell going today?
06:42:26 <olsner> > 1 `max` x `div` y
06:42:27 <lambdabot>  max 1 x `div` y
06:42:58 <Toxaris> > div x y
06:42:59 <lambdabot>  x `div` y
06:43:08 <DuClare> Toxaris, Tbh I haven't learnt much.  I checked the applicative functors tut on wikibooks, but it's a bit hard to understand without applying it to something in practice
06:43:15 <vixey> > x >>= y
06:43:15 <lambdabot>  Couldn't match expected type `m a' against inferred type `Expr'
06:43:21 <vixey> > [x] >>= y
06:43:21 <lambdabot>  Couldn't match expected type `Expr -> [b]'
06:43:35 <DuClare> Toxaris, I did write some quick hacks to add a little functionality to my program.  It'd be nice to know if I'm doing things "the bad way" tho.. :o
06:43:39 <DRMacIver> Hm. Is there a good way of using printf with ByteString?
06:44:02 <Toxaris> DuClare: so write instance Applicative Resources :)
06:44:21 <Toxaris> DuClare: which will allow you to write combineResources = liftA2
06:44:31 <DuClare> What is liftA2?
06:44:35 <DRMacIver> I guess packing it will do
06:44:55 <Toxaris> DuClare: one of the functions in Control.Applicative
06:45:03 <mauke> DRMacIver: I've written a very minimal printf for bytestrings
06:45:05 <Toxaris> @type liftA2
06:45:07 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
06:45:14 <mauke> it only supports strings and ints; no special formatting
06:45:27 <Toxaris> DuClare: see how the type of liftA2 looks like the type of combine from yesterday?
06:45:45 <DuClare> Yeh
06:45:51 <Toxaris> DuClare: but liftA2 is not a class member you have to write for all of your datatypes by hand, but it is a polymorphic function
06:45:54 <Toxaris> @src liftA2
06:45:54 <lambdabot> liftA2 f a b = f <$> a <*> b
06:46:19 <Toxaris> DuClare: which is defined in terms of <$> (which you already know!) and <*> (which you currently read about in some Applicative Tutorial)
06:46:21 <DRMacIver> mauke: I think I'll just stick with unpacking them here. Thanks though.
06:46:38 <DuClare> Toxaris, I think <*> was the thing I didn't completely understand
06:47:09 <Toxaris> @type (<*>)
06:47:10 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
06:47:14 <Toxaris> @type ($)
06:47:16 <lambdabot> forall a b. (a -> b) -> a -> b
06:47:33 <Toxaris> @type (<$>)
06:47:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:47:57 <Toxaris> DuClare: compare the types of $, <$> and <*> and note where the fs are
06:49:31 <DuClare> Can you explain the left side from => ?
06:49:53 <Toxaris> DuClare: about your code, if it's not too much you can post it on hpaste.org and ask here in the channel for code review
06:50:34 <Toxaris> "forall (f :: * -> *) a b" introduces type variables. f is a variable which stands for some type constructor, a and b stand for normal types
06:51:07 <Toxaris> "(Applicative f) =" is a constraint on these variables: we want to restrict ourself to such values for f which have an Applicative instance
06:51:25 <Toxaris> "=> f (a -> b) ..." uses the type variables to build a type
06:52:07 <Toxaris> so the overall meaning is: "for every type constructor f which is an applicative functor, and every types a and b, (<*>) has the type f (a -> b) -> f a -> f b
06:52:12 <DuClare> It might be quite messy. :x http://hpaste.org/7208
06:53:15 <DuClare> Toxaris, What effect does the forall have?
06:54:02 <Toxaris> DuClare: simple answer: ignore it. you don't have to type it in Haskell code, because it is the default option and is automatically inserted at an appropriate place
06:54:30 <Toxaris> DuClare: technical answer: it introduces a type variable
06:55:44 <Toxaris> DuClare: note that (<*>) has more then one type. it's polymorphic. we can describe the set of all types (<*>) has by using variables. if you give the values of all variables, you come to a possible type of (<*>). if you give other values, you come to another type.
06:56:52 <Toxaris> so (<*>) has type f (a -> b) -> f a -> f b "for all" values of f, a and b, provided that f is Applicative
06:57:26 <arussel> what is wrong with:  where x = floor (length as)
06:57:32 <DuClare> Does the position have any effect?  In <*> a and b come after (f :: * -> *), whereas they're at the beginning in <$>
06:57:33 <vixey> :t floor
06:57:34 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
06:57:41 <vixey> :t length
06:57:42 <lambdabot> forall a. [a] -> Int
06:57:45 * Toxaris goes to buy, cook and eat some food now 
06:57:47 <vixey> Int is not a RealFrac
06:58:05 <vixey> arussel: maybe use fromIntegral . length $ as
06:58:53 <arussel> vixey: no, I am doing programming in haskell, chapteer 4, not learned that yet. I am probably missing something really easy
06:59:09 <mauke> arussel: remove the floor
06:59:22 <vixey> :t fromIntegral
06:59:24 <lambdabot> forall a b. (Num b, Integral a) => a -> b
07:00:38 <arussel> mauke: the problem is I want to cut a list in half so x need to be an integer. halve as = (take x as, drop x as) where x = floor(length(as/2))
07:00:54 <vixey> arussel: use div
07:01:00 <mauke> arussel: that doesn't make sense
07:01:13 <mauke> arussel: as/2 is impossible because as is a list
07:01:26 <mauke> arussel: floor . length doesn't make sense because length doesn't return a fractional number
07:01:28 <ivanm> mauke: I think it was meant to be length(as)/2, not length(as/2)
07:01:41 <arussel> ivanm: yep, thanks
07:01:47 <ivanm> (even though that doesn't typecheck)
07:01:52 <ivanm> @type length
07:01:53 <mauke> arussel: splitAt may be useful
07:01:54 <lambdabot> forall a. [a] -> Int
07:02:02 <ivanm> @type (/)
07:02:03 <lambdabot> forall a. (Fractional a) => a -> a -> a
07:02:11 <Toxaris> arussel: consider using div
07:02:12 <arussel> got it, so 5/2 and 5 `div` 2 are different :-)
07:02:19 <DuClare> vixey, Can you answer my question abouth the position of a and b in :t <$> and :t <*> ?
07:02:19 <ivanm> arussel: yes
07:02:34 <vixey> DuClare: Maybe
07:02:36 <arussel> I think it what Hutton wanted me to do
07:02:39 <ivanm> arussel: very vaguely, div == floor . (/)
07:02:42 <vixey> :t (<$>)
07:02:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:02:44 <vixey> :t (<*>)
07:02:45 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
07:02:56 <vixey> DuClare: what do you want to know?
07:02:58 <Saizan_> DuClare: no, it doesn't matter
07:03:21 <DuClare> vixey, The first occurances of a and b come in different order.  Seems like Saizan_ got the answer. :)
07:03:25 <DuClare> Thanks
07:03:38 <Saizan_> DuClare: forall <set of variables>. <type using those variables>
07:03:58 <arussel> thanks everybody
07:04:37 <Saizan_> and forall used like that is implicit in haskell, so "(Applicative f) => f (a -> b) -> f a -> f b" is just the same
07:05:16 <DuClare> Yeah, I figured by checking the type in ghci on my computer.  Apparently it omits the forall part
07:05:49 <ivanm> DuClare: that's an extension, IIRC
07:06:15 <DuClare> I suppose
07:06:29 <Baughn> DuClare: That forall doesn't actually affect anything. Other foralls might.
07:06:37 <DuClare> Right
07:06:57 <Baughn> Well, unless you're using lexically scoped typing
07:07:51 <DuClare> No clue what that means :)
07:08:01 <DuClare> I could say I started with haskell yesterday
07:08:38 <DuClare> Not counting the hello worlds I've done in the past.
07:08:45 <Baughn> foo :: a -> b; foo x = (moo x :: b)
07:09:00 <Baughn> With lexically scoped types, the last b would be the /same/ b as the first one
07:09:14 <Baughn> Adding a forall would change that. Although by inference it has to be the same anyway, but still
07:09:26 <Baughn> ..that said, I'm not sure haskell supports this. I haven't checked.
07:10:29 <Saizan_> with ScopedTypeVariables and using a forall in foo's signature, yes
07:10:44 <Saizan_> however this is not something a beginner should care about :)
07:11:39 <olsner> hmm, what was the break-on-exception flag for ghci?
07:11:52 <DuClare> Mmh.
07:12:01 <DuClare> I wonder if anybody glanced through my code. :o
07:12:16 <Saizan_> where was it?
07:12:23 <DuClare> http://hpaste.org/7208
07:12:55 <olsner> ah, found it, -fbreak-on-exception
07:15:48 <jorick> import Data.Map (Map, !) gives me an error when it reaches !. how do i import operators?
07:16:06 <DRMacIver> (!)
07:16:42 <jorick> cool it works now, thx
07:22:29 <Saizan_> DuClare: it looks fine, but you don't have to use parentheses around single identifiers, (foo) is always the same as foo
07:22:36 <olsner> my program crashes with Exception: undefined, and when I try to backtrace with ghci more than 2-3 steps, ghci fails with Exception: undefined
07:23:53 <DuClare> Saizan_, Indeed
07:24:06 <fourbissime> hi there. recently I bumped into a problem. Long story short, I'm pasting a little example.
07:24:08 <Saizan_> DuClare: and to address the question in the comments, you have fmap, liftA2 = combine, liftA3, etc.. all expressible in terms of (<*>)
07:24:24 <DuClare> Saizan_, How about the way I'm reading input, and transforming seconds to a string?  Could it be done more neatly?
07:24:32 <fourbissime> there it is http://hpaste.org/7209
07:25:12 <fourbissime> basically, it says that my function "funk" doesn't have the same number of arguments.
07:26:00 <fourbissime> even though both lines are equivalent - at least to my understanding.
07:26:13 <Saizan_> DuClare: uhm, isn't truncate (fromIntegral s / 3600) == div s 3600 ?
07:26:38 <DuClare> I think so
07:26:46 <allbery_b> fourbissime: what did you think you were trying to do there?
07:26:52 <DuClare> Yeah
07:26:54 <DuClare> It is
07:27:35 <allbery_b> if you are expecting the second argument to be handled automatically by currying, fine... but that doesn't mix with pattern matching
07:28:01 <fourbissime> allbery_b: well, I'm defining a different behaviour of the function for each constructor of MyType
07:28:03 <Saizan_> DuClare: and since you also want the remainder you can use divMod
07:28:35 <fourbissime> but the thing is that on the first line I simplify the expression by removing the argument on both sides
07:28:38 <allbery_b> (you are not actually defining two functions Funk there; it turns into a single function with a case statement.  bu it can't combine those two patterns
07:28:39 <allbery_b> )
07:29:03 <EvilTerran> fourbissime, in a pattern-match for one definition of a function (or implementation of a method), each pattern has to have the same number of parameters
07:29:13 <fourbissime> oh okay I see.
07:29:26 <EvilTerran> as allbery_b says, it desugars into a case
07:29:46 <EvilTerran> foo x y = ... desugars to something like foo = \x y -> case (x,y) of ...
07:29:48 <fourbissime> so it's only a matter of desugaring going wrong ...
07:30:01 <EvilTerran> no, the desugaring's perfectly valid, it's just a little limited
07:30:02 <Saizan_> ?type divMod
07:30:04 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
07:30:04 <allbery_b> it's a matter of the patterns not being for the same case expresison
07:30:39 <fourbissime> EvilTerran: well yeah, "it's a little limited" is what I had in mind. :)
07:30:45 <EvilTerran> i imagine it may be possible to devise a desugaring that does what you want, but it'd have some gotchas wrt pattern-match failures
07:30:58 <EvilTerran> and likely isn't worth the extra complexity
07:31:08 <fourbissime> yeah, definitely out of scope :D
07:32:46 <fourbissime> well in my case, I have a type with a long list of constructors (around 50) and I can express the "funk" function without specifying some arguments for every constructors except 2 or 3. So I have to add the extra useless parameters everywhere.
07:33:15 <EvilTerran> you could say "foo x y = \z -> ..." or whatever
07:33:45 <fourbissime> hmm ok. I'll have a look at that. thanks a lot !
07:33:48 <fourbissime> bye
07:33:52 <EvilTerran> or foo x y = case x of Foo -> ...; Bar -> ...; ... bah
07:35:30 <olsner> this is weird, my program gave Exception: undefined rather than a type error when I ended my do-block with printf instead of return (a,b,c)
07:35:49 <EvilTerran> um
07:36:32 <EvilTerran> i'd try compiling it again and hoping it goes away :P
07:36:53 <olsner> I compiled it several times, none of the times getting a type error :P
07:36:59 <EvilTerran> oh dear
07:38:56 <Jedai> Could you show the code ?
07:39:20 <olsner> yes, I will hpaste it shortly, just wanna check a few things first
07:39:31 <Jedai> printf has an instance for IO a, no ?
07:39:42 <EvilTerran> IO (), i thought
07:40:06 <olsner> well, the function in question ends up with type stepPar :: [Rule] -> (ByteString, Int, t) -> IO t1
07:40:09 <Jedai> EvilTerran: Well that's what I thought too but if he doesn't get an error there...
07:40:34 <Jedai> olsner: Well then that's normal
07:40:34 <olsner> if I have printf as the last statement
07:40:59 <olsner> "expected" behaviour then :P
07:41:03 <Jedai> olsner: Oh ok, that seems to prove that IO a is an instance of Printf
07:41:45 <Jedai> Yep, it has such an instance...
07:42:14 <Jedai> Bad stuff that, doesn't it work if they only put IO () as an instance ?
07:43:57 <Jedai> So this instance returns undefined... what's the advantage of this instance over IO ()...
07:44:38 <olsner> I can't see it ... if you want that I think it'd be appropriate to force people to write printf >> return undefined
07:45:15 <DuClare> Saizan_, Neat, thanks..  I knew my calculations weren't as elegant as possible.  Now it looks a lot better!
07:45:39 <Jedai> Yes, since undefined doesn't give any information on the printf...
07:46:12 <Jedai> That seems like a bug to me
07:46:15 <olsner> hmm, my parallellisation attempt made my program between 2-3 times faster ... but still only uses 1 CPU
07:46:46 <Jedai> olsner: ??? Well at least it's faster ! ;)
07:47:23 <olsner> Activity Monitor's cpu usage graph shows 100% on one cpu, and the other cpu idling
07:47:37 <Jedai> That's a bit surprising though, I know you can get some speed improvement from passing to the threaded model, but 2-3 times...
07:48:15 <DRMacIver> Hm. I can't tell if imperative Haskell looks especially ugly or if it just highlights how ugly imperative code normally is. (I bet I know which door the channel will pick :) )
07:48:45 <Jedai> DRMacIver: Which ?? ^^
07:49:20 <DRMacIver> I was thinking door number two. Although the "DRMacIver is just wrong" door is also a plausible candidate. :)
07:49:21 <olsner> my experience as of lately is that it is easier to write performant non-space-leaky haskell by sticking everything in IO
07:49:59 <Jedai> Though I don't find imperative code especially ugly in Haskell (except if you're speaking about IORef, IOArray which are badly in need of smart operators love)
07:50:23 <DRMacIver> I don't know. It's possible I'm just writing bad code. :)
07:51:04 <DRMacIver> I wrote this up as a "Hey, look what I did!" post, but looking over it the code just looks really unpleasant to me and I'm not quite sure why. http://www.drmaciver.com/2008/04/qdbm-bindings/
07:51:06 <lambdabot> Title: 10 David R. MacIver 1 16 » Blog Archive 1 16 » QDBM Bindings 37
07:51:26 <DRMacIver> (Aside from the really lousy argument handling)
07:51:47 <olsner> I think haskell yields quite pretty imperative code inside monads; but outside monads with e.g. x' = f x, x'' = g x' etc it does get quite ugly
07:52:18 <olsner> (but that's a case of not finding the proper monad to work in rather than haskell failing :P)
07:52:45 <DRMacIver> The classic example of that is the standard library's Random stuff.
07:52:54 <DRMacIver> It works so much better inside a state monad.
07:52:59 <astrolabe> In ghci, is there a way to bind a variable to something that isn't Showable?
07:54:01 <olsner> astrolabe: let asdf = (\x -> 3 ) worked fine for me?
07:54:27 <astrolabe> olsner:weird hang on, I'll try it
07:55:14 <allbery_b> :set -fno-print-bind-result
07:55:18 <astrolabe> olsner: Must be something unexpected in Parsec.  Thanks.
07:55:22 <allbery_b> and then you can x <- whatever
07:55:38 <astrolabe> thanks allbery_b
07:56:03 <olsner> parsec needs Show on lots of things for error messages (e.g. tokens)
07:57:15 <astrolabe> I'm being stupid.  It's just that parseTest prints its result.
07:57:27 <olsner> heh
08:07:46 <olsner> Jedai: heh, that program of mine is exactly as fast when compiled without the threading part
08:08:36 <Jedai> olsner: I thought it was 3 times faster ?
08:09:04 <olsner> apparently it's all in my rewriting to make it possible to split the work between threads
08:09:16 <Jedai> Well that's more normal, if you want to show us the code, maybe we can work out why it doesn't parallelize anything
08:14:07 <DuClare> Saizan_, You said liftA* were expressible in terms of (<*>).  Do you think you could explain it, along with a simp example maybe?
08:14:27 <allbery_b> @src liftA2
08:14:27 <lambdabot> liftA2 f a b = f <$> a <*> b
08:14:58 <Saizan_> DuClare: do you understand how (<*>) works yet?
08:15:17 <DuClare> Saizan_, I think that's what I'm trying to understand
08:15:29 <Saizan_> ok
08:16:01 <Saizan_> so, starting simple, Maybe is an Applicative
08:16:14 <Saizan_> you've already worked with Maybe?
08:16:19 <DuClare> Nope :o
08:16:30 <Saizan_> ?src Maybe
08:16:30 <lambdabot> data Maybe a = Nothing | Just a
08:16:54 <Saizan_> e.g. (Maybe Int) can be Nothing, or Just an int
08:17:10 <DuClare> Allright
08:17:14 <Saizan_> it's a way to represent potential failure in producing a result
08:17:30 <Saizan_> so, pure = Just
08:18:10 <Saizan_> (<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b  in this case
08:18:25 <Saizan_> so what should it do?
08:19:24 <DuClare> Hmm.  Wouldn't it take function and a value, returing either Nothing or a value of another type?
08:19:34 <DuClare> (or possibly the same type of course)
08:20:02 <olsner> hpaste-bot absent?
08:20:11 <Saizan_> yeah, but how can it construct that value?
08:20:13 <olsner> http://hpaste.org/7210
08:20:34 <DuClare> Uhmm..
08:21:40 <olsner> Jedai: there you are, forkIO' is my primitive attempt at threading; runThue -> runThuePar magically speeds it all up by a factor ~2.37, regardless of whether forkIO' actually tries to fork anything or just runs m
08:22:16 <Saizan_> defining it by cases, we can consider when we get two values constructed with Just, (<*>) (Just f) (Just v) = ..., here f :: a -> b, and v :: a, and we need to return something of type b
08:22:24 <olsner> and almost everything is in the IO monad, however ugly that may be
08:24:09 <DuClare> I'm listening
08:24:31 <Saizan_> so, we can just apply f to v, since (f v) :: b, hence (<*>) (Just f) (Just v) = Just (f v)
08:25:50 <Saizan_> and there's no other way we could construct a value of type 'b', because we don't get to choose the type in the implementation, we can only use the parameters passed
08:26:10 <Saizan_> does it make sense?
08:26:38 <DuClare> I think it does
08:27:09 <Saizan_> so, what if one of the parameter passed is Nothing?
08:27:21 <Saizan_> "parameters"
08:28:17 <Saizan_> in that case we lack a way to construct a 'b', so we can only return Nothing
08:28:47 <Saizan_> > Just (+1) <*> Just 42
08:28:48 <lambdabot>  Just 43
08:28:54 <Saizan_> > Nothing <*> Just 42
08:28:55 <lambdabot>  Nothing
08:28:58 <DuClare> Hm..
08:29:16 <DuClare> Right, Just and Maybe are Applicatives
08:29:17 <Saizan_> ?
08:29:24 <Saizan_> no
08:29:28 <DuClare> Oh
08:29:30 <Saizan_> Maybe is an Applicative
08:29:52 <Saizan_> Just and Nothing are the two data constructors for the Maybe type
08:30:09 <DuClare> A, right
08:30:16 <Saizan_> Just and Nothing are at the value level, Maybe at the type one
08:30:38 <Saizan_> ?type Just
08:30:40 <lambdabot> forall a. a -> Maybe a
08:30:43 <Saizan_> ?type Nothing
08:30:44 <lambdabot> forall a. Maybe a
08:32:53 <Saizan_> however the intuition behind (<*>) is that it takes a function ad a value wrapped in an Applicative, and return the function applied to the value, again wrapped
08:33:12 <Saizan_> "wrapped again"
08:35:30 <Saizan_> in your case a sensible definition would be (<*>) (Resource f1 f2 f3) (Resource v1 v2 v3) = Resource (f1 v1) (f2 v2) (f3 v3)
08:36:06 <ilyak> Is there a list of chars that are permitted in operators?
08:36:50 <Saizan_> so, defining pure x = Resource x x x, compose f r1 r2 = pure f <*> r1 <*> r2
08:38:52 <Saizan_> pure f <*> r1  = (Resource f f f <*> r1) <- so the result is a Resource with f partially applied to each of the fields
08:38:57 <Saizan_> DuClare: still there?
08:39:01 <DuClare> Yup
08:41:03 <Saizan_> so, if you have a function that takes 3 arguments, you can just use one more (<*>)
08:41:35 <Saizan_> ?type \f r1 r2 r3 -> pure f <*> r1 <*> r2 <*> r3
08:41:37 <lambdabot> forall a a1 a2 b (f :: * -> *). (Applicative f) => (a -> a1 -> a2 -> b) -> f a -> f a1 -> f a2 -> f b
08:42:34 <Saizan_> you're appling one argument at a time storing the partially applied function in your Resource
08:44:15 <Saizan_> have you ever seen zipWith?
08:44:20 <DuClare> No
08:47:37 <Saizan_> > zipWith (+) [1..5] [2..6]
08:47:38 <lambdabot>  [3,5,7,9,11]
08:47:54 <Saizan_> it just permorms a pointwise sum
08:47:59 <Saizan_> ?src zipWith
08:48:00 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
08:48:00 <lambdabot> zipWith _ _      _      = []
08:48:42 <Saizan_> > liftA2 (+) (ZipList [1..5]) (ZipList [2..6])
08:48:43 <lambdabot>   add an instance declaration for (Show (ZipList a))
08:48:52 <Saizan_> > getZipList (liftA2 (+) (ZipList [1..5]) (ZipList [2..6]))
08:48:53 <lambdabot>  [3,5,7,9,11]
08:49:04 <Saizan_> just to show another example :)
08:49:32 <Saizan_> > getZipList (pure (+) <*> (ZipList [1..5]) <*> (ZipList [2..6]))
08:49:33 <lambdabot>  [3,5,7,9,11]
08:49:42 <Saizan_> this is very similar to your Resource
08:49:59 <Saizan_> with the difference that Resource has a fixed number of elements
08:51:03 <Saizan_> > getZipList (pure (\a b c -> a + b + c) <*> (ZipList [1..5]) <*> (ZipList [2..6]) <*> (ZipList [3..7]))
08:51:04 <lambdabot>  [6,9,12,15,18]
08:51:21 <Saizan_> maybe i'm just confusing you at this point :)
08:55:23 <vixey> :t pure
08:55:24 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
08:55:26 <mux> > getZipList $ (+) <$> (ZipList [1..3]) <*> (ZipList [4..6])
08:55:28 <lambdabot>  [5,7,9]
08:55:37 <vixey> @instances Applicative
08:55:37 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
08:55:40 <mux> most uses of pure can be avoided with <$>
08:56:26 <mux> pure f <*> g == f <$> g
08:56:46 <vixey> > getZipList ((\a b c -> a + b + c) <$> (ZipList [1..5]) <*> (ZipList [2..6]) <*> (ZipList [3..7]))
08:56:47 <lambdabot>  [6,9,12,15,18]
08:56:55 <vixey> @src (<$>)
08:56:55 <lambdabot> f <$> a = fmap f a
08:57:09 <vixey> @src fmap Applicative
08:57:09 <lambdabot> Source not found. My pet ferret can type better than you!
08:57:26 <Deewiant> @src Applicative fmap
08:57:26 <lambdabot> Source not found. Maybe if you used more than just two fingers...
08:59:01 <olsner> wohoo! minimal degree of parallelity achieved, about 2 of my 13 seconds were run on the second cpu now
09:01:55 <izz1> hi guys, noob here. what is the shortest way to display an IO String in happs? i dont understand monads yet. all i want is display something from readfile.
09:03:02 <Lemmih> izz1: liftIO.
09:08:18 <mux> how would you guys do it if you needed a partitionM kind of thing? would you base it off foldM? I have an explicit recursion scheme for now and find it messy
09:09:51 <kpreid> @type foldM
09:09:52 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
09:10:03 <kpreid> seems reasonable
09:10:10 <kpreid> hm
09:10:22 <kpreid> @hoogle [Either a b] -> ([a], [b])
09:10:23 <lambdabot> No matches, try a more general search
09:10:43 <twanvl> I would write with recursion. paritionM p [] = return [];  partitionM p (x:xs) = do { keep <- p x; (ps,qs) <- parititionM xs; return $ if keep then (x:ps,qs) else (ps,x:qs) } -- not that messy
09:10:45 <kpreid> ...if that existed, I'd suggest mapM to [Either a b]] and then using that
09:12:09 <mux> twanvl: right but a true partitionM function wouldn't be quite enough since I also need to discard some elements
09:13:04 <mux> and I'm guessing filterM . partitionM somehow wouldn't be as efficient
09:13:06 <Bonus> is there any built in function for replacing substrings within strings?
09:13:19 <Bonus> like replace "dog" "cat" "my dog is a dog"
09:13:44 <twanvl> Bonus: some regex library can probably do that, but there is no standard list function.
09:13:51 <Bonus> aha ok
09:13:52 <Bonus> thanks
09:14:12 <twanvl> mux: Don't worry about efficiency too mutch, readability comes first
09:14:28 <mauke> replace a b = intercalate b . split a
09:14:33 <mauke> the problem is that split doesn't exist
09:15:20 <DuClare> @src fmap
09:15:20 <lambdabot> Source not found. There are some things that I just don't know.
09:15:31 <mux> twanvl: well in that case I know which elements (files in my context) to discard based on whether getFileStatus throws me an isDoesNotExistError exception - so if I needed in two steps my program would end up stat()'ing each file twice
09:16:04 <twanvl> mux: so you actually want to partition into three lists (and keep only two)?
09:16:18 <mux> correct
09:16:19 <twanvl> DuClare: fmap is a class method (in the class Functor)
09:16:59 <mux> would you use foldM in that case then or would you advice something else?
09:17:54 <twanvl> mux: I don't really like foldM here, since it is a left fold and hence it would reverse the order of the list
09:18:41 <twanvl> mux: kpreid's sugestion looks nice, you can easily extend it
09:19:13 <mux> thanks for the input
09:20:02 <bugQ> zipWith is easy to do as a list comprehension...is there a preference between them for speed/readability?
09:20:07 <twanvl> partitionClasses . mapM classify;   classify :: a -> Classified a;  partitionClasses :: [Classified a] -> ([a],[a]);  data Classified a = Keep a | Whatever a | Discard
09:20:22 <twanvl> bugQ: zipWith and list comprehension are not the same thing
09:20:36 <bugQ> no, but look:
09:20:42 <bugQ> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
09:20:46 <bugQ> fibs = 0 : 1 : [ a+b | a <- fibs | b <- tail fibs ]
09:20:57 <wjt> those are not equivalent
09:21:02 <mauke> yes, they are
09:21:05 <twanvl> bugQ: that is parallel list comprehension, it is a GHC extension
09:21:07 <wjt> really?
09:21:12 <twanvl> and it must DIE
09:21:13 <bugQ> oh, hah.
09:21:15 <vixey> > let fibs = 0 : 1 : [ a+b | a <- fibs | b <- tail fibs ] in fibs
09:21:15 <lambdabot>  Parse error at "|" (column 38)
09:21:16 <wjt> oh, | not ,
09:21:21 <vixey> > let fibs = 0 : 1 : [ a+b | a <- fibs , b <- tail fibs ] in fibs
09:21:22 <lambdabot>  [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
09:21:48 <bugQ> well ok then.
09:22:18 <mux> I'm partial to pointfree versions of the fibonacci list
09:22:34 <mux> > fix ((1:) . scanl (+) 1)
09:22:35 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
09:24:37 <bugQ> ?hoogle fix
09:24:38 <lambdabot> Data.Function.fix :: (a -> a) -> a
09:24:38 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
09:24:38 <lambdabot> Control.Monad.Fix :: module
09:25:35 <Deewiant> > fix ((0 :) . (1 :) . (zipWith (+) <*> tail))
09:25:37 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
09:26:09 <mux> fix ((1:) . scanl (+) 1)
09:26:17 <mux> woops, mispaste
09:27:34 <sarehu> > fix ((z:) . scanl (+) 1)
09:27:35 <lambdabot>  [z,1,1 + z,1 + z + 1,1 + z + 1 + (1 + z),1 + z + 1 + (1 + z) + (1 + z + 1),1...
09:30:14 <bugQ> well, I guess I prefer keeping my sanity to point-free
09:34:06 <DRMacIver> Hm. Cabal has suddenly stopped working with unknown symbol errors
09:34:46 <Toxaris> > let foo = foldr (first . (:) ||| second . (:)) ([], []) in foo [Left 'k', Right 'l', Right 'i', Left 'p', Left 'r', Right 'k', Right 'e', Left 'e', Right ' ', Left 'i', Right 't', Right 'h', Left 'd', Right 'i', Right 's', Right '?']
09:34:48 <lambdabot>  ("kpreid","like this?")
09:35:29 <kpreid> Toxaris: nicely done
09:36:14 <mux> nice indeed
09:36:26 <Bonus> if i want to work w/ like rly big numbers
09:36:35 <Bonus> do i have to watch out they're of the type Integer
09:36:42 <kpreid> Integer is good.
09:36:42 <Toxaris> Bonus: yes
09:36:43 <Bonus> or is it okay if they just conform to the Num class
09:36:45 <DRMacIver> Anyone know what's up with http://hpaste.org/7211 ?
09:36:45 <vixey> Bonus: probably you should use Integer anyway
09:36:48 <Deewiant> > 2^65
09:36:49 <lambdabot>  36893488147419103232
09:36:52 <Deewiant> > 2^65 :: Int
09:36:53 <lambdabot>  0
09:36:59 <Bonus> ah
09:37:06 <kpreid> Bonus: Not all instances of Num are suitable. Use Integer, avoid Int.
09:37:17 <Deewiant> > 2^65 :: Double
09:37:18 <lambdabot>  3.6893488147419104e19
09:42:05 <tony3> How does one hide specific Instances from an import? e.g. I'd like to hide the [Int] Binary instance, (Binary a) => Binary [a]), in order that I may override it with something application specifc.....
09:42:45 <Deewiant> AFAIK it's not possible - if you import something you always get all instances
09:43:08 <wjt> you need to newtype MyIntList = MyIntList [Int] and then write your own binary instance
09:43:11 <Deewiant> I don't know why although I've heard there's a good reason for this
09:43:43 <tony3> oh. well. ok.
09:44:06 <tony3> thanks,
09:44:37 <mux>  
09:44:39 <tony3> yeah' it won't be too much bother to have the newtype I guess.
09:47:06 <cedricshock> I need to be able to update nodes in mutually recursive data structures in pure-land. What's the best solution for this? Are there existing libraries for this? Should I make my own using hash tables?
09:49:03 <quicksilver> Deewiant: instances are fundamentally global
09:49:09 <cedricshock> It's not actually the recursion that's the problem; it's the many scattered in-bound edges.
09:49:18 <quicksilver> Deewiant: therefore any illusion of choice about importin them would be just that, an illusion :)
09:51:12 <StacyC> quicksilver: If I have a module A which imports a module B, and module B contains instances, will importers of A have access to the instances ?
09:51:35 <StacyC> Because I would have thought I would only have access to those things that are exported by A
09:51:45 <cedricshock> Basically I want half of a graph: A node containing a value, and edges into that node, where the edges know nothing about what's at the other end, and the node container knows nothing of the edges.
09:52:05 <quicksilver> StacyC: typically if you have access to the type, you have access to the instance.
09:52:12 <quicksilver> StacyC: (if the instance was defined along with the type_
09:52:36 <StacyC> Ok, then it's just that when importing the module containing the type you'll also get the instances because they are usually defined in the same module, right ?
09:53:04 <StacyC> Hmm, and it
09:53:23 <StacyC> oops, and it's not possible to choose a subset excluding the instances ?
09:53:54 <DRMacIver> Hm. Installing the pretty printer library has somehow fucked Cabal. :(
09:53:57 <malebria> Hello, is there a problem with ghci 6.8.2 and utf-8 filenames?
09:54:17 <malebria> I have a directory called PÃºblico (default in pt_BR Ubuntu), and I can't load a file with :load in GHCI.
09:54:45 <malebria> When I try in the command line, it works, like: ghci PÃºblico/codigo/haskell/Hora.hs
09:54:56 <malebria> The problem is with :load PÃºblico/codigo/haskell/Hora.hs
09:55:19 <SamB> malebria: well, why is it called that?
09:55:19 <malebria> It gives me: <no location info>: can't find file: Pï¿½blico/codigo/haskell/Hora.hs
09:55:29 <SamB> it's probably a bug
09:55:33 <malebria> SamB: the directory?
09:56:01 <SamB> but still, I think naming programming project directories in that sort of way is frowned upon...
09:56:17 <Lemmih> malebria: It's a bug. GHCi doesn't understand unicode.
09:57:06 <malebria> Lemmih: in 6.6.1 I thought this kind of thing worked.  I'm not sure, but I really think it did, because I have a script in .emacs.el that uses this command with this filename, and I didn't had a problem till I upgrade to 6.8.2
09:57:37 <malebria> SamB: this is not my programming project directory, this is the basic tree of Ubuntu.
09:57:49 <SamB> malebria: eh???
09:58:11 <malebria> Ãrea de Trabalho, Documentos, Imagens, Modelos, MÃºsica, PÃºblico e VÃ­deos.
09:58:42 <malebria> These directories are in the home directory of the user in the instalation of ubuntu.
09:59:10 <DRMacIver> Hurray. And now GHC is profoundly fucked. Time for a reinstall.
09:59:27 <wjt> you could just make a new directory? :)
09:59:44 <malebria> wjt: I like this one...
09:59:50 <SamB> what is the function of Publico?
10:00:17 <SamB> also, you could try going inside that directory before running GHCi
10:00:20 <malebria> What is most strange for me is why in ghci 6.6.1 I didn't got this problem..
10:00:26 <malebria> SamB: this works also.
10:00:34 <malebria> I don't want a workaround.
10:00:45 <malebria> There're plenty of them.
10:00:48 <SamB> malebria: just report it, probably somewhere is doing a conversion that wasn't done before...
10:00:58 <malebria> hum...
10:01:09 <nominolo> @bot
10:01:09 <lambdabot> :)
10:01:47 <mux> I have to say haskell with fastcgi & xhtml is fine for small web development
10:03:03 <cedricshock> What's the diference between DynApply and DynApp?
10:04:37 <malebria> =)
10:05:11 <cedricshock> @src DynApply
10:05:11 <lambdabot> Source not found. I feel much better now.
10:05:22 <StacyC> msg lambdabot > |||
10:05:27 <DRMacIver> Hm. Interesting.
10:05:35 <cedricshock> @src Data.Dynamic.DynApply
10:05:35 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
10:06:00 <DRMacIver> Can anyone confirm that installing the "pretty" package from hackage will destroy your GHC install?
10:06:07 <DRMacIver> Or at least render Cabal nonfunctioning
10:06:37 <SamB> DRMacIver: I'd rather not :-)
10:06:46 <Saizan_> what errors do you get? are you on windows?
10:07:21 <DRMacIver> I'm on linux. I get an unknown symbol when linking. http://hpaste.org/7211
10:07:40 <DRMacIver> The problem seems to be that cabal depends on a version of pretty print which isn't exposed anywhere.
10:08:23 <DRMacIver> And I conjecture that when I install pretty print it starts trying to use that for some reason (Which it shouldn't, right? I thought these things got statically linked in) and the two aren't binary compatible.
10:08:30 <DRMacIver> But I don't really understand what's going on. :(
10:08:56 <DRMacIver> Except that Clean install of GHC, Cabal works. Install pretty print, Cabal doesn't work.
10:09:03 <Saizan_> ?hackage pretty
10:09:03 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pretty
10:09:03 <DRMacIver> Which is sad. :)
10:09:09 <Heffalump> that sounds like a bad bug
10:09:11 <Heffalump> and rather odd
10:09:15 <DRMacIver> Yeah
10:09:22 <Heffalump> does the timestamp on that .o file change when you install pretty?
10:09:46 <Saizan_> well your cabal was compiled against your old pretty
10:09:58 <Heffalump> oh, wait. I see.
10:10:06 <Saizan_> but they are the same version.. so they should be binary compatible?
10:10:11 <Heffalump> but aren't.
10:10:14 <Heffalump> that sucks..
10:10:28 <paolino> DRMacIver: you need to recompile cabal with the new pretty ?
10:10:29 <Heffalump> oh, no, binary compatibility isn't expected, I don't think.
10:10:37 <Heffalump> so yes. But the fact that he has to do that sucks..
10:10:42 <DRMacIver> Heffalump: The time stamp appears to be that of the ghc install.
10:10:55 <Heffalump> ok, so the problem is that pretty isn't statically linked in, and has changed from underneath
10:10:56 <Saizan_> since the package version is the same cabal can't use your old pretty anymore, since it has been overwritten
10:11:03 <DRMacIver> I'm totally confused. I thought Haskell libraries got statically linked in?
10:11:04 <Heffalump> surely this is a known problem?
10:11:11 <paolino> well I did that story for all deps :-/
10:11:22 * SamB wants to open two emacs frames on different character terminals...
10:11:28 <Heffalump> DRMacIver: to binaries, yes. Probably not to libraries.
10:11:33 <DRMacIver> Ah, I see.
10:11:36 <DRMacIver> That makes sense.
10:11:39 <Heffalump> s/binaries/executables/
10:11:43 <DRMacIver> Right.
10:11:46 <sarehu> SamB: M-x rename-buffer?
10:12:13 <SamB> sarehu: eh?
10:12:14 <sarehu> oh never mind I understand
10:12:15 <DRMacIver> I actually tried recompiling Cabal earlier and I got the same problem afterwards.
10:12:24 <DRMacIver> But it's possible that something else got broken. I'll try again.
10:13:02 <sarehu> frames/windows, on/with, english/shminglish
10:13:15 <Lemmih> Heffalump: Binary compatibility /is/ expected if the version number hasn't changed.
10:13:18 <DRMacIver> Hm. Actually, how did I do that? Cabal was broken...
10:14:36 <Saizan_> DRMacIver: if you run runghc Setup.hs in the cabal repo it loads the files from sources
10:14:57 <Saizan_> in fact it's a bit slower than normal
10:15:28 <DRMacIver> Saizan_: oh, shiny. Thanks.
10:17:59 <DRMacIver> Righto. That's fixed it. Thanks all.
10:19:13 <DRMacIver> Should I file a bug about this to someone?
10:19:25 <Saizan_> i think so, probably to the package maintainer
10:19:51 <DRMacIver> ok
10:22:30 <DRMacIver> Hm. The maintainer is listed as libraries@haskell.org . It's not clear where to file bugs for that - I assume it has some sort of official bugtracker?
10:23:04 <DRMacIver> The issue isn't really with the ghc standard libraries, so it's not exactly a bug against ghc.
10:24:35 <Cale> At the least, you could send a message to that list and hope that someone knows where to file the bug :)
10:24:36 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
10:25:22 <izz2> ï»¿/msg lambdabot @messages
10:27:00 <sendark> hey guys how did you build the haskel bot in this channel?
10:27:05 <sendark> i want to make one for prolog
10:27:25 <Saizan> ?version
10:27:25 <lambdabot> lambdabot 4p625, GHC 6.8.2 (Linux i686 2.40GHz)
10:27:25 <lambdabot> darcs get http://code.haskell.org/lambdabot
10:28:06 <Saizan> sendark: essentially we disallowed IO via the type system
10:28:26 <Cale> sendark: You want to write one in Prolog, or you want to use lambdabot for the prolog channel?
10:28:40 <sendark> ok so you wrote lambdabot entirely in haskell?
10:28:45 <Cale> Yeah.
10:28:48 <sendark> sweet.
10:29:59 <Cale> In fact, it could probably use a serious refactoring by now, it's getting pretty complicated :)
10:30:41 <newsham> ?bot likes to be refactored?
10:30:42 <lambdabot> :)
10:33:35 <ddarius> This is how lambdabot was made:  You make the core bot features and some "plugins", you connect it to an IRC channel, you have an easy commit policy, and you wait for new plugins to come in.
10:34:10 <newsham> i have new lambdabot module.  how do i easy commit it?
10:34:42 <ddarius> newsham: darcs send or ask for commit privileges, wait 5 seconds, and darcs push.
10:34:44 <Cale> Send me a darcs patch and I'll apply it
10:43:51 * Baughn wouldn't mind fewer layers between main and main'', at least
10:44:25 * sjanssen wants to kill BotPP
10:44:36 * Baughn wants to rewrite the entire State system (and API)
10:48:51 <Saizan> BotPP is the build system?
10:49:06 <ddarius> Baughn: Then do it.
10:49:30 <Baughn> ddarius: How do you feel about relational databases?
10:51:01 <Saizan> for lambdabot state?
10:51:12 <Saizan> it's not really relational..
10:51:41 <Baughn> Saizan: Yes. That's the problem.
11:23:22 <zeno_> can you create a data type like this: data Something = Something {sa, sb :: (Class x) => x}?
11:24:37 <newsham> data Something a { sa,sb :: a }    ?
11:24:43 <newsham> data Something a = Something { sa,sb :: a }    ?
11:25:39 <zeno_> newsham: that doesnt restrict as type class though
11:26:41 <newsham> you mean something like: data Something a = Ord a => Something { sa,sb :: a }    ?
11:28:24 <zeno_> newsham: that works? thanks :)
11:28:36 <newsham> zeno: I think its preferred to put the class restrictions on the functions than on the datatype
11:29:00 <zeno_> ah ok, sorry im still getting used to this
11:29:21 <newsham> .. in case you have some functions which dont require the restriction..  you wont have to constantly carry around the restriction
11:30:41 <zeno_> the type system is really different than what im used to (java) :\
11:31:03 <sclv> I've been reading the species paper.
11:31:28 <sclv> stupid question -- what sorts of things does this make possible in terms of expressivity?
11:32:10 <newsham> lots of languages are fairly closely related and have similar concepts.  haskell's different in many ways and will definitely stretch your brain :)
11:32:11 <ddarius> sclv: It lets you directly express and manipulate things like cycles, unordered pairs, lists of length n.
11:33:30 <zeno_> which paper?
11:33:38 <sclv> http://www.cas.mcmaster.ca/~carette/species/msfp08_species.pdf
11:33:47 <zeno_> newsham: yeah thats the primary reason i picked it up :)
11:33:51 <sclv> its a bit much if yr. just learning haskell
11:34:28 <zeno_> still working on monads, they seem a bit like unix pipes
11:34:47 <sclv> that's a good intuition
11:35:26 <zeno_> (and my first program; im sure ill look back on it later and laugh :)
11:36:43 <sclv> ddarius: what bugs me about the paper is that i sort of see where they're going, but a single clear example of an "almost-syntax" for what working with species would look like would clear so much up for me.
11:37:52 <ddarius> zeno_: Actually the unix pipe system does form a monad.  cat is return and | is bind.
11:38:18 <cpoucet> hi
11:38:25 <cpoucet> Who do I have to contact for planet haskell?
11:38:41 <newsham> ddarius: that sounds like a blog with reddit potential.
11:38:43 <dcoutts> cpoucet: ibid, but it also says on the web page
11:39:17 <zeno_> newsham: so would the convention to put next to sa --Member of class x?
11:39:43 <newsham> zeno: I would think if its worth going in the comments, its worth going into the type decl.
11:39:49 <zeno_> ddarius: ah thats really cool
11:40:06 <newsham> but i wouldnt put it into the type decl unless you really wanted it to always be true for every function
11:40:12 <cpoucet> dcoutts: thx
11:40:49 <newsham> zeno: once you put that decl into the type, I think you have to type it in every time you use that type in a function
11:42:09 <newsham> for example, lets say you define:   data Foo a = (Ord a) => Foo Int a
11:42:11 <zeno_> newsham: ya it will always be there, if there are multiple class types what would the syntax be? data S a b = Ord a, Num b => S { sa :: a,sb :: b }?
11:42:30 <cpoucet> newsham: I nver understood what use it has
11:42:37 <newsham> and you had a function which just returned the Int part.   intPart (Foo x _) = x;   intPart :: (Ord a) => Foo Int a -> Int
11:42:43 <sclv> the "related work" section of the species paper actually made the most sense to me in a way -- sort of setting up a spectrum of approaches to extending the power of ADTs?
11:42:49 <sclv> is this intuition at all correct?
11:42:56 <newsham> you still have to say "(Ord a)" even though "intPart" could be more general than that (since it doesnt care what the other member is)
11:43:08 <ddarius> newsham: The only syntax accepted by Haskell 98 is: data (Ord a) => Foo a = Foo Int a and it is useless.
11:43:46 <newsham> err what ddarius said, the syntax I used is only ghc extension I guess
11:44:17 <ddarius> sclv: I don't understand what you mean.  Species aren't meant to provide nor (they hope) be merely part of a spectrum of approaches to extending the power of ADTs.
11:44:22 <zeno_> ah, is GHC really different (extended?) from the standard?
11:44:56 <newsham> ghc has a lot of extensions
11:45:05 <sclv> s/extending the power of ADTs/moving beyond ATDs/ ?
11:45:08 <sclv> warmer ?
11:45:24 <newsham> zeno: I thikn your best bet is to not mention the class restriction in your type decl, and just use it in the functions that require it
11:45:45 <newsham> the types for those functions will be documentary enough
11:46:17 <sclv> i.e. more expressive ways to build and manipulate structures?
11:47:57 <zeno_> newsham: k, the reason for this thing is i felt REALLY stupid defining data Node s a = Node {s :: state, a :: act}
11:48:53 <newsham> zeno: "s" and "a" are types on the left hand side, and names on the right hand side, thats prob not what you meant :)
11:49:12 <ddarius> sclv: Species does extend (regular) ADTs.
11:49:13 <zeno_> newsham: ya :) just mistyped here sry
11:49:15 <newsham> not sure you should feel stupid with a type decl like that.
11:49:57 * sclv sighs and scratches his head a bit.
11:50:41 <newsham> zeno: you could use tuples if it made you feel better :)
11:50:53 <ddarius> Java doesn't have tuples.
11:51:16 <Twey> It will when they hear about them -- they'll be implemented as arrays
11:51:21 <newsham> we're not in java anymore, toto
11:52:00 <zeno_> i know tuples from python :)
11:52:32 <Twey> Well, they're a bit different in Haskell :-)
11:52:37 <ddarius> sclv: It just provides ways of making new types of data backed by a well developed theory.
11:52:45 <newsham> be careful.  in haskell neither lists nor tuples are mutable (unlike mutable lists in python), and lists contain only a single type (unlike python lists)
11:52:57 <ddarius> In Haskell nothing is mutable.
11:53:17 <vixey> class TwoTuple<A,B> { A a; B b; public TwoTuple(A a, B b) { this.a = a; this.b = b; } public A getA() { return a; } public B getB() { return b; } public void setA(A a) { this.a = a; } public void setB(B b) { this.b = b; } }
11:53:22 <zeno_> ddarius: except if you use the state monad right?
11:53:30 <newsham> zeno: thats just an illusion :)
11:53:36 <ddarius> zeno_: No, the State monad just models mutation.
11:53:40 <sclv> ddarius: reading the paper, I was under the impression that there was a "species, now!" type implementation, but that the gist would be to move parts of this back to the compiler level?
11:53:48 <sclv> maybe that was where I went wrong. :-)
11:54:29 <ddarius> sclv: They have their Haskell code, but it would be much better if it was directly supported by the language.
11:56:10 <newsham> the RealWorld is still mutable.
11:56:28 <newsham> i blame entropy
11:56:33 <ddarius> RealWorld is an implementation detail and is just a token that has no structure to mutate.
11:56:42 <Deewiant> calling it something other than "RealWorld" might be a good idea
11:56:53 <sclv> conceptually I always liked "RealWorld"
11:56:55 <newsham> the RealWorld has very complex structure.
11:56:55 <Deewiant> I've noticed that a bunch of people I've talked about had a lot of trouble with the concept
11:57:00 <Deewiant> er
11:57:04 <newsham> its just hidden by an abstraction
11:57:05 <Deewiant> s/about/to/
11:57:25 <Deewiant> one thing with "RealWorld" is that it implies that your program is external to the real world
11:57:46 <conal> Deewiant: does it?
11:57:47 <sclv> it's a neat intuition to imagine that the universe outside the processor is collapsed into this little token that you pass around and act on.
11:57:47 <newsham> mathematics isnt external to the physical world?
11:58:19 <Beelsebob> http://hpaste.org/7212 <-- anyone have any idea how to get Cabal to look in my macports directories for glib/gtk?
11:58:28 <sclv> btw, ddarius, thanks, i think i've sort of got where they're going now, and why they focus so much on the generic properties, etc, of species.
11:58:36 <Deewiant> conal: it's of course hard for me to talk about this as I'm not the one that was confused, but I think it does
11:59:39 <conal> as complex as the RealWorld (or RealUniverse more accurately) is, RealWorld->(a,RealWorld) is still not nearly complex enough to model IO, because of concurrency.  interleaving models i've seen have sets of sequences of (RealWorld) states.  yipes!
12:00:40 <newsham> "histories"?
12:00:49 <Deewiant> concurrency is a problem of its own :-P
12:00:59 <conal> so i read IO as short for WeDontHaveAPrayerOfKnowingWhatThisMeans
12:01:26 <newsham> good thing einstein showed that no two things ever happen at the same time :)
12:01:32 <conal> *imperative* concurrency is hard, but not necessarily concurrency itself.
12:02:03 <conal> newsham: did he really?  or did he point out that the idea of simultaneity might not be meaningful.
12:02:22 <newsham> in my small mind I cant tell the difference between those two.
12:02:33 <ddarius> conal: The parts on declarative concurrency in CTM are the main reason I recommended it to you.
12:02:42 <conal> FRP is very concurrent and yet has super simple semantics.
12:02:46 <vixey> CTM has very good sections on concurrency
12:02:48 <conal> ddarius: oh, thx.
12:02:57 <vixey> best stuff I've read
12:03:12 <ddarius> newsham: What's simultanous for you might not be simultaneous to me.
12:03:14 <sclv> CTM?
12:03:20 <edwardk> has there been any progress made on a usable way to work with commutative monads in haskell?
12:03:20 <ddarius> hmm
12:03:22 <ddarius> @google CTM
12:03:25 <lambdabot> http://www.ctmracing.com/
12:03:25 <lambdabot> Title: CTM Racing Products
12:03:38 <ddarius> @google Concepts, Techniques and Models of Computer Programs
12:03:49 <lambdabot> http://www.amazon.com/Concepts-Techniques-Models-Computer-Programming/dp/0262220695
12:04:00 <newsham> ddarius: what is simultaneous for your left eye might not be simultaneous for your left thumb.
12:04:02 <sclv> ah, thanks!
12:04:06 * vixey notes the Oz channel is very empty :P
12:04:08 <ddarius> newsham: Yep.
12:04:34 <newsham> anyway, I probably ventured out of haskell and into -blah
12:04:38 <vixey> (CTM uses Oz to describe thigs)
12:04:55 <sclv> edwardk: you mean where MonadAT MonadBT Identity = MonadBT MonadAT Identity ?
12:05:27 <ddarius> sclv: He means where the two implementation of liftM2 are equivalent.
12:05:29 <sclv> or where do {a; b} = do {b; a} ?
12:05:29 <edwardk> sclv: nah, things like reader, or unique supply, or a memoizing state monad
12:06:20 <sclv> gotcha :-)
12:06:38 <ddarius> edwardk: A long, long time ago I made a hack using TH to give a more applicative notation for monadic code.
12:06:47 <edwardk> i just got bitten in the ass by the lack of a notion of commutative monad for a in a toy kind of memoizing hylomorphism that now has way too much 'ordering' baked into it
12:08:24 <newsham> ?remember edwardk i just got bitten in the ass by the lack of a notion of commutative monad for a in a toy kind of memoizing hylomorphism that now has way too much 'ordering' baked into it
12:08:25 <lambdabot> It is stored.
12:09:26 <dcoutts> Beelsebob: you probably just need the --user flag, or to use cabal-install which uses that by default
12:09:55 <dcoutts> Beelsebob: I'm guessing those packages are registered in your per-user package db, check using ghc-pkg list
12:11:00 <zeno_> how can i test timestamp time in lambdabot? > import Time doesnt work
12:11:23 <ddarius> @hoogle Time
12:11:23 <lambdabot> System.Time :: module
12:11:23 <lambdabot> Data.Time :: module
12:11:23 <lambdabot> System.Timeout :: module
12:12:06 <zeno_> thx
12:12:32 * edwardk wonders what lambdabot remembers about him now.
12:12:34 <edwardk> @quote edwardk
12:12:34 <lambdabot> edwardk says: i just got bitten in the ass by the lack of a notion of commutative monad for a in a toy kind of memoizing hylomorphism that now has way too much 'ordering' baked into it
12:12:39 <edwardk> @quote edwardk
12:12:39 <lambdabot> edwardk says: i just got bitten in the ass by the lack of a notion of commutative monad for a in a toy kind of memoizing hylomorphism that now has way too much 'ordering' baked into it
12:12:41 <edwardk> heh
12:12:43 <edwardk> guess not much
12:12:56 <geezusfreeek> probably even less about me
12:12:59 <ddarius> edwardk: Other than more annoying syntax, there really isn't much of an issue with using monadic syntax for a commutative monad.
12:13:05 <geezusfreeek> @quote geezusfreeek
12:13:05 <lambdabot> geezusfreeek says: "i was half hoping lambdabot would lie and make something up :)"
12:13:20 <geezusfreeek> i do not remember saying that at all
12:13:29 <geezusfreeek> @quote geezusfreeek
12:13:29 <lambdabot> geezusfreeek says: "i was half hoping lambdabot would lie and make something up :)"
12:13:35 <geezusfreeek> mmkay
12:13:44 <zeno_> geezusfreeek: it must not have any quotes from you
12:14:07 <geezusfreeek> eh well, i did say that i guess
12:14:16 <conal> geezusfreeek: About your your haskell-cafe note, how small a test case can you make that reproduces the hang problem?  I've been getting some hangs also that I don't know how to debug, and perhaps it's the same root problem.
12:14:19 <edwardk> ddarius: well, what i want is a way to capture the fact that i functor full of monadic effects that i may or may not need to evaluate and that the order i evaluate them in doesn't matter, so going through and using Traversable to sequence them is too strong
12:15:11 <geezusfreeek> ohâ€¦ i said that once when lambdabot had no quotes of meâ€¦ and then somebody quoted that!
12:16:06 <edwardk> m_hylo' :: (Traversable f, Ord a) => (f b -> b) -> (a -> f a) -> a -> Memo a (f a) b -- or something like that, where Memo a b c is just a state monad holding a Map a b
12:16:35 <geezusfreeek> conal: hmmâ€¦ the one i have right now is pretty small, but it uses a fair bit of other library code i've been working on. it should be pretty easy to separate though
12:16:51 <geezusfreeek> it's really just print <$> someEvent
12:17:25 <geezusfreeek> the someEvent is what uses other library code though
12:17:39 <conal> geezusfreeek: i'd sure appreciate it if you could localize.
12:17:58 <geezusfreeek> conal: alright, i will do thatâ€¦ but laterâ€¦ i have to study a bit for an exam i have tomorrow
12:18:09 <conal> geezusfreeek: exam in what?
12:18:13 <edwardk> the thing is as it stands i'm kinda forced to use sequence and  fmap to inject the memoizing place holders out of the functor. thats fine, but if your catamorphism doesn't need the whole of the datastructure, then you managed to get sharing at the cost of requirng total evaluation of the structure.
12:18:37 <geezusfreeek> heh, Unix Programmingâ€¦ the class is a joke, but there is still a lot of memorizingâ€¦ different shells and such
12:18:38 <cpoucet> edwardk: hey you're a genius
12:18:45 <edwardk> cpoucet: ?
12:18:46 <cpoucet> edwardk: how do I distribute the natural numbers over a binary tree
12:19:04 <edwardk> as in so that you get a unique number in each node?
12:19:08 <cpoucet> edwardk: such that I a) don't have repeittions, b) recursive construction and c) the ability to easily find a node
12:19:19 <cpoucet> edwardk: yeah, I want to use the data-structure in my blog for storing infinite seuqences
12:19:29 <conal> cpoucet: see patricia trees
12:19:31 <cpoucet> data Tree a = Tree (Tree a) a (Tree a)
12:19:32 <edwardk> nice build up to actually get me to actually think about it btw ;)
12:19:38 <cpoucet> ;)
12:19:39 <conal> cpoucet: (IntMap)
12:19:40 <newsham> its a shame the class is a joke, unix is so much fun :)
12:19:49 <cpoucet> conal: no I have a data-structure
12:19:55 <cpoucet> the above tree
12:20:00 <conal> geezusfreeek: anyway, good luck on the exam!
12:20:13 <cpoucet> ccshan suggested it
12:20:20 <cpoucet> just not sure how to map naturals statically to it
12:20:36 <geezusfreeek> conal: thanks!
12:20:38 <cpoucet> the best I can come up with is starting with '1' and then 2*n and 2*n+1
12:20:42 <edwardk> cpoucet writing it up
12:20:47 <cpoucet> but then finding a number would require me to reverse the bits
12:21:10 <geezusfreeek> newsham: i signed up for it thinking it'd be pretty easy, but the differences between all these shells are so subtle yet vast!
12:21:16 <conal> cpoucet: have you read the patricia trees paper?  there are little-endian and big-endian versions.
12:21:39 <newsham> geezusfreeek: well the first thing they should teach you is that if you're writing a script that other people will read, modify and run, it should be written for /bin/sh.
12:21:39 <conal> cpoucet: the techniques may be relevant
12:21:44 <cpoucet> conal: not yet, no
12:21:49 <cpoucet> I'll take a look, thx for the pointer
12:21:57 <newsham> memorizing details of each shell sounds pretty silly
12:21:59 <edwardk> cpoucet: what about just let mkTree n = Tree (mkTree (n*2) n (mkTree (n*2+1)) in mkTree 1
12:22:10 <cpoucet> edwardk: finding a node is a pain then
12:22:30 <geezusfreeek> newsham: well, the teacher is focusing mostly on personal productivity, not on writing scripts for others, but yeah i agree, learning all these shells is just stupid
12:22:36 <geezusfreeek> and HARD!
12:22:41 <edwardk> cpoucet: so, heap ordering is out.
12:22:52 <newsham> geezus: did they cover rc and es? ;-)
12:22:55 <cpoucet> edwardk: What is heap ordering?
12:23:14 <cpoucet> edwardk: the idea is to inject a function (Integer -> a) (where I ensure I only use naturals)
12:23:17 <cpoucet> and then memoizing on the tree nodes
12:23:20 <edwardk> what i just gave, that basically put them in with the nodes numbered as their position in a heap ;)
12:23:21 <geezusfreeek> newsham: nope. the only shells were sh, csh/tcsh, ksh, and bash
12:23:24 <cpoucet> that way your tree only grows to the consumed data-set
12:23:33 <newsham> doesnt sound that bad.
12:23:50 <cpoucet> edwardk: I tried the above structure, but it places your nodes in a rather odd manner
12:24:39 <geezusfreeek> newsham: then we went into awk, sed, perl, tcl, tcl/tk, expect, etc.
12:24:47 <cpoucet> I guess I could do (drop 1 . reverseBits)
12:24:50 <newsham> cpoucet: bit reversal is only as expensive as the tree traversal though, no?
12:24:51 <edwardk> cpoucet: just bitreverse the number and look based on each bit, no?
12:24:51 <cpoucet> and then walk down as required
12:24:53 <geezusfreeek> it's really not so bad. it's justâ€¦ a lot
12:25:00 <cpoucet> edwardk: yeah, just a pain :)
12:25:04 <cpoucet> edwardk: was hoping on an easier system
12:25:14 <newsham> geezusfreeek: those are all useful to know, esp if you ever plan to maintain a unix system
12:25:15 <cpoucet> edwardk: but if I do even odd numbers, you get a lot of repetitions in your tree
12:25:21 <edwardk> cpoucet: then bitreverse during the insertion ;)
12:25:23 <cpoucet> (e.g. 0)
12:25:47 <geezusfreeek> newsham: yeah... i use them a lot, but this is in more depth than i ever felt like i needed to know by heart without reference
12:25:51 <Beelsebob> anyone have any idea how to get Cabal to recognise libraries stored in odd places (in this case /opt/local/lib) http://hpaste.org/7212
12:26:10 <newsham> geezus: you'll clean up on unix trivia night
12:26:21 <dcoutts> Beelsebob: does "ghc-pkg list" list those packages?
12:26:21 <edwardk> hrmm
12:26:36 <dcoutts> Beelsebob: is it in the per-user package db?
12:26:42 <dcoutts> is it/ary they
12:26:54 <Beelsebob> ah, okay, it wants a package for them, not just the libraries
12:26:58 * Beelsebob disapears to hackage
12:27:26 <dcoutts> Beelsebob: three of those are packages in gtk2hs
12:27:32 <dcoutts> which is not in hackage yet
12:27:36 <Beelsebob> ah, okay
12:28:08 <Beelsebob> luckily, it is in MacPorts though :)
12:28:14 <dcoutts> Beelsebob: so the confusion was system vs ghc/haskell packages, I guess we should try and improve the error message to make that clearer, any suggestions?
12:28:50 <edwardk> cpoucet: i don't know that there is really any other option for distributing them
12:29:49 <DuClare> Toxaris, Yay, I think I finally got it.  Mostly at least.
12:29:54 <Beelsebob> dcoutts: Setup.lhs: At least the following dependant Haskell packages are missing:
12:30:00 <Beelsebob> would clarify it enough for me
12:30:30 <Beelsebob> o.O gtk2hs requires perl?
12:30:54 <dcoutts> Beelsebob: not that I'm aware of, but it might be an indirect dependency
12:31:07 <dcoutts> hia nominolo, I'm just resting your fix
12:31:28 <nominolo> resting=testing?
12:32:55 <DuClare> Toxaris, Now I also have instance Combinable Resources where combine = liftA2
12:32:58 <DuClare> Toxaris, Which works
12:33:09 <dcoutts> nominolo: erm, yes :-)
12:33:35 <Toxaris> DuClare: hehe cool!
12:33:35 * Beelsebob ponders if MacPorts is being a noob and not seeing my existing ghc install
12:33:40 * nominolo goes test on his lorels
12:33:49 <nominolo> Beelsebob: it doesn't
12:33:53 <DuClare> Toxaris, One of my problems was that I didn't understand the syntax properly
12:34:04 <Beelsebob> nominolo: it doesn't be a noob, or it doesn't see the existing ghc?
12:34:10 <nominolo> Beelsebob: has to do with controlled environment and stuff, i guess
12:34:25 <Beelsebob> I guess, yeh
12:34:27 <Toxaris> DuClare: hehe yeah that's a problem with Haskell, because it reuses keywords from other languages without reusing their meaning
12:34:28 <DuClare> Toxaris, I was reading the 'a <*> b <*> c ...' piece from right to left :|
12:34:40 <Beelsebob> they could do a ghc-shadow package like they do for apple's X11
12:34:57 <nominolo> Beelsebob: imagine the irreproducable bug reports they would get otherwise
12:35:10 <Toxaris> DuClare: oh ok then this has nothing to do with keywords of course :)
12:35:12 <Beelsebob> true dat
12:35:25 <Beelsebob> oh well, manually building gtk2hs time
12:35:41 <DuClare> Toxaris, Yeah.  I'm still a bit puzzled by the 'pure' piece, although I believe I can clear it up when I look back to it again.
12:35:48 <DuClare> Toxaris, What would be the next step?
12:36:14 <nominolo> Beelsebob: after this GSoC we might be close to gtk2hs-on-cabal
12:36:21 <dcoutts> yay!
12:36:23 <Beelsebob> :)
12:36:56 <sm> where is the sourceview package required by leksah ?
12:37:08 <nominolo> if that doesn't work out, i'm sure dcoutts accepts cheques
12:37:15 <Toxaris> DuClare: there are some more standard typeclasses you could make your Resources type an instance of
12:37:23 <Toxaris> DuClare: to get even more operations for free
12:37:37 <Beelsebob> nominolo: am I going to have fun getting gtk2hs to recognise gtk2 installed via MacPorts?
12:37:44 <Beelsebob> (assuming I don't build it via mac ports too)
12:38:00 <nominolo> Beelsebob: nope. you just have to find the right packages to install
12:38:06 <dcoutts> Beelsebob: no, should be fine, at most you'll have to set some env var
12:38:08 <Zao> Beelsebob: As long as you mangle your include and lib dirs enough, probably not that bad.
12:38:16 <Beelsebob> okies, cool
12:38:23 <Toxaris> DuClare: e.g. Data.Traversable.Traversable and Data.Foldable.Foldable comes to mind
12:38:24 <nominolo> Beelsebob: but be careful with a fink/ports co-install
12:38:29 <Beelsebob> I take it gtk2hs is reasonably good at spitting out "you're missing these deps"
12:38:36 <Beelsebob> nominolo: yeh, I don't have fink installed on this box
12:38:55 <dcoutts> Beelsebob: it'll tell you if it cannot find gtk and what env var to set to point it in the right place
12:38:57 * sm thinks: in gtk2hs
12:38:59 <nominolo> Beelsebob: yes.  it gives a summary of all extensions it found at the end
12:39:08 <Beelsebob> cool :)
12:39:13 <Toxaris> DuClare: but I think instead of learning more abstract stuff, you should try out what you already know
12:39:20 <DuClare> Toxaris, There's one fancy repetition in there right now, though. :|
12:39:29 <Toxaris> DuClare: yeah which one?
12:39:31 * Beelsebob leaves MacPorts to build gtk2 then
12:40:35 <DuClare> Toxaris, liftA can be used for instancing the Resources Functor.  But that method depends on the Applicative, which is okay since we have the applicative anyway.  But if we also wanted to use liftA for Soldier's fmap, then it too needs Applicative
12:40:53 <DuClare> Toxaris, The Applicatives for Soldier and Resources look exactly the same except for the names.
12:41:01 <Toxaris> DuClare: Oh have you learned about Monads yet? Some applicative functors are also monads, which gives another operation additional to <$>, <*> and pure. and monads are pretty useful because they can encapsulate a lot of stuff
12:41:19 <DuClare> Toxaris, No, I haven't looked into monads yet
12:41:39 <Toxaris> DuClare: unfortunately, your Resources type is not a Monad :( so we need a different running example for this one
12:41:55 <Toxaris> DuClare: but first about your "except for the names" problems
12:42:22 <Toxaris> DuClare: this is a big problem with most existing languages in my eyes, that they can't abstract (statically typesafe) over names
12:42:48 <Toxaris> DuClare: so the short answer is: Haskell fails here.
12:43:10 <Toxaris> DuClare: the long answer is: there are tools which look at the structure of the datatype and produce the typeclass instances automatically
12:44:03 <Toxaris> DuClare: these tools come in two flavors: either as preprocessors (more or less integrated with the compiler) or as libraries
12:45:17 <Toxaris> DuClare: the preprocessors are fully automatic, the libraries rely on information the programmer provides. The idea is to define type class which capture the structure of data types. then the programmer needs to write appropriate instances for all of his data types to point out their structure, and the instances for the various other type classes can be infered 'cause of the structure
12:45:45 <Toxaris> DuClare: obviously, you can combine these approaches, by using a preprocessor to produce the structure instances
12:46:10 <Toxaris> DuClare: but I have never used such a system, so someone else has to give you real examples
12:46:45 <DuClare> I'll try to keep it in mind.  I guess it's topic not so important at this stage. :)
12:46:54 <Toxaris> another option (which I have experimented with) is to avoid using data declarations, and structurally define your data types instead.
12:47:41 <Toxaris> e.g. instead of data Resources = Resources Int Int Int use type Resources = Int :
12:47:48 <Toxaris> e.g. instead of data Resources = Resources Int Int Int use type Resources = Int :*: Int :*: Int
12:48:12 <Toxaris> where data (:*:) a b = (:*:) a b
12:48:29 <Toxaris> but I guess this is too advanced (and to unimportant) at this point
12:48:37 <DuClare> Yeah
12:48:48 <DuClare> Do you think monads would be the next topic?
12:48:54 <Toxaris> yeah guess so
12:48:57 <DuClare> Hmm.
12:49:02 <Toxaris> but first you should *really* understand applicative functors
12:49:12 <Toxaris> have you looked at the list applicative functor?
12:49:21 <DuClare> Is there such a thing?
12:49:44 <Toxaris> DuClare: I guess that's a no :)
12:49:48 <DuClare> Yeah
12:49:59 <Toxaris> your Resources basically is a list of fixed length 3
12:50:10 <DuClare> I thought list was merely a functor
12:50:23 <Toxaris> list is a lot of stuff
12:50:27 <DuClare> :)
12:50:36 <Toxaris> i think lambdabot can somehow point out the instances of a type, but i don't know how
12:50:41 <Toxaris> @instances []
12:50:42 <lambdabot> Plugin `instances' failed with: regex failed: (ReturnCode 7,"Unmatched [ or [^")
12:50:49 <Toxaris> :(
12:50:57 <Toxaris> @help instances
12:50:58 <lambdabot> instances <typeclass>. Fetch the instances of a typeclass.
12:51:14 <DuClare> Lst?
12:51:23 <sieni> what a suprising description
12:51:30 <Toxaris> I want the other direction
12:51:38 <DuClare> Indeed
12:52:27 <Toxaris> DuClare: when you wrote your instance Applicative Resources, which really is a instance Applicative FixedListOfLengthThree, you had to decide which element combine with which for <*>
12:52:53 <DuClare> Yup
12:52:56 <Toxaris> DuClare: I suppose you've chosen to combine the first element of boths list, the second elements of both lists and the third elements of both lists
12:53:05 <DuClare> Exactly
12:53:16 <Toxaris> this is called zipping for hopefully obvious reasons
12:53:38 <Toxaris> there actually is a function zipWith wich does something similar to lists
12:53:40 <Toxaris> :t zipWith
12:53:41 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
12:54:13 <Toxaris> this is related to combine, if you want to look at <*>:
12:54:17 <mofmog> you know what'd be great? an arclisp interpreter in haskell
12:54:24 <Toxaris> :t zipWith ($)
12:54:25 <DuClare> So a could be a list of functions and b could be values fed to the function?
12:54:25 <lambdabot> forall a b. [a -> b] -> [a] -> [b]
12:54:39 <byorgey> mofmog: people were working on that when arc first came out.  but then lost interest.
12:54:40 <Toxaris> DuClare: exactly!
12:54:50 <mofmog> byorgey: ??
12:55:03 <Toxaris> DuClare: in this very moment, I realize that you can define <*> in terms of combine
12:55:20 <edwardk> cpoucet: bitreversed, but with the msb = 1, yields the sequence: 1, 2, 3, 4, 6, 5, 7, 8, 12, 10, 14, 9, 13, 11, 15, ... you can walk down it without bitreversal and check for if you are at the bottom by checking to see if your bit shifted 'remainder' = 1
12:55:31 * cpoucet nods
12:55:34 <cpoucet> edwardk: cool, thanks
12:56:14 <byorgey> mofmog: like a couple days after PG released arc, some people in here decided to implement it in Haskell, just to show how silly and trivial it was
12:56:25 <byorgey> but I think they got bored and didn't finish it
12:56:39 <edwardk> so the decendant of a node, say 5, which has bits 101 are 1001 and 1101, 9 and 13 respectively
12:56:53 <Toxaris> DuClare: so we could define instance Applicative [] where ... in a similar way to how instance Applicative Resources work
12:56:54 <byorgey> edwardk, cpoucet: whatcha talking about?
12:56:56 * cpoucet nods
12:57:01 <cpoucet> byorgey: encoding a sequence in a tree
12:57:09 <Toxaris> DuClare: do you see how. are there any problems we hadn't with Resources?
12:57:20 <edwardk> just look at your msb at each point and walk down based on that, (shifting it) then stop check your 'seed' has been reduced to 1.
12:57:27 <edwardk> er look at your lsb i mean
12:58:05 <edwardk> byorgey: cpoucet was looking for a way to label a tree with naturals so that it could be walked quickly to find a node with a particular natural
12:58:17 <edwardk> but he didn't want to pay for bit-reversal during lookup
12:58:25 <DuClare> Toxaris, I think the problem would be the amount of umm.. "parameters" ?
12:58:42 <DuClare> Toxaris, Both lists aren't neccessarily equally long :o
12:58:50 <edwardk> so i contorted the sequence to get the bit-reversal during insertion and while keeping the list of numbers unique globally
12:59:00 <Toxaris> DuClare: yes exactly!
12:59:01 <edwardk> i'm sure its probably on sloane somewhere =)
12:59:34 <DuClare> Toxaris, How would we remedy this?
12:59:39 <edwardk> yep. http://www.research.att.com/~njas/sequences/?q=1%2C2%2C3%2C4%2C6%2C5%2C7%2C8%2C12%2C10%2C14%2C9%2C13%2C11%2C15&language=english&go=Search
12:59:40 <lambdabot> Title: 1,2,3,4,6,5,7,8,12,10,14,9,13,11,15 - OEIS Search Results, http://tinyurl.com/6jovn9
13:00:03 <Toxaris> DuClare: there are two quite different options, and both are good, so we will implement both and let the user choose.
13:00:21 <byorgey> edwardk: ah, cool
13:00:28 <Toxaris> DuClare: first option: we throw away all parameters we can't handle
13:00:41 <Toxaris> DuClare: this is how the zipWith function works
13:01:03 <Toxaris> > zipWith (+) [1, 2, 3, 4, 5, 6] [10, 10]
13:01:05 <lambdabot>  [11,12]
13:01:14 <byorgey> hah, I knew it would have some relationship to the Stern-Brocot tree =)
13:01:32 <edwardk> http://www.research.att.com/~njas/sequences/?q=1%2C3%2C2%2C7%2C5%2C6%2C4%2C15%2C11%2C13%2C9%2C14%2C10%2C12%2C8&sort=0&fmt=0&language=english&go=Search was the result of my first pass at it before i simplified it
13:01:33 <lambdabot> Title: 1,3,2,7,5,6,4,15,11,13,9,14,10,12,8 - OEIS Search Results, http://tinyurl.com/5b2uww
13:02:16 <edwardk> that version seems to have the nice property that it is its own inverse
13:02:34 <byorgey> they're both self-inverse.
13:02:38 <edwardk> ah good point
13:02:55 <dcoutts> nominolo: yay, works for me :-)
13:03:00 * dcoutts pushes patches
13:03:13 <Toxaris> DuClare: can you implement the instance Applicative [] for this first option?
13:03:19 <Toxaris> DuClare: hint: you can use zipWith!
13:03:29 <dcoutts> nominolo: I'll try doing some more testing and do another Cabal-1.4 pre-release
13:03:44 <dcoutts> nominolo: I might have a go at getting the old test code to compile
13:03:51 <DuClare> Toxaris, Do I have to use zipWith?
13:03:54 <nominolo> dcoutts: i only tested with cabal-install
13:04:01 <DuClare> Hmm.
13:04:03 <dcoutts> nominolo: that's ok
13:04:11 <mofmog> byorgey: how is it trivial?
13:04:25 <Toxaris> DuClare: no of course not, you can write it "from scratch", and it may well be that you learn more this way
13:04:47 <DuClare> Toxaris, I'm not sure at all if this is right but..
13:04:49 <byorgey> mofmog: it's just some macros on top of lisp.  which you can already do in lisp.
13:05:02 <DuClare>     (f:ff) <*> (v:vv) = (f v):(ff <*> vv)
13:05:08 <nominolo> dcoutts: i'd like to have the feeling of assurance after 1000+ quickcheck tests have passed
13:05:26 <byorgey> mofmog: I must admit I haven't really tried it out myself.  it might be cooler than it seems.
13:05:31 <DuClare> Would that work?  With another case to handle it when one list is empty ...  like [] <*> _ = []
13:05:41 <DuClare> But the problem is, I'm not sure if I got the costructors right
13:05:48 <dcoutts> nominolo: aye, if you have any more test cases or informal properties, send them in
13:05:48 <DuClare> (Does the latter have a constructor at all?)
13:05:52 <byorgey> DuClare: yup, and you need a case for the rhs being empty too
13:06:08 <byorgey> DuClare: looks right to me!
13:06:08 <Toxaris> DuClare: well, try it :) or are you still experiencing these ghc slowness problems?
13:06:11 <dcoutts> nominolo: we should record what properties we think hold even if we don't have a framework yet to plug them into
13:06:40 <Toxaris> DuClare: unfortunately, lambdabot can't handle class, data or instance declarations, so we can't try it out "live" :(
13:07:05 <byorgey> DuClare: try implementing it using zipWith also, and compare the approaches
13:07:11 <DuClare> Toxaris, what do I hide to get rid of the duplicate declaration?  I'm importing Control.Applicative
13:07:32 <Toxaris> DuClare: hmm. that's a problem :( basically, it's not possible :(
13:07:37 <DuClare> Huh. :o
13:07:47 <Toxaris> DuClare: general idea: instances are very super extra public. you cannot avoid importing them
13:08:00 <byorgey> DuClare: just don't import Applicative, and declare the Applicative class yourself for now
13:08:16 <Toxaris> DuClare: you will learn a work-around soon, but for now ... what byorgey said. copy the code for Applicative
13:08:27 <byorgey> class Applicative f where pure :: a -> f a ; (<*>) :: f (a -> b) -> f a -> f b
13:08:47 <dcoutts> nominolo: I was thinking, something that'd make it easier to express some properties, we should have a value representing the configuration of a package, then the search just returns one of those, and we can apply a configuration to a GenericPackageDescription to get a PackageDescription
13:09:16 <dcoutts> nominolo: I guess it'd be just a total flag assignment and perhaps also the exact dependencies
13:09:55 <dcoutts> nominolo: though I guess there are circumstances where one just wants to apply a flag assignment and get back the dependencies
13:10:07 <dcoutts> the flexible/range dependencies I mean
13:11:09 <nominolo> dcoutts: http://hpaste.org/7215
13:11:49 <DuClare> Toxaris, I'm not sure how to define pure
13:11:54 <chessguy> 'afternoon, haskellers
13:11:56 * Beelsebob ponders where to get System.Glib.UTFString from
13:12:02 <Beelsebob> it appears to be part of Gtk2hs
13:12:05 <Beelsebob> but it won't build without it
13:12:29 <chessguy> pure |pyoÅr|
13:12:29 <DuClare> Toxaris, I actually tried pure f = [f..]
13:12:29 <chessguy> adjective
13:12:29 <chessguy> not mixed or adulterated with any other substance or material
13:12:30 <dcoutts> Beelsebob: it is part of gtk2hs, it's in the glib package
13:12:34 <nominolo> Beelsebob: can you paste the error?
13:12:50 <Beelsebob> dcoutts: oh, hang on, there's an earlier error
13:12:51 <Beelsebob> sec
13:13:02 <Toxaris> DuClare: that's the correct idea!
13:13:12 <Toxaris> DuClare: but the syntax doesn work
13:13:25 <dcoutts> nominolo: I'm trying to interpret that
13:13:34 <nominolo> dcoutts: heh
13:14:16 <Beelsebob> http://hpaste.org/7216 <-- that's the whole stream of errors
13:14:49 <dcoutts> nominolo: env |- <cond> ~~> true  is a property?
13:14:52 <nominolo> given a package "P" and an environment (os, arch, flag-assignment): if the condition evaluates to true, then package "foo" with some version "X" must be in the chosen dependencies
13:15:00 <Toxaris> DuClare: I'm not sure how to introduce this the best way.
13:15:11 <nominolo> and X must fulfill the given constraints
13:15:20 <dcoutts> nominolo: ah
13:15:28 <Toxaris> DuClare: well what do you want (pure f) to be, described in english?
13:15:45 <dcoutts> nominolo: so it's explaining the constraint that build-depends puts on the condition
13:15:47 <nominolo> dcoutts: the second "==>" should be "/\" actually
13:15:49 <DuClare> Toxaris, I was thinking about an infinite list whose elements are all f
13:16:02 <nominolo> dcoutts: yes, but the other way round
13:16:07 <YourAlgebra> afternoon
13:16:12 <Toxaris> DuClare: yeah that sounds good. now, what is the first element of that list?
13:16:14 <dcoutts> Beelsebob: ghc-6.8.2: could not execute: /usr/local/lib/ghc-6.8.2/ghc-asm
13:16:21 <dcoutts> Beelsebob: that doesn't look good
13:16:39 <Beelsebob> indeed
13:16:50 <dcoutts> Beelsebob: check that your ghc works, that it can make a hello world for example
13:16:53 <DuClare> Toxaris, Uhm. f
13:16:56 <zeno_> can type signatures be on multiple lines (ones > 80 chars)
13:17:00 <Toxaris> DuClare: (I'm going for somewhat stupid rhetorical questions here, I hope that is ok for you)
13:17:03 <Beelsebob> dcoutts: ghc works, ghc-asm doesn't exist
13:17:13 <Toxaris> DuClare: yep, so we can start with   pure f = f :
13:17:23 <dcoutts> Beelsebob: that's really not good :-)
13:17:25 <Toxaris> DuClare: but we have to fill in the rest of the list. What is the rest of the list?
13:17:37 <dcoutts> Beelsebob: the means you cannot compile -fvia-C
13:17:57 * Beelsebob notes that the standard install of ghc on mac appears broken
13:18:08 <Baughn> Beelsebob: Well, there isn't one. ;)
13:18:09 <nominolo> dcoutts: ~~> is evaluation
13:18:10 * Beelsebob dumps it and gets MacPorts to install it
13:18:11 <dcoutts> Beelsebob: right, looks that way, you can try building with -fasm
13:18:30 <dcoutts> nominolo: ah ok
13:18:33 <DuClare> Toxaris, f ...  I'm thinking of some recursion, combining f with the list itself, but no clue how to do that :]
13:18:39 <nominolo> (big-step semantics)
13:19:03 <Toxaris> DuClare: nope, the rest of the list is not f. If I have an infinite list of f's, and I take away one f, what is left?
13:19:13 <dcoutts> nominolo: and deps is part of the environment?
13:19:26 <DuClare> An infinite list of f :o
13:20:01 <Toxaris> DuClare: exactly. and which function we have already defined expressed exactly this?
13:20:11 <nominolo> dcoutts, it's part of the result.  it's still a bit sketchy
13:20:47 <DuClare> Hmmm..
13:21:14 <Toxaris> DuClare: Hint: recursion is a very good idea!
13:22:10 <DuClare> Toxaris, Let me think..  When did we define it?
13:22:26 <DuClare> pure f?
13:22:31 <Toxaris> DuClare: yes!
13:22:34 * byorgey cheers
13:23:01 <chessguy> @type let p f = f : p f in p
13:23:02 <lambdabot> forall a. a -> [a]
13:23:36 <chessguy> @pl let p f = f : p f in p
13:23:36 <lambdabot> fix (ap (:))
13:23:52 <Toxaris> chessguy: :)
13:24:46 <Toxaris> so pure for ZipList is fix <$> (<*>) $ (:) for normal list
13:24:58 <Toxaris> can this be justified by CT?
13:25:47 <chessguy> @unpl ap (:)
13:25:47 <lambdabot> (\ e -> (:) >>= \ b -> e >>= \ a -> return (b a))
13:27:06 <Saizan_> ?ty fix <$> (<*>) $ (:)
13:27:07 <lambdabot> forall a. a -> [a]
13:28:05 <DuClare> Toxaris, Something's up though
13:28:40 <DuClare> Toxaris, Or maybe not.
13:28:42 <DuClare> :]
13:29:43 <edwardk> cpoucet: still around?
13:29:47 <daveux> So I'm calling System.system on a process that takes about a second to terminate, and I want to be able to execute that process more than once per second, so I do something like this:
13:29:59 <daveux> > forkIO $ system "my_proc"
13:30:00 <lambdabot>   Not in scope: `system'
13:30:18 <sarehu> daveux: try forkOS?
13:30:24 <edwardk> @tell cpoucet mkTree = mkTree' 1 1 where mkTree' h n = Tree (mkTree' h2 (n+h2)) n (mkTree' h2 (n+h)) where h2 = h * 2
13:30:24 <lambdabot> Consider it noted.
13:30:31 <DuClare> Toxaris, I think I'm going to leave the zipWith version for tomorrow
13:30:33 <daveux> that has different behavior?
13:30:41 <DuClare> Toxaris, Got school so I can't stay up all night :)
13:31:09 <sarehu> yes, calls inside a forkOS thread won't block calls outside the thread
13:31:13 <sarehu> or at least system shouldn't
13:31:20 <daveux> ok, will try
13:31:25 <edwardk> @tell cpoucet mkTree = mkTree' 1 1 where mkTree' h n = Tree (mkTree' h2 (n+h)) n (mkTree' h2 (n+h2)) where h2 = h * 2 -- alternate labeling
13:31:26 <lambdabot> Consider it noted.
13:31:30 <Saizan_> do you compiled with -threaded?
13:31:37 <Saizan_> *compile
13:32:10 <sarehu> er, maybe what Saizan said, I think I'm being an idiot here
13:32:42 <daveux> Compile ghc?
13:32:47 <daveux> No, I didn't :(
13:32:50 <sarehu> daveux: right, read http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html#osthreads and use -threaded
13:32:51 <lambdabot> http://tinyurl.com/33wpmr
13:33:19 <dmwit> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html#3
13:33:20 <lambdabot> http://tinyurl.com/33wpmr
13:33:34 <dmwit> Does this mean you can choose between cooperative and pre-emptive scheduling?
13:33:39 <dmwit> It's a little ambiguous there.
13:33:45 <mattam> @type unsafeCoerce
13:33:47 <lambdabot> Not in scope: `unsafeCoerce'
13:34:05 <dmwit> (It talks about the behavior of both, but doesn't say which one actually happens.)
13:34:07 <Saizan_> daveux: not ghc, i mean your program
13:34:25 <daveux> Right, I tried... Without -threaded, system will block all threads?
13:34:37 <daveux> system uses ffc interface?
13:34:55 <sarehu> dmwit: I think they're talking about haskell implementations there
13:35:15 <daveux> I added ghc -threaded, I must have done it wrong.
13:35:21 <Saizan_> without threaded every syscall will block all threads afaiu
13:35:29 <cpoucet> edwardk: eah
13:35:29 <lambdabot> cpoucet: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:35:48 <sarehu> daveux: make sure it's recompiling every file -- some were compiled without -threaded and they won't be recompiled unless they were touched
13:35:59 <daveux> ok
13:36:06 <DuClare> Toxaris, One thing though..  Can I now somehow utilize pure to actually generate the infinite list to be used with <*> and another list?
13:36:25 <daveux> omg! You guys just saved my ass.
13:37:02 <daveux> I'm working on a Haskell drum machine, and I was using system to pass generated midi files (haskore) to an external midi player.
13:37:04 <DuClare> Toxaris, Or do I use map in cases like that?
13:37:32 <daveux> Now I can go faster than 30 bpm :)
13:39:42 <Beelsebob> >.<
13:39:48 <Beelsebob> the MacPorts version of ghc doesn't build
13:39:58 <chessguy> Beelsebob: it just built for me the other day
13:40:04 <chessguy> on OS X
13:40:21 <Beelsebob> configure: error: GHC is required unless bootstrapping from .hc files.
13:40:32 <Beelsebob> and that's even with ghc installed!
13:40:50 <geezusfreeek> Beelsebob: port sync?
13:41:25 <geezusfreeek> i just built ghc on both intel and ppc a couple weeks ago
13:42:13 <chessguy> mine was on intel, and was literally just a couple days ago
13:42:33 <Beelsebob> this is intel too, and with a pre-existing ghc install (but not from mac ports)
13:43:14 <edwardk> cpoucet: find (Tree l a r) n = if n == 1 then a else find (if mod n 2 == 1 then r else l) (n `div` 2)
13:44:23 * Beelsebob cleans and fetches again, hope it works this time
13:46:03 <DuClare> Oh well, I really need to get some sleep now.  Good night, thanks for your time & help, Toxaris and the others. :)
13:48:32 <vorner> Hello, I'm trying to launch and control mplayer from a haskell program, but I can not find a way how to do that (I didn't find dup, do I look wrong?)
13:48:52 <vorner> thanks for any hints
13:49:02 <Beelsebob> vorner: what do you mean by "control" mplayer?
13:49:22 <Baughn> vorner: Dup? How do you get from "control mplayer" to "have to explicitly duplicate FDs"?
13:49:23 <vorner> Beelsebob: well, I want to send something to its stdin
13:49:26 <Baughn> vorner: There are higher-level APIs
13:49:47 <Beelsebob> vorner: so all you want is essentially, fork, exec, and the ability to send text through pipes?
13:49:59 <vorner> Beelsebob: well, yes
13:50:16 <vorner> but just that the pipe must be connected to it's stdin
13:50:38 <vorner> which is done by dup2, ususally
13:51:25 <vorner> (and I found fork and exec, there seemed to be some note about handles not working, so I will have to test that)
13:51:28 <Beelsebob> vorner: look at System.system
13:51:38 <vorner> Ok, thanks
13:51:47 <Beelsebob> and the various other functions in System
13:52:26 <Beelsebob> not so sure about setting up the pipe
13:53:10 <zeno___> lambdabots @pl teaches me alot :)
13:53:11 <vorner> I saw something in Network.Socket
13:54:31 <ziman> vorner, isn't there popen() interfaced somewhere?
13:55:00 <vorner> ziman: I found only notes that there is not one
13:55:21 <vorner> but there seems to be some runInteractiveCommand, which seems ok
13:55:28 <vorner> thanks a lot :-)
14:01:00 <zeno___> is there a simpler way to do positionList b = let s = (length b) - 1 in [[(x, y) | y <- [0..s]] | x <- [0..s]]
14:03:19 <Toxaris> DuClare: hi sorry I was away for some time. sure you can use pure, just, well, use it :)
14:03:27 <Toxaris> > pure 3 :: Maybe Int
14:03:28 <lambdabot>  Just 3
14:03:40 <Toxaris> > pure 14 :: Ziplist Int
14:03:40 <lambdabot>   Not in scope: type constructor or class `Ziplist'
14:03:42 <Toxaris> :(
14:04:22 <Saizan_> > pure 5 :: ZipList Int
14:04:23 <lambdabot>   add an instance declaration for (Show (ZipList Int))
14:04:31 <Toxaris> DuClare: you can use functions introduced by type classes exactly like you use normal functions.
14:04:41 <Toxaris> > getZipList $ pure 5
14:04:42 <lambdabot>  [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
14:05:09 <BornToLag> hi if i am recursively running through a list using (x : xs) how do i test when there is no more tail i.e. the list end
14:05:26 <Toxaris> BornToLag: add another case for []
14:05:47 <Toxaris> e.g. f (x:xs) = ... <newline here> f [] = ...
14:06:04 <zeno___> BornToLag: you can use pattern matching, so myFunc [] = someVal \n myFunc (x:xs) = ...
14:06:32 <bugQ> semicolons work too
14:07:04 <BornToLag> ahh I see... i'm using a guard and wasn't sure
14:07:36 <Toxaris> BornToLag: a guard would work too, but pattern matching is typically a better choice where applicable
14:08:06 <BornToLag> great thanks i'll try that
14:08:49 <olsner> this thing just doesn't seem to work in the Writer monad as it does with putStr and IO
14:13:15 <kamaji> BornToLag: ohi
14:14:09 <BornToLag> hai
14:21:56 <byorgey> BornToLag: by the way, note that pattern-matching (x:xs) guarantees that the list will *not* be empty -- in other words, only non-empty lists will match the pattern (x:xs)
14:23:25 <BornToLag> ahh very handy thanks
14:24:05 <byorgey> if you want to match any list, you can just use a single variable as a pattern, like xs -- which will match anything.
14:24:27 <byorgey> but as others have pointed out, typically when dealing with lists you do want to have two separate cases, one for [] and one for (x:xs)
14:25:42 <Bonus> many a time list functions with (x:xs) and [] can be reduced to a foldl
14:25:44 <Bonus> or foldr
14:26:08 <dmwit> Always, in fact.
14:26:29 <Bonus> really?
14:26:53 <eugman> hey besides gcd, what's a 2 input numerical function  in prelude that doesn't have a symbolic equivalent
14:27:02 <BornToLag> cool
14:27:14 <dmwit> eugman: What do you mean by symbolic?
14:27:41 <eugman> syntactic sugar, so no add or subtract
14:27:59 <dmwit> const, lcm
14:28:09 <Bonus> hmm how would you reduce this to a fold
14:28:12 <dmwit> min, max
14:28:14 <eugman> thanks
14:28:28 <Bonus> @let pairs (x:y:xs) = (x,y):(pairs xs)
14:28:29 <lambdabot> Defined.
14:28:32 <Bonus> @let pairs [] = []
14:28:33 <lambdabot> Defined.
14:28:47 <dmwit> That's not a list function with (x:xs) and []. ;-)
14:28:54 <Bonus> oh
14:28:55 <dmwit> But you can still do it.
14:28:55 <Bonus> :D
14:28:57 <Bonus> right-o
14:28:58 <Bonus> haha
14:28:59 <Toxaris> > L.pairs [1]
14:29:00 <lambdabot>  Exception: <local>:(13,0)-(14,12): Non-exhaustive patterns in function pairs
14:29:32 <MyCatVerbs> > let { pairs (x:y:zs) = (x,y): pairs zs; pairs [] = [] }
14:29:33 <lambdabot>  Parse error at end of input
14:29:50 <MyCatVerbs> Awww. That works in ghci.:/
14:29:58 <dmwit> It works here, too.
14:30:04 <Bonus> just use @let
14:30:06 <dmwit> > let { pairs (x:y:zs) = (x,y): pairs zs; pairs [] = [] } in pairs [1, 2]
14:30:07 <lambdabot>  [(1,2)]
14:30:16 <MyCatVerbs> dmwit, Bonus: ooh, thanks.
14:30:17 <dmwit> > let { pairs (x:y:zs) = (x,y): pairs zs; pairs [] = [] } in pairs [1] -- this is still an error
14:30:18 <lambdabot>   Non-exhaustive patterns in function pairs
14:30:45 <Bonus> yeah it's still an error but that cool in my case
14:31:08 <Bonus> i used that function when i got alternating lines of variable names and values through stdio
14:31:12 <Bonus> and had to make a Map out of them
14:31:19 <sclv> what am I missing here?
14:31:20 <sclv> http://hpaste.org/7218
14:31:40 <sclv> I've got a functional dependencies conflict for something that it seems I should be able to cleanly express.
14:32:30 <zeno___> how (could) would i turn checkRulesValidity from http://hpaste.org/7217 into a fold?
14:32:54 <sclv> overlapping and undecidable instances don't help for this...
14:33:46 <Bonus> you could foldl with the accumulator set to True
14:34:01 <Bonus> and then && it with the thing you got there
14:34:06 <Bonus> on each element in the foldl
14:34:14 <sclv> actually, I'm a bit braindead at the moment -- can't even tell why the fundeps should be overlapping at all.
14:34:30 <zeno___> Bonus: ah, thanks
14:35:00 <Bonus> but i think just because you can reduce every function that has (x:xs) and [] to a foldl doesn't mean you should :)
14:35:12 <dmwit> right
14:35:15 <Bonus> if it's readable and concise this way, which I think it is, leave it
14:35:19 <MyCatVerbs> Bonus: yes you should. :P
14:35:40 <sclv> I can get rid of the second SqlType a => instance and just replace it with a zillion unrolled by hand, but that's irritatingly painful.
14:35:44 <Bonus> a good example of when you should reduce to a foldl is this
14:35:45 <Bonus> http://hpaste.org/7193
14:35:55 <Bonus> which i revised then to this http://hpaste.org/7198
14:36:03 <MyCatVerbs> Bonus: and if you find yourself writing foldl (&&), you should write "all" instead, too. ^^
14:36:20 <Bonus> hehe yeah
14:37:35 <zeno___> Bonus: nice =p
14:37:53 <Bonus> hehe it's also a pretty cool functio
14:37:54 <Bonus> n
14:38:04 <Bonus> evaluates an expression with operators and everything
14:38:16 <Toxaris> @let pairs' = uncurry zip . foldr (first . (:) ||| second . (:)) ([], []) . zipWith id (cycle [Left, Right])
14:38:17 <lambdabot> Defined.
14:38:43 <Toxaris> > (pairs' [], pairs' [1..3], pairs' [1..4])
14:38:44 <lambdabot>  ([],[(1,2)],[(1,2),(3,4)])
14:39:02 <dmwit> http://hpaste.org/7219
14:39:10 <Bonus> what does Left and Right do
14:39:14 <dmwit> Bonus: That's one way to fold-ize your pairs function.
14:39:18 <zeno___> Toxaris: wow that looks alot more confusing :"
14:39:36 <Toxaris> > Left 3
14:39:37 <lambdabot>  Left 3
14:39:39 <Toxaris> > Right 3
14:39:41 <lambdabot>  Right 3
14:39:44 <Bonus> dmwit cool
14:39:58 <Toxaris> Bonus: Left and Right are just data constructors
14:40:11 <Bonus> yeah but i mean what are they used for
14:40:13 <wjt> Toxaris: nice
14:40:18 <Bonus> i see they're value constructors of the Either type
14:40:23 <Bonus> but i haven't done much with that so far
14:40:29 <Toxaris> Bonus: in general or in my pairs'?
14:40:38 <Bonus> in general
14:41:19 <MyCatVerbs> When you want disjoint pairs.
14:41:44 <dmwit> Any laws for (foldr f [] . foldr g [])?
14:41:47 <Toxaris> let's say you want either an String or an Int at some point in your program, and you don't know statically which, you can use type (Either String Int). if it's a string, it looks like (Left "hello"), if it's a number, it looks like (Right 42)
14:41:51 <MyCatVerbs> For example, I have a dinky brokenly-implemented parser somewhere around here which parses numbers to Either Integer Double, depending on format.
14:42:09 <Bonus> ah i see
14:42:11 <Bonus> cool stuff
14:42:29 <dmwit> ?. free type foldr
14:42:31 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
14:42:33 <Toxaris> Bonus: you could use data NumberOrString = Number Int | String String
14:42:37 <dmwit> ?type foldr
14:42:38 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:42:43 <MyCatVerbs> Then I can later match against (Left i) in contexts where only an integer will do, or use a helper function that converts (Left i) to (Right d) where I want to allow upcasting to a double.
14:42:47 <dmwit> ?free (a -> b -> b) -> b -> [a] -> b
14:42:47 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
14:42:50 <dmwit> ?free foldr
14:42:51 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
14:42:57 <Bonus> aha
14:43:01 <ddarius> MyCatVerbs: f :: String -> Either Int Double; f = Right . read
14:43:05 <Toxaris> Bonus: but sometimes it's handier to use Either, because you don't need to define a *named* data type, and you can use predefined functions for Either, like the (|||) operator I used in my snippet
14:43:28 <Bonus> kewl
14:44:09 <Toxaris> Bonus: actually, using Either, pairs like (String, Int) and a fancy type named Fix, you can build all types you can build with Haskell's data definitions
14:44:26 <MyCatVerbs> ddarius: I really don't want to allow people to use doubles to index into arrays. :P
14:44:26 <Bonus> hmmm
14:44:58 <Toxaris> Bonus: using Either is like using "|" in a data definition, using a pair is like using " " (space) in a data definition, and using Fix is like, hmm, defining a recursive type.
14:45:29 <Toxaris> Bonus: so, in a sense, data definitions can be seen as syntactic sugar for stuff like Either :)
14:45:41 <sclv> any help on my fundeps problem?
14:45:53 <sclv> otherwise i'll just bite the bullet and unroll the second declaration.
14:45:55 <Bonus> oh so those types can kind of map into syntax
14:46:09 <Bonus> sclv sorry br0 i'm a noob myself :)
14:46:51 <Toxaris> Bonus: well I would say: syntax can map into these types
14:47:00 <Bonus> yeah
14:47:11 <Dino__> hey
14:47:15 <Bonus> haskell owns
14:47:35 <dmwit> Hiya, Dino__!
14:47:40 <Bonus> i've been learning it for like two weeks now and it's displaced python as my fav language :)
14:50:23 <Dino__> I have a little problem, if anyone could give me a solution please,
14:50:26 <Toxaris> zeno___: but it is easy. the general structure is pairs' = makePairOfListIntoListOfPairs . makeListOfEithersIntoPairOfList . applyLeftAndRightAlternately
14:50:41 <Toxaris> Dino__: The answer is 42.
14:51:09 <Dino__> haha
14:51:16 <Dino__> displayPlaylistDetails :: [Playlist] -> [PlaylistDetails]
14:51:18 <Dino__> displayPlaylistDetails [] = []
14:51:19 <Dino__> displayPlaylistDetails ((t,a,p,l,n,g):xs) = ("Title: " ++ t,
14:51:21 <Dino__> 					    "Artist/Composer: " ++ a,
14:51:23 <Dino__> 					    "Performer: " ++ p,
14:51:24 <Dino__> 					    "Duration: " ++ (show l)) : displayPlaylistDetails xs	
14:51:24 <dmwit> Wait!
14:51:30 <dmwit> ?hpaste
14:51:30 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:51:40 <ddarius> Dino__: That's called map
14:51:41 <dmwit> That's the preferred place for longish code snippets. =)
14:52:22 <Toxaris> zeno___: but instead of writing these easy functions in an obvious way, i used some combinators from Control.Arrow, mainly to embed my earlier efinition of makeListOfEithersIntoPairOfList which I'm quite proud of
14:52:25 <Saizan_> a 7 tuple!
14:52:37 <dmwit> ...6
14:52:48 * Saizan_ can't count
14:53:00 <ddarius> Saizan_: That's why we have computers.
14:53:11 <Dino__> when I add the following (g) ,    ((t,a,p,l,n,g):xs)     I get an error, because can't have more than 5 elements in the x:xs   list
14:53:44 <Dino__>  Instance of Read ([Char],[Char],[Char],Int,Int,[Char]) required for definition of displayPlaylistDetailsInput
14:54:11 <Toxaris> Dino__: :)
14:54:14 <ddarius> Dino__: Are you using Hugs?
14:54:17 <dmwit> First, that error is in a different function. ;-)
14:54:21 <Dino__> but if I just put,  ((t,a,p,l,n):xs)  without the 5th, which was g, it works,
14:54:21 <dmwit> Second: yeah, that sucks.
14:54:40 <dmwit> I think there's no instances for the usual nice things for tuples of big size.
14:54:45 <dmwit> So: here's my suggestion.
14:54:52 <dmwit> Use a record data type instead.
14:54:53 <Dino__> I am in hugs yes
14:55:05 <dmwit> For example:
14:55:26 <dmwit> data PlaylistEntry = PlaylistEntry { title :: String, artist :: String, ... }
14:55:35 <gwern> @hoogle min
14:55:35 <lambdabot> Prelude.min :: Ord a => a -> a -> a
14:55:35 <lambdabot> Data.Ord.min :: Ord a => a -> a -> a
14:55:35 <lambdabot> Prelude.minBound :: Bounded a => a
14:55:42 <dmwit> Then you can do:
14:55:48 <gwern> > min 100 1000
14:55:49 <lambdabot>  100
14:55:58 <dmwit> data PlaylistEntry = PlaylistEntry { ... } deriving (Read, Show, Eq, Ord)
14:56:08 <ddarius> @hoogle minimumBy
14:56:08 <dmwit> And get most of the usual functions that you want for free.
14:56:08 <lambdabot> Data.List.minimumBy :: (a -> a -> Ordering) -> [a] -> a
14:56:08 <lambdabot> Data.Foldable.minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
14:57:36 <Dino__> how could I refer to the g element , when I use the above example ?
14:58:20 <dmwit> With the syntax "data Foo = Foo { bar :: String, baz :: Int }", the compiler creates two functions.
14:58:27 <zeno___> Toxaris: yes quite cleaver :) i just didnt get alot of the syntax
14:58:29 <dmwit> bar :: Foo -> String
14:58:30 <dcoutts> nominolo: I'm making the testsuite run again, found one bug already :-)
14:58:33 <dmwit> baz :: Foo -> Int
14:58:47 <nominolo> dcoutts: oh, what was it?
14:58:56 <dmwit> That is, each name in the brackets defines a function that takes a value of the data type and returns the corresponding record.
14:58:59 <dcoutts> nominolo: parsing licenses
14:59:06 <dmwit> Dino__: Was that too confusing? =P
14:59:16 <dcoutts> nominolo: missed a case for the BSD4 license
14:59:29 <Dino__> :P yeah
14:59:31 <ddarius> Who uses BSD4?
14:59:43 <dcoutts> ddarius: nobody uses it on purpose
14:59:54 <dcoutts> cabal now warns as much
15:00:07 <dcoutts> suggesting the you almost certainly meant BSD3
15:00:16 <gwern> hm. what is 4kb exactly? 4096 bytes?
15:00:18 <dmwit> Dino__: ok
15:00:24 <ddarius> gwern: Yes
15:00:26 <dcoutts> > 1024 * 4
15:00:27 <lambdabot>  4096
15:00:27 <dmwit> Dino__: Are you familiar with the "data" syntax?
15:00:45 <dmwit> Dino__: i.e. do you know what "data Foo = Foo String | Bar Int" would do?
15:00:46 <ddarius> Kids not knowing their powers of two.  What do they teach them these days?
15:01:22 <gwern> ddarius: I was jes' uncertain, is all
15:01:28 <gwern> ddarius: they teach us base-10 :)
15:02:17 <Toxaris> are 4k the same on RAM and HDD?
15:02:55 <Dino__> yes, I've known the data syntax,
15:03:36 <Toxaris> Dino__: as a start, you can use displayPlaylistDetails (PlaylistDetails t a p l n g : xs) = ...
15:04:09 <Toxaris> Dino__: this should solve your problem with missing instances for tuples
15:04:11 <Dino__> i see, by using the data definition was introduced by dmwit ?
15:04:34 <Toxaris> Dino__: yep.
15:04:48 <Dino__> mm, very interesting
15:05:07 <Toxaris> Dino__: It would be enough to write data PlaylistDetails = PlaylistDetails String String Int Whatever ...
15:05:21 <wjt> how controversial is record punning?
15:05:34 <Toxaris> Dino__: but by using the syntax dmwit suggested, you get these access functions for free
15:10:02 <zeno___> is there a built in function that does something like m x | x>0=1;m<0=-1;_=0
15:10:12 <dmwit> :t signum
15:10:13 <lambdabot> forall a. (Num a) => a -> a
15:10:16 <zeno___> thx
15:10:40 <dmwit> signum (0.5 :+ 0.5)
15:10:46 <dmwit> > signum (0.5 :+ 0.5)
15:10:47 <lambdabot>  0.7071067811865475 :+ 0.7071067811865475
15:10:50 <dmwit> ;-)
15:11:07 <dmwit> > signum (0 :+ 0)
15:11:08 <lambdabot>  0.0 :+ 0.0
15:12:56 <zeno___> neat apparently *** is map for pairs
15:13:21 <dmwit> Kind of, yes. =)
15:13:34 <dmwit> (Although it's a bit more general than that, I guess.)
15:15:19 <Toxaris> :t (***)
15:15:21 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
15:15:45 <Toxaris> :t (***) :: (a -> b) -> (c -> d) -> (a, c) -> (c, d)
15:15:46 <lambdabot>     Couldn't match expected type `b' against inferred type `c'
15:15:46 <lambdabot>       `b' is a rigid type variable bound by
15:15:46 <lambdabot>           the polymorphic type
15:16:04 <Toxaris> :t (***) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
15:16:05 <lambdabot> forall a b c d. (a -> b) -> (c -> d) -> (a, c) -> (b, d)
15:16:13 <zeno___> lost me at "Arrow"
15:16:14 <dmwit> Aha!
15:16:30 <zeno___> also what do the 's mean
15:16:36 <Toxaris> :t map
15:16:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:16:46 <dmwit> zeno___: ' is a valid character in type variable names.
15:17:05 <Toxaris> so map uses one function on all elements of some structure, while *** gives a function for each element of the structure
15:17:06 <dmwit> zeno___: So just read a' as z and you'll be fine. =)
15:17:12 <zeno___> ah thx :)
15:17:29 <zeno___> wierd it picks a' INSTEAD of z tho
15:17:33 <Toxaris> this is similiar to (<*>)!
15:17:37 <Toxaris> :t (<*>)
15:17:39 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
15:17:40 <dmwit> zeno___: As for the Arrow bit, well, (***) is a function on something more general than functions called Arrows.
15:17:54 <Toxaris> :t curry (***)
15:17:56 <lambdabot>     No instance for (Arrow (,))
15:17:56 <lambdabot>       arising from a use of `***' at <interactive>:1:6-10
15:17:56 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
15:18:02 <dmwit> zeno___: It didn't pick a', the (human) authors did.
15:18:23 <Toxaris> :t curry
15:18:24 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
15:18:28 <dmwit> It is supposed to help readability.
15:18:32 <zeno___> ah, is a' somehow related to a?
15:18:32 <Toxaris> :t uncurry (***)
15:18:34 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
15:19:04 <Toxaris> :t uncurry (***) :: (a -> b, c -> d) -> (a, c) -> (b, d)
15:19:05 <dmwit> zeno___: Technically, no; but they are often used when there is some "intuitive" connection.
15:19:05 <lambdabot> forall a b c d. (a -> b, c -> d) -> (a, c) -> (b, d)
15:19:14 <dmwit> zeno___: For example, in the type of (***):
15:19:16 <dmwit> :t (***)
15:19:17 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
15:19:28 <Toxaris> dmwit, zeno___: conclusion: *** is like <*> for pairs
15:19:32 <dmwit> zeno___: The connection between b and b' is that they are the "inputs" of the two Arrows.
15:19:52 <dmwit> zeno___: (And the connection between c and c' is that they are the "outputs".)
15:20:05 <zeno___> oh, ok
15:20:17 <dmwit> Technically, they can still range over any type.  But the primes help us understand a little.
15:21:04 <dmwit> Incidentally, I really miss the Monoid instance for Ordering when I'm working in other languages. =/
15:21:39 <dibblego> ?src Monoid Ordering
15:21:39 <lambdabot> Source not found. :(
15:21:48 <dibblego> ?src mappend Ordering
15:21:48 <dmwit> ?src mplus Ordering
15:21:48 <lambdabot> Source not found. Maybe you made a typo?
15:21:48 <lambdabot> Source not found. You type like i drive.
15:21:54 <dibblego> yeah that
15:22:11 <dmwit> Well, anyway, it's (Eq `mplus` x) == x, (x `mplus` _) = x.
15:22:23 <dibblego> ah right
15:22:25 <dmwit> So:
15:22:36 <dmwit> compare (a, b) = compare a `mplus` compare b
15:22:59 <EvilTerran> err
15:23:17 <dmwit> Am I wrong again?
15:23:25 <EvilTerran> (a,b) `compare` (c,d) = (a `compare` c) `mplus` (b `compare` d)
15:23:33 <dmwit> oh, yes
15:24:02 <dmwit> mplus on (uncurry compare) ? =P
15:24:15 <dmwit> `on`
15:24:16 <EvilTerran> except it should be mappend
15:24:21 <Toxaris> compare = uncurry mplus . compare *** compare
15:24:52 <Toxaris> dmwit: uncurry compare would compare a with b and c with d
15:25:03 <dmwit> yeah
15:25:05 <Toxaris> dmwit: instead of a with c and b with d
15:25:22 <dmwit> ANYway, so maybe it isn't so bug-free in Haskell either (for me).
15:25:22 <Toxaris> :t uncurry mappend . compare *** compare -- let's try it
15:25:24 <lambdabot>     Couldn't match expected type `(a, a)'
15:25:24 <lambdabot>            against inferred type `a1 -> Ordering'
15:25:24 <lambdabot>     Probable cause: `compare' is applied to too few arguments
15:25:34 <dmwit> But it certainly was an odd bug in C++. =/
15:25:41 <Toxaris> once again, used *** on binary functions. :(
15:31:54 <MyCatVerbs> Gah. Anyone have any ideas on how to debug a Parsec parser?
15:32:21 <MyCatVerbs> I have one here that isn't behaving anything *like* how I expect it to. Frankly, I'm bewildered.
15:32:53 <Toxaris> :t (uncurry mappend .) . uncurry (***) . (compare *** compare) -- dmwit: but fortunately I realized that (uncurry (***)) is like <*> for pairs some minutes ok, so I can apply that knowledge now :)
15:32:55 <lambdabot> forall a b'. (Ord b', Ord a) => (a, b') -> (a, b') -> Ordering
15:33:05 <yitz> MyCatVerbs: start out by making sure you have plenty of <?> annotations
15:34:12 <MyCatVerbs> yitz: tried that. It's breaking expecting a token that AFAIK it should never under any circumstances want at that point. :/
15:34:27 <dmwit> > let c (a, b) (c, d) = compare a c `mappend` compare b d in map (uncurry c) [((a, b), (c, d)) | [a, b, c, d] <- replicateM 4 [True, False]]
15:34:28 <lambdabot>  [EQ,GT,GT,GT,LT,EQ,GT,GT,LT,LT,EQ,GT,LT,LT,LT,EQ]
15:34:48 <Toxaris> :t (uncurry mappend .) . uncurry (***) . join (***) compare -- alternative formulation
15:34:50 <lambdabot> forall b. (Ord b) => (b, b) -> (b, b) -> Ordering
15:35:22 <dmwit> ?pl \(a, b) (c, d) -> compare a c `mappend` compare b d
15:35:22 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. compare) . flip . (((.) . mappend) .) . compare)
15:35:31 <Toxaris> oups, less polymorphic because of join :(
15:36:03 <Toxaris> pl should learn about Control.Arrow
15:36:17 <dmwit> Anyway, the point is that the point-ful one is pretty easy to write.
15:36:21 <monochrom> MyCatVerbs: That means the parser has gone down a path you were unaware of.
15:37:09 <monochrom> If your parser goes through a sequence of <|> choices, it may commit to the left while you think it commits to the right.
15:37:29 <monochrom> If your parser goes through a loop, it may finish earlier or later than you think.
15:37:40 <MyCatVerbs> monochrom: any way to diagnose that?
15:38:27 <TSC> You could try littering some trace calls
16:03:33 <MyCatVerbs> Hrmn. Tracing isn't making this much clearer. :/
16:04:46 <EvilTerran> paste?
16:06:50 <monochrom> Some program structures are undebuggable.
16:07:39 <EvilTerran> these should either be avoided or proven correct before you use them :P
16:08:32 * MyCatVerbs is starting to feel tempted to round-file Parsec and just write a recursive descent parser by hand.
16:08:49 <MyCatVerbs> EvilTerran: this is pretty damn long. :/
16:09:11 <monochrom> testing is an approximation to proving. depending on your testing technique, it may be an extremely close approximation.
16:09:22 <monochrom> Some program structures are untestable.
16:09:30 <OceanSpray> how do I "split" an array into two?
16:09:41 <monochrom> If it's untestable, nevermind proving.
16:09:44 <MyCatVerbs> monochrom: that's great, except that this isn't doing what I think the source code says it will.
16:10:04 <OceanSpray> is there a function for that, or do I have to do it manually?
16:10:04 <MyCatVerbs> monochrom: therefore my model of what the library does is incorrect.
16:10:38 <MyCatVerbs> monochrom: therefore I have no hope whatsoever of ever even attempting a proof of correctness, since I'm obviously working from some quantity of broken assumptions.
16:10:53 <MyCatVerbs> It'd be nice if I had some clue what those assumptions were, though.
16:12:43 <Dino__> I've got an error, I have posted it
16:12:45 <Dino__> Cheers
16:12:55 <monochrom> I have never written more than 100 lines of code without first rigorously verifying my assumptions about the libraries and languages I use.  I am incapable of doing that.
16:13:14 <MyCatVerbs> monochrom: it's kind of awkward to write half a parser.
16:14:19 <MyCatVerbs> monochrom: the longer I spend on this, the more I feel like throwing my keyboard through my monitor. :/
16:16:16 <monochrom> Do not think of it as writing half a parser.
16:17:29 <monochrom> If you think of a project as "write one parser", its structure will be untestable, unprovable, undebuggable, uncomprehensible.
16:18:37 <monochrom> The project should be "write a hundred little parsers and combining them in so-and-so way". Then you have little testable, comprehensible parsers; you can also test whether the way of combination is right or wrong.
16:20:46 <lispy> monochrom: and then generalize by replacing parser with "function" or "method" or "small piece of code"
16:25:25 <ddarius> @quote dark
16:25:25 <lambdabot> apfelmus says: Ah, yet another UndeadArray necromancer exhausting his stack of bones. May the forces of light suggest to structure the incantation of darkness?
16:26:48 <hgolden> Hi. While emerging lhs2tex, pdfTeXk is looking for stmaryrd.sty and module.sty. Are these in gentoo somewhere? If not, where can I find them?
16:27:25 <hgolden> Sorry! This was for gentoo-haskell.
16:28:17 <MyCatVerbs> monochrom: a collection of small parsers that work individually but break without leaving any clue as to why when put together are just as useless as the same thing written all in one go.
16:28:43 <MyCatVerbs> monochrom: furthermore, I'm sick and tired of rewriting this shit repeatedly. This gets more irritating every single time I touch it.
16:32:31 <MyCatVerbs> @pl \a b -> line a == line b
16:32:31 <lambdabot> (. line) . (==) . line
16:32:54 <MyCatVerbs> @pl \a b -> (line a) == (line b)
16:32:54 <lambdabot> (. line) . (==) . line
16:34:05 <Toxaris_> MyCatVerbs: (==) `on` line?
16:34:30 <MyCatVerbs> Toxaris_: looks like.
16:37:10 <bugQ> sounds like a cheesy pro-tolerance slogan: equality is online!
16:45:41 <Dino__> @ Toxaris, hi I  have posted an error I get, would you mind to have a quick look , thanks :)
16:50:48 <twanvl> Dino__: You can't construct a PlaylistDetails with "(a,b,c,d)", that creates a tuple. You should use "PlaylistDetails a b c d"
16:50:51 <mux> simon marlow's rewrite of System.Process looks very nice
16:53:06 <Dino__> I see, @ twanvl  thanks, can I still use (a b (show c) d)?
16:53:32 <twanvl> "(a b (show c) d)" calls the function 'a' with three parameters
16:53:52 <dbpatterson> I'm working on a library wrapper to the smugmug (photo sharing site) api... does anyone have a minute (or the desire) to take a look at it (a minimal protoypish version) to critique the model of it?
16:54:04 <Dino__> because at the Playlist c is String, and at PlaylistDetails , is   [Playlist] -> [PlaylistDetails]
16:54:07 <dbpatterson> before I go through the tedious process of putting in every function that the api supports
16:54:52 <dbpatterson> it is based on curl, and done in a (hopefully) haskellish way (type safety, etc)... however, this is the first thing of any significance I've written in haskell, so...
16:54:52 <Dino__> **Correction because at the Playlist c is String, and at PlaylistDetails , is Int   , which comes from [Playlist] -> [PlaylistDetails]
16:59:13 <dbpatterson> well, posted if anyone wants to check it out... http://hpaste.org/7222
17:04:34 <Dino__> @twanvl   I posted an update on the code you checked, can you please take a look? thanks!
17:04:34 <lambdabot> Unknown command, try @list
17:04:48 <Dino__> @ twanvl I posted an update on the code you checked, can you please take a look? thanks!
17:05:38 <clanehin_> dbpatterson: minor, but you might use deriving (Show) instead of custom instances.  Typically, show gives you valid haskell code.  It's minor and maybe some people would even disagree.
17:06:50 <twanvl> Dino__: to be able to display values the types need to be instances of the class Show (and for reading of the class Read). You can either give the instance yourself with "instance Show PlaylistDetails where show = ..." or you can add "deriving (Read,Show)" to the data declaration.
17:09:23 <clanehin_> dbpatterson: and ljr and ljra are fmap jread and fmap (map jread) respectively.
17:10:18 <clanehin_> mr is fromMaybe empty_object
17:11:04 <clanehin_> dbpatterson: seems like a respectable start, though.
17:11:09 <Dino__> @twanvl Thanks a lot, I will check that and let you know :))
17:11:09 <lambdabot> Unknown command, try @list
17:12:18 <eugman> I know I probably shouldn't even try it but why does  map putStr ["one","long","word"] not work?
17:12:43 <dibblego> eugman, because it won't type check; you want mapM_
17:12:47 <dibblego> ?type putStr
17:12:49 <lambdabot> String -> IO ()
17:13:01 <dibblego> actually, it will type-check :)
17:13:02 <wjt> well, it will typecheck, and you will get [IO ()]
17:13:11 <dibblego> right; it won't have evaluated
17:13:48 <eugman> Also, is there a way to insert a endline character?
17:14:02 <dibblego> ?type putStrLn
17:14:03 <lambdabot> String -> IO ()
17:14:06 <dibblego> ?type mapM_
17:14:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
17:14:11 <eugman> No i mean literally
17:14:16 <dibblego> ?type mapM_ putStrLn
17:14:17 <lambdabot> [String] -> IO ()
17:14:18 <eugman> like "\n" doesn't work
17:14:26 <wjt> yes, yes it does
17:14:29 <eugman> hmm
17:14:46 <dibblego> ?type mapM_ putStrLn ["one","long","word"]
17:14:47 <lambdabot> IO ()
17:14:50 <dibblego> you want that
17:14:55 <wjt> try Â« putStr "hello\n new line!\n" Â» in ghci
17:15:02 <dibblego> do you want "\n" in between?
17:15:09 <dibblego> ?type mapM_ putStrLn $ lines ["one","long","word"]
17:15:11 <lambdabot>     Couldn't match expected type `Char' against inferred type `[Char]'
17:15:11 <lambdabot>     In the expression: "one"
17:15:11 <lambdabot>     In the first argument of `lines', namely `["one", "long", "word"]'
17:15:22 <eugman> ok nvm it works. For somereason "\n" by itself didn't.
17:15:29 <dibblego> ?type mapM_ putStrLn $ unlines ["one","long","word"]
17:15:31 <lambdabot>     Couldn't match expected type `String' against inferred type `Char'
17:15:31 <lambdabot>       Expected type: [String]
17:15:31 <lambdabot>       Inferred type: String
17:15:34 <dibblego> bah
17:16:22 <eugman> What I wanted was mapM_ putStr ["one","long","word","\n"] which works
17:16:39 <dibblego> ok
17:17:25 <jaj> Hi! If I have [[a]] and I have func :: a -> b and I want [[b]], is the best thing to do map (map func) [[a]] or is there something more elegant?
17:17:58 <jorick> that's a pretty elegant way already imo
17:18:00 <Saizan_> (map . map) func, if you prefer
17:18:36 <Saizan_> (there's a "deepfunctor" implementation somewhere, but not really worth the trouble)
17:18:45 <jorick> :t map . map
17:18:47 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
17:19:09 <TSC> :t Data.List.map . Data.List.map
17:19:11 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
17:19:35 <jorick> @hoogle map
17:19:35 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
17:19:35 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
17:19:35 <lambdabot> Data.ByteString.map :: (Word8 -> Word8) -> ByteString -> ByteString
17:20:06 <jaj> indeed I prefer (map . map). thanks!
17:25:34 <gwern> > 1 `notElem` [1..100]
17:25:36 <lambdabot>  False
17:25:42 <gwern> > 1 `notElem` [2..100]
17:25:43 <lambdabot>  True
17:26:18 <sarehu> there is a 'notElem'?? :S
17:27:32 <geezusfreeek> @src notElem
17:27:33 <lambdabot> notElem x =  all (/= x)
17:27:42 <geezusfreeek> @src all
17:27:42 <lambdabot> all p =  and . map p
17:28:03 <geezusfreeek> nice, simple definitions there
17:30:53 <sbahra> @hoogle snd
17:30:53 <lambdabot> Prelude.snd :: (a, b) -> b
17:30:53 <lambdabot> Data.Tuple.snd :: (a, b) -> b
17:35:04 <dbpatterson> clanehin_: cool, thanks.. the reason why some deriving of Show are specialized is I am using them in a (semi) abused way to spit out valid parts of the url.. ie, the Session is printed out as "SessionID=_whatevertheidis_" ... and I'll fix the fmap stuff, thanks :)
17:36:29 <clanehin_> dbpatterson: cool, the only other thing is, in all the un* functions, if you use those a lot, you'll have annoying-to-track-down pattern match errors if you accidentally pull something of the wrong type
17:36:58 <dbpatterson> clanehin_: and while ljr is fmap jread, I dont think ljra is the same... it has to do with how JSON arrays are shown, I believe.. it changes the type from ljra :: JRead a => Maybe J.Value -> Maybe [a] to ljra :: JRead a => Maybe [J.Value] -> Maybe [a] I think...
17:37:21 <clanehin_> dbpatterson: Let me look at it again
17:37:26 <dbpatterson> clanehin_: hmm. I've been worrying about that a little... is there an easier way though?
17:38:16 <clanehin_> dbpatterson: not really, just use them as little as possible, and you can use something like fromMaybe (error "this went wrong in this function") so that you know where to look
17:39:08 <clanehin_> dbpatterson: it's not like you're using them in places where they ever should fail
17:39:29 <dbpatterson> assuming the json doesnt come back structered a different way, yes.
17:39:59 <dbpatterson> well, anyway, thanks for the advice.. I guess I'll try to tidy it up and add enough functionality to actually use it :)
17:40:36 <dbpatterson> all this because I wanted to be able to show a random photo on my haskell powered website :)
17:40:43 <clanehin_> dbpatterson: you're right, you have to unwrap the J.Array.
17:41:40 <clanehin_> dbpatterson: pretty nifty.
17:41:41 <dbpatterson> clanehin_: actually, ghc pointed it out to me (ahh, the beauty of static typing....)
17:42:35 <dbpatterson> actually, hmm, I did have one question
17:42:49 <dbpatterson> mainly about how to construct the data types
17:43:00 <chessguy> 'ello
17:43:35 <dbpatterson> what I'm doing now (as should be apparent) is data types for anything that seems decently isolated, and then composing them (via nested jread's, essentially), to build the types
17:43:40 <dbpatterson> this works well when it is simple
17:44:24 <dbpatterson> well, actually, the question is how to easily allow for optional fields... is there a cleaner way than just putting in tons of Maybe types?
17:44:54 <dbpatterson> because this means I have to test the JSON for the field before trying to read it...
17:45:46 <clanehin_> dbpatterson: does test JSON == a round trip to the server?
17:45:52 <dbpatterson> nope, not at all
17:45:57 <dbpatterson> its more how to keep the code clean
17:46:18 <clanehin_> dbpatterson: I would just use maybe then.  It's more a matter of getting practice with how to use maybe
17:46:28 <dbpatterson> all these 'if jmember "blah" then jread "blah" else nothing" suck.. of course, I could move the testing into the fields themselves...
17:46:47 <dbpatterson> hmm.. that could work (would involve restructuring a little bit...)
17:47:20 <dbpatterson> that does seem the most logical thing - let the field trying to read itself decide if it exists or not :P
17:48:53 <clanehin_> dbpatterson: I think you're on the right track.  Also look at the Maybe monad and Control.Applicative, you can write functions like combineMaybeThings <$> one_maybe_thing <*> another_maybe_thing <*> yet_another_maybe_thing
17:49:48 <dbpatterson> is that a sort of first fail trickles down?
17:50:13 <clanehin_> dbpatterson: if any of them are nothing, then the whole expressing is, yes
17:51:02 <ddarius> dbpatterson: If some repetitive code is getting annoying, abstract it.
17:52:22 <dbpatterson> ddarius: thanks :P
17:52:38 <dbpatterson> (programming 101)
17:54:09 <Saizan> is there a name for a structure like a graph, but where there can be an edge between a node and another edge?
17:55:16 <Pseudonym> Not that I know of, but there are generalisations of graphs where "edges" are relations between sets of three nodes, rather than the traditional 2.
17:57:07 <edwardk> Saizan: sounds like something impredicative. E = (V,E) you have a set containing itself. What stops you from having an edge from a node to the edge itself from that node?
17:57:40 <chessguy> edwardk: sanity :)
17:57:45 <edwardk> chessguy: heh
17:59:06 <Saizan> heh yeah :)
18:00:25 <Saizan> i'd need this to model dependencies when compiling, the fact itself that a module depends on others to compile depends on the content of the module
18:00:29 * edwardk is starting to get fed up with the computational zoology that is this hylomorphism stuff. There should be a way to build one kind of rule and a way to glue together monad/comonad transformers to get the laws you want if you want something apomorphic over another comonad, etc. rather than writing 60 versions of the same basic logic with some combinators swapped
18:01:26 * chessguy is sure he would thoroughly agree with edwardk if he had a clue what he just said
18:01:27 <edwardk> Maybe Laemmel and Rypacek's ExpLemmaLib stuff: http://www.uni-koblenz.de/~laemmel/expression/src/ is a step in the right direction
18:01:32 <lambdabot> Title: The ExpLemmaLib
18:01:52 <ddarius> chessguy: He wants combinator combinators.
18:02:02 <chessguy> naturall
18:02:03 <chessguy> y
18:02:12 <edwardk> chessguy: anamorphisms are like a general unfoldr and catamorphisms are a generalized foldr. hylomorphisms are a foldr/unfoldr pair.
18:02:59 <edwardk> the thing is there are various generalizations of ana and catamorphisms that all basically come down to the fact that i can parameterize an anamorphism with a monad and a catamorphism with a comonad. and so i can build a 'generalized hylomorphism' that allows you to do both.
18:03:25 <edwardk> the thing is since no one really realized this and the 'general' construction is a little painfully general people picked up bits of functionality along the way and gave them new names
18:03:55 <lispy> what is a co-slurpy?
18:04:11 <edwardk> jason: i dunno, it has something to do with the coffee comonad
18:04:20 <lispy> heh
18:04:35 <lispy> no, really darcs has a funtion, co_slurp...
18:04:49 <lispy> a normal slurpy is a way to lazily read a directory tree
18:04:56 <edwardk> heh
18:06:03 <edwardk> chessguy: so basically i'm just fed up with the fact that every possible permutation of choice of comonad/monad has a name. i think what i want to do is bite the bullet and define just a small set of distributive law combinators that let you 'roll your own' generalized hylomorphism
18:08:07 <edwardk> then if you want to return multiple levels of data at once you use a free monad. if you want to do an 'apomorphism' which allows you to basically do an anamorphism that can optionally supply an infinite tail directly and get out of the way then
18:08:11 <edwardk> you can use an EitherT monad transformer. (unforunately haskell's ErrorT monad is broken for purposes of this)
18:08:37 * lispy blinks
18:08:38 <edwardk> and you can lift the distributive law for to one for that extra feature
18:08:45 <lispy> edwardk: I'll take your word for it :)
18:12:12 <Pseudonym> @let halton' p invp 0 = 0
18:12:13 <lambdabot> Defined.
18:12:35 <Pseudonym> @let halton' p invp n = let (q,r) = n `divMod` p in fromIntegral r * invp + h' p (invp / fromIntegral p) q
18:12:36 <lambdabot> <local>:17:71: Not in scope: `h''
18:12:42 <Pseudonym> @let halton' p invp n = let (q,r) = n `divMod` p in fromIntegral r * invp + halton' p (invp / fromIntegral p) q
18:12:43 <lambdabot> Defined.
18:12:57 <Pseudonym> @let halton n = (halton' 2 (1/2) n, halton' 3 (1/3) n)
18:12:58 <lambdabot> Defined.
18:13:03 <Pseudonym> > halton 2
18:13:04 <lambdabot>  (0.25,0.6666666666666666)
18:13:32 <dolio> edwardk: Any thoughts on what to call the dual of dynamorphisms?
18:13:38 <Pseudonym> @let inQuadrant (x,y) = if x*x + y*y <= 1.0 then 1 else 0
18:13:39 <lambdabot> Defined.
18:14:01 <Pseudonym> >  map ((*4) . fromRational . uncurry (%)) . tail . scanl (\(t,n) b -> (t+b,n+1)) (0,0) . map (inQuadrant . halton) $ [1..]
18:14:02 <lambdabot>  [4.0,4.0,4.0,4.0,4.0,4.0,3.4285714285714284,3.5,3.5555555555555554,3.6,3.272...
18:14:03 <edwardk> dolio: call it a codynamorphism ;) i think we need to stop the zoo somewhere ;)
18:14:20 <Pseudonym> >  (!!1000) . map ((*4) . fromRational . uncurry (%)) . tail . scanl (\(t,n) b -> (t+b,n+1)) (0,0) . map (inQuadrant . halton) $ [1..]
18:14:21 <lambdabot>  3.148851148851149
18:14:53 <edwardk> dolio: oh, and i put in code for generalized zygomorphisms in Chronomorphism.hs. you can implement a zygomorphism over an arbitrary generalized catamorphism. thats what prompted my 'hey maybe i should stop writing all these damn functions' kick
18:15:05 <Pseudonym> >  (*4) . fromRational . uncurry (%) . (!!10000) . tail . scanl (\(t,n) b -> (t+b,n+1)) (0,0) . map (inQuadrant . halton) $ [1..]
18:15:06 <lambdabot>  3.144885511448855
18:15:07 <edwardk> and i think i'm just going to write a small set of distributive law combinators
18:15:30 <Pseudonym> Hmm.  Converges kinda slowly.
18:15:40 <edwardk> then you can say g_hylo distCata distCata (liftCata f) (liftAna f)      or something like that
18:16:20 <EvilRanter> lovely
18:16:31 <dolio> edwardk: I thought zygo was already g_para or something.
18:16:55 <edwardk> dolio: sure, but i can parameterize a zygomorphism with a comonad as well =)
18:17:12 <edwardk> because i can use the reader comonad transformer to transform that comonad
18:17:15 <dolio> Oh yeah. I'm looking at it now.
18:17:26 <edwardk> remember how g_dyna had two generalizations?
18:17:39 <edwardk> thats why i think i just want distributive law combinators
18:18:05 <dolio> Yeah, but it turned out one subsumed both, no?
18:18:22 <edwardk> dolio: sure, in that sense g_hylo subsumes them all, so we can go home =P
18:18:31 <dolio> g_hylo . distribCofree, but that illustrates your point.
18:18:43 <edwardk> and g_dyna is pretty damn boring, you have to do a lot of plumbing to use it.
18:19:19 <edwardk> so i think i'm going to see how far i can go with just little apoDistT style distributive law transformers
18:19:19 <dolio> Well, quite frankly, I have trouble figuring out what exactly most of the g_ functions are good for.
18:19:44 <dolio> Besides specializing them to get non-g_ functions that people have already investigated.
18:19:52 <edwardk> actually they are rather easy once you see the role for each generalization
18:20:53 <edwardk> just think of each class of distributive law in isolation, thats why i think the law transformer stuff is the right path
18:21:27 <edwardk> coz i don't think about g_dyna i think oh, to unfold it i want to be able to give it all at once or return multiple levels at once or plod through one at a time or ...
18:21:39 <edwardk> and on the catamorphic side i want to ...
18:21:51 <dolio> Yeah. I see what you mean.
18:22:11 <edwardk> the zoo is actively getting in the way ;)
18:23:17 <dolio> Finding example uses for all of them isn't easy, either.
18:23:19 <dbpatterson> clanehin_: if you're still here - I'm putting all the checking into the actual JRead class (which makes sense...) - so its interface is class JRead c where jread :: J.Value -> Maybe c - this should work, aside from putting tons more stuff into the maybe monad (which shouldnt be an issue). what I'm realizing is I really should not be doing any map accesses without first verifying that what I'm trying to pull out is indeed in th
18:23:19 <dbpatterson> derive*
18:23:19 <dbpatterson> is this templatehaskell stuff?
18:23:21 <edwardk> so to get there i need to write an EitherT (ApoT?) monad transformer that doesn't require Error on the left
18:23:35 <dolio> I pulled a futu and a dyna example out of a couple papers, for the docs.
18:24:00 <edwardk> i have a couple of chronomorphisms i'm writing up to blog about at some point here
18:24:29 <EvilRanter> ... now you're just making words up
18:24:35 <clanehin_> dbpatterson: it can be, but there are some derives built into ghc that you don't need any specials for data X = X Int deriving (Show) is haskell98.
18:25:01 <clanehin_> dbpatterson: That's the kind of thing I've found worked well in the past.
18:25:03 <dbpatterson> clanehin_: but no way to get ghc to derive my typeclass?
18:25:14 <clanehin_> dbpatterson: not for custom typeclasses, no.
18:25:23 <dbpatterson> damn.
18:25:32 <edwardk> gg_apo (which was when i finally said 'ok fuck this') can be used to let you parameterize an apomorphism with both an optional infinite tail (as Nu f) or jump multiple levels because its a Free monad wrapper around the Either that gives you the apomorphism bit
18:25:43 <clanehin_> dbpatterson: there are some derive libraries that I haven't used that make it easier.
18:26:21 <edwardk> apo/zygo are special because the monads/comonads preserve Either/Pair stuff, so they can always be applied as 'transformers' so they are worthwhile notions to keep
18:26:32 <edwardk> EvilTerran: actually i did make up chronomorphism ;)
18:27:09 <edwardk> EvilTerran: i needed a word to talk about something that subsumed futu- histo- and dyna- morphisms, and it bounced around the channel a few times and came back as that
18:28:27 <Dino__> A big thank you to everyone here giving help! I 've managed to solve out some hard for me problems
18:28:30 <edwardk> dolio: i suppose i'm going to have to dig out my comonad transformer library stuff and actually use it here, because a few should respect lifted distributive laws like pair.
18:28:34 <EvilTerran> i see
18:29:16 <dbpatterson> clanehin_: hmm.. I could just make (</>) :: J.Value -> String -> Maybe J.Value - and put all the checking into the actual accessor.
18:29:49 <dbpatterson> or make a new </> (named something else) of that type.
18:31:41 <dolio> Well, I might stick (g_)codyna in, and try to roll up a release.
18:32:00 <dolio> And then worry later about whether most of them should be blown away in favor of talking about distributive laws.
18:32:17 <edwardk> yeah
18:32:41 <dolio> I don't have to worry about breaking backward compatibility with large codebases. :)
18:32:55 <edwardk> yeah i think i'm probably your only user ;)
18:34:11 <edwardk> i also started replacing all the explicit forall stuff with Dist f g and Natural f g for distributive laws and natural transformations respectively
18:34:17 <edwardk> i think it cleaned up a lot
18:35:30 <dolio> I'll worry about that later, too. The generalized type signatures do get hairy, though.
18:35:37 <edwardk> yeah
18:36:40 <eugman|college> Hpw do you map two lists to a two input function?
18:36:50 <dibblego> liftM2?
18:38:01 <dibblego> zipWith?
18:38:05 <dibblego> ?type zipWith
18:38:05 <zeno_> my router hates me :(
18:38:06 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
18:38:10 <dibblego> ?type liftM2
18:38:11 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
18:38:33 <zeno_> @src liftM2
18:38:34 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
18:38:58 <eugman|college> i think zipwith might be it, lemme check
18:39:24 <eugman|college> yeah, looks like
18:39:25 <EvilTerran> eugman|college, it depends on what behaviour you want
18:39:28 <adu> I love the map / for-each / zipWith combinator, its my favorite :)
18:40:12 <eugman|college> I basically want to demonstrate some simple functions on infinite lists so somthing like multiplying or adding two
18:40:28 <dons> > map (^2) [1..]
18:40:30 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
18:40:34 <EvilTerran> > zipWith (+) [a,b,c]
18:40:35 <lambdabot>  <[SimpleReflect.Expr] -> [SimpleReflect.Expr]>
18:40:38 <EvilTerran> > zipWith (+) [a,b,c] [x,y,z] -- even
18:40:39 <lambdabot>  [a + x,b + y,c + z]
18:40:45 <EvilTerran> > liftA2 (+) [a,b,c] [x,y,z] -- even
18:40:46 <lambdabot>  [a + x,a + y,a + z,b + x,b + y,b + z,c + x,c + y,c + z]
18:40:57 <EvilTerran> ... as i said, depends on what behaviour you want :)
18:41:07 * EvilTerran deletes the second "-- even"
18:43:46 <Woo1> how do I turn echoing off in the terminal? (via haskell
18:43:47 <eugman|college> lol, yeah i gues (^2) would have the smae effect
18:44:41 <jaj> does liftA2 calculate the cartesian product?
18:45:22 <jaj> @type liftA2
18:45:23 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
18:46:01 <ABoyNamedWooh> @type hEcho
18:46:02 <idnar> > liftM2 (+) [a,b,c] [x,y,z]
18:46:02 <lambdabot> Not in scope: `hEcho'
18:46:03 <lambdabot>  [a + x,a + y,a + z,b + x,b + y,b + z,c + x,c + y,c + z]
18:46:10 <ABoyNamedWooh> > hEcho False
18:46:11 <lambdabot>   Not in scope: `hEcho'
18:46:19 <idnar> oh, of course that's the same as liftA2
18:46:48 <Saizan> @hoogle setEcho
18:46:48 <lambdabot> System.IO.hSetEcho :: Handle -> Bool -> IO ()
18:47:16 <dolio> edwardk: You want your name on it anywhere?
18:47:25 <ABoyNamedWooh> thanks saizan
18:47:28 <edwardk> wouldn't mind
18:47:35 <eugman|college> Assuming i wanted to do some serious haskell learning in the future, is there any project that a beginner would be able to help with?
18:47:59 <EvilTerran> jaj, for the [] instance of Applicative, yes
18:48:17 <idnar> er
18:48:19 <idnar> @type liftA2
18:48:21 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
18:48:37 <idnar> man, I need sleep
18:48:38 <idnar> hrm. for some reason I thought that had something to do with arrows
18:48:54 <EvilTerran> jaj, for any Monad, it's possible to define an instance of Applicative with the same type such that (<*>) = ap and pure = return
18:49:07 <EvilTerran> ... and liftA2 = liftM2 for any such instance
18:49:12 <idnar> right
18:49:14 <monochrom> sleep :: IOArrow Int ()
18:49:18 <dolio> edwardk: I'll stick your name in the description of Control.Recursion (it also says you coined 'chronomorphism' if that's all right with you).
18:49:25 <idnar> that all makes sense once I have Applicative, not Arrow ;)
18:49:36 <edwardk> dolio: sounds good to me
18:49:40 <lispy> is there a CSize_t in the FFI?
18:49:56 <zeno_> hmmm GHC couldnt find Control.Applicative, is it an extension?
18:50:26 <EvilTerran> ... what version are you using?
18:50:39 <zeno_> 6.8.2
18:50:51 <EvilTerran> er
18:51:19 <zeno_> (im actually in eclipse, maybe it has path or something messed up)
18:51:25 <EvilTerran> it's in the base package in 6.8.2
18:52:17 <zeno_> yup, command line GHC found it
18:52:32 <zeno_> first time ive had eclipse mess with me like that :)
18:53:13 <lispy> looks like CSize is what I wanted
18:53:16 <jaj> EvilTerran: thanks, I'll save the explanation to review it once I feel more comfortable with monads and once I know what the Applicative and Arrow classes do ;)
18:53:28 <EvilTerran> don't worry about Arrow just not, it's not relevant here
18:53:48 <EvilTerran> Applicative is just something more specific (and so powerful) than Functor but less so than Monad
18:54:18 <EvilTerran> (a specific something, mind, not just any old something)
18:54:22 <eu-prleu-peupe1> hello
18:54:36 <zeno_> should i avoid using it in a non-main function?
18:55:16 <eu-prleu-peupe1> i was thinking about this strange idea of a possible extension to haskell to make it generate gpu code
18:55:48 <eu-prleu-peupe1> like some kind of compiler flag, that whenever true, it would generate gpu code instead of plain c--
18:55:56 <eu-prleu-peupe1> do you guys think its feasable ?
18:56:26 <eu-prleu-peupe1> since its a pure functional language, i think it would be great to explore its possible paralelization in the gpu
18:56:31 <eu-prleu-peupe1> but i dont know
18:57:28 <byorgey> eugman|college: I'm working on a project which I hope to release a primitive version of soon, which could be appropriate for a beginner to help with.
18:57:41 <zeno_> c--?(srsly?)
18:58:01 <byorgey> eugman|college: it's an embedded domain-specific language for creating diagrams, based on the cairo rendering engine
18:59:07 <byorgey> eugman|college: the Haskell Community and Activities Report (HCAR) should be coming out within a few weeks, that's always a good source of information on projects you might be able to help out with.
18:59:27 <eu-prleu-peupe1> yeh, check it: http://www.cminusminus.org/
18:59:30 <lambdabot> Title: C-- Home
18:59:33 <eu-prleu-peupe1> isn't that what the ghc produces ?
18:59:36 <eu-prleu-peupe1> i thought it was...
19:00:10 <byorgey> you can also take a look at the most recent HCAR (~6 months old now but still useful!)
19:00:29 <eugman|college> Hmm, do data definitons work in the interpreter?
19:00:37 <byorgey> eugman|college: nope
19:01:03 <zeno_> eu-prleu-peupe1: cool i didnt know that
19:01:10 <eu-prleu-peupe1> ;)
19:04:06 <zeno_> so what do GPUS use? not just c?
19:04:43 <eu-prleu-peupe1> gpu's use shader language
19:05:01 <eu-prleu-peupe1> which may be glsl, hlsl, Cg, or low level shader languages
19:05:10 <eu-prleu-peupe1> and are intrinsically parallel
19:05:38 <eu-prleu-peupe1> there are some extensions to C to perform gpgpu
19:05:53 <eu-prleu-peupe1> it would be great to have an extension to haskell to do the same :)
19:06:31 <eu-prleu-peupe1> the most known extensions to C to do gpgpu are CUDA (from nvidia), brook (from standford univ.), and brook+ (from amd)
19:07:19 <zeno_> neat, id like to help but i know little c, and no assembler :\
19:07:32 <zeno_> still working on haskell
19:07:54 <adu> zeno_: its very liberating
19:08:08 <eu-prleu-peupe1> but the idea would be to produce some haskell extensions to be able to do gpgpu mixed with normal cpu code
19:08:17 <adu> zeno_: do you understand Monads yet?
19:09:09 <zeno_> somewhat, i know how IO works, what they have to have, and that the shell acts like one (with cat == return, and | == bind
19:09:50 <zeno_> really they seem like ways to make good DSLs :)
19:10:07 <geezusfreeek> zeno_: yup :)
19:11:02 <adu> zeno_: yeah, you got it
19:11:32 <adu> except I question the "cat" thing
19:11:46 <zeno_> =p, one thing i love about haskell is the currying
19:11:48 <adu> i suppose you're right
19:11:49 <zeno_> sure
19:12:11 <zeno_> (to the question)
19:12:41 <adu> well, the only problem is that its not scalable to other languages
19:13:01 <adu> to do currying in other languages, you still need to do f(x)(y)(z)
19:13:05 <adu> which sucks
19:13:24 <zeno_> yeah, and in java you pretty much cant
19:13:30 <adu> but I guess that's why haskell rocks!
19:13:55 <zeno_> writing my first program now :)
19:14:04 <adu> cool
19:14:23 <adu> my first Haskell app was "cat" :)
19:14:38 <adu> main = interact id
19:14:57 <Beelsebob> hehe
19:15:04 <Beelsebob> nice implementation
19:15:14 <Uthius> Salud!  I am learning Haskell and one of the big benefits, according to my book, is the ability to reason mathematically/algebraically about programs.  So as an exercise I am trying to prove a couple properties, but I am not sure what a good first step is.  Can anyone suggest a first step for showing concat (map (map f) xs) = map f (concat xs) ?
19:16:16 <Uthius> its obvious that it is true, but, I am not sure how to transform one side into the other
19:17:05 <Dino__> I would like to know how I can print out the instance out of a list, including a line break, I have posted the code here :  http://hpaste.org/7224 thanks
19:17:25 <ddarius> @free concat
19:17:26 <lambdabot> $map f . concat = concat . $map ($map f)
19:17:33 <gwern> I have a question about hGetBuf http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#v%3AhGetBuf <-- since it uses Int, does that mean it can't handle more'n 4 gigs or so of data?
19:17:33 <lambdabot> http://tinyurl.com/sbkmj
19:17:37 <vgax> hello just wandering whats going to be in the next release of haskell?
19:17:44 <adu> Uthius: the first step is to show that the types are combatible, the second step would be a base case, and the third step induction maybe?
19:17:51 <ddarius> Uthius: That's the free theorem of concat.
19:17:56 <gwern> vgax: you mean the standard, haskell'? or GHC the compiler?
19:18:34 <Beelsebob> vgax: I suggest you join the haskell-prime mailing list
19:18:41 <Beelsebob> and watch what goes by
19:18:41 <zeno_> ?help @free
19:18:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:18:47 <zeno_> ?help free
19:18:47 <lambdabot> free <ident>. Generate theorems for free
19:18:51 <dibblego> shouldn't that be concat (map f xs) = map f (concat xs) ?
19:19:06 <vgax> i just want to know if ghc will improve on peformance
19:19:10 <Pseudonym> ?free id :: a -> a
19:19:11 <lambdabot> f . id = id . f
19:19:20 <ddarius> dibblego: That's not even well typed.
19:19:22 <cjb> nn
19:19:23 <cjb> oops
19:19:25 <Pseudonym> ?free concat
19:19:26 <lambdabot> $map f . concat = concat . $map ($map f)
19:19:36 <dibblego> oh of course
19:20:30 <gwern> @hoogle Integer -> CSize
19:20:31 <lambdabot> No matches, try a more general search
19:20:40 <gwern> @hoogle CSize
19:20:41 <lambdabot> Foreign.C.Types.CSize :: data CSize
19:20:46 <gwern> bleh
19:20:47 <adu> gwern: well it certainly means you can't address more than 4 GiB
19:21:18 <gwern> 'darcs: /home/gwern/foo/bigtempfile: hGetBuf: failed (Bad address)' <-- like that? (but bigTempFile is 2.9G...)
19:21:24 <vgax> are working on performance in the next build of ghc?
19:21:38 <vgax> anyone know whos of the mailing list
19:21:44 <Uthius> adu: ok, i will try to show the types are the same followed by an inductive proof, here goes...
19:22:36 <adu> gwern: no that sounds like it was out of bounds, like it was trying to access byte at 3.1 GiB
19:23:05 <gwern> adu: hm. feel like looking at an hpaste?
19:23:10 <adu> sure
19:24:34 <gwern> http://hpaste.org/7225#a1
19:26:56 <geezusfreeek> conal: http://hpaste.org/7226
19:27:08 <geezusfreeek> compile that with O2 and run test and test2 in ghci
19:27:10 <gwern> how fast is the mmap co_slurp for you anyway?
19:27:15 <geezusfreeek> test will work, test2 will fail
19:27:17 <gwern> (mischan)
19:27:57 <geezusfreeek> it's not a hang though, but rather just a demonstration that the inlining is a problem
19:29:05 <geezusfreeek> but i'm pretty sure that is the cause of the hang when i use the second version of cached in my code
19:29:05 <gwern> adu: any ideas?
19:29:41 <geezusfreeek> just some sort of other interaction somewhere
19:32:48 <adu> gwern: what is the "fp <-" doing?
19:33:04 <eu-prleu-peupe1> did you guys saw the haskell demo on the breakpoint demoparty this year ?
19:34:06 <geezusfreeek> eu-prleu-peupe1: no, but i'm interesting in seeing it!
19:34:28 <cjs> Hey, is this supposed to work?  http://hpaste.org/7127
19:34:42 <gwern> adu: presumably it'll be set to the value of 'thefp'
19:34:51 <adu> ok
19:35:02 <eu-prleu-peupe1> here, check: http://www.pouet.net/prod.php?which=50137
19:35:04 <lambdabot> Title: Mrs. Pavlov here tells me that she is a polytoxicowomane by A moiré misszió bemu ...
19:35:14 <eu-prleu-peupe1> there is a link to the download, and youtube video on the right side of the image
19:35:28 <eu-prleu-peupe1> :)
19:35:37 <eu-prleu-peupe1> i just though opengl would be complete non-sense in haskell
19:35:40 <adu> oh ok i get it
19:35:41 <eu-prleu-peupe1> since its lazy and all
19:35:49 <eu-prleu-peupe1> but seems like its a go after all :)
19:35:59 <adu> gwern: all the #if's are confusing me
19:36:10 <geezusfreeek> eu-prleu-peupe1: no, i find opengl to be quite enjoyable in haskell
19:36:10 <gwern> the CPP hackery doesn't help, I'll admit
19:36:24 <eu-prleu-peupe1> better than C ? :)
19:36:40 <geezusfreeek> eu-prleu-peupe1: yes, except for the bindings lacking one or two somewhat advanced features
19:36:44 <eu-prleu-peupe1> but coding opengl is nothing but coding state changes and passing data to those states...
19:36:50 <geezusfreeek> eu-prleu-peupe1: yup
19:37:01 <eu-prleu-peupe1> ...haskell handles that kind of coding well ?
19:37:05 <geezusfreeek> eu-prleu-peupe1: io in haskell in general is quite enjoyable
19:37:09 <eu-prleu-peupe1> i thought it would be like total torture
19:37:15 <eu-prleu-peupe1> and kill in terms of performance
19:37:20 <geezusfreeek> it's all thanks to the power of monads!
19:37:31 <eu-prleu-peupe1> cause of the monads overbloat io stuff
19:37:36 <eu-prleu-peupe1> yeah, precisely
19:37:56 <geezusfreeek> there may be a _slight_ performance penalty for monads, but not big
19:38:04 <geezusfreeek> at least, i have not run into any
19:38:10 <eu-prleu-peupe1> hmm
19:38:10 <geezusfreeek> regardless, most of your processing is still pure
19:38:18 <eu-prleu-peupe1> even in opengl ?
19:38:19 <geezusfreeek> the io monad is only for the top level
19:38:26 <gwern> geezusfreeek: clean seems to be a lot faster than haskell in some areas because of uniqueness typing instead of monads
19:38:37 <geezusfreeek> gwern: true, but i think we can catch up
19:38:44 <eu-prleu-peupe1> also, haskell is not "array oriented" like C...
19:38:55 <zeno_> i think i heard of clean, was it windows only?
19:38:59 <geezusfreeek> eu-prleu-peupe1: well, i have been doing opengl in haskell a bit lately and i love it. fast enough for me
19:39:01 <eu-prleu-peupe1> and working with arrays seems like a natural choice for performance guided apps
19:39:16 <geezusfreeek> eu-prleu-peupe1: haskell has mutable arrays if you need them, but i have never used them
19:39:26 <gwern> certainly, but that we're already behind clean, even with the incredible amount of brainpower poured into optimizing monads, shows that uniqueness is just a more easily efficient approach
19:39:31 <gwern> so 'slight'? not really
19:39:40 <eu-prleu-peupe1> its not that i "need" them... just a performance hint...
19:39:46 <vgax> ghc team should stop ading features and work on perfomrance and optimization
19:39:46 <eu-prleu-peupe1> how do you store an image in haskell ?
19:39:55 <geezusfreeek> gwern: well, it really is slight, in my opinion... uniqueness typing has a tradeoff in that it's still hard to express imperative code
19:40:03 <eu-prleu-peupe1> the data structure for an image is intrinsically procedural
19:40:14 <geezusfreeek> eu-prleu-peupe1: image handling would benefit from a C binding, for sure
19:40:18 <zeno_> what is "uniqueness typing"?
19:40:22 <geezusfreeek> but it can still have a functional interface
19:40:26 <dolio> Which benchmarks are we talking about?
19:40:29 <geezusfreeek> *pure interface
19:40:38 <vgax> maybe functional programming is the wrong way to code anyone thought of that
19:40:53 <byorgey> vgax: yup, I've thought of that.
19:40:55 <dolio> If you ask dons, he'll probably tell you that Clean beat Haskell for a long time due to their more efficent string implementation, at least on a lot of shootout stuff.
19:40:55 <geezusfreeek> eu-prleu-peupe1: it's not _intrinsically_ procedural. it's just more efficient on a computer that way
19:40:58 <gwern> vgax: are you suggesting that logic programming is correct? MADNESS
19:41:00 <byorgey> vgax: I don't think it's true though =)
19:41:02 <eu-prleu-peupe1> heheh
19:41:11 <Beelsebob> vgax: if functional programming is wrong, you can always just do imperative programming in a safe way within it
19:41:13 <vgax> think about how the world works
19:41:24 <vgax> it has affects
19:41:26 <eu-prleu-peupe1> but, i would end up coding the entire 3d engine in C, and then provide some bindings for haskell to use
19:41:29 <gwern> vgax: it works via graph reduction, obviously
19:41:35 <eu-prleu-peupe1> so, it seems better to just do it all in C
19:41:41 <geezusfreeek> vgax: that's what you thinkâ€¦ my world has no effects
19:41:44 <vgax> computers are imperitive at the core
19:41:49 <vgax> lol
19:42:03 <Beelsebob> vgax: computers are imperative at the core because they run mostly imperative code
19:42:04 <geezusfreeek> vgax: no seriously. the world only has effects from a certain point of view
19:42:09 <geezusfreeek> there are other ways to look at the world
19:42:13 <eu-prleu-peupe1> hehehe
19:42:15 <eu-prleu-peupe1> lavoisier ?
19:42:16 <Beelsebob> there's a research project at york that is working on a functional computer
19:42:16 <eu-prleu-peupe1> :)
19:42:19 <gwern> most of physics is time-invariant
19:42:27 <gwern> as I understand it
19:42:30 <vgax> Beelsebob: cool
19:42:33 <eu-prleu-peupe1> everything "transforms", lavoisier rule
19:42:42 <eu-prleu-peupe1> its a very "pure" view of the world
19:42:48 <vgax> but the world is also has infinite recursion
19:42:59 <vgax> we can't do that in computers
19:43:05 <zeno_> Time :: Universe -> LawsOfPhysics -> Universe
19:43:05 <adu> gwern: you should check to see what the outputs of hFileSize and hGetBuf are
19:43:07 <adu> no wait
19:43:08 <geezusfreeek> there have been functional machines before, but it really ends up being similar in implementation to everything else anyway, so might as well just let the compiler do the work
19:43:13 <adu> gwern: mallocForeignPtrBytes !!!
19:43:30 <gwern> adu: where!
19:43:32 <adu> you are allocating 1 byte, thats your problem
19:43:35 <geezusfreeek> eu-prleu-peupe1: i still say haskell makes a nice imperative language
19:43:38 <adu> @hoogle mallocForeignPtrBytes
19:43:38 <lambdabot> Foreign.ForeignPtr.mallocForeignPtrBytes :: Int -> IO (ForeignPtr a)
19:43:43 <vgax> geezusfreeek: my only gripe with fp programming is its hard to get fast code
19:43:49 <adu> @hoogle mallocForeignPtr
19:43:49 <lambdabot> Foreign.ForeignPtr.mallocForeignPtr :: Storable a => IO (ForeignPtr a)
19:43:49 <lambdabot> Foreign.ForeignPtr.mallocForeignPtrBytes :: Int -> IO (ForeignPtr a)
19:43:49 <lambdabot> Foreign.ForeignPtr.mallocForeignPtrArray :: Storable a => Int -> IO (ForeignPtr a)
19:43:54 <geezusfreeek> vgax: i have not had that problem yet
19:43:59 <byorgey> haskell makes a lovely imperative language, since chunks of imperative code are first-class!
19:44:01 <eu-prleu-peupe1> but i think haskell is meant to be pure
19:44:09 <adu> as you see the mallocForeignPtr version doesn't take an integer, but the mallocForeignPtrBytes version does
19:44:10 <eu-prleu-peupe1> byorgey:  lol
19:44:13 <zeno_> vgax: still faster than other high level languages like python
19:44:17 <byorgey> I'm serious.
19:44:18 <geezusfreeek> eu-prleu-peupe1: and it is! the IO monad is still pure. that's the nice thing
19:44:20 <vgax> maybe the ocaml style is better
19:44:36 <gwern> adu: wait, mallocForeignPtrBytes :: Int -> IO (ForeignPtr a)? <-- still Int
19:44:37 <eu-prleu-peupe1> i've heard about something called "arrows" but i could not understand it
19:44:42 <byorgey> you can construct a (parameterized) chunk of imperative code, execute it later (or maybe not at all), make a list of them, a tree of them...
19:44:49 <geezusfreeek> yeah, really, all the IO monad is is a way to write an imperative program and then execute it at runtime
19:44:55 <eu-prleu-peupe1> monads are preatty straightforward, its just a dumb interface for the trash bin in haskell
19:44:55 <dons> ocaml and haskell are pretty much identical, when writing fast code.
19:44:56 <adu> gwern: ya, still int
19:45:05 <dons> its just hard to take advantage of laziness in ocaml, and you don't get an ST monad
19:45:10 <eu-prleu-peupe1> but "arrows" i could not dig it
19:45:10 <gwern> eu-prleu-peupe1: just think of arrows as a few convenient functions on tuples
19:45:11 <geezusfreeek> uh oh, we brought in dons ;)
19:45:20 <vgax> geezusfreeek: why hasn't anyone made large softwre in haskell?
19:45:22 * dons writes fast code in FP languages for a living
19:45:27 <geezusfreeek> vgax: you think they haven't?
19:45:30 <eu-prleu-peupe1> hmm functions on tuples... ok
19:45:32 <dons> vgax: heh.
19:45:38 <vgax> geezusfreeek: no
19:45:41 <dons> vgax: there are entire companies built around huge haskell systems
19:45:48 <byorgey> dons works for one =)
19:45:58 <geezusfreeek> vgax: for example: Large scale parallel programming: GranSim is currently being used in the parallelisation of several large Haskell programs. The largest is the LOLITA natural language processing system, which consists of about 60.000 lines of Haskell and some 1000 lines of C code.
19:45:59 <gwern> eu-prleu-peupe1: for example, I had a real world use for arrows - I had '(\(x,y) -> unpack x, unpack y) $ foo bar...' which I turned into 'unpack *** unpack $ foo bar...'
19:45:59 <vgax> dons: thats the first time i'm hearing that
19:46:02 <adu> dons: really? I want to work there
19:46:05 <geezusfreeek> vgax: from http://www.dcs.gla.ac.uk/fp/software/gransim/
19:46:07 <lambdabot> Title: GranSim Home Page
19:46:08 <dons> bluespec and cryptol are several hundred thousand of lines of haskell
19:46:22 <gwern> geezusfreeek: do you know what happened to LOLITE? I still haven't found out
19:46:30 <gwern> my emailing hit a dead end when two people failed to respond
19:46:30 <geezusfreeek> gwern: not a clue
19:46:30 <dons> vgax: i guess you've not looked at http://haskell.org/haskellwiki/Haskell_in_industry ?
19:46:40 <eu-prleu-peupe1> :)
19:46:51 <zeno_> a real world use i found for arrows was *** maps to a pair
19:46:56 <eu-prleu-peupe1> what do you think of haskell as an GUI language ?
19:47:01 <vgax> dons: i looked at that but didn't see anything impressive
19:47:13 <eu-prleu-peupe1> it would be great to explore that... "pure functional GUI's"
19:47:18 <ABoyNamedWooh> I can't find a definitive source of information on how records work in haskell. how can I recover and update a field in a noncumbersome way? I'd rather not reconstruct a whole new record...
19:47:21 <dons> vgax: i guess it depends on what's impressive. i think its cool that there are half a dozen global banks using haskell
19:47:28 <geezusfreeek> eu-prleu-peupe1: http://araujoluis.blogspot.com/2007/04/haskell-gui-programing.html
19:47:29 <lambdabot> Title: araujo's blog: Haskell for GUI Programing, http://tinyurl.com/yrz4ce
19:47:37 <gwern> adu: I still don't entirely follow what's better about Foreign.ForeignPtr.mallocForeignPtrBytes
19:47:39 <dons> eu-prleu-peupe1: yeah, gtk2hs is the most common gui library
19:48:22 <geezusfreeek> eu-prleu-peupe1: there a several people in this channel who are working on even nicer interfaces for gui programming
19:48:27 <eu-prleu-peupe1> yes
19:48:32 <dons> its kind of obvious haskell would scale up to very large systems -- polymorphism and purity enforce modularity, so you can just keep piling on the code, with things not going haywire.
19:48:33 <eu-prleu-peupe1> that would be very veyr good
19:48:38 <geezusfreeek> eu-prleu-peupe1: in a way, i am one of them
19:48:48 <vgax> dons: don't get me wrong i love haskell and want it to be used more often but when i search for large scale use of haskell i can't find much and it makes me wonder why is that?
19:48:51 <eu-prleu-peupe1> instead of using gtk gui, try to evolve the "gui's" using pure functional expressiveness
19:49:08 <eu-prleu-peupe1> are you a jesus freak ?
19:49:09 <adu> gwern: mallocForeignPtr allocates any number of bytes, mallocForeignPtrBytes allocates exactly what you tell it
19:49:16 <dons> vgax: well, i've pointed at companies that collectively have millions of lines of haskell.
19:49:27 <dons> i guess though, there's say, 6 languages that are mainstream. everything else is hard to find.
19:49:38 <adu> gwern: how do you know mallocForeignPtr is allocating more than a single byte?
19:49:53 <eu-prleu-peupe1> this luis araujo seems like a nice guy
19:49:57 <geezusfreeek> eu-prleu-peupe1: my handle is a bit of a carry-over from the past. i would describe my spiritual beliefs now as a follow of the teachings of jesus, but with an open mind
19:50:10 <gwern> adu: if mallocForeignPtr allocates as much as needed, then why would it cuase problems?
19:50:18 <dolio> 6, eh?
19:50:24 <adu> how do you know how much is needed?
19:50:27 <vgax> dons: i havn't seen not one program written in haskell?
19:50:38 <adu> vgax: you should, its fun
19:50:40 <vgax> that i can download and test
19:50:44 <eu-prleu-peupe1> geezusfreeek: im also a jesus freak
19:50:50 <eu-prleu-peupe1> yeah, jesus was pure functional for sure
19:50:51 <dons> vgax: where are you looking? there's more than 500 libraries and apps on hackage.haskell.org
19:50:55 <eu-prleu-peupe1> no side-effects on him
19:50:56 <eu-prleu-peupe1> :)
19:50:58 <gwern> adu: I think it must be ' l <- fromIntegral `liftM` hFileSize h'
19:51:05 <dons> vgax: you don't use darcs, or xmonad, or pugs, or hpodder?
19:51:13 <vgax> adudons: no
19:51:14 <dons> or lambdabot, for that matter?
19:51:16 <vgax> dons*
19:51:22 <byorgey> @botsnack
19:51:23 <lambdabot> :)
19:51:25 <dons> ah well, i guess you *are* looking in the wrong place.
19:51:28 <adu> gwern: its possible, but then if you don't need to be passing l to mallocForeignPtr, then why are you?
19:51:42 <gwern> adu: I didn't write this code :(
19:51:49 <vgax> dons: i recently started learning haskell seriously for some of my projects
19:51:55 <ABoyNamedWooh> Is there a way to update only one field in a record?
19:52:00 <dons> for what its worth, i don't have any ruby or lisp or prolog or erlang or C# programs on my machine, so i guess they're not used either. they probably don't scale.
19:52:04 <eu-prleu-peupe1> i still think gpgpu on haskell would be killer stuff :D
19:52:17 <adu> I'm talking about how "thefp <- mallocForeignPtr l" should either be "thefp <- mallocForeignPtrBytes l" or "thefp <- mallocForeignPtr" but the way it is now should not even compile...
19:52:21 <byorgey> ABoyNamedWooh: sure.  you can say  oldRecordValue { fieldName = newValue }
19:52:24 <dons> ABoyNamedWooh: yeah, v { x = 7 } -- updates just x in structure v
19:52:25 <geezusfreeek> ABoyNamedWooh: myStructure { fieldName = newValue } will return a copy of myStructure with the field value replaced
19:52:36 <gwern> eu-prleu-peupe1: it'd be neat, but history has been pretty clear about languages needing special hardware (ie don't)
19:52:38 <ABoyNamedWooh> ah, great
19:52:44 <ABoyNamedWooh> so if I wanted to take the old value and add 5
19:52:44 <ABoyNamedWooh> it'd be
19:52:51 <dons> vgax: cool. the best place to really get into using haskell for everything is to become familiar with hackage.haskell.org
19:52:54 <ABoyNamedWooh> v {x = (x v) + 5} ?
19:52:55 <Dino__> I would like to know how I can print out the instances of a list, including a line break,
19:52:56 <Dino__> I have posted the code here : http://hpaste.org/7224 thanks
19:52:58 <dons> there's libraries there for pretty much everything.
19:52:58 <vgax> i heard someone mention that haskell can't handle 50 connections a second why is that?
19:52:59 <ddarius> gwern: Very littel effort has been spent on optimizing monads specifically.
19:53:05 <byorgey> ABoyNamedWooh: you've got it.
19:53:12 <geezusfreeek> ABoyNamedWooh: yes. that is admittedly a bit ugly, but haskell's record are a bit flawed
19:53:18 <geezusfreeek> *records
19:53:20 <dons> vgax: languages don't handle connections.
19:53:28 <ABoyNamedWooh> ah, it's a shame there isn't a nicer way to do it, thanks
19:53:35 <gwern> this mmap business makes me sad
19:53:37 <eu-prleu-peupe1> it would be necessary for the ghc to produce brook code instead of c--
19:53:40 <dons> fwiw, happs serves up around 2000 requests/sec on a good day, so i guess you heard wrong.
19:53:42 <zeno_> vgax: maybe some haskell networking library cant?
19:53:43 <vgax> dons: i was referring to the one haskell server
19:53:52 <byorgey> ABoyNamedWooh: there ARE nicer ways to do it, actually, with help from various libraries.
19:53:55 <ABoyNamedWooh> ah, ok
19:53:59 <dons> even the HWS web server does 900 req/sec last i checked
19:54:03 <geezusfreeek> vgax: that makes little sense. usually the problem is too much memory taken up by OS threads, and haskell's green threads are among the best of _any_ language
19:54:19 <vgax> ok
19:54:19 <eu-prleu-peupe1> "green threads" ?
19:54:22 <eu-prleu-peupe1> like ecological ?
19:54:29 <geezusfreeek> eu-prleu-peupe1: userspace threads
19:54:30 <byorgey> ABoyNamedWooh: if you're going to be doing lots of updating of records with lots of fields, maybe even nested records, you might want to look into some of the functional references stuff
19:54:32 <gwern> dons: I hope your bytestring-mmap lib has a function with the type 'mmap :: FilePath -> IO (ForeignPtr Word8, Int)'
19:54:33 <eu-prleu-peupe1> ah ok
19:54:39 <eu-prleu-peupe1> i dont see the need for userspace threads...
19:54:42 <dons> gwern: yeah. look deeper down.
19:54:43 <byorgey> ABoyNamedWooh: but for most simple uses it may be too heavyweight.
19:54:45 <eu-prleu-peupe1> ...they just suck at everything
19:54:48 <ABoyNamedWooh> byorgey: yeah, it's a simple thing
19:54:51 <eu-prleu-peupe1> overbloated stuff
19:54:56 <geezusfreeek> eu-prleu-peupe1: haskell's threads are neat. you can have n green threads running on m os threads
19:54:58 <ABoyNamedWooh> byorgey: but if it gets nasier I would :)
19:55:03 <byorgey> ABoyNamedWooh: ok. =)
19:55:09 <dons> eu-prleu-peupe1: yeah, try forking 500k kernel threads sometime :)
19:55:11 <geezusfreeek> eu-prleu-peupe1: and they are insanely fast
19:55:17 <eu-prleu-peupe1> but why would anyone want that ?
19:55:32 <geezusfreeek> eu-prleu-peupe1: so you can scale to more cores!
19:55:32 <eu-prleu-peupe1> i have complete confidence on the kernel scheduler
19:55:33 <dons> to handle lots of connections, or very fine grained parallelism
19:55:53 <eu-prleu-peupe1> but its overbloat!
19:55:53 <dons> it makes sense to have a user land thread abstraction anyway -- its a basic structuring technique.
19:56:02 <geezusfreeek> eu-prleu-peupe1: the problem is not so much the scheduler but the overhead of context switches and the overhead of memory in os threads
19:56:12 <geezusfreeek> os threads are very inefficient
19:56:24 <Cale> eu-prleu-peupe1: It's not overbloat -- that's the point of lightweight threading, to make that programming model feasible.
19:56:31 <geezusfreeek> the only benefit they give you is true parallelism
19:56:41 <geezusfreeek> s/they/os threads/
19:56:47 <eu-prleu-peupe1> thats the point on having threads
19:56:49 <dons> eu-prleu-peupe1: check http://shootout.alioth.debian.org/gp4/benchmark.php?test=threadring&lang=all
19:56:51 <eu-prleu-peupe1> true parallelism
19:56:51 <lambdabot> Title: thread-ring benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Langu ..., http://tinyurl.com/2lyngq
19:56:55 <dons> and guess which languages have fast lightweight threads
19:56:55 <gwern> dons: actually, beofre I finish downloading - does bytestring-mmap handle >4gb files?
19:56:59 <Cale> eu-prleu-peupe1: No, not necessarily.
19:57:09 <dons> gwern: if you're on the appropriate machine
19:57:11 <Cale> eu-prleu-peupe1: The point of threads is concurrency, not parallelism per-se.
19:57:16 <Uthius> adu: i have tried to prove the types of the two expressions are the same but im not sure if i did this correctly
19:57:16 <eu-prleu-peupe1> oh
19:57:17 <gwern> great
19:57:18 <eu-prleu-peupe1> yes
19:57:19 <lispy> what is this bytestring-mmap?
19:57:19 <eu-prleu-peupe1> indeed
19:57:22 <geezusfreeek> eu-prleu-peupe1: well, first of all, that's not really true, and second of all, the model haskell uses gives you the best bang for your buck as far as parallelism goes
19:57:24 <Cale> The parallelism is a win if you can get it.
19:57:26 <Uthius> http://hpaste.org/7227
19:57:32 <lispy> ?users
19:57:32 <lambdabot> Maximum users seen in #haskell: 459, currently: 415 (90.4%), active: 19 (4.6%)
19:57:36 <eu-prleu-peupe1> geezusfreeek: i really like openmp in C
19:57:47 <vgax> dons: do you think haskell would be a good language to write a download manager in?
19:57:55 <lispy> Interesting, just 19 active and I feel like it's scrolling so fast I can barely keep up :)
19:58:02 <geezusfreeek> eu-prleu-peupe1: i am not familiar with openmp
19:58:07 <eu-prleu-peupe1> openmp is great, very low-cost, it compiles single threaded, and is very fast... compiler can even use vectorization to help out some loops
19:58:09 <lispy> vgax: what type of download manager?
19:58:19 <vgax> like idm
19:58:33 <lispy> vgax: I guess I'll go look it up, never heard of it
19:58:36 <eu-prleu-peupe1> haskell can't do better than that, because it compiles to c--
19:58:38 <ddarius> vgax: People have written download manager type programs and related things in Haskell.
19:58:39 <gwern> lispy: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring-mmap-0.2.0
19:58:41 <ABoyNamedWooh> A slightly more erudite question. Does anyone know why when I do a show of a return value that is supposed to be in picoseconds I sometimes get a negative number? it is of type Integer (are haskells integers unsigned or something?)
19:58:42 <lambdabot> http://tinyurl.com/5oql6u
19:58:42 <eu-prleu-peupe1> at least on the vectorization part :/
19:58:55 <eu-prleu-peupe1> it would be a good project to make ghc generate c-- with openmp support :)
19:58:58 <geezusfreeek> eu-prleu-peupe1: you seem to have preconceptions that would be very difficult for us to shake
19:59:08 <eu-prleu-peupe1> heheh
19:59:31 <eu-prleu-peupe1> im a very stubborn person
19:59:52 <ABoyNamedWooh> (I'm using Haskell's getClockTime and reading the picoseconds field)
19:59:58 <eu-prleu-peupe1> i have been convinced about the lwt
20:00:05 <vgax> i'm just wandering if a good download manger with lots of threads etc would be possible in haskell?
20:00:13 <eu-prleu-peupe1> ok, for concurrency i can see the point of having lwt
20:00:21 <geezusfreeek> eu-prleu-peupe1: you would also be hard pressed to find synchronization primitives as nice as haskell's :)
20:00:21 <dons> vgax: sure, just fork a thread for each job. its a trivial task, isn't it?
20:00:23 <vgax> we don't need idm peformance
20:00:38 <lispy> ABoyNamedWooh: you're probably traveling at realtivistic speeds or something in that case :)
20:00:46 <vgax> dons: last time i wrote something in haskell it was terrible slow
20:01:03 <ABoyNamedWooh> lispy: haha it's the only option
20:01:04 <Cale> eu-prleu-peupe1: Also, it's nice to be able to just spawn a whole massive number of threads, and have the scheduler take care of how many OS threads can actually run in parallel.
20:01:13 <ABoyNamedWooh> lispy: it's either seconds or picoseconds and I need something more granular than seconds
20:01:22 <eu-prleu-peupe1> geezusfreeek: i have never tried out haskell parallel stuff... but i want to (isn't that the point of being pure functional all about?)
20:01:30 <dons> vgax: there's no reason for that to be the case. unless maybe you were using hugs?
20:01:36 <geezusfreeek> eu-prleu-peupe1: that's a benefit, but not really the point, imo
20:01:38 <eu-prleu-peupe1> yes cale
20:01:43 <vgax> dons: no ghc
20:01:45 <lispy> ABoyNamedWooh: I don't know the technical answer here.  It's not a part of Haskell I've used :(
20:01:47 <dons> vgax: http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all illustrates that ghc is rather good native code compiler
20:01:48 <lambdabot> Title: Create your own Ranking | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lan ..., http://tinyurl.com/lepfo
20:01:48 <vgax> and i compiled it
20:01:50 <Uthius> can anyone tell me if http://hpaste.org/7227 is at all a correct proof of the type of the expression on the first line?
20:01:55 <eu-prleu-peupe1> what is the holy grail of pure functional computation ?
20:02:09 <geezusfreeek> eu-prleu-peupe1: you mean the goal?
20:02:13 <dons> vgax: its fairly meaningless to discuss without code :) the last thing i wrote was insanely fast (array fusion programs)
20:02:16 <eu-prleu-peupe1> yes
20:02:21 <eu-prleu-peupe1> the main objective / difficulty
20:02:22 <Pseudonym> Pure functional computation _is_ the holy grail!
20:02:31 <geezusfreeek> eu-prleu-peupe1: that might mean different things to different people
20:02:39 <vgax> dons: i was writing a poker hand evaluator
20:02:45 <Pseudonym> Seriously, the term "holy grail" is overused in science.
20:02:50 <dons> oh, that list program we looked at?
20:02:56 <vgax> dons: it was stupidly slow
20:02:56 <geezusfreeek> eu-prleu-peupe1: but in my opinion, it's composability on all fronts
20:02:59 <dons> that was doing naive combinatorial list generation?
20:03:05 <Cale> eu-prleu-peupe1: Well, one nice thing is that purely functional programs are easier to reason about equationally.
20:03:07 <geezusfreeek> *safe composability
20:03:08 <zeno_> vgax: maybe you had a really nieve implementation :)?
20:03:27 <dons> vgax: wasn't that something like 15seconds for the naive program, and a couple of tweaks had it down to 1.7 seconds, while still being naive?
20:03:28 <lament> Pseudonym: especially in theology.
20:03:30 <vgax> dons: yes but it took all that effort to optimize it
20:03:30 <jaj> hmm, I'm stuck trying to do IO stuff in a CGIT IO do-block...
20:03:32 <eu-prleu-peupe1> hmm
20:03:35 <eu-prleu-peupe1> nice
20:03:36 <Cale> Yeah, composability is a good chunk of the summary. If I had to pick just one word, that would be it :)
20:03:37 <Pseudonym> Because they're easier to reason about equationally, computer programs can do the reasoning.
20:03:39 <lament> "What's the holy grail of the holy grail"?
20:03:41 <Pseudonym> In many cases.
20:03:49 <dons> vgax: well, it was a couple of trivial changes.
20:04:07 <Pseudonym> It's easier for a compiler, say, to discover information about a pure functional program.
20:04:08 <eu-prleu-peupe1> composability, like being able to compose everything in every possible way ?
20:04:14 <jaj> Couldn't match expected type `CGIT IO t' against inferred type `IO String'
20:04:14 <dons> vgax: naive list traversals aren't always the most appropriate data structure/algo approach
20:04:24 <Cale> eu-prleu-peupe1: Well, not necessarily in ways that don't make sense.
20:04:30 <eu-prleu-peupe1> ah ok
20:04:31 <eu-prleu-peupe1> yes
20:04:31 <geezusfreeek> eu-prleu-peupe1: maybe an alternative way of stating it would be in every possible meaningful way
20:04:37 <vgax> dons: how would you simulate nested loops then?
20:04:47 <eu-prleu-peupe1> yes
20:05:03 <dons> vgax: simulate? i'd just write a nested loop. but since the list comprehension optimised into a loop anyway, that's a reasonable approach
20:05:11 <Cale> eu-prleu-peupe1: But to build things up from simple primitives and simple but fruitful means of composition
20:05:14 <dons> using a better algorithm makes more sense though
20:05:42 <Cale> If you have two correct programs, you'd like to be able to put them together into a new correct program in any way which would make sense.
20:05:52 <lispy> and one point of using Haskell is that you should find it easier to experiment with algorithms
20:06:01 <vgax> dons: i have the fastest poker hand evaluation algorithm there is :)
20:06:17 <zeno_> maybe the fastest in C isnt the fastest in Haskell
20:06:29 <dons> vgax: some kind of bit array for marking off hands, with a smarter generator, would be a better approach wouldn't it?
20:06:31 <eu-prleu-peupe1> yes offcourse
20:06:35 <dons> a tree of hands to generate
20:06:41 <jaj> http://hpaste.org/7228 could anybody explain me this error?
20:06:42 <dons> prune the search space a bit
20:06:49 <Cale> Parallelism and state tend to break that right away, because you can have two programs running in different threads which stomp all over one another. So there are things like STM, pure parallelism (par), and (nested) data parallelism, which are nice ways to avoid those problems.
20:06:52 <vgax> dons: that how it works
20:06:53 <eu-prleu-peupe1> i think the C code on the shootout is veryyyyy un-optimized, probably because C coders dont care about silly benchmarks :P
20:06:55 <Pseudonym> The fastest algorithm on a Sparc might not be the fastest algorithm on a Pentium, either.
20:07:08 <dons> vgax: you could also try parallelising it (do parts of the search space in separate threads)
20:07:24 <geezusfreeek> well, STM still breaks some of that safety, but it's still much nicer than explicit locks
20:07:30 <vgax> dons: do i need extra libs?
20:07:32 <lispy> jaj: you're probably missing a lift
20:07:38 <dons> vgax: for what, bit arrays?
20:07:51 <vgax> parallel
20:08:04 <Cale> jaj: try putting  liftIO (getPage Overview)  in place of  getPage Overview
20:08:07 <eu-prleu-peupe1> does haskell support continuations ?
20:08:10 <dons> vgax: concurrency is built in, the 'parallel' library on hackage.haskell.org has some nice combinators that make it easier though
20:08:11 <eu-prleu-peupe1> like scheme ?
20:08:11 <geezusfreeek> eu-prleu-peupe1: the shootout is full of unidiomatic code on all fronts. i think it's full of crap
20:08:16 <geezusfreeek> eu-prleu-peupe1: oh yeah
20:08:27 <Cale> eu-prleu-peupe1: Not in the same sense that scheme does.
20:08:31 <eu-prleu-peupe1> "unidiomatic" ?
20:08:32 <eu-prleu-peupe1> hmm
20:08:32 <vgax> dons: what about bit arrays?
20:08:34 <jaj> lispy: indeed, thanks :)
20:08:41 <Cale> eu-prleu-peupe1: But there's a continuation monad.
20:08:42 <geezusfreeek> eu-prleu-peupe1: http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Cont.html
20:08:43 <lambdabot> http://tinyurl.com/gnsuu
20:08:46 <dons> vgax: just use STUArray Bool, they're in the 'array' library, which is bundled
20:08:50 <Cale> (which is just a library)
20:08:56 <Pseudonym> I agree with geezusfreeek on that one.
20:09:07 <Pseudonym> Real language comparisons are rare.
20:09:07 <vgax> dons: is that the fastest?
20:09:10 <dons> the shootout is very useful as a source of data structure benchmarks
20:09:16 <Cale> That is, continuations are not first class, but you can work with them using a library.
20:09:22 <dons> vgax: STUArrays are raw bit packing arrays. they're insanely fast.
20:09:33 <vgax> dons: thanks a bunch
20:09:58 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsievebits&lang=all  STUArray woot!
20:09:59 <lambdabot> Title: nsieve-bits benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Langu ..., http://tinyurl.com/sxpth
20:09:59 <geezusfreeek> the benchmark measures which languages are the most c-like more than anything
20:10:06 <Cale> In fact, I find the continuation monad a little easier to comprehend than first class continuations, because it's just a little more obvious what the continuation is at any point.
20:10:11 <dons> geezusfreeek: definitely, its how close you can get to the metal
20:10:26 <dons> after the C guys find the machine-optimised evaluation strategy
20:10:41 <eu-prleu-peupe1> you can get much better than C, so in that point the shootout is quite right
20:10:42 <eu-prleu-peupe1> :)
20:10:46 <eu-prleu-peupe1> s/can/cant
20:10:57 <Cale> But first class continuations break referential transparency, so we wouldn't want them.
20:11:07 <eu-prleu-peupe1> referential transparency ?
20:11:21 <zeno_> eu-prleu-peupe1: you can? i thought compilers produced faster assember than humans usually
20:11:22 <Cale> The property that a function always gives the same result for the same parameters.
20:11:36 <gwern> @hoogle openFd
20:11:36 <lambdabot> No matches found
20:11:44 <geezusfreeek> eu-prleu-peupe1: my point is that the rules of the benchmark require certain restrictions, like strictness, which do not play fair with languages that are designed with different philosophies
20:11:44 <zeno_> never mind saw the sed =p
20:12:22 <Cale> Or, if you want, the property that if f x = g x for all x, then any instance of f can be replaced with g throughout the program without changing its meaning.
20:12:28 <eu-prleu-peupe1> yes i see
20:12:50 <Cale> Basically, the idea that functions are *completely* determined by input-output pairs and nothing else, like functions in mathematics.
20:13:24 <geezusfreeek> eu-prleu-peupe1: and even though some of those restriction may, in fact, make a haskell program faster, it's still not very idiomatic, and it also doesn't indicate the fact that had those structures been implemented lazily and used in an actual program instead of a benchmark it may indeed perform more quickly than the c version
20:13:29 <eu-prleu-peupe1> where can i learn about all that mambo-jambo of programming languages, like "referencial transparency", and stuff like that ?
20:13:41 <gwern> @search openFd
20:13:41 <lambdabot> Unknown command, try @list
20:13:42 <geezusfreeek> eu-prleu-peupe1: right here :)
20:13:45 <gwern> eu-prleu-peupe1: osmosis
20:13:46 <vgax> lol
20:14:25 <gwern> dang it. where does 'openFd' come from?
20:14:30 <eu-prleu-peupe1> yes, that is a case geezusfreeek
20:14:51 <eu-prleu-peupe1> osmosis seems fine :)
20:15:11 <vgax> could be bit slow though :)
20:15:14 <eu-prleu-peupe1> hehehe
20:15:28 <eu-prleu-peupe1> ill try osmosis with wikipedia
20:15:37 <vgax> lol
20:15:37 <geezusfreeek> eu-prleu-peupe1: just learn lazily!
20:15:48 <eu-prleu-peupe1> :)
20:15:51 <vgax> let haskell do it for you
20:15:56 <Pseudonym> One thing: If I had to nominate the biggest unsolved problem in pure lazy functional programming, it's predicting resource usage.
20:16:07 <dibblego> eu-prleu-peupe1, referential transparency is also sometimes called purity or a "pure function"; Haskell is a pure functional language
20:16:15 <Pseudonym> Mind you, that's an unsolved problem in general.
20:16:26 <eu-prleu-peupe1> hmm
20:16:26 <gwern> dons: where does 'openFd' come from? local, lambdabot, and web hoogle don't know it, and I don't see any definitions in the bytestring-mmap repo, and the GHC libraries index doesn't seem to know it
20:16:32 <gwern> and google isn't helping
20:16:38 <vgax> Pseudonym: doesn't seem that hard
20:16:41 <Pseudonym> But resource usage (like memory) is much more of a global property of the program in Haskell than in some other languages.
20:16:53 <dibblego> eu-prleu-peupe1, it's pure because all functions are pure (or referentially transparent)
20:16:58 <awesame>  which constructs force evaluation in haskell?
20:16:59 <eu-prleu-peupe1> "referential transparency", means its reference is transparent ?
20:17:04 <vgax> can't we throw genetic programming at it
20:17:12 <gwern> @hoogle ReadOnly
20:17:13 <lambdabot> No matches found
20:17:15 <awesame> I have a book that says that guards force eval
20:17:15 <ABoyNamedWooh> how can I do division of an Integer such that 123 `div` 100 yields 1.23 instead of 1?
20:17:23 <dibblego> eu-prleu-peupe1, no, it means what Cale said earlier
20:17:25 <geezusfreeek> vgax: genetic programming hasn't done much for us yet
20:17:39 <dibblego> > 123 / 100
20:17:40 <eu-prleu-peupe1> oh i see
20:17:42 <lambdabot>  1.23
20:17:45 <vgax> geezusfreeek: what have you used it for?
20:17:53 <ddarius> Bah, referential transparency simply means that a reference (a variable) can be replaced by it's definition without changing the semantics of the program.
20:18:00 <vgax> > floor (123/100)
20:18:02 <eu-prleu-peupe1>  the property that if f x = g x for all x, then any instance of f can be replaced with g throughout the program without changing its meaning.
20:18:03 <lambdabot>  1
20:18:06 <geezusfreeek> vgax: i mean "us" in a very general computer science sense
20:18:10 <vgax> ah
20:18:15 <Cale> eu-prleu-peupe1: yeah
20:18:28 <vgax> > (123:Int)/(100:Int)
20:18:29 <lambdabot>   Not in scope: data constructor `Int'
20:18:33 <Pseudonym> http://citeseer.ist.psu.edu/41732.html <- Some more research of this type is also needed.
20:18:34 <lambdabot> Title: Haskell vs. Ada vs. C++ vs. Awk vs. ... An Experiment in Software Prototyping Pr ...
20:18:38 <ABoyNamedWooh> (123 :: Integer)/(100 :: Integer)
20:18:40 <vgax> > (123::Int)/(100::Int)
20:18:41 <lambdabot>   add an instance declaration for (Fractional Int)
20:18:41 <lambdabot>     In the expression: (12...
20:18:43 <dibblego> I've always liked the definition given at http://foldoc.org/function
20:18:45 <eu-prleu-peupe1> i dont see how "no side effects" comes from that rule
20:18:52 <ABoyNamedWooh> > ï»¿(123 :: Integer)/(100 :: Integer)
20:18:52 <lambdabot>  Illegal character ''\187''
20:18:52 <lambdabot>  at "»¿(12..." (column 2)
20:19:02 <ABoyNamedWooh> oops
20:19:05 <ABoyNamedWooh> ï»¿> ï»¿(123 :: Integer)`div`(100 :: Integer)
20:19:12 <dibblego> eu-prleu-peupe1, a side-effect would imply that all occurrences of the expression are not equivalent
20:19:21 <eu-prleu-peupe1> haskell makes me feal my mind is really really small
20:19:34 <vgax> > (123::Int) / (100::Int)
20:19:35 <lambdabot>   add an instance declaration for (Fractional Int)
20:19:35 <lambdabot>     In the expression: (12...
20:19:39 <eu-prleu-peupe1> which in fact it is
20:19:39 <geezusfreeek> eu-prleu-peupe1: haskell doesn't have side-effects. what you actually do with a haskell program is you lazily write an imperative program which performs those side-effects for you
20:19:46 <geezusfreeek> it's easier than it sunds
20:19:47 <geezusfreeek> *sounds
20:19:47 <ABoyNamedWooh> ï»¿> ï»¿(123 :: Integer) `div` (100 :: Integer)
20:19:53 <lament> people in this channel make me feel my mind is really small
20:20:00 <vgax> lol
20:20:01 <dibblego> > 123 / 100
20:20:03 <lament> haskell is just a language :)
20:20:03 <lambdabot>  1.23
20:20:05 <dibblego> > 123 / 100 -- ABoyNamedWooh
20:20:06 <lambdabot>  1.23
20:20:10 <vgax> ABoy just use floor
20:20:33 <ABoyNamedWooh> what does floor do?
20:20:36 <eu-prleu-peupe1> dibblego: a side-effect would make that rule invalid for all x, is that it ?
20:20:42 <ABoyNamedWooh> I have 2 integers and normal division gives no decimal
20:20:55 <vgax> > floor 1.99
20:20:56 <lambdabot>  1
20:21:01 <vgax> see
20:21:10 <ABoyNamedWooh> that's not what I want...I guess I was inspecific
20:21:17 <ABoyNamedWooh> I want to be able to divide 2 integers and get the decimal
20:21:18 <ABoyNamedWooh> like
20:21:25 <dibblego> eu-prleu-peupe1, correct
20:21:28 <vgax> mod
20:21:29 <ABoyNamedWooh> 123 ::Integer / 100 :: Integer and get 1.23
20:21:29 <vgax> ?
20:21:40 <ABoyNamedWooh> but then I'd have to piece together the decimal...was hoping to avoid that
20:21:40 <awesame> anyone?  I need a reference for which constructs force evaluation in Haskell.
20:21:45 <vgax> ABoy that can't be done
20:21:58 <dibblego> > 123 / 100 -- ABoyNamedWooh I want to be able to divide 2 integers and get the decimal like 1.23
20:21:59 <lambdabot>  1.23
20:22:10 <ddarius> Uthius: At best, all your "proof" does is show that each side has the same type.  You need to actually use the definitions or some (assumed) properties of the functions if you want to prove equivalence.
20:22:13 <eu-prleu-peupe1> geezusfreeek: that whats makes me actually prefer C over haskell... its very hard to manage if using haskell to perform lazy compositions of side-effects (monads) is better than just coding all procedurally :P
20:22:40 <ABoyNamedWooh> > do {let f = 123 :: Integer; let y = 100 :: Integer; return $ f `div` y;}
20:22:40 <lambdabot>  Parse error at "let" (column 29)
20:22:52 <geezusfreeek> eu-prleu-peupe1: how much haskell have you actually written?
20:22:53 <ABoyNamedWooh> hmm
20:22:54 <eu-prleu-peupe1> i like the __attribute__((__pure__)) gcc attribute
20:23:00 <dibblego> eu-prleu-peupe1, you don't prefer C; you just don't understand Haskell :)
20:23:03 <eu-prleu-peupe1> geezusfreeek: 0 :)
20:23:09 <awesame> eu-prleu-peupe1: monads give you a clear boundry between the pure functional code and the side-effects
20:23:11 <geezusfreeek> eu-prleu-peupe1: that's your problem ;)
20:23:29 <Pseudonym> eu-prleu-peupe1: I agree that the attribute pure thing is one of the things that makes C more useful than it otherwise would be.
20:23:31 <eu-prleu-peupe1> i think in haskell i would be coding with monads all the time, because in my mind its "more efficient"
20:23:37 <geezusfreeek> monads are beautiful. to understand monads is to truly understand imperative programmming
20:23:42 <vgax> can we just use haskell as an imperitive language?
20:23:53 <Pseudonym> But it's not standard, and it's horribly verbose, and most importantly, it's the wrong default.
20:24:01 <dibblego> vgax, sure, it's quite good at it even
20:24:05 <eu-prleu-peupe1> there is an even more hardcore gcc attribute, its the const
20:24:17 <eu-prleu-peupe1>  * Functions marked with __ATTR_CONST do not examine any values except
20:24:17 <eu-prleu-peupe1>  * their arguments, and have no effects except the return value. This
20:24:17 <eu-prleu-peupe1>  * is a stricter class than __ATTR_PURE (see below), since the function
20:24:17 <eu-prleu-peupe1>  * is not allowed to read global memory. Such a function can be subject
20:24:17 <eu-prleu-peupe1>  * to common subexpression elimination and loop optimization in GCC.
20:24:19 <zeno_> vgax: isnt that what the IO modad is?
20:24:37 <eu-prleu-peupe1> sorry about the spam
20:24:38 <vgax> havn't gotten that far in learning haskell :)
20:24:44 <ABoyNamedWooh> > do {x <- getClockTime; y <- getClockTime; let c = diffClockTimes y x; return $ (((tdSecs c)*1000000000000) `div` (tdPicosecs c)) `div` 1000000000000
20:24:45 <lambdabot>  Parse error at end of input
20:24:49 <vgax> no your not :0
20:25:02 <ABoyNamedWooh> ï»¿> do {x <- getClockTime; y <- getClockTime; let c = diffClockTimes y x; return $ (((tdSecs c)*1000000000000) `div` (tdPicosecs c)) `div` 1000000000000;}
20:25:29 <Dino__> Any idea on this one ? http://hpaste.org/7224 Thanks
20:25:30 <geezusfreeek> eu-prleu-peupe1: if you like that about C then you and Haskell _belong_ together
20:25:52 <awesame> yeah, I'm with geezusfreeek there
20:26:04 <vgax> eu-prleu-peupe1: yeah but in a room
20:26:10 <eu-prleu-peupe1> lol
20:26:11 <vgax> i don't want to see that
20:26:13 <zeno_> functions in haskell are ATTR_CONST
20:26:28 <Pseudonym> eu-prleu-peupe1: Imagine that was a strong guarantee, that the compiler could infer.
20:26:30 <eu-prleu-peupe1> those are my macros for the attributes :P
20:26:37 <Pseudonym> And that the compiler could check for correctness.
20:26:37 <ABoyNamedWooh> ï»¿> do {x <- getClockTime; y <- getClockTime; let c = diffClockTimes y x; return $ (((tdSecs c)*1000000000000) `div` (tdPicosecs c)) `div` 1000000000000;}
20:26:48 <Pseudonym> Do that, and you're thinking in Haskell.
20:26:52 <zeno_> ?ping
20:26:59 <Pseudonym> ?botsnack
20:26:59 <lambdabot> :)
20:27:00 <eu-prleu-peupe1> hmm
20:27:01 <eu-prleu-peupe1> i see
20:27:12 <eu-prleu-peupe1> but i like the pointers and array expressive power
20:27:15 <vgax> hmm lets write a port scanner in hasekell?
20:27:22 <zeno_> whats wrong with woohs attempt
20:27:23 <geezusfreeek> eu-prleu-peupe1: pointers and arrays are not expressive
20:27:28 <vgax> i think it can work well
20:27:37 <eu-prleu-peupe1> for me they are, and specially when i think in terms of cache block size
20:27:45 <eu-prleu-peupe1> i really enjoy the power that arrays have
20:27:46 <awesame> geezusfreeek: they're expressive of concepts close to the machine
20:27:59 <geezusfreeek> awesame: yes, i was about to rephrase to say something like that
20:28:02 <dibblego> eu-prleu-peupe1, they are not very expressive in the greater scheme of expressivity
20:28:04 <Pseudonym> awesame: Where by "machine" you are, of course, referring to a PDP7.
20:28:12 <Pseudonym> C has no support for SIMD instructions, for example.
20:28:13 <geezusfreeek> eu-prleu-peupe1: they are not composable at all
20:28:38 <eu-prleu-peupe1> Pseudonym: it has ... you have intel extensions (which are very good), and -msse :)
20:28:41 <eu-prleu-peupe1> or openmp
20:28:44 <eu-prleu-peupe1> with vectorization
20:29:06 <Pseudonym> That's not C.  That's the related language of C plus nonstandard and non-portable extensions and libraries.
20:29:19 <eu-prleu-peupe1> haskell has support for simd ?
20:29:23 <geezusfreeek> eu-prleu-peupe1: you need to meet par :)
20:29:27 <eu-prleu-peupe1> par ?
20:29:30 <eu-prleu-peupe1> who is par ?
20:29:37 <geezusfreeek> i don't think ghc does simd by itself, but i could be wrong
20:29:37 <eu-prleu-peupe1> ah
20:29:38 <dibblego> ?type par
20:29:39 <lambdabot> forall a b. a -> b -> b
20:29:40 <eu-prleu-peupe1> par like parallel
20:29:50 <Pseudonym> eu-prleu-peupe1: Almost.  But that's not the point.  The point is that C isn't as close to a modern machine as people think.
20:29:58 <geezusfreeek> eu-prleu-peupe1: par is a primitive for parallelism of pure functions
20:30:21 <zeno_> @hoogle simd
20:30:22 <lambdabot> No matches found
20:30:29 <Pseudonym> And it's an odd way to think, but the further away from the machine that you are, the more scope there is for optimisation.
20:30:30 <araujo> thanks eu-prleu-peupe1 ;-)
20:30:34 <Pseudonym> Think of SQL, for example.
20:30:41 <eu-prleu-peupe1> hey araujo ;) you are welcome
20:30:45 <Pseudonym> The same query might do very different things depending on what indexes are present.
20:30:58 <eu-prleu-peupe1> is haskell cache aligned ?
20:31:40 <eu-prleu-peupe1> i find it hard to think about what jumps the machine might be doing when im thinkin in haskell
20:31:52 <geezusfreeek> eu-prleu-peupe1: you don't want to
20:31:57 <Pseudonym> Yeah, that's the idea.
20:31:59 <eu-prleu-peupe1> and then i think "in C, this would be a simple array, and it would be optimally fast"
20:32:18 <Pseudonym> If it's any consolation, Haskell still lets you write C for your inner loops, once you've found them via profiling.
20:32:18 <eu-prleu-peupe1> array traversal, and stack operations are the sliced bread of C
20:32:21 <geezusfreeek> that is exactly why i don't like c
20:33:11 <sjanssen> eu-prleu-peupe1: do you write programs where this actually matters?
20:33:17 <awesame> eu-prleu-peupe1: to be fair "optimally fast" isn't exactly right.  haskell can sometimes be automatically parallelized, for example, where C can't.
20:33:43 <eu-prleu-peupe1> sjanssen: i dont, but it makes me sleep better at night
20:33:44 <Pseudonym> I think that one thing that you might be missing is that "cycle counting" (as it is known) is one tool out of many in the programmer's toolbox.
20:33:47 <awesame> sjanssen: I write programs where that actually matters
20:34:02 <eu-prleu-peupe1> i think it should matter everytime
20:34:03 <Pseudonym> It's very important to know when it's appropriate and when it isn't.
20:34:08 <Pseudonym> Really?
20:34:12 <Pseudonym> Do you not write shell scripts?
20:34:14 <geezusfreeek> eu-prleu-peupe1: it really doesn't matter most of the time
20:34:21 <geezusfreeek> why would it?
20:34:45 <conal> geezusfreeek: thanks for the paste!
20:34:54 <zeno_> Pseudonym: i think some of the bash syntax is really unnatural :(
20:34:56 <geezusfreeek> conal: np
20:34:59 <eu-prleu-peupe1> because you would be terribly destroying your code performance
20:35:00 <ddarius> vgax: I believe someone has already written a port scanner in Haskell.
20:35:02 <eu-prleu-peupe1> and that is a bad thing
20:35:14 <Pseudonym> But what you lose in "performance", you gain in flexibility.
20:35:24 <awesame> it's not bad if your code goes fast enough the slow way
20:35:25 <Pseudonym> Moreover, "performance" doesn't mean the same thing to everyone.
20:35:35 <byorgey> eu-prleu-peupe1: you just said "non-optimal performance is bad, because it is bad".
20:35:36 <eu-prleu-peupe1> i think, "i have spent 600euros on this computer, so this code better squeeze the last drop of performance out of it..."
20:35:41 <byorgey> not a very convincing argument. =)
20:35:41 <geezusfreeek> eu-prleu-peupe1: _why_ is it so bad, first of all? and secondly, i want to point out again that haskell compiled with ghc is pretty quick most of the time
20:36:05 <Pseudonym> eu-prleu-peupe1: One thing you need to remember is that your time is more expensive than your CPU's time.
20:36:07 <eu-prleu-peupe1> byorgey: :) argumentation is not my strongest quality
20:36:10 <awesame> there are more things to optimize for than just speed (like, memory consumption, concurrency, clarity)
20:36:12 <geezusfreeek> eu-prleu-peupe1: you are slower than the computer. a program taking an extra millisecond of time will not slow you down a bit
20:36:25 <byorgey> eu-prleu-peupe1: well, I think, "I have a bunch of things to do with my time, so writing this code better squeeze the last drop of performance out of me"
20:36:31 <zeno_> eu-prleu-peupe1: alot of the time its the difference between a thousandth and 2 thousands of a second, i dont think you can tell :)
20:36:33 <ddarius> Pseudonym: You are assuming that.
20:36:34 <dejones> sometimes lots of $$$ is saved by saving the programmer time rather than cpu cycles.
20:36:39 <byorgey> I care much more about my performance than my computer's.
20:36:42 <Pseudonym> ddarius: It's true in my case.
20:36:46 <awesame> geezusfreeek: particularly if you saved three hours writing it in haskell!
20:36:49 <dejones> byorgey: exactly :)
20:36:49 <ddarius> Pseudonym: In your case, yes.
20:36:50 <Pseudonym> True, I'm assuming it of eu-prleu-peupe1.
20:36:54 <byorgey> eu-prleu-peupe1: besides, your computer is sitting there wasting cycles most of the time anyway.
20:36:56 <zeno_> eu-prleu-peupe1: and you may gain alot of time since writing haskell is easier
20:37:10 <Pseudonym> Moreover, you need to consider the cost of fixing a bug or adding a feature.
20:37:18 <awesame> but it's true that for some tasks you need more control than haskell will give you
20:37:23 <Pseudonym> WHich is what programmers spend most of their coding time doing.
20:37:44 <geezusfreeek> awesame: but i want to point out that the percentage of tasks that require more control than haskell gives you are very very very small
20:37:51 <awesame> true
20:37:53 <Cale> Besides, if you're writing the sort of program which is going to sit there and crunch for 3 months, the best approach might be to write a special-purpose compiler in a high level language.
20:38:03 <Pseudonym> Cycle counting often locks you into an architecture.  Maintenance can make your original architecture decisions obsolete.
20:38:06 <ddarius> I like to spend my time producing bugs for others to fix.
20:38:07 <eu-prleu-peupe1> hmm i see
20:38:47 <Pseudonym> Now, I do embedded real-time stuff as part of my job, so believe me, I understand cycle counting.
20:38:59 <conal> geezusfreeek: http://hpaste.org/7229 shows a simple implementation of Data.Future via IVal (was called TIVal), using your idea (i think) for mappend.  getIVal is what we'd called "force" on IVal.  if you have any comments, i'd love to hear.
20:39:03 <Pseudonym> But even that is very much a proper subset of my job.
20:39:08 <ddarius> Cycle counting is fun!
20:39:31 <eu-prleu-peupe1> and you do that in haskell Pseudonym ?
20:39:50 <geezusfreeek> conal: yes it was my idea. reading it nowâ€¦
20:40:02 <conal> geezusfreeek: i just pasted an annotation with Data.Val
20:40:10 <geezusfreeek> alright
20:40:23 <Pseudonym> eu-prleu-peupe1: No.
20:40:25 <conal> geezusfreeek: i meant i'm not sure i translated your idea accurately.
20:40:30 <eu-prleu-peupe1> see
20:40:31 <Pseudonym> I use Haskell for prototyping and to keep my sanity.
20:40:34 <geezusfreeek> conal: right, i'm checking
20:40:35 <eu-prleu-peupe1> :)
20:40:39 <eu-prleu-peupe1> ok
20:42:00 <sclv> I wish haskell special-cased Num more -- like plain old type inference for everything else but some special backtracking or whatever nonsense for values of (Num a) => a
20:42:05 <awesame> once more with feeling: how do I figure out when haskell will evaluate an expression?
20:42:21 <geezusfreeek> eu-prleu-peupe1: but you have already seen a haskell demo. there is also a first person shooter called Frag hanging around somewhere
20:42:26 <sclv> hand annotating numbers passed to polymorphic functions is a PITA
20:42:28 <conal> geezusfreeek: btw, i really like that idea of reuse `orElse` compute.
20:42:39 <Pseudonym> BBS
20:42:47 <sclv> awesame: it evaluates it when it needs it.
20:43:16 <geezusfreeek> conal: your mappend looks fine, i think
20:43:16 <ddarius> awesame: Why do you care?
20:43:35 <geezusfreeek> conal: thanks!
20:43:37 <awesame> ddarius: I want to understand how to work out memory usage vs runtime
20:43:47 <sclv> one thing you can do to get intuition is to import Debug.Trace and then insert traces before various expressions to see when thunks are actually invoked.
20:44:03 <sjanssen> sclv: we already have numeric defaulting...
20:44:12 <awesame> if the modern answer is "ghc is smarter than you, you're not allowed to know", that's fine, I just want to understand the situation
20:44:14 <ddarius> awesame: Evaluate by hand using call-by-need.
20:44:21 <sclv> sjanssen: it doesn't work with my fancy polymorphic functions.
20:45:01 <conal> geezusfreeek: great.  i've started rebuilding Reactive on this basis.  it's a little less general than the approach in my paper (due to the assumption on when futures become knowable), but sure seems simpler.
20:45:07 <awesame> ddarius: does that mean that only IO ever forces eval?  I have a book that seems to claim that a guard will force eval.  and, seq?
20:45:13 <geezusfreeek> and it's good to see your observations in writing about the behavior of mappend when a future becomes knowable before its time has actually come.
20:45:29 <awesame> my book is from 1996 though
20:45:45 <conal> geezusfreeek: yeah, that's the bit.  nice to know what the tradeoff is.
20:45:49 <geezusfreeek> conal: i worked with that assumption only because my purposes depend on events being causal anyway
20:45:56 <geezusfreeek> games
20:46:09 <sclv> if I have class ToExpr a b | a -> b and instance ToExpr Int Int then if I pass in something of (Num a => a) it can't handle it. This happens surprisingly more often than you'd imagine.
20:46:10 <conal> geezusfreeek: a useful counterexample is timer events.
20:46:27 <geezusfreeek> conal: what do you mean?
20:47:01 <conal> geezusfreeek: i can define an event that occurs at known future time(s).
20:47:10 <eu-prleu-peupe1> haskell has eval ? (like perl has ?)
20:47:22 <conal> geezusfreeek: and then mappend with a future that comes sooner but is knowable later
20:47:31 <sclv> awesame: seriously. use Debug.Trace if you're curious -- and there are legitimate reasons to need to know for various things you get up to -- ensuring that certain expressions are only evaluated once, for example.
20:47:38 <conal> geezusfreeek: then the future implementation is wrong
20:47:55 <geezusfreeek> conal: perhaps another constructor for future could explicitly state this sort of case?
20:47:56 <ddarius> awesame: Ultimately, main is the source for all need, but usually you only work on part of a program at a time.
20:48:00 <geezusfreeek> might ugly things up a bit though
20:48:12 <geezusfreeek> there is already one for Never though
20:48:40 <conal> geezusfreeek: might.  another example: collision between known trajectories.  we can sometimes solve analytically.
20:48:57 <sclv> awesame: if x = (a `seq` b), then evaluation of a will only be forced when x is forced.
20:48:58 <awesame> sclv: Debug.Trace will be useful, thanks
20:49:26 <geezusfreeek> conal: i really think there are probably other possible solutions besides making futures knowable in advance
20:49:57 <conal> geezusfreeek: me too.
20:50:11 <conal> geezusfreeek: it's just that there are some advantages to knowing a future before it arrives.
20:50:19 <conal> geezusfreeek: e.g., cut down on reaction latency.
20:50:42 <geezusfreeek> conal: yeah. i still think that latency can be addressed in some other way. hopefully that way can be found!
20:50:56 <conal> geezusfreeek: sure.
20:51:46 <conal> geezusfreeek: for now, i'm going to give this version a try.  i'll see if it triggers the hang problem.  your trimmed down test case should help a lot!
20:52:08 <geezusfreeek> alright. keep me up to date!
20:52:15 <shapr> @yow !
20:52:15 <lambdabot> I smell a RANCID CORN DOG!
20:52:17 <shapr> @users
20:52:17 <lambdabot> Maximum users seen in #haskell: 459, currently: 413 (90.0%), active: 24 (5.8%)
20:52:20 <shapr> yarr
20:52:20 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
20:52:29 <shapr> hm
20:52:32 <conal> geezusfreeek: will do.  knock-em dead tomorrow.
20:52:39 <geezusfreeek> conal: thanks
20:55:20 <eu-prleu-peupe1> they say haskell is good for my health
20:56:34 <ddarius> It's high in fiber, gets the bowels moving.
20:56:40 <eu-prleu-peupe1> :)
20:57:04 <Cale> It's possibly good for your mental health, though also possibly not if you're still going to be forced to write Java for 8 hours a day.
20:57:19 <eu-prleu-peupe1> i dont like the logo that much :/
20:57:24 <ddarius> Me neither.
20:57:38 <Cale> Yeah, perhaps I should design a new one, but I'm not sure what I'd make it.
20:57:48 <Pseudonym> There are worse logos.
20:58:00 <Pseudonym> But yeah, I agree.
20:58:54 <Cale> I was playing around with ideas for a GHC logo a while back, and wasn't terribly happy with anything.
20:59:19 <eu-prleu-peupe1> hmm
20:59:24 <eu-prleu-peupe1> what about an open contest for a logo ?
20:59:47 <eu-prleu-peupe1> i did like the summer of code logo though
21:00:00 <Cale> I did that one :)
21:00:11 <lament> yeah, the logo is pretty terrible
21:00:17 <eu-prleu-peupe1> it was very nice :D congratulations
21:00:42 <lament> it could be worse... it could be the london olympics logo
21:00:44 <Cale> http://cale.yi.org/autoshare/ghc.png -- This is probably my favourite potential GHC logo of the stuff I've come up with, but it's not quite what I'd like it to be.
21:01:13 <eu-prleu-peupe1> why the lambda ?
21:01:24 <ddarius> Cale: I don't like it.
21:01:24 <geezusfreeek> eu-prleu-peupe1: it's in reference to lambda calculus
21:01:33 <eu-prleu-peupe1> hmm
21:01:37 <Cale> ddarius: yeah. I don't really care much for it either.
21:01:39 <lament> Cale: fewer colours would be nice.
21:01:46 <lament> the purple is totally gratuitous
21:01:49 <eu-prleu-peupe1> this logo seems like those 80's logos
21:02:06 <eu-prleu-peupe1> i like its retro feeling, but im not sure it would be nice in a language of the future
21:03:06 <solrize_> it should have something plaid with bagpipes since it's glasgow.  the bagpipes could be opened out to a lambda shape ;)
21:03:16 <Cale> Hehe
21:03:21 <eu-prleu-peupe1> i like that logo of the alien with the lisp flag "alien technology" :)
21:03:27 <solrize_> yeah
21:03:36 <Cale> Yeah, I played around a bit with Glasgow tartan, but it's a bit odd :)
21:03:47 <eu-prleu-peupe1> http://lispers.org/
21:03:48 <lambdabot> Title: Lisp - made with secret alien technology
21:04:16 <Cale> http://www.gerardbutlerreviews.com/Tartantrivia/0534k6Glasgow.jpg
21:04:38 <Cale> http://www.gerardbutlerreviews.com/Tartantrivia/UOGTartan.jpg -- there's for the University of Glasgow.
21:04:52 <Cale> (which is a little more workable, I think)
21:05:13 <dons> there's a lot of haskell philosophy in this article, http://www.fastcompany.com/node/28121/print
21:05:14 <lambdabot> Title: They Write the Right Stuff
21:05:25 <dons> just building systems that don't go wrong by construction.
21:05:27 <Cale> http://www.gerardbutlerreviews.com/Tartantrivia/PrideofScotland.jpg -- there's also the Pride of Scotland, which might be appropriate.
21:05:28 <lambdabot> http://tinyurl.com/5m8xfu
21:05:59 <dons> "Don't just fix the mistakes -- fix whatever permitted the mistake in the first place"
21:06:37 <Pseudonym> Hey, there's a Peyton tartan.
21:07:04 <Pseudonym> Oh, you use the MacDonald one.
21:08:32 <dons> clearly these days we'd use lolbots
21:08:42 <dons> or a pyramid with an evil eye
21:08:56 <lament> tartans are so weird.
21:09:03 <lament> they're a lot like barcodes.
21:09:13 <Pseudonym> lament: That's very true, actually.
21:09:25 <Pseudonym> The assigning of tartans to clans is an English invader thing.
21:09:27 <solrize_> hehe dons
21:09:49 <dons> http://www.lisperati.com/landoflisp/panel57.html
21:09:50 <Pseudonym> Traditionally, scottish textile makers just made whatever tartan they wanted.
21:10:00 <lament> coats of arms at least have a pretty picture that symbolizes something. It's an elaborate visual language for symbolizing stuff.
21:10:06 <dons> the angry lolbot army in glasgow tartan
21:10:25 <dons> building more perfect software :)
21:10:41 <gwern> they advance, twirling their skirls and shouting theorems, and their arms are full of lambdacats
21:10:47 <gwern> truly a fearsome prospect
21:11:05 <eu-prleu-peupe1> off to bed
21:11:06 <dons> their comonadic future weapons kick butt
21:11:07 <eu-prleu-peupe1> hasta*
21:11:17 <eu-prleu-peupe1> thanks for all the hints, and conversation
21:11:37 <gwern> and each battle is won by the smallest possible margin, as they lazily send in only enough warriors
21:12:20 <sclv> poor fluffles. every time i read that comic i get a little choked up...
21:12:24 <dons> lisp might be alien, but haskell is built by man. like the cylons :)
21:12:40 <gwern> we're building a language which can be proud of us?
21:13:06 <dons> cylons are programmed in haskell. that's why they just work .. and destroy
21:13:39 <eu-prleu-peupe1> hasta la pasta*
21:14:06 <sclv> the machines... they've learned... how to perform side effects....
21:14:10 <gwern> (argh... adapting bytestring-mmap to darcs is just so hard, since I don't know what half the stuff in either is doing)
21:16:13 <solrize_> that nasa article is pretty interesting, it doesn't say what language they use but i guess it's ada
21:16:29 <gwern> I think it's some old custom language, actually
21:16:46 <zeno_> are nested wheres allowed?
21:16:47 <solrize_> yow
21:16:53 <gwern> (lower-level than ada, iirc)
21:16:54 <solrize_> zeno_ no i don't think so
21:16:57 <dons> yeah, it would be pre-Ada wouldn't it
21:17:01 <dons> zeno_: yeah :)
21:17:07 <zeno_> ah thx :)
21:17:13 <dons> > let x = y where y = z where z = a where z = 2  in x + x
21:17:15 <lambdabot>  a + a
21:17:21 <dons> heh
21:17:22 <solrize_> aha, cool :)
21:17:26 <dons> > let x = y where y = z where z = a where a = 2  in x + x
21:17:28 <lambdabot>  4
21:18:00 <sclv> lots of times though if you rethink your code, it turns out you don't need nested wheres at all (although sometimes you do)
21:18:21 <solrize_> i confused it with not being able to use where inside an expression
21:18:28 <solrize_> i tend to use let instead of where because of that
21:19:14 <solrize_> do they wrote those nasa specs with Z notation?
21:19:39 <solrize_> http://slashdot.org/developers/00/05/19/050258.shtml  slashdot thread about the article
21:19:41 <lambdabot> Title: Slashdot | Space Shuttle Software: Not For Hacks
21:20:05 <solrize_> http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=242519
21:20:14 <solrize_> The authors discuss the development of a complexity domain model for the HAL/S programming language in which all of the space shuttle software is written.
21:20:54 <solrize_> http://en.wikipedia.org/wiki/HAL/S
21:20:55 <lambdabot> Title: HAL/S - Wikipedia, the free encyclopedia
21:22:22 <jaj> seems like they're finally developing HAL 9000 ;)
21:22:33 <Dino__> Any idea on how I could print the elements of the list by using also break line,  http://hpaste.org/7224 Thanks
21:23:44 <Dino__> I would like to get back , only the values, without anything else, and including breaklines,
21:23:51 <Dino__> I really don't know how to work it out
21:23:54 <zeno_> since you cannot use where in an expression is (\x y -> let a = b x y in c a) legal?
21:24:44 <zeno_> ( i know it could be c (b x y) but say if a was used more than once
21:24:51 <solrize_> dino, looking
21:25:13 <conal> zeno_: yep
21:25:38 <zeno_> cool, thx
21:25:43 <solrize_> i'd say use putStrLn on each line you want to print
21:26:38 <solrize_> i have an officemate who used to program in ada
21:27:19 <solrize_> and i described coding in haskell as struggling through many iterations of trying to understand and fix compiler error messages, followed by getting a program that worked correctly as soon as the compiler stopped complaining
21:27:24 <solrize_> and he said that sounded like ada
21:27:26 <Dino__> @solrize the values are retrieved from a text file, which are stored as a list,
21:27:26 <lambdabot> Unknown command, try @list
21:28:07 <Dino__> and when I call the function, I get back this [Playlist {pTitle = "a", pArtist = "a", pPerformer = "a", pLength = 5, pPlaycount = 0, pGenre = "pop"}]
21:28:43 <Dino__> what I want to do , is to get back only the values when the file is read,
21:29:13 <solrize_> one of the design characteristics of ada (and apparently hal/s) is it's supposed to be very easy for non-programmers (e.g. spacecraft designers who know about turbine pressure curves but not that much about code) to read and validate
21:30:06 <solrize_> zomg
21:30:25 <solrize_> A shuttle uses five AP-101s as "general-purpose computers" (GPCs). Four operate in sync, for redundancy, while the fifth is a backup running software written independently. The shuttle software is written in HAL/S, a special-purpose high-level language, whereas AP-101s used by the US Air Force are mostly programmed in JOVIAL. ..
21:30:54 <solrize_> As of 2006, JOVIAL is still actively maintained and distributed by the USAF JOVIAL Integrated Tool Set (ITS) Program Office, and a commercially supported JOVIAL Compiler System is available from DDC-I.
21:31:25 <solrize_> Notable systems using JOVIAL include the Advanced Cruise Missile, B-52, B-2 bombers, C-130, C-141, and C-17 transport aircraft, F-15, F-16 (prior to Block 50), and F-117 fighter aircraft, LANTIRN, U-2 aircraft, E-3 Sentry AWACS aircraft, Special Operations Forces, Navy Aegis cruisers, Army Multiple Launch Rocket System (MLRS), Army UH-60 Black Hawk helicopters, F100, F117, F119 jet engines, the NORAD air defense & control system (Hughes HME-5118ME s
21:31:26 <solrize_> ystem) and RL-10 rocket engines.
21:31:29 <solrize_> aieeee
21:34:48 <dons> http://cgi.cse.unsw.edu.au/~dons/blog/2008/04/28#cylon-technology :)
21:34:50 <lambdabot> Title: Haskell hacking
21:35:31 <solrize_> wow, look at this, someone asked who the "Jules" in Jovial was (Jovial stands for Jules' Own Version of the International Algebraic Language)
21:35:37 <solrize_> Jules himself answered !
21:35:39 <solrize_> http://en.wikipedia.org/wiki/Talk:JOVIAL_%28programming_language%29
21:35:40 <lambdabot> http://tinyurl.com/62cqq8
21:36:08 <solrize_> heh dons, that looks like a vorlon
21:38:36 <vegai> "Real World Haskell" is priced at 50$ in amazon currently. Is that going to be the final price?
21:38:53 <Cale> It looks a heck of a lot more like a cylon :)
21:39:15 <dons> vegai: unknown. we don't get to decide these things.
21:39:23 <dons> 50 seems reasonable
21:39:38 <vegai> for us europeans anyway :)
21:39:41 <dons> cheap!
21:39:49 <dons> like 3 cups of coffeee
21:40:01 <vegai> that's some quality coffee you drink
21:40:04 <dons> hehe
21:40:12 <dons> the finest indonesian lemur coffee
21:40:22 <shachaf> dons: Do you get to decide on the book cover?
21:40:23 <Cale> vegai: as is evidenced by the extra 'e'
21:40:36 <shapr> dons: Civet cat coffee?
21:40:40 <dons> shapr: that's the stuff
21:40:59 <Cale> Coffeeee
21:41:04 <dons> shachaf: we have some input i think
21:41:17 <dons> narwhals or unicorns?
21:41:24 <shapr> You've really tried civet cat coffee?
21:41:30 <shachaf> dons: So it hasn't been decided on yet?
21:41:35 <dons> shapr: no, i've seen it in sydney though
21:41:39 <dons> shachaf: not yet.
21:41:51 <shapr> I'm not sure I want to eat anything that's traveled through the digestive tract of a mammal.
21:42:01 <dons> ~$100/kg iirc
21:42:04 <shapr> Of course, I eat cheese... and that's ...
21:42:10 <zeno_> i think i just constructed the worst function ever :(
21:42:25 <dons> i think we could have a suite of future-robot themed haskell logs.
21:42:26 <solrize_> http://www.flickr.com/photos/22009051@N05/2398308853/   man that looks like a cylon contraption
21:42:27 <dons> logos.
21:42:27 <lambdabot> Title: Siphon Bar, Blue Bottle Coffee Co. on Flickr - Photo Sharing!
21:42:37 <shapr> Excreted from a gland and then digested by germs, that's cheese.
21:42:38 <dons> way better than stupid green aliens.
21:42:47 <dons> these guys will crush and destroy :)
21:42:51 <Pseudonym> At least it's not something really disgusting, like an egg.
21:42:52 <vegai> shapr: don't forget mold
21:42:58 <shapr> Right
21:43:06 * dons is glad to be vegan right now
21:43:08 <shapr> Pseudonym: Yeah, unfertilized ovum please.
21:43:20 * Pseudonym hopes dons keeps up his vitamin B12
21:43:31 * zeno_ is glad he is eating steak tonite
21:43:32 <shapr> Or how about shrimp? I've heard the housefly is a 'close' relative to shrimp.
21:43:41 <shapr> zeno_: You're eating muscles!
21:43:50 <zeno_> yup mmmm
21:43:54 * shapr grins
21:44:00 <shapr> Ok, I'm going to go cause chaos elsewhere now.
21:44:05 <cjb> huh, python lets you create partially-applied functions.  Who knew.
21:44:44 <solrize_> well, it has closures
21:44:45 <shapr> Yeah, but WHAT GOOD ARE THEY?
21:44:48 <zeno_> is that new in 3000?
21:44:53 <shapr> Ok, now I'm really taking my chaos elsewhere.
21:45:06 <solrize_> zeno no it's been there for a while
21:45:30 <cjb> i.e.:  addfive = partial(add, 5)
21:45:40 <Cale> Mmm... chicken and eggs. Nothing like eating the dead and unborn of the same species at once.
21:45:42 <cjb> partial's in functools
21:45:57 <solrize_> partial(f,x) = lambda *args: f(x, *args)   or something like that
21:46:03 <zeno_> ah cool, still less natural than (+ 5) though :)
21:46:36 <cjb> solrize_: yup.
21:51:19 <gwern> huh. this is a mystery. so I've removed all use of hGetBuf from the darcs code, cleaned and rebuilt and manually removed the old binary and everything, and somehow it is still erroring out as 'darcs: /home/gwern/foo/bigtempfile: hGetBuf: failed (Bad address)'
21:51:31 <gwern> what could possibly be calling hGetBuf?
21:51:58 <gwern> I can only think something in a library like bytestring
21:52:45 <sjanssen> gwern: ByteString definitely uses it
21:53:27 <gwern> great, and of course profiling doesn't track stuff back into bytestring
21:53:55 <sjanssen> build bytestring with -auto-all
21:58:24 * gwern gives up. time to call it a night
21:59:40 <ivanm> gwern: what are you calling a night? :p
22:00:01 <shachaf> ivanm: The night.
22:00:12 <ivanm> so the night is a night? :o
22:03:07 <solrize_> gwern, run under ghci and use a breakpoint?
22:12:18 <ddarius> gwern: Use more goat's blood.
22:13:20 <ivanm> ddarius: sounds tasty, got any good recipes? ;-)
22:25:57 <solrize_> dons?
22:31:23 <geezusfreeek> wow dons http://cgi.cse.unsw.edu.au/~dons/blog/2008/04/28
22:31:26 <lambdabot> Title: Haskell hacking
22:31:41 <geezusfreeek> oh you already linked it here
22:31:57 <geezusfreeek> just... wow...
22:34:27 <Cale> geezusfreeek: hehe
22:34:31 <solrize_> what is that a picture of?  is that a cylon?
22:34:34 <Cale> Yes.
22:35:05 <Cale> I like the implication that Haskell is going to try to wipe us out and replace us.
22:35:10 <ivanm> lol
22:35:16 <solrize_> according to wikipedia, cyclons were created by the twelve colonies of kobol
22:35:22 <solrize_> which suggests they weren't programmed in haskell :)
22:35:30 <OceanSpray> "Use those extra cores and beat C today! (Parallel Haskell redux)"
22:35:31 <ivanm> solrize_: parallel language evolution
22:35:31 <Cale> solrize_: Still, humans.
22:35:31 <ivanm> duh
22:35:32 <solrize_> http://en.wikipedia.org/wiki/Cylon_%28re-imagining%29#Background
22:35:33 <OceanSpray> Ha ha oh wow.
22:35:45 <OceanSpray> ...that bring me back to a previous question:
22:35:46 <geezusfreeek> solrize: didn't you know that they use haskell on the colonies?
22:35:50 <OceanSpray> how do you "split" an array?
22:35:53 <solrize_> i would have though tthey used kobol :)
22:36:02 <solrize_> kommon battlestar oriented language :)
22:36:06 <ivanm> @type splitAt
22:36:07 <lambdabot> forall a. Int -> [a] -> ([a], [a])
22:36:11 <solrize_> http://coboloncogs.org
22:36:19 <Cale> OceanSpray: there isn't a good builtin, you typically construct two new arrays from the contents.
22:36:23 <jaj> until now I thought haskell was amazing. now I start to fear it...
22:36:39 <OceanSpray> I got a two dimensional IArray, and I just want the top half and the bottom half separate.
22:36:43 <OceanSpray> dang.
22:36:57 <Cale> solrize_: ahahaha!
22:37:07 <ivanm> OceanSpray: oh, split an _array_ :o
22:37:37 * sjanssen just finished the first season of BSG
22:37:45 <Cale> sjanssen: How are you finding it?
22:38:01 <sjanssen> Cale: I like it
22:39:45 <OceanSpray> Cale, for that Imlib thing you wrote,
22:39:59 <OceanSpray> you can "fuse" two images together, right?
22:40:20 <OceanSpray> top half, bottom half, same resolutions...
22:41:20 <Cale> Let me refamiliarise myself with imlib for a moment, but yes, there should be an easy way to do that.
22:41:26 <sjanssen> dons: unsafeKillHuman shouldn't be allowed in the Cylon Monad
22:42:29 <lament> sadly, unsafePerformIO is :)
22:45:17 <Cale> Man, I should really update that library already...
22:47:22 <Cale> OceanSpray: ah, right, you'd use blendImageOntoImage
22:47:46 <OceanSpray> ok, thanks
22:47:54 <OceanSpray> wait, "blend"?
22:48:22 <Cale> yes, since it's actually more general, it'll do alpha blending
22:48:43 <Cale> er
22:48:51 <Cale> I suppose you could use imageCopyRect
22:48:59 <Cale> er, hmm
22:49:08 <Cale> No, that doesn't work
22:49:38 <newsham> hi
22:49:59 <Cale> Yeah, stick with blendImageOntoImage
22:50:22 <Cale> To simply copy the two source images into an appropriately sized larger image.
22:52:33 <Cale> Hi, that reminds me, I should apply that patch now :)
22:53:21 <newsham> :)
22:57:13 <Cale> done :)
22:57:21 <OceanSpray> patch?
22:57:23 <OceanSpray> to imlib?
22:57:23 <Cale> rebuilding lambdabot...
22:57:27 <OceanSpray> oh.
22:57:38 <Cale> OceanSpray: newsham sent me some patches :)
22:58:12 <Cale> OceanSpray: The Imlib update would take a while. I'm about 1/4 of the way through a properly documented and carefully written version.
22:58:17 <OceanSpray> I wonder what wondrous wonders newsham bestowed upon this wonderful automated communicator.
22:58:42 <Cale> (which I haven't touched in a while, since it's really tedious work writing bindings that I won't personally need)
22:58:51 <newsham> ocean: more means of time wasting
22:59:02 <Cale> Some new quotes modules and a stock ticker, by the looks of it.
22:59:15 <Cale> lambdabot: @quit
22:59:22 <Cale> @nixon
22:59:27 <lambdabot> Certainly in the next 50 years we shall see a woman president, perhaps sooner than you think. A woman can and should be able to do any political job that a man can do.
22:59:35 <dons> heh
22:59:37 <Cale> Well, that seems sensible.
22:59:40 <Plareplane> @nixon
22:59:45 <lambdabot> The second point is that coming out--coming back and saying that black Americans aren't as good as black Africans--most of them , basically, are just out of the trees.  Now, let's face it, they are.
22:59:53 <OceanSpray> wow, feature bloat, anyone?
22:59:59 <ivanm> why did someone write a nixon plugin?
23:00:00 <Cale> @farber
23:00:07 <lambdabot> We need to do it ex-post-hasto.
23:00:15 <Cale> ivanm: for fun
23:00:21 <newsham> ?tick cadusd=x
23:00:22 <dons> hunter s. thompson quotes next
23:00:29 <lambdabot> CADUSD=X: 0.9912 N/A - @ 4/28/2008 1:58am
23:00:35 <OceanSpray> so are these capabilities hard-coded into lambdabot, or is there some sort of plugin/module system?
23:00:42 <Cale> OceanSpray: plugins
23:00:47 <OceanSpray> ah.
23:01:31 <Cale> Sigh, that's it, trackerd dies.
23:01:40 <Adamant> @elite . nixon
23:01:45 <lambdabot> . NIX0n
23:01:50 <Cale> @. elite nixon
23:01:55 <lambdabot> I'M g14D I'm Not 8REshneV. 8Eing +h3 rU5zIAn l3aD3R iN ThE kr3/\/\1iN. u ne\/Er xN0w iph $OM30nE'$ t4pe RE(0RdING w|-|at u 54y.
23:02:14 <Adamant> that's quality right there.
23:02:29 <solrize_> zomg
23:03:04 <Cale> Nice, Ubuntu, don't even put trackerd in your list of easily-disabled system services, so I have to edit the rc.d directories manually.
23:03:19 <Adamant> tracked?
23:03:22 <Adamant> *trackerd
23:03:45 <Cale> It's some file indexing system which likes to sit at 100% cpu for hours.
23:03:48 <dibblego> that's the one that chews all the CPU after you boot
23:04:08 <newsham> cpu fan utility? :)
23:05:34 <Plareplane> um, cale
23:05:41 <Plareplane> you can turn it off in your gnome sessions
23:06:08 <Cale> ah, so that's where it is.
23:06:10 <Plareplane> or maybe unless there are multiple of them
23:06:15 <Cale> Yeah, I wasn't finding it in rc*.d
23:07:04 <Plareplane> the trackerd that first came with gutsy was awful about 100%ing my cpu, but the one with hardy hasnt done so yet (knock on wood)
23:07:34 <Cale> Yeah, I just switched to hardy.
23:07:40 <Cale> I have quite a lot of files though.
23:08:03 <Plareplane> if this is "the" cpu usage bug, it's because your trackerd index is corrupted
23:08:18 <Plareplane> telling trackerd to reindex (or just deleting your index) fixes it
23:08:28 <Cale> Well, that's possible, but I find the activity annoying anyway.
23:09:08 <Cale> At first it was actually indexing the *contents* of all the files, which is completely useless to me, so I turned that off, but it was still wasting too much in the way of resources.
23:09:46 <Cale> I can use the unix find utility if I really need to find something.
23:10:20 <newsham> you might already have "locate" index too.
23:10:26 <Cale> yeah, there's that too
23:11:00 <Cale> How much time does my computer really have to spend on making it easy to find my already carefully-organised files?
23:11:30 <sjanssen> Cale: I just uninstalled it
23:11:35 <Plareplane> you mean you don't have all 10000 files in My Documents with descriptive names like Untitit~2.doc?
23:11:36 <Cale> sjanssen: yeah.
23:11:42 <Cale> Plareplane: heh
23:11:59 <sjanssen> though I do wonder which idiot decided to turn it on by default in the first place
23:12:16 <Plareplane> it defaulted to being off on my laptop, but not on my desktop
23:12:25 <Plareplane> i'm not sure why, since i don't thinnk i did the installations any differently
23:13:02 <sjanssen> to reduce power use, I'm sure
23:19:24 <zeno_> is there a way to make prelude "step"?
23:19:25 <desegnis> Oh wow. I just purchased a used Macbook Pro, to be delivered soon, and only now find all those board posts about failing linux drivers. Crap!
23:19:50 <ivanm> desegnis: heh
23:19:58 <ivanm> why would you buy a mac to run linux?
23:20:02 <zeno_> desegnis: arnt PCS usually cheaper for the hardware (since your running linux in any case)
23:20:35 <desegnis> ivanm, because I also want some OSX experience, but a notebook not running linux wouldn't make me happy either
23:21:19 <desegnis> zeno_, ^
23:21:19 <ivanm> ahhhhh
23:21:26 <Cale> A while back one reason might be that you wanted to be running on ppc.
23:21:45 <Cale> (which is a nicer architecture in many ways, if you really care about that)
23:21:53 <zeno_> Cale: now that sucks (i know since i have a PS3)
23:22:06 <Caelum> there's a hacked iso of OSX floating around that runs on PCs
23:22:12 <zeno_> less hardware support
23:22:26 <Cale> zeno_: Sure, but you might not care about that.
23:23:15 <Cale> zeno_: A project I worked on a few years ago involved Haskell code which wrote very optimised PPC/Altivec code for signal processing algorithms.
23:24:45 <Cale> PPC chips were largely much more predictable and easy to do constraint optimisation of low-level code on than Intel chips.
23:25:28 <Adamant> Cale - PPC also used to have way better FP and SIMD support, I thought
23:25:35 <Cale> Yes, that's true.
23:25:39 <Cale> (Altivec)
23:26:11 <solrize_> altivec is still better architecturally, intel got ahead by having faster raw silicon
23:26:13 <zeno_> hmmm i want to ask a question but i feel really dumb (my first haskell program)
23:26:26 <Cale> Go for it, we were all beginners at some point :)
23:26:37 <Adamant> solrize_: Cell is probably better than Altivec
23:26:52 <solrize_> adamant, cool, i haven't really looked at cell
23:26:55 <zeno_> i know this should be a fold but which one? chain p used = chain (sqs !! 3) (chain (sqs !! 2) (chain (sqs !! 1) (link (sqs !! 0)))) --link and sqs are in the where
23:27:08 <Cale> Yeah, Cell is a really very nice architecture for that sort of thing, which is why those guys switched to it (which happened after I left)
23:27:19 <solrize_> intel has something called AVX coming, which is sort of like a wider SSE with some new operations, but i dunno if it will be as good as altivec by then
23:27:59 <Cale> zeno_: looks like a right fold
23:28:51 <zeno_> yeah was thinking foldr chain (something) [] sqs, but not sure what something is
23:29:32 <Cale> actually, since you're folding over the reverse...
23:29:34 <solrize_> (foldr chain $ take 3 $ tail seqs)
23:29:34 <Cale> foldr chain (link (head sqs)) (reverse (tail sqs))
23:29:52 <solrize_> hmm
23:29:58 <cjs> Question. I have to do some reasonably complex parsing of messages I receive, but only in certain cases; in other cases I need to do only a bare minimum of parsing. I'm assuming that lazyness will help me there, but are there situations where I might not be lazy if I'm not careful?
23:30:01 <zeno_> sqs could be reversed too would that help?
23:30:08 <Cale> (supposing that your example was meant to extend)
23:30:12 <zeno_> thanks for the input BTW :)
23:30:14 <Cale> yeah
23:30:22 <cjs> (Probably too generally, really, but I'm looking for hints as to what to watch out for.)
23:30:34 <Cale> Is sqs supposed to be exactly 4 elements long?
23:30:44 <solrize_> zeno_ i don't understand these nested func calls
23:30:47 <zeno_> 0-8
23:30:50 <Cale> (or you're really only using the first 4 elements?)
23:30:55 <zeno_> was just giving an example of what it would look like
23:30:59 <Cale> ah, okay
23:31:09 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
23:31:19 <zeno_> neat :)
23:31:20 <lambdabot> Title: Fold Diagrams - CaleWiki
23:31:27 <Cale> I made those diagrams to help choose which fold your thing fits :)
23:31:43 <Cale> Most often you want foldr, though in some cases a foldl is appropriate.
23:32:11 <Cale> zeno_: What happens if sqs is empty?
23:32:24 <Cale> zeno_: That'd be a special case not handled by my code above.
23:32:29 <solrize_> wow those are awesome
23:32:34 <zeno_> actually it can be 0-3
23:32:37 <zeno_> 3-8
23:32:41 <zeno_> sorry
23:32:47 <Cale> ah, okay
23:32:54 <zeno_> (and its order doesnt matter for the result)
23:33:04 <zeno_> @src link
23:33:05 <lambdabot> Source not found. I am sorry.
23:33:18 <Cale> In any event, you'll probably want to stick a case in for the empty list which reports a more meaningful error than:
23:33:20 <Cale> > head []
23:33:21 <lambdabot>  Exception: Prelude.head: empty list
23:33:40 <Cale> Just in case :)
23:33:47 <zeno_> @pl chain (sqs !! 0) (chain (sqs !! 1) (chain (sqs !! 2) (link (sqs !! 3))))
23:33:47 <lambdabot> chain (sqs !! 0) (chain (sqs !! 1) (chain (sqs !! 2) (link (sqs !! 3))))
23:34:12 <Cale> > foldr f z [0,1,2,3]
23:34:13 <lambdabot>  f 0 (f 1 (f 2 (f 3 z)))
23:34:49 <Cale> > foldr f (g 3) [0,1,2]
23:34:50 <lambdabot>  Add a type signature
23:34:59 <Cale> > foldr f (g 3) [0,1,2] :: Expr
23:35:00 <lambdabot>  f 0 (f 1 (f 2 (g 3)))
23:35:37 <Cale> > foldl (flip f) (g 0) [1,2,3]
23:35:38 <lambdabot>  Add a type signature
23:35:40 <Cale> > foldl (flip f) (g 0) [1,2,3] :: Expr
23:35:41 <lambdabot>  f 3 (f 2 (f 1 (g 0)))
23:36:02 <Cale> That fits your original pattern :)
23:36:12 <zeno_> foldr chain (flip link) [] sqs
23:36:21 <Cale> hmm
23:36:50 <Cale> that looks like a type error...
23:37:03 <edwardk> @seen dolio
23:37:03 <lambdabot> dolio is in #haskell-blah and #haskell. I don't know when dolio last spoke.
23:37:18 <dolio> What up?
23:37:28 <zeno_> > foldr (flip chain) (flip link) [1,2,3] :: Expr
23:37:29 <lambdabot>   Not in scope: `link'
23:37:30 <edwardk> not much, i went through and finished the distributive law stuff
23:37:38 <Cale> foldl (flip chain) (link (head xs)) (tail xs)
23:37:39 <dolio> How's it look?
23:37:46 <edwardk> much nicer and a lot smaller, one sec
23:37:57 <Cale> (of course, you'd probably pattern match the head and tail of xs)
23:38:16 <Cale> oh, wait!
23:38:27 <Cale> zeno_: Is chain really supposed to be recursive like that?
23:38:28 <czakey> you killed lambdabot ;p
23:38:29 <edwardk> dolio: check http://comonad.com/haskell/hylo/src/Hylo/ (i'm clacking away in those while you look, so be warned it may tweak =)
23:38:30 <lambdabot> Title: Index of /haskell/hylo/src/Hylo
23:38:37 <Cale> czakey: I did?
23:38:39 <zeno_> Cale: yes
23:38:54 <czakey> ah without >
23:38:57 <Cale> zeno_: I mean, you defined chain as a bunch of applications of chain...
23:39:03 <Cale> chain p used = chain (sqs !! 3) (chain (sqs !! 2) (chain (sqs !! 1) (link (sqs !! 0))))
23:39:06 <Cale> was your example...
23:39:23 <Cale> chain occurs on both sides of the equation there -- is that intended?
23:39:38 <Cale> I suppose it's okay...
23:39:50 <zeno_> i think i got it though! foldl (flip chain) (last sqs) (init sqs)
23:40:03 <Cale> ooh, avoid last and init
23:40:43 <Cale> hmm
23:40:44 <edwardk> note that its smaller than before and supports more things, for instance i can define a new ghylo-variant that has an apomorphic futumorphism on one side and a paramorphic histomorphism on the other and the definition fits on a line.
23:40:53 <Cale> zeno_: which order do you want the sqs in now?
23:41:08 <zeno_> Cale: why avoid last and init
23:41:18 <Cale> zeno_: they're both O(n)
23:41:19 <zeno_> (its a list of 3-8 elements)
23:41:25 <Cale> Oh, I suppose that's true.
23:41:35 <Cale> Forgot about that :)
23:41:50 <dolio> edwardk: Interesting stuff.
23:42:13 <edwardk> distZygoT/distParaT/distApoT/distGApoT are new but i didn't want to make up new names to let me use them =)
23:42:51 <edwardk> most of the time i was spending was trying to figure out how to write those laws
23:43:10 <zeno_> > foldl (flip f) (g (last sqs)) [1, 2, 3] :: Expr
23:43:11 <lambdabot>   Not in scope: `sqs'
23:43:19 <zeno_> > foldl (flip f) (g 4) [1, 2, 3] :: Expr
23:43:20 <lambdabot>  f 3 (f 2 (f 1 (g 4)))
23:43:29 <dolio> Oh, I forgot about metas in the category-extras release.
23:43:33 <edwardk> took me about an hour to figure out  distZygoT g k = ZygoT . liftW (g . fmap (liftW fst) &&& fmap (snd . extract)) . k . fmap (duplicate . runZygoT)
23:43:36 <zeno_> yessss :) what i wanted thanks a thon Cale
23:43:56 <Cale> zeno_: No problem :)
23:44:27 <Cale> zeno_: If the sqs were in the reverse order to begin with though, it would perhaps be simpler.
23:44:43 <Cale> (Unless that's unnatural)
23:44:54 <edwardk> i'm half-tempted to switch from 'ZygoT' to a better named reader comonad transformer but i think that would actually make it harder to figure out whats going on
23:45:07 <Cale> > foldr f (g 4) [3,2,1]
23:45:08 <lambdabot>  Add a type signature
23:45:11 <Cale> > foldr f (g 4) [3,2,1] :: Expr
23:45:12 <lambdabot>  f 3 (f 2 (f 1 (g 4)))
23:45:53 <Cale> (and note that the 4 that you peel off would be at the beginning of the list, which is the easy end to tear things from)
23:46:04 <Cale> So it'd be something like:
23:46:13 <zeno_> still i learned alot from that so not a total waste :)
23:47:28 <Cale> let (x:xs) = sqs in foldr chain (link x) xs
23:47:44 <Cale> (where the sqs convention is reversed from the other one)
23:47:59 <Cale> I suppose you could also just explicitly reverse the list :)
23:50:04 <zeno_> what i did :)
23:58:00 <leandrom> hello, sorry if it is a dumb question, but I there a way to split a line when writing a function? It's very long and I'm writing a report where the code is longer that document margins
23:58:26 <leandrom> s/I/is/
23:59:12 <zeno_> just put a new line and indent it more to the right than the last one
23:59:25 <geezusfreeek> leandrom: you should be able to just insert a new line anywhere you want as long as you respect the layout rules
23:59:53 <leandrom> zeno_, ok thank you
