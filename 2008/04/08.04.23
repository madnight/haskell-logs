00:01:42 <Cale> RogerTaylor_: hmmm, yeah, I'm seeing that behaviour as well
00:02:07 <Cale> RogerTaylor_: maybe it only works with absolute bases?
00:02:51 <RogerTaylor_> The docs for that module are carefully written, so I'd expect it to mention that
00:03:05 <RogerTaylor_> No worries, I'm just going to stomp on it with some string concatenation
00:03:27 <Cale> RogerTaylor_: I'll see if I can work out what's going on
00:03:27 <RogerTaylor_> and not carp about whether the libs are RFC-compliant or not
00:03:29 <RogerTaylor_> :-)
00:03:38 <RogerTaylor_> Don't waste your time on my behalf
00:03:45 <Cale> It's probably something worth submitting a ticket about at least.
00:04:10 <RogerTaylor_> err... I've had enough subtle bugs in the libs that I'm becoming resigned to doing it mostly by hand
00:04:21 <RogerTaylor_> while I'm carping about URI handling
00:04:30 <RogerTaylor_> (but, I hasten to add, not the Haskell libs)
00:04:35 <Cale> Pseudonym: You should chime in about your level of support on the ($) thread :)
00:04:47 * Pseudonym reads haskell-prime in digest mode
00:04:50 <RogerTaylor_> do you think "foo%3Fbar"
00:04:56 <Pseudonym> Hard for me to do that and keep metadata.
00:05:18 <RogerTaylor_> means "foo?bar" - bar is a query string, or the pat helement is "foo?bar"
00:05:35 <RogerTaylor_> Apache 1.3 is confused about this
00:05:37 <glguy> path element
00:05:45 <RogerTaylor_> right, i totally concur
00:05:51 <RogerTaylor_> but Apache does not (half of the time)
00:05:54 <Cale> I would hope that it's a path element.
00:06:01 <RogerTaylor_> try it out, if you can
00:06:10 <Gnezdo> Is trac a good place to submit ghc bug reports?
00:06:38 <glguy> RogerTaylor_: apache.org treats %3f as a path element
00:06:43 <Cale> http://cale.yi.org/foo%3fbar/
00:06:46 <Cale> seems to work.
00:06:48 <lambdabot> Title: Index of /foo?bar
00:06:49 <RogerTaylor_> err, some of the time
00:06:51 <RogerTaylor_> hold on
00:06:52 <bos> whee!
00:06:59 <RogerTaylor_> take a look at the PATH_INFO
00:07:05 <Gnezdo> after a week my http://hackage.haskell.org/trac/ghc/ticket/2223 didn't elicit any reaction :-(
00:07:08 <lambdabot> Title: #2223 (Int64.toInteger) - GHC - Trac
00:07:08 <bos> five new public beta chapters, and fifteen new alpha chapters for reviewers to chew over.
00:07:24 <RogerTaylor_> you'd get "foo?bar" - try leaving off the trailing '/' if you don't
00:07:39 <bos> get 'em while they're hot: http://www.realworldhaskell.org/blog/2008/04/23/five-new-chapters-for-review/
00:07:40 <lambdabot> Title: Real World Haskell » Blog Archive » Five new chapters for review, http://tinyurl.com/6comc4
00:08:34 <RogerTaylor_> so this makes PATH_INFO a little less that reliable
00:08:49 <glguy> the ? should be found in the path-info
00:09:20 <RogerTaylor_> i am confused
00:09:29 <RogerTaylor_> why decode it there?
00:09:45 <RogerTaylor_> argh
00:10:06 <glguy> % encoding is just for the URLs
00:10:13 <RogerTaylor_> i see
00:10:23 <RogerTaylor_> ok, i misunderstood what PATH_INFO is for
00:10:39 <RogerTaylor_> doesn't make my life easier, but at least it's my problem now.
00:10:40 <RogerTaylor_> thanks
00:15:04 <glguy> ?seen solrize
00:15:05 <lambdabot> solrize is in #haskell. I last heard solrize speak 2h 31m 33s ago.
00:15:11 <solrize> hey
00:15:42 <glguy> I was looking through the pastes and wanted to mention that: let n = stuff in case n of _ | ....    can be written: case stuff of n | ....
00:16:27 <solrize> oh, cool, thanks
00:18:00 <solrize> yeah, that's nicer
00:19:45 <solrize> is there a generally clean way of printing something once in a while during a long computation?
00:19:46 <RogerTaylor_> Cale: OK, there's another bug in the CGI lib
00:19:51 <inimino> I like Bulat's idea about precedence
00:19:59 <solrize> offsetmap = foldl' (\t (Offset (a,b))->t `seq` IM.insert a b t) IM.empty
00:20:00 <Cale> inimino: I'm not sure that I do :)
00:20:13 <inimino> Cale: why not?
00:20:19 <RogerTaylor_> queryString turns my %3F into '?'
00:20:24 <Cale> inimino: That would result in *really* hard to see bugs sometimes.
00:20:26 <RogerTaylor_> i.e. a path element into a query break
00:20:40 <inimino> Cale: true, but we will adapt no?
00:20:44 <Cale> inimino: Ones which were not necessarily even type errors.
00:21:08 <inimino> Cale: also, sytax highlighting can help (though that's a bit of a stretch I admit)
00:21:56 <inimino> Cale: it might bite some people yeah, but the elegance of it appeals to me
00:25:33 <RogerTaylor_> also getVars seems to think "foo%3Fbar" has a query parameter "bar"
00:26:08 <aleator> I'm twisting my brain into knots. How does Text.StringTemplate.renderf work?
00:28:13 <Cale> aleator: Similarly to Printf it seems?
00:29:30 <aleator> Well. That much I have heard :)
00:29:35 <od> whats the fastest way to take off the last word in a string performance wise?
00:30:00 <Cale> od: in a String? Or is ByteString an option?
00:30:22 <sjanssen> inimino, Cale: merd is one language that actually uses a version of Bulat's idea
00:30:24 <od> whichever is ok i think
00:31:01 <sjanssen> though I think he is crazy if "f g(x) h(y)" is a good idea
00:31:44 <Cale> sjanssen: Especially since if you're going to write that, why not just write f (g x) (h y)?
00:31:45 <sjanssen> if he thinks ... is a good idea
00:31:50 <sjanssen> Cale: exactly
00:32:04 <dolio> I think even the rubyists are getting rid of that sort of thing.
00:32:12 <inimino> sjanssen: interesting, they call it horizontal layout
00:32:25 <pjd_> dolio: they are?
00:32:48 <sjanssen> Cale: Bulat has all sorts of nutty suggestions :)
00:32:54 <Cale> sjanssen: I know.
00:32:54 <inimino> I thought the arithmetic operators were more compelling than function application
00:33:14 <dolio> pjd_: I don't follow it closely anymore, but I've heard a few times that 'f x, y, z' is going away in 2.0.
00:33:23 <dolio> Whenever that occurs.
00:34:02 <Cale> od: Sorry about that -- if it was a String, hmm... you have to find the last index at which there's a space and break the string there. It's O(n) no matter what you do.
00:34:04 <inimino> it's a slippery slope that may lead to Perl syntax though...
00:34:48 <Cale> od: But short of writing it recursively by hand, I might try findIndices together with last and either take or splitAt
00:35:10 <dolio> > (length "f g1(h1 x1 y1) g2(h2 x2 y2)", length "f (g1 $ h1 x1 y1) (g2 $ x2 y2)")
00:35:14 <lambdabot>  (27,30)
00:35:40 <dolio> Big big savings. :)
00:36:00 <Cale> od: With a ByteString, there are convenient things like  spanEnd (not . isSpace)
00:36:23 <Cale> (or even  breakEnd isSpace)
00:36:34 <od> yea that seems perfect
00:36:45 <od> parsec 2 doesnt take bytestrings though i dont think
00:36:56 <od> might end up being in the same boat depending how slow unpacking is
00:37:00 <Cale> Uh, actually I think that was one of the design goals for it.
00:37:08 <inimino> I think it does
00:37:12 <od> hmm k
00:37:12 <od> thanks
00:37:18 <sjanssen> dolio: you didn't write the same thing on each side
00:37:19 <Cale> er, Parsec 2...
00:37:26 <Cale> as opposed to 3 :)
00:37:39 <Cale> Okay, I had the version numbers mixed up :)
00:37:43 <dolio> Oh, yeah, I forgot an h2.
00:38:09 <dolio> > (length "f g1(h1 x1 y1) g2(h2 x2 y2)", length "f (g1 $ h1 x1 y1) (g2 $ h2 x2 y2)") -- is this right?
00:38:10 <Cale> > (length "f g1(h1 x1 y1) g2(h2 x2 y2)", length "f (g1 $ h1 x1 y1) (g2 $ h2 x2 y2)")
00:38:13 <lambdabot>  (27,33)
00:38:13 <lambdabot>  (27,33)
00:38:36 <Cale> Wow! 5 characters!
00:38:44 <pjd_> dolio: does that mean first-class methods, or is 'foo' still a call?
00:38:52 <Cale> and it's no easier to read :)
00:38:53 <inimino> um. 5?
00:38:57 <Cale> er
00:39:03 <Cale> > 33 - 27
00:39:04 <lambdabot>  6
00:39:06 <inimino> haha
00:39:10 <Cale> Okay, I'm tired :)
00:39:51 <Cale> I should really try sleeping again.
00:40:13 <inimino> it's easier to read for people that know more maths than Haskell
00:40:18 <dolio> pjd_: That I don't know. I imagine they'll keep 'bar.foo' a call, because that looks nice for pseudo-member/property access (and goes nice with 'bar.foo = baz'). But, like I said, I don't follow it closely anymore.
00:40:50 <dolio> I just think that a fair number of people think that 'f a, b, c = f(a,b,c)' is confusing.
00:41:04 <Cale> dolio: hm?
00:41:11 <dolio> Cale: In ruby.
00:41:13 <Cale> oh
00:41:26 <Cale> That is confusing :)
00:41:28 <dolio> Those are equivalent, modulo some other stuff.
00:41:42 <lament> i agree, it's confusing
00:42:09 <Cale> I'd expect the application of f to bind much tighter than ,
00:42:23 <dolio> 'f a, b, c { block }' is not the same as 'f(a,b,c) { block }' for instance.
00:42:24 <lament> yeah
00:42:28 <lament> (f a), b, c
00:42:35 <lament> is how i parse that :)
00:42:47 <inimino> but if "," has no other use, it's unambiguous
00:43:00 <lament> of course i'm thinking in haskell, not ruby
00:43:58 <Cale> What does  [f a, b, c]  mean?
00:44:07 <lament> hehe
00:44:18 <Cale> Indeed, it means [(f a, b, c)]
00:44:34 <Cale> Which is perhaps even more surprising.
00:44:39 <inimino> right, once "," is used for tuples or lists...
00:44:58 <inimino> then it gets odd
00:45:20 <Cale> irb(main):003:0> [square 5, 3, 4]
00:45:20 <Cale> (irb):3: warning: parenthesize argument(s) for future version
00:45:20 <Cale> ArgumentError: wrong number of arguments (3 for 1)
00:45:20 <Cale>         from (irb):3:in `square'
00:45:20 <Cale>         from (irb):3
00:45:21 <Cale>         from :0
00:47:26 <dolio> I used to think it looks nice for stuff like 'print "foo", 6, :bar'.
00:47:40 <dolio> But, of course, it's unlikely that you'd put that kind of thing in a list.
00:48:01 <Cale> Why not just go Haskell-style and have function application be denoted by whitespace?
00:48:13 <Cale> So you'd have  print "foo" 6 :bar
00:49:44 <dolio> So I can write "print 5 + 5, 77"? :)
00:50:32 <Cale> print (5 + 5) 77  isn't much worse :)
00:51:03 <Cale> The other thing I find confusing about ruby is that blocks are not first class values.
00:51:22 <Cale> Well, one other thing.
00:51:28 <lament> that really creeped me out when i looked at ruby
00:51:38 <Cale> It's like they went 90% of the way to discovering lambda and gave up.
00:51:43 <lament> like, why would the language designers commit flaws as huge and obvious
00:52:04 <dolio> It is rather weird.
00:52:05 <lament> makes one kinda worry about the state the rest of the language is in
00:52:25 <lament> same with the special syntax for passing _one block_ to things
00:52:39 <dolio> The really weird part is that 'Proc.new { block }' and 'lambda { block }' have different semantics.
00:53:25 <dolio> Or, they used to, at least.
00:53:39 <lament> on the plus side, most common combinators are possible and available in ruby
00:53:42 <lament> eg map and stuff
00:54:03 <dolio> They're all named after Smalltalk, though. :)
00:54:10 <lament> they're all named ending in -ect
00:54:19 <lament> is that from smalltalk?
00:54:33 <lament> i don't like it, but it does give it a more "objecty" than "functional" flavor
00:54:57 <lament> which makes sense, since ruby clearly isn't functional and clearly is OO
00:55:19 <dolio> Yeah. inject, collect, select are smalltalk names.
00:56:17 <lament> i bet there's many, many people in the world familiar with one of the two naming schemes ("select" vs. "map"), and not suspecting the existence of the other group
00:56:25 <lament> on both sides, too
00:56:50 <lament> c# also has names like collect
00:59:49 <dolio> select may actually be a better name, since filter is somewhat ambiguous as to whether you're keeping or discarding the things for which the predicate returns true.
01:00:01 <dolio> I'm not sure I see where the others come from, though.
01:00:03 <lament> it actually looks kinda cute
01:00:06 <lament> > let collect = flip map; select = flip filter in [1..10] `select` (>5) `collect` show
01:00:10 <lambdabot>  ["6","7","8","9","10"]
01:00:27 <lament> Ruby in Haskell :D
01:01:20 <lament> except (>5) would be \num -> num > 5
01:04:55 <dolio> > let infixl # ; x # f = f x in [1..10]#select (>5)#collect show
01:04:55 <lambdabot>   Not in scope: `select'
01:05:08 <dolio> > let infixl # ; x # f = f x in [1..10]#filter (>5)#map show
01:05:09 <lambdabot>  ["6","7","8","9","10"]
01:05:18 <lament> cute
01:05:45 <lament> i didn't know you could have infixls in lets
01:06:00 <dolio> Or if you really want to get hardcore...
01:06:12 <lament> oh no. no monads, please :)
01:06:14 <dolio> > let infixl . ; x . f = f x in [1..10].filter (>5).map show
01:06:15 <lambdabot>  ["6","7","8","9","10"]
01:06:27 <lament> nice
01:06:34 <lament> why does that even work :)
01:07:23 <lament> also, that should totally be a prelude builtin!
01:07:43 <lament> it will make intros to haskell seem so much friendlier to OO people, whereas in reality nobody would use it!
01:07:47 <lament> everybody wins
01:09:09 <quicksilver> > [1..10]>>>filter(>5)>>>map show
01:09:09 <lambdabot>  Couldn't match expected type `a b c' against inferred type `[a1]'
01:09:15 * quicksilver cries
01:09:59 <glguy> > (filter(>5)>>>map show) [1..10]
01:09:59 <lambdabot>  ["6","7","8","9","10"]
01:10:20 <lament> not the same!
01:10:38 <glguy> yeah, one type-checks
01:11:00 <Cale> lament: Function composition is one of the most important operations in functional programming and overriding it would be a crime?
01:11:25 <lament> nono, it wouldn't be the dot of course
01:11:42 <Cale> ah
01:11:47 <lament> some other operator, and all the tutorials would say "think of it as your familiar dot"
01:12:03 <lament> i'm joking of course
01:12:28 <glguy> might be easier to teach Python and just say that it's Haskell
01:13:11 <lament> call decorators "monads"
01:13:29 <quicksilver> lament: one of the bindings for C# or something used '#' as object deference
01:13:32 <quicksilver> i.e. '.'
01:13:40 <quicksilver> I think the cocoa binding, too?
01:13:45 <inimino> I'm sure Unicode has a different dot that could be used...
01:14:26 <inimino> ideally one that's visually indistinguishable
01:14:26 <lament> people are extremely hostile to any change of syntax
01:14:46 <Cale> Look at the thread about ($) on the Haskell' list
01:14:48 <lament> many people are "monolingual in notation"
01:15:12 * Cale got the ($) associativity flipped, which caused a few people to flip as well ;)
01:15:20 <lament> it must have curly braces, semicolons, parens fur function calls and The Dot :)
01:15:38 <lament> s/fur/for
01:15:41 <Baughn> Cale: How would that change anything?
01:15:55 <inimino> Cale: I thought the idea that Haskell' would just be a codification of existing practice was well-established, is that not the case?
01:16:02 <Baughn> Oh, right. Multi-parameter functions.
01:16:28 <Vq^> lament: indeed, we have been overrun by C-monkeys
01:16:31 <Cale> inimino: Well, that's what I thought too, but talking to Simon Marlow the other day, it seems that he thinks it should incorporate some fixes to the Prelude.
01:16:43 <dolio> Flipping the precedence of an operator isn't exactly adding a significant type system extension or anything.
01:17:06 <Cale> Baughn: You would have to write f . g . h $ x instead of f $ g $ h $ x, but in return, you get to write things like  f $ g x $ h y $ k z  for f (g x) (h y) (k z)
01:17:20 <Cale> and $! becomes saner to use
01:17:25 <dolio> Especially one whose precedence can't be flipped without losing compatibility with the current standard.
01:17:36 <Baughn> Cale: Sounds good to me
01:17:42 <Peaker> is the Haskell list archived?
01:17:52 <Cale> Peaker: yep, all of them are
01:18:10 <lament> Cale: i like that idea!
01:18:12 <Cale> http://www.haskell.org/haskellwiki/Mailing_Lists
01:18:13 <lambdabot> Title: Mailing lists - HaskellWiki
01:18:28 <lament> it's really quite pretty compared to the current state
01:18:31 <Cale> lament: Voice your support for it on the Haskell' list :)
01:18:47 <lament> but i bet it's too radical to get accepted
01:18:56 <inimino> Cale: it seems like minor Prelude tweaks would be an easier sell than major breaking syntax changes
01:19:15 <Baughn> It's not a syntax change, though it /would/ break things
01:19:18 <lament> yeah, it's breaking too
01:19:24 <Cale> inimino: We really ought to be fixing Num and lots of other major flaws while we're at it.
01:19:27 <Baughn> So write a converter. ;)
01:19:51 <Peaker> oh my it sorts by date -- not reversed - by default. I get posts from 2000
01:20:15 <lament> it's little flaws like this which you can't remove because of backwards compatibility that accumulate slowly and eventually cause the language to die and be replaced by a more modern competitor with all those flaws removed
01:20:19 <Cale> http://www.haskell.org/pipermail/haskell/
01:20:21 <lambdabot> Title: The Haskell Archives
01:20:22 <inimino> Baughn: well, ok, s/breaking syntax change/breaking operator precedence change/
01:20:30 <Cale> http://www.haskell.org/pipermail/haskell-cafe/
01:20:30 <lambdabot> Title: The Haskell-Cafe Archives
01:20:36 <Cale> http://www.haskell.org/pipermail/haskell-prime/
01:20:37 <lambdabot> Title: The Haskell-prime Archives
01:20:40 <lament> and haskell' is not that competitor
01:20:46 <Peaker> lament, I think the Python way is the right way to solve those things
01:20:52 <lament> (because it's still haskell)
01:21:04 <lament> Peaker: you mean py3k?
01:21:14 <Cale> I think we should be less afraid of breaking things than we already are.
01:21:38 <Peaker> lament, yeah,and intermediate warning releases
01:21:45 <lament> it's a good idea. It will keep Haskell a relevant research language
01:21:48 <Cale> Just focus on making the language as awesome as humanly possible.
01:21:56 <lament> (since no better alternative will be desired)
01:22:08 <inimino> Cale: breaking changes make people with large codebases to maintain nervous
01:22:11 <lament> backwards compatibility bogs the language down
01:22:21 <lament> but yeah, people are less likely to commit to your language
01:22:38 <Cale> If Haskell loses its place as a valid research language, then I lose probably 80% of my interest in it.
01:23:04 <lament> Cale: i think that the transition will be very smooth, as a competitor naturally arises
01:23:24 <lament> Cale: with the overall effect being simply of this very channel just changing its name :)
01:23:33 <inimino> heh
01:23:48 <lament> that's pretty much what happened with miranda and haskell, no?
01:24:05 <Cale> I don't want to bother improving my ability to use a language which is not going to improve along with me.
01:24:36 <lament> Cale: but what about even cutting-edger languages, agda, epigram?
01:24:50 <lament> not enough research there?
01:25:10 <glguy> What are the backwards compatibility breaking changes being discussed beyond $'s associativity?
01:25:21 <Cale> They're nice, but my current impression is that their type inference isn't so great.
01:25:21 <glguy> that you are going to quit using Haskell over?
01:25:42 <inimino> Cale: I hear people are writing books with titles like "Real World Haskell" now ;-)
01:25:50 <Cale> glguy: Heh, I'm not really talking about quitting Haskell over anything current.
01:26:16 <lament> haskell is really wonderful as a way of organizing thought
01:26:17 <Cale> glguy: Just the potential loss of research effort directed at it caused by inability to change the language itself.
01:26:18 <Baughn> If haskell stops improving, then eventually something will pass it, right?
01:26:21 <Baughn> ..probably a fork
01:26:27 <jorick> $ is going to be switched ?!
01:26:34 <Baughn> jorick: So we hope
01:26:38 <jorick> awesome ! :D
01:26:38 <glguy> not likely
01:26:39 <lament> Baughn: something related to haskell as haskell was related to miranda
01:27:11 <Cale> Baughn, jorick: Add a comment to the Haskell-prime list voicing your support for the change :)
01:27:18 <Baughn> lament: I wasn't around for miranda. Is haskell directly derived to the point of reusing code changes?
01:27:29 <lament> i don't actually know :)
01:27:32 <Peaker> where is the $ thread, I couldn't find it?
01:27:36 <Cale> The patch was applied by Simon Marlow, but there have been a couple of complaints
01:27:40 <Peaker> what do they want to change it to?
01:27:41 <lament> but i doubt it
01:27:52 <lament> Cale: of course there will be complaints
01:27:52 <Jaak> why would one want to change the $s assoc?
01:27:53 <Cale> patch applied (haskell-prime-status): add ""Make $ left associative, like application"
01:27:54 <glguy> the patch was aplied that makes it something being considered
01:28:02 <glguy> it wasn't applied tha tmakes it part of haskell prime
01:28:05 <dolio> From what I've read, miranda got left behind because people wanted an open language to standardize on, but the inventor wanted to keep it proprietary.
01:28:08 <dolio> Or something like that.
01:28:08 <Cale> glguy: ah
01:28:20 <Peaker> syntax/presentation should be separate from the model.. it will make these kinds of changes so much easier...
01:28:30 <Peaker> Also, one can make an automatic program convertor for such changes
01:28:40 <Peaker> (Given that there are no syntax macros in Haskell)
01:28:54 <Cale> Jaak: there are a few reasons. One is that f $ g $ h $ x can already be written as f . g . h $ x, but there's no way to remove parens from something like f (g x) (h y) (k z)
01:28:57 <lament> eventually some new language will appear that will just be really, really awesome and absolutely amazigly cool. Then people will switch to it :)
01:29:28 <Peaker> If the only difference to a new language is only _syntax_ then people the new langauge will just be two-sided convertor scripts?
01:29:31 <lament> (i mean the functional language and the functional community)
01:29:47 <Jaak> hmm, interesting
01:29:53 <Cale> Jaak: Another is that with $! a very common thing to want to do is to apply a function to a parameter other than the first strictly, and this currently involves awkward parens
01:29:57 <Peaker> I mean, syntax is just a presentational issue
01:30:02 <lament> Peaker: most changes will probably concern the typing system and the builtins
01:30:07 <solrize> haskell had the motto "avoid success at all costs" (to preserve the availability to break things) but it seems to be going after more stability now.  and i think it's not so much of a research testbed any more either; although it inspires a lot of dialects/variants (ddc, agda, etc.)
01:30:08 <Jaak> yeah, i get the $! issue
01:30:10 <lament> not just syntax
01:30:25 <inimino> Cale: isn't it better to save it for Haskell 2 and let the compilers add a mode then?
01:30:34 <Peaker> lament, well, those are easier to make backwards compatible, with new syntax :-)
01:30:43 <lament> solrize: it's not? :(
01:30:47 <Jaak> haskell 2? there is already haskell 98 :P
01:31:08 <Cale> Jaak: Another is that it's just better style to write  f . g . h $ x  than  f $ g $ h $ x, because the former effectively has more subexpressions, making it easier to think about and work with.
01:31:18 <Cale> g . h is a well-typed thing there
01:31:22 <lament> Peaker: type system stuff can be hard or impossible to "port over"
01:31:24 <Cale> Whereas g $ h is meaningless.
01:31:41 <inimino> "has more subexpressions"?
01:31:46 <Cale> inimino: yeah
01:31:55 <Cale> Since (.) is an associative operator
01:32:07 <quicksilver> more of its substrings are valid subexpressions
01:32:11 <quicksilver> is another way of saing it
01:32:13 <Baughn> ((f . g . h) x) instead of (f (g (h x)))?
01:32:17 <quicksilver> associative operators are great
01:32:22 <inimino> quicksilver: oh, right
01:32:28 <Cale> Baughn: yeah
01:32:34 <Baughn> I can see it being cleaner, but not really due to having /more expressions/
01:32:37 <quicksilver> f . g and g . h are both well typed and sensible sub expressions.
01:32:44 <quicksilver> Baughn: it helps a lot when refactoring code
01:32:53 <lament> also, f . g . h $ x simply looks much nicer and more neat :)
01:32:55 <Baughn> quicksilver: Noted. Annoyingly, I've always used the latter.
01:32:57 <Cale> Baughn: well, suppose you want to take g . h and apply some transformation, like factor it out into a new definition
01:33:00 <quicksilver> that you can rename f . g or g . h, or split g into m . n
01:33:02 <Baughn> quicksilver: No more - the former is obviously better. ;)
01:33:03 <quicksilver> etc.
01:33:09 <solrize> this precedence of $ stuff seems pretty trivial.  i'd rather see them make bytestrings a primitive part of the language
01:33:24 <Jaak> nonono
01:33:25 <solrize> and support unicode more thoroughly
01:33:26 <solrize> etc
01:33:29 <Baughn> Cale: More potential subexpressions, perhaps?
01:33:33 <lament> yes please!
01:33:34 <Cale> Baughn: yeah, I suppose
01:33:43 <Cale> Baughn: More virtual subexpressions :)
01:33:49 <lament> strings are rilly important
01:33:59 <Baughn> Cale: I despise that word. "Potential" is more descriptive.
01:34:10 <lament> they should be significantly optimized transparently to the programmer
01:34:27 <Cale> Baughn: okay :)
01:34:39 <Baughn> For that matter, is there some good reason bytestrings aren't a kind of IArray?
01:34:42 <Jaak> it would be nice is IsString was in standard, tho'
01:34:58 <Jaak> makeing bytestring part of the language sounds really bad
01:35:08 <Cale> IsString is the most easily abused Haskell extension ever.
01:35:09 <Jaak> making*
01:35:23 <Jaak> probably...
01:35:32 <quicksilver> making bytestring primitive sounds like an abstraction failure
01:35:38 <Baughn> Should we remove useful functions just because they could be abused?
01:35:43 <quicksilver> bytestring should be a library which is implementable with primitives which are available
01:35:51 <solrize> well the idea is to unify all these different types of strings that exist now
01:35:55 <Cale> Baughn: no, not necessarily -- I actually think it's a good idea still :)
01:35:58 <inimino> Baughn: ask the Python people ;-)
01:36:04 <quicksilver> solrize: yes, but it's not a language issue, it's a library issue.
01:36:12 <Baughn> inimino: There's a reason I'm here and not in #python. ;)
01:36:15 <quicksilver> (of course ($) is a library issue too)
01:36:16 <inimino> hehe
01:36:25 <quicksilver> but ($) is in the prelude so it's a bit deeper
01:36:26 <Cale> But yeah, at least with linear implicit parameters, you had to think a bit to really abuse them.
01:37:22 <solrize> supposedly ML-like languages with default strict evaluation have a blemish, that there ends up being strict and lazy versions of all kinds of functions and data
01:37:27 <solrize> but that's exactly what we have with bytestrings
01:37:41 <Cale> solrize: That's what we *should* have.
01:37:48 <lament> wwhy?
01:37:51 <solrize> and also we have monadic and non-monadic versions of quite a few combinators, as the ddc page points out
01:38:01 <quicksilver> solrize: doesn't sound like a bad thing to me. ByteStrings are a different data structure to Lists
01:38:07 <quicksilver> I'm not surprised there are different functions
01:38:08 <Cale> The difference between lazy and strict is important, and we should have the choice. :)
01:38:13 <quicksilver> there are different algorithms and so on
01:38:28 <quicksilver> List Map and Set all have different functions too :)
01:38:38 <solrize> once we have strict and lazy versions of stuff, then we have to ask ourselves why lazy is the default
01:38:52 <Cale> Now it might be nice in some cases where possible to make better use of Control.Parallel.Strategies
01:39:02 <Baughn> I'm not sure why we need an explicit, separate strict bytestring library. COuldn't rwhnf automatically convert to a strict representation?
01:39:05 <jorick> it's confusing though, when i came asking here for a strict readFile i almost ended up using ByteString (before someone explained the (length s)`seg` trick)
01:39:10 <Cale> So you'd pass in a strategy to the higher order function along with the rest.
01:39:26 <Cale> jorick: You probably should just use ByteString
01:39:32 <quicksilver> jorick: that's a specific stupid design decision in the prelude
01:39:36 <quicksilver> jorick: readFile is broken.
01:39:45 <Cale> quicksilver *really* hates lazy IO
01:39:50 <quicksilver> indeed
01:40:01 <quicksilver> because it gives a bad impresion of the language to people like jorick
01:40:03 <Cale> I think it's essential for supporting the smaller end of the program space.
01:40:08 <quicksilver> who want to do something simple and it doesn't work.
01:40:09 <jorick> this is even more confusing ... why should i rewrite my code to use ByteStrings?
01:40:23 <quicksilver> Cale: in this instance I'm not objecting to a lazy readFile existing
01:40:26 <Cale> jorick: Well, you'll get much better performance
01:40:34 <Cale> (If that matters)
01:40:34 <quicksilver> Cale: I'm objecting to it being default, broken, and undocumented
01:40:44 <quicksilver> Cale: he didn't get better performance
01:40:47 <Cale> quicksilver: Broken?
01:40:49 <quicksilver> Cale: his program didn't work.
01:40:54 <quicksilver> he got a broken program
01:40:58 <quicksilver> because readFile was broken.
01:41:05 <quicksilver> yes, broken.
01:41:08 <Cale> quicksilver: Uh, he rewrote his program in terms of ByteStrings?
01:41:11 <solrize> i notice that clean beats haskell on a bunch of benchmarks dealing with small strings, possibly because it has a primitive string type isntead of char lists
01:41:13 <inimino> how is readFile broken?
01:41:16 <quicksilver> he wrote a naive program using readFile
01:41:22 <quicksilver> which was "obviously" correct
01:41:30 <Cale> quicksilver: What did he write?
01:41:32 <quicksilver> but failed because of readFile's subtle and poor explained semantics.
01:41:45 <jorick> what happened was that i was using readFile, expecting it to close the handle. it didn't do this when i expected this to happen. after using the `seq` trick it worked
01:41:47 <quicksilver> foo <- readFile "foo; writeFile "foo" bar
01:41:49 <Cale> Maybe the main problem with readFile is that people suck at explaining it?
01:41:49 <quicksilver> roughly
01:41:53 <pjd_> readFail
01:42:04 <jorick> quicksilver, that's what my testcase became after a while :D
01:42:33 <Cale> quicksilver: I don't understand what you mean by that it's broken though. It does exactly what the documentation says it does.
01:42:40 <jorick> Cale, i wouldn't say 'the people', i would say the library documentation.
01:43:08 <Cale> The readFile function reads a file and returns the contents of the file as a string. The file is read lazily, on demand, as with getContents.
01:43:14 <quicksilver> Cale: The documentation doesn't make it clear that you won't be able to writeFile immediately afterwards.
01:43:32 <Cale> If you haven't demanded the contents of the file, then it won't have been read.
01:43:39 <quicksilver> look I know how it works
01:43:43 <quicksilver> you don't need to explain it to me!
01:43:44 <quicksilver> ;)
01:43:44 <jorick> IMO this is not about broken or whatnot, i don't really have the technical knowledge to decide which one would be better (lazy, strict)
01:43:56 <inimino> maybe it just needs a new name
01:43:58 <quicksilver> I'm just saying that it violates least surprise for newbies
01:44:01 <Cale> quicksilver: The behaviour follows from what the documentation says.
01:44:02 <inimino> streamFile
01:44:06 <quicksilver> and the alternative isn't given either.
01:44:12 <Cale> quicksilver: Okay, I wouldn't call that broken.
01:44:15 <jorick> as a noobie however, i have perfect insight into the things that confuse people (coming from a scheme/python/java/php/etc... background)
01:44:19 <Baughn> mmapFile?
01:44:37 <Baughn> This is almost /exactly/ the behaviour you'd expect from mmap
01:44:38 <Cale> jorick: Yes, there should be a strict readFile, and perhaps it should even be the default.
01:44:43 <quicksilver> if a function doesn't work as people expect after reading the documentaion, then one of three things is broken
01:44:44 <inimino> streaming is expected behaviour on Unix
01:44:49 <quicksilver> the function, the documentation, or the people.
01:45:01 <quicksilver> this has bitten enough people that I don't blame the people :)
01:45:10 <quicksilver> if strict readfile even existed that would be 100 times better
01:45:12 <Cale> But the lazy one is important for making the best use of lazy functional programming in many cases.
01:45:20 <inimino> the laziness seems like a feature in a lot of cases
01:45:22 <quicksilver> instead of #haskell having to show people how to write it every time this comes up
01:45:31 <quicksilver> inimino: it is, yes.
01:45:42 <solrize> but the lazy one breaks its abstraction in that do { h <- readFile foo; ...} doesn't REALLY make h referentially transparent
01:45:57 <quicksilver> but it's prioritising performance over referential transparency
01:45:58 <solrize> since someone could rewrite the file before h has forced all the contents
01:46:02 <inimino> so yeah, there should be two versions and they should be adjacent in the documentation
01:46:03 <quicksilver> which is a surprising choice
01:46:06 <Cale> quicksilver: Simon Marlow even wrote a really good one which read the file strictly into a buffer and lazily converted it into a list, somehow it didn't end up in the libraries.
01:46:13 <quicksilver> Cale: *nod*
01:46:14 <glguy> the 98 IO module doesn't seem targeted at programming beyond small examples (that's not to say that people haven't found ways to trick it to be)
01:46:20 <Cale> quicksilver: He wrote it in a reply to me on the mailing list.
01:46:25 <quicksilver> Cale: I believe I remember.
01:46:37 <solrize> really the only solution is for readFile to actually lock the file
01:46:44 <solrize> in OS's where that's possible
01:46:58 <quicksilver> I think it does, actually.
01:47:17 <Cale> Yeah, writeFile should probably throw a useful exception when applied to a file which a readFile is in the middle of reading.
01:47:31 <inimino> seems like Unix and Win32 people have different expectations about what readFile "should" do
01:48:01 <quicksilver> inimino: it's not really that, to be honest.
01:48:05 <quicksilver> at least, I don't think it is.
01:48:08 <jorick> the bahviour now actually doesn't bother me too much ... using the `seq` trick if you need a strict readfile. but this trick should be in the documentation. along with 1000 other examples. i would love it if haskell documentation looked (a *little* bit) more like the one from PHP
01:48:13 <inimino> Cale: that doesn't really help much
01:48:28 <quicksilver> I think haskell is broken if you need to use `seq` to correctly use a simple basic IO function.
01:48:48 <inimino> Cale: (in cases where something else is writing the file)
01:48:50 <solrize> you can `seq` after readfile and it actually reads the whole file?
01:48:59 <quicksilver> yes
01:49:01 <Cale> quicksilver: Well, the real answer is that this isn't the IO function you really want :)
01:49:02 <quicksilver> with some care
01:49:05 <quicksilver> Cale: yes, of course.
01:49:08 <solrize> that's scary
01:49:12 <Cale> quicksilver: and that the one you really want isn't available for String
01:49:17 <quicksilver> Cale: and that's my point about it being broken, or the documentation
01:49:18 <jorick> s <- readFile foo; length s `seq` return s
01:49:27 <quicksilver> Cale: either the documentation should tell you this isn't the function you want.
01:49:32 <mux_> I'd use evaluate if already in the IO mona
01:49:33 <quicksilver> or it should be :)
01:49:42 <quicksilver> and preferably the function you want should exist, too.
01:50:25 <Cale> Lazy IO is actually really awesome, but we need to be careful about warning people about the downsides as well :)
01:50:28 <inimino> so it's a documentation problem and a missing strict version of readFile
01:50:35 <Cale> inimino: yeah
01:50:46 <quicksilver> inimino: yes, absolutely.
01:50:51 <jorick> inimino, seconded
01:51:15 <solrize> i'm cringing at the idea of some strict annotation suddenly hosing my machine as a 100 GB file gets read into 2 GB of ram...
01:51:19 <Cale> The documentation for readFile is correct, but people who don't already know how lazy IO works probably aren't going to infer everything they need to infer from it, even though it's possible to do so.
01:51:32 <mux_> why don't we have readFile' in base yet?
01:51:32 <quicksilver> inimino: I've previously said that getContents should be renamed unsafeOnlyCallThisIfYouHaveAPhdAndUnderstandGraphReductionAndInterleavingGetContents
01:51:47 <Cale> quicksilver: That's silly.
01:51:55 <quicksilver> inimino: I would, however, settle for it being renamed to lazyGetContents :)
01:51:57 <Cale> getContents works very very well for its task.
01:51:57 <Baughn> quicksilver: unsafeGetContents would suffice
01:51:59 <inimino> quicksilver: hGetContents already has some strong language in the docs though
01:52:03 <quicksilver> Cale: yes, of course it's silly :)
01:52:05 <quicksilver> I am silly.
01:52:14 <Zao> inimino: People read docs?
01:52:21 <quicksilver> sometimes being silly is the only way I can make a point coherently :)
01:52:27 * Baughn has repeatedly hosed ghci by calling getContents, but that's another story
01:52:27 <Cale> And there's no way to screw up using getContents, at least as far as I know.
01:52:39 <inimino> Zao: how else do they write correct code...?
01:52:43 <Cale> Can you even open your own stdin for writing?
01:52:55 <Baughn> Nope
01:52:57 <quicksilver> Cale: you can be upset by asynchronous exceptions.
01:53:07 <Zao> inimino: Programming by coincidence?
01:53:07 <inimino> Zao: I guess I assume people who don't read docs are a lost cause regardless
01:53:12 <quicksilver> which are a bit more subtle than the gotcha we have been discussing
01:53:20 <quicksilver> but still odd if you get them when not expecting it
01:53:37 <inimino> Zao: programming by random permutation?
01:53:50 <Vq^> Zao: putting a cat on the keyboard?
01:53:56 <quicksilver> mux_: I object to readFile' as a naming convention for this problem, actually.
01:54:20 <quicksilver> mux_: foldl and foldl' are both referentially transparent and equivalent except for a kind of 'safe strictness'
01:54:23 <inimino> readFile' actually feels wrong
01:54:29 <quicksilver> mux_: here we have a kind of 'unsafe lazyness'
01:54:35 <quicksilver> it deserves a strong signal than a '
01:54:44 <quicksilver> I would favour readFile (being strict) and lazyReadFile
01:55:03 <inimino> quicksilver: bringing referential transparency into it is a red herring
01:55:07 <mux_> that would be fine
01:55:08 <quicksilver> inimino: it's not.
01:55:20 <inimino> it's just that people misunderstand the returned type
01:55:40 <glguy> if you are concerned about when specifically the file is closed
01:55:57 <glguy> you should be using openFile and hClose
01:56:41 <glguy> if you are making a toy that doesn't reuse a file
01:56:45 <glguy> use readFile
01:56:46 <glguy> solved
01:57:00 <inimino> (it's not as if even a strict readFile would be atomic wrt other processes)
01:57:16 <quicksilver> inimino: I disagree.
01:57:22 <quicksilver> inimino: readFile uses unsafeInterleaveIO
01:57:30 <qwr> err, there is strict readFile in library
01:57:32 <quicksilver> this is a kind of referential transparency issue.
01:57:43 <jorick> qwr: there is?
01:57:46 <qwr> in Bytestring.something
01:57:50 <quicksilver> inimino: it's a subtle one.
01:57:56 <jorick> ah yes, but it's a diffrent one
01:57:59 <quicksilver> qwr: yes but not a String one.
01:58:23 <quicksilver> @go perils of getContents
01:58:24 <lambdabot> No Result Found.
01:58:29 <quicksilver> eh?
01:58:33 <quicksilver> http://www.haskell.org/pipermail/haskell-cafe/2007-March/023073.html
01:58:36 <lambdabot> Title: [Haskell-cafe] Takusen and strictness, and perils of getContents, http://tinyurl.com/yp35rl
01:58:40 <glguy> no perils to be found !
01:58:44 <quicksilver> inimino: oleg explains it better than I do.
01:58:52 <quicksilver> he is less inclined to hyperbole and silliness :)
01:58:59 <inimino> heh
01:59:21 <qwr> quicksilver: yes. but you might be right, that it would be good to have a non-lazy readFile::String too (and maybe it should be default...)
01:59:36 <Armored_Azrae1> Hey, I'm having a hard time getting a buffer back from a C program after it's been modified. Ideas?
02:00:00 <inimino> well, it's a bit of a philosophical issue I suppose
02:00:22 * qwr has been bitten too by the readFile x >>= writeFile x . foo 
02:02:16 <qwr> one the other hand, this kind of forces you to think about lazyness ;)
02:02:41 <inimino> qwr: not much different from POSIX $ sed s/from/to <foo >foo
02:02:45 <Armored_Azrae1> Right now I'm trying
02:02:45 <Armored_Azrae1> fread fd n = let read2 s = do err <- wRead fd s n
02:02:45 <Armored_Azrae1>                               sFin <- peekCString s
02:02:45 <Armored_Azrae1>                               return (sFin, toErr err)
02:02:45 <Armored_Azrae1>              in allocaBytes n read2
02:02:45 <Armored_Azrae1> where wRead is a function exposed in C, where the variable s is a buffer to be modified. Anyone see something wrong?
02:02:55 <qwr> inimino: yes
02:03:09 <inimino> qwr: though that bites newbies just as hard
02:03:17 <solrize> oleg gets right to the point of why readFile is inherently impure
02:03:43 <quicksilver> qwr: but what upsets me is that people believe this is laziness
02:03:46 <quicksilver> qwr: it isn't!
02:03:53 <quicksilver> qwr: it's something different and much more scary.
02:04:04 <quicksilver> qwr: laziness is inherently safe and referentially transparent.
02:04:06 <herman> What is a "monad"?
02:04:08 <inimino> solrize: operating environments are inherently impure, you can regard this as nothing different that ENOMEM
02:04:21 <quicksilver> (which is why I prefer 'unsafeReadFile' to 'lazyReadFile')
02:04:40 <qwr> layness is part of it ;)
02:05:03 <Baughn> herman: Just about whatever you want them to be. A set of types with a few common operators and a syntax that happens to be handy, plus some functions built on it..
02:05:06 <jorick> i prefer unsafe, for the strict version ... open a 200GB file, which one is safe?
02:05:44 <qwr> quicksilver: used for streaming from a reader thread (or so i understand it)
02:05:53 <quicksilver> qwr: I appreciate that you understand it.
02:06:01 <quicksilver> qwr: but my point is we are overloading the term 'lazyness'
02:06:10 <Baughn> herman: It'll probably make sense to learn how to use /particular/ monads first, befre tackling the general issue very much
02:06:12 <quicksilver> lazy or non-strict evaluation is semantic preserving
02:06:16 <quicksilver> its a safe transformation
02:06:16 <herman> like "programmers are lazy"?
02:06:23 * earthy agrees with herman
02:06:30 <earthy> 'so what if we're overloading lazyness?'
02:06:36 <quicksilver> there are no issues with lazy evaluation like those described by oleg
02:06:44 <quicksilver> this unsafeInterleaveIO has more serious issues
02:06:53 <quicksilver> earthy: because it can confuse the debate, that's all
02:07:04 <earthy> but indeed, interleaved exectuion of IO is not inherently lazy
02:07:05 <quicksilver> someone might say "I don't like using haskell because the lazyness catches you out"
02:07:19 <quicksilver> when they are really talking about this unsafeInterleave based construct
02:07:21 <earthy> heck, that even happens to professors
02:07:30 <quicksilver> which is a different thing
02:07:34 <qwr> writing stupid code catches you out ;)
02:07:39 <quicksilver> and not in itself expressible in haskell.
02:07:56 <quicksilver> (althought the prelude includes some functions which can only be implemented using it, it contains no primitives to build such)
02:07:58 <earthy> (really: prof. Swierstra once made slides explaining how a haskell program would be evaluated... only to later find out that he hadn't been lazy enough)
02:07:59 <solrize> e.g. the singularity research OS uses no hardware memory protection between potentially hostile processes. it instead relies on compiler type systems for interprocess security.  so there can be no unsafecoerce or anything like that, at all.  (also no ffi)
02:09:22 <earthy> solrize: there is (typed) IPC in singularity, right?
02:09:37 <solrize> yeah, i haven't studied it just read an overview
02:10:02 <glguy> ?oeis 3 24 528 31968
02:10:03 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
02:10:09 <earthy> basically, the IO monad can be seen as a 'seperate' program that you construct
02:10:22 <earthy> that is then evaluated to result in the sideeffects
02:10:41 <earthy> however, this clean and pure formulation can be subverted using IO interleaving
02:11:42 <inimino> earthy: but the system could e.g. run out of memory at any time
02:11:47 <earthy> which is all fine and dandy, but I agree with quicksilver in that people should be aware of it and should be aware that it is an issue distinct from non-strictness
02:12:22 <earthy> inimino: it is also practical to do the interleaving, no doubts there
02:12:30 <glguy> > 31968 / 528
02:12:33 <lambdabot>  60.54545454545455
02:12:36 <solrize> so i have a file with a bunch of records in it that i need to access randomly.  i have a table of where each record starts, and the table is small enough to fit in memory, so i was thinking of having an io action that would seek to the right place in the file and get the corresponding record as a lazy bytestring.  but i suddenly realize that having multiple lazy bytestrings with dangling io, while the underlying file pointer is moving around, is
02:12:36 <solrize> just totally out.
02:12:59 <solrize> and this is something i would have expected the type system to protect me from
02:13:04 <earthy> why not mmap the file? is it too big?
02:13:13 <earthy> ah, no.
02:13:18 <glguy> the type system will never protect you from opening a file twice
02:13:21 <inimino> earthy: I think the ghetto-izing of IO always leaves out important details of how a program is executed, so people should not be too surprised
02:13:25 <solrize> for this file i can mmap, it's not that big, but there's a 2 gig limit on 32 bit linux
02:13:32 <solrize> or 4 gig maybe
02:13:48 <earthy> glguy: not in haskell, at least. ;)
02:14:20 <herman> what language's type system does that?
02:14:32 <solrize> in this instance i'm not opening the file twice, it's just that its contents appear to have been lifted into purity when they really haven't been
02:14:49 <solrize> it's ok, the records are small so i can access them with strict operations i guess
02:14:58 <solrize> or use mmap if i can figure out how
02:15:22 <solrize> there seems to be no mmap in the ghc lib, just something in hackage
02:15:50 <dmwit> I wouldn't be surprised if it was in the unix package or something like that.
02:16:55 <solrize> aha
02:17:08 <solrize> hmm there's an shm wrapper
02:17:54 <solrize> i don't see any obvious place where mmap would be
02:20:30 <solrize> IntMap is really nice.  it seems to merge ranges of adjacent keys?
02:22:48 <earthy> it 'merges' prefixes
02:22:53 <earthy> see http://en.wikipedia.org/wiki/Radix_tree
02:22:58 <solrize> nice
02:23:20 <solrize> yeah i notice that it uses less memory than the keys+values stored in it
02:23:39 <solrize> and figure that can only be because the keys are fairly dense
02:24:26 <solrize> any idea how hard it would be to compile it to use int64's?
02:27:36 <Arnar_> @src zipWith
02:27:36 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
02:27:36 <lambdabot> zipWith _ _      _      = []
02:27:41 <Jaak> anyone here who knows something about lucid synchrone?
02:28:11 <earthy> isn't that some finite automata tool?
02:28:31 <dmwit> Not from the first Google hit.
02:28:38 <Jaak> it has one, yes
02:29:57 <Jaak> its semantics are fucked up or i have found a bug
02:30:03 <Arnar_> Jaak: I don't know lucid synchrone.. but I know a little about rs and ccs
02:30:26 <solrize> does anyone here use ML?  lazy/strict contrasts aside, does it lead to a completely different style than haskell because it doesn't have type classes?
02:31:11 <Jaak> well, i have expression "rec o = 1 fby (o + (0 fby o))" that evaluates to 0 1 2 4 8 16 ... and i don't understand how
02:32:57 <Jaak> it should give me fibonacci numbers :\
02:33:13 <earthy> > let o = (1 : (zipWith (+) o (0:o))) in take 10 o
02:33:14 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
02:33:17 <Arnar_> hmm
02:34:06 <Arnar_> fby is cons.. right?
02:34:13 <Jaak> yes
02:34:28 <EvilTerran> ... and + here is zipWith (+)?
02:34:38 <dmwit> > fix \o -> 1 : (zipWith (+) o (0 : o))
02:34:39 <lambdabot>  Parse error at "\o" (column 5)
02:34:46 <dmwit> > fix (\o -> 1 : (zipWith (+) o (0 : o)))
02:34:48 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
02:34:49 <EvilTerran> > let o = 1 : zipWith (+) o (0 : o)
02:34:49 <lambdabot>  Parse error at end of input
02:34:52 <EvilTerran> > let o = 1 : zipWith (+) o (0 : o) in o
02:34:53 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
02:34:54 <dmwit> huh
02:35:34 <EvilTerran> well, it works here
02:35:38 <earthy> there is something fishy in that code giving that result, Jaak. :)
02:35:42 <EvilTerran> do they have their own IRC channel you could ask in?
02:36:03 <Jaak> not that i'm aware of
02:36:21 <vincenz> solrize: yes
02:36:29 <vincenz> solrize: it's more painful is what I can tell you
02:36:58 <solrize> vincenz, yeah, that makes sense
02:37:04 <Jaak> earthy: fishy? :)
02:37:13 <vincenz> solrize: it's not necesssarily 'different'
02:37:19 <vincenz> solrize: just that yo have to work with modules and functors
02:37:25 <vincenz> solrize: so you do a lot more . notation
02:37:56 <vincenz> + the whole .ml vs .mli always pissed me off
02:37:58 <earthy> Jaak: it doesn't result in the expected stream
02:38:14 <Jaak> oh, sorry, not "0 1 2 4 8 16..." but "1 1 2 4 8 16..." that's not what is expect either :P
02:38:22 <earthy> so, either the result is right and the semantics are surprising
02:38:30 <Jaak> yeah
02:38:34 <earthy> or the result is wrong
02:38:46 <Jaak> that's unlikely, but hell knows
02:38:46 <Arnar_> Jaak: if it is always adding the last no. to 0 rather than the second last number..
02:38:52 <Arnar_> you get 1 1 2 4 8 16 ...
02:39:02 <vincenz> 1 1 2 4 8 16 can make sense
02:39:15 <vincenz> it's' round(2^n) starting at n = -1
02:39:17 <Arnar_> n+1 = 2*n
02:39:20 <solrize> vincenz i had thought of functors as being much more heavyweight than type classes but i know close to zilch about ml.  it just seemed syntactically uglier than haskell and the implementations were less ambitious than ghc, so i decided to try out haskell instead
02:39:32 <vincenz> solrize: syntactically they can be
02:39:40 <vincenz> solrize: you have shortcuts (some what akin to typedefs)
02:39:53 <vincenz> both for modules as well as types
02:40:03 <vincenz> but yeah, it's not fun :)
02:40:22 <vincenz> solrize: and I -really- missed 'deriving' though I think Ocaml has a Camlp4 plugin somewhere for that
02:40:39 <Arnar_> Jaak: looks like its doing a[n+1] = a[n] + a[n] rather than a[n] + a[n-1]   ..  which, yes.. I wouldn't expect from the expression
02:40:47 <solrize> oh right, it has sort of a macro system
02:40:58 <vincenz> solrize: well ocaml does, not sure about SML
02:41:21 <solrize> i've been using data.binary and i'm really impressed with the way the serializer automatically knows what to do just from the class instance
02:41:26 <Jaak> Arnar_: ah, thanks. it does seem so
02:41:30 <cjs__> quicksilver: So, I'm back to strict ByteString reads from handles.
02:41:36 <Jaak> i'll dig around in the manual some more
02:42:06 <cjs__> An ostensible bug in Data.Binary's getLazyByteString did me in at last.
02:42:30 <solrize> what was that?
02:43:09 <cjs__> The data were getting pushed over the network, and I wasn't reading more than had been received, but while getByteString returned the data I'd asked for, getLazyByteString blocked.
02:43:26 <cjs__> I have a test case and framework in which to try it out, if anybody wants to play with it.
02:43:32 <solrize> oh i remember that
02:43:35 <solrize> hmm
02:45:52 <solrize> i think i'm starting to understand what data.generics does (data.binary has a bunch of canned serializers generated by a generics-using script) and it's cool the way the stuff all fits together
02:57:44 <kamaji> how do I return nothing from a function?
02:58:00 <solrize> er, you can't, every function returns a value
02:58:12 <solrize> but you could return something like ()
02:58:16 <cjs__> You can't. Typically, when you want to do that, you return unit instead: f :: Int -> ()
02:58:25 <kamaji> hmm ok
02:58:37 <cjs__> But if you want to do that, you're likely doing something a bit weird....
02:58:57 <quicksilver> kamaji: if a function returns nothing, it hasn't done anything.
02:59:02 <quicksilver> kamaji: so, what's the point of calling it? :)
02:59:23 <dmwit> Now, returning a monadic action containing nothing... that can *do* something!
02:59:42 <cjs__> But then you're not returning nothing, you're returning an action.
02:59:51 <quicksilver> cjs__: my gut feeling is taht if you're doing network IO you want to handle your own reads, anyway. So I think you're probably doing it right.
03:00:09 <quicksilver> cjs__: you want to handle exceptions in a timely way and probably control your bufferring strategy too.
03:01:33 <cjs__> Yeah. Well, what really pushed me this way was that, while in some instances I'm parsing messages and so on, there are some applications, such as the market data recorder and player, where I really don't care about the contents, I just read and write chunks of bytes. So for that, might as well be fast and leave every message as a plain 'ol ByteString, with no further processing.
03:02:29 <solrize> :k State
03:02:30 <lambdabot> * -> * -> *
03:02:49 <solrize> :k State Int Int
03:02:50 <lambdabot> *
03:05:17 <SamB> woohoo. I caught two typos in two of Wadler's papers!
03:05:54 <cjs__> Uh oh. "Module imports form a cycle for modules:"
03:06:02 <SamB> and one of them was in an equation!
03:06:03 <cjs__> Is this just not possible, or is there a trick?
03:06:10 <SamB> cjs_: there is a trick
03:06:14 <dmwit> There is a trick.
03:06:19 <dmwit> Use .hs-boot files.
03:06:30 <SamB> @go "SOURCE" pragma ghc manual
03:06:31 <lambdabot> No Result Found.
03:06:34 <cjs__> Ummm.
03:06:38 <SamB> @go SOURCE pragma ghc
03:06:39 <lambdabot> No Result Found.
03:06:45 <SamB> huh
03:06:48 <quicksilver> however, some people think cycle module dependencies are a sign of a bad factoring.
03:06:59 <cjs__> Ok. Maybe I want to look at fixing my code, first. I kinda ended up here during the course of a refactoring that will make it all go away, anyway.
03:07:09 <quicksilver> at the very least I'd stare at the code a bit
03:07:09 * quicksilver nods
03:07:17 <mauke> cjs__: http://haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
03:07:22 <quicksilver> I would treat a cyclic module dependency as at least a "warning"
03:07:23 <lambdabot> http://tinyurl.com/2y3hr6
03:07:28 <SamB> yes, it is a warning
03:08:06 <SamB> but sometimes it is a heck of a lot better to just accept the cyclic dependancy, inserting the loop breaker where it will do the least damage
03:08:35 <mauke> preflex uses one .hs-boot file
03:09:00 <mauke> there's a module exporting a list of all active plugins but the Help plugin needs access to that list
03:10:28 <paolino> you can put the Help plugin there , but that is not very nice
03:11:55 <SamB> paolino: can you?
03:13:25 <paolino> write the Help plugin in the exporting module, I think so
03:13:28 <jorick> who's Sam Danielson?
03:13:49 <paolino> mhh, maybe not eh
03:16:02 <cjs__> How do I express a string that's a "\x02" followed by a "0"?
03:16:57 <dmwit> > "\x02\?0"
03:16:57 <lambdabot>  Illegal escape sequence at ""\x02..." (column 1)
03:17:06 <dmwit> > "\02\?0"
03:17:07 <lambdabot>  Illegal escape sequence at ""\02\..." (column 1)
03:17:07 <mauke> > "\x02\\0"
03:17:08 <lambdabot>  "\STX\\0"
03:17:16 <dmwit> > "\x02?0"
03:17:17 <lambdabot>  "\STX?0"
03:17:21 <mauke> > "\x02\ \0"
03:17:22 <lambdabot>  "\STX0"
03:17:39 <mauke> "\STX0"
03:18:09 <dmwit> There really is a right way, though.
03:18:16 <dmwit> (I can't remember it, but I know there is one.)
03:18:39 <mauke> my way!
03:18:56 <cjs__> How did it work for you? That doesn't work for me in ghci.
03:19:13 <mauke> which one?
03:19:16 <cjs__> "\x02\\0" gives me "\STX\\0"
03:19:21 <cjs__> 6.8.2.
03:19:26 <mauke> yes, you need "\x02\ \0"
03:19:40 <dmwit> Ah, here it is!
03:19:40 <cjs__> Oh, is there a space in there?
03:19:46 <dmwit> > "\x02\&0"
03:19:47 <lambdabot>  "\STX0"
03:19:50 <dmwit> Got it!
03:19:50 <mauke> what kind of font are you using?
03:19:54 <cjs__> Ah, that's it.
03:20:05 <mauke> > "\&\&\&"
03:20:06 <lambdabot>  ""
03:20:06 <cjs__> I'm using a proportional one to save screen space.
03:20:19 <dmwit> \& is specifically for breaking escapes. =)
03:20:23 <mauke> nice
03:20:28 <cjs__> That's what I was trying to remember.
03:20:31 <quicksilver> \& is the 'official' feature to make this happen
03:20:35 <mauke> \ ... \ is a string gap
03:20:37 <quicksilver> string gaps is a neat trick which works :)
03:20:47 <dmwit> Wait, what's that?
03:20:56 <quicksilver> The escape character \& is provided as a "null character" to allow strings such as "\137\&9" and "\SO\&H" to be constructed (both of length two)
03:21:15 <quicksilver> (quoth the report)
03:21:15 <dmwit> What are string gaps?
03:21:22 <mauke> > "\x02" ++ "0"
03:21:22 <lambdabot>  "\STX0"
03:21:24 <quicksilver> > "this\   \is a string gap"
03:21:25 <SamB> > "Hello\ this is an intron \ World!"
03:21:25 <lambdabot>  Illegal character in string gap at ""Hell..." (column 1)
03:21:25 <lambdabot>  "thisis a string gap"
03:21:37 <SamB> hmm.
03:21:42 <SamB> has to be all whitespace?
03:21:51 <quicksilver> they are a (in my opinion ugly) way to support multiline stings and suchlike.
03:21:51 <mauke> > "are \ {- comments -} \legal?"
03:21:51 <lambdabot>  Illegal character in string gap at ""are" (column 1)
03:21:59 <dmwit> ahhh
03:22:07 <dmwit> multiline
03:22:13 <SamB> > "Hel\    \lo"
03:22:13 <lambdabot>  "Hello"
03:22:25 <dmwit> > "Hel\
03:22:26 <lambdabot>  Illegal character in string gap at ""Hel\" (column 1)
03:22:31 <SamB> quicksilver: indeed, it is ugly
03:22:54 <dmwit> All this time, I've been doing
03:23:06 <dmwit> concat ["line 1", "line 2", etc.]
03:23:09 <SamB> but at least it allows the string to continue at the same column, unlike say Python's triple-quoted strings
03:23:24 <quicksilver> dmwit: I prefer that version personally
03:23:38 <SamB> dmwit: shouldn't that be unlines?
03:23:46 <dmwit> quicksilver: It's much less surprising for a reader not acquainted with string gaps. =)
03:24:00 <dmwit> SamB: It depends on what you want, I guess.
03:24:12 <quicksilver> dmwit: it's easier for syntax highlighters too although I concede that's a stupid reason.
03:24:22 <SamB> yes, string gaps are rather obscure
03:24:53 <SamB> I suppose most everyone either (a) forgets they exist or (b) thinks they are ugly. Well, most likely (b) => (a)...
03:25:02 <quicksilver> I use concat or unlines
03:25:09 <quicksilver> and of course if it gets big, I put it in a file!
03:25:13 <dmwit> =)
03:25:59 <SamB> JHC employs that approach, and then uses a perl script to generate a Haskell module which exports the contents of all those files as strings ;-)
03:26:40 <quicksilver> ;)
03:26:50 <SamB> though admittedly the natural form for the data to take is as files, in this case
03:27:08 <quicksilver> you can also use TH and something along the lines of $(readFile)
03:27:41 <SamB> but the dependancy handling wouldn't work too well then
03:28:08 <jorick> you could also support "multiline strings reading from the same column" by stripping spaces from the trailing lines ( illustrated here http://hpaste.org/7127 )
03:28:27 <dmwit> Incidentally, the way I remembered what the empty escape sequence was:
03:28:31 <dmwit> ?quote faxathisia
03:28:31 <lambdabot> faxathisia says: oh god I'm having DeBruijn encoded dreams
03:28:33 <SamB> jorick: yes, that is possible, but it's rather ugly
03:28:39 <dmwit> ?quote faxathisia su
03:28:40 <lambdabot> faxathisia says: /msg lambdabot > fun (cycle "\3\&5de\3\&3su ") :: Expr
03:28:45 <quicksilver> jorick: you haskell could count strings as a layout block?
03:28:53 <quicksilver> yes, that's been sugested befotre
03:29:22 <quicksilver> ISTR there was a strong counter-argument but I don't remember what it was.
03:29:31 <SamB> jorick: unless, of course, you meant that the haskell parser should do it
03:30:05 <jorick> SamB: the way i see it the parser should do it, along with all the other whitespace conversion stuff
03:30:15 <jorick> but there appears to be a challenger
03:30:16 <SamB> quicksilver: probably some silly argument about generated literals, or tabs, or japanese ;-)
03:30:33 <SamB> jorick: well, okay, that's a heck of a lot better than what they do in Python
03:30:37 <dmwit> Tabs are a lexical error!
03:30:38 <Armored_Azrae1> Anyone know how to access errno when binding to a C library?
03:30:41 * dmwit mumbles
03:30:49 <SamB> in Python, they leave that to pydoc
03:30:59 <SamB> or other docstring-using tools
03:31:02 <mauke> @hoogle errno
03:31:03 <lambdabot> Foreign.C.Error.Errno :: newtype Errno
03:31:03 <lambdabot> Foreign.C.Error.Errno :: CInt -> Errno
03:31:03 <lambdabot> Foreign.C.Error.errnoToIOError :: String -> Errno -> Maybe Handle -> Maybe String -> IOError
03:31:25 <Armored_Azrae1> Oh. Doy. Thanks.
03:31:29 <SamB> which consequently have to guess at the indentation level by looking at the second line
03:31:36 <quicksilver> don't think that's what you're after, Armored_Azrae1
03:31:39 <Armored_Azrae1> err, no
03:31:42 <Armored_Azrae1> you're ryight quicksilver
03:31:46 <Armored_Azrae1> that just processes information
03:31:47 <quicksilver> that doesn't give the actual value of it
03:31:49 <SamB> (and only docstrings get this treatment)
03:32:06 <Armored_Azrae1> The instance I'm in is that I call a function, and if it returns -1, errno is set
03:32:10 <SamB> which means you can't have docstrings which have the second line indented differently than the first
03:32:29 <mauke> throwErrnoIfMinus1
03:33:08 <Armored_Azrae1>   getErrno,             -- :: IO Errno
03:33:09 <Armored_Azrae1> got it
03:33:13 <kamaji> I have "someinteger > ((last list) * num)" in a guard, and i'm getting a "couldn't match expected type" error
03:33:38 <kamaji> about the second argument of >
03:33:45 <jorick> SamB, it seems like a worthwhile addition, although i admit it's purely aesthetical. maybe it could be an option feature
03:33:59 <dmwit> Possibilities: num isn't an Integer, list isn't an [Integer]
03:34:12 <SamB> jorick: I don't think that would work too well ;-)
03:34:32 <SamB> jorick: except if you used a new syntax for such strings
03:35:02 <dmwit> Why?
03:38:18 <jorick> oh ok
03:38:40 <paolino> and last isn't a [Integer] -> Integer ?
03:40:50 <dmwit> paolino: last is from Data.List, it's [a] -> a.
03:41:04 <dmwit> unsafePerformList :: [a] -> a -- ;-)
03:41:28 <dmwit> kamaji: Did you figure it out, or are you still having trouble?
03:41:58 <kamaji> I'd missed an argument in a previous function
03:42:04 <kamaji> sorry :|
03:42:08 <kamaji> silly mistake
03:42:16 <dmwit> OK, no problem. =)
03:50:06 <dobblego> will RWH have a chapter with HAppS?
03:52:53 <jacobian_wrk> I'm curious about E, the PTS style system used as a core for the JHC compiler
03:53:13 <jacobian_wrk> how does one know that reductions in the type system are terminating?
03:57:10 <Bonus> how is haskell with unicode?
03:57:31 <dmwit> Haskell was designed with Unicode in mind.
03:57:52 <Bonus> ah, cool
03:57:52 <dmwit> The Report says compilers should accept Unicode in source code (UTF-8 encoded).
03:57:59 <cjs__> However, in terms of encoding conversion....
03:58:02 <Bonus> what about in strings
03:58:11 <dmwit> > maxBound :: Char
03:58:13 <dmwit> ;-)
03:58:14 <lambdabot>  '\1114111'
03:58:20 <Bonus> aah
03:58:20 <Bonus> nice
03:58:20 <cjs__> A String is just a list of Chars. A Char is a unicode code point.
03:59:06 <cjs__> But if you do any serious string processing, you want to use ByteStrings, which consist of Word8s or Char8s, and for which there's little or no encoding conversion support.
03:59:28 <Bonus> aha
03:59:35 <quicksilver> for values of "little of no" approaching "there are multiple libraries which solve this problem"
03:59:47 <cjs__> Oh, really? I guess just nothing standard, then.
03:59:59 <quicksilver> utf8-string, encoding, compactstring
04:00:07 <quicksilver> and iconv
04:00:13 <quicksilver> and maybe a 5th which I always forget
04:00:15 <cjs__> Ok, never mind. I know not of what I speak.
04:00:41 <dmwit> Bonus: I think the short answer is: "Haskell is pretty good at Unicode." =)
04:00:44 <quicksilver> it is certainly odd that the builtin IO primitives strip non-8-bit chars.
04:00:53 <Bonus> hehe yeah that's what i was looking for
04:00:54 <quicksilver> but outside of that oddity, support is pretty good.
04:07:23 <SamB> how long has the Haskell report specified that Char support Unicode?
04:08:54 <dmwit> Since before Unicode existed!
04:09:53 <mauke> No instance for (regex-base-0.72.0.1:Text.Regex.Base.RegexLike.RegexLike Regex S.ByteString)
04:10:23 <mauke> but Text.Regex.Posix.Wrap says there's an instance RegeLike Regex ByteString
04:10:37 <mauke> (this is my first attempt to use regexes in haskell)
04:11:37 <mauke> what am I missing?
04:11:51 <quicksilver> mauke: wrong text.regex version I think
04:11:56 <quicksilver> bytestring support is recent. very recent?
04:13:17 <jacobian_wrk> How can haskell type variables range over constructors?
04:13:34 <jacobian_wrk> I mean, what is an example of such a feature
04:13:41 <dmwit> They don't.
04:13:47 <quicksilver> type constructors, they can
04:13:51 <quicksilver> if that's what jacobian_wrk means
04:13:53 <dmwit> oh
04:13:54 <quicksilver> :k StateT
04:13:57 <lambdabot> * -> (* -> *) -> * -> *
04:14:05 <quicksilver> the second parameter to StateT has kind * -> *
04:14:10 <quicksilver> i.e. it's a type constructor
04:14:15 <jacobian_wrk> Ah, I get it
04:14:52 <quicksilver> kind inference is decidable (indeed, it's easy)
04:14:59 <quicksilver> so you never need explicit kind annotations
04:15:33 <mauke> isn't http://haskell.org/ghc/docs/latest/html/libraries/regex-posix/Text-Regex-Posix-Wrap.html for 6.8.2?
04:15:34 <lambdabot> http://tinyurl.com/69tuoe
04:15:58 <dmwit> Type inference is not decidable?  (Without extensions?)
04:17:02 <quicksilver> mauke: that URL relates to the version in the darc repo
04:17:10 <quicksilver> mauke: I don't remember which version got bundled with 6.8.2
04:17:15 <quicksilver> mauke: (and I don't know how to tell, either)
04:17:31 <quicksilver> mauke: I was only guessing about versions, but I do remember bytestring regex support being a relatively recent feature.
04:20:09 <wjt> huh.  I've installed Network.Curl, but running :m +Network.Curl in ghci yields Â«module main:Network.Curl is not loadedÂ». weird.
04:20:38 <mauke> the docs are for 0.72.0.2 and that's what I have
04:21:07 <wjt> oh, ghci -lcurl helps!
04:22:57 <byorgey> dmwit: no, type inference is not decidable *with* extensions =)
04:23:06 <byorgey> like, say, UndecidableInstances
04:23:53 <quicksilver> mauke: then I think I must be wrong, sorry :(
04:23:55 <byorgey> I'm pretty sure type inference is decidable in H98
04:25:44 <byorgey> wjt: it also doesn't like it sometimes if you try doing :m +Foo in the directory where Foo is.  As if it could load it either from the installed package, or from the current directory, so it petulantly huffs and does neither.
04:25:53 <solrize> http://hpaste.org/7128   can imake this strict somehow?
04:26:25 <wjt> byorgey: mmmh, i wasn't in the curl source dir; i've seen that behaviour before with a library of my own, though; good to know i'm not imagining it :)
04:27:26 <byorgey> something of a bug IMO, although there may be a good reason for it that I'm not aware of.
04:27:33 <dolio> solrize: Make what strict?
04:27:41 <mauke> @seen bos
04:27:41 <lambdabot> bos is in #ghc and #haskell. I last heard bos speak 4h 20m 2s ago.
04:28:06 <solrize> dolio, when i run that prog, the trace output goes 20,18,16,... instead of the other way
04:28:25 <solrize> i.e. i want to do the state updates in strict order
04:28:32 <solrize> instead of building up a huge thunk
04:28:36 <byorgey> solrize: also, btw, I don't think return () means what you think it means
04:28:47 <byorgey> in particular, it does not cause 'hack' to exit early.
04:28:48 <dolio> What happens if you 'import Control.Monad.State.Strict'?
04:28:57 <byorgey> the 'modify' still gets run regardless.
04:29:03 <solrize> byorgey i didn't want to exit hack early
04:29:16 <solrize> i just wanted to not return any value
04:29:22 <solrize> dolio, that sounds like just what i want
04:29:24 <solrize> let me try it
04:29:35 <byorgey> solrize: didn't want to return a value from what?
04:29:53 <solrize> byorgey, basically what i'm trying to do is crunch a file containing a few million lines, one line at a time
04:30:05 <byorgey> oh, I see, you only want to call 'trace' when i is even
04:30:08 <solrize> and every 5000 lines or so i want to print a message showing the progress
04:30:14 <byorgey> ok, never mind =)
04:30:42 <solrize> anyway let me try control.monad.state.strict
04:31:02 <solrize> yes!  that did it!
04:31:50 <solrize> so is this approach insane?   and what i really like to do is print a timestamp on each of those messages...
04:32:09 <solrize> but i think i could only do that in the io monad, which means i'd have to use a StateT IO   ?
04:32:24 <solrize> right now i just sort of barely understand State
04:32:33 * dolio goes to sleep.
04:33:12 <solrize> dolio, thanks
04:34:16 <mauke> > foldl f c [x,y,z]
04:34:17 <lambdabot>  f (f (f c x) y) z
04:34:50 <mauke> > foldl1 f [x,y,z]
04:34:51 <lambdabot>  f (f x y) z
04:36:04 <mux_> no need to annotate type to be Expr anymore?
04:36:39 <Botje> :t f
04:36:40 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
04:36:48 <Botje> :t [x,y,z]
04:36:49 <lambdabot> [Expr]
04:36:52 <Botje> :)
04:36:59 <Botje> they've added some variables with Expr types
04:39:55 <damg> is it possible to return a general type a of a class instead of a concrete instance? something like http://hpaste.org/7130
04:40:30 <mauke> sounds like you want existential types
04:40:48 <mauke> your current signature says fromFoo's caller gets to decide the type
04:40:59 <quicksilver> damg: yes, http://www.haskell.org/haskellwiki/Existential_type
04:41:01 <lambdabot> Title: Existential type - HaskellWiki
04:41:01 <mauke> you want the instances to choose a type
04:41:24 <damg> thank you!
04:43:48 <solrize> are existential types still cool?  i mean are they subsumed by GADT's?
04:44:44 <quicksilver> that's like asking "are trousers still cool? I mean are they subsumed by clothes?"
04:44:48 <quicksilver> :)
04:44:50 <mm_freak_work> http://www.haskell.org/monad/ â what's that?!
04:44:53 <lambdabot> Title: Index of /monad
04:45:06 <quicksilver> just because you have a name for a larger group of things doesn't maek the specific group irrelevant
04:45:25 <solrize> i thought gadt's had a different syntax than the existential type stuff from earlier
04:46:29 <mauke> data WNum :: * where WNum :: forall a. (Num a) => a -> WNum
04:46:38 <quicksilver> they give you a slightly different syntax for declaring the data type
04:46:41 <quicksilver> that's all
04:47:02 <mauke> data WNum = forall a. (Num a) => WNum a
04:48:46 <solrize> http://hpaste.org/7128#a2   hmm, now it inserts stuff in the right order, but gets a stack overflow on trying to find the size
04:51:00 <solrize> can i put a strictness annotation on the state constructor?
04:51:04 <quicksilver> well, it's not until you try to find the size that you do anything at all
04:51:05 <solrize> State !(IM.IntMap Int)
04:51:13 <quicksilver> so taht's a bit of a red herring as far as it goes
04:52:16 <solrize> well it does all those state updates and prints the trace messages, but i guess the intmap is a huge nested thunk
04:52:28 <quicksilver> it shouldn't be.
04:52:39 <quicksilver> intmap should be strict in its spine, I thought.
04:52:53 <quicksilver> and your strict state should force it
04:53:28 <quicksilver> compiled or interpreted?
04:53:36 <solrize> ghci
04:53:44 <quicksilver> try compiling it with -O
04:53:48 <quicksilver> out of interest
04:53:55 <solrize> ok, sec
04:54:22 <solrize> (2000000,2000000,1385447424)
04:54:22 <solrize> Stack space overflow: current size 8388608 bytes.
04:54:22 <solrize> Use `+RTS -Ksize' to increase it.
04:55:01 <solrize> same thing with -O2
04:55:33 <quicksilver> when I run it it appears to stack overflow whilst trying to print 150^2
04:55:35 <quicksilver> which is a bit odd.
04:56:28 <solrize> 150^2?  you unguarded the trace i guess
04:56:39 <quicksilver> no
04:56:47 <quicksilver> (148,148,21904)
04:56:47 <quicksilver> (150,150,*** Exception: stack overflow
04:56:57 <solrize> wow, that doesn't happen to me
04:57:03 <solrize> oh you have `mod` 2 ?
04:57:19 <quicksilver> yes
04:57:21 <solrize> hmm
04:57:23 <quicksilver> I copied from your paste
04:57:31 <solrize> http://hpaste.org/7128#a2   that one?
04:57:36 <quicksilver> now it just overflows without printing anything
04:57:45 <quicksilver> yes
04:57:57 <solrize> i'm using 6.8.2 and it prints all the trace messages and then stack overflows on trying to print the size
04:58:30 <solrize> oh whoops, i forgot to change the paste
04:58:36 <solrize> i changed `mod`2 to `mod`500000
04:58:39 <solrize> 50000 rather
04:59:02 <solrize> http://hpaste.org/7128#a3
04:59:05 <solrize> that prints all the messages
04:59:33 <solrize> however i get way past 150 when i use mod 2
04:59:44 <quicksilver> ah
04:59:48 <quicksilver> red herring
04:59:50 <quicksilver> the bug in is ..
05:00:26 <quicksilver> or maybe not.
05:00:27 <quicksilver> hmm
05:04:09 <quicksilver> solrize: there is a bug in .. for Int
05:04:24 <quicksilver> solrize: but the workaround I thought I knew doesn't fix it
05:04:30 <solrize> sorry?
05:04:30 <mauke> quicksilver: ah, regex-posix may be built against the wrong bytestring version
05:04:54 <solrize> you mean the 1.. is doing something wrong in the compiler?
05:04:58 <solrize> should i use Integer ?
05:05:06 <solrize> or Float or something?
05:05:24 <damg> hm, existentials are an extension to haskell98. But then e.g. fromIntegral wouldn't be possible in h98 ...
05:05:34 <mauke> damg: huh?
05:05:39 <quicksilver> damg: not so. fromIntegral does not use existentials.
05:05:52 <quicksilver> damg: indeed, that is a good example of the difference :)
05:06:26 <damg> hm, i'll apt-source ghc to see how it works :)
05:06:36 <quicksilver> solrize: http://hackage.haskell.org/trac/ghc/ticket/1997
05:06:40 <lambdabot> Title: #1997 (Stricter enumFrom instance for Integer, to match Int) - GHC - Trac
05:06:44 <quicksilver> :t fromIntegral
05:06:45 <mauke> @src Num
05:06:45 <lambdabot> class  (Eq a, Show a) => Num a  where
05:06:45 <lambdabot>     (+), (-), (*)           :: a -> a -> a
05:06:45 <lambdabot>     negate, abs, signum     :: a -> a
05:06:45 <lambdabot>     fromInteger             :: Integer -> a
05:06:47 <lambdabot> forall a b. (Num b, Integral a) => a -> b
05:06:54 <mauke> @src fromIntegral
05:06:54 <lambdabot> fromIntegral = fromInteger . toInteger
05:07:00 <quicksilver> damg: fromIntegral works for any types a,b, the caller gets to choose
05:07:05 <quicksilver> damg: that's different from existential
05:07:12 <quicksilver> damg: in an existential the function chooses
05:07:18 <quicksilver> and the claler doesn't know exactly which type it got
05:07:30 <solrize> quicksilver, arggggghhhhh!!!!!!    thanks !
05:07:39 <damg> hm, interesting
05:07:56 <quicksilver> solrize: I"m not sure if it's relevant to be honest
05:08:00 * matthew_- breaks through the hour mark with ghci compiling his code
05:08:03 <quicksilver> solrize: there is definitely somethign I don't understand.
05:08:17 <damg> because fromInteger looks to want to do exactly what I want to do
05:08:27 <damg> :t fromInteger
05:08:28 <lambdabot> forall a. (Num a) => Integer -> a
05:08:49 <quicksilver> damg: that returns some type a CHOSEN BY THE CALLER
05:08:54 <quicksilver> that's different from an existential
05:08:54 <matthew_-> err, type checking, not compiling
05:09:07 <quicksilver> which returns some type a which is 'secret' and the caller doesn't know what it got.
05:09:42 <damg> ok, I understood it. thank you
05:10:05 <solrize> i change the map to hold floats and it gets the same overflow
05:10:21 <quicksilver> solrize: might be worth posting to the -cafe
05:10:29 <quicksilver> unless someone else comes along and explains it
05:10:37 <solrize> how do i do that?  have to email someplace?  ugh
05:11:29 <quicksilver> you don't have to do anything
05:11:40 <quicksilver> but the haskell-cafe mailing list has the best stock of haskell knowledge known to man
05:11:50 <quicksilver> it has decent odds of solving a problem :)
05:12:11 <solrize> getting rid of 1.. didn't help
05:12:14 <solrize>    let sq = take 2000000 $ [(x,(fromIntegral x)**2) | x <- (iterate (+1) 1)]
05:12:22 <solrize> i might just ask about it here during the day when more ppl are around
05:13:38 <solrize> i would have thought there'd be some strictness annotation i could use on the modify
05:16:58 <solrize>    let nums = iterate (\x -> (let y = 1+x in y `seq` y)) 1
05:16:58 <solrize>    let sq = take 500000 $ [(x,(fromIntegral x)**2) | x <- nums]
05:17:01 <solrize> still loses
05:21:06 <desegnis> What's the difference between (+1) and (\x -> let y = 1+x in y `seq` y) ?
05:21:22 <Zao> Strictness?
05:21:25 <solrize> +1 is lazy
05:21:31 <EvilTerran> no strictness difference
05:21:40 <desegnis> no, those definitions are equivalent I think
05:21:42 <EvilTerran> the LHS of `seq` only gets forced when the RHS does
05:21:46 <solrize> hmm
05:22:00 <EvilTerran> so (y `seq` y) is wholly the same as just y
05:22:03 <solrize> well it's obvious that it's getting forced since the tracing messages are printing it
05:22:14 <desegnis> besides, (+) is strict anyway
05:22:19 <EvilTerran> indeed
05:22:48 <EvilTerran> i think, if you wanted more strictness, you'd need something like
05:23:26 <EvilTerran> iterate' f x = x `seq` (x : iterate f (f x))
05:23:46 <EvilTerran> which'd force each element as you forced the cons following it
05:24:03 <gnuvince> bos++
05:24:06 <gnuvince> dons++
05:24:16 <gnuvince> Thank you bot for the new chapters :)
05:24:20 <dcoutts_> EvilTerran: you really want to be doing the forcing when consuming, not producing
05:24:36 <EvilTerran> i have no context here, i'm just tossing ideas around
05:24:43 <EvilTerran> but sure, okay :)
05:24:51 <solrize> new chapters??!!!!   yay!
05:24:55 * solrize looks
05:25:42 <dcoutts_> EvilTerran: hmm, actually perhaps you're right
05:26:05 <desegnis> EvilTerran, you might even want to force f x instead of x
05:26:08 <dcoutts_> EvilTerran: though still, no need to fuse that into iterate
05:26:12 <EvilTerran> that force will only happen when you consumre the list anyway
05:26:16 <dcoutts_> right
05:26:52 <dcoutts_> something like foldr seq . iterate blah
05:27:11 <EvilTerran> ?type foldr seq
05:27:12 <lambdabot> forall a b. b -> [a] -> b
05:27:31 <dcoutts_> not quite, we want [a] -> [a]
05:27:47 <EvilTerran> ?type foldr (\x e -> x `seq` (x:e)) []
05:27:47 <lambdabot> forall a. [a] -> [a]
05:28:03 <desegnis> @type foldr seq ()
05:28:05 <lambdabot> forall a. [a] -> ()
05:28:17 <desegnis> crap
05:28:38 <desegnis> @type \xs -> foldr seq xs xs
05:28:39 <lambdabot> forall a. [a] -> [a]
05:28:53 <dcoutts_> > head $ foldr (\x e -> x `seq` (x:e)) [1, undefined]
05:28:53 <EvilTerran> ... that's quite clever, actually. allows you to tie the forcing of each element to the forcing of the associated cons regardless of where the list came from.
05:28:53 <lambdabot>  Couldn't match expected type `[a]'
05:29:10 <dcoutts_> > head $ foldr (\x e -> x `seq` (x:e)) [] [1, undefined]
05:29:12 <lambdabot>  1
05:29:26 <PeakerWork> @src undefined
05:29:27 <lambdabot> undefined =  error "Prelude.undefined"
05:29:33 <dcoutts_> > head $ tail $ foldr (\x e -> x `seq` (x:e)) [] [undefined, 1]
05:29:33 <EvilTerran> and it only goes as far down the list as you force the conses
05:29:34 <lambdabot>  Exception: Prelude.undefined
05:29:50 <dcoutts_> EvilTerran: yes
05:29:56 <EvilTerran> > head $ join (foldr seq) [1, undefined]
05:29:57 <lambdabot>  Exception: Prelude.undefined
05:30:08 <EvilTerran> > head $ join (foldr seq) [1, 2, 3]
05:30:09 <lambdabot>  1
05:30:35 <EvilTerran> ... while that one forces the whole thing, even if you don't use the whole thing. i think i prefer mine. :)
05:31:01 <solrize>    modify ((IM.insert $! x) $! y)            doesn't help
05:31:09 <vincenz> EvilTerran: what''s yours
05:31:13 <Saizan> ?ty ap seq (:)
05:31:14 <lambdabot> forall a. a -> [a] -> [a]
05:31:38 <EvilTerran> foldr (\x e -> x `seq` (x:e)) []
05:31:58 <dcoutts_> EvilTerran, solrize: so that works
05:32:01 <vincenz> @pl (\x e -> x `seq` (x:e))
05:32:02 <lambdabot> liftM2 (.) seq (:)
05:32:06 <dcoutts_> let strictify = foldr (\x e -> x `seq` (x:e)) []
05:32:09 <vincenz> isn't liiftM2 ap id?
05:32:09 <dcoutts_> let sq = take 500000 $ [(x,(fromIntegral x)**2) | x <- strictify nums]
05:32:15 <dcoutts_> sq !! (500000-1)
05:32:19 <dcoutts_> and no stack overflow
05:32:29 <solrize> oh cool let me try that
05:32:29 <dcoutts_> without the strictify nums we do get the stack overflow
05:32:43 <dcoutts_> but the nice thing is it's still lazy
05:32:47 <EvilTerran> ?pl \x e -> x `seq` (x:e)
05:32:47 <lambdabot> liftM2 (.) seq (:)
05:32:52 <EvilTerran> ... i had to ask O.o
05:33:10 <ddarius> I think there are good cases for all three ways of adding strictness.
05:33:38 <solrize> what was nums again?
05:33:49 <dcoutts_> solrize: what you defined it as originally
05:34:18 <dcoutts_> iterate (\x -> (let y = 1+x in y `seq` y)) 1 = iterate (1+) 1
05:34:34 <solrize> got it
05:35:18 <solrize> hmm i still get a stack overflow in ghci
05:35:19 <EvilTerran> [1..] would probably work just as well, now
05:35:39 <solrize> also with ghc -O2
05:35:50 <EvilTerran> hmm
05:35:59 <dcoutts_> solrize: so what are you doing now exactly?
05:36:09 <solrize> http://hpaste.org/7128#a4
05:40:18 <solrize> it does let me compute sq !! (500000-1)
05:40:29 <solrize> but i'm not sure that was failing before
05:40:34 <dcoutts_> yes it was :-)
05:40:37 <dcoutts_> try it
05:41:24 <solrize> *Main> [(x,(fromIntegral x)**2) | x <- [1..]] !! 500000
05:41:24 <solrize> (500001,2.50001000001e11)
05:41:45 <solrize> *Main> (take 500000 [(x,(fromIntegral x)**2) | x <- [1..]]) !! (500000-1)
05:41:45 <solrize> (500000,2.5e11)
05:41:49 <dcoutts_> that's not the same
05:42:07 <dcoutts_> try the code you originally wrote, with the iterate etc
05:42:38 <solrize> i originally had [1..], the iterate was an attempt to strictify it, but trying with iterate...
05:42:50 <Saizan> however in the original code he's consuming the elements in order, so strictify shouldn't help, no?
05:43:08 <dcoutts_> solrize: the other difference was you were retaining intermediate values using let
05:43:08 <solrize> i think it's the map itself that's not being built strictly
05:43:16 <solrize> hmm
05:43:25 <EvilTerran> Saizan, i think the problem is you get a big thunk buildup in, say, ([1..] !! 500000)
05:43:42 <KniGhT_ShaDoW> hello
05:43:51 <Saizan> EvilTerran: i don't see an use of !! in the paste
05:43:52 <KniGhT_ShaDoW> what is hackshell ?
05:43:56 <EvilTerran> but, in (strictify [1..] !! 500000), the elements are forced as you force the list spine, so the thunk buildup doesn't happen
05:44:09 <EvilTerran> well, he's using !! in the channel. i dunno.
05:44:58 <Saizan> solrize: i'd try do m <- get; let m' = M.insert x y m; m' `seq` put m, instead of modify ...
05:45:42 <dcoutts_> solrize: or just let z = foldl' (\m (x,y) -> IM.insert x y m) IM.empty sq
05:45:48 <Saizan> because Control.Monad.State.Strict is only strict in the tuple
05:45:55 <solrize> trying saizan's suggestion
05:46:17 <solrize> dcoutts if i use foldl', how do i print a trace message every 50000 inserts?
05:46:50 <Saizan> you keep (i,m) as the accumulator
05:47:19 <PeakerWork> @src strictify
05:47:19 <lambdabot> Source not found. Just what do you think you're doing Dave?
05:47:22 <Saizan> (but then you've to add strictness annotations)
05:48:25 <solrize> saizan, that works!  (using m' `seq` put m')
05:48:43 <Saizan> ah yeah :)
05:49:14 <solrize> they ought to add modify' to the monad
05:49:17 <ddarius> Saizan likes calculating results and then throwing them away
05:50:06 <Saizan> so i can calculate them again
05:50:39 <Deewiant> put $! m'
05:51:03 <solrize> deewiant, i'm trying that
05:51:16 <solrize> that also worked
05:51:29 <solrize> thanks
05:51:29 <Deewiant> should be the same as m' `seq` put m' unless I'm confused
05:51:34 <solrize> yeah
05:51:35 <Saizan> ?src ($!)
05:51:36 <lambdabot> f $! x = x `seq` f x
05:51:38 <ddarius> :t let modify' = (get .) . (. (put . ($!))) in modify'
05:51:40 <lambdabot> forall (m :: * -> *) b a b1 b2. (MonadState (a -> b1) m, MonadState b2 ((->) b)) => (m () -> b) -> (a -> b1) -> b2
05:51:48 <solrize> @src modify
05:51:48 <lambdabot> Source not found. You speak an infinite deal of nothing
05:52:00 <Deewiant> @unpl (get .) . (. (put . ( $!)))
05:52:00 <lambdabot> (\ e k -> get (e (put (($!) k))))
05:52:14 <ddarius> :t let modify' = (get .) >=> (. (put . ($!))) in modify'
05:52:15 <lambdabot> forall (m :: * -> *) a b a1 c. (MonadState (a -> b) m, MonadState (m () -> c) ((->) a1)) => ((a -> b) -> a1) -> (a -> b) -> c
05:52:28 <Saizan> they should add strictness properties in the haddock of those .Strict variants
05:52:48 <solrize> man that was a big headache
05:53:22 <dcoutts_> solrize: http://hpaste.org/7128#a5
05:53:25 <ddarius> The standard should go through and specify the strictness behaviour of most of the functions as well as choosing reasonably defaults for them rather than tending to be as lazy as possible.
05:54:15 <dcoutts_> solrize: note, no strictness fiddling and no state monad, just simple functional programming, plus your evil use of trace :-)
05:54:21 <solrize> dcoutts_ thanks i may write it that way
05:54:47 <ddarius> Only in Haskell does one get berated for a print statement.
05:54:49 <solrize> there's still strictness fiddling in the foldl'  but that's more tasteful ii guess
05:54:52 <dcoutts_> solrize: of course if you really want to print the intermediate values then using trace is not the right way
05:55:40 <solrize> what's the right way?
05:56:27 <solrize> i thought of using StateT IO
05:56:36 <solrize> so that i could use normal print statements
05:56:51 <solrize> but it just seemed daunting
05:58:11 <Saizan> why you want that trace? like a progess status?
05:58:19 <solrize> saizan, yeah, the program runs for hours
05:59:21 <solrize> in C i used to do stuff like jam status info into *argv so that "ps" would show what the program was doing
05:59:27 <solrize> but that is going too far :)
06:00:17 <cjs__> Hm. For my system I was planning to jam stuff into mvars as I go along, and have a separate thread that would let me query stuff from there.
06:00:41 <solrize> yow i guess i could do that
06:01:03 <cjs__> Actually, having an Excel spreadsheet that would hook up via a TCP connection and exchange commands back and forth, asking the trader to send updates of various things to various cells.
06:01:06 <solrize> i'm still at a stage where it takes me forever to make simple things work
06:01:19 <solrize> cjs wow
06:01:25 <Saizan> well, howeve i'd use foldM in IO here
06:01:30 <cjs__> So you could, e.g., watch a pricing model as it evolves.
06:01:45 <cjs__> solrize: I'm still at the same stage. :-)
06:02:14 <cjs__> Actually, today wasn't so bad. Perhaps just because I was working on simpler stuff, but I feel like I made a reasonable amount of forward progress.
06:02:29 <solrize> i've spent something like 3 days on this, which is way more than i can really afford
06:02:39 <cjs__> Though I realize, this is now the start of my second month of (almost) full time Haskell hacking and building this application.
06:04:04 <cjs__> My abilities to organize a program in Haskell have gone from almost completely hopeless to somewhat hopeless. That's progress, of a sort, I guess.
06:04:45 <uebayasi> cheers :)
06:05:25 <cjs__> I wonder though if I'm not working too hard to avoid keeping state. Maybe I should just use a bit more; it would still be tons less than in OO programming.
06:05:56 <Saizan> as a guideline State is useful when you've a number of disparate functions that have to access the state, if you use it so locally and with execState you're probably better with a fold
06:06:04 <matthew_-> so, is Dimitris Vytiniotis here and/or do people know him?
06:06:42 <cjs__> I am getting a lot of practice at hiding stuff inside closures.
06:07:51 <solrize> saizan, that sounds like good advice.  i used state because i couldn't think of any other way to get the tracing in there
06:08:00 <matthew_-> Corun: what are you doing here? You should be revising!
06:08:37 <ddarius> With enough resourcefulness there is always a solution.
06:08:39 <dcoutts_> solrize: http://hpaste.org/7128#a6
06:08:40 * ddarius walks off.
06:09:13 <dcoutts_> note how it separates the tracing from the IO
06:09:33 <dcoutts_> but due to lazyness we get interleaveing of the calculation and the printing
06:09:39 <cjs__> Actually, for status, if you're not particularly caring about perfect accuracy, perhaps MVars are the way to go. After all, does it worry you so much if you observe it 0.5 or 1.5 seconds out of date?
06:09:40 <dcoutts_> but no foldM or equivalent
06:10:02 <solrize> dcoutts_, interesting, i'm trying to grok it
06:10:05 <dcoutts_> solrize: we generate a lazy list of partial answers and finally the result
06:10:30 <dcoutts_> then we just print all the intermediate answers and the final result
06:10:51 <Corun> Very funny, Matt
06:10:52 <Corun> :-)
06:10:59 <matthew_-> REVISE BOY!
06:11:07 <solrize> :t either
06:11:09 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
06:11:11 <Corun> brb
06:11:16 <matthew_-> Corun: you have "really hard" exams coming up
06:11:33 <dcoutts_> solrize: the either is just because your intermediate results are a different type from the final result
06:11:53 <dcoutts_> so we bung them in an Either and use 'either' to print the two kinds of results differently
06:12:44 <solrize> shouldn't the otherwise have a Right ?
06:12:57 <dcoutts_> solrize: no, Right is for the final answer
06:13:09 <dcoutts_> solrize: in the otherwise case we don't produce any intermediate result
06:13:20 <dcoutts_> we just carry on calculating
06:14:16 <dcoutts_> solrize: instead of Either we could have used: data Result = Trace (Int,Float) | Result (IntMap Float)
06:15:05 <solrize> well trace is evil
06:15:20 <Corun> Right I'm back
06:15:26 <Corun> What's this revision thing you were talking about Matt?
06:15:46 <cjs__> dcoutts_: BTW, getLazyByteString test case generated and sent off. Today I switched back to reading ByteStrings from a handle (socket), raather than using getContents.
06:16:08 <dcoutts_> cjs__: ta
06:16:11 <solrize> but this other thing seems pretty difficult to get right
06:16:24 <dcoutts_> solrize: hmm?
06:17:00 <solrize> oh i see, $! takes care of the strictness
06:17:03 <dcoutts_> solrize: the key thing to note about that foo, is that it lazily produces a list of intermediate results but it has a strict accumulating param -- the intmap
06:17:08 <dcoutts_> solrize: yes, exactly
06:17:33 <cjs__> I don't think trace is evil at all; it's very nice. It would be dumb to use it in any place where you cared about evaluation order, but that's hardly the typical case you'd even think about using it.
06:17:37 <dcoutts_> solrize: or equivalently with bang patterns we could have put a ! on the m input
06:17:59 <dcoutts_> cjs__: it's evil to use in a production prog, it's great for debugging and understanding though
06:18:44 <cjs__> Well, hmm, I guess I can't think of a circumstance where I'd use it in a production program, off-hand. In fact, I've used it a fair but, but never has a call to trace been commited to the code repository.
06:18:45 <solrize> i like to print the current time with the trace messages and i didn't see a way to do that without using unsafeperformIO or actually running in IO
06:18:51 <solrize> but with this other method it's easier i think
06:18:52 <cjs__> s/fair but/fair bit/
06:19:16 <dcoutts_> solrize: you can do that at the end, when printing
06:19:26 <solrize> right since the printing is in main
06:19:29 <dcoutts_> solrize: instead of print use printWithTime
06:19:36 <dcoutts_> which you can write
06:19:37 <solrize> :t printWithTime
06:19:38 <lambdabot> Not in scope: `printWithTime'
06:19:39 <solrize> oh i c
06:22:18 <solrize> thanks this has been very enlightening
06:22:26 <solrize> i think i can apply this stuff to the real prog
06:26:04 <solrize> once i get these haskell progs to work, they feel a lot more solid and serious than the corresponding python scripts.  but it takes an awful lot of head smacking (so far) and i don't get anything like the speedups i was hoping for (though i generally do get some)
06:27:50 <cjs__> Gah. When refactoring, I keep writing commit messages that say "extract method" instead of "extract function."
06:32:51 <solrize> i just realized the little pauses i see are garbage collection
06:33:26 <dcoutts_> solrize: you can get the rts to beep on each major GC
06:33:36 <solrize> yeah i saw that in the docs :)
06:33:49 <solrize> i'm ok with the pauses, they're short and this is a batch operation
06:36:18 <dcoutts_> Cale: re this discussion about $, isn't the simplest case things like:
06:36:22 <dcoutts_> check (not $ null unknownImpls)
06:36:43 <dcoutts_> where we want to apply not to the whole expression to the right
06:37:02 <dcoutts_> we don't want check ((not null) unknownImpls)
06:37:31 <dcoutts_> or am I still confused
06:37:51 <dcoutts_> I guess it does still mean that since functions bind tighter
06:38:46 <dcoutts_> it's only when we start piling more foo $ up on the left when it'd change
06:42:20 <skorpan>     Could not find module `System.Directory':      it is a member of package directory-1.0.0.0, which is hidden
06:42:26 <skorpan> why does that happen?
06:42:43 <mux_> I guess you are building something via cabal
06:42:45 <skorpan> ghc-pkg list lists it
06:42:49 <mux_> cabal hides everything by default
06:42:58 <skorpan> so what do i do?
06:43:02 <mux_> so you have to put the corresponding dependency in the .cabal file to be able to use some package
06:43:14 <dcoutts_> skorpan: build-depends: directory
06:43:17 <mux_> in that case, add directory
06:44:49 <skorpan> i was trying to make a PKGBUILD for the arch user repository, but there's just too much small fixes that have to be done in order for it to work...
06:44:58 <skorpan> trying to automate the installation of BNFC
06:47:28 <dcoutts_> skorpan: the medium/long term plan is to do much more QA at the hackage level so that it should be easy for distributions like yours since we'll already know what does and does not build ok
06:48:15 <dcoutts_> skorpan: we have the same problem for gentoo, we have to do too much patching at the distro level, we should share that work and get it done centrally
06:49:32 <skorpan> that would indeed be awesome
06:54:09 <dcoutts_> @seen nominolo
06:54:09 <lambdabot> I saw nominolo leaving #haskell-soc, #haskell.se, #ghc, #haskell-hac4 and #haskell 15h 40m 15s ago, and .
06:54:51 <dcoutts_> @tell nominolo we seem to have a bug with the recent configurations resolution changes, cabal-install itself get's configured incorrectly
06:54:51 <lambdabot> Consider it noted.
06:55:06 <dcoutts_> get's/gets
06:56:14 <czakey> Consider it corrected.
06:56:14 <czakey> ;>
06:56:51 <MarcWeber> @tell ndm which are the option to be used to compile your option lib on ghc-6.8.2?
06:56:52 <lambdabot> Consider it noted.
06:57:58 <Bonus> is there any difference between doing liftM f m and m >>= return . f
06:58:20 <vincenz> Bonus: syntax
06:58:25 <vincenz> @src liftM
06:58:26 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
06:58:36 <Bonus> yeah i meant like
06:58:39 <Bonus> in behavior
06:58:39 <vincenz> @undo do { x1 <-m 1; return (f x1) }
06:58:40 <lambdabot> m 1 >>= \ x1 -> return (f x1)
06:58:46 <vincenz> nop
06:58:49 <Bonus> kewl
06:58:54 <mauke> Bonus: no, >>= return . is liftM
07:07:17 <cjs__> So "newtype StockCode = StockCode { unStockCode :: ByteString }" will be just as efficient as using a ByteString directly, right?
07:07:51 <vincenz> cjs__: yes
07:08:53 <cjs__> That's a happy thing. Extra typechecking for free (at runtime).
07:09:41 <vincenz> cjs__: at compiletime
07:09:54 <cjs__> Err..."no runtime cost."
07:10:38 <vincenz> Right, but typechecking is at compiletime :)
07:10:58 <Deewiant> Yes, but it's free at runtime. ;-)
07:10:58 <cjs__> Yes. Thus, "mmmm."
07:11:18 <vincenz> I guess your sentence was ambiguously parsable :)
07:11:37 <cjs__> You know, it's the astounding levels of intellectuality in the conversation on this channel that made me swtich to Haskell....
07:12:01 <vincenz> cjs__: Starting to doubt that now? :P
07:12:30 <cjs__> Never! I can just *feel* that I'm in the presence of genius.
07:12:55 <vincenz> cjs__: returning to newtype
07:13:09 <vincenz> cjs__: th way to think about it is that 'data' introduces a pointer for each field, while newtype does not
07:13:25 <vincenz> cjs__: which also explains why for 'data Foo a = Foo a'
07:13:30 <vincenz> Foo _|_ != _|_
07:13:36 <vincenz> while for newtype it would be
07:13:51 <vincenz> (just imagine _|_ as a null-pointer and it makes sense :)
07:14:56 <cjs__> Ok. That makes sense to me. That was more or less what I was intuitively thinking, anyway, from stuff I'd read. I just wanted a confirmation on it.
07:15:33 <cjs__> Though you'd think the compiler could figure out that a data with a single constructor doesn't need a pointer....
07:16:21 <quicksilver> cjs__: it could, but it would subtly change semantics
07:16:30 <quicksilver> cjs__: programs which terminated would not terminate
07:16:42 <quicksilver> it's a bit of a silly edge case, but they don't like optimisations which change semantics...
07:17:02 <cjs__> Really! Interesting.
07:17:16 <cjs__> Ah, yes, I see....
07:17:19 <quicksilver> foo `seq` 0
07:17:26 <quicksilver> you could argue that really "seq" is the problem here
07:17:28 <quicksilver> but there it is :)
07:18:47 <Deewiant> rule of thumb: use newtype and if your program loops infinitely try data instead. ;-)
07:21:44 <pejo> quicksilver, the "not liking optimisations that change the meaning of the program" is a very sane thing though.
07:22:53 <quicksilver> pejo: agreed.
07:23:05 <quicksilver> pejo: it's just that this particular one doesn't feel very important in practice.
07:23:14 <quicksilver> pejo: as a general principle that's excellent though :)
07:24:45 <PeakerWork> what's the relationship between Tunes and Haskell?
07:24:51 <PeakerWork> is Tunes a real "project"? :)
07:27:48 <pjd_> PeakerWork: "Redefining Computing" is a somewhat open-ended, for a project
07:28:55 <PeakerWork> pjd_, heh, I believe computing desparately needs redefining (though I am not sure my vision is very similar to that of Tunes)
07:29:46 * pjd_ believes it will incrementally sort itself out
07:29:51 <pjd_> hail Eris
07:29:56 <PeakerWork> its not working that well so far
07:30:00 <PeakerWork> (e.g the web)
07:30:09 <PeakerWork> Evolution has many limitations
07:30:38 <pjd_> the web is a success story, compared with what could have been
07:31:18 <PeakerWork> I don't think there are many ways for it to be worse
07:31:29 <PeakerWork> I think the web is almost as horrible as it could possibly be :)
07:32:15 <pjd_> PeakerWork: clearly you lack pessimism
07:32:31 <PeakerWork> also, I think that the size of the "solution" (current software architecture and components) is many orders of magnitude larger than the size of the "problem" (the actual functionality users require [mail, remote document viewing, document editing])
07:32:59 <cjs__> @remember pjd_: clearly you lack pessimism
07:33:00 <lambdabot> Good to know.
07:51:12 <audreyt> is there are deep reason why Control.Applicative has no definition of:
07:51:15 <audreyt> ($>) = flip (<$)
07:51:16 <audreyt> ?
07:51:23 <audreyt> s/are/a/
07:52:54 <EvilTerran> ?type ($>)
07:52:55 <lambdabot> Not in scope: `$>'
07:52:59 <EvilTerran> ?hoogle ($>)
07:52:59 <lambdabot> Control.Applicative.(<$>) :: Functor f => (a -> b) -> f a -> f b
07:52:59 <lambdabot> Text.ParserCombinators.Parsec.Perm.(<$$>) :: (a -> b) -> GenParser tok st a -> PermParser tok st b
07:53:16 * EvilTerran blinks... sorry, not paying attention
07:53:18 <EvilTerran> ?type (<$)
07:53:19 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
07:54:40 <audreyt> in applicative parsing it's convenient to replace
07:54:48 <audreyt> string "foo" >> return FooObject
07:54:50 <audreyt> to
07:54:55 <audreyt> string "foo" $> FooObject
07:55:10 <audreyt> it reads more natural than
07:55:15 <audreyt> string "foo" <$ FooObject
07:55:24 <audreyt> er I mean FooObject <$ string "foo"
07:56:22 <audreyt> defining it myself is no big deal. just curious if there's Deep Theoretical Reason
07:56:49 <dcoutts_> audreyt: if there is, it's not obvious to me
07:57:16 <quicksilver> I'm not sure if I agree, fwiw.
07:57:22 <pjd_> audreyt: <$> and <*> are intended to mirror/suggest application syntax, i think
07:57:25 <quicksilver> if FooObject took a parameter, I'd write
07:57:36 <quicksilver> FooObject <$> string "foo"
07:57:43 <quicksilver> so, even if it doesn't take a parameter
07:57:47 <quicksilver> I'd choose to write it that way around
07:57:51 <quicksilver> hence <$
07:58:03 <audreyt> no, FooObject is simply a literal
07:58:03 <audreyt> it's like
07:58:07 <quicksilver> I know.
07:58:10 <audreyt> string "y" $> True
07:58:13 <quicksilver> that's why I used the word "if"
07:58:21 <quicksilver> "if" FooObject took a parameter
07:58:24 <quicksilver> then I would...
07:58:25 <audreyt> mm.
07:58:33 <quicksilver> then if it doesn't take a parameter
07:58:34 <audreyt> so you'd use =<< instead of >>=
07:58:38 <quicksilver> correct.
07:58:40 <audreyt> in the monadic style
07:58:55 <quicksilver> because it mirrors straight forward functions
07:58:58 <quicksilver> where you just write
07:59:01 <quicksilver> FooObject (bar bar)
07:59:07 <quicksilver> FooObject <$> (bar bar)
07:59:12 <quicksilver> FooObject =<< (bar bar)
07:59:13 <audreyt> right. I guess I have this mental picture where it says
07:59:16 <quicksilver> nice parallel syntaxes
07:59:19 <audreyt> "first" you parse string
07:59:22 <audreyt> "then" you return a literal
07:59:23 * quicksilver nods
07:59:31 <quicksilver> that's a perfactly sensible view :)
07:59:34 <quicksilver> I was just explaining mine.
08:00:56 <audreyt> thanks for the clarification/sanity check :) bbl
08:01:58 <vincenz> quicksilver: you an emacser?
08:04:33 <quicksilver> vincenz: yes
08:04:36 <quicksilver> born and bred.
08:05:26 <mauke> @vixen dontcha wish your emacs was hot like vim?
08:05:27 <lambdabot> i'm on fire!
08:05:44 <vincenz> quicksilver: #oasis? since it's' a bit ot
08:07:58 <pjd_> that definition of $> does make sense, in the light of <$> : <*> and <$ : <*
08:09:57 <quicksilver> pjd_: definitely.
08:10:19 <quicksilver> pjd_: it makes sense, I was just explaining why I don't use it, and so possibly why they might not have defined it
08:13:17 * pjd_ wonders what name would correspond to f (a -> b) -> a -> f b
08:13:38 <mauke> :t pure
08:13:41 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
08:14:21 <EvilTerran> i tend to go for <%>
08:14:40 <EvilTerran> just as an arbitrary variant on <$> and <*>
08:14:54 <Jaak> > let o = 1 : s; s = 1 : t; t = s + o in o
08:14:55 <lambdabot>   add an instance declaration for (Num [t])
08:15:03 <Jaak> > let o = 1 : s; s = 1 : t; t = zipWIth (+) s o in o
08:15:04 <lambdabot>   Not in scope: `zipWIth'
08:15:14 <Jaak> > let o = 1 : s; s = 1 : t; t = zipWith (+) s o in o -- *sigh*
08:15:15 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
08:15:39 <pjd_> EvilTerran: then $> would actually be %>
08:15:50 <mauke> > let o@(_ : s) = 1 : 1 : zipWith (+) s o in o
08:15:51 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
08:16:20 <mauke> > let o = 1 : 1 : zipWith (+) o (tail o) in o
08:16:21 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
08:17:01 <mauke> > let o = (1 :) . (1 :) . ap (zipWith (+)) tail $ o in o
08:17:02 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
08:17:17 <mauke> > fix $ (1 :) . (1 :) . ap (zipWith (+)) tail
08:17:18 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
08:17:29 <mauke> pointlessness achieved.
08:17:36 * Corun has seen lambdabot say that _sooo_ many times.
08:18:09 <scook0> @oeis 1 1 2 3 5
08:18:10 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
08:18:10 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
08:18:39 <scook0> *that*'s how it's done :)
08:18:45 <nejucomo> I'm calling a function with input that does not match any of its patterns, so I get an error message about that fact.  But there is no stack trace.  How do I determine the call stack?
08:19:23 <audreyt> quicksilver: just a quick note to say thank-you for makign me see that $> harms normal equational reasoning. I was staring at
08:19:40 <audreyt> p1 = char '$' *> (VLabel <$> bareLabel)
08:19:42 <audreyt> p2 = VPage <$ sym "PAGE"
08:19:52 <audreyt> and was unhappy with the apparent asymmeetry, but p1 can easily be
08:20:06 <audreyt> p1 = VLabel <$> (char '$' *> bareLabel)
08:20:08 <mauke> nejucomo: you don't :/
08:20:14 <audreyt> and there's no assymetry anymore. thanks
08:20:32 <Baughn> nejucomo: There isn'T a call stack to get, really
08:20:37 <nejucomo> mauke: Really?!  That seems essential to debug, IMM.
08:20:49 <nejucomo> Baughn: I see.
08:21:00 <EvilTerran> p1 = VLabel bareLabel <$ char '$' -- audreyt, ?
08:21:03 <mauke> nejucomo: the dynamic call stack is a mess
08:21:24 <mauke> nejucomo: have you tried ghci's built-in debugger?
08:21:40 <Baughn> nejucomo: Haskell operates via graph reduction. There /is/ a call stack, but it probably bears no particular resemblance to the way you're reasoning about things
08:22:10 <nejucomo> I have not tried the debugger.
08:22:31 <nejucomo> Is there a way I can tell the debugger to run until an "error"?
08:22:48 <mauke> there was something like :set -fbreak-on-error
08:22:59 <Baughn> nejucomo: http://haskell.org/haskellwiki/Debugging <-- Have a look
08:23:02 <mauke> @where tmr
08:23:02 <lambdabot> http://www.haskell.org/haskellwiki/TheMonadReader
08:23:33 <nejucomo> Thanks for the refs.
08:23:35 <mauke> nejucomo: http://www.haskell.org/sitewiki/images/0/0a/TMR-Issue10.pdf
08:25:46 <quicksilver> audreyt: nice :)
08:26:00 <quicksilver> audreyt: you've discovered a factorisation law :)
08:26:13 <quicksilver> audreyt: <$> distributes through *>
08:26:47 <quicksilver> nejucomo: add this to your function:
08:27:04 <quicksilver> nejucomo: f x y z = error $ "called with invalid arguments " ++ show (x,y,z)
08:27:09 <quicksilver> nejucomo: as its "final case"
08:27:25 <quicksilver> nejucomo: this recipe requires some modification if your function doesn't take 3 args but I bet you can work it out :)
08:30:36 <nejucomo> quicksilver: I've already done that, but now I have to trace what I think of as the "call stack" backwards adding argument checking and/or unit tests.
08:30:58 <nejucomo> I have a strong hypothesis what the problem is, but I want to expose it with argument checks and unit tests.
08:32:37 <quicksilver> nejucomo: that's how I generally debug haskell programs
08:32:45 <quicksilver> in ghci by calling functions with various arguments
08:32:49 <quicksilver> narrowing in on a test case
08:34:54 <matthew_-> whereas I just tend to break GHC
08:35:06 <matthew_-> but each to their own...
08:41:20 <sw17ch> quicksilver, if it weren't for ghci, i never would have been able to learn haskell. it's *essential* to debugging
08:42:40 <quicksilver> sw17ch: I find it much more useful that your typical imperative GUI debugger
08:42:48 <quicksilver> but, it does depend somewhat from program to program
08:42:52 <quicksilver> and there are techniques to learn
08:42:57 <Cale> dcoutts_: yeah, it's only the associativity I want to change, not the precedence or anything
08:43:23 <sw17ch> quicksilver, yes... i always find it most helpful to open a module with ghci, use :edit to work on it, :reload, and test my functions
08:43:50 <sw17ch> or i have the editor in one window, ghci in the other, both with the same module loaded
08:43:55 <sw17ch> it *really* helps
08:44:16 <dcoutts_> Cale: btw, independently of that, what about ! as a left assoc strict apply?
08:44:22 <dcoutts_> Cale: f !x !y !z
08:45:18 <desegnis> Btw, talking about debugging in ghci: It's somehow uncomfortable that you always need to create an executable by hand when you do profiling. A ghci command that compiles an expression behind the scenes and gives profiling output would really be nice
08:45:36 <Cale> I think that's fairly reasonable apart from the fact that the array and map libraries would need to be changed.
08:45:54 * dcoutts_ didn't realise Map used it too
08:46:15 <quicksilver> desegnis: agreed.
08:46:44 <quicksilver> dcoutts_: do you prefer that to $! ?
08:46:51 <quicksilver> or do I misunderstand?
08:47:07 <dcoutts_> quicksilver: I'd keep $ and $! with the same assoc as now, not change them at all
08:47:14 <quicksilver> ah.
08:47:16 <quicksilver> I wouldn't.
08:47:23 <quicksilver> they serve no purpose. In the bin.
08:47:23 <quicksilver> :)
08:47:26 <dcoutts_> quicksilver: but I'd add ! as: f ! x = x `seq` f x
08:47:47 <dcoutts_> with infixl !
08:47:53 <Cale> It seems a bit troubling to have a lot of the good operator symbols go toward simple variations on function application.
08:48:10 <dcoutts_> it is a functional language ;-)
08:48:19 <Cale> (especially if they're only going to differ in associativity)
08:48:23 <dcoutts_> Cale: we already use ! to mean a strictness annotation
08:48:33 <dcoutts_> in data types and patterns
08:48:37 <dcoutts_> and in $!
08:48:44 <DukeDave> Hey gang, what's the name of that set of 'programming challenges' which gets mentioned with high frequency?
08:48:50 <Cale> That's true, but I'd probably at least want to remove $! if we were going to include ! for that.
08:48:54 <pjd_> Cale: overloaded application syntax!
08:49:11 <Cale> DukeDave: The Euler problems?
08:49:22 <ziman> DukeDave, Project Euler
08:49:25 <dcoutts_> Cale: sure if you were switching the assoc of $ then $! would not be needed as well as !
08:49:35 <dcoutts_> Cale: but I'd advocate leaving $ and $! as is
08:49:40 <DukeDave> Cale: ziman: Perfect! :)
08:49:54 <DukeDave> Google has nothing on #haskell :)
08:50:12 <Cale> dcoutts_: Solely for backwards compatibility?
08:50:12 <dcoutts_> Cale: $! is not really all that nice, it does have the wrong assoc imho, even though I think $ has the right assoc
08:50:43 <dcoutts_> Cale: if we added ! I would not argue for keeping $!, but it's not that expensive to keep it
08:51:51 <quicksilver> given that haskell parsers exist, it's trivial to write a program which fixes all code which uses $ wrongly.
08:52:02 <quicksilver> So I say we fix the standard, fix the code, and put the mess behind us.
08:52:03 <quicksilver> :)
08:52:52 <dcoutts_> Cale: actually, ! on it's own would not be all that helpful without an ordinary left assoc application
08:53:04 <dcoutts_> f !x y would not work
08:53:05 <Cale> dcoutts_: mm... yeah
08:53:17 <dcoutts_> f !x `leftAssocApply` y
08:53:23 <Cale> hehe
08:53:39 <Cale> That's the enterprise version.
08:54:00 <dcoutts_> it might confuse people that you can write f x !y but not f !x y
08:54:12 <quicksilver> yes
08:54:29 <quicksilver> s/might/would/
08:54:30 <quicksilver> ;)
08:54:43 <ertai> @src foldl1
08:54:43 <lambdabot> foldl1 f (x:xs) = foldl f x xs
08:54:43 <lambdabot> foldl1 _ []     = undefined
08:55:21 <ertai> @src foldr1
08:55:22 <lambdabot> foldr1 _ [x]    = x
08:55:22 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
08:55:22 <lambdabot> foldr1 _ []     = undefined
08:55:56 <dcoutts_> JaffaCake: I think we might have found the best bikeshed yet with this $/$! issue :-)
08:56:34 <dcoutts_> nominolo: ping
08:56:49 <bos> gug
08:56:59 <dcoutts_> nominolo: I've got a bug for you, I think it was introduced recently with your configurations resolution changes
08:57:25 <bos> @seen cosmicray
08:57:25 <lambdabot> cosmicray is in #haskell-blah, #darcs and #haskell. I don't know when cosmicray last spoke.
08:58:28 <nominolo> dcoutts_: which one?
08:58:28 <lambdabot> nominolo: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:59:01 <dcoutts_> nominolo: when I configure cabal-install, it picks the wrong value for the bytestring-in-base flag
08:59:06 <JaffaCake> morning dcoutts_ :)
08:59:06 <lambdabot> JaffaCake: You have 1 new message. '/msg lambdabot @messages' to read it.
08:59:19 <dcoutts_> g'afternoon JaffaCake :-)
09:00:30 <nominolo> dcoutts_: i'll take a look
09:00:55 <dcoutts_> nominolo: configure with -v, it looks to me like it's ignoring the second condition in the .cabal file completely
09:01:26 <dcoutts_> nominolo: the second condition puts different constraints on base, but neither show up in the configure -v output
09:01:40 <nominolo> dcoutts_: time to resurrect the test suite ...
09:01:52 <dcoutts_> nominolo: sigh, yes.
09:02:34 <dcoutts_> nominolo: it's been moved to tests/UnitTest/Distribution/PackageDescription/Configuration.hs
09:02:58 <JaffaCake> dcoutts_: the point I was making about renaming was that we'd like to re-use the name runProcess for what is now called rawSystem, I think
09:03:09 <JaffaCake> hence breaking the API
09:03:31 <dcoutts_> JaffaCake: oh, because we already have a runProcess
09:03:37 <JaffaCake> right
09:04:16 <JaffaCake> maybe we should try to come up with a consistent naming scheme that doesn't overlap with the existing names, and then deprecate the existing ones
09:04:41 <dcoutts_> JaffaCake: mm, though some of the existing ones are fairly good
09:04:48 <JaffaCake> yup, that's the problem
09:06:30 <quicksilver> if we had really good refactoring tools available then when we broke the API we could provide a script to patch people's source
09:06:37 <quicksilver> this might make us feel less bad about breaking the API
09:06:40 <quicksilver> when it's important to do so.
09:07:11 <CosmicRay> bos: hi
09:08:04 <Cale> JaffaCake: I remember you wrote a nice strict readFile at one point, which actually read the file into a buffer and lazily converted it into a list. That should probably be in the libraries :)
09:08:13 <Cale> (at least in GHC)
09:08:14 <DRMacIver> dons: Heh. I only just noticed you redditted my silly monadic card shuffling post. Was it actually interesting? It was just intended as something that made me go "Oh, that's a cute way of looking at it"
09:08:52 <JaffaCake> Cale: yes, I vaguely remember that, but I don't remember where it was, maybe just an email
09:08:53 <dcoutts_> Cale: something like B.unpack <$> B.readfile f
09:09:09 <damg> DRMacIver: : e.g. how to shuffle cards by throwing them into the air :)
09:09:17 <Cale> JaffaCake: Yeah, it was on the mailing list.
09:09:21 <JaffaCake> right, I bet it's easier with bytestring nowadays
09:09:30 <dcoutts_> B.unpack <$> B.readfile f
09:09:45 <Cale> dcoutts_: Yeah, that's the idea -- it was pre-bytestring that I remember the code being written.
09:09:58 <DRMacIver> damg: Right. :)
09:10:07 <Syzygy-> DRMacIver: It contains the word "Monad"? How can you expect it to avoid redditting?
09:10:10 <damg> I found it really interesting
09:11:02 <Cale> http://www.mail-archive.com/haskell@haskell.org/msg16951.html
09:11:02 <lambdabot> Title: RE: [Haskell] Files and lazyness
09:11:12 <DRMacIver> Syzygy-: Heh. True
09:12:36 <dcoutts_> Cale: I think what we'd really like is for the OS to provide a mmap mode that gives us a COW snapshot of a file, but not just COW to writes that we make, but COW to writes that other processes make, so we really can get a immutable snapshot of a file
09:12:43 <JaffaCake> what about using @ for left-associative application?
09:13:04 <JaffaCake> it's not currently allowed as an operator, but I think we might be able to fix that
09:13:13 <DRMacIver> damg: Thanks
09:13:43 <dcoutts_> JaffaCake: f !z @y
09:13:50 <JaffaCake> right
09:13:59 <JaffaCake> I like the idea of using ! for strict application too
09:14:06 <Igloo> dcoutts_: Are ! and @ supposed to be normal operators there?
09:14:11 <quicksilver> Igloo: yes
09:14:12 <Igloo> You're writing your expressions very oddly if so
09:14:20 <dcoutts_> JaffaCake: or ~ for non-strict apply? ;-)
09:14:22 <quicksilver> I'm not sure I like the way dcoutts_ writes it
09:14:31 <quicksilver> because it encourages people to view ! and @ as 'something special'
09:14:35 <Igloo> Yeah
09:14:36 <dcoutts_> quicksilver: you want balanced whitespace
09:14:39 <quicksilver> if they know that they are just normal operators
09:14:51 <quicksilver> they will understand that the same parsing applies as for normal operators
09:14:52 <Igloo> The way dcoutts writes it I'd expect   f !x y   to work
09:14:53 <quicksilver> e.g.
09:14:58 <quicksilver> f !x y @z
09:15:05 <dcoutts_> Igloo: right, which is the problem
09:15:18 <Igloo> dcoutts_: What is the problem, exactly?
09:15:20 <quicksilver> would of course be f ! (x y) @ z
09:15:31 <quicksilver> so I'd rather write it with balanced whitespace
09:15:33 <dcoutts_> Igloo: well that it will not work :-)
09:15:45 <dcoutts_> ! would have to have higher precedence than function application
09:15:51 <dcoutts_> infixl 11 !  :-)
09:16:08 <Igloo> Well I'd expect   f x !y z   to work too, if you're going to write it that way
09:16:39 <quicksilver> haskell is a much better language
09:16:43 <quicksilver> it's infixls go up to 11!
09:16:55 <JaffaCake> hmm, it would be strange that f !x y works when defining a function, but associates differently in expressions
09:17:05 <quicksilver> ++ on that, too.
09:17:22 <Cale> I think the best thing is just to fix $ and $! myself. It seems awkward to have both the left and right associative variants of these things.
09:17:22 <quicksilver> consistency is good. Even if it stops us getting the very neatest syntax tricks.
09:17:22 <Igloo> JaffaCake: So are you proposing that ! is treated specially in the lexical syntax?
09:17:28 <dcoutts_> JaffaCake: aye, we'd need ! to have equal precedence to function application ie 10
09:17:31 <JaffaCake> no, I'm backing off from using ! at all
09:17:39 <Igloo> Well, I guess it already is for patterns
09:17:55 <ddarius> Igloo: ?
09:18:03 <Cale> (especially as it's the associativity we're talking about and not precedence)
09:18:07 <Igloo> JaffaCake: So rejecting BangPatterns too?
09:18:13 <JaffaCake> ! is a prefix operator in patterns, it would have to be in expressions too
09:18:13 <Igloo> ddarius: With BangPatterns, I mean
09:18:25 * dcoutts_ loves bang patterns
09:18:50 <mauke> while we're talking about prefix operators, can we get rid of unary - ?
09:18:51 <Igloo> Hmm, if we required spaces around infix operators then we could have prefix and postfix operators
09:18:55 <JaffaCake> Igloo: no, I'm not proposing to reject bang patterns
09:19:11 <wjt> folks who like ghc bugs: I can hit the same error as http://hackage.haskell.org/trac/ghc/ticket/2164 on x86_32, with a different application.  would it be more useful for me to cut my code down to a minimal example, or to try the zmachine stuff?
09:19:14 <lambdabot> Title: #2164 (zmachine: internal error: task 0xa031e0: main thread 1 has been GC'd) - G ...
09:19:27 <dcoutts_> Igloo: can't we have them anyway? what has whitespace got to do with it?
09:19:38 <dcoutts_> Igloo: the only problem is having a single operator as both
09:19:57 <Igloo> dcoutts_: Well, it would make it a lot easier to parse
09:19:58 <wjt> more useful to folks who might want to fix it, that is:)
09:20:02 <dcoutts_> Igloo: I wrote a compiler once with prefix, postfix and infix operators
09:20:10 <dcoutts_> Igloo: but perhaps you mean easier for a human to parse
09:21:28 <dcoutts_> prolog has had prefix, postix and infix for years as well as other combos like [| |] 'operators'
09:22:18 <dcoutts_> @seen dons
09:22:28 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc and #haskell. I last heard dons speak 11h 10m 2s ago.
09:22:32 <quicksilver> outfix!
09:22:37 <quicksilver> or bra-ket-fix
09:22:45 <Cale> heh
09:23:04 <dcoutts_> @tell dons we should to revisit the strictness of B.unpack, I think it's too strict
09:23:04 <lambdabot> Consider it noted.
09:23:13 <quicksilver> custom brackets are cool
09:23:27 <quicksilver> btu I am quite fond of the relative simplicity of haskell's operator rules
09:23:27 <Saizan_> agda has even trifix(?)! e.g. you can define if_then_else_
09:23:45 <Arnar_> hey folks
09:23:58 <Igloo> dcoutts_: Certainly with local fixity declarations it's fiddly to do
09:24:13 <desegnis> You're quick from trifix to n-mixfix
09:24:30 <vincenz> bos: ping
09:24:31 <dcoutts_> quicksilver: great for defining semantic interpretations: [| a + b |]env = ...
09:24:33 <desegnis> But then try to remember fixity rules
09:24:46 <quicksilver> dcoutts_: definitely.
09:24:51 <vincenz> dcoutts_: Oh is that the quasiqutations thing?
09:24:59 <Arnar_> I have one quick question: i'm implementing an algorithm that requires both a hash-table and a priority queue - now, since I'll be using a mutable hash-table inside an IO monad anyways, will it be much better (performance wise) to use a priority queue based on mutable ds rather than a pure functional one?
09:25:09 <ddarius> quicksilver: See OBJ3
09:25:48 <dcoutts_> vincenz: no, I was just imagining custom bracket functions as nice syntax for interpreters etc. As it happens that is the syntax for TH quasiquotes atm.
09:25:51 <Cale> Arnar_: Uh, which hashtable implementation are you using? I sure hope you're not thinking of using Data.HashTable. :)
09:26:07 <vincenz> dcoutts_: you could get there for 90% with quasiquotations :)
09:26:09 <Arnar_> Cale: well.. until now I was o_O
09:26:10 <Arnar_> :)
09:26:16 <vincenz> eval [| a + b |] env  = ...
09:26:17 <Arnar_> Cale: what are my choices?
09:26:31 <bos> vincenz: pong
09:26:42 <vincenz> bos: how do you the comment/paragraph thing on the book?
09:26:51 <vincenz> bos: what system do you use for that?
09:26:56 <dcoutts_> nominolo: been able to reproduce the problem?
09:27:02 <desegnis> vincenz: I think dcoutts_ actually meant [| a :+ b |] env = ...
09:27:05 <Cale> Arnar_: I'd usually go with Data.Map myself. But if you feel that you really need a hashtable...
09:27:05 <dcoutts_> nominolo: want help tracking it down?
09:27:15 <vincenz> desegnis: I think not
09:27:16 <dcoutts_> desegnis: mm I guess so
09:27:17 <Arnar_> Cale: maybe not..
09:27:24 <bos> vincenz: i built it myself.
09:27:34 <vincenz> bos: is it open sourced?
09:27:42 <Arnar_> Cale: shouldn't be to hard just to try it first with Data.Map and measure, right?
09:27:47 <Cale> Arnar_: Data.Map beats Data.HashTable for all sizes where they can be compared, and is more scalable.
09:27:49 <dcoutts_> desegnis: [| |] :: Exp -> Env -> Value
09:27:51 <bos> vincenz: not yet. i'm a bit busy finishing the book.
09:27:52 <desegnis> vincenz: on the other hand, quasiquoting is really cool in the context of writing eval functions
09:27:58 <Cale> Arnar_: Plus Data.Map has a pure interface :)
09:28:01 <vincenz> desegnis: yeah :)
09:28:04 <vincenz> dcoutts_: just add a functoin
09:28:12 <vincenz> dcoutts_: eval :: Ast -> Env -> Value
09:28:14 <desegnis> dcoutts_, right, that's how I understood it
09:28:14 <Cale> (and a pure implementation even)
09:28:18 <dcoutts_> vincenz: of course, it's just syntax
09:28:21 <vincenz> dcoutts_: and use quasiquotes to generate patterns for those :)
09:28:32 <vincenz> bos: it's very spiffy
09:28:43 <Cale> Arnar_: The theoretical downside is that lookups are O(log n) time, but in practice, this is the same as constant time.
09:29:19 <Arnar_> Cale: ok, excellent.. I'll give Data.Map a go and stick with the (pure) pqueue I found online
09:29:21 <quicksilver> Arnar_: meanwhile Data.Seq give you a pure queue
09:29:26 <Arnar_> ok
09:29:29 <quicksilver> Arnar_: oh, sorry. priority queue
09:29:30 <bos> vincenz: thanks. it was pretty quick to implement.
09:29:31 <quicksilver> that's not the same :)
09:29:45 <vincenz> bos: what's the input for it?
09:29:45 <Arnar_> Cale++
09:29:46 <quicksilver> Arnar_: my gut feeling is always start pure and measure.
09:29:47 <quicksilver> :)
09:29:51 <vincenz> bos: and what's it written, haskell I presume?
09:29:55 <mauke> well, you can use Data.Map as a priority queue :-)
09:29:58 <Cale> It's silly that we *don't* have a finger tree based priority queue in the libraries.
09:29:58 <Arnar_> quicksilver: sounds like a goot plan :)
09:30:00 <vincenz> s/,/ in,/
09:30:17 <Arnar_> mauke: hmm.. how so?
09:30:27 <Cale> Finger trees can be used to implement all sorts of nice data structures, and that seems to have been missed.
09:30:28 <Arnar_> I know keys are ordered.. but I would need a multi-map, right?
09:30:47 <mauke> Arnar_: just use lists as values
09:31:02 <quicksilver> Cale: the generalised trie SoC project got accepted.
09:31:10 <Arnar_> mauke: ah, right
09:31:11 <quicksilver> Cale: maybe that will help.
09:32:24 <bos> vincenz: it's actually django (python), mysql, and jquery
09:33:06 <bos> vincenz: django has a few features that make it easier to use than putting something together in haskell right now, given the current state of server-side web code.
09:33:35 * vincenz nods
09:33:42 <vincenz> bos: and what does the book input consist of then?
09:33:45 <nominolo> dcoutts_: what are the expected flag assignements?
09:33:56 <quicksilver> Cale: I know it's not the same thing but still :)
09:33:57 <bos> vincenz: docbook xml.
09:34:02 <vincenz> oicc
09:34:35 <dcoutts_> nominolo: for ghc-6.8.2, we have base-3, so we expect bytestring-in-base to be false
09:34:45 <nominolo> that's what i get
09:34:54 <nominolo> well, with "cabal configure"
09:35:01 <dcoutts_> nominolo: hmm, I get: Flags chosen: bytestring-in-base=True, old-base=False
09:35:18 <dcoutts_> nominolo: what cabal lib version are you using?
09:35:26 <dcoutts_> which darcs repo?
09:35:32 <dcoutts_> and when did you last pull?
09:35:56 <nominolo> dcoutts_: i had to use runhaskell Setup.hs to reproduce
09:37:19 * dcoutts_ checks again
09:38:42 <vincenz> bos: spiffy :)
09:49:04 <gwern> I'm kind of curious - does anyone have profiled binaries? do they dump out empty foo.prof files on every run, even minus any +RTS options?
09:52:34 <dcoutts_> nominolo: I can reproduce it with Cabal-1.5.1 and 1.3.10, both very latest darcs versions
09:52:44 <Igloo> gwern: Yes
09:53:55 <gwern> Igloo: I see. is there any particular reason for such an annoying behaivour?
09:54:32 <Igloo> I don't know what the rationale is, but it makes sense to me as a measure to stop people getting confused when they forget to use +RTS -p
09:54:58 <JaffaCake> I don't think it's intentional
09:56:36 <dcoutts_> nominolo: http://hpaste.org/7131
09:56:49 <gwern> Igloo: maybe, but it bugs me to no end since i need profiled darcs but I also need to use it a lot
09:57:00 <gwern> so all over my hard drive are these empty 'darcs.prof'...
09:57:32 <nominolo> dcoutts_: i'll try to track it down later today
09:57:42 <dcoutts_> nominolo: thanks
09:57:56 <dcoutts_> nominolo: ping me if you want us to look at it together
10:06:16 <pioj1> hello. Is there a way to write "stop if this boolean expression is true" in monadic code? I wrote "if myFunc then fail "bad input" else Just 1", but the "else Just 1" is just throwaway code
10:06:30 <pioj1> there must be a simpler, more idiomatic way to write this
10:07:32 <bos> pioj1: "when"
10:07:38 <mauke> when myFunc $ fail "BAD"
10:07:40 <bos> pioj1: also "unless"
10:07:57 <bd_> mauke: myFunc can't be monadic there
10:07:57 <Vulpyne> That's not actually a fail though. That's if myFunc then stuff else return ()
10:08:05 <bd_> oh, nevermind, it isn't
10:08:13 <bd_> guard myFunc -- if you don't care about a useful message
10:08:35 <pioj1> thank you all--these are exactly the answers i was looking for--i'll start using all of these :)
10:09:05 <bd_> pioj1: depending on what you're doing, you might also find ContT useful
10:09:46 <pioj1> i'm just playing with an example from a book, now. but i'll read about ContT. thanks
10:10:27 <Vulpyne> maybe (fail "ohnoes") (return . Just) Nothing
10:10:37 <Vulpyne> maybe (fail "ohnoes") (return . Just) (Just 1)
10:10:41 <Botje> :t fail
10:10:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
10:10:58 <pioj1> but i don't really need the "Just 1", so guard is the best solution, I think
10:11:03 <Botje> i remember there being some noises about changing the type of fail
10:11:29 <Botje> why is the current type "wrong" ?
10:12:13 <mauke> because it's in Monad
10:12:35 <bos> it was more along the lines of nuking fail entirely.
10:12:43 <bos> however, that's not likely to happen.
10:13:28 <Botje> why nuke fail? is mempty better?
10:13:29 <bd_> if fail was nuked, what would a failed pattern match in a monad do? Just result in the bottom as an action?
10:13:43 <mauke> bd_: not compile
10:13:57 <Botje> @src catMaybes
10:13:57 <bd_> so, you couldn't do [a] <- someFoo, then?
10:13:58 <lambdabot> catMaybes ls = [x | Just x <- ls]
10:13:59 <mauke> or rather, use mzero
10:14:08 <Botje> so catMaybes would have to change?
10:14:17 <bd_> Botje: List has mempty...
10:14:19 <mauke> no, Maybe is an instance of MonadZero
10:14:24 <mauke> er, []
10:14:39 <Botje> makes sense.
10:14:47 <Botje> thanks :)
10:17:43 <paczesiowa> dons: shouldn't System.Plugins.load return nice error message inside LoadStatus in case of missing include dirs? now it justs errors out with cryptic "Main: Loaded.o: unknown symbol `Dependancy_Type_con_info'\nMainr: user error (resolvedObjs failed.)"
10:20:46 <saml> how can I handle exceptions thrown by error "blah blah" ?
10:21:13 <mauke> terrible!
10:22:05 <elliottt> saml: i think Control.Exception.catch will catch it
10:22:26 <elliottt> you can only catch it from IO, though
10:23:32 <saml> thanks elliottt
10:23:37 <elliottt> :)
10:27:18 <lament> oh god, RWH has "Will the real state monad please stand up?" as a chapter heading
10:27:49 <bos> sometimes you just have to say that.
10:28:50 <shepheb> as long as there isn't "I can has lazy ByteStrings?" or something.
10:29:01 <dons> you can has them though!
10:29:02 <lambdabot> dons: You have 8 new messages. '/msg lambdabot @messages' to read them.
10:29:03 <bos> we wouldn't debase ourselves that far.
10:29:12 <dons> no lolcode implementation chapter?
10:29:19 <dons> ok, maybe an appendix for that
10:30:23 <dcoutts_> dons: kolmodin and I considered implementing lolcode in the small step semantics style
10:30:35 <dons> heh
10:30:36 <dcoutts_> including how to simulate lolcode io purely
10:30:44 <dcoutts_> simulate/model
10:30:55 <dcoutts_> eg continuations or stream style io
10:31:08 <dcoutts_> dons: so, I mentioned that our unpack is too strict I think
10:31:09 <mauke> preflex: remember dcoutts kolmodin and I considered implementing lolcode in the small step semantics style, including how to simulate lolcode io purely
10:31:12 <dons> this sounds like a good ICFP paper
10:31:20 <dons> not enough lolcode research has been done
10:31:27 <lament> definitely not enough
10:31:29 <dcoutts_> it's a pretty trivial language actually
10:31:38 <lament> er... duh?
10:31:41 <dcoutts_> would make a nice toy example for a prog lang class
10:32:23 <dcoutts_> dons: eg unpack <$> readFile "foo"
10:32:25 <shepheb> would've beat the hell out of the ugly minimal C-like thing I did my compilers class with.
10:32:26 <dons> oh, the new chapter announcements must be on the reddit front page.
10:32:31 <dons> silly comments landing
10:32:53 <dons> dcoutts_: that's a fun idea, actually. implementing lolcode as an assignment
10:32:56 <Cale> dons: Did you see that paper which alpheccar recently reddited?
10:32:57 <dcoutts_> dons: we want that to read the file strictly then unpack lazily, so we get the space advantage but get the strict IO
10:33:01 <dons> more fun than TinyJava
10:33:03 <dcoutts_> dons: aye :-)
10:33:13 <dons> Cale: i saw the title
10:33:32 <dons> Cale: the analytic functors one?
10:33:35 <Cale> Combinatorial Species are almost certainly the future of algebraic datatypes. It's a rather fun paper -- though it looks a bit in need of minor edits :)
10:33:50 <dcoutts_> dons: [| HAI body KTNXBYE |] evn -> ...
10:33:56 <dcoutts_> evn/env
10:33:57 <paczesiowa> dons: shouldn't System.Plugins.load return nice error message inside LoadStatus in case of missing include dirs? now it just errors out with cryptic "Main: Loaded.o: unknown symbol `Dependancy_Type_con_info'\nMain: user error (resolvedObjs failed.)"
10:34:13 <dons> paczesiowa: possibly
10:34:15 <Cale> (There are spelling errors here and there, but the basic ideas are solid)
10:34:42 <bos> and who wouldn't want to try out combinatorial acts with http://www.imdb.com/media/rm3485243648/tt0114508 ?
10:34:43 <lambdabot> Title: Photos from Species
10:35:05 <dcoutts_> dons: so currently unpack is fully strict, it makes a big list. I suggest we make it semi-strict, it should build chunks of lists a few k each go
10:35:26 <Cale> Look how simple it is to define connected simple graphs in that language!
10:35:35 <Cale> (Page 8)
10:35:44 <dons> dcoutts_: hmm, seems reasonable
10:35:49 <dons> i don't know how common unpack is now.
10:35:59 <dons> bos, heh.
10:36:07 <dcoutts_> dons: pretty common I think, no?
10:37:58 <dons> goodbye, MR.
10:38:00 <dons> http://www.haskell.org/pipermail/haskell-prime/2008-April/002488.html
10:38:01 <Cale> The cool thing is that they point out that these very general operations actually lead to a nice immediate concrete representation as well.
10:38:06 <lambdabot> Title: The monomorphism restriction and monomorphic pattern bindings, http://tinyurl.com/6ncrhr
10:38:39 <Cale> (as they should -- they were invented by combinatorialists who care about things like that :)
10:38:46 <dons> hmm. sounds promising
10:38:51 <dons> i'll check the paper out in more detail
10:42:48 <Cale> They still have to work on the implementation for more powerful recursion, but the tools are available I think.
10:46:30 <Cale> Another really interesting thing they mention is that there are actually apparently algorithms for working out worst case and average case asymptotic complexity for functional programs written over species.
10:47:03 <lament> oooh the species thing is pretty interesting
10:47:36 <dcoutts_> JaffaCake: I think we're missing some arguments against changing $. We should include the original Haskell rationale for making $ right associative.
10:47:43 <dcoutts_> JaffaCake: in the wiki page
10:47:48 <lament> i was thinking recently about how the similarity between different datatypes with the same structure is not adequately reflected by haskell
10:48:09 <lament> which also leads to the abuse of, say, Either
10:48:27 <Cale> Being an algebraic combinatorics person, I knew it was only a matter of time before people started talking about this more -- especially since McBride's paper on differentiation of datatypes (which coincides perfectly with differentiation of species).
10:48:34 <lament> (which people use with labels "Left" and "Right" even though in every case there's something more meaningful)
10:49:04 <Cale> Well, there's also some need for a mechanism for generic programming.
10:49:24 <dons> ?users
10:49:25 <lambdabot> Maximum users seen in #haskell: 459, currently: 455 (99.1%), active: 11 (2.4%)
10:49:38 <Cale> Where you define functions inductively on the structure of the datatypes they're applied to.
10:50:28 <dcoutts_> Cale: another reason, suppose you've got <big expression>, with right assoc $ you can make f $ <big expression> and know that it'll work (even if the exp contains other $'s)
10:51:17 <dcoutts_> rather than having to go find the end of the expression and add ()'s around the whole thing
10:51:31 <Cale> dcoutts_: That's true, but you get used to just applying composition where appropriate.
10:51:49 <Cale> You should almost never have to add parens.
10:52:04 <dcoutts_> Cale: that assumes the thing starts with another function you can compose with
10:52:12 <Cale> Either the right thing is  f . <expr>  or  f $ <expr>
10:52:19 <dcoutts_> $ works whether the thing contains another $ or not
10:52:22 <dcoutts_> . doesn't
10:52:44 <dcoutts_> Cale: yes, exactly, you have to inspect it to see which is the right one
10:52:45 <Cale> I haven't found that to be a significant disadvantage in use.
10:53:12 <dcoutts_> Cale: and we don't necessarily have to want to inspect the thing, just apply a function to it
10:53:13 <Cale> (I've been using this style for maybe a year now.)
10:53:36 <Cale> I suppose it matters if you're automatically constructing programs :)
10:53:51 <lament> heh
10:53:55 <Cale> (but then, probably just using parens in that case is more appropriate :)
10:54:04 <dcoutts_> Cale: I also use f . g $ x rathe than f $ g $ x, but $ is still useful for the case I mentioned
10:54:39 <Cale> Yeah, I'll admit it's a limitation that you have to look at the code a bit more carefully.
10:55:48 <MyCatVerbs> Hrmn. What's the usual procedure for dealing with a stack overflow when you have no idea where the infinite loop occurred?
10:56:08 <mauke> profiling and/or ghci debugger
10:56:15 <dcoutts_> MyCatVerbs: ghci -fbreak-on-exception :trace
10:56:21 <MyCatVerbs> Thanks.
10:56:29 <MyCatVerbs> mauke: the profiler can find these? Nice.
10:58:26 <Cale> Stack overflows are usually not infinite loops.
10:59:04 <Cale> In Haskell, the stack reflects the distance from the currently evaluated expression to the shallowest reducible subexpression in it.
10:59:10 <MyCatVerbs> Cale: I don't have any long folds here, though.
10:59:23 <MyCatVerbs> Cale: what I'm working on right now is a Parsec parser.
10:59:24 <Cale> You might have recursion though?
10:59:42 <Cale> You might still be building up a large unevaluated expression somehow.
10:59:44 <MyCatVerbs> (I don't *think* there are any right-recursions left in here by mistake...)
10:59:51 <MyCatVerbs> Yarr, but I have no idea how.
11:00:24 <Bonus> [1..n] ++ [1..m] has a complexity of O(n) rite?
11:00:31 <bos> yes
11:00:51 <Cale> Left-recursions, you mean
11:01:02 <MyCatVerbs> Cale: er, yes, sorry.
11:01:29 <Cale> Bonus: right, or O(max(n,k)), where k is the number of elements of the resulting list that you use.
11:01:34 <Cale> er
11:01:37 <Cale> min(n,k)
11:02:07 <Bonus> aah
11:03:15 <EvilTerran> because of laziness
11:03:27 <Bonus> haskell is da bomb
11:05:21 <Apocalisp> lambda of da bomb
11:10:33 <Cale> @src (++)
11:10:33 <lambdabot> (++) []     ys = ys
11:10:33 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
11:10:41 <Cale> Sigh.
11:10:55 <Cale> Oh well, I suppose that will do :)
11:11:01 <dcoutts_> Cale: what were you expecting?
11:11:10 <Cale> I was expecting infix definitions.
11:11:14 <dcoutts_> ah
11:11:28 <dcoutts_> @src ++
11:11:28 <lambdabot> (++) []     ys = ys
11:11:28 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
11:11:39 <dcoutts_> worth a try :-)
11:11:43 <Cale> yeah :)
11:12:31 <Cale> lambdabot: @quit
11:12:38 <Cale> @src (++)
11:12:47 <lambdabot> []     ++ ys = ys
11:12:53 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
11:13:31 <dons> the community response to the RWH book is just amazing.
11:14:20 <dejones> dons: I have to say that the peer reviewed book by the community is just awesome and no doubt greatly increases the quality of the book.  :)
11:14:37 <tromp> shldnt (++) be written as a foldr?
11:14:42 <Cale> Bonus: So you can see there that in the case where xs is empty, xs ++ ys reduces immediately to ys, so that's constant time. In the case where xs is nonempty, xs ++ ys immediately reduces to a constructor (:) applied to some parameters which may or may not be evaluated. So in a sense, that's also O(1)
11:14:48 <dons> I hope so, yes. It's kind of scary to think about what happens once the presses start rolling
11:15:02 <dons> more eyes on the text before that date, the better!
11:15:08 <Cale> tromp: I'll include it as an alternate definition :)
11:15:12 <Bonus> aha
11:15:15 <Bonus> so its not that simple eh
11:15:16 <Bonus> hehe
11:15:17 <Bonus> cool
11:15:55 <tromp> @let cat = \x y -> foldr (:) y x
11:15:57 <lambdabot> Defined.
11:16:05 <Cale> Bonus: But one of the expressions that (:) is applied to contains another (++) call, so if you count that call as well, then it'll take length xs + 1 steps to completely reduce the (++)'s away
11:16:09 <tromp> > cat "hello, " "world"
11:16:11 <lambdabot> Terminated
11:16:26 <Cale> :t cat
11:16:27 <lambdabot>     Ambiguous occurrence `cat'
11:16:27 <lambdabot>     It could refer to either `L.cat', defined at <local>:3:0
11:16:27 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.cat', imported from Text.PrettyPrint.HughesPJ at State/imports.h:67:0-46
11:16:31 <Cale> aha
11:16:33 <dejones> dons: I even find the comments teach me something additional about Haskell.  :)
11:16:35 <tromp> > L.cat "hello, " "world"
11:16:36 <Bonus> hmmm
11:16:36 <lambdabot>  "hello, world"
11:16:40 <Cale> @undef
11:16:41 <lambdabot> Undefined.
11:17:18 <tromp> > cat "hello, " "world"
11:17:20 <lambdabot>  Couldn't match expected type `Doc' against inferred type `Char'
11:17:22 <gwern> Igloo: I filed a ghc bug report about the empty .prof files, if you care
11:17:31 <Cale> @src (++)
11:17:31 <lambdabot> []     ++ ys = ys
11:17:31 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
11:17:37 <Cale> lambdabot: @quit
11:17:41 <Cale> @src (++)
11:17:47 <lambdabot> []     ++ ys = ys
11:17:54 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
11:18:02 <Cale> hehe, always slow for the first few seconds as it joins all its channels :)
11:18:03 <lambdabot> Plugin `source' failed with: thread killed
11:18:14 <Cale> Let's try that again...
11:18:15 <Cale> @src (++)
11:18:21 <lambdabot> []     ++ ys = ys
11:18:26 <Bonus> hmm
11:18:27 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
11:18:30 <Bonus> there
11:18:33 <byorgey> go, lambdabot, go!
11:18:37 <lambdabot> Plugin `source' failed with: thread killed
11:18:40 <byorgey> awww
11:18:41 <Cale> ouch
11:18:51 <Cale> @src (++)
11:18:55 <lambdabot> []     ++ ys = ys
11:19:01 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
11:19:02 <Cale> One more try before I start to get angry :)
11:19:12 <lambdabot> Plugin `source' failed with: thread killed
11:19:14 <Cale> huh
11:19:31 <mrd> @yarr
11:19:37 <lambdabot> I want me grog!
11:19:42 <Cale> well, at least it works in the local lambdabot
11:19:47 <Cale> I added:
11:19:51 <Cale> -- OR
11:19:52 <Cale> xs ++ ys = foldr (:) ys xs
11:23:20 <gwern> A question: suppose you say a package named 'darcs-cabal'. what do you think that is?
11:23:25 <tromp> or (++) = flip (foldr (:))
11:24:02 <tromp> > foldr (:) " bar" "foo"
11:24:03 <lambdabot>  "foo bar"
11:24:05 <dcoutts_> gwern: Frankenstein's monster
11:24:23 <dcoutts_> gwern: what do you think it is?
11:24:27 <gwern> dcoutts_: har har. srsly tho
11:25:19 <gwern> dcoutts_: I'm going to upload to hackage an unofficial darcs tarball; to preventively mollify dr. roundy, I need to name it something other than just 'darcs'
11:25:20 <dcoutts_> gwern: dunno, knowing what you've been up to recently I'd say its a darcs app built using cabal, but without knowing that it could be many things
11:25:46 <dcoutts_> gwern: hmm, I think we should be careful before doing that
11:26:03 <Cale> Is it just me or is Ryan Ingram's complaint regarding STM really strange?
11:26:17 <dcoutts_> gwern: perhaps start by posting your darcs.cabal file to haskell-cafe and ask for feedback
11:26:27 <dcoutts_> gwern: I know you've submitted it to darcs-devel
11:26:28 <Cale> I don't understand how moving the condition to retry into the STM runtime will help.
11:26:46 <gwern> dcoutts_: hm? what would the point be of submitting it to -cafe?
11:27:06 * Cale wonders if Ryan is here :)
11:27:24 <dcoutts_> gwern: you can ask if people would find it useful, and they can test it for you
11:27:52 * dcoutts_ fixes the hackage over-zealousness that CosmicRay reported the other day...
11:28:02 <gwern> dcoutts_: it's only useable with darcs darcs, obviously. wouldn't most of those with darcs darcs and the inclination have already seen/tested it out on darcs-devel?
11:28:18 <CosmicRay> dcoutts: woohoo
11:28:19 <CosmicRay> thanks
11:28:26 <Cale> But I suppose it raises a point about just how expensive actually retrying a transaction is...
11:28:26 <dcoutts_> CosmicRay: I've gone for not complaining about the newer extensions that ghc-6.6's default cabal didn't grok
11:28:55 <CosmicRay> nice, that makes sense.
11:28:59 <dcoutts_> CosmicRay: though if you put cabal-version: >=1.2 then it will still complain about the newer ones
11:29:18 <dcoutts_> CosmicRay: on the basis that it's not going to work with 1.1.6 anyway
11:29:19 <dejones> dons: This may be a silly question... but what is "finger typing"?  It is from RWH: "Furthermore, because Haskell can infer the types of your expressions and functions, you gain the benefits of static typing without the added burden of âfinger typingâ imposed by less powerful statically typed languages."
11:29:41 <gwern> dejones: 'static int void main'
11:29:45 <opqdonut> dejones: finger typing is explicitly ... yeah
11:29:48 <CosmicRay> dcoutts: sounds like a good plan.
11:30:09 <Cale> dejones: The kind of typing that you do with your fingers :)
11:30:12 <dejones> gwern, opqdonut: hmm, never heard it called "finger typing."  lol
11:30:12 <dcoutts_> CosmicRay: btw, on the issue of just using strings for extensions, yeah, I don't mind. Cabal does need a list of valid ones though, at least valid at the time if only so we can pick up spelling mistakes :-)
11:30:31 <dejones> Cale: I usually think of it as "explicit typing" :P
11:30:38 <dcoutts_> CosmicRay: we can upgrade the list that hackage knows about fairly easily, either by recompiling or updating a data file
11:30:40 <CosmicRay> dcoutts: I think it was someone else that brought that up
11:30:52 <dcoutts_> CosmicRay: oh was it, ok :-)
11:30:52 <Cale> dejones: Well, the point is that 'typing' doesn't refer to the type system :)
11:31:11 <dcoutts_> CosmicRay: oh, yes, it was JohnMecham
11:31:13 <gwern> Cale: it's a pun dood
11:31:17 <dejones> ol
11:31:17 <dejones> lol
11:31:19 <gwern> a reasonably clever one
11:31:35 <dejones> yeah, just never really heard that pun
11:31:59 <dejones> and I thought it might be some technical term I was unaware of
11:32:00 <dejones> heh
11:32:05 <dejones> :P
11:32:12 <opqdonut> :P
11:33:40 <gwern> :P
11:33:43 <zgold> :p
11:33:49 <zgold> :P *Capslock was on*
11:33:51 <gwern> :q
11:33:56 <dejones> :Q
11:34:49 <opqdonut> :b
11:35:45 <zgold> > :P
11:35:46 <lambdabot>   parse error on input `:'
11:40:22 <CosmicRay> hrm, anybody know where I can look up <<loop>> in the run-time output of a haskell program?
11:40:26 <CosmicRay> I've never seen that before
11:40:45 <dcoutts_> CosmicRay: it's a kind of exception
11:40:56 <CosmicRay> dcoutts_: it sucks trying to google for it
11:40:59 <Cale> CosmicRay: That's what you get when a value which is currently evaluating ends up getting evaluated again.
11:41:12 <CosmicRay> crap.  that sounds messy.
11:41:17 <Cale> CosmicRay: For example,  let x = x + 1 in x
11:41:22 <mauke> > let x = x + 1 in x
11:41:29 <CosmicRay> is there any way to track that down?
11:41:37 <CosmicRay> make it print out what symbol is doing that or something?
11:41:38 <lambdabot>  thread killed
11:41:49 <dcoutts_> CosmicRay: http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#1
11:41:49 <lambdabot> http://tinyurl.com/yk8zqb
11:41:50 <mauke> > let x = x  in x
11:41:51 <Cale> (lambdabot might not catch that one, the <<loop>> mechanism has been slightly broken for the last couple GHC versions)
11:41:56 <mauke> :(
11:42:05 <lambdabot>  thread killed
11:42:10 <Cale> CosmicRay: You can use GHCi's debugger.
11:42:15 <dcoutts_> CosmicRay: you can try using the ghci debugger and get it to -fbreak-on-exceptions, use :trace
11:42:24 <CosmicRay> Cale: unfortunately, not likely.  this program involves both forking and threading.
11:42:26 <dcoutts_> CosmicRay: btw, have you tried the Cabal-1.4 and cabal-install pre-releases?
11:42:32 <CosmicRay> dcoutts: no, I haven't
11:42:48 <CosmicRay> dcoutts: it's enough for me to keep up with the releases ;-)
11:42:56 <dcoutts_> CosmicRay: they should answer all your recent Qs about hackage/cabal inconsistencies
11:42:57 <CosmicRay> dcoutts: but I do love cabal, btw.
11:43:10 <dcoutts_> :-)
11:43:20 <CosmicRay> you should see the horrible crap the ocaml folks were using.
11:43:21 <dcoutts_> CosmicRay: seems people love it or hate it :-)
11:43:22 <CosmicRay> (are?)
11:45:02 <CosmicRay> Cale: and to make things worse, adding debug statements is what caused <<loop>> to appear, rather than a hang.
11:45:03 <CosmicRay> sigh.
11:50:52 <sjanssen> CosmicRay: <<loop>> and hanging are the same, essentially
11:51:15 <sjanssen> wait, is it hanging or consuming CPU?
11:51:30 <CosmicRay> sjanssen: hanging.  no cpu consumption.
11:52:09 <Cale> CosmicRay: trace?
11:52:19 <CosmicRay> strace you mean?  or some other trace?
11:52:39 <Cale> CosmicRay: Debug.Trace.trace -- I was wondering if that's what you meant by "debug statements"
11:52:56 <CosmicRay> Cale: no, hPutStr stderr's
11:53:00 <Cale> ah
11:53:01 <CosmicRay> this is all in the io monad already
11:53:04 <Cale> okay
11:53:12 <ripplepay> substrings [] = []
11:53:13 <ripplepay> substrings (x:xs) = ( map (x:) $ inits xs ) ++ substrings xs
11:53:24 <ripplepay> algorithmic complexity is N squared right?
11:53:25 <CosmicRay> and is in complicated code that sets up pipelines and stuff too.  so having exacting control over I/O is important.
11:53:53 <Baughn> CosmicRay: Hang on. Pipelines?
11:54:10 <tromp> uhm, substrings "" should be [""]
11:54:41 <ripplepay> tromp: seems to work either way
11:54:44 <dons> Cale: this guy wants help, http://reddit.com/r/programming/info/6gsrx/comments/c03sw7u
11:54:45 <Cale> ripplepay: Hmm... yeah, I think that's right.
11:54:51 <CosmicRay> Baughn: yes, I'm trying to add new features to HSH
11:54:54 <Baughn> CosmicRay: As in, you're using subprocesses and wanting to feed.. ah
11:54:59 <Baughn> CosmicRay: Pipelines won't work. See http://hackage.haskell.org/trac/ghc/ticket/2220
11:55:02 <lambdabot> Title: #2220 (Subprocesses do not close open FDs) - GHC - Trac
11:55:18 <CosmicRay> Baughn: I am aware of this.  I reported it ;-)
11:55:24 <CosmicRay> Baughn: the stuff in System.Posix works
11:55:31 <CosmicRay> oh, I guess I didn't report that ticket
11:55:38 <CosmicRay> I reported it on the mailing list
11:55:50 <CosmicRay> oh there we go.  http://hackage.haskell.org/trac/ghc/ticket/1780
11:55:52 <lambdabot> Title: #1780 (runInteractiveProcess broken with >2 processes on POSIX) - GHC - Trac
11:55:54 <Baughn> CosmicRay: Still ain't fixed, though. I'm not sure what to do about it.. really, everything needs to be marked close-on-exec by default
11:56:10 <CosmicRay> Baughn: I give up on System.Process for anything complex.
11:56:22 <CosmicRay> Baughn: and just use System.Posix.Process and do it the low-level way
11:56:31 <Baughn> CosmicRay: It's not system.process; it's a general problem that happens in any language if you don't set FD_CLOEXEC. Are you doing that?
11:56:51 <CosmicRay> Baughn: no, but I keep track of what Fds need closing (the old-fashioned way)
11:57:03 <Baughn> I suppose that works, too
11:57:15 <CosmicRay> it is not quite the same result; but then somethimes that is not the desired result.
11:57:33 <CosmicRay> I close endpoints for pipes that aren't needed anymore.  stuff like that.
11:57:34 <Baughn> It'd be very easy to miss one, and a single open writer will prevent any EOF from ever occurring
11:58:15 <CosmicRay> oh I am quite well aware of this :-)
11:58:42 <Baughn> I suppose you would be. Alright, I'll let you get on with it
11:58:45 <CosmicRay> that is why you use HSH or something like it, and make stupid people like me write that complex code ;-)
11:58:48 <Baughn> People /keep stumbling into it/, though
11:58:57 <CosmicRay> that issue is not even Haskell-specific
11:59:05 <CosmicRay> I mean, it's hard to make pipelines work well in C too
11:59:34 <Jedai> :t fromIntegral
11:59:35 <lambdabot> forall a b. (Num b, Integral a) => a -> b
11:59:56 <Baughn> Me, I've got functions that (among other things) set all FDs to close on exec by default. If I want to keep them open I'll do something, not otherwise..
12:00:08 <CosmicRay> Baughn: that is a nice practice.
12:00:16 <CosmicRay> you can apply that to already-open fds?
12:00:26 <Baughn> Clear the bit? Of ocurse
12:00:41 <CosmicRay> what's the C call that does that?  is it a fcntl?
12:00:55 <Baughn> Yep
12:01:16 <Baughn> ..how /else/ would you do it? I've never noticed any open call that lets you set the bit, which can be troublesome
12:01:39 <CosmicRay> I guess I assumed it was an open() flag, but of course that doesn't make sense since it doesn't start with O_
12:01:49 <Baughn> It should have been
12:01:56 <Baughn> Moreover, it should have been the default. Oh well.
12:02:03 <CosmicRay> ah, linus added O_CLOEXEC to open(2) in 2.6.23
12:02:06 <CosmicRay> which is really /quite/ recent
12:02:14 <CosmicRay> and means it is likely non-portable
12:02:18 <CosmicRay> s/linus/linux/
12:02:24 <Baughn> Mm. I've got posix manpages, so I don't see that sort of thing
12:03:08 <Baughn> (And yes, it is. Would help, if we didn't care about portability, though - it means you can open FDs in multiple threads without race conditions with exec)
12:05:50 <gwern> CosmicRay: hey, what happened to HSH anyway? the darcs repo seems to be broken
12:05:58 <CosmicRay> gwern: I've moved everything to GIT
12:06:05 <CosmicRay> gwern: see http://git.complete.org/
12:06:05 <lambdabot> Title: git.complete.org Git
12:06:20 <gwern> CosmicRay: oh. does git have any darcs send?
12:06:53 <CosmicRay> gwern: see http://software.complete.org/software/wiki/site/GitGuide for as close as git gets
12:06:54 <lambdabot> Title: The Software.Complete.Org Site - GitGuide - Software.Complete.Org
12:07:08 <CosmicRay> in a word yes, but it is a bit more typing.
12:07:35 <Cale> I noticed that most of the text from the HSH site was also removed, but fortunately it's still in the Haddock.
12:07:49 <gwern> ...does it store your smtp password? like, in clear?
12:08:01 <CosmicRay> Cale: what do you mean?
12:08:12 <CosmicRay> Cale: give me a url that's messed up
12:08:33 <CosmicRay> make sure you read that sentence that says "click on the hsh wiki for more information" ;-)
12:08:45 <Cale> ah, okay
12:09:03 <CosmicRay> there, it's bold now ;-)
12:09:07 <Cale> That wasn't there before, I don't think :)
12:09:16 <CosmicRay> it was, just not bold ;-)
12:09:17 <dcoutts_> CosmicRay: it just means that we'd have to do it conditionally and use a separate fcntl if O_CLOEXEC isn't available
12:09:20 <Cale> (maybe when you'd just switched to the new site layout?)
12:09:32 <CosmicRay> Cale: yeah, all of the projects have that
12:09:39 <CosmicRay> I actually switched from Trac to Redmine
12:09:43 <CosmicRay> because trac sucks for multiple projects
12:09:50 <dcoutts_> CosmicRay: it means a slight gap between opening and fcntl where one could fork and inherit the open fd, but what else can one do?
12:10:12 <CosmicRay> right
12:13:04 <sjanssen> one could use a global lock that threads must take before forking
12:13:43 <dcoutts_> though it doesn't help for C code
12:14:06 <Baughn> dcoutts_: Well, one can do all FD opens and forks in the same thread
12:14:13 <Baughn> dcoutts_: Doesn't the RTS already work that way?
12:14:24 <sjanssen> global semaphore, then :)
12:15:09 <dcoutts_> Baughn: yeah, like sjanssen's suggestion that helps for process forks done from haskell code
12:16:17 <Baughn> Then add the lock, I guess. I wouldn't want to see the bug "fixed" only to turn into a heisenbug
12:16:36 <Baughn> Such a lock should be possible to grab from C code as well
12:16:46 <Baughn> As for C code that forks without doing that.. well, it's broken
12:21:21 <Arnar_> what version of cabal is required for cabal-install?
12:21:46 <Baughn> Arnar_: darcs, pretty much
12:21:49 <dcoutts_> Arnar_: if you use the latest darcs version of cabal-install then you need the latest darcs version of Cabal too
12:22:03 <Arnar_> ok.. thanks
12:22:05 <dcoutts_> Arnar_: though I did put out snapshots of both recently
12:22:13 <dcoutts_> if you prefer tarballs
12:22:28 <Arnar_> dcoutts_: ok.. I don't mind getting from darcs if it has the same stability
12:22:42 <dcoutts_> Arnar_: hopefully :-)
12:24:31 <Arnar_> hmm.. I'm not too good with darcs.. can I get a snapshot without getting each patch individually?
12:24:54 <Baughn> Arnar_: Add --partial to the get command
12:25:05 <Baughn> Mind you, that depends on the maintainer /making/ snapshots
12:25:25 <Baughn> (And it tends to break if you try to make changes, but is fine for just tracking)
12:25:57 <Arnar_> Baughn: ok
12:26:08 <Arnar_> better go for the snapshots then :)
12:27:04 <Arnar_> dcoutts_: where are the snapshots?
12:27:23 <Arnar_> sorry..nm
12:27:24 <Arnar_> found it
12:28:24 <dcoutts_> sorry, confusion, when I said snapshots I meant tarballs not darcs's notion of snapshots
12:28:32 <dcoutts_> @where cabal
12:28:32 <lambdabot> http://www.haskell.org/cabal
12:28:51 <Arnar_> dcoutts_: yeah.. I read "tarballs" :)
12:28:55 <dcoutts_> http://www.haskell.org/cabal/release/devel/
12:28:55 <lambdabot> Title: Index of /cabal/release/devel
12:28:58 <ziman> @pl \ (a1, b1) (a2, b2) -> (a2-a1, b2-b1)
12:28:59 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. subtract) . flip . (((.) . (,)) .) . subtract)
12:29:05 <ziman> ohh
12:29:13 <dcoutts_> Arnar_: and http://www.haskell.org/cabal/release/cabal-install-0.4.6.tar.gz
12:29:30 <Arnar_> dcoutts_: yeah, thanks.. was just clicking that one :)
12:34:49 <Baughn> Hm. Call pipe, then close all descriptors from 3 up to the pipe FDs?
12:34:58 <Baughn> ..I think I've just succeeded in grossing myself out.
12:40:15 <halberd> is there a word for the opposite of operator precedence (the property of operators to bind loosely to their arguments)?
12:40:49 <mauke> is there a word for the opposite of temperature?
12:41:35 <bugQ> not really, because there is a lower bound on temp.
12:41:41 <halberd> well I'm trying to describe a system where you decrement the precedence of certain operators
12:42:00 <bugQ> oh.
12:42:02 <halberd> but you can decrement them indefinitely and i'd rather use the "opposite of precedence" and increment it
12:42:06 * bugQ answers rhetorical questions. :P
12:42:08 <halberd> so you don't get negatives
12:42:53 <halberd> i'm describing a "function" . such that .f makes f bind more loosely to its arguments by a factor of 1
12:43:13 <halberd> er, a difference of 1
12:43:16 <Baughn> bugQ: http://en.wikipedia.org/wiki/Negative_temperature <-- Is that so?
12:44:01 <bugQ> "a system with a truly negative temperature is not colder than absolute zero; in fact, temperatures colder than absolute zero are impossible."
12:44:06 <halberd> I would call it "importance" because something with lower precedence moves higher up in the abstract syntax tree
12:44:12 <halberd> which makes it more important
12:44:21 <halberd> except that precedence kind of already means important
12:44:50 <Baughn> bugQ: Oh, hush. It sounds good.
12:44:57 * bugQ hushes...
12:46:14 <bugQ> OK, this is interesting: "The temperature scale from cold to hot runs +0 K, . . . , +300 K, . . . , +â K, ââ K, . . . , â300 K, . . . , â0 K."
12:46:34 <bugQ> oops, the â¢ should be â
12:46:36 <bugQ> ack.
12:46:46 <bugQ> oh, it's my font.
12:51:02 <halberd> I think I'll call the opposite of precedence "strength" so increasing the strength of an operator makes it "grab" more arguments, which is the same as decreasing the precedence
12:51:06 <Cale> I wonder if GHC 6.10 will have  (IArray a u, IArray a v) => IArray a (u,v),  (or similar, restricted to UArray)
12:51:18 <bugQ> operator tenacity?
12:51:51 <Cale> Type families should make it possible to have UArrays of a wider class of types :)
12:52:09 <vincenz> Cale: or better
12:52:30 <vincenz> (IArray a u, IArray u v) => IArray a v
12:52:43 <vincenz> of course that would only work in a depdently typed language
12:52:54 <vincenz> where you can make sure the two u's are the same domain/codoman
12:54:09 <vincenz> Cale: are type-families complicated to make?
12:54:23 <Cale> They're actually pretty easy to use.
12:55:11 <IsoPallo> Hmm... Anybody thought of designing a nice 2d-layout based syntax into arrow-notaton (like those for electronics) and selling it as the Functional COmmon Business Oriented Language...
12:55:21 <Cale> http://www.haskell.org/haskellwiki/GHC/Indexed_types
12:55:23 <lambdabot> Title: GHC/Type families - HaskellWiki
12:56:00 <Cale> IsoPallo: Well -- there's the presently-informal diagram language which shows up in a lot of the papers.
12:56:16 <Cale> IsoPallo: The arrow syntax in GHC is sort of a flattening of that.
12:56:18 <vincenz> Cale: but to implement
12:56:23 <vincenz> Cale: what I wonder is, how come it too so long to make.
12:56:26 <Cale> vincenz: oh, to implement :)
12:56:35 <vincenz> s/too/took
12:57:10 <Cale> I think the problem had more to do with actually realising that this was the thing we wanted :)
12:57:23 <Cale> But there are likely some subtleties.
12:57:42 <Cale> Especially the interactions with type inference.
12:58:51 <halberd> how would you write \ x -> a (e (j (c (b x) (d x)))) (f (g (i x)) (h x)) points free?
12:59:02 <Cale> @pl \ x -> a (e (j (c (b x) (d x)))) (f (g (i x)) (h x))
12:59:02 <lambdabot> ap (a . e . j . liftM2 c b d) (ap (f . g . i) h)
12:59:13 <Cale> like that
12:59:17 <halberd> ok
12:59:20 <Cale> hehe
12:59:35 <Cale> However, that might be going too far.
12:59:38 <halberd> thanks
12:59:42 <Cale> I'd probably not remove that lambda
12:59:59 <Cale> But I might express some of the stuff underneath it in terms of (.)
13:00:22 <Deewiant> @pl a (e (j (c (b x) (d x)))) (f (g (i x)) (h x))
13:00:23 <lambdabot> a (e (j (c (b x) (d x)))) (f (g (i x)) (h x))
13:00:24 <Taejo> if my program doesn't use Integers, can I compile it so it doesn't have a libgmp dependency?
13:00:47 <Cale> Taejo: I don't think that's easy, if it's doable at all.
13:01:01 <Cale> Taejo: Many of the library functions internally use Integers
13:01:10 <Taejo> fair enough
13:01:45 <Saizan> you can link libgmp statically perhaps?
13:04:25 * byorgey is having fun developing a cairo-based EDSL for creating simple diagrams!
13:04:35 <dcoutts_> yay
13:04:41 <dons> woot
13:04:49 <Nafai> byorgey: Sounds cool!
13:04:52 <dcoutts_> I've long hoped that someone would make a pure layer on top of cairo
13:04:58 <dons> i'd love a little gtk tool for looking at origami folding..
13:05:20 <byorgey> err... well, you'll have to wait a bit yet, dons =)
13:06:02 <byorgey> cairo is really quite nice!
13:06:10 <dmwit> Yes!
13:06:20 * xerox agrees!
13:06:29 <Cale> liftM2 a (e . j . liftM2 c b d) (liftM2 f (g . i) h)
13:06:32 * Vq^ too
13:06:33 <Arnar_> as in cairo the city?
13:06:35 <Cale> hmm, is that correct?
13:06:43 <Cale> Anyone want to check that for me? :)
13:06:53 <byorgey> Arnar_: well, I was referring to cairo the graphics library, but the city might be nice too =)
13:06:54 <dmwit> Not enough info!
13:06:55 <Vq^> Arnar_: as in the graphics package
13:07:03 <Arnar_> ah :)
13:07:22 <dcoutts_> byorgey: we really need to get gtk and cairo cabalised
13:07:35 <byorgey> dcoutts_: that would be nice, yes
13:07:36 <dmwit> Isn't there a SoC project working on that?
13:07:42 <dcoutts_> dmwit: yes!
13:07:48 <Cale> > liftM2 f g h x
13:07:48 <dmwit> Sweet!
13:07:49 <lambdabot>  Add a type signature
13:07:49 <dcoutts_> Saizan is doing it, I'm supervising :-)
13:07:51 <Cale> > liftM2 f g g x
13:07:52 <lambdabot>  Add a type signature
13:07:54 <Cale> > liftM2 f g g x :: Expr
13:07:55 <lambdabot>  Add a type signature
13:08:12 <dmwit> > [liftM2 f g h x, ()]
13:08:13 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr ())
13:08:24 <Cale> > liftM2 (f :: Expr -> Expr) (g :: Expr -> Expr) (g :: Expr -> Expr) (x :: Expr)
13:08:25 <lambdabot>  Couldn't match expected type `a2 -> r' against inferred type `Expr'
13:08:31 <Arnar_> anyone know where I could find some color-schemes for emacs' font-lock?
13:08:35 <Cale> > liftM2 (f :: Expr -> Expr -> Expr) (g :: Expr -> Expr) (g :: Expr -> Expr) (x :: Expr)
13:08:36 <lambdabot>  f (g x) (g x)
13:08:40 <Cale> okay, good :)
13:08:46 <Cale> liftM2 a (e . j . liftM2 c b d) (liftM2 f (g . i) h) x
13:08:59 <Vq^> Arnar_: the color-theme package perhaps
13:09:02 <dcoutts_> dmwit: yeah, the project is to prototype a make-like system for cabal and to try it out for pre-processors initially, so that should solve the cabal/c2hs problem and allow glib, cairo, gtk etc to be cabalised
13:09:03 <dmwit> ?unpl liftM2 f g g x
13:09:04 <lambdabot> (g >>= \ b -> g >>= \ a -> return (f b a)) x
13:09:06 <Cale> -> a (e . j . liftM2 c b d $ x) (liftM2 f (g . i) h $ x)
13:09:23 <Arnar_> Vq^: oh, didn't know about that one
13:09:30 <Cale> -> a (e . j $ liftM2 c b d x) (liftM2 f (g . i) h $ x)
13:09:33 <Vq^> Arnar_: http://www.emacswiki.org/cgi-bin/wiki?ColorTheme
13:09:34 <lambdabot> Title: EmacsWiki: Color Theme
13:09:41 <dcoutts_> Saizan: btw, paolin1 is writing up some ideas you might be interested in, and generally we should start thinking about the approach we want to take.
13:09:43 <Cale> -> a (e . j $ c (b x) (d x)) (liftM2 f (g . i) h $ x)
13:09:51 <dmwit> Oh, ?pl applies some one-way rewrite rules, huh?
13:09:53 <Cale> -> a (e . j $ c (b x) (d x)) (f (g . i $ x) (h x))
13:10:04 <dmwit> dcoutts_: Yeah, I saw that one.  Seems pretty cool!
13:10:17 <dcoutts_> yeah I think so :-)
13:10:24 <Cale> -> a (e (j (c (b x) (d x)))) (f (g (i x)) (h x))
13:10:39 <Cale> == a (e (j (c (b x) (d x)))) (f (g (i x)) (h x)) ?
13:10:41 <Cale> yes
13:10:55 <dcoutts_> dmwit: and hopefully we'll be able to extend it later to cover .hs files too so we can stop using ghc --make and do parallel builds ourselves
13:11:03 * dmwit hopes Cale actually uses more readable identifiers in real code
13:11:04 <Cale> halberd: So, you could do it as  liftM2 a (e . j . liftM2 c b d) (liftM2 f (g . i) h)
13:11:18 <halberd> ok
13:11:20 <Cale> dmwit: Not my code. halberd asked how to points-free that.
13:11:32 <Saizan> dcoutts_: yeah, i promptly catched a flu last weekend.. but i'm getting better and i'll start working :)
13:11:41 <Cale> halberd: If you want to see my steps of reasoning...
13:11:46 <dcoutts_> Saizan: oh, poor you :-(
13:11:56 <halberd> no that's fine I just wanted to know about how long it would be to do it points free in Haskell
13:11:59 <Cale> halberd: Well, they're basically that chain of steps in reverse.
13:12:20 <halberd> I'm working on a system based on J for concise points free declarations where you know the arity of the functions involved and none of them are higher order
13:12:33 <Cale> Of course, pl is even more clever and comes up with a way to use ap
13:12:39 <dmwit> ?pl \x -> a (e (j (c (b x) (d x)))) (f (g (i x)) (h x))
13:12:40 <lambdabot> ap (a . e . j . liftM2 c b d) (ap (f . g . i) h)
13:12:51 <halberd> in my system, I would write it e .j c b d .a g i f h
13:13:20 <Cale> Whoa...
13:13:23 <halberd> requiring you to know that a, b, f have arity 2
13:13:29 <Cale> ah, okay
13:13:40 <halberd> and the others have arity 1
13:13:43 <Cale> er... it's a little strange that e ends up on one end there.
13:13:46 <halberd> and none of them take functions as arguments
13:13:54 <halberd> a, b, f are infix
13:14:27 <halberd> . decreases the precedence of the function that follows it
13:14:38 <Cale> Hehe, I think I'll stick to my liftM2's for now ;)
13:14:52 <halberd> and the functions are written as an inorder traversal of the abstract syntax tree
13:15:16 <Cale> mm... yeah, okay, I can see how e will end up there.
13:15:40 <haskell4thugz> Is anyone here familiar with Haskell+Music, Haskore, or MIDI?
13:16:05 <haskell4thugz> We're trying to create a live Haskell synthesizer that has a constant event output stream to MIDI.
13:16:06 * Cale wonders if Alex McLean is here...
13:16:19 <halberd> I'm trying to determine that my system actually uniquely determines the function, then I'll make a post
13:16:34 <dons> Cale: 'yaxu'
13:16:39 <dons> ?seen yaxu
13:16:39 <lambdabot> I haven't seen yaxu.
13:16:40 <Cale> Ah, right.
13:16:57 <haskell4thugz> Cale, can yaxu help us?
13:17:11 <Cale> haskell4thugz: There are a bunch of people working on that, Alex McLean being one of the major ones, iirc.
13:17:20 <Cale> haskell4thugz: Check out his blog here: http://doc.gold.ac.uk/~ma503am/alex/haskellmusic/
13:17:25 <lambdabot> Title: Alex McLean » Blog Archive » Haskell music
13:17:51 <haskell4thugz> Yes, I've seen his blog. I think he's using csound mostly, though.
13:18:22 <Cale> Hmm, who else was doing this sort of thing? I forget now. You probably should post on Haskell-cafe and see if you attract any responses that way, at least.
13:18:28 <Cale> Do you have any specific questions?
13:18:35 <Cale> I know a *little* about Haskore.
13:19:12 <haskell4thugz> Well, we were playing with Haskore, and Haskore writes a [Event] to a midi file and plays that file.
13:19:23 <haskell4thugz> We're interested in playing a cycle [Event]
13:20:38 <Cale> So effectively an infinite piece of music?
13:20:46 <haskell4thugz> yes
13:21:05 <haskell4thugz> we'd like to create it on the fly with user input
13:21:13 <haskell4thugz> and keep feeding it to a MIDI device
13:21:37 <Cale> Have you tried it yet?
13:21:43 <Cale> It *may* just work.
13:21:49 <haskell4thugz> Nope, doesn't work.
13:21:57 <haskell4thugz> It just writes an infinite file to disk.
13:22:07 <haskell4thugz> Which works as expected :)
13:22:15 <Cale> oh
13:22:33 <haskell4thugz> we're trying to take the file part out of it
13:22:38 <Cale> so instead of writing that file to disk, you want to write to /dev/sequencer or similar
13:23:19 <haskell4thugz> something like that
13:23:25 <haskell4thugz> we're really unsure
13:25:23 <Cale> hmm...
13:25:42 <dmwit> Do they use some other program to play the MIDI file?
13:25:44 <Cale> You're on linux?
13:25:50 * dmwit wonders why they have the middleman
13:26:01 <Cale> dmwit: Normally, yeah.
13:26:06 <haskell4thugz> yes
13:26:10 <Cale> dmwit: Which varies by platform.
13:26:13 <haskell4thugz> right, we don't want to create the file
13:26:17 <dmwit> Ah, okay.  That makes sense.
13:26:22 <haskell4thugz> right now, Haskore writes a midi, and pmidi plays it
13:26:41 <mofmo1> so UArrays are still slow as molasses
13:26:43 <Cale> haskell4thugz: Does pmidi accept a file on its stdin perhaps?
13:26:46 <\phil\> hello! goodbye!
13:26:52 <haskell4thugz> Cale, no
13:27:12 <gwern> @seen dons
13:27:12 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc and #haskell. I last heard dons speak 10m 33s ago.
13:27:14 <haskell4thugz> ok, we have to go to class
13:27:21 <haskell4thugz> be back later for more suggestions, thanks
13:27:28 <Cale> haskell4thugz: I'll think about how to do this :)
13:27:29 <mofmo1> so i set the uarrays to be strictly evaluated
13:27:33 <dons> gwern: yo
13:27:34 <gwern> does anyone know Philip Weaver? is he from Galois?
13:27:37 <dons> gwern: yes.
13:27:40 <mofmo1> i dont think that made too much of difference. however, it's still slower than it should be
13:27:44 <dons> gwern: he's pweaver in here.
13:27:48 <mofmo1> i think i've seen quicker javascript implementations
13:27:53 <dons> and awesomely talented, fwiw.
13:28:02 <Cale> mofmo1: Can I see your most recent code?
13:28:06 <mofmo1> sure
13:28:06 <gwern> dons: ah. that explains his cryptol comment - cryptol is a galois project
13:29:03 <dons> quite so.
13:29:04 <gwern> dons: does cryptol use autotools and not cabal?
13:29:13 <dons> its moved from one to the other, iirc
13:29:45 <yav> they have switched to cabal
13:29:48 <dcoutts_> dons: moved in which direction?
13:29:53 <gwern> dons: what was wrong with cabal?
13:30:13 <byorgey> http://wso.williams.edu/~byorgey/diagram1.html
13:30:16 <dons> its like cabalising ghc, a hard job.
13:30:20 <dons> so best done piecewise
13:30:54 <yav> yeah, they have quite a fancy Setup script, apprently
13:30:57 <Cale> byorgey: Sweet! Keep going and we'll have a Haskell version of inkscape in no time ;)
13:31:09 <gwern> hum. a awful big project then. but he seems interested in how I cabalized darcs, so maybe the hardest bit could be solved with a buildinfo and some well placed configure.ac patches
13:31:18 <byorgey> Cale: hehe, that's the goal ;)
13:31:18 <dons> not bad, byorgey
13:31:34 <mofmo1> hey cale, see if you can access this https://bspace.berkeley.edu/access/content/user/309140/Board.hs
13:31:39 <mofmo1> that's not the current code however
13:31:40 <dons> gwern: keep pushing on darcs. i don't see why it shouldn't be a normal haskell app. and likely good for long term contributions.
13:31:55 <Cale> mofmo1: Login required.
13:31:58 <mofmo1> hmm
13:31:59 <mofmo1> damn
13:32:03 <dons> getting ghc6.6 installed so you can reproduce david's setup is a good idea.
13:32:09 <gwern> dons: you see my Cabalizing darcs on -cafe? that's my latest strategy
13:32:19 * gwern calls it 'lightweight forking'
13:32:38 <awesame> what do people use for computing sha1 and md5 hashes in haskell?
13:32:44 <dons> gwern: yeah.
13:32:56 <dons> awesame: the nano-sha and nano-md5 packages
13:33:03 <mauke> Data.Digest.MD5
13:33:03 <dons> awesame: look on hackage.haskell.org
13:33:14 <dons> there's half a dozen libs
13:33:17 <gwern> awesame: they use everything under the sun. there's something like 6 different versions of sha1 in use by various projects
13:33:49 <dcoutts_> dons, yav: I hope all the cabal features you need to cabalise your projects are reported on the trac, adding a cc on existing ones to indicate interest wouldn't go amiss either
13:33:50 <awesame> I was disatistified with the implementations I found in the Crypto
13:33:52 <awesame> library
13:34:07 <mofmo1> http://codepad.org/x8UmUgkI http://codepad.org/MfgAwMuh http://codepad.org/guOiceF5 http://codepad.org/MRyo5Ti9 http://codepad.org/tggXInQp
13:34:17 <mofmo1> i didn't use hpaste due to the truncation problem...
13:34:32 <dons> i prefer the openssl bindings
13:34:37 <mofmo1> last file is a puffer train which runs fairly sluggishly
13:34:45 <dons> the Crypto lib is more of a model, imo.
13:34:46 <gwern> @tell glguy 'mofmo1> i didn't use hpaste due to the truncation problem...'
13:34:46 <lambdabot> Consider it noted.
13:35:49 <yav> dcoutts_: i only make simple packages :-)  i am not sure if phil has added problems to the track but i'll encourage him to do so, if he finds anything
13:36:12 <dcoutts_> yav: thanks :-) we can't fix problems we're not aware of
13:36:25 <mofmo1> perhaps i'm asking too much performance out of haskell :-P
13:36:27 <Arnar_> hmm..
13:36:38 <Arnar_> using cabal install to install the "plugins" package (dependency of lambdabot)
13:36:50 <dons> mofmo1: ?
13:36:52 <Arnar_> getting error "Ambiguous occurrence 'depends'"
13:37:04 <mofmo1> dons: uarrays are still too slow
13:37:10 <mofmo1> for my CA program
13:37:11 <dons> they're raw memory...
13:37:13 <dcoutts_> gwern: http://haskell.org/pipermail/haskell-cafe/2008-April/042067.html seems to be mostly empty, where can I find your darcs.cabal?
13:37:28 <dons> mofmo1: are they the right data type for your problem?
13:37:37 <dons> you're using STUArray or IOUArrays?
13:37:42 <mofmo1> well i've tried lists, DiffArrays and DiffUArray
13:37:45 <dons> with -O2 , and unchecked reads and writes.
13:37:49 <mofmo1> oh... just uarrays
13:37:51 <dons> oh, they're all very slow though.
13:37:57 <dons> DiffUArrays, you mean?
13:38:06 <mofmo1> no i just use UArrays
13:38:18 <mofmo1> it had a slight speed up compared to DiffUArrays
13:38:19 <dons> what operations do you do on them, just lookup?
13:38:27 <mofmo1> no no no... lookup and update
13:38:31 <Cale> mofmo1: okay, just compiling this :)
13:38:34 <mofmo1> 9 times more lookup
13:38:34 <dons> so I'd use STUArrays
13:38:52 <dons> they're fast, safe.
13:38:53 <gwern> dcoutts_: oh dear. well, it's obviously in darcs-devel in patch form
13:38:53 <mofmo1> i'm scared of using monad arrays
13:38:55 <glguy> gwern: that he chose a different site than hpaste for his big file is perfect
13:38:56 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
13:38:57 <glguy> that's the idea
13:38:58 <gwern> dcoutts_: do you want me to just hpaste it?
13:38:59 <glguy> @messages
13:39:00 <lambdabot> gwern said 4m 14s ago: 'mofmo1> i didn't use hpaste due to the truncation problem...'
13:39:10 <dons> ok, but if its performance, you need something closer to the machien
13:39:10 <dcoutts_> gwern: or if you can point me to the patches on darcs-devel
13:39:16 <dons> until we have a better arrays library
13:39:19 <ziman> @pl \(x,xs) -> (x, y:xs)
13:39:19 <lambdabot> second (y :)
13:39:37 <Cale> mofmo1: What should I enter for the colour setting?
13:39:40 <gwern> dcoutts_: take too long
13:39:43 <gwern> http://hpaste.org/7136
13:39:45 <mofmo1> any number from 1-5
13:39:47 <dons> mofmo1: STUarrays are *fasT*, http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsievebits&lang=all
13:39:49 <lambdabot> Title: nsieve-bits benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Langu ..., http://tinyurl.com/sxpth
13:39:51 <dcoutts_> gwern: I'd like to look to see what darcs needs that cabal could provide more conveniently, perhaps so we can make droundy a bit happier
13:39:56 <dcoutts_> gwern: thanks
13:39:58 <mofmo1> dons: oh, i see i see
13:40:09 <mofmo1> of course they'd be faster- i get it now
13:40:28 <mofmo1> actually any number from 0-5
13:40:29 <dons> yeah, raw memory wrapped in monadic boxes
13:40:42 <mofmo1> 0 is one color, 5 is full color!
13:40:56 <dons> dcoutts_: http://code.haskell.org/~dons/code/lightarray/
13:40:56 <lambdabot> Title: Index of /~dons/code/lightarray
13:41:07 <Cale> okay, it seems to be filling my screen with white and freezing?
13:41:13 <dons> dcoutts_: they're all streams atm. need to do some perf benchmarking, and lots of other stuff
13:41:16 <dons> but you get the idea.
13:41:17 <dcoutts_> dons: so why is it light? :-)
13:41:18 <mofmo1> Cale: full screen
13:41:28 <mofmo1> wait- do you run a unix derivative?
13:41:38 <Cale> yes
13:41:43 <mofmo1> i basically abuse ansi escape code sequences for rendering
13:41:50 <Cale> yeah, my terminal supports them
13:41:58 <mofmo1> alright, full screen or else it'll be weird
13:41:58 <dons> dcoutts_: so i'd like to not rely on streams actually, but i'll get some numbers before doing the 'direct' implementations
13:42:09 <mofmo1> what did you put the speed setting at?
13:42:10 <Cale> Uh, what's "full screen"?
13:42:19 <mofmo1> F11
13:42:23 <mofmo1> ?? what do you run?
13:42:23 <lambdabot> Plugin `compose' failed with: Unknown command: ""
13:42:24 <gwern> dcoutts_: the cabal can't be a totally general replacement for the darcs makefile just yet; it does way too much stuff
13:42:31 <dcoutts_> dons: why not streams?
13:42:39 <Cale> mofmo1: The size of that will depend on my font size.
13:42:46 <dcoutts_> gwern: sure, sure, I just want to see what it does do
13:42:52 <Cale> mofmo1: I use the gnome terminal
13:42:57 <dons> dcoutts_: well, i'm suspicious. then again, there's no concatMap here, so might be fine.
13:43:07 <dcoutts_> dons: right, I see
13:43:14 <mofmo1> Cale: runs on my gnome terminal
13:43:15 <mofmo1> hrm
13:43:26 <Cale> mofmo1: What would you recommend for colour period and speed?
13:43:32 <dons> dcoutts_: there's *only* stream operations at the moment, thanks to rl :)
13:43:33 <gwern> dcoutts_: keep in mind the ld-flags, cc-options and CPP-options get defined by configure in darcs.buildinfo
13:43:38 <mofmo1> color period - any number below 10. Speed- 0
13:43:42 <dons> so i've not got numbers of if that's costing us anything
13:43:51 <mofmo1> set speed to 0 for larger files... speed really means "the opposite of speed"
13:43:56 <dons> also, need some test programs. the shootout is a good candidat.e
13:44:00 <mofmo1> (it sets the argument to threadDelay)
13:44:11 <dcoutts_> dons: I don't quite understand the 'light' names
13:44:24 <dons> dcoutts_: well, i'm open to suggestions.
13:44:30 <dcoutts_> dons: it doesn't really tell me what they do
13:44:33 <dons> i want 1 array type, that's really fast, with few dependencies
13:44:43 <dons> fast-packed-fused-arrays
13:44:43 <awesame> hm, found nano-md5 but not nano-sha1
13:44:54 <dons> awesame: nano-hmac?
13:44:56 <awesame> and hopenssl appears to be hugs-only or something
13:44:58 <Cale> mofmo1: I figured that, and had set it to 1 before, but 0 makes no difference. I just get a completely white screen.
13:45:03 <dons> hugs only?
13:45:12 <awesame> there is a nano-hmac, but an hmac is different from a sha1 digest
13:45:13 <dcoutts_> dons: light-foo seems to me to be a bit of a redditism ;-)
13:45:15 <mofmo1> Cale: is your terminal in fullscreen mode?
13:45:16 <mauke> inconceivable!
13:45:27 <dons> dcoutts_: i thought it was a dons-ism
13:45:41 <Cale> Yeah. Though there's not a lot of difference between fulscreen mode and just maximising the window.
13:45:42 <awesame> it uses a LANGUAGE pragma that ghc 6.6 doesn't support
13:45:43 <dcoutts_> dons: aaarg! more fooU's all over the place. Who is it who loves those? :-)
13:45:51 <dcoutts_> dons: do I blame rl ? :-)
13:45:52 <dons> awesame: it wouldn't be a hugs ism.
13:45:56 <awesame> hm
13:45:58 <dons> yes, its all rl .
13:46:01 <mofmo1> Cale: hmm... leme see if i somehow pasted the wrong file
13:46:05 <dons> i've just ripped out 50 other modules
13:46:10 <dons> to get the bare BUArr and UArr
13:46:18 <dcoutts_> dons: we should use module names not U suffixes
13:46:21 <dons> all the segmented and parallel stuff is gone.
13:46:23 <dons> agreed.
13:46:24 <Cale> mofmo1: At the very least, it's large enough to completely fit the life file which you pasted.
13:46:56 <dons> dcoutts_: the distinction between mutable and immutable ones is nice.
13:47:01 <dons> no pinning :)
13:47:03 <mofmo1> Cale: so um does thsi work in ghci: putStr "\ESC[45m"
13:47:04 <mofmo1> ?
13:47:05 <Cale> mofmo1: If it's any help, I have to reset my terminal after killing your program, because the background and text are apparently both white.
13:47:16 <Cale> yep
13:47:22 <dcoutts_> dons: hmm? pinning is orthogonal to the mutation I think
13:47:23 <dons> dcoutts_: also, we can keep the api down.
13:47:25 <Cale> The background colour changes to purple.
13:47:25 <mofmo1> so the ansi background works
13:47:32 <gwern> glguy: I really think hpaste needs a higher limit. I can't even paste in darcs.cabal
13:47:33 <dcoutts_> dons: so they're all 1-d vectors, Vector might not be such a bad name
13:47:34 <mofmo1> hrmm
13:47:39 <dons> dcoutts_: oh, I thought mutable arrays are also handled specially
13:47:50 <mofmo1> how did you compile it? i did "ghc -o cgol -O --make Main"
13:48:06 <dons> dcoutts_: Data.Vector ?
13:48:07 <Cale> Yeah, basically, except with -O2
13:48:25 <mofmo1> what color setting did you use?
13:48:27 <mauke> > "\SO" ++ "H"
13:48:28 <lambdabot>  "\SO\&H"
13:48:33 <gwern> dcoutts_: the paste got cut off; I've added the rest
13:48:38 <dcoutts_> dons: oh, hmm. I'm not sure then. It's not clear that mutable arrays have to be pinned. Large ones will always be pinned of course, where large = >= 1.5k
13:48:42 <dcoutts_> gwern: ta
13:48:54 <dons> dcoutts_: there's some write barrier stuff with mutable arrays too, iirc
13:48:57 <Cale> mofmo1: I've tried a few. 3 in particular.
13:49:05 <dons> dcoutts_: remember those discussions about GC barriers on mutable arrays?
13:49:07 <dcoutts_> dons: yeah, Data.Vector might be ok
13:49:15 <dcoutts_> dons: right
13:49:16 <mofmo1> huh. so after you Ctrl-C it... it changes the color settings but it doesn't actually draw it in
13:49:18 <Cale> I'm using that file that you provided.
13:49:21 <mofmo1> yeah
13:49:21 <bugQ> buh, what is '\SO'?
13:49:32 <bugQ> (mauke)
13:49:33 <pejo> dcoutts/dons, is the pinning to avoid copying stuff back and forth?
13:49:34 <Cale> aha
13:49:37 <dons> dcoutts_: another issue is how best to provide new element type instances
13:49:46 <Cale> If I don't load the file, it works.
13:49:47 <dons> -- how to make it easy for people to unbox their own types
13:49:47 <mauke> bugQ: shift out
13:49:52 <dcoutts_> dons: right, how does that work atm?
13:50:00 <bugQ> hm.
13:50:04 <mofmo1> Cale: oh perhaps the file got pasted wrong
13:50:22 <awesame> which is more stylish: "f $ g $ h x" or "(f . g . h) x"?
13:50:28 <dons> dcoutts_: you define a representation type, using an associated type.
13:50:35 <dons> to map it to one of the primitive arra types
13:50:36 <mofmo1> Cale: the colum length of each line should be 120
13:50:40 <mofmo1> as per the number at the top
13:50:53 <allbery_b> f . g . h $ x -- ?
13:50:57 <Cale> mofmo1: yeah, it appears to be
13:51:04 <dons> dcoutts_: pretty much the same as UArrays
13:51:14 <Cale> Oh, it's in dos format for some reason...
13:51:14 <dons> e.g. for Bool
13:51:16 <dons>   indexBU (BUArr (I# s#) n ba#) i@(I# i#) =
13:51:16 <dons>       (indexWord8Array# ba# (s# +# i#) `neWord#` int2Word# 0#)
13:51:30 <mofmo1> Cale: oh that could be it
13:51:31 <glguy> awesame: the first one
13:51:38 <dcoutts_> dons: in Internal.hs some of the pragmas are missing LANGUAGE
13:51:40 <dons> f . g . h $ x
13:51:44 <mofmo1> so mozilla or whatever you use put it into dos format? hahaha
13:51:55 <dons> dcoutts_: oops
13:52:04 <glguy> awesame: it's an issue of style, one that is presently under debate
13:52:07 <awesame> f . g . h $ x is pretty nice
13:52:16 <Cale> Yes, that was it, and yes it's pretty slow.
13:52:23 <Cale> Let's do some profiling :)
13:52:31 <bugQ> is there any performance difference for using composition?
13:52:34 <mofmo1> oh i should get some debugging tools
13:52:37 <dons> bugQ: no.
13:52:41 <dons> ?src (.)
13:52:41 <lambdabot> (f . g) x = f (g x)
13:52:47 <dons> is trivially inlinable :)
13:52:59 <mofmo1> Cale: it's slow, but it sure is purty
13:53:01 <dons> and ghc does very aggressive inlining
13:53:08 <mofmo1> (and a resource hog)
13:53:14 <sjanssen> @type (.)
13:53:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:53:20 <dons> crikey.
13:53:32 <lament> haha
13:53:32 <dons> that's not haskell.
13:53:37 * sjanssen stares at Cale :P
13:53:41 <glguy> epic fail
13:53:43 <lament> it doesn't match src, though.
13:53:52 <dons> HasCale
13:53:58 <lament> (src doesn't match the def-n lambdabot actually uses, that is)
13:54:07 <mauke> > sqrt . succ . [2 .. 5]
13:54:07 <lambdabot>  [1.7320508075688772,2.0,2.23606797749979,2.449489742783178]
13:54:09 <glguy> which in this case is unfortunate
13:54:21 <lament> it's never very fortunate
13:54:24 <dons> Cale, you've broken lambdabot as a teaching tool with this silliness
13:54:27 <dcoutts_> gwern: you mentioned two other files I need, what are they?
13:54:44 <nibro> I really think lambdabot ought to say the Right Thing, since newbies actually use it to learn something
13:54:47 <vincenz> dons: soon we can program in Caleskell
13:55:01 <dons> i propose lambdabot's funky evaluator should be availabl eonly from the Hascale language plugin.
13:55:13 <vincenz> shouldn't that be HasCale
13:55:15 <vincenz> as a proper TC?
13:55:20 <bugQ> the "forall a b (f :: * -> *)." is redundant though, yes?
13:55:30 <mofmo1> Cale: dons suggested STUArrays
13:55:38 <mauke> I want @type to give the Prelude version but @run to use fmap
13:55:40 <lament> STFUArray
13:55:41 <vincenz> dons: that way you can o
13:55:45 <vincenz> instance HasCale Dons where ...
13:55:49 <awesame> as a recent beginner, I really got a lot out of what (.) means to lambdabot
13:55:49 <mofmo1> but i fear that'll mean a complete overhaul of the program
13:55:59 <Cale> mofmo1: All the time is being spent in arrUpdateBoard
13:56:04 <mofmo1> mm
13:56:06 <mofmo1> i figured
13:56:06 <awesame> but I am perhaps atypical
13:56:39 <Cale> I totally disagree that having awesome definitions of things in lambdabot harms its use as a teaching tool :)
13:56:43 <lament> awesame: the problem is that first people have to realize the whole situation, ie that lambdabot's prelude is not the "normal" prelude
13:56:47 <mofmo1> an absolutely disproportionate amount of time right?
13:56:56 <Cale> mofmo1: 87% of the time
13:57:15 <dons> Cale, i want to retrieve the Prelude defintions
13:57:15 <awesame> lament: well, I was confused about that for a little while myself, but I feel like it helped me out anyway
13:57:22 <dons> they shouldn't be hidden by default
13:57:36 <Cale> :t (P..)
13:57:38 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
13:57:47 <dons> introduce the funky things via some other mechanism
13:57:49 <Cale> :t (Prelude..)
13:57:50 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
13:58:06 <lament> awesame: so if people actually have a question about (.) or map, we can't just use lambdabot to demonstrate without creating some confusion in the process
13:58:06 <awesame> the awesome definitions were invisible to me early on, and since then have helped me understand more significant things about haskell
13:58:09 <dons> *especially* since none of the people can install or use these definitions anyway
13:58:10 <nibro> :t (Cale..)
13:58:11 <lambdabot> Couldn't find qualified module.
13:58:16 <jorick> is there a gui library other than gtk2hs that i should know about?
13:58:21 <mofmo1> Cale: so... most of the time is spent PRINTING?
13:58:24 <lament> awesame: it's only invisible till you do @type :)
13:58:28 <nibro> I agree with dons completely
13:58:40 <Cale> mofmo1: Yes.
13:58:41 <dcoutts_> jorick: there's also a wx binding, gl libs and sdl
13:58:42 <allbery_b> jorick: wxhaskell
13:58:45 <mofmo1> i'd figure arrDifference would be the bottle neck
13:58:45 <awesame> lament: I see that as a potential problem, I'm just adding my own datapoint having just gone through the learning process
13:58:47 <mofmo1> christ
13:58:48 <Cale> mofmo1: Which is unsurprising really.
13:58:52 <Toxaris> Cale could provide the definitions as a package on hackage
13:58:52 <mofmo1> Cale: ??
13:59:00 <mofmo1> printing is slow?
13:59:02 <allbery_b> there are also some functional reactive programming libs, but consider those experimental
13:59:07 <mofmo1> i even have it so it only prints where things change
13:59:07 <Toxaris> so that you could get a lambdabot-emulation in ghci
13:59:12 <Cale> Toxaris: in fact, someone has done this :)
13:59:16 <nibro> if you're looking for what . does, getting a weird type for @type is definitely a harm to the learning experience
13:59:28 <awesame> Cale: link plz!
13:59:32 <Cale> nibro: Not if people are kind enough to explain the situation
13:59:44 <dons> its completely silly. we get the point, but (.) isn't changing any time soon, so this just gets in the way
13:59:48 <Cale> nibro: In fact, it's an additional learning opportunity
14:00:01 <dons> just have them available under a different evaluator
14:00:19 <lament> let's add macros to lambdabot! It will be a great learning opportunity, people will learn about macros
14:00:29 <mofmo1> Cale: is it because printing itself is slow or that printing ANSI escape codes is slow?
14:00:29 <lament> macros are a great, interesting topic to learn about, so why not
14:00:31 <Cale> I'll happily accept any patch which makes a second evaluator available :)
14:00:44 <allbery_b> urgh.  Cale, unless you have a firm promise from the Haskell' folks that yiur definitions will be canonified, it's a bad idea
14:00:51 <dons> is there anyone but Cale who thinks this is a good idea?
14:00:55 <nibro> Cale: you can explain "the situation" anyway, every time you see someone looking for the type of (.)
14:00:56 <mauke> I like it
14:01:00 <Toxaris> two evaluators sounds good
14:01:06 <Cale> dons: awesame likes it, and he's a beginner
14:01:07 <mofmo1> :t (.)
14:01:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:01:13 <awesame> dons: I liked it, personally.
14:01:17 <dons> after we explained why lambdabot is doing some non-Haskell thing
14:01:22 <allbery_b> I like the odea in theory.  In practice, though, I'd prefer that LB default to matching what ghc does.
14:01:28 <awesame> I'm not sure whether it's a good idea, but it definitely worked for me
14:01:31 <dons> and why he should forget the type he sees here, since he can't use it anywhere
14:01:35 <allbery_b> a second evaluatyor would be fine.
14:01:36 <glguy> until we have two evaluators, and Cale gets his patch, the alternate definitions should be in a qualified namespace
14:01:46 <lament> i simply want lambdabot to be a strict superset of the standard
14:01:53 <Cale> glguy: The prelude definitions are available
14:02:05 <Cale> (qualified)
14:02:10 <glguy> (broken)
14:02:16 <dons> make the Prelude ones the default,
14:02:16 <lament> i suppose (.) = fmap keeps it a strict superset
14:02:18 <Cale> anyway
14:02:22 <dons> and the other ones available under Cale.*
14:02:32 <mauke> dons: too long
14:02:33 <dons> or Awesome.*
14:02:34 <Cale> mofmo1: I think the problem is that you're doing a lot of small unbuffered writes.
14:02:50 <lament> the issue where @src prints source that doesn't match is just completely wrong
14:02:50 <mauke> you might as well use <$> in that case
14:02:51 <Jedai> Two evaluators should be fine, no ?
14:02:55 <lament> regardless of everything else
14:03:09 <lament> @src Prelude..
14:03:09 <lambdabot> Source not found. :(
14:03:10 <Jedai> >> and > for example
14:03:11 <Toxaris> it's not jus two evaluators, @type, @src and @eval should agree
14:03:16 <mofmo1> Cale: oh so i should do explicit writes
14:03:18 <dons> not being able to walk through :type (.) and ?src (.) is just so broken
14:03:26 <mofmo1> and take out that general "no buffering" thing
14:03:40 <mauke> Toxaris: @src is unrelated to anything running code and @eval is a no-op :-)
14:03:41 <Cale> mofmo1: Also, using Data.ByteString and constructing a complete screen in a string before writing it would probably help
14:03:46 <Jedai> Toxaris: And @type should refer to the "Prelude" evaluator
14:04:15 <Cale> lament: @src (.)
14:04:19 <Toxaris> mauke: but @src is related to a standard library
14:04:22 <dons> Cale, so you're not going to act on this, and default to the real definitions?
14:04:27 <Cale> lament: The @src database still has the Haskell 98 one
14:04:40 <lament> Cale: yes, i understand. That's called a high priority bug.
14:05:19 <Toxaris> I think we want the illusion of two lambdabots, with some way to choose wich gets which command
14:05:43 <lament> or, in more exact terminology, "couldn't match expected type against inferred type" :)
14:05:53 <dons> > "haskell"
14:05:54 <lambdabot>  "haskell"
14:06:14 <dons> ] "HasCale"
14:06:16 <vincenz> > "Caskell"
14:06:17 <lambdabot>  "Caskell"
14:06:39 <lament> how about '>
14:06:43 <vincenz> > var "I want less Cale stuff"
14:06:44 <lambdabot>  I want less Cale stuff
14:06:54 <lament> '> f $ g x $ h y
14:07:00 <mauke> >'
14:07:03 <Toxaris> dons: that dosn't help with src and type
14:07:06 <vincenz> lament: ' is annoying to type
14:07:16 <vincenz> why not
14:07:18 <vincenz> @eval
14:07:19 <vincenz> and
14:07:19 <lament> vincenz: how so?
14:07:20 <vincenz> @elac
14:07:21 <lambdabot> Maybe you meant: eval slap
14:07:26 <dons> Toxaris: it does if @src, @type and @run are in agreement -- that they work for Haskell as installed on our machiens
14:07:35 <lament> vincenz: - doesn't even need a shift key, unlike >
14:07:47 <vincenz> why not --
14:08:13 <lament> because... that's the comment sign?
14:08:24 <vincenz> lament: exactly but all of IRC is already comment, so we inverse it
14:08:26 <Jedai> I proposed >> ?
14:08:26 <vincenz> -- code -- comment
14:08:33 <Toxaris> dons: but we want @src, @type and @run for Cale's Haskell too, not only @run. so we need an alternative to @
14:08:37 <dons> Cale... I can't see how this position is tenable. All our other extension/tweaks go under different namespaces -- confusing the Prelude for your own purposes can't be justified -- no one can actually use these definitions.
14:08:40 <Jedai> >> [1..]
14:08:57 <dolio> @vera RAII
14:08:59 <lambdabot> No match for "RAII".
14:09:03 <dons> Toxaris: why? its just 2 or 3 different definitions, which we're now familiar with, and not using. so move on.
14:09:12 <lament> (+1) . [1..3]
14:09:15 <lament> > (+1) . [1..3]
14:09:15 <lambdabot>  [2,3,4]
14:09:16 <mauke> dons: I can
14:09:36 <lament> (does anybody actually think that "(+1) . [1..3]" is a good idea?)
14:09:42 <mauke> lament: yes!
14:09:44 <vincenz> it's pretty
14:09:44 <glguy> 3 do
14:09:59 <dons> and meanwhile we confuse people for no good reason -- the change is against the fundamental philosophy of lambdabot as a teaching tool for Haskell-as-we-know-it
14:10:01 <vincenz> > (*3) . (+1) . [1..3]
14:10:03 <lambdabot>  [6,9,12]
14:10:11 <lament> my problem is
14:10:17 <lament> if we overload (.) that way
14:10:25 <lament> we should overload whitespace the same way
14:10:29 <vincenz> > ((*) . (+) ) 1 2
14:10:30 <lambdabot>   add an instance declaration for (Num (a -> a))
14:10:32 <vincenz> > ((*) . (+) ) 1 2 3
14:10:34 <lambdabot>   add an instance declaration for (Num (a -> a))
14:10:42 <Cale> lament: how?
14:10:51 <lament> i mean
14:10:56 <lament> . is function composition
14:10:57 <Cale> lament: (in what way should whitespace be overloaded?)
14:11:04 <lament> shouldn't function application be (+1) [1..3] ?
14:11:10 <vincenz> I wonder how . combines with reader monad
14:11:12 <mauke> lament: . is lifted function application
14:11:25 <vincenz> > ((*3) . (+1) ) $ 2
14:11:25 <lambdabot>  9
14:11:33 <vincenz> > ((*) . (+1) ) $ 2
14:11:34 <lambdabot>  <Integer -> Integer>
14:11:40 <Cale> vincenz: It works beautifullt
14:11:41 <vincenz> > (((*) . (+1) ) $ 2) 5
14:11:42 <lambdabot>  15
14:11:44 <Cale> Beautifully *
14:11:56 <Cale> vincenz: The reader monad is exactly why (.) works as fmap
14:11:59 <vincenz> it removes the need for ..
14:12:09 <dons> Cale, are you ignoring me? :) I just wan to know if you're going to move on this issue.
14:12:21 <vincenz> Oh no
14:12:24 <Cale> dons: Well, I'd love to have two modes.
14:12:26 <vincenz> We're turning into #scheme
14:12:35 <Cale> vincenz: Oh?
14:12:37 <glguy> vincenz: what do they do in #scheme?
14:12:39 <vincenz> "R6RS is the way to go" "R6RS sucks!"
14:12:53 <vincenz> glguy: channel-titans fighting over language definitions?
14:12:56 <dons> its not like its a new standard
14:13:00 <dons> or even an H' ticket.
14:13:03 <dons> its just a local hack
14:13:06 <vincenz> dons: make it plt vs chez?
14:13:15 <Cale> dons: I should probably ask Simon to make it an H' ticket.
14:13:24 <vincenz> dons: is H' still going to happen, I mean the new things in GHC have surpassed it
14:13:35 <dons> vincenz: check haskell@haskell.org as of today
14:13:36 <mauke> Cale: yes!
14:13:43 <Toxaris> vincenz: isn't there recent news about the H' frontier?
14:13:48 <Cale> JaffaCake: are you still around?
14:13:53 <dons> now, we've 100 other H' tickets that aren't on by default
14:14:01 <JaffaCake> Cale: hi
14:14:06 <vincenz> dons: hmm, check haskell@haskell.org, you mean the M?
14:14:07 <vincenz> ML?
14:14:18 <dons> so why is this not-even-in-H' change on by default?
14:14:35 <Cale> JaffaCake: I'd like to request an H' ticket for making (.) and map into the two names for fmap
14:14:44 <Toxaris> lament: I think I might prefer ($) = (<$>) and (.) = (>>>)
14:14:51 <awesame> lament: re: overloading whitespace, I did that for ($): http://codepad.org/vkcUvLCm
14:15:04 <Cale> (that is, rename fmap to map, and define (.) as a synonym of it)
14:15:14 <JaffaCake> Cale: I'd suggest discussing it on the mailing list first
14:15:16 <Toxaris> lament: the Monad instance for (->) feels unimportant compared with the Arrow instance for (->)
14:15:33 <JaffaCake> if there's enough support, then we can make it a fully fledged proposal
14:15:37 <Cale> Okay.
14:16:03 <JaffaCake> I think I might have been premature in making $ a full proposal, there doesn't seem that much support for it
14:19:15 <Cale> Niklas Broberg seems to be defending it quite well :)
14:19:44 <dons> just use a new symbol for it.
14:19:52 <dons> unicode is a rich set of fun
14:20:02 <lament> unicode is not realistic
14:20:05 <Cale> dons: Unicode is also hard to type.
14:20:11 <lament> nobody can type it and not everybody can read it
14:20:14 <dons> lament, it is for stuff no one cares about :)
14:20:33 <Cale> dons: In fact, I would suggest the same for the *right* associative $
14:20:47 <Cale> If we really wanted to keep it.
14:20:50 <dons> i'd be happy to see a fun symbols lib appear on hackage
14:21:01 <Cale> People are *way* too concerned with backwards compatibility.
14:21:09 <dons> you don't write code, Cale :)
14:22:01 <Cale> What made Haskell into such an awesome language is that the people designing it didn't care about making things comfortable for the existing masses of programmers.
14:22:04 <saml> > [1 .. 'a']
14:22:05 <lambdabot>   add an instance declaration for (Num Char)
14:22:05 <lambdabot>     In the expression: 1
14:22:05 <lambdabot>     In ...
14:22:27 <saml> > [1, 2, 'a'] !! 1
14:22:28 <lambdabot>   add an instance declaration for (Num Char)
14:22:28 <lambdabot>     In the expression: 1
14:22:29 <lament> dons: we talked about this yesterday. What makes Haskell interesting is primarily its position as a research language.
14:22:40 <Cale> They were more concerned with elegance of the language, and not worried about whether it was compatible with pre-existing ideas.
14:22:44 <dons> ($) isn't a research issue.
14:22:48 <dons> its just a bikeshed
14:23:10 <Cale> dons: But this is a sign that the language is becoming harder to change.
14:23:17 <lament> dons: sure, but the issue of backwards compatibility is larger
14:23:23 <dons> i see no reverse ($) on hackage.
14:23:32 <dons> that would be a fast way to build acceptance
14:23:35 <lament> dons: backwards compatibility is what ultimately causes the language to be replaced by a more modern competitor
14:23:52 <lament> dons: and if haskell is serious about backwards compatibility, that's what will happen to it.
14:24:01 <dons> ($) is such a *trivial* issue.
14:24:03 <lament> not that that's necessarily a bad thing
14:24:10 <dons> there are so many bigger issues to sort
14:24:19 <Cale> dons: If it's so trivial, then why bother complaining about the change?
14:24:37 <dons> the breakage outweights the benefit massively
14:24:41 <dons> it has trivial benefit
14:24:55 <Cale> Have you checked exactly how much breakage there'd be in your own code?
14:25:11 <JaffaCake> it's trivial in the sense that it's easy to define your own version
14:25:25 <JaffaCake> but far from trivial in impact
14:25:28 <dons> Cale, I think its up to those wanting to change the default to justify it.
14:25:39 <Cale> dons: I've provided a lot of good reasons.
14:25:50 <dons> showing the breakage would be good.
14:26:02 <dons> compile the 500 hackage packages against a modified prelude
14:26:16 <dons> then you'd have a very strong case either way
14:26:40 <dons> its really the simplest way to get things done. provide some numbers, otherwise its just a vapour-ticket
14:26:42 <pejo> The argument that Heffalump (?) put forth is quite convincing though - there's plenty of closed source in the wild.
14:27:07 <awesame> one thing I find impressive about Python is how it's managed to grow from a really terrible language (the one I found in 1997) to a pretty decent one
14:27:10 * CosmicRay notes that there is precedent for major languages changes in the wild.  Perl, for instance.
14:27:15 <dons> but it feels like a classic bikeshed issue. meanwhile the much harder stuff goes undiscussed.
14:27:21 <lament> awesame: yes, but not without scars
14:27:24 <lament> awesame: hence py3k
14:27:25 <CosmicRay> awesame: funny, I feel that since 2001 python has gotten worse :-)
14:27:27 <awesame> it does that by ditching backward compatibility occassionally
14:27:37 <pejo> CosmicRay, talking about perl 4 -> perl 5?
14:27:41 <CosmicRay> pejo: yes
14:27:41 <dons> let's discuss which order arguments to fold should be next.
14:27:46 <Cale> Niklas Broberg went through a bunch of his code and claims that in the first 10 modules he looked at, there was only one $ which had to change, and in the largest module which he could find, which had 211 uses of $, only 23 of them needed to change.
14:27:48 <CosmicRay> pejo: of course there is perl6 at some point too
14:27:57 <dons> ok. so 10% of code breaks?
14:28:24 <Cale> And when it breaks, it's always consistently easy to fix up.
14:28:27 <halberd> http://www.bparkis.com/node/17
14:28:28 <lambdabot> Title: Concise Points-Free Functions | www.bparkis.com
14:28:42 <Cale> and it's always pointed out by the typechecker.
14:28:45 <dons> i'd be much more convinced if we had a package, and people used it.
14:29:08 <Cale> It's hard to replace the prelude functions.
14:29:30 <Cale> You have to import the prelude hiding things in every module you write
14:29:43 <dmwit> s/hard/annoying/
14:29:51 <dmwit> Which is, in some ways, worse.
14:29:55 <Cale> Yeah, annoying enough that nobody does it.
14:29:59 <chr1s> it's not just the packages that aren't compiling anymore.
14:30:06 <chr1s> also, all documentation has to be updated
14:30:08 <Cale> That doesn't mean that nobody wants to see the definitions in the Prelude change.
14:30:43 <chr1s> so that includes all web-pages. people will find outdated information and wonder the code doesn't wor
14:30:46 <chr1s> +k
14:31:11 <glguy> isn't this just a matter of adding two lines two the source file you want to use the new $ in?
14:31:15 <Cale> It won't work because it's Haskell 98 code and not Haskell 1.6 code (or whatever Haskell' ends up being)
14:31:32 <Cale> glguy: You also have to hide the Prelude one.
14:31:46 <Cale> glguy: It's enough of a hassle that nobody does it.
14:31:52 <chr1s> yes, but that's extremely annoying if you've just started to learn Haskell
14:31:58 <Cale> But it would affect the way people program.
14:32:47 <Cale> chr1s: The point is that existing Haskell 98 stuff doesn't really match up with what's implemented anymore either, which is why there's a new standard process, so people can write teaching materials relative to the new standard.
14:33:18 <Cale> So yeah, there'd be some period like after fromInt was removed, where you'd get questions from beginners, but the answer is always easy.
14:33:45 <halberd> actually this same technique doesn't just work for points-free functions, it can be made into a general concise way of representing any expression consisting of functions of fixed arity that are not higher order
14:34:34 <halberd> or at least whose types are such that one function taking the other as an argument would be incompatible
14:35:22 <halberd> it's really just a concise way to represent trees
14:36:16 <glguy> That adding three lines to a source file is too much of a hassle should tell us something about its value overall
14:36:33 <glguy> if three lines got me a solid associated types impl in 6.8.2 I'd use it
14:36:47 <dons> we have forM_ and mapM_
14:36:56 <dons> =<< >>+
14:36:58 <dons> =<< >>=
14:37:08 <dons> so why not two ($)
14:37:08 <glguy> >>+ ?
14:37:14 <dons> typo :)
14:37:25 <dons> we've a long tradition of providing options, not breakages.
14:37:27 <glguy> oh, I thought I'd just learned of some cool new monadic operator!
14:37:31 <yav> is this a new form of ascii art :-)
14:37:31 <dons> for library things.
14:37:39 <dons> >>+ hmm
14:39:01 <awesame> there's a lot of momentum behind any standard definition that makes people less likely to use an alternative even if they would prefer it
14:40:09 <awesame> for one thing, you don't necessarily want to wander off into speaking a different dialect from everyone else without thinking about it real hard
14:40:25 <nibro> Cale: indeed I did defend your position, but I would still prefer a new operator over changing the existing one
14:41:03 <lament> awesame: unless you're using Lisp
14:41:04 <nibro> but yes, I don't think the breakage will be half as bad as some people would have it
14:41:06 <Cale> nibro: My main problem with that is that there are not so many good keys left.
14:41:31 <nibro> Cale: I know and agree, but I would be fine with, say, $$
14:41:47 <lament> !!??$$..$$??!! is still available!
14:41:52 <Cale> Yeah, possibly. It also looks funny to have both available.
14:42:04 <Cale> Like, if we have $$, then what is $ for?
14:42:24 <Cale> (other than backwards compatibility)
14:42:38 <lament> python has a very similar issue with /
14:42:48 <Cale> division?
14:42:53 <lament> the division operator used to give an integer with integer operands
14:42:59 <Cale> ah
14:43:04 <lament> 3 / 4 = 0
14:43:10 <Cale> Yeah, I like Haskell's solution to that problem.
14:43:17 <lament> and now they want to change that
14:43:27 <Cale> Integer division is really a separate operation altogether.
14:43:29 <lament> so they actually will break backwards compatibility and make / return a float
14:43:40 <awesame> yeah
14:43:41 <lament> Cale: it's wholly different in python since it's dynamically typed
14:43:54 <lament> Cale: you don't know in advance if you get an integer or a float. It's stupid.
14:44:00 <awesame> and in the python community, people are really anxious for "from __future__ import division" to become the default
14:44:03 <Cale> I realise that, but it doesn't mean that they couldn't in principle have a separate function for integer division.
14:44:47 <lament> i think they will, called //
14:44:55 <Cale> (which it should be, since it's mathematically very different -- to the point where mathematicians strongly hesitate to use / for it.)
14:44:58 <lament> which is what made me think of it
14:45:05 <lament> the $ vs. $$ issue
14:45:07 <awesame> yeah, // is the new int division operator
14:45:10 <Cale> yeah
14:45:13 <lament> that's exactly how they did it
14:45:18 <lament> but it's clearly ugly :)
14:45:31 <Cale> Well, that's not so ugly.
14:45:41 <Cale> I might have called it div even.
14:45:47 <awesame> they did it the other way: changed the existing symbol, and introduced a new one to mean the old thing that you want less often
14:45:58 <Cale> right, that's good :)
14:46:09 <Cale> Does // work with floats, or does it error?
14:46:18 <nibro> how about <$ for left and $> for right, with $ = $> ?
14:46:20 <awesame> works with floats
14:46:35 <lament> Cale: playing with it, it seems to behave funny
14:46:51 <lament> Cale: it rounds the answer, but then converts it back to float
14:47:05 <Cale> nibro: It's really a hard call, but I think it's worth thinking about.
14:47:10 <awesame> it's int division on whatever types you applied it to
14:47:18 <awesame> so with floats, it returns a float
14:47:19 <lament> so 2.3 // 1.1 == 2.0
14:47:23 <awesame> but still does and int division
14:47:36 <Cale> nibro: Personally, I think there's going to be massive breakage regardless, and fixing the $'s won't really be so bad.
14:47:44 <Cale> (at least in programs, if not documentation)
14:48:00 <Jedai> nibro: but $> is already taken by Applicative (which is awesome)
14:48:43 <nibro> Jedai: right, I didn't consider that
14:48:45 <Cale> $$ would be a reasonable option if you were going to go the somewhat-annoying route of including both
14:49:23 <nibro> Cale: I don't see what's so annoying about that route - I can even find it an appealing option, allowing the choice of style to fit the code
14:50:13 <lament> in a way, $ itself is "including both"
14:50:36 <lament> you don't have to use it
14:51:12 <lament> with $$ we'd have three (four, with ., and probably more with possibly different combinations of $, $$ and .) different ways to do the same thing
14:51:15 <lament> ugly
14:51:48 <lament> we already have the a . b $ c versus a $ b c; imagine the combinatorial explosion of possibilities when $$ is added into the mess
14:51:56 <lament> i meant versus a $ b $ c
14:52:04 <lament> just ask ddarius
14:52:06 <sw17ch> has any one else played around with the new JSON library?
14:52:14 <damg> I would suggest adding the wtf operator (??!??) then...
14:52:53 <ddarius> @seen Cale
14:52:53 <lambdabot> Cale is in #haskell-overflow, #ghc and #haskell. I last heard Cale speak 4m 8s ago.
14:53:18 <nibro> I would like to see a Data.Function (or should that be Control.Function?) that has a lot more options than what the prelude has now
14:53:32 <ddarius> Cale: Have you heard of/read Jacque Carette's new paper on species and analytic functors and data types?
14:54:10 <nibro> in particular I would like to see the (.) = (*.*), and other versions like *.** and **.*
14:54:13 <Cale> ddarius: Yes, it's great :)
14:54:50 <ddarius> I started reading it, but only got to page 2 or 3 or so.
14:54:53 <Cale> ddarius: I've been thinking for a long time that it's only a matter of time before someone works this stuff out.
14:55:00 <nibro> f *.** g = \x y -> f (g x y)
14:55:15 <ddarius> Cale: Many people have been thinking that.  It's something that was coming.
14:55:24 <nibro> f **.* g = \x y -> f (g x) y
14:56:50 <Cale> @unpl (f .) . g
14:56:50 <lambdabot> (\ d i -> f (g d i))
14:56:58 <nibro> hmm, that didn't seem quite right, that would make *.** the same as .
14:57:13 <Cale> other one :)
14:57:45 <nibro> Cale: I wasn't referring to your example, but to my own suggested definition :)
14:58:03 <Cale> nibro: I mean it's **.* which is equivalent to .
14:58:14 <nibro> right, doh :)
14:58:18 <Cale> (after eta reduction)
14:58:54 <nibro> it's *.** I really find lacking though
14:59:40 <nomeata> Cale: hi. You are maintaining the darcs repo ATM, right?
14:59:46 <nomeata> eh, lambdabot that is
14:59:49 <Cale> nomeata: yeah
14:59:58 <Cale> nomeata: have a patch for me? :)
15:00:17 <nomeata> Cale: yes, but I sent it to dons before, itâs on http://darcswatch.nomeata.de/repo_http:__code.haskell.org_lambdabot.html or I can send it to you again.
15:00:19 <lambdabot> Title: DarcsWatch overview for http://code.haskell.org/lambdabot, http://tinyurl.com/6ma66u
15:00:26 <nibro> @type (.)
15:00:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:00:35 <nibro> send him a patch to fix that :-p
15:00:51 <nomeata> Cale: GET http://darcswatch.nomeata.de/20080409200126-23c07-0d4c9732c60e72e5f9a74f1ff877be7a822a068a.dpatch | darcs apply # this should work
15:00:51 <lambdabot> http://tinyurl.com/65vcus
15:00:57 <Cale> nomeata: yep
15:01:43 <nomeata> Cale: and http://code.haskell.org/lambdabot/_darcs/prefs/email is not yet pointing to you
15:01:47 <Cale> ah
15:02:47 <Cale> Is it safe to just edit that file by hand, or do I have to run darcs to change it?
15:03:18 <nomeata> Cale: I think its safe to edit it
15:03:52 <nomeata> Cale: I donât think its written anywhere automatically, and only read by darcs send (at least Iâd expect that)
15:04:46 <dcoutts_> nominolo: any luck?
15:05:23 <nominolo> no, but i'm too tired to think straight
15:05:26 <dcoutts_> :-)
15:05:30 * dcoutts_ knows that feeling
15:05:41 <dcoutts_> nominolo: g'night then
15:05:46 <nominolo> i'm going to try again tomorrow
15:05:49 <Cale> nomeata: done :)
15:06:13 <nomeata> Cale: merci
15:06:13 <dcoutts_> nominolo: do ping me when you want to look at it, we can look at it together
15:25:26 <nominolo> dcoutts_: i somewhere seem to discard the second if
15:25:31 <nominolo> not sure why, yet
15:46:29 <dcoutts> nominolo: sounds like a good start :-)
15:46:30 <Jedai> @src partition
15:46:31 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
15:46:31 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
15:46:31 <lambdabot>                               | otherwise = (ts, x:fs)
15:47:22 <Jaak> lovely
15:52:49 <Gnezdo> does anybody know how to determine the userid (better yet user name) of the unix process running the haskell program?
15:53:25 <TomMD> From within the haskell program, I assume?
15:54:01 <Gnezdo> yes
15:55:37 <Gnezdo> System.Posix.User seems to be the answer
15:55:59 <Gnezdo> too bad hoogle finding it
15:56:09 <TomMD> Hoogle doesn't return POSIX results
15:56:21 <Zao> I find the index at  http://www.haskell.org/ghc/docs/latest/html/libraries/index.html  rather useful.
15:56:21 <TomMD> Intentional behavior by ndm
15:56:22 <Gnezdo> ouch
15:56:33 <TomMD> yes, certainly is great use.
15:56:41 <orzo> how do i read members of class Storable from a file handle?
15:57:04 <TomMD> Gnezdo: I can't seem to find an OS neutral way to do it - but if you do shout something out on IRC as I would like to know.
15:57:07 <Zao> I just used unsafePerformIO. I feel dirty now.
15:57:37 <Gnezdo> thanks TomMD, I'm content with Posix
15:58:09 <Zao> I wonder what side effects inet_ntoa could possibly have that warrants it being in IO.
15:58:16 <TomMD> sounds like another System module is needed to fill this gap.
15:58:43 <TomMD> Zao: I would bet it is a call to the 'C' inet_ntoa
15:58:49 <TomMD> Which uses a global buffer.
15:58:53 <orzo> @hoogle handle -> Storable
15:58:53 <lambdabot> Did you mean: Handle -> Storable
15:59:01 <xd> you could write your own pure version pretty easily
15:59:04 <orzo> @hoogle Handle -> Storable
15:59:04 <lambdabot> No matches, try a more general search
15:59:19 <orzo> @hoogle Storable a => Handle -> a
15:59:19 <lambdabot> No matches, try a more general search
16:00:00 <TomMD> xd: The fact that no one has done so is unfortunate.  I view haskells lack of good/native network and crypto libs like the lack of serialization once was.
16:00:02 <cjs_> Hey, dudes, I've got some guy claiming that the "exponential conflict" issue with Darcs 1.9 is not fixed in 2.0. Am I missing something here?
16:00:16 <Zao> That should probably be safe for my application.
16:00:25 <Saizan> ?hoogle hgetbuf
16:00:25 <lambdabot> System.IO.hGetBuf :: Handle -> Ptr a -> Int -> IO Int
16:00:25 <lambdabot> System.IO.hGetBuffering :: Handle -> IO BufferMode
16:00:25 <lambdabot> System.IO.hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
16:00:53 <wagle> i bet inet_ntoa returns the string in a static buffer
16:01:04 <Zao> wagle: It does.
16:02:08 <orzo> hgetbuf is ok, but i'd like a higher level instead of giving it a pointer
16:02:23 <TomMD> It makes me wonder if there is a race when returning results using two threads of inet_ntoa.  I could test... I could read the FFI report to ease my concern... or I could get dinner.
16:02:44 <orzo> Handle -> Word16
16:02:47 <orzo> something like that
16:03:30 <Zao> I thankfully only call it from a single thread, and return a strict result from the sneaky function.
16:03:39 <Zao> So hopefully *crosses fingers* I should be safe.
16:03:57 <wagle> Zao, well then, you have to consume the value and "release" it before you call it again..  (i saw one lib routine rotate through 4 static buffers)
16:05:30 <Zao> wagle: Safe enough? http://hpaste.org/7138
16:05:36 <ehird> So say there was a binary operator on something whose mnemonic was /, but not a number -- it's just a mnemonic
16:05:41 <ehird> What should it be defined as? </>?
16:06:31 <wagle> Zao, i dunno..  i know what to worry about, but not how to worry about it in haskell
16:07:30 <Zao> The question is naturally open for everyone :)
16:09:50 <vincenz> Zao: unsafeperformio == illegal
16:09:53 <vincenz> Zao: stated in another way
16:10:09 <vincenz> Zao: the only time you're allowed to use it is when you do not need to ask whether you may use it
16:10:30 <dzlk> Ceiling Cat is watching you unsafePerformIO.
16:10:33 <cjs_> Zao: use it when you don't care so much if it works.
16:10:36 <bd_> inet_ntoa shouldn't be in IO
16:10:53 <bd_> I mean, it should be implemented with unsafePerformIO built in with the necessary locks etc
16:11:18 <wagle> bd_, i bet inet_ntoa returns the string in a static buffer
16:11:25 <ehird> Zao: that's not safe!
16:11:33 <bd_> wagle, it does. However the haskell-side stuff should fix that (in a perfect world)
16:11:34 <Zao> ehird: Please elaborate?
16:11:43 <bd_> or better yet, just implement it in haskell!
16:11:43 <ehird> Zao: well, it's just a plain jane IO function
16:11:46 <ehird> being unsafely performed
16:11:48 <ehird> So ...
16:11:52 <wagle> i can imagine (wacked out) evaluation orders that'd break it
16:12:10 <bd_> Zao: anyway, assuming it's (inet_ntoa :: something -> IO String) it's not safe in the threaded RTS
16:12:21 <bd_> as another thread may invoke it at the same time
16:12:29 <wagle> bd_, make one thats not racey (locks i guess)
16:12:33 <ehird> Zao: Visually, though, the code look snice. :P
16:12:41 <ehird> *looks nice
16:12:43 <Zao> bd_: That is not an issue in my application though.
16:12:51 <bd_> wagle: wrong answer; the correct solution is to implement it in haskell. It's a very trivial function :)
16:12:52 <ehird> Zao: but it might become one
16:12:56 <ehird> you have to think about the future..
16:13:05 <ehird> that's what haskell is all about
16:13:18 <lament> that's why it's statically typed!
16:13:18 <Zao> ehird: I have a complete system design, and the system is final :)
16:13:23 <wagle> bd_, fine, reimplement glibc
16:13:34 <ehird> Zao: designs are never final
16:13:36 <bd_> wagle: No need to reimplement all of glibc, only the functions which are unusably broken
16:13:52 <Zao> But otherwise, yes, it'd be silly to do this hack.
16:13:52 <bd_> wagle: you simply /cannot/ use inet_ntoa in any kind of library whatsoever
16:14:38 <bd_> Zao: anyway, just use Data.Bits + show to reimplement it, it's much safer
16:16:19 <wagle> ... until the definition of struct in_addr changes
16:16:57 <bd_> wagle: in_addr's definition is documented in ip(7) as containing a single uint32_t
16:17:00 * wagle would love to reimplement the world, its just way harder than it looks
16:17:24 <bd_> wagle: using inet_ntoa is harder than reimplementing it, I'd argue
16:17:32 <bd_> unless your particular implementation uses thread-local storage
16:17:51 * wagle watches the nickels and dimes blow away
16:17:54 <bd_> even then it's more painful than it needs to be, particularly in haskell where haskell threads can roam to different OS threads
16:18:26 <MarcWeber> dcoutts: I've read about your actionWatcher idea (only allow writing to dist). Would this be implemented similar to the gentoo sandbox (or just examine a strace like log) ?
16:18:32 <Zao> bd_: Done :)
16:18:42 <dcoutts> MarcWeber: as a monad
16:19:08 <Zao> Seems like nothing stimulates discussion as unsafety :)
16:19:10 <dcoutts> MarcWeber: so readFile is an action in the monad and it has to pass muster with the monad's action supervisor
16:19:21 <wagle> i think there's gobs of functions b0rked like inet_ntoa
16:19:31 <bd_> wagle: and they're all bugs in the RTS, I'd argue
16:19:36 <bd_> or in the base library
16:19:38 <dcoutts> MarcWeber: for external processes it's obviously a lot harder, one would have to use strace etc
16:20:11 <dcoutts> MarcWeber: I do have code to analyse a strace log after the even and check if it was ok, but that only helps for debugging not security
16:20:30 <bd_> so if the choice is between using a broken library function, or using a trivial reimplementation, well.
16:21:11 <dcoutts> MarcWeber: so yes like a sandbox for the haskell bits and examining an strace log for external processes
16:21:12 <wagle> price of no garbage collector...  i suppose the (ahem, caff caff) "correct" solution is to allocate the static in thread local storage..  which would still have problems with some lazy evaluation strategies
16:21:46 <MarcWeber> dcoutts: Using strace like features would be cool, but not portable :( warning the auther that something has gone wrong is a bit step.. But tmp must be read/ writable because ghc does use it itself.. Or symlink all used applications and chroot :)
16:21:55 <bd_> wagle: from the POV of glibc, yes, putting it in a __thread is best. Then on the GHC side you'd need a wrapper to make sure you can marshal it into the haskell heap before you're rescheduled
16:22:06 <Jedai> @src merge
16:22:07 <lambdabot> Source not found. :(
16:22:12 <bd_> this assumes we're forced to work with the existing C API
16:22:13 <Jedai> @hoogle merge
16:22:14 <lambdabot> Control.Concurrent.mergeIO :: [a] -> [a] -> IO [a]
16:22:14 <lambdabot> Text.ParserCombinators.Parsec.Error.mergeError :: ParseError -> ParseError -> ParseError
16:22:14 <lambdabot> Control.Concurrent.nmergeIO :: [[a]] -> IO [a]
16:22:24 <wagle> ... still have the gap of getting the static buffer and later copying its value into the heap
16:22:37 <dcoutts> MarcWeber: my code for analysing straces already can account for temp files and allow or disallow them depending on policy
16:22:52 <MarcWeber> dcoutts: But it's not only about building code.. also about using it later on. And we can't protect against everything because we can't read each single line of code (we just hoope all the time nobody has added unsafePerformIO $ system "rm -fr /" ) somewhere..
16:22:56 <bd_> wagle: sure, but if the static buffer is thread-local, that's not a problem. Unfortunately it's /not/ thread-local, and so we can't actually use that function in the threaded RTS. At all.
16:23:08 <bd_> (because it might break C libraries, or an embedding C app)
16:23:15 <dcoutts> MarcWeber: sure, it's not a security thing
16:23:55 <dcoutts> MarcWeber: it's for checking ordinary build code that is trying to do the right thing, not deliberately malicious code
16:24:50 <dcoutts> MarcWeber: and yes the strace code is certainly not portable, but just using it in debug runs on linux would help to improve quality enormously on all platforms
16:25:17 <dcoutts> MarcWeber: as you know from nix, tracking dependencies really carefully is really important to a reliable build/packaging system
16:25:41 <wagle> i think you want some sort of strictness annotation that says that the whole call must be driven to completion before the thread progresses
16:26:34 <wagle> dont think unsafeperformio is that annotation..  maybe seq?  (i dont understand the full implications of seq, etc)
16:27:34 <wagle> (like is WHNF seen as "completion"?)
16:27:39 <allbery_b> seq only goes to whnf.  Control.Parallel.Strategies may have something useful
16:28:02 <MarcWeber> dcoutts: It would be cool to extend franchise to make it create cabal files
16:28:19 <dcoutts> MarcWeber: it's not clear to me that that is possible
16:28:35 <dcoutts> MarcWeber: a Setup.hs is essentially opaque
16:29:02 <dcoutts> a .cabal file declares a lot of info, it enables a conversation between the environment and the package to arrive at a configuration
16:29:25 <bd_> wagle: You still have the problem that the function may be entered from C libraries.
16:29:26 <MarcWeber> dcoutts: Of course it can't.. But if you feed in a list of exposed modules it can try figuring out the pacakges to be used on its own. Of course that's it's only a lazy solution for some trouble..
16:29:28 <bd_> (unfortunately)
16:29:43 <bd_> wagle: and afaik there is no annotation to prevent a thread from migrating
16:30:00 <dcoutts> a franchise Setup.hs does not, it assumes the environment is static and tries to make the package build in that environment. It doesn't tell the package manager what it needs, it just tries to make do by turning off optional features etc.
16:30:34 <dcoutts> MarcWeber: cabal should be able to do that too, it's on the TODO list
16:30:49 <Heffalump> I wish people would stop building language-specific build tools
16:31:02 <dcoutts> MarcWeber: ie you'd say: cabal build Foo without even having a .cabal file and it does what ghc --make does and picks a set of packages to use
16:31:13 <dcoutts> Heffalump: there are a lot of language specific problems
16:31:28 * wagle dusts off his old "c must die" banner, and goes out marching the streets
16:32:12 <wagle> bd_, yeah, blech
16:32:23 <dcoutts> Heffalump: I've used autoconf+automake for haskell, it requires a lot of work to add support for a language to the point where it becomes convenient
16:33:00 <Heffalump> well, apart from the explicit vs implicit dependency design decision, it would at least fit into the rest of the world better
16:33:22 <Heffalump> it's not just that it hinders multi-language projects, it's also a barrier to people coming at a language from outside
16:33:25 <jorick> how does lambdabot execute haskell?
16:33:43 <Heffalump> jorick: forks a process with a time limit and reads the results over a pipe
16:33:44 <bd_> wagle: so anyway, in short, it's a bug that a perfectly good pure function is limited by an impure function that's unsafe even in IO.
16:33:47 <dcoutts> Heffalump: there's no particular reason we cannot provide wrappers so you can ./configure and make install
16:33:50 <bd_> impure implementation*
16:33:56 <jorick> aww
16:34:10 <MarcWeber> dcoutts: franchise says it can compile similar to make -j4.. But I guess the right thing to do would be making ghc beeing able to compile on multiple cores (I guess a lot more work.. ) because you don't have to restart ghc and ghc could cache data in memory, right?
16:34:21 <Heffalump> dcoutts: that wouldn't help with a mixed python/haskell program (say)
16:34:33 <jorick> i'd like to make an extensible irc client in haskell, i was hoping i could have the scripting language also be haskell
16:34:46 <dzlk> It's being done. There are packages that come with "./configure && make" as a wrapper around Cabal (can't remember which ones, offhand).
16:34:53 <wagle> bd_, use uniqueness types to insure that no more than 4 "threads" use it at the same time..  1/2 j.k
16:35:20 <bd_> wagle: or write a trivial reimplementaiton :)
16:35:30 <bd_> a pure one, rather
16:35:33 <dcoutts> Heffalump: no, but that is actually rather hard in any system. Having decent support for haskell and python in a single language independent system is a huge amount of work. I've not seen it done well anywhere. autoconf+automake comes closest
16:35:34 <wagle> there are gobs of these functions
16:35:50 <wagle> and new ones being produced
16:36:25 <cjs_> Heffalump: having dealt with a bunch of these, "Thank God for Cabal." It's done more to make my life easy than hard in a multi-language world.
16:36:31 <dzlk> You can always use make when you can and a language-specific tool where you must (or vice-versa). It's much easier to do well than design a single build system that's good for every language in the world.
16:36:52 <dcoutts> Heffalump: and with my distro packageing hat on I claim that autoconf based systems are not very helpful, they make all kinds of opaque automagic decisions and tracking the dependencies they pick up requires a lot of manual delving into configure.ac files
16:37:16 <Heffalump> I think I agree that explicit dependencies are better.
16:37:32 <dcoutts> MarcWeber: we're doing a GSoC project to do a make-like system for cabal with one aim being to do parallel builds
16:37:36 <bd_> wagle: but when they're exported into the RTS, that is a bug.
16:37:50 <Heffalump> so what are the Haskell-specific problems?
16:38:04 <MarcWeber> Heffalump: You know about scons, do you ? :) But kde switched over to cmake
16:38:10 <bd_> s/RTS/haskell libraries/
16:38:36 <wagle> bd_, does "export into the RTS" freeze the C source code?
16:38:36 <Zao> cmake needs haskell support.
16:38:55 <Zao> Embedding Haskell into C++ becomes a bit tricky when mixing build systems.
16:38:58 <bd_> wagle: s/RTS/haskell libraries/ :)
16:38:59 <wagle> ... or do you have to go check every time the underlying source changes?
16:39:00 <Heffalump> I'm not particularly familiar with any of the make-alternatives around.
16:39:06 <dcoutts> Heffalump: the notion of packages, checking dependencies are satisfied, language extensions, discovering module dependencies
16:39:09 <bd_> wagle: eh? inet_ntoa is in libc.
16:39:38 <Heffalump> dcoutts: none of those are Haskell-specific concepts, though
16:39:45 <Zao> bd_: My solaris man pages claim -lsocket and -lnsl
16:40:03 <dcoutts> Heffalump: perhaps, but all need to be coded into a support library for your language independent build system
16:40:11 <wagle> bd_, the source code for libc changes
16:40:20 <bd_> Zao: okay, it's in some sort of system library :)
16:40:39 <Heffalump> only to tell it how to invoke the compiler
16:40:47 <Zao> I also doubt that I could get my paws on the libc implementation for this AIX box here.
16:40:51 <bd_> wagle: we dynamically link... it doesn't matter. Point is if we just take these broken semantics and import them wholesale into haskell, that's a bug.
16:40:57 <wagle> bd_, by the way, i dont fundamentally disagree with you, i'm just more cynical
16:41:13 <dcoutts> Heffalump: and to generate package registration info and register things, there's a lot of meta data
16:41:20 <bd_> wagle: well, my main point is people should engage their brain before doing a foreign import :)
16:41:27 <dcoutts> Heffalump: the configurations system we have is rather novel I think
16:41:42 <dcoutts> though it's not language specific in concept
16:42:11 <Heffalump> what's novel about it?
16:42:30 <MarcWeber> dcoutts: Don't think C people like to install haskell to build their buildsystem *lol*
16:42:40 <wagle> bd_, my point is that a re-entrant C library function could turn non-re-entrant when its source code changes
16:42:44 <Heffalump> MarcWeber: they generally don't build make from source, either
16:42:57 <dcoutts> Heffalump: the way we discover a valid configuration for your system either locally for one package or globally for a set of packages
16:43:00 <MarcWeber> Heffalump: Try and error: If a dependency can't be met toggle this flag and try again.. do so till everything has been tried and give up
16:43:15 <bd_> wagle: and this is why you should only trust that it's reentrant if it's documented to be (or can reasonably be assumed to be - raw syscalls, malloc and friends on a sane libc, sort of thing)
16:43:20 <wagle> so if you import it now, it might break later
16:43:24 <MarcWeber> dcoutts: Think about hooks :)
16:43:33 <daveux> Hey, I stopped by earlier looking for some help with creating a percussion music engine in Haskell.
16:43:37 <cjs_> Actually, the NetBSD build system always builds make from source.
16:43:46 <daveux> Does anyone here know about generating music with Haskell?
16:43:51 <johnnowak> daveux: there are haskell bindings for supercollider
16:43:52 <cjs_> (I'm not saying that using make is a good thing.)
16:43:53 <Heffalump> my argument would be rather stronger if there was a decent language-independent build system I could point to
16:44:07 <johnnowak> daveux: http://www.slavepianos.org/rd/f/207949/
16:44:09 <lambdabot> Title: rd: hsc3
16:44:10 <dcoutts> Heffalump: yes, if there was we might be using it
16:44:16 <cjs_> daveux: what do you want to know? I know a little bit about Haskell, and a lot about computer music.
16:44:28 <dzlk> Heffalump: that fact in itself might suggest something :)
16:44:30 <dcoutts> Heffalump: nix might come close
16:44:30 <Heffalump> what we need is a meta-system that can import descriptions from lots of language-specific ones :-)
16:44:37 <Heffalump> dcoutts: yeah
16:44:38 <dcoutts> Heffalump: indeed
16:45:24 <dcoutts> Heffalump: I think our inter-language issues will be a bit easier to deal with once cabal uses a dependency framework internally
16:45:44 <dcoutts> I think we'll be able to integrate better with foreign build systems then
16:46:06 <daveux> cjs_, supercollider might work for us
16:46:08 <daveux> we
16:46:15 <johnnowak> cjs_: what are you using for cm?
16:46:21 <wagle> malloc/free is safe?
16:46:23 <daveux> we're basically just looking to make a drum machine
16:46:32 <johnnowak> daveux: sc is more than sufficient
16:46:50 <johnnowak> although if you just want a drum machine, picking something like pure data might get you to a solution much more quickly
16:46:52 <daveux> does sc have instrumental sounds?
16:47:01 <cjs_> Not much lately. But basically, I'm in the cmusic camp.
16:47:02 <johnnowak> if you load instrumental sounds
16:47:04 <daveux> we have some Reichian stuff going in MIDI that we want to stick with
16:47:44 <johnnowak> sc can do most anything you'd want, it just a matter of how long it takes you to get it to do it
16:47:46 <cjs_> Ah, ok, so you're in the "notes" thing rather than the "generate waveforms" thing.
16:48:35 <daveux> cjs_, yes
16:48:50 <johnnowak> daveux: if you just want to play back midi and have percussion, you're almost certainly better off using pre-built tools
16:48:54 <daveux> I think sc might be overkill, actually
16:49:07 <daveux> johnnowak, not if we want to get a grade :)
16:49:13 <daveux> It's a school project
16:49:23 <daveux> to make an interesting Haskell music maker
16:49:24 <cjs_> I've done lots of MIDI stuff, but didn't write that much that dealt with it. I was more playing with FFTs and suchlike.
16:49:34 <johnnowak> daveux: where are you attending out of curiosity?
16:49:35 <cjs_> johnnowak is probably right there.
16:49:40 <daveux> UPenn
16:50:11 <cjs_> Did you read the stuff in _Haskell School of Expression_? That was pretty well done.
16:50:34 <daveux> Yes, we read that. It doesn't do exactly what we're looking for.
16:50:54 <johnnowak> do you have to use haskell?
16:51:10 <daveux> well, we can use any functional language
16:51:17 <johnnowak> there are scheme sc bindings as well
16:51:48 <cjs_> Well, that's good. At least if you do what you want to, your prof isn't going to accuse you of plagiarising.
16:51:52 * johnnowak is trying to decide between computer music (something like ccrma) and computer science for his graduate studies
16:51:53 <daveux> we'd prefer to stick with haskell. I mean, we pretty much have everything we need. We just need to understand midi a bit more. We basically want to keep pushing midi events at our sound card.
16:52:12 <wagle> daveux, you seen haskore?
16:52:35 <cjs_> So what do you want to do, then? I'm getting the impression it's based on subdivided tempos, and you don't have to worry about pitch.
16:52:36 <daveux> Yeah, we are playing with it. Haskore atomically writes a midi event stream to a file and plays the file
16:53:18 <daveux> cjs_, we want a default beat on loop, and we want to assign different percussion instruments to keys on the keyboard
16:53:24 <daveux> the user listens to the loop
16:53:33 <cjs_> Oh, MIDI I can tell you a bit about, though perhaps not how Haskell talks to it.
16:53:35 <daveux> and by pressing keys, adds midi events to the stream
16:53:35 <johnnowak> (is there a cm-related channel on freenode?)
16:54:47 <cjs_> daveux, I'm probably not quite getting this yet. But the assignment seems easy, key events are just key events after all (up and down, and key number). But what's the "default beat on a loop" thing?
16:55:48 <cjs_> Oh, wait, I might understand this. Basically, you want to build up patterns interactively, right? So you can add (and, I hope, delete) beats to the ongoing pattern?
16:55:54 <dzlk> by adding events do you mean once per keypress so that you're "playing the keyboard" (hrr. sorry) or do the keyed instruments get added to the loop? (or both?)
16:55:55 <wjt> If I'm using a URI of the form "http://user@pass:foo.com/..." with Network.HTTP's simpleHTTP, should I need to pass any headers, or anything in the request body, for authentication to work?  parseURI understands the URI string just fine as far as I can tell.
16:55:57 <daveux> exactly
16:56:12 <daveux> dzlk -- both
16:57:08 <daveux> I think we would have stock midi files ready for quick playback when a key press occurs for instant feedback, but we'd also like to add the MIDI events that these key presses correspond to to the main music loop.
16:57:11 <cjs_> Ok, well, that doesn't seem so hard. So are you looking at just implementing the basic idea, or are you dealing with the issues of how you'd deal with this kind of thing in performance (which I've put a bit of thought into, by the way)?
16:57:43 <dzlk> ah, hm. I've been wanting an interface like that to push pre-made samples out the soundcard in a live setting.
16:57:52 <cjs_> BTW, are you familiar with the LinnDrum and the Akai things that Bob Linn did after that?
16:58:03 <daveux> cjs_, no.
16:58:23 <daveux> ï»¿cjs_, we are just looking to put a basic system together and demo it for our class -- if that's what you mean by performance.
17:00:11 <johnnowak> well that's not very exciting!
17:00:17 <daveux> Why not?!
17:00:22 <daveux> I think it's cool.
17:00:27 <daveux> What more do you want from us?!
17:00:33 <cjs_> If you can possibly get your hands on an Akai MPC, you'll find it very interesting, if you're into this kind of stuff.
17:01:40 <cjs_> But anyway, my recommendation is, for a basic demo, just a sequencer in an 8-bar loop, and an input device that let's you play on top, and repeats what you played in the previous loop.
17:02:16 <daveux> A 'sequencer'?
17:02:29 <cjs_> Oh, and you very, very, very much want quantization, and pretty heavy, if you want to impress anyone.
17:02:52 <daveux> That's what we're trying to figure out. Suggestions?
17:03:03 <daveux> RIght now our best solution is forkIO and generating midi files
17:03:07 <daveux> and playing them concurrently
17:03:14 <johnnowak> use a quantizer
17:04:28 <pizza_> what's a quantizer? some sort of futuristic weapon?
17:04:59 <cjs_> daveux, ok, we have a bit to talk about here. Should we take this to another channel? It's going to be a lot of electromusic stuff.
17:05:01 <johnnowak> they can  be   use- ful
17:05:52 <cjs_> pizza_, A quantizer moves your notes that are slightly off the beat on to the beat. So you sound less like a really bad player, and more like a robot. :-)
17:06:25 <pizza_> i already sound like a robot. end statement.
17:06:27 <cjs_> daveux: Hmm. I'm not sure I'd recommend forkIO and playing MIDI files with something else.
17:07:04 <cjs_> Keep in mind, if you've got the drivers or whatever, MIDI is basically a network interface like any other. It's just a 32.27whatever Kbps serial line.
17:07:09 <mofmo1> @seen cale
17:07:09 <lambdabot> cale is in #haskell-overflow, #ghc and #haskell. I last heard cale speak 2h 1m 20s ago.
17:08:27 <mofmo1> so i have  a function that renders text- specifically ansi escape sequences. Apparently it's REALLLY slow. I've therefore buffered the output and have used explicit flushes to only print once per frame (instead of multiple unbuffered outputs) but this is still pretty slow
17:08:31 <dzlk> Hmm. IMHO, alf the fun of doing live loop-guitar improv is knowing that if you goof, you're stuck with it for the next several bars ;)
17:09:03 <cjs_> Anyway, what might help is to find a stand-alone "MIDI sequencer," which is what we used to use way back when to record MIDI stuff, and get a sense of what it does.
17:09:19 <mofmo1> dzik: kind of like Mountain Jam... there's this one part where one of the guitarists makes an obvious mistake and he just plays off of it
17:09:37 <mofmo1> you can fix a mistake by doing it twice and pretending like you meant it :-P
17:09:57 <dzlk> Interesting and good things can happen that way.
17:10:43 <dzlk> (hm, maybe I should have said "and/or".)
17:10:49 <Cale> mofmo1: I think the next thing to try is to turn that code into something which constructs a Data.ByteString and then putStr's it all in one go.
17:11:18 <cjs_> daveux: but thinking about it, if there are going to be problems with the interface issues, you might be better of working on something that generates MIDI files (in non-real-time) and the someone plays them back later.
17:12:09 <daveux> yeah, that's what we've got right now, and it's clunky but I think it will just work
17:13:01 <mofmo1> Cale: i've cut it down to 75%
17:13:12 <mofmo1> (wow this profiling option is cool!)
17:13:24 <Jedai> daveux: alsa-midi seems to be a package that allows you to do some MIDI stuff (if I'm not mistake, I know next to nothing in this field)
17:13:55 <cjs_> Isn't that actually a synthesizer that plays MIDI events?
17:14:04 <daveux> We would really like to be able to do this in haskell: http://www.youtube.com/watch?v=jX8XYc0ATdY&feature=related
17:14:05 <lambdabot> Title: YouTube - beamz Music Performance System
17:14:44 <Jedai> cjs_: Hmm, yes
17:14:54 <johnnowak> daveux: why?
17:15:15 <daveux> I'm just kidding. We were just looking for haskell midi screencasts on youtube.
17:15:26 <Jedai> I think so (is that what is needed here or not ? it seemed like it from my flawed understanding)
17:15:29 <dolio> Those guys in the "jam with your buddies" section look like cool dudes.
17:15:47 <johnnowak> whew
17:16:19 <johnnowak> daveux: sorry, i've run into too many people that actually would think that's cool
17:16:36 <daveux> haha, well it's in SkyMall for a mere $600
17:16:39 <mofmo1> cale: for some reason xydToi takes 15% which surprising as it's all arithmetic operators
17:16:52 <johnnowak> nice
17:17:25 <ertai> @src Forest
17:17:26 <lambdabot> Source not found. I am sorry.
17:19:13 <Trinithis> what is a good haskell debugger?
17:19:51 <mauke> ghci
17:19:54 <Jedai> Trinithis: GHC has a simple haskell debugger builtin
17:19:59 <johnnowak> a grad student
17:20:01 <Jedai> In the latest version
17:20:16 <Trinithis> oh, okay
17:20:44 <codetoad> i'm getting a type error when trying to use quickcheck to check for an exception, in some cases..but i don't know why.  i'm taking my lead from the xmonad tests:  http://hpaste.org/7139
17:22:05 <codetoad> when i add in the appropriate return's it will just dump the exception rather than handle it in the catch
17:22:37 <EvilTerran> ?type catch
17:22:39 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
17:22:53 <EvilTerran> ?type (minimumsBy cmp [])
17:22:54 <lambdabot> Not in scope: `minimumsBy'
17:22:54 <lambdabot> Not in scope: `cmp'
17:23:09 <EvilTerran> well, it's [a], isn't it
17:23:14 <codetoad> yeah
17:25:02 <EvilTerran> anyway, catch takes an IO action in its first parameter
17:25:02 <codetoad> yeah, but it shoul dbe an io action
17:25:03 <codetoad> because it throws an exception when given []
17:25:04 <EvilTerran> ... but an IO action's got to have an IO type
17:25:04 <codetoad> e.g. that code works for the first case, with randLoser
17:25:04 <EvilTerran> that's what makes it an action...
17:25:04 <codetoad> why would that be?
17:25:05 <EvilTerran> randLoser has return type "a", which can be specialised to "IO a"
17:25:10 <EvilTerran> while [a] can't
17:25:18 <codetoad> hm
17:25:28 <codetoad> so how can i test for exceptions on certain input?
17:26:05 <Jedai> codetoad: You can use "evaluate" from Control.Exception to turn pure code into IO action
17:26:07 <EvilTerran> is "C.catch (return (minimumsBy cmp []))
17:26:07 <EvilTerran> " not satisfactory?
17:26:16 <shapr> @users
17:26:16 <lambdabot> Maximum users seen in #haskell: 460, currently: 420 (91.3%), active: 17 (4.0%)
17:26:18 <shapr> hmm
17:26:18 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
17:26:26 <shapr> oh
17:26:30 <EvilTerran> ah, i see
17:26:36 <codetoad> EvilTerran: it doesn't work right that way
17:26:56 <EvilTerran> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#7 <- it needs more strictness
17:26:56 <lambdabot> http://tinyurl.com/sqmlj
17:27:06 <Jedai> codetoad: use evaluate
17:27:17 <codetoad> EvilTerran: i tried doing `seq` return False...
17:27:23 <codetoad> Jedai: ok, will try :)
17:27:34 <EvilTerran> it might not be forcing far enough, even with that
17:28:06 <EvilTerran> seeing as `seq` doesn't force its first parameter in full when it's forced, only as far as the first/outermost constructor
17:28:11 <Jedai> EvilTerran: In this case I guess it's Control.Parallel.Strategies, isn't it ?
17:28:11 <EvilTerran> > undefined `seq` `
17:28:12 <lambdabot>  Parse error at "`" (column 17)
17:28:13 <EvilTerran> > undefined `seq` 1
17:28:15 <lambdabot>  Exception: Prelude.undefined
17:28:20 <EvilTerran> > Just undefined `seq` 1
17:28:21 <lambdabot>  1
17:28:33 <EvilTerran> Jedai, yes, that would be appropriate if a deepSeq is needed
17:28:36 <Jedai> You can use rnf from this library
17:31:56 <codetoad> do i just use evaluate (minimumsBy cmp []) (\e ...) ?
17:32:49 <EvilTerran> evaluate instead of return, not instead of catch
17:32:52 <Jedai> codetoad: That should work
17:33:11 <Jedai> With the catch around of course...
17:33:16 <Jedai> @type evaluate
17:33:17 <lambdabot> forall a. (Testable a) => a -> Gen Result
17:33:31 <EvilTerran> Jedai, and more parens
17:33:31 <Jedai> @type Control.Exception.evaluate
17:33:31 <BMeph> EvilTerran: "let cowbell = strictness in 'needs more cowbell" ;)
17:33:32 <lambdabot> forall a. a -> IO a
17:33:33 <EvilTerran> <lambdabot> Control.Exception.evaluate :: a -> IO a
17:33:45 <EvilTerran> :)
17:34:16 <Jedai> ^^
17:34:25 <codetoad> ah, i was using the wrong evaluate :p
17:36:43 <codetoad> http://hpaste.org/7139#a2 not sure what's up :/
17:38:16 <codetoad> I think it's because it needs to return Bool, not [Bool]
17:41:02 <shapr> @yow !
17:41:02 <lambdabot> I used to be a FUNDAMENTALIST, but then I heard about the HIGH
17:41:02 <lambdabot> RADIATION LEVELS and bought an ENCYCLOPEDIA!!
17:42:02 <dolio> @b52s
17:42:02 <lambdabot> Girl from Ipanema, she goes to Greenland
17:42:12 <codetoad> using head and specializing cmp to just 'compare' works
17:42:16 <dolio> There aren't many of those, are there?
17:42:19 <codetoad> thanks guys:)
17:42:29 <codetoad> on my way to 100% :P
17:45:04 <shapr> @b52s
17:45:04 <lambdabot> She drove a Plymouth Satellite faster than the speed of light!
17:45:31 <dolio> @girl19
17:45:32 <lambdabot> I'm in Moscow, Russia
17:45:46 <MyCatVerbs> shapr: what the Hell is b52s?
17:46:04 <dolio> Quotes from songs by the B52s.
17:46:04 <shapr> The B-52s the band?
17:46:18 <TSC> Love shack, baby
17:46:24 <MyCatVerbs> Huh. Never heard of 'em.
17:46:25 <dolio> @b52s
17:46:25 <lambdabot> Girl from Ipanema, she goes to Greenland
17:46:30 <dolio> @b52s
17:46:31 <lambdabot> His ear lobe fell in the deep. Someone reached in and grabbed it. It was a rock lobster!
17:46:38 <MyCatVerbs> Admittedly, I'm a philistine.
17:46:52 <MyCatVerbs> These all sound pretty deep, or at the very least nicely stoned.
17:46:57 <shapr> I think... stoned.
17:47:14 <dolio> You should go to youtube and listen to Love Shack and Rock Lobster. Those are pretty famous.
17:47:24 <dolio> Or were, on a time.
17:47:50 <shapr> @. elite protontorpedo
17:47:50 <lambdabot> |-|Ow woULD |-|4SkE|L S0|\/3 tH3 f0L1OwINg GNaRL3y prOBL3M: /\/\4Ny (|IENT DI5TrI8U7ED 4(cR0Sz the U$A, +r4Nsph3RS mUzT TAkE palCe iN 7h3 FORm oph phIl3 TraNsph3r, aND D4+4 MuS+ 8e rEad phr0/\/\
17:47:50 <lambdabot> phileS, 4nD R3coRD3D, t|-|3N o+HeR pAR7N3rz0rz \/\/HO ApPly 74xEz +0 tHIs DatA aND tHeN GI\/e ab(k n3W phi1es WiT|-| 7AXe5 aD3D, +h3n L4s7 +raN53rs t0 4tH Par7i3s wH0 g3+ U5 p4iD FoR tHe pHOne (al1S
17:47:50 <lambdabot> T|-|4T 4RE +|-|E ProDu(T
17:48:35 <daveux> @lord-destros
17:48:35 <lambdabot> Unknown command, try @list
17:48:38 <daveux> @list
17:48:38 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
17:48:38 <shapr> hej felipe, god morgon!
17:48:53 <daveux> @slap daveux
17:48:53 * lambdabot slaps daveux
17:48:58 <shapr> @shapr shapr
17:48:58 * lambdabot submits shapr's email address to a dozen spam lists
17:48:58 <mibX> anyone know what the big difference between haskell and ocmal and why haskell is more popular?
17:49:18 <dibblego> Haskell is pure and lazy
17:49:20 <daveux> @shapr
17:49:20 * lambdabot smashes a lamp on  head
17:49:35 <shapr> mibX: Yeah, Haskell is pure, lazy and has typeclasses and a prettier syntax. OCaml is strict, allows mutability and can be faster with hand tuning.
17:49:37 <daveux> @get-shapr
17:49:37 <lambdabot> shapr!!
17:49:42 <shapr> daveux: You called?
17:49:56 <shapr> mibX: Also, Haskell has a better community than OCaml.
17:50:05 <mibX> shapr so which is better for large projects?
17:50:08 <shapr> Or at least, larger and friendlier.
17:50:13 <mibX> :)
17:50:20 <Heffalump> Haskell has prettier syntax ;-)
17:50:21 <shapr> mibX: I think that depends on the project and the person implementing the project.
17:50:40 <Heffalump> mibX: I would look at your requirements first.
17:50:54 <shapr> mibX: Both languages have their advantages.
17:50:59 <mibX> ok i want to create a large server
17:51:04 <shapr> Server for what?
17:51:10 <mibX> it will be processing alot of data
17:51:13 <shapr> Like, web server?
17:51:15 <mibX> census data
17:51:18 <mibX> yes
17:51:37 <shapr> Are you just serving up static data?
17:51:46 <mibX> no lots of dynamic data
17:52:00 <dolio> @quote JonHarrop
17:52:00 <lambdabot> JonHarrop says: I lurk on the Haskell Cafe mailing list and eager evaluation is often the solution to reliability or performance problems: laziness is unpredictable.
17:52:08 <shapr> Have you used either OCaml or Haskell before?
17:52:14 <dibblego> lol, did he really say that? where?
17:52:24 <mibX> i have used haskell but not alot
17:52:24 <Heffalump> laziness is quite predictable, it just can be unhelpful
17:52:33 <dolio> He undoubtedly said it.
17:52:50 <dolio> If I had to guess, I'd say I pulled that from comp.lang.functional a while ago.
17:52:54 <dolio> But I'm not certain.
17:53:28 <mibX> i have on the other hand used alot of prolog
17:53:29 <orzo> i have a grammar for a binary file
17:53:35 <Heffalump> he seems to specialise in mixing interesting work and clueless trolling to the point where you can't work out where one morphs into the other
17:53:35 <orzo> i want some help/advise
17:53:55 <orzo> http://hpaste.org/7140
17:54:09 <orzo> this is the layout of my binary file
17:54:20 <mibX> so any ideas anyone? which is better for a large dynamic website?
17:54:29 <shapr> mibX: I'd suggest you spend an hour or so trying OCaml and see if it clicks for you. (biased advice warning) If not, use Haskell ;-)
17:54:33 <orzo> I'd like to model it in a generic way and have a haskell program parse it and display the information
17:54:44 <shapr> mibX: But seriously, I think either would be fine.
17:54:59 <shapr> mibX: You could use existing Haskell dynamic website frameworks, HAppS is one example.
17:55:05 <dibblego> dolio, I found it on a web forum
17:55:16 <mibX> ok i will give ocaml a go if not go back to haskell
17:55:19 <orzo> How are grammars generally represented in haskell?
17:55:25 <shapr> I've heard that OCaml has some dynamic web tools, but I haven't tried those tools.
17:55:36 <shapr> mibX: Feel free to drop by and tell us how you're doing!
17:55:38 <dibblego> dolio, http://objectmix.com/programming-languages/171793-shootout-implementing-interpreter-simple-procedural-language-minim-16.html#post608486
17:55:39 <lambdabot> Title: shootout: implementing an interpreter for a simple procedural language Minim - P ..., http://tinyurl.com/59qnd4
17:55:50 <shapr> mibX: I'm always interested in the impressions of people new to functional programming.
17:56:18 <mibX> shapr: i curse the day of was introduced to fp langs
17:56:22 <shapr> Why?
17:56:34 <shapr> Now you've seen beauty, and it's hard to keep a C# job?
17:56:47 <shapr> (Perhaps I was projecting a bit much there)
17:56:48 <mibX> they are so nice and when i goto use C/C++ or java i hate the sysntax
17:56:56 <shapr> Ah yes, I understand that all too well.
17:57:10 <mibX> i almost feel demotivated
17:57:10 <johnnowak> if you only hate the syntax you have so much further to fall
17:57:13 <dolio> dibblego: That looks like some kind of web forum view of comp.lang.functional. I recognize several names.
17:57:35 <mibX> i start to try and to everything in a fp language
17:57:38 <mibX> do*
17:57:48 <shapr> Yeah, me too.
17:58:00 <shapr> I had a job doing Haskell for over a year :-)
17:58:02 <mibX> its depressing sometimes
17:58:05 <mibX> :)
17:58:12 <dolio> dibblego: I also recognize the "Minim" topic. It was a proposed benchmark for Qi vs. other functional languages, as I recall.
17:58:22 <shapr> mibX: That's the solution, if you get to the point where you CAN do everythin in Haskell, you can get a job doing that!
17:58:32 <mibX> shapr: there is hope that the industry may be changing F#?
17:58:40 <johnnowak> no
17:59:06 <shapr> mibX: F# isn't really much like Haskell, imho
17:59:16 <dolio> Unless they all had the exact same conversation on a web forum, too. Then again, I didn't know people were mirroring c.l.f like that.
17:59:23 <mibX> shapr: still its a step towards the fp world
17:59:55 <shapr> Yeah, but so is C# 3.0 with lambdas and lots of map/filter/etc stuff.
18:00:02 <Svrog> f# is a dialect of caml
18:00:05 <shapr> I do think that the good points of Haskell are spreading into other languages.
18:00:10 <dino-> I had at work happen the other day, we thought we needed to transform a list in the way that Control.Monad.sequence will..
18:00:19 <mibX> shapr: how does haskell scale to large websites?
18:00:28 <dino-> And the alternative in Perl is either writing crazy nested loops or using a matrix transform lib to get the cross product.
18:00:32 <shapr> mibX: How large?
18:00:42 <shapr> HAppS is not quite as fast as Apache, last I checked.
18:00:44 <dino-> Or, you know, that one function in Haskell.
18:00:46 <mibX> 2000 hits a day
18:00:50 <shapr> mibX: Easily
18:00:57 <mibX> 10000?
18:01:20 <dino-> Turns out we didn't need this as originally thought. But they were ready to have me commit Haskell source to do this from Perl and call a native compiled bin.
18:01:25 <mofmo1> Cale: is it the printing of strings that is slow or is it the operations upon them?
18:01:31 <shapr> I'm trying to remember how many connections a second were causing problems.
18:01:45 <jayw> @pf nonzero x = not . (x == 0)
18:01:45 <lambdabot> Maybe you meant: bf pl
18:02:01 <Cale> mofmo1: It could be the operations, I'm not sure.
18:02:09 <Cale> mofmo1: Let me have another look at your code
18:02:12 <mauke> jayw: not (x == 0)?
18:02:23 <shapr> > 10000 / 60 / 60
18:02:23 <lambdabot>  2.7777777777777777
18:02:29 <shapr> mibX: Easily.
18:02:33 <Cale> mofmo1: well, for one,  xs !! n  is O(n) time
18:02:38 <mofmo1> Cale: one sec i'm in the middle of messing around with it
18:02:44 <mibX> shapr: thanks for ur info ;)
18:02:50 <mibX> i have to go now
18:02:52 <Cale> and  xs ++ ys  is O(length xs) time
18:02:53 <mofmo1> Cale: well... i'm not using !! on the strings
18:02:57 <shapr> mibX: I think the problems happened around 50 connections a second.
18:03:06 <shapr> mibX: Have fun!
18:03:08 <mibX> i have to say though the haskell community is very nice :)
18:03:12 <shapr> Yay!
18:03:12 <jayw> mauke: I'm wondering about some type weirdness.
18:03:28 <mauke> :t not . (?x == 0)
18:03:29 <lambdabot>     Couldn't match expected type `f Bool' against inferred type `Bool'
18:03:29 <lambdabot>     In the second argument of `(.)', namely `(?x == 0)'
18:03:30 <mofmo1> well the length of xs is pretty small... so that doesn't sseem like that big of a speed boost
18:04:06 <mofmo1> i just realized that i could save the list of changes from the board life eval function
18:04:08 <dino-> list of lists, I should have said
18:04:20 <mofmo1> so now i'm rewriting update board to make use of them
18:04:39 <jayw> mauke: In ghci, :t not . (== 0) gives (Num a) => a -> Bool. But "let f = not . (== 0)" and ":t f" gives Integer -> Bool.
18:04:53 <jayw> mauke: So I'm wondering why, when I bind it to a name, the type suddenly specializes.
18:05:07 <johnnowak> uh oh
18:05:13 <dolio> Monomorphism restriction.
18:05:20 * johnnowak plays dramatic music
18:05:21 <dolio> Dun dun dun!
18:05:46 <mofmo1> TURN IT OFFF
18:06:10 <jayw> But then "let g x = not (x == 0)" gives the expected, more general type.
18:06:52 <Jedai> jayw: Monomorphism restriction is there for performance reasons, check the Wiki page on it
18:06:57 <Jedai> @where monomorphism
18:06:58 <lambdabot> I know nothing about monomorphism.
18:07:02 <Jedai> @where monomorphism restriction
18:07:02 <lambdabot> I know nothing about monomorphism.
18:07:10 <dolio> @where mr
18:07:11 <lambdabot> I know nothing about mr.
18:07:12 <jayw> jedai: I'm at the page now, thanks.
18:08:04 <dolio> Apparently getting rid of the MR has overwhelming support for haskell'.
18:08:09 <Jedai> @where+ monomorphism restriction http://www.haskell.org/haskellwiki/Monomorphism_restriction
18:08:09 <lambdabot> I will never forget.
18:08:14 <Jedai> @where monomorphism restriction
18:08:14 <lambdabot> restriction http://www.haskell.org/haskellwiki/Monomorphism_restriction
18:08:21 <Jedai> @where monomorphism
18:08:22 <lambdabot> restriction http://www.haskell.org/haskellwiki/Monomorphism_restriction
18:08:32 <Jedai> Oh well... ^^
18:10:00 <jayw> Thank you. I did not realize it was so easy to fall foul of that.
18:12:12 <Heffalump> it'll be gone soon :-)
18:16:53 <mofmo1> HOLY MAGIKARP
18:17:02 <mofmo1> it's... it's fast as lightning now
18:17:04 <mofmo1> ahahahahahaahhahaahha
18:17:25 <mofmo1> and surprisingly bug free
18:19:27 <daveux> We're trying to get system time when a key is pressed. SOE uses GLFW but we want to avoid having to use opengl for something so simple. Is there a good system command for this?
18:20:36 <Saizan> are asking for a way to get the current time or?
18:21:02 <daveux> Saizan: something more granular, ideally.
18:21:13 <daveux> so maybe elapsed milliseconds or something
18:21:26 <sw17ch> System.getClockTime
18:21:27 <sw17ch> > System.getClockTime
18:21:28 <lambdabot>   Not in scope: `System.getClockTime'
18:21:36 <daveux> > import System
18:21:36 <lambdabot>  Parse error at "impor..." (column 1)
18:21:45 <daveux> > let f = id
18:21:45 <lambdabot>  Parse error at end of input
18:21:58 <daveux> > putString "hello"
18:21:58 <lambdabot>   Not in scope: `putString'
18:22:04 <daveux> > putStr "hello"
18:22:05 <lambdabot>  <IO ()>
18:22:07 <daveux> ah
18:22:09 <sw17ch> > System.Time.getClockTime
18:22:09 <lambdabot>   Not in scope: `System.Time.getClockTime'
18:22:13 <daveux> hmm
18:22:53 <BMeph> Shouldn't there be a "Posix" in there somewhere? :)
18:23:37 <sw17ch> http://haskell.org/ghc/docs/latest/html/libraries/old-time/System-Time.html#v%3AgetClockTime
18:23:37 <lambdabot> http://tinyurl.com/5cuhyf
18:23:46 <daveux> thanks, switch
18:27:01 <daveux> > getKey
18:27:02 <lambdabot>   Not in scope: `getKey'
18:27:06 <OceanSpray> theoretically, can you omit ALL type annotations?
18:27:31 <daveux> no, there are certain cases where type inference doesn't work...but I think you have to specifically state those cases
18:27:45 <daveux> also, with monad transformers I think you need the type annotations or else it will be ambiguous
18:27:57 <OceanSpray> huh.
18:28:05 <daveux> make I misunderstood you
18:28:07 <daveux> haha
18:28:27 <mofmo1> Cale: it's extremely fast without ByteStrings now that I used a liberal amount of "map"
18:28:37 <mofmo1> and only have one putStr
18:28:43 <Cale> mofmo1: cool
18:28:50 <dolio> There are very few cases where you need to write explicit signatures if you're not using extensions.
18:29:50 <mofmo1> in fact, arrUpdateBoard doesn't even come in the top time consumers haha
18:30:01 <dolio> "show . read" is one, since that's ambiguous.
18:30:31 <dolio> Overriding the monomorphism restriction is another possibility.
18:30:51 <mofmo1> so is there any way to find unused functions in the profiler?
18:38:51 <sw17ch> wow, the time stuff for haskell seems hard to work with...
18:39:02 <sw17ch> is it really that hard just to get seconds since the epoch?
18:39:46 <daveux> I'm using the getClockTime command, and when I get a time difference in picoseconds and call show on that difference I'm getting results with an odd notation I don't recognize. 1-77388000000. What does the 1- mean?
18:39:56 <daveux> Sometimes it has the 1- and sometimes it doesn't
18:45:19 <daveux> we have integers with a leading 1- when we print them. Anyone know why?
18:46:13 <sw17ch> i'm looking at that... i'm not seeing the leading 1
18:46:17 <sw17ch> do you have an example?
18:46:27 <daveux> haha, we were using getChar and didn't realize it was printing it out
18:46:52 <sw17ch> :)
18:47:54 <daveux> Do you know why x <- getChar is echoing?
18:48:48 <sw17ch> in ghci?
18:48:50 <Saizan> ?hoogle setEcho
18:48:51 <lambdabot> System.IO.hSetEcho :: Handle -> Bool -> IO ()
18:48:58 <daveux> thanks
18:49:09 <qwr> daveux: terminal settings...
18:49:14 <sw17ch> > Data.Time.Clock.POSIX.getPOSIXTime
18:49:15 <lambdabot>   Not in scope: `Data.Time.Clock.POSIX.getPOSIXTime'
18:49:29 <daveux> is that nicer than getClockTime?
18:49:35 <sw17ch> actually, it might be
18:49:38 <sw17ch> what are you trying to do?
18:50:05 <daveux> basically, we have a benchmark time and then we need to keep comparing elapsed time to it. We ideally need seconds and milliseconds
18:50:23 <sw17ch> the lazy's not going to hurt you is it? :)
18:50:38 <sw17ch> (i really don't know when stuff is actually executed for real in a monad)
18:50:40 <daveux> well, it's going to be based on key presses
18:50:46 <sw17ch> i'm assuming this is all happening in IO
18:50:49 <sw17ch> oh, alright
18:50:49 <daveux> yeah
18:50:54 <daveux> otherwise yeah it'd be insane
18:52:07 * qwr wonders, how the keypresses could change execution order?
18:54:47 <daveux> sw17ch: I think that getClockTime is fine, but why am I getting negative return values for the difference in picoseconds?
18:55:01 <sw17ch> switch the order of your arguments to the time difference function
18:55:01 <qwr> ... and lazy is easy - if you use a value, it will be forced. simple as that.
19:13:16 <gwern> > ((250 / 180) / (750 / 116)) * 100
19:13:17 <lambdabot>  21.48148148148148
19:13:51 <gwern> > ((750 / 116) / (250 / 180)) * 100
19:13:52 <lambdabot>  465.5172413793104
19:17:00 <neutrino> Hopefully this is just a newbie question, but I haven't been able to find an answer for it.  I'm trying to figure out how to declare a type with a restricted range that will give me a compile time error (i.e. static check) if a number a supply to the data constructor is out of range.
19:17:20 <neutrino> For instance to declare a numeric type with a range of 1 .. 90.
19:17:30 <pizza_> use Ada :-P
19:17:51 <neutrino> he he he ... that's were I've been :-)
19:17:58 <neutrino> where
19:17:59 <pizza_> ahhh
19:18:19 <gwern> neutrino: define 'data RestrictedNumber = 1 | 2 | 3 | ... | 90'
19:18:32 * gwern jests of course
19:18:53 <neutrino> :-)   Yes, very painful!
19:19:55 <gwern> although if your range isn't very big, that's probably easier than figuring out the GADT or phantom type hackery you'd need to do it in a principled manner
19:20:32 * gwern doesn't actually know how you'd do it though, sry. maybe one of the type gurus will wake up and tell you
19:21:26 <BMeph> I want Nat, can someone point out how to define Nat's type? ;)
19:21:31 <Saizan> neutrino: what do you want  90 + 1 to be?
19:21:54 <neutrino> I did look at phantom types a bit, but they seemed (at least from what I could tell of my limited knowledge of Haskell) to target a single size (such as fixed size vectors).
19:22:06 <Saizan> BMeph: an efficient one?
19:22:11 <tibbe> neutrino: as a practical matter it isn't possible, it requires dependent types afaik
19:22:41 <BMeph> Saizan: As efficient as Integer, give-or-take half-a-factor... :)
19:22:48 <neutrino> Saizan: If it could determine it at compile time, a compile time error, else a run-time error.
19:25:01 <Saizan> well the only pratical solution to both of your problems is to use a newtype, export only a smart constructor that checks bounds, and insert the proper bound checking/exceptions in the Num class and maybe Integral
19:25:12 <Saizan> in the instance i mean
19:25:42 <BMeph> Saizan: Sounds fair, thanks.
19:25:52 <Saizan> BMeph: you can use a Word if you don't care about the limited size
19:26:58 <Saizan> i wonder if there's a Nat package on hackage, actually
19:27:14 * BMeph scratches his head, and starts on defining Gaussian integers...
19:27:28 <neutrino> Saizan: That's what I've experimented with so far, but that is still a run-time error instead of a compile-time one.  Was hoping to tighten things up if I could.
19:30:18 <Saizan> well you can
19:31:00 <neutrino> ???
19:31:13 <Saizan> no, wait
19:32:01 <Saizan> if you can it's a lot of type hackery.. but i'm not sure how it will work
19:32:22 <Saizan> how are you going to use those numbers?
19:32:55 <Saizan> also, are they all compile-time constants?
19:36:29 <neutrino> I didn't really have anything in particular at the moment.  I was just looking through the Haskell YAHT and didn't like the section about enumerated sets when it supplied a "Custom Int Int Int" data constructor to create your own color.  I figured there must be a way to indicate that the RGB values must range between 0 and 255.  That kind of lead me down this path (and having background in...
19:36:31 <neutrino> ...Ada to know that it was possible in Pascal and Ada languages).
19:38:06 <neutrino> I thought that if I did something like "let x = Custom (300, 0, 0)" that I
19:38:16 <mdmkolbe|work> I have a list of "equivalance pairs", is there already a function to make equivalance sets from them?  E.g. [(a, b), (b, c), (c, d), (e, f)] should produce [[a,b,c,d], [e,f]]
19:38:18 <neutrino> 'd want the compiler to give a compile-time error.
19:39:14 <Saizan> ah i see, however it's not something that haskell supports, if you want compile-time errors you've to either lift things at the type-level, or use a macro system like template-haskell
19:39:50 <qimera> hello, i have a couple newbie questions.  what does the keyword 'Just' accomplish, and what does '$' do?
19:40:13 <mdmkolbe|work> qimera: '$' in an infix operator
19:40:16 <mdmkolbe|work> @src ($)
19:40:17 <lambdabot> f $ x = f x
19:40:32 <dolio> I've done some TH stuff for compile time number checking before.
19:40:35 <BMeph>  mdmkolbe|work: I don't know of a built-in for that, bt I suppose you could cobble something together with lookup and catMaybes.
19:40:41 <dolio> But it was more proof of concept.
19:40:56 <mdmkolbe|work> qimera: basically "f $ x $ y" is the same as "f (x (y))"
19:42:17 <mdmkolbe|work> qimera: "Just" is actually a constructor name.  Do you know what Contructors in Haskel terminalogy are?  (Not to be confused with constructors in Object oriented programming)
19:42:39 <qimera> mdmkolbe|work , so its just another tool, like parenthesis, to control order of function application?  f $ x seems pointless when one could write f x
19:42:53 <neutrino> I haven't really looked at Template Haskell yet, but it sounds like maybe I should :-)
19:43:11 <qimera> mdmkolbe|work , no I do not, this is only our 5th week of haskell at university
19:43:29 <mdmkolbe|work> quicksilver: yes that is exactly it.  The idea is that "f x y z" is "(((f x) y) z)" but that "f $ x $ y $ z" is "f (x (y z))"
19:43:51 <mdmkolbe|work> sorry I meant qimera not quicksilver
19:44:42 <mdmkolbe|work> qimera: just keep in mind that "$" is not build into the compiler, it is a library function like any other. so once you get far enough, you can right functions that do things just like "$" does
19:45:30 <Jedai> qimera: As you see from mdmkolbe|work example, you get quite an economy in parenthesis by using $, it avoids the "parenthesis hell" you can get in Lisp
19:45:43 <qimera> mdmkolbe|work: ah ok, that makes sense then, lets you go from left associative to right associative functinon application without ugly parenthesis
19:45:53 <qimera> Jedai: roger that :)
19:46:16 <dolio> neutrino: http://hpaste.org/7141
19:46:27 <dolio> It's not great, but...
19:46:44 <mdmkolbe|work> qimera: ok now on to "Just".  Have you seen uses of "Left" or "Right" or (someone help me out with examples of other constructors qimera may have already seen but doesn't realize it)
19:47:32 <qimera> mdmkolbe|work: yes we just saw Left or Right today in the context of data... data eitherBC = Left Bool | Right Char I believe it was
19:47:47 <Saizan> actually f $ x $ y $ z is better written f . x . y $ z
19:47:58 <mdmkolbe|work> qimera: good!  Now "Just" is just like "Left"
19:48:02 <mdmkolbe|work> @src Maybe
19:48:03 <lambdabot> data Maybe a = Nothing | Just a
19:48:06 <Twey> Saizan: Why?
19:49:03 <Saizan> Twey: it looks nicer :), and it has more valid subexpressions, so it's easier to refactor, e.g. (f $ x) makes no sense from the first, while f . x does
19:49:34 <Twey> Hm, OK
19:50:30 <mdmkolbe|work> qimera: basically, a "Maybe Int" is either "not return value" (Nothing) or "an Int" (Just 3).  Its like how in C/Java they return an Int sometimes but reserve a special Int value to mean no return value
19:50:58 <mdmkolbe|work> qimera: In haskell the "Maybe" type does the same thing but with out needing to reserve a special "Int" value
19:51:00 <Jedai> Except it's cleaner this way and the type say you when a function can fail
19:52:02 <neutrino> dolio: Thanks.  I'll definitely need to digest that.  Not fluent enough in Haskell to take it all in yet.
19:52:07 <Jedai> And also you get nice function to work with Maybe values.
19:52:24 <Jedai> @type fromMaybe
19:52:26 <lambdabot> forall a. a -> Maybe a -> a
19:52:30 <mdmkolbe|work> @index groupBy
19:52:31 <lambdabot> Data.List
19:52:51 <Jedai> > fromMaybe 5 (Just 3)
19:52:53 <lambdabot>  3
19:52:59 <Jedai> > fromMaybe 5 (Nothing)
19:53:00 <lambdabot>  5
19:53:13 * qimera studies
19:53:39 <mdmkolbe|work> Hmm, is there a version of groupBy that will group elements even if they are not next to each other?
19:53:47 <Jedai> Well there's other functions (and also a way to chain potentially failing operations nicely) but you'll see that later ;)
19:54:24 <Jedai> mdmkolbe|work: Generally I do that with Map
19:54:51 <Jedai> You can also do a sort and then a groupBy but the Map way is more efficient
19:55:08 <Jedai> sortBy rather
19:56:06 <mdmkolbe|work> Jedai: doesn't the Data.Map way require the elements to be groupBy "=="?
19:57:09 <Jedai> mdmkolbe|work: No, for example say I want to group strings by their first letter, I can do :
19:58:02 <Jedai> elems . Map.fromListWith (++) [] . map (\s -> (head s, [s])
19:58:22 <Jedai> @type M.fromListWith
19:58:23 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> M.Map k a
19:58:29 <qimera> well thank you both for your help so far.  so why would you write reshapeCallback $= Just reshape , instead of reshapeCallback = reshape ?
19:58:36 <Jedai> elems . Map.fromListWith (++) . map (\s -> (head s, [s])
19:59:21 <Jedai> qimera: $= isn't $ and =, it's another operator (specific to your API, a GUI API ?)
19:59:22 <mdmkolbe|work> qimera: "$=" is an operator defined by some library (Windowing library?), but "=" is part of haskell syntax
19:59:59 <qimera> Jedai: well that explains it , yes this is Graphics.UI.GLUT
20:00:38 <mdmkolbe|work> @type elems . Map.fromListWith (++) . map (\s -> (head s, [s])
20:00:39 <lambdabot> parse error (possibly incorrect indentation)
20:00:48 <mdmkolbe|work> @type elems . Map.fromListWith (++) . map (\s -> (head s, [s]))
20:00:50 <lambdabot> Couldn't find qualified module.
20:00:56 <mdmkolbe|work> @type elems . M.fromListWith (++) . map (\s -> (head s, [s]))
20:00:58 <lambdabot>     Couldn't match expected type `Array i e'
20:00:58 <lambdabot>            against inferred type `M.Map k a'
20:00:58 <lambdabot>       Expected type: [(k, a)] -> Array i e
20:01:04 <Jedai> qimera: Yes, so this operator is probably to tie a particular callback to a given function (and using Nothing would unregister the callback or something like that)
20:01:19 <Jedai> @type M.elems . M.fromListWith (++) . map (\s -> (head s, [s]))
20:01:21 <lambdabot> forall a. (Ord a) => [[a]] -> [[[a]]]
20:02:15 <Jedai> (supposing a is Char, this would effectively groups String by their first letter)
20:02:16 <qimera> Jedai: yes thats exactly what it does...so what do you think the Just is accomplishing here?
20:02:42 <qimera> (and btw ($=) :: (HasSetter s) => s a -> a -> IO () )
20:03:05 <Jedai> qimera: That's to allows you to write Nothing when you want no callback (rather than specifying a noop which would be less performant)
20:03:12 <mdmkolbe|work> Jedai: unfortunately, I think your example only works if there is a value I can extract that I compare for "==", that won't work in my case there is no "hash" I can take, I can only compare to value to see if they are the same
20:03:38 <qimera> Jedai: ok, thanks
20:03:40 <Jedai> mdmkolbe|work: Yeah, well then a sortBy maybe
20:04:27 <mdmkolbe|work> qimera: "Just" means "not Nothing".  "3" has type "Int", but "Just 3" has type "Maybe Int".
20:05:04 <ABoyNamedWooh> Howdy y'all. If I have my own state monad, how can I used it within the IO monad? That is...how can I do something like do {(a,b) <- getState; putStr $ a ++ b; }
20:05:24 <mdmkolbe|work> Jedai: actually I can't even compare to see if they are less than, I only get whether they are the same (heh, sorry, if I'm sounding picky)
20:05:31 <Zao> ABoyNamedWooh: You want a StateT.
20:05:43 <ABoyNamedWooh> a state transformer or what?
20:05:46 <Jedai> ABoyNamedWooh: You should use Monad Transformer (StateT in this case)
20:05:50 <ABoyNamedWooh> oh heavens
20:05:55 <Zao> Great fun, those.
20:05:55 <ABoyNamedWooh> monad transformers are a pain ;__;
20:06:13 <ABoyNamedWooh> what would my instance declaration look like?
20:06:13 <Jedai> ABoyNamedWooh: With newtype deriving they're not that bad
20:06:27 <ABoyNamedWooh> StateT (IO()) ?
20:06:47 <Zao> StateT YourState IO (), isn't it?
20:06:48 <Jedai> ABoyNamedWooh: On the other hand I don't really see the point of wrapping IO by a StateT, you could just use a IORef
20:07:10 <ABoyNamedWooh> IORef...to print and whatnot? Because I'm also using getChar
20:07:35 <ABoyNamedWooh> Basoically, I want the user to be able to press the '1' key, and have a state monad record the time stamps
20:07:39 <ABoyNamedWooh> is there a better way to do this?
20:08:19 <Jedai> ABoyNamedWooh: I don't really get why you want state here...
20:08:30 <ABoyNamedWooh> well, Jedai, the full context is
20:08:34 <ABoyNamedWooh> I want to loop for say, 30 seconds
20:08:38 <ABoyNamedWooh> and like, during those 30 seconds
20:08:43 <ABoyNamedWooh> have the user press keys
20:08:48 <ABoyNamedWooh> record the keystrokes and the time stamps
20:08:57 <ABoyNamedWooh> and then at the end convert it to events
20:09:04 <ABoyNamedWooh> doesn't that require state?
20:09:16 <ABoyNamedWooh> like, to hold on to the old keystrokes and time stamps?
20:09:37 <Jedai> ABoyNamedWooh: Well yes and no (that sounds more like Writer monad in fact) but IO already has state
20:09:57 <Jedai> ABoyNamedWooh: You can use an IORef to put all this stuff in
20:10:02 <ABoyNamedWooh> Ohhhhhhhhh
20:10:04 <ABoyNamedWooh> that's what you meant
20:10:06 <ABoyNamedWooh> clever clever
20:10:18 <ABoyNamedWooh> have I mentioned I love you guys? haha
20:10:32 <Jedai> ABoyNamedWooh: They're like variables in others language (imperative ones) but you can't use them outside of IO
20:10:52 <ABoyNamedWooh> yeah, I saw them in class...
20:10:57 <ABoyNamedWooh> go go C lol
20:12:12 <ABoyNamedWooh> I mean IORef basically passes around a pointer to a piece of data, right?
20:12:22 <Saizan> right
20:12:34 <ABoyNamedWooh> Sorry for being a newb
20:12:45 <ABoyNamedWooh> Haskell is beautiful but it's hard to wrap my mind around how to do some seemingly easy things
20:13:18 <bugQ> well, functional languages make some things incredibly easy, and others somewhat complicated.
20:13:29 <ABoyNamedWooh> not a complaint, it's just why I'm glad there's #haskell haha
20:13:37 <Saizan> you could also just pass an accumulating parameter to the recursive calls and add elements to it..
20:14:47 <ABoyNamedWooh> sounds like something nasty in the stack waiting to happen. or is it no worse?
20:15:26 <mofmo1> is there any built in haskell function that takes in keyboard input without having to press enter?
20:15:37 <mofmo1> simply raw keyboard input
20:15:44 <mdmkolbe|work> @type getChar
20:15:45 <lambdabot> IO Char
20:15:57 <Saizan> it depends on what this accumulator is, with a list it shouldn't be a problem if you prepend to it
20:16:02 <bugQ> every line of a do block is a call on the stack, isn't it?
20:16:27 <mdmkolbe|work> mofmo1: will "getChar" work for you?
20:16:46 <mofmo1> oh right
20:17:01 <sw17ch> mofmo1, i don't think that handles any keypress though
20:17:13 <Saizan> you may need to use hSetBuffering
20:17:19 <mdmkolbe|work> bugQ: what do you mean?
20:17:34 <sw17ch> mofmo1, though i've been wrong before :)
20:17:52 <bugQ> wait, no.  nevermind
20:17:58 <sw17ch> it doesn't seem to accept much besides characters... so if you're looking for events, that's not the way to do it
20:18:00 <qimera> mdmkolbe|work , Jedai: I appreciate the help, I'm understanding this tutorial much better now, thanks
20:18:13 <bugQ> recursion != composition
20:18:26 <mdmkolbe|work> qimera: glad to help. come by #haskell any time you have questions
20:18:54 <Saizan> even recursion doesn't use the stack as in strict languages
20:18:57 <Saizan> ?src map
20:18:57 <lambdabot> map _ []     = []
20:18:57 <lambdabot> map f (x:xs) = f x : map f xs
20:19:19 <bugQ> OK, what does?
20:19:24 <mofmo1> swit7ch: hmm.. it still requires some sort of input
20:19:41 <Saizan> map there is not a tail recurion but works in constant stack
20:19:51 <mofmo1> i want it to loop if there is no input
20:20:14 <bugQ> just scoped values?
20:21:57 <Saizan> well, arguments to functions are on the stack iirc, but i was referring to the interaction with lazy evaluation
20:22:30 <bugQ> right, ok.
20:22:31 <Saizan> well, references to them mostly
20:29:07 <ABoyNamedWooh> ?src monad
20:29:08 <lambdabot> Source not found. Just what do you think you're doing Dave?
20:29:12 <ABoyNamedWooh> ?src fold
20:29:12 <lambdabot> Source not found. That's something I cannot allow to happen.
20:29:14 <ABoyNamedWooh> ?src foldr
20:29:15 <lambdabot> foldr f z []     = z
20:29:15 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:29:18 <ABoyNamedWooh> hah, nifty
20:29:37 <ABoyNamedWooh> ?src sequence_
20:29:37 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
20:36:10 <sw17ch> has any one tried to get haskell running on an Arduino?
20:36:55 <sw17ch> is it even possible to run haskell in such a small environment?
20:42:46 <ABoyNamedWooh> so, I'm trying to make a loop that uses time. For some reason, however, it will only update on keypresses
20:42:55 <ABoyNamedWooh> does anyone know how I can force it to check itself every, who knows
20:43:00 <ABoyNamedWooh> 10 milliseconds
20:43:01 <ABoyNamedWooh> or something?
20:43:05 <ABoyNamedWooh> basically I have to hit enter
20:43:06 <ABoyNamedWooh> and it'll go
20:43:14 <mofmo1> alright so i want a loop to break whenever someone presses the q key
20:43:28 <mofmo1> but i dont want getChar to hang the process
20:43:39 <ABoyNamedWooh> you and I have similar wants, sir
20:43:49 <ABoyNamedWooh> do you want it to destroy the program or end the loop?
20:44:11 <mofmo1> end the loop
20:44:19 <ABoyNamedWooh> can't you just have something like...case keypress of your otherstuff -> blah blah; loop    'q' -> nottheloop
20:44:31 <ABoyNamedWooh> so like the recurse is only in the event that it's not a q
20:44:35 <mofmo1> yeah but there's no keypress function unless you use another library
20:44:41 <mofmo1> i think
20:44:50 <ABoyNamedWooh> you mean System.IO?
20:44:52 <ABoyNamedWooh> ohh you mean
20:44:53 <ABoyNamedWooh> like
20:44:53 <mofmo1> there's hWaitForInput
20:44:55 <ABoyNamedWooh> q without htiting enter?
20:44:59 <mofmo1> yes
20:45:04 <mofmo1> getChar does that
20:45:11 <mofmo1> but it hangs the loop wating for input
20:45:18 <mofmo1> i want it so that if there's no input it keeps going
20:45:44 <Svrog> you could fork a thread
20:46:04 <mofmo1> i... guess i could
20:46:51 <ABoyNamedWooh> Svrog: I don't think forking a thread would help my problem. I basically want mine to keep looping periodically...
20:47:17 <Svrog> keep looping periodically and when the user presses a key?
20:48:06 <ABoyNamedWooh> well, basically here's the idea
20:48:13 <ABoyNamedWooh> user imput makes it log a keystroke and a time stamp
20:48:16 <ABoyNamedWooh> and every 10 seconds
20:48:18 <ABoyNamedWooh> I want it to reset
20:48:31 <ABoyNamedWooh> I have a case time of 10 -> resetstuff _ -> keepgoing
20:48:35 <ABoyNamedWooh> but it doesn't activate
20:48:39 <ABoyNamedWooh> unless I actually hit enter around 10 seconds
20:48:51 <ABoyNamedWooh> so it seems like the looping is sort of...staying quiet
20:48:54 <ABoyNamedWooh> perhaps laziness is to blame
20:49:02 <Svrog> and you're using getChar?
20:49:07 <Svrog> getChar will block
20:49:07 <ABoyNamedWooh> yeah
20:49:13 <Svrog> which is why you'd have to fork a new thread
20:49:17 <Svrog> if you want the loop to continue
20:49:21 <ABoyNamedWooh> okkk
20:49:23 <ABoyNamedWooh> ohhh*
20:49:27 <ABoyNamedWooh> I see what you're saying
20:49:29 <ABoyNamedWooh> so the command
20:49:31 <ABoyNamedWooh> getchar
20:49:33 <ABoyNamedWooh> will stop progress?
20:49:43 <Svrog> yeah - it will wait for input
20:49:53 <ABoyNamedWooh> do you know if there's a way around that outside of forking?
20:50:24 <Svrog> well the only way would be not to use getChar
20:50:44 <Svrog> i could be wrong but i dont think there's a keypress function in any of the standard libraries
20:51:00 <Svrog> what you could do is write one yourself on top of getchar
20:51:04 <Svrog> again using threads :P
20:51:42 <roconnor> @hoogle hReady
20:51:43 <lambdabot> System.IO.hReady :: Handle -> IO Bool
20:51:46 <Svrog> oh
20:51:47 <ABoyNamedWooh> haha well to be honest while I've done thread stuff...that sort of thing still sort of eludes me. so I fork a thread to continue without blocking...do I fork a versoin that is only IO dependent?
20:51:56 <ABoyNamedWooh> roconner: what does hReady do?
20:52:01 <roconnor> Computation hReady hdl indicates whether at least one item is available for input from handle hdl.
20:52:10 <Svrog> there you go :)
20:52:35 <ABoyNamedWooh> haha ok I'll go read up on that, I'm confused but THANK YO!
20:52:36 * dolio holds his breath for total type families.
20:52:37 <ABoyNamedWooh> THANK YOU*
20:52:37 <roconnor> @hoogle stdin
20:52:37 <allbery_b> hm, but does it work with devices or only files?
20:52:38 <lambdabot> System.IO.stdin :: Handle
20:53:14 <ABoyNamedWooh> so can I do something like
20:53:16 <allbery_b> (commonly there is a test for more data which always returns true on devices, because it's really "have we hit EOF yet" which is final on files)
20:53:44 <roconnor> @hoogle hIsEOF
20:53:45 <lambdabot> System.IO.hIsEOF :: Handle -> IO Bool
20:53:46 <ABoyNamedWooh> do {x <- hReady stdin; case x of True -> c <- getChar   and so on
20:53:54 <ABoyNamedWooh> would that work or am I thinking of this incorrectly?
20:54:18 <Svrog> that should work - you should be able to try that directly in ghci
20:54:28 <roconnor> ABoyNamedWooh: you can use if instead of case
20:54:36 <Svrog> yes that too
20:54:37 <Svrog> hehe
20:55:04 <ABoyNamedWooh> you guys are amazing
20:55:18 <ABoyNamedWooh> if I become a mad haskell hacker it will be for people who have nothing better to do than help nubs like me ;)
20:55:30 <roconnor> You probably want to hSetBuffering stdin NoBuffering
20:55:45 <sw17ch> hehe, nub....
20:55:54 <roconnor> @hoogle nub
20:55:55 <lambdabot> Data.List.nub :: Eq a => [a] -> [a]
20:55:55 <lambdabot> Data.List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
20:55:57 <sw17ch> > nub [1,1,1,1,2,2,2,2,3,3,3,3]
20:55:58 <lambdabot>  [1,2,3]
20:56:12 <sw17ch> > nub [1,1,1,1,2,2,2,2,3,3,3,3,1,1,1,1,1]
20:56:13 <lambdabot>  [1,2,3]
20:56:14 <ABoyNamedWooh> what does that do, roconner?
20:56:44 <roconnor> The nub function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element.
20:56:48 <sw17ch> takes out everything that already occurred in the list
20:57:00 <sw17ch> @src nub
20:57:00 <lambdabot> nub = nubBy (==)
20:57:05 <sw17ch> @src nubBy
20:57:05 <lambdabot> nubBy eq []             =  []
20:57:05 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
20:57:17 <sw17ch> is that O(n^2)?
20:57:31 <allbery_b> yes
20:57:45 <ABoyNamedWooh> lol not the nub function, hehe, I'm not that bad
20:57:57 <sw17ch> i thought so... there's not really a better way to do that is there
20:57:59 <ABoyNamedWooh> I meant hSetBuffering stdin NoBuffering
20:58:03 <sw17ch> i suppose if there was one... it would be the nub implementation :)
20:58:05 <roconnor> oh
20:58:23 <roconnor> ABoyNamedWooh: it makes sure that input isn't line buffered or block buffered.
20:58:26 <sw17ch> nubBy (<=) [1..10]
20:58:32 <sw17ch> > nubBy (<=) [1..10]
20:58:32 <lambdabot>  [1]
20:58:33 <allbery_b> hm?  I thought someone did a better one and it's been submitted to libraries@
20:58:34 <sw17ch> hah
20:58:39 <sw17ch> > nubBy (>=) [1..10]
20:58:40 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
20:58:45 <roconnor> ABoyNamedWooh: if the input is buffered, then even if a key is pressed, it won't necessarily appear.
20:58:50 <ABoyNamedWooh> ahh ok
20:59:01 <roconnor> until the buffer gets full or is flushed.
20:59:06 <ABoyNamedWooh> is that why the cmd prompt makes me hit enter? should I be using cygwin? (admits to not being able to get linux to work ;__;)
20:59:33 <allbery_b> I think you need System.Win32
21:00:44 <ABoyNamedWooh> so roconner
21:00:54 <ABoyNamedWooh> is it ok if I paste like 5 lines of code? bad juju?
21:00:58 <ABoyNamedWooh> I implemented what you said
21:01:01 <ABoyNamedWooh> and no it's not accepting anything
21:01:03 <dibblego> @paste
21:01:03 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:01:39 <ABoyNamedWooh> http://hpaste.org/7142
21:02:19 <ABoyNamedWooh> I can paste more of my hideous code if you don't mind
21:02:55 <Svrog> no problem - just put annotate your existing hpaste
21:03:04 <Svrog> -put
21:03:32 <ABoyNamedWooh> http://hpaste.org/7142#a1
21:03:51 <ABoyNamedWooh> I'd be much obliged if you could perhaps tell me where the character input is going wrong
21:04:56 <ABoyNamedWooh> oh and there's a comment on the hSetBuffer but I've tried it both ways
21:05:45 <dolio> @t (.)
21:05:45 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
21:05:49 <roconnor> ABoyNamedWooh: what is the problem?
21:05:51 <dolio> @type (.)
21:05:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:06:17 <ABoyNamedWooh> roconner: it only works itinerantly. I run it and it loops, I hit 1 and enter, nothing happens. I keep doing this and once in a while I see output.
21:06:29 <ABoyNamedWooh> And the thing that's based on time also still doesn't quite work
21:06:35 <ABoyNamedWooh> did I use hReady incorrectly?
21:06:43 <Trinithis> @ty Prelude.(.)
21:06:44 <lambdabot> Not in scope: data constructor `Prelude'
21:06:47 <roconnor> ABoyNamedWooh: set both stdin and stdout to no buffering
21:07:12 <Trinithis> dolio, in general type (.) == (b -> c) -> (a -> b) -> a -> c
21:07:24 <Trinithis> (or rather, less generally :D)
21:07:38 <ABoyNamedWooh> let me try using cygwin
21:07:40 <lament> @type P..
21:07:40 <dolio> Trinithis: I wanted to see how to write kind signatures, actually. :)
21:07:41 <lambdabot> parse error on input `P..'
21:07:52 <lament> @type P.(.)
21:07:53 <lambdabot> Not in scope: data constructor `P'
21:08:01 <dolio> @type (P..)
21:08:02 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
21:08:28 <ABoyNamedWooh> man, this is frustrating. hmmmmmm
21:08:35 <roconnor> ABoyNamedWooh: hmm, it looks like your program will spin
21:08:41 <Svrog> ABoyNamedWooh: using cygwin wont make any difference
21:08:44 <ABoyNamedWooh> yeah, it spins
21:08:52 <ABoyNamedWooh> I mean if I do something like putStr (my second counter)
21:08:55 <ABoyNamedWooh> it spits out seconds
21:08:59 <roconnor> well, you need to block somewhere somehow.
21:09:08 <ABoyNamedWooh> in what sense?
21:09:56 <allbery_b> this is usually done with threads.  there is hWaitForInput (which demonstrates that hReady is in fact the right call... a bit surprising to me, most I/O libraries don't think that way and I expected Haskell's to be "use threads" about it)
21:10:32 <roconnor> ABoyNamedWooh: you code is spewing out output,
21:10:43 <roconnor> so the output is probably having a hard time keeping up
21:11:01 <roconnor> And if you don't print output, then you will be spinning with the CPU at 10%
21:11:08 <roconnor>  100%
21:11:25 <ABoyNamedWooh> oh, so basically, it's doing what I'm saying, it's just doing it too well?
21:11:26 <roconnor> I don't know what you are trying to do.
21:11:31 <ABoyNamedWooh> ah well, here's my goal
21:11:34 <ABoyNamedWooh> perhaps I'm doing it poorly
21:11:41 <ABoyNamedWooh> I want to record the timestamp for when the user presses a key
21:12:05 <roconnor> x <- getChar; t <- getClockTime
21:12:14 <roconnor> no problem. :)
21:12:20 <ABoyNamedWooh> lol, well, there is a problem there haha
21:12:26 <ABoyNamedWooh> because I also want it to reset every 10 seconds
21:12:33 <ABoyNamedWooh> which getchar was blocking it from doing
21:12:44 <allbery_b> hWaitForInput has a timeout
21:13:07 * dolio is thoroughly confused.
21:13:16 <ABoyNamedWooh> Ok so here's my end goal
21:13:25 <roconnor> ABoyNamedWooh: allbery_b is right
21:13:28 <ABoyNamedWooh> Go for 10 seconds, spit out all the time stamps, then go for another 10 seconds, spit out the time stamps, and so on
21:13:46 <ABoyNamedWooh> allbery_b: I guess I'm not quite sure where hWaitForInput factors in
21:14:15 <roconnor> It allows you to wait for a input, but timeout and continue after n seconds.
21:14:30 <ABoyNamedWooh> I see
21:14:31 <roconnor> (BTW, this is not a haskell specific problem. :) )
21:14:34 <allbery_b> hm, that's harder.  I'd switch to threads and MVars.  one thread goes getChar and stuffs it and timestamp into a list in an MVar; other thread wakes up every 10s, reads the MVar, and dumps the list
21:14:38 <ABoyNamedWooh> (ah, thanks haha I feel so dumb)
21:15:05 <ABoyNamedWooh> allbery_b: how do I make a thready wake up every 10 seconds? with hWaitForInput?
21:15:11 <roconnor> as allbery_b notes, threads may be good for this problem.
21:15:15 <ABoyNamedWooh> the MVar suggestion is actually very good
21:15:19 <mofmo1> so for some reason ghc wont thread properly even with -threaded
21:15:20 <allbery_b> the second thread uses threadDelay
21:15:26 <mofmo1> the program works right in ghci
21:15:30 <roconnor> @type threadDelay
21:15:32 <ABoyNamedWooh> ahh
21:15:32 <lambdabot> Not in scope: `threadDelay'
21:15:39 <roconnor> @hoggle threadDelay
21:15:39 <lambdabot> GHC.Conc.threadDelay :: Int -> IO ()
21:15:40 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
21:15:49 <ABoyNamedWooh> so I thread delay it for 10 seconds
21:16:01 <ABoyNamedWooh> then when it wakes up it spits it out, ends everything, and resets the loop? (and of course kills itself haha)
21:16:10 <allbery_b> reading an MVar clears it
21:16:10 <ABoyNamedWooh> or I guess it creates a new listening thread
21:16:11 <roconnor> Not that complicated
21:16:18 <ABoyNamedWooh> I've dealt with MVars, threads I'm less sure about
21:16:26 <allbery_b> and the reading thread wiull be blocked while it happens
21:16:27 <ABoyNamedWooh> my professor had us do all sorts of nasty things with MVars haha
21:16:38 <mofmo1> at least you get to use haskell in a class
21:16:42 <roconnor> it wake up after 10 seconds, emptys the MVar, does it's thing, and loops.
21:16:43 <pizza_> your professor is a brave woman
21:16:44 <ABoyNamedWooh> we have a whole haskell class
21:16:59 <mofmo1> where do you go?
21:17:03 <mofmo1> somewhere in the UK?
21:17:04 <ABoyNamedWooh> University of Pennsylvania
21:17:07 <mofmo1> oh
21:17:08 <mofmo1> figures
21:17:15 <ABoyNamedWooh> Benjamin Pierce teaches it, great guy
21:17:27 <mofmo1> Berkeley is a dyed in the wool LISP/C kind of place
21:17:33 <ABoyNamedWooh> haha
21:17:34 <ABoyNamedWooh> C
21:17:36 <ABoyNamedWooh> *vomit*
21:17:42 * allbery_b is no great shakes at threading (self-tarught programmer from the days before threads, then switched to sysadmin) but this much he understands :)
21:17:43 <ABoyNamedWooh> man I don't know how I'll ever write java again
21:18:01 <mofmo1> C is pretty clear and good for what it does
21:18:04 <ABoyNamedWooh> how will I ever write java again, #haskell??
21:18:17 <allbery_b> with great wailing and gnashing of teeth
21:18:19 <mofmo1> java is pretty vomit
21:18:28 <dolio> You could write Scala instead.
21:18:35 <dolio> That's supposed to be all right.
21:18:36 <allbery_b> I already have a couple perl scripts for work with "this wants to be haskell" comments in them :)
21:19:00 <ABoyNamedWooh> haha
21:19:06 <ABoyNamedWooh> man I had to write matlab
21:19:08 <ABoyNamedWooh> it's even worse
21:19:09 <allbery_b> (but I have little choice, $coworkers will kill me if I start writing production stuff in haskell...)
21:19:11 <ABoyNamedWooh> the inconsistency was killing me
21:19:21 <dolio> Matlab is annoying.
21:19:22 <ABoyNamedWooh> what sphere do you work in, all?
21:19:40 * allbery_b only knows matlab by repute, it's one of the most heavily used programs in the department (cadence verilog is the other)
21:19:44 <ABoyNamedWooh> Matlab is so hideous. Haskell is all beautiful and mathematical and consistent and matlab is like "no we are completely ridiculous and unprincipaled" ;__;
21:19:55 <ABoyNamedWooh> yeah I have to build a processor in verilog. fun times.
21:19:58 <wagle> matlab is evil
21:20:02 <mofmo1> matlab was made for people who need to program but can't
21:20:20 <allbery_b> senior system administrator, department of electrical and computer engineering, carnegie mellon university
21:20:21 <dolio> I just remember matlab making it really hard to define functions interactively.
21:20:27 <mofmo1> in general, the most popular languages are the worst kinds of languages because most people are stupid
21:20:29 <ABoyNamedWooh> oh wow, CMU is great
21:20:34 <wagle> when matlab crashed, it cleared my work file AND all the backups i'd made..  i lost 2 weeks of week
21:20:46 <dolio> So, when I was doing numerical analysis, it was a huge pain to test things out.
21:20:51 <ABoyNamedWooh> yeah thankfully I've done nothing too big in matlab. just financial calibratoins and stuff
21:21:00 <ABoyNamedWooh> the code just gets so incomprehensible
21:21:00 <mofmo1> the only exception as far as i could see is C. but then everyone went to C++ and that was the end of that
21:21:00 <allbery_b> I started learning haskell because I like to keep stretching my mind, and because I have vague notions of applying it to some security and system configuration areas
21:21:21 <mofmo1> i use haskell because LISP isn't quite functional enough
21:21:32 <ABoyNamedWooh> haskell has such dedication to the cause
21:21:35 <mofmo1> although i do get seduced by S-Expressions every now and then
21:21:51 <mofmo1> (and data mutation SHOCK!)
21:22:11 <mofmo1> sometimes when im tired i just want to set-car! something
21:22:18 <ABoyNamedWooh> lol
21:22:23 <ABoyNamedWooh> WON'T SOMEONE WRITE ME A GETTER
21:22:24 <ABoyNamedWooh> someoneeee
21:22:39 <ABoyNamedWooh> ABoyNamedWooh.getHelp(#Haskell)
21:22:39 <ABoyNamedWooh> ahh
21:22:40 <ABoyNamedWooh> there we go
21:22:42 <ABoyNamedWooh> I'm homeee
21:23:50 <mofmo1> in other news, why wont ghc thread
21:24:01 <sjanssen> mofmo1: hmm?
21:24:36 <mofmo1> ghc -o cgol -O -threaded --make Main
21:24:43 <mofmo1> it works in ghci... but not in ghc
21:24:46 <sjanssen> looks fine
21:25:13 <sw17ch> ghc -version ?
21:25:24 <sjanssen> oh, you might need to pass -no-recomp to force GHC to relink the executable
21:25:29 <mofmo1> ??
21:25:46 <sw17ch> i seem to recall 6.6 didn't thread for real
21:25:52 <sjanssen> sw17ch: it does
21:26:00 <sw17ch> oh, well never mind then :)
21:26:06 <mofmo1> hmm
21:26:09 <mofmo1> i think it threads now
21:26:11 <sjanssen> the threaded RTS was a new feature for GHC 6.6
21:26:20 <allbery_b> mofmo1: if you want real OS threads you also need RTS stuff (+RTS -N2)
21:26:21 <sw17ch> mmm... alright
21:26:23 <sjanssen> mofmo1: also, what do you mean by "it works"?
21:26:25 <mofmo1> but the forkIO procedure doesnt work right
21:26:36 <mofmo1> well
21:26:41 <sw17ch> allbery_b, is there a way to build those options into the program?
21:26:45 <djfroofy> threads are evil
21:26:48 <djfroofy> who needs em
21:26:50 <mofmo1> i have a do block that forks off an infinite loop
21:27:12 <mofmo1> then the do block itself has getChar and checks if it's q. if it is, it kills the thread and then exits the program
21:27:15 <djfroofy> why not make the loop cooperative?
21:27:19 <sjanssen> sw17ch: there is a way to specify default RTS arguments, but it is really ugly (you write some C and link to it IIRC)
21:27:22 <allbery_b> there "is* but ut's paunful
21:27:25 <allbery_b> yeh, that
21:27:27 <mofmo1> djfroofy: ??
21:27:40 <allbery_b> better to use a wrapper script
21:27:41 <sjanssen> djfroofy: GHC has preemptive threads and they work perfectly well
21:27:42 <djfroofy> mofmo1: your example of an inifinite loop
21:27:58 <djfroofy> sjanssen: preemption is bad
21:28:17 <rntz> djfroofy: "bad" how?
21:28:19 <mofmo1> djfroofy: it prints stuff
21:28:24 * sjanssen doesn't agree.  But that's neither here nor there
21:28:27 <djfroofy> people don't like being preempted
21:28:31 <djfroofy> nations don't either
21:28:35 <mofmo1> perhaps there's an unfairness issue
21:28:39 <mofmo1> i dunno
21:28:46 <roconnor> djfroofy: preemption is good because threads, like people, aren't very good at cooperating.
21:28:47 <djfroofy> nor people's code in general
21:28:51 <rntz> djfroofy: oh yes. Because personification is such a valid method of arguing about code.
21:29:07 <djfroofy> rntz: it is actually
21:29:18 <sjanssen> mofmo1: is this small enough to hpaste?
21:29:25 <mofmo1> sjanssen: maybe
21:29:50 <mofmo1> http://hpaste.org/7143
21:30:04 <djfroofy> rntz: preemption means creating non-deterministic execution paths - so is computer-sciency jargon better?
21:30:51 <mofmo1> flush is hFlush stdout
21:31:04 <rntz> djfroofy: Yay an argument with a point. And it wouldn't matter if you had said "preemption leads to uncertain results", which is not CS jargon but means approximately the same.
21:31:27 <bos> jeez, (.) is an incredibly small bikeshed to be trying to paint.
21:31:32 <djfroofy> rntz: i wasn't really aiming for an argument ...
21:31:40 <sjanssen> mofmo1: have you set the buffering on stdin?
21:31:47 <rntz> djfroofy: eh, sorry. sometimes my pedantic side gets the better of me.
21:31:54 <mofmo1> sjanssen: oh
21:31:59 <mofmo1> that could be a problem
21:32:03 <sw17ch> the FAA thinks threads are bad
21:32:06 <sjanssen> mofmo1: it is line buffered by default, so you'd have to type enter for getChar to complete
21:32:15 <sw17ch> along with dynamic memory
21:32:17 <djfroofy> rntz: yeah ... my comments were more like: "watch out, i think it might rain tonight'
21:32:17 <mofmo1> hrm
21:32:24 <dolio> bos: Nobody seems interested in that one. ($) is much more exciting.
21:32:38 <mofmo1> is it just hSetBuffering stdin NoBuffering?
21:32:40 <djfroofy> anyhow, cooperate task can be controlled quite effectively
21:32:45 <sjanssen> bos, dolio: is this why my Haskell mailbox has 173 new messages?
21:32:50 <djfroofy> the even online guys figured it out ...
21:32:52 * sjanssen hasn't checked it today
21:32:55 <bos> sjanssen: yes, blame Cale.
21:33:13 <djfroofy> preemption minus shared memory might be less bad of a thing of course ...
21:33:45 <djfroofy> s/even online/eve online/g
21:34:03 <sjanssen> djfroofy: have you tried threading in Haskell?  It tends to have significantly fewer pitfalls than, say, C
21:34:28 <dolio> sjanssen: Probably 50 are about ($).
21:34:53 <djfroofy> i avoid posix threading like the black plague.  twisted helps clear my mind on the front of building concurrent apps in the world of shared mem
21:35:16 <dolio> And I don't think you can blame Cale. Only 3 are from him.
21:35:44 <Cale> dolio: Oh, but you can, sort of. I'm the one who made the recommendation to Simon :)
21:36:14 <dolio> Ah.
21:37:35 <sw17ch> hmm... living in an embedded world without threads every day makes one pine for real live POSIX threads :)
21:37:53 <sw17ch> ... oh, and an operating system :)
22:06:30 <Plareplane> oh boy, the . and map post
22:06:34 <Plareplane> you've really done it now
22:13:04 <ABoyNamedWooh> @info .
22:13:04 <lambdabot> (.)
22:13:12 <ABoyNamedWooh> @type .
22:13:14 <lambdabot> parse error on input `.'
22:13:26 <sw17ch> @type (.)
22:13:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:17:25 <dolio> I think map should clearly go back to being over functors. I'm ambivalent about (.).
22:18:56 <dejones> Cale++
22:19:32 <Cale> @karma
22:19:33 <lambdabot> You have a karma of 73
22:19:36 <dejones> Cale++
22:19:38 <Cale> @karma
22:19:39 <lambdabot> You have a karma of 74
22:19:47 <dejones> Bonus point since Cale took the time two explain to me twice.  ;)
22:19:52 <Cale> hehe
22:19:53 <dejones> * to explain
22:20:01 <dejones> :D
22:20:04 <dejones> thanks again Cale
22:20:06 <dejones> back to studying
22:20:06 <dejones> cya
22:24:39 <Cale> ah, later dejones
22:24:51 <dejones> byyyee Cale :)
22:24:56 <sw17ch> alright, there's only so long i can work on this paper...
22:29:00 <cjs__> So how does one deal with a type such as, e.g., an integral that must be between 0 and 999, inclusive.
22:30:58 <OceanSpray> cjs__, I'm not getting you.
22:31:06 <OceanSpray> you mean an integral from 0 to 999?
22:31:13 <OceanSpray> oh
22:31:14 <OceanSpray> OH
22:31:22 <OceanSpray> an integer, you mean.t
22:31:45 <sw17ch> cjs__, a dependent type?
22:32:03 <cjs__> Sure, an Integer. Basically, I'm wondering how I make sure that I never try to create one that's, say, 1000.
22:32:07 <OceanSpray> But Haskell does not have dependent types, does it?
22:32:53 <roconnor> an enumeration :D
22:33:25 <roconnor> data foo = Zero | One | Two | ... | NineHundredNintyNine
22:33:30 <sw17ch> roconnor, short of creating data Lt1000 = One | Two | Three ... | OneThousand...
22:33:31 <sw17ch> :)
22:33:40 <cjs__> Ooo. I see. Unfortunately the actual range is 00000 to 99999, so it's a bit of typing....
22:33:42 <dolio> You can fake some checking of that sort with template haskell, but it'll be kind of annoying and ugly.
22:34:05 <sw17ch> Dependent Types are hard to check at compile time... you really need runtime checking for that sort of thing
22:34:08 <cjs__> I suppose I could use Church numerals in some weird way, if I can figure out how to stop the recursion at the appropriate point....
22:34:22 <OceanSpray> you mean Peano numbers?
22:34:33 <cjs__> Sorry, yes.
22:34:42 <OceanSpray> http://haskell.org/haskellwiki/Smart_constructors
22:34:47 <OceanSpray> read this.
22:35:49 <OceanSpray> pragmatically speaking, using 'em is pointless.
22:36:43 <OceanSpray> hold on there, sw17ch
22:36:58 <OceanSpray> dependent types are hard to check at compile time?
22:37:02 <OceanSpray> what do you mean?
22:37:22 <bugQ> it would be nice to create meta-types of some kind that would verify runtime restrictions.
22:38:04 <bugQ> well, I guess guards are good enough
22:38:05 <cjs__> Ah, that's a great page, thanks.
22:38:31 <dolio> I pasted some TH earlier that checks wheter a literal is prime, even, odd, etc. at compile time.
22:38:37 <cjs__> Yeah, I'm exporting functions with guards as constructors now. I was just hoping against hope that there was some brilliant way to deal with this.
22:38:42 <dolio> And tags is appropriately in the type system.
22:38:54 <OceanSpray> every language has limitations.
22:39:15 <cjs__> And regardless, I still have to deal in some way with bad data coming over the network at run time.
22:39:33 <cjs__> I wish the compiler could tell me when my program was going to receive bad data from the network.....
22:40:09 <OceanSpray> cjs__, how's that even possible?
22:40:17 <OceanSpray> The compiler can't see into the future!
22:40:23 <cjs__> Hey, I thought Haskell was more advanced than other languages!
22:40:40 <cjs__> Not even for just this one light cone?
22:40:54 * cjs__ is reading too much Charles Stross lately.
22:41:27 <bugQ> dolio: what tags do you speak of?
22:41:44 <dolio> http://hpaste.org/7141
22:42:09 <QtPlatypus> workCJS: His turing oricals?
22:42:16 <dolio> That code is kind of old. I haven't tested it in a while.
22:43:05 <bugQ> ah, yeah, not enough to just check literals, but useful for designing an optimization, I guess
22:44:38 <cjs__> Hey, can already-registered users quickly register a new alias?
22:45:41 <bugQ> pretty sure you have to switch to the nick in question to claim it.
22:46:30 <cjs__> I tried it, but it said I had to message a staffer. Oh, I guess I could do that. But is it really worth the trouble, I wonder. What a pain that someone else is logged in as cjs.
22:46:48 <bugQ> really? i've never got that message.
22:47:14 <bugQ> oh, i see
22:47:28 * paolino thinks the hsoc 2008 has very high goals :P 
22:48:10 <bugQ> better not to fulfill high goals than to prematurely finish low ones, maybe?
22:49:08 <bugQ> ..oh
22:49:13 <paolino> ehm, I didn't talk about fulfill
22:49:31 * bugQ loses his sense of sarcasm when it's late
22:49:41 <paolino> :)
22:49:43 <solrize> http://citeseer.ist.psu.edu/669645.html   cjs__, here ya go ;-)  (joking, sorta)
22:49:54 <lambdabot> Title: Ordinals and Interactive Programs - Hancock (ResearchIndex)
22:50:58 <bugQ> I guess that's my queue to leave, then.
22:52:04 <ABoyNamedWooh> lol I know how you feel cjs I usually go by Wooh and nobody ever takes it but someone on this server has taken it!
22:52:39 <cjs__> Oh no, lenses? What's next, bannanas?
22:53:06 <solrize> dogomorphisms
22:56:40 <ivanm> cjs__: is "cjs" your's? if so, did you try ghosting them?
22:57:45 <cjs__> It's mine, I thought. I think I had it at one point, since I've used it before. And yes, I do seem to recall something about trying to get it, if that's what "ghosting" is.
22:59:28 <ABoyNamedWooh> type /nickserv ghost cjs yourpassword
22:59:32 <ABoyNamedWooh> it will kick the other cjs off
23:04:04 <cjs__> Oh, is that how you do it?
23:04:20 <cjs> Yay!
23:29:49 <oklopol> o
23:40:41 <janszn> @pl concatMap (\n -> map (cuboid n)serie)
23:40:42 <lambdabot> (flip map serie . cuboid =<<)
23:43:01 <lety> hello anyone know how fast haskell is for ai?
23:43:22 <solrize> @faq is haskell suitable for fast AI code?
23:43:22 <lambdabot> The answer is: Yes! Haskell can do that.
23:43:37 <lety> i would like to write a poker bot
23:44:02 <lety> would ocaml be faster for it?
23:44:26 <lety> what about support?
23:44:27 <solrize> talk to joel reymont :)
23:46:22 <janszn> @pl concatMap (\n -> map (cuboid n)serie) [1..r]
23:46:22 <lambdabot> flip map serie . cuboid =<< [1..r]
23:46:57 <lety> solrize: would i be able to screen scrape in haskell? does haskell have bindings to win32 api?
23:48:06 <solrize> there is some win32 stuff, i don't know how complete i tis
23:48:07 <solrize> it is
23:48:18 <lety> :(
23:52:48 <solrize> if worse came to worse you could write some c++ code that pulled in win32 events and handed them off to a haskell program.  xmonad is something like that, i believe.
23:53:51 <sjanssen> xmonad is pure Haskell (more or less)
23:53:57 <lety> solrize: just wandering why doesn't haskell just compile to asm?
23:54:06 <lety> why to gcc
23:54:12 <solrize> it has asm generators for some cpu's
23:54:19 <solrize> c is more portable
23:54:40 <lety> i think gcc is not made to optimize haskell style code
23:54:46 <bd_> solrize: but the evil mangler isn't? :)
23:54:54 <bd_> isn't*
23:55:16 <sjanssen> lety: yes, this is true -- as GHC progresses the via-C route is becoming less deemphasized
23:55:39 <sjanssen> for example, in GHC < 6.8 -O implied -fvia-c, now it uses -fasm
23:55:47 <bd_> less deemphasized -> more emphasized
23:55:59 <lety> lol
23:55:59 <sjanssen> bd_: yes, I screwed that one up :)
23:56:07 <sjanssen> I mean it is becoming less emphasized
23:56:24 <bd_> anyway, http://hackage.haskell.org/trac/ghc/wiki/Commentary/EvilMangler <-- sounds less portable than -fasm, to me...
23:56:25 <lety> anyone why does haskell irc have 400 users and ocaml 80?
23:56:26 <lambdabot> Title: Commentary/EvilMangler - GHC - Trac
23:56:30 <lety> know*
23:56:45 <sjanssen> lety: because #haskell rocks
23:56:45 <bd_> Because we're cooler ;)
23:57:03 <lety> no but seriously :)
23:57:28 <Heffalump> I think Haskell has become very popular in the last few years
23:57:54 <bd_> I've not been there myself, but I've heard that there are some people in #ocaml who can be a bit... abrasive.
23:57:56 <Heffalump> ocaml's user base has mostly been around much longer, I suspect they're not getting many new users
23:57:59 <sjanssen> lety: we're being serious.  #haskell grew so large because it is a really good resource, people are friendly and knowledgeable, and we work to maintain that
23:58:02 <lety> last i looked haskell and ocaml had the same number of installs on debian and unbuntu
23:58:16 <Heffalump> that's a pretty inexact metric
23:58:22 <cjs> I expect a lot of those are curiousity installs, though.
23:58:43 <inimino> lety: there are probably more people currently learning Haskell
23:58:44 <cjs> I have a PLT Scheme install on a lot of machines, but I hardly use it.
23:59:06 <lety> is haskell being more actively developed?
23:59:15 <cjs> I can think of many reasons why Haskell would be gaining right now.
23:59:31 <lety> cjs: what are they?
23:59:58 <cjs> It's only relatively recently had a great compiler, Perl6, it's honestly a more powerful language than O'Caml, from the looks of it....
