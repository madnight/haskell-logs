00:42:50 <functor> how can I filter duplicate elements in a list?
00:42:55 <Cale> nub
00:42:56 <functor> anyone?
00:43:07 <Cale> > nub [1,1,2,3,1,2,3,4,3,4]
00:43:14 <Cale> It's in Data.List
00:43:15 <lambdabot>  [1,2,3,4]
00:43:47 <functor> thanks =]
00:46:48 <Cale> However, that's O(n^2) (really O(k^2) where k is the number of list items you look at). If you don't mind an implementation which sorts the list, you can use map head . group . sort
00:46:48 <Heffalump> or you can use a Set and still get O(n log n) behaviour without sorting
00:46:48 <Heffalump> (a Set to keep track of things seen so far)
00:46:48 <sjanssen> Cale: O(k n), I think
00:46:49 <Cale_> oof
00:46:49 <Cale_> In case you didn't get that last comment...
00:46:49 <Cale_> However, that's O(n^2) (really O(k^2) where k is the number of list items you look at). If you don't mind an implementation which sorts the list, you can use map head . group . sort
00:46:55 <olsner> Cale: sjanssen thinks it's O(kn) :P
00:47:05 <sjanssen> erm, no
00:47:06 <sjanssen> I'm wrong
00:47:14 <olsner> *thought :P
00:47:46 <MyCatVerbs> :t group
00:47:47 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
00:47:58 <Heffalump> Cale_: is all the code lambdabot is running in the repo on code.haskell.org?
00:48:05 <vincenz> Passe compose
00:48:09 <Cale_> mm, have to be careful -- the k isn't the number of elements of the resulting list you look at, it's the largest index of the original list which you look at in the new one :)
00:48:19 <Cale_> Heffalump: I believe so, yeah.
00:56:17 <solrize> @pl \ a b -> show (a,b,foo a b)
00:56:18 <lambdabot> (show .) . liftM2 ap (,,) foo
00:56:25 <solrize> yuck
00:56:56 <olsner> @ty show .: liftM2 ap (,,) ?foo
00:56:57 <lambdabot> Not in scope: `.:'
00:57:37 <olsner> hmm, no, that's probably not right
00:57:47 <vincenz> liftM2 ap ...
00:57:50 <vincenz> nasty
00:57:54 <vincenz> that's a double monad
00:58:03 <olsner> @ty liftM2 ap
00:58:04 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m1, Monad m) => m1 (m (a -> b)) -> m1 (m a) -> m1 (m b)
00:58:25 <Cale> Double reader :)
00:58:27 <vincenz> fortunately they're both reader-monads here (one for a -> one for b ->)
00:59:12 <olsner> @ty liftM2 ap :: (a -> b -> c -> d) -> (a -> b -> c) -> a -> b -> d
00:59:13 <lambdabot> forall a b c d. (a -> b -> c -> d) -> (a -> b -> c) -> a -> b -> d
01:00:18 <Cale> That actually makes a surprising amount of sense now.
01:00:30 <olsner> yeah, it's scary
01:01:00 <olsner> @ty liftM2 ap (,,) -- this'll be even more sense-making, I suspect
01:01:01 <lambdabot> forall a a1 b. (a1 -> b -> a) -> a1 -> b -> (a1, b, a)
01:01:23 <vincenz> :|
01:01:44 <olsner> unfortunate naming of the types though
01:02:25 * vincenz wonders when it choses to do different letters and when it chooses to use numbers
01:03:10 <Cale> It gets hints from explicit type annotations as to what to name the variables, and I think if two of them have the same name, it starts numbering.
01:04:18 <olsner> hmm, I wonder if it would be better or worse to replace that with a heuristic name-assigner
01:05:37 <vincenz> I think it should do lazy naming
01:05:39 <vincenz> and only name on show
01:06:00 <vincenz> that way you can guarantee a nice, uniform, sequential naming pattern
01:07:06 <sjanssen> there are nice aspects to the current system
01:07:11 <sjanssen> @type getLine
01:07:12 <lambdabot> IO String
01:07:41 <sjanssen> @type (>>=)
01:07:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
01:07:59 <vincenz> sjanssen: such as?
01:08:30 <sjanssen> vincenz: type synonyms are preserved
01:08:55 <sjanssen> and things like the commonly used 'Monad m' are as well
01:09:24 <vincenz> type synonyms would not be affected, as I'm talking about type-variables only
01:09:34 <vincenz> But I grant you the  monad bit
01:13:12 <Heffalump> does anyone know where the Stream package is? (Required by arrows which is required by lambdabot, AFAICT)
01:14:42 <functor> Cale, how do I determine if a string is contained within a string (i.e. is the string "++" contained within the string "1++2")? Is this not possible? All the functions in the Prelude and Data.List (find, elem, filter..) only work with elements. =[
01:15:10 <Toxaris> :t app :: ArrowApply (~>) => (a ~> b, a) ~> b
01:15:11 <lambdabot> forall (~> :: * -> * -> *) a b. (ArrowApply ~>) => ~> (~> a b, a) b
01:15:17 <sjanssen> Heffalump: should be on Hackage
01:15:19 <Cale> functor: isInfixOf
01:15:33 <solrize> so my program is basically   mapM_ myfunc big_input    is there a simple way i can run it in parallel on a multicore box?  i.e. without going and writing stuff with chans etc.
01:16:24 <Toxaris> hmm if that would work better, it would be an example for more important keeping of user-defined type variable names (because the difference between infix / prefix is more visible then the difference between different names)
01:16:46 <sjanssen> @hackage Stream
01:16:47 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Stream
01:16:51 <functor> Cale, Thanks!
01:16:53 <functor> =]
01:17:00 <Heffalump> oh, so it is. I could have sworn I searched that page. Sorry!
01:17:18 <sjanssen> Heffalump: you really should try cabal-install :)
01:17:33 <Heffalump> I want to find darcs repos and install from those, though
01:20:20 <vincenz> Cale: I thought you were heading to bd
01:20:22 <vincenz> +e
01:20:33 <Cale> vincenz: I probably should.
01:30:38 <solrize> ~/rj +RTS -M128m -RTS   doesn't change the memory footprint seen from "top", is there some other flag to increase the heap size?
01:36:48 <Heffalump> trying to build lambdabot from darcs, and I get Setup.hs: can't find source for FTbase in ["scripts/FT"]
01:37:28 <olsner> solrize: that sets the maximum heap size; that would guarantee that it *doesn't* grow
01:38:15 <solrize> hmm, the program only uses about 7 meg which means with more heap it would gc less i thought
01:38:20 <solrize> otoh it would miss cache a lot more
01:38:30 <solrize> maybe i should make the heap smaller to hit the cache more
01:39:05 <solrize> i guess it's a generational gc so doesn't miss much
01:39:33 <olsner> if you want to set a heap size, maybe you could use the -H flag (minimum heap size)
01:39:45 <solrize> thanks i'll try that
01:40:43 <olsner> GC is probably run before trying to expand the heap, so you get stuck with something close to the least amount actually required
01:41:17 <solrize> yeah that would make sense.  i think expanding the heap isn't a good strategy for this prog (lots of consing of short lived objects) for cache reasons
01:47:48 <solrize> man i'm really hosed.  the haskell json module is at least 5x slower than the python one.
01:48:05 <olsner> solrize: profile, then fix it ;-)
01:48:31 <solrize> i think it's unfixable, it has to be rewritten from scratch, which i might attempt, though it's a bit much for me at the moment
01:48:57 <solrize> i might instead change the input format (comes out of a python prog) from json to a binary format that i can parse fast
01:51:19 <solrize> after hacking haskell code for a a few hours i feel like i just took a math test
01:51:38 <solrize> i wonder if it gets easier with practice
01:54:15 <solrize> i will use ghetto parallelism and just split the input across several machines by hand.  that's the ticket.
01:57:59 <solrize> ai yi, 2am again.  i better sleep.  thanks everyone.  this was my first .hs program that wasn't a complete toy, so it's an accomplishment even though it turned out dog slow :).  gnite
02:29:36 <Saul_> Lemmih: I'm having a bit of trouble using your fastcgi bindings (http://hpaste.org/7058)
02:30:16 <Saul_> Lemmih: Single-threaded seems to work fine, but if I try multi-threading things go very wrong
02:30:59 <Saul_> Using forkOS gives instant internal server errors (500), while using forkIO works well if I limit it to 1 thread
02:31:39 <Saul_> but using forkIO with more than one thread it takes forever and I probably get a timeout and I see a 500 error
02:34:25 <vincenz> Saul_: you probably want to use STM
02:34:47 <mehrheit> @index (%)
02:34:47 <lambdabot> Data.Ratio
02:34:49 <Saul_> vincenz: I do, but I want to test concurrency first
02:35:34 <vincenz> Saul_: exactly, you want to make sure your IORef writes are correct, concurrency-wise
02:37:11 <Saul_> vincenz: True, but it is rather pointless to use STM, but not concurrency :)
02:37:48 <Saul_> But it doesn't, even with a simple hello world program
02:39:32 <Saul_> it doesn't work*
02:39:43 <vincenz> Oh, then I misunderstood you, I thought you were threaading access in that program
02:39:47 <vincenz> (and not showing it in the paste :)
02:41:00 <Saul_> The paste is the whole program
02:41:34 <Saul_> And the point was that the IORefs weren't thread-safe, so I could see that threading was working
02:41:51 <vincenz> oh right
02:42:01 <vincenz> well there is your problem, you're forking multiple accesses to 'inc'
02:43:55 <Saul_> Actually, the much simpler http://hpaste.org/7058#a1 also has the same problems
02:44:17 <vincenz> Then I'm afraid it lies out of my knowledge, I'm not familiar with that framework
02:44:32 <vincenz> potentially: you're not returning proper headers?
02:45:02 <Saul_> Perhaps, although that would suggest that the single-threaded version also wouldn't work
02:45:24 <vincenz> Does it work?
02:50:23 <Saul_> It doesn't look like it
02:50:40 <Saul_> @seen Lemmih
02:50:40 <lambdabot> Lemmih is in #haskell. I don't know when Lemmih last spoke.
02:54:14 <Saul_> hmmz now it does seem to work
02:54:32 <Saul_> But only after a few failed attempts
02:55:16 <Saul_> Hmm now it doesn't anymore :S
02:55:52 <Saul_> It's really weird, it seems to work sometimes, but it's highly unstable
02:57:05 <Saul_> And that was with only two threads, it gets far worse with more of them
03:09:43 <Lemmih> Saul_: Using apache?
03:17:07 <Saul_> Lemmih: Yes
03:32:26 <Saul_> Lemmih: So the problem might be there?
03:45:30 <ilyak_> how much is x : xs faster than xs ++ [x]?
03:45:38 <ilyak_> If, say, length of xs is ten?
03:46:11 <ilyak_> Anso, how faster or slower is [x] ++ xs to xs ++ [x]?
03:46:43 <ilyak_> (I wonder if one should really interpret XSLT templates from bottom to top
03:47:09 <ilyak_> (This way it would be x : xs all the way up)
03:47:35 <Deewiant> compilers optimize [x] ++ xs to x:xs
03:47:56 <Deewiant> and that's a constant-time operation, whereas xs ++ [x] takes time proportional to the length of xs.
03:48:15 <Deewiant> haven't benchmarked it so I don't know any numbers, though.
03:48:50 <Saul_> ilyak_: xs ++ [x] takes as much time as the length of xs, while x:xs (which is equal to [x] ++ xs) takes constant time
03:49:12 <ilyak_> Saul_: How faster is it in case length xs is ten?
03:49:15 <Saul_> meaning that the former is length xs times slower than the latter
03:49:24 <Saul_> ten times
03:49:25 <Deewiant> it's about ten times faster.
03:49:41 <ilyak_> Ok, it looks like we should rearrange XSLT template to reverse order of its operators
03:50:04 <ilyak_> Given that XSLT is pure, we can easily do this
03:50:34 <Saul_> That might be smart
03:50:58 <Deewiant> ilyak_: you might be interested in Data.DList, supports constant-time append: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist
03:51:07 <Saul_> if you need to add and grab elements on both sides of the list though, it might be useful to use Data.Sequence instead
03:51:31 <ilyak_> Saul_: I don't, I'll just grow it from one side and give out
03:51:40 <ilyak_> Deewiant: It will require a lot of conversions
03:51:46 <ilyak_> Because HXT is list-based
03:52:01 <ilyak_> And I don't really need that given I can grow list in this direction
04:24:49 <yuriyp> @src unions
04:24:49 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
04:25:08 <yuriyp> @hooglw unions
04:25:09 <lambdabot> Data.Set.unions :: Ord a => [Set a] -> Set a
04:25:09 <lambdabot> Data.Map.unions :: Ord k => [Map k a] -> Map k a
04:25:09 <lambdabot> Data.IntSet.unions :: [IntSet] -> IntSet
04:25:14 <sioraiocht> using ghc 6.8 and trying to install lhs2tex I get the error     Could not find module `Distribution.Program':
04:25:42 <yuriyp> @src Data.Set.unions
04:25:42 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
04:26:45 <ivanm> yuriyp: lambdabot doesn't have the source of everything :p
04:26:53 <ivanm> sioraiocht: which version of lhs2tex?
04:27:03 <takamu> > pl \f z x y -> f x y z
04:27:03 <lambdabot>  Parse error at "\f" (column 4)
04:27:11 <sioraiocht> ivanm: yean nevermind, i realised i somehow downloaded 1.12
04:27:17 <ivanm> ahhh, k
04:27:22 <takamu> pl \f z x y -> f x y z
04:27:26 <takamu> @pl \f z x y -> f x y z
04:27:27 <lambdabot> flip . (flip .)
04:27:32 <wjt> @src S.unions
04:27:33 <lambdabot> Source not found. My brain just exploded
04:27:37 <wjt> doh.
04:36:24 <ivanm> for some reason, doing operations with darcs-1 repos using darcs-2 seems slower :s
04:37:03 <Deewiant> the announcement does say "Darcs 2.0.0 contains some performance regressions when running with large
04:37:06 <Deewiant> repositories."
04:37:41 * ivanm doesn't think the xmonad repos are that large :p
04:37:56 <ivanm> nor the gentoo-haskell one, though I might be mistaken on that score
04:39:14 <ivanm> does 1675 patches count as large?
04:40:58 <Heffalump> I hope not!
04:41:12 <Heffalump> large in that announcement means "GHC", aiui.
04:42:02 <ivanm> yes, that's what I figured
05:25:40 <ToRA> anyone know if there is there a reason why there isn't an instance for Error () in the std libs?
05:34:43 <Heffalump> what would it do?
05:34:51 <Heffalump> why not just use Maybe?
05:35:26 <ToRA> yeah, i've realised that
05:35:28 <ToRA> i had
05:35:33 <ToRA> runErrorT $ (ask >>= Map.lookup n >>= return . lv) `catchError` (\ (_::()) -> return $ gv qid)
05:35:36 <ToRA> but actually
05:35:42 <ToRA>  liftM (maybe (gv qid) lv) (asks (Map.lookup n))
05:35:44 <ToRA> is the same thing
05:36:46 <byorgey> chopping code length in half is a sweet, sweet thing =)
05:37:03 <ToRA> it is indeed
05:37:21 <Heffalump> byorgey: does oeis have a darcs repo online?
05:37:40 <ToRA> it's worrying when you start thinking your over-engineering things because one line is twice as long as it could be...
05:38:52 <byorgey> Heffalump: heh, sjanssen just asked that the other day. =)  I've applied for a directory on c.h.o but haven't heard back about it yet.
05:39:11 <byorgey> I'll let you know as soon as it's up though.
05:43:10 <sioraiocht> is there a good list of haskell one-liners around?
05:43:27 <Heffalump> filter typeChecks $ generateAllStrings
05:49:47 <byorgey> sioraiocht: there's the 'blow your mind' page on the wiki
05:49:59 <sioraiocht> cheers
05:50:43 <Botje> heh
05:51:07 <Botje> #haskell is the only place where mindblowing is _this_ normal :)
05:51:19 <ksandstr> the cost is increased tolerance.
06:01:09 <olsner> ksandstr: yeah, the high gets a little bit lower every time
06:01:37 <ksandstr> you find yourself looking for purer stuff, until only point-free oneliners will do
06:02:17 <dolio> I can't even feel it unles it contains at least three flips.
06:04:31 * olsner needs his hourly 'fix' O.O
06:04:58 <olsner> > take`id`20$fix$(.)<$>(:)<*>((.((:[]).))(=<<).(*).(*2))$1
06:05:03 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
06:05:40 <dolio> Awww yeeeah. That's the good stuff.
06:06:21 <olsner> yeah, your usual run-of-the-mill suppliers always mix it up with whitespace... needs it pure!
06:07:23 * Botje 's mind blows
06:07:31 <Botje> thoroughly.
06:08:41 <olsner> I might have to go over to fixpoint monads though, a few lines of ordinary haskell just doesn't have that kick
06:09:16 <ksandstr> it's sort of funny how rarely run of the mill, straightforward functional code is discussed itc
06:09:44 <dolio> You should try some ArrowLoop action.
06:10:14 <desegnis> German "Fixer" means someone who consumes heroin... that should tell it all
06:11:03 <dolio> You're not allowed to send run of the mill code to the channel.
06:11:07 <dolio> You have to use hpaste.
06:12:05 <olsner> ooh, yeah, ArrowLoop, that stuff'll mess up your head bad
06:21:54 <olsner> @type flip const
06:21:56 <lambdabot> forall a b. b -> a -> a
06:23:06 <Bonus> i finally get moands!
06:23:07 <Bonus> whoo!
06:23:08 <Bonus> :D
06:23:28 <Bonus> now to write a tutorial about them
06:23:34 <yuriyp> @src all
06:23:34 <lambdabot> all p =  and . map p
06:23:42 <olsner> @ty let if' = ([const, flip const] !!) . fromEnum in (if' True 1 2, if' False 1 2)
06:23:43 <lambdabot> forall t t1. (Num t1, Num t) => (t, t1)
06:23:51 <olsner> > let if' = ([const, flip const] !!) . fromEnum in (if' True 1 2, if' False 1 2)
06:23:53 <lambdabot>  (2,1)
06:23:58 <yuriyp> @src and
06:23:58 <lambdabot> and   =  foldr (&&) True
06:24:03 <olsner> > let if' = ([flip const, const] !!) . fromEnum in (if' True 1 2, if' False 1 2)
06:24:04 <lambdabot>  (1,2)
06:24:26 <olsner> pointsfree if' <3
06:27:49 <desegnis> > let true = flip const; false = const in (true 1 2, false 1 2)
06:27:50 <lambdabot>  (2,1)
06:28:20 <desegnis> er
06:28:26 <olsner> desegnis: yeah, just redefine True and False and have if' = id :P
06:28:27 <desegnis> bah
06:28:28 <dolio> > let fact = loop (\(n, f) -> (f n, \k -> if k < 2 then 1 else k * f (k-1))) in map fact [1..5]
06:28:29 <lambdabot>  [1,2,6,24,120]
06:28:49 <desegnis> olsner, yeah, but I should still do it the right way around
06:29:18 <olsner> what's true for you may be false for me, what do I know :P
06:34:41 <olsner> @ty mapMaybes
06:34:42 <lambdabot> Not in scope: `mapMaybes'
06:34:44 <olsner> @ty mapMaybe
06:34:45 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
06:36:16 <dolio> That factorial definition seems like cheating.
06:36:17 <olsner> hmm, is it faster to count on parsec's parse errors to detect that the input doesn't match the wanted input, or is it best to build a parser that parses anything and returns Maybe?
06:36:24 <dolio> I'm not sure how to do it better, though.
06:36:42 <olsner> @ty loop
06:36:43 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
06:37:39 <ToRA> > map (product . enumFromTo 1) [1..5]
06:37:40 <lambdabot>  [1,2,6,24,120]
06:37:40 <EvilTerran> olsner, i think it's best to use the parse errors
06:37:47 <EvilTerran> that way you also get error location info for free
06:37:57 <desegnis> How should a significant Parsec parser parse anything?
06:38:52 <olsner> but I'm not interested in the error message or location, only in success+data or failure
06:42:28 <Botje> olsner: parse already returns Either, and parsec is pretty good at failing fast, so ..
06:44:26 <olsner> I guess I'll go with using parsec's failure then... especially since it's also easier than the other way :P
06:45:26 <desegnis> Also, the ParseError fields in the parsec source are not marked strict afaics, so there should be not much overhead if you don't use them?
06:46:19 <desegnis> Hm, there are seq annotations though
06:47:02 <fnord123> anyone have a sweet vim syntax file for .hsc?
06:49:06 <fnord123> nm, haskell mode works well enough
06:50:35 <Saul_> Lemmih: You there?
06:50:42 <Lemmih> Saul_: Yes.
06:50:58 <Saul_> You asked if I was using apache, which I am
06:51:08 <Saul_> Anything I might be doing wrong there?
06:51:54 <Saul_> http://hpaste.org/7058
06:52:16 <Saul_> I see morrow posted something that seems to work, I'll try that out now
06:56:54 <Saul_> Lemmih: That also doesn't seem to work here
06:57:47 <tony2> I've a hopefully very quick question: I'm trying to use the HsJudy package via ghci but get unknown symbol `judy1_free' error. I've set my LD_LIBRARY_PATH to point to dir containing judy libs, and tried a few cmd line options?
06:58:09 <Lemmih> Saul_: We had some problem with concurrency in 6.6 but they seemed to go away with 6.8+lighttpd.
06:58:28 <Saul_> I have 6.8.2
06:58:49 <Saul_> but I really need to use apache, since my webserver doesn't have lighttpd
06:59:19 <tony2> Am I missing something obvious? I'm not to hot on linking.
07:03:40 <yuriyp> @hoogle intersects
07:03:42 <lambdabot> No matches found
07:12:21 <kuribas> quicksilver: I have added case guards to haskell-indentation.el.
07:17:23 <dolio> kuribas: Oh, I've noticed, haskell-indentation doesn't like {- -} comments.
07:18:02 <dolio> I suppose I should get in the habit of using comment-region.
07:19:24 <olsner> @ty putStr . unwords . mapMaybe (flip M.lookup ?files) . S.toList -- thread killed => bot bug?
07:19:26 <lambdabot> forall a. (?files::M.Map a String, Ord a) => S.Set a -> IO ()
07:20:04 <olsner> hmm, I got thread killed when I privmsg'd it to lambdabot
07:20:05 <dolio> It randomly gets thread killed messages.
07:20:17 <dolio> Since it moved to code.haskell.org, I think.
07:20:21 <olsner> oh, okay
07:32:49 <Jedai> @hoogle mapMaybe
07:32:49 <lambdabot> Data.Maybe.mapMaybe :: (a -> Maybe b) -> [a] -> [b]
07:32:49 <lambdabot> Data.Map.mapMaybe :: Ord k => (a -> Maybe b) -> Map k a -> Map k b
07:32:49 <lambdabot> Data.IntMap.mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
07:33:07 <Jedai> @src mapMaybe
07:33:07 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
07:33:15 <Jedai> @src Data.Maybe.mapMaybe
07:33:15 <lambdabot> Source not found. My mind is going. I can feel it.
07:33:28 <Jedai> ?source Data.Maybe
07:33:28 <lambdabot> http://darcs.haskell.org/packages/4/Data/Maybe.hs
07:34:37 <olsner> catMaybes . map, probably
07:35:09 <olsner> or something like catMaybes `boobs` map
07:35:28 <SamB> where boobs = (.).(.)?
07:35:34 <olsner> yeah
07:36:06 <SamB> @type (.).(.)
07:36:07 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
07:36:15 <SamB> damn you, Cale !
07:36:28 <SamB> @type (P..)P..(P..)
07:36:29 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
07:36:37 <SamB> icky icky icky
07:36:59 <olsner> > let boobs = (P..)P..(P..) in catMaybes `boobs` map
07:37:00 <lambdabot>  Add a type signature
07:37:07 <olsner> @ty let boobs = (P..)P..(P..) in catMaybes `boobs` map
07:37:08 <lambdabot> forall a a1. (a1 -> Maybe a) -> [a1] -> [a]
07:37:36 <olsner> been mixing up @ty and > all day
07:38:05 <SamB> @ty let boobs = (.).(.) in catMaybes `boobs` map
07:38:06 <lambdabot> forall a a1. (a1 -> Maybe a) -> [a1] -> [a]
07:38:22 <tony2> Can't get HsJudy to work......No one here used it?
07:38:57 <olsner> hmm, yeah, those Functors obviously collapse into their function instance when applied to those arguments
07:42:26 <Jedai> olsner: Yeah, that's what I figured, but I wanted to be sure. In fact it is catMaybes . map, but expressed by a direct recursion.
07:43:57 <EvilTerran> ?type mapM
07:43:59 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
07:44:11 <EvilTerran> hm... no, that's not what i want
07:44:19 <olsner> hmm, well, it does depend on whether you want the quickest-to-write or fastest implementation
07:44:43 <Jedai> EvilTerran: sequence ?
07:44:57 <Jedai> ?type sequence
07:44:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:45:05 <EvilTerran> nah, nvm
07:45:27 <EvilTerran> i was trying to remember if there was some other way of saying catMaybes .: map
07:46:21 <Jedai> ?type (catMaybe .) . map
07:46:25 <lambdabot> Not in scope: `catMaybe'
07:46:27 <Jedai> ?type (catMaybes .) . map
07:46:31 <lambdabot> forall a a1. (a1 -> Maybe a) -> [a1] -> [a]
07:47:02 <EvilTerran> ?type concatMap . (maybeToList.)
07:47:03 <lambdabot> forall a a1. (a -> Maybe a1) -> [a] -> [a1]
07:50:20 <Saul_> How do you use .hsc files?
07:55:18 <EvilTerran> Saul_, you pass them through hsc2hs
07:55:21 <EvilTerran> ?where hsc2hs
07:55:21 <lambdabot> I know nothing about hsc2hs.
07:55:29 <EvilTerran> er
07:55:53 <Saul_> EvilTerran: thanks
07:56:04 <EvilTerran> ?where+ hsc2hs http://www.haskell.org/ghc/docs/latest/html/users_guide/hsc2hs.html
07:56:04 <lambdabot> I will remember.
08:03:50 <kuribas> dolio: It should have no problem with such comments.
08:04:09 <kuribas> dolio: Only when you have code on a line after -}
08:04:21 <dolio> kuribas: Well, unterminated it seems to.
08:04:32 <dolio> Yeah, using them to comment out code.
08:04:42 <dolio> Oh, well.
08:05:48 <dolio> If I have a {-, then a line of code, and I press enter at the end of that line of code, I get a complaint, and the enter does nothing.
08:07:18 <kuribas> dolio: It sounds like a bug.
08:07:21 <dolio> Hmm, actually, it doesn't seem to do it off the bat, now that I'm testing it.
08:09:56 <dolio> Okay, this seems to reproduce it from a new file:
08:10:10 <dolio> "\n{-\nfoo a = bar a"
08:10:28 <dolio> Starting the comment on the first line allows me to keep typing.
08:11:03 <fnord123> Is there a way to have a type of a -> IO () where IO() is actually nothing (stubbing out using conditional compilation in a .hsc)
08:11:09 <dolio> But typing enter at the end of that gives me "Illegal token: layout-next"
08:11:40 <fnord123> i thought, e.g. > stub :: a -> IO () \ stub _ = do return
08:11:51 <kuribas> dolio: Hm, it should know that it is inside a comment.
08:11:52 <Tordek>  /j #c
08:12:01 <Tordek> sorry ;P
08:12:02 <dolio> "\n{-\nfoo a = bar a\n-}" gives the same error.
08:12:09 <Beelsebob> fnoble: \x -> return () -- this is what you're looking for I think
08:12:15 <Beelsebob> fnord123: even
08:12:48 <Beelsebob> there are various functions already defined with that type though
08:12:50 <Beelsebob> e.g. print
08:12:53 <Beelsebob> or putStr
08:13:11 <Beelsebob> well, beth are more specific types to varying degrees
11:26:53 --- topic: '["The Haskell programming language" ,"http://haskell.org " ,"Paste: http://hpaste.org " ,"Logs: http://tunes.org/~nef/logs/haskell/"]'
11:26:53 --- topic: set by Cale on [Thu Apr 10 20:49:20 2008]
11:26:53 --- names: list (clog matthew_- catbee Beelsebob andrei gwern schme int-e benny99 s|k_ fophillips efdetonator dv\ paolino mattrepl Cale s710b goalieca ToRA bos31337 Nshag Daveman rey_ mauke erg0t mlh fdr- travisbrady shachaf SyntaxNinja phlpp_ sm mrsolo sioraiocht arjanb chessguy kipras AndreWe entropie Yuffster Aduros fnordus gbeshers dibblego SamB Baughn thou jfredett f00li5h aeonproxy Choko sek MarcWeber [CitationNeeded] cjb jrx Feuerbach lekro RayNbow)
11:26:53 --- names: list (zamez noteventime cognominal_ ank616 mxc globra pierre- kayess Jaak AtnNn fnoble kopophex macondo EvilTerran rukav skorpan johnnowak ttmrichter_ asmanian davidL SuttoL sad0ur Blicero TomMD edward2 umis hrehf conal zerny cinema thotypous tony2 hmich_ Duddle gweiqi exe LordMetroid fnord123 astrolabe ArthurClemens_ kpreid ZsoL alc daniel_larsson mmorrow twanvl iblechbot Axioplase augustss_ BCoppens jeffz ilyak_ mperillo wadcom hkBst igel rawicki)
11:26:53 --- names: list (ken_____ petekaz` borism metavoid ddvlad nottha_k_ therp musiKk tensh thorkilnaur scook0 aik njbartlett clanehin gogonkt Gilly edwinb Liskni_si bens Gnezdo vincenz mornfall koeien cjay roderyk tirpen bsod2 mercury^_ Toxaris olsner smtms rdd matveev jatqceer takamu Plareplane unknown_ dolio dcoutts_ stef_ idnar bd_ tessier saccade_ Nucleo lQg magagr glith jberryman dvekravy dropdriv2 Dessous lars_t mar77a geezusfreeek sw17ch liesen_ OceanSpray)
11:26:53 --- names: list (dobblego araujo robreim bugQ s1d Nanar dort rue Arnia blbrown dblog SubStack lambdabot capiCrimm rdtsc eyck ski_ foff seafood Arnar cdsmithu1 sarehu_ Spockz|Away timchen1` Shurique jleedev Staz Modius_ vinc456 znutar byorgey yango integral solrize_ lucca- encryptio Betovsky monadproxy agemo deemon ksandstr jamesjb huamn baaba proq mokomull krunga z|Andy binary42 LordBrain Igloo Peaker mathrick Korollary Time`s_Witness gal_bolle sclv delYsid)
11:26:53 --- names: list (DukeDave mux_ dcoutts pjd_ atsampson cbe uebayasi stylus r0bby mm_freak wjt DRMacIver u_quark liyang awesame simony czShadoW stevan drbean ajhager sjanssen desp arnar_ hhg zgold Ginzor Botje ohub dogbite_ chylli mapreduce inimino ivan dmwit gbacon czakey schlumpi noj GNU\caust1c gnuvince cnwdup Syzygy- huh obk ydo ertai cods qebab kaol bran_ yahooooo2 m4thrick_ jonafan Taggnostr OnionKnight nipuL OscarZ lament worklez quicksilver klugez)
11:26:53 --- names: list (pantsd__ loupgaroublond Runar pastorn Jedai Tigge MyCatVerbs gnuvince_ fxr thingwath kscaldef Twey xinming redbeard0532 flori opqdonut1 Japsu pragma_ felipe tromp kilimanjaro |jeremiah mattam Nafai omg-9238423 IvdSange1 bockmabe_ elias` lasts netx nornagon spopp Boney authentic dionoea ulfdoz solrize raxas audreyt kennyv Eelis geocalc blarz wagle nothingmuch Tobsan jvoorhis Lycurgus Jiten orbitz whoppix jones- rblackwe muhtimin xsdg trez)
11:26:53 --- names: list (earthy Tordek Khisanth Laney thedward tankgirl_ dino- kpk roconnor purplepenguins arjanoosting myki ski cmeme pantsd_ flx mrd SimonRC joed QtPlatypus kalven Dreamer`_ arguile allbery_b Oatschool osfameron junlajipcis laz0r elliottt Riastradh Lunchy mokus _frederik_ Vulpyne wli tessier_ hellige warmenhoven jmei xerox wolverian Thas eno rumbleca kokekola Poeir_ wang Caelum @ChanServ Shimei DuClare miasma chr1s ac lispy Mitar opqdonut ibid)
11:26:53 --- names: list (saiam qwr Vq^ gds sieni ath Deewiant funktio Smurfen ziman l_a_m mwti kosmikus acura shoragan puusorsa kolmodin mux Heffalump trurl jql dons wifs Philippa buff_drinkslot daf smg tuukkah ray koninkje_away newsham profmakx Fubar^ pa-ching lostman_ Zao nnunley yuriyp)
11:27:09 <newsham> perhaps the author made a mistake?
11:27:19 <Baughn> OceanSpray: \footnote{GHC exposes "unlifted" types that don't contain bottom. Don't use them.}
11:27:48 <efdetonator> maybe, but I'm not good in haskell to say that he made a mistake
11:28:07 <chessguy> @hoogle sortBy
11:28:08 <aeonproxy> efdetonator: which interpreter are you using?
11:28:08 <lambdabot> Data.List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
11:28:16 <geezusfreeek> efdetonator: what page is this one?
11:28:21 <efdetonator> ghci
11:28:46 <newsham> efde: I think the answer he was looking for is  "func5 f = ...."
11:28:47 <OceanSpray> Baughn, what are those?
11:28:50 <geezusfreeek> page number? :)
11:28:54 <newsham> ie. you can easily remove the "l" part
11:29:01 <newsham> answer page 172
11:29:12 <newsham> question page 79
11:29:14 <efdetonator> yes
11:29:15 <Baughn> OceanSpray: Basically machine types. Bare ints, doubles, the sort of thing you'd see in Cee - and used to implement haskell.
11:29:27 <chessguy> what are the minimum functions you have to define for Ord?
11:29:43 <newsham> efde: email the author :)
11:29:53 <Baughn> OceanSpray: They may sometimes be useful as a weapon of last resort to improve performance, but generally that's the /optimizer's/ job - any code that is improved by switching to them is supposedly exposing a compiler bug. ;)
11:30:09 <OceanSpray> interesting.
11:30:14 <aeonproxy> efdetonator: do you remember about 'let' before functions, lists etc?
11:30:25 <Baughn> OceanSpray: Lots of details on the haskell wiki
11:30:42 <Cale> efdetonator: which solution?
11:30:42 <efdetonator> aeonproxy yes
11:30:50 <efdetonator> Cale func5
11:31:02 <efdetonator> Cale solution 7.1   func5 = ...
11:31:18 <Cale> okay, one minute
11:32:17 <efdetonator> newsham I tried func5 f = ...  but it also didn't work, I'll try to email the author
11:32:36 <aeonproxy> efdetonator: so which errors do you get?
11:33:13 <Cale> func5 f = foldr (\x y -> f (y,x)) 0
11:33:39 <newsham> thats what I said. :)
11:34:02 <efdetonator> first I tried func5 f l = foldr (\x y -> f (y,x)) 0 l                     and I typed func5 (fst) [1,2,3] and the result was 0
11:34:24 <efdetonator> then I tried with his solution and the interpreter threw an error =/
11:34:26 <newsham> you dont need to parenthesize fst, btw.
11:35:07 <Cale> Oh, or yeah, you could replace that lambda term with flip (curry f)
11:36:12 <efdetonator> thanks Cale it worked
11:36:47 <efdetonator> the author flipped the functions lol
11:37:02 <efdetonator> he put uncurry $ flip f
11:37:09 <Cale> He did?
11:37:17 <Cale> Which version of YAHT are you looking at?
11:37:24 <Cale> http://darcs.haskell.org/yaht/yaht.pdf
11:40:02 <efdetonator> Cale someone sent me and old version -_-
11:40:11 <efdetonator> sorry
11:40:16 <Cale> No problem :)
11:40:22 <Cale> @where yaht
11:40:22 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
11:40:31 <efdetonator> thanks :D
11:40:34 <Cale> hmm, okay, at least that's pointing at the right URL :)
11:43:17 <adiM> @pl  bestAt horizon list = best $ map cost list
11:43:17 <lambdabot> bestAt = const (best . map cost)
11:43:41 <adiM> @pl  bestAt list = best $ map cost list
11:43:42 <lambdabot> bestAt = best . map cost
11:45:09 <adiM> @pl  allBest horizon list = map (\x -> bestAt  x list) [1..horizon]
11:45:09 <lambdabot> allBest = flip (map . flip bestAt) . enumFromTo 1
11:45:33 <adiM> @type flip
11:45:33 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
11:46:06 <chessguy> @src Monad
11:46:06 <lambdabot> class  Monad m  where
11:46:06 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
11:46:06 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
11:46:06 <lambdabot>     return      :: a -> m a
11:46:06 <lambdabot>     fail        :: String -> m a
11:46:10 <zgold> is there an easy way to get rid of the last character in a string (aside from reverse tail reverse s)
11:46:17 <byorgey> adiM: flip f x y = f y x
11:46:31 <byorgey> @. djinn type flip
11:46:34 <lambdabot> f a b c = a c b
11:46:40 <byorgey> =D
11:46:55 <adiM> thanks byorgey
11:47:02 <byorgey> > init "hello"  -- zgold
11:47:03 <lambdabot>  "hell"
11:47:11 <byorgey> adiM: sure =)
11:47:23 <zgold> byorgey: thanks :) Knew it has to be in the prelude somewhere
11:47:45 <byorgey> zgold: yup.  and note of course that 'init' works on any list, not just Strings.
11:47:51 <byorgey> > init [1,2,3,4]
11:47:53 <lambdabot>  [1,2,3]
11:48:00 <newsham> zgold: when you're not that familiar with the std lib yet, hoogle is very useful.  you give it a type signature and it tells you which functions match
11:48:10 <zgold> newsham: No sh** ?
11:48:12 <zgold> thats nuts
11:48:17 <byorgey> @hoogle [a] -> [a]
11:48:18 <lambdabot> Prelude.tail :: [a] -> [a]
11:48:18 <lambdabot> Prelude.init :: [a] -> [a]
11:48:18 <lambdabot> Prelude.reverse :: [a] -> [a]
11:48:27 <Baughn> @src init
11:48:28 <lambdabot> init [x]    = []
11:48:28 <lambdabot> init (x:xs) = x : init xs
11:48:28 <lambdabot> init []     = undefined
11:48:28 <newsham> also available on the interwebs
11:48:40 <zgold> is there an initN as well?  ... lemme try
11:48:45 <zgold> @hoogle [a] -> Int -> [a]
11:48:46 <lambdabot> Prelude.take :: Int -> [a] -> [a]
11:48:46 <lambdabot> Prelude.drop :: Int -> [a] -> [a]
11:48:46 <lambdabot> Data.List.take :: Int -> [a] -> [a]
11:48:49 <Headache> How do I declare a variable for filter? filter (>2) xs has an implicit variable -- I'm a noob
11:48:54 <zgold> take will work :)
11:49:02 <TomMD> > take 3 [1..10]
11:49:02 <lambdabot>  [1,2,3]
11:49:17 <Baughn> Headache: What do you mean? Like filter (\x -> x>2) xs?
11:50:07 <AndreWe> @type (>2)
11:50:08 <lambdabot> forall a. (Ord a, Num a) => a -> Bool
11:50:17 <macondo> > init "batman"
11:50:18 <lambdabot>  "batma"
11:50:55 <newsham> > inits "batman"
11:50:57 <lambdabot>  ["","b","ba","bat","batm","batma","batman"]
11:50:58 <Headache> Let me try that
11:51:09 <macondo> @src inits
11:51:09 <lambdabot> inits []     =  [[]]
11:51:09 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
11:51:23 <zgold> LB is really useful, wow.
11:51:34 <newsham> you can also /msg lambdabot
11:51:37 <macondo> wow I love recursivity
11:51:51 <Baughn> Headache: To begin with, I never feel happy claiming that Haskell has variables at all. (>2) certainly doesn't involve any implicit ones - it's just currying, passing /one/ parameter to a function that takes two and getting back a function that (naturally) takes one.
11:52:36 <TomMD> > let greaterThanTwo x = x > 2 in filter greaterThanTwo [1,2,3,6,1] -- Headache, this is the same as (filter (>2) [1,2,3,6,1]), just that the function is named.
11:52:37 <lambdabot>  [3,6]
11:53:03 <newsham> ?check \n -> flip (<) 2 n == (<2) n
11:53:09 <lambdabot>  OK, passed 500 tests.
11:53:15 <conal> as an intermediate, let greaterThanTwo = (> 2) in ...
11:54:19 <Baughn> > let isPrime = (>2) in filter isPrime [1..7]
11:54:20 <lambdabot>  [3,4,5,6,7]
11:55:08 <chessguy> @pl \n -> flip (<) 2 n
11:55:08 <lambdabot> (< 2)
11:57:53 <macondo> Baughn: what do you mean isPrime = (>2) ?!
11:58:16 <chessguy> macondo, you mean you haven't heard the new math news?
11:58:30 <chessguy> turns out, all numbers greater than two are prime! who knew?!
11:58:55 <macondo> ah right, that's obvious
11:58:57 <chessguy> some MIT guy just discovered the proof
11:58:59 <newsham> its due to inflation.
11:59:34 <newsham> soon some irrational numbers may be considered prime, too.
12:00:00 <newsham> especially those originating outside of the US
12:00:08 <macondo> > filter a [1..10] where a = (>4)
12:00:08 <lambdabot>  Parse error at "where" (column 18)
12:00:13 <chessguy> isn't that redundant?
12:00:16 <Deewiant> > let isPrime = const True in filter isPrime [1..]
12:00:17 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
12:00:29 * macondo hides under a rock
12:00:34 <Baughn> macondo: I think I was making a point, regarding names. Of some sort. Maybe.
12:00:57 <chessguy> Baughn, you certainly triggered plenty of silliness :)
12:02:30 <Headache> That worked, thanks a bunch. And yes you're correct haskell doesnt have variables. ;o)
12:03:00 <Headache> Could you explain to me why that works, whats going on with the \x
12:03:07 <Baughn> Headache: It has IO/ST references, which are more or less the same thing
12:03:47 * chessguy had a feeling that someone was going to drag that out
12:03:51 <Baughn> Headache: And \x creates an anonymous function. "foo x y = x + y" is (almost, but for some type inference silliness) equivalent to "foo = \x y -> x + y"
12:03:52 <newsham> > let pi = 1/42; r = 66 in 2*pi*r
12:03:53 <lambdabot>  3.142857142857143
12:04:16 <aeonproxy> > atan 1 * 4
12:04:17 <lambdabot>  3.141592653589793
12:04:17 <Baughn> Headache: Either of which could be more reasonably rewritten to "foo = (+)"
12:04:23 <chessguy> @type let foo x y = x + y
12:04:25 <lambdabot> <no location info>: not an expression: `let foo x y = x + y'
12:04:31 <chessguy> @type let foo x y = x + y in foo
12:04:32 <lambdabot> forall a. (Num a) => a -> a -> a
12:04:36 <SamB> hmm, elisp mode needs work :-(
12:04:41 <chessguy> @type \x y -> x + y
12:04:43 <lambdabot> forall a. (Num a) => a -> a -> a
12:04:49 <SamB> too bad there's no hope of a SELIME
12:05:08 <Baughn> chessguy: Monomorphism restriction. It's not readily visible.
12:05:20 <chessguy> SamB, i've never really needed elisp (yet)
12:05:28 <chessguy> or at least, i've never admitted needing it
12:06:34 <Headache> Well, I'm working on a programming languages assignment, the goal is to filter lists with lengths larger than two. Is there a way to accomplish this without anonymous functions? Here's what I got that works: longlists xxs = filter (\x -> length x > 2) xxs
12:06:52 <Baughn> Headache: Yes. ;)
12:07:24 <Baughn> Headache: There's /always/ a way to write pointsfree code - though sometimes it's awful. Given that you've already solved the /assignment/..
12:07:25 <Headache> Could you point me in some direction without being too obvious =)
12:07:27 <chessguy> Headache, the question is, why do you want to do it without anonymous functions?
12:07:37 <Baughn> Headache: Just feed it to @pl
12:07:40 <TomMD> > filter (\x -> length x > 2) (inits [1..5])
12:07:40 <lambdabot>  [[1,2,3],[1,2,3,4],[1,2,3,4,5]]
12:07:42 <newsham> headache: you can also define an auxilliary function that tests if a list length is greather than two
12:07:44 <Baughn> @pl foo x y = x+y
12:07:44 <lambdabot> foo = (+)
12:07:49 <newsham> you dont have to do it all in one line using a lambda
12:07:54 <chessguy> Baughn, that would be quite obvious
12:08:13 <Baughn> True. Since he doesn't /want/ a simple answer, I guess..
12:08:17 <newsham> err blah thats what you asked for
12:08:18 <chessguy> Headache, so you want to convert \x -> length x > 2 to pointfree?
12:08:18 <newsham> heh
12:08:25 <newsham> too much scroll
12:08:35 <newsham> headache: do you know how to define new functions?
12:08:49 <Baughn> Headache: The simple solution to this involves using the . operator - do you know how that works?
12:09:00 <chessguy> Headache, generally, the best technique for that is to get the parameter to the function all the way to the right of the right-hand-side
12:09:18 <chessguy> so change it to be \x -> ... x
12:09:44 <dolio> \l -> not (null (drop 2 l)) is advisable.
12:09:59 <Baughn> > drop 2 []
12:10:00 <lambdabot>  []
12:10:02 <dolio> (And perhaps easier to see the point-free version.)
12:10:36 <macondo> @src drop
12:10:36 <lambdabot> drop n xs     | n <= 0 =  xs
12:10:36 <lambdabot> drop _ []              =  []
12:10:36 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
12:10:39 <Baughn> > ((>2) . length) "Howdy"
12:10:40 <lambdabot>  True
12:10:48 <macondo> reading sources is very didactic
12:10:49 <newsham> everyone's doing his homework :)
12:10:54 <chessguy> Baughn, so much for not being obvious
12:10:57 <Cale> > filter (not . null . drop 2) (inits [1..5])
12:10:58 <lambdabot>  [[1,2,3],[1,2,3,4],[1,2,3,4,5]]
12:11:10 * chessguy sighs
12:11:13 <chessguy> too many cooks
12:11:15 <Baughn> chessguy: I think that went out the window a while ago
12:11:31 <chessguy> Baughn, not really
12:11:31 <int-e> > ((>2) . length) [0..]
12:11:35 <lambdabot> Terminated
12:11:43 <Baughn> newsham: Well, not according to his statement of the assignment
12:11:47 <newsham> I think the problem with people asking homework questions in this channel is that the people in this channel dont have enough homework questions of their own to do
12:11:50 <Cale> chessguy: Which is why the ideal programming language would only have one user.
12:12:00 <Headache> The reason I want to change it is because we are lightly touching multiple languages and that hasnt been taught, but neither has the dot operator or the drop command
12:12:15 <int-e> > (not . null . drop 1) [0..]
12:12:17 <lambdabot>  True
12:12:18 <Cale> Headache: The dot operator is just function composition
12:12:26 <Baughn> Headache: drop's a function. Haskell doesn't have commands - ghci may, but not haskell.
12:12:28 <Cale> Headache: (which you may remember from mathematics classes)
12:12:30 <newsham> ?src (.)
12:12:31 <lambdabot> (f . g) x = f (g x)
12:12:46 <newsham> > ((+1).length) "test"
12:12:47 <lambdabot>  5
12:12:58 <newsham> > (+1) (length "test")
12:12:59 <lambdabot>  5
12:13:13 <Cale> drop is a function which takes an integer and a list, and removes that many items from the start of the list
12:13:25 <Cale> (and gives an empty list if it runs out of items to remove)
12:13:36 <newsham> headache: why not just define a named command that is the predicate you want to use for your filter?
12:13:38 <Cale> > drop 3 [1..10]
12:13:39 <lambdabot>  [4,5,6,7,8,9,10]
12:13:45 <newsham> s/command/function/
12:13:48 <Heffalump> Cale: do you know how to build lambdabot?
12:13:49 <Cale> newsham: hehe :)
12:14:00 <Cale> Heffalump: Uh, roughly, yeah, I've done it before.
12:14:06 <chessguy> @remember newsham I think the problem with people asking homework questions in this channel is that the people in this channel dont have enough homework questions of their own to do
12:14:07 <lambdabot> Done.
12:14:09 <Headache> Alright, thanks a lot fellas. I might come back later if I get stuck on something else.
12:14:15 <Cale> Heffalump: I have it set up on code.haskell.org
12:14:15 <newsham> heffalump: it comes with a build script with all the commands in it
12:14:21 <Baughn> Heffalump: "./build" doesn't work?
12:14:26 <Heffalump> Baughn: no
12:14:39 <Baughn> Heffalump: That happens a lot. How /specifically/ does it fail to work this time?
12:14:54 <Heffalump> I'm just about to tell you :-)
12:15:08 <chessguy> "he's going to tell, he's going to tell'
12:15:15 <Heffalump> Setup.hs: can't find source for FTbase in ["scripts/FT"]
12:15:16 <lament> oh no the suspense is killing me!!!
12:15:18 <chessguy> "uh....could somebody give me a push"
12:15:23 <arussel> I'm trying to build yi (with no haskell experience), I cd into yi and did: runhaskell Setup.hs configure
12:15:36 <arussel> the answer was: Setup.hs:4:28: Not in scope: `simpleUserHooks'
12:15:40 <Cale> Heffalump: mm... that might be related to sjanssen's recent patches
12:15:53 <newsham> arussel: you may need a different version of cabal?
12:15:55 <Cale> Heffalump: He separated out some of the external programs.
12:15:57 <arussel> refering to this line: main = defaultMainWithHooks simpleUserHooks
12:16:13 * Heffalump unpulls, then
12:16:25 <Heffalump> I'm making more progress now.
12:16:27 <Heffalump> thanks
12:16:32 <Baughn> arussel: IIRC, simpleUserHooks was added recently. You may need to upgrade cabal.
12:16:34 <chessguy> what, no monte python love in here?
12:16:38 <Cale> yeah, I'm getting that too
12:16:55 <Heffalump> I just unpulled his last patch and it's compiling now
12:17:05 <Cale> (I've added sjanssen and Baughn's patches just now)
12:17:08 <arussel> Baughn, newsham: any chance to get it from debian package or I have to get it from source ?
12:17:14 <Cale> sjanssen: are you around?
12:17:16 <Cale> @seen sjanssen
12:17:16 <lambdabot> sjanssen is in #xmonad, #haskell-soc and #haskell. I last heard sjanssen speak 2m ago.
12:17:18 * Baughn is having all sorts of fun trying to install lambdabot in ..
12:17:26 <newsham> arussel: dont know re: debian
12:18:09 <arussel> my version is: Version: 98.200609.21-5
12:18:31 <arussel> well, it doesn't seems very new :-(
12:18:34 <newsham> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Cabal-1.2.3.0
12:18:38 <lambdabot> http://tinyurl.com/2eey3b
12:18:43 <arussel> newsham: thanks
12:18:45 <newsham> which ghc version are you using?
12:18:56 <newsham> (other packages can be found on hackage.haskell.org, btw)
12:19:04 <arussel> The Glorious Glasgow Haskell Compilation System, version 6.6.1
12:19:12 <Cale> sjanssen: Did you update the .cabal file when you separated out FT/Hoogle/etc.?
12:19:22 <newsham> there's a 6.8.* version out now.  6.6.1 isnt that old though
12:19:34 <Cale> d'oh
12:19:51 <Cale> Now running lambdabot is giving me an infinite loop initialising plugins...
12:19:59 <Cale> 6.6.1 is pretty old
12:20:19 <Cale> A lot of stuff on hackage doesn't work with 6.6.1
12:20:41 <Heffalump> why is it trying to install stuff into /usr/local ? The build script seems to be telling it to use `pwd`
12:21:02 <Cale> Unfortunately, Ubuntu doesn't seem to care to update their ghc package.
12:21:46 <Baughn> Cale: Ubuntu is due for a new release in, oh, five days or so. We can hope that does it.
12:21:58 <Baughn> Heffalump: The build script is outdated
12:22:02 <Cale> Baughn: hehe, and then 6.10 will come out :)
12:22:08 <Baughn> Heffalump: Or.. too new? I'm not sure
12:22:35 <Baughn> Heffalump: Anyway, you need all of --libdir, --bindir and --prefix for the configure command
12:23:36 <Heffalump> Baughn: ok, ta
12:24:43 <newsham> ?bot
12:25:16 <Cale> I took lambdabot down to restart it with Baughn and sjanssen's new patches and it's not restarting properly
12:25:34 <chessguy> Cale, see what you get for trying to be helpful?
12:25:41 <Cale> hehe
12:25:43 * Baughn only touched an external executable. honest.
12:25:54 <newsham> cale: ahh, you're running the bot?  you might be interested in http://www.thenewsh.com/%7Enewsham/x/Ticker.hs
12:26:25 <newsham> (i'm running quite an old version of lb, so if the module interface has changed it may need tweaks)
12:26:45 <Cale> Yeah, something tells me it's sjanssen's fault for not updating the .cabal file with the appropriate new dependencies.
12:26:59 <sjanssen> sjanssen: I believe so
12:27:11 <sjanssen> what is going wrong?
12:27:17 <Heffalump> Cale: he's obviously disturbed, he's talking to himself now.
12:27:23 <Cale> cgibbard@haskell:~/darcs/lambdabot$ ./lambdabot
12:27:23 <Cale> Initialising plugins ...........exception:
12:27:23 <Cale> Prelude.init: empty list
12:27:24 <sjanssen> ha
12:27:29 <sjanssen> whoa
12:27:36 <Baughn> Cale: I don't even get that. It quits, with zero output
12:27:38 <newsham> I thikn I see the source of the infinite loop: "[09:25] < sjanssen> sjanssen: I believe so"
12:27:54 <Cale> Actually, the infinite loop was from my shell script.
12:28:05 <Cale> (it restarts lambdabot when it dies, I forgot about that)
12:28:17 <Baughn> "When"? -_-
12:29:16 <zgold> Baughn: your going to laugh at me
12:29:25 <Cale> sjanssen: what were the extra dependencies in hackage that I was going to need?
12:29:42 <zgold> After our conversation about making a string serializable I went ahead and skipped all of that, and just used "newtype S = S String, instance serializable S where ..."
12:30:10 <zgold> then i wrote some code to make more complicated things serializable... and then went back and made that code generic... then realized i could use that framework to make string serializable
12:30:10 <Baughn> zgold: No, that sort of thing will just make me wince.
12:30:23 <zgold> and now it all works (the right way)
12:30:25 <Baughn> ..okay, that made me laugh
12:30:41 <zgold> :)
12:30:49 <chessguy> newsham, that seems a nice little module
12:30:55 <sjanssen> Cale: djinn, hoogle, ftshell
12:31:04 <sjanssen> Cale: but they shouldn't cause lambdabot to crash like that
12:31:09 <newsham> chess: I use it more than any other commands :)
12:31:20 <chessguy> newsham, would be a good one to turn into a little tutorial on how to write an LB module
12:31:27 <zgold> thanks for all your help!  I'm haskelled out for the moment
12:31:33 <newsham> chess: make it so!
12:31:53 <chessguy> newsham, i don't know the first thing about writing lambdabot modules!
12:31:54 <newsham> also my "csv" is a little wonky (and hackage has a CSV package), perhaps someone could make it nicer
12:32:02 <Heffalump> State/L.hs:4:0:  error: imports.h: No such file or directory
12:32:06 <newsham> chessguy: who better suited to write a tutorial on one, then.
12:32:14 <chessguy> bleah
12:32:31 <sjanssen> Cale: I forgot to remove something from the .cabal file, will push that patch in a moment
12:32:32 <chessguy> newsham, you, that's who better :)
12:32:49 <Baughn> Heffalump: Add -I. to the appropriate build line
12:33:01 <newsham> chess: if someone who doesnt know anything about writing a lambdabot module writes one, then surely anyone can.
12:33:02 <chessguy> newsham, i would be the perfect person to _review_ the tutorial, not to write it :)
12:33:26 <Baughn> sjanssen: I've traced my crash to the patch that replaces ./djinn with djinn
12:33:40 <Heffalump> Baughn: thanks, seems to have built now.
12:33:47 <Baughn> sjanssen: ..any idea how that is happening?
12:36:01 <Cale> Building free-theorems-0.2...
12:36:01 <Cale> src/Language/Haskell/FreeTheorems/Parser/Hsx.hs:16:7:
12:36:01 <Cale>     Could not find module `Language.Haskell.Hsx.Syntax':
12:36:12 <Heffalump> Baughn: seems to run too once I copied imports.h into the bin directory manually, thanks (I guess if I'd left that as `pwd` it would have worked fine straight away)
12:36:46 <Baughn> Cale: Aha. Figured it out - the Djinn plugin uses doesFileExist to decide whether or not using djinn should work, which (spuriously) succeeds when djinn is missing from the path but still exists in your install directory
12:36:58 <Cale> ah
12:37:04 <Baughn> If you remove it it'll work. Granted, "it'll work" in the sense that djinn /won't/ work, ever
12:37:05 <Cale> This was a bad time to have software issues...
12:37:21 <Baughn> You should just unpull that patch - it's incomplete on its own
12:37:29 <Cale> djinn is in a separate package
12:37:42 <Cale> Which I've already installed
12:37:54 <Cale> But the dependencies need to be updated
12:38:11 <Baughn> Part of the djinn plugin assumes that djinn is installed in the same directory as lb, part of it doesn't (now).
12:38:25 <Cale> mm
12:38:38 <Cale> I need to get into the shower and take off for a bit soon.
12:38:48 <Cale> until then...
12:38:59 <mar77a> take pics
12:39:34 <Cale> Have mbot. It doesn't have all the modules, but it has the important ones :)
12:39:46 <newsham> mbot is better than nobot
12:39:59 <Cale> Plus it can evaluate mathematica expressions.
12:40:05 <Baughn> > 42
12:40:09 <mbot>  42
12:40:24 <Cale> % Integrate[Cos[x]^2, {x,0,1}]
12:40:27 <mbot> Cale: (2 + Sin[2])/4
12:40:49 <Baughn> Cale: Doesn't that violate the mathematica license or something?
12:41:02 <dons> ssh.
12:41:08 <dons> math wants to be free!
12:41:10 <ski> zgold : sorry .. wandered into the maze of WP for awhile
12:41:14 <newsham> software licensing.  hah.
12:41:15 <Cale> probably. It does less than the free demos of mathematica though.
12:41:31 <aeonproxy> successor of lambdabot?
12:41:31 <Cale> I consider it good advertising for Wolfram :)
12:41:33 <newsham> mathematica advertising wants to be free
12:41:35 <ski> zgold : afaiu `default S' or maybe `default (S)' as a top-level declaration
12:41:55 <Cale> aeonproxy: It's my lambdabot.
12:42:31 <newsham> sounds like a hanson song
12:42:51 <newsham> http://www.youtube.com/watch?v=Xk8Yo4pzhWs
12:43:13 <xerox> Cale: is the mathematica plugin up-to-date with current darcs get lambdabot?
12:43:34 <Baughn> xerox: Can't be. That doesn't build, which is why it's here. ;)
12:45:03 <aeonproxy> Cale: what differences are between both?
12:57:27 <audreyt> what's the name of function f such that (f [] [] = []), (f "nonempty" [] = "nonempty"), (f "nonempty" "another" = "nonempty"), (f [] "another" = "another")?
12:58:18 <audreyt> i.e., if there's a well known name for that
12:59:08 <allbery_b> mplus in the list monad?
12:59:20 <Heffalump> that would take a product in case 3
12:59:21 <jrx> \x y -> if (null x) y x
12:59:25 <jrx> mplus does (++)
12:59:36 <Heffalump> oh, sorry, yes, but it's still wrong for case 3
12:59:53 <audreyt> @pl \x y -> if (null x) y x
12:59:53 <mbot> (line 1, column 24):
12:59:53 <mbot> unexpected end of input
12:59:53 <mbot> expecting variable, "(", operator or "then"
12:59:54 <allbery_b> hm, right, wrong monad model :/
13:00:01 <audreyt> @pl \x y -> if (null x) then y else x
13:00:01 <mbot> flip =<< if' . null
13:00:05 <Heffalump> if you get into Maybe easily that'd do it
13:00:18 <audreyt> I was hoping there's a name for it other than (flip =<< if' . null) :)
13:00:24 <jrx> sorry, should be f'
13:00:28 <ski> wouldn't this be `melse' in `instance MonadElse []' ?
13:00:29 <jrx> if'
13:00:30 <Heffalump> I doubt there's a name for it.
13:00:40 <dons> is it a `guard` of some kind?
13:00:48 <tromp> it's too unnatural to deserve a name:)
13:01:08 <allbery_b> er?  it's just the list version of catMaybes
13:01:11 <allbery_b> sort of
13:01:20 <audreyt> ski: why, yes, that's it. thanks.
13:01:32 <chessguy> @type \n -> take n (drop n (show pi))
13:01:35 <mbot> Int -> [Char]
13:01:51 <chessguy> @pl \n -> take n (drop n (show pi))
13:01:51 <mbot> ap take (flip drop (show pi))
13:02:09 <ski> audreyt : http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
13:02:22 <chessguy> @pl \n -> map read $ take n (drop n (show pi))
13:02:23 <mbot> map read . ap take (flip drop (show pi))
13:02:35 <chessguy> @type \n -> map read $ take n (drop n (show pi))
13:02:39 <mbot>     Couldn't match expected type `String' against inferred type `Char'
13:02:39 <mbot>       Expected type: [String]
13:02:39 <mbot>       Inferred type: [Char]
13:03:14 <dons> Cale, so lambdabot's a bit crook?
13:03:23 <chessguy> @hoogle Char -> Int
13:03:24 <mbot> Data.Char.digitToInt :: Char -> Int
13:03:24 <mbot> Data.Char.ord :: Char -> Int
13:03:24 <mbot> Data.ByteString.Char8.count :: Char -> ByteString -> Int
13:03:29 <chessguy> @type \n -> map digitToInt $ take n (drop n (show pi))
13:03:32 <mbot> Int -> [Int]
13:03:36 <audreyt> ski: *nod* though morelse is a horrible name... I tend to parse it as "MoreLSE"
13:03:54 <audreyt> on the other hand, "motherwise" isn't much better, either ;)
13:04:27 <ski> audreyt : i'd prefer s/MonadOr/MonadElse/ s/morelse/melse/ .. though maybe someone has an even better suggestion
13:04:43 <int-e> ... malternatively ...
13:04:51 <audreyt> ski: me too.
13:04:51 <ski> `malt' ?
13:05:17 <Cale> dons: yeah, I'll sort it out when I get back
13:05:19 <ski> (possibly s/MonadPlus/MonadOr/ too ..)
13:05:59 <audreyt> x `mV` y `mV` z
13:06:11 <ski>   mcond :: MonadElse m => m a -> (a -> m b) -> m b -> m b  -- this could maybe be handy as well, sometimes
13:07:39 <Heffalump> I'm sure you can come up with a combinator with suffix "onad" if you keep this up.
13:09:02 <Headache> What kind of function do I need to define to get foldl to work, as in what parameters is it suppose to take
13:09:36 <int-e> @type foldl
13:09:39 <mbot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:09:54 <int-e> Headache: if the type doesn't help you, please ask a more specific question
13:11:23 <newsham> foldl f x0 ys   is an abstraction of the pattern:   accum = x0; for(y in ys) accum = f(accum, y); return accum
13:11:52 <ski> > let zero = "0"; str `plus` num = concat ["(",str," + ",show num,")"] in foldl plus zero [3,4,5,6]
13:11:54 <mbot>  "((((0 + 3) + 4) + 5) + 6)"
13:12:18 <newsham> > foldl f 0 [3,4,5]
13:12:19 <mbot>  Add a type signature
13:12:35 <macondo> hey what happened to lambdabot?
13:12:58 <newsham> macondo: failed update under time pressure, maintainer had to leave
13:12:59 <elux> just wondering
13:13:06 <elux> but what sort of applications have people built with haskell?
13:13:10 <Headache> Could you give me an example function that can be passed to foldl?
13:13:13 <elux> im just beginning to look at haskell
13:13:18 <int-e> > foldl (\a b -> b : a) [42] [1..5]
13:13:20 <mbot>  [5,4,3,2,1,42]
13:13:34 <newsham> > foldl (\accum n -> accum + n) 0 [3,4,5]
13:13:36 <mbot>  12
13:14:03 <audreyt> elux: http://haskell.org/haskellwiki/Applications_and_libraries
13:14:30 <newsham> elux: some well known programs are a text editor, an X window manager, and a source revision control system
13:14:56 <newsham> ?bot and an irc bot :)
13:14:56 <mbot> :)
13:14:57 <int-e> > foldl (-) a [b, c]
13:14:59 <mbot>  a - b - c
13:15:25 <newsham> > foldl f 0 [3,4,5] :: Int
13:15:26 <mbot>        add an instance declaration for (SimpleReflect.FromExpr Int)
13:15:34 <newsham> why doenst that work?
13:15:37 <ski> > foldl (\number digit -> 10*number + digit) 0 [3,4,5]
13:15:39 <mbot>  345
13:16:01 <int-e> > foldl f a [3,4,5]
13:16:04 <mbot>  f (f (f a 3) 4) 5
13:16:06 <int-e> @type a
13:16:09 <mbot> Expr
13:16:12 <newsham> ahh
13:16:12 <ski> > foldl f 0 [3,4,5] :: Expr
13:16:14 <mbot>  f (f (f 0 3) 4) 5
13:16:18 <newsham> ty
13:16:32 <dons> elux: also poke around hackage.haskell.org , which gives you a hint at the general areas people are using haskell for
13:16:41 <Headache> ski... you just did my homework problem for me....
13:16:47 <Headache> Could you explain that to me?
13:16:53 <dons> there's a nice perl6 compiler too
13:16:55 <ski> which ?
13:16:58 <Headache> foldl (\number digit -> 10*number + digit) 0 [3,4,5]
13:17:01 <newsham> headache: you can derive it directly from the src
13:17:04 <newsham> ?src foldl
13:17:04 <mbot> foldl f z []     = z
13:17:04 <mbot> foldl f z (x:xs) = foldl f (f z x) xs
13:17:21 <allbery_b> http://foldl.com and http://foldr.com :)
13:17:32 <Botje> @remember Headache you just did my homework problem for me.... / Could you explain that to me?
13:17:33 <mbot> Done.
13:17:34 <ski> Headache : try and hand-evaluate that example with paper and pencil (or text-editor, if you prefer)
13:17:40 <newsham> foldl f 0 (3:4:5:[0]) = foldl f (f 0 3) (4:5:[])
13:17:45 <newsham> err,  s/[0]/[]/
13:18:10 <newsham> headache: start with the src for foldl, and your expr, and just keep manually substituting
13:18:37 <ski> it might help if you define
13:18:39 <Headache> could you define the function without the anonymous function?
13:18:50 <ski>   addDigit number digit = 10*number + digit
13:18:57 <ski> and then start evaluating
13:19:10 <ski>   foldl addDigit 0 (3:4:5:[])
13:19:28 <newsham> headache: if you're an imperative programer, you might want to thikn of it in terms of a loop with an accumulator, first.
13:19:39 <elux> thanks guys
13:19:51 <newsham> ie:   accum = 0; for(n in [3,4,5]) accum = accum * 10 + n; return accum
13:19:59 * ski starts to wonder whether there's telepathy involved .. :)
13:20:01 <newsham> foldl is just an abstraction of that pattern
13:20:52 <jrx> could you take a look at: http://hpaste.org/7061
13:21:11 <jrx> I wonder if I can write a generic unpacker with Data.Generics
13:21:32 <jrx> something different than: \(Some s) -> s
13:21:44 <jrx> because patterns are not first-class
13:22:59 <Headache> Alright, I see how it works now. I just didnt have a good example to work off. Thanks again. One more question to go.
13:23:23 <newsham> > foldl (\number digit -> 10*number + digit) a [1]
13:23:25 <mbot>  10 * a + 1
13:23:28 <newsham> > foldl (\number digit -> 10*number + digit) a [1,2]
13:23:30 <mbot>  10 * (10 * a + 1) + 2
13:23:33 <newsham> > foldl (\number digit -> 10*number + digit) a [1,2,3]
13:23:35 <mbot>  10 * (10 * (10 * a + 1) + 2) + 3
13:23:57 <newsham> > foldl (\number digit -> 10*number + digit) a []
13:23:59 <mbot>  a
13:24:14 <newsham> smart bot
13:24:42 <int-e> @botsnack
13:24:42 <mbot> :)
13:25:13 <matthew_-> Corun: what are you doing here?! You should be revising for exams!
13:25:15 <ski> > let zero = var "0" in foldl (\number digit -> 10*number + digit) zero [8,1,2,8]
13:25:17 <mbot>  8+10*(2+10*(1+10*(8+10*0)))
13:25:33 <newsham> > foldl (\number digit -> 10*number + digit) (var "0") [1,2,3]
13:25:35 <mbot>  3+10*(2+10*(1+10*0))
13:25:38 <newsham> awesome
13:27:17 <byorgey> what happened to \bot?
13:27:44 <Botje> 21:19 -!- lambdabot [n=lambdabo@72.249.126.23] has quit [Remote closed the
13:27:48 <Botje> connection]
13:28:08 * byorgey weeps
13:28:25 <Botje> perhaps we should have a hot spare for \bot
13:28:33 <byorgey> hehe
13:28:38 <byorgey> well, apparently we do =)
13:28:56 <byorgey> oh, you mean, another bot that sits around in the channel but only responds if lambdabot doesn't?
13:29:09 <newsham> cale's updating the bot and had to leave.
13:29:15 <byorgey> ah.
13:29:32 * SamB thinks this whole bussiness of XML requiring a system identifier for every DTD was a BAD idea..
13:29:44 <Botje> make some up!
13:30:14 <Botje> XML is just static typing applied to markup :)
13:30:40 <Headache> Alright I'm done, thanks for the help, saved me much time.
13:32:10 <int-e> jrx: I don't think this can work. You could pass a partially applied binary constructor to unpackConstr - what is it supposed to do then?
13:32:49 <jrx> int-e: it can return e.g. Nothing, or report error somehow
13:33:05 <Saul_> I have a small question on the function Control.Concurrent.threadDelay
13:33:07 <int-e> jrx: or even worse, you could pass const Nothing and variations on that theme
13:33:22 <Saul_> Does this block the actual OS thread or also IO threads?
13:33:40 <newsham> ski doing your homework always saves time
13:33:48 <jrx> int-e: I'm just interested in values for correct data, as I can filter them with isConstr
13:33:50 <dons> Saul_: just the current thread
13:33:52 <allbery_b> it should only block the haskell thread, which may not be an OS thread
13:34:21 <jrx> int-e: unpackConstr can return for example Maybe a and work only for unary constructors
13:34:30 <jrx> int-e: that would be pretty enough for me
13:36:30 <Saul_> dons: Then I don't understand my code at http://hpaste.org/7070
13:37:11 <Saul_> As far as I understand, two requests right after eachother should return right after eachother as well
13:37:16 <dons> Saul_: the accept is probably a blockign foreign call. do you use the -threaded runtime?
13:37:21 <Saul_> with a 5 second delay
13:37:34 <dons> ghc -O -threaded Foo.hs
13:37:39 <Saul_> no I don't, I'll try it
13:37:51 <dons> then IO will run in its own thread, which is important if you don't want blocking C calls to block all threads
13:39:17 <Saul_> dons: that didn't help :(
13:40:30 <yuriyp> @hoogle instersection
13:40:31 <mbot> No matches found
13:40:35 <yuriyp> @hoogle intersection
13:40:36 <mbot> Data.Set.intersection :: Ord a => Set a -> Set a -> Set a
13:40:36 <mbot> Data.Map.intersection :: Ord k => Map k a -> Map k b -> Map k a
13:40:36 <mbot> Data.IntSet.intersection :: IntSet -> IntSet -> IntSet
13:40:48 <yuriyp> @src Data.Set.intersection
13:40:48 <mbot> Source not found.
13:41:52 <int-e> jrx ok. data Foo a = Foo { unFoo :: a }; unsafeUnpackConstr _ v = unFoo (unsafeCoerce v) might just work often enough to be useful. it'll break hopelessly on unpacked data fields though. You need compiler support to do it properly.
13:42:25 <dons> Saul_: looking..
13:42:57 <dons> Saul_: so what behaviour do you expect?
13:43:02 <int-e> jrx: and by hopelessly I mean segfaults: data Bar = Bar {-# UNPACK #-} !Int; *Main> unsafeUnpackConstr Bar (Bar 1) --> Segmentation fault (core dumped)
13:43:14 <Saul_> I want to make a multithreaded http server
13:43:24 <dons> its just accepting things endlessly, forking a thread, which waits, then closes the handle
13:43:27 <dons> ok.
13:43:28 <Saul_> so it should handle requests in parallel
13:44:04 <dons> that code looks reasonable
13:45:46 <dons> and bla seems to wait properly
13:45:53 <jrx> int-e: ok, I'll try
13:47:06 <dons> Saul_: so you will definitely want the threaded runtime no matter what
13:47:14 <dons> so you can run your threads on multiple cores.
13:47:22 <jrx> int-e: I only mind for correct data types, but the problem is rather in writing unFoo, because it works only for one type
13:47:27 <dons> Saul_: do you have an easy way to test the accept program?
13:47:28 <jrx> int-e: Foo
13:47:47 <Saul_> I use a browser at the moment
13:47:50 <jrx> int-e: it would be good if I can parametrize it somehow
13:48:01 <dons> Saul_: oh, just connect on port 2000 ?
13:48:09 <Saul_> yup
13:49:30 <dons> you might want to look at the inner loops in the haskell web server, HWS
13:49:39 <dons> there's a paper about how it was implemented (and made scalable)
13:50:04 <int-e> jrx: really I'd look for a different approach to the problem. Maybe a type class that contains the unpack method with suitable instances. It's tedious, but at least it has a fighting chance to be safe.
13:50:13 <dons> http://citeseer.ist.psu.edu/318767.html
13:50:27 <dmwit> Enum?
13:50:29 <dons> Saul_: anyway, what's happening again?
13:50:33 <dons> Saul_: only one fork is seen?
13:50:39 * dmwit jumps into the middle of a problem without knowing the actual problem
13:51:58 <int-e> jrx: the 'Foo' type is just a proxy, and the code hopes that except for the constructor tag, the single constructor value C a that you're after a Foo a are represented in the same way in memory, and also that ghc takes a shortcut for single constructor datatypes. that's really a lot of assumptions to make.
13:52:06 <Saul_> I think so
13:52:30 <Saul_> If I refresh several tabs at once, they return at five second intervals
13:52:44 <Saul_> instead of all at once after 5 seconds
13:53:46 <jrx> int-e: I already thought about typeclass but I hoped that something similar has been implemented in Data.Generics
13:54:50 <int-e> jrx: not as far as I can see, although I may be missing something.
13:59:41 <dons> Saul_: hmm.
14:00:56 <jrx> int-e: I made a little research, and I find gfindtype pretty sufficient
14:01:07 <jrx> it works good for most cases I think
14:01:15 <jrx> http://hpaste.org/7061#a1
14:04:45 <Saul_> dons: It might be that accept uses unsafe foreign calls
14:05:15 <dons> hmm I'm not sure that explains the sequencing
14:06:49 <Saul_> I also seem to be having errors occassionally
14:07:08 <Saul_> connection was reset or unable to connect
14:07:45 <int-e> jrx: nice
14:12:32 <nibro> could anyone tell me what I need to do to get my blocking foreign call to not hang all my other haskell threads?
14:12:43 <nibro> -threaded doesn't seem to do what I thought it would :-\
14:12:54 <dons> hmm. talk to Saul_ :)
14:13:15 <dons> -threaded should be enough, nibro , as long as the blocking call runs in a forkio thread
14:13:31 <nibro> dons: forkIO, not forkOS?
14:13:40 <nibro> I tried both though...
14:13:52 <dons> forkOS is rarely needed -- its for thread-local state in C apps
14:14:37 <dons> "Using GHC without the -threaded option, all foreign calls will block all other Haskell threads in the system, although I/O operations will not. With the -threaded option, only foreign calls with the unsafe attribute will block all other threads."
14:15:09 <dons> nibro: so ensure that the functions are 'safe' (they don't call back in)
14:15:10 <nibro> aha!
14:15:26 <dons> i always forget which one is which -- unsafe usually means 'i know what i'm doing'
14:15:26 <nibro> fair enough, they don't, so that should be easy to fix
14:15:34 <dons> but in this case, 'unsafe' is the 'safe' option. confusing.
14:15:41 <nibro> haha, indeed
14:15:47 <nibro> thanks a lot, that should do it
14:16:19 <dons> i should use 'safe' more often.
14:17:06 <nibro> indeed, I should probably do that too
14:17:21 <nibro> but foreign calls seem inherently 'unsafe' :-)
14:18:17 <dons> hmm,
14:18:18 <dons> "A safe call is less efficient, but guarantees to leave the Haskell system in a state that allows callbacks from the external code. In contrast, an unsafe call, while carrying less overhead, must not trigger a callback into the Haskell system."
14:19:17 <nibro> hmm, alright, that means that as long as you don't callback or block, use unsafe
14:19:34 <dons> which is a bit confusing. 'unsafe' is cheaper, but 'unsafe' will block all threads == more expensive
14:19:57 <wjt> the naming is pretty unfortunate
14:20:02 <nibro> right, which is why it's unsafe :-)
14:20:20 <dons> so safe does some copying, i suppose, which means it can do the non-blocking stuff
14:20:38 <dons> there's no unsafe-unsafe
14:20:48 <dons> which does non-blocking, and cheap/no-callbacks
14:21:25 <dons> I should talk to Simon Marlow about when to use which
14:21:37 <dons> since bytestring uses 'unsafe' calls, but maybe that's problematic with blocking
14:22:33 <andyjgill> Hey dons!
14:23:01 <Saul_> Well I'm going to give up for now and do some sleeping
14:23:15 <Saul_> goodnight
14:24:52 * sjanssen is back
14:25:09 <sjanssen> Cale, Baughn: did you figure out what was going wrong with lambdabot?
14:25:17 <sjanssen> hmm, doesn't seem so
14:25:34 <andyjgill> dons: I was wondering about a ffi debugging aid.
14:25:37 <GrayShade> did anyone play with the views ghc 6.9? i get these warnings http://hpaste.org/7071
14:25:58 <Baughn> sjanssen: Somewhat
14:26:14 <andyjgill> I'm playing with OpenGL, and would like to know what *actual* ffi calls are being made by the Haskell API.
14:26:29 <nibro> that would be very nice to have
14:26:53 <Baughn> sjanssen: At least in my case. The djinn plugin checks whether it's runnable /in advance/ by using doesFileExist. This succeeds with "djinn", since ./djinn exists, but since I haven't installed it in the path it isn't actually /runnable/
14:27:21 <nibro> dons: unsafe => safe solved the problem :)
14:27:21 <dons> andyjgill: i'd like some safe marshalling :)
14:27:22 <Baughn> sjanssen: And there's no error handler for failing to run djinn. LB just quits (with no error, even. Seems a bit odd.)
14:27:28 <dons> nibro: right. good.
14:27:30 <sjanssen> Baughn: ah, for some reason I'm not seeing this error
14:27:44 <dons> dcoutts: i wonder, shouldn't bytestring be using safe calls too?
14:27:59 <dons> andyjgill: some people use dtrace for this , iirc
14:28:03 <dons> i've seen people debugging xmonad this way
14:28:05 <Baughn> sjanssen: You ned the combination of having a djinn executable in the lambdabot directory (rather, pwd when you start it) and /not/ having it in your path
14:28:06 <dons> watching all the calls
14:28:13 <sjanssen> Baughn: but I'm also running locally, not connecting to an IRC server
14:28:15 <Baughn> sjanssen: Also quite possibly lacking one in State/
14:28:15 <sjanssen> Baughn: ah
14:28:31 <sjanssen> Baughn: so you need to have it in your $PATH, this is now required
14:28:39 <sjanssen> I'll look into making lambdabot fail gracefully
14:29:02 <Baughn> sjanssen: You really need to switch out the doesFileExist check for something that looks (only) in the path, then
14:29:05 <andyjgill> Can you wire dtrace to an api layer, or is it only system calls?
14:29:28 <sjanssen> dons: you wrote the popen code, right?  What does it do if the executable can't be found
14:29:40 <nibro> now I only have the problem that I can't seem to killThread the thread that did the foreign blocking call, hmm
14:30:06 <nibro> but maybe that's to be expected, if inconvenient
14:30:46 <dons> sjanssen: popen code in lambdabot? it returns an empty list , iirc
14:30:50 <dons> all exceptions get caught, iirc
14:32:28 <sjanssen> I get ("", "", ExitFailure 127), which is perfectly reasonable
14:32:41 <sjanssen> oops
14:33:14 <sjanssen> dons: I think lambdabot gets SIGPIPE if you try to feed input into a non-existing executable
14:33:19 <sjanssen> I remember this bug from xmonad, now
14:34:11 <dons> ah, could be.
14:34:25 <Baughn> If I strace lambdabot, I get "Prelude.init: empty list"
14:34:30 <sjanssen> so what is the best route to fixing this
14:34:53 <sjanssen> Baughn: and then lambdabot exits?
14:35:02 <Baughn> Yep, but that's before trying to initialize anything
14:35:22 <Baughn> Normally it dies when trying to init djinn. YOu may be right about sigpipe, but this makes it hard to tell
14:35:23 <allbery_b> ignore sigPIPE so it is returned as an I/O error instead of killing LB?
14:37:48 <Baughn> Mm. It gets killed by sigpipe, yep.
14:38:16 <Baughn> To be honest, I don't see any reason the rts doesn't ignore that by default. It would be hard to use it in any way.
14:38:53 <sjanssen> so where is the least hacky place to add 'ignore sigPIPE'
14:38:58 <sjanssen> lambdabot is too big!
14:39:03 <Baughn> Main.hs?
14:41:09 <sjanssen> ignoring sigPIPE adds a dependency on posix
14:41:11 <allbery_b> Main does nothing but invoke the real main, IIRC
14:41:18 <sjanssen> does lambdabot run on Windows?
14:41:31 <Baughn> sjanssen: We already have a dependency on posix in RunPlugs
14:41:39 <allbery_b> which sends you to Lambdabot.hs, which IIRC send you somewhere else for the *real* real main :)
14:41:47 <sjanssen> Baughn: ah, yes
14:41:51 <Baughn> I don't think anyone cares, but if they do it should be reasonably simple for /them/ to add defines
14:42:04 <sjanssen> not the posix lib, but posix itself
14:43:06 <Baughn> An interesting distinction, but it's a dependency that is only needed if you're /running/ on posix
14:43:21 <Baughn> Anyone on windows could just comment it out. Or ifdef it out, I suppose.
14:43:25 <sjanssen> yeah
14:43:56 <Baughn> It's a pity that ghc doesn't have a cross-platform interface to resource limiters
14:44:26 <sjanssen> nevermind, the lib is called unix, and we already depend on it
15:01:06 <sjanssen> Baughn: try the latest patches
15:03:17 <Baughn> sjanssen: Prelude.init: empty list
15:03:27 <Baughn> sjanssen: You may not be handling the case where djinn is not, in fact, installed.
15:05:57 <sjanssen> Baughn: but does lambdabot still crash?
15:06:12 <Baughn> sjanssen: Yes, with that error
15:06:59 <sjanssen> hmm, that really shouldn't cause lambdabot to crash
15:08:21 <sjanssen> Baughn: should be better now
15:09:39 <Baughn> sjanssen: By the way, you should remove the System.Directory import in djinn - that stops the build, right now. (-Werror and all)
15:09:52 <Baughn> Oh, and it works now. Yay!
15:10:11 <Baughn> (But the error message from trying to use djinn isn't very helpful)
15:19:18 <MarcWeber> Which is the update site to be used to get ghc-6.8 on debian?
15:20:06 <solrize_> i don't think there is a package for it
15:20:11 <solrize_> just install from the tarball
15:21:06 <wjt> apart from 6.8 being in unstable
15:21:14 <solrize_> hmm
15:21:48 <allbery_b> don't do it!  that way lies only pain and suffering
15:22:46 <allbery_b> ("debian unstable:  it's always fun when apt-get decides glibc is incompatible with some updated package and offers to remove it")
15:23:17 <BCoppens> allbery_b: actually, it is somewhat safer than gentoo on this matter afaik
15:23:26 <allbery_b> dunno if that happens these days since it seems like a bad bug to not have deps in place to keep glibc around, but it used to happen
15:23:44 <bauglir> haskell
15:23:52 <BCoppens> allbery_b: since a friend of mine had his gentoo let him remove his gcc in order to compile a new one ;)
15:24:01 <bauglir> haskell
15:24:11 <ehird> bauglir: java
15:24:18 <bauglir> ehird
15:24:39 <allbery_b> *eyebrow*
15:24:44 --- mode: ChanServ set +o allbery_b
15:25:00 <ehird> allbery_b: don't ask me
15:25:05 <BCoppens> allbery_b: whereas at that time, to prove the point that debian > gentoo, doing an apt-get remove libc helpfully insisted that I typed over 'yes, do as I say' after outputting a severe warning as to explain why it was bad ;)
15:25:06 <ehird> aha
15:25:09 <ehird> it's wp-gast, allbery_b
15:25:12 <ehird> kick it with fire
15:25:41 --- mode: allbery_b set +b *!*n=WP-Gast@*.dclient.hispeed.ch
15:25:41 --- kick: bauglir was kicked by allbery_b (allbery_b)
15:26:02 <solrize_> ??
15:26:10 --- mode: allbery_b set -o allbery_b
15:26:13 <allbery_b> bot
15:26:20 <allbery_b> I figured so from the behavior
15:26:29 <ehird> allbery_b: WP-Gast, actually.
15:26:32 <ehird> A specific kind of bot.
15:26:37 <ehird> WP = Wikipedia, I assume.
15:26:44 <allbery_b> sure looks like a bot.  I grant that some users may be indistibuishabel though
15:26:48 <ehird> Gast might mean something in german, it seems to troll mainly in #wikipedia-de
15:26:53 <BCoppens> allbery_b: 'You are about to do something potentially harmful To continue type in the phrase Yes, do as I say!' :P
15:26:56 <allbery_b> ah
15:26:57 <ehird> Basically, it does things like repeating the channel name
15:27:00 <ehird> Or nicknames
15:27:06 <ehird> Sometimes it does things like 'I have a question'
15:27:07 <solrize_> gast = guest
15:27:11 <ehird> without ever specifying a question
15:27:13 <ehird> over and over
15:27:19 <allbery_b> so, an annoybot
15:27:23 <ehird> allbery_b: Yes
15:27:40 <ehird> allbery_b: You just made it move to #centos it seems.
15:27:40 <sjanssen> @tell Cale lambdabot should be fixed now
15:27:41 <mbot> Consider it noted.
15:28:41 <solrize_> http://www.google.com/search?q=wp-gast  it gets around
15:29:54 <ehird> Hmm.
15:30:01 <ehird> I should write a 'WP-Gast KILL!' bot.
15:30:10 <ehird> But nobody would trust it enough to use it ;)
15:31:40 <allbery_b> yeh, the problem with automated anti-bots is the same as with automated anti-worms
15:32:00 <allbery_b> miss one corner case and it becomes worse than the original problem
15:32:12 <ehird> allbery_b: well, WP-Gast is ALWAYS very predictable
15:32:17 <ehird> and always ... usesthehostnamewp-gast
15:32:21 <Twey> Hahaha
15:32:23 <ehird> (lets hope the owner doesn't see that :--))
15:32:33 <ehird> wait, no, REAL NAME
15:32:34 <ehird> sorry
15:32:53 <ehird> No wait
15:32:54 <ehird> ident
15:32:54 <ehird> :PP
15:32:56 <ehird> n=WP-Gast
15:33:08 <allbery_b> is that your final answer?  :)
15:33:10 <ehird> So, no whois or anything required.
15:33:14 <ehird> Just a checking of joins.
15:33:21 <ehird> And then op self, kickban, deop.
15:33:43 <solrize_> always logs in from same host, why not just a permaban?
15:34:02 <ehird> solrize: I'm not sure. #wikipedia don't do it. There must be some reason.
15:34:03 <BCoppens> solrize_: banlist tends to overflow after a while, apparently, after which it is cleared completely
15:34:13 <ehird> ah, of course
15:34:44 <ehird> it's not like #haskell or anyone would use it though. so there's not much point coding it :-)
15:34:45 <BCoppens> perhaps lambdabot should keep a list of permbans, and enforce those :)
15:35:23 <chessguy> http://hpaste.org/7072
15:35:25 <chessguy> is this right?
15:35:59 <ehird> bar :: A -> A -> Int
15:36:00 <ehird> bar = undefined
15:36:00 <ehird> try
15:36:02 <ehird> bar _ _ = undefined
15:36:08 <ehird> but
15:36:13 <ehird> you cannot define a function if it is in an instance,.
15:36:15 <ehird> outside an instance
15:36:24 <ehird> ChanServ: you could do
15:36:27 <ehird> bar' :: A -> A -> Int
15:36:28 <allbery_b> ???
15:36:28 <ehird> bar = bar'
15:36:31 <ehird> but ... WHY
15:36:41 <allbery_b> undefined by itself is perfectly valid there, as irt matches any type
15:36:46 <ehird> allbery_b: yes
15:36:50 <dmwit> chessguy: I don't think you can define a function with the same name as a class function.
15:37:03 <chessguy> well, shoot
15:37:07 <allbery_b> nope
15:37:11 <allbery_b> not without hiding the class
15:37:28 <ehird> chessguy: why why whyh
15:37:42 <chessguy> somebody give ehird a sedative
15:37:44 <allbery_b> (because a class function is really a global function dispatched on its hidden first argument which is a type dictionary)
15:37:52 <chessguy> ehird, why what?
15:38:44 <ehird> chessguy: why are you doing that
15:38:51 <chessguy> ehird, doing what?
15:38:54 <ehird> chessguy: THAT
15:38:57 <ehird> the thing you pasted
15:38:58 * chessguy siys
15:38:59 <ehird> it makes no sense
15:39:01 <ehird> why do you want to do it?
15:39:08 <chessguy> ehird, first of all, it's a contrived example
15:39:13 <ehird> chessguy: no kidding
15:39:28 <chessguy> ehird, if you're talking about the same name thing, what's so silly about that?
15:39:37 <chessguy> the function clearly does the same thing in both places
15:39:40 <ehird> chessguy: why on earth would you want to do it
15:39:46 <ehird> why not just put it in the instance?
15:39:58 <chessguy> ehird, uh, because there could be multiple ways of implementing it
15:40:06 <ehird> chessguy: You make no sense. :-)
15:40:07 <allbery_b> define the function in the instance or use a different name for the standalone version.  the class-instantiated name is not available
15:40:59 <chessguy> allbery_b, that's fine, i understand that it's not syntactically valid, which is what i was asking. what i don't understand is why ehird seems to think it's an idea from mars
15:42:57 <allbery_b> because you are in some sense using the same name in different namespaces (except it's really the same namespace which is why it doesn't work)
15:43:12 <allbery_b> that's usually a recipe for confusion (or perl, but I repeat myself :)
15:43:44 <chessguy> allbery_b, right, i'm using the same name for the same reason you would want to name it bar' -- it represents the same action
15:44:19 <allbery_b> right, but using it both as class member and as classless global is conflating things with different semantics
15:44:41 <chessguy> i can see why the interpreter could get it confused, especially in light of the implementation of typeclasses, so i understand why it doesn't work, but i don't know why it seems totally insane to ehird
15:44:45 <allbery_b> even if it were syntactically correct (as would be in C++, I think), it's asking for confusion
15:45:15 <chessguy> well, at that point it's a preference thing
15:45:34 <allbery_b> (and yes, I think conflating things with different semantics is a bit insane, especially in Haskell which tends to discourage it)
15:46:09 <chessguy> i might like to name the function the same way if it does the same thing
15:46:14 <chessguy> anyway
15:46:35 <chessguy> it doesn't work, which is what i was asking
15:46:36 <allbery_b> with and without a class, though?  still asking for major confusion
15:47:01 <chessguy> well if the only reason the function exists is to instantiate the typeclass
15:47:07 <allbery_b> that's one of those "come back in 6 months, trip over it, hit your head on the wall, and ask yourself what you were smoking when you wrote that" things
15:47:17 <chessguy> perhaps so
15:47:23 <chessguy> i don't claim to have a lot of experience
15:48:42 <allbery_b> (or occasionally "what blithering idiot whote th---oops")
15:48:57 <chessguy> haha, been there, said that
15:49:01 <__pao__> hi all :-)
15:49:37 <allbery_b> I think anyone who's written anything beyond hello world has been there
15:49:38 <chessguy> hi __pao__
15:49:45 <__pao__> is there a way to query ghci for "methods" that need to be implemented for a certain class?
15:49:56 <allbery_b> :info class
15:50:08 <__pao__> allbery_b:  thanks!
15:50:11 <allbery_b> (warning, also prints a lot of other stuff)
15:50:31 <chessguy> allbery_b, that doesn't show default function definitions though
15:50:43 <__pao__> allbery_b: very useful
15:50:48 <chessguy> so technically it doesn't answer quite the question he asked
15:50:48 <allbery_b> true; that information is missing at the level of :info, I think
15:50:59 <allbery_b> (I was just thinking that)
15:51:35 <__pao__> chessguy: is there a way to get that info?
15:51:41 <chessguy> __pao__, i have no idea :)
15:51:52 <ehird> is there a blogging engine in haskell that generates static filse?
15:51:53 <allbery_b> not without source
15:51:55 <ehird> Kinda like nanoblogger.
15:51:58 <chessguy> i'd love to know myself
15:52:00 <ehird> Been considering writing one.
15:52:12 <ehird> (But more bloated: e.g. comments via a CGI)
15:52:29 <ehird> Yeah, static files and CGI are all ancient technology. It'll do until I get my fancy FastCGI setup just right.
15:52:29 <allbery_b> but you can follow the references given by :info (e.g. "Defined in GHC.Base" for ":info Eq")
15:52:51 <__pao__> allbery_b: ... and look at the source?
15:52:56 <allbery_b> yeh
15:53:17 <__pao__> clear
15:53:24 <saml> ehird: maybe pandoc
15:53:25 <chessguy> yuck :(
15:53:32 <chessguy> @go pandoc
15:53:33 <mbot> http://johnmacfarlane.net/pandoc/
15:53:47 <saml> although it's not blog engine, it should be easy to use it to generate html files
15:53:54 <ehird> Pandoc is nice... But it's not a blogging tool, it's just a formatting tool.
15:53:58 <ehird> I was going to use Pandoc for formatting posts.
15:53:59 <allbery_b> ghci might be able to provide that for interpreted stuff if suitably modified, but probably not for compiled ones
15:54:22 <saml> i wrote a blog in PHP using Markdown.php
15:54:24 <ehird> saml: I'm talking about tags, archives, pagination, comments, etc here
15:54:33 <ehird> You should only need two CGIs in the whole thing, really:
15:54:35 <__pao__> allbery_b: clear
15:54:37 <saml> oh i see. that's a serious business then
15:54:43 <ehird> post, and comment
15:55:01 <__pao__> allbery_b: chessguy thank you both :-)
15:55:09 <ehird> 'post' can dual as an editor (Just generate .edit.html or similar files along with the HTML)
15:55:10 <ehird> though
15:55:14 <ehird> that seems a bit weird
15:55:15 <saml> comment is a hard part i think.
15:55:19 <ehird> because it would be very duplicated
15:55:22 <chessguy> __pao__, no problem, i was wondering the same thing
15:55:35 <ehird> saml: no, it's not really serious business. you just need to generate a few mini-posts. :-)
15:55:48 <ehird> hm, ok, here's my current thoughts:
15:55:59 <ehird> All static apart from two CGIs:
15:56:27 <ehird> 'post' - This grabs one of the data files and lets you edit it, causing it to regenerate after that. It can use a new, empty file for making new posts.
15:56:37 <ehird> and
15:56:45 <ehird> 'comment' - Adds a new comment to a data file, causes regeneration.
15:56:48 <ehird> A third might be nice though:
15:56:53 <ehird> 'admin' - lets you do things like edit comments.
15:57:03 <chessguy> __pao__, i've been thinking of writing some chess stuff using typeclasses, such that you don't have to implement very much to get a working chess engine, but you can override any functions you want to to get very particular behavior
15:57:15 <ehird> Apart from that, you can easily generate:
15:57:18 <ehird> An index page with a few posts
15:57:21 <ehird> Tag lists
15:57:24 <ehird> Archives
15:57:28 <ehird> etc
15:57:32 <ehird> so that can be static
15:57:37 <chessguy> so making it clear what typeclasses have default implementations, and what don't will be a very important part of my docuemnation process
15:57:50 <saml> no database? what happens 2 comments come in at the same time?
15:58:17 <ehird> saml: PLENTY of blogs use no database.
15:58:17 <allbery_b> locking, presumably
15:58:22 <ehird> And yeah, locking.
15:58:44 <ehird> If you get reddited digged and slashdotted ... then you'll get about 10 comments per second if for some reason everyone is on drugs.
15:58:51 <ehird> So... only a second or two delay in adding comments.
15:58:52 <__pao__> chessguy: clear
15:59:09 <allbery_b> less than that; you only need to lock when the user hits post/submit
15:59:23 <ehird> allbery_b: Yes.
15:59:28 <ehird> I meant literally the same time.
15:59:30 <ehird> Take a look at this: http://nanoblogger.sourceforge.net/
15:59:31 <allbery_b> if that takes a second or two, upgrade from the 486 already :)
15:59:50 <ehird> It does the tag thing etc. The comments are done by haloscan there, but it has permalinks
15:59:58 <ehird> So just click a permalink and imagine comments and a comment form at the bottom.
16:00:59 <__pao__> lambdabot seems dead
16:01:09 <saml> so not using framework. only those CGIs? (i only know PHP for web development)  that sounds like a nice blog post. post your result on the blog engine you wrote
16:01:19 <chessguy> @seen lambdabot
16:01:19 <mbot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
16:01:29 <ehird> saml: Network.CGI is nice.
16:01:32 <chessguy> __pao__, i think lambdabot got rebooted earlier, and it didn't come back
16:01:35 <chessguy> Cale, ?
16:01:42 <ehird> Also, Tim Bray's Ongoing's comment system uses no database.
16:01:43 <ehird> And is a CGI.
16:02:05 <Cale> Yeah, sjanssen has added some patches. I've just gotten back. I'll fix lambdabot in a minute.
16:02:06 <mbot> Cale: You have 1 new message. '/msg mbot @messages' to read it.
16:03:16 <chessguy> Cale, thanks. i just didn't know what the status was. i just got back from a long walk myself
16:06:08 <ehird> Hmm.
16:06:11 <ehird> Any haskell YAML libraries?
16:06:21 <ehird> (do Haskellers like YAML?)
16:06:25 <sw17ch> i do
16:06:56 <sw17ch> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/YamlReference
16:07:05 <sw17ch> though i haven't used that
16:07:13 <sw17ch> it's the package referenced by yaml.orgb
16:07:17 <sw17ch> minus b
16:07:52 <ehird> Does not look very nice.
16:08:55 <ehird> :|
16:08:56 <allbery_b> HsSyck?
16:09:06 <allbery_b> (SYCK being the follow-on to YAML)
16:09:33 <ehird> allbery_b: Syck is kinda dead.
16:09:51 <ehird> & is appaerntly not this amazing 1.1 thing.
16:10:04 <saml> performance, throughput...etc wise, mature and large blog engines like wordpress don't match simple filesystem ones?
16:10:13 <MarcWeber> allbery_b: What's the trouble with glibc? If it changes I have to recreate the package, right?
16:10:34 <ehird> saml: Meh.
16:10:42 <ehird> WordPress costs you a lot on each page view anyway.
16:10:46 <ehird> Servers are good at serving files. :-)
16:11:09 <ehird> saml: I point you again to http://nanoblogger.sourceforge.net/
16:12:11 <allbery_b> MarcWeber:  several years ago apt-get mishandled it in unstable (and occaisonally testing)
16:13:14 <ehird> Beh -- Debian has no cabal pkg
16:13:15 <ehird> :|
16:14:29 <chessguy> @hoogle hunit
16:14:30 <mbot> No matches found
16:14:38 <chessguy> @go haskell hunit
16:14:39 <mbot> http://hunit.sourceforge.net/
16:14:39 <mbot> Title: HUnit -- Haskell Unit Testing
16:14:48 <chessguy> is that in base yet?
16:17:14 <MarcWeber> allbery_b:  I still don't understand the problem packaging ghc-6.8.2 for debian
16:17:21 <ehird> What does cabal depend on?
16:20:36 <ehird> :/
16:25:01 <allbery_b> hm?  smeon suggested the package in unstable.  I was just pointing out that "unstable" means exactly that
16:26:04 <nibro> @hoogle unsafeInterleaveIO
16:26:05 <mbot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
16:26:38 <ehird> nibro: Look away.
16:26:59 <nibro> ehird: trust me, I know what I'm doing :D
16:27:21 <ehird> RULE 1 OF HASKELL: You do not know what you are doing
16:27:22 * nibro feels like Sledge Hammer
16:27:25 <ehird> RULE 2 OF HASKELL: You do *NOT* know what you are doing
16:27:59 <dons> hehe
16:28:50 <nibro> http://www.youtube.com/watch?v=fktjw7gNv3M
16:29:16 <int-e> rule 3 of haskell (experts only): you do not know what you are doing yet.
16:30:28 <ehird> RULE 4 OF HASKELL: Even if you know what you are doing, anything with 'unsafe' in its name IMMEDIATELY MAKES YOU AN IDIOT
16:31:32 <nibro> ehird: so how would *you* implement a getContents-like generator? :-)
16:31:48 <allbery_b> ehird: sadly there is at least one context where unsafePerformIO is kinda useful.  (it could be argued that you should factor things differently but that can lead to unreadable code; pick your poison)
16:32:07 <Baughn> nibro: forkIO and a Chan or two?
16:32:09 <ehird> nibro: Uhh, I'm pretty sure you can do that without uspi.
16:32:25 <ehird> allbery_b: Which context?
16:33:28 * Heffalump is currently writing code sprinkled with unsafeCoerce
16:33:30 <nibro> ehird: I'm not using uspi, I'm using the other one ;-)
16:33:43 <ehird> nibro: Well, even with unsafeinterleave. ;)
16:33:51 <chessguy> so does haskell have some community space somewhere that we can have a darcs repo and maybe some documentation pages?
16:34:30 <Heffalump> code.haskell.org ?
16:34:32 <nibro> ehird: sure, you can go Baughn's way and use a lazy read from a Chan, but that's a lot of code to write when unsafeInterleaveIO is just one word :-)
16:34:51 <ehird> I'm sure there's a sane way.
16:34:52 <Baughn> nibro: I wasn't suggesting a /lazy/ read. ;)
16:34:54 <chessguy> Heffalump, how do we get space there?
16:35:34 <Heffalump> http://community.haskell.org (which is the same machine)
16:35:53 <Heffalump> (that page has instructions)
16:36:04 <nibro> Baughn: well, I'm doing a lazy write in any case, i.e. I write as few loc as possible :-D
16:37:49 <nibro> @src hGetContents
16:37:50 <mbot> Source not found. I've seen penguins that can type better than that.
16:37:56 <nibro> ah, too bad
16:37:56 <Baughn> nibro: Just one thing - if you use unsafeiio, you should try to make sure your code never errors out. Embed any errors (that aren't totally exceptional) in your return data.. geting a fileNotFoundError in the middle of pure code is just annoying.
16:38:26 <nibro> Baughn: good point
16:38:41 <allbery_b> ehird: shared global variables.  myGlobal :: Int; myGlobal = unsafePerformIO 0
16:39:12 <ehird> allbery_b: But that is just evil.
16:39:16 <ehird> allbery_b: StateT FTW
16:39:22 <nibro> Baughn: though despite my cheeky replies here, I'll go the safer route when I actually publish this, but right now I just want to get it to work
16:39:58 <nibro> ehird: that's a very useful design pattern when you really need it, cue hs-plugins for example
16:40:12 <ehird> hs-plugins is deep magic :)
16:40:21 <nibro> though with a no inline pragma tied to it of course
16:41:55 <ehird> @hoogle unfold
16:41:56 <mbot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
16:41:56 <mbot> Data.ByteString.unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
16:41:56 <mbot> Data.ByteString.unfoldrN :: Int -> (a -> Maybe (Word8, a)) -> a -> (ByteString, Maybe a)
16:42:12 <ehird> unfoldr's type seems wrong.
16:42:26 <nibro> ehird: how so?
16:43:43 <ehird> hmm
16:44:10 <allbery_b> ehird: as I said, there are times when building a stack to hold everything obfuscates more than a well-placed global.
16:44:11 <ehird> @type fix $ \r f i p -> if (p i) then [i] else i : r f (f i) p
16:44:14 <mbot> forall t. (t -> t) -> t -> (t -> Bool) -> [t]
16:44:40 <ehird> that's the unfold i know, at least
16:45:16 <allbery_b> for example I have some things which get initialized using other values which have to be themselves shared and initialized beforehand.  building the tables in question could certaibnly be done with state at runtime, but would be mich harder to understand
16:45:31 <allbery_b> :t unfoldr
16:45:34 <mbot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
16:45:36 <ehird> @let unfold p _ i | p i = [i]
16:45:37 <mbot> Plugin `eval' failed with: : copyFile: permission denied (Permission denied)
16:45:41 <ehird> @let unfold p _ i | p i = [i]
16:45:41 <mbot> Plugin `eval' failed with: : copyFile: permission denied (Permission denied)
16:45:43 <ehird> WTF
16:45:56 <dolio> @let stopWhen p f x = if p x then Nothing else Just (f x)
16:45:56 <mbot> Plugin `eval' failed with: : copyFile: permission denied (Permission denied)
16:46:04 <allbery_b> it's well known that stock unfoldr is painful, there's an alternatice in the wiki somewhere
16:46:04 <Heffalump> we get the idea :-)
16:46:25 <allbery_b> and I suspect @let isn't enabled in mbot for whatever reason
16:46:46 <sw17ch> why is lambdabot mbot?
16:46:48 <dolio> @type let stopWhen p f x = if p x then Nothing else Just (f x) in \p f -> unfoldr (stopWhen p $ f)
16:46:51 <mbot> forall t a. (t -> Bool) -> (t -> (a, t)) -> t -> [a]
16:46:55 <ehird> > let unfold p _ i | p i = [i]; unfold p f i = i : unfold p f (f i) in unfold (const False) id 2
16:46:57 <mbot>  [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
16:47:08 <Baughn> sw17ch: Why are any of us here? What is the meaning of life?
16:47:17 <Baughn> sw17ch: (Lambdabot is temporarily down for repairs)
16:47:24 <ehird> Is Haskell' going to fix this? ;)
16:47:34 <ehird> I'm sure I can define unfoldr from my function
16:47:42 <sw17ch> Does haskell know the meaning of life?
16:47:54 <Baughn> @faq Can haskell compute the meaning of life?
16:47:55 <mbot> The answer is: Yes! Haskell can do that.
16:48:13 <sw17ch> > meaningOfLife where meaningOfLife = 2
16:48:13 <mbot>  Parse error at "where" (column 15)
16:48:16 <ehird> Hmm.
16:48:28 <ehird> I cannot see why anyone would want the Dat.List one
16:48:34 <sw17ch> > let meaningOfLife = 42 in meaningOfLife
16:48:36 <Jedai> > let meaningOfLife = 42 in meaningOfLife
16:48:36 <mbot>  42
16:48:38 <mbot>  42
16:48:42 <sw17ch> oh... wow
16:48:43 <sw17ch> :)
16:48:48 <dolio> @type let stopWhen p f x = if p x then Nothing else Just (f x) in \p f -> unfoldr (stopWhen null $ splitAt 5) ['a'..'z']
16:48:51 <mbot> forall t t1. t -> t1 -> [[Char]]
16:48:51 <ehird> #define SIX 5 + 1
16:48:56 <dolio> > let stopWhen p f x = if p x then Nothing else Just (f x) in \p f -> unfoldr (stopWhen null $ splitAt 5) ['a'..'z']
16:48:57 <ehird> #define NINE 8 + 1
16:48:58 <mbot>  Add a type signature
16:49:02 <ehird> SIX * NINE == 42
16:49:08 <dolio> > let stopWhen p f x = if p x then Nothing else Just (f x) in unfoldr (stopWhen null $ splitAt 5) ['a'..'z']
16:49:10 <mbot>  ["abcde","fghij","klmno","pqrst","uvwxy","z"]
16:49:40 <int-e> ehird: yours can't generate empty lists, so no, you can't define unfoldr in terms of it.
16:49:57 <ehird> int-e: Hmm.
16:50:03 <int-e> ehird: easily fixed of course
16:50:03 <ehird> > let unfold p _ i | p i = []; unfold p f i = i : unfold p f (f i) in unfold (const False) id 2
16:50:05 <mbot>  [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
16:50:15 <ehird> Actually, perhaps we need to directly define fold.
16:50:18 <ehird> Then unfold should become obvious.
16:50:26 <Jedai> > takeWhile (not . null) . unfoldr (Just . splitAt 5) $ ['a'..'z']
16:50:29 <mbot>  ["abcde","fghij","klmno","pqrst","uvwxy","z"]
16:50:54 <ehird> But unfold is actually quite hard to reason about... because intuitively folds are 'irreversable' so how can unfold exist?
16:51:33 <Jedai> ehird: fold aren't irreversable, if you have an "inverse" of the folded operator
16:51:41 <ehird> Jedai: Exactly
16:51:47 <monochrom> intuitively folds are reversible but there are many answers.
16:51:57 <int-e> > unfoldr (liftM2 (>>) (guard . not . null) (splitAt 5)) ['a'..'z']
16:51:59 <mbot>  Couldn't match expected type `Maybe'
16:52:30 <int-e> > unfoldr (liftM2 (>>) (guard . not . null) (return . splitAt 5)) ['a'..'z']
16:52:32 <mbot>  ["abcde","fghij","klmno","pqrst","uvwxy","z"]
16:52:36 <monochrom> intuitively unfold chooses one based on how you code up the callback.
16:52:41 <int-e> (yay for obscurity)
16:52:43 <monochrom> intuitively it all makes sense.
16:53:25 <Jedai> Depends on your intuition though ;)
16:53:52 <monochrom> intuitively it is not rocket science.
16:54:21 <ehird> int-e: Wow. :D
16:54:33 <ehird> Hmm.
16:54:40 <ehird> There should be a list monad based on folds of some kind.
16:55:16 <Cale> Hmm, the free-theorems package doesn't want to build for me... I'll have a closer look.
16:56:38 <twanvl> There really should be a function  unfoldrGuard :: (b -> Bool) -> (b -> (a,b)) -> b -> [a]
16:57:48 <dolio> I wouldn't mind dropping the current unfoldr for that.
16:58:12 <dolio> There are too few functions of the right type for the unfoldr.
16:58:17 <ehird> Still too complex
16:58:20 <nibro> wee, package release! :-D
16:58:23 <ehird> it doesn't really reflect fold
16:58:37 <ivan_salazar_v> Hello. How would you apply a function f :: (Monad m) => (a -> m b) -> a -> m b over a list of values while the return value of f is equals to some value v?My initial guess was: liftM (dropWhile (= v)) $ mapM f xs,  but mapM isn't lazy and I want lazy evaluation over xs.
16:58:46 * nibro feels proud for actually having released early for once... really early...
16:59:17 <dons> unfoldrGuard :: (b -> Bool) -> (b -> (a,b)) -> b -> [a]
16:59:18 <dons> unfoldrGuard p f = unfoldr (\s -> if p s then Nothing else Just (f s))
16:59:24 <dolio> ehird: The current unfoldr is the right type as far as the theory goes.
16:59:34 <ehird> dolio: Doesn't look right though.:P
16:59:38 <dons> foldr . unfoldr works, it really is the right function
16:59:44 <int-e> ehird: we could define foldr :: (Maybe (a,b) -> b) -> [a] -> b ;-)
16:59:57 <dolio> Because list is the fixpoint of the functor 'F b = Maybe (a, b)'.
17:00:10 <ehird> int-e: eeek :)
17:00:11 <dolio> More or less.
17:00:11 <Cale> ivan_salazar_v: hm? You could use map
17:00:32 <Cale> ivan_salazar_v: You're applying it to a list of functions?
17:00:41 <ehird> Cale: sounds like ap
17:00:43 <ivan_salazar_v> Cale: Noup, a list of values.
17:00:59 <Cale> ivan_salazar_v: Is the function f partially applied then?
17:01:07 <ehird> @type \f xs -> liftM (dropWhile (= v)) $ mapM f xs
17:01:11 <mbot> parse error on input `='
17:01:15 <ehird> @type \f xs -> liftM (dropWhile (== v)) $ mapM f xs
17:01:18 <mbot> forall (m :: * -> *) a. (Monad m) => (a -> m Expr) -> [a] -> m [Expr]
17:01:37 <ivan_salazar_v> Cale: Sorry, what means "partially apllied"
17:01:40 <dolio> ehird: You need to read the Bananas, Lenses, ... paper. Then it will look right.
17:01:51 <ehird> dolio: Maybe.
17:01:52 <ivan_salazar_v> Oh, yes, I missed another =
17:02:18 <Cale> ivan_salazar_v: Because if f :: (a -> m b) -> a -> m b, then f wants a function.
17:02:31 <Cale> ivan_salazar_v: So if you're mapping f over a list, it had better be a list of functions.
17:02:41 <ehird> Welp, I just invented the silliest function ever, out of tiredness.
17:02:42 <ehird> @type \x y -> do v <- x; foldl y x v
17:02:45 <mbot> forall (t :: * -> *) b. (Monad t) => t [b] -> (t [b] -> b -> t [b]) -> t [b]
17:03:11 <ivan_salazar_v> Cale: Damn, my mistake. It was f :: Monad m => a -> m b
17:03:11 <dolio> Besides, (a -> Bool) -> (a -> a) -> a -> [a] clearly isn't the right type, because it doesn't mention 'b' like fold does. :)
17:03:16 <ehird> Under the list monad maybe..
17:03:17 <ehird> [[b]] -> ([[b]] -> b -> [[b]]) -> [[b]]
17:03:43 <ehird> > let wtf = \x y -> do v <- x; foldl y x in wtf [[1,2,3],[4,5,6],[7,8,9]] (flip (:))
17:03:43 <Cale> sjanssen: Did you have any problems building the free-theorems package? I'm having lots of trouble with the way in which it's using haskell-src-exts.
17:03:44 <mbot>  Couldn't match expected type `[b] -> t' against inferred type `[a]'
17:03:53 <Cale> ivan_salazar_v: Okay.
17:03:54 <ehird> Hmm, wait what
17:03:55 <ehird> Oh
17:04:05 <ehird> > let wtf = \x y -> do v <- x; foldl y x in wtf [[1,2,3],[4,5,6],[7,8,9]] (\xs x -> [x] : xs)
17:04:07 <Cale> ivan_salazar_v: So if you map that function over a list, you'll get a list of values of type m b
17:04:07 <mbot>  Couldn't match expected type `[b] -> t' against inferred type `[a]'
17:04:11 <ehird> Hmm, what.
17:04:16 <ivan_salazar_v> Cale: yes
17:04:27 <Cale> ivan_salazar_v: Which can then be strung together and executed in any particular order that you'd like.
17:04:43 <ehird> ?type let wtf = \x y -> do v <- x; foldl y x in wtf [[1,2,3],[4,5,6],[7,8,9]]
17:04:46 <mbot>     Couldn't match expected type `[b] -> t' against inferred type `[a]'
17:04:47 <mbot>     In the first argument of `wtf', namely
17:04:47 <mbot>         `[[1, 2, 3], [4, 5, 6], [7, 8, 9]]'
17:04:51 <ehird> Oh!
17:05:04 <Cale> sequence will turn them into a single action which when executed will execute all of them, and produce a list of the results.
17:05:11 <ehird> Wait .. that doesn't make any sense, does it?
17:05:23 <ehird> forall (t :: * -> *) b. (Monad t) => t [b] -> (t [b] -> b -> t [b]) -> t [b]
17:05:28 <ivan_salazar_v> Cale: Yes, but I don't want all of them.
17:05:39 <ehird> Ohhh
17:05:44 <ehird> ?type \x y = do v <- x; foldl y x v
17:05:44 <Cale> ivan_salazar_v: Do you know which ones you want?
17:05:48 <mbot> parse error on input `='
17:06:03 <ehird> > let wtf = \x y -> do v <- x; foldl y x v in wtf [[1,2,3],[4,5,6],[7,8,9]] (\xs x -> [x] : xs)
17:06:06 <mbot>  [[3],[2],[1],[1,2,3],[4,5,6],[7,8,9],[6],[5],[4],[1,2,3],[4,5,6],[7,8,9],[9]...
17:06:07 <ivan_salazar_v> Cale: take the ones that are equal to some value inside the monad
17:06:14 <ehird> Well...
17:06:17 <Cale> ...
17:06:17 <ehird> That makes highly little sense.
17:06:20 <ehird> I love it.
17:06:32 <Cale> ivan_salazar_v: Computations in your monad are comparable for equality?
17:06:36 <Cale> ivan_salazar_v: Which monad is this?
17:06:49 <ehird> Cale: He's talking about the values inside I think.
17:07:07 <int-e> ehird: there's a context where you get a fold like that quite naturally: newtype Fix t = Fix { out :: t (Fix t) } with fold :: Functor t => (t b -> b) -> Fix t -> b ; fold f = f . fmap (fold f) . out  and  unfold :: Functor t => (a -> t a) -> a -> Fix t; unfold f = Fix . fmap (unfold f) . f
17:07:10 <Cale> But you have to run them to know what value they produce :)
17:07:54 * ehird tries to work out what on earth [[3],[2],[1],[1,2,3],[4,5,6],[7,8,9],[6],[5],[4],[1,2,3],[4,5,6],[7,8,9],[9]... could be useful for.
17:07:59 <ivan_salazar_v> Cale: OK, maybe I should be more concise.
17:08:11 <ehird> It looks almost random at a glance
17:08:42 <monochrom> Every program without a clearly stated purpose is random.
17:08:51 <ehird> monochrom: Sure.
17:09:01 <ehird> But my 'wtf' function seems *fairly* simple
17:09:20 <geezusfreeek> wait, what's so weird about it?
17:09:24 <monochrom> There are simpler pseudo-random generators.
17:09:48 <ehird> geezusfreeek: Nothing, it's just a bit sill yin its output
17:10:09 <ehird> For each element in the list, it produces each element in a list of its own, but backwards.
17:10:13 <ehird> Then, the full set.
17:11:17 <ivan_salazar_v> Cale: I'm coding a lisp-like interpreter. And my eval function has return type: IOThrowsError Exp. Exp is the data type that contains the lisp values, and IOThrowsError is the higher-order type ErrorT SalsaError IO and SalsaError is the error type my eval function may throw when failing
17:11:47 <ivan_salazar_v> Cale: (As you are now aware of, I'm really newbie)
17:11:57 <geezusfreeek> > let wtf = \x y -> do v <- x; foldl y x v in wtf ["123","456","789"] (\xs x -> [x] : xs)
17:11:59 <mbot>  ["3","2","1","123","456","789","6","5","4","123","456","789","9","8","7","12...
17:12:08 <geezusfreeek> ah now i see
17:12:16 <geezusfreeek> all those brackets were making my eyes sore!
17:12:17 <chessguy> hey, i'm looking at http://community.haskell.org/admin/account_request.html ... can someone give me a summary of the differences between the licenses mentioned there?
17:12:20 <Cale> ivan_salazar_v: Okay.
17:12:44 <ehird> geezusfreeek: Yeah, I want to see what appears at the end
17:12:54 <ehird> > let wtf = \x y -> do v <- x; foldl y x v in drop 7 $ wtf ["123","456","789"] (\xs x -> [x] : xs)
17:12:56 <mbot>  ["5","4","123","456","789","9","8","7","123","456","789"]
17:13:03 <ehird> Ah.
17:13:11 <ehird> So ... first person to find something that 'wtf' embodies wins amazement ;)
17:13:19 <geezusfreeek> chessguy: BSD = don't force derivative works to be BSD. GPL = force derivative works to be GPL. PD = i don't know
17:13:36 <Cale> PD is public domain
17:13:39 <geezusfreeek> oh
17:13:44 <geezusfreeek> right
17:13:59 <ivan_salazar_v> Cale: And I want to write code that evaluates the "or combination" in Lisp.
17:14:09 <ehird> PD <3
17:14:10 <Cale> ivan_salazar_v: all right.
17:14:11 <chessguy> geezusfreeek, surely that's not the only difference
17:14:16 <monochrom> <3 PD
17:14:21 <geezusfreeek> chessguy: you asked for a summary :P
17:14:32 <geezusfreeek> but essentially that's it
17:14:36 <Cale> ivan_salazar_v: So you want to run one action, get its result and decide then whether to execute the next?
17:14:47 <ivan_salazar_v> Cale: Yes.
17:14:50 <ehird> monochrom: totally
17:15:03 <geezusfreeek> chessguy: to go into any further detail would be to reveal my bias ;)
17:15:26 <chessguy> geezusfreeek, if that was accurate, there wouldn't really be any differences between them. you could just say that any license requires derivative works to have the same license. c
17:15:36 <Cale> Okay, there might be a more concise way to write this, but let's write a monadic generalisation of the prelude 'and' function which executes the elements in order and expresses that control flow.
17:15:38 <geezusfreeek> chessguy: you must have misread me
17:15:49 <geezusfreeek> BSD does _not_ require derivate works to be BSD
17:15:50 <monochrom> BSD does not.
17:15:52 <ivan_salazar_v> Cale: I wrote some code that behaves like that, but I used recursion. I'm trying to figure out if there is some way to write that using higher-order functions
17:15:58 <chessguy> geezusfreeek, oh, whoops
17:16:09 <ivan_salazar_v> Cale: I'll paste that code in hpaste
17:16:40 <monochrom> I think mplus helps.
17:16:55 <Cale> ivan_salazar_v: possibly using foldM, but I'm not sure that you can do it without continuations.
17:17:23 <ehird> Cale: Okay then.
17:17:23 <monochrom> nevermind, mplus doesn't help easily.
17:17:26 <ehird> ANY monad?
17:17:27 <ehird> Like..
17:17:27 <geezusfreeek> revealing my biases, i really like that a majority haskell projects seem to be under BSD
17:17:30 <mokomull> rrr
17:17:33 <ivan_salazar_v> Cale: http://hpaste.org/7073
17:17:34 <ehird> (Monad m) => m Bool -> Bool
17:17:44 <mokomull> oh so that's why firefox wouldn't respond :X
17:17:57 <ehird> Because I don't think that's possible :P
17:17:59 <Cale> er, ah, right or, not and :)
17:18:13 <ehird> @type or
17:18:17 <mbot> [Bool] -> Bool
17:18:21 <Cale> Yeah, that seems sensible. You can factor that pattern out into a control structure if you like.
17:18:29 <ehird> Cale: it'll have to be (Monad m) => m Bool -> m Bool
17:18:36 <ehird> @type foldM
17:18:36 <monochrom> [m Bool] -> m Bool
17:18:41 <mbot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
17:18:44 <ehird> monochrom: Ahhh.
17:19:18 <ehird> @type \xs -> (\x y -> y >>= \v -> x && v) True xs
17:19:21 <mbot>     Couldn't match expected type `m b' against inferred type `Bool'
17:19:22 <mbot>     In the expression: x && v
17:19:22 <mbot>     In the second argument of `(>>=)', namely `\ v -> x && v'
17:19:23 <ehird> @type \xs -> foldM (\x y -> y >>= \v -> x && v) True xs
17:19:27 <mbot>     Couldn't match expected type `m Bool' against inferred type `Bool'
17:19:27 <mbot>     In the expression: x && v
17:19:27 <mbot>     In the second argument of `(>>=)', namely `\ v -> x && v'
17:19:30 <ehird> Hmm.
17:19:42 <dolio> @type liftM and . sequence
17:19:43 <int-e> @type foldM . liftM2
17:19:45 <mbot> forall (m :: * -> *). (Monad m) => [m Bool] -> m Bool
17:19:48 <mbot> forall a1 a2 (m :: * -> *). (Monad m) => (a1 -> a2 -> m a1) -> m a1 -> [m a2] -> m (m a1)
17:19:50 <ehird> @type \xs -> foldM (\x y -> do a <- x; b <- y; return (a && b)) True xs
17:19:53 <mbot>     Couldn't match expected type `m Bool' against inferred type `Bool'
17:19:53 <mbot>     In the first argument of `return', namely `(a && b)'
17:19:53 <mbot>     In the expression: return (a && b)
17:20:10 <ehird> @type liftM
17:20:13 <mbot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
17:20:20 <ehird> @type \xs -> and (sequence xs)
17:20:25 <ehird> err
17:20:27 <mbot>     Couldn't match expected type `Bool' against inferred type `[a]'
17:20:27 <mbot>       Expected type: [Bool]
17:20:27 <mbot>       Inferred type: [[a]]
17:20:34 <ehird> @type fmap
17:20:37 <mbot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:20:42 <ehird> @type \xs -> fmap and (sequence xs)
17:20:45 <mbot> forall (f :: * -> *). (Functor f, Monad f) => [f Bool] -> f Bool
17:20:48 <monochrom> dolio: there is a short-circuit requirement on skipping computations, not just their results.
17:20:48 <ehird> There we go.
17:20:49 <ehird> :-)
17:20:59 <dolio> Ah.
17:21:01 <mauke> <dolio> @type liftM and . sequence
17:21:06 <ehird> monochrom: Oh damn
17:21:07 <ehird> Okay
17:21:09 <ehird> Well I can do this
17:21:28 <ivan_salazar_v> Cale: Thanks, I'll try with foldM
17:21:37 <ehird> foo x = do v <- x; case v of {[] -> return True; (x:xs) -> if x then foo xs else return False}
17:21:46 <int-e> @type foldM (liftM . (&&)) True
17:21:48 <dolio> I'm not sure foldM is acceptable either, then.
17:21:49 <ehird> @type fix $ \f x -> do v <- x; case v of {[] -> return True; (x:xs) -> if x then f xs else return False}
17:21:49 <mbot> forall (m :: * -> *). (Monad m) => [m Bool] -> m Bool
17:21:50 <Cale> ivan_salazar_v: The tricky thing is that by default foldM will run *all* the computations.
17:21:52 <ehird> @pl fix $ \f x -> do v <- x; case v of {[] -> return True; (x:xs) -> if x then f xs else return False}
17:21:53 <mbot>     Couldn't match expected type `Bool' against inferred type `[Bool]'
17:21:53 <mbot>       Expected type: [Bool] -> [Bool]
17:21:53 <mbot>       Inferred type: [[Bool]] -> [Bool]
17:21:53 <mbot> (line 1, column 24):
17:21:53 <mbot> unexpected ";"
17:21:55 <mbot> expecting letter or digit, variable, "(", "`", "!!", ".", operator, "$", "$!", "`seq`" or end of input
17:22:01 <ehird> ........
17:22:07 <ivan_salazar_v> Cale: uhm... damn...
17:22:12 <ehird> @undo fix $ \f x -> do v <- x; case v of {[] -> return True; (x:xs) -> if x then f xs else return False}
17:22:12 <mbot> fix $ \ f x -> x >>= \ v -> case v of { [] -> return True; (x : xs) -> if x then f xs else return False}
17:22:17 <ehird> @pl fix $ \ f x -> x >>= \ v -> case v of { [] -> return True; (x : xs) -> if x then f xs else return False}
17:22:17 <mbot> (line 1, column 39):
17:22:17 <mbot> unexpected "{"
17:22:17 <mbot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<", "$", "$!", "`seq`" or end of input
17:22:21 <EvilTerran> pl doesn't deal with do notation
17:22:22 <EvilTerran> or cases
17:22:23 <ehird> @pl fix $ \ f x -> x >>= \ v -> case v of [] -> return True; (x : xs) -> if x then f xs else return False
17:22:23 <mbot> (line 1, column 42):
17:22:23 <mbot> unexpected ">" or "-"
17:22:23 <mbot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<", "$", "$!", "`seq`" or end of input
17:22:27 <ehird> EvilTerran: Darn
17:22:29 <ehird> What can I do?
17:22:54 <ehird> @pl fix $ \ f x -> x >>= \ v -> if null v then return True else if (head v) then f (tail v) else return False
17:22:54 <monochrom> You can undo then pl.
17:22:54 <mbot> fix ((=<<) . ap (flip if' (return True) . null) . flip flip (return False) . liftM2 if' head . (. tail))
17:23:04 <ivan_salazar_v> Cale: I was thinking if there was something like a monadic dropWhile or something like that :S
17:23:04 <EvilTerran> monochrom, but not for case{}
17:23:05 <ehird> @unpl fix ((=<<) . ap (flip if' (return True) . null) . flip flip (return False) . liftM2 if' head . (. tail))
17:23:05 <mbot> fix (\ r u -> u >>= ((\ ag -> if' (null ag) (return True)) >>= \ z -> (\ i -> (head >>= \ k -> (\ aq -> r (tail aq)) >>= \ j -> return (if' k j)) i (return False)) >>= \ y -> return (z y)))
17:23:09 <ehird> @. redo unpl fix ((=<<) . ap (flip if' (return True) . null) . flip flip (return False) . liftM2 if' head . (. tail))
17:23:10 <mbot> fix (\ r u -> do { a <- u; (do { z <- (\ ag -> if' (null ag) (return True)); y <- (\ i -> (do { k <- head; j <- (\ aq -> r (tail aq)); return (if' k j)}) i (return False)); return (z y)}) a})
17:23:12 <EvilTerran> blimey
17:23:13 <Cale> ivan_salazar_v: Which is why I mentioned continuations. You could ContT transform your monad briefly in order to use callCC to escape early, but I don't think it's worthwhile. I can write that for you if you'd like.
17:23:14 <int-e> oh you want shortcut semantics I guess
17:23:17 <monochrom> Sorry if "you can undo" is a pun to the question "what can I do".
17:23:17 <ehird> Okay, well, lambdabot sucks.
17:23:22 <int-e> ehird: mbot replies to privmsg
17:23:27 <ehird> However.... fix $ \f x -> do v <- x; case v of {[] -> return True; (x:xs) -> if x then f xs else return False}
17:23:30 <Cale> ivan_salazar_v: Alternately, you can write a version of foldM which has an early stopping condition.
17:23:48 <ehird> we need @golf
17:23:55 <ehird> tries to factor out code patterns into higher-order stuff
17:24:14 * chessguy sighs
17:24:19 <ehird> chessguy: :))
17:24:20 <chessguy> licensing is way too complicated
17:24:22 <EvilTerran> does an exhaustive search of all haskell expressions from smallest to largest until it finds one of the same type
17:24:23 <EvilTerran> :D
17:24:29 <ivan_salazar_v> Cale: Yes, maybe.
17:24:51 <Cale> chessguy: Just go with BSD3.
17:24:52 <ehird> chessguy: 1. Public domain 2. Feel warm and fuzzy
17:25:03 <monochrom> 3. Profit!
17:25:06 <ehird> Cale: Oh sure, you THINK it's total freedom, BUT IT'S TOO RESTRICTIVE
17:25:09 <ehird> :P
17:25:14 <Cale> Public domain is slightly dangerous, because it doesn't have the disclaimer.
17:25:22 <ehird> No but seriously as long as it's not the fascist GPL I am fine
17:25:28 <ehird> And so what about the goddamn disclaimer
17:25:33 <ehird> I'm happy, let them do what they want
17:25:40 <monochrom> I think some people actually like the restrictions in BSD.
17:25:47 <Cale> ehird: Well, you can be liable if someone uses your code and it doesn't work.
17:25:51 <ivan_salazar_v> Cale: I think what would be piece of cake for and advanced haskeller (the continuation thing) but maybe the recursive approach is still the choice for a newbie like me :s
17:25:56 <ehird> Cale: You can put in a 'no warranty'
17:25:57 <chessguy> well, what i'm working on is a chess engine toolkit. i have to be careful, because i want to say exactly what people can and can't include in their engine 1.) to go commercial and 2.) to participate in chess engine competitions
17:25:59 <ehird> That's not a license
17:26:20 <ehird> That's just "This code comes with no warranty. Any side effects it has are YOUR PROBLEM. Now don't talk to me about your broken toaster."
17:26:22 <ehird> except more formal
17:26:28 <EvilTerran> ivan_salazar_v, i'd go for straightforward recursion
17:26:41 <Cale> ivan_salazar_v: Yes, I think that's probably the nicest way to go for now. Write a few things like that and see if they resemble one another, and maybe you can factor out a higher order pattern.
17:27:02 <Cale> OR and AND should be rather similar.
17:27:28 <ehird> Cale: or and and
17:27:35 <ehird> and `or` and
17:27:38 <bos> what's the difference between "type Foo = StateT Int IO" and "type Foo a = StateT Int IO a"?
17:27:50 <ehird> bos: None at all.
17:27:51 <bos> ghc treats them as different, even though they both have kind "* -> *"
17:27:55 <ehird> Oh
17:27:56 <ehird> Of course
17:27:58 <monochrom> Sad music could cause some already distressed people to go suicidal. Mahler wrote very sad music. The work is in public domain. Mahler is still not liable.
17:28:01 <ehird> No currying on type synonyms.
17:28:04 <ivan_salazar_v> Cale: Yes. http://hpaste.org/7073#a1 They are similar... XD
17:28:07 <ehird> Ha ha, play again.
17:28:09 <dolio> bos: The second can't be unapplied.
17:28:09 <ehird> You suck.
17:28:10 <ehird> :)
17:28:37 <Cale> ivan_salazar_v: What's isFalse?
17:28:39 <bos> dolio: unapplied?
17:28:47 <ehird> monochrom: Pretty much yes
17:28:53 <ehird> Cale: Presumably, Salsathingy -> Bool
17:28:59 <Cale> ehird: ah, right
17:29:06 <dolio> bos: Think 'instance Monad Foo where ...' or 'ContT r Foo a'
17:29:09 <ivan_salazar_v> Cale: Yes, that.
17:29:26 <ivan_salazar_v> XD
17:29:37 <dolio> bos: The first works with those (with synonym deriving for the first), the second doesn't.
17:29:42 <bos> dolio: yes, that's where i ran into the difference. oh, i see, you can't use it without applying it.
17:29:43 <monochrom> If someone sues me over my public domain work, I'll go around asking you for donations to fund my effort to face the case and show that I am not supposed to be liable, no one is.
17:30:02 <bos> dolio: your wording confused me.
17:30:07 <ehird> monochrom: I agree.
17:30:08 <int-e> @type (>> return True) . mapM (>>= guard)
17:30:11 <mbot> forall (m :: * -> *). (MonadPlus m) => [m Bool] -> m Bool
17:30:25 <ehird> We should start a Public Domain Haskell movement! :p
17:30:29 <ehird> just like n+k
17:30:41 <pjd_> monochrom: they would have to demonstrate what you're liable for
17:31:01 <dolio> bos: Yeah. I was going to say partially applied, but Foo only has one parameter.
17:31:10 <ivan_salazar_v> Cale: Here's the code to isFalse: http://hpaste.org/7073#a2
17:31:19 <EvilTerran> ivan_salazar_v, it seems like something to the effect of "takeWhileM" would be perhaps useful
17:31:38 <Cale> ivan_salazar_v: Right, that's sensible :)
17:31:42 <pjd_> monochrom: many kinds of liability won't apply at all, because you're not providing a product or service
17:31:57 <ivan_salazar_v> EvilTerran: Does "takeWhileM" exists?
17:32:20 <ivan_salazar_v> @t takeWhileM
17:32:21 <mbot> Maybe you meant: tell temp thank you thanks thx time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
17:32:24 <EvilTerran> no
17:32:30 <EvilTerran> ?type takeWhile
17:32:34 <mbot> forall a. (a -> Bool) -> [a] -> [a]
17:32:49 <int-e> why does mapAndUnzipM exist?
17:33:06 <ivan_salazar_v> EvilTerran: Oh, then I should code my own.
17:33:06 <EvilTerran> actually, that's not quite right. maybe rolling an untilM - or, as someone suggested, a foldM with an escape clause
17:33:08 <EvilTerran> ?type foldM
17:33:11 <mbot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
17:34:14 <ivan_salazar_v> EvilTerran: OK.
17:34:28 <ivan_salazar_v> ?type untilM
17:34:32 <mbot> Not in scope: `untilM'
17:34:43 <ivan_salazar_v> ?type Control.Monad.untilM
17:34:46 <mbot> Not in scope: `Control.Monad.untilM'
17:34:47 <EvilTerran> ?type until -- again, you'd have to roll your own, but something of similar type to until
17:34:50 <sjanssen> Cale: did you have more trouble getting lambdabot up?
17:34:50 <ivan_salazar_v> Douh.
17:34:51 <mbot> forall a. (a -> Bool) -> (a -> a) -> a -> a
17:35:02 <chessguy> EvilTerran, ivan_salazar_v i implemented a takewhileM a while back, IIRC. i can look for it if you're interested
17:35:16 <EvilTerran> untilM :: (a -> m Bool) -> (a -> m a) -> a -> m a -- or something
17:35:35 <Cale> sjanssen: I think I might have it now. One moment :)
17:35:43 <chessguy> actually, i just found it
17:35:51 <ivan_salazar_v> Oh, thanks.
17:36:00 <Cale> sjanssen: I had some trouble building the free-theorems package, since it relies on an old version of haskell-src-exts
17:36:08 <Cale> (and doesn't express this fact)
17:36:31 <chessguy> http://hpaste.org/7074
17:36:42 <chessguy> ivan_salazar_v, EvilTerran ^^
17:36:42 <sjanssen> Cale: yep, I had to work around that too
17:36:51 <EvilTerran> ta
17:37:00 <sjanssen> Cale: lambdabot will still run without it, @ft just won't work
17:37:01 <EvilTerran> blimmeh
17:37:02 <ivan_salazar_v> chessguy: Wow...
17:37:10 <chessguy> actually, i shouldn't take credit for this, someone in the channel helped me with it
17:37:19 <ivan_salazar_v> chessguy: Oh :P
17:37:24 <EvilTerran> bit heavy on the pointsfree
17:37:28 <Cale> aha, there we are
17:37:33 <Cale> @bot
17:37:33 <mbot> :)
17:37:38 <lambdabot> :)
17:37:44 <Cale> > foldr f z [1,2,3]
17:37:46 <mbot>  f 1 (f 2 (f 3 z))
17:37:52 <lambdabot>  setResourceLimit: invalid argument (Invalid argument)
17:37:56 <Cale> uhh...
17:37:59 <EvilTerran> durr
17:38:00 <Cale> oh, right.
17:38:04 <Cale> *sigh*
17:38:04 <chessguy> EvilTerran,  yeah, i think i was going through a @pl phrase at the time
17:38:07 <allbery_b> heh
17:38:07 <sjanssen> Cale: did I break that?
17:38:28 <chris___> hi
17:38:36 <chessguy> hiya chris___
17:38:49 <Cale> I think Baughn did (but sort of rightfully so). It's actually a GHC bug which I had an awful workaround for.
17:39:39 <Cale> ah, nice, he put in some cpp flags for it :)
17:39:42 <ivan_salazar_v> chessguy: Thanks, I think I'll have to read that code for a while. XD
17:40:07 <Baughn> Cale: Sure. That's what you get for not reading the patch comments. :P
17:40:31 <Cale> Baughn: for some reason when darcs imported them it didn't step me through them like usual.
17:40:34 <chessguy> ohhhh, p0wn'd
17:40:41 <Cale> > foldr f z [1,2,3]
17:40:42 <lambdabot>  f 1 (f 2 (f 3 z))
17:40:43 <mbot>  f 1 (f 2 (f 3 z))
17:40:49 <Cale> there we are :)
17:40:56 <Cale> mbot: @part #haskell
17:41:08 <Baughn> > [1..3] ++ [last [1..]]
17:41:12 <lambdabot>  [1,2,3,
17:41:12 <sw17ch> lambdabot, i missed you
17:41:21 <chessguy> @quote miss
17:41:22 <lambdabot> astrolabe says: I guess missile launching would have to be in IO
17:41:22 <Twey> Er
17:41:24 <Twey> Bug?
17:41:29 <Cale> Baughn: is that new?
17:41:43 <chessguy> @quote miss
17:41:43 <lambdabot> astrolabe says: I guess missile launching would have to be in IO
17:41:53 <Twey> Hmm
17:41:56 <Baughn> Cale: That's what my patch /did/, but it's not quite complete yet - there should be a "tiemout" on that, at least
17:42:25 <dolio> > let andM = foldM (\b ma -> if not b then return False else ma) True in runWriter (andM [return False, tell "quux" >> return True])
17:42:26 <lambdabot>  (False,"")
17:42:33 <Baughn> This is actually the second time I fix this. I managed to delete my last patch. :/
17:42:56 <sjanssen> I don't see this patch in the repository?
17:43:32 <byorgey> > 1 : [ sum [1..] ]
17:43:38 <lambdabot>  [1,Exception: Time limit exceeded
17:43:42 <byorgey> neat! =)
17:43:47 <byorgey> Baughn++
17:44:35 <beikyn> 'sup tueis
17:44:41 <dolio> > let andM = foldM (\b ma -> if not b then return False else ma) True in runWriter (andM $ [return False, tell "quux" >> return True] ++ repeat (return False))
17:44:45 <lambdabot>  (
17:45:24 <sjanssen> > let f :: Int -> Int; f x = x `seq` (x+1) in f 0
17:45:25 <lambdabot>  1
17:45:32 <sjanssen> > let f :: Int -> Int; f x = x `seq` f (x+1) in f 0
17:45:39 <lambdabot> Terminated
17:45:51 <sjanssen> ah good, you still use cpu limits
17:46:40 <Baughn> Yep. I just installed a handled for xcpu instead of having a hard limit right away.
17:46:57 <int-e> > let andM = foldr (\a r -> a >>= \x -> if x then r else return False) (return True) in runWriter (andM $ [return False, tell "quux" >> return True] ++ repeat (return False))
17:46:58 <lambdabot>  (False,"")
17:49:37 <int-e> I still like  mapM (>>= guard) -- it's a bit like quantum suicide :)
17:50:30 <int-e> > mapM (>>= guard) (replicate 100 [False, True])
17:50:31 <lambdabot>  [[(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
17:51:00 <int-e> hmm. too many ().
17:51:23 <beikyn> > replicate 2 [Maybe "I saw", Nothing]
17:51:23 <lambdabot>   Not in scope: data constructor `Maybe'
17:51:32 <beikyn> > replicate 2 [Just "say", Nothing]
17:51:33 <lambdabot>  [[Just "say",Nothing],[Just "say",Nothing]]
17:51:37 <int-e> > mapM_ (>>= guard) (replicate 100 [False, True])
17:51:38 <lambdabot>  [()]
17:51:48 <int-e> wrong mapM :)
17:52:04 <byorgey> @type guard
17:52:05 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
17:52:20 <byorgey> > [False, True] >>= guard
17:52:21 <lambdabot>  [()]
17:52:41 * EvilTerran wants to be able to write "if <- (pred :: m Bool) then ..."
17:52:43 <beikyn> > flip take . repeat $ 3 'a'
17:52:44 <lambdabot>   add an instance declaration for (Num (Char -> a))
17:53:05 <Botje> you want if'M!
17:53:09 <EvilTerran> ... yes.
17:53:21 <Botje> I just realised.
17:53:23 <byorgey> EvilTerran: I think there's a proposal floating around somewhere to add (<- foo) syntax
17:53:29 <EvilTerran> byorgey, yeah, there is that
17:53:30 <Botje> haskell is just BEGGING for a Klingon DSL :)
17:53:48 <EvilTerran> which'd make that "if (<- pred) then ..."
17:53:51 <int-e> byorgey: it was a twist on the andM problem :)
17:53:54 <byorgey> exactly.
17:54:11 <EvilTerran> but that has problems wrt specifying where the (<- ...)s lift to, iirc
17:54:43 <EvilTerran> s/lift/float/ or whatever the term is
17:55:02 <EvilTerran> as "the nearest do{} block" is fugly
17:58:22 <Cale> Baughn: That's really cool :)
17:58:25 <Cale> Baughn++
18:07:19 <byorgey> @seen chessguy
18:07:20 <lambdabot> chessguy is in #haskell. I last heard chessguy speak 25m 36s ago.
18:07:27 * chessguy hides
18:07:39 <byorgey> hmm, anyone seen chessguy?
18:08:08 <chessguy> howdy :)
18:08:14 <byorgey> hey there chessguy =)
18:08:26 <dolio> Has anyone seen cheeseguy?
18:08:34 <byorgey> chessguy: what was it you wanted to talk about the other day?
18:08:38 <chessguy> @quote cheese
18:08:38 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
18:08:44 <chessguy> @quote chess
18:08:44 <lambdabot> newsham says: haskell's like chess.  easy to learn. hard to master.
18:08:50 <chessguy> ha
18:08:51 <Botje> @quote phil
18:08:51 <lambdabot> vincenz says: [Philippa] you can catch stuff off someone who's asymptomatic [vincenz] Philippa: only if you allow your body to become assymptotic with his [Binkley] nice typo [vincenz] it's a typo?
18:09:09 <byorgey> what!? Haskell is clearly like Go for those reasons.  ;)
18:09:26 <chessguy> byorgey, haskell is way too interesting to be compared to go
18:09:54 <chessguy> byorgey, anyway, i don't really have any well-defined thoughts, but it seems to me like your partial-knowledge monad would have interesting potential applications in AI. is that where you were kind of going?
18:10:10 <byorgey> chessguy: er, I wasn't really going anywhere in particular =)
18:10:30 <chessguy> ah
18:10:33 <byorgey> but it certainly could, and if it does, I'll bet someone has already done so =)
18:11:11 <chessguy> well, it seems like search which changes the searching function as it goes (which really is what your code wound up doing) could be useful
18:11:50 <byorgey> hmm, that's an interesting way of thinking about it
18:13:52 <byorgey> so, yeah, you could think of it as, instead of searching for one particular solution, you're searching for the best possible solution(s) you can find
18:14:09 <byorgey> where you have some kind of ordering on solutions that isn't a total order
18:14:39 <chessguy> byorgey, you can also think of it as exploring the game tree, adding various facts about it to its base of knowledge
18:15:02 <byorgey> sure
18:15:06 <chessguy> err, s/game tree/search space/
18:15:16 <byorgey> and some facts make other facts obsolete, and so on
18:15:21 <chessguy> my background is in chess AI :)
18:15:27 <chessguy> exactly
18:16:07 <chessguy> here's another idea
18:16:35 <kris`> read a bit of Spivak today. I got some of it. *achievement*
18:16:46 * byorgey high-fives kris` 
18:16:51 <chessguy> what if your Fact datatype were an instance of Arbitrary
18:17:03 <chessguy> you could consider arbitrary facts and see which ones fit and which don't
18:18:06 <byorgey> chessguy: in fact, I made the Fact datatype in my post an instance of Arbitrary, just to test my implementation =)
18:18:25 <chessguy> byorgey, well, it's pretty trivial for your particular one
18:18:33 <chessguy> but that's still cool
18:19:01 <byorgey> I'm not sure I understand what you mean by "see which ones fit and which don't"
18:19:43 <byorgey> chessguy: yeah, for my trivial Fact example, it's very simple:  arbitrary = oneof [fmap Name arbitrary, fmap Age arbitrary]  =)
18:19:44 <chessguy> i imagine generating arbitrary facts, seeing whether or not they match reality, and if so, appending them to the knowledge base
18:20:46 <chessguy> (just as an example)
18:21:03 <byorgey> ok, sure
18:21:25 <chessguy> you probably wouldn't want that as your _only_ method of search, but it could add some liveliness :)
18:21:42 <byorgey> sure =)
18:22:40 <chessguy> i don't know, lots of interesting possibilities
18:25:47 <chessguy> byorgey, by the way, i just noticed you're in the DC area...whereabouts?
18:26:13 <byorgey> chessguy: in DC itself, on capitol hill
18:26:21 <byorgey> near Eastern Market if you know where that is
18:26:33 <TomMD> He is a rep of the state of Lleksah
18:26:36 <chessguy> aha. i live in Reston...everyone here seems abelian
18:27:03 <byorgey> chessguy: ah, cool.  hehe.
18:27:18 <byorgey> I'm naileba
18:27:32 <byorgey> I work in New Carrollton =)
18:28:08 <chessguy> what? you commute out of DC? that's got to be nuts
18:28:48 <TomMD> I would think that better than driving into DC
18:29:05 <chessguy> yeah, but cost of living in DC is horrible
18:29:17 <chessguy> if you don't work there....why would you live there?
18:29:22 <byorgey> chessguy: not at all.  there are approximately zero people on the metro going my direction.
18:29:36 <chessguy> oh i'm sure the commute itself isn't bad
18:29:44 <byorgey> chessguy: the cost of living is pretty high.  but we really love our neighborhood
18:29:53 <byorgey> we don't own a car, everything we need is in walking distance
18:30:03 <chessguy> aha
18:30:03 <OceanSpray> if values have types, and types have kinds, then kinds have -?
18:30:03 <byorgey> we see people we know all the time
18:30:05 <byorgey> it's great =)
18:30:13 <lispy> OceanSpray: sorts?
18:30:13 <chessguy> interesting...
18:30:14 <adu> byorgey!
18:30:16 <byorgey> OceanSpray: sorts  =)
18:30:21 <byorgey> hey adu!
18:30:21 <OceanSpray> seriously?
18:30:28 <chessguy> what kind of work do you do, if i may ask?
18:30:28 <Adamant> thingies
18:30:29 <byorgey> OceanSpray: well, I don't know how standard that is
18:30:56 <OceanSpray> what, then, do sorts have?
18:31:00 <TomMD> Seems like all the DC folks are getting online right now.
18:31:01 <OceanSpray> it's got to end somewhere.
18:31:13 <byorgey> OceanSpray: that's what Tim Sheard calls them when writing about Omega (which has an infinite user-definable heirarchy of types, kinds, sorts, etc....)
18:31:20 <monochrom> You now understand why particle physicists talk of colour, charm, strangeness...
18:31:25 <Adamant> you just develop a type-x system
18:31:31 <Adamant> where x is the type level
18:31:42 <Adamant> I think someone's suggested it on here before
18:31:53 <byorgey> chessguy: I'm a software developer, with Java mostly.  But I'll be starting a PhD in the fall.
18:32:49 <chessguy> byorgey, ah, nice. i work for a web development company. we have our own web application framework written in Java
18:33:13 <byorgey> OceanSpray: I think after sorts, there's not much need to have special names.  so you can just say "third-order kind" or something like that =)
18:33:18 <chessguy> lets you write applications purely in javascript, via Rhino
18:33:24 <byorgey> chessguy: ah, cool
18:33:28 <chessguy> good stuff
18:34:36 <adu> I just realized what would help  bridge Python and Haskell ..... making a Haskell binding to Python.h
18:34:37 <chessguy> at least JS is functional, even if it's not strongly-typed
18:35:21 <kris`> what makes it notably functional?
18:35:44 <chessguy> kris`, having functions as first-class objects
18:36:11 <adu> well it definitely has lambdas
18:36:27 <adu> function (x, y) { ... }
18:37:12 <OceanSpray> infinite-order type system, eh?
18:37:18 <kris`> chessguy: sorry, i thought you were comparing it to something, like "at least javascript is functional unlike x"
18:37:20 <OceanSpray> are there any languages with that?
18:37:27 <chessguy> kris`, oh, haha
18:37:29 <OceanSpray> and what use would it be?
18:37:30 <monochrom> Coq does that, unlimited levels of types.
18:37:42 <kris`> cool?
18:37:44 <monochrom> paradox-free type system.
18:38:00 <EvilTerran> ... ours isn't?
18:38:11 <monochrom> No "this sentence is false" pun.
18:38:37 <monochrom> ours isn't, thanks to type, kind, sort, ...
18:38:43 <TomMD> > let 0 = 1 in 0
18:38:46 <lambdabot>  0
18:39:04 <TomMD> It doesn't complain?
18:39:28 <lispy> > let 1 + 1 = 7 in 1 + 1
18:39:31 <lambdabot>  7
18:39:32 <monochrom> let bindings are similar to irrefutable (lazy) pattern matching. no checking.
18:39:38 <adu> OceanSpray: what's oo-order?
18:39:47 <EvilTerran> > case 1 of 0 -> 0
18:39:48 <lambdabot>   Non-exhaustive patterns in case
18:39:50 <EvilTerran> > case 1 of ~0 -> 0
18:39:51 <lambdabot>  0
18:40:00 <dolio> data Void ; v :: Void ; v = fix id
18:40:05 <dolio> There's your paradox.
18:40:36 <EvilTerran> dolio, and how does an infinite heirarchy of types, kinds, ... resolve that?
18:40:37 <monochrom> haha
18:40:51 <dolio> It doesn't if you have general recursion.
18:41:12 <lispy> :t fix id :: Int
18:41:14 <lambdabot> Int
18:41:27 * EvilTerran is confused
18:41:39 <dolio> But, for instance, in Coq, you can't prove false.
18:41:48 <lispy> EvilTerran: what is the base value supporting all the applications of 'id' in 'fix id'?
18:41:50 <dolio> At least, I suspect.
18:41:59 <kris`> huh
18:42:19 <dolio> Because Coq doesn't give you general recursion, and has a consistent type theory.
18:42:20 <lispy> EvilTerran: does the bottom-ness of 'fix id' make more sense?
18:42:21 <monochrom> I picked a confusing example.
18:42:41 <EvilTerran> i just got confused by "paradox-free type system"
18:42:46 <EvilTerran> rather than "paradox-free language"
18:42:49 <chessguy> hey TomMD, are you http://blog.moertel.com/pages/about-tom ?
18:42:50 <lambdabot> Title: About Tom Moertel
18:43:01 <TomMD> Nope
18:43:03 <monochrom> Here is a better example. A multi-level type system is a way out of the "the type of all types" dilemma.
18:43:04 <EvilTerran> seeing as general recursion if not particularly a property of the type system
18:43:08 <chessguy> oh, wrong tom
18:43:13 <dolio> Epigram 1 didn't have general recursion (well, it did, but ideally you wouldn't use it), but apparently you could still prove false, because * : *.
18:44:30 <lispy> Proving false is something you should not do on a first date, BTW
18:44:52 <monochrom> You know the "the set of all sets" problem. The solution is, "oh, when you gather all the sets together, you get a class."  Well, there is your second level.
18:45:01 <TomMD> NOW you tell me... could have used that BEFORE the weekend started, lispy.
18:45:30 <monochrom> Then you gather all your classes together, and it should be something new, not a class. There is your third level.
18:45:46 <kris`> values, types, kinds, sorts -- these are all called? types?
18:45:49 <lispy> TomMD: :)
18:46:17 <kris`> sets?
18:46:33 <dolio> I think you can refer to them all as sorts.
18:46:38 <lispy> monochrom: aren't types, kinds and sorts all isomorphic?  (and I'm guessing the isomorphism are really trivial)
18:46:55 <dolio> Or universe.
18:47:27 <monochrom> I don't know. Would it hurt?
18:47:35 <lispy> monochrom: and if what I just asked is true, couldn't you then collapse to just have 2 and then map between them :)
18:47:57 <monochrom> isomorphic does not imply it's valid to collapse.
18:48:29 <lispy> Right, because it wouldn't preserve their semantic differences
18:49:23 <kris`> has anyone seen Colossus: The Forbin Project? the two AIs establish a basis for communication by starting with basic arithmetic and working up. do you think that is realistic? do you think we would attempt that if we ever met an alien race or would we just jab them with weapons?
18:49:49 <chessguy> ...
18:50:00 <kris`> ehem. nevermind.
18:50:09 <monochrom> It is true that most of the time you focus on just two consecutive levels.
18:50:43 <dolio> Seems like jabbing at them with our weapons when they just accomplished the as-far-as-we-know-impossible feat of interstellar travel would be a bad idea.
18:50:51 <jturner_> has anyone had any problems with ghc on 64-bit machines that gives errors like "file format not recognized; treating as linker script"?
18:51:13 <monochrom> But it's also true that sometimes you want to be allowed to pick your natural number n and make a statement across n consecutive levels.
18:52:00 <chessguy> dolio, not to mention pretty pointless
18:54:31 <allbery_b> kris`: that would be #haskell-blah fodder
18:55:07 <monochrom> Our ethernets establish commmunication by starting with basic boolean algebra. It turns out to be quite practical and versatile.
18:55:30 <monochrom> If they started out with basic arithmetic, the possibility is endless.
18:55:57 <kris`> allbery_b: cool, i thought there was an off-topic channel
18:56:04 <lispy> I think communicating with aliens will make unicode obselete :(
18:56:10 <monochrom> They probably could prove the incompleteness theorems by themselves.
18:56:39 <monochrom> Right now they can't because boolean algebra is so bloody decidable.
18:56:50 <chessguy> @remember lispy I think communicating with aliens will make unicode obselete :(
18:56:50 <lambdabot> Okay.
18:57:02 <chessguy> @quote unicode
18:57:03 <lambdabot> lispy says: I think communicating with aliens will make unicode obselete :(
18:57:04 <TomMD> Yay, the toy package ipc-0.0.3 is now uploaded for everyone to ignore.
18:57:20 <lispy> TomMD: what is icp?
18:57:22 <chessguy> TomMD, what's that?
18:57:23 <lispy> er ipc
18:57:34 <lispy> chessguy: I'm here all week ;)
18:57:38 <TomMD> Inter program communication (named datagram sockets)
18:57:55 <lispy> TomMD: like unix sockets?
18:57:57 <TomMD> But it is amazingly basic right now (just a couple lines built ontop of Network.Socket)
18:58:05 <TomMD> Exactly
18:58:05 <monochrom> Unicode already includes Klingon. You can say Unicode 5.0 specifically will be obsolete, but surely they will come up with Unicode 50.0.
18:58:06 <chessguy> oh, THAT ipc
18:58:14 <chessguy> isn't that usuall inter-process communication?
18:58:22 <chessguy> s/ll/lly/
18:58:35 <TomMD> Err, yep, obviously I'm not with it right now
18:59:07 <chessguy> so...out of sheer morbid curiosity, how is it that you're on your third sub release already?
18:59:12 <inimino> http://hpaste.org/7075
18:59:29 <TomMD> I don't really know.  Forgot map, foldr, and append for one.
18:59:57 <inimino> I wrote my first Haskell program
18:59:58 <chessguy> but i mean, this is your first release, right?
19:00:04 <lispy> inimino: congrats!
19:00:19 <inimino> lispy: thanks!
19:00:46 <TomMD> chessguy: No, actually.  My first was 0.0.2 for a reason lost in time.
19:01:01 * chessguy scratches his head and gives up
19:01:02 <inimino> it's a Comet chat server, if anybody wants to try it out it is live (for now...) http://mjclement.com:8888/chat
19:01:11 <chessguy> comet in haskell?
19:01:19 <inimino> works in Firefox only as far as I know
19:01:20 * chessguy takes a second look
19:01:24 <inimino> chessguy: yep
19:02:34 <lispy> what is comet?
19:02:45 <inimino> I'm sure the code could be cleaned up if I really knew what I was doing
19:03:01 <inimino> lispy: it's kind of like Ajax
19:03:14 <chessguy> reverse ajax
19:03:34 <inimino> it's a way of communicating between an HTTP server and a page that's already loaded
19:03:38 <monochrom> > reverse "ajax"
19:03:41 <lambdabot>  "xaja"
19:04:16 <chessguy> inimino, what's the firefox dependency?
19:04:18 <lispy> Oh, so comet is a pun on the cleaner
19:04:54 <OceanSpray> oy, the wikipedia articles aren't helpful.
19:05:04 <OceanSpray> what's the deal with the set of all sets paradox?
19:05:05 <chessguy> comet is relatively new
19:05:06 <inimino> chessguy: that's all I tested it in, and my JavaScript was written without other browsers in mind
19:05:26 <chessguy> inimino, let me take a look in IE8
19:05:28 <chessguy> uh
19:05:29 <chessguy> IE7
19:05:36 <monochrom> If there is a set such that every set is a member of it, you run into contradictions.
19:05:41 <chessguy> i'm sure i have it here somewhere....
19:05:49 <inimino> chessguy: ok
19:05:52 <EvilTerran> S = { s | s \notelem s }
19:05:56 <EvilTerran> S \elem S ?
19:09:34 <byorgey> > let xs = 1 : zipWith (+) xs (xs >>= replicate 2) in xs   -- a spiffy recurrence!
19:09:35 <lambdabot>  [1,2,3,5,7,10,13,18,23,30,37,47,57,70,83,101,119,142,165,195,225,262,299,346...
19:09:43 <EvilTerran> in haskell terms, s is over values and S is a type; or s is over types and S is a kind...
19:09:46 <byorgey> @oeis 1 2 3 5 7 10
19:09:47 <lambdabot> Numbers n such that 6n-1, 6n+1 are twin primes.
19:09:47 <lambdabot> [1,2,3,5,7,10,12,17,18,23,25,30,32,33,38,40,45,47,52,58,70,72,77,87,95,100,10...
19:09:56 <byorgey> @oeis 1 2 3 5 7 10 13
19:09:57 <lambdabot> a(n) = a(n-1) + a([n/2]), a(1) = 1.
19:09:57 <lambdabot> [1,2,3,5,7,10,13,18,23,30,37,47,57,70,83,101,119,142,165,195,225,262,299,346,...
19:10:17 <byorgey> bingo!
19:10:38 <inimino> any comments on how my Haskell could be make shorter, neater, more idiomatic, etc?
19:10:40 <inimino> http://hpaste.org/7075
19:12:01 <EvilTerran> @let oeis = var . ("@oeis "++) . unwords . map show
19:12:02 <lambdabot> <local>:5:42:     Ambiguous type variable `a' in the constraint:       `Show ...
19:12:24 <EvilTerran> @let oeis :: Show a => [a] -> Sym b; oeis = var . ("@oeis "++) . unwords . map show
19:12:25 <lambdabot> Defined.
19:12:49 <EvilTerran> @. run run oeis $ let xs = 1 : zipWith (+) xs (xs >>= replicate 2) in xs
19:12:49 <lambdabot>  Parse error at "@oeis" (column 2)
19:13:02 <EvilTerran> @@ @@ @run oeis $ let xs = 1 : zipWith (+) xs (xs >>= replicate 2) in xs
19:13:03 <lambdabot> Plugin `compose' failed with: Prelude.(!!): index too large
19:13:07 <EvilTerran> le bla
19:13:10 <eugman> Besides "all about monads" anyone know anything that covers use of State/reader/writer? most of the stuff i'm finding just talks about maybe and IO monads
19:13:41 <EvilTerran> @@ @run oeis $ let xs = 1 : zipWith (+) xs (xs >>= replicate 2) in xs
19:13:42 <lambdabot>  @oeis 1 2 3 5 7 10 13 18 23 30 37 47 57 70 83 101 119 142 165 195 225 262 29...
19:13:51 <EvilTerran> @undef
19:13:52 <lambdabot> Undefined.
19:14:09 <EvilTerran> @let oeis :: Show a => [a] -> Sym b; oeis = var . ("@oeis "++) . unwords . take 10 . map show
19:14:10 <lambdabot> Defined.
19:14:13 <EvilTerran> @@ @@ @run oeis $ let xs = 1 : zipWith (+) xs (xs >>= replicate 2) in xs
19:14:14 <lambdabot>  a(n) = a(n-1) + a([n/2]), a(1) = 1.
19:14:14 <lambdabot>  [1,2,3,5,7,10,13,18,23,30,37,47,57,70,83,101,119,142,165,195,225,262,299,346,...
19:14:20 <EvilTerran> huzzah
19:15:03 <EvilTerran> @go you could have invented monads
19:15:04 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
19:15:04 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
19:15:06 <EvilTerran> eugman, ^
19:15:47 <byorgey> inimino: looks pretty good to me!
19:16:08 <EvilTerran> eugman, that introduces writer, list, and random (which is very similar to state)
19:16:52 <inimino> thanks, byorgey!
19:17:13 <dolio> inimino: 'return . htmlResp =<< readFile "info.html"' = 'liftM htmlResp $ readFile "info.html"' if you care.
19:17:22 <eugman> thanks, I keep thinking I understand things and then I get to some point where I see a big page of code and my head just explodes
19:17:42 <EvilTerran> ?type last
19:17:43 <lambdabot> forall a. [a] -> a
19:17:47 <inimino> ah... thanks dolio
19:17:53 <inimino> I do care...
19:17:57 <saml> > last [1..]
19:18:00 <lambdabot>  Terminated
19:18:18 <saml> > last [1..] :: [Int]
19:18:18 <lambdabot>   add an instance declaration for (Num [Int])
19:18:18 <lambdabot>     In the expression: 1
19:18:23 <dolio> Actually, I suppose it might be better to do 'htmlResp `liftM` readFile "info.html"'
19:18:25 <Cale> > [1,2,last [1..]]
19:18:29 <lambdabot>  [1,2,
19:18:39 <EvilTerran> inimino, Control.Applicative may interest you
19:18:44 <EvilTerran> Cale, hey, that's new
19:18:51 <Cale> Yeah, Baughn added it :)
19:18:56 <EvilTerran> Baughn++
19:19:04 <inimino> dolio: ok, that looks much nicer
19:19:07 <dolio> > [1,2,undefined]
19:19:08 <lambdabot>  Undefined
19:19:29 <EvilTerran> ... only works for Terminateds, not errors?
19:19:37 <EvilTerran> Baughn -= 0.5
19:19:57 <inimino> EvilTerran: I'll look at that
19:20:20 <saml> > [(maxBound :: Int) .. ]
19:20:21 <lambdabot>  [2147483647]
19:20:28 <EvilTerran> inimino, specifically, newConversation = Conversation <$> newTVar [] <*> newTVar [] <*> newTVar M.empty
19:20:51 <Cale> > 1 : undefined
19:20:51 <lambdabot>  Undefined
19:20:54 <EvilTerran> (<$>) = fmap, and, for Monads, (<*>) = ap
19:20:54 <Cale> mm..
19:21:10 <byorgey> what monad is that in? IO?
19:21:25 <byorgey> @type newTVar
19:21:26 <lambdabot> Not in scope: `newTVar'
19:21:27 <EvilTerran> TVar is STM, isn't it?
19:21:31 <EvilTerran> ?hoogle TVar
19:21:32 <byorgey> oh, duh
19:21:33 <lambdabot> Control.Concurrent.STM.TVar :: module
19:21:33 <lambdabot> GHC.Conc.TVar :: data TVar a
19:21:33 <lambdabot> GHC.Conc.newTVar :: a -> STM (TVar a)
19:21:36 <byorgey> of course =)
19:21:39 <EvilTerran> :)
19:21:42 <byorgey> is there an Applicative instance for STM?
19:21:55 <EvilTerran> ?instances-importing Control.Applicative Control.STM Applicative
19:21:56 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
19:22:24 <EvilTerran> ?instances-importing Control.Applicative Control.Concurrent.STM Applicative
19:22:25 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
19:22:28 <EvilTerran> what
19:22:47 <inimino> EvilTerran: ah...
19:22:53 <inimino> EvilTerran: yeah, it's STM
19:23:28 <byorgey> there might not already be an Applicative instance for STM, but you can declare one yourself
19:23:42 <byorgey> instance Applicative STM where pure = return ; (<*>) = ap
19:23:45 <byorgey> works for any Monad
19:24:07 <EvilTerran> indeed
19:24:38 <EvilTerran> ... there isn't one already
19:25:13 <inimino> ok, what's the difference between using that vs. `ap`?
19:25:42 <EvilTerran> Applicative is, in spirit, a superclass of Monad
19:26:12 <inimino> oh
19:26:19 <EvilTerran> just like any Monad can be made into a Functor with fmap = liftm, any Monad can be made into an Applicative with pure = return; (<*>) = ap
19:26:54 <EvilTerran> and every Applicative is already a Functor, as enforced by the class definition
19:27:30 <EvilTerran> but there are things you can do in Monads that you can't do in Applicatives, just like there are things you can do in Applicatives that you can't do in Functors
19:28:19 <adiM> @pl two a = zip (init a) (tail a)
19:28:19 <lambdabot> two = liftM2 zip init tail
19:28:24 <inimino> hm, ok
19:28:26 <EvilTerran> it's fairly common for something that you would use Monad for to be expressible using only Applicative
19:28:56 <EvilTerran> for instance, liftM{n} f x1 ... xN can be expressed as f <$> x1 <*> ... <*> xN
19:29:33 <inimino> ok
19:29:42 <inimino> which would then be more general
19:29:49 <EvilTerran> exactly! :)
19:29:58 <inimino> cool
19:30:19 <mauke> @src liftA2
19:30:20 <lambdabot> liftA2 f a b = f <$> a <*> b
19:30:22 <EvilTerran> ?type liftA2 (uncurry snd)
19:30:23 <lambdabot> forall a b b1 c (f :: * -> *). (Applicative f) => f ((a, b -> b1 -> c), b) -> f b1 -> f c
19:30:27 <EvilTerran> whups
19:30:31 <EvilTerran> ?type (*>)
19:30:32 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
19:30:34 <EvilTerran> ?type (>>)
19:30:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
19:30:39 <EvilTerran> is another example
19:31:11 <inimino> ah
19:31:34 <EvilTerran> but note you can't define (>>=) in terms of Applicative
19:32:23 <EvilTerran> category-theory wise, Applicative = applicative functor, and Monad = monoidal(?) applicative functor
19:33:38 <inimino> ok, thanks, I think I'll read that paper
19:33:55 <EvilTerran> have fun!
19:34:42 <inimino> :)
19:34:50 <EvilTerran> =]
19:35:18 <dolio> Applicative functor isn't a category theory term.
19:35:32 <dolio> The category theory term is something like 'strong lax monoidal functor'.
19:36:48 <allbery_b> IIRC that is the term mentioned in the applicative functors paper
19:37:37 * byorgey still doesn't understand how anything can be strong and lax at the same time =)
19:38:01 <allbery_b> different axes, if you will
19:38:22 <inimino> heh
19:38:24 <byorgey> I figured it was something like that, but it still sounds funny =)
19:39:20 <byorgey> like it should be an arrow in the category of large small open closed categories
19:42:01 <adu> large small open closed categories?
19:42:21 <adu> is that like a convex concave circle-square?
19:44:51 <SamB> okay, poll:
19:45:13 <SamB> who thinks :b should mean :browse? who likes it meaning :break?
19:46:45 <byorgey> adu: right, you've got it!
19:46:58 <adu> :)
19:47:20 <SamB> direct answers to http://hackage.haskell.org/trac/ghc/ticket/2142
19:47:21 <byorgey> adu: convex concave circle-squares are actually fixed points under the isometries induced by the action of large small open closed categories on R^2  ;)
19:47:23 <lambdabot> Title: #2142 (:b doesn't invoke :browse, or even generate an ambiguous command error) - ...
19:47:24 <koninkje> SamB: I much brefer it meaning :browse
19:47:46 <koninkje> er, prefer
19:47:48 <adu> byorgey: do you mean the sqrt(R^2)?
19:47:58 <SamB> koninkje: as do I, but Igloo doesn't seem to be too sure ;-)
19:48:03 <byorgey> hehe
19:48:32 <adu> byorgey: i didn't know you were into math
19:48:47 <adu> byorgey: if I had known i would have pointed you to my website
19:48:53 <koninkje> SamB: The really annoying thing is that you have to type even more than two chars to distinguish them
19:48:58 <byorgey> adu: well, it's not too late! =)
19:49:06 <adu> byorgey: http://tetration.itgo.com/
19:49:07 <lambdabot> Title: Home of Tetration
19:49:10 <scook0> can't you just :def b const (return ":browse")?
19:49:19 <SamB> scook0: no
19:49:28 <SamB> not *quite*
19:49:43 <SamB> and you could, but good defaults are important
19:50:07 <sw17ch> is there an equivalent to the behavior of C++'s cin?
19:50:17 <sw17ch> read a white-space separated value from standard input?
19:50:18 <adu> sw17ch: stdin?
19:50:19 <gwern> :t xor
19:50:22 <lambdabot> forall a. (Bits a) => a -> a -> a
19:50:42 <gwern> xor is a bit operation? that's not cool
19:50:52 <scook0> :def b \arg -> return (":browse " ++ arg) then, though I see your point about the defaults
19:51:04 <sw17ch> adu, yes
19:51:04 <byorgey> adu: cool! I'll have to take a look around
19:51:06 <adu> sw17ch: that would be "stdin" and "reads"
19:51:19 <sw17ch> huh... /me checks
19:51:25 <SamB> gwern: hmm, too bad ^^ is already taken :-(
19:51:27 <byorgey> gwern: what should it be instead?
19:51:43 <dons> > '\12345'
19:51:46 <lambdabot>  '\12345'
19:52:10 <dolio> That's the combination to my luggage!
19:52:31 <gwern> byorgey: well, I was hoping for an binary operation that would return True iff one arg was True and t'other False and in all other cases False
19:53:00 <byorgey> gwern: that's called (/=)  =)
19:53:05 <byorgey> > True /= False
19:53:06 <lambdabot>  True
19:53:53 <allbery_b> yeh, (/=) is xor in boolean context
19:54:34 <SamB> scook0: so, which do you prefer? please use a complete sentance to state your answer ;-)
19:54:37 <gwern> byorgey: that's not the way I think!
19:54:37 * gwern hadn't realized that
19:55:00 <allbery_b> gwern: I have this suspicion that everyone has to discover that
19:55:11 * scook0 still has 6.6 installed, and therefore doesn't feel qualified to offer an opinion :)
19:55:26 <gwern> allbery_b: obviously you discovered it obviously, and byorgey
19:55:28 <allbery_b> because I not only had the same revelation, I've watched many others have it
19:55:41 <SamB> aww
19:55:55 <SamB> I don't get too much out of the GHCi debugger, honestly
19:55:57 <byorgey> yeah, I remember having that revelation, I don't remember exactly when it was though =)
19:56:06 <allbery_b> it's an interesting blind spot in people's systems of logic
19:56:26 <SamB> it hasn't helped me much with JHC, and 6.9 keeps crashing...
19:56:54 <byorgey> and xnor is (==) of course =)
19:57:08 <SamB> nxor, I say!
19:57:21 <dolio> @yow!
19:57:22 <lambdabot> Look into my eyes and try to forget that you have a Macy's charge card!
19:57:29 <scook0> the fact that (/=) is xor feels like a coincidence, rather than something that ought to be true
19:57:49 <SamB> how so?
19:57:52 <byorgey> SamB: I guess it should be nxor, shouldn't it... harder to pronounce though =)
19:58:33 <scook0> I dunno ... maybe just the fact that while I'm aware of it, it doesn't seem part of my logical intuition
19:58:40 <byorgey> scook0: I know what you mean, but I think that's just because it's not something one runs across all that often
19:59:03 <byorgey> the more you play with it the more it becomes part of your intuition
19:59:59 <SamB> it holds for 4, with the interpretation (/= 0)
20:00:46 <SamB> or, well, any boolean lattice, I think...
20:01:12 <scook0> I guess it's a bit like how false => X is vacuously true (though I'm used to that one by now)
20:01:14 * gwern curses darcs autotools stuff. I hate all this promicuous state!
20:01:16 <gwern> I mean, how do I tell Cabal that src/hscurl.c needs CPP? this is so annoying
20:01:16 <gwern> SamB: well, if there were three values for logic, I'm not sure XOR would be a simple inequality
20:01:16 <gwern> (and if xor = =\ just because of a specific n=2 for n-valued logics, that seems like a coincidence a bit, I guess)
20:01:18 <gwern> @seen dcoutts
20:01:18 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #ghc and #haskell. I don't know when dcoutts last spoke.
20:01:29 <SamB> gwern: that's not a boolean lattice
20:01:45 * wjt used != on booleans in his uni entrance exam, and only realised its more common name at the very last minute :)
20:02:11 <gwern> gah! just when I needed dcoutts
20:04:32 <SamB> any more opinions on :b?
20:07:49 <dolio> I never use the debugger.
20:07:56 <dolio> But then, I never use :browse, either.
20:09:53 <byorgey> I'd prefer :browse.
20:14:22 <geezusfreeek> gwern: speaking of three values for logic: http://www.trinary.cc/Tutorial/Tutorial.htm
20:14:23 <lambdabot> Title: Tutorial
20:14:25 <geezusfreeek> ;)
20:14:39 * byorgey idly wonders what happened to oerjan
20:14:59 <gwern> byorgey: he was eaten by a grue. it's now night where he is
20:15:14 <byorgey> a grue!  oh noes!
20:18:09 <lament> "inequality" doesn't generalize to multiple arguments, while XOR should.
20:19:11 <dolio> For booleans?
20:19:14 <lament> yes
20:19:26 <dolio> xor for more than two would be guaranteed to be false, wouldn't it?
20:19:34 <SamB> > foldr (/=) False [True,False,True]
20:19:35 <lambdabot>  False
20:19:39 <lament> and and or readily generalize to multiple arguments, and xor can be expressed as those
20:19:42 <SamB> > foldr (/=) False [True,False,True,True]
20:19:43 <lambdabot>  True
20:19:49 <SamB> dolio: you never took logic design, did you?
20:20:38 <byorgey> dolio: it depends how you interpret extending xor to more than two arguments.
20:20:45 <lament> xor args = (or args) and not (and args)
20:21:05 <byorgey> dolio: if you take it to mean 'zero if any of the arguments are the same and one if they are all different' then of course you will get all zeros.
20:21:07 <lament> so, some values are true but not all values are true
20:21:24 <byorgey> much more sane would be to take the output to be the parity of the sum of the inputs
20:21:33 <lament> byorgey: true.
20:21:59 <dolio> Ah, yeah.
20:22:12 <lament> but i still like my def-n more :)
20:22:29 <byorgey> lament's definition makes sense too.
20:22:42 <lament> another possible definition is that "exactly one argument is true"
20:22:56 <lament> the "common-sense" or
20:23:08 <lament> the common-sense or is actually xor, and it works for multiple arguments as well as for two
20:23:23 <SamB> lament: eh?
20:23:25 <byorgey> ah, interesting interpretation
20:23:27 <lament> "i either go shopping, or read about monads" - xor
20:23:30 <SamB> you have a strange interpretation of xor
20:23:37 <lament> "i either go shopping, read about monads, or go kill myself" - xor
20:23:42 <lament> not really
20:24:00 <SamB> that isn't the one signified by the logic symbol!
20:24:08 <lament> sure it is
20:24:14 <lament> it's called "exclusive or"
20:24:25 <lament> that's exactly what the "common-sense or" does
20:25:28 <byorgey> agreed.  although there isn't really a standard interpretation of xor of more than two arguments, I don't think
20:27:14 <SamB> @go three-input xor
20:27:18 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
20:27:43 <SamB> http://www.shef.ac.uk/physics/teaching/phy107/othergates.html
20:27:44 <lambdabot> Title: PHY107 Other Logic Gates
20:28:50 * dolio should get some sleep.
20:29:05 <byorgey> yeah, if there's a standard interpretation it's probably  foldr xor 0, i.e. the 'parity' interpretation I mentioned above.
20:30:01 <SamB> that's the one given in MY textbook, certainly
20:32:02 <byorgey> interesting, it's easy for me to see what foldr xor 0 does, but I'd have to squint at foldr (/=) False for a while, if it wasn't for this conversation...
20:32:18 <byorgey> even though I "knew" that xor == (/=)
20:34:09 <SamB> hmm, the logic is basically that XOR generates the modulo-2 sum of it's inputs
20:34:38 <byorgey> @check \xs -> foldr (/=) False == odd (length $ filter id xs)
20:34:39 <lambdabot>  Couldn't match expected type `[Bool] -> Bool'
20:34:48 <byorgey> @check \xs -> foldr (/=) False xs == odd (length $ filter id xs)
20:34:48 <lambdabot>  OK, passed 500 tests.
20:35:10 <byorgey> SamB: right.
20:44:14 <gwern> I'm curious, has anyone else played aroud with darcswatch?
20:44:58 <SamB> I think John Meacham will soon
20:45:47 <gwern> hum
20:47:45 <bos> @src maybe
20:47:45 <lambdabot> maybe n _ Nothing  = n
20:47:45 <lambdabot> maybe _ f (Just x) = f x
20:48:43 <chessguy> hm. n isn't the best name there
20:48:49 <xif> what's the best Haskell reference?
20:49:00 <chessguy> xif, that's such a vague question
20:49:32 <xif> chessguy: what additional parameters would allow you to answer?
20:49:43 <Aduros> xif: haskell.org/hoogle
20:50:06 <chessguy> xif, a function from reference to quality
20:50:21 <xif> Aduros: awesome
20:50:39 <xif> thanks.
20:50:51 <Aduros> No prob ;)
20:58:19 <SamB> xif: chessguy wishes to know what you seek to maximize ;-P
20:59:07 <xif> SamB: if I had a function from anything to quality, I'd publish it in most major philosophical magazines :)
20:59:30 <xif> mostly, I'm looking for something where I can easily find the definition for keywords and such.
20:59:53 <xif> and builtin functions, and syntax constructs (thought the later is naturally harder to find)
21:00:47 <xif> for example, I want to know what the `where` keywords stands for, and get examples of where and how it is to be used.
21:00:50 <SamB> you mean Prelude functions?
21:01:00 <SamB> @google haskell report
21:01:02 <lambdabot> http://www.haskell.org/onlinereport/
21:01:02 <lambdabot> Title: The Haskell 98 Language Report
21:01:06 <SamB> xif: how about that?
21:01:23 <SamB> that tells, well, not quite all...
21:01:25 <SamB> but most!
21:01:36 <SamB> @hoogle GHC extensions
21:01:37 <lambdabot> Did you mean: GHC Extensions
21:01:39 <SamB> @google GHC extensions
21:01:40 <lambdabot> http://www.haskell.org/haskellwiki/GHC
21:01:40 <lambdabot> Title: GHC - HaskellWiki
21:01:44 <SamB> hmm
21:02:39 <SamB> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html
21:02:40 <lambdabot> Title: Chapter 8. GHC Language Features, http://tinyurl.com/kf2g3
21:04:15 <xif> SamB: actually, Hoogle found the definition for "where" in a second.
21:04:29 <xif> http://www.haskell.org/haskellwiki/Keywords#where
21:04:30 <lambdabot> Title: Keywords - HaskellWiki
21:05:07 <xif> the only thing I'm missing right now is some more depth where I want it.
21:08:56 <gwern> heh. yeah, ndm had to add support for 'where' searches when he looked at the states and discovered it was one of the top searches
21:09:39 <gwern> *stats
21:28:32 <mofmo1> so, i have a variable y :: Int
21:28:54 <mofmo1> in the expression "y >= (length st)/div" where div is also an int
21:29:08 <mofmo1> apparently / doesnt just spit out an int even if both sides are ints
21:29:16 <mofmo1> causing much pain and hurt
21:29:39 <ivanm> mofmo1: what are you trying to do?
21:29:51 <mofmo1> i want to see if a certain number is above a certain bound
21:30:06 <ivanm> max?
21:30:20 <ivanm> >=, <=, etc.?
21:30:25 <mofmo1> no, above a certain number divided another number
21:30:41 <ivanm> ummm..... div is integer division (rounded down)
21:30:47 <mofmo1> i have y >= (length someList)/div
21:30:48 <mofmo1> i uh
21:30:51 <mofmo1> redefined div
21:30:59 <mofmo1> but alright ill change the variable name
21:31:59 <ivanm> > 9 `div` 2
21:32:00 <lambdabot>  4
21:33:55 <zgold> @src init
21:33:55 <lambdabot> init [x]    = []
21:33:55 <lambdabot> init (x:xs) = x : init xs
21:33:55 <lambdabot> init []     = undefined
21:34:11 <zgold> Gotta love those O(n) simple operations
21:34:34 <ivanm> wouldn't that be O(1) ?
21:34:40 <bos> is there a standard Monad instance for (Either left)?
21:34:42 <zgold> to make a new list?
21:34:43 <ivanm> wait, I take it back
21:34:49 <ivanm> zgold: I misread it ;-)
21:34:51 <bos> my memory fails me.
21:34:55 <zgold> well, i guess it depends how many items your reading from the new list
21:35:02 <ivanm> @instances Either
21:35:04 <lambdabot> Couldn't find class `Either'. Try @instances-importing
21:35:19 <bos> @instances-importing Data.Either Either
21:35:19 <lambdabot> Couldn't find class `Either'. Try @instances-importing
21:35:22 <bos> bah.
21:35:47 <bos> ah, Control.Monad.Error
21:45:04 <bos> @seen dons
21:45:04 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc and #haskell. I last heard dons speak 1h 50m 9s ago.
22:31:16 <bos> @hoogle filterM
22:31:17 <lambdabot> Control.Monad.filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
22:36:48 <halberd> is the set of all strings including newlines as line breaks, where every letter a is vertically adjacent to another letter a, a context free grammar?
22:37:59 <OceanSpray> Coq is a proof thingie, but is it a programming language?
22:38:52 <Jedai> OceanSpray: Yeah, it is (it lacks some things to do practical program though)
22:38:59 <halberd> or in general can context free grammars be used to parse 2 dimensional syntax?
22:39:40 <mofmo1> if i put i do y = if labalbhalbhalb in a let expression
22:39:47 <mofmo1> how would i use the value of y inside the let?
22:39:54 <OceanSpray> halberd, since it is trivial to count the number of characters after a newline, I'd think so.
22:40:07 <halberd> well it is trivial but is it context free?
22:40:19 <mofmo1> essentially like a let-rec ? if i do it, i get a not in scope error. I think this is some sort of laziness issue
22:40:28 <OceanSpray> why would you need a context?
22:40:33 <Jedai> halberd: Depends on the syntax but some are (Haskell-like is from what I see)
22:41:01 <Jedai> mofmo1: All bindings are recursive in Haskell
22:41:27 <Jedai> mofmo1: You can write : let y = 1:y in y
22:41:34 <Jedai> > let y = 1 : y in y
22:41:37 <mofmo1> well yeah
22:41:43 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
22:41:47 <mofmo1> but i have
22:41:58 <halberd> well for example, "baabbb\nbaab" would be in the grammar but "baabbb\naaab" would not
22:42:10 <halberd> er, in the language
22:42:10 <mofmo1> let y = if exp then blah else blah *newline* x = y+ 4
22:42:12 <mofmo1> for example
22:42:40 <Jedai> mofmo1: And ? All bindings in a let are mutually recursive
22:43:06 <mofmo1> hmm
22:43:11 <mofmo1> then why am i getting this error
22:43:19 <Jedai> Show us the code
22:43:25 <Jedai> @where hpaste
22:43:25 <lambdabot> I know nothing about hpaste.
22:43:55 <Jedai> http://hpaste.org/
22:44:02 <mofmo1> http://hpaste.org/7076
22:44:06 <Jedai> @where+ hpaste http://hpaste.org/
22:44:07 <lambdabot> It is forever etched in my memory.
22:45:31 <Jedai> You have a in the where and in the let...
22:45:38 <mofmo1> oh right
22:46:29 <mofmo1> i'm still not used to not having ()s
22:46:31 <Jedai> Besides your layout is pretty weird (well that's a question of personal taste but... the else at the end of a line like that I'd never seen)
22:47:48 <mofmo1> i'm used to having ()'s and if taking three arguments
22:48:25 <Jedai> You're trying to get a lisp-like feeling then ? Ok, but what's really dangerous (and bited you here) is the where at the end of a line
22:48:40 <mofmo1> i just deleted it
22:48:41 <mofmo1> it works
22:48:52 <mofmo1> i also reformated my if statements
22:48:58 <Jedai> All studies shows we tend to put more of a weight on the beginning of lines and ignore the ending
22:50:00 <adu> Jedai: hm
22:50:11 <Jedai> mofmo1: If you like your if statements like that, why not (you could also just define yourself a if' function), but put the where another place
22:50:46 <adu> Fascinating! that is something that is not fascinating
22:50:59 <adu> lol
22:56:14 <OceanSpray> does anyone have a good introduction to the concept of dependent typing?
23:09:24 <adu> OceanSpray: ya!
23:09:32 <ello> OceanSpray, http://www.cs.nott.ac.uk/~txa/publ/ydtm.pdf
23:09:41 <adu> [Integer, String, Char] :: Type
23:09:55 <adu> er I meant [Type]
23:11:20 <adu> but I think that just that one line "[Integer, String] :: [Type]" is enough to introduce Haskell'ers to dependent typing
23:25:08 <halberd> how about this: is the language over the alphabet {A, B, C, \n} where every C must be enclosed in 2 dimensions within a B, context-free?
23:27:42 <halberd> here is an example of a string in this language:
23:27:43 <halberd> http://paste.lisp.org/display/59389
23:28:43 <halberd> to be precise, if you trace vertically and horizontally from any C, you must hit a B before you hit an A or the edge in order for the string to be in the language
23:33:58 <OceanSpray> halberd, how about you just try to write a grammar and see for yourself?
23:34:39 <halberd> because I don't think 2 dimensional grammars are context-free
23:35:10 <halberd> at least, not ones of this nature
23:35:50 <OceanSpray> prove it.
23:36:27 <halberd> I know that I can't prove it with the pumping lemma for context free languages, since some 2-d grammars that I'm thinking about satisfy that
23:37:06 <halberd> this one, for example, pumps quite well because if you simply duplicate any horizontal row, you get something that is still in the language
23:37:44 <halberd> but the pumping lemma is not a biconditional
23:38:25 <halberd> so there may be some other way to prove the language is not regular, however the pumping lemma was the only tool I had
23:39:51 <arussel> I am trying to install yi, I installed  cabal1.2.3, cd into yi, did: runhaskell Setup.hs configure
23:40:36 <arussel> I got the following result: http://pastebin.com/m326cac52
23:41:08 <arussel> I am a bit sceptical about the needed cabal version
23:41:45 <arussel> and is there a way to: "cabal install regex-compat" ?
23:45:07 <halberd> Is the set of all matrices whose rows are strings in context free languages and whose columns are also strings in context free languages, themselves context free languages?
