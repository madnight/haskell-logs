00:00:05 <Cale> Want to try writing it?
00:00:21 <Trinithis> i remember seeing it a while ago. sure ill try
00:01:24 <Trinithis> join m = \x y -> m x x y
00:02:52 <Cale> hmm, that's almost right
00:03:05 <Trinithis> join m = \x -> m x x
00:03:10 <Cale> yeah
00:03:14 <geezusfreeek> i love/hate it when i end up writing tons of code without testing it at all because i am pretty sure the type system will catch most of the errors i could make
00:03:38 <geezusfreeek> it mostly sucks because i'm not sure whether i understand my code when i rely on that
00:03:44 <Cale> Or of course
00:03:50 <geezusfreeek> it's like "why did that compile?"
00:03:51 <Cale> join m x = m x x
00:04:06 <Trinithis> right
00:04:41 <Trinithis> :t (>>>)
00:04:42 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
00:04:47 <Cale> fmap is fun :)
00:04:53 <Trinithis> oh dear!
00:05:02 <Cale> fmap :: (Functor f) => (a -> b) -> f a -> f b
00:05:10 <Cale> in our case, the f is (e ->)
00:05:21 <Cale> So  fmap :: (a -> b) -> (e -> a) -> (e -> b)
00:05:30 <Cale> Which is something recognisable :)
00:05:43 <Trinithis> fmap m f = f
00:06:07 <Cale> er...
00:06:14 <Trinithis> wrong order
00:06:19 <dons> http://reddit.com/info/6fe03/comments/ wadler's written a functional pearl
00:06:23 <dons> on arrows
00:06:28 <Trinithis> fmap f m (what i meant)
00:06:49 <Cale> Trinithis: it's not just f again though...
00:07:21 <Trinithis> so its . ?
00:07:25 <Cale> yeah :)
00:07:34 <Cale> It's function composition :)
00:07:42 <Cale> fmap f m = f . m
00:07:55 <Trinithis> point free!!!
00:08:39 <Cale> Now, wouldn't it be nice if we went the other way from here and redefined (.) to be fmap in general? :)
00:08:51 <Trinithis> haha
00:08:54 <Cale> (and I've actually done this in lambdabot)
00:09:20 <Trinithis> i'm guessing its use hasnt cause confusion?
00:09:26 <Trinithis> (to the programmer)
00:09:44 <Cale> Not *too* much confusion. We have to explain it to beginners using the bot from time to time.
00:09:53 <Cale> Once you understand it, it's quite a sane notation.
00:10:04 <awesame> like to me, roughly yesterday
00:10:09 <Cale> Especially so because fmap is required to satisfy a couple of laws
00:10:17 <Cale> one of which is:
00:10:22 <Cale> fmap (f . g) = fmap f . fmap g
00:10:29 <Trinithis> :D
00:10:33 <Cale> If we add the point to this:
00:10:40 <Cale> fmap (f . g) x = fmap f (fmap g x)
00:10:52 <Cale> and then convert the notation, so that fmap and (.) are the same thing :)
00:11:00 <Cale> (f . g) . x = f . (g . x)
00:11:09 <Cale> This is an associative law!
00:11:18 <Trinithis> and easy to read
00:11:23 <hpaste>  wadcom pasted "newbie questions: 1) returning 3 possible values 2) dealing with exceptions" at http://hpaste.org/6935
00:12:12 <Trinithis> is there more I should know about (e->) ?
00:12:34 <Cale> Trinithis: might be good to look at the definition of bind and some more of the Control.Monad stuff -- sequence is fun too :)
00:12:55 <Cale> (>>=) :: m a -> (a -> m b) -> m b
00:13:07 <lament> yay, hpaste is back!
00:13:08 <Trinithis> sequence is like the functional equiv to forEach in found in some languages?
00:13:41 <Cale> Trinithis: well, forM is more like that
00:13:50 <Cale> But forM is built from sequence and map
00:14:11 <Cale> (also mapM, which is the same thing as forM but has its parameters flipped)
00:14:23 <Trinithis> > sequence $ map putStrLn ["a", "b"]
00:14:24 <lambdabot>  <IO [()]>
00:14:32 <Cale> sequence :: (Monad m) => [m a] -> m [a]
00:15:02 <Cale> So it takes a list of actions to be performed, and turns them into a single action which does each of them in turn, producing a list of results.
00:15:05 <lament> Trinithis: lambdabot does not execute IO actions.
00:15:11 <Trinithis> ok
00:15:28 <Cale> sequence [] = return []
00:15:40 <wadcom> http://hpaste.org/6935, anyone, please? :-)
00:15:41 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
00:16:07 <Cale> wadcom: Since it's in IO already, you might just re-throw any other error.
00:16:39 <Cale> wadcom: If that's not so great, then the type you have looks okay.
00:16:55 <wadcom> cale: I got totally confused by differences between IOError vs IOException, etc...
00:17:05 <Cale> wadcom: yes, it's confusing
00:17:35 <Cale> wadcom: Haskell 98 defines a bare-bones exception system, and GHC has a more full-featured one in Control.Exception
00:17:37 <wadcom> cale, so, keeping the type as it is, how should I make it compile?
00:18:06 <Cale> Well,  ioErrors :: Exception -> Maybe IOError
00:18:39 <Cale> wadcom: I think that just only handling the one error you want to handle is probably nicest though.
00:19:26 <Trinithis> Cale: <3 Thanks very much. it's getting late here, but i'll probably be on tomorrow night
00:19:34 <Cale> Well, regardless, you'll want to do  handleJust ioErrors, in place of handle
00:19:45 <Cale> Trinithis: great, see you around!
00:19:59 <Cale> (It's very late here, but my hours are a bit screwy.)
00:20:22 <Cale> handleJust :: (Exception -> Maybe b) -> (b -> IO a) -> IO a -> IO a
00:20:24 <wadcom> cale: ok
00:20:28 <Cale> ioErrors :: Exception -> Maybe IOError
00:20:28 <Trinithis> Cale: perhaps if you don;t mind next time, explainging a bit about applicative functors
00:20:34 <Cale> Trinithis: sure!
00:20:38 <Trinithis> night
00:20:53 <wadcom> cale: but I still need to select with isAlreadyExistsError
00:20:56 <Cale> handleJust ioErrors :: (IOError -> IO a) -> IO a -> IO a
00:20:58 <Cale> right
00:21:06 <Cale> But at least then you'll only get IOErrors
00:21:15 <wadcom> right
00:21:29 <wadcom> but still the biggest question is how to make it compile :-)
00:21:42 <Cale> Oh, catchJust
00:22:01 <Cale> (since you're using catch, not handle, I skimmed your code too quickly :)
00:22:04 <wadcom> cale: which is almost the same thing :-)
00:22:07 <Cale> right
00:22:43 <Cale> With handleJust, it would perhaps be a little more natural, since the do-block comes last
00:22:57 <wadcom> yep
00:23:04 <Cale> CE.handleJust ioErrors handler $ do createDirectory d
00:23:10 <Cale> and so on
00:23:13 <wadcom> oh
00:23:26 <wadcom> hmm, it got compiled, but I haven't yet realized why
00:23:29 <wadcom> thanks :-)
00:23:37 <Cale> Because instead of a general Exception
00:23:42 <Cale> you have an IOError
00:24:15 <Cale> ioErrors :: Exception -> Maybe IOError, after all
00:24:45 <Cale> So e becomes an IOError instead of a general Exception too
00:24:52 <wadcom> oh, I see
00:25:25 <wadcom> okay, thanks a lot :-)
00:25:33 <Cale> No problem.
00:26:17 <Cale> The exception mechanisms in GHC are a bit of a mess at the moment -- most of what you want is there, but there are perhaps too many choices about how to do things.
00:26:51 <Cale> (resulting from holding on to the H98 standard, and then newer stuff coming along)
00:27:55 <wadcom> yeah and also the documentation doesn't quite tie the two together (e.g. how does IOError relate to Exception? how can it be converted?)
00:28:17 <wadcom> or maybe it's not prominent for me to spot :-)
00:29:41 <Cale> IOError is the type of exception which is defined by Haskell 98, and it's then embedded into the more general Exception type
00:30:45 <Cale> (even more confusingly, this involves some kind of wrapper called IOException)
00:31:41 <Cale> oh
00:31:49 <Cale> It's not a wrapper, it's a type synonym
00:31:55 <Cale> duh!
00:32:05 <wadcom> ok Cale, thanks for your help -- appreciate it! gotta go right now
00:32:12 <wadcom> see you around :-)
00:32:13 <Cale> Alright, see you around
00:39:00 * Cale reads the new functional pearl :)
00:53:15 <dolio> I wonder if GHC will get arrow calculus.
00:53:49 <dolio> I suppose it'd be a fairly significant endeavor.
00:56:35 <Cale> Especially with the secondary type system :)
00:56:43 <dolio> Yeah.
01:14:32 <wagle> @cow
01:14:33 <lambdabot> I know th'MAMBO!!  I have a TWO-TONE CHEMISTRY SET!!
01:24:41 <solrize_>     case ex of
01:24:42 <solrize_>         ExitFailure e      -> fail $ "Failed with status: " ++ show e
01:24:42 <solrize_>         _  | not (null se) -> fail se
01:24:42 <solrize_>            | otherwise     -> return so
01:24:52 <solrize_> that is cool, the pattern guard on _
01:24:57 <solrize_> is that a standard idiom?
01:26:23 <dolio> That's just a regular guard. But yes.
01:26:36 <solrize_> thanks
01:26:40 <dolio> Case is the other place you can use guards, besides function definitions.
01:26:48 <solrize_> i had never seen that before
01:26:57 <solrize_> it's sort of like an if statement in the middle of the cases
01:27:31 <dolio> In fact, that's the way people get multi-way ifs.
01:27:47 <dolio> case () of _ | if1 -> ... | if2 -> ... | etc.
01:28:28 <solrize_> i hadn't seen that, it looked sort of weird at first and took me a minute to understand, but it comes out quite well
01:28:46 <dolio> I think there's a haskell' ticket to make it nicer by allowing you to omit the () and the _.
01:28:59 <dolio> But I don't know how much support that has.
01:30:05 <solrize_> something like if/elif would be ok, i guess
01:30:13 <solrize_> or a cond monad?
01:31:39 <wagle_home> > (Left 1) >> (Right 2) >> (Right 3)
01:31:42 <lambdabot>  Add a type signature
01:32:17 <ski> > ((Left 1) >> (Right 2) >> (Right 3)) :: Either Int Int
01:32:17 <lambdabot>   add an instance declaration for (Error Int)
01:32:27 <dolio> That, unfortunately, won't work, because the Monad instance for Either requires Error on the left type.
01:32:29 <ski> damn you `MonadError' !
01:33:49 <wagle_home> > case () of { _ | 1 = 2 -> "foo" }
01:33:49 <lambdabot>  Parse error at "=" (column 20)
01:33:51 <dolio> Otherwise I suppose you could do: 'when b1 (Left e1) >> when b2 (Left e2) >> when b3 (Left e3) ...'
01:33:55 <wagle_home> > case () of { _ | 1 == 2 -> "foo" }
01:33:57 <lambdabot>   Non-exhaustive patterns in case
01:34:16 <wagle_home> what about non-exhaustive cond
01:35:01 <wagle_home> > case () of { _ | 1 == 12 -> "foo" }
01:35:02 <lambdabot>   Non-exhaustive patterns in case
01:35:08 <wagle_home> > case () of { _ | 1 == 1 -> "foo" }
01:35:09 <lambdabot>  "foo"
01:35:42 <wagle_home> if else is at least exhaustive
01:35:49 <dolio> Use otherwise.
01:36:42 <dolio> > case () of _ | 1 == 2 -> "foo" | otherwise -> "bar"
01:36:42 <lambdabot>  "bar"
01:37:10 <wagle_home> i think (?) my question is "should cond mandatorially be exhaustive?"
01:38:10 <wagle_home> otherwise is a keyword?
01:38:18 <dolio> otherwise = true
01:38:30 <wagle_home> > otherwise
01:38:31 <lambdabot>  True
01:38:38 <wagle_home> ah
01:38:52 <ski> @src otherwise
01:38:53 <lambdabot> otherwise = True
01:39:26 <wagle_home> lambdabot knows the source of something?   *shock*
01:39:39 <ski> @src something
01:39:40 <lambdabot> Source not found. My pet ferret can type better than you!
01:39:56 <wagle_home> thanks, i feel better now
01:40:23 <dolio> -Wall warns about non-exhaustive patterns.
01:40:33 <dolio> If you don't include an otherwise.
01:41:00 <wagle_home> even for:
01:41:06 <wagle_home> > case () of { _ | 1 == 1 -> "foo" }
01:41:06 <lambdabot>  "foo"
01:41:28 <dolio> Perhaps not, since it might determine that that's always True.
01:41:38 <wagle_home> nm...  i shouild have gone to bed 45 minutes ago
01:41:41 <dolio> Although, I suppose that's not necessarily the case.
01:41:46 <jsnx> so, it would be nice to have some kind of list that guaranteed that it was sorted
01:42:09 <jsnx> and also a list that guaranteed it was not empty
01:42:30 <wagle_home> tricky:
01:42:41 <wagle_home> > NaN == NaN
01:42:41 <lambdabot>   Not in scope: data constructor `NaN'
01:42:47 <wagle_home> aww
01:43:09 <wagle_home> @index NaN
01:43:09 <lambdabot> bzzt
01:43:12 <ski> > let nan = 0.0/0.0 in nan == nan
01:43:15 <lambdabot>  False
01:43:21 <wagle_home> thanks
01:43:36 <mauke> > join (==) . join (/) $ 0
01:43:37 <lambdabot>  False
01:45:15 <wagle_home> > let x = 0.0/0.0 in case () of { _ | x == x -> "foo" }
01:45:15 <lambdabot>   Non-exhaustive patterns in case
01:45:59 <ski> `forall a. a == a =< True' ought to be a law
01:46:10 <wagle_home> i wonder how many optimizers in the world get fooled by that behavior of ==
01:46:18 <ski> > > let x = 0.0/0.0 in case () of { _ | x == x -> "foo" ; True -> "bar"}
01:46:18 <lambdabot>   parse error on input `>'
01:46:21 <ski> > let x = 0.0/0.0 in case () of { _ | x == x -> "foo" ; True -> "bar"}
01:46:21 <lambdabot>  Couldn't match expected type `()' against inferred type `Bool'
01:46:32 <sieni> jsnx: how do you guarantee that a list is not empty, if you allow taking the tail of a list (besides inserting infinitely many foobar elements to the end of the actual list if it happens to be finite)
01:46:32 <ski> > let x = 0.0/0.0 in case () of { _ | x == x -> "foo" | True -> "bar"}
01:46:33 <lambdabot>  "bar"
01:47:44 <wagle_home> oh well..  gnite
01:47:48 <dolio> You have a type 'newtype NonEmpty a = NE (a,[a])' and define operations on it.
01:48:27 <dolio> Including 'checkEmpty :: [a] -> Maybe (NonEmpty a) ; checkEmpty [] = Nothing ; checkEmpty (x:xs) = NE (x,xs)'
01:48:32 <jsnx> sieni: well, the 'tail' is the whole list if there's but one element
01:48:44 <quicksilver> dolio: +Just
01:48:52 <dolio> Oh, right.
01:49:28 <catface> can you give kind signatures in the data keyword?
01:49:39 <jsnx> or you have `data One a = OoO a (One a) | Oo a`
01:49:57 <jsnx> but then pattern matching is unpleasant
01:53:19 * dons waves from the hackathon
01:53:31 * quicksilver waves at the donathon
01:53:49 <quicksilver> dons: solved any NP-complete problems yet?
01:54:55 <jsnx> now i wonder, what do we do to get a list that's guaranteed sorted, at the type level?
01:55:06 <jsnx> i'm not sure that even makes any sense
01:55:34 <dolio> Well, you can newtype, and only export smart constructors that ensure the underlying list is sorted.
01:55:38 <quicksilver> jsnx: it does make sense.
01:55:55 <quicksilver> you have a data structure which contains a list, and a reification of a proof that it's sorted
01:55:58 <quicksilver> or something like that.
01:56:10 <quicksilver> it may not be terribly useful or efficient :)
01:56:15 <quicksilver> but it's an interesting question to ask.
01:56:26 <dolio> Proving it's sorted in the types would require dependent types, I assume.
01:56:32 <quicksilver> yes
01:56:41 <dolio> Where it's not so hard to do.
01:56:44 <quicksilver> although I daresay there is enough strength in typeclass hackery to do it
01:56:52 <quicksilver> in a moderately ugly way
01:57:07 <quicksilver> at least for finite types I can imagine it
01:57:19 <quicksilver> not sure if you can reify the order relation on an infinite type conveniently with typeclasses?
01:57:42 <dolio> Maybe. I guess you might be able to do something like Oleg's configurations passed by type.
01:58:54 <dolio> But that'd involve writing a type-level analogue to every value-level type you want to store in your list.
01:59:04 <quicksilver> the simpler question is : can you imagine a pair which must be increasing?
01:59:17 <quicksilver> can you write a type for (a,b) | a <= b
01:59:17 <jsnx> quicksilver: ?
01:59:33 <jsnx> oic
01:59:33 <quicksilver> if you can do that then the same trick will work for sorted lists, given that we have recursion.
02:00:05 <jsnx> as for useful and efficient -- it's useful for search
02:00:56 <quicksilver> in practical cases it's more useful to go the non-exported constructor way.
02:01:11 <quicksilver> that falls a long way short of "guaranteeing in the type syste"
02:01:20 <jsnx> yeah
02:01:25 <quicksilver> but it does give you a manageable thing to prove
02:01:34 <quicksilver> (prove all your exported functions preserve the invariant)
02:01:44 <jsnx> basically, i make this type and then put it in Functor and Foldable and Traversable
02:01:45 <hpaste>  dancor pasted "can i replace this with ghc or, better, cabal?" at http://hpaste.org/6936
02:01:46 <quicksilver> non-trivial ADTs always have invariants anyway, IME.
02:01:57 <jsnx> so it can be "list-like"
02:06:36 <Cale> dancor: You can pass .c files on your GHC commandline.
02:06:50 <dancor> wow
02:07:26 <Cale> That will save basically all of that mess :)
02:11:01 <dancor> > zipWith ((chr .) . (. ord) . (+)) [0,5,0] "gcc"
02:11:02 <lambdabot>  "ghc"
02:17:05 <dancor> can i hide the import list in ghci
02:17:32 <pjd_> dancor: :set prompt
02:17:40 <pjd_> the default is "%s> "
02:17:42 <dons> quicksilver: they're working on at least one.
02:18:25 <quicksilver> dons: \o/
02:19:45 <dons> (the optimal dependency resolution problem for haskell modules is in NP apparently)
02:19:56 <dons> i guess that's intuitive though: its a *graph* of modules
02:23:33 * sjanssen wonders if alexj was on the right path with searchpath after all
02:24:04 <dancor> punnn
02:24:53 <sjanssen> the fact that GHC has absolutely no concept of binary compatibility makes upgrading packages very difficult
02:25:32 <dancor> sorry i can't figure this stuff out, can i do qualified imports in ghci
02:26:07 <sjanssen> ghci automatically supports qualified names
02:26:15 <sjanssen> > Data.List.map (+1) [1..]
02:26:15 <lambdabot>   Not in scope: `Data.List.map'
02:26:29 <sjanssen> bah, lambdabot is not ghci
02:26:29 <dancor> can i do   as
02:26:32 <sjanssen> but anyway
02:26:36 <sjanssen> dancor: that you can't do
02:26:44 <dancor> can i do hiding
02:27:03 <sjanssen> another negative
02:27:11 <sjanssen> you can write your imports in a .hs and load them from ghci
02:27:17 <dancor> right
02:28:58 <Drum> Wanna earn money ?Or if u wanna get ircop hack u can find everything here - click here ----> http://white.hopto.org/
02:28:58 -Drum(n=Drum@balticom-196-248.balticom.lv)- Wanna earn money ?Or if u wanna get ircop hack u can find everything here - click here ----> http://white.hopto.org/
02:28:59 <lambdabot> Title:
02:29:13 --- mode: ChanServ set +o sjanssen
02:29:26 --- mode: sjanssen set +b *!*n=Drum@*.balticom.lv
02:29:26 --- kick: Drum was kicked by sjanssen (sjanssen)
02:29:50 --- mode: sjanssen set -o sjanssen
02:29:56 <ski> ty
02:49:07 <dancor> Cale: hm i can't seem to get it any less messy
03:03:12 * SamB notices the interesting nicks LordMetroid and [CitationNeeded]
03:05:23 <SamB> @ask [CitationNeeded] are you named after the xkcd strip?
03:05:23 <lambdabot> Consider it noted.
03:05:49 <LordMetroid> Hmm... I do not need a citation, thank you very much
03:06:37 <SamB> how am I supposed to believe that you are actually Lord Metroid without a citation?
03:07:03 <LordMetroid> Tsk, tsk, tsk... This is a registred nick
03:07:11 <LordMetroid> Check with nickserv!
03:07:39 <LordMetroid> [1]
03:08:35 <SamB> hey, ChanServ isn't logged in
03:08:38 <SamB> or out, either
03:09:38 <SamB> anyway, you don't seem to be identified at the moment...
03:10:23 <LordMetroid> http://xkcd.com/285
03:10:24 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
03:11:32 <LordMetroid> lambdabot is wrong!
03:11:44 <LordMetroid> [CitationNeeded]
03:11:57 <SamB> LordMetroid: yes, that is the strip in question...
03:12:08 <SamB> and lambdabot is just repeating the <title> tag...
03:12:13 <LordMetroid> :)
03:12:19 <LordMetroid> http://www.areta.org
03:12:20 <lambdabot> Title: Areta
03:12:36 <mauke> http://www.emasc.com/
03:12:37 <LordMetroid> yupp[2]
03:12:37 <lambdabot> Title: „—ﬂ“ «·≈„«—«  ··œ—«”«  Ê«·≈⁄·«„:.
03:12:48 <LordMetroid> Arabic!
03:13:11 <LordMetroid> http://www.emacs.com
03:13:13 <lambdabot> Title: www.Zippy.com.tw - index
03:13:23 <LordMetroid> http://www.emacs.org
03:19:45 <mauke> argh, why is PortNumber not an instance of Read?
03:20:22 <LordMetroid> a portnumber is just a virtualcategory
03:48:55 <MarcWeber> Doesn't HaXml provide a native functions to get the value of an attr by name ?
03:51:32 <malcolmw> MarcWeber: Text.XML.HaXml.Combinators.find (and iffind)
03:51:44 * quicksilver wonders if malcolmw has a highlight on HaXml
03:51:57 <dons> malcolmw: you're missing the hackathon! :(
03:51:59 <malcolmw> quicksilver: of course!
03:52:10 <MarcWeber> mauke: fromInteger. read might work
03:52:35 <malcolmw> quicksilver: and for numerous other pieces of software I've written
03:53:02 <SamB> okay... I seem to have somehow lost the gcc command...
03:53:09 <MarcWeber> malcolmw: Thanks. But I'm not looking for filters but for a functions extracting the attr value after having applied some filters
03:53:14 <malcolmw> dons: is there a hackathon channel on IRC?
03:53:35 <Lemmih> malcolmw: Yes, #haskell-hac4
03:53:59 <MarcWeber> malcolmw: Something like attrs (Elem _ attrs _) = attrs
03:53:59 <MarcWeber> attrValue name = snd . head . filter ( == name . fst) . attrs
03:54:43 <malcolmw> MarcWeber: there you go - it's a one liner, so no need for a special combinator! :-)
03:55:00 <SamB> how decidedly strange
03:55:24 * SamB upgrades his "gcc" and "g++" packages to the latest
03:55:38 <MarcWeber> malcolmw: Two lines. So this taks is very uncommon for an XML library .. ? :)
03:56:16 <malcolmw> MarcWeber: Feel free to add it to the library and send me a patch...
03:56:59 <MarcWeber> malcolmw: Then I have to dive into those references and when they are used.. I'll try
03:58:41 <malcolmw> MarcWeber: you might find the Verbatim module useful in that regard
04:00:08 <MarcWeber> malcolmw: I know. You've told me about it long time ago replying to me question how to extract text from tags..
04:01:50 <MarcWeber> malcolmw: May I add the getElemen used in XPath as well ?
04:02:40 <malcolmw> MarcWeber: add whatever you think is useful.  I don't do enough XML processing these days to know what is missing from HaXml.
04:21:29 <hpaste>  realspace pasted "Ambiguous type variable in constraints" at http://hpaste.org/6937
04:21:39 <realspace> Hello, I have a strange problem with type variables. See http://hpaste.org/6937
04:22:40 <kpreid> realspace: ghci does more enthusiastic defaulting, for convenience
04:22:50 <EvilTerran> ?type show -- show can take parameters of various types
04:22:52 <lambdabot> forall a. (Show a) => a -> String
04:23:06 <EvilTerran> er, wiat, nvm. it's the fromIntegral thing, isn't it.
04:23:23 <kpreid> realspace: but in normal haskell there's nothing to determine what the type of x is
04:23:39 <mauke> realspace: foobar :: Int -> Int and remove the fromIntegral
04:23:47 <realspace> the code is a striped down version of a larger piece
04:24:05 <kpreid> realspace: you can write foobar (123 :: Integer) to fix the type sufficiently
04:24:24 <realspace> in the larger piece, there could be all sort of Integrals, like Int, Integer, WordXX and so on
04:24:58 <mauke> convert on the outside
04:25:03 <mauke> foobar chops it down to Int anyway
04:25:09 <kpreid> realspace: just make the type of the *input* specific
04:25:10 <realspace> the main problem is, that in the larger piece i have to write ([] :: [Int])
04:25:45 <kpreid> hm. there might be a ghc extension to make it willing to default Bits
04:26:16 <realspace> hmm...
04:58:27 <jcaldwell> I'm working on a mad-libs style program.  Looking for any Haskell libraries comparable to FreeMarker or Velocity.  Seems mostly the Haskell approach would be to use Parsec to roll-your-own template manager, but just trying to see what is already there to build on...
05:11:58 <jcaldwell> looks like HStringTemplate may do the trick - http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HStringTemplate-0.3.1 -
05:12:02 <lambdabot> http://tinyurl.com/5afnrg
05:12:15 <dons> oh for templates? yes, its pretty good
05:15:08 <jcaldwell> not much docs but maybe after hacking around with a little example I'll have something to add
05:20:20 <Heffalump> has anyone done anything with the quasi-quoting stuff yet, OOI?
05:22:11 <MarcWeber> Am I right that old-time is depreceated and that I should use time instead? Which is the right way to convert a ClockTime to a new POSIXTime then ? Because eg hsql still supports reading to ClockTime
05:22:44 <MarcWeber> Probably the right thing to do is updating hsql...
05:52:02 <dancor> are bloom filters not cool in fp
05:53:17 <ivanm> @seen sjanssen
05:53:17 <lambdabot> sjanssen is in #haskell, #xmonad and #haskell-soc. I don't know when sjanssen last spoke.
06:21:27 <fons> hi all
06:21:36 <fons> got a question regarding strictness
06:21:50 <fons> can anyone tell me why the following expression doesn't terminate
06:22:04 <fons> (\[x] -> x)   $ transpose (cycle [[1]])
06:22:12 <fons> whereas this one works?
06:22:35 <fons> (\(x:xs) -> x)   $ transpose (cycle [[1]])
06:23:14 <Heffalump> doesn't terminate, or crashes?
06:23:17 <mauke> because xs is bottom
06:23:17 <dancor> is there a library for bit arrays
06:23:20 <dancor> already
06:23:31 <Heffalump> oh, I see.
06:23:33 <mauke> your first pattern is equivalent to \(x:[])
06:23:35 <Deewiant> [x] only matches a one-element list, (x:xs) matches a list with any amount of elements
06:23:45 <Deewiant> (except 0, of course)
06:23:52 <Heffalump> checking whether the tail is [] is what fails to terminate
06:24:10 <fons> Deewiant: but the list only has one element
06:24:21 <fons> an infinite element, but just one
06:24:37 <mauke> fons: no, not really
06:24:53 <allbery_b> dancor: unboxed Bool arrays are bit arrays, I believe
06:25:52 <fons> mauke: I'm surely missing something (otherwise I souldn't be asking) but ... the result should be a list with just only element, a list with inifinite one's
06:25:55 <fons> noes*
06:26:09 <Deewiant> > length $ transpose (cycle [[1]])
06:26:15 <lambdabot> Terminated
06:26:38 <fons> > length $ transpose [[1],[1]]
06:26:39 <lambdabot>  1
06:26:47 <Deewiant> > head.tail $ transpose (cycle [[1]])
06:26:52 <mauke> fons: the result is a cons whose head is an infinite list of ones and whose tail is bottom
06:26:53 <lambdabot> Terminated
06:27:20 <fons> mauke: I don't see why the tail is bottom
06:27:28 <Deewiant> transpose would generate the tail, but it needs to fill in the head first?
06:27:36 <Deewiant> or something like that?
06:27:42 <mauke> > transpose [[1], [1], [1], [1,2]]
06:27:43 <lambdabot>  [[1,1,1,1],[2]]
06:28:02 <mauke> transpose needs to check ALL elements to determine that there is only one element in the result list
06:29:28 <fons> ok good, thanks for the help
06:29:46 <fons> this stupid thing was causing the implementation of a system simulator to be strict
06:38:43 <takamu> hi
06:42:40 <Duddle> hello everybody! quick question: how do I get the middle element of a list? i.e. given [1,5,0,7,6] I want that 0
06:43:43 <scook0> depends what you want it to do with an even-length or zero-length list
06:43:44 <Deewiant> > let mid l = l !! (length l `div` 2) in mid [1,5,0,7,6]
06:43:44 <lambdabot>  0
06:43:46 <Duddle> or even simpler: I want to split a list in two halves, but splitAt needs an n, but I cannot just do ((length list)/2) as splitAt wants an Integer
06:44:02 <Deewiant> you want `div` instead of /
06:44:12 <Deewiant> it does integer division
06:44:16 <Toxaris> > let middle xs = xs ! i where i = length xs `div` 2 in middle [1,5,0,7,6]
06:44:17 <lambdabot>  Couldn't match expected type `Array i e'
06:44:26 <Toxaris> > let middle xs = xs !! i where i = length xs `div` 2 in middle [1,5,0,7,6]
06:44:27 <lambdabot>  0
06:45:04 <Duddle> I'll try
06:46:18 <Duddle> thanks, `div` was what I was looking for :)
06:48:01 <Duddle> I started learning haskell yesterday, it's such a sweet language... I implemented quicksort basically in just 3 minutes :)
06:49:35 <funktio> > let middle xs = rec xs xs where rec (_:ys) (_:_:zs) = rec ys zs ; rec (y:_) _ = y in middle [1,5,0,7,6]
06:49:36 <lambdabot>  0
07:00:25 <[CitationNeeded]> SamB what xkcd strip?
07:00:25 <lambdabot> [CitationNeeded]: You have 1 new message. '/msg lambdabot @messages' to read it.
07:00:45 <[CitationNeeded]> @messages
07:00:45 <lambdabot> SamB asked 3h 55m 22s ago: are you named after the xkcd strip?
07:03:08 <Duddle> I guess he means the "Wikipedian Protester" ( http://xkcd.com/285/ )
07:03:08 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
07:03:13 <[CitationNeeded]> ah
07:03:17 <[CitationNeeded]> heh
07:03:32 <[CitationNeeded]> i'm not a big fan of xkcd
07:05:42 <kilimanjaro> [CitationNeeded], do you realize where you are? This is freenode! Saying that you don't really like xkcd is like being at the vatican and saying you don't really like catholocism.
07:06:46 <zeno___> some of the jokes arnt that funny, and mostly the art sucks
07:06:57 <[CitationNeeded]> kilimanjaro haha
07:07:02 <ivanm> blasphemy!
07:07:26 <kilimanjaro> zeno___, yea I agree, the only xkcd I read is what I get linked to. I like perry bible fellowship better, for a quirky laugh
07:07:57 <zeno___> i just found one called subnormality
07:08:11 <zeno___> (like PBF if it had txt =p)
07:08:40 <zeno___> i like some xkcd
07:08:45 <Duddle> if you like PBF, you might also like http://truckbearingkibble.com/  (that sounded alot like amazon)
07:08:46 <lambdabot> Title: Truck Bearing Kibble
07:09:00 <zeno___> but its not always as brilliant as its made out to be
07:10:26 <simony_> funktio, that's a weird way to define middle!
07:14:35 <dancor> that's awesome, one pass?
07:15:05 <dancor> it's unclear if you actually get fasterness even for really long things..
07:16:38 <kilimanjaro> It could be that in fact really long things absorb slowitude more quickerlike
07:16:50 <jadrian> can we use the lambdabot to get free theorems for given types?
07:17:04 <jadrian> instead of theorems for functions from the haskell libs?
07:17:57 <dancor> it's like 1.5 passes
07:18:00 <dancor> with a copy
07:18:03 <Saizan> @free map :: (a -> b) -> [a] -> [b]
07:18:03 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
07:18:10 <Saizan> @free map :: (a -> b) -> [a] -> [b]
07:18:10 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
07:18:50 <jadrian> @free h :: (a -> b) -> [a] -> [b]
07:18:50 <lambdabot> g . k = p . f => $map g . h k = h p . $map f
07:19:03 <jadrian> ok cool
07:19:21 <simony> ghc 6.6 doesn't have Control.Monad.Trans, any idea where its at in 6.6?
07:19:27 <Heffalump> -package mtl
07:19:29 <jadrian> @free h :: (a -> b) -> a
07:19:29 <lambdabot> g . k = p . f => f (h k) = h p
07:19:35 <gnuvince> :t ($)
07:19:35 <lambdabot> forall a b. (a -> b) -> a -> b
07:20:49 <simony> Heffalump, is that a ghc flag?
07:21:10 <jadrian> this free theorem didn't help me much :S
07:21:12 <Duddle> when I am using ghci, is there a way to call a function and see the calculations step by step?
07:21:14 <simony> weird! How come its not in the stdlib?
07:21:24 <jadrian> can we use the free thing in ghci?
07:21:48 <jadrian> it would be a pretty cool addition to it if it's not there already
07:23:52 <dancor> was it wrong of me to assume `ghc --make -c -ffi src/Main.hs` would compile src/Data/Thing.hs if src/Main.hs has import Data.Thing
07:24:18 <Deewiant> you might want "-isrc"
07:24:21 <scook0> try adding -isrc
07:24:31 <dancor> sweet
07:26:31 <Heffalump> simony: yes
07:26:45 <Heffalump> simony: because the stdlib is being broken up to move unnecessary things out of it
07:26:51 <simony> Heffalump, ok
07:26:54 <Heffalump> but you should only explicitly need -package if not using --make
07:27:08 <Heffalump> or if you're defining a cabal package or using --hide-all-packages
07:36:55 <byorgey> Duddle: no, there isn't
07:37:01 <Duddle> ok
07:37:16 <Deewiant> well there's the debugger?
07:37:28 <byorgey> Duddle: there is a tracing tool called Hat, but in my experience it's quite difficult to get it set up and use it properly, so I wouldn't bother
07:37:39 <byorgey> at least not when you're just starting out
07:37:49 <Duddle> ok, thanks
07:38:06 <byorgey> Duddle: and by the way, welcome! =)
07:38:46 <Duddle> ^_^
07:41:48 <Cale> Duddle: However, if you'd like an explanation of how lazy evaluation proceeds, I'd be happy to give one.
07:42:15 <Cale> (It's pretty easy to do it by hand, if a bit mechanical :)
07:42:25 <Duddle> nah, it's just that I wanted to see the recursions happening
07:43:01 <Cale> The main idea is that expressions are reduced outermost (leftmost) first.
07:43:27 <Duddle> and today was only my first lecture about haskell, I guess the professor will tell us more about the theoretical stuff soon :)
07:43:46 <vixey> theoretical? :P
07:43:48 <Cale> So that when evaluating f (g x), you write out the body of f, and stick (g x) into it.
07:43:56 <byorgey> Duddle: cool, where are you in school?
07:44:35 <Cale> (But there's an added proviso that if the parameter of f occurs multiple times in the body, g x will only be computed once, if at all, and then shared between the copies.
07:44:37 <Cale> )
07:44:56 <byorgey> graph reduction ftw! ;)
07:45:02 <Duddle> http://tu-dresden.de/
07:45:06 <lambdabot> Title: TUD - TU Dresden - Startseite - Aktuelles
07:45:53 <Duddle> Cale: thanks
07:46:10 <vixey> is that how you find the normal form of a (n untyped) lambda term when it exists?
07:46:25 <Cale> yeah, that'll always work
07:47:12 <Cale> (whereas strict evaluation won't always work, it sometimes gets stuck in an infinite loop computing something which isn't required)
07:47:57 <mauke> const () (fix id)
07:53:46 <pejo> Cale, (to which programmers have responded by not writing non-terminating expressions).
07:54:13 <Cale> pejo: right, rather than fixing their evaluators to work better.
07:55:09 <Nerrep> Hi everyone - currently having a bit of a problem which you might be able to help me with. I've basically built up around 15-20 functions designed to solved smaller parts of a larger problem - my issue is working out how to bring it all together coherantly? Anything I should be looking at?
07:55:11 <shepheb> anyone have a reference for min-maxing AI in Haskell?
07:55:53 <dcoutts> @seen ibid
07:55:53 <lambdabot> ibid is in #haskell. I don't know when ibid last spoke.
07:56:05 <dcoutts> ibid: ping
07:58:04 <dancor> A.hs exports a C func and import B.hs.  making A_stub.o is fine and everything works if i drop the import of B.  B.hs exports no C funcs.  but with the import, linking yells about __stginit_B_
07:58:22 <dancor> i can't seem to creat a B_stub.o
07:59:45 <dancor> i don't know why there is a trailing _ since for just A.hs i only have to worry about __stginit_A
07:59:57 <czakey> > map (+1) read $ cycle "2"
08:00:02 <lambdabot> Terminated
08:00:09 <czakey> hm
08:00:16 <ski> what did you expect ?
08:00:30 <vixey> > map ((+1) . read) $ cycle "2 "
08:00:30 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
08:00:32 <dancor> so all in all, i would say that i have no idea what is going on
08:00:33 <czakey> > [3,3..]
08:00:33 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
08:00:36 <mauke> :t map (+1) read
08:00:36 <czakey> that
08:00:37 <lambdabot> forall a. (Read a, Num a) => String -> a
08:00:37 <czakey> ;>
08:00:47 <vixey> > map ((+1) . read) $ repeat "2 "
08:00:51 <funktio> simony, dancor: I think it should be about as fast as using length and !!, just written differently
08:00:54 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
08:01:09 <vixey> > read "2222222222222222222222222222222222222222"
08:01:09 <mauke> > map (+1) read $ "222"
08:01:10 <lambdabot>  Exception: Prelude.read: no parse
08:01:10 <lambdabot>  223
08:01:13 <byorgey> Nerrep: it's a little hard to know how to help, since you haven't given us too much information.
08:01:14 <ski> > map (+1) read $ ("[" :) $ cycle "2,"
08:01:15 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
08:01:16 <dancor> funktio: yeah i suppose it could be..
08:01:26 <ski> > map (+1) read $ ("[" ++) $ cycle "2,"
08:01:27 <lambdabot>  Exception: Prelude.read: no parse
08:01:34 <funktio> it still traverses the list 1.5 times
08:01:40 <ski> > map (+1) $ read $ ("[" ++) $ cycle "2,"
08:01:40 <lambdabot>   add an instance declaration for (Read (f a))
08:01:57 <funktio> dancor: but I think it's elegant in a funny way :)
08:02:00 <byorgey> Nerrep: what are you trying to do?
08:02:36 <simony> hey, what's mfix used for?
08:02:45 <mauke> constructing objects :-)
08:02:51 <dancor> me too.  well there is some definite hackery.. it doesn't generalize to 1/Nth easily e.g.
08:03:11 <dancor> where n is a var i mean
08:03:25 <ski> > take 10 $ map (take 10) $ mfix $ \xs -> do x <- [0,1]; return (x:xs)
08:03:26 <lambdabot>  [[0,0,0,0,0,0,0,0,0,0],[1,1,1,1,1,1,1,1,1,1]]
08:03:27 <dancor> (_:_:_:zs) def gets you 1/3rd
08:03:59 <funktio> dancor: I suppose you could use drop
08:04:16 <ski> > take 10 $ map (take 10) $ mfix $ \xs -> do x <- [2,3]; return (x:map (x*) xs)
08:04:17 <lambdabot>  [[2,4,8,16,32,64,128,256,512,1024],[3,9,27,81,243,729,2187,6561,19683,59049]]
08:04:37 <dancor> heh ya i guess so
08:04:56 <funktio> > let f xs = rec xs xs where rec (y:_) [] = y ; rec (_:ys) zs = rec ys (drop 5 zs) in f [1..100]
08:04:57 <lambdabot>  21
08:05:17 <ski> `mfix' executes the monadic effect *once* in the result of the argument of type `a -> m a', passing the monadic result as input to the argument
08:05:22 <dancor> ok general functions of length :p
08:05:59 <Nerrep> Essentially, I have various functions which are all reliant on pieces of data generated by other functions - individually they all work fine (just typing test data into them with hugs), but I need to find a way to put them all together into a contingious program. unfortunately it's a bit more complex than being able to do "f1 (f2 (f3...)" as some of the functions take paramaters that would be worked out much earlier in the
08:06:14 <funktio> > let f n xs = rec xs xs where rec (y:_) [] = y ; rec (_:ys) zs = rec ys (drop n zs) in f 10 [0..99]
08:06:15 <lambdabot>  10
08:06:25 <dancor> that's more like i'm assuming one solution ahead of time.  if the function is easily doable "as you go" your thing definitely has a kind of appeal
08:06:44 <byorgey> Nerrep: maybe you want to use a 'where' clause.
08:07:17 <byorgey> Nerrep: solution = f1 (f2 x) where x = foo y; y = bar z; z = foobar x z
08:07:36 <byorgey> Nerrep: mutual recursion is just fine, and the order doesn't matter.
08:07:55 <Nerrep> brilliant, I shall have a look at that
08:07:58 <Nerrep> Thanks very much
08:08:03 <ski> TyingTheKnot
08:08:13 <byorgey> Nerrep: sure, hope it helps. =)
08:10:45 <simony> I am looking at the Control.Monad.State.Lazy module source code, and it seems to have code duplication for both State and StateT. Couldn't it replace all the State-related code with a  newtype State s a = StateT s Identity a ?
08:12:16 <pjd_> simony: that might impact efficiency
08:12:47 <simony> pjd_, in second thought, maybe it can be a type synonym rather than a newtype?
08:13:46 <pjd_> simony: the fact that it's an identity transformer, i mean
08:14:04 <pjd_> newtype shouldn't have any runtime overhead
08:14:10 <simony> pjd_, wouldn't it be optimized into nothingness?
08:14:56 <pjd_> possibly; i don't know what GHC does with it
08:15:19 <pjd_> maybe a guru can enlighten
08:15:20 <ski> one would need to specialize the operations
08:16:10 <ski> (i think ghc can be asked to do such, with `SPECIALIZE' pragma .. hm, or maybe that was obsoleted by `RULES' pragma ?)
08:18:53 <ndm> ski, no specialise is still useful
08:19:15 <ski> ok
08:20:04 <czakey> @google ala
08:20:06 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
08:20:09 <czakey> ha!
08:20:21 <czakey> I have simillar bug
08:20:51 <jaj> Hi! Just wondering, can you compile a haskell program without linking it to libgmp?
08:21:02 <jaj> if you just use Int, not Integer
08:21:37 <czakey> dons: is that a bug or I'm doing something wrong?
08:22:17 <ndm> jaj: no, you can't just use Int, since there are loads of Integer's everywhere in a program, including the standard libraries
08:22:27 <czakey> @tell dons try "@google ala" I think that is a bug in lambdabot...
08:22:27 <lambdabot> Consider it noted.
08:23:23 <jaj> ndm: that's what I was thinking, thanks!
08:23:50 <ndm> jaj: we did try it within Yhc at one point, but thinks like rational numbers screwed it all up - but i think it is still worth doing at some point
08:26:35 <dons> czakey: oh, maybe google is blocking us
08:26:35 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
08:26:38 <dons> they did that once before
08:26:56 <dons> we have to see what page lambdabot is getting redirected to, and type in some key
08:27:03 <czakey> dons: that isn;t that
08:27:12 <czakey> yup captcha
08:27:27 <czakey> but this is not that I think
08:27:51 <czakey> because other queries are ok
08:28:58 <dons> ?google foo
08:28:59 <lambdabot> http://www.foofighters.com/
08:28:59 <lambdabot> Title: Foo Fighters
08:29:03 <dons> oh weird
08:29:06 <dons> ?google ala
08:29:07 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
08:29:10 <czakey> yup
08:29:10 <dons> huh
08:29:15 <dons> a utf8 issue?
08:29:23 <czakey> I think that has something to do witch utf
08:29:27 <czakey> yup
08:29:38 <czakey> Polish chars in that case
08:29:40 <czakey> I think
08:30:09 <czakey> because I've tried to rewrite Search plugin to Polish google
08:30:20 <czakey> and I have lot of that errors
08:30:34 <dons> i think that's the reason
08:31:43 <jaj> ndm: I wanted to compile a haskell program for my C64 by generating C code via ghc but then I found out that libgmp is 10 times bigger than my RAM :) It was probably a stupid idea in the first place
08:31:56 <czakey> :D
08:32:33 <scook0> people have been known to write haskell programs that *generate* programs for embedded systems
08:32:42 <simony> do you have any concrete example use of mfix?
08:33:16 <simony> oh, ski did, sorry
08:33:59 <fons> How are cabal packages unistalled?
08:34:19 <czakey> unregister?
08:35:00 <fons> czakey: does unregister actually remove the files installed?
08:35:23 <scook0> nope
08:35:33 <sm> my cabal doesn't have that command
08:35:50 <sm> or --version >:/
08:35:50 <fons> uhm, that not good, I assume I have to remove then by hand then
08:36:01 <fons> sm: ghc-pkg has it
08:36:21 <scook0> if you've used cabal-install, the files should be under ~/.cabal
08:36:33 <geezusfreeek> i read somewhere that the lack of uninstall is intentional, which makes no sense to me
08:36:34 <sm> aha
08:37:04 * scook0 hates the unix "tradition" of spreading stuff all over the filesystem, and providing no uninstall mechanism
08:37:09 <geezusfreeek> also note that if you manually delete stuff you still have to also unregister it
08:37:23 <Cale> scook0: I hate that tradition as well.
08:37:48 <geezusfreeek> i like the ideas of NixOS though
08:38:00 <geezusfreeek> where everything is installed separately from everything else
08:38:01 <Cale> geezusfreeek: Usually I manually unregister stuff without deleting it.
08:38:12 <geezusfreeek> that is what i do too
08:38:14 <czakey> me too
08:38:15 <geezusfreeek> i just don't like it
08:38:58 <fons> geezusfreeek: it neither makes sense to me
08:39:18 <fons> package management without actually being able to uninstall packages :S
08:39:46 <Cale> Right, it doesn't make a lot of sense. At least it works for now, and I think things are installed in the ghc lib dir, so I'll just blow them away when upgrading to the next ghc
08:40:07 <awesame> I love this trend for every OS and every language to have its own package management system
08:40:32 <byorgey> I think it's just that package uninstallation is very difficult to get right.
08:40:32 <awesame> and by "love", I mean "hate"
08:40:47 <geezusfreeek> it gets especially bad when you have to decide whether to use your distro's or your language's for some things
08:41:05 <Cale> awesame: To be fair, a lot of the linux distributions use one of two package management systems.
08:41:09 <byorgey> rather than a conscious decision for Cabal not to support uninstall for some sort of positive reason
08:41:32 <Cale> byorgey: Right, I'm pretty sure they're working on it :)
08:41:54 <byorgey> maybe dcoutts is working on it at the Hackathon, at this *very moment*! =D
08:42:01 <Cale> They're also working on dependency analysis, which is apparently NP-complete.
08:42:13 <geezusfreeek> no actually i had read something to the effect of they see no reason somebody would want to uninstall a cabal package
08:42:16 <Cale> (finding the optimal set of packages to install)
08:42:16 * paolino is working on it
08:42:26 <Cale> geezusfreeek: That's absurd.
08:42:29 <byorgey> paolino++
08:42:30 <geezusfreeek> yeah
08:42:41 <geezusfreeek> lemme see if i can find it to avoid mutilating it though
08:42:48 <awesame> Cale: that's better than nothing, but I still have to use like 4 incompatible package management systems
08:42:49 <Cale> geezusfreeek: I don't know who said that, but the Cabal developers seem a lot saner than that to me. :)
08:42:52 <geezusfreeek> i could be vastly exaggerating
08:43:20 <jaj> you have 1 subfolder per package in lib/ under ghc's root folder
08:43:23 <Cale> geezusfreeek: Installing packages easily is definitely a priority.
08:43:40 <jaj> I assume deleting this folder will effectively remove the package
08:43:50 <awesame> apt, cpan, setuptools, cabal, gem, etc, etc
08:43:50 <jaj> if you also run unregister of course
08:44:39 <geezusfreeek> meh i can't seem to find it easily
08:44:41 <geezusfreeek> i give up
08:44:44 <Cale> awesame: I think it makes sense for languages to have package managers for libraries (and I don't care if they're programmed separately), since there's a lot of extra information about development libraries which can be used to help inform the system, and which wouldn't be appropriate in the system-wide package manager.
08:45:33 <scook0> also, it can be useful to have stable system packages, combined with bleeding-edge language library packages
08:45:48 <czakey> I want all that stuff that is not OS-packaged somewhere in one place
08:45:48 <awesame> yeah, I see why it's happening
08:45:57 <awesame> but it's a mess right now
08:46:03 <ndm> @seen Eric Kow
08:46:03 <lambdabot> I haven't seen Eric.
08:46:04 <jaj> I like it how BSD ports solve this problem by offering a standard interface which uses the language specific package manager in the background. I assume other systems do the same
08:46:07 <scook0> that's what /usr/local is supposed to be for, iirc
08:46:09 <czakey> Im usung debian so everything that is not from apt
08:46:10 <ibid> dcoutts: pong
08:46:12 <ndm> @seen kowey
08:46:13 <lambdabot> I haven't seen kowey.
08:46:19 <czakey> is in /usr/local
08:46:20 <scook0> but you still have the problem that everything you install is spread throughout /usr/local
08:46:22 <awesame> for example, python's setuptools and apt/yum will cheerfully overwrite files installed by the other system
08:46:28 <Cale> czakey: My current solution is a combination of /usr/local and my home directory.
08:46:46 <czakey> Cale: yup as for me the same :)
08:46:50 <gwern> Loading package hpc-0.5.0.0 ... linking ... ghc-6.8.2: unable to load package `hpc-0.5.0.0'
08:46:54 <Zao> I tend to use stow for most third party software.
08:46:59 <gwern>  que: ghc-6.8.2: /usr/lib64/ghc-6.8.2/lib/hpc-0.5.0.0/HShpc-0.5.0.0.o: unknown symbol `directoryzm1zi0zi0zi0_SystemziDirectory_lvl19_closure'
08:47:03 <Zao> That way, if something mangles it, it's easy to restore.
08:47:10 <scook0> at the very least, an install process should generate a list of paths and hashes
08:47:17 <scook0> so you can remove stuff yourself
08:47:29 <czakey> scook0: I have /usr/local/Haskell
08:47:33 <gwern> appears regardless of whether I configure for profiling
08:47:37 <czakey>  /usr/local/Perl
08:47:40 <czakey> and so
08:47:48 <scook0> I put all my cabal packages in ~/.local
08:47:56 <czakey> so I know where everything is ;)
08:48:05 <scook0> though I'll switch to ~/.cabal at some point
08:48:05 <awesame> and because every language is reimplementing package management, there are a ton of package managers I have to use right now which are really not very good yet
08:49:11 <scook0> it would be nice to have some kind of standard communication protocol between system and language package systems
08:49:15 <awesame> it makes me think fondly of the java "make yourself a directory full of jars" method of package management
08:49:30 <awesame> scook0: the python folks have a proposal for one
08:49:33 <awesame> PEP 262
08:50:00 <awesame> if I understand it correctly
08:50:03 <czakey> java ;/
08:52:35 <awesame> I think it's overengineered, though
08:52:39 <scook0> I do like the fact that ghc-pkg can happily mix distro, non-distro, user, and system-wide packages
08:52:56 <awesame> it seems like just having a separate install directory for language-installed packages would be fine
08:54:57 <awesame> python has kind of gone off the deep end trying to work around some dumb package management design decisions that aren't universally acknowledged to be dumb in their community
08:55:26 <ski> jaj : fun idea :)
08:56:01 <ski> jaj : at some point i was considering implementing a simple graph-rewriting functional programming language on the C64 (.. never got so far, though)
08:56:04 <Cale> Python needs to work harder on its module *names*. :)
08:57:23 <Cale> They're all strangely contracted things with no coherent convention with regard to capitals and underscores.
08:57:53 <awesame> yes
08:58:43 <ski> simony : another example of using `mfix' is to create a cyclic datastructure from an `IO'-computation in one pass, without having to insert `IORef' indirections to patch up later
08:58:58 <Cale> This might have something to do with the fact that people always import everything qualified in python, which means that they have to type the module name over and over.
08:59:01 <simony> ski, How do you do that?
08:59:20 <awesame> importing qualified a lot is a pretty decent idea
08:59:39 <awesame> but python has "import foo as bar", so there's no excuse
09:00:13 <Cale> ah, I don't think I've ever seen that used.
09:00:22 <ski> simony : same as usually tying the knot, except the computation is monadic and you use `mfix' instead of `fix' or explicit cyclicism (like `where (b,c) = foo a c')
09:00:25 <Cale> (but I haven't done a lot of python programming)
09:00:26 <byorgey> @type mfox
09:00:30 <byorgey> er
09:00:34 <byorgey> @type mfix
09:00:35 <roconnor> importing unqualified a list of names is also fine.
09:00:36 <Cale> @type mbison
09:00:41 <lambdabot> thread killed
09:00:42 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
09:00:43 <lambdabot> Not in scope: `mbison'
09:00:43 <ski> @type fix
09:00:44 <lambdabot> forall a. (a -> a) -> a
09:00:50 <byorgey> @type mwombat
09:00:51 <lambdabot> Not in scope: `mwombat'
09:01:08 <Deewiant> @type mkitteh
09:01:08 <lambdabot> Not in scope: `mkitteh'
09:01:14 <awesame> I generally think of haskell as having cryptic and sometimes poorly chosed function names, but I was amused recently to learn that for http form encoding, haskell has formEncode and formDecode, while python has urlencode and parse_qs
09:01:24 <Cale> http://en.wikipedia.org/wiki/M._Bison ;)
09:01:25 <lambdabot> Title: M. Bison - Wikipedia, the free encyclopedia
09:01:33 <byorgey> hehe
09:01:35 <awesame> uh, "poorly chosen", too
09:02:04 <byorgey> awesame: no, I think 'poorly chosed' is a good description of 'parse_qs' =)
09:02:11 <Cale> I think the names are mostly pretty sane, with some important and glaring exceptions.
09:02:22 <pjd_> Cale: re. Python module names, there's a lot of hysterical raisins there
09:02:27 <byorgey> Cale: which? Haskell or python?
09:02:27 <Zao> byorgey: So what are qs and why do I parse them.
09:02:28 <simony> ski, I don't use fix yet, so like "usually using fix" doesn't clear it up ;)
09:02:33 <Cale> byorgey: Haskell
09:02:36 <pjd_> Python 3 includes a reorganization effort
09:03:02 <awesame> Cale: my impression is mostly based on stuff that's in the Prelude -- outside the Prelude, things seem to get better
09:03:03 <vixey> > (1:)$(1:)$(1:)$(1:)$(1:)$(1:)$(1:)$(1:)$(1:)$(1:)$(1:)$(1:)$(1:)$(1:)$(1:)$[]
09:03:03 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
09:03:08 <vixey> > fix (1:)
09:03:08 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
09:03:17 <Cale> awesame: What's poorly named in the Prelude?
09:03:18 <byorgey> Zao: why, to mogrify the attenuators, of course
09:03:30 <Cale> awesame: Other than the "Real" class :)
09:03:45 <awesame> Cale: I wouldn't have allocated "read" for what it does
09:04:00 <Cale> hmm
09:04:10 <Cale> I've never had a problem with that...
09:04:12 <mauke> reify!
09:04:16 <vixey> > (fix (\factorial -> \n -> if n==0 then 1 else n*factorial(n-1)))5
09:04:16 <lambdabot>  120
09:04:34 <Cale> Yeah, hehe, we'll change read and show to reify and reflect
09:04:46 <awesame> well, you learn what it does, and then it's not a problem
09:04:53 <vixey> freeze and thaw
09:05:01 <awesame> but toString and fromString might have been wiser than show and read
09:05:13 <jsnx> pickle and unPickle
09:05:21 <resiak> "toString foo" sounds silly
09:05:30 <vixey> > fix show
09:05:31 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
09:05:49 <vixey> > show (show (show (show (show ("?")))))
09:05:49 <jsnx> > fix (1 +)
09:05:50 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"?\\\\\\\\\\\\...
09:05:50 <lambdabot>  Exception: <<loop>>
09:05:58 <gwern> 'Loading package ghc-6.8.2 ... linking ... ghc-6.8.2: unable to load package `ghc-6.8.2'' <-- no.... does GHC not build itself with profiling?
09:05:59 <jsnx> > fix show
09:06:00 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
09:06:05 <Cale> > fix ((0:) . scanl (+) 1)
09:06:05 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
09:06:24 <jsnx> > fix (0 +)
09:06:25 <lambdabot>  Exception: <<loop>>
09:06:27 <vixey> simony: Are these making sense?
09:06:45 <Cale> oh, hehe
09:06:55 <Cale> There's someone who wants examples of fix?
09:07:09 <awesame> also, seeing a long list of zip2, zip3, made me suspicious of haskell right away
09:07:14 <gwern> hm. it has nothing to do with profiling, it seems
09:07:17 <mauke> > fix (const 42)
09:07:18 <lambdabot>  42
09:07:18 <gwern> dagnabbit shim!
09:07:19 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
09:07:20 <lambdabot>  3628800
09:07:27 <mauke> > zip4
09:07:28 <lambdabot>  Add a type signature
09:07:28 <vixey> mauke ooh!
09:07:28 <awesame> how can it have good abstraction mechanisms if they end up numbering functions in the standard library?
09:07:35 <vixey> that's a nice example
09:07:49 <Deewiant> @pl fix . const
09:07:49 <lambdabot> id
09:07:50 <mauke> ‚Äúcdaddr‚Äù
09:07:56 <ndm> awesame: sometimes the abstraction to fix such a pattern is more painful than the numbering
09:08:16 <ndm> awesame: and if you are using 4 element tuples, there is a fairly strong chance you are doing it wrong
09:08:56 * pjd_ notes ZipList, just for completeness
09:09:13 <gwern> didn't we have the same problem with printf taking varargs? why not apply the solution that fixed it to zips and liftms?
09:09:35 <Cale> gwern: people have tried that
09:09:42 <pjd_> gwern: Applicative
09:09:50 <Saizan> gwern: it's harder because the result type depends on the args
09:10:00 <simony> @src scanl
09:10:00 <lambdabot> scanl f q ls = q : case ls of
09:10:00 <lambdabot>     []   -> []
09:10:00 <lambdabot>     x:xs -> scanl f (f q x) xs
09:10:21 <Saizan> gwern: it works with some extensions and milliolegs however
09:10:29 <awesame> also, I guess foldl and friends are concatenated and abbreviated at least as badly as Python module names, and for the same reasons
09:10:38 <vixey> > tail $ scanl id 0 [1..]
09:10:39 <lambdabot>      Occurs check: cannot construct the infinite type: a = b -> a
09:10:39 <lambdabot>     Probabl...
09:10:44 <awesame> not sure what I'd do about those, though, long names would be obnoxious
09:10:48 <ndm> awesame: if tuples were inductive data structures, i.e. 3 tuple = ((a,b),c), then we probably wouldn't have the zip problem
09:10:50 <vixey> > tail $ scanl (+) 0 [1..]
09:10:50 <lambdabot>  [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276...
09:11:05 <vixey> > tail $ scanl (flip const) () [1..]
09:11:05 <lambdabot>   add an instance declaration for (Num ())
09:11:06 <lambdabot>     In the expression: 1
09:11:13 <gwern> Saizan: and it didn't become standard because those functions are supposed to be part of the haskell98 base?
09:11:20 <Cale> awesame: Those, I'm willing to put up with, at least until we get subscripts or something :)
09:11:25 <vixey> > tail $ scanl (flip const) undefined [1..]
09:11:25 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
09:11:55 <ski> ndm : though we'd probably need type pairs, i think
09:12:17 * ski ponders
09:12:18 <Saizan> gwern: mmh, well, you don't see that kind of type hackery in the standard libs anyway
09:12:23 <ndm> ski: i'm sure it could be done, and i don't think it requires anything more than desguaring (a,b,c) -> ((a,b),c)
09:12:33 <ndm> anyone know when GHC 6.10 is out?
09:12:49 <Saizan> inductive tuples -> HList, no?
09:12:53 <ndm> i have a program (Dr Haskell) that depends on GHC 6.9, so am eagerly awaiting it
09:13:00 <ndm> Saizan: HList = inductive tuples + pain
09:13:14 <Cale> ndm: Is this anything like Dr. Scheme?
09:13:16 <ndm> Saizan: inductive tuples, in the language, are a trivial syntax desugaring
09:13:17 <ndm> Cale: no
09:13:21 <ndm> @where drhaskell
09:13:22 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/drhaskell/
09:13:38 <Cale> Oh, right, that Dr. Haskell :)
09:13:51 <ndm> Cale: think of it as a newbie suggestion engine, which is actually rather good at fixing code even in TMR articles :)
09:14:40 <geezusfreeek> ndm: is it really just a desugaring and not a semantic change?
09:14:40 <Saizan> ndm: and how do you write the type of zipN ? or zipWithN if you prefer
09:14:41 <ndm> i.e. TMR 10 has maybe "message"  id, which should be fromMaybe "message"
09:14:42 <simony> can a [Char] be an instance of something?
09:14:48 <gwern> ndm: so it would do stuff like suggest 'foo (x:xs) = ...head (x:xs)' be turned into 'foo (x:xs) = ...x'?
09:14:54 <gwern> refactoring or someting?
09:15:03 <Cale> simony: With GHC extensions.
09:15:07 <ndm> geezusfreeek: its a semantic change in case of instances, but not otherwise
09:15:09 <simony> vixey, Thanks for the examples. The (1:) fix one is easy.,. I am trying to understand the (show) one though
09:15:09 <Cale> (and hugs extensions)
09:15:20 <ndm> Saizan: think of it as a half thought, rather than a full one :) - i have no idea
09:15:30 <ski> simony : if you have `where (b,c) = foo a c' then that can be rewritten using `fix' into `where (b,c) = fix (foo a . snd)'
09:15:44 <ndm> gwern: perhaps, but more usually things like "that is a fold", "id $! x" == "x" etc
09:15:44 <vixey> > iterate show ()
09:15:45 <lambdabot>  Couldn't match expected type `String' against inferred type `()'
09:15:49 <vixey> > iterate show ""
09:15:50 <lambdabot>  ["","\"\"","\"\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\\"\\\"\"","\"\\\"\\\\\\\"\\\\...
09:15:57 <geezusfreeek> well, what should zipping a list of pairs with another list do?
09:16:05 <Cale> simony: I think FlexibleInstances is the appropriate language option.
09:16:29 <Deewiant> > iterate show (show ())
09:16:29 <ndm> gwern: head (x:xs) isn't a known reactoring, but its the kind of thing that can be added
09:16:29 <vixey> fix f = last $ iterate f undefined
09:16:30 <lambdabot>  ["()","\"()\"","\"\\\"()\\\"\"","\"\\\"\\\\\\\"()\\\\\\\"\\\"\"","\"\\\"\\\\...
09:16:35 <gwern> ndm: oh. "It looks like you're using primitive recursion on a list! Would you like to use a map instead?"
09:16:47 <ndm> gwern: yes, it does have that
09:17:09 <gwern> ndm: now all it needs is a cheerful animated helper...
09:17:18 <simony> vixey, iterate show ""  starts from "".  fix doesn't "start" from anywhere..?
09:17:21 <awesame> ooo, maybe I need that
09:17:26 <ndm> gwern: http://www.cs.york.ac.uk/fp/darcs/drhaskell/Hints.hs - this is the list of suggestions it currently offers
09:17:36 <desegnis> Cale, FlexibleInstances just to have instance C String?
09:17:48 <vixey> simony, it's lazy, so it starts from the outermost
09:18:06 <vixey> simony, that's why it doesn't matter that there's no terminal
09:18:08 <Cale> "It looks like you're abusing the fact that ($) was shortsightedly defined to be right associative, would you like to use (.) instead?"
09:18:25 <ndm> (see redefined_map and special_map for the map bits)
09:18:39 <gwern> ndm: I don't quite follow - so the definitions to the right of the equals are the 'bad' ones?
09:18:42 <ndm> Cale: if you added such a rule, it would follow
09:18:43 <Cale> desegnis: Because you're not defining the instance for all lists.
09:18:48 <gwern> ie concat_map f x = concat (map f x)
09:18:53 <Cale> ndm: :)
09:18:57 <ndm> gwern: if you match something on the right, it gives you the message on the left
09:18:59 <gwern> seems to me it's better to use concatMap in that isntance
09:19:15 <gwern> ndm: ok
09:19:24 <simony> vixey, don't you have to see how show is defined to predict (fix show)? Wouldn't it not terminate under different (show) implementations?
09:19:31 <ndm> gwern: it matches concat (map f xs), then says "concat_map" at the user
09:19:42 <awesame> one problem I've had learning haskell is that because it's so different from other languages I've worked in, it's a lot more work to pick up the standard conventions
09:19:44 <vixey> fix f's termination depends on f, yes
09:19:48 <nominolo> > foldl f 0 [a,b,c]
09:19:49 <lambdabot>  Add a type signature
09:20:02 <nominolo> > foldl f x [a,b,c]
09:20:02 <lambdabot>  f (f (f x a) b) c
09:20:09 <vixey> > foldl (+) z [a,b,c,d,e]
09:20:10 <lambdabot>  z + a + b + c + d + e
09:20:12 <desegnis> Cale, ah ok
09:20:16 <awesame> if you're coming to ruby from python, you start out writing python-like code, but pretty quickly you pick up on how to do things better in ruby
09:20:18 <vixey> > foldr (+) z [a,b,c,d,e]
09:20:19 <lambdabot>  a + (b + (c + (d + (e + z))))
09:20:29 <lament> awesame: s/better/worse :D
09:20:40 <awesame> as you like
09:20:54 <pjd_> :t show
09:20:57 <lambdabot> forall a. (Show a) => a -> String
09:21:08 <vixey> > foldr (\x y -> show y) "" (repeat "")
09:21:09 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
09:21:18 <awesame> coming to haskell from anywhere non-functional plus a little scheme leaves me wondering whether I'm writing things in horribly obtuse ways all the time
09:21:48 <mauke> unsnoc :: [a] -> b -> ([a] -> a -> b) -> b
09:21:50 <pjd_> simony: show's return type is fixed, so the type of fix forces it to the String instance
09:21:52 <mauke> opinions?
09:21:56 <pjd_> :t fix
09:21:57 <lambdabot> forall a. (a -> a) -> a
09:22:05 <lament> awesame: as long as you don't have IORefs all over the place, it can't be THAT bad
09:22:10 <vixey> awesame: Just write the code that expresses what you intend, if it actually runs this is a useful coincidence
09:22:52 <byorgey> awesame: I know what you mean though.  I've been writing Haskell for a year and I still have that feeling sometimes =)
09:23:06 <desegnis> Cale, sorry I should know this, but how is show :: String -> String realized then?
09:23:18 <Cale> A hack!
09:23:20 <mauke> @src Show
09:23:20 <lambdabot> class  Show a  where
09:23:20 <lambdabot>     showsPrec :: Int -> a -> ShowS
09:23:20 <lambdabot>     show      :: a   -> String
09:23:20 <lambdabot>     showList  :: [a] -> ShowS
09:23:24 <Cale> :t showList
09:23:25 <lambdabot> forall a. (Show a) => [a] -> String -> String
09:23:42 <slava> why is String [Char?
09:23:54 <Zao> slava: Because it's a suitable representation.
09:23:57 <mauke> instance Show Char where ... showList = '"' : etc
09:23:58 <pjd_> String is a synonym for [Char]
09:24:00 <lament> slava: so you can use all the list-processing functions on strings
09:24:06 <pjd_> @src String
09:24:07 <lambdabot> type String = [Char]
09:24:10 <slava> that's not a very good reason
09:24:11 <lament> > map toUpper "hello"
09:24:12 <lambdabot>  "HELLO"
09:24:13 <lament> yes it is
09:24:18 <Cale> slava: because it's really convenient, and people didn't care for a long time about efficiency
09:24:23 * awesame points at showsPrec
09:24:26 <slava> why is it more convenient?
09:24:27 <Zao> slava: List processing is a fundamental concept in functional programming.
09:24:33 <Zao> Heck, lisp is named after it.
09:24:44 <lament> slava: map toUpper "hello" does not convince you? :)
09:24:49 <slava> map, etc should work sequence types other than lists
09:24:58 <mauke> slava: pfft, sequence types
09:25:03 <mauke> Functors!
09:25:03 <slava> it doesn't convince me at all because it just shows the library isn't polymorphic enough :)
09:25:14 <mauke> > map toUpper (Just 'h')
09:25:15 <lambdabot>  Just 'H'
09:25:17 <desegnis> Cale, doh... a hack really
09:25:24 <byorgey> slava: perhaps you want Traversable, then =)
09:25:24 <pjd_> slava: Haskell has fmap for that instead
09:25:26 <desegnis> thanks
09:25:27 <slava> anyway, given a string you could produce a lazy list of chars, and if you map over it then fusion should get rid of the intermedaite list no?
09:25:36 <awesame> I've been grumbling all week when I work with strings in python
09:25:37 <vixey> @let display string = ['"'] ++ concatMap (\c -> if c == '"' then ['\\', '"'] else [c]) string ++ ['"']
09:25:41 <lambdabot> Defined.
09:25:44 <vixey> > display "test \"string"
09:25:45 <lambdabot>  "\"test \\\"string\""
09:25:48 <vixey> > fix display
09:25:49 <lambdabot>  "\"\\\"\\\\\"\\\\\\\"\\\\\\\\\"\\\\\\\\\\\"\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\...
09:25:53 <lament> awesame: why?
09:26:01 <slava> @src fmap
09:26:01 <lambdabot> Source not found. :(
09:26:07 <awesame> String = [Char] is such a better idea than python's "characters are strings of length 1"
09:26:14 <pjd_> @src Functor
09:26:14 <lambdabot> class  Functor f  where
09:26:14 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
09:26:18 <slava> characters as strings of length 1 is dubious
09:26:32 <mauke> hey, it works fine in perl
09:26:37 <pjd_> characters are distinct from strings of length one
09:26:43 <pjd_> :t 'x'
09:26:44 <vixey> slava: sounds like you want an Object Oriented language
09:26:44 <lambdabot> Char
09:26:46 <pjd_> :t "x"
09:26:47 <lambdabot> [Char]
09:26:54 <lament> awesame: i'm not sure how useful the difference between 'x' and "x" is
09:27:01 <pjd_> "x" == ['x']
09:27:10 <slava> vixey: but haskell's type classes can express this just fine
09:27:18 <slava> it just so happens that the standard library is list-centric
09:27:26 <slava> i think its a bit unfortunate
09:27:27 <awesame> lament: neither was I, but working in both haskell and python, I get annoyed at python
09:27:51 <slava> lists are nice and inductive and all, but many operations like appending, mapping don't depend on specific properties of lists
09:28:08 <pjd_> slava: there's a lot of sentiment towards generalizing it
09:28:10 <pjd_> e.g.
09:28:13 <pjd_> :t (++)
09:28:14 <lambdabot> forall m. (Monoid m) => m -> m -> m
09:28:20 <slava> yup, that's a great idea
09:28:28 <pjd_> (that's lambdabot-specific)
09:28:30 <ski> > let return = getZipList . pure; ap x y = getZipList (ZipList x <*> ZipList y) in return (,,,) `ap` [0,1,2] `ap` [3,4,5] `ap` [6,7,8] `ap` [9,10]
09:28:31 <lambdabot>  [(0,3,6,9),(1,4,7,10)]
09:28:33 <ski> > let return = getZipList . pure; ap x y = getZipList (ZipList x <*> ZipList y) in (,,,) `liftM` [0,1,2] `ap` [3,4,5] `ap` [6,7,8] `ap` [9,10]
09:28:34 <lambdabot>  [(0,3,6,9),(1,4,7,10)]
09:28:34 <Cale> The list-centricness isn't as bad as one might think, because lists can be thought of as our general way to express iteration. A way of iterating over something is a function which turns it into a list.
09:28:51 <slava> Cale: right
09:29:06 <byorgey> slava: also, you have to realize that the Prelude was written like 20 years ago.  Since then there have been many advances in peoples' understanding of the ways all these things generalize.
09:29:23 <slava> byorgey: just like common lisp :)
09:29:28 <slava> dylan has a very nice collections protocol
09:29:49 <slava> @src Functor
09:29:49 <lambdabot> class  Functor f  where
09:29:49 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
09:29:52 <slava> could f be [] there?
09:29:56 <pjd_> yeah
09:30:04 <Cale> But yeah, there should be some generalisation here and there. I don't actually think that it's quite appropriate to generalise map to the point where it could be applied at types of datastructure which aren't polymorphic in their element type, but perhaps I'm wrong about that, and there's some clever way to use type functions there :)
09:30:07 <Gilly> If i have a type class like class Mult a b is there a way to say that if TypeA TypeB is an instance of that class then TypeB TypeA is also and provide defaults for the functions in the class?
09:30:14 <jewel> why did SPJ say ?I am now convinced that delimited continuations are a bad idea.??
09:30:15 <dcoutts> ibid: I sent you an email about it
09:30:16 <pjd_> i believe an earlier version of Haskell had map = fmap
09:30:23 <ibid> dcoutts: yeah, saw it
09:30:34 <vixey> jewel: Why?
09:30:35 <slava> Cale: i think it makes sense to generalize map to sequences but little else
09:30:41 <slava> Cale: trees perhaps?
09:30:42 <dcoutts> ibid: great, seem ok do you think? or any questions?
09:30:48 <Cale> slava: Functors :)
09:30:51 <vixey> jewel: oh, where is this?
09:30:52 <pjd_> slava: fmap captures that and more
09:30:53 <Cale> :t fmap
09:30:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:30:55 <slava> yeah, but i meant as far as conventional data types go
09:30:57 <pjd_> :t (.)
09:30:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:31:02 <Cale> hehe
09:31:06 <mauke> slava: why stop at sequences?
09:31:10 <awesame> slava: fmap covers basically all containers
09:31:11 <Cale> Function composition is an example :)
09:31:19 <awesame> containers with a polymorphic content type
09:31:21 <byorgey> Gilly: you might be able to do that, if you enable OverlappingInstances
09:31:21 <slava> function composition?
09:31:24 <pjd_> (that's another lambdabotism)
09:31:26 <jewel> vixey, http://www.brics.dk/~danvy/delimited-continuations-blues.pdf
09:31:27 <Cale> (which is why I think (.) should be generalised in exactly the same way as map)
09:31:31 <ibid> dcoutts: it's in the queue. ping me if you don't hear from me eventually (i'd say a week but you'd say that's too long so i'll just leave it vague:)
09:31:33 <slava> Cale: how could (.) be generalized?
09:31:36 <pjd_> slava fmap == (.) for functions
09:31:38 <byorgey> Gilly: instance (Mult b a) => Mult a b where ...
09:31:40 <mauke> slava: map == (.)
09:31:46 <vixey> ty jewel
09:31:50 <slava> i have trouble seeing why
09:31:52 <Cale> slava: The partially applied type constructor (->) e is a functor
09:31:54 <Gilly> byorgey: sounds nice
09:31:54 <dcoutts> ibid: ok, np :-)
09:31:58 <slava> Cale: oh
09:31:59 <Cale> slava: (basically the hom functor)
09:32:02 <slava> oh!
09:32:03 <slava> ok
09:32:06 <byorgey> Gilly: I'm not 100% sure it would work, but it's worth a try =)
09:32:12 <Gilly> byorgey: i'll test it :) thanks
09:32:13 <dcoutts> ibid: just checking that the fact that it's a company blog isn't a problem
09:32:30 <shepheb> lambdabot's "Caleskell" has map == fmap == (.)
09:32:31 <slava> @src filter
09:32:31 <lambdabot> filter _ []     = []
09:32:31 <lambdabot> filter p (x:xs)
09:32:31 <lambdabot>     | p x       = x : filter p xs
09:32:31 <lambdabot>     | otherwise = filter p xs
09:32:36 <slava> what are some ways to generalize filter?
09:32:44 <ibid> dcoutts: the concept as such, no. i haven't actuallly looked at it yet :)
09:32:50 <slava> map generalises as fmap, but you also have folds, filters, and possibly mapM
09:33:03 <shepheb> @index Foldable
09:33:03 <lambdabot> bzzt
09:33:07 <ibid> dcoutts: if it makes me go "ewww" i'll let you know:)
09:33:09 <shepheb> @hoogle Foldable
09:33:09 <lambdabot> Data.Foldable :: module
09:33:09 <lambdabot> Data.Foldable.Foldable :: class Foldable t
09:33:13 <slava> Cale: there's a lot of power here but it seems the prelude doesn't take advantage of it all
09:33:23 <slava> Cale: haskell2008 soon? :)
09:33:37 <dcoutts> ibid: ok :-), I don't think it'll make you barf :-)
09:33:40 <slava> is it just a case of type classes being ironed out after much of the prelude was already designed?
09:33:45 <dcoutts> ibid: we've got some pics of the hackathon
09:33:46 <Cale> slava: Sigh, at present it looks like Haskell' is really not being ambitious enough.
09:33:51 <vixey> filter = foldr (\x ys -> if f x then x `cons` ys else ys) nil
09:33:52 <byorgey> slava: there's also the tension between making the Prelude elegant and general, and making it accessible to people just learning the language.
09:33:57 <Cale> slava: Yes, that's part of it.
09:34:01 <slava> Cale: it seems ghc is the de-facto standard now
09:34:05 <vixey> replace foldr cons and nil with something more general
09:34:07 <dcoutts> http://blog.well-typed.com/
09:34:09 <lambdabot> Title: blog.well-typed.com
09:34:12 <slava> byorgey: you mean making the implementation accessible?
09:34:15 <slava> a beginner could still just use lists
09:34:16 <pjd_> :t let filter p = (>>= \x -> if p x then pure x else empty) in filter
09:34:17 <lambdabot> forall a (m :: * -> *). (Monad m, Alternative m) => (a -> Bool) -> m a -> m a
09:34:19 <Cale> slava: Plus the Haskell 98 committee was *really* opposed to polymorphism. The Haskell 1.4 prelude was *way* nicer.
09:34:19 <byorgey> slava: it wouldn't do to require people to understand the concepts of functors, Foldable, Traversable, etc. just to use basic Prelude functions
09:34:25 <byorgey> slava: no, just using it
09:34:30 <dcoutts> http://blog.well-typed.com/2008/04/hac4/
09:34:30 <lambdabot> Title: blog.well-typed.com ª Blog Archive ª Hac4: Haskell Hackathon in G√∂teborg
09:34:32 <slava> but if they stick with lists is there a problem?
09:34:36 <RayNbow> this channel sometimes goes way too fast... I keep mis-clicking on links :p
09:34:54 <slava> @src Alternative
09:34:54 <lambdabot> class Applicative f => Alternative f where
09:34:54 <lambdabot> 	empty :: f a
09:34:54 <lambdabot> 	(<|>) :: f a -> f a -> f a
09:35:03 <dcoutts> RayNbow: :-)
09:35:04 <Mr_Awesome> slava: their error messages would be unreadable
09:35:06 <byorgey> slava: maybe not if they're just using them, but as soon as they run into a type error or try reading the documentation...
09:35:11 <slava> good point
09:35:16 <slava> hmm
09:35:16 <pjd_> :t let filter p = (>>= \x -> if p x then return x else mzero) in filter
09:35:17 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => (a -> Bool) -> m a -> m a
09:35:22 <Cale> Language levels!
09:35:24 <pjd_> (alternatively)
09:35:30 <slava> Cale: what is Alternative?
09:35:52 <Cale> slava: It's something analogous to parser alternation
09:36:01 <Cale> slava: for general applicative functors
09:36:02 <byorgey> Cale: yeah, having several alternative standard libraries among which you could choose would be cool
09:36:05 <awesame> ndm: dr haskell was yours, right?
09:36:15 <slava> Cale: so a parser combinator might be an instance of Alternative?
09:36:16 <byorgey> making sure that each new level is a generalization of the previous
09:36:17 <ndm> awesame: yes, it still is mine
09:36:23 <Cale> slava: yep
09:36:32 <pjd_> slava: http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html
09:36:33 <lambdabot> http://tinyurl.com/yrwujr
09:36:33 <byorgey> i.e. "beginner", "intermediate", "expert", and "Oleg"
09:36:38 <Cale> slava: In fact, that's a rather nice way to design a parser library.
09:36:43 <awesame> ndm: reading Hints.hs was informative, so thanks!
09:36:52 <pjd_> slava: the paper that links to is a good read
09:36:59 <IsoPallo> What does it take to become "beginner"?
09:37:10 <ndm> awesame: no probs - i hope soon to have a new release which works properly, so that it can run those hints automatically over your code
09:37:17 <shepheb> hooray for hackathon pics!
09:37:18 <slava> is giving decent error messages with H-M type inference still an open problem?
09:37:43 <byorgey> IsoPallo: what do you mean? you are a beginner as soon as you begin. =)
09:37:52 <byorgey> shepheb: where?
09:38:03 <IsoPallo> Oh. Great.
09:38:13 <allbery_b> giving decent error messages is always an open problem.  (ever tried to debug code using c++ templates?)
09:38:14 <IsoPallo> I feel elevated.
09:38:15 <pjd_> slava: Applicative and Alternative are basically simpler generalizations of Monad and MonadPlus
09:38:24 <slava> ok
09:38:45 <shepheb> byorgey: linked above: http://blog.well-typed.com/2008/04/hac4/    -- HACKATHON PICS
09:38:45 <lambdabot> Title: blog.well-typed.com ª Blog Archive ª Hac4: Haskell Hackathon in G√∂teborg
09:38:50 <slava> allbery_b: yes, but c++ is not a good benchmark for anything :)
09:38:59 <byorgey> shepheb: oh, thanks, I must have missed that =)
09:38:59 <shepheb> it got lost in the spam a bit
09:39:00 <Cale> slava: It's more that once you generalise everything, it makes things a little more work for teachers to explain all the new concepts -- there are some people teaching basic FP courses who just want to work with lists and not worry about functors and so on.
09:39:08 <pejo> slava, check the work by Bastiaan Heeren for the current state of the art
09:39:17 <geezusfreeek> (.) == fmap == map == liftM == (<$>) == liftA
09:39:22 <allbery_b> C's only slightly better :)
09:39:24 <Cale> slava: But I think it would be more appropriate to provide a separate base package for those people :)
09:39:26 <shepheb> (also, the channel was quiet for an hour, and now it's flying. bah.)
09:40:01 <IsoPallo> By the way, is shadowing names in IO monad enough to make garbage collector collect tehm?
09:40:37 <desegnis> Cale, another way would be to force people to import the function of the generality they like (but that loses the handiness of a Prelude)
09:40:38 <JaffaCake> IsoPallo: shadowing isn't relevant, the object must be unreachable
09:40:53 <IsoPallo> Like does x <- foo >> x <- bar let foo go?
09:40:56 <conal> one sense of "beginner" is as in the zen notion of "beginner's mind" -- often more open to possibilities than an expert.
09:41:23 <JaffaCake> IsoPallo: if foo isn't reachable from anywhere else, it will be dropped after the x<-foo
09:41:25 <IsoPallo> Assuming nothing else has a pointer to it.
09:41:40 <Cale> conal: This is true, and it's actually how I'd prefer to teach things to people.
09:41:59 <roconnor> A better question is if after x <- foo, x is never used, is it even allocated in the first place?
09:42:08 <Cale> conal: But it seems that a lot of the people on the Haskell committees would disagree with this approach for some reason.
09:42:11 <ski> geezusfreeek : s/==/=/
09:42:19 <geezusfreeek> sure
09:42:25 <awesame> I definitely missed a lot learning not-too-generalized FP in scheme
09:42:54 <JaffaCake> Cale: it's a matter of balance - making Haskell accessible enough to teach, and yet powerful enough to keep the experts happy
09:42:55 <awesame> Haskell has been teaching me about fundamental-feeling abstractions I failed to notice before
09:43:08 <realspace> if i, for what reason ever, would like to convert different integers (WordX, Int, Integer, ..) is "fromIntegral x :: TargetInteger" the correct way?
09:43:10 <geezusfreeek> conal: are you conal elliot?
09:43:16 <shepheb> I found the \bot generalizations the geezusfreeek posted above very enlightening, but you have to know what each part does in the standard version before the deep connection can be revealed.
09:43:23 <mauke> realspace: yes
09:43:34 <realspace> mauke: thx
09:43:35 <ski> @type let filter p xs = do x <- xs; guard (p x); return x in filter
09:43:36 <lambdabot> forall t (t1 :: * -> *). (MonadPlus t1) => (t -> Bool) -> t1 t -> t1 t
09:43:43 <Twey> conal: Unfortunately quite often preconceptions exist for a reason :-)
09:43:44 <conal> geezusfreeek: yep, though i prefer two "t"s
09:43:50 <geezusfreeek> ah yes yes
09:43:58 <ski> that would be one general version of `filter' (though i'd prefer `MonadZero')
09:44:10 <geezusfreeek> cool, i've been working on a reactive library based on Reactive
09:44:19 <IsoPallo> JaffaCake: But is it the powerfulness or incomprehensibility that appeals to experts? I'm convinced that engineers use decibels just to confuse others, for example...
09:44:25 <awesame> also, reading "the craft of functional programming" circa 1997 did nothing for me, but learning even basic haskell now has been highly educational
09:44:41 <JaffaCake> IsoPallo: some of us experts prefer to keep our code readable :)
09:44:48 <conal> geezusfreeek: cool!  how's it going?
09:44:58 <geezusfreeek> i read somewhere that you had tried using stm but couldn't find a way to avoid nesting calls to atomically. i'm i remembering that right?
09:45:06 <awesame> so I feel like teaching the accessible stuff maybe fails to communicate anything really significant
09:45:14 <shepheb> I'm in the state of wishing I had an application to try the reactive stuff on, it looks very powerful.
09:45:29 <conal> geezusfreeek: yes, when wrapping in a pure interface.
09:45:57 <byorgey> awesame: you have to strike the right balance, which is tough.
09:46:25 <ski> pjd_ : oh, same as yours .. didn't notice it
09:46:34 <shepheb> that is why schools offer, for example, standard math classes, and more theoretical ones that cover the same material.
09:46:44 <pjd_> ski: but sweeter :)
09:47:16 <geezusfreeek> conal: what do you mean by pure interface? you do require io functions to create futures
09:47:20 <geezusfreeek> i am using stm
09:48:21 <geezusfreeek> i have it mostly working, actually, i just haven't added all the convenience functions
09:48:32 <conal> geezusfreeek: i mean having the future & frp combinators be io-free
09:48:53 <Cale> IsoPallo: For me at least, it has nothing to do with incomprehensibleness. It's about recognising very fundamental patterns in the way that things work.
09:48:55 <geezusfreeek> i have no calls to unsafePerformIO in my combinators :)
09:49:35 <conal> geezusfreeek: cool.  do you know what semantics your library implements?
09:49:51 <Cale> IsoPallo: decibels are a fairly arbitrary system -- especially the bit about using base 10 -- certainly not the one I would design for measuring loudness. :)
09:50:11 <geezusfreeek> honestly i have relied on the type system way too much so far, so it's not all tested, but i am pretty sure i am matching the semantics of Reactive pretty well
09:50:21 <geezusfreeek> except i don't have that odd race condition in mappend
09:50:30 <geezusfreeek> since it's all atomic!
09:51:35 <conal> geezusfreeek: if you check out my icfp submission, you'll see the denotational semantics i was going for, which the currently released Reactive *doesn't* implement.  the tricky bit was getting mappend to have determinate semantics.
09:52:00 * ski .oO( let ,(filter p `x) | p x = x )
09:52:13 <geezusfreeek> i read your paper, but i have not very throughly studied the semantics of what i have actually _implemented_ yet ;)
09:52:49 <geezusfreeek> my little test programs so far work great though
09:54:39 <conal> geezusfreeek: is your mappend on futures deterministic?  or does it depend on the scheduler.
09:54:45 <geezusfreeek> it is deterministic
09:54:58 <conal> geezusfreeek: even when two futures are simultaneous?
09:55:04 <geezusfreeek> futures are set inside atomic transactions
09:55:05 <geezusfreeek> yes
09:55:19 <conal> geezusfreeek: i'd like to see that.
09:55:19 <geezusfreeek> for that case i carry around a time
09:55:46 <geezusfreeek> i will be extending it a bit over the next week or two and then putting the code up somewhere
09:55:57 <geezusfreeek> (also checking that my semantics actually are correct)
09:56:15 <conal> geezusfreeek: cool.  if you'd like my feedback at some point, just let me know.
09:56:23 <geezusfreeek> i definitely would like feedback
09:56:29 <geezusfreeek> you have a lot more experience in frp than i
09:57:01 <vixey> are there examples of FRP I can try out and read?
09:57:42 <shepheb> conal: it seems like your semantics, when implemented, will remove a lot of the quirks of FRP-based GUI engines. is that an accurate impression?
09:57:57 <conal> vixey: if you want to get a flavor, you could check out the old fran tutorial -- http://conal.net/Fran/tutorial.htm .
09:57:57 <lambdabot> Title: Composing Reactive Animations
09:58:08 <vixey> thanks conal
09:58:15 <conal> shepheb: i don't know.  what quirks are you thinking of.
09:58:55 <geezusfreeek> anyway, it's time to go to work for now
09:58:58 <geezusfreeek> gbye
09:59:04 <conal> geezusfreeek: later
09:59:25 <conal> vixey: there are also examples in some of my old papers (http://conal.net/papers) and papers indirectly linked to at http://haskell.org/frp
09:59:25 <lambdabot> Title: Conal Elliott&#146;s Publications
10:01:11 <JaffaCake> straw poll: would anyone seriously object to removing the monomorphism restriction altogether?
10:01:43 <allbery_b> altogether?  how aout just inverting the default so those who want it can still have it?
10:02:01 <Cale> JaffaCake: no
10:02:03 * allbery_b is being frustrated by ghc builds on apparently non-core platforms.  again.
10:02:09 <Cale> JaffaCake: Turn it into a warning message.
10:02:11 <JaffaCake> I'm talking about in the language definition; of course it could be retained as an extension
10:02:23 <Cale> JaffaCake: It doesn't belong in the language definition.
10:02:38 <JaffaCake> Cale: thanks, I agree
10:03:01 <Cale> JaffaCake: The only real justification for its existence is based on a particular evaluation model of Haskell, and the language definition isn't meant to have evaluation-model specific things in it.
10:03:03 <sebell> Are we talking about Haskell'?
10:03:06 <allbery_b> in the language definition?  no, it doesn't realy belong there; it was a workaround for a particular implementation issue, not a fundamental language problem
10:03:14 <JaffaCake> Cale: right, exactly
10:03:20 <conal> i agree
10:03:20 <JaffaCake> sebell: yes
10:03:32 <sebell> Yeah, I would agree that it should be removed from the definition.
10:04:28 <lament> we (#haskell) generate so much noise about the new standard
10:04:34 <JaffaCake> there seem to be more people tripped up by its existence than would be affected by the occasional unexpected performance behaviour
10:04:38 <lament> is anybody here actually on the haskell' committee?
10:04:44 <JaffaCake> lament: yes :)
10:04:56 <JaffaCake> also dons
10:05:06 <sebell> JaffaCake: I agree, and implementations can be free to warn about it
10:05:50 <Cale> JaffaCake: I've also had really *really* annoying problems because of it. One time I wasted half an hour trying to work out why my ST computation was monomorphic in s, and it turned out that I'd not given a type signature to my quick definition of forM (before the libraries had forM)
10:06:22 <JaffaCake> Cale: yes, I've often had similar experiences
10:07:00 <JaffaCake> while I'm here, are there any other Haskell' issues anyone would like to bring up?
10:07:42 <Cale> JaffaCake: I'd like to see more polymorphism in the Prelude.
10:07:45 <Cale> Much more.
10:08:04 <JaffaCake> Cale: I'd like to see less stuff in the Prelude, actually
10:08:23 <conal> more polymorphism might lead to less stuff
10:08:43 <lament> JaffaCake:
10:08:44 <lament> :t map
10:08:45 <Cale> For instance, map, (.), liftM, fmap, etc. are all the same thing.
10:08:46 <JaffaCake> eg. map vs. fmap?
10:08:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:08:57 <vixey> @src liftM
10:08:57 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
10:09:02 <Cale> I've replaced some definitions in lambdabot ;)
10:09:08 <JaffaCake> so I heard :)
10:09:08 <Cale> :t (.)
10:09:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:09:11 <conal> JaffaCake: any chance of getting monad comprehensions back?  and map = fmap, (++) = mappend?
10:09:15 <roconnor> @type liftA
10:09:16 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
10:09:24 <Cale> Yeah, (++) should definitely be for Monoid
10:09:28 <roconnor> @type (<$>)
10:09:29 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:09:33 <vixey> but how did you notice that liftM is Cale?
10:09:42 <ski> JaffaCake : MonadZero,MonadPlus,MonadElse
10:09:50 <vixey> I can't imagine that could ever have occured to me...
10:09:52 <roconnor> MonadElse?
10:10:00 <Cale> vixey: Look at the type.
10:10:12 <ski> roconnor : instance MonadPlus Maybe
10:10:19 <mauke> I want a  Functor <: Applicative <: Monad  hierarchy
10:10:23 <Cale> JaffaCake: Also, no more fail!
10:10:26 <mauke> and Num without Eq and Show
10:10:30 <Cale> JaffaCake: Move fail into its own class!
10:10:31 <conal> i second mauke
10:10:40 <JaffaCake> so for (++), comprehensions, map etc.  there are arguments both ways... there's general agreement that we want both the general and restricted versions, but not much agreement on which should be the default
10:10:40 <ski> ale : indeed
10:10:45 <ski> s//C/
10:10:47 <Cale> JaffaCake: and define the do-translation like it was in Haskell 1.4
10:11:03 * vixey wishes #haskell would design a new fp language
10:11:10 <Cale> Also, ($) has had the wrong associativity all this time.
10:11:22 <roconnor> Cale: you should really write you own Haskell report.
10:11:25 <vixey> just boil haskell down to it's smallest parts
10:11:29 <roconnor> Cale:  you can totally scoop Haskell'
10:11:33 <Cale> ;)
10:11:42 <Cale> Don't think that it hasn't crossed my mind :)
10:11:52 <JaffaCake> Cale:  I'm not sure I agree about ($)
10:12:01 <JaffaCake> map f $ filter p $ xs
10:12:07 <shepheb> you couldn't look in the libraries without risking your sanity.
10:12:08 <Cale> JaffaCake: At present, f $ g $ h $ x is always the same as f . g . h $ x
10:12:18 <ski> $!
10:12:24 <Cale> (modulo precedence issues involving other operators)
10:12:44 <Cale> But there's no way to remove the parens from an expression like: f (g x) (h y) (k z)
10:13:03 <Cale> But if ($) had the opposite assoc. we could write f $ g x $ h y $ k z
10:13:11 <ski> foo $! bar x $ baz y  -- would be nice if this provided `foo' with two arguments
10:13:22 <JaffaCake> I think we want another operator for that
10:13:25 <shepheb> well, that's already taken
10:13:27 <Cale> Which makes more sense as well, since ($) is meant to represent function application, which is a left associative operation.
10:13:31 <Zao> ski: $! is taken though.
10:13:31 <shepheb> ski: ^^
10:13:39 <lament> JaffaCake: what are the arguments for keeping the less-polymorphic things like map in the library? Additional type safety?
10:13:39 <ski> Zao : that's the point
10:13:42 <Cale> $! also becomes more convenient.
10:13:45 <shepheb> what's wrong with a $$?
10:14:11 <Cale> The current associativity of $ adds nothing.
10:14:17 <ski> Zao,shepheb : the point was to make use of current `($!)' simpler
10:14:20 <shepheb> we get into "which is the default" arguments again, but I don't see why both can't exist.
10:14:23 <Cale> You can always replace the first n-1 instances of $ with .
10:14:34 <ski> no more `(foo $! bar x) $ baz y'
10:15:04 <Cale> Also, writing expressions using composition is outright better than using $ anyway
10:15:09 <JaffaCake> Cale: but I think f . g .h $ xs looks worse than f $ g $ h $ xs
10:15:20 <JaffaCake> I have to remember the relative associativities of . and $
10:15:23 <Cale> Composition is an associative operation, so f . g . h $ x effectively has more subexpressions
10:15:28 <Cale> So it's easier to refactor
10:15:43 <cjb> JaffaCake: I read someone's blog yesterday arguing exactly the opposite; that $ is too "heavy" a symbol to repeat so much :)
10:15:43 <Cale> And I've found that it even gets you thinking the right way more of the time.
10:16:11 <mauke> I agree with Cale on this
10:16:14 <JaffaCake> I do agree that $! isn't very useful
10:16:15 <ski> one could argue this is similar to `x^y^z' in math .. choose the interpretation that is not expressible simply with other means
10:16:17 <Cale> g . h is a well-typed expression in that, but g $ h is meaningless
10:16:31 <Cale> ski: Indeed!
10:17:08 <JaffaCake> I find it amusing that $ was in Haskell from the start, but was barely used for like 8 years
10:17:38 <Cale> Of course, it's an incompatibility that all the $-chains will have to be fixed, but if we're going to break the world, let's do it in style :)
10:17:39 <shepheb> took time to built up aversion to (  )s?
10:17:46 <vincenz> JaffaCake: a lot more people are doing pointless programming
10:18:07 <JaffaCake> vincenz: and this is a good thing or a bad thing, do you think? :)
10:18:44 <Cale> I think it's very much a good thing -- when points-free programming is appropriate, it's very appropriate.
10:18:49 <Botje_> I really like scheme's (cut ...) syntax
10:19:00 <Botje_> but it's probably hard to integrate within the grand haskell scheme of things :(
10:19:08 <Cale> Of course, points-free for the sake of points-free can be obnoxious.
10:19:14 <vixey> you mean SRFI-26?
10:19:34 <Cale> JaffaCake: Another thing I'd really like to see is something like Class Aliases.
10:19:39 <Botje_> could be, i only memorize irrational numbers :)
10:20:01 <vixey> I've never seen an example of that being an improvement over lambda terms or curried procedures
10:20:01 <JaffaCake> yup, we have a proposal for class aliases
10:20:21 <ski> it would be nice if classes could provide default instances for superclasses
10:20:31 <Cale> JaffaCake: I've really been convinced in the last month or so that (.) as functor application is not a bad idea.
10:20:34 <ski> e.g. default `Functor' from `Monad'
10:20:41 <JaffaCake> ski: there are some problems with that idea, see posts by ross
10:20:42 <quicksilver> JaffaCake: the nice thing about (a . b . c . d . e) x is that (b . c) is a valid subexpression.
10:20:50 <ski> JaffaCake : where ?
10:20:52 <Cale> JaffaCake: One of the things which convinced me the most was the translation of the fusion rule for fmap :)
10:21:02 <Cale> fmap (f . g) x == fmap f (fmap g x)
10:21:12 <quicksilver> JaffaCake: given a $ b $ c $ d $ e $ x,  you have that (b $ c) isn't even type-correct.
10:21:13 <Cale> If we unify (.) and fmap, that can be written as:
10:21:15 <quicksilver> (normally)
10:21:21 <Cale> (f . g) . x = f . (g . x)
10:21:23 <Botje_> @unpl uncurry id
10:21:23 <lambdabot> uncurry (\ a -> a)
10:21:23 <JaffaCake> ski: probably the haskell' list, I can't remember off hand
10:22:13 <ski> something with similar power to meachams superclasses would also be interesting
10:22:14 <Cale> Simultaneously making the fmap fusion law easier to remember, and providing a convincing argument for why that notation won't get out of hand :)
10:22:28 <paczesiowa> @seen dcoutts
10:22:28 <lambdabot> I saw dcoutts leaving #haskell-soc, #gentoo-haskell, #haskell and #ghc 41m 59s ago, and .
10:22:44 <ski> JaffaCake : ok, maybe i'll take a look there, later
10:22:47 <Cale> (the functor is always determined by the last term in the chain of (.)'s)
10:23:01 <Cale> hmm.. what else...
10:23:23 * JaffaCake makes a note of all these suggestions
10:23:26 <shepheb> well, what else does \bot do
10:23:27 <Cale> Oh, another thing is of course that signum and abs are in Num and that Eq and Show are superclasses
10:23:48 <Cale> Which makes it painful to define a lot of useful instances of Num
10:23:51 <ski> hm .. maybe `Eval'
10:24:11 <JaffaCake> yes... actually we're deferring most of the library issues for now, dealing with the language itself first
10:24:36 <JaffaCake> ski: you want to bring back the Eval class?
10:24:39 <Cale> Another is the simple fact that the instance of functor and monad for (->) e isn't in the Prelude.
10:24:55 <Cale> (But that's another library issue)
10:25:01 <ski> JaffaCake : i'm not sure .. but i think it could be considered
10:25:07 <sclv> Monads having fail vs. a MonadFail type thing is a bit of both, because it affects do notation translation.
10:25:15 <ski> (maybe `seq' is a lost cause in haskell ..)
10:25:26 <aFlag> Hello, does anyone know about examples of monad definitions with proof that their >>= and return work as they should? So I can have a feel about how those proves go.
10:25:45 <JaffaCake> ski: personally I hate that we have lifted functions, but I think the alternative is worse
10:25:51 <ski> sclv : "a bit of both" ?
10:26:09 <ski> JaffaCake : that might well be
10:26:28 <sclv> a bit of a library/classes issue, a bit of a core language issue.
10:26:33 <Cale> It would be nice if seq could be made such that it applied to everything but functions.
10:26:41 <Cale> (maybe)
10:26:56 <Cale> Maybe not such a great idea though...
10:26:57 <JaffaCake> and polymorphic values, then?
10:26:59 <Cale> yeah
10:27:01 <Cale> exactly
10:27:17 <JaffaCake> I've considered that too.. maybe not such a bad idea
10:27:32 <JaffaCake> but you have to be clear about how type information propagates
10:27:37 <Cale> It's hard to say what should be done with polymorphic values, and I think that kills it.
10:27:57 <JaffaCake> there'd be no way to define a strict list type
10:28:23 <ski> (possibly `seq' only makes sense for inductive sum types, not coinductive product ones)
10:28:34 <Cale> Oh, it would be nice if we had something like rnf, but more thorough.
10:28:46 <JaffaCake> Cale: and polymorphic?
10:28:55 <Cale> Possibly...
10:29:02 <JaffaCake> I've been talking about how to do that with andyjgill
10:29:11 <Cale> I don't know how good it is to encourage lots of strictness annotations, as people really do go overboard with them.
10:29:23 <JaffaCake> we want it so that the second time you do rnf it completes immediately
10:29:25 <Cale> But when you really do need these things, it'd be nice to have them.
10:29:54 <hysterio> hello, is there a function that `maps` 2 levels deep? something like map2x (1+) [[1,2,3,4],[5,6,7,8]] -> [[2,3,4,5],[6,7,8,9]]
10:29:54 <hysterio> my head hurts now
10:30:00 <Cale> I think laziness has almost been underappreciated in recent years.
10:30:07 <andyjgill> There is a who class of space leak problems you could squash with a deepseq.
10:30:08 <vixey> > map (1+) [2,3,4,5]
10:30:09 <Cale> hysterio: map (map (1+))
10:30:10 <lambdabot>  [3,4,5,6]
10:30:14 <ski> > map (map (2*)) [[1,2,3,4],[5,6,7,8]]
10:30:15 <lambdabot>  [[2,4,6,8],[10,12,14,16]]
10:30:19 <vixey> > map (map (1+)) [[2,3,4,5],[6,7,8,9]]
10:30:19 <lambdabot>  [[3,4,5,6],[7,8,9,10]]
10:30:25 <Deewiant> > (map . map) (1+) [[1,2,3,4],[5,6,7,8]]
10:30:26 <lambdabot>  [[2,3,4,5],[6,7,8,9]]
10:30:27 <shepheb> whoa, someone implemented `it'?
10:30:35 <cjb> Cale: you mean the twenty most-recent years, right?  :)  laziness isn't particularly new.
10:30:38 <Cale> andyjgill: That's often overkill though.
10:30:49 <hysterio> coolness! that was fast guys
10:30:53 <hysterio> thanks!
10:30:59 <Cale> cjb: Yes, but in the earlier days of Haskell, it seemed that it was more the focus of the language.
10:30:59 <vixey> > (map.map) (1+) [[2],[3]]
10:31:00 <lambdabot>  [[3],[4]]
10:31:06 <andyjgill> Yes, but in the correct place, it fixes a large class of problems.
10:31:14 <Deewiant> >(map map map) (1+) [[2],[3]]
10:31:26 <Deewiant> > (map map map) (1+) [[2],[3]]
10:31:26 <lambdabot>  [[3],[4]]
10:31:28 <orzo> how old is haskell
10:31:28 <vixey> > ((.).(.)) [[2],[3]]
10:31:29 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
10:31:30 <Cale> andyjgill: I agree that it does -- I just caution about how much we apply that sledgehammer.
10:31:41 <ski> > join (.) map (2*) [[1,2,3,4],[5,6,7,8]]  -- noops :)
10:31:42 <JaffaCake> Cale: to some extent I agree, but I have memories of long hours debugging space leaks in GHC where the fix was a correctly-placed seq
10:31:42 <lambdabot>      Occurs check: cannot construct the infinite type: a = f a
10:31:42 <lambdabot>       Expected...
10:31:42 <Deewiant> vixey: no function. :-)
10:31:52 <vixey> > ((.).(.)) (+1) [[2],[3]]
10:31:52 <lambdabot>  [[3],[4]]
10:32:08 <vixey> hehe
10:32:24 <JaffaCake> Cale:  and the fix is always fragile, a deepSeq would be less so
10:32:34 <Cale> JaffaCake: I've started to develop a fairly useful mental model that I really should write about at some point.
10:32:34 <andyjgill> The big place is finite maps, where you add something, and it is added in a lazy way.
10:32:40 <astrolabe> I imagine lots of us have had JaffaCake's experience?
10:33:10 <astrolabe> Cale: Please do!
10:33:15 <Cale> andyjgill: Oh, yeah, data structures certainly need some support for laziness or strictness as necessary.
10:33:45 <andyjgill> I just want to know what I get back from some calls are *values* not *thunks*.
10:33:47 <Cale> I've thought about the possibility of using the Strategies idea for data structures like Data.Map
10:33:49 <shepheb> someone implemented `it' in \bot?
10:34:20 <Cale> So that various higher order functions on the structure would take a Strategy, along with the usual parameters
10:34:40 <Cale> (of course, you'd probably want specialised versions of the common cases)
10:35:32 <Cale> Control.Parallel.Strategies was underappreciated for a long time because the GHC documentation was literally empty for a long while.
10:35:44 <JaffaCake> I think we should declare that the past tense of 'seq' is 'suck'
10:36:07 <astrolabe> Would the strategy be propogated to contained structures, or would they have their own?
10:36:26 <shepheb> > 1
10:36:27 <lambdabot>  1
10:36:29 <shepheb> > (+1)
10:36:30 <lambdabot>  <Integer -> Integer>
10:36:34 <shepheb> bah
10:36:55 <Cale> Anyway, my idea about recognising the points where strictness is needed is that the only places that you want strictness are when you're collapsing large structures into small ones by summarising all the components of the large structure. (By 'large' and 'small' here, I mean in terms of separately-evaluable components)
10:37:06 <shepheb> thought I saw someone do that above, guess I got confused in the rush the firehose a newbie question with answers.
10:37:19 <shepheb> s/rush the/rush to/
10:37:20 <Cale> This is what makes foldl' such a useful case.
10:37:51 <andyjgill> I'm all for Strategies, but I do not want to know the details about a specific data structure, I just want a value, sometimes.
10:38:06 <Cale> It's also what makes lazy programming so much fun, because all the rest of the time, you either really want laziness, or it makes no difference.
10:38:28 <JaffaCake> Cale: what about those structures that simply hold on to unevaluated data in the parts that you never look at?  you want strictness earlier, not later
10:38:53 <bparkis> recurrence relations don't have to specify a "base case"
10:38:59 <bparkis> they could specify a case that is not a base
10:39:02 <vixey> Cale, and it can be pretty mindbending too!
10:39:14 <Cale> JaffaCake: well, the only case where unevaluated data is a problem is when the expressions are large.
10:39:44 <cjb> Cale: it might be fun to have a gtk2hs program that lets you give a map/fold expression and see a visualization of the data flow
10:39:47 <Cale> JaffaCake: and the only way to get large expressions is by repeatedly applying functions to collapse other bits of data (otherwise it's just some constant)
10:39:52 <JaffaCake> yes, but that's like saying the only time that space leaks are a problem is when they're large
10:40:03 <vixey> > map f [x,y,z]
10:40:03 <lambdabot>  Add a type signature
10:40:09 <vixey> > map f [x,y,z] :: [Expr]
10:40:10 <bparkis> e.g. a_n = a_{n-1} + a_{n-2} can be specified by a_3 = 2 as well as by a_0 = 0
10:40:11 <lambdabot>  [f x,f y,f z]
10:40:23 <roconnor> the only time that space leaks are a problem is when they're large
10:40:24 <bparkis> well, a_3 = 2 and a_4 = 3
10:40:25 <astrolabe> I suppose if you are going to look at the data eventually, there is normally no harm in evaluating it now.  But if you never are going to look at it, there might be a trade off between the cost of an unnecessary evaluation, and the cost of carrying around a heavy thunk.
10:40:31 <bparkis> as well as by a_0 = 0 and a_1 = 1
10:40:33 <Cale> So in order to get such a data structure holding thunks like that, you must have done something to a large bunch of data which collapsed it to a small piece of data.
10:40:44 <Jaak> > map f [x ..] :: [Expr]
10:40:46 <lambdabot>  Exception: not a number
10:40:56 <Cale> (where by large and small, I'm again referring to the number of components which could in principle be separately evaluated)
10:40:59 <JaffaCake> Cale: like fst?
10:41:06 <vixey> @instances Num
10:41:07 <lambdabot> Double, Float, Int, Integer
10:41:10 <Cale> JaffaCake: hm?
10:41:15 <Cale> JaffaCake: like sum
10:41:17 <bparkis> so I wonder the extent to which this could be applied to other recurrences
10:41:25 <JaffaCake> lets take fst, it's simpler
10:41:55 <Cale> okay, but fst doesn't usually collect up in thunks in large numbers.
10:42:16 <bparkis> like you could specify f (x:xs) = x + f xs and specify f [1,2,3] = 6
10:42:24 <bparkis> instead of specifying f [] = 0
10:42:25 <JaffaCake> I don't think I agree with that
10:42:29 <orzo> why is Word8 distinct from CChar?
10:42:39 <Cale> (like sum in the sense that a large number of occurrences of (+) are built)
10:42:49 <JaffaCake> Cale: fst is a *big* cause of space leaks
10:43:02 <JaffaCake> we have special optimisations to deal with it
10:43:26 <Cale> hmmm
10:43:51 <Cale> Can you give an example?
10:44:20 <JaffaCake> let x = (small, big) in  Just (fst x)
10:44:20 <bparkis> then f [1,2,3] = 6 = 1 + f[2,3] = 1 + 2 + f[3] = 1 + 2 + 3 + f[]
10:44:25 <bparkis> so then f [] = 0
10:45:08 <Cale> JaffaCake: What sort of type would 'big' be here?
10:45:19 <bparkis> so sometimes you can specify cases that aren't "base cases"
10:45:22 * roconnor doesn't get JaffaCake's example
10:45:27 <Cale> Integer, say? (For concreteness sake)
10:45:44 <JaffaCake> Cale: anything that holds on to a large data structure
10:46:32 <orzo> how is it a space leak?
10:46:39 <Cale> Ah, I see what you're saying.
10:47:06 <JaffaCake> orzo: well until you seq the (fst x) thunk, 'big' will be retained in the heap
10:47:17 <Cale> orzo: If the fst is not evaluated, then big can't be gc'd, in which case the thing which big is pointing to can't be gc'd
10:47:24 <bparkis> and the actual base cases can be inferred
10:47:52 <ski> bparkis : yes  (but what brought this on now ?)
10:48:39 <JaffaCake> Cale: in fact this particular case won't cause a problem because we handle projections specially, but you can construct more complex cases that do cause problems
10:48:48 <bparkis> one thing to ask is, under what conditions can they be inferred?
10:48:53 <ski> Cale : consider a backtracking alternative in a monadic parsing library
10:48:59 <Cale> ski: right.
10:49:34 <Cale> So perhaps my point about summarization isn't always true :)
10:49:54 <ski> bparkis : well, in the case of linear recursion, i think it's just that the step should be invertible (for suitable inputs)
10:50:23 <roconnor> big things only become big because of sharing right?  I mean, big wouldn't be any bigger than the code that created it unless something else has forced big to be expanded out in to it's big thing.
10:50:30 * roconnor wonders if I am making sense.
10:50:35 <astrolabe> > fst(last as, as) where as = [1..10000]
10:50:35 <lambdabot>  Parse error at "where" (column 18)
10:50:38 <ski> bparkis : or are you talking about machine-inferred in a programming language ?
10:50:56 <astrolabe> >let as = [1..10000] in fst(last as,as)
10:51:01 <astrolabe> > let as = [1..10000] in fst(last as,as)
10:51:02 <lambdabot>  10000
10:51:13 <bparkis> yes, machine inferred
10:51:20 <Cale> roconnor: this is true.
10:51:24 <roconnor> astrolabe: right, so that expression isn't very big when fst remain unevaluated.
10:51:40 <roconnor> and it isn't very big after fst is evaluated.
10:51:59 <astrolabe> roconnor: You make sense to me, but that isn't necessarily a complement.
10:52:00 <ski> bparkis : it's an interesting problem, i think ..
10:52:11 <bparkis> another possibility is specifying functions by giving examples of their behavior and demanding that they be sufficiently simple
10:52:12 <roconnor> and I hope it isn't very big during evaluation
10:52:15 <Cale> roconnor: I think the idea is that we're in a larger context in which big is some expression that is causing a large data structure to be retained.
10:52:38 <Cale> (which indeed probably got evaluated because of sharing)
10:52:42 <bparkis> you can completely specify a fourth degree polynomial, for instance, by specifying its behavior on five input values, so long as you know it is fourth degree
10:52:47 <ski> bparkis : i wonder if there's any nice example for some inductive tree type (instead of Integer or Real)
10:53:28 <roconnor> Cale: so instead of making fst strict, one could also solve the problem by reducing sharing?
10:53:32 <bparkis> maybe you could rank functions by how "complicated" they are and say, I want a function that is no more complicated than "10," that has the following behavior on the following inputs and outputs
10:53:36 <Cale> roconnor: yep
10:53:37 <astrolabe> I don't think my example will give a problem :(
10:53:38 <ski> bparkis : yes, e.g. inductive logic programming
10:53:48 <bparkis> and then give 10 examples inputs and 10 outputs
10:53:56 <Cale> roconnor: There might be reasons why that's not desirable of course.
10:54:14 <roconnor> of course, I'm just exploring alternatives.
10:54:15 <Cale> roconnor: For instance, maybe in some cases, we're not going to end up applying fst, and we really want the shared copy.
10:54:28 <bparkis> and the compiler spits back a function definition that produces those outputs on the given inputs, where the definition is sufficiently simple (no more than complexity "10")
10:54:32 <Cale> It's something which really has to be tackled on a case-by-case basis I think.
10:54:43 <JaffaCake> roconnor: imagine the large data structure being retained is a Data.Map which you use in lots of places
10:55:20 <bparkis> so I might say "f [1,2,3] = 6, f[3,8] = 11, f[8,9,10,4] = 31" and ask for f
10:55:31 <bparkis> given that f is of a certain specified simplicity
10:55:48 <Cale> I think the worst problem we have in lazy programming is the lack of good documentation which *really* gets into the practical performance issues like this. They're usually not that hard to spot once you're used to things, but it's hard to become used to things without just programming for 3 or 4 years.
10:55:53 <roconnor> JaffaCake: okay, but it is a bit hard for me to imagine that such a large data structure used in lots of places is now only being held up from GC by a little unevaluated fst somewhere.
10:56:13 <JaffaCake> http://homepages.inf.ed.ac.uk/wadler/papers/leak/leak.ps
10:56:36 <JaffaCake> roconnor: believe me, it happens a lot
10:56:50 <roconnor> JaffaCake: of course, if the map is being updated, and is shared, then it becomes more confusing to me.
10:57:00 <JaffaCake> go look at some of the early heap profiling papers by Runciman and co.
10:57:14 <ski> bparkis : if you search for `inductive functional programming' or `inductive logic programming' you might find some related (though maybe not exact same) things
10:57:33 <JaffaCake> roconnor: perhaps the map is not being updated, it's just a big lookup table
10:58:00 <roconnor> JaffaCake: if it is a big lookup table that is used everywhere, it sounds like it will last for the entire execution of the program.
10:58:01 <JaffaCake> e.g. the symbol table in a compiler
10:58:23 <JaffaCake> well, perhaps each pass of the compiler builds a new symbol table
10:58:28 <Cale> To be honest, GHC's heuristics for this sort of thing are good enough that I hardly ever run into issues with things being retained. It's far more common that I need explicit strictness because the built-up expressions are getting so large that they kill the stack when evaluated.
10:59:27 <astrolabe> I've had heap overflows.
10:59:32 <JaffaCake> Cale: GHC is littered with strictness annotations to fix these kinds of things
10:59:58 <Cale> JaffaCake: Are they all still needed, I wonder?
11:00:04 <JaffaCake> good question
11:00:16 <gbacon> I'm using HXT and XPath to find elements in an XML document. I'm chaining arrows with $<, but I'm threading values down and then back up with constructions of the form ... >>> pure ((,...,) a b ... n). How can I cut out the boilerplate?
11:00:22 <JaffaCake> I'm sure some subset of them are not needed, but it's impossible to figure out which
11:00:29 <astrolabe> heh
11:01:07 <Cale> JaffaCake: hehe, I think someone invented a tool for that :)
11:01:09 <astrolabe> Does the set of needed sets have a minimal element?
11:01:23 <Cale> JaffaCake: But applying it to the whole GHC codebase would be rather impractical :)
11:01:39 <byorgey> especially since it is O(2^n) in the number of strictness annotations ;)
11:01:55 <Cale> Doesn't it use genetic algorithms?
11:02:04 <byorgey> oh, maybe we're thinking of different tools
11:02:07 <gbacon> astrolabe: attrs of some elements influence XPath expressions downstream
11:02:17 <JaffaCake> but the point is, the extra strictness annotations don't usually do any harm, and the set of strictness annotations you need varies from time to time
11:02:27 <Cale> Maybe I'm just confusing the real tool with a discussion about a possible one
11:03:19 <bparkis> yes that is inductive logic programming
11:03:20 <Cale> JaffaCake: This is true, but I generally think it's worth it for the convenience of being able to carry around expressions without evaluating them.
11:03:38 <JaffaCake> by 'it' you mean laziness?
11:03:43 <Cale> yes
11:03:51 <JaffaCake> oh, I'm not arguing against that :)
11:03:58 <Cale> JaffaCake: I'm probably biased due to the sorts of programs I write, but I've generally had *huge* wins from laziness.
11:04:07 <JaffaCake> sure, and we do in GHC too
11:04:16 <Cale> And space leaks and so on have only been minor issues for me.
11:04:18 <JaffaCake> interface files are loaded lazilly
11:04:35 <Cale> I've done lots of combinatorial search stuff where laziness is almost made for it.
11:04:56 <JaffaCake> strict languages have space leaks too
11:05:01 <Cale> That's true :)
11:05:10 <Cale> And they have infinite loops that we don't have
11:05:30 <JaffaCake> yes, and in some cases they have more space leaks
11:05:41 <Cale> Strict languages end up building things which aren't needed.
11:05:42 <visof> .join #haskell-blah
11:05:55 <Cale> (and programmers adjust for it by turning their programs inside-out)
11:06:02 <JaffaCake> yep
11:06:16 <roconnor> Cale: what do you mean by inside out?
11:06:34 <Cale> roconnor: Consider for example the isInfixOf function
11:06:39 <Cale> @src isInfixOf
11:06:39 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
11:06:40 <aFlag> is there a strict implementation for haskell?
11:06:46 <Cale> Not a great example, but it'll do.
11:06:48 <JaffaCake> writing explicit stream processos
11:07:07 <desegnis> aFlag, er, Haskell has non-strict semantics
11:07:09 <Cale> Here, it builds the list of tails, then checks if any has the needle as a prefix.
11:07:16 <Cale> You would not do that in a strict language.
11:07:30 <geezusfreeek> to make a strict algorithm lazy you basically have to drive it from the outside rather than use the language's normal recursive function calls, like writing your own small interpreter almost
11:07:38 <Cale> (because building the whole list of tails is stupid)
11:07:40 <roconnor> in a strict language tails would return an iterator?
11:07:49 <astrolabe> I find lazy solutions harder to invent, even when they are simpler.
11:08:01 <Cale> roconnor: Yeah, okay, you can incorporate lazy datastructures into strict languages.
11:08:05 <roconnor> and any would consume an iterator.
11:08:08 <JaffaCake> roconnor: right, iterators are a hack to work around the lack of laziness
11:08:22 <Cale> roconnor: But what's more common is you end up with a pair of loops.
11:08:22 <roconnor> JaffaCake: how are they a hack?
11:08:32 <drigz> is there a canonical way of converting an integer to a binary string?
11:08:39 <drigz> i reimplement it every time and it's always ugly
11:08:49 <Cale> roconnor: So that you can bail out early.
11:08:54 <astrolabe> JaffaCake: That's a nice way of looking at it.
11:08:55 <sethk> drigz, why don't you reuse your earlier implementation?
11:08:58 <JaffaCake> roconnor: in the sense that given the right language, you don't need iterators
11:09:04 <mauke> drigz: Data.Binary.Put
11:09:20 <drigz> sethk: i tend to end up writing it in ghci
11:09:30 <astrolabe> Pointers and references generally are the same kind of hack I guess.
11:09:34 <sethk> drigz, don't end up writing it in ghci.  :)
11:09:53 <drigz> mauke: maybe you already understood but i mean as in "01011011"
11:10:14 <Cale> > showIntAtBase 2 intToDigit 570 ""
11:10:14 <lambdabot>  "1000111010"
11:10:18 <roconnor> Numeric.showIntAtBase 2 ("0","1"]!!) 1234 ""
11:10:19 <drigz> sethk: i ask more for the sake of elegance rather than practicality
11:10:23 <astrolabe> Although, for general graphs (rather than trees), I guess you need to be explicit about having references.
11:10:29 <roconnor> > Numeric.showIntAtBase 2 (["0","1"]!!) 1234 ""
11:10:30 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
11:10:36 <bd_> > replicateM 10 "01" !! 570
11:10:37 <lambdabot>  "1000111010"
11:10:46 <Cale> bd_: hehe :)
11:10:48 <roconnor> > Numeric.showIntAtBase 2 ("01"!!) 1234 ""
11:10:48 <lambdabot>  "10011010010"
11:10:55 <drigz> bd_: i like yours best
11:11:02 <drigz> but Cale and roconnor - thank you very much!
11:11:02 <mauke> hahaha
11:11:02 <bd_> drigz: mine is slow though :)
11:11:05 <roconnor> on right intToDigit
11:11:08 <aFlag> bd_, wow, that looks fancy
11:11:08 <bd_> O(n)
11:11:17 <roconnor> that's much more sane
11:11:19 <drigz> bd_: i thought we have an optimising compiler for that? :p
11:11:19 <mauke> > replicateM 10 "01"
11:11:20 <lambdabot>  ["0000000000","0000000001","0000000010","0000000011","0000000100","000000010...
11:11:29 <Cale> drigz: Of course, bd's has a limitation that it's fixed width.
11:11:42 * bd_ votes to add a rewrite rule for replicateM n s !! to the standard library
11:11:57 <Cale> (and O(n) for having to traverse the list, rather than O(log n))
11:11:59 * mauke votes to add %b to printf
11:12:02 <drigz> Cale: my current need is fixed width, actually. it's perfect :D
11:12:02 <roconnor> bd_: that's a pretty nice way of doing fixed width.
11:12:15 * roconnor votes to add showBin to Numeric.
11:12:32 <roconnor> actually, adding showBin is probably a really good idea.
11:12:34 <Cale> drigz: If you need all the binary strings though, it's the way to go.
11:13:21 <gnuvince> :t replicateM
11:13:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
11:13:34 <drigz> Cale: yeah, i'd gotten as far as sequence . replicate on my own, knowing that sequence did the cartesian product, but i hadn't thought of that
11:14:40 <drigz> unfortunately, i haven't gotten a good opportunity to show off things like that in my latest attempt to do my c++ homework in haskell, since the only actual programming problem needed unsafeCoerce
11:14:43 <Cale> JaffaCake: I'm assuming that adding a nice polymorphic record and variant system would be best left to start its life as a GHC extension :)
11:14:45 <drigz> which didn't end up pretty
11:14:58 <JaffaCake> Cale: quite
11:15:21 <Cale> JaffaCake: I wanted to add something based on Daan's semantics, but GHC is too big and confusing for me :)
11:15:26 <JaffaCake> Cale: I'd really like to see that, actually
11:15:41 <JaffaCake> i.e. some improved record system, not necessarily Daan's
11:16:09 <Cale> Well, Daan's has terrible syntax, but I think everything else about it is great.
11:16:13 <roconnor> anyone have a head build of GHC to patch Numeric with showBin and readBin?
11:16:20 <Cale> It doesn't need lacks predicates, for one. :)
11:16:38 <byorgey> drigz: yikes.  what was the problem?
11:16:42 <yav> Cale: what is wrong with lacks predicates?
11:17:28 <roconnor> JaffaCake: ML people argue that they can add laziness when they need it.  I find it had to argue they are wrong.
11:17:32 <Cale> yav: They're a bit clunky to work with.
11:17:39 <drigz> byorgey: access the internal representation of a float to show its binary representation
11:17:47 <yav> Cale: ?
11:17:51 <JaffaCake> roconnor: I don't :)
11:17:52 <drigz> specifically, IEEE float
11:18:06 <mauke> drigz: can be done with Storable, I think
11:18:09 <byorgey> drigz: ah, yikes.
11:18:11 <roconnor> JaffaCake: okay, I'll pretend to love ML.
11:18:29 <JaffaCake> so the problem is that lazy expressions have a different type in ML
11:18:42 <Cale> yav: Type signatures have to mention that the incoming record doesn't already have any fields which they want to add. Sometimes you want to say "I don't care if it already has x or not, x should be this thing here."
11:18:58 <roconnor> JaffaCake: how is that a problem, it lets the user know what to expect about the runtime behavour.
11:19:43 <aFlag> hm, I don't think I'm understanding that replicateM code
11:19:43 <roconnor> JaffaCake: typeclass polymorphism allows you to abstract out similar functionality with different data types.
11:19:54 <drigz> mauke: it might not need the word unsafe, but I think it will come out even less pretty...
11:19:59 <aFlag> why does sequence ["01","01"] gives me ["00","01","10","11"]?
11:20:26 <byorgey> drigz: well, accessing the actual internal representation of a float isn't pretty.
11:20:31 <byorgey> =)
11:20:33 <yav> Cale: like when?
11:20:38 <drigz> byorgey: i know, we're engineers
11:20:40 <aFlag> I looked at sequence's code, but I think I didn't really understand what it does, it looked to me that it did something like "01" >> "01" in that case
11:20:43 <drigz> i'm a mathematician in denial
11:20:46 <Cale> yav: I think Daan's proposal of allowing multiple fields with the same name (and preserving their order like a stack) is a rather elegant way to deal with things, as it means that something which wants to add and later remove something from a record doesn't have to worry about whether the record already has that label, and they're going to stomp over it.
11:20:47 <byorgey> hehe
11:21:09 <roconnor> aFlag: sequence ["01","01"] == [[x,y] | x<-"01", y<-"01"]
11:21:10 <desegnis> aFlag: sequence collects the results in a list
11:21:14 <roconnor> > [[x,y] | x<-"01", y<-"01"]
11:21:15 <lambdabot>  ["00","01","10","11"]
11:21:24 <byorgey> @src sequence
11:21:24 <lambdabot> sequence []     = return []
11:21:24 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
11:21:24 <lambdabot> --OR
11:21:24 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
11:21:52 <yav> Cale: no need to worry about anything :-)  It is just ordinary types.
11:22:03 <byorgey> sequence ("01":["01"]) = do v <- "01"; vs <- sequence ["01"]; return (v:vs)
11:22:35 <JaffaCake> roconnor: the problem is that those lazy types are really inconvenient, and the abstraction leaks all over the place
11:22:36 <vincenz> > (map reverse . sequence $ replicate 10 "01") !! 11
11:22:37 <lambdabot>  "1101000000"
11:22:46 <vincenz> > reverse $ (map reverse . sequence $ replicate 10 "01") !! 11
11:22:46 <Cale> yav: Row polymorphism?
11:22:47 <lambdabot>  "0000001011"
11:23:03 <vincenz> > reverse $ (map reverse . sequence $ replicate 10 "01") !! 157
11:23:03 <lambdabot>  "0010011101"
11:23:21 <vincenz> oh, duh
11:23:25 <yav> Cale: Have you played with TREX in hugs?
11:23:32 <Cale> yav: A bit.
11:23:45 <byorgey> isn't  reverse $ (map reverse . sequence $ x) == sequence x?
11:23:52 <vincenz> byorgey: wasn't thinking
11:24:00 <byorgey> ok, just checking =)
11:24:02 <vincenz> byorgey: I thought the first one would be the tightest loop
11:24:03 <simony> does liftList exist in the stdlib?
11:24:05 <vincenz> but it's not
11:24:09 <yav> Cale: I really don't think that the lacks predicates get in the way.  I do think that we can have some slsightly nicer syntax to not have to write them all the time...
11:24:12 <vincenz> so hence I reveresed the result again
11:24:12 <Cale> simony: liftList?
11:24:16 <vincenz> and yes, that was id :)
11:24:23 <Deewiant> @scheck \x -> reverse (map reverse . sequence $ x) == sequence x
11:24:23 <lambdabot>   Completed 1957 test(s) without failure.
11:24:24 <byorgey> vincenz: ok, I see =)
11:24:31 <astrolabe> Would it be possible somehow to have a compiler automatically diagnose where a single strictness annotation would save a lot of heap?
11:24:36 <simony> Cale, http://www.haskell.org/haskellwiki/ListT_done_right
11:24:36 <roconnor> JaffaCake: you got me.  I've only used lazy structures once, and actually not really.  I used continuation passing style.  It wasn't so bad in my very limited experience.
11:24:37 <lambdabot> Title: ListT done right - HaskellWiki
11:24:38 <Cale> yav: Have you read Daan's paper?
11:24:54 <Cale> simony: liftList is defined on that page
11:25:24 <simony> Cale, yeah, but it seems that everything on that page is stuff that's in the Control.Monad.List module?
11:25:27 <Cale> simony: ListT in the libraries is done wrong
11:25:31 <Cale> No
11:25:33 <astrolabe> roconnor: I find using haskell that one uses lazy structures without even realising it.
11:25:34 <simony> Cale, oh
11:25:38 <Cale> Control.Monad.List is horribly broken
11:25:39 <gnuvince> @src (>>=)
11:25:40 <lambdabot> Source not found. I feel much better now.
11:25:44 <simony> Cale, ah
11:25:48 <Cale> It doesn't produce a monad most of the time.
11:25:59 <byorgey> gnuvince: >>= is different for each Monad instance.
11:26:16 <Cale> It produces something which doesn't satisfy the monad laws and is hence extremely confusing to work with.
11:26:22 <gnuvince> byorgey: I'm searching for the definition of >>= for the List monad.
11:26:32 <Twey> @src List (>>=)
11:26:32 <lambdabot> Source not found. Are you on drugs?
11:26:32 <byorgey> @src [] (>>=)
11:26:32 <lambdabot> xs >>= f     = concatMap f xs
11:26:41 <Twey> D'oh
11:26:44 <Cale> (Unless the monad in question is such that ordering of computations doesn't matter, like the reader monad)
11:26:48 <Twey> That was a particularly stupid error
11:26:54 <vixey> (>>=) = flip concatMap
11:27:08 <vixey> return = (:[])
11:27:20 <byorgey> gnuvince: in the list monad,  xs >>= f   maps f over the elements of xs (producing a list for each one), then concatenates the results into one big list
11:27:48 <Cale> > [1,2,3] >>= \x -> [x, x*10]
11:27:52 <lambdabot>  [1,10,2,20,3,30]
11:28:26 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
11:28:26 <lambdabot>  [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2,...
11:28:46 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
11:28:46 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
11:29:07 <Cale> > filterM (const [True,False]) [1,2,3]
11:29:07 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
11:29:23 <byorgey> > "hello" >> "hello"
11:29:24 <lambdabot>  "hellohellohellohellohello"
11:29:27 <gnuvince> Hmmmm
11:29:40 * gnuvince doesn't see how the replicateM 4 "01" trick worked...
11:29:50 <Cale> Basically, to "run" a list and get a value means to select an element from that list in all possible ways.
11:29:51 <vixey> > replicateM 4 "01"
11:29:51 <lambdabot>  ["0000","0001","0010","0011","0100","0101","0110","0111","1000","1001","1010...
11:29:58 <byorgey> gnuvince: well, replicateM n = sequence . replicate n
11:30:01 <vixey> @src replicateM
11:30:01 <lambdabot> replicateM n x = sequence (replicate n x)
11:30:09 <glen_quagmire> > replicateM 2 "01"
11:30:10 <lambdabot>  ["00","01","10","11"]
11:30:16 <vixey> > replicate 4 "01"
11:30:16 <Cale> > replicate 2 "01"
11:30:16 <lambdabot>  ["01","01","01","01"]
11:30:17 <lambdabot>  ["01","01"]
11:30:18 <roconnor> > foldr(\h t->t++map(h:)t)[[]] [1,2,3]
11:30:18 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
11:30:33 <Cale> So an element will be selected from each copy of "01"
11:30:39 <vixey> > sequence ["01","01","01","01"]
11:30:39 <lambdabot>  ["0000","0001","0010","0011","0100","0101","0110","0111","1000","1001","1010...
11:30:40 <byorgey> in all possible ways
11:30:47 <Cale> right
11:31:15 <Cale> The list monad is very much like list comprehensions.
11:31:33 <Cale> > [[x,y] | x <- "01", y <- "01"]
11:31:34 <lambdabot>  ["00","01","10","11"]
11:31:36 <byorgey> gnuvince: replicateM 4 "01"  isn't even particularly a 'trick', this is actually the intended use of the list monad =)
11:32:15 <gnuvince> byorgey: I meant, I don't see how it works on the inside.
11:32:34 <vixey> gnuvince: Do you now understand it?
11:32:51 <Cale> Nor is filterM (const [True,False])  -- in fact, this is the most elegant algorithm for generating combinations I've ever seen. It says directly "no matter what the element of the list is, either keep it or drop it"
11:33:09 <gnuvince> vixey: I don't think I do.
11:33:19 <Cale> gnuvince: okay
11:33:25 <gnuvince> But it's ok
11:33:30 <astrolabe> @type filterM
11:33:31 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
11:33:31 <gnuvince> I'll just explore the bits individually
11:33:37 <Cale> gnuvince: There might be some disconnect between what >>= does and the 'selection' we're talking about
11:33:40 <gnuvince> and eventually the light will flick on.
11:33:52 <byorgey> gnuvince: do you see how replicateM 4 "01" is the same as sequence ["01", "01", "01", "01"] ?
11:34:00 <Cale> > [1,2,3] >>= (\x -> [4,5] >>= (\y -> return (x,y)))
11:34:01 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
11:34:08 <gnuvince> byorgey: yes, I see that.
11:34:13 <byorgey> ok.
11:34:22 <Cale> ^^ do you see how my code above there works?
11:34:34 <aFlag> After reading the definition of >>= for the List monad I think I get it
11:34:58 <byorgey> aFlag: congrats =)
11:35:19 <aFlag> the do notation for it looks kinda weird, though
11:35:36 <Cale> aFlag: v <- xs is read as "v is selected from xs"
11:35:37 <gnuvince> Cale: I do, but only because you mentioned earlier that (>>=) in the list monad worked pretty much like comprehensions.
11:35:47 <cjb> most people understand the do notation and not the bind notation :)
11:35:52 <Cale> gnuvince:  xs >>= f = concat (map f xs)
11:36:06 <aFlag> cjb, for the IO monad, sure, but for the List monad?
11:36:26 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
11:36:26 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
11:36:30 <cjb> (yes, that's what I meant)
11:36:32 <vixey> @src IO >>=
11:36:32 <lambdabot> Source not found. There are some things that I just don't know.
11:36:42 <vixey> @src IO (>>=)
11:36:42 <lambdabot> m >>= k     = bindIO m k
11:36:43 <roconnor> > 1428 % 12480
11:36:43 <lambdabot>  119%1040
11:36:50 <vixey> @src bindIO
11:36:50 <lambdabot> bindIO (IO m) k = IO ( \ s ->
11:36:50 <lambdabot>   case m s of (# new_s, a #) -> unIO (k a) new_s)
11:36:52 <Cale> I think it's pretty clear what that do-notation means, even if it's not clear how it does it :)
11:36:53 <aFlag> Cale, yeah, I got how it works now :)
11:37:08 <aFlag> I think maybe it's because I'm so used with using do only for IO
11:37:26 <Cale> Yeah, people get stuck on the idea that >>= has something to do with evaluation order.
11:37:29 <roconnor> > 120 % 1040
11:37:29 <Cale> It really doesn't :)
11:37:30 <lambdabot>  3%26
11:38:00 <vixey> > numerator (120 % 1040)
11:38:01 <lambdabot>  3
11:38:04 <gnuvince> > concat $ map (\x -> map (\y -> (x, y)) [4, 5]) [1,2,3]
11:38:05 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
11:38:12 <Cale> It has to do with the ordering of computations in the monad, which is not necessarily very tightly related with the evaluation order :)
11:38:19 <astrolabe> There's a way of thinking of the list monad that helps.  Unfortunately, I forgotten what it was.  Something like it generalises pure functions to multi-functions.
11:38:32 <vixey> x`gcd`y = numerator (x%y) * denominator (x%y) -- ?
11:38:50 <Cale> astrolabe: It's all about nondeterminism. So v <- xs means that v is selected from xs in all possible ways.
11:38:56 <drigz> how to you make a Ptr?
11:39:03 <astrolabe> Cale: That's it.  Thanks.
11:39:14 <drigz> i assume i have to allocate some space somehow...
11:39:19 <aFlag> yeah, the List monad kinda look like prolog programming
11:39:19 <Cale> astrolabe: and yeah, a function of type a -> [b] is like a function which nondeterministically produces a bunch of results
11:39:21 <vixey> astrolabe: It's like a subset of pure Prolog
11:39:40 * astrolabe doesn't know prolog
11:39:41 <Cale> There's actually a fancier monad which is a lot more like Prolog
11:40:09 <Cale> You can get it in the LogicT package on Hackage, iirc.
11:40:14 <vixey> > let member = id in head $ do a <- member [1,2,3] ; b <- member [4,5,6] ; guard (a*b = 15) ; return (a,b)
11:40:14 <lambdabot>  Parse error at "=" (column 85)
11:40:15 <geezusfreeek> there are some nice database-y monads out there
11:40:25 <vixey> Cale: LogicT is not like Prolog
11:40:26 <aFlag> hm, you can create the goals and stuff like you do in prolog?
11:40:32 <vixey> > let member = id in head $ do { a <- member [1,2,3] ; b <- member [4,5,6] ; guard (a*b = 15) ; return (a,b) }
11:40:32 <lambdabot>  Parse error at "=" (column 87)
11:40:39 <vixey> > let member = id in head $ do { a <- member [1,2,3] ; b <- member [4,5,6] ; guard (a*b == 15) ; return (a,b) }
11:40:39 <lambdabot>  (3,5)
11:40:48 <Cale> vixey: Well, it supports cut, and various other control operators.
11:41:26 <Cale> vixey: Of course there's still not general unification, but it's closer.
11:41:54 <aFlag> it seems like you can do something very close to prolog using monads and creating a :- operator
11:42:09 <Cale> mm, I'm not sure about that
11:42:32 <Cale> Well, you might be able to do something, but you'll have trouble with the way that prolog handles variable binding.
11:42:48 <aFlag> yeah, that's true
11:44:18 <arnar_> hi there.
11:44:28 <arnar_> I'm having frustrating problems compiling xmonad..
11:44:29 <Cale> hello
11:44:44 <arnar_> hoping you good people might help me out :)
11:44:52 <Cale> arnar_: Feel free to ask, but there's also #xmonad
11:44:56 <arnar_> chased dependencies down to old-time..
11:44:57 <arnar_> ah, ok
11:45:03 <arnar_> well.. old-time requires old-locale
11:45:08 <arnar_> wont compile without it..
11:45:16 <glguy> and time requires old-locale
11:45:26 <glguy> which is a little more entertaining
11:45:30 <arnar_> but I cant compile with it either since System.Locale is found in both old-locale and base
11:45:38 <arnar_> tried hiding old-locale but didn't make a difference..
11:45:46 <elliottt> arnar_: which ghc are you using?
11:45:51 <Cale> Which version of GHC is this?
11:46:01 <arnar_> 6.6.1
11:46:10 <Cale> If you're using anything but 6.8.2, I recommend upgrading.
11:46:15 <arnar_> ah, ok..
11:46:21 <arnar_> I just apt-get installed whatever was there..
11:46:30 <Cale> There have been rather large library shifts since 6.6
11:46:44 <arnar_> I think I've hit that one before :)
11:46:48 <Cale> Lots and lots of stuff got moved out of base
11:46:49 <arnar_> should've remembered
11:47:01 <elliottt> you might be able to say: runhaskell Setup configure --flags=small_base
11:47:25 <elliottt> err, --flags=-small_base
11:47:34 <arnar_> elliottt: thanks.. I'll try 6.8 though, I'll need to upgrade anyways probably
11:47:35 <Cale> ah, that's interesting :)
11:47:39 <elliottt> :)
11:47:56 <awesame> when I first learned haskell, I thought for a while that it did something it doesn't do
11:48:02 <awesame> which I just now understand
11:48:48 <awesame> the combination of currying, type inference, and reasoning by substitution made me think that function application and function composition would be written the same way
11:49:09 <awesame> now I'm curious what problems a language like that would run into
11:50:18 <drigz> is Foreign considered to be unsafe?
11:50:34 <awesame> so I thought for a little while that pointfree expressions like (+1):[0] might work
11:50:34 <astrolabe> If you wanted to apply a function to a function (for example map), how would you specify that rather than composition?
11:51:05 <astrolabe> (that was to awesame )
11:51:46 <awesame> I'm not sure it does work out, but my misunderstanding was that there would be no difference
11:52:01 <astrolabe> I see.
11:52:23 <conal> i'm trying 'cabal update' for the first time (on winxp) and getting a parse error: Warning: Error parsing config file C:\Documents and Settings\Conal\Application Data\cabal\config: On line 1: GHC
11:52:41 <conal> line 1 is:  compiler: GHC
11:52:47 <augustss> drigz: there are many dangerous things in Foreign
11:52:58 <awesame> so for example "(:) f list" might mean f:list or \x -> f x:list, depending on the type of f
11:53:15 <drigz> augustss: damn. so if i use Storable instead of unsafeCoerce, i'm not even gaining purity?
11:53:37 <vixey> there is no deriving fold?
11:53:39 <awesame> (and of list, I guess)
11:54:01 <awesame> I'm trying to figure out a simple example where this approach runs into bad trouble
11:54:21 <byorgey> awesame: the problem is that you really want to have higher-order functions.
11:54:31 <byorgey> so, sometimes, you really do want to pass a function as a parameter to another function
11:54:32 <yav> conal: maybe GHC should be ghc?
11:54:35 <byorgey> instead of composing them.
11:54:54 <augustss> drigz: using Storable would probably be more portable
11:55:17 <conal> yav: hey -- that seems to have fixed it.  thanks!
11:55:20 <byorgey> awesame: for example, map concat and map . concat are quite different.
11:55:33 <byorgey> er, sorry, that doesn't make sense
11:55:42 <byorgey> map . concat does not type =)
11:55:48 <drigz> :t map . concat
11:55:49 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
11:55:49 <lambdabot>     Probable cause: `concat' is applied to too many arguments
11:55:49 <lambdabot>     In the second argument of `(.)', namely `concat'
11:56:03 <drigz> oh yeah, you need map f . concat
11:56:12 <awesame> what's an example that does type?
11:56:18 * drigz should be more trusting
11:56:23 <astrolabe> awesame: I guess having the same notation (here juxtaposition) for two different things is against the philosophy of haskell.
11:57:09 <drigz> augustss: yes, that's true. i wonder if there's any guarantee about what unsafeCoerce does
11:57:15 <astrolabe> Although type classes contradict what I just said a bit :)
11:57:16 <awesame> I feel like I've seen this kind of ambiguity in math notation sometimes
11:57:34 <augustss> drigz: I doubt it :)
11:57:49 <astrolabe> awesame: Yeah.  Maths notation is ambiguous about what f^-1(A) means.
11:58:29 <astrolabe> awesame: But ambiguity is usually more tolerable in maths because people have more sense than computers.
11:58:44 <lament> awesame: doesn't it mean "the set of x s.t. f(x) = A"?
11:59:16 <lament> oh, i guess it could be a set or a single element
11:59:19 <astrolabe> lament: it can also mean the inverse of f applied to the element A.
11:59:23 <astrolabe> right
12:00:39 <awesame> right, math does that kind of thing a lot
12:00:51 <aFlag> natural language is even more ambiguous than math, and people do communicate succesfully
12:01:04 <awesame> and I initially thought that haskell had some kind of unambiguous interpretation of those kinds of expressions
12:01:22 <augustss> awesame: if you want an example that type checks, try 'twice f x = f (f x); quad = twice twice; f1 = twice quad; f2 = twice . quad'
12:01:23 <drigz> augustss: "On the existence of unsafeCoerce ... we should be very careful not to guarantee anything about what it does."
12:02:18 <awesame> augustss: excellent example, thanks
12:04:09 <roconnor> the only specification I can think of for unsafeCoerce is that unsafeCoerce (x::a) == (x::b) when a and b are the same type
12:04:25 <awesame> nice job tying it to addition vs multiplication, too
12:04:42 <roconnor> I've seen one example where a and b where two type variables that were the same type (due to the branch under analysis).
12:04:51 <roconnor> were
12:06:12 <augustss> roconnor: and by == you mean semantic equaility, i presume?
12:06:22 <roconnor> yes
12:07:29 <augustss> I could imagine stronger ones, like if you've put something in an existential wrapper, and then unpack and coerce you get the original value back
12:07:55 <roconnor> that being said I've also used unsafeCoerce to cast to a type and back from it later.
12:08:08 <roconnor> But it is unclear that this sould actually be safe.
12:08:12 <roconnor> *should
12:08:47 <roconnor> I've seen it used to cast to and from (), but this is actually unsafe in ghc -O2.
12:08:57 <augustss> I use unsafeCoerce everywhere when generating Haskell from Cayenne.  It seems to work fine, but I don't know what it really means :)
12:08:59 <roconnor> and it caused the code to segfault.
12:09:11 <mrd-> same notation for two different things? you mean type classes
12:09:19 <roconnor> augustss: yep, I was generating Haskell from Coq.
12:10:15 <roconnor> I think I suggested to cast to and from (forall a. a) instead of ().
12:10:33 <roconnor> but really, I'm not sure that any time is truly safe.
12:11:02 <roconnor> A compiler may be inclinded to use the type of stuff to do various optimization. ... or so the static type people keep saying.
12:12:09 <augustss> I had a compiler that would have done funny things to values of type (forall a . a)
12:12:39 <augustss> it knows that all values of that type are interchangable
12:12:57 <roconnor> augustss: how about () -> (), which was another suggestion?
12:13:32 <augustss> still dodgy, i think
12:13:42 <augustss> functions might get special treatment
12:14:10 <awesame> so I think maybe haskell could have a syntax like I was assuming it had
12:14:14 <byorgey> awesame: another example would be  map . map  vs.  map map
12:14:36 <byorgey> awesame: how so?
12:14:58 <byorgey> how would the compiler tell the difference, when you want to compose vs. apply?
12:15:13 <awesame> instead of writing e.g. (twice thrice) (+1) 0 or (twice . thrice) (+1) 0, you would write (twice thrice) (+1) 0 or twice (thrice (+1)) 0
12:15:35 <byorgey> awesame: but that's what we already have =)
12:15:48 <awesame> and "twice thrice (+1) 0" would be an error, because it's ambiguous
12:16:27 <aFlag> awesame, are you trying to make Haskell into lisp? :P
12:16:32 <byorgey> awesame: the only thing that would change from the present is that  "twice thrice (+1) 0" would become illegal (it presently means the same as (twice thrice) (+1) 0 of course)
12:16:44 <awesame> aFlag: maybe I was assuming it was more lisp-like early on?
12:16:52 <byorgey> awesame: in particular, note that composition (.) is just a library function, it is not built-in to Haskell
12:16:56 <awesame> really I'm just trying to understand what the hell I thought was going on
12:16:57 <byorgey> @src (.)
12:16:57 <lambdabot> (f . g) x = f (g x)
12:17:51 <Deewiant> @src ($)
12:17:51 <lambdabot> f $ x = f x
12:18:00 <aFlag> the applications are left associative, then when you write f g h, you're writing ((f g) h)
12:18:01 <byorgey> awesame: also, note that if you wanted to make "twice thrice (+1) 0" ambiguous, you'd also have to make "(twice thrice) (+1) 0" ambiguous -- it would need to be "((twice thrice) (+1)) 0"
12:18:12 <aFlag> it goes well with the typing being right associative
12:18:18 <byorgey> indeed.
12:18:32 <awesame> so the cute thing in my misunderstanding would be that instead of twice = f . f, you would write twice = f f (which isn't ambiguous, because the other option is a type error)
12:18:48 <roconnor> augustss: yep.  So like I said, I don't think there is any safe type to cast to and from.
12:18:56 <aFlag> awesame, you realise that f . f and f f are too different things, right?
12:19:19 <byorgey> awesame: but what would you write if you actually wanted twice to be equal to f applied to itself?
12:19:28 <awesame> aFlag: yes.  I'm trying to work out a misunderstanding I had long ago about how haskell worked, and figure out whether anything could possibly work that way
12:19:39 <byorgey> awesame: notice, that isn't necessarily a type error.
12:19:47 <byorgey> @type map map
12:19:48 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => f1 (a -> b) -> f1 (f a -> f b)
12:20:02 <awesame> ah, I see
12:20:05 <shepheb> well, this is Caleskell.
12:20:09 <byorgey> applying a function to itself is a perfectly legitimate thing to do.
12:20:16 <augustss> roconnor: in the Haskell I generate I just replace x with cast x for every variable
12:20:18 <Deewiant> @type id id
12:20:19 <lambdabot> forall a. a -> a
12:20:22 <byorgey> shepheb: well, it doesn't matter, the point is that (map map) is well-typed
12:20:29 <augustss> with cast having type a->b
12:20:48 <simony> I am trying to instantiate Arrow, but it tells me that "arr", >>> and first  are not (visible) methods. Why?
12:21:04 <shepheb> simony: import Control.Arrow?
12:21:14 <simony> shepheb, I did: import Control.Arrow(Arrow)
12:21:21 <byorgey> simony: oh, that's why =)
12:21:25 <simony> oh, I see, thanks :)
12:21:27 <Deewiant> simony: if you want the members of Arrow, you want Arrow(..)
12:21:40 <byorgey> if you just say (Arrow) it only imports the class Arrow, but none of its members
12:21:42 <Deewiant> that way you're only getting the type
12:21:50 <edwardk> @type (.)
12:21:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:21:56 <simony> thanks
12:22:00 <edwardk> very much Caleskell ;)
12:22:51 <awesame> I think my weird system would have to introduce a difference between (map map) and (map (map)) to resolve ambiguities, so maybe it works out to be pretty similar
12:23:13 <byorgey> awesame: I guess you could do that, but I think it would be pretty contorted
12:23:17 <awesame> yeah
12:23:27 <byorgey> interesting idea though =)
12:27:40 <awesame> I see where my confusion came from now, though
12:29:20 <byorgey> awesame: where's that?
12:29:20 <awesame> because of currying, "f g x" means "(f applied to g) applied to x", and sometimes you could use the type system to figure out that it must mean "f applied to (g applied to x)"
12:29:43 <vixey> you could just write
12:29:47 <vixey> f (g x)
12:29:57 <awesame> I was trying to be extra clear
12:30:10 <awesame> since I've been messing with alternative syntax
12:30:17 <vixey> I mean you could write f (g x)
12:30:25 <vixey> rather than f g x
12:31:27 <awesame> of course
12:31:54 <dolio> roconnor: You could try coercing to GHC.Prim.Any
12:32:04 <awesame> haskell doesn't make you write (f g) x, though, and initially I must have thought it was using the type system to do that, rather than just a binding rule
12:32:44 <vixey> > f$g$x :: Expr
12:32:44 <lambdabot>  Add a type signature
12:33:17 <Deewiant> > (f :: Expr -> Expr) $ g $ x :: Expr
12:33:18 <lambdabot>  f (g x)
12:37:54 <roconnor> dolio: actually, that is a good idea
12:43:43 <roconnor> dolio: I don't suppose that Hugs has something similar?
12:44:41 <dolio> The base that comes with ghc doesn't come with Hugs code, as far as I can see, so I don't know.
12:45:27 <Cale> awesame: well, the fact that (f g) x is permitted is reflected in the type system, but function application is simply defined to be left associative, so that f g x means (f g) x directly
12:48:33 <awesame> Cale: yeah, I missed that point early on
12:49:51 <simony> if combining two monads is done with a monad transformer, is the same true for arrows? Are there "arrow transformers"?
12:50:30 <awesame> and I'm pretty sure that ambiguities like map map would make trying to infer the meaning of f g x without a left-associative rule turn out to be irritating
12:54:08 <Cale> simony: While monad transformers are in a sense used to combine the effects of various monads, I think it's best to keep that idea separate from combining the monads themselves...
12:54:15 <Cale> simony: But yes, there are arrow transformers
12:54:36 <dolio> @hackage arrows
12:54:36 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/arrows
12:54:42 <simony> thanks
12:55:15 <Cale> Interestingly, Applicative functors combine very well on their own (though there may be things which Applicative functor transformers could do which composing applicative functors can't do directly.)
12:55:52 <roconnor> Cale: did someone say that the composition of applicative functors is an applicative functor?
12:55:52 <orzo> i'm using -prof -auto-all and I'm passing "a.out", "-p", "RTS" to hs_init
12:55:59 <Cale> roconnor: yes
12:56:01 <orzo> a file called a.out.prof is created
12:56:15 <orzo> but it has zero bytes
12:56:20 <roconnor> Cale: is it true?
12:56:21 <Cale> (It was probably Conal, since he uses this fact a lot)
12:56:22 <Cale> yes
12:56:44 <roconnor> Cale: the the composition of any two Monads is an applicative functor?
12:56:49 <dolio> I think it's mentioned in the Idiom paper, too.
12:57:20 <Cale> Yes, that's true. In order to make it into a monad, you need something called a distributive law.
12:57:49 <shepheb> can someone help me firm up my idea of what is called a "commutative monad"?
12:58:11 <Cale> shepheb: basically,  x >> y = y >> x for any x and y
12:58:26 <shepheb> hmm. how many of those do we have?
12:58:31 <Cale> Not many.
12:58:38 <Cale> Reader is one.
12:58:38 <dolio> Reader...
12:58:50 <Cale> (->) e, which of course is isomorphic to that.
12:59:10 <Cale> Writer, when the monoid in question is commutative.
12:59:30 <dolio> You can hand wave some more if you decide you don't care about certain things, I imagine.
12:59:38 <Cale> and that's about it, for ones which are in common use in programming at the moment.
12:59:42 <roconnor> monadRandom is semanticallly commutative.
12:59:55 <Cale> Yeah.
12:59:57 <dolio> For instance, a unique supply monad would be commutative up to the actual unique values.
13:00:03 <shepheb> @src MonadPlus
13:00:04 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
13:00:04 <shepheb> @src Monoid
13:00:05 <lambdabot> class Monoid a where
13:00:05 <lambdabot>     mempty  :: a
13:00:05 <lambdabot>     mappend :: a -> a -> a
13:00:05 <lambdabot>     mconcat :: [a] -> a
13:00:09 <dolio> Which you probably don't really care about.
13:00:28 <sclv> a writer to Max or Min or a Set would also work.
13:00:37 <roconnor> yeah, I'd agree that unique supply is semantically a commutative.
13:00:43 <shepheb> well, any Writer whose target doesn't care about order.
13:00:48 <Cale> sclv: Yes, that's because those are commutative operations
13:01:04 <sclv> this is true.
13:01:20 <roconnor> oooh Writer with max sounds useful.
13:01:30 <Cale> Yep.
13:01:34 <roconnor> I should put that in something.
13:01:34 <shepheb> min-maxing AI?
13:01:43 <sclv> oh -- I missed when you already said that above. :-)
13:01:58 <Cale> sclv: ah :)
13:05:15 <dolio> Oleg and ccshan do some nice stuff with Writer + Any in their generalized zipper, to track whether any operations have modified stuff.
13:06:00 <roconnor> @src Any
13:06:00 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
13:06:19 <dolio> > Ant False ++ Any True
13:06:21 <lambdabot>   Not in scope: data constructor `Ant'
13:06:24 <dolio> > Any False ++ Any True
13:06:25 <lambdabot>  Any {getAny = True}
13:08:46 <mrd> someone is giving a talk "Functional Programming in Space" next week here
13:10:05 <roconnor> here, on #haskell ? :D
13:10:13 <mrd> in the nether
13:10:34 <roconnor> @where mrd
13:10:34 <lambdabot> I know nothing about mrd.
13:10:44 <mrd> i just spotted it on a sign while walking around
13:11:02 <mrd> @cmu
13:11:02 <lambdabot> Unknown command, try @list
13:11:09 <mrd> @botsmack
13:11:09 <lambdabot> :)
13:15:20 <czakey> @fact
13:15:20 <lambdabot> I can not handle empty facts.
13:15:24 <czakey> @fact haskell
13:15:25 <lambdabot> haskell: Haskell is the language of choice for discriminating hackers.
13:15:37 <mrd> @fact undefined
13:15:37 <lambdabot> I know nothing about undefined
13:15:42 <mrd> @fact _|_
13:15:43 <lambdabot> I know nothing about _|_
13:15:56 <mrd> @fact anything
13:15:57 <lambdabot> I know nothing about anything
13:16:05 <jatqceer> @fact lambdabot
13:16:05 <jatqceer>  
13:16:05 <lambdabot> lambdabot: Lambdabot is a bot of curious opinions, and is female.
13:16:20 <dolio> @fact hsu
13:16:20 <lambdabot> hsu: I know nothing about Haskell Secret Underground.
13:17:12 <dolio> @fact chessguy
13:17:12 <lambdabot> chessguy: is not cheeseguy
13:17:20 <lament> @fact fact
13:17:20 <lambdabot> fact: A fact is a fact is a fact is a fact. Or not.
13:17:28 <czakey> @fact-set fun haskell
13:17:29 <lambdabot> Fact recorded.
13:17:39 <czakey> @fact fun
13:17:40 <lambdabot> fun: haskell
13:17:44 <czakey> @fact-set fun haskell!
13:17:44 <lambdabot> Fact already exists, not updating
13:17:50 <lament> "Idiots: a weaker, more functional, form of moron"
13:17:53 <czakey> @fact-del fun
13:17:53 <lambdabot> Fact deleted.
13:18:08 <czakey> @fact-set fun fun? Haskell! :>
13:18:08 <lambdabot> Fact recorded.
13:19:42 <lament> fun?
13:19:47 <Cale> @fact @fact
13:19:47 <lambdabot> I know nothing about @fact
13:19:57 <lament> @fact-set @fact @fact
13:19:58 <lambdabot> Fact recorded.
13:20:02 <lament> @fact @fact
13:20:02 <lambdabot>  @fact: @fact
13:20:14 <lament> stupid colon
13:20:27 <Cale> @fact-set @fact @fact:
13:20:27 <lambdabot> Fact already exists, not updating
13:20:32 <lament> @fact: @fact
13:20:32 <lambdabot>  @fact: @fact
13:20:38 <lament> oh
13:20:39 <conal> @localtime geezusfreeek
13:20:40 <lambdabot> Local time for geezusfreeek is Fri Apr 11 15:20:39 2008
13:20:41 <lament>  @fact: @fact
13:20:51 <Cale> hehe, spell checker to the rescue
13:30:01 <dons> http://reddit.com/info/6fgq2/details woot, darcs 2. the full story
13:30:33 <mrd> darcs. behind the scenes. cherrypicking details.
13:33:58 <lament> "faster" sounds much better than what David said
13:34:05 <lament> ("sometimes it's faster, and sometimes it's slower")
13:35:18 <arnar_> what's haskell's equivalent of python dicts (hashtables)?
13:35:42 <Igloo2> You probably want Data.Map
13:35:48 <dolio> Well, that article says that it's probably slower for very large repositories, too.
13:35:53 <arnar_> Igloo2: thx
13:36:29 <arnar_> ah, Data.List.lookup is nice too
13:36:39 <dons> yes, i think kowey should write darcs announcements
14:00:45 <roconnor> Does git have that same feature in darcs where I consider one hunk at a time to commit?
14:01:39 <rey_> git-add --interactive
14:01:52 <rey_> I believe (I don't really use git)
14:05:05 <fnoble> does anyone know of a good introduction to calling haskell from C using the FFI?
14:05:19 <fnoble> I can only find information about calling C from haskell
14:05:42 <astrolabe> fnoble: Have you seen the peyton-jones paper?
14:05:58 <glguy> roconnor: yes, either use git gui, or git add --patch
14:05:59 <astrolabe> 'tackling the awkward squad'
14:06:02 <fnoble> no... ill go have a look
14:07:26 <astrolabe> fnoble: http://research.microsoft.com/~simonpj/papers/marktoberdorf/
14:07:27 <lambdabot> Title: Simon Peyton Jones: papers
14:08:41 <fnoble> thanks, hopefully doesn't go straight over my head :)
14:08:58 <astrolabe> fnoble: I liked it.
14:09:18 <astrolabe> and I have a low head where this stuff is concerned.
14:12:09 <Syzygy-> http://carlzimmer.typepad.com/sciencetattoo/2008/02/y-combinator.html
14:12:10 <lambdabot> http://tinyurl.com/685mbc
14:12:22 <Syzygy-> Gotta love lambda calculus tattoos!
14:15:35 <dons> that doesn't look well typed
14:15:37 <dons> ;)
14:16:00 <dolio> I don't know, what if, in a few years, you break up with lambda calculus?
14:16:06 <dolio> What would pi calculus say?
14:16:24 <dons> i'd hate to have a type error tattooed -- you have to live with that
14:17:11 <cjb> dolio: it would say "mu"
14:17:59 <dolio> So, dons, how can I go about getting one of your green prayer handkerchiefs?
14:21:46 <Cale> dons: hehe
14:21:55 <ehird> are there any pure, lazy haskell parsing libraries?
14:22:02 <ehird> like parsec - monads - strict
14:22:18 <Cale> Is parsec all that strict?
14:22:22 <ehird> Cale: completely
14:22:27 <Cale> Really?
14:22:29 <ehird> yes
14:22:35 <Cale> I don't think it forces the entire string.
14:22:51 <dolio> Why would you want to remove the monads? Unless you're going with just applicative functors or something.
14:23:05 <Cale> Just the stuff which you parse, (which of course, needs to be forced)
14:23:13 <ehird> dolio: Applicative functors sound nice.
14:23:22 <ehird> Cale: Not the string
14:23:33 <Cale> ehird: What is it strict in?
14:23:48 <Cale> (that it could plausibly not be strict in)
14:23:59 <dolio> You want incremental parsing, maybe? I thought someone was working on that around here.
14:24:12 <Cale> Every monad is an applicative functor by the way
14:24:41 <ehird> i've always wanted a library that does 'parsing by example with holes' so to speak
14:24:46 <Cale> So parsec is already (conceptually) an applicative functor parsing library, you just have to use it that way.
14:24:59 <Cale> What would that mean?
14:26:15 <Cale> (what would parsing by example with holes be?)
14:26:57 <dons> dolio: oh, for the prosperity association? :)
14:27:31 <dolio> Yeah.
14:27:41 <dons> scary stuff
14:27:47 <dolio> I was looking for your page yesterday, but you're, apparently, not the most famous Don Stewart on the internet.
14:27:49 <YourAlgebra> afternoon
14:28:02 <dons> dolio: its very sad. at least i still own google.com.au :)
14:28:41 <Cale> dons: For a moment I thought you meant that you actually owned that domain name :)
14:28:51 <dons> heh
14:29:20 <dons> they come monogrammed with my initials
14:29:31 <dons> you'll receive abundant blessings
14:29:33 <ski> awesame : Charity uses juxtaposition for composition
14:30:03 <dolio> Hehehe.
14:30:13 <roconnor> > 238 % 4160
14:30:14 <lambdabot>  119%2080
14:30:18 <dons> here's a puzzle for you, Cale, http://cdiggins.com/2008/04/11/expressing-local-assignment-without-side-effects-using-fold-can-you-do-this-in-haskell/
14:30:49 <dons> i'd love to see a proper paper about Cat's type system one day -- its a bit scary otherwise
14:31:25 <sjanssen> "can you do this in Haskell?"  them's fightin' words
14:31:33 <sjanssen> dons: how is the hackathon going?
14:31:48 <dons> good! some photos on blog.well-typed.com
14:32:04 <dons> Lemmih combined HSP and HAppS
14:32:17 <dons> trying to get Igloo to use xmonad
14:32:21 <sjanssen> any xmonad converts?
14:32:23 <dons> he wants some funky overlaping layout
14:32:29 <sjanssen> how many people there *aren't* using xmonad?
14:32:35 <dons> well, we may already have saturated the market
14:32:37 <Heffalump> oh, and it's xmonad's fault that acpi doesn't work properly
14:32:41 <dons> heh
14:32:44 <sjanssen> Heffalump: bwah?
14:33:01 <Heffalump> (sez Igloo)
14:33:02 <dons> sjanssen: Heffalump uses xmonad, did you know?
14:33:11 <sjanssen> dons: yeah, I think so
14:33:24 <dons> leading investment banks say: xmonad will bring you financial security
14:33:34 <Igloo2> (I wasn't being serious about the ACPI thing)
14:33:42 <dons> hah. to you so bad, Igloo2
14:33:48 <dons> s/got you/
14:34:11 * Igloo2 can't parse that correction
14:34:20 <roconnor> > 120 % 2080
14:34:20 <lambdabot>  3%52
14:34:28 <Heffalump> sed: -e expression #1, char 10: unterminated `s' command
14:34:44 <dons> :)
14:34:55 <roconnor> where is my 1/2080 difference coming from?
14:34:58 <roconnor> hmm
14:35:06 <Heffalump> probably xmonad
14:35:28 <ski> xmonad makes the difference ?
14:35:53 <glguy> process = uncurry (-) . foldl ( \ (zeros,sum) x -> (if x == 0 then zeros+1 else zeros, sum+x)) (0,0)
14:35:58 <Cale> dons: Nice formatting on that blog. I like how the code goes underneath the sidebar ;)
14:36:03 <glguy> is that what the Cat blog post is about?
14:36:17 <glguy> (if you switch the zeros and sum around)
14:36:43 <dons> glguy: its possible -- the cat blog has been oddly trivial at times
14:37:23 <sjanssen> glguy: yes, I think so
14:38:13 * dons is suspicious of type systems without papers
14:38:19 <dons> its like the computer modern rule for math papers, Cale
14:38:28 <Cale> > let process = liftM2 (-) sum (length . filter (== 0)) in process [2,0,1,2,0,3,0,0]
14:38:28 <lambdabot>  4
14:38:29 <kfish> yeah, I find that one of the major advantages of tuple-based languages is that you can return multiple values
14:38:44 <Cale> That seems to be essentially the gist of what the program does?
14:38:45 <sjanssen> glguy: for bonus points, make a little stack EDSL so you can pointfree that expression
14:38:52 <dolio> He says it's just row polymorphism for the stack.
14:39:03 <dolio> There are even papers on that in Haskell. :)
14:39:04 <dons> didn't we have a stab at factor as an edsl a while ago?
14:39:08 <dons> and there wasn't much to it?
14:39:12 <roconnor> > factor 2080
14:39:13 <lambdabot>   Not in scope: `factor'
14:39:21 <roconnor> > ifactor 2080
14:39:22 <lambdabot>   Not in scope: `ifactor'
14:39:29 <sjanssen> dons: I've done it before, not hard at all
14:39:43 <roconnor> quick, somone write ifactor in one line of haskell.
14:39:49 <Cale> reddit has seemed randomly slow lately
14:40:44 <sjanssen> roconnor: you want the prime factors of 2080?
14:41:27 <glguy> In Factor, that Cat code is
14:41:27 <glguy> : process ( seq -- n )
14:41:27 <glguy>     0 0 rot [ tuck [ + ] [ zero? [ 1+ ] when ] 2bi* ] each - ;
14:42:21 <glguy> (though I'm sure the exact same code could be written if those functions where defined)
14:43:48 <dons> sjanssen: have you noticed the xmonad install reports have gone up by about 50 users in the last 2 weeks?
14:43:55 <dons> yay for distro packages and releases :)
14:44:40 * Heffalump pokes dons with discussion on #darcs about the bytestring issue
14:45:13 <dons> too tired. but if someone has a reproducible test case, i can hunt tomorrow
14:45:26 <roconnor> sjanssen: nevermind.  I think I've found my missing 1/2080 bit.
14:45:40 <roconnor> > 78 % 1352
14:45:40 * nibro hates cygwin
14:45:40 <lambdabot>  3%52
14:46:26 <nibro> general question: if I wanted a linux flavor that "just worked", what should I go for then?
14:46:41 * nibro is not friends with his gentoo...
14:46:47 <Heffalump> debian IMO
14:46:53 <Heffalump> but I'm sure ubuntu has its supporters
14:47:03 <grahamhutton> @users
14:47:03 <lambdabot> Maximum users seen in #haskell: 481, currently: 460 (95.6%), active: 19 (4.1%)
14:47:27 <nibro> Heffalump: thanks for the input - I'll go have a look
14:47:50 <glguy> nibro: debian seems good for a "just works" and "doesn't move much" fedora seems good for "just works" and "cutting edge"
14:48:00 <roconnor> > 90 % 1800
14:48:01 <lambdabot>  1%20
14:48:26 <roconnor> > (3%2) * (1%15)
14:48:26 <lambdabot>  1%10
14:48:40 <nibro> glguy: then debian is my cup of tea :)
14:48:51 <roconnor> > (3%4) * (1%15)
14:48:52 <lambdabot>  1%20
14:49:03 * glguy could go for some tea
14:49:06 <dons> what about ubuntu?
14:49:13 <glguy> What about it?
14:49:17 <dons> kids are safe around it
14:49:18 <fnoble> nibro: i recommend ubuntu, first distro i found that really made a good stab at tackling ease of use
14:49:29 <jsnx> @hoogle (a0 -> b0) -> (a1 -> b1) -> ((a0, a1) -> (b0, b1))
14:49:30 <lambdabot> Did you mean: (A0 -> B0) -> (A1 -> B1) -> ((A0, A1) -> (B0, B1))
14:49:37 <fnoble> and it works out of the box
14:49:43 <glguy> Ubuntu is less stable than debian and less uptodate than Fedora
14:49:56 <glguy> it's like playing an armsman in old dark age of camelot
14:49:57 <dons> but easier to install and configure?
14:49:59 <elliottt> obviously arch is the one true choice.
14:50:01 <elliottt> :)
14:50:01 <fnoble> i think its a good compromise
14:50:01 <glguy> dons: not realy
14:50:09 <dons> more widely available?
14:50:20 <glguy> What does that mean?
14:50:22 <dons> is it really just the free disks that it took off?
14:50:24 <jsnx> dons: just more mindshare
14:50:33 <dons> why did it gain so much more mindshare?
14:50:38 <glguy> financial backing
14:50:48 <Cale> > let process = sum . uncurry (++) . first (map (+(-1))) . partition (== 0) in process [1,0,0,2]
14:50:49 <lambdabot>  1
14:50:52 * nibro 's head is spinning :-)
14:50:54 <dons> which was used to do what? free disks?
14:51:16 <jsnx> dons: ads, slick installer, stuff like that
14:51:26 <dons> xmonad+ubuntu importante sjanssene
14:51:31 <nibro> what I dislike about gentoo is that I don't get anything at all for free
14:51:32 <jsnx> dons: fedora just had less backing
14:51:33 <glguy> I think it became cool for kids switching from Windows
14:51:53 <Choko> xubuntu go make it!
14:51:54 <jsnx> nibro: well, that's great for servers...
14:51:58 <nibro> I can't get my keyboard maps to work, I don't know how to enable the wi-fi, etc
14:52:11 <jsnx> nibro: i don't want to see a bunch of stuff for free on them
14:52:27 <vincenz> fedora is ugly
14:52:33 <glguy> Gentoo was a fun hobby
14:52:35 <nibro> jsnx: I had someone preach the valor of gentoo to me when I was in the process of choosing, I now know I shouldn't have listened
14:52:37 <glguy> lots to tweak and aply with
14:52:57 <jsnx> nibro: you should have had a more realistic estimate of your own interests, maybe
14:53:12 <jsnx> nibro: "not listening" is generally a bad way to get advice
14:53:14 <fnoble> i find ubuntu to have all the benefits of debian, with more emphasis put on usablility
14:53:30 <nibro> jsnx: or a more realistic friend who wouldn't tell me that everything would work great under gentoo :\
14:53:52 <jsnx> nibro: well, if they said that, they are half-right and half-wrong
14:53:54 <nibro> what's the main difference between ubuntu and debian then?
14:54:04 <fnoble> ubuntu is based on debian
14:54:09 <jsnx> everything will work, but you have to work on it
14:54:14 <elliottt> jsnx: is this what you were looking for earlier?  \f g -> first f >>> second g
14:54:41 <fnoble> but debian's policy is to release slowly, with an emphasis on stability
14:54:53 <vincenz> fnoble: -very- slowly
14:55:10 <fnoble> if you just want to get an application to play a dvd you may have to fiddle
14:55:21 <fnoble> but ubuntu seems to target the average user needs
14:55:35 <fnoble> its easy to enable use of non free codecs so you can play mp3s etc
14:55:53 <nibro> I'm particularly wary about my wi-fi card
14:55:54 <jsnx> elliottt: not exactly
14:56:03 <fnoble> use non free or non tested-for-over-5-years drivers for your hardware
14:56:07 <nibro> since I can't get it to work under gentoo no matter what I try
14:56:19 <elliottt> jsnx: never mind then :)
14:56:39 <nibro> fnoble: if I installed ubuntu "out of the box", would the wi-fi card "just work" then?
14:56:39 <jsnx> basically, i'm looking for 'cross'
14:56:49 <fnoble> i think it has a good chance
14:56:51 <jsnx> nibro: generally
14:57:01 <Cale> nibro: Go with ubuntu, since installing is generally pretty easy and if you find you don't like it, you can always try something else afterward :)
14:57:02 <fnoble> in any case, the installer is a live cd
14:57:09 <fnoble> so you can check before you install
14:57:09 <elliottt> jsnx: cross?
14:58:07 <jsnx> f : F -> F', g : G -> G', f x g : (F, G) -> (F', G')
14:58:08 <Cale> I used to run debian, but when I needed to reinstall, I went with Ubuntu, and enjoyed how easy it was to get things set up.
14:58:28 <ski> @type (***)
14:58:29 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
14:58:42 <fnoble> C
14:58:46 <fnoble> Cale: ditto
14:58:46 <jsnx> ski: only takes one function
14:58:59 <nibro> alright, I'm dling ubuntu now
14:59:00 <jsnx> ditto on ubuntu
14:59:11 <ski> jsnx : ?
14:59:36 <jsnx> ski: i thought you were suggesting that as a substitue for cross
14:59:43 <ski> jsnx : i was
14:59:46 <Cale> The one thing which makes me sad about ubuntu is how they always have an old ghc package, so it's best to just install the generic linux package manually.
14:59:46 <jsnx> eh?
14:59:51 <nibro> stupid question: can I run the installer by mounting the iso in windows, or must I burn it?
14:59:57 <jsnx> ski: okay, just a second
15:00:09 <jsnx> nibro: you must burn it
15:00:45 <nibro> jsnx: ok, thanks
15:00:53 <wolverian> Cale, 8.04 will have 6.8.2, anyway. :)
15:01:05 <Cale> wolverian: Shortly after which 6.10 will come out.
15:01:07 <jsnx> oh, i am being silly
15:01:08 <ski> > (succ *** pred) (5,5)
15:01:10 <lambdabot>  (6,4)
15:01:22 <wolverian> Cale, well, that's obviously ghc's fault for having such a terrible release schedule... ;)
15:01:26 <ski> > uncurry (***) (succ,pred) (5,5)
15:01:27 <lambdabot>  (6,4)
15:01:45 <Cale> wolverian: Ubuntu should clearly wait on GHC :)
15:01:56 <jsnx> ski: you are right
15:01:59 <jsnx> elliottt: so were you
15:02:13 <jsnx> i just need something different than that
15:02:17 <ski> @pl \f g -> first f >>> second g
15:02:18 <lambdabot> (. second) . (>>>) . first
15:02:20 <ski> bah
15:02:21 <wolverian> Cale, and gnome! ghc should be put in gnome core supported languages.
15:02:23 <Cale> wolverian: Actually what would be really cool is if we could get an update in after the release.
15:02:27 <wolverian> erm. haskell, that is.
15:02:48 <wolverian> Cale, one can always request one afterwards, to go into the hardy-updates repository.
15:02:58 <wolverian> ubuntu releases are only feature-frozen if you don't enable the updates repo. :)
15:03:01 <Cale> That would be great -- why isn't it done?
15:03:16 <wolverian> because the debian 6.8 transition was very recent
15:03:21 <Cale> mm...
15:03:39 <wolverian> the packages have been there, but they've been reorganised in the past few months.
15:03:40 <Cale> Maybe we need more Debian users. :)
15:03:47 <jsnx> i need an analogue for three arguments
15:03:52 <wolverian> yes, and it would help to have someone do the actual ubuntu package updating and uploading.
15:04:25 <Cale> I wonder who's actually doing that. We should get them to come and hang out here.
15:04:30 <jsnx> (a0 -> b0 -> c0) -> (a1 -> b1 -> c1) -> ((a0, a1) -> (b0, b1) -> (c0, c1))
15:05:06 <ski> @type \f g h -> (\(a,b,c) -> (a,(b,c))) >>> (f *** g *** h) >>> (\(a,(b,c)) -> (a,b,c))
15:05:08 <lambdabot> forall b c b1 c1 b' c'. (b -> c) -> (b1 -> c1) -> (b' -> c') -> (b, b1, b') -> (c, c1, c')
15:05:16 <ski> oh
15:05:19 <Cale> (If they aren't already ;)
15:05:43 <jsnx> it's just two functions
15:05:49 <ski> ic
15:05:57 <wolverian> Cale, there doesn't currently seem to be a person or group responsible for it specificially
15:06:08 <jsnx> i need a 'project' or something
15:06:59 <wolverian> sorry. the maintainer is Stefan Potyra.
15:07:23 <wolverian> https://launchpad.net/~sistpoty/+packages here are his packages. :)
15:08:55 <astrolabe> jsnx: sadly, all useful programs have already been written.
15:09:35 <Cale> * [sistpoty] (n=sistpoty@ubuntu/member/sistpoty): Stefan Potyra
15:09:35 <Cale> * [sistpoty] #ubuntu-kernel #ubuntu-motu #ubuntu-devel
15:09:36 <jsnx> astrolabe: i meant 'project' in the sense of 'projection'
15:09:43 <Cale> He's online, but not in this channel :)
15:10:14 <jsnx> astrolabe: they are all encoded in the digits of pi, if only i could find this one
15:10:44 <realspace> there is also _K_ubuntu, if you don't like ubuntu...
15:12:57 <astrolabe> @djinn (a0 -> b0 -> c0) -> (a1 -> b1 -> c1) -> ((a0,a1)->(b0,b1)->(c0,c1))
15:12:57 <lambdabot> f a b (c, d) (e, f) = (a c e, b d f)
15:14:07 <astrolabe> Hello sistpoty, we were just talking about you :)
15:14:17 <sistpoty> hi astrolabe
15:14:24 <sistpoty> I hope nothing too negative :P
15:14:38 <ski> @type curry ((uncurry *** uncurry) >>> (curry . ((\((a,b),(c,d)) -> ((a,c),(b,d))) >>>) . uncurry (***)))
15:14:39 <lambdabot> forall a b c a1 b1 c1. (a -> b -> c) -> (a1 -> b1 -> c1) -> (a, a1) -> (b, b1) -> (c, c1)
15:14:52 <astrolabe> sistpoty: Sadly no :)
15:15:21 <ski> jsnx : possibly that's too unreadable ?
15:15:37 <sistpoty> :)... thanks to Igloo, I only pick up patches from him :)
15:15:52 <ski> @hoogle ((a,b),(c,d)) -> ((a,c),(b,d))
15:15:53 <lambdabot> No matches, try a more general search
15:15:54 <jsnx> ski: that's great that you did it, but in this case, it seems like a where with a pattern match is better
15:17:34 <jsnx> generalizing over tuples is a pain
15:17:44 <ski> *nod*
15:17:54 <jsnx> seems like we always get stuck with f1, f2, f3, f4...
15:18:10 <ski> hmm
15:18:24 <ski> i wonder if you could do something like `ap' here ..
15:18:38 <jsnx> can you explain more?
15:18:39 <ski> @type (***)
15:18:40 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
15:19:10 <ski> > liftM3 (,,) [0,1] [2,3] [4,5]
15:19:10 <lambdabot>  [(0,2,4),(0,2,5),(0,3,4),(0,3,5),(1,2,4),(1,2,5),(1,3,4),(1,3,5)]
15:19:25 <ski> > return (,,) `ap` [0,1] `ap` [2,3] `ap` [4,5]
15:19:25 <lambdabot>  [(0,2,4),(0,2,5),(0,3,4),(0,3,5),(1,2,4),(1,2,5),(1,3,4),(1,3,5)]
15:19:32 <ski> > (,,) `liftM` [0,1] `ap` [2,3] `ap` [4,5]
15:19:32 <lambdabot>  [(0,2,4),(0,2,5),(0,3,4),(0,3,5),(1,2,4),(1,2,5),(1,3,4),(1,3,5)]
15:19:43 <ski> something in a similar spirit to that
15:19:58 <jsnx> i need to think about that -- i never use `ap`
15:20:08 <ski> @type liftM2
15:20:09 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:20:11 <ski> @type ap
15:20:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:20:20 <ski> @type liftM
15:20:21 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
15:20:49 <ski> `(***)' is sortof like `liftM2 (,)', but for arrows
15:21:20 <ski> (though maybe `(&&&)' is the correct analogue, here .. hm)
15:21:25 <ski> @type (&&&)
15:21:26 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:24:07 <ski> (***) :: Arrow (~>) => (a0 ~> a1) -> (b0 ~> b1) -> ((a0,b0) ~> (a1,b1))
15:25:11 <ski> aap :: Arrow (~>) => ((b0 -> a0) ~> (a1 -> b1)) -> (a0 ~> a1) -> (b0 ~> b1)  -- ?
15:26:04 <ski> hm, probably not quite that
15:31:22 <ski> maybe a 2-category would be the right solution .. ?
15:34:52 <ski>   class TwoCategory ar ar2 | ar2 -> ar
15:34:57 <ski>     where
15:35:07 <ski>     id :: ar a a
15:35:16 <dolio> @type arr (,,)
15:35:17 <lambdabot> forall b b1 c (a :: * -> * -> *). (Arrow a) => a b (b1 -> c -> (b, b1, c))
15:35:43 <ski>     id2 :: ar a b -> ar2 a b a b  -- ?
15:36:08 <ski> no
15:36:12 <ski> that's not right
15:37:04 <dolio> What are you trying to do?
15:37:59 <dolio> I'm not sure arrows (as currently formulated) have direct analogues.
15:38:03 <dolio> Since you never apply them to values.
15:38:18 <ski> "liftM3 (,,) foo bar baz" can be written as "return (,,) `ap` foo `ap` bar `ap` baz"
15:39:26 <ski> hm
15:40:13 <ski> i was pondering some kind of analogue of that, for arrows (or something similar) .. but now i wonder if i maybe mistook the problem
15:40:43 <ski> @type app
15:40:44 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
15:42:50 <dolio> Did you read Wadler's new arrow calculus paper?
15:43:02 <dolio> Not that it will help, necessarily. :)
15:43:15 <ski> aap :: Arrow (~>) => ((a0 ~> a1) ~> (b0 ~> b1)) -> (a0 ~> a1) -> (b0 ~> b1)  -- ??
15:43:26 <ski> dolio : nope .. link handy ?
15:43:50 <dolio> http://homepages.inf.ed.ac.uk/wadler/topics/links.html#arrows
15:43:51 <lambdabot> Title: Wadler: Links
15:44:50 <ski> ty
15:45:29 <dolio> Although as someone in the reddit submission pointed out, theres a similarity between [m] and f * g in that paper and pure m and f <*> g in applicative functors.
15:46:23 <dolio> Which might not be an accident, since arrows and applicative functors are sort of inter-relatable.
15:48:20 <ski> dolio : oh, this looks *very* interesting (to compare with some ideas i've had myself regarding monads, idioms, to some extent comonads, and only vaguely for arrows) !
15:48:49 <ski> inter-relatable in what sense ?
15:49:12 <dolio> I belive that for any arrow (~>), (~>) r is an applicative functor.
15:49:33 <ski> hm .. that could be
15:50:28 <dolio> @type WrappedArrow
15:50:29 <lambdabot> Not in scope: data constructor `WrappedArrow'
15:51:07 <ski> instance Applicative i => Arrow (WrappedArrow i)
15:51:23 <ski> newtype WrappedArrow i a b = WA (a -> i b)
15:51:28 <ski> something like that ?
15:51:59 <ski> hm, maybe not, actually
15:52:26 <dolio> Well in Control.Applicative, WrappedArrow a b c = Wrap (a b c), instance (Arrow a) => Applicative (WrappedArrow a b)
15:52:39 <ski> (right .. the other way)
15:52:49 <ski> well, i should head for bed, i think
15:52:50 <dolio> instance (ArrowZero a, ArrowPlus a) => Alternative (WrappedArrow a b)
15:52:59 <ski> ty for the pointer
15:53:02 <dolio> You can probably go the other direction, too.
15:53:09 <dolio> Like Kleisli for monads.
15:53:15 <ski> *nod*
15:53:21 <dolio> Night.
15:54:07 * ski `yield` sleepCoroutine
16:19:21 <awesame> how do I get the length of a Foreign.C.String.CString?
16:19:57 <Lemon> how would I go about writing a ghc extension?
16:21:41 <awesame> ah, withCStringLen will give it to me when I generate it
16:21:42 <awesame> nm
16:22:09 <roconnor> @go 1 mole g in g
16:22:15 <lambdabot> http://dbhs.wvusd.k12.ca.us/webdocs/Mole/MolarMass.html
16:22:15 <lambdabot> Title: ChemTeam: The Mole & Molar Mass
16:22:20 <roconnor> @go 1 mol g in g
16:22:22 <awesame> having links to the source for haskell libraries in the docs is fantastic, btw
16:22:22 <lambdabot> http://en.wikipedia.org/wiki/Molar_mass
16:22:22 <lambdabot> Title: Molar mass - Wikipedia, the free encyclopedia
16:22:35 <roconnor> @go 1 mol in g
16:22:36 <lambdabot> http://antoine.frostburg.edu/chem/senese/101/moles/index.shtml
16:22:36 <lambdabot> Title: General Chemistry Online: Companion Notes: The mole
16:22:53 <awesame> I'm starting to learn how to do things by thinking "what's a function that would have to do that?" and looking up the source
16:28:41 <ddarius> Wouldn't it be easier to think "what's a function that does that?" and just using it?
16:29:59 <Cale> You learn more by looking at how it works though :)
16:36:14 <ehird> Did anyone reply to my thing about parsing-by-example?
16:36:44 <Cale> ehird: I asked what you meant by "parsing by example", but maybe I left before you replied.
16:37:42 <Jedai> @src replicate
16:37:42 <lambdabot> replicate n x = take n (repeat x)
16:38:00 <ehird> Cale: Ah. Well I meant 'model a sort of EXAMPLE of what you would like to parse, with placeholders for where concrete data will go.'
16:38:06 <ehird> I hope you kind of get what I'm saying.
16:38:14 <ehird> It would be a very 'functional' way to model parsing.
16:38:33 <Cale> Isn't that sort of how parsers are always written?
16:39:56 <Cale> Except maybe some poorly written ones in imperative languages which go fiddling with strings of characters and indices and so on.
16:40:20 <ehird> Cale: Not parsec parsers.
16:40:27 <ehird> They have a distinctly imperative feel.
16:40:32 <Cale> Really?
16:40:36 <ehird> IMO. Yes.
16:40:38 <Cale> They feel pretty functional to me.
16:41:03 <Cale> You start with basic parsers, and join those together in various ways to build up more complicated ones
16:41:15 <ehird> @type (\f xs -> do x <- xs; return (f x))
16:41:16 <lambdabot> forall (t :: * -> *) t1 t2. (Monad t) => (t1 -> t2) -> t t1 -> t t2
16:41:16 <Cale> Using concatenation of parsers, and alternation between parsers.
16:41:32 <ehird> Um, oops. Of course.
16:41:33 <Cale> The do-syntax is merely a way to express concatenation of parsers.
16:41:36 <ehird> Wait, no
16:41:37 <ehird> Hmm
16:41:41 <ehird> @hoogle (Monad t) => (t1 -> t2) -> t t1 -> t t2
16:41:46 <lambdabot> Did you mean: Monad t => (T1 -> T2) -> t T1 -> t T2
16:41:46 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
16:41:46 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
16:41:48 <ehird> I think that's fmap.
16:42:00 <ehird> Cale: I guess so... Even so
16:42:12 <Cale> That is, it's not intended to feel imperative, it's just a shorthand for gluing.
16:42:22 <Cale> (not intended in this case, at least)
16:42:47 <Cale> After all, the order in which your parsers execute isn't necessarily directly the order of the do-block
16:43:07 <Cale> (though it is in the case when the parsers don't backtrack much)
16:44:40 <Cale> Of course, if you want an even more functional-looking approach, you could use the Control.Applicative library with Parsec -- at least in principle, I'm not sure that the instance is actually available.
16:45:07 <Cale> (If it's not, that should be considered a bug :)
16:45:26 <ehird> @type fmap
16:45:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:45:35 <ehird> thought so
16:45:40 <ehird> is there a reason map isn't fmap?
16:45:48 <Cale> not a good one
16:46:01 <Cale> ah, yeah, there's an instance of Alternative and Applicative in the new parsec.
16:46:07 <elliottt> ehird: simplicity i thought
16:46:19 <elliottt> when starting out, it's easier to think of map only on lists
16:46:23 <Cale> It's so that people don't have to teach beginners what a Functor is.
16:46:27 <ehird> elliottt: having a general and a specific version is 'simple'?!
16:46:39 <ehird> Cale: ah yes, the 'learning' argument
16:46:39 <elliottt> ehird: like Cale says :)
16:46:45 <Cale> It's more complicated in the end, but some people think that it's somehow easier to teach.
16:46:55 <ehird> if Haskell was meant to be the easiest language to learn, ever, then it would look nothing like it does
16:46:56 <monochrom> @type (+)
16:46:57 <lambdabot> forall a. (Num a) => a -> a -> a
16:47:14 <resiak> monochrom: normal people know what a 'number' is
16:47:18 <Cale> I actually disagree, and think that just teaching the general idea from the outset would be better in this case, especially as specific cases can be focused on rather easily.
16:47:33 <ehird> monochrom: Should be mappend! :-P
16:47:51 <Cale> ehird: But should mappend be (+) or (*)? :P
16:47:55 <ehird> Num should be a subclass of Monoid! Okay, this is making less and less sense as I go along.
16:47:55 <monochrom> I know someone who disagrees.
16:48:05 <ehird> Cale: (-), DUH.
16:48:10 <Cale> heh
16:48:14 <twanvl> map is a great example of recursion over lists, though
16:48:17 <resiak> monochrom: you know someone who knows what a functor is but not a number?
16:48:21 <ddarius> mappend is not commutative in general (or even usually) which suggests (*)
16:48:25 <Cale> twanvl: The instance of fmap for lists is as well.
16:48:40 <ddarius> resiak: Numbers are a lot more complicated than functors.
16:48:56 <ehird> hmm, it occurs to me that a concatenative language is the best environment for parser combinators
16:49:08 <Cale> If you're smart enough to learn what a number is, you're surely smart enough to learn what a functor is.
16:49:09 <ehird> the composition of parsers is just as normal functions
16:49:11 <resiak> ddarius: Sure, but I don't compose functors at the supermarket :-)
16:49:31 <Cale> resiak: Learning a new language *should* be a learning process.
16:49:31 <monochrom> Chris Smith disagrees that normal people already know "number".
16:49:39 <twanvl> Cale: yes, but it might make sense to explain, say, pattern matching and data types before explaining what a functor is.
16:49:45 <Cale> monochrom: I actually agree with him on that then :)
16:49:45 <shachaf> ehird: (-)?
16:49:58 <ehird> shachaf: Yes! :D
16:50:01 <ehird> Or `div`.
16:50:10 <ehird> And I know `div` isn't in Num.
16:50:13 <ehird> I'm just being ridiculous
16:50:17 <Cale> twanvl: and you can do that of course :)
16:50:24 * shachaf would at least hope for an associative mappend.
16:50:31 <Cale> twanvl: People even introduce myMap before they introduce map :)
16:50:32 <resiak> Cale: I know, and I agree with you about fmap, I'm just trying to play devil's advocate :)
16:51:14 <Cale> A lot of people, even some people in mathematics who should know better, don't seem to fully grasp the idea that the natural numbers are an abstraction.
16:51:58 <ehird> : anbn ['a' char anbn 'b' char 1 +] [] choose ;    \ parses a^nb^n and returns the number of pairs
16:52:09 <ehird> example of what a concatenative combinator-parser library might look like
16:52:09 <ddarius> Natural numbers are an abstraction?!
16:52:10 <ehird> i like it
16:52:14 <twanvl> Cale: what do you mean by 'abstraction' herre? The natural numbers are just a structure satisfying some axioms
16:52:50 <Cale> twanvl: they are any structure satisfying those axioms
16:53:12 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/38314 by Chris Smith. "I have enough time already trying to explain Num, Fractional, Floating, RealFrac, ... to new haskell programmes"
16:53:14 <lambdabot> Title: Gmane -- Mail To News And Back Again
16:53:23 <ehird> monochrom: Ouch
16:53:26 <twanvl> Cale: yes; and in that sense they are indeed an abstraction
16:53:35 <ddarius> Why would you explain anything to Haskell programmes?
16:53:43 <Cale> ddarius: hehe
16:54:46 <ehird> In the spirit of monads and comonads, I bring you sidemonads.    splice :: (Sidemonad e) => a -> (e a -> b) -> b
16:54:53 <ehird> I don't know why it's called splice, or what use it could possibly have.
16:54:56 <ehird> But it's called splice.
16:55:20 * koninkje hopes all that other cruft does get split out from Ring/Num class
16:55:54 <ehird> Oh, and
16:55:56 <ehird>     redact :: e (e a) -> e a
16:55:58 <Cale> As someone with a mathematical background, I don't think that Ring is an appropriate name for Num, or even that Haskell should necessarily have a class called Ring.
16:56:09 <twanvl> ehird: you should flip the arguments to  splice :: (e a -> b) -> (a -> b)
16:56:14 <Cale> After all, we want Float and Double to fit in somewhere, and they're not rings.
16:56:20 <ehird> twanvl: But then it doesn't mirror monads.
16:56:39 <jberryman> what is the function to collapse nested lists into one list, please?
16:56:45 <Cale> jberryman: concat
16:56:46 <twanvl> ehird: but then they do mirror functors, functions, and nearly everything else
16:56:52 <jberryman> Cale: thanks
16:56:54 <Cale> > concat [[1,2,3],[4,5],[6,7,8]]
16:56:55 <lambdabot>  [1,2,3,4,5,6,7,8]
16:56:58 <koninkje> Ring (nor semiring) isn't an appropriate name for haskell's Num, but I've had many occasions of working on (semi)ring structures and it'd be nice to have a single obvious class for them
16:57:05 <ehird> twanvl: Yeah, that's true. :P
16:57:12 <Cale> > concat [[[1,2,3],[4,5],[6,7,8]],[[9,10],[11,12,13]]
16:57:13 <lambdabot>  Parse error at end of input
16:57:14 <Cale> > concat [[[1,2,3],[4,5],[6,7,8]],[[9,10],[11,12,13]]]
16:57:15 <lambdabot>  [[1,2,3],[4,5],[6,7,8],[9,10],[11,12,13]]
16:57:17 <twanvl> Cale: Float and Double will probably never fit in anywhere
16:57:20 <ehird> Hmm. I can't think of any Sidemonads.
16:57:25 <Cale> > map concat [[[1,2,3],[4,5],[6,7,8]],[[9,10],[11,12,13]]]
16:57:26 <lambdabot>  [[1,2,3,4,5,6,7,8],[9,10,11,12,13]]
16:57:32 <Cale> > concat . concat $ [[[1,2,3],[4,5],[6,7,8]],[[9,10],[11,12,13]]]
16:57:32 <koninkje> Cale: semirings I find even more often than rings...
16:57:33 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13]
16:57:34 <gwern> hm... I forget, does [Word8] = ByteString?
16:57:45 <Cale> twanvl: Which is why Num is a good name :)
16:57:46 <ehird> gwern: No. ByteString isn't a list.
16:57:52 <ehird> gwern: As far as I know.
16:58:18 <koninkje> ehird: it isn't, that's part of the point. its an UArray or some simmilar beast
16:58:20 <ddarius> A lazy bytestring is (essentially) a list of strict bytestrings, but no, bytestrings aren't lists.
16:58:21 <Cale> Because even if they're not rings, they're intuitively a kind of number.
16:58:46 <ehird> If anyone thinks of a Sidemonad I'd be glad to hear about it
16:59:15 <ddarius> ehird: Why are you naming random collections of functions?
16:59:18 <ehird> Ah. there are none.
16:59:26 <ehird> You need an (e a) to be able to do anything.
16:59:30 <koninkje> Cale: but there's no reason to not have: class Ring r => Num r where... is there?
16:59:33 <ehird> Oh, wait, no.
16:59:35 <ehird> Hmm
16:59:38 <Cale> ehird: That doesn't mean there aren't any :)
16:59:48 <ehird> Cale: Yes, I just realised that. Heh. I'm stupid.
16:59:55 <Cale> koninkje: Except that it makes things complicated?
17:00:08 <ehird> Still, I can't really think of any.
17:00:08 <ehird> ddarius: Eh. ;)
17:00:26 <koninkje> Cale: only complicated for those crazy folks who deal with numbers more often than rings :)
17:00:36 <Cale> koninkje: We could explore these ideas better if we had something like class aliases.
17:01:06 <koninkje> Cale: indeed.
17:01:33 <Cale> I actually think that the Haskell numeric hierarchy, while it's obviously not perfect in a lot of ways, does strike quite a decent balance between mathematical structure and the practical considerations of representing numbers on a computer.
17:02:23 <Cale> We really should have classes for working with the structure of floating point values for example.
17:02:32 <twanvl> Cale: I would like to see at least a class for just addition split off
17:02:50 <awesame> augh, I am lost in a twisty maze of String, ByteString [Word8], encode, decode, chr, ord, and withCString
17:03:09 <gwern> awesame: hee hee. I've often felt like that too
17:03:16 <Cale> twanvl: Yes, it'd be great if addition and multiplication were separated out, and you could define one without the other, and yet defining them all together was no harder than it presently is.
17:03:18 <koninkje> I agree, with two caveats. First is that they could use some more documentation (especially around the distinctions on the Ratio/Rational, Real, Floating... end; i.e. the distinctions beyond just the interface). And second is that I'd like to see semirings broken out.
17:03:38 <awesame> I think I wish ByteString were used more in the haskell standard libraries
17:03:49 <ddarius> awesame: Give it time.
17:03:57 <awesame> there's a lot of use of encoded Strings rather than proper Unicode Strings
17:04:50 <Cale> I think if we get Class Aliases in, then the Prelude can define some very fine structure along with some very rough structure and a lot of this arguing over which classes should be present will go away because we'll be able to put together the abstractions we want from the finer pieces.
17:04:57 <Cale> At least if it's done carefully.
17:05:48 <nolrai_> that seems reasonable.
17:06:27 <twanvl> Speaking of class aliasses, what do you people here think of my slightly different class alias proposal? (http://haskell.org/haskellwiki/Superclass_defaults)
17:08:00 <Jedai> @src replicateM
17:08:00 <lambdabot> replicateM n x = sequence (replicate n x)
17:11:56 <ehird> snarky:
17:11:57 <ehird> @type (.)
17:11:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:12:06 <TomMD> ByteString should be an instance of Num - anyone else think so?
17:12:08 <ehird> @src (.)
17:12:08 <lambdabot> (f . g) x = f (g x)
17:12:13 <ehird> well that's broken
17:13:25 <koninkje> on a completely different topic, I was wondering if there's any good library out there for pickling? --where "good" means it's very quick to unpickle; and fragility across upgrades is perfectly fine
17:13:44 <Jedai> ehird: @type give the actual type in Lambdabot, while @src get the standard source, not those used in lambdabot
17:13:48 <koninkje> i.e. using pickling as a preprocessing step when we can rederive things
17:13:58 <jsnx> koninkje: Data.Binary ?
17:14:17 <Jedai> It don't handle versioning though
17:14:20 <gwern> ok... does anyone know of a SHA1 modules besides those in: Crypto, Conjure, Yi, Ginsu, JHC, HAppS, and Darcs?
17:14:33 <ehird> Jedai: :-)
17:14:38 <TomMD> gwern: Must the hash be SHA1?
17:14:40 <Jedai> but if you want a fast library, Data.Binary is it sure
17:14:47 <jsnx> or else he just doesn't look that good
17:14:49 <jsnx> oops
17:14:51 <gwern> TomMD: well, SHA256 would also be germane for my purpose
17:14:56 <ehird> gwern: I like SHA512
17:15:11 <koninkje> jsnx: excellent, thanks
17:15:30 <twanvl> gwern: why do you need that many SHA1s?
17:15:40 <gwern> ehird: I know, but darcs does not use SHA512
17:15:46 <ehird> twanvl: he is a hackage upload script
17:15:47 <TomMD> gwern: Well, I will mention pureMD5, though it obviously won't help you.  If you have time you could follow such a structure and implement SHAx.
17:15:50 <ehird> totally automated
17:16:25 <gwern> twanvl: I don't; I'm trying to point out to the darcs devs it's a bad thing to have their own SHA implementations
17:16:33 <gwern> in part by adducing examples
17:16:45 <ddarius> gwern: It sounds like we need less SHA1 modules, not more.
17:17:09 <gwern> ehird: no, I'm a human! really, I'll even prove it in a conversation
17:17:28 <gwern> ddarius: yes, I've long felt so...
17:17:55 <TomMD> What we need is a performant crypto module.
17:18:02 <TomMD> s/module/package
17:18:15 <gwern> Crypto doesn't have high performance?
17:18:24 <TomMD> Far from it.
17:18:50 <gwern> oh. that's strange. I had assumed it was the place to find optimized crypto stuff
17:19:14 <TomMD> And all the SSL bindings I've seen are for strict bytestrings (good luck if you have less memory than you want to hash.)
17:20:58 <nolrai_> @hoogle Maybe a -> m a
17:20:58 <lambdabot> Data.Maybe.fromJust :: Maybe a -> a
17:20:58 <lambdabot> Data.Maybe.fromMaybe :: a -> Maybe a -> a
17:20:58 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
17:23:38 <nolrai_> I want to change an Maybe a to and Either b a, i can just use "case -- of" but I was hopeing for a better way.
17:24:21 <nolrai_>  /and/an
17:24:42 <tromp> :t maybe
17:24:43 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:25:10 <nolrai_> duh.
17:25:18 <tromp> > maybe (Left "Nothing") id (Just 2)
17:25:18 <lambdabot>        add an instance declaration for (Num (Either [Char] b))
17:25:25 <TomMD> > succ "nolrai_"
17:25:25 <lambdabot>   add an instance declaration for (Enum [Char])
17:25:25 <lambdabot>     In the expression: succ "...
17:25:36 <tromp> > maybe (Left "Nothing") Right (Just 2)
17:25:36 <lambdabot>  Right 2
17:25:42 <tromp> > maybe (Left "Nothing") Right Nothing
17:25:43 <lambdabot>  Left "Nothing"
17:25:56 <nolrai_> awsome
17:26:11 <gwern> if you're curious about darcs and hashes - http://lists.osuosl.org/pipermail/darcs-devel/2008-April/007819.html
17:26:13 <lambdabot> Title: [darcs-devel] SHA hashing, http://tinyurl.com/6e8q28
17:29:08 <TomMD> gwern: Thanks for the link - I'll follow along.
17:35:35 <koninkje> twanvl: re your proposal, under <<Superclass defaults>> why force all the classes to have the same arguments? Or rather, why not allow: instance (Class1, Class2, Class3) a where...
17:35:37 <awesame> @source take
17:35:37 <lambdabot> take not available
17:35:49 <Cale> @src take
17:35:49 <lambdabot> take n _      | n <= 0 =  []
17:35:49 <lambdabot> take _ []              =  []
17:35:49 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
17:35:56 <awesame> oops, src
17:36:51 <twanvl> koninkje: perhaps forcing them to have exactly the same arguments is too restrictive, but we dont want to end up in the situation where you say: instance (Class1 X, Class2 Y, EveryOtherClassInMyProgram EveryOtherTypeInMyProgram) where ...
17:37:23 <koninkje> twanvl: my point was more of a syntactic one, namely, why not factor out the common type?
17:37:39 <koninkje> twanvl: all this is ignoring classes with more than one parameter, natch
17:38:12 <twanvl> koninkje: indeed, for multi parameter type classes your syntax will not work
17:38:46 <koninkje> it could be made to work...
17:39:12 <koninkje> are multi-parameter classes on the approved list for haskell'?
17:39:22 <twanvl> koninkje: quite likely
17:39:32 <koninkje> sweet.
17:39:55 <Cale> They're almost the reason for Haskell'
17:40:26 <twanvl> unfortunatly, at the current rate it will still be at least five years before the standard is finished
17:40:38 <Cale> So it would be strange if they didn't get included. However, formalising the exact meaning of MPTCs has been a major sticking point.
17:40:49 <dolio> Well, that'll give time for type families to get in. :)
17:40:54 <Cale> It might actually be best to go with type families, yeah.
17:41:18 <koninkje> I wasn't aware whether they'd resolved the exact meaning sufficiently to mark it as approved (rather than really desired)
17:41:24 <Cale> As I see more examples, I'm more convinced that type families are a sane approach and decent replacement for fundeps.
17:41:43 <ddarius> That's the issues.  It's FunDeps that are holding it up, but now they seem to be thinking about putting that off 'til another standard, but MPTCs and FunDeps (or something equivalent) is one of the main motivators for Haskell' anyway.
17:42:32 <Cale> (and MPTCs without fundeps or something is kind of a silly compromise to even consider)
17:42:53 <twanvl> there are also some other useful really things, like FlexibleInstance
17:43:02 <dolio> I recall the fundeps section suggesting that associated types are the real solution for as long as I can remember, but we're only just now getting (an extension of) them.
17:43:04 <Cale> Oh, for sure :)
17:43:37 <Cale> Type functions!
17:43:46 <ddarius> Cale: Indeed.
17:44:31 <TomMD> Having only read the paper, and not really used type classes, I feel FunDeps are just enough simpler for 80% of the use cases.  Is this a common opinion?
17:44:51 <Staz> take 5 [1..] <-- So the taking occurs as the list is being built?
17:45:08 <dolio> Type families seem superior most of the time to me.
17:45:25 <dolio> Although it's not too hard to cook up examples where fundeps seem more concise/clear.
17:45:42 <nolrai_> :t Map.lookup
17:45:43 <lambdabot> Couldn't find qualified module.
17:45:50 <nolrai_> :t lookup
17:45:51 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
17:46:39 <dolio> For one, you can do a lot more type-level stuff with type families without having to turn on undecidable instances than you can with mptcs + fundeps in my experience.
17:46:57 <ddarius> TomMD: For simple things, FunDeps and Associated Types seem comparable.
17:47:49 <dolio> Even the MTL lifting classes need undecidable instances with fundeps, but not with type families.
17:48:45 <Cale> TomMD: I don't know if they're simpler really. The common cases seem pretty similar.
17:48:49 <stepcut> my fundeps always get out of control
17:49:00 <Cale> (from a user perspective)
17:49:04 * stepcut has not learned type families yet
17:49:48 <Saizan> dolio: but type instances have the restriction that they can't overlap, doesn't that rule out a lot of type hackery?
17:50:10 <Cale> Someone redid the mtl with associated types, and the code looked nice and pretty.
17:50:11 <jsnx> type families are not in 6.8.2, though -- we have to use 6.9?
17:50:20 <Staz> 1@src take
17:50:23 <Staz> @src take
17:50:23 <lambdabot> take n _      | n <= 0 =  []
17:50:23 <lambdabot> take _ []              =  []
17:50:23 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
17:50:24 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mtl-tf-0.1
17:50:27 <dolio> Saizan: Maybe. Although apparently there will be closed families that can overlap, so maybe that will alleviate the problem.
17:50:27 <lambdabot> http://tinyurl.com/6z8sfl
17:50:45 <dolio> Those aren't in 6.8, though.
17:50:54 <Saizan> jsnx: they are in 6.8.2 but not documented
17:51:19 <nolrai_> what are type famlies?
17:51:23 <Cale> jsnx: type families are apparently poorly supported by 6.8 so you probably should wait until 6.10.
17:51:28 <Saizan> dolio: oh, nice, are they already in HEAD?
17:51:30 <dolio> They're changing a fair ammount between 6.8 and 6.10, though.
17:52:18 <dolio> Saizan: I'm not sure about that. My guess would be no, but SPJ said they were coming, I think.
17:52:40 <Cale> type family StateType (m :: * -> *)
17:52:43 <Cale> class (Monad m) => MonadState m where
17:52:43 <Cale>     get :: m (StateType m)
17:52:43 <Cale>     put :: StateType m -> m ()
17:53:04 <jsnx> the great/terrible thing about haskell is no matter how much you learn, there's always some crazy new thing that will completeley change everything just a little further along on the pipe
17:53:29 <Cale> There's a downside to that? ;)
17:53:35 <ddarius> I don't think anything has come along that has "completely changed everything"
17:54:16 <jberryman> another dumb question: how would I pattern match for the last, say, two integers in a list?
17:54:25 <ddarius> In fact, the slope seems nicer with Haskell than with e.g. C# since changes happen more gradually (though more often)
17:54:27 <jsnx> jberryman: no such pattern
17:54:59 <nolrai_> jsnx: what about a : b : []?
17:55:02 <Cale> jberryman: You can't directly pattern match, but you can get the last two elements in other ways.
17:55:15 <Cale> nolrai_: that's the first (and only) two elements
17:55:22 <jsnx> nolrai_: that matches a two element list
17:55:34 <TomMD> jberryman: > \xs -> drop (length xs - 2) xs
17:55:36 <jsnx> Cale: why is get :: m (StateMonad m)
17:55:41 <ddarius> And incidentally can be sugared as [a,b]
17:55:45 <Cale> jsnx: m (StateType m)
17:55:54 <jsnx> aye
17:56:05 <TomMD> > let xs = [1..10] in drop (length xs - 2) xs
17:56:05 <lambdabot>  [9,10]
17:56:07 <Cale> jsnx: It's a computation in the monad m which returns a value of the state type of m
17:56:16 <jsnx> oic
17:56:20 <TomMD> > let xs = [1] in drop (length xs - 2) xs
17:56:21 <lambdabot>  [1]
17:56:27 <jsnx> so it associats a StateType with m
17:56:33 <dolio> Saizan: http://www.haskell.org/pipermail/glasgow-haskell-users/2007-October/013271.html
17:56:34 <ddarius> take 2 . reverse
17:56:37 <jsnx> (the type family)
17:56:41 <lambdabot> Title: type families not advertised for 6.8, http://tinyurl.com/6amndm
17:56:44 <Cale> jsnx: StateType is a type function, effectively, which sends a monad to the type of state which is associated to it
17:56:52 <jsnx> oic
17:56:57 <jsnx> interesting...
17:57:05 <Cale> jsnx: (so yeah, your description is accurate)
17:57:19 <ddarius> dolio: The implementation of type families and related things is seriously incomplete and buggy in 6.8
17:58:29 <dolio> Well, it's worked passably for what little experiments I've done with them, but I'm probably not exercising them very hard.
17:58:49 <jsnx> are they any plans to bring us 'number types' so we can do things like Vector 4 ?
17:58:58 <ddarius> Nope.
17:59:11 <dolio> Of course, maybe I have run into bugs/incompleteness and just assumed I was doing something wrong/worked around it.
17:59:15 <jsnx> Of course I saw that article about doing with it with D1, D2, &c.
17:59:31 <ddarius> dolio: That's possible.
17:59:43 <Saizan> dolio: if they implement those closed type families a lot of things will become quite nicer i think
17:59:51 <Cale> I talked to Simon Marlow earlier today, and he seemed very receptive to ideas, which was very cool.
17:59:54 <ddarius> Heffalump said something about having code that was a mess working around issues with type families and such.
18:00:01 <jsnx> Cale: which ideas?
18:00:17 <ddarius> Cale is pouring poison into Simon's ear.
18:00:44 <Cale> jsnx: Lots of ideas regarding the Prelude, the MR is as good as dead, and we discussed briefly some things regarding strictness annotations.
18:01:12 <dolio> I did have a lot of trouble proving (Length (Snoc ts t)) ~ (Succ (Length ts)) not too long ago.
18:01:53 <dolio> I ended up having to do the proofs in a where clause with scoped type variables.
18:02:09 <Cale> dolio: hmm, you're encoding the proof in the type system then?
18:02:46 <dolio> Yeah. I needed to coerce 'Nat former' to 'Nat latter' or something like that.
18:03:11 <jsnx> MR ?
18:03:19 <jsnx> MonadReader?
18:03:21 <Cale> jsnx: Monomorphism restriction
18:03:26 <jsnx> oh
18:03:38 <dolio> Which is easy when you get an equality GADT of the right type, but getting the GADT wasn't as easy as I'd hoped.
18:03:39 <jsnx> hurray, death to monomorphism restriction
18:03:42 <Cale> Oh, I should have mentioned the stupid context!
18:03:56 <Cale> Oh well, I'll mention that next time I see him :)
18:04:15 <Cale> and it's probably on the table already anyway
18:04:27 <jsnx> as for number parameterized types -- you would'nt need full dependent typing for it
18:04:39 <jsnx> you could just have sugar for numbers in type signatures
18:04:41 <dolio> Cale: You can see it here: http://hpaste.org/6802
18:08:05 <dolio> Oh, this is another oddity: http://hpaste.org/6907
18:09:46 <hpaste>  morrow pasted "zipsL" at http://hpaste.org/6939
18:10:02 <dolio> GHC won't let me specify that to look up something in a vector of length n, you need something of type Fin n.
18:10:10 <dolio> More or less.
18:11:37 <dolio> But I don't know how much of this is GHC bugs, and how much is my not knowing exactly what I'm doing.
18:15:33 <Cale> dolio: I'll have a closer look in a bit. I have some studying to do for an exam tomorrow morning.
18:16:32 <Cale> dolio: But from the comments that I've heard, if you're using 6.8, you can't expect much to work :P
18:17:22 <dolio> Resolving type families into their types seems to not happen in 6.8, too.
18:18:05 <dolio> Like, if you have 'type instance F Char = Int' and you enter in '5 :: F Char' I wouldn't be surprised if it fails to print 5.
18:18:16 <dolio> Complaining that there's no instance of Show for (F Char).
18:18:23 <Cale> heh, yeah, I ran into that
18:18:47 <Cale> (In the tiny amount of playing around with type families I did when 6.8 came out)
18:19:22 <dolio> I should see if I can install 6.9 some time.
18:20:19 <Cale> Apparently they're using type families in their nested data parallelism stuff -- it's nice how things fit together :)
18:22:01 <SamB> Cale: you didn't know that?
18:26:13 <Cale> SamB: I did know that :)
18:26:21 <Cale> SamB: I was just reflecting on it
18:27:34 <SamB> why did you say "apparantly" about something you didn't just discover in the past month or so?
18:30:36 <nolrai_> @pl dotdot f1 f2 a b -> f1 (f2 a b)
18:30:36 <lambdabot> (line 1, column 18):
18:30:36 <lambdabot> unexpected ">" or "-"
18:30:36 <lambdabot> expecting variable, "(", operator or end of input
18:30:43 <nolrai_> @pl dotdot f1 f2 a b = f1 (f2 a b)
18:30:43 <lambdabot> dotdot = (.) . (.)
18:35:03 <Cale> SamB: Because it is apparent? :P
18:43:34 <roconnor> @go 1 EUR in USD
18:43:35 <lambdabot> http://www.x-rates.com/d/USD/EUR/graph120.html
18:43:35 <lambdabot> Title: Exchange Rates Graph (Euro, American Dollar)
18:44:01 <roconnor> lambdabot doesn't do calculator anymore.
18:44:35 <roconnor> 1 Euro = 1.5823 U.S. dollars
18:44:38 <roconnor> good god!
18:45:25 <nolrai_> @pl dotdot a b -> f1 (f2 a b)
18:45:25 <lambdabot> (line 1, column 12):
18:45:25 <lambdabot> unexpected ">" or "-"
18:45:25 <lambdabot> expecting variable, "(", operator or end of input
18:45:32 <nolrai_> @pl dotdot a b = f1 (f2 a b)
18:45:32 <lambdabot> dotdot = (f1 .) . f2
18:45:33 <roconnor> I'm glad I have 1/3 of my savings in Euros.
18:46:08 <Saizan> GSoC is paid in dollars though
18:46:17 <roconnor> :D
18:46:22 <roconnor> oh wait
18:46:26 <roconnor> google is paying
18:46:28 <roconnor> :(
18:46:41 <roconnor> for the moment I was thinking "cheap student labour"
18:47:43 <Saizan> cheap for google maybe :)
19:03:24 <nolrai_> @hoogle intersperse
19:03:30 <lambdabot> Data.List.intersperse :: a -> [a] -> [a]
19:03:31 <lambdabot> Data.ByteString.intersperse :: Word8 -> ByteString -> ByteString
19:03:31 <lambdabot> Data.ByteString.Char8.intersperse :: Char -> ByteString -> ByteString
19:05:14 <nolrai_> is there a shorter version of (concat .) . intersperse?
19:05:54 <Saizan> ?ty intercalate
19:05:57 <lambdabot> forall a. [a] -> [[a]] -> [a]
19:06:28 <nolrai_> thanks
19:07:39 <heatsink> who thinks up these names?
19:07:47 <pantsd_> is there an easy way to take make parsec stuff be cool with bytestring?
19:07:47 <heatsink> I would never have come up with that.
19:08:12 <gwern> pantsd_: doesn't the latest parsec use bytestrings?
19:08:20 <gwern> or was that not released yet...
19:08:28 <Saizan> pantsd_: yeah, use parsec 3
19:08:44 <Saizan> gwern: there was an ANN for it no?
19:08:55 <pantsd_> d'oh
19:16:27 <Cale> heatsink: It's a brilliant name though :)
19:16:38 <heatsink> yeh.
19:17:01 <Cale> (at least for reading)
19:17:09 <davidL> what name?
19:17:16 <ivanm> what's wrong with saying it?
19:19:20 <Saizan> in other languages it's often called join i suppose, but we've taken join for an higher cause :)
19:20:06 <geezusfreeek> most other languages don't really differentiate between "foo" ++ 'b' and "foo" ++ "bar" though
19:20:31 <geezusfreeek> s/most/many/
19:32:02 <Staz> flip (flip f)
19:32:16 <Saizan> ?type flip . flip
19:32:17 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
19:33:03 <Staz> flip (flip f) => flip (flip f) x y  <-- Does this step have a special name? "reverse currying simplification" or something?
19:33:47 <heatsink> I don't see how you get the RHS from the LHS.  Where did x and y come from?
19:33:54 <Saizan> flip (flip f) = \x y -> flip (flip f) x y is eta-expansion
19:34:29 <Staz> Saizan : cheers -- I'll look into that.
19:43:08 <chessguy> @pl \x -> f x x
19:43:08 <lambdabot> join f
19:43:45 <heatsink> @type join
19:43:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
19:49:56 <andyjgill> I'm getting a Setup.lhs:4:30: Not in scope: `autoconfUserHooks' message when building a new package, any ideas?
19:57:30 * SamB wonders how the heck you make a decent IR pretty printer...
20:00:00 <nolrai_> what's IR?
20:00:01 <heatsink> SamB: I guess the hard thing is making the important information prominent.  Otherwise, it's just a Text.PPrint exercise...
20:00:58 <SamB> heatsink: is that Daan's PPrint?
20:01:55 <heatsink> Oh... It's Text.PrettyPrint.  Says it's John Hughes and SPJ's.
20:03:24 <SamB> JHC's "E" language uses John Meacham's modified version of Daan's PPrint library...
20:04:21 <SamB> I am not really very thrilled with either Daan or Wadler's versions, actually...
20:04:46 <SamB> and John doesn't seem to have changed much
20:06:23 <SamB> just look at this:
20:06:26 <SamB> fullCheck: Œõa.
20:06:26 <SamB>            ŒªControl.Arrow.251_f‚à∑Control.Arrow.Kleisli@(Œõf0.Œõb.Œõc.
20:06:26 <SamB>                                                        b ‚Üí f0 c)
20:06:26 <SamB>                                 Control.Arrow.v1188 Control.Arrow.v1189
20:06:26 <SamB>                                 Control.Arrow.v1190.
20:06:28 <dolio> One hour down...
20:07:03 <SamB> and weep, if you use an IRC client which doesn't keep everything grid-aligned
20:07:16 <SamB> like me
20:07:27 <heatsink> Oh.  Mine keeps it aligned.
20:07:32 <heatsink> I didn't know there was a :: character.
20:07:55 <SamB> I can't find a font with that in for windows :-(
20:07:57 <heatsink> it looks pretty though.
20:08:06 <ivan> Verdana
20:08:19 <SamB> at least, not one that putty is willing to use
20:08:25 <ivan> xchat
20:08:26 <Saizan> i'd say the uglyness comes from fully qualified names
20:08:55 <SamB> personally, I'd blame the stair-step effect
20:09:02 <dolio> v1188 isn't a great name, either.
20:09:20 <SamB> I can't come up with a way to get rid of that using Daan's primitives...
20:09:58 <heatsink> SamB: Do you have another indentation scheme in mind?
20:10:02 <Saizan> how'd you like that to be printed?
20:11:18 <SamB> I'd like to have some things "paragraph filled", but if a given item needs more than one line, I want it to have nothing before or after it on it's first/last line ... or something like that...
20:11:25 <Saizan> less \n on dots would be nicer i think
20:11:40 <SamB> that is, I want lines to be broken as far up the parse tree as possible
20:12:04 <SamB> I suppose wadler is really blameless - his library couldn't print stuff like this
20:12:16 <SamB> it didn't support alignment at all
20:12:22 <SamB> only nesting
20:13:00 <SamB> is it just me or is Daan good at botching abstractions?
20:13:10 <SamB> Parsec, PPrint...
20:13:16 * heatsink likes parsec
20:13:53 <SamB> I might like it more if it wasn't so damn deterministic
20:14:10 <heatsink> You want a probabilistic parser?
20:14:32 <SamB> er, you know, deciding which path to take based on a single character?
20:15:02 <SamB> you know the difference between an NFA and a DFA don't you?
20:15:18 <SamB> nolrai_: oh, I forgot to answer your question
20:15:28 <Saizan> recursive descent parsers have their good sides :)
20:15:37 <SamB> nolrai_: by "IR", I meant "intermediate representation"
20:15:57 <SamB> nolrai_: essentially a language used internally by a compiler
20:16:02 <Saizan> but yeah, i wouldn't have to use them "manually"
20:16:04 * heatsink looks up NFA
20:16:35 <glguy> SamB: so you prefer Happy?
20:16:46 <clanehin> he means nondeterminism like the list monad
20:16:48 <SamB> glguy: I'm not sure
20:17:05 * glguy thinks he might mean determinism like the list monad
20:17:17 <clanehin> . . .
20:17:32 <heatsink> I see.
20:17:46 <SamB> clanehin: that *is* essentially the kind of nondeterminism that an NFA has
20:18:14 <clanehin> That's what I said.
20:18:23 <Saizan> for combinators with fair backtracking see ReadP or polyparse
20:18:55 <SamB> I notice that ReadP also has an unfair combinator
20:19:21 <glguy> not all parses are created equal :)
20:19:28 <SamB> yeah
20:22:44 <heatsink> What's involved in making such a parser run without consuming unnecessary time and memory?  I can see situations where input tokens are always held for backtracking and where too many valid parses are returned...
20:22:55 <Saizan> the strong point of parsec was the good error reporting, no?
20:23:40 <SamB> Saizan: that has always been my favorite thing about Parsec
20:24:08 <SamB> heatsink: well, my guess is that that is one reason for the unfair combinator in ReadP
20:24:16 <glguy> What is "deep cherry picking"? People seem to be talking about this like it is a known term
20:24:35 <SamB> heatsink: I suppose it might help to use a non-monadic API?
20:24:51 <glguy> heatsink: ReadP doesn't hold onto the token stream for backtracking
20:25:08 <glguy> heatsink: instead it parses on all branches in parallel, a kind of breadth first parse
20:25:44 <geezusfreeek> glguy: i actually had commented on an article about deep cherry picking just earlier today. perhaps that article is what you are referring to? (about darcs 2)
20:25:51 <SamB> could someone explain to me the point of the "C-a =" command in screen?
20:25:57 <geezusfreeek> i was also confused by the term
20:26:00 <glguy> geezusfreeek: are you kowey?
20:26:05 <geezusfreeek> no
20:26:12 <glguy> but you commented on that blog post?
20:26:24 * glguy scrolls down
20:26:24 <geezusfreeek> Jake McArthur
20:26:26 <glguy> finds the answer
20:27:16 * glguy wonders how that is different from git
20:27:28 <geezusfreeek> it was explained to me in response that basically it is in reference to the fact that patches in darcs are commutative
20:27:47 <geezusfreeek> not a huge point of distinction in my opinion, but oh well
20:27:57 <SamB> apparantly this can be either a help or a hinderance
20:28:30 <SamB> but at least in darcs 2 it seems to be *true*
20:28:37 <geezusfreeek> :)
20:28:50 <clanehin> I just assumed that it refers to the fact that you can casually cherry pick a patch from arbitrarily far back in a project's history, modulo dependencies.
20:29:16 <glguy> I assumed that it was more than that since that is a common capability for dvcs
20:29:17 <geezusfreeek> which is still no different from most other SCMs
20:29:20 <SamB> of course, why the heck you would be missing a patch from that far back ...
20:29:59 <glguy> Debian's popcont confirms it, darcs is dying
20:30:09 <glguy> if only netcraft was into version control...
20:30:13 <clanehin> Just stalling, atm.
20:30:38 <SamB> glguy: how do you know they aren't building darcs 2 and uninstalling the debian package because they no longer need it if they have their own darcs 2?
20:31:00 <glguy> debian people installing modern software?
20:31:01 <glguy> I think not
20:31:03 <glguy> ;)
20:31:08 <gwern> heh
20:31:15 <clanehin> That's exactly what's happened in my case, I've personally -2 darcs from popcon.
20:31:34 <SamB> I think I did it too
20:31:40 <gwern> (I kind of wish the darcs guys were more active. I get more replies and interaction from xmonad)
20:31:40 <SamB> I definately installed darcs-2
20:31:48 <gwern> clanehin: '-2 darcs from popcon'?
20:32:03 <bos> he, uh, had it cursed by a nymph on level 12.
20:32:19 <glguy> bos: doesn't hg do cherry-picking?
20:32:27 <clanehin> gwern: subtract two counts from darcs on popcon
20:32:30 <bos> glguy: sort of, like git.
20:32:34 <gwern> oh
20:32:34 <SamB> bos: where does one *find* darcs
20:32:41 <geezusfreeek> there are lots of definitions for cherry picking
20:32:59 <bos> SamB: you have to drink from a blessed fountain if you have a basilisk as a pet and a golden shield
20:33:00 <SamB> how good is git at permuting patches?
20:33:13 <glguy> it does it
20:33:17 <glguy> that doesn't come up much
20:33:26 <geezusfreeek> pretty darn well, in my opinion
20:33:39 <SamB> what identities does it satisfy?
20:33:53 <geezusfreeek> :P you're looking for an algebra that probably doesn't exist
20:34:04 <geezusfreeek> it's tested, not proven
20:34:24 <geezusfreeek> let's just say i have not run into many problems
20:34:25 <glguy> the darcs theory is nice in .pdf, but in practice it is great at not satisfying those identities
20:34:34 <glguy> and corrupting/destroying data
20:34:37 <gwern> geezusfreeek: has the testing proven the existence of any bugs? :)
20:34:45 <geezusfreeek> surely
20:34:59 <SamB> glguy: under what circumstances?
20:35:06 <SamB> mostly for me that happened with --partial
20:35:16 <geezusfreeek> the whole theory behind git if there is any is to just do the naive thing in most cases, but make everything reversible just in case the naive thing was wrong
20:35:19 <glguy> I never use partial, since they didn't work
20:35:33 <geezusfreeek> that's my interpretation anyway
20:35:40 <glguy> after losing 2 cumulative days of work repairing darcs repos
20:35:43 <SamB> glguy: yes, that's why I like darcs 2
20:35:45 <glguy> I gave up on it
20:35:51 <SamB> --hashed --lazy works!
20:36:10 <SamB> now if only there were more repositories to pull from
20:36:28 <glguy> the release notes said that it probably works and hasnt' been extensively tested
20:36:32 <geezusfreeek> i must admit i have not given darcs 2 a fair shot yet, but now that i have been using git for a while i am a hard customer to persuade
20:36:36 <glguy> and that darcs won't be maintained
20:36:40 <glguy> so...
20:37:11 <gwern> glguy: it's maintained, just in a different way
20:37:35 <gwern> (sheesh. we're going to be living down that ANN of roundy's for years to come, aren't we.)
20:37:43 <Cale> (It just said that David Roundy wouldn't be working on it full time.)
20:37:58 <SamB> why would he be working on it full time?
20:38:03 <SamB> he's a PHYSICIST
20:38:09 <Cale> exactly
20:38:18 <glguy> and that he wouldn't be listening to the mailing list
20:38:25 <glguy> or responding to bug reports (something to that effect)
20:38:32 <SamB> at all?
20:38:34 <gwern> glguy: yeah, that's actually really annoying. I keep having to CC him
20:38:43 <SamB> or just that it would be sporadic?
20:39:00 <glguy> SamB: considering the alternatives, I don't think it matters
20:39:24 <Cale> For the time being, he sounds like he just wants to apply patches.
20:39:52 <pantsd> is Category	Data
20:39:52 <pantsd> Home page	http://www.cse.unsw.edu.au/~dons/fps.html
20:39:52 <pantsd> Exposed modules	Data.ByteString, Data.ByteString.Char8, Data.ByteString.Unsafe, Data.ByteString.Internal, Data.ByteString.Lazy, Data.ByteString.Lazy.Char8, Data.ByteString.Lazy.Internal, Data.ByteString.Fusion
20:39:53 <lambdabot> Title: Data.ByteString
20:39:54 <SamB> hmm, he may lose maintainership
20:39:56 <pantsd> Upload date	Fri Jan 4 21:23:01 PST 2008
20:40:07 <gwern> Cale: he did criticize my patches to fix darcs's bytestring support, so he's still looking at the patches
20:40:21 <gwern> pantsd: ?
20:40:21 <Cale> That's good
20:40:27 <SamB> gwern: what was wrong with them?
20:41:35 <gwern> SamB: oh, I removed the old packedstring stuff, but it seems roundy doesn't have bytestring installed, so making darcs bytestring only didn't really work for him
20:41:49 <pantsd> Is -XOverloadedStrings supposed to make things that define IsString work as strings? i.e. if I have a bytestring and pass it to a function which expects string should it work? or do I misunderstand what -XOverloadedStrings is supposed to do?
20:42:08 <glguy> OverloadedStrings overload string *literals*
20:42:24 <glguy> "these things"    but not just any String value
20:42:59 <pantsd_> ah
20:43:00 <pantsd_> oks
20:44:09 <pantsd_> so if I had a function that expected type bytestring and I gave it "blargh" as an argument then it would work?
20:44:22 <Cale> Yeah, that's the idea.
20:44:30 <pantsd_> rocking
20:44:41 <Cale> "blargh" would initially have the polymorphic type (IsString s) => s
20:44:55 <Cale> and then the function you applied it to would specialise that
20:45:06 <Cale> *applied to it
20:47:02 <Cale> This, by the way, is the easiest Haskell extension to abuse, ever.
20:47:20 <bos> abuse?
20:47:51 <Cale> By writing funny instances of IsString :)
20:47:58 <pantsd_> hmms
20:48:08 <bos> i don't know, i enjoyed the binary digit versions of Num a few months ago.
20:48:26 <Cale> Say, like an IsString instance which interprets the string as a brainfuck program IO () value :)
20:48:46 <glguy> IsString (IO ()) lets you embed another language in string literals :)
20:49:04 <bos> boy, combine IsString and LLVM, and you're onto something.
20:49:11 <dolio> Huh, apparently 6.9 doesn't like my fancy type programming.
20:49:47 <glguy> You could have an IsString instance(s) to support multi line string literals: "asdf" "asdf" "jkll"  -> "asdfasdfjkll"
20:49:58 <glguy> (instead of the "string\     \gaps"
20:51:04 <bos> hmm, that one is tempting.
20:51:11 <SamB> dolio: what happens?
20:52:15 <dolio> SamB: http://hpaste.org/6907 in proj, "Occurs check: cannot construct the infinite type: t = Lookup (t ::: ts) fn"
20:53:28 <Cale> Heh, or merge the functionality of printf directly into string literals
20:53:52 <dolio> Apparently it isn't figuring out that FZ forces fn to be FZ, or something.
20:56:47 <dolio> It doesn't have a problem with the FS branch, apparently.
20:57:27 <SamB> how odd
20:57:35 <SamB> reported it yet?
20:57:42 <dolio> No.
20:59:08 <Saizan> i think there has been a -cafe post with a similar problem
20:59:27 <SamB> You probably should. Even if the code is wrong, the message should do better...
20:59:41 <dolio> Yeah, I don't know if I should be expecting it to work yet.
21:00:04 <dolio> It worked on 6.8, but I don't know how much checking it was actually doing.
21:02:06 <roconnor> @quote postfix
21:02:06 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
21:02:54 <roconnor> @quote calculator
21:02:54 <lambdabot> No quotes match.
21:03:05 <dolio> Most quotes have been blown away.
21:04:17 <SamB> who by ?
21:04:20 <SamB> why?
21:04:23 <SamB> @quote
21:04:23 <lambdabot> jfredett says: i would @remember that, but when someone @quotes olsner, it'd be nsfw on the normal channel... :/
21:04:35 <SamB> @quote C-a-l-e
21:04:35 <lambdabot> No quotes match. Where did you learn to type?
21:04:39 <SamB> aww
21:04:42 <OceanSpray> @quote SamB
21:04:42 <lambdabot> No quotes match. Take a stress pill and think things over.
21:04:49 <SamB> @quote
21:04:49 <lambdabot> <shapr> says: GHC has more flags than the UN.
21:04:52 <SamB> @quote
21:04:52 <lambdabot> JohnMeacham says:  Is it ironic I had to look up and read a tutorial on the haskell regular expression syntax I invented?
21:04:58 <SamB> @quote
21:04:58 <lambdabot> <shapr> says: GHC has more flags than the UN.
21:04:59 <dolio> I don't know. But as of a few days ago, there were only like 4 quotes in the database.
21:05:00 <araujo> hahaha
21:05:05 <SamB> @quote
21:05:05 <lambdabot> JohnMeacham says:  Is it ironic I had to look up and read a tutorial on the haskell regular expression syntax I invented?
21:05:08 <SamB> @quote
21:05:08 <lambdabot> jfredett says: i would @remember that, but when someone @quotes olsner, it'd be nsfw on the normal channel... :/
21:05:13 <SamB> @quote
21:05:13 <lambdabot> JohnMeacham says:  Is it ironic I had to look up and read a tutorial on the haskell regular expression syntax I invented?
21:05:14 <ivanm> heh, the JohnMeacham one is good
21:05:18 <shapr> Where'd all the quotes go?
21:05:25 <dolio> @quote rational
21:05:25 <lambdabot> Cale says: "Betta watch your back when I'm packin' a nine/I'll pump you fulla holes like the rational line"
21:05:31 <SamB> Cale: well?
21:05:33 <dolio> @quote lambdabot
21:05:33 <lambdabot> lambdabot says: Exception: I'm a moron
21:06:09 <SamB> @remember lambdabot lambdabot hasn't said anything memorable
21:06:09 <lambdabot> It is stored.
21:06:52 <SamB> @quote olsner
21:06:52 <lambdabot> jfredett says: i would @remember that, but when someone @quotes olsner, it'd be nsfw on the normal channel... :/
21:06:54 <SamB> @quote olsner
21:06:54 <lambdabot> jfredett says: i would @remember that, but when someone @quotes olsner, it'd be nsfw on the normal channel... :/
21:06:57 <SamB> @quote Cale
21:06:57 <lambdabot> Cale says: "Betta watch your back when I'm packin' a nine/I'll pump you fulla holes like the rational line"
21:07:04 <SamB> @quote stupid
21:07:04 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
21:07:09 <SamB> @quote fun
21:07:09 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
21:07:15 <ivanm> @quote quote
21:07:15 <lambdabot> jfredett says: i would @remember that, but when someone @quotes olsner, it'd be nsfw on the normal channel... :/
21:07:36 <ivanm> @quote olsner
21:07:36 <lambdabot> jfredett says: i would @remember that, but when someone @quotes olsner, it'd be nsfw on the normal channel... :/
21:07:39 <SamB> @remember dolio I don't know. But as of a few days ago, there were only like 4 quotes in the database.
21:07:39 <lambdabot> Good to know.
21:08:04 <shachaf> @seen Cale
21:08:04 <lambdabot> Cale is in #haskell-overflow, #haskell-blah, #ghc and #haskell. I last heard Cale speak 14m 36s ago.
21:09:43 <dolio> Saizan: Any idea what subject I might look for for that thread you mentioned.
21:12:10 <roconnor> @quote stack-calculator
21:12:10 <lambdabot> No quotes match. It can only be attributed to human error.
21:12:18 <Saizan> dolio: Equality constraints in type families was the one i remembered
21:12:27 <roconnor> @remember stack-calculator let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 add end
21:12:27 <lambdabot> It is stored.
21:12:39 <dolio> Oh, that's a big one. :)
21:12:39 <roconnor> let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 add end
21:12:50 <roconnor> > let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 add end
21:12:51 <lambdabot>  5
21:13:04 <roconnor> ^^ is that essetially Forth.
21:13:08 <roconnor> but type safe.
21:13:13 <roconnor> ?
21:13:15 <ddarius> roconnor: No
21:13:25 <roconnor> how is forth different?
21:13:53 <aFlag> Hm, I don't know if people working with haskell ever feels this way, but someone may find this entertaining (maybe most already know about it): http://www.catonmat.net/blog/musical-geek-friday-code-monkey/
21:15:12 <ddarius> roconnor: Being low-level is a large part of Forth.  That example can't handle some things even the simple data stack sublanguage of Forth can do.  There's a lot more to Forth programming than stack programming, e.g. parsing words.
21:15:35 <gwern> 'My motivation in working on darcs has changed quite a bit as it's become more popular. I never would have guessed how much time I'd end up spending on email, but I've found that helping people use darcs is very satisfying. Darcs feels a lot more like work now than it used to, and at times it starts feeling old, but then I get an email from someone who's just discovered darcs, and it's all worthwhile.
21:15:35 <gwern> 2004
21:15:50 <ivanm> aFlag: well, if used haskell then his code would be more likely to be "functional" than what it currently is :p
21:16:14 <aFlag> :P
21:17:07 <aFlag> it's a fun little song, there are so many code monkeys out there :(
21:17:23 <ivanm> yeah
21:18:46 <gwern> 'In the longer term, I'd like to see some interesting new primitive patch types, which should allow better merge behavior by better expressing the intention of the user. The simple line-based patching patching works pretty well for source code, but for other sorts of files, you'd rather use a different scheme. For example, there is a PhD student in Germany who has been working on diffing algorithms for XML documents, who has been working on ...
21:18:52 <gwern> ... implementing his algorithms in darcs. This was originally one of the things about darcs that interested me most, but for about a year I've been distracted by working to stabilize darcs and improve its interface.'
21:18:56 <gwern> whatever happened to that?
21:19:35 <ddarius> gwern: The guy got his PhD probably.
21:19:58 <roconnor> gwern: I ponder a patch format for Epigram sometimes
21:20:00 <gwern> ddarius: I wish I could lol at that, but that's too often the story in haskell-land
21:20:39 <gwern> roconnor: how would that work?
21:21:11 <roconnor> I have no idea, but I'm sure it would be totally awesome.
21:22:38 <gwern> hm. if I have something compiled -prof -auto-all, what are good RTS flags to find out what functions are eating up time?
21:22:42 <ddarius> Presumably it would use tree-based edits rather than line-based ones and preferably would respect/take advantage of a schema
21:23:32 <gwern> ddarius: epigram have some sort of tree syntax?
21:23:49 <ddarius> gwern: Oh, I misorganized lines.
21:23:54 <gwern> +RTS -p -RTS seems to be good
21:24:10 <ddarius> gwern: Yeah, the "default" mode should be what you want (to start)(
21:25:03 <gwern> holy cow. darcs pull wastes 25% of its time in SHA256, 25% in unpackPS, and another 25% in findPS
21:26:15 <roconnor> gwern: epigram functions are defined by a decision tree more or less
21:26:26 <roconnor> not that I've ever written an epigram program mind you.
21:26:50 <SamB> gwern: indeed, epigram's syntax is not really textual
21:26:52 <roconnor> gwern: is that my SHA256?
21:27:07 <SamB> that text is just ASCII-art
21:27:13 <SamB> that can be parsed back into trees
21:27:38 <ddarius> SamB: It's still textual.
21:27:44 <ddarius> Maybe "linear" is a better word.
21:27:50 <gwern> roconnor: I think so, since darcs is still self-contained
21:28:02 <roconnor> It would be cool for a langauge to be designed, not as string to be parse, but as a set of patches to be applied.
21:28:20 <roconnor> gwern: not mine then,  Mine is in the crypto library
21:28:41 <aFlag> What concerns me more on darcs is how long it takes to do a darcs diff if you have a very big project
21:28:50 <hpaste>  morrow annotated "zipsL" with "todos" at http://hpaste.org/6939#a1
21:29:02 <roconnor> gwern: maybe it would be faster if mine was used :P.  Probably not.  I refuse to make my code ugly just because GHC refuses to optimise my code.
21:29:30 <roconnor> perhaps I should add rewrite rules.
21:29:32 <ddarius> Tell GHC how to optimize your code and have the best of both worlds.
21:29:32 <hpaste>  gwern pasted "darcs profiling" at http://hpaste.org/6940
21:29:58 <gwern> roconnor: it's an old SHA256, so I'd hope yours is faster
21:30:39 <gwern> on the other hand, it goes through a FFI binding to 'sha256'
21:30:43 <roconnor> mine is nothing special.  the crypto lib was in need of it, and after fixing up SHA1 I figured I'd add the SHA2's
21:30:47 <gwern> so maybe it's actually as fast as is reasonable
21:31:56 <roconnor> heh, my sha works on lists.  Which means it can sometimes work in constant space.
21:32:44 <Saizan> FastPackedString is actually implemented with bytestring or what?
21:33:27 <gwern> ouch. 11% of time going just to unpacking bytestrings
21:33:55 <gwern> Saizan: depends. it can be either ByteString, or the old packedstring stuff which dons forked from darcs 3 years ago and turned into ByteString
21:34:18 <gwern> darcs right now defaults to the old, but I'm running with ByteString'd darcs
21:34:27 <jberryman> 'night all, thanks for the bits of help today
21:37:04 <Saizan> mmh, so the easy "switch to bytestring" optimization won't work :)
21:37:11 <gwern> Saizan: nope
21:37:31 <gwern> I almost wonder if all string wouldn't be better, since then you wouldn't lose time to packing and unpacking
21:37:46 <Saizan> i wonder why they are unpacked though
21:38:35 <gwern> well, it's a 'darcs get', so at the very least you'd need to pack them as they downloaded, and then unpack them to write to disk
21:39:21 <SamB> gwern: eh, wouldn't it make more sense to read them packed to begin with?
21:39:51 <gwern> SamB: I'm not sure. can ByteStrings be sent over the network without being unpacked and then repacked?
21:40:04 <Saizan> gwern: yeah.
21:40:26 <Saizan> ?hoogle hPut
21:40:27 <lambdabot> Data.ByteString.hPut :: Handle -> ByteString -> IO ()
21:40:27 <lambdabot> Data.ByteString.Char8.hPut :: Handle -> ByteString -> IO ()
21:40:27 <lambdabot> Data.ByteString.Lazy.hPut :: Handle -> ByteString -> IO ()
21:40:32 <Saizan> ?hoogle hGet
21:40:32 <lambdabot> Data.ByteString.hGet :: Handle -> Int -> IO ByteString
21:40:32 <lambdabot> Data.ByteString.Char8.hGet :: Handle -> Int -> IO ByteString
21:40:32 <lambdabot> Data.ByteString.Lazy.hGet :: Handle -> Int -> IO ByteString
21:40:45 <gwern> Saizan: but where would the ByteString come from, in Darcs? when you 'get' a repo, you're just downloading some files, there is no darcs server on the other end making bytestrings for you, afaik
21:41:28 <Saizan> gwern: ByteStrings are just Word8 arrays, nothing magical, you can get them from a socket
21:41:31 <gwern> (the apache server on the other end is just sending your normal TCP packets with strings, no?)
21:42:06 <Saizan> i'd say TCP packets are more like a ByteString than [Char] ..
21:43:11 <Saizan> haskell's Strings are quite unusual since Char is supposed to represent all unicode
21:45:45 <hpaste>  morrow annotated "zipsL" with "better" at http://hpaste.org/6939#a2
21:49:05 <gwern> huh. so doing a quick darcs whatsnew results in unpackPS eating 38% of memory
21:49:11 <gwern> man, unpack sucks!
21:52:08 <hpaste>  morrow annotated "zipsL" with "(no title)" at http://hpaste.org/6939#a3
21:55:50 <Saizan> well, unpack inevitably has to build a lot of cons cells..
22:01:35 <gwern> @quote oleg
22:01:35 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
22:01:48 <gwern> Saizan: but it keeps on showing up, no matter what operations I try
22:02:44 <gwern> I wonder why epigram is not cabalized?
22:03:11 <gwern> it kind of saddens me how both epigram and agda try to pretend they aren't haskell programs, and avoid hackage/cabal/haskell-cafe like the plague
22:05:15 <araujo> it's futile , they will be assimilated
22:05:26 <orzo> when I profile my code, it always says 0.0% time for all cost centers
22:05:56 <orzo> am i doing it wrong?
22:06:37 <gwern> orzo: maybe. or maybe it's running too fast
22:07:01 <gwern> kind of like how 'time' gets less accurate for programs under .5 seconds or so, y'know?
22:07:24 <ivanm> yes, isn't it amazing how no-op programs take time? :p
22:10:40 <orzo> ok, guess it was too fast
22:10:59 <orzo> i made it repeat 100 times and now it has time values
22:13:45 <orzo> hm
22:13:56 <orzo> inherited time and alloc is greater than individual time and alloc
22:14:01 <orzo> that is not what I expected
22:37:10 <dolio> Both agda and epigram are cabalized.
22:37:53 <Staz> Hi there! I would really appreciate it if someone could explain to me how on earth the following works :
22:38:00 <Staz> remainder‚Äô = fix (\f a b -> if a < b then a else f (a-b) b)
22:38:01 <dolio> Epigram doesn't have a version that works, currently, unless you go way back to epigram 1.
22:38:08 <Staz> fix f = f (fix f)
22:39:23 <Staz> I have a basic understanding of lamda expressions and understand the 'a b' part of it.
22:39:24 <Heffalump> staz: by recursion
22:39:33 <Staz> but where does 'f' come from.
22:39:49 <Heffalump> do you understand how remainder' a b = if a < b then a else remainder' (a-b) b ?
22:39:50 <solrize_> @seen shapr
22:39:50 <lambdabot> I saw shapr leaving #haskell-blah, #scannedinavian and #haskell 1h 21m 40s ago, and .
22:40:06 <Staz> Heffalump : yep that's easy.
22:40:18 <Heffalump> staz: ok, so the program with fix is just an abstracted version of it
22:40:31 <Staz> this is where I get confused big time :)
22:40:49 <Heffalump> going baout it in small steps, the first one would be remainder' = \a b -> if a < b then a else remainder' (a-b) b ; are you happy with that?
22:41:12 <Staz> yep I am
22:41:32 <Heffalump> ok, now when you say where does 'f' come from, do you mean in the definition of remainder' or the definition of fix?
22:41:46 <Staz> in remainder definition.
22:42:10 <Heffalump> ok, well are you unhappy with where remainder' comes from in the body of my last definition of remainder'?
22:42:34 <Staz> no
22:43:37 <Heffalump> ok, let's look at the definition of fix. Another way of writing it would be fix = \g -> g (fix g) -- I've renamed f to avoid confusion a bit later. Is that ok?
22:43:48 <Staz> remainder‚Äô = fix (\f a b -> if a < b then a else f (a-b) b) <-- I call remainder with two arguments yet this lamda expression seems to take three.
22:43:53 <Staz> That is where I am confused.
22:44:02 <Heffalump> ok, but fix consumes one of them
22:44:17 <Heffalump> look at how the parameter to fix is applied
22:44:23 <Heffalump> it gets given an argument
22:44:41 <Heffalump> the type of fix is (a -> a) -> a -> a
22:44:57 <Heffalump> sorry, (a -> a) -> a
22:45:36 <Heffalump> i.e. it takes in something that takes 1 argument and returns something that takes 0, or more generally allowing for currying as in this case, it takes in something that takes (n+1) arguments and returns something that takes n arguments.
22:46:27 <Staz> I'm going to have to read over this a few times :)
22:47:23 <Heffalump> ok. Another line of understanding is to follow my other definitoin of fix = \g -> g (fix g), substitute that into the body of remainder' and then just apply it to see how it expands out and what f becomes.
22:47:43 <Staz> I will do that! Thanks very much Heffalump.
22:47:50 <Staz> I
22:48:46 <Heffalump> (by substitute into I mean beta-reduction, if you're familiar with that; the act of turning an application (\x -> b) a into the result (b with x replaced by a).
23:16:55 <Lemon> what's the 'deriving' declaration used for?
23:17:18 <sjanssen> Lemon: automatically writing instances for standard classes
23:17:32 <Lemon> automatically?
23:17:33 <Lemon> how?
23:18:06 <sjanssen> the compiler generates them -- according to some rules defined in the language spec.
23:20:50 <geezusfreeek> it only works for certain type classes and for certain forms of data structures, so it's not magic or anything
23:21:20 <geezusfreeek> (but it feels like it sometimes)
23:59:52 <ski> Cale : i'm not convinced having at most one (standard) state type per monad is right ..
