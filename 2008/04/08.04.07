00:00:01 <cjs> Basically, I am recording a stream of messages, and I later want to play them back with the same timing. Anybody got a good idea of how to approach this?
00:00:16 <olsner> hmm... (2^32) picoseconds = 0.0042949673 seconds?
00:00:41 <jeffz> cjs, number them?
00:01:33 <olsner> just make sure to use types with proper precision in all time calculations, I guess
00:02:02 <cjs> Numbering them is not hard, but how to I tell how long to wait after sending the first message before sending the second?
00:02:14 <cjs> How do I figure out how much time was between the two when recording?
00:02:35 <jsnx> cjs: can you explain why this is difficult?
00:02:49 <cjs> Because I'm a poor Haskell programmer. :-)
00:02:58 <jsnx> cjs: oic
00:03:08 <jsnx> cjs: you are wondering, what programming constructs to use
00:03:24 <jsnx> cjs: as opposed to, how to solve this problem in principle
00:03:40 <cjs> Yes. Is getCurrentTime my only option for getting a timestamp, for example.
00:04:04 <jsnx> cjs: well, if you had another option, how would it be different?
00:04:18 <cjs> It might not go backwards?
00:04:34 <jsnx> oic
00:04:57 <jsnx> we must have some kind of "getClockTime" or something like that
00:05:07 <jsnx> Epoch seconds do not go backwards
00:05:12 <jsnx> oh, wait
00:05:16 <jsnx> that's a UNIX-ism
00:06:02 <roconnor> how does a timestamp move backwards?
00:06:21 <jsnx> roconnor: UTC gets set back every now and again
00:06:31 <jsnx> roconnor: by law
00:06:43 <olsner> you can always change your clock while the program is running
00:07:18 <cjs> I can live with a unixism.
00:07:20 <roconnor> then you had better get a timestamp unique-id pair
00:07:44 <cjs> But actually, they do go backwards, if you (or your NTP daemon) changes the clock while the system is running.
00:07:48 <bparkis> is there a "most expressive" typed lambda calculus?
00:07:54 <roconnor> ugh, and locks
00:09:45 <cjs> You know, I think maybe it's easiest if I use System.Time's getClockTime and timeDiff, and just use the diff between the timestamp on the previous and current messages received. I'll get a zero time diff should the clock be set back, but that's livable. And I'm just sorta stuck with the delay if the clock is moved forward.
00:09:52 <olsner> and in general, not all timers are guaranteed monotonous... unfortunately, I don't remember all the reasons, I just read an article that I deemed trustworthy and now treat its conclusions as fact
00:10:25 <cjs> Actually, they're all quite monotonous, just not monotonic. :-)
00:10:47 <idnar> heehee
00:11:08 <sclv> http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Time.html
00:11:08 <olsner> read what I mean, not what I write :P
00:11:09 <lambdabot> http://tinyurl.com/6lqyvb
00:11:27 <jsnx> olsner: perl programmer, are we?
00:14:33 <olsner> @quote olsner.*perl
00:14:33 <lambdabot> No quotes match. Just try something else.
00:14:38 <olsner> @quote perl
00:14:38 <lambdabot> qwe1234 says: it's 2006 already, and the world doesn't need 'dynamic languages'. otherwise, we'd be all programming in perl.
00:14:40 <olsner> @quote perl
00:14:40 <lambdabot> ghc says: GHCi's bytecode generation machinery can't handle 64-bit code properly yet.
00:15:01 <olsner> well, anyway, there is some quote about me disliking perl
00:15:13 <jsnx> olsner: okay, i take it back
00:15:19 <olsner> thanks ;-)
00:17:21 <Pseudonym> @quote olsner
00:17:22 <lambdabot> olsner says: shapr: 2eyb6ard 0a5ntenance
00:17:26 <Pseudonym> @quote olsner
00:17:26 <lambdabot> olsner says: a mind won't be enough, you need a comind to go with it
00:17:36 <cjs> Hm. So is there no way to get a DiffTime that's the difference between two UTCTimes? Just a NominalDiffTime?
00:17:45 <Pseudonym> @quote olsner perl
00:17:45 <lambdabot> olsner says: hmm, so perl basically has all harmful features ever invented?
00:18:08 <Pseudonym> Yes, including a fixpoint operator.
00:18:18 <jsnx> olsner: that's a quotable quote
00:18:30 <olsner> ah, keyboard maintenance, I remember that one
00:19:00 <cjs> Not that a NominalDiffTime won't do ok, anyway; who knows if we'll even ever have another leap second.
00:19:31 <olsner> jsnx: what do you get when you quote a quote?
00:19:52 <jsnx> quote * quote -> quote
00:20:00 <jsnx> fixed point, i think
00:20:01 <cjs> But how does one convert, say, a nominalDiffTime to a Word64, or something similarly compact for storage?
00:20:26 <olsner> quote :: a -> Quoted a
00:22:01 <takamu> hi
00:22:01 <olsner> you'd get Quoted (Quoted olsner) ... so you should probably use (join . quote) instead of simply quote when requoting
00:23:48 <jsnx> cjs: i don't know
00:23:57 <jsnx> cjs: you have to convert it to a number first
00:24:05 <jsnx> cjs: and then to a Word64
00:24:11 <jsnx> something like that
00:25:39 <jsnx> i think Storable must have something to do with it:
00:25:40 <jsnx> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Storable.html
00:25:41 <lambdabot> http://tinyurl.com/5s9kld
00:26:39 <scook0> don't confuse quote :: a -> Quote a with quote :: Quote a -> Speech a
00:27:02 <cjs> I think that Storable is only for the "C" data types.
00:27:51 <jsnx> cjs: well, Word and Int and Double are in it
00:28:06 <jsnx> cjs: but yeah, it seems to have mostly to do with pointers
00:29:46 <jsnx> you know, i honestly can not find a Data.Serializable ...
00:29:54 <jsnx> it's gotta be here somewhere...
00:30:33 <cjs> Well, there's Data.Binary, if I want to do my own format. But I don't really need much of a framework for this.
00:30:45 <cjs> I need to understand the Numeric Tower, or whatever haskellers call it.
00:35:27 <jsnx> putting ascending strings into a Trie is really quite tough
00:36:04 <jsnx> devilish, even
00:37:14 <dancor> i want to make ffi wrapper for tcgetattr, but i don't understand how to marshal the termios struct
00:37:43 <dancor> i have to make a haskell version and make it Storable?
00:38:13 <Peaker> @hoogle Word8 -> Int
00:38:13 <lambdabot> Data.ByteString.count :: Word8 -> ByteString -> Int
00:38:24 <Peaker> @hoogle Num a => Word8 -> a
00:38:24 <lambdabot> No matches, try a more general search
00:38:38 <Peaker> @type fromIntegral
00:38:41 <lambdabot> forall a b. (Num b, Integral a) => a -> b
00:39:07 <Peaker> ((fromIntegral someWord8)::Int)  doesn't seem to work...
00:39:12 <dancor> i don't actually need to modify the struct at all in haskell
00:39:22 <jsnx> okay, to be fair, i'm forcing myself to have complete pattern matches
00:39:30 <cjs> Data.ByteString is looking hopeful. Come to think of it, I probably want to be using that for the messages as well....
00:39:40 <jsnx> but still, it's much harder that i thought
00:40:00 <jsnx> cjs: how will you go from NominalDiffTime to bytes?
00:40:59 <Peaker> @hoogle -> Word8
00:40:59 <lambdabot> hoogle: unrecognized option `->'
00:40:59 <lambdabot> unrecognized option `- '
00:40:59 <lambdabot> unrecognized option `-W'
00:40:59 <lambdabot> unrecognized option `-o'
00:40:59 <lambdabot> unrecognized option `-r'
00:41:01 <lambdabot> [21 @more lines]
00:41:02 <cjs> It's an instance of Num, so I can convert it to a Word64.
00:41:43 <dancor> @hoogle ->
00:41:44 <lambdabot> No matches found
00:42:21 <cjs> Somehow. Not quite sure how yet....
00:46:58 <cjs> Or worst comes to worst, I just use System.Time, which will get me what I need.
00:47:28 <Peaker> cjs:  fromIntegral yourval::Integer and then fromInteger x::Word64?
00:47:48 <dancor> looks like this is what i need: http://therning.org/magnus/archives/315
00:51:06 <Peaker> dancor, that seems like a Storeable cannot be used to access a single field of a large struct, you must copy it all?
00:52:07 <dancor> Peaker: it looks like you can use peek to get the haskell-side struct
00:52:22 <dancor> maybe?
00:52:55 <dancor> i think you can access the elements in haskell
00:53:01 <Peaker> dancor, you can use peek, but the Storeable interface only lets you read/write the whole thing?
00:53:24 <jsnx> Peaker: only the whole thing that is pointed at
00:53:25 <dancor> Peaker: yeah, you can only marshal an entire struct
00:53:45 <jsnx> oh, hum
00:53:48 <dancor> but you could like take an element and then marshal that
00:53:55 <dancor> back
00:54:15 <Peaker> if you can convert a Ptr(Bar) to a Ptr(FieldOfBar) easily, then yeah
01:09:26 <cjs> Is there something to convert between ByteStrings and Strings?
01:10:21 <Deewiant> @hoogle pack
01:10:22 <lambdabot> Data.ByteString.pack :: [Word8] -> ByteString
01:10:22 <lambdabot> Data.ByteString.Char8.pack :: String -> ByteString
01:10:22 <lambdabot> Data.ByteString.Lazy.pack :: [Word8] -> ByteString
01:10:24 <Deewiant> @hoogle unpack
01:10:25 <lambdabot> Data.ByteString.unpack :: ByteString -> [Word8]
01:10:25 <lambdabot> Data.ByteString.Char8.unpack :: ByteString -> [Char]
01:10:25 <lambdabot> Data.ByteString.Lazy.unpack :: ByteString -> [Word8]
01:11:02 <cjs> Ah, in Char8. I'm always forgetting to look in sub-packages.
01:13:44 <haskbob> just wandering why are there so few open source project in haskell
01:13:59 <haskbob> well any projects for that matter
01:14:29 <cjs> Managers don't understand it.
01:14:56 <skorpan> people haven't really read whyfp.pdf, that's why
01:15:34 <haskbob> i havn't read it :)
01:15:59 <skorpan> i must admit that i haven't read the whole thing :/
01:16:06 <skorpan> but i like telling people they should
01:16:44 <haskbob> is haskell the most popular fp lang
01:17:14 <Botje> it's the most popular _PURE_ fp lang :)
01:18:02 <haskbob> what are some non pure?
01:18:10 <cjs> Most.
01:18:10 <skorpan> erlang is impure
01:18:24 <haskbob> doesn't seem that popular
01:18:34 <skorpan> erlang is pretty popular
01:18:38 <skorpan> ericsson still use it
01:18:43 <skorpan> if that makes it "popular".
01:18:59 <haskbob> yeah well they built there whole infrastructure in it
01:19:02 <skorpan> haskbob: http://www.youtube.com/watch?v=uKfKtXYLG78
01:19:19 <skorpan> i actually like erlang a lot
01:19:39 <haskbob> well erlang has crap lib support
01:20:10 <Beelsebob> which is fair enough really seeing as it's primary purpose was to control telephone exchanges
01:20:32 <skorpan> erlang does have crap lib support, that's true, but it doesn't make the languager less nice
01:21:24 <haskbob> ok laters
01:21:25 <Beelsebob> haskbob: there are only a few projects in Haskell?
01:21:39 <haskbob> yes very few
01:21:40 <Beelsebob> I've seen far more in Haskell than in any other non-C-like language
01:21:51 <Beelsebob> well, maybe Python
01:21:53 <haskbob> even python?
01:21:58 <haskbob> or ruby?
01:22:09 <Beelsebob> no, never seen ruby ones
01:22:17 <skorpan> wow, what a debater
01:22:21 <Beelsebob> idd
01:22:59 <skorpan> 1. why are there so few open source projects in haskell? 2. repeat (oh that's crap) 3. quit
01:24:05 <Beelsebob> tbh, the answer is "because there are so few Haskell programmers"
01:24:20 <Beelsebob> which raises another question... but that's not the one he asked
01:24:41 <cjs> Can one mix ByteString I/O and "normal" I/O?
01:25:00 <Beelsebob> cjs: define "mix"
01:25:11 <Beelsebob> use the two in the same program?
01:25:17 <Beelsebob> use the two to access the same file?
01:25:19 <Beelsebob> at the same time?
01:25:30 <cjs> intersperse calls to the two reading from a network socket.
01:25:49 <cjs> E.g., a couple of hGetChars followed by an hGet.
01:26:20 <Beelsebob> I don't see why not
01:26:29 <Beelsebob> although there may be some unexected oddities
01:26:36 <Beelsebob> e.g. their definitions of newlines may be different
01:26:46 <Beelsebob> not certain on that one though
01:27:24 <cjs> Me neither, but for some odd reason my program and its test framework is getting into a weird deadlock of some sort; it's no longer reading responses.
01:28:23 <Beelsebob> I think that's one to poke dons with
01:29:27 <cjs> Weird thing is that Debug.Trace's trace function isn't working for me, either.
01:29:34 * Beelsebob should put some clothes on before landlord appears with potential tennants
01:29:54 <Beelsebob> cjs: suggests something is locking stdout
01:29:56 <Beelsebob> o.O
01:30:44 <Beelsebob> because I *think* Debug.Trace is just a synonym for (\x y -> seq (unsafePerformIO $ putStr x) y)
01:31:06 <Deewiant> @src trace
01:31:07 <lambdabot> trace string expr = unsafePerformIO $ do
01:31:07 <lambdabot>     hPutStrLn stderr string
01:31:07 <lambdabot>     return expr
01:31:17 <Beelsebob> ah, not quite
01:31:19 <Beelsebob> but close
01:31:29 <cjs> Ah, putTraceMsg works. Duh. I was doing "let x = trace "foo"" and then never evaluating x.
01:31:34 <Beelsebob> ah, and it's stderr
01:31:41 <Beelsebob> lol
01:33:30 <cjs> Oh, idiot. I went and tried to read two more bytes than were available.
01:39:39 <dibblego> is there a library for reading ID3 tags of mp3 files?
01:40:48 <earthy> hmp3 will have something to do that
01:41:19 <earthy> or maybe not
01:56:27 <cjs> It wouldn't be terribly hard to write, anyway.
01:57:02 <Beelsebob> I suspect it would be hard to write something that handled a lot of malformed tags
01:57:30 <Beelsebob> looking at the way different players handle things, I suspect it's almost as hard a problem as reliably rendering html
02:03:35 <atsampson> it's probably best to write bindings for taglib, or similar
02:10:08 * Beelsebob ponders writing an automagical binding generator
02:10:20 <Beelsebob> to map any C library into Haskell
02:10:34 <araujo> c2hs?
02:11:10 <Beelsebob> thing is... it doesn't work usually
02:11:48 <araujo> but that's what you mean right?
02:11:54 <Beelsebob> something like that yes
02:11:54 <araujo> probably an improved version?
02:12:05 <Beelsebob> something that is somewhat more reliable
02:12:07 <araujo> I guess it can be definitely improved :-]
02:12:44 * gour has problems with c2hs as well
02:12:45 <lambdabot> gour: You have 1 new message. '/msg lambdabot @messages' to read it.
02:12:50 <Beelsebob> well, the evidence is that people tend to say "write some bindings" rather than "I'm sure C2Hs will give you bindings easily enough"
02:12:57 <araujo> hah
02:13:09 <araujo> I know what you mean :-]
02:13:23 <gour> mostly docs :-/
02:13:58 <gour> araujo: can you explain to me one sentence from c2hs tutorial?
02:17:14 <araujo> gour, I have not used c2hs too much , but throw it in here :-)
02:18:54 <Botje> perhaps we need to look into a haskell backend for SWIG
02:27:21 <hpaste>  morrow pasted "hGetNoEcho" at http://hpaste.org/6885
02:33:05 <hpaste>  morrow annotated "hGetNoEcho" with "fixed" at http://hpaste.org/6885#a1
02:36:39 <hpaste>  beelsebob annotated "hGetNoEcho" with "Why not use do?  It looks much clearer" at http://hpaste.org/6885#a2
02:42:03 <jacobian> are functional language contexts derivatives of a the term type of the language?
02:42:07 <hpaste>  beelsebob annotated "hGetNoEcho" with "In fact, why is that continuation there?  If we're working in monads, lets be consistant" at http://hpaste.org/6885#a3
02:43:22 <hpaste>  (anonymous) annotated "hGetNoEcho" with "And actually use your own code ;)" at http://hpaste.org/6885#a4
02:48:35 <hpaste>  morrow annotated "hGetNoEcho" with "yeah true..." at http://hpaste.org/6885#a5
03:23:08 <cjs> Hm. Can anybody help me with a little bit of functional organization?
03:23:53 <cjs> I've got a thread that reads messages from the net and writes them out to a file. It has a...oh...hmmm...never mind.
03:26:32 <Igloo> Glad to be of help!
03:26:48 <cjs> Closures. Closures are my friend.
03:30:49 <sjanssen> now we're all curious
03:31:55 <Beelsebob> cjs has come up with the ultimate way to get help
03:32:05 <cjs> Heh.
03:32:05 <fons> hi all
03:32:07 <Beelsebob> don't quite fully eqplain the question, then say you've fixed it
03:32:46 <cjs> I don't know if I have. But I've got a message reading thread, and a list of functions that take messages and do stuff (i.e., pulling out info I need for future requests, logging the messages, etc.)
03:33:10 <cjs> But these now need to keep state, e.g., the counter, the time of the previous message, etc.
03:33:21 <fons> question: I might be wrong, but if you use StateT monads in the same stack, there is no way to access the inner StateT?
03:33:36 <sjanssen> fons: there is a way, but it is painful
03:33:40 <sjanssen> @type get
03:33:48 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
03:33:53 <sjanssen> @type lift get
03:33:54 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, MonadState a m) => t m a
03:34:02 <sjanssen> @type lift . lift $ get
03:34:03 <lambdabot> forall (t :: (* -> *) -> * -> *) (m :: * -> *) a (t1 :: (* -> *) -> * -> *). (MonadState a m, MonadTrans t1, Monad (t1 m), MonadTrans t) => t (t1 m) a
03:34:17 <sjanssen> fons: do you see where this is going?
03:34:28 <fons> uhm, yep
03:34:32 <cjs> So I could just zip up the functions and states, and make a new zip of what's returned (though also actions are returned, which makes it a bit tricky--return an (IO, StateThingie) pair?)
03:34:45 <cjs> Or maybe I just return the next function to call.
03:35:13 <fons> sjanssen: my problem is that I have some code which needs some "extra" state, which is only related to that code
03:35:36 <sjanssen> cjs: are all the functions stateful?  Do they all use the same type of state?
03:35:38 <fons> sjanssen: my solution right now is simply to put everything in a global state
03:35:57 <cjs> They are not all stateful, just some. Those that are use different bits of state, generally related only to themselves.
03:36:14 <fons> sjanssen: but it's not really clean since the "extra" state I'm talking about only makes sense in some parts of the code
03:36:29 <cjs> In an OO system, I'd just create instances of various ResponseProcessors (or whatever) with a common interface.
03:36:37 <sjanssen> cjs: so a list isn't possible anyway, because the contents would be different at each index?
03:36:51 <sjanssen> the type of the contents
03:37:23 <cjs> Hmmm...there is that point. The ResponseProcessors are all the same, but the state is not.
03:37:32 <sjanssen> fons: so one solution is to manually 'lift' to the right StateT
03:37:50 <cjs> Thus, return closures?
03:38:31 <fons> sjanssen: thanks
03:38:41 <sjanssen> fons: another would be to use an extensible type as your state, say (ConstantState, ExtraState) sometimes, and (ConstantState, ()) other times
03:39:04 <cjs> Given that I need also return actions, it gets ugly....
03:39:31 <dancor> does cabal do hsc
03:39:38 <sjanssen> dancor: yeah
03:40:04 <dancor> i can't find example on net, is there a package that is a good example
03:40:23 <sjanssen> dancor: the X11 package has several .hsc files
03:40:28 <hpaste>  cjs pasted "response processors" at http://hpaste.org/6886
03:49:21 <cjs> Aw!
03:49:41 <cjs> "type ResponseProcessor = (GLConnection, Response) -> (IO (), ResponseProcessor)" gives me "Cycle in type synonym declarations."
03:50:22 <cjs> That has to be a data?
03:50:25 <Botje> yes, since the compiler tries to rewrite all references to ResponseProcessor to that thing
03:50:45 <Botje> you might get away with newtype, but i'm still not sure how newtype ticks
03:51:42 * Baughn still isn't sure /why/ newtype ticks. Why does it exist?
03:52:13 <cjs> Changing the "type" to "newtype" there gives me "parse error in data/newtype declaration".
03:52:55 <Beelsebob> cjs: you need to provide a tag?
03:53:17 <cjs> A constructor?
03:53:20 <mattr__> newtype allows the compiler some optimisation room?
03:53:24 <Beelsebob> newtype ResponseProcessor = RP ((GLConnection, Response) -> (IO (), ResponseProcessor))
03:53:30 <mattr__> cjs: yes
03:56:42 <EvilTerran> Baughn, it exists for performance reasons, AFAICT
03:56:58 <EvilTerran> although it does also allow such things as generalized newtype deriving
03:57:00 <cjs> That gets me into an even bigger mess, somehow.
03:57:04 <Baughn> EvilTerran: Yes, but I don't see why the compiler can't rewrite qualifying datas to newtypes
03:57:09 <Baughn> EvilTerran: Ah. That might be it.
03:57:29 <EvilTerran> the compiler can't auto-rewrite because it changes the bottom semantics
03:57:57 <EvilTerran> data Foo = Foo () -- case Foo undefined of Foo _ -> "is okay"
03:58:06 <EvilTerran> newtype Foo = Foo () -- case Foo undefined of Foo _ -> "is undefined"
03:58:20 <EvilTerran> er, i think. something like that.
03:58:34 <Botje> EvilTerran++ # that made it clear for me
03:59:01 <EvilTerran> http://www.haskell.org/haskellwiki/Newtype
03:59:06 <EvilTerran> :)
03:59:17 <EvilTerran> ?where+ newtype http://www.haskell.org/haskellwiki/Newtype
03:59:17 <lambdabot> Good to know.
04:00:55 <EvilTerran> ah, that's what it is. in a newtype, the constructor always matches, even against something completely undefined
04:01:32 <EvilTerran> while with a strict data, undefined and (Foo undefined) are still indistinguishable, but trying to pattern-match out the constructor fails on both of them
04:02:15 <EvilTerran> and with a lazy data, they're distinct, and (Foo _) works on (Foo undefined) but not on undefined
04:09:31 <mxc> anyone around?
04:09:41 <mxc> and have a good haskell book recommendation?
04:10:03 <mxc> i've done a bit of ocaml, so i'mnot really looking for an intro to FP, more of a practical haskell book
04:11:09 <araujo> I like the R. Bird book
04:11:28 <Beelsebob> mxc: paul hudac's book is more practical
04:11:33 <Beelsebob> I'm still not keen on it though
04:11:57 <Beelsebob> my personal favourite is SJT's book, but it's possibly a bit too intro-to-FP like for you
04:13:15 <mxc> SPJ?
04:13:19 <mxc> who is SJT?
04:13:26 <Beelsebob> Simon Thompson
04:13:52 <Beelsebob> the third simon :P
04:13:56 <mxc> that looks closer to ben pierce's book
04:14:13 <Beelsebob> the other suggestion I can't not mention is Tony Davie's
04:14:14 <nominolo> tapl?
04:14:25 <mxc> which, while it has a really nice cover (i'm biased, took his class) is about a million itmes more theoretical than i'm looking for
04:14:28 <Beelsebob> but that's because I would get the royalties for it :P
04:14:55 <mxc> apparently, penn (home of me and ben pierce) is now switching from ocaml to haskell
04:14:58 <cjs> Is that the one from around '92? White cover with blue stripes?
04:15:05 <cjs> IO was...interesting.
04:15:12 <mxc> no, the kind of dark red one
04:15:21 <mxc> which is funny because he made fun of haskell when i took his class
04:15:22 <Beelsebob> cjs: yeh
04:15:29 <Beelsebob> cjs: pre-monads
04:15:39 <nominolo> mxc: what kind of fun?
04:16:03 <mxc> basically how it tries to be everything in FP/prog lang research and thus achieves nothing well
04:16:40 <nominolo> i think it's quite successful in all of those areas
04:17:18 <mxc> i feel like if i actually understood two things, i would love haskell
04:17:21 <nominolo> otoh, one day we'll all be programming in dependently typed languages and will laugh at the times when people were trying to fake features with all those weird extensions
04:17:23 <mxc> 1) monad transformers
04:17:50 <nominolo> yeah, we miss a good tutorial on that one
04:17:55 <mxc> 2) how to structure large programs with lots of IO.. ideally you want as much of it to be pure as possible, but seems kind of unwieldy, just cant get a sense of it
04:17:58 <hpaste>  cjs pasted "ResponseProcessor (again)" at http://hpaste.org/6887
04:18:05 <nominolo> took me 15min to understand in a lecture
04:18:19 <nominolo> but i completely failed to get it from anything i found on the web
04:18:25 <mattr__> mxc: on 1) I can't help
04:18:35 <mxc> see, i feel like if there was someone next to me explaining it, i'd get it
04:18:37 <cjs> Ok. If that showResponse function wants to print the time since the previous response it printed, how might I do that. State monad? Doesn't seem clever enough to me.
04:18:41 <mxc> but yeah, web not very helpful
04:18:50 <mattr__> mxc: and on 2) I have no specific advice except to say that it falls out with a bit of practice
04:19:09 <b_jonas> cjs: don't want to be overly clever
04:19:11 <nominolo> mxc: 2) basically embed IO in your custom monad
04:19:44 <nominolo> mxc: read dons's blog posts on xmonad
04:20:14 <Botje> cjs: you're already in IO, might as well use an IORef to store the time
04:20:51 <cjs> That won't soil my purity?
04:21:24 <Botje> type ResponseProcessor = Response -> IO ()
04:21:28 <Botje> how is that pure, again? :)
04:22:05 <cjs> Right, right. I was sort of thinking I was at least a partial virgin.
04:22:38 <Botje> not really, sorry
04:23:07 <Botje> @pl readResponse >>= \response -> sequence_ $ map ($response) procs
04:23:39 <Botje> ah, lambdabot went tits up again :(
04:27:41 <b_jonas> have no-one yet modified his own copy of lambdabot to start answering queries when lambdabot doesn't seem to answer?
04:37:34 <cjs> So an IORef starts out empty? What happens when you try to read an empty one?
04:38:13 <Botje> don't you supply an initial value?
04:38:25 <Botje> Data.IORef.newIORef :: a -> IO (IORef a)
04:45:03 <int-e> @botsnack
04:45:16 <Botje> OM NOM NOM NOM
04:58:26 <dancor> can i make ghci like .hsc files so that i can use :t in them
05:01:42 <hpaste>  morrow pasted "another shell pipe attempt" at http://hpaste.org/6888
05:29:59 <titusg> what are the options for doubly-linked data structures without IORefs etc? Can you do it with CPS somehow?
05:31:28 <mauke> just build it
05:31:33 <b_jonas> titusg: well, sometimes you can use Seq instead, but sometimes you can't
05:31:38 <mauke> but a doubly-linked list is pretty useless
05:31:49 <b_jonas> mauke: what? it isn't
05:31:52 <mauke> any time you change an element, you have to rebuild the list from scratch
05:32:31 <b_jonas> ah yeah, if it's immutable, then maybe
05:32:35 <earthy> http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg06683.html
05:32:44 <titusg> mauke: it'm more about finding the parent of an element without searching the wole thing
05:32:45 <b_jonas> though you could use it instead of an immutable array sometimes
05:32:48 <titusg> it's
05:33:20 <ddarius> http://web.archive.org/web/20061011010615/http://www.haskell.org/hawiki/TyingTheKnot
05:33:32 <mauke> can't you use a tree zipper?
05:33:57 <titusg> earthy: thanks for that
05:36:03 <titusg> mauke: maybe I can! I've not used zippers but I thought they were a way of saving the current pointer to the top of the list and moving it around...how would that help me find the predecessor of *any* element?
05:37:01 <hpaste>  morteng pasted "first program" at http://hpaste.org/6889
05:37:02 <mauke> a zipper is a pointer to a tree element
05:37:14 <morteng> hi  what is wrong with my hugs ? http://hpaste.org/6889
05:37:18 <mauke> the important part is that you can move in any direction, even up
05:37:59 <EvilTerran> morteng, you can't use "let" on its own in hugs, it only does complete expressions
05:38:03 <mauke> morteng: nothing
05:38:04 <EvilTerran> morteng, but you can in ghci
05:38:54 <morteng> ok  I have just watched an haskell video and i know where to find GHC.
05:39:49 <EvilTerran> because the REPL in ghci treats each line like a line in a do-block, you can use "let foo = some expression" (and "foo <- some IO expression" for getting the result of an IO expression into a name)
05:40:33 <EvilTerran> except ghci wraps everything that's not already an IO expression in "print (...)" to display the result
05:41:34 <titusg> mauke: thanks, I'll read up about zippers
05:41:41 <morteng> I try this one  http://haskell.org/ghc/download_ghc_66.html#x86solaris
05:42:21 <Deewiant> morteng: you might want the newest version instead, http://haskell.org/ghc/download_ghc_682.html#x86solaris
05:45:43 <morteng> Oh  and that during a download,  sure I try both versions.  Thank you for telling me before i set it up.  http://haskell.org/ghc/dist/6.8.2/maeder/ghc-6.8.2-i386-unknown-solaris2.tar.bz2 # is downloading.
05:49:15 <ddarius> @google Functional Pearl Weaving a web
05:49:38 <ddarius> Freakin' lambdabot
05:52:17 <HunterXHunter> why is the GHC compiler called "Glorious" ?
05:52:49 <HunterXHunter> what makes it glorious ?
05:53:00 <opqdonut> :D
05:53:18 <opqdonut> the same think that makes KDE "Kool"
05:53:33 <HunterXHunter> lol
05:54:00 <mauke> GHC stands for GHC Haskell Compiler
05:54:20 <ziman> morteng, this `let' syntax for defining functions interactively is supported in ghci only, i guess
05:54:36 <cjb> mauke: not according to its webpage :)
05:55:07 <ddarius> The G in GHC stands for Glasgow.  It's the Glorious Glasgow Haskell Compiler.
05:55:18 <EvilTerran> is hackage down again?
05:55:21 <opqdonut> ziman, morteng: think of the ghci prompt as being inside a do block
05:55:26 <opqdonut> then the let-thing makes sense
05:55:33 * EvilTerran provided that blurb already
05:55:53 <EvilTerran> ... also pointed out that you can do "foo <- someIOExpression" at the ghci prompt
05:56:20 <opqdonut> ah, sorry
05:56:21 <yitz> @seen lambdabot
05:56:32 <opqdonut> i didn't read any of the backlog :)
05:56:47 <opqdonut> ircing and following an algebra lecture at the same time is kinda hard
05:56:51 <EvilTerran> yitz, yeah, that's not gonna work with no lambdabot :P
05:57:07 * ziman had irssi scrolled up so he lived in the past a bit ;)
05:57:11 <EvilTerran> [12:07] * lambdabot has quit (Read error: 104 (Connection reset by peer))
05:57:12 * yitz feels abandoned 
05:57:26 <EvilTerran> (it's 13:57 here now)
05:57:44 <yitz> Cale is not around?
05:57:59 <yitz> I was about to type @seen Cale
05:58:26 <mauke>  idle     : 0 days 6 hours 15 mins 22 secs
05:59:04 <EvilTerran> [06:49] <Cale> ... is the last thing my /lastlog comes up with
05:59:04 <mauke> EvilTerran: I can't connect to hackage
05:59:20 <EvilTerran> http://downforeveryoneorjustme.com/hackage.haskell.org
05:59:23 <dancor> can hsc do arrays in structs
05:59:38 <dancor> i'm hard coding the offsets right now for the arrays and it's lamesauce
05:59:56 <mxc> @hoogle forkIO
06:00:03 <mauke> dancor: what do you mean?
06:00:22 <mauke> Control.Concurrent.forkIO:: IO () -> IO ThreadId
06:00:45 <EvilTerran> >mbot< ?join #haskell
06:00:46 <yitz> Hey, this is almost as good.
06:01:01 <EvilTerran> <mbot> not enough priviledges
06:01:14 <EvilTerran> but we can still use mbot by pm
06:01:28 <hpaste>  dancor pasted "hsc for arrays in structs?" at http://hpaste.org/6890
06:01:29 <yitz> msg mauke @pl \f g x y -> f (g x) y
06:01:41 <mauke> f . g
06:01:59 <yitz> msg mauke @pl \f g x y -> f g x (g y)
06:02:21 <mauke> dancor: why are you binding termios manually?
06:02:24 <mauke> dancor: http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Terminal.html
06:02:46 <dancor> that's funny
06:05:36 <EvilTerran> yitz, liftA2 (.) (.)
06:07:03 <yitz> On mbot I got flip . ((.) . )
06:07:24 <yitz> Looks like mbot is running on someone's private machine.
06:08:35 <EvilTerran> actually, that doesn't seem to be quite right. nvm.
06:10:30 <dancor> hackage is down?
06:10:42 <dancor> .\bot is missing?
06:10:43 <EvilTerran> liftA2 (.) (flip (.))
06:12:31 <EvilTerran> <EvilTerran> > (\f g x y -> f g x (g y)) (f :: (Expr -> Expr) -> Expr -> Expr -> Expr) (g :: Expr -> Expr) x y
06:12:31 <EvilTerran> <mbot>  f <SimpleReflect.Expr -> SimpleReflect.Expr> x (g y)
06:12:31 <EvilTerran> <EvilTerran> > liftA2 (.) (flip (.)) (f :: (Expr -> Expr) -> Expr -> Expr -> Expr) (g :: Expr -> Expr) x y
06:12:31 <EvilTerran> <mbot>  f <SimpleReflect.Expr -> SimpleReflect.Expr> x (g y)
06:12:56 <mxc> :t Option
06:13:17 <EvilTerran> <mbot> Not in scope: data constructor `Option'
06:14:12 <dancor> mauke: well how are arrays in structs done anyway?  i'm dying to know but i can't grab unix source from hackage bc it's down right now
06:14:40 <dancor> i don't really need to know anymore but i'm sure i will someday
06:16:34 <MarcWeber> I've a small question about GADTs: example http://rafb.net/p/13IMU987.html
06:17:03 <MarcWeber> is b of constructor 2 (line 7) kind of existential here?
06:17:06 <mauke> dancor: you get a pointer to the struct field, then do whatever
06:17:32 <EvilTerran> MarcWeber, indeed.
06:18:03 <MarcWeber> Does this definition make sense when not adding some class definitions to the context of C2 ?
06:18:14 <EvilTerran> i think a lot of people like GADTs because they let them have existential constructors much more intuitively, without having to muck about with forall.s
06:18:21 <EvilTerran> not really, no
06:18:21 <MarcWeber> I mean I have some value.. but I can't do anything useful with it, can I?
06:18:37 <EvilTerran> C3 :: b -> (b -> a) -> MyGadt a -- this would also be useful
06:19:57 <EvilTerran> but, like all existentials, you need some way of getting a value of concrete type out of the value of existential type before you can do anything with it
06:20:08 <MarcWeber> EvilTerran: Without gadts this could be done by using a class mapping b to a or using dynamic typing, right?
06:20:23 <EvilTerran> er...
06:20:32 <EvilTerran> "this"?
06:26:41 <mxc> anyone know when the realworldhaskell.org book is expected to come out?
06:28:10 <gnuvince> mxc: last I heard, it was 70% complete, and they were moving to a new server, at which point they'll release more chapter.  I don't know when this move will happen.
06:51:46 <hpaste>  (anonymous) annotated "drawTree" with "(no title)" at http://hpaste.org/6891#a1
06:53:10 <hpaste>  (anonymous) pasted "c" at http://hpaste.org/6892
06:55:24 <mxc> so hackage is dead?
06:55:27 <mxc> still
07:00:08 <shepheb> @pl \x -> f x || g x
07:00:19 <mauke> liftM2 (||) f g
07:00:31 <shepheb> mauke: thanks. \bot dead?
07:02:33 <EvilTerran> not dead, just sleeping
07:15:58 <gbacon> with HXT, how can I extract lists of values instead of transforming one XmlTree to another?
07:17:14 <gbacon> should my processor's type be something like ArrowXml a => a XmlTree [String] ?
07:18:10 <seebaer> looks good. that makes you extract a list of strings from an XmlTree.
07:18:30 <seebaer> if you give me a hint what you want to extract i might be able to help you
07:19:21 <gbacon> seebaer: I have deep $ isElem >>> hasName "foo" >>> getAttrValue "bar", but then what?
07:19:27 <gbacon> return doesn't typecheck
07:20:41 <Saul_> I'm having problems with an assignment I got
07:21:08 <seebaer> well, getAttrValue should return a string
07:21:14 <Saul_> The goal is to define a polyvariadic function that returns the amount of inputs
07:21:41 <Saul_> I've done something similar once, using http://okmij.org/ftp/Haskell/vararg-fn.lhs
07:21:58 <gbacon> seebaer: but it doesn't typecheck
07:22:05 <Saul_> But that uses extensions, and the assignment states that those aren't needed
07:22:31 <Saul_> So could someone nudge me in the right direction?
07:22:38 <gbacon> seebaer: expected Data.Tree.NTree.TypeDefs.NTree, inferred []
07:23:36 <seebaer> ah, now i understand. i will check it in a minute
07:26:09 <scook0> Text.Printf appears to be variadic without extensions, though I can't say for sure
07:27:32 <yondalf> it's quite easy to be variadic, i think...even read is variadic
07:28:17 <ehird> printf is variadic h98 yeah
07:28:21 <ehird> but impossible to understand
07:28:42 <yondalf> they should have just made printf and sprintf
07:32:03 <Saul_> Okay I'll check those out
07:32:12 <Saul_> Although I think I might have something here
07:33:37 <davidL> @bot
07:36:15 <seebaer> gbacon: first thing i think of is xpath. getXPathTrees "/foo/@bar/text()" >>> getText
07:41:07 <ExplicitCall> are there any repositories for yhc besides http://darcs.haskell.org/yhc/?  because darcs.haskell.org is still dead, as hackage. is
07:41:53 <gbacon> seebaer: but isn't that an XmlTree?
07:42:16 <seebaer> getText :: (ArrowXml a) => a XmlTree String
07:42:49 <ExplicitCall> ah, http://www.golubovsky.org/repos/yhc/ if someone is interested.  03-Sep-2007, not so old
07:43:17 <seebaer> this should transform it into a list of strings
07:46:32 <yitz> Cale?
07:53:22 <Industrial> I am doing http://en.wikibooks.org/wiki/Haskell/Next_steps#if_.2F_then_.2F_else and I am wondering why there is a difference between "mySignum 5-10" and "mySignum (5-10)".
07:54:03 <bgeron> }eval 3
07:54:14 <kpreid> Industrial: because application has the highest precedence.
07:54:26 <kpreid> Industrial: the former is equivalent to "(mySignum 5) - 10"
07:54:36 <Industrial> ah, okay
07:55:07 <shepheb> so if I use liftM2, why would I get a warning about import but not using Control.Monad?
07:56:29 <Baughn> XGas: Have fun. And don't let the esoteric discussions people here often get into discourage you; half the time I don't understand them either.
07:56:36 <XGas> lol
07:56:39 <XGas> Thanks.
07:57:40 <Saizan> shepheb: because Control.Monad exports it?
08:00:45 <bgeron> where's lambdabot gone?
08:01:19 <Cheiron> No idea, but I'll take over for the time being
08:01:30 <mapreduce> He gave up and is rewriting himself in COBOL.  3 million lines thus far.
08:01:41 <mapreduce> s/He/She/ etc if you like.
08:01:43 <byorgey> "lambdabot, why are you sleeping?  wake up! WAKE! UP!"
08:01:53 <shepheb> how does one deal with orphan instances?
08:02:01 <bgeron> !eval sum $ filter (\x -> 0 == 6 mod x) [1..5]
08:02:15 <byorgey> shepheb: you can either (1) find them a good home, or (2) ignore them.
08:02:27 <byorgey> and I was joking about (1).
08:02:54 <shepheb> I assume it's because they aren't being exported?
08:03:11 <davidL> hello byorgey
08:03:28 <byorgey> orphan instances are one of those things that I've read about twice, and understood both times, and then promptly forgot
08:04:22 <shepheb> "An instance declaration is an orphan if it appears in a module in which neither the class nor the type being instanced are declared in the same module."
08:05:08 <shepheb> meh, I'm going to ignore them, then.
08:06:52 <byorgey> hi davidL
08:08:56 <osfameron> gah... in 3 months I've forgotten all my haskell :-(
08:08:59 <davidL> I would have liked to discuss PSU but class starts in two minutes :-\
08:09:10 <osfameron> I wanted to write "n-at-a-time" and I think I need something along the lines of
08:09:21 <osfameron> *  unfoldr (splitAt 2) [1..10]
08:09:33 <osfameron> which of course doesn't work for types (Maybes and the like)
08:09:45 <osfameron> anyone give me a gentle prod in the right direction ?
08:10:07 <Baughn> osfameron: What do you expect it to do on a Maybe?
08:10:37 <shepheb> prana: no, it's an ordinary workspace. you can change which display has the focus with mod+w, e and r
08:10:38 <osfameron> Baughn: nothing... just that :t unfoldr suggests it needs a function (b -> Maybe (a,b))
08:10:40 <shepheb> mischan
08:10:52 <Baughn> osfameron: Ah. You just want to get [[1,2],[3,4,]..etc?
08:10:57 <osfameron> and splitAt is just [a] -> ([a],[a])
08:10:59 <osfameron> yeah
08:11:24 <osfameron> I could have sworn it was easy... but been busy with $newjob and not looked at haskell in 3 months, can't remember at all...
08:11:46 <mauke> > unfoldr (\x -> do _:_ <- return x; return $ splitAt 2 x) [1..10]
08:11:47 <Cheiron>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
08:12:05 <quicksilver> > takeWhile (not.null) . map (take 2) . iterate (drop 2) $ [1..10]
08:12:06 <Cheiron> Terminated
08:12:10 <gbacon> seebaer: I'm running multiple XPath queries and trying to factor out the readDocument
08:12:12 <quicksilver> > takeWhile (not.null) . map (take 2) . iterate (drop 2) $ [1..10]
08:12:13 <Cheiron> Terminated
08:12:23 <yitz_> > let groupsOf n = takeWhile (not . null) . map (take n) . iterate (drop n) in groupsOf 2 [1..10]
08:12:23 * quicksilver blinks
08:12:23 <Cheiron> Terminated
08:12:24 <gbacon> seebaer: but am having a hard time pleasing the typechecker
08:12:52 <gbacon> if dons complains about HXT, I guess I shouldn't feel bad
08:13:13 <yitz_> quicksilver: lambdabot has been out cold for a few hours now.
08:13:17 <mnislaih> congratz Igloo & dcoutts_ , and good luck
08:13:31 <osfameron> mauke: nice - that's basically what I had but with monadic boilerplate on the front... not the simple answer I thought I remembered
08:14:18 * mnislaih hopes that some contractor for well-typed will be spanish and you will need a spanish speaking hacker :)
08:14:32 <quicksilver> yitz_: yes, but why doesn't Cheiron like that?
08:14:37 <Baughn> > let atN n [] = []; atN n l = [take n l] : atN n (drop n l) in atN 2 [1..10]
08:14:38 <Cheiron>  [[[1,2]],[[3,4]],[[5,6]],[[7,8]],[[9,10]]]
08:14:50 <Baughn> Close enough. :)
08:15:11 <yitz_> > take 10 [1..]
08:15:12 <Cheiron>  [1,2,3,4,5,6,7,8,9,10]
08:15:36 <proppy> Hi, when I try runhaskell Setup.lhs build cabal-install
08:15:36 <proppy> http://pastebin.com/m1cbac488
08:15:37 <yitz_> > take 10 $ iterate (+1) 1
08:15:38 <Cheiron>  [1,2,3,4,5,6,7,8,9,10]
08:15:41 <proppy> I get the following
08:15:41 <Saizan> mnislaih: about cabal-install .cabal/config, have thought about allowing flags of other commands to appear there? not only ConifgFlags?
08:16:05 <yitz_> > (take 10 . iterate (+1)) 1
08:16:06 <Cheiron> Terminated
08:16:08 <scook0> splitting a list into groups of n is starting to become a faq...
08:16:12 <yitz_> @type (.)
08:16:13 <Cheiron> forall b c a. (b -> c) -> (a -> b) -> a -> c
08:16:31 <seebaer> gbacon: i often complain, too. sometimes it's hard to get a start. but sometimes you see the inner beauty.
08:16:37 <Saizan> proppy: which version of Cabal are you using?
08:16:46 <seebaer> tell me what you want to do, maybe i can help you to wrestle the typechecker
08:17:02 <gbacon> seebaer: oh yes, HXT code is very nice once it's working :-)
08:17:03 <yitz_> > (take 10 . id) [1..]
08:17:04 <Cheiron> Terminated
08:17:18 <Baughn> @pl atN n l = let (h,r) = splitAt n l in h : atN n r
08:17:18 <Cheiron> (line 1, column 9):
08:17:18 <Cheiron> unexpected "="
08:17:18 <Cheiron> expecting variable, "(", operator or end of input
08:17:29 <unenough> what is the best age to start teaching Haskell?
08:17:39 <unenough> He is 5 months old already
08:17:47 <unenough> :)
08:17:52 <mapreduce> I would start teaching it when I'm 28 if possible.
08:18:01 <seebaer> gbacon: yeah, and i always get a adrenalin flush when i hit the right types with the first attempt ;)
08:18:02 <unenough> I mean, to start learning
08:18:07 <mapreduce> Sorry :)
08:18:09 <yitz_> hmm, seems to have (.) f g x = (f . g) $! x
08:18:14 <scook0> @pl \f x -> guard (f x) >> return x
08:18:15 <Cheiron> (`ap` return) . (((>>) . guard) .)
08:18:22 <seebaer> rush
08:18:24 <seebaer> not flush
08:19:03 <gbacon> seebaer: so I have doc <- readDocument ... and I want to feed doc to various arrows
08:19:25 <seebaer> so, the xml tree should go into several arrows?
08:19:29 <gbacon> seebaer: but doc >>> foo says it wants [XmlTree], not XmlTree
08:19:54 <gbacon> seafood: right, I want to run multiple XPath queries against the same tree
08:19:54 <seebaer> try readDocument >>> (arrow1 &&& arrow2 &&& arrow3)
08:20:07 <gbacon> oh yeah
08:20:23 <gbacon> @karma+ seebaer
08:20:23 <Cheiron> seebaer's karma raised to 1.
08:20:27 <seebaer> that will give you a (res1, res2 res3)
08:20:31 <gbacon> right
08:20:40 <seebaer> and then you can put it into something that will merge the results or whatever
08:20:45 <Baughn> @pl  atN n [] = []; atN n l = let (h,r) = splitAt n l in h : atN n r
08:20:45 <Cheiron> (line 1, column 10):
08:20:46 <Cheiron> unexpected "="
08:20:46 <Cheiron> expecting variable, "(", operator or end of input
08:20:56 <seebaer> e.g. arr (\(a,b,c) -> a ++ b ++ c)
08:20:56 <Baughn> ..too much for poor pl?
08:21:01 <gbacon> seebaer: but they aren't independent
08:21:17 <Baughn> gbacon: Not much point right now, we're on an emergency reserve lambdabot.
08:21:29 <seebaer> so, one arrow's result should move into another arrow?
08:21:31 <gbacon> seebaer: the query in arrow2 will need to know the results from arrow1
08:21:38 <scook0> > let ensure f x = guard (f x) >> return x in unfoldr (ensure (not . null . fst) . splitAt 3) [1..10]
08:21:38 <Cheiron> Terminated
08:21:52 <seebaer> k, no problem - my favourite operator comes into play
08:22:02 <gbacon> <- -< ?
08:22:11 <seebaer> readDocument >>> (arrow1 &&& (arrow2 $< arrow1))
08:22:19 <proppy> Saizan: 1.3.x (current development version) I guess
08:22:25 <seebaer> might not be to clever for laziness
08:22:27 <seebaer> but does the job
08:22:30 <proppy> Saizan: IIRC I pulled it from darcs
08:22:42 <gbacon> @ty ($<)
08:22:43 <Cheiron> Not in scope: `$<'
08:23:07 <Saizan> proppy: so you need to pull cabal-install from darcs too
08:23:27 <seebaer> ($<) :: (ArrowList a) => (c -> a b d) -> a b c -> a b d
08:23:36 <Baughn> @karma C
08:23:36 <Cheiron> C has a karma of 15
08:23:56 <proppy> Saizan: thanks
08:24:02 <mnislaih> Saizan, can you put an example of why is that useful ?
08:24:10 <unenough> @karma Cheiron
08:24:10 <Cheiron> Cheiron has a karma of 0
08:24:34 <yitz_> @karma+ Cheiron
08:24:34 <Cheiron> Cheiron's karma raised to 1.
08:24:55 <proppy> @karma+ Saizan
08:24:55 <Cheiron> Saizan's karma raised to 5.
08:24:58 <proppy> :)
08:25:11 <Saizan> mnislaih: install's --root-cmd
08:25:51 <mnislaih> oh, I see. I thought all the options were subsumed by the configure command, but I see they are not
08:26:23 <proppy> Cheiron: help
08:26:24 <mnislaih> yes, we should have that. Do you mind to post this in the Trac ticket ?
08:27:08 <seebaer> gbacon: http://www.fh-wedel.de/~si/HXmlToolbox/hdoc_arrow/Control-Arrow-ArrowList.html#v%3A%24%3C
08:27:37 <mnislaih> Saizan: luckily this should involve changes to cabal-intall only,
08:27:46 <gbacon> seebaer: yeah, I've been all over the index
08:28:15 <seebaer> gbacon: does it work or do you need another example (i did not understand the one in the haddock)
08:29:08 <gbacon> seebaer: it's not typechecking
08:29:42 <seebaer> hpaste it, i will have a look
08:30:07 <Saizan> mnislaih: yeah, it looks so
08:30:58 <sethk> what should I use when I need Data.Map but supporting duplicate keys?
08:31:41 <mauke> Data.Map k (Data.Set v)
08:31:49 <sethk> mauke, thanks
08:32:30 <mnislaih> the values need not be in Ord. You can use Data.Map k (Data.Sequence a) if they are not
08:33:11 <gwern> morning all
08:33:35 <proppy> Saizan:  darcs get --partial http://darcs.haskell.org/cabal-install/ quite long
08:33:45 <sethk> mauke, mnislaih, wait, I'm confused.  Won't Data.Map k (Data.Set v) still allow only one member with key k?
08:34:20 <Jedai> mnislaih: In this case, and except if you have really strange requirements, you better use Data.Map k [v] since it will likely perform better
08:34:25 <mnislaih> But you have a list of values instead of one value, thus modelling duplcate keye
08:34:28 <mnislaih> keys*
08:34:36 <sethk> mnislaih, ah, ok.  thanks
08:34:38 <gbacon> seebaer: http://hpaste.org/6893
08:34:38 <mnislaih> Jedai: why ?
08:35:07 <gbacon> oh, duh
08:35:26 <Jedai> mnislaih: Data.Sequence has better asymptotic complexity for some operations, but the constant factors of List are much better
08:35:48 <mnislaih> maybe, and I don't know in what cases is that true, but you probably want to be strict in the contents of the Map anyway
08:35:55 <sethk> mnislaih, in that case, if the values are strings, should I just use   Data.Map k [String]   ?
08:36:10 <mnislaih> sethk: yep
08:36:16 <sethk> mnislaih, ok, thanks
08:36:24 <gbacon> seebaer: see my annotation
08:36:39 <Jedai> mnislaih: And ? What does the strictness have to do with Data.Sequence ?
08:36:59 <mnislaih> Jedai: Sequences are strict in the spine
08:37:23 <sethk> mnislaih, then to use fromList my list has type  [(String,[String])]  ?
08:38:01 <mnislaih> sethk: I'm not sure, shouldn't that be [(k,[String])]
08:38:18 <Jedai> mnislaih: given the fact that sethk want to emulate duplicate keys, he will likely insert his values one at a time and the list spine will then be strict too
08:38:19 <sethk> mnislaih, the keys are also always strings in this particular program
08:38:35 <Jedai> sethk: Then this type is correct
08:39:00 <sethk> Jedai, that's correct, I'm processing a list and adding each value to the Map, either as a new key or a new value for an existing key
08:39:24 <seebaer> gbacon: if you use g $< f
08:39:31 <seebaer> g needs an additional param
08:40:18 <byorgey> sethk: I think you want to use  fromListWith (++)
08:40:34 <byorgey> sethk: if you just use fromList, it will not combine multiple values for the same key like you want.
08:40:56 <sethk> byorgey, I was assuming the list was:    ("abc", ["def", "ghi"])
08:41:07 <seebaer> gbacon: does datasets compute a string value that influences the dataunits arrow?
08:41:10 <sethk> byorgey, but I didn't know about the other option so I'll think about that.
08:41:17 <byorgey> sethk: oh, if you already have all values for the same key combined into a single pair, then fromList would be fine
08:41:18 <gbacon> seebaer: it should
08:41:45 <sethk> byorgey, I'm using fromList / toList to persist the data
08:42:02 <Jedai> @src Data.Map.fromListWith
08:42:02 <Cheiron> Source not found.
08:42:03 <gbacon> seebaer: e.g., //dataSet[@name='foo']/*/@name/text()
08:42:08 <Jedai> @src fromListWith
08:42:08 <Cheiron> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
08:42:20 <byorgey> sethk: aha, well, if you only ever call fromList on a list produced by toList, then it should be fine
08:42:21 <Jedai> ?source Data.Map
08:42:21 <Cheiron> http://darcs.haskell.org/packages/4/Data/Map.hs
08:42:37 <gbacon> seebaer: where foo is one of the elements returned from datasets
08:43:03 <seebaer> gbacon: ah, now i understand
08:43:10 <gbacon> make that //dataSet[@name='foo']/dataUnits/*/@name/text()
08:43:20 <sethk> byorgey, your suggestion is maybe more relevant to how I add a new value.  I can write a few lines of code, of course, but is there a better way?
08:43:56 <Jedai> myInsert = insertWith (++) . (:[])
08:44:05 <seebaer> gbacon: so dataset determines the attribute that you want to look up?
08:44:09 <Jedai> Or something like that
08:44:14 <byorgey> sethk: what Jedai said =)
08:44:16 <sethk> Jedai, myInsert being the Map after the insert?
08:44:26 <byorgey> well, not quite, but that's the idea
08:44:38 <sethk> byorgey, ok, why not quite?  :)
08:44:44 <Jedai> sethk: Nope, myInsert is the fonction you'll use to insert new value in the map
08:44:49 <byorgey> @type insertWith
08:44:49 <Cheiron> Not in scope: `insertWith'
08:44:50 <Jedai> :t insertWith
08:44:50 <Cheiron> Not in scope: `insertWith'
08:44:55 <byorgey> @type M.insertWith
08:44:56 <Cheiron> Couldn't find qualified module.
08:44:59 <Jedai> :t Data.Map.insertWith
08:45:00 <Cheiron> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> Data.Map.Map k a -> Data.Map.Map k a
08:45:04 <sethk> Jedai, ah, ok.
08:45:16 <gbacon> seebaer: right, I want to match dataunits with their parent dataSets
08:45:33 <gbacon> seebaer: i.e., (String, [String])
08:45:38 <Jedai> Well then : myInsert k = insertWith (++) k . (:[])
08:45:49 <Jedai> should do it, no ?
08:45:49 <byorgey> yes, that looks better =)
08:46:03 <Jedai> :t Data.Map.insertWith (++) k . (:[])
08:46:04 <Cheiron> Not in scope: `k'
08:46:12 <Jedai> :t \k -> Data.Map.insertWith (++) k . (:[])
08:46:13 <Cheiron> forall a k. (Ord k) => k -> a -> Data.Map.Map k [a] -> Data.Map.Map k [a]
08:47:30 <sethk> :t (:[])
08:47:31 <Cheiron> forall a. a -> [a]
08:47:46 <seebaer> gbacon: see hpaste
08:47:56 <sethk> :t . (:[])
08:47:56 <Cheiron> parse error on input `.'
08:48:03 <sethk> :t k . (:[])
08:48:03 <seebaer> gbacon: i fixed the typechecking for you
08:48:03 <Cheiron> Not in scope: `k'
08:48:15 <mauke> :t ?k . (:[])
08:48:15 <Cheiron> forall c a. (?k::[a] -> c) => a -> c
08:48:22 <seebaer> gbacon: but be careful, ($<) makes you addicted quickly
08:48:22 <sethk> oh, you made a lamba to get the type.
08:48:25 <sethk> mauke, thanks
08:49:12 <gbacon> seebaer: I may have gotten it independently.. reloading
08:49:42 <gbacon> seebaer: yeah, pretty close
08:49:57 <byorgey> :t \k -> k . (:[])
08:49:57 <Cheiron> forall c a. ([a] -> c) -> a -> c
08:51:19 <byorgey> Type Inference with Implicit Parameters Considered Harmful =P
08:51:26 <gbacon> seebaer: see my annotation
08:51:39 <sethk> byorgey, I'm still struggling a bit with the type.  For Data.Map m, key k, and value v, what's the syntax to add a value and return the new map?
08:51:49 <sethk> not return, sorry  :)  You know what I mean
08:51:49 <Jedai> sethk: The idea is that (:[]) wrap your value in a list with one element and insertWith add this value to the list associated to the key k
08:52:16 <Jedai> sethk: myInsert key value oldMap
08:52:21 <byorgey> sethk: given those things, you could just write   insertWith (++) k [v] m
08:52:31 <Jedai> sethk: and that evaluates to the new map
08:52:36 <byorgey> sethk: Jedai's myInsert function just abstracts out this functionality
08:53:18 <byorgey> sethk: so an equivalent and possibly simpler to understand way to write myInsert would be:
08:53:32 <byorgey> myInsert k v m = insertWith (++) k [v] m
08:53:43 <Jedai> byorgey: You know what, I might be a little bit pointfree sick... ^^
08:53:47 <byorgey> hehe
08:54:16 <byorgey> dropping the m from both sides is easy, to obtain:
08:54:22 <byorgey> myInsert k v = insertWith (++) k [v]
08:54:42 <byorgey> going from there to the  . (:[]) version is a little harder to see if you're not used to it.
08:55:09 <Jedai> And a little bit pointless (ah no pointfree, sorry !)
08:55:20 <seebaer> gbacon: what is wrong?
08:55:24 <sethk> byorgey, thanks.  I tend to get messed up about types with the composition operator
08:55:35 <byorgey> sethk: yeah, it comes with practice.
08:55:36 <Jedai> @pl \k -> Data.Map.insertWith (++) k . (:[])
08:55:36 <Cheiron> (. return) . Data.Map.insertWith (++)
08:55:53 <gbacon> seebaer: oh, nothing.. just for comparison.. it's giving me a pairlist that I could feed to Data.Map.fromList, e.g.
08:55:58 <byorgey> yeesh, that's even worse =)
08:56:20 <Jedai> byorgey: Well yes, that's the _point_ of @pl !
08:56:29 <byorgey> yeah, I know ;)
08:56:42 <byorgey> the... point, eh?
08:56:44 <seebaer> gbacon: so, does it work with the input data?
08:58:21 <shepheb> using @pl, in general, mangles your code. but every once in a while, it's a brain explosion, and you level up your Haskell skill.
08:58:52 <gbacon> seebaer: yes
08:59:29 <seebaer> gbacon: dataunits set = traceMsg 0 set >>> getXPathTrees xpath >>> getText
08:59:47 <seebaer> gbacon: fine :-) you can use the traceMsg arrow for debugging, it is nice
09:00:05 <gbacon> seebaer: thanks for the tip
09:01:13 <gbacon> seebaer: so if I want another link in the chain, should I ... >>> (arr3 $< arr2 $< arr1) ?
09:03:13 <gbacon> seebaer: hmm.. or bury in dataunits with &&&
09:14:54 <sethk> OK, all, almost there.  However, now I need to make sure that each value in the value list is unique.  In other words, if value V is already in the [String] list for key k, then don't add it again.
09:16:32 <sethk> I can use a List function I think that checks whether a value exists
09:17:21 <Saizan> sethk: or you could use Data.Set.Set instead
09:17:33 <sethk> saiam, yes, that might be cleaner
09:18:49 <gwern> wonder why QuickCheck 2 hasn't been released
09:18:56 <gwern> the repo has been dead since November
09:19:02 <gwern> *inactive
09:20:16 <seebaer> gbacon: do you want two input params to the dataunits-arrow?
09:20:29 <dons> gwern: there's active development happenign separately
09:20:36 <dons> all is in hand.
09:20:57 <gbacon> seebaer: I made the dataunits a compound arrow
09:21:46 <gbacon> seebaer: and it's working, but now I'm trying to do something with what's effectively a toList gone awry :-)
09:21:55 <gwern> dons: where's the real repo then? I'm working off of http://darcs.haskell.org/QuickCheck and the homepage its cabal lists is dead
09:22:40 <dons> you can just use that for now. please don't place it on hackage, the maintainers are looking after it
09:23:04 <gbacon> @index on
09:23:04 <Cheiron> bzzt
09:23:20 <gwern> dons: what are they doing then? november was a long time ago
09:23:25 <sethk> Saizan, you're thinking I use Data.Set, and use the member() function to check whether the value exists?
09:23:28 <gbacon> @hoogle on
09:23:28 <Cheiron> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
09:23:28 <Cheiron> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
09:23:28 <Cheiron> Data.Function :: module
09:23:39 <gbacon> @ty on
09:23:39 <Cheiron> Not in scope: `on'
09:23:43 <dons> writing a paper, and finishing the last things
09:23:54 <gbacon> @ty compare `Data.Function.on` fst
09:23:55 <Cheiron> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
09:24:00 <gbacon> on rocks
09:25:47 <seebaer> gbacon: i don't understand, can you explain it a little more?
09:26:25 <yuriyp> @src Data.Function.on
09:26:26 <Cheiron> Source not found. Do you think like you type?
09:26:42 <gbacon> seebaer: I changed it to (datasets &&& (uom $< (dataunits $< datasets)))
09:26:51 <desegnis> @djinn (b -> b -> c) -> (a -> b) -> a -> a -> c
09:26:51 <Cheiron> f a b c _ = a (b c) (b c)
09:27:05 <gbacon> too bad I need the extra parens
09:27:07 <desegnis> bah
09:27:26 <seebaer> what is uom supposed to do?
09:27:35 <gbacon> seebaer: another XPath query of course! :-)
09:28:02 <gbacon> seebaer: seems like it'd be better to thread datasets instead of doing it twice
09:28:37 <seebaer> gbacon: maybe a let ... in would help
09:31:52 <Jedai> sethk: You don't need to use member, a Set can't have a value twice
09:32:19 <Jedai> When you insert a value that's already in the set, it just stay the same
09:32:27 <sethk> Jedai, the doc is a bit confusing, it says "if the set already contains an element equal to the given value, it is replaced with the new value"
09:32:42 <sethk> Jedai, I guess if they are equal that's the same as what you said  :)
09:33:43 <Jedai> sethk: I guess that's to adress the case where the Eq instance is such that different value can still be "equal" in the sense that a == b returns True
09:34:56 <Jedai> sethk: But in all usual cases (Not crazy instances), that means if you add a value that's already in the set, it stays the same
09:35:41 <tromp> maybe your set has numbers mod 10, so insert(16,{2,6}) = {2,16}
09:36:16 <Jedai> sethk: And don't worry, Eq String is sane (the only really insane instances in the standard lib that I know of is Float/Double but that can't be helped since it's the IEEE standard)
09:37:14 <Baughn> > (0/0) == (0/-0)
09:37:16 <Cheiron>   Not in scope: `/-'
09:37:20 <Baughn> > (0/0) == (0/(-0))
09:37:22 <Cheiron>  False
09:37:35 <Peaker> that makes sense
09:37:35 <Baughn> > (0/0) == (0/0)
09:37:36 <Cheiron>  False
09:37:48 <Baughn> > 0/0 -- Hmm
09:37:49 <Cheiron>  NaN
09:38:14 <mgsloan> that doesn't look right
09:38:41 <Jedai> sethk: tromp example is pretty good, (that's one of these case where your Eq instance may be different from observational equality)
09:39:01 <Jedai> > 1 / 0
09:39:02 <Cheiron>  Infinity
09:39:09 <Baughn> @pl \n l = let (h,r) = splitAt n l in h : foo n r
09:39:09 <Cheiron> (line 1, column 6):
09:39:09 <Cheiron> unexpected "="
09:39:09 <Cheiron> expecting pattern or "->"
09:39:19 <Peaker> where's lambdabot?
09:39:22 <yitz_> > 1/0 == 1/0
09:39:23 <Cheiron>  True
09:39:26 <Baughn> @pl \n l -> let (h,r) = splitAt n l in h : foo n r
09:39:26 <Cheiron> (line 1, column 13):
09:39:26 <Cheiron> unexpected "("
09:39:26 <Cheiron> expecting "()", natural, identifier or "in"
09:39:56 <Jedai> mgsloan: 0/0 == NaN because you can't guess what would be the limit of two sequences converging towards zero
09:40:23 <Jedai> mgsloan: And NaN is never equal to anything (even NaN) because it isn't, really !
09:40:24 <Baughn> @pl \n l -> (\(h,r) -> h : foo n r) splitAt n l
09:40:25 <Cheiron> flip (`ap` snd) splitAt =<< (. fst) . flip ((.) . (:)) . foo
09:40:35 <yitz_> > compare (0/0) (0/0)
09:40:36 <Cheiron>  GT
09:41:02 <byorgey> > compare (-0/0) (0/0)
09:41:03 <Cheiron>  GT
09:41:18 <Baughn> Shouldn't compare throw an error on these?
09:41:26 <Jedai> yitz_: This one is pretty fucked up, I would really have preferred it to error on compare NaN _
09:41:32 <byorgey> > 1 + 1  -- phew, much better
09:41:32 <Cheiron>  2
09:41:36 <ddarius> @unpl const ap ap (const (ap id 1) const)
09:41:36 <byorgey> aahhhh
09:41:36 <Cheiron> (\ g h i -> h >>= \ g -> i >>= \ e -> return (g g e)) (\ j -> j) ((\ c -> c) >>= \ r -> 1 >>= \ q -> return (r q))
09:42:19 <yitz_> Jedai: what does ieee say to do?
09:42:48 <Baughn> ddarius: Please tell me nobody has actually /used/ that line
09:42:49 <Jedai> yitz_: On this one I don't know (not my field), but my guess is "not specified" for performance reason
09:43:22 <ddarius> Baughn: What I wrote or what Cheiron produced?
09:43:23 <Jedai> ddarius: I concur with Baughn on this one o_O'
09:43:28 <Baughn> ddarius: Either.
09:43:55 <ddarius> Baughn: What I wrote is someone's nick (although it was missing a closing bracket so...)
09:44:02 <ddarius> KK[K[SI1]K
09:44:06 <byorgey> "On comparing NaN to NaN, IEEE-conformant implementations should issue a warning advising the user to stab themselves in the eye with a (void*) pointer."
09:44:22 <ddarius> er KSS[K[SI1]K
09:44:39 <Baughn> (NaN == NaN) == NaB, maybe?
09:44:49 <Jedai> byorgey: One more proof that IEEE is a sane standard !! ^^
09:45:37 <Peaker> Baughn, you mean, an exception? :)
09:45:47 <Baughn> Peaker: That would work too
09:45:59 <yitz> Baughn, Peaker: NaNaN
09:46:05 <Baughn> Alternately, someone needs to implement isBottom
09:46:09 <Peaker> Baughn, propagating this "Na*" thing all over the computation seems like an exception
09:46:17 <ddarius> @hoogle isBottom
09:46:18 <Cheiron> No matches found
09:46:22 <Deewiant> I believe NaN <any comparison> NaN = unordered
09:46:31 <Baughn> isBottom (last [1..]) = True
09:47:09 <Saizan> > (0/0) == (0/0)
09:47:10 <Cheiron>  False
09:47:19 * ddarius pokes haskell.org
09:47:29 <Deewiant> > (0/0) > (0/0)
09:47:30 <Cheiron>  False
09:47:38 <Deewiant> > compare (0/0) (0/0)
09:47:39 <Cheiron>  GT
09:47:44 <Deewiant> O_o
09:47:58 <baaba> well _that_ sure makes sense :P
09:48:02 <ddarius> :t Test.QuickCheck.Batch.isBottom
09:48:02 <Cheiron> forall a. a -> Bool
09:48:08 <Deewiant> @src compare
09:48:08 <Cheiron> compare x y | x == y    = EQ
09:48:08 <Cheiron>             | x <= y    = LT
09:48:08 <Cheiron>             | otherwise = GT
09:48:20 <Baughn> ddarius: ...what
09:48:21 <Deewiant> predictable :-P
09:48:25 <ziman> shouldn't (compare (0/0) (0/0)) be undefined?
09:48:36 <Deewiant> I think it should
09:48:40 <Baughn> ddarius: But.. halting problem...
09:49:05 <bgeron> you can at least define it ;)
09:49:21 <bgeron> and not tell whether it terminates in the "yes" case
09:50:07 <ydo> http://hpaste.org/6896 - I need help with this one
09:52:20 <yitz> ydo: the number of type params on the left need not equal the number on the right.
09:53:18 <yitz> (that's a cryptic hint, but think about it for a moment)
09:54:05 <ydo> but I can't get the constructors signature right even when I use the one :t give me?
09:54:12 <ddarius> ydo: The swallows ride at midnight.  Think about it for a moment.
09:55:10 <Jedai> ydo: Your Quad datatype has four type params when it normally is only parametrized by two types. Think about it for a moment.
09:56:01 <Jedai> ydo: You can ignore ddarius advice, it is much _too_ deep.... ^^
09:56:08 <bgeron> ydo: Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo. Think about it for a moment.
09:56:11 * bgeron runs
09:56:22 <yitz> @slap bgeron
09:56:22 * Cheiron pokes bgeron in the eye
09:56:37 <Peaker> Cale, was Haskell your first language?
09:57:24 <yitz> Peaker, if Cale were here, lambdabot would also
09:57:41 <Peaker> ah
09:57:45 <mapreduce> I thought dons was hosting it atm.
09:57:45 <Peaker> I see
09:58:12 <ydo> so.. the arguments to the constructor is really like a type pattern?
09:58:15 <ddarius> mapreduce: lambdabot gets around
09:58:21 <ydo>      26 data Quad a b  = Quad a a b b
09:58:24 <ydo> I guess
09:58:32 <yitz> ydo: yes.
09:58:48 <ddarius> ydo: The syntax is exactly analogous to function definition syntax
09:59:20 <Peaker> Using (a -> Bool) as a set type seems great. Question is, how easy is it to later replace that function with a data structure for O() improvements or the ability to enumerate the set properly, etc?
09:59:38 <ddarius> Peaker: Use an ADT
10:01:36 <Peaker> ddarius, I am wondering if I later want to use a data structure that requires imperative changes.. can that be encapsulated in the ADT so I don't commit to having no imperative data structures?
10:02:37 <ddarius> Peaker: If you use a monadic interface, or the imperative implementation is not observable (i.e. it has a pure interface)
10:03:05 <Jedai> Peaker: You can use "unsafePerformIO" but then there's the question of the persistence of your data structure (you can see how it's done for DiffArray in the standard lib)
10:03:43 <Jedai> Peaker: ByteString is another example of a pure interface to an imperative data structure
10:04:03 <Peaker> thanks, I'll look at ByteString
10:06:34 <Jedai> Peaker: Understand that if you use a data structure that's not persistent (you can't access to old version), you have to do it in IO or at least in ST
10:07:08 <Peaker> Jedai, yeah, that worries me a little - I have to commit to a lot by having the ADT live in a monad or not
10:07:38 <bparkis> is there a "most general" typed lambda calculus, that all other lambda calculi are special cases of?
10:08:27 <lament> the simply typed LC presumably
10:08:44 <lament> if anything
10:08:49 <bparkis> simply typed LC is not dependently typed
10:08:56 <bparkis> so it can't be the most general
10:09:00 <lament> oh, in that case a pure type system
10:09:05 <bparkis> what is a pure type system?
10:09:06 <Jedai> I would have said a PTS too
10:09:12 <mrd> also simply typed LC is strongly normalizing
10:09:29 <lament> bparkis: it's the thing on the opposite end of the spectrum. Potentially infinite hierarchy of kinds.
10:09:44 <bparkis> strongly normalizing is less general, it means you can't express everything
10:11:37 <bparkis> wait I am reading that pure type systems are actually a family of lambda calculi
10:12:08 <bparkis> is there some member of that family that is sufficient to express anything?
10:12:12 <Saizan> all of lambda cube is strong normalizing, no?
10:12:43 <glguy> seems like the most expressive would be untyped lambda calc
10:12:58 <bparkis> typed lambda calculus is not a special case of untyped lambda calculus
10:13:30 <mib_vi5q8d> hey guys i am writing a replace function and i want to check the char before the word is that possible ?
10:13:40 <Saizan> bparkis: in which way?
10:13:44 <ski> !hpaste
10:13:47 <Jedai> bparkis: Well the limit of the PTS I guess
10:13:57 <Jedai> :-P
10:14:13 <lament> bparkis: pure type systems have a set of kinds; when this set is infinite you presumably get the most expressiveness
10:14:23 <mrd> bparkis: i think what you are looking for is more along the lines of the calculus of constructions
10:14:25 <Jedai> mib_vi5q8d: What you want isn't very clear ?
10:14:31 <glguy> type systems serve to eliminate a class of invalid programs
10:14:35 <lament> bparkis: you lose any hope of type inference of course
10:14:36 <glguy> and take some valid ones with them
10:14:36 <ski> mib_vi5q8d : http://hpaste.org/new
10:15:14 <mrd> Saizan: if you want dependent types, and you're not strongly normalizing, type checking is going to become undecidable
10:15:21 <Jedai> CoC is a PTS, no ?
10:15:37 <bparkis> yes lament that's acceptable
10:16:14 <bparkis> the calculus of constructions is strongly normalizing
10:16:44 <Saizan> mrd: right
10:19:03 <bparkis> there are so many different kinds of logics, but I've also heard that ZFC is considered a "foundation"
10:19:06 <lament> i kinda doubt it would be strongly normalizing when the hierarchy of types is infinite... but that's just guessing
10:19:26 <lament> but ZFC is clearly not the most expressive one, of which all others are special cases
10:19:28 <mrd> ZFC is one foundation for mathematics that appears to be in vogue
10:19:40 <bparkis> but how can it be a foundation if it is not the most expressive
10:19:51 <lament> bparkis: heard of this guy called Turing?
10:20:00 <roconnor> no inaccesable cardinals.
10:20:02 <Saizan> i'd like to see an interesting program that can't be expressed in coq
10:20:04 <bparkis> yes I know what Turing completeness is
10:20:22 <roconnor> Saizan: write an intepreter for coq (in coq)
10:20:37 <lament> bparkis: ZFC is powerful enough to express anything else in it. Just like untyped LC is powerful enough to embed an interpreter for typed LC in it.
10:20:44 <mrd> though I'm not really aware of any mathematicians that care if their proofs can be completely validated against ZFC.  I mean, practically.
10:20:53 <nominolo> Saizan: you can always add a magical big number which you decrease in each step
10:20:55 <mib_vi5q8d> i just posted the replace function, take a look at it
10:21:05 <nominolo> Saizan: then it won't run forever, but long enough
10:21:16 <nominolo> say, 2^64 seconds
10:21:26 <Saizan> long enough for what?
10:21:36 <bgeron> for earth to be gone?
10:21:45 <nominolo> yeah, something like that
10:21:52 <lament> Saizan: how about Quake III
10:22:08 <Saizan> earth limitness is not a problem for formal logic, no?
10:22:11 <bparkis> lament then why make things more general at all
10:22:22 <bgeron> it isn't, no
10:22:25 <yav> how about a program that prints "Hello world"? :-)
10:22:28 <Jedai> mib_vi5q8d: You can ask hpaste to announce it on the channel... Now you should give us a link
10:22:30 <bparkis> if untyped lambda calculus is already fully general why do you need type systems
10:22:32 <glguy> coq can't express any non-terminating program, right?
10:22:58 <glguy> bparkis: like I said, type systems are there to eliminate bad programs
10:23:04 <mrd> glguy: coinductively
10:23:07 <nominolo> it can express corecursive programs
10:23:11 <Saizan> it could express non-terminating productive programs
10:23:12 <bparkis> and why do you need other logics if ZFC is already capable of expressing everything
10:23:16 <roconnor> glguy: coq can express non-terminating programs indirectly, but it cannot compute them internally.
10:23:31 <lament> bparkis: why do you need other programming languages if you can write everything in assembly?
10:24:01 <bparkis> lament: is that really the relationship between ZFC and other logics, just convenience?
10:24:35 <lament> bparkis: yes. ZFC seems to closely match our intuitive ideas about sets. Also, historical reasons.
10:25:03 <Saizan> bparkis: typed lambda calculus was introduced because untyped is not strong normalizing i.e. untyped lc is too general
10:25:21 <lament> there's nothing magical in ZFC, certainly
10:25:35 <bparkis> what is wrong with something not being strongly normalizing
10:25:44 <Jedai> bparkis: Yes, ever tried to prove things in propositional minimal logic ?
10:26:24 <roconnor> untyped lambda calculus isn't even weakly normalizing.
10:26:25 <lament> bparkis: consider http://en.wikipedia.org/wiki/Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory
10:26:26 <bparkis> isn't the ability to express a nonterminating program an important part of Turing completeness?
10:26:33 <Saizan> bparkis: that you can prove the false, afaiu
10:26:45 <EvilTerran> (\x . x x) (\x . x x)
10:26:53 <gbacon> I'm chaining together multiple arrows that each depend on the immediately-upstream neighbor, but the code seems to rub against the grain and suggests that there ought to be a better way
10:27:01 <mrd> untyped LC is simply typed LC with a single type
10:27:12 <EvilTerran> mrd, um... don't think so
10:27:19 <mrd> try it, it works :)
10:27:30 <EvilTerran> (\x . x x) (\x . x x) is not typeable in simply-typed LC
10:27:35 <gbacon> (a1 $< (a2 $< ($a3 $< a4)))
10:27:39 <mrd> it is if you don't have function types and everything is of one type
10:27:47 <Jedai> mrd: And a rule that says any term is of this type, no ?
10:27:49 <mrd> |- t : T
10:27:55 <mrd> ya
10:27:58 <EvilTerran> well, that's not what most people mean when they say "simply-typed", now, is it?
10:28:11 <mrd> that's why i qualified it with "a single type"
10:28:15 <gbacon> and each arrow finishes with some variant of >>> pure ((,...,) arg1 arg2 ...)
10:28:25 * Jedai thinks mrd is poking fun at us
10:28:27 <EvilTerran> i think you've gotta have the function type before you're allowed to call it simply typed
10:28:53 <EvilTerran> "he simply typed lambda calculus (\lambda^\to) is a typed lambda calculus whose only connective is \to (function type)."
10:29:02 <mrd> well, it's the same fun that harper pokes at his readers in his pl book, so ehe
10:29:04 <EvilTerran> nyah. :P
10:29:04 <lament> of coq, isabelle, agda, epigram, which is more fun to play with?
10:29:28 <gbacon> is there a more natural way to structure this computation?
10:29:39 <mrd> coq or isabelle are the most complete and well supported, i imagine
10:29:47 <bparkis> are there any logical systems as powerful as coq or agda, but that are intended to write actual programs?
10:30:10 <Jedai> bparkis: Epigram2 (but it don't exists yet)
10:31:23 <Jedai> bparkis: There's still plenty of problem to make dependent type in a generally usable form... :(
10:32:16 <Peaker> speaking of Turing completeness: http://rendell-attic.org/gol/tm.htm
10:32:26 <Jedai> Hmmm... That wasn't even a correct english sentence. ^^
10:32:39 <Jedai> s/make/get/
10:33:09 <Peaker> that guy implemented a Turing Machine in game of life, that's _insane_
10:33:19 <bparkis> what problems jedai
10:35:16 <dons> darcs 2.0 released
10:35:50 <glguy> I guess they are trying to beat git on version numbers instead!
10:35:59 <MarcWeber> Anyone used HSQL? Is there a small library providing getRow functions for type (,) (,,) (,,,) etc ?
10:36:06 <yav> bparkis: i believe some things that people are working on are: type inference, erasing proof objects, working with effects
10:36:50 <bparkis> I don't know what the latter two of those mean but you could let the human do type inference
10:36:54 <bparkis> it's just a convenience
10:37:36 <yav> sure, but high level programming languages are all about convenience
10:37:49 * dons smacks glguy 
10:37:53 <Peaker> yav, I wouldn't say that :)
10:37:58 <Botje> ooh, a smackfest
10:37:59 <yav> erasing proof objects is about figuring out which bits need to be represented at runtime
10:38:01 <Botje> can I join?
10:38:03 <Jedai> bparkis: working with effects is pretty important, and erasing proof object is pretty significant too...
10:38:16 * glguy remembers redhat reverting to competition by version number
10:38:24 <yav> working with effects is about doing IO, mutable state etc
10:38:33 <bparkis> ok
10:38:35 <Jedai> darcs 2.0 yay !
10:38:44 * Botje pokes google
10:38:46 <bparkis> the Haskell way of doing IO isn't enough for a more general system?
10:38:49 <Botje> TRACK RELEASES FASTAR!
10:39:35 <Jedai> bparkis: You get a problem when value can give types and those value aren't available at compile time
10:40:07 <yav> bparkis: i think that encapsulating effects is the right way to do it, but you have to work out the detail (e.g., typechecking the program should not depend on arbitrary IO actions)
10:41:28 <bparkis> if I wanted to write a toy compiler or interpreter for a really general typed lambda calculus, is there a book I should read?
10:42:03 <dons> barendreght?
10:42:08 <dons> hmm, SICP?
10:42:13 <dons> or both :)
10:42:14 <Jedai> bparkis: You already read TAPL ?
10:42:32 <bparkis> no
10:42:44 <mib_vi5q8d> http://hpaste.org/6897?lines=true
10:42:57 <Jedai> I know Pierce did a more advanced book but I don't really know what it speaks of
10:43:07 <mib_vi5q8d> the link for my replace function
10:43:24 <Botje> mib_vi5q8d: okay. do you know about the "elem" function?
10:43:37 <bparkis> there's no "compilers for dependently typed languages" book similar to the dragon book?
10:43:37 <mib_vi5q8d> yes
10:43:52 <yav> bparkis: here is a paper that you might want to start with: http://www.cs.nott.ac.uk/~wss/Publications/Tutorial.pdf
10:43:54 <Botje> good. how about isPrefixOf ?
10:44:21 <bparkis> great i'll look at that thanks
10:44:47 <mib_vi5q8d> nope
10:45:01 <Jedai> :t isPrefixOf
10:45:02 <Cheiron> forall a. (Eq a) => [a] -> [a] -> Bool
10:45:13 <Botje> also [SOMETHING] ++ ELSE is the same as SOMETHING : ELSE
10:45:15 <Jedai> Do exactly what's his name says
10:45:41 <Botje> you might also want to look at splitAt
10:45:59 <gbacon> > pure ((,) 1) $< constA 2
10:46:00 <Cheiron>   Not in scope: `constA'
10:46:48 <sethk> :t Data.Set.fromList t
10:46:49 <Cheiron> Not in scope: `t'
10:46:52 <sethk> :t Data.Set.fromList t
10:46:52 <Cheiron> Not in scope: `t'
10:46:53 <sethk> :t Data.Set.fromList
10:46:54 <Cheiron> forall a. (Ord a) => [a] -> Data.Set.Set a
10:49:56 <lament> (from wikipedia) "In the latest processors from AMD, Intel, and others, automated theorem proving has been used to verify that division and other operations are correct."
10:50:04 <lament> do they use their own internal tools?
10:50:54 <gwern> oh, wow
10:50:58 <gwern> darcs 2.0 just got released?
10:51:12 <mib_vi5q8d> the isPrefixOf doesn't work the way i want it to
10:51:23 <mib_vi5q8d> i want to check the char b4 the word i want to find
10:51:31 <mauke> what happened to hackage? :(
10:51:39 <Jaak> wow, rly. finally?
10:51:43 * gwern reads the announcement. but how long 'til the gentoo overlay picks it up?
10:51:54 <bparkis> hey if I want to do grad school about dependently typed programming languages, should I be looking at computer science or at logic departments?
10:51:55 <Botje> mib_vi5q8d: your code suggests the char afterthat word
10:52:02 <Jaak> ask @ #gentoo-haskell :P
10:52:11 * gwern shall
10:52:24 <Jaak> or haskell-gentoo... or whichever was it
10:52:51 <Jedai> mib_vi5q8d: It would be much more easy to split your string in a word,non-word list
10:52:51 <gwern> no, it's a channel for gentoo, not haskell, for you were right the first time
10:52:53 <mib_vi5q8d> yeah i know, i also want to check b4 too
10:52:57 <Jedai> and then change the words that correspond
10:53:05 <nomeata> the darcs announcement does not sound too happy...
10:53:17 <shepheb> is darcs 2 (on both ends) running a darcs 1 repo still a win? (ie. things like all-at-once darcs get)
10:54:04 <mib_vi5q8d> suppose i have replace "sets" "bets" i asets.", i suppose to check infront of the sets, if a char is present return a false
10:55:23 <Jedai> mib_vi5q8d: Yeah I understand, now looks at my proposition
10:55:44 <paczesiowa> @seen dcoutts
10:55:45 <Cheiron> I haven't seen dcoutts.
10:56:41 <nomeata> shepheb: I think things like lazy repositories still work.
10:57:38 <Jedai> mib_vi5q8d: You start by breaking, let's say "##hello;;world" into ["##", "hello", ";;", "world"], then you do your replacements (and you see that is much easier) and you concat the result
10:58:09 <Jedai> mib_vi5q8d: That would take care of your problem, wouldn't it ?
10:58:52 <mib_vi5q8d> i don't want it like that
10:58:57 <Jedai> mib_vi5q8d: Of course, you could also use Text.Regex.PCRE and it's builtin... Why do you want to do that anyway ?
10:59:04 <dons> Cale, no bot?
10:59:26 <JaffaCake> hackage will be down for a little bit, we're currently trying to find out why it keeps falling over
10:59:37 <mib_vi5q8d> if i haves ssets and i want sets replace it wouldn't because there is a char b4 it
10:59:45 <lament> wow, the darc 2.0 announcement is unhappy indeed
11:00:03 <Jedai> mib_vi5q8d: Wasn't it what you wanted ?
11:00:05 <lament> darcs 2.0 announcement summarized by the author: "I recommend
11:00:05 <lament> considering either switching to a different revision control system, or
11:00:08 <lament> helping us to improve darcs.  The former is certainly the easier path."
11:00:13 <dons> darcs 1.0 came out in 2004, and the golden age was 2003-5, imo.
11:00:54 <gwern> it's interesting to read some of the interwiki links to [[darcs]]. like http://pl.wikipedia.org/wiki/Darcs <-- it looks like a man page or something
11:01:02 <Peaker> darcs is not doing very well?
11:01:05 <Jedai> lament: Really ? That's sad !
11:01:21 <dons> well, its running out of steam
11:01:28 <lament> Jedai: well, that's not really a summary, but it is a direct quote :)
11:01:29 <Peaker> how come?
11:01:43 <gwern> (I tried to help out with darcs once; but man was that some tangled messy code. Iwonder if things have improved since?)
11:02:00 <dons> 6 years, too much competition, not enough developers, complacency on our part
11:02:12 <roconnor> [citation needed]
11:02:20 <lament> i would imagine not enough developers to be the main problem
11:02:50 <dons> i don't think that's a general issue -- xmonad for example has too many, more that people were slowly leached away, or it was "good enough"
11:02:53 <Peaker> how many developers do the competitors have?  Bzr? git? etc?
11:02:57 <dons> there are some barriers to darcs contribution too
11:03:00 <Jedai> mib_vi5q8d: Let me get this straight : replace "assets" "sets" "bets" should evaluate to "assets", right ? not "asbets" ?
11:03:08 <lament> dons: like the fact that it's written in Haskell!
11:03:27 <dons> lament: i don't think that's a serious issue though -- xmonad has far more developers than similar projects
11:03:49 <dons> its more that the people slowly stopped working on it
11:03:52 <lament> dons: writing a WM is much more glorious
11:04:07 <dons> possibly if more aggressive action was taken early on to ensure it was easy to collaborate
11:04:22 <dons> lament: i think people forget what it was like to work on darcs 2003-2005
11:04:33 <dons> linus torvalds was on the darcs list then, git was but a dream
11:04:34 <nomeata> lament: tell us, how was it? :-)
11:04:36 <gwern> they forgot to optimize with -Ofun eh...
11:04:39 <dons> there was little serious competition
11:04:48 <Peaker> isn't xmonad about 500 lines of code or so? :)
11:05:01 <dons> Peaker: 500 lines, and 70 contributors
11:05:06 <dons> ;)
11:05:15 <Peaker> something that small is sure to be easy to develop for :)
11:05:17 <mauke> 1200
11:05:18 <nomeata> dons: but the darcs theory and the language werent easier back then, were they?
11:05:25 <Peaker> how large is darcs?
11:05:38 <yav> dons: so that about 8 lines per contributor :-)
11:05:48 <dons> yav, something like that :)
11:06:01 <lament> is xmonad actually 500 lines?
11:06:06 <paczesiowa> that number includes newlines and comments?
11:06:08 <dons> no.
11:06:09 <Jedai> Peaker: xmonad is 1000 lines of code (and 1000 lines of comments) in the core, 7000 LOC in the contrib is the last I heard ?
11:06:14 <roconnor> http://lists.osuosl.org/pipermail/darcs-devel/2008-April/007778.html
11:06:52 <Peaker> Jedai, ah. that's also tiny. how large is darcs?
11:07:16 <Igloo> dons: What do you mean, re barriers?
11:07:36 * Igloo doesn't think Linux was ever actually on the list
11:07:37 <Jedai> Peaker: Still consider that it's a complete WM (very complete now) in that amount of LOC :P
11:07:43 <Igloo> Gah, Linus. Silly fingers.
11:08:15 <Deewiant> Igloo: google finds at least one post of his on darcs-devel
11:08:20 <lament> 1000 loc for WM sounds like it could potentially be used by the reinventing computing project
11:08:30 <ExplicitCall> Jedai, not, it still lacks correct ICCCM implementation, and that's the reason I'm still on wmii but not on darcs.
11:08:31 <lament> of course, they'd need a haskell compiler in another 1000 loc
11:08:36 <Igloo> Deewiant: He was CCed on a thread
11:08:44 <Deewiant> ah
11:09:06 <nomeata> ExplicitCall: what are you missing exactly?
11:09:09 <ExplicitCall> Jedai, i mean, not on xmonad, lol
11:09:26 <dons> ExplicitCall: ?
11:09:27 <Jedai> ICCCM ?
11:09:33 <dons> ExplicitCall: what part of ICCCM is missing?
11:09:43 <ExplicitCall> http://tronche.com/gui/x/icccm/
11:10:00 <dons> ExplicitCall: are you looking for an announcement of ICCCM compliance? or is there something particular?
11:10:05 <ExplicitCall> dons, don't know exactly but there's something that prevents xxkb working in right way.
11:10:09 <Jedai> ExplicitCall: I have it now
11:10:13 <dons> xxkb eh?
11:10:31 <dons> ExplicitCall: did you file a bug report?
11:10:37 <ExplicitCall> dons, that's a keyboard switcher that preserves keyboard mapping separately for each window.
11:10:40 <Peaker> Linus Torvalds didn't make a great impression on me in his google tech talk
11:11:17 <dons> ExplicitCall: I think we're quite close to ICCCM, so could you file a report about the problem, and how to reproduce it, http://code.google.com/p/xmonad/issues/list
11:11:30 <dons> so we can investigate what the problem is.
11:11:33 <ExplicitCall> dons, uh, not yet.  last time I thought it was easier to hack xxkb and then I totally forgot about it
11:11:44 <dons> have you tried with 0.7?
11:11:52 <dons> also, xxkb might be using EWMH ?
11:12:30 <dons> ExplicitCall: could you make some report about the bug please?
11:12:55 <ExplicitCall> dons, don't think it has any ewmh support code.  Also it's a C program that has few K lines of code, somewhat obscure to find the exact reason.
11:13:37 <ExplicitCall> dons, I'll report a bug tomorrow or a day after tomorrow, still have some reports for GSoC to work on :)
11:13:51 <dons> ExplicitCall: just need the bug report, we can then look at what its trying to do
11:14:04 <paczesiowa> does hs-plugins app embed ghc inside resulting binary?
11:14:13 <thorkilnaur> Peaker, In a darcs repository of darcs from August 2007, wc -l `find src -name '*hs'` concludes "30347 total"
11:14:21 <ExplicitCall> dons, the main thing I discovered is that xxkb catches the change of window focus in wmii, fvwm but not in xmonad
11:14:40 <Peaker> thorkilnaur, 30K lines is pretty large, if the language is Haskell
11:14:57 <dons> yeah, git's 80k or so
11:15:35 <lament> managing different keyboard layouts is always a pain
11:15:39 <ExplicitCall> dons, here's the project page for xxkb, if you're interested http://sourceforge.net/projects/xxkb
11:16:00 <dons> so all i need is how to reproduce the  issue :)
11:16:12 <Peaker> dons, I'd expect more than a 1<->2.5 between Haskell<->C though
11:17:13 <dons> yeah, that ratio would indicate significant differences in what's been implemented
11:17:16 <nomeata> ExplicitCall: sounds like it might rely on EWMH, guessing without looking at the code.
11:17:50 <dons> ExplicitCall: i'd try enabling the EWMH module in your config
11:18:10 <lament> ideally the ratio should increase as code size increases
11:18:22 <Peaker> So supposedly, darcs has many more features than git?
11:18:35 <ExplicitCall> dons, just start the xxkb in xmonad, change the xkb group, switch to other window and the group is preserved.  that isn't a supposed behaviour and that doesn't happen on several other WMs I used (wmii and fwvm to be exactly).  Yes, I'll try EWMH next time, thanks for advice
11:18:38 <dons> i like to note that ion3 is 21k lines of C in comparison to xmonad :)
11:18:39 <lament> 1 haskell line = 1 c line, but 10 haskell lines = 100 c lines and 100 haskell lines are 10000 c lines :)
11:18:48 <nomeata> Peaker: maybe the user interface takes up a lot of lines
11:19:21 <Peaker> lament, in theory, that doesn't work, because at worst, you implement Haskell in C, and get that as line-count overhead in your C side :)
11:21:06 <dons> ExplicitCall: http://code.google.com/p/xmonad/issues/detail?id=171
11:21:09 <kilimanjaro> I don't really understand the fascination with LOC, programmers don't "spend lines", they spend time
11:21:10 <dons> add more details if you can
11:21:38 <dons> kilimanjaro: one small detail: if your functions are 10x shorter, you can hold more of the program in your head at one time
11:21:48 <gwern> kilimanjaro: it's a pretty robust result that bugs per LoC is a constant for a particular language
11:21:49 * Peaker is used to the eye candy of compiz :)
11:21:49 <dons> making global transformations, and recognising broad patterns, easier
11:21:55 <kilimanjaro> dons, I agree, but not 10x more
11:21:57 <gwern> *as robust as that sort of thing gets anyway...
11:22:00 <glguy> kilimanjaro: also, line numbers are easy to measure concretely, so it gives people something to talk about
11:22:38 <Peaker> maybe a "token count" would be slightly better than a "line count", though
11:22:57 <kilimanjaro> I liked the study where they compared haskell to other languages and timed how long it took to implement stuff, that yielded some pretty meaningful results. I've never seen any study on bugs / LOC though
11:23:12 <lament> Serious Nethack players try to finish their games as quickly as possible. Because the more time you spend in the dungeon, the more likely you are to die.
11:23:24 <Peaker> fewer lines also implies more DRY compliance - which definitely correlates to less bugs
11:23:36 <Peaker> (DRY violations are probably a primary source of bugs)
11:23:41 <kilimanjaro> what is DRY?
11:23:51 <Peaker> Its the "Dont repeat yourself" principle
11:23:54 <gwern> kilimanjaro: don't repeat yourself
11:24:10 <laura85> g evening ^^
11:24:11 <glguy> by using an acronym only ruby programmers repeat, you've had to repeat yourself!
11:25:01 <lament> DRY. DRY. DRY. DRY. DRY.
11:25:11 <lament> everybody repeat after me: DRY.
11:25:18 <glguy> hypocrite!
11:25:18 <Peaker> kilimanjaro, each "concept" should be represented in only one place in the program.  It should not manifest itself in multiple places.  Its similar to another principle: that pieces of code should not be coupled to each other.  A DRY violation typically means that if you fix one manifestation of some concept, and forget to fix the other ones, you have a bug
11:25:24 <kilimanjaro> I think the type system plays a bigger role than terseness in reducing bugs, but that's also just speculation
11:25:53 <Peaker> kilimanjaro, A strong type system probably helps a lot in catching DRY violation bugs
11:26:17 <bos> they're both important.
11:26:21 <laura85> does the haskell summer of code link work for you?
11:26:22 <lament> type system won't mind if you have the same code copy-pasted five times
11:26:34 <gwern> Peaker: true. you can get a lot of mileage just looking at a list of type sigs and seeing which functions are only differing in a few places, concretely
11:26:40 <kilimanjaro> Peaker, are you selling a book? This is the first time I have heard of DRY and you've used it 6 times in the past 4 minutes :)
11:26:55 <ExplicitCall> laura85, hackage is still down
11:27:02 <Peaker> kilimanjaro, I re-used it to explain what it is :)
11:27:09 <laura85> ExplicitCall, oh ok
11:27:16 <kilimanjaro> Peaker, don't worry, I was more teasing than anything
11:27:22 <ExplicitCall> laura85, <JaffaCake> hackage will be down for a little bit, we're currently trying to find out why it keeps falling over
11:27:50 <laura85> good luck ^^
11:28:04 <gwern> ExplicitCall: perhaps they should stick some books under it. works for my shelves
11:28:10 <Jedai> kilimanjaro: DRY is a pretty well spread buzz-word nowaday (and it's a good one for once !)
11:29:27 <nomeata> Jedai: because it cant be used repeatedly without making the buzzword-user look funny?
11:29:45 <glguy> If you prop your shelf up with a stack of books, what you have is a table ;)
11:29:51 <kilimanjaro> I agree completely with the philosophy, that's part of what brought me to Scheme (and so by extension, Haskell)
11:30:06 <Vulpyne> It's weird that there's no generic split function to break lists on a delimiter, but there are functions that break lines and words.
11:30:27 <sjanssen> ExplicitCall: about your xmonad bug, have you tried the Ewmh extension?
11:31:03 <Jedai> nomeata: Why would it be funny to repeat DRY, I mean even if you repeat DRY, it stay true, it's not like you're repeating yourself, just the buzz
11:31:18 <ExplicitCall> sjanssen, not yet, maybe after few hours, too busy now
11:31:36 <Jedai> Vulpyne: Nobody agreed to how this function should work...
11:31:42 <paczesiowa> repeating DRY is metarepeating
11:31:55 <gwern> hm. darcs-2 is faster - I remember pulling the darcs repo as being slower
11:32:03 <Vulpyne> jedai: Same as in pretty much all other programming languages? :)
11:32:20 <sjanssen> ExplicitCall: please let us know whether it works or not
11:32:50 <Jedai> Vulpyne: Haskell guys don't like blurry semantics or "do everything" functions (like split in Perl, you know...)
11:32:56 <sjanssen> ExplicitCall: btw, #xmonad is a good place to do that, because the conversations tend to scroll by much more slowly :)
11:33:08 <Jedai> Vulpyne: they want pretty properties
11:33:08 <Peaker> dons, why is fpstring.c needed in ByteString? surely a trivial max() implementation on a char array can be optimized into that straightforward C code from Haskell?
11:33:19 <dons> Peaker: possibly. why do you ask?
11:33:19 <gwern> oh noes, #xmonad is the new #haskell-blah
11:33:35 <Vulpyne> split :: Eq a => (a -> Bool) -> [a] -> [[a]] seems like what people would expect, given the existance of break.
11:33:37 <Peaker> dons, I'm looking at ByteString as an example of a pure data structure with internal imperative state
11:33:42 <Peaker> dons, pure interface, that is
11:33:45 <tromp> @src inits
11:33:46 <Cheiron> inits []     =  [[]]
11:33:46 <Cheiron> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
11:33:59 <Jedai> Vulpyne: Yeah, and what does it do ?
11:34:00 <Vulpyne> Well, maybe without the typeclass part.
11:34:15 <tromp> hmm, inits is still unnecessarily strict
11:34:16 <dons> Peaker: ok. when i was using ghc 6.2 it was worth it, but more and more calling out to C is not worth it
11:34:48 <Peaker> dons, ok I was just wondering, thanks
11:34:50 <paczesiowa> split should work like, words = split ' ', lines = split '\n;
11:35:02 <Vulpyne> Jedai: I would expect it to break at each delimiter. split (==' ') "hello there  test" == ["hello","there", "","test"]
11:35:22 <mauke> paczesiowa: words and lines use different split functions
11:35:22 <Deewiant> an alternate version would also keep the delimiters
11:35:27 <dcoutts> lemmih__: ping
11:35:34 <dcoutts> @seen lemmih__
11:35:35 <Cheiron> lemmih__ is in #haskell. I don't know when lemmih__ last spoke.
11:35:39 <Jedai> Vulpyne: And already you see the problem, you don't have the equivalent of words
11:35:48 <paczesiowa> > words "qwet tyu io gh"
11:35:49 <Cheiron>  ["qwet","tyu","io","gh"]
11:35:54 <paczesiowa> > lines "qwet tyu io gh"
11:35:55 <Cheiron>  ["qwet tyu io gh"]
11:36:02 <Deewiant> > words "qwet tyu io    gh"
11:36:03 <Cheiron>  ["qwet","tyu","io","gh"]
11:36:03 <Vulpyne> Jedai: But words can be built very easily in terms of split.
11:36:04 <paczesiowa> > lines "qwet tyu io gh\ngh yui bn yu"
11:36:04 <Cheiron>  ["qwet tyu io gh","gh yui bn yu"]
11:36:46 <gwern> 'I have a hunch that the best big programs begin life this way, rather than being designed big from the start, like the Hoover Dam. It's terrifying to build something big from scratch. When people take on a project that's too big, they become overwhelmed. The project either gets bogged down, or the result is sterile and wooden: a shopping mall rather than a real downtown, Brasilia rather than Rome, Ada rather than C.' <-- perhaps darcs is too big
11:36:47 <Syzygy-> @check \t ->  unwords . words $ t == t
11:36:48 <Cheiron>  quickcheck: setResourceLimit: invalid argument (Invalid argument)
11:36:56 <Lemmih> dcoutts_: Hi.
11:37:01 <Deewiant> @check \t -> unwords (words t) == t
11:37:01 <Cheiron>  quickcheck: setResourceLimit: invalid argument (Invalid argument)
11:37:07 <Jedai> Vulpyne: Well I don't know, personally I wouldn't have put htis empty field in the list
11:37:14 <Syzygy-> @check \t ->  (unwords . words $ t) == t :: [Char]
11:37:14 <Cheiron>  quickcheck: setResourceLimit: invalid argument (Invalid argument)
11:37:20 <Syzygy-> @check \t ->  (unwords . words $ t) == (t :: [Char])
11:37:20 <Cheiron>  fd:13: hClose: resource vanished (Broken pipe)
11:37:23 <Deewiant> @check \x -> x == x
11:37:23 <Vulpyne> It would fail though because words collapses multiple spaces.
11:37:23 <Cheiron>  fd:13: hClose: resource vanished (Broken pipe)
11:37:39 <Syzygy-> Vulpyne: I know  it would. I wanted to see quickcheck's take on it.
11:37:40 <Cale> hmm
11:37:41 <sebell> Syzygy-: You broke it :(
11:37:47 <Vulpyne> Jedai: That's different from the split-alike function in any other language I'm familiar with.
11:37:49 <Cale> Did lambdabot disappear?
11:37:49 <Syzygy-> sebell: Obviously.
11:37:59 <Peaker> hmm, does ghc support C preprocessing directives?  #ifndef/etc?
11:38:00 <Deewiant> Cale: about 7 hours back, yes
11:38:02 <Syzygy-> no lambdabot in here.
11:38:06 <yitz> hi Cale, we've been waiting for you :)
11:38:13 <Vulpyne> Peaker: Think there's a special compile flag to run through CPP.
11:38:15 <Cale> strange
11:38:22 <Jedai> Vulpyne: Most split-alike split on string, not on character
11:38:24 <Cale> My screen session was killed.
11:38:27 <Vulpyne> It's -cpp
11:38:32 <Peaker> Vulpyne, ah, thanks
11:38:32 <Jedai> Vulpyne: like your proposition
11:38:33 <dejones> Cale: did you kill the lambdabot?
11:38:36 <Cale> no
11:38:43 <Cale> But something did.
11:38:44 <EvilTerran> ?bot!
11:38:44 <Cheiron> Missing argument. Check @help <vote-cmd> for info.
11:38:45 <Deewiant> @check \t -> unwords (words t) == t
11:38:45 <Cheiron>  quickcheck: setResourceLimit: invalid argument (Invalid argument)
11:38:51 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
11:38:59 <gwern> I've been wondering something about list syntax; so commas seperate items from each other, but are they redundant with spaces?
11:39:05 <lambdabot> Plugin `check' failed with: thread killed
11:39:17 <Vulpyne> Jedai: That's true, but given two consecutive delimiters whether they're single character or more, they'd add a blank item.
11:39:19 <Cale> Oh, it seems code.h.o is acting up again
11:39:25 <gwern> ie, isn't [1 2 3 4] just as good as [1, 2, 3, 4]?
11:39:29 <Syzygy-> unwords . words $ "abc def ghi  jhl"
11:39:30 <glguy> gwern: [ f x ]
11:39:31 <Peaker> its kinda funny to see an .hs file use #define's and stuff
11:39:36 <Syzygy-> > unwords . words $ "abc def ghi  jhl"
11:39:37 <Cheiron>  "abc def ghi jhl"
11:39:39 <sjanssen> ooh, darcs 2.0.0
11:39:40 <Peaker> And using the C preprocessor strictness macros
11:39:43 <lambdabot>  "abc def ghi jhl"
11:39:47 <Cale> gwern: Function application.
11:39:50 <glguy> gwern: and number literals can be functions
11:39:53 <yitz> Cale: yes, people have been complaining about other services there also
11:39:55 <Syzygy-> Majestic stereo, anyone?
11:40:03 <Jedai> Vulpyne: Yes
11:40:05 <sjanssen> darcs++
11:40:23 <glguy> darcs looks like it's in legacy mode now
11:40:24 <gwern> glguy: oh. I forgot those didn't have to be in parens :)
11:40:40 <tromp> @let myinits l = [] : case l of [] -> []; (x:xs) -> map (x:) (myinits xs)
11:40:41 <Cheiron> Defined.
11:40:49 <lambdabot> Defined.
11:40:52 <tromp> > myinits "hi"
11:40:52 <Cheiron>  ["","h","hi"]
11:40:57 <lambdabot>  ["","h","hi"]
11:41:02 <Jedai> Vulpyne: But you don't want those blank items, so you get a split working on regexps to allow for flexibility in the length of the delimiter and ...
11:41:16 <tromp> > let bla = map length (myinits bla) in bla
11:41:17 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
11:41:17 <Cheiron>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
11:41:22 <yitz> msg Cheiron thanks! you can go now.
11:41:26 <tromp> > let bla = map length (inits bla) in bla
11:41:26 <lambdabot>  Exception: <<loop>>
11:41:27 <Cheiron>  Exception: <<loop>>
11:41:45 --- mode: ChanServ set +o glguy
11:41:48 --- kick: Cheiron was kicked by glguy (glguy)
11:41:52 <glguy> (nothing personal)
11:41:53 <Vulpyne> jedai: Don't think I completely understood that.
11:41:55 --- mode: glguy set -o glguy
11:41:57 <EvilTerran> tromp, good point, that
11:42:34 <EvilTerran> i'd call that a "refinement" and have no complaints to it replacing the standard one in Data.List :P
11:42:38 <Jedai> Vulpyne: I mean, your split isn't the one expected by most others
11:42:51 <tromp> but i dont know how to submit such fixes
11:43:08 <Jedai> Vulpyne: It could be one of several functions that do split-alike work
11:43:23 <Jedai> Vulpyne: But probably not "the split"
11:43:34 <EvilTerran> tromp, i'd give it a thread on the mailing list, see what people think there
11:43:42 <Jedai> Vulpyne: I would really like to see some of these in standard lib though
11:43:43 <Vulpyne> Jedai: Not sure I agree there. :)
11:43:51 <EvilTerran> someone there'll know what to do with it, too
11:43:57 <laura85> lazy evaluation sometimes evaluates the same expression two or more times. now if someone says, it can be 'optimized' by 'seeing' it as a graph instead of a tree, does he/she mean a parsing graph instead of a parsing tree?
11:44:38 <EvilTerran> yes, you can view common subexpression elimination as merging branches of the parse tree to leave a directed graph
11:45:14 <laura85> EvilTerran, and Hugs and GHc do that automatically?
11:45:19 <EvilTerran> no
11:45:24 <EvilTerran> but they could!
11:45:28 <jsnx> lolz
11:45:32 <jsnx> some day...
11:45:46 * jsnx sings something from the Sound of Music
11:45:53 <solrize> ghc does that some, jhc does it more, i think.
11:46:01 <laura85> hm ok
11:46:07 <Peaker> @type inlinePerformIO
11:46:08 <lambdabot> Not in scope: `inlinePerformIO'
11:46:13 <Peaker> what's inlinePerformIO?
11:46:15 <EvilTerran> at the moment, if you want to be sure of it happening, you have to do it manually by binding the common subexpression to a name, then using that name in the two places the expression was originally
11:47:00 <laura85> EvilTerran, ok
11:47:02 <jsnx> e.g. `doubleUp x = (sqr, sqr) where sqr = x * x`
11:47:04 <bos> CSE is often dangerous in lazy code.
11:47:15 <jsnx> bos: why?
11:47:18 <bos> that's why it's not usually done automatically.
11:47:33 <laura85> bos, what's CSE?
11:47:35 <bos> jsnx: it can keep values alive for much longer than they would otherwise be, leading to huge space leaks.
11:47:36 <Jedai> Vulpyne: That's the problem, nobody agrees with me !!! :P
11:47:45 <jsnx> bos: oh, interesting
11:47:47 <bos> common subexpression elimination.
11:48:03 <laura85> bos, like a garbage collector (in Java)?
11:48:06 <bos> CSE is always safe with strict expressions.
11:48:12 <bos> laura85: no.
11:48:19 <bos> it's a source code transformation.
11:48:28 <JaffaCake> bos: true, but that's not why GHC doesn't do it
11:48:36 <jsnx> JaffaCake: oh?
11:48:36 <laura85> bos, cool ^^
11:48:47 <JaffaCake> after all, we do full laziness and that suffers from the same problem
11:49:01 <omg911> @pl (\a b -> compare (fst b) (fst a))
11:49:01 <lambdabot> flip (compare . fst) . fst
11:49:02 <JaffaCake> GHC doesn't do full CSE just because it isn't implemented
11:49:20 <bos> JaffaCake: i was going to get to that bit :-)
11:49:30 <JaffaCake> ah :) sorry
11:49:39 <glguy> *preempt*
11:49:40 <bos> so much to do, so few simons!
11:49:52 <yitz> > (compare `on` fst) (1,5) (7,2)
11:49:52 <lambdabot>  LT
11:49:52 <Deewiant> omg911: compare `on` fst
11:50:03 <Deewiant> although...
11:50:04 <yitz> > (compare `on` snd) (1,5) (7,2)
11:50:04 <lambdabot>  GT
11:50:07 <MyCatVerbs> laura85: like if you have (in C): float foo = (a * b) + (a * b); the compiler can safely optimize that by adding a temporary variable to store the result of (a * b).
11:50:10 <glguy> :t Data.Ord.comparing
11:50:10 <Deewiant> > (compare `on` fst) (1,5) (5,"foo")
11:50:10 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
11:50:11 <lambdabot>   add an instance declaration for (Num [Char])
11:50:11 <lambdabot>     In the expression: 5
11:50:17 <omg911> ooh cool
11:50:22 <glguy> comparing = (compare `on`)
11:50:25 <Deewiant> > (\a b -> compare (fst b) (fst a)) (1,5) (5,"foo")
11:50:27 <lambdabot>  GT
11:50:58 <byorgey> Deewiant: ah, interesting observation.
11:51:03 <bos> i'm very pleased by the recent progress of the C++ standard.  it's gradually eroding the performance advantage of C++ compilers over GHC, without the simons having to do anything.
11:51:12 <laura85> MyCatVerbs, understand
11:51:18 <mauke> hahaha
11:51:26 <yitz> bos: :)
11:51:39 <glguy> @remember bos  i'm very pleased by the recent progress of the C++ standard.  it's gradually eroding the performance advantage of C++ compilers over GHC, without the simons having to do anything.
11:51:39 <lambdabot> I will never forget.
11:51:45 <byorgey> although I'm not sure in what situation you'd ever want to do comparisons with 'on' on heterogeneously typed tuples...
11:51:47 <Japsu> @remem.... too slow :<
11:51:47 <lambdabot> Unknown command, try @list
11:51:52 <Peaker> never is such a strong word
11:51:56 <sjanssen> @flush
11:52:14 <glguy> sjanssen: you wanted "<lambdabot> I will never forget." to mean something?
11:52:15 <Deewiant> byorgey: or comparisons at all. :-)
11:52:21 <sjanssen> Peaker: in fact, lambdabot tends to lose her state frequently, it is almost certainly a lie
11:52:27 <byorgey> Deewiant: right. =)
11:52:44 <Peaker> sjanssen, I see, I will never forget
11:52:52 <glguy> Peaker: @flush
11:52:57 <yitz> sjanssen: it's the thought that counts
11:53:01 <Peaker> bloing
11:53:40 <Peaker> does lambdabot keep a persistent memory?
11:54:02 <MyCatVerbs> bos: the Simons? There are more than one?
11:54:03 <glguy> it flushes to disk
11:54:12 <Jedai> MyCatVerbs: Three
11:54:28 <Jedai> At least ;)
11:54:43 <MyCatVerbs> Jedai: bloody Hell. I didn't realise Haskell had so much going for it.
11:54:45 <mauke> .oO( Peyton, Jones and Marlow )
11:55:03 <bos> lambdabot remembers everything that has ever happened.  when it is unable to retrieve something, that is because it has un-happened.  lambdabot has reached into the past and modified human history.  that bit's a plugin, you see.
11:55:20 <glguy> an experiment in collective STM?
11:55:24 <mrd> @revise history
11:55:24 <lambdabot> Unknown command, try @list
11:55:27 <paczesiowa> thanks to System.IO.Unsafe.unsafeUndoIO
11:55:31 <glguy> @retry
11:55:53 * glguy wonders what command that spell-corrected into
11:56:04 <tromp> @src strict
11:56:04 <lambdabot> Source not found. I am sorry.
11:56:07 <tromp> @src inits
11:56:07 <lambdabot> inits []     =  [[]]
11:56:07 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
11:56:09 <Botje> @swift-retribution?
11:56:09 <lambdabot> Unknown command, try @list
11:56:15 <mrd> unsafeUndoIO :: IO a -- might destroy the fabric of space-time
11:56:23 <glguy> @help retry
11:56:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:56:25 <mauke> IOT Cont a
11:56:34 <lament> :D
11:56:48 <lament> mauke: the universe is probably something fucked up like that, and not IO
11:58:28 <paczesiowa> IOT IO a should be possible
11:58:39 <MyCatVerbs> lament: ListT IOT Cont a -- for the multiple-universes freaks amongst us.
11:59:18 <paczesiowa> TreeT :>
12:00:18 <glguy> MyCatVerbs: ListT has an interesting kind ;)
12:00:31 <MyCatVerbs> @kind ListT
12:00:32 <paczesiowa> :k ListT
12:00:32 <lambdabot> Not in scope: type constructor or class `ListT'
12:00:33 <lambdabot> Not in scope: type constructor or class `ListT'
12:00:48 * bgeron hugs lambdabot 
12:00:55 <glguy> ListT (IOT Cont) a   was all I was harping on :)
12:00:57 <mauke> ((* -> *) -> * -> *) -> (* -> *) -> * -> *
12:01:16 <therp> hm, isn't ListT somehow subsumed by Cont?
12:01:53 <MyCatVerbs> Hang on, ListT does exist, right?
12:02:00 <paczesiowa> MyCatVerbs: yes
12:02:05 <therp> MyCatVerbs:  http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-List.html#t%3AListT
12:02:06 <lambdabot> http://tinyurl.com/6867kh
12:02:13 <MyCatVerbs> therp: ah, thanks. Hadn't spotted that.
12:02:29 <paczesiowa> @google google
12:02:29 <lambdabot> http://www.google.com/
12:02:29 <lambdabot> Title: Google
12:02:33 <therp> MyCatVerbs: you know hoogle?
12:02:41 <paczesiowa> @google ListT done right
12:02:42 <lambdabot> http://www.haskell.org/haskellwiki/ListT_done_right
12:02:42 <lambdabot> Title: ListT done right - HaskellWiki
12:03:41 <MyCatVerbs> therp: yes, indeed. I don't have it hardwired into my brain yet, though.
12:04:47 <ndm> I just read the darcs2 announce
12:05:01 <ndm> reading between the lines, the message I got was "darcs is now abandoned, and still has numerous bugs, have fun"
12:05:43 <ndm> am I way off?
12:05:57 <allbery_b> it can be read that way, yes.
12:06:20 <allbery_b> I'd be a bit dispirited watching everyone moving away form darcs to hg / git too
12:06:42 <Igloo> ndm: You could read it as "Help!"
12:06:54 <Jaak> i don't think darcs 2 accelerates such move
12:07:05 <ndm> Igloo: "Help! We're sinking" ?
12:07:06 <Jaak> it's step forward
12:07:12 * bgeron is a git user, but I discovered I think more in terms of patches than in terms of commits
12:07:21 <Peaker> why not bzr? :)
12:07:42 <ndm> I'm more than happy sticking with darcs, I love it, but if its developers are gone, then I'm probably going to go too
12:08:00 <bgeron> shame :(
12:08:12 <dons> ndm, are you coming to the hackathon?
12:08:20 * Igloo would like to get back into darcs development, especially if the exp merge problem is fixed
12:08:25 <Peaker> What other non-trivial Haskell projects are out there?  are darcs/xmonad the flagships?
12:08:36 <Jaak> ghc
12:08:36 <ndm> dons: no, busy thesis hacking in England - plus no money :(
12:08:40 <bos> there's fibonacci.
12:08:44 <allbery_b> no, it doesn't.  but I've been seeing more and more darcs-based repos switch away, which makes darcs2 kinda redundant
12:08:44 <Jaak> pugs
12:08:45 <bgeron> ;)
12:08:54 <Igloo> And if anyone listening is interesting in sponsoring some darcs development, get in touch  :-)
12:09:10 <dons> what non-trivial ruby or python or lisp projects are there out there?
12:09:14 * ndm doesn't even own a computer anymore...
12:09:21 * dons model of open source: 99% of it is in C.
12:09:23 <bos> Igloo: congrats on establishing the consultancy
12:09:29 <bgeron> Perl 6 runs on Parrot now, so I wonder how long Pugs will last :(
12:09:32 <ndm> Peaker: xmonad i'd say is the flagship, darcs has always had a lot smaller contributor base
12:09:36 <glguy> dons: is Haskell in the same category as ruby and python amongst programming languages?
12:09:55 <bos> haskell's about an order of magnitude, perhaps two, behind
12:10:00 <ndm> Igloo: yeah, congrats on the company, hope you are millionaires in no time :)
12:10:04 * bgeron wonders what recent Lisp projects exist
12:10:09 <Igloo> bos, ndm: Thanks  :-)
12:10:10 <gbacon> bgeron: pugs has been dead in the water for a while
12:10:26 <gbacon> bgeron: it's at least building again, but there are internal issues
12:10:28 <Peaker> dons, Python has bittorrent (at least had it till a while ago), a lot of Google, some interesting websites, Ubuntu, NASA, ...
12:10:37 <luqui> it was highly correlated with audreyt's disappearance
12:10:49 <MyCatVerbs> dons: what? 99% in C? Er, what about Perl?
12:10:58 <bgeron> Python is the new Perl, if you ask me
12:11:34 <dons> MyCatVerbs: do you use any non-trivial perl programs?
12:11:40 <Peaker> Places I worked at used Python extensively for testing and scripting C-built systems
12:11:41 <ndm> dons: GHC
12:11:41 * luqui used to use svk
12:11:45 <Igloo> ndm: Do you mention flagshipness by devels, or users?
12:11:47 <ndm> (evil-mangler)
12:11:48 <dons> any system utilities, window managers, revision control systems?
12:11:55 <Igloo> darcs wins on the latter according to http://people.debian.org/~igloo/popcon-graphs/index.php?packages=darcs%2Cxmonad&show_installed=on&want_legend=on&want_ticks=on&from_date=&to_date=&hlght_date=&date_fmt=%25Y-%25m&beenhere=1
12:11:56 <lambdabot> Title: popcon graph, http://tinyurl.com/68pcgt
12:12:07 <Peaker> dons, there's also bzr/hg, but I don't know how popular they are
12:12:11 <bos> mercurial is written in python, as is buildbot.
12:12:19 <Peaker> also trac
12:12:21 <ndm> Igloo: by programs, and their impact on the wider community, and their exposure of the language
12:12:37 <luqui> gentoo portage...
12:12:41 <MyCatVerbs> dons: Bugzilla is a pretty famous one. A *lot* of large websites are written in Perl.
12:12:43 <ndm> i'd say darcs is a great project, but XMonad leads in terms of Haskell evangalism, rather than just a Haskell app
12:12:50 <Peaker> MyCatVerbs, Bugzilla is still popular?
12:13:02 <EvilTerran> Peaker, bugzilla was ever popular?
12:13:04 <MyCatVerbs> Peaker: it was at one point, and it fits the "large" requirement.
12:13:05 <bos> yes, bugzilla is still widely used.
12:13:11 <MyCatVerbs> dons: also, um... GHC?
12:13:17 <roconnor> Isn't XMonad a lot smaller than darcs?
12:13:21 <MyCatVerbs> dons: y'know, the mangler and all that.
12:13:23 <Jedai> Peaker: Bittorrent ? There's much better bittorent client out there, not in Python
12:13:32 <dons> MyCatVerbs: not used by default
12:13:40 <Peaker> Jedai, Yeah, its just the first thing that came to mind - and the original one was in Python
12:13:43 <allbery_b> pugs hs served its purpose, and has been supplanted by other implementations
12:13:43 <dons> and the mangler's not an open source project.
12:14:13 <MyCatVerbs> dons: isn't it? That's news to me.
12:14:21 <dons> anyway, the point is that in open source, the 'killer app for the language' idea is bogus -- pretty much every app we install is C.
12:14:22 <allbery_b> unfortunately it would need significant redesign in order to continue being useful
12:14:23 <MyCatVerbs> dons: when did that change come about, please?
12:14:33 <dons> MyCatVerbs: 6.6, -fasm is the default. no mangler
12:14:43 <Jedai> Peaker: I would say the prototype was written in Python, but it wasn't a project dependent on language features, contrary to XMonad for exemple
12:14:52 <MyCatVerbs> dons: I take it the mangler is only necessary when compiling via C?
12:15:00 <dons> i've no ruby, or lisp, or ocaml, or java, or C# system tools.
12:15:07 <Peaker> Jedai, why/how is XMonad dependent on language features?
12:15:11 <dons> so they're clearly not ready for prime time :)
12:15:22 <yitz> dons: mailman in python
12:15:27 <MyCatVerbs> Peaker: well, there's the X monad that it introduces, for starters... ;)
12:15:34 <Peaker> dons, If you run Ubuntu, a big portion of your system is written in Python though :)
12:15:35 <allbery_b> MyCatVerbs: the mangler rewrites gcc output to make some things work better (tail call oiptimization, for one)
12:15:46 <yitz> zope
12:15:49 <Peaker> MyCatVerbs, does a user get exposed to it though?
12:15:59 <allbery_b> when ghc generates the code itself it doesn't need to be fixed afterward
12:15:59 <ndm> dons: part of that is GNU providing most of the system utils, and having rather "backward" issues to language choice
12:16:09 <yitz> 4suite (or whatever it's called now)
12:16:55 <MyCatVerbs> allbery_b: gcc's -foptimize-sibling-calls doesn't suffice?
12:17:18 * allbery_b notes that for a long time updatiung freebsd systems involved a program written in modula 3 (cvsup).  this didn't exactly make modula3 a popular language
12:17:23 <Jedai> Peaker: Writing it in another language would be a chore and very uninteresting, it exploit many strengths of functional programming and more precisely Haskell vision of it, whereas bittorrent is only a network p2p protocol, implementing it in any other language than Python isn't more complicated or anything
12:17:31 <allbery_b> MyCatVerbs: not for ghc's purposes
12:17:46 <MyCatVerbs> allbery_b: fair 'nuff.
12:17:52 <allbery_b> tail call application for C is not quite the same as tail call optimization for Haskell
12:18:14 <allbery_b> you can do better for Haskell by following different rules.
12:18:30 <ndm> MyCatVerbs: tail call optimisation in GCC Is fairly  unreliable at best, and quadratic complexity at worst (i believe)
12:18:35 <allbery_b> there's also some register allocation stuff and some other evil going on in there (it's called evil mangler for a reason)
12:19:11 <luqui> that reminds me of something: map f [] = []; map f (x:xs) = f x : map f xs;   <-- is this "tail recursive" in some lazy stretch of the imagination?
12:19:25 <luqui> and what does this kind of recursion have to do with classic tail recursion
12:19:59 <allbery_b> tail recursion with a base case, yes
12:20:10 <luqui> and what makes it tail?
12:20:17 <gbacon> luqui: no... it's (cons (f x) (map f xs))
12:20:25 <luqui> right I understand that
12:20:41 <luqui> but it is constant in space like tail recursive functions are
12:20:53 <MyCatVerbs> allbery_b: I'm still vaguely curious as to why the mangler was written in Perl rather than Haskell. :)
12:20:54 <gbacon> luqui: thanks to laziness
12:20:54 <luqui> so I thought laziness might introduce a new "tail recursion"esque concept
12:21:01 <Jedai> Well, it is not tail call recursion, it's laziness
12:21:16 <allbery_b> it's tail because the not-immediately-terminating case is reinvocation of the same function with slightly modified arguments
12:21:21 <Jedai> MyCatVerbs: Because Perl is just very good at mangling...
12:21:22 <mrd> luqui: that's not tail recursive
12:21:27 <allbery_b> er, ends with
12:21:57 <allbery_b> as for why the mangler is perl, most of it is regexp twiddling and perl is still the king of regular expressions
12:21:59 <Jedai> allbery_b: No, it's not tail recursive
12:22:02 <MyCatVerbs> luqui: it's constant-space because the last function to be called there is a constructor, if that makes any sense.
12:22:04 <mauke> it's not even real perl
12:22:16 <MyCatVerbs> Jedai: yes, but correct mangling?
12:22:21 <mauke> it's some horrible bastardization of perl, written by someone who knows nothing about the language
12:22:26 <luqui> MyCatVerbs, that makes the most sense of any of the replies I've heard so far :-)
12:22:41 <allbery_b> mauke: and this differs from normal perl programs how?  }:>
12:22:59 <mauke> normal perl programs are readable and structured
12:23:01 <Jedai> MyCatVerbs: I'm a Perl programmer, believe me, you can do correct code with Perl (which the mangler is not, from the last remarks...)
12:23:01 <EvilTerran> luqui, alternatively, because the first thing to be evaluated under lazy evaluation is a constructor
12:23:03 <mauke> they "flow"
12:23:03 <MyCatVerbs> luqui: I believe the term is "ascending on a constructor", but I might be wrong.
12:23:38 <EvilTerran> mauke, that makes me think of the vogon constructor fleet looking like they'd been poured
12:23:39 <Jedai> Good Perl program are rather pretty (in my eyes at least...)
12:23:51 * allbery_b doesn't really want to fully cabalize a simple ffi binding in order to hook it into lambdabot but is failing to figure out how to hook it in directly
12:25:21 <MyCatVerbs> luqui: the idea is that, since you're calling a constructor, you can return that constructor rightaway with all its fields filled with new thunks.
12:25:40 * EvilTerran loves the smell of a new thunk, fresh out of the shrinkwrap
12:25:50 <EvilTerran> (sorry, i'm in a terribly silly mood this evening)
12:27:00 <sw17ch> why doesn't Either have isLeft or isRight defined?
12:27:06 <luqui> MyCatVerbs, yeah.  I was looking for some higher duality, rather than wondering about why map is constant space.
12:27:07 <sw17ch> because it's trivial? or some other reason
12:27:41 <mauke> perl5 came out 14 years ago
12:27:41 <EvilTerran> isRight = (either `on` const) [False ..]
12:27:52 <mauke> the Evil Mangler wasn't updated for it
12:27:57 <edwardk> > either (const True) (const False) (Left 12)
12:27:57 <lambdabot>  True
12:27:59 <bos> sw17ch: just one of those oversights
12:28:03 <byorgey> sw17ch: good question, I don't know.  probably for no good reason. =)
12:28:09 <sw17ch> isLeft (Left _) = True
12:28:12 <sw17ch> that's what i was working on
12:28:17 <sw17ch> byorgey, hehe, alright
12:28:32 <ndm> sw17ch: i think it should, other people disagreed with me, that's because other people are wrong...
12:28:41 <bos> other people often are.
12:29:02 <byorgey> we do have isJust and isNothing, after all.
12:29:10 <ndm> i actually don't think anyone agreed with me...
12:29:11 <sw17ch> ndm: i think Maybe and Either are quite similar...
12:29:13 <edwardk> sw17ch: the trick is thats a bit of a rabbit hole, do you define case distinguishing combinators for every data type?
12:29:15 <sw17ch> yes... exactly
12:29:27 <ndm> edwardk: yes, you should
12:29:40 <edwardk> ndm: i personally agree
12:29:53 <ndm> edwardk: what standard data types do we have other than Either that don't have such a combinator set?
12:30:02 <ndm> i also want fromLeft and fromRight as well
12:30:09 <sw17ch> well, i guess adding 4 lines to my program where i'd like to use it isn't a problem... but i figured it was a little interesting
12:30:27 <ndm> yeah, otherwise clever people can be really blind to fairly obvious things sometimes
12:30:36 <sw17ch> fromRight (Right a) = a
12:30:37 <sw17ch> ?
12:30:42 <ndm> yep :)
12:30:44 <edwardk> ndm: fromLeft and fromRight bother me for the same fundamental reason that fromJust and head do, but hey
12:31:04 <sw17ch> i like the whole from* idea... i haven't used other languages that do that.
12:31:10 <edwardk> i acknowledge that people like to program with partial functions
12:31:13 <sw17ch> makes so much more sense to me than .to_* or whatever
12:31:14 <bos> edwardk: ndm wants fromLeft and fromRight so more people will use "catch"
12:31:20 <edwardk> heh yeah =)
12:31:21 <bos> :-)
12:31:23 <mrd> some are partial to partiality
12:31:46 <edwardk> where as i am impartial about impartiality ;)
12:31:53 <byorgey> and some are totally into totality
12:32:00 <EvilTerran> and i am to- dammit, byorgey beat me
12:32:01 <Peaker> edwardk, you want explicit pattern matching instead of fromJust?
12:32:06 <byorgey> haha
12:32:15 <ilyak_> How is that site called that hosts a nice javadoc-like haskell reference?
12:32:22 <ilyak_> Can't find the link
12:32:34 <sw17ch> .. the API docs?
12:32:40 <ilyak_> I only remember it had grey background
12:32:42 <ilyak_> sw17ch: Nope
12:32:56 <ilyak_> Well, it hosted api docs but not just them
12:33:01 <mrd> haskell.org?
12:33:02 <edwardk> peaker: i like pointfree as much as the next guy, but generally i try to use 'maybe' or something instead that way i at least think about the other case
12:33:24 <byorgey> ilyak_: http://haskell.org/ghc/docs/latest/html/libraries/
12:33:24 <edwardk> @type maybe
12:33:25 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:33:28 <desegnis> haskell.org/ghc/docs/latest/html/libraries ?
12:33:43 <desegnis> doesn't have gray background though :P
12:33:45 <ilyak_> byorgey: mrd: nope
12:33:54 <ilyak_> It had a grey background and frames
12:33:59 <ilyak_> And it wasn't haskell-only
12:34:08 <shepheb> anyone have a good "why language support for monads is a win over reimplementing them every time in C" example? I'm thinking probably list monad for something.
12:34:18 <ilyak_> And it ordered functions by their signatures
12:34:28 <edwardk> > let fromJust = maybe (error "I'm a moron") id in fromJust Nothing
12:34:28 <lambdabot>  Exception: I'm a moron
12:34:42 <byorgey> ilyak_: oh, you mean zvon.org?
12:34:53 <mrd> @remember lambdabot Exception: I'm a moron
12:34:53 <lambdabot> Good to know.
12:35:16 <byorgey> ilyak_: I have no idea who made that site though, and I have no idea how up-to-date it is.
12:35:16 <ilyak_> byorgey: yeah, thanx!
12:35:20 <byorgey> probably not very.
12:35:54 <lispy> gwern: ping?
12:36:01 <ndm> edwardk: i think it encourages a direct style of programming that succinctly states what you want to do, without adding ridiculous extra pattern matches and totally fake error "oh noes!" code everywhere
12:36:02 <ilyak_> It's comfortable
12:36:06 <ilyak_> To use :)
12:36:28 <byorgey> yeah, it still uses the old non-hierarchical module names.
12:36:36 <gwern> lispy: oy
12:36:42 <lispy> gwern: thanks for the patches
12:36:43 <byorgey> ilyak_: that's fine, just be aware that it is not very up-to-date so you may run into things that have changed.
12:37:03 <ndm> ilyak_: have you tried hoogle? http://haskell.org/hoogle
12:37:09 <lispy> gwern: but, it looks like i'm still getting corrupted patches.  Could I bug you to resend it the other way?
12:37:09 <gwern> lispy: welcome
12:37:30 <ilyak_> I'm trying to create a useful monad
12:37:50 <gwern> lispy: I'll retry, I just installed darcs 2
12:37:57 <gwern> helisp right?
12:38:00 <lispy> gwern: and I wanted to tell you what helisp.c does.  It's a minimal run-time that gets complied and linked in via the ld.
12:38:07 <lispy> gwern: yeah
12:38:27 <shepheb> @index Monad
12:38:28 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
12:38:53 <edwardk> ndm: i agree, but my principled side doesn't like partial programming. make a better type system in which you can say fac :: { n : Int | n >= 0 } -> Int  but then of course you land in the realm of total programming and lots of theorem proving
12:39:09 <ndm> edwardk: or just use Catch, and have it proven for you...
12:39:10 <edwardk> so i concede
12:39:38 <ilyak_> I need a [] Monad where a >>= b is (b a) and a >> b is a ++ b
12:39:38 <ndm> you do not need to beef up the type system just to have more invariants
12:39:41 <lispy> gwern: I'm wondering if the step that puts in your email address is corrupting the patches.  The "<\n>" after your email address seems to be a problem
12:39:49 <ilyak_> Still no luck to that point
12:40:21 <edwardk> ilyak: em, that doesn't satisfy the monad laws does it?
12:40:53 <edwardk> @type (>>)
12:40:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
12:41:05 <edwardk> i can't even type your a >> b case =)
12:41:15 <edwardk> let alone satisfy it =)
12:41:22 <ilyak_> That's bad, that's why I search a way around that
12:41:37 <ilyak_> Because that's how xslt works and also it's pretty damn useful
12:41:37 <edwardk> ilyak: easy, don't make it a monad ;)
12:41:47 <ilyak_> edwardk: I'll lost syntax sugar
12:41:51 <ilyak_> lose*
12:42:00 <gwern> lispy: I dunno. most of the time people seem to successfully apply my darcs send patches, but an errant \n should make it always fail no?
12:42:06 <edwardk> ilyak: you don't meet the requirements for the syntax sugar, so the sugar goes *shrug*
12:42:33 <ilyak_> Well, what's the point of having sugar you can't really eat?
12:42:42 <ilyak_> Except for a few /very/ special cases...
12:42:54 <bg> Dentists would agree with that
12:43:02 <edwardk> monads have a lot more than a few cases
12:43:14 <allbery_b> sugaring inedible "food" doesn't generally help it
12:43:27 <ilyak_> allbery_b: xslt is pretty edible
12:43:58 <lispy> gwern: those people might have a version of darcs that ignores the hashes on the patch bundles
12:44:03 <edwardk> heh i suppose you might be able to get away with it in a f# workflow or something, they have a million little methods you have to implement, in there you might be able to get away with approximately the semantics you want, but even so i doubt it.
12:44:36 <ilyak_> edwardk: I was told to discard Prelude and declare my own >> and >>=
12:44:42 <ilyak_> This way I'll have my sugar
12:44:56 <mrd> sugar rots the teeth
12:44:58 <ilyak_> But I wouldn't be able to compose that with IO, I guess
12:45:00 <edwardk> ugly, at the expense of giving up access to everything else the standard libraries give you
12:45:08 <lispy> gwern: do yo know if those people used gmail?
12:45:11 <EvilTerran> syntactic sugar rots your code
12:45:14 <edwardk> also you have to say '-fno-implicit-prelude' etc.
12:45:40 <ilyak_> I wonder whenever >> does something useful in any monad short of IO
12:45:41 <lispy> gwern: i have my mail go through one gateway before it reaches my gmail.  As a test you could send a bundle to dagitj at gmail dot com and see if it arrives unmangled.
12:46:01 <ilyak_> Given it's not possible to do anything remotely useful in it
12:46:31 <EvilTerran> ilyak_, sure, it's useful in Parsec, say
12:46:46 <gwern> lispy: hm. that'll be difficult, I'm not sure where darcs tores the default send-to address
12:46:50 <EvilTerran> ilyak_, and with guard on the LHS in [] and Maybe
12:47:03 <edwardk> depends on the monad, writers, state, etc anything that carries around mutable information can use it nicely
12:47:07 <lispy> gwern: I think the command line allows us to set it, just a sec
12:47:23 <EvilTerran> ilyak_, and with put on the LHS in State...
12:47:43 <ilyak_> I guess I miss something
12:47:52 <lispy> gwern:  darcs send --to=EMAIL
12:48:13 <EvilTerran> ilyak_, it's useful for your actions that have effects other than the value you can get out with >>=
12:48:14 <Peaker> I am having trouble reading the meaning of the expression (. flip id)  can anyone de-section it?
12:48:18 <gwern> right
12:48:28 <EvilTerran> ilyak_, these effects being a pretty fundamental aspect of the point of monads
12:48:33 <gwern> @unpl (. flip id)
12:48:33 <lambdabot> (\ e h -> e (\ c -> c h))
12:48:38 <pejo> Does lambdabot forget everything when it hangs/crashes/whatever it does?
12:49:00 <lispy> pejo: typically yes
12:49:13 <ilyak_> EvilTerran: Well, xslt operators have effects other than the value
12:49:22 <ilyak_> I wonder how can I collect those effects
12:49:30 <Peaker> gwern, is (. flip id) equivalent to:   flip ((.) flip id) ?
12:49:39 <edwardk> ilyak: carry around a state monad to accumulate the effects in
12:49:43 <ilyak_> I'm looking at parsec
12:49:51 <edwardk> then you can write a couple of combinators for your code to do what you need to do to your state
12:49:51 <EvilTerran> Peaker, flip (.) (flip id)
12:50:07 <edwardk> the state can represent the transformation you want to apply or whatever it is you need
12:50:17 <lispy> gwern: did you check that it still builds correctly after removing the makefile?
12:50:21 <Peaker> Evil_Ether, What meaningful thing does (flip id) do?
12:50:22 <EvilTerran> Peaker, or (\f -> f . flip ($)), if you prefer
12:50:29 <lispy> gwern: does cabal know to call gcc instead of ghc
12:50:36 <mauke> @unpl flip id
12:50:36 <lambdabot> (\ b c -> c b)
12:50:41 <EvilTerran> flip id x f = id f x = f x
12:50:49 <EvilTerran> > flip id f x :: Expr
12:50:49 <lambdabot>  Couldn't match expected type `b -> c' against inferred type `Expr'
12:50:55 <EvilTerran> !
12:50:56 <gwern> lispy: I am not sure
12:50:58 <edwardk> then instead of x <- y; z like you want you can use x <- foo y; bar z    to get the desired effect when you run the state monad
12:51:25 <mauke> > flip id x f
12:51:25 <lambdabot>  Add a type signature
12:51:28 <mauke> > flip id x f :: Expr
12:51:29 <lambdabot>  f x
12:51:30 <lispy> and you removed, -Werror, any particular reason?
12:52:35 <gwern> lispy: yes, hackage dislikes it
12:52:53 <gwern> too easy to trigger -Wall errors which are trivial or not warnings
12:53:20 <lispy> well, hackage needs to be fixed...why would you want code to compile that has warnings.
12:54:10 <Saizan> lispy: because new version of the compiler can introduce new warnings, so -Wall -Werror is pretty fragile
12:54:32 <gwern> lispy: pretty much every project has warnings. sometimes they're too hard to winkle out, and the name shadowing ones are pretty trivial
12:54:45 <Peaker> hmm, I don't understand,  if  id::a->a    and the first arg of flip is (a->(b->c)), then it must mean that "id" arg to flip is of type ((b->c)->(b->c)) ?  which would mean that the type of (flip id) should be: ((b->c)->(b->c)) -> b -> (b->c) -> c ?
12:54:48 <ndm> lispy: because some of the current warnings in GHC are fairly silly
12:54:58 <ndm> head (x:xs) = x is a warning code
12:55:01 <sjanssen> lispy: -Werror is useful for packages during development, but not so good for users
12:55:09 <ndm> for two different reasons, neither of which are good
12:55:26 <sjanssen> lispy: what happens when the next version of GHC adds additional warnings?
12:55:31 <byorgey> Peaker: if that was the type of (flip id), it would mean that (flip id) is expecting *another* function of type (b->c)->(b->c).
12:55:36 <edwardk> @type flip id
12:55:37 <lambdabot> forall b c. b -> (b -> c) -> c
12:55:40 <byorgey> but that is not the case, id has already been provided to flip
12:55:58 <lispy> sjanssen: then you should fix the broken code :)
12:55:59 <Peaker> byorgey, oh, that's a silly mistake. Thanks! :-)
12:56:12 <sjanssen> lispy: but it might not be broken, these are warnings, not errors
12:56:22 <byorgey> Peaker: sure, glad my explanation made sense =)
12:56:41 <lispy> So, why not have a release target that disables it?
12:56:45 <gwern> lispy: sometimes the code isn't broken. what about a function defined in a where clause, where you get warned it doesn't handle [] or some other case, but you know that it is never called in the main definition with [], and never can be?
12:57:13 <Peaker> so (flip id) === (flip ($)) ?
12:57:23 <mauke> Peaker: ($) = id
12:57:25 <Igloo> gwern: Then you should put an _ = error case in, so that you can use -Wall to find things that /are/ bugs
12:57:31 <sjanssen> ndm: I'm not sure I agree
12:57:31 <Peaker> mauke, ah, thanks
12:57:43 <ndm> sjanssen: with which one?
12:57:48 <Peaker> mauke, with a different type signature, though?
12:57:50 <sjanssen> ndm: unused variable analysis is useful
12:57:55 <Peaker> (less generalized type)
12:58:08 <mauke> right
12:58:09 <lispy> So, if this is true, about -Wall -Werror then I would only want to disable -Werror when I've tagged a release
12:58:15 <ndm> Igloo: but then instead of a beautiful error message include the exact line, you get a piece of text that is virtually guaranteed to go out of date as the code changes
12:58:27 <edwardk> Anyone want to suggest other stuff I should bake into: http://comonad.com/haskell/categories/dist/doc/html/categories/ before i go and start playing with adding some standard categories to it?
12:58:27 <sjanssen> ndm: (x:_) makes the intent of the function even more explicit
12:58:41 <ndm> sjanssen: head (x:xs) = x; tail (x:xs) = xs
12:58:43 <lispy> and head (x:_xs) = x, is fine
12:58:47 <Igloo> ndm: I'd support a proposal for a ood way of fixing that
12:58:47 <ndm> that looks so much more beautiful
12:58:56 <mauke> Peaker: ($) :: (a -> b) -> (a -> b); ($) = id  -- valid definition
12:59:01 <gwern> Igloo: but that's just noise, then, dead code
12:59:15 <sjanssen> ndm: and incomplete pattern analysis is usually useful
12:59:16 <ndm> Igloo: partial pattern matching errors should invoke Catch, rather than the trivial pattern matcher currently in GHC
12:59:20 <Igloo> gwern: No, it's documentation. Telling the reader that that case can't happen
12:59:40 <ndm> Igloo: (assuming Catch gets to industrial standard, of course, not in its current state)
12:59:40 <sjanssen> ndm: a {-# I_KNOW_THIS_IS_PARTIAL head #-} pragma would be really neat
12:59:42 <Peaker> mauke, cool.  I haven't noticed that $ and id are related in that way until you mentioned it
12:59:47 <edwardk> there are so many times that i wish $ was a primitive piece of syntax so i could use it in more places and not have it rob me of universal quantification, not be usable in types, etc.
12:59:57 <ndm> sjanssen: so why is head x fine but x:xs not - it doesn't make sense
13:00:08 <ndm> sjanssen: there is already such a pragma supported by Catch
13:00:43 <luqui> sjanssen, "(forall a. (a -> a) -> a) ->" in a dependently typed language fills the role of that pragma :-)
13:01:14 <sjanssen> ndm: you mean why is head (x:_) fine?
13:01:20 <lispy> gwern: hmm...I'm not sure this cabalization is going to work
13:01:21 <lispy> Warning: Dulicate modules in executable 'helisp': X86_64Inst
13:01:37 <sjanssen> ndm: because it is explicit about the fact that the tail isn't used
13:01:41 <luqui> sjanssen, no, why is using the "head" function fine but partial pattern matches not
13:01:43 <ndm> sjanssen: i mean why is calling head not a partial pattern warning, but doing a match is - they are the same thing semantically, and both just as dangerous
13:02:04 <ndm> some might even say head is more dangerous, because the failure message is much worse
13:02:13 <sjanssen> ndm: because the first analysis is more difficult :)
13:02:23 <sjanssen> you know this
13:02:25 <edwardk> ndm: and we get back to my case from earlier with you now on the other side ;)
13:02:48 <ndm> edwardk: i argue the warning, as currently implemented, is not good practice - i'm just showing why
13:02:51 <edwardk> ndm: (yes, yes i realize its a finer point of distinction being made, just amuses me) =)
13:03:04 <ndm> sjanssen: i know :) - a whole PhD's worth of difficult at least!
13:03:57 <ndm> edwardk: i think partial programming is a bad idea in production systems, but that incomplete patterns are very useful
13:04:38 <lispy> oh weirdness
13:04:47 <lispy> first build does nothing, second one does something
13:05:00 <yitz> ndm: why is a pattern that you "know" won't fail better than head of a list that you "know" will never be empty?
13:05:35 <lispy> gwern: yeah, nothing builds now :(
13:05:44 <ndm> yitz: the first is slightly better (fractions of a percent) because if it fails you get a better error message, stating where the error is, rather than just head []
13:06:03 <ndm> yitz: but basically, they are the same thing
13:06:03 <yitz> sounds like an artifact to me
13:06:12 <gwern> lispy: strnage. the builds worked for me
13:06:20 <lispy> what is built?
13:06:30 <ndm> yitz: yep, its entirely a pragmatic engineering concern, not a correctness thing - for me i treat them both identically in Catch
13:06:37 <lispy> i expected to get helisp at the top level or some .hi stuff in src
13:07:06 <lispy> oh, wth, it puts stuff in dist?
13:07:12 <gwern> dammit. hpaste needs to bump the 5k limit
13:08:01 <tromp> 640k should be enough for anybody...
13:08:12 <yitz> well, I don't know Catch yet, but if that saves the day it would be great
13:08:21 <Peaker> swing f c a = f ($ c) a  -->  swing map :: [a -> b] -> a -> [b]   but shouldn't "a" here be a list, because that's what a map expects as a 2nd argument?
13:09:13 <kpreid> Peaker: the variable a has the type [b]
13:09:15 <gwern> lispy: this is what I see when I run my build-from-sdist script: http://rafb.net/p/awNIQC38.html
13:09:16 <lambdabot> Title: Nopaste - helisp build
13:09:25 <kpreid> Peaker: value variable names have nothing to do with type variable names
13:09:48 <Peaker> kpreid, http://www.haskell.org/haskellwiki/Pointfree  says that's the type, but ghci says  swing map :: a -> [a -> b] -> [b]
13:09:49 <lambdabot> Title: Pointfree - HaskellWiki
13:09:51 <kpreid> Peaker: try writing it as "swing f c x = f ($ c) x" to clarify
13:09:51 <edwardk> @type let swing f c a = f ($ c) a in swing fmap
13:09:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => a -> f (a -> b) -> f b
13:10:03 <Peaker> kpreid, I think the website has a mistake
13:10:12 * kpreid looks
13:10:22 <lispy> I have an increasing dislike for cabal
13:11:32 <lispy> gwern: I think I know why there are so many errors.  Not all of the code was set to compile before.  The parser, for example, is out of date.
13:11:32 <ndm> yitz: the theory is done to a large extent, but Catch is not yet prime time ready, but _should_ solve these issues - its been used to prove XMonad and HsColour complete - finding 3 crashable bugs in HsColour
13:11:33 <Peaker> kpreid, at least, it seems ghci has reverse the argument order in the type of   swing map
13:12:04 <yitz> ndm: sounds great!
13:12:15 <kpreid> @let swing f c a = f ($ c) a
13:12:16 <lambdabot> Defined.
13:12:19 <kpreid> @type swing any
13:12:20 <lambdabot> forall a. a -> [a -> Bool] -> Bool
13:12:24 <kpreid> @type swing map
13:12:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => a -> f (a -> b) -> f b
13:12:28 <Peaker> @unpl flip . (. flip id)
13:12:28 <lambdabot> (\ k b c -> k (\ f -> f c) b)
13:12:30 <kpreid> @type swing
13:12:31 <lambdabot> forall a b t t1. (((a -> b) -> b) -> t -> t1) -> a -> t -> t1
13:12:49 <gwern> lispy: that would explain it.
13:12:51 <kpreid> @type flip . (. flip id)
13:12:52 <lambdabot> forall b c b1 c1. (((b1 -> c1) -> c1) -> b -> c) -> b -> b1 -> c
13:13:16 <Peaker> the mistake is in http://www.haskell.org/haskellwiki/Pointfree  is in "swing f c a = f ($ c) a"  it should reverse ($ c) and a
13:13:17 <lambdabot> Title: Pointfree - HaskellWiki
13:13:36 <kpreid> Peaker: looks like the two definitions of swing given are contradictory
13:13:53 <Peaker> kpreid, yeah, it would be easier to fix the unpl'd one
13:14:12 <kpreid> oh?
13:14:14 <kpreid> @pl swing f c a = f ($ c) a
13:14:14 <lambdabot> swing = (. flip id)
13:14:22 <kpreid> there :)
13:14:43 <lispy> gwern: ah, and we have the wrong Main-Is
13:14:56 <lispy> gwern: should be Main.hs, changing it now
13:15:13 <Peaker> kpreid, but then the types in the examples have to be reversed
13:15:40 <lispy> that's more like it
13:15:42 <Peaker> kpreid, I spent 5 minutes staring at the type of "swing map" trying to figure out how the last arg of map can become not a list there
13:15:42 <lispy> gwern: src/MonadUnique.hs:16:0: Can't make a derived instance of `MonadError (m a) (UniqueT m)'
13:15:57 <lispy> gwern: I think you have have guess the extension incorrectly
13:16:14 <gwern> lispy: sorry?
13:16:29 <lispy> hmm...no it seems a change in ghc has changed the new type deriving here.
13:16:46 <lispy> I don't think this will work in ghc6.8 yet
13:17:00 <edwardk> @type (\f a c -> f ($c) a) map
13:17:00 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
13:17:06 <edwardk> @type map
13:17:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:17:14 <lispy> gwern: I changed the Main-Is in helisp.cabal, because it should be Main.hs
13:17:16 <edwardk> when did map get fixed?
13:17:31 <sjanssen> edwardk: wtf?
13:17:41 <edwardk> did someone @let?
13:17:43 <lispy> gwern: and now it compiles the way I had it when I last worked on it.
13:17:44 <sjanssen> > map id $ Just ()
13:17:44 <lambdabot>  Just ()
13:17:48 <sjanssen> this is wrong.
13:17:57 <lispy> gwern: but, it seems that newtype deriving is changed.  dos that make sense?
13:18:18 <gwern> lispy: I have no idea. newtype deriving is not something I know much about
13:18:20 <Peaker> map is supposed to be restricted to lists?
13:18:21 <sjanssen> edwardk: someone must have toyed with runplugs' imports
13:18:30 <gwern> you could ask the list, maybe you were doing it wrong
13:18:31 <sjanssen> Peaker: yes
13:18:36 <kpreid> Peaker: lambdabot decided to go general
13:18:49 <kpreid> Peaker: map and (.) have been rebound to fmap
13:18:50 <lispy> gwern: yeah and that particular instance is something people here gave me help with so I'm not sure I know how to fix it :)
13:18:57 <edwardk> @type (.)
13:18:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:19:00 <edwardk> ah
13:19:08 <edwardk> maybe cale? =)
13:19:13 <lispy> newtype UniqueT m a = UniqueT (StateT Integer m a) deriving (Functor, Monad, MonadTrans, MonadIO, MonadError (m a))
13:19:13 <sjanssen> edwardk: sounds like it
13:19:17 <sjanssen> I object to this change
13:19:29 <Peaker> kpreid, (.) is simply fmap?
13:19:33 <damg> does anyone have a tutorial on read class usage handy?
13:19:34 <Peaker> kpreid, is that right?
13:19:37 <edwardk> these days i'm preferring the new (.) in Control.Category. its less 'surprising' than the fmap generalization.
13:19:38 <kpreid> Peaker: it is...in lambdabot.
13:19:45 <sjanssen> lambdabot is supposed to execute Haskell code, not some imaginary Prelude that doesn't really exist
13:19:46 <Peaker> kpreid, I mean, is it a simply-more-general form?
13:19:51 <kpreid> Peaker: yes
13:19:51 <Peaker> kpreid, doesn't sound like that :)
13:19:58 <lispy> sjanssen: I agree
13:20:00 <kpreid> Peaker: fmap = (.) for functions
13:20:15 <Peaker> @src (->) fmap
13:20:15 <lambdabot> fmap = (.)
13:20:21 <lispy> sjanssen: I would like Cale to revert it.
13:20:38 <sjanssen> lispy: was it Cale?  I'm just now grabbing a new copy of the repo
13:20:47 <Peaker> kpreid, ah, now I see
13:20:48 <edwardk> peaker: from way back: http://comonad.com/reader/2006/generalizing-dot/
13:20:50 <lambdabot> Title: The Comonad.Reader  Generalizing (.)
13:21:02 <sjanssen> (by the way, we should really tag and 'darcs optimize' the repo)
13:21:12 <lispy> sjanssen: Yes, Cale would like to improve the Prelude, but I think sandboxing it on lambdabot is the wrong way to go about it.
13:21:18 <Peaker> edwardk, I understand that if you treat a function as a container for its result value, then you can fmap it with a convertor function for its result, which is the same as (.)
13:21:40 <lispy> sjanssen: FWIW, I think optimize is implied in tagging with modern darcs, but yes, that never hurts
13:21:56 <Peaker> I find it enlightening that fmap is related to (.) that way, and that ($) is related to id that way.. too revelations in one hour :)
13:21:56 <sjanssen> lispy: oh?  Didn't know that
13:22:09 <lispy> sjanssen: I could be wrong, but I think that's what david told me the other day
13:22:11 <edwardk> peaker: thats one way to think about it
13:22:24 <kpreid> > Prelude.map id ()
13:22:24 <lambdabot>   Not in scope: `Prelude.map'
13:22:33 <sjanssen> I just don't want to pull 1631 patches from the extremely slow code.haskell.org server :)
13:23:02 <sjanssen> @seen Cale
13:23:02 <lambdabot> Cale is in #haskell-overflow, #haskell-blah, #ghc and #haskell. I last heard Cale speak 1h 43m 15s ago.
13:23:13 <mauke> Peaker: what does 'fmap fix id' do?
13:23:18 <mauke> er
13:23:21 <mauke> Peaker: what does 'fmap fix return' do?
13:23:28 <Peaker> edwardk, there's a problem, if (.) is defined to be fmap, then (->) instance's fmap cannot be (.) :)
13:23:29 <lispy> gwern: I'm applying your patches, so that helisp can be put on hackage, but currently things are not so happy.  A bit of love will be needed before it works for development again.  But, I do appreciate the effort.
13:23:40 <mauke> > P.map id ()
13:23:41 <lambdabot>  Couldn't match expected type `[a]' against inferred type `()'
13:23:46 <Peaker> mauke, I am still new and am very slow, it will take me a while to answer that :)
13:23:58 <mauke> yes :-)
13:24:00 <Igloo> sjanssen: Is code. slower than other online servers?
13:24:11 <tromp> :t fmap fix return
13:24:12 <lambdabot> forall a. a -> a
13:24:17 <sjanssen> Igloo: maybe not
13:24:23 <sjanssen> Igloo: it might just be darcs
13:24:41 <lispy> I think c.h.o is throttled, right?
13:24:47 <sjanssen> Igloo: yeah, SSH seems quite responsive
13:24:50 <Igloo> No, that's darcs.haskell.org
13:24:50 <tromp> :t fix
13:24:51 <lambdabot> forall a. (a -> a) -> a
13:25:06 <Igloo> sjanssen: OK, thanks
13:25:51 <gwern> lispy: true enough. I made sure the description made it clear that it needed love
13:25:57 <Jedai> :t return
13:25:58 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
13:26:13 <tromp> :t fmap
13:26:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:26:33 <lispy> gwern: does cabal support a way to build for release and development in the same .cabal?
13:26:44 <lispy> or will I need one for each?
13:27:05 <lispy> one of the advantages to using a makefile is that you can have a 'make test'
13:27:11 <lispy> I don't know how you do this with cabal
13:28:41 <Peaker> mauke, I don't understand the (->) monad well enough to answer yet, I'm researching though :)
13:28:42 <Jedai> @src (->) return
13:28:42 <lambdabot> return = const
13:28:50 <Peaker> @src (->) (>>=)
13:28:50 <lambdabot> f >>= k = \ r -> k (f r) r
13:29:38 <lispy> ?src ap
13:29:38 <lambdabot> ap = liftM2 id
13:30:53 <Jedai> (->) fmap = (.)
13:31:27 <Jedai> So fmap fix return == fix . return == fix . const
13:32:00 <Jedai> @src fix
13:32:00 <lambdabot> fix f = let x = f x in x
13:32:33 <Jedai> So Peaker ?
13:33:20 <gwern> lispy: the conditionals are pretty flexible in cabal
13:38:45 <dons> Igloo: monk is going down again, for a memory upgrade
13:39:59 <Igloo> dons: oh, I hadn't realised it was up again  :-)
13:40:08 <dons> heh.
13:40:16 <Igloo> dons: Is there any news on what the problem is?
13:40:30 <dons> not yet. paul wants to use the ram as a stop gap measure
13:40:36 <dons> i think he's considering a new machine
13:41:05 <Igloo> *nod*
13:42:00 <malcolmw> is monk more poorly than usual?
13:45:08 <dons> malcolmw: yeah, its locking up on and off
13:45:11 <dons> last week or so
13:46:46 * malcolmw admits to creating lots of wedged cgi-bin processes today on code.haskell.org
13:46:56 <dons> code is fine
13:47:04 <dons> its darcs/hackage that run on monk
13:47:07 <malcolmw> a simple matter of forgetting the -thread flag
13:47:11 <dons> heh
13:47:51 <malcolmw> I know it isn't monk - but maybe the cause is something similar
13:49:37 <astrolabe> I want the function :: (a->b)->(c->d)->(a,c)->(b,d).  Do I have to write it myself?
13:50:08 <mauke> @djinn  (a->b)->(c->d)->(a,c)->(b,d)
13:50:09 <lambdabot> f a b (c, d) = (a c, b d)
13:50:18 <mauke> @. pl djinn  (a->b)->(c->d)->(a,c)->(b,d)
13:50:19 <lambdabot> f = flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
13:50:21 <EvilTerran> isn't that ***?
13:50:37 <mauke> :t (***) ::  (a->b)->(c->d)->(a,c)->(b,d)
13:50:37 <lambdabot> forall a b c d. (a -> b) -> (c -> d) -> (a, c) -> (b, d)
13:50:51 <EvilTerran> cha-ching!
13:50:53 <astrolabe> Oh.  Thanks.
13:51:27 <Peaker> Jedai, I had a phone and then I took a shower.  is it id? :)
13:51:44 <Jedai> Peaker: Congratulations :)
13:51:45 <EvilTerran> ?hoogle ***
13:51:45 <lambdabot> Control.Arrow.(***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
13:52:33 * byorgey wishes that could be written 
13:52:50 <byorgey> well, maybe that would look too much like x
13:53:04 <dons> Igloo: shall we stress test darcs 2.0 during the hackathon?
13:53:21 <dons> if we can decide that 2.0 is ready to go into wide use, that would be a good hackathon result
13:53:26 <Jedai> fmap fix return == fix . return == fix . const == \x -> fix (const x) == (const x) ((const x) ((const x) ...)) == x
13:53:53 <Jedai> s/== x/== \x -> x
13:54:00 <Jedai> sorry
13:54:06 <sjanssen> dons, Igloo: can we get darcs 2 on code.h.o?
13:54:25 <Peaker> Jedai, with about a week or two of Haskell experience (and about 1.5 written programs), that wasn't very easy for me :)
13:55:09 <Jedai> Peaker: From what I've seen, you're pretty good for "a week or two of Haskell experience"... ;)
13:55:18 <lispy> does anyone update this page? http://www.haskell.org/haskellwiki/Programming_guidelines
13:55:19 <lambdabot> Title: Programming guidelines - HaskellWiki
13:55:54 <lispy> Prelude.interact is considered bad style
13:55:58 <lispy> I never knew that.
13:56:01 <tromp> @where fix
13:56:02 <lambdabot> I know nothing about fix.
13:56:03 <Heffalump> it is?
13:56:05 <sjanssen> lispy: huh?
13:56:13 <Jedai> tromp: Data.Function
13:56:16 <lispy> sjanssen: section 4.9 on that page i just linked
13:56:33 <lispy> they do make a good point about readFile/writeFile though
13:56:40 <lispy> sohuld be unsafeReadFile
13:56:46 <tromp> @which fix
13:56:46 <lambdabot> Unknown command, try @list
13:56:52 <Peaker> Jedai, thanks! :)
13:56:57 <Jedai> tromp: You have it in Control.Monad.Fix too
13:57:18 <dons> sjanssen: yeah, it seems it would be useful to have it known as darcs2 for a while
13:57:20 <tromp> trying to remember the command that shows where it is
13:57:28 <dons> until we've built up some trust
13:57:31 <Peaker> Jedai, I've programmed for many years, but never before in FP.. I thought Python decorators were abstract...
13:58:01 <lispy> That guide is odd.  It tells you to use the heirachical module names but avoid extensions.
13:58:08 <mattr___> dons: is darcs2 ready for me to switch to?
13:58:20 <lispy> mattr___: the official release was today
13:58:28 <mattr___> oh - yay!
13:58:29 <lispy> mattr___: but, that doesn't mean you're ready to switch
13:58:34 <mattr___> I think I am
13:58:39 <dons> well, its supposed to be darcs1 with bugs seriously fixed.
13:58:41 <Heffalump> interact is I think a relic of the old stream-based IO
13:58:43 <dons> so we need to try it out.
13:58:44 <lispy> mattr___: Well, be cautious about the switch
13:58:48 <dons> we've used darcs1 for nearly 4 year snow
13:58:50 <Heffalump> but still, it's quite nice
13:58:57 <dons> so another 4 years with darcs2 would be good
13:59:10 * dons thinks david needs a different release announce editor
13:59:11 <Heffalump> darcs badly needs developers :-(
13:59:25 <mattr___> I have plenty of little projects that are safe from borked scm thanks to over-cautious backups
13:59:54 <mattr___> so I plan to get right into it
13:59:55 <edwardk> i'm particularly fond of haskell extensions, mainly because i have yet to actually see the ghc folks really drop support for anything
14:00:18 <ndm> edwardk: linear implicit parameters?
14:00:27 <edwardk> ndm: THAT was a bad idea ;)
14:00:35 <dons> extensions should report home on when they're used in a compile
14:00:37 <ndm> edwardk: yes, agreed!
14:00:38 <dons> extn-pop-con
14:00:44 <edwardk> ok, dropping support for any GOOD extensions anyways ;)
14:02:11 <tromp> :t fmap fix
14:02:12 <lambdabot> forall a (f :: * -> *). (Functor f) => f (a -> a) -> f a
14:02:32 <slava> glguy: ping
14:02:34 <tromp> how does f (a->a) unify with a -> m a ?
14:02:38 <glguy> slava: pong
14:02:45 <glguy> slava: test x11?
14:02:51 <slava> glguy: i have a question; can you pop into the other channel for a bit
14:03:01 <slava> yes, that too, i thought you were on the mailing list so you'd know it was fxed :)
14:03:11 <tromp> or with b -> m b ?
14:04:08 <mauke> f = (b ->): (b -> a -> a) -> (b -> a)
14:10:31 <dons> hackage is up
14:10:41 * byorgey throws lambda-shaped confetti
14:10:54 <lament> man, it's scary how much code is either map or filter
14:11:12 <lament> (in languages that don't have map and filter, or written by programmers not aware of map and filter)
14:12:17 <vincenz> bos: lol
14:12:21 <vincenz> electric snail fence
14:12:29 <bos> heh
14:13:16 * vincenz laughs even more at the end :)
14:13:27 <vincenz> bos: why would you even start with a lemon isntead of a battery?
14:13:47 <bos> vincenz: because you're a kid?
14:13:52 <bos> or a mad scientist?
14:14:00 <laura85> does anyone here write programs in haskell for work (no school stuff) ?
14:14:17 <dons> yes.
14:14:30 <laura85> dons, do you have to prove your programs?
14:14:35 <dons> sometimes
14:14:40 <laura85> dons, cool ^^
14:14:48 <dons> depends on what the client needs
14:15:12 <laura85> dons, you prove it to the client?
14:15:52 <dons> we sometimes give them proofs, yeah. products go through certification
14:16:55 <laura85> dons, hm just the test result (report) or the proof itself?
14:17:29 <lesshaste> I know this is a tricky question but is there a particularly good lecture course online for intro to haskell?
14:17:40 <lesshaste> There are some great ones for other undergrads topics so I was wondering
14:18:09 <laura85> lesshaste, video or course material (lecture notes & exercises/solutions)
14:18:11 <laura85> ?
14:18:26 <dons> laura85, proofs, not tests :)
14:18:34 <lesshaste> laura85: well. are you offering both :) really anything you think is great would be interesting to hear about
14:18:40 <unenough> dons, cool! what sort of programs
14:18:41 <lesshaste> laura85: I was expecting the latter
14:18:41 <gnuvince_> dons: you give your clients results of QuickCheck and HPC?
14:18:53 <dons> gnuvince_: nope.
14:19:03 <laura85> dons, yeah well ^^
14:19:11 <laura85> lesshaste, lemme search
14:19:14 <lesshaste> thanks
14:19:22 <lesshaste> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/d1pt/d1pta/external.html is the best I found
14:19:24 <lambdabot> Title: Programming in Haskell, http://tinyurl.com/fan47
14:21:08 <laura85> lesshaste, heh had the same one (bookmark) ^^
14:21:13 <lesshaste> laura85: :)
14:21:29 <lesshaste> great minds and all that
14:21:31 <lesshaste> or.. google :)
14:21:37 <pejo> lesshaste, not exactly what you're asking for but .. have you seen the wikibook, or YAHT? Plenty of exercises there.
14:21:43 <laura85> lesshaste, someone emailed me the url
14:21:49 <lesshaste> pejo: no I don't think I have
14:21:54 <pejo> @where yaht
14:21:54 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
14:22:23 <lesshaste> thanks
14:22:38 <lesshaste> shame no one put up any video lectures yet
14:24:03 <Cale> hi
14:24:03 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
14:24:35 <Cale> sjanssen: It does execute Haskell. :)
14:24:54 <laura85> Cale, hi ^^
14:24:59 <Cale> laura85: hello :)
14:26:10 <ExplicitCall> lesshaste, have you seen a taste of haskell?
14:26:16 <lesshaste> ExplicitCall: no :)
14:26:22 <lesshaste> I haven't seen anything :)
14:26:35 <laura85> lesshaste, don
14:26:43 <lesshaste> don?
14:26:48 <mib_vi5q8d> how can i write a function to give me back the index of a word in a list?
14:26:51 <laura85> lesshaste, don't panic, ExplicitCall is not part of the corleone family ^^
14:27:09 <lesshaste> laura85: aha :)
14:27:19 <dons> > elemIndex "dons" ["haskell","java","dons","lambdabot"]
14:27:20 <lambdabot>  Just 2
14:27:37 <dons> > elemIndex "dons" (words "haskell java dons lambdabot")
14:27:38 <lambdabot>  Just 2
14:27:41 <ExplicitCall> lesshaste, http://blip.tv/file/get/OSCON-OSCON2007SimonPeytonJonesATasteOfHaskellPartI455.mov http://blip.tv/file/get/OSCON-OSCON2007SimonPeytonJonesATasteOfHaskellPartII749.mov
14:27:45 <Cale> > elemIndex "foobar" ["haskell","java","dons","lambdabot"]
14:27:45 <lambdabot> http://tinyurl.com/2pgvry
14:27:45 <lambdabot>  Nothing
14:28:06 <byorgey> mib_vi5q8d: use elemIndex, as dons has demonstrated above
14:28:09 <resiak> Cale: could you not have ] or something with your madness, and > being normal? :)
14:28:12 <debris> Hi. How can i get the type for something in GHC ? I've tried...  :t 10
14:28:26 <mauke> debris: and?
14:28:28 <laura85> hm does indexing start with 0 for the first element?
14:28:29 <Cale> resiak: Theoretically, but it's more work than one might think.
14:28:31 <debris> Not in scope
14:28:36 <byorgey> laura85: yes
14:28:43 <lesshaste> ExplicitCall: oh wait I did see that.. it's terribly filmed :) you can't see most of the board
14:28:45 <resiak> Cale: sure
14:28:54 <mauke> debris: huh?
14:28:56 <Cale> debris: It works here:
14:28:59 <Cale> Prelude> :t 10
14:28:59 <Cale> 10 :: forall t. (Num t) => t
14:29:21 <byorgey> debris: so you started ghci, typed ':t 10' at the prompt, and it said something about 'not in scope'?
14:29:33 <ExplicitCall> lesshaste, well, it was useful and interesting for me, though i've read and understood a bunch of haskell tutorial a few years ago
14:29:41 <debris> it works on ghci
14:29:51 <debris> can't i use it on a compiled program ?
14:30:00 <lesshaste> ExplicitCall: ok thanks. I will download it for future use in any case
14:30:02 <mauke> er?
14:30:03 <Cale> debris: :t is a metacommand to ghci
14:30:06 <ExplicitCall> lesshaste, and I've discovered that "a taste of haskell" videos just few months ago
14:30:08 <debris> ah
14:30:09 <mauke> debris: what would it do in a program?
14:30:13 <Cale> debris: It's not actually part of Haskell syntax
14:30:28 <debris> i need to get the type of something at runtime for a parser
14:30:35 <lesshaste> ExplicitCall: there are more and more amazing technical videos online these days
14:30:37 <Cale> debris: Types are known statically though
14:30:40 <debris> for a simple interpreter i'm trying to build to learn haskell
14:30:44 <lesshaste> ExplicitCall: you have got to wonder what the point of going to uni is :)
14:30:50 <Cale> debris: So you can just think about it a bit, and you should know what type it is.
14:30:56 <debris> however, thanks for the help and explanation :-)
14:31:03 <ExplicitCall> lesshaste, let me know if you'll find some about Haskell :)
14:31:09 <lesshaste> ExplicitCall: will do
14:31:14 <Cale> debris: Types are actually not present at runtime.
14:31:20 <debris> Oh
14:31:22 <Cale> debris: Compilation removes them.
14:31:35 <debris> Well, i may be able to get them from the parsec itself
14:31:59 <Cale> debris: Can you explain in a little more detail what you're trying to do?
14:32:02 <debris> Yep
14:32:11 <Cale> You're presumably parsing something...
14:32:17 <debris> I'm trying to build a simple scheme interpreter in haskell
14:32:28 <debris> i'm fluent in scheme, but i'm just starting to learn haskell
14:32:29 <lesshaste> ExplicitCall: two more :) http://lambda-the-ultimate.org/node/1303
14:32:32 <lambdabot> Title: Haskell video lectures online | Lambda the Ultimate
14:32:35 <Cale> debris: Okay :)
14:32:50 <debris> the goal of this type thing is to be able to say to the user:
14:32:53 <lament> debris: have you seen "Write Yourself a Scheme in 48 Hours"
14:33:13 <debris> Expected symbol: ')' but found Integer at line...
14:33:20 <lesshaste> ExplicitCall: actually much more than 2
14:33:30 <debris> lament, actually that's exactly what i'm reading
14:33:31 <debris> :-D
14:33:37 <Cale> debris: Ah, that's just a matter of annotating your parsers with names.
14:33:45 <Cale> Er...
14:33:54 <Cale> Well, it can't be perfect :)
14:34:01 <debris> :-)
14:34:28 <ExplicitCall> lesshaste, thanks
14:34:37 <lesshaste> ExplicitCall: no problem :)
14:34:39 <Cale> In order to know that it found an integer, it would have to try a completely different parser. However, I think it by default shows the thing which it read.
14:34:44 <laura85> dons, do you know of any public proofs for haskell programs)?
14:35:01 <debris> yep, it shows a string of what it found
14:35:02 <laura85> publicly available*
14:35:28 <bugQ> goooood morning!
14:35:46 <laura85> bugQ, morning ^^
14:35:57 <Cale> debris: I *suppose* you could get it to try a bunch of parsers which parse various things and then cause a parse failure with an appropriate message...
14:36:15 <bugQ> it's actually 15:35 here, but it feels like I just work up.
14:36:19 <bugQ> *woke
14:36:32 <debris> Well, that's a bit ahead in the way of learning but i'll walk slowly to it
14:36:33 <debris> :-)
14:36:34 <Cale> debris: But if it were me, I'd just leave that for some other time, and worry about the more interesting bits :)
14:36:47 <debris> Yep
14:37:00 <debris> Thanks a lot, you are helpful :-)
14:37:12 <Cale> debris: No problem, let us know if you have any other questions :)
14:37:36 <Cale> laura85: Of large scale programs you mean, or of smaller things?
14:38:01 <Cale> laura85: I'm pretty sure I've seen lots of papers which prove various properties of small programs. (Mostly by algebraic substitution)
14:38:17 <lesshaste> ExplicitCall: there are loads more on this page too :) http://freescienceonline.blogspot.com/
14:38:18 <lambdabot> Title: Free Science and Video Lectures Online!
14:38:22 <Cale> laura85: But for large scale applications, I'm not sure.
14:38:51 <laura85> Cale, hm smaller things I guess. I'd like to see how a real world haskell program proof looks like ^^
14:39:08 <laura85> Cale, since I have to proof in mini-haskell
14:39:11 <laura85> prove
14:40:51 <Cale> Hmm, I seem to recall that Bird and Wadler's Haskell book had lots of nice proofs in it. You might be able to get it from your library.
14:41:29 <Cale> It was a while since I saw it though, so I might have it confused with another text, but I'm pretty sure that was the one.
14:41:39 <mrd> think of a proof as being a really really specific type :)
14:41:41 <mrd> er
14:41:44 <mrd> proposition
14:42:01 <Cale> The basic idea though, for the most part, is to do algebraic substitution using the properties that you already know are true.
14:42:01 <mrd> and the proof being carried out by your program
14:42:02 <unenough> dons, what sort of program do you write that you later prove?
14:42:09 <unenough> or not later, but whenever
14:42:11 <Cale> It's very much like highschool algebra in that regard :)
14:42:48 <laura85> Cale, bird and wadler, made a note. thanks ^^
14:50:02 <mib_vi5q8d> is possible to get the (x,y) cooordinate of a word in a list?
14:50:19 <Cale> mib_vi5q8d: What do you mean by (x,y) coordinate?
14:55:01 <mib_vi5q8d> (line, columna)
14:55:17 <Zao> A list is still just a sequence of things.
14:55:54 <mib_vi5q8d> i want to return the position where a found word is located (startpos, endpos)
14:56:43 <Cale> mib_vi5q8d: Well, as a start, you can break a string into lines using the 'lines' function
15:01:44 <Cale> You can then find the indices in the list of tails of each line at which the word to search for is a prefix of the tail.
15:02:53 <Cale> > let search needle haystack = [(l,c) | (l,cs) <- zip [1..] . map (findIndices (isPrefixOf needle) . tails) . lines $ haystack, c <- cs] in search "multi" (unlines ["This is", "a multi-line string"])
15:02:54 <lambdabot>  [(2,2)]
15:03:16 <Cale> > let search needle haystack = [(l,c) | (l,cs) <- zip [1..] . map (findIndices (isPrefixOf needle) . tails) . lines $ haystack, c <- cs] in search "multi" (unlines ["This is", "a multi-line string", "with multiple occurrences", "of multi"])
15:03:17 <lambdabot>  [(2,2),(3,5),(4,3)]
15:04:06 <Cale> How's that?
15:04:40 <Cale> Of course, you might want to 0-index the lines instead...
15:04:43 <Cale> > let search needle haystack = [(l,c) | (l,cs) <- zip [0..] . map (findIndices (isPrefixOf needle) . tails) . lines $ haystack, c <- cs] in search "multi" (unlines ["This is", "a multi-line string", "with multiple occurrences", "of multi"])
15:04:44 <lambdabot>  [(1,2),(2,5),(3,3)]
15:05:15 <Cale> mib_vi5q8d: ^^
15:06:13 <ddarius> @src isInfixOf
15:06:13 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
15:06:30 <Cale> isInfixOf doesn't work when we want the location though.
15:06:41 <ddarius> Cale: I know.
15:06:46 <laura85> Cale, I need your brain on friday ^^
15:06:52 <Cale> laura85: hehe
15:07:04 <laura85> Cale, midterm you know ^^
15:07:08 <Cale> :)
15:07:10 <laura85> (functional programming)
15:10:30 <ddarius> [1..] ?!  What were you thinking Cale?
15:11:03 <Cale> Yeah, I probably also should have added one to the results of findIndices in that case
15:11:41 <Cale> > let search needle haystack = [(l,c+1) | (l,cs) <- zip [1..] . map (findIndices (isPrefixOf needle) . tails) . lines $ haystack, c <- cs] in search "multi" (unlines ["This is", "a multi-line string", "with multiple occurrences", "of multi"])
15:11:42 <lambdabot>  [(2,3),(3,6),(4,4)]
15:11:50 <shapr> @users
15:11:51 <lambdabot> Maximum users seen in #haskell: 477, currently: 455 (95.4%), active: 11 (2.4%)
15:12:19 <Cale> 1-indexed things are easier for users to read ;)
15:12:30 <Cale> (but harder for programmers to work with :)
15:12:34 <mrd> unless that user is me
15:13:08 <Cale> After all, you usually think of the first line of your text file, and not the zeroth.
15:13:12 <allbery_b> OPTION BASE 1 forever! :)
15:15:56 <Vulpyne> Would a function in the State monad recurse using withState?
15:16:02 <shapr> hiya Vulpyne
15:16:07 <Vulpyne> Hey, shapr! How goes?
15:16:15 <Cale> Vulpyne: uh, not usually?
15:16:26 <shapr> Vulpyne: Life is fun and exciting, how about you?
15:16:34 <Vulpyne> shapr: Pretty good.
15:16:35 <Cale> Vulpyne: By function in the State monad, I assume you mean a function of type  a -> State s b
15:17:09 <seebaer> Welcome to computer science. We count from zero ;)
15:17:09 <Cale> Usually if one of those is recursive, it just literally calls itself.
15:17:10 <Cale> (and then runs the action resulting)
15:17:18 <lament> except for lua.
15:17:29 <Vulpyne> cale: Yeah. It seems like it would need to do something to arrange for the current state to be passed.
15:17:40 <laura85> who came up with the name "Maybe" for the type Maybe?
15:17:45 <Cale> Vulpyne: That's handled by >>=
15:17:54 <Vulpyne> Hmm, good point!
15:18:05 <Vulpyne> Thanks. Pretty dumb question.
15:18:20 <Cale> laura85: hmm, good question :)
15:18:35 <Cale> laura85: It's possible that it even came from Miranda...
15:18:42 <ddarius> (A lot better than option)
15:19:15 <mrd> Maybe better
15:19:57 <Cale> Hmm, it doesn't seem to be in this copy of the Miranda standard environment...
15:20:10 <Cale> I'm pretty sure it's in the first Haskell Report.
15:20:42 <ddarius> There are some weird things missing from early versions of Haskell.
15:21:29 <laura85> Cale, good to know. What would have been your name suggestion?
15:21:39 * shapr hugs cale
15:21:44 <Cale> Hmm, maybe it's *not* in the first Haskell report :)
15:21:51 <Cale> laura85: I think Maybe is a good name.
15:22:27 <Cale> laura85: Optional would be another possibility.
15:22:48 <Cale> Yeah, I don't see it here in Haskell 1.0
15:23:06 <mrd> Presumably a
15:23:36 <ddarius> ItsEasyToSee a
15:23:48 <laura85> hm... Maybe makes it unique ^^
15:24:13 <Korollary> Potentially a
15:24:26 <laura85> Spongebob a
15:24:30 <Cale> Wow, it seems that it wasn't there until Haskell 1.3!
15:24:48 <ddarius> Cale: See
15:25:31 <Cale> Maybe Lennart would know who was responsible? :)
15:25:38 <ddarius> I imagine he would.
15:26:14 <Cale> @seen augustss
15:26:14 <lambdabot> augustss is in #haskell. I don't know when augustss last spoke.
15:26:17 <Cale> hmm
15:27:34 <Korollary> When did option get into ml or ocaml or whatnot
15:28:17 <Cale> I'm not sure where to research that even. Is there a handy list of links to versions of the ML standards?
15:31:37 <ndm> anyone know of a Haskell Latex parser?
15:32:03 <ndm> I just want to do some analysis on the result, so doesn't have to be 100% correctness preserving
15:32:29 <lispy> darcs does some latex munging...
15:32:34 <lispy> I wouldn't call it parsing though
15:32:47 <ndm> yeah, it needs to be a bit more than munging
15:33:18 <ddarius> Why does darcs do latex munging?
15:33:42 <lispy> ddarius: good question, I think it does it to give latex2html a helping hand
15:33:53 <lispy> ddarius: and it also inserts the output of darcs --help for each command
15:34:01 <ddarius> Ah
15:36:31 <seebaer> @user shag
15:36:31 <lambdabot> Maximum users seen in shag: 1, currently: 0 (0.0%), active: 0 (NaN%)
15:36:32 <lispy> Cale: does has a custom thing like Maybe called Hopefully
15:36:36 <lispy> er
15:36:40 <lispy> Cale: darcs has not does has
15:36:46 <seebaer> @seen shag
15:36:46 <lambdabot> I saw shag leaving #gentoo-haskell and #haskell 24m 10s ago, and .
15:37:11 <lispy> it's basically, data Hopefully a = Actually a | Unavailable
15:37:25 <lispy> but, in practice it's more complicated (which is why we don't use Maybe)
15:38:05 <lispy> But, I'm very fond of "Maybe" instead of Optional
15:43:02 <laura85> g night everyone ^^
15:43:22 <Korollary> lispy: how is it more complicated?
15:48:33 <jorick> now that i finished my project i would like to rent a "shell" somewhere to put it online. if i don't need much (ram/bandwidth/cpu), how much can i expect to pay for this? can anyone recommend me an honest company?
15:50:36 <sjanssen> @tell gwern the hs-plugins tarball you've uploaded on hackage is broken -- missing install.sh
15:50:36 <lambdabot> Consider it noted.
15:51:26 <gweiqi> hmm, this gnome 3.0 and xmonad collaboration is just an april fool's joke, right?
15:51:44 <tromp> :t ap return
15:51:46 <lambdabot> forall a a1. (a -> a1) -> a -> a
15:53:53 <gwern> @seen cosmic-ray
15:53:53 <lambdabot> I haven't seen cosmic-ray.
15:54:05 <gwern> @seen cosmicray
15:54:06 <lambdabot> I haven't seen cosmicray.
15:54:18 <gwern> bleh. what was goerzen's irc nick?
15:54:18 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
15:54:34 <sjanssen> gwern: CosmicRay
15:54:40 <sjanssen> @seen CosmicRay
15:54:40 <lambdabot> I haven't seen CosmicRay.
15:54:51 <sjanssen> @quote CosmicRay
15:54:51 <lambdabot> No quotes match. Do you think like you type?
15:55:02 <gwern> sjanssen: yes, I know about that. but my repo is broken because of some cabal oddities, and I don't want to upload another package until I've resolved it
15:55:12 <sjanssen> gwern: yes, it is ajoke
15:55:25 <sjanssen> gwern: should I fix it?
15:55:31 <sjanssen> just needs some extra source files
15:56:09 <gwern> sjanssen: go ahead. but don't all you need to do is change the Setup.hs to 'defaultUserHooks'?
15:57:45 <gnuvince_> @src unions
15:57:45 <lambdabot> Source not found. I am sorry.
15:57:50 <gnuvince_> @src Data.Set.unions
15:57:50 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
15:57:50 <sjanssen> gwern: no, install.sh is missing
15:58:12 <sjanssen> gwern: also, your .cabal file differs from the one found at http://code.haskell.org, what's up with that?
15:58:13 <lambdabot> Title: Index of /
15:58:37 <sjanssen> http://code.haskell.org/~dons/code/hs-plugins, to be specific.  Is there an updated URL?
15:58:37 <lambdabot> Title: Index of /~dons/code/hs-plugins
15:59:36 <mib_vi5q8d> in a  findDialog, how does the selection on text works?
16:02:57 <sjanssen> this Cabal QA crap is really annoying
16:03:11 <sjanssen> these should be *warnings* not *errors*
16:04:04 <glguy> errors put the assurance in qa
16:04:14 <glguy> rather than quality suggestions ;)
16:04:33 <sjanssen> glguy: sometimes I know better than the tool
16:04:39 <glguy> it's like any type system, some times you have to kill off a few good programs to kill more of the bad ones
16:05:04 <sjanssen> or sometimes I just want to make a tarball of a package I know is crappy
16:05:16 <glguy> There are languages for people like you!
16:05:17 <glguy> ;)
16:05:37 <sjanssen> glguy: throw something towards dons for using -fasm in plugins.cabal :)
16:05:39 * glguy imagines sjanssen is a monkey patcher!
16:05:44 <glguy> heh, can do
16:05:58 <dobblego> ooooh, he called him the m.p. word
16:06:13 <glguy> hopefully dons reads the channel to find out why he got hit with a hacky sack
16:06:46 <glguy> dons: feel free to throw that back my way
16:07:16 <dons> done
16:07:25 <glguy> :-D
16:07:48 <sjanssen> hey dons, is http://code.haskell.org/~dons/code/hs-plugins/ the right repo?
16:07:49 <lambdabot> Title: Index of /~dons/code/hs-plugins
16:07:53 <dons> yep
16:08:16 <sjanssen> and -fasm isn't needed for any particular reason?
16:09:43 <dons> hmm. probably not
16:09:59 <dons> check the testsuite kinda runs
16:10:39 <sjanssen> will do
16:22:56 <sjanssen> gwern, dons: so I've got a working plugins tarball.  Should I bump the version, or not?  Okay if I upload it?
16:25:45 <dons> sjanssen: go for it
16:26:34 <sjanssen> I'll bump the version to 1.2 just to avoid any confusion
16:28:16 <dons> ok. good
16:32:20 <sjanssen> done
16:39:15 <bos> you have to love how expressive java is:
16:39:17 <bos> return new ArrayList<ArrayList<String>>() {{
16:39:17 <bos>     add(new ArrayList<String>());
16:39:17 <bos> }};
16:39:55 <bos> maybe we could have a little more repetition in there.
16:42:59 <jsnx> sometimes, i want to map a function over a list of tuples, and only alter the first or third element or whatever
16:44:00 <Saizan> of the tuples?
16:44:10 <jsnx> what is a good way to transform a function `f :: a -> x` to a function `f' :: (a, b) -> (x, b)` ?
16:44:22 <jsnx> Saizan: yes
16:44:29 <Saizan> ?type first
16:44:30 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
16:44:35 <Saizan> ?type second
16:44:36 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
16:44:47 <Saizan> but it doesn't scale :\
16:45:23 <jsnx> Saizan: doesn't work on lists, i guess
16:45:30 <Saizan> it does
16:45:32 <Saizan> with map
16:45:49 <jsnx> it takes pairs of tuples, though...
16:45:54 <jsnx> how do i use it?
16:46:06 <Saizan> > map (first (+1)) $ zip [1..10] ['a'..'z']
16:46:07 <lambdabot>  [(2,'a'),(3,'b'),(4,'c'),(5,'d'),(6,'e'),(7,'f'),(8,'g'),(9,'h'),(10,'i'),(1...
16:46:24 <jsnx> :t first (+ 1)
16:46:25 <lambdabot> forall b d. (Num b) => (b, d) -> (b, d)
16:46:46 <Saizan> > map (second ord) $ zip [1..10] ['a'..'z']
16:46:46 <lambdabot>  [(1,97),(2,98),(3,99),(4,100),(5,101),(6,102),(7,103),(8,104),(9,105),(10,106)]
16:46:48 <jsnx> oic
16:47:00 <Saizan> > map (fmap ord) $ zip [1..10] ['a'..'z']
16:47:01 <lambdabot>  [(1,97),(2,98),(3,99),(4,100),(5,101),(6,102),(7,103),(8,104),(9,105),(10,106)]
16:47:05 <jsnx> Arrow a => a x y  is an arrow from x to y
16:47:12 <Saizan> yeah
16:47:26 <Saizan> we're using the (->) arrow in this case
16:47:44 <jsnx> Saizan: did that require compiler extensions?
16:47:56 <Saizan> no
16:48:18 <jsnx> oh wait, because of kinds, i guess
16:48:21 <Saizan> you could also just define a specialized first for (->)
16:48:45 <jsnx> i am mystified by all this, but it certainly works
16:48:54 <TomMD> ?src first
16:48:55 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
16:49:03 <Saizan> Arrow is a higher-kinded class, but that's haskell98
16:49:26 <Saizan> ?src (->) first
16:49:27 <lambdabot> first f = f *** id
16:49:38 <Saizan> ?src (->) (***)
16:49:38 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
16:49:54 <Saizan> no magic :)
16:51:49 <jsnx> thanks
16:51:57 <jsnx> i've wanted to know a good way to do that for ages
17:00:33 * lispy tries to match wits with a rutabaga
17:04:18 <Cale> jsnx: Of course, you can also just do something like map (\(x,y) -> (f x, y)) or similar
17:04:40 <jsnx> Cale: that's what i do
17:04:50 <gwern> sjanssen: you have to bump the version number anyway
17:05:04 <jsnx> but if i am transforming functions this way all the time, i should generify it
17:05:09 <lament> so arrows are just some kind of a trick for making working with tuples easier?
17:05:21 <Cale> lament: The (->) arrow is, sort of.
17:05:27 <clanehin_> lament: no!
17:05:33 <jsnx> lament: that is oversimplification
17:05:34 <gwern> sjanssen: and if there are differents, presumably that reflects not-yet-upstream patches
17:05:42 <clanehin_> lament: they can do side effects, like monads.
17:05:49 <Cale> lament: But Arrows are a style of combinator library, really, just like monads, but with different primitives.
17:06:13 <lament> what other arrows are used?
17:06:28 * lament imagines there's (->), (<-), (^) and (v)
17:06:36 <Cale> In fact, for any monad m, there is an arrow A such that A a b is isomorphic to (a -> m b)
17:07:01 <EvilTerran> the Kleisli arrows!
17:07:09 <Cale> and for any comonad w, there is an arrow such that A a b is isomorphic to (w a -> b)
17:07:26 <EvilTerran> the, uh, Co-Kleisli arrows?
17:07:32 <Cale> So arrows simultaneously generalise monads and comonads.
17:07:45 <Cale> (in a sense)
17:07:51 <ehird> Hmm.
17:07:56 <ehird> Is there a 'bidirectional function thing'?
17:08:01 <ehird> Something that unifies a->b and b->a
17:08:16 <Cale> ehird: Not in the standard libraries.
17:08:25 <ehird> Cale: What would be a sensible definition of one?
17:08:31 <EvilTerran> i think that'd have to go in a Control.Category rather than a Control.Arrow
17:08:54 <Syzygy-> Why Category?
17:09:00 <Syzygy-> If anything, then Groupoid
17:09:01 <Cale> Perhaps something like  data Bijection a b = Bi (a -> b) (b -> a)
17:09:04 <EvilTerran> data Inv a b = Inv { fore :: a -> b, back :: b -> a }
17:09:04 <jsnx> so, does anybody have a nice NeverBeEmpty list that is already foldable, &c?
17:09:23 <EvilTerran> Syzygy-, not sure, really. what's a groupoid?
17:09:34 <Syzygy-> A category with all morphisms isomorphisms
17:09:40 <jsnx> OneList a = OoO a (OneList) | Oo a
17:09:49 * EvilTerran blinks
17:09:55 <lispy> EvilTerran: it's like a group, but the operator does have to be full, it can be partial
17:09:58 <Syzygy-> So you can invert all arrows
17:10:07 <EvilTerran> i see
17:10:19 <ehird> [01:09]  <Cale> Perhaps something like  data Bijection a b = Bi (a -> b) (b -> a)
17:10:22 <ehird> that's kinda boooring though
17:10:23 <ehird> :D
17:10:37 <Syzygy-> lispys way of thinking of it is that you have something like a group, but you also have a bunch of compatibility conditions for the product to work out.
17:10:41 <Pseudonym> class Cast a b where { cast :: a -> b }
17:10:58 <Pseudonym> class (Cast a b, Cast b a) => Bicast a b where {}
17:11:09 <lispy> Syzygy-: yeah, like darcs patch application :)
17:11:15 <Pseudonym> The trouble with that is that it would be better if Bijection a b was the same as Bijection b a.
17:11:37 <Syzygy-> Whereas I think of it more in category terms.
17:11:39 <Pseudonym> And if you have Bijection, it'd be nice to also have Retraction and Section.
17:11:41 <Syzygy-> It works out to the same thing.
17:12:28 <ehird> Pseudonym: Yeah, dunno how to make Bijection a b == Bijection b a
17:12:30 <ehird> Maybe a type-class.
17:12:50 <ehird> But Bijection/Retraction/Section would be neat
17:12:52 <ehird> Control.Neat
17:13:03 <lispy> Wouldn't you want the bijection class to be a constraint on the invertible function?
17:13:04 <Pseudonym> Moreover, there may be more than one interesting bijection.
17:13:43 <lispy> My favorite bijection: id
17:13:57 <lispy> Bijection your honour!
17:14:14 <clanehin_> @type id id id id id
17:14:14 <ehird> lispy: My favourite: rot13.
17:14:15 <lambdabot> forall a. a -> a
17:14:15 <ehird> :D
17:14:53 <lispy> clanehin_: what would you need, in order to be able to contribute regularly to darcs?
17:15:00 <lispy> clanehin_: is there anything currently in your way?
17:15:14 <ehird> though 'reverse' is up there too
17:15:29 <ptolomy2> Is it theoretically possible to compile a stack of monad transformers into a single monad? Rather, is there such a tool or a guide to doing this?
17:15:32 <lispy> ehird: so you like self-inverting bijections?
17:15:39 <ehird> lispy: Yes!
17:16:05 <Pseudonym> automorphisms
17:16:11 <clanehin_> lispy: only my lack of knowledge about darcs.  I wouldn't mind being given a chore to do to get me started.
17:16:15 <Syzygy-> Pseudonym: Not all automorphisms are selfinverting
17:16:21 <lament> ptolomy2: a stack of monad transformers IS a single monad.
17:16:25 <Pseudonym> True.
17:16:29 <ehird> automorphingbijection
17:16:31 <gwern> boy... I wish roundy had take some more time with his announcement - http://reddit.com/info/6ewbq/comments/c03nmlm
17:16:33 <Pseudonym> I still like automorphisms.
17:16:33 <Syzygy-> Take, for instance, \(a,b,c) -> (c,a,b)
17:16:33 <clanehin_> lispy: although I'm looking at a few minor configure/build errors in 2,0 right now.
17:16:40 <ehird> totally the best thing to describe id and rot13 with
17:16:41 <ehird> :D
17:16:41 <gwern> if that attitude spreads, darcs *will* die
17:16:44 <Syzygy-> This is a perfectly good automorphism.
17:16:57 <Pseudonym> involution
17:16:58 <Pseudonym> That's it.
17:17:04 <Syzygy-> Yeah.
17:17:10 <Syzygy-> Far from all automorphisms are involutions.
17:17:13 <ptolomy2> lament: That's true. I mean more "compile down to a single ADT for efficiency purposes because my inner loop is all gets, puts, and liftIOs."
17:17:16 <Syzygy-> but involutions are just what you're talking about
17:17:24 <ehird> I prefer automorphingbijection
17:17:26 <lispy> clanehin_: okay, maybe we should take the discussion back to #darcs
17:17:49 <lament> ptolomy2: i believe that "it's possible in principle, but nobody bothered yet"
17:18:08 <gwern> ehird: go go power morphisms?
17:18:36 <Cale> ptolomy2: I'm not sure how well the optimiser currently does -- you'd have to check, but yes, it's theoretically possible.
17:19:14 <ehird> gwern: :D
17:19:20 <Cale> ptolomy2: At worst, if you've designed your library correctly, this could be done by hand quite simply by replacing the monad datatype built up from transformers with a more direct implementation.
17:19:21 <ptolomy2> I'd also be just as happy with a guide for how to do it manually or an example of it being done... I don't think I could manage it on my own without quite a bit of effort, but I want to compare performance.
17:19:34 <ptolomy2> Cale: That is what I'd like to do.
17:19:38 <Cale> (which underscores the need to always newtype a monad transformer stack)
17:19:53 <ehird> "Starting with the darcs 2.0.0 release, there will be just one central branch of darcs and only one maintainer: for now this is me, David Roundy. Moreover, I will be attempting to act as a much lower-profile maintainer than we've had previously. I will not be reading bug reports, reading the darcs-users email list or even the darcs-devel mailing list."
17:19:55 <ehird> wtf is that about
17:20:09 <Cale> I would start by taking the composed run function for your monad transformer stack and looking at its type.
17:20:10 <lament> ehird: "I quit"
17:20:19 <ehird> lament: that's how i read it too
17:20:30 <Cale> ehird: He just wants to have a life outside maintaining darcs, which I think is reasonable.
17:20:40 <gwern> ehird: I think it means that roundy will apply every patch that doesn't make him go wtf
17:20:53 <Cale> ehird: It's not like darcs is going to go away -- it has enough users that someone will maintain it.
17:20:54 <EvilTerran> ptolomy2, i've seen something that suggests newtype'ing it in its own module so it can be made abstract, then exporting appropriately-lifted versions of all the basic actions on that monad
17:21:15 <Cale> EvilTerran: You might have seen my tutorial on this :)
17:21:23 <gwern> Cale: stagnation is bad for the haskell community at large
17:21:24 * gwern blames dons for this
17:21:32 <EvilTerran> it may well have been yours. do you have a link?
17:21:37 <Cale> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
17:21:39 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
17:22:03 <Lycurgus> I disagree with dons that darcs command are so very much "intuitive" or natural than those of other rcs.
17:22:11 <Cale> That is indeed exactly what I suggest, and I don't recommend using monad transformers at all without doing that.
17:22:23 <Cale> Lycurgus: I agree with him about it.
17:22:26 <Lycurgus> *much more
17:22:50 <Cale> Lycurgus: Darcs is basically the only VCS which I've had the patience to learn properly.
17:23:01 <gwern> Lycurgus: I've only tried git and monotone in addition to darcs, but darcs made the most sense by far
17:23:04 <Cale> (because it took all of 120 seconds)
17:23:13 <Lycurgus> different ones have different things going for hem
17:23:14 <dons> gwern: you're blaming me for stagnation?
17:23:16 <Lycurgus> *them
17:23:21 <pjd> hg++
17:23:27 <Lycurgus> hg, git, svn, and darcs.
17:23:29 <Cale> dons: hehehe
17:23:41 <ehird> I am a git
17:23:57 <gwern> dons: heh. no, I was humorously saying that 'because dons evangelized so much darcs as a examplar of the haskell way, stagnation makes us look bad'
17:24:01 <ptolomy2> Hm. I have the issue that my StateT type depends on my monad (it contains a map of monadic operations).
17:24:15 <dons> i'm not sure i evangelised darcs, fwiw. its nice though
17:24:21 <ptolomy2> I suppose I'm going to have to parameterize to decouple. So it goes.
17:24:28 <dons> i think david could have split the announce into two parts
17:24:31 <EvilTerran> ptolomy2, wow, that's quite something
17:24:40 <Cale> ptolomy2: So... your monad is recursive in the state type?
17:24:42 <dons> one annoucning all the bug fixes, the other to the darcs list about the new maintainer system
17:24:47 <EvilTerran> ?paste -- can you show us what you've got just now, ptolomy2?
17:24:47 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:24:53 <dons> that would have prevented the perception that he is killing darcs
17:24:57 <ptolomy2> erm.. yes.
17:25:03 <LordBrain> dons, you still find time to do the benchmarks for the great language shootout?
17:25:07 <dons> i think that was a strategic error
17:25:13 <dons> LordBrain: sometimes
17:25:18 <EvilTerran> ?bots-back
17:25:18 <lambdabot> :)
17:25:19 <Cale> ptolomy2: I think I might avoid StateT there -- that's brutally strange, and probably worth thinking about in an unravelled way :)
17:25:21 <gwern> dons: no kidding. you see the reddit comments?
17:25:32 <dons> gwern: yeah
17:25:33 <Lycurgus> i always thought the strong suite of darcs was some payoff in conflict/merge due to the theory of patch, but seems there may have been a dark cloud there even.
17:25:45 <Lycurgus> *patches
17:25:50 <dons> gwern: the email will be used as justification for not using darcs for the next few years
17:26:09 <gwern> dons: exactly :( darcs is dying, netcraft confirms it
17:26:10 <dons> it was a PR blunder
17:26:22 <LordBrain> how does one use darcs to download a large repo in a reasonable amount of time?
17:26:26 <Syzygy-> dons: What was?
17:26:29 <Syzygy-> Oh that.
17:26:41 <sjanssen> dons: yes, I don't think the announce as written will even have the desired effect
17:26:49 <sjanssen> nobody wants to board a sinking ship
17:26:54 <dons> right, it was to encourage contributors
17:27:01 <Cale> ptolomy2: Newtype deriving almost certainly won't work with that...
17:27:05 <Cale> hmm...
17:27:06 <dons> so what should have been a triumph, darcs 2.0, was entirely deflated
17:27:44 <dons> despite the fact that all the core reasons for not using darcs seem now to be fixed
17:27:57 <dons> the announce produced a new reason. silly silly
17:28:04 <Lycurgus> if i'm not mistake there are good intentions for 3.0
17:28:09 * EvilTerran is thinking that ptolomy2's problem might work better with ContT... dunno, really.
17:28:11 * ptolomy2 wonders what the haskell equivalent of forward-declaring a type in order to resolve a cyclical dependency is.
17:28:17 <Lycurgus> good things are worth waiting for
17:28:19 <dons> note we've been using darcs 1 for nearly 4 years
17:28:24 <gwern> dons: it *should've* been, 'Darcs 2.0: last major problem fixed and faster than ever', and now it's 'yeah the conflict bug is fixed, but darcs is a dead-end. let's all go use git'
17:28:25 <Lycurgus> *mistaken
17:28:27 * ptolomy2 will look into ContT.
17:28:28 <dons> so we could be using a stable darcs 2 for another 4
17:28:28 <Cale> Meh, it's not like darcs will die. The entire Haskell community uses it almost exclusively.
17:28:49 <Cale> ptolomy2: Types are allowed to be recursive and mutually recursive.
17:28:58 <EvilTerran> ptolomy2, you don't need to forward-declare
17:28:59 <dons> Cale, right, i think with the merge bug gone, and network corruption issues gone, we could get another 4 years
17:29:04 <LordBrain> ptolomy2, you know you can use  :: to specify the type right int he code right?
17:29:08 <Pseudonym> All software dies.
17:29:11 <EvilTerran> consider data Tree a = Leaf a | Branch (Tree a) (Tree a)
17:29:17 <vincenz> Booo
17:29:18 <Cale> ptolomy2: The declarations in a file are not required to be in any particular order (except that import decls must come at the top)
17:29:22 <Pseudonym> Eventually.
17:29:33 <TomMD> Pseudonym: Tell that to my Cobol programming friends.
17:29:35 <dons> we thought darcs could have taken over the world 3 years ago
17:29:37 <gwern> Cale: dunno. there are people switching from darcs. goerzen is moving to git for his many projects (like hpodder), the distract fellow was using monotone, and so on
17:29:42 <vincenz> data Tree a = Leaf | Branch a (Tree a) (Tree a)  !!!
17:29:46 <dons> darcs 1.0 had landed, and it was way beyond cvs and svn
17:29:47 <vincenz> just look how lists are made
17:29:53 <Lycurgus> (i.e. specifically completions of the theory of patches that will enhances darcs merge capabilities (or the performance thereof))
17:30:01 <ptolomy2> I'm aware of that. I mean more in the sense of "declare a type that you'll pass around only as a pointer, but will actually be defined in another file".
17:30:04 <Pseudonym> TomMD: Even those will die eventually.
17:30:08 <Lycurgus> *enhance
17:30:13 <gwern> that may be anecdotal, but how do you tell the initial defectors that start the downward spiral from random switches?
17:30:18 <EvilTerran> ptolomy2, ah, well... parameters, i guess
17:30:29 <Pseudonym> The big Cobol programs used by oversized government departments will eventually get rewritten because they must.  Though it may take 100 years.
17:30:41 <Pseudonym> Remember, 50 years ago, those programs didn't exist.
17:30:42 <Cale> People care too much about taking over the world and not enough about just creating the coolest language, libraries and software that we can. :)
17:30:56 <Pseudonym> I only care about scratching my own itches.
17:30:58 <LordBrain> it could be i just dont know how to use it right, but darcs seems like a SLOW way to download source code.
17:31:18 <Cale> LordBrain: Have you tried darcs 2?
17:31:18 <sjanssen> LordBrain: even that is improved in darcs 2
17:31:20 <dons> looks what the ion license controversy, and then maintainer abandonment announcement, did to ion: http://people.debian.org/~igloo/popcon-graphs/index.php?packages=ion3%2Cratpoison&show_installed=on&want_legend=on&want_ticks=on&from_date=2006-10-01&to_date=&hlght_date=&date_fmt=%25Y-%25m&beenhere=1
17:31:22 <lambdabot> Title: popcon graph, http://tinyurl.com/6agkjp
17:31:31 <dejones> :(
17:31:31 * EvilTerran wants himself and everything he uses to be in the category of "stupendous badass"
17:31:33 <dons> immediately a bunch of people leave, then there's a slow decline for several years
17:31:35 <gwern> Cale: taking over the world is the fastest way to get all the people for creating the libararies and software
17:31:47 <sjanssen> dons: well, droundy didn't say anything nearly like tuomov
17:31:49 <EvilTerran> Cryptonomicon style
17:31:55 <Pseudonym> BTW, darcs will dies, but I'm certain that it will have a successor.
17:31:59 <dons> no, i think we'll see very little immediate abandonment
17:32:03 <Cale> gwern: It's also the fastest way to lock the language into stagnation.
17:32:06 <gwern> dons: is red ion?
17:32:09 <Pseudonym> Which will live for a bit longer.
17:32:10 <dons> and liekly a 4+ year tail as it falls off
17:32:23 <vincenz> what's ion?
17:32:25 * ptolomy2 will probably resort to begging for help on -cafe.
17:32:27 <dons> if darcs 2.0 is more stable, it may live on for a lot longer
17:32:30 <dejones> it did have some of the desired effect... I was interested in trying to contribute to darcs, but the follow-up emails made me feel like it wasn't worth it.   :/
17:32:32 <Cale> gwern: The more users the language has, the harder it becomes to change.
17:32:39 <EvilTerran> ptolomy2, did you paste? i may've missed it
17:32:41 <Pseudonym> Oh, I agree that darcs won't die soon.
17:32:43 <dons> gwern: yes, see the key at the bottom
17:32:53 * dejones is lagging really bad.
17:32:56 <EvilTerran> Cale, so you invent a new language that looks a bit like the old one!
17:32:57 <Pseudonym> If nothing else, it's still the best thing I've found for managing code where everything is local.
17:33:07 <Pseudonym> Especially if your needs aren't modest.
17:33:10 <Pseudonym> are modest
17:33:11 <gwern> ah. oops
17:33:18 <Pseudonym> One of these days, I'm going to put /etc in darcs.
17:33:23 <Cale> EvilTerran: We might have to do that already.
17:33:34 <EvilTerran> yes, quite
17:33:41 <EvilTerran> i'm thinking about how i'm gonna do it already :D
17:33:43 <gwern> impressive drop. in like a month the userbase is cut in half and then some
17:33:55 <Cale> I'm so not interested in getting stuck with this Prelude.
17:33:57 <gwern> Pseudonym: I hear that's a bad thing to do because of permissions
17:34:03 <Pseudonym> Oh, good point.
17:34:14 <Pseudonym> OK, my dot files then.
17:34:19 <dons> gwern: note how ratpoison immediately benefitted.
17:34:22 <dons> right place, right time.
17:34:48 <LordBrain> Cale, we want to take over the world, so that we can use it at our work
17:34:49 <gwern> dons: indeed. question is, why?
17:35:00 <ptolomy2> EvilTerran: No, I didn't paste. Due to my li'l cyclical dependency, my 'stuff that touches the innards of my State and whatnot' module is 500+ lines and it isn't immediately clear to non-me people what parts are relevant.
17:35:09 <gwern> ratpoison is more different from ion than stuff like wmii, I thought
17:35:18 <EvilTerran> can we at least see your type?
17:35:20 <Cale> LordBrain: heh, I don't really have much interest in writing commercial software for the time being, so that doesn't work for me :)
17:35:22 <EvilTerran> i'm curious
17:35:42 <Pseudonym> LordBrain: So you don't want to take over the world, just your workplace.
17:35:49 <LordBrain> well i wouldnt either i suppose if i was wealthy enough
17:35:50 <Pseudonym> And your next workplace.
17:35:59 <LordBrain> yeah
17:36:55 <dons> so time to hunt for a new cutting edge niche for some haskell to jump into
17:36:58 <TomMD> lol, "This is the darcs darcs repository"
17:37:14 <Cale> dons: It is funny though, how there was this big spike in ratpoison users, and then they were all like "oh, shit, what am I doing using ratpoison?"
17:37:20 <dons> distributed bug trackers? parallel web servers?
17:37:21 <glen_quagmire> in type theory what's the difference between \/a.b  and /\a.b  where \/ is universal quantifier and /\ is type abstraction.  /\a.b   I understand this as taking a type and returning a type. not sure about \/a.b
17:37:26 <dons> Cale: right :)
17:37:30 <dons> they freaked out.
17:38:06 <Cale> glen_quagmire: It makes the type polymorphic.
17:38:43 <dons> http://people.debian.org/~igloo/popcon-graphs/index.php?packages=darcs%2Cmercurial%2Cgit&show_installed=on&want_legend=on&want_ticks=on&from_date=2006-10-01&to_date=&hlght_date=&date_fmt=%25Y-%25m&beenhere=1
17:38:44 <lambdabot> Title: popcon graph, http://tinyurl.com/6okzj9
17:38:47 <glen_quagmire>  /\a.b  return value (type) depends on a.   \/a.b  return value depends on nothing. <--  can I say this?
17:38:47 <Cale> glen_quagmire: There's an implicit forall at the start of all Haskell type signatures which captures all the type variables.
17:38:48 <dons> is an interesting graph
17:38:51 <dons> darcs is still very competitive
17:38:56 <byorgey> glen_quagmire: for example, the type of reverse is forall a. [a] -> [a], which in your notation would be written \/a.[a] -> [a]
17:39:07 <dons> git has only just recently overtaken darcs in use
17:39:24 <Cale> glen_quagmire: (/\a. b) is not a type, it's a type function, whereas (forall a. b) is indeed a type
17:39:31 <gwern> now that's strange. why is mercurial so popular?
17:39:40 <vincenz> Cale: a poly type
17:39:45 <Cale> vincenz: right
17:39:55 <byorgey> Cale: /\a . b is a type in a dependently typed language, just not in Haskell, right?
17:39:57 <Syzygy-> gwern: Possibly because it has a stated design goal of making the transition from cvs/svn painless.
17:40:04 <Saizan> well, in (/\a.b) b is a term, not a type.
17:40:04 <glen_quagmire> what's the need of forall  when you just do reverse :: [a] -> [a]  ?
17:40:06 <Syzygy-> That certainly was what made me look into mercurial to begin with.
17:40:11 <Cale> byorgey: It doesn't have the right kind.
17:40:20 <Saizan> while in \/a.b both b and a are types
17:40:38 <byorgey> Cale: how's that?
17:40:49 <gwern> Syzygy-: there are that many people abandongin subversion?
17:40:50 <Cale> byorgey: It takes a type parameter and gives a type.
17:41:07 <Cale> (/\a. b) is effectively a type constructor
17:41:08 <byorgey> glen_quagmire: the type [a] -> [a] really has an implicit 'forall a.' at the beginning.
17:41:24 <Syzygy-> gwern: I dunno. But most people transitioning into DCVS will have had CVS experiences previously.
17:41:30 <byorgey> Cale: ah, right, I see.
17:41:30 <Syzygy-> And most of those with something in the SVN family
17:41:38 <Saizan> Cale: sure? i've always seen that b is a term there
17:41:38 <Cale> For instance (/\a. [a] -> [a]) Char is the same as [Char] -> [Char]
17:42:16 <Cale> Saizan: Perhaps you've seen different formalisms than I have.
17:42:22 <dons> looking at that graph, a 10 year tail off for darcs seems reasonable
17:42:36 <glen_quagmire> (\/a. [a] -> [a])[a := Char]   isn't this same as [Char] -> [Char] again?
17:42:38 <Cale> Saizan: Some even don't really make a distinction between types and terms.
17:42:40 <Saizan> Cale: e.g. id : \/a. a -> a = /\a.\x:a. x
17:42:41 <byorgey> well, let's not bury darcs quite yet =)
17:42:50 <glen_quagmire> oh i start to see the difference
17:43:09 <EvilTerran> ?localtime
17:43:11 <byorgey> all it would take is for some enthusiastic new hackers to join and contribute, it could be revived
17:43:11 <lambdabot> Local time for EvilTerran is Tue Apr 08 01:43:08
17:43:17 <dons> byorgey: true enough.
17:43:19 <EvilTerran> yeah, TTGTB
17:43:28 <gwern> yeah, seriously. there's a lot that could be done for darcs. libdarcs it, cabalize both halves, scrap the packedstrings, and you're a big way towards making it easier to hack on
17:43:38 <dons> i think we can get everyone at te hackathon trying out darcs 2.0
17:43:51 <byorgey> I must confess I have considered hacking on darcs myself, at times, and I still might
17:43:52 <Saizan> Cale: yeah, in those i'd expect to just use a lambda
17:43:57 <byorgey> dons: yeah, good idea
17:43:59 <dons> i wish darcs had an obvious purely functional core like xmonad
17:44:04 <vincenz> hackathons are great for blowing life into projects
17:44:10 <byorgey> dons: it doesn't?
17:44:26 <dons> well, if it is, its twisted into a knot with lots of scary stuff
17:44:33 <byorgey> fair enough
17:44:43 <byorgey> I looked at the darcs code once, it is indeed quite scary
17:44:45 <gwern> (the patch algebra looks as functional as xmonad's zippers to me, but I've never looked at the math really...)
17:45:04 <dons> yeah, the algebra could surely be done with just some database/patch io skin
17:45:14 <dons> now that the model has been sorted out
17:45:32 <gwern> byorgey: I wanted to make .darcs an option, instead of always _darcs, but it was impossible...
17:46:00 <SamB> gwern: how so?
17:46:02 <byorgey> heh
17:46:05 <SamB> I can't see why...
17:46:28 <Cale> Saizan: I think maybe we're thinking about different type lambdas :)
17:46:34 <gwern> SamB: because the string "_darcs" is hardcoded all over the place, and I didn't see anyway to smuggle around the config information
17:46:42 <SamB> gwern: eh?
17:46:44 <byorgey> yuck
17:46:50 <EvilTerran> eew
17:46:53 <SamB> it can be done
17:47:00 <vincenz> grep
17:47:13 <SamB> the solution may be yucky....
17:47:16 <byorgey> sed
17:47:26 <vincenz> lolcatz sed grep
17:47:58 <gwern> SamB: and it would be far from easy, here, let me show you a quick grep output
17:48:15 <SamB> gwern: you were implying that it was impossible, though
17:48:20 <gwern> (not all of them are this problem, obviously)
17:48:55 <gwern> oy
17:48:57 <ruud> i am using wx haskell to create a text editor and i am having problems creating a find and replace function could you help?
17:49:18 <glen_quagmire> findAndReplace = replace . find
17:49:23 <glen_quagmire> i'm kidding sorry
17:49:40 <vincenz> of course you are
17:49:41 <vincenz> they are monadic
17:49:50 <vincenz> findAndReplace = find >>= replace
17:49:54 <Cale> ruud: Could you be more specific about what the trouble is?
17:50:13 <SamB> it's obviously findAndReplace pattern replacement = find pattern >>= replace replacement
17:50:45 <sw17ch> what do replacements look like syntactically?
17:51:17 <ruud> i dont know how to write the function
17:51:34 <glen_quagmire> ruud: maybe regular expressions?
17:52:09 <ruud> what do you think cale?
17:52:39 <glen_quagmire> :t findSubstring
17:52:40 <lambdabot> Not in scope: `findSubstring'
17:52:58 <EvilTerran> ?hoogle indexs
17:52:59 <lambdabot> No matches found
17:53:02 <EvilTerran> ?hoogle index
17:53:02 <lambdabot> Data.Ix.index :: Ix a => (a, a) -> a -> Int
17:53:02 <lambdabot> Data.ByteString.index :: ByteString -> Int -> Word8
17:53:02 <lambdabot> Data.Sequence.index :: Seq a -> Int -> a
17:53:03 <Cale> ruud: Well, uh, you likely need a dialog box to take the inputs from the user for what string they want to find and what they want to replace it with.
17:53:40 <Cale> ruud: Then, depending on how the feature will work, you'll need various functions for locating and replacing strings in your text.
17:53:54 <ruud> i did the dialog box already
17:54:07 <araujo> hello
17:54:14 * araujo uploading new himerge web site
17:54:27 <EvilTerran> ?type \needle haystack -> findIndex (needle `isPrefixOf`) (tails haystack)
17:54:28 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe Int
17:54:37 <byorgey> ruud: so you need help implementing a function to actually do the replacing?
17:54:57 <EvilTerran> > (\needle haystack -> findIndex (needle `isPrefixOf`) (tails haystack)) "ra" "abracadabra"
17:54:58 <lambdabot>  Just 2
17:55:27 <EvilTerran> there's almost certainly a better way of doing it than mucking around with indices, mind
17:55:47 <EvilTerran> zippers!
17:56:00 <ruud> yes byorgey
17:56:12 <glen_quagmire> http://en.wikipedia.org/wiki/String_functions_(programming)#Find  oh no haskell version
17:56:28 <Cale> Typically, these search and replace functions take a needle, a replacement needle, a haystack, a point in the haystack, and return a modified version of the haystack wherein the first occurrence of the needle after the point is replaced by the replacement needle
17:57:41 <Cale> Alternately, you could have your 'find' separate the string into three parts: the part of the text before the found string, the found string, and the part of the text after it
17:58:25 <ruud> how would i implement it?
17:58:33 <Cale> (and of course, it again has to find the first occurrence following a given point, because you'll probably want to hit the find button multiple times to find the next instance)
17:59:01 <Cale> I would probably use tails.
17:59:25 <ruud> could you write this function for me please i'm in a crunch
17:59:46 <EvilTerran> that's not really our style
17:59:57 <EvilTerran> if we write one function for someone, that sets a nasty precedent
18:00:03 <glen_quagmire> i would want to but im not good enough
18:00:09 <Cale> http://haskell.org/haskellwiki/Homework_help
18:00:10 <dobblego> we only write id for people
18:00:17 <Syzygy-> EvilTerran: Awwwww. Can't you PLEEEEEEEEZ write me a fibonacci?
18:00:17 <EvilTerran> soon everyone will be coming to us to write their functions for them, and no-one but us would learn anything
18:00:30 <vincenz> can ai haz fonctions?
18:00:34 <Cale> We can help you write it, but you should at least give us an attempt :)
18:00:39 * EvilTerran tries to think of the worst possible implementation of the fibbonacci sequence
18:01:02 <vincenz> EvilTerran: the regular definition, no memoization, with church numerals
18:01:13 <glen_quagmire> erlang style fib:  fib = 42
18:01:21 <bd_> vincenz: Implemented using the SK calculus.
18:01:34 <ruud> you are probably right
18:01:36 * araujo just uploaded new site
18:01:44 <paczesiowa> using only iota combinator
18:01:55 <vincenz> on top of a white-space interpreter
18:02:06 <Cale> X (X X) (X X) ((X X) X X (X X))
18:02:21 <paczesiowa> no, run through ghc to C:>
18:02:29 <atsampson> well, that's got to be the most obscure smiley I've ever seen
18:02:41 <Saizan> has Henk been used in GHC or any other compiler?
18:02:43 <vincenz> C:>
18:02:53 <glen_quagmire> > let { f l = 1 : l; a (x:xs) (y:ys) = (x+y) : a xs ys; (s1, s2, s3) =  (f s2, f s3, a s1 s2); fib n = s1 !! n; } in fib 100
18:02:54 <lambdabot>  573147844013817084101
18:02:55 <Cale> C:\>
18:03:07 <vincenz> glen_quagmire: is that fast?
18:03:26 <glen_quagmire> vincenz: nope. your array version was the fastest i've seen
18:03:47 <vincenz> Well it's not mine, I based it on a blog article on an implemenation in ruby
18:03:57 <vincenz> Except the haskell version is 10x more legible (and shorter)
18:04:11 <slava> what are we implementing here?
18:04:18 <vincenz> slava: fibonacci of course :D
18:04:25 <EvilTerran> fibonnacci, as badly as possible
18:04:33 <Syzygy-> slava: On a code request from m e.
18:04:38 <glen_quagmire> that is infinite stream version of fibonacci from text book
18:04:48 <vincenz> EvilTerran: I know, fibonacci on top of church numerals in the type system
18:04:53 <vincenz> xD
18:04:54 * EvilTerran tries to remember if the fibonacci sequence is derivable pascal's triangle anywhere
18:05:01 <EvilTerran> +from
18:05:07 <EvilTerran> vincenz, i'm sorely tempted, actually
18:05:17 <vincenz> Should'n't be too hard really
18:05:43 <vincenz> Is there a way to go from (undefined :: Type) to a string representation of that type?
18:06:12 <vincenz> oh wait, just use another typeclass
18:06:12 * vincenz goes of
18:06:12 <scook0> via Typeable, perhaps
18:06:12 <vincenz> nah
18:06:12 <vincenz> class Numeric a where
18:06:13 <vincenz>   a -> Integer
18:06:18 <Saizan> > typeOf (undefined :: Int)
18:06:19 <lambdabot>  Int
18:06:28 <vincenz> that would get pretty illegible with all those S
18:06:41 <TSC> dynTypeRep
18:06:48 <atsampson> vincenz: you can probably do it with Data.Generics...
18:06:58 <vincenz> slava: when will you learn?
18:07:03 <vincenz> slava: haskell is all about fibonacci :)
18:07:38 <atsampson> yes -- show (typeO... oh, Saizan beat me to it
18:07:55 <vincenz> thx
18:08:04 <vincenz> :t typeOf
18:08:05 <lambdabot> forall a. (Typeable a) => a -> TypeRep
18:08:30 <Botje> is there a paper or explanation as to how and why typeable works?
18:08:57 <Syzygy-> EvilTerran: Aren't the numbers of the middle column of the Pascal triangle every other fibonacci number or something like that?
18:09:02 <atsampson> yes; "Scrap Your Boilerplate"
18:09:50 <Botje> ah, cool
18:09:57 <Botje> i just found that paper :)
18:10:13 * Botje files under: "read with duct tape at hand"
18:10:49 <sohum> this is a trivial question, but is it possible to use  instead of \ in lambda expressions?
18:10:59 <Botje> there's a ghc extension for it
18:11:11 <Cale> > [product [1..2*n] `div` (product [1..n]^2) | n <- [1..10]]
18:11:12 <lambdabot>  [2,6,20,70,252,924,3432,12870,48620,184756]
18:11:15 <Cale> > [product [1..2*n] `div` (product [1..n]^2) | n <- [0..10]]
18:11:16 <lambdabot>  [1,2,6,20,70,252,924,3432,12870,48620,184756]
18:11:16 <tromp> hmm, that's an ugly lambda
18:11:23 <Cale> @oeis 1,2,6,20,70,252,924,3432
18:11:23 <lambdabot> Central binomial coefficients: C(2n,n) = (2n)!/(n!)^2.
18:11:23 <lambdabot> [1,2,6,20,70,252,924,3432,12870,48620,184756,705432,2704156,10400600,40116600...
18:11:45 <Cale> sohum: Not in GHC.
18:11:56 <Cale> (Or in standard Haskell)
18:11:58 <tromp> at least on my Konsole; almost looks like an A
18:12:08 <Cale> tromp: Maybe a bad font.
18:13:05 <sohum> Cale: not possible with any ghc extensions, either?
18:14:10 <Syzygy-> Cale: So that's a "no", right?
18:14:20 <Cale> sohum: No, but one extension allows you to use Greek letters in identifiers.
18:14:31 <Cale> (and other unicode characters)
18:16:11 <tromp> right Cale; I just switched to Lucida Console and the lambda looks good now
18:16:16 <sohum> hm... maybe i'll have better luck forcing vim to display it as lambda...
18:16:26 <sohum> thanks guys
18:16:28 <Cale> sohum: That's a possibility.
18:16:38 <Cale> sohum: I know some people do something like that with emacs.
18:16:46 <davidL> http://www.emacswiki.org/cgi-bin/wiki/PrettyLambda
18:16:47 <lambdabot> Title: EmacsWiki: Pretty Lambda
18:17:26 <vincenz> woot
18:17:33 <Cale> gwern in particular, I think has a module for that
18:19:19 <SamB> JHC is always spewing stuff in unicode...
18:19:47 <vincenz> \o/
18:19:54 * vincenz is crashing ghci
18:19:58 <vincenz> main = print . value . fib . S . S . S . S . S . S . S . S . S . S . S . S . S . S . S $ (undefined :: Nat)
18:20:27 <SamB> it looks a bit ugly when I connect using Putty, because nearly every :: in the "E" (JHC's "core" language) code is displayed as a green rectangle...
18:20:31 <sohum> oh, while I'm here.
18:20:40 <sohum> > let twice f = f.f
18:20:41 <lambdabot>  Parse error at end of input
18:20:42 <vincenz> Fibonacci.hs:1:0: Context reduction stack overflow; size = 20 Use -fcontext-stack=N to increase stack size to N
18:22:00 <vincenz> http://hpaste.org/6906
18:22:11 <sohum> weird. ok...
18:22:31 <vincenz> sohum: let ... in ...
18:22:37 <sohum> ?type (foldl (++) []) . (foldl (++) [])
18:22:38 <lambdabot> forall a. [[[a]]] -> [a]
18:22:42 <sohum> that works.
18:22:56 <Pseudonym> ?type join . join
18:22:57 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m (m a)) -> m a
18:22:59 <vincenz> > let twice f = f.f in f
18:22:59 <lambdabot>  Add a type signature
18:23:06 <sohum> let twice f = f.f in twice (foldl (++) [])
18:23:11 <vincenz> EvilTerran: chech that link
18:23:16 <sohum> ?type let twice f = f.f in twice (foldl (++) [])
18:23:16 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
18:23:17 <lambdabot>       Expected type: [[a]] -> [[a]]
18:23:17 <lambdabot>       Inferred type: [[a]] -> [a]
18:23:19 <EvilTerran> i see it :)
18:23:29 <Pseudonym> ?type join . liftM join
18:23:30 <sohum> why does that happen?
18:23:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m (m a)) -> m a
18:23:35 <EvilTerran> sohum, the problem there is the type of (.)
18:23:42 <vincenz> Yay for :r
18:23:48 <EvilTerran> ?type (P..)
18:23:49 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
18:24:12 <sw17ch> did anything become of this? http://www.cs.rit.edu/~bja8464/lambdavm/
18:24:13 <lambdabot> Title: LambdaVM - The Haskell to Java Translator
18:24:21 <EvilTerran> ?type \f -> f . f
18:24:22 <lambdabot> forall b. (b -> b) -> b -> b
18:24:43 <EvilTerran> sohum, the return type of the RHS has to be the same as the parameter type of the LHS, as the type of (.) states
18:24:56 <sohum> ?type (foldl (++) []) . (foldl (++) [])
18:24:57 <lambdabot> forall a. [[[a]]] -> [a]
18:25:02 <sohum> ^ that uses . as well.
18:25:16 <EvilTerran> so, if both sides're the same (f), that f needs to take as parameter the thing it returns
18:25:31 <EvilTerran> s/thing/same type as/
18:25:48 <EvilTerran> yes, but then the two concats have different types
18:26:02 <EvilTerran> one is [[a]] -> [a], and the other is [[[a]]] -> [[a]] (for the same a)
18:26:06 * sohum sees the light.
18:26:09 <sohum> oooooooh.
18:26:45 <EvilTerran> the problem is the placement of the forall in the type of (.) (when you're using explicit foralls, which are an extension. but they help explain things)
18:27:05 <EvilTerran> (.) :: forall a b c. (b -> c) -> (a -> b) -> a -> c
18:27:25 <EvilTerran> b has to be the same in both cases, because they're both captured by the same forall
18:28:02 <sohum> I see...
18:28:29 <EvilTerran> ?type let twice :: (forall a. [[a]] -> [a]) -> [[[a]]] -> [a]; twice f = f . f in f
18:28:30 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
18:28:31 <EvilTerran> ?type let twice :: (forall a. [[a]] -> [a]) -> [[[a]]] -> [a]; twice f = f . f in twice -- even
18:28:32 <lambdabot> forall a. (forall a1. [[a1]] -> [a1]) -> [[[a]]] -> [a]
18:29:03 <EvilTerran> in that one, the two uses of "f" are allowed to use different types for "a1"
18:29:10 <EvilTerran> in one case, a1 = a. in the other, a1 = [a]
18:29:49 <EvilTerran> unfortunately, you can't write a generic "twice", even with explicit foralls
18:29:57 <sohum> so you need to explicitly tell it the types are different...
18:30:18 <EvilTerran> well, that they *can* be
18:30:25 <sohum> right.
18:30:35 <EvilTerran> but just giving the parameter the type (forall a b. a -> b), say, wouldn't be very useful
18:31:00 <EvilTerran> because, sure, it could take anything in the parameter, it could also *return* anything
18:31:36 <EvilTerran> so you couldn't do anything with the return value, as you wouldn't be able to tell at the typechecking stage which not-completely-polymorphic functions you could call on it
18:31:51 * sohum nods.
18:32:20 <EvilTerran> (forall a. a) is as abstract as you get, and, as such, is completely sodding useless
18:32:26 <EvilTerran> i'm sure there's a moral in there somewhere ;)
18:32:32 <sohum> hehe
18:33:35 <EvilTerran> if you want to do something with the returned value, it either has to have a constructor involved, or be constrained to a typeclass
18:33:56 <EvilTerran> (forall a. Show a => a) is a little more useful - you can pass it to show, for instance!
18:34:39 <EvilTerran> (forall a. Typeable a => a) is actually getting into the vaguely useful stuff, as - if you (as the programmer) know what "a" must be, you can get the value out with Data.Typeable.cast
18:35:02 <mauke> (forall a. Show a => a) better written as String
18:35:14 <sohum> I like Haskell's version of strong typing and all, but yeeesh...
18:35:33 <EvilTerran> this is a minor limitation, but it doesn't come up often in practice
18:36:02 <sohum> It came up in my fifth Haskell program! 
18:37:05 <sohum> anyways, haveta go to class. thanks for the help, EvilTerran.
18:37:17 <Botje> > foldl
18:37:17 <lambdabot>  Add a type signature
18:37:22 <Botje> blarf
18:37:35 <Botje> the SYB paper is very interesting
18:37:36 <dino-> Question for my Windows-using friends.. When you install the GHC in binary form, do you really need cygwin to do anything serious like build cabal packages?
18:38:27 <Saizan> no
18:39:07 <dino-> Or can you get by with the Microsofty cmd thinger for many things.
18:39:36 <Saizan> the latter.. there's also a non-cygwin GHC build, no?
18:39:48 <SamB> I don't think there is a cygwin GHC build
18:39:48 <dino-> I'd like to avoid building GHC in this case.
18:40:02 <dino-> ok s/this/every/
18:40:18 <Saizan> it might get more problematic if the package you're building requires an external C lib
18:40:21 <SamB> based on some things I've seen in the makefiles...
18:40:24 * EvilTerran plays with Data.Dynamic
18:40:26 <dino-> yeah
18:40:41 <dino-> I can control that for a while, we'll be building things I write for starters.
18:40:55 <dino-> in 100% Haskell
18:41:04 <SamB> they imply that, even if you do build using Cygwin (which is likely required), you end up with a mingw binary...
18:41:13 <dino-> mm
18:41:59 <dino-> I'm working on a project for a friend and am basically trying to avoid having to hunker down and install a VM with Windows in it on one of my Linux systems, is what this is all about. Hoping to offload native Windows binary build to the other party.
18:43:12 <Saizan> dino-: when i was on windows i was pleased with how smooth cabal worked :)
18:43:31 <Saizan> and i was using cmd.exe
18:43:42 <dino-> Great. Thank you guys. I hope I don't get into sad missing Posix stuff.
18:43:44 <dino-> ok
18:43:46 <dino-> great
18:46:52 <sjanssen> dino-: most packages don't need cygwin
18:47:07 <sjanssen> though some use configure scripts which require a /bin/sh
18:47:16 <adu> hi
18:48:54 <jeffz> hi dino-, you can use the windows version of ghc on GNU/linux
18:51:02 <jeffz> dino-: it works under wine, just grab an up to date copy of wine from http://winehq.org/download and you can build your Haskell programs for windows without a vm.
18:51:05 <lambdabot> Title: Wine HQ - Wine Binary Downloads
19:04:31 <dino-> sjanssen: Ok, I'll cross that cygwin bridge when it comes up.
19:04:36 <dino-> jeffz: Really? huh
19:04:53 <dino-> That would be much cooler than installing a whole XP in a vm.
19:05:18 <dino-> Thank you everyone for the good idea.
19:05:20 <dino-> ideas.
19:08:09 <gwern> (hm. this HXT thing on -cafe is odd)
19:10:54 <gwern> hm. If I understand Haskell syntax right, 'option { foo = bar, baz = qiix }' can't be right, since 'option' would be a function and not some sort of type/record constructor
19:11:42 <dino-> I'm shaky on it too, but isn't that use the already-constructed option but with the foo and baz modifications?
19:11:48 <dons> option is a value of some record type
19:11:59 <dons> and you're updating 2 fields
19:12:54 <Cale> > Branch 3 [Branch 1 [], Branch 2 []]
19:12:54 <lambdabot>   Not in scope: data constructor `Branch'
19:13:19 <dino-> Like: similarToOption = option { foo = bar, baz = qiix }
19:13:42 <Cale> Oh, right, Node
19:13:52 <Cale> > Node 3 [Node 1 [], Node 2 []]
19:13:52 <lambdabot>  Node {rootLabel = 3, subForest = [Node {rootLabel = 1, subForest = []},Node ...
19:14:05 <Cale> > let myTree = Node 3 [Node 1 [], Node 2 []] in myTree { rootLabel = 5 }
19:14:06 <lambdabot>  Node {rootLabel = 5, subForest = [Node {rootLabel = 1, subForest = []},Node ...
19:14:06 <bd_> :t Node
19:14:07 <lambdabot> forall a. a -> Forest a -> Tree a
19:14:19 <Cale> (there's an example of the syntax :)
19:14:37 <Cale> > let myTree = Node 3 [Node 1 [], Node 2 []] in myTree { subForest = [] }
19:14:38 <lambdabot>  Node {rootLabel = 3, subForest = []}
19:15:06 <scodil> hey does anyone know any cool tricks FP/laziness tricks for updating circular lists in amortized constant time?
19:15:12 <dons> good idea, Cale, we often look for a record type in the base lib
19:15:15 <scodil> er, scratch on of those tricks
19:16:56 <Cale> scodil: That seems kind of impossible...
19:17:00 <SamB> indeed
19:17:18 <SamB> don't you kinda need to replace the whole list if you update a pure, circular list?
19:17:32 <scodil> sure. but maybe theres some way to defer the cost
19:17:33 <Cale> But probably it depends on what you consider a "circular list"
19:17:55 <dobblego> does mconcat use foldl or foldr?
19:18:03 <dobblego> ?src mconcat
19:18:03 <lambdabot> Source not found. Take a stress pill and think things over.
19:18:05 <dolio> You could work up some fancy stuff with reallyUnsafePointerEquality#.
19:18:22 <Cale> If I'm allowed to implement circular lists with non-circular finger trees, I can do it in log time :)
19:18:26 <SamB> oh, yes, if you used a "zipper" of a circular list, you could probably manage something fancy...
19:18:30 <gwern> @seen ndm
19:18:30 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 3h 27m 23s ago, and .
19:18:34 <SamB> or something like that...
19:19:03 <scodil> SamB: have you seen any such zippers? That was one of the first things i thought of when i saw the zipper, but I couldn't figure it out
19:19:26 <Cale> dobblego: foldr by default
19:19:34 <dobblego> or, why does mconcat use foldr and not foldl? I should say
19:19:41 <Cale> foldr is better
19:19:57 <LordBrain> foldr handles infinite lists
19:19:58 <Cale> > foldr (++) [] [[n] | n <- [1..]]
19:19:59 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
19:20:02 <Cale> > foldl (++) [] [[n] | n <- [1..]]
19:20:02 <pjd> foldl is in reverse
19:20:05 <SamB> foldr allows you to see the first error messages before the compiler finishes running
19:20:06 <lambdabot> Terminated
19:20:10 <dobblego> I'm unclear on why you'd want that though
19:20:12 <SamB> or warnings or whatever
19:20:18 <Cale> ^^ see above
19:21:23 <Cale> foldr is the more natural of the two, because it simply replaces list structure -- foldr f z replaces each (:) with f and the [] at the end with z
19:21:40 <dobblego> ah yes, of course, thanks
19:22:12 <Cale> foldl has to recurse all the way to the end of the list, building up huge expressions as it goes before it'll give you anything
19:22:17 <Cale> and it flips the list over
19:22:19 <pjd> with outermost-first evaluation, foldl is basically right-to-left, and foldr left-to-right
19:22:35 <dobblego> yes I understand; I just wasn't clear on why foldr was most natural
19:22:52 <pjd> the opposite of with innermost-first evaluation
19:24:01 <gwern> foldr is natural because we write our lists left to right, no? if lists went []:foo:bar instead of foo:bar:[], foldl would be the one with nice laziness properties, right?
19:24:11 <Cale> gwern: yeah
19:24:40 <SamB> it's all about dogamorphisms
19:24:42 <Cale> Everything is backward with snoc lists :)
19:25:23 * SamB waits for someone to correct him
19:25:59 <gwern> SamB: are you denigrating my catmamorphisms?
19:26:09 <gwern> Eris would be displeased to hear!
19:26:39 <gwern> >.< 'displeased to hear'? you know you've been haskelling too much when even your prose is pointless
19:26:42 <bugQ> > map (foldr1 (+)) [[1..10^n] | n <- [1..5]]
19:26:43 <lambdabot>  [55,5050,500500,50005000,5000050000]
19:26:48 <bugQ> heehee.
19:28:10 <cjs> Hey, the bot's alive again!
19:29:11 <bugQ> gwern: don't question the illogic of Discordia.
19:29:43 * gwern excommunicates bugQ for suggesting discordianism is about blind faith
19:31:29 * gwern sighs. hxt takes a while to compile. and the darcs getting is even slower
19:31:40 <SamB> I didn't know discordians had communion
19:31:54 <gwern> SamB: oh, we have plenty of it
19:32:10 <gwern> every man, woman, and child is an authentic POEE Pope
19:32:17 <Twey> Heh
19:32:28 <gwern> we have communion out the wazoo from all our hot dog eating
19:32:36 <Twey> xD
19:33:04 <gwern> at least once a week
19:33:09 <gwern> sometimes even more
19:33:20 <gwern> even the non-discordians take communion with us
19:33:49 <vincenz> scientologist?
19:34:11 <gwern> even them
19:34:21 <gwern> they contribute to chaos together with Anonymous, after all
19:34:30 <LordBrain> will perl 6 have laziness?
19:34:42 <vincenz> LordBrain: Mostly in the developers
19:34:47 * Twey grins.
19:34:49 <LordBrain> lol
19:35:00 <Twey> Procedural languages can never be lazy, LordBrain :-\
19:35:14 <Cale> actually, I think it will apparently have some lazy features
19:35:27 <Cale> Twey: *sane* procedural languages can never be lazy
19:35:33 <pjd> Twey: all control constructs are laziness
19:35:55 <Twey> Well, yes, but they can never be entirely lazy
19:36:01 <cjs> Hm. Lazyness, impatience and hubris. Haskell is already one third of a great programmer.
19:36:02 <LordBrain> hmmm you could have lazy lists in a procedural language... scheme calls them streams
19:36:02 <Cale> pjd: If one thinks of them as functions, sure :)
19:36:05 <bugQ> they're all turing machines, right?  who says you can't make it lazy?
19:36:14 <LordBrain> oh i guess scheme is functional
19:36:19 <LordBrain> hmm
19:36:40 <Cale> LordBrain: No, that's true. There's no problem with having lazy streams in an imperative language.
19:36:47 <Twey> Aye
19:36:54 <LordBrain> yeah
19:36:56 <pjd> LordBrain: that laziness just comes down to lambda (and/or delay)
19:37:01 <Twey> But they're little tucked-away pockets of laziness.
19:37:06 <Cale> You can have some lazy datastructures. It's just that going to full laziness makes things insane.
19:37:20 <SamB> what about Haskell?
19:37:30 <bugQ> it's insane, yeah.
19:37:33 <Cale> Outermost-first evaluation + side effects -> crazy
19:37:36 <Twey> Heh
19:37:40 <Twey> Yeah
19:37:59 <pjd> Cale: arguably, that holds equally for innermost-first evaluation
19:38:05 <Cale> pjd: :)
19:38:45 <SamB> ... wouldn't that be leftmost first evaluation?
19:39:40 <SamB> or, well, depth-first?
19:39:51 <pjd> well, Scheme for one doesn't specify leftmost first
19:40:08 <Cale> SamB: Well, to fully specify it, it'd be outermost leftmost first, or innermost leftmost first
19:40:13 <pjd> the parameters of an application are evaluated in undefined order
19:40:33 <SamB> Cale: you can't have an outermost leftmost
19:40:42 <SamB> there is only ONE outermost
19:40:44 <vincenz> I would say atmost onemost
19:41:46 <vincenz> SamB: Why are you changing the argument... The argument was about outermost or not
19:42:28 <Cale> SamB: The very outermost subexpression might not be reducible
19:42:46 <SamB> Cale: oh
19:42:59 <SamB> for example?
19:43:08 <Cale> (5 + 5) + 5
19:43:27 <bugQ> are there any lazy streams that are not defined recursively, i.e. two-way?
19:43:33 <SamB> you mean it isn't up to (+) which way to go first?
19:44:06 <lament> bugQ: it can be two-way but still recursive (zipper on lists)
19:44:14 <Cale> Well, okay, in Haskell that's presumably reducible to some magical case expression.
19:44:25 <SamB> that's not what I meant
19:45:07 <SamB> well, anyway, in that case it doesn't make much difference which way you go first...
19:45:21 <Cale> Of course, it never makes a difference in a pure language.
19:45:39 <SamB> @go imprecise exceptions simonpj
19:45:41 <lambdabot> http://research.microsoft.com/~simonpj/papers/imprecise-exn.htm
19:45:41 <lambdabot> Title: Simon Peyton Jones: papers
19:45:49 <Cale> I suppose if we introduce set! or something we can see the difference :)
19:46:07 <SamB> oh, true
19:46:18 <SamB> which was, uh, your point, wasn't it?
19:46:23 * SamB had forgotten
19:46:32 <Cale> I forget, I have a headache.
19:49:25 <gwern> Cale kant haskell today :)
19:51:09 <Absolute0> Would haskell be ideal for a chess engine?
19:51:57 <mm_freak> hey people  once again a type question  what's the preferred data-type for arbitrarily long (i.e. unbounded) arrays?
19:52:30 <Absolute0> haskell has arrays?
19:52:31 <cjs> You want arrays, as opposed to lists?
19:52:33 <SamB> how do you type ""?
19:52:39 <cjs> Sure. Haskell has all sorts of stuff.
19:52:50 <mm_freak> cjs: yes, i need O(1) index access
19:52:55 <SamB> unbounded?
19:53:06 <lament> mm_freak: you do realize that you need O(1) index access in an infinite data structure?
19:53:11 <Cale> mm_freak: Will log(n) indexing do?
19:53:19 <mm_freak> SamB: i have a custom xmodmap for chars like "", "" and ""
19:53:26 <Cale> mm_freak: Try Data.Sequence
19:53:28 <bd_> mm_freak: O(1) access on an infinitely large data structure is physically impossible.
19:53:42 <Cale> bd_: He's not saying infinitely long
19:53:51 <Cale> bd_: He's saying arbitrarily long :)
19:54:01 <mm_freak> Cale: yeah, i thought about Data.Sequence, but O(log n) is pretty slow =/
19:54:02 <lament> it's not possible on an arbitrarily long one, either
19:54:07 <Cale> mm_freak: No it's not.
19:54:10 <bd_> ah, but if it's sparse you can't get O(1) access, and if it's not sparse it's infinitely large
19:54:16 <mm_freak> i want to emulate the memory of a turing machine
19:54:22 <Cale> mm_freak: Unless you have exponentially expanding amounts of memory, it's fairly fast.
19:54:26 <SamB> but you can't fit an arbitrarily long datastructure in memory anyway
19:54:30 <bd_> mm_freak: in that case, use two lists
19:54:43 <SamB> mm_freak: yeah, an array is totally the wrong way to do that ;-)
19:55:01 <SamB> in Haskell it's not even the easiest
19:55:01 <mm_freak> i need fast index-based access
19:55:02 <mm_freak> lists don't do
19:55:10 <bd_> mm_freak: So, it's not a turing machine?
19:55:14 <SamB> turing machines don't do that
19:55:18 <Cale> mm_freak: A Turing machine doesn't do random access.
19:55:18 <SamB> they have heads
19:55:22 <bd_> mm_freak: what kind of accesses are you trying to do?
19:55:25 <mm_freak> hmm
19:55:37 <mm_freak> actually you're right  i don't need index access
19:55:42 <mauke> list zipper!
19:55:46 <mm_freak> ok, that already helps a lot  thank you =)
19:56:41 <mm_freak> Cale: i'll use Data.Sequence
19:57:04 <Cale> mm_freak: You could just use two lists.
19:57:14 <Cale> mm_freak: Which is probably actually faster.
19:57:28 <mm_freak> yeah, true
19:57:43 <Cale> mm_freak: The first list stores the elements to the left of the write head, in reverse order, and the second stores those after it.
19:57:52 <Cale> (in order)
19:57:54 <mm_freak> yep
19:58:37 <mm_freak> data Tape a = Tape [a] a [a]   -- like that?
20:01:00 <SamB> mm_freak: more or less
20:01:16 <bugQ> feedl (Tape ls x (r:rs)) = Tape (x:ls) x rs, etc.
20:01:20 <bugQ> that works.
20:01:29 <bugQ> neat
20:01:54 <SamB> bugQ: you messed uup
20:02:03 <bugQ> ups, where?
20:02:10 <mm_freak> though i'm gonna use (Tape a [a] [a]) instead  i wonder how that behaves in recursive calls
20:02:14 <SamB> you have no r on the right sidde
20:02:25 <SamB> and two xs
20:02:37 <SamB> mm_freak: I don't think it makes a difference
20:02:41 <bugQ> oh duh.  the second x should be an r.
20:03:02 <SamB> also, you might need to do something if you hit the end of the tape?
20:03:10 <SamB> or I guess you could start with infinite tape...
20:03:15 <kpreid> infiniteTape (x:xs) = Tape (repeat 0) x (xs ++ repeat 0)
20:03:23 <mm_freak> SamB: i mean generally  i'm afraid that there will be some implicit copying, which i need to work around
20:03:25 <SamB> but that probably would be harder to debug and so on?
20:03:35 <SamB> mm_freak: implicit copying?
20:03:47 <vincenz> kpreid: infiniteTape . infiniteTape $ []
20:03:55 <mm_freak> well, no  forget about it
20:04:08 <kpreid> vincenz: hmm?
20:04:22 <bugQ> feedl (Tape ls x []) = ..?
20:04:25 <mib_fj6pagwl> Hi Haskell gurus! I have a quick question here: I see tail implemented as (subtract 10.length>>=drop ), my question is what monad  is used here? looks like a mix of List and State.
20:04:27 <mm_freak> ok, thanks to all
20:05:03 <vincenz> mib_fj6pagwl: list monad
20:05:19 <vincenz> or, err...wait
20:05:26 <vincenz> :t subtract 10 . length >>= drop
20:05:27 <lambdabot> forall a. [a] -> [a]
20:05:51 <vincenz> reader monad
20:05:51 <vincenz> sorry
20:06:17 <mm_freak> :t (subtract 10 . length) >>= drop
20:06:18 <lambdabot> forall a. [a] -> [a]
20:06:48 <mm_freak> vincenz: how do you know?
20:06:58 <vincenz> mm_freak: lenght and drop both take a list as parameter
20:07:05 <vincenz> readerm onad supplies it's input value to all actions
20:07:18 <bd_> wouldn't tail be drop 1?
20:07:23 <mib_fj6pagwl> i read about the Reader monad somewhere, let me check
20:07:35 <bugQ> ?pl drop 1
20:07:35 <lambdabot> drop 1
20:07:51 <scook0> strictly speaking it's the ((->)r) monad
20:07:55 <bd_> @check \l -> ((subtract 10 . length) >>= drop) l == (take 10 l :: [Int])
20:07:56 <lambdabot>  Falsifiable, after 35 tests: [4,19,2,-19,-5,19,-13,14,-12,-9,-6]
20:08:05 <bugQ> ?src tail
20:08:05 <lambdabot> tail (_:xs) = xs
20:08:05 <lambdabot> tail []     = undefined
20:08:09 <Cale> That seems like a bad way to implement that function by the way
20:08:13 <mm_freak> vincenz: IMO >>= forwards an Int
20:08:16 <bd_> oh, takes last 10
20:08:23 <vincenz> :t (>>= drop)
20:08:24 <lambdabot> forall a. ([a] -> Int) -> [a] -> [a]
20:08:38 <vincenz> nope
20:08:46 <vincenz> the action returns an int
20:08:57 <mm_freak> the action should return a function
20:09:01 <bugQ> oh duh, forgot about undefined.  so: feedl (Tape ls x []) = undefined
20:09:02 <vincenz> the action, however is a reader monad action, thus eventually taking an input, namely a list
20:09:28 <gwern> @seen dons
20:09:29 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc and #haskell. I last heard dons speak 54m 16s ago.
20:09:47 <Twey> What's hac4?
20:10:13 <Cale> > ap (zipWith (flip const)) (drop 10) [1..20]
20:10:14 <lambdabot>  [11,12,13,14,15,16,17,18,19,20]
20:10:18 <gwern> @tell dons I've tried to address the negative comments on darcs; hope I didn't omit any of our points: http://reddit.com/info/6ewbq/comments/c03nonh
20:10:18 <lambdabot> Consider it noted.
20:10:21 <Cale> That's a much better way to do the same.
20:10:29 <gwern> Twey: hackathon
20:10:34 <Twey> Ahh
20:10:34 <thoughtpolice> Twey: fourth haskell hackathon
20:10:37 * Twey nods.
20:10:38 <gwern> people get together and in person work on stuff
20:10:55 <gwern> good stuff comes out of it. nothing like hanging out in person with other haskellers
20:10:58 <thoughtpolice> gwern: btw, did you have fun playing with ditz?
20:11:30 <Cale> length is evil :)
20:11:47 <SamB> how so?
20:12:16 <Cale> > ((subtract 10 . length) >>= drop) [1..]
20:12:19 <lambdabot> Terminated
20:12:20 <jcreigh> SamB: doesn't work on infinite lists.
20:12:21 <bugQ> because it unravels the whole list?
20:12:29 <Cale> > ap (zipWith (flip const)) (drop 10) [1..]
20:12:29 <lambdabot>  [11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,...
20:12:37 <SamB> because it ain't genericLength!
20:12:43 <gwern> thoughtpolice: I did, a little. I think I'm going to wait until they mature a bit more before I try cloning it for use with darcs tho. it's nice, but I think they'll find some improvements
20:12:54 <Cale> er
20:12:59 <Cale> > drop 10 [1..]
20:12:59 <lambdabot>  [11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,...
20:13:03 <thoughtpolice> gwern: i do think it's a bit immature, but it's a good step.
20:13:53 <Cale> oh, hmm
20:14:05 <Cale> This is take from end?
20:14:09 <Cale> I see, yeah
20:14:12 <gwern> kind of interesting how much new software seems to be out lately. FF3, emacs 23, a new zsh, xmonad .6-.7, ghc 6.8.x, darcs 2.0, and so on
20:14:24 <gwern> I think the only major programs I use without a recent release are mutt and irssi
20:14:59 <thoughtpolice> gwern: btw the guy who wrote ditz wrote my mail client of choice these days: http://sup.rubyforge.org. i like it a lot more than mutt, at least.
20:15:03 <lambdabot> Title: Sup
20:15:03 <Cale> There still ought to be a decent way to do that without length, let me think :)
20:15:21 <thoughtpolice> gwern: also isn't emacs 23 still in development? i thought it was emacs 22.2 that came out
20:15:38 <gwern> thoughtpolice: really? what does it do better?
20:16:05 * bugQ takes Tape and runs with it for monad practice
20:16:33 <dolio> 22 still doesn't have freetype/antialiasing support, I think.
20:17:03 <thoughtpolice> gwern: i was way too lazy to get proper threading to work with mutt; sup does it by default and it's nice. it differs a little in terms of how it deals with threads and its index. the only complaint I have is it is somewhat slow; 0.4 is a lot better than 0.3 though, by a landslide
20:17:22 <gwern> thoughtpolice: hm, maybe. alright, 22 then
20:17:35 <thoughtpolice> but it handles extremely large amounts of mail better than I initially thought it would; it can track LKML fairly well.
20:17:54 <gwern> thoughtpolice: oh, is that all? I think I have threading in mutt. so it wouldn't be worthwhile to switch
20:18:07 <thoughtpolice> only complaint with sup: doesn't seem to be a good way to have keyboard macros, so I can't just 'G' and run getmail
20:18:15 <thoughtpolice> but I have it set up on cron anyway so it's not that big of a deal
20:19:35 <gwern> (also, no sup in gentoo)
20:19:49 <thoughtpolice> $ gem install sup
20:22:01 <bugQ> would it be that bad to get rid of the "current" tape element, to allow empty tapes?
20:22:09 <bugQ> data Tape a = Tape [a] [a]
20:23:16 <bugQ> oh, but could it still be a monad? hmm.
20:26:15 <mauke> @hoogle exit
20:26:15 <lambdabot> System.Exit :: module
20:26:15 <lambdabot> System.Exit.exitWith :: ExitCode -> IO a
20:26:15 <lambdabot> System.Exit.exitFailure :: IO a
20:26:22 <Cale> Oh right, yeah, the right way to implement that function is  last $ zip (tails xs) (drop (n+1) xs)
20:26:24 <Cale> er
20:26:29 <Cale> fst . last $ zip (tails xs) (drop (n+1) xs)
20:27:58 <Cale> Or we can even use zipWith const
20:28:47 <Cale> @let myTakeFromEnd n xs = last $ zipWith const (tails xs) (drop (n+1) xs)
20:28:47 <lambdabot> Defined.
20:29:13 <Cale> @let otherTakeFromEnd n xs = drop (length xs - n) xs
20:29:14 <lambdabot> Defined.
20:29:26 <Cale> > otherTakeFromEnd 10 [1..10000000]
20:29:29 <lambdabot>  [9999991,9999992,9999993,9999994,9999995,9999996,9999997,9999998,9999999,100...
20:29:32 <Cale> > otherTakeFromEnd 10 [1..100000000]
20:29:36 <lambdabot>  Terminated
20:29:40 <Cale> > myTakeFromEnd 10 [1..100000000]
20:29:45 <lambdabot>  Terminated
20:30:00 <Cale> heh, well, one is much faster :)
20:31:30 <Cale> er, whoops, that should be an n-1 too
20:31:36 <Cale> @let myTakeFromEnd n xs = last $ zipWith const (tails xs) (drop (n-1) xs)
20:31:36 <lambdabot> <local>:12:0:     Multiple declarations of `L.myTakeFromEnd'     Declared at:...
20:31:40 <Cale> @undef
20:31:40 <lambdabot> Undefined.
20:31:42 <Cale> @let myTakeFromEnd n xs = last $ zipWith const (tails xs) (drop (n-1) xs)
20:31:42 <lambdabot> Defined.
20:31:48 <Cale> @let otherTakeFromEnd n xs = drop (length xs - n) xs
20:31:48 <lambdabot> Defined.
20:32:32 <Cale> > myTakeFromEnd 10 [1..15000000]
20:32:38 <lambdabot>  [14999991,14999992,14999993,14999994,14999995,14999996,14999997,14999998,149...
20:32:41 <Cale> > otherTakeFromEnd 10 [1..15000000]
20:32:44 <lambdabot> Terminated
20:42:22 <bos> @hoogle hPutStrLn
20:42:22 <lambdabot> System.IO.hPutStrLn :: Handle -> String -> IO ()
20:42:22 <lambdabot> Data.ByteString.hPutStrLn :: Handle -> ByteString -> IO ()
20:42:22 <lambdabot> Data.ByteString.Char8.hPutStrLn :: Handle -> ByteString -> IO ()
20:51:11 <dolio> @seen hpaste
20:51:11 <lambdabot> I haven't seen hpaste.
21:04:40 <scook0> @type listArray
21:04:42 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
21:08:53 <dobblego> is there a [a] -> (a -> Bool) -> ([a], [a]) that will 'filter' rather than 'break'? i.e. no elements matching the predicate in fst and all elements matching in snd
21:09:09 <dolio> @type partition
21:09:10 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
21:09:18 <dobblego> ah great thanks
21:11:13 <pantsd_> Question: I'm trying to install cabal packages on the new ubuntu 8.04 and cabal seems to be hosed (/usr/lib/ghc-6.8.2/lib/Cabal-1.2.3.0/HSCabal-1.2.3.0.o: unknown symbol `oldzmtimezm1zi0zi0zi0_SystemziTime_a97_closure' ghc-6.8.2: unable to load package `Cabal-1.2.3.0') has anyone else run into this?
21:11:37 <pantsd_> I tried searching on google but I couldn't find anything
21:12:29 <bos> pantsd_: you might be missing some ghc package
21:13:07 <Cale> pantsd_: well, oldzmtimezm1zi0zi0zi0_SystemziTime_a97_closure looks like it'd be in a package called old-time
21:13:36 <mauke> old-time-1.0.0.0_System.Time_a97_closure
21:13:41 <Cale> You might ghc-pkg list old-time and see if anything comes up.
21:14:18 <bugQ> brainsplode.  I'm not exactly sure what it would mean to have Tape be a monad.
21:15:10 <pantsd_> I do have the ubuntu libghc6-old-time-dev package install
21:15:19 <Cale> Well, the Tape itself being a monad is probably a bit strange, but a monad for operations which act on the tape is probably reasonable.
21:15:20 <pantsd_> and it shows up when I run ghc-pkg list old-time
21:15:44 <bugQ> Cale: well yeah, in instance of Monad on Tape.
21:15:46 <bugQ> *an
21:16:07 <bugQ> I just don't know what a possible (>>=) would look like.
21:16:18 <Cale> bugQ: Well, I'm saying not directly for the Tape type, but for a related type -- maybe the type  Tape -> (Tape, a)
21:16:37 <bugQ> ah, hmm.
21:16:47 <bos> monad transformers are sadly not terribly convenient for localised use.
21:17:01 <Cale> data TapeAction a = TA { runTapeAction :: Tape -> (Tape,a) }
21:17:20 <Cale> Which, incidentally, is the same as State Tape a
21:18:05 <Cale> (but it's worth thinking about how you'd do the >>= anyway, if you haven't already seen the state monad :)
21:18:33 <Cale> pantsd_: I'm afraid I don't have the new ubuntu yet, so I haven't yet bumped into that problem...
21:18:51 <Cale> pantsd_: Maybe try rebuilding cabal?
21:19:08 <pantsd_> Cale: sounds like the ticket
21:19:10 <pantsd_> thanks :)
21:19:23 <pantsd_> just wanted to see if maybe someone else had run into it the problem
21:20:29 <bos> @unpl (f a ==) . f
21:20:29 <lambdabot> (\ e -> (f a) == (f e))
21:21:00 <bos> @pl \ e -> (f a) == (f e)
21:21:01 <lambdabot> (f a ==) . f
21:21:10 <bos> snrk.
21:21:42 <Cale> @pl \f a e -> (f a) == (f e)
21:21:42 <lambdabot> flip =<< (((.) . (==)) .)
21:21:45 <Cale> @pl \a e -> (f a) == (f e)
21:21:46 <lambdabot> (. f) . (==) . f
21:22:01 <bos> it has no concept of `on` apparently.
21:22:05 <dolio> on (==) f a e
21:30:55 <bos> i wish that atomically was defined on MonadIO instead of plain IO.
21:31:40 <bos> in code that mixes IO, STM, Reader, Writer, and Maybe, god kills a kitten every time you call lift.
21:32:39 <dolio> Most stuff would probably be better in MonadIO instead of plain IO.
21:32:46 <bos> true nuff.
21:33:16 <mauke> atomically = liftIO . Control.Monad.STM.atomically
21:33:35 <bos> mauke: yes, i have an "atomic" function that does that.
21:34:22 <bos> but still.  the need to sprinkle liftIO throughout code that generalised newtype deriving has politely tidied up to be free of explicit calls to lift is unsightly.
21:37:01 <ddarius> bos: So make an (appropriate) MonadIO class
21:37:18 <ddarius> I think CosmicRay already partially has
21:37:57 <awesame> the Control.Exception docs suggest this implementation of withFile, using bracket:
21:37:58 <awesame> withFile name mode = bracket (openFile name mode) hClose
21:38:16 <bos> ddarius: one for which the default instance provides lifted versions of huge piles of the usual suspects, you mean?
21:38:44 <awesame> I'd like to do the same thing with accepting a socket connection, rather than opening a file, but I keep getting confused
21:38:44 <ddarius> bos: One that is analogous to MonadState and co
21:39:07 <awesame> openFile returns a handle, while accept returns a (handle, _, _)
21:39:19 <bos> ddarius: yeah. that would be nice to have.  a MonadHandle for Handle-based IO, etc, etc.
21:39:27 <mauke> awesame: do you need the other two things?
21:39:36 <sjanssen> ddarius: why add a new class for this?
21:39:44 <awesame> mauke: no, I need an expression that calls accept, but just returns the handle
21:39:53 <sjanssen> shouldn't all the functions just be generalized to MonadIO?
21:40:02 <mauke> fmap (\(x, _, _) -> x) (accept ...)
21:40:29 <awesame> oh!  duh
21:40:41 <sjanssen> bos: in xmonad, we've shortened liftIO to io
21:40:49 <bos> sjanssen: i know.
21:40:58 <awesame> I'm still finding gaps in my ability to come up with the natural way to do things in haskell
21:41:05 <bos> sjanssen: but that doesn't make it any less awkward :-)
21:41:21 <mauke> awesame: you could always write a named helper function
21:42:22 <ddarius> sjanssen: That would be suitable for many, though there are functions in IO that could be generalized to other monads, such as newIORef.
21:42:56 <sjanssen> ddarius: true
21:43:14 <bos> having those APIs be class-based would be handy for testing pure code, too.  it would stop those OO weenies with their mock objects in their ruby-licking tracks.
21:43:19 <sjanssen> I've seen a MonadRef class in the arrayref library
21:43:32 <ddarius> There are MonadRef classes all over the place.
21:45:07 * mattr__ missed the ghci banner
21:45:18 * mattr__ misses :)
21:45:21 <sjanssen> one obstacle to MonadIO-ing everything is the monomorphism restriction
21:45:32 <sjanssen> main = putStrLn "Hello, world!" -- won't compile
21:45:45 <ddarius> Solution: Remove the monomorphism restriction.
21:46:02 <dobblego> ?type main = putStrLn "Hello, world!"
21:46:03 <lambdabot> parse error on input `='
21:46:08 <dobblego> ?type let main = putStrLn "Hello, world!" in main
21:46:09 <lambdabot> IO ()
21:47:09 <lament> so provide a signature for main.
21:47:37 <ddarius> Won't Haskell implementations complain if you write main = True?
21:47:46 <roconnor> I wonder if main ought to get an implicit signature
21:48:01 <dobblego> ?type sequence
21:48:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
21:48:09 <dobblego> ?src sequence
21:48:09 <lambdabot> sequence []     = return []
21:48:09 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
21:48:09 <lambdabot> --OR
21:48:09 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
21:48:24 <roconnor> or maybe not; maybe people want to reuse main :P
21:53:40 <cjs> What's the usual way to build a string out of a couple of characters? "c1 : c2 : []"
21:53:55 <ddarius> [c1,c2]
21:54:31 <cjs> Thanks.
21:55:49 * ddarius writes C in Haskell.
21:56:09 * kfish writes haskell in C
21:56:41 <cjs> Hey, a Char holds a Unicode code point, right?
21:57:02 <mauke> cjs: yes
21:57:12 <kfish> map (print_int, take (40, merge_ints (randoms, randoms)));
21:58:12 <prb_> cjs Yep.
21:58:57 <cjs> So it's pretty sloppy, if I've got a length that in a file is a little-endian 16-bit int, to be using Chars to store it in Haskell, right? What should I be using for what's effectively binary IO? Data.ByteString.Char8 seems perfect for my message format, which really is ASCII values, but the lengths are int16_le, and I've also got a timestamp that I was sort of planning to make a 64-bit value.
22:00:03 <prb_> cjs: Hopefully someone who's got binary serialization expertise will chime in.
22:00:15 <prb_> cjs: I'm pretty sure that there's support for packed structures in and out.
22:00:17 <sjanssen> cjs: use Data.Binary instead?
22:00:33 <ivan_salazar_v> How would you write this:
22:00:33 <ivan_salazar_v> if doesFileExist name && doesDirectoryExist name then <exp> else <exp>
22:00:38 <ddarius> The Haskell community with it's crazy and cryptic naming scheme.
22:01:05 <mauke> cjs: Data.Binary.Get
22:01:09 <sjanssen> ivan_salazar_v: isn't the 'doesFileExist name' part redundant?
22:01:41 <ddarius> ivan_salazar_v: What's wrong with the way it is written?
22:01:52 <cjs> I've kinda glanced at Data.Binary a couple of times. Ah, There are the docs. Right, I'll pursue that. Thanks.
22:01:59 <kfish> cjs: are you trying to parse an existing binary file format, or just store your own data?
22:02:17 <ivan_salazar_v>   sjanssen: I think not, I need to get files only, not directories
22:02:23 <kfish> Data.Binary is great for the latter, not for the former
22:02:53 <ivan_salazar_v> ddarius: I get a type error: && expects Bool and it inferres IO Bool
22:03:31 <sjanssen> kfish: why do you say that?
22:03:54 <ddarius> liftM2 (&&) (doesFileExist name) (doesDirectoryExist name) >>= \b -> if b then <exp> else <exp>
22:04:10 <cjs> Both, though the former only a little. Basically, from the network I get ASCII messages each prefixed with an int16_le giving the length of the message. I need to store these, along with timestamps, in a file, and later be able to play these back to the network, among other things.
22:04:36 <prb_> cjs: Sounds like the ASCII stuff is irrelevant...
22:04:47 <prb_> That is, that it is ASCII isn't relevant to your operation.
22:04:47 <cjs> Message lengths are typically 50-300 bytes, and I'm expecting to have to handle 500-1000 per second.
22:05:02 <ivan_salazar_v> thanks, ddarius
22:05:30 <lament> ddarius: ugly :(
22:05:31 <cjs> Well, I do have to parse stuff out of it in other areas of my program, but for this, yes, just treating them as a ByteString works fine.
22:05:47 <ivan_salazar_v> lament: XD
22:06:06 <lament> doesn't one of those two predicates imply the other?
22:06:11 <ddarius> lament: If we had bool it would be nicer.
22:06:20 <lament> if the file exists, the directory presumably also does
22:06:55 <lament> ddarius: it would be nicer if we had a monad-aware "if"
22:07:09 <dobblego> ?type ifM
22:07:10 <lambdabot> Not in scope: `ifM'
22:07:20 <cjs> I've always felt it was a deficiency in a language to have "if" as syntax.
22:07:22 <ivan_salazar_v> lament: Yes, but directoryExist succeeds when the file exists and the file is a directory
22:07:52 <lament> ivan_salazar_v: then why do you have to check doesFileExist?
22:07:53 <ivan_salazar_v> lament: I want directoryExists to fail, so the consequent executes only when the name given is that of a file
22:07:53 <ddarius> cjs: if is trivial syntactic sugar in Haskell
22:08:23 <cjs> Still, Smalltalk didn't need syntatic sugar for it.
22:08:27 <lament> ivan_salazar_v: oh, so you want that part to be false rather than true
22:08:27 <ivan_salazar_v> lament: (and the file existed)
22:08:36 <lament> ddarius: syntactic sugar is never trivial.
22:08:54 <ivan_salazar_v> yes (did I forget the not? XD)
22:09:09 <lament> ddarius: look how much trouble we have without monadic if.
22:09:11 <sclv> ?seen bos
22:09:11 <lambdabot> bos is in #haskell and #ghc. I last heard bos speak 25m 57s ago.
22:09:20 <lament> ddarius: your solution no longer works because now it needs a not
22:09:38 <kfish> sjanssen, i thought data.binary was designed for serializing haskell types, and doesn't provide anything for dealing with raw data with endianness, bitfields etc.
22:09:50 <kfish> sjanssen, i'd like to be wrong tho
22:09:53 <ivan_salazar_v> lament: yes, I forgot to negate the value, sorry
22:10:03 <mauke> kfish: http://hackage.haskell.org/packages/archive/binary/0.4.1/doc/html/Data-Binary-Get.html
22:10:08 <lambdabot> http://tinyurl.com/27z765
22:10:10 <sclv> ping bos
22:10:11 <ddarius> lament: Nothing stops one from writing ifM
22:10:19 <ddarius> We already have when and unless.
22:10:29 <ddarius> Actually, those aren't appropriate.
22:10:31 <cjs> kfish: "For parsing and generating simple external binary formats (e.g. C structures), Binary may be used, but in general is not suitable for complex protocols. Instead use the Put and Get primitives directly."
22:10:33 <kfish> mauke, sweet, thanks
22:10:56 <lament> ddarius: making it work with actions and regular logic functions would take some work
22:11:06 <lament> possibly infinite amount
22:11:06 <bos> sclv: pong
22:11:14 <ddarius> lament: Anyway, it's quite reasonable for my solution to no longer work if you change what the correct solution is.
22:11:21 <sclv> bos: http://hpaste.org/6858 -- presenting... drumsroll... gAtomically!
22:11:41 <sclv> any monadIO into any monadSTM (define them just like monadIO)
22:11:52 <bos> sclv: cute. that's similar to the MonadBase / BaseM trick.
22:11:56 <cjs> So, basically, you can go and create your own get/put for an Word16LE or whatever, from the looks of it. If you don't mind having a separate type for that.
22:11:58 <ddarius> liftM2 (flip (&& . not))
22:12:01 <lament> ivan_salazar_v: if i were you i would <- those things into variables, separately, and then have a normal if
22:12:05 <ddarius> Er + ()s
22:12:14 <ddarius> :t flip ((&&) . not)
22:12:15 <lambdabot> Bool -> Bool -> Bool
22:12:16 <lament> ivan_salazar_v: it's more readable and easier to change when you forget something again
22:12:31 <sclv> right. its also similar to gcatch. i'm using this stuff quite a bit. i smell a generalization of all of them that's almost within my reach, but i can't quite write it.
22:12:40 <ivan_salazar_v> lament: I thought so, but I reads kind of ugly XD
22:12:48 <sclv> i also have a gOrElse
22:12:50 <cjs> In my case, it's actually an LC, which works well for me, since a separate type for it is helpful.
22:13:09 <ddarius> ivan_salazar_v: Is beauty worth your immortal soul? !!!
22:13:40 <ivan_salazar_v> ddarius: lol
22:14:13 <sjanssen> kfish: no support for bitwise stuff, but words of various sizes and endiannesses are supported
22:16:15 <kfish> sjanssen, cool
22:16:34 <kfish> actually i hate using bitpackers anyway, explicit bit ops are fine :-)
22:17:30 <cjs> Hey, Data.Binary.Put exports putWord32be and putWord32le, and the usual other gang.
22:17:48 <ivanm> I asked this yesterday but no one responded, so I'll try again
22:17:51 <ivanm> this is pretty much off topic, but I'm starting to look for places to do my phd in next year... would anyone know of a good uni that does work in computational combinatorics, preferably in Haskell (or indeed just computational maths in general with haskell)?
22:18:09 <ddarius> ivanm: Cale would be a good person to ask I suspect.
22:18:16 <ivanm> OK
22:18:18 <ivanm> @seen Cale
22:18:18 <lambdabot> Cale is in #haskell-overflow, #haskell-blah, #ghc and #haskell. I last heard Cale speak 56m 33s ago.
22:18:26 <ivanm> ddarius: any particular reason why Cale?
22:18:52 <ddarius> ivanm: He's into combinatorics.
22:18:58 <ivanm> ok
22:20:29 <Cale> Why me?
22:20:34 <Cale> oh
22:20:46 <ivanm> heh
22:20:48 <Cale> one sec :)
22:20:56 <bos> i think you might get combinatorics or haskell, but not both.
22:21:29 <ivanm> :( that's what I was worried about
22:21:46 <Cale> I don't know where would be good for computational combinatorics
22:22:20 <ivanm> :(
22:22:34 <Cale> Waterloo has some pretty good algebraic combinatorics people. Also, Montreal is supposed to be good for that.
22:22:52 <bos> ivanm: you'll probably want to choose a place that focuses on whichever aspect you're most interested in, and try to find an open-minded advisor.
22:22:54 <Cale> My friend is going to Paris to study symmetric functions.
22:23:13 <ivanm> bos: heh, trying to find anything like that is what I've been having trouble with :p
22:23:38 <ivanm> and I only say combinatorics because thats what my honours thesis this year is on
22:23:42 <bos> essex has a good computational combinatorics group, but it's in the maths department, and the CS dept wouldn't know haskell if you beat them with a lambda.
22:23:46 <ivanm> and I've done another haskell project in that field
22:24:06 <ivanm> bos: heh... my current honours supervisor is annoyed that I'm using haskell (he's in maths) ;-)
22:24:30 <bos> so you don't have a deep and abiding love for regular spanning subgraphs?
22:24:54 <ddarius> ivanm: You should be using FORTRAN?
22:25:13 <ddarius> Or is it matlab for math people?
22:25:14 <ivanm> bos: haven't done much theory, unfortunately :(
22:25:24 <ivanm> ddarius: F90 isn't too bad, actually
22:25:26 <adu> matlab is for matrix people
22:25:27 <ivanm> F90 > C IMHO
22:25:45 <ddarius> ivanm: Setting the bar high there, I see.
22:25:55 <ivanm> bos: in my 4 years of undergrad, I managed to cram in maths, physics and IT, so didn't get to specialise too much :s
22:25:56 <dobblego> ?hoogle (Monad m) => Int -> m a -> m a
22:25:56 <lambdabot> No matches, try a more general search
22:26:19 <Cale> ddarius: More likely Maple or Mathematica.
22:26:20 <Korollary> ivanm: If you're not too sure on combinatorics, perhaps you should choose school over subject.
22:26:33 <ivanm> ddarius: heh... I did a course in C (addmittedly for embedded stuff) and tought myself F90 for a project... and liked F90 better
22:26:58 <ivanm> Korollary: well, yes, I'm willing to go with that... but I definitely want to do some computational maths kind of thing, and preferably in haskell ;-)
22:26:59 <Cale> Matlab's strengths aren't really so directed at combinatorics.
22:27:09 <dobblego> is there a function that sequences a monad n times?
22:27:15 <ddarius> replicateM
22:27:20 <bos> ivanm: if you're not already deep into a particular subdiscipline, you might want to think about finding a sympatico advisor at a good school, rather than just jumping on the thing you've been working on for one term.
22:27:22 <dobblego> oh course, cheers
22:27:30 <Cale> dobblego: Careful with your use of the word 'monad' :)
22:27:32 <ddarius> and replicateM_
22:27:43 <dobblego> Cale, what do you mean?
22:27:46 <ivanm> bos: OK, but what's a good school ;-)
22:27:49 <ddarius> Cale: ReplicateM n
22:27:51 <bos> because the thing you've been doing for just one term is probably not the thing you'll be interested in next year.
22:27:55 <Cale> dobblego: A monad is a type constructor.
22:28:05 <dobblego> ah right
22:28:11 <Korollary> -pedant heh
22:28:20 <mauke> -fignore-errors
22:28:44 <bos> ivanm: generically: oxford, cambridge, glasgow, chalmers, utrecht, edinburgh.
22:28:52 <bos> in no particular order.
22:28:59 <ivanm> bos: they all do haskell?
22:29:19 <bos> in the US, there's a little bit of focus on haskell at a few schools, but it's mostly marginal if it exists at all.
22:29:31 <bos> ivanm: they're all "big" centres of haskell.
22:29:45 <ivanm> heh, shows how much I know
22:29:47 <mauke> what's the difference between getBytes and getByteString?
22:30:05 <bos> oh, and nottingham.
22:30:17 <bos> mauke: getByteString gives you the entire rest of the input.
22:30:17 <ivanm> down here, the only people that seem to know about haskell are 2 or 3 in the IT department, and 1 in the maths department who learnt it once
22:30:22 <sjanssen> mauke: IIRC, getByteString reads a length first, then reads that many bytes
22:30:26 <ivanm> bos: but haskell in terms of CS or maths?
22:30:33 <bos> ivanm: where's "down here"?
22:30:37 <mauke> bos: then why does it take an Int?
22:30:53 <ivanm> bos: slightly further north than where dons came from :p ... Brisbane, Australia
22:31:21 <bos> ivanm: most of those places, there's not a strong distinction.  you could end up working in category theory or abstract algebra or who knows what else, with some haskell.
22:31:28 <cjs> What is getByteString from?
22:31:32 <bos> mauke: perhaps i have the two swapped.
22:31:36 <mauke> Data.Binary.Get
22:31:37 <ivanm> bos: *nod*
22:31:38 <bos> cjs: Data.Binary
22:31:44 <mauke> they have the same type signature
22:31:47 <cjs> Oh. Duh. :-)
22:31:56 <bos> ivanm: oh, and on your continent, then, there's UNSW.
22:32:25 <ivanm> bos: well, I _did_ want to go somewhere in Europe or the UK, to get a different feel and for the hell of it ;-)
22:32:50 <ivanm> and from having a quick look at UNSW, that seems to be oriented more towards CS than I wanted
22:32:58 * ivanm hasn't done that much pure CS stuff :(
22:33:48 <sjanssen> mauke: there should be no real difference
22:35:09 <sjanssen> mauke: getByteString n = readN n id
22:35:24 <awesame> what the heck does this mean?: (f x . show .)
22:35:36 <awesame> I can read everything up to the final "."
22:35:55 <mauke> @unpl (f x . show .)
22:35:55 <lambdabot> (\ a h -> f x (show (a h)))
22:35:56 <ddarius> It's a syntax error
22:35:56 <sjanssen> mauke: readN n f = fmap f $ getBytes n
22:36:09 <ddarius> :t (f x . show .)
22:36:10 <lambdabot>     The operator `.' [infixr 9] of a section
22:36:10 <lambdabot>         must have lower precedence than the operand `(.)' [infixr 9]
22:36:10 <lambdabot>         in the section: `(f x . show .)'
22:36:20 <awesame> hm
22:36:24 <mauke> sjanssen: heh, so getByteString = getBytes
22:36:27 <awesame> but, it works
22:36:36 <sjanssen> mauke: yeah
22:37:00 <sjanssen> maybe there are rewrite rules at play, but I doubt it (all of these functions are INLINEd)
22:37:35 <ivan_salazar_v> is there a way to convert from a String to a ByteString?
22:37:39 <bos> pack
22:37:49 <awesame> oh, uh, "." may be "fmap" in this code
22:37:57 <bos> in GHC 6.8.2, there's a language extension you can use, too
22:38:04 <sjanssen> awesame: still a syntax error
22:38:04 <bos> awesame: yes, that's not unusual.
22:38:50 <awesame> the code also says "(try . string .)"
22:39:12 <awesame> (try and string are from parsec here)
22:39:18 <mauke> awesame: where is . from?
22:39:48 <awesame> mauke: it looks like it's defined to be fmap
22:40:04 <mauke> does it have an accompanying infix declaration?
22:40:09 <awesame> (.) :: Functor f => (a -> b) -> f a -> f b
22:40:09 <awesame> (.) = fmap
22:40:38 <sjanssen> awesame: this code actually builds?
22:40:41 <mauke> I'll take that as a no
22:40:48 <awesame> yeah, it does build
22:41:04 <awesame> I don't see an infix declaration
22:41:15 * sjanssen is skeptical -- "(try . string .)" is a syntax error for all definitions of (.)
22:41:52 <awesame> well, it's good to know that I'm now finding confusing things confusing, rather than just simple things
22:42:01 <sjanssen> oh, that isn't true I guess
22:42:12 <sjanssen> awesame: nevermind, I'm wrong
22:43:01 <awesame> emacs claims that . :: (b -> c) -> (a -> b) -> a -
22:43:03 <awesame> > c
22:43:04 <lambdabot>  c
22:43:10 <Cale> awesame: this is true
22:43:41 <awesame> oh, right, that's the normal (.)
22:44:03 <Cale> awesame: the problem with (f . g .) is that it's against the syntax rules to have an operator section together with an expression in which there's an operator of the same or higher precedence
22:44:15 <Cale> You could have ((f . g) .)
22:44:28 <awesame> perhaps that's what this means
22:44:34 <Cale> :t \f g -> ((f . g) .)
22:44:35 <lambdabot> forall a b a1 (f :: * -> *). (Functor f) => (a -> b) -> (a1 -> a) -> f a1 -> f b
22:44:39 <Cale> ;)
22:45:00 <mauke> :t let (.) = (P..) in (?f . ?g .)
22:45:01 <lambdabot> forall b c b1 a. (?g::b1 -> b, ?f::b -> c) => (a -> b1) -> a -> c
22:45:12 <Cale> Of course, that's my generalised version, but if you want the un-generalised one, you can just stick a  (t ->) wherever you see f
22:45:18 <mauke> no need for ( )
22:45:25 <Cale> hmm
22:45:28 <sjanssen> (. f . g) is allowed
22:45:48 <sjanssen> but not (f . g .) (assuming (.) is infixr)
22:46:03 <ddarius> It is
22:46:09 <sjanssen> right
22:46:17 <sjanssen> but perhaps it isn't in awesame's module?
22:46:34 <awesame> but this redefined fmap version of (.) doesn't look infixr to me
22:47:05 <Cale> hmm, did I make a mistake in defining it?
22:47:07 <sjanssen> zany idea: are you sure that the two "." characters are actually the same character?
22:47:16 <ddarius> infixl 9 is the default fixity, yes?
22:47:28 <mauke> Cale: did you write awesame's code?
22:47:47 <Cale> oh, I thought he was referring to lambdabot's redefinition
22:48:02 <awesame> sjanssen: I just retyped them into emacs myself, and it still compiles
22:48:07 <Cale> (and yeah, lambdabot has an infixr 9 decl. for (.)
22:48:24 <sjanssen> Cale: about that, I think these redefinitions are wrong
22:48:33 <Cale> "wrong"?
22:48:33 <sjanssen> what do we say when a newbie notices:
22:48:36 <sjanssen> @type (.)
22:48:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:48:38 <sjanssen> doesn't match ghci?
22:48:49 <awesame> Cale: (.) is defined as follows in the code I'm trying to understand:
22:48:51 <awesame> (.) :: Functor f => (a -> b) -> f a -> f b
22:48:51 <awesame> (.) = fmap
22:48:54 <Cale> We say that the version in lambdabot is a generalisation
22:48:58 <sjanssen> Cale: they shouldn't be used as the default evaluation context for lambdabot
22:48:59 <Cale> and perhaps explain what a functor is
22:49:25 <Cale> awesame: okay, that's similar to lambdabot's definition, except that lambdabot has an infix declaration
22:49:53 <Cale> infixr 9 .
22:50:12 <sjanssen> Cale: lambdabot isn't very useful as a reference if it's based on an alternate Prelude
22:50:12 <Cale> awesame: I suspect that if there's no infix declaration, (.) becomes infixl 9
22:50:35 <Cale> sjanssen: There are not that many differences, and they're all generalisations.
22:51:42 <awesame> indeed, (.) in this code appears to be identical to `fmap`
22:51:42 <sjanssen> that is beside the point -- they should be the versions from the Prelude
22:51:58 <Cale> sjanssen: Let's change the Prelude and make that true :)
22:52:07 <sjanssen> Cale: yes, I would be fine with this :)
22:52:18 <awesame> so this says (f x `fmap` show `fmap`)
22:52:22 <lament> "You should obey the law, no matter how stupid"
22:52:39 <awesame> that second fmap still hurts my head, but at least it doesn't look like a syntax error
22:52:51 <mauke> awesame: it's an operator section
22:53:05 <Cale> awesame: remember also that fmap specialises to function composition
22:53:22 <Cale> But in this case, which functor depends on what that thing gets applied to
22:53:29 <awesame> fmap is new to me, so I'm more realizing it that remember it, but yes
22:53:43 <Cale> That operator section is the same as:
22:53:43 <awesame> er, "than remembering"
22:54:09 <Cale> (\u -> fmap (f x) (fmap show u))
22:54:17 <Cale> which, thanks to the fmap law is the same as
22:54:24 <Cale> (\u -> fmap (f x . show) u)
22:55:26 <Cale> Or, if you like,  \u -> f x . (show . u) = \u -> (f x . show) . u
22:55:54 <awesame> what does "operator section" mean?
22:55:55 <Cale> So if u ends up being a list, say, it'll apply show to all the elements, and then apply f x to all the elements.
22:55:58 <awesame> google isn't helping
22:56:04 <Cale> awesame: That's the name for things like (5+)
22:56:09 <Cale> > map (5+) [1..10]
22:56:09 <lambdabot>  [6,7,8,9,10,11,12,13,14,15]
22:56:09 <awesame> ah, ok
22:57:23 <Cale> does that make sense?
22:57:52 <awesame> yeah, I think I understand this expression now
22:58:33 <awesame> thanks, this continues to be the best language channel ever
23:01:40 <Cale> Functors are just type constructors for which there's a way to apply a function to all the contained values whose type is the type parameter -- like applying a function to all the elements of a list, or, indeed composing functions
23:02:32 <Cale> (you can think of functions as like containers which are indexed by inputs)
23:06:14 <awesame> so, fmap is that way, right?
23:06:28 <Cale> Yeah, fmap is the Haskell 98 name for that operation
23:06:35 <Cale> There's a class:
23:06:38 <Cale> class Functor f where
23:06:46 <Cale>    fmap :: (a -> b) -> f a -> f b
23:07:23 <Cale> Note that when f is the partially applied type constructor:  (->) e
23:07:26 <Cale> we get:
23:07:43 <Cale> fmap :: (a -> b) -> ((->) e a) -> ((->) e b)
23:07:46 <Cale> which is:
23:07:52 <Cale> fmap :: (a -> b) -> (e -> a) -> (e -> b)
23:08:02 <Cale> and that's got to be function composition :)
23:08:27 <Cale> and of course, when f is [], the list type constructor, you get map
23:08:31 <mauke> @djinn (a -> b) -> (e -> a) -> (e -> b)
23:08:31 <lambdabot> f a b c = a (b c)
23:08:53 <mauke> @. pl djinn (a -> b) -> (e -> a) -> (e -> b)
23:08:53 <lambdabot> f = (.)
23:09:07 <Cale> and when f is something like a tree datatype, the appropriate operation is the one which applies the supplied function to all the values held in the tree
23:09:30 <Cale> when f is a monad, we have that fmap f x = do v <- x; return (f v)
23:09:43 <Cale> (er, that's not the same f there, obviously :)
23:12:23 <Gnezdo> > :t fmap
23:12:23 <lambdabot>   parse error on input `:'
23:12:31 <awesame> right, so mapping f onto the value contained in the monad
23:12:32 <elaforge> ok, so does anyone else find ghc's -main-is really mysterious?
23:12:59 <sclv> whats the issue?
23:13:01 <elaforge> the first time I use it with a new file, I get the usual no _ZCMain_main_closure thing
23:13:15 <Gnezdo> how do I ask lambdabot the type of an expressesion?
23:13:17 <elaforge> then if I doodle around, copying and pasting, it eventually works
23:13:24 <awesame> Functor is a weird name for that
23:13:31 <elaforge> then I gradually return the cmdline and file back to what I originally had... and now it works
23:13:36 <sclv> :t fmap
23:13:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:13:41 <sclv> ^^ like that
23:13:43 <olsner> :t liftM
23:13:44 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
23:13:44 <elaforge> then it keeps working... until I make another makefile target...
23:13:53 <Gnezdo> duh, thank sclv
23:13:53 <sclv> if privmsgs with lambdabot you do ?type fmap
23:13:58 <Gnezdo> thanks
23:14:14 <Cale> awesame: It comes from category theory
23:14:26 <elaforge> I wind up with exactly where I started... only it works this time
23:14:43 <Cale> awesame: Really, a Haskell functor is an endofunctor on the category of Haskell types and functions, but close enough :)
23:14:56 <awesame> heh
23:15:00 <mauke> and what's a C++ functor? :-)
23:15:17 <Cale> mauke: A function.
23:15:19 <awesame> I can't decide whether learning haskell before category theory is going to make category theory harder or easier
23:15:43 <slava> why would it make it harder?
23:15:50 <lament> i don't think it will change anything at all
23:15:55 <awesame> "functor" in most programming lingo means roughly "first-class function"
23:16:06 <slava> that's java/c++ lingo
23:16:07 <awesame> which I assume is just completely unrelated
23:16:14 <slava> in ML, functor means a higher-oder module
23:16:16 <mauke> "most"
23:16:17 <slava> which isn't really related either
23:16:30 <awesame> mauke: most by number of users, I am guessing
23:16:39 <mauke> I've only seen that meaning in C++
23:16:39 <Cale> awesame: It'll possibly make it slightly easier, as you'll know a good example of a category
23:17:49 <Cale> "function object" would be a better name
23:18:31 <elaforge> python tends to call them 'callables', never 'functors'
23:18:31 <awesame> mauke: I've heard it used that way by people who didn't use C++
23:18:55 <elaforge> I've actually only ever seen "functor" that way in stroustrup
23:19:35 <Gnezdo> http://en.wikipedia.org/wiki/Functor
23:19:36 <lambdabot> Title: Functor - Wikipedia, the free encyclopedia
23:19:52 <sclv> usefulobject
23:19:54 <Gnezdo> quote: For functors as a synonym of "function objects" in computer programming, see Function object.
23:20:09 <Gnezdo> otherwise speaks of category theory meaning
23:20:17 <lament> 'functor' is a word that snobs use sometimes to mean 'function'
23:20:31 <lament> it takes something and returns something else
23:20:52 <Cale> lament: But that's not quite the category theoretic meaning
23:21:06 <olsner> STL documents talk heaps about "functors" as function objects... especially for user-defined classes with a ()-operator
23:21:10 <awesame> huh, now I'm curious where the function-object sense of functor comes from
23:21:39 <Cale> lament: (which is what it generally means if you see it in this channel)
23:22:37 <sclv> no relation to the cat theory side -- adding "or" is often a way to "noun" a verb
23:22:43 <ddarius> 'functional'
23:22:52 <mattr__> woah - this ghci debugger is serious stuff
23:23:10 <olsner> sclv: functing functor functs?
23:23:12 <sclv> comparator, gladiator
23:23:26 <elaforge> sclv, can you actually gladiate someone?
23:23:37 <slava> elaforge: dons has been known to do so
23:23:48 <elaforge> "unforunately, he didn't make it 3 steps before being gladiated"
23:23:58 <Cale> If C and D are categories, a functor F: C -> D is a pair of mappings: one which sends objects of C to objects of D, and one which associates to each arrow f: X -> Y in C, a corresponding arrow Ff: FX -> FY in D such that F(id_X) = id_(FX), and F(g . f) = Fg . Ff for all f and g which compose
23:24:10 <slava> Cale: is functor usually taken to mean 'covariant functor'?
23:24:14 <Cale> slava: yeah
23:24:18 <lament> "gladius" means "bulb"
23:24:34 <sclv> ok, its actually a way to "noun" another noun more like -- gladiatus means sword in latin
23:24:34 <awesame> I think the short definition of Functor is "mappable container"
23:24:48 <Cale> slava: Usually if you want a contravariant functor, you explicitly say so. :)
23:24:57 <Cale> awesame: That's in Haskell alone.
23:25:09 <awesame> right, so not correct for category theory I guess
23:25:18 <Cale> awesame: In a broader context, they don't all look like that
23:25:29 <Cale> But it does give some of the right idea.
23:26:03 <sclv> the wikipedia article seems to say that "functor" is used to mean "covariant functor" fairly frequently.
23:26:04 <Cale> In fact, most of the functors which come up in mathematics are structure erasing functors, whereas basically all Haskell functors "add structure" in a way.
23:26:21 <elaforge> sclv, so gladiated might be the fancy latin way to say "sworded!"
23:26:25 <sclv> structure erasing = "forgetful"
23:26:27 <sclv> ?
23:26:42 <slava> yeah. in algeibrac topology you use functors to simplify problems, in some sense.
23:26:43 <Cale> sclv: Well, forgetful functors are an example of that
23:27:03 <Cale> Yeah, I'm thinking of the fundamental group functor
23:27:12 <slava> sclv: just functors that are not 'injective'
23:27:41 <Cale> Which sends a pointed topological space to a group, and continuous maps on pointed topological spaces to group homomorphisms.
23:27:54 <lament> functor - function, factor - ?
23:28:06 <slava> faction? :)
23:30:14 <sclv> factor -- from facere, "to do"
23:30:33 <Cale> If you don't like pointed spaces, there's also a fundamental groupoid functor which sends topological spaces to groupoids (which are small categories in which every arrow is invertible), and continuous functions to groupoid homomorphisms, which of course are just functors between the groupoids :)
23:30:47 <Cale> (which preserve inverses, necessarily)
23:31:13 <awesame> okay, brain hurts now
23:31:16 <Cale> :)
23:31:18 <Cale> hehe
23:31:19 <sclv> humidor -- that one's obvious (ish?)
23:31:49 <Cale> awesame: This stuff is beautiful, but probably best treated in maybe 3rd or 4th year of a pure mathematics degree. :)
23:32:02 <awesame> I think I actually managed to get something about what a functor is out of that, in a way that might make it seem easier later
23:32:32 <lament> we never had to do any fun stuff like that in my pure math degree
23:32:44 <Cale> awesame: To a first approximation, categories are bunches of structures we're interested in, together with "structure preserving maps" between them.
23:32:47 <lament> of course it's cause i picked all the easiest courses.
23:32:57 <Cale> awesame: Functors are then structure preserving maps between categories :)
23:33:08 <lament> (no, really category theory wasn't offered in undegrad :( )
23:33:23 <slava> it was a 4th year course at my school
23:33:31 <elaforge> Cale, so I've heard "isomorphism" used for something like that...
23:33:31 <Cale> lament: We didn't get a course in category theory, but lots of the other courses had ideas from category theory.
23:33:45 <slava> elaforge: an isomorphism is a special type of homomorphism
23:33:46 <Cale> elaforge: An isomorphism is a stronger way to preserve structure.
23:33:54 <slava> and a homomorphism is a structure preserving map between objects
23:34:09 <Cale> elaforge: When you say two things are isomorphic, you're actually saying they're basically the same.
23:34:09 <elaforge> Cale, I see, so there are degrees of structure preservingness
23:34:09 <slava> at the category level the equivalent of an isomorphism os n 'equivalence of categories' iirc
23:34:26 <slava> Cale: basically the same from one specific viewpoint
23:34:31 <Cale> yeah
23:34:39 <slava> R^2 and R are 'isomorphic' as sets :)
23:34:39 <awesame> Cale: so what are the categories that haskell functors map between?
23:35:00 <Cale> awesame: Haskell functors are functors from Hask to itself
23:35:11 <awesame> got it
23:35:19 <Cale> Where Hask is the category whose objects are Haskell types, and whose arrows are Haskell-definable functions.
23:36:15 <lament> what a long-ass way of saying "container" :)
23:36:21 <Cale> lament: hehe
23:36:22 <awesame> "arrows" are the homomorphisms between members of a category?
23:36:29 <Cale> awesame: yeah
23:36:40 <elaforge> "fundamental groupoid" sounds like a good band name, actually
23:36:42 <Cale> awesame: 'arrow' and 'homomorphism' are almost synonyms
23:36:50 <Cale> elaforge: :)
23:36:53 <slava> except haskell's Arrow type is something different altogether
23:37:20 <awesame> elaforge: eh, maybe an album name.  band names should be shorter.
23:37:23 <Cale> I know of a singing quartet named "The Klein Four Group"
23:37:44 <Cale> awesame: yeah, that's important, Hughes' Arrows are something different.
23:38:02 <lament> nice, they got 50% of the singing quartet market
23:38:09 <awesame> thanks for clarifying, I was already wondering about those
23:38:15 <lament> (of the group-named singing quartet market)
23:38:45 <Cale> http://uk.youtube.com/watch?v=UTby_e4-Rhg
23:38:45 <lambdabot> Title: YouTube - Finite Simple Group (of Order Two)
23:38:58 <slava> heh
23:39:09 <lament> nothing is more pathetic than mathy musicians.
23:39:17 <slava> my number theory teacher played taht to us in class...
23:39:24 <Cale> ahaha
23:39:43 <awesame> lament: how about musical mathematicians?
23:39:58 <Cale> lament: How about a mathematical gangsta rap group?
23:40:06 <slava> that sounds pretty bad
23:40:07 <elaforge> then you wind up with xenakis
23:40:08 <Adamant> MC Hawking, bishes
23:40:24 <cjs> Damn! All  this time wondering what the heck kind of magic liftM does, and it reading the source makes it entirely obvious.
23:40:24 <awesame> okay, #haskell has clearly jumped the shark
23:40:35 <Cale> "Betta watch your back when I'm packin' a nine/I'll pump you fulla holes like the rational line"
23:40:42 <cjs> Or Conlon Nancarrow.
23:40:49 <lament> "Ever see what them computa bitchez do to numbas? It ain't natural. Numbas ain't supposed to be code, they supposed to quantify shit."
23:41:15 <xerox> Cale: awesome :)
23:41:23 <therp> cale :)
23:41:40 <awesame> that was pretty awesome
23:42:25 <bos> @hoogle timed
23:42:25 <lambdabot> System.Time.TimeDiff :: data TimeDiff
23:42:25 <lambdabot> System.Time.TimeDiff :: Int -> Int -> Int -> Int -> Int -> Int -> Integer -> TimeDiff
23:42:25 <lambdabot> System.Time.timeDiffToString :: TimeDiff -> String
23:42:28 <bos> @hoogle time
23:42:28 <lambdabot> System.Time :: module
23:42:28 <lambdabot> Data.Time :: module
23:42:28 <lambdabot> System.Timeout.timeout :: Int -> IO a -> IO (Maybe a)
23:43:19 * olsner thinks he almost understands adjoint functors
23:43:41 <ddarius> Hom(F-,=) ~ Hom(-,U=) done
23:43:52 <olsner> as usual, it's something really simple described in a very complicated way
23:44:08 <lament> the short word for that is "math"
23:44:18 <kfish> @remember Cale "Betta watch your back when I'm packin' a nine/I'll pump you fulla holes like the rational line"
23:44:19 <lambdabot> Done.
23:45:05 <Cale> Heh, I should probably point out that line is actually one of my friends' doing :)
23:46:23 <kfish> @citation-needed
23:46:23 <lambdabot> Unknown command, try @list
23:46:33 <Cale> lament: I'm not sure that most math is any more complicated than it needs to be.
23:46:54 <slava> math is all about making things simpler
23:47:04 <slava> giving names to concepts and identifying comon structure
23:47:24 <slava> some programming languages, on the other hand... :)
23:47:27 <Cale> Actually, I don't really care so much for that Hom(F-,=) ~= Hom(-,U=) description of adjoint functors, even though it's the most common one.
23:48:03 <ddarius> Cale: It's my preferred one nowadays.  I used to spurn it, but I was mistaken.
23:48:10 <Cale> (I much prefer the unit/counit description)
23:48:47 <ddarius> Cale: That's pretty, but representability based descriptions seem much more amenable to (pen and paper) calculations.
23:49:05 <Cale> I suppose it depends on what calculations you're doing :)
23:49:10 <ddarius> Indeed.
23:49:19 <ddarius> String diagrams make certain calculations trivial.
23:49:43 <ddarius> Certainly, one should know all of the many definitions and how they relate.
23:51:07 <Cale> But yeah, as an initial definition when you're first learning what adjoint functors are, thinking of adjunction as a kind of weakening of equivalence of categories is nice.
23:52:56 <ddarius> (Incidentally, I also find representability based descriptions seem to be more amenable to computer calculations as well.)
23:53:07 <cjs> Is a constructor considered a kind of function?
23:53:13 <ddarius> Yes.
23:53:34 <Cale> cjs: Yeah -- a data constructor is a function.
23:53:40 <Cale> :t Just
23:53:41 <lambdabot> forall a. a -> Maybe a
23:53:50 <Cale> Well, when it has parameters, it is.
23:53:55 <Cale> :t Nothing
23:53:56 <lambdabot> forall a. Maybe a
23:54:10 <Cale> That's not obviously a function in any meaningful way :)
23:54:45 <Twey> Everything's a kind of function!
23:55:08 <Cale> ... if you squint hard enough.
23:55:08 <Twey> Just some functions take no arguments :-)
23:55:10 <cjs> I see. so we just pass these around as parameters to functions like anything else when we're doing, e.g., a liftM.
23:55:17 <Cale> Yeah.
23:55:21 <Twey> cjs: Yep, that's fine
23:55:22 <Cale> > liftM Just [1,2,3,4,5]
23:55:23 <lambdabot>  [Just 1,Just 2,Just 3,Just 4,Just 5]
23:56:34 <ziman> :t liftM
23:56:35 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
23:57:24 <cjs> So list is a monad?
23:57:52 <Twey> Yep
23:59:21 <ziman> > liftM (+1) (Just 3)
23:59:21 <lambdabot>  Just 4
23:59:23 <Cale> I think it's still my favourite example of a monad
23:59:33 <Cale> (the list monad)
23:59:50 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
23:59:50 <lambdabot>  [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2,...
