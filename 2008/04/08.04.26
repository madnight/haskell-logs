00:00:01 <Koobs> Doh, "want" not "wan't"
00:00:28 <edwardk> then you can work with a list like: [Attribute] and just use the tag to disambiguate
00:01:40 <Koobs> I should elaborate, I'm making a basic tuple-space and using (a -> Bool) type functions for the query.
00:01:58 <Koobs> I want (>5) to match 6 and 6.0
00:02:14 <sjanssen> an existential is probably fine, then
00:02:20 <edwardk> yeah
00:02:25 <sjanssen> Koobs: just looking for opportunities to simplify :)
00:03:08 <Koobs> Existential types, eh?  I'll have to look those up.
00:03:23 <sjanssen> Koobs: this is what the forall a. thing is called
00:03:49 <dolio> Not on a 'type', though.
00:03:51 <ketil> or instance Ord Attribute where compare (Float x) (Int y) = ... ?
00:04:31 <Koobs> Not on a type?  In the 'data Attribute' bit?
00:04:48 <Koobs> I don't know the syntax for that.
00:05:17 <ketil> dolio makes a Fermat exit.
00:07:23 <Koobs> Doh, I can't derive Show if I use an existential.
00:08:48 <dolio> Did I get cut off?
00:09:03 <Koobs> Something about a 'non-Haskell-98 constructor' from GHC
00:09:23 <Koobs> Yes, you did.
00:09:32 <dolio> What'd I last say?
00:09:46 <Koobs> "Not on a 'type', though."
00:09:57 <dolio> Oh.
00:10:08 <dolio> 'data Number = forall a. (Ord a, Num a) => N a' defines an existential type Number.
00:10:14 <dolio> 'type Number = forall a. (Ord a, Num a) => a' does not.
00:10:52 <dolio> 'foo :: Number -> T' would be shorthand for 'foo :: (forall a. (Ord a, Num a) => a) -> T', if I'm not mistaken, which is higher-rank polymorphism, not existential quantification.
00:12:26 <dolio> That might be a good argument for adding an 'exists' keyword, as the two aren't strikingly different.
00:12:47 <Koobs> That they aren't.
00:13:34 <dolio> The latter looks like the 'type' version of the former, since it's just removing the constructor.
00:14:00 <dolio> But it's actually the 'type' version of "data Number = N (forall a. (Ord a, Num a) => a)".
00:14:09 <edwardk> newtype Forall f = Forall (forall a. f a); data Exists f = forall a. Exists (f a)   -- are a pair of types i've been using a lot lately
00:14:24 <Koobs> I still can't derive Show for Number.  Attribute will be a lot more terse, though.
00:15:17 <edwardk> dolio: yeah the 'whether or not the forall is on the inside of the constructor defining if its existential or universal has always struck me as a problem waiting to happen.
00:16:18 <dolio> I read a paper last night that made me want first class existentials, but I guess that won't be happening.
00:22:41 <Koobs> Now I'm getting a 'No instance for (Num Number)' error.  I've hpasted the rest of the code.
00:22:45 <Koobs> http://hpaste.org/7181#a0
00:22:47 <solrize> what is the basic tension in haskell, that prevents it from turning into something like agda?  is it that haskell tries to make its type system as powerful as possible without giving up pervasive type inference, while agda-like languages get even stronger types by throwing inference out the window?
00:23:50 <edwardk> solrize: basically, in a word.. yes =)
00:24:29 <dolio> Haskell people are determined to add features that get you close to dependent typing without actually being dependently typed.
00:24:51 <solrize> edwardk, ic, that makes sense then.
00:25:28 <solrize> dolio, right, i'm asking what it is that they're trying to hold onto by not going to dependent types, and the answer seems to be type inference.
00:26:42 <solrize> but, even when i write haskell without type annotations, it's not like i'm sitting back letting the inferencer do all the work, i still have to think about the types as if figuring out a crossword puzzle in my head
00:27:07 <dolio> I don't know. Dependent typing has a bad rap (or used to).
00:27:20 <dolio> A lot of GHC extensions require type signatures at the top level just like Agda.
00:27:44 <dolio> Although, only for the ones that use the extensions, usually.
00:29:52 <dolio> But then, I annotate almost all my stuff at the top level anyway, so I don't notice a big difference in that regard.
00:30:07 <solrize> i find myself annotating internal stuff as well
00:31:35 <solrize> i've been wondering, suppose you have an incorrectly typed program, so that unification fails.  is it still possible to assign types to most of the terms?  it would be nice to be able to see those types in order to figure out what to do about a given error message.
00:31:39 <dolio> Agda's a bit different in that it doesn't do polymorphism, either.
00:32:09 <dolio> So you need the dependent product to define any function that isn't monomorphic.
00:32:22 <solrize> what's that?
00:32:38 <dolio> Well, in Haskell 'id :: a -> a'.
00:32:48 <dolio> In Agda, 'id : {a : Set} -> a -> a'
00:32:58 <dolio> So, id uses dependent types.
00:33:13 <dolio> More or less.
00:33:17 <solrize> all types live inside Set ?
00:33:30 <dolio> Set is like *.
00:33:52 <solrize> hmm, am i missing something then, or is that just syntax sugar?
00:34:01 <edwardk> Pi a : *. B    plays the role of 'forall a. B' , while Pi _: A. B plays the role of A -> B in a pure type system, modify syntax accordingly to fit Agda/your language of choice ;)
00:34:14 <dolio> You can make them look more similar by writing, in Haskell: 'id :: forall (a :: *). a -> a'.
00:35:00 <edwardk> solrize: also note that that type term comes across like an 'extra argument' that you have to plumb around
00:35:04 <solrize> right, now i'm wondering about something like   head :: [a] -> a
00:35:41 <edwardk> head : { a : Set } -> [a] -> a
00:36:25 <edwardk> but you want to carry around some proof term that says its safe to use generally =)
00:36:30 <edwardk> so it becomes uglier in practice
00:37:02 <dolio> Yeah, like 'head : {a : Set} (l : [a]) {pf : Sorted l} -> a'
00:37:35 <dolio> Sorted, what am I doing.
00:37:39 <solrize> edwardk, hmm, plumb around in the sense that it gets more complicated as you evaluate other functions on it
00:37:41 <dolio> That should be NonEmpty or something.
00:38:09 <dolio> Or 'length l > 0'.
00:38:57 <edwardk> solrize: meaning you carry around a proof that the list is non-empty usually as an extra argument and it becomes non-trivial
00:39:29 <solrize> well, does the syntax let you separate that proof from where you use the term?
00:40:33 <edwardk> agda entangles them they just become another argument. you can't 'think about proofs later' without cheating and adding axioms in most of these settings. =/
00:42:28 <solrize> well, i mean having the proof refer to some separate derivation
00:42:39 <solrize> i don't know what the syntax looks like
00:43:02 <edwardk> solrize: the short answer is yes, the long answer is that i'm a lot more familiar with doing so in coq than agda
00:45:31 <solrize> http://www.lri.fr/~noury/PowerPi.pdf   this paper made dependent types sound practical, but i've otherwise always heard they're very difficult to program with
00:46:34 <solrize> http://www.lri.fr/~noury/    this guy's stuff looks interesting in general
00:47:07 <edwardk> solrize: if you are looking for a decent 'build-up' to pure type systems and dependent types take a look at: http://people.cs.uu.nl/johanj/MSc/jwroorda/
00:47:18 <solrize> thanks
00:47:56 <edwardk> it has the benefit that it starts simply typed, so you chafe a bit then gets to the good stuff quickly enough you don't get frustrated ;)
00:47:59 <solrize> what is PTS?
00:49:00 <edwardk> that is another thing that the paper in question will cover. but its basically a generalization of the system F_omega stuff that a lot of type systems is built up off of that enables you to have one framework for talking about both dependent and non-dependent types
00:49:51 <solrize> wow this looks neat
00:49:53 <edwardk> basically a pure type system has a very small number of rules (like 7) and you parameterize those rules with sorts, rules and axioms, and you get the 'roll your own pure type system' of your choice depending on what tradeoffs you want in your language
00:50:16 <solrize> there's a paper by barendregt that i'm sure is well known, that went along those lines, that i started to read but then couldn't find it again later
00:50:22 <edwardk> yeah
00:50:41 <edwardk> pure type systems are a generalization of the 'lambda cube' aka berendregts' cube whenever he isn't looking ;)
00:51:11 <solrize> heh
00:51:26 <edwardk> all of the systems in the lambda cube can be encoded as a pure type system, just by varying the rules to include or not include 3 of 4 rules.
00:52:49 <solrize> the lambda cube itself was like that, except there were 3 axes instead of 4 ?
00:53:22 <edwardk> well you get one rule you 'have to have' to let terms depend on terms, then you get 3 other axes you can vary
00:53:47 <edwardk> but you can do stuff beyond the cube with a PTS without having to rederive everything from scratch
00:54:54 <edwardk> i.e. Coq (and Agda) uses a predicative type tower, so instead of having two 'sorts' you a type of types of types of types of types of types of ...
00:56:09 <edwardk> you may only see one name like 'Type' in the language as the type of types, but Type i has type Type (i + 1) secretly in the background.
00:56:41 <solrize> that makes sense i guess
00:57:00 <solrize> it's like in set theory, you get new types by iterating the powerset function
00:57:57 <edwardk> in haskell you start to go up and you run out of things to say what is the 'type' of * -> *. you get something maybe we'll call it 'Box' but you can't actually say it in code and you can't talk about functions from Box -> Box.
00:58:24 <edwardk> solrize: exactly
00:58:58 <dolio> How does the lambda cube get away with not having a tower? I guess there's no way to talk about Box -> Box there, either?
00:59:36 <edwardk> the lambda cube you don't get to talk about box. its a type error to have a 'box' appear in an expression basically
01:00:00 <mattam> The omega variants have towers I think dolio
01:00:46 <mattam> Well, limited towers obviously :)
01:01:58 <edwardk> if you skim http://www.augustsson.net/Darcs/LambdaCube/CubeExpr.hs you'll find:
01:02:11 <edwardk>  tCheck _ (Kind Star) = return $ Kind Box; tCheck _ (Kind Box) = throwError "Found a Box"
01:02:21 <dolio> Ah.
01:02:56 <edwardk> i figured i should back up my earlier statement with a reference
01:06:59 <edwardk> dolio: did you opt to add the kernels of the individual morphisms to category-extras?
01:07:33 <dolio> I haven't decided yet. I took a break after tweaking a bunch of stuff, and turning Strf into Cofree.
01:07:41 <edwardk> fair nuff
01:07:49 <edwardk> do you have a free monad in there?
01:08:19 <dolio> Yeah. I added that when trying to work out g_futu.
01:09:17 <dolio> Although I'm debating whether to switch over to your 'Free f a = Either a (f (Free f a))' representation.
01:09:24 <dolio> And same with Cofree.
01:09:26 <edwardk> nice, now i just need to get you to roll the exponential functor stuff in and i'll just use your library instead of my stuff =P =)
01:10:18 <solrize> what does it mean for type checking in PTS to be undecidable?  just that there's no explicit derivation that some two terms have the same type?  why is that an issue of concern, if it's already ok for inference to be undecidable, so you only even attempt checking if you're given a derivation explicitly?
01:10:40 <edwardk> i blogged the explanation stuff using the Place a | Roll (f (Free f a)) originally which i admit makes it easier to explain the easy stuff, but when you start doing a lot of tricky morphisms the power of &&&, |||, *** and +++ is nice without havign to rederive them
01:11:00 <dolio> Yeah.
01:11:02 <edwardk> and it says something more fundamental than 'oh look its a trick for this particular constructor =/
01:11:47 <edwardk> that said i only finally converted a few hours ago when writing up the post ;)
01:11:56 <mattam> solrize: type checking and inference are the same. Consider typing the application rule.
01:12:12 <solrize> mattam, what's the application rule?
01:12:54 <dolio> Well, I was thinking I could even do something like 'FreeS f a x = Either a (f x)' and then do 'Free f a = Fix (FreeS f a)' and get Fixpoint, cata, etc. for free.
01:12:58 <dolio> But that might be overkill.
01:13:30 <mattam> Γ |- f : Π x : A. B  Γ |- e : A  |= Γ |- f e : B[e/x]
01:13:45 <edwardk> dolio: tried it, hated it =)
01:13:52 <dolio> Heh.
01:14:47 <mattam> With some conversion if in the algorithmic version. You need inference to find A and B.
01:14:56 <edwardk> a few posts back i posted up a sort of general library i was toying with just to get my head around fegaras/sheard and hoas. the fourth implementation i cut out of it went that way
01:15:07 <solrize> mattam i'm still trying to grok that expression
01:15:08 <edwardk> the thing is i'm never interested in that
01:15:14 <edwardk> particular functor
01:16:01 <mattam> solrize: It's the rule that types application of a function to an argument.
01:16:22 <edwardk> i'm either interested in Either a (f a) after coming out of a catamorphism  or in the rolled up form.
01:16:39 <solrize> ok, but if the argument term carries a proof that it's a particular type, then no inference is needed
01:17:14 <edwardk> that said the FreeS version you mention does have the advantage of having a single fixpoint operator
01:17:38 <mattam> solrize: values do not carry their types.
01:17:45 <edwardk> only one datatype that actually recurses. i picked up a couple of cleanups from that, but the rolling was a little funny
01:18:15 <mattam> Also, you'd still need to infer B, you only have B[e/x].
01:18:18 <solrize> well i thought values were represented by terms and that the terms carry types
01:19:12 <mattam> types appear in terms but each term does not carry its own type.
01:19:21 <solrize> i really like this guy's thesis so far, it starts at a basic level and is very readable
01:19:22 <dolio> edwardk: Well, it was mostly that I felt bad, while writing a library that does generalized recursion combinators, writing a specific recursion combinator for that data type.
01:19:32 <edwardk> yeah
01:19:40 <mattam> Γ |- id : Π x : *. x -> x   Γ |- A : *  |= Γ |- id A : A -> A
01:19:54 <dolio> Since the machinery is there for getting it automatically.
01:19:58 <edwardk> i'll see if i can dig up the 'flat' version i had of it
01:20:00 <mattam> solrize: Nicolas Oury's thesis ?
01:20:20 <solrize> mattam, jan-willem roorda's thesis, the one edwardk linked a few minutes ago
01:20:49 <dolio> It might mess up the module dependency graph too, though. I'm not sure.
01:21:38 <dolio> Since Free is in its own module currently, but Fix is in the Recursion module (which depends on Free).
01:21:48 <edwardk> dolio: and the traditional derivation usually refers to the free monad as free f a = mu x. a + f x so i guess if you rolled the mu in there explicitly its just more noise in the types
01:23:25 <edwardk> solrize: i'm glad you're finding it useful
01:23:52 <edwardk> solrize: it was what finally made dependent types 'click' for me i think
01:24:19 <solrize> mattam i just don't understand type systems well enough to make sense of those equations.  i've seen some type judgements written out in a somewhat different notation that i think may mean the same thing
01:24:24 <edwardk> even though admittedly at the end his 'dependent' examples are somewhat lacking his explanation of the PTS rules is really good
01:25:59 <edwardk> dolio: oh, btw the cataFree and anaCofree can be rolled into your general catamorphism and anamorphism stuff. but they are slightly weaker, and i don't remember how well they type in haskell since i merged them in an untyped setting =)
01:26:34 <solrize> i have a borrowed copy of TAPL that i've never managed to attempt reading much of
01:27:05 <solrize> i think it doesn't reach into this level of generality though
01:27:15 <edwardk> solrize: the equations can be read as 'if i have the stuff on the left of the |- in my environment then the stuff on the right of it makes sense. and if i have the stuff above the line then everything below the line makes sense.
01:27:34 <solrize> does the : represent a horizontal line?
01:27:42 <mattam> solrize: ATAPL has a chapter on dependent types IIRC.
01:28:26 <solrize> what does     Π x : *. x -> x    mean?
01:28:31 <edwardk> solrize: in the line matthieu wrote out above, it would appear he used |= for the line break
01:28:51 <solrize> is  Π  supposed to be a lambda?
01:28:56 <solrize> or is that pi (product) ?
01:28:57 <mattam> A pi
01:29:00 <solrize> ok
01:29:00 <edwardk> Pi x : *. x -> x can be read "forall (x :: *). x -> x
01:29:36 <edwardk> Pi serves double duty as 'forall' and '->'
01:30:05 <solrize> ok, so that's the type of id
01:30:08 <edwardk> Π x : *. Π _ : x. x
01:30:13 <mattam> Yes.
01:30:14 <edwardk> is another way to say the same thing
01:31:38 <solrize>  Γ |- A : *      just means A is a simple type?
01:31:46 <mattam> Yes.
01:32:37 <edwardk> Π x : *. Π y : x. / insert something crazy involving y here /  is where the power of dependent types kick in, you now have a type that depends not just on types but also on the particular term it was passed.
01:35:11 <solrize> what is a proof then?  i thought of it as a spelled-out series of judgements starting with a term and ending up with a type
01:36:02 <edwardk> if a type is a proposition, then a proof is just the existence of a term that has that given type.
01:36:12 <edwardk> @type flip
01:36:15 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
01:36:49 <mattam> It depends if you refer to proof terms or proofs of typing (which are just derivations).
01:36:54 <edwardk> 'flip' is a proof of that proposition. in haskell it might be degenerate. in a stronger language you probably don't have bottom inhabiting every type
01:37:42 <edwardk> ah, you probably mean what mattieu said
01:39:55 <mattam> 0 is a proof of nat. 4 is another. |- 4 : nat is a proof that 4 is of type nat. To build it you need to repeateadly apply a rule like x : nat |- x+1 : nat starting from |- 0 : nat.
01:41:03 <solrize> edwardk, yes, i mean proof of typing
01:41:27 <vixey> a proof of typing is the same as any other proof
01:42:00 <edwardk> solrize: thats basically a tower of those derivation rules leading down to the statement you are trying to prove
01:42:56 <edwardk> in a well behaved system you'll have one way to get there through your maze of rules or every possible way to get there says the same thing, thats where ideas like principle typings and confluence all come in
01:43:09 <dancor> is there a reasonable way to  supermap :: ((k, a) -> (l, b) -> (m, c)) -> Map k a -> Map l b -> Map m c
01:43:48 <edwardk> s/principle/principal
01:43:51 <vixey> dancor: there's at least two I suppose
01:44:25 <vixey> dancor: since the maps may have different dimension, you could take the product or minimum
01:44:45 <dancor> oh i'm crazy
01:45:03 <dancor> i want  smap :: ((k, a) -> (l, b)) -> Map k a -> Map l b
01:45:42 <vixey> @hoogle Map k a -> [(k,a)]
01:45:42 <lambdabot> Data.Map.assocs :: Map k a -> [(k, a)]
01:45:42 <lambdabot> Data.Map.toList :: Map k a -> [(k, a)]
01:45:42 <lambdabot> Data.Map.toAscList :: Map k a -> [(k, a)]
01:45:43 <Heffalump> @type Data.Map.fromList . map . Data.Map.assocs
01:45:45 <lambdabot>     Couldn't match expected type `[(k, a)]'
01:45:45 <lambdabot>            against inferred type `f a1 -> f b'
01:45:45 <lambdabot>     Probable cause: `map' is applied to too few arguments
01:46:01 <vixey> @hoogle [(k,a)] -> Map k a
01:46:01 <dancor> mm
01:46:01 <lambdabot> Data.Map.fromDistinctAscList :: [(k, a)] -> Map k a
01:46:01 <lambdabot> Data.Map.fromList :: Ord k => [(k, a)] -> Map k a
01:46:01 <lambdabot> Data.Map.fromAscList :: Eq k => [(k, a)] -> Map k a
01:46:06 <Heffalump> @type \f -> Data.Map.fromList . map f . Data.Map.assocs
01:46:07 <lambdabot> forall k a k1 a1. (Ord k) => ((k1, a1) -> (k, a)) -> M.Map k1 a1 -> M.Map k a
01:48:12 <vixey> :t fromList . map ?f . assocs
01:48:13 <lambdabot> Not in scope: `fromList'
01:51:20 <vixey> :t map
01:51:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:51:38 <vixey> @instances Functor
01:51:38 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
01:51:54 <vixey> make a Functor instance for Data.Map?
01:52:19 <Heffalump> how would that help?
01:52:27 <vixey> :t map
01:52:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:52:40 <Heffalump> map only has that type because Cale broke lambdabot
01:52:48 <Heffalump> it's not that type in the prelude
01:52:48 <vixey> :t fmap
01:52:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:53:56 <vixey> oh I guess
01:54:22 <vixey> instance Functor (k,a) where fmap f = fromList . map f . assocs
01:54:31 <vixey> instance Functor (Map (k,a)) where fmap f = fromList . map f . assocs
01:54:45 <vixey> this can't work out can it?
01:54:52 <Androo> I'm just starting to learn Haskell.  How do I check an argument to determine if it is a list?
01:55:02 <Heffalump> vixey: no
01:55:04 <vixey> > elem 5 [1..10]
01:55:08 <lambdabot>  True
01:55:11 <vixey> > elem 66 [1..10]
01:55:11 <lambdabot>  False
01:55:15 <vixey> Androo: that?
01:55:18 <Heffalump> Androo: if it *is* a list? You don't, your types say whether it is a list or not.
01:55:32 <Heffalump> If you want to know if it's *in* a list, then vixey's answer is the way to go.
01:56:06 <Heffalump> vixey: you could make (Map k) into a functor. But that wouldn't help with the original question, and in any case going via a list is a perfectly reasonable solution.
01:57:07 <vixey> something like newtype Map2 (k,a) = Map k a
01:57:22 <vixey> instance Functor Map2 ...
01:57:28 <vixey> but this sucks obviously
01:59:15 <Heffalump> you can't write that
01:59:31 <Heffalump> the LHS of a type declaration has to use separate type variables
01:59:43 <Heffalump> in principle you could do it with associated datatypes, but now things are just getting silly :-)
01:59:59 <Androo> Heffalump: ok, should have been more specific.  I'm writing a Scheme interpreter (seems to be a common task) and have been asked to extend a given Show instance "show (ConsCell v1 v2)" to check to see if its input is a list (it currently does not).
02:01:19 <Heffalump> do you mean whether it is actually show a list of [ConsCell v1 v2] ?
02:01:29 <Heffalump> or whether v1/v2 are lists?
02:02:33 <Botje> Androo: well, conscell v1 v2 is a list if v2 is a list
02:02:46 <Botje> so you can check that recursively
02:03:00 <Botje> although you don't have to check the entire list
02:05:08 <dolio> edwardk: You're right. FreeS is a mess.
02:06:45 <dolio> I can't make it a monad without making Free a newtype, so that's 'return = Free . In . FreeS . Left'.
02:08:01 <edwardk> dolio: yep
02:08:35 <edwardk> dolio: i ran into that problem everywhere when working up the skeleton for Control.Category.Monad, etc. i had so many little 'fixup' newtypes it just got maddening =/
02:09:43 <edwardk> and FreeS adds no value other than to tell you oh yeah this particular Either is a skeleton for a free monad.
02:09:52 <vixey> is there any thing that could be added to haskell/changed that would stop you having to use newtypes?
02:10:06 <Androo> I threw up a description of what I'm trying to do here:  http://pastebin.com/dd87ccf and the code for what I'm extending here:  http://www.gildehaus.net/misc
02:10:11 <edwardk> vixey: you could rip out the occurs check, but then just about everything typechecks
02:10:21 <dolio> Yeah, it's only there so that \f a x -> Either a (f x) can be partially applied.
02:10:59 <edwardk> vixey: i've got a toy typeless haskell-alike (with some odd tricks for operator overloading)  that gets away without newtypes (at least the common ones)
02:11:23 <vixey> interesting, is this online?
02:11:38 <edwardk> vixey: not yet. i got sidetracked a bit =)
02:12:02 <Botje> Androo: what part of the problem ar eyou strugginling with?
02:12:16 <edwardk> thats where all this generalized hylomorphism stuff i've been talking to dolio about all day came from actually. its like the first 20 lines of my prelude ;)
02:12:55 <qwr> edwardk: iirc everything typechecks, if you don't have constants and there are no type signatures nowhere
02:12:58 <edwardk> without types i can feel free to pun constructors, but i have to do a lot of work with views to fix up and handle overloading
02:13:00 <vixey> please hpaste it? :p
02:13:04 <vixey> I'm really curious
02:13:22 <edwardk> vixey: the prelude bit?
02:13:26 <qwr> edwardk: (without occurs check)
02:13:26 <vixey> yeah
02:14:11 <edwardk> @hpaste
02:14:11 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:16:28 <dolio> Agda seems to get away without stuff like newtypes.
02:16:43 <dolio> But that's because it has unrestricted type functions, I suspect.
02:17:59 <edwardk> http://hpaste.org/7182 is a fragment of it that i think is internally consistent
02:18:12 <Androo> Botje: Considering I've had maybe a week of Haskell introduction, I'm clueless as to how to check arguments for type.
02:18:38 <edwardk> #arity declares how many arguments a constructor carries #alias says they are really the same constructor
02:18:46 <edwardk> #infixl and #infixr are ala haskell
02:19:06 <edwardk> #axiom is a 'RULE' pragma
02:19:23 <edwardk> i probably missed some bits like i didn't copy the list view in
02:19:49 <Botje> Androo: you would have to pattern match.
02:20:17 <Botje> a cons cell has the ConsCell constructor
02:20:24 <Botje> and you know a list is a chain of cons cells
02:21:20 <Botje> show (ConsCell v1 v2) = '(' : (show v1) : showInner v2
02:21:31 <Botje> where showInner should check if its argument is a cons cell
02:21:37 <Botje> (pattern match)
02:21:54 <Botje> if it's a cons cell, show the car and continue showInner
02:22:14 <Botje> if the empty list, show a )
02:22:16 <edwardk> vixey: 'overapplication' of a constructor is alowed if you have a suitable function definition for it. thats the strangest thing in the language. but it lets me handle all of my overloading cases.
02:22:27 <Botje> if it's something else, show a ., show the value, and a )
02:22:45 <Heffalump> edwardk: overapplication of a data constructor?
02:23:25 <edwardk> i.e. if i have a unary constructor Ok that expects one argument then Ok x is a value, but if i have a declaration Ok x 0 = x    then i have written a function declaration that basically says how to apply a 'non-function' on the left of an application.
02:24:06 <ski>   map f (BifunctorFunctorT x) = BifunctorFunctorT ! (map f a * map f b) x  -- where does `a' and `b' come from ?
02:24:10 <edwardk> my 'types' for a constructor consist of the arity and a hidden number of extra arguments to accumulate to trigger the pattern match machinery,
02:24:26 <edwardk> heh thats what we call a bug. a and b shouldn't be there ;)
02:25:05 <dancor> @pl \ f g (x, y) = (f x, f y)
02:25:05 <lambdabot> (line 1, column 14):
02:25:05 <lambdabot> unexpected "="
02:25:05 <lambdabot> expecting pattern or "->"
02:25:14 <dancor> @pl \ f g (x, y) -> (f x, f y)
02:25:14 <lambdabot> const . (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
02:25:24 <ski> @type (***)
02:25:25 <edwardk> BiFunctorFunctorT ! (map f * map f) x
02:25:27 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
02:25:29 <dancor> @pl \ f g (x, y) -> (f x, g y)
02:25:29 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
02:25:36 <vixey> (,) on f
02:25:40 <vixey> @src on
02:25:40 <lambdabot> (*) `on` f = \x y -> f x * f y
02:25:40 <dancor> pl hates arrows
02:25:49 <vixey> :t (,) `on` f
02:25:50 <lambdabot> forall b a. (SimpleReflect.FromExpr b, Show a) => a -> a -> (b, b)
02:26:06 <vixey> :@unpl (,) `on` f
02:26:10 <vixey> @unpl (,) `on` f
02:26:10 <lambdabot> (on ((,)) f)
02:26:13 <vixey> :/
02:26:21 <ski> @type ((,) `on`)
02:26:22 <lambdabot> forall b a. (a -> b) -> a -> a -> (b, b)
02:27:10 <edwardk> i'm currently using / as 'on' for functions as a way to test that overapplication stuff
02:28:35 <edwardk> since i don't know what meaning you want for + until  i know context, i suspend it as a constructor then define an initial algebra for tearing it apart. functions are open you can extend them anywhere (cue unsafety complaints here) and pattern matching is most-specific-match  first
02:28:59 <vixey> cool
02:29:21 <edwardk> it means i can have an untyped language with overloading as long as i'm very careful =)
02:30:13 <edwardk> R acts as the 'return' for all monads guaranteed by the monad laws, then you fold up the constructors that represent ambiguous operations by 'typing' it with a view.
02:31:19 <edwardk> it has a long way to go. my current goal is to get some form of counter-example guided unrolling going so i can tell you that you use a function unsafely and why for enough cases that it can be programmed in by mortals
02:33:25 <edwardk> in a language that isn't haskell is there a good argument for not making 'mdo' do the default do? i realize there were some 'it'd be confusing' and 'breaking change' complaints about it for haskell
02:34:14 <vixey> where is mdo?
02:34:38 <edwardk> its not in that prelude. i was thinking in terms of the one haskell has: http://www.cse.ogi.edu/PacSoft/projects/rmb/mdo.pdf
02:36:00 <Heffalump> edwardk: I think it might be dangerous, as most of the time people don't want recursion like that.
02:36:13 <Heffalump> you lose some error diagnosis
02:36:34 <edwardk> Heffalump: heh, well, i took off a LOT of training wheels already ;)
02:38:23 <edwardk> one advantage is you can just nicely say things like do x <- Just ! take 50 (1; x)    and it just does the right thing
02:39:26 <edwardk> er thats if you relax the no final name restriction i guess
02:40:54 <edwardk> i'll probably just do it if i get around to it and see if i scream later
02:42:44 <edwardk> anyways going to go get some sleep
02:55:35 <DRMacIver>  Hm. FFI question. I'm trying to interface with something which returns a CString and I want to associate a finalizer with it to free the String. I'm not quite clear on how this works. Ideally I'd like to end up treating the CString as a ByteString without copying the data.
02:56:22 <DRMacIver> Is this even a valid thing to do?
02:57:01 <Baughn> Is the code performance-critical?
02:57:51 <Baughn> (Because I want to tell you "no; use packCString", but frankly it is)
02:57:56 <DRMacIver> Relatively. Or rather, it's a binding to one of the central operations of a C library so the library's performance will suck a bit.
02:58:13 <DRMacIver> ...if I use a copying operation here I mean.
02:58:40 <Baughn> Okay. How about fromForeignPtr in ByteString.Internal?
02:59:05 <Baughn> A ForeignPtr is, of course, what you get when you attach a finalizer - so that should be fine
03:00:33 <DRMacIver> fromForeignPtr seems to take a ForeignPtr Word8, while a CString is a ForeignPtr CChar. Do I have to cast the pointer?
03:00:54 <DRMacIver> (I've never used the FFI before. This is as much an experiment in learning it as anything else)
03:01:04 <Baughn> Yeah, probably
03:01:13 <DRMacIver> Ok. Thanks.
03:01:31 <Baughn> The cast should be relatively safe. Or you could use ByteString.Char8.Internal, except that doesn't seem to exist
03:01:45 <DRMacIver> Yeah, I looked for that.
03:02:01 <Baughn> The only gotcha is that a CChar /can/ be larger than a Word8
03:02:10 <Baughn> Except that, if Word8 exists, it can't. So..
03:02:40 <DRMacIver> Can it? Huh. I'm forgetting my C then.
03:02:44 <DRMacIver> Not that I ever knew very much. :)
03:02:53 <Baughn> Sure. chars are 8 bits /or more/
03:03:04 <Baughn> But chars are also, by definition, the smallest possible type - one byte
03:03:22 <DRMacIver> Ah, right
03:04:57 <takamu> Me too have a question: I have ghc 6.6.1 installed, and yesterday I built ghc 6.82 and installed it. Now, when compiling my programs, ghc complaints that it can't found parsec and other libraries that I do have installed. I must reinstall all the libraries? or is there any way to convince ghc 6.8.2 that they are installed?
03:05:27 <DRMacIver> GHC underwent a process of library normalization where a lot of things that were in the standard libraries moved out into hackage.
03:05:29 <Baughn> takamu: parsec and friends are (I'm pretty sure) in the "extra libraries" package
03:05:42 <DRMacIver> Also, you need to recompile new libraries against the new version of ghc anyway.
03:05:48 <Baughn> takamu: You won't get them unless you also unpack /that/ tarball as well as the main source
03:06:01 <takamu> ok, i will reinstall them...
03:06:27 <Baughn> Also, make sure you never have two copies of ghc installed. It gets confusing.
03:08:22 <takamu> 6.6.1 is from my distro, and I used it because I didn't want to reinstall all the libraries, but now I see I will have to do that
03:08:57 <Baughn> takamu: Typically, you should do (compile ghc; uninstall distro ghc; install ghc), in that order
03:09:17 <Baughn> It's not that you /can't/ have two copies installed, but the potential for obscure error messages is great
03:09:18 <takamu> ok, now i will clear the mess
03:10:10 * dcoutts has three versions of ghc installed
03:10:26 <Baughn> dcoutts: ..sure, but you understand the implications
03:10:46 <dcoutts> it's really not that confusing
03:11:05 <dcoutts> they all have separate package dbs, by default packages install into per-compiler dirs
03:11:27 <takamu> so I can install two library versions?
03:11:37 <dcoutts> yes
03:11:41 <Baughn> Sure. You can, and /mostly/ it'll work
03:11:52 <takamu> what can fail?
03:12:13 <Baughn> dcoutts is right; the main risk is if you manage to install two separate ghcs /with the same version number/
03:12:18 <Baughn> Which isn't the case here
03:12:44 * Baughn wonders if hardy heron uses 6.8.2 now, or what
03:12:58 <takamu> then I will install the new versions also
03:13:01 <takamu> thanks to all
03:13:24 <dcoutts> Baughn: yeah, that'll make things go wrong in subtle ways
03:13:29 <takamu> now I remember some libraries require 6.6.1
03:13:59 <Baughn> takamu: Very few, these days
03:14:09 <Baughn> But yes, api-breaking changes do that
03:16:13 <DuClare> 'elo
03:16:32 <takamu> hi, DuClare
03:16:32 <DuClare> A beginner here
03:16:47 <takamu> wellcome :D
03:17:20 <DuClare> I ought to start with a simple calculator for an imaginary game like the ones you find on the web ..   resource stockpiles and production & such :)
03:17:23 <Baughn> One by one, we're taking over the world.
03:17:27 * Baughn laughs maniacally
03:17:59 <DuClare> I'm concerned about what's the right way to present a set of values associated with each resource
03:18:50 <DuClare> There could be three resources for example, and one needs to store the amount of each resources in stockpile, and the amount of each resource produced in a given time
03:19:12 <Baughn> Ah. Sounds like a plain old data would do fine.
03:19:24 <DRMacIver> Hm. Using the FFI is slightly scary. Whenever I ask "How do I do this?" the name of the function for doing it is inevitably prefixed with "unsafe". :)
03:19:30 <DuClare> It could be a list; but the amount of fields (different resources) is always static, so list is probably not what I'm looking for
03:19:39 <DuClare> It could be a tuple
03:19:46 <Baughn> Tuple, or data, yes
03:20:16 <opqdonut> date Resources = R {res1 :: Int, res2 :: Float, res3 :: Bool}
03:20:33 <Baughn> Choosing between them is a bit.. well, it's reasonable to claim that "data" = "tuple with extra documentation", if a tuple would work at all
03:20:42 <opqdonut> yeah
03:20:47 <Baughn> With a tuple you won't have field names
03:20:54 <opqdonut> prototype with a tuple, implement with a data
03:21:14 <Toxaris> data = tuple with extra type safety
03:21:23 <Toxaris> and recursion
03:21:34 <Baughn> And existentials, and..
03:21:45 <Baughn> Thus, "if a tuple would work at all". ;)
03:21:46 <opqdonut> well you can get recursion with newtypes, too :P
03:22:22 <Toxaris> the type safety should *help* with prototyping, not hinder it. I would therefore go for a data from start
03:22:38 <DuClare> So hm.  Would something like 'data Resources = {iron :: Integer, wood :: Integer, gold :: Integer}' appear sane?
03:22:55 <opqdonut> yeah
03:23:07 <Baughn> DuClare: Yes, but note that (except for one ghc extension that isn't universally applicable) field names are module-global
03:23:18 <Baughn> DuClare: That is, you can't reuse "gold" as a function name or in another data
03:23:31 <quicksilver> yeah, so unless you're putting that in a self contain module, you might want to use 'resIron' or 'rIron' as a field name.
03:23:35 <quicksilver> otherwise, fine.
03:23:40 <DuClare> Ah, indeed
03:24:13 <Toxaris> DuClare: how do store stockpile amount *and* production rate with this data type?
03:24:44 <Baughn> DuClare: He has a point. Might want to use Resource instead of Integer. ;)
03:25:10 <jorick> i would like to parse "int[-[int]]" (eg 1-, 2-3, 4, -5) as an index in a [String], and return the concat of the referenced parts. how would i go about this?
03:25:48 <DuClare> Toxaris, Production could be represented as 'units per minute' or something, thus Integer would work
03:25:50 <Baughn> DuClare: Might want to do that sort of thing even when he doesn't, in fact - you can type Resource = Integer and then change it later without altering the data, plus it's extra documentation
03:25:55 <jorick> i'm thinking of using a regular expression, but this operation will take place fairly often so i was wondering if there was a better way
03:26:19 <Toxaris> DuClare: so you think about having stockpile :: Ressources and somewhere else production :: Ressources ?
03:26:31 <DuClare> Toxaris, Exactly
03:26:42 <Baughn> jorick: Use parsec? It's not the fastest, but it should be clean and quite fast enough for this
03:26:55 <Toxaris> DuClare: ok that works of course.
03:27:50 <Baughn> jorick: Mind you, your grammar is simple enough that you'd be fine writing a parser by hand, I expect
03:28:52 <jorick> i'm creating my own shell language (based loosely on tcl, bash, mircscript), this parsing is needed for the positional args (eg to evaluate $1) so i'd like it to be really really fast
03:28:58 <Toxaris> fancy idea: data Ressources a = Ressources {iron : a; wood : a; ...} with instance Applicative Ressources and instance Traversable Ressources. That would allow to do tick = zipWith (+) stockpile production
03:29:36 <Toxaris> and similar stuff. but it is slightly too advanced I guess :)
03:29:59 <DuClare> I guess.  Let's keep it simple enough 'till I learn more :)
03:30:34 <DuClare> I typed it, just for the looks if not else. :)  Alright, the next question is — what would be a smart way to do simple calculations, like a sum of two stockpiles :o  clearly newStock = stock1 + stock2 doesn't work outright
03:30:38 <vixey> jorick: don't use regex
03:30:45 <vixey> jorick: Parsec should be fine
03:30:52 <DuClare> Is there something like operator overloading in C++?
03:30:58 <vixey> DuClare: No
03:31:19 <Baughn> DuClare: The really clean way would be what toxaris suggested, but that /is/ too advanced
03:31:38 <DuClare> Baughn, I guess.  What would you suggest for me?
03:31:40 <jorick> ok
03:31:44 <Baughn> DuClare: ..you could try doing it anyway
03:31:55 <Toxaris> DuClare: but you can head in that direction. the first step (which already gains gives you much) would be to abstract the (+) away
03:32:09 <Toxaris> let's see how you would write it by hand
03:33:07 <Toxaris> addRessources (Ressources iron1 wood1 metal1) (Ressources iron1 wood1 metal1) = Ressources ... ?
03:33:21 <Toxaris> hmm. change this stub to contain unique variable names ...
03:34:17 <DuClare> Ah, so we're able to decompose the fields with the constructor used in data definition :o
03:35:14 <Toxaris> DuClare: yes exactly that's the idea
03:36:45 <Baughn> DuClare: You can also (de)compose them positionally, and field names are in fact optional, but if you do that you aren't winning anything over the tuples
03:37:07 <Toxaris> Baughn: static type safety
03:37:19 <Baughn> Okay, there is that
03:37:39 <Toxaris> Baughn: and my example uses positional decomposition
03:37:53 <Baughn> Hum. So it does.
03:38:19 <Toxaris> DuClare: Can you complete the definition of addRessources? (Do you see what it is meant to do?)
03:38:54 <pjd_> (shouldn't that be "resources"?)
03:39:36 <DuClare> pjd_, (yep)
03:40:22 <DuClare> Toxaris, Yeah, I did 'sumResources (Resources i1 w1 g1) (Resources i2 w2 g2) = Resources (i1+i2) (w1+w2) (g1+g2)
03:40:39 <DuClare> Toxaris, Took a moment as I tried out the accessor functions (which I couldn't get working before)
03:43:04 <Toxaris> DuClare: that looks good. Now imagine the function which deducts the price of some building project from the stockpiled Ressources. (wildly guessing what you're programming).
03:43:29 <DuClare> Yeah, I was just thinking of that
03:43:53 <DuClare> Could I create something like combineResources which takes a function and two sets of resources :o
03:44:06 <Toxaris> DuClare: exactly!
03:45:33 <DuClare> Does haskell let me pass an operator where it wants a funcion?  Or do I create things like mul a b = a*b and pass mul instead of *?
03:45:43 <Toxaris> DuClare: you can just pass the operator
03:45:47 <DRMacIver> More stupid FFI questions. :) How do I access C constants (presumably defined as macros) defined in a header file from within Haskell?
03:45:50 <Baughn> DuClare: Haskell has no operators in that sense, only functions
03:45:54 <Toxaris> DuClare: but you have to wrap it in parens
03:45:56 <Baughn> DuClare: "Operators" are just infix functions
03:46:05 <DuClare> Right, indeed :)
03:46:06 <pjd_> > (+) 2 3
03:46:09 <lambdabot>  5
03:46:09 <DRMacIver> (I suspect I should probably be using hsc here, but I wanted at least one attempt at the basic FFI)
03:46:10 <Toxaris> DuClare: the difference between operators and functions is purely syntactic in haskell
03:46:26 <Baughn> DuClare: Well, except for the wart known as "if"
03:46:39 <pjd_> > (*2) `map` [1..3]
03:46:40 <lambdabot>  [2,4,6]
03:47:14 <Toxaris> DuClare: so you can just use   newStockpiled = combineRessource (+) stockpiled production
03:47:27 <Toxaris> DuClare: or   newStockpiled = combineRessources (-) stockpiled price
03:48:01 <Toxaris> DuClare: can you write combineRessources or do you need help with that?
03:48:48 * pjd_ wonders if a Num Resources instance would make sense
03:49:04 <Toxaris> pjd_: fromInteger 3 would mean what for Ressources?
03:49:33 <pjd_> Toxaris: who cares, as long as you can (+) and (-) :)
03:49:44 <DuClare> Toxaris, Yup, that's how I did it..  One question though, is there any practical difference between doing `combineResources f res1 res2 = ...` and using the data accessors, or doing `combineResources f (Resources i1 w1 g1) (Resources i2 w2 g2) = ...` instead?
03:50:12 <Baughn> DuClare: No.
03:50:31 <pjd_> Toxaris: morally, you can just provide the subset of Num you would have if it was more split up
03:50:57 <Toxaris> DuClare: I don't think so. The version using data accessors should be optimized to the version using pattern matching during compilation
03:51:30 <Toxaris> DuClare: just use whatever you like or find useful in a particular situation
03:51:56 <Toxaris> pjd_: but my Applicative and Foldable version is more expressive, and more to the point!
03:52:11 <Toxaris> pjd_: because Ressources is a container
03:52:58 <Toxaris> pjd_: in a world with a sensible Num, I may want instance (Traversable f, PartOfNum a) => PartOfNum (f a) where (+) = zipWith (+) ...
03:53:25 <pjd_> Toxaris: woo, Applicative
03:53:29 <pjd_> that works
03:54:11 <Toxaris> Applicative always works. it's the way to go forward, away from bad old monad land into the shining realm of applicative functors
03:56:57 <Toxaris> DuClare: Now, with combineRessources, you have reached a very usefull abstraction by abstracting the operators (+) or (-) to a higher-order function f. This technique should be enough to express most interesting functions, but of course, there is still more. are you interested in the next step, or do you want to play with this?
04:00:12 <DuClare> Toxaris, I sure am interested, although at this point I might want to write a little helper for printing out a set :o
04:00:59 <Baughn> DuClare: There is already a set type in the standard library, so I assume you mean for printing out a Resources?
04:01:18 <DuClare> Toxaris, yep
04:01:29 <DuClare> Erm, didn't mean to hilight like that. :)
04:01:43 <Baughn> DuClare: You can get that automatically by adding " deriving(Show)" to the data statement, then just use show to print it
04:02:05 <DuClare> Oh, what does that mean exactly?  The deriving part.
04:02:33 <Baughn> Hm. More or less "automatically write an instance Show Resources by rules that are built into ghc"
04:02:55 <Baughn> You can't derive all typeclasses - most notably, you can't derive any you define yourself - but it's handy when it works
04:03:44 <Baughn> DuClare: By those rules, the string it'll generate is the same string that you'd put in your source to /make/ it, or feed to read if you also derive Read.
04:04:31 <DuClare> Neat
04:04:58 <Baughn> DuClare: (You can also derive Ord, Eq, etc. - all the basic typeclasses you'd need to use standard collections and algorithms, so you can mostly just add a deriving clause if you get errors about that)
04:05:20 <DuClare> I'll keep that in mind.
04:05:27 <Baughn> Of course, at some point you'd want to read your tutorial's chapter on typeclasses. ;)
04:06:36 <megeria> sorry, if I have a ghc question is there a better forum to ask than here?
04:07:00 <Baughn> megeria: Depends on the question, but typically not
04:07:12 <Baughn> Anything we can't answer, post to haskell-cafe.
04:09:44 <megeria> okie, trying to find information on the STM implementation in ghc, I read the whitepaper and such, but too tired to figure how it is hooked into the threading model on SMP is there somewhere that I can find that without going to source?
04:10:48 <Baughn> ..that sounds like one for haskell-cafe.
04:11:03 <megeria> lol
04:11:52 <solrize> megeria i don't understand the question
04:12:05 <quicksilver> megeria: there are some details on the implementation at the end of the paper.
04:12:12 <quicksilver> other than that, there is not much written down.
04:12:14 <solrize> i mean, the paper describes it pretty well, i thought
04:13:47 <megeria> its kind of dated on the paper from what i gathered, since it mentioned that the design from a single os thread point of view, i guess i could dig out the source and look at it :(
04:14:36 <megeria> i really like the threading on haskell, its actually a lot simpler than what i have to work with in ada
04:14:38 <solrize> single os thread?  i didn't get that impression
04:15:02 <solrize> the idea is it uses cmpgxchg instead of something like bts
04:15:23 <solrize> to store an incrementing version number when locking a structure for writing
04:15:27 <solrize> so that readers don't need any locks
04:15:45 <solrize> http://research.microsoft.com/~simonpj/Papers/stm/  you saw this apge?
04:15:47 <solrize> page
04:16:03 <quicksilver> megeria is correct.
04:16:12 <quicksilver> the STM paper predates the threaded runtime
04:16:13 <megeria> yeap the composable memory trans paper
04:16:30 <quicksilver> or at least, the paper doesn't talk about the threaded runtime.
04:16:38 <solrize> hmm
04:16:39 <quicksilver> I'm not sure if any paper actaully discusses the threaded runtime.
04:16:46 <solrize> i will confess that i haven't actually tried using stm
04:16:52 <quicksilver> JaffaCake would be the one who would know.
04:16:57 <megeria> i guess use the source luke :)
04:16:59 <solrize> so by definition i haven't hit any issues
04:17:06 <quicksilver> most of the concurrent haskell related papers I have read all talk about the non-threaded RTS
04:17:08 <solrize> however it seemed conceptually complete
04:17:10 <solrize> from what i saw
04:17:41 <solrize> i mean, what kinds of issues are unresolved by the paper?
04:18:49 <quicksilver> it's clear but it doesn't explain the details when there are real threads behind the scenes.
04:19:31 <quicksilver> "Concurrent Haskell is currently implemented only for a uniprocessor. The runtime schedules lightweight Haskell threads...
04:19:32 <Toxaris> DuClare: sorry I was distracted. Let's try to understand what the datatype Ressource really is. It is not just the type of "stockpiled ressources", or the type of "production rate" or the type of "building costs", but it is a general container which allows to map ressources to numbers.
04:19:42 <megeria> actually i can see a way that it extend to real threads from the paper
04:20:39 <Toxaris> DuClare: But what happens if you want to map ressources to a something else then numbers, like strings. consider storing a human-readable string containing the name of the ressource (think internationalization).
04:20:54 <DuClare> Yup
04:21:33 <Toxaris> DuClare: it would be great to do this with something like Ressource. you could use combineRessources to apply operations to these strings on a per ressource base
04:21:47 <Toxaris> DuClare: unfortunately, it is not possible because Ressource is restricted to storing numbers :(
04:22:04 <DuClare> What kind of operations would one do on the strings exactly?
04:22:49 <Toxaris> DuClare: let's say we have stockpile :: NumberRessource and names :: StringRessource
04:23:38 <Toxaris> DuClare: we want to write showRessource :: NumberRessource -> StringRessource
04:23:56 <Toxaris> and then use combineRessources (++) (showRessource stockpile) names
04:24:13 <Toxaris> to produce strings like "5 metal" and "0 wood"
04:24:37 <DuClare> Indeed
04:24:50 <solrize> i glanced up and saw that and thought you were talking about golf
04:24:56 <Toxaris> :)
04:25:54 <Toxaris> to do so, we have to abstract over the type
04:25:58 <__pao__> Hi all :-)
04:26:02 <Toxaris> DuClare: do you know about types?
04:26:24 <DuClare> A little, I guess
04:26:27 <__pao__> how do I split a string on a certain char without reimplementing my custom "words"?
04:26:50 <quicksilver> __pao__: ask someone else to reimplement a custom "words" on your behalf.
04:26:55 <Toxaris> __pao__: you don't. reimplement your custom "words". a good start is the standard "words"
04:26:59 <DRMacIver> Hm. Yeah, so I completely don't understand how the FFI is intended to map any non-trivial C type.
04:27:07 <__pao__> quicksilver: :-)
04:27:13 <quicksilver> DRMacIver: it isn't.
04:27:16 <DRMacIver> ok
04:27:24 <DRMacIver> How about even fairly trivial ones like enums? :)
04:27:28 <quicksilver> DRMacIver: it only maps ints, doubles, chars and ptrs basically.
04:27:30 <DRMacIver> ok
04:27:37 <__pao__> Toxaris: Ok, I'll do that... it's three line infact...
04:27:44 <quicksilver> C enums are just ints in disguise :)
04:27:53 <Toxaris> DuClare: so we have data NumberResources = Resources Int Int Int
04:28:06 <DRMacIver> I know they are. But I'd like a way of getting the names of the enums into my program in a reasonably reliable way.
04:28:07 <Toxaris> DuClare: and data StringResources = StringResources String String String
04:28:31 <quicksilver> DRMacIver: yeah. You need a tool for that. perhaps c2hs or hsc2hs can help.
04:28:45 <Toxaris> DuClare: last time we wanted to abstract (+) and (-) to f. we did so by adding a new parameter (namely f) to the function, and use f instead of (+) resp. (-)
04:29:16 <Toxaris> DuClare: this tinme, we want to abstract Int and String to some type a. we do so by adding a new type parameter (namely a) to the data type, and use a instead of Int and String
04:29:32 <Toxaris> DuClare: data Resources a = Resources a a a
04:30:10 <Toxaris> if we want to actually use Resources, we have to specify some type, like Int or String. e.g., we use stockpile :: Resources Int and names :: Resources String
04:31:21 <DRMacIver> quicksilver: ok. I'll take another look. I was hoping to avoid using them as I wanted a peek at how the FFI worked directly, but I think I can conclude that the answer to that is "Painfully" :)
04:32:57 <DRMacIver> What I'd really like here is something that basically preprocesses a C header and generates a bunch of datatypes and functions for use from Haskell. The results would (deliberately) be painfully low level, but could then be nicely wrapped from another Haskell module.
04:33:24 <quicksilver> DRMacIver: right. that's what the two tools I alluded to do.
04:33:33 <quicksilver> DRMacIver: the FFI is just a way to accessing C calling conventions.
04:33:44 <Toxaris> DuClare: so far, we have avoided to specify both NumberRessources and StringRessources. instead we can use the types Ressources Number and Ressources String. but now comes the cool thing! (everything ok so far?)
04:33:48 <quicksilver> DRMacIver: it doesn't read your source files or even, necessarily, your header files.
04:33:52 <DRMacIver> hsc didn't make it at all obvious that that was what it did. :) But maybe I was looking at the wrong documentation.
04:34:09 <quicksilver> DRMacIver: it just belives you when you tell it that a symbol will exist at link time.
04:34:25 <DRMacIver> ghc at least seemed to do some useful validation against the header file
04:34:35 <DuClare> Toxaris, Well, sort of ...  Do you also give the Int / String / whatever type is wanted on functions' return type?
04:34:37 <quicksilver> yeah, I coul dbe wrong about what the tools do. But I know I'm right about what the FFI doesn't do.
04:34:42 <DuClare> Toxaris, I have getVals :: IO Resources
04:34:44 <quicksilver> it can optionally look at header files.
04:34:55 <DRMacIver> ok. Thanks.
04:34:55 <quicksilver> but it's fairly limited what it does.
04:35:08 <DuClare> Toxaris, Which reads a line and returns Resources
04:36:09 <Toxaris> DuClare: yes, you have to specify a type at this position, and Ressource alone is only a "type constructor". (that is: something which produces types when it is applied to a type. like function produces values when it is applied to a value)
04:36:11 <DRMacIver> The "generate a working Haskell module from a header file" model still seems to be exactly what c2hs and hsc2hs *don't* do, unless I'm completely reading this wrong.
04:37:36 <megeria> quicksilver, solrize: thanks for the help
04:37:41 <DRMacIver> Oh well. I'll give c2hs a try.
04:38:35 <_JFT_> Good Morning haskellers :)
04:39:08 <quicksilver> DRMacIver: hmm. Maybe I totally misunderstood then :)
04:39:23 <quicksilver> DRMacIver: I've not used them. I assumed that's how they worked. Partly from the names.
04:41:32 <DRMacIver> quicksilver: As far as I can tell they're much more "make the process of mixing Haskell and C much less painful" tools which preprocess a mixed source file into something useful.
04:42:11 <DuClare> Toxaris, Alright, I'm ready to go on
04:42:29 <DRMacIver> While what I really like is something which takes a header file, spits out a painfully low level Haskell module with a bunch of opaque data types corresponding to the header's types and then lets me get on with the business of building something usable on top of that
04:42:38 <Toxaris> DuClare: So, the cool thing is that sometimes, you don't care for what a exactly is
04:42:53 <Toxaris> DuClare: an example is the combineResources function
04:43:01 <quicksilver> DRMacIver: I agree that would be a useful tool.
04:43:06 <quicksilver> DRMacIver: would be handy for C++ too.
04:43:20 <DRMacIver> C++ is presumably a lot harder.
04:43:36 <DRMacIver> C has a sufficiently simple set of datatypes that it seems like this shouldn't be that difficult to do.
04:43:42 <vixey> "C++ is the most advanced language, it takes years to learn it all"
04:44:01 <DRMacIver> At least "not that difficult to do" if you know a hell of a lot more C and Haskell than I do. :)
04:44:07 <Toxaris> DuClare: combineResources works by applying an approbiate (!) function f. as long as the type of the function and the type inside the Resource containers are identical, we don't care for what it is
04:44:25 <Toxaris> DuClare: (no not identical, but working together)
04:44:32 <DuClare> Yeah
04:44:32 <minivan> I think kung fu might be a better programming language than C++ while we are at it ;)
04:45:05 <DRMacIver> hsffig seems to be what I want.
04:45:12 <DRMacIver> But it appears to be bitrotted
04:45:19 <Toxaris> DuClare: so what is the type of combineResources f (Resource i1 m1 w1) (Resource i2 m2 w2) = Resource (f i1 i2) (f m1 w1) (f w1 w2)?
04:45:23 <vixey> minivan: link?
04:46:09 <minivan> http://en.wikipedia.org/wiki/Chinese_martial_arts
04:46:20 <vixey> um.................
04:46:37 <vixey> got any example code in it? like finding the prime decomposition ?
04:46:46 <DuClare> Hmm.. (a -> a -> a) -> Resources -> Resources -> Resources ?
04:47:00 <vixey> (a -> a -> a) -> Resources a -> Resources a -> Resourcesa
04:47:07 <vixey> (a -> b -> c) -> Resources a -> Resources b -> Resources c
04:47:34 <DuClare> Ah, indeed
04:48:06 <minivan> vixey: from what I know it seems to involve years of push ups and meditation ;)
04:48:17 <vixey> heh
04:48:20 <DRMacIver> Oh well. It's way too nice a day to be fretting over the FFI.
04:48:22 * DRMacIver goes outside
04:48:23 <DRMacIver> Bye
04:49:23 <Toxaris> DuClare: now let's see how we can use our good old combineResources functions with this fancy new type vixey correctly suggested to code the "5 metal", "0 wood", ... example:
04:50:41 <Toxaris> DuClare: we need a function which maps 5 and "wood" to "5 wood". then, combineResources will take care to use this function for all resources
04:51:55 <vixey> :t (++) . show
04:51:57 <lambdabot> forall a. (Show a) => a -> String -> String
04:52:11 <vixey> > (++) . show $ 5 "wood"
04:52:12 <lambdabot>   add an instance declaration for (Num ([Char] -> a))
04:52:28 <Toxaris> vixey: $ /= magic
04:52:32 <vixey> > ((++ " " ++) . show) 5 "wood"
04:52:33 <lambdabot>  Parse error at ")" (column 12)
04:52:40 <vixey> > (((++ " ") ++) . show) 5 "wood"
04:52:40 <lambdabot>  Couldn't match expected type `[Char] -> [Char]'
04:52:48 <vixey> :C
04:53:23 <Toxaris> > (\amount name -> show amount ++ ' ' : name) 5 "wood"
04:53:24 <lambdabot>  "5 wood"
04:53:32 <vixey> > ((++ (" " ++)) . show) 5 "wood"
04:53:34 <lambdabot>  Couldn't match expected type `[Char] -> [Char]'
04:53:38 <vixey> :t ((++ (" " ++)) . show)
04:53:39 <lambdabot>     Couldn't match expected type `[Char] -> [Char]'
04:53:39 <lambdabot>            against inferred type `String'
04:53:39 <lambdabot>     Probable cause: `show' is applied to too many arguments
04:53:46 <cpoucet> that won't work
04:53:46 <lambdabot> cpoucet: You have 1 new message. '/msg lambdabot @messages' to read it.
04:53:49 <vixey> :t ((++ (" " ++)))
04:53:50 <cpoucet> you're ++ing a function
04:53:50 <lambdabot> ([Char] -> [Char]) -> [Char] -> [Char]
04:54:00 <vixey> ohh of course
04:54:03 <minivan> I think generalizing on it would require infinite type
04:54:09 <vixey> > ((((++ " ")) . show) 5 "wood"
04:54:09 <lambdabot> Unbalanced parentheses
04:54:10 <vincenz> test
04:54:10 <lambdabot> vincenz: You have 1 new message. '/msg lambdabot @messages' to read it.
04:54:23 <cpoucet> dibblego: thanks
04:54:32 <vixey> > (((" " ++) . (++)) . show) 5 "wood"
04:54:32 <lambdabot>  Couldn't match expected type `t1 -> t'
04:54:37 <vixey> I give up
04:54:45 <jorick> don't do it
04:54:56 <vixey> I just want to write (
04:55:01 <vixey> I just want to write (++ " " ++)
04:55:04 <cpoucet> > ((((" " ++) . (++)) ) . show) 5 "wood"
04:55:05 <lambdabot>  Couldn't match expected type `t1 -> t'
04:55:06 <Toxaris> @pl f a n = show a ++ n
04:55:07 <cpoucet> oh
04:55:07 <lambdabot> f = (++) . show
04:55:09 <vixey> :t (++ " " ++)
04:55:10 <Deewiant> @pl \n s -> show n ++ " " ++ s
04:55:10 <lambdabot> parse error on input `)'
04:55:10 <lambdabot> (. (' ' :)) . (++) . show
04:55:22 <cpoucet> @pl \x y -> x ++ " " ++ y
04:55:23 <lambdabot> (. (' ' :)) . (++)
04:55:24 <Toxaris> @pl f a n = show a ++ ' ' : n
04:55:24 <lambdabot> f = (. (' ' :)) . (++) . show
04:55:32 <vixey> > ((++) . show) 5 "wood"
04:55:42 <lambdabot>  "5wood"
04:55:42 <Deewiant> > ((. (" " ++)) . (++) . show) 5 "wood"
04:55:42 <lambdabot>  "5 wood"
04:55:50 <minivan> guys, isn't it better to test first at ghci and then show us the result?
04:55:51 <vixey> > (((++) . (" " ++)) . show) 5 "wood"
04:55:52 <lambdabot>  " 5wood"
04:55:58 <vixey> > (((++) . (++ " ")) . show) 5 "wood"
04:55:59 <lambdabot>  "5 wood"
04:56:07 <vixey> > ((++) . (++ " ") . show) 5 "wood"
04:56:08 <lambdabot>  "5 wood"
04:56:14 <vixey> that sucks
04:56:38 <Toxaris> DuClare: sot he function we want is (\amount name -> show amount ++ " " ++ name), which can be written shorter as ((++) . (" " ++)) . show, but who cares :)
04:56:40 <vixey> is it possible to have a mixfix language with sections which support (++ " " ++)?
04:56:48 <quicksilver> yes, it's possible.
04:56:52 <vixey> could it be reasonably parsed?
04:57:07 <cpoucet> the question becomes
04:57:10 <cpoucet> which argument comes first?
04:57:18 <cpoucet> I mean then you would have to intimately knw associativity
04:57:34 <cpoucet> to know ((x ++ " ") ++ y) vs (y ++ (" " ++ x))
04:57:48 <Toxaris> DuClare: we can now say (combineResources (\a n -> show a ++ " " ++ n) stock names) as we hoped for
04:58:08 <cpoucet> vixey: there's a cleaner way
04:58:14 <vixey> yes?
04:58:20 <cpoucet> > unwords [show 5, "wood"]
04:58:21 <lambdabot>  "5 wood"
04:58:24 <Toxaris> DuClare: this is possible because we abstracted the operation away to write combineResources, and because we abstracted the type away to combine resources of different types
04:58:35 <vixey> cpoucet: neat!
04:58:37 <Deewiant> @pl \n s -> unwords [show n, s]
04:58:37 <lambdabot> (unwords .) . (. return) . (:) . show
04:58:59 <vixey> :t [show, id]
04:59:00 <lambdabot> [String -> String]
04:59:19 <vixey> :t ([show, id] .)
04:59:20 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
04:59:20 <lambdabot>     In the first argument of `(.)', namely `[show, id]'
04:59:22 <cpoucet> won't work, lists are mono-typed
04:59:34 <vixey> gahh
04:59:41 <Deewiant> :t (show, id)
04:59:41 <minivan> :t sequenceM
04:59:43 <lambdabot> forall a a1. (Show a) => (a -> String, a1 -> a1)
04:59:43 <lambdabot> Not in scope: `sequenceM'
05:00:00 <Toxaris> I would use something like [] +?+ x = x; x +?+ [] = x; x +?+ y = x ++ ' ' : y
05:00:17 <Toxaris> now (+?+) . show does what I want
05:00:57 <Toxaris> (the need for such a smart combinator may be a good sign to use a real pretty printing library)
05:00:58 <solrize> :t seqM
05:01:09 <lambdabot> Not in scope: `seqM'
05:02:11 <minivan> M is redundant
05:02:14 <minivan> :t sequence
05:02:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:02:32 <_JFT_> or
05:02:35 <_JFT_> :t sequence_
05:02:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
05:02:41 <Deewiant> or
05:02:42 <Deewiant> :t seq
05:02:44 <lambdabot> forall a t. a -> t -> t
05:02:45 <Deewiant> ;-)
05:02:53 <DuClare> Toxaris, Resources {resIron = "20 Iron", resWood = "32 Wood", resGold = "11 Gold"}
05:02:59 <DuClare> That's what I got
05:03:13 <minivan> is that a game? *_*
05:03:51 <DuClare> nope
05:03:58 <Toxaris> DuClare: yep, we have now a Resources String value wich contains a user readable string for every resource
05:04:04 <Toxaris> DuClare: it's not a game?
05:04:22 <DuClare> Toxaris, It's a calculator, isn't it :)
05:04:34 <DuClare> Well, something like that
05:04:55 * Beelsebob_ ponders why you're storing resources strings rather than just values that can easily have show applied to them
05:05:13 <Toxaris> Beelsebob_: we are talking about "easily applying show" here
05:05:19 <Beelsebob_> data resource = Iron Int | Wood Int | Gold Int deriving show
05:05:34 <_JFT_> Could anybody enlight me please? I dont see why to use either MonadReader or MonadWriter instead of a "simple" state monad. What's the advantage?
05:05:43 <vixey> Beelsebob: that's a sum, they need a product
05:05:59 <quicksilver> _JFT_: more precise types
05:06:08 <quicksilver> _JFT_: you're documenting the fact it's read only
05:06:10 <Beelsebob_> vixey: yeh, but Resources :: (Resource, Resource, Resource) works
05:06:12 <quicksilver> (or write-only)
05:06:23 <Beelsebob_> okay, you could define Iron, Wood and Gold types seperately
05:06:23 <vixey> Beelsebob: that doesn't really work
05:06:24 <_JFT_> quicksilver: Thank you :) I was looking for a technical reason
05:06:30 <vixey> yeah
05:06:34 <Beelsebob_> vixey: it works as well as their method
05:06:35 <_JFT_> quicksilver: your answer make sense
05:06:41 <Beelsebob_> okay, you could use the type system more
05:06:51 <Toxaris> Beelsebob_: but unlike DuClare's approach, your type cannot be made an interesting instance of Applicative, Foldable and Traversable, which is a shame for a Haskell data type
05:06:52 <Beelsebob_> but that has as much enforced in the type system as their method
05:07:14 <_JFT_> quicksilver: so no technical reason outside of more precise typing?
05:07:20 <Beelsebob_> Toxaris: why can't it?
05:07:30 <Toxaris> Beelsebob_: because it's not a type constructor
05:07:37 <Beelsebob_> Toxaris: newtype then
05:07:38 <Beelsebob_> done
05:07:43 <vixey> I'd just define data Prod a b = a :*: b and type Resources a b c = a :*: b :*: c
05:07:51 <quicksilver> _JFT_: precise typing is the best reason there is :)
05:08:16 <_JFT_> quicksilver: then MonadReader's "local" don't make much sense, as it violates that more precise type  :O
05:08:29 <_JFT_> :t local
05:08:30 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
05:08:46 <quicksilver> no, it doesn't.
05:08:52 <quicksilver> it just lets you run a subaction in a different context
05:08:59 <quicksilver> ir doesn't have apermanent affect on the context
05:09:09 <_JFT_> quicksilver: Oh!!!!! Thank you
05:09:15 <_JFT_> quicksilver: Now THAT make sense :)
05:09:44 <_JFT_> quicksilver: that's the part that was nagging at me  :D
05:11:37 <Toxaris> DuClare: you have a fairly cool system now (in my eyes, Beelsebob_ obviously thinks differently). there are three possible next steps now: (1) go on writing your Warcraft-like calculator. (2) define more operations like combineResources (e.g. mapResources :: (a -> b) -> Resources a -> Resources b; applyResources :: Resources (a -> b) -> Resources a -> Resources b). (3) abstract over the datatype Resources to apply the same ideas to different d
05:11:37 <Toxaris> atatypes (e.g. data Soldier a = {atack :: a; defense :: a; speed :: a}).
05:12:07 <Beelsebob_> Toxaris: my point is merely that resources in general want calculations done on them
05:12:14 <Beelsebob_> so it doesn't make much sense to store them as a string
05:12:26 <Beelsebob_> when they could be stored numerically, and have an instance of Num and Show easily derived
05:12:28 <Toxaris> Beelsebob_: I told already that we do not do so
05:12:42 <Beelsebob_> and you haven't said why you don't
05:12:52 <DuClare> Toxaris, Actually I think some kind of (simulated?) state saving would come in handy
05:12:53 <Toxaris> Beelsebob_: we have data Resources a = Resources {metal :: a; wood :: a; ...}
05:12:58 <Peaker> hey, can anyone explain how conal uses Improving Values in FRP to avoid waiting for the later value for a comparison?  Wouldn't it need the "improving value" to get an infinite stream `mappend`ed into it according to the current time? Or is there a way to mappend the current time when comparing only?
05:13:06 <Beelsebob_> Toxaris: oh!
05:13:07 <Beelsebob_> okay
05:13:20 <DuClare> Toxaris, Imagine somebody wants to input information about his stockpiles and production, then do calculations based on them without having to re-enter them for every task
05:13:27 <Beelsebob_> I had the impression you had data Resources = Resources {metal :: String ....}
05:14:08 <Toxaris> Beelsebob_: hehe that would have been a bad idea indead
05:14:10 <DuClare> Beelsebob_, data Resources a = Resources { resIron :: a, resWood :: a, resGold :: a } deriving (Show)
05:14:44 <Beelsebob_> appologies for violently agreeing with you then :P
05:14:45 <DuClare> Oh, Toxaris already mentioned it :o
05:15:03 <DuClare> Hehe, I don't mind.  I'm just trying to learn.
05:15:40 <Toxaris> DuClare: now that's option (1), go on writing your program. now for state, you want a state monad, or maybe a reader monad (hehe, more things to learn).
05:16:07 <Toxaris> DuClare: interestingly, if we had followed the abstract-more-and-more path for another three hours or something, we would have arrived at monads, too
05:16:17 <_JFT_> quicksilver: Thanks again!
05:16:58 <DuClare> Toxaris, Then the abstraction doesn't sound too bad an idea -- I'll have to learn it at some point anyway :)
05:17:41 <Toxaris> DuClare: hehe. unfortunately, I have to read two Papers today and prepare some slides, so I don't think I can spend three hours now :)
05:18:10 <Toxaris> DuClare: but we can go on one step further, and maybe someone else will step in
05:18:19 <DuClare> Sure!
05:18:43 <Toxaris> (it is an interesting opportunity to explain this stuff in the order it should be learned, not it is normally learned. that is: easy stuff first, not most usable stuff first)
05:19:13 <Toxaris> DuClare: so let's go on by defining mapResources :: (a -> b) -> Resources a -> Resources b
05:19:22 <Toxaris> DuClare: you should be able to do it
05:20:58 <DuClare> That takes one function and one set of resources
05:21:04 <Toxaris> Beelsebob_: hehe no problem :) but I disagree with your idea of instance Num Resources
05:21:24 <Toxaris> Beelsebob_: because I don't see what fromInteger 4 :: Resources would mean
05:21:29 <Beelsebob_> Toxaris: I wouldn't necessarily want Resources to be in Num
05:21:52 <Beelsebob_> I would have wanted to enforce the constraint that your 'a' would be in Num
05:22:05 <Beelsebob_> but I guess that there's some flexibility in not enforcing that
05:22:22 <Toxaris> Beelsebob_: obivously, sometimes we want an a in Num, but sometimes we don't
05:22:43 <MarcWeber> What happpens if you implement kind of row based transactions using TVars and you want to do a full backup? Will the one atomic action reading all tvars and writing them to disk retry and retry because some other threads are doing updates occasionally?
05:22:46 <Toxaris> Beelsebob_: such enforcements should be done where types are used, not where they are defined
05:23:06 <Beelsebob_> Toxaris: at least in my invisioning of this situation, I would only be converting it to something not in Num at the last second... e.g. as I wanted to display it
05:23:30 <Beelsebob_> and I'm not sure I agree there
05:23:36 <Beelsebob_> my types are my documentation
05:23:46 <Beelsebob_> I want to document as much as I can about what they mean where they are defined
05:24:44 <DuClare> Did GHC stall or is it just taking time?  I copied the file over to another place and renamed, loaded it in ghci :o
05:24:45 <Toxaris> Beelsebob_: consider the building "wood market", which offers an option to sell two wood for one gold. the behaviour of this option can be represented by (Resources (- 1) (+ 2)) :: Resources (Int -> Int)
05:25:12 <Toxaris> Beelsebob_: obviously, it needs a precondition (you can only sell wood if you have some).
05:25:28 <Toxaris> Beelsebob_: I mean (Resources (+ 1) (-2)) of course
05:25:38 <Beelsebob_> yeh, that's a fair enough point
05:25:59 <Toxaris> Beelsebob_: the precondition can be expressed as (Resources (const True) (>= 2)) :: Resources (Int -> Boolean)
05:26:28 <DuClare> Uhh.
05:26:46 <Toxaris> Beelsebob_: so there *is* a need for more complicated types :)
05:26:56 <Beelsebob_> Toxaris: I wouldn't say a need
05:27:01 <Toxaris> Beelsebob_: a use.
05:27:27 <Beelsebob_> in that the addition can be also described as mapM (+) currentResource (Resource 1 -2)
05:27:36 <Beelsebob_> etc
05:27:46 <Beelsebob_> (-2) even
05:28:18 <Toxaris> Beelsebob: are you talking about instance Monad Resource here?
05:28:58 <Toxaris> Beelsebob: are you talking about instance Monad Resource here?
05:29:01 <DuClare> Toxaris, mapResources f res = Resources (f resIron(res)) (f resWood(res)) (f resGold(res))
05:29:04 <Beelsebob> oops, battery fail
05:29:06 <Beelsebob> Toxaris: yes
05:29:25 <Toxaris> Beelsebob: Monad is only possible if you don't restrict types
05:29:32 <Beelsebob> ah, bugger, yeh
05:29:37 <Beelsebob> okay, fair point :P
05:29:43 <Toxaris> Beelsebob: so once again, we agree
05:29:47 <Beelsebob> yep
05:29:55 <Toxaris> DuClare: yes that's it!
05:30:16 <DuClare> Toxaris, I actually had it done for quite a while, but I'm waiting for GHC to get done with the compilation. :o
05:30:39 <Toxaris> DuClare: this one can be used to write our output function easier:
05:31:04 <Toxaris> DuClare: combineResources (++) (mapResources show stock) names
05:31:30 <Toxaris> DuClare: this is oversimplified, because it doesn't insert spaces, but you could use a space-inserting append function instead of (++)
05:31:57 <vixey> ((++) . (++ " "))
05:32:29 <vixey> :t unwords . (\x y->[x,y])
05:32:32 <lambdabot>     The lambda expression `\ x y -> ...' has two arguments,
05:32:32 <lambdabot>     but its type `t -> [String]' has only one
05:32:32 <lambdabot>     In the second argument of `(.)', namely `(\ x y -> [x, y])'
05:32:35 <DuClare> vixey, What does the dot do in between?
05:33:02 <vixey> DuClare: it's function composition,  (f . g) x = f (g x)
05:33:14 <DuClare> Oh, how come I still can't remember it.
05:33:32 <vixey> > (+1) . (*2) $ 5
05:33:34 <lambdabot>  11
05:34:43 <vixey> :t ((.).(.)) unwords (\x y->[x,y])
05:34:49 <lambdabot> String -> String -> String
05:34:59 <vixey> > (((.).(.)) unwords (\x y->[x,y])) "foo" "bar"
05:35:00 <lambdabot>  "foo bar"
05:35:21 <Toxaris> vixey: (.).(.) == (<$>).(<$>) == the greedy monster
05:35:21 <jorick> i'm using readline for my interpreter, however something weird happens when i press tab: the program prints "clt.hs: no saved_ses \n clt.hs: interrupted", quits and hangs my screen session
05:36:37 <Toxaris> DuClare: the cool thing about mapResources is that it can be abstracted to something very general, very powerfull with a deep fundament in category theory
05:37:07 <cpoucet> functor
05:37:26 <Toxaris> DuClare: to understand why this is possible, we first need a second example
05:37:46 <Toxaris> DuClare: (rule of thumb: if you want to abstract, write two concrete examples and see what is the same / what is different)
05:37:55 <__pao__> Toxaris: what is mapresources
05:37:56 <__pao__> ?
05:38:10 <jorick> google isn't particularely helpful, does anyone know how i can get readline to simply insert a tab when a tab is pressed?
05:38:49 <Toxaris> __pao__: a function we have developed over the last hour. it is similar to map, but works over a list of finite length, encoded as a data Resources a = Resources a a a
05:38:55 <__pao__> jorick: try ctrl-v + tab
05:39:30 <__pao__> Toxaris: nice
05:39:36 <Toxaris> DuClare: I assume we are in some kind of warcraft setting here?
05:40:05 <Toxaris> __pao__: the goal is to have instance Foldable Resource :)
05:40:34 <Toxaris> __pao__: introducing all of Haskell on the way. It's a kind of live-tutorial
05:40:41 <__pao__> Toxaris: :-)
05:40:46 <DuClare> Toxaris, I don't have a specific game in my mind now...  I just happened to see people mentioning such calculators and thought one would make a good excercise for learning haskell.
05:40:59 <__pao__> Toxaris: nice ...  I should give a look at logs :-)
05:41:22 <Toxaris> DuClare: hehe ok, so I assume it's fine to invent a datatype which describes the power of soldiers now
05:41:42 <Toxaris> DuClare: like data Soldier a = Soldier {atack : a; defence : a; speed : a}
05:41:52 <DuClare> Sure :)
05:41:58 <jorick> __pao__, that seems to work, but this is my user interface ... i would really like tabs to just work. i just discovered bindKey so i'm going to experiment with that and see if it can be done with that
05:42:17 <Toxaris> I used the type parameter idea again, to be able to apply our new tricks to this data type again
05:42:20 <DuClare> Toxaris, is one colon intentional?
05:42:29 <Toxaris> DuClare: not at all, it's a typo
05:42:36 <__pao__> jorick: clear
05:42:40 <jorick> or will the user still have to press ctrl-v? that would seem like a bug imo
05:42:42 * Toxaris is looking at scala these days
05:43:00 <__pao__> jorick: your use case is not clear to me...
05:43:23 <Toxaris> DuClare: now, to apply our tricks, we want to write combineSoldier and mapSoldier
05:43:55 <jorick> __pao__, i will try to make a test case and put it on hpaste
05:43:58 <__pao__> Toxaris: how do you like scala? it's seems a little be "immature" to me
05:43:59 <DuClare> Umm.  Now I really wonder if GHC is working as it's supposed to :o
05:44:06 <DuClare> It's been compiling for 17 minutes
05:44:29 <Toxaris> __pao__: it's absolutely great. bad news: it's impure. good news: the type system is more expressible
05:44:56 <__pao__> Toxaris: more expressible that what?
05:45:06 <Toxaris> __pao__: it's still very unstable, so not usable for real-world development, but for toying around, it's really cool
05:45:10 <Toxaris> __pao__: then haskell's
05:45:13 <__pao__> Toxaris: s/that/then/
05:45:28 <__pao__> Toxaris: I see
05:45:44 <__pao__> Toxaris: what do you mean by expressible?
05:46:11 <vixey> probbly synonymous for expressive
05:46:15 <Toxaris> DuClare: mapSoldier will look somehow like this:
05:46:27 <Toxaris> mapSoldier f (Soldier x y z) = Soldier (f x) (f y) (f z)
05:46:34 <Toxaris> and mapResources looked like this:
05:46:47 <DuClare> mapResources f res = Resources (f resIron(res)) (f resWood(res)) (f resGold(res))
05:46:54 <__pao__> vixey: got it
05:46:54 <Toxaris> mapResource f (Resources x y z) = Resources (f x) (f y) (f z)
05:47:03 <DuClare> It's actually shorter without the accessors
05:47:06 <DuClare> So I'll change that
05:47:11 <Toxaris> __pao__, vixey: yes, I mean expressive, sorry.
05:47:28 <DuClare> Toxaris, Can I somehow tell if GHC is actually doing something, other than eating my CPU?
05:47:52 <Toxaris> DuClare: no clue. what commandline do you use to start it?
05:48:37 <DuClare> Toxaris, ghci rescalc.hs
05:49:03 <DuClare> duclare  28044 96.5  1.4  71100 30480 pts/11   Rl+  15:27  21:08 /usr/lib64/ghc-6.8.2/ghc-6.8.2 -B/usr/lib64/ghc-6.8.2 --interactive rescalc.hs
05:49:36 <jorick> __pao__, a use case isn't even necessairy. run System.Console.Readline's "readline" and press a tab ... console hangs
05:49:38 <Toxaris> __pao__: the cool thing and the bad thing about scala's typesystem is: Haskell's notion of datatypes, classes and instances are all unified by the notion of traits. this allows "impure" designs, where you mix "interface describing parts" and "implementation parts" in traits, *but* since scala allows to abstract over traits via generics, you can abstract over classes
05:51:34 <Toxaris> __pao__: this is not possible in Haskell at all, since have a predefined hierarchy of types -- type classes -- nothing else
05:51:42 <Toxaris> __pao__: in scala, you have traits -- traits -- traits -- ...
05:51:47 <__pao__> Toxaris: I feel I need to think a bit about your statement in order to decipher it fully... :-)
05:52:07 <Toxaris> hehe if I would be able to say it in nice words, i would write a paper about it :)
05:53:01 <Toxaris> but my feeling so far is: if Haskell's typesystem can encode it, Scala's can too, and better.
05:53:09 <Toxaris> the only problem is the absence of pureness.
05:53:22 <DuClare> Clearly the only difference is Soldier <-> Resources
05:53:26 <__pao__> jorick: ok... now I've got it... I've never used S.C.Readline... I think you need to "override" tab default behaviour
05:54:05 <Toxaris> DuClare: now comes the bad news: Haskell is not able to easily abstract over this difference
05:54:33 <__pao__> Toxaris: let me see if I understood (your statement, a bit o scala, and a bit of haskell)
05:54:37 <DuClare> (Hmm, it's compiling with one core only)
05:54:42 <Toxaris> DuClare: there are approaches to avoid writing such functions all the time (e.g. "Scrap your boilerplate", "polytypic programming")
05:54:51 <Baughn> Toxaris: Is that true for haskell in general (with all ghc extensions, etc.), or just haskell'98?
05:55:18 <__pao__> Toxaris: haskell has to level of abstractions, variables, type-variables
05:55:23 <Toxaris> Baughn: my feeling is for all of Haskell I know, which is strictly more then H98
05:55:31 <__pao__> Toxaris: haskell has two level
05:55:44 <Toxaris> __pao__: yes, and there are no type-class-variables
05:55:48 <jorick> __pao__, if i call bindKey, will that override the tab or do i need to override it somewhere else?
05:56:29 <__pao__> Toxaris: scala allow you to have n arbitrary levels of abstractions by means of trait and generics
05:56:38 <Baughn> DuClare: Compilation is an extremely hard problem to parallelize, I'm afraid. Or, specifically, optimization is - you can split a program into multiple files and compile them in parallel, but you'll be losing some optimization.
05:57:05 <Toxaris> __pao__: and subtype polymorphism
05:57:10 <__pao__> jorick: I really do know :-( sorry :-(
05:58:19 <jorick> i'll just try to mess around than :D i'll let you know if i found it
05:58:32 <jorick> maybe it's something to do with completion
05:58:51 <Baughn> DuClare: And you just don't want to know how slow unoptimized haskell is. ;)
05:58:59 <Toxaris> DuClare: but what we *can* do is to overload the name map to mean both mapResources and mapSoldier (context-dependant)
05:59:33 <__pao__> Toxaris: the question is... do you really think that is usefull in real use cases? I'm very new to scala, haskell and static type systems (being a dynamic programming guy)... What I like in haskell is the nice compromise between power and simplicity
05:59:56 <DuClare> Baughn, I also don't feel like compiling a 45 line application for more than 30 minutes of CPU time ;)
06:00:57 <Baughn> DuClare: If that happens, then you either have an extremely old computer, or your program has managed to hit one of the degenerate cases in the type-checker
06:01:13 <Toxaris> Baughn: does ghc whole-program optimization?
06:01:14 <Baughn> DuClare: (Given that it's turing-complete, you can actually cause infinite loops if you really try)
06:01:47 <vixey> hmm
06:01:56 <DuClare> Baughn, Can I somehow try to find out what's "wrong" by looking at the source?
06:02:03 <vixey> I don't think turing complete means you can infinite loop
06:02:15 <Baughn> vixey: It does. Halting problem.
06:02:20 <Toxaris> __pao__: my feeling is, that expressing type programs in Scala may be easier then in Haskell. This is important because type-programs give you both a "poor man's dependent types" and "poor man's meta programming"
06:02:35 <vixey> turing completet just means you can compute anything computable right?
06:02:42 <Baughn> vixey: Mind you, that just proves you can cause an infinite loop by reimplementing the type system in the type system
06:02:45 <vixey> any recursive function on N or somesuch
06:03:05 <Baughn> http://en.wikipedia.org/wiki/Halting_problem
06:03:52 <vixey> I don't see how that's relevant actually
06:04:01 <__pao__> Toxaris: clear... do you have any paper link that supports what you are suggesting?
06:04:10 <Baughn> Toxaris: To a certain degree. The .hi interface files include code, for example, which allows it to inline functions from other modules
06:04:19 <__pao__> Toxaris: I'd like to study the question further...
06:04:44 <__pao__> Toxaris: I think I never found an informed haskell vs scala comparison
06:04:52 <Baughn> vixey: "Turing-complete" -> "Halting problem applies" -> "An appropriately constructed program can cause an infinite loop, guaranteed"
06:05:06 <Toxaris> __pao__: no sorry, it's just a feeling. Actually, I think writing such a comparision would be a good thing to do
06:05:20 <Toxaris> __pao__: given that scala is explicitly (partly) modeled after Haskell
06:05:31 <vixey> I don't understand the reasoning behind the second ->
06:06:24 <jorick> i think turing complete means capable of expressing every computable function, it doesn't say "and unable to express infite loops"
06:06:24 <Toxaris> __pao__: but scala is a moving target, e.g. "higher-kinded generics" (related to constructor classes in Haskell) are quite new as I understand it
06:06:45 <vixey> an infinite loop doesn't compute anything
06:07:00 <vixey> so theoretically couldn't there be a TC language in which all valid programs terminate?
06:07:04 <Baughn> vixey: No.
06:07:16 <vixey> why not?
06:07:23 <__pao__> Toxaris: ... and I think the real usage advantes are yet to be demonstrated exactly because is still a moving target...
06:07:23 <EvilTerran> because halting problem
06:07:36 <jorick> it would be nice, but it's impossible
06:07:43 <__pao__> Toxaris: s/advantes/advantages/
06:08:03 <vixey> I don't see why halting problem is relevant
06:08:07 <Baughn> vixey: The halting problem proves that, for every set of a turing-complete language and loop detector, there is at least one program you can write that will cause the loop detector to itself go into a loop
06:08:08 <EvilTerran> however, it is possible to devise a non-TC language in which most interesting problems can still be solved but everything terminates
06:08:15 <Toxaris> __pao__: yes exactly. but my feeling is that it is moving into a good direction (good for what I want to do, e.g., Oleg-like stuff without Oleg-like brain)
06:08:35 <QtPlatypus> Baughn: Its broader then that.
06:08:41 <EvilTerran> for instance, one in which guarded and structural recursion are encoded in the type system and enforced statically
06:08:43 <Baughn> QtPlatypus: Yes, but it does prove this. ;
06:08:57 <byorgey> isn't Agda such a language?
06:09:02 <Baughn> vixey: This implies that if there is no loop detector then you can write a program that will loop, and if there is then you can write one that will cause the /detector/ to loop. Either way, loop.
06:09:10 <byorgey> I know it has a termination checker as well as a type checker
06:09:23 <vixey> I'm not wondering if its' possible to write a an interpreter for such a language
06:09:28 <EvilTerran> byorgey, i believe so - but that's not really a general-purpose language, is it? more of a proof assistant, IIRC.
06:09:33 <QtPlatypus> byorgey: If so the language is not Turing compleate.
06:09:34 <vixey> in some existing turing complete language
06:09:42 <byorgey> QtPlatypus: agreed.
06:09:53 <byorgey> EvilTerran: no, it's actually a general-purpose language.
06:09:56 <vixey> I'm just saying by the definition of turing complete, there's no reason why such a language should have a valid program that loops
06:10:04 <__pao__> Toxaris: who is Oleg? I'm really a bit less than a newbie :-)
06:10:05 <Toxaris> DuClare: So let's see where we are. We want to give a common name to mapSoldier and mapResources. This is possible with a type class in Haskell. They are notated like this: class Container c where mapContainer :: (a -> b) -> c a -> c b
06:10:05 <EvilTerran> oh right. i'll have to have a look at that.
06:10:21 <EvilTerran> ?where oleg
06:10:21 <byorgey> EvilTerran: perhaps still somewhat lacking in the practicals/libraries department, but definitely general purpose.
06:10:21 <lambdabot> http://okmij.org/ftp/
06:10:25 <__pao__> Toxaris: which kind of use you do of haskell/scala?
06:10:31 <QtPlatypus> vixey: What do you mean by "loop"?
06:10:31 <EvilTerran> ok. cool :)
06:10:32 <allbery_b> __pao__: Oleg Kiselyov.  rewgularly does insane thing swith Haskell's type system
06:10:43 <vixey> > let __ = __ in __
06:10:55 <allbery_b> (basically programs in the type system the way we program with values)
06:10:58 <lambdabot>  thread killed
06:11:00 <byorgey> EvilTerran: it is very cool, you should check it out =)
06:11:09 <Toxaris> __pao__: I'm currently interested in embedding extendible domain specified languages with embedded type systems
06:11:23 <byorgey> EvilTerran: I found it pretty easy to pick up, since it's closely related to Haskell
06:11:25 <QtPlatypus> Its possable to create a checker that checks that code never enteres the same state twice.
06:11:39 <Toxaris> __pao__: ... specific ... of course
06:12:01 <Baughn> QtPlatypus: Well, yes, but only because computers aren't turing-complete
06:12:01 <byorgey> QtPlatypus: interesting.
06:12:08 <__pao__> Toxaris: yep...
06:12:18 <QtPlatypus> However its trival to write a non terminating program that never enters the same state twise.
06:12:24 <jorick> vixey the interpreter for that language will have to solve the halting problem (because it has to reject looping computations)
06:12:28 <Toxaris> __pao__: so it's a mix of theoretical computer science and software engineering
06:12:37 <vixey> jorick: that's irrelevant
06:12:38 <byorgey> > print [1..]
06:12:39 <lambdabot>  <IO ()>
06:12:40 <Baughn> Er. I should say: Yes, and that solves the halting problem because computers have a finite number of states
06:12:49 <vixey> the interpreter could be on an Arthur Merlin system or something
06:12:59 <Toxaris> DuClare: have you heard about type classes before?
06:13:21 <vixey> but I'm not interested in the interpreter
06:13:23 <__pao__> Toxaris: I see
06:13:28 <QtPlatypus> Baughn: True but more often then not compleatly impractical.
06:13:53 <DuClare> Toxaris, I believe not
06:14:07 <Toxaris> DuClare: ok, the idea is to express the notion of "a set of types with a common interface"
06:14:28 <Toxaris> DuClare: in our case: "the set of container types which offers a mapContainer method"
06:14:57 <DuClare> Does it have anything to do with the thing like a set of numeric types...  :: (Num a) => a ...
06:15:06 <Toxaris> DuClare: it's exactly the same thign!
06:15:14 <DuClare> Oh, then I've heard of them :)
06:15:52 <Toxaris> DuClare: but Num is a set of types, and our Container is a set of type constructors
06:16:12 <Toxaris> DuClare: Num is defined like this: class Num n where (+) :: n -> n -> n; ...
06:16:24 <Baughn> QtPlatypus: Computer science isn't about what is /practical/. ;)
06:16:32 <Toxaris> DuClare: note that n is directly used as a type
06:16:42 <Toxaris> DuClare: our container class is defined like this:
06:16:52 <QtPlatypus> Baughn: If you say that then I can say my computer has unlimmited memory :D
06:16:56 <Baughn> QtPlatypus: Practically speaking, it is practical to tell people "Don't write programs that deliberately break my halting-problem solver"
06:16:56 <Toxaris> class Container c where mapContainer :: (a -> b) -> c a -> c b
06:17:05 <vixey> So I'm gonna stick with a TC language need not be able to infinite loop
06:17:09 <Toxaris> DuClare: not that c is applied to a or b to produce a type
06:17:22 <vixey> (obviously though, any TC language implemented in this universe will be able to..)
06:17:39 * johnnowak whacks vixey
06:17:46 <vixey> am I wrong?
06:17:54 <johnnowak> you're silly!
06:18:11 <Toxaris> vixey: you miss the point.
06:18:33 * __pao__ thinks that passing time on haskell makes you feel depressed and IGNORANT :-)
06:18:50 <johnnowak> __pao__: think of it this way; you were even dumber before you came in
06:18:51 <QtPlatypus> Baughn: The problem is that a large number of problems can equiverlent to the halting problem  So even if you say "Don't write programs that delibrately break my halting-problem solver" Someone's going to.
06:19:03 <__pao__> johnnowak: :-)
06:19:04 <jorick> __pao__ it gets better after a while :D wikipedia is your best friend here
06:19:22 <johnnowak> wikipedia is a decent friend if you're skeptical of him and don't leave him alone with your girlfriend
06:19:28 <Toxaris> DuClare: do you understand the class notation?
06:19:29 <johnnowak> there's a lot of junk on there
06:19:36 <DuClare> Toxaris, I believe so
06:19:55 <johnnowak> oh i need sleep.
06:19:55 <Toxaris> DuClare: ok, so we have defined the class of type constructors, now we have to populate it
06:19:59 <QtPlatypus> (I worked out once that alph_null functions are equiverlent to the halting problem if you have the right definition of equiverlent)
06:20:01 <jorick> true
06:20:11 <DuClare> (51 minutes CPU time spent ... still not done.  And it's just 45 lines!)
06:20:33 <Baughn> DuClare: It's not going to work. Post the code somewhere so we can see!
06:20:35 <Toxaris> DuClare: if it's not secret, post that code on hpaste.org
06:21:06 <Toxaris> DuClare: we already now two candidates for inclusion into this class: the types constructors Soldier and Resources
06:21:13 <__pao__> I think someone said "I know nothing except the fact of my ignorance" :-)
06:21:24 <Baughn> __pao__: He lied.
06:21:34 <Toxaris> __pao__: socrates?
06:21:39 <__pao__> Toxaris: yep
06:21:52 <__pao__> Baughn: so I'm the only one? :-)
06:22:07 <Baughn> __pao__: Nope. For example, you know how to write english.
06:22:23 <Toxaris> DuClare: we specifiy this inclusion into a class with an instance statement: instance Container Resources where mapContainer = mapResources
06:22:25 <EvilTerran> vixey, in your language, as it's TC, it should be possible to construct an expression for the least odd perfect number. can your compiler determine whether that halts?
06:22:39 <vixey> EvilTerran: yes
06:22:45 <DuClare> There - - http://hpaste.org/7185
06:22:49 <Toxaris> DuClare: so we have to give the name of the class, the name of the type, and definitions for all functions in the interface
06:22:52 * Baughn kinda wishes people would stop quoting Socrates. Yes, great philosopher and all - but almost everything he's said has been discredited since; it /was/ several thousand years ago, after all.
06:22:52 <EvilTerran> if so, there are some mathematicians who would be very interested in hearing from you
06:23:13 <EvilTerran> vixey, and how does it do that?
06:23:14 <QtPlatypus> Well we don't know what he said.
06:23:21 <vixey> EvilTerran: I'm not interested in actually implementing an interpreter for this language is C or whatever, I'm just asking about the actual property of a theoretical TC language
06:23:37 <QtPlatypus> We only have Plato's word and thats unreliable.
06:23:38 <vixey> EvilTerran: it doesn't matter how it does that, it's clearly not possible to implement this ...
06:23:46 <__pao__> Baughn: I think the problem is that with the internet you really get over-dosed with information... and if you are information addicted that's a problem :-) ... someone else has said... "ignorance is a bliss" :-)
06:23:54 <EvilTerran> because it doesn't exist theoretically either, as i understand it
06:23:55 <vixey> EvilTerran: I'm only thinking about the definition of TC though
06:23:59 <vixey> oh?
06:24:03 <vixey> that would be news to me though
06:24:10 <Baughn> vixey: It's possible to leverage the halting problem so that if you have a solver for that, it can solve /any/ problem in finite time - including infinite ones. Good luck. ;)
06:24:19 <jorick> how is a language a language if there is no implementation for it? i thought language = syntax + semantics
06:24:24 <EvilTerran> what Baughn said. it's a proof by contradiction
06:24:39 <vixey> no
06:24:42 <vixey> that's the same argument
06:24:44 <EvilTerran> "assume language exists. prove that unsolvable problems can be solved in it. therefore no such language"
06:24:49 <Toxaris> DuClare: can you give the instance statement for Soldier?
06:24:51 <Baughn> EvilTerran: Well, not really. If it happens to be a complete, superintelligent AI, it might have a chance.
06:25:10 <vixey> again... I'm not saying that this languages interpreter is written in a TC language
06:25:11 <DuClare> Toxaris, instance Container Soldier where mapContainer = mapSoldier
06:25:21 <Baughn> EvilTerran: Unless that problem is one that has been proven /unsolvable/.. I thought it was merely unsolved
06:25:23 <DuClare> Toxaris, How is the layout?  Do the instance statements go inside the class?
06:25:37 <jorick> is there anything bigger than TC ?
06:25:43 <DuClare> Hum, somehow the thing runs fine now.
06:25:44 <DuClare> o_O
06:25:45 <vixey> jorick: loads
06:26:08 <EvilTerran> Baughn, that one's merely unsolved. i just chose it as an example of something that's currently un-known as a demonstration of the unimplementability of the language
06:26:12 <Baughn> jorick: Nothing that appears to be implementable in this universe, but there's an infinite hierarchy of hyperturing computers at least
06:26:12 <jorick> whoa? how can that be?
06:26:15 <EvilTerran> but apparently that's not what vixey's on about
06:26:18 <Toxaris> DuClare: no they are top-level statements and can go anywhere (even in different modules)
06:26:24 <DuClare> Alright
06:26:32 <EvilTerran> jorick, there's turing machine + halting oracle
06:26:45 <Toxaris> DuClare: top-level *declarations* would be a better word I guess
06:26:50 <EvilTerran> turing machine + turing machine halting oracle, that is
06:26:50 <jorick> what's a hyper turing machine?
06:27:08 <EvilTerran> then there's turing machine + turing machine halting oracle + (turing machine + turing machine halting oracle) halting oracle
06:27:12 <EvilTerran> and so forth
06:27:26 <Baughn> jorick: Hyperturing = turing + turing-machine oracle
06:27:27 <QtPlatypus> There are real computers.  That is computers that are able to compute with real numbers rather then naturals.
06:27:28 <EvilTerran> for each layer of machines M, there's a more powerful "M + halting oracle for M"
06:27:58 <jorick> oh i get it now
06:28:07 <Baughn> jorick: Actually, it's really just "any computer that can't be emulated by a turing machine"
06:28:07 <EvilTerran> for instance, a TM with a halting machine for TM can't tell if another machine with such an oracle halts in the general case
06:28:21 <EvilTerran> s/halting machine/halting oracle/
06:28:22 <Baughn> jorick: A quantum computer, by the way, is just another turing machine
06:28:33 <Baughn> A ridiculously powerful one, but still
06:28:47 <jorick> so there are no hyperturing computers atm?
06:28:48 <EvilTerran> just one with better asymptotic complexities for certain classes of problem (?)
06:29:00 <EvilTerran> jorick, they're impossible, i believe
06:29:27 <EvilTerran> there's that whacko who "invented" NaN claiming to have designed a hyperturing machine, but no-one pays any attention to him
06:29:28 <Baughn> jorick: As I said, a quantum computer is a turing machine. They're also capable of emulating physics.
06:29:43 <Baughn> jorick: By inference, quantum physics is unable to implement anything above a turing machine
06:29:58 <DuClare> Toxaris, Now that they've been instanced, how do I use them exactly?
06:30:07 <Baughn> jorick: So it probably won't work in this universe. Happily, quantum physics is known to be wrong
06:30:10 <Toxaris> EvilTerran: I understand that you can simulate a n-bit-quantum computer using a n^2 real computer
06:30:17 <jorick> it's wrong ?!
06:30:34 <QtPlatypus> If that is the case then it follows the universe itself is turing compleate.
06:30:49 <vixey> QtPlatypus: certainly
06:30:55 <Toxaris> QtPlatypus: well, that's the original idea of turing completeness
06:31:04 <QtPlatypus> Yeah.
06:31:08 <Baughn> jorick: Certainly. Quantum physics doesn't imply anything that is implied by general relativity, or vice versa. Worse, they're incompatible.
06:31:16 <jorick> QtPlatypus, doesn't say there couldn't be some oracle laying around somewhere
06:31:21 <Baughn> jorick: That's why figuring out a theory of everything is so hard
06:31:31 <vixey> jorick: it would still be TC though
06:31:38 <QtPlatypus> jorick: Of cause.  Its an open question.
06:31:41 <Toxaris> DuClare: you can just use mapContainer instead of mapResources
06:31:49 <Toxaris> DuClare: or instead of mapSoldier
06:31:57 <Baughn> jorick: An oracle would have to be compatible with physics. Physics appears to be turing-computable, so cannot allow turing oracles. Thus..
06:32:33 <jorick> that's circular reasoning
06:32:39 <Baughn> Not quite
06:33:03 <EvilTerran> he missed out the step where you prove that turing oracles are not turing-computable
06:33:04 <Toxaris> Baughn: Thus an oracle appears to be inexistent
06:33:26 * QtPlatypus has been working on some infomation theorical stuff on the idea that an oracle could be used to violate the second law of therodynamics "But I have nothing solid"
06:33:31 <Baughn> EvilTerran: ..yes. I didn't think you had to prove that.
06:33:46 <EvilTerran> well, *you* don't. it's been done already.
06:34:03 <Baughn> It'd be a two-step proof, though
06:34:23 <Toxaris> DuClare: the interesting thing about the Container class and the mapContainer functions it that very very very many types are instances of Containers
06:34:26 <Baughn> QtPlatypus: That would be nice. I'd very much like to live forever.
06:34:48 <EvilTerran> assume turing oracle; apply to self a la russel's paradox; contradiction! therefore any level of oracle is not computable at that level
06:35:05 <Toxaris> DuClare: or more precise: can be made instances of Containers, because a sensible mapContainer function exists for them
06:35:23 <Toxaris> DuClare: this includes such important types as Haskell's predefined List type and IO
06:35:34 <Toxaris> DuClare: what is the mapContainers function for Haskell lists?
06:35:35 <DuClare> Toxaris, Happen to know a piece of tutorial I can later go back to?
06:35:40 <EvilTerran> and Maybe, Either e, ...
06:35:47 <EvilTerran> ?go you could have invented monads
06:35:49 <EvilTerran> is vaguely relevant
06:35:52 <EvilTerran> hm. no bot.
06:35:55 <jorick> i think physics will appear to be TC untill we find an oracle, but just because we haven't found it doesn't mean we won't find it
06:35:57 <Baughn> jorick: In any case.. physics /appears/ to be turing-computable, but it also seems to have singularities that decidedly /aren't/; on the other hand, those singularities are always nicely hidden away where they can't be noticed, and so physics could be easily implemented by something like a lazy language, so..
06:36:29 <EvilTerran> hehe. "there's superturing bits of the universe, but we can't see them"
06:36:30 <DuClare> Toxaris,  just map?
06:36:37 <Toxaris> DuClare: exactly
06:36:39 <EvilTerran> sounds like as good a definition of god as any...
06:36:39 <vixey> if you zoom in enough :P
06:36:50 <jorick> maybe you can see them if you know how to look
06:36:56 <Baughn> jorick: Two options, if we ever manage to find a naked singularity. First, it'll provide us with a turing oracle; second, it'll be defined as undefined, and will cause the universe to crash. ;)
06:37:09 <Toxaris> DuClare: no sorry I don't know a tutorial which goes this way, most tutorials explain a single concept in isolation.
06:37:19 <Baughn> EvilTerran: Hehe. nakedSingularity x = undefined.
06:37:20 * EvilTerran wishes the bot was here so he could quote Baughn on that
06:37:22 <jorick> hehe
06:37:36 <byorgey> Toxaris, DuClare: Container is more commonly known as... Functor =)
06:37:41 <DuClare> Toxaris, Yeah, I've actually read some tutorials but it's not all that easy to put the pieces together in practice.
06:37:42 <allbery_b> didn't Hawking already prove that black holes can evaporate leaving naked singularities behind?
06:37:53 <byorgey> @src Functor
06:37:59 <Toxaris> byorgey: Hey, it's my live tutorial session ;-)
06:38:02 <DuClare> byorgey, Reminds me of function pointers, C
06:38:04 <Baughn> allbery_b: No. He proved that, given some laws of physics that almost certainly are wrong, that could happen.
06:38:09 <mauke> preflex: remember Baughn Hehe. nakedSingularity x = undefined.
06:38:12 <Baughn> allbery_b: The question is /how/ wrong they are.
06:38:13 <byorgey> Toxaris: oh, sorry =)
06:38:24 <EvilTerran> DuClare, nonono - that's a completely different meaning of functor
06:38:31 <Toxaris> byorgey: but you are invited to join in of course, I should be working anyway
06:38:32 <DuClare> As expected
06:38:42 <EvilTerran> here, it doesn't mean "function object", it means, er... something from category theory
06:39:03 <EvilTerran> "morphism in the category of small categories"
06:39:14 <Toxaris> DuClare: I would advise you not to care *why* it is called Functor, it's just that is *is* called Functor, and mapContainer is called fmap for "functor map"
06:39:18 <DuClare> I've learnt to expect that nothing in haskell is the same as something in C or C++ carrying the same name. :)
06:39:27 <EvilTerran> yeah, that's generally true
06:39:36 <Baughn> EvilTerran: Is the category of small categories in the category of small categories?
06:39:40 <mauke> the C++ meaning of "functor" is just weird
06:39:44 <mauke> it's nothing like OCaml
06:39:50 <EvilTerran> Baughn, i have no idea. i was quoting wikipedia...
06:39:52 <byorgey> Baughn: nope, the category of small categories is not small =)
06:40:00 <Botje> just s/functor/container/ in your head and you'll do fine
06:40:01 <Toxaris> what is a small category?
06:40:13 <EvilTerran> Baughn, i imagine it's not small, though - ah, Baughn beat me to it
06:40:20 <EvilTerran> er, byorgey did, rather
06:40:22 <EvilTerran> fnord!
06:40:36 <Toxaris> DuClare: so instead of defining our own class Container, we should have used class Functor from the standard library
06:40:43 <Baughn> EvilTerran: Don't type empty lines, okay?
06:41:01 <mauke> pɹouɟ
06:41:02 <Toxaris> DuClare: because it's always a good idea to use predefined interfaces instead of inventing new ones. it will increase general interoperability of our code
06:41:44 <DuClare> Uhm...  So could we change the instances from Container to Functor?
06:42:03 <Toxaris> DuClare: exactly. delete the class declaration, and change the instance declarations
06:42:15 <quicksilver> win 24
06:42:17 <quicksilver> duh
06:42:33 <byorgey> Toxaris: basically, a small category is one whose set of objects and set of morphisms are both proper sets (not classes)
06:42:46 <byorgey> although I think there are different ways of axiomatising it.
06:43:01 <byorgey> you know, Russel's paradox, ZFC, all that fun stuff ;)
06:43:07 <DuClare> Toxaris, In functor the mapping function is..  simply 'map' ?
06:43:20 <mauke> fmap
06:43:21 <Toxaris> DuClare: no it's called fmap for stupid reasons
06:43:31 <byorgey> but it SHOULD be called map =)
06:43:38 <mauke> and (.)
06:43:39 <Baughn> @type map
06:43:42 <byorgey> yes, that too
06:43:50 <mauke>  map :: (a -> b) -> [a] -> [b]
06:43:51 <DuClare> Is there any actual distinction between fmap and map?
06:43:57 <byorgey> lambdabot seems to be sleeping
06:44:03 <byorgey> DuClare: yes, map is for lists only
06:44:03 <Toxaris> DuClare: the type is different
06:44:09 <byorgey> DuClare: fmap is for any Functor
06:44:17 <mauke> preflex: seen lambdabot
06:44:17 -preflex(n=preflex@d83-191-186-37.cust.tele2.de)- lambdabot was last seen on #haskell 31 minutes and 38 seconds ago, saying:  <IO ()>
06:44:19 <DuClare> Uhh.
06:44:20 <DuClare> Funny.
06:44:35 <byorgey> ohhh, I killed lambdabot! =(
06:44:37 <allbery_b> ...although Cale is trying hard to make map be fmap
06:44:42 <mauke> :t map
06:44:44 <Cheiron> Never fear, I am here
06:44:44 <Cheiron> forall a b. (a -> b) -> [a] -> [b]
06:44:54 <byorgey> Cheiron++
06:45:00 <byorgey> :t fmap
06:45:01 <Cheiron> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:45:13 <mauke> > fmap (+1) (Just 41)
06:45:15 <Cheiron>  Just 42
06:45:36 <byorgey> DuClare: if you ignore all the stuff at the beginning of the type of fmap, you can see that it's very similar to map
06:45:50 <byorgey> in fact it is the same, but in the type of map, f has been replaced by []
06:46:01 <Baughn> @src [] fmap
06:46:02 <Cheiron> fmap = map
06:46:39 <Baughn> @admin+ mauke
06:46:40 <Cheiron> Plugin `system' failed with: user error (@admin: invalid usage)
06:47:00 <allbery_b> space
06:47:02 <Baughn> @admin + mauke
06:47:13 * Baughn disappears. Have it quit when lb comes back.
06:47:24 <Baughn> Er, leave. Not quit. Leave.
06:47:32 <mauke> huhu
06:49:14 <DuClare> Toxaris, I greatly appreciate your time \o/
06:50:50 <Toxaris> DuClare: let's look at the type of fmap again. it's fmap :: Functor f => (a -> b) -> f a -> f b
06:51:28 <Toxaris> DuClare: that type can be written so: fmap :: Functor f => (a -> b) -> (f a -> f b)
06:51:55 <Toxaris> these two versions are exactly the same, the second just uses explicit parens
06:52:22 <DuClare> It looks like a function it the latter..
06:52:37 <Toxaris> DuClare: Do you know why these types are identical?
06:52:44 <DuClare> No
06:53:03 <Toxaris> DuClare: That's how functions with multiple parameters work in Haskell
06:53:59 <Toxaris> DuCare: the first parameter is processed, and a function is returned, which takes the next parameter and returns a function, which takes the next parameter and returns a function, ..., which takes the last parameter and returns a result
06:54:36 <EvilTerran> f x y = ... is the same as "f x = g where g y = ..."
06:54:44 <Baughn> DuClare: When you have something like a+b+c.. the + function only takes two parameters, so it /has/ to be parametrized somehow. Either (a+b)+c or a+(b+c); either would do in this case, but if you think of - you can see that it matters
06:55:05 <EvilTerran> ... is the same as "f = \x y -> ...", and "f = \x -> \y -> ..."
06:55:08 <Toxaris> Baughn: "parametrized"?
06:55:14 <Baughn> ..parenthesized
06:55:28 <Baughn> DuClare: Types are the same. a->b->c *could* be either (a->b)->c or a->(b->c), but haskell has chosen the latter as its default, basically because it's more useful.
06:56:46 <Baughn> DuClare: (a->b)->c is "function that takes a function and returns a value"; a->(b->c) is "function that takes a value and returns a function that takes a value and returns a value" or, more simply, "function that takes two values and returns a value". That is used rather more often, which is why it's the default.
06:58:54 <Baughn> @admin + Cale
06:59:16 <Baughn> ..shouldn't there be a /response/, or something?
06:59:53 <Toxaris> DuClare: So far we have seen fmap as a multi argument function, which takes a function and a container, and yields a container
07:00:03 <mauke> @flush
07:00:20 <vixey> > 1
07:00:21 <Cheiron>  1
07:00:27 <Toxaris> DuClare: Now we look at fmap as a single-argument function, which returns a function which takes a container and yields a container
07:00:51 <allbery_b> no, @admin doesn't provide any feedback.  (possibly bcause it's usually used in online.rc, not interactively)
07:01:05 <Toxaris> the interesting thing about this point of view is that fmap now takes a function of type (a -> b) and yields a function of type (f a -> f b). so the meaning of fmap is: add f at approbiate places.
07:01:31 <__pao__> is CamelCase to be preferred to foo_foo ?
07:01:34 <EvilTerran> yes
07:02:10 <Toxaris> I guess I mean appropriate
07:03:45 <Toxaris> fmap closely related to function application, because it means "apply the function *inside* the container". this point is emphasized by a different name for fmap, namely (<$>). it's an operator defined in Control.Applicative.
07:04:06 <Toxaris> DuClare: do you know the function application operator ($)?
07:04:58 <DuClare> No :)
07:05:28 <Toxaris> no problem that's an easy one. it applies functions.
07:05:32 <EvilTerran> ?src ($)
07:05:32 <Cheiron> f $ x = f x
07:05:35 <Toxaris> > succ 3
07:05:37 <Cheiron>  4
07:05:38 <EvilTerran> ?bot
07:05:38 <Cheiron> :)
07:05:43 <Toxaris> > succ $ 3
07:05:44 <Cheiron>  4
07:05:51 <EvilTerran> > f $ x
07:05:51 <Cheiron>  Add a type signature
07:05:56 <EvilTerran> > f $ x :: Expr
07:05:57 <Cheiron>  f x
07:06:11 <czakey> he
07:06:20 <EvilTerran> yay simplereflect
07:06:22 <czakey> where is lambdabot
07:06:26 <Baughn> > map ($ 3) [(+1),(+3),(*2)]
07:06:28 <Cheiron>  [4,6,6]
07:06:32 <Toxaris> DuClare: so $ applies functions to values, and <$> applies functions to containers of values
07:06:39 <EvilTerran> she's gone to have a nap
07:06:49 <Toxaris> > succ $ 41 -- $ applies function to values, DuClare
07:06:50 <Cheiron>  42
07:07:09 <Toxaris> > succ <$> [1, 2, 41, 26] -- <$> applies function to containers of values, DuClare
07:07:10 <Cheiron>  [2,3,42,27]
07:07:36 * SamB thinks he sees why people call the two-valued boolean algebra "2" now...
07:08:11 * Toxaris wonders why people bother to introduce a three-valued boolean algebra, instead of using Maybe Bool
07:08:17 <SamB> planetmath says that 2 = {0, 1} ;-)
07:08:22 <SamB> Toxaris: there is no such thing
07:08:32 <SamB> as far as I can see
07:08:42 <Baughn> @src ($)
07:08:43 <Cheiron> f $ x = f x
07:08:50 <Baughn> ..right. What's the default precedence of $?
07:08:51 <SamB> I think that what you are thinking of is in fact not a boolean algebra
07:08:57 <Toxaris> SamB: maybe "boolean algebra" is the wrong term, I'm talking about three-valued logic here
07:09:00 <SamB> Baughn: wrong!
07:09:21 <SamB> it currently works like this...
07:09:33 <Toxaris> Samb: to be true, i don't know what a "boolean algebra" is
07:09:39 <SamB> a $ b $ c = a (b c)
07:09:51 <Baughn> SamB: Don't worry, I'm about to fix that.
07:09:54 <SamB> I guess that's also right
07:10:22 <SamB> Prelude> :i ($)
07:10:22 <SamB> ($) :: (a -> b) -> a -> b 	-- Defined in GHC.Base
07:10:22 <SamB> infixr 0 $
07:10:57 <Toxaris> DuClare: so we have fmap = (<$>), but fmap emphasizes "in a sense" the idea of mapping a function on values to a function on containers; and <$> emphasizes the idea of applying a function on values to a container
07:11:24 <DuClare> Do I have to define <$> myself?
07:11:35 <SamB> Toxaris: as far as I can see, the finite boolean algebras all have 2^n values
07:11:46 <Toxaris> DuClare: you have to "import Control.Applicative"
07:11:57 <Toxaris> DuClare: somewhere at the top of your source file
07:12:10 <DuClare> Neat
07:12:28 <DuClare> Hmm,
07:12:39 <DuClare> import Control.Applicative (<$>) would give only <$>?
07:12:40 <Toxaris> DuClare: the eval bots we have here in #haskell are equipped with a number of sensible import statements
07:12:54 <Toxaris> DuClare: import Control.Applicative( (<$>) )
07:13:01 <SamB> I won't speak about infinite boolean algebras, since I'm not too good on infinity-related terminology...
07:13:08 <DuClare> Why two pairs of paretheses?
07:13:26 <Toxaris> DuClare: inner one to use an operator as a function name, outer one to give a list of things to import
07:13:38 <SamB> DuClare: one to take the section of the operator
07:13:42 <DuClare> Ah, so it's an operator.
07:13:46 <DuClare> That explains.
07:13:52 <DuClare> Of course it is.
07:14:06 <SamB> yes, operators in haskell are just functions with funky syntax
07:14:35 <Toxaris> DuClare: oh that operator vs. function thingie. the rule is simple: if it consists of alphanumeric letters, it's a normal function. if it consists of fancy symbols, it's an operator function.
07:14:41 <DuClare> Everything that goes in between it's parameters and isn't surrounded by backticks is an operator?
07:15:05 <SamB> DuClare: well, maybe the ones with backticks are operators too
07:15:21 <SamB> but the names are ordinary names in that case
07:15:28 <DuClare> Right
07:15:44 <Baughn> > map $ +2 $ [1..5]
07:15:45 <Cheiron>  Parse error at "+2" (column 7)
07:15:57 <Toxaris> > succ `fmap` [1, 2, 3] -- a normal identifier used infix
07:15:58 <Cheiron>  [2,3,4]
07:16:01 <SamB> operator names are indeed the ones that aren't made of letters
07:16:12 <Toxaris> > (<$>) succ [1, 2, 3] -- an operator identifier used prefix
07:16:13 <Cheiron>  [2,3,4]
07:16:22 <vixey> > (.) succ [1, 2, 3]
07:16:23 <Cheiron>  [2,3,4]
07:16:24 <SamB> hmm, what's the current thinking on caseless letters in identifiers?
07:16:39 <Baughn> > (+) $ 2 $ 3
07:16:41 <Cheiron>  5
07:17:06 <Toxaris> DuClare: a cool thing about Haskell is that you can define your own operators easily. There is no predefined set of operators like in C++.
07:17:35 <SamB> > (`map`) succ [1, 2, 3] -- an ordinary identifier used as an operator used prefix
07:17:35 <Cheiron>  Parse error at ")" (column 7)
07:17:39 <SamB> hmm.
07:17:43 <SamB> funky!
07:17:51 <SamB> I think that's not good
07:17:56 <nominolo> @seen dons
07:17:56 <Cheiron> dons is in #haskell. I don't know when dons last spoke.
07:18:00 <SamB> it seems like it would make parsing more complicated!
07:18:03 <vixey> > (succ `map`) [1, 2, 3]
07:18:04 <Cheiron>  [2,3,4]
07:18:11 <vixey> > (`map` [1, 2, 3]) succ
07:18:12 <Cheiron>  [2,3,4]
07:18:22 <vixey> `'s suck in haskell
07:18:35 <SamB> hmm, when did lambdabot get such an odd name anyway?
07:18:38 <ski> > succ `(`map`)` [0,1,2]
07:18:38 <Cheiron>  Parse error at "(`map..." (column 7)
07:18:42 <vixey> actually they're extremely useful
07:18:47 <vixey> but they could be a bit better
07:18:57 <SamB> ski: why the heck would THAT work?
07:19:00 <byorgey> SamB: that's not lambdabot =)
07:19:09 <Toxaris> > let x ?$% y = x ++ ": " ++ y in "DuClare" ?$% "you can define whatever operators you want"
07:19:09 <Cheiron>  Illegal character ''\167''
07:19:09 <Cheiron>  at "" (column 10)
07:19:11 <SamB> byorgey: it is surely lambdabot
07:19:13 <SamB> @version
07:19:13 <Cheiron> lambdabot 4p626, GHC 6.8.2 (Linux x86_64 1.86GHz)
07:19:13 <Cheiron> darcs get /home/svein/dev/milfbot/orig
07:19:18 <ski> SamB : well since yours didn't, my wouldn't either ..
07:19:44 <Toxaris> DuClare: ok, clearly you can't in pratice, but in theory, you can, if you use sensible fancy characters or something
07:19:44 <SamB> ski: mine at least looks reasonable!
07:19:54 <byorgey> SamB: I mean, it's A lambdabot, but it isn't THE lambdabot
07:19:56 <SamB> I can't even begin to fathom what yours was meant to do
07:20:05 <SamB> byorgey: well, yes. I just noticed ;-
07:20:25 <ski> SamB : nesting the back-appostrophes
07:20:26 <DuClare> Toxaris, How would I know which characters are 'sensible'? :]
07:20:37 <SamB> ski: that doesn't work in shell, why would it work here?
07:20:47 <SamB> besides, even this doesn't work:
07:20:53 <Toxaris> I have no clue and I was not aware that  is a problem
07:21:05 <Toxaris> I guess you have to try it out :)
07:21:13 <SamB> > show `(map)` [1,2,3]
07:21:13 <Cheiron>  Parse error at "(map)..." (column 7)
07:21:15 <Toxaris> or to look it up in the Haskell 98 Report
07:21:24 <SamB> Toxaris: lambdabot is probably obstructing it with the pre-parsing
07:22:17 <ski> SamB : yes, i'm just noting (in a silly way) that it could be nice if one could back-quote arbitrary expressions
07:22:20 <SamB> Toxaris: if you fix lambdabot to decode/re-encode the UTF-8...
07:23:01 <SamB> and change Language.Haskell to actually parse identifiers containing unicode...
07:23:25 <SamB> > length "§"
07:23:25 <DuClare> Yeah, it doesn't like my unicode. :]
07:23:25 <Cheiron>  1
07:23:26 <DuClare> <interactive>:1:6: lexical error at character '\35486'
07:23:35 <SamB> oh, duh...
07:23:42 <Toxaris> ski: what would (`x`y`z`) mean?
07:23:47 <SamB> GHC does decode it, so length returns 1, duh...
07:23:51 <DuClare> > length "語"
07:23:53 <Cheiron>  1
07:23:57 <DuClare> Neat.
07:24:14 <Baughn> > succ "語"
07:24:15 <Cheiron>   add an instance declaration for (Enum [Char])
07:24:15 <Cheiron>     In the expression: succ "...
07:24:17 <ski> Toxaris : indeed
07:24:25 <Baughn> > succ '語'
07:24:25 <Cheiron>  Improperly terminated character constant at "'語'" (column 6)
07:24:35 <ski> Toxaris : one would have to find out some way to make the nesting unambiguous
07:24:56 <desegnis> oh, we have a utf8ized lambdabot now? neat indeed
07:24:59 <SamB> see, the issue is that lambdabot runs a seperate parser over the source to make sure it is actually an expression
07:25:07 <Baughn> > "語"
07:25:09 <SamB> because people were doing stuff like this:
07:25:09 <Cheiron>  "\35486"
07:25:12 <SamB> > ) (
07:25:13 <Cheiron> Unbalanced parentheses
07:25:18 <Botje> heh. i've managed to use three different monads in just nine lines
07:25:37 <ski> Toxaris : though in your case, i'm not sure whether the "(`x` y `z`)" interpretation (ISWIM) would be allowed
07:26:07 <SamB> I mean, there was more to it than that, I think, but the point is that they were endingt the parenthesized expression in the boilerplate and inserting wierd shit...
07:26:29 <SamB> Botje: good job
07:26:39 <SamB> Botje: I think you have me beat
07:26:54 <Toxaris> ski: yes, probably a bad example
07:26:57 <ski> now use an unbounded number of monads
07:27:02 <Botje> :)
07:27:09 <Botje> ski: can't do that in a bounded space :p
07:27:10 <SamB> I tried to use as many features as possible in as short a program, once, in some kind of misguided attempt to show people how cool Haskell was...
07:27:22 <ski> (existentially quantified monads ftw !)
07:27:49 <Botje> SamB: mine is fairly innocent, i have an RWS that returns either, and process that in IO
07:27:52 <SamB> Wrote a BF interpreter that used Parsec to parse, the FFI to get that BF "crash the machine with ease" thrill...
07:28:14 <SamB> StateT to hold the Ptr into the array...
07:28:27 <Toxaris> DuClare: ok, so now we have seen that there is a very common abstraction Functor, which allows to map functions on values to functions on containers, resp. to apply functions on values to containers, which really is the same thing.
07:28:50 * EvilTerran would quite like arbitrary expressions in backticks, with the condition that you can't nest backticks without parentheses
07:28:52 <DuClare> Yeah
07:29:09 <Toxaris> DuClare: if we now go back to our little warcraft calculator, we have the function combineResources
07:29:12 <vixey> I'd like mixfix and (++ " " ++) style sections
07:29:27 <SamB> And the parser directly converted the BF to a monadic action
07:29:27 <EvilTerran> `zipWith (+)` would be okay, `zip `on` snd` wouldn't - that'd have to be `(zip `on` snd)`
07:29:37 <SamB> vixey: me too, me too!
07:29:38 <EvilTerran> vixey, i agree about the two-ended section
07:29:48 <Toxaris> DuClare: We could abstract the conrete data type away and invent some type class Combinable
07:29:58 <vixey> what about definitions like:
07:30:05 <vixey> mixfix if_then_else
07:30:11 <DuClare> Toxaris, Let's do it
07:30:13 <vixey> if True then x else y = x
07:30:18 <vixey> if False then x else y = y
07:30:19 <ski> if_then_else_
07:30:26 <vixey> oops, that's what I meant
07:30:35 <ski> Agda/Alfa has such, iirc
07:30:36 <SamB> vixey: I meant about two-ended sections, actually
07:30:39 <EvilTerran> if the section desugaring wasn't (EXP `OP`) -> (OP (EXP)), (`OP` EXP) -> (flip OP (EXP)), (`OP`) -> OP
07:30:41 <SamB> I don't see how the other thing would work
07:30:42 <Toxaris> DuClare: ok, you can do that as an exercise if you want.
07:30:56 <Toxaris> DuClare: you should have seen the necessary techniques
07:31:02 <EvilTerran> but (EXP `OP`) -> (\x -> EXP `OP` x), etc
07:31:11 <SamB> two-ended sections are a lot more within my reach ;-)
07:31:12 <EvilTerran> then two-ended sections would make perfect sense
07:31:22 <desegnis> vixey, how do you interpret that definition style, syntactically? it could also be if_then__y
07:31:32 <SamB> EvilTerran: isn't it?
07:31:38 <SamB> EvilTerran: anyway, it sure can be done
07:31:40 <EvilTerran> ?type ([1,2,3] ++ [4,5,6] ++) -- and it'd also make stuff like
07:31:41 <Cheiron> Plugin `type' failed with: invalid ghci output: no type signature
07:31:42 <vixey> desegnis: I don't know :/
07:31:43 <EvilTerran> er, that work
07:31:49 <vixey> I've not tried writing such a parser
07:31:59 <EvilTerran> SamB, i'm pretty sure it's defined in terms of flip etc
07:32:01 <SamB> > ([1,2,3] ++ [4,5,6] ++)
07:32:02 <Cheiron>      The operator `++' [infixr 5] of a section
07:32:02 <Cheiron>         must have lower preced...
07:32:11 <EvilTerran> SamB, it's not relevant at the moment, owing to the restriction you just ran into
07:32:14 <ski> EvilTerran : seconded
07:32:29 <EvilTerran> SamB, but the two interpretations would be different if that restriction were lifted
07:32:34 <SamB> EvilTerran: yes, obviously that would also need to be dealt with
07:32:41 <Toxaris> vixey: I would love to have the ability to define such functions
07:32:43 <SamB> EvilTerran: hmm?
07:32:51 <EvilTerran> (x ++ y ++) would be interpreted as (++) (x++y) according to the spec
07:33:05 <EvilTerran> which is different to (\z -> x ++ (y ++ z))
07:33:13 <EvilTerran> (parens added for emphasis)
07:33:19 <SamB> EvilTerran: oh, yes, that would need changing
07:33:28 <Toxaris> vixey: which feel like keywords when used, but I as I understand it, it is a problem with parsing
07:33:39 <SamB> the lambda one is clearly the more desirable
07:33:43 <EvilTerran> i initially thought the first way seemed more intuitive, but was quickly won over to the second way when i thought about it
07:33:53 <vixey> Toxaris: I don't know how to combine Mixfix with sections
07:33:59 <SamB> but if ++ was infixl, it should be this:
07:34:02 <vixey> but I'd very much like to be able to define such as
07:34:10 <SamB> (\z -> (x ++ y) ++ z)
07:34:11 <EvilTerran> people might get confused with stuff like (1 + 2*) being (1+).(2*) instead of ((1+2)*), but they'd get over it :)
07:34:16 <vixey> [[ whatever ]] = [[ x ]] + [[ y ]]
07:34:34 <SamB> EvilTerran: they ought not to be
07:34:45 <ski> hm .. sections feel somewhat like relative clauses, in natural language
07:34:46 <EvilTerran> indeed. that's the reason for the current restriction, tho, i believe
07:34:50 <SamB> now all we need is to figure out how the heck you'd parse that
07:35:16 <SamB> EvilTerran: I mean, they should expect a parse error before precedence would be ignored in such a gross way...
07:35:23 <EvilTerran> indeed
07:35:35 <Toxaris> vixey: maybe just outfix operators would be an easier goal
07:35:37 <SamB> because the NUMERICAL precedence of + and * does not permit the latter interpretation
07:35:44 <Toxaris> vixey: they would be cool in itself
07:35:46 <EvilTerran> quite
07:36:05 <DuClare> Toxaris, Let's see..
07:36:06 <DuClare> class Combinable c where combine :: (a -> a) -> c a -> c a -> c a
07:36:21 * EvilTerran thinks about wading into the GHC source and trying to add his generalised sections idea
07:36:39 <EvilTerran> ... it seems like a very appealing idea ATM. probably because i'm meant to be revising. ;)
07:37:13 <vixey> {- _ -} = id
07:37:13 <vixey> wouldn't really work :/
07:37:18 <Toxaris> DuClare: compare this with the existing combineResources function and it's type
07:38:03 <SamB> EvilTerran: generalized to (x ++ y ++) and (++ x ++)?
07:38:27 <EvilTerran> exactly
07:38:29 <SamB> EvilTerran: and I have the same problem :-(. I wish someone offered a major in FP
07:39:11 <SamB> ah, well, I don't think many could deny that knowing how to use a theorem prover is good for EEs?
07:39:34 <vixey> how do you use a theorem prover?
07:39:34 <EvilTerran> knowing how to use a theorem prover is probably good for everyone
07:40:06 <EvilTerran> polishes up your rigorous logic skills nicely
07:40:07 <DuClare> Oh yeah, I'm missing something :>
07:40:48 <SamB> vixey: well, it depends on the theorem prover
07:40:56 <EvilTerran> vixey, in terms of mixfix-y stuff, the idea for quasiquoting in a future version of TH might interest you
07:41:01 <EvilTerran> ?go template haskell quasiquote
07:41:02 <Cheiron> No Result Found.
07:41:15 <DuClare> Toxaris, Doesn't the function take and return same type though?  So (a -> a -> a)
07:41:35 <SamB> at the moment I want Coq with an Epigram-style UI
07:41:58 <vixey> how is Epigrams UI better than Proof General?
07:42:11 <Toxaris> well, class Combinable c where combine :: (a -> a -> a) -> (c a -> c a -> c a) is an option
07:42:38 <Toxaris> but it is generally a good idea to provide types as general as possible
07:42:43 <SamB> vixey: Well, I like the way you end up with a program
07:43:01 <SamB> which you see in your buffer
07:43:16 <Toxaris> so DuClare will it be possible to combine containers with a function (a -> b -> c), and whould be the type of combine in this case
07:43:31 <SamB> even though you only wrote a small amount of it
07:43:37 <Toxaris> DuClare: hmm, better go for (x -> y -> z), since c is already taken for the container
07:43:38 <vixey> I have toyed with Coq and Agad 2
07:43:53 <SamB> or, well, maybe half
07:44:13 <vixey> and Twelf
07:44:25 <vixey> they are very different
07:44:39 <ski> "Bob gave the book to Lisa, who was managing the engine."
07:44:45 <ski> np (rel NP Rel) --> np NP,tok who,all X\ ( (np X --> true) -o np (Rel X)).
07:44:51 <ski> something like that, iirc
07:45:16 <SamB> vixey: yeah
07:45:25 <DuClare> Toxaris,  I think yes — the type would be c z ?
07:45:27 <sw17ch> so, say that i wanted to, for fun/learning, write a haskell parser/interpreter... where would I start? I guess the parser is the most important part to me. :)
07:45:27 <SamB> well, Agda is different, anyway
07:45:45 <vixey> I'm most impressed with the reflection stuff you can do
07:46:04 <Toxaris> DuClare: hmm, the overall type of combine should be something like combine :: (x -> y -> z) -> ...
07:46:11 <vixey> like in Coq writing new proof search methods.. in Agda making new notations to write proofs in
07:46:31 <ski> Toxaris : s/Combinable/Zippable/ ?
07:46:34 <SamB> vixey: you can make new notations in agda now?
07:46:42 <SamB> how is the Emacs interface for agda at the moment?
07:46:51 <SamB> I don't even remember how it was last I looked
07:46:52 <vixey> it's fine
07:47:01 <SamB> what do you do in it?
07:47:05 <Toxaris> ski: yep. but it's just an exercise on the way to Applicative, since Functor instance is ZipList like anyway
07:47:07 <DuClare> Toxaris, combine :: (x -> y -> z) -> c x -> c y -> c z
07:47:17 <Toxaris> DuClare: yes exactly
07:47:23 <vixey> it does syntax coloring which is very nice and you can query what types go where while you write a program
07:47:39 <SamB> vixey: how epigramy is it?
07:47:42 <vixey> so it's a nice thing for program derivation
07:47:49 <vixey> I didn't try Epigram
07:47:58 <ski> (clarification, that logic programming comment above was meant as a comment on parsing sections)
07:48:03 <Toxaris> DuClare: compare this type to the type of fmap
07:48:06 <vixey> just read all these baffling papers abotu  OTT
07:48:08 <SamB> and what does it have in the way of parameterization?
07:48:33 <SamB> vixey: well, epigram 1 doesn't work terribly well... keeps crashing on me... names stuff badly...
07:49:07 <Toxaris> sli: the cool thing about all the CT-inspired type classes is that they are perfectly obvious if you come from Functor and specialize, instead of going directly to Monad
07:49:08 <SamB> makes it entirely too painful to revert a term to editable form
07:49:29 * vixey wonders when Epigram 2 is coming..
07:49:41 <Toxaris> ski: that was for you of course. It's a kind of "you could have invented Control.*" approach
07:49:43 <SamB> doesn't unify equal things all the times it ought to
07:49:47 * jyp mumbles something about Agda 2
07:49:56 <vixey> jyp: hmm?
07:50:17 <jyp> I call Agda 2 the working version of Epigram :p
07:50:20 <ski> Toxaris : which CT-inspired type classes ?
07:50:28 <SamB> jyp: okay, cool
07:50:34 <Toxaris> ski: Functor, Applicative, Monad, Alternative, ...
07:50:39 <vixey> I think Agda 2 is very different to Epigram
07:50:39 <SamB> I guess I should try that then
07:50:47 <vixey> not talking about Syntax
07:50:59 <vixey> but the actual foundations
07:51:01 <adekoba> is there any way to uninstall packages with cabal?
07:51:01 <SamB> anyway, I managed to prove that addition is commutative yesterday in Coq
07:51:20 <Toxaris> ski: if you start with Functor, and try to add expressivity, motivated by examples of programs you want to write, you arrive at the more complicated classes, because they just express what you want.
07:51:22 <SamB> but I still have to prove that multiplication is
07:51:26 <jyp> vixey: like what?
07:51:27 <vixey> SamB: I have a proof in Agda of foldr/foldl if you lieke
07:51:38 <SamB> vixey: proof of what about it?
07:51:51 <DuClare> Toxaris, The only difference would be that combine uses a function which works on two sets of values instead of just one.. :o
07:51:58 <vixey> foldr (flip f) z l = foldl f z (reverse l) -- for inductive l
07:52:03 <allbery_b> adekoba: no.  you can ghc-pkg unregister and then remove the package directory (most packages install nicely in their own directory trees)
07:52:08 <DuClare> Thus it also takes the two sets in
07:52:28 <ski> Toxaris : ok .. (i was wondering if you maybe meant starting with some other `Category' and try using functors,monads over that one ..)
07:52:36 <vixey> jyp: I don't really know the details but I think Epigram is OTT and Agda is CoC .. some importart differences wrt either eta equality or something like that
07:52:54 <vixey> jyp: maybe someone else here can clarify it for me
07:53:05 <adekoba> allbery_b: ok. and those would be in /usr/lib/ghc-x.x.x/lib ?
07:53:32 <Toxaris> ski: hehe sounds interesting too, but well beyond my knowledge. If I need a specific category, I ask the guy in the office next to mine's who understands that stuff
07:53:44 <allbery_b> usually in /usr/lib/package-version in my experience.  you should be able to query with ghc-pkg
07:53:55 <adekoba> adekoba: is it preferred to install packages in one's home directory? or maybe in /usr/local?
07:54:07 <ski> (Toxaris : for `Category' think roughly `Arrow')
07:54:14 <adekoba> er, allbery_b rather
07:54:55 <vixey> I never took any intrest in non Type Theory based systems
07:54:56 <Toxaris> DuClare: so we have fmap for unary functions, combine for binary functions, and we would need another class and function for trinary functions and so on
07:55:02 <vixey> not sure what is happening in that area
07:55:10 <DuClare> Toxaris, Indeed.  Sounds like a waste
07:55:22 <Toxaris> ski: that would mean to have the same objects, but different morphisms?
07:55:40 <Toxaris> ski: and then to study the functors, monads, whatevery on this, maybe simpler category
07:56:11 <ski> *nod*
07:56:12 <allbery_b> generally --user and something under your home directory is preferred unless you actually intend for it to be global (as with the official supported builds I'm doing for CMU ECE)
07:56:29 <Toxaris> DuClare: the crucial step to avoid this waste of effort is to apply the trick about multi-ary functions encoded as unary functions which Haskell uses all the time
07:56:30 <ski> (though having different objects would be nice, too .. like `FunctorFunctor')
07:56:37 <ski> http://lambda-the-ultimate.org/node/2785
07:56:45 <adekoba> allbery_b: nice. thanks for your help.
07:56:53 <ski>  Species: making analytic functors practical for functional programming
07:57:24 <byorgey> anyone familiar with Cairo?  I want to draw the outline of an ellipse, but if I apply a non-uniform scaling to a circular arc and then stroke it, the stroke comes out scaled too -- so it gets fatter then skinnier.
07:57:45 <byorgey> is there a way to apply the scaling to the path itself, and then stroke that?  or some other trick to get a uniform stroke?
07:58:15 <Toxaris> DuClare: do you remember Haskell's trick about multi-ary functions?
07:58:20 <ski> http://lisperati.com/landoflisp/f057.png    side effects
07:58:29 <allbery_b> anyway, "ghc-pkg describe package-version" to get paths and such
07:58:33 <pjd_> snide effects
07:58:51 <DuClare> Toxaris, Do I know it?
07:59:12 <Toxaris> DuClare: we've started to talk about it in the context of the type of fmap, but we did not look deeply into it
07:59:32 <byorgey> I guess I could draw the ellipse using cubic bezier splines instead of scaling a circular arc =P
07:59:35 <Toxaris> DuClare: the idea is that a binary function can be seen as a unary function which returns another unary function
07:59:49 <DuClare> Right
08:00:00 <DuClare> I got the idea, although it's still quite confusing.
08:00:05 <DuClare> Hard to think at such abstract level..
08:00:12 <Toxaris> DuClare: let's look at an example.
08:00:17 <Toxaris> > (+) 3 4
08:00:19 <Cheiron>  7
08:00:30 <edwardk> toxaris, ski: I started putting together a sort of generic 'categorical' version of Functor, etc that can work over different categories, but it seems to be a mess with haskell typeclasses to actually use many other categories.
08:00:38 <edwardk> or at least to derive the things like the dual category. you run into the functor/contrafunctor composition problem and the fact that you don't always have a way to handle newtype labels
08:01:00 <pjd_> > (((+) 3) 4)
08:01:02 <Cheiron>  7
08:01:06 <ski> edwardk : `functor/contrafunctor composition problem' ?
08:01:07 <jyp> community.haskell.org is down for me...
08:01:07 <EvilTerran> ... for the idea of splitting Alternative into Additive where { zero; (<+>) }, Alternative where { empty; (<|>) }, what were the algebraic properties for the different classes again?
08:01:24 <Toxaris> DuClare: Here we have the binary function + which adds 3 and 4 to return 7
08:01:25 <EvilTerran> ISTR "x <|> x = x" was the one for Alternative
08:01:29 <ski> > let add_3 = (+) 3  in  (add_3 4,add_3 10)
08:01:30 <Cheiron>  (7,13)
08:01:33 <geezusfreeek> :t (+)
08:01:40 <geezusfreeek> aw
08:01:45 <ski> > let add_3 = (+) 3  in  map add_3 [4,10,42]
08:01:45 <vixey> @ty (+)
08:01:46 <Cheiron>  [7,13,45]
08:01:46 <Cheiron> Plugin `type' failed with: invalid ghci output: no type signature
08:01:48 <Toxaris> EvilTerran: isn't that one the Haskell Wiki, on some page about MonadPlus?
08:01:49 <EvilTerran> (along with the monoid requirement for both, of course)
08:01:50 <geezusfreeek> oh wait, that's not lambdabot!
08:01:58 <EvilTerran> ?wiki MonadPlus
08:01:58 <Cheiron> http://www.haskell.org/haskellwiki/MonadPlus
08:02:01 <vixey> Baughn: seems like a bug
08:02:03 <edwardk> ski: defining one operator :.: for functor composition, then (f :.: g) is the composition of functors f and g, but you'd like Functor f, Functor g to imply Functor (f :.: g)
08:02:19 <edwardk> otoh, ContraFunctor f, ContraFunctor g => Functor (f :.: g)
08:02:29 <Toxaris> EvilTerran: I recently learned that Parcec's <|> cannot made into <+> by whatever magic you want to apply
08:02:44 <Toxaris> EvilTerran: at least, someone here told me that, I tried to do it anyway, and failed
08:03:07 <edwardk> and ContraFunctor f , Functor g => ContraFunctor f :.: g, and the equivalent flipped version, and definitions for adjunctions deriving monad and comonad off of composed functors, etc.
08:03:16 <EvilTerran> Toxaris, how curious
08:03:28 <Toxaris> DuClare: now let's look at (+) 3:
08:03:28 <ski> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
08:03:31 <edwardk> you run into an instance head problem that given a need for a 'Functor' you can't backtrack to choose between the ContraFunctor and Functor instances
08:03:32 <EvilTerran> hence you'd need some slacker requirement for a general <|> operator
08:03:39 <Toxaris> > (+) 3 -- DuClare
08:03:40 <Cheiron>  <Integer -> Integer>
08:03:57 <EvilTerran> "left catch" instead of "left distribution"
08:04:05 <Toxaris> DuClare: here we use + as an unary function, and it returns: another unary function
08:04:21 <Toxaris> DuClare: what is the behaviour of (+) 3 when applied to some integer x?
08:04:55 <Toxaris> EvilTerran: the problem about Parsec is that it's <|> is a mess
08:05:08 <edwardk> With dual categories, you wind up with conflicts between automatically lifting bifunctors for a category to bifunctors on the dual category and bifunctors from say c^op * c -> c, like (->). they start to pop up all over the place
08:05:09 <Toxaris> EvilTerran: it's optimized.
08:05:22 <DuClare> Toxaris, Clearly it'll add 3 to it
08:05:33 <Toxaris> DuClare: yeah, obviously. so we have
08:05:38 <ski> edwardk : hm ..
08:05:39 <Toxaris> > ((+) 3) 4
08:05:40 <Cheiron>  7
08:05:46 <EvilTerran> Toxaris, i think it's still an idempotent monoid, though
08:06:03 <DuClare> So [(+) 3] is actually a "new" function which is then applied to 4
08:06:14 <Toxaris> DuClare: exactly
08:06:32 <Toxaris> and (+) 3 4 is just a shorter version of (((+) 3) 4)
08:06:51 <ski> > map ((+) 3) [4,10,42]
08:06:52 <Cheiron>  [7,13,45]
08:07:06 <ski> > [(+) 3 4,(+) 3 10,(+) 3 42]
08:07:07 <Cheiron>  [7,13,45]
08:07:23 <EvilTerran> > map ((+) 3) [x,y,z]
08:07:23 <Cheiron>  [3 + x,3 + y,3 + z]
08:07:27 <EvilTerran> > map (+ 3) [x,y,z]
08:07:28 <Cheiron>  [x + 3,y + 3,z + 3]
08:07:44 <edwardk> so at the moment the only way i've been able to use them is to define 'category transformers' rather than monads over arbitrary categories, because the general kleisli/cokleisli construction is problematic, because i need the newtype constructor to wrappable/unwrappable as a morphism in the category, but i can work with a kleisli'd version of the category and have the newtypes only have to live in Hask
08:07:46 <ski> > (+) x y
08:07:47 <Cheiron>  x + y
08:07:51 <edwardk> it just makes it really unwieldy =/
08:07:52 <ski> > (+ y) x
08:07:53 <Cheiron>  x + y
08:08:05 <ski> > (x +) y
08:08:06 <Cheiron>  x + y
08:08:24 <edwardk> so i don't get to share code between the different kleisli/cokleisli constructions which kinda sucks
08:08:51 <ski> *nod*
08:08:55 <DuClare> Toxaris, I think it's about time to get some food though :o
08:09:18 <Toxaris> DuClare: hehe similar here.
08:09:40 <Toxaris> DuClare: if you want to progress from this point at some other time, we are somewhere between Functor and Applicative
08:09:58 <Toxaris> DuClare: and the running example is a ZipList variant.
08:10:05 <DuClare> Toxaris, I'll try to remember.  We can go on whenever you have time etc. :)
08:10:11 <edwardk> ski: http://comonad.com/haskell/categories/src/Control/Category/Transformer/Reader.hs shows about the complexity of writing a generic reader comonad's cokleisli construction in an arbitrary category.
08:10:29 <Toxaris> DuClare: this should be enough to find someone here who can help you, or to read some papers, or just to ask me :)
08:10:39 <DuClare> Yup
08:10:42 <DuClare> I'll do my best
08:10:44 <DuClare> :)
08:10:50 <DuClare> Toxaris, Thanks a lot
08:10:50 <Toxaris> DuClare: have fun with Haskell!
08:10:53 <edwardk> (the reader comonad is a 'nicer' reader category transformer than the reader monad category transformer because the former only requires you to be precartesian while the latter requires a CCC.
08:11:21 <DuClare> Toxaris, From you I learnt a lot more than I've learnt from all the tutorials I've read :]
08:12:49 * EvilTerran blinks... from looking at the Applicative docs, apparently f <*> pure x = pure ($ x) <*> f
08:12:50 <EvilTerran>  -- that doesn't seem right
08:13:20 <EvilTerran> oh, wait, yeah, that does kinda make sense. never mind me. :P
08:13:26 * ski always associates the `reader' name with some kind of "parsing" (maybe also e.g. unique supply)
08:13:49 <edwardk> fair nuff, was just going for symmetry with the reader monad =)
08:14:03 <byorgey> EvilTerran: the idea is that 'pure x' shouldn't have any effects, so it can be commuted with f
08:14:10 <ski> (me preferring the `environment' naming, i.e. ..)
08:14:25 <ski> `(<*>)' shouldn't be a (syntactically) symmetric operation
08:15:10 <ski> pure f <*> x = fmap f x  -- yes ?
08:15:10 <byorgey> but in general  f <*> x  is not the same as (liftA ($) x) <*> f, since the order of the effects is switched
08:15:18 <byorgey> ski: yes
08:15:44 <Toxaris> edwardk: I hope you don't hope that I have any hope in following you
08:16:05 <edwardk> newtype ReaderC e k a b = ReaderC { runReaderC :: k (Prod k e a) b }  works better than newtype ReaderM e k a b = ReaderM { runReaderM :: k a (Exp k e b) } - because of the exponentials on the second case requiring that you have some notion of function
08:16:28 * ski nods sagely
08:16:39 <edwardk> class (Category c, Category d) => Functor f c d | f c -> d, f d -> c where map :: c a b -> d (f a) (f b)
08:16:45 <edwardk> thats the main idea Toxaris =)
08:17:12 <ski> strange
08:17:16 <edwardk> where c and d are 'Categories' represented by their type of morphisms instead of just implicitly (->)
08:18:06 <edwardk> technically it should have f -> c  d for fundeps, but this version lets me recycle functors if the functor is generic in its category in some way as long as i can typecheck bidirectionally
08:21:35 <Toxaris> edwardk: I think I'm somewhat catching up.
08:21:43 <edwardk> my current issue is that i run into ambiguous instance heads between instance Functor f k k => Functor f (Dual k) (Dual k) automatically transforming a functor into its categorical dual ... and real contravariant functors from a category i.e. Functor f (Dual k1) k2
08:22:51 <edwardk> pretty much everything in http://comonad.com/haskell/categories/dist/doc/html/categories/ plays nice together except the stuff in Control.Category.Dual which causes you to blow up with a ton of ambiguous instances when you try to add anything useful ;)
08:23:19 <Toxaris> so you tried to solve the Cofunctor-Functor-FunctorComposition problem by representing Cofunctors as Functors from the Dual category, but it didn't help
08:24:15 <edwardk> actually iirc that one works fine, its that i just can't have it and automatically take a functor f and generate a functor for the dual category
08:24:33 <edwardk> if i do, then it blows up =/
08:26:12 <edwardk> so if f : c -> c    i'd like to be able to generate f^op : c^op -> c^op. i tried generating a generic 'Dual' constructor to wrap the functor in but then i don't have a way to generically 'get that newtype' into an arbitrary category.  since i can't just all the newtype constructor - as it is a function.
08:26:33 <edwardk> so putting on the Category lenses lets me deal with categories and category transformers really nicely but the notion of a Functor is somewhat hosed =)
08:26:37 <byorgey> if I want to bind something at the ghci prompt, like 'foo <- someIOAction', but NOT print the value of foo, is there a way to do that?
08:27:20 <ski> iirc it used to do that before
08:27:23 <Toxaris> byorgey: there is some kind of ghc option
08:28:48 <Toxaris> byorgey: :set -fno-print-bind-result
08:30:00 <Toxaris> byorgey: or (x, y) <- fmap ((,) undefined) (real stuff)
08:30:19 <byorgey> aha! -fno-print-bind-result, that's it
08:30:23 <byorgey> thanks =)  Toxaris++
08:30:45 <byorgey> Toxaris: hehe, clever
08:35:31 <bos> @seen cosmicray
08:35:31 <Cheiron> I haven't seen cosmicray.
08:35:44 <dcoutts_> byorgey: re the scaled ellipse, I think you'd just have to draw the right shape from the start, eg using arc segments or cubic curves, otherwise go ask the cairo people specifically or look for some ps/pdf reference
08:35:48 <bos> > "foo"
08:35:49 <Cheiron>  "foo"
08:36:03 <bos> huh, a norwegian lambdabot.
08:36:33 <byorgey> dcoutts_: yeah, I think you're right
08:37:17 <byorgey> dcoutts_: I'm annoyed that there's no way to just draw a *line*, which always comes out 1px wide or whatever in the device coordinate system, no matter what.
08:37:28 <bos> i once had a bot, or should i say, she once had me...
08:37:40 <Japsu> boten anna, som ingen annan slår
08:37:42 <dcoutts_> byorgey: indeed, such a thing isn't device independent
08:37:42 <byorgey> all you can do is stroke paths with a circular brush.
08:38:03 <byorgey> yeah, I figured there must be technical limitations in the way.
08:38:57 <byorgey> dcoutts_: you can do such things in a vector graphics format, like svg or ps though, right?
08:39:28 <dcoutts_> byorgey: I don't know
08:39:36 <byorgey> dcoutts_: ok, fair enough =)
08:39:44 <byorgey> I've never really done all that much with this sort of thing before, so this diagram EDSL is definitely a learning experience =)
08:39:56 <dcoutts_> it doesn't make sense in a purely vector system
08:40:04 <byorgey> why not?
08:40:07 <dcoutts_> completely scalable I mean
08:40:20 <dcoutts_> everything has to have a size
08:41:27 <byorgey> hm, I was under the impression that in a vector graphics system you could e.g. define a square to be composed of four lines, and theoretically they are just infinitely thin, theoretical lines
08:41:46 <byorgey> so when it actually gets rendered, the scaling doesn't matter and they always come out as the thinnest physical lines possible
08:41:57 <allbery_b> the postscript model works tht way
08:42:00 <dcoutts_> but you don't really want that
08:42:12 <dcoutts_> a 600dpi printer can print pretty thin lines
08:42:14 <allbery_b> but you can also set brush sizes for when a path is rendered
08:42:25 <byorgey> dcoutts_: yeah, I guess you're right.
08:42:43 <byorgey> allbery_b: ok, good to know.
08:43:14 <nominolo_> dcoutts: is there any way to let Cabal use -O0/-Onot to build library?
08:43:43 <dcoutts_> nominolo_: cabal install foobar -O0
08:43:45 <byorgey> ok, I guess I'll just add ellipses as a primitive, and construct them out of bezier splines or something
08:43:52 <byorgey> which isn't really all that bad
08:43:52 <nominolo_> dcoutts_: would ghc-options="-Onot" work?
08:43:57 <allbery_b> actually it depends on what you tell it to do.  IIRC a path includes "brush size", but you can specify (may be default, I forget) a "zero size" brush which renders as the thinnest possible line on the device
08:43:59 <dcoutts_> nominolo_: that'd also work
08:44:18 <nominolo_> dcoutts_: oh, there it is
08:44:31 <dcoutts_> nominolo_: any luck with the configurations bug?
08:44:39 <nominolo_> soon
08:44:42 <byorgey> allbery_b: makes sense.
08:45:38 <dcoutts_> nominolo_: cool, I'll be around tomorrow evening if you want to talk about it
08:45:49 * byorgey goes back to stealing lists of color name-rgb pairs from the interwebs with tagsoup
08:46:12 <allbery_b> had you considered /usr/lib/X11/rgb.txt?
08:46:21 <nominolo_> dcoutts_: no, mommy, i'm old enough to deal with it myself ;P
08:46:27 <allbery_b> (or whereveryour x11 is installed)
08:46:32 <dcoutts_> nominolo_: heh :-)
08:46:46 * dcoutts_ disappears
08:47:36 <byorgey> allbery_b: !!
08:47:45 <byorgey> allbery_b++
08:47:52 <byorgey> didn't know about that one =)
08:48:42 * byorgey makes a mental note to mention everything semi-annoying he does, in the hopes that someone will know of a better way
08:54:29 <MyCatVerbs> Hrm. Is there a good way in either hugs or ghci to print a rough approximation to how long a particular thunk took to evaluate? Short of just using the timing IO libraries to hack something up by hand, I mean.
08:55:50 <allbery_b> :set +s
08:55:59 <MyCatVerbs> Thanks.
08:56:22 <allbery_b> hm, no, that' total
08:56:37 <allbery_b> individual thunks, hm, would require profiling
08:56:47 <allbery_b> but I don't think the bytecode stuff does profiling
08:57:46 <MyCatVerbs> Eh. I'm just generating a lazy list and timing how long it takes to (!!n) it for different values of n.
08:57:59 <MyCatVerbs> The thunk that I'm trying to time is the thunk that I'm typing in anyway. ^^
08:58:34 <bugQ> it should be linear, yes?
08:59:02 <MyCatVerbs> bugQ: only if each element is generated in amortized O(1).
08:59:16 <bugQ> ah
08:59:29 <bugQ> lazyness brainf*'s me
08:59:55 <MyCatVerbs> bugQ: for example, let fib n = if n < 2 then 1 else fib (n-1) + fib (n-2) in [ fib x | x <- [1..] ]
09:00:05 <bugQ> right right
09:00:26 <allbery_b> laziness is fuuuuun
09:00:37 <MyCatVerbs> Stupid question also, is it possible to make ghci throw away all the thunks it's already evaluated? :D
09:01:09 <allbery_b> possibly :set +r
09:02:40 <MyCatVerbs> Thanks again. Just found out the hard way that it's pretty useless trying to repeatedly measure the time taken by a lazy list generation when you've just gone and memoized the preceeding section of the list. ;)
09:03:30 <allbery_b> heh
09:04:02 <bugQ> MyCatVerbs: as opposed to fibs 2 = [1,1]; fibs n = sum $ take 2 $ fibs $ n-1
09:04:21 <MyCatVerbs> bugQ: precisely, jah.
09:06:13 <bugQ> nice nick, by the way.  we had once considered naming our cat after a verb or adverb, or just 'verb' or 'adverb'
09:10:28 <MyCatVerbs> Thanks. It came out of me always having set my nick to "MyCatSleeps" or "MyCatEats" or "MyCatCodes" or whatever.
09:11:00 <MyCatVerbs> Since I'm too lazy to actually keep my nick updated, though, I just parameterized it over all verbs instead to save typing. ;)
09:11:02 <allbery_b> "MyNounVerbs"
09:11:12 <bugQ> ya, nice
09:11:19 <byorgey> "PossessiveNounVerbs"
09:11:43 <MyCatVerbs> allbery_b: that is an excellent idea, except that I don't actually need to switch nouns. Only cats ever do anything worth reporting on anyway. ;)
09:11:49 <czakey> MyYawns
09:12:11 <czakey> MyCatYawnsToo
09:12:41 <MyCatVerbs> czakey: try hugging him/her.
09:12:56 <MyCatVerbs> czakey: won't alleviate the yawning, but it'll make the world a slightly nicer place anyway.
09:12:56 <bugQ> oh, my example for fibs doesn't even work, yay
09:13:22 <MyCatVerbs> bugQ: fibs = 1 : 1 : zipWith (+) fibs (tail fibs) -- ?
09:13:25 <czakey> uup
09:13:57 <bugQ> assuming that meant 'yup'
09:14:04 <czakey> yup
09:14:10 <MyCatVerbs> Either that or vomit.
09:14:15 <czakey> cat on a laptop
09:14:19 <bugQ> :)
09:14:22 <MyCatVerbs> czakey: d'awwwww.
09:14:24 <czakey> is nice random string generator
09:14:29 <czakey> ;)
09:14:31 <MyCatVerbs> No need to hold your head over a bowl, then.
09:14:37 -Jedai(n=Jedai@ALyon-252-1-11-38.w82-122.abo.wanadoo.fr)- AVATAR
09:14:53 <MyCatVerbs> Not much entropy per character, though. Lotta repetition. :)
09:15:19 <bugQ> yeah, it's just for seeding
09:15:44 <czakey> I was thinking about great random number generator for my ssl server
09:15:54 <MyCatVerbs> Bet you'd get better results if you included timing data too, and then dragged a toy mouse over a huge keyboard.
09:16:08 <czakey> a room with lot of keyboards on the flor
09:16:11 <czakey> some cats
09:16:19 <czakey> and possibly some mices
09:16:22 <czakey> ;p
09:16:44 <bugQ> not a bad idea!  I bet that's how the pentagon handles encryption nowadays
09:17:36 <czakey> I think that they are using monkeys
09:17:54 <czakey> like in the Babel Library
09:18:06 <MyCatVerbs> I hope they're using Geiger-Muller counters and lumps of uranium ore, but that's just me.
09:18:44 <czakey> http://en.wikipedia.org/wiki/The_Library_of_Babel
09:18:52 <bugQ> MyCatVerbs: that's what they'd want you to think, of course.
09:19:08 <czakey> yes
09:19:12 <czakey> uranium ore
09:19:24 <czakey> doesen't need to be huging
09:19:46 <czakey> after all they have someone to talk to
09:19:59 <czakey> 'p
09:20:01 <czakey> ;p
09:26:52 <LegendaryPenguin> does call by need always modify the values of variables passed in to the function?
09:26:57 <LegendaryPenguin> er call by name
09:27:59 <ski> call-by-name are usually described in terms of substitution, i think
09:28:55 <LegendaryPenguin> how is it implemented usually
09:29:34 <ski> it might be that Algol (68 ?) used thunks (not updating ones)
09:30:22 <LegendaryPenguin> like, is it just a direct substitution where the formal parameters are not even referred to in a function because they are replaced with the actual parameters
09:30:43 <LegendaryPenguin> and no copies are created for the formal parameters
09:30:58 <ski> that would be one implementation, i think
09:31:21 <ski> (whatever "substitution" means concretely, here)
09:31:59 <LegendaryPenguin> is it impossible to write a swap function with call by name
09:32:28 <ski> why would that be the case ?
09:32:56 <ski> \p. (snd p,fst p)
09:34:06 <nominolo_> @pl \x y -> MkFoo $ bar (unFoo x) (unFoo y)
09:34:06 <Cheiron> (MkFoo .) . (. unFoo) . bar . unFoo
09:34:13 <nominolo_> :t on
09:34:46 <ski> @type off
09:34:47 <Cheiron> Plugin `type' failed with: invalid ghci output: no type signature
09:36:43 <nominolo_> @pl \x y -> MkFoo $ (bar `on` unFoo) x y
09:36:43 <Cheiron> (MkFoo .) . (bar `on` unFoo)
09:40:07 <nominolo_> dcoutts_: it was a missing customised Monoid instance
09:42:11 <ttt--> @src flip
09:42:12 <Cheiron> flip f x y = f y x
09:47:52 <LegendaryPenguin> with call by need, the value does not have to be "stored" for subsequent uses, does it
09:48:38 <Philippa> yes, that's precisely how call-by-need differs from call-by-name
09:48:48 <LegendaryPenguin> but does it really need to be stored
09:48:54 <LegendaryPenguin> in terms of appending variables to the environment
09:49:08 <LegendaryPenguin> cant you run through the body of the function and change references to that name to the computed value
09:49:10 <Philippa> huh? Where did you get that from?
09:49:28 <ddarius> I'm not sure where LegendaryPenguin is getting any of this from.
09:49:30 <Philippa> there's a bit of a problem with that - how do you trace the "name"?
09:49:56 <Philippa> I mean yes, in principle you can do it - you don't need an environment as an implementation technique
09:50:00 <Philippa> it's just a really good idea
09:50:14 <LegendaryPenguin> yeah
09:50:22 <LegendaryPenguin> im just saying it's not really needed for the implementation
09:50:26 <Philippa> (and conceptually speaking, hunks go on a heap, not in an environment)
09:50:28 <Philippa> *thunks
09:50:49 <LegendaryPenguin> hmm
09:51:06 <Philippa> the "value" is effectively a reference onto that heap
09:51:19 <LegendaryPenguin> you lost me
09:52:03 <LegendaryPenguin> the environment would be somewhere on a heap wouldnt it
09:52:35 <Philippa> different notion of 'heap'. You might prefer 'store', in the ML sense
09:52:48 <Philippa> as in 'where all the mutable cells are'
10:04:16 <ttt--> how do i get the arity of a typerep
10:04:26 <ttt--> or of a function
10:05:07 <ttt--> > length typeOf (+ 1)
10:05:08 <Cheiron>  Couldn't match expected type `[a]'
10:06:02 <bugQ> :t typeOf
10:06:03 <Cheiron> forall a. (Typeable a) => a -> TypeRep
10:06:59 <TomMD> Cheiron?  What is this?
10:07:09 <TomMD> @where Cheiron
10:07:10 <Cheiron> I know nothing about cheiron.
10:07:16 <allbery_b> lb is as usual horked
10:07:36 <TomMD> @go Cheiron irc bot
10:07:38 <Cheiron> No Result Found.
10:08:38 <byorgey> ttt--: length . typeRepArgs . typeOf?
10:08:51 <byorgey> > length . typeRepArgs . typeOf $ (+1)
10:08:53 <Cheiron>  2
10:08:54 <TomMD> > length . typeRepArgs . typeOf $ (+)
10:08:54 <Cheiron>  2
10:09:08 <byorgey> > length . typeRepArgs . typeOf $ (liftM2)
10:09:09 <Cheiron>  Add a type signature
10:09:19 <TomMD> ?hoogle typeRepArgs
10:09:19 <Cheiron> A Hoogle error occured.
10:09:25 <TomMD> hoogle--
10:09:28 <bugQ> yay!
10:10:01 <ttt--> thanks
10:10:05 <byorgey> ttt--: well, I'm not exactly sure, but read http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html#t%3ATypeRep
10:10:19 <TomMD> hoogle++ Cheiron--  (got to punish the right offender)
10:10:22 <byorgey> I wonder why it said '2' for (+1)
10:10:30 <TomMD> So do I
10:10:34 <sclv> ?karma Cheiron
10:10:34 <Cheiron> Cheiron has a karma of 0
10:10:37 <TomMD> > typeRepArgs . typeOf $ (+)
10:10:38 <Cheiron>  [Integer,Integer -> Integer]
10:10:40 <sclv> ?karma hoogle
10:10:41 <Cheiron> hoogle has a karma of 0
10:10:45 <TomMD> > typeRepArgs . typeOf $ (+1)
10:10:46 <Cheiron>  [Integer,Integer]
10:10:52 <TomMD> there you have it
10:10:56 <byorgey> oh, I see
10:11:06 <byorgey> (+1) is  Integer -> Integer, so that's 2
10:11:09 <TomMD> > typeRepArgs . snd . typeOf $ (+1)
10:11:09 <Cheiron>  Couldn't match expected type `(a, TypeRep)'
10:11:15 <TomMD> > snd . typeRepArgs . typeOf $ (+1)
10:11:16 <Cheiron>  Couldn't match expected type `(a, b)'
10:11:17 <byorgey> (+) is Integer -> (Integer -> Integer) so that's also 2 =)
10:11:44 <TomMD> but are all functions two?
10:11:51 <byorgey> ttt--: if you actually want to know the number of arguments, you'll have to recurse through the type, deconstructing any function types
10:11:54 <TomMD> > typeRepArgs . typeOf $ foldl
10:11:55 <Cheiron>  Add a type signature
10:11:56 <byorgey> TomMD: I would assume so.
10:12:34 <byorgey> > typeRepArgs . typeOf $ (1,2,3) :: (Int,Int,Int)
10:12:35 <Cheiron>  Couldn't match expected type `(Int, Int, Int)'
10:12:39 <byorgey> > typeRepArgs . typeOf $ (1,2,3)
10:12:40 <Cheiron>  [Integer,Integer,Integer]
10:13:12 <byorgey> > typeRepTyCon . typeOf $ (+1)
10:13:12 <Cheiron>  ->
10:13:16 <TomMD> Who runs Cheiron?
10:14:08 <byorgey> ttt--: so as long as you get -> as the TyCon, add one to your running total, then look at the second element of the list returned by typeRepArgs
10:14:17 <byorgey> if it's a function too, recurse
10:14:54 <TomMD> "But recursion is slow!" -Anon
10:15:04 <byorgey> hehe
10:15:10 <Arnar> g'day folks
10:15:18 <TomMD> Hello Arnar.
10:15:19 <byorgey> hi Arnar
10:15:48 <Arnar> I'm getting a weird error when "cabal instal"-ling a package (Alex)
10:16:20 <Arnar> can't match Distribution.Verbosity.Verbosity against inferred "Distribution.Simple.Setup.Flag Distribution.Verbosity.Verbosity"
10:16:34 <Arnar> is that some kind of cabal version-mismatch?
10:17:50 <TomMD> I get the same problem (just tested) and I don't think any of my packages have a 'diamond dependency' issue.
10:18:52 <Arnar> hmm, ok
10:19:38 * Arnar tries getting Alex the normal way
10:19:44 <BMeph> Looks more like an older Cabal package version.
10:20:28 <Arnar> BMeph: that was what I was thinking.. but I'm using a development snapshot of cabal (needed for cabal-install)
10:20:31 <TomMD> I just noticed, I must not have updated my cabal since last re-install (many options I know of are missing)
10:21:05 <Arnar> cabal 1.3.3 <- is that old?
10:21:27 <Arnar> actually.. ghc-pkg list shows two Cabal pkgs, 1.2.3.0 and 1.3.3
10:22:10 <ttt--> > let testArity = length . typeRepArgs . typeOf
10:22:11 <Cheiron>  Parse error at end of input
10:22:45 <TomMD> Arnar: That shouldn't be too old, but I am pulling down cabal to run another test.
10:22:46 <ttt--> > let x = (+ 1)
10:22:47 <Cheiron>  Parse error at end of input
10:22:48 <Deewiant> > let testArity = length . typeRepArgs . typeOf in testArity (show)
10:22:49 <Cheiron>  2
10:22:57 <Arnar> TomMD: thanks for the trouble
10:23:00 <Deewiant> > let x = (+ 1) in x
10:23:03 <Cheiron>  <Integer -> Integer>
10:23:40 <Arnar> :let testArity = length . typeRepArgs . typeOf
10:24:00 <Deewiant> @let testArity = length . typeRepArgs . typeOf
10:24:01 <Cheiron> <local>:2:35:     Ambiguous type variable `a' in the constraint:       `Typea...
10:24:15 <Arnar> right.. I  always do that (: instead of @)
10:24:35 <Arnar> (@ is somewhat cumbersome to type on my kbd)
10:24:40 <sclv> @let testArity x = length . typeRepArg . typeOf $ x
10:24:41 <Cheiron> <local>:2:23: Not in scope: `typeRepArg'
10:24:49 <sclv> @let testArity x = length . typeRepArgs . typeOf $ x
10:24:50 <TomMD> The @ is never very good.  I prefer ?
10:24:50 <Cheiron> Defined.
10:25:03 <Deewiant> § would be most convenient on my keyboard ;-)
10:25:08 <sclv> > testArity (+)
10:25:10 <Cheiron>  2
10:25:10 <Arnar> ?type "this works?"
10:25:12 <Cheiron> [Char]
10:25:22 <Deewiant> > testArity [+]
10:25:22 <Cheiron>  Parse error at "+]" (column 12)
10:25:24 <TomMD> ?let someValue = 293
10:25:24 <Cheiron> Defined.
10:25:25 <Deewiant> > testArity [(+)]
10:25:27 <Cheiron>  1
10:25:28 <TomMD> > someValue
10:25:29 <Cheiron>  293
10:25:43 <TomMD> ?undefine someValue
10:25:44 <Cheiron> Undefined.
10:25:47 <sclv> > testArity (\x y z -> x + y+ z)
10:25:48 <Cheiron>   Not in scope: `testArity'
10:25:56 <sclv> @let testArity x = length . typeRepArgs . typeOf $ x
10:25:57 <Cheiron> <local>:1:14:     precedence parsing error         cannot mix `(.)' [infixr 9...
10:26:01 <TomMD> Oh... um... did I just wipe out everyones?  Sorry guys.
10:26:09 <sclv> @let testArity x = length . typeRepArgs . typeOf $ x
10:26:10 <Cheiron> <local>:1:14:     precedence parsing error         cannot mix `(.)' [infixr 9...
10:26:10 <Deewiant> I think you did :-)
10:26:18 <Arnar> lol
10:26:22 <TomMD> Yeah, I saw.  Sorry, as I said.
10:26:30 <sclv> and you borked something else royally too.
10:26:32 <Arnar> ?help undefine
10:26:33 <Cheiron> undefine. Reset evaluator local bindings
10:26:40 <TomMD> Cost billions in damage?
10:26:42 <Arnar> ?help unlet
10:26:43 <Cheiron> help <command>. Ask for help for <command>. Try 'list' for all commands
10:26:52 <Deewiant> @let foo x = (+1) . (*2) $ x
10:26:53 <Cheiron> <local>:1:8:     precedence parsing error         cannot mix `(.)' [infixr 9]...
10:26:55 <TomMD> ?help undefine
10:26:55 <Cheiron> undefine. Reset evaluator local bindings
10:27:21 <Deewiant> > (+1) . (*2) $ 2
10:27:22 <Cheiron>   Not in scope: `$'
10:27:28 <Deewiant> :-D
10:27:32 <Deewiant> jolly good show
10:27:37 <TomMD> You've got to be kidding me
10:27:43 <Deewiant> > 1+1
10:27:44 <TomMD> ?src ($)
10:27:45 <Cheiron> f $ x = f x
10:27:45 <Cheiron>  2
10:27:50 <Deewiant> > (+1) $ 1
10:27:51 <Cheiron>   Not in scope: `$'
10:28:00 <Arnar> hmm..
10:28:01 <Deewiant> > ((+1) . (+2)) 1
10:28:02 <Cheiron>  4
10:28:13 <Arnar> TomMD: put that memory-erasing stick away.. :)
10:28:16 <TomMD> $ should not be a local binding.
10:28:25 <Arnar> :t ($)
10:28:26 <Cheiron> forall a b. (a -> b) -> a -> b
10:28:32 <Deewiant> @. let src ($)
10:28:33 <Cheiron> Defined.
10:28:37 <Deewiant> > (+1) $ 1
10:28:38 <Cheiron>   Not in scope: `$'
10:28:51 <Arnar> > ($)
10:28:51 <Cheiron>   Not in scope: `$'
10:29:04 <Deewiant> @let ($) f x = f x
10:29:05 <Cheiron> Defined.
10:29:09 <byorgey> I wonder if it's a local binding because Cale made it left-associative ?
10:29:09 <Deewiant> > ($)
10:29:11 <Cheiron>  Add a type signature
10:29:15 <Deewiant> > (+1) $ 1
10:29:16 <Cheiron>  2
10:29:30 <Cale> byorgey: I didn't locally bind ($), as far as I know.
10:29:34 <TomMD> But some things probably won't work, I am guessing.
10:29:36 <byorgey> ok
10:29:37 <Deewiant> byorgey: but this is Cheiron, not lambdabot, so it's not running Caleskell.
10:29:42 <Arnar> Cale: undefine seems to nuke it
10:29:47 <Deewiant> or?
10:29:49 <TomMD> > (+1) . (+2) . (*3) $ 6
10:29:49 <Cheiron>      precedence parsing error
10:29:50 <Cheiron>         cannot mix `(.)' [infixr 9] and `($)' [...
10:29:54 <Cale> Okay, must have been someone else then :)
10:29:55 <byorgey> Deewiant: right, well, I didn't know how recent Cheiron's code was
10:30:05 <Cale> @undefine
10:30:06 <Cheiron> Undefined.
10:30:08 <Deewiant> now that ($) has been manually defined it'll have the default precedence
10:30:11 <Cale> > (+1) . (+2) . (*3) $ 6
10:30:13 <Cheiron>   Not in scope: `$'
10:30:16 <Cale> ...
10:30:19 <bugQ> heh.
10:30:26 <Deewiant> Cale: lambdabot's dead, by the way.
10:30:31 <Cale> oh, right
10:30:35 <Cale> heh
10:30:40 <Cale> I didn't even notice :)
10:30:44 <Deewiant> :-)
10:30:48 <byorgey> haha =)
10:30:58 <Cale> oh look, code.haskell.org is completely down
10:31:05 <byorgey> yup =(
10:31:10 <TomMD> Who runs code.haskell.org?  Galois?
10:31:11 <Cale> sigh
10:31:14 <Cale> I don't know
10:31:15 <byorgey> it's been down for a while now I think
10:31:47 <byorgey> TomMD: ISTR it's run by Galois, but located in... Texas?  or I could be completely making that up...
10:32:25 <TomMD> Aren't the happs people down near that part of the US?
10:32:32 <Saul__> A quick question: If I have the same expression in a function body twice, does it only get calculated once?
10:32:46 <ddarius> No
10:32:47 <dzlk> It was down about two hours ago when I tried a darcs get.
10:32:48 <byorgey> Saul__: no, it's probably calculated twice.
10:33:01 <Saul__> :(
10:33:09 <TomMD> Saul__: If you place it in a let or where expression it will be once for most compilers (I believe).
10:33:18 <ddarius> Saul__: This is preferable.
10:34:08 <byorgey> why would you want to type out the same expression twice anyway?  give it a name, save your fingers. =)
10:34:30 <TomMD> To avoid the evil that is 'let floating' of coarse.
10:34:37 <Deewiant> because typing g (f x) (f x) is shorter than let foo = f x in g foo foo ;-)
10:34:45 <johnnowak> ?type succ . const . const
10:34:46 <Cheiron> Plugin `type' failed with: invalid ghci output: no type signature
10:34:54 <Deewiant> and easier than having to think about obscure stuff like 'join' ;-)
10:34:59 <johnnowak> ?type const
10:35:00 <Cheiron> Plugin `type' failed with: invalid ghci output: no type signature
10:35:06 * johnnowak kicks Cheiron 
10:35:17 <byorgey> Deewiant: it's not asymptotically shorter, though ;)
10:35:25 <sclv> let x = foo . bar . baz $ z in g x x
10:35:29 <Deewiant> >_<
10:35:41 <Saul__> http://hpaste.org/7187 So (b - a) is calculated three times?
10:35:51 <johnnowak> > fold (\x y -> 1) 0
10:35:52 <Cheiron>   Not in scope: `fold'
10:35:59 <johnnowak> > foldl (\x y -> 1) 0
10:36:00 <Cheiron>  Add a type signature
10:36:09 <byorgey> Saul__: it's compiler-dependent, but most likely yes.
10:36:12 <johnnowak> pfft.
10:36:23 <Saul__> byorgey: Ok thanks
10:36:32 <Saul__> I guess I'll rewrite it then
10:36:51 <byorgey> Saul__: there's a good reason for it, which is that common subexpression elimination can in some cases be a pessimization
10:37:03 <byorgey> it can cause drastic increases in memory usage in some cases, for example.
10:37:20 <Saul__> ok
10:37:26 <Saul__> good to know
10:37:43 <bugQ> :t foldl (\x y -> 1) 0
10:37:53 <bugQ> ...
10:37:55 <TomMD> cabal-install must not be a darcs2 repo, I am thinking.
10:38:09 <bugQ> > foldl (\x y -> 1) 0 [1..10]
10:38:10 <Cheiron>  1
10:38:12 <ddarius> Why would it be?
10:38:31 <TomMD> My get is going extremely slow - that is all.
10:38:36 <johnnowak> > foldl (succ . const . const) 0 [1..10]
10:38:37 <Cheiron>      Occurs check: cannot construct the infinite type: a = b -> a
10:38:37 <Cheiron>     Probabl...
10:38:42 * Arnar misses lambdabot.. *sniff*
10:38:56 <TomMD> lambdabot++ -- you don't know what you got till its gone.
10:40:26 <bugQ> > foldl (succ . const) 0 [1..10]
10:40:27 <Cheiron>   add an instance declaration for (Enum (b -> a))
10:44:52 <johnnowak> length = 0 [drop succ] fold
10:45:10 <ddarius> Take your joy out of here.
10:45:18 <bugQ> what language?
10:45:31 <johnnowak> bugQ: joy
10:45:41 <bugQ> oh, should have guessed.
10:46:26 <johnnowak> length = [pop 1] map sum
10:46:29 * johnnowak wanders off
10:48:53 <Arnar> TomMD: the Alex Setup.lhs seems to be for some other version of Cabal than I'm running
10:49:06 <Arnar> got it installed by removing some stuff (hard-coding verbosity setting)
10:49:18 <Arnar> but got some deprecated warnings from Cabal
10:50:20 <Arnar> just fyi
10:51:54 <TomMD> Arnar: Great, thanks.  My darcs get just finished :-|
10:56:41 <noohgodno> s/darcs/orgy
10:57:03 <noohgodno> where am i
11:05:53 <TomMD> What is this, some sort of bot or troll + script?  First a lewd comment then two name changes.  Several hours and a dozen names later will we see just one more comment and continue the cycle?
11:05:55 <DRMacIver> Why is Data.ByteString.Unsafe.unsafePackMallocCString O(n)?
11:06:22 <DRMacIver> It seems like it should be O(1) unless I'm misunderstanding its behaviour
11:07:08 <DRMacIver> Oh, because it needs to calculate the length
11:07:57 <TomMD> That sounds like a bad reason.  You are saying it traverses looking for a NULL?  How does it recognize the end?
11:08:11 <byorgey> sam1336: are you a person or a robot?
11:08:34 <opqdonut> turing test over irc
11:08:38 <DRMacIver> TomMD: Yes, it traverses looking for a null.
11:08:40 <byorgey> yup =)
11:08:54 <byorgey> seems to be failing so far
11:09:07 <byorgey> sam1336: tell me about one of your favorite poems.
11:09:44 <opqdonut> :D
11:11:49 <TomMD> byorgey: Unless he responsed "Jabberwolky", I vote kick/ban/nab/kcik - in that order.
11:12:04 <opqdonut> :D
11:12:13 <byorgey> hehe
11:12:43 <byorgey> well, if someone feels like kicking, go ahead
11:12:55 <byorgey> not like he/she/it is really being a nuisance though
11:13:16 <TomMD> I'm just overly aggressive - its all this C I've been looking at lately.
11:13:34 <TomMD> Too strict.  I must become lazy again.
11:13:35 <byorgey> haha, C tends to do that to you...
11:15:04 <OceanSpray> what's an infinite type?
11:15:34 <bugQ> byorgey: ya, I've noticed that with the guys in #bzflag
11:15:47 <bugQ> OceanSpray: an impossible one
11:15:55 <Cale> OceanSpray: Kind of what it sounds like... think about the type of (\x -> x x), if it had one
11:16:18 <bugQ> or, one that is not sufficiently well-defined
11:16:22 <Cale> It's certainly got to be a function, so its type is a -> b for some types a and b
11:16:24 <OceanSpray> wait, why can't you do (\x -> x x) ?
11:16:34 <byorgey> or the type of  f (x:xs) = f x
11:16:34 <OceanSpray> just because the type wouldn't make sense?
11:16:35 <Beelsebob> it's (a -> a) -> a -> a
11:16:38 <johnnowak> OceanSpray: something like this: (List a) = (+ Null (* a (List a)))
11:17:12 <byorgey> johnnowak: that's not an infinite type, just a recursive one.
11:17:13 <Cale> But the parameter type a must itself be a function which takes a parameter of type a
11:17:21 <EvilTerran> OceanSpray, it's because typeOf x = typeOf x -> a
11:17:25 <bugQ> yay, #haskell explodes over a question over a compiler message!
11:17:38 <bugQ> and I thought we were all supposed to be more laid back
11:17:40 <Beelsebob> Cale: you might have been thinking of let x = (\x -> x x) in x x -- to make it need rank 2 polymorphism?
11:17:41 <Cale> (and produces a value of type b)
11:17:43 <Beelsebob> unless I'm missing the point?
11:17:46 <Zao> bugQ: For great explosions, try asking about unsafe IO :)
11:17:48 <EvilTerran> = (typeOf x -> a) -> a = ...
11:17:51 <liyang> s/laid back/lazy/
11:17:54 <Cale> :t (\x -> x x)
11:17:58 <Cale> ...
11:18:02 <Beelsebob> fair enough
11:18:04 <Beelsebob> I am missing the point
11:18:05 <EvilTerran> ?type \x -> x x
11:18:06 <Cheiron> Plugin `type' failed with: invalid ghci output: no type signature
11:18:10 <EvilTerran> buu
11:18:30 * bugQ feasts eyes on the pretty mushroom cloud.
11:18:30 <EvilTerran> ghci> :t \x -> x x
11:18:30 <EvilTerran>     Occurs check: cannot construct the infinite type: t = t -> t1
11:18:31 <Cale> So it would seem that if it had a type, that type would be the solution to the equation  a = a -> b
11:18:45 <EvilTerran> ... which is exactly what that type error says
11:19:13 <EvilTerran> and you aren't allowed such infinite types because the finiteness is what keeps the typechecking sound
11:19:14 <Cale> Which, as a least fixed point, looks something like  (((... -> b) -> b) -> b) -> b
11:19:44 <Cale> Well, infinite types *usually* indicate errors.
11:20:13 <Cale> There are some cases where you might conceivably want something with an infinite type, but in order to get that, you can usually just define a newtype
11:20:14 <EvilTerran> Cale, isn't it baked into the definition of "type system" that types must be finite?
11:20:22 <Cale> No, not at all.
11:20:23 <opqdonut> no, not really
11:20:34 * sam1336 does a handstand on the balcony
11:20:35 <Cale> You can even write a typechecker which infers infinite types.
11:20:39 <sam1336> no, it's ok, i do this all the time!
11:20:47 * sam1336 falls 6 stories to his death
11:20:48 <Cale> sam1336: Do you ever talk about Haskell?
11:20:57 <sam1336> i don't actually know haskell
11:21:01 <bugQ> shoo!
11:21:04 <EvilTerran> sure, things not expressible finitely in one type system (eg, simply typed \calc) can be expressible finitely in another (eg, haskell, using a newtype)
11:21:04 <Cale> sam1336: This channel is about Haskell.
11:21:10 <EvilTerran> sam1336, do you intend to learn haskell?
11:21:11 <sam1336> as the name would suggest
11:21:13 <byorgey> sam1336: would you like to learn Haskell?  it's really cool =)
11:21:15 <sam1336> and yes, i do
11:21:42 <johnnowak> OceanSpray: cat infers (or did infer) infinite types. so does ocaml.
11:21:43 <EvilTerran> sam1336, well, if you don't want to talk about haskell, but still want to bask in our intellectual glory, we have #haskell-blah for offtopic
11:22:10 <johnnowak> byorgey: i was getting to the infinite types. :)
11:22:17 <EvilTerran> but please keep it haskell- (not parkour-) related in here :)
11:22:25 <byorgey> johnnowak: oh. =)
11:22:55 * bugQ peeks into #parkour...
11:22:57 <OceanSpray> hmm.
11:22:58 <bugQ> aw, empty.
11:27:20 <ketil> EspenG, god aften.
11:27:29 <TomMD> When testing code, I often have properties (prop_a, prop_b, prop_c) which are not the same type.  I find it frustrating that I can't simply create [prop_A..propC] and run (mapM quickCheck propList).  Has anyone worked this out in a clean manner?
11:27:53 <ketil> TomMD, existentials?
11:28:04 <ketil> I can dig up an example if you like.
11:28:14 <ketil> (Think I ripped it from Bytestring)
11:28:40 <TomMD> For some reason I thought i had an issue using existentials for this... I'm going ot make a test case right now, see if I hit a snag.
11:30:40 <ketil> TomMD: I have data Test = forall t . Testable t => T String t
11:31:19 <EvilTerran> if you prefer GADT syntax, that's data Test where T :: Testable t => String -> t -> Test
11:31:40 * ketil must read up on GADTs one day.
11:33:22 <DRMacIver> My impression is that the right way of thinking about GADTs is that they're just a step in the direction of data constructors becoming types in their own right.
11:33:36 <DRMacIver> But this might be coloured by my only having used approximations to them. :)
11:33:56 <TomMD> ketil: Yeah, ok.  Thanks!
11:33:56 <johnnowak> i think after you understand how they actually work, only then do you see where you'd really want to use them
11:34:09 <DRMacIver> (Ok, I might have used actual GADTs at some point, but if so only as a toy)
11:34:27 <pjd_> "constructors with customized type signatures"?
11:34:28 <TomMD> ketil: that is to say, I've tried it and this fits in well :-)
11:35:17 * EvilTerran prefers GADT syntax to explicit forall.s in the cases where they both work
11:36:06 <desegnis> yeah, GADT syntax makes it more intuitive where the forall belongs
11:36:31 <desegnis> namely, the constructor wraps any t
11:36:33 <ndm_web> @seen nibro
11:36:33 <Cheiron> I haven't seen nibro.
11:37:04 <ndm_web> anyone any haskell-source-extensions exerience?
11:37:25 <DRMacIver> Hm. (Yet another) FFI question. For various reasons I have a C function which is accepting a pointer argument to use as an out parameter. I can't actually figure out how I should get a Ptr to use for this.
11:37:27 <ndm_web> i'm trying to find the latest version - the darcs has 0.2.1 but hackage has 0.3.3
11:38:35 <DRMacIver> Except possibly by using unsafeForeignPtrToPtr
11:39:27 <EvilTerran> DRMacIver, Foreign.Marshal.Alloc.malloc?
11:40:00 <adekoba> I have a little program that uses hscurses, and it works when using it with `runhaskell`. But when I try to `ghc --make` the file, ghc spits out all kinds of linker errors and it fails. Does anyone know why this is happening?
11:41:36 <DRMacIver> EvilTerran: Ah ha. Thanks.
11:41:43 <EvilTerran> np :)
11:50:03 <DRMacIver> Hm. What is "in" used for? It seems to be a keyword, but I'm blanking on what for.
11:50:12 <DRMacIver> (I'm sure it's obvious)
11:50:29 <adekoba> let/in
11:50:35 <DRMacIver> Oh, of course
11:54:02 <jaredj> > parseTest (endBy1 anyChar (char '\n')) "12345\n"
11:54:03 <Cheiron>   Not in scope: `anyChar'
11:54:26 <jaredj> well.
11:55:55 <Deewiant> > parseTest (endBy1 (satisfy (const True)) (char '\n')) "12345\n"
11:55:56 <Cheiron>   Not in scope: `satisfy'
11:56:21 <jaredj> Parsec unavailable?
11:57:08 <Deewiant> > endBy1
11:57:09 <Cheiron>   Not in scope: `endBy1'
11:57:19 <Deewiant> evidently
12:22:21 <EvilTerran> jaredj, isn't satisfy (const True) = any or anyChar or something like that?
12:22:54 <EvilTerran> anyToken
12:23:16 <EvilTerran> (or, apparently, anyChar)
12:23:45 <DRMacIver> *mutter*
12:23:51 <DRMacIver> I hate unary -
12:24:29 <DRMacIver> Just spent a good ten minutes debugging a bizarre type error that turned out to be because f 0 -1 parses as f (0 - 1), not f 0 (-1) as I expected
12:24:56 <newsham> not (f 0) - 1   ?
12:25:13 <DRMacIver> Hm. I don't think so. I could be wrong.
12:25:45 <EvilTerran> i'm pretty sure newsham's right
12:25:50 <DRMacIver> newsham is right
12:26:06 <DRMacIver> And is in fact obviously right. My version was stupid. :)
12:26:10 <newsham> > abs 0 - 2
12:26:12 <Cheiron>  -2
12:26:44 <DRMacIver> But anyway, the point of "boo for unary minus" remains. :)
12:26:48 <Toxaris> a good compiler should contain some heuristics to suggest a fix in such situations
12:26:58 <Bonus> how did they make Text.Printf.printf take a variable number of arguments
12:26:59 <Bonus> :[
12:27:18 <Toxaris> e.g., type error => try to restructure expression tree => if type error is solved, suggest to user
12:27:31 <newsham> > f 0 (negate 2)
12:27:32 <Cheiron>  Add a type signature
12:27:32 <paolino> :t Text.Printf.printf
12:27:34 <Cheiron> forall r. (PrintfType r) => String -> r
12:27:49 <DRMacIver> Bonus: Type classy magic
12:27:56 <Bonus> hmmm
12:28:04 <Bonus> oh i see
12:28:18 <Bonus> printf "some string" returns like sort of a printf function?
12:28:22 <Bonus> that takes a string
12:28:22 <Bonus> etc
12:28:28 <Toxaris> Bonus: there are many function in Haskell which take a variable number of arguments
12:28:32 <Toxaris> Bonus: like id
12:28:38 <DRMacIver> It returns either a printf function or an IO ()
12:28:46 <DRMacIver> (Or anything else satisfying that type class)
12:28:48 <Toxaris> :t id (++)
12:28:48 <Bonus> aha i see
12:37:34 <desegnis> actually, a disfunct bot isn't such a bad thing. it makes you reason about the code yourself
12:39:25 <paolino> does anyone code without ghci ?
12:41:17 <paolino> desegnis: ghci is a bot ?
12:41:24 <Zao> paolino: Mostly.
12:41:38 <Zao> I just use ghci for quick tests.
12:42:21 <desegnis> paolino, er, it isn't?
12:43:19 <Zao> ghci is just a REPL.
12:43:43 <paolino> desegnis : I couldn't code without a working bot
12:44:21 <desegnis> still lambdabot interaction does sometimes clutter up #haskell a little too much
12:44:28 <paolino> at least every 30 lines I'm tempted to debug with it
12:44:38 <paolino> ah ok
12:45:51 <paolino> #haskell-bot can be a solution?
12:46:15 <Lemmih> Lambdabot responds to private messages.
12:46:51 <desegnis> paolino, that would be probably too much a separation if the bot interaction is tied to the discussion
12:51:42 <ddarius> lambdabot has been here a lot longer than many of the people currenly here.
12:51:54 <paolino> :)
12:54:17 <DRMacIver> Is it just me who finds the fact that there are about 6 different datatypes called "ByteString" defined in the same library?
12:54:34 <DRMacIver> err. who finds that fact annoying
12:54:46 <DRMacIver> (Particularly that they all appear as "ByteString" in the haddock)
12:54:51 <Lemmih> DRMacIver: What library is that?
12:54:56 <DRMacIver> Well, ByteString. :)
12:55:05 <Lemmih> DRMacIver: It only has two.
12:55:08 <mauke> DRMacIver: I've only seen 2
12:55:08 <EvilTerran> that they don't appear qualified in the haddock is a bit annoying
12:55:22 <EvilTerran> but it does make it possible to use one module as a drop-in replacement for another
12:55:33 <EvilTerran> does BS.Char8 use the same type as BS?
12:55:36 <mauke> yes
12:56:06 <DRMacIver> ok. So some of them are actually the same. But there's nothing to indicate this fact in the documentation.
12:56:35 <mauke> right :/
12:56:57 <DRMacIver> And if that's the case, why am I getting "No instance for Data.String.IsString Data.ByteString.Internal.ByteString"?
12:57:05 <DRMacIver> When Data.ByteString does define such an instance
12:57:26 <mauke> probably because you didn't import the module containing the instance
12:57:35 <mauke> but I haven't used IsString yet
12:57:51 <DRMacIver> Oh, hm. I did, but of course ghci doesn't import everything imported by the file.
12:58:05 <jaredj> i'm making a permute parser with Parsec but all my keywords start with '<'. how do i left factor it?
12:58:10 <paolino> does that happen for haddock renders the exports ?
12:58:17 <DRMacIver> No, adding Data.ByteString has the same issue.
12:58:20 <bugQ> is [Char] treated specially at all in terms of implementation?
12:58:28 <DRMacIver> bugQ: Nope.
12:58:43 <jaredj> mmm mocha licorice
12:59:21 <jaredj> er, xmonad!
13:02:15 <bugQ> jaredj won't get away with that one again...
13:02:23 <adekoba> has anyone had any luck with hscurses?
13:02:52 <adekoba> i cannot seem to get anything to compile using it
13:05:18 <DRMacIver> http://hpaste.org/7188
13:05:21 <DRMacIver> This should work shouldn't it?
13:06:03 <adekoba> ah. nevermind. had to add "-lcurses" of course
13:07:40 <jaredj> crap. uh, GADTs
13:07:49 <bugQ> DRMacIver: "foo" is [Char], not ByteString
13:08:04 * bugQ pokes jaredj with a lit match.
13:08:21 <DRMacIver> bugQ: No it's not. It's (Data.String.IsString t) => t. That's what OverloadedStrings does.
13:08:32 <jaredj> HaPpS!
13:08:37 <bugQ> ah
13:09:05 <paolino> is there a way to let a function fmap on a newtype to avoid things like  A . f x . unA ?
13:09:26 <opqdonut> newtype instance inheriting is an extension
13:09:27 <opqdonut> iirc
13:09:48 <DRMacIver> That's not really newtype deriving.
13:10:46 <paolino> right I'm not deriving Functor there
13:11:03 <opqdonut> hmm, true
13:11:05 <Toxaris> paolino: you can make f a member of a typeclass, and derive instance transformers for this class for the newtype using newtype deriving with ghc
13:11:12 <mauke> DRMacIver: the instance is in .Char8
13:11:29 <mauke> which makes sense to me
13:11:44 <DRMacIver> Hm
13:11:53 <DRMacIver> That makes sense. It's profoundly unobvious from the documentation though.
13:12:04 <DRMacIver> In particular it shows up in the Instances list for the Data.ByteString module
13:12:04 <mauke> yes
13:12:09 <DRMacIver> Ok. Thanks.
13:12:15 <mauke> because that's where the type itself is defined
13:12:19 <mauke> I blame haddock
13:12:24 <DRMacIver> Right. That works. Thanks.
13:12:39 <mauke> (I had similar problems with Data.Time)
13:13:06 <paolino> Toxaris, I can't get that
13:13:16 <Toxaris> paolino: let me make an example
13:17:39 <Toxaris> paolino: http://hpaste.org/7189
13:18:04 <desegnis> you'd have to do it manually, I guess: withA f = A . f . unA
13:19:45 <Toxaris> paolino: but my idea only works when you want f to always be lifted into the newtype
13:21:08 <paolino> any newtype ?
13:21:33 <paolino> deriving that
13:22:52 <mauke> Cheiron: @join #xmonad
13:23:14 <Toxaris> paolino: yes
13:23:21 * paolino learned something
13:23:46 <Toxaris> paolino: you decide on a PerFunctionBase (you put the function into the class or not) and on a perNewtypeBase (you derive the class or not), but not on a per usagesite base
13:24:59 <paolino> and X is a hint ?
13:25:44 <Toxaris> paolino: "a hint"? X is just some datatype which lies at the bottom of the "newtype stack"
13:26:19 <paolino> is how to derive for New ?
13:27:42 <paolino> I mean without X , New couldn't derive ClassContainingOnlyF =
13:28:35 <Toxaris> paolino: newtype deriving is done locally, just by looking at the newtype and the class to derive
13:30:03 <Toxaris> in this case, I hope that something like this is derived:
13:30:03 <Toxaris> instance ClassContainingOnlyF x => ClassContainingOnlyF (New x) where f x (New y) = New (f x y)
13:30:23 <Toxaris> but I don't know whether newtype deriving can handle the Int argument to f
13:30:54 <paolino> uhm, looks like New behaves like X in respect to f
13:31:17 <Toxaris> paolino: New X   behaves like   X
13:31:32 <paolino> ahh
13:31:36 <Toxaris> paolino: but New Y for some Y with instance ClassContainingOnlyF Y would behave like Y
13:32:04 <Toxaris> paoline: and New (New (New (New ()))) would not support f at all, because () doesnt
13:32:36 <Toxaris> but the same idea should be applicable for newtypes without type arguments
13:32:53 <Toxaris> e.g. newtype NewX = New X deriving ClassContainingOnlyF
13:33:57 <Toxaris> maybe you could even write class Newtype n x => new :: x -> n; old :: n -> x
13:34:24 <Toxaris> and lift f = new . f . old :: Newtype n x => (x -> x) -> (n -> n)
13:34:36 <mauke> .oO( class Iso )
13:35:07 <Toxaris> mauke: better name or existing class?
13:35:33 <mauke> I don't know whether it exists
13:36:11 <mauke> you don't really need old and new; just make two instances
13:37:21 <Toxaris> so it's lift = (iso .) . (. iso)
13:37:46 <Toxaris> it's even cooler. it's iso = (iso .) . (. iso)
13:38:03 <opqdonut> heh
13:39:00 <Toxaris> instance (Iso x x', Iso y y') => Iso (x -> y, x' -> y') where iso = (iso .) . (. iso)
13:39:21 <Toxaris> ehm, "Iso (x -> y) (x' -> y')" of course
13:39:25 <Toxaris> or something similar
13:57:10 <Toxaris> mauke, paolino: http://hpaste.org/7190
13:57:17 <Toxaris> mauke: thanks for the great idea!
14:03:10 <ddarius> And instead of isomorphism you can extend to embed and project pairs
14:07:09 <Toxaris> ddarius: but these aren't necessarily unique, are they?
14:07:40 <Toxaris> ddarius: so instances may be a bad mechanism to handle them
14:10:02 <ddarius> isomorphisms aren't necessarily unique either
14:10:50 <opqdonut> but as they're isomorphisms it doesn't really matter which one you choose :P
14:10:51 <ddarius> Toxaris: swapping the components is also an isomorphism in the particular example you have on hpaste
14:11:05 <ddarius> opqdonut: Sure it does.
14:11:09 <opqdonut> (from an abstract point of view)
14:11:12 <opqdonut> yeah it does :P
14:11:34 <opqdonut> different logarithms is a good example
14:11:37 <Toxaris> ddarius: I see
14:11:51 <opqdonut> (Isomorphisms (R,*)->(R,+))
14:13:20 <ddarius> > log (-30)
14:13:22 <Cheiron>  NaN
14:13:39 <Cale> > log (-30) :: Complex Double
14:13:40 <Cheiron>  3.4011973816621555 :+ (-3.141592653589793)
14:14:14 <ddarius> Moral of the story, R isn't R+ nor is it C
14:14:37 <nominolo> > (3.4011973816621555 :+ (-3.141592653589793) :: Complex Double) ** (-30)
14:14:38 <Cheiron>  (-9.999624597235098e-21) :+ (-4.0065148921529755e-21)
14:15:01 <saml> @where Complex
14:15:02 <Cheiron> I know nothing about complex.
14:15:12 <newsham> why the weird bot name?
14:15:23 <nominolo> lambdabot is asleep
14:15:23 <Cale> Because the server which lambdabot runs on is down.
14:15:58 <ddarius> IRC As Distributed Fault Tolerance
14:16:13 <newsham> s/tolerance//
14:16:32 <Toxaris> I guess a problem with class Iso (and friends) is that instance Iso a a where iso = id doesn't work
14:21:40 * Baughn wonders if anyone has noticed that I switched the associativity of $
14:22:09 <saml> > 1 + $ 2 + $ 3
14:22:10 <Cheiron>  Parse error at "$" (column 5)
14:22:52 <saml> > (+) 1 $ div 3 $ read "3"
14:22:53 <Cheiron>   Not in scope: `$'
14:23:01 <Baughn> > ((+) . (*)) 42 $ 1+13 $ 9+2
14:23:01 <mauke> > id $ ()
14:23:02 <Cheiron>   Not in scope: `$'
14:23:02 <Cheiron>   Not in scope: `$'
14:23:07 * Baughn blinks
14:23:11 <Baughn> Er..
14:23:27 <Cale> Don't ask me :)
14:23:31 <saml> > (+) 1 $! div 3 $! read "3"
14:23:33 <Cheiron>  2
14:24:17 <Cale> Baughn: Did you perhaps define the new ($) in L.hs and not Pristine.hs ?
14:24:27 <Baughn> Cale: Yes..
14:24:31 <Baughn> It worked, I swear
14:24:32 <Cale> Baughn: L.hs gets trashed by @undef
14:24:35 <Baughn> Ah.
14:25:11 <Cale> I like how you're even more aggressively making changes to the Prelude. :)
14:25:20 <Baughn> > ((+) . (*)) 42 $ 1+13 $ 9+2
14:25:21 <Cheiron>   add an instance declaration for (Num (a -> a))
14:25:42 <Baughn> > ((+) . (*)) 42 $ 1+13 $ 9+2 $ 43
14:25:44 <Cheiron>        add an instance declaration for
14:25:44 <Cheiron>       (Num (t -> t1), Num ((t -> t1) -...
14:25:49 <MyCatVerbs> Cheiron: ...what!? You want Church numerals based on endofunctors or something?
14:25:53 <Cale> :t (+) . (*)
14:25:55 <Baughn> Yes. That was unsurpris.. oh, of course
14:26:11 <MyCatVerbs> Oh wait, I misparsed that conversation.
14:26:23 <MyCatVerbs> I thought you were daring Cale to add crazy instances to the Prelude.
14:27:14 <Baughn> @type (+) . (*)
14:27:15 <Cheiron> Plugin `type' failed with: invalid ghci output: no type signature
14:27:25 <Baughn> That is incredibly unhelpful. >_<
14:27:27 <Baughn> @type (+)
14:27:28 <Cheiron> Plugin `type' failed with: invalid ghci output: no type signature
14:27:36 <Cale> (+) . (*) :: forall a. (Num a, Num (a -> a)) => a -> (a -> a) -> a -> a
14:27:48 <Baughn> Cale: Yeah, I figured out how I got that wrong.
14:27:54 <Baughn> But.. any idea what's up with @type?
14:28:02 <Cale> I don't know...
14:28:03 <TomMD> @let negateS "off" = "on"
14:28:04 <Cheiron> Defined.
14:28:15 <Baughn> > negateS "on"
14:28:17 <Cheiron>  "Exception: <local>:2:0-19: Non-exhaustive patterns in function negateS
14:28:22 <mux> there I am wishing for partitionM
14:28:28 <Cale> > ((+) .) . (*) $ 3 + 4 $ 9 + 2 $ 43
14:28:29 <Cheiron>  120
14:28:35 <saml> can a function of arity greater than 1 be in a monoid?
14:28:44 <TomMD> > "Cheir" ++ (negateS "off") ++ "--"
14:28:46 <Cheiron>  "Cheiron--"
14:28:52 <Cale> saml: yes, via the lifting instances
14:29:03 <TomMD> @karma Cheiron
14:29:04 <Cheiron> Cheiron has a karma of 0
14:29:11 <Cale> Monoid b => Monoid (a -> b)
14:29:56 <Cale> So by applying that as many times as necessary, you'll get a monoid of functions of any type returning values in a monoid.
14:29:56 <saml> hrm
14:30:11 <Cale> This is handy for combining sorting comparison functions :)
14:30:39 <Cale> > sortBy (comparing length ++ compare) (words "This is a list of words to be sorted first by length then alphabetically.")
14:30:40 <Cheiron>  ["a","be","by","is","of","to","This","list","then","first","words","length",...
14:31:10 <Baughn> @src (++)
14:31:11 <Cheiron> (++) []     ys = ys
14:31:11 <Cheiron> (++) (x:xs) ys = x : xs ++ ys
14:31:14 <Cale> (note that ++ usually isn't generalised like that -- that's just a lambdabot extension)
14:31:23 <Baughn> Also, lambdabot-wrong-source
14:31:32 <dogbite> does anybody have suggestions on how best to post haskell code to the web, such as a wordpress blog?
14:31:47 <dogbite> what's the best practice for posting haskell code?
14:32:05 <Cale> Well, you could make it a literate Haskell script, which is nice.
14:32:08 <MyCatVerbs> dogbite: familiar with Literate Haskell?
14:32:18 <Cale> Syntax colouring is also a good idea, if you have it.
14:32:23 <MyCatVerbs> dogbite: a lot of people use bird script when writing up blog posts.
14:32:36 <dogbite> i'm somewhat familiar.  just that you prefix all code with a '>'
14:32:38 <dogbite> and the rest is comments
14:32:44 <conal> dogbite: i like the solution described at http://conal.net/blog/posts/switching-blog-engines/
14:33:01 <Cale> Right. So someone can come along and copy-paste your entire blog post into a text editor and then compile it.
14:33:03 <conal> dogbite: for auto-colored haskell code in wordpress blos.
14:33:04 <jaredj> map lets me apply one function to many values
14:33:10 <jaredj> what lets me apply many functions to one value?
14:33:24 <jaredj> :t map
14:33:27 <Baughn> @pl \x -> map ($ x)
14:33:27 <Cale> jaredj: Well, there's map ($ x)
14:33:27 <Cheiron> map . flip id
14:33:31 <mauke> jaredj: sequence
14:33:36 <Cale> jaredj: or sequence
14:33:40 <jaredj> :t sequence
14:33:42 <Cheiron> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
14:33:43 <Cale> if you have the appropriate instances handy
14:33:51 <Baughn> jaredj: That's basically what the reader monad(s) do
14:33:53 <dogbite> thanks canal.. reading..
14:34:06 <Cale> You need an instance of Monad for (e ->), which you can get from Control.Monad.Instances
14:34:25 <Cale> In that case, sequence :: [e -> a] -> e -> [a]
14:34:28 <Baughn> > (do a <- (*2); b <- (+3); return (a,b)) 42
14:34:29 <dogbite> MyCatVerbs: 'bird script' means you put '>' before code?
14:34:29 <Cheiron>  (84,45)
14:34:45 <MyCatVerbs> dogbite: yes, sorry for being too lazy to spell that out. :)
14:34:55 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
14:34:56 <Cheiron>  ("hello","olleh","HELLO")
14:35:02 <dogbite> haskell coders should be lazy
14:35:06 <mauke> > sequence [(*1),(*2),(*3)] 7
14:35:06 <duschendestroyer> hey guys .. i need to make a decision: I intend to write a program with lots of linear algebra and mostly vectors (length 3 and 4) and matrices 3x3 and 4x4 but it is possible that I need to model other dimensions later so I do not know how to handle the types a) i could make Vector3, Vector4, Matrix4x4 etc b) I could use dynamic dimensions and hope that everything works at runtime c) I could use some fancy hacks to get number-parameterized-types bu
14:35:07 <Cheiron>  [7,14,21]
14:35:10 <EvilTerran> they're called bird tracks, after richard bird
14:35:18 <Cale> > sequence [id, reverse, map toUpper] "hello"
14:35:19 <Cheiron>  ["hello","olleh","HELLO"]
14:35:24 <EvilTerran> i believe
14:35:28 <Baughn> duschendestroyer: Got cut at c
14:35:41 <EvilTerran> duschendestroyer, have you looked at what the matrix math library does?
14:36:05 <duschendestroyer> EvilTerran: hmatrix? that's b
14:36:29 <EvilTerran> ok. i hadn't checked, that's why i was asking
14:36:30 <Baughn> duschendestroyer: If b already exists, I'd go for c. a is mostly useless
14:36:39 <EvilTerran> i'd go for the fancy hacks too, tbh
14:36:56 <EvilTerran> but then, i'm like that. i should probably just bite the bullet and learn agda. :P
14:37:21 <Cale> duschendestroyer: your message got cut off, but I would probably personally go with using 1D and 2D Arrays or UArrays if the code needed to be fast. You can do fancy typing hacks to represent array sizes in the type system, but I'm not convinced that's elegant enough in Haskell for it usually to be worth it.
14:38:19 <Cale> You can do runtime matrix compatibility checks fairly easily with the tools that the array library gives you.
14:38:45 <Baughn> I wonder, isn't there already a library for (pseudo-)efficient type math?
14:39:22 <Cale> There is, but to really be very usable, I tend to think that just needs to be specially supported, or you need proper dependent types.
14:39:42 <jaredj> oh ohhh, lists have to be of one type
14:39:56 <Baughn> jaredj: Yes. That is almost never a problem.
14:39:57 <mauke> yes, otherwise they'd be tuples
14:39:57 <Cale> jaredj: Is that a problem?
14:40:02 <jaredj> :d
14:40:06 <Baughn> Cale: Well, the problem is that the math is just really slow, right?
14:40:22 <Baughn> *is just
14:40:25 <Cale> Baughn: My beef is with the syntax you have to use.
14:40:44 <Cale> Like, you can't just write something like  Vector 3 Double
14:40:54 <Cale> You have to invent your own numerals.
14:41:02 <jaredj> so i've got this data Transaction = Transaction { foo :: bar, ...} type
14:41:03 <ddarius> Vector D3 Double
14:41:12 <Baughn> Cale: That could be better, I agree. I wonder how much work it would be to add properly supported type math
14:41:18 <Cale> and use typeclasses for things like addition and so on.
14:41:33 <jaredj> i want to get the values out, and call toSql (from Database.HDBC) on them to get SqlValues, which will all go in one list ok.
14:41:58 <jaredj> whaddya call those types with named members again?
14:42:23 <mauke> records
14:42:50 <jaredj> right. so the values in my record are of different types, but all will be SqlValues by the time I'm done.
14:42:54 <Cale> jaredj: That doesn't sound like you need multiple types in one list.
14:43:03 <Cale> Er...
14:43:12 <jaredj> before the toSql, they're of disparate types
14:43:24 <duschendestroyer> I read a paper about number-parameterized-types but this Matrix D3 D3 Double does not look very appealing to me
14:43:34 <Cale> right, so you need to write something like  [toSql x, toSql y, toSql z]
14:43:45 <jaredj> blargh. i was hoping to avoid that
14:43:46 <jaredj> k
14:43:55 <Baughn> jaredj: What does the code you'd like to write look like?
14:44:08 <Cale> Baughn: probably map toSql [x,y,z]
14:44:17 <jaredj> map toSql $ sequence (member1, member2, member3) record, or so
14:44:44 <awesame> does the continuation monad implement continuations in pure haskell, or is there some kind of recourse to underlying mechanisms in there?
14:44:51 <Cale> For that, the elements of the list would need to be first-class existentially-typed
14:44:59 <dogbite> MyCatVerbs: do most people prefer the bird style over the latex tyle?
14:45:03 <Cale> awesame: pure haskell
14:45:22 <jaredj> i think the rumblings of that were in the back of my mind
14:45:26 <awesame> okay, now I just need to understand how
14:45:28 <Cale> awesame: It's even pretty straightforward, if you understand continuations well enough.
14:45:31 <dogbite> Cale: my blog is hosted on wordpress.org -- it's not clear to me i can use your solution
14:45:38 <MyCatVerbs> dogbite: bird style is a bit less work unless you're planning to write a LaTeX document.
14:45:41 <Baughn> dogbite: I'd wager that most people decide depending on what they're using it for. Latex is nicer if you're writing a /large/ document
14:45:46 <Cale> dogbite: Yeah, I have no familiarity with wordpress.
14:45:56 <saml> awesame: http://haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-Cont.html
14:45:59 <dogbite> Cale: either do i
14:46:08 <dogbite> :-)
14:46:14 <MyCatVerbs> dogbite: if you're going to write a large document and you want it nicely typeset, use LaTeX style. For shorter things (blog posts in particular) just use birds.
14:46:43 <MyCatVerbs> dogbite: blogging packages probably quarrel less with bird scripts than with LaTeX markup, anyway.
14:46:51 <dbpatterson> I'm writing a haskell wrapper to a JSON api, and it is working okay, but I feel like I am repeating so much stuff in doing this. this is mainly writing out the data types, and then writing code to extract, with error - ie Maybe monad - handling, the data out of the JSON and sticking into the types... but I'm wondering, is there a good approach to this, or a (simple) similar api to take a look at?
14:47:42 <dogbite> MyCatVerbs: what would be the advantage of birds on a blog?
14:48:16 <Cale> dogbite: People can take your blog post and copy/paste it into a texteditor and compile it right away.
14:48:29 <Cale> and all the interstitial text becomes comments.
14:49:11 <dogbite> Cale: that seems good.  no syntax highlighting though, right?
14:49:12 <conal> dogbite: on the other hand, the "> " is used for blockquotes in markdown-based blogs (like my wordpress blog)
14:49:29 <Cale> dogbite: Well, there's syntax highlighting if you install the appropriate plugins
14:49:53 <conal> and haddock-linking in some cases
14:49:55 <dogbite> canal: right '>' seems like an unfortunate choice
14:50:13 <conal> dogbite: to me too.  (btw "conal", not "canal")
14:50:29 <dogbite> canal: you're wordpress blog is hosted on your own machine, right?
14:50:36 <duschendestroyer> ok thanks for your answers ... I could not decide yet though
14:50:45 <QuietPurple> hi, i've written a very simple function that isn't working for some reason. can someone please look at it if i paste it into the bin/
14:50:45 <conal> dogbite: yes
14:50:46 <QuietPurple> ?
14:50:55 <saml> I just do:  sed 's/^>/    >/' blog.txt | pandoc | xclip
14:50:58 <Cale> QuietPurple: sure
14:51:03 <conal> QuietPurple: just do it and see
14:51:17 <QuietPurple> its just a function to negate every second member of a list
14:52:02 <mauke> f (x : y : zs) = x : negate y : f zs; f xs = xs
14:52:21 <Cale> > let negateOdd xs = [if odd n then negate x else x | (n,x) <- zip [0..] xs] in negateOdd [1..10]
14:52:22 <Cheiron>  [1,-2,3,-4,5,-6,7,-8,9,-10]
14:52:40 <mauke> > let f (x : y : zs) = x : negate y : f zs; f xs = xs in f [1..]
14:52:41 <Cheiron>  [1,-2,3,-4,5,-6,7,-8,9,-10,11,-12,13,-14,15,-16,17,-18,19,-20,21,-22,23,-24,...
14:52:42 <QuietPurple> that's basically what i've done
14:52:43 <dogbite> conal: oops, small font.  i will do more reading and maybe convert my code over to literate style
14:52:54 <dogbite> is there a script that can convert non lhs code to lhs code?
14:53:07 <dogbite> i could write a script to do it but why reinvent
14:53:19 <mauke> dogbite: perl -pe 's/^/> /'
14:53:20 <QuietPurple> its giving me a parse error in pattern error
14:53:51 <dogbite> mauke: followed by i guess s/--//
14:54:49 <QuietPurple> ok, i've got it it was because i hadn't put brackets around a:b:ns
14:55:40 <Cale> QuietPurple: yeah, have to be careful about that :)
14:56:09 <QuietPurple> thanks guys
14:56:37 <Baughn> > let negateOdd x = (-1 ^ x) * x in negateOdd [1..]
14:56:38 <Cheiron>   add an instance declaration for (Integral [t])
14:56:54 <Baughn> > let negateOdd x = (-1 ^ x) * x in map negateOdd [1..]
14:56:56 <Cheiron>  [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,...
14:57:49 <Baughn> > -1 ^ 2
14:57:50 <Cheiron>  -1
14:57:57 <FordCortina> im trying to build ghc but i get this error on installation: installPackage: Error: Could not find module: Graphics.UI.GLUT with any suffix: ["hi"]
14:58:00 <mauke> > negate 1 ^ 2
14:58:01 <Cheiron>  1
14:58:27 <Cale> > let negateOdd = foldr (\x xs -> x : map negate xs) [] in negateOdd [1..10]
14:58:28 <Cheiron>  [1,-2,3,-4,5,-6,7,-8,9,-10]
14:58:49 <mauke> oh wow
14:58:54 <ziman> > (-1) ^ 3
14:58:54 <Cheiron>  -1
15:00:04 <Cale> (of course, that's a bit stupidly inefficient)
15:03:06 <Baughn> > let negateOdd x = (-1) ^ x) * x in map negateOdd [1..]
15:03:06 <Cheiron> Unbalanced parentheses
15:03:20 <Baughn> > let negateOdd x = ((-1) ^ x) * x in map negateOdd [1..] -- I have to say, having to do this is a bit surprising
15:03:21 <Cheiron>  [-1,2,-3,4,-5,6,-7,8,-9,10,-11,12,-13,14,-15,16,-17,18,-19,20,-21,22,-23,24,...
15:03:40 <mauke> I vote for removing unary - from the language
15:03:54 <Baughn> If this is how it's going to work, I agree
15:03:56 <Cale> I vote for keeping it forever.
15:04:02 <Cale> :)
15:04:07 <Baughn> I vote for renaming negate to "neg"
15:04:14 <mauke> Baughn: agreed
15:04:23 <mauke> I also want syntax for negative literals
15:04:54 <Baughn> I don't see why we couldn't use - for that, to be honest
15:05:12 <Baughn> It's not surprising. Everyone *else* has it overloaded for both unary and binary - just do a better job of it.
15:05:41 <mauke> that makes (- 1) and (-1) mean different things
15:05:53 <Baughn> True
15:06:07 <Baughn> We already have significant whitespace. Some more won't kill us.
15:06:08 <Cale> I want to keep the ability to write (-x) anyway
15:06:15 <mauke> Cale: boo
15:06:31 <Cale> But I'd be okay with (- x) meaning the section.
15:06:52 <Cale> Since it'd show up as a type error pretty likely, if you meant the wrong one.
15:06:54 <Baughn> Syntax coloring would suffice to disambiguate them
15:07:10 <mauke> in that case I want user-defined unary operators
15:07:12 <saml> > let x = 1 in ( (- x), (-x))
15:07:14 <Cheiron>  (-1,-1)
15:07:31 <saml> > let x = 1 in ( (- x) 1, (-x))
15:07:32 <Cheiron>   add an instance declaration for (Num (t -> t1))
15:07:38 <Cale> > let (!) x = product [1..x] in (5!)
15:07:39 <Cheiron>  120
15:07:43 <Cale> ;)
15:07:46 <SamB> hmm, kinda funny having to import classical logic in order to get proof-irrelevance...
15:08:15 <Cale> 120 seems to be my favourite number today.
15:08:17 <saml> hrm i remember (+ 1) is a function. maybe (- 1) is not. and that was the whole point of this discussion.
15:08:23 <saml> that i just found out
15:08:23 <Baughn> The only problem with - is that it's supposed to be unary /and/ binary
15:08:24 <Cale> > ((+) .) . (*) $ 3 + 4 $ 9 + 2 $ 43
15:08:24 <Cheiron>  120
15:08:45 <Baughn> That is wrong, but there's nothing we can do about it now. That said, I see absolutely no reason to let users define /more/ such horrors.
15:09:03 <mauke> special cases suck
15:09:07 <ziman> how did you make that ! postfix?
15:09:21 <Baughn> mauke: Shall we complain to Euclid?
15:09:29 <Baughn> ziman: It's a ghc extension
15:09:57 <SamB> Baughn: did he make up that notation for negtation/subtraction?
15:10:09 <jaredj> @hoogle (Monad m) => m a -> (a -> m [b]) -> m [b]
15:10:10 <Cheiron> A Hoogle error occured.
15:10:10 <ziman> does that work for all unary operators or jsut for `!'?
15:10:12 <Cale> Uh, no, that was *much* later.
15:10:13 <saml> > let (~) x = product [x..1] in (3~)
15:10:13 <Cheiron>  Parse error at ")" (column 7)
15:10:16 <Baughn> SamB: Well, no
15:10:22 <jaredj> :t concatMap
15:10:28 <Baughn> SamB: He's just an easily recognizable name, and I don't remember who did
15:10:34 <SamB> Baughn: so, uh, what are you suggesting we complain to the dead man about?
15:10:49 <ziman> concatMap :: (a -> [b]) -> [a] -> [b]
15:10:49 <Baughn> SamB: The existence of unary and binary -
15:10:57 <Baughn> SamB: He's dead. He can't argue.
15:11:05 <Jaak> > let (~) x = product [x..1] in (~) 3
15:11:05 <Cheiron>  Parse error at ")" (column 7)
15:11:06 <SamB> Baughn: he also can't fix it!
15:11:13 <Cale> ~ isn't allowed as the name of an operator, I'm pretty sure
15:11:15 <int-e> saml: ~ is part of the pattern syntax
15:11:36 <mauke> I want ~123 for negative literals!
15:11:37 <Cale> > let (#) x = product [1..x] in (3#)
15:11:38 <Cheiron>  6
15:12:01 <mauke> > let (3#) = product [1..5] in (3#)
15:12:01 <Cheiron>  Parse error in pattern at "in" (column 27)
15:12:08 <Baughn> mauke: No, ~ should be a function Num a, Vague b => a -> b
15:12:19 <int-e> > let (!~) = 1 in (!~)
15:12:20 <Cheiron>  1
15:12:32 <Cale> Wow, mIRC script. That takes me back.
15:12:43 <Cale> What an altogether horrid language :)
15:12:57 <saml> > let LET x = product [1..x] in (3LET)
15:12:58 <Cheiron>   Not in scope: data constructor `LET'
15:13:07 <saml> > let LET x = product [1..x] in (3`LET`)
15:13:08 <Cheiron>   Not in scope: data constructor `LET'
15:13:11 <Botje> $$echo(I disagree)
15:13:13 <int-e> > let (?) x = product [1..x] in (3?)
15:13:14 <Cheiron>  6
15:13:17 <jaredj> how come every time i :load something in ghci, all my things i assigned interactively go away?
15:13:28 <gnuvince_> saml: functions may not start with a capital letter
15:13:48 <Baughn> jaredj: That's what it does. If you want to keep them, define them in a file you :(re)load
15:13:51 <SamB> jaredj: because nobody could think of a better idea
15:14:07 <jaredj> meh. k
15:14:11 <SamB> jaredj: that would didn't give them a headache when they thought about how to implement it, that is
15:14:17 <jaredj> right
15:14:19 <SamB> s/would //
15:14:32 <Baughn> jaredj: It's more convenient anyway. This way you'll have a permanent record, and be able to get your state back easily if you have to quit ghci.
15:14:40 <Sadache> I am looking for a host for a track i am organizing about FP in the enterprise (in a famous conference) , do u guys have any suggestions?
15:15:02 <SamB> yeah, it really isn't very usefull to keep them around for long...
15:15:12 <SamB> if you wanted to keep something around longer, you could use :def
15:15:27 <Cale> I really really want a mathematica-style notebook interface for Haskell.
15:15:45 <SamB> only without that confounded kernel state to contend with?
15:15:49 <Cale> I'd write it, but I'm too scared to have to write the specialised text control.
15:16:04 <Cale> SamB: Yeah, hopefully you could keep things sane :)
15:16:04 <jaredj> bargh, isn't there a concatMapM?
15:16:29 <SamB> mathematica's kernel is the bane of my existance. well, not really...
15:16:46 <jaredj> progress is promising but then little things are impossible
15:17:02 <Cale> In 6.0 it's a *little* nicer, because the syntax colouring at least tells you which things are defined and which are not.
15:17:17 <mgsloan> specialized as in pretty?
15:17:44 <Cale> But it really would be nice if it could tell you whether or not a cell was committed or not, and if the language was a bit less imperative in places.
15:17:59 <Cale> It's really state which breaks the mathematica abstraction so hard :)
15:19:23 <Cale> (which makes it perfect for Haskell)
15:20:14 <Cale> Build in a nice FRP system akin to what Mathematica 6 has, and you should have something very nice. :)
15:20:46 <OceanSpray> Cale, remember that raytracer I wrote?
15:20:51 <Cale> OceanSpray: yeah
15:21:05 <OceanSpray> I was wondering whether you could gimme that scene with the balls and stuff again,
15:21:12 <Cale> Oh, sure.
15:21:19 <Cale> Should I just describe it?
15:21:27 <OceanSpray> sure
15:21:44 <OceanSpray> I "fixed" the view generator
15:21:54 <OceanSpray> now it shoots rays through a rectangle.
15:22:15 <Cale> ah, good :)
15:22:20 <OceanSpray> but I've not yet implemented the transformation to let the camera point anywhere else but straight down the z axis.
15:23:08 <Cale> Okay, there are spheres at (0,0,0), (1,1,0), (1,0,1) and (0,1,1) having radius 1/(sqrt 2)
15:23:31 <OceanSpray> ok.
15:23:34 <Cale> There's a red light at (1,0,0), a green light at (0,1,0), and a blue light at (0,0,1)
15:23:44 <Cale> The camera is at (1,1,1) and is facing (0,0,0)
15:23:56 <OceanSpray> yeah, can't do that yet.
15:24:07 <Cale> Well, feel free to rough it in.
15:24:23 <ddarius> Simply (manually) rotate
15:26:44 <Cale> I really like the mathematical simplicity of that scene. Also the way in which the lights RGB components are the same as their positions :)
15:27:04 <jaredj> http://hpaste.org/7192
15:27:06 <Cale> lights' *
15:28:17 <Cale> jaredj: I think we'd have to know what txnExists is to figure out what's going on there :)
15:28:30 <jaredj> it looks in an sqlite3 database.
15:28:50 <jaredj> i've verified that if i "insert conn txn", then txnExists conn txn yields True
15:28:54 <Cale> txnExists :: Scene -> Bool -- determines if there is a Texan.
15:29:01 <jaredj> lol
15:29:32 <jaredj> i've verified that insert conn txn returns 1
15:29:56 <Cale> hmm...
15:30:02 <jaredj> but when i delete everything, insertIfNotExists always returns 0
15:30:10 <Cale> maybe somehow the database query results are being stupidly cached?
15:30:22 <jaredj> hrm, ok. but nothing obvious right?
15:30:42 <Cale> Yeah, that doesn't seem like an obvious problem... especially if you can do things in GHCi and they work.
15:31:30 <jaredj> dooooh!
15:31:36 <Cale> Can you verify that when the database is clear, txnExists returns False?
15:31:43 <jaredj> i want to insert if it *doesn't* exist
15:31:46 * jaredj slaps forehead
15:31:58 <Cale> oh, right, of course
15:32:00 <Cale> hehe
15:32:30 <Cale> I should have looked at the name of your function, not just its contents :)
15:33:14 <jaredj> heh yeah i still depend heavily on names. it seems some here could comfortably program in de Bruijn notation; not i
15:33:50 <Cale> If you have ice cream, I will give it to you. If you have no ice cream, I will take it away from you.
15:34:09 <jaredj> "from him who has not, even what he has will be taken away"
15:34:22 <mauke> it's an ice cream koan!
15:34:30 <Botje> ice kroan!
15:34:31 <jaredj> arargaraghhh
15:34:38 <jaredj> this is an ice cream groan
15:37:52 <saml> not all ice cream have cream in it
15:38:12 <jaredj> http://bash.org/?859255
15:39:16 <mauke> Quote #859255 is pending moderation.
15:39:29 <jaredj> yeh
15:39:29 <mauke> what did you submit?
15:39:39 <jaredj> the ice cream koan, of kourse
15:39:44 <mauke> er. why?
15:39:50 <jaredj> because it was funny :)
15:39:51 <mauke> it's pretty old
15:40:08 <jaredj> meh new to me. so they'll vote it down
15:40:23 <mauke> you need to read more fortune cookies
15:40:45 <jaredj> ah. fortunes disabled at work
15:41:07 <jaredj> but it's unique, it has your name on it :)
15:42:00 <mauke> Results 1 - 10 of about 3,730 for "ice cream koan".
15:45:24 <ddarius> "this approach is embodied in two fundamental new processes: drag-along and beating"
15:48:28 <Bonus> can i pattern match the last element or two of a list?
15:48:43 <ddarius> No
15:48:47 <Bonus> :[
15:48:48 <Botje> with views you can!
15:49:08 <ddarius> Haskell doesn't have views.
15:49:21 <Botje> won't 6.10 have views?
15:49:39 <ddarius> No.
15:49:43 <Cale> That'd be news to me, but it would be quite cool.
15:50:14 <ddarius> It may have something called "view patterns", but those are what was previously called "transformational patterns" (somewhat extended and with a different syntax), not what is triaditionally called "views".
15:51:35 <Botje> oh :(
15:52:41 <ddarius> In my opinion, transformational patterns (and pattern guards) are a much better idea than views.
15:54:15 <Cale> They're certainly more lightweight
16:02:09 <astrolabe> Botje: You could reverse the list, and pattern match on the first few elements of the result (which might be inefficient)
16:03:01 <Botje> only slightly so :)
16:04:14 <SamB> does anyone have an explanation for "the wigglies" -- that annoying phenomenon where some PDFs will have their characters displaying somewhat out of vertical alignment?
16:05:36 <jaj> Hi! Is there anybody who has some experience with hstringtemplate in here?
16:05:52 <czakey> hm
16:05:53 <bos> SamB: never seen it.
16:06:12 <czakey> is there any good Haskell-fastcgi
16:06:27 <czakey> or happas howto
16:06:28 <czakey> ?
16:06:50 <czakey> @hoogle haskell fastcgi
16:06:50 <Cheiron> A Hoogle error occured.
16:06:58 <czakey> @hoogle haskell cgi
16:06:58 <Cheiron> A Hoogle error occured.
16:07:11 <jaj> @go fastcgi
16:07:12 <Cheiron> http://www.fastcgi.com/
16:07:13 <Cheiron> Title: FastCGI Home
16:07:25 <jaj> hmm
16:07:52 <czakey> I know fatcgi ;)
16:07:55 <jaj> what happened to lambdabot?
16:08:02 <czakey> but im asking about haskell
16:08:05 <czakey> under it
16:08:18 <jaj> czakey: yeah I thought it had something about haskell+fastcgi ;)
16:08:40 <Bonus> is there a built in function for joining, say, ["my", "name", "is", "joe"] into "my name is joe"
16:08:51 <dibblego> Bonus, join
16:08:56 <Bonus> where is it defined
16:08:56 <dibblego> > join ["my", "name", "is", "joe"]
16:08:57 <Cheiron>  "mynameisjoe"
16:09:01 <Zao> Bonus: unwords.
16:09:05 <Bonus> unwords
16:09:05 <Bonus> ah
16:09:06 <dibblego> oh, you want intersperse as well
16:09:10 <czakey> [16:06:22] < czakey> where is lambdabot
16:09:11 <dibblego> or what Zao said
16:09:13 <czakey> [16:06:39] < EvilTerran> she's gone to have a nap
16:09:17 <Bonus> kewl thanks!
16:09:25 <Zao> > intercalate " " ["omg", "wtf", "bbq"]
16:09:26 <Cheiron>  "omg wtf bbq"
16:09:38 <dibblego> > intersperse " " (join ["my", "name", "is", "joe"])
16:09:39 <Cheiron>  Couldn't match expected type `[Char]' against inferred type `Char'
16:09:42 <dibblego> er
16:09:52 <dibblego> > join (intersperse " " ["my", "name", "is", "joe"])
16:09:53 <Cheiron>  "my name is joe"
16:09:59 <Zao> @src intercalate
16:10:00 <Cheiron> intercalate xs xss = concat (intersperse xs xss)
16:10:10 <dibblego> nice
16:10:22 <Zao> @src join
16:10:22 <Cheiron> join x =  x >>= id
16:10:35 <dibblego> join = concat
16:11:00 <jaj> @src intersperse
16:11:00 <Cheiron> intersperse _   []     = []
16:11:01 <Cheiron> intersperse _   [x]    = [x]
16:11:01 <Cheiron> intersperse sep (x:xs) = x : sep : intersperse sep xs
16:11:45 <astrolabe> What should I import to get Parsec?
16:11:47 <mux> > intercalate " " ["hello","world"]
16:11:48 <Cheiron>  "hello world"
16:11:52 <astrolabe> (for ghc)
16:12:02 <mux> @src intercalate
16:12:03 <Cheiron> intercalate xs xss = concat (intersperse xs xss)
16:12:09 <mauke> @index GenParser
16:12:09 <Cheiron> bzzt
16:12:36 <jaj> astrolabe: see the title of the haddocks
16:12:41 <czakey> @go haskell cgi
16:12:42 <Cheiron> http://www.geocities.com/laitenberger/haskell/CGI/
16:12:42 <Cheiron> Title: Haskell CGI Library
16:12:43 <ddarius> Text.Parsec or Text.ParserCombinators.Parsec depending on which version you want.
16:12:50 <saml> @index P.GenParser
16:12:50 <Cheiron> bzzt
16:12:54 <czakey> hm
16:12:57 <saml> @index Parsec.GenParser
16:12:58 <Cheiron> bzzt
16:13:13 <astrolabe> @hoogle Parser
16:13:14 <Cheiron> A Hoogle error occured.
16:13:17 <czakey> I wonder how to start play with that
16:13:18 <jaj> @b52s
16:13:18 <Cheiron> She drove a Plymouth Satellite faster than the speed of light!
16:13:22 <astrolabe> Thanks everyone
16:14:34 <jao> hmm. latest (darcs) cabal-install fails to build:
16:14:34 <Bonus> are f a = \b -> c and f a b = c
16:14:36 <Bonus> equivalent
16:14:37 <jao> Hackage/Tar.hs:26:7:
16:14:37 <jao>     Could not find module `Data.ByteString.Lazy':
16:14:37 <jao>       it is a member of package bytestring-0.9.0.1, which is hidden
16:14:45 <astrolabe> ddarius: Is there anything else I need to do? 'import Text.Parsec' doesn't seem to work
16:15:13 <ddarius> Text.Parsec is the module used for parsec3 which isn't distributed with GHC (currently)
16:15:46 <astrolabe> I wish they wouldn't break common libraries.
16:15:51 <jaj> Is there an easy way to get a when you have Just a? or do you always have to go through pattern matching?
16:15:58 <ddarius> astrolabe: They had nothing to do with it.
16:16:06 <astrolabe> @type fromJust
16:16:07 <Cheiron> forall a. Maybe a -> a
16:16:15 <mauke> jaj: fromMaybe, maybe
16:16:24 <SamB> astrolabe: they have the traditional version in GHC still
16:16:32 <jaj> thanks mauke astrolabe :)
16:16:40 <ddarius> Also, parsec3 has a Text.ParserCombinator tree as well (though it doesn't -perfectly- match parsec2)
16:16:48 <astrolabe> ddarius: Who is 'they'?
16:17:01 <SamB> GHC devs had nothing to do with it
16:17:03 <astrolabe> SamB: I get an error from 'import Parsec'.
16:17:12 <SamB> astrolabe: not THAT traditional!
16:17:12 <ddarius> astrolabe: I should have asked you that actually, but what SamB said.
16:18:30 <ddarius> The "they" that did "break" parsec3 is me.
16:18:58 <astrolabe> Well... GHC devs must have decided to use a library that can be changed without their noticing rather than a static copy of it.
16:19:23 <SamB> astrolabe: what for?
16:19:58 <astrolabe> SamB: for the Parsec package
16:20:15 <SamB> astrolabe: I fail to follow
16:20:21 <SamB> how does any of this relate to GHC?
16:20:37 <SamB> you still have the same parsec2 that I have, right?
16:20:49 <edwardk> @seen dolio
16:20:49 <Cheiron> dolio is in #haskell. I don't know when dolio last spoke.
16:20:51 <SamB> parsec-2.1.0.0
16:20:57 <SamB> % ghc-pkg list
16:21:44 <astrolabe> SamB: Didn't 'import Parsec' use to work by default with ghc?
16:21:59 <SamB> astrolabe: that was a loooong time ago, I think
16:22:20 <SamB> at least, I don't remember ever doing it that way
16:22:27 <edwardk> @tell dolio dyna' f g = hylo (Cofree . (f &&& id)) g -- then extract from it for dyna
16:22:27 <Cheiron> Consider it noted.
16:22:43 <astrolabe> SamB: It may be a long time, but breaking it still causes problems.  It will break old code, and documentation hasn't been updated.
16:23:14 <SamB> astrolabe: which documentation?
16:23:26 <astrolabe> SamB: The parsec documentation.
16:23:33 <SamB> URL plz
16:24:07 <astrolabe> SamB: the pdf from http://legacy.cs.uu.nl/daan/parsec.html
16:24:26 <SamB> which pdf?
16:24:32 <SamB> the paper?
16:24:36 <SamB> that's a ... paper
16:24:54 <SamB> papers can't be expected to be up-to-date in that way
16:25:01 <astrolabe> The 'Parsec documentation' near the top of the page.
16:25:05 <astrolabe> Not the paper
16:25:26 <SamB> besides, that is daan's page, not ddarius's
16:25:44 <yaru1022> hi, what was the command to see the list of packages installed on my comp?
16:25:57 <dons> ghc-pkg list
16:26:07 <yaru1022> thanks
16:26:17 <astrolabe> SamB: It does say 'legacy' in the address, but it is the first hit from google.
16:26:33 <SamB> astrolabe: that might just mean that the server is legacy
16:26:40 <astrolabe> SamB: My point was that breaking things that used to work causes problems.
16:26:40 <SamB> also, iirc daan moved to MS?
16:26:46 <SamB> @google daan parsec
16:26:47 <Cheiron> http://legacy.cs.uu.nl/daan/parsec.html
16:26:47 <Cheiron> Title: Parsec
16:26:50 <SamB> @google daan
16:26:51 <Cheiron> http://daan.be/
16:26:51 <Cheiron> Title: Daan - The Close Up Live Shows
16:26:54 <ddarius> SamB: To and then from, yes.
16:26:56 <SamB> @google daan microsoft
16:26:58 <Cheiron> http://research.microsoft.com/users/daan/
16:26:58 <Cheiron> Title: Daan Leijen
16:27:06 <SamB> ddarius: where did he go now?
16:27:23 <OceanSpray> uh oh
16:27:29 <OceanSpray> Cale, you still here?
16:27:38 <Cale> OceanSpray: yeah
16:27:52 <OceanSpray> you wrote that imlib thing, right?
16:27:52 <ddarius> SamB: If my sources are correct, relatively recently he went to equational.org
16:27:56 <astrolabe> SamB: So should I find documentation through hackage?
16:28:13 <OceanSpray> http://i116.photobucket.com/albums/o11/omgwtfazn/out-1.png
16:28:14 <SamB> astrolabe: that would give you the docs for the package you are looking at...
16:28:20 <OceanSpray> something's wrong with this rendering.
16:28:30 <ddarius> astrolabe: Hackage has haddock for everything for parsec3, but it still refers to Daan's page as his letter is still the best source of tutorial-like documentation.
16:28:52 <ddarius> OceanSpray: Very impressive
16:28:57 <SamB> astrolabe: hmm, read the next paragraph or so after the link to that?
16:29:21 <SamB> astrolabe: ... and don't ask me why daan didn't update the PDF
16:29:28 <OceanSpray> ddarius, huh?
16:29:41 <SamB> Nowadays, Parsec is distributed with the standard Haskell libraries with most Haskell compilers (GHC, NHC, Hugs). You can import the Parsec library now with hierarchical module names, for example:
16:29:41 <SamB> import Text.ParserCombinators.Parsec
16:29:49 <ddarius> SamB: He probably didn't update it because he probably hasn't really done much with Parsec since 2001
16:30:13 <SamB> ddarius: that makes it difficult to go into the PDF and change one line now?
16:30:17 <astrolabe> SamB: Perhaps 'should' would be more helpful than 'can' in that sentence.
16:30:40 <SamB> astrolabe: well, see ddarius' statement above
16:31:01 <astrolabe> SamB,ddarius :Sorry, I'm just whinging.
16:31:13 <SamB> ddarius: I don't suppose he will be willing to relinquish the sources to that documentation?
16:31:16 <ddarius> SamB: By "done much with parsec", I mean done anything maintainership-wise with parsec.  As far as I can tell, parsec has been unmaintain for the vast majority of existence.
16:31:31 <ddarius> SamB: No one seems to be able to get in touch with him.
16:31:41 <SamB> well, where does he work?
16:32:41 <SamB> hmm, he didn't even change the URL in the parsec logo HTML snippet...
16:34:57 <lispy> didn't the author of parsec move on to work at MSR or some place and the problem with contacting the author is just one of getting ahold of the right contact info?
16:35:25 <SamB> lispy: I don't think that's it
16:36:40 <saml> MSR is IO monad. once you get in, no way out
16:36:59 <lispy> oh, is lambdabot down?
16:37:05 <SamB> Microsoft Research
16:37:05 <SamB> One Microsoft Way
16:37:05 <SamB> Redmond, WA, 98052
16:37:05 <SamB> email:	daan@microsoft.com
16:37:05 <SamB> phone:	+1 425 707 6629
16:37:05 <SamB> fax:	+1 425 936 7329
16:37:11 <SamB> that's the MS contact info
16:37:40 <saml> @go 425 707 6629
16:37:42 <Cheiron> http://research.microsoft.com/users/daan/
16:37:42 <Cheiron> Title: Daan Leijen
16:37:56 <lispy> saml: I guess that's what you call a "think tank" then....more of a "think cage" though...
16:38:46 <Bonus> check this out guys i made a pretty cool thing i think
16:38:47 <Bonus> http://hpaste.org/7193
16:38:55 <Bonus> it's a reverse polish notation expression evaluator
16:39:19 <dibblego> ?index intercalate
16:39:20 <Cheiron> bzzt
16:40:44 <cpoucet> @bot
16:40:44 <Cheiron> :)
16:41:16 <jorick> how do i convert "1" to 1?
16:41:23 <Bonus> read "1"::Int
16:41:24 <ddarius> > read "1" :: Int
16:41:25 <Cheiron>  1
16:41:36 <jorick> Bonus, ty
16:41:45 <Bonus> kewl
16:41:55 <jorick> > read "foo" :: Int
16:41:56 <Cheiron>  Exception: Prelude.read: no parse
16:42:37 <ddarius> Bonus: Lists are stacks, you are going out of your way to inefficiently write what you want.
16:42:38 <lispy> Bonus: Hmm...are you putting new values at the end of the list?  I think that might be the more ineffecient way to make a stack
16:43:00 <Bonus> yeah now i'm thinking over it
16:43:07 <Bonus> it makes more sense to push to the beginning of the list
16:43:11 <Bonus> instead of to the end
16:43:24 <Bonus> for performance
16:43:24 <lispy> > let pop (x:xs) = (x, xs) in pop [1,2,3]
16:43:26 <Cheiron>  (1,[2,3])
16:43:38 <saml> > let push = (:); pop (x:xs) = x in pop $ push 1 [1,2,3]
16:43:40 <Cheiron>  1
16:44:20 <saml> now, when you pop a [], it'll throw error. how can I catch it?
16:44:39 <Bonus> `catch` ?
16:44:41 <lispy> Control.catch?
16:44:54 <lispy> ?hoogle catch
16:44:55 <Cheiron> A Hoogle error occured.
16:45:27 <saml> > let push = (:); pop (x:xs) = x in pop [] `catch` (\e -> return "wrong")
16:45:29 <Cheiron>  <IO [Char]>
16:46:44 <saml> > let push = (:); pop (x:xs) = x in pop [] `catch` (\e -> do { liftM $ print (show e); return "wrong";} )
16:46:45 <Cheiron>  Couldn't match expected type `a1 -> r'
16:49:49 <twb> What's the most elegant way to express the three-way branch where x<y, x>y or x=y ?
16:50:06 <conal> twb: compare
16:50:10 <SamB> > compare 1 2
16:50:10 <Cheiron>  LT
16:50:20 <conal> twb: case (compare a b) of ...
16:50:22 <twb> Thanks.
16:54:01 <ski> case a `compare` b of
16:54:11 <ski>   LT -> ..  -- a <  b
16:54:16 <ski>   EQ -> ..  -- a == b
16:54:21 <ski>   GT -> ..  -- a >  b
16:54:25 <twb> Where are guards in http://haskell.org/onlinereport/syntax-iso.html ?
16:54:39 <cpoucet> twb: like this
16:54:47 <Bonus> okay here's the revised version of the RPN evaluator what do you think http://hpaste.org/7194?
16:54:53 <cpoucet> case .. of
16:54:59 <cpoucet>    Pattern | guard -> ...
16:55:07 <cpoucet>        | otherwise -> ...
16:55:17 <cpoucet> twb: 'guard' should evalute to a boolean
16:55:31 <ddarius> Bonus: Too many parentheses and use pattern matching.
16:55:34 <cpoucet> twb: they can also be used in functions
16:55:42 <Bonus> hmmm
16:55:44 <cpoucet> function pattern | guard = ...
16:55:47 <cpoucet>     | otherwise = ...
16:55:51 <cpoucet> then if the pattern matches
16:55:53 <Cale> twb: It's in the context free syntax under  gdrhs
16:56:04 <cpoucet> the guard is checked, if it returns true, then the first ... otherwise the second ... is evaluate
16:56:04 <Bonus> how do i pattern match for first:second:rest_of_list
16:56:16 <ddarius> Exactly like that + parentheses
16:56:21 <twb> Cale: of course, I needed to remove the silly vowels :P
16:56:22 <Cale> Bonus: just like that, but remember to put parens around it if it's a function parameter
16:56:32 <Bonus> aha
16:56:41 <Bonus> kewl
16:56:45 <ddarius> > let f (x:y:xs) = (x,y,xs) in [1,2,3]
16:56:46 <Cheiron>  [1,2,3]
16:56:51 <ddarius> > let f (x:y:xs) = (x,y,xs) in f [1,2,3]
16:56:52 <Cheiron>  (1,2,[3])
16:56:57 <Bonus> nice
16:57:11 <adekoba> why do you need parenthases? can't ghc figure out that it is one argument?
16:57:21 * adekoba never understood this
16:57:36 <SamB> adekoba: that's the way the syntax was defined
16:57:52 <Heffalump> because otherwise you would be defining the operator (:)
16:57:53 <Cheiron> Heffalump: You have 1 new message. '/msg Cheiron @messages' to read it.
16:57:55 <Cale> It syntactically looks like a pattern binding otherwise
16:58:18 <Cale> You can't define the operator : because it's a constructor
16:58:23 <Cale> So that's a pattern
16:58:30 <Heffalump> oh, yeah
16:58:43 <Cale> Except it's still syntactically incorrect...
16:58:49 <Cale> Since f is lowercase.
16:59:12 <Heffalump> yes, well the underlying point is that pattern syntax mirrors expression syntax
16:59:20 <Cale> right
16:59:22 <Heffalump> so the same rules apply, although fewer things are valid
16:59:35 <Heffalump> why is Cheiron telling me about things that are several months old?
17:00:14 <Cale> Yeah, it would be strange for  f x:xs   to mean f (x:xs) on the LHS, and to mean (f x):xs on the RHS of an equation
17:00:16 <allbery_b> hasn't been here since then?
17:00:30 <Cale> That's I suppose the real explanation.
17:01:08 <twb> What's the ∈ operator/function called?
17:01:08 <Bonus> ok y0 how is this for less parens and pattern matching http://hpaste.org/7195
17:01:18 <Cale> elem ?
17:01:21 <twb> elem?
17:01:22 <allbery_b> `elem`
17:01:26 <twb> Woo, got it on my third guess.
17:01:29 <twb> Too much lua
17:01:30 <Cale> > 4 `elem` [1..10]
17:01:31 <Cheiron>  True
17:01:34 <Cale> > 12 `elem` [1..10]
17:01:35 <Cheiron>  False
17:04:25 <yaru1022> does anyone know where i can find a glome scene haskell source code?
17:06:00 <twb> What happened to lambdabot?
17:06:06 <newsham> vacation
17:06:09 <Zao> Lazy.
17:06:21 <cpoucet> evaluation
17:06:32 <ddarius> She got tired of us.
17:09:11 <Cale> oh, code is back up!
17:09:25 <Cale> It's bloody slow, but it's up
17:10:53 <ski> @arr
17:10:53 <Cheiron> I'll crush ye barnacles!
17:11:01 <lambdabot> Aye Aye Cap'n
17:11:33 <newsham> ?yow
17:11:33 <Cheiron> Couldn't find fortune file
17:11:39 <lambdabot> I smell like a wet reducing clinic on Columbus Day!
17:13:11 <lispy> yaru1022: glome scene?
17:15:50 <Arnar> evening
17:15:53 <mauke> > ()
17:15:54 <lambdabot>  ()
17:15:54 <Cheiron>  ()
17:15:59 <mauke> Cheiron: @part #haskell
17:16:16 <Arnar> yay.. lambdabot++ is back :)
17:16:41 <mauke> @karma lambdabot
17:16:41 <lambdabot> lambdabot has a karma of 2
17:17:16 <Arnar> anyone here familiar with the ghc build system?
17:18:06 <twb> How do I generate a pseudorandom value for a Bounded type (say, Char)?  I'm having trouble following the Random module.
17:18:20 <Arnar> I'm wondering how to get just one extra package (as opposed to getting them all with ./darcs-all --extra get)
17:19:17 <newsham> > randoms (mkStdGen 1) :: [Char]
17:19:19 <lambdabot>  "\629073\603808\589755\435161\1103860\398837\853172\649397\957366\147026\219...
17:19:40 <Arnar> there is an "instance Random Char"..
17:19:44 <newsham> > randoms (mkStdGen 1) :: [Word8]
17:19:45 <lambdabot>  [81,160,187,217,244,245,180,181,182,82,191,131,68,141,82,191,104,16,242,24,8...
17:19:50 <conal> geezusfreeek: i just sent a follow-up response to your haskell-cafe note ("Caching the Result of a Transaction?").  I hope it clarifies rather muddies the issue.
17:19:51 <twb> And 1 is the seed?
17:19:54 <cpoucet> > randoms (mkStdGen 1) :: [Bool]
17:19:56 <lambdabot>  [True,False,True,True,False,True,False,True,False,False,True,True,False,True...
17:19:58 <cpoucet> > randoms (mkStdGen 1) :: [()]
17:19:59 <lambdabot>   add an instance declaration for (Random ())
17:19:59 <lambdabot>     In the expression: randoms ...
17:20:33 <newsham> twb: yah, 1 is the seed.  there are other ways to get a generator, though
17:21:06 <Arnar> :t length
17:21:08 <lambdabot> forall a. [a] -> Int
17:21:40 <Arnar> > length $ filter id $ take 500 (randoms (mkStdGen 1) :: [Bool])
17:21:40 <lambdabot>  255
17:22:10 <twb> I'd like to get a pseudorandom see from something like the epoch time
17:22:19 <mauke> > sum . map fromEnum . take 500 . randoms . mkStdGen $ 1
17:22:20 <lambdabot>  Add a type signature
17:22:26 <twb> Or /dev/urandom or whatever
17:22:47 <mauke> > sum . map fromEnum . take 500 $ (randoms . mkStdGen $ 1 :: [Bool])
17:22:48 <lambdabot>  255
17:22:56 <Arnar> :t fromEnum
17:22:57 <lambdabot> forall a. (Enum a) => a -> Int
17:23:08 <Arnar> what's an Enum?
17:23:13 <mauke> @src Enum
17:23:13 <lambdabot> class  Enum a   where
17:23:13 <lambdabot>     succ                     :: a -> a
17:23:13 <lambdabot>     pred                     :: a -> a
17:23:13 <lambdabot>     toEnum                   :: Int -> a
17:23:13 <lambdabot>     fromEnum                 :: a -> Int
17:23:15 <lambdabot> [3 @more lines]
17:23:22 <Arnar> ah.. ok
17:23:24 <twb> Arnar: the class of datatypes that are enumerable.
17:23:35 <Arnar> so that's used for [a..b] ?
17:23:37 <mauke> does anyone know where randomIO gets its seed from?
17:23:40 <MyCatVerbs> Arnar: yep.
17:24:10 <Arnar> > fromEnum True
17:24:11 <lambdabot>  1
17:24:31 <MyCatVerbs> > [False..]
17:24:31 <lambdabot>  Parse error at "False..." (column 2)
17:24:43 <Bonus> is there a way to read a double from a string in a radix that's not 10?
17:24:43 <MyCatVerbs> > enumFrom False
17:24:44 <lambdabot>  [False,True]
17:24:53 <mauke> > [False ..]
17:24:54 <lambdabot>  [False,True]
17:24:59 <Arnar> ok..
17:25:02 <Arnar> > succ True
17:25:03 <lambdabot>  Exception: Prelude.Enum.Bool.succ: bad argument
17:25:08 <twb> I'm writing a "guess what number I'm thinking of" program and I want it to appear to randomly choose an integer between 0 and 9 inclusive.
17:25:09 <newsham> mauke: same as getStdGen I think
17:25:47 <mauke> twb: randomRIO (0, 9)
17:25:50 <newsham> > randomRs (mkStdGen 1) (0,9)
17:25:50 <lambdabot>  Couldn't match expected type `(a, a)'
17:25:55 <twb> Ah, neat.
17:26:00 <newsham> > flip randomRs (mkStdGen 1) (0,9)
17:26:01 <lambdabot>  [7,8,7,9,0,9,6,7,2,0,3,7,6,3,8,5,4,2,8,6,6,9,2,6,9,3,7,6,3,8,8,9,8,1,6,4,2,1...
17:26:49 <Arnar> twb: http://www.haskell.org/onlinereport/random.html#global-rng
17:26:50 <lambdabot> Title: The Haskell 98 Library Report: Random Numbers
17:27:08 <jaj> > randomRs (mkStdGen 1) (0,9)
17:27:08 <lambdabot>  Couldn't match expected type `(a, a)'
17:27:18 <jaj> hmm why does it need flip?
17:27:26 <newsham> > randomRs (0,9) (mkStdGen 1)
17:27:27 <lambdabot>  [7,8,7,9,0,9,6,7,2,0,3,7,6,3,8,5,4,2,8,6,6,9,2,6,9,3,7,6,3,8,8,9,8,1,6,4,2,1...
17:27:36 <jaj> oh yeah I just saw that...
17:27:48 <newsham> flip was just easier in a line-edit sense
17:28:07 <Arnar> so.. how'bout them GHC sources?
17:30:04 <jaj> @seen hpaste
17:30:04 <lambdabot> I haven't seen hpaste.
17:30:20 <Bonus> hexadecimal numbers are represented as 0xFF for example
17:30:27 <Bonus> are there any other bases that can be represented directly
17:30:37 <jaj> http://hpaste.org/7196 wrote that once to learn how random numbers work in haskell :)
17:31:21 <Arnar> Bonus: looks like octal is there too
17:31:22 <Arnar> http://www.haskell.org/onlinereport/lexemes.html#lexemes-numeric
17:31:22 <lambdabot> Title: Haskell 98 Lexical Structure
17:31:33 <Arnar> > 010
17:31:34 <lambdabot>  10
17:31:37 <Bonus> aha cool
17:31:43 <Arnar> > 0O10
17:31:44 <lambdabot>  8
17:32:33 <newsham> ?check oct31 == dec25
17:32:34 <lambdabot>   Not in scope: `dec25'
17:32:54 <Bonus> > decit{0xFF}
17:32:55 <lambdabot>  Parse error at "0xFF}" (column 7)
17:33:23 <allbery_b> that' pseudo-bnf, not haskell syntax
17:33:27 <Bonus> oh
17:34:08 <Botje> I will spend tomorrow tackling uniplate for tree rewrites
17:34:13 * Botje predicts loads of fun
17:35:38 <Bonus> here's my final (i think) verison of the RPN evaluator http://hpaste.org/7197
17:35:46 <Bonus> i think that's as terse as it gets
17:36:37 <ddarius> Bonus: You can drop some parentheses and replace the code with a foldl.
17:36:53 <Bonus> a foldl huh?
17:36:54 <Bonus> hmmm
17:39:14 <twb> Is there a way to ask ghci to list all (currently known) instances of a type class?
17:39:19 <ddarius> > foldl (\acc@(~(x:y:xs)) op -> case op of "+" -> x+y:xs; _ -> read op:acc) [] . words "3 4 + 5 +"
17:39:20 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
17:39:28 <ddarius> > foldl (\acc@(~(x:y:xs)) op -> case op of "+" -> x+y:xs; _ -> read op:acc) [] . words $ "3 4 + 5 +"
17:39:29 <lambdabot>  [12]
17:39:31 <dibblego> ?instances Functor
17:39:31 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
17:39:39 <Bonus> yeah i'm rewriting it into a foldl now
17:39:40 <dibblego> twb, I use lambdabot for that :)
17:39:46 <Bonus> it's similar to yours :)
17:39:54 <twb> Bah.
17:40:31 <Arnar> foldl readOp stack $ words st
17:40:52 <dolio> @seen edwardk
17:40:52 <lambdabot> edwardk is in ##logic and #haskell. I don't know when edwardk last spoke.
17:41:03 <ddarius> flip foldl (flip readOp) . words
17:41:14 <ddarius> unwords . map show . flip foldl (flip readOp) . words
17:41:25 <Bonus> whoa
17:41:38 <Arnar> @pl \st stack -> foldl readOp stack $ words st
17:41:39 <lambdabot> flip (foldl readOp) . words
17:42:06 <Arnar> so.. parseExpC = flip (foldl readOp) . words
17:42:08 <Arnar> I guess..
17:42:28 <dolio> edwardk: "g_dyna m f g = extract . hylo . return where hylo = (f &&& id >>> Cofree) . fmap (hylo . join) . m . liftM g"?
17:42:30 <Bonus> nice
17:42:43 <dons> dcoutts: http://code.haskell.org/~dons/code/uvector
17:42:44 <lambdabot> Title: Index of /~dons/code/uvector
17:43:11 <Arnar> Bonus: now. sorry, ddarius was right.. need to flip readOp too
17:43:21 <Arnar> ooh.. star-trek on tv
17:44:14 <Bonus> very cool
17:44:25 <Bonus> the solution with the flipping i mean
17:44:31 <Bonus> which star trek
17:44:43 <sjanssen> dons: why all the U suffixes?
17:44:49 <mauke> preflex: seen edwardk
17:44:49 -preflex(n=preflex@d83-191-186-37.cust.tele2.de)- edwardk was last seen on #haskell 1 hour, 22 minutes and 22 seconds ago, saying: @tell dolio dyna' f g = hylo (Cofree . (f &&& id)) g -- then extract from it for dyna
17:44:55 <dons> sjanssen: hysterical reasons. that's a todo
17:45:10 <dons> sjanssen: if you're keen, check out test/Fusion/* and look at the core they produce :)
17:45:20 <dons> sjanssen: not a box or GC call in sight.
17:45:21 <jamii> Hi all
17:46:02 <jamii> Is there any way I can load compiled code in the interpreter instead of using interpreted code?
17:46:15 <ddarius> jamii: Compile and then load it.
17:46:33 <sjanssen> dons: so what is the advantage here over UArray?
17:47:01 <Arnar> sjanssen: hmm..
17:47:07 <Arnar> dunno it's english name
17:47:14 <jamii> ddarius: It needs a main function to compile, no? I tried -no-hs-main but it didn't work. I'd like to be able to call any function from the file
17:47:24 <Arnar> its picard.. starts with the romulan council killed by some small orb
17:47:28 <ddarius> jamii: Use ghc -c
17:47:42 <dons> sjanssen: they fuse away, and smaller overhead (not Ix, or Bounds)
17:47:48 <sjanssen> Arnar: Nemesis?
17:47:54 <dons> sjanssen: also, pure.
17:47:56 <sjanssen> Arnar: btw, was that question directed at me? :P
17:48:21 <Arnar> sjanssen: sorry.. I confused lines, it was Bonus who asked which startrek :)
17:48:22 <jamii> jamie@shiny:~/catam/17-3$ ghc -c ./17-3.hs
17:48:22 <jamii> ./17-3.hs:1:0: The function `main' is not defined in module `Main'
17:48:29 <Arnar> but yeah, nemesis it is
17:49:23 <allbery_b> jamil: unless you put the code in a named module it will assume module Main and then check for a function main
17:54:57 <jamii> allbery_b: Oops. Ok, that was obscuring the actual problem. ghc -c produces 17-3.o  . How do I use this in ghci?
17:55:00 <Bonus_> check this out guys
17:55:06 <edwardk> mauke: back
17:55:25 <Bonus_> with your help i reduced this http://hpaste.org/7193 to this http://hpaste.org/7198
17:55:34 <Bonus_> awesome
17:55:45 <allbery_b> you need to load it by module name
17:55:46 <Bonus_> (also the newer version has log, pow and sqrt)
17:55:56 <allbery_b> :m + Module
17:56:02 <conal> Bonus_: super!  big improvement.
17:56:05 <Arnar> Bonus: nice :)
17:56:15 <allbery_b> 17.3 strikes me as an invalis module name though
17:56:19 <Bonus_> foldl is the best
17:56:21 <allbery_b> er, 17-3
17:56:38 <edwardk> dolio: that should work
17:57:25 <Bonus_> off to bed good night!
17:57:32 <dolio> edwardk: Is it a special case of g_hylo? I was trying that first, but it didn't seem to be working out.
17:57:52 <Arnar> I felt a warm feeling the other day when I explained fold (er, well, "reduce" in Python) and she immediately said "oh, cool - I guess you can do almost anything with that"
17:58:03 <edwardk> dolio: http://comonad.com/reader/2008/dynamorphisms-as-chronomorphisms/
17:58:05 <dolio> Since there's no duplicate/liftW on the left.
17:58:05 <lambdabot> Title: The Comonad.Reader  Dynamorphisms as Chronomorphisms
17:58:20 <edwardk> its a special chronomorphism, its just an anamorphism instead of a futumorphism
17:58:32 <dolio> Ah.
17:58:54 <Arnar> Bonus: too many people don't see the value in abstract things (such as foldl) - glad you do
17:59:05 <jamii> allbery_b: So I've renamed and recompiled it. I now have Hamiltonian.o in my directory.
17:59:09 <dolio> You're updating your blog too fast. I can't keep up. :)
17:59:10 <jamii> Now :
17:59:10 <jamii> Prelude> :m + Hamiltonian
17:59:10 <jamii> module main:Hamiltonian is not loaded
17:59:26 <edwardk> dolio: hehe, i had a productive day
17:59:49 <dolio> edwardk: Your g_dyna has a different type than mine, though.
17:59:50 <edwardk> dolio: note the new signature for g_hylo
18:00:06 <dolio> Yeah, I saw that and changed it in category extras.
18:00:07 <allbery_b> errr
18:00:13 <edwardk> whats your type look like?
18:01:09 <dolio> edwardk: My g_dyna has a signature like g_hylo, with a monad and a distributive law fused with a natural transformation.
18:02:25 <edwardk> thats not a dyna then. that would be what i've been toying with as a 'memomorphism' or something
18:02:43 <edwardk> if you have the monad you are the dual of a dynamorphism coz a dynamorphism is a histo/ana pair
18:03:00 <dolio> Actually, your is also different in that there's an h and an f functor, whereas mine only has an f.
18:03:07 <edwardk> and histo has the fact that you have a branching stream (cofree comonad) implicit in the type
18:03:37 <dolio> Hmm...
18:03:51 <edwardk> dolio: ah so your 'g_dyna' is a dynamorphism with a histo and g_ana instead of a g_histo and an ana
18:04:04 <jamii> allbery_b: Not the most informative error message ever. On par with windows "An error has occurred"
18:04:17 <dolio> edwardk: Yeah, that sounds right.
18:04:19 <edwardk> thats the difference
18:04:20 <jamii> allbery_b: module not loaded. Very helpfull
18:05:05 <edwardk> thats why i have g_chrono since it subsumes both ;)
18:05:28 <allbery_b> jamil: at this point I'm lost and hoping someone with more understanding will jump in :/
18:05:40 <Arnar> ?src GHC.Conc
18:05:40 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
18:06:48 <jamii> Ok, thanks. Anyone know how to load compiled code?
18:08:47 <meowfaceman> So, -1 `div` 12 = 0.  Why does (-1) `div` 12 = -1? (ghc 6.8.2)
18:08:58 <edwardk> your g_dyna would allow you to sub in, for instance, an apomorphism in for the anamorphism, mine lets you use a different memoization structure. technically it should probably have both generalizations merged. it still gives a natural place to merge the natural transformation in.
18:09:01 <ddarius> jamii: Do you have a module declaration in your file?
18:09:16 <jamii> ddarius: module Hamiltonian where ...
18:10:14 <dolio> edwardk: Does g_chrono subsume the one I have? Or do you need a g_chronoEta?
18:10:17 <edwardk> the g_dyna with an apomorphism is interesting. its like if you had a dynamic programming table that you were trying out a black box with and then suddenly you figured out exactly what every entry was with an exact answer and give that
18:10:48 <edwardk> g_chronoEta should be 'g_chrono' unless you can write that distCofree' that i mentioned. i wasn't smart enough to figure it out on first glance
18:11:29 <edwardk> g_chrono isn't sufficiently general without the embedded natural transformation
18:12:21 <ddarius> jamii: Try 'ghci Hamiltonion.hs'
18:12:45 <jamii> ddarius: Works fine. I can :load just fine, but I'm pretty sure thats just giving me the interpreted version. If I move the source it no longer works.
18:12:55 <edwardk> dolio: was the natural transformation post coherent? i was trying to work up hylo shift for g_hylo then i noticed it
18:13:55 <ddarius> jamii: GHCi loads compiled code by default if it is more current than the source.
18:14:07 <dolio> edwardk: Yeah, it made sense to me.
18:15:28 <ddarius> jamii: The only way to make it -not- load compiled code is by deleting the object code files (or perhaps by touching the source file)
18:16:16 <edwardk> dolio: feel like taking a quick crack at the distCofree problem? i'm poking at it in another window
18:16:24 <edwardk> i'd love to keep the eta term out of the whole thing
18:16:25 <dolio> edwardk: I'm getting confused. How do you write "g_dyna :: (Functor f, Monad m) => (forall c. m (e c) -> f (m c)) -> (f (Cofree f b) -> b) -> (a -> e (m a)) -> a -> b" using g_chrono?
18:16:34 <jamii> ddarius: Thanks for clearing that up. I just assumed I would have to do something special
18:16:50 <edwardk> oh wait, hrmm
18:17:06 <edwardk> i think that does need g_hylo
18:17:08 <edwardk> my bad
18:17:20 <edwardk> thats an arbitrary monad not a free monad
18:17:24 <dolio> edwardk: I looked at it a little bit when I read the eta stuff, but it wasn't obvious to me, either.
18:17:28 <jamii> ddarius: Wow, if I had known that last week I would have spent a lot less time watching output trickle out
18:18:09 <dolio> edwardk: Right. Except I had trouble using g_hylo. I guess I need to wrap it in the Identity comonad or something?
18:18:10 <edwardk> i keep trying to figure it out coz the types almost work, its like if i can figure out the right fold or whatever it'd just drop out
18:18:17 <edwardk> g_hylo should work fine
18:18:24 <edwardk> there is no comonad wrapper needed
18:18:33 <edwardk> you have a comonad (Cofree h a)
18:18:37 <edwardk> you have a monad (m a)
18:18:55 <edwardk> you have a pair of laws one generated by distCofree from the law for a functor, one given in totality for the monad
18:19:00 <edwardk> you have all you need for g_hylo
18:20:09 <dolio> edwardk: Yeah, but g_hylo takes 'g (w b) -> b' and (f &&& id >>> Cofree) is 'f (Cofree f b) -> Cofree f b', so it complains.
18:20:20 <dolio> Occurs check.
18:20:28 <edwardk> one sec i'll write it up
18:23:45 <edwardk> check out http://comonad.com/haskell/Chronomorphism.hs
18:23:52 <edwardk> the version in there contains both generalizations
18:24:21 <SamB> what the heck?
18:24:21 <edwardk> g_dyna is so trivial i kinda feel bad for it ;)
18:24:24 <SamB> chromomorphism?
18:24:28 <SamB> oh, wait
18:24:30 <SamB> chrono
18:24:34 <SamB> nevermind
18:24:40 <edwardk> generalize futu- and histo- =)
18:24:43 <edwardk> needed a name ;)
18:25:03 <edwardk> er also generalizes dynamorphisms, so its got dynamic programming uses
18:26:12 <edwardk> with g_dyna basically being g_hylo with its first argument just a wrapped  in a call to distCofree i think it can probably go away
18:26:47 * allbery_b keeps misreading that as ...Coffee
18:27:10 <dolio> Huh, seems like I should have tried that when I was fooling around earlier.
18:27:13 <dolio> I wonder what I was doing wrong.
18:27:35 <edwardk> g_dyna k = g_hylo (distCofree k)
18:27:38 <SamB> edwardk: you'll have to watch out for those caffeine addicts, I guess...
18:28:00 <meowfaceman> Dammit.  Now that I know it's NOT coffee, I've literally understood none of their conversation.
18:28:08 <edwardk> heh, i need to find an excuse to work with a coffee comonad
18:28:44 <edwardk> meowfaceman: basically these are just excessively generalized versions of foldr and unfoldr ;)
18:29:18 <edwardk> just where you can do them over different things than lists and maybe have memoized some intermediate results, and you can fuse different traversals of different data structures together so that you don't have to build up and tear down intermediate results
18:30:38 <meowfaceman> This is deep juju mystery here.  To call me a Haskell noob would be an understatement.
18:30:38 <edwardk> some variations have a comonad that you can hold information about what you've already computed in, or have a monad in which you can put place markers for where you have stuff yet to do.
18:31:56 <edwardk> meowman: ever heard of 'dynamic programming'? for things like edit distance, or computing fib more efficiently, etc?
18:33:03 <SamB> @wiki dynamic programming
18:33:04 <lambdabot> http://www.haskell.org/haskellwiki/dynamic_programming
18:33:05 <dolio> edwardk: So, g_histo = foldWith . distribCofree, g_futu = unfoldWith . distribFree, g_dyna = refoldWith . distribCofree, what's flip refoldWith . distribFree called?
18:33:07 <SamB> hmm
18:33:09 <meowfaceman> Yeah, I've got a decent algorithms background.
18:33:10 <SamB> wrong wiki
18:33:15 <edwardk> so g_dyna is kinda succinct to say the least.
18:34:28 <edwardk> g_dyna's dual doesn't have a name, i've been toying with it though, its basically where you can compute a bunch of intermediate results as soon as you know their values rather than working them out one at a time. its a 'top down' dynamic programming approach or something similar whereas the dynamorphism is a bottom up dynamic programming scheme.
18:35:11 <dufflebunk> Is someone able to help me with a happs form processing problem? It's really a monad problem, I'm not sure how to do what I want.
18:35:32 <dufflebunk> http://hpaste.org/7199#a1
18:36:05 <edwardk> its like a sudoku solver. when you get some new fact it goes through and fills in everything it can figure out from the fact. rather than going through and asking each cell if it can figure out its value.
18:36:41 <meowfaceman> Hrrrrm.  Interesting.
18:36:43 <edwardk> in general it seems like a chronomorphism gives you a way to represent both forms of 'solving' at the same time. so chrono fusion is actually kinda neat ;)
18:37:23 <jaj> hmm, I did "import Data.Map" and when I try to compile I get "Not in scope: data constructor `Map'"
18:37:33 <dolio> I need to try and figure out some examples using this stuff so I can put them in the haddock.
18:37:55 <dolio> If only to figure out what these actually do. :)
18:37:56 <conal> dufflebunk: what kind of help/problem?
18:38:32 <minivan> hey, those wanting an easy way to draw diagrams without using inkscape or other complex svgs: have you looked at MetaPost?
18:38:37 <dolio> I kind of get lost at the g_ combinators.
18:38:59 <edwardk> dolio: thats what i've been working towards. i've been figuring i'll see if i could turn them into a paper.
18:39:51 <edwardk> right now what i'm looking for is a good case that warrants the power of a chronomorphism over a dynamorphism
18:40:17 <dufflebunk> conal: I have a form with numEntries, foo_0, foo_1, ... fields. I can't figure out how to get a variable number of fields out. The code in http://hpaste.org/7199#a1 assumes there are two.
18:41:12 <meowfaceman> Well, I have a really brief (but perhaps confusion question).  I'm just trying to figure out why: -1 `div` 12 != (-1) `div` 12.  I'm using ghc-6.8.2.  Just for my understanding.
18:42:17 <conal> dufflebunk: do the field names fit a regular pattern?
18:42:21 <allbery_b> haskell doesn't have a concept of negative numbers per se, that is unary negatyion (and has unexpected precendence)
18:42:36 <edwardk> i've also been trying to figure out if i can use a chronomorphism as a sort of 'buffered' hylomorphism. i.e. when you want your producer and consumer to be able to run at slightly different speeds and to switch between the two when the buffer is empty or full.
18:42:37 <allbery_b> ...and breaks a few other things, such as section syntax, but you can wory about that later
18:43:03 <Cale> -1 `div` 12 has the precedence I'd expect it to have.
18:43:04 <allbery_b> so, -1 `div` 12 parses as -(1 `div` 12)
18:43:12 <edwardk> in which case chrono-fusion can be viewed as a sort of generalized production/consumption chain
18:43:17 <allbery_b> or somethoing lik that
18:43:22 <Cale> div is a multiplicative function, so you want it to happen before negation, which is additive
18:43:23 * Taggnostr is reading haskell source
18:43:23 <dufflebunk> conal: Yeah, the number at the end increases by 1 each time up to numEntries-1
18:43:24 <geezusfreeek> conal: nice way to squeeze in exactly the interface that would otherwise be a future ;)
18:44:02 <meowfaceman> allbery_b: Well, the odd thing is that both 1 `div` 12 and -1 `div` 12 are supposed to be 0.
18:44:07 <geezusfreeek> ^ referring to Re: [Haskell-cafe] Caching the Result of a Transaction?
18:44:14 <meowfaceman> allbery_b: But if I can chalk it up to weird parsing, I can live with that.
18:44:18 <Cale> > 1 `div` 12
18:44:19 <lambdabot>  0
18:44:23 <Cale> > -1 `div` 12
18:44:24 <lambdabot>  0
18:44:26 <conal> dufflebunk: great.  define a (monadic) function that takes the loan number (0,1,...), does the lookups, and returns a Loan.  then call it in a loop (forM)
18:44:29 <Cale> yep
18:44:32 <allbery_b> you have something else going on
18:44:38 <Cale> > (-1) `div` 12
18:44:39 <lambdabot>  -1
18:44:53 <geezusfreeek> and i do think that clarifies more than muddies
18:44:55 <conal> geezusfreeek: TIVal?
18:44:59 <geezusfreeek> yeah
18:45:10 <Cale> meowfaceman: do those examples help?
18:45:15 <geezusfreeek> okay, almost exactly the interface of a future anyway
18:45:22 <Cale> meowfaceman: -1 `div` 12 means -(1 `div` 12)
18:45:26 <Zao> Is there any GUI module that _does_ work with a threaded RTS?
18:45:42 <meowfaceman> Cale: That they do.
18:45:45 <Zao> Both wx and gtk seem to require a non-threaded RTS.
18:45:51 <conal> yeah.  it's a funny thing we're doing.  so close to purely functional.  STM semantics is such overkill.
18:46:04 <dufflebunk> conal: Thanks. I missed forM when I was looking at the docs.
18:46:32 <conal> @src forM
18:46:33 <lambdabot> forM = flip mapM
18:47:29 <geezusfreeek> i thought i had mentioned IVars in my original email, but apparently i had not. i would not have gone into the details you did anyway though. i think this does clarify things, and is exactly what we need
18:47:43 <edwardk> dolio: the buffering mechanism view works rather well if you think about it, because i can return a structure that i've filled out partially, say the portion of a b-tree that exists on the current disk page i just read in,
18:48:00 <edwardk> then when asked for its next leaf down i can generate the next chunk of the tree. anything unevaluated is left as a 'seed' in the free monad and my output can depend on anything on the path to the root, so, for instance if i was doing index compression on the keys of the b-tree or something
18:48:06 <conal> geezusfreeek: great.  btw, i wonder if this very-nearly-functional is an unexplored corner of functional programming.
18:48:06 <geezusfreeek> oh wait, s/IVar/IVal/? have i been calling it the wrong thing?
18:48:22 <conal> geezusfreeek: i just made up IVal
18:48:26 <geezusfreeek> ah
18:48:34 <conal> i was going to say IVar, but the composite form is not an IVar
18:48:40 <conal> since it's not settable.
18:49:06 <conal> geezusfreeek: or, it is settable, but in exactly one way!
18:49:27 <ddarius> conal: Have you ever read Concepts, Techniques and Models of Computer Programs?
18:50:23 <conal> ddarius: sure haven't.
18:50:51 <conal> ddarius: do you recommend it?
18:51:18 <geezusfreeek> conal: i think it would be interesting research to try to define this in terms of some sort of substructural type system
18:51:32 <geezusfreeek> i am not intimate with substructural type systems, unfortunately
18:51:51 * conal googles
18:52:12 <geezusfreeek> i only know about ones which restrict how many times you may _use_ a value, not how many times you may write it
18:52:27 <geezusfreeek> conal: consider, for example, linear types
18:52:34 <geezusfreeek> use once
18:52:47 <conal> geezusfreeek: got it
18:53:32 <ddarius> conal: CTM (as it is referred to) is highly recommended by many including me.  It is on the level of TAPL or SICP or other books named by acronyms.
18:53:50 <geezusfreeek> hmm… the function which sets the value of the IVal could be defined in terms of linear types though, i think
18:54:37 <geezusfreeek> or maybe an affine type
18:55:40 <geezusfreeek> the IVals themselves are kind of mysterious though
18:56:24 <conal> i like the accuracy of the representation used in my paper.
18:56:49 <geezusfreeek> well, such types are beyond haskell anyway
18:58:35 <geezusfreeek> conal: the representation of which abstraction?
18:58:38 <conal> maybe there's a cleaner way to construct the primitive futures, other than forkIO, mvar/tvar, and unsafePerformIO, while keeping the simple/direct representation.
18:58:41 <conal> geezusfreeek: Future
18:58:44 <geezusfreeek> ah
18:59:30 <geezusfreeek> well, surely it depends on references of some sort
18:59:56 <conal> geezusfreeek: the implementation depends?
19:00:14 <conal> geezusfreeek: *all* of lazy functional programming depends on references in the implementation.
19:00:18 <geezusfreeek> conal: yes, unless we can come up with a different way to feed it values from the ouside
19:00:36 <geezusfreeek> conal: well, i mean settable/gettable references
19:00:40 <geezusfreeek> explicitly
19:01:23 <conal> geezusfreeek: in the interface.  i figured you meant that.  i just wanted to suggest that those references could perhaps be pushed into the language implementation instead.
19:01:37 <geezusfreeek> conal: ah yes, that is exactly what i would love
19:01:43 <conal> :)
19:03:10 <conal> geezusfreeek: after all, the future can be computed, simply by waiting and observing.  so why not represent the future as an unevaluated pure value.
19:03:18 <geezusfreeek> exactly
19:03:25 <conal> ! :)
19:04:26 <zgold> Is it possible to do IO() within STM()?
19:04:37 <conal> zgold: no
19:04:46 <geezusfreeek> actually, yes
19:04:55 <zgold> Oh right
19:04:58 <zgold> Rolling back
19:05:10 <Zao> It kind of goes against the whole "no firing of missiles" idea of STM.
19:05:21 <zgold> Yeah, i wasn't thinking
19:05:24 <conal> geezusfreeek: i have a hunch that we can move *all* imperative computation (IO and similar types) from the programming model to the implementation.  and then really do purely functional programming.
19:05:42 <geezusfreeek> conal: that is my hunch as well
19:05:52 <geezusfreeek> but it is nice to see i'm not the only one!
19:06:10 <geezusfreeek> i'm not so sure, though, that it would be superior to monads for most things
19:06:17 <geezusfreeek> *the current monadic approach
19:07:11 <conal> yeah, we'll see.  my metric is simplicity of denotational semantics.  IO is incredibly intractable (especially with concurrency).
19:07:30 <conal> while numbers, trees, and FRP have simple denotational semantics.
19:07:42 <geezusfreeek> zgold: it's evil, but http://haskell.org/ghc/docs/latest/html/libraries/base/GHC-Conc.html#v%3AunsafeIOToSTM
19:07:43 <lambdabot> http://tinyurl.com/ys92tb
19:07:50 <conal> hence good for reasoning & composition.
19:07:59 <zgold> geezusfreeek: I'm gunna use a less evil approach :)
19:08:15 <geezusfreeek> zgold: good idea
19:08:44 <conal> zgold: good.  things like unsafeIOToSTM are like old dynamite.  never know when it'll blow up.
19:08:57 <zgold> Its called... unsafeIOtoSTM ?/
19:08:59 <zgold> holy crud
19:09:41 <geezusfreeek> zgold: does that seem an unreasonable name?
19:09:50 <zgold> No not at all
19:09:55 <zgold> its just a scary name :)
19:10:00 <geezusfreeek> yes it is
19:10:06 <Zao> Heh, gtk2hs has a function unsafeInitGUIForThreadedRTS. Now that's a mouthful.
19:10:20 <zgold> Its a sentence.
19:10:46 <geezusfreeek> other languages get an exclamation mark. we make sure it gets noticed with "unsafe"!
19:15:26 <zgold> does hmake not work with 6.8?
19:16:39 <geezusfreeek> conal: it just occurred to me that this FRP semantics might have an interesting definition in terms of the π-calculus
19:17:47 <conal> geezusfreeek: i'm in emacs without utf8.  was that pi-calculus?
19:17:57 <geezusfreeek> yes, pi-calculus
19:18:15 <geezusfreeek> sorry, i'm on os x with an all-too-handy option key
19:18:23 <conal> nice
19:18:27 <geezusfreeek> if only i had a lambda shortcut!
19:19:14 <Arnar> what's FRP?
19:19:16 <SamB> you like the Λ-calculus?
19:19:23 * SamB did that on purpose
19:19:28 <geezusfreeek> Arnar: functional reactive programming
19:19:30 <Arnar> functinoal reactive programming?
19:19:34 <Arnar> ah..
19:19:41 <geezusfreeek> SamB: :P
19:20:10 <geezusfreeek> λ-calculus, ha!
19:21:21 <Arnar> geezusfreeek: how does that compare to, say CCS?
19:21:55 <geezusfreeek> Arnar: you mean the pi-calculus?
19:21:59 <SamB> did you know that in Henk, a→b is sugar for π_::a. b?
19:22:02 <dzlk> ack. I'm in a known-good unicode aware rxvt, so that must be irssi that's choking on the pi...
19:22:09 <Arnar> geezusfreeek: no.. frp
19:22:23 <SamB> dzlk: you say you are using urxvt?
19:22:31 <dzlk> yep!
19:22:37 <geezusfreeek> Arnar: ah, to my knowledge there hasn't been much of a comparison of FRP to process calculi yet
19:22:52 <Arnar> geezusfreeek: ok.. (reading the wikipedia entry now)
19:23:03 <Arnar> but does it make sense to compare it to pi-calculus?
19:23:18 * SamB throws in a comment about a 22 kΩ resistor for good measure
19:23:27 <geezusfreeek> Arnar: maybe not all FRP in general, but the specific kind that conal and i are talking about might
19:23:40 * SamB wishes x-chat would switch back to the fixed-width font for the space...
19:23:44 <geezusfreeek> Arnar: most FRP seems to be defined in terms of Arrows
19:23:46 <conal> geezusfreeek: though the specifics are about the implementation, not the interface & semantics.
19:23:58 <Arnar> geezusfreeek: ok.. (sorry for the newbie questions)
19:24:41 <geezusfreeek> conal: right, but i still haven't seen a formulation of FRP in a process calculus yet, and i suspect it would be a pretty simple definition
19:24:52 <geezusfreeek> not that that helps us with an implementation
19:25:01 <geezusfreeek> i just find such speculation interesting
19:25:05 <conal> geezusfreeek: even with frp's continuous-time semantics?
19:25:27 <chessguy> 'evening haskellers
19:25:56 <byorgey> hey chessguy
19:26:04 * lament generates an audio signal that's 1 at rationals and -1 at irrationals
19:26:22 <byorgey> lament: hehe, awesome. =)  what's it sound like?
19:26:28 <chessguy> byorgey :)
19:26:49 <lament> byorgey: like a cross between the beatles and bob marley
19:27:05 <OceanSpray> Cale, check it out:
19:27:05 <OceanSpray> http://i116.photobucket.com/albums/o11/omgwtfazn/out-2.png
19:27:14 <geezusfreeek> conal: well, it seems to me that it would almost be trivial to implement futures, and then events would fall out of that pretty easily
19:27:28 <Arnar> lament: Cantor's Symphony?
19:28:04 <conal> geezusfreeek: perhaps.  though i wonder about determinacy.
19:28:04 <lament> For string aleph-tet.
19:28:06 <chessguy> OceanSpray: that's pretty cool-looking
19:28:10 <byorgey> lament: amazing!
19:28:25 <conal> i have a personal bias.  operational semantics and process calculi have never appealed to me.  i like clean & simple denotational semantics.
19:29:06 <conal> s/clean/a clean/
19:29:19 * Arnar is halfway through an msc in OS and process calculi
19:29:22 <byorgey> OceanSpray: what's that from?
19:29:27 <geezusfreeek> conal: i think process calculi might have something to offer someday
19:29:30 <OceanSpray> a raytracer I wrote.
19:29:35 <byorgey> OceanSpray: nice!
19:29:36 <OceanSpray> ...in Haskell.
19:29:40 <byorgey> =D
19:29:46 <lament> "...in the type system."
19:29:53 <byorgey> =O
19:29:56 <geezusfreeek> but i do agree that in its current state of research, the results so far have been pretty ugly
19:30:28 <conal> geezusfreeek: maybe process calculi for nicely structured implementations of interfaces with simple denotational semantics.
19:30:31 <OceanSpray> I still can't figure out how to do refraction right.
19:30:34 <conal> rather than as an alternative.
19:30:37 <geezusfreeek> conal: yeah
19:30:57 <geezusfreeek> just a low level detail
19:31:11 <geezusfreeek> *low level abstraction, actually
19:31:41 <ddarius> OceanSpray: Looks a lot better than your other one.
19:32:13 <geezusfreeek> OceanSpray: pretty dang sweet looking
19:32:13 <OceanSpray> what, this?
19:32:21 <OceanSpray> http://i116.photobucket.com/albums/o11/omgwtfazn/out-1.png
19:32:56 <ddarius> OceanSpray: Yes
19:33:16 <OceanSpray> I still haven't figured out that bug either.
19:33:51 <OceanSpray> for some reason, if I set the viewing angles and resolution as anything other than a square, I get those artifacts.
19:34:36 <OceanSpray> around 200 lines of code.
19:36:43 <jaj> ?users
19:36:43 <lambdabot> Maximum users seen in #haskell: 459, currently: 409 (89.1%), active: 16 (3.9%)
19:38:04 <jaj> Ambiguous occurrence `map', It could refer to either `Prelude.map', imported from Prelude or `Map.map', imported from Data.Map at st.hs:3:0-21
19:39:09 <jaj> I thought that the fact that I imported Data.Map qualified as Map would mean that it will not interfere with the namespace
19:39:24 <TSC> How did you import it?
19:39:28 <geezusfreeek> jaj: you did "import qualified Data.Map as Map"?
19:39:32 <jaj> import Data.Map as Map
19:39:33 <jaj> import Data.Map as Map
19:39:42 <geezusfreeek> jaj: you need the qualified keyword too
19:39:49 <geezusfreeek> "as Map" just gives you a nice alias
19:39:50 <jaj> geezusfreeek: oh thank you :)
19:40:01 <geezusfreeek> np
20:12:34 <OceanSpray> what's with the w coordinate in affine transformations?
20:12:40 <OceanSpray> is that really necessary?
20:15:26 <sarehu> yes
20:15:34 <sarehu> the w coordinate is really cool, don't diss it :)
20:16:29 <sarehu> Here's an exercise: what if the universe were a 3-sphere -- the sphere x^2 + y^2 + z^2 + w^2 = 1
20:17:11 <sarehu> you would then represent points as 4D coords, (x,y,z,w).
20:17:24 <sarehu> Now consider points around (0,0,0,1)
20:18:15 <sarehu> the sphere is locally similar to euclidean space.  Vectors tangent to the sphere tell what direction we can walk in.  Those vectors are of the form (dx,dy,dz,0)
20:18:25 <sarehu> (if you're at the point (0,0,0,1)
20:19:01 <sarehu> so, what if you wanted to rotate points on the sphere in that direction
20:24:16 <sarehu> such an operation is equivalent to a translation --  and you have 3 coordinates to choose from. The other three rotation parameters are described by the direction you want to look at.  You can swivel the camera around in 3 dimensions since the universe is locally euclidean
20:25:24 <OceanSpray> http://i116.photobucket.com/albums/o11/omgwtfazn/out-3.png
20:25:43 <ddarius> OceanSpray: You may want to look at geometric algebra.
20:25:56 <OceanSpray> hm
20:27:13 <Cale> OceanSpray: Did you end up trying that scene?
20:27:20 <sarehu> anyway, it _feels_ very similar -- translating is much like rotating along a sphere of infinite radius.  if you ever wrote a shader that takes points on the 3-sphere and maps them to euclidean coordinates to simulate flying through a 3-sphere I'm sure you would agree with me :P
20:27:26 <Cale> OceanSpray: if you want, I can work out the rotated coordinates
20:27:45 <OceanSpray> nah, I'll just implement the transformation.
20:29:43 <Cale> Heh, on this upload site, there's an ad for their premium service which claims "...the entire functions are included"
20:30:14 <chessguy> ok, i've got a haskell architectural question, and i'm not even entirely sure how to phrase it
20:30:16 <chessguy> http://hpaste.org/7200
20:30:35 <Cale> Wow! Is that all the functions which are holomorphic on C, or just a subset?
20:30:38 <chessguy> so i'm thinking about writing this class for what constitutes a data structure to represent a chessboard
20:30:38 <ddarius> OceanSpray: You may find this a nice hook given your current interests: http://www.science.uva.nl/~leo/clifford/CGA3.pdf
20:30:56 <ddarius> Cale: All of C, but I want meromorphic functions.
20:31:25 <Cale> ddarius: Er, all the functions or not :)
20:31:32 <chessguy> i want to provide a lot of default functionality, but allow the user to override a lot of it too
20:31:58 <chessguy> this way, they can easily define their own data structure, but they can also customize it a lot if they want
20:32:05 <ddarius> Cale: I would say all.
20:32:24 <chessguy> where it gets hairy though is that some overridden functions may or may not depend on other functions in the class
20:32:26 <Cale> Yeah, but you know businessmen
20:33:31 <Cale> You think you're getting the whole set of entire functions and find out it's just a countable dense subset of them.
20:33:42 <chessguy> like with the class i pasted, you may want to just define getPiece, and get getMoves for free. but you may also want to define your own getPiecesFor function, and you may want your getMoves function to be written in terms of that
20:34:23 <chessguy> am i missing some layer of abstraction or something?
20:34:37 <chessguy> or am i over-architecting it
20:34:41 <Cale> chessguy: That seems reasonable. You just have to put real implementations in.
20:34:42 <ddarius> "Surely a countable dense subset of the entire functions is enough for anyone !"
20:35:34 <chessguy> Cale: but the issue is, i don't know which function getMoves should be defined in terms of
20:36:05 <Cale> chessguy: oh, can each be defined in terms of each other?
20:36:08 <chessguy> maybe it should be in terms of getPiece, but for some data structures, it may be better for it to be defined in terms of getPiecesFor
20:36:27 <Cale> chessguy: The usual trick is to define them circularly in terms of one another.
20:36:35 <chessguy> hrm
20:36:45 <Cale> that way if you define one, they're all defined
20:36:58 <chessguy> how would it make sense to define getPiece in terms of getMoves?
20:37:10 <Cale> Oh, perhaps it doesn't.
20:37:38 <ddarius> chessguy: Why do you care what functions getMoves is defined in terms of?
20:37:43 <chessguy> Cale: to be clear, there are lots of other functions that i'll be adding to this class
20:38:25 <chessguy> ddarius: well, the client code will care, because maybe for their data structure, it's much more efficient to define getMoves in terms of getPiecesFor
20:38:31 <chessguy> rather than getPiece
20:38:36 <ddarius> chessguy: Then they will do that.
20:39:02 <Cale> chessguy: well, you do your best to minimise the number of functions the user has to define, but it's not always easy to make all possible starting points workable
20:39:27 <chessguy> hm, yeah
20:39:34 <chessguy> i'm probably over-architecting it
20:42:05 <chessguy> i just don't want it to be like "well, if you just want to re-define this one low-level function, great, but if you want the higher functions to use any other low-level function, you get nothing
20:48:44 <ddarius> Damn
20:49:14 <sarehu> meh
20:49:21 <sarehu> how many people are going to be implementing this chessboard typeclass
20:50:43 <ddarius> [22:45] * chessguy has quit ()
20:50:56 <sarehu> s/meh/feh
21:03:54 <hasenov> hello, i would like to use monad transformation to show the time in xmonad
21:04:12 <hasenov> im not sure exactly where to use the lift function though
21:04:54 <Cale> Uh, I'm not certain that you should need monad transformers for that.
21:05:35 <hasenov> well, i use getClockTime, which returns a monadic type
21:05:46 <Cale> It's in the IO monad...
21:05:48 <sarehu> nothing returns a type
21:05:58 <sarehu> stuff returns values
21:06:01 <hasenov> and then i try to display it using the dzen call
21:06:09 <Cale> sarehu: It returns something which has a monadic type
21:06:19 <sarehu> which _has_ a type yes
21:06:19 <hasenov> yeah, thats what i meant
21:06:23 <Cale> :t getClockTime
21:06:24 <lambdabot> Not in scope: `getClockTime'
21:06:31 <sarehu> IO UTCTime
21:06:41 <sarehu> er, that's getCurrentTime
21:06:56 <Cale> :t System.Time.getClockTime
21:06:57 <lambdabot> IO System.Time.ClockTime
21:07:10 <hasenov> IO ClockTime
21:07:27 <Cale> okay, and you probably want to run this in the X monad?
21:07:42 <Cale> So you need to use the io :: IO a -> X a  function to lift it.
21:08:30 <Cale> Something like  timeString <- io . fmap show $ getClockTime
21:09:26 <hasenov> Cale: what does io do?
21:09:55 <Cale> It converts an IO action into an X action. There's a monad in xmonad called X, which the whole program is named after.
21:10:48 <Cale> Does that make sense?
21:11:20 <hasenov> Cale: yeah, for now
21:11:45 <hasenov> why do i need to have "fmap show"
21:11:55 <Cale> You don't necessarily need it.
21:12:07 <Cale> I just figured it would be convenient to have the time as a string.
21:12:56 <hasenov> yeah true, thats what the dzen command takes in
21:13:10 <hasenov> so can i have the dzen command in the same function as well?
21:13:26 <Cale> What's the dzen command's type?
21:13:46 <Cale> (I'm actually pretty unfamiliar with xmonad in general, I just know a few basic things about it)
21:14:28 <Cale> Ah,  String -> Int -> X () ?
21:15:00 <hasenov> it takes as input a string and an integer, and then displays the string for a given amount of integer seconds on a bar on the top of the screen
21:16:40 <Cale> Okay, so you'd write something like   do time <- io . fmap show $ getClockTime; dzen time (5 `seconds`)
21:16:49 <Cale> Following the example in the documentation
21:17:01 <Cale> Or you could translate that to...
21:17:05 <hasenov> oh, it said Couldn't match expected type `()' against inferred type `X ()'
21:17:05 <hasenov>       Expected type: X ()
21:17:09 <hasenov>       Inferred type: X (X ()
21:17:13 <Cale> do time <- io getClockTime; dzen (show time) (5 `seconds`)
21:17:32 <Cale> hmm...
21:17:56 <Cale> Do you by any chance have an extra return somewhere, or what are you trying to define?
21:18:25 <hasenov> yeah, i defined a whole another function, im going to type it right in like u said
21:18:49 <Cale> Um, I'm trying to understand why you're getting that particular error.
21:20:42 <hasenov> Cale: hey that worked
21:20:45 <hasenov> thanx
21:20:52 <Cale> cool, no problem :)
21:21:04 <hasenov> i had it defined as a function before and I used return at the end of the function
21:21:11 <Cale> ah, okay
21:21:32 <Cale> return takes a value and turns it into the no-op action which always returns that value
21:21:45 <Cale> Which is why you ended up with X (X ())
21:22:01 <Cale> You had an X action which returned another X action as its result :)
21:22:35 <hasenov> so is the io function essentially a monad transformer that transforms everything to X()?
21:23:10 <Cale> It wouldn't be right to call the io function a monad transformer itself...
21:23:39 <Cale> But it's sort of the action transformer which goes along with the X monad, which is built using monad transformers.
21:24:11 <Cale> It actually transforms IO actions into actions in other monads which have some defined way to do that.
21:24:18 <Cale> (of which X is one of them)
21:24:37 <Cale> In the standard libraries, it's called liftIO
21:24:57 <Cale> (The xmonad libraries include it as a nice shorthand)
21:25:40 <hasenov> yeah, thats what i thought it mightve been, something like liftX
21:25:42 <Cale> A monad transformer is something which takes a monad as a whole (that is, a type constructor, like X or IO), and turns it into another monad.
21:26:38 <Cale> When you say that something is a monad, you're referring to a type constructor - for example,  Maybe  is a monad, but Just 5 isn't.
21:26:51 <Cale> And  IO  is a monad, but putStrLn "Hello" isn't.
21:27:28 <Cale> If that gets the terminology across :)
21:28:16 <hasenov> i thought Maybe is a type, and Just a is the constructor for it
21:28:29 <Cale> Maybe Integer  is a type
21:28:47 <Cale> Maybe is a type constructor, like a function on types, it takes a type and produces another.
21:29:13 <Cale> Just is one of the data constructors for Maybe types
21:29:18 <Cale> Just 5 :: Maybe Integer
21:29:24 <Cale> Just "Hello" :: Maybe String
21:29:34 <hasenov> oh ok, thats what i got confused between, data and type constructor
21:29:37 <Cale> Nothing :: Maybe a  (for any a)
21:31:06 <hasenov> so when u lift something, it surronds the current monad with the monad of the parameter?
21:31:24 <hasenov> like an onion layer
21:31:29 <Cale> Well, suppose that T is a monad transformer
21:31:33 <Cale> and that M is a monad
21:31:40 <Cale> Then T M is another monad
21:31:50 <Cale> and  lift :: M a -> T M a
21:31:59 <hasenov> T is not a monad in itself?
21:32:22 <Cale> Nope, it's just a sort of type-level function on monads.
21:32:24 <hasenov> is it a type constructor of monads?
21:32:32 <Cale> For example...
21:32:44 <hasenov> kind of like Maybe is a type constructor?
21:33:02 <Cale> newtype StateT s m a = S (s -> m (a,s))
21:33:36 <Cale> (I renamed the data constructor here to S to avoid confusion, since it's normally called StateT as well)
21:33:41 <Cale> For each type s
21:33:45 <Cale> StateT s
21:33:50 <Cale> is a monad transformer
21:33:55 <Cale> It takes a monad m
21:34:20 <Cale> and produces a new monad, which helps carry a value of type s through the computations
21:34:43 <Cale> Yeah, it's a type constructor kind of like Maybe
21:34:58 <Cale> Except that it takes a type constructor (the original monad) as one of its parameters
21:35:04 <Cale> :kind Integer
21:35:07 <Cale> :k Integer
21:35:09 <lambdabot> *
21:35:10 <yrlnry> I don't understand the effect of the declaration    data Mu f   = In (f (Mu f))
21:35:12 <Cale> :k Maybe
21:35:14 <lambdabot> * -> *
21:35:17 <Cale> :k StateT
21:35:20 <lambdabot> * -> (* -> *) -> * -> *
21:35:29 <Cale> :k StateT Integer
21:35:31 <lambdabot> (* -> *) -> * -> *
21:35:33 <ddarius> yrlnry: It works exactly like any other data declaration.
21:35:34 <Cale> :k StateT Integer Maybe
21:35:35 <lambdabot> * -> *
21:35:45 <yrlnry> ghci saus that In has type  f (Mu f) -> Mu f,  but what is the meaning of "f (Mu f)" here?
21:36:23 <Cale> yrlnry: It depends on what f is, I suppose. It's the type constructor f applied to the type (Mu f)
21:36:36 <geezusfreeek> hmm… i think i may have just solved this stm caching problem…
21:36:41 <Cale> So suppose for instance that the type constructor is Maybe
21:36:41 * geezusfreeek furiously writes code
21:36:46 <yrlnry> But what is the kind of f?
21:36:51 <Cale> * -> *
21:36:59 * yrlnry scratches his head.
21:37:16 <Cale> In :: Maybe (Mu Maybe) -> Mu Maybe
21:37:37 <yrlnry> What does it mean to have Mu Maybe?
21:37:45 <Cale> Let's think about that.
21:37:49 <yrlnry> Yes.
21:38:07 <Taggnostr> does someone know if is there a way to integrate haskell with python in some way, that is, writing haskell code that can be executed by a python program or something similar?
21:38:09 <Cale> Well, we have Nothing :: Maybe (Mu Maybe)
21:38:11 <yrlnry> I am having trouble with partially applied curried type constructors.
21:38:18 <Cale> So  In Nothing :: Mu Maybe
21:38:32 <Cale> and then  Just (In Nothing) :: Maybe (Mu Maybe)
21:38:44 <Cale> So  In (Just (In Nothing)) :: Mu Maybe
21:38:55 <yrlnry> Ahh.
21:39:01 <Cale> Can you start to see what we have?
21:39:09 <yrlnry> Yes, thanks.
21:39:15 <yrlnry> That was very helpful.
21:39:16 <Cale> It's the natural numbers of course :)
21:39:19 <yrlnry> Yes
21:39:42 <yrlnry> And in fact the following declarations do construct the natural numbers that way.
21:39:52 <Cale> :)
21:40:00 <yrlnry> Except using NatF s = Zero | Succ s    instead of Maybe.
21:40:02 <yrlnry> Thanks again.
21:40:09 <Cale> No problem :)
21:40:46 <Cale> Taggnostr: Well, Haskell has a foreign function interface which can import and export C functions.
21:41:00 <Cale> Taggnostr: So it will be much the same as interfacing Python with C.
21:41:18 <Taggnostr> I see
21:41:22 <Cale> http://wiki.python.org/moin/PythonVsHaskell has some examples
21:41:23 <lambdabot> Title: PythonVsHaskell - PythonInfo Wiki
21:42:49 <Taggnostr> do you know python too?
21:43:28 <Cale> Well, basically. I don't really use it much. In fact, I just remember that URL from the last time this question came up :)
21:44:04 <Cale> But if you put a piece of python code in front of me, I'll probably understand what's going on, and I can get by in python.
21:44:28 <sarehu> python is slow
21:44:35 <sarehu> array access is O(n^(1/2)) in python :)
21:44:50 <Cale> sarehu: How'd they end up with that bound?
21:45:02 <sarehu> snakes can't fly
21:45:10 <Cale> That's actually probably the theoretical physical bound on array access.
21:45:36 <Cale> (as n gets incredibly large, and you just keep buying more and more memory)
21:45:38 <sarehu> why, because you're accounting for gravity crushing things?
21:45:49 <Taggnostr> I'd like to try some haskell, but I have nothing to code with it, so I was thinking to write something to use with other python programs
21:45:51 <Cale> You're accounting for the fact that the speed of light is finite.
21:46:10 <sarehu> why the switch to 1/2 instead of 1/3 then?
21:46:20 <Cale> Holographic principle.
21:46:50 <Cale> (That's pretty controversial, but it's how you end up with n^(1/2))
21:46:50 <sarehu> oh gosh :)
21:47:50 <Cale> Taggnostr: That would probably work best if you had a complicated algorithm with simple inputs and outputs, which would keep the FFI simple.
21:47:50 <OceanSpray> what's array access in Haskell?
21:48:01 <Cale> OceanSpray: With Data.Array? It's O(1)
21:48:08 <OceanSpray> how would you go about implementing arrays anyway?
21:48:18 <Cale> You wouldn't, they're part of the language standard.
21:48:25 <OceanSpray> oh.
21:48:39 <OceanSpray> I always thought Data.Array was just a plain library.
21:48:49 <Taggnostr> Cale, I was thinking to write single functions, so it shouldn't be that hard
21:48:50 <Cale> ah, it's sort of halfway in between :)
21:49:05 <Cale> It uses some lower level machinery.
21:49:19 <Cale> I suppose you could implement arrays from scratch in terms of the FFI primitives.
21:49:36 <Cale> (which include stuff for allocating raw blocks of memory and stuff like that)
21:50:12 <Cale> Without lower-level primitives, the best you can do is O(log n) access.
21:50:20 <Cale> Which is still actually very practical.
21:50:21 <sarehu> are you talking about something other than Ptr and friends?  Because storablearray uses ForeignPtr
21:50:36 <Cale> sarehu: That's what I'm referring to :)
21:51:24 <Cale> You might not use ForeignPtrs if you didn't care about interoperability with C.
21:51:58 <Cale> er, hmm
21:53:41 <Taggnostr> can you suggest me some good tutorial where to start?
21:54:22 <sarehu> hm if you're starting with haskell, I'd just forget about playing with python and instead just goof around
21:55:26 <Taggnostr> well, python is the language that I know better, but haskell seems interesting too
21:56:28 <Cale> Yeah, I think they're sufficiently different, that it's probably most comfortable to just try to write small toy Haskell programs for a while. Of course, that might not fit your style of learning, but it's what I'd usually recommend.
21:56:39 <Cale> @where YAHT
21:56:40 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
21:56:43 <Cale> @where Wikibook
21:56:43 <lambdabot> http://en.wikibooks.org/wiki/Haskell
21:56:54 <Cale> Those are some reasonably good tutorials...
21:57:11 <Cale> when you get to the part on monads and/or IO, ask me and I'll point you at some other references :)
21:57:12 <Taggnostr> thanks!
21:57:28 <Cale> The monad tutorials in those are not that great.
21:57:43 <Cale> Well, I don't know -- has the wikibook been fixed?
21:57:48 <Taggnostr> btw I already tried some functional programming with python
21:57:49 <sarehu> maybe it should be
21:58:31 <Cale> Taggnostr: You may still be in for quite a ride :)
22:00:41 <Plareplane> what's the usual way to browse the repositories on darcs.haskell.org or code.haskell.org?
22:02:08 <Cale> Well, http works.
22:02:31 <Cale> and you can use darcs to get them.
22:03:08 <Cale> (there are no special tools associated with those servers afaik)
22:03:22 <Plareplane> darcs.haskell.org/darcsweb seems broken, and it's entirely absent from code.haskell.org :(
22:03:25 <Taggnostr> it seems that I can do .exe too with haskell, this could be useful, with python I can't do them easily
22:03:51 <phlpp_> n8
22:03:57 <Cale> Plareplane: and it's not on hackage either
22:04:02 <Cale> Taggnostr: yeah
22:04:37 <Cale> Taggnostr: Haskell is both compiled and interpreted. (GHC provides both, and there are a bunch of other compilers, interpreters and bytecode compilers)
22:04:59 <sarehu> ironpython can't make exes?
22:05:59 <Taggnostr> I don't know, there is py2exe but it embeds the interpreter and all the files it needs in an exe
22:07:36 <geezusfreeek> yeah, haskell's exes are _real_ exes :)
22:07:50 <geezusfreeek> s/_/"/
22:08:33 <Cale> s#s/_/"/#s/_/"/g#
22:08:36 <Taggnostr> it doesn't seem that hard
22:09:04 <Cale> What doesn't?
22:09:52 <Taggnostr> I'm looking at the examples on the wiki
22:09:58 <Cale> ah
22:10:30 <Cale> Well, there are simple examples, but also quite a few new ideas come up.
22:12:19 <Cale> For example, in Haskell, actions which perform side effects are represented as values, which can be combined and manipulated in various ways. Eventually your 'main' is one of these values, and the Haskell runtime system carries out the instructions.
22:13:18 <Cale> But for example, if you're writing a function  foo :: String -> String  (that means it takes a string and produces a string), it can do no I/O, because its type says that it's pure.
22:13:45 <Cale> Moreover, given the same string, that function will produce the same output string every time.
22:14:11 <Taggnostr> I see
22:14:19 <Cale> So the meaning of 'function' is different from in Python, it's closer to the mathematical definition of a function.
22:14:36 <Cale> Functions only serve to associate output values with input values.
22:14:52 <Cale> All other effects are represented explicitly in some fashion.
22:15:12 <Taggnostr> I also hope that haskell will help me to learn some math :D
22:15:24 <Cale> It might :)
22:15:35 <ddarius> It can if you want it to.
22:15:36 <Beelsebob> possibly some catergory theory if you care enough
22:15:57 <Beelsebob> possibly some computer science if you care enough
22:16:05 <Cale> It's not so much that you need a lot of mathematics to use Haskell, but it can help, and the particular mindset used when writing Haskell programs is similar to the mathematical mindset.
22:16:06 <Beelsebob> (where by computer science I mean the branch of maths)
22:16:44 <Cale> (Really, you'd think it ought to be that way for programming in any language, but Haskell pushes you toward that more)
22:16:49 <ddarius> My mindset when writing programs is rather different than my typical mindset when doing math.
22:17:03 <Taggnostr> I want to "mathematicize" my mindset too :D
22:17:36 <Beelsebob> Cale: if you use Haskell in what I guess could be called it's most purely functional form, yes
22:18:02 <Beelsebob> in that you can use Haskell in a form that really encourages very non-mathematical thinking, even if it does have a very strong mathematical background
22:18:10 <Cale> That's true.
22:18:15 <bos> @seen dons
22:18:15 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc and #haskell. I last heard dons speak 3h 41m 39s ago.
22:18:17 <Cale> It's technically possible to do absolutely everything in the IO monad.
22:18:48 <Cale> But to make that tolerable, I think you'd still have to do some serious functional programming from time to time :)
22:18:58 <Beelsebob> hehe, indeed
22:19:10 <Beelsebob> tbh, I make it tollerable by ignoring the IO monad as much as I can
22:19:30 <Beelsebob> or any of the state based monads for that matter
22:19:47 <Cale> That's generally a decent policy :)
22:19:56 <jcpetruzza> hi, i'm trying to upload a package to hackage but it gets rejected because "This package requires Cabal version: >=1.2&&<1.3".... what am i doing wrong?
22:21:38 <Cale> Taggnostr: Here's another big new idea -- well, it might be moderately familiar to you if you've used python's generators. Lists in Haskell, like most datastructures in Haskell are lazy, which means roughly that only as much of the structure is computed and built as you look at (with pattern matching).
22:22:06 <Taggnostr> yep, I know
22:22:36 <Cale> Taggnostr: Over time, this gives lists sort of a feel of "reified loops".
22:23:28 <Cale> A lazily evaluated list is as good as a loop counter, and a higher order function (like map, filter, or foldr for example) is rather like a loop body.
22:24:05 <Taggnostr> can I do oop with haskell (assuming that it makes some sense)?
22:24:07 <ddarius> Not like the body, like the control structure (the 'for')
22:24:22 <ddarius> The function passed to map or foldr is like the body.
22:24:32 <Cale> ah, I suppose you're right, yes
22:25:00 <Cale> Taggnostr: It's not an OO language, but you can get some of the abstractions from OO in different ways.
22:26:24 <Taggnostr> can I do, for example, a list of all the natural numbers and use filter to have another list with only the odd numbers?
22:26:30 <Cale> Sure.
22:26:39 <Cale> > filter odd [0..]
22:26:45 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
22:26:50 <Taggnostr> I think that in python this is not possible
22:27:07 <Cale> You can even have the infinite list of prime numbers.
22:27:23 <Cale> > nubBy (\x y -> y `mod` x == 0) [2..]
22:27:24 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
22:27:39 <Taggnostr> I can do a "list" of infinite numbers and a list of infinite odd numbers, but you can't filter the former to get the latter, afaik
22:27:39 <ddarius> Taggnostr: It should be no problem in python to use generators to do that.
22:28:00 <Cale> Or the infinite list of Fibonacci numbers:
22:28:11 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
22:28:12 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
22:28:36 <Taggnostr> I think that filter will start to loop through the generator without reaching the end
22:29:09 <Cale> Taggnostr: that's possible, but it'd be a bug in filter.
22:29:11 <ddarius> You may need your own filter function, but it should be no problem to write.
22:29:24 <Taggnostr> that's also true
22:29:25 <Cale> Does filter produce a generator?
22:29:39 <Taggnostr> let me check
22:30:45 <Cale> > fix ((0:) . scanl (+) 1)
22:30:46 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
22:30:55 <ddarius> In C#: IEnumerable<int> Nats() { int i = 0; while(true) yield return i++; };  IEnumerable<A> Filter(Predicate<A> p, IEnumerable<A> xs) { foreach(A a in xs) if(p(a)) yield return a; }
22:31:21 <Cale> yield return ?
22:31:29 <vixey> interesting
22:31:35 <Cale> What does yield do without the return there? :)
22:31:43 <vixey> yeild is like a weak callcc?
22:31:44 <sarehu> doesn't compile?
22:31:44 <bos> there's also "yield break"
22:31:46 <ddarius> Cale: Syntax error.
22:31:48 <sarehu> oh
22:31:59 <Cale> That's kind of an odd syntax decision.
22:32:14 <ddarius> Cale: Yeah, I thought it was weird too.
22:32:18 <Cale> But then, I suppose it's in keeping with the rest of the verbosity in C#
22:32:20 <Taggnostr> yep, it seems that filter runs through all the generator
22:32:21 <bos> "yield break" bails out of a loop.
22:32:48 <bos> so if you squint, and you have a fork in your eye, it makes a certain sense.
22:32:56 <bos> "yield" is a prefix keyword, not a standalone thing.
22:33:01 <ddarius> Cale: C# isn't too bad, much better than Java.  The biggest verbosity issue I've had is the lack of type inference.
22:33:34 <levi> Don't they have some sort of weak type inference now, or am I thinking of a different language?
22:33:38 <Taggnostr> in py yield is used in the generators
22:33:38 <bos> it seems like it's mostly recent C# that's better than java. they started around the same place, but C# has evolved rapidly, while java hasn't.
22:33:40 <sarehu> C# has Func<A,B> and that's enough  for me :)
22:33:45 <Cale> ddarius: Yeah, the type annotations in it always strike fear of working as a programmer into me.
22:33:50 <bos> yes, C# 3.0 has limited type inference.
22:33:54 <ddarius> levi: It does, but it doesn't get the things I need.
22:34:08 <Cale> Taggnostr: yeah
22:34:15 <vixey> so how do you use IEnumerable?
22:34:21 <vixey> is it just a lazy list or something?
22:34:23 <ddarius> levi: I made a HaXml type library in C# and the type variable instantiations were extremely noisy.
22:34:29 <sarehu> vixey: implement GetEnumerator
22:34:49 <sarehu> IEnumerable is an interface, you have to implement it with a class
22:34:51 <ddarius> bos: Agreed.
22:35:09 <Cale> ddarius: I misread that as HXT and wondered for a moment if you'd implemented the arrow abstraction. ;)
22:35:16 <vixey> can yeild be desugared into something whoes semantics are clear?
22:35:30 <bos> also, java is benighted without a cadre of former functional programmers to wisely steer its evolution.
22:35:44 <vixey> (I'm guessing it basically just writes a continuation down somewhere, the returns?)
22:35:55 <Cale> vixey: That's a good question...
22:35:59 <bos> yield is indeed desugared for you.
22:36:08 <ddarius> bos: Java had plenty of people who knew what they were doing available, I don't know what the heck went wrong.
22:36:09 <Taggnostr> I've also found ifilter in itertools
22:36:24 <Taggnostr> that should be the lazy version of filter
22:36:30 <bos> ddarius: they mostly lost interest and wandered off.
22:36:53 <ddarius> bos: I'm talking about when the first version of Java was being drafted.
22:37:10 <Cale> Taggnostr: If you want, I can give you a quick demo of how lazy evaluation works.
22:37:11 <bos> oh. those people weren't in the loop at the time.
22:37:34 <ddarius> Cale put it on the wiki already!
22:37:54 <Cale> ddarius: Someone might even have done that for me, and I just don't know where it is :)
22:38:38 <ddarius> @google site:haskell.org inurl:haskellwiki Cale double
22:38:39 <lambdabot> No Result Found.
22:38:45 <Cale> hehe
22:39:20 <Cale> Anyway. I'll just type it, I don't mind :)
22:39:48 <Cale> That is, if Taggnostr wants to see it :)
22:39:56 <ddarius> What about all those people who have to explain laziness when you're not around?
22:40:16 <OceanSpray> what IS laziness, anyway?
22:40:32 <Taggnostr> let's see
22:40:34 <vixey> It's an order of evaluation
22:40:37 <OceanSpray> not evaluating an argument until it is needed, and evaluating it only once if used multiple times?
22:40:43 <OceanSpray> that's what I gathered, anyways.
22:40:50 <Cale> Okay
22:40:52 <vixey> contrast with strictness, call by need, ...
22:40:56 <ddarius> OceanSpray: That's it.
22:40:56 <Cale> There's enough interest :)
22:41:12 <Taggnostr> http://dpaste.com/47085/ here is what I did with filter and py, the latter is lazy, the former isn't :P
22:41:15 <Cale> Consider the function:  double x = x + x
22:41:28 <Cale> and the expression double (double 5)
22:41:32 * dibblego grabs popcorn for Cale's double function
22:41:45 <Cale> Under strict (innermost-first) evaluation, this evaluates like this:
22:41:48 <Cale> double (double 5)
22:41:52 <Cale> -> double (5 + 5)
22:41:56 <Cale> -> double 10
22:41:59 <Cale> -> 10 + 10
22:42:01 <Cale> -> 20
22:42:35 <OceanSpray> straight from SICP!
22:42:36 <Cale> We could also choose to do outermost-first (also called normal order) evaluation on this expression
22:42:43 <Taggnostr> I think I've already seen something like that in scheme
22:42:45 <Cale> double (double 5)
22:42:50 <Cale> -> double 5 + double 5
22:42:55 <Cale> -> (5 + 5) + double 5
22:43:02 <Cale> -> 10 + double 5
22:43:06 <Cale> -> 10 + (5 + 5)
22:43:08 <Cale> -> 10 + 10
22:43:10 <Cale> -> 20
22:43:21 <Cale> Note that we wasted some work recomputing double 5 though.
22:43:44 <Taggnostr> yes
22:43:54 <Cale> So lazy evaluation is a simple refinement of that. It says that if a function parameter occurs multiple times in the body of the function, the results of evaluating it are shared between the copies.
22:44:22 <Cale> If you'll permit me to use  let ... in ...  syntax to represent this sharing, we get:
22:44:25 <Cale> double (double 5)
22:44:32 <Cale> -> let x = double 5 in x + x
22:44:38 <Cale> -> let x = 5 + 5 in x + x
22:44:42 <Cale> -> let x = 10 in x + x
22:44:46 <Cale> -> 20
22:45:02 <OceanSpray> ah.
22:45:05 <newsham> sharing is caring
22:45:23 <ddarius> @google trouble shared is trouble halved
22:45:24 <lambdabot> No Result Found.
22:45:38 <OceanSpray> I share needles because I don't care anymore.
22:45:42 <newsham>         http://hpaste.org/7197
22:45:48 <Cale> and in this case, we're back down to the same number of steps as the strict evaluation
22:45:51 <newsham> err sorry, mispaste
22:46:54 <Cale> In general sometimes lazy evaluation is faster, and sometimes strict evaluation is faster. But lazy evaluation (along with outermost-first evaluation) has one really big advantage over strict evaluation: if any evaluation order at all will terminate and produce a result, then so will lazy evaluation, and of course it will produce the same result.
22:47:20 <Cale> This is not true of strict evaluation, there are programs which don't terminate under strict evaluation which terminate nicely under lazy evaluation.
22:47:46 <OceanSpray> also straight from SICP!
22:47:56 <Taggnostr> like the example I did with filter and ifilter
22:48:01 <Cale> This makes programmers in strict languages effectively end up turning their programs inside out in order to prevent that from happening.
22:48:11 <OceanSpray> inside out?
22:48:14 <OceanSpray> call/cc?
22:48:21 <Cale> and in doing so, they're often forced to break abstraction boundaries
22:48:22 <vixey> OceanSpray: afaict it's just facts which appear in multiple texts..
22:48:28 <Cale> I'm not talking about call/cc...
22:48:46 <OceanSpray> oh.
22:49:11 <vixey> there's a huge range of hacks you can do to get round not having lazy evaluation
22:49:23 <Cale> I'm referring to the fact that rather than just generating all the data they could possibly need, and then processing that, they end up having to generate the data *while* processing it.
22:49:46 <OceanSpray> ah.
22:50:32 <Cale> Let's look at a simple example which is not perfect, but it's simple :)
22:51:01 <Cale> Consider the function  isSubstringOf xs ys = any (isPrefixOf xs) (tails ys)
22:52:19 <Cale> To a strict programmer, this looks a bit sloppy, since it would miss the early break-out
22:52:33 <Cale> for example, in the case that xs occurs right at the start of ys
22:52:49 <Cale> You're still going to generate all the tails of ys
22:53:16 <Cale> and possibly even ask whether xs is a prefix of all of them before combining those -- if you look at the source for any
22:53:20 <Cale> @src any
22:53:20 <lambdabot> any p =  or . map p
22:53:48 <Cale> So it's saying apply the prefix to all the elements of the list, and then combine the results with the 'or' function.
22:53:59 <Cale> It looks absolutely stupid to a strict programmer.
22:54:36 <Taggnostr> I used I "lazy approach" while doing a python class a while ago, the object represented an irc-privmsg, with attributes like channel, nick, msg, and so on, but the server message wasn't parser until you called the attribute, and when you did it, it parsed only the needed part :D (though I could have used methods instead that attributes, as indeed they are)
22:54:36 <Cale> But under lazy evaluation, this is no worse than the nested loops with early breakouts that you might write in python.
22:54:49 <Cale> But you got to reuse lots of handy library functions.
22:55:37 <Cale> Well, you might argue that the algorithm is naive anyway, and that's true, but this is a small example of something much more general.
22:56:17 <Cale> Taggnostr: yeah, that's the right sort of thinking :)
22:58:22 <Taggnostr> when I saw that I was creating like a dozen of attributes for every object and actually using just 1 or 2, I thought that maybe was better avoid to create them all unless I need them
22:59:21 <paolino> iirc you must intercept __new__ for that sort of things
22:59:51 <paolino> lazy objects in python
23:00:48 <newsham> cale: you can do the lazy method in python with generators (or other langauges that support coroutines)
23:00:56 <newsham> you have to manage the laziness yourself, though
23:00:58 <Cale> newsham: absolutely
23:01:12 <Cale> Of course, it only works with lazy lists.
23:01:26 <Taggnostr> at the beginning I did everything in the __init__ (the constructor), now I use the @property decorator on the attributes so I can hide a "getter" behind a simple attribute
23:01:54 <Cale> You need to design new funky kinds of generator objects to support other kinds of lazy datastructures, and those have not such nice programming models.
23:03:23 <Taggnostr> well, I'm off to sleep now
23:03:31 <paolino> and redefine methods (inside __new___) as wrappers around original ones with the actual instantiation of the object data inside and a a form of caching
23:03:33 <Cale> Well, okay, in any language with proper first class functions, you can also do it, perhaps awkwardly. But you tend not to have very good library support for lazy stuff, since if supporting laziness is even slightly harder, nobody will give it to you.
23:03:53 <Taggnostr> thanks for the infos, I will probably to start to play with haskell in some days
23:04:11 <Cale> Cool, be sure to hang around and feel free to ask lots of questions :)
23:06:12 <Cale> Heh, I just had a great idea. A blog entirely in PDF format.
23:07:25 <newsham> written in lhs2tex?
23:07:45 <Cale> Yeah.
23:08:30 <sarehu> that's a "great" idea
23:09:07 <newsham> and replies will be rejected if they dont type-check? ;-)
23:10:15 <Cale> It would be perfect for antagonising the people on reddit who don't like PDFs
23:11:05 <Cale> Especially if you submitted every article without a (PDF) in the title.
23:11:35 <newsham> whats the reddit objection to pdf?
23:13:13 <geezusfreeek> Cale: i have seen a couple blogs now that have links at the end which convert the current blog article to a downloadable pdf
23:13:39 <Cale> newsham: People have crappy PDF viewers.
23:14:10 <Cale> geezusfreeek: Yeah, but what about a blog which was *only* available in PDF :)
23:14:18 <geezusfreeek> i sure wouldn't read it :P
23:14:36 <vixey> I want to write this parser
23:14:54 <vixey> which deals with (++ " " ++) and mixfix and better backticks and all that
23:17:51 <Plareplane> how would you view such a blog?
23:19:30 <Plareplane> i don't know if any of the popular pdf viewers automatically fetch and open a pdf link without popping open new windows, while preserving forward/back
23:21:08 <OceanSpray> lol, it's Plareplane
23:21:36 <pjd_> Plareplane: there's Adobe's PDF plugin
23:30:05 <visof> hello
23:30:27 <visof> did anyone install ghc6.8.2 in netbsd ?
