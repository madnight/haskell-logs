00:00:53 <dons> ?yow!
00:00:54 <lambdabot> Hand me a pair of leather pants and a CASIO keyboard -- I'm living for today!
00:01:02 <dons> hackathon day 3 almost underway
00:01:12 <hpaste>  wadcom pasted "is there a nicer way to write it?" at http://hpaste.org/6955
00:06:15 <Cale> dons: What an apropos yow in that case :)
00:06:31 <dons> heh
00:06:43 <Cale> Somehow it just makes sense. Don't ask me how.
00:13:24 <wadcom> any suggestions on http://hpaste.org/6955, please? ;-)
00:14:06 <Cale> wadcom: You don't need the explicit type signature on that reads if you don't want it.
00:14:25 <Cale> (since the type signature for your function as a whole pins that down nicely)
00:14:30 <wadcom> ah, right!
00:17:14 <haskelln00b> bye haskell people.. i cant help you'll yet cause i dont know enough
00:17:20 <haskelln00b> but one day!!
00:17:26 <Cale> :)
00:17:29 <haskelln00b> :gnight
00:18:00 <Cale> @yow
00:18:01 <lambdabot> So this is what it feels like to be potato salad
00:18:04 <Cale> @yow
00:18:04 <lambdabot> Uh-oh!!  I forgot to submit to COMPULSORY URINALYSIS!
00:18:55 <Twey> Hew
00:18:57 <Twey> Heh**
00:19:08 <Twey> We have a nutty-quote function now?  :-P
00:21:11 <mauke> "now"?
00:21:49 <nornagon> kfish: yo
00:22:47 <kfish> heya nornagon
00:23:00 <kfish> i'm at the continuation fest
00:23:01 <kfish> oleg is here
00:23:03 <kfish> my brain hurts
00:23:04 <nornagon> oh neat
00:23:06 <nornagon> haha
00:23:15 <nornagon> damn, i wish i could be there :)
00:23:27 <kfish> right in central akihabara :-)
00:23:55 <nornagon> :D
00:23:56 <__pao__> how to I define (a->b) as an instance of function?
00:25:09 <__pao__> how do I define (a->b) as instance of Functor... sorry for the mispell
00:25:44 <adiM> If I try to declare a 6 dimensional array, I get  No instance for (Ix (t, t, t, t, t, t))
00:25:44 <adiM>  Possible fix:
00:25:44 <adiM>       add an instance declaration for (Ix (t, t, t, t, t, t))
00:25:44 <adiM> How do I do that?
00:26:44 <mauke> __pao__: don't you mean ((->) a)?
00:27:01 <__pao__> mauke: probably :-)
00:27:35 <bd_> adiM: You'll need to implement a conversion to linear coordinates by implementing Ix: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Ix.html
00:27:36 <lambdabot> http://tinyurl.com/5kmf2w
00:27:40 <mauke> there is one in Control.Monad.Instances
00:27:56 <mauke> can't you use nested tuples?
00:28:19 <__pao__> > 1 +1
00:28:19 <lambdabot>  2
00:28:28 <__pao__> mauke: perfect
00:28:57 <__pao__> mauke: is (->) notation valid only inside instance declarations?
00:29:13 <mauke> > (id :: (->) a a) 42
00:29:13 <lambdabot>  42
00:29:44 <Cale> __pao__: Wouldn't that be kind of silly? :)
00:30:10 <__pao__> Cale: just an exercise...
00:30:31 <Cale> __pao__: It's just like at the value level, if you wrap an infix function in parens it becomes prefix. The same thing happens at the type level :)
00:30:59 <Cale> (Just you don't see all that many infix type constructors)
00:31:01 <__pao__> Cale: perfect
00:31:29 <__pao__> Cale: you are the cause of my exercise :-)
00:31:31 <adiM> bd_ where can I find the implementation of 5 dimensional Ix?
00:31:33 <Cale> The type constructors with special notation also have prefix forms
00:31:45 <__pao__> Cale: I've been told you aliased (.) to fmap in lambdabot :-)
00:31:46 <adiM> The link does not contain any implementaition :(
00:31:51 <Cale> :t (5, "hello") :: (,) Integer String
00:31:53 <lambdabot> (Integer, String)
00:31:56 <Cale> __pao__: yep :)
00:32:11 <Cale> :t (,) 5 "hello" :: (,) Integer String
00:32:12 <lambdabot> (Integer, String)
00:32:27 <__pao__> Cale: got it
00:32:36 <__pao__> Cale: why did you do that?
00:32:58 <Cale> :t map :: (->) ((->) a b) ((->) ([] a) ([] b))
00:32:58 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
00:33:09 <Cale> Just showing the prefix forms of some type constructors :)
00:34:03 <bd_> adiM: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Arr.html
00:34:04 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2lr2q9
00:34:26 <hpaste>  __pao__ pasted "(no title)" at http://hpaste.org/6956
00:34:42 <bd_> adiM: note that unsafe* is GHC-specific
00:35:13 <__pao__> Cale: http://hpaste.org/6956
00:35:39 <Cale> __pao__: oh, why did I define (.) to be fmap?
00:35:48 <adiM> bd_ Thanks :)
00:35:54 <__pao__> Cale: that is it? right?
00:36:19 <Cale> __pao__: basically -- you have to hide the version from the prelude, and really there should be a fixity declaration too, but yeah
00:36:32 <Cale> infixr 9 .
00:36:54 <__pao__> Cale: how do you hide prelude definition?
00:37:03 <Cale> import Prelude hiding ((.))
00:37:29 <Cale> Oh, also, if you write it that way, you have to be careful about the MR
00:37:56 <Cale> f . g = fmap f g -- will work nicer with the MR
00:37:56 <Cale> (or just give an explicit type decl)
00:38:31 <Cale> Oh, hehe, you'll want to use the Prelude version of (.) to define the instance there.
00:38:43 <Cale> I just imported the appropriate instance from Control.Monad.Instances
00:38:54 <Cale> (you just import that module, and you get them all)
00:46:53 <__pao__> cale: it will the whole day to decipher your indications ;-)
00:47:09 <__pao__> Cale: got to prepare breakfast for children now :-)
00:47:12 <Cale> hehe
00:47:15 <Cale> all right
00:47:15 <Twey> MR = Monomorphism Restriction, I presume
00:47:18 <Twey> ?
00:47:20 <Cale> yes
00:48:33 <__pao__> Cale: hmmm... already deciphered....
00:48:51 * __pao__ has benn promoted from uber newbie to simple newbie
00:49:01 <Twey> Hehe
00:49:06 <Cale> hehe :)
00:49:09 <Cale> I should sleep :)
00:49:22 <__pao__> Cale: thanks and good night :-)
00:49:25 <__pao__> bye everyone
00:49:39 <Twey> 'night __pao__
01:10:12 <mauke> is there an elegant way to derive an infinite list of nicknames from a "seed"?
01:13:30 <solrize_> nicknames?  like by pasting syllables together?
01:17:01 <mauke> I think I've found a solution :-)
01:31:21 <dons> mauke: and nice randomRs ?
01:31:27 <dons> instance Random Nick
01:32:35 <mauke> no, I want a recognizable progression of nicks
01:33:02 <mauke> like "foo" -> "foo_", only unlimited
01:33:14 <solrize_> foo1, foo2, foo3...
01:34:18 <solrize_> > take 5 $ ["foo"++(show n)|n<-[1..]]
01:34:21 <lambdabot>  ["foo1","foo2","foo3","foo4","foo5"]
01:35:56 <nornagon> > take 5 $ ["foo" ++ replicate n "_" | n <- [0..]
01:35:56 <lambdabot>  Parse error at end of input
01:35:58 <nornagon> > take 5 $ ["foo" ++ replicate n "_" | n <- [0..]]
01:35:58 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
01:36:00 <mauke> wait, why does the IRC RFC say _ is not valid in nicknames?
01:36:08 <nornagon> aw.
01:37:17 <ari> mauke: Draw a Hilbert curve through the space of valid nicknames and follow that :)
01:37:35 <nornagon> @quote fluxbox
01:37:35 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
01:37:42 <nornagon> @help quote
01:37:42 <lambdabot> quote <nick>
01:37:42 <lambdabot> remember <nick> <quote>
01:37:42 <lambdabot> Quote somebody, a random person, or save a memorable quote
01:41:01 <nornagon> Oh. Quote database destroyed? :(
01:41:19 <solrize_> > let f cset n = let (a,b)=divMod n (length cset) in (if a>0 then f cset a else []) ++ (cset!!b) in take 10 ["foo"++f "_`-" n|n<-[1..]]
01:41:19 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
01:41:24 <nornagon> @quote quote
01:41:24 <lambdabot> jfredett says: i would @remember that, but when someone @quotes olsner, it'd be nsfw on the normal channel... :/
01:41:53 <solrize_> > let f cset n = let (a,b)=divMod n (length cset) in (if a>0 then f cset a else []) ++ [(cset!!b)] in take 10 ["foo"++f "_`-" n|n<-[1..]]
01:41:55 <lambdabot>  ["foo`","foo-","foo`_","foo``","foo`-","foo-_","foo-`","foo--","foo`__","foo...
01:42:50 <grom358> ghci doesn't let you define functions??
01:42:59 <nornagon> what happened to foo_, solrize_?
01:43:09 <nornagon> grom358: > let f x y = x + y
01:43:14 <solrize_> > let f cset n = let (a,b)=divMod n (length cset) in (if a>0 then f cset a else []) ++ [(cset!!b)] in take 10 ["foo"++f "_`-" n|n<-[0..]]
01:43:15 <lambdabot>  ["foo_","foo`","foo-","foo`_","foo``","foo`-","foo-_","foo-`","foo--","foo`__"]
01:44:02 <mauke> solrize_: that hits the size limit pretty fast
01:44:02 <grom358> ah
01:44:38 <solrize_> size limit?  i mean how can you do better than O(log n) ?  the base of the log depends on how many suffix characters you can pick
01:45:08 <solrize_> > let f cset n = let (a,b)=divMod n (length cset) in (if a>0 then f cset a else []) ++ [(cset!!b)] in take 30 ["foo"++f "_`-" n|n<-[0..]]
01:45:08 <mauke> there's a 9 char size limit on nicks
01:45:09 <lambdabot>  ["foo_","foo`","foo-","foo`_","foo``","foo`-","foo-_","foo-`","foo--","foo`_...
01:45:21 <nornagon> mauke: add more characters to the cset
01:45:30 <solrize_> > 3**6
01:45:31 <lambdabot>  729.0
01:45:40 <solrize_> so that will give you 729 nicks
01:45:48 <mauke> only if the base nick is small enough
01:45:54 <solrize_> i dunno what other cset chars are valid
01:46:06 <nornagon> ['1'..'9'], perhaps.
01:46:09 <solrize_> otherwise you can start using letters
01:46:12 <nornagon> |
01:46:14 <mauke> take something like "lambdabot"
01:46:23 <solrize_> what was wrong with foo1,foo2,...?
01:46:29 <solrize_> lambdabot is stuck already
01:46:38 <solrize_> wait arjanoosting is > 9
01:46:45 <nornagon> ah, so you need to be able to chop chars off the end
01:46:56 <solrize_> there are several longer nicks here
01:47:03 <abcdefghijklmnop> max length nickname.
01:47:14 <solrize_> 15
01:47:17 <mauke> yeah, freenode allows longer nicks, but I can't rely on that
01:47:42 <nornagon> so when you hit the max length, start chopping characters off the end of the nick
01:52:33 <mauke> take 20 . iterate next . f $ "solrize"
01:52:35 <mauke> ["solrize","solrize_","solriz_e","solri_ze","solr_ize","sol_rize","so_lrize","s_olrize","solrizf","solrizf_","solriz_f","solri_zf","solr_izf","sol_rizf","so_lrizf","s_olrizf","solrizg","solrizg_","solriz_g","solri_zg"]
01:52:56 <nornagon> :t next
01:52:57 <lambdabot> forall g. (RandomGen g) => g -> (Int, g)
01:53:06 <mauke> next :: S.ByteString -> S.ByteString
01:53:22 <solrize_> :t f
01:53:23 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
01:53:31 <mauke> f :: String -> S.ByteString
01:57:28 <dons> hack hack hack!
01:57:35 <solrize_> what u hacking?
01:58:32 <dolio> I think the hackathon should work at cranking out some new lambda cats images.
01:59:09 <dons> heh
01:59:17 <dons> solrize_: hackathon. i'm working on bytestring stuff.
01:59:25 <dons> i'll get people to update the wiki with all the things being worked on
01:59:25 <solrize_> cool
01:59:32 <solrize_> that will be great
01:59:52 <mauke> oh yes. I'd like to file a bytestring complaint
02:00:12 <solrize_> it almost seems possible to take a java or python manual and reimplmeent all those library functions in a hackathon.  i keep missing them
02:00:25 <mauke> Warning: Deprecated use of `findSubstring'
02:00:28 <mauke>  Do not use. The ByteString searching api is about to be replaced.
02:00:33 <mauke> WHAT THE HELL
02:03:26 <dons> mauke: ?
02:03:32 <dons> something unclear about that ?
02:03:41 <mauke> why does it exist?
02:03:44 <dons> actually, i just pushed yesterday a patch to undprecate findSubstring
02:03:46 <mauke> the warning, I mean
02:03:49 <dons> its findSubstrings that we're going to remove
02:04:19 <solrize_> dons how about adding a way to configure the chunk size, 64k is way too small
02:04:41 <dons> solrize_: how do you know it is too small?
02:04:45 <mauke> I need this functionality now. There's still enough time to deprecate parts of the API when you have a replacement.
02:04:55 <dons> mauke: so use it :)
02:04:59 <dons> its just a warning
02:05:13 <mauke> I like warning-free builds
02:05:37 <solrize_> dons just from arithmetic, if i'm jumping between a bunch of disk files that transfer at 20 MB/sec and the seek latency is 8 msec, each seek takes as long as 160k bytes transferred
02:05:56 <dons> ok, so we actually measured this :)
02:06:01 <solrize_> oh cool
02:06:07 <dons> the number's not 64k , actually, and its more todo with the cache size
02:06:09 <dons> than anything else
02:06:13 <Igloo2> Your disk does clever readahead etc
02:06:15 <dons> not IO transfer sizes
02:06:35 <solrize_> i thought i saw someplace that it was 64k
02:07:28 <solrize_> but anyways the issue is the readahead not helping if many files are active simultaneously
02:08:40 <solrize_> i had a long chat with cale and quicksilver about this and next step was to do some experiments which i've been too swamped to do
02:08:51 <solrize_> but i'm a little less swamped now
02:09:28 <solrize_> baughn was also involved, forgot to say
02:11:50 <solrize_> i wonder if there's a way to use the XMM cache prefetch instructions while getting chars lazily from a chunk
02:24:32 <__pao___> in daume II tutorial there an unwritten chap: 8.7 Class Hierarchies...
02:24:49 <__pao___> does anyone have an idea on the topic?
02:25:14 <__pao___> I suspect it was meant to be an overview of prelude class hierarchy
02:36:01 <solrize_> wow, i'm looking at a slide show about the amd barcelona processor, and it has a hw prefetcher that does a lot of predictive fetching
02:44:41 <oldsalt> @seen shag
02:44:42 <lambdabot> I saw shag leaving #gentoo-haskell and #haskell 22h 1m 3s ago, and .
03:30:56 <Sadache> What editor for haskell you guys usually use?
03:31:42 * ziman uses gvim/vim
03:32:31 <__pao___> Sadache: vim as well
03:32:35 <hpaste>  paolino pasted "occurs check error" at http://hpaste.org/6957
03:33:03 <Heffalump> yi is looking very promising
03:33:30 <paolino> any good soul can dig this error out for me, please
03:33:39 <__pao___> paolino: nice to get another italian on #haskell :-)
03:34:01 <paolino> we have other 2 on #haskell.it
03:35:09 <__pao___> paolino: I'll join
03:36:15 <Sadache> so no ides right?
03:36:47 <Sadache> IDEs
03:36:53 <paolino> there is visual whatever for microsoft sistem
03:37:06 <ivanm> Sadache: some IDEs have some haskell support... visual studio, eclipse, etc.
03:37:14 <ivanm> then there's all the dead haskell proto-IDEs
03:37:38 <ivanm> Sadache: and of course emacs is almost an IDE... ;-)
03:37:42 <Sadache> ok, but they are not widely used right?
03:37:43 <Heffalump> yi is being actively worked on at the hackathon
03:37:51 <Sadache> yeah emacs
03:37:56 <Heffalump> not widely used yet, but it looks really good so far
03:38:10 <Sadache> i ll try yi
03:38:28 <Heffalump> might want to wait a bit until all the recent work actually gets released :-)
03:38:37 <ivanm> Heffalump: problem with yi will probably end up being the fact that you're using a seperate editor just for haskell stuff.... which IMHO would get annoying :s
03:38:49 <Heffalump> yeah, true.
03:39:09 <dolio> Just start using Haskell for everything.
03:39:13 <dolio> Problem solved. :)
03:39:16 <pejo> ivanm, isn't that what DrScheme does, and users have adopted?
03:39:20 <ivanm> dolio: even say latex? :p
03:39:25 <pejo> adapted, duh.
03:39:35 <ivanm> pejo: I thought DrScheme was primarily for teaching purposes...
03:39:57 <ivanm> and AFAIK a lot of lisp/scheme people use either guile or SLiME
04:01:04 <mauke> yay, I've got an IRC bot
04:01:14 <mauke> it does absolutely nothing but it can connect and stay connected
04:01:40 <TSC> Like many human IRC participants
04:01:54 * ukl = bot.
04:02:21 * qwr . o O ( YetAnotherHaskellBot? )
04:03:06 <ukl> What's IRC if not a Turing test?
04:03:12 <mauke> is it possible that the haskell wiki search is broken?
04:03:14 <qwr> btw, i could give irc library for future haskell irc bot writers ;)
04:03:28 <ivanm> mauke: wasn't it always broken?
04:03:33 <qwr> (http://linux.ee/~mzz/hirc/)
04:03:34 <lambdabot> Title: Index of /~mzz/hirc
04:04:05 <ilyak_> Hi *.
04:04:21 <moozilla> hi
04:05:20 <kpreid> @. read run 'h' : 'i' : []
04:05:23 <lambdabot>  hi
04:06:13 <ilyak_> Is there a way to say "a list of any data which are instances of Node class"?
04:06:32 <ilyak_> [Node] complains about a wrong type kind
04:06:42 <mauke> qwr: looks like you're using an IORef for inter-thread communication
04:07:07 <mauke> ilyak_: you need existential types for that
04:07:11 <Twey> @type run
04:07:12 <lambdabot> Not in scope: `run'
04:07:20 <qwr> mauke: yes, i wondered by myself how unsafe it exactly is
04:07:59 <ilyak_> mauke: Oh I'll try
04:09:18 <qwr> mauke: it has obvious problem with potential race, but in practice it shouldn't happen since the pinging there shouldn't happen more often than once in minute
04:10:50 <heisenbug> someone might like this: http://heisenbug.blogspot.com/2008/04/llvm-data-structures-and-putting-use-on.html
04:10:51 <lambdabot> Title: don't count on finding me: LLVM Data Structures, and Putting Use on Diet, http://tinyurl.com/5hy6w3
04:13:38 <mauke> qwr: what does it do if the requested nickname is in use?
04:14:22 <qwr> mauke: automatically changing nick is currently not implemented
04:15:02 <qwr> mauke: although it should be easy to add
04:15:57 * qwr just haven't had nick conflict when running this bot yet...
04:16:14 <Heffalump> I'm making a package for restricted monads. Is rmonad a reasonable name for this?
04:16:43 * resiak .oO('monadr' would be more web 2.0)
04:27:50 <hpaste>  ilyak pasted "Why >> complains about b rigidity?" at http://hpaste.org/6959
04:28:00 <ilyak_> Please help me with this snipped
04:28:16 <ilyak_> I don't understand why (acc f ++ cur s) doesn't work.
04:28:42 <ilyak_> Because acc f is NodeI, cur s is a list of nodes and it should resolve to NodeI
04:28:46 <mauke> what's the error message?
04:29:08 <ilyak_> Couldn't match expected type `NodeI' against inferred type `b' (a rigid variable) `b' is bound by the type signature for `>>' at <no location info>
04:29:41 <ilyak_> b is guaranted to be Node, because it's Node a => NodeCollector a
04:29:59 <kpreid> ilyak_: I suggest not defining >>, just >>=
04:30:07 <kpreid> ilyak_: defining >> is just an optimization
04:30:18 <ilyak_> kpreid: I need >> and  >>= to do different things
04:30:24 <kpreid> then it isn't a monad.
04:30:29 <kpreid> and you shouldn't use Monad.
04:31:25 <ilyak_> Why?
04:31:37 <kpreid> because it doesn't obey the monad laws.
04:31:46 <ilyak_> Which one?
04:31:59 <syntaks> it would cause a rift in space-time continuum ;)
04:32:02 <Twey> Heh
04:32:03 <kpreid> hm, point.
04:32:28 <ilyak_> I see three monad laws in my book
04:32:36 <ilyak_> I don't see how it doesn't obey
04:32:43 <stevan> hi, i have a question regarding keeping state in ghci which i explained here: http://hpaste.org/6960
04:32:49 <Twey> ilyak_: (>>) = (>>= id) if I remember correctly
04:32:58 <kpreid> ilyak_: I admit I don't see where it's defined
04:33:04 <ilyak_> Twey: Where can I read about it?
04:33:07 <Twey> Hm
04:33:13 <qwr> ilyak_: i understand that as f in f >> s is guaranteed to be Monad anything by Monad typeclass?
04:33:14 <Twey> ilyak_: That's the big question, isn't it :-P
04:33:19 <kpreid> ilyak_: however, I am certain that it is improper to give a definition of >> that is not equivalent to >>= \_ ->
04:33:30 <mauke> ilyak_: Node is not a type
04:33:36 <ilyak_> qwr: yes
04:34:07 <mauke> acc f :: [NodeI]; cur s :: [b]
04:34:11 <mauke> you can't just ++ them
04:34:12 <ilyak_> But a in NodeList a is guaranted to be Node
04:34:20 <mauke> no
04:34:26 <ilyak_> mauke: Why?
04:34:28 <olsner> a >> b = a >>= const b
04:34:31 <mauke> also, irrelevant
04:35:04 <qwr> ilyak_: but you add additional restriction to f's type by expecting it to contain list
04:35:05 <mauke> ilyak_: because you can't restrict the contents of polymorphic types
04:35:41 <ilyak_> qwr: Well, NodeCollector holds two lists
04:35:51 <mauke> but even if you could, NodeI and (Node b) => b are still different types
04:36:08 <olsner> hmm, I wonder how a desugaring of section syntax would look to be sugary enough to define (>>) by writing (>> b) = (>>= const b)
04:36:11 <ilyak_> mauke: Well, (Node b) => b is NodeI isn't it?
04:36:15 <qwr> ilyak_: with that restriction it can't be anything, which contradicts the Monad typeclass. (correct me if i'm wrong...)
04:36:17 <mauke> ilyak_: no
04:36:27 <ilyak_> mauke: Why?
04:36:37 <mauke> ilyak_: why would it?
04:36:51 <ilyak_> mauke: Because NodeI is Node anything?
04:36:58 <ilyak_> As far as I understood it
04:36:59 <mauke> no, NodeI is a specific type
04:37:14 <olsner> ilyak_: the NodeI type has one constructor called NodeI which takes a (Node b => b) and produces a value of type NodeI
04:37:41 <mauke> actually, it doesn't take a Node b => b :-)
04:37:51 <mauke> NodeI :: (Node b) => (b -> NodeI)
04:38:21 <ilyak_> How would I make such type that if I have a list of that I can add any Nodes to it?
04:38:25 <ilyak_> Is it possible at all?
04:38:30 * olsner doesn't understand the difference between that and what he said :P
04:39:14 <mauke> olsner: you said NodeI :: (Node b => b) -> NodeI
04:39:31 <mauke> ilyak_: no, all list elements must have the same type
04:40:12 <ilyak_> mauke: I thought forall is a keyword made especially to make lists of different types which have something in common
04:40:17 <ilyak_> And the like
04:40:32 <mauke> if you want to write your own list type, yes
04:40:48 <mauke> but if you want to use standard lists, you need to use an existential wrapper
04:41:12 <ilyak_> mauke: how would such my own list would look like?
04:41:40 <mauke> wrong question!
04:41:52 <mauke> the right question is: "how do I use such an existential wrapper?"
04:42:06 <mauke> the answer is: (acc f ++ map NodeI (cur s))
04:42:38 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6961
04:44:30 <ilyak_> mauke: how would I write the NodeI definition?
04:44:39 <ilyak_> I guess I didn't figure it out in full
04:44:52 <mauke> data NodeI = forall a. Node a => NodeI a
04:45:44 <ilyak_> Ok, I did something which resembles that
04:45:54 <mauke> you did exactly that
04:46:10 <ilyak_> And yes, now it complains that it couldn't deduce Node a from a in >> parameter
04:46:44 <mauke> yes. the current Monad definition doesn't allow restricted instances
04:47:07 <hpaste>  paolino annotated "occurs check error" with "disconnection calculator" at http://hpaste.org/6957#a1
04:47:10 <ilyak_> Why? I guess there is no way to make such NodeCollector a where a wouldn't be Node?
04:47:21 <ilyak_> Why can't it assume a is a Node then?
04:47:31 <mauke> ilyak_: undefined :: NodeCollector Bool
04:48:14 <ilyak_> mauke: ? I can't say that I do understand you
04:49:01 <mauke> that's a value of type NodeCollector Bool, and Bool is not an instance of Node
04:49:36 <ilyak_> I don't understand
04:49:44 <ilyak_> given data Node a => NodeCollector a
04:50:24 <Saizan_> ilyak_: that Node a => doesn't give you the context when unpacking a NodeCollector, but you can fix that with gadts
04:50:41 <Saizan_> ilyak_: the real problem is in return
04:50:57 <mauke> ilyak_: all that does is gve NodeCollector the type :: (Node a) => [a] -> [NodeI] -> NodeCollector a
04:51:11 <mauke> i.e. the Node restriction only applies to values constructed with NodeCollector
04:51:20 <Saizan_> ilyak_: return :: a -> NodeCollector a, but you can't use that implementation because you can't know if a instances Node
04:52:51 <ilyak_> Well, return is a -> m a. I tought that implies that a should be Node
04:53:05 <Saizan_> no, why?
04:53:21 <ilyak_> Saizan_: Because you can't do NodeCollector a if a isn't Node
04:53:40 <Saizan_> ilyak_: but return is just given an 'a'
04:54:14 <Saizan_> ilyak_: it's return responsibility to build a (NodeCollector a) for any 'a' you'd give to it
04:54:38 <mauke> ilyak_: yes, you can
04:54:54 <mauke> you can build a value of type NodeCollector a for any a by using undefined
04:55:02 <mauke> (or anything that's bottom)
04:55:30 <Saizan_> that's not relevant anyway
04:56:20 <mauke> yeah, there are at least two issues: '(Node a) =>' doesn't do what you think it does, and NodeCollector isn't a Monad
04:58:12 <ilyak_> I don't understand how would I do what I want given all that.
04:58:42 <Saizan_> ilyak_: you can't, you have to use a different definition of the Monad class
04:59:03 <Saizan_> and you make (Node a) => do what you think it does if you write data NodeCollector a where NodeCollector :: Node a => [a] -> [NodeI] -> NodeCollector a
04:59:36 <ilyak_> Saizan_: I'll think about that
05:00:34 <Saizan_> ilyak_: look here for the problem i was getting at with return (and also >>=) http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros
05:00:34 <lambdabot> Title: How to make Data.Set a monad, http://tinyurl.com/22rhsc
05:00:46 <Saizan_> or in general look for "restricted monad"
05:00:49 <Heffalump> anyone know how to document constructors in a GADT with haddock 2.0
05:00:49 <Heffalump> ?
05:01:06 * Heffalump is about to upload a package to hackage to do restricted monads, btw
05:01:22 <Heffalump> but using a ghc 6.8 feature
05:01:52 <ilyak_> Saizan_: Wow
05:01:59 <ilyak_> I see a lot of black magic there
05:02:22 <ilyak_> I wonder if future haskell revisions would eliminate that black magic
05:03:51 <Saizan_> ilyak_: if you don't care for do-notation there's no black magic
05:05:37 <ilyak_> I care about semantics. do-notation and monads are for imperative sublanguages, I want one, I should be able to make one
05:07:58 <Saizan> to get what you want you need MultiParameterTypeClasses or other extensions (class families, not even implemented), while Monad is haskell98. Also the Monad class as written ensures naturality of the methods by parametricity
05:08:30 <Saizan> i.e. you can't make a monad that works differently on some types
05:09:03 <ilyak_> I need it to work on some types because it's only applicable to them
05:11:08 <kpreid> if Monad permitted that then operators like, say, sequence and mapM, wouldn't be applicable to all monads
05:11:32 <kpreid> because they use specific result types
05:11:34 <kpreid> @type sequence
05:11:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:11:38 <kpreid> m [a]
05:12:16 <Saizan> well the context would become (Monad m a, Monad m [a]) => or similar
05:12:32 <Heffalump> Saizan: you can get "class" families by wrapping stuff up in an associated datatype
05:14:03 <Saizan> Heffalump: and use it as a witness?
05:14:52 <Heffalump> Saizan: right
05:22:23 <dons> hackathon photos, http://blog.well-typed.com/2008/04/hac4-last-day/dsc_1824/
05:22:24 <lambdabot> Title: blog.well-typed.com » Blog Archive » dsc_1824
05:50:40 <DRMacIver> Hm. Who do I talk to about planet haskell?
05:51:12 <DRMacIver> Ah, there's an email address on the site.
06:07:33 <mauke> @src MonadPlus STM
06:07:33 <lambdabot> Source not found. :(
06:13:36 <dancor> it seems like i have to 'foreign export ccall' a dummy function in every pure-hs file that is imported by my main file that exports a function to c
06:13:49 <dancor> is that right or am i just doingitwrong
06:17:56 <ilyak_> Do I understand correctly that Parsec avoids the fact that one can't use a or b in >> because their types are unknown by never using them
06:18:19 <ilyak_> Maybe I should go the same route?
06:32:26 <ilyak_> Having a type parameter is a zen-like practice
06:32:30 <ilyak_> Like one-hand clapping
06:32:42 <ilyak_> I don't think I could figure it out by myself
06:35:13 <ilyak_> I mean, having totally unused tpye parameter
06:40:41 <Heffalump> phantom types, you mean?
06:40:59 <ilyak_> Heffalump: I don't understand such smart words.
06:41:30 <ilyak_> But, Parsec carries st type parameter around which it never use as far as I understand.
06:41:47 <ilyak_> But, now I can't fugure out how to make >>= work
06:41:50 <Heffalump> I think it's optional, if you want a stateful parser.
06:42:10 <ilyak_> Heffalump: Well, maybe, but in my case this thing isn't going to have state
06:42:16 <Heffalump> right, so you just use ()
06:42:31 <ilyak_> Yeah, something like that.
06:42:39 <Heffalump> just a standard parametrisation mechanism
06:42:46 <ilyak_> I'm still struggling to make >>= work, tho
06:43:15 <DRMacIver> dons: Which reminds me of another example of where higher order modules would be useful. :) Parsec parsers are basically parameterized over a record type in a way that's clearly designed to emulate higher order modules. Even the documentation says "Each function of this record is separately described as if it was a toplevel function".
06:44:04 <kpreid> DRMacIver: ISTR the documentation even says "This would be a higher-order module if they existed"
06:44:12 <DRMacIver> Ah. I hadn't read that bit.
06:44:18 <DRMacIver> Or if I had I'd forgotten it
06:44:31 <DRMacIver> Ah yes, so it does.
06:44:46 <DRMacIver> "The extension library ParsecToken uses the forall keyword (to emulate a first-class module)"
06:45:08 <luntain> what is the rationale to have show and read? It would make more sense to have toStr and parse!
06:45:30 <ilyak_> Wow, it did build
06:45:33 <ilyak_> That's weird
06:45:57 <resiak> luntain: surely "stringify foo" sounds better than "toStr foo"
06:45:59 <ilyak_> It was so simple after I've got that "Q: I can't use a or b! A: You're not supposed to."
06:46:27 <luntain> resiak: yes, but why show?
06:46:42 <resiak> Why not, I guess.
06:46:53 <ilyak_> I wonder why nobody pointed to me that I don't need them.
06:47:08 <luntain> resiak: I would expect it to print sth on the screen
06:47:33 <byorgey> oooh, RMonad!
06:47:33 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
06:47:37 <byorgey> Heffalump++
06:49:54 <Heffalump> this solution seems simple enough that it's actually worth standardising around (or trying to)
06:50:24 <byorgey> I haven't looked at the code yet, but the interface seems simple enough
06:50:30 <Heffalump> though the 6.8 restriction is one issu
06:50:48 <byorgey> that's not that big of a deal, IMO
06:50:57 <Heffalump> yeah, I think it's livable with
06:51:12 <byorgey> most people who really want restricted monads probably already have 6.8 anyway (or would be willing to upgrade)
06:51:14 <Heffalump> and it's way less messy than the usual tricks with split MPTCs
06:51:18 <byorgey> yup
06:51:53 <byorgey> Heffalump: if I do NoImplicitPrelude and import RMonad, do "normal" monads still work?
06:52:02 <Heffalump> not for do notation, no
06:52:04 <Heffalump> you have to choose
06:52:09 <Heffalump> well, on a per-module basis
06:52:15 <byorgey> ok, fair enough
06:52:37 <Heffalump> I need to add all the standard monad combinators for RMonad
06:57:12 <ilyak_> how is this function called which is [Maybe a] -> [a]?
06:57:19 <resiak> @ty catMaybes
06:57:20 <lambdabot> forall a. [Maybe a] -> [a]
06:58:04 <ilyak_> Which module is that?
06:58:24 <byorgey> Data.Maybe
06:58:34 <byorgey> @index catMaybes
06:58:34 <lambdabot> Data.Maybe
06:59:30 <ilyak_> Thanx, already googled
07:03:18 <ilyak_> Wow! It works
07:03:36 <ilyak_> I'm happy, looking forward to build compiling xslt
07:05:31 <byorgey> =D
07:05:33 <ilyak_> Also, parameters work
07:05:48 <ilyak_> But that NodeI thing is ugly
07:05:56 <ilyak_> I'll paste
07:06:49 <hpaste>  ilyak pasted "How to get rid of NodeI?" at http://hpaste.org/6962
07:07:18 <ilyak_> Is there a way to get rid of NodeI?
07:07:33 <ilyak_> I.e. I have to pack into NodeI in text function
07:07:44 <ilyak_> And unpack it using lambda in map
07:07:57 <ilyak_> I would like to somehow drop these unnecesary steps
07:08:20 <ilyak_> They are unnecessary in the sence they  tell nothing about computation
07:12:46 <ilyak_> How
07:12:59 <ilyak_> Sorry, wrong window :)
07:15:22 <fophillips> Can I tell ghci to just print the output from a function, rather than all the version info etc.? Like `irb --noprompt`
07:16:40 <byorgey> fophillips: you can use ghc -e, is that what you want?
07:16:43 <kpreid> fophillips: if you just want to do one thing, try ghc -e
07:17:37 <fophillips> Thanks.
07:18:38 <byorgey> ilyak_: no, you can't get rid of the NodeI, not if you want to be able to deal with different types of Node
07:19:02 <byorgey> ilyak_: lists must be homogeneous
07:21:39 <ilyak_> byorgey: That's pity
07:23:56 <ilyak_> Because it's really the case of "Is there some computation happening in there somewhere?" (c)
07:24:23 <kpreid> ilyak_: the NodeI constructor actually corresponds to an effect: bundling the value together with the typeclass 'dictionary' of operations on it
07:24:35 <kpreid> ilyak_: so it is an allocation, and so on
07:24:39 <ilyak_> :)
07:29:08 <ilyak_> I still think it should be somehow hidden
07:32:47 <ilyak_> http://xkcd.com/349/ - trying to change correct haskell code is all like that
07:32:47 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
07:36:48 <ilyak_> I get No instance for (Eq Element) arising from the superclasses of an instance declaration
07:37:07 <ilyak_> The weird thing that the line in question is instance Node Element where
07:37:09 <Beelsebob> ilyak_: you're probably giving it for example Ord Element
07:37:32 <ilyak_> Oh really
07:37:34 <Beelsebob> well, Node Element requires you to have an instance of Eq Element first
07:37:38 <ilyak_> I forgot an ord there
07:37:42 <ilyak_> eq, I mean
07:38:01 <ilyak_> I wonder if Node should support Eq
07:38:18 <ilyak_> You can compare texts but don't want to compare elements
07:38:23 <ilyak_> It would get you nowhere
07:38:24 <Beelsebob> well, is equatability necessary for nodyness
07:38:33 <ilyak_> I guess, no
07:38:44 <fxr> How can I declare a domain D of binary digits, say D ::= 1 | 0
07:38:46 <Beelsebob> then probably you don't want class Eq a => Node a
07:39:10 <Beelsebob> fxr: defining a type as a subset of the values of another type is not possible
07:39:22 <Beelsebob> you would have to define something like data Bit = One | Zero
07:39:34 <resiak> type Bit = Boolean -- :-)
07:39:41 <fxr> like that?
07:39:43 <fxr> data D = D0 | D1
07:39:48 <Beelsebob> that would work
07:39:55 <Beelsebob> if you want D0 and D1 to be your constuctors
07:39:56 <fxr> ok next question
07:40:17 <fxr> how can I declare B of binary numerals such that B ::= BD | D
07:40:55 <Beelsebob> data Binary = Binary :^: Digit | Digit
07:41:00 <Beelsebob> fail
07:41:01 <Beelsebob> no
07:41:16 <Beelsebob> data Binary = Comb Binary Digit | End Digit
07:41:21 <Beelsebob> give each a tag
07:41:24 <Beelsebob> and say what it's components are
07:41:42 <Beelsebob> of course a better representation for this might be type Binary = [Bit]
07:41:44 <fxr> I don't know how to declare sum of types, is that like your example?
07:42:00 <vincenz> Beelsebob: Comb :)
07:42:03 <vincenz> Beelsebob: Why not Brush
07:42:18 <Beelsebob> hehe, Combination it was meant to mean
07:42:26 <Beelsebob> I couldn't think of appropriate tags fast
07:42:52 <fxr> any other view?
07:43:03 <Beelsebob> fxr: luckily, we already have the list type
07:43:19 <Beelsebob> which is data [a] = a:[a] | []
07:43:44 <Beelsebob> so [Bit] is probably your best representation for (possibly) infinite lists of bits to make up binary numbers
07:43:53 <Beelsebob> if you want to define instances, then you'll need a newtype instead of type
07:44:03 <Beelsebob> so newtype Binary = B [Bit]
07:44:49 <fxr> so how do you define Bit?
07:44:59 <Beelsebob> data Bit = Zero | One
07:45:01 <Beelsebob> as defore
07:45:05 <Beelsebob> before*
07:45:51 <fxr> well so we're implementing B::= BD | D as a list
07:45:58 <Beelsebob> indeed
07:46:10 <Beelsebob> we already have the pattern of lots of homogenous things stuck together with the [a] type
07:46:13 <Beelsebob> so just use it
07:46:39 <fxr> I'm not writing a program, I'm just exercising denotational semantics with haskell
07:46:39 <Beelsebob> incidentally... purely english thing... Digit means part of a base 10 number
07:46:53 <Beelsebob> Bit means part of a base 2 number
07:48:55 <ilyak_> Another thing.
07:49:44 <allbery_b> "binary digit" is perfectly acceptable, notwithstanding the origin of that use of "digit"
07:49:54 <Beelsebob> allbery_b: true
07:49:57 <dancor> Main.hs has a "foreign export ccall" and import's ByteString.  when i link i get undefined reference to `__stginit_bytestringzm0zi9zi0zi1_DataziByteString_'
07:49:58 <Beelsebob> but digit is misleading
07:49:59 <ilyak_> Attribute is defined as (String, String) and is instance of NodeI
07:50:05 <fxr> well so how to make an instance of B with a D?
07:50:13 <fxr> given those
07:50:19 <fxr> data D = Zero | One
07:50:19 <fxr> data B a = B [D]
07:50:20 <ilyak_> I try to  attribute :: String -> String -> NodeCollector () ; attribute = el . (curry NodeI)
07:50:21 <allbery_b> dancor:  ghc --make
07:50:30 <allbery_b> (or add -package bytestring)
07:50:37 <ilyak_> I must be missing something, as this doesn't work
07:50:50 <Beelsebob> fxr: data Bit = Zero | One
07:50:50 <Beelsebob> data Binary = End Bit | More Binary Bit
07:51:12 <fxr> so we need 2 constructors
07:51:15 <Beelsebob> then an example of your type might be... More (More (End One) Zero) One)
07:51:20 <Beelsebob> fxr: yes
07:51:23 <dancor> allbery_b: ah thanks. yeah looks like i need to actually do out -package in this case
07:57:41 <ilyak_> I have a function (Node (a, b)) => a -> b -> NodeI
07:57:49 <ilyak_> and a function NodeI -> NodeCollector ()
07:57:55 <paolino> :t fail
07:57:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
07:58:01 <ilyak_> How would I make them produce a -> b -> NodeCollector () ?
07:59:13 <roconnor> @djinn (a -> b -> c) -> (c -> d) -> (a -> b -> d)
07:59:13 <lambdabot> f a b c d = b (a c d)
07:59:36 <ilyak_> Oh, I see (.) only works with one-parameter functions
07:59:50 <roconnor> @. pl djinn (a -> b -> c) -> (c -> d) -> (a -> b -> d)
07:59:50 <lambdabot> f = flip ((.) . (.))
07:59:52 <scook0> @type (.).(.)
07:59:53 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
08:00:11 <roconnor> @. pl djinn (c -> d) -> (a -> b -> c) -> (a -> b -> d)
08:00:11 <lambdabot> f = (.) . (.)
08:00:48 <scook0> @type let (.) = (Prelude..) in (.).(.)
08:00:49 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
08:00:58 <scook0> @type let (.) = (Prelude..) in (.).(.).(.)
08:00:59 <lambdabot> forall a a1 b c a2. (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
08:02:16 <paolino> how can I make a recursive monadic (in the list monad) function fail inside and jump to first level, if I return [] I just fail one level , I suppose
08:03:14 <ilyak_> paolino: throw?
08:04:10 <paolino> :t throw
08:04:11 <lambdabot> Not in scope: `throw'
08:04:17 <TomMD> ?hoogle throw
08:04:18 <lambdabot> Control.Exception.throw :: Exception -> a
08:04:18 <lambdabot> GHC.Conc.throwTo :: ThreadId -> Exception -> IO ()
08:04:18 <lambdabot> Control.Exception.throwIO :: Exception -> IO a
08:04:28 <ilyak_> roconnor: Do you mean I should say flip ((.) . (.)); attr = (curry NodeI) `f` el?
08:04:30 <TomMD> You the Control.Exception.throw
08:04:47 <ilyak_> That's too wtfy for me, I'll just suppy args I guess
08:05:56 <paolino> is ContT [] a way ? or I do it explicitly with a Maybe
08:09:25 <fxr> are there any constructors for natural numbers?
08:11:22 <dons> fxr: there's no unbounded Nat type
08:13:56 <roconnor> type Nat = [()]
08:16:29 <vincenz> type Nat = Fix Maybe
08:16:37 <Arnar> hi there..
08:17:01 <Arnar> let me know if this is the wrong channel, but I could use some help with parsec..
08:17:33 <vincenz> Arnar: this is the right channel
08:17:41 <vincenz> roconnor: I like mine better :)
08:19:03 <Arnar> ok.. I have three parsers, parallelProcess, renaming and restriction. I need a parser for the term (in re format)  "process ::= process renaming | process restriction | parallelProcess"
08:19:21 <Arnar> I can do the left factoring.. but I can't figure out how to construct the proper ast
08:19:43 <Arnar> renaming and restriction can be thought of as complex postfix operators on processes
08:19:57 <vincenz> Arnar: so iiuc
08:19:59 <vincenz> it's' possible to have
08:20:06 <vincenz> process renaming renaming renaming
08:20:11 <Arnar> yup
08:20:20 <Arnar> and process renaming restriction renaming
08:20:26 <vincenz> right
08:20:58 <Arnar> which needs to be this in type ctr syntax : Renaming x (Restriction y (Renaming z P)))
08:21:02 <Arnar> s/P/p/
08:21:17 <Arnar> (the language is CCS btw)
08:21:57 <Arnar> I can paste what I have already..
08:22:36 <vincenz> ok
08:23:13 <vincenz> @paste
08:23:13 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:23:52 <hpaste>  Arnar pasted "CCS parser" at http://hpaste.org/6964
08:24:12 <ilyak_> Overlapping instances for Show Attribute arising from the superclasses of an instance declaration
08:24:27 <ilyak_> Is there a way to tell it mine one is right?
08:24:27 <vincenz> ok
08:24:29 <vincenz> Arnar: what about...
08:24:41 <vincenz> process_adapter :== renaming | restrcton
08:24:49 <vincenz> and have those return the type
08:24:52 <vincenz> Process -> Process
08:25:10 <ilyak_> Oh, I guess it wouldn't be smart. Probably I should  make Attribute = Attribute (String, String) instead of just String, String
08:25:17 <Arnar> vincenz: sounds good..
08:25:57 <Arnar> could I then match  parallelProcess ; many process_adapter
08:26:10 <Arnar> and then apply the Process -> Process functions from the latter and return?
08:26:32 <Arnar> (just to check if I'm on your page)
08:26:48 <vincenz> right
08:26:51 <Arnar> ok
08:27:12 <Arnar> @hoogle a -> [a -> a] -> a
08:27:12 <lambdabot> No matches, try a more general search
08:27:32 <vincenz> :t \l -> foldr (.) id  l
08:27:33 <lambdabot> forall a. [a -> a] -> a -> a
08:27:42 <Arnar> ah, thanks
08:27:50 <vincenz> never sure if it's foldl or foldr on that one
08:28:05 <vincenz> > foldr (.) id [(*3), (+2)] 1
08:28:07 <lambdabot>  9
08:28:14 <resiak> > foldr (.) id [f, g, h] x
08:28:14 <lambdabot>  f (g (h x))
08:28:16 <vincenz> foldl apparently
08:28:23 <vincenz> resiak: thx
08:28:41 <scook0> vincenz: try using :info to check its fixity
08:29:05 <scook0> seems like a good heuristic for which fold you should be using
08:30:32 <vincenz> scook0: the folds have no fixity
08:30:51 <scook0> I was talking about (.)
08:31:11 <vincenz> oh
08:31:26 <vincenz> > foldl (.) id [f, g, h] x
08:31:27 <lambdabot>  f (g (h x))
08:31:33 <vincenz> wtf
08:31:36 <vincenz> > foldr (.) id [f, g, h] x
08:31:37 <lambdabot>  f (g (h x))
08:31:42 <Arnar> hmm
08:31:46 <vincenz> > foldr (flip (.)) id [f, g, h] x
08:31:46 <lambdabot>  h (g (f x))
08:32:13 <Arnar> ok.. so foldr + flip is what I want.. I guess
08:32:30 <Arnar> shouldn't there be something in prelude that does this.. fmap or sth?
08:32:37 <vincenz> nah
08:32:38 <shachaf> vincenz: (.) is associative.
08:32:49 <vincenz> shachaf: touche
08:33:46 <Arnar> vincenz++
08:35:14 <Arnar> I'd like to have a brain-implant with lambdabot on a chip..
08:35:37 <vincenz> until you get "GHC: Brain exploded"
08:35:39 <shachaf> @@ (@where goa) -- starting point
08:35:39 <lambdabot>  http://www.cse.unsw.edu.au/~dons/code/goa/ -- starting point
08:35:42 <Twey> Arnar: But then Microsoft would own your soul.
08:35:53 <vincenz> Twey: who says the soul is located in the brain?
08:36:20 <Arnar> Twey: heh.. I wouldn't be the first one
08:36:21 <Twey> vincenz: It's not.  It's a clause in their permission to use their cyborg patent.
08:36:40 <vincenz> Twey: Good thing I don't have a soul :)
08:36:44 <Twey> Heheh
08:37:00 <ilyak_> Twey: Why Microsoft?
08:37:01 <Twey> Mmmm
08:37:07 <ilyak_> Did they wrote lambdabot?
08:37:10 <Twey> ilyak_: Because they own a patent on cyborgs.
08:37:21 <vincenz> Twey: Seriously?
08:37:28 <Twey> vincenz: I think if you don't believe in Cartesian dualism, your body is your soul
08:37:37 <Arnar> shachaf: GOA looks good... I haven't had the follow through to compile lambdabot yet though :/
08:37:45 <Twey> vincenz: Any electrical device powered by the human body, if I remember correct
08:37:48 <vincenz> Twey: Assuming a soul exists in the first place.
08:37:52 <Twey> @go Microsoft cyborg patent
08:37:56 <lambdabot> http://www.saitek.com/uk/prod/p3600.htm
08:37:56 <lambdabot> Title: Cyborg Rumble Pad
08:37:57 <vincenz> Twey: That's pretty broad
08:38:12 <vincenz> Twey: I should make a patent on "anything invented in the year 2220"
08:38:14 <Twey> vincenz: Well no, you missed the point -- I was defining 'soul' as 'something without which you are not you'
08:38:35 <Twey> vincenz: Which, if you don't believe in dualism, is your body
08:38:45 <vincenz> Twey: I disagree :)
08:38:46 * dancor thought it was an implantable rumble pad
08:38:58 <vincenz> Twey: Your memories make you, and they're not a soul
08:39:08 <vincenz> Twey: That's' why people who have lost their memories often seem like different people.
08:39:27 <dancor> well a lot of times they have messed up prefrontal stuff too
08:39:27 <ddarius> Meanwhile people who've lost their soul seem just the same
08:39:40 <Twey> Here's the patent: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=/netahtml/search-bool.html&r=1&f=G&l=50&co1=AND&d=ptxt&s1=microsoft&s2=6,754,472&OS=microsoft%20AND%206,754,472&RS=microsoft%20AND%206,754,472
08:39:42 <lambdabot> Title: United States Patent: 6754472, http://tinyurl.com/582yc4
08:40:12 <vincenz> Abolish patents!
08:40:35 * ddarius patents the idea of abolishing patents.
08:40:45 <ilyak_> You can get the other way
08:40:50 <Twey> vincenz: Well, anything works -- the point is that there is something that separates a person from a chunk of meat, which most people agree on :-)
08:41:10 <Twey> ddarius: Haha, excellent idea!
08:41:16 <vincenz> Twey: Usually that's my teeth
08:41:17 <Twey> But I dislike it
08:41:19 <ilyak_> As far as I understand this patent isn't covering configuration when generator sits inside implanted device
08:41:50 * Twey patents the idea of patent-abolishing patents.
08:42:04 <vincenz> Twey: More seriously, soul tends to be something spiritual.
08:42:08 * vincenz adds a 'usually'
08:42:12 <Twey> Heh
08:42:13 <vincenz> It's why I reject the term
08:42:26 <Twey> Whereas I'd prefer to modify the term :-)
08:42:59 <Twey> ilyak_: You may be right
08:43:09 <Twey> Either way, it's quite scary :-)
08:43:13 <vincenz> Twey: Welll that way you can make any text mean anything, which tends to make terms/texts lose their originial spirit
08:43:50 <Twey> vincenz: Ah, but it's a reinterpretation, not a redefinition
08:44:22 <vincenz> Bah
08:44:29 <vincenz> You're suiting whatever serves your purpose
08:46:11 <Twey> vincenz: Eh, this one's a matter of taste.
08:46:41 <vincenz> Twey: but it makes arguments rather arbitrary and thus pointless to discuss :)
08:48:06 <Twey> Heh, fair enough
08:50:10 <Arnar> vincenz: parser works like a charm.. thank you very much
08:50:41 <hpaste>  Arnar pasted "CCS parser (partial) - solved" at http://hpaste.org/6965
08:50:45 <vincenz> Arnar: welcome :)
09:43:40 <benny99> hi -- what do you think is the best way to create Haskell bindings for C++ libraries like CrystalSpace 3D?
09:44:13 <allbery_b> IMO, make a C binding first, then use FFI.  anything else will be *really* painful
09:44:38 <SamB> or use boost::haskell
09:44:46 <SamB> but first, you have to create it
09:44:50 <benny99> there's boost::haskell :) ?
09:44:58 <benny99> you are... cruel...
09:45:02 <SamB> sorry
09:45:12 <SamB> at least I explained QUICKLY
09:45:17 <benny99> :'( ... (no problem)
09:45:48 <SamB> I don't even know if there can *be* a boost::haskell or not
09:45:48 <OceanSpray> I just read about "smart constructors"
09:45:56 <SamB> but it would be cool if there could be
09:46:02 <benny99> guess there's also nobody working on SWIG Haskell?
09:46:15 <ddarius> benny99: When I was writing a binding to Kyra I used SWIG to generate a C interface.
09:46:16 <SamB> I don't seem to remember much liking SWIG
09:46:22 <OceanSpray> who else here thinks that they're extremely cumbersome?
09:46:32 <SamB> OceanSpray: they can be
09:46:32 <benny99> ok
09:46:42 <SamB> OceanSpray: but they also can make things a lot easier!
09:46:56 <SamB> things like, oh, debugging compilers
09:47:09 <benny99> or are there already Haskell 3D Engines? (even if they are quite simple (ther was HFPS I guess))
09:47:12 <OceanSpray> huh.
09:47:22 <geezusfreeek> oh i just looked up "smart constructor" â€¦ i didn't even realize there was a name for that
09:47:26 <SamB> but you need to make corresponding smart deconstructors to go with them
09:47:37 <OceanSpray> But seriously, define Peano numbers just to check bounds?
09:47:47 <SamB> OceanSpray: eh?
09:47:51 <ddarius> OceanSpray: Wtf are you talking about?
09:47:55 <geezusfreeek> umm
09:47:55 <benny99> C++
09:47:58 <benny99> boost stuff I guess
09:48:03 <OceanSpray> I'm talking about that example in the wiki
09:48:11 <benny99> (ok)
09:48:19 <SamB> OceanSpray: chapter and verse?
09:48:22 <geezusfreeek> oh, indexed types
09:48:29 <geezusfreeek> that is a difference concept from smart constructors
09:48:46 <OceanSpray> http://www.haskell.org/haskellwiki/Smart_constructors
09:48:47 <lambdabot> Title: Smart constructors - HaskellWiki
09:48:50 <geezusfreeek> the example is just to show how smart constructors and indexed types can work together
09:48:52 <SamB> anyway, that kind of stuff is common in dependantly typed code
09:49:11 <SamB> it is, after all, kind of the point
09:49:15 <geezusfreeek> SamB: it also is a lot less cumbersome in a true dependently typed language
09:49:25 <SamB> truly so
09:49:35 <ddarius> OceanSpray: 1.2 is a smart constructor
09:49:35 <phr_> do they really use unary peano numbers as types, for stuff like array bounds?  what if the arrays are large??
09:50:00 <SamB> another example of a smart constructor is:
09:50:04 <SamB> say you have a compiler
09:50:29 <geezusfreeek> phr_: it's just a type, and usually they are used lazily
09:50:31 <SamB> and your intermediate language has these two constructors:
09:50:55 <geezusfreeek> if you are using peano numbers at runtime it better be just to exploit some laziness properties
09:50:58 <SamB> TArrow :: Type -> Type -> Type
09:51:03 <benny99> thanks, I'm off again
09:51:09 <SamB> TAp :: Type -> Type -> Type
09:51:35 <SamB> and there is also a value tc_Arrow :: Type
09:51:51 <SamB> that corresponds with (->) in Haskell
09:52:35 <geezusfreeek> phr_: and in most dependently type languages i know numerical literals can be typed as Nat, so you don't have to go through the trouble of (S (S (S (S z)))) and such
09:52:41 <SamB> (TAp a b ==> a b, of course, and TArrow a b ==> a -> b)
09:53:15 <SamB> so say you don't want any fully-applied tc_Arrows
09:53:18 <SamB> anyone with me?
09:53:37 <geezusfreeek> dependently typed languages are still a little cumbersome currently, but there is a lot of research going on to change that
09:54:02 <SamB> nobody cares about my example ?
09:54:04 <ddarius> Why wouldn't you want any fully-applied tc_Arrows?
09:54:11 <ddarius> Did you mean "partially-applied"?
09:54:34 <phr_> ic, this smart constructor stuff in haskell is sort of a hack, and i see further down the page you can use a decimal encoding, which i hope means the size of the types would be O(log n) instead of O(n)
09:54:35 <SamB> ddarius: because you want them to be replaced by TArrows
09:54:38 <SamB> as in:
09:54:57 <ddarius> Ah, I see what you meant now.
09:55:19 <SamB> instead of "TAp (TAp tc_Arrow a) b", you want "TArrow a b"
09:56:27 <SamB> anyway, this is a perfect application of smart constructors
09:57:34 <SamB> instead of having to add code to check whether something is a (TAp tc_Arrow _) wherever you construct a TAp, you just make a smart constructor:
09:58:17 <SamB> hmm, I'm apparantly a bit mixed up in my notation...
09:58:19 <ddarius> It's just typical ADT stuff.  Smart constructors maintain an invariant (in SamB's case, a "normal" form)
09:58:46 <SamB> the name is actually tArrow in this representation ;-)
09:59:04 <SamB> tAp (TAp c@TCon{} a) b | c == tArrow = TArrow a b
09:59:04 <SamB> tAp a b = TAp a b
09:59:25 <SamB> GHC uses smart constructors extensively
09:59:41 <SamB> they *really* help when you change the invariants
10:00:20 <SamB> (this example is from JHC, though)
10:00:41 <mauke> does anyone know where the Show instance for UTCTime is defined?
10:00:43 <SamB> (and I'm not sure the code has been committed yet -)
10:04:40 <Koobs> Anyone have an idea as to why I would get linking errors when loading code in GHCI but not when compiling the same code with GHC?
10:05:25 <mauke> oh, doesn't really matter as long as you import Data.Time :-)
10:10:59 <geezusfreeek> mauke: yeah that got me just a couple days ago actually
10:15:49 <SamB> Koobs: what linker errors?
10:18:18 <Koobs> Well, "unknown symbol '__imp__glutGetProcAddress'" is what ghci spits out.
10:18:46 <Koobs> I'm trying to get the glut bindings to work with the freeglut library.
10:18:59 <Koobs> On windows, I should add.
10:19:53 <SamB> Koobs: there is a bug on the tracker that mentioned that problem
10:21:32 <Koobs> Whose tracker?  I would very much like to read the bug report.  Has it been solved?
10:22:31 <SamB> http://www.google.com/url?sa=t&ct=res&cd=1&url=http%3A%2F%2Fhackage.haskell.org%2Ftrac%2Fghc%2Fticket%2F1288&ei=TkECSOTrOKTkep6YySI&usg=AFQjCNFeA7V2CQfzzrUKg_YbZvueGwsNHA&sig2=iijnW-BsKIJa2bW_lk77kQ
10:22:35 <SamB> erg.
10:22:35 <lambdabot> Title: #1288 (ghci 6.6 foreign import stdcall broken, panic, panic!!!!) - GHC - Trac, http://tinyurl.com/5zr2ln
10:22:45 <SamB> don't follow that
10:22:56 <SamB> hackage.haskell.org/trac/ghc/ticket/1288
10:23:20 <Koobs> Reading it now...
10:24:31 <hpaste>  ManoX pasted "Anagrammeur full chouette" at http://hpaste.org/6966
10:27:03 <Koobs> You're my saviour, SamB.  I almost wasted a great deal of time.
10:27:12 <Koobs> That was exactly my problem.
10:27:39 <Koobs> Thanks.
10:28:41 <SamB> so, you can chime in if you want, but the workaround is to not use GHCi for that, as you can see
10:28:45 <atp> does anyone here have much familiarity with GHC's implementation of TChan and STM
10:29:06 <SamB> JaffaCake isn't here...
10:29:09 <SamB> so probably not.
10:29:13 <sjanssen> atp: I read the code once
10:29:16 <sjanssen> (to TCHan)
10:29:26 <quicksilver> TChan is pure haskell, isn't it?
10:29:36 <quicksilver> using TVars.
10:29:40 <SamB> well, I was speaking of STM, mostly
10:30:39 <atp> basically what i'm wondering is, if i have a thread that is blocked on a readTChan, and the only other thread with a reference to that TChan closes, will the first thread block for ever, or will the RTS kill it
10:30:54 <atp> i guess basically, are threads garbage collected
10:31:23 <SamB> If a TVar is anything like an MVar, GHC will likely catch it
10:31:38 <atp> is there anyway to profile how many threads are live?
10:31:42 <SamB> yes
10:31:47 <atp> ah!
10:31:49 <geezusfreeek> atp: well, threads are garbage collected, but a thread shouldn't really be able to exit in the middle of a transaction
10:31:52 <atp> good, then i can answer my own question
10:32:18 <SamB> include -xt in the RTS flags
10:32:26 <SamB> as +RTS --help will tell you
10:32:30 <atp> geezusfreeek: does readTChan actually block until something comes through, or does it only do that if I do readTChan blah `orElse` retry?
10:32:45 <geezusfreeek> oh it certainly blocks
10:33:00 <geezusfreeek> i just mean that any thread in the middle of a transaction can't do IO unless you are using unsafe functions
10:33:08 <SamB> atp: oh, but you might not like how GHC deals with it when it notices...
10:33:10 <geezusfreeek> so unless something goes horribly wrong it shouldn't be able to exit
10:33:16 <atp> SamB: how so?
10:33:27 <atp> geezusfreeek: you mean the thread?
10:33:34 <geezusfreeek> right
10:33:36 <SamB> well, the program might be terminated as well
10:33:39 <SamB> I don't know for sure
10:33:42 <atp> geezusfreeek: so is it preferable to use throwTo or something?
10:33:59 <geezusfreeek> what is it that you are trying to do?
10:34:09 <atp> SamB: hm.  good point.  although so far, that hasn't happened.
10:34:19 <geezusfreeek> unless you are using unsafe functions the type system shouldn't even allow you to kill a thread during a transaction
10:34:20 <SamB> atp: has it reported deadlock?
10:34:31 <SamB> usually with MVars it reports deadlock for me...
10:34:32 <atp> it's a pretty simple network server.  it listens on a port, reads some simple commands from clients
10:34:41 <SamB> geezusfreeek: how is the type system going to do it?
10:34:48 <SamB> geezusfreeek: wouldn't that be more the RTS?
10:35:04 <SamB> I mean, another thread could try to kill that one in the middle of a transaction...
10:35:07 <atp> SamB: no, no deadlock.  I think the point of STM is to avoid that, but then this is my first foray into concurrent haskell so i don't know anything about mvars
10:35:16 <geezusfreeek> do TChans not require executing STM stuff with atomically?
10:35:19 <atp> i'm pretty much completely clueless about this aspect of haskell
10:35:23 <atp> yes
10:35:27 <geezusfreeek> oh, another thread!
10:35:37 <geezusfreeek> well then that might be a problem
10:35:45 <quicksilver> STM is less "blocky", in that TVars are never empty afaik?
10:35:50 <quicksilver> (unlike MVars)
10:35:55 <SamB> atp: well, if all the threads that hold references to a given TRef are blocked on it...
10:35:57 <quicksilver> I've never used TChans though.
10:36:08 <SamB> and ONLY it
10:36:14 <SamB> then wouldn't that be a deadlock?
10:37:14 <atp> yeah, that's sort of what i'm wondering.  but at the same time, it wouldn't be too strange to expect that the haskell rts would notice that readTChan is reading a reference that no one else has, and so it will block forever, and kill it
10:37:30 <atp> the thread i mean
10:37:34 <atp> but i don't know if it does that, or what.
10:38:13 <atp> i guess i don't want there to be a "thread leak" for lack of a better term
10:38:15 <sjanssen> so lets do a simple experiment
10:38:36 <SamB> well, yesterday I accidentally wrote some code that left another thread trying to read from a Chan that nobody was writing to... and GHC killed the program, stating that it was deadlocked
10:38:43 <Zao> I belive that you get an deadlock exception if you block too long on an transaction.
10:38:48 <sjanssen> I believe GHC notices deadlock with STM programs, but I'm not sure
10:38:51 <Zao> Or so my fractal renderer seems to do.
10:38:58 <atp> i guess it wouldn't be too hard to check, eh?
10:39:00 <sjanssen> SamB: Chan /= TChan
10:39:04 <SamB> yeah
10:39:10 <atp> make two threads
10:39:12 <sjanssen> they're totally different mechanisms in GHC
10:39:17 <geezusfreeek> i have never had a program with stm deadlock without ghc reporting it
10:39:17 <atp> that share a tchan
10:39:29 <SamB> sjanssen: both undergo garbage collection, though
10:39:30 <atp> and then have one die
10:39:33 <atp> and see what happens
10:39:42 <SamB> and it's the garbage collector that is responsible for noticing these things, is it not?
10:39:44 <geezusfreeek> or with MVar either
10:39:58 <atp> concurrent haskell is pretty bloody cool i have to say
10:40:34 <atp> i wrote a multiplexing network server that can take tons of concurrent connections in like 20 minutes without even really understanding how STM works, and in less than 40 lines
10:40:36 <SamB> sjanssen: what other code knows who has references to what?
10:41:11 <atp> but because this thing will be fairly long lived and because it's for work i want to make sure it doesn't die
10:41:21 <atp> my whole reason for choosing haskell for this job was because it's safe
10:42:00 <SamB> atp: the easiest way to tell is to write a toy program that will show you what GHC does when you have a thread waiting on a TVar that it has the only reference to
10:42:27 <atp> SamB: yeah, it seems that way.  thanks a lot for the pointer on the cmd-line flags though, that will help a lot.
10:42:37 <geezusfreeek> you don't even have to do that
10:42:40 <geezusfreeek> just run atomically retry
10:42:48 <geezusfreeek> :P
10:42:52 <atp> that blocks forever
10:42:54 <SamB> atp: note that that flag just includes threads in heap profiles
10:43:02 <atp> atomically retry blocks
10:43:05 <atp> at least in ghci
10:43:20 <geezusfreeek> wow, you're right
10:43:23 <geezusfreeek> i didn't expect that
10:43:23 <SamB> atp: so read the "heap profiling" stuff in the GHC manual
10:43:24 <atp> i'm a bit confused about retry, to be honest.
10:43:29 <atp> SamB: ok, i will do that.
10:43:52 <atp> because retry blocks but apparently retry `orElse` readTChan chan doesn't
10:44:02 <geezusfreeek> right
10:44:18 <SamB> atp: hmm, so what does it do? read from the TChan?
10:44:24 <atp> yeah
10:44:29 <SamB> makes sense
10:44:38 <geezusfreeek> retry just means retry the current transaction, but if it's nested then the outer transaction can catch that and do something else if wants
10:44:44 <sjanssen> atp: those are the semantics of retry
10:44:45 <atp> well, i guess i would have expected readTChan chan `orElse` retry to work
10:44:45 <SamB> I guess retry actually means "give up"
10:44:52 <sjanssen> orElse retry y = y
10:44:57 <sjanssen> orElse x _ = x
10:45:01 <atp> ah
10:45:02 <SamB> (and try later, if you don't have anything better to do)
10:45:06 <awesame> so I was thinking about the (.) = fmap definition in lambdabot
10:45:19 <awesame> and I think there should be something similar for ($)
10:45:22 <atp> there is
10:45:24 <atp> <$>
10:45:24 <SamB> (well, actually, not try later, but try again if something relevant changes)
10:45:34 <atp> awesame: in Control.Applicative
10:45:55 <atp> SamB: yeah, that seems to be how it works.
10:46:11 <atp> the fact that you can do that means you can do this though, which is neat:
10:46:27 <atp> foldl orElse retry [listOfSTMActions]
10:46:34 <awesame> atp: hm, I think that's not what I mean
10:47:02 <geezusfreeek> awesame: do you mean (.) is to fmap as ($) is to ???
10:47:11 <awesame> geezusfreeek: exactly
10:47:30 <geezusfreeek> that would be just normal function application, wouldn't it?
10:47:37 <awesame> with (.) = fmap, you can write f . list instead of map f list
10:48:04 <awesame> I want a way to write list $ 1 instead of list !! 1
10:48:16 <Heffalump> too much obfuscation!
10:48:17 <SamB> > [(+1), (*2)] <$> 3
10:48:19 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
10:48:22 <SamB> hmm.
10:48:27 <geezusfreeek> that doesn't seem quit analogous to me
10:48:29 <SamB> @type (<$>)
10:48:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:48:39 <SamB> geezusfreeek: indeed
10:48:42 <atp> <$> is just fmap
10:48:46 <SamB> I was expecting him to want to apply a list of values
10:48:52 <atp> hm
10:49:00 <atp> yeah, i answered too hastily without understanding what he wanted
10:49:01 <SamB> @hoogle [a -> b] -> a -> [b]
10:49:02 <lambdabot> No matches, try a more general search
10:49:26 <SamB> so what the heck is <$> like that for?
10:49:27 <geezusfreeek> SamB: i actually wasn't referring to what you were doing there
10:49:32 <atp> > ($3) <$> [(+1), (*2)]
10:49:33 <lambdabot>  [4,6]
10:49:40 <geezusfreeek> (1+) <$> [1..]
10:49:45 <SamB> geezusfreeek: what was your idea?
10:49:50 <geezusfreeek> > (1+) <$> [1..]
10:49:51 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
10:50:02 <SamB> > (1+) . [1..]
10:50:02 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
10:50:17 <SamB> anyway, clearly <$> isn't to $ what fmap is to .
10:50:23 <SamB> since <$> == fmap
10:50:25 <geezusfreeek> SamB: i was referring to awesame wanting to be able to do list $ 1
10:50:32 <atp> <$> is pretty intuitive actually... if you'll forgive the abuse of notation, f <$> F a -> F (f a), ie, it applies f to the value inside the Functor
10:50:44 <geezusfreeek> i <3 <$>
10:50:51 <atp> so like (*3) <$> Just 5 -> Just 15
10:50:53 <SamB> geezusfreeek: oh, oh, indeed
10:51:06 <SamB> !! isn't at all analogous to $ in my mind
10:51:14 <atp> :t (!!)
10:51:15 <lambdabot> forall a. [a] -> Int -> a
10:51:18 <atp> :t ($)
10:51:19 <lambdabot> forall a b. (a -> b) -> a -> b
10:51:38 <awesame> I feel like there's some similar generalization possible here, but I'd like to know if I'm wrong
10:51:42 <SamB> at least, I don't think there are any simple classes that would have both of those as the same method...
10:51:45 <atp> yeah, it doesn't seem like it
10:51:53 <geezusfreeek> awesame: what would its type be?
10:52:07 <awesame> hang on a sec
10:52:09 <awesame> :t fmap
10:52:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:52:10 <atp> (a->) b -> a -> b doesn't lend itself well to functors that aren't also functions
10:52:25 <atp> perhaps it could lend itself well to bifunctors though
10:52:36 <atp> (->) a b -> a -> b
10:52:40 <atp> Either a b -> a -> b
10:52:46 <atp> (a, b) -> a -> b
10:52:48 <atp> m
10:52:49 <atp> hm
10:53:16 <atp> i kind of can't think of what that function would be?
10:53:27 <geezusfreeek> not a very useful one
10:53:33 <atp> it seems like it would have to ignore a
10:53:49 <geezusfreeek> Either a b -> a -> b would fail for Left
10:54:02 <geezusfreeek> and (a, b) -> a -> b is just snd
10:54:08 <geezusfreeek> well, const snd
10:54:12 <atp> const snd yeah
10:54:16 <awesame> :t $
10:54:17 <lambdabot> parse error on input `$'
10:54:18 * Botje_ read the idioms fucntional pearl yesterday
10:54:21 <awesame> :t ($)
10:54:21 <atp> :t ($)
10:54:22 <lambdabot> forall a b. (a -> b) -> a -> b
10:54:22 <lambdabot> forall a b. (a -> b) -> a -> b
10:54:24 <Botje_> are they really _that_ nice?
10:54:35 <atp> applicative functors rock
10:54:51 <geezusfreeek> Botje_: applicative functors are nicer than the idioms paper, IMO
10:54:56 <atp> i love doing stuff like f . g <$> m >>= f
10:55:07 <atp> mmm
10:55:12 <avtobiff> hi all. i need some help installing HXT on debian. i have heard that installing cabal-install makes it really, really simple. should i just do a darcs get cabal and cabal-install and make them?
10:55:30 <awesame> geezusfreeek: I think it would be Foo f => f (a -> b) -> a -> b
10:55:40 <atp> that would be ap
10:55:44 <atp> or <*>
10:55:47 <dcoutts> avtobiff: it's worth a go :-) I did a pre-release of Cabal-1.4 and cabal-install the other day
10:55:51 <Botje_> geezusfreeek: well, yeah. but i can't seem to wrap my head around applicative functors :)
10:55:53 <atp> no wait
10:55:59 <atp> i missed some fs there
10:56:00 <atp> hehe
10:56:06 <awesame> where Foo is a class of mappings, including lists, functions, etc
10:56:06 <atp> f (a -> b) -> f a -> f b
10:56:11 <Botje_> I understand the types but i can't work out what the operations mean intuitively
10:56:14 <avtobiff> hi dcoutts, yeah. i heard when you told us this friday :)
10:56:20 <atp> Botje_: it depends on the functor
10:56:46 <geezusfreeek> :t (<*>)
10:56:47 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
10:56:53 <geezusfreeek> there you go awesame
10:57:08 <avtobiff> dcoutts, how do i go about. do i need cabal-1.4? is there some clever way i can mix the source with my package management?
10:57:15 <geezusfreeek> but it still doesn't do the example you wanted
10:57:35 <awesame> hm, what does it do?
10:58:02 <geezusfreeek> [(1+), (5*)] <*> [1..5]
10:58:08 <SamB> atp: well, it looks like there is an exception called BlockedOnSTM
10:58:10 <awesame> the instance declarations for Applicative look promising at first glance
10:58:15 <geezusfreeek> > [(1+), (5*)] <*> [1..5]
10:58:15 <lambdabot>  [2,3,4,5,6,5,10,15,20,25]
10:58:18 <avtobiff> dcoutts, you mentioned a tarball this friday. where do i get that one?
10:58:38 <SamB> er, wait, that isn't an exception
10:58:55 <ddarius> Applicative Functors are Idioms.
10:59:27 <SamB> the exception is called BlockedIndefinately, I think
10:59:47 <hpaste>  Runaro pasted "How can the general structure be abstracted here?" at http://hpaste.org/6967
10:59:47 <awesame> > [(1+)] <*> [1]
10:59:48 <lambdabot>  [2]
10:59:53 <SamB> or maybe it isn't an exception...
11:00:13 <awesame> yeah that's not the function I'm looking for, but it's close
11:00:20 <geezusfreeek> > putStrLn <*> return "hello"
11:00:20 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `IO ()'
11:00:38 <geezusfreeek> i'm a dummy
11:00:56 <geezusfreeek> that won't work
11:00:59 <dcoutts> avtobiff: http://haskell.org/cabal/release/
11:01:15 <avtobiff> dcoutts, thanks
11:01:41 <awesame> > (+1) <*> (+2) $ 0
11:01:41 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> b
11:01:41 <lambdabot>     Probabl...
11:01:45 <awesame> hm
11:01:55 <conal> Runaro: i'd add onceE :: Event a -> Event a, and define b `untilB` e = b `switch` onceE e
11:02:00 <avtobiff> dcoutts, cabal-nstall-0.4.6 and devel dir?
11:02:15 <SamB> atp: ah, yes it is...
11:03:26 <Runaro> conal: Good idea
11:05:00 <conal> Runaro: do you really need untilB?  when i switched from single-occurrence to multi-occurrence events in frp, and added accumulator combinators, i rarely wanted untilB.
11:06:28 <awesame> hm, I think the type I want is maybe more like Applyable f => f a -> b -> a
11:06:29 <dcoutts> avtobiff: yep, Cabal-1.3.10 and cabal-install-0.4.6
11:06:36 <awesame> that doesn't seem to be quite right, but it's close
11:07:16 <avtobiff> dcoutts, thanks. i'll try it out after my running round.
11:08:07 <Runaro> conal: Probably not. This is an example from a book, and I thought it was a bit odd.
11:08:23 <conal> Runaro: School of Expression?
11:08:32 <Runaro> yes
11:08:49 <awesame> how do I specify the type of functions in an instance declaration?
11:09:02 <awesame> I tried (a -> b) but that seems to not be right
11:09:24 <ilyak_> awesame: Why would you need to? It's already specified in class declaration.
11:09:52 <awesame> ilyak_: I want to say that functions are an instance of the class
11:09:55 <SamB> atp: so, I guess the default handling for that in forked threads is to silently die? I'm not sure...
11:10:05 <awesame> e.g. instance Foo (a -> b) where...
11:10:33 <ilyak_> instance <Class> Foo where
11:10:43 <ilyak_> What class do you want to implement?
11:10:50 <awesame> no, Foo is the class
11:10:56 <awesame> I just made it up
11:11:03 <SamB> awesame: what was the real class?
11:11:08 <SamB> what happened?
11:11:14 <awesame> it's really called Foo!
11:11:26 <SamB> how is it defined?
11:11:37 <awesame> I don't know yet, it's broken
11:11:38 <ilyak_> awesame: Well, instance Foo String where
11:11:44 <ilyak_> <some function>
11:11:50 <SamB> ilyak_: would you please stop that
11:11:53 <ilyak_> awesame: Paste the code to hpaste.org
11:11:55 <awesame> ilyak_: right, I want instance Foo <functions!> where...
11:11:57 <SamB> you keep not understanding him
11:12:08 <SamB> and making up stuff instead
11:12:10 <ilyak_> awesame: You put functions after where
11:12:19 <ilyak_> Not before
11:12:30 <SamB> ilyak_: he wants to make some FUNCTION TYPES instances of the class
11:12:36 <SamB> so he wants them BEFORE the where
11:12:59 <ilyak_> SamB: Oops.
11:13:21 <awesame> okay, this is full of problems, but maybe explains what I'm trying to figure out how to do: http://codepad.org/loz0NmXQ
11:13:39 <SamB> ilyak_: we all get confused sometimes ;-)
11:13:44 <awesame> I renamed Foo to Applyable
11:14:06 <ilyak_> awesame: Why not define a typedef?
11:14:15 <ilyak_> And implement instance on that?
11:14:20 <ilyak_> If I understand correctly
11:14:28 <awesame> I'm not sure how that would work
11:14:58 <ilyak_> type Bar = (a -> b)?
11:16:12 <awesame> I'm curious how this works for making functions instances of Functor, but I can't find that declaration
11:16:32 <Botje_> type Bar = [Booze] -> [People] -> IO (Either Drunk People)
11:17:37 <quicksilver> awesame: your Applyable type needs to know what type to apply
11:17:49 <quicksilver> awesame: so, for [] it needs to "know" it's Int
11:17:55 <quicksilver> (!!) can only be applied to ints
11:18:03 <quicksilver> similarly functions can only be applied to whatever type they are
11:18:04 <awesame> right, that makes sense
11:18:25 <quicksilver> so it probaly needs to be a multi-param type
11:18:38 <quicksilver> class Applyable f i where apply :: f a -> i -> a
11:18:42 <awesame> ah
11:18:54 <quicksilver> multi-param class, I should say
11:20:08 <awesame> that seems to have done the trick, it compiles with -fglasgow-exts now
11:20:13 <awesame> thanks quicksilver
11:20:56 <astrolabe> Is there a standard way to put asserts into haskell code which get used or ignored depending on how the code is compiled?
11:22:28 <sjanssen> astrolabe: yes:
11:22:31 <sjanssen> @hoogle assert
11:22:31 <lambdabot> Control.Exception.assert :: Bool -> a -> a
11:22:31 <lambdabot> Control.Exception.assertions :: Exception -> Maybe String
11:22:31 <lambdabot> Control.Exception.AssertionFailed :: String -> Exception
11:22:50 <astrolabe> sjanssen: Thanks! I'll look it up.
11:23:02 <awesame> does anyone know where I can find the special prelude lambdabot uses?
11:23:17 <awesame> e.g. the things one gets with @src
11:23:45 <sjanssen> @version
11:23:45 <lambdabot> lambdabot 4p603, GHC 6.8.2 (Linux i686 2.40GHz)
11:23:45 <lambdabot> darcs get http://code.haskell.org/lambdabot
11:24:02 <sjanssen> awesame: see the file 'imports.h' in that repo
11:25:07 <awesame> sjanssen: thanks
11:25:29 <SamB> awesame: http://codepad.org/bbH7P8BQ
11:26:34 <awesame> SamB: excellent!
11:26:51 <awesame> what does the "| f -> i" in the class def mean?
11:28:31 <skorpan> @pl \y -> inferExp y env == inferExp x env
11:28:31 <lambdabot> (inferExp x env ==) . flip inferExp env
11:28:33 <SamB> it is, as you might have guessed, a functional dependancy
11:28:41 <SamB> it means that f determines i
11:30:04 <geezusfreeek> i still don't really see how this class could be useful
11:30:06 <awesame> ah, ok
11:30:12 <SamB> me either
11:30:35 <SamB> did I not mention "simple" in the requirements?
11:31:05 <awesame> well, I just thought of lambdabot's (.) = fmap, and realized there must be a similar generalization for ($)
11:31:21 <idnar> <$>?
11:31:24 <geezusfreeek> :t ($)
11:31:24 <lambdabot> forall a b. (a -> b) -> a -> b
11:31:37 <geezusfreeek> ($) is already polymorphicâ€¦ there's not much more to generalize
11:31:40 <idnar> I suppose not
11:31:58 <geezusfreeek> idnar: (<$>) = fmap
11:32:05 <idnar> geezusfreeek: yeah...
11:32:13 <idnar> :t (.)
11:32:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:32:28 <awesame> geezusfreeek: my "apply" is more general than ($) in exactly the same way that fmap is more general than (.) or map
11:32:31 <geezusfreeek> this fmap stuff seems to be coming up a lot these last few days
11:32:38 <shachaf> Would a ($) that works with ST count as generalized? :-)
11:32:46 <geezusfreeek> awesame: i don't see howâ€¦
11:33:06 <idnar> geezusfreeek: well, you can replace (->) with a typeclass or something
11:33:06 <geezusfreeek> ($) and (!!) don't perform similar operations at all
11:33:10 <awesame> fmap is (.) for all Functors, and contains map and (.) as special cases
11:33:32 <awesame> my "apply" is ($) for all Applyables, and contains (!!) and ($) as special cases
11:33:32 <shachaf> awesame: @src is not the same as the Prelude that lambdabot uses; they're separate.
11:34:00 <awesame> shachaf: ah -- how do I find the full contents of @src?
11:34:54 <awesame> geezusfreeek: they both take a mapping and a key and produce a value
11:35:02 <shachaf> awesame: http://code.haskell.org/lambdabot/State/source
11:35:05 <awesame> with ($) the mapping is a function, and with (!!) it's a list
11:35:06 <geezusfreeek> awesame: but what kind of polymorphic functions could you write with Applyable?
11:35:30 <mattam> awesame: isn't ($) equal to fmap for the identity functor ?
11:35:33 <awesame> thanks shachaf
11:36:03 <awesame> geezusfreeek: I don't know, I'm new to this!  it was just an idea.
11:36:41 <geezusfreeek> ah, i guess i wasn't paying enough attention to realize you were new
11:36:55 <geezusfreeek> i probably would have argued differently
11:37:35 <awesame> mattam: hm, what's the identity functor?
11:38:03 <awesame> @src (.)
11:38:03 <lambdabot> (f . g) x = f (g x)
11:38:19 <awesame> huh, I thought lambdabot had the fmap thingy
11:38:34 <mattam> type id x = x
11:38:43 <awesame> @src fmap
11:38:43 <lambdabot> Source not found. You untyped fool!
11:38:52 <awesame> er
11:38:53 <mattam> @src Functor Id
11:38:53 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
11:39:10 <mattam> Well, you can guess fmap I think.
11:39:33 <Cale> awesame: @src just has its own text file
11:42:56 <awesame> Cale: oh, so is lambdabot actually using a different definition of (.) then?
11:43:05 <Cale> :t (.)
11:43:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:43:08 <Cale> yep
11:43:10 <awesame> ah
11:49:55 <awesame> here's a nice full example of what I was looking for: http://codepad.org/2Im4OIxS
11:51:34 <Cale> hehe, that works nicely with the definition of (.) as fmap
11:52:50 <Cale> Since then if f is some function, xs is a list, and n is an Int, we have that  f $ (xs $ n) is the same as f . xs $ n
11:56:08 <awesame> yeah!
11:59:28 <atp> SamB: sorry, i stepped out for a bit to eat, i should have mentioned it.  i'll look into the BlockedOnSTM exception, thanks for looking into it, i really appreciate that.
12:05:31 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6968
12:06:11 <Baughn> Cale: Should lambdabot patches still be sent to dons? The repository seems to be schizophrenic.
12:07:25 <SamB> atp: actually that's njot the name of the exception
12:07:29 <SamB> but my computer is swapping heavily right now so don't expect much spelling from me right now
12:10:06 <atp> ok
12:11:14 <SamB> iit's something like BlockedIndefinately
12:11:35 <skorpan> is there any predefined function which lets me check if all elements in a list are equal to eachother?
12:11:51 <skorpan> atm i'm thinking \ls -> all (==(head ls)) (tail ls)
12:12:02 <atp> you could fold with (==)
12:12:03 <sjanssen> skorpan: that seems fine
12:12:08 <skorpan> okay
12:12:11 <atp> yeah
12:12:22 <skorpan> so there is no such function?
12:12:22 <Baughn> skorpan: (== 1) . length . nub
12:12:32 <skorpan> Baughn: true
12:12:38 <skorpan> not too intuitive though
12:12:42 <sjanssen> Baughn: that is rather slow
12:12:44 <atp> actually that seems pretty clear
12:12:49 <atp> but yeah, slow
12:12:56 <Baughn> It'll be fast in the case where they /are/ all equal
12:13:00 <sjanssen> the 'all' definition is best, in my opinion
12:13:08 <sjanssen> Baughn: yes, but very slow when they're all different
12:13:23 <Baughn> sjanssen: Meh. What's a factor of n between friends?
12:13:23 <skorpan> my definition will not work for empty lists, neither will anyone else's :)
12:13:32 <sjanssen> the all solution only checks the minimal required
12:13:37 <Zao> atp: Wouldn't fold with == fail since == returns a Bool?
12:13:41 <Duddle> I'm pretty new to haskell, so my question might be really simple: how would you define a datatype that can represent a matrix? I know of lists of lists of Int to define something 2-dimensional, but there are also tuples in haskell so I was wondering in what direction I should look :)
12:14:05 <skorpan> Duddle: i don't see why you would use a tuple for it
12:14:12 <Zao> Duddle: There's always arrays, which you could use a (Int,Int) as index.
12:14:22 <skorpan> you mean a list of tuples or something?
12:15:03 <Sadache> I ve read The Haskell School of Logic for Paul Hudak, and i am searching for the next book to read about Haskell
12:15:05 <Duddle> more like... well, I'm not that great of a mathematician but a matrix is a 2-dimensional tuple iirc
12:15:19 <byorgey> Duddle: the short answer is, a list of lists is probably fine.  The long answer is, it kind of depends what you want to do with your matrices. =)
12:15:24 <Duddle> so I thought thinking in lists would be wrong here :)
12:15:52 <Sadache> I want to learn the way of thinking in Haskell, because i have a very imperative way of thinking in problem solving
12:15:55 <fnoble> the only thing about using lists is its possible to make an ill formed matrix
12:16:09 <fnoble> a tuple of tuples maybe more robust
12:16:19 <Duddle> byorgey: I'm basically just experimenting, trying to learn how to think in haskell
12:16:20 <xd> or an array
12:16:27 <atp> Zao: you'd just have to combine it with (&&), but there's no reason to, all does that for you and is clearer
12:16:36 <atp> @src all
12:16:36 <lambdabot> all p =  and . map p
12:16:44 <atp> @src and
12:16:44 <lambdabot> and   =  foldr (&&) True
12:16:46 <atp> see
12:17:06 <Sadache> so any suggestions?
12:17:18 <atp> code in haskell?
12:17:47 <atp> the best way to learn anything is by doing it
12:17:58 <byorgey> Duddle: ok, then in my opinion a list of lists is probably perfect.  There are definitely more complicated things you can do, but a list of lists will work just fine and will give you some good practice.
12:18:14 <Duddle> thanks everybody, I'll look into it :)
12:18:28 <byorgey> Sadache: if you want more material to read, try the wikibook, there's lots of great stuff in there.
12:18:32 <byorgey> @where wikibook
12:18:32 <lambdabot> http://en.wikibooks.org/wiki/Haskell
12:19:04 <byorgey> Sadache: but I agree that the best way to learn to think in Haskell at this point is probably just to pick an interesting project, jump in, and try writing some Haskell =)
12:19:23 <byorgey> and read stuff along the way as you find out more stuff you want to learn
12:19:28 <byorgey> and ask lots of questions in here =)
12:19:36 <Sadache> does Haskell fit with any kind of project
12:19:38 <Sadache> ?
12:20:06 <fnoble> Sadache: could try and work through some of the problems on project euler
12:20:07 <byorgey> Sadache: yes, although some would be more accessible than others as a first project
12:20:30 <Sadache> I am often afraid to overuse type classes because of my oop background, or to overuse monads (and the do expression) because of my imperative background
12:20:41 <atp> type classes are not the same as classes in oop
12:20:49 <fnoble> www.projecteuler.net
12:20:53 <Sadache> i know
12:21:03 <Sadache> but they are so much like interfaces
12:21:06 <atp> despite the similar names they are different as concepts, and you will not go far if you try to use them similarly (which would be instructive)
12:21:19 <Sadache> and interfaces are used much in oop
12:21:27 <atp> they really aren't at all alike.
12:21:32 <astrolabe> I suspect overusing monads (particularly IO) is more of a risk.
12:21:42 <atp> just avoid IO
12:21:48 <astrolabe> heh
12:22:04 <atp> and avoid state
12:22:05 <astrolabe> as far as possible, and no further
12:22:06 <atp> and ST :)
12:22:07 <byorgey> type classes have some similarities to interfaces in Java.
12:22:17 <Baughn> Besides IO and possibly State, the other monads should be /just fine/ to use. ;)
12:22:27 <atp> ST
12:22:30 <Baughn> They're nothing like anything you'll have seen in other languages
12:22:33 <Sadache> byorgey: yes and interfaces are used much in java, i guess unlike in haskell
12:22:36 <Baughn> ..okay, st in general
12:23:08 <fnoble> maybe just try some algorithm based problems to get the feel for functional programming
12:23:11 <byorgey> Sadache: type classes are actually used quite a bit in Haskell.
12:23:18 <Baughn> Sadache: Typeclasses are used quite a lot, really. They're about the only way you /have/ to get ad-hoc polymorphism
12:23:29 <Sadache> i mean for example in OOP i know very well when to use a certain pattern: strategy, decorator...etc
12:23:51 <atp> Sadache: really, just write some code.  you'll learn the boundaries quickly enough.
12:24:06 <Sadache> But in haskell i am not able yet to grasp it well, and to know when to use a monadic abstraction
12:24:07 <atp> there's nothing with trying to use type classes like interfaces if you feel like doing that.
12:24:12 <Baughn> Sadache: Whenever you reach for a pattern.. try not to. You mostly don't /need/ them
12:24:17 <atp> nothing wrong*
12:24:26 <atp> you'll learn quickly where the differences lie.
12:24:26 <geezusfreeek> Sadache: type classes are more like templates
12:24:30 <atp> yeah.
12:24:37 <atp> they're a type level abstraction
12:24:44 <atp> compile time :)
12:24:53 <astrolabe> Sadache: A heuristic is not to use monads until you see somewhere where a monad would save you work.
12:24:56 <Baughn> Until you get into existentials, that is. ;)
12:25:06 <mauke> or polymorphic recursion
12:25:15 <geezusfreeek> right
12:25:15 <mauke> or higher rank types
12:25:17 <astrolabe> (except for IO, which is compulsory sometimes)
12:25:21 <Sadache> i know what type classes are, but yet, you cant avoid the way of thinking
12:25:27 <atp> and not to use monads where an applicative functor would do, and not to use applicatives where just a functor is sufficient... etc
12:25:54 <Sadache> atp : I see
12:25:56 <atp> Sadache: you will avoid that way of thinking once you try to do something with a type class and realize it can't be done
12:25:58 <idnar> I think the main difference between interfaces and type classes is that interfaces are usually used in languages with dynamic typingn
12:26:02 <idnar> *typing
12:26:12 <geezusfreeek> Sadache: i came from a strong oop background. it definitely took a while to work out the differences, but then things just started clicking. you just have to keep trying things
12:26:22 <mauke> er, what's the point of defining an interface if you have dynamic typing?
12:26:44 <Baughn> mauke: Bondage, domination, all those good things
12:27:03 <mauke> what language supports that?
12:27:04 <idnar> mauke: well, I'm thinking of languages like Java
12:27:17 <mauke> Java is statically typed
12:27:21 <atp> heh
12:27:21 <idnar> not entirely
12:27:26 <geezusfreeek> mauke: an interface is a dictionary, essentially
12:27:30 <mauke> the interface part is
12:27:30 <idnar> because of inheritance
12:27:40 <Baughn> Java is statically /and/ dynamically typed - it somehow gets the worst of both world
12:27:56 <Sadache> generic interfaces exist in java and c#, they look so much like type classes, with two differences: type classes can have a default implementation, type classes dont tie functions with structure
12:28:19 <idnar> Sadache: how do interfaces enforce structure?
12:28:22 <geezusfreeek> you can claim an object conforms to an interface and then it is safe to use the interface's methods on that object without knowing the object's actual type
12:28:41 <monochrom> What's the point of defining array index bounds if you have dynamic array resizing?
12:29:07 <geezusfreeek> monochrom: what are you talking about?
12:29:26 <Sadache> maybe i expressed wrong, but you have to implement the interface inside your class, which means you are having structure and functions in the same module, and you cant do otherwise
12:29:29 <monochrom> I'm asking a guiding question.
12:29:57 <monochrom> There are more. What's the point of defining while-loops if you have goto?
12:30:16 <geezusfreeek> oh, i thought you were starting a concurrent conversation ;)
12:30:41 <atp> you know, i've often wondered that.  i basically just use goto in all my code.
12:30:49 <atp> it's not like loops add any value.
12:31:12 <geezusfreeek> they are more readable much of the time
12:31:25 <atp> geezusfreeek: believe it or not, i'm kidding.
12:31:28 <atp> :)
12:31:46 <geezusfreeek> *sigh* i have gotten used to people being serious saying stuff like that
12:31:46 * paolino retires the bottle of wine
12:31:49 <Sadache> while is more strict, less imperative and easier to grasp
12:31:54 <byorgey> loops don't add values, + adds values
12:32:00 <atp> hah
12:32:07 <atp> what about mappend?
12:32:12 <geezusfreeek> you beat me to it
12:32:13 <atp> it's more generic :)
12:32:52 <awesame> I think I'm not totally clear on the differences between templates, interfaces, and type classes
12:33:33 <mauke> templates = preprocessor macros + sugar
12:33:59 <Sadache> interfaces are just contracts, they have to be implemented then, in java and c# the class that implements several interfaces has to implement them inside its difinition, and if it doesnt then its too late
12:35:00 <geezusfreeek> interfaces also cannot be instantiated generally across many classes
12:35:12 <geezusfreeek> it has to be case by case or in a superclass at least
12:35:21 <Sadache> Type classes intances are done outside the difinition of their types, which decouples them. This makes it easier to extend existing Types
12:35:34 <atp> hey, this is changing the subject a bit, but is there a function f :: (a -> Bool) -> Maybe a -> Maybe a such that f p m = m >>= \x -> if p x then Just x else Nothing  ?
12:35:44 <atp> defined somewhere i mean
12:36:05 <resiak> @ty (<*)
12:36:08 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
12:36:28 <Baughn> @type runST
12:36:29 <lambdabot> forall a. (forall s. ST s a) -> a
12:36:33 <resiak> hmm, that's not going to work
12:36:59 <RayNbow> http://prog21.dadgum.com/23.html
12:36:59 <lambdabot> Title: prog21: Purely Functional Retrogames, Part 1
12:37:16 <atp> basically i would like to be able to do something like f (not . null) m for m :: Maybe [a]
12:37:17 <geezusfreeek> @djinn (a -> Bool) -> Maybe a -> Maybe a
12:37:17 <lambdabot> f a b =
12:37:17 <lambdabot>     case b of
12:37:17 <lambdabot>     Nothing -> Nothing
12:37:17 <lambdabot>     Just c -> case a c of
12:37:17 <lambdabot>               False -> Nothing
12:37:19 <lambdabot>               True -> Just c
12:37:33 <sclv_> ?hoogle guard
12:37:34 <lambdabot> Control.Monad.guard :: MonadPlus m => Bool -> m ()
12:37:34 <lambdabot> Language.Haskell.TH.Guard :: data Guard
12:37:34 <lambdabot> Language.Haskell.TH.Syntax.Guard :: data Guard
12:37:42 <atp> whoa
12:37:44 <resiak> I was looking for an m <* guard p
12:37:47 <sclv_> ?hoogle unless
12:37:47 <lambdabot> Control.Monad.unless :: Monad m => Bool -> m () -> m ()
12:37:56 <resiak> you want x <- m; guard p x; return x
12:39:18 <atp> geezusfreeek: what was that djinn thing?
12:39:27 <geezusfreeek> it's a haskell theorem prover
12:39:30 <mauke> @help djinn
12:39:30 <lambdabot> djinn <type>.
12:39:30 <lambdabot> Generates Haskell code from a type.
12:39:30 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
12:39:51 <atp> geezusfreeek: that's pretty sweet, it got it exactly right.
12:39:59 <geezusfreeek> yup
12:40:24 <geezusfreeek> :t (.)
12:40:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:40:36 <atp> i don't actually mind if the function isn't defined as such, it would just be nice if there were some relatively easy way to string some stuff together in a point-free way given just p and m
12:40:37 <geezusfreeek> grr i forgot lambdabot has the different defs
12:40:55 <geezusfreeek> @djinn (b -> c) -> (a -> b) -> a -> c
12:40:55 <lambdabot> f a b c = a (b c)
12:41:16 <Baughn> @type newSTRef
12:41:17 <lambdabot> Not in scope: `newSTRef'
12:41:30 <atp> @djinn a -> a
12:41:30 <lambdabot> f a = a
12:41:32 <atp> hehe
12:41:33 * Baughn pokes the bo. Why does it work here?
12:41:38 <geezusfreeek> @djinn (a -> b) -> [a] -> [b]
12:41:38 <lambdabot> -- f cannot be realized.
12:41:41 <geezusfreeek> oops
12:42:07 <geezusfreeek> hmm, why can't it do that one?
12:42:17 <mauke> because it doesn't understand lists
12:42:19 <geezusfreeek> maybe it doesn't know lists
12:42:20 <geezusfreeek> ah
12:42:31 <atp> does it understand general functors?
12:42:43 <sclv_> i don't think it does typeclasses.
12:42:50 <geezusfreeek> djinn is pretty limited
12:42:50 <atp> @djinn Functor f :: (a -> b) -> f a -> f b
12:42:50 <lambdabot> Cannot parse command
12:42:52 <atp> hm
12:42:57 <atp> oops
12:43:01 <geezusfreeek> @djinn (Functor f) => (a -> b) -> f a -> f b
12:43:07 <atp> thanks
12:43:17 <atp> it appears to be thinking?
12:43:17 <geezusfreeek> lambdabot?
12:43:21 <atp> uh oh.
12:43:25 <sclv_> ?google haskell djinn
12:43:26 <geezusfreeek> broke it
12:43:27 <lambdabot> http://lambda-the-ultimate.org/node/1178
12:43:27 <lambdabot> Title: Djinn, a theorem prover in Haskell, for Haskell. | Lambda the Ultimate
12:43:38 <atp> haskell is safe :)
12:43:39 <mauke> :t \p m -> (m >>= guard) >> m
12:43:40 <lambdabot> forall t (m :: * -> *). (MonadPlus m) => t -> m Bool -> m Bool
12:43:42 <atp> you'll love how safe it is.
12:43:53 <mauke> :t \p m -> (m >>= guard . p) >> m
12:43:54 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => (a -> Bool) -> m a -> m a
12:45:13 <Botje_> introducing the UAC monad: it's like the IO monad but asks you if you're sure everytime an action is evaluated
12:45:29 <mauke> :t \p -> (>>= guard . p) >>= (>>)
12:45:30 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => (a -> Bool) -> m a -> m a
12:45:48 <geezusfreeek> Botje_: the Vista monad?
12:45:55 <atp> that would be very easy to implement
12:46:03 <mauke> :t (>>= (>>)) . (>>= guard .)
12:46:04 <lambdabot> parse error on input `)'
12:46:16 <ilyak_> Botje_: :))
12:46:34 <ilyak_> I guess that should made to fortunes of some kind
12:46:45 <mauke> :t (>>= (>>)) . (flip (>>=) . (guard .))
12:46:46 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => (a -> Bool) -> m a -> m a
12:46:48 <Botje_> geezusfreeek: hmm, then you'd have to load at least a gigabyte of data before popping up the dialog
12:46:52 <resiak> mauke: isn't that running m twice?
12:46:56 <geezusfreeek> easy enough
12:47:03 <mauke> resiak: yes
12:47:13 <resiak> this seems .. undesirable :-)
12:47:20 <mauke> why? m = Maybe
12:47:46 <atp> but if we're doing MonadPlus ...
12:47:49 <mauke> @pl \p m -> (m >>= guard) >> m
12:47:49 <lambdabot> const ((>>) =<< (guard =<<))
12:48:00 <resiak> Surely there are some MonadPluses where running the action twice is a Bad Idea
12:48:05 <geezusfreeek> @unpl (>>= (>>)) . (flip (>>=) . (guard .))
12:48:05 <lambdabot> (\ h -> (\ d -> d >>= \ n -> guard (h n)) >>= (>>))
12:48:14 <mauke> @pl \p m -> (m >>= guard . p) >> m
12:48:14 <lambdabot> join . ((>>) .) . (=<<) . (guard .)
12:48:51 <resiak> @pl \p m -> (m >>= \x -> (guard p >> return x))
12:48:51 <lambdabot> (=<<) . (. return) . (>>) . guard
12:48:59 <atp> i was more hoping something along the lines of not . null `libraryFunction` (Just []) -> Nothing
12:49:06 <conal> where does 'cabal install' place package sources?  i've found the cached .tar.gz files, but not the untar'd-gz'd sources.
12:49:08 <atp> you know, something readable :)
12:49:15 <resiak> atp: oh, if that's all you need
12:49:26 <atp> then?
12:49:31 <resiak> > join (fmap listToMaybe) (Just [])
12:49:31 <lambdabot>      Occurs check: cannot construct the infinite type: f = (->) (f [a])
12:49:31 <lambdabot>     P...
12:49:41 <resiak> hmm.
12:49:44 <geezusfreeek> make your own :P
12:49:50 <resiak> > (join . fmap listToMaybe) (Just [])
12:49:52 <lambdabot>  Nothing
12:49:55 <resiak> > (join . fmap listToMaybe) (Just [5])
12:49:56 <lambdabot>  Just 5
12:50:16 <geezusfreeek> it would be awesome if ghc had djinn built in and could just build functions from types if you wanted
12:50:19 <resiak> oh, but you presumably want more than one value from the list :)
12:50:36 <geezusfreeek> some select functions anyway
12:50:42 <atp> geezusfreeek: yes, that's what i've done, but it seemed like it would be such a useful function... to be able to apply a predicate into a MonadZero and have it give me mzero if the predicate returs false and the original functor if it doesn't
12:51:17 <dons> hackathon photos, http://blog.well-typed.com/2008/04/hac4-last-day/ :)
12:51:18 <lambdabot> Title: blog.well-typed.com » Blog Archive » Hac4: Last day
12:51:46 <geezusfreeek> oh you want it generically
12:52:02 <atp> yeah
12:52:10 <atp> doesn't that seem like it would be useful?
12:52:15 <atp> or am i just smoking the wild ganja again
12:52:46 <geezusfreeek> seems at least a little useful
12:53:32 <atp> something like not . null <?> mlist
12:53:35 <atp> yes
12:53:39 <atp> hm
12:53:45 <atp> :t (<?>)
12:53:46 <lambdabot> Not in scope: `<?>'
12:54:21 <atp> :t (?)
12:54:22 <lambdabot> Not in scope: `?'
12:54:25 <skorpan> how do i tell ghc which directories to search for dependencies?
12:54:33 <atp> are we allowed to use ? in haskell?
12:54:44 <atp> seems surprising that it hasn't been used yet
12:54:44 <geezusfreeek> i don't see why not
12:55:03 <geezusfreeek> http://haskell.org/hoogle/?q=%3F
12:55:32 <atp> hm
12:55:37 <atp> weird that (?) isn't defined
12:55:41 <atp> p ? mlist
12:56:04 <geezusfreeek> sometimes you don't want such a lightweight operator
12:56:13 <geezusfreeek> visually, i mean
12:56:17 <atp> yeah.
12:56:54 <geezusfreeek> using just ? looks almost like some sort of a lookup function or something
12:57:08 <geezusfreeek> something that would return a Bool or something
12:57:17 <atp> well, p does return a Bool...
12:57:24 <atp> but i see what you mean.
12:57:26 <geezusfreeek> well, i mean the whole expression
12:57:27 <atp> maybe <?> is better
12:57:30 <Cale> Usually infix operators have less questionable behaviour than ? would suggest, I suppose :)
12:57:50 <atp> it kind of recalls the applicative operators which is nice
12:57:58 <atp> because it's apply a function to the inside of the functor
12:58:01 <atp> applying
12:58:02 <paolino> <?> is a parsec op
12:58:05 <atp> oh right
12:58:06 <atp> i forgot.
12:58:12 <atp> i knew i'd seen that somewhere.
12:59:21 <atp> i was going to say <$?> but that's a parsec op too...
12:59:25 <atp> sigh.
12:59:49 <atp> although, <|> is both a parsec op and an applicative op... alternatives iirc
13:00:14 <geezusfreeek> they also mean the same thing, don't they?
13:00:16 <Cale> Fortunately in that case, it does the same thing
13:00:49 <atp> yeah.
13:01:49 <atp> obviously this operator isn't that useful, or some schmuck would have beaten me to defining it
13:02:36 <geezusfreeek> just look for other possible uses of it and if enough come up then reconsider
13:03:40 <atp> i mean, i guess it just seems like you might often be in a situation where you're representing Nothing as failure and you'd like to be able to check that the value inside the Just is valid
13:04:15 <geezusfreeek> you are right that it does sound useful
13:04:28 <atp> making it Nothing if it's not and continuing on if it is, rather like guard but more applicative-y
13:04:49 <atp> and if we're defining it on Maybe might as well define it on MonadZero
13:05:28 <geezusfreeek> :t guard
13:05:29 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
13:06:09 <atp> actually in general a combinator cond p f g x = if p x then f x else g x is pretty useful
13:06:44 <atp> cond null (const Nothing) Just
13:07:08 <atp> at some point it all reduces to ski calculus though :)
13:09:10 <Peaker> sounds like a job for:  f :: (Monad m, Monad n) => m a -> n a   but that seems impossible
13:09:49 <atp> generally impossible, but in specific instances possible
13:09:50 <Peaker> (and ill defined :-)
13:10:12 <atp> atomically, isn't there some STtoIO function
13:10:18 <atp> obviously not called that
13:10:22 <atp> i don't use ST or IO much
13:10:37 <Peaker> I bet you use IO at least once per program! :)
13:10:57 <atp> you know, i often sit in the REPL like a lisp hacker
13:11:09 <atp> but yeah, for programs i actually compile obviously i do :)
13:11:42 <atp> this recent program i've been writing for work uses a lot more IO than usual
13:11:56 <atp> it's a marriage made in heaven
13:12:07 <atp> a haskell network server talking to an excel visual basic macro
13:12:16 <atp> ahh, corporate programming
13:12:38 <cabbage> Hello all. So I know there used to be this repository for Debian/Ubuntu where you could get "experimental" new GHC versions that weren't. in the main repo. Does such a thing still exist? Where? (I wanted to use a library, but it turns out it needs Cabal >=1.2, and Ubuntu 7.10 comes with GHC 6.6.1 which doesn't have that.)
13:13:04 <atp> debian and ubuntu are quite different
13:13:13 <atp> debian unstable has 6.8.2
13:13:28 <cabbage> atp, I understand this, but I recall that back when, the repository was for both. I am actually using Ubuntu.
13:14:01 <TomMD> cabbage: So far as I know you have to use the darcs repo these days if you want newer-then-current.
13:14:06 <TomMD> s/then/than
13:14:15 <atp> ok guys, girlfriend calls
13:14:18 <atp> see you all later
13:14:28 <cabbage> atp, thanks
13:14:36 <BMeph> Schucks - see ya, atp. :)
13:14:50 <TomMD> Hello BMeph - how are things going?
13:15:10 <BMeph> I was going to mention that "cond null (const Nothing) Just" looks suspiciously like "listToMaybe," though. :)
13:15:17 <Cale> cabbage: I just install the generic linux binary GHC. (On ubuntu)
13:15:59 <cabbage> cale, I guess I'll have to do that, or else forego the library and implement Voronoi graphs myself ;-)
13:16:05 <BMeph> Heya, TomMD, doing well.
13:16:27 <geezusfreeek> does anybody use the Edison library?
13:16:38 <lament> @remember atp it's a marriage made in heaven | a haskell network server talking to an excel visual basic macro
13:16:38 <lambdabot> It is forever etched in my memory.
13:20:59 <g234567890123456> oops
13:43:58 <andyjgill> Is there a tutorial on using the Haskell SDL bindings?
13:50:00 <Sadache> does any one have a reference to an article or paper that explains when to use foldr and when to use foldl?
13:50:26 <Sadache> i know the difference between them, yet i cant grasp well their usage
13:50:30 <dons> never use foldl :)
13:50:44 <dons> foldl only makes sense in a strict language, basically.
13:50:59 <dons> so either use foldl' or foldr. foldr is most idiomatic in haskell
13:51:20 <Sadache> what is foldl'
13:51:58 <dons> its a version of foldl that is strict in its accumulator
13:52:06 <Sadache> what to use for concatening lists? flodr (++)?
13:52:09 <dons> so no lazy thunks are built up in the loop's state.
13:52:11 <dons> yep
13:52:16 <dons> > "foo " ++ "bar"
13:52:18 <lambdabot>  "foo bar"
13:52:29 <dons> > concat ["foo ", "bar"]
13:52:32 <lambdabot>  "foo bar"
13:52:41 <dons> > foldr1 (++) ["foo ", "bar"]
13:52:41 <lambdabot>  "foo bar"
13:52:48 <byorgey> Sadache: see http://haskell.org/haskellwiki/Stack_overflow
13:53:21 <Sadache> byorgey: thanks that is what i got, and that is what i need
13:54:03 <OceanSpray> Why are data constructors are capitalized?
13:54:03 <byorgey> yup, that page has a pretty good description
13:54:08 <byorgey> @where folds
13:54:08 <lambdabot> http://cale.yi.org/index.php/Fold_Diagrams
13:54:10 <OceanSpray> They're functions, are they not?
13:54:16 <byorgey> Sadache: ^^^ those diagrams are also nice =)
13:54:54 <Jedai> OceanSpray: They're functions too but they can also be used in a pattern (unlike normal functions)
13:57:27 <byorgey> OceanSpray: technically, there's no reason you couldn't implement a version of Haskell in which data constructors could be lowercase.
13:57:42 <byorgey> It's just a nice syntactic way to distinguish between constructors and functions.
13:58:02 <Baughn> OceanSpray: Practically, haskell is defined this way so what would otherwise be conventions are enforced in the language. That ensures that everyone follows them.
13:58:04 <allbery_b> ...when your charset distinguishes case, at least
13:58:36 * byorgey puts on his Unicode-argument-shield
13:59:14 <dons> it seems to be a reasonably harmless convention.
13:59:20 <dons> i guess GADTs confuse things a bit
13:59:27 <dons> since constructors start to look a bit more general
14:00:07 <reilly> EBCDIC RULEZ
14:00:47 <allbery_b> I was thinking nationalc haracter sets.  (EBCDIC has lowercase.  Many IBM print trains didn't.)
14:00:50 <Sadache> thanks guys, it is amazing how helpful people are in Haskell community in general
14:01:45 <dons> Sadache: we try. i hope you have a pleasant experience
14:02:22 <TomMD> And if your experience is bad, lambdabot goes on a rampage banning all the regulars.
14:02:28 <dons> yep
14:02:35 <dons> TomMD knows the score.
14:02:40 <vincenz> 2-1
14:02:57 <Sadache> dons: I certainly do :)
14:03:43 <Sadache> And i try to search before not to ask dumb questions ;)
14:03:46 <Sadache> :p
14:05:14 <chessguy> #quote
14:05:20 <chessguy> @quote
14:05:20 <lambdabot> <shapr> says: GHC has more flags than the UN.
14:05:31 <chessguy> @quote bot
14:05:31 <lambdabot> lambdabot says: lambdabot hasn't said anything memorable
14:08:08 <kolmodin> good night
14:28:37 * byorgey distributes a bunch of chocolate lambdas, one for each distinct three-coloring of the cyclic graph with ten nodes
14:29:01 <byorgey> (that's 2^10 + 2 = 1026 for anyone who's counting =)
14:29:09 * Twey giggles.
14:29:21 * Twey thinks maybe he's had too much sugar.
14:29:58 <byorgey> well, how many chocolate lambdas did you eat?
14:30:05 * olsner commits the number 1026 to memory
14:30:24 <olsner> I was suspecting it would be something silly like only one coloring being possible...
14:30:42 * Baughn eats a hundred of the things, the better to sleep tonight
14:31:05 <byorgey> hehe, maybe I should have said "distinct two-colorings of the cyclic graph with nine nodes" =)
14:31:12 <Twey> Hehe, chocolate lambdas
14:31:23 <Twey> Your stomach evaluates them into pure sugar?
14:31:40 * Botje_ eats exactly the amount of distinct three-colorings of a cyclic graph with 6 nodes
14:31:44 <byorgey> well, it extracts the sugar
14:31:46 <Botje_> *burp*
14:31:48 <Baughn> Now, now. They're chocolate. Chocolate is /healthy/.
14:31:49 <byorgey> this process is called 'desugaring'
14:32:03 <TSC> byorgey: Do you know the answer to http://projecteuler.net/index.php?section=problems&id=189 ?
14:32:05 <lambdabot> Title: Problem 189 - Project Euler
14:32:43 <byorgey> TSC: not yet.  That's why I'm investigating graph three-colorings. =)
14:32:51 <TSC> Ah (:
14:33:37 <paczesiowa> Baughn: anything new with that bug?
14:33:54 <TSC> There's a woman in my CS department who studies graph colourings; I'll have to bug her
14:34:02 <Baughn> paczesiowa: I'm no longer sure it's a bug
14:34:19 <byorgey> TSC: hehe
14:34:34 <Baughn> paczesiowa: I mean, yes it's a bug, but..
14:34:45 <byorgey> I'm sure it's been done before in full generality, but I'm having fun figuring out as much as I can on my own
14:34:56 <Baughn> paczesiowa: It just bugs me. It's too obvious - it makes no sense that nobody else would have noticed.
14:34:58 <gwern> @src unlines
14:34:58 <lambdabot> unlines = concatMap (++ "\n")
14:35:16 <byorgey> so far, I know how to compute the number of three-colorings of arbitrary paths, cycles, cycles with one chord, and various combinations of them
14:35:48 <Baughn> Wouldn't "arbitrary paths" cover all of them?
14:36:20 <paczesiowa> Baughn: can't you show it to some ghc developer? it's easy and small piece of code. (I'd do it myself, but I'm scared of them and I don't want to waste their time)
14:36:42 <byorgey> Baughn: well, by "arbitrary paths" I meant graphs with nodes 1..n and edges 1-2, 2-3, ..., (n-1)-n
14:36:53 <Baughn> paczesiowa: I'm scared of them and don't want to waste their time.
14:37:05 <olsner> hmm, isn't there a standard method for decomposing graphs and calculating their chromatic numbers from the components?
14:37:17 <olsner> I seem to remember something like this from my discrete mathematics course
14:37:23 <Baughn> byorgey: Just "lists of length n", then?
14:37:24 * geezusfreeek really should learn some graph theory
14:37:32 <byorgey> olsner: probably, but note "chromatic number" means the minimum number of colors needed to color the graph
14:37:44 <gwern> hm. an 'append
14:37:44 <byorgey> olsner: which is different than counting the number of distinct such colorings
14:37:51 <gwern> operator would add to the end of a list right?
14:37:54 <byorgey> Baughn: yeah =)
14:38:34 <olsner> byorgey: hmm, yeah, I'm probably mixing up a bunch of stuff here
14:38:46 <paczesiowa> Baughn: so we need to find sameone brave enough to do it for us:P
14:38:46 <geezusfreeek> gwern: is this a question of terminology?
14:38:57 <geezusfreeek> gwern: i would think that would be what append means
14:39:00 <Baughn> paczesiowa: Pretty much, yes.
14:39:17 <gwern> geezusfreeek: I am not certain that the ByteString append does what I think it does
14:40:25 <Baughn> paczesiowa: From my point of view, anyone who understands everything ghc can do is /scary/. I'm sure that will change once I reach that level myself, but then again, there's also the possibility that I'll be in a permanent state of autophobia.
14:40:30 <geezusfreeek> hmmâ€¦ looking at the type, the word "append" doesn't seem quite right to me
14:40:37 <olsner> byorgey: the chromatic *polynomial* seems to be what I'm thinking of
14:40:45 <Twey> Baughn: Hahahahahaha
14:41:03 <geezusfreeek> looks like it should just be (++), doesn't it?
14:41:06 <paczesiowa> Baughn: :D
14:41:41 <olsner> @remember Baughn From my point of view, anyone who understands everything ghc can do is /scary/. I'm sure that will change once I reach that level myself, but then again, there's also the possibility that I'll be in a permanent state of autophobia.
14:41:42 <lambdabot> Okay.
14:41:47 <olsner> :D
14:41:54 <gwern> geezusfreeek: well, ++ would imply [ByteString], while I want to add two ByteStrings and get a ByteString
14:41:55 <Baughn> paczesiowa: That said, I'll write up a bug report tomorrow before noon. Too late now.
14:42:02 <geezusfreeek> time to write a little program to reveal how much i owe my roommate
14:42:28 <paczesiowa> Baughn: thanks for facing you own fear:>
14:42:38 <geezusfreeek> gwern: i mean in the sense that (++) can be considered String -> String -> String
14:42:41 <hpaste>  morrow pasted "toTree :: TypeRep -> Tree TyCon" at http://hpaste.org/6969
14:42:44 <geezusfreeek> > "foo" ++ "bar"
14:42:45 <lambdabot>  "foobar"
14:43:08 <byorgey> olsner: interesting, I will have to look that up
14:43:19 <geezusfreeek> i guess "append" isn't too much of a misnomer
14:43:24 <geezusfreeek> after all, mappend is the same thing
14:43:42 <geezusfreeek> > "foo" `mappend` "bar"
14:43:42 <lambdabot>  "foobar"
14:44:27 <gwern> hm. here the problem is I expect 'append x y = y ++ x', I suppose
14:44:45 <tromp> @let f = 0 : scanl 6 (map (*2) f)
14:44:45 <lambdabot> <local>:2:26:     Ambiguous occurrence `f'     It could refer to either `L.f'...
14:44:48 <tromp> take 10 f
14:44:58 <gwern> :t append
14:44:59 <lambdabot> Not in scope: `append'
14:45:04 <tromp> @let colors = 0 : scanl 6 (map (*2) colors)
14:45:04 <lambdabot> Couldn't match expected type `[t]'
14:45:17 <Baughn> > "foo" `(flip mappend)` "bar"
14:45:17 <lambdabot>  Parse error at "(flip" (column 8)
14:45:17 <tromp> @let colors = 0 : scanl (+) 6 (map (*2) colors)
14:45:18 <lambdabot> Defined.
14:45:21 <geezusfreeek> gwern: you mean you are reading append x y as "append x to the end of y"? yeah, that's not right ;)
14:45:25 <tromp> take 10 colors
14:45:33 <tromp> > take 10 colors
14:45:34 <lambdabot>  [0,6,6,18,30,66,126,258,510,1026]
14:45:56 <gwern> geezusfreeek: the problem is, that makes more sense for mapping - 'map (append '\n') list', y'know?
14:46:23 <geezusfreeek> gwern: but that would be the wrong type anyway
14:46:23 <gwern> yeah. the bystring source says 'append xs ys = ... concat [xs,ys]
14:46:30 <tromp> 1026 seems right, byorgy
14:46:37 <geezusfreeek> it would have to be append "\n"
14:46:54 <tromp> i mean byorgey
14:47:13 <gwern> geezusfreeek: right right, but you see what I mean about the arg order
14:47:15 <geezusfreeek> gwern: you could always say (`append` "\n") or something
14:47:18 * olsner gets suddenly fired up about graphs
14:47:38 <gwern> geezusfreeek: hm. can you section infix like that?
14:47:47 <geezusfreeek> i don't know, but i would think so
14:48:02 <geezusfreeek> > (`mappend` "bar") "foo"
14:48:03 <lambdabot>  "foobar"
14:48:04 <Botje_> @fac can haskell section infix functions?
14:48:04 <lambdabot> Maybe you meant: fact fact-cons fact-delete fact-set fact-snoc fact-update faq
14:48:05 <geezusfreeek> works
14:48:08 <Botje_> @faq can haskell section infix functions?
14:48:08 <lambdabot> The answer is: Yes! Haskell can do that.
14:48:33 <gwern> oh, I don't think it'd work anyway, since bytestring is import qualified - I've tried to do stuff like `B.foo` and it didn't work
14:48:54 <gwern> (hm. or does it?)
14:49:04 <byorgey> tromp: yup
14:49:12 <Saizan> B.`foo` ?
14:49:25 <geezusfreeek> i'm thinking what Saizan said might work
14:49:26 <Saizan> one of the two options work
14:49:36 <byorgey> > map (\n -> 2^n + 2*(-1)^n) [1..10]
14:49:37 <lambdabot>  [0,6,6,18,30,66,126,258,510,1026]
14:49:43 <gwern> Saizan: ... B.`foo` would work? wow, I've never seen it written that way
14:49:49 <byorgey> @oeis 6,6,18,30
14:49:49 <lambdabot> Number of ways of 3-coloring an annulus consisting of n zones joined like a p...
14:49:49 <lambdabot> [0,6,6,18,30,66,126,258,510,1026,2046,4098,8190,16386,32766,65538,131070,2621...
14:49:54 <byorgey> =D
14:50:06 <byorgey> olsner++
14:50:14 <byorgey> chromatic polynomial it is!
14:50:41 <gwern> @pl unlinesPS w = B.concat $ map (`B.append` (B.pack "\n")) w
14:50:41 <lambdabot> (line 1, column 13):
14:50:41 <lambdabot> unexpected "="
14:50:41 <lambdabot> expecting variable, "(", operator or end of input
14:50:41 <byorgey> chi(G;k) = chi(G - e;k) - chi(G * e;k)
14:51:04 <gwern> @pl unlinesPS w = concat $ map (`append` (pack "\n")) w
14:51:04 <lambdabot> unlinesPS = ((`append` pack "\n") =<<)
14:51:14 <DRMacIver> Hm
14:51:23 <gwern> huh. the list monad strikes again
14:51:28 <Saizan> > "a" Data.Monoid.`mappend` "b" -- test
14:51:28 <lambdabot>  Parse error at "`mapp..." (column 17)
14:51:30 <DRMacIver> Why are there separate System.FilePath.Windows and System.FilePath.Posix modules?
14:51:38 <Saizan> > "a" `Data.Monoid.mappend` "b" -- test
14:51:39 <lambdabot>  "ab"
14:51:52 <DRMacIver> They have the same interface as far as I can tell. Wouldn't it make life a lot easier if they were unified?
14:52:09 <byorgey> TSC: google for "chromatic polynomial" =)
14:52:10 <Saizan> DRMacIver: why?
14:52:21 <gwern> unlinesPS = B.concat . map (`B.append` (B.pack "\n")) <-- good enough I suppose
14:52:32 <Saizan> DRMacIver: System.FilePath exports the one of the current platform
14:52:36 <gwern> DRMacIver: maybe the semantics are different even if the names are the same
14:53:07 <DRMacIver> Saizan: Oh, it does? Ok. I've misunderstood what's going on. :)
14:53:18 <DRMacIver> My mistake.
14:53:49 <gwern> (Wow, yi has gotten so many patches in the past few days)
14:54:01 <geezusfreeek> is there a standard permute function?
14:54:57 <tromp> no0
14:55:06 <geezusfreeek> aw
14:55:54 <gwern> geezusfreeek: it's the old dogshed problem
14:56:01 <gwern> (kind of like the split functions)
14:56:33 <geezusfreeek> i actually am not familiar with "dogshed problem"
14:56:44 <Frem> Greetings! Would any of you fine gentlemen happen to know which module I'd need to load in hugs98 to use bit shifting? The documentation is not helping much; perhaps I'm just not looking in the right places?
14:56:49 <tromp> @let permute = join (evalStateT . mapM (const (StateT pick))) where pick [] = []; pick (x:xs) = (x,xs) : map (second (x:)) (pick xs)
14:56:49 <lambdabot> Defined.
14:57:04 <geezusfreeek> but i infer that you mean that there is no consensus on the proper way to do it?
14:57:05 <gwern> @hoogle xor
14:57:09 <lambdabot> Data.Bits.xor :: Bits a => a -> a -> a
14:57:17 <gwern> geezusfreeek: something like that
14:58:27 <gwern> Frem: does Data.Bits d'you fine?
15:01:10 <sgillespie> what does the '@' symbol mean in haskell?
15:01:33 <solrize_> in a pattern match it means to bind a partial match to a symbol, i.e.
15:01:35 <Frem> gwern, ":module Data.Bits" and ":module Bits" are both returning "cannot find module" errors.
15:02:07 <tromp> > permute "bit"
15:02:11 <lambdabot>  ["bit","bti","ibt","itb","tbi","tib"]
15:02:28 <sgillespie> can you give me an example?
15:02:30 <gwern> Frem: dunno; sounds like you have install problems. I thought data.bits was pretty standard
15:02:35 <solrize_> a x@(2:3):xs =  x:(tail xs)
15:02:44 <Frem> gwern, Oh, ok. Thanks.
15:02:50 <solrize_> takes a list starting with 2:3 and chops the 3rd element   ok lousy example :)
15:03:02 <gwern> might want to search your system for a Bits.hs, see if it's there
15:03:15 <Frem> gwern, 'Ight
15:03:17 <gwern> (although that'd probably only be good for a source-based distro)
15:03:21 <geezusfreeek> oh shoot, i guess permutations won't help me in this case anyway. this is a list of 27 elements!
15:03:30 <geezusfreeek> not without some filtering at least
15:03:44 <sgillespie> in that example x is binded to (2:3)?
15:03:45 <olsner> > product [1..27]
15:03:45 <lambdabot>  10888869450418352160768000000
15:03:59 <solrize_> yes
15:04:04 <sgillespie> okay
15:04:05 <solrize_> i'm trying to find you a more precise explanation
15:04:26 <sgillespie> is it a ghc extension, or is it haskell98?
15:04:33 <solrize_> standard haskell i'm pretty sure
15:04:38 <sgillespie> alrighty
15:04:40 <geezusfreeek> my problem is almost like something from project euler
15:04:43 <sgillespie> thanks for your help
15:04:45 <Botje_> sigh
15:04:50 <Botje_> i should really get started on my compiler
15:05:00 <Botje_> only two more months and the parser isn't even done yet :)
15:05:16 <vincenz> > product [1..64
15:05:16 <lambdabot>  Parse error at end of input
15:05:22 <vincenz> > product [1..64]
15:05:22 <lambdabot>  1268869321858841641034333893351614808028655161745451921988018943752147042304...
15:05:32 <vincenz> > product [1..63]
15:05:33 <lambdabot>  1982608315404440064116146708361898137544773690227268628106279599612729753600...
15:05:51 <solrize_> weird, YAHT doesn't expalin it, it just starts using it with no explanation
15:07:02 <solrize_> http://www.haskell.org/tutorial/patterns.html   here ya go sgillespie
15:07:02 <lambdabot> Title: A Gentle Introduction to Haskell: Patterns
15:08:28 <geezusfreeek> i have a list of bills. generally my roommate pays them and then i pay him back my half later, usually in bulk, so i also have a list of checks that i have written him. of these, one is incorrect and another was inadvertently skipped, and there is one extra large one yet to be payed. i'm trying to figure out how much the yet-to-be-payed check should be to account for the other flaws. this would still be pretty easy except that
15:09:02 <geezusfreeek> i'm thinking of writing a program that tries to match checks with bills to cancel them out
15:09:07 <geezusfreeek> and then see what's left
15:09:37 <geezusfreeek> also accounting for the fact that not all bills will be covered due to the list of checks starting later
15:09:47 <gwern> sounds like an interesting problem: 'what is the optimal matching of check to bill such that the absolute value of their sums is as small as possible?'
15:09:55 <geezusfreeek> oh, i also know when the checks were written
15:10:01 <geezusfreeek> and when the bills were due
15:10:05 <geezusfreeek> but not how long i waited
15:10:07 <gwern> where check = a positive number and bill = a negative number
15:10:54 <Bonus> yo guys is there a function like filter only that it gives the index of the element as the argument to the function supplied to it instead of the element itself?
15:11:21 <Botje_> findwithindex?
15:11:28 <Bonus> lemme check if that's it
15:11:35 <Botje_> @hoogle withindex
15:11:44 <lambdabot> No matches found
15:11:52 <shachaf> > filter (even . fst) . zip [0..] $ "abcdefg"
15:11:52 <lambdabot>  [(0,'a'),(2,'c'),(4,'e'),(6,'g')]
15:11:57 <shachaf> > map snd . filter (even . fst) . zip [0..] $ "abcdefg"
15:11:58 <lambdabot>  "aceg"
15:12:03 <Bonus> i wrote one like it already
15:12:06 <Bonus> filterIndex k lst = map snd $ filter (\(i, elem) -> k i) $ (zip [0 .. (length lst) -1] lst)
15:12:22 <Bonus> only i was wondering if there's one already somewhere in Haskell
15:12:23 <vincenz> Bonus: just drop
15:12:27 <vincenz> zip [0..
15:12:32 <vincenz> Bonus: bad idea to do length lst
15:12:36 <Bonus> oh
15:12:36 <vincenz> it won't work for infinite lists
15:12:52 <Bonus> yeah i guess you're right better to just do [0..]
15:13:04 <vincenz> also, don't you mean [1..]
15:13:20 <Bonus> uh no because the index of the first element is 0
15:13:23 <Bonus> at least that's how i view it
15:13:38 <Saizan> that's how (!!) works too
15:13:48 <Bonus> yeah
15:14:31 <Saizan> ?type curry fst
15:14:32 <lambdabot> forall a b. a -> b -> a
15:14:38 <shachaf> @let filterIndex f = map snd . filter (f . fst) . zip [0..]
15:14:39 <lambdabot> Defined.
15:15:13 <Bonus> does anyone know a way to split a 9x9 list into 9 3x3 lists?
15:15:23 <Bonus> i've been wracking my brain with that, still new to haskell
15:15:57 <Botje_> Bonus: you want the individual boxes of a sudoku?
15:16:02 <Bonus> yeah something like that
15:19:21 <bockmabe_> Does anyone have recommendations for expect like interaction with haskell.
15:19:23 <bockmabe_> ?
15:19:33 <Bonus> also is there a built in function to split an array into several arrays of length x?
15:19:56 <Botje_> Bonus: not built-in, no
15:20:16 <Bonus> aha, ok
15:20:39 <Bonus> i'm always worried that i'm needlessly reimplementing built in functions because i'm not so familiar with what the built ins are :)
15:21:05 <Korollary> use hoogle
15:21:32 <Korollary> @where hoogle
15:21:32 <lambdabot> http://haskell.org/hoogle
15:21:38 <gwern> @src lines
15:21:38 <lambdabot> Source not found. :(
15:21:44 <Bonus> yeah, but implementing them is rather fun actually :)
15:23:54 <gwern> > lines "foo\nbar\n\n"
15:23:55 <lambdabot>  ["foo","bar",""]
15:24:15 <gwern> > lines "foo\nbar\n"
15:24:15 <lambdabot>  ["foo","bar"]
15:24:34 <Bonus> show "Im gay"
15:24:40 <Bonus> lol
15:25:14 <lambdabot> Bonus: You're gay
15:25:20 <Bonus> haha
15:25:21 <Bonus> touche
15:25:27 <gwern> > show "Bonus is gay"
15:25:28 <lambdabot>  "\"Bonus is gay\""
15:25:38 <Bonus> >:[
15:25:38 <lambdabot> Bonus: gwern is gay too
15:25:52 <Botje_> happy happy gay functional programmers!
15:25:57 <gwern> @smack lambdabot
15:25:57 * lambdabot pulls lambdabot through the Evil Mangler
15:26:16 <olsner> byorgey: unfortunately, the problem of finding the chromatic polynomial is exponential-time unless you can do something clever specific to the graph in the problem
15:26:28 <vincenz> @smack gwern
15:26:28 * lambdabot locks up gwern in a Monad
15:26:34 <vincenz> ouch
15:26:39 <vincenz> you're stuck, my friend
15:26:54 <olsner> (but i do wonder if extensive memoization can be of help there)
15:27:03 <gwern> > unsafePerformIO gwern
15:27:03 <lambdabot>   Not in scope: `gwern'
15:27:25 * vincenz inlines to get 2 gwerns
15:27:45 <olsner> > let gwern = unsafePerformIO gwern in gwern == fix unsafePerformIO
15:27:45 <lambdabot>   Not in scope: `unsafePerformIO'
15:28:16 * gwern and the clone attack vincenz and escape the monad
15:29:07 <olsner> but you can also just snd, head, fromJust or (\Right x -> x) gwern out of a monad
15:29:24 <vincenz> he's in the ContT monad
15:29:28 <vincenz> forever more to repeat his mistakes
15:30:13 <gwern> Nooooo....
15:30:36 <vincenz> callcc
15:33:22 <gwern> @pl (\x -> append (pack "\n") x)
15:33:23 <lambdabot> append (pack "\n")
15:33:41 <gwern> @pl (\x -> append x (pack "\n"))
15:33:41 <lambdabot> flip append (pack "\n")
15:34:21 <gwern> thought so
15:38:02 <solrize_> @seen shapr
15:38:02 <lambdabot> shapr is in #haskell-blah, #scannedinavian and #haskell. I last heard shapr speak 2h 37m 5s ago.
15:38:57 <bockmabe_> so, noone knows of expect-like interraction module for haskell?
15:41:04 <hpaste>  DRMacIver pasted "openFile: does not exist (No such file or directory) " at http://hpaste.org/6970
15:41:18 <tromp> > 272+89
15:41:20 <lambdabot>  361
15:41:32 <DRMacIver> Having a bit of trouble with this code. (It's a simple offline merge sort). Looks like I've screwed up the file handling somewhere and it's getting confused between relative and absolute paths.
15:41:46 <DRMacIver> Anyone mind taking a quick eyeball at it and see if it's obvious where? :)
15:42:27 <DRMacIver> (Oh, I've actually commented out the sorting code, but this exhibits the same problem)
15:43:33 <DRMacIver> (Yes, it's very IOey. It's meant to be)
15:49:45 <gwern> @hoogle append
15:49:46 <lambdabot> Data.ByteString.append :: ByteString -> ByteString -> ByteString
15:49:46 <lambdabot> Data.ByteString.Char8.append :: ByteString -> ByteString -> ByteString
15:49:46 <lambdabot> Data.ByteString.Lazy.append :: ByteString -> ByteString -> ByteString
15:59:41 <tromp> > 4*66250
15:59:42 <lambdabot>  265000
16:02:42 <nornagon> <lambdabot> Here I am, brain the size of a planet, and you ask me to perform multiplication.
16:03:16 <Botje_> :D
16:03:23 <Botje_> @vixen are you sentient?
16:03:23 <lambdabot> i truely am
16:04:03 <gwern> what? that's not spelled right.
16:04:15 <shachaf> @faq Can Haskell write sentient bots?
16:04:15 <lambdabot> The answer is: Yes! Haskell can do that.
16:04:42 <lament> @vixen Let's go shopping.
16:04:42 <lambdabot> i enjoy talking to you
16:04:47 <lament> <3
16:04:51 <Botje_> :D
16:04:53 <Botje_> lament++
16:05:12 <shachaf> @faq Can Haskell grow moldy?
16:05:12 <lambdabot> The answer is: Yes! Haskell can do that.
16:05:19 <Botje_> eww
16:05:38 <lament> yummy bitrot
16:05:51 <lament> hackage tofu
16:06:40 <goalieca> go habs go!
16:06:52 <fnoble> basic question, but how does one define multiple values using where?
16:07:07 <shachaf> @faq Can Haskell strangle you in your sleep if you don't feed it?
16:07:07 <lambdabot> The answer is: Yes! Haskell can do that.
16:07:15 <Japsu> > a + b where { a = 5; b = 2 }
16:07:15 <lambdabot>  Parse error at "where" (column 7)
16:07:18 <Japsu> bah
16:07:29 <shachaf> fnoble: "f x = y\n    where y = z\n    z = x"
16:07:35 <Japsu> > let { a = 5; b = 2 } in a + b
16:07:36 <lambdabot>  7
16:07:37 <shachaf> Hmm, misindented.
16:07:45 <czakey> @msg #haskell :)
16:07:45 <Japsu> anyway
16:07:45 <lambdabot> Not enough privileges
16:07:53 <czakey> ;)
16:07:54 <Japsu> just separate them by newlines and correct indentation
16:07:57 <lament> fnoble: the same as multiline let: each variable on its line, all indented the same way
16:08:12 <czakey> @listmodules
16:08:12 <lambdabot> activity babel base bf check compose dice dict djinn dummy elite eval fact figlet free fresh ft haddock help hoogle instances irc karma localtime log maya more oeis offlinerc pl pointful poll pretty
16:08:12 <lambdabot> quote search seen slap small source spell state system tell todo topic type undo unlambda unmtl url version vixen where
16:08:16 <fnoble> ok thanks
16:08:52 <czakey> @activity-full
16:08:53 <lambdabot> Not enough privileges
16:09:01 <czakey> :/
16:09:05 <lament> > case 1 of 1 -> a + b where {a = 5; b = 2}
16:09:05 <lambdabot>  7
16:09:33 <lament> (where is a subclause of case expressions and function definitions)
16:10:20 <fnoble> thanks, thats upgraded me to a 4% genius in haskell according to project euler :)
16:10:32 <fnoble> getting there
16:10:49 <lament> nice, that's like 0.4 micro-olegs
16:11:21 <SamB> lament: it would be 4 milli-olegs if he had done it in the typesystem ;-)
16:12:01 <gwern> this is annoying. are there no QuickCheck Arbtirary instances for bytestring?
16:12:24 <Botje_> B.pack . arbitrary?
16:12:50 <gwern> @hoogle arbitrary
16:12:50 <lambdabot> No matches found
16:13:01 <fnoble> is the haskell type system a turing complete language do you think?
16:13:11 <Botje_> Test.QuickCheck.arbitrary :: Arbitrary a => Gen a
16:13:13 <Botje_> hmm
16:13:15 <Botje_> nevermind :)
16:13:23 <gwern> fnoble: it is
16:13:23 <lament> fnoble: with GHC extensions, it is
16:13:28 <gwern> with extensions anyway
16:13:40 <Saizan> fmap B.pack arbitrary
16:13:47 <Saizan> Gen is a monad, no?
16:13:49 <lament> fnoble: the problem with turing-completeness is that as its first consequence, the programs are not guaranteed to terminate
16:14:04 <lament> fnoble: so you want to avoid a turing-complete type system, because then your program may never finish to compile
16:14:16 <lament> fnoble: however, with GHC extensions, that indeed may happen.
16:14:18 <fnoble> well... yes
16:14:33 <Saizan> especially -fallow-undecidable-instances :)
16:14:52 <fnoble> heh
16:15:32 <Bonus> i made a function to check the correctness of a sudoku puzzle -> http://dpaste.com/44659/
16:15:47 <ddarius> Saizan: Only that one.
16:15:53 <ddarius> (modulo potential bugs)
16:15:58 * glguy never understood the concern with having programs that never finish compiling
16:16:02 <Bonus> is there any stuff that i solved really badly?
16:16:06 <glguy> We do just find with programs that never finish running
16:16:18 <lament> (which, incidentally, means either "pale red undecidable instances", or "pale yellow undecidable instances", or "undecidable instances that were plowed but left unsowed")
16:16:58 <gwern> the heck? there is no Arbitrary instance for Char?
16:17:04 <lament> glguy: i agree, it would be nice to have a language with a powerful, simple type sysetm where TC is built-in right from the start
16:17:42 <lament> (but i suspect it would feel too much like a dynamic language)
16:17:54 <ddarius> lament: There's Cayenne, Qi, Aldor, some others.
16:18:00 <thoughtpolice> is there an haskell-mode command to quickly insert a haddock-style module description at the top of a module? (stating name, author, portability, stability, etc)
16:18:04 <Botje_> Bonus: all (==True) ~~ and
16:18:06 <fnoble> well, even if you cant prove the compile time finite, doesnt mean that for most normal programs it wont finish
16:18:24 <Bonus> what?
16:18:31 <glguy> never write ==True or ==False
16:18:33 <Botje_> all (== True) is equivalent to and
16:18:41 <lament> fnoble: no, it means that there will be a class of bugs that stop the compilation from completing
16:18:42 <Bonus> aha
16:18:47 <Bonus> :t and
16:18:47 <ddarius> @src all
16:18:47 <lambdabot> all p =  and . map p
16:18:47 <lambdabot> [Bool] -> Bool
16:18:49 <lament> fnoble: and you would have to be able to find and debug them, etc
16:19:00 <ddarius> (== True) == id so that's all id = and . map id = and
16:19:14 <Bonus> aha i see cool
16:19:18 <Baughn> lament: There should also be a class of bugs that are impossible to find and debug
16:19:36 <Botje_> Bonus: i'd also look at splitAt if i were you
16:19:50 <Baughn> That's really a good thing, though. I don't think I'd like a language so limited as to avoid those. ;)
16:19:52 <Bonus> aha, cool
16:20:04 <fnoble> lament: you cant fix it, you cant tell which programs will cause that behaviour i think
16:20:10 <Botje_> although your split is good too
16:20:18 <lament> Baughn: as well as a bunch of programs whose existence you can prove, but which you can never write? :)
16:20:29 <Baughn> lament: Yep. :P
16:20:30 <Botje_> concat (map f l ) ~~ concatMap f l
16:21:09 <Baughn> Hm.. specifically, I guess, there are programs that implement an AI in the type system that you can never prove will successfully compile.
16:21:10 <Bonus> aha
16:21:14 <lament> fnoble: right, you can't fix it in the general case, but you will need to do something about each individual case where your program stops compiling all of a sudden
16:21:18 <Bonus> concatMap i never knew about that
16:21:26 <lament> just another type of bug, that doesn't arise normally
16:22:14 <lament> nothing magical and not much different from a run-time infinite loop
16:22:33 <glguy> We need a language that isn't powerful enough to express numbers so that we don't have math errors
16:22:52 <lament> glguy: HTML
16:23:05 <Baughn> lament: I take it you've never read the HTML specification
16:23:37 <Botje_> Bonus: I take it subsections is supposed to do the 1x9x9 -> 9x3x3 transform?
16:23:42 <Bonus> yeah
16:23:47 <Bonus> that's the part of the code i don't like
16:23:48 <shapr> solrize_: ?
16:23:50 <Botje_> it looks really complicated
16:24:01 <Bonus> it takes a 3x3 subsection and gives it as a 1x9 list
16:24:11 <Bonus> yeah basically i do a whole bunch of transformations
16:24:22 <Bonus> i'm wondering how i could do that more elegantly
16:24:34 <lament> @faq Let Haskell=HTML. Can Haskell express numbers?
16:24:34 <lambdabot> The answer is: Yes! Haskell can do that.
16:25:07 <Botje_> Bonus: i was thinking something along the lines of map (split 3 . transpose) . split 3
16:25:18 <Botje_> but i'm not sure if that typechecks.
16:25:26 <Bonus> hmmm i'll have to try that
16:27:32 <Bonus> i never use the compositum operator :\
16:27:35 <gwern> woot! fixed the bug! man, quickcheck can be a pain to setup, but there's nothing like it for figuring out what apparently equivalent functions aren
16:27:42 <gwern> 't the same
16:27:51 <Bonus> is that generally more readable than just putting parens or $ around stuff
16:28:47 <Pseudonym> Bonus: Generally speaking, parenthesis soup is unreadable.
16:29:01 <Pseudonym> Parentheses should be used sparingly.  If in doubt, introduce a let.
16:29:07 <Bonus> aha
16:29:15 <Pseudonym> That doesn't mean "don't use them".
16:29:31 <Pseudonym> But as a rule of thumb, if your nesting is three-deep, it's time to introduce some combinators or a let-binding.
16:29:36 <Pseudonym> (Where "let" could mean "where".)
16:29:57 <Bonus> i see
16:30:00 <Pseudonym> Composition is best if the algorithm is a composition of passes/phases.
16:30:13 <Pseudonym> That's not the only case where it's best, but that's a really good case.
16:30:26 <Botje_> Bonus: looks like concatMap (split 3 . transpose) $ split 3 lst does the trick
16:30:29 <Pseudonym> In general, you learn style in Haskell the same way you learn style in any other language.
16:30:40 <Pseudonym> Read as much code as you can, and read it critically.
16:30:42 <Bonus> so basically (f . g) x is f (g x)
16:30:44 <Botje_> by getting bopped on the head by regulars going "OMG UGLY" ?
16:30:52 <Bonus> Botje_ really? coooooool
16:31:03 <Pseudonym> And, of course, drop in here and show us your snippets.
16:31:17 <DRMacIver> Hm. How do I test if a file is a directory?
16:31:50 <Pseudonym> As always, developing good taste is the most important thing.
16:32:00 <shachaf> DRMacIver: System.Directory.doesDirectoryExist, maybe?
16:32:18 <DRMacIver> Ah, that works. Thanks.
16:32:18 <Pseudonym> We're actually pretty relaxed about programmer-specific style, so long as it's consistent.
16:32:28 <Bonus> yeah that makes sense
16:33:15 <Bonus> now that i'm messing around a bit in haskell i see why they say that learning haskell makes you a better programmer in [insert language here]
16:33:19 <Pseudonym> Yeah.
16:33:28 <snhmib> hello! i just made a small program of conway's life in haskell, but it's superslow, could someone maybe have a look at it and give me some pointers how to make it faster?
16:33:46 <Botje_> it also makes you horribly unproductive in other languages because you keep going "OH GOD THIS IS SO MUCH EASIER IN HASKELL" every time
16:33:54 <Pseudonym> snhmib: Paste buffer is here.
16:33:57 <Pseudonym> ?paste
16:33:57 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:33:58 <Botje_> snhmib: sure, put it on hpaste if it's up
16:34:26 <Bonus> Botje yeah
16:34:37 <DRMacIver> Botje_: The worst part is that happens even before you're good at Haskell, so you're doing that in both Haskell and (imperative language). :)
16:34:38 <Bonus> although some haskell stuff can be pretty closely emulated in python
16:34:40 <Pseudonym> Botje_: Actually, it made me more productive in C++, because when faced with an algorithm that I knew was going to be hard, I knew I could always write it in Haskell first to iron out the wrinkles.
16:34:52 <Bonus> it really improved my python skill
16:34:55 <hpaste>  snhmib pasted "(no title)" at http://hpaste.org/6971
16:35:06 <Botje_> DRMacIver: I have in fact wished for the state and reader monads several times when writing ruby code
16:35:10 <snhmib> oh smart bot :)
16:35:35 <Botje_> Pseudonym: yeah, haskell is good for whipping up quick prototypes
16:35:36 <Pseudonym> snhmib: That's really beautiful layout, BTW.
16:35:51 <snhmib> o_O thanks
16:36:07 <opqdonut> :)
16:36:13 <opqdonut> yeah it's pretty neat
16:36:17 <snhmib> but it's superslow though
16:37:16 <Bonus> conway's game of life usually has O(n) complexity, right?
16:37:40 <Pseudonym> Bonus: Worst-case, yes.
16:37:53 <Pseudonym> In theory you can do better if the board is quite sparse.
16:38:08 <fnoble> O(n) in the number of cells?
16:38:08 <Botje_> snhmib: you're allocating a new array every iteration
16:38:14 <Botje_> that seems pretty slow to me
16:38:32 <Saizan> snhmib: try using an UArray Field Bool
16:38:59 <Pseudonym> Actually, this code gives me an idea.
16:39:10 <kpreid> snhmib: you can write the rules of life like so:
16:39:13 <snhmib> what is a UArray?
16:39:20 <Pseudonym> What if the board was represented as Array Field (Bool,Int)
16:39:38 <kpreid> snhmib: rules _ 3 = Alive; rules Alive 2 = Alive; rules _ _ = Dead
16:39:39 <aFlag> is there anything I can use that will make 0.1^9000 be a very small number, rather than 0? Maybe an arbitrary precision package for floating point numbers or something like that.
16:39:41 <Pseudonym> Where the Int is the number of neighbours.
16:39:55 <Pseudonym> You obviously have to fill that in lazily.
16:40:10 <Pseudonym> But that's okay.
16:40:14 <gnut> I'm trying to compile a program using Control.Parallel, but I'm getting symbol referencing errors during linking.
16:40:20 <Cale> > 0.1^9000 :: Rational
16:40:21 <lambdabot>  1%10000000000000000000000000000000000000000000000000000000000000000000000000...
16:40:22 <kpreid> snhmib: if you're interested I wrote my own (funky) implementation including that: http://kpreid.livejournal.com/8629.html
16:40:23 <lambdabot> Title: kpreid: GraphLife
16:40:28 <gnut> with ghc 6.8.2
16:40:33 <solrize_> > 9000 * log 0.1
16:40:33 <lambdabot>  -20723.265836946408
16:40:42 <Saizan> snhmib: an UArray it's an unboxed array, it'll use much less space and possibly be faster
16:40:51 <snhmib> kpreid: thanks i'll have a look at it
16:41:07 <Cale> gnut: --make ?
16:41:12 <Pseudonym> Actually, no, not much advantage there.
16:41:14 <Pseudonym> Never mind.
16:41:30 <aFlag> Cale, nice, thanks
16:42:30 <DRMacIver> (Hurray, my offline sort code works now. Just some confusion over relative and absolute paths)
16:42:47 <asdgs> I once did also de game of life
16:42:54 <asdgs> i used an IntMap
16:43:06 <asdgs> just to keep only the values of the alive cells
16:44:03 <gnut> Cale: ah... thanks.
16:44:09 <wagle> i made each cell a stream of Bool..  (just for fun)
16:45:18 <xif> what's a decent Haskell editing mode for GVim?
16:45:41 <Pseudonym> xif: The standard one is fine if you know vim well.
16:45:50 * wagle successfully refrains from saying "xemacs"...  
16:45:56 <Saizan> each cell a stream?
16:46:01 <Pseudonym> Your use of the word "decent" suggests that you're not happy with it, though.
16:46:07 <wagle> Saizan, yeah
16:46:28 <Pseudonym> wagle: That's really neat.
16:46:29 <wagle> position in the stream represents generation number
16:47:27 <glguy> sounds especially useful since the neighbors don't change
16:47:31 <glguy> you don't have to look them up more than once
16:47:35 <glguy> (their streams that is)
16:48:37 <Bonus> for editing Haskell in GVim i usually prefer insert mode and command mode :)
16:48:53 <xif> Pseudonym: it doesn't seem to handle basic stuff like indentation very well.
16:48:55 * glguy likes visual mode
16:49:02 <snhmib> Bonus: only for haskell?
16:49:11 <Bonus> haha
16:49:12 <glguy> once you turn on autoindent
16:49:14 <gnut> while my thing is compiling, will control.parallel allow my haskell code to run on sge?
16:49:17 <xif> I just entered a guarded function, it didn't reindent every line accordingly.
16:49:21 <xif> glguy: it's on.
16:49:39 <Bonus> i have autoindent on and it indents stuff nicely
16:49:42 <Bonus> guards and everything
16:49:42 <gnut> it says that haskell parallel code only runs on shared-memory MP, but does pvm count?
16:49:54 <gnut> forgive me, this is my first foray into parallel programming
16:49:55 <wagle> xif: the indenters i know cycle through the possible indentation points with repeated pressings of TAB..  you try that?
16:52:54 <Bonus> how does function composition work when functions take multiple arguments
16:53:01 <Bonus> i'm still trying to wrap my brain around that
16:53:11 <glguy> it only works on the first argument
16:53:23 <Bonus> aaaaha
16:53:26 <aFlag> it would be fun if we could write something like \begin{evaluate} haskell code \end{evaluate} so that when the .lhs is called on the latex interpreter the haskell code inside those tags is executed and its result is printed there.
16:53:38 <aFlag> Is there something in those lines?
16:54:45 <xif> wagle: yeah, but I'd expect it to indent to the right place automatically.
16:55:11 <lament> vim's haskell autoindent is kinda buggy
16:55:24 <lament> inside comments it totally loses its mind
16:55:42 <Bonus> i dont know for me it works quite nicely
16:55:50 <Bonus> when i go to a new line
16:56:02 <Bonus> it just starts the indent at the same place where the last line started
16:56:06 <Bonus> and that works fine for me
16:56:27 <mmorrow> snhmib: looks pretty!
16:56:51 <wagle> xif, not sure how it could know that
16:57:03 <xif> wagle: with function guards? :)
16:57:15 <Bonus> what does ' do in haskell?
16:57:23 <mmorrow> snhmib: (Red,Yellow)->(Blue,White) hurts my eyes less, though
16:57:27 <wagle> the indentation is part of the syntax..  its not "just whitespace"
16:57:27 <Bonus> blah blah = x:xs'
16:57:36 <SamB> wagle: are you talking about Life?
16:58:01 <s|k> hi
16:58:03 <wagle> SamB, with the cells being streams, yes
16:58:29 <SamB> how did the topic in ##c leak over to here?
16:58:43 <snhmib> sorry SamB
16:58:54 <SamB> no need to apologize
16:58:57 <gwern> @src unlines
16:58:57 <lambdabot> unlines = concatMap (++ "\n")
16:58:58 <SamB> I just think it's amusing
16:59:13 <SamB> ;-)
16:59:20 <gwern> @unlines ["foo", "bar"]
16:59:21 <lambdabot> Unknown command, try @list
16:59:23 <wagle> whats the topic in ##c??
16:59:28 <snhmib> i tried it in haskell but it's slooooooow =)
16:59:32 <gwern> > unlines ["foo", "bar"]
16:59:33 <lambdabot>  "foo\nbar\n"
16:59:34 <wagle> s/??/?/
16:59:57 <DRMacIver> Bonus: ' doesn't do anything in Haskell. It's just an allowed character in identifiers.
17:00:08 <Bonus> aha i see
17:00:23 <xif> you guys suck ;)
17:00:24 <xif> http://www.vim.org/scripts/script.php?script_id=1968
17:00:27 <lambdabot> Title: indent/haskell.vim - Haskell indent file : vim online
17:00:31 <xif> the script is out there.
17:00:45 <xif> just needed me to find it.
17:00:56 <DRMacIver> Hm. My "offline" sort appears to leak memory like crazy.
17:01:19 <mmorrow> snhmib: one of my favorite images: http://upload.wikimedia.org/wikipedia/commons/e/e5/Gospers_glider_gun.gif
17:01:20 <lambdabot> http://tinyurl.com/5v4dya
17:02:51 <snhmib> hey that looks nice
17:03:04 <olsner> mmm, hypnotic
17:03:17 <wagle> yeah..  i wanna see a turing machines encoded as a life form
17:03:34 <wagle> (ala Poundstone's description in his book)
17:04:08 <Peaker> Game of Life?
17:04:12 <olsner> someone did build a turing machine simulator in game of life
17:04:15 <wagle> yeah
17:04:27 <Peaker> http://rendell-attic.org/gol/tm.htm
17:04:28 <lambdabot> Title: A Turing Machine in Conway's Game of Life, extendable to a Universal Turing Mach ...
17:04:29 <Bonus> yeah that's pretty neat
17:04:43 <Trinithis> out of curiosity, do you guys prefer 2 or 4 (or x) spaces for indentation in haskell?
17:04:46 <Bonus> when you think about it, you could have a sentient lifeform inside a conway's game of life
17:05:02 <DRMacIver> Trinithis: I prefer 2 spaces for everything. :)
17:05:12 <Peaker> "This is the first fully working Turing machine so I made it small, just 3 states and 3 symbols. It takes 11040 generations for one cycle."
17:05:14 <Trinithis> same
17:05:33 <Bonus> i use 4 because i'm used to it from python
17:05:47 <Peaker> heh, I use 8 for C, 4 for Python.  2 for Haskell starts to seem like a correlation to the high-levelness of the language (conciseness of the functions :-)
17:05:56 <Bonus> hehe
17:06:04 <Trinithis> lol
17:06:07 <Pseudonym> I tend to use 2 for mailing list or blog posts.
17:06:08 <Bonus> 16 for java
17:06:10 <Pseudonym> 4 elsewhere.
17:06:17 <Trinithis> 16 for java? lol
17:06:21 <snhmib> normally use tabs but haskell doesn't really like them =(
17:06:27 <Pseudonym> Bonus: <16 spaces> public final static foobar omgOutOfColumns();
17:06:29 <Bonus> well if you were going by the terseness of the language hehe
17:06:37 <Bonus> :D
17:07:15 <Bonus> incidentally i tried to write filter in java the other day
17:07:18 <Bonus> let me tell you
17:07:20 <Bonus> not pretty
17:07:28 <olsner> ColumnOutOfBoundsException
17:07:50 <Trinithis> Bonus: 'lambda's in java are not fun
17:08:06 <Bonus> yeah exactly
17:08:27 <Bonus> although i hear they're planning on adding lambdas and closures
17:08:32 <Bonus> but i bet the syntax will be awful
17:08:45 <Trinithis> theres a huge debate last time i checked. has anytrhing changed?
17:08:48 <Pseudonym> Things are better than they used be in Java 1.0.
17:08:54 <mmorrow> lucidlife is teh sickness: http://icculus.org/~jcspray/LucidLife/
17:08:54 <lambdabot> Title: LucidLife
17:09:02 <Bonus> i dunno, i just know they're debating it
17:09:05 * Pseudonym actually used Java 1.0
17:09:22 <Bonus> wow
17:09:24 <Bonus> when was that
17:09:25 <Bonus> like
17:09:32 <Pseudonym> 1996 or so?
17:09:37 <Bonus> hmm
17:09:38 <Pseudonym> 1995, maybe?
17:09:41 <mmorrow> it's apparently based on http://ironphoenix.org/tril/gtklife/ and there screenshots look pretty identical
17:09:42 <Pseudonym> Can't recall.
17:09:42 <lambdabot> Title: GtkLife
17:10:08 <ddarius> Pseudonym: Yes, things are better.  We have C# now.
17:10:15 <Bonus> hehe
17:10:28 <Pseudonym> Things are better, we have monad-based I/O.
17:10:31 * olsner started out with Java 1.1.8 iirc
17:10:52 <Bonus> my hate for C# is based solely on the fact that the style is CamelCase for methods
17:10:55 <Pseudonym> Anyone know what's up with darcs.net?
17:10:59 <Bonus> which drives me nuts
17:11:11 <Trinithis> Bonus: i share your hate
17:11:19 * wagle started out with whatever was extent in nov 1995
17:11:38 <Bonus> hey is there a way to rewrite the hanoi tower solving function to be tail recursive?
17:11:52 <ddarius> Bonus: There's always a way.
17:12:03 <Bonus> hehe
17:12:10 <Pseudonym> Bonus: But there's actually a better answer.
17:12:12 <wagle> of course!  if all else fails, pass the stack around
17:12:16 <tromp> >no recursion needed at all
17:12:18 <Pseudonym> Tail recursion isn't as useful in a lazy language.
17:12:42 <Bonus> why so
17:12:52 <Pseudonym> @let hanoi' to from mid 1 = ((to,from):)
17:12:52 <Trinithis> Psuedonym: but is it better than not having tail recursion?
17:12:52 <lambdabot> Defined.
17:13:13 <Trinithis> nvm i sound silly
17:13:21 <Pseudonym> @let hanoi' to from mid n = hanoi' to mid from (n-1) . ((to,from):) . hanoi' mid to from (n-1)
17:13:22 <lambdabot> Defined.
17:13:30 <Pseudonym> @let hanoi n = hanoi' 1 3 2 n
17:13:30 <lambdabot> Defined.
17:13:33 <Pseudonym> > hanoi 5
17:13:33 <lambdabot>  <[(Integer,Integer)] -> [(Integer,Integer)]>
17:13:38 <Pseudonym> Dammit.
17:13:40 <Pseudonym> > hanoi 5 []
17:13:41 <lambdabot>  [(1,3),(1,2),(3,1),(1,3),(2,3),(2,1),(3,2),(1,2),(3,1),(3,2),(1,3),(3,1),(2,...
17:13:54 <Pseudonym> Actually, can do better than that.
17:14:16 <wagle> two versions of hanoi: search, and the encoded "the solution" (which doesnt need to backtrack)
17:14:16 <Pseudonym> @let tower' t f m 0 = id
17:14:16 <lambdabot> Defined.
17:14:45 <Pseudonym> @let tower' t f m n = tower' t m f (n-1) . ((t,f):) . tower' m f t (n-1)
17:14:46 <lambdabot> Defined.
17:14:54 <Pseudonym> @let tower n = tower' 1 3 2 n []
17:14:54 <lambdabot> Defined.
17:14:56 <Pseudonym> Better.
17:15:00 <Pseudonym> > tower 2
17:15:00 <lambdabot>  [(1,2),(1,3),(2,3)]
17:15:47 <Pseudonym> Bonus: Tower of Hanoi is conceptually a big list.
17:15:52 <Pseudonym> It's best to construct it lazily.
17:16:04 <Bonus> ah yeah
17:16:09 <Bonus> like the fibonnaci sequence
17:16:23 <Bonus> so you dont repeat the same computations
17:17:03 <ddarius> Pseudonym's code doesn't share anything.
17:17:18 <Pseudonym> No, it doesn't.
17:17:52 <tromp> the list is a bad representation
17:18:06 <tromp> you can write a tiny function that computes the i'th move from i
17:18:08 <Pseudonym> It does, however, use logarithmic space.
17:18:12 <Pseudonym> Not including the actual stream.
17:19:01 <tromp> the x'th move is ((x&x-1)%3, ((x|x-1)+1)%3)
17:19:34 <Pseudonym> tromp: Modulo a renaming.
17:19:38 <tromp> true
17:21:22 <Bonus> hmmm
17:21:28 <Bonus> i have an expression which is
17:21:37 <Bonus> (split n (drop n lst))
17:21:46 <Bonus> why cant i rewrite that as (drop n lst) . (split n)
17:22:09 <twanvl> ?pl \lst -> (split n (drop n lst))
17:22:09 <lambdabot> split n . drop n
17:22:28 <Bonus> hmm
17:23:08 <Bonus> aha i see
17:24:32 <solrize_> is there some arrow combinator for that?
17:24:49 <solrize_> (split `something` drop) n
17:25:40 <twanvl> ?pl \n -> split n . drop n
17:25:40 <lambdabot> liftM2 (.) split drop
17:25:54 <solrize_> heh thanks
17:26:15 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6972
17:26:18 <Bonus> welp im off thanks for all the help today guys
17:27:09 <Saizan> ?type [liftM2 (.), (<=<)]
17:27:10 <lambdabot> forall b b1. [(b1 -> b1 -> b) -> (b1 -> b1 -> b1) -> b1 -> b1 -> b]
17:32:02 <nottha_k_> I installed darcs with Setup.lhs build, configure, and install. How do I uinstall it now?
17:32:38 <nottha_k_> or any package with a similar install process for that matter
17:33:11 <twanvl> you can unregister it, but that doesn't delete the files
17:34:05 <aFlag> is there something for printing a Rational number in a more human-readable manner? This is the number ``print number'' gives to me: http://rafb.net/p/brRAah25.html
17:34:05 <lambdabot> Title: Nopaste - No description
17:35:05 <twanvl> aFlag: you could convert it to a Double, but of course you will lose some precission
17:35:06 <aFlag> s/This is the number//
17:36:15 <Saizan> ?hoogle showDouble
17:36:15 <lambdabot> No matches found
17:36:32 <gwern> > last "foo bar"
17:36:32 <lambdabot>  'r'
17:36:54 <gwern> @hoogle inits
17:36:54 <lambdabot> Data.List.inits :: [a] -> [[a]]
17:36:54 <lambdabot> Data.ByteString.inits :: ByteString -> [ByteString]
17:36:54 <lambdabot> Data.ByteString.Char8.inits :: ByteString -> [ByteString]
17:38:08 <aFlag> twanvl, transforming that on Double gives me 0.0. I wanted something using power of 10
17:38:20 <aFlag> some rounding can definetely take place
17:39:46 <gwern> > null []
17:39:47 <lambdabot>  True
17:41:21 <aFlag> I'm having a hard time finding anything that will help me on Prelude, anywhere else I might look?
17:41:43 <twanvl> properFraction might help
17:42:53 <pantsd> Is there an efficient way to lower case all of a bytestring?
17:43:14 <aFlag> twanvl, I've tried that, but it didn't change anything :(
17:45:27 <hpaste>  gwern pasted "any style advice or shorter ways of doing this?" at http://hpaste.org/6973
17:45:32 <thotypous> @src cycle
17:45:32 <lambdabot> cycle [] = undefined
17:45:32 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
17:45:33 <twanvl> aFlag: there is no direct way to do what you want, but you can iterate multiplying by 10 and properFraction until the first element of the tuple is >0, in other words, this way you find the power of 10 of the number
17:45:57 <hpaste>  (anonymous) annotated "any style advice or shorter ways of doing this?" with "deunicode" at http://hpaste.org/6973#a1
17:46:15 <aFlag> hm
17:46:49 <aFlag> and the first element in the tuple will be the number on that decimal place, right?
17:46:56 <aFlag> seems like a good idea
17:47:00 <twanvl> gwern: can't you just use B.unlines?
17:47:53 <gwern> twanvl: I don't think there is one
17:48:05 * gwern sees none in http://haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString.html#v%3Aempty
17:48:07 <lambdabot> http://tinyurl.com/39be59
17:48:22 <twanvl> gwern: it is in Char8
17:48:47 <gwern> twanvl: I don't think that's good then - I'm working with Data.ByteString here
17:49:08 <twanvl> I meant Data.ByteString.Char8
17:49:24 <gwern> in addition, it has different behaivour
17:49:29 <BMeph> aFlag: Is there something wrong with solrize_'s version (i.e., use log)?
17:49:55 <gwern> it'd terminate with a \n, while darcs's old unlinesPS doesn't terminate with a \n
17:50:21 <twanvl> gwern: then just do init . unlines?
17:51:05 * gwern ponders
17:51:33 * gwern quickchecks that
17:51:50 <gwern> init throws an exception on empty lists
17:53:07 <twanvl> unlines [] = B.empty; unlines xs = B.init (B.unlines xs)
17:53:08 <gwern> so I need to keep the guard at least
17:53:45 <gwern> er. I mean empty strings
17:53:48 <gwern> ""
17:53:59 <gwern> (although that might not make a difference)
17:55:39 <gwern> twanvl: I think you were right that you can match on [] - 2000 tests in and quickcheck hasn't found a counterexample
17:56:43 <Arnar> hey folks..
17:56:58 <Arnar> anyone know of a good example of a interactive console application written in haskell?
17:57:06 <P_D> ghci
17:57:15 <aFlag> BMeph, hm, I didn't realise solrize_ was talking to me
17:58:00 <Arnar> P_D: I'm looking for something that generalizes this.. instead of evaluating input, define custom commands etc..
17:58:39 <gwern> Arnar: check out the Shellac shell framework and the demo for it, lambdashell
17:58:43 <aFlag> twanvl, I did that thing you suggested and it was extremely slow http://rafb.net/p/R9wkeh59.html
17:58:44 <lambdabot> Title: Nopaste - No description
17:58:46 <gwern> nice example, imo
17:58:50 <aFlag> let me think how this log thing would work
17:58:56 <Arnar> gwern: thanks..
17:59:17 <TomMD> Arnar: Shellac is great, as gwern said, also look at the not yet ready for prime time haskell shell (HSH)
17:59:19 <BMeph> I didn't see how "solrize_:	> 9000 * log 0.1" made sense, otherwise... :)
18:00:00 <twanvl> aFlag: it just occured to me you don't need properFraction at all here, just test if x < 1
18:00:13 <gwern> TomMD: HSH isn't really a interactive app unless you're talking about a different one...
18:00:47 <TomMD> gwern, arnar: My mistake - I ment hashell not hsh.
18:01:16 <gwern> TomMD: I think hashell was abandoned
18:01:35 <TomMD> Really?  I just downloaded it after seeing an annoucement I thought was recent...
18:02:01 <Arnar> TomMD, gwern: shellac looks like exactly what I need..
18:02:05 <Arnar> thanks
18:03:06 <gwern> Arnar: I found shellac a little hard to work with; if you want to see a pile of crap I sort of had working to reimplement hashell in shellac, I could send it to you if you'd like
18:03:41 <Arnar> gwern: sure.. I'd definitely like to have a look
18:03:59 <gwern> > unlines ["foo", "bar"]
18:03:59 <Arnar> paste or email?
18:03:59 <lambdabot>  "foo\nbar\n"
18:04:18 <gwern> Arnar: multiple files, so email
18:04:23 <Arnar> arnarbi at gmail
18:04:46 <gwern> 'k
18:04:50 <gwern> lemme clean'em up...
18:05:02 <Arnar> thanks alot
18:05:06 <Arnar> gwern++
18:06:40 <Arnar> :t liftIO
18:06:41 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
18:08:46 <gwern> Arnar: should be inbound
18:09:28 <Arnar> gwern: received.. thank you very much
18:10:14 <dolio> @type B.unlines
18:10:16 <lambdabot> Couldn't find qualified module.
18:10:26 <dolio> @type C.unlines
18:10:27 <lambdabot> Couldn't find qualified module.
18:10:52 <aFlag> hm, actually what twanvl said worked within reasonable time when I used -O2
18:11:09 <gwern> dolio: B for ByteString
18:11:59 <dolio> Yeah. I thought lambdabot had them imported that way.
18:12:02 <aFlag> BMeph, I'm not sure how I'd use that log notation for doing arithmetic operations with the number
18:12:07 <dolio> @type BS.pack
18:12:08 <lambdabot> [Word8] -> BSC.ByteString
18:12:16 <aFlag> maybe I could change all the other numbers, into log and figure something out
18:12:21 <aFlag> dunno
18:12:22 <dolio> Ah, there we are.
18:12:29 <dolio> @type BSC.unlines
18:12:30 <lambdabot> [BSC.ByteString] -> BSC.ByteString
18:12:47 <dolio> > BSC.unlines []
18:12:48 <lambdabot>  ""
18:13:57 <aFlag> maybe I'm missing something, though
18:14:37 <BMeph> Hold on, let me review - what did you want to do with your itty-bitty numbers again? ;)
18:16:43 <aFlag> maybe this explains better what I'm trying to do: www.dcc.ufmg.br/~rafaelc/Probability.pdf
18:17:22 <aFlag> I want to calulate that last math expression in page 2
18:17:23 <dolio> dropEnd might be useful to have for Data.ByteString.
18:17:44 <dolio> Then gwern's function would be 'f = dropEnd 1 . unlines'
18:18:02 <aFlag> I think I got the result, although it takes a little bit to make the resulting number into something human-readable
18:18:19 <gwern> dolio: I think 'init' = dropEnd
18:18:41 <dolio> dropEnd wouldn't throw an exception on an empty string.
18:18:52 <BMeph> init is "dropEnd 1"
18:19:26 <dolio> Hence, no need for an extra clause to check for an empty list.
18:19:42 <BMeph> i.e. dropEnd n == reverse . drop n . reverse
18:20:11 <dolio> Effectively, but it's much faster than that on ByteString.
18:20:31 <fnoble> aFlag: can do that keeping the numbers as logs
18:20:49 <BMeph> dolio: Yeah, just confirming what it means, not how it does it. ;)
18:21:25 <dolio> Since it'd get to do something like: dropEnd n (BS offset len ptr) = BS offset (max 0 (len - n)) ptr
18:21:26 <fnoble> questionA = 10^(log(fromInteger count) + log(brobForEach))
18:21:42 <fnoble> *prob not brob
18:22:39 <BMeph> And, aFlag? Since it's all mults/divs and powers, log works just fine.
18:22:39 <gwern> dolio: why not do it? if you're going to make bytestring changes, sooner rather than later - dons is planning a release, I think I saw'im say
18:23:02 <fnoble> actually you want 10^(log(frmInt count) + 1000*log(0.9) + 9000*log(0.1))
18:23:13 <dolio> Is he around?
18:23:15 <dolio> @seen dons
18:23:15 <lambdabot> dons is in #haskell, #xmonad, #haskell-hac4 and #haskell-soc. I last heard dons speak 4h 20m 40s ago.
18:23:16 <aFlag> hm
18:23:20 <BMeph> That is, multiplications and divisions, not div-as-in `div` :)
18:24:18 <fnoble> night all
18:24:44 <SamB> gwern: he did
18:24:52 <SamB> gwern: he said it on darcs-devel
18:25:08 <gwern> he did?
18:25:22 * gwern thought it was #darcs, but awright
18:25:26 <aFlag> hm, I'm not too smart with my log stuff, let me think
18:25:37 <BMeph> SamB: Did he do it, or just say he was going to do it? :)
18:25:52 <SamB> BMeph: said
18:26:06 <SamB> gwern: he might have said it there too!
18:26:26 <SamB> I do know that I saw it on gmane, though
18:26:30 <SamB> and gmane doesn't do IRC
18:26:59 <BMeph> aFlags: Just remember, log (A * B) == (log A) +( log B)
18:27:26 <BMeph> Er, log ( A * B ) == ( log A ) +( log B )
18:29:32 <SamB> what was the difference there?
18:30:57 <dolio> @tell dons Thought: 'dropEnd n ps@(PS x s l) | n <= 0 = ps | n >= l = empty | otherwise = PS x s (l - n)' Perhaps takeEnd too?
18:30:57 <lambdabot> Consider it noted.
18:32:24 <BMeph> SamB: NM, my client puts smilies in things automatically
18:32:32 <gwern> SamB: spaces in the parentheses, I think...
18:32:46 <BMeph> (8)
18:32:46 <SamB> ah!
18:32:55 <BMeph> ( 8)
18:33:00 <SamB> B)
18:33:05 <BMeph> (8 )
18:33:22 <SamB> how many of those does it smilize?
18:33:42 <SamB> ... chatzilla?
18:33:47 <SamB> I used to use that
18:34:00 <SamB> like, when I used mozilla
18:34:08 <SamB> before they ditched it for firefox
18:34:17 <GenericLunatic> Hello
18:35:20 <dolio> My e-mail client interprets smileys.
18:35:27 <gwern> heh.
18:35:32 <gwern> chatzilla is still around y;know
18:35:35 <GenericLunatic> Sorry to ask about this in the Haskell channel, but it was the only place I could think of. Does anyone know where I could get help with Clean?
18:35:42 <snhmib> if i don't have profiling libraries installed, what is the line to still use -prof with ghc for only the functions in my program?
18:35:42 <dolio> So, for instance, (*) gets turned into a star, and (&) turns into a dog.
18:35:42 <gwern> I see it mentioned in a lot of part/joins in #wikipedia
18:35:57 <dolio> Makes haskell code look weird sometimes.
18:36:00 <SamB> Konversation, huh
18:36:10 <SamB> gwern: and BMeph uses it
18:36:23 <SamB> dolio: so I would imagine
18:36:34 <SamB> dolio: can't it be turned OFF??
18:36:48 <dolio> It can, but I haven't bothered to.
18:36:54 <SamB> WHY NOT?
18:37:06 <dolio> Never really occurred to me.
18:37:16 <gwern> snhmib: if you find out, I'd like to know too
18:37:17 <SamB> @hoogle (&)
18:37:17 <lambdabot> Did you mean: (&)
18:37:17 <lambdabot> Prelude.undefined :: a
18:37:17 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
18:37:21 <SamB> @hoogle &
18:37:21 <lambdabot> Prelude.(&&) :: Bool -> Bool -> Bool
18:37:21 <lambdabot> Data.Bool.(&&) :: Bool -> Bool -> Bool
18:37:21 <lambdabot> Control.Arrow.(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
18:37:24 <SamB> hmm
18:37:31 <SamB> who uses & as an operator anyway?
18:37:53 <dolio> I don't know. I'm pretty sure I've seen it, though.
18:37:54 <SamB> I bet it is avoided because | is reserved ;-P
18:38:23 <gwern> SamB: that would make sense. it'd feel unfair to have & and ||
18:38:30 <thoughtpolice> i'm trying to build SDL 0.5.4 and it fails on the err 'gcc: unrecognized option '-rpath'', from a look at the mailing lists it says to remove rpath from your package.conf file but if I do a search through the file nothing is to be found; any suggestions?
18:38:32 <BMeph> I use it because regular IRC clients get stopped by my company's f-wall, but browser-based ones work fine.
18:39:42 <SamB> BMeph: your company has a really wierd firewall
18:39:45 <gwern> thoughtpolice: sure you are looking in the right conf?
18:39:47 <solrize_> genericlunatic, comp.lang.functional maybe?
18:39:48 <SamB> it must be on your workstation
18:39:58 <solrize_> there's also a clean wiki  iirc
18:40:14 <thoughtpolice> gwern: looked in both ghc-6.8.2/package.conf and my own ~/.ghc/i386-linux-6.8.2/package.conf
18:40:23 <dolio> SamB: Besides, who doesn't like the birthday cake operator (^)?
18:40:24 <SamB> GenericLunatic: you might even be able to get help HERE
18:40:32 <Lycurgus> genericlunatic: subscribe to their list. Ask about FP generally here.
18:40:36 <SamB> dolio: hmm, strange operator
18:40:40 <SamB> how about (^^)
18:41:12 <Lycurgus> and know thier name to be a misnomer.
18:41:19 <Lycurgus> should be MisguidedFork.
18:41:31 <BMeph> Oh, and SamB? More than enough people use smilies intentionally, that the few times that it shows up accidentally are easily ignored. :)
18:41:41 <GenericLunatic> Well, I'm trying to figure out what's wrong with this simple program... http://rafb.net/p/IqtF0o90.html
18:41:41 <dolio> Nope, doesn't do that one.
18:41:41 <lambdabot> Title: Nopaste - Clean Problem
18:41:43 <thoughtpolice> gwern: actually the mailing list post i'm looking at has to do with after SDL is installed, i'm actually getting this err while trying to just build the SDL bindings
18:41:54 <GenericLunatic> since it's very similar to something in their tutorial
18:42:14 <BMeph> Well, by me, anyhow. It sounds like dolio's client does a lot more of it than CZ does.
18:42:18 <dolio> I don't know where some of the emoticons come from. (D) appears to be a martini glass.
18:42:21 <GenericLunatic> it may actually carry over between Haskell and Clean... I don't know either language very well.
18:44:12 <dolio> I don't know of an StdInt module.
18:44:18 <thoughtpolice> gwern: ah, removing -rpath and /usr/lib from SDL.buildinfo worked :)
18:44:36 <dolio> Other than that, you  might need to indent the |s more (not sure on that one).
18:45:10 <GenericLunatic> The issue I'm having is that it says it expects an expression instead of the | for the guard.
18:45:10 <dolio> And 'Start' is a constructor name in Haskell, so 'Start = fac 6' doesn't make much sense.
18:45:30 <GenericLunatic> @dolio: I was asking about Clean :)
18:45:30 <lambdabot> Unknown command, try @list
18:45:39 <dolio> Oh, okay.
18:45:47 <dolio> My bad.
18:46:19 * dolio doesn't actually know Clean.
18:46:42 <hpaste>  morrow annotated "toTree :: TypeRep -> Tree TyCon" with "t :: Tree (TyCon, Type)" at http://hpaste.org/6969#a1
18:47:46 <dolio> GenericLunatic: If Clean's layout is anything like Haskell's, though, you need to indent the | more.
18:48:03 <GenericLunatic> That was my first guess, but I couldn't seem to get it to work :\
18:48:38 <dolio> I guess that's not it, since my copy of the clean report has code that looks like that.
18:48:50 <dolio> My next guess is that 'n=0' is wrong. It needs to be 'n==0'.
18:50:05 * SamB sighs with relief that "clean language report" actually gets him to the right page
18:50:43 <GenericLunatic> ah ha
18:50:46 <GenericLunatic> good guess
18:50:47 <GenericLunatic> :)
18:50:51 <GenericLunatic> seems to be it
18:51:12 <GenericLunatic> I thought I'd tried that already
18:51:14 <GenericLunatic> :P
18:51:22 <GenericLunatic> thanks dolio, I feel silly now
18:51:33 <dolio> Happens to everyone.
18:59:26 * BMeph smirks thinking about what Else SamB might've found looking for a "clean language report"... ;)
19:01:16 <solrize_> do any of the harpy guys ever hang out here?  speaking of clean languages :)
19:14:11 <nornagon> darcs.net down? :(
19:17:28 <dejones> is this not correct in Haskell, data Point = (Integer, Integer)
19:17:29 <dejones> ?
19:17:51 <dejones> as in, a Point is a data type which is a 2-tuple of Integers
19:18:07 <aFlag> I had to leave for a minute and now I came back. About that log thing 10 ** (log (fromInteger count) + (1000 * log 0.9 ) + (9000 * log 0.1)) turned out to give me Infinity
19:18:16 <TomMD> dejones: You need a constructor
19:18:24 <aFlag> I suppose there's just not enough precision to represent the number I want in float or Double
19:18:25 <nanothief> dejones: you could use data Point = Point Integer Integer
19:18:25 <TomMD> dejones: data Point = Pnt (Integer, Integer)
19:19:16 <dejones> Ahhh
19:19:37 <dejones> TomMD: does Data Point = Point (Integer, Integer) seem reasonable too?
19:20:17 <TomMD> dejones: Sure does.  Also, type Point = (Integer, Integer) might due for your uses too.
19:20:31 <dejones> TomMD: Thanks.  :)
19:20:40 <BMeph> TomMD: s/due/do/, maybe? ;)
19:20:43 <dejones> Thank you nanothief too
19:20:48 <pantsd> What is the correct way to write this: foo:: (Num a) => String -> a
19:20:48 <pantsd> foo str = 1::Int
19:21:29 <TomMD> BMeph, yes, you caught me.  I am actually Senior TomasMD and English is my seventh language.  (I wish, that would mean I knew languages besides English)
19:21:50 <sw17ch> in a case statement, _ is the default case right?
19:23:07 <BMeph> sw17ch: Not exactly, it means "I don't care what matches, just match something"
19:23:42 <TomMD> pantsd: foo = const 1
19:25:03 <TomMD> pantsd: The problem is you are saying 1 :: Int is of type (Num a).  If you just say '1' then the type system will infer which instance of Num is correct for any given use.
19:25:12 <sw17ch> BMeph, close enough for my purposes... or is there an "otherwise" keyword, i can't remember and it isn't referenced here. http://www.haskell.org/haskellwiki/Keywords#case
19:25:13 <lambdabot> Title: Keywords - HaskellWiki
19:25:19 <pantsd> TomMD: cool thanks :)
19:25:55 <pantsd> TomMD: hmms it still fails
19:26:01 <TomMD> Worked for me
19:26:04 <TomMD> ?where paste
19:26:05 <lambdabot> http://hpaste.org/new
19:27:30 <BMeph> sw17ch: It fits the role - the underscore always matches.
19:27:37 <hpaste>  pantsd pasted "a.hs" at http://hpaste.org/6974
19:28:12 <vincenz> pantsd: either
19:28:13 <vincenz> foo = const 1
19:28:14 <vincenz> or
19:28:16 <vincenz> foo str = 1
19:28:17 <vincenz> or
19:28:19 <vincenz> foo _ = 1
19:28:31 <vincenz> foo str = const 1 ==== foo str _ = 1    is a fucntion of two arguments
19:28:38 <hpaste>  TomMD pasted "pantsd: Both worked for me!" at http://hpaste.org/6975
19:28:55 <vincenz> TomMD: annotate the posts :)
19:29:36 <pantsd> hrms
19:30:07 <hpaste>  (anonymous) annotated "a.hs" with "(no title)" at http://hpaste.org/6974#a1
19:30:25 <TomMD> vincenz: Yeah, I know, tired as my annotation without a name or title proves.
19:30:33 <TomMD> and my darn slow typing.
19:31:04 <TomMD> pantsd: Incase you aren't watching IRC - look at the recent annotation.
19:31:47 <pantsd> rocking
19:31:49 <pantsd> thanks :)
19:33:07 <vincenz> Btw, not sure about "foo = const 1" in pure haskell 98
19:33:22 <vincenz> It'll work in GHC, but I think in haskell 98 that's probably a source of monomorphism restrictions
19:33:29 <vincenz> Someone more knowledgeable can correct me.
19:34:32 <BMeph> vincenz: With the type anno, it should work.
19:35:07 <vincenz> BMeph: Right, in GHC, not sure about pure H98
19:35:18 <vincenz> But then again, I only use GHC :)
19:35:26 <BMeph> Heh, heh.
19:41:14 <TomMD> Does anyone know how the dynamic library works?  Is there a simple tutorial out there?
19:45:15 <Cale> :t toDyn
19:45:15 <lambdabot> forall a. (Typeable a) => a -> Dynamic
19:45:29 <awesame> where do I find haskell's sleep function?
19:45:35 <Cale> You can turn (Typeable) things into values of type Dynamic with toDyn
19:45:38 <Cale> :t fromDyn
19:45:39 <lambdabot> forall a. (Typeable a) => Dynamic -> a -> a
19:45:41 <paczesiowa> awesame: threadDelay
19:45:46 <paczesiowa> @src threadDelay
19:45:46 <lambdabot> Source not found. Do you think like you type?
19:45:59 <conal> @query lambdabot
19:45:59 <lambdabot> Unknown command, try @list
19:46:04 <Cale> fromDyn will turn them back again, but you must provide a default in case the value of type Dynamic doesn't match the type a
19:46:04 <paczesiowa> Control.Concurrent.threadDelay
19:46:08 <Cale> :t fromDynamic
19:46:09 <lambdabot> forall a. (Typeable a) => Dynamic -> Maybe a
19:46:14 <conal> @query lambdabot foo
19:46:14 <lambdabot> Unknown command, try @list
19:46:25 <conal> @query lambdabot @hoogle threadDelay
19:46:26 <lambdabot> Unknown command, try @list
19:46:34 <Cale> fromDynamic provides a handy case of that using Maybe
19:46:37 <conal> silly me
19:46:54 <Cale> TomMD: That's almost all there is to it, really.
19:47:17 <Cale> Oh, there's also dynApp/dynApply
19:47:32 <awesame> paczesiowa: thanks
19:48:38 <brothers> guys, guys
19:48:57 <Cale> which are used to apply Dynamic-typed functions to Dynamic-typed values (with dynApp :: Dynamic -> Dynamic -> Dynamic deferring the type failures until values are extracted from the Dynamic, and dynApply :: Dynamic -> Dynamic -> Maybe Dynamic making the failures noticeable immediately.
19:48:59 <Cale> )
19:49:41 <BMeph> brothers: Where?!? ;)
19:49:46 <brothers> there is an incandescent bulb in my refrigerator
19:51:38 <TomMD> Cale: I guess I just want a library that that would do the impossible in a statically typed language.  I find that now and then I have a set of configuration values (different types) and a polymorphic parser.  So I have this non-sensical list [conf1, conf2...] which I wish to turn into some useful data: map parser confs.
19:52:26 <Cale> TomMD: Well, are there infinitely many different types of possible configuration values?
19:52:44 <Cale> Or is there some finite manageable list of them?
19:53:23 <Cale> The standard thing is really to construct a nice tagged union of the various cases.
19:54:05 <Cale> How would the parser operate in a dynamically typed language?
19:54:12 <Cale> (and is it really a parser?)
19:54:17 <TomMD> Cale: No, it varies from a few of my uses, but in one case it was somewhat more dynamic.
19:54:48 <Cale> Are conf1, conf2, ... meant to be strings?
19:55:13 <Cale> Or values of various types?
19:55:14 <TomMD> Cale: The parser was simply polymorphic - it wasn't dynamically typed.  So conf1/conf2 would be (SomeTypeClass a)
19:55:52 <Cale> (this must be some generalised idea of what a parser is :)
19:56:56 <TomMD> Sure.  I probably shouldn't have said parser.  It is more of a set of functions which extracts the important information of any particular piece of configuration information.
19:59:58 <Cale> One thing to consider would be whether you can simply force whoever is calling this part of the code to refine out the configuration data that you're interested in, such that it can be conveyed in a nicely concrete fashion. This would also help the type system ensure that the needed data were really made available.
20:00:44 <Cale> If you do want to go with that route, you might be interested in libraries such as Data.Generics (Scrap your boilerplate) or Uniplate.
20:01:05 <Cale> Which are generic ways of traversing algebraic datastructures.
20:03:49 <TomMD> Cale: Are you going to the ICFP?
20:05:30 <Cale> I have no plans currently. Perhaps if I somehow came into an appropriate amount of money between now and then, I'd go.
20:20:52 <bos> sigh.
20:20:52 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
20:22:52 <bos> i knew i'd regret using wordpress as a blog system.
20:23:12 <dolio> You should have written your own in 20 minutes using ruby on rails.
20:23:47 <conal> bos: what kind of trouble are you having with wordpress?
20:23:54 <bos> conal: linkspam
20:24:01 <vincenz> bastards
20:24:09 <bos> being inserted through one of their umpteen security holes
20:24:22 <conal> bos: do you have akismet active?
20:24:28 <bos> i believe this one was their xmlrpc injection hole
20:24:38 <bos> conal: this wasn't comment spam, they modified article text directly
20:24:50 <bos> PHP developers give me hives.
20:24:59 <conal> bos: oh, yoink!  do you have the latest version?
20:25:05 <bos> conal: i do now!
20:25:10 <vincenz> bos: I've had that happening on another php wiki system
20:25:31 <vincenz> articles filled with spam
20:25:33 <vincenz> without any history
20:25:37 <vincenz> so it wasn't through edit
20:25:39 <bos> basically, if you're relying on code written by someone who can only write php, they're sure to fuck it up.
20:26:27 <vincenz> c and php :D
20:26:34 <vincenz> Like that bug introduced by gcc compilers :D
20:26:45 <vincenz> if (buf + len > buf)  { ...} => nil
20:30:02 <conal> one of my posts on "future values" drew tons of comment spam, mostly about online gambling.  fortunately, all intercepted.
20:34:16 <bos> yes, akismet catches about 99% of my incoming spam.
20:34:32 <bos> maybe even 99.7% or so.
20:36:11 <dibblego> Akismet has caught 41,911 spam for you since you first installed it.
20:36:47 <conal> wow
20:37:11 <vincenz> spammers should be publicly flaggelated
20:38:34 <Jay67> hello
20:48:46 <jberg_> does anyone know if darcs 2 (the newest version?) is available in binary for mac os x? darcs.net is down it seems
20:49:02 <jberg_> and noone answers in #darcs so i figured id ask here
21:00:38 <gwern> @seen tibbe
21:00:38 <lambdabot> I saw tibbe leaving #haskell-hac4, #haskell-soc, #darcs, #xmonad, #ghc and #haskell 14h 4m 39s ago, and .
21:11:40 <kris_> doublec: hi
21:11:45 <doublec> hi kris_
21:12:44 <kris_> doublec: just reading it. if you haven't ascertained from my code, it's pretty much a â€œword-for-wordâ€ translation of parsec
21:13:04 <s|k> would haskell be a good language to decode an image or video codec?
21:13:07 <doublec> yes, I saw that.
21:13:50 <kris_> grabbed the repo.
21:13:50 <doublec> Does parsec return a lazy list of succesfull parses? If so, how did you handle that?
21:14:36 <doublec> I started off with that approach, and switching to using packrat/peg - but still using combinators to compose parsers.
21:14:50 <vincenz> doublec: a lazy list is like a backtracking monad
21:15:00 <vincenz> doublec: it blows up though
21:16:29 <vincenz> doublec: imagine two parsers 'a' and 'b''
21:16:34 <vincenz> then doing a >> b
21:16:46 <vincenz> will return you a list of all combinations of a * all combinations of b
21:17:00 <vincenz> that's how the list monad works
21:17:03 <kris_> doublec: well. i'm not so sure what you mean. it has simple constructs like "this <|> that" meaning "try this and if it doesn't consume any input, try that", and also 'try someparser' which, if the parser fails, pretends it didn't consume any input
21:17:12 <vincenz> > [(a,b) | a <- [1..3], b <- [1..3]]
21:17:14 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
21:17:16 <kris_> doublec: it keeps a "remaining" variable hanging around
21:17:23 <vincenz> :t Parser
21:17:24 <lambdabot> Not in scope: data constructor `Parser'
21:17:54 <kris_> doublec: my implementation does, anyway. i'm not very adept at topics in parsing, i just figured parsec would be fun to implement in javascript so i could parse BBCode. haha
21:18:16 <doublec> thanks vincenz
21:18:27 <luqui> afaik BBCode does not need context-free parsing
21:18:30 <luqui> it is very simple...
21:18:33 <kris_> doublec: to be honest yours looks like parsec so far
21:18:40 <doublec> kris_, makes sense
21:18:48 <doublec> Sounds like we've done very similar things
21:18:51 <kris_> indeed
21:19:24 <kris_> doublec: looks like you're working out speed issues, which is more hardcore insane than i've yet ventured :P
21:19:40 * kris_ plays with the examples
21:20:00 <doublec> yeah, I went for caching in the style of packrat parsers
21:20:09 <doublec> which trades off memory for linear parse times
21:20:43 <ddarius> Parsec doesn't do (globally) ambiguous parses at all.
21:20:50 <kris_> doublec: is that, put simply, storing the result of applying a combinator to a string input in some hashtable/array or whatnot?
21:21:22 <doublec> kris_, Yes. Each parsers stores it's result in a cache, keyed by the input position
21:21:39 <doublec> so whenever are parser is run it checks the cache to see if it has already been run at that position
21:21:43 <doublec> and just returns the result
21:21:46 <kris_> ddarius: is that a retort or are you just stating it for information? i'm not sure what that means
21:21:55 <doublec> Currently it doesn't handle left recursion
21:21:59 <doublec> I'll be adding that though
21:22:08 <kris_> doublec: sounds like a good idea considering it's all pure
21:22:12 <doublec> I added it to my parsers in Factor and it makes things much nicer
21:22:14 <kris_> doublec: (presumably all pure)
21:22:30 <kris_> ahh. factor. i haven't tried that [yet] (or Joy)
21:22:33 <doublec> Yes, the parsers need to have no side effects
21:23:18 <doublec> For factor I wrote an simple EBNF parser that allowed doing embedded DSL's: http://www.bluishcoder.co.nz/2008/04/factor-parsing-dsl.html
21:27:10 <kris_> (just reading, hehe)
21:28:37 <kris_> so have you used this javascript one to parse something nontrivial?
21:29:01 <kris_> ie in a â€œreal-worldâ€ page
21:29:17 <hpaste>  morrow annotated "any style advice or shorter ways of doing this?" with "(no title)" at http://hpaste.org/6973#a2
21:29:18 <ddarius> kris_: It's a response to: [23:13] <doublec> Does parsec return a lazy list of succesfull parses? If so, how did you handle that?
21:29:40 <kris_> ddarius: ahh right. sorry!
21:30:11 <doublec> kris_, only the portions of the ecmascript 3 grammar included in the repository
21:30:27 <doublec> Someone in #lojban was parsing lojban with it
21:30:48 <kris_> oh wow :D
21:31:36 <slava> doublec: do i know you?
21:31:57 <doublec> slava, hmm. Not sure. Are you that annoying guy that harps on about documentation?
21:31:59 <kris_> doublec: well i've bookmarked the factor parser for when i learn factor
21:32:02 <hpaste>  morrow annotated "any style advice or shorter ways of doing this?" with "better" at http://hpaste.org/6973#a3
21:32:29 <slava> doublec: oh, i remember now. you're the guy who ate all my pies in new zealand!
21:32:30 <slava> ;)
21:33:04 <doublec> hehe
21:33:26 <slava> doublec: i was looking at the OMeta slides and it seems you have most of that except the leixcally-scoped syntax extensions?
21:33:40 <slava> do you have parser inheritance?
21:33:47 <doublec> Not yet
21:34:01 <doublec> I will though
21:34:20 <doublec> Did you see that cola has been updated to include the latest ometa stuff?
21:34:52 <slava> doublec: yup
21:35:07 <vincenz> A bit OT here, *proposes# oasis :D
21:35:22 <jberg_> does anyone know what the latest version of darcs is? #darcs is a bit quiet..
21:35:25 <ddarius> Everyone ends up in #haskell it seems.
21:35:28 <jberg_> and darcs.net is down
21:35:56 <slava> jberg_: you acn get the latest version from http://git.or.cz
21:35:57 <lambdabot> Title: Git - Fast Version Control System
21:36:12 <jberg_> slava: ah ok great
21:36:25 <jberg_> uh hu
21:36:38 <bos> jberg_: it's 2.0
21:36:54 <bos> only ruby programmers use git.
21:37:06 <bos> we all know slava is secretly a rubyist.
21:37:09 <slava> i didn't realize linus was a ruby programmer
21:37:12 <slava> i'm in good company!
21:37:13 <jberg_> bos, do you know if there are os x binaries? and also if i can get it somewhere else than darcs.net?
21:37:18 <bos> linux is written in ruby.
21:37:40 <slava> bos: dude, ruby is an OS. its not a language. how can the linux text editor be written in an OS?
21:37:40 <bos> jberg_: i try to know as little about darcs as possible, i'm afraid.
21:37:51 <jberg_> ah ok. anyone else?
21:38:35 <kris_> aaanyhoo
21:39:39 <kris_> doublec: imma try parsing some stuff. then maybe i'll learn factor or something. not really committed to any project and i have tonnes of time so i'm just coding any contrived thing i find mildly interesting.
21:40:02 <doublec> kris_, cool. Good luck.
21:40:02 <slava> doublec: are you trying to promote factor in here?
21:40:07 <doublec> slava, never
21:40:18 * slava is methodically writing unit tests to catch runtime type errors
21:40:36 <kris_> amazing what closure support can do for a language's expressiveness
21:43:04 <vincenz> doublec `ap` #oasis
22:27:45 <kris_> excellent
22:37:01 <jberg_> should ghc 6.8 take like a looong time to build on a 2ghz dual core?
22:37:38 <mrd> maybe an hour?
22:37:48 <jberg_> really? okay then
22:41:16 <dolio> What are you using to compile it?
22:42:32 <dolio> I compiled 6.9 the other day, and it took maybe an hour and a half (on an Athlon 64 3000+).
22:42:53 <dolio> But that was using 6.8 to compile, which is significantly faster than 6.6.
22:49:43 <paczesiowa> has anyone played with qthaskell?
22:50:04 <dolio> I compiled it once.
22:50:09 <dolio> But didn't do anything with it.
22:50:26 <paczesiowa> did you run the examples?
22:50:28 <dolio> It seemed to be a pretty bare wrapping of the API.
22:50:50 <dolio> I can't really recall.
22:51:11 <jberg_> dolio: i don't know really. it just compiling because it's a dependency in macports when im installing darcs
22:51:22 <paczesiowa> few months ago I succesfully ran them, but now all I get is "Cannot mix incompatible Qt libraries" at runtime
22:51:35 <jberg_> why can't macports have binary packages
22:52:58 <cjs> Use Fink?
22:54:18 <jberg_> cjs: it only has 1.0.9
22:54:25 <jberg_> macports has 2.0.0 pre 4
22:54:44 <pantsd> :t ("Length",(\x -> (fromInteger (toInteger (length x))))):[]
22:54:48 <lambdabot> forall a a1. (Num a1) => [([Char], [a] -> a1)]
22:54:50 <jberg_> no, i didn't even see darcs in fink
22:55:57 <pantsd> how come :t ("Length",(\x -> (fromInteger (toInteger (length x))))):[] has Num in it but if I assign it to a varaible Num a becomes integer?
22:56:07 <cjs> @hoogle Data.Binary
22:56:10 <lambdabot> No matches, try a more general search
22:56:14 <cjs> Annoying.
22:56:29 <ivanm> @hoogle binary
22:56:29 <lambdabot> System.IO.withBinaryFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
22:56:29 <lambdabot> System.IO.openBinaryFile :: FilePath -> IOMode -> IO Handle
22:56:29 <lambdabot> System.IO.hSetBinaryMode :: Handle -> Bool -> IO ()
22:56:47 <ivanm> cjs: what are you trying to find? IIRC, hoogle only finds functions, not modules
22:56:49 <paczesiowa> pantsd: type defaults to Integer in ghci I think
22:56:55 <ivanm> @index Data.Binary
22:56:55 <lambdabot> bzzt
22:57:09 <ivanm> @doc Data.Binary
22:57:09 <lambdabot> Data.Binary not available
22:57:48 <paczesiowa> pantsd: so you can print 2+2, without narrowing type to Int for example
22:58:36 <pantsd> paczesiowa: is there a way to avoid narrowing the type to Integer then?
22:59:26 <dolio> -XNoMonomorphismRestriction
23:00:06 <pantsd> yays!
23:00:08 <pantsd> thank you
23:00:36 <pantsd> w00t my code compiles!
23:00:37 <pantsd> :)
23:01:18 <dolio> Note: fromInteger (toInteger x) = fromIntegral x
23:01:24 <paczesiowa> I recompiled qthaskell, and now I get segfaults:/
23:01:37 <pantsd> yays
23:01:39 <pantsd> thanks :)
23:01:44 <dolio> And fromIntegral (length l) is approximately the same as genericLength l (genericLength is in Data.List).
23:01:51 <pantsd> dolio: thank you :)
23:02:23 <pantsd> in this case the code I'm pokeing at is actuall for data.bytestring so its not a list
23:02:27 <pantsd> but yays!
23:02:29 <pantsd> my code compiles
23:02:31 <pantsd> happy times :)
23:02:37 <dolio> Heh.
23:21:27 <paczesiowa> yay, qthaskell segfaults were just nice way of saying that there is rcc file missing.
23:22:52 <Zao> paczesiowa: Reminds me of tractorgen.
23:22:58 <Zao> "In keeping with this theorem, TRACTORGEN will politely inform the user if any attempt to make tractors with less than four wheels is made (by calling abort(3) and dumping core)."
23:24:10 <paczesiowa> has anyone ever ported c++ code to haskell with nice translation of overloading?
23:24:53 <paczesiowa> in qthaskell there are fun1..funN for every overloaded method fun
23:29:19 <cjs> What is this syntax? newtype Get a = Get { unGet :: S -> (a, S) }
23:29:28 <cjs> (The "unGet ::" part I mean?)
23:29:36 <sjanssen> cjs: the {} part?  Record syntax
23:29:37 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
23:29:53 <cjs> On a newtype?
23:29:56 <sjanssen> yep
23:30:23 <sjanssen> it's just a little trick to make an unwrapper very easily
23:30:46 <sjanssen> instead of writing: newtype Get a = Get (S -> (a, S)); unGet (Get x) = x
23:46:19 <cjs> Does it make sense to use a lazy bytestring to read from the network? I guess as much as from a disk, right? When data are available, my reads will return?
23:47:23 <cjs> BTW, hoogle finds modules just fine.
23:47:27 <cjs> @hoogle ByteString
23:47:27 <lambdabot> Data.ByteString :: module
23:47:27 <lambdabot> Data.ByteString.ByteString :: data ByteString
23:47:27 <lambdabot> Data.ByteString.Internal.ByteString :: data ByteString
23:51:52 <dons> cjs, yes, people use it like that
23:51:52 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
23:51:58 <dons> you might need to read chunks non-blocking
23:53:22 <cjs> It's a separate thread, so I'm perfectly happy to block on reads. I can't do anything with a message until I've read it completely anyway.
23:55:06 <bd_> Well, you'll have to make sure you don't end up reading 4kb out of a 1kb message, and blocking until the other 3kb arrive
23:55:20 <cjs> But it appears when converting from hGet::Data.ByteString and friends to using Data.Binary, I've got to switch from strict to lazy ByteStrings, and this propagates all the way back up to where I open the handle, since I now appear to have to pass around the lazy ByteString instead of the handle.
23:55:45 <cjs> Oh, that's no problem. I specify an exact length for every read.
23:55:59 <cjs> (And that length is the minimum I must read before continuing.)
23:56:10 <cjs> s/continuing/being able to continue any processing/
23:56:47 <bd_> ah, okay then :)
23:57:27 <cjs> Seems to me you're quite as likely to end up doing that on a handle, too, anyway. It's all in the technique.
23:57:49 <cjs> Well, I suppose on a handle you're not likely to do an accidently foldl.
23:59:01 <bd_> you could also use unsafeInterleaveIO and a non-blocking read to read out just what is available from the handle and tack it on as another chunk in the lazy bytestring
23:59:31 <cjs> Wow, that sounds fun. I'm glad that the protocol doesn't require that.
