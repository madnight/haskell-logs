00:00:10 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
00:00:11 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
00:00:18 <ddarius> Cale: That's 'cuz you're into combinatorics.
00:00:40 <ziman> :t sequence
00:00:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
00:00:42 <Cale> ddarius: Also, because it has an evaluation order which is very different from the execution order.
00:00:52 <Cale> and it's extremely simple
00:01:12 <solrize_> @hoogle forall b. a->b
00:01:13 <lambdabot> Did you mean: Forall B. a -> b
00:01:13 <lambdabot> Prelude.id :: a -> a
00:01:13 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
00:01:46 <solrize_> @hoogle Forall B. a->b
00:01:46 <lambdabot> No matches, try a more general search
00:01:50 * solrize_ shrug
00:01:51 <Cale> So it's a nice kind-of-generic point in the space of monads :)
00:02:16 <Cale> solrize_: Hoogle actually doesn't know about forall
00:02:18 <bd_> Showing how things generalize from Maybe to List is also quite informative, imo
00:02:38 <Cale> I also really like parsing monads for similar reasons :)
00:07:00 <cjs> I can't use (:+) as an operator?
00:07:07 <bd_> :t (:+)
00:07:08 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
00:07:14 <bd_> already exists :)
00:07:21 <solrize_> :t ;-)
00:07:22 <lambdabot> parse error on input `;'
00:07:31 <bd_> you could import Prelude hiding ((:+)), perhaps
00:07:38 <cjs> Oh, that's why. Ok, "Invalid type signature" was slightly misleading me for a moment.
00:07:52 <cjs> Nah, I'll just use (+:).
00:07:59 <bd_> :t (+:)
00:08:00 <lambdabot> Not in scope: `+:'
00:08:06 <solrize_> > 3 :+ 4
00:08:07 <lambdabot>  3.0 :+ 4.0
00:08:40 <solrize_> (0 :+ 1) ** 2
00:08:44 <solrize_> > (0 :+ 1) ** 2
00:08:45 <lambdabot>  (-1.0) :+ 1.2246063538223773e-16
00:08:54 <solrize_> close enough for govt work
00:10:34 <olsner> as long as you don't lose more than $(10^-16)i, it's OK
00:10:58 <Cale> > exp (0 :+ pi)
00:10:59 <lambdabot>  (-1.0) :+ 1.2246063538223773e-16
00:11:14 <Cale> > exp (0 :+ pi) == (0 :+ 1) ** 2
00:11:15 <lambdabot>  True
00:11:17 <Cale> ;)
00:11:32 <solrize_> (0 :+ 1) ** (0 :+ 1)
00:11:35 <solrize_> > (0 :+ 1) ** (0 :+ 1)
00:11:35 <lambdabot>  0.20787957635076193 :+ 0.0
00:12:09 <Cale> > exp (-pi/2)
00:12:10 <lambdabot>  0.20787957635076193
00:12:28 <solrize_> hehe
00:13:55 <solrize_> > let t =(1+sqrt(5))/2 in t**(-1/t)
00:13:56 <lambdabot>  0.7427429446246816
00:15:23 <Cale> > let t = 2/(1 + sqrt 5) in t^t
00:15:23 <lambdabot>  Add a type signature
00:15:26 <Cale> > let t = 2/(1 + sqrt 5) in t**t
00:15:27 <lambdabot>  0.7427429446246817
00:16:55 <ddarius> > range ((0,0),(3,3))
00:16:56 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3,...
00:19:51 <scook0> @hoogle intersperse
00:19:51 <lambdabot> Data.List.intersperse :: a -> [a] -> [a]
00:19:52 <lambdabot> Data.ByteString.intersperse :: Word8 -> ByteString -> ByteString
00:19:52 <lambdabot> Data.ByteString.Char8.intersperse :: Char -> ByteString -> ByteString
00:26:29 <ziman> i have a function called `primes' that returns an infinite list of primes (which is a quite time-expensive operation). it's used in an algorithm where primes are repeatedly iterated over to factor various numbers. are the primes calculated always all over again or do they get cached?
00:27:28 <cjs> Aw! "(`Monad' is not a derivable class)"
00:27:33 <Japsu> ziman: afaik with your infinite list approach they do get cached
00:28:33 <Cale> ziman: Is it a function, or is it a list?
00:28:38 <scook0> assuming your list of primes is let-bound somewhere
00:28:38 <nominolo> ziman: but it's likely to be quadratic
00:28:59 <Cale> ziman: The results of evaluating functions are not cached, but constants (even infinite lists), are only computed once.
00:29:44 <Cale> cjs: Monad is derivable however, for newtypes where the original type was a monad.
00:30:00 <nominolo> ziman: take a look at this: http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
00:30:35 <ziman> Cale, well it's a function (everything is, isn't it?): primes :: [Integer]
00:30:43 <Cale> ziman: No, that's just a list :)
00:31:06 <Cale> ziman: If it were something like  primes :: Integer -> [Integer], then the result wouldn't be kept.
00:31:45 <ziman> nominolo, thanks, i will
00:31:51 <Cale> Some people like to think of other values as nullary functions, but I find that isn't such a useful approach much of the time ;)
00:32:02 <ziman> i see
00:33:15 <solrize_> foo
00:33:25 <solrize_> oops
00:34:30 <ziman> well, i have an idea that nullary functions create thunks which are cached then; so when i want to do some common subexpression elimination i just need to name the subexpression and it'll be cached
00:34:36 <ziman> is that true?
00:35:17 <Cale> Well, yeah, I think.
00:35:38 <Cale> Named values are only computed once so long as they remain in scope.
00:35:58 <scook0> just be careful with class-polymorphism
00:36:19 <Cale> Right, typeclass polymorphic values won't be cached, since they're actually functions of the typeclass dictionary.
00:36:43 <ziman> thanks :)
00:37:09 <nominolo> Cale: not necessarily in JHC
00:37:24 <Cale> sure, not necessarily in JHC :)
00:37:42 <Cale> Of course, all of this is subject to change in a different implementation
00:38:04 <scook0> strictly speaking, I don't think a Haskell implementation is required to cache anything at all
00:38:05 <Cale> All the standard says is that Haskell has non-strict semantics :)
00:38:18 <Cale> So yeah, you could use normal order evaluation even.
00:38:34 <Cale> Or needlessly evaluate things again once they finish evaluatign
00:38:40 <Cale> -ing*
00:39:31 <scook0> I remember having to take special care to make a top-level polymorphic constant memoizable
00:40:31 <scook0> I ended up with a top-level binding of type Integer, and made the polymorphic binding use fromInteger on that
00:59:22 <ivan_salazar_v> @t PortNumber
00:59:22 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
00:59:48 <ivan_salazar_v> :t PortNumber
00:59:49 <lambdabot> Not in scope: data constructor `PortNumber'
00:59:59 <ivan_salazar_v> :t Network.PortNumber
01:00:00 <lambdabot> Network.Socket.PortNumber -> Network.PortID
01:00:09 <ivan_salazar_v> :t Network.PortID
01:00:10 <lambdabot> Not in scope: data constructor `Network.PortID'
01:00:51 <Cale> ivan_salazar_v: PortNumber is a type which is an instance of Num, as well as a data constructor
01:01:00 <Cale> (of the PortID type)
01:01:35 <ivan_salazar_v> does read knows how to handle that?
01:02:10 <Cale> hmm, it's not an instance of Read, but you could read an Integer, and then use fromInteger or fromIntegral to convert
01:02:21 <ivan_salazar_v> ooooh, man, thanks.
01:05:10 <ivan_salazar_v> Cale: Thanks, really I was going mad looking for a function named "toPortNumber"
01:05:21 <Cale> :)
01:05:38 <ivan_salazar_v> Cale: As you have noticed, I'm still a newbie XD
01:05:54 <solrize_> don't you just say Portnumber 80  or something like that?
01:05:59 <Cale> That's all right, we all have been :)
01:06:03 <ddarius> solrize: You just say 80.
01:06:14 <Cale> solrize_: Yeah, if you have a static PortID that you want.
01:06:30 <Cale> :t Network.PortNumber 80
01:06:31 <lambdabot> Network.PortID
01:06:42 <ddarius> :t 80 :: Network.PortID
01:06:43 <lambdabot>     No instance for (Num Network.PortID)
01:06:43 <lambdabot>       arising from the literal `80' at <interactive>:1:0-1
01:06:43 <lambdabot>     Possible fix: add an instance declaration for (Num Network.PortID)
01:07:02 <Cale> :t 80 :: Network.PortNumber
01:07:03 <lambdabot> Network.Socket.PortNumber
01:07:16 <ddarius> Wrong type.
01:08:28 <ivan_salazar_v> I was doing something like this: let port = maybe (1729) (read) (lookup "port" conf) :: Integer
01:08:52 <ivan_salazar_v> that's why I didn't used a hard coded value
01:16:14 <ski> hm ..
01:16:46 <ski> it appears that when Heffalump emptied the ban list, IRSeekBot crept back in here
01:17:13 --- mode: ChanServ set +o Cale
01:17:22 --- mode: Cale set +b *!*@*irseek/log-bot/IRSeekBot
01:17:29 --- mode: Cale set -o Cale
01:17:33 <ski> (i don't know the earlier specific reason for banning it, but speaking for myself, i'd prefer not having that thing here)
01:18:05 <Cale> I think some people didn't like it, and wanted it banned.
01:18:11 <Cale> So I'll go along with that.
01:18:23 <elaforge> ok, here it goes again... does anyone understand -main-is?
01:18:34 <ski> Cale : you'll wait 'til it disconnects itself, or kick it now ?
01:18:36 <Cale> sure, though I wouldn't usually recommend it
01:18:51 <Cale> ski: Doesn't need kicking, it's no longer getting messages from the channel.
01:19:00 <ski> oh
01:19:14 <solrize_> how is it no longer getting messages?  it's on channel...
01:19:18 * ski is not so familiar with all these op features of irc
01:19:21 <Cale> solrize_: it's banned
01:19:26 <solrize_> so it stops listening?
01:19:27 <elaforge> when I run it on a new file, I get _ZCMain_main_closure etc., when I mess with the file in random ways it goes away
01:19:57 <elaforge> I haven't figured out "random ways" enough to script that though
01:19:59 <ski> mayhaps Cale means that the server stops relaying on-channel messages to banned nicks
01:20:18 <Cale> I'm fairly sure that's the case.
01:20:34 --- mode: ChanServ set +o Cale
01:20:36 <bg> That doesn't happen
01:20:40 <opqdonut> yeah
01:20:43 <bg> You can only not send if you're banned
01:20:48 <elaforge> and is there an alternative?  I'm compiling tests and one directory will have a lot of them
01:20:51 <opqdonut> you need a specific channel mode for that
01:20:53 --- kick: IRSeekBot was kicked by Cale (Cale)
01:20:56 <glguy> BOOM
01:21:01 <opqdonut> HEADSHOT
01:21:04 <Cale> all right, I'll kick it to be sure
01:21:06 <opqdonut> >_>
01:21:13 <ski> ty
01:21:16 <solrize_> i just tried on another channel and i can hear other people when i'm banned
01:21:32 <glguy> were you really obnoxious to get the test ban?
01:21:35 <glguy> or did you just ask
01:21:42 <idnar> haha
01:21:48 --- mode: Cale set -o Cale
01:21:49 <solrize_> at least on undernet i can both send and receive while banned
01:22:10 <solrize_> banning only prevents joining the channel, nothing else, as far as i can tell
01:22:11 <Cale> solrize_: Yeah, I didn't think freenode was like that though.
01:22:17 <solrize_> could be
01:22:23 <Cale> solrize_: At least on freenode you can't send.
01:22:37 <bg> solrize_: not really, you should be getting messages in your status window ("cannot send to channel")
01:22:43 <Cale> I was pretty sure you couldn't receive either, but I may be wrong about that.
01:23:32 <bg> IRC doesn't relay messages back to you that you've sent, so your client may still think that you're sending, even if you're banned
01:24:07 <idnar> right, you shouldn't be able to send
01:24:17 <bg> Unless you're chanop/voice of course
01:24:26 <idnar> oh yeah, true
01:24:30 <Twey> +v overrides +b?
01:24:42 <solrize_> hmm i can send while banned here on freenode too
01:24:53 <Twey> solrize_: No, it prevents sending
01:25:04 <opqdonut> let's ban someone and find out?-)
01:25:06 <cjs> Is it possible to set up a package.conf for a particular project (that's got a full release directory with bin, lib, etc. etc.)?
01:25:07 <solrize_> i just tried and i can send
01:25:12 * Twey volunteers.
01:25:35 <elaforge> no one else sees that error?
01:27:37 <Twey> Yep, definitely RO.
01:27:39 <solrize_> looks like banned ppl can hear but not send
01:28:42 <Cale> solrize_: Yeah, I just convinced myself of that as well :)
01:35:18 <elaforge> maybe I'll ask on haskell-cafe then
01:37:50 <cjs> Hm. How does one convince a cabal build to use a specified package database, other than global and user?
01:39:04 <Lemmih> cjs: --package-db ?
01:53:56 <Cale> elaforge: I suppose -main-is would be appropriate for that.
01:54:18 <Cale> elaforge: But you might just put them all in separate files (and import any common bits from another module)
01:54:21 <elaforge> Cale, I figured out that if I empty the file, compile, and then put stuff back in, it works
01:54:33 <elaforge> and stays working
01:54:37 <Cale> odd
01:54:42 <elaforge> they actually are in separate files
01:54:47 <elaforge> ModuleName_test.hs
01:55:12 <elaforge> definitely odd, because it stays working even after a make clean
01:55:27 <Cale> You're removing the .o and .hi files?
01:55:34 <elaforge> yep
01:55:35 <dcoutts> Lemmih: ping
01:55:39 <dcoutts> @seen Lemmih
01:55:39 <lambdabot> Lemmih is in #haskell-hac4 and #haskell. I last heard Lemmih speak 16m 35s ago.
01:57:33 <elaforge> but in general I wind up using a lot of -main-is, because there can only be one Main.hs, but I have a number of binaries to build
01:58:47 <Lemmih> dcoutts: Hi.
01:58:54 <dcoutts> Lemmih: hia
01:59:15 <dcoutts> Lemmih: so I'm wondering how to meet up with you tomorrow
01:59:15 <Cale> elaforge: Why not just start the modules with "module Main where" ?
01:59:31 <dcoutts> Lemmih: did you get my message about train times, and do you have a mobile number?
01:59:37 <Cale> elaforge: (or not have a module decl at all, for that matter)
01:59:58 <Lemmih> dcoutts: Yes, and I do not have a cellphone.
02:00:00 <Cale> elaforge: If they're already separated from the rest of the program, that should be okay, right?
02:00:09 <elaforge> Cale ghc says: file name does not match module name `Main'
02:00:14 <Lemmih> dcoutts: I was thinking I'd pick you up at the train station.
02:00:22 <elaforge> ghci, actually, lemme try ghc
02:00:27 <Cale> elaforge: huh, it doesn't do that for me
02:00:33 <dcoutts> Lemmih: oh great, ah just got your email, I'm happy to get the earlier train to gbg
02:00:42 <elaforge> and would that interfere with hpc tix?
02:00:49 <Cale> I don't know.
02:00:53 <elaforge> lemme try
02:02:11 <ndm> @seen kosmikus
02:02:11 <lambdabot> kosmikus is in #haskell-hac4, #gentoo-haskell, #darcs, #ghc and #haskell. I last heard kosmikus speak 4m 43s ago.
02:02:24 <elaforge> looks like ghc is ok with no module name, but ghci isn't
02:02:36 <kosmikus> hi ndm
02:02:42 <ndm> kosmikus: i am trying to use lhs2tex with \usepackage{setspace} \onehalfspacing
02:02:51 <dcoutts> Lemmih: ok, great, you've got my mobile number
02:03:07 <ndm> kosmikus: it makes the code in figures single spaced, but the code in the flow of the text 1.5 spaced - i'd like it to be single spaced code everywhere
02:03:07 <kosmikus> ndm: I've never tried that before ...
02:03:23 <dcoutts> Lemmih: do you have a number I can call in case trains are late etc so I can tell you when I'll arrive etc
02:03:25 <ndm> any idea why its doing different things in different places?
02:03:37 <dcoutts> Lemmih: so I don't leave you waiting if I'm forced to catch a later train
02:03:41 <kosmikus> singe spaced everywhere, not 1.5-spaced everywhere?
02:03:43 <ndm> I tried: \let\oldhscode\hscode\renewenvironment{hscode}    {\begin{singlespace}\begin{oldhscode}}    {\end{oldhscode}\end{singlespace}}
02:03:43 <dcoutts> hia ndm
02:03:48 <ndm> hi dcoutts
02:04:03 <kosmikus> ndm: do you have a small sample document?
02:04:06 <ndm> kosmikus: single spaced code, 1.5 spaced text - i'd rather single spaced text but the rules specify it must be 1.5 text
02:04:14 <ndm> kosmikus: i can knock one up easy enough
02:04:39 <kosmikus> yes, that'd certainly help me to understand what you want :)
02:06:33 <elaforge> Cale, yeah, looks like all the tests overwrite .hpc/Main.mix which breaks it
02:06:43 <elaforge> unfortunately tests are exactly where I want to use hpc
02:07:00 <elaforge> oh well, I don't fully understand hpc yet so maybe there's a way around
02:07:10 <elaforge> thanks for your help!
02:07:51 <ndm> kosmikus: http://hpaste.org/6909
02:08:16 <ndm> kosmikus: the code in the figure gives no spacing between lines, the code in the body gives double spacing (easier to see if its double)
02:08:20 <kosmikus> ndm: thanks
02:08:29 <ndm> I want single spacing in all code, but double spacing in all text
02:09:39 <kosmikus> I see.
02:09:54 <kosmikus> I misunderstood what you meant by "in flow of text" initially
02:10:04 <kosmikus> it's indeed strange that it's different
02:10:54 <kosmikus> but it seems to be just general setspace behaviour to have figures single-spaced
02:13:18 <ndm> fair enough, anyway to override it to give single spacing in all code?
02:13:50 <kosmikus> yes, I'm trying ;)
02:15:13 <kosmikus> ndm: \renewcommand\hscodestyle{\setstretch{1}}
02:15:48 <ndm> @karma+ kosmikus
02:15:48 <lambdabot> kosmikus's karma raised to 8.
02:15:54 <ndm> perfect! many many thanks
02:17:56 <todsmatrix> hi
02:33:16 <dcoutts> @seen dons
02:33:16 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc and #haskell. I last heard dons speak 4h 40m 22s ago.
02:36:58 <cjs> Wow, project-based package build all done. That sure was easy. Another win for GHC!
02:38:25 <cjs> elaforge: Did you get your problem worked out?
03:10:24 <cjs> Well, time for a nomikai.
04:26:10 <swiert> The Monad.Reader Issue 10 is out:
04:26:11 <swiert> http://www.haskell.org/haskellwiki/The_Monad.Reader
04:26:12 <lambdabot> Title: The Monad.Reader - HaskellWiki
04:37:55 <MarcWeber> @seen beschmi
04:37:55 <lambdabot> I haven't seen beschmi.
04:38:55 <ikegami--> I have not know the ':step' feature of GHCi before reading the latest "The Monad.Reader"
04:39:40 <ikegami--> good article
04:59:34 <Boney> Hi Haskellers.  Is anyone aware of extra type contraints that can be used to create for example, a type who's value can only be an integer above zero, because it's a count of how many things something has,  or an irrational number between 0 and 1 to represent a percentage?
04:59:53 <Boney> err, rational.
05:02:43 <swiert> Boney: You could define Peano numbers:
05:02:53 <swiert> data Nat = Zero | Succ Nat
05:03:06 <swiert> Not terribly efficient, though.
05:04:50 <EvilTerran> Boney, you could make a newtype of, say, Integer or Double, and re-implement Num etcetera to do bounds checking
05:05:10 <EvilTerran> unfortunately, there's no simple way of doing this, AFAIK
05:05:50 <nominolo> @google lightweight static capabilities
05:05:53 <lambdabot> http://lambda-the-ultimate.org/node/1635
05:05:53 <lambdabot> Title: Lightweight Static Capabilities | Lambda the Ultimate
05:06:17 <nominolo> Boney: see this for an example to have "certified" bounds checking
05:06:47 <nominolo> though, the approach is different
05:07:19 <nominolo> the common way is: newtype + Num instance
05:10:04 * EvilTerran realises that he seems to be CPS-transforming his types
05:10:08 * EvilTerran stops that at once
05:10:51 <jadrian> is there a name for non-polymorphic functions
05:10:59 <jadrian> better than, non-polymorphic ;)
05:11:10 <EvilTerran> monomorphic
05:11:20 <jadrian> that actually makes sense
05:11:23 <jadrian> :)
05:11:25 <EvilTerran> as in Dreaded Monomorphism Restriction
05:11:30 <jadrian> yeap
05:11:37 <EvilTerran> which restricts things to be monomorphic
05:11:39 <jadrian> how didn't I think about that
05:12:48 <EvilTerran> i had an "oh! that's awfully clever!" moment the first time i encountered the term
05:13:55 <jadrian> :D
05:37:52 <timd> Hi all - just playing with Data.Reactive for the first time.
05:39:14 <timd> My gtk+cairo+reactive app works for a little while, then starts printing "<<loop>>", and stops responding. What does "<<loop>>" mean? What prints it?
05:40:09 <Deewiant> > let foo = foo in foo
05:40:10 <lambdabot>  Exception: <<loop>>
05:40:31 <Deewiant> > let f n = f (n + 1) in f 0
05:40:37 <lambdabot> Terminated
05:41:15 <Deewiant> I /think/ it's for cases where the runtime system can detect an infinite loop and chooses to abort your program instead
05:41:38 <timd> We'll it's not actually aborting, but perhaps one thread is...
05:41:42 <Deewiant> or maybe the detection is done at compile time, I'm not sure
05:41:50 <timd> Thanks, BTW.
05:42:00 <Deewiant> no problem
05:42:25 <timd> It's odd that it seems to be non-deterministic.
05:42:31 <timd> (in my prog)
05:42:47 <jadrian> are there any news on the Haskell work by the Linspire guys?
05:43:48 <skorpan> > curry (x, y)
05:43:48 <lambdabot>  Couldn't match expected type `(a, b) -> c'
05:43:57 <skorpan> of course.
05:44:30 <jadrian> they announced in 2006 that Haskell was selected as their primary language for core OS devel
05:44:45 <jadrian> and even talked about bindings for Qt and KDE
05:44:54 <jadrian> but then never heard about it anymore
05:45:03 <jadrian> and that was 2 years ago already
05:45:33 <ziman> i can't quite imagine how a language like haskell can effectively be used as a system utility language :)
05:46:10 <nornagon> 'system utility language'?
05:46:14 <pejo> ziman, because?
05:46:40 <MarcWeber> Qt gets PHP bindings using roadsend ..
05:47:22 <MarcWeber> pejo: Maybe because executables are bigger than C apps ?
05:47:22 <Boney> swiert, EvilTerran and nornagon: Thanks for your replies, sorry I was distracted reading Monad.Reader
05:47:36 <nornagon> er, what did i reply to?
05:50:07 <Boney> my question about restricting types.
05:50:40 <Boney> all the replies where good, but don't fit the more compliated situation I'm having, I beleive I'll have to go without.
05:50:41 <ziman> because i perceive haskell programs as... a bit closed, interacting only when inevitable, while utilities need to touch this, move that all the time; what advantages does haskell have in this field?
05:50:52 <nornagon> Boney: itym nominolo
05:51:21 <Boney> oh, my mistake, Thanks nominolo
05:51:26 <nornagon> ziman: that's a pretty silly way to look at it. Haskell is an imperative language too :)
05:51:53 <sclv> Boney: have you seen the "Restricted Datatypes in Haskell" paper?
05:52:00 <nornagon> there are not really very many differences between C and IO code in Haskell.
05:52:05 <pejo> ziman, look at the CUFP reports, I think the (former?) linspire people are quite open about what they are doing and saying that it works well.
05:52:12 <nornagon> except that in Haskell it's all typechecked and nice.
05:52:16 <Boney> sclv: no,  I'll look around for it.
05:52:42 <nornagon> plus you get to use pure code when you want it.
05:52:47 <sclv> my last blog entry is sort of about it: http://fmapfixreturn.wordpress.com/
05:52:47 <lambdabot> Title: fmap fix return
05:53:13 <nornagon> ziman: haskell also has constructs that work like pipes in sh
05:53:31 <sclv> if you need to use them recursively, you can also get some ideas from Scrap Your Boilerplate With Class
05:53:46 <nornagon> and nice ways to compose a number of actions (eg using the list monad to build up a series of actions to be taken)
05:55:25 <Boney> sclv: I've found the paper.  thanks.
05:55:40 <ziman> uhm
05:56:20 <Boney> > fix return
05:56:20 <lambdabot>      Occurs check: cannot construct the infinite type: a = m a
05:56:20 <lambdabot>       Expected...
05:59:25 <nominolo> swiert: love the editorial for TMR10
06:00:49 <Boney> > fmap fix return
06:00:49 <lambdabot>  Add a type signature
06:00:54 <Boney> > fmap fix return :: ()
06:00:54 <lambdabot>  Couldn't match expected type `()' against inferred type `a -> a'
06:01:08 <Boney> :t fmap fix return
06:01:09 <lambdabot> forall a. a -> a
06:01:11 <swiert> nominolo: Thanks.
06:01:20 <Boney> > fmap fix return $ 3
06:01:20 <ziman> @src foldl
06:01:21 <lambdabot> foldl f z []     = z
06:01:21 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:01:21 <lambdabot>  3
06:01:21 <swiert> nominolo: I made a resolution to stop writing boring editorials.
06:01:40 <Boney> neat,
06:01:59 <HunterXHunter> @src foldr
06:01:59 <lambdabot> foldr f z []     = z
06:01:59 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:02:25 <ziman> why does `foldl (+) 0 [1..1000000]' fail with stack overflow?
06:02:57 <ziman> shouldn't it be reduced to tail recursion?
06:02:59 <Deewiant> > foldl (+) 0 [a,b,c,d,e]
06:02:59 <lambdabot>  0 + a + b + c + d + e
06:03:04 <nominolo> :t fmap fix return
06:03:05 <lambdabot> forall a. a -> a
06:03:13 <Deewiant> it just keeps on adding those +'s, never evaluating them
06:03:29 <ziman> oh, i see
06:03:39 <nominolo> ziman: use foldl'
06:03:39 <HunterXHunter> > foldr (+) 0 [a,b,c,d,e]
06:03:40 <lambdabot>  a + (b + (c + (d + (e + 0))))
06:03:41 <Deewiant> you should use foldl' in almost all cases
06:03:54 <ziman> @src foldl'
06:03:55 <lambdabot> foldl' f a []     = a
06:03:55 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
06:03:55 <Deewiant> since it's strict, and evaluates the intermediate results.
06:03:57 <Boney> :t foldl'
06:03:58 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
06:04:15 <Deewiant> > foldl' f i [a,b,c,d,e]
06:04:15 <lambdabot>  f (f (f (f (f i a) b) c) d) e
06:04:23 <Deewiant> seeing it that way is maybe a bit clearer.
06:04:26 <ziman> thanks
06:05:06 * shepheb has used QC to convice himself that fmap fix return == id, but suspects a pending brain explosion when he starts to understand why.
06:05:31 <Saizan> long answer: http://www.haskell.org/haskellwiki/Stack_overflow
06:05:32 <lambdabot> Title: Stack overflow - HaskellWiki
06:05:43 <kpreid> @src (->) return
06:05:43 <lambdabot> return = const
06:06:00 <kpreid> shepheb: return is const, so you're just ignoring the argument fix provides
06:06:04 <Boney> shepheb: look at fix and fmap
06:06:13 <kpreid> @unpl fmap fix return
06:06:13 <lambdabot> fmap fix return
06:06:29 <Boney> to make it simplier,
06:06:37 <Boney> > map fix const $ 3
06:06:37 <lambdabot>  3
06:06:39 <kpreid> @unpl (.) fix (\_ x -> x)
06:06:39 <lambdabot> (\ c -> fix (\ x -> x))
06:06:59 <Boney> I've removed the monads,
06:07:40 <shepheb> @ty const
06:07:41 <lambdabot> forall a b. a -> b -> a
06:07:44 <Saizan> you've keeped the functor? :)
06:08:17 <kpreid> @type fmap (+1) return
06:08:19 <Saizan> return :: Functor f, Monad m => f (m a) for some f and m
06:08:19 <lambdabot> forall a (m :: * -> *). (Monad m, Num (m a)) => a -> m a
06:08:33 <shepheb> @ty fmap
06:08:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:10:33 <shepheb> I'm confused by the map fix const $ 3, how is const an acceptable list?
06:12:01 <Deewiant> @ty map
06:12:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:12:16 <Deewiant> it's not, but in Caleskell map == (.) == fmap
06:12:38 <shepheb> ah, very well.
06:13:00 * shepheb 's mind ignores the middle part of that for now. map == fmap I can roll with.
06:13:05 * SamB wonders what keywords jane street capital is using that they get their ads on my inbox
06:13:28 <Saizan> shepheb: you need fmap == (.) to understand fmap fix return
06:13:47 <Deewiant> @src (->) fmap
06:13:47 <lambdabot> fmap = (.)
06:13:55 <SamB> @src (.)
06:13:55 <lambdabot> (f . g) x = f (g x)
06:14:00 <shepheb> Saizan: I'm working on that now.
06:14:08 <SamB> @type (.)
06:14:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:14:33 <EvilTerran> shepheb, i find it helps if you think of a -> b as being like Map a b
06:15:01 <SamB> See, Cale wrote a different (.)
06:15:08 <SamB> this (.) = fmap
06:15:26 <shepheb> which is theoretically true, but not in standard Haskell?
06:15:37 <SamB> well, it's a generalization
06:15:41 <EvilTerran> fmap f m ! ix = f (m ! ix), yes?
06:16:06 <shepheb> @ty (!)
06:16:07 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
06:16:18 <EvilTerran> so if g = (m!), fmap f g ix = f (g ix) = (f . g) ix, so fmap = (.)
06:16:34 <SamB> @instances Functor
06:16:34 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
06:16:39 <EvilTerran> (cheating a teensy bit somewhere in the middle there, but nvm)
06:17:06 <SamB> is Array a Functor?
06:17:11 <EvilTerran> the (e ->) functor is much like the (Map i) functor, except abstract mappings instead of concrete ones
06:17:22 <EvilTerran> ?instances-importing Data.Array Functor
06:17:22 <lambdabot> ((,) a), ((->) r), Array i, Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
06:17:27 <EvilTerran> yes :)
06:17:32 <SamB> EvilTerran: also, Map isn't a functor
06:17:35 <SamB> is it?
06:17:40 <SamB> oh, wait, yes it is
06:17:41 <EvilTerran> ?instances-importing Data.Map Functor
06:17:42 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Map k, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
06:17:46 <EvilTerran> yes :)
06:17:48 <SamB> since it is polymorphic in value types
06:17:51 <SamB> right
06:18:00 <SamB> set is the one that isn't
06:18:22 * EvilTerran really quite likes his analogy between (e ->) and (Map i), there
06:18:23 <shepheb> RWS = "ReaderWriterState"?
06:18:32 <shepheb> EvilTerran: that's definitely helping
06:18:47 <EvilTerran> indeed, RWS gives you all three
06:19:08 <EvilTerran> happy to help :)
06:19:18 <timd> jadrian: the linspire haskell guys quit linspire, and started a new company using haskell for educational software development.
06:19:47 <flux> I suppose linspire still keeps going on the haskell track?
06:20:17 <scook0> wonder how that works out for linspire
06:20:32 <timd> It didn't sound like it - I suspect that the haskell enthusiam walked out the door with the staff.
06:21:03 <flux> I wonder what happened to the earlier ocaml-enthusiasm they had before haskell :)
06:21:14 <flux> (that is, do they make that kind of decisions lightly..)
06:21:41 <tromp> :t \f -> fmap f return
06:21:42 <lambdabot> forall b a (m :: * -> *). (Monad m) => (m a -> b) -> a -> b
06:22:58 <shepheb> :t fix
06:22:59 <lambdabot> forall a. (a -> a) -> a
06:23:08 <timd> I guess trying to build a distro with new tools in a new languages is a noble goal, but it's easy to underestimate the man-years in the existing tools (bash though they might be!)
06:24:18 <shepheb> I need to internalize the (->) e monad a bit more. but clearly fix is an acceptable ma -> b
06:24:24 <shepheb> ma
06:24:27 <shepheb> damn it. m a
06:28:21 <vincenz> :t fmap fix return
06:28:22 <lambdabot> forall a. a -> a
06:28:33 <vincenz> > fmap fix return [a]
06:28:34 <lambdabot>  [a]
06:28:36 * shepheb ponders the transition point from having one's brain explode, and generating new material to make other brains explode. Haskell has been very intellectually exhilerating and humbling for me.
06:28:40 <vincenz> > fmap fix return [a,b,c,d]
06:28:40 <lambdabot>  [a,b,c,d]
06:28:56 <vincenz> Kinda useless :)
06:28:59 <shepheb> yes, I have myself convinced that fmap fix return == id, it's the why that I'm working on.
06:29:16 <shepheb> well, yes. but clever, and it's a koan from which I can gain understanding.
06:29:18 <timd> Well thanks to Deewiant, I've tracked down what loop means, from Control.Exception: NonTermination: The current thread is stuck in an infinite loop. This exception may or may not be thrown when the program is non-terminating.
06:29:53 <timd> Anyone know in more detail what circumstances ghc will throw this thing?
06:30:47 <scook0> iirc, it can mean that a thread tries to enter a thunk that it's already inside
06:30:48 <shepheb> truly circular lets will throw it. any time it tries to start evaluating a thunk while evaluating that same thunk, it will throw that exception.
06:32:37 <timd> Hmmm, my code is only 90 lines, but it's building on ghk, with threads, and the data.reactive stuff. Working out what's going on here might be hard.
06:34:50 <tromp> only tricky part of fmap fix return is figuring out what functor/monad it uses
06:36:20 <shepheb> @src (->) return
06:36:20 <lambdabot> return = const
06:36:55 <shepheb> that one!
06:37:13 <shepheb> :t fmap fix
06:37:14 <lambdabot> forall a (f :: * -> *). (Functor f) => f (a -> a) -> f a
06:37:20 <tromp> (->) is not a monad :(
06:37:57 <shepheb> @src ((->)e) return
06:37:57 <lambdabot> Source not found. Do you think like you type?
06:38:58 <tromp> aren't (a->) and (->a) both monads ?
06:39:23 <shepheb> certainly the former is. the latter I don't think so.
06:39:59 <shepheb> monads only parameterize over their return type, so I don't see how the latter could be a monad.
06:40:28 <Boney> shepheb, timd: try map fix const, it removes the monad-ness,
06:40:52 <Boney> You can probably work through a proof by subsututing sources for fix and const into map.
06:41:00 <tromp> :t map fix const
06:41:01 <lambdabot> forall a. a -> a
06:41:05 <tromp> :t map
06:41:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:41:19 <shepheb> I'm getting increasingly comfortable with it.
06:41:27 <tromp> ah, this is an fmap called map:)
06:42:28 <Boney> @src fix
06:42:28 <lambdabot> fix f = let x = f x in x
06:44:29 <byorgey> oh, did Cale change map to fmap too?
06:45:16 <byorgey> > map (+1) (2,3)
06:45:16 <lambdabot>  (2,4)
06:45:25 <byorgey> apparently so
06:47:22 <shepheb> I need to improve my functor-spotting and monad-spotting. would every size tuple, with all types defined but one, be a functor?
06:49:25 <scook0> yeah
06:49:58 <EvilTerran> as would data Two a = Two a a; data Three a = Three a a a; etc
06:50:05 <shepheb> I suppose (a,a) is a functor too, and so would be (a, String, a, a)
06:50:11 <shepheb> as long as there's only one free type.
06:50:30 <EvilTerran> well, you'd need to wrap it in a data or newtype so as to make the free type a parameter
06:50:37 <scook0> be careful of the distinction between things that are functors, and things that can actually have a Functor instance defined
06:50:53 <EvilTerran> functors vs Functors, yeah
06:51:09 <byorgey> for example, (a, String) is a functor, but you can't define a Functor instance for it (not without a newtype)
06:51:52 <shepheb> okay, I was going to ask. is that the main limitation, that we need an explicit parameter type rather than merely a free type?
06:52:21 <byorgey> well, you need to be able to leave the parameter type off the end
06:52:25 <scook0> it has to be the last type parameter
06:52:36 <scook0> though as EvilTerran pointed out, you can always use a newtype
06:52:51 <scook0> to shuffle the parameters, at the cost of some convenience
06:52:51 <byorgey> so you can say  instance Functor (,) b where ...  but you can't say  instance Functor (,) _ b where ...
06:52:58 <EvilTerran> and it doesn't work for type aliases
06:53:21 <shepheb> well, type aliases don't contain any power, I believe. they're just a notational shorthand.
06:53:49 <byorgey> if we had type-lambdas...  instance Functor (\a -> (,) a b) ... ;)
06:53:55 <EvilTerran> you could make a generalised monstrosity with newtype Flip f a b = Flip { unFlip :: f b a } or something
06:54:06 <byorgey> eek
06:54:30 <takamu> hello
06:54:41 <byorgey> hey takamu
06:54:48 <shepheb> with the power to create great beauty comes to power to create evil as well, apparently.
06:55:05 <shepheb> comes the power, even.
06:55:05 <EvilTerran> but then again, (a,b) is isomorphic to (b,a) anyway, so you might as well just use the right one in the first place if you want the functor instance
06:55:07 <byorgey> indeed.
06:56:03 <shepheb> ?instances Monad
06:56:03 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
06:58:15 <shepheb> my local WebSense regime blocks Luke Palmer's blog under "Phishing and other frauds"... sigh.
07:10:50 <fxr> MarcWeber: http://hpaste.org/6911
07:21:10 <phlpp> @go 10 USD in EUR
07:21:11 <lambdabot> 10 U.S. dollars = 6.36983247 Euros
07:21:16 <MarcWeber> fxr: Thanks I'll look at it
07:24:40 <EvilTerran> > map (*255`div`15) [0..]
07:24:41 <lambdabot>      The operator `*' [infixl 7] of a section
07:24:41 <lambdabot>         must have lower precede...
07:24:49 <EvilTerran> > map (*(255`div`15)) [0..]
07:24:50 <lambdabot>  [0,17,34,51,68,85,102,119,136,153,170,187,204,221,238,255,272,289,306,323,34...
07:25:29 <EvilTerran> ?botsnice
07:25:29 <lambdabot> :)
07:27:07 <cruxxx> How to change header of HTTP-request for getXmlDocuments [..] URL ?
07:37:52 <byorgey> > let f 0=0; f 1=1; f 2=3; f _ =2; p 0=1; p n = sum [ f k * p (n-k) | k <- [1..n] ] in map (sqrt . p) [1..12]
07:37:53 <lambdabot>  [1.0,2.0,3.0,5.0,8.0,13.0,21.0,34.0,55.0,89.0,144.0,233.0]
07:38:37 <shepheb> what twisted imagination spawned that
07:38:54 <byorgey> hehe, a problem I saw the other day
07:39:29 <byorgey> which ended up (after some manipulations) to involve a recurrence that yielded squares of fibonacci numbers.
07:39:51 <Deewiant> > let f 0=0; f 1=1; f 2=3; f _ =2; p 0=1; p n = sum [ f k * p (n-k) | k <- [1..n] ] in (sqrt . p) 25
07:39:57 <lambdabot> Terminated
07:40:12 <byorgey> it's... not a very efficient way to compute fibonacci numbers =)
07:40:24 <Deewiant> no. :-P
07:41:10 <byorgey> it was just a neat problem.  perhaps I'll blog about it...
07:56:43 <vincenz> holy moly
07:56:47 <vincenz> nearly 1.6 for a euro
07:57:08 * byorgey sighs
07:57:09 <Beelsebob> haha, serves you right for having a crap currancy :P
07:57:35 <ejt> @go 10 USD in GBP
07:57:35 <lambdabot> 10 U.S. dollars = 5.00801282 British pounds
07:57:49 <wli> What's the estimated half-life of a US dollar these days?
07:57:56 <byorgey> good thing I'm not planning a trip to Europe any time soon...
07:58:29 <byorgey> wli: you mean of a physical dollar bill?  how long it is in circulation?
07:58:54 <Twey> Heheheh
07:58:56 <wli> No, how long it takes a US dollar to halve in value vs. the EUR.
07:58:57 <shepheb> @go 1 USD in CAD
07:58:57 <lambdabot> 1 U.S. dollar = 1.00630045 Canadian dollars
07:59:00 <Beelsebob> byorgey: no, he means how long will it take for a dollar to be worth half what it was before
07:59:07 <byorgey> oh, duh, I see =)
07:59:38 * boegel is visiting the US from Europe and doesn't mine the current rates at all
07:59:39 <tromp> you mean how long till a bigMac doubles in price?
07:59:43 <boegel> everything is cheap here!
08:00:24 <tromp> alexandra dupre isnt cheap:(
08:00:43 <boegel> tromp: I'm not talking about hookers
08:01:33 <Twey> @go 1 GBP in RUB
08:01:33 <lambdabot> 1 British pound = 47.0765749 Russian rubles
08:01:42 <Twey> Mn
08:03:30 <byorgey> apparently physical $1 bills have a life expectancy of about 18 months, in case anyone is interested in the answer to the question wli wasn't asking =)
08:04:58 <boegel> byorgey: not the ones in my wallet
08:08:42 <byorgey> boegel: no? you're taking them back and framing them, eh? =)
08:09:45 <boegel> byorgey: no, I mean they don't even reach 18 months :)
08:10:15 <byorgey> why not? I'm confused
08:11:17 <dolio> He uses them as napkins, and as a cloth to wash his dishes.
08:11:19 <boegel> byorgey: because they suffer too much :p
08:11:28 <boegel> dolio: more like toilet paper :p
08:11:31 <byorgey> ah, hehe =)
08:11:43 <boegel> wipe your ass with dollar bills y'all
08:11:56 * atsampson wonders idly how long it'll take for it to cost more than $1 to make a dollar bill
08:12:11 <byorgey> I wouldn't wash any dishes with them, apparently most bills have traces of cocaine...
08:12:43 <dolio> http://au.youtube.com/watch?v=YT7UyPuwlbI
08:12:44 <lambdabot> Title: YouTube - Ass Pennies For Confidence
08:47:22 <vincenz> dolio: hehe :D
08:57:03 <IsoPallo> Wow. I finally managed to get a working installation of GHC...
08:57:28 <IsoPallo> And all the stuff I wrote without testing worked witout modification.
08:57:41 <IsoPallo> I must say that Haskell does seem nice..
08:58:09 <roconnor> such is the magic of static type checking
08:58:12 <roconnor> :)
09:03:28 <Jedai> IsoPallo: Still, don't believe that testing is unnecessary, you just have much less things to test (and good tools to test the rest, like Quicktest)
09:06:10 <Jedai> roconnor: I think that static typing is a part of it, but there's also the functional style, I'm pretty sure it encourage a style less subject to trivial mistakes (there's obvious benefits like the absence of explicit loops, but also the tendance to cut a task in small units, evidently correct)
09:10:39 <IsoPallo> Jedai: In this case testing was impossible, since I couldn't get a working compiler installed. So I just played around writing stuff as a mindgame. Then when I actually got the compiler I just for fun compiled the things they worked. It was quite unexpected actually.
09:11:26 <sebell> Ooh JFF compilation
09:11:52 <Jedai> IsoPallo: Yes, it's a nice feeling right !? The clean syntax and the functional paradigm contributes to this effect I think
09:12:31 <roconnor> I wonder if developers would make fewer software errors if they didn't have compilers, like in the good old days
09:13:24 * Twey grins.
09:13:46 <Twey> 'Somewhere, in this 5MB of binary, is a bug.  Can *you* spot it?'
09:14:12 <sebell> How many punch cards is 5MB?
09:14:21 <gbacon> two or three
09:14:23 <shepheb> > 80 * 24
09:14:24 <lambdabot>  1920
09:14:59 <IsoPallo> In the good old days you just took a pair of pincers threw away the fried bug and tried re-running...
09:15:27 <vincenz> In the good old days you pressed the button in synch with the cpu-clock to punch in 1 or 0
09:15:37 <vincenz> skip a clocktick -> 0
09:15:46 <roconnor> @go 5MB / 80 bytes
09:15:46 <lambdabot> (5 megabytes) / (80 bytes) = 65,536
09:16:01 <dons> cool, monad reader!, http://reddit.com/info/6f131/comments/
09:16:10 <roconnor> sebell: 65,536
09:16:17 <atsampson> roconnor: yes, but only because they'd make less software
09:17:21 <roconnor> ah, the trade off between correct software, cheap software, and pleantiful software.
09:17:38 <atsampson> "pick zero"
09:18:04 <yitz_> sebell: what's the best algorithm for sorting 1920 punched cards after you drop the box, assuming that you remembered to number them?
09:18:18 <shepheb> yitz_: interns.
09:18:22 <opqdonut> mergesort
09:18:45 <opqdonut> with fallback to insertion for small sizes
09:18:49 <shepheb> map a mergesort over multiple cores^H^H^H^H^H students
09:18:51 <laura85> hi ^^
09:19:37 <yitz_> the problem becomes more interesting if you *didn't* remember to number them, which by Murphy's law was usually the case.
09:20:16 * shepheb wonders how many programmers experienced a Zen moment when, picking up the card stack to number them before they dropped them, dropped them.
09:22:06 <yitz_> shepheb: you numbered them one by one as they came out of the keypunch machine. unless you had a deadline, in which case you didn't, and then dropped them.
09:22:25 * shepheb shows his youth.
09:22:33 <roconnor> yitz_: I'd radix sort them if they were numbered
09:26:05 <yitz_> roconnor: that what they did, i think.
09:26:24 <jaj> Hi!
09:26:35 <vincenz> shepheb: then what?
09:27:21 <jaj> Is there anybody here who is familiar with hstringtemplate? I'd like to ask whether it is possible to have loops in a template
09:27:42 <jaj> a repeating pattern which can be filled with rows from a database
09:28:25 <fanw> hi vincenz, thanks for the help last night  about the MonadReader
09:29:05 <vincenz> fanw: hmm?
09:29:57 <fanw> my question now is if i compile    tail2 = (subtract 2 . length) >>= drop
09:30:09 <fanw> i got No instance for (Monad ((->) [a]))
09:30:24 <vincenz> Oh, you're mib_..
09:30:36 <byorgey> woohoo, Monad.Reader!
09:30:39 <byorgey> swiert++
09:30:42 <vincenz> Welcome :)
09:30:53 <fanw> what is mib_?
09:32:57 <EvilTerran> fanw, import Control.Monad.Reader
09:33:02 <EvilTerran> or Control.Monad.Instances
09:33:11 <fanw> if i add the line "import Control.Monad.Instances" then it compiles
09:33:12 <fanw> yes
09:33:43 <fanw> the question is how is "->" related with the bind >>=?
09:34:37 <EvilTerran> ?src (->) (>>=)
09:34:37 <lambdabot> f >>= k = \ r -> k (f r) r
09:34:53 <EvilTerran> ... doesn't really help
09:35:43 <sethk> fanw, the <- is really a shorthand
09:35:50 <EvilTerran> tail2 = do l <- subtract 2 . length; drop l
09:36:15 <sethk> fanw, with >>= and >>, you can sequence using standard haskell syntax
09:36:52 <EvilTerran> sethk, i think fanw's asking about ->, not <-
09:37:09 <fanw> right
09:37:12 <EvilTerran> ... in the reader (e ->) monad, each action gets the environment as an extra parameter, of whatever type "e" is
09:37:17 <EvilTerran> in this case, e = [a]
09:37:33 <EvilTerran> and the environment appears as a parameter to the overall action
09:37:54 <fsk141_> minifsk.com
09:38:25 <EvilTerran> ?where ops
09:38:25 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
09:38:27 <fanw> i got that part. what confused me is i see '->' used in many places, how do i know that is a monad?
09:38:40 --- mode: ChanServ set +o allbery_b
09:38:47 <EvilTerran> by looking in the module where it's declared
09:39:00 --- mode: allbery_b set +b *!*n=fsk141@*.dsl.lsan03.sbcglobal.net
09:39:00 --- kick: fsk141_ was kicked by allbery_b (allbery_b)
09:39:11 <EvilTerran> there's nothing magic about it being a monad - you could define the instance yourself
09:39:20 <EvilTerran> allbery_b++
09:39:20 --- mode: allbery_b set -o allbery_b
09:40:36 <EvilTerran> instance Monad ((->) e) where { return = const; (m >>= f) e = f (m e) e }
09:40:58 <roconnor> @src fromMaybe
09:40:58 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
09:41:02 <EvilTerran> so you know it's a monad the same way ghc does - because the source code of a module you're importing says it is
09:41:09 <shepheb> vincenz: then what what?
09:41:17 <vincenz> shepheb: if you drop the cards before numbering them.
09:42:23 <shepheb> vincenz: oh, I'm just imagining it as a kind of sublime catch-22. in trying to ensure that dropping the cards would not be a disaster, you dropped the cards. and if you had not intended to number them, they might never have been dropped.
09:43:00 <fanw> thanks EvilTerran, could you please show me where is '->' used  in the example of (subtract2.length>>=drop)?
09:43:25 <vincenz> shepheb: dropping the cards is a poisson-distribution, at some point they will be dropped..
09:44:17 <shepheb> vincenz: what boggles my mind is that no one added a little card-printer postprocessor to number the buggers.
09:44:38 <vincenz> "Noone will ever need more than 64 cards!"
09:45:02 <EvilTerran> it's the same as (\env -> subtract 2 (length env)) >>= (\n env -> drop n env)
09:45:23 <vincenz> EvilTerran++
09:45:29 <EvilTerran> but with a bit of equational reasoning to pointfree it and beta-reduce the ->s out of existance
09:45:46 <EvilTerran> vincenz, er... thanks :)
09:46:04 <fanw> i guess this is what i am looking for
09:46:14 <fanw> EvilTerran++
09:46:21 <fanw> vincenz++
09:46:47 <fanw>  ++ means points right? :)
09:47:15 <Deewiant> @karma EvilTerran
09:47:15 <lambdabot> EvilTerran has a karma of 9
09:47:21 <byorgey> yup
09:47:33 <EvilTerran> if you prefer, the ((->) e) (where e = [a]) is in "subtract 2 . length :: ((->) [a]) Int" and "drop :: Int -> ((->) [a]) [a]
09:47:54 <byorgey> if someone is helpful, you can express your appreciation by using ++ to give them karma points.
09:47:57 <EvilTerran> *that*'s the very -> that appears in ((->) e) -- the type-level one, not the lambda syntax
09:47:59 <byorgey> alternatively, you can send them cookies.
09:48:58 <EvilTerran> ... if that makes it any clearer?
09:49:32 <EvilTerran> ((->) x) y = (->) x y = x -> y, if that's confusing
09:49:33 <fanw>  i see, much better! But i need to chew it a bit. Thanks a lot EvilTerran!
09:49:37 <EvilTerran> :)
09:51:50 <vincenz> > repeat "lambda-cookies"
09:51:50 <lambdabot>  ["lambda-cookies","lambda-cookies","lambda-cookies","lambda-cookies","lambda...
09:51:54 <vincenz> Please take 1
09:52:03 <byorgey> yum!
09:52:18 <byorgey> > take 1 $ repeat "lambda-cookies"
09:52:18 <lambdabot>  ["lambda-cookies"]
09:52:34 <byorgey> > replicate 5 "munch"
09:52:35 <lambdabot>  ["munch","munch","munch","munch","munch"]
09:52:49 <vincenz> :
09:52:50 <vincenz> :D
09:53:20 <Botje> > tail . words . repeat $ "NOM"
09:53:21 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
09:53:28 <Botje> > tail . words $ repeat "NOM"
09:53:29 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
09:53:35 <Botje> > tail . unwords $ repeat "NOM"
09:53:36 <lambdabot>  "OM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM ...
09:53:36 <Botje> bah.
09:53:37 <vincenz> that's' exactly the same
09:53:37 <EvilTerran> > eat "lambda-cookie"
09:53:38 <lambdabot>  OM NOM NOM
09:53:51 <byorgey> hehe
09:53:53 <Deewiant> @ty eat
09:53:53 <lambdabot> forall a. [Char] -> Sym a
09:54:04 <lambdabot> Stop messing with me!
09:54:08 <Deewiant> @index eat
09:54:08 <lambdabot> bzzt
09:54:17 <Deewiant> lies
09:54:19 <vincenz> @src eat
09:54:19 <lambdabot> Source not found. Just what do you think you're doing Dave?
09:54:24 <resiak> hmm, could an infinite chain of NOMs be made with 'forever' somehow
09:54:34 <Botje> will \bot grow fat if we stuff her with enough lambda-cookies? :)
09:54:40 <EvilTerran> > eat "Deewiant"
09:54:41 <lambdabot>  That's not a lambda-cookie!
09:54:56 <vincenz> Haha, whoever did that :D
09:55:04 <vincenz> > var "This is more text"
09:55:05 <lambdabot>  This is more text
09:55:22 <EvilTerran> > var . ((++) <*> show) $ "> var . ((++) <*> show) $ "
09:55:23 <lambdabot>  > var . ((++) <*> show) $ "> var . ((++) <*> show) $ "
09:55:31 <Deewiant> resiak: with State or Writer, probably. forever returns m () so not directly, I don't think.
09:55:37 <vincenz> Using Exp, something meant for a completely different purpose to make lambdabot talk from haskell code
09:55:58 <vincenz> EvilTerran: did you just devise that on the spot?
09:56:32 <vincenz>  @eval var . ((++) <*> show) $ "@eval var . ((++) <*> show) $ "
09:57:42 <EvilTerran> nah, i thought it up a while ago. it's in my bag-o-tricks.hs
09:57:49 <EvilTerran> next to
09:57:49 <EvilTerran> main = putStr s >> print s where s = "main = putStr s >> print s where s = "
09:59:13 <roconnor> > runWriter do forever (tell "OM N")
09:59:13 <lambdabot>  Parse error at "do" (column 11)
09:59:21 <roconnor> > runWriter (forever (tell "OM N"))
09:59:25 <lambdabot>  Terminated
09:59:31 <resiak> Is writer strict? :(
09:59:42 <roconnor> @hoogle Writer
09:59:42 <lambdabot> Control.Monad.Writer :: module
09:59:42 <lambdabot> Control.Monad.Writer.Lazy.Writer :: newtype Writer w a
09:59:42 <lambdabot> Control.Monad.Writer.Lazy.Writer :: (a, w) -> Writer w a
10:00:02 <roconnor> @docs Control.Monad.Writer
10:00:02 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/3/Control-Monad-Writer.html
10:00:12 <roconnor> resiak: nah, it's just trying to print the result too
10:00:30 <resiak> @ty runWriter
10:00:31 <lambdabot> forall w a. Writer w a -> (a, w)
10:00:47 <Saizan> > execWriter (forever (tell "OM N"))
10:00:48 <lambdabot>  "OM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM ...
10:01:00 <roconnor> that's what I was looking for
10:01:12 <resiak> hooray!
10:01:36 <resiak> Hmm, (fst . runWriter) doesn't do what I'd expect
10:01:37 <roconnor> > swap (runWriter (forever (tell "OM N")))
10:01:37 <lambdabot>   Not in scope: `swap'
10:01:38 <Baughn> Num-nums?
10:01:41 <dolio> Heh.
10:01:49 <roconnor> > fst (runWriter (forever (tell "OM N")))
10:01:49 <resiak> @src runWriter
10:01:49 <lambdabot> Source not found.
10:01:55 <lambdabot> Terminated
10:02:06 <EvilTerran> > snd (runWriter (forever (tell "OM N")))
10:02:07 <roconnor> > snd (runWriter (forever (tell "OM N")))
10:02:08 <lambdabot>  "OM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM ...
10:02:08 <lambdabot>  "OM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM ...
10:02:13 <Deewiant> > cycle "UM N"
10:02:13 <lambdabot>  "UM NUM NUM NUM NUM NUM NUM NUM NUM NUM NUM NUM NUM NUM NUM NUM NUM NUM NUM ...
10:02:14 <resiak> ah.
10:02:17 <EvilTerran> > (snd &&& fst) (runWriter (forever (tell "OM N")))
10:02:18 <lambdabot>  ("OM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM...
10:02:30 <roconnor> > let swap (x,y) = (y,x) in swap (runWriter (forever (tell "OM N")))
10:02:31 <lambdabot>  ("OM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM...
10:02:42 * Igloo coughs
10:02:48 <roconnor> @pl swap (x,y) = (y,x)
10:02:48 <lambdabot> swap = uncurry (flip (,))
10:02:53 <roconnor> hm
10:03:02 <roconnor> I like snd &&& fst better
10:03:06 * EvilTerran prefers his, although it does require Control.Arrow
10:03:15 <resiak> Igloo: sorry :)
10:03:30 <dolio> Saizan: Did you see my sexy inductive tuples in Agda?
10:03:37 <Deewiant> Control.Arrow should be in the prelude for the (->) Arrow.
10:03:38 <byorgey> coming down with something, Igloo?
10:03:44 <EvilTerran> i'd put swap in Data.Tuple, meself
10:04:07 <byorgey> I thought there was a library proposal to do exactly that, not too long ago?
10:04:17 <EvilTerran> maybe it's for 6.8.10
10:04:17 <dolio> @type uncurry (flip $ curry id)
10:04:17 <Deewiant> that'd be nice too, but I miss stuff like first, second, (>>>), (***)
10:04:17 <lambdabot> forall a b. (b, a) -> (a, b)
10:04:23 <Deewiant> EvilTerran: it is, IIRC
10:04:25 <Deewiant> byorgey:
10:04:38 <Saizan> dolio: no! link?
10:04:44 <dolio> http://hpaste.org/6907
10:05:07 <elliottt> sclv: hey, i've got a question about anonymous templates when you've got a chance :)
10:05:15 <EvilTerran> well, i'd put an arrowy version in Control.Arrow, too, especially seeing as the arrow de-sugaring seems to use it heavily (according to the paper, at least)
10:05:20 <roconnor> EvilTerran: is snd &&& fst compiled to effiecent code?
10:05:54 <EvilTerran> probably, seeing as the arrow type will usually be known to be (->) at compile-time
10:06:08 <skorpan> @pl \(c, s) -> ((M.insert i t (head c)):(tail c), s)
10:06:08 <lambdabot> first (ap ((:) . M.insert i t . head) tail)
10:06:11 <EvilTerran> there might be {-# SPECIALIZE #-} pragmas in for the (->) instance of Arrow
10:06:20 <roconnor> EvilTerran: I'm concerend that the pair is patterned matched twice, once with fst and once with snd.
10:06:31 <EvilTerran> ah, yes... that's entirely possible
10:06:40 <roconnor> that's sucky
10:06:44 <EvilTerran> probably won't make that much difference, though
10:06:49 <EvilTerran> skorpan, egad
10:06:54 <roconnor> :/
10:06:56 <Saizan> dolio: btw, do you have a link handy where i can find documentation about Set1 and forall?  i couldn't find them on the wiki
10:07:12 <roconnor> people go on and on about how type information is wonder for the compiler.
10:07:17 <swiert> dolio: do you really want Set1?
10:07:19 <roconnor> but our compilers really suck
10:07:42 <EvilTerran> roconnor, that's not really type information... more some variant on CSE, i think
10:07:51 <dolio> Saizan: Not off hand. Set1 is the level above Set. Set : Set1, Set1 : Set2, Set2 : Set3 ...
10:07:52 <EvilTerran> well, a mixture
10:08:02 <dolio> swiert: No, but I can't avoid it, as far as I know.
10:08:09 <roconnor> right, and we know how much CSE is used.
10:08:22 <EvilTerran> not very much at all?
10:08:28 <roconnor> correct
10:08:34 <EvilTerran> ?type \(c, s) -> ((M.insert i t (head c)):(tail c), s)
10:08:35 <lambdabot> forall t. ([M.Map Expr Expr], t) -> ([M.Map Expr Expr], t)
10:08:41 <swiert> dolio: you could define a universe, if you don't mind losing a bit of generality
10:08:43 <EvilTerran> heh
10:08:49 <dolio> Saizan: forall is short hand for when the compiler can figure out the sort of everything, you don't have to state it explicitly.
10:08:53 <EvilTerran> ?type \(c, s) -> ((M.insert ?i ?t (head c)):(tail c), s)
10:08:54 <lambdabot> forall t k a. (Ord k, ?t::a, ?i::k) => ([M.Map k a], t) -> ([M.Map k a], t)
10:08:59 <roconnor> so our code still looks like totally crap to be effiecent.
10:10:10 <EvilTerran> ?type first ((:) <$> M.insert ?i ?t . head <*> tail)
10:10:11 <lambdabot> forall k a d. (Ord k, ?t::a, ?i::k) => ([M.Map k a], d) -> ([M.Map k a], d)
10:10:17 <dolio> Saizan: So, if you have 'forall {a n} -> Vector a n', the type of Vector requires 'a : Set' and 'n : Nat', so it can figure that out without your saying so, and you save a bit of typing.
10:10:30 <EvilTerran> skorpan, that's how i'd pointfree that code
10:11:13 <EvilTerran> skorpan, or the equivalent with liftA2 or liftM2
10:11:14 <skorpan> right :)
10:11:33 <dolio> swiert: I'd appreciate an example, if you have one handy.
10:11:40 <Saizan> dolio: i see
10:12:08 <swiert> dolio: See Section 3-4 of: http://www.cs.nott.ac.uk/~wss/Publications/ThePowerOfPi.pdf
10:12:25 <swiert> dolio: It's even written in Agda :)
10:13:15 <swiert> dolio: Especially, the data type U at the beginning of Section 3.
10:13:22 <dolio> swiert: Thanks. I'll take a look.
10:13:36 <Saizan> swiert: is there a problem in using Set1? too much type information at runtime?
10:14:14 <swiert> Saizan: There's not even a real Agda compiler - so I wouldn't worry too much about type info at runtime.
10:14:55 <swiert> Saizan: But it pays off to be careful about how "big" your types get.
10:15:12 <swiert> Saizan: Keeping your programs in Set is usually a good idea.
10:17:13 <sphynx> is this a correct way to apply function N times: let applyNTimes n f x = foldr ($) x (replicate n f)
10:17:53 <roconnor> sphynx: that's how I've done it
10:18:01 <lament> (iterate f x( !! n
10:18:02 <lament> err
10:18:07 <lament> (iterate f x) !! n
10:18:46 <roconnor> > foldr ($) x (replicate n f)
10:18:46 <lambdabot>  Couldn't match expected type `Int' against inferred type `Expr'
10:18:54 <roconnor> > foldr ($) x (replicate 5 f)
10:18:54 <lambdabot>  f (f (f (f (f x))))
10:19:06 <dolio> swiert: Oh, I have seen that sort of thing before. However, only being able to have tuples of things on a fixed list is a bit disappointing.
10:19:07 <Deewiant> > iterate f x !! 5
10:19:07 <lambdabot>  f (f (f (f (f x))))
10:19:23 <lament> right, don't need the braces even
10:19:34 <glen_quagmire> > let { a f 0 x = f x; a f n x = a f (n-1) (f x); } in a (+1) 2 40
10:19:35 <lambdabot>  43
10:19:43 <swiert> dolio: it's not perfect - but for a lot of domains it's good enough.
10:20:00 <sphynx> well, thanks!
10:20:21 <glen_quagmire> > let { a f 0 x = f x; a f n x = a f (n-1) (f x); } in a f 5 x
10:20:22 <lambdabot>  f (f (f (f (f (f x)))))
10:20:24 <swiert> dolio: one example in the paper is about connecting to a database server - most of these servers have a very small set of supported types.
10:20:29 <sphynx> So both variants are good :) Lament's way is more precise than mine I think.
10:20:59 <roconnor> sphynx: I think your way is better than Lament's
10:21:02 <nominolo_> swiert: i have a question regarding your "observational equality now" paper
10:21:07 <byorgey> roconnor: why?
10:21:08 <roconnor> @type replicate
10:21:09 <lambdabot> forall a. Int -> a -> [a]
10:21:18 <dolio> swiert: Yeah. The place I saw it was in a typed interpreter, where the universe represented the types in the interpreted language.
10:21:23 <opqdonut> what's the minimum we need for nonterminating typechecking?
10:21:24 <nominolo_> swiert: what does the notation { s || Q : S=T } mean?
10:21:29 <lament> roconnor: why?
10:21:32 <swiert> dolio: besides, universes can describe a *lot* of types.
10:21:33 <opqdonut> fundeps+undecideableinstances+flexibleinstances
10:21:35 <roconnor> !! scares me
10:21:40 <byorgey> bah
10:21:43 <opqdonut> ?
10:21:48 <lament> roconnor: this is exactly a good usage of !!, though
10:21:49 <byorgey> not a good reason =)
10:21:57 <swiert> dolio: as they can be closed under type formers, like Plus, Times, Mu, etc.
10:22:00 <lament> roconnor: since you actually need all the elements before and including the one you're interested in
10:22:06 <opqdonut> also: how do GADTs and type families relate?
10:22:09 <opqdonut> or do they?
10:22:10 <glen_quagmire> maybe haskell type checking always terminates
10:22:20 <swiert> nominolo_: do you have a page number?
10:22:21 <opqdonut> glen_quagmire: w/o extensions it does
10:22:28 <EvilTerran> opqdonut, i think UndecidableInstances is enough
10:22:33 <dons> opqdonut: there's a paper on the relationship :)
10:22:36 <EvilTerran> it may imply FlexibleInstances, i forget
10:22:38 <opqdonut> dons: link?
10:22:45 <nominolo_> swiert: page 3, last judgent on the left
10:22:46 <opqdonut> EvilTerran: yeah flexble seems pretty much needed
10:22:55 <EvilTerran> instance Foo a => Foo a -- doesn't terminate or need flexible instances
10:22:58 <nominolo_> swiert: it could be just set comprehension
10:23:17 <nominolo_> swiert: but then I have to think harder to understand what that means
10:23:23 <nominolo_> :)
10:23:40 <swiert> nominolo_: no. It's Conor's notation for coherence.
10:23:42 <roconnor> > (iterate (const 5) f)!!1000000
10:23:43 <lambdabot>  Add a type signature
10:23:51 <roconnor> > (iterate (const 5) ())!!1000000
10:23:51 <lambdabot>   add an instance declaration for (Num ())
10:23:59 <roconnor> > (iterate (const 5) 0)!!1000000
10:24:00 <lambdabot>  5
10:24:05 <roconnor> > (iterate (const 5) 0)!!100000000
10:24:09 <lambdabot> Terminated
10:24:16 <swiert> nominolo_: That is to say, if you coerce a value between to provably equal types, coherence tells you that the original value is necessarily equal to the coerced result.
10:24:29 <lament> roconnor: foldr isn't any more efficient in that case
10:24:36 <roconnor> > (foldr ($) 0 (replicate 100000000 (const 5)))
10:24:36 <lambdabot>  5
10:24:40 <lament> oh, it is
10:24:42 <roconnor> ta da
10:24:49 <nominolo_> swiert: ok
10:24:51 <nominolo_> thanks
10:24:53 <byorgey> roconnor: ah, excellent point!  I concede
10:25:01 <roconnor> that's why I like sphynx's version
10:25:06 <swiert> nominolo_: no problem. It's a pretty hard-core paper...
10:25:23 <dons> opqdonut: the System Fc paper, http://www.cse.unsw.edu.au/~chak/papers/SCPD07.html perhaps?
10:25:24 <lament> roconnor: 1) premature optimization 2) it's unlikely that the function will be constant
10:25:24 <lambdabot> Title: Research Papers of Manuel Chakravarty
10:25:34 <swiert> nominolo_: but the idea's actually nice and simple.
10:25:55 <dolio> swiert: Incidentally, are you the one who fixed my inductive indexing blunder?
10:25:55 <roconnor> lament: I use const it indicate a lazy function that may bail out early.  This is not uncommon.
10:26:08 <swiert> dolio: on agda@ - yes.
10:26:16 <dolio> Ah, thanks again.
10:26:22 <roconnor> lament: I also don't find it a premature optimisation.  I'd find folding here very natural.
10:26:24 <swiert> dolio: No worries.
10:26:31 <roconnor> lament: for people who are into folds.
10:26:36 <swiert> dolio: Agda's pretty cool, but there's a serious lack of documentation.
10:26:56 <nominolo_> swiert: is epigram better? ;)
10:26:57 * lament would make a pun about folds but it would be way too dirty
10:26:59 <dolio> Yeah. Although, embarassingly enough, that was documented. :)
10:27:04 <dons> map.toUpper.org -- has anyone thought of using pointfree form for cute domain names?
10:27:15 <dons> cute and executable. :)
10:27:29 <lament> ORG
10:27:45 <dons> :)
10:27:56 <monstre> hello
10:28:05 <opqdonut> dons: okay, thanks
10:28:31 <swiert> nominolo_: no! Agda's one of the most usable systems out there at the moment.
10:29:00 <dolio> Epigram isn't actually done. At least, not Epigram 2.
10:29:02 <monstre> Newbie question: is there a way to get random numbers outside of the IO monad?
10:29:05 <glen_quagmire> @pl fix
10:29:05 <lambdabot> fix
10:29:28 <kpreid> monstre: sure, you just have to supply a seed yourself
10:29:29 <xerox> monstre: you might flip a coin and put the outcome in your source :-)
10:29:30 <swiert> dolio: unfortunately not. Although my officemates assure me they'll have a core theory running "real soon now".
10:29:45 <lament> monstre: remember that a pure function always returns the same value when given the same arguments
10:29:52 <dolio> Heh. Well, I look forward to it. :)
10:29:56 <Peaker> monstre, I don't know much about it but I would guess "real randomness" depends on IO things like /dev/urandom and such (though maybe unsafePerformIO is legitimate to use in such a case)
10:29:58 <jadrian> monstre: you cannot get anything out of the IO monad
10:30:11 <glen_quagmire> > fix id x
10:30:11 <jadrian> monstre: that is the best way to think about it
10:30:12 <lambdabot>  Exception: <<loop>>
10:30:19 <kpreid> Peaker: no, it is not, because doing so breaks referential transparency
10:30:33 <Peaker> kpreid, yeah, I was just about to take it back :)
10:30:53 <Peaker> (loses all the advantages of non-monadic code)
10:30:54 <monstre> So there's no way to write a coinFlip function without using unsafePerformIO?
10:31:07 <EvilTerran> giving it an IO return type
10:31:09 <kpreid> monstre: it just needs to have a seed or a RandomGen as an argument.
10:31:16 <Peaker> monstre, you can create a pseudo-random sequence
10:31:26 <kpreid> @type random
10:31:27 <lambdabot> forall g a. (RandomGen g, Random a) => g -> (a, g)
10:31:28 <kpreid> @type randoms
10:31:29 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
10:31:34 <dolio> Although Agda seems to have also outdone Epigram for ease of writing, too, unless things have changed a lot since I last used Epigram.
10:31:34 <kpreid> no IO there!
10:31:44 <EvilTerran> another possibility would be making an stream of results in IO, then passing the extracted stream into some pure code as a parameter
10:31:44 <dolio> Maybe I'm just biased against big case trees, though.
10:31:48 <monstre> what if I need a random seed?
10:32:00 <kpreid> monstre: pass it in.
10:32:11 <kpreid> @type newStdGen
10:32:12 <lambdabot> IO StdGen
10:32:12 <EvilTerran> get it from IO, *then* pass it in
10:32:16 <kpreid> @type mkStdGen
10:32:17 <lambdabot> Int -> StdGen
10:32:32 <EvilTerran> do gen <- newStdGen; print $ somePureFuntion gen
10:32:44 <kpreid> what EvilTerran said.
10:32:53 <enticingjelly> I often use the following pattern: map (uncurry foo) (zip aList anotherList)
10:32:59 <enticingjelly> is there a better way?
10:33:23 <paczesiowa> zipWith foo?
10:33:32 <enticingjelly> zipWith
10:33:44 <enticingjelly> exactly what I need. thanks.
10:33:55 <monstre> what I need is a function coinFlip :: Bool, to be used inside a pure function. Any way to accomodate this besides unsafePerormIO?
10:34:15 <monstre> and yes, the function really is pure
10:34:22 <Deewiant> of course it's not pure if it returns a different value every time
10:34:23 <paczesiowa> monstre: do you understand monads?
10:34:30 <monstre> not quite
10:34:32 <kpreid> monstre: that is self-contradictory
10:34:34 <jadrian> monstre: if it depends on a coinflip which is not pure then it is not pure
10:34:37 <allbery_b> pass a RandomGen?
10:35:08 <vincenz> No, people
10:35:12 <vincenz> monstre is right
10:35:23 <vincenz> monstre: If the function is pure, the function you want for randomCoinFlip is
10:35:25 <monstre> if the randomness only impacts the complexity and not the result, is the function not pure?
10:35:30 <Deewiant> coinFlip = False
10:35:34 <vincenz> randomCoinFlip = True -- done by a real coin
10:35:39 <allbery_b> heh'
10:35:47 <monstre> very funny
10:35:53 <paczesiowa> monstre: learn monads (you'll have to sooner or later). try this: http://en.wikibooks.org/wiki/Programming:Haskell_monads#Random_Number_Generation
10:35:55 <lambdabot> http://tinyurl.com/2annd2
10:36:11 <vincenz> monstre: somewhere inside, the code will be impure
10:36:41 <monstre> but if it's not visible from the outside, does it matter?
10:36:58 <vincenz> monstre: it's impure inside, tht will screw the compiler
10:36:59 <kpreid> monstre: then use a fixed seed!
10:37:16 <vincenz> monstre: why do you need randomness?
10:37:35 <kpreid> monstre: mkStdGen with some arbitrary constant input, then use that gen throughout the operation
10:37:50 <monstre> I guess that could work
10:38:06 <vincenz> monstre: why do you need randomness?
10:41:00 <atsampson> I've actually seen an instance of the "done by a real coin" approach -- a lighting controller with a small random sequence in EPROM generated by picking numbers from a hat...
10:41:52 <monstre> vincenz: say I want to delete an internal node from a binary search tree, I can either replace it with the right-most node from its left child or the left-most from the right. What I'd like to able to do is choose one of those two methods at random each time to minize the chance of getting an unbalanced tree
10:42:37 <monstre> which is where coinFlip comes in
10:42:55 <paczesiowa> so it is not pure, you can get different trees
10:42:56 * roconnor would use MonadRandom
10:43:32 <kpreid> paczesiowa: it would be pure if the difference between trees is externally unobservable
10:43:34 <Deewiant> @hoogle MonadRandom
10:43:34 <lambdabot> No matches found
10:43:47 <kpreid> @where MonadRandom
10:43:47 <lambdabot> I know nothing about monadrandom.
10:43:49 <monstre> yes, I suppose you could observe the trees in order to reconstruct the random bits
10:43:49 <roconnor> @go MonadRandom
10:43:51 <lambdabot> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
10:43:51 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
10:44:00 <monstre> but let's say I'm not actually going to do that
10:44:51 <monstre> would it be okay to use unsafePerformIO in this particular case?
10:45:04 <jadrian> monstre: no
10:45:10 <vincenz> You should never use unsafePerformIO
10:45:12 <vincenz> Once you know this mantra
10:45:17 <vincenz> And you still need it
10:45:20 <jadrian> monstre: if it were ok in that case it would be ok in all
10:45:30 <jadrian> monstre: there is nothing particular about that case
10:45:33 <vincenz> You will learn that unsafePerformIO is evil
10:45:37 <jadrian> monstre: at all!
10:45:46 <jadrian> monstre: you just need to learn monads
10:45:51 <vincenz> After that stage, you will study GHC in depths on the high mountains of Glassgow
10:46:03 <vincenz> And only then will you be ready for unsafePerformIO
10:46:19 <vincenz> monstre: hope that answers ;)
10:46:40 <monstre> the point of this example is that the non-determinism will never be observed, so why should it matter?
10:47:05 <roconnor> unsafePerformIO is fairly safe when the function returns the same answer in all contexts
10:47:05 <vincenz> monstre: cause it might screw the compiler
10:47:16 <vincenz> monstre: let's say you do two things based on that boolean
10:47:23 <vincenz> monstre: and now the compiler inliens them, cause it says "hey, it's pure"
10:47:29 <vincenz> suddenly your rtree is borked
10:48:00 <monstre> well, if the compiler can defeat the use of unsafePerformIO, why does it exist at all?
10:48:23 <vincenz> monstre: because in VERY rare circumstances, it can not
10:48:42 <vincenz> monstre: and like I said, only those cases should you use it, and that's typically left for those with a more fundamental understanding of not only haskell but also the compiler
10:48:50 <vincenz> monstre: so if you don't even know monads.... don't ask for unsafePerformIO
10:49:09 <jadrian> monstre: unsafePerformIO does not exist
10:49:18 <jadrian> monstre: in the sense it is not part of the language
10:49:20 <vincenz> That's like asking to fly a jet when you can't walk yet.
10:49:46 <monstre> I'll gladly forget about it as soon as someone tells me how to do what I want without using it
10:49:51 <jadrian> monstre: if you don't even know the language yet, refrain from using hackish compiler features
10:49:54 <IsoPallo> jadrian: unsafePerformIO was only a weather balloon?
10:50:07 <roconnor> monstre: use MonadRandom
10:50:09 <vincenz> IsoPallo: It's the nukes in Irak
10:50:17 <jadrian> IsoPallo: I'm not telling...
10:50:35 <roconnor> monstre: or make your code deterministic.
10:51:04 <jadrian> monstre: one of the things I don't get is... you say your function is pure
10:51:10 <EvilTerran> unsafeFlyBlackHelicopter
10:51:11 <jadrian> monstre: but it needs coinflip
10:51:19 <jadrian> monstre: does it really?
10:51:31 <jadrian> monstre: instead of coinflip
10:51:37 <Zao> EvilTerran: Invisible black helicopter?
10:51:40 <vincenz> unsafeShootYourselfInFoot
10:51:43 <jadrian> monstre: maybe the argument should be the result of a coinflip
10:52:05 <jadrian> monstre: that is, maybe the argument should be the a value of type Head | Tail
10:52:12 <jadrian> monstre: and not the generator itself
10:52:18 <jadrian> monstre: that makes it pure
10:52:53 <jadrian> monstre: then inide the IO monad (the real world) you can flip your coin, and pass the pure argument into that pure function
10:52:57 <EvilTerran> "i made u a black helicopper, but i top secreted it"
10:53:39 <monstre> jadrian: but then I would have the change the interface of my tree delete function, which really has nothing to do with random numbers at all
10:54:08 <jadrian> monstre: have no idea what you are talking about now sorry :S
10:54:15 <roconnor> monstre: what may be reasonable is to use MonadRandom, and once you get to the point where your binary tree is gone (perhaps it has been flattend to a list); it may be reasonable to use unsafePerformIO to execute the MonadRandom, depending on your circumstances
10:55:38 <Deewiant> jadrian: he explained the function earlier, he wants to randomly left or right insert into a binary tree so that it doesn't become unbalanced
10:55:40 <dons> ?quote fulla
10:55:40 <lambdabot> Cale says: "Betta watch your back when I'm packin' a nine/I'll pump you fulla holes like the rational line"
10:55:41 <monstre> what I'd like is to able to write a function delete :: Ord a => a -> BST a -> BST a that does a single coin flip without having to lift my function to some monad
10:55:41 <Deewiant> or something like that
10:55:47 <dons> Cale, that's such an awesome rap :)
10:56:07 <jadrian> Deewiant: if he does it randomly there is a chance it becomes unbalanced :)
10:56:30 <Jaak> flipping a coin is a severe side effect...
10:56:35 <Deewiant> jadrian: aye, but less likely than always choosing the same side
10:56:40 <sethk> Cale, does that actually mean anything?
10:56:58 <jadrian> monstre: ok so just make it deterministc...
10:57:02 <roconnor> sethk: it means, don't fuck with Cale
10:57:03 <Baughn> If I specify an explicit type signature (foo :: a -> b), ghc won't add anything else to it (like instance requirements), right?
10:57:03 <jadrian> monstre: that is
10:57:13 <jadrian> monstre: you have a random number generator
10:57:31 <jadrian> monstre: instead of getting a random seed from the IO Monad
10:57:38 <jadrian> monstre: use a fixed seed
10:57:42 <jadrian> monstre: say 0
10:57:46 <monstre> I know a coin flip is a side effect and, although it could be observed from the outside in principle, in this case, I know that it won't
10:58:08 <jadrian> monstre: sure so why don't you do what I just said
10:58:19 <Baughn> monstre: Why are you flipping a coin if it can't be observed?
10:58:19 <sethk> a coin flip isn't a side effect
10:58:21 <jadrian> monstre: use a fixed seed for the random number generator
10:58:32 <jadrian> monstre: and you will get an infinite list
10:58:35 <Jaak> well, if it will never be directly or indirectly observed then you could replace coinflip with just "undefined"
10:58:36 <monstre> yeah, I think that's what I'll end up doing
10:58:38 <jadrian> monstre: of random numbers
10:58:45 <jadrian> monstre: then you just consume that list
10:58:54 <roconnor> Baughn: the randomness is for effeciency.
10:58:58 <jadrian> monstre: put the random seed as a constant
10:59:02 <sethk> Baughn, if it can't be observed, how can we know it was flipped?
10:59:04 <sethk> :)
10:59:08 <jadrian> monstre: if you don't like the way things are working
10:59:14 <jadrian> monstre: change the constant
10:59:23 <jadrian> monstre: so you have exactly what you are describing
10:59:31 <jadrian> monstre: a function that really is pure
10:59:33 <Baughn> roconnor: If it really can't be observed, I wouldn't have any issues with using unsafePerformIO
10:59:48 <Baughn> If it's for qsort or something. Of course it takes a bit of care
10:59:53 <jadrian> monstre: and that simulates the randomness you want, it will just always generate the same random sequence
11:00:06 <jadrian> monstre: which should be fine, because it seems that is not a problem
11:00:12 <roconnor> Baughn: I'm unclear as to whether unsafePerformIO is safe here.
11:00:21 <lament> lol @ editorial in the monad reader
11:00:25 <sethk> Has anyone run into this?  I'm writing an algebraic value to a file using hPutStrLn handle (show whatever).  the whatever is an array.  After a certain maximum size, the readIO on the data (when I read it in of course) fails
11:00:28 <roconnor> Baughn: if he pulls unsafePerformIO out far enough, it will be safe.
11:00:36 <lament> "The time has come to retreat and climb higher into our ivory tower: we need
11:00:37 <lament> to design a language that is so devious, so confusing, and so bizarre, it will take
11:00:39 <sethk> I think it's all written as one line and I'm exceeding a line length limit
11:00:40 <lament> donkeys years for mainstream languages to catch up."
11:00:40 <roconnor> Baughn: but at that point, he might as well use a fixed seed.
11:01:05 <sethk> lament, I think Haskell has already done that
11:01:13 <monstre> for the sake of argument, let's say I need a random seed to defeat complexity attacks from an adversary or something
11:01:13 <Jaak> lament: epigram?
11:01:27 <monstre> I just want to know how to write the function, that's all
11:01:39 <jadrian> monstre: we're telling you how
11:01:53 <jadrian> monstre: if you really need the randomness
11:01:54 <roconnor> monstre: use MonadRandom, and then run it with unsafePerformIO at the end (when it is safe)
11:01:58 <Baughn> monstre: You could say something like "qsort list = let randoms = unsafePerformIO makeRandomList in ..."
11:02:06 <monstre> jadrian: your solution uses a constant seed, not random
11:02:22 <resiak> make the creation function impure?
11:02:23 <Baughn> monstre: Of course it will produce a different list each time; that's the point. Your job is making sure that isn't observable.
11:02:24 <jadrian> monstre: the random solution uses IO monad because *it is not* pure
11:02:47 <jadrian> monstre: running the same function twice with the same argument can give different results
11:02:55 <jadrian> monstre: so it is not pure
11:03:12 <monstre> no, it is not
11:03:13 <Jaak> i dont get it. why not just use "randoms (mkStdGen 1) :: [Bool]" as a random supply?
11:03:16 <jadrian> monstre: using unsafePerformIO means the compiler might optimize things and just run it once
11:03:21 <Jaak> > randoms (mkStdGen 1) :: [Bool]
11:03:24 <lambdabot>  [True,False,True,True,False,True,False,True,False,False,True,True,False,True...
11:03:24 <jadrian> monstre: and always use the same result
11:03:26 <Baughn> Jaak: The Adversary
11:03:38 <monstre> but if I only care that the result is a BST, does it matter if it is impure?
11:03:46 <roconnor> monstre: unsafePerformIO (evalRandIO (do { blah; blah; blah; return some_value_that_is_independent_of_the_random_choices}))
11:03:47 <jadrian> monstre:  yes
11:03:48 <Baughn> Jaak: That line produces the same series each time. Attacking something using it can be trivial, in many cases
11:04:05 <sethk> jadrian, why does he care?
11:04:35 <Jaak> i'm sorry, but if you want to produce a seed out of thin air then you simply HAVE to use IO
11:04:43 <Baughn> sethk: Because the compiler does, and will happily chew up your dog if you violate referential transparency
11:04:47 <jadrian> sethk: for the same reason you care if a function as a  print
11:04:54 <Baughn> Or, worse, your goldfish
11:05:09 <sethk> Baughn, I'm safe, I think my dog already chewed up my goldfish
11:05:21 <Baughn> Erronous use of unsafePerformIO is, amusingly enough, undefined behaviour. ;)
11:05:23 <Baughn> Avoid it.
11:05:47 <monstre> I will, I'm just arguing for its own sake
11:05:47 <sethk> Baughn, sure, but as several people have pointed out, you can have randomness in the absense of undefined behavior
11:06:12 <Baughn> Sure, a lot of different ways
11:06:22 <Baughn> Using unsafePerformIO correctly, to begin with..
11:06:58 <sethk> well, I guess it's really pseudorandomness
11:07:23 <Baughn> Pseudorandom != random. You use random functions to make information, which no pure function can do..
11:07:42 <Baughn> Come to think of it, that's one of the defining aspects of IO. It's the only source of information in haskell.
11:08:00 <IsoPallo> Violating Haskell referencial transparency is an incredibly serious offence! It only has ten years!
11:08:02 <jadrian> I do agree things get messy sometimes
11:08:09 <jadrian> I use implicit parameters a lot
11:08:13 <jadrian> for instance
11:08:15 <DRMacIver> Hm. Idle observation. It occurs to me that the combination of >>= and reduction over a monoid have nice rewrite rule properties. I'm sure this isn't a new observation. Any papers to this effect?
11:08:15 <roconnor> hello, safe use of unsafePerformIO: unsafePerformIO (evalRandIO (do { blah; blah; blah; return some_value_that_is_independent_of_the_random_choices}))
11:08:20 <jadrian> the way *I* would do this
11:08:23 <jadrian> would be
11:08:33 <DRMacIver> (On lists or arrays or any sort of sequence type really)
11:08:39 <jadrian> make the whole stuff pure
11:08:49 <roconnor> as long as the intensional value return by evalRandIO is independent of the random choices.
11:08:53 <Baughn> Or "qsort = unsafePerformIO qsortWithRandomPivot" <-- should be perfectly fine
11:09:09 <jadrian> and put the state as implicit parameters
11:09:14 <jadrian> and the generator in the world
11:09:22 <roconnor> Baughn: good example
11:09:23 <EvilTerran> why use a random pivot, anyway?
11:09:29 <Baughn> EvilTerran: To avoid attacks
11:09:46 <dino-> map (read :: String -> Int) ["f", "o", "o"]
11:09:50 <dino-> > map (read :: String -> Int) ["f", "o", "o"]
11:09:51 <lambdabot>  Exception: Prelude.read: no parse
11:09:54 <dino-> hm
11:10:01 <EvilTerran> seems a tad obsessive, but okay
11:10:02 <roconnor> @go antiquicksort
11:10:03 <lambdabot> http://www.cs.dartmouth.edu/~doug/aqsort.c
11:10:08 <Baughn> EvilTerran: Most non-random pivots have O(n^2) behaviour on easily producable lists. The rest are still worse than mergesort.
11:10:18 <dino-> > map read ["f", "o", "o"]
11:10:18 <EvilTerran> isn't the built-in sort O(n.log n) worst case, anyway?
11:10:18 <lambdabot>  Exception: Prelude.read: no parse
11:10:26 <Deewiant> > map (read :: String -> Int) ["1", "2", "3"]
11:10:27 <lambdabot>  [1,2,3]
11:10:28 <Baughn> EvilTerran: Yes - it's mergesort. ;)
11:10:37 <dino-> > (map read ["f", "o", "o"]) :: Int
11:10:37 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
11:10:38 <Jaak> yeah, if you need good sort just use heap sort :P
11:10:40 <EvilTerran> so... why not just do that?
11:10:49 <Baughn> Quicksort is often faster, that's why
11:10:50 <roconnor> EvilTerran: mergesort doesn't operate in place
11:10:55 <Jaak> it's n log n with any input
11:11:02 <dino-> Interesting, can anyone me with this? I'd like :: [String] -> [Int]
11:11:11 <EvilTerran> is this guy working with mutable arrays, too?
11:11:11 <Baughn> mergesort makes perfect sense when we're sorting immutable lists anyway
11:11:12 <Deewiant> > map (read :: String -> Int) ["1", "2", "3"]
11:11:13 <lambdabot>  [1,2,3]
11:11:16 <monstre> someone please explain to me why randomized qsort is a sensible example of the use of unsafePerformIO but my BST deletion example isn't?
11:11:19 <dino-> Oh, I'm a dork
11:11:19 <Baughn> But in other languages.. quicksort is nice too
11:11:20 <Deewiant> dino-: how is "o" an Int?
11:11:23 <dino-> Non numbers
11:11:24 <dino-> yeah
11:11:26 <Deewiant> :-)
11:11:46 <Baughn> monstre: Dunno. Would it produce the /exact same/ tree structure regardless of the random numbers produced?
11:11:49 <roconnor> monstre: because the result of sorting is intensionally the same regardless of the random choices made.
11:12:01 <monstre> not quite
11:12:08 <monstre> qsort isn't stable
11:12:29 <dino-> But you really need that :: String -> Int I see
11:12:36 <Baughn> monstre: True. You'd have to augment it to /make/ it stable, in case of terrible ORd instances.
11:12:41 <roconnor> monstre: as I keep trying to tell you, if you move your unsafePerformIO out far enough, eventually you will get to some code where the result is intensinally the same value, always.  You can use unsafePerformIO there.
11:12:48 <dino-> > map read ["1","2","3"]
11:12:48 <lambdabot>  Exception: Prelude.read: no parse
11:12:57 <EvilTerran> defaulting to ()
11:13:03 <EvilTerran> > map read ["1","2","3"] :: [Int]
11:13:04 <lambdabot>  [1,2,3]
11:13:11 <EvilTerran> > map read ["()","()","()"]
11:13:12 <lambdabot>  [(),(),()]
11:13:28 <dino-> ok, yeah, somebody has to type it somewhere
11:13:32 <Baughn> monstre: It could be said that stability should not be an observable property in haskell, but..
11:13:40 <thetallguy> Question:  ghci tells me (fromIntegral 10 :: forall b. (Num b) => b), but if I put  ten = fromIntegral 10 in a file and load, then ghci says sample :: Integer
11:13:55 <dino-> Thank you.
11:13:55 <thetallguy> sorry, ten :: Integer
11:13:56 <EvilTerran> it's the dreaded monomorphism restriction!
11:14:00 <thetallguy> Is it?
11:14:05 <EvilTerran> yes, it is
11:14:16 <mrd> defaulting
11:14:21 <Baughn> Feeling restricted yet? -_-
11:14:23 <EvilTerran> stick "ten :: Num a => a" in the line above the definition
11:14:46 <thetallguy> EvilTerran, yeah, I figured out how to keep the type more general easily enough
11:14:49 <gnuvince> > map (read :: String -> Int) ["1", "2", "3"]
11:14:49 <lambdabot>  [1,2,3]
11:14:59 <EvilTerran> or use {-
11:15:04 <dons> "The barbarians are at the gates. Hordes of Java programmers are being exposed to generics and delegates; hundreds of packages have been uploaded to Hackage; the Haskell IRC channel has nearly hit 500 users; and itdata bases?s only a matter of time before Microsoft seals that multi-billion dollar bid for Hayoo"
11:15:05 <thetallguy> EvilTerran: I just wasn't sure what was causing the narrowing.
11:15:09 <dons> mwhaha
11:15:12 <DRMacIver> Baughn: It's not part of the contract of Eq that == things have to be extensionally (is that the right word?) equal is it?
11:15:12 <EvilTerran> {-# LANGUAGE NoMonomorphismRestriction #-}
11:15:24 <paczesiowa> Baughn: anything new with that shell pipes? have you filed a buf?
11:15:26 <Baughn> DRMacIver: It isn't, no
11:15:27 <thetallguy> dons: :-)
11:15:29 <mrd> defaulting is the precise mechanism which causes  it to choose Integer instead of erroring
11:15:44 <Baughn> paczesiowa: Not yet, and probably won't until friday - I'm busy with an assignment.
11:15:49 <DRMacIver> Baughn: So, given that, stability should be an observable property shouldn't it?
11:15:59 <thetallguy> EvilTerran: thanks, I read about it long ago, but I guess I've forgotten the details.  Time for a refresher
11:16:12 <Baughn> DRMacIver: No. It /is/ an observable property; that does not imply that it /should/ be.
11:16:18 <roconnor> DRMacIver: I've always interpreted Eq as only defining an equivalence relation on types.
11:16:23 <Baughn> DRMacIver: A question on which I am still undecided, mind you
11:16:33 <monstre> sorry if I'm a bit dense, but is randomized qsort a pure function or not?
11:16:44 <DRMacIver> Baughn: Ah, ok.
11:17:05 <DRMacIver> Baughn: I think what you want interacts poorly with the way newtypes are often used to work around the global scope of type classes.
11:17:10 <Baughn> monstre: It is, if you first augment the list to make it stable as well
11:17:26 <DRMacIver> Because one will often want to create newtypes which only care about a subset of the data
11:17:28 <roconnor> monstre: assuming (a==b) only if a and b are the same value, then randomised qsort is a pure function.
11:17:29 <monstre> but unstable, it isn't?
11:17:37 <Jaak> monstre: depends. you could define it like sort :: (RandomGen g, Ord a) => r -> [a] -> (r, [a])
11:17:42 <Jaak> then it's pure
11:17:45 <shepheb> the @quote database appears to be messed up. it can't find anything for "dons", "monad", "monads", "java", etc.
11:17:52 <roconnor> monstre: rather (comparing a b == Eq) only if a and b are the same value.
11:18:06 <DRMacIver> e.g. suppose I wanted to store a set of people, kept unique by name. It's reasonable to newtype Person and have the resulting order and equality depend only on the name.
11:18:22 <DRMacIver> (Ok, this is a lousy example, but hopefully it conveys the idea)
11:18:29 <Baughn> monstre: Unstability can be observed, so no.
11:18:39 <roconnor> DRMacIver: I think so.
11:19:20 <DRMacIver> But in this case we do care about the value of x up to more than ==, because when we unwrap it back to a Person we could potentially have two different people with the same name.
11:19:31 <Baughn> Hm. Question: If you use unsafePerformIO, is it okay if your "pure" function sometimes returns an already-evaluated list and sometimes a thunk that would evaluate to said list?
11:19:56 <DRMacIver> The thunky nature of something isn't generally considered to be observable.
11:20:05 <roconnor> Baughn: I believe so
11:20:10 <DRMacIver> You have to do other unsafe things to observe it. :)
11:20:20 <Baughn> Good. :)
11:21:27 <DRMacIver> So, any references on what I was asking about >>= and monoids?
11:21:44 <monstre> so if I *know* I don't care about stability, would anyone object to the use of unsafePerformIO in randomized qsort?
11:21:56 <Baughn> monstre: Yes
11:22:10 <roconnor> monstre: yes
11:22:14 <Baughn> monstre: Even if *you* don't, the RTS does. You could end up corrupting it
11:22:24 <monstre> RTS??
11:22:25 <Baughn> (Not to the point of segfaults - that's on a lower level. I think.)
11:22:32 <roconnor> monstre: run time system
11:22:36 <Baughn> monstre: The virtual machine running your haskell program
11:22:39 <DRMacIver> Baughn: I doubt it would corrupt the RTS. It would turn off a bunch of optimisations though.
11:22:59 <Baughn> DRMacIver: If it /did/ turn off the optimizations, that'd be fine. What if it didn't?
11:23:06 <DRMacIver> It does. :)
11:23:25 <Baughn> Also, I'm using "corrupt" in the more general "produce behaviour that does not perfectly match the haskell standard" sense
11:23:44 <Baughn> Seeing as I've yet to had any haskell program actually /crash/, there's not much for that sense. ;)
11:23:51 <yav> i missed the beginning of this, but you don't need IO to generate random numbers
11:23:55 <DRMacIver> Oh. Well, that's different. It's by definition true because "a randomly unstable sort" is already not matching the haskell standard.
11:23:59 <Baughn> yav: We covered that, yes.
11:24:06 <yav> oh, sorry :-)
11:24:12 <[CitationNeeded]> i wonder if one day i'll be able to write code without making stupid mistakes, so that it works on the first try
11:24:23 <Baughn> [CitationNeeded]: No.
11:24:30 <[CitationNeeded]> :(
11:24:39 <DRMacIver> But my point is just that I don't think it's likely to cause anything worse than things being in a slightly funky order (but still subject to the conditions you'd expect)
11:24:56 <DRMacIver> Maybe I'm wrong. I'm sure as hell not an expert on GHC internals. :)
11:25:02 <byorgey> [CitationNeeded]: Yes.
11:25:10 <DRMacIver> [CitationNeeded]: Maybe.
11:25:15 <Baughn> [CitationNeeded]: Well, not as long as you stay purely human. Stay alive and that might change
11:25:18 <byorgey> [CitationNeeded]: FileNotFound.
11:25:40 <Baughn> [CitationNeeded]: Either Human AI?
11:26:27 <DRMacIver> either (sleepUntil $ timeOf singularity) undefined
11:26:59 <DRMacIver> (ok, that doesn't type check. Oh well)
11:27:11 <Baughn> ..no singularities, please. They're too piercing.
11:27:27 * Baughn wonders if the Ultimate AI will be written in haskell
11:28:10 <DRMacIver> Nah. There will be at least 10,000 generations between now and then (which might take an entire 15 minutes to develop)
11:28:15 <DRMacIver> generations of language that is
11:28:36 <Baughn> True dat. OKay.. last AI written by humans, then?
11:28:36 <roconnor> I'd be vaguely inclined to write AI in an untyped language.
11:28:40 <byorgey> The Ultimate AI will write itself in a language written in a language written in Haskell.
11:29:25 <Baughn> > fromList [(1,2),(1,3)]
11:29:25 <lambdabot>   Not in scope: `fromList'
11:29:30 <Baughn> > M.fromList [(1,2),(1,3)]
11:29:30 <lambdabot>  fromList [(1,3)]
11:30:49 <Baughn> @pl \f -> 'a'++f++'b'
11:30:49 <lambdabot> ('a' ++) . (++ 'b')
11:31:20 <sethk> why is Data.Map.lookup monadic, but Data.Map.findWithDefault is not?
11:31:31 <dons> it shouldn't be monadic.
11:31:34 <Baughn> sethk: It doesn't need to be
11:31:45 <IsoPallo> byorgey: And it will hell sure come here to ask advice :)
11:31:47 <dino-> > map (\x -> [x]) "foo"
11:31:48 <lambdabot>  ["f","o","o"]
11:31:49 <DRMacIver> lookup is monadic to handle the "I didn't find anything" case.
11:31:51 <dons> the monadic failure idiom is considered bad practics
11:31:59 <dons> as it admits more broken programs that Either or Maybe
11:31:59 <dino-> Is that the best way to do that? Turn that [a] into [[a]] ?
11:32:03 <dolio> It should be monadplusic.
11:32:06 <DRMacIver> dons: Really? Why?
11:32:16 <dons> fail = error in almost all monads
11:32:17 <Baughn> dolio: Bondage and Discipline thing?
11:32:24 <Baughn> *dons
11:32:29 <dons> and the overloading means you can accidentally use the wrong fail, without noticing
11:32:48 <DRMacIver> Fair enough
11:32:52 <Baughn> I suppose it's pretty easy to make a wrapper either way, if you want one. So Maybe works.
11:32:57 <dons> a language for high assurance, like haskell, shouldn't be behaving in this perl-like way.
11:33:03 <dons> and yes, you can lift Maybe to m a
11:33:38 * roconnor doesn't understand the problem with monadic failure
11:34:21 <yav> roconnor: it is just that the type is not accurate
11:34:24 <kpreid> roconnor: that it exists on all monads, not just those which implement it nontrivially
11:34:26 <Lycurgus> i'm not seeing any haskell interfaced formal/algebraic methods packages, like larch. http://haskell.org/haskellwiki/Analysis_and_design has some inconclusive stuffs. Is this because haskell is considered self-sufficient in this respect and does anyone know of a good paper thereupon.
11:34:33 <monstre> Possibly related to my earlier questions, but is there a way to write a function memoize :: (a->b) -> (a->b) ?
11:34:40 <sethk> dons, are you saying that I shouldn't use Data.Map.lookup?
11:34:42 <roconnor> oh okay
11:34:46 <kpreid> monstre: yes...with unsafePerformIO!
11:35:07 <monstre> but this function is pure though, right?
11:35:14 <Baughn> monstre: Yep
11:35:14 <yav> sethk: use it but with caution (i.e., make sure you are using it at a type that makes sense)
11:35:15 <DRMacIver> monstre: If you don't mind a type class constraint on a you can do it with generalized tries.
11:35:23 <yav> we really should fix the library
11:35:40 <Jedai> sethk: No, but use it in a monad that handle fail sanely (ie Maybe is the main use case anyway)
11:35:42 <Baughn> monstre: If a is reasonably small, wrapping it in a map of all values works fine too. Or an array if it's even smaller
11:36:07 <Baughn> monstre: Arrays are lazy in their values, which makes them /very/ nice for dynamic programming. :)
11:36:30 <Baughn> monstre: Also, you norwegian?
11:36:49 <monstre> Canadian, actually
11:36:53 <monstre> strange question
11:36:59 <sethk> yav, Jedai, this particular use is well defined, so I think I'm ok.
11:37:06 <Baughn> It's just that your name is the norwegian word for "monsters". Seemed odd.
11:37:17 <monstre> it's also Frnech
11:37:23 <monstre> err, French
11:37:38 <lament> i would guess it's pretty international
11:37:47 <desegnis_> it's also Esperanto, while we're at it
11:38:01 <Jedai> sethk: Don't worry about dons rambling, really, it's not that bad (mostly a problem of language design (standard lib design rather))
11:38:03 <lament> yay esperanto
11:38:28 <monstre> speaking of memoize, is there an equivalent in a library somewhere?
11:38:28 <Jedai> Canadian from Quebec ?
11:38:35 <monstre> yes
11:38:56 <sethk> Jedai, I don't know, I've found that dons usually turns out to be right
11:39:05 <Jedai> memoize :: (a -> b) -> (a -> b) can't be written
11:39:06 <lament> are there lots of hot girls in montreal? Do they speak English?
11:39:16 <sethk> lament, sure, and they all write Haskell code
11:39:18 <Baughn> Jedai: In any language
11:39:37 <monstre> many do speak English, much better than myself
11:39:38 <lament> memoize = id
11:39:41 <Jedai> sethk: Oh he is right, it's just that it's not important in most use case
11:39:55 <roconnor> eliminuNaturaNombro :: a -> (a -> a) -> NaturaNombro -> a
11:40:02 <Jedai> Baughn: You can in a language with side-effect
11:40:10 <sethk> Jedai, yes, but unless I understand the issue, it's hard to say whether it matters to _my_ use case
11:40:12 <Baughn> Jedai: Not with that type. How would you do it?
11:40:18 <monstre> Jedai: why can't memoize be written?
11:40:38 <Baughn> Jedai: If you could, you could write (a->b) -> IO (a->b) in haskell, which you can't
11:40:41 <roconnor> data PozitivaProporcio = Unuo
11:40:41 <roconnor>                 | PliGranda PozitivaProporcio
11:40:41 <roconnor>                 | MalpliGranda PozitivaProporcio
11:40:42 <Jedai> Baughn: You memoise only value when they're asked for the first time
11:40:47 <EvilTerran> memoize :: ((a -> b) -> c) -> ((a -> b) -> c) -- also
11:40:58 <Baughn> Jedai: You can't even /store/ them without Ord or at least Eq constraints
11:41:10 <dons> Jedai: i'm rambling? Monad m return type polymorphism is error prone though. Any non-total functions for purely functional structures are highly suspect.
11:41:12 <lament> Baughn: doesn't return have that type?
11:41:22 <dons> sethk: but yeah, as long as you're careful, its fine
11:41:23 <Jedai> Of course you also need some universal Eq/Ord (but many language have it)
11:41:24 <EvilTerran> specialisation of the above type, and completely unimplementable, as functions are abstract
11:41:26 <Baughn> lament: What of it?
11:41:30 <sethk> dons, ok
11:42:07 <Baughn> Jedai: Then, if you constraint it with Ord, you can do the exact same thing in haskell using unsafePerformIO. It'd be safe in this case.
11:42:17 <lament> baughn: what's impossible about (a->b) -> IO (a->b) ?
11:42:28 <Baughn> lament: Writing a memozer with that type
11:42:33 <Baughn> *memoizer
11:42:51 <Jedai> dons: Yes, I agree, it's just that sethk seemed to take the warning a little bit too seriouly (there's nothing really dangerous about lookup used in the right monads)
11:43:25 <Jedai> Baughn: Yes of course, you can consider that Haskell + unsafePerformIO is a language with side-effect
11:43:42 <dons> ah right.
11:43:48 <Jedai> Baughn: And this usage is fine since it stays referentially transparent
11:43:58 <dons> 'safety' has a different meaning in haskell :)
11:44:00 <sethk> Jedai, dons, I'm using it in what I imagine is the most common situation, in the IO monad
11:44:03 <Baughn> Jedai: Right. Now I think we're agreeing violently.
11:44:04 <dons> any partial function is considered unsafe
11:44:15 <dons> sethk: so you want it to throw error ?
11:44:22 <shepheb> I would have thought the most common lookup monad would be Maybe.
11:44:26 <shepheb> @ src Maybe fail
11:44:27 <dons> yeah.
11:44:29 <sethk> dons, In the not found case, you mean?
11:44:31 <shepheb> @src Maybe fail
11:44:31 <lambdabot> fail _      = Nothing
11:44:38 <shepheb> that one, at least, is safe.
11:44:39 <dons> case M.lookup x y of Nothing -> .. ; Just n -> ...
11:44:45 <dons> sethk: yeah
11:44:55 <dons> if M.lookup fails in the IO monad, it calls error
11:45:07 <sethk> dons, Not in general, no, I want to report the error but allow the program to continue with the normal sequence
11:45:11 <sethk> dons, so I catch it?
11:45:14 <dons> and your program exits. that's "unsafe" in my book, since lookup failing is common, not exceptional
11:45:23 <dons> sethk: why not just catch it in Maybe then?
11:45:28 <sethk> dons, yes, that won't do.
11:45:29 <Jedai> sethk: You should use MAybe
11:45:36 <sethk> dons, OK, I'll use Maybe
11:45:41 <dons> this is *exactly* why return type Monad overloading is dangerous
11:45:46 <shepheb> @src (Either String) fail
11:45:46 <lambdabot> Source not found. My mind is going. I can feel it.
11:45:57 <Deewiant> @src Either fail
11:45:57 <lambdabot> fail msg      = Left (strMsg msg)
11:46:14 <dons> > M.lookup 1 M.empty :: Either String ()
11:46:16 <lambdabot>  Left "Data.Map.lookup: Key not found"
11:46:16 <desegnis> roconnor, do people actually put non-English identifiers into Haskell code like that?
11:46:22 <Jedai> What "normal sequence", the returned value by lookup is now not defined, what would you do, you must be explicit about the error handling !
11:46:26 <sethk> dons, you mean because a different function may be called than you are expecting?
11:46:30 <dons> > M.lookup 1 M.empty :: MAybe ()
11:46:30 <lambdabot>   Not in scope: type constructor or class `MAybe'
11:46:43 <roconnor> desegnis: I argue that we ought to.
11:46:50 <dons> sethk: because it exits your program in the common case, and its easy to accidentally get that undesirable behaviour
11:46:54 <roconnor> desegnis: although my argument isn't very pursuasive.
11:46:58 <dons> > M.lookup 1 M.empty :: Maybe ()
11:46:59 <lambdabot>  Nothing
11:47:35 <roconnor> data PozitivaMalnaturaNombro = Unuo
11:47:35 <roconnor>                              | Duobla PozitivaMalnaturaNombro
11:47:35 <roconnor>                              | SekvaDuobla PozitivaMalnaturaNombro
11:47:43 <desegnis> roconnor, I imagine that to play badly with the Prelude and base :)
11:48:11 <EvilTerran> > length "PozitivaMalnaturaNombro"
11:48:12 <lambdabot>  23
11:48:18 <roconnor> haskell' should be written in Esparanto
11:48:28 <Jedai> dons: Well I guess your point is even more important that I thought... It seemed obvious to me that using lookup in IO should kill the program if it failed but apparently that's not the case for everyone...
11:48:33 <EvilTerran> i'd go for shorter identifiers, in any language. this isn't java, fehrcryinoutloud.
11:48:41 <monstre> so is there a rule for when it's okay to use unsafePerformIO, besides 'never'?
11:48:51 <paczesiowa> so lookup shoud fail in some ErrorMonad right?
11:48:55 <olsner> "never ever" :P
11:49:15 <roconnor> monstre: when the intensional value of the result is independent of the environment.
11:49:24 <sethk> Jedai, failed lookup is not an uncommon event and may not be an error at all, let alone a fatal one
11:49:28 <Jedai> monstre: If you use unsafePerformIO, you should prove yourself that you don't break referencial transparency
11:49:44 <Lycurgus> ftr and fwiw, the Camilla Revival doc describing a VDM/V++ interaction is the closet i've found
11:49:47 <EvilTerran> monstre, it's like's Jackson's rules of program optimisation
11:49:52 <EvilTerran> Rule 1: don't do it
11:50:03 <EvilTerran> Rule 2 (for experts only!): don't do it yet
11:50:11 <sethk> More concretely, how do I use the Maybe monad?  Do I use a liftM call?
11:50:13 <Jedai> sethk: Yes, but if you use it in IO without handling the error, then continuing would left your program in a incoherent state
11:50:27 <desegnis> @faq u ghc subtenas esperantigitan bazbibliotekon?
11:50:27 <lambdabot> The answer is: Yes! Haskell can do that.
11:50:36 <monstre> well, I thought I finally hit upon an example where it might be called for with memoize
11:50:41 <Jedai> sethk: With a case for example
11:51:12 <Jedai> sethk: case lookup k m of Nothing -> ... ; Just v -> ...
11:51:13 <sethk> Jedai, I tried that, but I must not have done it correctly.  I'll try again.
11:51:33 <sethk> Jedai, yes, my fault, fat fingers
11:51:46 <Lycurgus> yeah, I think that was supposed to be beacuse Jackson designs were supposed to obviate optimizations a lot of times
11:52:56 <EvilTerran> i think it was basically just warning you off premature optimisation
11:53:21 <monstre> rconnor: what exactly does it mean for two things to be extensionally equivalent?
11:53:34 <EvilTerran> if you're not an expert, you won't be familiar with what affects code speed, so you should just write the obvious code
11:53:58 <monstre> does it just mean that a == b ?
11:54:03 <Lycurgus> (thumbing thru Principles of Program Design now)
11:54:19 <augustss> monstre: depends on what == means
11:54:23 <Jedai> monstre: It means you can't distinguish using any function
11:54:48 <monstre> alright, thank you
11:55:58 <Jedai> monstre: (Forall function f, f a is extensionally equivalent to f b) => a is extensionally equivalent to b. (and you define some base cases)
11:56:49 <Lycurgus> "But two poings should always be kept in mind: first, optimization makes a system less reliable and harder to maintain, and therfore move expensive to build and operate; second, because optimizatuib obscures struture it is difficult to improve efficiency of a system which is already partly optimized".
11:57:06 <Lycurgus> that immediatel after the famous 2 part rule
11:57:15 <Lycurgus> *immediately
11:58:12 <Lycurgus> *points
11:58:15 <sethk> Anyone have a suggestion for my earlier problem?  I'm persisting a data structure, which is an array, using show, and when it exceeds a certain size, the corresponding read fails.  I believe because it writes it to one line and a line length limit is eventually exceeded.  ?
11:58:20 <Jedai> Lycurgus: The second point is very true :) (Better to improve the algorithm, and easier to do if you haven't already obscured the intent of your code)
11:58:41 <Lycurgus> *more
11:59:10 <Lycurgus> whoa "optimizatuib" beelzebub's ugly sibling
11:59:18 <Jedai> sethk: show hardly seems a good choise to persist large data structures (Data.Binary would be better)
11:59:18 <sethk> Jedai, I "failed" a job interview because I pointed that out.  Not that I wanted that job, but it was still weird ...
11:59:44 <monstre> now that I think about it, is there any way to write a memoize function that works with recursive functions as well?
11:59:50 <monstre> because I can't see how
11:59:57 <lament> sethk: you had a haskell job interview?
12:00:12 <sethk> lament, not that one, no.
12:00:30 <sethk> lament, but we got into a discussion of premature optimization and when one should think about algorithmic efficiency
12:00:57 <sethk> lament, and how it's common to make the code less reliable only to find out that the algorithm in question wasn't even really a bottleneck at all
12:01:12 <Jedai> monstre: You can't really, no, well the outer layer would get memoizing but the internal function would recurse to the original not-memoized function
12:01:29 <monstre> yeah, that's what I thought
12:01:32 <lament> sethk: ...and that caused them to reject you? :)
12:01:35 <sethk> Jedai, using read/show delegates to the compiler all the marshalling/unmarshalling issues
12:01:40 <monstre> you'd have to re-bind the function name
12:01:42 <sethk> lament, yes.
12:01:58 <Jedai> monstre: A recursive function should be written in an open recursive form to allow for that
12:02:16 <monstre> I'm afraid you lost me there, sorry
12:02:22 <monstre> open recursive form?
12:02:42 <lament> sethk: sounds like a fun job
12:03:01 <lament> "Here, you are expected to SHUT UP AND OPTIMIZE!"
12:03:09 <Jedai> monstre : fact' 0 _ = 1 ; fact' n f = n * f (n-1)
12:03:17 <sethk> lament, I'm luckly they rejected me  :)
12:03:27 <sethk> Jedai, I don't see Data.Binary in the library docs
12:03:46 <Jedai> monstre: then fact n = fact' n fact
12:03:59 <Jedai> monstre: And you can write a memoized version
12:04:00 <Saizan> ?hackage binary
12:04:00 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
12:04:13 <Jedai> sethk: It's in the standard GHC library
12:04:13 <Saizan> sethk: ^^^
12:04:28 <monstre> Jedai: I see. I don't suppose there's any way to get the same effect without re-writing the function, right?
12:04:32 <sethk> Jedai, I thought if it's in the standard library, I don't need to get it from hackage.
12:04:50 <Jedai> monstre: Nope, you'll need language support to change that
12:05:23 <desegnis> binary does indeed not ship with ghc
12:05:39 <monstre> hmmm, perhaps there should be a memoize function built into the standard
12:05:47 <monstre> seems like it would come in handy
12:05:52 <sethk> desegnis, ok, thanks
12:06:06 <Cale> Heh, I just noticed that whoever wrote the myspace music player either didn't know how, or was too lazy to write a proper frequency analyser, so they have some bars which go up and down randomly, it seems.
12:06:17 <DRMacIver> It seems like most of the time when people want to memoize something they build an appropriate lazy datastructure.
12:06:33 <Jedai> I thought it did (maybe in another version)
12:06:53 <desegnis> Cale, heh. But do people actually need those bars?
12:06:53 <Jedai> sethk: What's the size limit you get ?
12:07:20 <sethk> Jedai, I haven't completely tested, but roughly 8k
12:07:24 <monstre> DRMacIver: It would still be nice to be able to memoize functions after the fact without having to modify them though
12:07:50 <DRMacIver> Sure.
12:08:21 <Jedai> sethk: That seems pretty strange, I'm not aware of any limit to read/show input/output size...
12:08:24 <Cale> desegnis: I suppose at least myspace people don't ;) It's handy if there's also an equaliser around to get the levels where you want them.
12:08:41 <sethk> Jedai, might be a limit in the library call it uses to read a line from the file
12:08:51 <sethk> Jedai, no, check that, I used hGetContents
12:09:06 <desegnis> for calibration... ok, imaginable
12:09:28 <sethk> its runghc Setup.lhs configure        runghc Setup.lhs build         and     runghc Setup.lhs install             correct?
12:09:53 <Jedai> Yes
12:10:11 <sethk> and where do I find the docs?
12:10:36 <lament> Cale: really, those bar thingies actually serve some purpose?
12:10:48 * lament actually didn't realize
12:11:11 <Saizan> sethk: either on the hackage page, or with runghc Setup.lhs haddock
12:11:26 <lament> so you would adjust the equalizer to get some specific shape?
12:11:28 <sethk> Saizan, thanks
12:11:56 <Cale> lament: They give you what's essentially the pointwise square of the Fourier transform, so they measure the energy of the wave at various frequencies.
12:12:18 <Saizan> sethk: you should just need encode/decode
12:12:26 <lament> Cale: i understand
12:12:29 <sethk> Saizan, ok, thanks
12:15:15 <Jedai> sethk: Still, those limits on your show/read are pretty strange, I just did a test with a 40k elements array without a problem...
12:15:26 <Jedai> Could you show the program
12:17:39 <sethk> Jedai, yes.  Maybe I'm misinterpreting.  I can't see how, though.  It always succeeds until a certain size and then it always fails; I did it with two different types, and it's the same code that reads/writes in all cases.
12:17:49 <CosmicRay> what is the proper way to reflect something like this in build-depends in a .cabal file?   HaXml>=1.13.2<=1.19
12:18:01 <sethk> Jedai, I'll split the data into more than one line and see what the behavior is.
12:26:06 <Jedai> sethk: I'm pretty sure the problem isn't the line length (hGetContents don't work in a line oriented fashion)
12:27:07 <sethk> Jedai, ok, I'll do some more investigating
12:31:35 <gnuvince> Does anybody know if SPJ's keynote (or his "A Taste of Haskell" tutorial) at ACCU 08 was video taped?
12:33:06 <dibblego> A Taste of Haskell definitely was
12:33:21 <dibblego> http://blog.tmorris.net/algebraic-data-types-again/ I have links on there
12:33:24 <lambdabot> Title:  Tony&#8217;s blog   Blog Archive  Algebraic Data Types again
12:35:29 <gnuvince> dibblego: that's from OSCON 2007.  Did he use the same material?  I recall reading that he showed how to use Haskell to do Perl-like scripting (which is the part that really interests me)
12:36:21 <dibblego> oh sorry, dunno then
12:36:44 <CosmicRay> gnuvince: both were videotaped
12:37:38 <gnuvince> CosmicRay: thanks
12:37:40 <CosmicRay> gnuvince: http://oscon.blip.tv/#330372
12:37:41 <lambdabot> Title: O'Reilly Open Source Convention on blip.tv
12:37:52 <gnuvince> ...
12:37:57 <gnuvince> That's OSCON again.
12:38:14 <CosmicRay> gnuvince: isn't that what you're looking for?
12:38:25 <Cale> CosmicRay: He said ACCU'08
12:38:30 <CosmicRay> oh, missed that.
12:39:36 <Jedai> sethk: Note that on a 100k elements array, the read takes almost 5s (in interactive mode) and the show/write 0.3s, that's using readFile and writeFile
12:41:24 <sethk> Jedai, that's acceptable for my present purpose
13:11:06 <thetallguy> Anyone care to name a cabal package with a model quickCheck config?
13:11:49 <mib_cn4pay> i want to place my ghc on my jump drive, can i make it portable/
13:11:50 <mib_cn4pay> ?
13:13:05 <thetallguy> mib_cn4pay: you mean make it runnable from .?
13:13:26 <roconnor> does configure --local work?
13:13:38 <thetallguy> mib_cn4pay: I think there are instructions on that in the GHC build process, since it is done during build
13:15:36 <sethk> mib_cn4pay, it can be done.  The simplest way to do it is to name the directory on the stick to match the default install locations for ghc.  Then it just happens.
13:17:07 <sethk> Jedai, you were correct, turned out to be a different issue which I've now resolved.
13:17:18 <oldsalt> @seen shag
13:17:18 <lambdabot> shag is in #gentoo-haskell and #haskell. I don't know when shag last spoke.
13:17:29 <tcr> I'm facing the problem that Trace output seems to get swallowed somewhere, i.e. it's truncated in mid of displaying something. If I decrease the amount of stuff that's printed before this "something", more trace output of "something"  will appear. Does anyone know how I tweak this on ghc?
13:17:38 <shag> oldsalt: hm?
13:18:00 <oldsalt> shag: mr. arrow?
13:18:09 <shag> hehe
13:28:21 <fanw> EvilTerran: you there?
13:30:57 <Cale> tcr: hmm
13:31:04 <fanw> Question: i see code like this "instance Monad ((->) r) where"
13:31:07 <fanw> and "instance Functor ((->) r) where"
13:31:14 <Cale> fanw: Sure
13:31:32 <Jedai> fanw: Well yeah
13:31:32 <Cale> fanw: ((->) r) is the partial application of the type constructor (->) to r
13:31:36 <fanw> does "->" has a general meaning other than lambda?
13:31:44 <Cale> fanw: -> is the type constructor for functions
13:31:53 <Cale> :t chr
13:31:54 <lambdabot> Int -> Char
13:31:56 <Jedai> (->) is a type constructor
13:32:13 <mib_cn4pay> what about libraries, i want to run wxhaskell from my jump drive
13:32:20 <Cale> fanw: So ((->) r) is the type constructor for functions from a fixed type r
13:32:28 <mib_cn4pay> can it be done?
13:32:29 <Jedai> -> in the lambda is at the value level, (->) in signature is at type-level
13:32:40 <tcr> Cale: I'm trying to get at the root of a bug causing some non-termination. And not being able to trace lots of output makes my life really unbearable.
13:32:55 <lament> why is it written ((->) r) and not (r ->) ?
13:33:08 <Jedai> tcr: Do you know the trace function ?
13:33:10 <fanw> cale: is this define by Haskell? or because it's in ((->)r)?
13:33:15 <Cale> lament: Because sections aren't supported at the type level.
13:33:22 <tcr> Jedai: Well, guess what I use :)
13:33:23 <Jedai> tcr: Also, did you try the GHCi debugger ?
13:33:35 <Cale> tcr: You're using Debug.Trace?
13:33:40 <tcr> Right
13:34:01 <Cale> tcr: I've never seen that get cut off...
13:34:23 <Cale> tcr: However, it can get pretty confusing if your program is printing on the same terminal :)
13:34:36 <tcr> I've never seen it not get cut off, hum. I'm using 6.6.1.
13:34:37 <Cale> fanw: I'm not sure I understand your question now...
13:35:05 <Jedai> trace print on stderr, you can redirect it to a file, it may help
13:35:58 <Cale> tcr: how long are the strings you're trying to print as traces?
13:36:41 <tcr> Cale: Moderately long. Ranging from a few lines, to a couple of dozens.
13:36:51 <fanw> Cale: WRT "-> as a type constructor", is this universal or only when it is interpreted in the context of  say "((->)r)?
13:37:25 <Jedai> fanw: This is universal, you can use it in any type signature
13:37:31 <Cale> ah, that's interesting, it does get cut off at about 4096 characters here
13:37:53 <fanw> i see, thanks
13:37:55 <Jedai> > let f :: (->) Int Int; f = (+2) in f 5
13:37:56 <lambdabot>  7
13:37:58 <Cale> fanw: (->) shows up in the type signature of any function
13:37:58 <lispy> ?type id :: ((->) a b) -> ((->) a b)
13:37:59 <lambdabot> forall a b. (a -> b) -> a -> b
13:38:05 <Cale> fanw: It's just usually infix.
13:38:56 <Cale> @type map :: (->) ((->) a b) ((->) ([] a) ([] b))
13:38:57 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
13:39:00 <Cale> ;)
13:39:20 <Cale> Types look funny when you make all the constructors prefix :)
13:39:24 <lispy> why does that remind me of lisp :)
13:39:59 <tcr> Jedai: Redirecting stderr seems to help a bit.
13:40:04 <dibblego> is '[] a' valid type signature syntax?
13:40:09 <Cale> dibblego: yep
13:40:10 <lispy> yeah
13:40:20 <dibblego> oh great, I wish I knew that when I was teaching
13:40:20 <Cale> [] is the name of the type constructor for lists
13:40:39 <dibblego> > [1,2,3] :: [] Int
13:40:40 <lambdabot>  [1,2,3]
13:40:43 <Cale> Similarly, pairs have the type constructor (,)
13:40:54 <Cale> and triples have (,,) and so on
13:41:02 <lispy> :t (,,,,,,,,,)
13:41:03 <lambdabot> forall a b c d e f g h i j. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> (a, b, c, d, e, f, g, h, i, j)
13:41:15 <lispy> :t zipWith (,)
13:41:15 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
13:41:19 <EvilTerran> :k (,,,,,)
13:41:19 <Cale> :t (,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -
13:41:20 <lambdabot> * -> * -> * -> * -> * -> * -> *
13:41:21 <lambdabot> parse error on input `-'
13:41:42 <EvilTerran> @quote pcrs
13:41:42 <lambdabot> No quotes match. :(
13:41:46 <Cale> :t (,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> (,,,,,,,,,) a b c d e f g h i j
13:41:47 <EvilTerran> ... bah.
13:41:47 <lambdabot> forall a b c d e f g h i j. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> (a, b, c, d, e, f, g, h, i, j)
13:41:47 <Jedai> lispy: Be careful, that's not a type constructor, that's the corresponding constructor
13:41:58 <mrd> -> is also a kind constructor
13:42:19 <EvilTerran> :k [] :: (->) * *
13:42:20 <lambdabot> parse error on input `::'
13:42:26 <EvilTerran> humbug
13:42:32 <mrd> no kind annotations !
13:42:47 <dons> http://reddit.com/info/6f29b/comments/ interesting graph for those who've not seen it
13:42:49 <Cale> tcr: maybe try printing shorter traces?
13:42:53 <fanw> very interesting
13:43:03 <fanw> Cale++
13:43:06 <Cale> tcr: But the debugger in ghci is really probably the way to go :)
13:43:19 <fanw> Jedai++
13:44:14 <lispy> dons: but what about people that build from source and people like myself taht don't like to use popularity contest
13:46:11 <sethk> thanks, all, for the help.  I'll be back later
13:46:18 <Cale> lispy: Are you saying there's a likely correlation between popcon users and mercurial users?
13:46:44 <dons> mercurial's likely cheaper to install
13:47:11 * Heffalump is not at all convinced that popcon graphs prove very much
13:47:19 <lament> wow, mercurial rules
13:47:21 <Heffalump> but they are interesting
13:47:28 <dons> they say something about the ease of installing a package on that distro
13:47:28 <lament> (and the day of darcs' glory are gone)
13:47:32 <lament> *days
13:47:37 <EvilTerran> Heffalump, just like most statistics, then :P
13:47:48 <lispy> Cale: no, I'm just wondering how significant those contributions are to the "real" number of people using these systems
13:47:56 <Cale> lament: Which is funny, since 2.0 was just released and it fixes basically all the problems people were having
13:48:00 <dons> yes, darcs defined what dvcs could do, by being the first seriously usable system
13:48:06 <dons> it was 5 years ahead of its competitors
13:48:31 <dons> oh, hang on.
13:48:34 <dons> git vs git-core?
13:48:34 <lispy> Yeah, a lot of other vcs figured out how they could handle things based on what darcs was doing.
13:48:57 <dons> anyone know if git is actually git-core on debian, or the other way around?
13:49:08 <lispy> I know monotone and hg both seemed to correspond with the darcs about how to do this or that best
13:49:18 <nominolo_> git-core is the right one i think
13:49:20 <Botje> dons: it's git-core on ubuntu
13:49:24 <dons> yes, its git-core
13:49:26 <lispy> no idea, the last time i used git you had to build it yourself
13:49:27 <nominolo_> at least on ubuntu
13:49:37 <Cale> dons: yeah, git is the GNU Interactive Tools
13:49:45 <dons> fixing..
13:50:07 <nominolo_> dons: you're switching to git now?
13:50:14 <lispy> whoa, that changes everything
13:50:27 <lispy> now git is way, way in the lead as off 2006-08 or so
13:50:35 <dons> http://reddit.com/info/6f2ak/details
13:51:11 <dons> i wonder if we can infer something about how haskell makes a suitable language for rapidly getting a system into releasable state
13:51:45 <lispy> and how that system then stagnates because few outsiders can understand it? ;)
13:51:45 <nominolo_> ok, that seems more believable
13:51:55 <Cale> It's interesting how the growth curves for git and mercurial are nicely quadratic.
13:52:03 <nominolo_> dons: heh, you sound like a marketing department
13:52:19 <lament> was pugs the same way?
13:52:20 <dons> well, darcs really did move a *lot* faster than its competitors
13:52:22 <cjb> dons: you might instead find that people don't upload Haskell code to an SCM *until* it's in a releasable state.  :)
13:52:24 <dons> similar with pugs
13:52:37 <dons> for these problems that couldn't actually be coded up until they tried to do it in haskell
13:52:55 <dons> so it wasn't known how to do dvcs or perl6, after a few attempts
13:53:01 <dons> then the haskell guy just does it.
13:53:03 <nominolo_> dons: or maybe just the functional approach to programming
13:53:09 <dons> xinerama + dwm-style tiling is another example :)
13:53:16 <lispy> dons: I know what you're driving at, but how do you controll for the effect that david has.  Some studies have already shown the variance between developers is much greater than between languages.  How would you show that it wasn't the programmers that were getting the prototypes right so quickly?
13:53:21 <nominolo_> dons: though, really, i think it's more the person than the language
13:53:21 <dons> nominolo_: yes, perhaps. and strong typing + high levels of abstraction
13:53:26 <lament> so basically haskell rules for prototyping, but sucks for maintenance.
13:53:36 <nominolo_> dons: just the language happening to attract better programmers
13:53:41 <dons> lispy: right, it could just be the david and audreyt factor
13:53:42 <cjb> hm, subversion's logarithmic growth seems much greater than git's.
13:53:53 <dons> subversion is a default install
13:53:58 <dons> as is cvs, i think
13:54:06 <dons> so you're seeing debian's (or popcon) growth?
13:54:22 <cjb> you're saying there are only 20000 machine running popcon?
13:54:30 * Cale is starting to think this obsession with popularity is unhealthy :)
13:54:40 <dons> cjb: oh, good point. not sure.
13:54:43 <cjb> oh, sure enough, there are
13:54:47 <cjb> (I did a search for popcon)
13:54:49 <dons> it'd expect 10x that.
13:54:53 <dons> oh?
13:55:09 <cjb> graphing popcon's popularity doesn't get you >20k.  I guess because it's optional?
13:55:16 <dons> ah
13:55:20 <dons> that's good to know.
13:55:20 <thetallguy> second posting, now that things are livelier:  Anyone care to name a cabal package with a model quickCheck config?
13:55:39 <dons> thetallguy: Data.Binary ?
13:55:42 <Cale> http://people.debian.org/~igloo/popcon-graphs/index.php?packages=popularity-contest&show_installed=on&want_legend=on&want_ticks=on&from_date=2003-10-01&to_date=&hlght_date=&date_fmt=%25Y-%25m&beenhere=1
13:55:43 <lambdabot> Title: popcon graph, http://tinyurl.com/5wwac5
13:56:19 <lispy> Is it possible to have a project be community maintained?
13:56:22 <Cale> It actually gets you somewhere near 80k
13:56:39 <nominolo_> lispy: yes, but nothing really gets done ;)
13:56:45 <Heffalump> Cale: success may not be everything, but it's pretty important for keeping momentum.
13:57:14 <thetallguy> dons: Thanks, that will do.
13:57:29 <lispy> I've also wondered, since most FOSS projects are in C, what would happen if we converted darcs to C now that we understand what the "prototype"
13:57:30 <Cale> Heffalump: It's also pretty important for stagnating.
13:57:46 <lispy> er, understand what the prototype should do :)
13:57:52 * lispy needs to finish his sentences
13:57:54 <Cale> The more popular something becomes, the less people allow it to change.
13:58:13 <EvilTerran> Cale, do i detect a little "but we can't change the prelude now everyone's expecting it to be like it is"-related bitterness?
13:58:35 <Heffalump> we just need to make it easier to use alternate preludes, and actually make some
13:58:40 <Cale> EvilTerran: Heh, yes. But not just that, the whole language will have a hard time changing like that.
13:58:51 <Cale> Heffalump: I agree, that should be the first step.
13:58:53 * Heffalump thinks a DSEL-targeted prelude would be really useful
13:59:40 <Heffalump> using an alternate prelude isn't hard in itself, really what we need are standard packages rebuilt against different preludes
13:59:47 <lament> lispy: ...people will use Git.
13:59:49 <thetallguy> Heffalump: sounds interesting, what would it have?
13:59:49 <Heffalump> functors would be handy here :-)
13:59:57 <Cale> Yeah, also, support for an alternate do-syntax translation
14:00:11 <Heffalump> Cale: -XNoImplicitPrelude does that
14:00:13 <nominolo_> don't we have quasiquoting in ghc now?
14:00:17 <Cale> Heffalump: Hm?
14:00:22 <Heffalump> thetallguy: a boolean type class
14:00:23 <lispy> lament: ah, so no need to rewrite darcs in C because git is way ahead anyway?
14:00:28 <Cale> Heffalump: I'm pretty sure the do-notation will still use fail
14:00:29 <Heffalump> Cale: provides a different do-translation
14:00:33 <Heffalump> oh, right.
14:00:37 <lament> http://blog.moertel.com/articles/2007/12/10/how-i-stopped-missing-darcs-and-started-loving-git
14:00:38 <lambdabot> Title: How I stopped missing Darcs and started loving Git, http://tinyurl.com/6h93n6
14:00:55 <Cale> However, we might be able to stick fail in its own class...
14:00:57 <Cale> Hmm...
14:01:07 <Tobsan> @src reverse
14:01:07 <lambdabot> reverse = foldl (flip (:)) []
14:01:28 <thetallguy> Heffalump: there's an answer I didn't expect.  I haven't heard about why such a thing would be useful
14:02:57 <Heffalump> thetallguy: because otherwise you can't have a different boolean type in your DSEL
14:03:03 <Heffalump> and Haskell booleans are often not what you want
14:03:23 <nominolo_> how would a different boolean type look like?
14:03:27 <thetallguy> Heffalump: That's never been the case for me.  Have an example?
14:03:45 <nominolo_> data MyBool = True | False | DontKnow ?
14:03:53 <Heffalump> I have a DSEL that produces SQL
14:03:55 <gwern> @seen dcoutts_
14:03:55 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #ghc and #haskell. I don't know when dcoutts_ last spoke.
14:04:16 <Heffalump> so I want to be able to write code that works on SQL booleans, not Haskell booleans
14:04:18 <gwern> hm. are any of the cabal devs around?
14:04:35 <thetallguy> Heffalump: Ah, gotcha.
14:04:42 <Heffalump> also, a Num class that doesn't have Show and Eq as superclasses
14:05:05 <lament> blog comment "As a mathematician, darcs appeals to me in a way Git never will. I also think darcs will become the better SCM when t -> inf."
14:05:39 <gwern> guess not.
14:05:49 <gwern> so anyway, what do people think of making the 'stability:' the same kind of enumerated type entry as 'license:'? currently stability is too free-form to be useful
14:05:57 <thetallguy> Heffalump: why not Eq?
14:06:15 <Heffalump> well, once you have overloaded booleans it's not so bad, but without them it's crippling for the same reason
14:06:16 <thetallguy> Heffalump: because you want to use SQL's version
14:06:50 <Heffalump> perhaps I'm biased towards staged DSELs where the code actually runs outside the Haskell runtime.
14:07:10 <thetallguy> Heffalump: I don't think so.
14:07:49 <thetallguy> Heffalump: even if things run inside the run-time, I often feel things are still too tightly bound for my purposes.
14:08:27 <thetallguy> Heffalump: though much better than any other system, of course...
14:09:10 <Heffalump> indeed.
14:09:55 * Heffalump disappears
14:10:07 <Cale> hmm, what is this GHC.Base.Monad class?
14:10:57 <Cale> hmm, it's showing up in my type signatures with NoImplicitPrelude
14:11:12 <lispy> lament: that article does not convince me to use git, it makes me think that git is very complex and hard to use
14:11:58 <lispy> lament: I mean, based on that article, I'd probably choose svn over git purely for simplicity.
14:12:48 <pjd> *couhg*
14:13:15 <Cale> aha
14:13:22 <Saizan> is there any intention/interest to cabalize darcs?
14:13:28 <Cale> I also need -XNoImplicitPrelude in my ghci session for that to work
14:13:52 <Cale> Okay, separating fail into a separate class works like this...
14:14:09 <lispy> Saizan: it comes up a fair bit, but cabal is not industrial strength and darcs needs that to work in all of it's different configurations on different platforms, or so it seems
14:15:19 <Saizan> lispy: does it depend on lots of C libraries?
14:15:50 <lispy> Saizan: it can
14:16:07 <gwern> Saizan: I think the issue is the baroque build architecture, and lispy mentioned darcs supports as far back as GHC 6.2
14:16:10 <oldsalt> @seen shag
14:16:10 <lispy> I lost track of how many http libraries it uses :)
14:16:10 <lambdabot> shag is in #gentoo-haskell and #haskell. I last heard shag speak 58m 1s ago.
14:16:32 <lispy> gwern: I'm pretty sure 6.2 was dropped when 6.8 came out.
14:17:05 <lispy> But, 6.4 is still valid
14:17:10 <gwern> I hope so. I'm not sure what's the point of even supporting 6.4, fwiw
14:17:10 <Baughn> Darcs uses.. a http library of some description, obviously. Anything else?
14:17:27 <Baughn> Oh dear. ldd says "a lot".
14:17:58 <lispy> gwern: lots of people are using old-ish versions of ghc.
14:18:07 <lispy> I think that's the reasoning
14:18:15 <gwern> lispy: so let them use oldish versions of darcs
14:18:29 <Baughn> Does ghc use exec for anything other than runProcess/friends? Anyone know?
14:18:40 <gwern> if you're using something like debian stable, you're supposed to be using all-old components! there are reasons they don't backport stuff willy-nilly
14:18:44 <lispy> gwern: we're not the darcs maintainers though, so we don't get to make that call
14:19:39 <lispy> can cabal build the darcs manual?
14:19:48 <lispy> I doubt it
14:19:54 <awesame> is there an easy way to convert a symbol into a string in haskell?
14:19:59 <gwern> lispy: true, but it's worth remembering; if it comes up on darcs-devel I'll think I'll argue that supporting 6.4 is wasteful
14:20:11 <awesame> I have some constructors, data Foo = Bar | Baz
14:20:34 <awesame> and I'd like to do something more convenient than:
14:20:39 <awesame> show Bar = "Bar"
14:20:42 <lispy> awesame: well, show/read
14:20:44 <Cale> deriving Show
14:20:52 <Baughn> awesame: data foo = Bar | Baz deriving(Show)
14:20:58 <awesame> oh, deriving Show already does that?
14:21:02 <Cale> yep
14:21:03 <awesame> well, that makes this easier
14:21:06 <Baughn> What else would it do?
14:21:07 <lispy> show Foo ==> "Foo"
14:21:11 * awesame deletes code
14:22:56 <Botje> about that: how do you derive a Typeable instance for a custom type?
14:23:07 <Botje> does GHC do it for you or do you have to go ".. deriving Typeable" ?
14:23:18 <Baughn> Botje: No, and that wouldn't wrk
14:23:24 <Jedai> lispy: I was under the impression that darcs problem was that it hadn't really _a_ maintainer anymore ?
14:23:25 <Baughn> Botje: instance it yourself, or use drift
14:23:59 <Botje> awww
14:24:11 <Botje> the SYB paper promised GHC would be able to do it "real soon now"
14:24:23 <Jedai> Botje: deriving Data and Typeable works now
14:24:53 <Jedai> Baughn: Are you sure ? (I'm pretty sure I already derived Data and Typeable)
14:24:54 <roconnor> I'm told that Conor McBride literally threw up after reading SYB.
14:25:06 <roconnor> although I suspect he only figuratively threw up
14:25:11 <bos> Botje: what?
14:25:41 <Botje> bos: what? :)
14:25:50 <bos> Botje, Baughn: you need the DeriveDataTypeable extension, and it works
14:26:08 <Botje> ah
14:26:10 <Botje> cool!
14:26:19 <bos> it has worked since at least 6.6, possibly earlier.
14:26:26 <Jedai> Yes, I already did it several time (in 6.6)
14:26:36 <lament> what's so bad about SYB?
14:27:09 <roconnor> lament: I'm not sure.
14:27:44 <roconnor> lament: I got the impression that foldable, traversable, and maybe applicative functors was Conor's response.
14:28:13 <roconnor> swiert may know more
14:28:26 <lispy> Jedai: kinda yeah.  It has a maintainer who doesn't went to send much time on it.  Are you interested in being the maintainer?
14:28:46 <lispy> Is anyone here interested in that job?
14:28:57 <roconnor> lispy: maintaing darcs?
14:29:00 <lispy> roconnor: yeah
14:29:09 <roconnor> maybe, but I need to finish my thesis first.
14:29:21 <lispy> roconnor: that's exactly what I've been saying :)
14:30:37 <ziman> @where on
14:30:37 <lambdabot> I know nothing about on.
14:30:46 <lispy> ?goohle on
14:30:47 <lambdabot> http://www.yourdictionary.com/
14:30:47 <lambdabot> Title: Dictionary & Thesaurus - YourDictionary
14:30:52 <lispy> ?hoogle on
14:30:52 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
14:30:52 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
14:30:52 <lambdabot> Data.Function :: module
14:31:01 <ziman> thanks
14:31:25 <awesame> for converting Chars to lowercase, there's Data.Char.toLower
14:31:41 <awesame> is there already a function somewhere that does "map toLower"?
14:31:57 <Cale> no
14:32:03 <Cale> (because there's map toLower :)
14:33:22 <Baughn> Will derived Show instances ever insert newlines into their output?
14:34:09 <tromp> i doubt it
14:34:33 <Cale> Baughn: No, but they may call other show instances which do.
14:34:52 <Baughn> Cale: So as long as I don't instance or use anything that does, I'm good. Thanks
14:36:25 <mib_cn4pay> hey i am trying run wxhaskell and i get the error -v to see a list of files searched for
14:36:35 <mib_cn4pay> what is -v?
14:37:13 <lispy> verobes?
14:41:33 <fnoble> does anyone have any experience compiling nhc98, building from C?
14:41:36 <Jedai> mib_cn4pay: it's short for verbose, by the way this isn't the error it's an advice on how to detect why ghc don't find some of the modules that are imported by what you're trying to compile
14:42:21 <Jedai> mib_cn4pay: The actual error should be before that (something like "<Module> not found")
14:42:59 <Cale> dons: By the way, checking "want percent" gives a much more informative graph. The growth in the number of users of each VCS in those popcon graphs is dominated by the increase in the number of popcon users as a whole.
14:43:31 <fnoble> im getting some unresloved symbols: _FN_Control_46Exception_46throw and _FN_Control_46Exception_46try
14:43:39 <fnoble> google doesnt know anything about them
14:43:56 <dons> Cale: i was starting to wonder about that.:)
14:44:09 <dons> seems like that should be the default.
14:44:42 <Cale> Indeed.
14:45:11 <dons> interesting, much the same curves for xmonad with percent
14:45:17 <dons> but we see a shrinking curve for darcs
14:45:19 <Cale> It shows a very different picture.
14:45:21 <Cale> Yeah
14:46:30 <dons> its bleaker
14:46:46 <dons> so darcs got as high as 6.2% of popcon users
14:47:01 <dons> xmonad's up to 0.2% :)
14:47:12 <lament> where's the pic for xmonad?
14:47:25 <Cale> lament: type xmonad into the textbox
14:47:30 <Cale> and check "want percent"
14:47:35 <dons> http://people.debian.org/~igloo/popcon-graphs/index.php?packages=xmonad&show_installed=on&want_percent=on&want_legend=on&want_ticks=on&from_date=2007-10-01&to_date=&hlght_date=&date_fmt=%25Y-%25m&beenhere=1
14:47:36 <lambdabot> Title: popcon graph, http://tinyurl.com/56hxme
14:47:54 <dons> now, if we can get 500 people in here to apt-get xmonad
14:47:59 <dons> after first registering popcon
14:48:00 <vincenz> @type runST
14:48:01 <lambdabot> forall a. (forall s. ST s a) -> a
14:48:17 <dobblego> removeIndicies :: [Int] -> [a] -> [a] -- would you sort the given [Int] first, then traverse the [a] filtering each index as it is encountered?
14:48:30 <kaol> apt-get install xmonad popcon
14:48:42 <Cale> http://people.debian.org/~igloo/popcon-graphs/index.php?packages=firefox&show_installed=on&want_percent=on&want_legend=on&want_ticks=on&from_date=2006-10-01&to_date=&hlght_date=&date_fmt=%25Y-%25m&beenhere=1
14:48:42 <lambdabot> Title: popcon graph, http://tinyurl.com/6jw7ww
14:48:46 <lament> ratpoison declines in about the same way as xmonad increases
14:49:06 <dons> ah, yes
14:49:17 <dons> while on the install graph, ratpoison climbs with overall use
14:49:17 <Cale> I wonder why that is :)
14:49:19 <lament> however dwm has the same trend as xmonad but a higher percentage
14:49:25 <Cale> (look at the firefox graph!)
14:49:45 <dons> and wmii has been falling
14:49:51 <lament> Cale: isn't firefox called seamonkey in debian
14:49:59 <Cale> ah, iceweasel
14:50:01 <lament> or something like that
14:50:02 <Cale> http://people.debian.org/~igloo/popcon-graphs/index.php?packages=firefox%2Ciceweasel&show_installed=on&want_percent=on&want_legend=on&want_ticks=on&from_date=2006-10-01&to_date=&hlght_date=&date_fmt=%25Y-%25m&beenhere=1
14:50:02 <lament> iceweasel
14:50:02 <lambdabot> Title: popcon graph, http://tinyurl.com/5lc4yl
14:50:29 <Cale> So there's the explanation right there :)
14:50:44 <Cale> Seamonkey is a different project
14:51:03 <lament> why is there no ghc package
14:51:20 <lament> hugs is there
14:51:26 <Cale> It's called ghc6
14:53:14 <Cale> and you see in April 2007 around the time of the 6.6.1 release, a massive drop
14:53:22 <lament> it seems like all packages show a decline in percentage between 2007-04 and 2007-05
14:53:27 <lament> no
14:53:32 <lament> that drop is there for everything
14:53:52 <lament> er, http://people.debian.org/~igloo/popcon-graphs/index.php?packages=perl&show_installed=on&want_percent=on&want_legend=on&want_ticks=on&from_date=2006-10-01&to_date=&hlght_date=&date_fmt=%25Y-%25m&beenhere=1
14:53:53 <lambdabot> Title: popcon graph, http://tinyurl.com/5uyea4
14:53:57 <Cale> mm
14:54:16 <lament> perl is erratic as usual
14:54:31 <Cale> But perl is installed with the system, so it'll always be close to 100%
14:54:35 <lament> yeah
14:54:42 <lament> but for example, http://people.debian.org/~igloo/popcon-graphs/index.php?packages=bitchx+ircii+irssi+xchat&show_installed=on&want_percent=on&want_legend=on&want_ticks=on&from_date=2006-10-01&to_date=&hlght_date=&date_fmt=%25Y-%25m&beenhere=1
14:54:42 <lambdabot> Title: popcon graph, http://tinyurl.com/696ktq
14:54:52 <lament> irc clients all have that drop in april 2007
14:55:00 <Cale> Interesting
14:55:15 <Cale> I wonder if there was a new version of debian out then?
14:55:15 <lament> some bare-bones debian-based distro joined popcon en masse?
14:55:49 <s710b> does somebody know a function for permutation, like [a]->[[a]], returning a list of all permutations of a?
14:56:08 <lament> s710b: ohhh you asked for it
14:56:18 <lament> s710b: now the entire channel will start giving you cryptic one-liners
14:56:21 <Cale> s710b: It's not in the libraries, strangely enough :)
14:56:59 <Cale> Permutations isn't easy to do well as a one-liner, but can fit comfortably in 3 or so.
14:57:24 <lament> what, you don't have a one-liner?
14:57:27 <lament> incredible
14:57:40 <Cale> combinations however, I have a very elegant one liner :)
14:57:42 <lament> the appropriate monad must not have been written yet :)
14:57:53 <s710b> thats enough for me, just thought there would be one in the libraries
14:58:00 <Cale> > filterM (const [False, True]) [1..3]
14:58:01 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
14:58:10 <tromp> @let permute l = foldM (\s _ -> [a:s | a <- l\\s]) [] l
14:58:11 <lambdabot> Defined.
14:58:22 <lament> > permute [1..3]
14:58:23 <lambdabot>  [[3,2,1],[2,3,1],[3,1,2],[1,3,2],[2,1,3],[1,2,3]]
14:58:24 <Cale> List subtraction is a bad way to do it :)
14:58:38 <dobblego> ?type (\\)
14:58:39 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
14:58:50 <lament> > permute [1,1,2]
14:58:50 <lambdabot>  [[2,1,1],[1,2,1],[2,1,1],[1,2,1],[1,1,2],[1,1,2]]
14:59:13 <lament> works...
14:59:40 <s710b> i tried this before, but dont know how to deal with changable numbers of arguments:
14:59:43 <Cale> I think it might choke if the instance of Eq was only an equivalence relation.
14:59:44 <lament> > (permute [], permute [1], permute [1,1])
14:59:44 <lambdabot>  ([[]],[[1]],[[1,1],[1,1]])
14:59:47 <s710b> > [[x,y,z] | x<-[1..3], y<-[1..3], z<-[1..3], x/=y, x/=z, y/=z]
14:59:47 <lambdabot>  [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
14:59:55 <s710b> i tried this before, but dont know how to deal with changable numbers of arguments:
15:00:21 <lament> > permute [0..]
15:00:26 <lambdabot> Terminated
15:00:33 <s710b> ow double post. this chat is too fast for me...
15:00:42 <Cale> s710b: I'd start by writing a function select :: [a] -> [(a,[a])] which gives a list of pairs consisting of an element, and the remainder of the list.
15:01:13 <lament> > head$head$permute [0..]
15:01:18 <lambdabot> Terminated
15:01:23 <dobblego> ?hoogle Int -> [a] -> [a]
15:01:23 <lambdabot> Prelude.take :: Int -> [a] -> [a]
15:01:23 <lambdabot> Prelude.drop :: Int -> [a] -> [a]
15:01:23 <lambdabot> Data.List.take :: Int -> [a] -> [a]
15:01:39 <Jedai> lament: This permute isn't lazy enough
15:02:16 <s710b> Cale, thanks for the hint, ill try to make it work myself
15:02:31 <tromp> :t foldM
15:02:32 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
15:02:48 <lament> Jedai: couple years in QA taught me to trust no one but the output :)
15:04:15 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]; permute [] = [[]]; permute xs = [y:zs | (y,ys) <- select xs, zs <- permute ys] in permute [1..4]
15:04:16 <lambdabot>  [[1,2,3,4],[1,2,4,3],[1,3,2,4],[1,3,4,2],[1,4,2,3],[1,4,3,2],[2,1,3,4],[2,1,...
15:04:34 <tromp> Cale, the list subtraction is ok, since the list comprehension generates a linear number of results anyway
15:04:56 <Cale> tromp: It requires an Eq instance though.
15:05:19 <Cale> :t let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]; permute [] = [[]]; permute xs = [y:zs | (y,ys) <- select xs, zs <- permute ys] in permute
15:05:20 <lambdabot> forall a. [a] -> [[a]]
15:05:23 <tromp> yeah, that's a minor issue
15:05:44 <augustss> permute should not rely on Eq.  That's just wrong
15:05:58 <tromp> i guess it's only good for showing off one liners:)
15:06:00 <Cale> It also doesn't work properly with instances of Eq which are equivalence relations.
15:06:25 <Cale> (i.e. that make some things compare equal which are otherwise distinguishable)
15:07:19 <Cale> I really wish that at least select were in the libraries.
15:07:40 <lament> > permute [(+), (-)]
15:07:40 <lambdabot>   add an instance declaration for (Eq (a -> a -> a))
15:08:12 <Cale> @undef
15:08:12 <lambdabot> Undefined.
15:08:28 <Cale> @let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
15:08:29 <lambdabot> Defined.
15:09:53 <Cale> @ let selectN n = runStateT . replicateM n . StateT $ select
15:09:55 <Cale> @let selectN n = runStateT . replicateM n . StateT $ select
15:09:58 <lambdabot> Defined.
15:10:08 <Cale> > selectN 2 [1..3]
15:10:09 <lambdabot>  [([1,2],[3]),([1,3],[2]),([2,1],[3]),([2,3],[1]),([3,1],[2]),([3,2],[1])]
15:10:18 <Cale> > selectN 3 [1..3]
15:10:18 <lambdabot>  [([1,2,3],[]),([1,3,2],[]),([2,1,3],[]),([2,3,1],[]),([3,1,2],[]),([3,2,1],[])]
15:10:31 <Cale> > map fst $ selectN 3 [1..3]
15:10:31 <lambdabot>  [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
15:11:09 <Cale> Monad transformers pwn.
15:11:27 <gnuvince_> :t selectN
15:11:28 <lambdabot> forall a. Int -> [a] -> [([a], [a])]
15:11:40 <gnuvince_> :t fst
15:11:41 <lambdabot> forall a b. (a, b) -> a
15:11:43 <dolio> But they're so inconvenient! :)
15:11:50 <Cale> dolio: Look at this case :)
15:11:50 <vincenz> :t typeOf
15:11:51 <lambdabot> forall a. (Typeable a) => a -> TypeRep
15:11:54 <dolio> C is much nicer. :)
15:12:11 <Beelsebob> dolio: what's inconvenient?
15:12:39 <Cale> Beelsebob: He's being facetious :)
15:12:44 <dolio> I don't know. You'll have to look up the recent reddit article about monad transformers to explain.
15:12:48 <gnuvince_> what module is selectN in?
15:12:54 <Cale> gnuvince_: I just defined it
15:13:03 <dolio> It's in L, of course.
15:13:03 <Cale> gnuvince_: scroll up a bit :)
15:13:03 <gnuvince_> oh
15:13:13 <Cale> selectN n = runStateT . replicateM n . StateT $ select
15:13:17 <Cale> select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
15:13:45 <dolio> Needs some Conor McBride 'ala' magic.
15:14:10 <Cale> dolio: hm?
15:14:21 <dolio> Let me see if I can find the mailing list post...
15:14:50 <dobblego> > let delete is xs = map fst (filter (\(_, n) -> n `notElem` is) (zip xs [0..])) in delete [4, 5, 3] ['a'..'z'] -- is this an appropriate algorithm? it seems it could be made more efficient by sorting 'is'?
15:14:50 <lambdabot>  "abcghijklmnopqrstuvwxyz"
15:15:09 <Cale> dolio: Oh, I see.
15:15:27 <Cale> dolio: Yeah, that was actually in reply to my message, but I didn't really absorb it.
15:15:31 <dolio> http://www.haskell.org/pipermail/haskell-cafe/2008-February/039007.html
15:15:32 <lambdabot> Title: [Haskell-cafe] A handy little consequence of the Cont monad, http://tinyurl.com/5rhkp2
15:15:40 <dolio> "Third-order: it's a whole other order."
15:15:56 <tromp> :t StateT
15:15:57 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
15:16:08 <Jedai> dobblego: yes it could be made more efficient
15:16:16 <dobblego> Jedai, would you sort is?
15:17:11 <Jedai> dobblego: Probably, since it would then pass from O(nm) to O(n + m log m) (and since m < n)
15:17:17 <tromp> :t replicateM
15:17:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
15:17:23 <dobblego> Jedai, ok agreed, thanks
15:17:28 <dolio> Actually, that'd probably be 'wrap StateT (replicateM n)'
15:18:05 * resiak reads the 'ala' post and leaks brane juice
15:18:08 * dolio >>= dinner.
15:20:22 <nominolo_> hm, how is that greek letter called that looks like a small "i" but without the dot?
15:20:36 <tromp> iota
15:20:40 <gwern> Mmm.... branes!
15:20:48 <Cale> Yep iota
15:20:57 <nominolo_> ah, thanks
15:21:08 <nominolo_> i hate it when i can't pronounce the letters in a paper
15:22:29 <tromp> @instances Monad
15:22:30 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
15:23:10 <Cale> alpha beta gamma delta ep-si-lon, zeta eta theta iota and kappa, lambda mu nu xi omicron pi, rho sigma tau, upsilon phi chi psi omega, now I know my alpha beta gammas, next time won't you ... uh, that's the end of the song.
15:24:38 <tromp> :t foldM
15:24:39 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
15:31:58 <tromp> is it possible to combina StatT select with foldM ?
15:32:34 <mib_cn4pay> i am getting an error that says can't load .so/.DLL for: wxc-msw2.6.4-0.10.3
15:32:46 <mib_cn4pay> what is that?
15:33:12 <tromp> :t runState
15:33:13 <lambdabot> forall s a. State s a -> s -> (a, s)
15:33:22 <Cale> :t runStateT
15:33:23 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
15:33:37 <Cale> mib_cn4pay: That looks like part of the wx libraries.
15:33:59 <Cale> mib_cn4pay: (as in, not the haskell part, but the other part)
15:35:07 <enticingjelly> why didn't I know of zipWith. it all makes sense now.
15:35:21 <Cale> enticingjelly: What makes sense?
15:35:22 <enticingjelly> so much better than map (uncurry..) (zip..)
15:35:34 <Cale> mm, yeah :)
15:36:03 <enticingjelly> Cale, heh, I wasn't really serious. it already made sense, but zipWith is nicer %)
15:36:42 <Jedai> enticingjelly: You have zipWith3 and so on until zipWith7 too (and zipWithM too)
15:37:29 <Jedai> mib_cn4pay: It seems the dll for wx isn't available, meaning it's not installed or the dll isn't on the PATH
15:37:31 <enticingjelly> another thing I *just* learned and would have profited from knowing before: for/forM instead of map/mapM. there I was, always typing (flip map) %)
15:37:54 <enticingjelly> Jedai, yup, nice... I'm already a heavy user for zipWithM
15:38:37 <Jedai> enticingjelly: It's really worthwile to take a little bit of time to review the standard library after you learned the Haskell basis.
15:38:41 <Cale> hmm, is there a 'for'?
15:38:43 <Cale> :t for
15:38:44 <lambdabot> Not in scope: `for'
15:39:02 <Jedai> @hoogle for
15:39:02 <lambdabot> Data.Traversable.for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
15:39:02 <lambdabot> Control.Monad.forM :: Monad m => [a] -> (a -> m b) -> m [b]
15:39:02 <lambdabot> Control.Monad.forM_ :: Monad m => [a] -> (a -> m b) -> m ()
15:39:18 <enticingjelly> Cale, there's a forM in Control.Monad and also a for in Data.Traversable (but I'm only using forM, so far)
15:39:24 <Jedai> So in Data.Traversable it seems
15:39:34 <Cale> Oh, right
15:39:36 <enticingjelly> Jedai, yeah, exactly right. there's all kinds of helpful little functions
15:40:19 <enticingjelly> did you know "on"?
15:40:26 <enticingjelly> haven't used it yet, but: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Function.html#v%3Aon
15:40:27 <lambdabot> http://tinyurl.com/yrwgjc
15:40:40 <mib_cn4pay> how do i set the dll on the path?
15:40:55 <Cale> > groupBy ((==) `on` length) [[1,2,3],[4,5],[6,7],[8,9,10]]
15:40:59 <lambdabot>  [[[1,2,3]],[[4,5],[6,7]],[[8,9,10]]]
15:41:42 <Cale> mib_cn4pay: Depends, but maybe try setting the LD_LIBRARY_PATH environment variable
15:41:56 <enticingjelly> :t fix
15:41:57 <lambdabot> forall a. (a -> a) -> a
15:42:36 <tromp> where's StateT defined?
15:42:45 <enticingjelly> tromp, Control.Monad.State
15:42:45 <lispy> ?free fix
15:42:46 <lambdabot> f . g = h . f => f (fix g) = fix h
15:43:03 <Cale> > fix ((0:) . scanl (+) 1)
15:43:04 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
15:43:05 <lispy> ?djinn (a -> a) -> a
15:43:05 <lambdabot> -- f cannot be realized.
15:43:06 <enticingjelly> lispy, what does ?free do?
15:43:24 <Cale> enticingjelly: generates a free theorem from the type of something
15:43:29 <enticingjelly> ah.
15:44:03 <tromp> :t select
15:44:04 <lambdabot> forall t. [t] -> [(t, [t])]
15:44:15 <tromp> @let permute l = map fst . runStateT (mapM (const (StateT select)) l) $ l
15:44:15 <lambdabot> Defined.
15:44:17 <Cale> :t StateT
15:44:18 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
15:44:23 <Cale> :t StateT select
15:44:24 <lambdabot> forall t. StateT [t] [] t
15:44:33 <EvilTerran> ?hoogle select
15:44:33 <lambdabot> No matches found
15:44:40 <Cale> :t replicateM 5 . StateT $ select
15:44:41 <lambdabot> forall t. StateT [t] [] [t]
15:44:49 <Cale> EvilTerran: It's defined in L right now
15:44:57 <EvilTerran> i see
15:45:01 <Cale> :t runStateT . replicateM 5 . StateT $ select
15:45:03 <lambdabot> forall t. [t] -> [([t], [t])]
15:45:11 <tromp> > permute "car"
15:45:11 <lambdabot>  ["car","cra","acr","arc","rca","rac"]
15:45:24 <tromp> can that be simplified further?
15:45:43 <EvilTerran> > replicateM 3 "car"
15:45:43 <lambdabot>  ["ccc","cca","ccr","cac","caa","car","crc","cra","crr","acc","aca","acr","aa...
15:45:46 <EvilTerran> no wait
15:45:59 <tromp> i mean the definitionm of permute in terms of select
15:46:04 <reltuk`> If I wanted to create a patched version of Distribution.Simple.Build that got used by default in my ghc installation, would I need to patch the version that installed with ghc, or could I make another package that provided that module along side the ghc installation?
15:46:07 <Cale> maybe
15:46:12 <Cale> :t perute
15:46:13 <lambdabot> Not in scope: `perute'
15:46:14 <Cale> :t permute
15:46:15 <lambdabot> forall a. [a] -> [[a]]
15:46:52 <lispy> :t peru
15:46:53 <lambdabot> Not in scope: `peru'
15:48:35 <Cale> hmm
15:49:42 <mib_cn4pay> is there a way to call a dll inside ghci to be used
15:50:14 <tromp> i can make it more  dotty:
15:50:29 <tromp> @let permute l = map fst . (runStateT . (mapM . const . StateT $ select) $ l) $ l
15:50:29 <lambdabot> <local>:3:0:     Warning: Pattern match(es) are overlapped              In th...
15:50:55 <shepheb> @pl g >>= return . f
15:50:55 <lambdabot> f `fmap` g
15:50:56 <Cale> @let p xs = (evalStateT . forM xs . const . StateT $ select) xs
15:50:56 <lambdabot> Defined.
15:51:00 <Cale> > p [1,2,3]
15:51:00 <lambdabot> Terminated
15:51:05 <Cale> er...
15:51:06 <shepheb> I knew that was something.
15:51:06 <lambdabot> shepheb: You have 1 new message. '/msg lambdabot @messages' to read it.
15:51:15 <Cale> @undef
15:51:16 <lambdabot> Undefined.
15:51:25 <byorgey> reltuk`: isn't Distribution.Simple.Build part of the Cabal library?
15:51:48 <Cale> @let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
15:51:48 <lambdabot> Defined.
15:51:55 <Cale> @let permute xs = (evalStateT . forM xs . const . StateT $ select) xs
15:51:55 <lambdabot> Defined.
15:52:01 <Cale> > permute [1,2,3]
15:52:01 <lambdabot>  [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
15:52:13 <byorgey> reltuk`: so if you really wanted to patch it (not sure why you'd want to do that though), you could create a patched version of the Cabal library
15:52:24 <byorgey> reltuk`: but... why do you want to patch it?
15:52:26 <tromp> :t forM
15:52:26 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
15:52:27 <Cale> So, uh, that works :)
15:52:53 <lispy> ?pl permute xs = (evalStateT . forM xs . const . StateT $ select) xs
15:52:53 <lambdabot> permute = flip (evalStateT .) select =<< (. (const . StateT)) . forM
15:53:05 <Cale> There's probably a better way...
15:53:14 <Cale> (to points-free that)
15:53:18 <lispy> yeah
15:53:22 <lispy> that was terrible :)
15:53:24 <tromp> :t evalStateT
15:53:25 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m a
15:54:49 <EvilTerran> ... i dunno, that looks pretty hard to me
15:55:12 * ddarius gets farther and farther behind on haskell-cafe
15:55:19 <EvilTerran> i'd end up using bind as well, i think.
15:55:27 <EvilTerran> or ap
15:55:39 <Cale> I'm thinking it'd be nicer with ap
15:56:10 <tromp> yes, but it's not of the form x z ( y z)
15:56:21 <Cale> Not directly.
15:56:28 <tromp> it's more like  x z z
15:56:39 <Cale> Maybe join?
15:56:42 <tromp> an ap with id is ugly:(
15:56:49 <reltuk`> byorgey: I need the Paths files it generates to be different....
15:57:04 <Cale> tromp: join
15:57:09 <tromp> :t join
15:57:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
15:57:23 <byorgey> reltuk`: for what purpose?
15:57:32 <reltuk`> byorgey: in particular, I need it to help me generate relocatable packages in a site-specific way
15:57:54 <tromp> dont see where join fits in
15:58:10 <EvilTerran> m = (e ->)
15:58:14 <byorgey> reltuk`: if I were you, I would get the latest darcs version of Cabal, and hack on that
15:58:16 <EvilTerran> > join f x :: Expr
15:58:16 <lambdabot>  f x x
15:58:32 <tromp> ah
15:58:36 <EvilTerran> ?type join :: (e -> e -> a) -> e -> a
15:58:37 <lambdabot> forall e a. (e -> e -> a) -> e -> a
15:58:45 <Cale> :t let permute = join (evalStateT . mapM (const . StateT $ select)) in permute
15:58:46 <lambdabot> forall t. [t] -> [[t]]
15:58:54 <tromp> @pl \l -> evalStateT . forM l . const . StateT $ select
15:58:54 <lambdabot> flip (evalStateT .) select . (. (const . StateT)) . forM
15:59:02 <tromp> ouch
15:59:20 <Cale> The @pl plugin sucks at this compared to a human :)
15:59:33 <reltuk`> byorgey: thanks =)
15:59:37 <EvilTerran> need some nice operators for (f .) . g and (. f) . g
15:59:43 <EvilTerran> <. and .>, perhaps?
15:59:44 <tromp> ah yes, mapM form better for that:)
15:59:58 <fxr> what a sin
15:59:58 <fxr> 01:59 *** You can't join #lisp because you're banned (+b)
16:00:03 <ddarius> EvilTerran: (.:) was already suggested for the former.
16:00:13 <EvilTerran> yeah, but you can't be so symmetrical with that
16:01:07 <shepheb> anyone point me to a reference for list monad desugaring?
16:01:07 <ddarius> EvilTerran: Just hack the compiler.
16:01:07 <tromp> :src join
16:01:14 <tromp> @src join
16:01:14 <lambdabot> join x =  x >>= id
16:01:36 <Botje> shepheb: what do you mean?
16:01:52 <shepheb> list comprehension desugaring, I should say.
16:02:14 <Botje> well, a list comprehension is a lot like a do block
16:02:36 <fxr> @tell MarcWeber http://hpaste.org/6918
16:02:36 <lambdabot> Consider it noted.
16:03:10 <Botje> [ (x, y, f x) | x <- xs, y <- ys, x + y < 3 ] ~> do { x <- xs; y <- ys; guard $ x + y < 3; return (x, y, f x) }
16:04:29 <tromp> what binds tighter in f $ g . h ?
16:04:43 <ddarius> .
16:04:54 <tromp> ok
16:05:04 <byorgey> tromp: $ has precedence 0, which is lower than (almost) everything else.
16:05:16 <gwern> http://hackage.haskell.org/trac/hackage/ticket/265 <-- comments on how 'stability:' in cabal files should work?
16:05:19 <atsampson> this being an application of the $-means-brackets-from-here-to-the-end-of-the-expression rule of thumb, presumably
16:05:20 <lambdabot> Title: #265 (Cabal field stability not useful) - Hackage - Trac
16:05:21 <ddarius> > (f $ f $)
16:05:22 <lambdabot>      The operator `$' [infixr 0] of a section
16:05:22 <lambdabot>         must have lower precede...
16:05:38 <byorgey> atsampson: essentially, yes
16:06:45 <tromp> now we can obfuscate it some more by using return instead of const
16:06:58 <tromp> @let permute = join $ evalStateT . mapM (return . StateT $ select)
16:06:58 <lambdabot> <local>:2:0:     Equations for `permute' have different numbers of arguments ...
16:09:08 <tromp> @pl return . StateT $ select
16:09:08 <lambdabot> return (StateT select)
16:16:27 <catface> wow = do { label "start"; x <- iget; iprint x; goto "start" }
16:16:27 <catface> wow1 = label "start" >> iget >>= \x -> iprint x >> goto "start"
16:16:37 <catface> these should be equivalent shouldn't they?
16:17:00 <Cale> catface: yeah, as far as I can see
16:17:20 <Cale> catface: are they somehow behaving differently?
16:17:30 <catface> yes
16:17:35 <Cale> Maybe the instance of Monad is broken?
16:17:47 <catface> could be, i wrote it
16:18:18 <Cale> For things to make sense, you have to satisfy the monad laws.
16:18:21 <catface> maybe i should check the monad laws hold
16:18:25 <Cale> yeah
16:18:55 <atsampson> isn't the do form just sugar for the second form, though? or is it more subtle than that?
16:20:08 <Cale> It might be slightly different...
16:20:24 <Cale> The desugaring is just a little more subtle
16:20:54 <Cale> I wouldn't expect them to be any different, but who knows.
16:21:44 <Cale> If you fail to satisfy the monad laws, then strange things can happen
16:28:55 * dolio returns triumphantly.
16:56:15 <pjd> catface: there could be a difference with pattern matching / fail?
16:57:11 <Saizan> ?undo  do { label "start"; x <- iget; iprint x; goto  "start" }
16:57:11 <lambdabot> label "start" >> iget >>= \ x -> iprint x >> goto "start"
16:57:52 <Botje> @pl \x -> iprint x >> got o"start"
16:57:52 <lambdabot> (>> got o "start") . iprint
16:57:57 <Botje> @pl \x -> iprint x >> goto "start"
16:57:58 <lambdabot> (>> goto "start") . iprint
16:58:04 <Botje> right. I knew that.
16:58:05 <EvilTerran> ?. pl undo do { label "start"; x <- iget; iprint x; goto  "start" }
16:58:05 <lambdabot> label "start" >> iget >>= (>> goto "start") . iprint
17:01:55 <pjd> sorry, fail would come in when the "x <-" matches a constructor
17:07:58 <zooko> Hello people of #haskell.  I just tried to build darcs-2.0.0 on Ubuntu Dapper and I get: src/Darcs/Commands/Send.lhs:24:58:
17:07:58 <zooko>     Module `Control.Monad' does not export `forM_'
17:08:53 <shachaf> zooko: Which version of GHC is this?
17:09:14 <shachaf> zooko: You need at least 6.6, I think.
17:09:19 <mib_cn4pay> if the dll file is placed within the bin directory, will ghc still search for it in system32 dir?
17:09:36 <mib_cn4pay> my school doesn't allow copying to system32
17:10:04 <mib_cn4pay> trying to work around by placing the file in the main dir, can it work?
17:10:27 <Saizan> mib_cn4pay: .dll needs to be in one directory mentioned in %Path% , iirc
17:11:49 <shachaf> Doesn't it look in . also (or is that in $PATH already? I'm not sure about Windows)?
17:12:04 <Botje> mib_cn4pay: by default w*nd*ws looks for DLLs in the same directory as the .exe file
17:13:06 <mib_cn4pay> so where do i go to edit the path for the dll
17:13:28 <zooko> shachaf: 6.4.1
17:13:40 <zooko> I thought darcs required ghc >= 6.4...
17:14:20 <shachaf> zooko: It's probably simplest to upgrade GHC.
17:14:30 <shachaf> (I don't think you can just upgrade base?)
17:15:33 <shachaf> mib_cn4pay: Either set $PATH (%Path%) or put the .dll in the .exe's dir, I guess.
17:16:18 <zooko> I'm building on Ubuntu Dapper -- there is no simple way to upgrade ghc without annoying the other admins.
17:16:50 <zooko> This says that ghc 6.4 is sufficient: http://darcs.net/manual/node3.html
17:16:50 <lambdabot> Title: Building darcs
17:16:57 <zooko> But apparently that page should be updated!
17:17:34 <Saizan> zooko: maybe you should report this as a bug
17:18:05 <sm> 6.4 is pretty old.. I am pretty used to building a newer ghc in order to build anything modern with it
17:18:13 <Saizan> zooko: the fast solution can be substituting forM_ with (flip mapM_) in the code
17:18:32 <lament> was the manual updated for darcs 2.0?
17:18:34 <zooko> Saizan: thanks.  :-)
17:18:42 <zooko> Saizan: I am reporting it.
17:20:55 <zooko> Saizan: thanks!  Your patch made the build proceed.
17:22:10 <Saizan> no wonder :) that's the definition of forM_ :)
17:22:30 <zooko> Hooray!  Now I get to submit a patch to darcs!  ;-)
17:23:05 <shachaf> zooko: You could also define forM_ somewhere in the source.
17:23:22 <zooko> shachaf: that would be better.
17:23:38 <Saizan> that gets annoying when you compile with ghc >= 6.6
17:23:40 <shachaf> zooko: (Or use something like "(`mapM_` list) function").
17:23:47 <shachaf> Saizan: Why?
17:23:53 <shachaf> Saizan: forM_ isn't imported.
17:24:10 <shachaf> (I'm assuming the functions to import are named explicitly.)
17:24:47 <Saizan> (that's probably not the case, since i've built darcs2.0 yesterday and there was no forM_ not in scope error :)
17:25:16 <shachaf> Saizan: I'm assuming it says "import Control.Monad (..., forM_)".
17:25:25 <zooko> It does.
17:25:39 <shachaf> Saizan: So if zooko is taking the forM_ out of the import and defining it explicitly, it should work with 6.6.
17:25:40 <Saizan> yeah, you can just remove it from there
17:31:07 <zooko> What's the type of forM_?
17:31:12 <Cale> :t forM_
17:31:13 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
17:31:27 <Cale> It's the same as flip mapM_
17:31:47 <zooko> Thanks!
17:31:58 <Cale> (but be careful if you write  forM_ = flip mapM_, because you'll get bitten by the monomorphism restriction!)
17:32:35 <Cale> So either supply an explicit type signature, or write forM_ xs f = mapM_ f xs
17:33:23 <yitz_> Cale: echo :set -fnomonomorphism-restriction >> ~/.ghci
17:33:26 * zooko wonders what the monomorphism restriction is and if it just bit him, as he replaced his patch with Cale's suggestion.
17:33:38 <Cale> yitz_: Yeah, I have that, but not everyone does :)
17:33:45 <yitz_> Cale: echo :set -fno-monomorphism-restriction >> ~/.ghci
17:33:53 <zooko> src/Darcs/Commands/Send.lhs:113:0:
17:33:53 <zooko>     Warning: Definition but no type signature for `forM_'
17:34:33 <Cale> zooko: That's not the MR, but it's possible that the MR is taking effect anyway, if you wrote forM_ = flip mapM_
17:34:54 <zooko> Adding forM_ :: forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
17:34:57 <zooko> results in
17:35:02 <zooko> src/Darcs/Commands/Send.lhs:113:24: parse error on input `*'
17:35:06 <Cale> oh, remove that forall junk :)
17:35:11 <Cale> forM_ :: (Monad m) => [a] -> (a -> m b) -> m ()
17:35:16 * zooko removes the forall junk.
17:35:36 <Cale> (That's just explicitly quantified type variables -- it's an extension)
17:35:39 <zooko> Cale: thakns!
17:35:43 <zooko> It is building again.
17:36:04 <Cale> zooko: The monomorphism restriction says that pattern bound variables who don't have explicit type signatures must be monomorphic.
17:36:15 <glguy> It's for your own good!
17:36:19 <Cale> (as opposed to polymorphic)
17:36:23 <Cale> glguy: No it isn't!
17:36:44 <Cale> It creates random strange type errors in programs which should otherwise work!
17:36:45 * yitz_ never believes anyone who says it's for his own good
17:36:52 <Saizan> well, it only applies to typeclass-polymorphic ones
17:37:38 <glguy> yitz_: then change your .ghci
17:38:09 <yitz_> i did
17:38:31 <Cale> The reason for the MR is that typeclass polymorphic values are actually functions of the typeclass dictionary, and so will be recomputed each time, which some people find counterintuitive.
17:38:41 <glguy> I don't think that it's terrible that you have to opt into no-mr
17:38:44 <Cale> (and so it can affect performance)
17:38:48 <Cale> I do.
17:38:48 <glguy> you should know what it is and choose to not care
17:38:56 <Cale> I think the MR should be *at most* a warning.
17:39:16 <Cale> It also has no place in the Haskell report.
17:39:22 <glguy> yeah , but you also think that the teaching bot should have non-standard prelude functions.. :-p
17:39:50 <Cale> Even though it can be described in terms of the semantics alone, the only reasoning which can be provided for it relies on a particular implementation of the language.
17:40:08 <Cale> Nothing else in the Report relies on the particulars of any implementation in the way that the MR does.
17:40:14 <glguy> well, I wouldn't be upset if it was changed to a warning
17:40:31 <glguy> I can agree there
17:42:41 <byorgey> Cale: btw, what do you think of my idea of adding a second evaluation mode to \bot (say, prefix with >>) which uses the standard libraries, with no special extensions?
17:42:46 <byorgey> how difficult would that be to do?
17:42:50 <Cale> byorgey: I think it's a good idea :)
17:43:11 <Cale> byorgey: You should certainly send me a patch if you do it :)
17:43:36 <Cale> It's more work than it should be the way that things currently are though.
17:43:49 <Cale> I was hoping that I could just use preprocessor directives to do it
17:44:03 <glguy> it would be much easier to run a separate bot, I'd imagine, that responded to >> instead of >
17:44:05 <byorgey> well, I'll try taking a look
17:44:09 <Cale> But it seems that L.hs only gets recompiled some of the time, and I haven't put in the time to work out when that is.
17:44:50 <shepheb> still pondering a Haskell blog name. "brain crater" came to mind.
17:44:57 <byorgey> hehe
17:45:35 <byorgey> or just "brain asplosion"
17:45:43 <pjd> brane
17:46:01 <Cale> pjd: That'll make people think it's about physics though
17:46:11 <byorgey> I was just about to say that =)
17:46:20 <jaj> shepheb: did you write the blog software in haskell?
17:46:21 <glguy> maybe write a physics blog instead
17:46:24 <glguy> so you can keep the name
17:46:49 <catface> can you define >>= in terms of >>?
17:46:57 <glguy> no
17:47:03 <Cale> catface: no
17:47:04 <pjd> Cale: a happy accident
17:47:26 <pjd> Cale: neurokinetics is arguably physics
17:47:33 <glguy> let a >>= f = a >> f undefined
17:47:40 <omg911> struggling to find space leak in app... is there any automated tools to help for haskell?
17:47:55 <Cale> omg911: There's the profiling tools built into ghc
17:47:56 <TomMD> Use the profiler
17:47:56 <shepheb> jaj: no, not blog software. a name for my blog.
17:48:25 <Cale> omg911: Is the program small enough that it can be put in an hpaste?
17:48:26 <shepheb> "Brain Crater: Thoughts from my splattered grey matter"
17:48:33 <omg911> Cale: even when it crashes
17:48:47 <Cale> omg911: Hm?
17:48:48 <omg911> Cale: it's about 200 lines
17:49:13 <TomMD> omg911: "Crash" or "Exit with an exception"?
17:49:23 <Cale> omg911: Go for it, though you might want to break it into two parts (and use an annotation for the second), as hpaste likes to cut stuff off
17:49:37 <Cale> omg911: I'll have a look and see if I see anything obvious
17:49:48 <omg911> TomMD: errors like: Stack space overflow: current size 8388608 bytes.
17:50:15 <TomMD> Impressive
17:50:23 <Cale> Oh, that's not a space leak
17:50:42 <Cale> That's unevaluated expressions being built which are very large.
17:50:54 <Cale> (and so evaluation causes a stack overflow)
17:51:00 <Cale> It's usually caused by tail recursion
17:51:12 <hpaste>  atp pasted "can any windows ffi gurus tell me why this doesn't launch a process?" at http://hpaste.org/6921
17:51:15 <omg911> Cale: i thought haskell optimize those
17:52:04 <Cale> GHC does optimise tail recursion, but you'll often end up with a tight loop that does nothing but build a gigantic expression.
17:52:04 <omg911> so is there a way to trace it down to the problemic function?
17:52:11 <Cale> Let me give an example.
17:52:17 <Cale> We have:
17:52:21 <Cale> foldl f z [] = z
17:52:31 <Cale> foldl f z (x:xs) = foldl f (f z x) xs
17:52:38 <hpaste>  catface pasted "imperative goto monad" at http://hpaste.org/6922
17:52:39 <Cale> This is clearly tail recursive
17:52:50 <Cale> Now let's evaluate foldl (+) 0 [1,2,3]
17:52:53 <Cale> We get:
17:52:57 <Cale> foldl (+) 0 [1,2,3]
17:53:04 <Cale> -> foldl (+) (0+1) [2,3]
17:53:09 <Cale> -> foldl (+) ((0+1)+2) [3]
17:53:16 <Cale> -> foldl (+) (((0+1)+2)+3) []
17:53:22 <Cale> -> ((0+1)+2)+3
17:53:33 <zooko> http://allmydata.org/trac/darcs-2/browser/src/Darcs/Commands/Send.lhs
17:53:36 <lambdabot> Title: /src/Darcs/Commands/Send.lhs  darcs-2 (demo trac instance)  Trac, http://tinyurl.com/5mz595
17:53:41 <Cale> and this is where the stack overflow happens if you had a very long list
17:53:51 <omg911> ok i see
17:54:10 <omg911> would making the constructor strict be of any help?
17:54:16 <Cale> Yeah, it would.
17:54:26 <Cale> If we also make the foldl strict
17:54:35 <Cale> There's a strict foldl in Data.List called foldl'
17:54:54 <Cale> which simply forces the evaluation of the accumulating parameter before recursing
17:55:07 <omg911> yeah i'll try those and see if it improves
17:55:20 <Cale> Does that fit into the picture of your program?
17:55:48 <omg911> yes i do plenty of folds especially on Seq data type
17:56:10 <omg911> i have most of the constructor strict but wasn't sure how much it helped
17:56:37 <Cale> Sometimes you can fix the problem by being lazier as well.
17:57:08 <Cale> For example, if instead of tail recursing, you can immediately return a data constructor applied to some parameters, that's even better.
17:57:27 <Cale> (where those parameters might include a recursive call)
17:57:51 <Cale> That's because it makes the start of the result immediately available.
17:58:24 <Cale> And if the component of the data in which that recursive call resides is never pattern matched against, the recursion will end there.
17:59:44 <omg911> i don't get that part, if you return a constructor won't you be killing the recursive loop
17:59:56 <Cale> Well, consider something like:
17:59:59 <Cale> map f [] = []
18:00:07 <Cale> map f (x:xs) = f x : map f xs
18:00:42 <Cale> That's recursive in the second case, but it returns a constructor (:) applied to the expressions f x and map f xs
18:01:07 <omg911> okk
18:01:11 <Cale> If you only ever end up needing the first element of the list, the recursive call to map f xs will never be computed.
18:01:52 <tromp> are there any channels for tax discussions:-?
18:02:04 <Cale> I think another thing which possibly helps is that the stack in GHC doesn't measure what it typically does in imperative languages. What it measures is the depth from the place where you're evaluating to the first reducible expression.
18:02:39 <Cale> So for instance, if you evaluate the expression (((1 + 2) + 3) + 4) + 5
18:02:56 <Cale> (1 + 2) is the shallowest reducible expression in that
18:03:15 <omg911> so everything will be on the stack before?
18:03:27 <Cale> yeah, the bits which add 3, 4, and 5 go on the stack.
18:04:02 <Cale> and of course this only happens when the expression as a whole needs to be evaluated
18:04:40 <Cale> Of course, I'm talking about Integers here, which are strict.
18:05:28 <Cale> If you had some lazy numeric type, well, you might be able to reduce that almost immediately
18:05:44 <Cale> (i.e. the outermost (+) might be able to do some work)
18:06:12 <Cale> (depending on how it was defined)
18:06:56 <omg911> hmmm definitely got a boost from that but it wasn't enough
18:07:17 <omg911> i got from about 50 to 100 generations extra
18:07:47 <Cale> Let's have a look
18:07:57 <omg911> ok
18:08:21 <Cale> Probably the first thing I'll suggest is to try profiling :)
18:08:41 <Cale> But I'd like to see the code, and see if I can spot anything right away
18:09:11 <byorgey> tromp: #haskell-blah ?  =)
18:10:01 <hpaste>  omg911 pasted "ga" at http://hpaste.org/6923
18:11:20 <byorgey> ooooh, genetic algorithms =)
18:12:50 <omg911> hmmm like 40% got chopped off
18:13:39 <Cale> omg911: Just add an annotation
18:14:11 <Cale> You don't care for do-notation do you? :)
18:14:57 <hpaste>  (anonymous) annotated "ga" with "(no title)" at http://hpaste.org/6923#a1
18:15:31 <omg911> nah i started off with >>= so i didn't wanna go back and forth
18:15:35 <Cale> uh, you'll want to delete the start of the file in the annotation :)
18:15:58 <Cale> (It's a size restriction)
18:16:45 <hpaste>  (anonymous) annotated "ga" with "(no title)" at http://hpaste.org/6923#a2
18:17:29 <omg911> should be ok now
18:17:46 <fanw> Quick question: is there a way to write code with GHC interactive interpret like I can do with python?
18:18:08 <Cale> fanw: You never put declarations into ghci, they always go into a file
18:18:23 <Cale> fanw: However, you can use let to temporarily define things
18:18:28 <Cale> let foo = bar
18:18:43 <Cale> on the ghci commandline should work, and define foo to be the same as bar
18:18:55 <fanw> how about other interpreters like hugs?
18:19:06 <Cale> hugs doesn't even have the 'let' thing
18:19:15 <fanw> ok
18:19:20 <fanw> thanks Cale
18:19:23 <fanw> Cale++
18:19:33 <Cale> I always keep two windows open -- one with my editor and one with ghci
18:19:38 <Cale> and :r will reload
18:19:54 <Cale> So it's only a few keystrokes to commit the changes you made
18:20:01 <fanw> that's what i'm doing now :-)
18:20:10 <Cale> omg911: Okay, I'll have a look...
18:20:34 <omg911> Cale: thanks hope it's not too much
18:21:06 <Cale> omg911: hmm... modNode looks like it got cut off, and isn't in the annotation
18:21:47 <Cale> omg911: It's a lot of code, but we'll see what the profiler comes up with
18:23:31 <hpaste>  (anonymous) annotated "ga" with "(no title)" at http://hpaste.org/6923#a3
18:24:32 <Cale> hmmm...
18:24:41 <Cale> Now I've got some type errors...
18:24:42 <omg911> it compiles?
18:25:15 <hpaste>  Cale annotated "ga" with "errors." at http://hpaste.org/6923#a4
18:26:48 <atp> so, is anyone here good with ffi and win32?  i've got more of a unix background and i've never played much with ffi before, and i'm having some trouble with a piece of code
18:27:00 <Cale> atp: I'm okay with FFI, but not Win32.
18:27:12 <atp> yeah... i figured the combo would be a hard sell
18:27:24 <Cale> Maybe sjanssen?
18:27:36 <atp> @seen sjanssen
18:27:36 <lambdabot> sjanssen is in #xmonad, #haskell-soc, #haskell-overflow and #haskell. I last heard sjanssen speak 4h 18m 42s ago.
18:27:36 <Cale> I seem to recall that he uses windows at least some of the time :)
18:27:42 <Cale> Or ndm would be good.
18:27:43 <atp> hm
18:27:52 <Cale> atp: What's the problem?
18:27:53 <atp> i never had to use windows until relatively recently... job
18:28:19 <LordBrain> Hello haskellers
18:28:20 <atp> basically i'm writing a small server for work that runs tasks
18:28:28 <Cale> Hello LordBrain
18:28:36 <atp> basically, it listens on the network and when it gets an instruction it runs a program that does some stuff.
18:28:53 <Cale> atp: That shouldn't require FFI, should it?
18:29:07 <atp> anyway, runProcess in System.Processes is imported unsafe, presumably for efficiency reasons, so that means Concurrent haskell doesn't like it
18:29:18 <Cale> hmm
18:29:28 <atp> an annoyingly large amount of stuff is imported unsafe
18:29:53 <LordBrain> I have ghc 6.6 on a windows machine, and I am going to upgrade, should i uninstall it first, or will the binary from http://haskell.org/ghc/download_ghc_682.html#windows be smart enough to handle upgrading from 6.6  to 6.8.2 ?
18:30:17 <omg911> Cale: it compiles on mine... i think it's the pasting screwed up a symbol
18:30:34 <Cale> omg911: mm, yeah, that's likely
18:30:44 <omg911> Cale: pls change line 152. switch 0.75 ? i >>=
18:30:47 <atp> anyway, the unix way of creating a process involves fork followed by exec, which of course doesn't play well with haskell threads, but on windows you can create a process without a fork
18:31:02 <omg911> Cale: to ff
18:31:13 <omg911> Cale: i mean switch 0.75 ff i >>=
18:31:14 <atp> using the CreateProcess() API (or so I understand)... so i'm trying to write an ffi wrapper for it that i can call from my network server
18:31:28 <atp> but i don't actually know enough about win32 or ffi to make it work :(
18:31:34 <omg911> Cale: and 2 lines down in the where clause as well
18:31:43 <atp> anyway, the paste is http://hpaste.org/6921
18:31:51 <Cale> atp: I thought the unsafe just meant that the FFI call mustn't trigger a callback into the Haskell code.
18:31:52 <atp> if you'd like to take a look and see if anything jumps out
18:32:15 <omg911> Cale: where ff i = randomPick pop >>= \...
18:32:23 <atp> right, that's what i understand as well.  but in the ghc faq, it says that unsafe FFI calls will always block
18:32:24 <Cale> omg911: aha
18:32:36 <atp> or does that mean only blocking ffi calls will block all threads?
18:33:08 <atp> i guess that would make more sense...
18:33:08 <omg911> Cale: i think in your error output the character was completely removed
18:33:30 <Saizan> LordBrain: deleting the installation directory first won't hurt i suppose
18:33:47 <Cale> omg911: Yeah, I misinterpreted the questionmark symbols :)
18:33:59 <Cale> okay, so what args should I run it with?
18:34:17 <omg911> Cale: try ./ga 50 10
18:34:26 <omg911> Cale: then up to  ./ga 200 100
18:35:38 <omg911> Cale: the first one should finish pretty fast
18:35:51 <omg911> Cale: the second will probably crash
18:36:28 <Cale> yep
18:37:00 <Cale> I'm going to try the new debugger. So I have :set -fbreak-on-exception
18:37:05 <Cale> and :set args 200 100
18:37:13 <omg911> ok
18:37:17 <Cale> and I've got a stack overflow now...
18:37:28 <Cale> oh, oops
18:37:34 <Cale> forgot to :trace
18:37:50 <Cale> :trace main
18:38:34 <zooko> Greetings again!  What is the type of forM_ again?
18:38:39 <Cale> :t forM_
18:38:40 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
18:38:44 <Cale> :t forM
18:38:45 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
18:38:49 <zooko> Thanks.
18:38:55 <Cale> zooko: It's like a foreach loop
18:39:17 <Cale> zooko: It takes a list of elements, and a function from those elements to actions to be performed, and constructs an action which does them all.
18:39:35 <Cale> If you think about it, a loop body is just a function from the index variable to something to be done
18:39:49 <Cale> ... still waiting for this to die :)
18:39:57 <omg911> oki got stack overflow too... _exception :: e = GHC.IOBase.AsyncException GHC.IOBase.StackOverflow
18:40:05 <Cale> Things run a good bit slower in the debugger.
18:40:10 <zooko> Hm.
18:40:13 <zooko> Thanks for the explanation.
18:40:19 <Cale> zooko: No problem :)
18:40:40 <Cale> zooko: try something like   forM_ [1,2,3,4,5] $ \x -> print x
18:40:58 <zooko> This doesn't work in darcs-2: forM_ :: (Monad m) => [a] -> (a -> m b) -> m [b]
18:40:58 <zooko> forM_ = (flip mapM_)
18:41:16 <Cale> It should be  m ()  at the end
18:41:25 <Cale> The _ means you're throwing away the results.
18:41:34 <zooko> Oh, thanks.  I don't have a _.
18:41:39 <zooko> Oh, in the name.
18:41:42 <zooko> Okay.
18:42:22 <Cale> omg911: You must have a faster machine than I do :)
18:42:28 <zooko> Hm, but doesn't it need to apply the m to [b] ?
18:42:50 <zooko> Oh, I think I see.
18:43:10 <Cale> forM will produce an action which returns a list of the results when run
18:43:17 <zooko> I see.
18:43:21 <Cale> forM_ throws away the results and just gives ()
18:43:31 <zooko> Ok.  Thanks.
18:43:45 <Cale> omg911: what do you get when you type :list ?
18:43:53 <omg911> Cale: it crash pretty fast on mines though... i'm on +2200 AMD but only 512 ram
18:43:58 <Cale> (and if that doesn't work, maybe try :back first)
18:44:13 <omg911> unable to list source for <exception thrown>
18:44:22 <Cale> Okay, can you :back?
18:44:38 <omg911> no more logged breakpoints
18:44:41 <Cale> hmm
18:44:47 <Cale> How did you run it?
18:44:51 <Cale> :trace main
18:44:52 <Cale> ?
18:44:56 <omg911> main
18:45:03 <Cale> oh, that'd be why :)
18:45:10 <Cale> (It's also why it's so fast :)
18:45:12 <omg911> lmao oh i've been doing it wrong
18:45:27 <Cale> oh, I'm swapping now...
18:45:57 <Cale> Maybe I'll just kill it here, and see where we are :)
18:46:53 <Cale> too crunchy :)
18:47:01 <Cale> must.. .kill...
18:47:26 <Cale> okay, let's maybe try that again with a bit smaller problem
18:47:26 <Saizan> or rerun ghci with reduced stack/heap size
18:47:35 <hpaste>  (anonymous) annotated "ga" with "(no title)" at http://hpaste.org/6923#a5
18:48:14 <omg911> mines always seem to crash fast
18:48:25 <omg911> check my log
18:48:29 <Cale> hmmmm...
18:48:45 <hpaste>  LordBrain pasted "Invalid type signature?" at http://hpaste.org/6924
18:50:18 <LordBrain> What's wrong with the foriegn export here?
18:50:42 <Cale> LordBrain: try adding a string version of the name you're exporting just before the my_func
18:50:45 <Cale> So...
18:50:52 <Cale> foreign export ccall "my_func" my_func :: Int -> Int
18:50:57 * heatsink doesn't get a compiler error
18:52:01 <LordBrain> I copied the example from the ghc  user guide "9.2.1. Using foreign export and foreign import ccall "wrapper" with GHC"
18:52:10 <LordBrain> is there example just wrong?
18:52:18 <Cale> LordBrain: yeah, honestly I think the example should work
18:52:21 <LordBrain> they used foo
18:52:27 <LordBrain> i said my_func
18:52:35 <LordBrain> oh maybe the underscore
18:52:40 <LordBrain> hmmm
18:52:45 <heatsink> It doesn't cause an error with 6.6.
18:53:03 <Cale> oh!
18:53:10 <Cale> You're not compiling with FFI turned on.
18:53:35 <LordBrain> oh
18:53:52 <Cale> The simplest way to fix that is to add:
18:53:56 <Cale> {-# LANGUAGE ForeignFunctionInterface #-}
18:54:00 <Cale> To the top of your file
18:54:34 <Cale> Or you could add -fffi or -XForeignFunctionInterface to your GHC commandline.
18:54:58 <LordBrain> hmmm
18:55:03 <LordBrain> i see
18:55:25 <Cale> omg911: out of interest, which version of GHC
18:55:29 <Cale> are you using?
18:57:21 <omg911> Cale: i actually got 2 installed now, 6.6 (no debugger) and 6.8.2
18:57:27 <Cale> okay
18:58:12 <shepheb> is there a ballpark release projection for 6.10? a month? six? two years?
18:58:20 <Saizan> maybe ghci is loading the compiled code so it doesn't have breakpoints?
18:58:47 <Cale> shepheb: I think the releases are usually about 6 months apart
18:59:19 <slowriot> Does anyone here know of any purely functional implementation of a scanline algorithm?
18:59:25 <Cale> So this summer, sometime, most likely.
18:59:37 <sjanssen> shepheb: to put this in perspective, 6.8 came out around Oct 2007, and 6.6 was late summer 2006
18:59:46 <LordBrain> ok, i'm not getting __stginit_Hlib in my Hlib_stub.h file .... why  not?
19:01:04 <omg911> the profiler is telling me over 76% of alloc is being done in evalutate though
19:01:11 <Cale> omg911: okay
19:01:32 <Cale> omg911: Also, uh, when you were running the GHCi debugger, did you see something like:
19:01:40 <Cale> [1 of 1] Compiling Main             ( ga.hs, interpreted )
19:02:09 <Cale> Or did it say that it was loading the code from an object file (which would explain why trace was broken)
19:03:00 <omg911> mmm no i loaded it once and got: Ok, modules loaded: Main.
19:03:16 <Cale> mm, it might have just been loading the compiled code
19:03:28 <LordBrain> i'm just trying to get a handle on how to make a library in haskell that i can use in c/c++
19:03:32 <Cale> For the debugger to work properly, it has to be interpreted.
19:03:46 <fons> Hi all
19:03:54 <Cale> hello
19:04:18 <omg911> ok i retried it... it did in fact compile it
19:04:20 <LordBrain> so far,  i have basically two source files, hlib_main.c and Hlib.hs
19:04:44 <omg911> is there a way to disable that?
19:05:02 <LordBrain> I'll post hlib_main.c
19:05:03 <fons> I'm pretty sure my question might be a bit weird but is there a way to treat tuples systematically? (i.e. apply fst snd ... regardless of their size)
19:05:25 <sjanssen> fons: nothing built-in, no
19:05:30 <Cale> fons: There's pattern matching
19:05:32 <TomMD> "To keep the book small enough to be covered in a one-semester advanced course - and light enough to be lifted by the average graduate student..."
19:05:34 <TomMD> I like this book
19:05:42 <Cale> fons: case foo of (x,y,z) -> z
19:05:43 <fons> :(
19:05:51 <Cale> fons: Large tuples should be avoided though
19:06:01 <fons> I guess I'm condemned to use template haskell
19:06:05 <Cale> fons: If you have more than 2 or 3 fields, probably a good idea to name them.
19:06:05 <fons> Cale: why?
19:06:07 <sjanssen> fons: of course you can use class overloading to write your own
19:06:17 <Cale> fons: You should define your own datatype.
19:06:34 <fons> Cale: well, I have good reasons for doing that
19:06:45 <sjanssen> fons: class Fst t a | t -> a where fst :: t -> a; instance Fst (a, b) a where fst (a, _) = a; ...
19:06:50 <Cale> Is it nothing more than an 8-dimensional vector?
19:06:51 <fons> I'm writing and embedded DSL which models systems
19:06:52 <SamB> fons: how about an HList?
19:07:15 <fons> the output of the system is always a tuple
19:07:34 <fons> SamB: yep, that wuld be an option
19:07:37 <fons> would
19:07:48 <Cale> fons: Are the components of the tuple all the same type?
19:07:50 <hpaste>  LordBrain pasted "hlib_main.c" at http://hpaste.org/6925
19:08:10 <Cale> fons: Perhaps an Array would be more appropriate in that case, or even a list.
19:08:59 <fons> Cale: not quite: for example (Signal Int, Signal Bool, Signal Int) is a possible output
19:09:01 <Cale> If you have a tuple of various things of different types, it's extremely confusing not to define a record type.
19:09:07 <fons> which is not expressable with an array
19:09:15 <Cale> Why not say:
19:09:32 <LordBrain> hlib_main.c:20: error: `__stginit_Hlib' undeclared (first use in this function)
19:09:51 <Cale> data Foo = Foo { fooX :: Signal Int, fooValid :: Signal Bool, fooZ :: Signal Int }
19:09:55 <LordBrain> when i read the manual, i thought this function would be put in for me automatically
19:10:44 <fons> Cale: now tell me how to make an embedded compiler support custom types and I'll apply your idea ;)
19:10:48 <heatsink> fons: What's the interface?  In what ways does the DSL access fields?
19:11:24 <fons> heatsink: the idea is to compile systems
19:11:33 <Cale> fons: are there only a finite number of possible types for signals?
19:11:56 <Cale> fons: It's important to remember that the Haskell type system is a compile-time apparatus only.
19:12:21 <Cale> So types really only have to do with what's going on when you compile your Haskell program, and nothing to do with what comes after.
19:12:48 <Cale> So you should know statically what the types of things are and be able to account for it.
19:13:02 <fons> Cale: I think you're missing the point, probably because I'm not explaining it properly
19:13:10 <heatsink> fons: If  we know more about what you want to do with this generic-size tuple type, we may be able to suggest another way to do it.
19:13:41 <fons> a system is a function which takes n signals (possibly zero) processes them and outputs m signals (possibly zero)
19:14:30 <glguy> what determines the type of the output signals?
19:14:33 <fons> the DSL is deep embedded using a Signal type which stores the structure of the system
19:15:26 <fons> it works similarly to Lava
19:15:47 <fons> glguy: Typeable a => Signal a
19:16:00 <awesame> here's something that's impossible to google for: what does "in" mean in haskell?
19:16:04 <Cale> ah, Typeable
19:16:14 <Cale> awesame: It's part of the syntax of let expressions
19:16:15 <fons> glguy: as long as the contained type is typeable there is no problem
19:16:18 <ddarius> awesame: Nothing.
19:16:21 <awesame> oh, duh
19:16:22 <Cale> awesame: let <decls> in <expr>
19:16:37 <Cale> > let x = 5; y = 7 in x^2 + y^2
19:16:38 <lambdabot>  74
19:17:10 <Cale> I'm beginning to hate Typeable.
19:17:16 <glguy> fons: I was asking how the input to your function related to the output of your system
19:17:53 <fons> write now I check systems with TH to satisfy, system :: Signal i1 -> Signal i2 ...... -> (Signal o1, SIgnal o2, ......)
19:17:57 <Cale> But okay, let's go down this path...
19:18:14 <fons> in and om are guaranteed to be typeable by construction (Signal is an ADT)
19:18:28 <fons> so it doesn't really matter
19:19:12 <Cale> fons: I still don't understand why it must be a tuple.
19:19:25 <ddarius> Cale: Even a whiff of dynamic typing is sinful
19:19:28 <fons> and although Signal a is differnent to SIgnal b, in practice the type parameter is phatom
19:19:36 <fons> to ensure type consistenci
19:19:48 <awesame> hey, at some point I started using let expressions sans-in-clause in do expressions in the IO monad
19:20:10 <awesame> and for some reason it worked
19:20:10 <fons> Cale: it doesn't need to be a tuple, that's how I'm modelling it now
19:20:10 <Cale> awesame: right, that's a different let
19:20:11 <ddarius> @undo do let { x = 3 }; return x
19:20:11 <lambdabot> let { x = 3} in return x
19:20:14 <Cale> awesame: there's a let which is part of the do-syntax
19:20:28 <awesame> I see
19:20:31 <fons> Cale: but, whatever it is, it must accept being treated systematically (i.e. a typeclass constraint or treatable with TH)
19:20:35 <awesame> handy, if confusing
19:21:17 <fons> Cale: a custom type (as far as I now) cannto be treated systematically
19:21:18 <Cale> awesame: It's essential if you want to make a declaration based on a bunch of things which were bound by <- earlier in the do-block
19:21:24 <pjd> typo in the new Monad.Reader: "looses laziness"
19:21:25 <fons> cannot*
19:21:28 <Cale> awesame: well, almost essential :)
19:21:33 <pjd> anyone around who can fix it?
19:21:34 <heatsink> Systematically?
19:21:48 <Cale> fons: What do you mean by "treated systematically"?
19:21:49 <omg911> awesame: took be a while to figure out the let in do doesn't require a "in"
19:22:07 <Cale> fons: Do you mean 'has an instance of Data'?
19:22:25 <Cale> fons: Those can be derived by GHC
19:22:30 <Cale> (along with Typeable)
19:22:55 <awesame> I had been doing foo <- return (expr)
19:23:09 <fons> Cale: not necessarily, I mean that you need to be able to put it in a list basically (whcih is possible because the type parameter of the signal is phantom)
19:23:12 <awesame> and then switched to let foo = expr at some point perhaps without realizing it
19:23:40 <ddarius> foo <- return E wouldn't let you do a recursive binding (which is a double-edged sword)
19:23:46 <Cale> fons: Are the phantom type parameters really necessary?
19:23:52 <fons> Cale: yes
19:24:08 <fons> Cale: to keep type coherence
19:24:48 <Cale> Well, you could always toDyn them all
19:25:11 <heatsink> fons: As I understand it, you're building a data structure and you want to use the type checker to statically check that signals have the right types in the right places.
19:25:25 <fons> Cale: not needed, again the type parameter is phantom
19:25:35 <heatsink> where the signals are really just elements of the data structure.
19:25:45 <Cale> fons: Well, you're certainly not sticking a Signal Foo and a Signal Bar in the same list!
19:25:55 <fons> heatsink: no, I need to model a function with multiple input signals and multiple output signals in a "generic" manner
19:26:02 <Cale> fons: You have to lose the type information somehow if you want to do that.
19:26:04 <fons> the embedded compiler takes a system
19:26:46 <heatsink> and does what with it?
19:26:54 <fons> My current solution works (based on TH), works (and my approach requires TH anyway)
19:26:56 <Cale> fons: You might want to represent the signal type information dynamically, just in the values rather than the type system.
19:27:09 <fons> but .... yhe use of TH prevents me form creating combinators
19:27:44 <fons> Cale: the respresentaiton of Signals is not the problem
19:27:58 <fons> ok how should I put it in a clearer way
19:28:14 <fons> the use of this DSL must create systems
19:28:18 <fons> user*
19:28:56 <fons> a system is created from a system function, which describes how the system works
19:29:31 <fons> a system is passed to the embedded compiler for simulation purposes, translation to a HDL language etc ..
19:29:39 <paczesiowa> parsec is dangerous - I have compiler design classes, and first assignment is to write compiler for simple while-programs without using any tools/libraries. after 100 loc of lexer I realised I almost reimplemented half of parsec and not a single line of lexer itself
19:30:21 <fons> so my problem is, what should the type of mkSystem be? (mkSystem, takes a system function)
19:31:04 <hpaste>  dolio annotated "Evil inductive product Agda syntax" with "Haskell inductive tuples." at http://hpaste.org/6907#a1
19:31:11 <fons> OK, too difficult to explain here, sorry
19:31:23 <heatsink> I agree with Cale, you're probably putting information in the type system that should be values instead.  But that's not clear so far.
19:33:22 <fons> heatsink: no, not really, the phantom paramter is well justifier
19:33:28 <fons> justified*
19:33:29 <Cale> Almost any usage of Typeable is a good sign that you're probably putting information into the type system which belongs in values.
19:33:51 <YourAlgebra> dibblego
19:33:52 <LordBrain> unless you actually want run time type checking...
19:35:08 <fons> Cale: not in this case, as I said it is well justified, been working on this for a long time :)
19:35:14 <Cale> It's doable sometimes, but it's much more trouble usually than it's worth
19:35:56 <Cale> Okay, why does it have to be a tuple? Presumably you're using these system functions together somehow.
19:36:05 <Cale> and Haskell and you know their types
19:36:16 <Cale> So when you apply the functions you know what type you're going to get, statically.
19:36:22 <fons> LordBrain: or unless you need implement a polymorphic deep-embedded DSL :)
19:36:25 <Cale> Maybe I don't understand at all :)
19:36:56 <Cale> You clearly cannot write a function which takes an arbitrary system function as a parameter.
19:37:15 <Cale> Unless it's, say, in its own typeclass.
19:37:28 <Cale> and you implement it separately for each possible type of system function
19:37:30 <fons> Cale: well, you can do that in TH
19:37:43 <fons> which is what I did
19:37:53 <glguy> TH is another one of those things that usually isn't the answer ;)
19:38:12 <ddarius> glguy: How can macros not be the answer?! ?! ?! ?!!!!
19:38:39 <fons> haha, ok, I give up
19:38:51 <fons> it's difficult to explain anyway
19:38:54 <Cale> Well, what are you trying to do with this arbitrary system?
19:39:01 <dolio> Macros are the answer to every problem anyone will ever come up with in the future.
19:39:02 <Cale> What does your TH function do?
19:39:22 <heatsink> fons: If I understand correctly, you're translating from Haskell source code to systems in a different DSL.  You've written a Haskell library such that the translation step is effected by executing the system function.  Is that right?
19:40:12 <fons> heatsink: bassically, yes
19:40:34 <heatsink> So the user writes a system function... executing it spits out some DSL code.  Okay.
19:41:23 <Cale> but... it doesn't exactly spit out some DSL code, it spits out a tuple of System k values for some various types k
19:41:25 <fons> heatsink: uhm no, sorry, the result of executing it is the structure of the system which you can the translate, simulate ...
19:41:46 <fons> Cale: but those tuples contain the structure of the sytem
19:41:49 <LordBrain> http://www.haskell.org/pipermail/cvs-ghc/2005-April/024661.html  <-- is this related to my problem?
19:41:50 <lambdabot> Title: __stginit_Foo
19:42:16 <fons> does anyone know Lava?
19:42:36 <YourAlgebra> i know java
19:42:37 <fons> it is difficult to understand this without knowing how Lava works
19:42:37 <Cale> LordBrain: which version of GHC?
19:42:42 <LordBrain> 6.6
19:42:44 <fons> YourAlgebra: not quite the same
19:42:52 <YourAlgebra> i thought it was a typo at first
19:42:52 <LordBrain> is it a bug?
19:43:02 <Cale> LordBrain: I don't know, but you might try 6.8.2
19:43:09 <LordBrain> ok...
19:43:11 <Cale> LordBrain: 6.6 is rather old
19:43:21 <LordBrain> i know...
19:43:46 <Cale> If you hpaste the code, I can try it
19:43:47 <LordBrain> but i didn't expect the ffi to have changed...
19:43:53 <LordBrain> i did
19:43:55 <heatsink> fons: It is a representation of the system, which has sufficient detail that you can construct the system from the representation?
19:43:56 <Cale> oh
19:43:59 <LordBrain> see #haskell-overflow
19:44:06 <fons> heatsink: exactly
19:44:43 <Cale> LordBrain: What happens if you just wipe out that extern void declaration?
19:44:52 <fons> heatsink: otherwise I wouldn't be able to translate it to VHDL, for example (I'm working on the VHDL backend now)
19:44:52 * ddarius listens to statements that could be applied to one hundred things be repeated.
19:45:06 <Cale> LordBrain: after all, you're not calling __stginit_Hlib, are you?
19:45:15 <Cale> er...
19:45:16 <Cale> oh
19:45:17 <Cale> hmm
19:45:24 <Cale> (you are)
19:45:41 <Cale> oh
19:45:49 <Cale> you're not calling it as a C function
19:45:51 <Cale> which it is
19:45:59 <Cale> Try adding () after ti
19:46:00 <Cale> it*
19:46:10 <LordBrain> hmmm i left that ... stuff in there
19:46:15 <LordBrain> maybe if i clean that up
19:46:53 <hpaste>  (anonymous) annotated "hlib_main.c" with "(no title)" at http://hpaste.org/6925#a2
19:47:15 <fons> anyway, tuples cannot be treated systematically, which sucks
19:47:42 <ddarius> Don't use tuples then.
19:48:13 <hpaste>  (anonymous) annotated "hlib_main.c" with "(no title)" at http://hpaste.org/6925#a3
19:48:19 <fons> on the other hand GHC seems to implement tuples as primitives
19:48:56 <fons> and I thought that there would be a GHC-only way of doing it
19:49:38 <heatsink> Tuples are really just special syntax for ordinary data constructors.
19:49:50 <heatsink> Other than syntax, they're no more primitive than Either.
19:50:23 <fons> heatsink: sure, but they _must_ be primitives in GHC I refuse to think that someone actually defined all of them ;)
19:50:47 <dons> interesting... http://arxiv.org/abs/0804.1079
19:50:55 <dons> "P is a proper subset of NP"
19:51:02 <dons> Submitted on 7 Apr 2008
19:51:49 <Pseudonym> dons: I just skimmed the paper yesterday.
19:52:03 <Pseudonym> If I'm reading it right, it suggests two conjectures that would imply P /= NP.
19:52:16 <awesame> how do I use constructors with named parameters in pattern matching?
19:52:16 <Pseudonym> Either one woudl imply it.
19:52:43 <heatsink> By proper subset, they mean something in NP was proven not in P?
19:53:12 <fons> awesame: you mean something like wholeTuple@(a1,a2,a3) ?
19:53:13 <awesame> (also, what do I call those, because googling for things like "constructor named parameters haskell" isn't working)
19:53:31 <dons> awesame: you need to use a record type
19:53:36 <awesame> fons: I have a type like data Foo = Foo { bar, baz :: String }
19:53:44 <dejones> dons: did you read the that P is a proper subset of NP paper yet?
19:53:49 <fons> wholeTuple is a name which represetns the full tuple, and the a1 a2 a3 represent the elements of the tuple
19:54:06 <awesame> I know how to write a pattern like (Foo bar baz), but that complains about shadowing existing bindings
19:54:17 <fons> awesame: Foo str1 str2 would be a pattern match of you data type
19:54:30 <lekro> dejones: what paper is that?
19:54:47 <dejones> lekro: http://arxiv.org/abs/0804.1079 --- dons posted it, so I was asking if he had read it yet.
19:54:58 <dons> no, just the abstract, reading atm.
19:54:58 <fons> thats because you are using  bar or baz in an outer scope
19:55:14 <awesame> I don't think I am
19:55:33 <fons> awesame: name shadowing doesn't cause errors BTW, just warnings so you can still be OK with them if you know what you are doing
19:55:34 <awesame> if I change the type definition to Foo = Foo String String, the pattern works fine
19:55:41 <fons> awesame: paste the code in hpaste
19:55:48 <dolio> Wow, only 14 pages to put to rest one of the biggest questions in computer science?
19:56:03 <Cale> LordBrain: I got something to work...
19:56:08 <LordBrain> Is this a typo .../ghc/ghc-6.6/include/HsFFI.h:extern void hs_init     (int *argc, char **argv[]);
19:56:15 <LordBrain> it has char **argv[]
19:56:22 <LordBrain> two astrices?
19:56:34 <Cale> Uh, that looks like a bug to me, but I can't be sure
19:56:49 <Cale> er, it's actually in the standard like that
19:57:00 <dejones> dolio: lol, yea, could be quite impressive
19:57:11 <LordBrain> hmmm they put an * on argc too
19:57:25 <Cale> ah, so they probably want pointers to the argc and argv
19:57:28 <LordBrain> i guess hs_init want's to be able to change those values
19:57:31 <Cale> and I think I know why too
19:57:33 <Cale> yeah
19:57:33 <LordBrain> or something...
19:57:37 <fons> was that submitted somewhere?
19:57:44 <LordBrain> why does hs_init want that Cale?
19:57:44 <Cale> It'll remove the RTS options from the list for you.
19:57:50 <LordBrain> ah
19:57:54 <awesame> fons: I'm more of a codepad man myself (being the author and all): http://codepad.org/dI3ciZ7W
19:58:34 <omg911> awesame: f (Foo a b) = do something with a, b
19:59:23 <awesame> omg911: see my paste
19:59:24 <omg911> haha you're really the author.. i seen a link to it from reddit
19:59:35 <omg911> i've been meaning to check out yoru site
19:59:47 <awesame> I encourage you to do so!
19:59:55 <solrize> at first glance that p vs np paper looks like crap
20:00:51 <heatsink> awesame: Do you want to match by field names?  pf _ (EvalEnv {x = input, y = args}) = pf xs (EvalEnv code x y)
20:00:52 <Cale> solrize: What do you want to bet that at second glance it looks like crap as well? ;)
20:00:56 <dolio> It has typos, at least.
20:01:09 <awesame> heatsink: perfect!  thank you.
20:01:39 <Pseudonym> dons: It's still not a "proof".
20:01:41 <Pseudonym> FWIW
20:01:48 <fons> awesame: your code is valid, the problem are the field names
20:02:16 <fons> awesame:  you are shadowing the field accesing functions
20:03:12 <solrize> i liked de branges paper about the riemann hypothesis better.  that one actually had a section about what he was going to do with the million dollars after he won the clay prize.
20:03:18 <dolio> "preformed" "\Gamma \subset M" instead of "\Gamma \subset \Sigma"
20:04:20 <omg911> solrize: are you in university?
20:04:40 <solrize> omg911 not any more, i are a graduate
20:05:07 <solrize> now i'm just a code geek :)
20:05:20 <omg911> solrize: ok cool i'm almost
20:05:35 <omg911> i don't know much people that reads paper outside of school
20:05:53 <ddarius> omg911: Then you know the wrong people.
20:06:16 <dejones> Pseudonym: why isn't it a proof?  I haven't read the paper yet
20:06:35 <dolio> I can't say I knew many people who went around reading papers in school.
20:06:48 <omg911> i guess so but i can't imagine much people would be hunting down p = np papers :)
20:07:12 <dejones> why not???
20:07:19 <fons> 28Mar08 Submitted for publication to AMS Journal Mathematics of Com-
20:07:19 <fons> putation. Rejected 1Apr08.
20:07:24 <ddarius> omg911: The people that are interested in such questions don't hunt down papers with the title "P is (not) in NP"
20:07:27 <solrize> i didn't hunt down that paper, someone posted the url here a few minutes ago
20:07:29 <dejones> p = np papers are incredibly pertinent to all computer scientists and programmers  :)
20:07:29 <dejones> hehe
20:07:39 <Cale> Yeah, this is not a proof.
20:07:46 <dejones> Cale: Why?
20:07:50 <dejones> I haven't read the paper yet
20:07:52 <solrize> so i clicked it and looked.  there goes 2 minutes of my life i will never get back
20:07:56 <dejones> Cale: Just curious.
20:07:59 <omg911> lol
20:08:04 <solrize> it's gibberish, as w. pauli used to say, "not even wrong"
20:08:26 <Cale> dejones: Because at the important point where there's supposed to be a proof, there's a bunch of wishy washy handwaving.
20:08:34 <solrize> scott aaronson has a good rant about bogus p vs. np papers
20:08:47 <dejones> Cale: hahah
20:08:53 <dejones> Cale: that's disappointing.  :(
20:09:19 <ddarius> dejones: Why?  Now -you- can solve the problem and collect fame and fortune.
20:09:21 <fons> bye guys, going to bed, I think I'll keep my TH trick
20:09:36 <fons> thanks for the effort trying to undersand me anyway :)
20:09:44 <dejones> ddarius: ha, true!  ;)
20:09:51 * dejones starts proving P != NP
20:10:10 <solrize> http://scottaaronson.com/blog/?p=304
20:10:11 <lambdabot> Title: 11 Shtetl-Optimized 17  Blog Archive 3f  Ten Signs a Claimed Mathematical Brea ...
20:10:11 <Cale> It basically says "We don't know a polynomial time algorithm for solving the Knapsack Can Fit problem, therefore, no such algorithm could exist, and hence P is a proper subset of NP.
20:10:38 <dejones> Cale: Hmm.  Yah, that doesn't seem like proof.  ;)
20:10:59 <Cale> dejones: Of course, it doesn't quite say it like that, but that's what it amounts to.
20:11:09 <dejones> http://www.youtube.com/watch?v=gKA1k3VJDq8 -- also interesting.  :)
20:11:10 <lambdabot> Title: YouTube - A quantum computer can determine who wins a game faster than a classic ...
20:11:22 <dolio> Man, I haven't seen L'Hopital's rule in a while.
20:11:26 <dejones> Cale: lol, those weren't the exact words in the paper.  ;)  hehe
20:13:07 <solrize> Typically, I find P!=NP papers easy to review. After all the bizarre notation and irrelevant steps are set out, there always come the point of there is an exponential number of solutions, and it takes at least constant time to rule out each solution, or something similar that either obviously relativizes or obviously proves exponential lower bounds for 2SAT (typically, both).
20:13:31 <solrize> (from luca trevisan comment on scott aaronson blog)
20:14:24 <dejones> Cale: I wonder why the paper was accepted to the publication if it does hand-waiving...
20:14:32 <Cale> dejones: It wasn't.
20:14:36 <dejones> lol
20:14:42 <Cale> dejones: It's just random crap on Arxiv.
20:14:47 <dejones> hahah
20:16:44 * ddarius writes a paper titled, "P v. NP: A Conflict Without Cause"
20:17:40 <roconnor> solrize: dude, you just proved P /= NP!
20:17:41 <heatsink> Since we're on this topic... any recommended reading in the vein of "A Non-Judgmental Reconstruction of Drunken Logic"?
20:19:03 <heatsink> (which is fun to read)
20:19:04 <LordBrain> Cale, thanks for your help
20:19:08 <LordBrain> i am out
20:19:52 <dejones> solrize: link to the blog article with that comment?
20:20:41 <ddarius> neelk!
20:24:04 <solrize> http://scottaaronson.com/blog/?p=304
20:24:04 <lambdabot> Title: 11 Shtetl-Optimized 17  Blog Archive 75  Ten Signs a Claimed Mathematical Brea ...
20:25:04 <dejones> solrize: ty
20:25:58 <solrize> http://scottaaronson.com/blog/?p=304#comment-16453
20:25:58 <lambdabot> Title: 11 Shtetl-Optimized 17  Blog Archive 75  Ten Signs a Claimed Mathematical Brea ...
20:26:00 <solrize> np
20:26:24 <heatsink> :)
20:28:00 <Cale> I find it kind of strange how all the problems in complexity theory are named in ALL CAPS
20:28:13 <shapr> That's one of the problems...
20:28:21 <shapr> CAPS LOCK COMPLEXITY PROBLEM.
20:28:32 <Cale> So, I've been working on the SUBGRAPH ISOMORPHISM PROBLEM lately...
20:28:47 <dejones> lol
20:28:47 <Cale> I wonder if complexity theorists actually shout the names when they're talking.
20:28:57 <shapr> I've been working on the LEARNING C# PROBLEM lately.
20:28:57 <solrize> yeah, referring is much harder than in other fields, where you can reject any paper that uses too many caps :)
20:29:00 <dejones> Cale: They want others to hear, I guess ;)
20:29:41 <shapr> Actually, this evening's problems are maemo and the BUG labs Dragonfly SDK.
20:31:39 <dons> shapr: oh, you playing with bug labs stuff?
20:31:47 <shapr> Yop, I bought one.
20:31:50 <dons> talked to sethk? :)
20:31:54 <shapr> Yeah :-)
20:32:05 <dons> awesome
20:32:07 <shapr> I didn't know bug labs hired him until after I bought the bug bundle though.
20:32:27 <shapr> I'll give you a shell account on my bug when I get it ;-)
20:32:54 <shapr> Actually, I'm working on a blog post comparing the N800, the OLPC XO and the BUG.
20:33:04 <Cale> Heh, I love that the first thing on that list of heuristics regarding how to know a paper is wrong without reading it is "The authors don't use TeX"
20:33:10 <Cale> It's funny, but true.
20:33:16 <shapr> Would be easier to finish the post if I could borrow an XO somewhere...
20:33:23 <Nafai> So I just installed a library via cabal
20:33:26 <shapr> I always get sniped on ebay :-(
20:33:34 <Nafai> And it shows up in ghc-pkg list
20:33:37 <Cale> (http://scottaaronson.com/blog/?p=304)
20:33:37 <lambdabot> Title: 11 Shtetl-Optimized 17  Blog Archive 75  Ten Signs a Claimed Mathematical Brea ...
20:33:39 <Nafai> But:
20:33:41 <dons> Cale, yeah, i liked that.
20:33:44 <dons> works for so many things
20:33:48 <Nafai> Prelude> :m + Text.CSV
20:33:49 <Nafai> module main:Text.CSV is not loaded
20:33:56 <Nafai> That's not very helpful :/
20:35:12 <Nafai> How do I debug this?
20:35:18 <shachaf> Nafai: Try another directory?
20:35:40 <shachaf> Nafai: (:cd, I mean.)
20:36:04 <Nafai> Weird
20:36:10 <Nafai> That worked
20:37:45 <ddarius> Cale: The last sentence is good as well.
20:38:21 <solrize> where are you shapr?  we've got some xo's here
20:38:37 <shapr> solrize: I'm just outside of Boston, in Somerville. Where are you?
20:38:43 <shapr> I could probably borrow an XO from the OLPC guys.
20:38:53 <solrize> woops.  california.  but yeah, you're right next to MIT...
20:39:09 <Cale> ddarius: haha, the grad student thing?
20:39:16 <ddarius> Cale: Yes.
20:39:28 <shapr> solrize: You know anyone who has experience doing maemo/XO/BUG dev?
20:39:41 <shapr> @seen boegel
20:39:41 <lambdabot> I saw boegel leaving #haskell-blah 9h 23m 24s ago, and .
20:39:42 <solrize> maemo and xo yes.  i never heard of the bug til just now.
20:39:49 <shapr> solrize: You have experience with both?
20:40:11 <solrize> we have some xo's here and i have an n770 but i have not personally hacked on either
20:40:26 <shapr> I have an N700 and an N800.
20:40:33 <shapr> And a BUG soon...
20:40:39 <shapr> And maybe an XO if I ever bid enough.
20:40:46 <solrize> i've been sort of tempted to get an n800 or 810, but the bug actually doesn't look that interesting
20:40:57 <shapr> I thought that at first, but I've changed my mind.
20:40:58 <solrize> and i sort of lost interest in the xo
20:41:09 <shapr> solrize: You have an XO you want to sell? :-)
20:41:11 <solrize> one of my huge rants is against proprietary rechargeable batteries
20:41:34 <solrize> i don't have an xo of my own
20:41:38 <shapr> Ah, too bad.
20:41:55 <Cale> It's quite funny how Computer Modern has become the typeface of trustworthiness with regard to mathematics. If you see a math paper in Times New Roman, you immediately know that it's very likely to be terrible.
20:41:58 <shapr> Anyway, I would of course like to get Haskell running on each of those devices :-)
20:41:58 <solrize> we have some where i work but i doubt they're for sale.  if you were here it would be fine for you to play with one
20:42:25 <solrize> i've sort of wanted to get haskell running under rockbox on my sansa c240 mp3 player which is about the size of a pack of gum
20:42:30 <Cale> No true mathematician would allow their sigmas to look that bad.
20:42:33 <shapr> solrize: Hugs?
20:42:38 <heatsink> Cale: I would use Lucida Bright if it weren't so expensive.
20:42:49 <solrize> under rockbox?  well i figured cross compiled ghc
20:43:08 * ddarius has no idea what  looks like in Times New Roman
20:43:13 <shapr> Um, ghc wants *lots* of memory. How much does that sansa have?
20:43:30 <ddarius> GHC doesn't cross-compile...
20:43:36 <Cale> ddarius: It's fat and strange looking
20:43:36 <solrize> 32gb of dram and 1gb built-in flash, plus a microsdhc slot that i have an 8gb card for
20:43:45 <solrize> 32mb of dram i meant!
20:43:56 <shapr> I was about to say, 32gb might work!
20:44:11 <shapr> ddarius: Well, pesco cross compiled GHC for something, sparc maybe?
20:44:14 <solrize> ghci works ok (at least for small programs) on my 512mb thinkpad
20:44:19 <shapr> Or bootstrapped it, or whatever you call it.
20:44:38 <solrize> no no i don't want to run ghc itself on the sansa, i meant i wanted to run ghc as a cross compiler on another machine, and run the output on the sansa
20:45:08 <shapr> oh!
20:45:16 <shapr> I agree with ddarius, ghc doesn't cross compile.
20:45:36 <solrize> i think the sansa could run python rather easily
20:45:37 <Cale> http://www.fileformat.info/info/unicode/font/times_new_roman/u03A3.png
20:45:39 <lambdabot> http://tinyurl.com/6qassu
20:46:25 <Cale> http://www.fileformat.info/info/unicode/font/times_new_roman_bold/u03A3.png -- or worse
20:46:26 <lambdabot> http://tinyurl.com/6juawv
20:46:40 <Cale> It's very unbalanced looking.
20:47:38 <solrize> i just don't see what to do with the bug thing.  for making a somewhat customized hardware gizmo it's probably easier to package a gumstix
20:48:10 <solrize> also it needs a cellular phone module
20:48:53 <solrize> bah the bug website has "requires flash" stuff on it
20:49:44 <Cale> http://upload.wikimedia.org/math/5/8/0/580e582a01321289628be3640c22da5f.png (for comparison)
20:49:45 <lambdabot> http://tinyurl.com/59mb5c
20:50:54 <solrize> that looks like cmr
20:58:33 <Cale> That is CMR
20:58:37 <Cale> (and CMI)
20:59:07 <Cale> I'm giving it as a comparison to the Times New Roman Uppercase Sigma
21:02:39 <bos> @seen dons
21:02:39 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc and #haskell. I last heard dons speak 28m 55s ago.
21:03:18 <omg911> @seen omg911
21:03:18 <lambdabot> You are in #haskell. I last heard you speak just now.
21:03:26 <omg911> :)
21:03:57 <omg911> Cale: hey i'm going to sleep thanks for the help tonight
21:04:43 <Cale> omg911: Yeah, sorry I couldn't be of more help, maybe I'll have another look at it tomorrow.
21:11:14 <dejones> Cale: that P != NP paper is annoying to read... poorly written and typos...
21:11:40 <Cale> dejones: I skipped most of it looking for the argument.
21:11:59 <Pseudonym> There is no argument, but there's a few good pieces of intuition.
21:12:00 <Cale> dejones: It wastes a lot of your time on irrelevant topics.
21:12:15 <dejones> lol
21:12:15 <Pseudonym> The thing is, we already have a lot of good intuition as to why P is probably not NP.
21:12:23 <dejones> Right.
21:12:33 <Cale> I think I even saw something about l'Hpital's rule in there.
21:12:39 <dejones> Heh, yep..
21:12:41 <drbean>  /sb end
21:12:45 <drbean>  /sb end
21:13:17 <dejones> Cale, Pseudonym: I'm taking a grad-level computational models course right now, so it is interesting to read overall, but the typos and poor writing making the paper tedious to read.
21:13:26 <Pseudonym> I agree with that.
21:13:36 <s710b> I made a little function which computes 'perfect' numbers, but its very slow. Could somebody check if i made something wrong in the code?
21:13:46 <hpaste>  s710b pasted "too slow" at http://hpaste.org/6926
21:13:46 <Cale> sure
21:14:17 <Cale> s710b: That's an extraordinarily slow way to factor numbers
21:14:44 <s710b> Cale, because i use list comprehension?
21:14:56 <Cale> s710b: because you're trying all possibilities
21:15:12 <twb> Waah, I'm trying to build Darcs 2.0.0 on Debian Testing and half the dependencies aren't compatible with GHC 6.8!
21:15:16 <Cale> Not just for one factor, but the other as well.
21:15:25 <Cale> Suppose you want to find factors of the number 6
21:15:32 <shapr> g'day twb
21:15:32 <Cale> Just brute force.
21:15:37 <Cale> Suppose you guess 3
21:15:51 <Cale> Would you really try multiplying 3 by 1 to see if you get 6?
21:16:03 <clanehin_> twb: I needed some things from unstable
21:16:12 <Cale> and then 3 by 2 (yep!), 3 by 3, 3 by 4, 3 by 5, 3 by 6
21:16:23 <s710b> Cale, sure! :P
21:16:45 <Cale> s710b: Well, sure, it works, but it's going to be really slow :)
21:16:48 <dejones> s710b: memoization?  save in an array any factor sums that you've alredy calculated...
21:17:15 <Cale> s710b: What you're looking for is division -- specifically the remainder after dividing.
21:17:25 <dejones> s710b: the problem might be deciding how big to initially make the array.
21:17:26 <Cale> Which can be had by the use of the mod function
21:17:38 <Cale> This will still be slow, but it will be much much faster.
21:18:07 <dejones> s710b: memoization can also help for Cale's solution too.  Save in an array the already computed mod's to re-use for other calculations.
21:18:08 <Pseudonym> If you're trying to just solve a problem, BTW, there are plenty of programs that do factoring out there.
21:18:18 <Cale> An even faster way to enumerate the factors of a number is to divide them out as you find them, giving a list of primes, which are then recombined.
21:19:21 <twb> 14:16 <clanehin_> twb: I needed some things from unstable
21:19:24 <Cale> dejones: You should really never reuse the mod calculations.
21:19:26 <twb> clanehin_: of course, why didn't I try that?
21:19:40 <s710b> Cale, dejones im pretty new to haskell, getting used to list comprehension atm. ill try sthg with division, thanks
21:20:27 <dejones> Cale: I meant the sum of factors calculations, sorry
21:20:40 <dejones> I would think you could re-use those...
21:20:49 <s710b> (i was happy it worked at least :) )
21:21:23 <dejones> :)
21:22:14 <dejones> s710b: are you familiar with memoization?  the overall concept is to save in memory computed results if the algorithm has the behavior that computations may be repeated, then you can get the computed results from memory instead of re-computing the results.
21:22:18 <Cale> > let sigma n = sum [k | k <- [1..n], n `mod` k == 0]; perfect n = sigma n == 2*n in filter perfect [1..]
21:22:24 <lambdabot> Terminated
21:22:30 <ddarius> Curse mutation!
21:22:42 <Cale> > let sigma n = sum [k | k <- [1..n], n `mod` k == 0]; perfect n = sigma n == 2*n in take 3 (filter perfect [1..])
21:22:43 <lambdabot>  [6,28,496]
21:22:54 <dejones> lol
21:22:59 <dejones> Cale is fast. :)
21:23:15 <s710b> dejones, no im not familiar with it
21:23:37 <Cale> of course, the factorisation is still too slow to get to 8128 within a minute or so
21:23:49 <dejones> s710b: memoization can be quite useful technique for improving speed.
21:24:06 <Cale> (because it's not factorisation, we're just enumerating divisors by brute force)
21:25:23 <dejones> :t filter
21:25:24 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
21:26:39 <s710b> Cale, dejones Thanks for the help. Now i have to read about memoization tomorrow :)
21:27:16 <dejones> s710b: I'd also look into Cale's suggestion about factorization; but, overall memoization can be a very useful technique.
21:27:45 <dejones> Cale: I hope s710b doesn't try the Ackermann function with memoization.  ;)  GHC bug! hehe
21:28:43 <dejones> http://hackage.haskell.org/trac/ghc/ticket/2120
21:28:47 <lambdabot> Title: #2120 (Arrays allow out-of-bounds indexes) - GHC - Trac
21:28:48 <s710b> dejones, Actually i want to do sthg useful with haskell ;)
21:29:07 <dejones> :)
21:29:37 <Cale> let factors 1 = []; factors n = k : factors (n `div` k) where {k = head [m | m <- [2..n], n `mod` m == 0]}; sigma n = sum . nub . map product . filterM (const [True,False]) . factors $ n; perfect n = sigma n == 2 * n in take 3 (filter perfect [1..])
21:29:39 <Cale> > let factors 1 = []; factors n = k : factors (n `div` k) where {k = head [m | m <- [2..n], n `mod` m == 0]}; sigma n = sum . nub . map product . filterM (const [True,False]) . factors $ n; perfect n = sigma n == 2 * n in take 3 (filter perfect [1..])
21:29:40 <lambdabot>  [6,28,496]
21:29:43 <Cale> > let factors 1 = []; factors n = k : factors (n `div` k) where {k = head [m | m <- [2..n], n `mod` m == 0]}; sigma n = sum . nub . map product . filterM (const [True,False]) . factors $ n; perfect n = sigma n == 2 * n in take 4 (filter perfect [1..])
21:29:44 <lambdabot>  [6,28,496,8128]
21:29:51 <Cale> Woohoo!
21:29:56 <dejones> much faster!
21:30:03 <s710b> impressive
21:30:14 <Cale> It won't likely find the next one so easily though.
21:30:15 <dejones> s710b: Cale is a master around here.  ;)
21:30:22 <Cale> (which is 33550336)
21:30:31 * s710b copies and pastes
21:30:53 <Pseudonym> > let perfect n = (==2*n) . sum . map product . powerset . (1:) . factor $ n in filter take 5 (perfect [1..])
21:30:54 <lambdabot>  Couldn't match expected type `Bool'
21:31:01 <Pseudonym> Hmm.
21:31:15 <Cale> powerset?
21:31:21 <Pseudonym> > powerset [1,2,3]
21:31:22 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
21:31:28 <Cale> Is that in L.hs?
21:31:31 <Pseudonym> It is now.
21:31:34 <Cale> ah
21:31:34 <Pseudonym> So is factor.
21:31:38 <Pseudonym> > factor 65535
21:31:38 <lambdabot>  [3,5,17,257]
21:32:08 <Cale> Don't forget that if you just take the powerset, you'll get duplicate divisors.
21:32:15 <Cale> (whenever the number isn't squarefree)
21:32:16 <Pseudonym> Ah, good point.
21:33:33 <Pseudonym> > let perfect n = (==2*n) . sum . nub . map product . powerset . (1:) . factor $ n in filter take 5 (perfect [1..])
21:33:33 <lambdabot>  Couldn't match expected type `Bool'
21:33:42 <Pseudonym> > let perfect n = (==2*n) . sum . nub . map product . powerset . (1:) . factor $ n in filter take 5 (filter perfect [1..])
21:33:42 <lambdabot>  Couldn't match expected type `Bool'
21:33:46 <Cale> filter take 5
21:33:57 <Pseudonym> > let perfect n = (==2*n) . sum . nub . map product . powerset . (1:) . factor $ n in take 5 (filter perfect [1..])
21:33:59 <Pseudonym> Thanks.
21:34:03 <lambdabot> Terminated
21:34:08 <Pseudonym> > let perfect n = (==2*n) . sum . nub . map product . powerset . (1:) . factor $ n in take 4 (filter perfect [1..])
21:34:09 <lambdabot>  [6,28,496,8128]
21:34:50 <Pseudonym> Probably this algorithm is unnecessarily expensive.
21:35:01 <Pseudonym> Because of the nub.
21:35:09 <Cale> aww, you used the non-cool version of powerset :)
21:35:11 <slava> @src nub
21:35:11 <lambdabot> nub = nubBy (==)
21:35:11 <Pseudonym> It's not so bad on even perfect numbers, though, because of their factorisation.
21:35:21 <slava> @src nubBy
21:35:21 <lambdabot> nubBy eq []             =  []
21:35:21 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
21:35:27 * Cale looks at L.hs :)
21:35:31 <Pseudonym> :-)
21:35:36 <Pseudonym> Do you like factor?
21:35:48 <Cale> That's significantly fancier :)
21:35:52 <slava> nub removes duplicates from a list?
21:35:58 <Cale> slava: yeah
21:36:10 <s710b> what is L.hs? sthg about lambdabot?
21:36:13 <twb> Win, I am past ./configure (darcs on Debian).
21:36:14 <Cale> yeah
21:36:26 <Cale> L.hs is where lambdabot keeps its temporary definitions
21:36:48 <s710b> ah. can everybody see it?
21:36:49 <slava> is there a better implementation that runs in constant time avaialable?
21:37:03 <Cale> s710b: actually no, which is a bit of a shame.
21:37:12 <Pseudonym> slava: You at least need to consult every element in the list.
21:37:17 <Cale> s710b: But if you want, I could hpaste it
21:37:17 <slava> correct
21:37:33 <Pseudonym> So no.
21:37:33 <slava> so you check if its in a hashtable, and if not, add it to the resulting list and add it to the hashtable
21:37:38 <s710b> Cale, nah, i was just curious
21:37:41 <slava> hashtable lookups areexpected  constant time
21:37:53 <slava> sorry I meant O(n) not O(1)
21:38:00 <Pseudonym> slava: Yes, you could do that.  Or you could use a binary search tree for O(n log n) goodness.
21:38:09 <Pseudonym> However, you'd need a stronger guarantee than (Eq a).
21:38:14 <hpaste>  Cale pasted "L.hs current local defs" at http://hpaste.org/6927
21:38:23 <Pseudonym> Ignore factor'
21:38:25 <slava> yeah, you'd need eq and hashing
21:38:26 <Pseudonym> That was a mistype.
21:39:30 <Cale> Of course, in Haskell we'd use a balanced tree rather than a hashtable :)
21:39:42 <Pseudonym> You could use a hash table, actually.
21:39:48 <slava> is it possible to implement a purely functional hashtable?
21:40:06 <Cale> I'd think it would lose all efficiency.
21:40:13 <Pseudonym> Because it's completely contained in the hypothetical nub replacement, you could put it in a local ST monad.
21:40:32 <Cale> Unless you could come up with a good way to share structure between hashtables...
21:41:37 <Pseudonym> > eratosthenesSieve 100
21:41:38 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
21:41:44 <solrize> if all you have is eq, you can't hash.  is there a way to write a version of nub that acts differently depending on whether ord is available?
21:41:57 <Cale> Usually we don't mind the logarithmic hit taken when going to pure algorithms. Really the only reason that hashtables can be average case O(1) is that memory is addressable in O(1) time, which is very unrealistic for large n anyway.
21:42:26 <Pseudonym> Hashtables are also only O(1) because you can expand them to keep the load factor under some bound.
21:42:42 <Cale> (So it's probably at least logarithmic in reality, as you add more and more memory.)
21:42:59 <solrize> O(1) memory access is realistic for real computers!
21:43:09 <slava> but for medium-sized hash tables
21:43:35 <Pseudonym> solrize: No, because the time to access a remote disk is logarithmic in the number of nodes in a network.
21:44:00 <Pseudonym> Given that there's a limit to the amount of disk you can hook up to one motherboard.
21:44:00 <Cale> solrize: Actually, it's pretty easy to show you can't do any better than O(n^(1/3)) time.
21:44:19 <solrize> this is about memory access -- there's no way to access a remote disk from a pure function :)
21:44:21 <Pseudonym> Unless you have a crossbar network.
21:44:23 <Cale> At least, assuming that the universe has finite information density bounds.
21:44:36 <Pseudonym> Is that true for quantum information, too?
21:44:53 <dejones> :t factors
21:44:54 <lambdabot> Not in scope: `factors'
21:44:56 <Cale> Seems so. In fact, if you accept the holographic principle, it'd be O(n^(1/2))
21:44:56 <dejones> :t factor
21:44:57 <lambdabot> forall a. (Integral a) => a -> [a]
21:45:07 <dejones> >factor 28
21:45:19 <Pseudonym> You need a space.
21:45:21 <Pseudonym> > factor 28
21:45:22 <lambdabot>  [2,2,7]
21:45:26 <dejones> Pseudonym: thanks
21:45:38 <Runaro> I'm working through HSOE chapter 14, and in Exercise 14.6 Hudak proposes representing polynomials as infinite lists of coefficients. But then he proposes a polynomial division function on such a construct. I can't see that such a function would ever not result in a division by zero.
21:45:43 <Pseudonym> Unfortunately, I think you recompile L.hs every time you do an eval.
21:45:47 <Cale> Since the interior of any closed surface can be encoded by a theory that lives in that surface alone.
21:45:52 <Pseudonym> So you don't share the CAFs.
21:45:58 <allbery_b> if anyone here is looking for ghc 6.8.2 on solaris 9 and has AFS, /afs/ece.cmu.edu/support/ghc/6.8.2/releases/0/sun4x_59/image/usr/local might be of interest.  (I can't promise it will work outside of ece.cmu.edu though)
21:46:13 <Cale> So rather than O(n^3) information in a radius n, you get O(n^2) information
21:46:18 <slava> Cale: in practice hashtables are faster than trees though
21:46:27 <Pseudonym> slava: Not necessarily.
21:46:49 <Pseudonym> In practice, tries seem to be faster than hashtables.
21:47:03 <Cale> Yeah, for real practical consideration, they're basically tied, except that trees are easier to understand.
21:47:19 <Pseudonym> And they support additional operations, like range queries.
21:47:33 <Cale> It's very easy to write a terrible hashtable implementation, but extremely difficult to write a good one.
21:47:39 * allbery_b may make a tarball tomorrow when he's awake
21:48:29 <Runaro> For a lot of data, a tree is certainly superior to a hash table. For most values of "a lot".
21:48:30 <dejones> Runaro: I've not seen the function that is proposed, but if the coefficent is zero then there would be no need to include it in the list...?
21:48:46 <Pseudonym> Oh, one advantage that hash tables have over trees or tries is that they're pretty easy to make concurrent.
21:48:48 <slava> sure, for a lot of data you can save parts of the tree to disk
21:48:54 <Pseudonym> Because you can lock hash lines individually.
21:48:59 <slava> not all sets of keys have a natural order
21:49:09 <dejones> Runaro: so, no division by zero bc the zero coefficients would never be in the list.
21:49:15 <Pseudonym> It's not obvious how to do fine-grained locking on a tree.
21:49:22 <Cale> Runaro: What does it give for 1/(1-x) ?
21:49:30 <dejones> Runaro: disclaimer, I'm not familiar with the function you are pondering.
21:49:45 <bos> Pseudonym: that's when we pull the STM rabbit out of the hat.
21:49:46 <Cale> Runaro: It should give [1,1,1,1,1,1...]
21:49:57 <Pseudonym> bos: Oh, you've seen Tom Conway's talk too, have you?
21:50:09 <slava> bos: i'm not sure if STM is useful for trees
21:50:10 <bos> no, it's just the obvious thing to do.
21:50:18 <slava> if you have a lot of concurrent access then STM doesn't really help
21:50:23 <Cale> Runaro: Note that not all power series are invertible.
21:50:28 <slava> you end up retrying transactions a lot
21:50:34 <Pseudonym> slava: Have I got news for you.
21:50:38 <slava> STM helps if the common case is no contention
21:50:48 <bos> slava: STM helps if you mostly read.
21:50:50 <Cale> Runaro: But it's extremely easy to tell which ones are (look at the constant term, check that it's not zero)
21:50:57 <slava> bos: that's what i said above
21:51:05 <bos> yes, but i'm a slow typist.
21:51:05 <Pseudonym> Essentially, you can STM trees, but you have to be careful.
21:51:15 <Pseudonym> 1. Store data in the leaves, like B+ trees.
21:51:18 <Cale> Runaro: and then the algorithm should be able to work -- if it doesn't, you have the wrong algorithm :)
21:51:23 <Pseudonym> That way, when you modify, you mostly modify leaves.
21:51:35 <bos> Pseudonym: what is this talk of tom's to which you refer?
21:51:51 <Pseudonym> One that only about 12 people were at a couple of weeks ago.
21:51:58 <bos> ah.
21:52:01 <Pseudonym> :-)
21:52:18 <Pseudonym> I know this stuff, because I spent many hours over coffee with him working out the details.
21:52:18 * dejones goes back to reading P != NP paper...
21:52:41 <Cale> dejones: I can find you a paper which isn't bullshit, if you need something to read.
21:52:44 <Pseudonym> Anyway, by storing data in leaves only, modifications are separated.
21:52:53 <Cale> ;)
21:52:56 <dejones> Cale: Sure.  I enjoy complexity theory.  :)
21:52:57 <Pseudonym> Even if there's a lot of writing going on, you can still get a lot of STM concurrency.
21:53:08 <Pseudonym> Second problem is how to do balancing.
21:53:16 <Pseudonym> And the answer is: lazily.
21:53:17 <bos> Pseudonym: ah.
21:53:23 <dejones> Cale: I like reading this paper although it is b.s. just for the thought process and possible intuitions.
21:53:28 <Cale> :)
21:53:31 <Cale> All right :)
21:53:37 <Pseudonym> @go "B-trees with relaxed balance"
21:53:38 <Runaro> Cale, thanks for that. I think I must have a bug.
21:53:52 <lambdabot> Plugin `search' failed with: thread killed
21:53:55 <Cale> dejones: btw, to go along with this discussion, have you looked at the finger trees paper?
21:53:59 <Pseudonym> Grrr.
21:54:13 <bos> lazy balancing is quite concurrency friendly.  this is what ropes do, for example.
21:54:15 <dejones> Cale: Nope.  What are finger trees?
21:54:23 <Pseudonym> Anyway, do a Google search for "relaxed balance" and you'll find lots of stuff.
21:54:25 <Cale> @go finger trees
21:54:27 <lambdabot> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
21:54:27 <lambdabot> Title: Finger Trees: A Simple General-purpose Data Structure
21:54:33 <Cale> @go "B-trees with relaxed balance"
21:54:34 <Pseudonym> People have worked out the details for B-trees and AVL trees.
21:54:35 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
21:54:39 <Cale> huh
21:54:41 <Cale> @go B-trees with relaxed balance
21:54:43 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
21:54:47 <Cale> wtf.
21:54:58 <jeffz> the sky is falling.
21:55:03 <Cale> @go B trees with relaxed balance
21:55:05 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
21:55:09 <Cale> @go finger trees
21:55:10 <lambdabot> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
21:55:10 <lambdabot> Title: Finger Trees: A Simple General-purpose Data Structure
21:55:14 <Pseudonym> Huh.
21:55:16 <dejones> Cale: Interesting!
21:55:19 <Pseudonym> @go avl trees with relaxed balance
21:55:22 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
21:55:27 <Cale> @go a b c d e
21:55:28 <lambdabot> http://www.abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijk.com/
21:55:28 <lambdabot> Title: AbcdefghijklmnopqrstuvwxyzAbcdefghijklmnopqrstuvwxyzAbcdefghijk.com - The World' ...
21:55:31 <Cale> heh
21:55:40 <Cale> @go relaxed
21:55:41 <lambdabot> http://dictionary.reference.com/browse/relaxed
21:55:41 <lambdabot> Title: relaxed - Definitions from Dictionary.com
21:55:45 <Cale> @go relaxed balance
21:55:45 <Pseudonym> @go avl trees relaxed balance
21:55:46 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
21:55:48 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
21:55:51 * dejones needs to buy Okasaki's "Purely Functional Data Structures."
21:55:53 <Pseudonym> @go avl trees with relaxed
21:55:54 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
21:55:58 <Pseudonym> @go avl trees with
21:55:59 <lambdabot> http://en.wikipedia.org/wiki/AVL_tree
21:55:59 <lambdabot> Title: AVL tree - Wikipedia, the free encyclopedia
21:56:02 <Cale> This is insane.
21:56:05 <Pseudonym> @go relaxed
21:56:06 <lambdabot> http://dictionary.reference.com/browse/relaxed
21:56:06 <lambdabot> Title: relaxed - Definitions from Dictionary.com
21:56:07 <dejones> lol
21:56:28 <Pseudonym> Do the damn Google search yourself.
21:56:47 <Cale> I'm just trying to sort out why the hell it doesn't like some searches.
21:56:49 <dejones> lambdabot punted to Google  ;)
21:56:51 <dobblego> "This is the only email address that would allow you to fail an online webform!" -- I hardly think so
21:57:53 * dejones awaits non-b.s. P = NP papers from Cale.  ;)
21:58:11 <Cale> heh, I'm afraid those don't really exist as of yet
21:58:14 <dejones> rather, P \= NP
21:58:15 <dejones> ha
21:58:35 <dobblego> are there any non-b.s. papers for either = or /= ?
21:58:51 <Pseudonym> There are none that answer the question.
21:58:52 <Pseudonym> Obviously.
21:58:58 <Pseudonym> But there are some good partial results.
21:59:01 <Cale> Well, okay, there are papers which establish things about the question which are not one way or the other.
21:59:05 <Cale> right.
21:59:06 <dobblego> why are so many people writing b.s. papers then?
21:59:16 <Cale> dobblego: Because they're cranks.
21:59:21 <Pseudonym> dobblego: Because a $1M prize attracts cranks.
21:59:33 <dobblego> oh ffs, this world is dumb
21:59:38 * dobblego cranks
21:59:39 <Pseudonym> FWIW, I don't think that the person who wrote this paper is a crank, exactly.
21:59:45 <Cale> dobblego: If it's on Arxiv, and not published, then basically, ignore it.
21:59:48 <dejones> isn't \= correct syntax for not-equal in Haskell?
21:59:55 <dobblego> dejones, /=
21:59:58 <dejones> ahh
22:00:00 <dejones> ty
22:00:00 <Cale> dobblego: You can just wait until it's peer reviewed to find out :)
22:00:06 <Pseudonym> I think that the guy's intuition as to why P is likely to be /= NP is sound.
22:00:10 <dolio> Why do people hang out on sci.math all day and talk about how set theory is evil religion and how their own work is going to revolutionize mathematics?
22:00:12 <dobblego> Cale, I'm sure it'll be on the evening news :)
22:00:14 <Pseudonym> But lots of people have come up with intuition.
22:00:37 <Cale> dolio: Haha
22:00:44 <solrize> err, everyone has the same intuition, that guy whether he realizes it or not is just another of the zillion of us who haven't figured out how to turn that same intuition into a proof
22:01:17 <Cale> It would be interesting if P vs. NP were formally undecidable.
22:01:19 <Pseudonym> solrize: The thing about the intuition here is that there are some pretty good heuristic reasons why P /= NP should be true.
22:01:22 <bos> also, arxiv.org attracts ideas of various stages of bakedness, from half-baked to dialing the pizza parlour in a frenzy of the munchies.
22:01:37 <Pseudonym> Cale: Or if the proof, assuming it existed, were computationally infeasable.
22:01:38 <solrize> pseudonym, yes. nobody doubts that.  that's why the problem is so maddening.
22:01:50 <dejones> > let p = 0; np = 1 in p /= np
22:01:50 <lambdabot>  True
22:01:53 <dejones> I win.
22:02:01 * dejones wants $1M now.
22:02:04 <roconnor> Cale: there was some kinda crazy argument that if P vs. NP was easy to solve then P would equal NP.
22:02:05 <solrize> scott aaronson (same guy with that list of bogus paper signs) has a good article about what it would be like for p vs np to be undecidable
22:02:18 <Pseudonym> What this paper has, essentially, is another heuristic reason.  One that I haven't seen before, though I haven't kept up with them.
22:02:20 <solrize> roconnor, yeah, that's basically what aaronson says
22:02:23 <dolio> dejones: Your proof isn't capitalized enough.
22:02:31 <Pseudonym> It might be original, it might not.
22:02:32 <dejones> dolio: SORRY!
22:02:33 <dejones> ;)
22:02:35 <solrize> http://www.scottaaronson.com/papers/pnp.pdf
22:03:09 <dejones> solrize: thanks
22:03:10 <Cale> Watch, P = NP, but no algorithm for solving NP problems in polynomial time can do better than O(n^(e^e^e^79))
22:03:33 <dobblego> Cale, intuition?
22:03:51 <Cale> dobblego: This is just joking around :)
22:03:58 <Cale> dobblego: But it's possible.
22:04:18 <dobblego> If P = NP, then the N is redundant, yet we continue to use it, therefore, P /= NP
22:04:30 <roconnor> > exp (exp (exp 79))
22:04:34 <lambdabot>  Infinity
22:04:38 <dejones> dobblego, Cale: e^e^e sounds like p but using e's, so we multiple by some factor of e's, so n*p
22:04:40 <solrize> cale, try O(n^busybeaver(K)) for some K >= the # of states in the smallest turing machine that recognizes an NP-hard language
22:04:43 <dolio> Hah.
22:04:45 <solrize> NP-complete make that
22:04:45 <Pseudonym> What would be seriously cool is if P = NP was provably equivalent to the axiom of choice or something like that.
22:04:57 <Cale> ahaha :)
22:05:01 <Cale> That would be awesome :)
22:05:03 <solrize> that could make P vs NP independent of peano arithmetic while decidable in set theory :)
22:05:39 <Cale> Or the continuum hypothesis, to get even more strange.
22:05:44 <solrize> haha
22:06:02 * dejones got lost on the axiom of choice and peano arithmetic. 
22:06:02 <solrize> or AC
22:06:10 <dejones> ;)
22:06:16 <Cale> solrize: That's what Pseudonym suggested
22:06:17 <solrize> P = NP depends on a well-ordering of the reals :)
22:06:24 <Pseudonym> I have a suspicion that if P /= NP is ever proven, it'll be done by some major breakthrough in algorithmic information theory.
22:06:40 <Cale> I've wanted CH to be true more often than not, but some set theorists think it would be better to consider it false.
22:06:56 <Cale> (obviously, either way is fine)
22:07:04 <solrize> huh?  CH is obviously false :)
22:07:10 <Runaro> it's arbitrary
22:07:25 <Cale> solrize: So you think there's a cardinal in between the naturals and the reals?
22:07:31 <dejones> Pseudonym: My computation models teacher said the same thing... he said essentially that we don't have the "tools available" currently to prove P /= NP.
22:07:34 <roconnor> solrize: CH is independent of P = NP
22:07:41 <Pseudonym> dejones: Right.
22:07:42 <dejones> is Manuel M. T. Chakravarty on IRC?
22:07:53 <dejones> he commented on my Haskell GSoC application.
22:07:54 <Heffalump> he's ChilliX
22:07:58 <dejones> ahh, thank you
22:08:01 <roconnor> and AC
22:08:14 <Pseudonym> It might also happen that P /= NP is first proven for quantum computers.
22:08:15 <Cale> roconnor: Are you sure?
22:08:20 <dejones> hello ChilliX:  I just got your comment on my GSoC application.
22:08:24 <roconnor> Cale: Bob Solovay told me.
22:08:32 <roconnor> Cale: who got it from Godel
22:08:35 <adu> CH = Continuum Hypothesis?
22:08:36 <roconnor> (indirectily)
22:08:37 <solrize> cale, yes, clearly.  cohen explained, getting bigger cardinals by diagonalization is one thing, getting them by powersets is vastly more powerful
22:09:03 <roconnor> AC and CH do not affect arithemetic statments because they don't affect omega.
22:09:16 <solrize> there is also some trendy argument by woodin based on infinitary logic that CH is false
22:09:42 <adu> I think CH and NvNP are both two instances of the same damn problem
22:09:59 <solrize> CH is unlikely to actually have anything to do with P/NP
22:10:01 <Cale> solrize: But it would be so much easier to be able to say that if something has a cardinality greater than the naturals, then you can fit R into it.
22:10:15 <roconnor> solrize: not just unlikely, it doesn't period.
22:10:29 <Cale> solrize: I've actually wanted that ability several times.
22:10:42 <solrize> what a cramped little set theory that would be :)
22:10:47 <solrize> i mean you get that if V=L
22:10:59 <solrize> but set theorists find that too limiting, apparently :)
22:11:03 <Cale> Oh, V = L would be awesome :)
22:11:09 <adu> whats V=L?
22:11:32 <solrize> V=L says there are no inaccessible cardinals
22:11:39 <Cale> adu: Every set is constructible, in a particular sense.
22:12:22 <Cale> V=L implies AC and GCH.
22:12:25 <adu> why not just make Omega a class?
22:12:31 <solrize> Omega?
22:12:51 <adu> that cardinal that is supposed to contain all cardinals or something
22:12:55 <adu> or is it ordinals...
22:13:10 <roconnor> the set of all cardinals
22:13:11 <solrize> ordinals are a class
22:13:16 <roconnor> or the set of all ordinals
22:13:21 <roconnor> er
22:13:21 <roconnor> class
22:13:27 <solrize> right, the class of all ordinals (or cardinals)
22:13:30 <solrize> they don't form a set
22:14:19 <adu> I think CH and NvNP suffer from lack of rigor
22:14:25 <Cale> http://en.wikipedia.org/wiki/G%C3%B6del%27s_constructible_universe
22:14:26 <lambdabot> Title: Constructible universe - Wikipedia, the free encyclopedia, http://tinyurl.com/5zkey6
22:14:32 <solrize> In 1993, Razborov and Rudich [56] wrote a paper that contains, arguably, the most important insight anyone
22:14:32 <solrize> has thus far had into the P vs. NP question. Loosely speaking, they said that the reason P = NP is so
22:14:32 <solrize> difficult to prove is that P = NP!   (from aaronson p/np independence paper)
22:14:43 <Cale> adu: CH is known to be undecidable.
22:15:09 <Cale> adu: That is ZFC+CH and ZFC+(not CH) are as consistent as ZFC.
22:15:22 <solrize> err... CH is independent of a particular axiomitization of set theory that's considered by some to be a weak axiomitization
22:15:42 <adu> lol
22:15:43 <Cale> It's the axiomatisation which everyone uses.
22:15:53 <solrize> for small values of "everyone" :)
22:16:05 <Cale> Pretty large values of everyone, really.
22:16:15 <Cale> Almost everyone doing mathematics.
22:16:17 <Pseudonym> Ah, yes.
22:16:21 <Pseudonym> Razborov and Rudlich.
22:16:25 <solrize> hmm... probably not most set theorists
22:16:48 <solrize> and i think non-set theorists don't care much about even ZFC, set theory just seems like a bogus subject
22:16:50 <Cale> Yeah, but set theorists wouldn't have anything to do if they didn't screw around with the axioms.
22:17:01 <roconnor> pfft, people doing mathematics hardly think about ZFC.
22:17:11 <Cale> roconnor: They make use of the axioms all the time.
22:17:34 <Cale> At least in my mathematics courses, it was quite clear that ZFC was in use.
22:17:44 <solrize> cale i think most non-set-theory math is done in PA2 or weak fragments of it
22:17:48 <roconnor> Cale: not really in practice
22:17:48 <Cale> Maybe modulo replacement or so.
22:18:02 <solrize> feferman has a rant about that
22:18:07 <roconnor> Cale: one could argue without much difficulty they are using PA.
22:18:22 <roconnor> yea, what solrize said
22:18:27 <solrize> http://math.stanford.edu/~feferman/papers/psa1992.pdf
22:18:41 <Cale> Can you prove that every vector space has a basis from PA?
22:19:29 <roconnor> Cale: that is a useless theorem.
22:19:40 <Cale> Or how about that every ideal is contained in a maximal ideal?
22:19:48 <roconnor> also useless
22:19:56 <Cale> I disagree on both counts.
22:20:24 <solrize> iirc the theorem that every finite dimensional vector space has some fixed dimension d, can't even be stated in ZFC
22:20:27 <solrize> much less proved
22:20:27 <adu> I think the vector space basis thing is super-useful
22:20:27 <Cale> Those theorems characterise vector spaces and rings very strongly, and without them, they take on a very different character indeed.
22:20:36 <roconnor> In practice all uses of the axiom of choice in the end generate choice functions for things that already had choice functions.
22:20:58 <Cale> How about Tychonoff's theorem?
22:21:27 <Runaro> http://209.85.165.104/search?q=cache:cK0L37gnkc4J:web.maths.unsw.edu.au/~norman/papers/Ordinals.pdf+%22Numbers,+Infinities+and+Infinitesimals%22&hl=en&ct=clnk&cd=1&gl=us&client=firefox-a
22:21:27 <lambdabot> http://tinyurl.com/6foa45
22:21:40 <Runaro> A gem.
22:21:56 <Cale> Or the Banach-Alaoglu theorem?
22:22:30 <Cale> (the closed unit ball of the dual space of a normed vector space is compact in the weak-* topology)
22:23:25 <Cale> Or for that matter, the Hahn-Banach theorem itself.
22:23:50 <Cale> That's like, the central tool of functional analysis.
22:24:01 <Cale> You're saying that's unimportant?
22:24:08 <roconnor> yes
22:24:19 <Cale> Well, I'm inclined to disagree :)
22:24:45 <roconnor> they theories need to be reworked to be construcitve.
22:24:52 <roconnor> (my advisor is doing that)
22:24:53 <Cale> What do you think of the ultrafilter lemma?
22:25:55 <solrize> the hahn banach theorem doesn't need anything like ZFC
22:26:05 <roconnor> Cale: looks useless
22:26:11 <Cale> solrize: It needs at least the ultrafilter lemma.
22:26:33 <Cale> solrize: It doesn't imply choice, but it's not true in ZF either.
22:26:57 <solrize> it doesn't need the ultrafilter lemma
22:26:59 <solrize> see http://en.wikipedia.org/wiki/Hahn-Banach_theorem#Relation_to_the_axiom_of_choice
22:26:59 <lambdabot> http://tinyurl.com/6c7vog
22:27:27 <solrize> at least in the separable case
22:28:32 <Cale> solrize: Well, okay, it may be technically somewhat weaker.
22:28:56 <solrize> well, for those reverse mathematics guys, it's much more than a technicality :)
22:29:05 <Cale> solrize: However, nobody gives a damn about WKL_0
22:29:20 <Cale> (except strange set theorist people)
22:29:21 <solrize> right, WKL_0 is much weaker than PA2
22:29:28 <solrize> and PA2 is where most math is considered to live
22:29:46 <solrize> and PA2 is waaay weaker than anything most of us would call set theory
22:29:49 <solrize> i mean it's countable :)
22:29:59 <Cale> Why not just go with ZFC?
22:30:19 <adu> i just watched a wonderful video on interval analysis
22:30:41 <solrize> well ZFC implies there are uncountable sets... and who but a set theorist would want to believe something like that?
22:30:49 <Cale> A mathematician?
22:30:55 <roconnor> @go The Hahn-Banach Theorem in Type Theory
22:30:56 <lambdabot> http://citeseer.ist.psu.edu/23706.html
22:31:05 <Cale> solrize: I want at least R and 2^R.
22:31:09 <solrize> CiteSeer is currently unavailable.
22:31:14 <solrize> R is countable :)
22:31:20 <Cale> No it isn't.
22:31:27 <Cale> Not *my* R anyway.
22:31:45 <adu> Not my R either
22:31:55 <roconnor> not my R either ... kinda
22:31:58 <solrize> you can't describe any elements of R that don't fit in a countable set
22:32:01 <adu> i'm on Cale's side
22:32:06 <Cale> The definable reals are countable, sure.
22:32:16 <solrize> yes.  the other ones are science fiction :)
22:32:19 <roconnor> ZFC has a countable model
22:32:19 <Cale> But the definable reals aren't topologically complete either.
22:32:31 <Cale> roconnor: First order model
22:32:38 <roconnor> if it is consistent
22:32:51 <adu> What do you mean "definable reals"?
22:32:56 <roconnor> Cale: you got a problem with first order models?
22:32:59 <Cale> adu: The ones which you can write down.
22:33:18 <adu> I beg to differ
22:33:52 <solrize> luqui explains this stuff pretty well
22:33:59 <adu> or do you mean the ones you can write in decimal notation?
22:33:59 <Cale> adu: Okay, more formally, the ones for which there exist proofs of existence and uniqueness.
22:34:11 <Cale> So, for instance pi is in that set.
22:34:34 <adu> ah, so only those that can be proven trancendental?
22:34:36 <roconnor> Cale: what kind of proofs?
22:34:38 <Cale> Every individual real number which you can point to and and say "that one right there" is in that set
22:34:44 <Cale> adu: No, 1 is also in the set.
22:34:52 <Cale> roconnor: Finite ones :)
22:35:02 <roconnor> Cale: proofs in what system?
22:35:05 <solrize> roconnor basically a constructable real = a real that's definable by some first order formula
22:35:15 <solrize> and there are only countably many first order formulas...
22:35:16 <Cale> roconnor: Whatever system we're using, which in this case is ZFC by fiat :)
22:35:47 <adu> solarize: what? no there isn't
22:35:51 * roconnor picks up a number that is a real number iff ZFC is consistent
22:35:51 <solrize> there's some theorems about lebesgue measure that depend on large cardinals
22:36:03 <Cale> adu: Unless you have an uncountable alphabet...
22:36:19 <adu> solarize: wait, your right, countable as in countably infinite, yes
22:36:25 <Cale> adu: right.
22:36:27 <adu> sorry
22:36:34 <solrize> ZFC can be consistent without having any uncountable models...
22:36:38 <adu> for some reason I thought countable = finite
22:36:48 <Cale> But the reals which aren't definable are still important.
22:36:50 <solrize> uncountable = "i can't count that high" :)
22:36:59 <adu> lol
22:37:06 <solrize> cale, one could be the same of cardinals that aren't definable :)
22:37:11 <solrize> be -> say
22:37:27 <Cale> solrize: One could, however, one would probably be lying ;)
22:37:30 <adu> Cale: like the hyper-neighbor of pi - epsilon?
22:37:34 <roconnor> Cale: how can they be important if they are not represented in ZFC's countable model?
22:37:51 <Cale> roconnor: second order properties
22:37:57 <Cale> roconnor: Like topological properties.
22:38:00 <adu> wait, n/m that wouldn't be real that would be hyper-real
22:38:10 <roconnor> Cale: they have not affects on the theory!!1!
22:38:12 <Runaro> The reals which aren't definable are still important to whom and for what?
22:38:15 <roconnor> no effects
22:38:22 <Cale> roconnor: huh?
22:38:57 <roconnor> Cale: the first order model models all the first order statements
22:39:21 <roconnor> which is effectively all of math
22:39:42 <Cale> I want things to be true of the reals like "every bounded sequence has a convergent subsequence"
22:39:52 <adu> there are higher forms of math in which statements are not first order
22:40:04 <adu> for example, obscurantism
22:40:15 <Cale> Which, as far as I can tell, is not true of the definable reals.
22:40:18 <roconnor> adu: ZFC has sucessfully reduce more or less all of math to first order.
22:40:35 <Cale> Unless, perhaps you'd like to prove it?
22:40:58 <Cale> Even if it is true, the proof is far more unwieldy.
22:41:14 <adu> roconner: obscurantism is far the way of the one and the true, darkly
22:41:17 <roconnor> Cale: It has a representative in the countable model.
22:41:49 <roconnor> whatever the heck it is. :P
22:41:54 <Cale> see?
22:42:07 <roconnor> see!
22:42:36 <Cale> The non-definable reals make all sorts of things much simpler to work with.
22:42:57 <roconnor> wait, isn't that convergent subsequent a "definable real"
22:43:03 <roconnor> subsequence
22:43:13 <roconnor> or at least a definable set
22:43:39 <roconnor> perhaps I'm unclear on what definable means
22:43:46 <roconnor> there are so many different definitions
22:43:49 <Cale> It might be definable.
22:44:00 <Cale> But you end up worrying about it, and wasting time on it.
22:44:01 <roconnor> I think it appears in L
22:44:30 <roconnor> it's not constructable, but it is definable.
22:44:54 <Cale> yeah, that seems true actually
22:45:17 <roconnor> let's not confuse the issues more than they already are. ;)
22:49:05 <Cale> Hmm, are intervals of the definable reals compact?
22:49:18 <roconnor> closed intervals?
22:49:21 <Cale> yeah
22:49:27 <roconnor> bounded intervals?
22:49:36 <Cale> Yes.
22:49:46 <roconnor> I don't know.  I study the constructive reals. :P
22:50:11 <roconnor> but since V=L is consisten with ZFC, I'd guess yes.
22:51:47 <Cale> I'm still pretty sure that you'd end up with strangeness.
22:52:02 <roconnor> V=L is consistent with ZFC.
22:53:05 <Cale> roconnor: But is V=L really what we're talking about here?
22:53:10 <roconnor> so I don't see how your reals are not the definable reals.
22:53:20 <roconnor> I have no idea what we are talking about :P
22:53:40 <solrize> L is huge, definable reals just mean reals that you can describe with a formula, like pi = 4*arctan(1) and stuff like that
22:53:49 <Cale> Well, there's a subset of R which is countable and consists of only those reals who have definitions.
22:54:01 <roconnor> solrize: that's a pretty tame example of a formula. :D
22:54:26 <roconnor> Cale: um, I'm not sure you can formalize what you just said.
22:54:56 <Cale> I'm fairly sure I could, but it would take some grinding :)
22:55:07 <Cale> roconnor: It would involve embedding ZFC inside itself.
22:55:17 <roconnor> Cale: you look like you are walking in "the smallest number that can be written in n words" territory to me.
22:55:38 <solrize> there is no limit on the formula size
22:56:07 <roconnor> solrize: but similar problem in making the statement formal.
22:56:30 <Cale> roconnor: Well, okay, it depends on the particular way in which you formalise things to some extent, sure.
22:56:46 <Cale> roconnor: But you can pick a formalisation.
22:57:14 <solrize> zzz later
22:57:21 <adu> What is the most well-written programming language specification?
22:57:31 <roconnor> Cale: okay, I'll pretend for the moment that what you are saying makes sense.
22:58:32 <Pseudonym> adu: If you ignore the fact that it's an implementation-defined language, "The Programming Language Pascal" is pretty good.
22:58:53 <roconnor> Cale: I also assume we are working in ZFC + Con(ZFC)?
22:58:58 <Cale> roconnor: btw, L isn't countable, it's actually a proper class, since it contains all the ordinals in V.
22:59:19 <roconnor> I never said L was countable.  I said ZFC has a countable model.
22:59:25 <Pseudonym> Oh, no, the standard is ISO-7185.
22:59:34 <roconnor> (if it is consistent)
22:59:59 <Cale> roconnor: yeah, but you seemed to bring up V=L a bunch in that discussion
23:00:08 <adu> Pseudonym: ok, ya I'm looking for coverage, you know, outline, terminology, etc.
23:00:14 <roconnor> Cale: because you kept on talking about definable sets.
23:00:26 <Cale> roconnor: definable reals
23:00:35 <Cale> L is the constructible sets.
23:00:48 <roconnor> which I can only assume means those reals (as sets) that are definable sets.
23:01:05 <roconnor> ie the intersection of R with L.
23:01:19 <Cale> It's those reals which have a first order formula that uniquely specify them.
23:01:38 <roconnor> uniquely?
23:01:42 <Cale> yes
23:02:05 <Cale> as in, you can prove that there is exactly one real number which satisfies the formula in question
23:02:30 <s710b> what does CAF stand for? as in 'Memoising CAFS'
23:02:40 <Cale> s710b: Constant applicative form
23:02:56 <s710b> thx!
23:05:46 <roconnor> Cale: oh okay
23:05:52 <roconnor> my bad
23:06:52 <s710b> Another memoizing question: Where is the memoization here:
23:06:55 <s710b> facs = scanl (*) 1 [1..]
23:06:59 <s710b> fac n = facs !! n
23:07:05 <s710b> ?
23:07:09 <roconnor> Cale: I guess I didn't know what a definiable real was.
23:07:11 <Cale> s710b: It's in the fact that facs is a constant which will not be recomputed.
23:07:19 <Cale> roconnor: that's all right :)
23:07:46 <adu> Cale: doesn't Memoising only apply to constant applicative forms? are there anything else you can Memoize?
23:07:59 <Cale> s710b: and so once you start pushing that scanl down the infinite list, the already computed elements stay computed, and the tail remains a promise to compute more of them.
23:08:10 <Cale> adu: basically.
23:08:33 <Cale> adu: There's sharing whenever a function parameter occurs multiple times in the body of a function as well.
23:08:42 <dolio> CAFs are, essentially, shared among all expressions in the program, so they never get garbage collected.
23:08:46 <s710b> hm, ok
23:09:05 <roconnor> The countable model of ZFC in some sense has more reals than the definable
23:09:20 <roconnor> because it includes real number than are not uniquely defined by a formula.
23:09:24 <dolio> Which is why you can use them for memoizing.
23:09:31 <roconnor> because it includes real numbers that are not uniquely defined by a formula.
23:09:44 <Cale> roconnor: interesting :)
23:09:45 <dolio> At least, if your implementation of Haskell uses lazy evaluation.
23:10:02 <roconnor> every existential statement whether unique or not gets puts into an equivalence class.
23:10:13 <Cale> roconnor: I still think it's a lot of trouble to go to for very little benefit :)
23:10:52 <roconnor> Cale: trouble, benefit?  We are philosophising here.  The only benefit is trouble.
23:11:26 <Cale> Benefit in terms of making it easy to get to the mathematics which you're actually interested in.
23:12:17 <Cale> You still don't really get to rely on the fact that there are only countably many sets -- because that statement is obviously inconsistent.
23:13:02 <sieni> Cale: what about countable models of set theory? *
23:13:05 <sieni> *ducks*
23:13:12 <Cale> sieni: that's what we're discussing
23:13:31 <sieni> ahh
23:13:37 <Cale> sieni: Even if you have a countable model of set theory, you can't go adding the statement to it that there are only countably many sets as an axiom.
23:13:47 <Cale> Because you can prove otherwise ;)
23:14:04 <dobblego> ?type liftM8 (,,,,,,,) -- do most people use Applicative here?
23:14:05 <lambdabot> Not in scope: `liftM8'
23:14:31 <dolio> Most people don't get to 8-tuples.
23:14:42 <dobblego> right
23:15:53 <bos> you'd usually introduce a nominal type at that point instead of a tuple.
23:15:56 <roconnor> Cale: if you assume False, it will be even easier to get the mathematics you are interested in.
23:16:09 <Cale> roconnor: It's like The Price Is Right.
23:16:19 <Cale> roconnor: The idea is not to go over ;)
23:17:02 <roconnor> too bad the list of prices isn't linear
23:17:07 <roconnor> AC or AD?
23:17:19 <Runaro> Cale: for (1/1-x), did you mean [1,0,1,0,1,0,1,0...] ?
23:17:24 <Cale> no
23:17:37 <Cale> 1/(1-x) should be [1,1,1,...]
23:17:44 <Cale> It's 1 + x + x^2 + x^3 + ...
23:19:10 <roconnor> Cale: I'd argue your game is a stupid game
23:19:40 <Cale> roconnor: and to some extent you'd be right -- we should just pick something and stay with it
23:20:01 <roconnor> Predicative topos!
23:20:11 <roconnor> with natural numbers
23:20:21 <Cale> People aren't going to live without AC
23:20:31 <Cale> Well, mathematicians won't anyway :)
23:20:33 <roconnor> AC is a non-issue
23:20:58 <Cale> roconnor: Well, then just accept it :)
23:21:20 <Cale> It's nice, you get that products of nonempty sets are nonempty. :)
23:21:51 <roconnor> I don't have a big problem with AC, because it has no arithmetic consequences.
23:22:28 <Runaro> (/) (a:as) (b:bs) = (a/b) : 0 : (as - (a/b) * bs) / (b:bs)
23:22:47 <Cale> Runaro: that can't possibly be right
23:22:58 <Cale> Runaro: You're not always going to get a 0 there :)
23:23:25 <Cale> Unless your representation allows for something strange in the odd positions.
23:26:15 <Runaro> (0:as) means "polynomial represented by as, multiplied by x"
23:26:25 <Cale> right
23:26:48 <Runaro> gaah, I'm missing something trivial
23:26:49 <Cale> (a/b) : 0 : zs
23:26:58 <Cale> means that the coefficient of x is always 0 :)
23:30:57 <Runaro> I see it, but I don't know why that is wrong.
23:34:27 <Runaro> although, clearly, it is.
23:35:22 <Cale> maybe just try removing that extra 0?
23:36:15 <Runaro> Removing the 0 makes it work correctly for all tests I can think of. But where has my multiplication by x gone?
23:36:27 <Runaro> oh! duh
23:36:27 <Cale> Well, it's in the cons
23:36:34 <Runaro> yea
23:36:46 <Cale> a:as is like a + x * as
23:36:54 <Runaro> right-o
23:37:30 <Runaro> Thanks a heap
23:37:42 <Runaro> ...or an infinite set
23:38:06 <Cale> > let (0:fs) ./ (0:gs) = fs ./ gs; (f:fs) ./ (g:gs) = let { q = f/g } in q : (zipWith (-) fs (map (q*) gs)) ./ (g:gs) in ([1] ++ repeat 0) ./ ([1, -1] ++ repeat 0)
23:38:07 <lambdabot>  [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0...
23:39:30 <olsner> Cale: what number system is that? (assuming ./ is "division")
23:39:40 <Cale> olsner: Ring of formal power series
23:40:08 <olsner> if only I had formal powers
23:40:30 <Cale> [a0,a1,a2,...] represents  a0 + a1 x + a2 x^2 + a3 x^3 + ...
23:41:16 <olsner> oh, so ./ does polynomial division even?
23:41:23 <Cale> yeah
23:41:48 <Cale> Although my definition doesn't quite elegantly handle the case where the lists are finite :)
23:42:16 <Cale> But if you represent polynomials by lists which are eventually all 0's, then it works :)
23:42:39 <olsner> > let (0:fs) ./ (0:gs) = fs ./ gs; (f:fs) ./ (g:gs) = let { q = f/g } in q : (zipWith (-) fs (map (q*) gs)) ./ (g:gs) in (7:repeat 0) ./ (2:repeat 0)
23:42:40 <lambdabot>  [3.5,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0...
23:44:02 <olsner> hmm, "eventually all zeroes"? isn't (3:replicate 1000000000 0 ++ [1,2,3]) different from 3:repeat 0?
23:44:07 <Cale> > let (0:fs) ./ (0:gs) = fs ./ gs; (f:fs) ./ (g:gs) = let { q = f/g } in q : (zipWith (-) fs (map (q*) gs)) ./ (g:gs) in (4:-4:1:repeat 0) ./ (-2:1:repeat 0)
23:44:08 <lambdabot>   Not in scope: data constructor `:-'
23:44:14 <Cale> > let (0:fs) ./ (0:gs) = fs ./ gs; (f:fs) ./ (g:gs) = let { q = f/g } in q : (zipWith (-) fs (map (q*) gs)) ./ (g:gs) in (4:(-4):1:repeat 0) ./ (-2:1:repeat 0)
23:44:14 <lambdabot>  [-2.0,1.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-...
23:44:26 <Cale> heh, negative 0
23:45:01 <olsner> (but maybe that's just a matter of forcing the result to the proper length)
23:46:04 <Cale> olsner: Re: that question, yeah, they're different.
23:46:32 <Cale> One has some very high order terms :)
23:46:39 <Cale> (and one is a finite list)
23:46:56 <Cale> > replicate 1000000000 0
23:46:57 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
23:47:03 <Cale> > 1000000000 :: Int
23:47:04 <lambdabot>  1000000000
23:47:07 <Cale> okay :)
23:47:16 <Cale> > maxBound :: Int
23:47:17 <lambdabot>  2147483647
23:47:30 <povman> > length [0::Int ..]
23:47:35 <lambdabot>  Terminated
23:48:00 <olsner> maybe if I added another repeat 0 there, I think that's what I actually meant :P
23:48:02 <povman> > length [0::Int, 1000 ..]
23:48:03 <lambdabot>  2147484
23:48:06 <povman> :p
23:48:37 <Cale> olsner: So, uh, yeah, they're different, but in a certain strange sense, they're approximately the same.
23:51:09 <lispy> > length [0::Int, 10000 ..]
23:51:09 <lambdabot>  214749
23:51:25 <olsner> if x is [0..1], later terms become less important, but for x > 1, it really does matter if you have more non-zero exponents later in the list
23:51:27 <lispy> neat, it rounds up
23:51:31 <lispy> (in this case)
23:51:34 <olsner> *coefficients
23:52:15 <Runaro> > let (.-) = zipWith (-); (.+) = zipWith (+); (.*) (a:as) (b:bs) = a*b : ((map (*a) (0:bs)) .+ (map (*b) (0:as)) .+ ((0:as) .* (0:bs))); (./) (a:as) (b:bs) = (a/b) : ((as .- map (* (a/b)) bs) ./ (b:bs)) in (1:repeat 0) ./ (1:(-1):(-1):repeat 0)
23:52:16 <lambdabot>  [1.0,1.0,2.0,3.0,5.0,8.0,13.0,21.0,34.0,55.0,89.0,144.0,233.0,377.0,610.0,98...
23:54:29 <Runaro> "The world's most convoluted fibonacci sequence generator"
23:54:50 <lispy> Oh, yeah because of the .0s I didn't realize it was fibs
23:55:14 <lispy> maybe you can add a ceil or floor to it
23:55:18 <lispy> :t floor
23:55:19 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
23:55:34 <Runaro> that would make it too verbose!
23:55:36 <Pseudonym> I bet I can write one that's more convoluted.
23:55:39 <olsner> > map floor (let (.-) = zipWith (-); (.+) = zipWith (+); (.*) (a:as) (b:bs) = a*b : ((map (*a) (0:bs)) .+ (map (*b) (0:as)) .+ ((0:as) .* (0:bs))); (./) (a:as) (b:bs) = (a/b) : ((as .- map (* (a/b)) bs) ./ (b:bs)) in (1:repeat 0) ./ (1:(-1):(-1):repeat 0))
23:55:39 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
23:55:57 <mahogny> that's a good way of attracting new users. way to go :)
23:55:58 <Gilly> ... :)
23:56:14 <Gilly> generating functions hidden in there i assume
23:56:17 <Gilly> am i right?
23:56:38 <Cale> Gilly: Yeah :)
23:56:54 <Gilly> rather nice actually :)
23:57:28 <lispy> ?quickcheck fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs) == map floor (let ...)
23:57:28 <lambdabot> Unknown command, try @list
23:57:36 <Cale> 1/(1 - (x + x^2))
23:57:48 <Gilly> yea
23:58:11 <lispy> ?let (.-) = zipWith (-)
23:58:20 <lambdabot> Defined.
23:58:20 <lispy> ?let (.+) = zipWith (+)
23:58:21 <lambdabot> Defined.
23:58:30 <Gilly> that's remarkable how easily you can define those functions
23:59:08 <lispy> ?let (.*) (a:as) (b:bs) = a*b : ((map (*a) (0:bs)) .+ (map (*b) (0:as)) .+ ((0:as) .* (0:bs)))
23:59:09 <lambdabot> Defined.
