00:02:16 <ski> unrelated, i don't like the syntax of `class alias Cxt => C a where ...' .. i'd prefer `class Cxt <=> C a where  ...' .. but then i'd also prefer `class Eq a <= Ord a where compare :: a -> a -> Ordering; ...' (or `class Ord a => Eq a where compare :: a -> a -> Ordering; ...' if you prefer)
00:03:23 <ski> the idea being that we want to be able to think of class contexts as propositions (that some types are related by some type-classes / relations)
00:03:43 <ski> and then `=>' should mean implication and `<=>' should mean equivalence
00:04:29 <ski> however, the `=>' in the type signatures is ok
00:05:32 <adu> the more I learn about Fortress traits the less I think they resemble typeclasses
00:06:44 <ski> (if we have a logical reading of class contexts, then i think it would be simpler to think of possible extensions like `instance (forall a. Show a => Show (f a)) => Show (Fix f) where ...')
00:08:02 <ski> any comments on my venting ? :)
00:11:26 <adu> hi ski!
00:12:39 <adu> ski: makes sense to me
00:12:52 <adu> ski: but I don't think you could do that now
00:13:17 <povman> any gtk2hs type people, do know how to make an editable treeview? Each time I change the text and press enter, it goes back to what it was....
00:13:27 <ski> lo adu
00:14:37 <adu> I think Fortress traits should be more like Haskell typeclasses, but I think Haskell tuples should be more like Fortress tuples...
00:15:11 <ski> adu : well, i suppose if this would be tried, we would start with having option for implementation to flip meaning of `=>' in `class' declarations (or require `<=' instead, if preferred) .. then if people think this is a good idea, one could change the default in later releases, but keep a flag for reversing back for quite some while
00:15:57 * ski is not familiar with anything in Fortress
00:17:32 <ski> adu : maybe you'd like to elaborate ?
00:18:18 <adu> Fortress tuples allow (1, 2, x=3, y=4)
00:18:32 <Heffalump> are x and y field labels?
00:18:42 <adu> I dunno
00:18:48 <adu> i'm still learning
00:19:24 <Heffalump> ok, so what's good about the x= and y= bits?
00:19:38 <ohub> In Fortress the "provides" and "requires" thing (guards?) was nice for functions
00:19:49 <adu> ski: well at first I was thinking that what you are talking about could be implemented with that "a ~> f" notation, but upon further consideration I don't think so
00:21:32 <ski> adu : are you referring to infix type variables ?
00:22:06 <adu> ski: no I'm refering to higher-order typeclasses
00:22:24 <ski> descibed where ?
00:22:28 <ski> s//r/
00:23:03 <adu> ski: like "class F a b c d e => Bla a b c d e (c ~> d, e ~> a) where ..."
00:23:27 <adu> i don't know how to search the wiki, but theres a page about them
00:23:42 <ski> `(c ~> d, e ~> a)' being arguments to `Bla' ? .. signifying ?
00:24:21 <adu> nono
00:24:49 <adu> its an extension syntax, meaning c provides type information about d and e provides type information about a
00:25:24 <adu> http://en.wikibooks.org/wiki/Haskell/Advanced_type_classes
00:25:41 <adu> "class Eq e => Collection c e | c -> e where"
00:25:45 <adu> i got it totally wrong... hehe
00:26:44 <scook0> is there a nice implementation of a list-zipper sitting around anywhere?
00:27:50 <ski> adu : oh .. you were referring to fundeps
00:28:07 <adu> was I? I guess thats what they're called..
00:28:27 <ski> (which is not what i would call `higher-order typeclasses')
00:28:39 <ski> a higher-order typeclass would be something like
00:28:45 <ski> class Foo c a
00:28:47 <ski>   where
00:28:56 <ski>   foo :: c b => ..a..b..
00:29:15 <ski> where `c' is a parameter of `Foo' which is itself a typeclass
00:29:18 <adu> my mind hurts now
00:29:30 * ski has no idea what this would be useful for, though
00:29:36 <adu> lolol
00:30:14 <adu> I wish there were lower-order typeclasses
00:30:23 <ski> meaning ?
00:31:06 <ski> (btw, if you dodn't know, `fundeps' was short for `functional dependencies')
00:31:12 <adu> like: "foo :: Vector 3 v => v a" or something
00:31:19 <mmorrow>  scook0: Data.Seq (=> finger trees: Data.FingerTree) (see cons,view{r,l},split)
00:31:37 <adu> ski: ya, I figured as much
00:32:02 <ski> adu : maybe that could be called `dependent typeclasses' .. hm
00:32:16 <ski> (or maybe not)
00:32:20 <dolio> The type families guys have talked about associated classes/class families.
00:32:28 <dolio> There are use cases.
00:32:34 <adu> well its certainly possible with dependent types, although I've heard conflicting definitions
00:33:08 <scook0> mmorrow: I'd still have to implement a zipper type on top of that, which is what I'm doing already with two lists and an element
00:33:25 <scook0> (i.e. I don't see how D.S would help my situation)
00:33:34 <adu> Some people say dependent typing is when you can use types as values, and some people say dependent typing is when you can express dependancies in type expressions, like being divisible by 3 or something
00:33:49 <mmorrow> but finger tree *are* essentially a zipper
00:34:33 <ski> afaik, dependent typing is using values on the type-level, especially values that won't be known until run-time
00:34:45 <mmorrow> scook0: http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
00:34:47 <lambdabot> Title: Finger Trees: A Simple General-purpose Data Structure
00:35:03 <ski> (++) :: Vector m a -> Vector n a -> Vector (m+n) a
00:35:14 <scook0> but D.FT doesn't have a zipper-like interface
00:35:35 <adu> ski: There was a paper that used that approach, but AFAIK, that was a hack to simulate a dependent type system (where you wouldn't need to recreate natural numbers on the type level)
00:36:03 <ski> Vector :: Natural -> * -> *
00:36:07 <mmorrow> scook0: yeah true, i guess it depends on what you want it for
00:36:26 <scook0> I want a list zipper!
00:36:48 <mmorrow> scook0: as a means to do something else or for its own sake
00:36:57 <mmorrow> ha
00:37:18 <scook0> what I'm actually implementing is an inventory system
00:37:21 <scook0> with a series of pages
00:37:22 <adu> isn't that just ([a],a,[a])?
00:37:30 <scook0> that you can scroll back and forth between
00:37:35 <scook0> adu: yes, that's my representation
00:37:44 <adu> then you did it right
00:37:54 <ski> Zipper [] a
00:37:59 <ski> (we wish)
00:38:02 <scook0> what I wanted was for someone to have written a bunch of common operations (prev, next, curr, initial, final)
00:38:08 <mmorrow> with Seq you can access both ends of the "list" equally as efficiently
00:38:10 <scook0> so I didn't have to write them myself)
00:38:15 <adu> o
00:38:26 * ski wonders whether `Zipper' could be a good use of type families ..
00:38:43 <adu> well I would think that that would be included in the operations you are doing on them
00:40:00 <adu> like "f ([w], x, y:z) = f (w++[x], y, z)"
00:40:16 <adu> oops I didn't do anything
00:40:39 <scook0> e.g. I'd like my implementation of the "next page" key
00:40:50 <scook0> to be showMenuPage (next z)
00:41:33 <adu> ski: why isn't "Zipper [] a" a posibility?
00:41:43 <ski> adu : maybe it is
00:42:31 <adu> I mean couldn't you implement "Zipper []" independantly of "Zipper Tree"? isn't that the whole point of typeclasses?
00:46:11 <scook0> @hoogle a -> (a -> Maybe a) -> a
00:46:12 <lambdabot> No matches, try a more general search
00:52:07 <quicksilver> adu: the problem is that for useful zippers on interesting types you end up with unique operations.
00:52:16 <quicksilver> the set of completely standard ones isn't obvious
00:52:18 <quicksilver> well, not to me.
00:52:37 <quicksilver> every time I've written a zipper it's either been lists, or it's been an ADT and had custom ops.
00:52:49 <adu> ya, thats true
00:53:09 <adu> so do you get the whole derivative thing?
00:54:35 <adu> how Zipper y x = dy/dx ?
00:59:38 <audreyt> @pl \f x y -> f x (fromAtom y)
00:59:38 <lambdabot> flip flip fromAtom . ((.) .)
01:03:28 <audreyt> @pl (\f x y z -> f (fromAtom x) y z)
01:03:28 <lambdabot> (. fromAtom)
01:16:29 <Staz> Hi, I have been trying to understand this problem for hours now :
01:16:38 <Staz> remainder = fix (\f a b -> if a < b then a else f (a-b) b)
01:16:45 <Staz> fix f = f (fix f)
01:17:15 <adu> well I can tell you what the second part means
01:17:32 <Staz> adu : anything would be much appreciated
01:17:34 <adu> Staz: "fix" is the fixedpoint operator
01:18:13 <adu> Staz: so for example if "f x = x / 2", then "fix f = 0"
01:18:38 <adu> because 0 is a fixed point, f 0 = 0
01:19:36 <therp> staz: if you want an intuitive grasp of "fix", "foo = fix (\f \x \y -> (expression .. (f ..))" is semantically equivalent to "foo x y = expression .. (foo ..)"
01:19:55 <adu> Staz: when "fix f" is evaluated, its evaluated as fix f = f (fix f) = f (f (fix f)) = f (f (f (fix f)))
01:20:22 <Staz> adu : Yeah I found unfolding the expression a few times like you did above helped :)
01:20:31 <adu> ya
01:20:44 <adu> Staz: so anyways, now onto the first part...
01:21:05 <adu> (\f a b -> if a < b then a else f (a-b) b) plays the role of "f" in the second part
01:26:07 <adu> another way of thinking about it is "remainder x y = fix (\f -> remHelper f x y)"
01:27:15 <Staz> thanks adu / therp.
01:27:27 <Staz> I reckon if I read over your comments enough times I will finally get it
01:27:38 <adu> but anyways, theres another key insight
01:27:51 <adu> division is iterated subtraction
01:28:00 <adu> :)
01:28:00 <Staz> yep I understand that part
01:28:06 <quicksilver> adu: that's intuitively true but not actually true.
01:28:12 <adu> quicksilver: hehe
01:28:22 <quicksilver> adu: the /2 example, I mean
01:28:31 <adu> o
01:28:38 <quicksilver> > fix (\x -> x/2)
01:28:42 <lambdabot>  Exception: <<loop>>
01:28:54 <quicksilver> doesn't terminate. Haskell can't find that kind of fixed point.
01:29:19 <quicksilver> that generates, essentially the infinite expresion (_|_/2/2/2/2/2/2/2/2/2/2/2/2/2/2/2/2....)
01:29:22 <adu> ok, I figured it would at least give 0.000000000...
01:29:25 <quicksilver> which fails to terminate
01:29:32 <quicksilver> although intuitively it "is" 0.
01:29:40 <quicksilver> at least, 0 is the limit of the obvious series.
01:30:11 <quicksilver> from a programmer's perspective, fix just reifies recursion
01:30:21 <quicksilver>  remainder = fix (\f a b -> if a < b then a else f (a-b) b)
01:30:42 <adu> Staz:  you might also look at "Continuation Passing Style" that might help, or confuse things more, who knows
01:30:44 <quicksilver> remainder = \a b -> if a < b then a else remainder (a-b) b
01:30:53 <quicksilver> these two are equivalent
01:31:01 <quicksilver> fix is a way of rewriting recursive definition
01:31:06 <quicksilver> so they don't use recursion explicitly
01:31:32 <quicksilver> at least, that's a very concrete operational view of fix
01:32:17 <audreyt> I wonder if it makes sense to have a dedicated hackage bot to announce new uploads
01:32:27 <audreyt> or if it's better coded as a plugin to an existing bot here?
01:32:45 <therp> I wouldn't want to see that actually
01:32:55 <adu> me neither
01:33:23 <audreyt> *nod* okay then
01:33:32 * quicksilver is surprised
01:33:34 <quicksilver> I'd like that
01:33:36 * quicksilver shrugs
01:33:40 <quicksilver> no accounting for tastes.
01:33:52 <therp> quicksilver: probably an RSS feed in your personal RSS reader?
01:34:37 <audreyt> main reason for such a bot is giving the channel a constant source of things to talk about
01:34:58 <therp> audreyt: that never worked for ghc testsuite problems in #ghc
01:35:19 <audreyt> well, different social settings, but yeah, so I'm not pushing this idea too hard :)
01:35:35 <audreyt> (it worked wonders over there in #perl, but again, different social settings.)
01:36:08 <therp> audreyt: but otoh it's not that hard for me to /ignore such things.. so feel free to try.
01:36:19 * dons waves from hackathon day 2
01:36:25 <audreyt> hi dons :)
01:37:06 <dons> hey audreyt -- you'll have to drop by one of these hackathons soon, I think you'd love it. :)
01:37:09 <adu> well I would imagine if I used the hackageDB more often I would want that, but since I've only used 1 package so far (Yi) and thats not counting Cabal and FilePath and Darcs which it required
01:37:17 * audreyt points to the original question about re: rss feed display in lambdabot
01:37:21 <dons> photos from day 1 at http://blog.well-typed.com/
01:37:22 <lambdabot> Title: blog.well-typed.com
01:37:34 <dons> audreyt: oh? i've a general rss plugin interface to lambdabot
01:37:42 <dons> it just needs some galois xml and rss libs, to be released
01:38:00 <audreyt> ah. waiting eagerly for it. (particular use case: announce hackage uploads in #haskell)
01:38:19 <dons> ok. i just need to release the galois web libs sometime next week
01:38:34 <audreyt> whee. dons++
01:38:45 <Heffalump> what do they do?
01:38:49 <Heffalump> the web libs, that is
01:38:58 <dons> there's a bunch of libraries for web app programming
01:39:13 <dons> xml-light, sqlite , rss and atom parsing, templating, curl
01:39:28 <dons> the selenium web testing lib
01:39:28 <adu> ooo
01:39:31 <Heffalump> cool
01:39:38 <hpaste>  morrow pasted "TH.Quote and dataToQa" at http://hpaste.org/6941
01:39:57 <Heffalump> so does darcs currently have its own curl binding?
01:40:02 <dons> it does, yes.
01:41:56 <dons> audreyt: so diving full on into haskell dev for your new project?
01:42:04 <audreyt> actually old projects too
01:42:16 <audreyt> <- too have piles of not-yet-release-ready-code
01:42:21 <dons> yay :) audreyt++ energy!
01:42:58 <audreyt> in $job I've been trying to do something like the Domain Workbench, of course not as ambitious, but the same idea applies
01:43:15 <audreyt> namely a pretty web UI for users to construct something that can be annotated by coders into DSLs
01:43:25 <audreyt> surely an approach familiar to many in this channel :)
01:43:40 <adu> isn't "(+1)dons" more appropriate?
01:44:04 <audreyt> no, that would succ
01:44:13 <adu> lol
02:40:46 <lazypuree> how to syntax here documents to GHC ?
02:41:20 <Lemmih> lazypuree: GHC doesn't have here documents.
03:02:08 <Lycurgus> nonetheless, you should be able to use the capability in shells and the like to send haskell text to ghc in the normal way
03:07:39 <ivanm> what are "here" documents?
03:08:33 <rakir> They are essentially multi-line strings in scripting languages ...
03:09:10 <rakir> Like (in ruby) here = <<ENDHERE
03:09:17 <rakir> this is the here documents
03:09:20 <rakir> <<ENDHERE
03:10:35 <ivanm> ahhh, k
03:11:32 <lazypuree> Lycurgus: what shell capability, can you point me to example ?
03:34:34 <dons> woot, nixos, http://reddit.com/info/6fiqi/comments/
03:37:58 <dolio> Is there another ICFP coming up?
03:38:07 <dolio> Seems like the last one just happened.
03:38:08 <ivanm> dons: now if only they chose a better implementation language... :p
03:39:35 <dolio> Man, no /usr, /lib or /opt? Madness.
03:45:58 <ivanm> dolio: is this nixos?
03:46:20 <dolio> Yeah.
03:46:35 <dolio> One of their example packages is xmonad.
03:46:40 <dolio> It's famous, apparently.
03:46:42 <ivanm> gobbolinux only keeps them for compatability reasons, IIRC
03:47:15 <dolio> Yeah, I'm actually sympathetic to that sort of thing.
03:47:19 <Twey> And optionally hides them
03:47:22 <Twey> Mmmm
03:47:30 <Twey> I like Gobo
03:47:42 <Twey> But I don't like that it's verbosified its paths
03:47:43 <dolio> Nix, apparently, gets away with only a symlink for /bin/sh, according to the paper.
03:49:06 <Twey> Kind of superficial, I guess, but there's a reason we have /sys and not /System.
03:49:31 <ivanm> Twey: IIRC, due to limitations on filesizes, memory, etc.
03:50:32 <Twey> ivanm: Hmm?
03:55:22 <ivanm> Twey: actually, forget that, since I can't find any reference to back me up :p
03:55:27 <Twey> Heh
03:55:41 <Twey> Three character limit sounds a bit low
03:55:47 <Twey> Even DOS did better than that :-P
03:55:56 <ivanm> laziness?
03:56:19 <Twey> Because people don't want to have to type /System :-)
03:58:33 <ivanm> exactly, laziness
03:58:39 <Twey> And RSI :-)
03:58:39 <ivanm> same as the lack of capital letters
04:19:44 <Cale> and lack of tab completion
04:20:20 <opqdonut> it's just basic hacker laziness
04:20:50 <opqdonut> stick with the shortest (but mnemonic) unique prefix
04:20:51 <opqdonut> :P
04:27:58 <dolio> My shell would complete /sys to /System.
04:28:57 <Twey> Yes, but that's like being a Java programmer
04:29:16 <Twey> 'I don't care if my language requires insane amounts of useless boilerplate, my IDE fills it in for me'
04:30:10 <idnar> well, if the IDE can completely remove the boilerplate from your consideration, then it's not a problem
04:30:18 <idnar> the main problem is when you have to edit that boilerplate by hand
04:30:35 <ndm> idnar: that never happens, since you always need to modify it at some point, when things go wrong, and you have to have it in version control etc
04:30:38 <idnar> I mean, you don't complain about all the JPEG header boilerplate when you're taking a photograph
04:30:40 <Twey> It's not not a problem -- it's a hack
04:30:53 <idnar> it's irrelevant, you never even have to see it
04:30:55 <Twey> The point is, source code is meant to be human-editable
04:31:13 <ndm> idnar: give an example of code which is hidden by the IDE you've never had to edit
04:31:35 <idnar> ndm: I don't know if there is such an example
04:31:38 <ndm> I've never used a programming system in anger and had the boilerplate effectively hidden by the IDE
04:31:41 <Twey> The problem is that the boilerplate exists in the first place, having the IDE take care of most of it is hacking around it, not fixing said program
04:31:45 <idnar> I'm just saying that the problem is not the boilerplate
04:31:52 <idnar> the problem is that you have to interact with the boilerplate
04:32:14 <dolio> I'm not sure storing programs in /System instead of /sys is the same as having to read Java code.
04:32:15 <idnar> you can avoid that interaction in various ways, most of which involve offloading the problem on another piece of software
04:32:20 <Twey> No, having to interact with the boilerplate is a symptom of the problem
04:32:40 <idnar> the IDE can hide it from you, or the compiler can do without it, or you can write libraries that abstract it away
04:32:41 <Twey> Boilerplate should be handled by the compiler when it converts human-readable code to machine-readable instructions
04:32:47 <idnar> ultimately the information has to exist somewhere
04:32:49 <ndm> i assume everyone in this discussion uses either Scrap Your Biolerplate or Uniplate?
04:33:07 <Twey> ndm: No, I use Python and Haskell instead.  :-)
04:33:17 <dolio> Those are both Haskell.
04:33:22 <Cale> ndm: I'm not even sure that's the level of boilerplate they're discussing :)
04:33:29 <ndm> Twey: those are both haskell libraries for reducing boilerplate code
04:33:32 * Twey takes that back.
04:33:39 <Twey> Yes.  Heh
04:33:49 <Twey> I'm not a great Haskeller yet alas :-)
04:34:05 <tcr> ndm: Apropos Uniplate; could it be that semantics have changed within last half year? I'm now facing some non-termination bug that I haven't seen before my update.
04:34:23 <ndm> tcr: possibly, i think descendBi changed slightly
04:34:36 <EvilTerran> Derive and TH are also good for reducing boilerplate
04:34:50 <ndm> tcr: previously descendBi on two equal types would descend one level, now it doesn't
04:35:46 <ndm> tcr: if you are doing recursion, you should be using descend not descendBi in the recursive loop, and descendBi once at the begining
04:35:53 <tcr> ndm: I only use childrenBi and universeBi
04:36:13 <ndm> tcr: childrenBi may have the same effect as descendBi
04:36:24 <ndm> tcr: do you have your code online anywhere? in particular the childrenBi bit
04:37:08 <tcr> I do use descendBi too, that said.
04:37:50 <ndm> tcr: descendBi and childrenBi should not be used in a recursive loop
04:37:53 <tcr> I use descendBi in the recursive invocation; is that change documented somewhere?
04:38:15 <ndm> tcr: not yet, i'm still not 100% sure of the right behaviour
04:38:50 <ndm> tcr: the current way makes it easy to get non-termination, the previous way made it easier to be wrong, i really want the interface that is 100% safe and obvious by default
04:38:53 <tcr> That sucks for me. How am I supposed to release software depending on Uniplate?
04:39:20 <ndm> tcr: i will freeze the interface as it is, and release a new version
04:39:28 <ndm> tcr: when are you hoping to release your code?
04:39:46 <tcr> End of April is the deadline that I'm given
04:40:07 <ndm> cool, ok, i will guarantee that childrenBi and descendBi do exactly what they do now
04:40:15 <ndm> and that you'll have a release in the next week
04:40:50 <tcr> Ok, so could you please explain the current behaviour?
04:41:08 <ndm> descendBi on types alpha beta, will take you from alpha to beta
04:41:12 <paolino> any cabal-developer around ?
04:41:21 <ivanm> paolino: ping kolmodin_
04:41:25 <ndm> tcr: do you have a code fragment with the descendBi use in - easier to show by example
04:41:35 <ivanm> paolino: he was around before
04:41:40 <ndm> tcr: email me if its private code, and it doesn't need to be enough to work
04:41:51 <tcr> ndm: I do.
04:46:21 <tcr> ndm: Sent.
04:47:19 <ndm> tcr: in the last line, i think you can  replace descendBi with descend
04:48:43 <ndm> tcr: the general rule is use descend wherever you can, and i will write up a thing on how to use descendBi safely shortly
04:48:46 <tcr> Yeah, but that's only because this is a special case.
04:49:52 <ndm> the problem is there is kind of a tension between descend which goes down one step and dsecend which finds the right type
04:50:11 <ndm> i think the solution may be to introduce descend1Bi and descend0Bi, which have different behaviours
04:50:37 <tcr> When can a use of childrenBi be problematic?
04:51:02 <ndm> descendBi and childrenBi are only a bit weird if both the source and destination types are the same
04:51:18 <ndm> in which case a use of descend or children will fix it
04:51:53 <tcr> I use childrenBi as "get me data of that-or-that type, but only descend to a level where you found the first occurence"
04:52:06 <tcr> Or at least, that's what my memory says :)
04:52:07 <ndm> yep, thats correct
04:52:34 <ndm> i.e. given (Left 1), childrenBi (Left 1) = [1]
04:53:08 <ndm> descendBi has the same behaviour, so descendBi (+1) (Left 1 ) = Left 2
04:53:15 <tcr> That Left stuff seems to be new, I think.
04:53:25 <ndm> thats just using the Either data type as an example
04:53:36 <ndm> i.e. assuming a Uniplate instance for Either
04:54:27 <ndm> the difference is descend tail "neil" = "nil"
04:54:41 <ndm> descendBi tail "neil" = "eil"
04:55:20 <mib_jln4ch> Hello
04:55:39 <paolino> mhh
04:56:27 <mib_jln4ch> Hello there
04:56:59 <mib_jln4ch> I have a question that might be completely trivial for u
04:57:44 <mib_jln4ch> I want to join two lists with haskell a la Sql
04:58:43 <EvilTerran> ... a la sql?
04:59:08 <mib_jln4ch> like we do in sql but in memory
04:59:29 <EvilTerran> ... i don't know what you mean by joining two lists like we do in sql
04:59:34 <EvilTerran> > "but this is how you jo" ++ "in two lists"
04:59:49 <lambdabot>  thread killed
04:59:52 <EvilTerran> ...
04:59:53 <EvilTerran> > "but this is how you jo" ++ "in two lists"
04:59:54 <lambdabot>  "but this is how you join two lists"
05:00:10 <EvilTerran> ?type (++)
05:00:15 <lambdabot> forall m. (Monoid m) => m -> m -> m
05:00:16 <mib_jln4ch> in linq (c#) i would do : from i in list1 join j in list2 on i==j select (i,j)
05:00:19 <EvilTerran> gah
05:00:25 <EvilTerran> ?type (P.++)
05:00:26 <lambdabot> forall a. [a] -> [a] -> [a]
05:00:43 <paolino> @type zip
05:00:44 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
05:01:01 <EvilTerran> oh, i see. you want to take the cartesian product of the two lists, and filter on some condition... that's a list comprehension
05:01:13 <EvilTerran> [(i,j) | i <- list1, j <- list2, i == j]
05:01:31 <mib_jln4ch> aha, but is there any special effecient way to do that?
05:01:52 <EvilTerran> not in general, no
05:02:09 <EvilTerran> you could use Sets or Maps instead of lists, that'd be more efficient under some circumstances
05:02:11 <mib_jln4ch> i c
05:02:53 <mib_jln4ch> because i can imagine say ordering both lists then joining
05:03:17 <EvilTerran> you could do that, yes
05:03:18 <xerox> .oO(if the elements are the same why collect tuples?)
05:03:37 <EvilTerran> that would be O(n.log n) instead of O(n^2)
05:03:44 <EvilTerran> but you'd have to code it manually
05:03:53 <EvilTerran> ?index sort
05:03:53 <lambdabot> Data.List
05:04:08 <mib_jln4ch> ok, you answered my question, thank u
05:04:10 <EvilTerran> you'd have to do the combining of the two sorted lists yourself
05:04:45 <EvilTerran> as i said earlier, Data.Map or Data.Set may also be worth a look
05:04:47 <mib_jln4ch> I know that linq is inspired from hqskell, thats why i was wondering if the join exists in haskell
05:04:59 <resiak> if i == j why do you want (i,j)?
05:05:04 <EvilTerran> but they don't have comprehensions like lists do
05:05:19 <mib_jln4ch> do u have a linq that goes through that please?
05:06:11 <mib_jln4ch> resiak the example is trivial, but imagine that both are different types that have something in common
05:06:44 <EvilTerran> ?docs Data.Map
05:06:44 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/4/Data-Map.html
05:06:55 <EvilTerran> ... is someone gonna fix that sometime?!
05:07:06 <EvilTerran> ?go site:haskell.org Data.Map haddock
05:07:07 <lambdabot> No Result Found.
05:07:20 <mib_jln4ch> My problem is that i have publicity networks that have there repartitions on cities, so i have to join repartitions with cities to calculate their performance on a chosen territory
05:07:37 <mib_jln4ch> thanks guys
05:07:42 <EvilTerran> ... sounds like something i'd do with SQL
05:07:47 <EvilTerran> to be quite honest.
05:08:10 <EvilTerran> it's eminently suited for such data manipulation
05:08:51 <mib_jln4ch> I wouldnt, both lists are large, and the application has a lot of users, so i wouldnt do it on the server
05:09:12 <mib_jln4ch> and I have a lot of calculations to do after the join
05:09:31 <mib_jln4ch> and i want these calculations to be expressed in haskell
05:10:16 <mib_jln4ch> like the sum of all covered population devided by the population of the territory
05:10:26 <EvilTerran> ... you can do that in SQL, i think
05:11:16 <mib_jln4ch> I have several reasons not to do with sql
05:11:19 <EvilTerran> ok
05:11:36 <mib_jln4ch> first I have 100 users semultaniously
05:11:36 <EvilTerran> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html
05:11:38 <lambdabot> http://tinyurl.com/34gle9
05:11:41 <EvilTerran> might be worth a look
05:12:05 <EvilTerran> i'm sure sql can cope with 100 simultaneous users
05:12:14 <EvilTerran> depending on which engine you're using
05:12:19 <mib_jln4ch> and these calculations are dont on each manipulation of the interface (modifying territory, adding networks)
05:12:51 <mib_jln4ch> *calculations are donE
05:14:21 <EvilTerran> Data.Map gives you O(log n) lookups and updates
05:16:44 <mib_jln4ch> I guess that some calculations are too complex to be done in SQL, especially that I would loose a lot of safety
05:17:16 <mib_jln4ch> I mean to write in the first place in sql
05:17:27 <mib_jln4ch> or maybe its just me
05:17:56 <EvilTerran> i agree about the loss of safety thing
05:18:25 <EvilTerran> unfortunately, i don't think there's a type-safe wrapper around SQL for haskell
05:18:32 <mib_jln4ch> I have other networks that are composed of base networks, and this complicates the whole thing. I ve done it with Linq already, but I beleive that haskell's syntax would be much clearer
05:19:31 <mib_jln4ch> but if such an algorithm is doable with list comprehensions in C#, it should be doable in haskell, am i not right?
05:21:05 <EvilTerran> are the list comprehensions in c# efficient?
05:21:22 <EvilTerran> it seems to me they'd take time proportional to the product of the list lengths
05:21:52 <mib_jln4ch> quite, the join takes 200 ms for two lists of 200 000 elements
05:22:25 <mib_jln4ch> no, one list of 200 000 and the other of 30 000
05:22:32 <Heffalump> LINQ presumably does some optimisation rather than just doing the naive thing
05:22:42 <mib_jln4ch> I guess so too
05:23:10 <mib_jln4ch> maybe the fact that you can mutate state behind the scenes
05:23:46 <Heffalump> that's not really relevant, it's just a question of what the implementation chooses to do
05:23:54 <EvilTerran> you could probably write an EDSL to do the same levels of cunningness within haskell
05:23:58 <Heffalump> it's a language construct rather than a bunch of native combinators
05:24:08 <EvilTerran> but there isn't one at the moment
05:24:11 <EvilTerran> (AFAIK)
05:24:29 <Heffalump> EvilTerran: yes, if you had a run function so that you got an optimisation opportunity
05:24:37 <EvilTerran> indeed
05:25:24 <Heffalump> btw on the subject of type-unsafety, my type safe SQL embedding is now sort of announced (but it's just development code so far, not a proper project): http://code.haskell.org/squiggle/unstable
05:25:24 <lambdabot> Title: Index of /squiggle/unstable
05:26:45 <mib_jln4ch> cant it be done inside in a monad on the bind operation? in linq it is done on Select()
05:27:13 <EvilTerran> the difficulty with doing it there is that the RHS of bind is abstract
05:27:15 <mib_jln4ch> i guess i can see the problem
05:27:35 <EvilTerran> so it can't optimise based on the bit after the bind
05:28:03 <Heffalump> you can if you have a restricted type on the left of the bind
05:28:09 <mib_jln4ch> so it would need a dsl
05:28:42 <EvilTerran> well, monadic combinator libraries are basically EDSLs too
05:29:25 <Heffalump> oh, no you can't, cos you don't know the return type
05:29:45 <EvilTerran> Heffalump, yeah, thatwas my thought
05:29:54 <mib_jln4ch> i wonder why this doesnt exist natively in haskell, i thought it is a recurring problem
05:30:08 <EvilTerran> "this"?
05:30:12 <resiak> Heffalump: that's a *lot* of boilerplate in Types
05:30:49 <resiak> Heffalump: oh, is this what your restricted monad post was taken from?
05:33:33 <Heffalump> resiak, yeah, I know; it's just much better to enumerate the base types
05:33:41 <Heffalump> resiak: that was the original source of the idea, yes
05:34:17 <Heffalump> though it had a rather more complicated history than just coming out of that code; what's in that code now is putting what I ended up posting back into the original app
05:34:43 <Heffalump> I may well end up making the boilerplate with TH once I've settled the design properly
05:36:19 <mib_jln4ch> cant i just implement a function [a] -> [b] -> (a->b->bool)-> [(a,b)]
05:37:01 <mib_jln4ch> i mean a join fuction
05:37:07 <EvilTerran> mib_jln4ch, yes, but it'll be O(n^2)
05:37:31 <EvilTerran> join xs ys p = [(x,y) | x <- xs, y <- ys, p x y]
05:37:40 <mib_jln4ch> doesnt that depend on  the implementation?
05:37:45 <EvilTerran> well, yes
05:37:48 <EvilTerran> but it's lists
05:37:55 <EvilTerran> they're O(n) to traverse, and you've got two of them
05:38:04 <mib_jln4ch> oh i c
05:38:27 <EvilTerran> and there's no Ord constraint or anything, so you can't arrange them into a more efficient structure
05:38:41 <mib_jln4ch> so sets can be better, implemented as binary trees
05:38:52 <resiak> Heffalump: neat stuff!
05:38:56 <EvilTerran> implemented as whatever they're implemented as, yes
05:39:11 <EvilTerran> O(log n) lookups/inserts/deletes, iirc
05:39:11 <mib_jln4ch> i can have  the Ord contraint
05:40:11 <mib_jln4ch> aha, i guess thats what i am looking for
05:52:18 <paolino> if they are ordered they can be eaten in parallel
05:54:02 <paolino> I mean ordered lists
05:56:01 <mib_jln4ch> aha
05:56:51 <mib_jln4ch> is that more effecient?
05:57:13 <mib_jln4ch> much more effecient?
06:00:02 <mib_jln4ch> i guess then it will depend on there ordering implemenation
06:04:23 <Saizan> well you need them to be ordered wrt the joining predicate
06:04:33 <paolino> it's possible they are already, ordered, n*log n to order them
06:04:49 <dcoutts> paolino: pong
06:05:03 <mib_jln4ch> what would be the type of the joing function then?
06:06:18 <mib_jln4ch> Ord [a],Ord[b] : [a]-> [b]-> (a->b->bool)->(a,b)
06:06:22 <paolino> dcoutts, do exist rules with match anything on the dependencies for cabal-make ?
06:06:55 <dcoutts> paolino: sorry, I don't understand what you're asking.
06:07:57 <paolino> pp preprocessor is a match anything rule on targets, or any target can be realized by pp
06:08:12 <Heffalump> mib_jln4ch: that should be Ord a and Ord b, btw, it's the elements youneed to be able to order, not the lists
06:09:01 <dcoutts> paolino: are you asking about the http://darcs.haskell.org/cabal-make/ ? as I know nothing about it, it's not supported by the cabal developers, you could ask conal
06:09:02 <lambdabot> Title: Index of /cabal-make
06:09:48 <paolino> dcoutts, thanks
06:10:58 <mib_jln4ch> oh yeah, sorry! that was inspired by c#
06:11:15 <paolino> dcoutts, how can I contact him?
06:11:28 <dcoutts> paolino: he's here in the afternoons
06:11:39 <dcoutts> @seen conal
06:11:39 <lambdabot> I saw conal leaving #haskell and #ghc 10h 42m 12s ago, and .
06:12:01 <paolino> my nights I suppose :d
06:15:02 <mib_jln4ch> thanks guys, that was helpful
06:15:50 <paolino> mib_jln4ch: a anb b must compare so a Ord c :: [b c] -> [a c] -> [(b c,a c)] or something people here can tell better
06:17:29 <Saizan> paolino: the only function that instances that type is zip, i think
06:18:39 <mib_jln4ch> i didnt really understand paolino
06:19:35 <paolino> mmhh (Ord c, Extract a c,Extract b c) -> [a] -> [b] -> [(a,b)]  and Class Extract a b | a -> b where extract :: a -> b
06:21:18 <paolino> mib_jln4ch: to merge the 2 ordered lists linearly , the 2 types must compare but Ord is Ord a, not Ord a b
06:21:54 <paolino> they must share a common type which support Ord
06:22:11 <paolino> or, that's where I arrive
06:22:15 <mib_jln4ch> i see
06:22:19 * SamB wonders how to get JHC's E pretty printer to repeat attribute-setting sequences after newlines -- or can less be made to remember these between lines?
06:22:42 <mib_jln4ch> oh thats right
06:23:04 <mib_jln4ch> ok thanks
06:24:09 <paolino> Saizan: a "waiting" zip is needed there
06:25:42 * SamB supposes it might work better to just avoid having newlines occur during colored portions of the text...
06:26:27 <romildo> Hi.
06:26:39 <romildo> Please, how do I convert from Int to Integer?
06:26:50 <SamB> fromIntegral will do it
06:26:54 <SamB> or you could use toInteger
06:26:58 <paolino> :t toInteger
06:27:00 <lambdabot> forall a. (Integral a) => a -> Integer
06:27:12 <SamB> :t fromIntegral
06:27:13 <lambdabot> forall a b. (Num b, Integral a) => a -> b
06:27:56 <romildo> thanks.
06:28:02 <SamB> but probably just fromIntegral would be the usual style
06:28:34 <SamB> @src fromIntegral
06:28:34 <lambdabot> fromIntegral = fromInteger . toInteger
06:28:41 <paolino> @info Integral
06:28:41 <lambdabot> Integral
06:28:51 <SamB> there is no @info command
06:29:00 <SamB>  @info => @id
06:29:10 <paolino> @id Integer
06:29:10 <lambdabot>  Integer
06:29:25 <SamB> or ... not
06:29:41 <paolino> :)
06:30:14 <SamB> where is lambdabot's repository now? still on dons's page?
06:30:28 <allbery_b> @version
06:30:28 <lambdabot> lambdabot 4p603, GHC 6.8.2 (Linux i686 2.40GHz)
06:30:28 <lambdabot> darcs get http://code.haskell.org/lambdabot
06:33:16 <paolino> @bot
06:33:16 <lambdabot> :)
06:33:45 <paolino> it's had a better machine , it seems
06:36:43 <romildo> And to convert from Double to Integer? The usual floor, ceiling and round, or is there any other way?
06:38:01 <allbery_b> those are them
06:39:56 <ttt--> @djinn Double -> Integer
06:39:56 <lambdabot> -- f cannot be realized.
06:40:09 <Deewiant> @djinn Double -> Float
06:40:09 <lambdabot> -- f cannot be realized.
06:40:34 <Deewiant> djinn, as usual, can't do much. :-)
06:40:36 <ttt--> @hoogle Double -> Integer
06:40:37 <lambdabot> No matches, try a more general search
06:41:05 <Deewiant> @hoogle (Integral a, Floating f) => f -> a
06:41:05 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
06:41:05 <lambdabot> Data.Generics.Aliases.unGM :: GenericM' m -> Data a => a -> m a
06:41:05 <lambdabot> Control.Monad.Error.Class.throwError :: MonadError e m => e -> m a
06:41:30 <jhonny> there is nothing wrong with marrying and getting 2 women in your life even 2 girlfriends. always have a back up and chase 2 or more women. 100's is better
06:43:08 <Baughn> "No instance for (IArray DiffUArray a)" <-- What module do I need to get this?
06:43:24 <Deewiant> Data.Array.Diff?
06:43:24 <SamB> Baughn: eh?
06:43:39 <SamB> where did you get the *type* from?
06:43:45 <SamB> oh, wait
06:43:51 <Baughn> HCodecs..
06:43:52 <SamB> you said "a"
06:44:06 <SamB> could you paste the code?
06:44:07 <Baughn> Hm. I'm not sure that makes sense at all - it wants an unboxed array of arbitrary type
06:44:22 <Baughn> So far it's just "importFile "sound.wav""
06:44:38 <SamB> where is the documentation for HCodecs?
06:44:45 <Baughn> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HCodecs-0.0.3
06:44:47 <lambdabot> http://tinyurl.com/6xw94d
06:45:26 <SamB> well, uh, it looks like you need to either pick an a, or use an appropriate context on your function
06:45:47 <Baughn> That's what I figured, yes
06:46:10 <Baughn> ..it's a bit troublesome, since I don't know what the resolution is on a wav file before loading it
06:46:29 <SamB> yes, the API doesn't seem too great
06:46:40 <Baughn> Also, it just froze on me
06:46:52 <SamB> perhaps you shouldn't use that library :-(
06:46:55 <Baughn> Apparently doesn't like 300MB wav files. Oh well. I'll have to write my own.
06:47:39 <SamB> what API do you wish hcodecs had?
06:48:03 <Baughn> I'm not sure yet
06:48:20 <Baughn> Something that will let me deal with sound files too large to fit in memory, certainly
06:53:58 <SamB> well, I meant in terms of how it deals with different possible sample formats
06:54:45 <SamB> too large to fit in memory, or too large to fit in the address space, anyway?
06:54:56 <Baughn> Memory. My address space is 48-bit.
06:55:20 <Baughn> Store it internally in whatever format the file used, provide a single function (perhaps parametrized over int types) to read out samples
06:55:33 <Baughn> Instead of converting it all at load, like HCodecs seems t want
07:00:20 <mib_jln4ch> Is there a Type Class that applys to lists that has a functions that sorts lists?
07:01:09 <twanvl> mib_jln4ch: no, but there is a sort function in Data.List
07:02:47 <mib_jln4ch> what i mean is for example [1..] is sorted already so that the implementation of such a class will be returning the list itself
07:03:48 <mib_jln4ch> and i wont to base my algorithm on a sorting class
07:04:12 <mib_jln4ch> * i want
07:04:21 <Baughn> mib_jln4ch: Typeclasses act on /types/, not values. They can't discriminate [1..] from [50,49..].
07:04:50 <mib_jln4ch> it can apply to constructors cant it?
07:05:02 <Baughn> No, just types
07:05:22 <Baughn> And [1..] is just syntactic sugar for (enumFrom 1). (I think)
07:05:24 <Baughn> > enumFrom 1
07:05:29 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:05:29 <nornagon> They can distinguish Cons (Succ Zero) (Cons (Succ (Succ Zero) (...)) from (Cons (Succ (Succ (Succ ... though
07:05:44 <mib_jln4ch> aha
07:05:48 <Baughn> Sure, if you put your arithmetic in the type system
07:05:52 <Baughn> But then you're not doing it at runtime
07:06:32 <Baughn> @type sort
07:06:33 <lambdabot> forall a. (Ord a) => [a] -> [a]
07:07:21 <Baughn> mib_jln4ch: Sort isn't /exactly/ part of the Ord typeclass, but still, that's where it belongs. I'm not sure exactly what you're trying to do, but if you just want to sort lists, all you need to do is instance Ord.
07:07:59 <Baughn> It would be kind of handy to have a Sortable class you could instance for arrays and such too, but.. oh well
07:08:19 <mib_jln4ch> aha thats whay i need, a sortable class
07:08:42 <mib_jln4ch> that checks type constructors for lists
07:09:04 <Baughn> mib_jln4ch: What do you mean, "check"? Check for what?
07:09:56 <mib_jln4ch> i mean implements the sorting mecanism by constructor, isnt [1..] a special constructor?
07:10:10 <Baughn> No.
07:10:22 <mib_jln4ch> cant i for example tell if it is this constructor then i return the list itself
07:10:50 <Baughn> [1..] isn't a constructor at all, in fact - it's the function call "enumFrom (fromInteger 1)"
07:11:08 <mib_jln4ch> i see
07:11:58 <Baughn> mib_jln4ch: So it's just another value. You can name values, and pass them around, and eventually pass [1..] to your sort function at runtime, unpredictably..
07:12:11 <mib_jln4ch> so there is no way to tell that [1..] is already ordered because it is runtime thing
07:12:14 <Baughn> mib_jln4ch: There are a lot of /other/ reasons why this won't work, but one of them is that values are passed at runtime, instance selection is done at compile-time, and as such you can't pick an instance based on the value
07:12:21 <Baughn> Yes.
07:12:58 <Baughn> mib_jln4ch: You could add a rewrite rule to turn sort [1..] into [1..], but it would probably only trigger if someone says exactly that
07:13:04 <Baughn> mib_jln4ch: And, well, why would someone write such code?
07:13:33 <mib_jln4ch> cant i define a list constructor say list seed incerementer= ....
07:14:02 <Saizan> mib_jln4ch: that'll be a function, you can't pattern match on functions
07:14:17 <Baughn> mib_jln4ch: Typeclasses/instance selection acts on *types*, not constructors
07:15:23 <Baughn> mib_jln4ch: If you have "data Foo = Bar | Baz", then both Bar and Baz produce a Foo - you can instance something for Foo, but not Bar or Baz.
07:15:50 <Baughn> Of course the instance can use pattern matching to run different code for each, but that happens at runtime
07:16:23 <Saizan> i don't think he's talking about type-level programming, but rather using class in a OO sense
07:16:55 <Baughn> Upcasts and such?
07:16:58 <Baughn> mib_jln4ch: Are you?
07:17:26 <mib_jln4ch> wait i ll try to decribe, however i suspect that my code will be broken because i am not fluent in haskell
07:17:28 <Baughn> mib_jln4ch: Perhaps I should say, what code would you like to be able to write?
07:18:36 <mib_jln4ch> list a = nothing | infinitlyIncrementingList incrementor seed | normalList head tail
07:19:02 <mib_jln4ch> there can be a type that looks somehow like this
07:19:09 <Saizan> yeah
07:19:09 <mib_jln4ch> right?
07:19:11 <Baughn> Sure, no problem
07:19:29 <Baughn> You'd use pattern matching to avoid sorting the infinitely incrementing version
07:19:58 <mib_jln4ch> exactly, and that would be a compile time pattern matching right?
07:20:00 <Baughn> "sortMyListType (InfinitelyIncrementing l) = l"
07:20:11 <Saizan> mib_jln4ch: no, runtime
07:20:15 <Baughn> mib_jln4ch: That's up to the optimizer. It might be, but don't rely on it
07:20:27 <Baughn> mib_jln4ch: It won't actually matter; the difference is only a few cycles
07:20:43 <Baughn> Semantically it's runtime, yes
07:20:43 <mib_jln4ch> isnt type constructors matching comiple time?
07:20:50 <Baughn> Type constructors, yes
07:20:55 <Baughn> But these are value constructors
07:21:23 <mib_jln4ch> oh thats what i dont get, that wasnt a type constructor?
07:21:56 <Baughn> Maybe is a type constructor, IO is a type constructor (both of one parameter), Either is a type constructor of two parameters..
07:22:12 <Saizan> in data Foo a = Bar, Foo is the type constructor and Bar the value one
07:22:20 * Baughn nods
07:22:41 <Baughn> Though it would normally be "Bar a"
07:23:08 <Baughn> Which would make Bar a constructor that takes a parameter of type a, where a is some type that is decided at compile-time by passing it to Foo
07:23:31 <Baughn> For example, you could say "Bar 42 :: Foo Int" to lock a as Int, although normally the type inference means you don't have to
07:28:21 <mib_jln4ch> I have an algorithm that depends on sorted lists, and its effeciency depends on the effeciency of parametered lists. What i wanted is a type class like Sortable, that is implemented effeciently for each type of lists
07:29:49 <Baughn> If the different kinds of list are all of the same type, as your earlier example suggested - just using different constructors - then all you need is some pattern-matching
07:31:19 <mib_jln4ch> and if they are different types? anyway they should implement "effeciently" the sortable class, am i wrong?
07:31:50 <Baughn> If they are different types, /then/ you use a typeclass
07:32:07 <Baughn> mib_jln4ch: I do get the impression that you're running before you can walk, though. Try to get through the tutorials first?
07:33:05 <mib_jln4ch> i went through tutorials but i guess my problem can be the i have a long history of imperative and oop programming
07:33:24 <mib_jln4ch> and i have a precise thing i want to do with haskell
07:34:01 <mib_jln4ch> anyway, i ll try to search, i just wanted to know if such a type class (sortable) exists already for list comprehensions
07:36:18 <Heffalump> no, it doesn't
07:36:47 <Heffalump> and the question would be whether it exists for lists; list comprehensions are just a syntactic convenience for constructing lists
07:37:00 <Heffalump> and they aren't overloaded and don't have any "optimising" desugaring
07:38:03 <mib_jln4ch> so that i cant tell join:: Sortable [a],Sortable [b] : [a] -> [b] -> (a->b->bool)->[(a,b)]
07:39:23 <mib_jln4ch> ok, i meant lists then. That answers my question, there is no overloading for lists for optimizations of operations like sorts
07:40:18 <Baughn> mib_jln4ch: Well, no. Generally people already /know/ if their lists are sorted.
07:40:20 <Saizan> there are lot of optimizations for consuming and building lists
07:40:38 <Saizan> in GHC at least
07:43:00 <mib_jln4ch> Baughn: what i am trieng to implement is a generic function, so i cant no in advance how sortable the list is, imagine for my function u pass me [1..] and then i try to sort it inside. It will block forever
07:43:14 <mib_jln4ch> i cant know in advance
07:43:23 <Baughn> mib_jln4ch: Right. You'll want to do that with pattern matching, not typeclasses.
07:44:05 <hpaste>  paolino pasted "an sql join ?" at http://hpaste.org/6943
07:44:51 <Heffalump> hi conal
07:45:06 <paolino> don't trust me to learn haskell anyway :P
07:45:47 <byorgey> mib_jln4ch: just make a special data type like you hinted at before.  data Sortable a = Incrementing a a | NormalList [a], or something like that
07:46:12 <Baughn> paolino: Looks like a join to me, although perhaps a bit hardcoded
07:46:58 <mib_jln4ch> ok
07:47:09 <conal> Heffalump: hi there
07:47:13 <mib_jln4ch> byorgey: ok, i ll try to do that
07:49:06 <mib_jln4ch> paolino: thanks for the code
07:49:06 <mib_jln4ch> i ll try to do that with a special data type
07:50:03 <mxc> according to YAHT, map on a FiniteMap runs in O(n log n) time, anyone know why its not linear in the size of the map?
07:50:49 <Heffalump> mxc: map, rather than mapKeys?
07:50:51 <Saizan> mxc: it depends if the map can modify the keys or not
07:51:04 <mxc> oh, right, stupid quesiton
07:51:07 <mxc> nevermind
07:52:01 <mxc> had a little brain freeze and was thinking of a map from a tree to a list instead of to a new map, which doesn't really make much sense
08:04:56 <Zut> Hello, Im trying to link some haskell and C together, and Im following http://therning.org/magnus/archives/315.
08:04:58 <lambdabot> Title: therning.org/ magnus » Blog Archive » Haskell and C&#8212;structs
08:05:05 <Zut> However, when I try to compile it all
08:05:29 <Zut> windows seems to think Im running some old DOS-program
08:08:26 <Zut> And what I make of it is that Im not giving the right arguments to hsc2hs
08:09:30 <Zut> Should I compile my haskell and C first, thru GHC and GCC, and shove the .o-files into it, or let it compile for itself, or maybe it doesnt matter?
08:10:20 <scook0> I generally get cabal to take care of everything for me
08:10:27 <scook0> (though I've not used haskell on windows)
08:11:02 <Zut> Take care of the linking?
08:11:02 <mxc> is a multi-threaded GC planned at all?
08:11:18 <mxc> oops, meant to type 'hi, is a multi...'
08:11:26 <scook0> Zut: I suspect that linking problems are unrelated to hsc2hs
08:11:44 <scook0> are you using GHC to do the linking?
08:11:45 <dejones> mxc: I think so, but it's not finished... so I heard.  I'd ask in #ghc to be sure.
08:12:24 <Zut> Well I suspect it's GCC linking
08:12:50 <mxc> followup, will using the -threaded option and -Nx automagically parallelize things like Data.List.map?
08:13:04 <Zut> since I dont specify linker, I think thats the default
08:13:28 <scook0> what are you actually using to combine the results of your C and Haskell compiles?
08:14:30 <Zut> at the moment, hsc2hs
08:15:12 <scook0> that really doesn't sound right
08:15:29 <scook0> hsc2hs is just a fancy source preprocessor, really
08:15:41 <scook0> at least as far as I've used it
08:15:46 <Zut> Ah
08:15:50 <Zut> well then
08:16:19 <Zut> Changes a few things, ty ;)
08:16:46 <sw17ch> @src splitAt
08:16:47 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
08:16:52 <sw17ch> is that really the best way to do that?
08:17:19 <Cale> sw17ch: No, and that's not really how it's done.
08:17:43 <scook0> the output of @src is mostly for informational purposes
08:17:55 <sw17ch> Cale: good... because I was suddenly very confused :)
08:18:02 <sw17ch> i figured zippers would probably be the best solution
08:18:03 <Cale> sw17ch: (but the semantics are equivalent, and the asymptotic costs are the same)
08:18:16 <sw17ch> Really? the same? wow...
08:18:33 <scook0> take is O(n), drop is O(n)
08:18:43 <Cale> Well, it's O(n) regardless, right?
08:18:49 <sw17ch> oh, good point
08:19:08 <sw17ch> but there is a way to avoid having to call both take and drop right?
08:20:28 <Cale> right
08:20:33 <Cale> You just recurse directly
08:21:17 <sw17ch> mm... alright, thanks. just making sure
08:22:44 <Cale> The costs won't quite be 1/2 of course, because you're still building new cons cells as you recurse, so it's not as cheap as drop alone, but at least you're not walking down xs twice.
08:23:35 <Cale> genericSplitAt          :: (Integral i) => i -> [b] -> ([b],[b])
08:23:35 <Cale> genericSplitAt 0 xs     =  ([],xs)
08:23:35 <Cale> genericSplitAt _ []     =  ([],[])
08:23:35 <Cale> genericSplitAt n (x:xs) | n > 0  =  (x:xs',xs'') where
08:23:35 <Cale>                                (xs',xs'') = genericSplitAt (n-1) xs
08:23:36 <Cale> genericSplitAt _ _      =  error "List.genericSplitAt: negative argument"
08:24:32 * SamB wonders if splitAt can be made fusable...
08:28:20 * Cale wonders why whenever he thinks of the words "Battlestar Galactica", he thinks of them in a thick Russian accent.
08:31:49 <johnnowak> Cale: now i'll be doing that too, thanks
08:32:32 <sw17ch> huh, i didn't realize i could use tuple unpacking (?)...
08:32:45 <sw17ch> (x,xs) = splitAt 20 randomIxList
08:32:46 <sw17ch> cool
08:33:28 <scook0> "tuple unpacking" is just regular old pattern matching :)
08:33:44 <sw17ch> scook0, yeah, i know... i just didn't realize i could do it in a let expression
08:33:59 <scook0> you can do all sorts of zany things
08:34:04 <scook0> > let 2 = 3 in 2
08:34:05 <lambdabot>  2
08:34:17 <sw17ch> hahah, fantastic
08:34:46 <sw17ch> i have one pattern match 6 lines long... and i'm not sure if that's a good thing
08:34:48 <scook0> you can even do the same stuff in top-level bindings
08:34:58 <scook0> as in 6 different cases?
08:35:29 <sw17ch> no, to understand it, i had to wrap it 6 times
08:35:40 <scook0> yow
08:35:46 <scook0> paste it if you want
08:35:51 <sw17ch> there's 5 or 6 nesting cases and 7 _'s
08:36:05 <scook0> sounds like you need some helper functions
08:36:32 <hpaste>  sw17ch pasted "pattern match" at http://hpaste.org/6944
08:36:41 <sw17ch> i'd tend to agree :)
08:36:56 <sw17ch> the worst part is how simple the result is
08:37:25 <sw17ch> though, the pattern match may not be all that bad (as long as you know what we're matching against...)
08:38:02 <scook0> oh, I see, you're doing a pretty deep match
08:38:28 <sw17ch> yes. it's in a "lisp parser" (hah, it's an awful one) and i'm checking whether a list is a "defun" or not
08:38:38 <scook0> for what you're using it for, it's probably excusable
08:38:42 <scook0> though it's still ugly :)
08:38:46 <sw17ch> and if it is, i extract the name of the defun, and if not, Nothing :)
08:38:53 <sw17ch> oh, it's pretty ugly... :)
08:39:01 <sw17ch> though the fact that it works wows me :)
08:39:04 * sw17ch loves haskell
08:39:43 <SamB> what does "LispExpr" mean?
08:39:52 <SamB> the constructor
08:39:53 <SamB> not the tpye
08:40:48 <sw17ch> LispExpr contains a representation (string) a value and a Parsec SourcePos
08:40:59 <sw17ch> data LispExpr = LispExpr Rep LispValue SourcePos
08:41:05 <sw17ch> deriving (Show, Eq)
08:41:16 <sw17ch> type Rep = String
08:41:37 <sw17ch> i need to check out here for a few minutes, i'll be back later
08:42:03 <scook0> it might be easier if you define a simpler variant of LispExpr, without the extra baggage
08:42:17 <scook0> then match on that, and if it succeeds, return the original LispExpr
08:42:26 <scook0> YMMV
09:07:18 <shachaf> @seen dons
09:07:18 <lambdabot> dons is in #darcs, #haskell, #xmonad, #haskell-hac4 and #haskell-soc. I last heard dons speak 2h 45m 7s ago.
09:13:41 <henrylaxen> I have several mysteries that are beyond my meager mental power to decipher.  I'm trying to wrap my head around the Control.Monad package.  I tried the following, from the Blow Your Mind Haskell Wiki:
09:13:42 <henrylaxen> f = sequence [even,odd] 4
09:13:42 <henrylaxen> and GHCi complained:
09:13:42 <henrylaxen>     No instance for (Monad ((->) a))
09:13:42 <henrylaxen>       arising from a use of `sequence' at /home/henry/haskell/b.hs:7:4-24
09:13:43 <henrylaxen>     Possible fix: add an instance declaration for (Monad ((->) a))
09:13:45 <henrylaxen>     In the expression: sequence [even, odd] 4 .....
09:13:47 <henrylaxen> However, if I add:
09:13:49 <henrylaxen> import Control.Monad.Fix
09:13:51 <henrylaxen> f = sequence [even,odd] 4
09:13:53 <henrylaxen> then it compiles just fine.  I looked through Control.Monad.Fix and could not find any reason for this to be so.  This is mystery # 1.
09:13:58 <henrylaxen> I then copied the file Control.Monad.Fix in my private directory, and renamed it MyFix.  It compiles just fine.  So I changed my program to:
09:14:01 <henrylaxen> import MyFix
09:14:03 <henrylaxen> f = sequence [even,odd] 4
09:14:05 <henrylaxen> and GCHi again complained as above.  This is mystery # 2.
09:14:07 <henrylaxen> Is there anyone out there who can shed some light on this for me?
09:14:16 <Botje_> henrylaxen: the ((->) a) instance is defined in Control.Monad.Reader
09:14:31 <Botje_> which is imported by Fix, i think
09:15:05 <twanvl> henrylaxen: For the code to work that particular instances needs to be imported, it is in Control.Monad.Instances (in recent Ghc versions)
09:15:11 <henrylaxen> Well, Fix only imports Prelude and System.IO
09:15:53 <esap> It's too easy to accidentally use the Monad instance of ((->) a).
09:17:03 <twanvl> on line 27: "import Control.Monad.Instances ()"
09:17:05 <shachaf> esap: The (r ->) instance is useful enough to justify that, I think.
09:17:38 <esap> shachaf: yes, it's useful. But sometimes it makes buggy code work just fine :-)
09:18:07 <shachaf> esap: If it works "just fine", then it's not buggy. :-)
09:18:12 <henrylaxen> You are right, importing  Control.Monad.Instances fixes the compile problem.  However, there is still mystery # 2.
09:18:13 <shachaf> esap: Can you give an example?
09:18:24 <gnuvince_> Does GHC come with a library to fetch an HTTP document?
09:18:53 <shachaf> > map ($ 4) [even,odd] -- :-)
09:18:54 <esap> shachaf: let me think - I have some code where I accidentally used that. Hold on.
09:18:54 <lambdabot>  [True,False]
09:20:32 <esap> shachaf: another thing is, you don't realize you have used that until you remove the import :-) So it's hard to find where you've used it :-)
09:21:00 <shachaf> henrylaxen: What changes did you make to Control.Monad.Fix when you renamed it?
09:21:07 <shachaf> henrylaxen: Perhaps you removed the import?
09:22:13 <shachaf> henrylaxen: It seems to work for me, when changing "module Control.Monad.Fix" to "module MyFix" and testing with -XCPP.
09:22:25 <henrylaxen> I only renamed the module, replacing module Control.Monad.Fix with module MyFix and placing the file in my local directory.  Otherwise it is identical.
09:22:52 <shachaf> henrylaxen: And you're compiling with -XCPP? The error is with the definition of f itself?
09:23:58 <henrylaxen> I wasn't, but I just did, with the same result: ghci -XCPP b.hs
09:23:58 <henrylaxen> GHCi, version 6.8.2: http://www.haskell.org/ghc/  :? for help
09:23:58 <henrylaxen> Loading package base ... linking ... done.
09:23:58 <henrylaxen> [1 of 2] Compiling MyFix            ( MyFix.hs, interpreted )
09:23:58 <henrylaxen> [2 of 2] Compiling Main             ( b.hs, interpreted )
09:23:58 <lambdabot> Title: The Glasgow Haskell Compiler
09:23:59 <henrylaxen> b.hs:7:4:
09:24:01 <henrylaxen>     No instance for (Monad ((->) a))
09:24:13 <esap> shachaf: I can't now remember what was the example. I do remember I once pasted some code and all the other people didn't get it working because they didn't see the import for Control.Monad.Fix :-)
09:25:44 <Botje_> henrylaxen: you edited MyFix.hs to change the module name too, right?
09:26:05 <henrylaxen> Yes, of course
09:26:47 <Botje_> k
09:28:46 <shachaf> henrylaxen: Perhaps this is an old version?
09:29:19 <henrylaxen> shachaf: Isn't GHCi, version 6.8.2 the most recent?
09:30:26 <shachaf> henrylaxen: I mean, of Control.Monad.Fix.
09:30:33 <shachaf> henrylaxen: Where did you get it?
09:31:15 <shachaf> henrylaxen: Does the file have an import of Control.Monad.Instances?
09:31:36 <henrylaxen> shachaf:  good question, let me look into that.  Thank you shachaf and Botje_ for all of you help.
09:33:06 <esap> shachaf: ah, actually, now I remember. It was this:   swap :: (b,top) -> (top,b) ; swap = rightAdjunct (,)   The function 'rightAdjunct' is from a type class called 'Adjunction', but there is no such constraint in this function...
09:33:41 <henrylaxen> shachaf: It is from a debian package, hugs version 98.200503.08-4
09:33:43 <esap> shachaf: And I suppose it was really the Functor instance that was used :-)
09:34:05 <shachaf> henrylaxen: Perhaps try another version and see if it works?
09:34:18 <henrylaxen> shachaf: Thanks, will do.
09:34:56 <shachaf> henrylaxen: http://darcs.haskell.org/packages/base/Control/Monad/Fix.hs might work.
09:35:18 <shachaf> esap: In sequence?
09:35:21 <shachaf> @ty sequence
09:35:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
09:35:25 <shachaf> Oh, wait.
09:35:35 <shachaf> esap: Sorry, mixed up. :-)
09:35:38 <esap> shachaf: no, not sequence
09:35:57 <shachaf> esap: Yes, I know.
09:37:06 <esap> shachaf: class (Functor path, Functor space) => Adjunction path space | path -> space, space -> path where { leftAdjunct :: (path top -> bot) -> top -> space bot ; unit :: top -> space (path top) ; rightAdjunct :: (top -> space bot) -> path top -> bot ; counit :: path (space bot) -> bot }
09:38:53 <esap> shachaf: there is also instance Adjunction ((,) a) ((->) a) which was used in that example
09:40:09 <esap> shachaf: defined as follows: instance Adjunction ((,) a) ((->) a) where { unit t = \arg -> (arg,t) ; counit (x,f) = f x }
09:40:47 <esap> shachaf: oh that requires the default implementations (which I left out from Adjunction definition to save space :-)
09:41:39 <esap> shachaf: the defaults are:   unit = leftAdjunct id ; leftAdjunct f = fmap f . unit  ; counit = rightAdjunct id ; rightAdjunct g = counit . fmap g
09:47:15 <shachaf> esap: This seems rather more complicated than the "regular" accidental use of (Functor (r ->)). :-)
09:48:48 <esap> shachaf: yea, well here it used the default implementation of rightAdjunct, the Functor subclass and the Functor ((->) a) instance. OTOH, I have to say it's in some sense OK to use those here...
09:50:19 <esap> shachaf: you can really implement 'swap' using rightAdjunct  - but it was originally surprising that that function didn't rely on the Adjunction constraint...
09:57:28 <henrylaxen> shachaf:  Thanks for you help.  I think I understand the mysteries now.  I compiled my version of GHC from source, and hence it installed the new binary libraries in its search path.  I installed hugs from a debian package, and hence when I looked at the source for Control.Monad.Fix, it was old.  importing Control.Monad.Fix imported the binary version.  importing my local copy was the old hugs version, which did not import Control.Monad.Instances as y
09:57:28 <henrylaxen> ou suspected.  Both mysteries now solved.  Thanks so much for you prompt help.
10:10:16 <gwern> hm. has anyone had any experience with network-bytestring?
10:10:20 <mauke> @index liftIO
10:10:20 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
10:10:25 <gwern> speedwise, how does it compare with curl?
10:14:46 <gwern> @hoogle unpack
10:14:46 <lambdabot> Data.ByteString.unpack :: ByteString -> [Word8]
10:14:46 <lambdabot> Data.ByteString.Char8.unpack :: ByteString -> [Char]
10:14:46 <lambdabot> Data.ByteString.Lazy.unpack :: ByteString -> [Word8]
10:20:13 <Sgeo> Is everyone in here sick of my Goldilocks joke?
10:20:19 <Sgeo> When will it be on the web?
10:21:55 <Sgeo> Does anyone even care what I said?
10:26:11 <sjanssen> Sgeo: what are you going on about?
10:26:35 <Sgeo> What did Goldilocks say upon seeing: Maybe (b -> Either a b) ?
10:27:18 <sjanssen> Just Right
10:27:46 <Sgeo> yes
10:27:57 <sjanssen> Sgeo: you should add that to the wiki -- there's a jokes/humor page
10:28:14 <Sgeo> "It's Just Right" was how I would put it
10:28:39 <mauke> @djin Maybe (b -> Either a b)
10:28:39 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
10:28:42 <mauke> @djinn Maybe (b -> Either a b)
10:28:43 <lambdabot> f = Nothing
10:29:06 <Sgeo> Where exactly should it go? I'm not adding a page for a two-liner
10:31:31 * Sgeo pokes sjanssen 
10:35:36 <s710b> http://www.haskell.org/haskellwiki/Humor
10:35:37 <lambdabot> Title: Humor - HaskellWiki
10:35:39 <Cale> "Just (\x -> Right x)"
10:37:14 * sjanssen prefers the eta-reduced version
10:37:42 <Sgeo> s710b, I'm not adding it directly on that pager
10:37:44 <Sgeo> *page
10:39:12 <s710b> Sgeo, Why not? There are already two-liners :)
10:39:35 <Sgeo> hm?
10:39:36 <Sgeo> where?
10:39:50 <s710b> http://www.haskell.org/haskellwiki/Humor/Slow
10:39:51 <lambdabot> Title: Humor/Slow - HaskellWiki
10:40:47 <Sgeo> ah
10:42:36 <Sgeo> http://haskell.org/haskellwiki/Humor/Goldilocks
10:49:09 <HairyDude> is there a released version of the binary library that uses the new bytestring api?
10:49:18 <HairyDude> or do I need the darcs version?
10:53:34 <HairyDude> oh, there's a 0.4.1... I was using 0.3 cos that's what I was pointed to by a README :)
10:53:58 <gwern> does anyone know of a way to download HTTP links using ByteString without ever going through String?
10:55:54 <Lemmih> gwern: System.Process + curl/wget.
10:56:48 <gwern> Lemmih: wouldn't curl/wget feed Process some CStrings?
10:57:14 <Lemmih> gwern: Nope, you'd get a Handle.
10:58:14 <gwern> Lemmih: hm. would this be faster than a FFI binding to curl and then packing into a bytestring?
11:02:29 <syntaks> hello
11:04:09 <Lemmih> gwern: Maybe.
11:06:44 <syntaks> does anybody know how to correctly use Data.Digest.SHA1 whith Strings? just using the ascii values from the string as the [Word8] input seems to yield results that are not consistent with other implementations
11:07:30 <syntaks> I thiunk there is some defined mechanism of how a string needs to be converted to a "message" but I haven't been able to figure out where that is defined
11:07:53 <Deewiant> syntaks: you don't want ascii values, I don't think, you want to convert each Word8 to its hex representation (e.g. 0xff)
11:08:42 <syntaks> Deewiant, you mean when I want to display the generated hash?
11:09:04 <Deewiant> > foldr showHex "" [0xff,0xab]
11:09:05 <lambdabot>  "ffab"
11:09:13 <Deewiant> syntaks: yes, as above.
11:09:44 <Deewiant> I'm not 100% sure mind you but this did work with Data.Digest.MD5 so I'm hopeful. :-)
11:10:36 <syntaks> Deewiant, I'm wondering about the input to the hash function
11:11:06 <Deewiant> oh, darn, input. well once again I only have experience with MD5.
11:11:17 <Deewiant> And there, just passing the string directly worked.
11:11:36 <Deewiant> I was using ByteStrings at the time so I just unpacked it.
11:12:23 <syntaks> Deewiant, for the string "abc", the SHA-1 spec states that it should has to a9993e36 4706816a ba3e2571 7850c26c 9cd0d89d but when I do hash [97, 98, 99] I seem to get something alse
11:13:12 <syntaks> but maybe I mess up in handling the resulting Word160... I'll just play around with it a bit more ;)
11:15:12 <Deewiant> syntaks: that's what I get here, "Word160 2845392438 1191608682 3124634993 2018558572 2630932637"
11:15:20 <Deewiant> which is the same as the above just printed in decimal.
11:15:29 <Deewiant> (using the Show instance for Word160)
11:15:33 <syntaks> you are right... I just tried the same thing again
11:16:10 <syntaks> so I am  messing up in handling the return value somewhere else
11:16:21 <syntaks> false alarm ;)
11:33:47 <gwern> @seen dons
11:33:47 <lambdabot> dons is in #darcs, #haskell, #xmonad, #haskell-hac4 and #haskell-soc. I last heard dons speak 1m 14s ago.
11:35:29 <dons> gwern: hey
11:35:36 <gwern> dons: hey, do you know of any fast HTTP libraries using ByteString? in my profiling of darcs I've found an awful lot of time is being wasted packing and unpacking strings for HTTP stuff
11:35:42 <dons> gwern: why not modify the darcs curl binding to return FastPackedStrings ?
11:35:56 <dons> gwern: the galois curl lib on code.haskell.org also supports bytestrings
11:36:01 <dons> as does network-bytestring , iirc
11:36:08 <dons> tibbe knows more.
11:36:14 <gwern> dons: network-bytestring just does sockets
11:36:48 <gwern> dons: I'm not sure how to go from the curl FFI bindings which return CStrings to ByteString - is CString -> ByteString fast?
11:36:51 <gwern> @seen tibbe
11:36:51 <lambdabot> I saw tibbe leaving #haskell-hac4, #haskell-soc, #darcs, #xmonad, #ghc and #haskell 39m 14s ago, and .
11:38:05 <ddarius> gwern: It should be easy to make a fast CString -> ByteString if one doesn't exist.
11:39:46 <sjanssen> gwern: if you don't need to copy the CString, it is very fast
11:39:58 <sjanssen> gwern: do you know the length of the string beforehand?
11:40:12 <gwern> I suppose I would want packCString :: CString -> IO ByteString
11:40:45 <gwern> sjanssen: I'm not sure. the issue here is slow HTTP downloads in darcs, so the downloads are done by curl/libwww and turned into Strings
11:40:49 <gwern> and then ByteString
11:41:00 <sjanssen> ah
11:41:04 <sjanssen> that is dumb
11:41:48 <gwern> sjanssen: eh. I find a lot of the structuring of darcs dumb. like roundy saying it's not worth it to add a dep on a crypto lib just to scrap a few hundred lines of code
11:42:26 <sjanssen> gwern: anyway, see Data.ByteString.packCString
11:42:44 * gwern already is looking at it
11:43:11 <roconnor> does Cabal need to get together with NixOS?
11:43:12 <sjanssen> and there are faster alternatives if you know the length of the string, or know that the CString is not mutated later
11:43:37 <gwern> roconnor: that would be sweet. if I had the time, I would totally install NixOS and make it the haskell distro
11:44:03 <roconnor> I guess I mean, does Cabal have anything to learn from NixOS?
11:44:17 <Sgeo> Wjat's NixOS?
11:44:17 <gwern> (#haskellers would run NixOS; their editor would be yi; they'd manage revisions with darcs, drive X with xmonad, and so on...)
11:44:31 <roconnor> @what NixOS
11:44:31 <lambdabot> http://nix.cs.uu.nl/nixos/
11:44:43 <Sgeo> ty robreim
11:44:46 <Sgeo> roconnor even
11:50:44 <roconnor> Sgeo: they have submitted a paper to ICFP, which I'm reading now.
11:50:46 <gwern> @hoogle peekCString
11:50:47 <lambdabot> Foreign.C.String.peekCString :: CString -> IO String
11:50:47 <lambdabot> Foreign.C.String.peekCStringLen :: CStringLen -> IO String
11:51:06 <Deewiant> the paper in question is at http://people.cs.uu.nl/andres/NixOS.html
11:51:06 <lambdabot> Title: NixOS: A Purely Functional Linux Distribution
11:51:41 <shachaf> Does anyone here actually run NixOS?
11:52:33 <Heffalump> kosmikus does, though he doesn't seem to be on here (and right now he's over there <-- talking)
11:53:22 <solrize_> nixos is a package management system, sort of an apt replacement, it's not an OS kernel like House
11:53:38 <shachaf> solrize_: I know (actually, Nix is the package management system).
11:53:53 <solrize_> it does look cool
11:54:07 <roconnor> The introduction of the paper is very exciting
11:54:30 <roconnor> I can imagine it potentially being a useful distribution for companies.
11:57:34 <TomMD> gwern: why wouldn't they run house?
11:58:22 <gwern> TomMD: the graphics part has a bad license, so it doesn't make much of a toy
12:02:04 <funktio> @pl \x xs -> x:x:xs
12:02:05 <lambdabot> liftM2 (.) (:) (:)
12:02:48 <funktio> > foldr (liftM2 (.) (:) (:)) [] [1..5]
12:02:49 <lambdabot>  [1,1,2,2,3,3,4,4,5,5]
12:02:58 <Baughn> @pl \f (a,b) -> (f a,f b)
12:02:58 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
12:03:05 * Baughn groans
12:03:18 <funktio> f *** f
12:03:22 <funktio> using arrows
12:03:24 <Japsu> > concatMap (\x -> [x,x]) [1..5
12:03:24 <lambdabot>  Parse error at end of input
12:03:27 <Japsu> > concatMap (\x -> [x,x]) [1..5]
12:03:27 <lambdabot>  [1,1,2,2,3,3,4,4,5,5]
12:03:31 <Baughn> @ty f *** f
12:03:32 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a, SimpleReflect.FromExpr (a b' c'), SimpleReflect.FromExpr (a b c)) => a (b, b') (c, c')
12:03:47 <roconnor> xmonad.nix
12:03:49 <roconnor> :)
12:03:57 <xerox> > join (***) f (x,y) :: (Expr,Expr)
12:03:58 <lambdabot>  (f x,f y)
12:04:22 <Japsu> @pl \x -> [x,x]
12:04:22 <lambdabot> ap (:) return
12:04:47 <shachaf> Is there no way of getting rid of that :: (Expr,Expr)?
12:05:06 <roconnor> > join (***) f (x,y)
12:05:06 <lambdabot>  Add a type signature
12:05:18 <xerox> squint your eyes
12:05:55 <tcr> So what do I do if :step doesn't return?
12:06:02 <resiak>  > join (***) f (x,y) :: Expr
12:06:17 <Baughn> tcr: Press ctrl-c?
12:06:38 <tcr> Baughn: I mean how do I debug this?
12:06:40 <Deewiant> > liftM2 (.) first second >>> ($ (x,y)) $ f :: (Expr,Expr)
12:06:41 <lambdabot>  (f x,f y)
12:06:59 <Baughn> tcr: If you have an infinite loop..
12:07:18 <Baughn> tcr: Well, the immediate symptom of :step not returning can be fixed by not compiling whatever function it doesn't return from
12:07:45 <shachaf> > f x
12:07:45 <lambdabot>  Add a type signature
12:07:46 <shachaf> > asE $ f x
12:07:47 <lambdabot>  f x
12:08:05 <tcr> Baughn: How is that supposed to be helpful?
12:08:22 <Deewiant> @ty asE
12:08:23 <lambdabot> Not in scope: `asE'
12:09:54 <Baughn> tcr: Last I checked (but the documentation doesn't seem to agree) you can only step through functions that are being interpreted
12:10:15 <Baughn> tcr: ghci will only interpret functions in loaded files if it doesn't find a compiled version, so..
12:10:22 <tcr> Baughn: Well, in my case it's Data.Map.lookup
12:10:59 <Baughn> tcr: The loop isn't in lookup. It could be in evaluating the key, or the value, or whatever is producing the map - but not the actual Data.Map code
12:12:13 <tcr> If so, :step would step into whatever produces the map. And at the point of the invocation, the map is already evaluated, afaics.
12:12:31 <tcr> Wouldn't it?
12:12:40 <Baughn> Unless that code has been compiled, yes
12:12:46 <tcr> Everything's interpreted.
12:13:00 <Baughn> ..then I don't know what the cause might be
12:13:14 <Baughn> tcr: Hang on. When it locks up - does it do so at 100% cpu, or none?
12:13:36 <tcr> That is, if :load at ghci produces interpreted versions of the file, and its dependencies, which I assume.
12:14:02 <Baughn> It'll produce interpreted files unless it can find a compiled version (of any file), sure. I think.
12:14:43 <Cale> hmm
12:14:45 <Cale> :t (.)
12:14:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:14:51 <Cale> :t asE
12:14:51 <lambdabot> Not in scope: `asE'
12:14:59 <Cale> > asE $ f x
12:14:59 <lambdabot>   Not in scope: `asE'
12:15:03 <Cale> okay...
12:15:12 <ddarius> Presumably asE = id :: Expr -> Expr
12:16:01 <tcr> Baughn: It seems to sleep
12:16:10 <tcr> Baughn: I'll try to attach strace
12:16:42 <Baughn> tcr: If it's sleeping, then that's simply a deadlock
12:17:09 <tcr> I'm not doing anything multi threaded, though.
12:17:40 <Baughn> You don't need to be. Something like "fix (+1)" will produce a deadlock just fine
12:17:59 <Baughn> Or, in general, any thunk that winds up requiring its own value to evaluate that value
12:18:23 <Baughn> The threaded RTS does usually detect those, though..
12:18:49 <ehird> <-> is a cool infix op. do any libraries use it?
12:18:52 <Baughn> ..not ghci, apparently because you can theoretically break the lock by pressing ctrl-c. It's very conservative.
12:19:28 <tcr> So to further debug this, I should try to compile and run it instead?
12:19:44 <Baughn> That would work. Be sure to turn on backtraces, to the degree that's possible.
12:19:58 <Baughn> And compile with -threaded
12:20:02 <Twey> @type (<->)
12:20:03 <lambdabot> Not in scope: `<->'
12:20:06 <Twey> Eh
12:20:48 <tcr> Baughn: Thanks, I'll try that!
12:21:02 <hpaste>  jberryman pasted "All prime/compound factors of a number" at http://hpaste.org/6945
12:21:12 <dcoutts> roconnor: I hope we're learning from Nix
12:21:18 <jberryman> I just finished my first useful chunk of code, it produces a list of all factors of an integer. If anyone would care to look at it and give me any feedback, I would be most grateful.
12:21:45 <dcoutts> roconnor: there are certainly some things I've learned, there is probably more to learn
12:22:08 <vixey> > let divides n d = n`mod`d==0 ; factors n = filter (divides n) [1..n] in factors 360
12:22:10 <lambdabot>  [1,2,3,4,5,6,8,9,10,12,15,18,20,24,30,36,40,45,60,72,90,120,180,360]
12:22:19 <aFlag> I need a function to shuffle a list, where will I find something like that?
12:22:28 <vixey> > let facs 1=[];facs n=dr n:facs(n`div`dr n) where dr n=(!!0)$filter((==0).(n`mod`))[2..n] in facs 360
12:22:29 <lambdabot>  [2,2,2,3,3,5]
12:23:16 <vixey> > permutations xs = [x:ps | x <- xs, ps <- permutations (xs\\[x])] in permutations "xyz" -- stolen code
12:23:16 <lambdabot>  Parse error at "=" (column 17)
12:23:21 <vixey> > let permutations xs = [x:ps | x <- xs, ps <- permutations (xs\\[x])] in permutations "xyz" -- stolen code
12:23:22 <lambdabot>  []
12:23:32 <vixey> http://davidtran.doublegifts.com/blog/?cat=2 buggy?
12:23:33 <lambdabot> Title: David Tran&#8217;s blog » Haskell
12:23:44 <Baughn> aFlag: Something like "map fst . sort . zip randoms" would work, albeit in O(n lg n)
12:23:59 <Baughn> map snd, even
12:24:47 <roconnor> dcoutts: I'm still reading their paper, It's quite exciting
12:27:44 <aFlag> randoms would be the list I want to shuffle?
12:27:53 <aFlag> oh, it's a function, actually
12:28:33 <aFlag> I see how that would work
12:29:49 <gnuvince_> Shouldn't Data.ByteString have the remove function?
12:30:40 <gwern> @hoogle unsafePerformIO
12:30:40 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
12:30:40 <lambdabot> System.IO.Unsafe.unsafePerformIO :: IO a -> a
12:32:45 <aFlag> Baughn, if I do that, will each element of the list have the same chance to be placed in any of the positions?
12:34:12 <aFlag> for instance, in [1,2,3], will all the possible lists [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,2,1], [3,1,2] have the same probability of happening?
12:34:23 <tcr> Baughn: -prof and -threaded don't seem to like each other; is there way to get backtraces nontheless?
12:35:53 <hpaste>  gwern pasted "monad confuzzledness" at http://hpaste.org/6946
12:36:03 <gwern> I has a confusion
12:36:33 <Sgeo> @hoogle randoms
12:36:33 <lambdabot> System.Random.randoms :: (Random a, RandomGen g) => g -> [a]
12:36:51 <Cale> gwern: What are those ï¿½ characters supposed to be?
12:37:13 <Lemmih> gwern: liftM/fmap instead of >>=.
12:37:20 <gwern> Cale: ah, <-  and .
12:37:24 <gwern> unicode
12:37:26 <jberryman> vixey, thanks for those code snippets.
12:37:39 <Cale> gwern: They don't seem to make it through hpaste :)
12:37:51 <gwern> Cale: no. this is not the first time it's happened...
12:38:12 * gwern has two chief plaints for glguy: too small pastes, and unicode mangling
12:38:33 <Cale> Whoa, that's using the old FPS library, eh?
12:38:35 <gwern> Lemmih: you mean like 'liftM unpackPS $ fn ustr fstr $ cachableToInt cache'?
12:38:37 <vixey> ?where hpaste3
12:38:37 <lambdabot> I know nothing about hpaste3.
12:39:02 <Lemmih> gwern: Yes. Or: fn ... `liftM` unpackPS
12:39:03 <tcr> Baughn: I know tried -prof, without -threaded, and +RTS -xs; and I get endless lots of <Main.CAF> at the point where it seems to be stuck in a loop.
12:39:12 <gwern> Cale: actually, it's a hideous wrapper around ByteString that looks like FPS
12:39:19 <Cale> unpackPS likely has type PackedString -> String ?
12:39:44 <Cale> and what are the types of err and fn?
12:39:45 <gwern> Cale: believe so
12:39:56 <shachaf> @hoogle unpackPS
12:39:57 <lambdabot> Data.PackedString.unpackPS :: PackedString -> String
12:40:17 <Cale> err presumably wants a String
12:40:22 <gwern> I'm not entirely sure what err is supposed to be, but fn should be returining a PackedString
12:40:45 <Cale> Is it returning a PackedString, or an IO PackedString?
12:40:45 <gwern> IO PackedString, actally
12:40:48 <Cale> aha
12:41:04 <Cale> So you don't want to pass the IO action to unpackPS, you want to run it first.
12:41:08 <gwern> yeah, you can't convert CStrings to ByteString without being in IO, it seems
12:41:34 <Cale> So the first way to think about this would be to write something like:
12:41:38 <gwern> apparently there was some mutation related bug when you could do CString -> ByteString
12:42:03 <Cale> do v <- fn ustr fstr (cachableToInt cache); err (unpackPS v)
12:42:25 <Cale> Of course, that's in the shape of an fmap/liftM
12:42:54 <Cale> er...
12:43:03 <gwern> you mean ); err <- (unpackPS v)? err is just a name
12:43:06 <gwern> not a function
12:43:19 <Cale> oh
12:43:20 <Cale> oh, right
12:43:36 <Cale> I forgot that the first block of unreadable characters was <-
12:43:43 <Cale> yes
12:43:45 <Cale> er, no
12:43:53 <Cale> let err = unpackPS v
12:44:01 <Cale> or simply
12:44:05 <Cale> return (unpackPS v)
12:44:10 <Cale> if that's the end of the action
12:44:18 <gwern> Cale: no, there's a null check first
12:44:22 <Cale> But that's an fmap/liftM
12:44:28 <Cale> So you can write:
12:44:41 <Cale> err <- fmap unpackPS (fn ustr fstr (cachableToInt cache))
12:45:04 <Cale> (you're applying unpackPS to the result of the action)
12:45:30 <fnoble> does GHC let you use a unicode character for the name of a function that isn't an infix operator?
12:45:41 <gwern> oh you and your fmaps
12:46:16 <bauchus> GLUT has an example module "ReadImage.hs". Is there a format in gimp, which matches the needed format?
12:46:23 <Cale> Well, it's a standard thing to do :)
12:46:35 <Toxaris> > let ö = 42 in ö
12:46:35 <lambdabot>   lexical error (UTF-8 decoding error)
12:46:38 <Toxaris> :(
12:46:49 <Cale> Toxaris: That's more lambdabot's fault than anything, I think.
12:46:51 <Toxaris> but that's just lambdabot, i don't think it should be a problem with ghc
12:47:14 <Cale> ghci doesn't seem to like unicode chars either
12:47:23 <fnoble> i can define a function like (â½) :: Float -> Float -> Float
12:47:37 <fnoble> but not â :: [Num] -> Num
12:47:47 <fnoble> for example
12:47:55 <shachaf> fnoble: [Num] -> Num?
12:48:06 <shachaf> fnoble: Do you mean (Num a) => [a] -> a?
12:48:18 <Cale> fnoble: Those are strange characters, what are they?
12:48:27 <Cale> fnoble: Symbol characters are infix.
12:48:29 <fnoble> just some random ones for an example
12:48:32 <hpaste>  mncharity pasted "Q&A example in Paterson arrows?" at http://hpaste.org/6947
12:48:33 <Toxaris> i guess it depends on the character class of the chars used
12:48:42 <Cale> fnoble: If you use letters, you can define non-infix functions
12:48:44 <shachaf> 233D APL FUNCTIONAL SYMBOL CIRCLE STILE
12:48:54 <shachaf> 220F N-ARY PRODUCT
12:48:57 <Cale> (for example, Î  should perhaps work.)
12:48:58 <fnoble> taken from the mathematical operators codepage
12:48:58 <Toxaris> my ghci works with both german and danish letters, which is enough for me :)
12:48:59 <gwern> stile?
12:49:07 <gwern> isn't that a thing you use to get over fences?
12:49:20 <Cale> oh, nope
12:49:28 <Cale> Î  is a capital letter
12:49:35 <Cale> So it would have to be a data constructor
12:49:57 <Cale> but Ï works as a function name
12:50:02 <Twey> > "Î "
12:50:03 <lambdabot>  "\928"
12:50:07 <fnoble> i see, so even for non ascii characters GHC sticks to its guns on no caps :)
12:50:13 <Cale> > toLower "Î "
12:50:13 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
12:50:18 <Twey> > isAlpha '\928'
12:50:19 <lambdabot>  True
12:50:20 <Cale> > toLower 'Î '
12:50:20 <lambdabot>  Improperly terminated character constant at "'Î '" (column 9)
12:50:23 <Twey> > isUpper '\928'
12:50:24 <lambdabot>  True
12:50:24 <vixey> > let Ï = "lambda bot is still broken ?" in Ï
12:50:24 <lambdabot>  Illegal character ''\128''
12:50:24 <lambdabot>  at "" (column 6)
12:50:28 <Twey> > toLower '\928'
12:50:29 <lambdabot>  '\960'
12:50:55 <vixey> lambabot should use UTF8..
12:51:16 <Cale> Patches accepted :)
12:51:16 <Twey> Hm
12:51:21 <Twey> Doesn't seem to work
12:51:21 <mncharity> the http://www.haskell.org/haskellwiki/Arrow page has a prominent link to a rather old post by Daan Leijen, which points out (no pun intended) the old arrow notation being more obscure than monads.  Paterson tried to address that.  My haskell fu is low - could someone who knows Paterson arrows double check ï»¿ http://hpaste.org/6947 before I update the wiki with it?  thanks.
12:51:25 <ArcSin_> Hi, I'm currently running GHC-6.6.1 and I'm running into this error " Could not find module `Data.Time.Format' " does anyone know where I should go to download the source code for it?
12:51:26 <Toxaris> so one could actually use greek letters for type vars like in papers
12:51:33 <Twey> \960 is some strange invisible character.
12:51:34 <fnoble> so \220F capital pi is the same as the one in the greek letters?
12:51:55 <Twey> > "Ð"
12:51:56 <lambdabot>  "\1055"
12:52:01 <Twey> Ah, they are different.
12:52:11 <Cale> ArcSin_: That's in the time library. It should come with GHC 6.8.2
12:52:11 <Cheery> !seen tnovelli
12:52:19 <Twey> Ð and Î , heh
12:52:24 <Cheery> @seen tnovelli
12:52:24 <lambdabot> I haven't seen tnovelli.
12:53:43 <Cale> mncharity: hmm...
12:53:47 <ArcSin_> thanks cale
12:53:49 <Twey> > "Ð°"
12:53:50 <lambdabot>  "\1072"
12:53:55 <Twey> > "Ð°a"
12:53:56 <lambdabot>  "\1072a"
12:54:00 <Twey> Mmmm
12:54:05 <Cale> ArcSin_: You could try to get the library from hackage, but it's probably easier just to upgrade.
12:54:13 * Twey forsees some major debugging problems.
12:54:17 <Cale> ArcSin_: 6.6 is less and less supported by new packages.
12:54:34 <ArcSin_> yeah that's what I'm doing
12:55:34 <Cale> mncharity: that code seems reasonable, I suppose -- what are you updating?
12:56:41 <sylence> someone knows a german haskell irc channel?
12:57:34 <Cale> mncharity: oh...
12:57:49 <Cale> mncharity: hmm, that doesn't seem right -- where is question bound?
12:58:16 <mncharity> ï»¿Cale: oh, right.  oops.  thanks.
12:59:09 <mncharity> re ï»¿"what are you updating?", the wiki Arrow page.  Leading to a 8 year old post saying "the old notation had problems" seemed non-ideal.
12:59:25 <mncharity> *Leading with
13:01:07 <Cale> http://www.haskell.org/arrows/index.html -- this might make a good first link.
13:01:08 <lambdabot> Title: Arrows: A General Interface to Computation
13:01:47 <mncharity> good idea.
13:03:03 <Cale> The wiki page surprisingly doesn't even have a description about what arrows are.
13:03:57 <aFlag> Baughn, take a look at http://okmij.org/ftp/Haskell/perfect-shuffle.txt look the "A sort-based algorithm and its critique" part of the text, if you're interested
13:04:46 <Cale> sylence: Maybe #haskell.de ?
13:05:19 <sylence> Cale: not really, 3 idle people there :/
13:05:27 <Cale> sylence: yeah...
13:06:08 <Toxaris> sylence: I don't think there are enough german-speaking, non-english-speaking, haskell and irc using people in the world to form an active irc channel :)
13:06:11 <syntaks> if I have data Foo a = Foo a a a is there some standard function like f :: Foo -> [a]?
13:06:43 <syntaks> or for example f (Foo 1 2 3) = [1, 2, 3]
13:06:52 <Toxaris> sylence: why do you ask?
13:07:08 <Cale> syntaks: If you define your own datatype, you're responsible for writing functions which work on it.
13:07:15 <vixey> syntaxs: You just gave its definition
13:07:25 <vixey> syntaxs: except you need to use x y z insead to 1 2 3
13:07:45 <syntaks> vixey, yeah, I was wondering whether there already is some general mechanism to do this
13:08:03 <vixey> no
13:08:15 <vixey> doesn't make sense
13:08:19 <vixey> @src Either
13:08:19 <lambdabot> Source not found. I feel much better now.
13:08:25 <Cale> Well, there is, sort of.
13:08:29 <vixey> Either a b -> [a :+: b] ?
13:08:35 <Cale> But it's not something which you'd likely use often.
13:08:58 <Toxaris> syntaks: there is "generic programming" which tries to allow the automatic construction of such functions
13:09:43 <Toxaris> syntaks: there are a number of libraries / preprocessors / whatevers available to add it to haskell, but it is mostly usable for big examples, not small ones
13:09:52 <Cale> and Data.Generics has some things you could use for that
13:10:01 <syntaks> Toxaris, I could also imagine using template haskell to do this sort of thing, but that also seemed like overkill
13:10:04 <sylence> Toxaris: i've an question to a german haskell exercise
13:10:05 <Cale> :t listify
13:10:06 <lambdabot> Not in scope: `listify'
13:10:14 <Cale> :t Data.Generics.Schemes.listify
13:10:16 <lambdabot> forall r a. (Typeable r, Data.Generics.Data a) => (r -> Bool) -> a -> [r]
13:10:24 <Toxaris> sylence: so ask it here and i'll try to help you :)
13:10:42 <sylence> Toxaris: you speak german?
13:10:57 <Toxaris> sylence: yes
13:11:50 <Toxaris> sylence: as long as we discuss the problem in english -- and haskell :) -- it should be fine for the people here, i guess
13:11:59 <syntaks> Cale, I'd need to dig into Data.Generics.... but this might be my opportunity to finally do just that ;)
13:12:19 <vixey> f (Foo x y z) = [x, y, z]
13:12:23 <Cale> Prelude Data.Generics Data.Tree> listify (const True) (Node 1 [Node 2 [], Node 3 [Node 4 [], Node 5 []]]) :: [Integer]
13:12:23 <Cale> [1,2,3,4,5]
13:12:54 <syntaks> vixey, that is clear, I am looking for something general that works for Foo a a, Foo b b b and so forth
13:13:03 <vixey> it looks like you want a dynamic language
13:13:21 <Cale> vixey: No, he just wants generics.
13:13:36 <Cale> There are a number of generics libraries.
13:13:52 <Cale> (of varying ease of use)
13:14:00 <sylence> Toxaris: okay, thanks. :) http://people.cs.uu.nl/andres/haskell/4.pdf < exercise 2: i found an implementation without "const" - and now i have no idea why the author wanted me to use const too...
13:14:28 <syntaks> vixey, I want an abstraction for the pattern "convert a datatype with a constructor that takes n arguments of the same type to a list of that type"
13:14:34 <sylence> Toxaris: Prelude> (\x -> sum (map (\x -> 1) x))     this is my solution to the problem, it works, but uses no const
13:14:54 <vixey> syntaks: Yes it's exactly the kind of thing you'd do in a dynamic language..
13:15:04 <Cale> sylence: const y = \x -> y
13:15:07 <vixey> syntaks: Maybe there's an easier way in Haskell
13:15:50 <syntaks> vixey, but isn't one of the aspects of dynamic languages that they don't have a real type system, while my problem explicitly is based on the fact that all arguments have the same type?
13:15:50 <Toxaris> sylence: well, Cale answered already while I was scanning the pdf :)
13:16:06 <vixey> syntaks: no
13:16:11 <Cale> vixey: uh, yes :)
13:16:23 <vixey> syntaks: what do you do with the list though?
13:16:45 <vixey> Cale: values have types not variables, whether the type system is 'real' or not is a different issue
13:16:50 <Cale> Oh, another abstraction you could use is Foldable
13:16:54 <Toxaris> syntaks: but you loose type information on the way (exactly: you go from "exactly three values of type a" to "a list of type a", so you loose the number of available elements, which is only checkable on runtime from this point on)
13:16:59 <vixey> (you get both)
13:17:08 <Cale> vixey: Sorry?
13:17:11 <sylence> Cale: you mean it should be (\x -> sum (map (const 1) x)) ?
13:17:19 <Cale> sylence: That also works :)
13:17:26 <Cale> sylence: and is probably what the author wanted
13:17:44 <vixey> what were you saying yes to?
13:17:48 <Cale> sylence: If you know about function composition, you can try writing the function without lambda abstractions :)
13:17:49 <syntaks> vixey, I was writing this: w160ToOctets (Word160 w1 w2 w3 w4 w5) =  concat (map (toOctets 256) [w1, w2, w3, w4, w5])
13:17:55 <sylence> Cale: thanks, i will go on to the next tutorial =)
13:18:06 <syntaks> vixey, and I just thought that there must be a way to abstract that
13:18:30 <vixey> @src concatMap
13:18:30 <lambdabot> concatMap f = foldr ((++) . f) []
13:18:43 <vixey> syntaks: Maybe using a typeclass which means that a type can be converted to octets
13:18:49 <tcr> Baughn: Thanks for your help. I figured out the bug (which is actually too embarrassing to admit) myself.
13:19:15 <syntaks> vixey, but then I would still need to pattern watch w1... in the instance implementation
13:19:16 <Toxaris> :t fromList
13:19:16 <lambdabot> Not in scope: `fromList'
13:19:28 <Toxaris> :t Data.Foldable.fromList
13:19:28 <lambdabot> Not in scope: `Data.Foldable.fromList'
13:19:32 <Toxaris> :(
13:19:44 <vixey> syntaks: that's a problem?
13:19:56 <syntaks> vixey, but thanks for the concatMap hint... I didn't know that one yet
13:20:00 <Cale> vixey: While it's moderately typical of dynamically typed languages that you can generically traverse datastructures, it's generally hard to express the constraint which he wanted without a static type system.
13:20:57 <vixey> which constraint?
13:21:44 <Cale> That is, he wants the function to be parametrically polymorphic in the type of the contained values.
13:21:57 <Cale> Something like  f a -> [a]
13:22:25 <Cale> (and he wants to be certain that he gets a homogeneous list)
13:22:33 <syntaks> vixey, it's not really a problem at all... it's more of a learning-thing to me and I try to find out about the various ways in which something can be done
13:22:34 <Toxaris> syntaks: you could think about instantiating Data.Foldable for your type, it's not full generic programming, but it captures the idea of "this type describes values which contain a somehow structured set of subvalues of the same type"
13:22:53 <Toxaris> syntaks: ehm, "same" in a nonrecursive meaning :)
13:23:08 <opqdonut> :)
13:23:20 <Toxaris> but in a better language, you could express the abstraction you want *easily*
13:23:35 <Cale> In Generic Haskell, it's pretty easy.
13:23:37 <syntaks> though the recursive case would also be interesting ;)
13:23:55 <syntaks> Toxaris, does that language exist?
13:24:09 <vixey> Haskell
13:24:16 <vixey> f (Foo x y z) = [x, y, z] -- as said
13:24:22 <Cale> syntaks: There are various somewhat-experimental languages which exist and have that capacity.
13:24:37 <vixey> when you want the same thing to work with Foo Bar and Baz, like I said, you could use a typeclass
13:24:54 <Toxaris> syntaks: Hinze uses it in Papers all the time, and there is Generic Haskell which claims to do it (but i didn't try)
13:25:06 <Toxaris> vixey: I said *easily*
13:25:14 <Cale> vixey: Suppose you want to write an f which works on any algebraic datatype with at least one type parameter, and builds a list of all the values contained of the type of that parameter.
13:25:18 <vixey> trying to define classes of datatypes (rather than a sufficiently generic one) and functions operating on them is not usual though
13:25:56 <Cale> Typeclasses don't *really* hammer this problem very nicely, but it can be done with various systems for generics.
13:25:58 <vixey> Cale: That's what I'd do in a dynamic language but it makes very little sense in haskell
13:26:17 <Cale> vixey: No, it does make sense in Haskell, and the type constraints can be better expressed as well.
13:26:21 <Toxaris> vixey: why not? if it's statically typechecked, it would be fine to have
13:26:34 <vixey> what do you get from all that genericity.. save three lines of code by writing 40?
13:26:42 <Cale> Maybe more :)
13:26:50 <Toxaris> vixey: no, i want to write 1 line
13:27:03 <Toxaris> vixey: (*easily* expressed means one line for one idea)
13:27:11 <Cale> If you have a nice library or language which has appropriate features for recursing on the structure of types, then it's doable.
13:27:19 <Toxaris> but with haskell i need 30 lines, so Haskell is not expressive to do it
13:27:21 <Cale> vixey: Check out Data.Generics sometime.
13:27:27 <Cale> Or Generic Haskell.
13:27:29 <pejo> vixey, there's plenty of papers on generic programming out there, and they show pretty massive savings for certain types of applications.
13:27:46 <Cale> Really, you can do this with   listify (const True)
13:28:00 <Cale> If you import Data.Generics and you derive Data for your type.
13:28:34 <Cale> Here, I'll even add Data.Generics to lambdabot to show an example :)
13:28:48 <syntaks> Cale, I'll check that out now
13:29:04 <Cale> @undef
13:29:04 <lambdabot> Undefined.
13:29:31 <Cale> > listify (const True) (Node 1 [Node 2 [Node 3 [], Node 4 []], Node 5 []])
13:29:32 <lambdabot>  []
13:29:36 <Cale> > listify (const True) (Node 1 [Node 2 [Node 3 [], Node 4 []], Node 5 []]) :: [Integer]
13:29:37 <lambdabot>  [1,2,3,4,5]
13:29:44 <Cale> > listify (const True) (Node 1 [Node 2 [Node 3 [], Node 4 []], Node 5 []]) :: [[Node]]
13:29:44 <lambdabot>   Not in scope: type constructor or class `Node'
13:29:46 <syntaks> template haskell and reify would have been my other thought, but that would really have meant to write 30 lines in order to save 3 :)
13:29:49 <Cale> > listify (const True) (Node 1 [Node 2 [Node 3 [], Node 4 []], Node 5 []]) :: [[Tree Integer]]
13:29:49 <lambdabot>  [[Node {rootLabel = 2, subForest = [Node {rootLabel = 3, subForest = []},Nod...
13:30:32 <Cale> > listify (const True) [Left 3, Right "hello", Left 6, Right "goodbye"] :: [Integer]
13:30:32 <lambdabot>  [3,6]
13:30:37 <Cale> > listify (const True) [Left 3, Right "hello", Left 6, Right "goodbye"] :: [String]
13:30:38 <lambdabot>  ["hello","ello","llo","lo","o","","goodbye","oodbye","odbye","dbye","bye","y...
13:30:41 <Cale> :)
13:30:47 <Toxaris> Cale: and i only need "deriving Data" for this to work?
13:30:50 <Cale> yep
13:31:00 <Toxaris> hmm. ok, it is usable for small examples, too :)
13:31:12 <vixey> wow
13:31:42 <Cale> > listify even [Left 3, Left 5, Left 7, Right "hello", Left 6, Right "goodbye"] :: [String]
13:31:42 <lambdabot>   add an instance declaration for (Integral String)
13:31:45 <vixey> > listify (const True) Just (Just (Just (Just (Just (Just (1)))))) : [Integer]
13:31:45 <lambdabot>   Not in scope: data constructor `Integer'
13:31:46 <Cale> > listify even [Left 3, Left 5, Left 7, Right "hello", Left 6, Right "goodbye"] :: [Integer]
13:31:46 <lambdabot>  [6]
13:31:57 <Cale> > listify even [Left 3, Left 5, Left 7, Right "hello", Left 6, Right "goodbye", Left 8] :: [Integer]
13:31:57 <lambdabot>  [6,8]
13:32:05 <vixey> > listify (const True) Just (Just (Just (Just (Just (Just (1)))))) :: [Integer]
13:32:05 <lambdabot>  Couldn't match expected type `Maybe
13:32:28 <vixey> > listify (const True) (Just (Just (Just (Just (Just (Just (1))))))) :: [Integer]
13:32:29 <lambdabot>  [1]
13:32:38 <Cale> :t listify
13:32:39 <lambdabot> forall r a. (Typeable r, Data a) => (r -> Bool) -> a -> [r]
13:32:53 <Cale> :t listify (const True)
13:32:53 <lambdabot> forall r a. (Typeable r, Data a) => a -> [r]
13:32:57 <vixey> > listify odd [1..] :: [Integer]
13:32:58 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
13:33:14 <Cale> see? It's totally not impossible.
13:33:39 <geezusfreeek> > listify odd [1..]
13:33:40 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
13:33:49 <vixey> It's impossible in haskell...
13:33:58 <geezusfreeek> no it's not! :P
13:34:06 <Cale> That is Haskell.
13:34:08 <roconnor> actually nix sounds like it could learn something from darcs.
13:34:15 <Cale> (GHC Haskell)
13:34:20 <roconnor> version control for package management
13:34:30 <ibid> dons: are you aware of link spam in RWH blog feed? i'm disabling it from planet until you tell me it's been cleaned
13:34:34 <roconnor> I bet deep cherry picking would be good for that.
13:34:49 <Saizan_> well Typeable needs an unsafeCoerce, the rest it's higher rank polymorphism i suppose
13:35:21 <ArcSin_> does anyone know if there is a way to install GHC that does not involve using the terminal ?
13:35:24 <pejo> Saizan, you sure about that?
13:35:25 <Cale> Typeable probably should become a language primitive so that it can't be circumvented and wouldn't involve unsafeCoerce.
13:35:48 <Cale> ArcSin_: uh, on unix?
13:35:49 <geezusfreeek> pejo: he is right, it does require an unsafeCoerce in it implementation
13:35:53 <ArcSin_> yes
13:36:01 <Cale> ArcSin_: Not that I'm aware of.
13:36:14 <ArcSin_> i keep getting an error in Bash
13:36:20 <Saizan_> pejo: well, cast needs it
13:36:21 <Cale> What's the error?
13:36:29 <Cale> If it's long, maybe hpaste it
13:36:29 <ArcSin_> can't fine the right directory
13:36:32 <Cale> @hpaste
13:36:33 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:36:34 <ArcSin_> *find
13:36:44 <vixey> wait a sec,
13:36:59 <vixey> how is deriving Data implemented?
13:37:05 <Cale> vixey: In GHC.
13:37:06 <vixey> that has to part of the haskell implementation right?
13:37:10 <Cale> yes
13:37:34 <Saizan_> you can write the Data instance manually
13:37:40 <Cale> Though you can write instances manually, yeah.
13:37:50 <geezusfreeek> vixey: it's just a kind of dynamic typing, but typesafe!
13:37:59 <hpaste>  ArcSin_ pasted "GHC" at http://hpaste.org/6948
13:38:26 <Cale> ArcSin_: Could you do an ls ?
13:38:31 <geezusfreeek> provided a correct implementation of Data for your type
13:38:40 <ArcSin_> ls?
13:38:41 <Cale> ArcSin_: Is the package unpacked in that directory?
13:38:54 <Cale> Yeah, type ls into your terminal to get a list of the files in that directory.
13:39:08 <Cale> What do you see?
13:39:43 <mncharity> ï»¿Cale: updated.  thanks for your help.
13:39:51 <Cale> mncharity: No problem :)
13:39:55 <hpaste>  ArcSin_ annotated "GHC" with "GHC-1" at http://hpaste.org/6948#a1
13:40:30 <Cale> ArcSin_: You're trying to install GHC?
13:40:38 <ArcSin_> correct
13:40:42 <ArcSin_> or upgrade
13:40:46 <Cale> ArcSin_: Where's your GHC package?
13:40:58 <ArcSin_> from 6.61 to 6.8.2
13:41:14 <Cale> Presumably you've downloaded 6.8.2 to somewhere?
13:41:28 <ArcSin_> oh it's on my desktop
13:41:37 <Cale> cd ..
13:41:44 <Cale> (go up a level)
13:42:05 <Cale> Is it a .tar.gz?
13:42:13 <syntaks> Cale, cool, I got my stuff to work with listify ;)
13:42:17 <Cale> You got the generic linux binary package right?
13:42:21 <Cale> syntaks: cool :)
13:42:48 <syntaks> listify (const True) (Data.Digest.SHA1.Word160 1 1 1 1 1) :: [Word32]
13:42:49 <syntaks> [1,1,1,1,1]
13:42:58 <Cale> :)
13:42:59 <ArcSin_> tar.bz2
13:43:04 <Cale> ArcSin_: okay
13:43:54 <Cale> ArcSin_: so unpack that -- you can use a graphical archive manager to do that if you want
13:44:17 <ArcSin_> k i'll try it
13:44:36 <Cale> Or,  tar jxvf ghc-6.8.2-i386-unknown-linux.tar.bz2
13:45:28 <Cale> Or, if you want to use the terminal but don't want to learn all the different ways to unpack things, you can install a program called unp (if you're on Ubuntu, you could use  sudo apt-get install unp  to install it).
13:45:45 <dons> ibid: thanks, just noticed that.
13:45:51 <dons> @seen bos
13:45:51 <lambdabot> I saw bos leaving #ghc and #haskell 5h 13m 34s ago, and .
13:46:09 <dons> @tell bos link spam in RWH blog
13:46:09 <lambdabot> Consider it noted.
13:47:13 <Cale> (and then the command would just be:  unp ghc-6.8.2-i386-unknown-linux.tar.bz2
13:47:14 <Cale> )
13:47:42 <Cale> ArcSin_: Note that when working in the terminal, you can press the tab key to automatically fill in the rest of a filename.
13:47:50 <Cale> (after typing the first few characters)
13:48:11 <ddarius> Typeable doesn't -require- unsafeCoerce.
13:49:01 <Cale> It's really cast which secretly involves unsafeCoerce, and that could be built in.
13:49:22 <Cale> I think that it shouldn't be possible to write instances of Typeable by hand.
13:50:18 <vixey> why not add a macro system to haskell, if you could define your own deriving's using something like schemes syntax-rules you could implement Data in haskell right?
13:50:23 <Cale> It would be cool if Typeable was a completely hidden class, and the typesafe cast was built in.
13:50:43 <ddarius> Cale: My point was that you can implement Typeable without unsafeCoerce (secret or otherwise)
13:50:47 <Cale> vixey: There is a macro system.
13:50:56 <syntaks> vixey, template-haskell does that
13:51:18 <Cale> ddarius: Sure, it's just that most of the real applications of Typeable involve that typesafe cast operation :)
13:51:32 <vixey> I thought template-haskell just prints out haskell code..
13:51:43 <syntaks> I was at least able to build my own $(deriveFromXml...) for converting types to an xml representation
13:51:44 <Cale> "typesafe" since it's not actually typesafe if you're allowed to write bad instances of Typeable.
13:51:55 <Cale> vixey: No, it's a macro system.
13:52:16 <syntaks> vixey, it's hooked into the compile process
13:52:42 <vixey> has anyone implemented Data using it?
13:52:58 <Heffalump> yes
13:53:03 <Heffalump> if you mean Data.Typeable
13:53:15 <hpaste>  ArcSin_ annotated "GHC" with "GHC-2" at http://hpaste.org/6948#a2
13:53:18 <Cale> Heffalump: He means Data.Generics
13:53:21 <ddarius> He means deriving Data
13:53:26 <Heffalump> oh, I see, sorry
13:53:36 <Heffalump> I think someone sent me some TH to do it once, let me check
13:53:42 <syntaks> I think it is possible with reify
13:54:00 <ddarius> @google "A Lightweight Implementation of Generics and Dynamics"
13:54:01 <lambdabot> http://citeseer.ist.psu.edu/cheney02lightweight.html
13:54:19 <Cale> error.
13:55:11 <syntaks> ok, one last question for this one... can you think of a point-free way of doing "w160ToOctets w =  concatMap (toOctets 256) (listify (const True) w :: [Word32])"?
13:55:28 <roconnor> wow, they say that NixOS is not a proof-of-concept.
13:55:33 <Heffalump> no, seems not
13:55:54 <syntaks> I'm not sure how to get rid of the [Word32] signature
13:55:56 <ddarius> syntaks: It's just a composition.
13:55:58 <Saizan_> i think the derive package can also derive Data
13:56:08 <vixey> @pl \w -> concatMap (toOctets 256) (listify (const True) w
13:56:08 <lambdabot> (line 1, column 55):
13:56:08 <lambdabot> unexpected end of input
13:56:08 <lambdabot> expecting variable, "(", operator or ")"
13:56:18 <ddarius> syntaks: Give the function the type signature.
13:56:32 <vixey> @pl \w -> concatMap (toOctets 256) (listify (const True) w)
13:56:32 <lambdabot> (toOctets 256 =<<) . listify (const True)
13:56:45 <syntaks> ddarius, the type signature is w160ToOctets :: Word160 -> [Octet]
13:57:10 <ddarius> syntaks: You could use asTypeOf, but it's probably not worth it.
13:57:55 <Saizan_> syntaks: isn't toOctects enough to set the type?
13:58:17 <syntaks> Saizan_, I thought so too, but it doesn't work
13:58:42 <ddarius> syntaks: What is the type of toOctets?
13:58:53 <Saizan_> you can add the type sign there if you want
13:59:40 <syntaks> Saizan_, where?
14:00:28 <syntaks> ddarius, toOctets :: (Integral a, Integral b) => a -> b -> [Octet]
14:00:39 <Saizan_> concatMap (toOctets 256 :: Word32 -> [Octet]) (listify (const True)
14:01:19 <syntaks> Saizan_, oh, that's where it goes! now it all makes sense ;)
14:01:36 <roconnor> they should change the name NixOS sounds like a new operating system rather than a linux distribution.
14:01:42 <syntaks> did I say that you guys rock?
14:01:45 <syntaks> thanks everyone :)
14:02:37 <dolio> They could call it Fundows.
14:02:40 <dolio> Or Funspire.
14:02:43 <dons> roconnor: people are running nixos at the hackathon
14:02:55 <roconnor> dons: is that now?
14:03:01 <dons> yep
14:03:05 <ski> Cale : what would you think of a change from `class Cxt => C a' to `class Cxt <= C a' (or `class C a => Cxt') which i mentioned earlier?
14:03:30 <roconnor> dons: should I join the IRC channel, even if I'm not there?
14:03:43 <roconnor> dons: maybe I'll stick here
14:03:55 <dons> yeah, good idea.
14:04:48 <roconnor> They should rename NixOS to Zuiverheid, a Dtuch word meaning purity. (accoring to Google translate)
14:05:02 <roconnor> ... sounds like silverness rather than purity to me.
14:06:57 <dons> more hackathon photos up, http://blog.well-typed.com/
14:06:58 <lambdabot> Title: blog.well-typed.com
14:08:18 <roconnor> dons: how many attendees? probably less than last year because it isn't with ICFP
14:08:52 <dons> 20 or so. so a bit down.
14:08:54 <dons> more locals
14:10:00 <roconnor> That's too be expected.
14:10:07 <roconnor> *to be
14:17:47 <grahamhutton> @users
14:17:47 <lambdabot> Maximum users seen in #haskell: 481, currently: 470 (97.7%), active: 14 (3.0%)
14:18:07 <grahamhutton> not yet 500 :-*
14:18:49 <ddarius> #haskell user production has been down of late
14:18:51 <byorgey> getting closer!
14:19:37 <roconnor> Boy, NixOS sounds nice, but I'm still hesitent to switch from Ubuntu on my laptop.
14:19:58 <gnut> hello
14:20:14 <IsoPallo> Oh. I like haskell more each time. It just made me create an unexpected nice modularity. Doing "brute-force" state-tree of a system became actually a nice option as I can then just pass the tree to the IO routines. No nasty programmign interfaces :)
14:20:24 <gnut> how is parallel haskell coming along?
14:21:46 <byorgey> IsoPallo: yes, with lazy evaluation doing something like 'create an entire state tree' actually makes sense -- only the parts of the tree that are actually needed will get computed, but you can think of it *as if* you have the whole tree. =)
14:22:23 <ddarius> You do have the whole tree.
14:26:10 <byorgey> er... yes, but not necessarily all in memory at once.
14:26:34 <byorgey> but point taken. =)
14:27:22 <hpaste>  paolino pasted "something not to do without fold" at http://hpaste.org/6949
14:35:07 <dolio> 'beast' is a good function name.
14:35:53 <grahamhutton> looks like fairly standard fold stuff?  (e.g. nothing higher order)
14:36:27 <kosmikus> hi grahamhutton
14:36:33 <grahamhutton> hi andres!
14:36:54 <vixey> what do you mean higher order?
14:37:08 <grahamhutton> using fold to build up a function, which is then applied to something else
14:37:26 <vixey> ah ok
14:37:29 <grahamhutton> you can play many tricks with this, such as defining foldl in terms of foldr
14:37:49 <paolino> the problem is select all sets of a set of sets which satify a condition (eg  they don't intersect)
14:38:30 <paolino> the other face of Bell numbers
14:39:00 <vixey> I know of foldl f z l = foldr (flip f) z (reverse l)
14:39:11 <grahamhutton> (and defining the fibonnaci function using fold)
14:39:14 <vixey> but I think that's wrong for infinite lists
14:39:18 <Cale> e^(e^x - 1)
14:39:33 <visof> can foldl make what foldr can't ?
14:39:35 <Heffalump> foldl doesn't terminate for infinite lists either, so it's fine
14:40:06 <grahamhutton> visof: foldl is definable in terms of foldr.
14:40:27 <grahamhutton> but not vice-versa.
14:41:02 <dolio> > let foldl f z l = foldr (\x g y -> g (x `f` y)) id l z in foldl (flip (:)) [] [1..10]
14:41:03 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
14:41:03 <lambdabot>       Expected...
14:41:11 <roconnor> > foldr f z [a,b,c]
14:41:12 <lambdabot>  f a (f b (f c z))
14:41:12 <dolio> > let foldl f z l = foldr (\x g y -> g (x `f` y)) id l z in foldl (:) [] [1..10]
14:41:13 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
14:41:17 <roconnor> > foldl f z [a,b,c]
14:41:17 <lambdabot>  f (f (f z a) b) c
14:41:37 <grahamhutton> dolio: that's the one!
14:41:51 <Cale> except that you got the arguments to f backwards
14:41:57 <dolio> Yeah.
14:42:23 <dolio> > let foldl f z l = foldr (\x g y -> g (y `f` x)) id l z in foldl f z [a,b,c]
14:42:24 <lambdabot>  f (f (f z a) b) c
14:42:46 <grahamhutton> if you want a tough question, think about the class of functions definable using foldr as the only means of recursion...
14:43:10 <grahamhutton> it's pretty difficult to come up with a total/terminating function that isn't so definable..
14:43:11 <dolio> > let foldr f z l = foldl (\g x y -> g (x `f` y)) id l z in foldr f z [a,b,c]
14:43:12 <lambdabot>  f a (f b (f c z))
14:43:18 <aFlag> is there something more elaborated than randomIO, randoms, etc? I want to get random numbers from within a range, and I've heard that using mod is not a good idea because the lower bits are not uniformaly distributed or something like that
14:43:25 <dolio> That, of course, doesn't work on infinite lists.
14:43:33 <sarehu> randomRIO?
14:43:40 <sjanssen> aFlag: yes, see randomR and friends
14:44:41 <aFlag> oh, they're all in System.Random, I see it, thanks
14:45:12 <Cale> > randomRs (1,10) (mkStdGen 42)
14:45:12 <lambdabot>  [2,2,8,5,7,2,9,2,9,6,6,10,7,9,5,6,8,2,4,7,7,5,3,5,7,5,1,9,4,5,5,6,3,3,7,4,5,...
14:46:00 <vixey> > take 9 . nub $ randomRs (1,10) (mkStdGen 42)
14:46:03 <lambdabot>  [2,8,5,7,9,6,10,4,3]
14:46:30 <vixey> > take 10 . nub $ randomRs (1,10) (mkStdGen 42)
14:46:31 <lambdabot>  [2,8,5,7,9,6,10,4,3,1]
14:47:01 <paolino> nub is so lazy
14:47:39 <vixey> @let permutation list seed = let n = length list in map (!!list) . take n . nub $ randomRs (0,n-1) (mkStdGen seed)
14:47:39 <lambdabot> Couldn't match expected type `Int' against inferred type `[a]'
14:48:09 <vixey> @let permutation list seed = let n = length list in map (list!!) . take n . nub $ randomRs (0,n-1) (mkStdGen seed)
14:48:09 <lambdabot> Defined.
14:48:16 <vixey> > permutation "testing" 42
14:48:16 <lambdabot>  "tnitsge"
14:49:18 <Cale> > map (permutation "testing") [1..]
14:49:19 <lambdabot>  ["sngttei","ietntsg","gnsttei","etintgs","tinetsg","ntgites","tietngs","stit...
14:53:03 <paolino> how do I pick up all the subsets of a set of sets whose union is a given set ?
14:53:29 <Cale> filter with the appropriate condition
14:53:36 <opqdonut> :)
14:53:51 <paolino> all the combinations ?
14:54:06 <vixey> every partition of the union when the union is a subset of the original set, no?
14:54:21 <vixey> otherwise []
14:55:08 <Cale> paolino: uh, yeah, I don't think there's any way around it really
14:55:17 <Cale> paolino: You have an arbitrary set of sets?
14:55:47 <Cale> Or is your set of sets somehow special?
14:56:13 <paolino> Cale , then is it worth my function to select all the non inetersecting subsets before that ?
14:56:21 <paolino> arbitrary
14:56:59 <Cale> Non intersecting with what?
14:57:08 <paolino> among them
14:57:16 <vixey> paolino: No?
14:57:21 <Cale> Wait, you have a set of sets, or a set of sets of sets?
14:57:41 <paolino> in the beginning a set of sets
14:58:08 <paolino> vixey: I didn't get that
14:58:11 <Cale> Okay, and either those sets have pairwise intersections or they don't.
14:58:29 <paolino> yes
14:58:41 <Cale> So I don't know what you mean by "selecting the non-intersecting subsets"
14:59:27 <paolino> then I have another set which I want to "fill" with any possible subsets of those
14:59:33 <Cale> You mean finding all possible choices of sets such that they have no pairwise intersections?
14:59:40 <paolino> right
15:00:44 <Cale> Well, using those will miss some combinations of course.
15:01:16 <Cale> Consider the set of sets  {{1,2},{2,3}}
15:01:34 <Cale> and the set of combinations of those which cover the set {1,2,3}
15:01:48 <paolino> so each set of sets picked must have no pairwise intersection and union in the last
15:02:05 <Cale> Oh
15:02:31 <paolino> they intersect, so I reject that
15:02:39 <Cale> So you're strictly looking for partitions of a set S consisting of sets from a particular family?
15:02:58 <paolino> right
15:03:59 <paolino> actually the non intersection condition is only inside S
15:04:32 <Cale> There are a couple ways to approach that.
15:05:37 <Cale> One would be to start by selecting in all possible ways an element of the family such that the least element of S is in that set, then excluding all elements of the family which intersect with that and recursing.
15:06:32 <Cale> (of course, you also want to get rid of elements of the family which contain elements not in S right off the start)
15:07:10 <paolino> "such that the least element of S is in that set" ?
15:07:40 <Cale> paolino: yes, you know that in a partition of S, one of the sets will have to have the least element of S.
15:07:44 <paolino> I don't translate least there
15:07:51 <Cale> smallest
15:08:05 <Cale> minimal with respect to the ordering which I'm assuming that you have :)
15:08:34 <Cale> An element x of S such that for any y in S, x <= y.
15:08:48 <Cale> (you can use findMin to get it)
15:09:56 <paolino> ok, recursing where ?
15:10:23 <paolino> the S can have holes
15:10:55 <paolino> they are words mostly, filenames
15:10:59 <Cale> Well, you're finding a partition of S\x where x is the element of the family that you picked which consists of elements of the family which have no intersection with the one you picked
15:11:30 <Cale> (which you'd just do with filter)
15:12:47 <Cale> and then you'd pick an element y of the family which contains the least member of S\x, and continue in this fashion, building up a partition of S which is {x,y,...}
15:13:27 <paolino> ok
15:13:39 <Cale> If the family is empty but S is not, of course there are no partitions. If S is empty, there is a single partition which is empty.
15:14:30 <Cale> That condition that the set you pick contains the least element of S is a useful way to reduce the branching, and eliminates the possibility that you generate the same partition multiple times.
15:14:54 <paolino> the Ord on filenames
15:14:56 <Cale> I'd use the list monad for this :)
15:14:58 <Cale> yeah
15:15:34 <Cale> It'd just be string ordering. It doesn't matter what the order is so long as it's total. The Haskell Set library already requires an Ord instance.
15:15:38 <paolino> ok I can do that on the sets coming out of mkSatisfy
15:16:09 <shachaf> > compare LT GT -- ?
15:16:09 <lambdabot> Terminated
15:16:14 <shachaf> > compare LT LT
15:16:15 <lambdabot>  EQ
15:16:21 <shachaf> > compare GT LT
15:16:22 <lambdabot> Terminated
15:16:34 <Peaker> ??
15:16:43 <vixey> > GT . LT
15:16:44 <lambdabot> Terminated
15:17:05 <shachaf> > const LT GT
15:17:06 <lambdabot> Terminated
15:17:13 <shachaf> That's odd.
15:17:18 <vixey> > LT
15:17:18 <lambdabot>  LT
15:17:21 <vixey> > GT
15:17:21 <lambdabot> Terminated
15:17:22 <vixey> > EQ
15:17:23 <lambdabot>  EQ
15:17:27 <shachaf> Oh, it's GT.
15:17:36 <shachaf> Cale?
15:17:38 <vixey> :t GT
15:17:39 <lambdabot>     Ambiguous occurrence `GT'
15:17:39 <lambdabot>     It could refer to either `Data.Ord.GT', imported from Data.Ord
15:17:39 <lambdabot>                           or `Data.Generics.GT', imported from Data.Generics
15:17:43 <shachaf> Oh.
15:17:53 <vixey> :t EQ
15:17:54 <lambdabot> Ordering
15:18:00 <paolino> grand turism
15:18:05 <davidL> > Data.Ord.GT
15:18:06 <lambdabot>  GT
15:18:12 <shachaf> Cale: Perhaps one should be hidden?
15:18:18 <vixey> > Data.Generics.GT
15:18:19 <lambdabot>        add an instance declaration for
15:18:19 <lambdabot>       (Typeable GenericT', Typeable (f...
15:18:37 <sjanssen> Data.Generics shadows a Prelude type?
15:18:46 <shachaf> sjanssen: So it seems.
15:20:16 <paolino> thanks Cale
15:20:18 <sjanssen> I don't seem to have this
15:20:28 <shachaf> sjanssen: You don't?
15:20:33 * shachaf has the same thing in ghci.
15:20:36 <shachaf> @version
15:20:36 <lambdabot> lambdabot 4p603, GHC 6.8.2 (Linux i686 2.40GHz)
15:20:36 <lambdabot> darcs get http://code.haskell.org/lambdabot
15:21:31 <sjanssen> interesting, :info GT doesn't work
15:21:34 <sjanssen> but it is in scope
15:22:10 <shachaf> :i seems to give a "Not in scope" error with an ambiguous name.
15:22:26 <sjanssen> ah
15:22:46 <sjanssen> so imports.hs seems to import Data.Generics qualified
15:23:00 <shachaf> (For upper-case identifiers, anyway.)
15:24:35 <sjanssen> who admins lambdabot nowadays?
15:24:50 <shachaf> sjanssen: Cale.
15:26:32 <sjanssen> looks like Cale's repo isn't consistent with code.haskell.org?
15:28:06 <shachaf> @seen Cale
15:28:06 <lambdabot> Cale is in #haskell-overflow, #haskell-blah, #ghc and #haskell. I last heard Cale speak 12m 32s ago.
15:28:20 <shachaf> I think lambdabot is running on community.haskell.org.
15:29:40 <sjanssen> but probably in a copy of the public repository
15:30:36 <sjanssen> think C-le will notice if I push a patch removing his evil Prelude changes? :P
15:33:05 <shachaf> @get-cale
15:33:05 <lambdabot> Unknown command, try @list
15:34:06 <shachaf> sjanssen: Of course he would; nobody would be complaining about confusing lambdabot types in #haskell. :-)
15:34:42 <vixey> shachaf: Cale added generics just to show me something a moment ago
15:35:00 <sjanssen> well, there you go
15:35:29 <shachaf> At least part of Data.Generics should be hidden.
15:36:54 <sjanssen> we ought to make a new release of lambdabot
15:37:25 <vixey> sjanseen: UTF-8 by default please....
15:37:32 <shachaf> Is mbot also being run from community.haskell.org?
15:37:36 <sjanssen> vixey: what?
15:37:37 <shachaf> Doesn't look like it.
15:37:50 <shachaf> sjanssen: vixey wants Unicode support in lambdabot.
15:37:55 <sjanssen> oh
15:37:55 <xif> Good afternoon.
15:37:56 <vixey> sjanseen: it should use UTF-8 by default for encoding
15:37:58 <sjanssen> vixey: so write it :)
15:38:02 <shachaf> xif: Good $TIME.
15:38:19 <xif> shalom Shachaf
15:38:20 <vixey> sjanssen: I got a 403 from the ftp so I didn't bother
15:38:26 <sjanssen> vixey: ftp?
15:38:32 <vixey> anyway it's probably trivial
15:38:35 <vixey> ?where lambdabot
15:38:36 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
15:38:36 <sjanssen> you're chasing a seriuosly old version, methinks
15:38:47 <vixey> ftp://ftp.cse.unsw.edu.au/pub/users/dons/lambdabot/lambdabot-4.0.1.tar.gz
15:38:49 <sjanssen> vixey: darcs get http://code.haskell.org/lambdabot
15:38:49 <lambdabot> Title: Index of /lambdabot
15:39:06 <shachaf> vixey: You should use the darcs version.
15:39:38 <sjanssen> @tell dons http://www.cse.unsw.edu.au/~dons/lambdabot.html has stale links to an old lambdabot tarball
15:39:38 <lambdabot> Consider it noted.
15:40:00 <sjanssen> vixey: this is why we need a release :) -- 4.0.1 is at least a year (maybe two?) old
15:40:25 <kfish> s/release/birthday party/
15:47:27 <slava> is [] the free monoid functor?
15:47:59 <Saizan_> slava: yes
16:03:51 <sjanssen> lambdabot is such a mess
16:04:09 * vixey bites lambdabot
16:20:36 <joricj> when i (show) an integer, how can i prepend 0's to align the numbers?
16:21:57 <kpreid> use a number formatting function rather than show
16:21:59 <vixey> > reverse . take 10 . (++repeat '0') . reverse . show $ 357
16:22:00 <lambdabot>  "0000000357"
16:22:05 <vixey> > reverse . take 10 . (++repeat '0') . reverse . show $ 357000
16:22:05 <lambdabot>  "0000357000"
16:22:18 <kpreid> @hoogle showInt
16:22:18 <lambdabot> Numeric.showInt :: Integral a => a -> ShowS
16:22:18 <lambdabot> Numeric.showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
16:22:25 <kpreid> hm, not that...
16:22:47 <kpreid> vixey: won't work for negative integers
16:22:55 <vixey> > reverse . take 10 . (++repeat '0') . reverse . show $ -357000
16:22:56 <lambdabot>  "000-357000"
16:23:11 <roconnor> > replicate M ['0'..'9'] !! 357
16:23:12 <lambdabot>   Not in scope: data constructor `M'
16:23:17 <roconnor> > replicateM ['0'..'9'] !! 357
16:23:17 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
16:23:29 <roconnor> > replicateM 10 ['0'..'9'] !! 357
16:23:30 <lambdabot>  "0000000357"
16:23:35 <roconnor> > replicateM 10 ['0'..'9'] !! 357000
16:23:36 <lambdabot>  "0000357000"
16:23:46 <roconnor> btw, don't use the above
16:23:52 <vixey> > replicateM 10 ['0'..'9'] !! -357
16:23:52 <lambdabot>      precedence parsing error
16:23:52 <lambdabot>         cannot mix `(!!)' [infixl 9] and prefix...
16:23:54 <resiak> that's really cunning
16:23:55 <roconnor> it is really awful
16:24:02 <joricj> > printf
16:24:03 <lambdabot>  Add a type signature
16:24:13 <roconnor> resiak: I learned that yesterday on #haskell
16:24:18 <joricj> @printf
16:24:18 <lambdabot> ()
16:24:26 <joricj> o_O?
16:24:58 <joricj> > printf "%03" 0
16:24:58 <lambdabot>  Add a type signature
16:25:26 <resiak> > printf "%03" 0 :: Maybe String
16:25:27 <lambdabot>        add an instance declaration for (PrintfType (Maybe String))
16:25:27 <lambdabot>     In the...
16:25:31 <resiak> > printf "%03" 0 :: String
16:25:32 <lambdabot>  Exception: Printf.printf: formatting string ended prematurely
16:25:36 <vixey> > printf "%.8d" 0 :: String
16:25:37 <lambdabot>  "0"
16:25:44 <vixey> > printf "%0.8d" 354 :: String
16:25:45 <lambdabot>  "354"
16:25:49 <vixey> > printf "%8d" 354 :: String
16:25:50 <lambdabot>  "     354"
16:25:56 <vixey> > printf "%08d" 354 :: String
16:25:57 <lambdabot>  "00000354"
16:26:39 <joricj> awesome
16:26:41 <joricj> it works
16:31:13 <fnord123> has anyone used cairo in anger? I saw the clock example, but was wondering if there were larger examples out there.
16:32:13 <fophillips> Is there an existing function to see whether a [Bool] contains just True?
16:33:00 <Botje_> fophillips: "or"
16:33:45 <fophillips> Botje_: According to this wikibook I just found, it is âandâ
16:33:57 <Botje_> oh
16:34:08 <Botje_> i thought you wanted "at least one True"
16:34:16 <Botje_> but you meant "all True"
16:34:23 <Botje_> then and is the way to go, yes
16:34:29 <fophillips> Thanks,
16:34:42 <fnord123> > and [True, True]
16:34:42 <lambdabot>  True
16:34:53 <fnord123> > and [True, False, True]
16:34:53 <lambdabot>  False
16:36:08 <vixey> :t elem (Just True)
16:36:16 <lambdabot> [Maybe Bool] -> Bool
16:44:34 <fophillips> > foldl (\x y -> x * 10 + y) 0 [1,2,3]
16:44:35 <lambdabot>  123
16:45:24 <vixey> @pl (\x y -> x * 10 + y)
16:45:24 <lambdabot> (+) . (10 *)
16:48:52 <Botje_> @pl \x y -> y * 10 + x
16:48:52 <lambdabot> (. (10 *)) . (+)
16:49:17 <Botje_> plus is commutative, silly \bot
16:49:31 <fnoble> is there a standard function that takes a list of strings and concats them putting some character in between?
16:49:53 <Botje_> intersperse from Data.List
16:49:58 <allbery_b> @src intercalate
16:49:58 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
16:50:03 <Botje_> ah
16:50:04 <Botje_> even better
16:50:08 <fnoble> thanks
16:50:11 <Botje_> i forgot if it had intercalate too
16:50:25 <allbery_b> (not in 6.6.x)
16:53:34 <resiak> @ty intercalate
16:53:35 <lambdabot> forall a. [a] -> [[a]] -> [a]
16:54:02 <vixey> > intercalate " " .  words $ "forall a. [a] -> [[a]] -> [a]"
16:54:03 <lambdabot>  "forall a. [a] -> [[a]] -> [a]"
16:54:11 <vixey> > intercalate " <- " .  words $ "forall a. [a] -> [[a]] -> [a]"
16:54:12 <lambdabot>  "forall <- a. <- [a] <- -> <- [[a]] <- -> <- [a]"
16:54:55 <SamB> gwern: you about?
16:57:01 <EXetoC> Welcome DrMegahertz :-)
16:57:06 <DrMegahertz> Thx :)
16:57:06 <gwern> SamB: a little
16:57:24 <SamB> gwern: I will have a program for you to test in a little while
16:57:41 <SamB> a ZMachine frontend with no gtk2hs dependancy
16:57:51 <gwern> 'k
17:07:42 <Staz> @src foldr
17:07:42 <lambdabot> foldr f z []     = z
17:07:42 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:09:07 <godfool> fron
17:18:00 <SamB> gwern: okay, go ahead and pull that
17:18:07 <gwern> SamB: from the zmachine repo?
17:18:29 <SamB> gwern: yes
17:18:49 <gwern> just compile the bug.hs?
17:18:56 <SamB> the test is in bug2164.hs
17:19:01 <SamB> so, yeah, compile that
17:19:11 <SamB> or just load it in ghci, whatever
17:19:21 <hpaste>  gwern pasted "zmachine bug.hs output" at http://hpaste.org/6951
17:19:32 <gwern> didn't look like a crash to me
17:19:38 <SamB> huh
17:19:43 <SamB> it might be a gtk2hs bug?
17:19:59 <gwern> an awfully strange gtk2hs bug, if true
17:20:12 <gwern> why would it care if you type look map vs look at map?
17:20:17 <roconnor> zmachine -> http://www.sandia.gov/news/resources/releases/2006/images/z-machine.jpg ?
17:20:19 <lambdabot> http://tinyurl.com/22tx92
17:20:33 <SamB> not the one with the giant sparks
17:20:36 <SamB> the one with ZORK
17:20:58 <gwern> roconnor: and you call yourself a geek?
17:21:53 <shachaf> gwern: Isn't that usually "examine map", anyway? :-)
17:22:10 <gwern> shachaf: bah! I use intuitive words
17:22:19 <gwern> me talk pretty some day
17:22:23 <gwern> not today
17:22:26 <shachaf> gwern: I don't remember "look map" as working.
17:22:32 <SamB> shachaf: well, it does work
17:22:42 <SamB> in Museum.z5
17:22:46 <shachaf> It depends where, I suppose.
17:22:52 <gwern> shachaf: I think my point was that 'look map' shouldn't cause a segfault :)
17:23:31 <SamB> even if it turned out not to be a valid command, I'm fairly certain that zmachine handles those in a much-less-bad way than should cause a segfault ;-)
17:23:44 <SamB> I don't really remember using a Ptr anywhere except perhaps in loading stories
17:24:06 <SamB> and the segfault for that would happen before you saw >
17:24:40 <godfool> fron
17:24:57 <Cale> "I can has z-machine?" "I only understands you as far as wanting to has."
17:26:58 <Cale> Someone surely must have done a lolcats text adventure on the z-machine by now.
17:28:25 <SamB> you mean like "I can has cheeseburger" <<Take CheeseBurger>>?
17:28:51 <gwern> > I has can cheezburger? >> You have (1) canned cheeseburger
17:28:51 <lambdabot>  Parse error at ">>" (column 24)
17:28:52 <Cale> yes, and you would be a cat in serch of cheezburger
17:31:02 <shachaf> Is there a function for removing an element of a list at a particular position?
17:31:21 <SamB> tail
17:31:32 <SamB> it removes the element at the most particular position of all
17:31:51 <SamB> @hoogle Int -> [a] -> [a]
17:31:52 <lambdabot> Prelude.take :: Int -> [a] -> [a]
17:31:52 <lambdabot> Prelude.drop :: Int -> [a] -> [a]
17:31:52 <lambdabot> Data.List.take :: Int -> [a] -> [a]
17:31:55 <SamB> hmm.
17:32:03 <SamB> why the same one twice?
17:32:07 <SamB> @hoogle delete
17:32:08 <lambdabot> Data.List.delete :: Eq a => a -> [a] -> [a]
17:32:08 <lambdabot> Data.HashTable.delete :: HashTable key val -> key -> IO ()
17:32:08 <lambdabot> Data.Set.delete :: Ord a => a -> Set a -> Set a
17:32:15 <SamB> @hoogle deleteIndex
17:32:15 <lambdabot> No matches found
17:32:22 <SamB> @hoogle delete :: Int -> [a] -> [a]
17:32:22 <lambdabot> hoogle: Hoogle.Parser.readType: ([delete,::,Int,->,[,a,],->,[,a,]],BItem ::)
17:32:22 <lambdabot>  
17:32:26 <SamB> arg!
17:32:33 <Cale> I can has idiosyncratic conjugation!
17:33:28 <fnoble> can haskell test for equality with record types?
17:33:41 <fnord123> > tail [1, 2, 3]
17:33:42 <lambdabot>  [2,3]
17:33:55 <Cale> > let removeAt n xs = [x | (k,x) <- zip [0..] xs, k /= n] in removeAt 3 [1,2,3,4,5]
17:33:56 <lambdabot>  [1,2,3,5]
17:33:57 <shachaf> fnoble: If you derive Eq.
17:34:29 <fnoble> hmm, is there a function that tests if two things are the same object?
17:34:41 <Cale> > let removeAt n xs = ys ++ zs where (ys,z:zs) = splitAt n xs in removeAt 3 [1,2,3,4,5]
17:34:42 <lambdabot>  [1,2,3,5]
17:34:51 <shachaf> > let removeAt n xs = let (as,b:bs) = splitAt (n-1) xs in as ++ bs in removeAt 3 [0..10]
17:34:51 <lambdabot>  [0,1,3,4,5,6,7,8,9,10]
17:34:56 <Cale> fnoble: There's ==
17:34:58 <shachaf> Oh, too late.
17:35:12 <fnoble> ok, thanks
17:35:16 <Cale> fnoble: Values are otherwise indistinguishable.
17:36:11 <Cale> fnoble: It's important to point out that variables in Haskell are not what variables are in imperative languages. In an imperative language, a variable is a name for a box which might have any number of values at any given time. In Haskell, a variable is a name for a value.
17:36:29 <Cale> fnoble: So you can't tell if two things are the same box, because there is no box :)
17:36:31 <gwern> variables don't?
17:36:48 <Cale> They vary, but not in the same way that imperative variables do :)
17:37:22 <shachaf> So there's no library function to do it?
17:37:30 <Cale> Like, function parameters vary, but only between different applications of the function.
17:37:55 <Cale> shachaf: Not that I can tell. If it's something you need a lot of, lists are a bad choice.
17:38:22 <Cale> (though who knows, they may be your only choice, depending)
17:38:27 <fnoble> yep, ok, so the compiler might not keep the same value as the same physical object
17:38:39 <fnoble> so you cant really on physical equality
17:38:45 <fnoble> *rely
17:38:52 <Cale> fnoble: Right, that's up to the compiler. It also relocates things arbitrarily.
17:39:06 <Cale> (during garbage collection)
17:39:32 <Cale> So even if you did look at this stuff with low-level primitives, it wouldn't be too useful.
17:40:01 <jeffz> System.Mem.StableName is something similar though?
17:40:20 <Cale> Yeah, that's a way to make up for it to some extent.
17:40:33 <fnoble> ok, I only need to check for being the same value I think, but is this a sign of bad functional programming style to use ==?
17:40:46 <Cale> No, (==) is fine.
17:40:58 <Cale> fnoble: But what are you doing?
17:41:39 <Cale> Algorithms which avoid looking at elements of a structure (wherever that's possible) are usually considered more elegant than ones which do.
17:41:41 <fnoble> writing a routine to traverse up a tree, but need to check if Im at the root node
17:41:52 <fnoble> each node has a parent element
17:42:11 <Cale> ah, and how are these links stored?
17:42:39 <fnoble> data Node = Node { parent = Node ... }
17:42:49 <fnoble> maybe this is all rubbish :)
17:42:50 <Cale> oh, that's interesting...
17:42:54 <kpreid> that's not a good representation
17:43:02 <Cale> That looks like a child node to me :)
17:43:11 <kpreid> any time you modify any part of the tree you'd have to update every single other node
17:43:21 <kpreid> I suggest you use a zipper instead
17:43:27 <fnoble> zipper?
17:43:30 <Cale> Or just a regular tree?
17:43:39 <Cale> What are you doing with the tree?
17:44:46 <fnoble> ok, to actually state the problem, Im trying to basically represent a filesystem style structure
17:44:56 <Cale> okay
17:45:09 <fnoble> but where a directory can fill out its contents using a function
17:45:46 <Cale> a function of what sort of parameter?
17:46:12 <fnoble> I was thinking unit
17:46:25 <SamB> ???
17:46:30 <Cale> There's not much difference between () -> A and A in Haskell.
17:46:32 <fnoble> basically, the directoyr can choose what it contains itself
17:46:55 <Cale> Or do you want to actually store code in the directory tree?
17:47:07 <Cale> (which will be interpreted somehow by your program)
17:47:45 <fnoble> yeah, say one "directory" might just return a hard coded set of children
17:47:54 <SamB> Cale: it doesn't make much difference...
17:47:57 <fnoble> but one might generate its children by looking in a file
17:48:27 <SamB> wait what?
17:48:32 <fnoble> hmm, maybe i need to explore myself more before asking such vague questions :)
17:48:43 <Cale> fnoble: That's all right, I'm mostly following.
17:49:31 <Cale> fnoble: There are some options. You can store abstract syntax for some language at those nodes (and have an interpretation function for that syntax which goes to your tree type, possibly in the IO monad)
17:49:46 <Cale> Or you could just store IO actions at the nodes, depending on your needs
17:49:54 <Cale> Those aren't serialisable though.
17:50:29 <Cale> You might actually want to look into zipper data structures, since those are handy for the sort of moving around one does in a filesystem (in fact there is a real filesystem based on that datastructure)
17:51:03 <fnoble> ok, ill look into zippers and then maybe come back with a properly formulated question :)
17:51:28 <Cale> fnoble: But the usual style of upward links isn't so easy in a pure language.
17:52:02 <Cale> (which is why we have alternative data structures which maintain some level of efficiency in sharing subtrees when they need to be modified)
17:52:05 <SamB> I still don't understand how ZipperFS can allow multithreaded access like that...
17:52:52 <roconnor> SamB: doesn't it have some sort of central transaction arbitor?
17:52:57 * roconnor is not sure
17:53:48 <Cale> fnoble: http://www.haskell.org/haskellwiki/Zipper
17:53:49 <lambdabot> Title: Zipper - HaskellWiki
17:54:04 <SamB> dunno, but I just don't get how it can be functional and you can connect multiple telnets to it simultaneously...
17:54:53 <roconnor> SamB: a scheduler for threads?
17:55:01 <SamB> purely functional threading just blows my mind, I guess
17:55:14 <SamB> or I haven't looked at the right paper
17:55:30 <fnoble> can you do any kind of concurrency in a pure way?
17:55:33 <roconnor> I don't see how threads are any stranger than purely functional IO
17:55:39 <SamB> fnoble: well, this page says yes
17:55:44 <SamB> http://okmij.org/ftp/Computation/Continuations.html#zipper-fs
17:55:45 <augustss> SamB: Koen Claessen has good paper about it
17:55:45 <lambdabot> Title: Continuations and delimited control
17:55:54 <SamB> augustss: oh cool
17:56:04 <SamB> @go Koen Claessen threads
17:56:07 <lambdabot> http://osdir.com/ml/lang.haskell.glasgow.user/2002-09/threads.html
17:56:07 <lambdabot> Title: lang.haskell.glasgow.user (thread)
17:56:20 <SamB> hmm, wrong kind of threads
17:56:40 <fnoble> concurrency necessitates side effects i think
17:56:52 <roconnor> fnoble: how so?
17:57:06 <roconnor> or how is this different from IO
17:57:36 <clanehin> conurrency without side effects would just be parallelism.
17:57:42 <fnoble> it isnt different from IO, you cant have purely functional IO
17:57:47 <SamB> eh?
17:58:06 <SamB> according to that page, ZipperFS doesn't do IO in threads at all
17:58:14 <SamB> and the typesystem enforces this
17:58:29 <roconnor> oh
17:58:57 <fnoble> clanehin: exactly
17:59:20 <roconnor> SamB: do you know if the threads are preemptive?
17:59:26 <roconnor> or cooperative?
17:59:26 <SamB> roconnor: how can they be?
17:59:36 <SamB> not that they aren't
17:59:44 <SamB> just that *I* don't see how
18:00:05 <roconnor> well, if they are cooperative, then presumably it is easy to do in a purely functional way
18:00:26 <roconnor> threads + scheduler = pure function?
18:01:34 <roconnor> everything is deterministic
18:01:38 <SamB> augustss: do you happen to know the TITLE of the paper?
18:02:01 <SamB> roconnor: well, I'm not sure it can be quite that way
18:02:11 <SamB> how does the input work in that scenario?
18:02:34 <roconnor> SamB: you said the threads don't do IO
18:03:01 <SamB> well, honestly I'm not too clear on how this all works
18:03:41 <roconnor> :)
18:03:45 <SamB> but I'm not sure the schedular doesn't
18:05:55 <SamB> augustss: well???
18:06:29 <SamB> oh, A Poor Man's Concurrency Monad?
18:10:24 <SamB> wow, this paper is ancient
18:10:58 <SamB> class Monad m where (*) :: m a -> (a -> b) -> m b; return :: a -> m a
18:11:38 <Staz> @src length
18:11:38 <lambdabot> Source not found. My mind is going. I can feel it.
18:11:48 <joricj> exit
18:13:20 <fnoble> here is some good info about concurrency in haskell
18:13:21 <fnoble> http://research.microsoft.com/~simonpj/papers/marktoberdorf/mark.pdf
18:13:22 <lambdabot> http://tinyurl.com/yq63p6
18:14:09 <fnoble> which someone from this channel recommended to me
18:14:10 <dmhouse> SamB: that first one is fmap, not sure that's what you meant.
18:14:38 <SamB> dmhouse: well, just that it predates our Monad class...
18:15:06 <SamB> except maybe it doesn't
18:15:41 <SamB> hmm, January 1993 functional pearl...
18:16:08 <dmhouse> SamB: I got that, just that you made a typo, you said (*) :: m a -> (a -> b) -> m b.
18:16:20 <SamB> dmhouse: oh, oops
18:16:21 <dmhouse> fmap + return isn't Monad :)
18:16:22 <SamB> hah
18:16:38 <SamB> class Monad m where (*) :: m a -> (a -> m b) -> m b; return :: a -> m a
18:17:22 <SamB> Anyway, modern papers use something that looks more like >>=, generally, though they might squash the symbols together
18:18:16 <Cale> And even more modern papers might just go with do-notation :)
18:18:29 <SamB> oddly enough this one says it does that too
18:18:43 <SamB> I don't have a *clue* why they use (*) for bind!
18:27:23 <SamB> roconnor: hmm, in Claessen's paper, every action in the underlying monad takes up a time slice
18:28:22 <SamB> of course, nonterminating pure computations would throw a wrench in things ;-)
18:28:47 <roconnor> SamB: right, so it is cooperating threading
18:28:57 <roconnor> there is a yeild between every atomic block.
18:29:14 <roconnor> *yield
18:29:33 <SamB> or actually you could lift a big block I guess
18:29:39 <hpaste>  morrow annotated "GHC" with "get ghc-HEAD" at http://hpaste.org/6948#a3
18:29:41 <SamB> but that would be a bit selfish
18:30:23 <SamB> hmm, what kind of a morphism is lift?
18:34:53 <SamB> why do these people keep trying to make type synonyms instances of Monad?
18:35:02 <SamB> didn't anyone tell them this isn't allowed?
18:35:18 <Staz> @src map
18:35:18 <lambdabot> map _ []     = []
18:35:18 <lambdabot> map f (x:xs) = f x : map f xs
18:37:33 * clanehin must be tired, b/c he read type witnesses can't be instances of Monad.
18:37:54 <SamB> clanehin: can they?
18:38:00 <SamB> but yes, I suppose you must be
18:42:41 <clanehin> SamB: I would think so.
18:43:14 <clanehin> SamB: A good example doesn't come to mind though.
18:52:21 * solrize_ just bought an EEE PC, wheee
18:52:29 <solrize_> @seen shapr
18:52:29 <lambdabot> I saw shapr leaving #haskell-blah, #scannedinavian and #haskell 21h 34m 19s ago, and .
18:55:38 <mmorrow> \me just bought his mom a pink one
18:55:42 <mmorrow> ha
18:55:49 * mmorrow kids, it's green
18:55:58 <mmorrow> ee pc
18:55:59 <mmorrow> e
18:57:05 <SamB> nice, me and conal gave this article mostly the same tags
19:06:18 <clanehin> You know, sometimes debugging type errors in Haskell can be as time consuming as debugging dangling pointers in C.
19:12:53 <scook0> be glad they don't cause segfaults :)
19:13:46 <dino-> I am seeing an error from cabal trying to configure the SDL code:
19:13:50 <dino-> $ runhaskell Setup.lhs configure
19:13:56 <dino-> Setup.lhs:4:30: Not in scope: `autoconfUserHooks'
19:14:38 <dino-> I'm not sure what to change, the line in Setup is:
19:14:40 <dino-> > main = defaultMainWithHooks autoconfUserHooks
19:14:41 <lambdabot>  Parse error at "=" (column 6)
19:14:44 <allbery_b> what version of cabal?
19:15:06 <dino-> allbery_b: 1.2.3.0
19:17:59 <grom358> what is a good book to get familiar with Haskell for someone that has good knowledge of imperiative languages (Java, PHP, Python, D)?
19:18:19 <gnuvince_> grom358: I like Graham Hutton's "Programming in Haskell"
19:18:32 <gnuvince_> You can also try the wikibook
19:18:34 <gnuvince_> @go wikibook
19:18:36 <lambdabot> http://en.wikibooks.org/
19:18:36 <lambdabot> Title: Main Page - Wikibooks, collection of open-content textbooks
19:18:41 <sw17ch> http://en.wikibooks.org/wiki/Haskell
19:18:41 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
19:18:56 <sw17ch> i've only really used the Wikibook
19:19:10 <sw17ch> one of the best resources to get your feet wet... then you just need to write code and fix bugs
19:20:15 <grom358> does a lot of haskell knowledge transfer over to erlang and ocaml?
19:21:04 <gnuvince_> grom358: the general "functional thinking" translates pretty well.
19:21:16 <gnuvince_> O'Caml has side effects though, and Erlang is dynamically typed
19:21:22 <gnuvince_> So you'd use them differently.
19:22:34 <dino-> It was reading Yet Another Haskell Tutorial that really got me started. It's in the wikibooks as well.
19:22:59 <grom358> dino: yeah I'm looking at that one now
19:23:13 <allbery_b> hrmf.  can't find anything useful abotu that autoconfUserHooks thing
19:23:44 <dino-> Very very early on I read Haskell for C Programmers and found it absolutely confusing. Apologies to the author, just didn't work for me at all.
19:24:35 <dino-> allbery_b: Me either, but I see a pile of activity mentioning it from January. Like haskell-cafe and irc logs.
19:25:35 <grom358> also I see a number of people saying it takes awhile to get monads. I read about monads on wikipedia and it made sense
19:26:46 <grom358> i guess there must be more to it though. They use Maybe/Just/Nothing as example
19:30:48 <allbery_b> let's put it this way:  any time you (or most people) think you understand monads, someone can show you a monad that completely contradicts everything you think you know.  :)
19:31:15 <ddarius> False.
19:31:20 <gnuvince_> Haha :)
19:32:06 <grom358> allbery_b: yes I figure that would be the case
19:33:05 <allbery_b> well, maybe no contradicts.  but likely doesn't fit
19:34:04 <mib_hm246u> hey guys i want to create a syntax highlighter for a editor i created in wxhaskell, anyone familiar with the syntax ?
19:34:58 <allbery_b> highlighting-kate package on hackage?
19:35:31 <mib_hm246u> no i want to create my own, it's a project
19:36:43 <mib_hm246u> ???
19:36:49 <mib_hm246u> any help ???
19:37:34 <dino-> mib_hm246u: Do you mean you need to know more about Haskell source code syntax to write a highlighter?
19:37:59 <dino-> I haven't worked with wxHaskell yet myself, but I'd like to sometime in the future.
19:38:37 <dino-> You could try to mimic the colorizing that something already does, like Vim.
19:39:27 <mib_hm246u> dino- i am gonna do that, but i don't really no the color syntax, and it seems you don't either
19:39:41 <mib_hm246u> it cool though, thanks anyways
19:39:54 <allbery_b> I think mlost of us are not quite sure what you are asking.  "the color syntax"?
19:40:24 <dino-> Usually an editor does something for comments, something for literals (like strings), something for keywords.
19:40:29 <dino-> It can get fancier.
19:40:55 <allbery_b> that doesn't seem to fit what he seems to be asking
19:41:10 <allbery_b> not that I am sure I understand what he is saying at all
19:41:13 <dino-> I always sort of imagined that a syntax highlighter is an interesting and non-trivial problem involving at least partial parsing of the code at hand.
19:42:00 <bens> mib_hm246u: are you asking about how to change the colour of text in a wxhaskell component?
19:43:33 <mib_hm246u> yes
19:44:15 <bens> ah ha. I don't know about that but the question wasn't clear before. Maybe someone else does :)
19:52:04 <dino-> Well, I was able to change autoconfUserHooks to simpleUserHooks and get SDL to configure, but no build. I'm suspecting perhaps my system doesn't have the native SDL business required yet.
20:02:29 <andyjgill> Does anyone here have experience getting Cabal to work with autoconfUserHooks?
20:03:52 <allbery_b> @seen dcoutts_
20:03:52 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #ghc and #haskell. I don't know when dcoutts_ last spoke.
20:04:46 <dino-> andyjgill: I was just having trouble with that and the SDL package.
20:05:14 <andyjgill> Ahh. the *same* problem. What did you do?
20:05:24 <dino-> Not working yet.
20:05:50 <dino-> I did change it from autoconfUserHooks to simpleUserHooks. It thinks it configures now but does not build.
20:05:53 <dino-> Not sure why.
20:06:05 <dino-> Very possibly my native SDL stuff isn't installed right.
20:06:11 <andyjgill> I might try use the latest darcs
20:06:41 <andyjgill> I think you need the autoconf for it to work.
20:08:25 <dino-> yeah, I was suspecting that a naive change to simple* didn't really fix it.
20:09:02 <dino-> This stuff seems to have upheaved in 2008-Jan from the haskell-cafe and IRC stuff I see from searches.
20:09:06 <dino-> But I don't get what to do about it.
20:09:46 <andyjgill> Wait for the hackathon to fix things :-)
20:10:13 <dino-> :)
20:10:55 <allbery_b> when I did the google search I kept seeing references to cabal-1.3.something.  darcs?
20:11:15 <allbery_b> (autoconfUserHooks isn't in the installed cabal 1.2.3.0 here)
20:12:31 <allbery_b> the person to ask is dcoutts but he doesn't seem to be paying attention
20:12:45 <andyjgill> I'm not sure, but it seems that SDL uses a non-standard cabal.
20:13:30 <allbery_b> well, I saw commit messages for autoconfUserHooks, which is why I'm suspecting it wants the darcs Cabal
20:16:52 <allbery_b> autoconfUserHooks is definitely in darcs
20:17:01 <allbery_b> you need the unreleased Cabal to build it, apparently
20:17:12 * allbery_b is poking at http://darcs/haskell.org/Cabal
20:17:13 <lambdabot> Title: Kolmic.com
20:17:17 <allbery_b> oops
20:17:21 <lament> auto-confuser? :)
20:17:22 * allbery_b is poking at http://darcs.haskell.org/Cabal
20:17:29 <lambdabot> Title: Index of /Cabal
20:18:11 <allbery_b> there are quite a few people who would agree that autoconf is an autoconfuser :)
20:18:47 <allbery_b> problem is, it's the worse possible portability configuration system except for all the others (to paraphtase)
20:19:31 <lament> C is sin, and autoconf is the punishment
20:19:32 <mwc> allbery_b: I disagree. Cmake kicks ass
20:35:38 * gwern wonders how many unreleased versions of cabal there will be; I think darcs is up to like 1.5.1
20:39:28 <gwern> @hoogle lookup
20:39:28 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
20:39:28 <lambdabot> Data.List.lookup :: Eq a => a -> [(a, b)] -> Maybe b
20:39:28 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
20:39:42 <gwern> @info Data.Map.lookup
20:39:42 <lambdabot> Data.Map.lookup
20:39:55 <gwern> @src Data.Map.lookup
20:39:55 <lambdabot> Source not found. That's something I cannot allow to happen.
20:40:00 <gwern> @hoogle Data.Map.lookup
20:40:00 <lambdabot> No matches, try a more general search
20:40:06 <gwern> :t Data.Map.lookup
20:40:12 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
20:40:17 <gwern> finally
20:47:52 <hpaste>  ArcSin_ pasted "GHC "make install"" at http://hpaste.org/6952
20:54:03 <allbery_b> ArcSin_: either you need to configure with --prefix in a directory you can write to, or you need to run the "make install" as root.  (generally "sudo make install" on modern linux distributions)
20:56:31 <haskelln00b> hi all
20:56:40 <ArcSin_> allbery_b!  It works!!!!!!!!!!!!!!!!!! =]
20:56:59 <haskelln00b> congradulations!
20:57:09 <haskelln00b> :)
20:57:36 <EXetoC> hi
20:58:00 <haskelln00b> you know sometimes you write a haskell code (GUI)..n when you are testing
20:58:07 <haskelln00b> a particular something
20:58:14 <haskelln00b> everything vanishes
20:58:21 <haskelln00b> the ghci and you GUI
20:58:26 <haskelln00b>  vanishes
20:58:34 <haskelln00b> what does that mean?
20:58:40 <ArcSin_> ?
20:58:46 <haskelln00b> hi exetoc
20:58:57 <EXetoC> hi. what GUI?
20:59:10 <haskelln00b> wxhaskell
20:59:14 <EXetoC> oh
20:59:18 <TomMD> You got it running? wow
20:59:24 <haskelln00b> yes
20:59:33 <haskelln00b> i made so much progress
20:59:39 <haskelln00b> it can do stuff now
20:59:40 <allbery_b> with a gui framework it usually means you tickled a bug somewhere.  (gtk2 has many, gtk2hs is prone to tickling them.  if you have a terminal window open you will generally see gtk2 assertion failures, which are gtk2 saying "um, I blew it")
20:59:45 <haskelln00b> i can save items
21:00:06 <haskelln00b> humm
21:00:07 <allbery_b> I would not be surprised if wxhaskell has some as well, but I'm not very familiar with it.
21:00:20 <haskelln00b> it means i wrote something wrong right?
21:00:30 <allbery_b> (last time I tried it on OSX, running a wxhaskell program opened Classic and then crashed before displaying a window)
21:00:36 <haskelln00b> i dont know what bugs are
21:00:46 <haskelln00b> im new to computers
21:01:08 <haskelln00b> really?
21:01:30 <haskelln00b> well it's taken me days..but the windows run..do you still
21:01:43 <allbery_b> (don't know what bugs are?  you'll find out, oh yes :)
21:01:46 <haskelln00b> have wxhaskell stuff on your pc?
21:02:12 <haskelln00b>  Graphics.UI.WX'
21:02:18 <haskelln00b> and ghci
21:02:19 <haskelln00b> ?
21:02:20 <EXetoC> What do i do if i want to make a quadruple datatype where element 1 and 2 and element 3 and 4 respectively must be of the same type?
21:02:23 <koninkje> haskelln00b: welcome back :)
21:02:59 <haskelln00b> thank you
21:03:05 <koninkje> EXetoC: newtype Foo a b = (a,a,b,b) ?
21:03:11 <haskelln00b> nice to see you koninkje
21:03:24 <scook0> or data Foo a b = MkFoo a a b b
21:03:31 <haskelln00b> wait
21:03:36 <koninkje> EXetoC: or 'data' or 'type'...
21:03:40 <haskelln00b> but doesnt he have to use data
21:03:45 <EXetoC> i see. thank you
21:03:49 <haskelln00b> instead of newtype
21:04:07 <scook0> koninkje's newtype is not quite correct
21:04:12 <scook0> because it's missing a constructor
21:04:39 <haskelln00b> newtype can only be used with one thingy
21:04:53 <scook0> haskelln00b: a 4-tuple is one thingy
21:04:55 <haskelln00b> (i think..) not that i know
21:05:02 <koninkje> scook0: yeah, it's missing the data constructor for one
21:05:20 * koninkje replied before verifying
21:05:27 <scook0> haskelln00b: newtype Foo a b = MkFoo a a b b would be illegal
21:05:40 <scook0> but newtype Foo a b = MkFoo (a, a, b, b) is allowed
21:05:46 <haskelln00b> but what would be legal?
21:05:59 <scook0> though I don't think there's much point wrapping a tuple in a newtype
21:06:14 <haskelln00b> but that is what she wrote?
21:06:26 <koninkje> scook0: depends on the use. 'type' will generally be sufficient, but who knows
21:06:36 <haskelln00b> ohhh
21:06:37 <haskelln00b> i see
21:06:42 <haskelln00b> ohh kool
21:06:53 <scook0> I personally avoid type
21:06:56 <haskelln00b> thanks
21:07:01 <haskelln00b> scook0
21:07:06 <haskelln00b> or anyone
21:07:08 <koninkje> scook0: any reason why
21:07:09 <koninkje> ?
21:07:12 <haskelln00b> want to look at my code
21:07:24 <scook0> because it's unchecked
21:07:40 <scook0> there are legitimate uses of it
21:08:00 <scook0> but I prefer to either use a genuinely new type, or else use the underlying type without an alias
21:08:15 <haskelln00b> ohh
21:08:37 <koninkje> I tend to use them to increase semantic legibility
21:09:33 <scook0> my own style is that if it's worth typeing, it's probably worth newtypeing
21:09:43 <kfish> w00t, the continuation fest is packed :-)
21:13:08 <haskelln00b> hifish
21:13:13 <haskelln00b> hope u are good
21:13:14 <haskelln00b> :)
21:19:48 <EXetoC> I'm thinking of writing a math reference app sometime. Haskell is a good choice right?
21:20:17 <EXetoC> Better than C++ i guess (the only language i really know)
21:21:17 <Cale> EXetoC: Haskell would make a really nice base for a computer algebra system.
21:21:41 <EXetoC> As i thought, thanks.
21:21:56 <EXetoC> AND, there's support for complex numbers :-)
21:22:04 <Cale> :)
21:22:06 <haskelln00b> :)
21:24:26 <solrize_> @faq I'm thinking of writing a math reference app sometime. Haskell is a good choice right?
21:24:26 <lambdabot> The answer is: Yes! Haskell can do that.
21:24:56 <Cale> lambdabot, you're so filled with optimism!
21:26:55 <haskelln00b> anyone knows wxhaskell?
21:27:24 <haskelln00b> lambdadot
21:28:39 <Cale> I know it a little bit.
21:28:58 <Cale> What's the question?
21:29:17 <haskelln00b> moving the cursor
21:29:26 <haskelln00b> do you have to set up
21:29:37 <haskelln00b> a coordinate system
21:29:58 <haskelln00b> or is there an easier way.. to move it to a certain point
21:30:04 <haskelln00b> on command
21:30:04 <Cale> I'm not sure what you mean -- in a text edit control? I think it generally handles things like that...
21:30:37 <Cale> Oh, you want to have some code which moves the cursor in an edit control?
21:30:56 <haskelln00b> we have a assingment in school to build an editor
21:31:04 <haskelln00b> like word document
21:31:13 <haskelln00b> my editor looks pretty
21:31:20 <haskelln00b> but it doesnt really work yet
21:31:28 <haskelln00b> fully
21:31:36 <haskelln00b> anyway we have to move the cursor
21:31:42 <haskelln00b> to a new line
21:31:53 <haskelln00b> like how notepad or word does
21:32:07 <haskelln00b> i saw somewhere that someone using wxhaskell
21:32:18 <haskelln00b> made up a coorniate system
21:32:32 <haskelln00b> i was wondering if you knew of another way
21:33:03 <Cale> Which control are you using for your edit box?
21:33:09 <Cale> (how are you creating it?)
21:33:27 <Cale> textCtrl will create a multi-line text control for you...
21:33:38 <haskelln00b> umm
21:33:45 <haskelln00b> can you look at my code
21:33:47 <haskelln00b> pleaase
21:33:53 <Cale> !hpaste
21:33:55 <haskelln00b> if you have time
21:33:58 <Cale> !paste
21:33:59 <hpaste> Haskell paste bin: http://hpaste.org/
21:34:06 <haskelln00b> oaky posting
21:34:09 <haskelln00b> thank you so much
21:37:29 <ZenGeek> hi
21:37:32 <ZenGeek> cal
21:37:34 <Cale> hello
21:37:55 <ZenGeek> whats the site again
21:37:55 <ZenGeek> ?
21:38:06 <Cale> The site for what?
21:38:14 <Cale> Haskell?
21:38:27 <roconnor> http://haskell.org
21:38:27 <lambdabot> Title: Haskell Community Server
21:39:49 <Cale> !paste
21:39:50 <hpaste> Haskell paste bin: http://hpaste.org/
21:39:55 <functor> Hello all, can some help me decipher what this error message means: *** Exception: exit: ExitFailure 1. I got it while to run a Setup.lhs file
21:40:11 <Cale> ZenGeek = haskelln00b, I think
21:40:28 <functor> *while trying to
21:41:08 <Cale> functor: It means that exitWith (ExitFailure 1) was called.
21:41:20 <Cale> functor: I'm not sure what it means in the specific context.
21:41:50 <Cale> (maybe look inside the Setup.lhs to see if there's anything nonstandard?)
21:42:14 <Cale> If it's being thrown by Cabal, I suppose we can go looking through the Cabal code to see what might cause that.
21:42:27 <functor> weird, I was just  installing a package from cable
21:43:29 <functor> http://haskell.org/pipermail/haskell-cafe/2007-July/028400.html
21:44:30 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HTTP-Simple-0.1 -- you downloaded the package from here?
21:44:31 <lambdabot> http://tinyurl.com/5w7odf
21:51:18 <hpaste>  haskelln00b pasted "for CALE and other WXHASKELLERS" at http://hpaste.org/6953
21:52:02 <Cale> I am guessing that got cut off -- could you paste the rest as an annotation?
21:54:38 <hpaste>  haskelln00b annotated "for CALE and other WXHASKELLERS" with "for CALE and other WXHASKELLERS" at http://hpaste.org/6953#a1
21:54:40 <functor> Cale, I've already downloaded it and extracted the package's contents. It's all sitting in a folder on my desktop; But I can't access the "Network.HTTP.Simple" module in ghci
21:55:24 <functor> what am I suppose to do?
21:55:43 <Cale> runghc Setup.lhs configure
21:55:54 <Cale> (first)
21:56:09 <hpaste>  haskelln00b annotated "for CALE and other WXHASKELLERS" with "for CALE and other WXHASKELLERS" at http://hpaste.org/6953#a2
21:56:27 <Cale> ZenGeek: thanks :)
21:57:13 <functor> I got an error: Setup.lhs: At least the following dependencies are missing: HTTP -any
21:57:26 <Cale> okay, so you need to install the HTTP package
21:58:19 <functor> sorry if that was a dumb question, but I've never don this before lol
21:58:24 <Cale> functor: While I'm actually pretty sure it needs the HTTP package to install, there's a tool called cabal-install which will download and install packages and their dependencies for you, which you might want to get at some point to avoid the hassle.
21:58:26 <hpaste>  (anonymous) annotated "for CALE and other WXHASKELLERS" with "(no title)" at http://hpaste.org/6953#a3
21:58:52 <Cale> ZenGeek: Now, what's the problem with this?
22:04:43 <functor> cale I think your right. ok, so I just ran "runghc Setup.lhs configure" for the HTTP package, whats my next step in this process?
22:05:00 <Cale> runghc Setup.lhs build
22:05:17 <Cale> and then (possibly sudo)  runghc Setup.lhs install
22:05:26 <roconnor> for the HTTP package
22:05:52 <Cale> (and then a similar process for the other package)
22:06:07 <functor> then: "runghc Setup.lhs install"?
22:06:53 <roconnor> functor: if "runghc Setup.lhs install" fails you will need to "sudo runghc Setup.lhs install"
22:06:59 <roconnor> this will install the package
22:08:25 <functor> Awesome! It worked!
22:09:09 <roconnor> now you can go back to your other package
22:09:37 <adu> I wonder how many people here are working on Yi
22:13:04 <exe> How do I flush the buffer of the standard output? (the one I write to with putStr for example)
22:13:27 <adu> flush?
22:13:36 <exe> hFlush stdout?
22:14:00 <adu> putStr already does that
22:15:14 <adu> oo your right
22:15:17 <adu> there is an hFlush
22:16:22 <adu> so are you using hPutStr?
22:16:41 <awesame> @src putStr
22:16:41 <lambdabot> putStr s  = hPutStr stdout s
22:17:26 <adu> exe: yeah, you don't need hFlush
22:17:48 <awesame> I think hFlush stdout does what exe wants
22:18:03 <exe> Now it workes with hFlush stdout
22:18:10 <adu> ok
22:18:11 <exe> :_D
22:18:16 <exe> Thanks guys.
22:18:19 <exe> -sss
22:18:35 <roconnor> exe you may also find hSetBuffering NoBuffering useful depeding on your application
22:18:40 <awesame> exe: you can also do hSetBuffering stdout LineBuffering to make it flush every time you output a \n
22:18:58 <roconnor> awesame: isn't stdout LineBuffered by default?
22:18:59 <awesame> yeah, or NoBuffering as roconnor suggests
22:19:28 <exe> Great, thank you, it will be pretty useful.
22:19:36 <awesame> roconnor: I think it's not, because I ended up doing that explicitly, but maybe I was confused
22:24:26 <mauke> putStr doesn't call flush
22:24:42 <mauke> stdout is block buffered by default unless it's connected to a terminal, in which case it's line buffered
22:27:00 <adu> < do { b <- hGetBuffering stdout ; putStr (show b) }
22:27:15 <adu> > do { b <- hGetBuffering stdout ; putStr (show b) }
22:27:17 <lambdabot>   Not in scope: `stdout'
22:27:31 <roconnor> aww
22:27:42 <adu> well, thats supposed to say
22:27:44 <adu> "LineBuffering"
22:28:22 <mauke> unlikely
22:28:38 <kfish> ohoh, fresh oleg code
22:28:40 <mauke> I doubt code running in lambdabot is connected to a tty
22:29:51 <bd_> moreover you don't have access to IO in lambdabot
22:30:05 <bd_> certainly System.IO's not imported
22:30:10 <bd_> :t putStr
22:30:11 <lambdabot> String -> IO ()
22:30:16 <bd_> you've got the prelude IO stuff only really
22:30:24 <bd_> but no way to execute it ofc
22:35:34 <hpaste>  morrow pasted "Hole" at http://hpaste.org/6954
22:36:35 <hpaste>  morrow annotated "Hole" with "some usage" at http://hpaste.org/6954#a1
22:37:31 <roconnor> that appears at first glance to be awfully unsafe
22:43:48 <mmorrow> yeah, it's hard to place the seqs correctly
22:44:58 <mmorrow> o, n/m
22:47:54 <mmorrow> roconnor: what were you refering to?
23:01:07 <mauke> @hoogle time
23:01:07 <lambdabot> System.Time :: module
23:01:07 <lambdabot> Data.Time :: module
23:01:07 <lambdabot> System.Timeout.timeout :: Int -> IO a -> IO (Maybe a)
23:01:34 <mauke> @hoogle gettime
23:01:34 <lambdabot> Data.Time.LocalTime.getTimeZone :: UTCTime -> IO TimeZone
23:01:39 <mauke> :(
23:06:43 <solrize_> @seen shapr
23:06:43 <lambdabot> I saw shapr leaving #haskell-blah, #scannedinavian and #haskell 26m 57s ago, and .
23:35:12 <wadcom> hi
23:35:35 <wadcom> quick question: is there a shorter way to write the following function:
23:35:41 <wadcom> dataDirs ('d':'.':_) = True
23:35:41 <wadcom>     dataDirs _ = False
23:35:55 <wadcom> (match strings starting with "d.")
23:35:58 <wadcom> ?
23:36:18 <mauke> dataDirs = ("d." `isPrefixOf`)
23:37:06 <wadcom> great, thanks!
23:51:14 <wadcom> ...one more question: I can't figure out from docs which exception is thrown if I 'read "a" :: Int'
23:51:30 <mauke> > read "a" :: Int
23:51:32 <lambdabot>  Exception: Prelude.read: no parse
23:52:04 <mauke> are you trying to catch it?
23:52:11 <wadcom> 'no parse' -- what is that exactly? how do I handle it? and most importantly, where do I look to figure that out? :-)
23:52:35 <mauke> you handle it by using reads instead of read
23:52:58 <wadcom> hmm
23:53:12 <nornagon> :t reads
23:53:13 <lambdabot> forall a. (Read a) => String -> [(a, String)]
23:53:31 <wadcom> ah, got it, thanks
23:53:32 <bd_> > reads "123"
23:53:32 <lambdabot>  []
23:53:39 <bd_> > reads "123" :: [(Int, String)]
23:53:40 <lambdabot>  [(123,"")]
23:53:46 <bd_> > reads "123 4" :: [(Int, String)]
23:53:46 <lambdabot>  [(123," 4")]
23:54:01 <bd_> Hm, when does it return a list of more than one element?
23:54:22 <bd_> > toDyn $ reads "123"
23:54:22 <lambdabot>  Add a type signature
23:54:23 <Cale> bd_: If there are multiple possible parses
23:54:33 <Cale> bd_: I don't think any of the Prelude instances do that.
23:54:37 <bd_> and what type did reads "123" default to above
23:54:40 <bd_> ah, I see
23:54:46 <Cale> bd_: But it's something which you can do with your own instances.
23:55:07 <Cale> It probably defaulted to [((),String)]
23:55:10 <mauke> > reads "()"
23:55:11 <lambdabot>  [((),"")]
23:55:11 <Cale> > reads "()"
23:55:12 <lambdabot>  [((),"")]
23:55:13 <Cale> yep
23:56:19 <nornagon> > reads ""
23:56:20 <lambdabot>  []
