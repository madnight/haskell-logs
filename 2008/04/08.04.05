00:00:53 <Cale> You'll need all of  map, takeWhile, iterate, drop, take, not, null, (.)
00:01:49 <NekoIncardine> > map takeWhile not.null ( take 9 (iterate (drop 9) map ['a'..'z'] )
00:01:50 <lambdabot> Unbalanced parentheses
00:01:58 <NekoIncardine> > map takeWhile not.null ( take 9 (iterate (drop 9) map ['a'..'z'] ) )
00:01:58 <lambdabot>  Couldn't match expected type `a -> Bool'
00:02:15 <Cale> careful with the order of operations
00:02:35 <NekoIncardine> Hrm.
00:03:16 <Cale> function application has higher precedence than any operator symbol
00:03:31 <Cale> and  f g x  always means  (f g) x, and not f (g x)
00:03:38 <NekoIncardine> > map takeWhile (not.null) ( iterate ( take 9 (drop 9 map ['a'..'z'] ) ) )
00:03:39 <lambdabot>  Couldn't match expected type `a -> Bool'
00:04:08 <Cale> You're applying map to takeWhile, then to  (not.null), and lastly to ( iterate ( take 9 (drop 9 map ['a'..'z'] ) ) )
00:04:08 <NekoIncardine> Hrm... LEt's test a smaller one first.
00:04:22 <NekoIncardine> ... Ah.
00:04:29 <Cale> also, I don't think that you want the takeWhile *inside* the map
00:04:47 <NekoIncardine> ... Ah.
00:05:08 <Cale> I'll be back in a while, I'm just going to watch the new Battlestar Galactica episode which has finished downloading :)
00:05:19 <NekoIncardine> > takeWhile (not.null) map ( take 9 ( drop 9 map ['a'..'z'] ) )
00:05:21 <lambdabot>  Couldn't match expected type `[[a]]'
00:06:04 <Cale> Start with small expressions and work your way up.
00:06:18 <NekoIncardine> > takeWhile (not.null) map ( take 9 ( drop 9 ['a'..'z'] ) )
00:06:18 <lambdabot>  Couldn't match expected type `[[a]]'
00:06:21 <Cale> drop 9 map ['a'..'z']
00:06:25 <Cale> this is already a type error
00:06:33 <NekoIncardine> Yeah, I saw that one on a second glance.
00:06:40 <Cale> You're applying drop to 9, map, and ['a'..'z']
00:06:55 <NekoIncardine> > drop 9 ['a'..'z']
00:06:56 <lambdabot>  "jklmnopqrstuvwxyz"
00:07:25 <Cale> 'map' isn't one of the parameters which you want to pass to takeWhile
00:07:32 <NekoIncardine> > iterate drop 9 ['a'..'z']
00:07:32 <lambdabot>  Couldn't match expected type `Int'
00:07:43 <Cale> > iterate (drop 9) ['a'..'z']
00:07:44 <lambdabot>  ["abcdefghijklmnopqrstuvwxyz","jklmnopqrstuvwxyz","stuvwxyz","","","","","",...
00:07:50 <NekoIncardine> Hrm...
00:07:53 <Cale> Those parens are important!
00:08:03 <Cale> because otherwise, it means:
00:08:16 <Cale> ((iterate drop) 9) ['a'..'z']
00:08:20 <NekoIncardine> > map (take 9) ( iterate (drop 9) ['a'..'z'] )
00:08:21 <lambdabot>  ["abcdefghi","jklmnopqr","stuvwxyz","","","","","","","","","","","","","","...
00:08:40 <NekoIncardine> > takeWhile (not.null) ( map (take 9) ( iterate (drop 9) ['a'..'z'] ) )
00:08:41 <lambdabot>  ["abcdefghi","jklmnopqr","stuvwxyz"]
00:08:57 <Cale> there you go :)
00:09:00 <NekoIncardine> Yup.
00:09:15 <scook0> > takeWhile (not . null) . map (take 9) . iterate (drop 9) $ ['a'..'z']
00:09:16 <lambdabot>  ["abcdefghi","jklmnopqr","stuvwxyz"]
00:09:23 <NekoIncardine> Now to finish this portion up, then take a short break to refresh the brain. See if I can get my work downloads started finally.
00:10:17 <NekoIncardine> scook0: Huh. That adds to my knowledge, and makes sense given not.null
00:10:53 <scook0> yeah, all I did was tweak your version to reduce the parentheses
00:12:00 <NekoIncardine> You switch from .s to $ on the last one, though... Any reason for that?
00:12:56 <scook0> yes
00:13:03 <scook0> (.) composes two functions
00:13:10 <scook0> but ['a'..'z'] is not a function
00:13:28 <scook0> instead, what I want to do there is apply the composed function to ['a'..'z']
00:13:54 <scook0> ($) is another way of writing function application
00:14:02 <NekoIncardine> So $ means "Apply function before the $ to list or function output after the $"?
00:14:20 <scook0> i.e. f x is the same as f $ x, but with different precedence
00:14:28 <NekoIncardine> Hrm.
00:14:38 <scook0> it just means "apply the function on the left to the term on the right"
00:14:57 <scook0> > (takeWhile (not . null) . map (take 9) . iterate (drop 9)) ['a'..'z']
00:14:57 <lambdabot>  ["abcdefghi","jklmnopqr","stuvwxyz"]
00:15:42 <NekoIncardine> I see.
00:16:15 <scook0> ^^ in that case I eliminated the ($), but I had to insert some extra parens to get it to do what I wanted
00:16:53 <NekoIncardine> I'm not entirely sure I understand the idea perfectly, but I get the gist of it.
00:17:05 <scook0> it's quite common to see something that looks like f . g . h $ x
00:17:14 <scook0> i.e. (f . g . h) x
00:17:29 <scook0> which means "apply h to x, then apply g to the result, then apply f to the result of that"
00:18:20 <glguy> ( scratchpad ) CHAR: a CHAR: z 1 <range> >string 9 group .
00:18:20 <glguy> { "abcdefghi" "jklmnopqr" "stuvwxyz" }
00:18:33 <NekoIncardine> tileToChar x | x == Solved 1 = '1'
00:18:35 <NekoIncardine>              | x == Unsolved [*] = ' '
00:18:36 <scook0> using (.) and ($) generally isn't *necessary*, but it can help make your code more readable once you're familiar with them
00:18:37 <NekoIncardine> ^- Obviates out the cases 2..9, since the problem is with the last one. I've tried a few different things, basically what I want is "ANY Unsolved = ' '"
00:19:17 <glguy> or rather, CHAR: a CHAR: z [a,b] >string 9 group .
00:20:09 <scook0> NekoIncardine: what's the definition of that datatype you've got there?
00:20:20 <NekoIncardine> Unsolved [Integer]
00:20:40 <scook0> ok, it looks like you want:
00:20:55 <NekoIncardine> I tried "Unsolved = ' ' ", "Unsolved []" = ' '", and both caused similar glitches.
00:21:08 <Jedai> Unsolved _ = ' '
00:21:37 <Jedai> The _ is a "wildcard" that can accept any value and ignore it
00:21:39 <NekoIncardine> Jedai: Where _ means "Anything not enumerated in a case below", basically?
00:22:23 <Jedai> You could also do Unsolved x = ' ' but the binding to x isn't used in the body of the function so it's less clear from the pattern what you're going to do
00:23:28 <Jedai> NekoIncardine: No, _ means "anything", so if you have case like "Unsolved whatever" after this line they'll never be used
00:23:47 <NekoIncardine> ... "Illegal _ in expression"? O_o;
00:24:17 <NekoIncardine> Obviously there's some rule on _ I've missed here.
00:24:32 <Jedai> Oh, you're using that in guards, you must use patterns here, that will be more clear and shorter
00:24:48 <NekoIncardine> in guards?
00:24:58 <Jedai> tileToChar (Solved x) = show x
00:25:09 <Jedai> tileToChar (Unsolved _) = ' '
00:25:11 <NekoIncardine> ... Ah.
00:25:58 <Jedai> | introduce a guard, that is a boolean expression, that determines which body you choose for the function
00:26:02 <scook0> actually, you'll need head (show x)
00:26:06 <mikmik> when doing runghc Setup.hs configure
00:26:11 <scook0> because show produces a string
00:26:12 <mikmik> I'm getting <interactive>:
00:26:14 <mikmik> unknown symbol `_oldzmtimezm1zi0zi0zi0_SystemziTime_a99_info'
00:26:16 <mikmik> ghc-6.8.2: unable to load package `Cabal-1.2.3.0'
00:26:24 <mikmik> any ideas why?
00:26:30 <Jedai> scook0: Right :-)
00:27:05 <Jedai> tileToChar (Solved x) = head (show x)
00:27:05 <Jedai> tileToChar (Unsolved _) = ' '
00:27:28 <scook0> and that new definition for the Solved case now gives slightly different results if x isn't in [0..9]
00:27:42 <scook0> (which is invalid input anyway)
00:28:50 <NekoIncardine> Hrm.
00:31:28 <NekoIncardine> " printableBoard x = takeWhile (not.null) ( map (take 9) ( iterate (drop 9) ( map (tileToChar x) ) ) ) " <- Takes a Board, but works on individual Tiles. How do I typecast 'x' as [Tile] instead of Board?
00:31:44 <NekoIncardine> scook0++
00:32:28 <Jedai> NekoIncardine: There's a small error in there : "map tileToChar x" rather than "map (tileToChar x)"
00:32:44 <scook0> what do you want the type of printableBoard to be?
00:33:03 <NekoIncardine> scook0: The end type is [Char], the input type is Board.
00:33:09 <Jedai> NekoIncardine: But Board == [Tile] anyway ?
00:33:13 <NekoIncardine> data Board = Board [Tile] <- The definition.
00:33:26 <NekoIncardine> This was based off earlier readings, if this is a bad form...
00:33:30 <NekoIncardine> ... Never mind.
00:33:32 <Jedai> NekoIncardine: Ok, then you use a pattern
00:33:33 <NekoIncardine> It is.
00:33:41 <NekoIncardine> It uses a pattern and doesn't need ot.
00:33:44 <sclv> a blog post with some of the things i've been toying with lately: http://fmapfixreturn.wordpress.com/2008/04/05/type-hackery-for-the-practical-programmer/
00:33:46 <lambdabot> Title: Type-hackery for the practical programmer « fmap fix return, http://tinyurl.com/6zyzwl
00:33:56 <Jedai> printBoard (Board ts) = ... ts
00:33:57 <NekoIncardine> IT's supposed to be ONE list of tiles, not several.
00:33:57 <scook0> printableBoard (Board tiles) = ...
00:34:52 <NekoIncardine> Hrm.. So In other words, change the line to: printableBoard (Board x) = takeWhile (not.null) ( map (take 9) ( iterate (drop 9) ( map tileToChar x ) ) )
00:35:02 <Jedai> Yes
00:35:15 <NekoIncardine> Hrm...
00:35:35 <Jedai> But if you want the return type to be [Char] and not [[Char]], you'll need to add a unlines
00:35:55 <NekoIncardine> @src unlines
00:35:55 <lambdabot> unlines = concatMap (++ "\n")
00:36:20 <Jedai> printableBoard (Board tiles) = unlines . takeWhile (not.null) . map (take 9) . iterate (drop 9) . map tileToChar $ tiles
00:36:22 <NekoIncardine> Which is precisely the desired effect anyways.
00:38:15 <scook0> incidentally, it might be worth spinning off the "split into lines of length 9" into its own function
00:39:48 <Jedai> scook0: Right, in fact I think it should be in the standard lib, I use it often
00:43:11 <dibblego> ?type isSuffixOf
00:43:13 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
00:43:22 <dibblego> what's a good QC property for isSuffixOf?
00:43:27 <Jedai> @src isSuffixOF
00:43:27 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
00:43:30 <Jedai> @src isSuffixOf
00:43:30 <lambdabot> isSuffixOf x y = reverse x `isPrefixOf` reverse y
00:43:34 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6837
00:43:56 <scook0> @check \xs ys -> ys `isSuffixOf` (xs ++ ys)
00:43:57 <lambdabot>  OK, passed 500 tests.
00:45:25 <dibblego> nice thanks
00:46:16 <NekoIncardine> All right. Now that I have the makeBoard final input step and printableBoard output implemented and partially tested (made a quick Main), now I get to start figuring out the actual solver.
00:46:20 <NekoIncardine> Break time first. X_x
00:48:25 <NekoIncardine> Hrm... I can see quite a few ways to handle solving a board from a large number of unSolveds.
01:12:54 <glguy> What does it mean if you dream about a project euler problem and then you wake up only to manage to solve it on the way to work, but it ended up not being a real project euler problem when you went to submit
01:13:09 <idnar> haha
01:13:22 <idnar> a completely hypothetical situation, of course
01:13:32 <glguy> yeah, like, what if that happened *tomorrow*
01:13:35 <glguy> :-o
01:15:15 <sieni> reminds me of a story about a psychiatrist's patient who could only remember his future but not his past
01:15:40 <idnar> I thought that was Merlin
01:15:58 <glguy> whoa, the problem I was working out is quite similar to the one that was just released!
01:16:05 <glguy> I've got ESP
01:16:36 <idnar> or maybe you surf the internet in your sleep
01:16:45 <Twey> Hahahaha
01:17:01 <idnar> http://xkcd.com/269/
01:17:02 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
01:26:36 <glguy> I'm glad to see Randall got off the blue lightning sky choices theme and back on something worth reading
01:26:48 <glguy> even if only slightly
01:32:47 <Mystia_Lorelei> Gaaah.
01:36:32 <NekoIncardine> MY connection is annoying at this time of night >_<
01:43:31 * NekoIncardine gives up for tonight. This connection won't stop crashing for hours >_<
01:53:10 <NekoIncardine> Hrm... the C method I used weeks ago is not going to work here at all.
01:53:39 <NekoIncardine> It relies on iterative loops, which I see no real equivalent for here...
01:59:33 <glguy> :t mapM
01:59:36 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
01:59:37 <glguy> :t forM
01:59:38 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
01:59:44 <glguy> :t mapM_
01:59:45 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
01:59:53 <glguy> iterative loops !
02:00:22 <glguy> :t forever
02:00:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
02:06:47 <NekoIncardine> Hrm. o_O
02:07:01 <NekoIncardine> I can tell I'm going to need caffiene for this.
02:07:36 <ttt--> @info forever
02:07:36 <lambdabot> forever
02:07:42 <ttt--> @src forever
02:07:42 <lambdabot> Source not found. I've seen penguins that can type better than that.
02:08:02 <glguy> forever m = m >> forever m
02:09:12 <ttt--> > forever []
02:09:14 <lambdabot>  []
02:09:59 <ttt--> > forever [3]
02:10:02 <lambdabot>  Exception: stack overflow
02:10:38 <Cale> > forever Nothing
02:10:38 <lambdabot>  Nothing
02:10:42 <Jiten> I don't think it's very good function to use with list monad :)
02:10:45 <Cale> > forever (Just 4)
02:10:50 <lambdabot> Terminated
02:10:57 <Cale> heh
02:11:16 <idnar> I'd love to see a penguin that could type
02:11:47 <Cale> Clearly that's Just 4  ;)
02:14:46 <NekoIncardine> idnar: ... Where did that come from? O_o
02:14:55 <idnar> NekoIncardine: lambdabot's error message just now
02:15:19 <Twey> @src forever
02:15:19 <lambdabot> Source not found. I've seen penguins that can type better than that.
02:15:21 <Twey> :<
02:15:33 <NekoIncardine> .. Ah.
02:15:57 <Twey> :-)
02:16:20 <NekoIncardine> Hrm...
02:16:22 <idnar> < glguy> forever m = m >> forever m
02:17:26 <Twey> Oh, heh.
02:17:47 <Twey> Why is the source not available?  Is it defined per monad?
02:20:07 <Heffalump> no
02:20:18 <Heffalump> @src foreverM
02:20:18 <lambdabot> Source not found. There are some things that I just don't know.
02:20:20 <ttt--> how come forever [] terminates?
02:20:32 <Heffalump> because [] >> ... = []
02:24:19 <NekoIncardine> Okay, basically I have two ideas on how to run this. One is a recurring recursion, the other is probably more robust.
02:25:24 <NekoIncardine> Hrm... The more I think about it, that might not work.
02:26:36 <NekoIncardine> My basic idea: Locate first Unsolved tile with it's list having length 1 (indicating that there is only one possibility left). Take the tiles in the matching row, column, and group and remove that number from their Unsolved lists. Switch the initial tile to Solved. Repeat.
02:33:55 <HunterXHunter> monad is the hardest concept in haskell to grasp
02:34:27 <idnar> HunterXHunter: just wait until you get to the *really* hard stuff ;)
02:41:46 <solrize> @goo RM800.00
02:41:47 <lambdabot> No Result Found.
02:42:50 <NekoIncardine> I'm going to get some sleep and try this tomorrow. x_x
02:43:04 <solrize> sleep... that's a cool idea.  i'll try that too.
02:43:07 <solrize> nite
02:43:19 <bd_> HunterXHunter: No, doing math with instances is much harder.
02:44:06 <vegai> monad is the hardest concept to grasp whose grasping has any practical benefit
02:44:09 <vegai> ;)
02:44:55 <sieni> a monad isn't even that hard to grasp
02:45:28 <sieni> is monad for example more difficult to grasp than a hilbert space?
02:46:01 <sieni> or fourier transform
02:46:18 <Japsu> fourier transform was easy to grasp
02:46:20 <NekoIncardine> All right... Let me ask this principle-setting question. I have a list of 81 objects, all either of Solved Integer, or Unsolved [Integer]. I want to get the position in the list of the first Unsolved whose list length is 1.
02:46:20 <vegai> dunno. But that is not as directly related to Haskell as monads
02:46:49 <NekoIncardine> This would then let me use xs !! n to manipulate that item.
02:46:55 <Japsu> NekoIncardine: why do you need the position? are you aware that indexing lists with !! is O(n)?
02:47:03 <sieni> vegai: your statement seemed to have quite a large applicability
02:47:17 <Japsu> NekoIncardine: if you can get to that item other ways than xs !! n, it would probably be faster.
02:47:37 <Japsu> @src (!!)
02:47:37 <lambdabot> xs     !! n | n < 0 = undefined
02:47:37 <lambdabot> []     !! _         = undefined
02:47:37 <lambdabot> (x:_)  !! 0         = x
02:47:37 <lambdabot> (_:xs) !! n         = xs !! (n-1)
02:47:41 <NekoIncardine> True... Given I need to manipulate that item and 22 others at any one time, though?
02:48:11 <Japsu> NekoIncardine: are they a contiguous block or scattered?
02:48:24 <NekoIncardine> Scattered, and only 20 actually.
02:48:50 <NekoIncardine> The 81 positions represent a 9*9 sudoku board; thus I need to manipulate every tile in the same row, the same column, and the same group.
02:49:17 <Japsu> NekoIncardine: if you really need to do random access, you're better off with a data type that supports O(1) indexing, for example, http://haskell.org/ghc/docs/latest/html/libraries/array/Data-Array.html
02:49:20 <lambdabot> http://tinyurl.com/2uoebz
02:49:26 <Cale> I would almost certainly use an array, myself.
02:49:41 <Cale> (and it would be indexed by (Integer, Integer) pairs)
02:49:52 <NekoIncardine> .. I see.
02:50:07 <Japsu> Cale: you sure you would use Integer? sudokus are, after all, usually just 9x9 ;)
02:50:17 <Cale> Japsu: Premature optimisation
02:50:23 <Japsu> right
02:50:31 <NekoIncardine> Problem there is recoding, well, everything (including IO my partner is doing) to be array instead of int based.
02:50:54 <NekoIncardine> Or am I overestimating the difficulty of Array manipulation?
02:51:33 <hpaste>  NekoIncardine pasted "Sudoku Work (boardbuilding and display)" at http://hpaste.org/6838
02:51:35 <Cale> It's actually simpler than list manipulation for this task.
02:52:04 <Cale> You can also easily get the list of elements of an array
02:52:15 <Cale> So you don't have to lose the code you have which works for lists.
02:52:57 <NekoIncardine> Okay... Then starting from the top. That means redefining type Board (For 9-element items i.e. tiles I'm not even going to bother)
02:53:32 <NekoIncardine> "data Board = Board Array Integer Tile" would be an accurate replacement to switch the board to an array, correct?
02:54:08 <Cale> data Board = Board (Array (Integer, Integer) Tile)
02:54:49 <Cale> Using a 1-D array for a Sudoku board seems overcomplicated :)
02:54:52 <NekoIncardine> Hrm... That will mean full reimplementation of two commands. Nothing significant though.
02:55:04 <NekoIncardine> Eh, I already wrote the algorithms honestly :P
02:55:23 <NekoIncardine> (They're in the pastebox)
02:55:39 <NekoIncardine> But why not, it's only one command needing full reimplementing (Groupfind)
02:56:21 <Cale> Also, I'm not sure those are the functions you *really* want :)
02:56:24 <NekoIncardine> > array (9,9) [(1,1) .. (9,9)]
02:56:25 <lambdabot>   add an instance declaration for (Enum (t, t1))
02:57:17 <NekoIncardine> Cale: We'll figure that out as I go here...
02:57:17 <Cale> Really you're more interested in constructing the list of indices (n,m) consisting of the row, column, or box in which a given point (i,j) lies.
02:58:13 <Cale> Because whenever you do one of your tests, you're starting from some position (i,j), and wondering where you should look from there for cells to simplify.
02:58:46 <NekoIncardine> Hrm... First step, remake MakeBoard. Since I'm not switching Tile over, charToTile remains the same, so I just need to modify makeBoard...
03:00:40 <Cale> > listArray ((1,1),(9,9))
03:00:40 <lambdabot>  Add a type signature
03:00:42 <Cale> listArray ((1,1),(9,9))
03:00:50 <Cale> is the function you'll want to use
03:01:06 <NekoIncardine> Because that one can be manipulated as a list as well as an array?
03:01:20 <NekoIncardine> That form, rather?
03:01:37 <Cale> listArray is a function which takes a pair of bounds, and a list, and produces an array by filling the indices between those bounds with the elements of the list
03:02:55 <NekoIncardine> So it would be "makeBoard y = Board listArray ((1,1),(9,9)) [Content defining method here]"?
03:03:10 <Cale> yes, except you need parens
03:03:27 <NekoIncardine> From start of ListArray to end of code?
03:03:31 <Cale> yeah
03:03:44 <Cale> Because Board has only one parameter and not 3
03:04:06 <NekoIncardine> All right... And then a map function on y with charToTile would fill the list, 1,1 to 1,9 then 2,1 to 2,9 or...?
03:04:16 <NekoIncardine> Since y remains a one-dimensional list atm.
03:04:39 <Cale> yeah.
03:04:45 <Cale> (try it)
03:04:49 <NekoIncardine> @src map
03:04:49 <lambdabot> map _ []     = []
03:04:49 <lambdabot> map f (x:xs) = f x : map f xs
03:05:36 <Cale> > listArray ((1,1),(3,3)) ['a'..'i']
03:05:38 <lambdabot>  array ((1,1),(3,3)) [((1,1),'a'),((1,2),'b'),((1,3),'c'),((2,1),'d'),((2,2),...
03:06:33 <mib_g5224kl9> newbie can't get hugs to work
03:07:08 <mib_g5224kl9> fires it up cuts and pastes example from tutorial and gets an error
03:07:25 <NekoIncardine> And one mistake I just fixed, I had the map in a [ ] when it should have been just ()
03:07:42 <mib_g5224kl9> should I get an error if I enter "size :: Int" at the prompt?
03:07:55 <Cale> mib_g5224kl9: You should be aware that declarations go into a file, and hugs loads that file and then evaluates expressions based on the declarations
03:08:19 <Cale> mib_g5224kl9: yeah, you'll probably get a 'not in scope' or something like that
03:08:45 <NekoIncardine> A delcaration like that needs to go into a source file, then have a defined function to match (typically on the next line), like size = 42 or something
03:08:58 <Dessous> @src Just
03:08:58 <lambdabot> Source not found. Maybe you made a typo?
03:09:20 <mib_g5224kl9> No global scope then - that's not what Thomson's book suggests - oh well
03:09:21 <Cale> mib_g5224kl9: It's helpful to keep your editor window open alongside hugs, and then whenever you make a change, :r will reload the file
03:09:41 <Cale> mib_g5224kl9: There is a file-global scope.
03:09:46 <NekoIncardine> Or in winHugs, just tap the reload button and it types in :r for you!
03:09:55 <mib_g5224kl9> hmmm - wasn't impressed when the uninstaller fell over with an illegal instruction error
03:09:56 <Cale> mib_g5224kl9: The thing is that the hugs prompt is not the same as the toplevel of a file.
03:09:57 <NekoIncardine> Next phasee... printableBoard.
03:10:19 <mib_g5224kl9> ok - thanks -
03:10:38 <NekoIncardine> Next to fix: printableBoard.
03:10:48 <Cale> mib_g5224kl9: The hugs prompt is asking you for an expression, which it will evaluate to a particular value, and print.
03:11:04 <NekoIncardine> In fact, I can probably redo this one wholesale in a two-dimensional context. o_O
03:11:21 <mib_g5224kl9> right: I understand now - most interpreters I 've used allow you top level declarations
03:12:04 <Cale> mib_g5224kl9: For hugs, the top level declarations are the ones in the file you load :)
03:12:32 <mib_g5224kl9> anyway - thanks all
03:12:48 <Cale> mib_g5224kl9: The issue is made a bit more complicated because Haskell declarations can be mutually recursive.
03:13:17 <Cale> (there are ways to solve this, but Hugs has taken the easy way out)
03:13:44 <mib_g5224kl9> I'm wondering about an alternative to hugs
03:13:53 <Cale> GHC is what most people use
03:13:54 <mib_g5224kl9> goes to look up www.haskell.org
03:13:58 <Cale> Along with GHCi
03:14:34 <Cale> What operating system are you running?
03:15:14 <mib_g5224kl9> XP
03:15:36 <mib_g5224kl9> I'll try GHC
03:17:07 <NekoIncardine> Hrm... Really not sure where to start with printableBoard. I get the sense that ultimately I will still be using unlines, but from there...
03:19:04 <NekoIncardine> My big questions are how to read individual cells from an array, and how to read defined groups of an array. Iv'e seen plenty of explenations on WRITING, but none on READING.
03:19:50 <mauke> :t (!)
03:19:52 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
03:20:12 <NekoIncardine> Hrm...
03:20:15 <NekoIncardine> @src (!)
03:20:15 <lambdabot> arr@(Array l u _) ! i = unsafeAt arr (index (l,u) i)
03:21:11 <NekoIncardine> So that reads a single tile in the array.
03:21:49 * NekoIncardine now tries to figure out how to read each row...
03:22:28 <NekoIncardine> If the board is an Array, as in this case, and listArray means it can be manipulated as a List, how do I set it so I can do so?
03:23:24 <Cale> NekoIncardine: That's not what listArray means
03:23:41 <Cale> NekoIncardine: listArray is a function which constructs an array, given a pair of bounds, and a list.
03:23:42 <NekoIncardine> ... listArray lists the elements of a function in tuples.
03:23:47 <NekoIncardine> ... Ah.
03:23:49 <NekoIncardine> >_<
03:23:51 * NekoIncardine gets it now
03:24:25 <NekoIncardine> Man, I probably should just sleep on this, but I want to unbreak this one function before I sleep so I have some basics of arrayworking in my head to sleep on.
03:24:39 <Cale> You can use a list comprehension to do a bunch of extracting of indices.
03:24:43 <mauke> @hoogle Array i e -> [e]
03:24:44 <lambdabot> No matches, try a more general search
03:25:14 <Cale> @let myArray = listArray ((1,1),(9,9)) [1..]
03:25:15 <lambdabot> Defined.
03:25:32 <Cale> > [myArray ! (5,j) | j <- [1..9]]
03:25:33 <lambdabot>  [37,38,39,40,41,42,43,44,45]
03:25:39 <Cale> > [myArray ! (6,j) | j <- [1..9]]
03:25:40 <lambdabot>  [46,47,48,49,50,51,52,53,54]
03:25:46 <Cale> > [myArray ! (j,3) | j <- [1..9]]
03:25:46 <NekoIncardine> Hrm.
03:25:47 <lambdabot>  [3,12,21,30,39,48,57,66,75]
03:26:13 <Cale> > [myArray ! (i,j) | i <- [1..3], j <- [1..3]]
03:26:14 <lambdabot>  [1,2,3,10,11,12,19,20,21]
03:26:28 <NekoIncardine> Hrm.
03:26:28 <Cale> > [myArray ! (i,j) | i <- [4..6], j <- [1..3]]
03:26:29 <lambdabot>  [28,29,30,37,38,39,46,47,48]
03:26:53 <NekoIncardine> I see.
03:27:06 <NekoIncardine> So that command outputs the list... I think I have it now.
03:27:29 <Cale> You can also construct a new array from an old one and a list of changes:
03:28:18 <Cale> @let myNewArray = myArray // [((3,3),0), ((3,4),100)]
03:28:20 <lambdabot> Defined.
03:28:41 <Cale> > [myArray ! (i,j) | i <- [1..4], j <- [1..4]]
03:28:42 <lambdabot>  [1,2,3,4,10,11,12,13,19,20,21,22,28,29,30,31]
03:28:46 <NekoIncardine> {- printableBoard (Board x) = unlines ( takeWhile (not.null) ( map (take 9) ( iterate (drop 9) ( map tileToChar x ) ) ) ) -}
03:28:46 <Cale> > [myNewArray ! (i,j) | i <- [1..4], j <- [1..4]]
03:28:46 <lambdabot>  [1,2,3,4,10,11,12,13,19,20,0,100,28,29,30,31]
03:28:47 <NekoIncardine> printableBoard (Board x) = unlines ( takeWhile (not.null) ( map (take 9) ( iterate (drop 9) ( map tileToChar [x ! (i,j) | i <- [1..9], j <- [1..9]] ) ) ) )
03:29:00 <Heffalump> is darcs.haskell.org still badly overloaded?
03:29:03 <Cale> oh, for that you just use elems
03:29:07 <Cale> > elems myArray
03:29:08 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
03:29:38 <Cale> Heffalump: It appears to be working at least.
03:29:46 <Cale> > elems myNewArray
03:29:47 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,0,100,23,24,25,26,27,28,...
03:30:02 <Cale> @undefine
03:30:03 <lambdabot> Undefined.
03:30:05 <NekoIncardine> This is starting to make more sense.
03:31:10 <NekoIncardine> And I verified that makeBoard and printableBoard work (still), which is good.
03:32:06 <Heffalump> cale: yeah, just rather slowly
03:33:30 <NekoIncardine> Next, I come up with the three grouping commands (Row, Column, and Group).
03:36:54 <NekoIncardine> rowList :: Board Integer -> [Tile]
03:36:56 <NekoIncardine> rowList x y = [x ! (y,z) | z <- [1..9]]
03:38:16 <Bonus> hi guys i have a question!
03:38:35 <Bonus> i'm on Windows and I'm using GHCi 6.8.2 and it's like 25% of the functions are missing
03:38:53 <NekoIncardine> If I am thinking correctly the list that outputs there should be manipulable as a list (i.e. for a map function), which I can then put back into the Array by redefining it?
03:39:15 <Bonus> for instance if I type in :t nubs
03:39:19 <Bonus> it says it's not in scope
03:39:38 <Bonus> same with sort and group and groupBy
03:39:58 <Heffalump> :m +Data.List
03:40:01 <NekoIncardine> ... Hrm. I woudl not know. o_O
03:40:06 <Bonus> ooooh
03:40:06 <Heffalump> they're defined in a different module
03:40:15 <Bonus> i had a feeling that was the case!
03:40:17 <Bonus> thanks!
03:40:20 <Heffalump> it's nothing to do with being on Windows :-)
03:40:32 <Bonus> yeah i know i just thought i'd provide as much info as possible :D
03:40:59 <Heffalump> fair enough :-) It sounded from the way you worded it that you thought that was the reason.
03:41:38 <Bonus> hehe
03:41:42 <NekoIncardine> Hrm.
03:41:58 <Bonus> does anyone know how nub is implemented? i managed to make a function that removes duplicates from a list but it doesn't keep the ordering
03:42:41 <Heffalump> @src Data.List.nub
03:42:41 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
03:42:47 <Heffalump> @src nub
03:42:47 <lambdabot> nub = nubBy (==)
03:42:50 <Heffalump> @src nubBy
03:42:50 <lambdabot> nubBy eq []             =  []
03:42:50 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
03:42:54 <Bonus> ooh cool i didnt know you could do that
03:43:09 <NekoIncardine> That RowList method is invalid. Hrm.
03:43:10 <Heffalump> if you have an Ord constraint you can make it faster
03:43:26 <Heffalump> since that implementation is O(n^2)
03:44:13 <Bonus> rmDups :: (Eq a) => [a] -> [a]
03:44:13 <Bonus> rmDups (x:xs) = if x `notElem` xs then x:(rmDups xs) else rmDups(xs)
03:44:13 <Bonus> rmDups [] = []
03:44:30 <Bonus> this is what i have. like i said it doesnt keep the order but it works
03:44:32 <NekoIncardine> ... I need to sleep. I won't be able to get further at this rate. I'll try in the afternoon. x_x;
03:44:45 <Baughn> Bonus: @src very often does not show how things are implemented. It merely shows how they work.
03:44:54 <Bonus> aha
03:45:01 <Baughn> Bonus: The implementation can be faster. And harder to understand. For example.
03:45:03 <Bonus> well yeah thats what interests me
03:45:05 <Baughn> @src sortBy
03:45:05 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
03:45:15 <Baughn> ^-- GHC does not actually use insertion sort
03:45:15 <Bonus> @src nub
03:45:15 <lambdabot> nub = nubBy (==)
03:45:27 <NekoIncardine> good night, to all of you.
03:45:28 <opqdonut> Baughn: it doesn't?
03:45:41 <opqdonut> Baughn: but doesn't insertion sort work lazily on inifinite lists
03:46:06 <Baughn> opqdonut: Sure, and insertBy is right there if you need it. Me, I'll take a nice O(n lg n) sort function.
03:46:21 <opqdonut> it's some sort of mergesort then?
03:46:25 <Baughn> Yes
03:46:27 <opqdonut> (pun not intended)
03:46:31 <opqdonut> hmm okay
03:46:41 <opqdonut> so h98 doesn't place any restrictions on the sort
03:46:55 <Cale> No sort works well on infinite lists.
03:47:10 <Baughn> Some work less horribly
03:47:20 <Heffalump> how can you ever produce even the head?
03:47:34 <Heffalump> I suppose if you have a bucket sort you could.
03:47:46 <Heffalump> if you ever encountered the minimum element of the type
03:48:10 <Baughn> It's less "sort an infinite list" and more "insert element in infinite list in sorted order"
03:48:31 <Bonus> how are dicts usually implemented in haskell
03:48:34 <Bonus> as lists of tuples?
03:48:40 <Cale> Bonus: Data.Map
03:48:44 <Bonus> ooh
03:48:51 <Cale> Bonus: which internally uses balanced trees.
03:49:05 <Heffalump> insertBy could work, but how would any sort work?
03:49:19 <Baughn> Heffalump: No /sort/ could work. You have to adjust your expectations.
03:49:32 <Baughn> Bonus: Which has nice O(lg n) behaviour on just about every operation, even lazily/purely. Very nice library.
03:51:07 <Bonus> cool
03:51:51 <xpika> it would be cool if there was a haskell linux distro
03:51:58 <Baughn> xpika: What, ubuntu?
03:52:29 <Cale> Baughn: If only it kept the GHC up to date :)
03:53:03 <Baughn> Bonus: If you want to learn how to make data structures efficiently in haskell, you should read purely functional data structures, which is.. available online aat http://www.google.com/url?sa=t&ct=res&cd=1&url=http%3A%2F%2Fwww.cs.cmu.edu%2F~rwh%2Ftheses%2Fokasaki.pdf&ei=yln3R6fMJKOGwAHpuc0H&usg=AFQjCNGXKQqKJho73FE372EjGzUoeSJm1w&sig2=7Fzkwmkukxotmko_ME_pqw . Huh.
03:53:05 <lambdabot> http://tinyurl.com/5hkrtu
03:53:08 <xpika> Baughn: I was thinking of something more thorough.
03:54:37 <Cale> It would be cool if there were a Haskell operating system, oh right, there is one :)
03:55:29 <xpika> Cale: linux or house?
03:55:33 <Cale> House :)
03:55:46 <Cale> It would be more fun though to have an OS which was designed such that files were typed.
03:56:09 <Cale> (and could have any Haskell type)
03:56:39 <xpika> Cale: A haskell filesystem
03:56:41 <Baughn> Or we could just jump directly to orthogonal persistence
03:57:12 <Cale> xpika: yeah
03:57:33 <Cale> Executable programs could simply have type IO ()  :)
03:57:47 <xpika> Cale: wow
03:58:36 <xpika> Cale: a directory  [File a]?
03:59:20 <Cale> I'd probably make things a tree of files, and there could be content at any node, not just at the leaves.
03:59:54 <xpika> Cale: what about a sound file. would that just be a ByteString
04:00:38 <Cale> Possibly, but perhaps we'd end up defining more specific types for them as well.
04:00:44 <Baughn> xpika: No, a Sound a => a
04:00:49 <scook0> surely you'd at least have a wrapper over a bytestring
04:01:06 <Cale> Probably anything which came off the internet or somewhere that didn't have rich type information, would start life as a ByteString
04:02:57 <xpika> Cale: and /dev/dsp would  :: Sound a => a -> IO ()
04:03:27 <Heffalump> internet :: [ByteString] ?
04:04:13 <Cale> www :: String -> IO ByteString
04:04:34 <xpika> Heffalump: TCP :: Packet -> IO [Packet]
04:04:54 <Heffalump> does anyone have a snapshot of GHC HEAD from the last few days they could test something for me with?
04:13:57 <nominolo> Heffalump: i have from 2 weeks ago
04:17:54 <Heffalump> so do I :-)
04:18:09 <Heffalump> it's just that there haven't been any snapshots for my platform since then and the darcs repo is being very slow
04:19:40 <nominolo> well, i'm on osx.  what are you on?
04:29:37 <HunterXHunter> can haskell do strict evaluation?
04:30:33 <Jaak> yes
04:30:42 <HunterXHunter> how?
04:31:05 <Jaak> let f x = x `seq` 1 in f (length [1..])
04:31:07 <Baughn> HunterXHunter: Explicit annotations. Everything is lazy by default, of course
04:31:20 <HunterXHunter> ok
04:31:22 <Jaak> > let f x = x `seq` 1 in f (length [1..])
04:31:28 <lambdabot> Terminated
04:31:30 <Baughn> HunterXHunter: seq, $!, strict combinators like foldl'...
04:31:32 <Jaak> f is now strict
04:31:52 <Jaak> you can also use bang-patterns
04:32:08 <Jaak> http://hackage.haskell.org/trac/haskell-prime/wiki/BangPatterns
04:32:09 <lambdabot> Title: BangPatterns - Haskell Prime - Trac
04:34:18 <Baughn> HunterXHunter: http://haskell.org/haskellwiki/Performance <-- Here, read.
04:34:21 <lambdabot> Title: Performance - HaskellWiki
04:40:28 <HunterXHunter> "Use strict returns ( return $! ...) unless you absolutely need them lazy."
04:40:32 <HunterXHunter> is that it?
04:59:38 <desegnis> seq is the basic strictness annotation
05:01:52 <desegnis> ($!) is defined in terms of seq
05:04:43 <olsner> @src ($!)
05:04:43 <lambdabot> Source not found.
05:04:55 <olsner> lambdabot--
05:05:44 <Heffalump> @src $!
05:05:44 <lambdabot> Source not found.
05:06:18 <ttt--> @hoogle ($!)
05:06:19 <lambdabot> Did you mean: ($!)
05:06:19 <lambdabot> Prelude.undefined :: a
05:06:19 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
05:06:48 <desegnis> yeah, lambdabot is rather eclectic in its src information
05:07:03 <desegnis> @hoogle $!
05:07:03 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
05:07:18 <desegnis> (old hoogle bug)
05:07:41 <HunterXHunter> how do i get [10..1] count backward?
05:07:50 <HunterXHunter> eg. 10 9 8 ..
05:08:23 <Heffalump> > [10,9..1]
05:08:26 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
05:08:30 <HunterXHunter> oh
05:08:37 <HunterXHunter> why the comma?
05:08:46 <scook0> the difference between the first and second elements defines the step size
05:08:55 <desegnis> because 109 would be hundred and nine
05:09:16 <HunterXHunter> scook0: i see thanks
05:09:23 <desegnis> > enumFromThenTo 10 9 1
05:09:24 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
05:09:55 <desegnis> (This is what the .. syntax desugars to)
05:11:58 <Bonus> how can i curry foldl so that I get a function that's like foldl, only the starting value is always 1
05:12:21 <scook0> @type foldl
05:12:22 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
05:12:22 <Heffalump> (\f xs -> foldl f 1 xs)
05:12:29 <scook0> @type flip foldl 1
05:12:30 <lambdabot> forall a b. (Num a) => (a -> b -> a) -> [b] -> a
05:12:36 <Heffalump> or what scook0 said
05:12:42 <Bonus> aha
05:12:46 <paczesiowa> @pl (\f xs -> foldl f 1 xs)
05:12:46 <lambdabot> flip foldl 1
05:12:55 <Bonus> what does flip do exactly
05:13:01 <paczesiowa> @src flip
05:13:01 <lambdabot> flip f x y = f y x
05:13:05 <Bonus> aaah
05:13:10 <scook0> reverses the order of the first two parameters
05:13:39 <scook0> @type (`foldl` 1)
05:13:40 <lambdabot> forall a b. (Num a) => (a -> b -> a) -> [b] -> a
05:15:02 <ttt--> @type foldl 1
05:15:03 <lambdabot> forall a b. (Num (a -> b -> a)) => a -> [b] -> a
05:15:48 <paczesiowa> that type makes beginners think:>
05:16:07 <desegnis> Mm, funny to see that ($!) is the only base function in Prelude.hs that is not imported from GHC.*
05:17:10 <scook0> @type (. (1 :)) . foldl1 -- o_O
05:17:11 <lambdabot> forall a. (Num a) => (a -> a -> a) -> [a] -> a
05:17:19 <ttt--> what does (`x` 1) do to x?
05:17:39 <scook0> well, `` turns a function into an infix operator
05:18:01 <scook0> > let plus x y = x + y in 4 `plus` 5
05:18:02 <lambdabot>  9
05:18:18 <ttt--> isnt infix something between 2 things, like 1 + 1 ?
05:18:21 <Jedai> So (`x` 1) is a section, like (+ 1), it desugars to (\y -> x y 1)
05:18:32 <Bonus> 5 mod 2 returns 1
05:18:48 <scook0> so (`x` 1) ends up effectively being flip x 1
05:18:53 <Bonus> which can also be written as 5 `mod` 2
05:18:56 <scook0> i.e. \y -> x y 1
05:19:16 <scook0> Bonus: "5 mod 2" is illegal
05:19:19 <Jedai> Bonus: No, 5 mod 2 is a typing error, 5 `mod`  2 is correct though
05:19:23 <scook0> that would have to be mod 5 2
05:19:28 <scook0> or with the ``
05:20:02 <Bonus> oh yeah
05:20:03 <Bonus> i meant
05:20:06 <Bonus> mod 5 2
05:20:13 <Bonus> my bad :o)
05:20:24 <scook0> yeah, I figured that's what you meant
05:21:18 <ttt--> @type (`/` 3)
05:21:19 <lambdabot> parse error on input `/'
05:21:36 <ttt--> oh right
05:21:59 <Jedai> ttt--: / is already an infix operator, no need of ``
05:22:28 <Jedai> ttt--: But you can turn / in a normal function by putting it in parentheses : (/) 1 2 == 1 / 2
05:22:43 <ttt--> @type (`(/)` 3)
05:22:44 <lambdabot> parse error on input `('
05:22:50 <ttt--> :)
05:22:56 <scook0> ha, no, that doesn't work
05:22:57 <desegnis> I sometimes wonder why you need an opening ` and a closing ` even though you may put only one identifier in between
05:23:07 <scook0> desegnis: symmetry?
05:23:37 <scook0> especially since you're making a binary operator
05:23:44 <desegnis> scook0, you mean, aesthetics?
05:23:55 <scook0> yeah, more or less
05:24:01 <scook0> and readability too
05:24:14 <scook0> it's extremely unlikely that there's an actual technical reason
05:24:29 <Bonus> is there a way to define a function so it's infix by default?
05:24:48 <scook0> Bonus: give it a name that consists only of symbols
05:25:08 <Bonus> aha
05:25:12 <Bonus> what are the valid symbols?
05:25:13 <desegnis> scook0, the current syntax somehow suggests that you could write 0 `foldl (+)` [1,2,3]
05:25:15 <scook0> a name consisting of letters is always considered a prefix function, unless you use ``
05:25:38 <scook0> @where report
05:25:38 <lambdabot> http://www.haskell.org/onlinereport/
05:27:13 <scook0> ! # $ % & * + . / < = > ? @ \ ^ | - ~ :
05:27:24 <scook0> except that certain combinations are reserved
05:27:35 <scook0> and only constructors can begin with :
05:28:03 <Bonus> nice
05:28:11 <scook0> (oh, and also any unicode symbols, though I don't know exactly what class is used or whether GHC supports that)
05:29:02 <desegnis> unicode symbols are classified by being alphanumeric or not, so that should be the criterion used by ghc
05:29:08 <scook0> Bonus: have a look at the program on http://haskell.org/haskellwiki/Obfuscation
05:29:10 <lambdabot> Title: Obfuscation - HaskellWiki
05:29:38 <scook0> desegnis: yes, the report specifies "any Unicode symbol or punctuation"
05:30:13 <desegnis> hm... what about whitespace other than ASCII whitespace?
05:30:36 <scook0> desegnis: http://www.haskell.org/onlinereport/lexemes.html
05:30:38 <Bonus> lambdas can't be recursive, right?
05:30:41 <lambdabot> Title: Haskell 98 Lexical Structure
05:30:54 <scook0> Bonus: no
05:31:07 <scook0> either use a named function, or use fix to tie the knot yourself
05:31:22 <desegnis> ah, that should be UniWhite then
05:31:45 <ttt--> @users
05:31:46 <lambdabot> Maximum users seen in #haskell: 466, currently: 347 (74.5%), active: 7 (2.0%)
05:42:30 <HunterXHunter> > reverse [1..]
05:42:33 <lambdabot>  Terminated
05:55:42 <HunterXHunter> > let g = \f -> map f [-pi,-pi*(3/4)..] in g tan
05:55:42 <lambdabot>  [1.2246063538223773e-16,1.0000000000000002,-1.6331778728383844e16,-0.9999999...
05:55:50 <HunterXHunter> > let g = \f -> map f [-pi,-pi*(3/4)..] in g sin
05:55:51 <lambdabot>  [-1.2246063538223773e-16,-0.7071067811865476,-1.0,-0.7071067811865475,0.0,0....
06:14:40 <HunterXHunter> > halve [1..2]
06:14:40 <lambdabot>   Not in scope: `halve'
06:16:31 <HunterXHunter> > let halve l = (take (length l `div` 2) l, drop (length l `div` 2) l) in halve [1..]
06:16:33 <lambdabot>  Terminated
06:16:38 <HunterXHunter> > let halve l = (take (length l `div` 2) l, drop (length l `div` 2) l) in halve [1..10]
06:16:38 <lambdabot>  ([1,2,3,4,5],[6,7,8,9,10])
06:16:42 <HunterXHunter> > let halve l = (take (length l `div` 2) l, drop (length l `div` 2) l) in halve [1..9]
06:16:43 <lambdabot>  ([1,2,3,4],[5,6,7,8,9])
06:17:21 <ivanm> HunterXHunter: that'd be improved by only calculating the length div 2 bit once
06:17:32 <HunterXHunter> ivan: i will try
06:17:44 <Saizan> ?type splitat
06:17:44 <lambdabot> Not in scope: `splitat'
06:17:46 <Saizan> ?type splitAt
06:17:46 <lambdabot> forall a. Int -> [a] -> ([a], [a])
06:18:07 <HunterXHunter> > splitAt in [1..10]
06:18:07 <lambdabot>  Parse error at "in" (column 9)
06:18:09 <ivanm> or there's splitAt, as Saizan has pointed out :p
06:18:11 <HunterXHunter> > splitAt  [1..10]
06:18:12 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
06:18:26 <Saizan> > splitAt 5 [1..10]
06:18:27 <lambdabot>  ([1,2,3,4,5],[6,7,8,9,10])
06:18:40 <ivanm> > let halve l = splitAt (length l `div` 2) l in halve [1..10]
06:18:40 <lambdabot>  ([1,2,3,4,5],[6,7,8,9,10])
06:19:04 <byorgey> @src splitAt
06:19:05 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
06:19:24 <Saizan> that's a fake :)
06:19:27 <ivanm> *sigh* you'd think there'd be a single-pass way of doing that
06:19:33 <ivanm> Saizan: oh? how's it done then?
06:20:00 <Saizan> ivanm: singel pass with explicit recursion
06:20:12 <paczesiowa> is there a safe head (failing in some monad) in standard library?
06:20:37 <Saizan> ?type listToMaybe -- only this iirc
06:20:38 <lambdabot> forall a. [a] -> Maybe a
06:20:51 <ivanm> paczesiowa: wouldn't be hard to write one
06:21:14 <ivanm> > let mHead [] = Nothing, mHead (x:xs) = Just x in mHead []
06:21:14 <lambdabot>  Parse error at "," (column 23)
06:21:22 <ivanm> > let mHead [] = Nothing; mHead (x:xs) = Just x in mHead []
06:21:23 <lambdabot>  Nothing
06:21:50 <paczesiowa> ivanm: yeah, but if we love safety so much, why do we use unsafe head by default:>
06:21:57 <ivanm> oh, wait, that's just listToMaybe anyway :s
06:22:03 <ivanm> isn't that a rather stupid name though?
06:22:08 <Saizan> we don't use head much anyway :)
06:22:17 <ivanm> paczesiowa: that's haskell's sop to efficiency :p
06:22:25 <paczesiowa> ivanm: and fail would be nicer
06:22:25 <b_jonas> ivanm: I don't think it is
06:22:35 <Saizan> paczesiowa: however there's a package with things like that from ndm
06:22:36 <ivanm> Saizan: and we don't use our heads either? :p
06:22:48 <ivanm> b_jonas: hence the ":p" at the end of my message ;-)
06:23:08 <paczesiowa> sop? ndm?
06:23:09 <b_jonas> ivanm: no, I mean I think listToMaybe is not a stupid name
06:23:15 <ivanm> ahhh
06:23:54 <ivanm> b_jonas: I would have though listToMaybe would have been something like [a] -> Maybe [a] or something.... name doesn't indicate that it does a safe head operation
06:24:34 <Heffalump> SQL doesn't have any way of representing nesting, does it?
06:25:00 <b_jonas> ivanm: if you think of the list as how you use it as a monad for nondeterministic results
06:25:11 <b_jonas> then I think the name makes sense
06:25:32 <ivanm> b_jonas: maybe
06:26:35 <paczesiowa> ivanm: maybe doesn't make sense either:>
06:26:43 <paczesiowa> :t maybe
06:26:44 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
06:26:45 <Saizan> what should [a] -> Maybe [a] do?
06:26:52 <paczesiowa> :t either
06:26:53 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
06:27:52 <ivanm> Saizan: nothing much :p
06:29:49 <b_jonas> the problem with the names "maybe" and "either" is only that they're using a different convention than the build functions like "array" (and lisp's "list" and "vector")
06:30:17 <b_jonas> but I still think they're good names
06:30:19 <Peaker_> Hey, I am trying to read about CoMonads, and they all say that they are the "dual" of Monads. What does "dual" mean here?
06:30:37 <Volatile> O_o... Monad tensors?
06:30:40 <byorgey> "dual" in the category-theory sense.
06:30:49 <byorgey> i.e. you reverse all the arrows.
06:30:54 <Saizan> Peaker_: you reverse all the arrows in the category diagrams
06:31:04 <Peaker_> oh, thanks
06:31:06 <byorgey> so with Monad you have  return :: a -> m a,  with CoMonad you have coreturn :: m a -> a
06:31:08 <Peaker_> I don't know any category theory
06:31:17 <b_jonas> isn't that called "co-"?
06:31:23 <b_jonas> oh, it is
06:31:24 <Peaker_> That's concrete enough though
06:31:29 <b_jonas> that's why it's "co-"monad
06:31:32 <Peaker_> thanks
06:32:14 <TomMD> byorgey: didn't you recently visit Penn?
06:32:24 <Volatile> Hm, is it bad of me to reimplement the ?: operator in Haskell and then start using it in my programs? :)
06:32:41 <b_jonas> Volatile: no, someone actually coded it
06:32:41 <byorgey> TomMD: yes, and in fact, I'll be starting a PhD at Penn in the fall.
06:32:53 <b_jonas> it's tricky if you want it to have infix syntax though, but it can be done
06:33:01 * Volatile has done it
06:33:03 <b_jonas> it's trivial if you want it to be a prefix
06:33:15 <b_jonas> Volatile: really? does it work if you chain it?
06:33:20 <TomMD> You will for sure?  That is good news.  I had it somewhere in my head that you weren't 100% sure, only a worthless 99%.
06:33:21 <Peaker_> where are comonads used?
06:33:22 <Volatile> Hmm
06:33:28 <Volatile> b_jonas; I'll try
06:33:37 <b_jonas> @pl \x y z -> if x then y else z
06:33:37 <lambdabot> if'
06:33:38 <Saizan> let (?) a b c = if a then b else c in (True ? 1 $ 2, False ? 1 $ 2)
06:33:41 <Saizan> > let (?) a b c = if a then b else c in (True ? 1 $ 2, False ? 1 $ 2)
06:33:52 <syntaxfree> I need/want to get back to speed with Haskell.
06:33:52 <byorgey> TomMD: hehe, nope =)
06:33:54 <TomMD> byorgey; Under which prof?
06:33:56 <lambdabot>  thread killed
06:33:59 <resiak> > let (p ? t) f = if p then t else f; (!) = id in True ? 3 ! 5
06:34:00 <lambdabot>  3
06:34:03 <syntaxfree> I dropped programming for almost a year.
06:34:04 <resiak> > let (p ? t) f = if p then t else f; (!) = id in False ? 3 ! 5
06:34:04 <lambdabot>  5
06:34:06 <b_jonas> Saizan: yep, it works that way
06:34:23 <b_jonas> for some reason I wanted to write it like this:
06:34:26 <syntaxfree> But the standard tutorials won't help me because I already know all that stuff.
06:34:29 <Volatile> Well, if you code it using if then else, it gets hard, I guess
06:34:33 <byorgey> TomMD: well, I'll be working with the PL group (Pierce, Weirich, and Zdancewic), but not sure exactly which prof I'll be working with yet
06:34:36 * Volatile just used a Maybe monad
06:34:45 <byorgey> TomMD: at Penn you don't have to choose until the end of the first year
06:34:47 <resiak> hrm, what are the implicit fixity declarations there ^^ ?
06:34:49 <syntaxfree> It seems Haskell has also has advanced a lot in the last year.
06:34:55 <b_jonas> uh, whatever
06:35:11 <b_jonas> I wanted the : part to have a higher precedence than the ?
06:35:16 <b_jonas> and it can't work chained that way
06:35:16 <byorgey> syntaxfree: it has?
06:35:22 <syntaxfree> I'm teaching myself logic through Konyndyk, but that doesn't really help with getting to the next level.
06:35:48 <syntaxfree> for one, Control.Applicative
06:36:28 <Volatile> b_jonas; why would you want that?
06:36:39 <b_jonas> Volatile: it's easy to define it that way
06:36:41 <syntaxfree> I was getting comfortable with monads, and now I, uh, know how to write basic textbook stuff but can't figure out to take myself to the next level, sp. since I haven't programmed at all for a year.
06:36:50 <Saizan> syntaxfree: every Monad is an applicative with pure = return, (<*>) = ap :)
06:36:51 <TomMD> byorgey: It sure has advanced.  For starters, I use it now.
06:37:05 <TomMD> ;-)
06:37:11 <syntaxfree> Saizan: yes, I knew Applicative was a generalization of monads.
06:37:16 <byorgey> hehe
06:37:26 <nominolo> syntaxfree: did you read the applicative paper?
06:37:32 <syntaxfree> I also like that there's a cleaner generalization of monads. Arrows always seemed iffy to me.
06:37:43 <syntaxfree> nominolo: maybe that would help.
06:37:59 <nominolo> syntaxfree: i think the first part is a very good read
06:38:00 <b_jonas> > let { infix 0 ?; True ? x = fst x; False ? x = snd x; infix 1 %; x % y = (x, y); } in True ? 3 % 5
06:38:01 <lambdabot>  3
06:38:11 <b_jonas> > let { infix 0 ?; True ? x = fst x; False ? x = snd x; infix 1 %; x % y = (x, y); } in False ? 3 % 5
06:38:11 <lambdabot>  5
06:38:23 <nominolo> syntaxfree: after that it get's to the category theory stuff
06:38:26 <syntaxfree> My brain is kind of fuzzed out because I took Ritalin yesterday, but I think I can still parse stuff.
06:38:33 <nominolo> that's not needed for using it
06:38:46 <syntaxfree> nominolo: I actually can grok some of the cat theory stuff, at least from the first Bananas paper.
06:39:08 <nominolo> syntaxfree: good, but you don't need it to understand Applicative ;)
06:39:09 <syntaxfree> I never liked Arrows. I'm glad applicatives exist now.
06:39:37 <nominolo> arrows are more constrained than monads
06:39:49 <syntaxfree> nominolo: I seem to have some difficulty taking my theoretical knowledge to write code beyond toy stuff.
06:40:07 <nominolo> read the first pages of the paper
06:40:12 <syntaxfree> who is the author of the applicatives paper?
06:40:13 <nominolo> it gives you all you need to know
06:40:21 <nominolo> conor and ross?
06:40:25 <syntaxfree> (so I can actually google it)
06:40:38 <nominolo> http://www.soi.city.ac.uk/~ross/papers/Applicative.html
06:40:39 <lambdabot> Title: Applicative Programming with Effects
06:41:22 <syntaxfree> isn't Ross Patterson a #haskell dweller?
06:41:35 <syntaxfree> or a mailing list dweller anyway.
06:41:57 <nominolo> both are active on @cafe
06:42:12 <nominolo> but read the paper, it's a functional pearl (-> readable)
06:42:37 <syntaxfree> sure.
06:42:40 <nominolo> ok, it's only one section on category stuff
06:43:31 <syntaxfree> about the second question -- getting from toy problems to understanding common existing Haskell code and being able to change/contribute/hack it, any suggestions?
06:43:36 <HunterXHunter> how do i pass in a tuple to this function? let magnitude (x y z)  = sqrt (x*x+y*y+z*z)
06:43:43 <syntaxfree> or is it just "like riding a bike" thing?
06:44:08 <syntaxfree> HunterXHunter a tuple is actually (x,y,z)
06:44:17 <b_jonas> "like riding a bike" -- you don't know how to stop at first?
06:44:31 <HunterXHunter> oh
06:44:41 <nominolo> syntaxfree: yeah, just start hacking
06:44:46 <Volatile> > let { infixl 3 ?; infixl 3 !; True ? x = Just x; False ? x = Nothing; Just x ! _ = x; Nothing ! x = x;} in 1==1?2!3 -- just to show my approach
06:44:46 <lambdabot>  2
06:44:48 <syntaxfree> b_jonas: heh. I actually can't ride a bike, but I'm learning longboard skateboarding by myself.
06:44:51 <b_jonas> at least when I learnt to ride a bike I couldn't get off without falling
06:45:05 <Saizan> syntaxfree: you must start and learn while trying imo, better if you hack on a project with a nice devel team that can guide you a little
06:45:10 <syntaxfree> nominolo: that's what I was doing in 2006, but I both never got past toy problems and lost my gf.
06:45:20 <syntaxfree> :P
06:45:31 <nominolo> are those related?
06:45:45 <syntaxfree> Not in a deep way.
06:45:57 <syntaxfree> I did spend time hacking I regret having spent so.
06:46:18 <syntaxfree> while she tried to coo me into bed. But don't remind me I haven't had more than short flings since then.
06:46:44 <syntaxfree> none of which led to actual intimacy or being really loved as I was back then.
06:46:48 <nominolo> also, note that this is a logged channel
06:46:52 <syntaxfree> but I digress.
06:47:07 <clanehin> eh, save your hacking session for *after*, you can concentrate better then anyway.
06:47:18 <nominolo> or go jogging
06:47:21 <syntaxfree> clanehin: useless advice right now.
06:47:36 <nominolo> or other sport
06:47:42 <syntaxfree> it's been a year now, and I'm in psychiatric treatment for bipolar disorder.
06:47:42 <nominolo> clears your head, too
06:47:48 <syntaxfree> I also skateboard, as I said.
06:48:51 <syntaxfree> I actually have a bottle of the magic concentration pill but I took (half of) one yesterday because I had an impossible work deadline, and I don't wanna get used to it.
06:49:09 <syntaxfree> s/used/addicted/
06:49:29 <syntaxfree> anyway, my head is ok, and I'm not depressed over the girlfriend or anything.
06:49:36 <MarkVera> I'm considering Haskell as sort of scripting/plugin language for a audio application. However I wouldn't mind if you guys would help me out clarify few things what's possible and what are the problems.
06:49:47 <HunterXHunter> how do i do something like this: let magnitude v = (x,y,z) = v = sqrt (x*x+y*y+z*z) ?
06:50:16 <syntaxfree> I've been doing therapy forever. I was asking a how-to-learn-programming question.
06:50:32 <syntaxfree> is HunterXHunter a trollbot?
06:50:33 <yondalf> > let magnitude (x,y,z) = sqrt (x*x+y*y+z*z) in magnitude (2,3,4)
06:50:34 <lambdabot>  5.385164807134504
06:51:05 <TomMD> Perhaps - hey you troll bot, tell us you aren't a troll.
06:51:19 <HunterXHunter> syntaxfree: no I'm new to haskell, only started 3 days ago
06:51:32 <syntaxfree> > let magnitude [] = 0; let magnitude (c:cs) = c*c + magnitude cs
06:51:32 <lambdabot>  Parse error at "let" (column 23)
06:51:42 <yondalf> HunterXHunter: see my code above
06:51:54 <clanehin> MarkVera: you might consider scheme for that, haskell has a steep learning curve for someone who might just want to do a one-off plugin, unless the audio application itself is in haskell.
06:52:01 <HunterXHunter> yes but your code does not work when i pass in a single variable
06:52:11 <syntaxfree> > let magnitude [] = 0;  magnitude (c:cs) = c*c + magnitude cs in magnitude [2,3,4,7]
06:52:12 <lambdabot>  78
06:52:19 <yondalf> HunterXHunter: example code?
06:52:24 <nominolo> > let magnitude (x, y, z) = sqrt (x*x + y*y + z*z) in magnitude (1,3,4)
06:52:24 <lambdabot>  5.0990195135927845
06:52:41 <yondalf> single variable as in a sole number, not a tuple?
06:52:44 <HunterXHunter> yondalf: v = (1,2,3) ... magnitude v does not work
06:52:52 <nominolo> > let magnitude  x y z = sqrt (x*x + y*y + z*z) in magnitude  1 3 4
06:52:52 <lambdabot>  5.0990195135927845
06:52:53 <yondalf> it does
06:52:59 <HunterXHunter> no it doesn't
06:53:01 <MarkVera> clanehin, ok. have to check what scheme holds. Originally I was thinking about using Python.
06:53:14 <syntaxfree> > let magnitude = sum . map (^2)  in magnitude [1,2,3,4]
06:53:15 <lambdabot>  30
06:53:30 <yondalf> > let magnitude (x,y,z) = sqrt (x*x+y*y+z*z); v = (2,3,4) in magnitude v
06:53:31 <lambdabot>  5.385164807134504
06:53:31 <syntaxfree> there's gotta be a way to do that in a single fold.
06:53:55 <yondalf> > let magnitude = sqrt . sum . map (^2) in magnitude [1,2,3,4]
06:53:56 <lambdabot>  5.477225575051661
06:53:58 <MarkVera> clanehin, however functional language would fit more than better for what the scripting/plugin are supposed to do.
06:54:07 <syntaxfree> ah, sqrt is important, yes.
06:54:08 <nominolo> syntaxfree: sum . map is optimised to a single fold
06:54:23 <desegnis> Since the K and I combinators have Prelude names (const, id), is there another name for the S combinator that suggests (We have ap, but it is too general)
06:54:24 <HunterXHunter> yondalf: strange I'm getting error in GHCi
06:54:31 <syntaxfree> nominolo: yes, I'm trying to figure out how  to do it explicitly and please don't tell me.
06:54:34 <yondalf> post on hpaste.org?
06:54:35 <syntaxfree> I'm flexing my muscls.
06:54:39 <desegnis> s/suggests/suggests itself?/
06:55:27 <hpaste>  hunter pasted "strange error" at http://hpaste.org/6839
06:55:55 <MarkVera> clanehin, ah yes. scheme was that "parenthesis hell" language. I'm not really too keen about that.
06:56:16 <syntaxfree> > let mag = foldr1 ((+) . (^2)) in mag [1,2,3]
06:56:16 <lambdabot>  8
06:56:23 <HunterXHunter> yondalf: what am I doing wrong?
06:56:24 <syntaxfree> oh yeah baby.
06:56:38 <syntaxfree> MarkVera: Lua is popular as a scripting language, and is Lispy.
06:56:51 <b_jonas> MarkVera: what about lua? it's easy to embed because it has a well-documented C api
06:56:52 <syntaxfree> scripting/extension language.
06:56:55 <yondalf> HunterXHunter: ah i see
06:56:59 <b_jonas> (though mzscheme also has a well-documented C api)
06:57:02 <yondalf> um wait
06:57:03 <MarkVera> syntaxfree, lua was one I considered too. However as language it's not very interesting.
06:57:09 <syntaxfree> b_jonas: GMTA.
06:57:28 <yondalf> :t \(x,y,z) = sqrt(x*x+y*y+z*z)
06:57:29 <lambdabot> parse error on input `='
06:57:32 <syntaxfree> MarkVera: well, what's not interesting about it?
06:57:38 <yondalf> :t \(x,y,z) -> sqrt(x*x+y*y+z*z)
06:57:39 <lambdabot> forall t. (Floating t) => (t, t, t) -> t
06:57:47 <b_jonas> MarkVera: but you want a scripting langauge for an app, not an interesting one, don't you?
06:58:12 <yondalf> HunterXHunter: you got tripped up with type classes :-P magnitude expects the tuple to contain floating-point numbers, but yours only has integers
06:58:18 <yondalf> :t toFloat
06:58:18 <lambdabot> Not in scope: `toFloat'
06:58:26 <clanehin> MarkVera: I believe guile is specifically designed to be a plugin language.  If you need purely functional, I imagine there's something you can customize to get close to what you want.  Other than that, it's your choice.
06:58:32 <syntaxfree> @free foldr . map
06:58:33 <lambdabot> Extra stuff at end of line
06:58:34 <yondalf> um...irc channel, how do you convert an arbitary number to floating-point?
06:58:39 <syntaxfree> @free foldr1
06:58:40 <lambdabot> (forall x. f . g x = h (f x) . f) => f . foldr1 g = foldr1 h . $map f
06:58:49 <clanehin> MarkVera: sorry, guile is an implementation of scheme, not a separate language.
06:58:54 <nominolo> MarkVera: pff, dismissing scheme for superficial syntax, go away
06:58:55 <yondalf> HunterXHunter: you'll have to convert the number to a floating point, for instance, by writing 1.0 instead of 1
06:58:56 <HunterXHunter> yondalf: yes I understand now, change it v = (1.0,2.0,3.0) and made it work
06:59:08 <MarkVera> nominolo ;)
06:59:19 <b_jonas> how the f could that have helped?
06:59:24 <the_ez> @:t fromIntegral
06:59:25 <lambdabot>  There was an error in the type: (line 1, column 17):
06:59:25 <lambdabot>  unexpected type constructor 'Num' (this type constructor is not declared)
06:59:26 <b_jonas> 1 is a floating-point number too
06:59:33 <the_ez> :t fromIntegral
06:59:34 <lambdabot> forall a b. (Num b, Integral a) => a -> b
06:59:48 <syntaxfree> MarkVera: hey, what's your beef with Lua again?
07:00:17 <nominolo> MarkVera: it really depends on who's going to use it
07:00:21 <MarkVera> clanehin, ok. the scripting part is at first mostly for describing event/midi processing and transformation. also describe midi device sysex implementations.
07:01:33 <syntaxfree> you could use *repressed laughter* Arc.
07:02:30 <the_ez> @HunterXHunter:   v = (1,2,3) :: (Double,Double,Double) should work, or even v = (1::Double,2,3) perhaps
07:02:30 <clanehin> MarkVera: I know what some of those words mean.  Do you have specific questions about using haskell as a plugin language?
07:02:30 <lambdabot> Unknown command, try @list
07:04:05 <MarkVera> clanehin, well, mostly that if there are known problems using it for Windows 32-bit/64-bit and MacOSX. I suppose the native compiler would be easier to integrate to an application so it would be standalone (ie. compile "scripts" on application startup).
07:04:34 <yondalf> HunterXHunter: to do the_ez's suggestion you'll have to activate inline type annotations...it's a ghc extension
07:04:35 <MarkVera>  for MacOSX intel platform is fine.
07:05:12 * SamB doesn't like programs that embed languages, as a rule, and really doesn't think he likes languages that let such programs choose such things as whether the main numeric type will be integral or double or what...
07:05:47 * SamB greatly prefers libraries
07:06:44 <SamB> I think Emacs is an exception, because it is the only program that embeds emacs lisp
07:08:32 <MarkVera> clanehin, also one requirement for the system is realtime execution, such as the application feeds event data for the script to transform and it will then return new set of data.
07:11:38 <HunterXHunter> @src null
07:11:38 <lambdabot> null []     = True
07:11:39 <lambdabot> null (_:_)  = False
07:12:11 <SamB> MarkVera: realtime?
07:12:23 <clanehin> MarkVera: how many users do you have for this application?
07:12:57 * SamB tries to figure out if MarkVera means hard realtime, soft realtime, or just tolerably responsive
07:13:44 <MarkVera> clanehin, it's commercial application with fine userbase. I don't expect everybody to use the scripting part. Partly for ourselves and for the keen users.
07:13:46 <Lycurgus> commonly called "near-realtime". Never heard hard and soft before.
07:16:27 <Peaker_> hard realtime, iirc, just means that a correct result is worthless beyond some given time.. soft real time means it loses value, but more moderately
07:16:36 <MarkVera> SamB, in this case it means that the program feeds the events, the script needs to process them quickly. This is repeated like callback to get realtime feedback.
07:17:02 <MarkVera> Such as if user presses key from midikeyboard, then events are given for the script to transform, and given back for the application to output ie. sound.
07:18:16 <SamB> hmm, that sounds like "tolerably responsive"
07:18:35 <Lycurgus> Acknowledged. My experience of the terminology is based on work in satellite comm. that's quite old now.
07:19:33 <MarkVera> not sure how to explain "realtime" here. Say it's stream of data instead ie. of fixed data file
07:20:09 <HunterXHunter> what is the use of : operator ?
07:20:15 <Lycurgus> a permissive definiton would be within the latency of the channel from the event
07:20:30 <Lycurgus> a strick one would use plancks constant
07:20:54 <MarkVera> and it's usually sliced/buffered so that there's sort of latency, and in audio terms realtime usually means less than 40ms. Preferable near 10ms.
07:21:26 <Lycurgus> *strict
07:23:02 <yondalf> HunterXHunter: it's called "cons", appends an element to the front of a list, you can use it to construct lists etc.
07:23:02 <Lycurgus> *definition
07:23:04 <yondalf> > 1 : [2,3,4]
07:23:14 <lambdabot>  [1,2,3,4]
07:23:21 <HunterXHunter> i thought so ;)
07:23:23 <yondalf> > 1 : 2 : 3 : 4 : []
07:23:24 <lambdabot>  [1,2,3,4]
07:23:35 <TomMD> > [] : [] : []
07:23:36 <lambdabot>  [[],[]]
07:23:40 <yondalf> > 1 : (2 : []) -- : is right-associative
07:23:41 <lambdabot>  [1,2]
07:24:10 <HunterXHunter> > 1 : 2 : 3 : [] : 5
07:24:10 <lambdabot>   add an instance declaration for (Num [[a]], Num [a])
07:24:14 <yondalf> ah TomMD i think you're confusing hunter :-)
07:24:36 <TomMD> :-) Hunter, just ignore me, I thrive on confusion (though it is typically my own).
07:24:38 <HunterXHunter> > 1 : 2 : 3 : [] : 5 : []
07:24:39 <lambdabot>   add an instance declaration for (Num [a])
07:24:47 <yondalf> :t (:)
07:24:48 <lambdabot> forall a. a -> [a] -> [a]
07:25:04 <byorgey> HunterXHunter: that won't work because all the elements of a list must be the same type.  1,2,3,5 are not the same type as [].
07:25:24 <HunterXHunter> yes i know :)
07:25:27 <HunterXHunter> i was only testing
07:25:28 <TomMD> > 1 : 2 : 3 : [] : [5] : []
07:25:28 <lambdabot>   add an instance declaration for (Num [a])
07:25:42 <Jaak> > []:[]:[]
07:25:43 <lambdabot>  [[],[]]
07:25:44 <TomMD> oops, well, You can make it a list of lists and that is always fun
07:25:57 <yondalf> or use the Maybe or Either types
07:25:58 <Jaak> oh, should have read ^
07:26:12 <yondalf> > [Left 1, Right "hahaha", Left 100]
07:26:12 <lambdabot>  [Left 1,Right "hahaha",Left 100]
07:26:16 <Saizan> > (1 : 2 : 3 : []) : [5] : []
07:26:17 <lambdabot>  [[1,2,3],[5]]
07:26:36 <vincenz> ([]:[]):([]:[])
07:26:36 <yondalf> okay time for me to go
07:26:42 <vincenz> > ([]:[]):([]:[])
07:26:43 <lambdabot>  [[[]],[]]
07:26:52 <clanehin> MarkVera: ask your users what language they'd like to use.  If they say haskell, I'll be impressed.
07:27:37 <Lycurgus> me too.
07:28:19 <TomMD> The easiest fix for that would be to get a new user base.  The next easiest would be to use something besides Haskell for your project.
07:28:32 <Saizan> well, ask it to the users of xmonad :)
07:29:50 <MarkVera> clanehin, well not really question to ask. I rather go for what is practical. Most of our audio processing algorithms are originally written in matlab or as mathematical expressions. It's not too far step for haskell imho. Right now those are then translated to c++.
07:31:10 <HunterXHunter> whats the difference between \x -> (\y -> x+y) and \x y -> x+y ? which style is prefered?
07:31:24 <TomMD> One is uglier.
07:31:38 <atp> no difference
07:31:54 <HunterXHunter> so the latter is preferred?
07:32:07 <ivanm> HunterXHunter: depends on if you like ugliness :p
07:32:24 <HunterXHunter> ivan: certainly don't :P
07:32:42 <desegnis> HunterXHunter, the second is derived from the first
07:32:43 <atp> there may be times when the former is easier for you to follow
07:33:07 <atp> in which case it may behoove you for clarity to use that one, but in most cases we all use the latter form
07:33:17 <HunterXHunter> ok
07:33:56 <atp> also note that the parentheses are extraneous, because -> always scopes as far as possible.  \x -> \y -> x + y
07:33:58 <desegnis> Yet another random question: Is there a GHC extension that allows type signatures in instance declarations?
07:35:12 <Beelsebob> I'd use the latter where I want to emphasise that this is just a 2 argument function
07:35:14 <clanehin> MarkVera: I've said what I think, and if you don't care what your users think, then I don't know how my opinion could possibly matter.  It's entirely your prerogative.
07:35:25 <sieni> HunterXHunter: there is a reason why \x y -> foo is a shorthand for \x -> \y -> foo
07:35:33 <Beelsebob> and the former where I want to emphasise that it's a one argument function that happens to return another function
07:35:37 <Beelsebob> (a continuation for example)
07:36:08 <MarkVera> clanehin, thing is, that most users most likely have not even programmed single line of code.
07:37:33 <atp> y
07:38:10 <MarkVera> clanehin, anyhow. one of my questions was more of technical. Is haskell available as 64-bit for Windows?
07:38:31 <MarkVera> I tried to search about that, but it's wasn't that clear.
07:39:37 <atp> ghc just compiles down to C, and then uses gcc to produce the actual machine code, so i would imagine whether or not ghc works on 64bit win hinges on whether gcc does or not
07:39:51 <atp> but i don't have any idea further than that
07:40:10 <MarkVera> Does ghc native compiler use gcc?
07:40:18 <MarkVera> i got impression it's separate
07:40:20 <atp> yeah, afaik
07:40:33 <atp> if you install ghc on windows it comes with the mingw compiler
07:40:57 <atp> the c is nothing resembling readable portable C though
07:41:14 <desegnis> compiling via C is merely an option
07:41:33 <atp> the other backends (C-- and such) are less mature i thought
07:41:40 <MarkVera> I would need more of "standalone" compiler which could be easily shipped as part of application.
07:41:56 <Saizan> atp: the default is not to use gcc since 6.8
07:42:22 <atp> Saizan: oh?  i did not know that.  do we generate machine code directly then, or do we use C--, or what?
07:42:27 <b_jonas> I heared they used to be less mature but they've improved these days
07:43:12 <Saizan> atp: ghc always generates C--, but it can either compile it down to machine code, or convert it to C and pass it to gcc
07:43:22 <Saizan> the former is the default now
07:43:43 <atp> ah!  neat
07:43:55 <atp> that's good news
07:44:17 <ulfdoz> Is it because ghc can optimize better than gcc or less buggier? ;)
07:44:21 <Saizan> yeah the machine code generator is still suboptimal but wrt speed is on par with what you get passing via C
07:44:46 <Jedai> On x86 platform at least, on other architectures, --via-c is still the default
07:44:48 <atp> Saizan: that's to be expected at this juncture, but there's a lot more room for improvement now... we're not capped by the deficiencies of c
07:45:00 <sieni> ulfdoz: I think that C is a bad target for functional programming languages
07:45:15 <Saizan> ulfdoz: C-- has more lowlevel information then C, and i guess something is lost in translation, in fact ghc mangles the asm generated by gcc later
07:45:36 <atp> Jedai: good point... so would 64-bit x86 on windows count as 'x86'?
07:46:03 <sieni> ulfdoz: http://hackage.haskell.org/trac/ghc/wiki/Commentary/EvilMangler
07:46:04 <MarkVera> atp, that was a bit unclear to me atleast if it would count the same.
07:46:05 <lambdabot> Title: Commentary/EvilMangler - GHC - Trac
07:49:10 <pejo> MarkVera, there's a bug about 64 bit windows support somewhere in trac, or you can search ghc-users mailing list for comments about it.
07:49:21 <pejo> Hm, not bug, I mean ticket.
08:01:52 <Peaker_> xchat on Windows reverses all the > queries to lambdabot so for a while there I thought you could give reversed queries to lambdabot :)
08:02:12 <Peaker_> as in:   [] : 2 : 1 <
08:03:05 <olsner> why does your xchat do that?
08:03:17 <Peaker_> I guess its because Windows here is configured for right-to-left (Hebrew)
08:03:38 <Peaker_> and it tends to mess up text in a whole variety of programs
08:03:55 <b_jonas> Peaker_: hmm
08:04:02 <olsner> oh right, many programs don't handle bidirectionality correctly
08:06:48 <SamB> most, in fact ;-)
08:09:43 <Peaker_> Its quite horrible, Windows that's set up for right-to-left has half of the programs mirrored on the horizontal axis, including the minize/maximize/close buttons on the frame
08:12:00 <Volatile> haha, neat
08:13:07 <Peaker_> And us Hebrew keyboard users cannot even use keyboard shortcuts, because when they keyboard layout is not English, all the keyboard shortcuts cease to work
08:13:15 <Peaker_> Its a sad state of affairs..
08:13:43 <Peaker_> I think only the Mac has the heyboard shortcuts working in the different keyboard layouts
08:13:48 <b_jonas> is it not possible to set up the keybaord layout so control plus something would map to control plus the english letter?
08:13:49 <Volatile> Peaker_; and all this brings us to the question "Why are you still using Windows?"
08:13:50 <b_jonas> for shortcuts
08:13:59 <b_jonas> provided you don't use control plus hebrew character at all
08:14:06 <Peaker_> Volatile, I'm at my parents' home right now, its their machine
08:14:11 <Volatile> ah
08:14:19 <Volatile> not much to do, then, I guess...
08:14:23 <Peaker_> Volatile, but they keyboard shortcuts break in all Linux's too ...
08:14:27 <allbery_b> x11 isn't enormously better in that area
08:14:29 <Peaker_> Volatile, all distributions, that is
08:14:55 <Volatile> oh? Why is that? It seems like it would be a piece of cake to build an xmodmap file for it...
08:15:04 <Peaker_> b_jonas, Maybe that's possible, but the solution would be to have keyboard shortcuts but key shortcuts rather than symbol shortcuts
08:15:15 <Peaker_> s/but/be
08:15:35 <allbery_b> the problem is keyboard shortcuts are defined as modifier+Latin key
08:15:52 <Peaker_> It should be modifier+scancode
08:15:54 <allbery_b> if the key is returning 'he' instead of 'v' then ctrl-v doesn't exist
08:16:10 <Volatile> ah
08:16:11 <Volatile> hm
08:16:24 <radix> Peaker: that's interesting, I thought Windows _does_ allow you to use "english" keyboard shortcuts. Anyway, I know Mac and Linux (Gnome) do
08:16:33 <Peaker_> For 4 or 5 of the major shortcuts (including Ctrl-x, ctrl-c, ctrl-v), they just mapped the Hebrew ones too (Ctrl-? ? ?)
08:16:44 <b_jonas> Peaker_: I don't think so, because then what would you do with a non-standard keyboard
08:16:49 <Peaker_> radix, How?
08:16:51 <b_jonas> so that wouldn't work either
08:17:03 <Peaker_> b_jonas, I'd remap the scancodes to whatever keys I have
08:17:07 <radix> Peaker: How what? Does Windows allow you to do it? I don't know, it's just hearsay.
08:17:15 <Peaker_> b_jonas, how does a non-standard keyboard get the english letters translated correctly?
08:17:27 <b_jonas> Peaker_: with a normal keymap?
08:17:29 <Peaker_> radix, No, only Macs have shortcuts working in Non-English mode :-(
08:17:36 <b_jonas> e.g. suppose I wanted to use dvorak
08:17:55 <allbery_b> dvorak+non-latin1 mappings doesn't mix
08:18:00 <Peaker_> b_jonas, If I switch to Dvorak, my muscle memory for shortcuts would probably still be qwerty :-)
08:18:02 <radix> Peaker: Maybe I'm only thinking of a latin keyboard that has a software-mapped mode enabled
08:18:04 <b_jonas> allbery_b: yes, I know
08:18:17 <b_jonas> that's why I don't use dvorak
08:18:26 <radix> The Gnome behavior is really horrible for users of multiple latin layouts
08:18:43 <Peaker_> I'm all for configurable shortcut keys, but they should be associated with a key somehow (and using its latin translation is an ok way to do that), and not with a symbol
08:18:53 <b_jonas> Peaker_: if I switched to dvorak or something, I rewrote all the shortcuts of the editor to completely different
08:19:04 <b_jonas> so that I do the two at once and not separately
08:19:10 <b_jonas> it's difficult to change either
08:19:24 <Peaker_> b_jonas, Why not keep the Qwerty shortcuts with the Dvorak layout? (e.g: Ctrl+third from left on bottom to copy)
08:19:39 <Volatile> Peaker_; that would just be HORRIBLE!
08:19:43 <b_jonas> Peaker_: dunno, that just feels wrong
08:19:47 <Peaker_> Volatile, Why?
08:19:49 <b_jonas> firstly, the help would be wrong
08:19:54 <cjb> Peaker_: Ubuntu does this :(
08:19:59 <b_jonas> secondly, it could clash
08:20:00 <cjb> or at least, some apps
08:20:05 <b_jonas> and whatever
08:20:10 <radix> cjb: it's Gnome's (and GTK's) behavior
08:20:12 <Volatile> Well, for example, in the terminal ^C suddeny isn't "abort" anymore, but <tab>
08:20:19 <cjb> so, my xterms are in dvorak, but when I run Inkscape, cut is ctrl-{qwerty-x}
08:20:22 <Peaker_> Well, say that the shortcut is displayed visually on the keyboard rather than "Ctrl+<letter>" or mapped to letter in the current layout
08:20:24 <cjb> radix: Ah.
08:20:33 <radix> cjb: So, it actually scans which keymaps you have enabled.
08:20:40 <cjb> ah, yeah, reading scrollback now.
08:20:48 <radix> cjb: If you only have one latin keymap at a time, then it's got consistent behavior.
08:21:01 <cjb> radix: you can have more than one latin keymap at a time?  :)
08:21:02 <b_jonas> but I don't think I'll use an unmodified dvorak anyway
08:21:07 <radix> cjb: I mean configured for selection.
08:21:14 <cjb> *nod*
08:21:26 <b_jonas> I have to find some way to mix my current keymap with dvorak
08:21:43 <radix> So now I only have dvorak configured for selection and have to go through the 10 clicks or whatever it is to enable qwerty when someone wants to pair with me.
08:21:44 * Volatile uses a modification of a substandard of a swedish dvorak layout
08:22:30 <Peaker_> radix, are you more productive with dvorak?
08:22:38 <b_jonas> currently I'm using us-english with hungarian characters mapped to caps-lock+their-place-on-the-hungarian-keymap
08:22:52 <radix> Peaker: More productive than what, my productivity 7 years ago when I switched? :)
08:22:57 <b_jonas> (with some extras mapped to caps-lock+numbers and caps-lock+shift+numbers)
08:23:09 <Peaker_> radix, heh, faster with the keyboard than 7 years ago, yes
08:23:18 <radix> Peaker: yes
08:23:32 <cjb> Peaker_: often people learn a second keymap better than their first, I think.  I don't seem to use my little fingers when typing qwerty, for example.
08:23:36 <Peaker_> radix, Worth the non-uniformity and difficulty of sharing keyboards/etc?
08:23:42 <cjb> but with dvorak I trained myself to position my fingers properly.
08:24:10 <radix> Peaker: I use standard dvorak and found no reason to customize any applications beyond that. and it's not a big pain to switch layouts when you're pairing.
08:24:33 <b_jonas> cjb: yep
08:24:47 <b_jonas> second is definitely easier
08:25:16 <b_jonas> radix: I tried dvorak once and at that time I added a simple shortcut to change the keymap either way
08:25:25 <b_jonas> so changing is surely no problem
08:25:45 <radix> yes, most OSes give you the ability to switch with a key combo.
08:26:20 <b_jonas> radix: yep. it used to be like that from the start of customizable keymaps
08:26:35 <b_jonas> no wonder, because the us keymap is burnt to the rom so it doesn't eat extra memory
08:26:38 <Peaker_> well, if you are used to dvorak, and you have to use others' computers who can't easily be set up to use dvorak, isn't it a pain to use qwerty again?
08:26:39 <b_jonas> (in the dos days that is)
08:27:08 <Peaker_> 101 bytes of memory? :-)
08:27:16 <radix> Peaker: I know how to set up dvorak on most OSes within a couple of minutes.
08:27:23 <andun> Peaker_: i have a part time job in tech support, and it looks really clumsy when i'm writing on their qwerty layouts =)
08:27:29 <b_jonas> Peaker_: :)
08:27:32 <radix> Peaker: And when I only want to type a short bit, it's tolerable to use QWERTY
08:27:34 <b_jonas> but no
08:28:07 <radix> Peaker: I leave a trail of multi-keymap setups behind me when I'm using other peoples' computers :)
08:29:27 <Botje> > fix (tail.show) 42
08:29:31 <lambdabot>  Couldn't match expected type `t1 -> t'
08:29:43 <Botje> > fix (tail . show) "42"
08:29:43 <lambdabot>  Couldn't match expected type `[Char] -> t'
08:29:52 <Botje> grr :(
08:29:53 <b_jonas> radix: lol
08:34:54 <wolverian> with -fglasgow-exts, ghc understands the unicode versions of ->, forall, etc. can I enable this with a narrower pragma, e.g. a LANGUAGE option?
08:35:17 <wolverian> I tried to find it in the manual, but it wasn't mentioned even under the -fglasgow-exts documentation!
08:36:17 <wolverian> ah. -XUnicodeSyntax.
08:40:45 <hpaste>  bauchus pasted "let in do" at http://hpaste.org/6840
08:41:06 * bauchus has a question...
08:41:38 * Botje has a Maybe answer
08:41:45 * bauchus programs too much in ocaml. http://hpaste.org/6840 is syntactical wrong. 
08:42:03 <bauchus> how should i rewrite it?
08:42:04 <EvilTerran> bauchus, drop the "in"
08:42:26 <CosmicRay> "let" in a "do" is different from let anywhere else
08:42:35 <hpaste>  (anonymous) annotated "let in do" with "(no title)" at http://hpaste.org/6840#a1
08:42:40 <CosmicRay> try that
08:42:40 <hpaste>  EvilTerran annotated "let in do" with "(no title)" at http://hpaste.org/6840#a2
08:42:48 <allbery_b> although it iwll work if you indent the "in"
08:42:57 <allbery_b> (but that's bad style inside a "do")
08:43:32 <EvilTerran> bauchus, in general, the "in" has to be indented more than the "let" if its on a different line
08:43:41 <Heffalump> EvilTerran: it does?
08:43:45 <Heffalump> I always line it up with it
08:43:53 <allbery_b> not "in general", just inside a "do"
08:43:54 <bauchus> thanks!
08:44:02 <EvilTerran> but, as the others have said, it's neater to take advantage of the added sugar in do notation
08:44:05 <Heffalump> oh, right, yes
08:44:07 <EvilTerran> allbery_b, ah, i stand corrected
08:44:07 <allbery_b> because of interaction with the layout rules of "do"
08:44:21 <Heffalump> yeah
08:44:25 <Heffalump> same as if then else
08:44:27 <EvilTerran> yeah, 'cos it's not a parse error if it doesn't find a matching in for a let in a do block
08:44:35 <allbery_b> likewise with if/then/else, then and else must be indented insiide a "do" but not elsewhere
08:44:52 <EvilTerran> so it accepts the line with the let, and barfs on the non-matched in
08:45:04 <EvilTerran> but that wouldn't explain the same issue with ifs... i dunno, then
08:45:52 <allbery_b> I think it's that the layout translation for "do" happens earlier so a semicolon gets inserted before the keyword
08:46:27 <allbery_b> I suspect nested "let"s would have the same issue, but who does that?
08:50:48 <allbery_b> hm, actually you wonldn't see it in that case because it would have to be at the top level of the (virtual, via layout) braced group.  which only makes sense in "do"
08:56:08 <vegai> has anyone tried to beat yaws in a concurrency stress test?
08:56:57 <Lemmih> The webserver?
08:57:26 <vegai> yeah. Armstrong tested it against apache once. Apache died at 4k concurrent connections, while yaws managed > 80k
08:58:48 <vegai> the details are there: http://www.sics.se/~joe/apachevsyaws.html
08:58:49 <lambdabot> Title: Apache vs. Yaws
08:59:16 <vegai> oh, actually it was "Ali Ghodsi with a little help from Joe Armstrong. "
09:01:04 <vegai> I wonder when the operating system starts to be the bottleneck in such a thing
09:01:39 <bauchus> the beginning of my fist haskell 3d Game :-): darcs get http://cbauer.dnsalias.net/topkata/
09:01:41 <lambdabot> Title: Index of /topkata
09:02:31 <Heffalump>  when did the HW become the Haskell Symposium?
09:04:18 <kosmikus> after the last HW
09:04:43 <kosmikus> it's mainly an ACM thing
09:04:57 <kosmikus> and has to do with how many people are expected to attend
09:05:14 <byorgey> bauchus: cool, what is it?
09:05:40 <Heffalump> oh, right
09:06:05 <Peaker_> what practical uses does "theorems for free" have?  Does knowing that   a->a  must be the identity function have any practical implications?
09:06:17 <Heffalump> is there a definition of the ACM hierarchy anywhere online? (I can't spot anything with a quick google)
09:06:31 <Peaker_> (I wish papers used Haskell syntax instead of funny graphics.. Hate to learn another syntax)
09:06:40 <Heffalump> Peaker_: you can put rewrite rules inside your compiler based on them
09:06:56 <bauchus> at the moment: you can move in a 3d labyrinth. You can see the main actor jumping. But you cannot control the Sphere...
09:06:58 <Peaker_> Heffalump, ah, does ghc use it?
09:07:13 <Heffalump> I'm not sure if it uses any more than trivial ones, but it could do.
09:07:35 <Heffalump> where trivial means stuff that's obvious anyway like map f . map g = map (f . g)
09:07:56 <Otoom> > length ( sum[..1999])
09:07:56 <lambdabot>  Parse error at "..199..." (column 14)
09:08:00 <Peaker_> well, if it can do that for "map" even if it only knows map's type and nothing else - that's nice
09:08:00 <Otoom> hmmm
09:08:11 <Otoom> how would i do that?>
09:08:13 <Igloo> Peaker_: It might also be _|_
09:08:17 <byorgey> bauchus: hehe, cool, I just downloaded it and tried it =)
09:08:32 <Igloo> Peaker_: Or seq something else
09:08:44 <Peaker_> Igloo, what do you mean by seq something else?
09:08:47 <Otoom> > length sum[1..999]
09:08:48 <lambdabot>  Couldn't match expected type `[a]'
09:08:50 <bauchus> i just found a way to detect hitting a wall :-)
09:09:06 <Igloo> Peaker_: e.g. \x -> seq myVal x
09:09:09 <byorgey> > length (sum [1..999])
09:09:09 <lambdabot>   add an instance declaration for (Num [a])
09:09:09 <lambdabot>     In the expression: 1
09:09:17 <Peaker_> @src seq
09:09:17 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
09:09:24 <byorgey> er, wait, Otoom, what are you trying to do?
09:09:38 <Otoom> find the length of sum[1..999]
09:09:39 <Otoom> so
09:09:44 <Otoom> > sum[1.999]
09:09:48 <lambdabot>  1.999
09:09:48 <Peaker_> Otoom, the sum is a number, what do you mean by length of a number?
09:09:49 <Otoom> > sum[1..999]
09:09:50 <lambdabot>  499500
09:09:57 <byorgey> Otoom: that doesn't make sense.  sum [1..999] is just a number, it doesn't have a length.
09:10:04 <TomMD> > length $ show $ sum [1..999]
09:10:05 <lambdabot>  6
09:10:10 <Otoom> yh!
09:10:12 <Otoom> that
09:10:15 <byorgey> oh, like that =)
09:10:16 <Otoom> =D thanks
09:10:19 <TomMD> np
09:10:23 <Otoom> what are the $ for
09:10:34 <TomMD> > length (show (sum [1..999]))
09:10:35 <lambdabot>  6
09:10:37 <byorgey> yes, if you use 'show' you can convert the number into a corresponding string (list of Chars)
09:10:44 <TomMD> just a identity function with low precidence.
09:10:45 <Heffalump> Peaker_: in practice it just has theorems for particular functions that were put there by hand. And as Igloo says strictness considerations do need to be taken into account. So theorems for free sort of help the compiler writers, but aren't necessarily used directly.
09:11:02 <Otoom> oh Okay, thanks TomMD
09:11:04 <Peaker_> Otoom, a $ b  is like (a (b)). the precedence of $ is so low, that whatever stuff is in (b) won't need parenthesis
09:11:30 <Otoom> ah okay
09:11:52 <Peaker_> Igloo, what does seq do?
09:12:36 <Peaker_> Igloo, Heffalump:  What would be consequences of ignoring the fact that (a->a) may be bottom, and assuming its the identity function?  Are bottoms guaranteed to be eavluated and cause failures?
09:12:55 <TomMD> Not that I'm Ian, but - seq solves the worlds problems by forcing evaluation of arg1 before returning arg2
09:13:14 <TomMD> > undefined `seq` 42
09:13:14 <lambdabot>  Undefined
09:13:23 <TomMD> > "hello" `seq` 42
09:13:23 <lambdabot>  42
09:13:26 <Peaker_> why would you want to do that?
09:13:36 <Heffalump> Peaker_: well, you might turn a terminating program into a non-terminating one as a result
09:13:55 <Otoom> > sum [3,6..999] + sum [5,10..999] - sum [15,30..999]
09:13:56 <lambdabot>  233168
09:14:07 <Heffalump> but there's recent-ish work on dealing with that kind of problem - see "Free theorems in the presence of `seq`" by Voigtlander and Johann at POPL '04.
09:14:33 <Heffalump> basically they figure out the side-conditions you need to make the free theorems still be valid
09:14:59 <Peaker_> Heffalump, hmm, I dislike seq :)  Can't it just try to evaluate the various alternatives in parallel?
09:15:14 <TomMD> @type seq
09:15:15 <lambdabot> forall a t. a -> t -> t
09:15:15 <Heffalump> can't what do what?
09:15:16 <TomMD> @type par
09:15:17 <lambdabot> forall a b. a -> b -> b
09:15:40 <Peaker_> Heffalump, Maybe I misunderstand, any example circumstance one would use seq for?
09:16:00 <Heffalump> @src foldl'
09:16:00 <lambdabot> foldl' f a []     = a
09:16:00 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
09:16:24 <Heffalump> if you evaluate foldl (+) 0 [1..1000000], you'll get a huge thunk
09:16:31 <Heffalump> if you use foldl' instead, you won't
09:17:04 <resiak> how does par x y behave when evaluation of x doesn't terminate?
09:17:26 <Heffalump> it's absolutely crucial for dealing with "space leaks" of that nature
09:17:28 <Peaker_> Heffalump, Wouldn't it be better to have the compiler/runtime be smarter about thunk handling, and start stricting thunks that become too large?
09:17:38 <TomMD> > undefined `par` 5
09:17:39 <lambdabot>  5
09:17:42 <TomMD> thats how
09:17:43 <Heffalump> Peaker_: we don't have any compilers/runtimes that are that smart.
09:18:07 <TomMD> > 4 `par` 3
09:18:08 <lambdabot>  3
09:18:15 <Heffalump> a few people have tried (Maessen's Eager Haskell, Ennals' optimistic evaluation)
09:18:25 <resiak> TomMD: as I understand it, par's first argument gets shoved in a queue of things to be opportunistically evaluated; does putting a non-terminating expression in that queue break the world?
09:18:27 <Heffalump> and things do get better, but it's not enough
09:18:35 <Peaker_> Haskell could be divided into the model, syntax, and compiler hints.. I wish this separation was explicit and stuff like "seq" were just hints
09:18:45 <Otoom> > sum [2,4,6..999]
09:18:45 <lambdabot>  Parse error at "..999..." (column 11)
09:18:50 <Otoom> > sum [2,4,..999]
09:18:50 <lambdabot>  Parse error at "..999..." (column 10)
09:18:51 <Heffalump> well, seq isn't just a hint, it changes semantics
09:18:53 <Otoom> > sum [2,4..999]
09:18:54 <lambdabot>  249500
09:18:55 <TomMD> resiak: I certainly hope not :-)  but for a complete answer on that you'll have to look further than me.
09:19:04 <Peaker_> Otoom, You can use /msg lambdabot :)
09:19:06 <resiak> TomMD: okay :)
09:19:24 <Otoom> Oh, Peaker_ can i not do it in here? Sorry.
09:19:25 <Heffalump> there was a suggestion that it should go in a type class when H98 was being designed, but a substantial number of people were strongly against that as it makes it much harder to introduce
09:19:28 <Peaker_> Heffalump, What semantics does it change?
09:20:00 <Heffalump> well, a `seq` b evaluates to the same thing as b evaluates to if it terminates, but it doesn't necessarily terminate even if b does
09:20:06 <Peaker_> Otoom, you can, I think, but are all these sums that interesting to everyone? :)
09:20:18 <resiak> I can't see any mention of par's behaviour in the presence of bottoms in the ghc docs
09:20:25 <Otoom> Maybe not to you, but Peaker_ i am learning
09:20:46 <shachaf> Otoom: There's also #haskell-overflow, if you want some other people to see.
09:21:03 <shachaf> Otoom: Hence Peaker_'s suggestion of doing it in /msg. :-)
09:21:03 <Peaker_> Otoom, I mean, if its something you're about to ask a question on, or a behavior you'd like to demonstrate, or a quick check, then sure, but asking lots of > sum [..] questions may become noise at some point
09:21:18 <byorgey> Otoom only did three...
09:21:45 <Otoom> Fine, Ill do it some other place.
09:21:49 * shachaf doesn't think three is a cause for alarm...
09:21:49 <byorgey> Otoom: I think you are fine.
09:21:50 <Otoom> Ill do it over command line.
09:21:56 <Otoom> Or something.
09:21:59 <shachaf> Just that Peaker_ was telling Otoom about the possibility.
09:21:59 <Otoom> GHCi or whatever.
09:22:02 <Peaker_> I didn't yell or anything :-)
09:22:20 <Otoom> Yeah i know. But it is obvious you don't like it.
09:22:41 <Peaker_> Heffalump, Well, if you're willing to consider termination/non-termination as a semantic of a different sublanguage as the sublanguage of the values of evaluation, then "seq"/"par" can be in the first rather than the latter
09:23:01 <Heffalump> I don't follow.
09:23:12 <Heffalump> Are you saying that "optimisation hints" should be allowed to affect termination?
09:23:32 <Peaker_> Heffalump, I'm suggesting that possibility.. is that awful? :)
09:23:56 <Peaker_> maybe "optimization" would be a wrong name then
09:24:14 <Heffalump> I think it's pretty awful, yes :-)
09:25:56 <Peaker_> Heffalump, if the whole termination/evaluation-strictness stuff is encapsulated somehow, it could be nice
09:27:01 <olsner> @ty (\(a::IO Bool) -> if a then True else False)
09:27:02 <lambdabot>     Couldn't match expected type `Bool' against inferred type `IO Bool'
09:27:02 <lambdabot>     In the predicate expression: a
09:27:02 <lambdabot>     In the expression: if a then True else False
09:27:16 <Japsu> aaaaaa
09:27:29 <Japsu> -aaaaaa
09:27:35 <DRMacIver> dons: By the way, your profile information on the "Real World Haskell" page seems to be out of date.
09:27:49 <olsner> @ty do { let a = undefined :: IO Bool; if a then return True else return False }
09:27:50 <lambdabot> parse error on input `}'
09:28:03 <olsner> @ty do { let { a = (undefined :: IO Bool) }; if a then return True else return False }
09:28:03 <lambdabot>     Couldn't match expected type `Bool' against inferred type `IO Bool'
09:28:04 <lambdabot>     In the predicate expression: a
09:28:04 <lambdabot>     In the expression: if a then return True else return False
09:28:21 <resiak> @ty (\(a::IO Bool) -> a >>= \a' -> if a' then True else False)
09:28:22 <lambdabot>     Couldn't match expected type `IO b' against inferred type `Bool'
09:28:22 <lambdabot>     In the expression: if a' then True else False
09:28:22 <lambdabot>     In the second argument of `(>>=)', namely
09:28:23 <Heffalump> Peaker_: well, I think a Seq typeclass would be a good thing
09:28:30 <resiak> oh, doh
09:28:37 <resiak> aka
09:28:42 <resiak> @ty (\(a::IO Bool) -> a >>= return)
09:28:43 <lambdabot> IO Bool -> IO Bool
09:28:47 <Heffalump> and I agree with your general sentiment that it would be nice to split out what in practice amount to optimisation hints from the code itself
09:28:56 <Heffalump> but in practice I don't know how to do that given the termination issues
09:28:58 <DRMacIver> Heffalump: I thought optimisation hints *were* allowed to affect termination? Or at least that they did in GHC regardless.
09:29:01 <Peaker_> Heffalump, What would a Seq typeclass do?
09:29:53 <Heffalump> Peaker_: it would change the type of Seq from seq :: a -> b -> b to seq :: Seq a => a -> b -> b (or perhaps Seq b, I can't quite figure it out in my head)
09:30:29 <Peaker_> Heffalump, so you can only use it on types that allow it? Why do that?
09:30:44 <Heffalump> DRMacIver: yes, but those are not in the language itself
09:30:57 <Heffalump> so it's somehow a bit less polluting
09:31:01 <DRMacIver> ok
09:31:24 <Peaker_> Heffalump, If stuff out of the "language itself" is allowed to do it, then its great, take "seq" out of the language itself
09:31:26 <Heffalump> Peaker_: to restore parametricity. If seq is in a typeclass, then you know that map :: (a -> b) -> [a] -> [b] can't be using it, cos there's no Seq constraint in the type.
09:31:42 <Heffalump> Peaker_: but then your programs become less portable.
09:31:57 <b_jonas> Heffalump: but then you'd need a new deriving rule
09:32:20 <Heffalump> b_jonas: as in being able to derive Seq? Sure.
09:32:28 <b_jonas> Heffalump: yep
09:33:05 <Heffalump> Every seq would have the same actual implementation
09:33:25 <DRMacIver> Presumably the right way to do this would be to have an unsafeSeq operation and a Seq type class.
09:33:41 <dcoutts> @yarr!
09:33:41 <lambdabot> Where d' all t' pirates come from?
09:33:41 <lambdabot> Great Yarrmouth!
09:33:42 <Heffalump> In fact I think you could arrange for every type to automatically be in Seq.
09:33:43 <b_jonas> or what if you just did a kludge and used Eq and let seq x y = if x == x then y else y
09:33:53 <Heffalump> b_jonas: that has different semantics to seq
09:34:00 <shachaf> Would something like instance Seq a where ... possibly work?
09:34:04 <b_jonas> Heffalump: hmm, maybe
09:34:07 <Peaker_> Heffalump, If code was not limited in its information by what fits nicely into the syntax, then we could add arbitrary optimization hints to the code without making it uglier, and better encapsulating the various aspects..
09:34:08 <b_jonas> yes, it evaluates deeply
09:34:13 <b_jonas> sorry, that's not good then
09:34:22 <Heffalump> b_jonas: that's roughly what most deepSeq implementations would do.
09:34:47 <Heffalump> Peaker_: in principle I agree. In practice I don't know how to do that nicely.
09:34:51 <b_jonas> shachaf: why not? if it defines seq from case on the constructors?
09:35:01 <Heffalump> also, how do "optimisation hints" compose?
09:35:14 <DRMacIver> Badly, usually. :)
09:35:20 <Heffalump> well, yes.
09:35:28 <Peaker_> Heffalump, I think the only way forward is disconnecting program presentation from its content -- specialized UI's that edit the code
09:35:40 <b_jonas> Heffalump: so would you define function types to be Seq?
09:35:43 <shachaf> b_jonas: I mean, defining everything to be an instance of Seq at once, with seq = unsafeSeq.
09:36:10 <Heffalump> b_jonas: I was suggesting that the compiler just automatically provide Seq instances for everything, using the current implementation.
09:36:16 <Heffalump> for all concrete types, that is
09:36:28 <Peaker_> Heffalump, You could overlay a logic language, optimization hints language, and other languages that speak "about" the code in the code itself, without polluting the nomral view/edit of the code
09:36:29 <b_jonas> Heffalump: including functions?
09:36:32 <Heffalump> it would just be that for polymorphic types, you would have to explicitly state that you used Seq
09:36:45 <Heffalump> b_jonas: yes. It would work as it does now, a lambda is in WHNF.
09:37:05 <b_jonas> would it use some new primitive seqForFunctions of type (a->b)->c->c ?
09:37:13 <Heffalump> Peaker_: you could, yes. If you have time to implement something that would be usable, please do!
09:37:14 <b_jonas> which would mean the same as seq noe
09:37:28 <Heffalump> b_jonas: why would you need to?
09:37:53 <b_jonas> on the other hand,
09:38:01 <b_jonas> woudln't that new class break programs
09:38:10 <b_jonas> that expect that seq :: a -> b -> b
09:38:20 <b_jonas> and have explicit type annotations
09:39:15 <Heffalump> oh, it would be far too disruptive to introduce now
09:39:38 <Heffalump> I was just explaining/discussing how it could have worked had it been done earlier in the development of Haskell.
09:39:58 <dcoutts> @seen bringert
09:39:58 <lambdabot> I saw bringert leaving #ghc, #haskell.se and #haskell 7h 47m 36s ago, and .
09:40:35 <FreeNod2> imperial college
09:40:49 <Botje> hello to you too!
09:41:10 <dcoutts> @seen Lemmih
09:41:10 <lambdabot> I saw Lemmih leaving #haskell 34m 2s ago, and .
09:41:22 <FreeNod2> hi haskell geniuses :)
09:43:55 <bugQ> OK, in the Complex module definition, it says: data (RealFloat a) => Complex a = !a :+ !a
09:44:41 <bugQ> is there any reason that ghc can't infer the "(RealFloat a) =>" in the later funciton definitions?
09:45:07 <bugQ> or, that it shouldn't be able to.
09:45:26 <Heffalump> no
09:45:36 <Heffalump> in practice putting constraints there is completely useless
09:45:50 <bugQ> it doesn't work for me without them, though.
09:45:58 <Heffalump> I mean in data declarations
09:46:03 <Heffalump> rather than in the functions that work on them
09:46:10 <bugQ> ah.
09:46:16 <Heffalump> because H98 just gets it wrong
09:46:34 <Heffalump> if you use the new GHC "where" syntax to define datatypes, you actually can assume the constraints in definitions
09:46:52 <bugQ> oh, huh.
09:46:55 <Heffalump> simply because they took the opportunity of introducing non-H98 syntax to also fix the semantics
09:48:42 <bugQ> why not just enhance the semantics of the old context syntax?
09:49:07 <bugQ> it would still be backward-compatible, yes?
09:50:20 <Heffalump> not sure, I haven't thought it through.
09:50:31 <bugQ> all right.
09:50:40 <Heffalump> Arguably not rejecting programs you should is an extension in itself.
09:51:09 <gxng> hello
09:52:45 <shachaf> gxng: Hello.
09:53:41 <tromp> > 1350*1.33
09:53:42 <lambdabot>  1795.5
09:55:31 <gxng> hows every1
09:55:46 <gxng> any1 taking haskell as a course and finding it hard?
09:56:32 <mgdtgd> hello
09:56:41 <mgdtgd> I've got a problem with wxHaskell on windows
09:56:53 <ripplepay> I'm on ubuntu. is there an easy way I can get all the "haskell hierarchical libraries" stuff installed so that I can browse via firefox locally? Going away for a while and likely to have sporadic connectivity to the interweb...
09:57:08 <mgdtgd> I just installed wxWidget 2.6.4, ghc 6.8 and wxHaskell 10.3
09:57:21 <HunterXHunter> how do I see a list of defined variables in GHCi ?
09:57:35 <ripplepay> apt-cache search ghc | grep -i 6.8
09:57:40 <ripplepay> oops.
09:57:58 <mgdtgd> trying to load the HelloWorld example however gives me
09:57:59 <mgdtgd> Loading package wxcore-0.10.3 ... : can't load .so/.DLL for: wxc-msw2.6.4-0.10.3
09:57:59 <mgdtgd>  (addDLL: unknown error)
09:58:15 <mgdtgd> that's rather strange, since its in my path
09:58:20 <mgdtgd> windows/system32
09:58:23 <mrd> ripplepay: might want to search for libghc6
09:58:34 <roconnor> Did we ever figure out what atomically retry does?
09:59:01 <ripplepay> mrd: to get browsable docu locally?
09:59:08 <mrd> ripplepay: the -doc packages
09:59:19 <gxng> cale: how r ya man?
09:59:20 <Heffalump> roconnor: loop, surely?
09:59:32 <mgdtgd> rippleplay: wget everything to a local folder
09:59:32 <Heffalump> or rather hang, since there'd be no TVars to retry on
09:59:35 <shachaf> HunterXHunter: <tab><tab>? :-)
09:59:47 <Heffalump> but I presume the situation is rather more complicated otherwise you wouldn't be asking
10:00:44 <HunterXHunter> shachaf: I'm using windows and pressing tab prints a whitespace on the screen
10:00:59 <roconnor> Heffalump: I'm wondering if hangIO = atomically retry would be a better implementation than conal's
10:01:30 <Heffalump> what was conal's?
10:01:51 <Heffalump> this is in his ICFP submission? I haven't read that yet.
10:02:00 <roconnor> do forever $ threadDelay maxbound
10:02:39 <Heffalump> how does the thread get interrupted?
10:03:15 <roconnor> I don't think it ever does
10:03:25 <shachaf> HunterXHunter: I don't know, then.
10:03:32 <shachaf> HunterXHunter: Variables you defined?
10:03:44 <HunterXHunter> shachaf: using let x = ...
10:03:49 <roconnor> Heffalump: hang = unsafePerformIO hangIO
10:04:00 <shachaf> HunterXHunter: Your memory, then? :-)
10:04:01 <HunterXHunter> shachaf: yes variables I defined
10:04:15 <HunterXHunter> shachaf: agghh
10:04:44 <byorgey> HunterXHunter:   :show bindings
10:04:46 <gxng> any1 know of a haskell chess prog using gfx?
10:04:56 <HunterXHunter> byorgey: thanks
10:05:16 <byorgey> HunterXHunter: I actually didn't know that before, I just typed :help  in ghci and found it =)
10:05:42 <HunterXHunter> byorgey: right, :help is very helpful
10:05:57 <roconnor> @ask conal Would hangIO = atomically retry be a better (although less portable) definition of hangIO?
10:05:57 <lambdabot> Consider it noted.
10:06:19 <hpaste>  nolrai_ pasted "what is going on? wierdness with deriving" at http://hpaste.org/6842
10:10:18 <nolrai_> could some one have a look at my paste? It looks almost like a bug in ghc to me.
10:11:35 <Heffalump> nolrai_: no, it's the way type instances work
10:11:45 <Heffalump> it doesn't look at the antecedents to decide whether there is overlap
10:13:33 <nolrai_> If i use -XOverlappingInstances will it do what i want?
10:15:28 <nolrai_> Im trying to make sense of this stuf and almost getting there.
10:15:45 <Heffalump> I think it will, yes
10:15:52 <Heffalump> because it will pick the most specific instance
10:15:57 <gxng> i dont suppose any1 here is from montreal?
10:16:12 <EvilTerran> yeah, and B NoShow is more specific than B a
10:16:52 <nolrai_> Ok cool.
10:17:09 <nolrai_> thanks.
10:20:48 <rdtsc> mrd: I had the same problem on vista, I put the dll in ghc/bin when running with ghci, worked liked a charm
10:21:29 <Zao> Windows searches your %PATH% by the way for DLLs.
10:21:37 <rdtsc> i think msoft has heavily depreciated the idea of applications putting their dlls in system32
10:22:14 <Zao> See http://msdn2.microsoft.com/en-us/library/ms682586.aspx for more info.
10:22:15 <lambdabot> Title: 500 Internal Server Error
10:22:29 <rdtsc> nice title :-)
10:22:33 <Zao> Worksforme :)
10:23:56 <ddarius> msdn doesn't like lambdabot
10:30:12 <hpaste>  bugQ pasted "insufficient type inference" at http://hpaste.org/6843
10:31:09 <Heffalump> bugQ: same problem as above - the Num constraint is *required* rather than *available* for any functions that use Point
10:31:53 <bugQ> right, and that seems like it makes a lot of repetition.
10:31:54 <ddarius> bugQ: Contexts on data types are useless, you should never do it.
10:32:09 <bugQ> meh, ok.
10:32:11 <Heffalump> bugQ: agreed
10:35:28 <conal> roconnor: i like that def.  more direct, less of a hack than "forever $ threadDelay maxbound".
10:35:28 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
10:36:43 <SamB> bugQ: yeah, they should have never added that
10:36:57 <Heffalump> conal: what are you trying to achieve by hanging, OOI?
10:37:05 <SamB> if they hadn't added it, then someone might have made an extension that actually did what you would expect!
10:37:19 <conal> roconnor: though, perhaps using STM is sledgehammer on a fly
10:37:37 <SamB> at the very least, it would have saved you & me the pain of trying to figure out why it wasn't working
10:37:48 <conal> Heffalump: an identity for concurrent choice (ambiguous or unambiguous).
10:37:49 <bugQ> oh, what's that extension is that?
10:38:00 <bugQ> er, really bad grammar. sorry
10:38:14 <SamB> existential types does what you want
10:38:22 <SamB> maybe?
10:38:24 <Heffalump> as I said earlier, GADT syntax does what you want too
10:38:31 <Heffalump> at least AIUI it does
10:38:32 <SamB> oh, yes, GADT does
10:38:37 <bugQ> mmkay then.
10:38:40 <SamB> or at least the syntax means what you expect
10:38:52 <SamB> which means if it doesn't work, the typechecker will just tell you straight
10:39:10 <SamB> "you can't do that kind of thing"
10:39:23 <SamB> rather than interpreting your code in a completely different manner than intended
10:40:04 <nolrai_> is there a way to make it so that when ever some one imports ModB which uses TypeA from ModA, the importing file has access to TypeA as if it was from ModB?
10:40:20 <SamB> which is what the context on a datatype does according to Haskell 98
10:40:25 <Heffalump> just export TypeA from ModB
10:40:41 <Heffalump> either by exporting the whole of ModA (module ModA) or by just exporting TypeA.
10:40:51 <SamB> module ModB (ModB, TypeA(..)) where
10:40:55 <SamB> er.
10:40:59 <SamB> module ModB (module ModB, TypeA(..)) where
10:41:32 <nolrai_> ok thanks.
10:42:17 <nolrai_> so thats what exporting does.
10:46:14 <conal> roconnor: btw, one of the challenges of hangIO is how *not* to get a helpful error message saying that the thread is deadlocked.
10:47:02 <Heffalump> oh :-)
10:47:13 <Heffalump> sounds like the best solution would just be to add something to GHC..
10:47:42 <Heffalump> why is exiting not an identity for concurrent choice? Perhaps I don't properly understand what that is.
10:48:20 <conal> my first try: 'newEmptyMVar >>= takeMVar', for which ghc runtime says "warning: blocking forever."
10:49:32 <conal> Heffalump: suppose you want to try two computations in parallel and take the first answer.
10:49:44 <Heffalump> oh, I see, you need to return a result.
10:49:48 <Heffalump> (or not)
10:50:09 <conal> right.  the identity has to always lose the race, i.e., run forever.
10:50:31 <conal> ideally without consuming any resources.
10:50:46 <Heffalump> sounds like something that should be added to the libraries
10:51:09 <conal> yep
10:52:14 <gxng> :P
10:57:36 <roconnor> conal: does atomically retry produce a helpful error message?
10:58:12 <conal> roconnor: i don't recall whether i've tried.
10:58:32 <roconnor> conal: I tried in ghci 6.6 and it just hung.
10:58:47 <awesame> ok, looks like I need to learn about exceptions in Haskell
10:58:48 <conal> roconnor: cool :)
11:00:45 * chessguy checks to see if #haskell works on his new macbook
11:00:58 <chessguy> @pl \x y -> x + y
11:00:58 <lambdabot> (+)
11:01:01 <chessguy> wheee
11:01:17 <roconnor> I think it would be wrong for "atomically retry" to give a warning message, but I'm not sure.
11:01:23 <awesame> hGetLine can throw an isEOFError exception, and I need to catch it
11:01:48 <roconnor> then again it is possibly wrong for `newEmptyMVar >>= takeMVar' to gove a warning message too.
11:01:56 <awesame> is there an example somewhere of the usual idiom for this kind of thing?  the docs on haskell.org are a confusing place to start
11:02:48 <roconnor> awesame: do you want run-time exceptions, or your own exceptions via MonadError?
11:03:33 <awesame> roconnor: probably the former -- whatever hGetLine would throw
11:03:57 <roconnor> yes, that would be a run-time exception
11:04:38 <roconnor> awesame: there is section 7.3 of the haskell 98 report http://www.haskell.org/onlinereport/io-13.html
11:04:38 <lambdabot> Title: The Haskell 98 Report: Basic Input/Output
11:04:51 <roconnor> awesame: but there is a somewhat better, more modern approach
11:05:14 <gxng> Let us add state to Haskell by defining a recursive type for a _mutable_ data
11:05:14 <gxng> structure that can be acted on by Haskell transactions.  (Actually, these are
11:05:14 <gxng> Haskell++ transactional functions---so not even the latest GHC will compile
11:05:14 <gxng> them).
11:05:35 <gxng> opps..just wanted to know if ne1 interested in helping with my assignment
11:05:55 <awesame> roconnor: I'd like to learn about the more modern approach
11:07:23 <roconnor> the modern approach is to use catchJust or handleJust (they are essentially the same) from Control.Exception
11:08:11 <roconnor> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#v%3AcatchJust illustrates the basic usage
11:08:13 <lambdabot> http://tinyurl.com/sqmlj
11:08:38 <Heffalump> make sure you hide the catch from the prelude
11:08:42 <Heffalump> or confusion will reign
11:08:54 <awesame> roconnor: ah, ok, that makes sense
11:08:56 <awesame> thanks!
11:09:24 <gxng> any1 want to help with my assignment?
11:09:27 <Heffalump> gxng: if you have specific questions that are causing you problems, just ask here and someone will probably help. Try to condense them down as much as possible and don't just ask us to do the assignment, obviously.
11:09:35 <roconnor> awesame: oh right, what Heffalump said
11:09:45 <gxng> here's a sample header
11:09:50 <roconnor> awesame: you need to do import Prelude hiding (catch) when you import Control.Exception
11:10:05 <gxng>   mutableData Tree = Empty | Root {string :: String} {count :: Integer}
11:10:05 <gxng>                                   {left :: Tree} {right :: Tree}
11:10:07 <awesame> right, ok
11:10:12 <roconnor> awesame: well actually if you stick to catchJust, then it doesn't really matter.
11:10:23 <Heffalump> gxng: and please use hpaste for anything more than a line or two of code
11:10:26 <Heffalump> @hpaste
11:10:26 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:10:32 <gxng> thx
11:10:43 <Heffalump> it seems like you are talking about some extension of Haskell that we are unlikely to be familiar with, however.
11:10:59 <gxng> prof likes to call it ... haskell++ :P
11:11:11 <Heffalump> I think I heard someone on here mentioning it a while back (perhaps you)
11:11:19 <gxng> ya yesterday lol
11:11:53 <Heffalump> no, several weeks ago
11:12:21 <gxng> lol prob some1 else in my class..the chance of some1else from another skool doing similar assignment is prob low
11:12:46 <gxng> o wait..assn was given jsut a few days ago..neways
11:14:26 <gxng> the thing is the prof does all his compiling in his head n dis haskell extension wont compile for sure:P
11:14:56 <takamu> hi
11:15:38 <takamu> @users
11:15:38 <lambdabot> Maximum users seen in #haskell: 466, currently: 463 (99.4%), active: 13 (2.8%)
11:16:05 <takamu> mmm xchat says 462 total
11:17:36 <roconnor> @karma Haskell
11:17:36 <lambdabot> Haskell has a karma of 27
11:17:46 <roconnor> @karma haskell
11:17:46 <lambdabot> haskell has a karma of 27
11:18:33 <gxng> karma out of what? lol
11:19:09 <clanehin> Haskell++
11:19:18 <bugQ> Ooo, neat, is karma here like "hate" in Utu?
11:19:49 <bugQ> I refer to http://savingtheinternetwithhate.com/
11:19:49 <lambdabot> Title: Utu: start
11:20:23 <gxng> clanehin: got ne idea what i was talkn about? lol
11:20:32 <roconnor> well, karma here doesn't actually do anything
11:20:49 <bugQ> oh, shucks.
11:21:16 <roconnor> other than social effects
11:21:25 * allbery_b looks confused
11:22:43 <vegai> @karma java
11:22:43 <lambdabot> java has a karma of -22
11:22:50 <bugQ> heehee.
11:23:07 <bugQ> Java--
11:23:41 <gxng> @hpaste
11:23:41 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:23:59 <gnuvince_> @karma
11:23:59 <lambdabot> You have a karma of 0
11:24:23 <nolrai_> @karma java
11:24:23 <lambdabot> java has a karma of -23
11:30:17 <vegai> s
11:33:58 * roconnor uses his first pattern guard
11:34:02 <roconnor> \o/
11:34:54 <bugQ> funtimes!
11:38:25 <HunterXHunter> @karma haskell
11:38:25 <lambdabot> haskell has a karma of 28
11:47:32 <HunterXHunter> > compose [sum,(^2),filter even]
11:47:34 <lambdabot>   Not in scope: `compose'
11:48:14 <Heffalump> > let compose = foldr (.) id
11:48:14 <lambdabot>  Parse error at end of input
11:48:15 <HunterXHunter> > let compose l = foldl (.) id l in compose  [sum,(^2),filter even]
11:48:15 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
11:48:15 <lambdabot>       Expected...
11:48:33 <HunterXHunter> > let compose  = foldl (.) id  in compose  [sum,(^2),filter even]
11:48:33 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
11:48:33 <lambdabot>       Expected...
11:48:38 <Heffalump> did you mean map (^2)
11:48:47 <HunterXHunter> > let compose  = foldl (.) id  in compose  [sum,map (^2),filter even]
11:48:47 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
11:48:47 <lambdabot>       Expected...
11:49:01 <Heffalump> oh, I see
11:49:05 <mauke> sum :/: a -> a
11:49:09 <Heffalump> you can't put things of different types in lists
11:49:17 <HunterXHunter> oh
11:50:15 <HunterXHunter> what is the fix?
11:50:34 <mauke> sum . map (^ 2) . filter even
11:51:35 <HunterXHunter> why was the former invalid?
11:51:53 <mauke> what's the type of [sum,map (^2),filter even] ?
11:52:12 <HunterXHunter> a list ?
11:52:16 <EvilTerran> a list of what?
11:52:17 <mauke> "a list" is not a type
11:52:33 <HunterXHunter> a list of numbers?
11:52:40 <mauke> that's not a type either
11:52:41 <EvilTerran> but they're functions!
11:52:50 <mauke> do you mean (Num a) => [a]?
11:52:54 <HunterXHunter> yes a list of functions
11:53:05 <opqdonut> functions from what to what?
11:53:29 <EvilTerran> HunterXHunter, ok, so the type is [... -> ...], then. what're the ...s?
11:53:30 <HunterXHunter> ohh
11:53:40 <HunterXHunter> the problem is with sum
11:53:47 <EvilTerran> yeah
11:54:03 <EvilTerran> ?type [return.sum, map (^2), filter even] -- hacky
11:54:10 <lambdabot> forall a. (Integral a) => [[a] -> [a]]
11:54:16 <opqdonut> :)
11:54:22 <EvilTerran> > return.sum $ [1..10]
11:54:22 <lambdabot>   add an instance declaration for (Show (m a))
11:54:28 <EvilTerran> > return.sum $ [1..10] :: [Int]
11:54:29 <lambdabot>  [55]
11:55:04 <EvilTerran> don't do that, i'm just demonstrating a quick hack to make the types match up
11:55:11 <HunterXHunter> ok
11:56:00 <EvilTerran> why do you want to compose a list of functions, anyway?
11:56:27 <EvilTerran> can't you just (.) them together as you go along?
11:57:08 <opqdonut> data FunctionChain a b = Fun (a->b) | exists c. Comp (a->c) (FunctionChain c b)
11:57:11 <opqdonut> or something like that :)
11:57:30 <EvilTerran> eeew
11:57:36 <opqdonut> :?
11:57:39 <opqdonut> P
11:58:02 <EvilTerran> the only thing you could do with a Comp value would be to apply the two functions consecutively, anyway
11:58:14 <opqdonut> the only thing you can do
11:58:24 <opqdonut> with that exists there
11:58:25 <EvilTerran> or compose them (same end result)]
11:58:30 <EvilTerran> exactly
11:58:33 <opqdonut> :)
11:58:38 <EvilTerran> so you might as well just compose them in the first place
11:58:41 <opqdonut> yep
12:00:03 * EvilTerran would probably write that with GADTs as data Dot :: * -> * -> * where Dot :: (b -> c) -> (a -> b) -> Dot a c -- if it weren't pointless, anyway.
12:00:12 <Heffalump> opqdonut: eww, use a GADT like the good Simon intended
12:00:18 <EvilTerran> :D
12:00:59 <Heffalump> and that type can be useful if you stick in an extra, specific constructor
12:01:56 <EvilTerran> can it really be more useful to keep two functions apart, with the inbetween type existentially quantified, than to just compose them? even with an extra constructor, it doesn't seem very useful
12:02:01 <bugQ> > fhead $ foldr ($) [1..10] [return.sum, map (^2), filter even]
12:02:01 <lambdabot>   Not in scope: `fhead'
12:02:04 <bugQ> oops.
12:02:08 <bugQ> > head $ foldr ($) [1..10] [return.sum, map (^2), filter even]
12:02:08 <lambdabot>  220
12:02:19 <bugQ> that's really weird.
12:02:29 <EvilTerran> bugQ, yes, but now you've introduced a partial function into the proceedings
12:02:30 <bugQ> not sure what use it has.
12:02:38 <Heffalump> EvilTerran: you might be able to optimise
12:02:56 <EvilTerran> eh, i guess
12:03:30 <Heffalump> http://www.cs.nott.ac.uk/~nhn/Publications/icfp2005.pdf
12:03:55 <Heffalump> (that's more complicated than just normal functions, but it shows the basic idea)
12:04:39 * EvilTerran boggles
12:15:05 <BSP_> if i have a type family, defined in the obvious way so that i have "test = undefined :: Not True", is there a way to get ghci to tell me that the type of test is "False"?
12:15:27 <matthew-_> ahh, not sure
12:15:43 <matthew-_> this kind of thing does work with type classes and fundeps
12:15:52 <matthew-_> it may be something that's started working in ghc 6.9
12:15:53 <matthew-_> not sure
12:15:54 <BSP_> yeah, thats why i was wondering
12:16:15 <BSP_> hmm ok i'll try and get my checkout of 6.9 compiling and check
12:16:17 <BSP_> cheers
12:16:27 <matthew-_> you could do foo :: (False x) => x -> Bool
12:16:33 <matthew-_> and then see if you can call foo test
12:16:56 <matthew-_> you may need to use an equivalence
12:17:04 <mauke> *Main> eval (sum :. map (^2) :. filter even :. Nil) [1 .. 10]
12:17:04 <mauke> 220
12:17:19 <matthew-_> really, my knowledge of type families isn't overly strong. Heffalump is a better person to ask if he's around
12:17:48 <matthew-_> @seen Heffalump
12:17:48 <lambdabot> Heffalump is in #haskell, #darcs and #haskell-soc. I last heard Heffalump speak 13m 53s ago.
12:17:54 <matthew-_> might be around then
12:18:11 <mauke> *Main> eval (htail $ sum :. map (^2) :. filter even :. Nil) [1 .. 10]
12:18:11 <mauke> [4,16,36,64,100]
12:18:50 <BSP_> "foo :: (T ~ Not a) => a -> Bool" works
12:18:59 <BSP_> if you then do "foo test"
12:19:14 <matthew-_> right, so it knows True ~ Not False
12:19:17 <matthew-_> so that's what you want
12:19:19 <BSP_> yep
12:19:35 <BSP_> i'd like to have it "evaluate" the type level function at compile time really though
12:19:51 <BSP_> maybe it's not possible
12:20:06 <matthew-_> yeah, this is why I really still use fundeps and classes unless I need some specific property of type families
12:20:13 <matthew-_> you may well have more luck with 6.9
12:20:54 <BSP_> i'll report back if i manage to get 6.9 working, thanks for your help
12:20:59 <matthew-_> np
12:41:32 * Heffalump appears
12:41:55 * roconnor heffalumps
12:42:02 <Heffalump> BSP_: you definitely need to use 6.9, there are snapshots for download
12:42:33 <BSP_> Heffalump: great, thanks, i'll give it a try
12:42:39 <nominolo> uhuh.  "monadic reflection" is as old as monads ... interesting
12:42:52 * Heffalump has found various problems though
12:43:08 <ddarius> nominolo: As old as monads in programming...
12:43:38 <nominolo> yeah, i meant, it was mentioned already by Moggi
12:48:09 <matthew-_> thanks Heffalump
12:57:49 <swiert> @seen mattam
12:57:49 <lambdabot> mattam is in ##logic and #haskell. I don't know when mattam last spoke.
12:58:32 <OceanSpray> oooh, logic.
13:02:00 <bugQ> logic++
13:02:30 <dons> heya swiert
13:02:40 <swiert> hi dons.
13:02:45 <swiert> How's Portland?
13:02:55 * vincenz wonders why he read that as Poland
13:02:58 <dons> nice, having fun. the snow was very exciting.
13:03:17 * dons is unaccustomed to northern hemisphere winters
13:03:33 <swiert> Galois still treating you all right?
13:03:42 <Igloo> heh
13:03:49 <nominolo> there's a ##logic?
13:04:00 <Korollary> yes. quite quiet, tho
13:04:18 <dons> swiert: yeah :) we're moving into a big shiny new office in the center of the city in a month or so
13:04:22 <dons> so busy times
13:04:37 <dons> planning were to put the fussball table :)
13:04:42 <bugQ> quiet logic, huh? hmm.
13:04:45 <bugQ> logic--
13:05:10 * nominolo was shameless ignored by galois
13:05:19 <swiert> dons: sounds cool.
13:05:38 <swiert> dons: did you submit any new groundbreaking work to ICFP btw?
13:06:03 <matthew-_> there's a galois member on the PC too
13:06:12 <matthew-_> so it would be a cert to get in :p
13:07:40 <dons> swiert: no new papers, helping organise the developer workshop at icfp though
13:07:56 <swiert> dons: yeah. I saw the call go out today. Looks pretty cool.
13:08:19 <dons> yeah, hopefully like oscon, but for the icfp crowd. see how to build real things, get hired, etc. :)
13:08:34 <dons> http://article.gmane.org/gmane.comp.lang.haskell.cafe/38392
13:08:35 <lambdabot> Title: Gmane -- Mail To News And Back Again
13:08:50 <dons> "programmers who know how to solve
13:08:50 <dons> problems with functional prorgamming to give talks and lead tutorials
13:08:51 <dons> at the The ICFP Developer Tracks."
13:09:28 <dcoutts> dons, yeah, that looks interesting, are you allowed to propose a talk, perhaps we could do one on bytestring or something like that
13:09:41 <mattam> swiert: Hi.
13:10:01 <swiert> mattam: hi.
13:10:09 <swiert> mattam: I just made Program crash...
13:10:10 <dons> dcoutts: quite so!
13:10:20 <dons> "How-to talks: 45-minute "how-to" talks that provide specific information on how to solve specific problems using functional programming. These talks focus on concrete examples, but provide useful information for developers working on different projects or in different contexts.
13:10:24 <dons> "
13:10:41 <dons> also, specific technology examples
13:10:49 <dons> say, happs ,or using stm to write a webserver, etc
13:10:52 <swiert> mattam: Anomaly: uncaught exception Not_found. Please report
13:10:56 <dcoutts> dons, or perhaps on using profiling to find and fix perf bugs, hpc etc
13:11:04 <dons> my hope is that these workshops will be more fun that icfp itself :)
13:11:09 <matthew-_> that does look interesting
13:11:10 <dons> dcoutts: yeah, exactly
13:11:19 <matthew-_> is that before or after icfp?
13:11:22 <dons> during
13:11:24 <swiert> mattam: when pattern matching on a sig. I can send you the file if you want (Coq 8.1pl2 I think).
13:12:00 <matthew-_> oh.
13:12:07 <mattam> Yep, please do.
13:12:08 <matthew-_> running a parallel track?
13:13:08 <dons> well, its the 25th and 27th.
13:13:19 <nominolo> swiert: latest coq version is pl3
13:13:38 <swiert> nominolo: yeah, I know. I haven't gotten round to updating yet.
13:13:49 <NekoIncardine> Good afternoon, once again.
13:13:53 <nominolo> swiert: it said, "fixed critical bug" on the homepage but with no details whatsoever
13:14:06 * NekoIncardine looks outside. ... Looks again.
13:14:21 <swiert> (or rather, I don't think my patch to the coq port in macports has been pushed yet)
13:14:25 <NekoIncardine> God *DAMN* it. 4 inches of snow in themiddle of april. >_<
13:14:26 <mattam> nominolo: It fixed an inconsistency.
13:15:44 <mattam> A pretty neat one too, it was a non-terminating one-liner.
13:15:46 <bugQ> Oh, the snow isn't gone here either.
13:15:53 <nominolo> anyone here know "Eliot Setzer"
13:16:07 <mattam> I know Anton.
13:17:54 <nominolo> @seen bringert
13:17:54 <lambdabot> I saw bringert leaving #ghc, #haskell.se and #haskell 11h 25m 32s ago, and .
13:18:14 <bugQ> ...and .
13:18:22 <conal> The DEFUN workshop sounds like a lot of fun, but ouch -- concurrently with Haskell'08.
13:18:34 <dons> well, its over two days, iirc
13:18:53 <dons> so go to HW, then go to day 2 of defun.
13:18:58 <dons> give the scheme guys day 1
13:19:02 <Cale> conal: Nice paper the other day, btw :)
13:19:03 <conal> oh -- so maybe haskell talks could be scheduled for the 27th and erlang talks for the 25th.
13:19:07 <dons> right
13:19:13 <conal> Cale: thanks! :)  and thanks for the bug report.
13:19:22 <dons> conal: we'll try to watch that
13:19:27 <ehird_> @karma- xkfie, goapfo and aisfi.
13:19:27 <lambdabot> xkfie,'s karma lowered to -1.
13:19:43 <nominolo> anyone have an idea how expensive flights from europe to icfp will be?
13:20:41 <dons> hmm, $1k US return? approx
13:20:53 <dons> there's sometimes cheaper ones
13:21:08 <dons> also, the free trade agreement might mean some new flights,
13:22:44 <nominolo> do have some links to search engines?
13:22:58 <conal> my paper got 300 downloads, and its blog post 900 views.  i guess people are still interested in functional reactivity. :)
13:23:02 * NekoIncardine starts today's work with a fresh hpaste.
13:23:25 <Igloo> www.expedia.co.uk is who I use, although that'll get you answers in GBP of course
13:23:27 <dons> conal: very much so, i think. people want simpler, cleaner gui code, that's testable and flexible
13:23:34 <hpaste>  NekoIncardine pasted "Simple Sudoku Solver (Beta 1000something)" at http://hpaste.org/6845
13:23:38 <dons> nominolo: i use priceline.com but that's in USD
13:24:20 <NekoIncardine> Lessee... First glitch is trying to figure out rowList. I need to figure out how to get the Array from the Board type to manipulate. Currently, that command has a type error.
13:24:21 <Igloo> 1k USD from London looks optimistic, FWIW, although I did just pick random dates arond the right time
13:24:53 <nominolo> well, actually, on my flight back i could just go to london
13:25:12 <nominolo> gotta be in england the week after anyways
13:25:21 <petekaz> newbie question, I'm trying to write a list slicing function to mimic Python's slicing operations.  This is what I started with: slice1 xs (beg,end) = drop beg . take (if end < 0 then (length xs + end) else end) $ xs It works fine, but I need a simple way to let the user slice starting at a particular position to the end of the list (in python l[2:] would give a list from position 2 to the end).  I don't want to override the use of 0 to
13:25:21 <petekaz> "mean" the end as it seems hacky.
13:25:29 <swiert> nominolo: oh, congrats on your internship.
13:25:37 <swiert> nominolo: any idea what you'll be working on?
13:25:45 <nominolo> swiert: not yet
13:25:57 <nominolo> i proposed 4 topics
13:26:03 <mauke> petekaz: a user who wants l[2:] could just use drop 2
13:26:06 <nominolo> lets see what simon & simon have to say
13:26:07 <NekoIncardine> petekaz: Hrm... I dunno python's slicing op precisely, but could you write that as:
13:26:29 <NekoIncardine> take (end-beg) (drop beg xs)
13:26:31 <NekoIncardine> ?
13:26:48 <dons> Igloo, dcoutts: all set for the hackathon?
13:26:56 <Igloo> Hope so!
13:26:56 <NekoIncardine> (Which probably is not written correctly, I should note.)
13:27:05 <hpaste>  petekaz pasted "does'nt work of course" at http://hpaste.org/6848
13:27:11 <petekaz> So I started to make a Range type, this is what I started with.
13:27:29 <NekoIncardine> That will drop the items before beg from the list, then take the items until end, give or take.
13:28:19 <petekaz> It doesn't work because I'm using Value twice.  So all I have to do is change "Value" constructor in each to be unique, but I feel like there must be a better way to make my range type.
13:29:00 <nominolo> swiert: you're doing your phd at nottingham, right
13:29:02 <nominolo> ?
13:29:26 <swiert> nominolo: yep.
13:29:30 <NekoIncardine> petekaz: ... I'm a novice and at this point I'm lost. I apologize. :/
13:29:31 <petekaz> slice xs (Range (Value 2) End) just seems so much more of a pita than: slice xs (2,End) but I don't know how to do something like this.
13:29:40 <swiert> nominolo: with George - whom I'm sure you know.
13:29:47 <nominolo> yep, i know him
13:30:25 <ddarius> Slicing lists is not the best idea.
13:30:26 <nominolo> i presume thorsten is pretty well loaded with 5 phd students right now :)
13:31:07 <nominolo> oh, it's 4
13:31:24 <NekoIncardine> ddarius: For my own reference, why would that be?
13:31:24 <petekaz> I really like my first version but I can't represent the end  of the list without making 0 mean the end of a list which I thikn is hacky.
13:31:25 <swiert> nominolo: are you looking for a PhD position?
13:31:38 <nominolo> swiert: well, i'm looking for a topic first
13:32:35 <nominolo> swiert: you don't happen to have read edwin brady's thesis on compiling dependently typed programming languages and could give me a quick summary ;)
13:32:48 <ddarius> NekoIncardine: It's not an operation which lists support particularly efficiently and usually suggests you should be using a different data type.
13:33:01 <swiert> nominolo: well, I haven't read it, but I have some intuition regarding what it's about.
13:33:09 <NekoIncardine> ddarius: Hrm... Makes sense.
13:33:25 <swiert> nominolo: and edwinb does hang out in here.
13:33:34 <nominolo> @seen edwinb
13:33:34 <lambdabot> edwinb is in #haskell. I don't know when edwinb last spoke.
13:33:41 <swiert> nominolo: the idea is to compile dependent types efficiently.
13:34:17 <nominolo> yeah, like removing witnesses not needed at runtime?
13:34:21 <swiert> nominolo: to do that you need to determine what values matter at run time.
13:34:24 <swiert> nominolo: exactly.
13:34:32 <petekaz> Anyways, my real question is just how do I make a Range type that contains two ints (to represent start and ending indexes), BUT I want to be able to specify the end of a list with a token like 'End'.
13:34:43 <petekaz> and the beginning with 'Start'.
13:34:47 <ddarius> NekoIncardine: Slicing immutable arrays or mutable arrays with sharing is dirt cheap in both time and space.
13:34:53 <petekaz> data Range = Range Start End
13:34:53 <petekaz> data Start = Start | StartValue Int
13:34:53 <petekaz> data End   = End   | EndValue Int
13:35:06 <swiert> nominolo: but there's also other optimizations you can do. If you look at functions like "head" on a vector - the type tells you the only possible constructor is Cons.
13:35:08 <nominolo> swiert: could you embed an effect-type system with type inference in a dependently typed-language?
13:35:55 <dons> i find it funny that effect inference looks exactly like the implicit io monad augustuss said would appear in 2013
13:35:55 <swiert> nominolo: so there's no need to peel off the constructor in the compiled code. You can get rid of some more tags.
13:35:55 <ddarius> petekaz: I'd probably use a type class.
13:35:55 <petekaz> This seems dumb that I have to have 2 different constructor names (StartValue and EndValue) for those values.  Is this the correct way of representing this Range?
13:36:10 <nominolo> swiert: so you can use flat vectors?
13:36:21 <swiert> nominolo: I'd think so (regarding effect systems).
13:36:50 <nominolo> to me "vectors" in DTLs look a bit too much like lists
13:37:02 <swiert> nominolo: what do you mean by flat vectors?
13:37:09 <nominolo> like arrays
13:37:14 <Otoom> > sum [3,6..999], sum[5,10.999]
13:37:14 <lambdabot>   parse error on input `,'
13:37:20 <Otoom> > sum [3,6..999] sum[5,10.999]
13:37:21 <lambdabot>        add an instance declaration for
13:37:21 <lambdabot>       (Enum (([a] -> a) -> [t] -> a1),...
13:37:38 <Otoom> > sum [3,6..999] sum[5,10..999]
13:37:38 <lambdabot>        add an instance declaration for
13:37:38 <lambdabot>       (Enum (([a] -> a) -> [t] -> a1),...
13:37:42 <byorgey> Otoom: what are you trying to do?
13:37:42 <Otoom> > sum [3,6..999], sum[5,10..999]
13:37:42 <lambdabot>   parse error on input `,'
13:37:53 <Otoom> get that to work byorgey ;P
13:37:58 <nominolo> > (3,4)
13:37:58 <lambdabot>  (3,4)
13:38:29 <Otoom> sum ( [3,6..999], [5,10..999])
13:38:31 <NekoIncardine> data Tile = Solved Integer | Unsolved [Integer]
13:38:31 <byorgey> Otoom: er, right. ;)  but what would you like it to evaluate to, if it worked?
13:38:32 <NekoIncardine> data Board = Board (Array (Integer, Integer) Tile)
13:38:34 <NekoIncardine> rowList :: Board -> Integer -> [Tile]
13:38:35 <swiert> nominolo: well, they are lists decorated with extra information. How you compile them, what their low-level representation is, etc is a different question.
13:38:36 <NekoIncardine> rowList x y = [x ! (y,z) | z <- [1..9]]
13:38:45 <Otoom> just practicing mate.
13:38:54 <NekoIncardine> ^- Those four lines add up to, on the fourth line, a glitch. My question is how to make it work, basically.
13:38:56 <nominolo> swiert: but it's exactly the question that interests me ;)
13:39:04 <Otoom> byorgey: just practicing
13:39:17 <petekaz> ddarius: with regards to my objective of writing this slicing function for strings, its not a good idea?  I am parsing a log file, and just need to chop off the first 2 chars of a string, and the last 3.  So I thought of writing the slicing function.
13:39:18 <byorgey> > ( sum [3,6..999], sum [5,10..999] )
13:39:18 <lambdabot>  (166833,99500)
13:39:22 <nominolo> swiert: maybe i should just mail thorsten and get some ideas from him
13:39:26 <NekoIncardine> How do I pull the array out of the Board so that I can manipulate it, in other words?
13:39:29 <swiert> nominolo: right. It's a very good question to ask!
13:39:31 <byorgey> > map sum [ [3,6..999], [5,10..999] ]
13:39:32 <lambdabot>  [166833,99500]
13:39:39 <Otoom> sum ( [3,6..999], [5,10..999])
13:39:45 <Otoom> > sum ( [3,6..999], [5,10..999])
13:39:45 <lambdabot>  Couldn't match expected type `[a]'
13:39:50 <Otoom> why does that not work
13:39:52 <Otoom> and
13:39:56 <swiert> nominolo: we need some people to beef up the crummy compilers most DTLs have atm.
13:39:58 <byorgey> Otoom: look at the type of sum
13:39:59 <byorgey> @type sum
13:40:00 <Otoom> > (sum  [3,6..999], [5,10..999])
13:40:03 <lambdabot>  (166833,[5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110...
13:40:03 <lambdabot> forall a. (Num a) => [a] -> a
13:40:04 <NekoIncardine> Otoom: sum expects lists, not tuples.
13:40:04 <ddarius> petekaz: If efficiency is not a concern, then it's not really an issue.
13:40:20 <Otoom> > (sum  [3,6..999], [5,10..999])
13:40:21 <lambdabot>  (166833,[5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110...
13:40:28 <nominolo> swiert: that currently seems like the best fit for me (of all the current options for phd topics i can see)
13:40:29 <swiert> nominolo: kosmikus has a MSc student working on hooking Agda up to the backend of the Utrecht Haskell compiler.
13:40:39 <Otoom> > (sum [3,6..999] + sum [5,10..999])
13:40:39 <lambdabot>  266333
13:40:43 <Otoom> ah there we go.
13:40:46 <Otoom> thats the answer i need.
13:40:50 <Saizan> NekoIncardine: rowList (Board x) y = .., but use hpaste.org the next time for code :)
13:40:53 <vincenz> Otoom: you could try this
13:40:53 <petekaz> ddarius: well, if efficiency was a concern, how would you do the same to a string you read from a log file and needed to reformat for output?
13:40:56 <ddarius> dons: Do bytestrings have slicing functions.
13:40:57 <swiert> nominolo: have you talked to Ulf?
13:41:00 <NekoIncardine> Saizan: Point, sorry on that.
13:41:01 <mattam> swiert: are you saying GHC is crummy ? The Ynot guys are going from Coq to Core
13:41:08 <vincenz> > sum ([3,6..999] ++ [5,10..999])
13:41:09 <lambdabot>  266333
13:41:10 <bugQ> > sum [3,6..999] ++ [5,10..999]
13:41:10 <lambdabot>   add an instance declaration for (Enum [t], Num [t])
13:41:12 <Otoom> > (sum[3,6..999] + sum[5,10..999] - sum[15,30..999])
13:41:13 <lambdabot>  233168
13:41:14 <bugQ> whoops.
13:41:19 <nominolo> swiert: nope.  that would of course be an obvious person to ask
13:41:19 <Saizan> NekoIncardine: no problem :)
13:41:22 <bugQ> vincenz got it.
13:41:28 <vincenz> Otoom: concatenation of lists is ++
13:41:28 <swiert> mattam: have you ever tried to compile an Agda program? Have you even used Epigram? ;)
13:41:31 <vincenz> Otoom: (,) is a tuplel
13:41:32 <idnar> @pl \x y -> sum x + sum y
13:41:32 <lambdabot> (. sum) . (+) . sum
13:41:37 <vincenz> Otoom: it's not related to lists -at- all
13:41:42 <Otoom> kk
13:41:44 <swiert> nominolo: He's a nice guy and I'm sure he'd help you out.
13:41:53 <nominolo> swiert: given that i know at least one person who strongly prefers agda over epigram
13:41:53 <ddarius> petekaz: Nowadays, I'd read it in as a bytestring and slice that, or simply only read in the parts I cared about if the format was fixed enough.
13:41:54 <dons> ddarius: take/ drop in O(1) ?
13:42:01 <dons> if so, yes, its a sliceable structure
13:42:10 <glguy> > sum $ ([0,3..999] ++ [0,5..999]) // [0,15..999]
13:42:10 <ddarius> dons: Does it have anything more convenient than that, I meant.
13:42:11 <lambdabot>  Couldn't match expected type `Array i e'
13:42:11 <mgsloan> would it be faster to have one large bytestring, and a list of integral intervals in it, or a list of small bytestrings?
13:42:19 <glguy> > sum $ ([0,3..999] ++ [0,5..999]) \\ [0,15..999]
13:42:20 <lambdabot>  233168
13:42:20 <vincenz> glguy: not quite the same :)
13:42:21 <swiert> nominolo: sure. I prefer programming in Agda over Epigram (for most things)
13:42:24 <vincenz> glguy: you're assuming perfect overlap
13:42:33 <idnar> @type (\\)
13:42:34 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
13:42:39 <mattam> swiert: hehe :) I've tried. Evidently there's a lot of interesting work to do to use the massive amount of information we have now :)
13:42:42 <glguy> vincenz: why wouldn't there be perfect overlap?
13:42:46 <dons> ddarius: there was a substring, but it was notoriosuly difficult. so we reverted to just take/drop
13:42:49 <dons> which seems to suffice
13:42:53 <nominolo> swiert: yeah, but the agda "compiler" is a joke at the moment
13:42:55 <idnar> what is \\?
13:42:56 <vincenz> glguy: Well there is for this case, but you should be explicit :)
13:43:00 <swiert> nominolo: even though Epigram is much nicer in some respects, it's just unusable.
13:43:01 <tromp> > 2800*1.3333
13:43:01 <lambdabot>  3733.24
13:43:05 <idnar> @src (\\)
13:43:05 <lambdabot> (\\) = foldl (flip delete)
13:43:08 <vincenz> Anywho /me is offf
13:43:10 <idnar> ah
13:43:27 <swiert> nominolo: yep.
13:43:32 <ddarius> mgsloan: Assuming everything will be in memory at the same time, one large (strict) one would probably be faster, though if the "small" ones were substrings of a large one then it would be equivalent.
13:43:35 <glguy> vincenz: for any bounds or multiples, that approach would work though
13:43:40 <glguy> (to this specific problem)
13:43:40 <vincenz> glguy: yeah
13:43:44 <ddarius> dons: Okay.
13:43:48 <petekaz> ddarius: I sometimes find bytestrings make the code look ugly as I can't pattern match like I can with a regular string.  Fortunately efficiency is not a concern, only trying to keep the code looking nice.
13:44:08 <vincenz> glguy: I just wanted to be explicit bout it, since he seems to be new to Haskell
13:44:16 <glguy> OK, carry on then :)
13:44:42 <mgsloan> ddarius - they would be substrings.  At the same time, I'll want to break intervals and such, eg, chop a portion in half, in place.  So perhaps the list of intervals is better
13:45:37 <ddarius> mgsloan: The substring operations on (strict) bytestrings are in-place.  They just make new string "headers".
13:46:00 <mgsloan> ahh, interesting, so it would really be equivalent then :)
13:46:05 <petekaz> I was so proud of my slicing function.  "pete" `slice` (2,-1)   was the same as python's "pete"[2:-1]  But I just got stuck on how to represent this python case: "pete"[2:]  which returns "te"   This is why I was asking how to represent the End of a list so I could write something like   "pete" `slice` (2,End)
13:46:25 <mgsloan> I think I'll go for lots of small bytestrings then.  That way I don't have to worry about mutation as much either
13:46:31 <ddarius> petekaz: Actually, due to fromInteger, that should be no problem.
13:47:07 <petekaz> ddarius: I don't understand.
13:47:07 <ddarius> instance Num Start where fromInteger = StartValue
13:47:22 <ddarius> 2 gets parsed by Haskell as fromInteger 2
13:47:37 <swiert> nominolo: If I were you,  I'd talk to Ulf and send Thorsten an e-mail.
13:47:52 <petekaz> ddarius: neat.
13:48:06 <nominolo> swiert: i will.
13:48:10 <swiert> nominolo: there's plans to write a massive EU application to hire people to do research on DTLs. The sooner you express interest, the better.
13:48:18 <petekaz> ddarius: I'll give that a try.  Thanks!
13:48:51 * NekoIncardine completes his other two methods, tests, IT LOADS~
13:49:00 <ddarius> petekaz: Incidentally, Start (and End) would better be data Start = Start | StartValue !Int
13:49:06 <swiert> nominolo: and tell Thorsten you're doing an internship and want to come and visit.
13:49:08 <nominolo> swiert: DTLs FTW!!
13:49:20 <swiert> nominolo: definitely!
13:49:23 <hpaste>  NekoIncardine annotated "Simple Sudoku Solver (Beta 1000something)" with "Now with List grab functions!" at http://hpaste.org/6845#a1
13:49:37 <ddarius> "DTL" can be ambiguously interpreted...
13:49:52 <nominolo> ddarius: it's a TLA
13:49:55 <mattam> swiert: uhoh, bad. With the trunk it fails in Pretyping.search_guard... Will need some ML fix.
13:50:08 <nominolo> ddarius: *of course* it's ambiguous
13:50:15 <ddarius> nominolo: Yes, but it clashes with another possible TLA that's very close.
13:50:18 <swiert> mattam: ok. no rush - can probably work around it.
13:50:25 <kriptonet_> hello
13:50:27 <nominolo> ddarius: in my thesis ILP is overloaded
13:50:30 <NekoIncardine> Now... Am I correct in saying that I can use "do" multi-function chains for any function (as opposed to just main or IO functions)?
13:50:57 <Cale> NekoIncardine: no
13:51:02 <kriptonet_> I'm trying to compile hexpat, but c2hs won't process some includes on my Mac
13:51:06 <kriptonet_> any hints anyone ?
13:51:28 <elliottt> dons: ping
13:51:28 <lambdabot> elliottt: You have 1 new message. '/msg lambdabot @messages' to read it.
13:51:30 <Cale> NekoIncardine: Well, you can, technically, but do-notation constructs monadic values.
13:51:32 <dons> elliottt: pong
13:51:35 <elliottt> :)
13:51:36 <swiert> ddarius: how is it ambiguous?
13:51:36 <NekoIncardine> Cale: Hrm. That kills the easy route (replace a row in the array with the manipulated results of rowFind, repeat for Column and Group)
13:51:40 <dons> :)
13:51:45 <elliottt> dons: i just finished porting mtl to type families :)
13:51:48 <ddarius> swiert: Dynamically Typed Language
13:51:48 <dons> woot!
13:51:51 <kriptonet_> c2hs is failing because it can't process the leading whitespaces in preprocessor directives of header files
13:51:53 <dons> awesome mega fun elliottt
13:51:57 <swiert> ddarius: ah, of course.
13:51:57 <Heffalump> elliottt: interesting, what are the benefits?
13:51:58 <elliottt> http://code.haskell.org/~elliottt/code/mtl-tf
13:51:59 <lambdabot> Title: Index of /~elliottt/code/mtl-tf
13:52:02 <Cale> NekoIncardine: How would do-notation make that any easier?
13:52:05 <dons> elliottt: want to upload mtl-tf to code.h.o ?
13:52:09 <dons> very nice :)
13:52:10 <elliottt> Heffalump: no multi-param type classes
13:52:16 <Heffalump> oh, duh
13:52:19 <dons> elliottt: you should blog about this :)
13:52:20 <elliottt> :)
13:52:23 <dons> on eric's blog
13:52:23 <elliottt> haha
13:52:26 <Heffalump> you didn't run into any problems then?
13:52:28 <elliottt> dons: i'd need a blog :)
13:52:30 <ddarius> elliottt: Did you take the opportunity to spruce it up some?
13:52:36 <elliottt> Heffalump: no, very straight forward change
13:52:37 <dons> elliottt gets the prize for first library to use type families!
13:52:40 <NekoIncardine> Cale: Simply put, I could run one, then the next, then the next, and not worry about sliding all three pieces into one function.
13:52:43 <elliottt> ddarius: i haven't yet
13:52:49 <Heffalump> dons: only if he uploads it :-)
13:52:51 <Cale> elliottt: and you're keeping the broken version of ListT? ;)
13:52:53 <elliottt> hehe
13:52:53 * Heffalump has one using type families too
13:53:00 <elliottt> Cale: yes, it's still broken :(
13:53:02 <NekoIncardine> That means less head-poundng and more getting to completing this bloody thing x_x;
13:53:20 <Heffalump> but it has all sorts of hacks and workarounds for missing GHC stuff
13:53:27 <NekoIncardine> Let me ask a probably more relevent question, though...
13:53:29 <dons> elliottt: i think this is worth announcing on -cafe@ with some comparative discussion of the features
13:53:31 <Cale> NekoIncardine: But if each operation takes an array and produces an array...
13:53:40 <dons> it would be quite valuable
13:53:44 <elliottt> dons: it's pretty much the same, and i haven't tested anything yet
13:53:56 <dons> type instance ErrorType (Either e) = e -- nice
13:53:59 <elliottt> figured i'd do some more work before i announced it :)
13:54:00 <NekoIncardine> ... True. I'd be taking each one as the input for the next anyways, huh?
13:54:12 <mattam> swiert: It seems not to be the same bug as yours. Looking at your code, this may be because you assume patterns for the reference to destruct sigs, but they shouldn't, subset objects are automatically coerced to their underlying support type before pattern matching.
13:54:14 <dons> i like that it just looks more like haskell should look :)
13:54:18 <elliottt> hehe
13:54:31 <elliottt> it seemed easier to understand
13:54:34 <dons> yeah
13:54:35 <elliottt> especially the RWS stuff
13:54:51 <NekoIncardine> http://hpaste.org/6845#a1 <- A more relevent question: Am I correct in thinking that I could take the rowList function listed here, and use that to take a list, manipulate it using another function (removeNumber let's call it), then put the resultant list BACK into the array?
13:54:53 <elliottt> that really fell out as a simple case
13:55:11 <swiert> mattam: but if I leave out the "exist" I think I got a warning I was pattern matching on a sig...
13:55:13 <bugQ> petekaz: slice a b str = take b $ drop a str where l = length str
13:55:14 <swiert> mattam: let me try.
13:55:21 <bugQ> then replace b and a with things like (if b < 0 then l-b else b)
13:55:26 <bugQ> right?
13:55:44 <Nafai> dons: Hey, I found this by googling http://www.cse.unsw.edu.au/~dons/git/hsemail/ Is it just a mirror of the main hsemail or are there changes?
13:55:45 <lambdabot> Title: Index of /~dons/git/hsemail
13:55:48 <bugQ> um, that came out weird, sorry.
13:56:15 <Nafai> I've had a few issues trying to use hsemail downloaded from hackage, so if there were refinements elsewhere, I'm curious
13:56:16 <bugQ> slice a b str = take (if b < 0 then l-b else b) $ drop (if b < 0 then l-a else a) str where l = length str
13:56:27 <Cale> NekoIncardine: variables in Haskell are not the names of cells which you update with different values
13:56:33 <Cale> NekoIncardine: they are the names of values
13:56:37 <dons> Nafai: just a mirror
13:56:45 <petekaz> bugQ: I have this and it works well: slice1 xs (beg,end) = drop beg . take (if end < 0 then (length xs + end) else end) $ xs
13:57:04 <NekoIncardine> Cale: Rewording the last part: Then remake the array, replacing the relevent row with the resultant list?
13:57:11 <bugQ> oh right, it would be plus, not minus.
13:57:11 <Cale> NekoIncardine: Once a value is constructed, you don't change it. It is what it is. If you want something different, you define a new value :)
13:57:21 <swiert> mattam: found a constructor of an inductive type while a constructor of sig is expected.
13:57:27 <Nafai> dons: Thanks
13:57:27 <petekaz> bugQ: just trynig to find a neat way of representing the end of the list, so I can say give me from position 2 to the end.  slice "pete" (2,End)
13:57:34 <swiert> swiert: I'm sure I can work around it.
13:57:37 <mattam> swiert: oh right, because you wrap things in a pair ( , ) before pattern matching. You can do without
13:58:05 <Twey> > drop 2 "pete"
13:58:05 <lambdabot>  "te"
13:58:09 <swiert> mattam: yes, it looks a bit uglier.
13:58:10 <Cale> yeah, that sounds right :)
13:58:10 <Twey> petekaz: ^
13:58:13 <petekaz> Twey: thanks for the obvious!
13:58:16 <swiert> mattam: but it should be all right.
13:58:22 <Twey> Welcome :-P
13:58:49 <bugQ> yeah, I can't think of a good reason for that sort of thing...
13:59:00 <mattam> You mean it's uglier without the wrapping ??
13:59:23 <bugQ> let alone a way of implemeting it
13:59:43 <petekaz> bugQ: I suppose so.  The slice works well as it is.
14:00:02 <Heffalump> elliottt: so is it the same types, but replacements for the type classes?
14:00:17 <dons> Cale, we need to archive your reddit posts somehow
14:00:18 <Heffalump> i.e. will mtl and mtl-tf be compatible apart from having different typeclasses available?
14:00:20 <dons> they're too easy to lose
14:00:28 <Heffalump> dons: wiki page with URLs?
14:00:36 <dons> yeah, or wiki page with content..
14:00:40 <Cale> dons: What, like if I deleted my reddit account?
14:00:54 <dons> well, they mangle their database fairly regularly
14:00:59 <dons> and its hard to search for old posts
14:01:07 <ehird_> dons: profiles have lists of posts
14:01:08 <Heffalump> how about from his user page?
14:01:09 <ehird_> click 'Cale'.
14:01:13 <dons> ehird_: that's right
14:01:14 <dcoutts> @seen Lemmih
14:01:14 <lambdabot> I saw Lemmih leaving #haskell 4h 54m 6s ago, and .
14:01:14 <elliottt> Heffalump: yes
14:01:15 <swiert> mattam: nested patter matches don't look very nice in Coq, I think.
14:01:20 <dcoutts> @seen bringert
14:01:21 <lambdabot> I saw bringert leaving #ghc, #haskell.se and #haskell 12h 8m 58s ago, and .
14:01:21 <dons> its not really the same as a blog or wiki page
14:01:37 <swiert> mattam: the overhead with all the match-bla-with-end is a bit much.
14:01:47 <dons> Cale, if i moved things like this, http://reddit.com/r/programming/info/6emth/comments/c03mspn
14:01:53 <dons> to a Cale/* spot on the wiki, would you object?
14:02:02 <Cale> Not at all, go right ahead :)
14:02:34 <ehird_> dons: its exactly like a blag
14:02:34 <ehird_> ;)
14:02:41 <ehird_> + you can sort them
14:02:42 <ehird_> e.g. by score
14:02:56 <dons> it is. just one that's hard to search, subscribe to, index, and without titles
14:03:02 <Heffalump> and we can't trust reddit not to lose them
14:03:04 <ehird_> you can sort them, that makes it a bit easier
14:03:08 <dons> http://reddit.com/user/cgibbard/comments?sort=top is useful
14:03:11 <ehird_> Heffalump: about as much as you can trust haskell.org
14:03:18 <Heffalump> no, I know who runs haskell.org
14:03:29 <Heffalump> I trust them far more since I know what their motives are.
14:03:37 <dons> world domination
14:03:41 <ddarius> All the content back into the mid-early 90's is somewhere on their servers.
14:03:41 <Heffalump> precisely
14:03:57 <Heffalump> it is backed up, right? :-)
14:04:07 <dons> yeah :)
14:04:40 <NekoIncardine> One small side question: IS there a particular reason Haskell uses /= for not equals,as opposed to the usual !=?
14:05:13 <ehird_> NekoIncardine: /= resembles an = with a cross in
14:05:15 <mauke> usual?
14:05:20 <ehird_> which is the correct mathematical symbol for it
14:05:21 <kaustuv> World domination seems out of character for Haskellers, who would rather hide the world in a monad somewhere
14:05:22 <ehird_> @type (/=)
14:05:23 <lambdabot> forall a. (Eq a) => a -> a -> Bool
14:05:26 <NekoIncardine> mauke: At least, n most languages I've used.
14:05:34 <mauke> NekoIncardine: are they all derived from C?
14:05:56 <ehird_> mauke: Face it, most languages use !=
14:06:00 <ehird_> apart from the obscure ones
14:06:02 <NekoIncardine> mauke: I believe Prolog uses != as well
14:06:19 <NekoIncardine> ehird: Haskell isn't that obscure, it's just the exception in this area it seems
14:06:28 <Heffalump> many languages in common use today use !=
14:06:33 <mattam> swiert: Nested ? I can understand match .. with .. end might be a bit much, but using , to separate multiple patterns does not strike me as verbose. Or is it the | => delimiters ?
14:06:36 <NekoIncardine> I was just wondering if there was any technical reason for it (as opposed to aesthetic)
14:06:42 <Heffalump> NekoIncardine: no
14:06:45 <ehird_> http://reddit.com/info/2mx9o/comments/c2mxsh I hate threads like this
14:06:46 <dons> NekoIncardine: nope.
14:06:47 <hpaste>  NekoIncardine annotated "Simple Sudoku Solver (Beta 1000something)" with "Added removeValue" at http://hpaste.org/6845#a2
14:06:50 <dons> ?let (!=) = (/=)
14:06:50 <lambdabot> <local>:1:7:     Ambiguous type variable `a' in the constraint:       `Eq a' ...
14:06:51 <petekaz> ddarius: would that instance Num Start trick work only with literals in my haskell code?
14:06:54 <NekoIncardine> All right.
14:07:03 <audreyt> My first language uses <> instead of != and it's not particularly obscure :)
14:07:05 <dons> ?let (!=) :: Eq a => a -> a -> Bool ; (!=) = (/=)
14:07:06 <lambdabot> Defined.
14:07:17 <dons> > 1 != 2
14:07:17 <swiert> mattam: oh I agree. By nested I  mean match bla with pattern => match bla' with pattern' etc.
14:07:18 <lambdabot>  True
14:07:18 <ddarius> petekaz: Yes.
14:07:24 <petekaz> ddarius: okay, thanks.
14:07:28 <swiert> mattam: and not pattern matching on pairs.
14:07:33 <Twey> audreyt: Did it start with a V? *wince*
14:07:40 <mauke> pascal, ocaml, lisp
14:07:40 * NekoIncardine ponders if he has all the subfunctions needed for a solveTile method... And then ponders how to set *that* up.
14:07:56 <audreyt> Twey: no, it starts with a B :)
14:08:03 <audreyt> BASICA, that is
14:08:29 <ddarius> SML uses <>
14:08:39 <Twey> Haha, oh, OK.
14:08:42 <mauke> BASIÄ
14:09:09 <ehird_> python supports <>
14:09:14 <ehird_> but apparently that's Going Away(TM)
14:09:18 <NekoIncardine> Logic, concept #3: Take a tile and run solveTile on it. solveTile manipulates the Board input for a specified tile number input, marking that tile as Solved then changing every Unsolved in each direction of it, as well as in it's group. It then checks the row, column, and group for any tiles that now can be solved, and starts solveTile on that tile with the resultant board as input.
14:09:24 <mattam> swiert: well, you don't have to, you can match x, y, z with pâ, pâ, pâ => ... end. That's "telescope" matching.
14:09:31 * nominolo 's second language was x86-assembly :)
14:09:57 <swiert> mattam: ah. I didn't know that.
14:09:57 <NekoIncardine> nominolo: You are a higher caliber of programmer than I then. I could barely figure out MIPS assembly.
14:10:00 <ddarius> nominolo: Mine was kind of machine code/assembly.
14:10:29 <mattam> swiert: OCaml has that too, maybe other ML's.
14:10:34 <nominolo> my first language was Pascal.  in my book there was some sort of machine code (numbers!)
14:10:58 <Twey> x86 assembly is very easy to figure out, but very painful to do anything useful in :-P
14:11:06 <nominolo> so i told my dad i wanted to learn machine language.  but all i got was this assembler programming book
14:11:14 <swiert> mattam: yeah. I don't know enough ML to program in Coq :)
14:11:23 <ddarius> Twey: I like x86 assembly (at least for hand programming, compiling to it is a pain in the rear)
14:11:25 <mattam> hehe
14:11:54 <nominolo> hm, i should post my dirtiest x86 hack on my blog
14:11:57 <Twey> ddarius: You like x86 ASM *and* Haskell?  Gosh :-P
14:12:03 <mattam> Anyway, it's not really telescope matching as dependencies are not handled (yet).
14:12:03 <ddarius> Twey: And C++
14:12:17 <elliottt> dons: interestingly, mtl-tf works in ghc-6.8.2
14:12:21 <NekoIncardine> nominolo: IIRC, true assembly is basically a direct analogue to machine language, isn' tit?
14:12:34 <Twey> NekoIncardine: Yes
14:12:35 <NekoIncardine> At least that's how it was with MIPS assembly.
14:12:36 <ddarius> NekoIncardine: What's "false" assembly?
14:12:41 <Twey> Heh
14:12:43 <nominolo> NekoIncardine: yep. but i didn't know that when i was 13 or 14 :)
14:12:50 <bugQ> ddarius: preprocessed.
14:12:51 * therp wrote a novel brute force "cracker" in assembler when he was 14 :)
14:12:51 <NekoIncardine> ddarius: Assembly with more functions added that dont' directly analogue to machine language.
14:12:52 * Twey did.
14:13:01 <nominolo> NekoIncardine: you have some primitive macrology though
14:13:02 <therp> s/novel/novell/ (the network name)
14:13:11 <Twey> Usually.
14:13:26 <NekoIncardine> Hrm... Does the logic I wrote above seem sound?
14:13:34 <NekoIncardine> Now I just gotta figure out how to implement it, if it is. x-x;
14:13:47 <nominolo> x86 assembly is actually nice to write.  it's just hard to generate and clumsy to write an assembler for
14:13:48 <dons> elliottt: oh, that's interesting.
14:13:54 <dons> elliottt: hackage.haskell.org awaits! :)
14:14:02 <Twey> NekoIncardine: Must've missed it
14:14:13 <elliottt> dons: haha, ok.  i'll push it
14:14:13 <Twey> Oh, here we go.
14:14:27 <Twey> NekoIncardine: Yep, that's sound.
14:14:45 <NekoIncardine> Then the question becomes implementation...
14:15:08 <dons> elliottt: i think you should also announce it on -cafe@, so people can see some type families solving type programming problems in practice
14:15:57 <NekoIncardine> An alternative solution would be to make a doubly-recursive method: findTile takes a Board as input, and finds the first Tile of subtype Unsolved whose listlength is 1, using its location tuple as the input to a SEPARATE solveTile method that, when done, goes right back to findTile.
14:16:03 <wuxia> OT ... what do people use for issue tracking system? (somethiing that works with svn/git preferred)
14:16:26 <elliottt> dons: ok.  not sure i have a whole lot to say about it though :)
14:16:29 <mattam> swiert: We're currently thinking about adding epigram-style pattern-matching with support for inversion in the kernel.
14:16:38 <cjb> I think Trac works fine with SVN, but not GIT.
14:16:40 <elliottt> dons: it was a fairly straight forward change, like yav suggested
14:16:47 <dons> yep
14:16:49 <cjb> (I'd call it bugtracking, not issue tracking.)
14:17:02 <nominolo> elliottt: were you able to remove the overhead of monad transformers?
14:17:04 <NekoIncardine> That separates the problem into two disconnected halves which call each other in a loop. Technically MUCH less efficient, but by a linear factor (testing out of 81 tiles instead of 20)
14:17:13 <dons> nominolo: interesting idea
14:17:14 <NekoIncardine> Metaphorical loop, to clarify.
14:17:22 <elliottt> nominolo: how so?
14:17:25 <elliottt> dons: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mtl-tf-0.1
14:17:28 <lambdabot> http://tinyurl.com/6z8sfl
14:17:29 <nominolo> elliottt: no idea. ;)
14:17:29 <dons> nominolo: i wonder - has anyone looked at rules based optimisation, as the arrows lib does?
14:17:30 <bododo> hi folks :)
14:17:32 <dons> elliottt: woot!
14:17:34 <dons> elliottt++
14:17:34 <elliottt> nominolo: hehe, :)
14:18:00 <Cale> Now we just have to fix all the MTL bugs! :)
14:18:03 <nominolo> dons: i started looking into it a bit.  but you have to be careful with strictness
14:18:23 <dons> nominolo: yeah, they can be surprisingly subtle
14:18:24 <ddarius> elliottt, nominolo: Switch the things to continuation based implementations.
14:18:36 <nominolo> ddarius: then they become strict
14:18:45 <bododo> I'm learning haskell with the gentle introduction to, and I'm having some troubles understanding the 4th chapter (about types) should I worry?
14:18:46 <ddarius> nominolo: So you don't do it with all of them.
14:18:55 <Heffalump> it needs inline pragmas too, right?
14:18:58 <ddarius> Also, there is a lazy CPS transform.
14:19:05 <dons> bododo: what troubles are you having?
14:19:06 <Cale> bododo: The gentle intro isn't gentle.
14:19:07 <nominolo> ddarius: oh. got a link?
14:19:16 <bododo> Cale: yes :)
14:19:30 <bododo> dons: the "when in" thingy
14:19:31 <Cale> bododo: So don't worry. You might be able to take something from it, but it goes really fast.
14:19:34 <bododo> for example
14:19:49 <Cale> bododo: Usually people recommend the wikibook or YAHT
14:19:52 <Cale> @where wikibook
14:19:52 <lambdabot> http://en.wikibooks.org/wiki/Haskell
14:19:54 <ddarius> nominolo: Pretty much anything on the CPS transform should cover it.  It was well known from the beginning.  I had some stuff on it on the old wiki, but I don't think it ever got migrated.
14:19:55 <Cale> @where YAHT
14:19:55 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
14:20:13 <nominolo> ddarius: ok. i'll ask google
14:20:42 <bododo> Cale: yes i download it too, but and maybe i'm wrong, it seems like a set of reciepes, and I really want to understand the principles
14:20:49 <bododo> am i right?
14:20:52 <ddarius> nominolo: Though, it can effectively be looked at as whether you view functions as a -> m b or m a -> m b so I don't think it's particularly relevant here.
14:20:55 <audreyt> ne
14:20:57 <audreyt> oops, ww
14:21:06 <hpaste>  (anonymous) annotated "does'nt work of course" with "(no title)" at http://hpaste.org/6848#a1
14:21:30 <Cale> bododo: I don't know about that. It's not a perfect tutorial, but it should be enough to get you started.
14:21:42 <Cale> bododo: I wouldn't describe either of them as a set of recipes.
14:21:49 <nominolo> ddarius: well translating (s -> (a,s)) to (a -> s -> r) -> a -> s -> r makes it struct
14:21:51 <nominolo> *strict
14:22:28 <NekoIncardine> Okay... A question. I have a 2D Array of objects of a type. I want to find the FIRST item in the array that meets a particular condition, and return its location.
14:22:30 <ddarius> Which is usually what you want.
14:22:33 <NekoIncardine> How would I perform this?
14:22:37 <bododo> Cale: thanks for the advice! so, should I give up the gentle intro momentally and start over with the yaht?
14:23:04 <dons> Igloo, dcoutts: note that speakers get free ICFP registration
14:23:09 <NekoIncardine> bododo: I'd say yes, the YAHT was a little easier for me to figure out.
14:23:22 <Cale> bododo: Well, try it. Also, ask lots of questions here :)
14:23:33 <bododo> :) you guys! rock!
14:23:44 <bododo> so here's my first qustion, then :)
14:24:00 <dcoutts> dons, aye
14:24:11 <bododo> what does this means?http://rafb.net/p/1SGzY780.html
14:24:12 <lambdabot> Title: Nopaste - No description
14:24:44 <dons> dcoutts: if it goes well, we'll pay them next year :)
14:24:46 <mauke> it defines two variables, y and f
14:24:53 <mauke> then uses them in an expression
14:24:56 <dcoutts> dons, oooh
14:25:08 <dons> that's the plan anyway
14:25:18 <dcoutts> dons, since the main cost is the flight not the registration fee
14:25:19 <bododo> but what puzzles me actually is the "in f c + f d"
14:25:23 <dons> as they do for pretty much every other tutorial out there
14:25:28 <dons> dcoutts: yeah
14:25:36 <mauke> bododo: that's the body of the 'let'
14:25:45 <mauke> bododo: the place where the local variables are in scope
14:25:59 <Heffalump> do you have an idea of what tutorials you want?
14:26:01 * NekoIncardine looks thrugh some Array functions, but isn't finding anything quite like what he wants yet.
14:26:19 <bododo> i thought the body was the y   = a*b
14:26:26 <mauke> no, that's the definition of y
14:26:56 <mauke> and since it's a local definition, it's only visible in the "let"
14:27:01 <bododo> ok, so what are 'd' and 'c' ?
14:27:17 <mauke> they must be variables from somewhere else
14:27:20 <dons> Heffalump: i think the announce should give a decent overview. we're thinking OSCON-like howtos, combined with introductions for non-core ICFP people
14:27:21 <mauke> they're not defined here
14:27:35 <mauke> so are 'a' and 'b'
14:27:45 <bododo> wait, wiat... so this bloc actually computes f c + f d
14:27:58 <mauke> right
14:28:03 <bododo> given that f = x = (x+y)/y
14:28:12 <mauke> f x, not f = x :-)
14:28:24 <bododo> where y actually equals = a*b
14:28:30 <bododo> yes f x :)
14:28:48 <Twey> There's no dynamic scoping in Haskell, is there?
14:29:06 <mauke> (f c + f d) = ((c+y)/y + (d+y)/y) = ((c+(a*b))/y + (d+(a*b))/y)
14:29:11 <Twey> > let f = x * y in let x = 4; y = 5 in f
14:29:13 <lambdabot>  x * y
14:29:19 <Twey> Whew
14:29:27 <dons> Twey, only with funny features (implicit parameters sort of)
14:29:44 <mauke> > let f = ?x * ?y in f
14:29:44 <lambdabot>  Parse error at "?x" (column 9)
14:29:55 <dons> :t let f = ?x * ?y in f
14:29:57 <lambdabot> forall a. (Num a, ?y::a, ?x::a) => a
14:30:06 <Twey> O.O
14:30:12 <Twey> > let f = ?x * ?y in let x = 4; y = 5 in f
14:30:12 <lambdabot>  Parse error at "?x" (column 9)
14:30:24 <dons> i know of no current program that uses implicit parameters for state, fwiw
14:30:30 * Twey is slightly confused.
14:30:45 <mauke> Twey: > doesn't use glasgow extensions
14:30:45 <Twey> dons: I'm slightly worried as to why they exist :-P
14:30:47 <Twey> Ah
14:30:53 <bododo> sorry to bother you guys, is this correct then? http://rafb.net/p/zgI91c48.html
14:30:54 <lambdabot> Title: Nopaste - good example?
14:31:06 <dons> hey, its a research compiler, people get all sorts of weird things in there to explore language design
14:31:13 <mauke> bododo: that looks like valid code
14:31:22 <dons> comprehensive comprehensions are on a similar line -- just in to see if anyone likes them
14:31:22 <Twey> Fair 'nuff
14:31:33 <mauke> > let f = (^2) in f c + f d  -- shorter
14:31:34 <lambdabot>  c * c + d * d
14:31:35 <Twey> Comprehensive comprehensions?
14:31:47 <dons> ?go Comprehensive comprehensions
14:31:48 <bododo> mauke: great! so now I understand that let in thingy
14:31:48 <lambdabot> http://research.microsoft.com/~simonpj/papers/list-comp/index.htm
14:31:48 <lambdabot> Title: Comprehensive Comprehensions
14:31:53 <Twey> Thanks
14:31:59 <mauke> great success!
14:32:06 <dons> :)
14:32:14 <bododo> :) big! I'm in love!
14:32:17 <Twey> Hehe
14:32:50 <cjb> dons: I don't think that paper contains the syntax that got committed to GHC, though
14:32:54 <cjb> (but don't recall the details)
14:34:05 <Twey> dons: Well, that sounds interesting, if slow
14:34:35 <dons> "the way to approach such a comment is to ask for details (kind of like Socratic questioning)---not to challenge the competence of the writer (ad hominem)."
14:34:45 <dons> Cale, a nice little rule for #haskell when people complain :)
14:35:29 * ddarius had completely forgotten about Comprehensive Comprehensions.
14:35:53 <clanehin> At first I thought it was a joke, but I like it.
14:36:09 <bododo> just another one, and I'll study by myself :)
14:36:15 <bododo> http://rafb.net/p/qjr0Uf29.html ?
14:36:15 <lambdabot> Title: Nopaste - another good example?
14:36:30 <wuxia> where do I find the latest ghc-X11? I have 1.2.1, but xmonad wants 1.4
14:36:30 * bododo needs some cheerin' ;-)
14:36:58 <dons> go bododo !!
14:37:04 <dons> ?hackage X11
14:37:04 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/X11
14:37:06 <dons> wuxia: ^
14:37:12 <dons> wuxia: you building xmonad?
14:37:16 <wuxia> yeah
14:37:24 <wuxia> ubuntu gutsy doesn't support it
14:37:25 <bododo> :) thanks dons !
14:37:27 <dons> wuxia: cool :) drop by #xmonad
14:37:29 <wuxia> tried it on 8.04beta, and loved it
14:37:36 <dons> wuxia: yeah, hardy has a more recent setof packages
14:37:44 <dons> how long till the new ubuntu release?
14:37:48 * ddarius is still using Feisty...
14:37:51 <dons> (which will have xmonad 0.6 built in)
14:38:36 <wuxia> anyone here tried to code in yi?
14:38:44 <wuxia> if there was an implemenattio of vim in haskell, I'd switch over :-)
14:39:48 <bododo> thanks again guys! and have a nice day/night!
14:40:03 <dons> Cale, you should really get a blog. planet haskell is boring.
14:40:12 <dons> ever thought of writing about 'how to teach programming' ?
14:40:27 <wuxia> whoa, there's Hedi
14:40:36 <wuxia> I could be the one that makes it into Hvim
14:40:51 <hpaste>  ehird pasted "State, as a GADT" at http://hpaste.org/6852
14:42:28 <TomMD> @tell bododo Go bododo go! You rock!  Work those lambdas!
14:42:28 <lambdabot> Consider it noted.
14:43:51 <NekoIncardine> Hrm... Okay, check this loose theory bit out for a 2D array. If I take the fst of the HEAD tuple of the list defined by an assoc function on the whole array whch is run inside a filter, the result would be a location, correct?
14:44:05 <NekoIncardine> I didn't find a simpler method, so...
14:44:27 <elaforge> anyone know what the ___dso_handle symbol is?
14:44:38 <bugQ> really ugly.
14:44:43 <elaforge> I'm trying to get ghci to load a module that eventually touches a module that uses the ffi
14:45:02 <elaforge> and now it looks like I have to chase down every *.o and lib involved to get it to actually load
14:45:21 <elaforge> and some of them are OS X frameworks, about which I know little :/
14:45:23 <conal> has anyone here fiddled with hooking up lhs2TeX to jsMath, for lovely code in a web page?
14:45:37 <TomMD> elaforge: Did you use --make?
14:45:55 <elaforge> TomMD: I'm trying to load it with ghci
14:46:01 <TomMD> oh!
14:46:13 <elaforge> but yes, normally I use --make (and then staticlibs.a, but ghci doesn't understand those)
14:46:20 <elaforge> huh, weird, *now* it loads
14:46:33 <elaforge> I didn't change anything
14:47:02 <elaforge> what *are* the rules for ghci loading an FFI using module, anyway?
14:47:38 <hpaste>  NekoIncardine annotated "Simple Sudoku Solver (Beta 1000something)" with "added prototype findTile" at http://hpaste.org/6845#a3
14:47:56 <NekoIncardine> ^- Do I have the right idea for findTile, and how do I fix it to work? X.x
14:48:39 <ehird_> class (Gonad ((Gonad h) => g h)) => GonadTrans g     -- Why is this not valid? (Err, as for the naming: it's to not clash with Monad. WarmFluffyThing was a bit too long)
14:49:22 <elaforge> ehird_, "gonad transformers"... that sounds like spam already
14:49:33 <ehird_> elaforge: Yep
14:50:26 <elaforge> and I thought class contexts were restricted to "(A b c, D e f) => ..."
14:50:28 * BMeph thinks ehird_ is a bit desperate for others to play with his "Gonads"...
14:50:50 <ehird_> hahah
14:50:57 <ehird_>     Kind mis-match
14:50:57 <ehird_>     Expected kind `* -> *', but `g h' has kind `*'
14:50:57 <ehird_>     In the class declaration for `GonadTrans'
14:51:00 <ehird_> that's the problem, fwiw
14:51:06 <sohum> hey, I have a quick question
14:51:14 <ehird_> oh, wait
14:51:15 <ehird_> hmm
14:51:39 <ehird_> hmm
14:51:40 <ehird_> nope
14:51:59 <sohum> I can use guards so, using // for newline: f x // | x == 0 = exp // | otherwise = exp2
14:52:11 <sohum> can I do this in a lambda?
14:52:15 <mauke> you don't need newlines
14:52:52 <sohum> well, ok. but can you use guards in a lambda-ised function?
14:53:06 <Japsu> \x -> case x of ... :)
14:53:19 <mauke> > (\x | x == 0 -> 1 | otherwise -> 2) 3
14:53:19 <lambdabot>  Parse error at "|" (column 5)
14:53:23 <mauke> signs point to no
14:53:26 <Twey> > let f 0 = 1; f x = x * 2 in f 0
14:53:27 <lambdabot>  1
14:53:29 <Twey> > let f 0 = 1; f x = x * 2 in f 2
14:53:30 <lambdabot>  4
14:53:40 <Twey> With let, sohum
14:53:44 <sohum> well, the guards are more complex than that.
14:53:50 <Twey> Oh
14:53:52 <ehird_> > \x -> case x of _ | False -> "hello"; _ | True -> "world"
14:53:52 <lambdabot>  Add a type signature
14:53:56 <ehird_> > (\x -> case x of _ | False -> "hello"; _ | True -> "world") 2
14:53:57 <lambdabot>  "world"
14:53:57 <Twey> case is your friend, I guess.
14:53:59 <elaforge> > case (Just 4) of { Just n | n > 1 -> "hi" }
14:54:00 <ehird_> cool
14:54:00 <lambdabot>  "hi"
14:54:01 <ehird_> it wooorks
14:54:04 <BMeph> Correct. No guards for lambdas - you'll need to use case .
14:56:11 * NekoIncardine just waits, and looks at his solution more...
14:56:42 <EvilTerran> in some future iteration of haskell, we may be able to write that as (case of _ | False -> "hello" | True -> "world")
14:56:47 <BMeph> BRB - tinkering with the box...
14:56:50 <NekoIncardine> Hrm... I know it doesn't work, though I am convinced it is of the right form.
14:56:53 <sohum> what if I want to test different variables?
14:57:49 <sohum> > (\x,y,z -> case of x,y,z | x > y "hi" | y < z "nup" | otherwise "def" )
14:57:49 <lambdabot>  Parse error at ",y,z" (column 4)
14:57:50 <EvilTerran> sohum, unfortunately, that syntax will only work with single-parameter lambdas AFAIK
14:57:59 <EvilTerran> sohum, oh, right
14:58:12 <NekoIncardine> " findTile (Board x) = fst ( head ( filter (Unsolved _ && length Unsolved [a] == 1) ( assocs (x) ) ) ) " <- What I'm trying to do with the filter (which I think is the only problem here) is get it to filter to tiles of subtype Unsolved, whose lists are of length 1.
14:58:22 <EvilTerran> ?type (\x y z -> case () of _ | x > y "hi" | y < z "nup" | otherwise "def" )
14:58:23 <lambdabot> parse error on input `|'
14:58:37 <EvilTerran> ?type (\x y z -> case () of _ | x > y -> "hi" | y < z -> "nup" | otherwise -> "def" )
14:58:38 <lambdabot> forall a. (Ord a) => a -> a -> a -> [Char]
14:59:08 * sohum likes the lambdabot, btw.
14:59:22 <EvilTerran> also, some propose that "case () of _ | ... | ..." be re-writable to just "case | ... | ..."
14:59:36 <xahlee> there used to be a M bot in haskell... is it still available?
14:59:46 <EvilTerran> which'd make that (\x y z -> case | x > y -> "hi" | y < z -> "nup" | otherwise -> "def")
15:00:03 <sohum> > (\x,y,z -> case () of _ | x > y "hi" | y < z "nup" | otherwise "def" )
15:00:04 <lambdabot>  Parse error at ",y,z" (column 4)
15:00:12 <sohum> > (\x y z -> case () of _ | x > y "hi" | y < z "nup" | otherwise "def" )
15:00:13 <lambdabot>  Parse error at "|" (column 38)
15:00:20 <bugQ> need arrows.
15:00:36 <sohum> > (\x y z -> case () of _ | x > y -> "hi" | y < z -> "nup" | otherwise -> "def" )
15:00:37 <lambdabot>  <() -> () -> () -> [Char]>
15:00:43 <sohum> hmm
15:00:54 <sohum> what's the magic that's happening here?
15:00:58 <EvilTerran> that's the defaulting making everything ()
15:01:03 <EvilTerran> ?type (\x y z -> case () of _ | x > y -> "hi" | y < z -> "nup" | otherwise -> "def" )
15:01:04 <lambdabot> forall a. (Ord a) => a -> a -> a -> [Char]
15:02:21 <sohum> ?type ()
15:02:22 <lambdabot> ()
15:02:35 <sohum> ..that doesn't help. what does () signify?
15:02:43 <ddarius> @src ()
15:02:43 <lambdabot> data () = ()
15:03:10 <hpaste>  ehird pasted "how come the runStateT's bind case doesn't work? error is very vague" at http://hpaste.org/6853
15:03:11 <bugQ> absolutely nothing.
15:03:17 <ehird_>     Couldn't match expected type `(->) s' against inferred type `(,) s'
15:03:18 <ehird_> is the error
15:03:19 <EvilTerran> sohum, it's the type with only one value
15:03:28 <EvilTerran> () :: ()
15:03:30 <EvilTerran> and nothing else
15:03:35 <ddarius> s/one/one non-bottom/
15:03:50 <atsampso1> NekoIncardine: list comprehensions are handy for doing a pattern match across a list -- [doSomethingWith a | Unsolved [a] <- assocs x] (and since you're pattern-matching with [a], it'll only match lists with one item in anyway)
15:04:26 <sohum> so () matches forall a. a?
15:04:32 <ddarius> No.
15:04:35 <EvilTerran> > ( {- i expect -} ) :: ( {- this to work -} )
15:04:36 <lambdabot>  ()
15:04:44 <EvilTerran> sohum, no, it's a non-polymorphic type
15:04:48 <ddarius> It is equivalent to exists a. a though.
15:04:48 <EvilTerran> it's just ()
15:04:53 <EvilTerran> pronounce it Unit if you like
15:05:07 <EvilTerran> data Unit = Unit -- equivalent
15:05:22 <ddarius> You can also view it as the 0-tuple.
15:05:25 <EvilTerran> well, data Unit = Unit deriving (Eq, Ord, Show, Read, Bounded, Enum, ...)
15:06:02 <EvilTerran> as lambdabot said above, it's as if someone wrote "data () = ()". well, if that were valid code.
15:06:20 <sohum> it's starting to make sense now... so case () in _ matches ... every unit in the expression?
15:06:28 <EvilTerran> no
15:06:38 <mauke> sohum: you could also use case 42 of _ ...
15:06:39 <tromp> 224000/2500
15:06:44 <EvilTerran> you could equally say "case True of _" or "case undefined of _" or ...
15:06:48 <tromp> > 224000/2500.0
15:06:49 <lambdabot>  89.6
15:06:54 <atp> a question about ghc's lightweight threads: if I have a thread created with forkIO, and then I do a blocking call via FFI (for example, one that waits on an application to complete), it will cause all threads to halt until the block lifts, correct?  because they aren't preemptive?
15:06:57 <EvilTerran> the pattern _ means "anything, i don't care"
15:07:07 <tromp> > 90 * 3.80 * 1.333
15:07:08 <lambdabot>  455.88599999999997
15:07:22 <EvilTerran> so we're making this () value to match against, and then ignoring what value it might be, because we don't care
15:07:25 <kpreid> the keyword for that "case | ... | ..." syntax ought to be "cond" instead :-)
15:07:41 <EvilTerran> it's just a bit of syntactic ugliness so we can use guards somewhere where we couldn't otherwise
15:07:42 <sohum> oh, so it's basically a way to force the compiler to evaluate the guards within a case?
15:07:48 <atsampso1> or just "if"?
15:07:57 <ddarius> > case undefined of _ -> 3
15:07:58 <lambdabot>  3
15:08:11 <EvilTerran> ... not to force evaluation, no. just to allow guards within a lambda, or elsewhere where you can't have guards
15:08:13 <kaustuv> atp: are you using -threaded?
15:08:28 <sohum> right. I think I understand now.
15:08:33 <atp> kaustuv: no, i'm just using Control.Concurrent in ghci for now
15:08:33 <ddarius> sohum: () is just a trivial value because you need to perform a case on something.
15:08:42 <atp> kaustuv: so no special flags passed to ghci
15:08:43 <sohum> thank you all -- you've been a big help.
15:08:47 <atp> kaustuv: err, ghc
15:08:48 <dons> atp, you'll need the threaded runtime
15:08:48 <kaustuv> "Using GHC without the -threaded option, all foreign calls will block all other Haskell threads in the system, although I/O operations will not. With the -threaded option, only foreign calls with the unsafe attribute will block all other threads"
15:08:52 <EvilTerran> atsampso1, that would work, yeah. the trouble with introducing "cond" as per kpreid's suggestion is that introducing new keywords upsets things
15:08:59 <dons> atp, so compile with -threaded, then IO calls run in the IO manager thread
15:09:04 <dons> while the other threads can make progress
15:09:16 * ddarius has used cond as an identifier more than once.
15:09:21 <EvilTerran> exactly
15:09:22 <kpreid> EvilTerran: I know
15:09:37 <atp> dons: so with -threaded, forkIO uses OS threads?
15:09:55 <mauke> atp: no :-)
15:10:06 <EvilTerran> kpreid, i figured, from the smiley. but i thought it was worth pointing out to the folks at home, as it were.
15:10:08 <atp> hm... so what's the magic here, then?
15:10:41 <mauke> atp: the thread manager schedules M haskell threads to run on N OS threads
15:10:47 <ddarius> atp: The RTS will multiplex groups of forkIO threads over OS threads.
15:10:52 <atp> ah, i see
15:11:04 <atp> that's pretty neat
15:11:33 <atp> so without -threaded, does the application actually run single threaded and then just interleave?
15:11:35 <elaforge> atp: if you really want an OS thread, there's forkOS
15:11:40 <EvilTerran> kpreid, that's why i didn't address you directly :)
15:11:46 <atp> elaforge: i don't, i'm just trying to understand how it works
15:11:47 <bugQ> by what construct is (case () of _ | .. -> .. | .. -> ...) made possible?
15:11:59 <mauke> atp: yes
15:12:07 <atp> mauke: neat. :)
15:12:10 <mauke> without -threaded it's basically a select() loop
15:12:24 <mrd> bugQ: er, it's just case
15:12:24 <atp> yeah, that's what i figured
15:12:42 <mrd> with guards
15:12:45 <atp> which is most likely how i'd write this program if i were writing it in C... os threads are overkill
15:13:05 <NekoIncardine> atsampsol: Sorry for the delayed response... I'm not precisely sure what you mean by that. Do you mean "findTile (Board x) = fst (head [doSomethingWith a | Unsolved [a] <- assocs x]) will take the first of the head tuple out of the assocs-form Array?
15:13:10 <bugQ> I meant as opposed to (case () of {_ | .. -> ..; _ | .. -> ...})
15:13:21 <atp> haskell's light weight threads are pretty much the win... combined with the STM monad... it's really a dream
15:13:26 <mauke> atp: that's how you can easily spawn 100,000 threads in haskell and it still runs fine
15:13:27 <mrd> bugQ: layout?
15:13:49 <bugQ> mmkay...
15:13:54 <NekoIncardine> I'm just... Not sure what you mean there, particularly since the list will be tuples-based.
15:13:54 <mrd> | separation isn't layout dependent i think
15:14:12 <mrd> so i don't think it matters whether you use braces or not
15:14:30 <bugQ> that's not it, either...
15:14:53 <bugQ> (case () of _ | .. -> ..; _ | .. -> ...) vs (case () of _ | .. -> .. | .. -> ...)
15:15:13 <bugQ> braces or no
15:15:31 <levi> So, I have a data type that looks like data X = Y { getVal :: Int } | Z { getName :: String,  getVal :: Int }  and I want to be able to do a case without having to specify the number of args to the type constructor.  It this possible?
15:15:44 <mrd> > let a=1;b=2 in b
15:15:45 <lambdabot>  2
15:15:48 <mrd> that's ok
15:15:57 <atsampso1> NekoIncardine: you've got a list of whatever-type-Unsolved-is that's been returned by "assocs x", and you're trying to find all the items in it that match the pattern "Unsolved [a]"
15:16:07 <mrd> on one line
15:16:14 <kpreid> bugQ: in http://www.haskell.org/onlinereport/exps.html section 3.13
15:16:15 <lambdabot> Title: The Haskell 98 Report: Expressions
15:16:53 <kpreid> bugQ: the rule 'gdpat' allows repetition
15:17:31 <atsampso1> NekoIncardine: one way to do that is to use a list comprehension, which applies a pattern match to all the items in a list -- see section 2.4.1 of http://www.haskell.org/tutorial/goodies.html for some examples
15:17:31 <lambdabot> Title: A Gentle Introduction to Haskell: Values and Types
15:17:47 <bugQ> OK, so it's just an added syntax?
15:18:08 <bugQ> wait.
15:18:11 <kpreid> bugQ: well, it's defined as part of the fundamental syntax.
15:18:23 <monochrom> Everything is added.
15:18:38 <atsampso1> (so, in those examples, when it says "y <- xs" on the right-hand side, it's matching the pattern "y" (which matches anything) against all the items in xs; you can use something like "Unsolved [a]" as the pattern to do what you want)
15:19:51 <NekoIncardine> Hrm...
15:20:40 <ehird_> Is there a
15:20:45 <ehird_> 'functor tutorial' anywhere?
15:21:06 <mauke> @src Functor
15:21:06 <lambdabot> class  Functor f  where
15:21:06 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
15:21:13 <mauke> that's it
15:21:15 <NekoIncardine> findTile (Board x) = fst (head [ a | Unsolved [a] <- assocs x, length a == 1]), then?
15:21:27 <ddarius> Plus fmap id = id and fmap (f . g) = fmap f . fmap g
15:21:57 <ehird_> mauke: Unhelpful though, heh.
15:22:00 <ehird_> @type mplus
15:22:02 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
15:22:04 <mauke> why?
15:22:08 <ehird_> @type mzero
15:22:09 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
15:22:31 <ddarius> ehird_: That class and the laws I gave are the entire definition of functors.
15:22:52 <Cale> ehird_: There's not enough to them to really justify a whole tutorial.
15:23:16 <atsampso1> NekoIncardine: what's the definition of the type that Unsolved is a constructor for?
15:23:37 <Twey> data Tile = Solved Integer | Unsolved [Integer]
15:23:45 <Cale> ehird_: They're essentially parametric datatypes for which you can apply a function to all the values held of that given parameter.
15:23:51 <NekoIncardine> http://hpaste.org/6845#a3 <-  Line 7. (Thanks Twey.)
15:23:53 * ddarius wonders if the second functor law is a consequence of naturality in this case.
15:24:02 <atsampso1> NekoIncardine: then it's nearly right ;)
15:24:08 <NekoIncardine> Nearly...
15:24:11 <ddarius> fmap id = id means that fmap won't change the structure.
15:24:17 <Cale> ddarius: almost, but not quite
15:24:26 <kaustuv> I can imagine an interesting functor tutorial that discusses the Kan extensions.
15:24:26 <atsampso1> NekoIncardine: when you say "Unsolved [a]" as a pattern match, that matches an Unsolved with an argument that's a list of a single Integer, and binds a to that integer
15:24:43 <ddarius> (So, for example, reverse . map is not an acceptable implementation of fmap for lists)
15:24:45 <NekoIncardine> ... Ah.
15:24:54 <Cale> ddarius: ah, with the other law...
15:25:00 <Cale> hmm
15:25:11 <atsampso1> NekoIncardine: so the "length a == 1" and "head" are redundant (and it's a bit odd to be applying fst to an Integer, but maybe you have an odd definition of fst?)
15:25:14 <bos> anyone pondering the idea of giving a talk or tutorial at defun?
15:25:32 <NekoIncardine> atsampsol: No, the assocs x list returns tuples.
15:25:40 <NekoIncardine> So I'm trying to find the fst half of that tuple (which is the array location)
15:25:45 <NekoIncardine> Unless I misread that
15:26:16 <atsampso1> so assocs returns [(Int, Tile)]?
15:26:32 <NekoIncardine> [((Int,Int),Tile)] to be more precise
15:26:37 <NekoIncardine> That (Int,Int) is what I want.
15:26:43 <bos> @where mtl-tf
15:26:43 <lambdabot> I know nothing about mtl-tf.
15:26:54 <bos> @where+ mtl-tf http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mtl-tf-0.1
15:26:55 <lambdabot> Okay.
15:27:02 <bugQ> ok, thanks, atsampso1.  if that's the case, then I don't see any reason not to allow the (case | a > b -> ..) syntax, too.
15:27:15 <NekoIncardine> atsampso1++
15:28:14 <ehird_> Hmm. You can't have a ListT that doesn't require some kind of decorator, right?
15:28:26 <NekoIncardine> So given that... Hrm.
15:28:28 <ehird_> So there can't be a ListT such that (ListT Identity) can be used in place of []
15:28:28 <atsampso1> NekoIncardine: so you could use a pattern like (pos, Unsolved [_]) to match a tuple of the position (which'll get bound to pos) and an Unsolved containing a single Integer
15:28:48 <NekoIncardine> ... I'm not entirely sure what you mean there. o_O
15:29:26 <NekoIncardine> Hrm...
15:30:10 <Baughn>  I am [...] suggesting that lazy naturals be the standard numeric type in Haskell, [..] by not going that way we have paid a cost in terms of elegance. <-- Huh
15:30:12 <NekoIncardine> Starting with the list comprehension: [pos | (pos, Unsolved [_]) <- assocs x], then?
15:30:22 <atsampso1> NekoIncardine: if you say [pos | (pos, Unsolved [_]) <- assocs x] then that'll return a list of all the positions that correspond to an Unsolved [_] -- so "head" that, and you'll get the first position which correspond to an Unknown ... ah, I see you've got it ;)
15:30:24 <kaustuv> Apropos tutorials, someone should write a tutorial for the various monad tutorials
15:30:48 <NekoIncardine> Then I don't even NEED the fst... Clever.
15:30:55 <ehird_> Baughn: I am [...] suggesting that Haskell should be impractical for real use
15:30:56 <atsampso1> yup, I like pattern matching :)
15:31:41 <Baughn> ehird_: It would have applications for retroactive computing, though
15:31:57 <NekoIncardine> The only thing I'm not sure about, is if Unsolved [_] would really find only the length 1 cases... And nowthat I think about it there's a way for me to test for that.
15:32:14 <SamB> I am [...] suggesting the use of the "default" keyword
15:32:29 <ehird_> I am [...] suggesting the removal of Monads as they are confusing
15:32:37 <atsampso1> you can play with that sort of thing in the interpreter:
15:32:41 <atsampso1> > [x | [x] <- [ [1], [1,2], [1,2,3] ]]
15:32:42 <lambdabot>  [1]
15:33:13 <bugQ> I think it's just the monad tutorials that are confusing.
15:33:27 <NekoIncardine> Huh.
15:33:37 <Riastradh> What are you folks all quoting?
15:33:41 <NekoIncardine> Unintuitive, but I guess it works. o_O
15:34:04 <mauke> @undo [x | [x] <- [ [1], [1,2], [1,2,3] ]]
15:34:05 <lambdabot> concatMap (\ a -> case a of { [x] -> [x]; _ -> []}) [[1], [1, 2], [1, 2, 3]]
15:34:18 <aFlag> I don't get it, what is it that the seq function do? What's it for?
15:34:21 * NekoIncardine is one who is opposed to removing functions from a programming language. Maybe not DISCUSSING them, but in most modern contexts it is generally okay to leave them in for legacy support. >>
15:34:22 <mauke> @. pl undo [x | [x] <- [ [1], [1,2], [1,2,3] ]]
15:34:22 <lambdabot> (line 1, column 29):
15:34:22 <lambdabot> unexpected "{"
15:34:22 <lambdabot> expecting variable, "(", operator or ")"
15:34:30 <Baughn> aFlag: Forcing strict evaluation
15:34:34 <bugQ> I am [...] quoting the very most reputable publications.
15:35:06 <aFlag> Baughn, that's what hoogle says, but I don't see it
15:35:11 <aFlag> could you give me an example?
15:35:14 <Baughn> @. pl undo do [x] <- [[1],[1,2],[1,2,3]]; return x
15:35:14 <lambdabot> (line 1, column 47):
15:35:14 <lambdabot> unexpected "{"
15:35:14 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
15:35:33 <Baughn> @. undo do [x] <- [[1],[1,2],[1,2,3]]; return x
15:35:33 <lambdabot> Plugin `compose' failed with: Unknown command: "do"
15:35:35 * NekoIncardine thinks... What else remains. findTile, then solveTile...
15:35:35 <atsampso1> you've lost a ] there
15:35:43 <atsampso1> @. undo do [x] <- [[1],[1,2],[1,2,3]]]; return x
15:35:43 <lambdabot> Plugin `compose' failed with: Unknown command: "do"
15:36:25 <Baughn> @src foldl'
15:36:26 <lambdabot> foldl' f a []     = a
15:36:26 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:36:29 <Baughn> aFlag:  ^-- example
15:36:31 <mauke> > (\x -> 42) (1 `div` 0)
15:36:32 <lambdabot>  42
15:36:36 <mauke> > (\x -> x `seq` 42) (1 `div` 0)
15:36:36 <lambdabot>  Exception: divide by zero
15:37:29 <aFlag> hm, so it evaluates a' right away and the evaluated value is passed to the recursive call to foldl'?
15:37:42 <reltuk> anyone here make use of the GHC_PACKAGE_PATH feature?
15:37:48 <ehird_> @src [] (>>=)
15:37:48 <lambdabot> xs >>= f     = concatMap f xs
15:37:53 <ehird_> err
15:37:59 <ehird_> @src ((->) t) (>>=)
15:37:59 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
15:38:05 <ehird_> @src ((->) r) (>>=)
15:38:05 <lambdabot> Source not found. Wrong!  You cheating scum!
15:38:07 <ehird_> bah
15:38:16 <Baughn> aFlag: An expression like "a seq b" just says "before you need the value of b, you must first evaluate a"
15:38:22 <reltuk> I'm trying to use it to build parsec, but it's complaining about mtl missing...ghc-pkg list with the same GHC_PACKAGE_PATH shows mtl as being an available package
15:38:25 <mauke> @src (->) (>>=)
15:38:26 <lambdabot> f >>= k = \ r -> k (f r) r
15:38:31 <aFlag> Baughn, I see
15:38:32 <aFlag> thanks
15:39:01 <Baughn> aFlag: ..well, more like "c = a `seq` b" <-- c = b, but you can't have b before a has been evaluated
15:40:08 <Baughn> aFlag: That can be used to shut down space leaks, but it might be hard to understand. On the other hand, if you replace seq with par, what happens is that you're saying "when b is needed, you should start evaluating a /in parallel/ with the rest of the program"
15:40:09 <hpaste>  NekoIncardine annotated "Simple Sudoku Solver (Beta 1000something)" with "Finished findTile, devised form for solveTile." at http://hpaste.org/6845#a4
15:40:19 <Baughn> aFlag: Which is often more useful
15:40:29 <ehird_> what is the function monad useful for
15:40:35 <NekoIncardine> Whoo! If I have my thinking correct here, this is basically the last portion of this!
15:41:00 <Baughn> aFlag: Of course, "a `par` b" will evaluate to b before a has been evaluated - and a may /never/ in fact be evaluated if the RTS keeps deciding to do other things instead
15:42:21 * Baughn wonders if "par a b = unsafePerformIO $ forkIO $ evaluate a `seq` b" would be correct. Probably not.
15:43:29 <ehird_> the function monad is really confusing actually
15:43:30 <ehird_> :D
15:44:42 <lament> all monads are confusing!
15:45:05 <Baughn> Now, now. IO is simple, State is simple, Reader/Writer are simple..
15:45:48 <lament> right, the more the "monadic semicolon" approaches the usual "imperative semicolon", the more comprehensible the monad
15:45:49 <ehird_> foo = do a <- pred; (a*)     ==      foo x = pred x * x
15:45:50 <sieni> lament: don't lament like that
15:45:52 <ehird_> i worked that out on paper
15:45:52 <Baughn> Array.ST is simply evil, but still simple
15:45:52 <ehird_> so
15:46:06 <aFlag> Baughn, hm, I didn't know about that par thing, it seems like a nice way to explore paralelism
15:46:09 <ehird_> but i don't see why it's a useful monad of any sorts
15:46:31 <dons> `par` is also cheaper than forkIO -- it generates sparks , which may or may not get run in a new thread
15:46:51 <ddarius> Baughn: Why would a `par` b evaluate to b before a has been evaluated?
15:46:52 <mauke> ehird_: it's Reader
15:47:06 <ehird_> I .. never learned Reader
15:47:06 <Baughn> ddarius: If it couldn't, how would it be parallelism?
15:47:07 <ehird_> :(
15:47:21 <mauke> @src MonadReader
15:47:21 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
15:47:24 <ehird_> But I see. Yes, Reader appears to be (->) + newtype
15:47:31 <ehird_> But why>?
15:47:38 <aFlag> is par often used?
15:47:39 <mauke> what
15:47:50 <dons> aFlag: its growing in use -- it was kind of pointless before the smp runtime
15:47:57 <ddarius> Baughn: Nothing requires that they actually run in parallel and the difference would not be observable.
15:47:57 <aFlag> hm
15:47:59 <dons> but we need more experience understanding the cost model
15:48:19 <Baughn> ddarius: Oh. I meant "may", not "will"
15:48:20 <cjb> n
15:48:22 <cjb> oops
15:48:29 <aFlag> what's smp runtime? Before ghc wouldn't create different threads or something like that?
15:48:59 <ehird_> hmm
15:49:00 <Baughn> aFlag: OS threads, correct. It still had threads, to deal with IO
15:49:05 <NekoIncardine> solveTile (Board x) (y,z) =  solveTile ( (BOOP) findTile (BOOP) ) <- "BOOP" is a placeholder for a set of inner logic that I'm trying to figure out if there is a way for me to avoid runnig twice. Any suggestions?
15:50:08 <NekoIncardine> http://hpaste.org/6845#a4 <- For the method formats, which are near the bottom.
15:50:11 <Olathe> @pl \BOOP -> solveTile ( (BOOP) findTile (BOOP) )
15:50:11 <lambdabot> solveTile . join ($ findTile)
15:50:41 <NekoIncardine> ... Erm...
15:50:41 <Olathe> @unpl solveTile . join ($ findTile) BOOP
15:50:41 <lambdabot> (\ d -> solveTile (((\ a -> a findTile) >>= \ e -> e) BOOP d))
15:50:45 <Olathe> Ack
15:50:46 <NekoIncardine> Oh!
15:50:47 <Baughn>  > (do a <- (*2); b <- (+3) return $ a . b) 17
15:51:07 <NekoIncardine> So solvetile . join ($ findTile) BOOP where BOOP is the inner logic that defines the new Board that both use?
15:51:26 <NekoIncardine> ... Except then wouldn't solveTile need to be (Integer,Integer) -> Board? Not that that isn't trivial, I'm just clarifying.
15:51:47 <kaustuv> To correct a possible subtle error from earlier, a `seq` b does not mean that a will be evaluated necessarily before b. If you need that guarantee, use Control.Parallel.pseq.
15:55:33 <dons> kaustuv: btw, welcome! i'm not sure i've seen you in here before :)
15:55:52 <ehird_> @hoogle (Eq a) => a -> [a] -> Int
15:55:53 <lambdabot> No matches, try a more general search
15:55:59 <ehird_> Hmph
15:56:19 <kaustuv> dons: thanks for the welcome.
15:58:09 <ehird_> @hoogle [a] -> Int -> Maybe a
15:58:09 <lambdabot> No matches, try a more general search
15:58:31 <dons> ehird_: safeIndex?
15:58:37 <dons> :t lookup
15:58:37 <ehird_> @type safeIndex
15:58:43 <lambdabot> Not in scope: `safeIndex'
15:58:43 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
15:58:45 <dons> :t find
15:58:46 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
15:58:54 <Olathe> @hoogle [a] -> Int
15:58:54 <lambdabot> Prelude.length :: [a] -> Int
15:58:54 <lambdabot> Data.List.length :: [a] -> Int
15:58:55 <dons> :t elemIndex
15:58:56 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
16:00:04 <ehird_> @type (!!)
16:00:06 <lambdabot> forall a. [a] -> Int -> a
16:00:08 <ehird_> I really just want that in Maybe
16:00:34 <dbpatterson> sclv: hvacs not building - erroring in fastcgi (type mixup for bytestrings)... ideas?
16:00:35 <hpaste>  dbpatterson pasted "hvac build error - fastcgi" at http://hpaste.org/6854
16:00:35 <dons> ?src (!!)
16:00:35 <lambdabot> xs     !! n | n < 0 = undefined
16:00:35 <lambdabot> []     !! _         = undefined
16:00:35 <lambdabot> (x:_)  !! 0         = x
16:00:35 <lambdabot> (_:xs) !! n         = xs !! (n-1)
16:00:44 <dons> so change those undefineds to Nothing :)
16:01:40 <sclv> oy -- it was before?
16:01:44 <ehird_> hmm
16:01:48 <dbpatterson> yeah different ghc version
16:01:51 <ehird_> :)
16:01:56 <Baughn> Hum. I've understood the reader monad for /ages/
16:01:58 <sclv> ah -- did you upgrade bytestring?
16:02:06 <dbpatterson> built on 6.8.2.20080221
16:02:06 <Olathe> @version
16:02:06 <lambdabot> lambdabot 4p603, GHC 6.8.2 (Linux i686 2.40GHz)
16:02:06 <lambdabot> darcs get http://code.haskell.org/lambdabot
16:02:10 <Baughn> And yet, somehow, (->) never clicked until someone pointed out that they're the same thing. :/
16:02:18 <dbpatterson> did not build on 6.9.20080218
16:02:25 <dbpatterson> no I am using the same bytestring version
16:02:45 <dbpatterson> the min required by the cabal file (thought that would be the best idea.. as it must be the one you used originally) 0.9.0.1
16:02:48 <Peaker> Baughn, what's the (->) transformer?
16:03:13 <sclv> your ghc-pkg system itself -- it all has one bytestring, or there are multiple ones floating about?
16:03:36 <slowriot> Do you guys know of any purely functional implementations of computational geometry algorithms?
16:03:45 <slowriot> Specifically, scanline algorithms.
16:03:47 <dbpatterson> sclv: mm.. 2 - 0.9 and 0.9.0.1
16:03:59 <dbpatterson> is it because old libraries were built with the old version?
16:04:01 <sclv> that's the rub -- you have some libs built against one and some against the other.
16:04:14 <dbpatterson> I rebuilt cgi... ideas of what else to rebuild?
16:04:33 <dons> slowriot: good question. sigfpe might know
16:04:53 <ehird_> @faq
16:04:53 <Baughn> Peaker: Good question. I suppose there should be one..
16:04:53 <lambdabot> The answer is: Yes! Haskell can do that.
16:04:57 <ehird_> instead of Haskell -> Oleg
16:05:00 <sclv> i'd actually start over and get rid of the new bytestring and keep everything to the one that you started with -- if you have to change the cabal reqs, so be it.
16:05:00 <ehird_> Haskell -> sigfpe!
16:05:08 <Baughn> Peaker: Asking things like that, you'd be better off asking the channel. ;)
16:05:16 <dbpatterson> sclv: so it will work with just 0.9?
16:05:30 <sclv> can't see why not... i don't think the api changed.
16:05:33 <dbpatterson> oh, and for cabal reqs, I think it needs to be just base >=3 (not 3.0.0.0)...
16:06:05 <Baughn> Peaker: http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Reader.html#t%3AReaderT <-- Well, there we go
16:06:06 <lambdabot> http://tinyurl.com/ona24
16:06:18 <sclv> funny that the hardest part of writing a library always feels like getting the build stuff right...
16:06:22 <Peaker> Baughn, ReaderT I know, is it _literally_ the same as (->) ?
16:06:23 <ehird_> @type forM
16:06:24 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
16:06:26 <ehird_> @type forM_
16:06:27 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
16:06:29 <Peaker> Baughn, can't be, with the Reader module symbols
16:06:52 <Peaker> I haven't seen any use of (->) as a monad yet
16:07:01 <sclv> working, btw, on clearing out that FastCGI binding entirely and just relying on the standard package -- there's that issue with the monad transformer stacks that I was just posting on proggit about.
16:07:06 <audreyt> hm. is there such a thing as fzip (on, say, Traversable)?
16:07:37 <sclv> audreyt: that would require your two traversables had the exact same structure, no?
16:07:38 <Baughn> Peaker: It /works/ the same way, so it's at least isomorphic. Could be a newtype.
16:07:39 <audreyt> as in, sequenceA `fzip` sequenceB :: Sequence (a, b)
16:07:46 <sclv> there's a gzip
16:08:07 <ddarius> @src Reader
16:08:07 <lambdabot> Source not found. There are some things that I just don't know.
16:08:11 <ddarius> :t runReader
16:08:12 <lambdabot> forall r a. Reader r a -> r -> a
16:08:13 <conal> or liftA2 (,)
16:08:13 <ddarius> :t runReaderT
16:08:14 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
16:08:21 <sclv> http://www.cs.vu.nl/boilerplate/library/Data.Generics.Twins.html
16:08:38 <audreyt> liftA2 is it. thanks!
16:08:39 * Igloo sighs, as he hits darcs.haskell.org's throttling...from localhost  :-)
16:08:41 <Baughn> Peaker: http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-Reader.html#Reader <-- Yep, a newtype. Not that they had much choice, I suppose.
16:08:41 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/6crx7c
16:09:03 <slowriot> dons: I've spent a little time trying to implement one in F#, but I've been busy with other schoolwork. I chose F# because it has nice support for GUI stuff (.NET stuff) that I'm familiar with. The F# library's Set class wasn't versatile enough for me needs, so I'm going to have to scrap the idea.
16:09:16 <conal> :)
16:09:31 <dons> Igloo: 8 more weeks till the new hosting
16:09:34 <slowriot> It would probably be really easy with haskell, but I'm too clumsy with haskell, and don't have enough time to learn it better.
16:09:38 <dbpatterson> sclv: success! (or at least build success)
16:09:49 <dons> Igloo: so just hang on. we'll be on some serious network bandwidth in the new place
16:10:00 <sclv> its haskell -- if it compiles, it works. :-)
16:10:07 <sclv> maybe.
16:10:09 <dbpatterson> another problem though - the 404 workaround (h |\ (\anything -> renderf (tmpl "page")))
16:10:16 <dbpatterson> yeah, but you ar elinking to c libs..
16:10:18 <dbpatterson> anything can happen
16:10:35 <sclv> right -- the 404 workaround?
16:10:41 <Baughn> sclv: Last week, I wrote a twenty-page program in one go. Worked first time it compiled, too..
16:10:42 <Igloo> dons: It's not the bandwidth as such - just the configuration. There's no need to throttle localhost
16:10:42 <dbpatterson> but the 404 workaround.. it doesnt work because it cant figure out what type anything is..
16:11:02 <sclv> you need |\\ which returns a string, not |\ which does a generic read.
16:11:03 <dbpatterson> or that seems to be the problem..
16:11:05 <dons> Igloo: that's true, but in general we want to allow unrestricted access
16:11:07 <dbpatterson> ahh
16:11:12 <dbpatterson> that would do it.
16:11:17 <dons> Igloo: since it also hurts inside galois too
16:11:30 <dbpatterson> (damn being able to get in touch with the author is helpful...)
16:11:44 <Igloo> heh, true
16:14:24 <dbpatterson> sclv: one more question... this is about lighty rewrites.. I have the app living at /hvac, and rewrite-once to "~/hvac/(.*)$" => "/hvac/$1", "^/(.*)$" => "/hvac/$1", but this only sort of works
16:14:36 <dbpatterson> it passes the control to hvac alright, but the actual urls are not matchable
16:14:43 <dbpatterson> or only the index is...
16:14:49 <dbpatterson> everything else gets handed off to the 404
16:15:00 <dbpatterson> because it isnt 'scriptURI'/'whatever'
16:15:06 <dbpatterson> it is just 'whatever'
16:15:32 <sclv> why all the rewrites?
16:15:56 <ehird_> @type forM_
16:15:57 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
16:16:01 <dbpatterson> oh hmm.. I was doing that when lighty was being a pain in the ass, but it would probably work now at /...
16:16:08 <ehird_> @hoogle (Monad m) => [a] -> (Int -> a -> m b) -> m ()
16:16:08 <lambdabot> No matches, try a more general search
16:16:15 <ehird_> @hoogle (Monad m) => [a] -> (a -> Int -> m b) -> m ()
16:16:15 <lambdabot> No matches, try a more general search
16:16:17 <ehird_> Hmph
16:16:52 <NekoIncardine> Okay... How do I get the contents of a SPECIFIC array position? X_x;
16:16:53 <Peaker> Baughn, I just worked out what (->) does, exactly. Am not sure why its the same as Reader.  Reader has "ask", what's the equivalent in (->) ?  I guess you could write it, but its not there is it?
16:17:14 <mauke> :t ask
16:17:15 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
16:17:18 <dbpatterson> sclv: okay this is a little crazy...
16:17:18 <Baughn> Peaker: Reader definitely has more utilities than (->)
16:17:30 <mauke> ask = id
16:17:30 <NekoIncardine> nm found.
16:17:34 <dbpatterson> when the app lives at root, things are very wierd.
16:17:47 <Peaker> Baughn, I am not sure why (->) is useful as a monad at all, without "ask"/etc
16:17:50 <Baughn> Peaker: (Most of which are only necessary to unwrap the newtype, so..)
16:18:00 <dbpatterson> I can only get proper pages by going to /blah/articles where blah is anything
16:18:09 <mauke> > do { x <- id; y <- ask; return (x, y) } 42
16:18:09 <lambdabot>  Parse error at "42" (column 41)
16:18:14 <mauke> > (do { x <- id; y <- ask; return (x, y) }) 42
16:18:15 <lambdabot>  (42,42)
16:18:38 <dbpatterson> urls that depend on scriptURI are screwed up (perhaps this would obviously happen) - being //something
16:18:51 <Peaker> @src ask
16:18:51 <lambdabot> Source not found. Take a stress pill and think things over.
16:19:00 <ehird_> ask = Reader id
16:19:01 <ehird_> iirc
16:19:07 <Peaker> mauke, is ask coming from the Reader there?
16:19:08 <ddarius> correct
16:19:10 <Peaker> (reader module)
16:19:11 <NekoIncardine> solveTile (Board x) (y,z) =  solveTile.join ($ findTile) ( Board x // [map (removeValue (x ! (y,z))) (rowlist y)] ) <- Just checking the logic I have so far... If my writing's correct, and let's ignore everything before the second Board x for now...
16:19:12 <conal> one reason to look at ((->) a) as a monad is that you can then use monad-generic operations on functions, e.g., ap or liftM2.
16:19:18 <ehird_> @src Control.Monad.Reader.ask
16:19:18 <mauke> Peaker: yes
16:19:18 <lambdabot> Source not found. You type like i drive.
16:19:25 <mauke> ehird_: it's a method
16:19:40 <ddarius> @src MonadReader
16:19:40 <lambdabot> Source not found. That's something I cannot allow to happen.
16:19:43 <Peaker> mauke, ah, but isn't ask written to unwrap the newtype of the Reader monad?
16:19:44 <dbpatterson> and /something falls through to the index handler.. what it seems like is happening is the first part of the path is being assumed to be the scriptURI.. even though it isnt...
16:19:48 <conal> those particular operations correspond to applicative functor ops, though.
16:19:55 <mauke> Peaker: which ask?
16:19:59 <mauke> it's a method
16:20:00 <NekoIncardine> ( Board x // [map (removeValue (x ! (y,z))) (rowlist y)] ) <- Should create a new array, x being modified by running removeValue on the items in row y.
16:20:11 <Peaker> mauke, oh, I thought it was just a function in Reader
16:20:21 <Baughn> @src Reader (>>=)
16:20:21 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
16:20:28 <mauke> Reader is not a class
16:20:33 <Peaker> mauke, a method of what class?
16:20:46 <Peaker> @src ReaderT
16:20:46 * NekoIncardine wants to verify he has that case right, THEN he'll modify it to include columnList and groupList too. x_x
16:20:46 <mauke> MonadReader
16:20:46 <dbpatterson> sclv: all in all, it seems hvac is pretty broken if you use fastcgi.server = ( "/" =>
16:20:47 <lambdabot> Source not found.
16:21:26 <sclv> huh. I get all the path information from the pathInfo function. you might want to write an app that just returns the pathInfo for any request, and then see what it gives you for various requests...
16:21:55 <sclv> to get a sense of how your rewrite rules, etc, interact.
16:21:56 <Botje> I hereby dub <$ the ice-cream combinator
16:22:11 <kaustuv> Who's running the ICFP programming competition this year?
16:22:12 <atsampson> so what's the fine-toothed combinator?
16:22:37 <sclv> myApp = output =<< pathInfo
16:23:17 <ddarius> Botje: Ice-cream cone operator so that you can call $> the ice-cream cocone operator
16:23:23 <ehird_> sclv: hvac interests me. how easy would callbacks be to add?
16:23:24 <Botje> rofl =)
16:23:28 <sclv> then if its not getting you what you want, email me your lighttpd.conf file and describe the expected and actual behavior.
16:23:39 <sclv> ehird_: as in continuation-based programming?
16:23:58 <sclv> smalltalk/arc style?
16:24:49 <ehird_> sclv: no, as in seaside-style callbacks
16:24:58 <ehird_> anchor '++' callback [..do stuff..]
16:25:05 <ehird_> you can extend that to continuations like seaside does
16:25:11 <ehird_> because you just make the closure the continuation
16:25:19 <dbpatterson> sclv: what is your email?
16:25:28 <sclv> i haven't really thought about it... you'd need a closure persistence mechanism.
16:25:40 <sclv> dbpatterson: check the cabal file.
16:25:43 <dbpatterson> basically, from "/path/info" only /info is returned...
16:26:20 <sclv> dbpatterson: oh. i see the bug. yech.
16:26:24 <ehird_> sclv: no you wouldn't
16:26:32 <ehird_> if you have fastcgi, then your server is running continuously
16:26:56 <sclv> what i mean is in the app itself -- you'd need a place to stash them and associate them with keys.
16:27:12 <sclv> which i suppose wouldn't be that hard to build...
16:27:51 <hpaste>  sclv annotated "hvac build error - fastcgi" with "The Broken Function" at http://hpaste.org/6854#a1
16:28:12 <ehird_> sclv: presumably there's some kind of hvac monad which is a custom StateT?
16:28:13 <sclv> dbpatterson: that's the problem there. i wrote it assuming the scriptName would always be first.
16:28:48 <ehird_> so you could just stuff a (Map Int (Request -> HVAC Response)) -- or something
16:28:49 <ehird_> in there
16:28:54 <sclv> I had to override the default one because lighttpd stupidly strips case info from the path, which breaks the wiki.
16:29:34 <sclv> rewriting it the *right way* seems like a pain -- if you want to take a stab at it I'd be mighty pleased.
16:29:47 <dbpatterson> sclv: is there any way to tell that the scriptURI is blank? (ie, /)
16:29:53 <sclv> ehird_: well, yeah, except there's concurrency and atomicity so its a bit more complicated, but essentially yeah.
16:30:49 <sclv> dbpatterson: cgi interfaces are an unruly mess between servers. you're welcome to poke around a bit.
16:31:11 <ehird_> sclv: actually, generally the concurrency and atomicity stuff doesn't get in the way of callbacks
16:31:24 <ehird_> sclv: i suggest trying out Seaside sometime, it's really interesting
16:31:25 <dbpatterson> sclv: this may be a copout, but I'm already proxying through from nginx and I may just have the app live at /hvac for now...
16:31:32 <sclv> right. so given that, yeah, i think callbacks could be added without much trouble...
16:32:11 <sclv> dbpatterson: that's sort of how I wrote it to work. That function should be fixed at some point though, so other people don't run into your problem.
16:32:29 <dbpatterson> that is true...
16:33:07 <Twey> Is Unicode support good in Parsec?
16:33:58 <ehird_> sclv: Cool. Unfortunately it would break down: to have a nice callbacky thingy you need a component-based architechture
16:34:06 <ehird_> & use html generation
16:34:31 <ehird_> (ergo, coupled controller&template. But in a component model the component in very lightweight, and the model should handle as much as is sane)
16:34:33 <ddarius> Twey: Parsec doesn't have any particular support for Unicode.  It just works over whatever stream you give it.
16:34:43 <ehird_> The component model then gives way for a task system
16:34:55 <ehird_> So I don't think HVAC is the right platform for adding continuations&callbacks
16:34:59 <glguy> You should have already decoded the utf-8 bytes before running parsec
16:35:01 <Twey> ddarius: So, things like 'letter' would match ã?
16:35:45 <NekoIncardine> ... Gah. That line was completely inaccurate. X_x;
16:35:46 <glguy> Twey: does Data.Char.isAlpha recognize it?
16:36:06 <ddarius> Twey: It will if isAlpha returns true for it.
16:36:15 <Twey> Seems so.
16:36:21 <sclv> right -- that's sort of why i avoided it, you have to either pick a callback based architecture or not, i don't see how to generalize nicely to support both, although it would be cool to figure it out.
16:36:28 <Twey> > isAlpha 'ã'
16:36:28 <lambdabot>  Improperly terminated character constant at "'ã'" (column 9)
16:36:37 <Twey> Ack, doesn't work over lambdabot.
16:36:42 <Twey> GHCi liked it though.
16:36:54 <NekoIncardine> solveTile (Board x) (y,z) =  solveTile.join ($ findTile) ( Board x // [map (removeValue (x ! (y,z))) (rowList y)] ) <- I see at least two glitches here. First, "no method .join" error. Second, I have absolutely no clue if I'm writing the array modifiers accurately in the slightest.
16:37:15 <NekoIncardine> I suspect I need to import a file to get .join, but...
16:37:24 <glguy> Twey: what is the Unicode value of ã
16:37:42 <Twey> Err
16:37:45 * Twey looks it up.
16:37:50 <awesame> what's the syntax for importing a class together with its methods?
16:37:50 <ddarius> > "ã"
16:37:51 <lambdabot>  "\12354"
16:37:53 <ddarius> There you go
16:38:01 <Twey> Gah, my internet's being an ass
16:38:04 <Twey> Hm
16:38:10 <Twey> That was UTF-8, wasn't it?
16:38:11 <glguy> > isAlpha '\12354'
16:38:12 <lambdabot>  True
16:38:20 * Twey shrugs.
16:38:28 <glguy> \12354 is a single unicode code-point
16:38:30 <NekoIncardine> æ¥æ¬èªã®ãã­ã°ã©ã ã§ããï¼ (Yay two semesters of Japanese.)
16:38:35 <glguy> not utf-8
16:38:46 <EvilTerran> awesame, import Foo (Class(..)), i think
16:38:50 <Peaker> given that Parsec is monadic, and the paper describing arrows says monads disallow any static analysis - does this mean Parsec cannot do static analysis, and build an automaton for linear-time parsing?
16:39:05 <EvilTerran> Peaker, indeed
16:39:09 <Twey> NekoIncardine: ããããã§ãå°ãæ¥æ¬èªãåããã°ããã¨æãã¾ãã
16:39:15 <Twey> ã§ã**
16:39:23 <glguy> english** please ;)
16:39:25 <Baughn> NekoIncardine: I can't help but wince at how badly they mangle english words
16:39:29 <awesame> EvilTerran: that seems to work, thanks
16:39:30 <Twey> Heh
16:39:40 <Peaker> EvilTerran, that's a simpler answer than I expected :)
16:39:47 <Twey> Baughn: It's kind of hard to express English with a syllabary :-P
16:39:51 <awesame> just like types, I should have guessed
16:39:55 <NekoIncardine> Baughn: That's having a pronunciation-matched alphabet for you... And yeah, I completely failed to read that Twey. XD!
16:40:07 <Twey> Oh :-P
16:40:10 <NekoIncardine> Man I have a free month of YesJapan.com
16:40:18 <NekoIncardine> Once I'm out of school for the semester I should try it
16:40:18 <Baughn> Twey: So let them use our letters
16:40:30 <SamB> Baughn: I thought that was how they did it!
16:40:37 <NekoIncardine> The funny part is that they DO that quite a bit!
16:40:37 <SamB> they still mangle the words though
16:40:38 <Twey> Baughn: Personally I think all foreign words should be written in their native script
16:40:40 <EvilTerran> Peaker, in m >>= (\a -> ...), the function is - as it's a function - completely abstract to the implementation of >>=
16:40:49 <EvilTerran> awesame, np :)
16:40:50 <SamB> since they apparantly can't pronounce them very well
16:40:52 <Baughn> SamB: No. Neko's sentence contained "puroguramu".
16:41:06 <sclv> ehird: on the other hand, you could use chunky callbacks with no problem.
16:41:13 <SamB> NekoIncardine isn't japanese
16:41:14 <EvilTerran> awesame, the bit in the report on import declerations will explain all this stuff
16:41:15 <NekoIncardine> ... Man I did not mean to open a can of worms here.
16:41:26 <SamB> so you can't use him as even a single datapoint
16:41:27 <sclv> by which I mean, callbacks that described the entire subsequent page to be returned.
16:41:31 <Baughn> SamB: That has no actual bearing on this case, I'm afraid
16:41:32 <Peaker> EvilTerran, Yeah - is there a canonical replacement for parsec that does use static analysis and do linear-time parsing, in the stdlib?
16:41:36 <SamB> Baughn: I said "they"
16:41:42 <SamB> meaning the japanese
16:41:46 <EvilTerran> Peaker, not in the stdlib, no
16:41:47 <Twey> Baughn: Correct pronunciation rarely matches the transliteration to the speaker's native script anyway, so it doesn't really matter if the speaker just memorises pronunciation for certain shapes rather than learning how to read it
16:41:58 <Twey> Unfortunately, people don't seem to agree with me
16:42:03 * Baughn cries over the "fjords"
16:42:03 <atsampson> Peaker: do you have an application that Parsec's not fast enough for, then?
16:42:07 <EvilTerran> Peaker, there might be something on hackage, though
16:42:20 <EvilTerran> Peaker, you could use Happy, for instance
16:42:26 <EvilTerran> ?where happy
16:42:26 <lambdabot> http://www.haskell.org/happy/
16:42:31 <atsampson> (I'm using it and have been pretty impressed with its performance, although that might just be because the rest of my app's so slow...)
16:42:32 <Baughn> Twey: I know what you mean. You english bastards keep mangling /our/ words, after all..
16:42:39 <Peaker> atsampson, no, I am just curious
16:42:51 <Twey> Baughn: Indeed :-)
16:42:54 <Baughn> Twey: Why couldn't you just have let us conquer you? -_-
16:42:55 <Peaker> EvilTerran, thanks
16:43:10 <Twey> Baughn: Heheh
16:43:11 <ddarius> Pappy has a monadic interface that builds up a grammar type thing and then runs a packrat parser over it, but that has O(n) space useage.
16:43:13 <EvilTerran> that's "the" parser generator for haskell, anyway
16:43:24 <EvilTerran> ?where lex
16:43:24 <lambdabot> I know nothing about lex.
16:43:28 <EvilTerran> ?where alex
16:43:29 <lambdabot> http://www.haskell.org/alex/
16:43:29 <Twey> Baughn: Because then we'd be speaking Norsk :-P
16:43:43 <EvilTerran> (whups) - that's the lexer generator normally used with it
16:44:00 * NekoIncardine would enjoy speaking Norsk just for the hell of it. <_<
16:44:08 <Baughn> Twey: That would be a good thing.
16:44:15 <NekoIncardine> then again I'm Euromutt with significant amounts of norse blood, so...
16:44:47 <Baughn> Twey: Besides, you're /already/ speaking norwegian, to a large part
16:45:25 <SamB> but sometimes people hand-code lexers, in the cases where they are fortunate enough to have a lexically simple language ;-)
16:45:39 <Twey> Baughn: More Latin really
16:45:48 <SamB> or at least one in which the complexity is not the kind capturable by regexes
16:46:12 <Baughn> Twey: Latin's supposed to be a constructed language. I'm not sure /any/ country ever spoke it
16:46:19 <atsampson> "variable names are a prime number of letters long, reserved words are composite"?
16:46:58 <glguy> what are single character names?
16:46:59 <SamB> I was thinking more like contextual stuff
16:47:05 <Baughn> glguy: 1 is a prime
16:47:07 <TomMD> Can anyone tell me why I see people using Haddock 0.8 when 2.0 is out - this causes interop issues.
16:47:16 <glguy> Baughn: since when?
16:47:20 * EvilTerran generally just uses two parsec parsers, one for lexing and one for parsing
16:47:30 <SamB> rather than the most complicated thing in the language being distinguishing numeric literals from other stuff
16:47:33 <EvilTerran> Baughn, er, not by most definitions i've seen
16:47:35 <atsampson> TomMD: Debian stable only has 0.8
16:47:36 <Baughn> glguy: It's only divisible by itself and 1
16:47:57 <Baughn> EvilTerran: Most of /those/ have "except for 1" in the appendix somewhere, though. It's squicky.
16:48:16 <atsampson> I'm using Alex to lex and Parsec to parse, which works nicely
16:48:22 <Twey> Baughn: I suspect most languages were constructed at some point
16:48:27 <ddarius> Baughn: I'm with glguy and EvilTerran here, 1 is not usually considered a prime number.
16:48:28 <Twey> That doesn't mean nobody spoke them
16:48:29 * Baughn would like to see an unary spoken language
16:48:34 <TomMD> so the issue is people don't like to compile from source?  Guess I'm just weird and compile many packages (be it on Ubuntu, Debian, or Fedora).
16:48:35 * Twey votes Lojban.
16:48:36 <EvilTerran> Baughn, yours breaks the fundamental theorem of arithmetic, though
16:48:43 <ddarius> Baughn: One reason to do this is if it were, it would do what EvilTerran said.
16:48:48 <ddarius> (Damn you EvilTerran)
16:48:55 * NekoIncardine decides to tackle his issues with his solveTile method one piece at a time. ONE: "solveTile.join ($ findTile)" <- The idea is to run Solvetile on a board defined by the 'inner logic' (which is to the right of this section) and a tile defined by findTile on the board defined by the same inner logic.
16:49:05 <Baughn> ddarius: I'm not saying 1 should be prime
16:49:11 <NekoIncardine> Problem: I don't have a .join method, and I'm not sure this would work if I did.
16:49:18 <NekoIncardine> Question: Anyone have a recommended way to fix this?
16:49:18 <Baughn> ddarius: I just want people to be honest about it, and insert "except for 1" everywhere. :)
16:49:19 <SamB> 1 can't be prime
16:49:24 <EvilTerran> NekoIncardine, er, method?
16:49:31 <NekoIncardine> EvilTerran: Function.
16:49:35 <SamB> it will break all my project euler code!
16:49:42 * NekoIncardine too used to calling them Methods from Java x_x
16:49:46 <TomMD> @let prime = 1
16:49:46 <lambdabot> Defined.
16:49:50 <TomMD> ha
16:49:53 <EvilTerran> . means compose...
16:50:12 <NekoIncardine> EvilTerran: Yes... That's the function I was given earlier, and I wasn't sure of it then.
16:50:36 <NekoIncardine> http://hpaste.org/6845#a4 Lists the whole thing in context except for the lineI'm working on atm.
16:50:39 <Baughn> NekoIncardine: Just for the record, sectioning (.) makes baby jesus cry
16:50:50 <NekoIncardine> Baughn: Figured as much.
16:50:51 <ddarius> Baughn: It does?
16:50:58 <Baughn> ddarius: He's a baby. He cries easily.
16:51:19 <ddarius> Diaper rash makes baby Jesus cry.
16:51:47 <NekoIncardine> I guess the real question, though, is how I make it compose the desired result. X-x
16:52:03 <EvilTerran> NekoIncardine, a couple of thoughts... you can put arbitrary whitespace (including newlines) in strings by putting a \ on either end of the "string gap"
16:52:14 <EvilTerran> > "abc\        def"
16:52:14 <lambdabot>  Illegal character in string gap at ""abc\" (column 1)
16:52:17 <EvilTerran> > "abc\        \def" -- even
16:52:18 <lambdabot>  "abcdef"
16:52:20 <SamB> Baughn: my religion disagrees with you at this time
16:52:32 <SamB> because, according to my religion, there is no baby jesus
16:52:33 <NekoIncardine> EvilTerran: Er, what?
16:52:36 <SamB> (anymore)
16:52:39 <EvilTerran> > "abc\ {- i can't remember if comments are allowed -} \def"
16:52:39 <lambdabot>  Illegal character in string gap at ""abc\" (column 1)
16:52:42 <Baughn> SamB: Don't worry. I just figured out how to kill God.
16:52:44 <SamB> he, you know, grew up!
16:52:50 <elliottt> ?bug
16:52:50 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
16:52:54 <NekoIncardine> SamB: I'm a Neo Hebrew Zombiest, but it doesn't really matter does it.
16:52:56 <EvilTerran> NekoIncardine, just looking at your definition of generiBoard
16:53:18 <ehird_> SamB: Is there a Zombie Jesus?
16:53:31 <SamB> ehird_: that's just silly
16:53:40 <NekoIncardine> EvilTerran: Ah... I'm not even concerned about that atm.
16:53:42 <EvilTerran> you can write it as generiBoard = "    59  4\<newline><indent>\   7  1 2\..."
16:53:45 <ddarius> SamB: Well he was undead...
16:53:52 <Baughn> SamB: Just kill everyone.
16:53:54 <EvilTerran> it was just a random observation
16:53:56 <SamB> not undead -- alive!
16:54:26 <ehird_> SamB: He did die, and then start walking around again... That's quite common zombie behaviour
16:54:36 <SamB> ehird: I must admit that
16:54:54 <monochrom> Who? Who's dead and walking around?
16:54:55 <SamB> however, he was a bit more coherent than is typical of zombies
16:55:05 <ehird_> Maybe the Bible CONVENIENTLY left out descriptions of the BRAINS he ate!
16:55:13 <EvilTerran> NekoIncardine, also, you can write charToTile somewhat nicer.
16:55:25 <EvilTerran> again, just random points. nothing to worry about, just stylistic stuff
16:55:40 <SamB> are zombies coherent even after eating brains?
16:55:56 <ehird_> SamB: The brains make them smarter.
16:56:05 <NekoIncardine> I'm aware of that one as well. I intentionally chose to expand it for the sake of making the code more self-documenting in nature.
16:56:17 <EvilTerran> charToTile x | x `inRange` ('1','9') = Unsolved [digitToInt x] | x `elem` "0 _.b" = Unsolved freshTile
16:56:20 <monochrom> Even lambdabot is coherent.
16:56:29 <monochrom> @vixen are you coherent?
16:56:29 <lambdabot> where else would i be?
16:56:32 <ehird_> Also, if he eats someone's brains, all their descendants can use that distant brain to telepathically communicate to him and he will grant gifts to them
16:56:35 <SamB> anyway, there isn't much historical evidence for the existance of zombies is there?
16:56:46 <ehird_> Maybe he feels sorry for them because he ATE their ancestors' BRAINS
16:56:49 <EvilTerran> or just charToTile '1' = Unsolved [1]; charToTile '2' = Unsolved [2] ...
16:56:55 <EvilTerran> using the joys of pattern-matching :)
16:56:57 <ehird_> SamB: to be honest, you could say the same for jesus..
16:57:13 <ddarius> Indeed, there may actually be more "evidence" for zombies...
16:57:13 <Nafai> What's the best way to wrap a C++ library to be accessible from Haskell?
16:57:21 <ddarius> Nafai: Don't.
16:57:23 <NekoIncardine> ehird_: Actually... There is empirical evidence that, at the very least, Jesus lived and was a real person.
16:57:28 <SamB> there's plenty of evidence that he lived and said what he said
16:57:36 <Baughn> SamB: The roman judicial records were /very precise/. The most we have evidence of is a couple of religious terrorists
16:57:41 <ehird_> ddarius: All hail His Noodly Appendage's son, Holy Zombie!
16:57:42 <EvilTerran> Nafai, (1) bang head on desk (2) repeat (3) ??? (4) PROFIT!
16:57:47 <ddarius> Nafai: At one point I started wrapping Kyra, I used SWIG to get a C interface and wrapped that.
16:57:47 <Peaker> Nafai, maybe use   extern "C" { .. } and wrap it for C and then use the C from Haskell?
16:57:50 <Nafai> I was afraid at that :)
16:57:57 <ehird_> NekoIncardine: But next to no evidence that he was anything but a crazy cult leader
16:58:05 <Peaker> SWIG does C++ -> C?
16:58:15 <Baughn> ehird_: Well, a crazy /criminal/ cult leader. *shrug*
16:58:16 <EvilTerran> all the best people are crazy cult leaders
16:58:19 <NekoIncardine> ehird_: Insert L.Ron Hubbard joke here, and I think we've hit haskell_blah at this point
16:58:37 <ehird_> okies then, religion --> blah
16:58:42 <SamB> I didn't think jesus made much money
16:59:02 <SamB> Baughn: what did he do that was criminal?
16:59:10 <ehird_> Baughn: With shaky morals to boot
16:59:13 <ehird_> Anyway, -blah
16:59:38 * SamB was waiting for someone to say #haskell-blah whole so he could click on it
16:59:42 <Baughn> SamB: Disorderly conduct, assault and battery, incitement to rebellion.. take your pick
16:59:56 <NekoIncardine> quickSort (Inc's Brain)
17:00:10 <NekoIncardine> Hrm.
17:00:10 <ehird_> NekoIncardine: Sounds painful.
17:00:19 <NekoIncardine> ehird_: Rather. :V
17:01:00 <SamB> #1 and #3 are criminal now?
17:01:02 <NekoIncardine> Now, back to me trying to figure out how to fix this bloody thing. If I can fix it then I'm almost done with this entire problem. Then I just send it to my lab partner for him to throw in the Input code and then we're done.
17:01:15 <Baughn> SamB: #1, probably not. #3, always.
17:01:29 <Baughn> SamB: Worse yet, he did #3 badly enough that /his own people/ wanted him gone
17:01:34 <SamB> I was under the impression that the US was founded on #1 and #3
17:01:52 <dbpatterson> SamB: but who isnt a hypocrite these days...
17:01:53 <ehird_> #3 is illegal, but shouldn't be -- within reason.
17:02:00 <NekoIncardine> SamB: the US was founded on actions that the British called criminal. So did a whole lot of other nations. So what.
17:02:02 <ehird_> Jebus probably overstepped the reason element
17:02:17 <Baughn> SamB: If you win, you make your own rules. Might makes right, as usual.
17:02:18 <NekoIncardine> This is still #haskell-blah material.
17:02:24 <ehird_> NekoIncardine: But Baughn isn't there.
17:02:33 <SamB> NekoIncardine: that is my excuse too
17:02:36 <NekoIncardine> A point.
17:02:44 <NekoIncardine> Ah but he just joined
17:02:49 <SamB> so I see
17:03:11 <SamB> -> #haskell-blah we go
17:03:40 <RyanT5001> is there any good, general way to statically assert (i.e.: with a type) that a given function is a homomorphism?
17:04:09 <RyanT5001> for example, i'm writing a function to do lexical scoping
17:04:16 <sclv> ?hoogle unsafeCoerce
17:04:16 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
17:04:26 <RyanT5001> and i seem to be stuck with Tree -> Tree
17:04:37 <RyanT5001> which doesn't convey the information that "both trees will have the same shape"
17:04:59 <dbpatterson> sclv: trac.lighttpd.net/trac/ticket/729 - is this the lighty behavior you were talking about having to work around ? because this IS why my example is broken...
17:05:14 <NekoIncardine> Hrm.
17:05:38 <dbpatterson> now why in 2 years they havent bothered to fix it is beyond me...
17:05:49 <RyanT5001> i can't simply use fmap, because it needs to take into account an unbounded amount of the tree around the given node
17:05:56 <NekoIncardine> Anyways, I'm still stuck on getting the desired effect of SolveTile ( INNERLOGIC findTile SAMEINNERLOGIC) so that INNERLOGIC doesn't have to be processed in full twice.
17:06:07 <sclv> oh hey! its not my bug after all!
17:06:13 <EvilTerran> > indices (array ((0,0),(3,3)) [])
17:06:14 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3,...
17:06:19 * sclv wipes brow in relief.
17:06:25 <NekoIncardine> Should I just change solveTile to be (IntInt), Board instead of the other way around?
17:06:42 <NekoIncardine> ... No, I'd just have the two INNERLOGICS right next to each other then wouldn't I.
17:07:12 <sclv> given that their pathInfo is borked, I wouldn't mind writing a workaround for hvac for it nonetheless, if an obvious one that doesn't break everyone else presents itself.
17:07:58 <sclv> the behavior I work around is another path info bug actually -- it lowercases everything, which screws with the wiki, which obv. needs case sensitivity in the names of the pages.
17:08:02 <dbpatterson> sclv: well it is scriptName that is screwed up because of lighty...
17:08:25 <EvilTerran> ?type elem
17:08:27 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
17:09:13 <NekoIncardine> ... I'm drawing a total blank here. :/
17:09:24 <glguy> RyanT5001: no, as types aren't dependent upon values
17:09:49 <dbpatterson> gah lighty's trac is down for the count. here is google cache of it - http://72.14.205.104/search?q=cache:38H1WCTiOs0J:trac.lighttpd.net/trac/ticket/729
17:09:50 <lambdabot> http://tinyurl.com/64pz92
17:10:05 <_Alphahelix_> Ryan. I don't know that much about Haskell yet - not that well placed to give advice - but as no-one else is answering:  The short is answer is no because Haskell doesn't (yet?) have dependant types. Still, maybe there's something you can do with phantom types and/or GADTs that would help.
17:10:10 <dbpatterson> oh nevermind it seems to be okay now.
17:10:12 <hpaste>  NekoIncardine annotated "Simple Sudoku Solver (Beta 1000something)" with "premise for solveTile written, need to fix." at http://hpaste.org/6845#a5
17:10:20 <hpaste>  Laney pasted "Bug in GHC's DateTime libraries?" at http://hpaste.org/6855
17:10:32 <Laney> Can someone check I'm not going crazy with ^?
17:11:30 <EvilTerran> NekoIncardine, i must apologise for getting completely sidetracked, but i can't help but try to "improve" code when i see it...
17:11:55 <hpaste>  EvilTerran annotated "Simple Sudoku Solver (Beta 1000something)" with "some random ideas" at http://hpaste.org/6845#a6
17:11:57 <NekoIncardine> ET: Not a problem. I'm mostly worried about getting this done is all, but seeing other ways to do the same thing is a good thing. :)
17:13:12 <RyanT5000> my connection died; did anyone respond to my homomorphism point?
17:13:20 <_Alphahelix_> Ryan: I think you'd basically have to have a different type for every tree shape.
17:13:51 <RyanT5000> _Alphahelix_: well, not if i just want the special case of "input and output tree are the same type", right?
17:14:01 <RyanT5000> _Alphahelix_: i'm not going into how to *prove* it in the type system yet
17:14:09 <RyanT5000> _Alphahelix_: that would probably be super-hard
17:14:34 <RyanT5000> _Alphahelix_: i'm just looking for a denotational style, e.g. TreeHomomorphism a b
17:14:59 <RyanT5000> then there would be an apply operator to apply that to a tree
17:15:31 <NekoIncardine> Nonetheless, now I gotta figure out solveTile. That's, far as I know, the only remaining piece I need to finish this.
17:15:34 <EvilTerran> NekoIncardine, ok. i just can't stand to see folk learn bad habits (or what look like bad habits to me ;])
17:15:46 <ddarius> You might be able to do it with a Church encoding approach.
17:16:15 <EvilTerran> bear in mind that i haven't tested any of that code, so you may want to make sure you know how it works before borrowing any ideas from it ;)
17:16:16 * SamB attempts to make some joke involving Baughn not believing in the church
17:16:18 <RyanT5000> ok well here's another, related question
17:16:42 <RyanT5000> are there optimizations available to a compiler that knows that certain operations are homomorphic?
17:16:56 <RyanT5000> for example, say you've got a really complicated datastructure
17:16:58 <NekoIncardine> ET: That's one reason I'd like to keep my code, most of it I HAVE tested and know works, so...
17:17:06 <RyanT5000> like a heap of objects
17:17:09 <Baughn> SamB: Oh, I believe in the /church/. It's hard to miss, after all.
17:17:17 <RyanT5000> and you want to extend every Doohickey with an additional field
17:17:40 <NekoIncardine> PRettying the code is one thing, but getting the code to operate comes first in my book.
17:17:41 <EvilTerran> NekoIncardine, ok, but let me at least point out one thing, as it's an algorithm thing rather than a notation thing...
17:17:46 <NekoIncardine> All right.
17:18:30 <EvilTerran> er... well, both our definitions of removeValue are O(n), is pretty much what i was gonna say
17:19:17 <EvilTerran> in order for the "any" check to happen when x isn't in y, it'll have to look at every item of the list anyway, so you might as well just do the filter
17:19:17 <SamB> Baughn: as you can see, it was a failed attempt
17:19:45 <EvilTerran> now then. about the actual problem...
17:19:46 <NekoIncardine> ... Mine adds redundancy in the form of the any being redundant in its redundant nature?
17:20:05 <EvilTerran> also, "any (==x) y" can be written nicer as "x `elem` y"
17:20:28 <SamB> you said "any p = not . null . filter p"?
17:20:31 <NekoIncardine> Which means "x is element of y", correct?
17:20:40 <EvilTerran> exactly
17:20:40 <EvilTerran> ?src elem
17:20:40 <lambdabot> elem x    =  any (== x)
17:20:47 <EvilTerran> ha
17:20:59 <SamB> see, they agree with you
17:21:16 <SamB> they don't think any (== x) is clear either
17:21:30 <ddarius> any . (==)
17:21:36 <_Alphahelix_> Ryan - my knowledge of Haskell pretty shallow, and you're probably a lot smarter than me, but just out of curiosity: What kind of middle ground are you envisaging between (a) just having some newtype called TreeHomomorphism wrapping Tree a -> Tree b and (b) having a different type for every possible tree shape.
17:22:04 <SamB> ddarius: that needs a type sig
17:22:15 <RyanT5000> _Alphahelix_: i'm basically envisioning the first one, but i'd really like some way of not having to redeclare it every time i declare a new datastructure
17:22:28 <sclv> :t (>=>)
17:22:28 <SamB> besides being gratuitously point-free
17:22:32 <RyanT5000> _Alphahelix_: specifically, i'd like to abstract TreeHomomorphism over Tree
17:22:34 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
17:22:50 <RyanT5000> _Alphahelix_: I suppose i could just write Homomorphism a b = a b -> a b
17:22:56 <Peaker> @src elem
17:22:56 <lambdabot> elem x    =  any (== x)
17:23:00 <RyanT5000> _Alphahelix_: that's kind of ridiculous though
17:23:12 <RyanT5000> and probably useless
17:23:19 * NekoIncardine improves RemoveValue, now pondering back to solveTile again.
17:23:25 <_Alphahelix_> Ryan: Yeah, I guess it's not buying you anything...
17:23:50 <RyanT5000> _Alphahelix_: well, i'm trying to write my own language anyway, so maybe i'll just save that kind of proof for the meta-circular interpreter :P
17:23:55 <RyanT5000> this is just bootstrapping code anyway
17:24:04 * EvilTerran is thinking about his own (unfinished) sudoku solver again, now
17:24:49 <EvilTerran> i had "type Triple a = (a,a,a); type Square a = Triple (Triple a); type Board a = Square (Square a)", IIRC
17:25:17 <EvilTerran> so a board was represented as a load of nested triples, which made some of the stuff like what you're doing in groupList easier
17:25:22 <RyanT5000> i can't believe i'm actually writing a module called "Homo"
17:25:23 <NekoIncardine> EvilTerrain: ... Not too bad a premise, unless you want to modify yours for use with 16*16s or 4*4s.
17:25:37 <EvilTerran> it also exposed some rather nice symmetries
17:26:28 <_Alphahelix_> It is possible to have a different type for every tree shape, you know - you need to use type classes recursively and set the 'allow undecidable instances' option when you compile.
17:26:43 <ehird_> RyanT5000: hahah
17:26:44 <EvilTerran> indeed, it doesn't really extend to different-sized boards. if i wanted to do that, i'd probably want to hack something with type-level naturals to statically enforce the lengths of lists or something ;)
17:26:50 <_Alphahelix_> I might be able to find a link to an example of how that's done...
17:26:54 <sclv> whew! I finally beat the type problem I was having.
17:27:02 <RyanT5000> _Alphahelix_: yeah, that's way too much work, though; it'd be easier to just trust myself
17:27:07 <NekoIncardine> Hrm...
17:27:11 <sclv> on the minus side, I use unsafeCoerce, albeit safely. :-(
17:27:14 <chessguy> @quote asplode
17:27:14 <lambdabot> No quotes match. My pet ferret can type better than you!
17:27:17 <ehird_> sclv: haha, how
17:27:42 <ddarius> ehird_: It comes up when you need to change the type of a phantom variable.
17:27:51 <EvilTerran> NekoIncardine, i think part of the problem for writing solveTile might be that you can't really modify your array through use of rowList, columnList, and groupList
17:27:56 <EvilTerran> as they just return lists of tiles
17:27:57 <RyanT5000> _Alphahelix_: it only really matters when i have untrustworthy people providing code to me
17:28:12 <NekoIncardine> ET: doesn't the x // let me get past that, though?
17:28:21 <ehird_> ddarius: :x
17:28:28 <NekoIncardine> Cale seemed convinced it did, at least... I'm not seeing the how part but
17:28:35 <ehird_> though i might end up using unsafe* for this current project..
17:28:46 <ddarius> ehird_: It's not necessary in that case, but it can lead to losing sharing for no good reason.
17:28:49 <EvilTerran> NekoIncardine, well, you still need to keep track of the indices so // knows which cells to change
17:28:50 <sclv> well, in this case it changes the type of something guaranteed to be forall s. s in a ReaderT to something concrete so that it can unify properly with the rest of my program.
17:29:09 <NekoIncardine> ... Point.
17:29:23 <sclv> given that its guaranteed to be forall s, that means the coerced bit can't be accessing it anyway.
17:29:27 <RyanT5000> are arrows the same as homomorphisms?
17:29:38 <NekoIncardine> I'll need to figure out that part of the logic soon enough here, but first off, I need to figure out the outer logic.
17:29:39 <ddarius> RyanT5000: No.
17:29:39 <EvilTerran> so, as i said, i'd make *List return lists of co-ordinates
17:29:50 <RyanT5000> ddarius: are they related in any way?
17:30:04 <sclv> it only really comes up because ghc optimizes away the forall s. too soon in the unification process.
17:30:19 <NekoIncardine> ET: Returning the co-ordinates AND the tile to be removed, or just the tile to be removed?
17:30:32 <EvilTerran> just returning the co-ordinates would be fine
17:30:33 <ddarius> Arrows are Freyd categories which are not particularly related to typical categorical ways of representing algebras and algebra homomorphisms.
17:31:22 <RyanT5000> ok
17:31:24 <RyanT5000> thanks :)
17:31:34 <EvilTerran> you can get the tiles themselves out easily with just writing "map (x!) (groupList x (y,z))" where you're writing "groupList x (y,z)" now
17:31:55 <EvilTerran> ... or something. your Board constructor will have to appear in there somewhere.
17:32:24 <EvilTerran> also, i'd choose different variable names. (x,y) for co-ordinates and b for boards or something, consistently throughout
17:32:36 <chessguy> EvilTerran, what are you working on?
17:33:00 * EvilTerran is getting confused by x,y,z meaning vastly different things depending on which function we're looking at
17:33:46 <EvilTerran> chessguy, NekoIncardine's writing a sudoku solver... and i'm trying to provide gentle guidance towards good programming style, instead of helping with the problem at hand ;)
17:33:48 * NekoIncardine switches the solveTile to z (x,y) to make that one consistent with groupList, for the moment...
17:33:53 <chessguy> aha
17:33:57 <ddarius> RyanT5000: If you represent your data type as a function Shape -> a, then any function a -> b is a homomorphism.
17:34:07 <ehird_> actually, hmm
17:34:13 <ehird_> i think this DSL may be impossible
17:34:27 <ehird_> it's a DSL that zoops down into javascript code
17:34:29 <RyanT5000> ddarius: but wouldn't that be unworkably slow for most datastructures?
17:34:29 <ehird_> doesn't compile the haskell
17:34:35 <ehird_> just a dsl for writing javascipt
17:34:36 <ehird_> but..
17:34:52 <ehird_> do a <- jsEval "2+2"; b <- jsEval "2*2"; jsAlert (show (a+b))
17:34:55 <ddarius> RyanT5000: It would be a pain in the butt for most data structures.
17:35:00 <ehird_> i don't think i can get that to type properly, heh.
17:35:14 <NekoIncardine> Hrm.
17:35:27 <RyanT5000> ddarius: oh yeah, also, i'm not writing transformations that i can simply map over the individual data in the structure
17:35:35 <RyanT5000> ddarius: i'm doing stuff like binding variables in an AST
17:35:45 <dbpatterson> sclv: on the new system, db rows passed into stringtemplates dont seem to have the column identifiers - ie, $rows$ prints them all out, but $rows:{row | row.id}$ doesnt print anything... ideas of where the problem lies?
17:35:47 <NekoIncardine> solveTile (Board z) (x,y) =  solveTile.findTile ( Board z // [map (removeValue (z!) (rowList x) ) ] ) <- So once I adjust rowList to return [(Integer,Integer)] instead of [Tile], that form should work correct?
17:36:35 <NekoIncardine> ... rowList y, though. y is rise x is run.
17:36:45 <RyanT5000> which *is* shape-preserving, but not particularly simple
17:36:49 <EvilTerran> you'll need to include the indices in the parameter to //
17:37:19 <NekoIncardine> ET: Hrm... I'm just trying to figure out how to match that against the map function now.
17:37:44 <NekoIncardine> Especially since I'm going to have to modify this so that there's one giant list of rowList ++ columnList ++ groupList once I have it set up for rowList.
17:38:02 <dbpatterson> sclv: clarification, the count is correct, ie if it is $rows:{row | <tag> $row.id$}$ the correct number of <tag>s get printed...
17:39:46 <sclv> well, it seems like the individual rows don't have a column id coming through?
17:40:12 <NekoIncardine> ... Yeah at this point I'm getting kinda lost. x_x
17:40:23 <sclv> you can do $row.id;null='Null'$ to check?
17:41:01 <sclv> you can also do $rows:{row | row}$ to see what the individual rows do include...
17:41:08 <dbpatterson> sclv: I'll check, it is just wierd because identical controller/template code is working on my workstation...
17:41:24 <sclv> probably a db issue then?
17:41:42 <hpaste>  EvilTerran annotated "Simple Sudoku Solver (Beta 1000something)" with "an idea for solveTile" at http://hpaste.org/6845#a7
17:42:06 <dbpatterson> sclv: well it is sqlite, and I scp'd it up too..
17:42:13 <dbpatterson> rows are coming through fine...
17:42:21 <sclv> and the individual rows?
17:42:26 <dbpatterson> those two
17:42:41 <hpaste>  EvilTerran annotated "Simple Sudoku Solver (Beta 1000something)" with "errors fixed. also, reformatted." at http://hpaste.org/6845#a8
17:42:43 <sclv> but the id selector is failing... weird. same version of HStringTemplate?
17:42:44 <dbpatterson> it is getting $row.id$ and $row.contents$ for example that doesnt seem to be working
17:42:48 <NekoIncardine> Now, I just figure out the meaning of thisversion of solveTile.
17:42:48 <dbpatterson> 0.3.1
17:43:28 <EvilTerran> NekoIncardine, well, do you know how where{} works?
17:43:49 <NekoIncardine> {}? I don't see that set even here. O_o; Do you mean []?
17:44:10 <EvilTerran> ah... no, sorry, {} are what you use if you aren't using indentation to group things
17:44:12 <sclv> paste the results from the rows as a whole and I'll take a look...
17:44:19 <NekoIncardine> Ah.
17:44:30 <EvilTerran> that where clause i wrote could be written as "where { v = b!(x,y)
17:44:31 <NekoIncardine> As in Java and the like then. Here (and in the rest of my code) Indentation isthe method so
17:44:37 <EvilTerran> ; removeFrom = ... }"
17:44:37 <EvilTerran> er, minus the newline
17:44:55 <EvilTerran> (or with the newline, if you like. a block wrapped in {}s ignores whitespace, mostly
17:45:22 <NekoIncardine> In other words, in a Javalike style instead of following spacing details. That makes sense, but matching by indentation is easier to read anyways.
17:45:24 <EvilTerran> well, except that binding for v should be "Solved v = b!(x,y)"
17:45:30 <EvilTerran> indeed
17:45:40 <NekoIncardine> So lemme piece this together piece by piece.
17:45:41 <travisbrady> dons: I'm getting "bytestring-mmap.cabal:20: 'Executable' stanza starting with field 'flag split-base description'" when trying to install bytestring-mmap
17:46:03 <EvilTerran> the report specifies how to deal with the indentation in terms of the compiler going through adding explicit {s, }s, and ;s according to the newlines and indentation
17:46:09 <dons> travisbrady: update to a newer cabal
17:46:12 <dons> 1.2.x would be good
17:46:18 <travisbrady> dons: ahhh, ok
17:46:32 <EvilTerran> / takes, as its second parameter, a list of (index,value) pairs
17:46:34 <EvilTerran> er, //
17:47:00 <EvilTerran> ?type (//)
17:47:07 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
17:47:11 <NekoIncardine> Pre = is obvious enough at this point. "solveTile . findTile ." means solveTile with the inner logic that is shared with findTile as its first input, and findTile itself as its second input. The section from "Board z" onwards is shared between both.
17:47:20 <NekoIncardine> Is this accurate?
17:47:26 <dbpatterson> sclv: there is not much to paste.. it is just each column without spaces inbetween...
17:47:35 <EvilTerran> "inner logic" what?
17:47:50 <NekoIncardine> The "Inner Logic" is my term for the board refining component.
17:48:01 <EvilTerran> "solveTile . findTile . Board
17:48:03 <NekoIncardine> Sorry.
17:48:04 <EvilTerran>  $ ..." means exactly the same thing as "solveTile (findTile (Board (...)))
17:48:04 <EvilTerran> "
17:48:06 <EvilTerran> goddamn newlines
17:48:11 * EvilTerran stabs his client
17:48:18 <EvilTerran> ?src (.)
17:48:18 <lambdabot> (f . g) x = f (g x)
17:48:20 <EvilTerran> ?src ($)
17:48:21 <lambdabot> f $ x = f x
17:49:01 <SamB> since when does GHC have a 3-stage compilation process?
17:49:11 <sclv> well there's an issue right there.
17:49:20 <ddarius> It usually only uses 2 stages.
17:49:24 <sclv> if you show a whole row, it should show it with labels.
17:49:25 <NekoIncardine> All right.
17:49:48 <tromp> > 157*1.5
17:49:50 <lambdabot>  235.5
17:50:00 <sclv> like such: author: [test]authorid: []contents: [test]id: [135]thread: [97]time: [2008-03-22 20:26:24]
17:50:22 <sclv> if its not doing that, then the database probably isn't returning the column names correctly, and hence you can't access them.
17:50:40 <NekoIncardine> Then the innerlogic produces tuples of (x',y') and removeValue v $ b!(x',y')) for the list of values valid for (x',y').
17:50:50 <dbpatterson> sclv: yeah, different versions of sqlite, let me upgrade and see if that fixes...
17:50:53 <SamB> ddarius: do you have any idea when stage3 is relevant?
17:51:10 <ddarius> Not anymore, I've long since forgot.
17:51:15 <EvilTerran> indeed. and you just need to decide what those values are, by giving a value to removeFrom in the where block
17:51:33 <sclv> was the bad one sqlite3 or earlier?
17:51:39 <dbpatterson> sclv: and no, it isnt doing it like that, it is doing it like testtest135972008-03-22 20..
17:51:56 <NekoIncardine> Then I just need to modify the row/column/groupLists to produce point lists, then I can just put the three lists together using ++.
17:52:03 <EvilTerran> NekoIncardine, also, as i said, "v = b!(x,y)
17:52:08 <EvilTerran> " should probably be "Solved v = b!(x,y)
17:52:08 <EvilTerran> ", so the value of v isn't wrapped in a Solved constructor
17:52:08 <EvilTerran> ARGH
17:52:14 <sclv> dbpatterson: which vers is the bad one?
17:52:22 * EvilTerran must fix this newline bother
17:52:26 <dbpatterson> 3.5.3
17:52:29 <dbpatterson> 3.5.7 is working
17:52:42 <sclv> ok -- i'll note that, thanks.
17:52:55 <NekoIncardine> ... That's one part of the logic I forgot. SolveTile actually works on an UNSOLVED of length 1, either before or after actually solving it.
17:52:56 <dbpatterson> but I havent confirmed that that is the problem...
17:53:20 <EvilTerran> ohh. in that case, you may have to do something fancier when picking a value for v
17:53:22 <sclv> the other issue could be a different HDBC version too...
17:53:41 <dbpatterson> nope, I checked that... they are the same..
17:54:01 <NekoIncardine> Hrm.
17:54:10 * SamB wonders what happens if you run GHCi in GHCi... supposes you just get a really bloated process...
17:54:12 <EvilTerran> ... unfortunately, it's approaching 2am here, and i really should bow out and sleep. i'm sure someone else in this collection of gentlemen and scholars will be able to help you, though. :)
17:54:25 <ehird_> SamB: probably requires compilation
17:54:49 <NekoIncardine> Given this is  partially where-based, I could use a do line, and  swith the target tile out for a Solved first.
17:54:53 * dbpatterson is shocked that debian unstable has a higher sqlite version than gentoo ~arch
17:54:59 <NekoIncardine> Night ET. Thank you muchly.
17:55:01 <NekoIncardine> EvilTerran++
17:55:19 <SamB> ehird: that wouldn't stop me from running it in GHCi would it?
17:56:19 <SamB> actually, I bet I'd get errors due to double-initialization of the input library
17:57:23 <sclv> weird, I
17:57:30 <sclv> I'm running 3.1.3 without problems...
17:57:48 <SamB> schemelab: 3.1.3 of what?
17:57:54 <SamB> er. sclv
17:57:55 <EvilTerran> :)
17:58:11 <SamB> oh, sqlite?
17:58:15 <sclv> yep.
17:58:38 <dbpatterson> hmm.. well 3.5.6 doesnt seem to make it better
17:58:48 <dbpatterson> and it seems crazy that between minor versions something would happen...
17:58:51 <sclv> that's the worst part about Haskell -- dealing with talking to other programs.
17:58:56 <ddarius> EvilTerran: Aren't you supposed to be going to sleep?
17:59:04 <sclv> who are more flakey than haskell programs.
17:59:11 <dbpatterson> :)
17:59:20 <dbpatterson> hsqlite here we come!
17:59:35 <SamB> GHCi with profiling, here I come ;-)
18:00:18 <hpaste>  NekoIncardine annotated "Simple Sudoku Solver (Beta 1000something)" with "solveTile now with logic for catching Solved tile to be solved vs. Unsolved tile that needs to be ma" at http://hpaste.org/6845#a9
18:00:19 <EvilTerran> shh. it wasn't quite 2am when i said ":)". it is now, tho
18:00:23 <dbpatterson> sclv: just to be sure, this is the correct way to be injecting into templates - (join $ renderf (tmpl "articlesPage") <$> "posts" |= select "time,title,id from posts order by time desc" [])
18:00:58 <sclv> should be.
18:01:00 <NekoIncardine> I'm not 100% sure that's the right form (can the where influence the if-then-else grouping in this instance?), of course.
18:02:08 <dbpatterson> hmm.. maybe I wont get this up and running tonigh afterall...
18:04:55 <dbpatterson> sclv: can I output select? like output =<< select ... (to see if anything is clearer...)
18:05:08 <dbpatterson> eliminate the template aspect...
18:05:54 <sclv> output =<< show (select "etc" []) should work?
18:08:03 <hpaste>  NekoIncardine annotated "Simple Sudoku Solver (Beta 1000something)" with "sudoku solver (almost done!)" at http://hpaste.org/6845#a10
18:08:41 <NekoIncardine> .. Which exceeds 5k
18:08:54 * NekoIncardine re-annotates, removing comments >_<
18:09:47 <hpaste>  NekoIncardine annotated "Simple Sudoku Solver (Beta 1000something)" with "Now with the entire function VISIBLE!" at http://hpaste.org/6845#a11
18:09:54 <bd_> :t orElse
18:09:55 <lambdabot> Not in scope: `orElse'
18:09:56 <tromp> > 19237+600
18:09:58 <lambdabot>  19837
18:10:47 <tromp> > 19837*0.8
18:10:48 <lambdabot>  15869.6
18:12:35 * NekoIncardine points to a11... Line 106 produces an "Invalid _" error.
18:13:38 <Twey> Hmm
18:14:06 <chessguy> uh-oh, who let Twey out of ##javascript?
18:14:17 <chessguy> @quote twey
18:14:17 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
18:14:22 <Trinithis> hah
18:14:36 <NekoIncardine> @quote
18:14:36 <lambdabot> HavocPennington says: Haskell is the least-broken programming language available today.
18:14:50 <Cale> @quote
18:14:50 <lambdabot> DerekElkins says: What people need to do is stop reading two page blog posts by someone who's "just got" monads and read the well-written peer-reviewed papers by the people who clearly know what
18:14:50 <lambdabot> they are talking about.
18:14:57 <Cale> @quote
18:14:57 <lambdabot> gaal says: (ghc predicted a cpu death on my computer once.)
18:15:01 <Cale> @quote
18:15:01 <lambdabot> dcoutts says: monad transformers are not known for their blistering speed
18:15:04 <Cale> @quote
18:15:04 <lambdabot> sarahbot says: sarahbot: later tell lambdabot @quote sarahbot
18:15:10 <Cale> @quote
18:15:10 <lambdabot> scsibug says: i could have sworn it was incorrect until it type-checked
18:15:13 <Cale> @quote
18:15:14 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich internet application-driven environment.
18:15:14 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
18:15:27 <Cale> @quote
18:15:28 <lambdabot> cjeris says: Cale: I like how you conveniently gloss over the part where your head explodes.
18:15:48 <Cale> @quote
18:15:48 <lambdabot> dons says: open source is easy :)
18:15:50 <Cale> @quote
18:15:50 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
18:15:53 <Cale> @quote
18:15:53 <lambdabot> pkhuong says: [vincenz] life is all in the randomness [pkhuong] says the concurrent programmer
18:16:06 <Twey> Hahahaha
18:16:08 <Cale> @quote
18:16:08 <lambdabot> qwe1234 says: so, to summarize: laziness per your definition is a form of syntactic sugar that saves one or two lines of code while making programs slower.  whoop de doo
18:16:20 <Cale> @quote
18:16:20 <lambdabot> ##C++ says:  haskell == plain english ??
18:16:26 <Cale> @quote
18:16:26 <lambdabot> <erg0t> says: @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.   <lambdabot>  Hello World!
18:16:26 <Twey> Hahaha
18:16:30 <hpaste>  dbpatterson pasted "hvac sqlite test" at http://hpaste.org/6857
18:16:34 <Cale> @quote
18:16:34 <lambdabot> djinn says: does not do lists
18:16:37 <dbpatterson> sclv: okay the rows look okay
18:16:37 <Cale> @quote
18:16:37 <lambdabot> eyeris says: grr... I hate the way every haskell tutorial brags about how easy strings are to use. They are only easy once you drink the koolaid.
18:16:37 <Twey> Heh, is the quote DB grabbed randomly?
18:16:45 <Cale> Twey: yeah
18:16:53 <Cale> Twey: yeah
18:16:56 <Cale> er :)
18:16:57 <Cale> @quote
18:16:57 <lambdabot> fr30n says: <fr30n> php? eso es para vrutos
18:16:59 <dbpatterson> at least, it looks okay to me.. I'm not sure how hstringtemplate thinks they should look
18:17:00 <Twey> Er indeed :-P
18:17:04 <sclv> in the plain output you mean? the map shows up properly?
18:17:05 <Twey> Up-enter?  :-P
18:17:08 <Cale> yeah
18:17:13 <Cale> @quote
18:17:13 <lambdabot> mattam says: [Monads are] much more elegant [than soccer] in general.
18:17:19 <Cale> @quote
18:17:19 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
18:17:21 <Cale> @quote
18:17:21 <lambdabot> lament says: I'm running out of money and about to be evicted, what should i do? Use monads! My girlfriend dumped me, what should i do? Use applicative functors!
18:17:22 <Twey> o.@
18:17:23 * NekoIncardine distracted himself for a minute on LOLCODE, and suddenly I'm thinking of LOLFUNC. Basically Haskell but in lolspeak.
18:17:25 <Twey> Wait bug.
18:17:29 <Cale> I wonder what's causing that error :)
18:17:43 <Cale> @quote
18:17:43 <lambdabot> sfultong says: I need to start thinking more lazily
18:17:46 <Cale> @quote
18:17:47 <lambdabot> Spark says: "oops, we proved the wrong property"
18:17:50 <Cale> @quote
18:17:51 <lambdabot> NormanRamsey says: Type annotations in OCaml are completely broken and always have been.
18:17:56 <Cale> @quote
18:17:56 <lambdabot> wilx says: I mean, besides the murders, it all looks so nice.
18:17:58 <sclv> cale: seriously, please cool it.
18:18:01 <Twey> NekoIncardine: Ow
18:18:07 <NekoIncardine> Twey: Yeah.
18:18:17 <Twey> NekoIncardine: Sacrilege :-P
18:18:25 <Cale> sclv: fine.
18:18:37 <NekoIncardine> That would be a monster.
18:18:42 * Twey nods.
18:18:56 <sclv> dbpatterson: you mean with the names of the columns in place?
18:19:01 <Twey> Not something I'd like to find under my bed. .iiru'e
18:19:03 <NekoIncardine> "I CAN HAZ ARRAY?"
18:19:04 <sclv> thanks cale, sorry to be a spoilsport
18:19:14 <dbpatterson> sclv: check the hpaste... they seem there
18:19:22 <dbpatterson> dbpatterson pasted "hvac sqlite test" at http://hpaste.org/6857
18:19:32 <Axioplase> I don't see how OCaml's type annotations can be completely broken. But I don't care as much as I need to sleep.
18:20:59 <sclv> ok then, beats me for the moment.
18:21:44 <dbpatterson> hold on I'll run the same code on the working machine to see if it looks different
18:22:45 <dbpatterson> yeah, its the same.
18:23:16 <dbpatterson> so unless show is hiding some underlying difference, sqlite is not to blame.
18:23:18 <NekoIncardine> All right... Cale, can I get your advice on how to finish off solveTile? ATM, it gives me an error on line 88 (if v = Solved _), as appearently I can't place _ there.
18:23:28 <NekoIncardine> http://hpaste.org/6845#a11
18:23:34 <dbpatterson> hmm. maybe I installed hstringtemplate with the other bytestring lib?
18:23:38 <dbpatterson> (I'm reaching)
18:24:11 <sclv> they're both the hackage version?
18:24:37 <sclv> yeah, i'm stumped. it shouldn't be machine dependent at all -- although the bytestring thing sounds like a remote possibility.
18:24:45 * atsampson peers at the function he's just written which is elegant, concise, and completely wrong
18:24:51 <Cale> NekoIncardine: First, just a syntax thing, the contents of the if, then, and else part don't need to be parenthesized, since they're already grouped by those keywords. Secondly, the 'then' and 'else' are usually indented a bit further than the 'if' (and aligned)
18:25:06 <Cale> Now, what do you mean by  if v == Solved _ ?
18:25:08 <Cale> What's _ ?
18:25:26 <Cale> Do you mean that v is supposed to match the pattern Solved _ ?
18:25:46 <Cale> You'd actually do that with a case expression, not an if.
18:25:52 <NekoIncardine> Ah.
18:25:59 <Cale> Or of course, you could construct a new function
18:26:06 <Cale> isSolved (Solved _) = True
18:26:11 <Cale> isSolved _ = False
18:26:12 <NekoIncardine> If v is of form "Solved (anything)", then (run the olver based on those comments)
18:26:36 <Cale> == is only for testing that two things are equal
18:26:41 <NekoIncardine> ... Ah.
18:26:48 <NekoIncardine> thus A wildcard wouldn't be valid there.
18:26:53 <dbpatterson> sclv: well whatdya know, that seems to have fixed it
18:26:55 <Cale> right
18:27:02 <sclv> cool.
18:27:06 <dbpatterson> rebuilding hstringtemplate and all is well..
18:27:14 <dbpatterson> thanks for sitting through the mundane debugging..
18:27:24 <sclv> no prob
18:30:43 * NekoIncardine makes a couple other fixes, reannotates
18:31:15 <hpaste>  NekoIncardine annotated "Simple Sudoku Solver (Beta 1000something)" with "fixed *Finds, added isSolved, partially fixed solveTile." at http://hpaste.org/6845#a12
18:33:52 <nornagon> @index everywhereM
18:33:52 <lambdabot> Data.Generics.Schemes, Data.Generics
18:34:20 <NekoIncardine> Hrm... " then solveTile . findTile . Board $ b // [((x',y'), removeValue (v) (b!(x',y'))) | (x',y') <- removeFrom]" <- The (v) after removeValue needs to be just the value inside. *Thinks*
18:34:39 <NekoIncardine> v is a tile, what I want is the Integer inside it.
18:34:46 <NekoIncardine> Tile of type Solved, actually.
18:37:38 <NekoIncardine> ... Iz the Zvon haskell reference down? :
18:40:57 * NekoIncardine tried to figure out a quick-n-dirty solution... It *almost* worked too! "(fromEnum (head (show v)))"
18:41:14 <NekoIncardine> Problem? It give type Int and the program demands type Integer. Plus it's really dirty
18:41:44 <NekoIncardine> Now that I think about it I probably messed that up too X_x;
18:42:09 <NekoIncardine> Any advice here? My intent is to take Tile v, which will be of form Solved Integer, and get the Integer out
18:42:34 <NekoIncardine> (I can know it's of form Solved Integer and not Unsolved (Array) because of the earlier isSolved check.)
18:44:14 <gwern> it has always struck me as odd that Chris Okasaki teaches at West Point
18:44:25 <sclv> whee! gAtomically works.
18:46:32 <davidL> Does PSU have a nice campus? From what I've heard, there's a pretty good Haskell presence in the Portland area.
18:46:41 <hpaste>  sclv pasted "gAtomically!" at http://hpaste.org/6858
18:47:38 <NekoIncardine> sclv: Hrm... I'm not sure I see what it is but based on how many questions you asked and the involved items here, I'm impressed.
18:48:58 <dbpatterson> sclv: well, my site is now up and in the wild, morphed from using happs to hvac... dbpatterson.com :)
18:50:26 <sclv> oh, wow. awesome.
18:50:42 <dbpatterson> hehe..
18:50:59 <dbpatterson> I linked to your blog w/ tag hvac... is that an okay target? (from the little button at the bottom)
18:51:23 <sclv> the whole site is on it, or just the blog bit?
18:52:03 <sclv> yeah -- its a fine target.
18:52:18 <dbpatterson> the whole site..
18:52:45 <sclv> now lets get it slashdotted and see if it scales. :-)
18:52:50 <dbpatterson> hehe
18:52:57 <dbpatterson> dont kill my vps!!
18:53:14 * NekoIncardine still looking at solveTile... Still trying to figure out that one piece. >_<;
18:53:25 <dbpatterson> maybe I should turn on some of the caching?...
18:53:30 <davidL> dbpatterson: out of curiosity, who is hosting your vps?
18:53:35 <dbpatterson> slicehost...
18:53:44 * dbpatterson is very pleased with them
18:54:05 <davidL> ah ok, I've been meaning to get a 256slice for some darcs repos
18:57:18 <SamB> 256slice?
18:57:20 <sclv> yeah -- you should be able to just drop cacheHCGI in front of whatever actions that don't modify state that you feel like. maybe just the basic articles page.
18:58:18 <NekoIncardine> "Board $ b // [((x',y'), removeValue (v) (b!(x',y'))) | (x',y') <- removeFrom]" <- This has at least one glitch, at (v). (v) is of type Tile (and subtype Solved), and I need to figure out how to pull the Integer out of it.
18:58:40 <davidL> SamB: it's the cheapest of the slicehost packages
18:58:40 <NekoIncardine> Anyone here have advice on that? I've looked through my existing code and a couple references and nothing has came to mind x_x;
18:59:07 <dbpatterson> SamB: 256mb ram (10gb hd, 100gb bandwidth)
18:59:13 <NekoIncardine> ... nm.
19:00:42 <dbpatterson> gah, ghc + linking = memory like crazy
19:00:58 <dbpatterson> thankfully hvac swaps for about 10 seconds, vs 30 minutes with happs...
19:01:00 <SamB> I'm hoping gold will rectify that
19:01:24 * NekoIncardine fixes that with another new function... And runs into another error X_x;
19:01:51 <dbpatterson> sclv: what is the default cache time? 60 seconds?
19:02:12 <NekoIncardine> "then solveTile . findTile . Board $ b // (*snip*)" <- the solveTile is getting (Integer,Integer) -> (Integer,Integer), not the board I want it to get...
19:02:13 <dbpatterson> (the site is cached now, /. away.. if only there were something to /. haha)
19:02:16 <NekoIncardine> ... *Idea!*
19:02:24 <sclv> yep -- 60 seconds.
19:02:40 <sclv> you need to build with 02 to get the caching working right, mind you.
19:03:00 <sclv> not everything -- just your app.
19:03:30 <NekoIncardine> .. No, not what I need. x_x;
19:04:56 <dbpatterson> sclv: rebuilding ... :)
19:05:34 <NekoIncardine> Okay... I'm pretty confident I'm almost done with this, I just need to figure out these last couple bits.
19:06:02 <Twey> NekoIncardine: They're 0 and 1
19:06:05 <NekoIncardine> The above item needs to be of form Board -> (Integer, Integer) for the outer SolveTile. I'm not, however, sure how to get that.
19:06:40 <NekoIncardine> Twey: ... Last couple portions. 01001010
19:06:54 * Twey grins.
19:07:21 <SamB> Twey: well, but where do you put them?
19:07:29 <SamB> and in what proportions?
19:08:10 <Twey> SamB: He only wanted the last couple of bits
19:08:34 <elaforge> is it possible to make e.g. SomethingT m a = SomethingT (StateT X (ErrorT E m)) into an instance of MonadTrans?
19:09:01 <elaforge> i.e. a >1 monad stack
19:09:21 <NekoIncardine> Okay, I've lost myself, I knew how "solvetile. findTile . Board $ b" would parse earlier, and I've lost that.
19:09:25 <elaforge> newtype deriving is refusing to derive MonadTrans for me and I'm having trouble thinking of what the instance should look like
19:11:26 <Twey> @find readHex
19:11:27 <lambdabot> Not in scope: type variable `readHex'
19:11:31 <Twey> Eh
19:11:32 <Twey> Where is readHex defined?
19:11:46 <elaforge> and lift m = StateT $ lift m sure doesn't work...
19:12:31 <scook0> elaforge: try lift = SomethingT . lift . lift
19:13:13 <scook0> that should work, I think
19:13:27 <dbpatterson> sclv: also, recent blog post looks very promising... I (think) you were hinting in the last paragraph about using the Dynamic lists for sql stuff too, which is amazing (what I was just blabbing about web.py in dbpatterson.com/articles/8 )
19:13:55 <scook0> since you need as many lifts as you have wrapped transformers
19:14:04 <elaforge> scook0: wow, it typechecks at least
19:14:16 <elaforge> oh I see, so it has to lift the op all the way through the stack
19:14:27 <elaforge> *head hurts*
19:14:32 <sclv> yeah -- I finally solved the withValidation issue with typing, and that translates to dynamics for toSql as well. also, just finally removed the direct linking to the fastcgi libs -- everything now goes through the standard binding.
19:14:43 <scook0> writing your own transformers is a bit brain-bending
19:14:57 * NekoIncardine tries moving the $ around on his line a bit and removing it, to no success...
19:15:09 <dbpatterson> sclv: awesome...
19:15:18 <dbpatterson> side question, any way for me to know content is being cached?
19:15:19 <scook0> and remember that your lift won't be able to lift things to the StateT or ErrorT level
19:15:22 <scook0> only to the m level
19:15:35 <hpaste>  NekoIncardine annotated "Simple Sudoku Solver (Beta 1000something)" with "Still need to figure out solveTile..." at http://hpaste.org/6845#a13
19:15:39 <Twey> Hm... which is preferable: `read "0x" ++ someHexNumber` or `fst . head $ readHex someHexNumber`?
19:16:12 <elaforge> scook0, right, I'm hoping to do that with custom ops (i.e. so outside of the module you can only modify this particular state by using the given ops)
19:16:31 <scook0> yep, that sounds reasonable
19:17:13 <adu> 1 day left to apply to gsoc
19:17:38 <adu> I need to get to work on my app
19:17:49 <tromp> 2nd looks better, Twey
19:18:07 <scook0> NekoIncardine: I think I can see what your problem is
19:18:17 <NekoIncardine> scook0: ?
19:18:32 <Twey> tromp: They both seem pretty tortured to me :-\
19:18:43 <Twey> Especially given that the latter involves importing another module
19:18:55 <bugQ> Woo, GSoC.
19:19:16 <scook0> NekoIncardine: your recursive call to solveTile is missing the (Integer, Integer) argument
19:19:47 <scook0> is it supposed to re-use the same (x, y)?
19:20:37 <NekoIncardine> Hrm... Missing it? The way the error reads it puts it in twice. Which recursive call are we speaking of?
19:20:37 <tromp> @src ReadS
19:20:38 <lambdabot> Source not found.
19:20:41 <NekoIncardine> The then one, or the else one?
19:21:15 <scook0> the then one
19:21:27 <NekoIncardine> Hrm.
19:21:37 <NekoIncardine> It is not supposed to reuse the same x,y, no.
19:21:51 <scook0> what should it be using, then?
19:21:56 <NekoIncardine> It is supposed to use the result of findTile (Which locates a tile with a one-length Unsolved to solve).
19:22:12 <NekoIncardine> Along with the redefined board.
19:22:43 <scook0> ah, so the two arguments are essentially going to be board and findTile board
19:22:58 <NekoIncardine> Yes.
19:23:59 <NekoIncardine> findTile on (board), and then that same board should be going into solveTile.
19:24:12 <NekoIncardine> (Otherwise I have to calculate the same thing twice, which is computationally rather costly.)
19:24:20 <hpaste>  scook0 annotated "Simple Sudoku Solver (Beta 1000something)" with "something like this, perhaps?" at http://hpaste.org/6845#a14
19:25:28 <NekoIncardine> Hrm... And that will "let" a new board every time, right? i.e. when I go to the next solveTile, "board" will no longer be defined, so I can "let" it be modified another time?
19:26:52 <scook0> it won't share the same value of "board" across different calls, if that's what you mean
19:27:10 <NekoIncardine> That is indeed what I mean.
19:27:22 <scook0> the "let" gives a name to the expression, so it's easier to refer to it twice
19:29:35 <NekoIncardine> Hrm... Now to figure out the else case, which is much closer to correct out the box (yay), but seems I need to adjust.
19:33:56 <NekoIncardine> Yay, fixed... I think.
19:37:07 <adu> is anyone here working on the GHC API?
19:39:43 <davidL> dbpatterson: do you want me to put you as a referral? (I'm signing up for slicehost now)
19:40:08 * SamB comments out the ifeq in package.mk that prevents profiling libs being compiled for GHCi...
19:40:19 <SamB> er, linked, rather
19:40:48 <elaforge> scook0, works great so far!
19:40:49 <elaforge> scook0++
19:41:05 <TomMD> @karma scook0
19:41:05 <lambdabot> scook0 has a karma of 4
19:41:12 <sclv> dbpatterson: aside from updating and testing, you can check caching by replacing cacheHCGI by cacheHCGINoisy, which will print a message to stderr every time a new cache is created. If the caching is working right, you should only see the "Cache created" line once per resource. if it isn't, it'll show up on each new page hit.
19:41:13 <scook0> \o/
19:41:27 <TomMD> scook0**2
19:41:33 <TomMD> too bad that doesn't work.
19:41:52 <scook0> I am not a number
19:41:57 <scook0> I am a free variable!
19:42:05 <elaforge> the other issue is getting ghci to load all the symbols for FFI using modules... don't suppose you know anything about that?
19:42:11 <Riastradh> `Church numeral', surely, scook0.
19:42:18 <TomMD> Atleast we have: instance Haskell scook0 where ...
19:43:05 <elaforge> yeah, really, why do we have name++, when it could be "modify name Succ"
19:43:45 <NekoIncardine> scook0++
19:43:51 <NekoIncardine> (While thinking about it x_x)
19:44:22 <dbpatterson> davidL: sure
19:44:28 <dbpatterson> dbpatterson (at) riseup.net
19:44:37 <dbpatterson> if I didnt miss you...
19:44:37 <davidL> very well
19:44:48 <dbpatterson> thanks :)
19:44:53 <davidL> yup
19:45:02 <SamB> there was another notation for that
19:45:34 <SamB> then I believe I must have implemented that notation based on something I saw in #perl6 ...
19:45:46 <SamB> and now I don't really remember the other notation
19:46:03 <elaforge> wow, I just got an error msg full of high bit chars from ghci
19:46:16 <Twey> Hahaha, nice
19:46:22 <Twey> What did you do to it?  :-P
19:46:35 <elaforge> loading modules that do foreign imports
19:46:38 <SamB> I only remember it was me because I remember getting complaints about he noise in #perl6 ;-)
19:46:44 <SamB> so then I had to make it quiet
19:46:53 <SamB> the other notation probably still makes noise
19:47:02 <NekoIncardine> Okay, I just realized one last little thing I need for the Sudoku solver... Lemme toss it up on the annotations
19:47:14 <ddarius> @karma+
19:47:14 <lambdabot> usage @karma(+|-) nick
19:47:41 <SamB> then someone else rejiggered the regex
19:47:45 <TomMD> @karma str
19:47:45 <lambdabot> str has a karma of 0
19:47:46 <elaforge> sometimes it loads them and lets me at least do :t on things, other times it says "unresolved" symbol and refuses
19:48:07 <SamB> elaforge: well, you have to pass the libs on the commandline
19:48:13 <SamB> -l and so on
19:48:22 <elaforge> and then sometimes it puts my terminal into weird character mode :)
19:48:35 <SamB> otherwise, GHCi won't know what to pull in
19:48:36 <hpaste>  NekoIncardine annotated "Simple Sudoku Solver (Beta 1000something)" with "One last piece of the problem..." at http://hpaste.org/6845#a15
19:48:45 <elaforge> SamB, yeah, I got started tracking those down, but then ran into ___dso_import which I couldn't find anywhere
19:49:00 <NekoIncardine> ... *Thinks about it*
19:49:44 <elaforge> it winds up needing OS X frameworks too, so there's some weird macishness going on
19:49:55 <NekoIncardine> Okay, in the above (and hopefully final) example there, the line <<<HOW DO I KICK OUT???>>>, I just need 'board' correct? Since all I want to do at that point is return the board?
19:50:34 <scook0> you want to just not do anything?
19:51:25 <NekoIncardine> scook0: Yes - I want it to return the let-modified board (which either means the entire thing is done, OR that the logic I have isn't enough to finish it and it's returning what it DID do)
19:51:46 <scook0> then else board should do the trick
19:51:51 <NekoIncardine> All right.
19:52:53 <gbacon> @src union
19:52:53 <lambdabot> union = unionBy (==)
19:52:59 <gbacon> @src unionBy
19:52:59 <lambdabot> unionBy eq xs ys = xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs
19:53:13 <gbacon> @src nubBy
19:53:13 <lambdabot> nubBy eq []             =  []
19:53:13 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
19:53:21 <gbacon> @src deleteBy
19:53:21 <elaforge> whoah, ghci supports -framework!  still doesn't find ___dso_handle though
19:53:21 <lambdabot> Source not found. Sorry.
19:53:59 <gbacon> @src Data.Set.deleteBy
19:53:59 <lambdabot> Source not found.
19:54:06 <gbacon> @src deleteBy
19:54:06 <lambdabot> Source not found. Maybe if you used more than just two fingers...
19:54:12 <dbpatterson> delete sounds very un-functional.
19:54:33 <scook0> > delete 7 [1..10]
19:54:34 <lambdabot>  [1,2,3,4,5,6,8,9,10]
19:55:06 <tromp> > delete 0 [0,0,0,1,0]
19:55:07 <lambdabot>  [0,0,1,0]
19:55:36 <mauke> > [0,0,0,1,0] \\ [0,0,1,0]
19:55:37 <lambdabot>  [0]
19:56:15 <dbpatterson> *sounds*
19:56:29 <ddarius> > flip (foldr delete) [0,0,0,1,0] [0,0,1,0]
19:56:30 <lambdabot>  []
19:56:31 <NekoIncardine> Okay... now for the other issue, back to "if findTile board /= []" - [] is an invalid form. I need to know how to represent NULL here (since the idea is first is a null tuple)
19:56:33 <elaforge> is there a way to get ld to say where it's finding various symbols?
19:56:37 <NekoIncardine> (If it's completed)
19:56:45 <ddarius> > foldr delete [0,0,0,1,0] [0,0,1,0]
19:56:45 <lambdabot>  [0]
19:57:46 <scook0> NekoIncardine: you want findTile to be able to indicate that it can't find anything
19:58:03 <gbacon> @ty deleteBy
19:58:04 <lambdabot> forall a. (a -> a -> Bool) -> a -> [a] -> [a]
19:58:04 <scook0> ?
19:58:15 <NekoIncardine> scook0: Meaning I need to add a case for that then.
19:58:25 <gbacon> @src deleteBy
19:58:26 <lambdabot> Source not found. It can only be attributed to human error.
19:58:29 <SamB> huh, I never thought about that before
19:58:34 <scook0> if that's the case, change its type to Board -> Maybe (Integer, Integer)
19:58:44 <SamB> but code run under GHCi has it's own Handles...
19:58:57 <SamB> at least for stdin/stdout/stderr
19:58:57 <gbacon> @ty union
19:58:58 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
19:59:00 <scook0> and change head to listToMaybe
19:59:28 <ddarius> bigcup = foldr union []
20:00:29 <nolrai_> :t foldM
20:00:30 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
20:00:32 <scook0> this will return Nothing if the list is empty, or Just x where x is the first element
20:01:15 <NekoIncardine> Ah.
20:01:43 <awesame> so, what's up with exceptions in haskell?
20:01:49 <scook0> then you just need to fix up solveTile
20:01:50 <NekoIncardine> So then solveTile's if would just be "if findTile board /= Nothing" then?
20:02:01 <scook0> NekoIncardine: you'd change it to:
20:02:03 <awesame> are they part of the IO monad somehow, or are they their own monad, or are they a language feature somehow?
20:02:08 <scook0> case findTile board of
20:02:17 <kbateman> you probably want to use "case findTile board of"
20:02:24 <NekoIncardine> Ah. Going to a case statement.
20:02:26 <scook0>   Just tile -> solveTile board tile
20:02:30 <scook0>   Nothing -> board
20:02:44 <kbateman> yep
20:03:00 <NekoIncardine> My idea was to just have it return (0,0) if the list was empty... Let's do this proper though
20:04:08 <scook0> NekoIncardine: the whole point of the Maybe type is to avoid having to do nasty stuff like that
20:04:10 <awesame> and, what's up with the alternating use of Either/Maybe and exceptions in the standard libraries?
20:04:36 <scook0> awesame: the IO monad provides an exception-handling facility
20:04:48 <NekoIncardine> So, findTile would now be "findTile :: Board -> Maybe (Integer, Integer)", "findTile (Board z) = listToMaybe [pos | (pos, Unsolved [_]) <- assocs z]"?
20:04:48 <awesame> is that historical compatability stuff, or is there some reason for using one or the other that I'm missing?
20:04:51 <scook0> it's also possible to build exceptions into a new monad of your own, if you want
20:05:08 <awesame> ah, so maybe exceptions aren't used where the IO monad isn't necessarily involved
20:05:23 <scook0> there was a blog post a while back talking about different error-handling mechanisms in Haskell
20:05:34 <scook0> that might be helpful, if you can find it
20:06:08 <atsampson> http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors
20:06:09 <lambdabot> Title: 8 ways to report errors in Haskell, http://tinyurl.com/2yz77l
20:07:08 <NekoIncardine> ERROR file:.\SudokuSolver.hs:84 - Undefined variable "listToMaybe" <- ... Uh...
20:07:26 <scook0> NekoIncardine: import Data.Maybe
20:07:32 <NekoIncardine> Oh.
20:07:36 <scook0> @hoogle listToMaybe
20:07:36 <lambdabot> Data.Maybe.listToMaybe :: [a] -> Maybe a
20:09:10 <awesame> scook0, atsampson: thanks!
20:09:16 <NekoIncardine> ... Now I see!
20:09:39 <NekoIncardine> "Just tile" <- 'tile' is lower case ergo more akin to a variable. I thought it was "Just Tile" as in the type for a second.
20:10:46 * SamB reports a bug about the fact that GHCi doesn't work when GHC is built for profiling
20:11:10 <scook0> NekoIncardine: yes, tile is a variable that gets bound to the contents of the Just
20:12:28 <ddarius> SamB: Didn't you have to change the makefile to get that case in the first place?
20:12:33 <scook0> in a pattern-match, anything starting with a capital is a constructor
20:12:48 <scook0> and anything starting with lowercase is a variable that will be bound if the match succeeds
20:13:03 <SamB> ddarius: which case?
20:13:10 <SamB> oh, no, I didn't have to
20:13:13 <ddarius> Anything starting with a capital letter is either a constructor (type or data), or a class, or a module.
20:13:29 <SamB> I haven't seen any effect of my makefile change
20:13:43 * NekoIncardine now goes to zone out for an hour, and then the question insanity will begin anew (ish) for Knight's Cycle. Except I'll have more of the basics together this time.
20:13:45 <ddarius> Anything starting with a lowercase letter is a variable (type or data)
20:14:01 <SamB> ddarius: I would have considered it working if GHCi attempted to load a .o that was in fact not built...
20:14:13 <SamB> but it tried to load the non-profiling .o file
20:14:21 <mauke> C { x = y }
20:14:30 <SamB> that is bound to cause problems...
20:14:50 <scook0> mauke: ah yes, field names in record patterns are indeed an exception to the rule
20:20:55 <Twey> Hmmm
20:21:08 <Twey> I'm using utf8-string, and I can output UTF-8 correctly
20:21:24 <Twey> But when I read it through getArgs, it seems to mess up
20:21:32 * Twey attempts to create a test case.
20:25:14 <hpaste>  Twey pasted "UTF-8 input via getArgs failure -- outputs " at http://hpaste.org/6860
20:26:21 <ddarius> Twey: What's surprising?
20:26:33 <Twey> ddarius: Why does it not print out what I put in?
20:26:40 <mauke> it's WTF-8
20:26:56 <mauke> you need to decode input from getArgs first
20:27:02 <Twey> Aha
20:27:05 <Twey> Thanks
20:27:23 <SamB> won't he just have to encode it again then?
20:27:24 <dons> utf8-string ftw.
20:28:07 <Twey> SamB: No, utf8-string has its own putStrLn that does the encoding automatically.
20:28:42 <lament> :t putStrLn
20:28:43 <lambdabot> String -> IO ()
20:29:46 <SamB> ah
20:29:51 <SamB> but not it's own getArgs?
20:30:21 <SamB> hooray, at least my GHC change works
20:30:44 <lament> :t liftM
20:30:45 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
20:31:09 <lament> what does (m :: * -> *) mean?
20:31:15 <ddarius> m has kind * -> *
20:31:43 <lament> mm
20:32:29 <lament> that means that... monadic values are type constructors?
20:32:46 <lament> err, no, the monad itself is a type constructor.
20:32:51 <scook0> yep
20:33:08 <awesame> what's the difference between System.IO's hGetLine and System.IO.UTF8's version?
20:33:15 <scook0> so the type of a "monadic value" is the monad tycon applied to the value type
20:33:25 <mauke> hGetLine turns each byte into a Char
20:33:35 <mauke> the standard one, I mean
20:33:38 <awesame> okay
20:33:50 <mauke> the UTF8 version decodes its input as utf-8
20:33:53 <scook0> which causes ridiculous results if your input is  neither ASCII nor Latin-1
20:33:55 <lament> monads are weird.
20:34:06 <scook0> (the standard one, I mean)
20:34:11 <awesame> so, I need to read my input a byte at a time
20:34:28 <awesame> but I want to decode the resulting list of bytes as a UTF8 string
20:35:10 <mauke> http://hackage.haskell.org/packages/archive/utf8-string/0.3/doc/html/Codec-Binary-UTF8-String.html
20:35:12 <lambdabot> http://tinyurl.com/6ytmw6
20:36:04 <scook0> the builtin packages' treatment of character IO is a bit braindead
20:36:14 <dons> a getArgs might be useful there too
20:36:23 <Twey> Is this roughly how it should look: http://hpaste.org/6861 or is there a better way of doing it?
20:36:34 <Twey> (ddarius, mauke)
20:36:41 <awesame> how do I read an input byte as a Word8 rather than a Char?
20:36:53 <dons> use Data.ByteString
20:36:58 <scook0> Twey: your decodeUTF8 is just decodeString
20:37:05 <scook0> from Codec.Binary.UTF8
20:37:24 <Twey> Ohh.
20:37:39 <mauke> getArgs' = fmap (fmap decodeString) getArgs
20:38:29 <awesame> dons: hm, I don't see functions in Data.ByteString for reading a byte at a time
20:38:31 <Twey> scook0: OK, that looks a lot better, thanks :-)
20:38:41 <awesame> there's a getLine, but no getByte?
20:39:19 <mauke> why do you need to read a byte at a time?
20:39:23 <scook0> mauke: getArgs' = fmap fmap fmap decodeString getArgs -- ;)
20:39:31 <mauke> I CAME
20:39:39 <nolrai_> :t right
20:39:40 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either d b) (Either d c)
20:39:58 <awesame> I'm implementing a Stream (from Network.Stream) for use by functions from Network.HTTP
20:40:16 <awesame> and Streams want to be able to specify a number of entities to read
20:41:38 <awesame> in the case of HTTP that doesn't mangle UTF8, I think I need to read bytes, and then decode utf8
20:41:41 <Saizan> awesame: the nearest you get is hGetBug
20:41:50 <Saizan> hGetBuf
20:42:13 <Saizan> or use ByteString
20:43:12 <dons> awesame: hGetN i think is the function
20:43:23 <dons> you can read specific numbers of bytes off a handle
20:44:08 <Saizan> ?hoogle hGetN
20:44:08 <lambdabot> Data.ByteString.hGetNonBlocking :: Handle -> Int -> IO ByteString
20:44:08 <lambdabot> Data.ByteString.Char8.hGetNonBlocking :: Handle -> Int -> IO ByteString
20:44:08 <lambdabot> Data.ByteString.Lazy.hGetNonBlocking :: Handle -> Int -> IO ByteString
20:44:23 <awesame> hm
20:44:48 <awesame> googling finds me hGetN implemented used hGetChar, which doesn't help...
20:44:57 <awesame> er, using
20:45:25 <dons> try Data.ByteString.hGetNonBlocking
20:46:11 <awesame> oh, hGet and hGetNonBlocking take an Int
20:46:17 <awesame> I guess that must be the length...
20:46:19 <dons> or hGet if you like
20:46:23 <dons> that's right. check the haddocks
20:46:40 <dons> :t Data.ByteString.hGet ?h 4
20:46:41 <lambdabot> (?h::GHC.IOBase.Handle) => IO BSC.ByteString
20:47:03 <awesame> the haddocks don't explain what the Int param is for
20:47:15 <dons> ah hmm.
20:47:37 <dons> good point. fixing
20:49:15 <dons> fixed in darcs.
20:50:27 <awesame> excellent!
20:51:06 <shubuntu> hey does anyone here run haskell on eclipse
20:53:57 <Cale> Hey, we might enjoy a little type-system BDSM, but even we're not *that* masochistic. :)
20:53:59 <nolrai_> I tried it, in my opinion GEdit is better.
20:54:17 <nolrai_> ^^^ -shubuntu
20:54:29 <bos> i know someone has been beavering away at an fp-eclipse plugin for ages.
20:54:39 <bos> but i can't imagine wanting to actually use it.
20:54:50 <shubuntu> well i'm trying to add the -fglasgow-exts option to the build preferences
20:54:54 <shubuntu> and I don't know how to
20:55:00 <Saizan> Map a (Map b x) is isomorphic to Map (a,b) x, right?
20:55:03 <bos> best of luck with that.
20:55:19 <bos> Saizan: no.
20:55:22 <Cale> Saizan: hmm... no
20:55:25 <ddarius> @where eclipsefp
20:55:25 <lambdabot> I know nothing about eclipsefp.
20:55:29 <ddarius> @google EclipseFP
20:55:31 <lambdabot> http://eclipsefp.sourceforge.net/
20:55:31 <lambdabot> Title: EclipseFP - Functional programming support for Eclipse
20:55:40 <bos> Saizan: the latter does not account for an empty (Map b x)
20:57:38 <bos> also, an N-level map is often easier to work with than an N-tupled key.
20:57:43 <Cale> shubuntu: as an alternative, you could consider using LANGUAGE pragmas, which are the new way to do that anyway
20:58:07 <nolrai_> so would Map a (Map b x) be isomorphic to Map (a,b) (Maybe x)?
20:58:12 <shubuntu> care to elaborate Cale?
20:58:21 <Cale> shubuntu: Run  ghc --supported-languages for a list of the extensions, and then add {-# LANGUAGE ExtensionName #-} to your source
20:58:24 <Saizan> bos: well, having an 'a' that points to an empty Map is not so useful
20:58:37 <Cale> (where ExtensionName is the name of the extension that you're using)
20:58:42 <bos> nolrai_: no.
20:59:04 <adu> i did it, I just submitted my gsoc application
20:59:35 <dibblego> > 24 * 42
20:59:37 <lambdabot>  1008
20:59:41 <bos> Saizan: maybe not to you, but that doesn't invalidate either of my remarks.
20:59:51 <shubuntu> but how does that solve the eclipse build problem?
20:59:55 <Saizan> bos: sure :)
21:00:43 <bos> Saizan: and in fact having an empty second level map can be useful.  i wrote a blog posting about the slope one algorithm that used precisely this structure some time last year.
21:00:44 <awesame> hm, Stream wants a Result String
21:00:44 <dbpatterson> shubuntu: because the extensions are set in the source files, so you dont need params...
21:01:10 <Cale> shubuntu: It means you won't have to add -fglasgow-exts
21:01:26 <shubuntu> i'm confused
21:01:30 <adu> so are GADTs an extension language? I thought Haskell already had GADTs?
21:01:30 <Cale> shubuntu: However, if it were me, I'd probably not use Eclipse to run GHC for me.
21:01:35 <bos> i wonder if there's a more convenient way to make the main thread block forever than setting up a bogus MVar and reading from it.
21:01:43 <Cale> adu: nope.
21:01:44 <SamB> adu: heck no!
21:01:50 <shubuntu> that's the only ide that runs haskell for now
21:01:55 <Cale> adu: They're actually a very recent extension.
21:01:58 <Cale> shubuntu: vim
21:01:59 <dbpatterson> shubuntu: emacs?
21:02:03 <scook0> GHC Haskell has GADTs
21:02:06 <shubuntu> they are not IDEs
21:02:08 <scook0> Haskell 98 does not
21:02:08 <awesame> I'll have to hope that Network.HTTP uses Stream in such a way that it will always read full request bodies, and not ask for random numbers of bytes and then expect me to be able to decode a String from there...
21:02:09 <bos> what would one want an IDE for?
21:02:10 <Saizan> bos: i'm using it essentially to model a function of type a -> b -> x, i.e. a two-level index in a table
21:02:12 <SamB> there are much older extensions that were left out of H98 too
21:02:16 <shubuntu> I'm doing a project with hundreds of files
21:02:19 <Cale> shubuntu: That doesn't mean you can't use them to write code :)
21:02:20 <shubuntu> I need and IDE
21:02:28 <bos> a haskell project with hundreds of files?
21:02:32 <shubuntu> I can write code with anything
21:02:32 <dbpatterson> shubuntu: directories?
21:02:34 <bos> no you don't.
21:02:35 <shubuntu> I need an IDE
21:02:37 <SamB> Emacs isn't an IDE?
21:02:45 <SamB> IDEs seem like a PITA, actually ;-)
21:02:47 <bos> java programmers need IDEs.
21:02:51 <adu> so what is the difference between "data X = X A B C" and "data X where X :: A -> B -> C"?
21:02:51 <dbpatterson> SamB: of course it is. emacs is _
21:03:23 <Cale> shubuntu: Most of the benefits of IDEs are captured by emacs or vim, together with Haskell language features.
21:03:28 <scook0> adu: well, the latter isn't quite right, because the type for constructor X is wrong
21:03:42 <scook0> it should be X :: A -> B -> C -> X
21:03:42 <adu> scook0: o oops!
21:03:47 <Cale> Of course, theoretically, Haskell would allow for some really awesome IDE features, but no such IDE has been written.
21:03:54 <SamB> too bad emacs can't jump based on GHC's pattern match failures :-(
21:03:59 <ddarius> Cale: Such as?
21:04:03 <scook0> but with that fixed, I don't think there's a significant different
21:04:24 <scook0> modulo minor stuff like derived instances and whatnot
21:04:41 <shubuntu> I'd like to have several files open at the same time
21:04:47 <shubuntu> to run the program
21:04:54 <shubuntu> and find out where it is going wrong
21:05:00 <shubuntu> and fix it and reload
21:05:04 <Cale> ddarius: Typed completion, offside rule handling... if you want to get crazy, how about an interface which lets you view the stepwise reduction of the code graph? :)
21:05:06 <shubuntu> an IDE gives me that
21:05:06 <dbpatterson> errm,buffers?
21:05:12 <shubuntu> with vim nano, ....
21:05:17 <shubuntu> there isn't that flexibility
21:05:21 <dbpatterson> vim can have split screens
21:05:24 <Cale> shubuntu: So does keeping vim open alongside GHCi
21:05:25 <SamB> shubuntu: M-x compile gives you that
21:05:26 <shubuntu> you'll end up with 10s of open windows
21:05:36 <Cale> shubuntu: No you won't.
21:05:39 <Cale> Try it :)
21:05:52 <ddarius> What's a window?
21:06:13 <SamB> I end up with <10 open screen(1) windows
21:06:13 <shubuntu> you'll have to keep quitting and reopenning differen files
21:06:22 <adu> scook0: so if both are examples of GADTs, then why call the minor syntax revision "GADT" when its only a minor fix to make Haskell's 90% expression of GADT into 100% expression of GADT?
21:06:24 <shubuntu> or you'd have to have several terminals open
21:06:27 <SamB> which is good, because I only have 10 keys to switch to them
21:06:35 <bos> shubuntu: you mustn't have used proper editors much.
21:06:38 <shubuntu> you can't say IDEs can be replaced by vim
21:06:40 <ddarius> shubuntu: No.  Pretty much no editor has required that in decades.
21:06:44 <shubuntu> that's just ridiculous to me
21:06:46 <Cale> shubuntu: You should have exactly two terminals open.
21:06:57 <scook0> adu: huh?
21:07:01 <dbpatterson> shubuntu: both vim and emacs can do everything you have said so far
21:07:07 <Cale> One in which you run your text editor, and one in which ghci runs.
21:07:09 <SamB> indeed, I generally have emacs open on exactly one terminal
21:07:13 * allbery_b 's spider sense is tingling
21:07:15 <dbpatterson> what IDEs are usually touted for is automatic code refactoring, etc
21:07:17 <SamB> in my screen session
21:07:19 --- mode: ChanServ set +o allbery_b
21:07:20 <scook0> both of your examples defined perfectly ordinary data types, neither of which need GADTs
21:07:28 <scook0> it's just that the second one used GADT syntax
21:07:32 <Cale> allbery_b: don't do it :)
21:07:51 <adu> scook0: so what's the difference between ordinary datatypes and GA datatypes?
21:07:56 <bos> oh, awesome.  i can't block the main thread using this: "newEmptyMVar >>= takeMVar"
21:08:07 <SamB> well, try this one...
21:08:14 <bos> because GHC detects the impossibility of progress, and barfs.
21:08:33 <allbery_b> damn compilers that are too smart? :)
21:08:39 <Cale> GHC really ought to have an IO action which would reliably cause a thread to sleep forever without throwing an exception
21:08:40 <ddarius> RTS is that case.
21:08:46 <scook0> GADT syntax allows you give your constructors tighter signatures, that can't be expressed with the usual data type syntax
21:09:05 <bos> Cale: that's exactly what i need.
21:09:09 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6862
21:09:09 <ddarius> Cale: Primarily FP people find noddy functions crucial.
21:09:19 <SamB> data Expr :: a;  LitInt :: Int -> Expr Int; LitBool :: Bool -> Expr Bool; ...
21:09:24 <SamB> er.
21:09:29 <scook0> data Foo a where Bar :: Integer -> Foo Integer ; Baz :: a -> a -> Foo (a, a)
21:09:29 <bos> noddy functions?
21:09:33 <shubuntu> Cale: it does, google concurrency in ghc
21:09:33 <SamB> replace the first ; with where
21:09:37 <ddarius> @wn noddy
21:09:38 <mauke> :t delayThread
21:09:39 <lambdabot> Not in scope: `delayThread'
21:09:40 <SamB> bos: noddy?
21:09:40 <lambdabot> No match for "noddy".
21:09:50 <mauke> :t threadDelay
21:09:51 <lambdabot> Not in scope: `threadDelay'
21:09:56 <SamB> oh, you were asking about that
21:10:32 <bos> bleh.  block = threadDelay maxBound >> block
21:10:35 <Cale> shubuntu: The best I know of is something like forever (threadDelay maxBound)
21:10:55 <shubuntu> Cale: http://mult.ifario.us/p/tuppence-tour-of-haskell-concurrency-constructs
21:10:56 <lambdabot> Title: tuppence-tour-of-haskell-concurrency-constructs, http://tinyurl.com/ytgaro
21:10:58 --- mode: allbery_b set -o allbery_b
21:11:11 <ddarius> http://www.retrologic.com/jargon/N/noddy.html
21:11:11 <lambdabot> Title: noddy - The Jargon File v4.4.7
21:11:47 <Cale> shubuntu: I don't see an alternative there...
21:12:24 <ddarius> Actually, the wikipedia has a more relevant definition albeit on the disambiguation page
21:12:28 <shubuntu> Cale: you just case your read, and then define your reset, stop, sleep
21:12:36 <Cale> You might be able to go with  'atomically retry'
21:12:49 <mauke> Cale: that throws
21:12:51 <Cale> shubuntu: The goal is to sleep the thread forever.
21:13:08 <Cale> shubuntu: As in, there will be no way to wake it back up.
21:13:11 <awesame> is there an operator I'm not thinking of that composes ordinary functions the way >>= deals with monad-using functions?
21:13:16 <shubuntu> Cale: That can be done with stop
21:13:20 <Cale> awesame: function application?
21:13:50 <awesame> so, rather than (f (g x)) I want to write g SOMETHING f
21:13:59 <awesame> isn't . the other way around?
21:14:00 <sjanssen> does cabal-install have a separate bug tracker?
21:14:06 <bos> g . f
21:14:07 <ddarius> > g >>> f
21:14:08 <lambdabot>        add an instance declaration for
21:14:08 <lambdabot>       (SimpleReflect.FromExpr (a c d),...
21:14:10 <Cale> shubuntu: Sorry, I don't see how that accomplishes the goal.
21:14:13 <shubuntu> Cale: if your function does the import of a module that with stop gets killed, it will not be revivable
21:14:19 <Cale> shubuntu: In fact, it seems to make the thread finish.
21:14:39 <SamB> block
21:14:40 <SamB> ?
21:14:40 <Cale> loop won't be called again, so the thread finishes and dies.
21:14:52 <Cale> SamB: where is that?
21:15:02 <awesame> bos: that would be f . g though, right?
21:15:02 <SamB> @hoogle block
21:15:02 <lambdabot> Control.Exception.block :: IO a -> IO a
21:15:02 <lambdabot> System.IO.BlockBuffering :: Maybe Int -> BufferMode
21:15:02 <lambdabot> Control.Exception.BlockedOnDeadMVar :: Exception
21:15:08 <Cale> mm
21:15:14 <shubuntu> Cale: no the loop may continue, you did not throw an exception remember?
21:15:19 <bos> awesame: yes
21:15:37 <Cale> SamB: That doesn't appear to do it.
21:15:41 <ddarius> http://en.wikipedia.org/wiki/Noddy_%28disambiguation%29
21:15:42 <lambdabot> Title: Noddy (disambiguation) - Wikipedia, the free encyclopedia
21:15:45 <shubuntu> Cale: the casing was done inside of the loop
21:15:52 <Cale> shubuntu: I don't think you understand what's desired here.
21:16:51 <shubuntu> Cale: to my understanding you're loading a thread, adding it to your main, then you want to kill it, while the loop is alive.
21:16:56 <Cale> no
21:17:12 <shubuntu> Cale: what do you want to do then
21:17:12 <SamB> Cale: that will prevent other threads from killing that one
21:17:22 <Cale> SamB: oh, hmm
21:18:23 <awesame> (also, is there something like >>= that takes its args in the opposite order?)
21:18:39 <bos> awesame: =<<
21:18:53 <awesame> dang, should have tried that
21:19:08 <idnar> heh
21:20:08 <Cale> SamB: Doesn't seem to work
21:20:28 <awesame> aw, "cannot mix `(>>=)' [infixl 1] and `(>>>)' [infixr 1] in the same infix expression"
21:20:43 <sjanssen> > let True = False in True
21:20:44 <lambdabot>  True
21:20:44 <Cale> shubuntu: The goal is to have a thread which blocks indefinitely and yet doesn't get killed by GHC's automatic detection of that.
21:20:47 <sjanssen> tee hee
21:20:51 <awesame> I see why, but I was really excited about that
21:20:55 <ddarius> > let !True = False in Ture
21:20:55 <lambdabot>  Parse error at "!True" (column 5)
21:21:09 <Cale> shubuntu: Normally if a thread blocks in such a way that it could never be woken up, GHC kills it.
21:21:21 <Cale> shubuntu: But sometimes you really do want a thread to do that.
21:21:28 <shubuntu> Cale: what would be the use of that thing?
21:21:31 <sjanssen> ddarius: hmm, I wonder it we can have strict top-level pattern bindings?
21:22:02 <sjanssen> ddarius: to answer my own question: no
21:22:17 <ddarius> sjanssen: Indeed, I just checked as well.
21:22:56 <Cale> shubuntu: It's a useful unit with respect to an operation which races threads against one another.
21:23:08 <sjanssen> let !True = False; !False = True -- actually seems reasonable when viewed through C-colored glasses
21:23:40 <Cale> Plus bos seemed to need it :)
21:23:45 <adu> scook0: right, I understand the purpose of GADT syntax, that it allows expressing ideas that standard Haskell does not allow, but I was under the impression that the term "GADT" existed before "GADT syntax" and that both syntaxes allow the expression of some kinds of GADT, you know the datatypes themselves, not the syntax...
21:23:46 <ddarius> Functional programmers with their units and zeroes.
21:23:57 <shubuntu> Cale: Then why not Create a Casing and give the thread a value outside the boundaries. It'll stay there doing nothing while the rest will work
21:24:15 <Cale> sorry?
21:24:17 <scook0> adu: well, I could be wrong
21:24:37 <Cale> shubuntu: Typically, we just do something like  forever (threadDelay maxBound)
21:24:47 <adu> i'm just wondering where GADTs started, the ideas behind them, not the GHC syntax
21:24:52 <scook0> but my understanding is that "generalized" refers to the sort of datatypes you can't express with the usual syntax
21:24:56 <shubuntu> Cale: At any moment you can change the static value that represents the thread in your stack
21:25:00 <sjanssen> are you all trying to figure out the correct way to loop forever?
21:25:02 <Cale> shubuntu: which will cause the thread to sit and do nothing for a long time, before briefly waking up to sit and do nothing for another long time
21:25:03 <scook0> but you might want to find a more reliable source than myself
21:25:08 <sjanssen> conal and I had this discussion a while back
21:25:12 <roconnor> @seen conal
21:25:12 <lambdabot> conal is in #haskell and #ghc. I last heard conal speak 5h 5m 24s ago.
21:25:13 <Cale> shubuntu: stack?
21:25:15 <bos> sjanssen: no, we figured it out already.
21:25:18 <ddarius> adu: The notion started in several places independently.
21:25:34 <bos> sjanssen: shubuntu is prolonging the discussion by introducing crazy moon talk.
21:25:38 <Cale> shubuntu: I'm afraid I don't understand.
21:25:38 <shubuntu> Cale: your main concurrency runs based on a stack of representatives
21:25:45 <ddarius> adu: For earlier examples for Haskell look up First-class Phantom Types.
21:25:49 <sjanssen> bos: forever threadDelay?
21:25:56 <bos> sjanssen: yep.
21:26:07 <adu> ddarius: cool, phantom types... sounds scary
21:26:08 <shubuntu> bos: thanks for your astrological observations, you perhaps belong to mars?
21:26:09 <sjanssen> bos: blocking on a top-level (never garbage collected) MVar is generally more efficient
21:26:21 <sjanssen> AFAIK
21:26:30 <ddarius> adu: Phantom types are a very simple but common technique in statically type functional languages and Haskell in particular.
21:26:44 <Cale> sjanssen: Yeah, but you have to be careful that it's not GC'd :)
21:26:53 <bos> sjanssen: that requires another thread to own it, which i don't want.
21:26:53 <shubuntu> Cale: every concurrent system runs on a stack of elements which they iterate on
21:27:01 <adu> woah, i got a citeseerx page and it looks like its from the year 2010
21:27:03 <dons> anyone else noticed that #rubyonrails has gone from 1475 people in their irc channel a year or two ago, to only 270 now.
21:27:13 <bos> sjanssen: also, i'm a bit confweezled as to how it could be more efficient.
21:27:17 <Cale> shubuntu: Sorry I don't see how what you're saying has anything to do with Haskell threads.
21:27:51 <ddarius> dons: Wouldn't 1475 people make it like the top channel or maybe number 2/3?
21:28:05 <bos> dons: yes, it peaked in early 2006
21:28:20 <sjanssen> bos: GHC has to scan the list of threadDelay'd threads regularly to see if the timer has expired
21:28:32 <bos> sjanssen: really?
21:28:37 <bos> how odd.
21:28:39 <Cale> We're currently 11th
21:28:46 <shubuntu> Cale: http://hackage.haskell.org/trac/ghc/wiki/CapabilitiesAndScheduling
21:28:50 <lambdabot> Title: CapabilitiesAndScheduling - GHC - Trac, http://tinyurl.com/5z9fc5
21:29:05 <sjanssen> bos: how else could it be done?
21:29:06 <bos> if i built a thread scheduler like that, i'd have been taken out and thrashed!
21:29:31 <mauke> sjanssen: you make a priority queue of timer events
21:29:34 <Cale> shubuntu: That's a document about GHC's implementation of concurrency, it has nothing to do with what we're talking about :)
21:29:37 <bos> sjanssen: using a heap queue.
21:29:50 <sjanssen> mauke, bos: oh yeah, it probably isn't a a linear scan
21:29:52 <mauke> at each select() iteration, you extract the next event and use that as your sleep time
21:29:58 <shubuntu> Cale: the concept of concurrency is universal
21:30:17 <bos> sjanssen: :-)
21:30:17 <Cale> Uh, okay.
21:30:21 <shubuntu> Cale: there's always a stack, and there are push and pop functions
21:30:29 <mauke> shubuntu: no
21:30:37 <sjanssen> bos: so let's come up with a benchmark
21:30:37 <Cale> There aren't in Haskell's concurrency.
21:30:42 <mauke> I've never seen a concurrency system with a stack or push/pop
21:30:49 <sjanssen> first program to finish sleeping forever wins!
21:30:55 <Cale> (there may be somewhere in the depths of the implementation, but nobody cares about that)
21:31:17 <bos> sjanssen: if you come up with the technology that lets us wait to see who wins, i'm in!
21:31:33 <shubuntu> Cale: well all you need is to find a way to keep a value in your stack without ever being touched
21:31:43 <clanehin> let forever = 5 in sleep forever
21:31:46 <clanehin> I win.
21:31:46 <Cale> shubuntu: In Haskell, to create a new thread to perform a given action, you apply forkIO to the action and run it.
21:32:03 <Cale> shubuntu: forkIO turns an action into one which will run concurrently with other threads
21:32:06 <shubuntu> Cale: That's a closed captioned way
21:32:20 <ddarius> Cale, you're wasting your time.
21:32:29 <Cale> ddarius: I'm not sure :)
21:32:35 <ddarius> I am.
21:32:42 <mauke> Cale: you're on IRC. QED. :-)
21:32:46 <shubuntu> Cale: if you're going to just use haskell implemented functions then keep waiting
21:32:51 <Cale> mauke: You have me there :)
21:32:53 <bos> programming with STM is such a joy.
21:32:57 <Cale> shubuntu: hm?
21:33:38 <shubuntu> Cale: Haskell tends to take control of all underlying technologies, concurrency included
21:33:45 <Cale> shubuntu: hm?
21:33:53 <shubuntu> Cale: so far they don't have what you want as a function call
21:34:00 <sjanssen> bos: I wonder if 'atomically retry' will sleep forever?
21:34:09 <mauke> sjanssen: a.out: thread blocked indefinitely
21:34:13 <shubuntu> Cale: so your only way to achieve what you want is to personally tap into that stack they're using underneath
21:34:19 <Cale> shubuntu: If we're talking about programming in Haskell, we're obviously talking about programming in Haskell and not programming in Smalltalk or Erlang.
21:35:10 <bos> Cale: don't feed the trolls.
21:35:35 <Cale> bos: *Always* feed the trolls :)
21:36:24 <lament> feed me!
21:36:37 <ddarius> lament: You were fed the other day.  Don't get greedy.
21:36:41 <awesame> feed the trolls to whom?
21:36:54 <mauke> Xah Lee
21:37:15 <sjanssen> mauke: mmm, yes
21:37:39 <sjanssen> mauke: perhaps the discussion between conal and I was mainly about me making this boneheaded discussion :)
21:37:42 * bos once again bemoans the lack of a wildcard type variable
21:37:51 <sjanssen> erm, boneheaded suggestion
21:38:14 <shubuntu> Cale: where are you keeping the list of your processes you map with forkIO
21:38:31 <awesame> bos: what's a wildcard type variable?
21:38:40 <bos> awesame: something that does not exist, but should.
21:38:56 <bos> awesame: you know how value-level variables have wildcards?
21:39:01 <bos> awesame: same idea, but for types
21:39:05 <Cale> shubuntu: You don't keep that yourself, GHC handles it.
21:39:07 <awesame> like, _?
21:39:14 <mrd> bos: pattern matching on types?
21:39:18 <bos> awesame: as in, "i don't care what type this is, because i won't use it"
21:39:21 <Cale> shubuntu: You can save the ThreadId's yourself though, if you want.
21:39:29 <awesame> oh, I see
21:39:29 <bos> awesame: yes
21:39:41 <Cale> (which you'll need if you later want to throw exceptions to those threads, or kill them)
21:39:45 <awesame> how is "a" not good enough?
21:40:15 <shubuntu> don't you say foo = = sequence $ map forkIO $ [process1, process2, process3] where ...
21:40:42 <shubuntu> sorry for the double =s
21:41:02 <shubuntu> you could give a name to that list
21:41:18 <mauke> forM_ [p1, p2, p3] forkIO
21:41:29 <mauke> and off they go
21:42:09 <bos> awesame: for the same reason that you could use a variable "a" in place of "_" in a normal pattern.
21:42:20 <bos> awesame: why do you use "_", and not "a"?
21:42:25 <awesame> hm
21:42:35 <awesame> I think because ghc prints warnings
21:42:41 <bos> awesame: it's an explicit declaration of "i don't care"
21:42:56 <bos> ghc doesn't print warnings unless you put it in nagging mother in law mode.
21:43:04 <awesame> although I agree that it's useful to read a _ and know that I never need to worry about that value
21:43:12 <bos> exactly.
21:43:40 <ddarius> bos: How goes the book?
21:43:55 <bos> ddarius: not bad. we're about 70% done.
21:44:43 <gnuvince_> bos: any new free chapters coming up soon?
21:45:06 <bos> gnuvince_: i need to migrate to a new server, will shlep up some new chapters around the same time.
21:45:19 <gnuvince_> all right
21:45:24 <idnar> cool
21:46:03 <bos> modern haskell programs look very festive, with their line of christmas tree LANGUAGE directives strung across the top of every file.
21:46:05 <adu> bos: which book?
21:46:16 <bos> @go real world haskell
21:46:18 <lambdabot> http://www.realworldhaskell.org/
21:46:18 <lambdabot> Title: Real World Haskell
21:46:28 * roconnor grumbles
21:46:34 <mauke> YHBT Haskell Beginner's Tutorial
21:46:46 <adu> o i remember seeing this a couple months ago, perhaps I talked to you
21:46:58 <ddarius> bos: Or you could just use -fglasgow-exts, the serpent whispers.
21:46:59 <roconnor> main = bracket (return ()) (const (putStrLn "handler")) (const (atomically retry))
21:47:04 <roconnor> Should that program print anything?
21:47:21 <SamB> bos: wouldn't a christmas-tree LANGUAGE pragma be one with every possible value included?
21:47:36 <bos> SamB: something like that.
21:47:49 <adu> is bracket like Scheme's dynamic-wind?
21:48:05 <bos> a typical day at the coal face involves GeneralizedNewtypeDeriving, MultiParamTypeClasses, FunctionalDependencies, TypeSynonymInstances, FlexibleInstances
21:48:12 <mauke> main = atomically retry `catch` \_ -> putStrLn "o hi"
21:48:23 <bos> and PartrideInAPearTree
21:48:45 <awesame> hm
21:48:57 <ddarius> @src bracket
21:48:58 <lambdabot> bracket before after thing = block $ do
21:48:58 <lambdabot>     a <- before
21:48:58 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
21:48:58 <lambdabot>     after a
21:48:58 <lambdabot>     return r
21:49:04 <bugQ> I'm sorry, I read that as "patricide in a pear tree"...
21:49:18 <roconnor> mauke: does that print anything?
21:49:20 <lament> that's okay.
21:49:24 <roconnor> I don't think it should.
21:49:29 <roconnor> I think STM is busted.
21:49:36 <adu> roconnor: I think so, yes
21:49:37 <awesame> so receiveHTTP returns an Either ConnError a
21:50:09 <mauke> roconnor: I sort of agree with you
21:50:17 <awesame> and if the Either turns out to be a Left ConnError, I'd really like to throw an exception in the IO monad
21:50:23 <roconnor> great, an the handler isn't called when I ctrl-c a process. :(
21:50:29 <awesame> would I have to convert the ConnError to an IOError of some kind?
21:50:32 <mauke> well, duh
21:50:41 <mauke> signals will be signals
21:51:00 <roconnor> mauke: how should I clean up crap before I die?
21:51:28 <bugQ> give it to charity?
21:51:29 <mauke> depends
21:51:38 <roconnor> ok
21:51:47 <roconnor> depends on what?
21:51:49 <mauke> in general, you can die any time, any place
21:51:54 <conal> sjanssen: ah, yes.  i'd forgotten who gave me the 'threadDelay maxBound' idea.
21:52:08 <mauke> so the best solution is not to acquire resources that need cleanup
21:52:25 <roconnor> conal: sorry that atomically retry didn't work.  What a load of crock STM is.
21:52:40 <roconnor> mauke: I can't work on a remote system without acquiring a lock.
21:53:00 <roconnor> mauke: and relasing the lock and gaining it after each transaction is slow
21:53:01 <mauke> enjoy your stale locks
21:53:13 <roconnor> fucking Unix
21:53:17 <PenguinOfDoom> what
21:53:20 <PenguinOfDoom> just write more processes
21:53:37 <mauke> SIGKILL lurks in the shadows, waiting for you
21:53:41 <PenguinOfDoom> You can have one that releases the locks if the other one dies
21:53:49 <PenguinOfDoom> and also the one to clean up pidfiles from the first two
21:54:51 <PenguinOfDoom> and I guess at some point you'll either descend into an endless well of chaos or have the system do something useful for you
21:55:21 <mauke> my friend, you're suffering from insufficient paranoia
21:56:06 <PenguinOfDoom> Untrue! I just keep my overreaching paranoia from affecting my actions.
21:56:07 <roconnor> PenguinOfDoom: I get the feeling that my sequential program just got a whole heck of a lot more complicated.
21:56:25 <PenguinOfDoom> roconnor: Hey, can't take the fire, don't touch POSIX
21:56:37 <PenguinOfDoom> (I'm sorry)
21:56:44 <PenguinOfDoom> ((I hope someone makes something that's good))
21:57:03 <PenguinOfDoom> (((but we are probably stuck with unix for the next millenium)))
21:57:07 <roconnor> I'm not touching posix, I'm touching Control.Exception
21:57:41 <roconnor> I kind assumed ^C threw an exception
21:57:47 <roconnor> but I guess it doesn't.
21:58:55 <bos> roconnor: that's python thinking, that is.
21:59:02 <PenguinOfDoom> wait, wait, are you expecting your compiled-to-assembly software to detect SIGINT at arbitrary points in its execution, automagically?
21:59:12 <bos> roconnor: you have to install a signal handler yourself.
21:59:20 <PenguinOfDoom> Python installs a signal handler, sets a flag in it, then checks it every 10 instructions or so
21:59:25 <PenguinOfDoom> and uh
21:59:27 <PenguinOfDoom> yeah
21:59:43 <roconnor> all I did was type ^C, I didn't kill the process from the command line.
21:59:50 <PenguinOfDoom> Guess what ^C does!
22:00:01 <roconnor> throws an exception from getChar?
22:00:20 <PenguinOfDoom> No, exceptions weren't invented when ^C was.
22:00:31 <roconnor> hmm
22:00:38 <roconnor> I suppose that is a fair point
22:00:46 <roconnor> but they were around when getChar was invented.
22:01:16 <idnar> ^C sends SIGINT
22:01:21 <PenguinOfDoom> I'm sure if you ignore the appropriate signal (SIGINT), getChar will fail in some other way
22:02:35 <nolrai_> what does "module A (module A, Type) where" do that "module A (Type)" doesn't?
22:04:49 <nolrai_> cause one works and the other doesnt.  I still dont understand exporting.
22:11:24 <bos> @hoogle eof
22:11:25 <lambdabot> Text.ParserCombinators.Parsec.Combinator.eof :: Show tok => GenParser tok st ()
22:11:25 <lambdabot> Text.Read.EOF :: Lexeme
22:11:25 <lambdabot> Text.Read.Lex.EOF :: Lexeme
22:15:47 <ddarius> Stupid mutable array interface
22:17:16 <ddarius> Where's my NDP?
22:21:05 <bd_> :t toList
22:21:06 <lambdabot> Not in scope: `toList'
22:24:55 * ddarius searches Hackage
22:25:50 <dons> http://darcs.haskell.org/packages/ndp/
22:25:52 <lambdabot> Title: Index of /packages/ndp
22:27:33 <ddarius> dons: Right now I'm looking for a library that has convenience functions for working with mutable arrays.
22:32:14 <dons> hmm. StorableVector perhaps?
22:32:22 <dons> ndp is definitely one option
22:32:27 <SamB> ddarius: convenience? you don't deserve no convenience!
22:34:27 <weatherman_> !topkarma
22:34:33 <ddarius> ndp might work
22:34:55 <weatherman_> !stats
22:35:16 <weatherman_> karma system not working?
22:36:03 <ddarius> dons: Where's StorableVector?
22:36:28 <SamB> @karma
22:36:28 <lambdabot> You have a karma of 0
22:36:33 <SamB> heh
22:36:42 <SamB> @help karma
22:36:42 <lambdabot> karma <polynick>. Return a person's karma value
22:36:56 <SamB> @karma *
22:36:56 <lambdabot> * has a karma of 0
22:36:58 <SamB> @karma .*
22:36:58 <lambdabot> .* has a karma of 0
22:37:00 <SamB> @karma all
22:37:00 <lambdabot> all has a karma of 0
22:37:03 <SamB> @karma-all
22:37:03 <lambdabot>  "fglock"              401
22:37:03 <lambdabot>  "Aankhen"             219
22:37:03 <lambdabot>  "avar"                188
22:37:03 <lambdabot>  "moritz"              165
22:37:03 <lambdabot>  "pmurias"             159
22:37:05 <lambdabot> [1022 @more lines]
22:37:11 <weatherman_> oh ok thanks, i found this nifty script, and so i wanted to see it
22:38:39 <weatherman_> @help karma
22:38:39 <lambdabot> karma <polynick>. Return a person's karma value
22:38:51 <obk> Is there a reason why it is impossible to have code following a {- ... -} comment (in the same line)?
22:39:03 <obk> E.g. {- foo -} bar = 7
22:39:14 <obk> Is there another way to achieve this?
22:39:32 * obk needs to annotate some functions with a serial number for cross-reference with an external document
22:39:49 <clanehin> it worked last time I tried
22:40:36 <obk> Hmmm - GHC 6.8.1 seems to choke on it for me
22:40:37 <scook0> obk: the whitespace between -} and bar might be causing layout problems
22:40:39 <scook0> (just a guess)
22:40:48 <ddarius> obk: Disable layout by using { } if you want that.
22:40:49 * obk tries without white space
22:41:07 <scook0> though the {--} might still count as whitespace (not sure)
22:41:44 <obk> Seems even doing {-foo-}bar = 7 doesn't work
22:41:58 * obk didn't consider the indentation implications
22:42:03 <atp> that's not possible?
22:42:13 <obk> Syntax error on the '='
22:42:31 <Cale> I think if you have {-foo-}bar = 7, it's as if bar is starting in column 8
22:42:44 <obk> I thinks so - and that confuses GHC
22:42:54 <obk> So there's basically no way to do it?
22:43:03 <Cale> You can put the comment on the line above
22:43:10 <roconnor> @type handle
22:43:11 <Cale> Or at the end of the line :)
22:43:12 <lambdabot> forall (a :: * -> * -> *) e b ex. (ArrowError ex a) => a e b -> a (e, ex) b -> a e b
22:43:15 <roconnor> @hoogle handle
22:43:15 <lambdabot> Control.Exception.handle :: (Exception -> IO a) -> IO a -> IO a
22:43:15 <lambdabot> System.IO.Handle :: data Handle
22:43:15 <lambdabot> Control.Exception.handleJust :: (Exception -> Maybe b) -> (b -> IO a) -> IO a -> IO a
22:43:30 <obk> Sure, bit that would mean two lines for the short functions and looks ugly as sin
22:43:32 <ddarius> obk: If you really much put the comment there, you can turn off layout for top-level functions.
22:43:43 <obk> ddarius: Sounds good... how?
22:43:50 <ddarius> obk: {- foo -} bar = 6 doesn't look ugly as sin?
22:44:00 <obk> Depends on your sins :-)
22:44:16 <obk> I have the YAML productions in the spec prefixed by [123] numbers
22:44:29 <ddarius> obk: Just put opening brackets after the 'where' in module Foo where { ... }.  Put a semicolon at the end of each top-level definition.
22:44:31 <obk> They are also 1-1 with Haskell code, so I want it to look as close to it as possible
22:44:53 <obk> ddarius: Hmmm... would it be possible to do it for _part_ of a module?
22:45:41 <ddarius> No.  But it only disables the layout for the top-level definitions, not within them.
22:45:55 <obk> Thanks. I'll give it a try
22:46:17 <obk> I expect type declarations also require ; then...
22:47:05 <roconnor> conal: actually (atomically retry) seems to work fine so long as there are other threads still around.
22:47:27 <ddarius> Here's an example of Ashley Yakely's unusual style: http://hscheme.cvs.sourceforge.net/hscheme/Source/BatchMain.hs?revision=1.30&view=markup
22:47:28 <lambdabot> Title: SourceForge.net Repository - 1 [ 7 hscheme 1 ] 1 1c View of /Source/BatchMain.hs ..., http://tinyurl.com/6xv5wm
22:47:30 <conal> roconnor: oh.  that's probably just fine then.
22:47:55 <roconnor> conal: It seems you worked out all the kinks in your framework
22:48:13 <roconnor> conal: I take it all your uses of unamb are coherent?
22:48:24 <conal> roconnor: yes.  i was thrilled to come up with unamb and its uses.
22:48:41 <conal> yes -- all coherent, hopefully with very clear arguments.
22:48:50 <conal> (clear proofs)
22:49:13 <conal> it'd be nice to have dependent types, so as to formalize the prerequisite.
22:49:29 <roconnor> last time I checked with you some uses were ambiguous.  You were concerned about dependent things happening at the same time and racing to see who happens first.
22:49:53 <OceanSpray> I've been thinking of Liskell.
22:49:54 <conal> roconnor: yes, that was with amb, not unamb.
22:50:15 <roconnor> :), but there is no type enforcement that unamb is unambiguous
22:50:35 <conal> roconnor: right, none.
22:50:39 <OceanSpray> the conventional (a . (b . ())) list structure doesn't match well with Haskell's evaluation scheme.
22:50:47 <conal> though theoretically there could be.
22:50:48 * roconnor coq doesn't have unsafePerformIO at the moment.
22:50:54 <roconnor> er
22:50:58 <roconnor> coq doesn't have unsafePerformIO at the moment.
22:51:08 <sjanssen> OceanSpray: hmm?
22:51:20 <sjanssen> OceanSpray: this is exactly what Haskell uses for lists
22:51:25 <OceanSpray> yes, BUT
22:51:31 <conal> roconnor: no problem.  implement unamb differently.
22:51:41 <conal> roconnor: btw, was someone suggesting that Concurrent Haskell burns nontrivial cycles in handling 'threadDelay maxBound'?
22:51:46 <OceanSpray> haskell SYNTAX lists should have the form ((a . b) . c)
22:52:03 <sjanssen> conal: I said that, but I might be totally wrong
22:52:05 <roconnor> conal: what exactly changed that made your uses of amb unambigous?
22:52:06 <OceanSpray> that way, ((f a) b) is the same as (f a b)
22:52:29 <OceanSpray> and you can't have something like (f)
22:52:44 <roconnor> conal: I don't know who said that.  I just thought threadDelay maxBound was quiet ugly
22:53:10 <conal> roconnor: yeah, it is ugly.
22:53:13 <roconnor> conal: imagine waiting 22000 years just to wake up and sleep for another 22000 years.  Quite the snooze.
22:53:52 <roconnor> (a : (b : (c : [])))
22:54:07 <conal> roconnor: see section 10 of my paper, which introduces unamb.  the trick is trying two *equivalent* tactics for testing ta <= tb, when ta & tb are knowable only in the future.
22:54:27 <conal> since the tactics are semantically equivalent, it doesn't matter (semantically) which finishes first.
22:55:02 <roconnor> ah okay
22:55:09 <roconnor> now I'm willing to upgrade. :)
22:55:51 <conal> might be a generally useful tools for exploiting concurrency without sacrificing functional semantics.
22:56:14 <conal> roconnor: don't rush to upgrade.  i haven't released the new version yet.  i want to profile and study the performance first.
22:56:54 <roconnor> conal: not surprisingly this reminds me a lot of how piecewise functions on (constructive) real numbers are defined.
22:57:01 <conal> i have a mysterious cycle drain.  maybe it's what sjanssen suggested about 'threadDelay maxBound' having non-negligible cost.
22:57:17 <sjanssen> conal: how bad is it?
22:57:41 <sjanssen> your cycle drain, that is
22:58:37 <conal> sjanssen: in my first extremely crude tests, i see 50% cpu load when i expect nothing at all to be happening.  and i have no idea yet of why.
22:58:43 <bos> yoicks!
22:59:29 <conal> could be totally unrelated to my library.  that's why i want to get profiling going.  which means i have to upgrade my wxhaskell.
22:59:29 <bos> conal: you're on windows?
22:59:40 <conal> bos: yes, for now.
23:00:37 <sclv> just came up with great new names for my functions: mapFromTuple and mapToTuple are now inosculate and variegate. nothing less for the language that put intercalate in a standard library, I say.
23:02:26 <roconnor> sclv: sounds good to me
23:02:54 <lament> inosculate? does that mean un-kiss?
23:03:19 <sclv> to fuse together
23:03:27 <lament> ohh, okay
23:03:37 <lament> very romantic
23:04:00 <sclv> i spent a little time with a thesaurus looking for that one. :-)
23:04:19 * obk is having problems with overloading - inside where { ... }
23:04:25 <obk> Everything else works though
23:04:32 <bos> very recondite.
23:05:22 <scook0> cromulent?
23:14:28 <sjanssen> the cost of a blocking takeMVar seems to be cheaper than threadDelay (single threaded RTS)
23:15:23 <sjanssen> conal: how many threads might be blocking at one time?
23:16:51 <conal> sjanssen: not sure.  i guess one one or two per active event mappend.  mappend on events temporally interleaves occurrences.
23:18:24 <conal> sjanssen: plus one for the rendering thread, which is blocking while waiting for the value to change.
23:19:14 <conal> though that rendering is probably not a real thread, due to thread-unsafe gui & rendering apis.
23:19:44 <sjanssen> but nothing on the order of 10 thousand or so?
23:20:41 <conal> sjanssen: could be 10k in some cases, i guess, e.g., with lots & lots of potentially interacting (e.g., colliding) objects.
23:21:02 <conal> but not in examples i have in mind.
23:28:48 <vincenz> @localtime roconnor
23:28:50 <lambdabot> Local time for roconnor is Sun Apr 6 01:28:53 2008
