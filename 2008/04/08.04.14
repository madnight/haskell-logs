00:08:21 <cjs> Where does one grab the SOEGraphics modules for a Mac or X11?
00:09:29 <cjs> Wow, this is busting my head. So when I use a Lazy ByteString, things suddenly become pure, and I need to return the unread remainder etc. Argh.
00:09:43 <cjs> Data.Binary destroyed the entire model of my program.
00:10:34 <dcoutts> cjs: there are two SOE impls, one from the SOE website and one in Gtk2Hs
00:13:27 <cjs> Ah, got it. Thanks.
00:23:11 <cjs> I'm confused. Must I use lazy ByteStrings when using Data.Binary? Or can I use any of the four ByteString packages?
00:24:55 <Cale> cjs: The Data.Binary operations work on lazy bytestrings, but of course, you can convert between them.
00:26:05 <Cale> A strict ByteString x can be turned into a lazy one as  fromChunks [x]
00:26:22 <Cale> (of course, it's not really very lazy like that :)
00:26:59 <Cale> and a lazy ByteString can be converted to a strict one by applying toChunks and then concatenating the results.
00:31:19 <Cale> cjs: btw, the Get monad is supposed to keep track of the remaining bunch of the string for you
00:35:19 <jberg_> so ghc has been building for 2 hours 30 minutes on 2 ghz dual core, is that normal?
00:35:57 <vegai> I would say yes. How much memory in that?
00:36:30 <jberg_> 1gb
00:36:49 * araujo thinks like a little too much time
00:36:49 <vegai> linux? os x?
00:36:53 <jberg_> os x
00:37:14 <vegai> os x tends to be a little slower, I suppose
00:37:24 <jberg_> i see
00:37:51 <jberg_> any ideas how much longer? 3 4 5 hours?
00:38:00 <jberg_> in total that is..
00:38:19 <araujo> I think it shouldn't take longer than 3hrs.
00:38:26 <jberg_> okay thanks
00:39:30 <araujo> according to your hardware description ... and it is a bit too much yet ... , but don't trust me too much, since I have never done that on os x
00:39:35 <araujo> it might take longer
00:39:37 <ziman> merge time: 1 hour, 18 minutes and 42 seconds. (Athlon XP 2600 [mono-core], 512MB RAM & linux here...)
00:39:44 <sjanssen> jberg_: that is quite a bit more than I'd expect
00:39:56 <sjanssen> jberg_: did you build with make -j 2 or more?
00:40:26 <jberg_> it's fink whos building it because im installing darcs, so i dunno
00:40:49 <sjanssen> IIRC, my build time was usually around 45 min. in OS X on a Core Duo
00:40:54 <araujo> jberg_, only for installing darcs? ... doesn't fink have bin packages?
00:40:56 <sjanssen> this was with parallel make
00:41:23 <araujo> yeah, such a hardware should give <1hrs
00:42:03 <jberg_> araujo: err actually i didnt find darcs when i searched with fink. macports had 2.0.0 pre4 though, but not binaries
00:42:40 <jberg_> so is something wrong with this build then maybe?
00:42:57 <araujo> I guess
00:43:39 <groken> i've written a short grammar in antlr, would anyone be able to take a look at it and give some advice?
00:45:17 <jberg-> ah great, right after i asked if something was wrong with this build my macbook overheated and shut down (been having some problems with the fan)
00:45:27 <jberg-> but are there no 2.0.0 binaries for os x?
00:51:21 <quicksilver> jberg-: 2.0 ? erm?
00:51:28 <quicksilver> jberg-: GHC is at version 6.8.2 ...
00:51:36 <quicksilver> jberg-: and yes, there are binaries for osx
00:51:39 <jberg-> im talking about darcs
00:51:46 <quicksilver> ah
00:51:47 <jberg-> i want binary darcs
00:51:54 <quicksilver> sorry, I though you were still building ghc
00:52:02 <jberg-> os x crashed :X
00:52:09 <Baughn> darcs should most definitely not take two hours to build
00:52:18 <jberg-> Baughn: ghc did
00:52:25 <jberg-> darcs needs ghc
00:52:25 <Baughn> jberg-: I've seen its build system get into a loop before. Abort, abort.. crash?
00:52:30 <Baughn> Oh.
00:52:44 <jberg-> like i said, my macbook overheated and crashed
00:52:56 <Baughn> ..I knew they were hot, but that's a bit excessive
00:53:10 <jberg-> like i said, ive been having fan problems
00:53:15 * Baughn runs the fans in his mbp at a minimum of 3k5 RPM to avoid just that
00:53:32 <jberg-> how do you control the fan?
00:56:03 <jberg-> Baughn: can you control the fan?
00:56:22 <Baughn> jberg-: There are several applications. I use smcFanControl
00:56:42 <jberg-> ok cool
00:57:21 <Baughn> jberg-: You should be aware that *changing* the speed wears the fans faster than just running at a higher speed, so increasing the minimum speed may actually increase their life; conversely, using an application that changes the speed dynamically to keep temperature constant (there's at least one such out there) will drastically reduce their life.
00:57:58 <jberg-> i see
00:58:23 <Baughn> Of course the firmware *will* push the speed up if things get too hot (though yours seems broken).. try to set it high enough that that rarely happens.
00:58:56 <jberg-> yup ill try
01:07:17 <cjs> cale: Yes, the Get monad does keep track of the remaining bits of the string, but I have several layers of things through which I'm passing a handle that now need to take the ByteString instead. It's a pain to change all of these.
01:07:49 <cjs> Hm, can I use Data.Binary with a Data.ByteString.Lazy.Char8, as well as the regular Word8 version?
01:08:11 <cjs> (The messages I parse are mostly text, actually.)
01:24:54 <Taejo> Hans-Peter_Kunzi: what country are you from?
01:24:54 <Hans-Peter_Kunzi> I'm Swiss.
02:07:45 <cjs> So I'm looking at "The Get and Put Monads" in the Data.Binary docs; how do I interpet this to figure out what to do when I want to read a thingie from the first bit of the ByteString and pass the remainder on to be read by someone else?
02:14:56 <vegai> how much of last.fm is implemented in Haskell, then? :)
02:18:19 <Le-Chuck_ITA> Hi there
02:18:22 <Le-Chuck_ITA> I am decided
02:18:41 <jsnx> i can not fiture out why i get this error: "Illegal polymorphic or qualified type"
02:18:46 <Le-Chuck_ITA> I will learn how to use a proof assistant and that's because my proofs always sucks (and that's because I am always lazy)
02:19:00 <jsnx> if i turn on -fglasgow-exts, it goes away
02:19:13 <Le-Chuck_ITA> so I will ask an off topic question here :) What is a category-theory oriented proof assistant?
02:19:16 <xerox> jsnx: what code?
02:19:19 <Le-Chuck_ITA> Is there any one?
02:20:40 <jsnx> xerox: https://svn.j-s-n.org/public/haskell/cedict/Data/Char/CEDICT/C/PtrWalker.hs
02:20:43 <lambdabot> http://tinyurl.com/5l2c5j
02:20:45 <xerox> Le-Chuck_ITA: I suggest BlockNotesâ„¢ :-)
02:21:41 <Le-Chuck_ITA> xerox: does it run on any operating system, since I have installed linux in my brain
02:24:30 <xerox> jsnx: might be this one? http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#type-synonyms
02:24:33 <lambdabot> Title: 8.4. Extensions to data types and type synonyms, http://tinyurl.com/2cmgjm
02:25:48 <xerox> Le-Chuck_ITA: indeed, beware that it needs some special hardware sold separately: it's usually compatible with Penâ„¢ or Pencilâ„¢ hehe.
02:26:15 <jsnx> xerox: so what is the -X option for that? is it a GHC only thing?
02:28:20 <jsnx> set -XTypeSynonymInstances does not fix it
02:30:21 <desegnis> jsnx, -X is a ghc flag for language options and uses the same names as does the LANGUAGE pragma
02:30:36 <jsnx> desegnis: okay
02:31:03 <jsnx> desegnis: but the link i got doesn't say anything about a flag, so i wasn't sure
02:31:14 <jsnx> desegnis: it just says, GHC does this special
02:32:56 <xerox> It's a combination: -XRank2Types -XFlexibleContexts
02:33:09 <xerox> http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
02:33:10 <lambdabot> Title: 5.17. Flag reference, http://tinyurl.com/ydk2e6
02:33:23 * xerox off to do some work.
02:33:30 <desegnis> jsnx, yeah, the docs don't make clear what language options toggle the described behaviour
02:33:40 <hpaste>  cjs pasted "not quite monadic yet..." at http://hpaste.org/6976
02:34:22 <cjs> Anybody care to help me with a State type monad (Data.Binary.Get)? That's kinda what I want to do, but not right....
02:34:50 <jsnx> xerox: thank you -- i would never have figure that out
02:34:51 <cjs> That "let (response,rest) ..." thing is the idea, but not how it's done, obviously.
02:40:32 <desegnis> cjs, what's that "get" that you apply as a function?
02:40:36 <jsnx> cjs: you want to make a State monad?
02:40:58 <jsnx> cjs: State has it's own `get` that has nothing to do with Data.Binary's get
02:41:28 <cjs> No, I don't want to use State, unless I need to, but I'm confused as to how to work this recursive thing.
02:41:47 <cjs> Get is the one from Data.Binary: "newtype Get a = Get { unGet :: S -> (a, S) }"
02:42:06 <jsnx> cjs: you mean, recursively turning a stream into a list of results?
02:42:55 <cjs> Yes, I think that's it. "get" each RawResponse from that responseStream, and apply each ResponseProcessor to it, and then recurse.
02:43:26 <jsnx> cjs: maybe you should look at `unfoldr`
02:45:05 <cjs> Yeah, that's the kind of thing I need, though I can't seem to figure out how to put all of this together.
02:46:42 <cjs> Also, maybe using Maybe confuses things even more; this list can be considered infinite.
02:47:01 <cjs> (I.e., my program will let the TCP connection I'm reading from shut down when it exits.)
02:47:22 <cjs> Or, actually, I guess it doesn't matter; the ByteString comes from hGetContents.
02:50:47 <cjs> I think it's that I've got the one bit in the IO monad and the other bit in the Get monad that's confusing me.
02:54:12 <cjs> Even with unfoldr, I'm still stuck at the same place: how do I get (not the function) the unconsumed part of the ByteString?
02:54:50 <jsnx> cjs: you must split the bytestring somehow
02:55:21 <cjs> Well, it's get that does that, isn't it?  S -> (a, S) and all that?
02:56:31 <jsnx> :t get
02:56:45 <jsnx> :t Data.Binary.get
02:56:46 <lambdabot> thread killed
02:56:52 <lambdabot> forall t. (Data.Binary.Binary t) => Data.Binary.Get.Get t
02:56:53 <jsnx> eh?
02:57:10 <cjs> Wow. That was impressive.
02:57:14 <cjs> Anyway, from the source:
02:57:16 <cjs> newtype Get a = Get { unGet :: S -> (a, S) }
02:57:51 <jsnx> well, maybe unGet does it then
02:58:21 <hpaste>  cjs pasted "RawResponse definition" at http://hpaste.org/6977
02:58:27 <cjs> (In case it helps.)
02:58:51 <cjs> I seem to need a monadic recursion of some sort.
02:59:18 <jsnx> cjs: just plain recursion will likely be fine
02:59:21 <jsnx> w
03:02:06 <cjs> Actually, if I could just figure out how to turn that L.ByteString into a list of RawResponses....
03:02:43 <desegnis> hmm... is unGet exported?
03:02:50 <desegnis> :t Data.Binary.unGet
03:03:05 <lambdabot> thread killed
03:03:26 <cjs> :t Data.Binary.runGet
03:03:31 <lambdabot> Not in scope: `Data.Binary.runGet'
03:03:37 <desegnis> I take that as a "no", then
03:03:42 <cjs> runGet might be it.
03:03:49 <dolio> I don't think lambdabot has binary installed.
03:03:56 <cjs> unGet is not.
03:04:07 <cjs> But: runGet :: Get a -> L.ByteString -> a
03:04:30 <desegnis> ah, it's in Data.Binary.Get
03:04:47 <cjs> :t Data.Binary.Get.runGet
03:04:51 <lambdabot> forall a. Data.Binary.Get.Get a -> BSLC.ByteString -> a
03:05:01 <dolio> Huh.
03:05:03 <desegnis> I guess you need unGet, though
03:05:58 <cjs> Or this one? runGetState :: Get a -> L.ByteString -> Int64 -> (a, L.ByteString, Int64)
03:06:03 <dolio> Oh, you need binary to build lambdabot, of course it's available.
03:06:11 <desegnis> oh wait, you could just use isEmpty :: Get Bool and recurse within the Get monad
03:06:11 <cjs> Ok, so if I did have unGet, what would I write?
03:07:01 <cjs> Actually, we don't even need to worry about termination, at the moment.
03:07:32 <cjs> The thread doing this will die at exit, anyway, before or around the time the TCP connection is closed.
03:08:17 <desegnis> getThem = do e <- isEmpty; if e then return [] else (do x <- get; xs <- getThem; return (x:xs))
03:08:27 <desegnis> sth like that
03:10:28 <cjs> Isn't the getThem going to be sequenced before the return? That will go into an infinite loop, never returning anything.
03:10:50 <desegnis> it won't loop infinitely
03:11:01 <desegnis> I think
03:11:16 <cjs> How will it return the first message without waiting for the second?
03:11:56 <desegnis> I'd hope for some laziness
03:12:13 <desegnis> It's not the IO monad, mind
03:12:19 <cjs> Oh, I see.
03:13:11 <desegnis> btw let's write the last part as (liftM2 (:) get getThem), so it looks nice at least
03:13:11 <cjs> BTW; that responseStream is from an hGetContents called on a network connection....
03:24:38 <desegnis> cjs, btw, I double-checked that it really works with the right laziness
03:31:58 <scook0> if I want a ContT to *not* rollback state, I should put it on the outside of my transformer stack, correct?
03:43:08 <PeakerWork> does ghc 6.6.1 have Control.Monad.Cont?  I installed ghc from Ubuntu Gutsy, and I don't seen to have that module
03:43:27 <quicksilver> scook0: ContT StateT
03:43:35 <quicksilver> scook0: (won't rollback state)
03:44:09 <desegnis> PeakerWork, everybody loves ghc 6.8
03:44:32 <quicksilver> PeakerWork: yes, it does
03:44:37 <quicksilver> PeakerWork: you need the MTL
03:44:45 <quicksilver> PeakerWork: libghc6-mtl-dev I think it's called?
03:44:48 <quicksilver> something like that, at least
03:46:11 <PeakerWork> quicksilver, thanks!
03:53:00 <joricj> > getClockTime
03:53:08 <lambdabot>   Not in scope: `getClockTime'
03:53:26 <joricj> hrm
03:53:52 <Twey> No IO actions
03:54:08 <joricj> i'm trying to get the seconds-since-the-epoch as an Int. "getClockTime >>= \TOD x y -> x" doesn't seem to work
03:54:31 <joricj> the documentation mentions that "In Haskell 98, the ClockTime type is abstract.", what does that mean ?
03:54:51 <quicksilver> it means you are not allowed to know what the internal representation is.
03:55:17 <joricj> oh
03:55:59 <quicksilver> System.Time is broken, don't use it.
03:56:05 <quicksilver> haskell98 time is broken, don't use that either.
03:56:10 <quicksilver> use Data.Time.Clock
03:56:55 <joricj> okay
03:57:42 <Deewiant> System.Directory.getModificationTime still gives a ClockTime
03:58:32 <cjs> desegenis: thanks. I've got to run (meeting broke out), but I'll look into that.
04:02:54 <dolio> Apparently, in mtl StateT Cont won't roll back state either.
04:04:36 <dolio> > runCont (runStateT (callCC (\k -> put 5 >> k 0) 0) id
04:04:37 <lambdabot> Unbalanced parentheses
04:04:53 <dolio> > runCont (runStateT (callCC (\k -> put 5 >> k 0)) 0) id
04:05:03 <lambdabot>  (0,5)
04:07:53 <joricj> main = defaultTimeLocale >>= \l -> getCurrentTime >>= \t -> putStrLn $ formatTime l "%s" t
04:09:15 <joricj> it's not working for some reason. can anyone please help me with this? i just want the currrent UTC as seconds-since-epoch
04:11:10 <jsnx> try using `formatCalendarTime defaultTimeLocale "%s"`
04:18:43 <paolino> > runState (runContT (callCC (\k -> put 5 >> k 0)) id) 0
04:18:43 <lambdabot>   add an instance declaration for (Num (State s a))
04:22:37 <paolino> > runState (runContT (callCC (\k -> put 5 >> k 0)) return) 0
04:22:37 <lambdabot>  (0,5)
04:22:50 <paolino> at least
04:30:16 <joricj> i there a function like . which works the other way around?
04:30:42 <quicksilver> >>>
04:30:46 <quicksilver> it's in Control.Arrow
04:30:50 <joricj> jsnx: ah that works, thanks
04:30:58 <joricj> quicksilver: cool
04:31:10 <joricj> hehe, my code really starts to creep full of >> >>= and now >>>
05:00:39 <joricj> "\0" gives "NUL", but how do i follow it with a number? "\000" should become "\NUL00" somehow
05:01:13 <scook0> > "\0\&00"
05:01:13 <lambdabot>  "\NUL00"
05:01:22 <scook0> > "\NUL00"
05:01:29 <lambdabot>  "\NUL00"
05:01:45 <osfameron> "\000"
05:01:53 <osfameron> > "\000"
05:01:53 <lambdabot>  "\NUL"
05:01:56 <osfameron> ah
05:02:13 <osfameron> interprets as octal 00 ?
05:02:25 <scook0> I guess so
05:02:44 <scook0> so use \& to split an escape sequence from literal text
05:03:06 <kpreid> haskell escapes are not octal
05:03:18 <kpreid> > "\032"
05:03:19 <lambdabot>  " "
05:03:34 <kpreid> > "\2022"
05:03:35 <lambdabot>  "\2022"
05:03:35 <joricj> @src >>>
05:03:35 <lambdabot> Source not found. There are some things that I just don't know.
05:03:44 <joricj> @hoogle >>>
05:03:48 <lambdabot> Control.Category.(>>>) :: Category cat => cat a b -> cat b c -> cat a c
05:03:49 <kpreid> @. read run "\2022"
05:03:50 <lambdabot>  æ
05:03:54 <kpreid> hrf
05:04:06 <joricj> > "\0&9"
05:04:07 <paolino> :t (>>>)
05:04:08 <lambdabot>  "\NUL&9"
05:04:14 <joricj> > "\0\&9"
05:04:15 <lambdabot>  "\NUL9"
05:04:19 <joricj> awesome
05:04:22 <lambdabot> thread killed
05:04:29 <Arnar> http://book.realworldhaskell.org/beta/escapes.html#id409846
05:04:30 <lambdabot> Title: AppendixÂ B.Â Characters, strings, and escaping rules
05:04:38 <paolino> @type (>>>)
05:04:39 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
05:05:15 <paolino> > (*2) >>> (-1) $ 3 == 5
05:05:16 <lambdabot>   add an instance declaration for (Num (Bool -> b))
05:05:30 <paolino> > ((*2) >>> (-1) $ 3) == 5
05:05:31 <lambdabot>   add an instance declaration for (Num (a -> b))
05:06:03 <Gilly> hm, i'm trying to make a monad that has properties from reader monad and should be able to carry another monad within it, is this possible?
05:06:13 <paolino> :t (*2) >>> (-1)
05:06:14 <lambdabot> forall b d. (Num (b -> d), Num b) => b -> d
05:07:04 <scook0> Gilly: do you know about monad transformers?
05:07:11 <Gilly> no i don't
05:07:44 <scook0> you can use monad transformers to build up composite monads with multiple capabilities
05:07:46 <paolino>  :t (*2) >>> (-1) $ (const 3)
05:08:03 <Gilly> the concrete thing i'm trying to do is carry some information about the paper as a reader like environment and then have the PDF monad from Graphics.PDF inside my monad
05:08:10 <scook0> e.g ReaderT Foo (StateT Bar) is a monad with a Bar as state, and a Foo as environment
05:08:39 <scook0> oh, so you'd have something like ReaderT Info PDF
05:08:39 <Gilly> mmm
05:09:01 <scook0> though the usual practice is then to wrap the transformed monad in a newtype
05:09:25 <Gilly> i see, so newtype Geom = ReaderT Info PDF should do the job?
05:09:34 <Gilly> er, newtype Geom Geom ReaderT Info PDF
05:09:38 <Gilly> ...
05:09:40 <Gilly> missing =
05:10:00 <scook0> yeah
05:10:17 <scook0> add deriving (Monad) to make it a monad
05:10:28 <Gilly> ok, great :)
05:10:38 <mauke> newtype Geom a = Geom (ReaderT Info PDF a) deriving (Functor, Monad, MonadReader Info)
05:10:56 <scook0> note that if you want to use PDF actions inside the Geom monad
05:11:03 <scook0> you'll need to "lift" them
05:11:14 <Gilly> yea of course :)
05:11:34 <scook0> though if you're using the newtype, you won't actually be using the lift function
05:11:36 <Gilly> i'm not exactly sure how to do that, though... there is some existing api?
05:11:58 <scook0> instead you'll have something like liftPDF x = Geom (lift x)
05:13:29 <Gilly> yea, to use the reader i can use the usual 'ask' ?
05:15:59 <scook0> yeah
05:16:18 <scook0> unless for some reason you want to abstract away the MonadReader part
05:16:31 <scook0> don't forget asks, too
05:16:55 <Gilly> what would be such a reason?
05:17:13 <scook0> I can't think of one off-hand
05:17:38 <scook0> if it was StateT instead of ReaderT, you might want to prevent client code from arbitrarily altering the state, for example
05:17:57 <Gilly> ah
05:18:49 <ertai> Is GHC still doing graph-reduction and generate supercombinators?
05:28:26 <Lycurgus> ertai: would that be a problem?
05:28:52 <ertai> Lycurgus: not especially
05:30:22 <ertai> Lycurgus: it's more to keep me up to date with the differents ways that compilers of functional languages use to compile them.
05:31:14 <quicksilver> ertai: I don't think GHC is that straightforward any more
05:31:15 <ertai> That's because I'm a little bit confused with the litterature around
05:31:20 <quicksilver> but I'm not the man that knows what it does :)
05:31:41 <quicksilver> it certainly is a long way from naive graph reduction.
05:33:04 <ertai> quicksilver: Ok no problem with a complex-graph-reduction
05:34:07 <ertai> quicksilver: But I would like to known is some "call-by-value traditional compilation"+thunks was used too?
05:42:50 <mauke> @hoogle (a -> b -> b) -> [a] -> b -> b
05:42:50 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
05:42:50 <lambdabot> Data.List.foldr :: (a -> b -> b) -> b -> [a] -> b
05:42:56 <mauke> what
05:43:17 <mauke> haha
06:01:56 <joricj> for some reason i get an ["*** Exception: Prelude.init: empty list. when i put in a putStrLn to see what's happening, suddenly the error disappears (the putstrln works, and the code thereafter also starts working). what's going on?
06:02:28 <joricj> i figure it must have something to do with lazyness, so i sprinkled some $! around to see if it helped, alas to no avail (or maybe i didn't hit the right spot yet)
06:02:49 <ddarius> Are you using readFile, getContents, hGetContents or unsafePerformIO, unsafeInterleaveIO ?
06:03:19 <joricj> hGetContents
06:04:02 <ddarius> The file is probably getting closed before you are using it.  When you add the putStrLn, you force the input to be read fully in so that it is there when it is used.
06:05:02 <joricj> oh okay
06:05:23 <joricj> well you mentioned readFile, now that i've found that i'm going to abandon my current bracket-thing and go with that
06:05:31 <joricj> it seems perfect
06:06:47 <kaustuv> If I want to play with the new open type families support (Schrijvers et al, ICFP'08 submission), can I simply use the ghc 6.9 snapshot from 23/3 (the most recent available one), or should I build myself a newer ghc?
06:07:51 <ddarius> Newest would probably be best, but you may be able to use an older one.
06:09:16 <kaustuv> Hmm
06:17:56 <kaustuv> fwiw, the 23/3 snapshot seems to work
06:44:48 <dancor> i want allPossibleByteStrings :: [ByteString].  but i'm thinking i can be cool and use Enum or Bounded
06:47:26 <dancor> > let all = enumFrom . minBound in all (0 :: Word8)
06:47:33 <lambdabot>        add an instance declaration for (Bounded (Word8 -> a))
06:47:38 <jsnx> to make GHCi send the "bold" ANSI codes to my screen, what terminal type does it need to think i'm using? i'm using screen
06:48:19 <dancor> jsnx: have you tried a very minimal one like vt100
06:52:28 <jsnx> dancor: doesn't make any difference, alas
06:52:38 <jsnx> dancor: no bling-bling for me
06:52:38 <dancor> > let all = enumFrom (minBound) in all :: [Word8]
06:52:40 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
06:52:46 <allbery_b> er, in what context does ghci ever send bold?
06:53:02 <jsnx> allbery_b: screen, on os x
06:53:09 <dancor> > let all = enumFrom minBound in drop 200 $ all :: [Word8]
06:53:09 <lambdabot>  [200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218...
06:53:15 <dancor> > let all = enumFrom minBound in drop 250 $ all :: [Word8]
06:53:16 <lambdabot>  [250,251,252,253,254,255]
06:53:19 <jsnx> (i hope that last part makes no difference)
06:54:14 <allbery_b> let me try that again.  why are you expect ghci to send bold sequences?  it does not normally do so in my experience.
06:55:17 <jsnx> allbery_b: oic
06:55:56 <jsnx> allbery_b: when doing code listings
06:56:01 <jsnx> "If your output device supports it, then GHCi will highlight the active subexpression in bold."
06:56:11 <jsnx> allbery_b: while debugging
06:58:02 <allbery_b> oh, hm, haven't dne much with the debugger.  (main ghc env. is still 6.6.1, having trouble gettting 6.8.2 to behave on non-x86)
06:59:40 <dancor> jsnx: it works not in screen?
07:00:37 <dancor> in screen you basically always want TERM=screen
07:01:10 <jsnx> dancor: doesn't seem to work
07:01:26 <dancor> jsnx: does ghci bold work outside of sceren
07:03:09 <jsnx> dancor: yes
07:03:22 <dancor> jsnx: are you sure that your TERM setting is correct when you start screen?
07:03:36 <dancor> i.e. that it matches your terminal
07:03:49 <jsnx> dancor: my term setting is 'screen'
07:04:08 <dancor> jsnx: TERM should not be screen right before you start screen
07:04:08 <jsnx> my setting is 'xterm-color' before i start it
07:04:16 <jsnx> dancor: oh, right
07:04:20 <dancor> and you are using xterm, right?
07:04:51 <jsnx> using apple's thing
07:05:06 <jsnx> i don't set $TERM in my rc scripts
07:05:47 <dancor> it could be that Terminal is not completely compatible with TERM=xterm-color and it only shows up when you are in screen
07:05:56 <jsnx> maybe so
07:06:11 <jsnx> i have plenty of choices, though
07:06:16 <jsnx> i guess i'll try them out
07:06:26 <dancor> you might try using a different TERM when you invoke screen (maybe something minimal like vt100 or ansi..) or ask #screen etc
07:06:49 <jsnx> dancor: are you able to use screen without trouble?
07:07:14 <dancor> jsnx: i've had my share of troubles
07:07:30 <dancor> using finch, trying to use screen-256color
07:07:41 <dancor> i'm not on mac os x tho
07:08:31 <dancor> jsnx: this seems to claim dtterm is a better TERM setting: http://the.taoofmac.com/space/apps/Terminal
07:09:13 <dancor> jsnx: another thing to try would be starting screen from an actual xterm and seeing if ghci works right then
07:10:18 <dancor> in general debugging termcap/terminfo problems is a huge nightmare
07:11:29 <joricj> @hoogle foldM
07:11:32 <lambdabot> Control.Monad.foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
07:11:32 <lambdabot> Control.Monad.foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
07:11:32 <lambdabot> Data.Foldable.foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
07:12:00 <jsnx> dancor: makes no difference, but thanks for the info
07:13:09 <dancor> :pl \ l -> l ++ map (x:) l
07:13:18 <dancor> @pl \ l -> l ++ map (x:) l
07:13:18 <lambdabot> ap (++) (map (x :))
07:17:24 <jsnx> wow, the debugger makes a difference
07:17:28 <dancor> jsnx: i am seeing the same problem as you
07:17:33 <jsnx> hmm
07:17:41 <dancor> in xterm, ghci does show bold.  in screen in xterm, it does not.
07:17:50 <jsnx> ack
07:17:58 <jsnx> probably, it is a curses thing
07:18:07 <dancor> this is in linux.  it's probably being silly about checking for the capability
07:18:12 <jsnx> yeah
07:18:14 <cjs> Agh. I'm screwed.
07:18:19 <jsnx> !!
07:18:24 <Zao> The screen terminal is rather restricted.
07:18:37 <jsnx> Zao: but it can do bold and colors
07:18:54 <dancor> yeah irssi e.g. seems pretty happy
07:19:06 <cjs> I have ghc 6.6.1 on this machine. My only binary package of 6.8 is on my laptop, which is shut down and in the cabinet at work. I can rebuild from source, but this is a Pentium II 750.
07:19:40 <cjs> I suppose I could start a new build, and see if it's done in 20 hours or so when I come home from work tomorrow....
07:20:20 <dancor> there is no 6.8 binary that works on the inet?
07:21:20 <cjs> For NetBSD? Maybe somewhere....
07:21:55 <uebayasi> *stares*
07:22:03 <cjs> Ooo! Actually, I lucked out, I found one on another machine. Though I wonder how long it will take to bring down over my dog-slow DSL....
07:22:14 <cjs>  /brick uebayasi
07:23:54 <cjs> Hey, uebayasi-san, you're hanging around here a lot these days. What's up? Becoming a convert? :-)
07:24:58 <uebayasi> i'm just hanging around many channels :)
07:26:32 * jsnx used to use freebsd
07:27:11 <uebayasi> so, you've never surfaced during the last one month when many NetBSD developers have visited Tokyo...
07:27:22 <hpaste>  dancor pasted "i want a sane power-set func.." at http://hpaste.org/6978
07:31:52 <cjs> No, I've been incredibly busy since the beginning of March.
07:33:27 <scook0> > filterM (const [False ..]) "abc"
07:33:27 <lambdabot>  ["","c","b","bc","a","ac","ab","abc"]
07:33:56 <dancor> that's pretty cool anyway
07:34:22 <uebayasi> "nendomatsu" is a Japanese's excuse.  you are not. ;)
07:36:22 <cjs> Actually, my company's fiscal year ends on January 31st. Then I have the usual April 1st stuff. So I do have an excuse!
07:38:23 <gnuvince> :t filterM
07:38:24 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
07:38:55 <xml-rpc> http://mibbit.com/pb/zfbsbv
07:38:55 <lambdabot> Title: Mibbit: PasteBin
07:43:33 <cjs> Interesting. So it's not a compile error to declare something to be an instance of a class with a method of that class missing?
07:44:07 <ski> the method could have a default definition
07:44:18 <cjs> "Warning: No explicit method nor default method for `put'"
07:44:26 <ski> *nod*
07:44:31 <Baughn> You can always define anything as "undefined", which presumably is what is happening ehre
07:44:43 <cjs> Actually, that should say, "Neither explicit..." I guess I should report that as a bug.
07:45:41 <dancor> is that a lol?  i think "No" or "There is neither an" is better than "Neither"
07:46:24 <Baughn> "Neither" sounds correct
07:46:59 <cjs> It is. "Warning: neither explicit nor default method for `put'" is correct. (Note case, as well.)
07:47:28 <cjs> Regardless, it's probably still an "LoL", as you so quaintly term it. :-)
08:00:32 <Arnar> hey there..
08:00:47 <Arnar> I could use some wizard's assistance..
08:01:20 <Bonus> pretty empty at this time of the day here
08:01:27 <Bonus> and im not a wizard, sorry :\
08:01:29 <cjs> Arnar: ...for I am crunchy and good to eat.
08:01:29 <Bonus> im a paladin
08:01:43 <Arnar> :)
08:01:47 * Arnar pastes
08:02:04 <MyCatVerbs> > let droplast n l = zipWith const l (drop n l) in droplast 5 [1..10]
08:02:04 <lambdabot>  [1,2,3,4,5]
08:02:12 <hpaste>  Arnar pasted "Shellac monad and folding" at http://hpaste.org/6979
08:02:27 <MyCatVerbs> @pl \n l -> zipWith const l (drop n l)
08:02:28 <lambdabot> ap (zipWith const) . drop
08:02:29 <Arnar> I'm having trouble with the foldl line there..
08:02:58 <mauke> what is that supposed to do?
08:03:09 <MyCatVerbs> @index ap
08:03:10 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
08:03:10 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
08:03:23 <Arnar> mauke.. it should map the evalCommand function over the cmds (of type [Command])
08:03:37 <Arnar> updating the state inside the Sh CCSShellState monand along the way
08:03:37 <mauke> mapM evalCommand cmds?
08:03:54 <Arnar> :t mapM
08:03:55 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:04:23 <mauke> @src mapM
08:04:23 <lambdabot> mapM f as = sequence (map f as)
08:04:55 <Arnar> then map >>= over the result?
08:04:59 <Arnar> foldl rather
08:05:04 <sw17ch> i'm looking for a function which takes a list and removes duplicate values. sounds like something trivial...
08:05:12 <mauke> why >>=?
08:05:18 <swiert> sw17ch: nub?
08:05:24 <mauke> mapM gives you a single action that returns a list
08:05:47 <Arnar> mauke: ok.. but evaluate should not return the list
08:05:55 <sw17ch> swiert, yes, exactly. :) thanks
08:06:38 <Arnar> mauke: besides. will mapM help.. I need to chain the state from each command to the next..
08:06:58 <mauke> mapM does that
08:07:09 <Arnar> oh.. <:|
08:07:22 * Arnar tries
08:07:40 <mauke> :t foldl (>>=) (return ?st) $ map (flip ?evalCommand) $ ?cmds
08:07:41 <lambdabot> forall (m :: * -> *) a a1. (?cmds::[a1], ?evalCommand::a -> a1 -> m a, ?st::a, Monad m) => m a
08:09:26 <Arnar> mauke: I just get a type error, expecting () but finding [()]
08:09:54 <mauke> :t mapM_
08:09:55 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
08:10:53 <Arnar> mauke: ok.. that's type correct, hang on
08:11:20 <Bonus> is there any built in function that gives you every nth element of a list?
08:11:28 <Arnar> :t unlines
08:11:28 <Bonus> or every nth + m element?
08:11:29 <lambdabot> [String] -> String
08:11:48 <tromp> what is every nth element?
08:11:54 <Bonus> as in if i have
08:11:57 <tromp> you mean the nth element?
08:12:03 <Bonus> ['a','b','c','d','e','f','g','h']
08:12:07 <Bonus> and i want every 2nd element
08:12:14 <Bonus> i want b d e and g
08:12:21 <tromp> oh
08:12:27 <Bonus> b d f and h i mean
08:12:32 <Bonus> that's the equivalent of python's step
08:12:59 <mauke> argh! exceptions are hard
08:13:06 <Bonus> in python [0,1,2,3,4,5,6,7,8][::2] == [0,2,4,6,8]
08:13:14 <Feuerbach> > map ((!!) ['a','b','c','d','e','f','g','h']) [2,4..]
08:13:15 <lambdabot>  Exception: Prelude.(!!): index too large
08:13:28 <wolverian> Feuerbach, that has quite horrid performance characteristics :)
08:13:29 <tromp> the map (!!) is inefficient
08:13:30 <Bonus> ah
08:13:39 <tromp> you want to do repeated drops
08:13:40 <Feuerbach> yep, I know
08:14:01 <Bonus> yeah i was just wondering if there's a built in
08:14:05 <Bonus> i already wrote something like that
08:14:06 <tromp> no
08:14:10 <gnuvince> > map snd (zip ['a'..'h'] (tail ['a'..h']))
08:14:10 <lambdabot>   Not in scope: `h''
08:14:11 <snhmib> why not just write a function that does like take2 (a:b:cs) = a:take2 cs
08:14:15 <gnuvince> > map snd (zip ['a'..'h'] (tail ['a'..'h']))
08:14:15 <lambdabot>  "bcdefgh"
08:14:23 <Bonus> filterIndex k = map snd . filter(\(i, elem) -> k i) . zip [0..]
08:14:23 <gnuvince> Fail
08:14:29 <Bonus> i made this
08:14:31 <Bonus> and then i just do
08:14:41 <Bonus> filterIndex (\i -> i `mod` 2 == 0) lst
08:15:31 <Arnar> mauke: nope.. doesn't seem to work, only the last cmd shows effect on the state
08:15:36 <mauke> ah. now I know where my problems are coming from
08:15:51 <mauke> I'm trying to access the return value of a function that throws an exception
08:16:17 <Apocalisp> ?pl (\x -> map ((!!) x) [2,4,..]
08:16:17 <lambdabot> (line 1, column 21):
08:16:17 <lambdabot> unexpected "["
08:16:17 <lambdabot> expecting variable, "(", operator or ")"
08:16:22 <Apocalisp> oups
08:16:25 <Apocalisp> ?pl (\x -> map ((!!) x) [2,4,..])
08:16:25 <lambdabot> (line 1, column 21):
08:16:25 <lambdabot> unexpected "["
08:16:25 <lambdabot> expecting variable, "(", operator or ")"
08:16:34 <Apocalisp> ?pl (\x -> map ((!!) x) [2,4..])
08:16:35 <lambdabot> flip map [2,4..] . (!!)
08:16:41 <Apocalisp> lovely
08:16:56 <mauke> > execState (mapM_ (\x -> modify (+ x)) [1,7,2,-4]) 0
08:16:57 <lambdabot>  6
08:16:59 <tromp> you shld define something like everynth n l = case (drop (n-1) l) of []->[]; (x:xs) ->
08:17:11 <mauke> Arnar: works here
08:17:27 <Arnar> hmm
08:17:57 <Apocalisp> Arnar: Eru Haskellingar fjölmennir á fróni?
08:18:06 <tromp> @let everynth n l = case (drop (n-1) l) of []->[]; (x:xs) -> x:everynth n xs
08:18:09 <lambdabot> Defined.
08:18:11 <Arnar> Apocalisp: haha.. efast um það
08:18:17 <tromp> > everynth 3 "hello, world"
08:18:18 <lambdabot>  "l,od"
08:18:26 <mauke> is this icelandicâ€½
08:18:30 <Arnar> mauke: yup
08:18:31 <muhtimin_> yes
08:18:34 <Apocalisp> mauke: it is a bit
08:19:03 <Apocalisp> Notarðu hs í vinnunni?
08:19:21 <Arnar> Apocalisp: nope.. at school (msc. in theoretical cs)
08:19:42 <Bonus> hmmm
08:19:47 <mauke> now we just need Ã†var in here and we have ourselves a party
08:19:55 <Apocalisp> I probably asked you that before, but it got aged out of the heap.
08:20:19 <Arnar> heh.. icelanders everywhere
08:20:53 <Apocalisp> Icelander world domination!
08:21:01 <Arnar> mauke: am I doing it wrong this way:  mapM_ (evalCommand st) cmds
08:21:11 <Arnar> that (evalCommand st) is what's bothering me..
08:21:20 <Arnar> execute every command from the initial st
08:21:56 <mauke> Arnar: what was the problem with your original fold?
08:22:28 <Arnar> mauke: expected type Sh CCSShellState CCSShellState.. instead of Sh CCSShellState ()
08:22:56 <mauke> so you want to throw the final state away?
08:23:01 <Arnar> mauke: no..
08:23:34 <mauke> why does evalCommand return a value instead of updating the state?
08:23:54 <Arnar> mauke: hmm.. good question..
08:24:14 <Arnar> evalCommand used to be pure.. but then I needed shellPutStrLn which is why I changed it
08:24:16 <hpaste>  cjs pasted "the essentials of the problem" at http://hpaste.org/6980
08:24:28 <cjs> Ok. How do I define declist, the decoded version of enclist?
08:24:47 <dons> Cale, want to have a go at this, 'http://discuss.joelonsoftware.com/default.asp?joel.3.617925'
08:24:47 <lambdabot> Title: FogBugz
08:28:04 <cjs> "hard to reason about the time when a computation is done"?!?!
08:28:43 <Apocalisp> "I'm not a Haskell programmer, so I could be wrong."
08:29:13 <Apocalisp> i.e. "I don't know what I'm talking about, but I'm going to pull something out of my ass anyway."
08:41:09 <mauke> fix++
08:45:16 <Arnar> mauke: ok.. solved
08:45:58 <hpaste>  Arnar pasted "mapM_ on shellac monad (solved)" at http://hpaste.org/6981
08:54:14 <glen_quagmire> what is dynamic type system? is there really such a thing?
08:54:54 <oklopol> liek in python?
08:56:17 <glen_quagmire> python performs type checking? it if does, sensible implementor probably isolated type checking layer. then you should be able to type check and quit the interpreter without running the code.
08:56:36 <glen_quagmire> hence performing static type checking
08:57:35 <hpaste>  cjs annotated "the essentials of the problem" with "one small step...maybe" at http://hpaste.org/6980#a1
08:58:06 <cjs> I'm not really sure if that's progress or not.
08:58:21 <Saizan> glen_quagmire: it checks at runtime if the object has the specified method, or if the referenced value is of a certain type, but since both those characteristic can change at runtime static type checking is not so usable
08:58:37 <dancor> is there anything Word8 -> Int that just packs the bytes
08:58:44 <cjs> Yes, python is strongly typed. I'm not entirely sure, but certainly for something like Ruby, you *have* to run the code to check the types, becuase the code can change the types in variables as it executes.
08:58:53 <quicksilver> dancor: [Word8] -> Int, you mean?
08:58:57 <dancor> yes
08:59:05 <quicksilver> I just write it myself every time I want it :P
08:59:08 <dancor> heh ok
08:59:47 <glen_quagmire> Saizan: oh i see. impurity makes it impossible to type check statically
09:00:06 <cjs> Or it can change the "type" of an existing object, in that it can, e.g., add new methods to an object over that object's lifetime.
09:00:09 <mauke> :t sum . zipWith (*) (iterate (256 *) 1) . map fromIntegral
09:00:15 <lambdabot> forall a b. (Integral a, Num b) => [a] -> b
09:00:31 <quicksilver> foldr (\a b -> 256 * b + a)
09:00:35 <quicksilver> or something like that
09:02:12 <Saizan> glen_quagmire: well, it doesn't follow directly from impurity, java does a lot of static type checking compared to python, i guess it's the heavy use of meta-programming/reflection that defeats the point of static types
09:02:38 <hpaste>  morrow pasted "callCC" at http://hpaste.org/6982
09:03:28 <glen_quagmire> there could be a calculus that describes dynamically chaning objects statically
09:05:01 <glen_quagmire> how long does it take to learn and implement hindley-milner type checking in haskell?
09:05:24 <Saizan> a few hours?
09:05:41 <glen_quagmire> cool. /me digs
09:06:29 <quicksilver> if you can't do it in 25 seconds, you're not 733t enough!
09:06:44 <cjs> Hmm...that's interesting; given purity, that might be possible. Well, "more possible." :-)
09:06:52 <Saizan> well, you usually perform type inference and not type checking, and that requires unification which will be the hardest part
09:09:56 <Saizan> glen_quagmire: this might be interesting, it has a nice TypeChecker monad :) http://notvincenz.blogspot.com/2008_01_01_archive.html
09:09:56 <lambdabot> Title: lambda.oasis: January 2008
09:11:06 <glen_quagmire> Saizan: yup. it was too advanced for me. using extensions i don't know...etc
09:12:06 <mbenson> hi all--I actually have some questions about functional programming in general.  I am doing some work on a functional package for Java in the Apache Commons, and I'm trying to get some info on the commonest name for returning the first match for a given predicate from a generator.  Find?  First match?  Detect?  TIA
09:12:09 <Philippa> glen_quagmire: if you can handle it being written in a Pascal-like language, Cardelli's 20-year-old tutorial's pretty good. Or there's Typing Haskell in Haskell which'll go rather further than H-M
09:12:45 <Philippa> mbenson: we don't have 'generators', on account of Haskell being lazy
09:12:56 <Philippa> so to us it's just (head . filter pred)
09:13:03 <Philippa> where pred's the predicate in question
09:13:19 <mauke> listToMaybe!
09:13:21 <Saizan> ?src find
09:13:21 <lambdabot> find p          = listToMaybe . filter p
09:13:33 <Saizan> so yeah, haskell uses find
09:13:57 <Philippa> mauke: yeah, okay, my bad :-)
09:13:57 <mbenson> I know 0 about Haskell... :)
09:14:28 <mbenson> "find" seemed natural, but I thought I'd ask around.
09:14:48 <mbenson> how do "head" and "listToMaybe" compare to "find", out of curiosity?
09:14:58 <mauke> huh?
09:15:07 <mauke> @src head
09:15:07 <lambdabot> head (x:_) = x
09:15:07 <lambdabot> head []    = undefined
09:15:12 <mauke> @src listToMaybe
09:15:12 <lambdabot> listToMaybe []        =  Nothing
09:15:12 <lambdabot> listToMaybe (a:_)     =  Just a
09:16:34 <mbenson> Would you all say that Haskell is fairly representative of common functional programming terminology, or do any of you have any recommendations for elsewhere I might ask?
09:16:58 <HunterXHunter> mbenson: try #scheme
09:18:13 <cjs> "Simple Type Inference in Haskell." Why is it that when someone says that something is "simple"...
09:18:52 <Saizan> well, it's type inference for the simply typed lambda calculus :)
09:19:09 <cjs> mbenson: "detect" is Smalltalk-community-speak, rather than functional-community-speak.
09:19:17 <glen_quagmire> Philippa: thank you.
09:20:36 <qwr> mbenson: haskell is quite functional ;)
09:21:04 <dons> mbenson: its pretty defininitively functional, haskell.
09:21:48 <cjs> mbeson: Haskell is very functional, but Lisp/Scheme are the classics. Haskell deviates in things like "head" and "tail" instead of "car" and "cdr".
09:22:10 <mbenson> cjs:  thanks for picking up on "detect".  That's actually the name I was researching whether should be replaced.
09:22:37 <dons> no other functional languages follow car/cdr though :)
09:22:37 <cjs> Definitely replace that unless you're aiming at (old school) OO folks.
09:22:42 <dons> that's an historical dialect
09:22:50 <cjs> Paul Graham's new one does!
09:23:22 <mbenson> cjs:  so would it be safe to say that Haskell uses "classic" terminology but replaced things that might be considered too cryptic to a newcomer to the field?
09:23:40 <cjs> Anyway, you're sounding like one of those guys who, just because *you've* got a shiny new 1401, look down on all us 701 owners.
09:23:45 <cjs> mbenson: I'd say so.
09:23:54 <glen_quagmire> HASKELL IS THE ACADEMIA!!!!!!!!!!!!!1
09:24:58 <quicksilver> surely you mean 'TEH' ACADEMIA?
09:25:17 <cjs> Actually, one place you can look for clues is Ruby: pretty much anything there for which you find synonyms (find/detect, map/collect, etc.) just pick the synonym that Haskell uses, and you've got the functional one.
09:25:48 <qwr> mbenson: scheme is imho also worth learning, but not really for a pure functional programming - scheme is imho cool for understanding macros, cps, actors, and some unpure fun of mixing side effects with closures...
09:25:49 <mbenson> Since "detect" is valid in some circles, I may leave it in, but provide "find" as a semantically obvious alternative that also happens to have some context within the functional community as well.
09:25:57 <cjs> If there aren't synonyms in Ruby, research further elsewhere.
09:26:09 <mbenson> Thanks for the tip RE Ruby, cjs.
09:26:13 <cjs> mbenson: Mmmm, I'm not sure I'd do that.
09:26:30 <qwr> mbenson: and scheme shows very explicitly that code is data is code is ...
09:26:56 <xml-rpc> simple_client.hs: user error (Error calling examples.add: Lexical error in  file string input  at line 7 col 56:
09:27:17 <xml-rpc> unexpected EOF within </...>)
09:27:28 <glen_quagmire> what does "code is data" mean? other than meta programming, is it really useful to have code as data?
09:27:43 <qwr> mbenson: but haskell is the pure functional. and in practice i prefer ocaml and haskell, depending on mood ;)
09:27:58 <cjs> It's probably better to pick a vocabulary and stick with it, I'm thinking at the moment. Much as I love Smalltalk. Do keep in mind, in many ways, Smalltalk is far more functional than most OO languages.
09:28:28 <mbenson> qwr:  I haven't managed to make time to learn any of the classics e.g. LISP/Scheme though it's on my long TODO list.  :)  Mostly a Java guy for now...
09:29:04 <cjs> You can almost think of Smalltalk as being functional with some nice OO stuff integrated into it, and the succeeding OO languages being an inferior OO with the functional stuff entirely ripped out.
09:29:27 <Philippa> qwr: it's worth poking at what MLers call things
09:29:28 <cjs> mbenson: Do _The Little Schemer_. That will give you the feel of it.
09:29:47 <Philippa> haskell and the lisp and ML families are the big ones in FP
09:30:05 <Philippa> mbenson:, even
09:30:06 <mbenson> ML = macro language, or ???
09:30:13 <glguy> meta
09:30:48 <cjs> The one good reason I've ever heard to keep car/cdr (besides 701 nostalgia, which I consider perfectly valid--but keep in mind I also consider the 6502 to be a RISC chip with very few registers) is cddr/cdddr/etc.
09:30:52 <Philippa> mbenson: nope. ML as in SML, ocaml
09:31:11 <Philippa> originally stood for 'meta language', but that's a bit of a historical accident
09:31:50 <mbenson> (head spinning... Googling a lot in the background here)
09:32:29 <glen_quagmire> mbenson: are you trying to pick a functional language to learn?
09:32:37 <Philippa> mbenson: the ML family are strict (as opposed to non-strict/lazy, which is what differentiates haskell), impure (largely because of strictness), statically-typed languages
09:32:52 <Philippa> they're the functional languages that will feel most familiar if you've come from C++ or Java
09:33:48 <mbenson> glen_q:  long-term, I would like to look into some different stuff.  Again, ATM I am researching common terminology to apply to a Java functional library.
09:35:56 <Philippa> ML actually has a generator-like concept, due to being strict. And isn't lisp.
09:36:08 <glen_quagmire> mbenson: I think Haskell terminologies are pretty much common. maybe except monad stuff, mapM ...
09:37:00 <glen_quagmire> there is Scala. i hear it's functional programming language wirtten in java
09:37:19 <mbenson> cjs:  I'm still thinking about your assertion that it might be better to pick a vocabulary and stick with it...
09:37:23 <cjs> It's an FP language that compiles to the JVM.
09:37:30 <osfameron> is it written in itself?
09:37:49 <mbenson> glen_q:  heard of Scala, had forgotten though...  Seems like I read up on it, but can't remember what my impressions were...
09:38:35 <mbenson> osfameron:  would that be a good test of having achieved what FP and MLs are good at?  ;)
09:39:00 <osfameron> mbenson: heh
09:39:44 <cjs> mbenson: Basically, I'd say that Smalltalk is actually a lot closer to a functional language than it is to, say, Java. (Note the extensive use of lambdas, to the point where you message two of them to a boolean rather than have a syntatic "if".) So you might as well go whole hog with the functional terminology of the modern (and ancient) age.
09:41:48 <mbenson> Well, my initial reaction to "detect" that that it was less clear than "find."  This was before it occurred to me that (duh) the term might have some historical context behind it.  So I suppose I'd be no worse off than I was to simply rename the (here) method, and if somebody screams I could always restore the synonym...
09:41:54 <qwr> scala is one weird hybrid between java and fp... imho somewhat mess.
09:44:29 <cjs> When examining how intuitive "detect" is, you do need to think of it with the other methods: select/detect/reject/collect....
09:44:57 <cjs> Oops, that should be, I guess, detect/select/reject/collect....
09:45:55 <glen_quagmire> new Functional.detect { public static void action(Functional.Element e) { ... } }
09:46:28 <cjs> Within that scheme, it's very harmonious, and you have to admit, the lot are also more euphonious than find/filter/map.
09:46:38 <opqdonut> scheme, heh heh
09:47:02 <cjs>  /brick opqdonut
09:47:07 <opqdonut> :>
09:47:14 <cjs> That's the problem with irc; no bricks.
09:47:21 <mbenson> cjs:  those are the set in use.  I had noticed the rhyming nature of the set, but hadn't assigned it any significance.
09:47:45 <cjs> Aesthetic only, but that's a lot of what Smalltalk is all about.
09:47:55 <mbenson> So in that context, would you reassess your opinion of its appropriateness?
09:48:16 <mbenson> Are the others similarly redefined in e.g. Haskell?
09:48:26 <cjs> I would still say, at this point, that find/filter/map are the way to go.
09:48:53 <cjs> Beyond Smalltalk, Ruby is the only language I can think of that uses detect et al.
09:49:45 <glen_quagmire> in java, names don't matter beacuause eclipse autocompletes
09:50:25 <cjs> (That said, I still use the Smalltalk synonyms in Ruby, which was my day-job language for the previous three or four years. But then again, I'm nostalgic for Smalltalk; most people have never used it.)
09:50:28 <mbenson> glen_q:  As a Java dev, I think that's a little over-generalized... ;)
09:51:09 <glen_quagmire> you can stick with one naming and you can easily Refactor (tm)
09:51:13 <cjs> If only it could autocomplete on type signatures, like Hoogle.
09:51:45 <cjs> Anyway, that does give me the idea for the solution, though. Add a plugin to Eclipse that, when you type "collect", changes it to "map" for you. :-)
09:51:52 <glen_quagmire> detect sounds like an EventListner while find sounds like an Actor
09:52:01 <mbenson> so... in Haskell, reject == filter and select == filter(not)?
09:52:05 <glen_quagmire> find actually searches.. detect just waits
09:52:48 <glen_quagmire> reject = filter not  , select = filter i guess
09:52:57 <glen_quagmire> > filter (< 0) [-1,0,3]
09:53:03 <lambdabot>  [-1]
09:53:21 <glen_quagmire> > filter (not . (< 0)) [-1,0,3]
09:53:21 <lambdabot>  [0,3]
09:53:44 <cjs> Oh, and I thought of the real reason: "map abs [-1,-2,-3]" sounds fine; "[-1,-2,-3].collect abs" seems weird....
09:54:06 <xerox> abs . [-1,-2,-3] :D
09:54:25 <cjs> (Ruby would be [-1, -2, -3].collect { |n| abs(n) } of course.)
09:54:29 <mauke> > let collect = map; (.) = flip id in  [-1,-2,-3].collect abs
09:54:29 <lambdabot>  [1,2,3]
09:54:33 <cjs> (Which is wordy.)
09:54:53 <cjs> mauke: you are evil. :-)
09:54:59 <mbenson> glen_q:  That was similar to the feeling "detect" gave me.  Maybe I'll just add both sets of terminology after all... keep the Smalltalk aesthetics and add semantic sensibility.
09:55:04 <Bonuz> (abs(x) for x in [-1,-2,-3]) :)
09:55:11 <mbenson> lambdabot is pretty wild...
09:55:27 <ziman> how can id be flipped?
09:55:28 <glguy> @yow
09:55:29 <lambdabot> TAPPING?  You POLITICIANS!  Don't you realize that the END of the "Wash
09:55:29 <lambdabot> Cycle" is a TREASURED MOMENT for most people?!
09:55:29 <ziman> :t id
09:55:30 <lambdabot> forall a. a -> a
09:55:33 <mauke> Perl: map { abs } -1, -2, -3
09:55:40 <xerox> a becomes (b->c)
09:55:47 <glguy> ziman: id :: ( a -> b ) -> (a -> b)
09:55:49 <Bonuz> >_>
09:56:02 <xerox> by unification
09:56:05 <glen_quagmire> C++: {--1, --2, --3}
09:56:10 <ziman> ooh
09:56:24 <glen_quagmire> no that might not work
09:57:04 <mauke> glen_quagmire: that looks like a syntax error
09:57:46 <steve--> ~monads tutorial
09:58:04 <steve--> lamdabot: monads
09:58:21 <mrd> @wiki monad
09:58:21 <lambdabot> http://www.haskell.org/haskellwiki/monad
09:58:24 <mauke> lern2tab
09:58:55 <steve--> mrd: thank you
09:59:14 <mbenson> okay--so... (whew) collect = map?
09:59:45 <mbenson> @src map
09:59:45 <lambdabot> map _ []     = []
09:59:45 <lambdabot> map f (x:xs) = f x : map f xs
10:00:01 <mbenson> In the lib I'm working on, this sounds more like
10:00:08 <desegnis> the good thing about the select/reject wording is that you cannot accidentally think "filter" would filter things *out* where the predicate is true
10:00:10 <mbenson> grr...
10:00:32 <ziman> yes, that's always something i don't know and have to check in ghci
10:00:47 <mbenson> in the lib I'm working on "translate" is the name used for Haskell "map".
10:00:51 <glen_quagmire> I would name filter   collectTrue
10:01:10 <desegnis> ah, I just remember to think positive, and then I'm fine with filter
10:01:21 <BOnus> eh i always read it
10:01:28 <BOnus> filter X so that predicate is True
10:01:29 <mbenson> "collect" simply adds (generator) items to a collection.
10:01:31 <BOnus> that's how i read filter
10:01:55 <desegnis> translate? confusing.
10:02:06 <cjs> Heh? Collect doesn't add, it maps.
10:02:22 <mbenson> Excuse me.... "transform".
10:02:24 <cjs> In fact, thinking about it, "map" is rather more clear than "collect."
10:02:30 <desegnis> ah
10:02:33 <glen_quagmire> think about what you're doing. you have a collection of data. you're querying the data such that each element of the result satisfies some property.
10:02:48 <glen_quagmire> SELECT * FROM obj WHERE ...
10:03:29 <mbenson> To me, "map" and "transform" sound fairly interchangeable.  Thus I might add map as a synonym for transform.  :)  And at least there would something familiar for FPers to grasp...
10:04:33 <ziman> to me, `transform' sounds like in-place transformation, which is not what actually happens
10:04:35 <cjs> And also, probably many people, after enough years of SQL dementia, think that SELECT has the same meaning as PROJECT.
10:04:48 <glen_quagmire> semantically, map shouldn't destroy the list i think
10:05:21 <mbenson> But by that token I should also give some thought to how to mitigate the problem that FPers would be surprised by the changed meaning of "collect."
10:05:48 <glen_quagmire> ForEachPatternFactory.getInstance().perform() is better
10:06:05 <vincenz> glen_quagmire: you mean
10:06:09 <glen_quagmire> it's clear and i don't need to comment the code
10:06:11 <cjs> Although in perl, I have had map destroy the origninal data, though two layers of function calls, no less....
10:06:24 <vincenz> ForEachPatternFactorySingleton.getInstance().makeForEachPattern().perform()
10:06:36 <steve--> i heard this channel usually recommends a specific monads tutorial, not the one found in "yet another haskell tutorial", what is it?
10:07:03 <glen_quagmire> vincenz: that's professional and robust
10:07:15 <cjs> mbenson: This is probably why you should go with the standard FP terminology, and drop everything else.
10:07:22 <glen_quagmire> @where all about monads
10:07:22 <lambdabot> I know nothing about all.
10:07:39 * vincenz bows
10:07:43 <glen_quagmire> steve--: http://www.haskell.org/all_about_monads/html/index.html
10:07:44 <lambdabot> Title: All About Monads
10:07:55 <vincenz> @where monads
10:07:55 <lambdabot> http://www.haskell.org/all_about_monads/html/
10:08:07 <steve--> thanks
10:09:02 <mbenson> cjs:  all of select/reject/collect/detect?
10:10:59 <mbenson> = filter/filter/map/find?
10:11:03 <mbenson> what about inject?  :)
10:11:50 <Baughn> There is no "inject"
10:12:04 <mbenson> in smalltalk there is... that's my point.  :)
10:13:36 <cjs> mbenson: right. reject them all.
10:13:51 <cjs> mbenson: inject becomes fold.
10:14:39 <mbenson> right... my googling just found that.  So does H have fold and foldr, or does it have foldl and foldr?
10:14:50 <cjs> And hell, even most rubyists don't use inject, anyway.
10:14:56 <cjs> Haskell uses foldl and foldr.
10:15:03 <paolino> WriterT t [] rolls back the monoid of the writer when the list rolls back ?
10:15:17 <cjs> But the difference between the two is quite a bit more important in a lazy language than in a strict one.
10:15:46 <mbenson> Seemed that a foldr is basically a foldl over a reversed list, no?
10:16:01 <cjs> And the best thing about fold is that you don't have to remember whether the memo parameter in the block comes first or second.
10:16:43 <Bonus> in python, foldl is called reduce
10:16:48 <Bonus> i wish it was called foldl though :\
10:17:10 <gnuvince> Bonus: almost no Pythonista uses reduce() though.
10:17:17 <cjs> Actually, you can basically think of it as foldl being the eager version, and foldr being the lazy.
10:17:18 <johnnowak> Bonus: you'll live
10:17:24 <opqdonut> they're getting rid of it in 3k
10:17:28 <cjs> Hm! What does scheme use? Reduce as well?
10:17:40 <cjs> They don't use it? It's so fricking useful. Amazing.
10:17:43 <johnnowak> cjs: fold and fold-right
10:17:47 <johnnowak> they're not getting rid of it, they're moving it to a library
10:17:47 <opqdonut> they're getting rid of practically all functional programming features in 3k :\
10:18:12 <paolino> > runWriterT (tell ["ciao"] >> return [])
10:18:13 <lambdabot>        add an instance declaration for (Show (m ([a], [[Char]])))
10:18:17 <opqdonut> johnnowak: oh? there was much talk about removing it alltogether
10:18:24 <glguy> johnnowak: when you put it like that it sounds a lot less sensational
10:18:26 <opqdonut> haven't been really following lately tho
10:18:34 <johnnowak> glguy: ruins the fun, doesn't it?
10:18:45 <Bonus> yeah they're moving it to functools
10:18:49 <opqdonut> okay
10:18:58 <johnnowak> please don't make me defend python. it causes me pain.
10:19:02 <Bonus> hehe
10:19:15 <Bonus> i like the shift to more lazyness in py3k though
10:19:43 <cjs> johnnowak: You're just defending it badly, that's why. I can easily defend Ruby any day. "It sucks less than Java!"
10:19:44 <glen_quagmire> > do { (_, x) <- runWriterT (tell ["ciao"] >> return []); return x; }
10:19:44 <lambdabot>   add an instance declaration for (Show (t [[Char]]))
10:19:45 <mbenson> wow, I'm reading http://www.zvon.org/other/haskell/Outputprelude/foldr_f.html and I'm totally lost so far...
10:19:46 <lambdabot> Title: Haskell : foldr
10:20:03 <johnnowak> cjs: I'm just stating facts.
10:20:04 <newsham> what is magnus therning's irc handle?
10:20:09 <glen_quagmire> > foldr (-) 0 [1,2]
10:20:10 <lambdabot>  -1
10:20:14 <lispy> does lambdabot log channels?  If so, does she log #darcs and where?
10:20:17 <glen_quagmire> > foldr (-) 0 [1,2,3]
10:20:17 <lambdabot>  2
10:20:21 <int-e> opqdonut: I thought Guido backed down from that and only wants to remove reduce() now?
10:20:36 <lispy> newsham: I think it has magnus in it
10:20:38 <glen_quagmire> foldr (-) 0 [1,2,3] ==> (1 - (2 - (3 - 0)))
10:20:44 <paolino> > runWriterT ((tell ["ciao"] >> return []) :: WriterT [String] [] [()])
10:20:45 <ziman> > foldr [] (:) [1..5]
10:20:45 <lambdabot>  Couldn't match expected type `a -> b -> b'
10:20:46 <lambdabot>  [([],["ciao"])]
10:20:52 <lispy> foldr (-) [ [1..3] :: Exrp
10:20:57 <lispy> foldr (-) [ [1..3] :: Expr
10:21:00 <ziman> > foldr (:) [] [1..5]
10:21:00 <lispy> > foldr (-) [ [1..3] :: Expr
10:21:00 <lambdabot>  Parse error at end of input
10:21:00 <lambdabot>  [1,2,3,4,5]
10:21:10 <glen_quagmire> paolino: do you want to reset ["ciao"] in the Writer?
10:21:12 <lispy> > foldr (-) 0 [1..3] :: Expr
10:21:13 <lambdabot>  1 - (2 - (3 - 0))
10:21:16 <lispy> heh, I can't type today
10:21:47 <wolverian> oh, that's a useful type :)
10:21:48 <johnnowak> The real problem with python (in this particular case) is that it has some idiotic notion of "built-in" functions to begin with.
10:21:53 <mbenson> well, for one thing I expected arg 2 to be the left side of the function, so that explains one thing.  So basically it's damned hard to implement a foldr as a foldl?  :)
10:22:09 <byorgey> mbenson: impossible, actually =)
10:22:11 <lispy> wolverian: yeah, Expr is cool
10:22:20 <byorgey> mbenson: foldl can be implemented in terms of foldr, but not vice-versa
10:23:08 <glen_quagmire> > runWriterT ( do { tell ["ciao"]; reset; return []; } :: WriterT [String] [] [()]) where reset = tell []
10:23:08 <lambdabot>  Parse error at "where" (column 83)
10:23:20 <byorgey> @where folds
10:23:20 <lambdabot> http://cale.yi.org/index.php/Fold_Diagrams
10:23:21 <paolino> glen_quagmire: I have a recursion down a rose tree, I'm using the list monad, I want to use writerT to log things, but keep only the log of the successful branches
10:23:26 <lispy> Oh does lambdabot not log #darcs afterall?
10:23:29 <byorgey> mbenson: ^^^ those diagrams might be helpful
10:23:49 <mbenson> well, then... definitely food for thought.  Think FPists would be totally blown away if Java methods were named foldLeft and foldRight?
10:23:52 <allbery_b> @listchans
10:23:53 <lambdabot> ##logic #darcs #dreamlinux-es #friendly-coders #gentoo-haskell #gentoo-uy #ghc #haskell #haskell-blah #haskell-books #haskell-hac07 #haskell-hac4 #haskell-overflow #haskell-soc #haskell.de #haskell.
10:23:53 <lambdabot> dut #haskell.es #haskell.fi #haskell.fr #haskell.hr #haskell.it #haskell.jp #haskell.no #haskell.ru #haskell.se #haskell_ru #jhc #jtiger #parrot #perl6 #rosettacode #scala #scannedinavian #thunks #
10:23:53 <lambdabot> unicycling #xmonad
10:24:03 <mbenson> byorgey: thanks!
10:24:15 <johnnowak> it seems to me that the way to learn how to use folds would just be a nice set of exercises... those images in particular seem like they'd just be downright confusing
10:24:19 <Baughn> @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
10:24:19 <lambdabot>  fd:34: hClose: resource vanished (Broken pipe)
10:24:41 <lispy> Baughn: I don't think the bf plugin works correctly these days
10:24:48 <cjs> mbenson: my only real issue with foldr is its inability to be used on infinite lists, but my impression is that you don't use a lot of those in Java...
10:24:50 <mbenson> johnnowak: They're awfully pretty, though... ;)
10:25:13 <glen_quagmire> tell (if sucessful then "log msg" else "") ?
10:25:16 <johnnowak> mbenson: so is a mondrian, but it won't help you understand fold
10:25:17 <glguy> cjs: foldl is the one that doesn't work on infinite lists
10:25:51 <byorgey> johnnowak: it probably depends on your learning style.  some people find the diagrams incredibly enlightening.
10:25:54 <mbenson> Actually, would either of them work on an infinite list?
10:25:58 <Bonus> in haskell or in generat?
10:26:13 <Bonus> if you have a list of real numbers that converge to 0
10:26:14 <johnnowak> byorgey: sure, but not all diagrams are equally enlightening
10:26:15 <byorgey> mbenson: foldr does, since the result can be lazy
10:26:17 <Baughn> lispy: It's just turned off in cabal. I turned it on locally, and it compiles fine
10:26:33 <Baughn> lispy: The patch that turned it off says something about a hack for win32.. apparently a bit too hackish
10:26:43 <byorgey> mbenson: foldl on an infinite list will never give you any output
10:26:49 <lament> heh, from a reddit discussion on objective c
10:26:50 <lament> "calling method on null is perfectly legal and doesn't segfault. This way you can chain methods and get sort-of monads."
10:27:10 <lament> conclusion: haskell poisons people and makes them see monads everywhere
10:27:46 <mrd> I see dead monads
10:28:43 <glen_quagmire> monads can't be seen. that's the whole point.
10:28:56 <mbenson> byorgey:  You're saying that the answer to a foldr of an infinite list could be defined in terms of another foldr, or something like that?
10:29:28 <int-e> > foldr (:) [] [1..]
10:29:30 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
10:29:31 <byorgey> mbenson: I'm saying that a foldr of an infinite list can produce part of the result without first consuming the whole list.
10:29:48 <byorgey> > take 10 $ foldr (:) [] [1..]  -- this works
10:29:49 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
10:30:18 <byorgey> @src foldr
10:30:18 <lambdabot> foldr f z []     = z
10:30:18 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:30:18 <glen_quagmire> foldr (:) [] [1..] ==> (1 : (2 : (3 : (.... : []))))
10:31:29 <glen_quagmire> > foldM (:) [] "hi"
10:31:30 <lambdabot>  Couldn't match expected type `[[a]]' against inferred type `Char'
10:31:43 <byorgey> mbenson: note in the foldr f z (x:xs) case, the result is  f x (foldr f z xs).  If f can produce some output without evaluating the recursive call to foldr, then you can lazily get as much output as you like without evaluating the whole input list.
10:33:27 <n00b101> i am trying to create a coordinate function to find the (line & position) of a text in a string, any help ???
10:34:35 <cjs> glguy: oops, backwards. Thanks.
10:34:38 <johnnowak> ... is there a list of fold-related exercises somewhere? questions like "Write a function that reverses a list using fold and cons."
10:35:18 <mbenson> byorgey: Okay, maybe my understanding of folding is off.  It seems as though you're treating the output of a fold like a generator, where you can get the n results from a list of length n.  I was thinking of its output as being the final product, but you're saying that would be last of the foldr?
10:37:01 <mrd> well he's creating a new list as the output
10:40:44 <byorgey> mbenson: foldr is a way of taking a list and 'summarizing' it into a single value.  however, that value could itself be another list.
10:41:25 <mbenson> what's (:)?
10:41:29 <byorgey> mbenson: and in certain cases, if the output is a list, the beginning of the output list can be computed without looking at the whole input list,
10:41:43 <byorgey> in those cases, the output will be computed lazily.
10:41:47 <glen_quagmire> mbenson: it is cons operator
10:41:52 <byorgey> mbenson: the list constructor.
10:41:56 <byorgey> > (:) 1 []
10:41:57 <lambdabot>  [1]
10:42:02 <byorgey> > (:) 1 [2,3]
10:42:03 <lambdabot>  [1,2,3]
10:42:07 <byorgey> > 1 : [2,3]
10:42:08 <lambdabot>  [1,2,3]
10:42:30 <byorgey> mbenson: note that infix operators can be turned into prefix functions by enclosing them in parentheses.
10:42:37 <n00b101> any help???
10:42:56 <glen_quagmire> n00b101: y is line number. x is column number
10:43:18 <Baughn> @tell paczesiowa I've registered the bug; you can see it at http://hackage.haskell.org/trac/ghc/ticket/2220. I recommend you attach your program as an example.
10:43:18 <lambdabot> Consider it noted.
10:43:47 <n00b101> glen_quagmire yes
10:44:02 <glen_quagmire> i don't know how to saerch a substring in haskell
10:44:05 <byorgey> mbenson: do you understand how lists are represented as repeated application of : ?  i.e. [1,2,3,4] == 1 : 2 : 3 : 4 : []
10:44:31 <n00b101> does anyone know how to?
10:44:32 <byorgey> then a very useful way to think about foldr is that  foldr f z xs  replaces every : in xs by f,  and replaces [] by z
10:45:10 <byorgey> so foldr f z (1 : 2 : [])  is  1 `f` (2 `f` z)
10:45:16 <byorgey> `f` indicates infix application of f
10:45:33 <mbenson> byorgey: whew!  :)
10:46:13 <byorgey> mbenson: is this making sense?
10:46:32 <mbenson> Is it then a somewhat subjective decision on the part of the Haskell RT (or whatever) whether a given foldr can be computed against a list of infinte length?
10:46:41 <mbenson> infinite that is
10:46:55 <Baughn> mbenson: No, it's fully defined
10:47:06 <byorgey> no, foldr can always be computed on a list of infinite length.
10:47:19 <byorgey> it's just that sometimes it might never produce any output =)
10:47:28 <byorgey> whether it can or not is a property of the function f.
10:47:29 <Baughn> The semantics may not be immediately obvious, but they do exist. foldr works on infinite lists, and any code you write that acts in that way always /will/ act in that way..
10:48:05 <mbenson> > foldr (+) 1 [2..]
10:48:06 <lambdabot>  Exception: stack overflow
10:48:23 <mbenson> explanation?  :)
10:48:42 <glguy> + isn't lazy
10:48:46 <Baughn> mbenson: Produces infinite stack of (+ (+ (+ (+ chunks
10:48:47 <snhmib> you sum to infinity
10:48:49 <Baughn> *thunks
10:48:51 <paolino> you prepared an infinite stack of operations
10:49:00 <byorgey> mbenson: (+) is strict in both of its arguments, i.e. it needs both of them fully evaluated to produce a result.
10:49:12 <glguy> > foldr (\ x next -> if x == 100 then True else next) False [1..]
10:49:13 <lambdabot>  True
10:49:33 <Baughn> mbenson: This may be a bit vague, but you have to use foldr only on functions that can be /partially/ evaluated, like anything (usually) that builds a list
10:49:52 <Baughn> If it's an all-or-nothing thing, foldl' is your friend
10:49:54 <mbenson> Baughn:  That's pretty much what I mean but didn't know how to express it here.
10:50:35 <byorgey> glguy's example works, too, since in some cases (when x == 100) it does not need to evaluate next in order to produce a result
10:51:04 <Trinithis> n00b101: (and .) . (. tails) . map . isPrefixOf
10:51:16 <byorgey> eek
10:51:31 <Trinithis> lol
10:52:17 <byorgey> Trinithis: I recommend not using sections of (.) when helping people with the nick 'noob101' =P
10:53:39 <glen_quagmire> using parsec, how can I fail on specific string?
10:53:51 <glguy> Trinithis: is that a long way of writing: \ x y -> null x
10:53:55 <twanvl> glen_quagmire: fail?
10:54:09 <Trinithis> glguy: pointless \s s' -> and $ map (isPrefixOf s) $ tails s'
10:54:16 <int-e> Trinithis: and?
10:54:17 <glguy> Trinithis: right
10:54:22 <glen_quagmire> twanvl: yes. I want to fail on "Hello" to get its line numebr and column number
10:54:27 * int-e expected or.
10:54:28 <glguy> and on a map is all
10:54:31 <Baughn> glguy: (string "foo" >> fail "foo! foo! foo!")
10:54:35 <Baughn> *glen
10:54:48 <Baughn> glen_quagmire: You should probably throw in a try there, too
10:54:49 <int-e> in fact I'd use  any (isPrefixOf needle) . tails $ haystack
10:55:10 <Baughn> ..that is certainly concise.
10:55:18 <twanvl> > "def" `isInfixOf` "abcdefgh"
10:55:18 <lambdabot>  True
10:55:31 <int-e> @index isInfixOf
10:55:31 <lambdabot> bzzt
10:55:32 <glguy> Trinithis:
10:55:32 <glguy> ?check \ e n ->  and (map (isPrefixOf e) (tails n)) == null e
10:55:33 <lambdabot>  OK, passed 500 tests.
10:56:41 <Trinithis> glguy: i dont get the null variant
10:57:07 <glguy> those functions are equivalent. The first element of tails is []
10:57:29 <glguy> bottoms excluded
10:58:04 <mbenson> I think for my purposes I won't consider infinite lists in Java foldl/foldr implementations for now; I'll simply fail on these.
10:58:16 <olsner> byorgey: how went it, with the chromatic polynomials?
10:58:45 <mbenson> I appreciate everyone's time and accommodation and I'll definitely keep Haskell in mind when I get around to exploring some pure-FP disciplines...
11:01:32 <Trinithis> glguy: oh lol, i meant or, not and
11:03:28 <byorgey> olsner: well, I'm still fiddling with it.  The particular graph whose chromatic polynomial I want to compute is much too large to do it directly.
11:03:44 <byorgey> olsner: but it has a lot of symmetry and structure, so it may be possible to do it in a clever way.
11:03:58 <olsner> yeah, I figured it would be... but it does have a lot of symmetry
11:06:04 <n00b101> int-e that gives a boolean i need a tuple
11:06:12 <n00b101> init-e (x,y)
11:06:16 <byorgey> I know the answer for a triangle of four rows now, but going from there to eight is a big leap =(
11:06:33 <olsner> I guess if you could efficiently find isomorphic graphs you should be able to use a lot of that structure without too much theoretical work
11:06:56 <n00b101> int-e (x,y)
11:07:06 <byorgey> olsner: hmm, you mean with memoization?
11:08:23 <olsner> yeah... otoh, that might just give you 2^64 or so graphs to memoize without actually helping
11:09:15 <int-e> play with [(x, y) | (x, l) <- zip [0..] (lines haystack), (y, l') <- zip [0..] (tails l), needle `isPrefixOf` l']
11:09:42 <int-e> I guess I switched x and y there.
11:13:51 <pierre-> hello
11:20:32 <byorgey> hi pierre-
11:29:21 <nomeata> Hi. I try to deplay some haskell app on an older machine with only ghc 6.6. I manually installed the bytestring package, but now I get:
11:29:37 <nomeata>     Could not find module `Data.ByteString.Lazy.Char8':     it was found in multiple packages: bytestring-0.9.0.4 base
11:30:05 <nomeata> (but using the bytestring in base does not work because the module needs Data.Bytestring.Internal). What can I do?
11:30:24 <nomeata> alternatively, how can I build a binary that works on oder glibc, i.e. without the create_timer problem?
11:36:47 <Gilly> what is the usual way to deal with cyclic imports?
11:37:20 <opqdonut> the ghc manual has a section on that
11:37:31 <opqdonut> basicalyy you split the packages so that the cycle is broken
11:37:42 <Gilly> right
11:38:03 <Baughn> nomeata: Compile ghc yourself, edit mk/config.h to set HAVE_TIMER_CREATE to 0?
11:38:27 <Baughn> nomeata: That is, assuming that's the only place that needs it. Alternately you could just break the test in configure.ac yourself.
11:38:47 <nomeata> Baughn: will the generated files then work on newer boxes, or do I have to maintain two copies of ghc?
11:39:23 <Baughn> nomeata: I expect they'd work on newer boxes. It just wouldn't use timer_create, which would make it less efficient, but the old api still works.
11:40:24 <nomeata> hmm. I think I rather mess around with ghc6.6 on the server then, try to make my program run
11:40:49 <nomeata> anything I can do about the multiple package problem?
11:40:49 <Baughn> I don't think that's going to happen. You'd have to backport it to the older bytestring.
11:41:02 <Baughn> Yes. Don't install bytestring.
11:41:16 <Baughn> Or you could edit bytestring to change all the package names
11:42:24 <nomeata> allright...
11:43:50 <lament> here's a little expressivity challenge: I want a datatype for "vague dates". A vague date can be 2008-04-14, or 2008-04, or just 2008 (but not, for example, 2008-*-14). It can also be 2008-Spring. How to express this most accurately and concisely?
11:44:10 <glguy> as a range?
11:44:28 <glguy> data DateRange = DateRange Date Date
11:44:29 <glguy> ?
11:44:34 <lament> ranges are far more powerful than what i described.
11:44:42 <Baughn> Is that a problem?
11:45:02 <lament> obviously you could do it with a range but then you would lose all the invariants
11:45:16 <Baughn> You'd just have to write constructors that enforce them
11:45:40 <Baughn> I suppose you could arrange to do this with types instead, but it'd take more code and be harder to understand. I don't see why you'd want to.
11:45:43 <tromp> as a VagueDate = Date | MonthYear | Year
11:45:48 <lament> in theory it's possible to encode the invariant that disallows 2008-*-14 in the type system, as well as even the invariants that certain months have 30 days and others have 31
11:45:57 <nomeata> with the bytestring version in ghc6.6, how can I import the ByteString constructor?
11:45:59 <lament> although that last one is probably too much
11:46:08 <heatsink> lament: (Int, Maybe (Int, Maybe Int))?
11:46:22 <lament> heatsink: yeah, that's what i came up with too
11:46:31 <lament> pretty lame :D
11:46:36 <heatsink> yea
11:47:10 <gnuvince> @src Data.Map.lookup
11:47:10 <lambdabot> Source not found. Just try something else.
11:47:21 <gnuvince> @src lookup
11:47:21 <lambdabot> lookup _key []          =  Nothing
11:47:21 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
11:47:21 <lambdabot>                         | otherwise = lookup key xys
12:05:26 <lament> does (getCurrentTime >>= putStrLn . show) fail for people?
12:06:21 <olsner> <interactive>:1:0: Not in scope: `getCurrentTime'
12:06:35 <lament> :m +Data.Time.Clock
12:06:41 <Beelsebob> other than that... why not getCurrentTime >>= print
12:06:47 <sethk> anyone know of a library call that will take a symbolic link name and return the name of the file it points to?
12:06:53 <lament> cause i didn't know about print :)
12:06:59 <Beelsebob> no instance for Show UTCTime
12:07:17 <lament> haddock documentation says there is :(
12:07:19 <paolino> no System.Time.Clock here
12:07:29 <lament> paolino: it's Data.Time.Clock
12:07:37 <paolino> :d
12:08:02 <Beelsebob> lament: http://www.haskell.org/ghc/docs/latest/html/libraries/time/Data-Time-Clock.html <_- these docs dont
12:08:03 <lambdabot> http://tinyurl.com/2ydz82
12:08:19 <Beelsebob> actually... yes they do
12:08:23 <Beelsebob> I'm just a moron
12:08:35 <lament> Beelsebob: yep, they do, and it's the same version that I have
12:08:40 <lament> odd
12:09:09 <lament> haddock doesn't invent stuff, so the docs reflect some other version
12:09:33 <Beelsebob> idd
12:09:38 <Beelsebob> well actually
12:09:47 <Beelsebob> I'm not sure I trust haddock not to invent stuff
12:09:55 <Beelsebob> it's parser really isn't very reliable
12:11:18 <lament> heh :)
12:11:34 * paolino wonder what an IO is doing under Data branch
12:11:54 <lament> @instances UTCTime
12:11:55 <lambdabot> Couldn't find class `UTCTime'. Try @instances-importing
12:12:08 <lament> @instances-importing Data.Time.Clock UTCTime
12:12:08 <lambdabot> Couldn't find class `UTCTime'. Try @instances-importing
12:12:09 <Beelsebob> paolino: it's because the module defines data formats for represeting time
12:12:20 <Beelsebob> and then getCurrentTime just happens to fit in the module
12:15:15 <Syzygy-> What was the name of the lib function that removes all duplicates in a list?
12:15:23 <Zao> nub?
12:15:26 <Syzygy-> Thanks
12:15:57 <mauke> lament: Prelude Data.Time> getCurrentTime >>= print
12:15:57 <mauke> lament: Prelude Data.Time> getCurrentTime >>= print2008-04-14 19:14:30.624066 UTC
12:16:00 <paolino> on unsorted lists
12:16:07 <mauke> wtf
12:16:28 <Beelsebob> mauke: what version of GHC?
12:16:38 <mauke> lament: anyway, it works here. the trick is to import Data.Time and not some submodule
12:16:54 <mauke> 6.8.2
12:17:08 <lament> mauke: I see. Importing Data.Time works here as well
12:17:51 <lament> do you know why this happens?
12:18:03 <paolino> forgot to export
12:18:07 <lament> the source for Data.Time simply reimports the other modules
12:18:13 <lament> there's nothing else in there
12:18:38 <mauke> one of those other modules contains the instance declaration
12:19:22 <paolino> Data.Time.Clock should import it also
12:19:26 <lament> so when haddock shows instances, it takes them from everywhere?
12:21:31 <ivan_salazar_v> Hello. I'm having trouble sending a binary file (an image) through a socket connection (I'm trying to program a web server) . I'm using this code which doesn't work:
12:21:31 <ivan_salazar_v> do resource <- Data.ByteString.readFile namehSetBinaryMode handle TrueData.ByteString.hPut handle resource
12:21:39 <paolino> lament : probably haddock process is rooted on Data.Time
12:30:12 <ivan_salazar_v> Hello, is there a way to read a binary file in haskell and send it through a socket?
12:30:34 <Peaker> @faq Sending binary files on a socket
12:30:34 <lambdabot> The answer is: Yes! Haskell can do that.
12:30:46 <olsner> <3
12:30:50 <ivan_salazar_v> Lol.
12:31:07 <ivan_salazar_v> And how do you do that?
12:32:37 <Trinithis> @faq Can Haskell do anything?
12:32:37 <lambdabot> The answer is: Yes! Haskell can do that.
12:32:49 <olsner> the @faq is sometimes somewhat brief on exactly *how* to do stuff though ;-)
12:32:54 <ivan_salazar_v> Oh, my...
12:33:03 <ivan_salazar_v> lol
12:33:20 <erg0t> fuck I broke + in lambdabot, sorry :(
12:33:26 <erg0t> I was testing @let
12:33:29 <mauke> > 2 + 2
12:33:29 <lambdabot> Terminated
12:33:32 <mauke> @undefine
12:33:33 <lambdabot> Undefined.
12:33:35 <mauke> > 2 + 2
12:33:36 <lambdabot>  4
12:33:39 <erg0t> :)
12:33:40 <erg0t> thanks
12:34:06 <Peaker> mauke, what does @undefine undefine specifically?
12:34:22 <mauke> everything defined with @let
12:35:44 <paolino> @faq haskell use guns for sending files
12:35:45 <lambdabot> The answer is: Yes! Haskell can do that.
12:35:51 <paolino> mmh
12:36:01 <jsnx> look at this:
12:36:13 <jsnx> > liftM show [1, 2, 4]
12:36:13 <lambdabot>  ["1","2","4"]
12:36:35 <jsnx> we don't really need map any more...
12:36:49 <sethk> > show [1, 2, 4]
12:36:49 <lambdabot>  "[1,2,4]"
12:36:56 <Trinithis> liftM == fmap ?
12:37:04 <sethk> > liftM show [1,2,4]
12:37:05 <lambdabot>  ["1","2","4"]
12:37:07 <sethk> interesting
12:37:08 <Cale> hmm, when does hackage re-attempt building things?
12:37:08 <mauke> > show . [1,2,4]
12:37:09 <lambdabot>  ["1","2","4"]
12:37:13 <mauke> where is your god now?!
12:37:23 <jsnx> mauke: lolz
12:37:34 <jsnx> mauke: how did that happen?
12:37:35 <heatsink> mauke: @undefine
12:37:45 <paolino> :t liftM
12:37:46 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:37:52 <Cale> :t (.)
12:37:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:38:00 <paolino> :t fmap
12:38:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:38:13 <jsnx> liftM lifts a function into any monad, and map lifts it into the list monad
12:38:21 <Cale> :t map
12:38:22 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:38:23 <Cale> ;)
12:38:30 <olsner> mmm, (.) <3
12:38:33 <jsnx> :t map
12:38:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:38:45 <jsnx> not on my machine
12:38:47 <resiak> how many synonyms do you *need*!
12:38:50 <bd_> note: lambdabot does not necessarily match the normal prelude
12:38:50 <Trinithis> what is the point of forall? isnt it implied anyway?
12:39:04 <Cale> resiak: The hope is that (.) and map will eventually be the only ones left :)
12:39:07 <bd_> Trinithis: sure, inthis use it's implied
12:39:07 <jsnx> Trinithis: you can move it around and write papers
12:39:17 <resiak> Cale: and what about (<$>)? :)
12:39:29 <jsnx> :t (.)
12:39:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:39:31 <Trinithis> bd_: what would be a case when forall would have to be explicitly stated>?
12:39:38 <Peaker> Trinithis, I asked the same question.. forall is implied when its on the most external level. When its inside sub-expressions, its not the same
12:39:39 <bd_> :t runSt
12:39:40 <lambdabot> Not in scope: `runSt'
12:39:42 <bd_> :t runST
12:39:42 <lambdabot> forall a. (forall s. ST s a) -> a
12:39:49 <Cale> resiak: Perhaps an argument could be made for it, but I don't know.
12:39:51 <bd_> ^^^ that's one
12:39:54 <bd_> GADTs are another
12:39:55 <Trinithis> Peaker: ok
12:40:02 <jsnx> :t (.)
12:40:04 <jsnx> :t map
12:40:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:40:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:40:11 <Cale> jsnx: Note that this is just in lambdabot :)
12:40:11 <resiak> jsnx: the types aren't going to change if you keep doing that
12:40:18 <bd_> :t Prelude.map
12:40:19 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
12:40:26 <jsnx> resiak: i wanted to see them together to be sure
12:40:33 <Cale> :t (Prelude..)
12:40:34 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
12:40:57 <paolino> lambdabot import postlude
12:40:57 <jsnx> so fmap, (.) and map all have the same type in lambdabot
12:41:03 <Cale> yeah
12:41:05 <Heffalump> gnggh!
12:41:27 <mauke> :t [(.), map, (<$>), fmap, liftA, liftM]
12:41:28 <lambdabot> forall a b (f :: * -> *). (Monad f, Applicative f) => [(a -> b) -> f a -> f b]
12:41:32 <jsnx> so hypothetically, we can get by with (.)
12:41:34 <shepheb> lambdabot uses Cale's black-belt Haskell remix.
12:41:37 <Cale> jsnx: right :)
12:41:43 <gwern> hey - how do you get cabal to handle #include directives? ie I have a bunch of '#include "impossible.h"' where impossible.h is at ./
12:41:51 <Heffalump> it shouldn't, at least not in the default command
12:41:56 <jsnx> we can even use (.) for liftM?
12:41:57 <gwern> is this where the {-# INCLUDE #-} pragma is supposed to be used?
12:42:11 <Cale> It's not like I've changed the language itself :)
12:42:20 <Cale> jsnx: yep
12:42:23 <Heffalump> the libraries are specified in the report too, you know
12:42:25 <Cale> jsnx: Since every monad is a functor
12:42:32 <jsnx> Cale: where do i get this new haskell?
12:42:34 <mauke> :t read . getLine
12:42:35 <lambdabot> forall a. (Read a) => IO a
12:42:45 <Cale> jsnx: Bug the Haskell' people?
12:42:50 <jsnx> oic
12:43:06 <mauke> jsnx: import Prelude hiding ((.)); (.) x = fmap x
12:43:07 <jsnx> but that's like a new language or something
12:43:46 <Cale> jsnx: Lambdabot just imports the Prelude hiding ((.), map, (++)), and defines those itself.
12:44:06 <jsnx> :t (++)
12:44:06 <lambdabot> forall m. (Monoid m) => m -> m -> m
12:44:21 <jsnx> @src (++)
12:44:21 <lambdabot> (++) []     ys = ys
12:44:21 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
12:44:32 <Cale> (++) is the same as mappend
12:44:36 <resiak>  ! Heffalump explodes.
12:44:42 <jsnx> oic
12:44:43 <Heffalump> Cale: I really think that you shouldn't be trying to push your prejudices onto the channel, in particular newbies, by altering the default behaviour of what is effectively a standard channel service, no matter who happens to be running it now.
12:45:08 <jsnx> Heffalump: prejudices?
12:45:14 <Trinithis> not like he broke anything... only enhanced
12:45:23 * Heffalump is much more in favour of (++) etc being MonadPlus/Monoid than the (.)/fmap crap, but lambdabot should reflect the language as it is
12:45:25 <Cale> Heffalump: there are lots of other things which lambdabot supports that GHCi doesn't
12:45:38 <Cale> > foldr f z [1,2,3,4,5]
12:45:38 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 z))))
12:45:40 <Heffalump> Trinithis: you need many more signatures to resolve ambiguity with these changes
12:45:44 <jsnx> Heffalump: what would that look like
12:45:47 <Cale> Heffalump: No you don't.
12:45:58 <Heffalump> and :t is flat out lying
12:46:06 <Baughn> Cale: Should I still be sending lambdabot patches to dons? The repository seems slightly schizophrenic about its owner.
12:46:28 <Cale> Baughn: You should send them to me.
12:46:45 <Cale> Baughn: Unless dons is still applying patches that I don't know about?
12:46:47 <jsnx> maybe we should have a few lambdabots
12:47:05 <Baughn> Cale: Not that I know, but unfortunately he is where darcs send wants to send things
12:47:19 <jsnx> because, in the words of that inimitable simpson's kid, i am learnding
12:47:21 <Cale> The functor in question is always determined by the type of the last thing in the chain of (.)'s
12:47:21 <Heffalump> that would get really annoying. But I was just thinking about running one that only replies in cases where Cale's one is being inaccurate
12:47:23 <Riastradh> Hey, folks, ever thought about incorporating NumericPrelude into lambdabot?
12:47:39 <Cale> Riastradh: That's a neat idea :)
12:47:40 <Heffalump> cale: not for map
12:47:46 <Cale> Heffalump: hm?
12:47:47 <paolino> jsnx: chorus effect ? with some dissonances ?
12:48:01 <Heffalump> Cale: overloading isn't resolved automatically for map.
12:48:11 <Peaker> what's NumericPrelude?
12:48:15 <Heffalump> I'm not convinced you're right about (.) either but can't think of a counter-example while half-asleep
12:48:16 <Cale> Heffalump: But it's rarely a problem.
12:48:25 <Cale> Heffalump: Try it! :)
12:48:32 <Riastradh> NumericPrelude is a project to replace the Prelude's numerics with something more mathematically designed.
12:48:39 <ari> :t (.)
12:48:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:48:44 <ari> Oh my, oh mu
12:48:45 <Baughn> Cale: Very well. Sent.
12:48:57 <jsnx> Heffalump: so, what is it that you were talking about with MonadPlus and (++) ?
12:49:10 <Saizan> :t (++)
12:49:11 <lambdabot> forall m. (Monoid m) => m -> m -> m
12:49:13 <Heffalump> jsnx: just that (++) should be mappend as was suggested above
12:49:26 <sethk> mappend?
12:49:33 <Cale> :t mappend
12:49:34 <lambdabot> forall a. (Monoid a) => a -> a -> a
12:49:35 <Heffalump> or mplus, or something. I guess with a better type class system every MonadPlus is a Monoid
12:49:52 <shepheb> Heffalump: ((->) e) is a Monad, and hence a Functor. what fmap implementation makes more sense on functions than (.) ?
12:50:04 <sethk> what is the pend in mappend intended to convey?  why that name?
12:50:07 <Heffalump> but that's how I'd like the libraries to be, not how they are now. lambdabot's standard commands should be what the language is now.
12:50:10 <Heffalump> sethk: m(append)
12:50:18 <thoughtpolice> so to those there, how'd the hackathon go? :)
12:50:19 <sethk> Heffalump, ok, that makes more sense  :)
12:50:22 <Syzygy-> sethk: m append
12:50:26 <Heffalump> shepheb: I'm complaining about (.) = fmap, not vice-versa
12:50:27 <sethk> Syzygy-, thanks
12:50:32 <Heffalump> thoughtpolice: pretty well
12:50:46 <thoughtpolice> Heffalump: how many people?
12:50:47 <Syzygy-> Majestic stereo. As it were.
12:50:49 <Cale> Heffalump: But it already isn't what the language is now. It imports lots of things, many of which are only available in lambdabot.
12:50:50 * Heffalump didn't get that much done but had quite a few good conversations with people about where things are going
12:50:53 <Heffalump> 20-30
12:51:16 <Heffalump> Cale: adding extra stuff is significantly different to changing stuff that's already there
12:51:30 <Cale> I'm just generalising things.
12:51:33 <Heffalump> however much you deny it, you've actually changed what (.) and map are, particularly as reported by :t
12:51:39 <thoughtpolice> cool stuff. i'm hoping to attend the next hackathon, be it later this year or next. don't know how much i would be able to help, but meeting other haskellers would be worth it?
12:51:49 <Heffalump> yes, and those generalisations *aren't what the language is now*
12:52:11 <Heffalump> it's obvious that you can have things that aren't specified by the language. But changing things that are specified is just wrong.
12:52:19 <Heffalump> thoughtpolice: I think it's well worthwhile.
12:52:25 <Cale> Heffalump: What better place to play with new ideas for what the libraries should be?
12:52:47 <Heffalump> Cale: yes, sure, in a *non-default* command. We use > and :t to demonstrate stuff to newbies.
12:53:57 <Cale> I think someone's working on that :)
12:54:03 <Heffalump> working on what?
12:54:24 <jsnx> to be fair, i think Heffalump's point about n00bs is a worthy one -- if i were in the middle of explaining map to someone and got that type back, it would give me pause
12:54:25 <Heffalump> you're the one that changed what they do, it should be your responsibility
12:54:59 <shepheb> @ho map
12:54:59 <lambdabot> Maybe you meant: hoogle hoogle+ . ? @ bf echo ft ghc id pl rc show thx v wn yow
12:55:05 <roconnor> Cale: Heffalump is basically right
12:55:07 <shepheb> @hoogle map
12:55:08 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
12:55:08 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
12:55:08 <lambdabot> Data.ByteString.map :: (Word8 -> Word8) -> ByteString -> ByteString
12:55:10 <Cale> Heffalump: Allowing for multiple contexts for commands.
12:55:11 * Heffalump would be happy to host lambdabot instead if you don't want to provide one that does do it right
12:56:06 <Heffalump> thoughtpolice: where are you based?
12:56:36 <thoughtpolice> Heffalump: texas
12:57:21 <paolino> :t (Prelude.map)
12:57:21 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
12:57:54 <Baughn> :t (L.map)
12:57:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:58:32 <Cale> :t (Prelude..)
12:58:33 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
12:58:41 <paolino> :t@cale map
12:59:02 <Heffalump> thoughtpolice: the thought is that there'll be one just after or before ICFP this year, probably in Portland since we don't know anyone in Victoria
12:59:22 <Heffalump> and then another in Europe again sometime next spring
12:59:42 <Heffalump> this doesn't preclude other people organising ones, of course (and indeed they do, e.g. HaL)
13:00:10 <jsnx> the bay area functional programmers seem to be a bunch of retards
13:00:23 <Heffalump> paolino: that's a neat idea, especially if people could easily define their own
13:00:28 <jsnx> we have a little group -- bayfp -- but we don't really do anything
13:00:29 <Heffalump> jsnx: that's nice of you :-)
13:00:38 <Heffalump> do you meet up regularly?
13:00:44 <jsnx> Heffalump: once a month
13:00:49 <thoughtpolice> Heffalump: cool stuff. if it falls anywhere during the summer or after hopefully I could attend, since i can't skip out on my classes; don't think my hs they'd accept "went to haskell hackathon" as a excused absence :)
13:00:49 <Heffalump> that's already a pretty good start, it's like the London HUG
13:00:50 <jsnx> Heffalump: where are you?
13:01:04 <Heffalump> jsnx: UK. I live some way north of London and work in London.
13:01:09 <jsnx> oic
13:01:30 <jsnx> anybody here in the bay area?
13:01:33 <Heffalump> I didn't realise you were talking about yourself when I typed "that's nice of you"
13:01:53 <jsnx> Heffalump: yeah, i thought i might have slammed you by accident
13:02:15 <jsnx> i'm pretty confident that there are very few bay area people on the channel
13:02:32 <jsnx> "functional programming" seems to include using ruby, out here, anyways
13:02:58 <jsnx> the level of rigour is pretty low
13:03:30 <tromp> are there any other pure functional languages?
13:03:35 <Heffalump> anyway, local user groups are a really good thing
13:03:37 <Heffalump> tromp: Clean
13:03:38 <thoughtpolice> tromp: clean
13:03:39 <jsnx> the guy who wrote HAppS is out here, but he's seriously the only guy
13:04:07 <jsnx> maybe we need a *haskell* users group
13:04:27 <Heffalump> jsnx: Whatever works for the numbers you have in the area. Anything is good for providing a point of contact, IMO
13:04:27 <jsnx> to keep out the riff-raff
13:04:38 <Heffalump> and try not to call them "riff-raff" ;-)
13:04:53 <mauke> does http://mauke.ath.cx/stuff/perl/add.pl count as functional? :-)
13:05:08 <jsnx> it's got that .pl on the end
13:05:14 <jsnx> probably not
13:05:52 <tromp> i know clean doesn't use monads for IO, but does it still have monads?
13:06:21 <jsnx> really, we need a *declarative programming* group
13:06:36 <jsnx> that would sort the wheat from the chaff
13:06:46 <mauke> there are perl modules for that
13:06:57 <jsnx> mauke: cute
13:07:05 <jsnx> mauke: there's C for it too, and C++
13:07:20 <jsnx> let's blow the doors wide open -- there's nothing different about haskell
13:07:46 <Heffalump> tromp: well, it has type classes, so they could be added easily if not already there. I don't think it has do-notation
13:08:04 <jsnx> everybody in! you've all got first class functions, even if that means storing string templates in a hash table and evalling them!
13:08:15 <tromp> i guess no list comprehensions either then
13:08:37 <mauke> jsnx: that sounds like LISP
13:08:51 <gwern> I has a problem. so I have this 'impossible.h' which imports a module ande defines some stuf. the problem is that when I compile through cabal, it errors like thus: 'src/Lcs.lhs:47:0:  error: impossible.h: No such file or directory'
13:09:02 <jsnx> mauke: no, they have real macros that operate on the AST
13:09:18 <jsnx> mauke: which is rather different to `eval`
13:09:38 <ski> tromp : clean has list comprhensions, and also some monad combinators for state monad
13:09:53 <gwern> so my question is, why does neither {-# INCLUDE "impossible.h" #-} nor '{-# LANGUAGE CPP #-}; #include "impossible.h"' work?
13:10:00 <mauke> as long as lambda returns a list whose first symbol is 'lambda', there's no big difference
13:10:03 <edwardk> gwern: iis CPP not aware that src should be in your path, can you pass it the include path?
13:10:06 <Heffalump> gwern: have you told cabal what the include path is?
13:10:11 <jsnx> gwern: can you give us a link to source repository, so we can examing your directory heirarchy?
13:10:33 <gwern> jsnx: http://darcs.net/ although my cabalizing changes are not there
13:10:34 <lambdabot> Title: darcs
13:11:07 <gwern> Heffalump: but the include dir is ./, impossible.h and the problematic file are in the same dir
13:11:16 <jsnx> mauke: i don't actually use lisp or scheme -- but the macro system in scheme apparently has a bunch of restrictions in it -- it's not the same thing as `eval`
13:11:35 <jsnx> mauke: i can't defend them, though
13:11:38 <mauke> jsnx: I mean old school LISP without lexical variables
13:11:51 <Heffalump> gwern: ok, I dunno then. I was just speculating.
13:12:09 <jsnx> mauke: i can't say much about it -- i'm mocking the tendency to be overly inclusive
13:12:16 <jsnx> mauke: i'm sure you know what i mean
13:12:16 <gwern> hm. 'src/Lcs.lhs:47:0: error: src/impossible.h: No such file or directory
13:12:19 <sjanssen> gwern: did you set include-dirs?
13:12:29 <mauke> yeah
13:12:33 <gwern> sjanssen: no. would it be include-dirs: src/?
13:12:34 <sjanssen> gwern: hs-source-dirs and include-dirs are separate
13:12:49 <gwern> ah
13:12:53 <sjanssen> gwern: wherever impossible.h is
13:13:02 <gwern> yeah, that;d explain it. there is no system-wide impossible.h, after all
13:13:30 <Heffalump> oh, that's what I was asking about, and I thought it was what you answered :-)
13:13:41 <mauke> I'm just saying, you can write side-effect free/loop free, curried, CPS, tail-call-optimized code in perl :-)
13:13:46 <mauke> it just looks ... interesting
13:13:49 <jsnx> mauke: i suppose you could do 'functional programming' of a sort in awk
13:14:07 <jsnx> mauke: or in any language
13:14:11 <paczesiowa> is there some Applicative magic to simplify things like do {x<-m1; y<-m2; f x y} , like regular greedy left-to-right arguments evaluation?
13:14:11 <lambdabot> paczesiowa: You have 1 new message. '/msg lambdabot @messages' to read it.
13:14:19 <mauke> jsnx: not directly
13:14:23 <jsnx> but why? if i'm writing C, pointers are my friend
13:14:40 <mauke> if you have to build an interpreter first, it's sort of pointless
13:14:45 <jsnx> i should be imperative in the imperative languages, staying out of their weak spots
13:14:50 <paolino> paczesiowa: liftM2 ?
13:14:56 <jsnx> mauke: interpreter?
13:14:57 <paolino> :t liftM2
13:14:58 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:15:17 <mauke> :t liftA2
13:15:19 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
13:15:47 <jsnx> Cale: do you have any neat operators that generalize (&&&) over tuples?
13:15:59 <jsnx> Cale: is there a 'tuple monad' ?
13:16:11 <Cale> There's the writer monad...
13:16:21 <mauke> @src Writer
13:16:21 <lambdabot> Source not found. :(
13:16:25 <Cale> But I'm not sure that has anything to do with (&&&)
13:16:26 <edwardk> jsnx: sure, there is a free one for (,) =)
13:16:34 <mauke> @unmtl Writer a b
13:16:34 <lambdabot> (b, a)
13:16:45 <edwardk> and a reader comonad, and writer can be written using (,)
13:17:00 <gwern> 'src/Darcs/Sealed.lhs:45:19: Type found where type variable expected' <-- hm. I wonder what extension that is?
13:17:01 <jsnx> but what about (,,) and (,,,) and so on?
13:17:24 <paczesiowa> paolino: isn't there some <!@#$^&> infix operator? liftMN requires me to know the number of arguments
13:17:31 <edwardk> jsnx: they are really just unrelated type constructors, so there is no glue tying them together.
13:17:44 <conal> paczesiowa: use <$> and <*>
13:17:49 <roconnor> triples and higher are often a sign of bad code; record types often should be defined instead.
13:17:50 <paczesiowa> paolino: and I would like some semi automatic method to translate some imperative code
13:17:54 <conal> paczesiowa: or fmap and ap
13:18:18 <mauke> paczesiowa: I don't know but you seem to have missed the point of Applicative
13:18:19 <jsnx> roconnor: i agree, in general
13:18:32 <roconnor> jsnx: as long as you know then. :)
13:18:38 <edwardk> you could write a pretty boring monad with return x = (x,x); (x,y) >>= k = (fst (k x), snd (k x)) maybe but i'm not sure if it satisfies all the laws. never really thought through it before.
13:18:47 <paczesiowa> mauke: I can't miss point of something I haven't used yet:P
13:18:57 <mauke> @src Applicative
13:18:57 <lambdabot> class Functor f => Applicative f where
13:18:57 <lambdabot>     pure  :: a -> f a
13:18:57 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
13:18:59 <edwardk> then you'd get monads for each of the (,,,...)'s
13:19:02 <Toxaris> > (+) <$> [1, 2, 3] <*> [100, 200, 300] -- paczesiowa
13:19:03 <lambdabot>  [101,201,301,102,202,302,103,203,303]
13:19:13 <mauke> > pure (+)
13:19:14 <lambdabot>        add an instance declaration for (Show (f (a -> a -> a)))
13:19:28 <mauke> > pure (+) <*> [1,2,3] <*> [100,200,300]
13:19:28 <lambdabot>  [101,201,301,102,202,302,103,203,303]
13:19:49 <edwardk> but they have to be boxed to keep all the types the same, or you just get another variant on writer
13:20:06 <edwardk> so i guess thats kinda useless
13:20:50 <wagstaff> ?pl \x-> x `seq` f x
13:20:50 <lambdabot> ap seq f
13:20:52 <Toxaris> > (\a b c d -> a + b + c + d) <$> Just 3 <*> Just 2 <*> Just 5 <*> Just 17 -- no need to count arity by hand, just insert another <*>
13:20:53 <lambdabot>  Just 27
13:21:39 <conal> lambdabot doesn't know about <*>
13:21:44 <ski> edwardk : `(Bool ->)'
13:21:51 <conal> or it would have said seq <*> f
13:22:30 <mauke> (f $!)
13:23:06 <edwardk> ski: yeah
13:23:08 <ski> paczesiowa : so "return f `ap` m1 `ap` m2" or "pure f <*> m1 <*> m2", as mentioned
13:23:54 <byorgey> or "f <$> m1 <*> m2"
13:25:10 <paczesiowa> that gives type I need to join
13:25:17 <paczesiowa> IO (IO ())
13:25:57 <paczesiowa> and nesting level will be equal to number of arguments
13:25:58 <mauke> then you're doing it wrong
13:26:04 <byorgey> in that case, you likely wanted =<< somewhere instead of <*>
13:26:37 <paczesiowa> > let putTwoLines x y = putStrLn x >> putStrLn y in putTwoLines <$> getLine <*> getLine
13:26:38 <lambdabot>  <IO (IO ())>
13:27:12 <mauke> > let putTwoLines x y = putStrLn x >> putStrLn y in liftM2 putTwoLines getLine getLine
13:27:13 <lambdabot>  <IO (IO ())>
13:27:22 <mauke> the bug is in your expectations
13:27:54 <paczesiowa> so it's impossible?
13:28:09 <byorgey> > let putTwoLines x y = putStrLn x >> putStrLn y in putTwoLines <*> getLine <*> getLine
13:28:09 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `IO ()'
13:28:38 <mauke> > let putTwoLines x y z = putStrLn x >> putStrLn y >> putStrLn z in putTwoLines <$> getLine <*> getLine <*> getLine
13:28:39 <lambdabot>  <IO (IO ())>
13:28:53 <mauke> the nesting level is exactly two, so a single join suffices
13:29:18 <mauke> > let putTwoLines x y z = putStrLn x >> putStrLn y >> putStrLn z in putTwoLines <$> getLine <*> getLine =<< getLine
13:29:19 <lambdabot>  Couldn't match expected type `a -> String'
13:29:24 <ski> paczesiowa : sorry, you're right, you had `f x y' not `return (f x y)' .. simply omit the `return'/`pure'
13:29:25 <roconnor> a -> b -> IO () /= IO (a -> b -> ())
13:29:31 <paczesiowa> > let putThreeLines x y z = putStrLn x >> putStrLn y >> putStrLn z in putThreeLines <$> getLine <*> getLine <*> getLine
13:29:32 <lambdabot>  <IO (IO ())>
13:29:50 <mauke> > let putTwoLines x y z = putStrLn x >> putStrLn y >> putStrLn z in (putTwoLines <$> getLine <*> getLine) =<< getLine
13:29:50 <lambdabot>  Couldn't match expected type `a -> String'
13:30:09 <byorgey> the first IO represents the IO from the getLines; the inner IO is because putNLines results in an IO ()
13:30:16 <paczesiowa> mauke: yeah, it's always IO (IO ())
13:30:49 <ski> (paczesiowa : actually, i'm talking garbage, ignore me, i'm too tired to think properly)
13:30:52 <Peaker> @type <$>
13:30:53 <lambdabot> parse error on input `<$>'
13:31:02 <resiak> @ty (<$>)
13:31:03 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:31:09 <paczesiowa> how about this: how would you translate C code like "foo(bar(x),baz(y))" ?
13:31:47 <paczesiowa> with, foo :: a -> b -> IO (), bar,baz :: a -> IO b
13:32:07 <Peaker> @undo do { a <- bar x ; b <- baz y ; foo a b }
13:32:08 <lambdabot> bar x >>= \ a -> baz y >>= \ b -> foo a b
13:32:45 <byorgey> join (foo <$> (bar x) <*> (baz y))
13:33:02 <mauke> @pl bar x >>= \ a -> baz y >>= \ b -> foo a b
13:33:02 <lambdabot> (baz y >>=) . foo =<< bar x
13:34:04 <paczesiowa> byorgey: good enough
13:34:07 <conal> i like that pattern.  it never occurred to me to toss in a join onto the liftAN .
13:34:25 <paczesiowa> thanks guys
13:35:15 <edwardk> about half the time i use liftMn, i wind up having to sneak a join on there coz i got sloppy
13:35:34 <byorgey> yeah, the join makes sense if the outermost function you are applying is a -> b -> .... -> A z  instead of just a -> b -> ... -> z
13:35:44 <byorgey> where A is some Applicative type
13:35:53 <byorgey> er, sorry ,that wouldn't be join
13:36:15 <byorgey> for join it would have to be a monad
13:36:19 <edwardk> heh if you can join it, and return/pure it, and you're in hask you've got a monad
13:36:35 <edwardk> er well, actually you've just got a monad
13:36:47 <paczesiowa> > let a <$$> b = join $ a <$> b in let putTwoLines x y = putStrLn x >> putStrLn y in putTwoLines <$$> getLine <*> getLine
13:36:47 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `IO ()'
13:36:51 <Peaker> conal, hey, did you take a look at the Subtext 1 demos?
13:37:26 <conal> Peaker: no, i haven't.  i got absorbed working on my icfp submission and completely forgot.
13:37:30 <byorgey> paczesiowa: you're running into problems with associativity there, try putting parens around (getLine <*> getLine)
13:37:39 <byorgey> s/associativity/precedence/
13:37:41 <Peaker> conal, did that go well?
13:38:05 <conal> Peaker: i'm pretty happy with it.
13:38:20 <ski> byorgey : doesn't work
13:38:41 <edwardk> i did find it funny when i was working up some category stuff that (obviously in retrospect) that you don't get class Applicative f => Monad f in all categories, because you don't always have exponentials in the category and applicative only makes sense when you do.
13:39:12 <paczesiowa> looks like we can't hide that join
13:39:45 <Eelis> man, i hate authors that use the notation  (x)e  for  \x->e . it's like they're trying to win an obfuscation contest by overloading parentheses as much as they possible can
13:39:55 <byorgey> ski: er, you're right, of course it doesn't
13:40:00 <Fabien-Uto2> hi
13:40:25 <ski> Eelis : Per Martin-Löf ?
13:40:26 <byorgey> paczesiowa: nope, I don't think you can
13:40:30 <byorgey> hi Fabien-Uto2
13:40:49 <Eelis> ski: yes
13:40:57 <Eelis> think i've seen it elsewhere, too
13:40:59 <hpaste>  gwern pasted "link failures" at http://hpaste.org/6984
13:41:25 <ski> (Eelis : mayhaps originated with him .. ?)
13:41:27 <paczesiowa> anyway thanks
13:41:32 <Eelis> ski: beats me
13:41:33 <ski> <foo <bar x> <baz x>>  -- imaginary syntax
13:42:07 <ski> (but real semantics)
13:42:27 <byorgey> ski: well, the original Applicative paper suggested the syntax [[ foo (bar x) (baz x) ]]
13:42:38 <byorgey> to mean foo <$> bar x <*> baz x
13:42:51 <Fabien-Uto2> is there some kind of equivalent in Haskell to Lisp eval ? or any other way to execute and update Haskell code in Haskell code (being homoiconic or close to)
13:42:56 <shapr> hs-plugins
13:43:42 <paczesiowa> hs-plugins is great
13:43:51 <ski> byorgey : i know .. my idea was developed from that paper
13:43:56 <Saizan> gwern: forgot to add some c-source-dirs/files?
13:44:22 <paczesiowa> I suggest reading dons paper on yi to get excited about that
13:44:27 <gwern> Saizan: I think I may've. I have a lot of c and headers in extra-source-files: but I dunno if that's right
13:45:24 <Saizan> ?hackage xlib
13:45:25 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/xlib
13:45:27 <Saizan> ?hackage zlib
13:45:27 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zlib
13:46:20 <Saizan> gwern: look at the last few lines: http://hackage.haskell.org/packages/archive/zlib/0.4.0.4/zlib.cabal
13:46:22 <lambdabot> http://tinyurl.com/68ngrg
13:46:28 <edwardk> Is hs-plugins happy on windows these days?
13:47:50 <gwern> Saizan: is there a difference for the linker between c-sources and extra-source-files?
13:48:30 <paolino> edwardk:  (if it's not raining or he is on the inside of the pane :d)
13:48:46 <edwardk> =)
13:49:07 <Saizan> gwern: it looks so
13:50:16 <Saizan> gwern: extra-source-files just adds files to be included by sdist in the tarball, c-sources are actually built and linked
13:50:45 <Saizan> gwern: extra-source-files could be README, configure, etc..
13:50:58 * gwern frowns. simply switching to c-sources borks the build. hm
13:51:01 <gwern> Saizan: README would be data-files, no?
13:51:48 <Saizan> gwern: i think data-files is for files needed by executables at runtime, they get installed iirc
13:52:15 <Saizan> gwern: http://www.haskell.org/cabal/release/latest/doc/users-guide/x30.html#buildinfo
13:52:22 <lambdabot> http://tinyurl.com/2hxddg
14:08:26 <lament> gr, Couldn't match expected type `Integer' against inferred type `Int'
14:08:49 <Riastradh> You used `length', didn't you?
14:09:41 <lament> this is just bizarre
14:09:43 <lament> fromGregorian :: Integer -> Int -> Int -> Day
14:09:55 <lament> (year -> month -> day -> return value)
14:10:10 <lament> Ints are not big enough to store years?
14:10:33 <lament> Avoiding the famous Y2038 problem?
14:15:37 <glguy> maybe you wanted to talk about when the big bang happened
14:15:43 <lament> maybe.
14:15:54 <glguy> and you wanted to ask "when was Easter the year of the big bang"
14:15:58 <glguy> Int's might not cut it
14:16:30 <jsnx> glguy: well, if you just go a 64 bit computer...
14:17:15 <glguy> heh "Hi, my program runs out of memory, could someone look at it?" "No, but more ram"
14:17:20 <glguy> buy*
14:17:23 <jsnx> this is probably a major hold-up in physics -- how are the physicist's supposed to map out the creation of the universe if they can't put it on their calendars?
14:17:46 <glguy> They'd all forget the universe's birthday
14:17:52 <glguy> and wouldn't remember to celebrate or send a card
14:17:57 <jsnx> indeed, happens every year, i'm sure
14:18:11 <jsnx> so of course the universe has nothing to say to them
14:22:39 <lament> very funny!
14:25:06 <roconnor> the age of the universe is reference frame dependent.
14:25:36 <jsnx> roconnor: can we put it in a frame where it fits in an Int32 ?
14:25:51 <roconnor> yep
14:26:07 <jsnx> roconnor: can we get arbitrarily close to zero?
14:26:25 <roconnor> I suppose so
14:26:36 <roconnor> I'm not an expert though.
14:26:43 <slowriot> Does anyone here know of a purely functional implementation of a scanline algorithm?
14:26:54 <jsnx> glguy: you see -- it's all about your point of view
14:27:19 <roconnor> solrize_: what are you rasterizing?
14:27:41 <slowriot> me? nothing
14:28:30 <roconnor> er
14:28:47 <roconnor> slowriot: which scanline algorithm?
14:28:53 <slowriot> I mean a computational I mean a sweep line algorithm. Sorry
14:28:53 <roconnor> raserizing a polygon?
14:29:52 <roconnor> map sweepLine lines
14:30:09 <roconnor> map (sweepLine objects) lines
14:30:26 <roconnor> fmap (sweepLine objects) lines
14:30:30 <slowriot> what is sweepLine?
14:30:49 <slowriot> must be a function that takes a line?
14:30:53 <jsnx> slowriot: i think monads will help you here
14:30:57 <roconnor> a function that rasterized a single line
14:31:00 <roconnor> bad name I think
14:31:07 <roconnor> fmap (rasterizeLine objects) lines
14:31:14 <slowriot> jsnx: Yeah, monads would be one way to do it.
14:31:33 <jsnx> it's less declarative
14:31:38 <jsnx> but more intuitive
14:31:39 <slowriot> jsnx: I think you could also make a recursive function that uses purely functional sets for the status tree.
14:31:59 <jsnx> slowriot: what is the status tree like?
14:31:59 <slowriot> jsnx: It might not be efficient. But it would be cool.
14:32:11 <slowriot> jsnx: The status tree is typically a balanced binary tree.
14:32:13 <roconnor> I don't imediately see anything imperitive about sweep line algorithms
14:32:31 <jsnx> slowriot: why is it balanced? doesn't one line come after the next?
14:32:49 <jsnx> it seems like we'd have a right-sided tree...
14:33:37 <slowriot> jsnx: A sweep line algorithm is an algorithm in which an imaginary line sweeps across the plane. You could imagine it as a continuous motion, but really it just acts at discrete event points.
14:33:49 <slowriot> let's say the line is horizontal and sweeps down the y-axis. That usually works.
14:34:28 <jsnx> okay
14:34:47 <slowriot> A simple example of a sweep line algorithm is the bentley-ottman algorithm
14:35:18 <slowriot> it's a O(n lg n) algorithm to compute all intersections among a set of line segments. (n is the total number of intersections in the output)
14:35:42 <slowriot> in the b-o algorithm, the status tree just contains all of the lines which the sweep-line intersects from left to right.
14:35:53 <slowriot> it changes at every "event point"
14:36:01 <jsnx> oic
14:36:16 <roconnor> fold (rasterizeLine objects) lines
14:36:23 <jsnx> for some reason i misunderstood you to mean a fill line
14:36:29 <slowriot> so the status tree is defined with respect to a y-coordinate of the horizontal sweepline.
14:36:43 <roconnor> scan (rasterizeLine objects) lines ?
14:36:54 <slowriot> jsnx: could have been because I accidentally said scanline rather than sweepline.
14:37:15 <jsnx> roconnor: it's not about rasterizing -- it's about finding the boundaries
14:37:22 <jsnx> in *screenspace*
14:37:31 <jsnx> so you can fill them later
14:38:41 <slowriot> I tried implementing b-o in F#, but F# doesn't have very good functional data structures, and I was too clumsy to make my own.
14:39:01 <jsnx> slowriot: well you are in big trouble then
14:39:09 <slowriot> jsnx: why?
14:39:27 <jsnx> slowriot: haskell only has highly esoteric elite data structures
14:39:49 <slowriot> Haskell has a balanced binary tree, doesn't it?
14:39:57 <bd_> slowriot: Data.Map
14:40:10 <jsnx> bd_: Data.IntMap is closer
14:40:17 <bd_> oh?
14:40:24 <jsnx> bd_: a hash map is not balanced or anything
14:40:30 <slowriot> As long as it has a set with O(lg n) operations, we should be good.
14:40:30 <bd_> I thought Data.Map is an AVL tree?
14:40:36 <bd_> jsnx: Data.Map is not a hash map
14:40:47 <jsnx> bd_: oh, i am a goof
14:40:52 <bd_> :t Data.Map.insert
14:40:53 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
14:40:58 <jsnx> Data.IntMap is a patricia tree
14:41:36 <jsnx> a kind of trie -- it's search is O(length of the longest key)
14:42:15 <slowriot> so implementing a sweepline algorithm in a purely functional style wouldn't have that many benefits. The code might be easier to read, and it might be safer, but it would be less efficient than an imperative version.
14:42:26 <slowriot> it would be cool, though
14:44:12 <jsnx> well, actually, O(length of the key) is pretty good relative to O(length of the list)
14:44:49 <jsnx> say we have a trie that stores the ints all in order
14:46:26 <jsnx> log of that is 22
14:46:35 <jsnx> whereas length of the key is 32
14:46:47 <jsnx> and the comparisons involved in the latter case are much simpler
14:47:34 <jsnx> the key space is related logarithmically to the list space, any way
14:48:07 <jsnx> (if i had taken log_2 instead of log_e we'd have 32 in both cases)
14:49:05 <slowriot> huh
14:49:21 <jsnx> in the case of a trie, i'm doing bitwise comparisons
14:49:34 <jsnx> whereas in a balanced tree, i'd compare whole ints
14:49:58 <jsnx> you can see why the trie is preferable for things like building a dictionary
14:50:37 <jsnx> basically, when the elements are like to strings, in that they can be shortened and still sorted, its worth looking at a trie
14:50:47 <dolio> I've actually heard that in the case of IntMap, it's more likely the specialization to Int that makes things faster than the fact that it's a trie.
14:51:07 <dolio> But when you use something like a list as a key, the difference is more significant.
14:51:36 <jsnx> dolio: well, that may be so -- but they are using a totally different data structure
14:52:00 <jsnx> dolio: oh, by the way...
14:52:44 <jsnx> it's a PATRICIA tree in that case, which is a space optimized trie
14:53:15 <jsnx> anyways, i've learned a whole lot about this because i'm writing a chinese dictionary in haskell
14:53:22 <jsnx> and i made a trie
14:53:49 <jsnx> but then it could not be compiled, because large static data does not sit well with GHC -- so i had to redo it in C
14:54:08 <gwern> '/usr/lib/gcc/x86_64-pc-linux-gnu/4.2.3/../../../../x86_64-pc-linux-gnu/bin/ld: cannot find -lzlib
14:54:17 * gwern has includes: zlib.h
14:54:17 <gwern> extra-libraries: zlib
14:54:19 <gwern> in the cabal file
14:54:32 <Botje> the lib is called libz
14:54:33 <Botje> zo -lz
14:54:38 <Botje> *so -lz
14:54:56 <gwern> it is? how weird
14:54:59 <gwern> awright then
14:56:05 <gwern> I had sort of assumed zlib was called zlib :)
14:57:04 <ddarius> What is with the sudden popularity of Agda?
14:57:06 <Botje> libzlib.so looks a bit weird :)
14:58:19 <dolio> jsnx: Did you want me to do something about it? :)
14:58:22 <glguy> ddarius: "sudden popularity"?
14:58:27 <glguy> who is talking about it?
14:58:43 <jsnx> dolio: eh?
14:58:56 <pejo> ddarius, popular where, except Epigram-people?
14:58:56 <dolio> GHC's static data support.
14:59:15 <jsnx> dolio: yes, i posted a ticket
14:59:24 <jsnx> but honestly, i have a new idea
14:59:26 <dolio> Oh, well, I'm not a GHC hacker.
14:59:43 <jsnx> we just write bytestring parsers with the ASN.1 lib
14:59:47 <dolio> I was just confused because you said 'oh, by the way' directed at me.
14:59:59 <jsnx> oh, no problem
15:00:32 <jsnx> what is the idiomatic way to get the last character in a string?
15:00:38 <glguy> last
15:00:41 <ddarius> I guess it was the announcement of the release of Agda 2
15:00:46 <jsnx> :t last
15:00:47 <lambdabot> forall a. [a] -> a
15:00:59 <dolio> I don't know. fax got me to try agda, so I guess I've been talking about it some.
15:01:07 <dolio> And that got Saizan interested.
15:01:23 <dolio> Or something like that.
15:02:13 <dolio> Or are you referring to the paper on LtU or something?
15:02:42 <gwern> never been able to follow the difference between agda and epigram and qi and the other crazy languages
15:03:07 <dolio> Qi isn't dependently typed is it?
15:03:39 <jsnx> it kind of alarms me that there are languages crazier than haskell
15:04:00 <dolio> Qi is, essentially, lisp with an interesting type system.
15:04:01 <gwern> dolio: I think Qi is typed however you want it to be typed
15:04:04 <tankgirl_> intercal, baby
15:04:06 <ziman> is haskell crazy?
15:04:14 <shapr> No, Haskell is sane.
15:04:15 <jsnx> ziman: totally
15:04:21 <gwern> @faq is haskell crazy?
15:04:21 <lambdabot> The answer is: Yes! Haskell can do that.
15:04:33 <jsnx> in a crazy world, the sane are crazy
15:04:56 <jsnx> so i guess what i mean is, it makes me uncomfortable that there are languages saner than haskell
15:04:57 <gwern> the gods must be crazy
15:05:21 <sjanssen> gwern: you are familiar with the existing zlib binding, right?
15:05:23 <dolio> Agda and epigram seem to have similar goals of being dependently typed languages usable for more everyday programming.
15:05:24 <muhtimin> haskell is quite difficult to get into, at least it's quite difficult to read
15:05:42 <dolio> But agda seems to have gotten there first. And it looks a lot more like Haskell than epigram does.
15:05:56 <jsnx> muhtimin: if you understand the principles, the reading really is easy
15:06:08 <jsnx> muhtimin: it's the principles that are hard
15:06:17 <muhtimin> jsnx: ok.  then it is obvious that i don't understand the principles.
15:06:20 <muhtimin> heh
15:06:24 <jsnx> muhtimin: yes
15:06:25 <gwern> sjanssen: I've seen the zlib package on hackage, but I dunno if it does what I want. also, I'm not yet at the libraryfying point of darcs yet
15:06:50 <jsnx> muhtimin: the principles are completely esoteric and inscrutable
15:06:52 <ziman> i'd characterize haskell as enlightening and refreshing :)
15:06:59 <muhtimin> well, at least in my experience, haskell has a bit steeper learning curve than scheme
15:07:05 <jsnx> muhtimin: right
15:07:09 <jsnx> way steeper
15:07:11 <sjanssen> gwern: ah, darcs hacking
15:07:14 <sjanssen> gwern: what are you working on?
15:07:29 <gwern> sjanssen: yups. I just got darcs built through cabal!
15:07:29 * gwern is pleased
15:07:34 <Saizan> there is a name in CT for something like Monad m, Monad n => m (n a) -> n (m a), right?
15:07:56 <dolio> Distributive law?
15:08:35 <Saizan> uhm, sounds reasonable
15:08:37 <dolio> Saizan: http://au.youtube.com/view_play_list?p=EC25F0F5AC915192
15:08:38 <lambdabot> Title: YouTube - Broadcast Yourself.
15:09:20 <sjanssen> gwern: cool, I tried to do that once
15:09:22 <pejo> dolio, lots of interesting work going on in Nottingham on core stuff for Epigram2 though.
15:09:30 <gwern> sjanssen: what happened?
15:09:45 <sjanssen> gwern: have you talked to droundy about it?  He was against transitioning to Cabal the last time I asked
15:10:06 <Saizan> dolio: thanks :)
15:10:34 <gwern> sjanssen: nope. I'm going to submit all my non-breaking changes in a batch, and then I'll group together a big radical batch. if I can't convince him to take the latter, I'm not entirely sure what I'll do
15:10:41 <gwern> (forking is always an option)
15:11:40 <sjanssen> gwern: 'cabal install darcs' would be *great*
15:11:47 <sjanssen> I assume that's what you're going for
15:11:54 <gwern> sjanssen: ideally!
15:12:01 <dolio> pejo: Yeah, I look forward to them finishing. From what bits I've read, it seems like it might have some niceties (universe polymorphism?) that Agda lacks (currently, anyhow).
15:12:39 <gwern> (I think that would really help darcs - that feature alone would be worth doing a release for - 'Darcs 2.0.1 - Now on Hackage')
15:13:13 <gwern> it's an incredible pity that the type witness stuff in darcs breaks with 6.8.x
15:22:18 <Saizan> gwern: really? that's why they have those CPP macros to insert it conditionally?
15:23:09 <gwern> Saizan: yes. the typewitnesses fail on 6.8.x, but work with 6.6. so apparently roundy and lispy keep 6.6 installed and occasionally compile it with typewitnesses
15:30:02 <bos> @users
15:30:02 <lambdabot> Maximum users seen in #haskell: 481, currently: 449 (93.3%), active: 16 (3.6%)
15:34:15 <glguy> my client sees 440
15:34:36 <Corun> Ditto
15:34:36 <glguy> and two have quit since that message... so I wonder who the 7 ghosts are
15:34:46 <Corun> Wooooooooo! (ghost noise)
15:34:50 <bos> lambdabot must be seeing things. it's the drugs.
15:35:14 <glguy> If only we could check such a bug in the type system...
15:35:45 <andun> Â«Irssi: #haskell: Total of 440 nicks [1 ops, 0 halfops, 0 voices, 439 normal]
15:36:16 <fophillips> I thought someone was talking to me :(
15:36:44 <glguy> but it was one of the 7 ghosts?
15:37:23 <fophillips> Is andun a ghost?
15:37:47 <olsner> ooh, 481 users, that's like 100 more than when it was only 381
15:38:36 * olsner goes to bed, lest he state something even more obvious
15:40:08 <shapr> @users
15:40:08 <lambdabot> Maximum users seen in #haskell: 481, currently: 445 (92.5%), active: 16 (3.6%)
15:40:11 <shapr> hmm
15:40:13 <shapr> Cool!
15:43:10 <Choko> is there a cool haskell book out there which encapsulates what i can read in different guides on the internet?
15:44:06 <Choko> i want a haskell bible which can help me get something done with haskell
15:45:24 <bockmabe> I asked this question the other day here but got no response, think I'll try one more time before I post to mailing list.  Does anyone know of an Expect like package/module for haskell to support automation of interactive sessions with CLI tools?
15:45:58 <pejo> Choko, maybe  "Real World Haskell" when it is done?
15:45:58 <bockmabe> UniForM Workbench looks to be impossible to find source for.
15:48:38 <Choko> pejo: heh but it's not done :(
15:49:13 <allbery_b> bockmabe: I haven't seen one.  (Generally subprocess stuff is painful with most existing Haskell libraries, so I suspect nobody has yet had an itch strong enough to drive them over that hill.)
15:49:53 <ddarius> I think I recall someone being interested in doing something like that a long time ago, but I don't know what came of it.
15:50:21 <bos> i added pty support to the posix package in the 6.8 era.
15:50:37 <bos> i also have some smarter wrapper code sitting around somewhere.
15:50:46 <bos> don't remember if i pushed it to JaffaCake.
15:50:47 <ddarius> The "6.8 era" being now ...  (...)
15:51:13 <bos> anyway, writing something expect-like is now doable without much effort.
15:51:41 <daveux> What do I do about this build error? Could not find module `Codec.Utils':  it is a member of package Crypto-4.1.0, which is hidden
15:51:41 <bos> that's what i do for all the ghci interaction examples in the book, for example.
15:52:15 <allbery_b> add Crypto to the build-depends: line in the cabal file
15:52:23 <bos> or ghc --make
15:53:10 <pejo> bos, is it the same program that makes the comment system and pipes stuff through ghci and similar for the book?
15:53:34 <daveux> Hmm, I'm really not sure what you guys are suggesting -- I am trying to build yi with ./Setup build
15:53:41 <bos> the comment system is inrelated.
15:53:42 <daveux> Where should I add Crypto?
15:54:06 <allbery_b> there should be a file yi.cabal
15:54:52 <daveux> It has build-depends: Crypto==4.1.0
15:55:27 <bockmabe> Hmmm, so sounds like while there is no Expect module perse.  Implementing one might not be that bad now?
15:55:38 <bockmabe> bos, where should I look for example code :-)?
15:56:51 <daveux> full error: http://www.paste2.org/p/20725
16:01:03 <hpaste>  bos pasted "pty code" at http://hpaste.org/6985
16:02:20 <hpaste>  bos annotated "pty code" with "more pty fun" at http://hpaste.org/6985#a1
16:02:26 <bos> bockmabe: see above
16:03:03 <bos> bleg, it truncated my paste.
16:03:28 <hpaste>  bos annotated "pty code" with "changeTranscript was truncated" at http://hpaste.org/6985#a2
16:05:43 <bockmabe> thanks bos. will check it out.
16:11:26 <sjanssen> @seen byorgey
16:11:26 <lambdabot> byorgey is in #haskell, #haskell-blah and #xmonad. I last heard byorgey speak 2h 12m 22s ago.
16:11:53 <sjanssen> @ask byorgey is there a darcs repo for oeis?
16:11:53 <lambdabot> Consider it noted.
16:12:12 <daveux> can anyone help me with this error?: http://www.paste2.org/p/20725
16:12:25 <daveux> I'm trying to build Yi so I can add collaborative editing.
16:14:05 <sjanssen> @seen twanvl
16:14:05 <lambdabot> twanvl is in #haskell, #haskell.dut and #ghc. I last heard twanvl speak 3h 51m 46s ago.
16:14:15 <twanvl> @seen me
16:14:15 <lambdabot> I haven't seen me.
16:14:48 <sjanssen> hey twanvl
16:14:59 <sjanssen> I'm looking at removing Lib/OEIS.hs from lambdabot
16:15:27 <twanvl> yes, having it actually use the real OEIS library is probably a good idea
16:15:49 <sjanssen> so the only real difference is the searchSequence_IO function, yeah?
16:16:33 <sjanssen> the rest of the changes seem cosmetic, or adaptations to use another HTTP library
16:17:05 <lament> why do i always have to convert between Int and Integer :(
16:17:05 <twanvl> IIRC that is the only interface change
16:18:47 <sjanssen> ah, lambdabot also has support for proxies
16:27:23 <bd_> lament: because Int and Integer are different types
16:27:51 <bd_> and Int can be (much?) faster than Integer precisely because the compiler can prove it will remain in the range for a machine int in all cases
16:29:06 <lament> yes, very convenient
16:30:50 <Saizan> well, the compiler doesn't even try to prove that..
16:31:45 <bd_> Sure it does, via the type system :)
16:36:03 <Saizan> it depends on what you mean by "remain in the range" i suppose, Int can simply overflow
16:37:08 <TomMD> @faq Can the Haskell type system keep my plans for world domination from scratching my car?  Oh, and can it prove Ints remain in a range representable by a machine word?
16:37:08 <lambdabot> The answer is: Yes! Haskell can do that.
16:37:36 <bd_> True, but that's part of the semantics of Int; if it were to start converting between Int and Integer it'd have to determine when the semantics of Integer would not change when casted to Int, right?
16:37:42 <bd_> moreover, where would the conversion occur?
16:38:21 <bd_> consider  ((maxBound :: Int) * 42 `div` 42 - 1) :: Integer; where do we do the conversion?
16:38:38 <bd_> @ lament :)
16:41:43 <BMeph> bd_: Apparently, either right after the resolution of maxBound, or just before giving an answer, since in that form, you're trying to cast a value with a determined type, as some other, conflicting type. :)
16:42:25 <bd_> well, this problem will come up whenever you suggest casting between numeric types automatically
16:43:09 <BMeph> Eww! Who suggested that? Automatic type casting is De Debbil! ;p
16:43:27 <bd_> also, 'right before giving an answer' is not so simple if we bind an intermediate bit to a variable and use that as well
16:43:31 <bd_> BMeph: blame lament :)
16:43:35 <dolio> Integer is an auto-promoted Int.
16:44:04 <sjanssen> @slap dons
16:44:05 * lambdabot jabs dons with a C pointer
16:44:07 <dolio> When it's Int sized, it's stored as a box around an Int#, and when it's bigger, it gets promoted to using a byte array.
16:44:21 <sjanssen> dons put a perl script in the lambdabot repo!
16:44:58 <TomMD> And you are punishing him with a public shaming?  Shall I mail him a scarlet 'P' to place on his shoulder?
16:45:22 <sjanssen> TomMD: yes
16:45:26 * BMeph can't wait for Pugs to be done, so he can make his "type-casting Perls before swine" pun
16:45:39 <bd_> Isn't pugs mostly dead these days?
16:45:43 <TomMD> If I find one I will keep it waiting around for when I meet him.
16:45:50 <geezusfreeek> pugs is the most active perl 6 implementation currently
16:45:52 <sjanssen> I can't say I'm surprised about this, though
16:46:05 <BMeph> bd_: Aye, and "mostly harmless," therefore... ;)
16:46:06 <bd_> huh
16:46:07 <sjanssen> @vixen how crufty are you?
16:46:07 <lambdabot> i truely am
16:46:19 <bd_> it was removed from debian recently
16:46:28 <geezusfreeek> that's odd
16:46:41 <BMeph> That's typical...
16:46:49 <glguy> isn't parrot the main implementation now?
16:46:50 <bd_> geezusfreeek: I don't think the most recent release builds anymore :)
16:47:03 <geezusfreeek> glguy: parrot is just a vm
16:47:20 <bd_> geezusfreeek: parrot the project has a number of compilers in the work as well though
16:47:23 <bd_> including perl6
16:47:31 <geezusfreeek> bd_: i think that says a lot about the status of perl 6 in general though
16:47:43 <geezusfreeek> there is no "
16:47:46 <geezusfreeek> oops
16:47:56 <geezusfreeek> there is no "perl6" anymoreâ€¦ no "official" implementation
16:48:06 <geezusfreeek> they renamed perl6 to something else
16:48:10 <bd_> There's an (overly complex) spec! :/
16:48:24 <geezusfreeek> yes, and that is all the defines perl 6
16:49:01 <geezusfreeek> and IIRC, pugs also compiles to parrot
16:49:21 <bd_> yep, but the parrot compiler is trying to bootstrap itself
16:49:25 <bd_> and remove the ghc dependency
16:49:28 <TomMD> No need to worry - Perl6 will be consumed by C# soon, just like everything else (insert Borg or Dark side reference).
16:49:41 <bd_> TomMD: you mean by CIL?
16:49:59 <lament> TomMD: you mean by GHC?
16:50:18 <TomMD> lol
16:53:53 <Saizan> sjanssen: trying to properly cabalize lambdabot?
16:54:01 * gwern is surprised to remember I have a commit bit for pugs
16:54:39 <Saizan> "he has" :)
16:54:51 <sjanssen> Saizan: de-cruftifying
16:55:06 <gwern> Saizan: if you say so...
16:55:15 <sjanssen> Saizan: I'm removing all these cloned libs and programs in lambdabot: hoogle, djinn, ftshell, oeis, ...
16:55:33 <sjanssen> Saizan: the step after that is putting it on hackage
17:00:48 <cjs> Morning!
17:01:02 <heatsink> evening.
17:01:07 <cjs> Cripes. Who would have thought such a short blog post could generate so many comments? http://www.chadfowler.com/2008/4/2/haskell-is-slick
17:01:07 <lambdabot> Title: ChadFowler.com Haskell is Slick
17:01:47 <dolio> Did you get posted to reddit or something?
17:02:35 <bd_> most of them are spam though... :)
17:03:03 <gwern> most people are spam
17:03:08 <gwern> (or soylent green)
17:03:25 <dolio> Wow, that's a lot of spam.
17:03:27 * gwern notes the impressively unixy beard
17:03:34 <glguy> that blog posting only had 8 actual comments non of which particularly insightful...
17:03:40 <cjs> Oh, right. Just found where the spam started. Oh well.
17:04:05 <heatsink> hahaha, unix beards.
17:19:12 <jui> hey guys
17:20:05 <jui> i am trying to write a go to line function for an editor
17:20:40 <jui> i know it has something to do with x,y co-ordinates
17:20:50 <jui> any suggestions?
17:20:58 <sarehu> jui: what editor, and is Haskell involved?
17:22:24 <jui> its a project and yes haskell is involved
17:22:54 <sarehu> okay.  so, what data structure are you using for the buffer?
17:23:54 <jui> buffer?
17:24:16 <sarehu> a sequence of characters, stored in memory, that you load/save from a file
17:25:00 <jui> i am not using one
17:25:11 <sarehu> you are talking about an editor?
17:25:15 <jui> i am running it in ghci
17:25:40 <sarehu> what do you mean, an "editor"?  What is a "line"?
17:25:41 * glguy makes some popcorn
17:26:27 <jui> text editor
17:26:59 <sarehu> okay
17:27:35 <sarehu> how are people editing text, then, if you aren't storing it anywhere?
17:27:42 <jui> so what do you think
17:29:28 <jui> its similar to notepad
17:29:31 <sarehu> ok
17:29:40 <sarehu> and what are you storing the text in when you load it from a file?
17:30:08 <glguy> he told you that, ghci :)
17:30:13 <jui> in the editor
17:30:34 <sarehu> rofl
17:31:33 <sarehu> hmm
17:31:58 <sarehu> suppose you wanted to get the first character in a file currently being edited
17:32:01 <sarehu> how would you do that?
17:32:07 <sjanssen> jui: if you'd like help, you're going to have to give us more information
17:32:29 <cjs> Specifically, what sort of data structure are you using to hold the list of characters representing the editor buffer? is I think the question here.
17:32:43 <cjs> Anyway, I'm off to work; BIAB.
17:35:46 <jui> create a dialog to take a number, when that number is gained using it to find the (x,y) coordinate?
17:36:52 <sarehu> use a data structure of the form  data LineTree = Line !Int | Branch !Int !LineTree !LineTree
17:37:15 <sarehu> where each leaf represents a sequence of characters between newline characters
17:38:33 <jui> are you familiar with the textctrl classes
17:38:52 <sarehu> then keep the tree balanced somehow, and wait, add something that tells you how many lines are in each subtree.  Then you can navigate to any line in logarithmic time
17:39:31 <jui> are you?
17:40:00 <sarehu> and you can figure out what line a given character is on (if you know its index)
17:40:16 <sarehu> what is a textctrl class
17:41:18 <jui> a class in wxhaskell
17:43:19 <sarehu> type TextCtrl a = Control (CTextCtrl a)
17:44:21 <jui> what does that do
17:44:33 <sarehu> what
17:44:52 <sarehu> that's the definition of the type synonym, TextCtrl
17:46:35 <sarehu> you would probably want to use textCtrlSetInsertionPoint or something
17:47:42 <sarehu> there is also textCtrlXYToPosition
17:47:45 <sarehu> you could probably use that
17:47:56 <jui> whats the definition for that
17:48:02 <sarehu> I don't know
17:48:07 <sarehu> it's in the wxhaskell documentation
17:48:10 <sarehu> all the functions
17:48:16 <sarehu> I only know its type signature
17:48:26 <sarehu> http://wxhaskell.sourceforge.net/doc/Graphics-UI-WXCore-WxcClassesMZ.html
17:48:27 <lambdabot> http://tinyurl.com/63jwbp
17:50:20 <doitnow> what to do when someone wont listnen or wont listen to you especially?
17:50:39 <sarehu> use a monad transformer on that person
17:51:10 <sarehu> another is to ask yourself why they would want to listen to you
17:51:53 <jui> thanks
17:52:57 <sarehu> I suppose the answer would depend on what said person is not listening about
17:55:46 <macondo> may I congratulate you?, I see a beautiful community around Haskell
17:56:18 <sarehu> you're welcome to join the community and congratulate yourself <3
18:02:06 <gwern> I forget, how does a multiline literal work again?
18:02:52 <jeffz> "foo\
18:02:54 <jeffz> \bar"
18:03:52 <gwern> confusing. I wonder what's wrong with this module then?
18:04:08 <hpaste>  gwern pasted "some sort of multiline literal problem" at http://hpaste.org/6986
18:04:50 <heatsink> What error message have you?
18:05:47 <jeffz> that string looks well formed to me.
18:05:57 <TomMD> gwern: Yikes!  This is why I like Python multi-line strings.
18:06:04 <sarehu> at least it looks okay to the syntax highlighter
18:06:31 <gwern> TomMD: heh. heredocs ftw right?
18:06:50 * heatsink can compile it ok
18:07:03 <TomMD> ftw!
18:07:13 <gwern> I get 'src/Context.hs:3:57: lexical error in string/character literal at character '/'
18:07:45 <heatsink> gwern: It's a C preprocessor problem
18:08:17 <heatsink> the C preprocessor doesn't recognize haskell multiline string literals.
18:08:20 <gwern> heatsink: why would CPP be having a problem with it? there are no CPP directives
18:08:29 <heatsink> Hmm, weird.
18:08:31 <doitnow> i am embarrassed to admit it becasue it is sterio typical that would beat a woman and kill her in my cultureand she is not taking advantage of that sinc ei am such a great guy
18:08:44 <heatsink> I say that because I can compile it okay with ghc, but I get your error with ghc -cpp.
18:11:51 <gwern> 'A small word of warning: -cpp is not friendly to â€œstring gapsâ€.. In other words, strings such as the following:'
18:11:52 <gwern> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#cpp-string-gaps
18:11:53 <lambdabot> Title: 5.10. Options related to a particular phase, http://tinyurl.com/smq5n
18:57:11 <adu> hi
18:57:29 <Saizan> hi
18:58:10 <gwern> @src getContents
18:58:10 <lambdabot> getContents = hGetContents stdin
18:58:19 <gwern> @hoogle getContents
18:58:19 <lambdabot> Prelude.getContents :: IO String
18:58:19 <lambdabot> System.IO.getContents :: IO String
18:58:19 <lambdabot> Data.ByteString.getContents :: IO ByteString
19:01:24 <gwern> :t unlines
19:01:25 <lambdabot> [String] -> String
19:03:02 <byorgey> hey adu
19:03:02 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
19:03:08 <gwern> > init "foobar"
19:03:09 <lambdabot>  "fooba"
19:03:09 <adu> byorgey!
19:03:34 <adu> byorgey: how you doing?
19:04:28 <byorgey> adu: recovering from a headache at the moment, but very well overall, thanks =)
19:04:31 <byorgey> adu: you?
19:04:44 <adu> good, recovering from taxes
19:04:48 <byorgey> hehe
19:05:08 <byorgey> you'll get some $$ back, I hope?
19:05:19 <Nafai> Hey byorgey
19:05:24 <adu> well $100, its ok
19:05:28 <Nafai> I wasn't so lucky
19:05:31 <Nafai> I had to pay
19:05:35 <adu> I've been learning alot about the GHC API
19:05:38 <byorgey> adu: heh, better than nothing
19:05:40 <byorgey> Nafai: =(
19:06:07 <Nafai> It wasn't too bad.  I had friends that had to pay several thousand, I was only in the couple hundred range
19:06:15 <Nafai> At least I'll get the rebate
19:06:20 <adu> because I want to have what XMonad and Yi and Lambdabot have, only in well-documented tutorial and stuff
19:06:46 <byorgey> adu: cool!
19:06:58 <byorgey> @seen sjanssen
19:06:58 <lambdabot> sjanssen is in #haskell-hac4, #haskell, #xmonad and #haskell-soc. I last heard sjanssen speak 1h 34m 51s ago.
19:07:04 <gwern> @pl \x -> "\"" ++ x ++ "\","
19:07:04 <lambdabot> ('"' :) . (++ "\",")
19:07:12 <gwern> adu: xmonad doesn't use the GHC api
19:07:23 <adu> I also applied to GSoC to improve the GHC API, because it makes me happy :)
19:07:53 <byorgey> adu: oh, neat.  what do you propose to improve about it?
19:08:05 <adu> gwern: well, it should, or at least it should be able to, or at least other ppl should be able to
19:08:16 <gwern> byorgey: just documentation alone would help immensely
19:08:19 <Nafai> adu: That sounds great!  Look forward to reading your tutorial.
19:08:20 <Nafai> :)
19:08:31 <gwern> and also figure out how to let people use the API witout resorting to CPP hacks
19:08:47 <byorgey> indeed.  I tried using it once upon a time, it wasn't easy to figure out
19:09:05 <TomMD> adu: I didn't realize you are a student - where at?
19:09:23 <adu> montgomery college
19:10:44 <byorgey> @tell sjanssen oeis doesn't have a darcs repo, but I should probably set one up.  I certainly will if you are interested.
19:10:44 <lambdabot> Consider it noted.
19:10:50 <adu> byorgey: well, I think the current Haskell API needs better documentation, and there should be a C API for compiling / parsing Haskell, and the whole dynamic paradigm that Yi uses could be re-factored into a library
19:11:42 <gwern> adu: refectoring yi would be a good GSoC project
19:11:58 <adu> but that has less to do with the ghc api
19:12:34 <gwern> I dunno. coming up with a good library around the api has to do with the api
19:13:11 <adu> i suppose, and the core of Yi is just a dynamic linker, which has alot to do with GHC I think... maybe not...
19:14:40 <adu> byorgey: are you talking about the integer sequences site?
19:15:11 <byorgey> adu: yeah, I wrote a Haskell library for querying it
19:15:21 <byorgey> it's included in lambdabot now, actually
19:15:21 <adu> nice
19:15:27 <byorgey> @oeis 1 1 2 3 5
19:15:28 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
19:15:28 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
19:16:44 <Saizan> isn't hs-plugins supposed to be that dynamic linking library?
19:17:10 <Saizan> some parts of it has been ported to the ghc-api already
19:17:13 <ivanm> byorgey: does @oeis return all such sequences, or only the first?
19:17:31 <Saizan> ivanm: a random one
19:17:47 <byorgey> ivanm: the lambdabot command returns only the first
19:17:56 <byorgey> Saizan: oh, it's random?
19:18:15 <byorgey> I'm actually not all that familiar with the precise way in which the library is utilized by the lambdabot command =)
19:18:22 <adu> @oeis 0 1 5 26 154
19:18:22 <lambdabot> Generalized Stirling numbers: a(n) = n!*Sum[(k+1)/(n-k),{k,0,n-1}].
19:18:22 <lambdabot> [0,1,5,26,154,1044,8028,69264,663696,6999840,80627040,1007441280,13575738240,...
19:18:36 <adu> cool
19:19:10 <Saizan> byorgey: i've seen it spit an error about a random generator, so..
19:19:20 <ivanm> byorgey: heh
19:19:20 <SamB> @oeis 0 1
19:19:21 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
19:19:21 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
19:19:23 <SamB> @oeis 0 1
19:19:23 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
19:19:23 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
19:19:25 <SamB> @oeis 0 1
19:19:25 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
19:19:25 <dfeuer> #ubuntu+1
19:19:27 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
19:19:27 <dfeuer> sorry
19:19:40 <ivanm> Saizan: anyway of getting the rest of them?
19:19:52 <byorgey> actually, now that I go back and look at the code, the library only ever returns the first result
19:19:56 <adu> @oeis 1 2 9 64 625
19:19:56 <SamB> Saizan: it doesn't seem to work too well
19:19:56 <lambdabot> Number of labeled rooted trees with n nodes: n^(n-1).
19:19:56 <lambdabot> [1,2,9,64,625,7776,117649,2097152,43046721,1000000000,25937424601,74300837068...
19:20:06 <byorgey> adding the ability to get multiple results was on my TODO list =)
19:20:13 <Saizan> ok, i'm wrong :)
19:20:31 <byorgey> I think the random generator error is from @quote, perhaps?
19:20:38 <SamB> @quote
19:20:38 <lambdabot> bourbaki says: jfredett: sup?, bourbaki: no thanks i just had dinner
19:20:40 <SamB> @quote
19:20:40 <lambdabot> <shapr> says: GHC has more flags than the UN.
19:20:42 <SamB> @quote
19:20:42 <lambdabot> dolio says: I don't know. But as of a few days ago, there were only like 4 quotes in the database.
19:20:44 <SamB> @quote
19:20:44 <lambdabot> <shapr> says: GHC has more flags than the UN.
19:20:46 <SamB> @quote
19:20:46 <lambdabot> lambdabot says: i can't stand bots
19:20:49 <SamB> @quote
19:20:49 <lambdabot> Baughn says: From my point of view, anyone who understands everything ghc can do is /scary/. I'm sure that will change once I reach that level myself, but then again, there's also the possibility
19:20:49 <lambdabot> that I'll be in a permanent state of autophobia.
19:20:56 <adu> byorgey: thats probably best given the desire to not waste precious IRC lines
19:21:26 * SamB wonders what Baughn meant by "everything GHC can do"
19:21:34 <byorgey> adu: oh, right, I think the lambdabot @oeis command should only ever return one result.  I was talking about adding a function to get multiple results to the underlying library.
19:21:36 <Saizan> byorgey: i guess it was from the random insult :)
19:21:54 <byorgey> Saizan: maybe =)
19:22:05 <ivanm> Saizan: lol
19:22:16 <SamB> @oeis 10 9
19:22:16 <lambdabot> Signature-permutation of a Catalan automorphism: Reflect a rooted plane binar...
19:22:16 <lambdabot> [0,1,3,2,8,7,6,5,4,22,21,20,18,17,19,16,15,13,12,14,11,10,9,64,63,62,59,58,61...
19:22:25 <SamB> @oeis 102 9
19:22:26 <lambdabot> Smallest k such that 1 + Sum{j=1..n} k^(2*j-1) is prime.
19:22:26 <lambdabot> [1,1,2,1,2,1,10,2,2,1,2,1,48,182,2,1,60,1,10,42,2,1,102,12,4,12,110,1,12,1,10...
19:22:36 <SamB> @oeis 102 26
19:22:36 <lambdabot> First differences of Frobenius numbers for 4 successive numbers A138984.
19:22:36 <lambdabot> [1,1,6,2,2,10,3,3,14,4,4,18,5,5,22,6,6,26,7,7,30,8,8,34,9,9,38,10,10,42,11,11...
19:22:50 <SamB> @oeis 10^1000 9
19:22:51 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
19:22:51 <byorgey> hehe =)
19:23:10 <SamB> I'm trying to get it to return no result
19:23:38 <Beelsebob> @oeis 9872 38
19:23:38 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
19:23:43 <adu> @oeis 1 6 21 107
19:23:43 <lambdabot> Busy Beaver problem: maximal number of steps that an n-state Turing machine c...
19:23:43 <lambdabot> [1,6,21,107]
19:23:51 <Beelsebob> @oeis 89 67
19:23:51 <lambdabot> Lesser Fortunate numbers.
19:23:51 <lambdabot> [3,7,11,13,17,29,23,43,41,73,59,47,89,67,73,107,89,101,127,97,83,89,97,251,13...
19:24:01 <Beelsebob> @oeis 89 68
19:24:01 <lambdabot> Numbers k such that A122735(n) = n^k - k^n.
19:24:01 <lambdabot> [0,5,4,0,14,7,20,11,10,273,14,13,38,89,68,0]
19:24:09 <Beelsebob> @oeis 89 69
19:24:09 <lambdabot> Array T read by diagonals; T(i,j)=number of lattice points (x,y) in circle wi...
19:24:09 <lambdabot> [1,5,5,13,9,13,29,21,21,29,49,37,25,37,49,81,57,45,45,57,81,113,89,69,61,69,8...
19:24:11 <SamB> byorgey: how come it displays a ] there?
19:24:17 <adu> @oeis A000012
19:24:17 <lambdabot> The simplest sequence of positive numbers: the all 1's sequence.
19:24:17 <lambdabot> [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:24:19 <byorgey> SamB: were?
19:24:20 <SamB> on the Busy Beaver one
19:24:29 <Beelsebob> I wonder what the longest sequence of consecutive sequences is
19:24:30 <byorgey> SamB: because no one knows BB(5)
19:24:53 <SamB> so it should put ++_|_
19:24:59 <Beelsebob> @oeis A000013
19:24:59 <lambdabot> (1) Number of n-bead binary necklaces with beads of 2 colors where the colors...
19:24:59 <lambdabot> [1,1,2,2,4,4,8,10,20,30,56,94,180,316,596,1096,2068,3856,7316,13798,26272,499...
19:25:01 <ivanm> @oeis 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9
19:25:01 <lambdabot> n occurs A000045(n) times.
19:25:01 <lambdabot> [1,2,3,3,4,4,4,5,5,5,5,5,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,...
19:25:22 <Beelsebob> @oeis 1 2 3 4 5 6 7 8
19:25:25 <lambdabot> The natural numbers. Also called the whole numbers, the counting numbers or t...
19:25:25 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
19:25:30 <Beelsebob> @oeis 1 2 3 4 5 6 7 8 10
19:25:30 <SamB> @oeis A000045
19:25:30 <lambdabot> Numbers in base 9.
19:25:30 <lambdabot> [0,1,2,3,4,5,6,7,8,10,11,12,13,14,15,16,17,18,20,21,22,23,24,25,26,27,28,30,3...
19:25:30 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
19:25:30 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
19:25:36 <ivanm> hang on, that failed for me when I /msg'd lambdabot for it :s
19:25:37 <Beelsebob> @oeis 1 2 3 4 5 6 7 8 10 12
19:25:37 <lambdabot> Integers i such that 9*i = 9 X i, i.e. 8*i XOR i = 9*i.
19:25:37 <lambdabot> [0,1,2,3,4,5,6,7,8,10,12,14,16,17,20,21,24,28,32,33,34,35,40,42,48,49,56,64,6...
19:25:50 <Beelsebob> @oeis 1 2 3 4 5 6 7 8 10 12 13
19:25:50 <lambdabot> Numbers n such that representation in base 11 has same number of 0's and 9's.
19:25:50 <lambdabot> [1,2,3,4,5,6,7,8,10,12,13,14,15,16,17,18,19,21,23,24,25,26,27,28,29,30,32,34,...
19:25:56 <Beelsebob> @oeis 1 2 3 4 5 6 7 8 10 12 13 15
19:25:56 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
19:26:01 <Beelsebob> hehe
19:26:13 <byorgey> I don't know why it does that Prelude.init: empty list thing
19:26:29 <Beelsebob> because it's asking for the init of the list of results from oeis?
19:26:39 <byorgey> I think that's from the glue code that includes it in lambdabot, not from the library itself
19:26:39 <Beelsebob> and no results == that error
19:26:52 <byorgey> Beelsebob: but it doesn't get a list of results.
19:26:56 <Beelsebob> oh, okay
19:27:04 <Beelsebob> makes no sense really then
19:27:13 * byorgey goes to peer at the lambdabot code
19:27:24 <sfultong> @oeis 1 2 7 16
19:27:35 <Beelsebob> @oeis -10 10 -10 10
19:27:39 <lambdabot> Plugin `oeis' failed with: thread killed
19:27:44 <Beelsebob> @oeis -10 10 -10 10
19:27:50 <lambdabot> Plugin `oeis' failed with: thread killed
19:27:55 <Beelsebob> I think I broke it
19:27:59 <lambdabot> Plugin `oeis' failed with: thread killed
19:28:00 <Beelsebob> @oeis -10
19:28:02 <sfultong> I broke it first
19:28:07 <Beelsebob> @oeis 10
19:28:12 <TSC> byorgey: Did you end up solving the graph colouring problem?
19:28:15 <lambdabot> Plugin `oeis' failed with: thread killed
19:28:17 <Beelsebob> hmm, it's generally dead
19:28:21 <Beelsebob> not a bug
19:28:23 <lambdabot> Plugin `oeis' failed with: thread killed
19:28:23 <byorgey> TSC: not yet
19:28:31 <byorgey> Beelsebob: wow, you really did break it!
19:28:37 <Beelsebob> TSC: what was the graph colouring problem?
19:28:42 <sfultong> no, it was me!
19:28:43 <Beelsebob> byorgey: it appears so
19:28:44 <TSC> Project Euler problem 189
19:28:45 <byorgey> TSC: did you?
19:28:55 <TSC> Yeah, eventually
19:29:01 <TSC> I had to keep pushing it to get up to 8
19:29:26 <ivanm> what's this problem?
19:29:34 <TSC> http://projecteuler.net/index.php?section=problems&id=189
19:29:35 <lambdabot> Title: Problem 189 - Project Euler
19:29:37 <Beelsebob> hmm, that's an interesting one
19:29:55 <Beelsebob> it's one of those ones that you start by thinking "that should be brute forcable"
19:30:05 <TehZorroness> hey, what's a good way to start workng with haskell (after reading one of those tutorials)?
19:30:07 <Beelsebob> and then you go "hang on, this is problem 189, there's no way to make that work"
19:30:18 <Beelsebob> TehZorroness: do some project euler problems?
19:30:19 <TSC> It doesn't take long to see it's not brute forceable
19:30:28 <Beelsebob> TSC: yeh, I know
19:30:30 <adu> Project Euler questions are "easy"
19:30:33 <TSC> (that was my first attempt)
19:32:17 <TSC> I solved it by computing the number of combinations at each row
19:32:28 <ivanm> TehZorroness: writing a window manager? *ducks*
19:32:45 <TehZorroness> haha
19:32:53 <TehZorroness> good one :)
19:33:15 <Beelsebob> TehZorroness: seriously, I now use Project Euler as examples to get to grips with any new language
19:33:16 <Syzygy-> TehZorroness: Write a tutorial.
19:33:16 <TSC> TehZorroness: I used the Project Euler problems to practise Haskell
19:33:22 <Beelsebob> it's well worth doing
19:33:58 <TehZorroness> Beelsebob, TSC I'm reading the page
19:34:07 <TehZorroness> looks interesting
19:34:35 <adu> I use tetration problems to learn a new language
19:34:42 <byorgey> TSC: this is you? http://projecteuler.net/index.php?section=profile&profile=TSC
19:34:43 <lambdabot> Title: Project Euler
19:34:50 <TSC> Yep
19:34:53 <byorgey> cool
19:35:08 <sjanssen> byorgey: yes, I'd like to add a function to oeis
19:35:39 <sjanssen> lambdabot has a fork of Mathe.OEIS to search for a sequence by name
19:35:55 <sjanssen> or something
19:35:58 <Beelsebob> hmm, I hadn't realised how many I'd solved
19:36:05 <Beelsebob> I might have a go at a few more
19:36:24 <byorgey> sjanssen: ok, cool. I'll see about setting up a darcs repo on c.h.o
19:36:28 <sjanssen> great
19:36:36 * sjanssen is decruftifying lambdabot
19:37:18 <lament> !cruft
19:37:48 <Beelsebob> hmm, at first, Haskell's average user rating of 17% seems fairly pants
19:38:01 <Beelsebob> until you realise that actually that's bloody good compared to other general purpose languages
19:38:14 <heatsink> Hmm, a trapezoid has a 9-triangle boundary.  There are 6561 colorings for the boundary assuming the first triangle is always red (other cases are symmetric), which means you could reduce the problem to... wait a minute.  I already have work to do.
19:38:27 <lament> does the rating basically mean how fast you get bored with the thing and leave?
19:38:58 <byorgey> it used to be a lot higher, but note there are now 763 (!!) users who have indicated Haskell as their favorite language
19:39:16 <adu> how do you find out the average user rating?
19:39:31 <Beelsebob> lament: I suspect that each language has a base of people who solve ~20 problems and leave
19:39:35 <byorgey> adu: go to the "statistics" page
19:39:56 <Beelsebob> and that then the remaining proportion are how far you can get solving the problems before it becomes too much of a technical challenge
19:39:57 <lament> Beelsebob: 20! that's a lot
19:40:03 <lament> i see myself doing 2
19:40:09 <Beelsebob> hehe
19:40:27 <sw17ch> does any one have a link to the Cairo Clock example?
19:40:31 <byorgey> it's probably some sort of power-law distribution.
19:40:32 <sw17ch> handy that is
19:40:40 <sw17ch> i can't google the right keywords for whatever reason
19:40:45 <adu> hmm "Haskell statistics" gives a page about probablistic Baysian models
19:41:24 <Saizan> sw17ch: http://haskell.org/gtk2hs/gallery/cairo-clock/Cairo_Clock_medium  this?
19:41:45 <sw17ch> i'm looking for the source
19:41:50 <sw17ch> but yes, that
19:43:46 <byorgey> adu: huh?  this is on the Project Euler website?
19:44:40 <Saizan> sw17ch: http://darcs.haskell.org/gtk2hs/demo/cairo/Clock.hs ?
19:45:07 <sw17ch> exactly Saizan, thanks
19:45:13 <adu> you said something about a statistics page
19:45:17 <adu> what did you mean?
19:45:39 <adu> I tried googling it and I can only find the Shootout
19:48:19 <sjanssen> @version
19:48:19 <lambdabot> lambdabot 4p603, GHC 6.8.2 (Linux i686 2.40GHz)
19:48:19 <lambdabot> darcs get http://code.haskell.org/lambdabot
19:48:34 <lekro> adu: you might need to login to see the stats page on project euler
19:48:34 <sjanssen> lol
19:48:49 <sjanssen> I think lambdabot/RunPlugs isn't 64-bit clean!
19:49:00 <Syzygy-> sjanssen: No, really?
19:49:13 * Syzygy- still hasn't gotten lambdabot to work on any of his machines.
19:49:51 <sjanssen> Syzygy-: actually, it might be okay on AMD64
19:50:21 <byorgey> adu: we were talking about the average user rating for people who marked HAskell as their favorite language on Project Euler
19:51:01 <adu> o ok
19:51:14 <adu> I thought you were talking about the Haskell wiki! that makes more sense
19:51:19 <byorgey> hehe
19:51:38 <sw17ch> has any one present done work with Cairo and Haskell?
19:54:33 <lekro> sw17ch: I started doing a little test with it but I went to OpenGL very quickly because Cairo was too slow on my Mac
19:55:07 <lekro> sw17ch: once I'd managed to install all the required libraries, the cairo examples and everything worked fine
19:55:09 <sw17ch> lekro, hmmm... what were you trying to do?
19:55:21 <lekro> displaying graphs and knots
19:55:24 <sw17ch> oh, the examples work fine for me as well... i'm just trying to wrap my head around it :)
19:55:28 <sw17ch> oh fun...
19:55:42 <sw17ch> i'm just trying to render some text and arrows :)
19:56:53 <Syzygy-> ?go 1500 usd ineur
19:56:55 <lambdabot> http://www.muni.cz/study/attributes/tuition_fees_info
19:56:55 <lambdabot> Title: Fees for individual academic years
19:56:56 <Syzygy-> ?go 1500 usd in eur
19:56:58 <lambdabot> http://catalog.antiquorum.com/catalog_asta.html?hideauctions=1&auctionid=204
19:56:58 <lambdabot> Title: Catalog ONLINE
19:57:07 <Syzygy-> pshh
19:57:23 <newsham> ?tick eurusd
19:57:23 <lambdabot> Maybe you meant: dice dict time
19:57:44 <newsham> EURUSD=X: 1.5822 N/A - @ 4/15/2008 10:56pm
19:57:59 <lekro> sw17ch: things like that: http://christoph-d.de/c/Knot4.png (however, that's OpenGL now). it was a graphics project for a class
20:00:00 <hpaste>  dylan pasted "partial xmonad.hs" at http://hpaste.org/6987
20:00:33 <gwern> tarnation. this is a troublesome cabal/cpp/configure issue
20:00:59 <byorgey> heehee, gwern said 'tarnation' =)
20:01:03 <sw17ch> lekro, cool :) pretty slick
20:01:22 <sw17ch> i have a reference graph that i'm trying to visualize
20:01:39 <gwern> so I know HAVE_CURL is defined in my configure script, and I know there's CPP directives to that effect in URL.hs, but when I build through cabal, the directives act as if no HAVE_CURL was defined!
20:02:10 <newsham> http://www.thenewsh.com/%7Enewsham/x/Ticker.hs
20:02:36 <gwern> byorgey: tarnation describes my feelings without circumlocution or equivocating!
20:03:16 <Saizan> GHC never evaluates/shares under lambdas, right?
20:03:23 <gwern> *circumlocution or equivocation
20:05:14 <Saizan> gwern: tried using .cpphs as extension for those files that need CPP preprocessing?
20:05:27 <gwern> Saizan: no. worth a try I suppose
20:05:54 <gwern> but they are being CPP preprocessed, it's just that they are taking the branch of the conditional they're not supposed to!@
20:05:57 <Saizan> gwern: that way it's cabal that does the preprocessing, if not it's ghc itself
20:10:09 <gwern> Saizan: no, that doesn't seem to've helped
20:21:20 <hpaste>  (anonymous) annotated "some sort of multiline literal problem" with "(no title)" at http://hpaste.org/6986#a1
20:22:37 <gwern> sorry anonymous, I rewrote that a while ago, and the program which was generating that module too
20:39:30 <xif> Prelude> :t rem
20:39:32 <xif> rem :: (Integral a) => a -> a -> a
20:39:36 <xif> can anyone explain why?
20:39:57 <centrinia> It divides the first a by the second a and returns the remainder, of type a.
20:40:27 <xif> hm.
20:40:47 <gwern> frustrating. I still have no idea why the CPP directives are going awry
20:41:00 <Beelsebob> xif: what would you expect the type to be, and why?
20:41:40 <xif> Beelsebob, centrinia: the book says that it's actually short-hand for `a -> (a -> a)`
20:41:49 <Beelsebob> yep
20:41:59 <gwern> @seen dcoutts_
20:41:59 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #ghc and #haskell. I don't know when dcoutts_ last spoke.
20:42:02 <xif> Beelsebob: good. since you agree, how does that make sense? :)
20:42:05 <centrinia> You can (rem 100)
20:42:10 <Beelsebob> so xif rem is a function that accepts "some integer type value"
20:42:16 <Beelsebob> it returns another function
20:42:22 <centrinia> That is a function that lets you divide 100 by any (Integral a)
20:42:28 <ddarius> :t rem 100
20:42:31 <lambdabot> forall t. (Integral t) => t -> t
20:42:35 <Beelsebob> that function accepts a second value of the same integer type 'a'
20:42:46 <Beelsebob> and it returns a value of the same integer type a
20:42:48 <gwern> @seen dcoutts
20:42:48 <lambdabot> I saw dcoutts leaving #ghc, #haskell, #gentoo-haskell, #haskell-soc and #haskell-hac4 19h 7m 43s ago, and .
20:42:57 <sjanssen> gwern: so where is HAVE_CURL defined?
20:43:22 <xif> Beelsebob, centrinia, ddarius: OK, why is it implemented like that?
20:43:34 <xif> and how am I supposed to know that it is implemented like that?
20:43:36 <Beelsebob> xif: because it makes it incredibly clean to implement
20:43:45 <Beelsebob> and because it makes it incredibly flexible
20:43:48 <gwern> sjanssen: in the configure script
20:43:56 <Beelsebob> for example, if it weren't implemented like that, I couldn't do this...
20:43:58 <centrinia> Lambda calculus functions only accept single parameters. :p
20:44:03 <xif> Beelsebob: it seems more natural (naive?) for me to implement it as a function that takes too arguments.
20:44:05 <Beelsebob> > map (rem 5) [1..10]
20:44:06 <lambdabot>  [0,1,2,1,0,5,5,5,5,5]
20:44:15 <xif> *two
20:44:23 <sjanssen> gwern: the configure script should generate some file, what generated file should contain HAVE_CURL?
20:44:25 <xif> that is, admittedly, pretty cool.
20:44:42 <Beelsebob> xif: well, the point is that this way we don't have do deal with complex cases
20:44:45 <ddarius> xif: There is a natural isomorphism between (a,b) -> c and a -> b -> c
20:44:48 <xif> so basically, all functions in haskell take just one argument?
20:44:48 <Beelsebob> we have to deal with one case and one case only
20:44:56 <Beelsebob> the case where a function has one argument
20:44:58 <hpaste>  gwern pasted "confiugre.ac" at http://hpaste.org/6988
20:45:15 <Cale> xif: In Haskell, there's no difference between functions that have two parameters and functions which have one parameter and produce a function.
20:45:21 <Beelsebob> xif: the actual implementation may not do that, *but* they will certainly behave like that
20:45:32 <Cale> xif: You can have functions which take tuples of course.
20:45:37 <xif> Beelsebob, centrinia: and this is based on some mathematical principle?  that "lambda calculus" that you mentioned?
20:45:49 <Cale> (but that again is just one parameter really)
20:46:03 <Beelsebob> xif: well, you'll note that in lambda calculus, lambda expressions only take one argument
20:46:03 <Cale> So in some sense, all functions in Haskell have exactly one parameter.
20:46:10 <Beelsebob> it's all part of implementing it simply and beautifully
20:46:32 <sjanssen> gwern: look for *.in files that contain the variable you're interested in
20:46:55 <gwern> sjanssen: the configure produced is long and complex, and I'm not really sure what in the relevant section might be the problem
20:46:58 <xif> Cale: I'm reading a book, "The Haskell Road to Logic, Math, and Programming". will it teach me why it works that way?
20:47:04 <gwern> sjanssen: did you see the paste of the configure.ac?
20:47:22 <Cale> xif: I don't remember if it talks about that explicitly or not.
20:47:25 <sjanssen> gwern: ignore the configure script, it's billions of lines of backwards compatibility workarounds
20:47:34 <sjanssen> gwern: are you familiar with how autoconf works?
20:47:46 <Cale> xif: The main reason is that it's incredibly convenient for it to work that way, and gives rise to a nice clean syntax and conceptual model.
20:48:07 <gwern> sjanssen: not really. I think you give it some simple high-level scripts, and then it compiles them down into supposedly portable sh
20:48:09 <Beelsebob> xif: suppose you were to implement a functional language
20:48:17 <Beelsebob> you *have* to implement one argument functions
20:48:25 <xif> Beelsebob: sure.
20:48:33 <Cale> xif: One effect of this decision which you might notice is that function parameters are best arranged from least likely to change, to most likely to change.
20:48:35 <sjanssen> gwern: the configure script looks for files matching 'X.in', then substitutes certain variables in that file, producing 'X'
20:48:35 <xif> Beelsebob: hehe, it's sort of like a logic gate.
20:48:36 <Beelsebob> if one argument functions give you multi-argument functions too, why implement a special case to do that?
20:49:05 <xif> the most basic logic unit is also the only one implemented.
20:49:07 <Beelsebob> xif: a logic gate which may return a new logic gate on it's output stream
20:49:08 <Cale> xif: Because then partial application has the most usefulness.
20:49:13 <Beelsebob> so not very much like one
20:49:39 <xif> Beelsebob: I meant in the metaphorical sense of "impelementing only the most minimal building block"
20:49:42 <sjanssen> gwern: so you need to find the '.in' files that contain the variable of interest
20:49:47 <Beelsebob> xif: yep
20:49:53 <ddarius> One effect of this decision is that (functional) composition is more difficult.
20:50:07 <Cale> ddarius: It is?
20:50:18 <sjanssen> gwern: since the defined values aren't propagating to Cabal, they're probably built in to darcs makefile
20:50:20 <xif> Cale: OK, still, there is some math behind that, right?  this "lambda calculus" thing?
20:50:29 <Beelsebob> xif: of note, the most minial building blocks are... x, (\x -> T), and T T'
20:50:33 <ddarius> Cale: a -> b -> (a,b) is asymmetric and does not compose with itself
20:50:48 <Cale> ddarius: ah, okay, yes, there's that particular case :)
20:50:59 <Cale> ddarius: You can use (a,b) -> (a,b) still of course.
20:51:14 * gwern vaguely wonders whether the problem is that configure.ac says 'AC_SUBST(HAVE_LIBCURL)' while the CPP directives look like '#if !defined(HAVE_CURL) || !defined(HAVE_LIBWWW)
20:51:43 <sjanssen> gwern: heh, maybe that could do it
20:51:49 <Cale> It does however, compose with any function taking a parameter of type (b -> (a,b)), or on the other side with a function that produces an a
20:52:22 <sjanssen> gwern: do you understand what I'm trying to say about '.in'?
20:52:49 <gwern> sjanssen: I think so
20:52:59 <Beelsebob> xif: yes, lambda calculus is the minimal set of things you need to get "functional style" computation
20:53:01 <gwern> and I think I see what the problem is: the GNUmakefile says: ifeq ($(HAVE_LIBCURL),True)
20:53:05 <gwern> C_OBJS += src/hscurl.o
20:53:07 <gwern> GHCFLAGS += -DHAVE_CURL
20:53:10 <gwern> endif
20:53:13 <sjanssen> gwern: there you go
20:53:23 <gwern> sjanssen: now the question is, how do I fix that :)
20:53:30 <gwern> for cabal, I mean
20:53:34 <sjanssen> gwern: perhaps use a .buildinfo?
20:53:47 <sjanssen> gwern: see the X11 package for an example
20:53:49 <xif> Beelsebob: cool, any good book to study about it?
20:54:05 <gwern> sjanssen: I can't edit the CPP directives to say 'HAVE_LIBCURL'?
20:54:14 <sjanssen> gwern: that won't help
20:54:40 <gwern> oh. :(
20:55:01 <sjanssen> autoconf variables /= cpp variables
20:55:06 <Beelsebob> xif: hmm, perhaps this? http://www.cs.ru.nl/E.Barendsen/onderwijs/sl2/materiaal/lambda.pdf
20:55:08 <lambdabot> http://tinyurl.com/5kqq3g
20:55:11 <sjanssen> you have to do the plumbing between them
20:55:34 <gwern> consarn it!
20:56:27 * gwern briefly considers ripping out the curl defines and using the haskell binding. but then I'd need to make the binding compile on 6.8.x, and I'd have to duplicate the darcs C extensions to curl
20:56:45 <xif> Beelsebob: coolness, thanks!
20:56:46 <bos> good grief, System.Directory doesn't have some kind of binding for *stat*?
20:57:04 <pigeonflight> I've managed to install haskell ghc 6.8.2 and wxhaskell on os x 10.4
20:57:10 <Beelsebob> xif: I can't swear to the quality of that, but a quick google and skim through it seemed to indicate it was good
20:57:15 <pigeonflight> but when I try to run a program I get Could not find module `Graphics.UI.WX':
20:57:18 <xif> Beelsebob: (quite frankly, I expected that any introductory Haskell text would discuss it)
20:57:36 <glguy> bos, no one writes factorial functions with *stat*
20:57:42 <Beelsebob> xif: well, for all intents and purposes it's not something that an introduction needs to cover
20:57:54 <Beelsebob> in that you can go on telling people that we have multi-argument functions
20:58:09 <bos> glguy: i keep forgetting how awful the portable IO libraries are
20:58:25 <Beelsebob> and the only time you need to explain more is when people start saying "but why do we have this odd arrow thing in the type, why don't we have arguments then one arrow, then result?"
20:58:27 <ddarius> Haskell is a picture defined by negative space
20:59:34 <sjanssen> bos: which part of stat are you missing?
21:00:03 <bos> sjanssen: all the useful parts?
21:00:15 <xif> Beelsebob: yeah, it's very interesting though... thanks!
21:00:26 <Beelsebob> xif: yep, certainly is :)
21:00:38 <bos> sjanssen: all you get from System.Directory is "is this a file or directory", which requires two separate calls.
21:00:54 * pigeonflight just wants to get wxhaskell to work
21:00:59 <sjanssen> bos: also permissions and modtime
21:01:06 <Beelsebob> but possibly a little overwhelming to someone you're trying to convince that Haskell isn't a big bad maths-knowledge-requiring nasty
21:01:56 <bos> sjanssen: huh?
21:02:04 <bos> sjanssen: oh, yes
21:02:08 <bos> (sorry, wrong haddock)
21:02:17 <sjanssen> bos: System.Directory.{getPermissions, getModificationTime}
21:02:27 <bos> but you can't find out what size a file is.  boggle.
21:02:39 <sjanssen> yeah, that's a clear oversight
21:02:51 <gwern> sjanssen: so a darcs.buildinfo would get automatically picked up by cabal?
21:02:57 <cjs> You could read the entire file. :-)
21:03:08 <sjanssen> gwern: right
21:03:09 <bos> the entire interface is misdesigned.
21:03:10 <pigeonflight> how do I install cabal
21:03:14 <cjs> Or more realistically, seek to the end.
21:03:18 * pigeonflight wish he could cabal install cabal
21:03:37 <gwern> pigeonflight: you can - cabal's on hackage like any other lib
21:03:47 <gwern> bootstrapping may be a problem tho... :)
21:03:48 <sjanssen> bos: do you know how Windows does these operations?
21:03:50 <bos> cjs: you can actually find out the size of a file by opening it and calling something on the Handle you get back, but that's ... not optimal.
21:04:07 * pigeonflight is glad to know that cabal is on "hackage like any other lib"
21:04:14 <bos> sjanssen: yes, it provides a stat() implementation.
21:04:21 * pigeonflight goes to google hackage (being a cabal and haskell newbie)
21:05:42 <cjs> Is there no stat() in one of the Posix modules?
21:06:04 <pigeonflight> gwern: so.... how do I install cabal, I've never used hackage before /me is assuming you mean http://hackage.haskell.org
21:06:05 <bos> cjs: there is, but that's not much use on windows.
21:06:07 <lambdabot> Title: HackageDB: introduction
21:06:40 <cjs> Oh, Windows doesn't support the Posix modules? I had thought it would.
21:07:16 <bos> the native code underneath could support most of the posix interfaces, but hasn't been ported.
21:07:46 <bos> and the APIs aren't designed with "this may not work on some platforms" in mind.
21:08:01 <gwern> pigeonflight: your ghc didn't come with cabal?
21:08:14 <pigeonflight> gwern: I'm not seeing it
21:08:21 * pigeonflight is downloading cabal from hackage now
21:08:25 <thoughtpolice> pigeonflight: did you do 'ghc-pkg list Cabal' ?
21:08:33 <pigeonflight> thoughtpolice: no
21:08:45 * pigeonflight goes to do  'ghc-pkg list Cabal' 
21:09:00 <thoughtpolice> it should be installed, if it isn't, that would be very very weird
21:09:06 <thoughtpolice> and hard to fix considering cabal builds with cabal :)
21:09:15 <pigeonflight> thoughtpolice:  I get the following:
21:09:15 <pigeonflight>     Cabal-1.2.3.0
21:09:18 <pigeonflight>     Cabal-1.2.3.0
21:09:24 <thoughtpolice> pigeonflight: then you're fine. it's installed.
21:09:41 <pigeonflight> thoughtpolice: so perhaps it is a path issue then?
21:09:54 <pigeonflight> typing 'cabal' won't work for me
21:10:03 <ddarius> cabal is a library
21:10:04 <thoughtpolice> pigeonflight: oh, you're talking about cabal-install then
21:10:14 <ddarius> cabal-install is a package containing a cabal application
21:10:15 <pigeonflight> thoughtpolice: I guess
21:10:19 <thoughtpolice> pigeonflight: cabal (the command) allows you to automatically download packages from hackage
21:10:22 <ddarius> (it's a mite confusing)
21:10:22 * pigeonflight didn't know that he was talking about cabal-install
21:10:36 <pigeonflight> thoughtpolice: that's what I want
21:10:37 <thoughtpolice> Cabal (the library) is what's used to actually build the applications; Cabal provides the infrastructure to build and install things
21:10:52 <pigeonflight> was following a tutorial to get wxhaskell installed and saw cabal mentioned
21:10:59 <thoughtpolice> pigeonflight: yes it's not included standard, so you will have to install it from hackage. after that installing most things should be good :)
21:11:10 <sw17ch> so, i'm trying to mix IO actions with Render actions from the Cairo/GTK libraries ...
21:11:15 <sw17ch> i don't have a clue how to do that :)
21:11:15 <pigeonflight> thoughtpolice: so get cabal-install then?
21:11:24 <thoughtpolice> pigeonflight: it's not strictly necessary
21:11:36 <thoughtpolice> pigeonflight: you can just download the packages from hackage and build them manually
21:11:48 <thoughtpolice> which is normally about 4 steps: 1) download. 2) configure. 3) build. 4) install
21:11:52 <thoughtpolice> cabal install just makes it easier
21:12:19 <thoughtpolice> (it just automates those 4 steps basically, as well it does dependency fetching which is very useful though)
21:12:34 <thoughtpolice> so it's worth having. :)
21:14:25 <sjanssen> gwern: wow, darcs configure.ac is pretty insane
21:15:12 <gwern> sjanssen: I know :(
21:15:17 <sjanssen> gwern: it looks for Control.Monad in either mtl or util
21:15:38 <gwern> I think I've gotten it to include -DHAVE_CURL as a CPPFLAG, which means it appears in darcs.buildinfo
21:15:51 <gwern> sjanssen: yeah, how old is that? when was c.m in 'util'?
21:16:01 <sjanssen> Control.Monad has been in base since at least 6.4
21:16:07 <sjanssen> possibly longer
21:17:03 <sjanssen> I doubt that darcs builds on such an old GHC, anyway
21:17:33 <gwern> it barely does on 6.3
21:17:36 <gwern> er, 6.4
21:17:58 <sjanssen> gwern: have you actually tested that?
21:18:18 <sjanssen> this would be good ammunition if you want to convince darcs hackers to move to Cabal :)
21:18:32 <gwern> sjanssen: no, somone in #darcs said they were sending a patch which made darcs build on 6.4
21:18:51 <gwern> (apparently dars needed a function defined which wasn't in the 6.4 base libs or something)
21:19:06 <sjanssen> yay, more hacky workarounds!
21:20:13 * gwern imagines roundy collapsed over his desk. as he lifts his haggard head and his stained eyepits bore into the viewer, he intones with horror - 'I've created a - MONSTER!'
21:21:05 <ddarius> Isn't that a given with autoconf?
21:21:33 <gwern> ddarius: you could have said that more drolly. fie, fie
21:21:44 <thoughtpolice> gwern: you should write a book. "haskell: the untold stories" or something.
21:21:44 <gwern> sjanssen: is 'cpp-options:  -DCURL_MULTI_TIMEOUT -DHAVE_CURL' right, or was it supposed to be ghc-options:?
21:22:01 <sjanssen> gwern: it should be cpp-options
21:22:37 <gwern> but the makefile was syaing 'GHCFLAGS += -DHAVE_CURL'
21:23:15 <pigeonflight> okay... I've install cabal-install but it doesn't seem to be in my path
21:23:22 <pigeonflight> how do I know where it was installed to?
21:23:36 <sjanssen> gwern: cpp-options will always work, ghc-options will only work if Cabal uses GHC to preprocess (sometimes it can use cpphs)
21:23:55 <gwern> thoughtpolice: 'Haskell: the untold tales; discover the true meaning of SPJ on a unicycle, witness the perversions of darcs unnaturally coupling with cabal, be astounded at the ancient cruft in nofib, wilt in the gale of Cale's astonishing audiomatronic Lambdabot with its vicious new Prelude...'
21:24:36 * pigeonflight just wants to be able to use cabal install
21:25:02 <pigeonflight> I used the whole Setup.lhs configure, build, install dance
21:25:06 <sjanssen> pigeonflight: the default is probably /usr/local, unless you overrode that
21:25:23 <sjanssen> pigeonflight: did you give a --prefix argument to configure?
21:25:55 <pigeonflight> I used ports on os x to install
21:26:03 <pigeonflight> I know that ghc is in /opt
21:26:07 <thoughtpolice> pigeonflight: try 'which cabal' ?
21:26:31 <sw17ch> Why are all the Pango functions Render () actions and all the things that change the Pango layouts IO () actions...
21:26:33 <pigeonflight> thoughtpolice: that would only work if it was in my path
21:26:39 <thoughtpolice> gwern: you are only proving my point. go write that book.
21:26:40 <sw17ch> and how does one make the two work together
21:26:40 <sjanssen> pigeonflight: wait, which did you do: use ports, or install manually?
21:26:45 <gwern> sjanssen: are you *sure* 'darcs.buildinfo' need only be present for cabal to automatically use it? I've tried rebuilding with cpp-options and ghc-options in darcs.buildinfo having the appropriate '-DHAVE_CURL' entry, and ldd'ing the compiled binary still shows no curl link?
21:26:51 <pigeonflight> sjanssen: ports to install ghc
21:26:59 <pigeonflight> sjanssen: manually to install wxhaskell
21:27:09 <pigeonflight> and cabal packages to install cabal-install
21:27:35 <sjanssen> gwern: did you also use extra-libraries to make GHC link with curl?
21:27:50 <gwern> thoughtpolice: if I ever write an essay on my experiences, it'll be called 'Writing maintaineable Haskell software, or, Indiana Gwern and the Raiders of the Lost Src'
21:27:54 <gwern> sjanssen: no
21:27:57 <sjanssen> pigeonflight: okay, look in /usr/local/bin unless you gave a --prefix
21:27:59 * pigeonflight has spent 5 hours of his life trying to get wxhaskell working, with the simple goal of creating a simple text editor
21:28:32 <gwern> pigeonflight: builds character!
21:28:36 <pigeonflight> sjanssen: don't see them there (will need to pay more attention, next time I'm installing :) )
21:28:42 <gwern> pigeonflight: hey, I can't even compile wxhaskell on my system
21:29:03 * pigeonflight feels greatly encouraged now 
21:30:19 <gwern> hm. adding curl to extra-libraries causes link errors
21:31:52 * pigeonflight grabs wx and wxcore from hackage
21:32:09 * pigeonflight feels like he may actually know some haskell (or haskell package management)
21:32:35 * pigeonflight does the "runghc Setup.lhs configure && runghc Setup.lhs build && runghc Setup.lhs install" dance
21:33:45 <gwern> pigeonflight: advice: you can drop the .lhs's, and 'runhaskell' is better than 'runghc'
21:35:33 <mauke> how is it better? it's longer
21:36:45 <gwern> mauke: maybe you won't always use ghc
21:36:59 <mauke> then I'll use a different command
21:37:33 <gwern> 'A portable OS? That's absurd. If I change computers, then I'll use a different OS'
21:38:06 <glguy> yeah... this is definitely worth trying to convince him to switch
21:38:47 <mauke> in reality I just type 'make install'
21:39:08 <Cale> gwern: The other day I built wxhaskell, but every program built with it just died immediately with some gtk assertion failures.
21:39:25 <bos> @hoogle concatMapM
21:39:25 <lambdabot> No matches found
21:39:30 <ivanm> see? source-based-distributions ftw! :p
21:39:43 <bos> the agony and the ecstasy of monads, right there.
21:39:54 <gwern> Cale: that's odd. I thought wxwidgets was different from gtk
21:40:23 <Cale> gwern: It uses the gtk widgets when used on linux.
21:40:46 <gwern> hm
21:44:12 <bos> @pl  notDots p = p /= "." && p /= ".."
21:44:12 <lambdabot> notDots = liftM2 (&&) ("." /=) (".." /=)
21:44:41 <mauke> (`notElem` [".", ".."])
21:45:28 <bos> i was hoping it might do something exotic, like (&&) <*> ("."/=) <*> ("."/=)
21:45:44 <mauke> +pure
21:55:33 <paczesiowa> Baughn: I uploaded that code, you asked me to, to ghc ticket
21:56:54 <paczesiowa> @tell help
21:56:54 <lambdabot> Consider it noted.
21:57:05 <paczesiowa> yeah, that was helpful
21:57:10 <paczesiowa> @help
21:57:10 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:57:15 <paczesiowa> @help tell
21:57:15 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
21:57:36 <paczesiowa> @tell Baughn I uploaded that code, you asked me to, to ghc ticket
21:57:36 <lambdabot> Consider it noted.
22:09:29 <paczesiowa> @tell Baughn looks like we weren't first ones to notice that bug, check http://hackage.haskell.org/trac/ghc/ticket/1780
22:09:29 <lambdabot> Consider it noted.
22:46:28 <eck> what does the syntax (# #) mean? as in:     return x = State $ \s -> (# x, s #)
22:47:08 <eck> i'm looking at State.hs in the ghc code
22:48:09 <ivanm> unboxed types, IIRC
22:48:22 <ivanm> but you probably shouldn't be looking there :p
22:50:48 <eck> thanks
22:50:50 <ivan_salazar_v> Hello, I'm having a hard time reading binary files and sending them through a socket connection. I asked a couple hours later here in the channel and got no answer.
22:50:50 <ivan_salazar_v> I'm, trying to code a very minimalistic web server and the code I use to send the files is this:
22:50:50 <ivan_salazar_v> sendResource handle name =     do exist <- doesFileExist name        isFile <- liftM not (doesDirectoryExist name)       if exist && isFile            then do resource <- processResource name                   hPutStr handle (header ++ fileType ++ "\n")                    hSetBinaryMode handle True                   hPutStr handle resource           else do hPutStr handle page404    where fileType = maybe ("text/plain") (flip const [])                
22:50:51 <ivan_salazar_v> tensions)
22:51:49 <ivan_salazar_v> Oh, sorry... don't know why it isn't indented...
22:52:16 <mrd> hpaste: url
22:52:16 <hpaste> Haskell paste bin: http://hpaste.org/
22:52:26 <ivan_salazar_v> thanx
22:56:07 <hpaste>  ivan_salazar_v pasted "Question sending a binary file through a socket" at http://hpaste.org/6989
22:56:24 <ivan_salazar_v> http://hpaste.org/6989
22:56:39 <ivan_salazar_v> Wow... haskell tools amaze me...
22:57:13 <ivan_salazar_v> Well then, there's my code.
22:57:24 <mrd> ?hoogle processResource
22:57:25 <lambdabot> No matches found
22:57:29 <mrd> what is that?
22:57:46 <ivan_salazar_v> Damn, incomplete code, sorry.
22:58:02 <mrd> annotate it
22:58:13 <ivan_salazar_v> Yes.
22:59:25 <hpaste>  ivan_salazar_v annotated "Question sending a binary file through a socket" with "Question: sending a file through a scoket (cont)" at http://hpaste.org/6989#a1
22:59:57 <ivan_salazar_v> Oh, my.. It must be the hour of the day.
23:00:14 <ivan_salazar_v> I'm still missing code.
23:00:20 <ivan_salazar_v> I'm very sorry.
23:01:06 <hpaste>  ivan_salazar_v annotated "Question sending a binary file through a socket" with "(cont)" at http://hpaste.org/6989#a2
23:02:05 <ivan_salazar_v> Well, I think that's it.
23:03:00 <ivan_salazar_v> I've been trying with both readBinaryFile and with Data.ByteString.readFile and I just can't do it.
23:03:30 <ivan_salazar_v> Plain text files are being sent correctly, though.
23:05:43 <mrd> can you avoid converting to a String?
23:05:56 <mrd> you posted on ghc list, i saw, and that code should not have typechecked
23:06:06 <mrd> it used hPutStr on a ByteString
23:06:09 <ivan_salazar_v> Yes, I double posted :S
23:06:26 <ivan_salazar_v> ? hPut
23:06:34 <ivan_salazar_v> ?hoogle hPut
23:06:34 <lambdabot> Data.ByteString.hPut :: Handle -> ByteString -> IO ()
23:06:34 <lambdabot> Data.ByteString.Char8.hPut :: Handle -> ByteString -> IO ()
23:06:34 <lambdabot> Data.ByteString.Lazy.hPut :: Handle -> ByteString -> IO ()
23:06:43 <mrd> yah
23:06:53 <ivan_salazar_v> Should I use hPut ?
23:06:58 <mrd> try it
23:07:05 <ivan_salazar_v> Yes, thank you.
23:10:03 <ivan_salazar_v> got this in the browser: The image â€œhttp://localhost:1729/Xlight.pngâ€ cannot be displayed, because it contains errors.
23:11:43 <mrd> i'm not sure.  check out the binary package?
23:11:45 <mrd> ?hackage binary
23:11:45 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
23:11:58 <mrd> i have to go. perhaps that will have a useful function.
23:12:22 <hpaste>  (anonymous) pasted "form based upload" at http://hpaste.org/6990
23:12:30 <bos> i wonder if many people manually manage stacks of monad transformers.
23:13:10 <dibblego> do any of you guys have opinions on "pair programming"? would you "pair" when using Haskell?
23:13:55 <bos> pair programming requires a sturdy keyboard, for whenever the person who isn't typing reaches for it and starts beating the typist.
23:14:31 <dibblego> that's very much my opinion, but do you think it is a consequence of poor programming languages among others?
23:14:45 <Pseudonym> I would never do that.
23:14:47 <jeffz> sounds a bit archaic, don't pair programmers use a collaborate text editor?
23:14:55 <Pseudonym> Takes too much effort to reach over.
23:14:55 <jeffz> collaborative, I mean.
23:15:06 <Pseudonym> Especially when there's other stuff around, like nerf weaponry.
23:15:25 <dibblego> jeffz, yes, two keyboards plugged into the same machine and therefore, using the same editor
23:15:33 <bos> there are very few collaborative text editors. shoulder surfing is often the rule.
23:15:42 <jeffz> dibblego: I was thinking of some sort of emacs mode that lets you muck about in the same buffer over a network or something.
23:15:43 <ivan_salazar_v> hPut didn't seem to work.
23:15:44 <dibblego> sorry, not collaborative as I think you might mean
23:15:50 <bos> at work, some people use screen sessions and headsets to collaborate over the intertubes.
23:16:07 <dibblego> is this mockery representative of your opinion?
23:16:10 <bos> we have some XP and pair programming cultists.
23:16:48 <bos> i think that if other people want to pair program and don't bother me, they're neither breaking my leg nor stealing my wallet.
23:16:51 <ivan_salazar_v> MrDomino_: Thanks.
23:16:55 <ivan_salazar_v> Ouh
23:17:08 <ivan_salazar_v> MrDomino_: Thanks (sorry... XD)
23:17:16 <ivan_salazar_v> MrDomino_: thanks
23:17:20 <ivan_salazar_v> Uh?
23:17:50 <dibblego> bos, because you think it is detrimental to your progress? or because you simply have no great preference for it?
23:17:54 <elemjay> Latest Google Tech Talk on the future of Linux: http://www.youtube.com/watch?v=4A6ImflixL8
23:17:54 <lambdabot> Title: YouTube - Dan Compilation #3
23:18:20 <bos> dibblego: it slows me down. i love pair debugging, but pair programming drives me nuts.
23:19:00 <dibblego> bos, would you debug a Haskell program with another person? would you prefer someone mathematically versed? are you applying equational reasoning or stepping through imperative code?
23:19:13 <Pseudonym> I would, if it was someone smart.
23:19:27 <Pseudonym> I agree, pair programming is best if you're doing maintenance,.
23:19:36 <Pseudonym> Adding a small feature or fixing a bug report.
23:19:57 <bos> i'd definitely debug haskell code with someone else, yes.
23:20:12 <bos> the act of saying out loud what you think is going on is very valuable.
23:22:28 <bos> dibblego: i haven't often used equational reasoning or the like to debug haskell code. i mainly favour staring, scratching my head, and the occasional curse.
23:22:53 <koninkje_away> Given a MPTC "class Foo a b where foo :: a -> b -> ..." is there a safe way to derive Foo b a iff Foo a b exists? (ala "class Foo a b => Foo b a where foo x y = foo y x" but, y'know, without breaking everything)
23:23:41 <dibblego> bos, suppose there was a stereotypical Java programmer or a Haskell with equivalent levels of ability in programming, would you consider that a hindrance in all cases?
23:23:51 <bos> not at all.
23:24:10 <quicksilver> koninkje_away: no. it would make a loop, wouldn't it?
23:24:18 <quicksilver> koninkje_away: it would derive a b from b a from a b from b a
23:24:39 <koninkje_away> quicksilver: with that definition, yes. I was wondering if there was some safe way to do it
23:24:52 <dibblego> bos, why not? the chances of being offered anything useful become remote and the cost incurred in the pairing may not be worth it? is there some point where you think this becomes universally true?
23:24:57 <quicksilver> koninkje_away: you could safely do instance Foo a b => Foo (Wrapped a) (Wrapped b)
23:25:10 <quicksilver> koninkje_away: where Wrapped is a type constructor which does nothing.
23:25:15 <quicksilver> data Wrapped a = Wrapped a
23:25:27 <quicksilver> koninkje: ehm, swap a and b somewhere ;)
23:25:33 <bos> dibblego: i don't often get much from whoever i'm debugging with. they're a pair of ears to listen to my explanations as i try to describe what i think is happening, fairly often.
23:26:03 <dibblego> bos, then if that person is an inanimate object, then the process is just as effective, since you're just reflecting on your own words?
23:26:04 <koninkje> quicksilver: the trick is, Foo is a symmetric relation and it'd be nice to capture that elegantly...
23:26:17 <koninkje> quicksilver: using a newtype wrapper could work though...
23:26:25 <bos> inanimate objects don't nod or ask the occasional question.
23:26:38 <bos> and they're not noted for flashes of insight, either.
23:27:18 <dibblego> but some people are not smart enough to nod or ask occasional (meaningful) questions; does that point of poor ROI exist?
23:28:21 <bos> dibblego: probably?  i don't tend to ask people to look over something with me if i don't think they'll be any use at all, so i've no data for that end of the spectrum.
23:28:44 <dibblego> bos, well that's my point; suppose I imposed it on you - you didn't have the choice
23:29:06 <dibblego> bos, I understand that you would sometimes elect for help from peers, but this is because you believe it will be helpful
23:29:44 <dibblego> is it possible that you were put in a position where it is a hindrance (i.e. worse than not at all), but not necessarily by your own will?
23:30:38 <bos> i ... suppose?
23:30:57 <joed> Is this to do with elected people in the US?
23:31:03 <dibblego> no
23:31:06 <dibblego> bos, thanks
23:42:02 <slava> hi dibblego
23:42:37 <dibblego> hello
23:42:41 <dibblego> long time!
23:54:08 <pantsd> :t ( \x -> (foldl (+) 0 x)/(fromIntegral (length x)))
23:54:12 <lambdabot> forall a. (Fractional a) => [a] -> a
23:54:40 <pantsd> How would I write that so intestead of fractional a it would work with all Num a ?
23:56:45 <Korollary> @type (/)
23:56:45 <lambdabot> forall a. (Fractional a) => a -> a -> a
23:56:59 <ivanm> pantsd: you can't, since not all types of (Num a) accept /
23:58:33 <pantsd> hmms
23:59:09 <pantsd> damn
23:59:35 <pantsd> surely there must be a way to write a generalized average function
23:59:36 <pantsd> hmms
23:59:58 <ulfdoz> Hm yesterday, I tried to define a predicate over the ST-Monad. Thus I tried something like "let stm = return ["foo"] in (runST . null) stm", which gives me type error, I don't understand.
