00:01:11 <Gilly> how do i convert a string to bytestring?
00:01:19 <dolio> pack
00:01:33 <Gilly> pack wants [Word8]
00:01:37 <Gilly> String is [Char]
00:01:48 <dolio> Data.ByteString.Char8.pack
00:01:55 <Gilly> ah, thanks
00:02:01 <dolio> No problem.
00:43:16 <dcoutts> loupgaroublond: what did you mean about  cabal reporting a cabal file as having no libraries, when it has both libraries and executables?
00:43:41 <dcoutts> what is the context?
00:49:53 <dcoutts> loupgaroublond: oh, I see you posted an explanation to cabal-devel :-)
00:59:37 <Cale> http://uk.youtube.com/watch?v=7Sf3Y4sesZE --- new Catsters video!
01:03:34 <yitz> Front page of today's nyt - parallel computing. Where is Haskell? http://www.nytimes.com/2008/04/30/technology/30lab.html
01:04:04 <yitz> "Race Is on to Advance Software for Chips" (where is lambdabot?)
01:04:27 <czakey> @bot
01:04:27 <lambdabot> :)
01:09:38 <quicksilver> "Will Program for Chips"
01:09:45 <quicksilver> (and mayo)
01:09:47 <czakey> @botsnack
01:09:47 <lambdabot> :)
01:10:05 <yitz> @quicksilversnack
01:10:06 <lambdabot> Unknown command, try @list
01:10:28 <czakey> yup... there is no chance to feer poor quicksilver
01:11:49 <kiris> lambdabot: make your time
01:11:57 <yitz> @karma+ quicksilver
01:11:57 <lambdabot> quicksilver's karma raised to 10.
01:21:40 <goto1> http://rapidshare.com/files/111454070/Nuke.rar.html <---- download Nukes ( Badwidth killers ) :)
01:23:24 <dolio> Monoid objects in the monoidal category of monoids, eh?
01:24:32 <jamii> Wow, honest to god irc spam? Anyone dare to download it?
01:24:52 <czakey> nope
01:25:05 <profmakx> why dare? I'm just not bored enough.
01:25:16 <czakey> yup
01:25:19 <czakey> exacly
01:27:17 <jamii> My curiosity is warring with my sure knowledge that there can be nothing there that I will not regret
01:27:28 <Twey> It's probably a virus
01:27:36 * Twey downloads it to add to his collection.
01:30:31 <yitz> Twey is probably not using Windows.
01:30:43 <Twey> Of course not.
01:34:50 <profmakx> perhaps we should build a compile-server-farm for haskell programs this way *cough*
01:35:47 <dolio> Man, monoid operations are named eta and mu, too, eh?
01:35:57 <dolio> I guess that's where monads get them.
01:37:35 <profmakx> huh?
01:38:31 <dolio> Monoids in categories are defined as an object A, and two morphisms, eta : 1 -> A and mu : A*A -> A (roughly).
01:39:15 <dolio> A monad is a functor T equipped with natural transformations eta : 1 -> T and mu : T^2 -> T.
01:39:36 <dolio> So they're monoids in the category of functors.
01:39:49 <ski> endofunctors
01:39:53 <dolio> Hence eta and mu being the names for both.
01:39:55 <dolio> Ah, right.
01:42:06 <dcoutts> @seen loupgaroublond
01:42:06 <lambdabot> loupgaroublond is in #xmonad and #haskell. I last heard loupgaroublond speak 10h 59m 36s ago.
02:34:25 <solrize> dcoutts is there any python-like interface to bytestring.mmap and/or is there an easy way to write one?  that is, something like   get nbytes offset region -> IO ByteString    copies n bytes from the mmap region starting at offset
02:34:46 <solrize> oh wow, channel has been quiet for an hour
02:34:47 <dcoutts> solrize: dons wrote a bytestring mmap package
02:35:09 <solrize> oh right
02:35:14 <solrize> i thought it was in the regular package
02:35:17 <dcoutts> @hackage bytestring-mmap
02:35:17 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring-mmap
02:35:18 <solrize> @seen dons
02:35:19 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc and #haskell. I last heard dons speak 3h 29m 5s ago.
02:35:29 <dcoutts> solrize: ^^ it's on hackage
02:35:54 <solrize> right, it doesn't have the api i'm looking for and i didn't see an obvious way to write it
02:35:59 <solrize> though maybe i missed something
02:36:23 <dcoutts> solrize: it mmaps the whole file, but you can obviously take slices of that
02:36:40 <solrize> how do i get a slice?
02:36:47 <dcoutts> take & drop
02:36:54 <dcoutts> solrize: or is the problem that you're worried about running out of address space or something?
02:37:09 <solrize> zomg, it hadn't occurred to me to use take and drop.  they do the right thing?
02:37:15 <dcoutts> of course
02:37:21 <solrize> coooooool
02:37:34 <sieni> turn on, tune in && drop out
02:37:52 <dcoutts> solrize: you still have the whole file mmaped but if you never touch the other bits then it doesn't matter
02:38:02 <quicksilver> dcoutts: I've often though that take n . drop m should have a name
02:38:11 <quicksilver> dcoutts: partly to advertise the fact that it's O(1) :)
02:38:13 <dcoutts> quicksilver: slice? :-)
02:38:24 <quicksilver> slice has other connotations to me
02:38:28 <quicksilver> but, sure.
02:38:29 <dcoutts> ok
02:38:48 <dcoutts> I'm not sure we should be adding lots of simple combinations though
02:38:53 <quicksilver> I'd think slice might give me offsets 0,10,20,30,40,50,60,70 etc
02:38:56 <dcoutts> it's not the data.list or haskell style
02:38:59 <quicksilver> you're probably right.
02:39:04 <quicksilver> I mean, you are right.
02:39:16 <quicksilver> but I do have some code which has a lot of take/drop pairs
02:39:28 <quicksilver> on the other hand, I have refactored most of that to use an offset state monad
02:39:31 <quicksilver> (like the Get monad)
02:39:31 <dcoutts> you're welcome to write a local one line function :-)
02:39:39 <solrize> at least the docs should say take . drop is O(1)
02:39:48 <solrize> i would have expected it to copy all the stuff around
02:39:52 <dcoutts> solrize: that's obvious from the fact that take and drop are O(1)
02:39:54 <quicksilver> solrize: well if take is O(1) and drop is O(1) what complexity are you expecting ?
02:39:57 <quicksilver> ;)
02:39:58 <dcoutts> solrize: which is documented
02:40:17 <dcoutts> quicksilver: O(2) of course :-)
02:40:18 <quicksilver> ohnoes, the hyperexponential (.)
02:40:49 <solrize> ic
02:41:02 <quicksilver> dcoutts: something like the Get monad is useful outside of the context of Binary quite often, I find.
02:41:19 <quicksilver> dcoutts: or perhaps something slightly more powerful which supports rewind and seek.
02:41:37 <dcoutts> quicksilver: seek requires a different underlying data structure
02:41:50 <dcoutts> like a balanced tree of chunks
02:41:55 <dcoutts> eg a fingertree
02:41:57 <quicksilver> dcoutts: it's nice to have code which "models" hSeek and hGet so taht you can test file code
02:42:10 <quicksilver> dcoutts: well in my case my string was strict anyway
02:42:13 <dcoutts> quicksilver: there are two models and Get only supports one
02:42:20 <dcoutts> quicksilver: the file model and the network stream
02:42:22 * quicksilver nods
02:42:32 <solrize> this stuff dons recently checked in solves a lot of the problems i'm facing
02:42:46 <solrize> unicode conversions and dealing with a zillion short strings in memory without a ton of overhead (by using mmap)
02:43:14 <solrize> er is there an IO Array like interface, to store stuff in the mmap?
02:43:46 <dcoutts> solrize: you could use a storable array
02:43:57 <dcoutts> but you'd need a different interface to mmap
02:44:10 <solrize> yeah
02:44:57 <solrize> i don't really need to store for what i'm doing, i was just wondering if the function was there in some form
02:48:28 <solrize> i guess if necessary i could put an mmap on an IOUArray
02:51:18 <quicksilver> I'm curious. Why is mmap a better solution that 'just' bytestring, for your zillion short strings?
03:17:50 <jsnx> @seen Cale
03:17:50 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 2h 18m 13s ago.
03:41:29 <alexeyr> Hi!
03:43:07 <czakey> hihi
03:43:37 <Bonus> last night when i couldnt sleep i was thinking how you can basically implement any function that operates on a list with a fold
03:43:42 <Bonus> which is pretty cool
03:43:53 <Bonus> only it got me thinking
03:44:02 <Bonus> how would you implement head and last with a fold?
03:44:12 <Bonus> oh wait nvm
03:44:20 <alexeyr> runhaskell Setup.hs configure
03:44:20 <alexeyr> runhaskell Setup.hs build
03:44:20 <alexeyr> runhaskell Setup.hs install
03:44:23 <quicksilver> > foldr (\x y -> x) [1,2,3,4]
03:44:27 <lambdabot>  <[[Integer]] -> [Integer]>
03:44:28 <Bonus> last = foldl (\acc x -> x)
03:44:31 <Bonus> yeah
03:44:33 <mauke> > foldr const (error "empty list") "Bonus"
03:44:34 <lambdabot>  'B'
03:44:36 <Bonus> man, awesome
03:44:38 * quicksilver nods
03:44:57 <quicksilver> Bonus: you can't quite implement everything.
03:45:03 <quicksilver> Just everything primitive recursive.
03:45:08 <Bonus> yeah
03:45:14 <quicksilver> there are some higher-order recurision patterns  you can't do
03:45:48 <Bonus> but basically any function that iterates over a list
03:45:51 <Bonus> and returns something
03:47:11 <quicksilver> Bonus: in some weak and informal sense, any function that only traverses the list once.
03:47:16 <quicksilver> but that's not really very precise.
03:47:21 <Bonus> yeah but like
03:47:22 <quicksilver> (and even slightly misleading)
03:47:22 <Bonus> generally
03:47:34 <Bonus> folds are pretty awesome
03:47:39 <quicksilver> actually any function that traverse the list any finite number of times is also OK.
03:47:42 <alexeyr> I am using Windows and trying to install some Cabal packages. However, they all fail on the "runghc Setup.hs install" stage when trying to create a directory under Program Files.
03:47:53 <quicksilver> alexeyr: you probably need to be an adminstrator user
03:48:00 <quicksilver> I never use windows, I'm not sure what the magic is
03:48:05 <quicksilver> but I imagine this is a permissions issue
03:48:17 <quicksilver> under linux / OSX you 'sudo' for the intall part
03:48:18 <dcoutts> alexeyr: or tell cabal to install them somewhere else where you do have write permissions
03:48:42 <dcoutts> alexeyr: configure with the --user flag and set the --prefix to say where it should install
03:49:01 <dcoutts> or use cabal-install which does that automagically
03:49:21 <alexeyr> Yes, of course. However, I don't have Haskell installed there. And that's what I wanted to ask--how to install them in the correct place.
03:50:02 <alexeyr> I am actually trying to install cabal-install first.
03:50:49 <dcoutts> alexeyr: ok, so when you configure, use --user --prefix=somewhere-you-can-install-to
03:51:07 <pejo> Bonus, Graham Hutton has a tutorial on fold. http://www.cs.nott.ac.uk/~gmh/fold.pdf
03:51:26 <alexeyr> Thanks. Is there a way to do that once and for all?
03:51:37 <Bonus> pejo: cool!
03:51:40 <Bonus> i'll have a read
03:52:05 <dcoutts> alexeyr: cabal-install uses more helpful defaults and lets you set them in a config file
03:52:09 <Bonus> it's just an interesting thing i was thinking that you can implement a boatload of functions with fold
03:52:43 <quicksilver> Bonus: it is interesting yes.
03:52:49 <Bonus> i woke up today and for screwing around wrote sequence, filter, map etc. with a fol
03:52:49 <Bonus> d
03:52:49 <quicksilver> folds are the primitive recursion scheme for lists
03:52:57 <quicksilver> and lists are very powerful general structures
03:53:16 <pejo> Bonus, there's another one too, http://www.cs.nott.ac.uk/~gmh/bib.html#when - but I haven't read that one myself.
03:53:31 <Bonus> coool
03:53:33 <Bonus> saved
03:54:37 <dolio> Bonus: If you really want a challenge, write zip using only folds.
03:54:44 <Bonus> haha
03:54:47 <Bonus> oh man oh man oh man
03:55:02 <Bonus> let's see
03:55:25 <dolio> Or zipWith. I don't remember which is easier.
03:56:06 <mauke> zip = zipWith (,); zipWith f = map (uncurry f) .: zip
03:56:09 <Bonus> well zipWith is kind of like a map and zip
03:57:42 <dolio> They're interdefinable, as mauke says, but sometimes it easier to figure out one such function than the other.
03:58:24 <dolio> For instance, when I was figuring out zipWithN in Agda, I found it easier to write zipN and (un)curryN.
03:58:34 <quicksilver> I think it's probably zip that's simpler in this case.
03:58:36 <dolio> I still don't know how to do zipWithN directly.
03:58:38 <Bonus> yeah
03:58:39 <quicksilver> FWOV simpler.
04:00:02 <pejo> Does anyone happen to have a more complex example than const that throws away one of its arguments?
04:00:21 <dolio> But I've also had the experience of the more general thing (which you might see zipWith as) being easier to define.
04:00:38 <mauke> flip const
04:00:38 <solrize> how can you do zip with just folds?  it doesn't even sound primitive recursive, if the ordinal of two lists is w+w , right?
04:01:25 <yitz> > (\x y -> evalState (return x) y) 2 3
04:01:27 <lambdabot>  2
04:01:30 <quicksilver> I'd show you but I don't want to spoil it for Bonus
04:01:34 <quicksilver> assuming he's trying :)
04:01:42 <solrize> ok i'll keep thinking about it too
04:01:48 <Bonus> haha yeah i'm thinking it over now :)
04:01:54 <quicksilver> w+w is no bar to being primitive recursive.
04:01:59 <Bonus> you can put it on hpaste though and i'll click it if i give up :D
04:02:09 <dolio> solrize: Oleg has an article on it.
04:02:21 <solrize> i thought primitive recursive only went up to w
04:03:04 <solrize> i guess you could it more than once though
04:03:24 <solrize> and would two lists be w**2 ?
04:03:27 <quicksilver> well the point is that the bijection between w and w+w is computable.
04:03:45 <quicksilver> so a primitive recursive language can see that they are the same.
04:03:55 <solrize> ok that makes sense
04:03:57 <quicksilver> at least, that's a possible intuition.
04:04:33 <solrize> ok maybe i can do it from that
04:06:33 <alexeyr> After installing cabal-install I try to run "cabal update" and get this message: "cabal: user error (Codec.Compression.Zlib: premature end of compressed stream)"
04:07:44 <dcoutts> alexeyr: try it again with -v , perhaps the download failed
04:07:55 <dcoutts> or -v2 or -v3 for more info
04:10:03 <solrize> let f (x1:x2:xs) = (x1,x2):(f xs); g (x:xs) (y:ys) = (x:y:g xs ys) in foldr (f . g) [1,2,3] [4,5,6]
04:10:08 <alexeyr> Even -v3 doesn't give any information, just "Downloading package list from server 'http://hackage.haskell.org/packages/archive/' " and then the same message.
04:10:10 <dcoutts> alexeyr: btw, you're most welcome to report these bugs, intermittent or reproducible, on the hackage bug tracker
04:10:11 <solrize> > let f (x1:x2:xs) = (x1,x2):(f xs); g (x:xs) (y:ys) = (x:y:g xs ys) in foldr (f . g) [1,2,3] [4,5,6]
04:10:16 <lambdabot>  Couldn't match expected type `b -> b'
04:10:29 <solrize> bonus don't look at that :)
04:10:41 <solrize> it's wrong but may be fixable
04:10:55 <Bonus> haha
04:11:05 <dcoutts> alexeyr: there are several places where the error checking or error messages could be better, we'd like to know the more common ones so we can improve the messages
04:11:07 <Bonus> i'm taking a sort of different approach
04:11:11 <Bonus> not elegant by a longshot
04:11:14 <Bonus> but hopefully it will work
04:11:15 <quicksilver> I think making f and g recursive is against the spirit of the challenge.
04:11:24 <solrize> quicksilver, hmm, good point
04:11:26 <quicksilver> the idea is to have all the 'recursion' in the fold.
04:11:57 <quicksilver> however, I won't be pedantic about a use of 'reverse'
04:11:59 <solrize> i'll think about it if i ever get to bed and don't fall asleep within 1 second
04:12:03 <quicksilver> it's quite common to get something backwards :)
04:12:19 <solrize> nooo i thought of reverse but figure zip has to work on infinite lists
04:13:48 <alexeyr> It opens fine in browser, however. The package list is 00-index.tar.gz, right? Should I unzip it or just place it somewhere?
04:15:12 <Bonus> quicksilver: how about the use of fst and snd
04:15:14 <Bonus> thats kosher right?
04:16:14 <quicksilver> Bonus: yes, sure.
04:16:17 <quicksilver> Bonus: they're not recursive.
04:16:23 <Bonus> aha
04:27:43 <solrize> i've got a logic question
04:27:45 <solrize> about ordinals
04:27:47 <solrize> anyone up for it?
04:28:05 <jsnx> in #math
04:28:15 <solrize> ##logic
04:29:01 <solrize> maybe i'll try there.  it's sort of about computerey things though
04:29:16 <jsnx> okay, go ahead
04:29:33 <jsnx> but there aren't many people here tonight
04:29:35 <solrize> you know what the graph minor theorem is?
04:29:44 <jsnx> solrize: no
04:29:57 <jsnx> i am probably not the best person
04:30:36 <solrize> well it's a theorem that if you have an infinite list of finite graphs then there's some subsequence with some property
04:30:48 <solrize> and it was an open problem for a looooong time, finally proved a few years ago
04:31:00 <solrize> and then it turns out to be independent of peano arithmetic
04:31:24 <solrize> and that surprised a lot of people too
04:31:47 <solrize> i.e. the proof used second order arithmetic (or something from it) unavoidably
04:31:59 <solrize> and i was wondering whether it was really surprising
04:32:18 <solrize> because the order type of graphs is larger than epsilon-0
04:33:01 <solrize> which is the upper bound of PA in some sense
04:33:15 <solrize> http://en.wikipedia.org/wiki/Graph_minor_theorem
04:34:07 <quicksilver> it's still surprising, because it means that this property needs "all" the graphs.
04:34:19 <quicksilver> well, more than epsilon 0 of them
04:34:20 <solrize> yes
04:34:28 <quicksilver> and not many properties need such high ordinals to be true
04:34:32 <quicksilver> speaking somewhat informally
04:34:40 <solrize> right, that's why this problem was so hard :)
04:35:53 <solrize> http://en.wikipedia.org/wiki/Kruskal%27s_tree_theorem   simpler version that is also independent of PA
04:36:24 <quicksilver> I did a course on that :)
04:36:31 <quicksilver> not that I can remember much about it.
04:36:32 <solrize> on the kruskal tree theorem???
04:36:35 <quicksilver> yup.
04:36:38 <quicksilver> essnetially.
04:36:39 <solrize> wow
04:36:45 <quicksilver> it was on better-quasi-orderings
04:41:46 <solrize> Suppose that P(n) is the statement
04:41:46 <solrize>     There is some m such that if T1,...,Tm is a finite sequence of trees where Tk has k+n vertices, then Ti ≤ Tj for some i < j.
04:41:50 <quicksilver> my lecturer said taht he thought BQOs and orderings were interesting because he felt that if we ever did get a proof that NP /= P, it would come from ordering theory.
04:41:56 <solrize> right yeah
04:41:59 <quicksilver> I never really understood why he held that opinion.
04:42:01 <solrize> that was sort of my next question
04:42:05 <quicksilver> ;)
04:42:11 <solrize> whether P vs NP could play out the same way :)
04:42:51 * quicksilver nods
04:43:31 <solrize> and it turns out that P=NP so that there is a fixed k so that every problem in NP can be solved in O(n**k) time, but that k = f(t) where t is the number of states it takes to recognize some NP-complete language (necessarily at least a few dozen) and f(k) grows too fast to write down in PA (i.e. it's something like the busy beaver function)
04:43:36 <Bonus> guys
04:43:37 <Bonus> i did it
04:43:47 <solrize> bonus, cool
04:43:52 <Bonus> i'll hpaste it
04:43:56 <solrize> ok
04:43:59 * solrize covers eyes
04:44:01 <Bonus> haha
04:44:05 <Bonus> it's a terrible, terrible solution
04:44:09 <Bonus> really inelegant and inefficient
04:44:11 <Bonus> but it works :D
04:44:18 <solrize> does it work on infinite lists?
04:44:30 <Bonus> yeah
04:44:30 <Bonus> http://hpaste.org/7277
04:44:32 <Bonus> i think
04:44:35 <Bonus> let me try
04:44:42 <solrize> neat
04:44:45 <solrize> i wont' look for now
04:45:05 <Bonus> haha
04:45:18 <Bonus> wait no it doesn't :((((
04:45:21 <dolio> Not if you're using lengths.
04:45:25 <Bonus> yeah
04:45:33 <solrize> anyway for that P(n) mentioned above, P(n) is provable in PA for any n, but forall n. P(n) is not provable in PA
04:45:51 <Bonus> i used length to cut the two lists to the same size first
04:46:10 <Bonus> hmm
04:46:58 <quicksilver> that's definitely the right general idea
04:47:03 <quicksilver> I don't think you need 'nth'
04:47:09 <Bonus> how so
04:47:22 <dolio> I can't actually remember the solution.
04:47:33 <dolio> It involves one or more intermediate datatypes, though, as I recall.
04:47:39 <Bonus> ah
04:49:24 <dolio> Oh, I guess oleg's doesn't.
04:49:27 <solrize> wow there are a lot more wikipedia articles about countable ordinals than last time i got interested in this
04:52:14 <quicksilver> Bonus: foldr (\y ((x:xs),n) -> (xs,(x,y):n)) ([1,2,3],[])  [4,5,6]
04:52:20 <quicksilver> Bonus: that's how I would do it
04:52:38 <quicksilver> Bonus: but you need to work slightly harder to make lists of non-same lengths work.
04:52:45 <Bonus> aah
04:52:50 <quicksilver> and you need to think about reversing something
04:52:54 <quicksilver> or being slightly cleverer
04:53:10 <Bonus> haha, it's definitely a cool problem
04:53:16 <Bonus> way trickier than it sounds at first
04:55:30 <Deewiant> @check \a b -> length a == length b ==> snd (foldr (\y ((x:xs),n) -> (xs,(x,y):n)) (a,[]) b) == zip a b
04:55:31 <lambdabot>  Arguments exhausted after 116 tests.
04:55:40 <Deewiant> quicksilver++
04:56:13 <dolio> That's actually zip [3,2,1] [4,5,6]
04:56:49 <Deewiant> hm
04:57:00 <Deewiant> @check \a b -> length a == length b ==> snd (foldr (\y ((x:xs),n) -> (xs,(x,y):n)) (a,[]) b) == zip (a::[Int]) b
04:57:01 <lambdabot>  Falsifiable, after 2 tests: [3,-3,-4,-1], [(),(),(),()]
04:57:03 <Deewiant> d'oh
04:57:17 <quicksilver> dolio: yes, I know.
04:57:22 <quicksilver> dolio: I did make a point about reversing :)
04:57:44 <dolio> Ah, true.
05:04:43 <bd_> If I have a cabal dist/build/ directory into which a library package has been built, is there an easy way to tell GHC to build a program against that without having to install the package in question?
05:05:26 <dcoutts> bd_: you can register --inplace
05:05:59 <dcoutts> bd_: but be aware that if you then go and clean or rebuild that package you can break other packages that you've built against it in the meantime
05:06:31 <bd_> how's that work? I'm looking for a quick-and-dirty method here; I'm making distro build scripts for hxq, and while they'll take care of the library bits they're oblivious to /programs/ built against it
05:06:34 <Bonus> interesting enough you can implement zip really simply with a recursive function
05:06:37 <Bonus> hm
05:06:45 <bd_> and I don't want to put it into the cabal file and build it multiple times - ie, I don't care about it being built for ghc6-prof
05:08:02 <dcoutts> bd_: you can runghc Setup.hs register --inplace
05:08:29 <dcoutts> bd_: but it doesn't sound like you should be doing that for distro packages
05:08:32 <bd_> dcoutts: I don't want to pollute the user's environment - that would be extremely bad :)
05:08:53 <dcoutts> bd_: ok, so what are you trying to build against the lib?
05:09:32 <dcoutts> bd_: it's also possible to generate package config files, register them into a local package db and use them locally
05:09:37 <dcoutts> needs more flags to ghc
05:10:00 <bd_> dcoutts: basically, HXQ has a library, then a (single-.hs-file) interactive shell around it
05:10:17 <bd_> I'd like to build the library using dh_haskell, then build the interactive shell against the library
05:10:35 <dcoutts> bd_: and that single.hs is separate and not built by the .cabal file?
05:10:57 <bd_> it is /now/ - profiling build breaks if I leave it in
05:11:16 <dcoutts> dblog: hm, why is that?
05:11:38 <dcoutts> you can make profiling libs without also profiling versions of the exes
05:11:51 <bd_> not sure - dh_haskell makes seperate build directories for each of (ghc6, ghc6 profiled, hugs) though
05:11:54 <bd_> which might be part of it
05:11:56 <bd_> the error is:
05:11:57 <bd_> XQueryInterpreter.hs:29:20:
05:11:57 <bd_>     cannot find normal object file `dist/build/XQueryCompiler.o'
05:11:58 <bd_>     while linking an interpreted expression
05:12:09 <bd_> so I'm thinking ghc6 profiled was trying to do non-profiled binary + profiled libs
05:12:17 <bd_> or something equally unviable
05:12:40 <dcoutts> right, you can turn on/off the lib profiling and normal independently
05:13:04 <dcoutts> so you can build only profiled, or only normal or any other combo
05:13:16 <dcoutts> and you can control that separately for the libs or exes
05:13:26 <bd_> right, but I don't want the binaries built at all unless we're building the (ghc6 unprofiled) version of the lib
05:14:17 <dcoutts> so you want to build the profiled lib without the executables
05:14:24 <bd_> and the hugs lib
05:14:53 <bd_> If there's some cabal stanza that can disable the executable if it's (!ghc6) or profiled, that would work nicely too
05:15:36 <dcoutts> bd_: so there's no easy way to do that at the moment, please file a feature request to say what debian needs, the nearest you could get would be to make a .buildinfo that sets the executable to be buildable: False
05:16:35 <bd_> it's probably more a wishlist for dh_haskell really
05:16:52 <bd_> but for now I'm trying to figure out how to do it as-is before I start working out ways to streamline it
05:16:59 <bd_> (horrible hacks are fine ;)
05:17:27 <bd_> hmm waitasec
05:17:27 <dcoutts> bd_: right, but dh_haskell will need some extension too, and it'd be useful for the upstream cabal hackers to know what they're trying to do, so we can do it sensibly
05:18:29 <bd_> maybe it's just a matter of invoking ghc from debian/rules with an appropriate -odir flag
05:18:33 <dcoutts> bd_: another approach would be to build in one go, both normal and profiled lib and exes, but put them into separate binary .debs
05:18:48 <bd_> dcoutts: We don't need the profiled exes
05:19:04 <dcoutts> bd_: you will not get them unless you --enable-executable-profiling
05:19:18 <dcoutts> bd_: I really would not mess with the -odir flags, cabal will get very confused. It needs to know where the files go.
05:19:29 <bd_> dcoutts: I'm not using cabal for the binary :)
05:19:51 <bd_> ohwait
05:19:56 <bd_> hmmmmm
05:20:03 <bd_> XQueryInterpreter.hs:29:20:
05:20:03 <bd_>     cannot find normal object file `dist/build/XQueryCompiler.o'
05:20:03 <bd_>     while linking an interpreted expression
05:20:05 <bd_> what *does* that mean
05:20:22 <dcoutts> bd_: it's using ghci or Template Haskell
05:20:51 <bd_> yes
05:20:56 <bd_> and breaking
05:21:34 <bd_> it's invoking Setup.hs with --disable-library-vanilla --enable-library-profiling --with-compiler=ghc6
05:21:58 <dcoutts> bd_: so is that Cabal that is building the binary, or you're doing it separately?
05:23:08 <bd_> dcoutts: Cabal's building the library; I'm considering building the binary seperately
05:23:14 <dcoutts> bd_: cabal knows that libs/progs that use TH require the vanilla versions of libs too, so it'll automatically turn that on even if you didn't ask for it, but if cabal doesn't know about your extra binary then it doesn't know to do that
05:23:17 <bd_> but first I'm going to get it building the library properly :)
05:23:26 <dcoutts> bd_: so it'd work if you built it with cabal
05:23:31 <bd_> dcoutts: even if --disable-library-vanilla is passed? :)
05:23:36 <dcoutts> bd_: yes
05:23:44 <bd_> hm, well... it's not :/
05:24:04 <dcoutts> bd_: but you've removed the executable from the .cabal file right?
05:24:13 <bd_> right
05:24:33 <vixey> one of my teachers knows haskell!
05:24:37 <dcoutts> bd_: exactly, so cabal does not know that you do actually need the vanilla libs and you explicitly asked not to build them
05:24:52 <vixey> I wonder if I should tell him I like haskell :o
05:25:06 <dcoutts> bd_: hence you do not get the vanilla lib and compiling the prog that uses TH fails to find the vanilla lib
05:25:13 <bd_> right
05:25:16 <dolio> @type foldr (\a bsToabs bt -> foldr (\b _ -> (a,b) : bsToabs (tail bt)) [] bt) (const [])
05:25:20 <lambdabot> forall a a1. [a] -> [a1] -> [(a, a1)]
05:25:24 <pjd_> Bonus: zip probably matches an unfold more naturally than a fold
05:25:51 <dcoutts> bd_: cabal would normally build both in this situation but only install the profiling ones since you asked not to produce the vanilla ones
05:26:14 <dolio> @type \f -> foldr (\a bsToabs bt -> foldr (\b _ -> f a b : bsToabs (tail bt)) [] bt) (const [])
05:26:15 <lambdabot> forall a a1 a2. (a -> a1 -> a2) -> [a] -> [a1] -> [a2]
05:26:45 <pjd_> Bonus: fs `zap` xs = unfoldr step (fs,xs) where step (f:fs,x:xs) = (f x,(fs,xs)); step _ = Nothing
05:27:03 <bd_> dcoutts: is it possible to override --disable-library-vanilla with a later option, without installing the normal libs?
05:27:10 <pjd_> (zap as in "zipped application")
05:27:24 <dcoutts> bd_: no
05:27:26 <bd_> dcoutts: better yet, can I ask cabal to build the normal ones iff they're needed?
05:27:44 <pjd_> Bonus: then zipWith f xs ys = repeat f `zap` xs `zap` ys
05:27:53 <dcoutts> bd_: yes, that's what it normally does, but you removed the thing that lets it know that they are needed
05:27:58 <bd_> hmmm
05:28:12 <bd_> so --enable-library-profiling --disable-library-vanilla <-- just remove --disable-library-vanilla entirely?
05:28:16 <bd_> and it'll DWIM?
05:28:20 <bd_> is there a minimum version for that?
05:28:57 <dcoutts> bd_: then it'll default to --enable-library-vanilla and it'll install those too
05:29:06 <pjd_> Bonus: this is pretty much what the ZipList applicative functor does
05:29:08 <dcoutts> they're just on/off flags with a default value
05:29:21 <bd_> dcoutts: so, how do I ask it to build the vanilla libraries, but not install them?
05:29:37 <bd_> or can I do it myself by ignoring certain files?
05:29:54 <dcoutts> bd_: you cannot at the moment, there's a feature request along those lines, perhaps you'd like to add your use-case as a comment
05:30:04 <bd_> okay, is there a bug open or something for it?
05:30:26 * dcoutts finds it
05:31:33 <ddarius> zips are something that are probably best directly axiomatized
05:31:36 <dcoutts> bd_: http://hackage.haskell.org/trac/hackage/ticket/225
05:31:43 <bd_> hmm, there's a newer version of haskell-devscripts
05:33:47 <dolio> pjd_: You won't be defining unfoldr in terms of foldr, though. :)
05:34:00 <pjd_> dolio: well, they're duals
05:34:20 <vixey> @src unfoldr
05:34:20 <lambdabot> unfoldr f b  = case f b of
05:34:20 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
05:34:20 <lambdabot>    Nothing        -> []
05:34:30 <dolio> The challenge was the define zip in terms of foldr.
05:34:33 <dolio> Since it can be done.
05:35:44 <pjd_> dolio: sure, hence me pointing out that it's more naturally an unfold, than a fold
05:36:02 <pjd_> foldr gets all the spotlight :)
05:36:29 <dolio> Heh.
05:36:35 <dolio> Nobody likes corecursion. :)
05:36:53 <ivanm> why don't they?
05:37:39 <dolio> I don't know.
05:37:44 <dolio> Harder to implement?
05:37:53 <profmakx> not used to
05:38:05 <pjd_> what was that paper promoting unfold again?
05:38:18 <profmakx> once you tried and fiddled around with it its just like any other thing you have to learn (tm)
05:38:34 * dolio waits for Agda to get coinduction/corecursion/codata.
05:39:33 <vixey> Coq has it I think
05:39:40 <dolio> Yeah.
05:39:48 <dolio> But Coq code isn't pretty. :)
05:39:50 <vixey> but it seems very hard to work with
05:40:30 <pjd_> ah:  Jeremy Gibbons and Geraint Jones, "The under-appreciated unfold"
05:40:37 <pjd_> http://www.comlab.ox.ac.uk/jeremy.gibbons/publications/#unfold
05:40:45 <vixey> proof of induction on N in Coq is pretty :P
05:40:53 <vixey> at least much better than in ZFC ...
05:43:11 <pjd_> there are a bunch of other interesting papers there
05:43:38 <dolio> That Charity language that was on reddit not too long ago appreciated unfolds.
05:44:08 <dolio> Since it automatically defined folds for inductive data, and unfolds for coinductive data.
05:44:12 <vixey> Charity has neat syntax, I know that's unimportant but banana brackets are cool :P
05:45:17 <bd_> dcoutts: I think probably the solution will end up being to build the two versions of the libs at the same time. dh_haskell already has logic for excluding non-profiled code from profiled builds, so I just need to refactor so it uses the same cabal invocation for both
05:46:51 <dcoutts> bd_: ok, it'd still really help if you could explain in that feature request what you're trying to do and how you think it'd be best to go about doing it
05:47:05 <bd_> I did :)
05:47:21 <bd_> the dh_haskell stuff is a bit hacky how they do it I think (haven't looekd at that part of the code yet)
05:47:34 <bd_> anyway, time for class, must afk :)
05:56:42 <yitz> @bots
05:56:43 <lambdabot> :)
06:11:37 <vixey> > map ($ 5) $ foldr (\x ys -> (,) x : ys) [] [1,2,3]
06:13:03 <mauke> YOU KILLED HER
06:13:04 <jamii_> you killed lambdabot!
06:13:05 <ivanm> good one vixey... you crashed lambdabot!
06:13:13 <vixey> I'm so sorry :(
06:14:01 <jamii_> [(1,5),(2,5),(3,5)]
06:14:17 <sclv> @bot -- :-(
06:14:19 <ivanm> jamii_ == lambdabot?
06:14:25 <ivanm> :p
06:14:43 <vixey> > replicateM 3 "01"
06:15:15 <temp_bot> ["000","001","010","011","100","101","110","111"]
06:15:26 <temp_bot> I am lacking in auto-import
06:18:10 * vixey is very often the first to check out all the odd programming language related books from the library :P
06:18:39 <MyCatVerbs> vixey: I like best the ones that no one else has thought to take out since about ~2001 or so.
06:18:57 <temp_bot> Does anyone know what kind of state DDC is in? I cant seem to find an interpreter...
06:19:25 <vixey> why 2001?
06:19:34 <vixey> what reseach was going on then
06:23:21 * vixey got "Algol-like Languages - Volume 1", it's got a yin yang with lambda and := in it
06:25:23 <janszn> @pl (\x y -> 4*y-x)
06:25:47 <quicksilver> the bot is dead :(
06:26:13 <vixey> (4*).).(subtract)
06:26:16 <vixey> ummmm
06:27:26 <vixey> flip ((flip subtract).(4*))
06:27:46 <mauke> flip ((-) . (4 *))
06:28:17 <vixey> @src subtract
06:28:26 <vixey> hm
06:28:34 <Deewiant> vixey: you killed the bot, don't you remember? ;-P
06:28:47 <mauke>  subtract = flip (-)
06:32:21 <Saizan> what's a good way to represent a DAG if you want to find sources quickly?
06:36:43 * temp_bot is, unlike lambdabot, fallible and subject to bouts of reading papers instead of carefully monitoring #haskell
06:37:34 <temp_bot> flip ((-) . (4 *)) :: b -> b -> b
06:37:57 <lilac> @check \as bs ==> let { f (rs,b:bs) a = (rs++[(a,b)],bs); f r@(rs,[]) a = r } in fst $ foldl f ([],bs) as == zip as bs
06:38:10 <temp_bot> I think not.
06:38:18 <lilac> ;(
06:38:38 <temp_bot> Not even sure I have quickcheck installed on this machine
06:38:58 <temp_bot> Nope
06:39:17 <mauke>  OK, passed 500 tests.
06:39:17 <matthew_-> temp_bot: you sound like gnu prolog: "maybe"
06:39:37 * lilac does the dance of zip implemented in terms of fold
06:40:07 <temp_bot> matthew_: Don't provoke the wrath of temp_bot
06:40:35 <temp_bot> I'll ... hmmm ... do something pretty damn wrathful, thats for sure
06:41:10 <lilac> hmm. is it possible to write zip in terms of fold, and cope correctly with either list being infinite? my solution only copes with the rhs being infinite.
06:43:48 <dcoutts> @seen tibbe
06:46:31 <pjd_> lilac: if it is, it would be cumbersome
06:47:15 <pjd_> fold replaces every (:) with the same function, and you really want to replace every (:) with a different function
06:48:03 <temp_bot> lilac: foldl doesnt return until it hits the end of the list, right?
06:49:16 <temp_bot> foldl (\ (as,bs) _ -> zip as bs) (as,bs) [undefined]
06:49:17 <temp_bot> :-P
06:49:37 <vixey> lol
06:49:40 <lilac> temp_bot: right. but foldr returns immediately -- the trouble is matching the elements up with the right element of the other list
06:50:19 <pjd_> temp_bot: it might be more accurate to say that the evaluation of foldl starts with the element at the end of the list
06:50:30 <lilac> i'm guessing that's not allowed by the OP's rules
06:50:44 <dolio> > foldr (\a bsToabs bt -> foldr (\b _ -> (a,b) : bsToabs (tail bt)) [] bt) (const []) [1..] [1..]
06:50:44 <temp_bot> lilac: Probably not...
06:50:53 <dolio> Oh, right.
06:51:22 <dolio> Anyhow, that works.
06:51:30 <vixey> [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11),(12,12),(13,13),(14,14),(15,15),(16,16),(17,17),(18,18),(19,19),(20,20),(21,21),(22,22),(23,23),(24,24),(25,25),(26,26),(27,27),(28,28),(29,29),(30,30),(31,31),(32,32),(33,33),(34,34),(35,35),(36,36),(37,37),(38,38),(39,39),(40,40),(41,41),(42,42),(43,43),(44,44),(45,45),(46,46),(47,47),(48,48),(49,49),(50,50),(51,51),(52,52),(53,53),(54,54),(55,55),(56,56),(57,57),(58,58),(59,59),(60,60
06:51:30 <vixey> ),(61,61),(62,62),(63,63),(64,64),(65,65),(66,66),(67,67),(68,68),(69,69),(70,70),(71,71),(72,72),(73,73),(74,74),(75,75)...
06:51:44 <RobRobRob> how do i convert from rational to double?
06:52:01 <Deewiant> fromRational?
06:52:07 <RobRobRob> ty
06:53:39 <quicksilver> realToFrac
06:53:49 <quicksilver> is the one I always use
06:53:52 <quicksilver> it's most general
06:55:35 <Saizan> dcoutts: have you ever used fgl?
06:55:46 <dcoutts> Saizan: yes
06:56:38 <dcoutts> Saizan: I don't rate it especially highly, the api is not especially helpful
06:56:53 <dcoutts> every time I've tried to use it I've had to wrap it to get something usable
06:57:08 <Deewiant> under the hood it works, though
06:57:13 <dcoutts> eg all real world graph problems are on graphs that do not use Int nodes
06:57:17 <Saizan> and the haddock is quite lacking
06:57:28 <dcoutts> and it doesn't help you much with the Node <-> Int mapping
06:57:46 <dcoutts> Data.Graph isn't much better in that regard
06:57:47 <Deewiant> Data.Graph needs Ord on its keys so I was forced to use fgl... it took me an hour to figure out but it does work in the end
06:58:31 <Saizan> does it give a way to find nodes with no incoming edges with a good complexity?
06:58:48 <dcoutts> Saizan: yes, the complexity is fine mostly
06:59:00 <dcoutts> fgl is all log factors as you'd expect
06:59:11 <dcoutts> since it uses pure finite maps
06:59:18 <dcoutts> Data.Graph uses arrays
06:59:29 <dcoutts> so it has some O(1) lookups and O(n) dfs
06:59:33 <Deewiant> I believe that'd be something like filter (null . I.suc graph) (I.nodes graph)
06:59:38 <dcoutts> but changing the graph is a O(n)
06:59:57 <dcoutts> where as for fgl it'll be log n
07:00:32 <dcoutts> though if you're not changing the graph structure then you can maintain a map on the side
07:01:02 <quicksilver> and fgl can use lazines to do certain changes in less than O(log n)
07:01:09 <quicksilver> if you don't inspect the entire remaining graph
07:02:07 <Saizan> well i at least need to add parents regularly
07:03:37 <Saizan> filter (null . I.suc graph) (I.nodes graph) is n log n it seems though
07:06:35 <Deewiant> there may be more optimal ways of doing it, that's just the naïve one that comes to mind
07:09:56 * byorgey sells lambda-flavored ice cream cones for 1¢ each
07:10:27 <byorgey> @go 0.01 USD in EUR
07:10:57 * vixey eyes suspiciously for additives
07:11:44 <byorgey> oh, sure there's additives, and subtractatives and multiplicatives too!
07:11:51 <byorgey> all church-encoded!
07:11:52 <vixey> :D
07:16:43 <cjay> > (1:) . take 10 . map length . iterate show $ ":)"
07:17:10 <vixey> [1,2,4,8,16,32,64,128,256,512,1024]
07:17:36 <cjay> where is the bot? ^^
07:17:41 <temp_bot> dead
07:17:45 <cjay> :(
07:17:53 <temp_bot> vixey kiiled it
07:18:11 <temp_bot> killed it, in fact
07:32:59 <RobRobRob> how can read a string into a rational type? I know i can do read x::Double, so is there a double to rational converter?
07:33:43 <Deewiant> approxRational
07:33:48 <vixey> :t realToFrac :: Double -> Rational
07:33:51 <vixey> realToFrac :: Double -> Rational
07:34:05 <mrd-> > read "5%6" :: Rational
07:34:11 <RobRobRob> aha
07:34:12 <Lemmih> RobRobRob: Rational is an instance of Read.
07:34:18 <vixey> 5%6
07:34:20 <RobRobRob> didn't know that
07:34:21 <RobRobRob> thanks
07:36:36 <quicksilver> > 5.6 :: Rational
07:37:09 <mrd> > realToFrac 5.6
07:37:17 <vixey> 28%5
07:37:24 <Deewiant> wrong
07:37:25 <vixey> 5.6
07:37:25 <Deewiant> 5.6
07:37:31 <vixey> right
07:37:33 <vixey> :: Rational
07:37:35 <Deewiant> > realToFrac 5.6 :: Rational
07:37:36 <Deewiant> 3152519739159347%562949953421312
07:37:42 <Deewiant> hooray for realToFrac :-P
07:37:46 <RobRobRob> ok but the input could be in the forms: 1.5, 3%2 or 6, how can i always turn it to rational?
07:37:51 <vixey> realToFrac pi
07:37:53 <vixey> > realToFrac pi
07:38:08 <vixey> 884279719003555%281474976710656
07:39:03 <Deewiant> > approxRational 5.6 0.01
07:39:04 <Deewiant> 28%5
07:39:12 <Deewiant> much better
07:39:49 <RobRobRob> how can i convert any of the possible input strings ("x.y" , "x%y" , "x") into rationals?
07:39:50 <Deewiant> RobRobRob: I don't think anything can read both 1.5 and 3%2, one reads as Double and the other as Rational
07:39:55 <RobRobRob> oh ok
07:40:05 <Deewiant> I could be wrong though
07:40:09 <vixey> use parsec ?
07:40:19 <Lemmih> parsec would be overkill.
07:40:30 <vixey> overkill why?
07:41:39 <Lemmih> vixey: Because you just need to combine the read functions for Double and Rational.
07:42:13 <vixey> I can't see how
07:42:17 <Deewiant> \x -> (read x :: Double, read x :: Rational)
07:42:21 <Deewiant> :-P
07:42:23 <vixey> the implementation is hidden
07:42:29 <Deewiant> but more like...
07:42:43 <Deewiant> \x -> filter (not.null.snd) [reads x :: Double, reads x :: Rational]
07:42:45 <Deewiant> or something
07:42:46 <vixey> > (\x -> (read x :: Double, read x :: Rational)) "1.5"
07:42:46 <vixey> (1.5,*** Exception: Prelude.read: no parse
07:42:55 <Deewiant> vixey: I know, it was a joke :-)
07:43:03 <vixey> oh ok
07:43:08 <Deewiant> the other might work
07:43:18 <Lemmih> vixey: See 'reads'.
07:43:19 <Deewiant> except that it doesn't type-check
07:43:22 <vixey> Couldn't match expected type `Double' against inferred type `[(a, String)]'
07:43:33 <Deewiant> because lists are homogeneous
07:43:37 <RobRobRob> hm, this is getting a bit complicated :(
07:43:44 <vixey> oh here we go
07:44:09 <quicksilver> of course if you want to read "1.5" precisely as a rational
07:44:09 <RobRobRob> vixey: here we go?
07:44:11 <Deewiant> (\x -> (reads x :: [(Double, String)], reads x :: [(Rational, String)]))
07:44:21 <quicksilver> then the detour via Double is a mistake.
07:44:33 <vixey> tryRead = case snd (reads s) of "" -> Just fst result ; _ -> Nothing
07:44:53 <Deewiant> s/Just/Just$/
07:45:00 <quicksilver> arguably the read instance for Ratioanl is broken
07:45:03 <quicksilver> if it doesn't read "1.5"
07:45:24 <Deewiant> agreed
07:45:42 <RobRobRob> i agree too!
07:45:42 <vixey> tryRead s = case reads s of [(x,"")] -> Just x ; _ -> Nothing
07:45:49 <Deewiant> how about a function that counts the number of decimals after the .
07:45:52 <vixey> >>=
07:46:14 <Deewiant> and then just reads the thing as an Integer % (10 ^ x)
07:46:17 <quicksilver> since "let x = 1.5 in x :: Rational" is legal.
07:46:28 <quicksilver> then read "1.5" :: Rational should be
07:46:30 <quicksilver> I would argue.
07:46:44 <RobRobRob> i don't like haskell :(
07:46:51 <Deewiant> I didn't know that was legal, in that case you're definitely right :-O
07:46:58 <Deewiant> I don't like the 'read' family of methods
07:47:09 <Deewiant> Haskell is cool, though. :-)
07:47:11 <byorgey> RobRobRob: why not?
07:47:16 <Lemmih> quicksilver: The same goes for ByteStrings and IsString.
07:47:37 <RobRobRob> byorgey: cause i like object oriented programming
07:47:54 <RobRobRob> byorgey: i can't get my head around doing things in haskell
07:48:03 <byorgey> RobRobRob: oh, so you mean you're not *used* to Haskell =)
07:48:08 <vixey> readRat s = (tryRead s :: Just Rational) `mappend` (liftM realToFrac (tryRead s))
07:48:12 <RobRobRob> byorgey: pretty much :p
07:48:20 <byorgey> RobRobRob: but to your credit, you are still here. =)
07:48:46 <RobRobRob> byorgey: well, it's for university coursework. believe me i wouldn't touch haskell with a barge pole otherwise
07:48:48 <vixey> where is mappend from?
07:48:59 <dcoutts_> vixey: Data.Monoid
07:49:00 <Deewiant> Data.Monoid?
07:49:01 <byorgey> RobRobRob: you'll get there.  Haskell does take some getting used to, since it is so unlike mainstream languages
07:49:09 <vixey> thank you
07:49:42 <byorgey> RobRobRob: as a point of comparison, I learned python in approximately two days, and it took me almost a month to reach the same level of comfort with Haskell.
07:50:15 <RobRobRob> byorgey: well this is the first function programming i've ever done. feels like we've been thrown in at the deep end
07:50:17 <byorgey> but now I would never willingly choose python over Haskell, for most tasks.
07:50:49 <byorgey> RobRobRob: yeah, I can sympathize.  well, think of us as lifeguards =)
07:50:58 <vixey> liftM realToFrac (tryRead s :: Maybe Double) `mappend` liftM realToFrac (tryRead s :: Maybe Double) :: Maybe Rational
07:51:02 <vixey> why doesn't that work :S
07:51:07 <RobRobRob> byorgey: hehe thanks
07:51:10 <vixey> hmm
07:51:21 <vixey> I thought Just x `mappend` _ = Just x
07:51:28 <vixey> I thought Nothing `mappend` Just y = Just y
07:51:29 <vixey> ooops
07:51:32 <byorgey> vixey: no, that's mplus
07:51:36 <vixey> ohh ok thanks
07:51:45 <byorgey> vixey: you could argue that mappend *should* be like that, but it isn't
07:52:06 <byorgey> vixey: the library Monoid instance for Maybe requires the base type to be a Monoid too
07:52:17 <byorgey> so Just x `mappend` Just y = Just (x `mappend` y)
07:52:32 <ToRA> byorgey: for most tasks?  what tasks would you choose python for?
07:52:32 <vixey> success!
07:52:33 <vixey> readRat s = (tryRead s :: Maybe Rational) `mplus` (liftM realToFrac (tryRead s :: Maybe Double) :: Maybe Rational)
07:52:47 <vixey> readRat "1.5" and readRat "1%5" work :P
07:52:55 <matthew_-> ToRA: the demonstration of the superiority of Haskell
07:52:57 <byorgey> ToRA: none come to mind, just leaving myself a loophole in principle =)
07:53:00 <vixey> tryRead s = case reads s of [(x,"")] -> Just x ; _ -> Nothing
07:53:25 <quicksilver> Lemmih: point
07:53:26 <Deewiant> I prefer
07:53:30 <Deewiant> mread s = case reads s of [] -> fail "mread :: no parse" xs -> return.fst.head $ xs
07:53:43 <quicksilver> HERESY
07:53:53 <Deewiant> not my fault that fail is in Monad
07:53:58 * quicksilver beats Deewiant with the i-will-not-use-fail-stick
07:54:00 <Deewiant> it's still a useful function, though. :-P
07:54:06 <Deewiant> quicksilver: I'm willing to accept a good alternative.
07:54:14 <mauke> mzero
07:54:19 <quicksilver> no. all you are permitted to accept is a beating.
07:54:23 <Deewiant> :-D
07:54:28 <byorgey> haha
07:54:32 <vixey> you could design a new Haskell standard library?
07:54:45 <byorgey> aww, if \bot were here I would @remember that...
07:55:00 <quicksilver> A version of mzero which took an string parameter which the monad was allowed to ignore might be pragmatic though.
07:55:02 <Deewiant> MonadPlus has so few instances though :-S
07:55:18 <Deewiant> how about fail, for how many types does it do something 'smart'
07:55:20 <dolio> quicksilver: That's called fail.
07:55:29 <quicksilver> dolio: except it's in the wrong class, yes.
07:55:37 <dolio> Deewiant: Label your code as Haskell 1.4.
07:56:00 <Deewiant> dolio: what difference would that make
07:56:27 <dolio> Deewiant: The monad hierarchy was correct in that one.
07:56:38 <Deewiant> In what way?
07:56:42 <Deewiant> MonadError?
07:56:48 <dolio> I think, at least. Monadic pattern matching required a MonadZero constraint or some such.
07:57:00 <dolio> I don't know if it was via a fail function.
07:57:56 <quicksilver> Deewiant: all the classes for which fail does something smart are members of MonadPlus
07:58:03 <quicksilver> Deewiant: as far as I am aware.
07:58:05 <Deewiant> quicksilver: I just checked that manually and you are indeed correct
07:58:20 <quicksilver> mostly it's Maybe, Either String, MonadError m, and IO that you care about.
07:58:22 <Deewiant> (as in, the GHC docs)
07:58:43 <dolio> I guess it wasn't. Maybe pattern match failure just used 'zero' in 1.4.
07:59:09 <vixey> Maybe monad
08:00:15 <Deewiant> quicksilver: I didn't know this, thanks. The code now reads 'mzero' :-)
08:01:19 <quicksilver> ;)
08:01:32 <quicksilver> well the disadvantage of course if you can't pass a sensible message
08:04:01 <dolio> Ah, yeah, 'do {p <- e; stmts} = let ok p = do {stmts} ; ok _ = zero in e >>= ok'
08:08:03 <jorick> is there any program (doesn't matter what it does) written in haskell which stands out in particular for the clarity of it's code?
08:08:05 <jorick> its
08:08:23 <mauke> main = putStrLn "Hello, world!"
08:08:44 <gnuvince> > 3 + 4
08:08:48 <vixey> 7
08:09:03 <mauke> quicksort
08:09:19 <dcoutts_> jorick: some simpler parsers using parser combinators
08:10:07 <Saul_> jorick: How about fac?
08:10:08 <jorick> i've read some smaller examples ... i'm looking for a complete program
08:10:12 <vixey> jorick: The most incredible haskell code I read is LogicT
08:10:13 <dcoutts_> jorick: another nice comparison is red-black trees
08:10:29 <jorick> hey vixey
08:10:34 <vixey> hi :)
08:10:36 <mauke> quicksort [] = []; quicksort (p : xs) = left ++ [p] ++ right where left = [x | x <- xs, x <= p]; right = [x | x <- xs, x > p]
08:11:02 <Bonus> i think it's more readable with filter
08:11:23 <vixey> jorick: Also see the monad transformer stack tutorial
08:11:47 <Bonus> quicksort (filter (<= p) xs) ++ [p] ++ quicksort (filter (> p) xs)
08:11:50 <jorick> i just found logicT, curious about what it does also
08:11:52 <mauke> quicksort [] = []; quicksort (p : xs) = left ++ [p] ++ right where (left, right) = partition (<= p) xs
08:12:11 <Saul_> jorick: Simon Peyton Jones seems to think that xmonad is very clear and simple, so you might check it out
08:12:25 <matthew_-> SPJ also uses windows IIRC
08:12:25 <Bonus> mauke where is the recursion in there?
08:12:31 <mauke> heh
08:12:34 <mauke> missing!
08:12:50 <mauke> quicksort left ++ [p] ++ quicksort right
08:13:09 <jorick> ah, xmonad seems a good example
08:13:15 <lilac> is there a standard function to do: filter2 p a = (filter p a, filter (negate . p) a) ?
08:13:39 <mauke> see above
08:13:42 <Bonus> partition
08:13:54 <Bonus> > partition (> 3) [1,2,3,4,5,6,7]
08:14:00 <Bonus> ahem
08:14:18 <mauke>  ([1,5,2,6],[3,4,7,2])
08:14:27 <Saul_> This would be much more impressive if lambabot was alive
08:14:42 <Bonus> yeah lol
08:14:42 <vixey> jorick: there is also some really wonderful code http://www.iis.sinica.edu.tw/~scm/category/publication/
08:14:44 <Bonus> what a fail
08:14:51 <vixey> not all Haskell
08:14:56 <Saul_> lambdabot even
08:15:00 <lilac> quicksort [] = []; quicksort (p:xs) = (quicksort left) ++ [p] ++ (quicksort right) where (left, right) = partition (>p) xs
08:15:36 <Bonus> shouldn't that be
08:15:39 <Bonus> (< p)
08:15:39 <Bonus> ?
08:15:53 <Bonus> depends on if you're doing ascending or descending though yeah nvm
08:15:58 <byorgey> actually, that would introduce an extra copy of p
08:17:10 <byorgey> I mean, using partition, doesn't matter if it's (>p) or (<p)
08:17:26 <byorgey> since, e.g. if p = 2, partition (<2) [1,2,3] = ([1],[2,3])  and then you'd have quicksort [1] ++ [2] ++ quicksort [2,3]
08:17:49 <byorgey> er, make that [2,1,3], but you get the idea
08:18:03 <mauke> huh?
08:18:05 <byorgey> oh! wait, I'm dumb, it's (p:xs) =P
08:18:06 <Saizan> byorgey: but you partition on the tail, not the full list.
08:18:42 <byorgey> sigh.  I need to learn to read more carefully, or something.
08:18:43 <Saul_> byorgey: I think you mean that it doesn't matter if you used (<p) or (<=p)
08:19:02 <Saul_> And I need to type faster :)
08:19:14 <byorgey> that's not actually what I meant, but what I meant doesn't matter =)
08:20:06 <byorgey> but you're right, you could use < or <= and both would work fine
08:30:20 <vixey> this is exciting!
08:30:26 <vixey> I met someone in real life that knows haskell :P
08:31:41 <byorgey> vixey: really? cool!
08:31:57 <vixey> I think he did work in pH
08:32:00 <byorgey> vixey: did you intentionally meet them, or you just ran into them and randomly discovered that you both know haskell?
08:32:09 <vixey> he's my teacher
08:32:21 <byorgey> ah, I see =)
08:32:23 <vixey> it's just a silly mandatory (non haskell) class though
08:35:37 <Bonus> my calculus professor said he'd give me extra marks if i submitted to him a function in haskell that solves the hanoi towers problem but tail recursively
08:36:05 <vixey> isn't that impossible?: P
08:36:15 <vixey> I mean unless you have an explicit stack
08:36:20 <Bonus> yeah hmm
08:36:29 <Bonus> i think technically everything can be converted to tail recursion
08:36:32 <Deewiant> that may have been why he said that ;-)
08:36:33 <Bonus> but it would be a major bitch
08:36:38 <vixey> not everything
08:36:47 <Bonus> yeah
08:36:50 <Bonus> hm
08:37:50 <pjd_> Bonus: CPS?
08:37:57 <pjd_> CPS transform, that is
08:38:27 <Bonus> i haven't used CPS much as of yet
08:40:32 <pjd_> Bonus: in CPS, there are only tail calls
08:41:08 <MyCatVerbs> Bonus: heck, transforming to CPS also gives you just about the easiest way of doing GC in the universe.
08:41:30 <vixey> garbage collection?
08:41:33 <MyCatVerbs> Bonus: or at least, the most elegant one I've ever heard of: Cheney on the MTA!
08:41:33 <Bonus> ha, hmmm
08:41:43 <Bonus> haha i'll have to look into CPS a bit more
08:41:46 <MyCatVerbs> Bonus: seriously, take a look. It's beautiful.
08:42:14 <vixey> wow
08:42:27 <vixey> look how awful that scheme code is http://en.wikipedia.org/wiki/Tower_of_Hanoi
08:42:46 <Bonus> ugh
08:42:50 <Bonus> freaking lisp and scheme
08:42:56 <Bonus> i know i'll have to learn one of them one day
08:43:11 <pjd_> vixey: that's pretty bad
08:43:15 <Bonus> because everyone is like oooh ooh learn it because it changes the way you think blah blah
08:43:18 <Bonus> but those parens
08:43:18 <Bonus> ugh
08:43:39 <vixey> Bonus: That code is a particularly awful peice of rubbish :P
08:43:58 <vixey> "printf" in scheme ...
08:44:16 <Deewiant> what's wrong with printf
08:44:28 <vixey> It's not in R5RS...
08:44:39 <Deewiant> is it in R6, though?
08:45:19 <dolio> Why does that code have "(let ((...)) (let ((...)) ..."?
08:45:35 <dolio> Just to get more indentation?
08:45:44 <vixey> the author mustn't have known about let*
08:45:53 <MyCatVerbs> Bonus: ehhhh.
08:46:00 <Deewiant> why don't one of you rewrite it into something more idiomatic :-P
08:46:06 <Deewiant> (I would, but I don't speak Scheme)
08:46:11 <vixey> (let ((x 1) (y 2) (z 3)) ...) is like ((lambda (x y z) ...) 1 2 3)
08:46:43 <vixey> (let* ((x 1) (y 2) (z 3)) ...) is like ((lambda (x) ((lambda (y) ((lambda (z) ...) 3)) 2)) 1)
08:46:49 <vixey> in CBV the binding time might matter
08:46:52 <MyCatVerbs> Bonus: Scheme's not particularly mind-blowing compared to Haskell. Only *really* surprising thing I know of in Scheme (disclaimer: I do not know the whole language) is call/cc, and that seems positively normal once you've understood continuation-passing-style properly.
08:47:00 <dolio> I don't know scheme that well, either.
08:47:16 <Bonus> ah
08:47:21 <Bonus> i was thinking more about lisp though
08:47:24 <Bonus> i still can't tell them apart
08:47:29 <MyCatVerbs> Bonus: unless maybe I've missed something and I need to be enlightened, anyway. Still. Common Lisp is almost certainly worth a look at, simply for the sheer number of intensely useful features in it.
08:47:40 <Saul_> Does anyone know if there are LCP solvers implemented in Haskell?
08:47:41 <Bonus> hmm
08:48:12 <MyCatVerbs> Bonus: like, if you've ever been burned by Simula/C++/Java style (fail-at-)"OO", then you really need to check out CLOS for an idea of what a *real* object system can do.
08:48:17 <Saul_> (LCP = Linear Complementarity Problem)
08:48:45 <vixey> If you are interested in language design and implementation you are certainly missing out if you don't look at Common Lisp Scheme and ALGOL
08:48:52 <Deewiant> The thing I like about Lisps, without knowing much about them, is that they can use hyphens in variable names.
08:49:03 <Deewiant> That one feature counts for a lot. :-P
08:49:11 <Bonus> hmm hm
08:49:54 <pjd_> Bonus: Scheme is good for learning because it's such a small and compact language
08:50:12 <Bonus> yeah afaik it doesnt have a lot of syntax
08:50:14 <maltem> Deewiant: That's very true. That's what I liked about Scheme when having a 5-or-10-minutes look at it once
08:50:16 <matthew_-> surely the same could be said for 6502 assembly
08:50:36 <pjd_> there's a lot of literature that uses Scheme code;  it's probably worth knowing for that alone
08:50:50 <chell> to me, lisp and scheme both read like (((((()))))))
08:50:56 <Deewiant> Maybe we could get hyphens-in-names for Haskell'? :-)
08:51:02 <maltem> Bonus: Lispers like to say that in Lisp the AST is explicitly written down
08:51:14 <vixey> Deewiant: In haskell you can write f' though, can't do that in lisp!
08:51:31 <dolio> You'd lose them for operators with the way Haskell is currently parsed.
08:51:33 <maltem> Deewiant: At least we have primes'in'names
08:51:41 <Deewiant> vixey: doesn't that depend on the Lisp? In general, can't you use all characters? :-)
08:51:45 <dolio> And I don't think anyone wants to lose '3 - 4'.
08:51:58 <Deewiant> We'd lose only 3-4.
08:52:05 <Deewiant> Not 3 - 4, or even 3- 4 or 3 -4.
08:52:23 <Deewiant> And actually not 3-4 either, since names have to start with non-numbers, or?
08:52:25 <pjd_> Deewiant: after (), ' is probably the most universal bit of Lisp syntax
08:52:28 <vixey> Deewiant: will most lisps have () ' ` and , as special syntax (as well as # and stuff), so you can't use those in names without escaping
08:52:38 <dolio> You would if you took - out of the operator space, and put it in the normal function space.
08:52:38 <Deewiant> Alright.
08:52:47 <maltem> Hey, we want to quit having (-) as a special case in Haskell', now we get it again :)
08:52:54 <Deewiant> But that's still a lot less than losing +-?![]{} etc. ;-)
08:53:09 <Deewiant> I'd rather not make it a special case and just allow everything.
08:53:09 <profmakx> man searchpath rocks ;)
08:53:16 <Deewiant> Forcing spaces between operators where disambiguation is needed.
08:53:16 <vixey> Does anyone (like Cale maybe :D) have a new Prelude set out?
08:53:28 <vixey> like with all the MonadFail and so on changen?
08:53:49 <maltem> Deewiant: But in Haskell we have the infix/prefix disambiguation
08:53:54 <dolio> Deewiant: Agda is like that, but then you're required to write stuff like '[ a ]' instead of '[a]'.
08:53:59 <maltem> Deewiant: which isn't present in Lisps
08:54:06 <dolio> Deewiant: Because
08:54:09 <dolio> Oops.
08:54:21 <dolio> Because [a] is a valid identifier separate from [ a ].
08:54:25 <Deewiant> maltem: What exactly do you mean?
08:54:42 <vixey> hmm
08:54:52 <vixey> There is no categorized haskell wishlist?
08:55:06 <Deewiant> dolio: I'd allow non-characters only in the middle of names. Some exceptional cases like ? or ! at the end of identifiers might be fine but not really necessary.
08:55:39 <Deewiant> Hm. Non-letters, of course, not non-characters. :-P
08:55:51 <maltem> Deewiant: Basically what dolio said, if - is allowed in the middle of function names, then - becomes a symbol for prefix names, and - would be a prefix function. But wait... now I come to think of it, - is indeed a prefix symbol in Haskell98 :)
08:56:17 <quicksilver> in haskell98, - is demonfix
08:56:29 <quicksilver> when you think you understand it, it turns around and devours your soul.
08:56:31 <vixey> You couldn't really use the approach Prolog does
08:56:41 <vixey> since it's not possible to add sections to Prolog
08:56:47 <maltem> Deewiant: Ah, the only-in-the-middle bit should be what I missed until now
08:56:58 <saml> > (\x -> ((\x -> div x 1) x)) 1.0
08:57:05 <maltem> quicksilver, :)
08:57:13 <vixey>     Ambiguous type variable `a' in the constraints:
08:57:13 <vixey>       `Fractional a'
08:57:13 <vixey>         arising from the literal `1.0' at <interactive>:1:28-30
08:57:13 <vixey>       `Integral a' arising from a use of `div' at <interactive>:1:15-21
08:57:13 <vixey>     Probable fix: add a type signature that fixes these type variable(s)
08:57:32 <Deewiant> maltem: It's not such a bad restriction either. Who needs names like "][foobar][" anyway? :-P
08:57:52 <dolio> I wouldn't mind _1 being the syntax for negative one (I think I've seen that proposed somewhere).
08:58:04 <maltem> Deewiant: Well the restriction would be that we need spaces around any identifier
08:58:07 <vixey> Oz uses ~ like that
08:58:18 <dolio> Although maybe I'm the only one not writing functions like 'f _1 _2 = _1 + _2'.
08:58:19 <maltem> (or better, around most)
08:58:19 <vixey> it's a fine way to deal with it
08:58:37 <Deewiant> "-1" ought to be negative one, "- 1" ought to be subtract one.
08:58:38 <vixey> dolio: hmm
08:58:44 <vixey> 0 = Zero
08:58:48 <pjd_> @remember quicksilver in haskell98, - is demonfix
08:58:49 <vixey> 1 = Succ 0
08:58:50 <Deewiant> maltem: Not very often, I don't think.
08:58:57 <vixey> f 1 = 1 + 1
08:58:57 <Deewiant> ENOBOT
08:59:03 <pjd_> foiled
08:59:05 <dolio> ~ is used prefix for irrefutable patterns already.
08:59:06 <vixey> f 7 = 14 ?
08:59:07 <maltem> (I'd be perfectly happy with let neg = negate)
08:59:34 <vixey> why not make numerals less special
08:59:43 <mauke> dolio: but ~42 is useless
08:59:48 <vixey> then again, you'd have to . an operator if you wanted to write 1.5 :/
08:59:49 <maltem> Deewiant, right, if we're only talking about the - symbol, then it's only for cases such as a-b
09:00:13 <pjd_> ~ suggests approximity
09:00:38 <mauke> tell that to C
09:00:41 <matthew_-> well, either that or type equality constraint
09:00:53 <maltem> pjd_, ~ suggests a nasal
09:00:58 <Deewiant> maltem: Even if we allow a lot more symbols, it's not that bad. Unless other people use spaces a lot less than I do or the code I've come across does. :-)
09:01:27 <maltem> Deewiant, point taken
09:01:30 <Deewiant> maltem: (.), ($), and (:) aren't always spaced but most of the other operators are, in my experience.
09:01:50 <maltem> hmm, (:) is probably the most important one here
09:02:03 <Deewiant> and (.), because it already means too many things.
09:02:14 <pjd_> Unicode to the rescue: −42
09:02:31 <dolio> Heh.
09:02:35 <Deewiant> pjd_: that would be ideal but I doubt people would agree to differentiating between 'minus sign' and 'hyphen'. :-)
09:02:48 <maltem> That reminds me that we have forced spaces around (.) sometimes anyway
09:02:56 <Deewiant> yep
09:03:48 <maltem> Does unicode distinguish binary minus and negation minus?
09:04:00 <Deewiant> don't think so, no
09:04:13 <quicksilver> unicode has multiple glyphs which look a bit like horizontal lines though.
09:04:20 <quicksilver> you could arbitrarily choose some
09:04:24 <quicksilver> but it would be pretty confusing.
09:04:25 <vixey> -⁻₋−⊖﹣－
09:05:14 <mauke>  – —
09:05:27 <maltem> quicksilver, that would be too confusing. Unicode adds some interpretation to glyphs; it would be tedious to completely break those interpretations
09:06:38 <maltem> doh, the ordinary - is called "hyphen or minus sign" (HYPHEN-MINUS)
09:07:12 <Deewiant> yes, but U+2212 is 'MINUS SIGN'.
09:07:19 <maltem> right
09:07:39 <pjd_> (and U+2010 is HYPHEN)
09:07:39 <Deewiant> and U+2010 is 'HYPHEN'.
09:07:46 <pjd_> heh
09:08:11 <mauke> HYPHEN-MINUS, SUPERSCRIPT MINUS, SUBSCRIPT MINUS, MINUS SIGN, CIRCLED MINUS, SMALL HYPHEN-MINUS, FULLWIDTH HYPHEN-MINUS, HYPHEN, EN DASH, EM DASH
09:08:12 <vixey> well you could just make all numerals bound to zero arity functions of type Num a => a
09:08:13 <Deewiant> so, ideally, the latter would be usable in variable names. :-)
09:08:19 <vixey> and allow rebinding of them locally
09:08:48 <vixey> so e.g. f 1.6 = 1.6 ++ [] -- could work
09:10:09 <vixey> obviously you wouldn't write code like that, but if (-1) was the identifier for negative one whereas (- 1) subtracts one, it could work out?
09:10:39 <Deewiant> H' should just adopt something like C99's "universal alpha" for identifiers instead of restricting us to 'letters, digits, underscores, and single quotes.'
09:10:59 <jadrian> how do you call the 'basic' types...
09:11:04 <jadrian> like Int?
09:11:14 <jadrian> I keep thinking "ground"
09:11:18 <vixey> another thing I'd like very much is to be able to declare which unicode characters are upper and lowercase or operators
09:11:21 <Igloo> jadrian: In what context?
09:11:23 <Deewiant> "standard Haskell types"?
09:11:32 <Igloo> In the context of H98 I'd say primitive types
09:11:41 <jadrian> Igloo: as in types that you use to build other types
09:11:43 <vixey> (or possibly apply that to names in general, rather than characters, not sure what's best)
09:11:54 <Deewiant> my quote is what the report calls them. :-)
09:11:59 <jadrian> Igloo: ah, yes seems like the term I was looking for
09:12:04 <Deewiant> but it includes stuff like Maybe, IO, etc.
09:12:04 <vixey> (I still haven't writte a parser for this :/)
09:12:15 <Igloo> But in the context of GHC, Int# is the primitive type
09:12:22 <jadrian> Deewiant: nah, I don't even want to include (Int,Int)
09:12:28 <jadrian> Igloo: yeah I know :)
09:12:31 <Igloo> Deewiant: What do you mean by "universal alpha"?
09:12:42 <vixey> jadrian: Just list them and name them then
09:12:46 <jadrian> Igloo: but you got the idea :)
09:12:53 <vixey> "this set of types shall be referred to as ______"
09:12:58 <Deewiant> Igloo: ISO 9899:1999 annex D, "Universal character names for identifiers."
09:12:59 <pjd_> jadrian: "predefined", perhaps
09:13:13 <jadrian> primitive is a good word
09:13:19 <quicksilver> maltem: some people say unicoe is broken precisely because it does ascribe semantics to characters.
09:13:22 <jadrian> it's the types that are not built from other types
09:13:33 <quicksilver> Deewiant: what does it mean? universal alpha?
09:13:38 <jadrian> as far as I know ground just means it's not function type right?
09:13:52 <vixey> ground doesn't have a meaning
09:13:56 <vixey> you could give it one
09:14:15 <Deewiant> it's a listing of code points that C99 allows in identifier names.
09:14:23 <jadrian> I need two words, on for types that are not built from other types
09:14:25 <quicksilver> Deewiant: GHC uses the unicode classifier stuff.
09:14:27 <vixey> (it might be more correct to say, 'ground' has so many meanings in different contexts you must remove ambiguity if you want to use the term)
09:14:33 <jadrian> and another for types that are not function types
09:14:36 <maltem> quicksilver, I guess it is hard enough to give a glyph a name without ascribing semantics to it
09:14:38 <vixey> jadrian: Just define a term
09:14:40 <Deewiant> I recalled it was called something like 'universal alphanumeric characters' which is why I said 'universal alpha'. :-)
09:14:41 <quicksilver> Deewiant: if unicode classifies it as a symbok, you can use it in operators.
09:14:43 <jadrian> I guess I'm going with primitive and ground
09:14:46 <Igloo> Deewiant: H98 already allows any character from the appropriate unicode class
09:14:58 <Deewiant> oh?
09:15:02 <quicksilver> Deewiant: if unicode classifies it as a "letter" then it can be in an ordinary name]
09:15:05 <quicksilver> yes
09:15:11 <Deewiant> what am I missing in the H98 report
09:15:12 <Deewiant> "An identifier consists of a letter followed by zero or more letters, digits, underscores, and single quotes."
09:15:14 <quicksilver> haskell was one of the first languages to support unicode variable names :)
09:15:23 <Deewiant> is 'letters' defined somewhere?
09:15:34 <Igloo> Yes, the the syntax definition
09:15:34 <maltem> sure
09:16:10 <Igloo> e.g. uniLarge  ->  any uppercase or titlecase Unicode letter    on http://haskell.org/onlinereport/syntax-iso.html
09:16:58 <pjd_> quicksilver: Unicode has to have some abstraction over just glyph presentation, if you want to distinguish O and 0, or 1 and l, and so on
09:17:36 <quicksilver> yes.
09:17:43 <quicksilver> it's not clear to me what the best answer is
09:17:45 <Deewiant> hmm, I wonder if there's a 'lower case' letter that looks like a hyphen. :-)
09:17:49 <quicksilver> that's why I said "some people say"
09:17:53 <quicksilver> instead of "I think"
09:21:18 <Deewiant> okay, so the problem is solved by changing (-) to (−) in H' and allowing - in variable names. :-)
09:21:32 <Deewiant> (bah, I always say 'variable' when I mean 'identifier'!)
09:21:40 <profmakx> meh Network is still broken on freebsd
09:24:04 <roconnor> Oh, Caml weekly news is out
09:24:11 <roconnor> Persistent twice-delimited continuations and CGI programming
09:25:04 <vixey> where is that?
09:25:12 <vixey> I mean is this online?
09:25:48 <roconnor> http://alan.petitepomme.net/cwn/2008.04.29.html
09:42:57 <tuxagb> I wrote: data M a = Raise String | Return a
09:43:17 <tuxagb> and:
09:43:19 <tuxagb> instance Monad M where
09:43:25 <tuxagb> return :: a -> M a
09:43:29 <tuxagb> return x = M x
09:43:43 <tuxagb> (>>=) :: M a -> (a -> M b) -> M b
09:43:55 <tuxagb> (>>=) (Return x) f = f x
09:44:06 <tuxagb> (>>=) (Raise s) _ = Raise s
09:44:23 <tuxagb> ghci says: misplaced type signature
09:44:25 <tuxagb> why???
09:44:31 <vixey> That reminds me of the Either Monad
09:44:48 <vixey> I think you can't use a capitol M like that though
09:44:55 <roconnor> tuxagb: are your return and (>>=) definitions indented?
09:44:56 <tuxagb> ah
09:44:59 <vixey> maybe you should look at the Either Monad implementation too?
09:45:13 <tuxagb> return and (>>=) are on one line
09:45:16 <roconnor> oh right
09:45:17 <EvilTerran> tuxagb, you can't put type annotations for methods in instance declerations
09:45:22 <roconnor>  return x = Return x
09:45:25 <tuxagb> ahhhhh
09:45:29 <EvilTerran> just 'cos
09:45:32 <solrize> that mobile continuation stuff looks insane
09:45:35 <roconnor> EvilTerran: really?
09:45:55 <solrize> oh it's at okmij.org, that explains it :)
09:46:39 <tuxagb> thank you
09:47:34 <EvilTerran> roconnor, yeah. i think it's because it'd be wholly redundant with the one in the class decleration
09:48:38 <maltem> I always perceived it as a limitation that you cannot put type signatures there
09:49:15 <maltem> It'd sometimes be a nice sanity check if the compiler just made sure those type signatures are right
09:49:39 <Bonus> but then you're repeating yourself though
09:49:53 <Bonus> or repeating someone else who already made the type annotation in the class declaration
09:52:17 <EvilTerran> as maltem says, sometimes it'd be a good sanity check, to make sure the specialised type of the function is what you think it is
09:53:50 <Bonus> hmm yeah maybe
09:59:06 * edwardk waves hello.
10:00:02 <Saizan> hi
10:01:06 <Saizan> edwardk: do you know of any works on multi-hole zippers?
10:01:22 <Elly> multi-hole zippers?
10:01:24 <quicksilver> Saizan: I think conor has written at least a little bit about it.
10:04:53 <matthew_-> so since my last commit, 12 days ago, I have added 330 lines and removed 143. Which works out at about 15.6 lines of code added per day.
10:05:50 <dolio> You're never going to be qualify as an enterprise developer like that.
10:05:53 <Deewiant> does correcting a single line count as adding and removing 1? :-)
10:05:54 <Saizan> quicksilver: do you remember the name of the paper?
10:05:56 <edwardk> saizan: hrmm. i've seen a couple of things on two hole zippers
10:06:35 <edwardk> http://www.haskell.org/pipermail/haskell/2005-May/015844.html
10:07:34 <edwardk> saizan: look up oleg's zippers, he defines a lot of stuff for dealing with multi-hole zippers as a transaction isolation model
10:08:46 <Saizan> yeah, thanks :) i hope the delimited continuation are not too much over my head..
10:09:02 <matthew_-> Deewiant: yes. Those numbers are taken from diff | egrep '^\+' | wc -l and diff | egrep '^-' | wc -l
10:09:02 <edwardk> Writing in haskell I tend to actually reduce the number of lines in my code from day to day. This makes it impossible to start new projects and in general you are only able to plot my release schedules on a moebius strip.
10:09:50 <edwardk> saizan: just take the second derivative of a functor if you want to do it without oleg-speak. then think about what that makes cheap.
10:12:23 <Saizan> edwardk: that gives me two holes? or directly N?
10:13:54 <daveux> I have two threads: one runs an external program using system, the other continuously calls getChar to process user input. The system call causes the getChar thread to be scheduled, and that thread blocks if no character is available. This causes the system call on the other thread not to be made until getChar returns. Is there anyway to get around this? I'd need something like a getCharOrYield function.
10:16:22 <nejucomo> What does "\&" signify in a string literal?
10:16:32 <dcoutts_> daveux: I thought it did not block other threads, but you can try linking your program using -threaded then it shouldn't
10:16:36 <nejucomo> It appears to be removed.
10:16:44 <kpreid> nejucomo: terminating a previous escape thing
10:16:56 <nejucomo> Hmm...
10:17:04 <daveux> I'm already using -threaded :(
10:17:34 <kpreid> nejucomo: it's like whitespace between identifiers
10:18:01 <edwardk> saizan: actually what i suggested gives you a second order zipper: http://notvincenz.blogspot.com/2007/07/higher-order-zippers.html
10:18:26 <nejucomo> I see, so "\128\&0" is two characters, the second being '0', whereas "\1280" is one char ?
10:18:51 <JaffaCake> daveux: want to come over to #ghc?
10:18:52 <saml> how can I test if [a] has all unique elements and no duplicates?
10:19:10 <kpreid> nejucomo: something like that
10:19:10 <Deewiant> assuming Eq... xs == nub xs
10:19:26 <Deewiant> or length xs == length (nub xs)
10:20:04 <saml> > let allunique l = length l == length (nub l) in allunique "abcdefa"
10:20:13 <Deewiant> ENOBOT
10:20:43 <edwardk> damnit, now i need to figure out a higher order zipper comonad too =)
10:22:02 <Deewiant> if you've got Ord, do something like 'any (not . length1) (group . sort $ xs)'
10:25:30 <byorgey> http://byorgey.wordpress.com/2008/04/30/new-haskell-diagrams-library/  get it while it's hot! =D
10:26:07 <Nafai> w00t
10:27:28 <olsner> byorgey: hmm, so when is that gobby-in-haskell-with-undo clone coming? :P
10:27:41 <edwardk> I finally decided to post up something that isn't (directly) related to supercalihylocataanariffic-morphisms =)
10:27:51 <byorgey> olsner: haha, never =)
10:28:14 <byorgey> olsner: I was never really that serious about actually writing such a thing, it would have been way too big of a project
10:28:48 <byorgey> olsner: I did kind of leave off in the middle of my exposition of the theory, though, I do plan to get back to that at some point
10:29:03 <olsner> well, theory is the interesting part anyway
10:29:09 <byorgey> indeed =)
10:29:15 * byorgey is plagued with TOO MANY INTERESTS
10:29:22 <vixey> that's -really- nice byorgey!
10:29:28 <byorgey> vixey: thanks!
10:29:44 <nejucomo> Is there a way to search for values by type?  I want to ask ghci "what has type: [a -> a] -> [a] -> [a]".
10:29:53 <edwardk> @hoogle
10:30:01 <olsner> @hoogle [a -> a] -> [a] -> [a]
10:30:05 <bd_> zipWith ($)
10:30:06 <edwardk> @where hoogle
10:30:12 <bd_> :t zipWith ($)
10:30:17 <kpreid> nejucomo: http://haskell.org/hoogle/
10:30:18 <bd_> hmmmm
10:30:22 <nejucomo> Hoogle, eh.  Thanks.
10:30:26 <bd_> zipWith ($) :: [a -> b] -> [a] -> [b]
10:30:26 <bd_> there
10:30:27 <byorgey> lambdabot is dead...
10:30:30 <ziman> @t sipWith ($)
10:30:34 <bd_> slightly more general :)
10:30:49 <olsner> hmm, isn't that just ap though?
10:30:57 <byorgey> no
10:31:03 <byorgey> it's <*> for ZipList
10:31:13 <Deewiant> and isn't <*> ap? :-P
10:31:20 <edwardk> well, both are valid choices =)
10:31:36 <bd_> hm, yes, ap is even more general :)
10:31:37 <kpreid> olsner: zipWith ($) is zip-y where as ap is cross-product-y
10:31:43 <byorgey> [(+1), (+2)] `ap` [3, 6]  would give you [4,7,5,8]
10:31:55 <edwardk> > [(*1),(*2)] `ap` [3,6]
10:31:56 <byorgey> whereas zipWith ($) [(+1), (+2)] [3,6] would give you [4,7]
10:32:18 <olsner> hmm, you mean, [4,8]?
10:32:23 <sclv_> ooh... awesome diagrams.
10:32:24 <byorgey> er, yes
10:32:26 <Adamant> Haskell: The Cake Is Not A Lie!
10:32:31 <byorgey> sclv_: thanks =)
10:32:48 <Deewiant> and [(+1), (+2)] <*> [3,6] is [4,7,5,8]. :-)
10:32:55 <byorgey> yup =)
10:33:18 <byorgey> and (ZipList [(+1), (+2)]) <*> (ZipList [3,6]) is  ZipList [4,8]
10:33:47 <saml> in Parsec, I am using try combinator:  try parseA <|> try parseB ...    in one of parseX, I call fail. but because of outer try, it gets accepted from parseY.  is there a way to fail all the way through top level?
10:34:09 <olsner> iirc there is a failBad
10:35:01 <nejucomo> Hrm...  zipwith ($) is not what I want.
10:35:07 <saml> parseX <|> parseY    parseX fails but parseY accepts. however failure at parseX is critical and parseY shouldn't be invoked.
10:35:12 <byorgey> nejucomo: what do you want? can you give an example?
10:35:14 <saml> ?hoogle failBad
10:35:45 <olsner> lambdabot still not here ...
10:35:52 <byorgey> @get-Cale
10:35:57 <nejucomo> I'm writing: (map (\x ...) (map (\x ...) (map (\x...) ...) ...) ...)
10:36:02 <olsner> @connect #haskell
10:36:06 <roconnor> > 13631 - 7351
10:36:09 <dons> http://reddit.com/r/programming/info/6hon7/comments/ good work byorgey !
10:36:16 <nejucomo> I want something like: multimap [(\x ...), (\x ...), (\x ...)] ...
10:36:17 <byorgey> thanks dons! =)
10:36:36 <byorgey> nejucomo: oh, you want to apply each of the functions in turn?
10:36:41 <nejucomo> Yes.
10:37:01 <byorgey> nejucomo: first turn the list of functions into a single function with a fold.
10:37:07 <byorgey> something like  foldr (.) id
10:37:08 <nejucomo> Oh wait...  Can I do a "where" or "let ... in ..." clause inside a lambda?
10:37:12 <byorgey> although that may be backwards
10:37:39 <byorgey> or you could do  appEndo . mconcat . map Endo =)
10:37:42 <edwardk> nejucomo: you can let in. where wants to scope out
10:37:44 <nejucomo> byorgey: Oh cool, I see.
10:37:54 <roconnor> ugh, scaleY
10:38:10 <nejucomo> edwardk: What do you mean by "scope out"?
10:38:23 <byorgey> roconnor: ?
10:38:37 <roconnor> Damn you Descartes
10:38:41 <edwardk> nejucomo: well foo x = \y -> bar where bar = something y   fails because where is attached to the foo not the lambda
10:38:43 <nejucomo> byorgey: Thanks for the advice, but I think a "let" clause will be much easier to understand.
10:38:53 <byorgey> nejucomo: ok, no problem
10:39:01 <Cale> byorgey: what's up?
10:39:03 <roconnor> byorgey: sorry, I just think that graphics programs ought to coordinate independent.
10:39:16 <nejucomo> edwardk: What about: foo x = (\y -> bar where bar = something y)
10:39:20 <byorgey> roconnor: ah, I see.  so you'd rather see something like 'scaleHeight'?
10:39:38 <Cale> @bot
10:39:38 <roconnor> I blame scaleX and scaleY for all the aspect-incorrect images in the world today.
10:39:58 <roconnor> byorgey: I'd rather see scaleDir vector
10:40:07 <byorgey> Cale: not what's up, but what isn't up =)
10:40:14 <edwardk> nejucomo: parse error. the 'where' has nowhere to go
10:40:17 <roconnor> byorgey: still, nice work!
10:40:20 <byorgey> roconnor: ah, I see
10:40:23 <byorgey> roconnor: thanks!
10:40:26 <Cale> Seems like code.h.o killed my screen session.
10:40:27 <dcoutts_> yay lambdabot
10:40:31 <dcoutts_> @botsnack
10:40:34 <lambdabot> dcoutts_: You have 1 new message. '/msg lambdabot @messages' to read it.
10:40:41 <lambdabot> :)
10:40:52 <byorgey> roconnor: I might add something like that later.  for now, scaleX and scaleY translate directly to Cairo operations, so... =)
10:41:09 <saml> \x -> \x -> ...  do I have to rewrite 2nd x into something unique to evaluate/typecheck the lambda expression? or is there a way to evaluate/typecheck without rewriting?
10:41:15 <nejucomo> Hmm... Ok.  I still don't understand the grammar.  I figured one expression production rule would be: expr := expr where bindings
10:41:37 <nejucomo> But apparently 'where' isn't part of expressions.
10:41:41 <bos> dcoutts_: when you talk about xmonad "built twice", does that happen with a single invocation of "Setup build"?
10:41:58 <edwardk> where isn't scoped to expressions, its not quite the same as a let. because a where is scoped over multiple guards, it moves all the way out to the enclosing declaration
10:42:04 <roconnor> byorgey: when you do that, hide scaleX and scaleY from people.
10:42:20 <dcoutts_> bos: yes, it builds the lib and the exe in the package and they happen to use some of the same modules, so the overlapping modules get "built twice"
10:42:31 <bos> ok, cool.
10:43:02 <edwardk> this lets you say things like foo x y z | cond x = ...\n | cond y z = ...\n    where cond = ...
10:43:02 <byorgey> roconnor: I guess I'm still not sure exactly what the issue is.  what would  scaleDir 1 1 do, for example?
10:43:10 <edwardk> er cond x y
10:43:15 * byorgey scrolls back through input history to record that quote he was saving now that \bot is back
10:44:07 <byorgey> @remember quicksilver *** quicksilver beats Deewiant with the i-will-not-use-fail-stick  <Deewiant> quicksilver: I'm willing to accept a good alternative.  <quicksilver> no. all you are permitted to accept is a beating.
10:44:08 <lambdabot> It is forever etched in my memory.
10:44:17 <Deewiant> >_<
10:44:25 <dcoutts_> byorgey: I don't understand what roconnor means either :-)
10:44:28 <byorgey> =)
10:44:33 <vixey> omg O_O
10:44:34 <vixey> http://www.haskell.org/pipermail/haskell/2005-March/015423.html
10:44:35 <lambdabot> Title: [Haskell] De-typechecker: converting from a type to a term
10:44:48 <dcoutts_> roconnor: isn't scaleDir x y = scaleX x . scaleY y ?
10:45:41 <edwardk> @djinn (a -> b) -> (b -> c) -> a -> c
10:45:43 <lambdabot> f a b c = b (a c)
10:45:50 <Cale> @djinn (a -> Either b c) -> (b -> Maybe c) -> (c -> d) -> d
10:45:50 <lambdabot> -- f cannot be realized.
10:45:57 <Cale> @djinn (a -> Either b c) -> (b -> Maybe c) -> (c -> d) -> (Maybe d)
10:45:57 <lambdabot> f _ _ _ = Nothing
10:46:02 <vixey> this is 5046 times cooler than djinn :P
10:46:13 <Cale> @djinn (a -> Either b c) -> (b -> c) -> (c -> d) -> d
10:46:13 <lambdabot> -- f cannot be realized.
10:46:23 <vixey> (actually it's just that I don't understand it)
10:46:24 <Cale> @djinn (a -> Either b c) -> (b -> c) -> (c -> d) -> a -> d
10:46:24 <lambdabot> f a b c d =
10:46:24 <lambdabot>     case a d of
10:46:24 <lambdabot>     Left e -> c (b e)
10:46:24 <lambdabot>     Right f -> c f
10:46:30 <Cale> aha, there we go :)
10:46:36 <Cale> @djinn (a -> Either b c) -> (b -> Maybe c) -> (c -> d) -> a -> Maybe d
10:46:36 <lambdabot> f a b c d =
10:46:36 <lambdabot>     case a d of
10:46:36 <lambdabot>     Left e -> case b e of
10:46:36 <lambdabot>               Nothing -> Nothing
10:46:36 <lambdabot>               Just f -> Just (c f)
10:46:38 <lambdabot>     Right g -> Just (c g)
10:47:07 <edwardk> djinn still doesn't do typeclasses does it?
10:47:19 <Cale> It does do typeclasses in a limited way
10:47:23 <awesame> if I do a read and then a write in the IO monad, will the read happen lazily as required for the write?
10:47:27 <Cale> @djinn-env
10:47:28 <lambdabot> data () = ()
10:47:28 <lambdabot> data Either a b = Left a | Right b
10:47:28 <lambdabot> data Maybe a = Nothing | Just a
10:47:28 <lambdabot> data Bool = False | True
10:47:28 <lambdabot> data Void
10:47:30 <lambdabot> type Not x = x -> Void
10:47:32 <lambdabot> class Eq a where (==) :: a -> a -> Bool
10:47:58 <edwardk> @djinn Functor f => f  a -> b -> f (a, b)
10:47:58 <lambdabot> Cannot parse command
10:48:20 <Baughn> awesame: That depends on the functions you use - read the documentation carefully
10:48:29 <dcoutts_> awesame: are you talking about reading and writing files? or IORefs or what?
10:48:41 <awesame> I'm specifically wondering whether I can read a very large amount of data using simpleHTTP, and write it out using writeFile
10:48:42 <Baughn> awesame: If it doesn't say, you may assume it's strict. Some aren't - hGetContents, say
10:48:42 <Cale> edwardk: It only knows about Eq at the moment. You can add classes to it though.
10:49:05 <edwardk> @djinn-add class Functor f where map :: (a -> b) -> f a -> f b
10:49:10 <Cale> @djinn-add class Functor f where map :: (a -> b) -> f a -> f b
10:49:13 <awesame> ah, so many are strict
10:49:14 <awesame> dang
10:49:19 <awesame> I need a lazy simpleHTTP
10:49:20 <Cale> @djinn-env
10:49:21 <lambdabot> data () = ()
10:49:21 <lambdabot> data Either a b = Left a | Right b
10:49:21 <lambdabot> data Maybe a = Nothing | Just a
10:49:21 <lambdabot> data Bool = False | True
10:49:21 <lambdabot> data Void
10:49:22 <edwardk> @djinn Functor f => f  a -> b -> f (a, b)
10:49:23 <lambdabot> type Not x = x -> Void
10:49:25 <lambdabot> class Eq a where (==) :: a -> a -> Bool
10:49:27 <lambdabot> class Functor f where map :: (a -> b) -> f a -> f b
10:49:29 <lambdabot> Cannot parse command
10:49:37 <Saizan> i think it doesn't work for constructor classes
10:49:43 <Cale> @djinn (Functor f) => f a -> b -> f (a,b)
10:49:43 <lambdabot> -- f cannot be realized.
10:49:51 <edwardk> hrmm
10:49:51 * lispy thinks it's a bit spammy :)
10:49:52 <dcoutts_> awesame: yeah, check the docs, they should say if they're lazy, but IO is about sequencing side effects so the default is for all side effects to happen before returning rather than lazily deferring the effects until they are demanded
10:49:56 <vixey> why is it called map not fmap
10:50:00 <jadrian> Hmmm is there a name for, "only one type variable"?
10:50:10 <Cale> vixey: because we're like that.
10:50:13 <edwardk> @type \fa b -> fmap (\a -> (a,b) fa
10:50:14 <jadrian> Monomorphism means no type variables
10:50:14 <lambdabot> parse error (possibly incorrect indentation)
10:50:15 <jadrian> :S
10:50:30 <vixey> ?djinn a -> (a,a)
10:50:31 <lambdabot> f a = (a, a)
10:50:32 <vixey> @djinn (Functor f) => f a -> (a -> (a,a)) -> f (a,a)
10:50:32 <lambdabot> -- f cannot be realized.
10:50:33 <Cale> @type \fa b -> fmap (\a -> (a,b)) fa
10:50:33 <lispy> jadrian: like arity-1 except for parametric polymorphism?
10:50:33 <edwardk> @type \fa b -> fmap (\a -> (a,b)) fa
10:50:33 <Corun> Stereomorphism? :-P
10:50:34 <lambdabot> forall t a (f :: * -> *). (Functor f) => f a -> t -> f (a, t)
10:50:35 <lambdabot> forall t a (f :: * -> *). (Functor f) => f a -> t -> f (a, t)
10:50:55 <Cale> I wonder why it doesn't find that solution...
10:50:56 <jadrian> lispy: meaning I can have alphas, but not alphas and betas
10:51:01 <vixey> I don't get this
10:51:07 <jadrian> lispy: only one type variable per type
10:51:12 <lispy> jadrian: yeah, that is the kind
10:51:21 <awesame> hm, I think I am either going to become a major contributor to Network.HTTP, or end up switching to Python for web servers
10:51:24 <jadrian> lispy: thought so :)
10:51:35 <Baughn> awesame: There is absolutely nothing in the dcumentation suggesting that it's lazy. We're a bit short of bread-and-butter libraries, I'm afraid. :/
10:51:37 <lispy> jadrian: you're asking about "* -> *" essentially
10:51:38 <jadrian> lispy: is there a name for such a thing?
10:51:42 <edwardk> gah i jusgt realized my blog is eating my backslashes
10:51:54 <Vulpyne> http://hpaste.org/7281 -- I really don't understand how it's getting to the finally.
10:51:58 <lispy> jadrian: not sure, might it's rank-1 polymorphism?
10:51:59 <Baughn> awesame: I believe there was an SoC project proposal for writing a real one - I don't know if it got accepted, but you might check for that
10:52:17 <vixey> ?djinn (Functor f) => (a -> b) -> f a -> f b
10:52:17 <lambdabot> f = map
10:52:25 <vixey> ?djinn (Functor f) => f a -> (a -> b) -> f b
10:52:25 <lambdabot> f a b = map b a
10:52:28 <jadrian> lispy:  hmmm I haven't played with kinds ofr a long time... I'm used to think of a kind as the type of a type constructor
10:52:33 <vixey> ?djinn (Functor f) => f a -> (a -> (a,b)) -> f (a,b)
10:52:33 <lambdabot> -- f cannot be realized.
10:52:47 <vixey> ?djinn (Functor f) => f a -> (a -> Maybe a) -> f (Maybe a)
10:52:47 <lambdabot> -- f cannot be realized.
10:53:03 <jadrian> lispy:  but that's not exactly the same...
10:53:10 <Cale> Wow, that's a pretty disappointing performance.
10:53:18 <vixey> ?djinn (Functor f) => (a -> b -> c) -> f a -> b -> f c
10:53:18 <lambdabot> -- f cannot be realized.
10:53:28 <Vulpyne> Hmm, maybe I do.
10:53:28 <edwardk> methinks its support for types of kind other than * is somewhat lacking
10:53:34 <lispy> jadrian: How is it different than what you want?
10:53:51 <jadrian> lispy:  well what is the kind of ( , )
10:54:04 <glguy> :k (,)
10:54:06 <lambdabot> * -> * -> *
10:54:10 <jadrian> thanks :)
10:54:11 <lispy> http://en.wikipedia.org/wiki/Polymorphism_(computer_science)#Rank-1_.28prenex.29_polymorphism
10:54:12 <Saizan> i think i remember augustss deleting constructor classes from the env saying it couldn't instance them anyway
10:54:13 <lambdabot> http://tinyurl.com/5nzkq
10:54:19 <jadrian> lispy: and I can have (,)
10:54:21 <jadrian> lispy: and I can have (,
10:54:53 <vixey> ?djinn (Functor f) => f (f a) -> f (f b)
10:54:53 <lambdabot> -- f cannot be realized.
10:54:59 <edwardk> so much for my attempt to use it to show costrength can't be derived generically in Haskell ;)
10:55:14 <Cale> @djinn (Functor f) => (a -> b) -> f (f a) -> f (f b)
10:55:15 <lambdabot> -- f cannot be realized.
10:55:23 <jadrian> lispy:  so it's not really about the rank of type constructors
10:55:28 <dolio> @type mapM id
10:55:29 <lambdabot> forall (m :: * -> *) b. (Monad m) => [m b] -> m [b]
10:55:32 <dolio> @type sequence
10:55:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:55:41 <jadrian> lispy:  it's just about only having one type variable available
10:55:42 <mauke> @src mapM
10:55:43 <lambdabot> mapM f as = sequence (map f as)
10:55:46 <Baughn> Is there any way to serialize /functions/?
10:56:04 <IsoPallo> And what would that mean?
10:56:05 <edwardk> dolio: ah i should have just said 'sequence' in the blog post, no?
10:56:11 <jadrian> lispy:  does it make sense?
10:56:27 <lispy> jadrian: I don't understand how having one type variable available is different than * -> *
10:56:34 <vixey> Baughn: lots of ways
10:56:35 <dcoutts_> Baughn: not really, you might be able to serialise their results or the tuple of their inputs
10:56:37 <dolio> edwardk: Possibly.
10:56:37 <Cale> Baughn: Not unless they have a compact domain.
10:56:41 <vixey> none in Haskell though :?
10:56:41 <edwardk> dolio: fixing
10:57:09 <Cale> (where for most practical purposes, compact is the same as finite :)
10:57:47 <dcoutts_> Baughn: it's also not clear what it'd mean if you could serialise arbitrary functions, does it mean you have to serialise all the binary code in the base package along with it? if not, where does one stop?
10:58:21 <Baughn> dcoutts_: It would suffice to serialize them such that they could only be loaded by the same binary, in this case
10:58:36 <Cale> I'd personally be quite happy with the ability to serialise the continuation in IO into a new binary executable file :)
10:58:38 <sclv_> awesame: why do you want to write a webserver instead of just a cgi app?
10:58:43 <sclv_> also, there's mini-http
10:59:04 <Baughn> Cale: Yes, okay. I'm trying to implement state transactions for lb, using the old "write a log first" method - given that the log is effectively a list of transform functions, that made sense to me. ;)
10:59:27 <sclv_> Baughn: there's a fancy trick happs uses to do this, but it involves template haskell and such, and is rather limited.
10:59:34 <jadrian> lispy: well * -> *  is the rank of a type constructor that can only be applied to one type (constant or variable type)
10:59:44 <edwardk> dolio: oh yeah i needed 'swap' thats why. i'll point out the connection to sequence though
10:59:49 <Baughn> Besides that, is there an obvious typeclass (or something) I should be using for deriving datatypes this way?
11:00:01 <sclv_> it involves reifying each function as a constructor.
11:00:11 <dolio> edwardk: Ah.
11:00:17 <awesame> sclv_: for my app, I need a couple simple servers.  they're not actually serving HTML, it's just that HTTP is a convenient protocol.
11:00:22 <Baughn> That is, encoding "transform from a -> a", in general? Anything that already does that sort of thing?
11:00:47 <Saizan> Baughn: take a look at HAppS-State maybe
11:01:07 <lispy> jadrian: I think rank applies to functions too...at least one paper I was reading said something baout this
11:01:22 <sclv_> awesame: you can also roll a mini-server directly from sockets, for very simple things.
11:01:25 <Baughn> Saizan: http://happs.org/ <-- This?
11:01:46 <Saizan> Baughn: it does what it can to "serialize" events, so he can rerun them on failure etc..
11:01:49 <Saizan> *it
11:01:53 <Baughn> ..hmm. A hard refresh fixed it, but that looked odd
11:01:55 * lispy tries to find the paper
11:01:58 <awesame> sclv_: if there's a library that will handle the HTTP request and response parsing for me, that sounds good...
11:02:08 <jadrian> lispy: but my point is that it's not really about rank
11:02:20 <jadrian> lispy: I might want ranks like  *->*->*
11:02:22 <edwardk> dolio: I had some spare time on my hands the other day and started: http://comonad.com/haskell/ctl/dist/doc/html/ctl/
11:02:27 <jadrian> lispy: as in the case of (,)
11:02:39 <lispy> jadrian: but (,) takes an alpha and a beta
11:02:42 <dolio> Wow. That's a lot of modules.
11:02:42 <jadrian> lispy: I want (,) Int Int = (Int,Int)
11:02:50 <lispy> data MyTuple a = (a,a)
11:02:53 <jadrian> lispy: no (,) takes two types
11:02:57 <lispy> check the kind of MyTuple
11:03:08 <edwardk> dolio: which i guess at this point could be called category-extras-extras ;)
11:03:10 <awesame> hey, I know the author of Network.MiniHTTP!
11:03:13 <awesame> small world
11:03:17 <jadrian> lispy: and how would I do (Int,Char)
11:03:30 <Baughn> Saizan: Looks good, thanks
11:03:34 <dolio> edwardk: I think you already have all the stuff in category-extras in there.
11:03:35 <lispy> jadrian: data MyTuple a = (Int, a)
11:03:56 <jadrian> lispy: now I see your point
11:04:05 <sclv_> cool! I know he'd love more users putting it thru the paces.
11:04:08 <lispy> jadrian: I should be saying data MyTuple a = T Int a, but I thnk you get what I meant :)
11:04:12 <jadrian> lispy: and I think you're right
11:04:14 <dolio> edwardk: Except Stream and InfiniteTree, but those are sepcial cases of Cofree.
11:04:16 <edwardk> dolio: hrmm, you're probably right. as i was writing the comonad stuff i kinda had to recreate just about everything i think that category-extras covered
11:04:18 <edwardk> yeah
11:04:29 <edwardk> Stream i'll add because it has a nice intuitive flavor to it
11:04:36 <jadrian> lispy: yes yes indeed, like I said, not just very familiar with kinds sorry it took me this long to see your point
11:04:49 <lispy> jadrian: no problem, honestly I thought I was missing something
11:05:11 <edwardk> i'm also going to add cofree monad/free monad dual annihilation (which i'll blog up later tonight) =)
11:05:34 <jadrian> lispy: I'm still not absolutely sure though, because it's handy to have type constructors that can take two random types
11:05:35 <edwardk> er cofree comonad
11:06:08 <jadrian> lispy: with (,) I can do (Int,Char)    or   (Int,Int)   or (alpha, Int) or (alpha, alpha)
11:06:11 <lispy> jadrian: Probably what you need are type classes and to use the rank-2 constructor
11:06:23 <jadrian> lispy: I just want to remove the ability to do (alpha, beta)
11:06:33 <dolio> edwardk: Looks like I'm out of a job. :)
11:06:35 <edwardk> not sure about the understandability of the copointed endofunctor comonad composition stuff i think that'll scare people away from the library
11:06:36 <lispy> jadrian: type classes allow you to place "constraints" or "bounds" on the type variables.
11:06:57 <edwardk> dolio: i don't want to step on category-extras, i just got bored
11:07:07 <jadrian> lispy: ah wait, I'm not trying to implement it... just want a name for such types
11:07:17 <dolio> edwardk: Yours is already better. Put it on hackage. :)
11:07:18 <jadrian> lispy: that only have on type variable
11:07:40 <jadrian> lispy: and monomorphic doesn't cut it because it means no type variables
11:07:49 <edwardk> do you want me to replace category-extras with it or put it up as it is as 'ctl'? its really more categorical than just comonadic
11:08:47 <lispy> jadrian: Well, it sounds like you want to have n type variables and then place constraints on them
11:08:52 <edwardk> i'll go through and merge the rest of the category-extras stuff, and credit you and dave then
11:09:15 <dolio> edwardk: That sounds like a good plan.
11:09:33 <lispy> jadrian: with one special case where  data MyTuple a b ..., and a = b, so I'm saying, "Oh, that's just equivalent to getting rid of the b"
11:10:03 <edwardk> note though that i kept the natural transformation terms in this version because they made the distributive laws clearer
11:10:23 <edwardk> so there are a few subtle differences, not that i think you have any users other than me, but hey
11:11:36 <edwardk> i also need to finish adding gibbons-style bifunctor folds, which really is just the same thing as the existing ones, but they would permit the fusion of fmap/bimap with generalized hylomorphisms
11:11:44 <jadrian> lispy: I also don't want  a -> b
11:11:46 <dolio> edwardk: Yeah, I don't think there are many users of any of the stuff in the existing package.
11:12:03 <edwardk> i did the first few (see Control.Morphism.Hylo and Control.Morphism.Cata)
11:12:07 <jadrian> lispy:  my language can have  a x a -> a
11:12:23 <jadrian> lispy:  my language can have  Int x a -> Char -> (a -> Int)
11:12:25 <jadrian> etc etc
11:12:38 <IsoPallo> Hi! I'm a heskell newbie and I'm still wondering how the memory management is supposed to work... For example if I want to modify a Tree and create a new one copying an exisiting one with modifications will the garbage collector know to throw away the old one later if I don't actually use the new one for a while?
11:12:45 <jadrian> lispy: just not types with more than one type variable, it's not just about tuples
11:12:51 <lispy> jadrian: I would really encourage you to read this: http://en.wikipedia.org/wiki/Polymorphism_(computer_science)#Polymorphism_in_strongly-typed_languages
11:12:52 <lambdabot> http://tinyurl.com/5nzkq
11:12:57 <jadrian> lispy: thanks!!
11:13:15 <lispy> jadrian: actually that page isn't all the well written
11:13:30 <edwardk> iso: the short answer is 'yes', the long answer is '99% of the time, yes' ;)
11:13:37 <Baughn> IsoPallo: If you don't keep any references to the old one around, then it'll get thrown out just fine
11:14:05 <IsoPallo> But isn't the new one a refenrence to the old as it it created based on the values in the old?
11:14:22 <Baughn> IsoPallo: It's a reference to /part/ of the old one. Not all of it.
11:14:25 <IsoPallo> At least as long as the new tree is not forced to evaluate.
11:14:32 <Baughn> IsoPallo: (And those parts are also part of the new one, so..)
11:15:10 <edwardk> dolio: the other thing is functor composition is harder to use in mine because  i need to support different compositions, one for adjunction-oriented composition, and one for pointed-monad and monad-pointed and one for monad-monad-distributive composition.
11:15:20 <Baughn> IsoPallo: You may be right that more than needed of the old one will stay around until you actually /use/ the new one, but then again, under those circumstances the new one won't use any memory either, not having been constructed and all
11:15:29 <edwardk> so i lose the nice 'O' constructor
11:15:43 <dolio> Hmm.
11:16:01 <edwardk> stole a trick from something ski posted in here that mark jones did back in '93 on composing monads so i could get those for composing comonads
11:16:03 <dolio> I was eventually planning on losing O in favor of depending on TypeCompose.
11:16:20 <lispy> jadrian: this is a very long paper, but the first 10-20 pages I think will be of interest you probably don't need the whole thing: http://research.microsoft.com/~simonpj/papers/higher-rank/
11:16:21 <lambdabot> Title: Simon Peyton Jones: papers
11:16:24 <dolio> Which already does some of that stuff.
11:16:34 <edwardk> dolio: where is TypeCompose?
11:16:52 <edwardk> ah found it
11:16:54 <dolio> Contravariant functors, functor composition, monad composition with distributive laws...
11:17:08 <edwardk> ah so basically the stuff i spent yesterday writing ;)
11:17:34 <edwardk> i'll see if its possible for me to change over to depend on that then
11:19:13 <IsoPallo> BAughn: Ok. Thanks. I was just reading so much stuff about all this neccesity ti in-place update stuff that I became paranoid :)
11:20:00 <Baughn> IsoPallo: Before you get /too/ paranoid, read http://www.google.com/url?sa=t&ct=res&cd=1&url=http%3A%2F%2Fwww.cs.cmu.edu%2F~rwh%2Ftheses%2Fokasaki.pdf&ei=R7gYSLiTBonA0wSb9rT9Cg&usg=AFQjCNGXKQqKJho73FE372EjGzUoeSJm1w&sig2=BEwyBsMUJjBFfZ4ArP8VoA
11:20:01 <lambdabot> http://tinyurl.com/674mtc
11:20:05 <lispy> dons: why is d.h.o so slow for darcs getting?  I thought this was going to get faster, right?
11:20:13 * Baughn cries for the lack of easily copyable links
11:20:27 <lispy> Baughn: why?  lambdabot makes tinyurls
11:20:39 <lispy> Baughn: see 11:19 <lambdabot> http://tinyurl.com/674mtc
11:20:42 <Baughn> lispy: Which is a bit pointless when I've just posted the long one
11:21:00 <lispy> not really, because now I can use the nice short one very easily
11:21:05 <edwardk> dolio: any other comonads you can think of to add? i've got a zipper, supply and a couple others going in, but still looking for toys =)
11:21:07 <Baughn> But no, I was just annoyed that google didn't just give me http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
11:21:24 <edwardk> dolio: also do you have any short fragments you'd like to contribute to a 'cofib' suite?
11:21:47 <edwardk> you're a lot better at tracking down practical examples of this than I
11:22:11 <dolio> edwardk: Heh. Nothing I can think of off the top of my head. I've not looked at comonads much.
11:22:58 <Baughn> IsoPallo: Executive summary: Imperative/mutable datastructures are highly efficient, persistent (purely functional) ones are not, laziness allows you to get back a lot of efficiency by mutating data structureswhen the computer isn't looking
11:23:35 <dons> while retaining the persitence, safety, and flexibility of pure structures
11:24:09 <Baughn> Yep
11:24:11 <dolio> edwardk: I recall reading about comonads with regard to attribute grammars and dataflow programming, but it's been too long since I read those to suggest anything.
11:24:29 <dolio> I think the latter was just using a stream comonad.
11:25:08 <dolio> Or, perhaps more accurately, a stream pointer, kind of like the array pointer the sigfpe talked about.
11:25:39 <dolio> Or a stream zipper, perhaps.
11:25:57 <gwern> "Note to Douglas Hofstadter and Raymond Smullyan: Excessive self reference is as dangerous as smoking." McCarthy
11:26:54 <gwern> '
11:26:54 <gwern> '
11:26:54 <gwern> Everyone needs computer programming. It will be the way we speak to the servants.
11:27:46 <profmakx> gwern, actually i found the prologue to GEB quite annoying
11:28:04 <gwern> how dare you!
11:28:23 * gwern slices the infidel's head off. hofstadteru akbar!
11:28:26 <edwardk> dolio: yeah i figured out a comonadic way to propagate attributes in an attribute grammar, i figured it was common knowledge, but yeah i think thats a good example
11:29:28 <edwardk> dolio: i have a zipper comonad that i figure would make a nice 1d automata example, since you can see 'left and right' of you as you go through and evaluate your local state transition
11:30:15 <Heffalump> ooh, a real use for comonads?
11:30:35 <edwardk> heff: hence why i figured a 'cofib' suite would be a good idea
11:30:59 <edwardk> a nice supply example, a simple comonadic sudoku solver that evaluates its updates to the entire board all at once
11:31:28 <edwardk> looking for a good game where both players make a decision and then tell each other their answers at the same time, do you know one? its on the tip of my tongue
11:31:43 <Heffalump> rock, paper, scissors?
11:31:51 <edwardk> heff: heh that works =)
11:32:09 <edwardk> comonadic roshambo it is
11:32:14 <lispy> edwardk: poker
11:32:25 <edwardk> lispy: another good one
11:32:32 <IsoPallo> 6Nimmt
11:32:52 <lispy> edwardk: although, backjack is probably easier to code up
11:32:56 <edwardk> lispy: though its not entirely parallel since you raise, etc in sequence
11:33:02 <lispy> edwardk: right, you do both
11:33:32 <edwardk> roshambo is probably a nicer minimalist example
11:33:46 <IsoPallo> 6Nimmt is all parallel, plus I'd like to see an online version of it :)
11:34:31 <lispy> IsoPallo: how do you say the name?  six-N-immt doesn't sonud like anything to me
11:34:45 <IsoPallo> Sex-Nimmt
11:35:07 <IsoPallo> It's a german cardgame.
11:35:13 <edwardk> another kind of example i'm looking for is something like an MPI comonad, where you have some common distributed state and everyone updates their piece in isolation and passes messages
11:35:27 <lispy> IsoPallo: Ah, that explains why it looks like it should make sense in english, but doesn't quite :)
11:36:01 <edwardk> IsoPallo: never heard of it, will check
11:36:12 <DRMacIver> The new graphics library looks shiny.
11:37:17 <olsner> googling for take-6 card game produces some hits
11:37:42 <edwardk> nice. these are all good examples =)
11:37:59 <tromp> that would be sechs, not sex, in german
11:38:39 <lispy> tromp: but i think german sechs sounds a lot like english sex
11:38:52 <edwardk> lispy: too easy, no points
11:39:17 <edwardk> @quote lispy but i think german sechs sounds a lot like english sex
11:39:18 <lambdabot> No quotes match. My mind is going. I can feel it.
11:39:26 <edwardk> @remember lispy but i think german sechs sounds a lot like english sex
11:39:26 <lambdabot> It is stored.
11:39:31 <mauke> „zegs“
11:40:16 <lispy> i don't speak german but I was learning it for a while
11:40:32 <byorgey> DRMacIver: thanks =)
11:44:14 <Philippa> edwardk: this is probably a bit much like streams, but have you looked at comonadic FRP?
11:45:55 <edwardk> Philippa: do you have any specific examples or do you mean as an avenue to explore?
11:46:33 <edwardk> Philippa: it does sound like a very good fit though
11:47:03 * lispy envisions edwardk and conal getting together to talk about it
11:47:13 <edwardk> basically i figured i've been sitting on comonad.com long enough. I should try to get someone to use them ;)
11:47:55 <Philippa> edwardk: as an avenue to explore
11:48:15 <edwardk> Philippa: noted as another problem to keep me up weekends =)
11:48:26 <Philippa> it'd be interesting to see how it compares to the equivalent monadic approach, and perhaps whether it makes any sense to use a structure that's in some sense 'bimonadic'
11:49:00 <lispy> bimadic
11:49:03 <edwardk> Philippa: you're basically talking about BiKleisli arrows at that point. just need a distributive law of the comonad over the monad or vice versa
11:49:17 <lispy> monad | bimad | comonad
11:49:26 <Philippa> sure - but does it turn out to be useful? :-)
11:50:20 <olsner> bimad?
11:50:20 <edwardk> Philippa: check sigfpe's post before last, they are interesting, not sure about the bikleisli stuff performing if you use IO as the monad though. other monads it seems fine for. in fact my generalized hylomorphism is a form of interoperation between a monad and comonad.
11:50:47 <edwardk> abusing a monad to build up a structure and a comonad to tear it down
11:52:59 <edwardk> Lispy I think technically your only bimads are 'Identity' and the ((,)e) Writer/Comonad.Reader
11:54:04 <edwardk> there are a lot of BiKleisli arrows though
11:56:57 <edwardk> BiKleisli is mentioned in http://www.jucs.org/jucs_11_7/signals_and_comonads/jucs_11_7_1311_1327_vene.pdf
11:57:05 <lambdabot> http://tinyurl.com/6a3nzk
12:02:28 <saml> how can I make my monad into MonadIO ?  instance MonadIO TI where liftIO = ??
12:02:51 <saml> newtype TI a = TI (\s n -> (s, n, a))
12:03:01 <saml> TI is custom State monad
12:03:12 <Philippa> you probably can't
12:03:12 <sclv_> is TI a monad transformer though?
12:03:20 <sclv_> only monad transformers can be made monadIO
12:03:21 <bos> you have to have the IO monad inside or underneath somewhere.
12:03:48 <Philippa> sclv: is that an actual requirement of the class? Because there're sensible monads-that-do-IO that aren't built as transformers
12:03:57 <bos> no, it isn't.
12:04:05 <Philippa> thought not
12:04:33 <sclv_> damn imprecision again.
12:04:45 <saml> so, in TI monad, there's no way to print stuff out? for debugging purposes. and trace won't do because i'm not using the variable i'm tracing
12:04:50 <olsner> liftIO = return . unsafePerformIO :P
12:04:56 <dzlk> Anyone had ghc-6.8 fail by trying to give -fwrapv to a gcc version that doesn't support it?
12:05:17 <bos> saml: use the writer monad transformer on top.
12:05:52 <Philippa> the writer approach is more flexible, anyway - you can wire the output somewhere else easily
12:05:55 <sclv_> alternately "trace 'errmsg' $ return ()" will work, no?
12:06:10 <bos> yes, you can easily write a traceM.
12:06:16 <dzlk> (Oh, wait, I think I just realized why it's doing that. Nevermind.)
12:07:07 <ziman> @hoogle [m a] -> m [a]
12:07:07 <lambdabot> Prelude.head :: [a] -> a
12:07:07 <lambdabot> Prelude.last :: [a] -> a
12:07:07 <lambdabot> Data.List.head :: [a] -> a
12:07:09 <dons> ?bug
12:07:10 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
12:07:20 <saml> traceM msg = trace msg $ return ()
12:08:12 <bos> the usual thing to do, though, would be to combine a WriterT with a DList or a Sequence for efficient, pure logging.
12:08:32 <edwardk> hrmm i wonder if you could use a parameterized comonad to track what 'signals' a comonadic frp fragment used.
12:09:35 <byorgey> @type sequence
12:09:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:09:39 <byorgey> ziman: ^^
12:11:40 <ziman> byorgey, thanks!
12:11:49 <byorgey> sure =)
12:13:23 <zeno`> @hoogle fmap
12:13:23 <lambdabot> Prelude.fmap :: Functor f => (a -> b) -> f a -> f b
12:13:23 <lambdabot> Control.Monad.fmap :: Functor f => (a -> b) -> f a -> f b
12:13:23 <lambdabot> Control.Monad.Instances.fmap :: Functor f => (a -> b) -> f a -> f b
12:18:10 <hellige> @src (.)
12:18:10 <lambdabot> (f . g) x = f (g x)
12:21:19 <Deewiant> @src (->) fmap
12:21:20 <lambdabot> fmap = (.)
12:21:34 <Beelsebob> Hey, who here uses ghc on a Mac?
12:21:39 <sclv_> yep
12:22:54 <Beelsebob> and does anyone know what version (if any) does not require the end user to have any extra frameworks installed (like previous versions required Readline.framework)
12:23:07 <conal> DRMacIver: what shiny new graphics library?
12:23:57 <DRMacIver> http://byorgey.wordpress.com/2008/04/30/new-haskell-diagrams-library/
12:23:58 <lambdabot> Title: New Haskell diagrams library  blog :: Brent -> [String], http://tinyurl.com/5675xp
12:24:06 <conal> DRMacIver: thx!
12:24:11 <Baughn> Beelsebob: Well, basically none of them
12:24:14 <sclv_> oh dear, i think they've only still got that stuff in head?
12:24:17 <Beelsebob> Baughn: fail
12:24:20 <Baughn> Beelsebob: They all require /something/, though perhaps not a framework as such
12:24:50 <Beelsebob> Baughn: note, by end user, I mean end user of the generated program, not end user of the compiler
12:25:04 <Beelsebob> still the same story?
12:25:28 <olsner> iirc, haskell programs require libgmp and libreadline
12:25:30 <Baughn> Beelsebob: Then, all of them?
12:25:48 <sclv_> libgmp isn't needed on 10.5 i think.
12:25:51 <Beelsebob> olsner: so none of them statically link them in?
12:25:56 <Baughn> Beelsebob: The one I've got links only to libSystem and libgcc. Not even libc.. which is suspicious
12:26:07 <Beelsebob> Baughn: interesting
12:26:11 * Beelsebob ponders
12:26:12 <allbery_b> staticaly linked?
12:26:13 <Baughn> Beelsebob: Well, see what otool -L reports
12:26:22 <Beelsebob> the only way to check this I think is to try the binaries on machines without ghc on
12:26:23 <conal> byorgey: lovely!
12:26:32 <Beelsebob> or even just base OS X installs
12:26:35 <Baughn> Beelsebob: Doesn't seem to /be/ a libc, I guess
12:26:42 <olsner> well, ditto the otool tip ... that's the way to make sure what's being used
12:26:48 <byorgey> conal: thanks! =)
12:26:56 <kpreid> Baughn: iirc, libSystem incorporates what would be libc elsewhere
12:27:10 <allbery_b> anyway, I think there's some chance the next release will not need readline; turns out there's a simple readline clone in Haskell (System.Console.SimpleLineEditor?) but the ghc configure stuff isn;t smart enough to use it when there's no readline
12:27:16 <Baughn> kpreid: Quite. I do have a libc.dylib, but it's just a symlink
12:27:57 <conal> is Cairo going to get separated from gtk2hs and have its own cabal package?
12:28:10 <sclv_> i'd actually be surprised if binaries that didn't use readline still linked against it actually.
12:28:11 <dcoutts_> conal: yes, though when is less clear
12:28:36 <dcoutts_> conal: the improvements in cabal necessary to be able to cabalise cairo are part of a GSoC project this summer
12:28:46 <olsner> maybe readline was only used by ghc itself and not its linked programs last time I checked
12:28:52 <conal> dcoutts_: oh!  glad to hear.  thanks.
12:29:12 <sclv_> as i recall, with a broken readline you can even get a ghc... just one where ghci was borked?
12:33:21 <FalconNL> Can anyone tell if it's possible to write (\dc r -> do {w <- varGet world; drawWorld w dc r}) in a point-free style? All the variations with =<< and >>= I tried failed and lambdabot chokes on the {
12:33:52 <byorgey> FalconNL: sure it is.
12:34:01 <Deewiant> @. pl undo \dc r -> do { w <- varGet world; drawWorld w dc r}
12:34:02 <lambdabot> ((varGet world >>=) .) . flip . flip drawWorld
12:34:16 <Baughn> FalconNL: It chokes on the do, not the { as such
12:34:20 <byorgey> FalconNL: first of all, that do block is equivalent to varGet world >>= \w -> drawWodls w dc r
12:34:29 <byorgey> *drawWorld
12:34:30 <conal> byorgey: i left two comments -- in moderation.
12:34:33 <Deewiant> FalconNL: @undo helps
12:34:39 <FalconNL> thanks all
12:35:00 <byorgey> conal: thanks, I'll go approve them
12:35:15 <Deewiant> apart from pattern matching, every function can be written point-free?
12:35:44 <conal> Deewiant: every function expressible in lambda calculus can be written point-free
12:35:47 <byorgey> conal: ah, cool idea re: continuous time resolution.
12:35:52 <Baughn> Deewiant: Not that you'd /want/ to
12:36:19 <Deewiant> conal: and is that definition different to mine? :-)
12:36:25 <Deewiant> Baughn: :-)
12:36:28 <hellige> incidentally, is there a good list of pointfree expression patterns, to help develop intuition?
12:36:43 <byorgey> conal: I mean, you could do that currently as well, I was just giving an example, but if I put in stuff to explicitly support animation I will keep your suggestion in mind.
12:36:47 <hellige> like, i don't have good intuition for expressions like (. const) and so on...
12:37:04 <Deewiant> in general I don't have good intuition for partially-applied (.)
12:37:34 <conal> byorgey: great.  i think discrete time is an old habit from imperative programming.
12:37:36 <hellige> Deewiant: it seems like common patterns could easily be enumerated, even if it gets difficult in general.
12:38:05 <hellige> like, it's easy enough to understand that (>>) = (. const) . (>>=)
12:38:10 <conal> byorgey: because imperative programming has an implicit model of change, which is discrete.
12:38:16 <Deewiant> \x -> f . g x becomes (f .) . g
12:38:18 <byorgey> conal: right.
12:38:34 <conal> Deewiant: yes, unless you meant computable functions.
12:38:42 <Deewiant> that's one I still don't understand without going it through every time but it comes up often
12:38:50 <Deewiant> or rather, I can't intuit
12:39:06 <hellige> Deewiant: right. so basically, i'm just wondering whether someone has written up a cheat sheet of common rewrites.
12:39:11 <Deewiant> conal: I see. Are such functions generally useful, though? :-)
12:39:24 <Deewiant> hellige: not to my knowledge, but then I don't know that much when it comes to Haskell. :-)
12:39:24 <conal> Deewiant: sure, depending on what you're doing.
12:39:38 <sclv_> there's a list of handy point-free combinators on the haskell wiki tho.
12:39:51 <Deewiant> conal: can you give an example? I'm not sure what you're on about, to be honest.
12:40:03 <hellige> sclv_: yeah, i think that's the closest thing i've seen, but it seems to focus more on tricky things and less on common examples.
12:40:50 <hellige> maybe i'll start a more basic list. it seems like a good way to develop intuition, at least...
12:41:37 <Botje> you probably want to look at join and liftM2 in the ((->) r) monad
12:41:38 <conal> Deewiant: the halting problem, for instance.
12:41:59 <Botje> @pl \x -> (show x) == (show $ reverse x)
12:42:00 <lambdabot> liftM2 (==) show (show . reverse)
12:44:08 <Baughn> hellige: Oh, there already is such a list
12:44:23 <Baughn> http://haskell.org/haskellwiki/Points-free_style
12:44:36 <vixey> ((==)`on`show) x (reverse x)
12:45:06 <hellige> Baughn: i've seen that page
12:45:29 <conal> liftA2 ((==)`on`show) id reverse
12:45:36 <Baughn>  > pl \f g (a,b) -> (f a, g b)
12:45:39 <hellige> it's not quite what i have in mind...
12:45:44 <Baughn> > pl \f g (a,b) -> (f a, g b) -- How about this?
12:45:44 <lambdabot>  Parse error at "\f" (column 4)
12:46:00 <Baughn> ..never mind. Wrong window.
12:46:01 <vixey> ooh I like that
12:46:17 <vixey> Where is all the A stuff defined?
12:46:24 <edwardk> @type liftM2 ((==) `on` show) reverse id
12:46:25 <lambdabot> forall a. (Show a) => [a] -> Bool
12:46:26 <conal> Control.Applicative
12:46:40 <conal> @hoogle liftA2
12:46:41 <lambdabot> Control.Applicative.liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
12:46:41 <edwardk> heh conal beat me to it
12:47:09 <Valodim> <interactive>: internal error: allocGroup: requested zero blocks
12:47:10 <Valodim>     (GHC version 6.8.2 for i386_unknown_mingw32)
12:47:10 <Valodim>     Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
12:47:10 <Valodim> abnormal program termination
12:47:11 <lambdabot> Title: ReportABug - GHC - Trac
12:47:13 <Baughn> @pl \f g (a,b) -> ((a,b)(f a, g b))
12:47:13 <lambdabot> flip flip snd . (ap .) . flip flip fst . (((.) . liftM2 ap (,)) .) . flip . (((.) . (,)) .)
12:47:15 <Valodim> is this to be taken seriously?
12:47:18 <conal> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html
12:47:19 <lambdabot> http://tinyurl.com/yrwujr
12:47:37 <Cale> Valodim: Probably.
12:47:44 <Baughn> Valodim: Yes, unless you've done something horrible
12:48:02 <Valodim> well I don't know. it's a whole bunch of patchwork... :P
12:48:19 <Baughn> Valodim: Have you used any function prefixed with unsafe, or touched the FFI?
12:48:24 <Valodim> nope
12:48:31 <Baughn> Then it's probably genuine
12:48:53 <Valodim> working with the wxHaskell lib though
12:49:28 <Baughn> Windows is, as always, a second-class citizen. The chance of it being a real bug is much higher than on any other OS.
12:56:06 <Valodim> ah, it tried to ByteString.hGet a negative number
12:58:10 <dons> Valodim: hmm.
12:58:33 <dons> dcoutts_: we should do asserts on this Int-indexed things. its a bit sad the underlying primops aren't Word# indexed
12:59:05 <dons> Valodim: can you mail me a test program? I'd like to sort out this Int indexing stuff a bit better. dons <> galois.com
12:59:28 <dcoutts_> dons: mm, yes.
12:59:56 <dons> dcoutts_: the ndp library has a nice inlinable safety check we can borrow
13:00:13 <dons> (you can actually compile uvector with -funsafe to get them boiled away)
13:00:39 <dcoutts_> dons: so it's some primitive thing? How is it different from assert?
13:00:49 <dcoutts_> assert gets removed at -O
13:01:03 <dons> yeah, we could just use asserts. but we may want them in with or without -O
13:01:05 <dons> primop  ReadByteArrayOp_Word "readWordArray#" GenPrimOp MutByteArr# s -> Int# -> State# s -> (# State# s, Word# #)
13:01:14 <dons> i wonder why the underlying primitives use Int
13:01:39 <dons> since that bubbles all the way up to user space
13:01:52 <Valodim> dons: http://hpaste.org/7283
13:02:40 <Valodim> sorry, please disregard the two lines with binarymode and buffering, they are irrelevant
13:03:08 <dons> oh wow, we pass that all the way through to the rts.
13:05:09 <Valodim> annotated again, added the import and removed the two lines, the BS part is slightly ambiguous :P
13:11:43 <dcoutts_> dons: I'd like to see a common portable low level byte array interface, something to unify ghc's ByteArr# and the equivalents in hugs and nhc98
13:12:12 <dcoutts_> it's slightly weird that we have a common api for *foreign* byte arrays
13:12:29 <dcoutts_> but not one for native ones, though the native ones have been around since the beginning
13:13:55 <keseldude> Hello, I'm looking for a quality keyboard, and I'm hoping you'll be able to assist me :). I have my eye on DAS and happy hacking pro, but I'm open to any and all suggestions.
13:17:16 <Valodim> hahaha, Das Keyboard feature list
13:17:19 <Valodim> - Black color with matching black cable, Darth Vader approved
13:19:00 <keseldude> :P
13:19:20 <keseldude> I just need something that I can use for lots and lots of coding.
13:20:16 <dolio> Get an optimus, of course.
13:20:34 <dons> keseldude: i like the kinesis, happy hacking is also ok.
13:20:44 <jsnx> @seen Cale
13:20:44 <lambdabot> Cale is in #haskell-overflow, #ghc and #haskell. I last heard Cale speak 33m 7s ago.
13:20:50 <dons> if you're doing lots of coding, then RSI can be an issue, so something like a kinesis might be a good investment
13:20:59 <dons> the keyboard is one of the tools of our trade.
13:21:07 <dons> so it can make sense to invest
13:21:07 <Cale> jsnx: hm?
13:21:08 <keseldude> :)
13:21:36 <Valodim> hahaha, optimus
13:21:59 * jewel is a maltron fan
13:22:31 <keseldude> I'm not sure for how long I will be using the keyboard, though, as I'm getting a laptop for college :/.
13:23:17 <Valodim> and you still consider buying a 250$+ keyboard?
13:23:20 <Baughn> keseldude: Might be better off getting a powerball, then?
13:23:28 * DuClare uses the Natural Ergonomic 4000.
13:23:33 <DuClare> {/g 32
13:24:00 <jsnx> DuClare: your color escapes have escaped!
13:24:14 <DuClare> 'cept it wasn't a color escape
13:24:48 <vegai> keytronics are rather cheap and good
13:24:51 <DuClare> Alias for /window goto #, with a typoed character in front of it. :)
13:26:49 <keseldude> Thanks for the suggestions. :)
13:26:59 <keseldude> looking into them now...
13:27:11 <edwardk> shapr swears by his kinesis, but i still can't get used to it
13:28:12 <edwardk> spent/spend too much time in vi, my left hand never really stays on the home row.
13:31:17 <dcoutts_> @seen byorgey
13:31:17 <lambdabot> byorgey is in ##logic, #xmonad, #haskell-blah and #haskell. I last heard byorgey speak 52m 58s ago.
13:31:25 <byorgey> hey dcoutts_
13:31:43 <dcoutts_> byorgey: just reading your cairo blog post
13:31:56 <dcoutts_> byorgey: and I'll go make you that repo on code.haskell.org...
13:32:00 <sauxdado> i'm guessing the most comfortable keyboards are those that are split into two completely independent halves that you can put on the arms of your hopefully very comfortable chair.
13:32:06 <byorgey> dcoutts_: ah, thanks =)
13:32:15 <byorgey> hehe, I kind of figured an admin might read it =)
13:32:45 <dcoutts_> byorgey: I've got a question/comment, C.closePath? that's the underlying Cairo action right?
13:32:52 <byorgey> dcoutts_: right.
13:33:19 <dcoutts_> byorgey: and why is the bounding not right if we do an ordinary poly?
13:33:39 <byorgey> dcoutts_: oh, it's just the way I've implemented regular polygons in my library.
13:33:40 <Valodim> isn't the "Das Keyboard" essentially the same as the Cherry G80?
13:33:41 <Valodim> http://www.cherry.de/english/products/keyboards_g80-3000.htm
13:33:44 <lambdabot> Title: Cherry - G80-3000
13:33:48 <byorgey> it's nothing inherent in Cairo.
13:34:04 <dcoutts_> byorgey: don't you just need to track the min and max x and y coords of the points?
13:34:19 <dcoutts_> byorgey: well, + something for line width I guess
13:34:25 <byorgey> dcoutts_: well, for polygons, yes
13:34:55 <byorgey> dcoutts_: and I may well end up rethinking this when I get around to arbitrary polygons
13:34:55 <dcoutts_> byorgey: but it is a polygon, I'm missing something
13:35:40 <byorgey> dcoutts_: yes, you're right, it would be very easy to have better bounding boxes for polygons, and I definitely will. =)
13:36:06 <dcoutts_> byorgey: so a general approach to a pure wrapping the lineTo/moveTo stuff might be to have a list of lineTo, moveTo whatever
13:36:18 <byorgey> it's just that when I hacked up regular polygons, rather than think too hard I just made a 2x2 bounding box, and put the vertices on the circumference of a radius-1 circle =)
13:36:24 <dcoutts_> byorgey: but then have those as a parameter to a stroke function
13:36:48 <dcoutts_> byorgey: one of the most common bugs is forgetting the stroke, the types should make it impossible
13:36:53 <dcoutts_> fill or stroke
13:37:21 <byorgey> dcoutts_: yeah, I plan to provide a function where you can pass a list of vertices and get a polygon
13:37:50 <dcoutts_> byorgey: or more generally, the various line function, including curves
13:37:50 <byorgey> dcoutts_: really, most of the time, users of the library shouldn't need to use the low-level moveto/lineto sort of stuff anyway
13:38:00 <byorgey> dcoutts_: ah, indeed
13:38:24 <dcoutts_> byorgey: aye, probably so, but it's nice to have it in a type safe way for when you do want/need it
13:38:30 <byorgey> true.
13:38:48 <dcoutts_> fill, stroke :: Path -> Picture
13:39:09 <dcoutts_> and then line, move, curve etc are primitives for Path
13:39:38 <dcoutts_> byorgey: fill and stroke convert a Path to a picture/diagram, whatever your normal type is
13:40:01 <byorgey> dcoutts_: yeah, that's a good idea
13:40:22 <byorgey> dcoutts_: I basically already have that function, 'draw', except it's the wrong type =)
13:41:29 <dcoutts_> byorgey: ok, project created
13:41:35 <byorgey> huzzah!
13:41:38 <byorgey> dcoutts_++
13:41:49 <byorgey> er, dcoutts++
13:41:52 <dcoutts_> :-)
13:44:48 <byorgey> ok, the darcs repo for diagrams is up at http://code.haskell.org/diagrams/, for anyone who's interested
13:44:50 <lambdabot> Title: Index of /diagrams
13:46:15 <dcoutts_> byorgey: ooh...
13:46:22 <dcoutts_> byorgey: cairo_path_extents ()
13:46:33 <byorgey> dcoutts_: what's that?
13:46:54 <dcoutts_> byorgey: a new function in cairo 1.6, so you could handle arbitrary path segments without having to track the bounding box yourself
13:47:31 <byorgey> dcoutts_: ah, neat
13:48:24 <dcoutts_> byorgey: oh, and there are also ones for doing strok and fill and returing the inked extents, which includes the stroke width, which is usually what you want
13:48:43 <byorgey> dcoutts_: ah, yeah, that's cool
13:49:08 <byorgey> there are already issues with strokes going off the boundaries of the diagram =)
13:49:59 <byorgey> the only problem is that I need to know the bounding box *before* doing rendering, since I need the bounding box sizes to figure out where everything should go
13:51:07 <dcoutts_> ah right
14:24:05 <Tycho7> 'afternoon everyone
14:25:43 <Tycho7> Has anyone here had experience with servers using STM?
14:25:56 <dons> yeah, some.
14:26:02 <Lemmih> Tycho7: Kinda. What's on your mind?
14:31:50 <lispy> byorgey: what if you render to a unit bounding box and then scale that to fit reality?
14:32:06 <lispy> byorgey: sort of like texture mapping :)
14:34:29 <Tycho7> Lemmih: So, when my server connects to a client and receives a message, it forkIO's a process that reads the message, converts it into usable data, then calls a method on that data that does stuff with files
14:35:08 <Tycho7> Lemmih: I'm trying to figure out at what level I should be using STM
14:35:38 <Tycho7> Lemmih: I thought about using at the file writing level, but I wasn't sure
14:36:19 <Tycho7> Lemmih: And otherwise, I can't really see where or how I could bring everything into the STM monad
14:36:54 <Tycho7> Lemmih: Any ideas?
14:36:57 <Lemmih> Tycho7: What kind of shared data are you manipulating?
14:37:28 <dons> Igloo: any idea why my build would be failing with
14:37:30 <dons> /usr/obj/build/head/rts/libHSrts.a(StgPrimFloat.o)(.text+0xc6): In function `__2Int_encodeDouble':
14:37:33 <dons> : undefined reference to `exp2f'
14:37:43 <Tycho7> Lemmih: Text files on the hard disk
14:37:59 <Zao> dons: Got a recent enough libm?
14:38:08 <dons> mm
14:38:18 <dons> $ man exp2f
14:38:18 <dons> man: no entry for exp2f in the manual.
14:38:22 <Lemmih> Tycho7: How do you manipulate that in memory?
14:38:45 <dons> looks like that's not on OpenBSD .
14:39:28 <Igloo> dons: Hmm, my manpage says it's a C99 requirement
14:39:31 <Lemmih> Tycho7: If you're only dealing with things on the disk then you have no need for STM.
14:40:17 <dons> Igloo: definitely doesn't look to be present on my system
14:40:41 <Igloo> dons: You have exp2 presumably?
14:41:14 <Zao> Solaris9 lacks some of the C99 parts of libm unless you have their special compiler pack.
14:41:26 <Zao> Although OpenBSD shouldn't have any oddness in that regard.
14:42:00 <Tycho7> Lemmih: There is a search function that runs line by line through the file, converts any valid lines to a datatype, then returns a list of them.  The server then sends that list back to the requester
14:42:36 <Tycho7> Lemmih: And theres a write function that just appends a line to the file.
14:42:42 <dons> Igloo: exp2 doesn't look to be present
14:43:01 <Lemmih> Tycho7: You need a file lock, not STM.
14:43:01 <Igloo> Eh? That's apparently in SVr4,  POSIX.1-2001,  4.3BSD,  C89.
14:43:28 <Tycho7> Lemmih:  I was hoping that was the case.  Thanks!
14:43:50 <dons> Igloo: hmm, in libm?
14:44:12 <Igloo> What version of OpenBSD do you have, dons?
14:44:18 <glguy> 4.2
14:44:19 <dons> 4.2
14:44:22 <glguy> ;)
14:45:10 <dons> can we get by with exp and expf ?
14:45:10 <Igloo> in libm, yes
14:45:44 <dons> i should set my nightly builds on bsd up again
14:45:50 <dons> they kept these linuxisms in check
14:46:08 * dons hacks away at runtime primops
14:46:15 <Igloo> {SVr4,POSIX.1-2001,4.3BSD,C89} is not a Linuxism!
14:46:41 <dons> that's no a distro i'm familiar with
14:46:42 <Igloo> We only use it for exp2f(32), so I guess we ought to be able to just put 4294967296.0 in there instead
14:46:51 <dons> yeah!
14:46:53 <dons> how odd.
14:49:09 <dons> Igloo: shall I push a patch for this? it keeps ghc building on my box.
14:49:31 <Igloo> dons: OK
14:53:25 <dons> done.
14:56:48 <dons> ../utils/hsc2hs/hsc2hs-inplace -I../libffi/build/include -I.    -L/usr/local/lib -I/usr/local/include ghci/LibFFI.hsc
14:56:51 <dons> /usr/local/lib: file not recognized: File truncated
14:56:54 <dons> grr
14:57:01 <dons> oh, hmm hsc2hs doesn't recognise -L perhaps
14:57:50 <byorgey> lispy: well, that kinda-sorta happens already, for certain things =)
14:58:18 <byorgey> lispy: for example, there's a 'circle' function which takes a radius parameter... but under the hood it just applies a scale to the unit circle =)
15:13:43 <roconnor> @wn morphismismist
15:13:45 <lambdabot> No match for "morphismismist".
15:15:09 <augustss> Is that something like morphinist?
15:16:09 <roconnor> It's supposed to be the title of someone who manipulates morphisms for their job.
15:16:58 <roconnor> but yes, morphinists is probably better
15:17:01 <Elly> wouldn't that be a morphismist?
15:17:32 <roconnor> @wn  morphinist
15:17:33 <lambdabot> No match for "morphinist".
15:20:26 <augustss> wn seems crapp.  Not having a useful word like morphinist.
15:42:59 <dcoutts> @seen tibbe
15:42:59 <lambdabot> I saw tibbe leaving #haskell-soc, #darcs, #xmonad, #ghc and #haskell 7d 11h 15m 11s ago, and .
15:43:05 <dcoutts> @tell tibbe done! http://hackage.haskell.org/trac/hackage/ticket/272#comment:1
15:43:05 <lambdabot> Consider it noted.
15:44:13 <bos> @hoogle intersperse
15:44:14 <lambdabot> Data.List.intersperse :: a -> [a] -> [a]
15:44:14 <lambdabot> Data.ByteString.intersperse :: Word8 -> ByteString -> ByteString
15:44:14 <lambdabot> Data.ByteString.Char8.intersperse :: Char -> ByteString -> ByteString
15:44:19 <vixey> hmm
15:44:20 <vixey> so,
15:44:48 <TomMD> OT: Does anyone know if PacLang is very widely used?
15:44:55 <vixey> Has anyone written a Haskell program to generate tables of the + and * relations for Galios Fields?
15:46:08 <TomMD> I have never seen such a haskell program.
15:46:22 <TomMD> Why a program though - wouldn't it be more useful as a library?
15:46:34 <ziman> @pl \(x, y) -> (f x, f y)
15:46:35 <lambdabot> f *** f
15:46:51 <TomMD> ?src (***)
15:46:51 <lambdabot> f *** g = first f >>> second g
15:47:06 <TomMD> ?where arrows
15:47:07 <lambdabot> http://www.haskell.org/arrows/
15:47:12 <ziman> is there an option to turn arrows off? :)
15:49:46 <dogbite> hello all.  i've been doing some differences of infinite sets.
15:49:53 <dogbite> i wrote this function just now.
15:49:59 <dogbite> > dif :: (Eq a, Ord a) => [a] -> [a] -> [a]
15:49:59 <dogbite> > dif xs ys = _dif xs ys 0 10
15:49:59 <dogbite> >             where _dif [] _ _ _                   = []
15:49:59 <dogbite> >                   _dif l1 [] _ _                  = l1
15:49:59 <dogbite> >                   _dif (x:xs) (y:ys) n m | n >= m = x:xs
15:49:59 <lambdabot>  Parse error at "=" (column 11)
15:49:59 <lambdabot>  Parse error at "|" (column 24)
15:49:59 <lambdabot>  Parse error at "where" (column 1)
15:49:59 <lambdabot>  Parse error at "=" (column 33)
15:50:00 <lambdabot>   Not in scope: `dif'
15:50:02 <dogbite> >                                          | x == y = _dif xs ys 0 m
15:50:02 <lambdabot>  Parse error at "|" (column 1)
15:50:04 <dogbite> >                                          | x <  y = x : (_dif xs (y:ys) (n+1) m)
15:50:05 <lambdabot>  Parse error at "|" (column 1)
15:50:08 <dogbite> >                                          | otherwise = _dif (x:xs) ys (n+1) m
15:50:08 <lambdabot>  Parse error at "|" (column 1)
15:50:12 <Elly> err...
15:50:17 <dogbite> what did i do wrong?
15:50:23 <dogbite> somehow lambdabot hated that
15:50:26 <Elly> yeah
15:50:37 <Elly> are you typing that into ghci?
15:50:45 <Vulpyne> It doesn't really understand the concept of multiple lines.
15:50:46 <Elly> because it needs 'let' before function declarations
15:50:47 <dogbite> i pasted that from my lhs buffer
15:50:51 <glguy> dogbite:
15:50:53 <glguy> @paste
15:50:53 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:52:37 <dogbite> glguy: please excuse my ignorance.  do i now paste the 'raw' that was generated by that webpage?
15:53:28 <dogbite> http://hpaste.org/7286?
15:53:39 <dogbite> i see it's a shorl.  got it, thanks.
15:54:19 <TomMD> dogbite: Typically (if you leave annouce checked) a bot will announce that you made the post and provide the link.
15:54:43 <dogbite> TomMD: thanks.  will do next time.
15:54:55 <dogbite> so my question is: is there a better way to write this function?
15:55:09 <dogbite> the idea is that we only take a finite number of steps
15:55:13 <daveux> Can someone help me decode this error: http://pastebin.com/m3c835be8 (I've written a small test case that produces the error) ?
15:55:17 <dogbite> before producing each item in the set difference
15:55:49 <Cale> dogbite: So it's potentially not quite correct, and only an approximation to the difference?
15:56:15 <dogbite> Cale: Yes, since in general the diff of two infinite lists isn't possible to compute
15:56:25 <Cale> Right.
15:56:46 <dogbite> but for some applications you know that it is either "close" or not there
15:57:49 <dogbite> Cale: btw, I'm guessing that you are the person who wrote Monads_as_Containers
15:57:52 <Cale> yes
15:58:04 <dogbite> Cale: I'm learning monads, and that writeup helped me the most.
15:58:14 <Cale> Great :)
15:58:21 <dogbite> Cale: I'm actually trying to write my own (yet another) monad intro
15:58:33 <dogbite> Cale: and you're writeup helped me a lot.
15:58:34 <Cale> Have you considered possibly working with something like  map (take 10) (tails ys) ?
15:58:54 <dogbite> no, i haven't considered that
15:59:13 <dogbite> (trying to understand it as i stare at it...)
15:59:16 <Cale> > map (take 3) (tails [1..10])
15:59:17 <lambdabot>  [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10],[10...
15:59:42 <dogbite> > tails [1..10]
15:59:43 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,9...
16:00:17 <IsoPallo> Ah. I'm trying to learn monads as well... Actually I wanted to comment on th habit that everyone seems to pattern-match at their definitions of >>=...
16:00:52 <IsoPallo> It kept me from getting the idea for almost two weeks... :)
16:01:03 <dogbite> Cale: thinking about it still... does seem like i could use it..
16:01:50 <IsoPallo> Pattern-matching in my opinion reduces newbie-friendliness as important things are done in the side...
16:03:38 <Saizan> IsoPallo: "in the side"?
16:04:06 <Cale> IsoPallo: Do you mean something like  x >>= \(u:us) -> ... ?
16:04:14 <Cale> IsoPallo: Or...
16:04:20 <agcorona> Hi,
16:04:27 <Cale> IsoPallo: Well, perhaps you could give an example?
16:04:54 <dons> IsoPallo: the other argument is that its much easier to use data structures when introducting them, and taking them apart, uses the same syntax.
16:06:18 <daveux> Can someone help me figure out this tiny typing issue: http://pastebin.com/m4ee39466
16:06:36 <agcorona> How to force the strct evaluation of a list elements?
16:06:47 <agcorona> strict, sorry
16:06:47 <mauke> "Hello, world!" has the type [Char], not Show a => a
16:07:12 <daveux> But there exists Show String, right.
16:07:19 <mauke> yes
16:07:23 <TomMD> And there exists 'print'
16:07:30 <TomMD> :t print
16:07:31 <lambdabot> forall a. (Show a) => a -> IO ()
16:07:35 <conal> daveux: your declaration means that showable has *all* of those types.
16:07:50 <daveux> I'm trying to make a name that holds any Show a.
16:07:52 <conal> daveux: i.e., every type a such that Show a
16:07:58 <mauke> daveux: just use String
16:08:01 <daveux> Oh...
16:08:10 <daveux> No, this is a small case demonstrating my error.
16:08:16 <daveux> This is not my program :)
16:08:18 <mauke> the only thing you can do with a showable value is to call show on it anyway
16:08:53 <TSC> You can use existential types, but you should be careful that they're worth the trouble
16:09:06 <TSC> (as mauke says, for the Show case they're not)
16:09:10 <daveux> Hmm, I have a typeclass called Performer, and I want a name -- performer -- to refer to some Performer. How can I do that?
16:09:12 <agcorona> I need to know How to force the strict evaluation of a list  of elements
16:09:25 <conal> agcorona: why?
16:09:30 <agcorona> there is some pragma or something?
16:09:47 <daveux> So in one module, I can use this performer name all over the place, and have another module define what that perform is.
16:10:08 <dons> agcorona: strict in what sense?
16:10:25 <dons> a strict list type, or some particularly point where you think you should try to evaluate the list?
16:10:40 <agcorona> conal, to make sure that all the list elements have been evaluated
16:10:42 <TSC> daveux: Couldn't you have "Performer a => performer :: a", or something like that?
16:10:57 <dons> agcorona: the usual way now is to use Data.Parallel.Strategies.rnf
16:11:09 <dons> agcorona: though you can also just take the length of the list
16:11:11 <daveux> TSC, maybe that's what I'm looking for -- I just don't know typeclasses well enough -- will try that.
16:11:35 <dcoutts> dons: sometimes you need a bit more than that
16:11:47 <agcorona> dons the length? for what reason?
16:12:01 <wadcom> hi, is my understanding correct that String is not an instance of Read?
16:12:05 <dons> agcorona: to work out the length it must evaluate the list
16:12:06 <mauke> wadcom: no
16:12:10 <daveux> TSC, that doesn't seem to be valid haskell.
16:12:17 <dons> dcoutts: btw, i'm pushing that reexport >>> patch
16:12:21 <TSC> daveux: I meant, for example:  "f :: Performer a => a -> b" takes some arbitrary Performer type as an argument
16:12:32 <dcoutts> dons: oh good
16:12:32 <dons> since it keeps xmonad building, and there's no good reason to break an API
16:12:35 <wadcom> mauke: looking here [1] can't see that... [1]: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:ReadS
16:12:37 <lambdabot> http://tinyurl.com/y4wexy
16:12:43 <conal> agcorona: to eliminate a space leak?  to do timing?
16:12:47 <daveux> TSC : Yes, I want  f :: Performer a => a
16:12:48 <dcoutts> @type foldr (\x xs -> x `seq` (x:xs)) []
16:12:49 <lambdabot> forall a. [a] -> [a]
16:12:57 <daveux> A zero-argument function.
16:13:07 <wadcom> (reads "a") :: [(String, String)]
16:13:11 <dons> dcoutts: what's wrong with rnf there? ( not whnf )
16:13:33 <wadcom> result: []
16:13:42 <agcorona> conal, I use a list of created TVars, that must be created before entering the atomic block that uses them
16:13:46 <dcoutts> > head $ foldr (\x xs -> x `seq` (x:xs)) (1 : 2 : undefined)
16:13:47 <lambdabot>  Couldn't match expected type `[a]'
16:13:48 <TSC> daveux: Ah, now I understand your paste
16:13:48 <daveux> I suppose you can't return something typed like that.
16:13:56 <agcorona> otherwise i get an error
16:13:59 <wadcom> or it *is* an instance, but the parser is not greedy
16:14:00 <dcoutts> > head $ foldr (\x xs -> x `seq` (x:xs)) [] (1 : 2 : undefined)
16:14:01 <lambdabot>  1
16:14:08 <mauke> wadcom: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#i:Read
16:14:08 <lambdabot> http://tinyurl.com/y4wexy
16:14:12 <conal> agcorona: oh, via unsafePerformIO or some such?
16:14:16 <dcoutts> > head $ tail $ foldr (\x xs -> x `seq` (x:xs)) [] (error "1" : 2 : undefined)
16:14:16 <lambdabot>  Exception: 1
16:14:46 <dcoutts> dons: foldr (\x xs -> x `seq` (x:xs)) []  just orders the evaluation without forcing anything, sometimes it's exactly what one needs
16:14:58 <dcoutts> so that traversing the spine forces the elements
16:15:05 <daveux> TSC, I'm trying to do something very OO -- I want an abstract type that can be defined by a user.
16:15:13 <dons> dcoutts: oh, yes, certainly. 'length' :)
16:15:14 <wadcom> mauke: ?
16:15:28 <mauke> wadcom: that's a list of Read instances
16:15:45 <mauke> I don't know why you linked me to ReadS
16:16:06 <wadcom> yes, and there are no String instance there
16:16:18 <mauke> Read Char
16:16:22 <mauke> Read a => Read [a]
16:16:29 <wadcom> mauke: your url links to the top of the page :-)
16:16:31 <wadcom> ah
16:16:35 <TSC> daveux: The simplest way is to write your functions so that they take a type parameter, e.g. "operateOnPerformer :: Performer a => a -> Int -> etc", then the user of the function can pass any type that's an instance of Performer
16:16:39 <mauke> wadcom: no, it doesn't
16:17:15 <agcorona> conal, yes, trough unsafeperformIO because the TVar creation depends on if it has been created or not
16:17:22 <dcoutts> dons: try iterate (+1) !! 500000, it overflows, but let orderEval = foldr (\x xs -> x `seq` (x:xs)) [] in orderEval (iterate (+1) 0) !! 500000 works fine
16:17:28 <daveux> TSC, my application core code calls those user-defined functions on the performer, that's the problem.
16:17:33 <agcorona> before
16:17:42 <dcoutts> dons: and is still lazy and constant space
16:17:43 <wadcom> mauke, ok whatever... So how do I parse out a string here:  (reads "a") :: [(String, String)] ?
16:17:45 <mux> cabal-install is sweet
16:17:50 <dcoutts> mux: :-)
16:17:57 <dons> dcoutts: ah yes. this came up with the list enum instances, iirc
16:17:57 <mux> dcoutts: kudos!
16:17:59 <mauke> wadcom: you don't because a is not valid string syntax
16:18:07 <wadcom> hm
16:18:18 <mauke> hint: strings use quotes
16:18:50 <wadcom> *Main> (reads "\"a\"") :: [(Char, String)]
16:18:51 <dcoutts> mux: and it's getting better, I'm working on improving the planning so we can try installing all of hackage :-)
16:18:52 <mux> the only thing that somehow surprised me was the default choice of ~/.cabal/bin for installing binaries, even when I had specified --prefix=/home/foo
16:19:00 <wadcom> []
16:19:17 <mauke> yes, "a" is not a valid Char literal
16:19:30 <wadcom> doh
16:19:31 <TSC> daveux: Maybe existential types will help you (but I'm not sure): http://www.haskell.org/haskellwiki/Existential_type
16:19:32 <lambdabot> Title: Existential type - HaskellWiki
16:19:39 <dcoutts> mux: hmm, the bindir should be the default, ie relative to prefix
16:19:42 <mauke> > reads "'a'" :: [(Char,String)]
16:19:46 <lambdabot>  [('a',"")]
16:19:47 <wadcom> yeah, right :-)
16:19:50 <agcorona> :type forldr
16:19:53 <agcorona> ops
16:20:02 <agcorona> @type foldr
16:20:03 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
16:20:13 <mux> dcoutts: well there is a bug then - I was using hackage's latest tarball fwiw
16:20:21 <wadcom> mauke: thanks
16:20:26 <dcoutts> mux: ohhh, that's way way old
16:20:31 <mauke> > reads "\"sells books\" sells books" :: [(Char,String)]
16:20:32 <lambdabot>  []
16:20:33 <mux> d'oh :-)
16:20:36 <mauke> > reads "\"sells books\" sells books" :: [(String,String)]
16:20:37 <lambdabot>  [("sells books"," sells books")]
16:20:49 <mux> @where cabal-install
16:20:50 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
16:20:56 <mux> @darcs cabal-install
16:20:56 <lambdabot> cabal-install not available
16:21:17 <mauke> is @darcs a real command?
16:21:29 <mux> I vaguely felt like it was
16:21:42 <idnar> heh
16:21:43 <dons> it used to be a command for setting up darcs repos to watch
16:23:40 <IsoPallo> Saizan, Cale, dons: Sorry, a little AFK. I mean like taking the "insides" out of a monad by SM c2 = fc2 r (and using c2 later) like in the gentle introduction
16:23:43 <conal> byorgey: how about reformatting some of you blog post code to have shorter lines?  I have to turn my view font size down (zoom out) to read the code.
16:24:11 <IsoPallo> Or for me even worse with all the newtype confusion as in yaht
16:24:25 <agcorona> the foldr stuff seems not to work for strict evaluation of a list
16:24:27 <dcoutts> dons: I wonder if we could soon get away with rejecting package uploads that require dependencies that are not on hackage...
16:24:34 <Cale> IsoPallo: ah, it's generally more readable to use run functions.
16:24:37 <dcoutts> there are several that do not build because of that problem
16:24:38 <Cale> IsoPallo: like:
16:24:42 <dons> dcoutts: we're almost there, I suspect
16:24:52 <Cale> newtype State s a = State { runState :: s -> (a,s) }
16:24:52 <IsoPallo> Cale: I know now.
16:24:59 <dcoutts> dons: missing hsql-sqlite, xml, compact-string
16:25:03 <IsoPallo> That's how I learned them.
16:25:06 <pjd_> daveux: what you're trying to do is certainly possible;  the error message in your paste is a different thing
16:25:14 <IsoPallo> Finally.
16:25:15 <jaj> @type [(a, a)] -> [a]
16:25:16 <lambdabot> parse error on input `->'
16:25:20 <jaj> @hoogle [(a, a)] -> [a]
16:25:20 <lambdabot> No matches, try a more general search
16:25:21 <dons> xml is on hackage though
16:25:32 <dcoutts> dons: ok, we have the xml package now, but it was missing when I did my last snapshot, though there were other packages that needed it
16:25:32 <Cale> x >>= f = State $ \s -> let (v,s') = runState x s in runState (f v) s'
16:25:37 <Saizan> IsoPallo: weird, at the start it were the run functions that confused me :)
16:25:38 <daveux> pjd_, I'm trying existential types
16:25:39 <dons> ah right
16:25:50 <pjd_> daveux: i'm not sure if that's what you're after
16:25:54 <dons> you'd have to work out how many things would break
16:25:55 <daveux> Me neither.
16:26:00 <agcorona> i tried also strict (r:rs)= r `seq`  (r:strict rs)    but it also does not work either
16:26:01 <dons> i suspect we could do this now
16:26:23 <dons> agcorona: could you maybe paste the code? hpaste.org
16:26:24 <dcoutts> dons: we'd need an exception list, which would include base for example
16:26:35 <dons> dcoutts: yeah, and ghc-prim  now
16:26:38 <jaj> does (\(u,v) -> u ++ v).unzip have a name?
16:26:39 <dcoutts> dons: actually the biggest one is all the gtk2hs packages :-)
16:26:45 <pjd_> daveux: maybe you can describe in more detail?
16:26:48 <dons> ah gtk2hs
16:27:22 <daveux> pjd_, in an OO language, I would create an interface, and client objects would impement that interface, and I could write my code using client objects, referring to them using their interface.
16:27:42 <pjd_> daveux: that's more or less the idea with type classes
16:27:46 <daveux> I want a Performer typeclass, with a perform :: Performer -> Performance -> IO ()
16:27:47 <pjd_> :t 5
16:27:48 <lambdabot> forall t. (Num t) => t
16:27:52 <dibblego> daveux, upgrade to type-classes
16:28:19 <mux> :t map (uncurry (++))
16:28:21 <lambdabot> forall a (f :: * -> *). (Functor f, Monoid a) => f (a, a) -> f a
16:28:25 <daveux> the problem is, I also want a performer :: Perform a => a variable.
16:28:46 <daveux> so I can do performer `perform` performance
16:28:57 <agcorona> dons : http://hpaste.org/7287
16:29:00 <pjd_> daveux: as you can see in that example, 5 is actually overloaded
16:29:00 <mux> > map (uncurry (++)) [("foo","bar"),("baz","qux")]
16:29:02 <lambdabot>  ["foobar","bazqux"]
16:29:11 <mux> jaj: is that what you wanted?
16:29:42 <daveux> The thing I can figure out is how to make that performer name refer to some a, where a is an instance of Performer. This seems like it should be straightforward.
16:29:44 <pjd_> the literal can be used as any Num instance
16:30:02 <daveux> pfd_, what are you suggesting? I don't really understand.... So confused.
16:30:12 <pjd_> daveux: it depends how you want performer to work
16:30:13 <daveux> I am trying to express a common idiom.
16:30:26 <Saizan> daveux: Performer a => a means something totally different from what you want
16:30:35 <pjd_> daveux: if it's a value supplied by the implementation, then performer will be a method of your type class
16:30:36 <daveux> Yes, that's my problem.
16:30:43 <dons> agcorona: and what are you trying to solve by stricitfying?
16:30:44 <Saizan> and that's not a common idiom in FP, it's a common idiom in OO
16:30:56 <dons> agcorona: also, how are you compiling that code?
16:30:56 <IsoPallo> Saizan: I found refering to things inside things by a name very simple indeed if the choise was staying alert :)
16:31:01 <daveux> Saizan, again, that's why I'm here.
16:31:23 <dons> agcorona: perhaps use Debug.Trace.trace instead of print
16:31:33 <dons> its designed for tracing evaluation
16:31:36 <jaj> mux: rather (uncurry (++)).unzip
16:31:59 <dcoutts> dons: ohh, it's not that xml was missing, but something needs xml==1.2.3 and there is no such version on hackage
16:32:04 <dons> ah ha
16:32:09 <pjd_> Saizan: who says it's not common?  lots of Prelude classes have nullary members :)
16:32:14 <dons> dcoutts:  i can fix that. which package?
16:32:16 <dons> hackage2hwn?
16:32:19 <jaj> mux: but perhaps I just have to rethink my design
16:32:32 <agcorona> dons: I create a list of TVars partly extracted from a map of TVars and partly created anew. I have to make sure to be created before entering the next atomic block
16:32:34 <dcoutts> dons: if I know I'd tell you :-) the error message doesn't tell me that yet :-)
16:32:34 <dons> yep, that;s it.
16:32:36 <Saizan> daveux: ok, so, why you want to forget about the concrete type of your performer? do you have to store performers of different types in the same structure or?
16:32:42 <agcorona> because they can not be nested
16:32:49 <daveux> Saizan, yes
16:32:52 <dons> agcorona: so rnf should be fine for that.
16:32:59 <mux> jaj: I can't see how you can implement such a thing - if you concatenate the two elements in the pair, there is no pair to unzip afterwared
16:33:07 <daveux> Saizan, I have a user-defined module that specifies how a performer performs
16:33:09 <mux> *afterwards
16:33:20 <daveux> In my core app, I just want to call perform on the user's performer.
16:33:32 <agcorona> Dons: i used debug.Trace instead of print, but the sequence is the same
16:33:48 <mauke> daveux: so just make sure the user-defined function is appropriately polymorphic
16:33:55 <dons> agcorona: what are you trying to see in this test?
16:34:01 <dons> its not clear to me what you expect
16:34:08 <pjd_> daveux: like i said, it sounds like you want performer to by a method of the type class
16:34:21 <mux> ecmascript 4.0 is quite interesting
16:34:22 <daveux> But how will the instance be determined?
16:34:26 <pjd_> that means that every Perform instance supplies it
16:34:47 <pjd_> the instance is determined normally, by type inference or declarations
16:34:49 <mux> it has types, and what looks very much like structural subtyping
16:34:55 <agcorona> dons: it is just to test various strict-ification strategies
16:35:22 <dons> agcorona: perhaps look at the 'strict' package on hackage.haskell.org, and Control.Parallel.Stategies.rnf. I'd use either of those
16:35:23 <pjd_> :t pi
16:35:25 <lambdabot> forall a. (Floating a) => a
16:35:30 <daveux> pjd_, I can't determine the type, because the user defines it, and inference cannot happen, because performer has not arguments and returns something generic
16:35:30 <pjd_> > pi :: Float
16:35:31 <lambdabot>  3.1415927
16:35:32 <dons> but just length xs `seq` xs --  should be ok
16:35:33 <agcorona> to test that all the elements of the list have been evaluated before the next statement
16:35:35 <pjd_> > pi :: Double
16:35:36 <lambdabot>  3.141592653589793
16:35:46 <mauke> daveux: wait, who defines what?
16:35:51 <pjd_> daveux: there's an example
16:35:56 <pjd_> pi is a method of Floating
16:36:01 <agcorona> dons, thanks. I will look at both
16:36:11 <pjd_> daveux: the implementation of pi gets chosen by the user
16:37:51 <pjd_> > pi :: Complex Double
16:37:53 <lambdabot>  3.141592653589793 :+ 0.0
16:38:13 <daveux> pdj_, I cannot make a declaration
16:38:26 <daveux> I don't KNOW what type the user created
16:38:35 <daveux> If I could declare the concrete type, problem solved
16:38:44 <pjd_> daveux: well, the whole point of type classes is that you don't have to
16:38:54 <daveux> Which is why I'm so confused.
16:38:57 <pjd_> you write generic code that works with any instance of the type class
16:39:20 <daveux> Yes, but how do I hide the instance of the type class part
16:39:25 <Saizan> daveux: how is your control flow? does your core app provides a function that must be used to start it providing the performer or what?
16:39:27 <daveux> I want to not know the instance
16:39:52 <pjd_> daveux: the instance is already "hidden"
16:40:10 <pjd_> that's what the Perform a => a means
16:40:44 <Saizan> pjd_: yeah, ok, but we've to choose the concrete type somewhere, and it must be in the user-code
16:40:56 <daveux> Ok: http://code.google.com/p/siegel-coveney/source/browse/trunk/final/Performer.hs defines the class
16:40:57 <lambdabot> Title: siegel-coveney - Google Code, http://tinyurl.com/5fh245
16:41:09 <daveux> http://code.google.com/p/siegel-coveney/source/browse/trunk/final/PMidiPerformer.hs defines an instance
16:41:10 <lambdabot> Title: siegel-coveney - Google Code, http://tinyurl.com/5h9dt7
16:41:16 <daveux> (this is the user-defined part)
16:42:20 <daveux> Now, in my core code, I want to use this PMidiPerformer type, and call perform with it, but not write down that type.
16:42:23 <Saizan> ok, and how do you want to use a performer in your core?
16:42:46 <mauke> huh?
16:43:05 <daveux> I want a name, performer, that is some Performer.
16:43:17 <mauke> doStuff :: Performer a -> IO ()
16:43:21 <mauke> doStuff performer = do ...
16:43:26 <mauke> er
16:43:26 <daveux> In another module, PerformerConfig, I am trying to create and export that name (performer)
16:43:27 <Saizan> yeah..
16:43:31 <mauke> doStuff :: Performer a => a -> IO ()
16:43:50 <pjd_> daveux: that is exactly what adding "performer :: a" to the type class will give you
16:44:06 <Saizan> you don't have to export it as Perfomer a => a
16:44:14 <Saizan> just export it as the concrete type.
16:44:26 <Saizan> then you can use doStuff on it
16:44:35 <pjd_> your main module can then refer to that, and be polymorphic over any Performer instance
16:44:42 <daveux> Right, but how do I use that? If I just call performer somewhere, how will the instance be determined. I'll try it...
16:44:49 <daveux> But I don't see how that could be inferred.
16:44:54 <mauke> I still don't understand the control flow
16:44:59 <dogbite> Cale: okay, i like the idea of using the 'take' function, but the best i got was this
16:45:04 <dogbite> http://hpaste.org/7288
16:45:24 <pjd_> daveux: you said you want to determine it in PerformerConfig, right?
16:45:28 <Saizan> daveux: if you define performer = PMP the type is already fixed no? then it's easy to infer the instance.
16:45:30 <pjd_> so that's where you'll do it
16:46:13 <pjd_> daveux: PerformerConfig can export a concrete performer, which your core code imports
16:46:22 <dogbite> also, I left the "announce" box checked, but I don't see an announcement
16:46:25 <pjd_> the core code stays polymorphic
16:46:31 <mauke> dogbite: hpaste is down
16:46:53 <dogbite> mauke: sorry to hear it!
16:47:02 <Saizan> daveux: if you define your core functions using only methods of Performer you can change the type of the performer variable later without having to rewrite anything
16:47:12 <mauke> preflex: seen hpaste
16:47:12 -preflex(n=preflex@d90-128-48-213.cust.tele2.de)- hpaste was last seen on #haskell 12 days, 22 hours, 29 minutes and 6 seconds ago, saying: Haskell paste bin: http://hpaste.org/
16:47:14 <daveux> I think we're close.
16:48:01 <pjd_> daveux: i think you might be fearing problems where there aren't any :)
16:48:08 <Saizan> it was an entirely different problem if you wanted to decide the type of performer at runtime
16:48:09 * dcoutts tries installing 358 packages from hackage...
16:48:51 <daveux> pjd_, ok, got it
16:49:01 <daveux> reload those links to see your suggestions implemented
16:49:29 <daveux> My old habit of writing down types everywhere was holding me back.
16:50:05 <Saizan> sometimes you have to trust the compiler on them :)
16:50:07 <pjd_> daveux: note that if you only want the concrete performer defined in PerformerConfig, you don't actually need the "performer :: a" method in the typeclass
16:50:12 <Saizan> more so if it works..
16:50:16 <daveux> Letting PerformerConfig export performer :: a (where a is informally(?) a Performer) did the trick.
16:50:36 <Saizan> uh?
16:51:11 <Saizan> daveux: so you've removed the typesignature from performer in PerformerConfig?
16:51:15 <daveux> I exported a name, performer, from PerformerConfig, that was set to some type defined by the user (in PMidiPerformer)
16:51:23 <daveux> Saizan, exactly.
16:51:39 <daveux> Which still worries me...
16:51:45 <pjd_> daveux: you can still write the type, you just have to write it more generically
16:51:57 <Saizan> ok, so it is officially performer :: PMidiPerformer :) which happens to be an instance of Performer so everything works
16:51:59 <daveux> Which brings me back to square one -- how do I do that?
16:52:01 <pjd_> i.e. "Performer a => a" instead of "PMidiPerformer"
16:52:06 <daveux> Saizan, yeas
16:52:46 <Saizan> pjd_: and where should the concrete type be determined in that case?
16:52:48 <daveux> pjd_, that returns me to my original error
16:52:59 <dogbite> for the infinite set difference function that i defined, what is the best practice for defining a new operator that works on lists of any type?
16:53:17 <dogbite> the normal operator is of course (\\)
16:53:59 <Cale> dogbite: Btw, I'm not 100% sure that there's a clearer way than you ended up with there.
16:54:26 <Cale> I suppose you can pick whatever operator symbol you like.
16:55:15 <dogbite> is '\' an escape operator?  would (\-) be an acceptable operator name?
16:55:26 <Cale> It's valid, certainly.
16:55:41 <Cale> > let x \- y = x^2 + y^2 in 5 \- 7
16:55:42 <lambdabot>  74
16:55:59 <dogbite> neat.  thank you.
16:57:08 <conal> dcoutts: have you seen this error when configuring gtk2hs on windows?
16:57:11 <conal> checking for GLIB... ./configure: line 5255:  3800 Segmentation fault      (core dumped) ( $PKG_CONFIG --exists --print-errors "glib-2.0 >= 2.0.0 gobject-2.0 >= 2.0.0" ) 2>&5
17:01:25 <dons> Igloo: argh,
17:01:28 <dons> StgPrimFloat.c:92:0: warning: integer constant is too large for âlongâ type
17:01:49 <TSC> long long?
17:02:01 <dcoutts> conal: no, I've not
17:02:12 <Igloo> dons: It said that about 4294967296.0?!
17:02:34 <conal> dcoutts: oh well.
17:02:35 <dons> Igloo: gabi just reported that, on macOS
17:02:54 <dcoutts> conal: it's repeatable?
17:02:57 <dons> i don't get warnings on x86_64/bsd
17:03:00 <Igloo> But that's not an integer constant
17:03:25 <dcoutts> conal: if you run on it's onw, pkg-config.exe --exists --print-errors "glib-2.0 >= 2.0.0 gobject-2.0 >= 2.0.0"
17:03:32 <dons> hmm, C.
17:03:39 <dons> does it need an   r *= (StgDouble)4294967296; /* exp2f(32); */
17:03:55 <Igloo> Oh, you didn't put the .0 on?
17:04:01 <dons> ah.
17:04:33 <dons> seems like it would be best to give a type too. exp2f :: Float -> Float
17:04:53 <conal> dcoutts: i get bash: [1200: 1] tcsetattr: Inappropriate ioctl for device .  i'm in an inferior shell in emacs.  will try in a bash process outside of emacs.
17:05:09 <dons> Igloo: so you think   r *= 4294967296.0; should be the fix?
17:05:47 <Igloo> I'd have thought so
17:05:56 <dons> shall I push that, or ask Gabi to do it?
17:06:38 <Igloo> May as well check it really does work first
17:06:39 <conal> dcoutts: that fixed it.  now it's not finding my gtk, which i think i just installed from cygwin.
17:06:52 <dons> well, it builds without warnings here, but it did before as well
17:07:14 <dcoutts> conal: you probably need to set the env variable that pkg-config uses to know where to look for package descriptions
17:08:07 <dcoutts> conal: PKG_CONFIG_PATH A colon-separated (on Windows, semicolon-separated) list of directories to search for .pc files.
17:08:22 <conal> dcoutts: thx.  what's a .pc file?
17:08:52 <dcoutts> conal: it's a bit like a .cabal file but for C libraries, it tells us what gcc flags to use to compile and link against that C library
17:09:48 <dcoutts> conal: for example, try: pkg-config --cflags --libs gtk+-2.0
17:10:19 <dcoutts> conal: that output is constructed by looking at the .pc file for the gtk+-2.0 package and its dependencies
17:12:07 <conal> dcoutts: i don't find any gtk .pc files either.  maybe the cygwin install failed silently.
17:12:46 <dcoutts> conal: where did you get your gtk+ from? did it include .h files as well as just .dlls?
17:14:39 <conal> dcoutts: i got it through my cygwin package installer.  i ended up with a cyggtk-1-2-0.dll, a bunch of language files, some docs.
17:14:42 <saml> I have tInfer :: Expr -> TI Type .  now I want to type inference multiple expressions.    tInferMulti :: [Expr] -> TI [Type] . how can I go about implementing tInferMulti ?
17:14:53 <conal> dcoutts: maybe i need gtk+devel also
17:15:29 <dcoutts> conal: cyggtk-1.2 sounds like it's gtk+ version 1.2, which is about 8 years too old, you need gtk+ 2.0 or later
17:16:00 <dcoutts> gtk+ 2.6 or later is preferred for a reasonable experience on windows
17:16:03 <saml> mapM tInfer !
17:17:40 <conal> dcoutts: okay.  i'm getting old stuff from cygwin.  i'll try some gtk2-* packages
17:17:48 <dcoutts> hmm, seems that HTTP leaks file handles, my cabal-install has 156 open network connections to hackage.haskell.org
17:18:15 <dons> dcoutts: john goerzon mentioned this too
17:18:33 <dcoutts> dons: I do seem to recall something on the lists recently
17:18:45 <dcoutts> will have to check that out
17:19:08 <dcoutts> dons: it's not good if every user ends up with loads of open connections to galois's server :-)
17:19:29 <dons> dcoutts: right.
17:19:33 <dcoutts> you lot might not be very happy :-)
17:24:49 <dcoutts> oh, they all just got GC'ed :-)
17:35:24 <dcoutts> $ ghc-pkg list --simple-output | wc -w
17:35:24 <dcoutts> 292
17:35:34 <dcoutts> how many packages have you got installed? :-)
17:36:04 <ddarius> Doing that says 48
17:36:05 <mauke> 56
17:36:32 * dcoutts notes http://hackage.haskell.org/trac/ghc/ticket/2089
17:36:34 <lambdabot> Title: #2089 (reading the package db is slow) - GHC - Trac
17:36:39 <saml> 43
17:36:45 <TomMD> 63
17:36:52 <dcoutts> saml: one too many! :-)
17:36:55 <Saizan> hah 88
17:37:21 <cedricshock> Any haskell logic programming libraries?
17:37:35 <vixey> yes
17:37:43 <dcoutts> too low people! there are 568 packages on hackage!
17:37:48 <ddarius> cedricshock: There are several described.  I don't know how many are packaged.
17:37:49 <TomMD> What does a clean install result in?
17:37:58 <vixey> http://okmij.org/ftp/Computation/monads.html#LogicT
17:38:04 <lambdabot> Title: Monads
17:38:11 <Saizan> logict is on hackage, also
17:38:34 <vixey> would be great to see more logic languages implemented from LogicT
17:38:41 <dcoutts> Tomas: about 20 iirc
17:38:45 <ddarius> I don't think there are any libraries for logic variables or narrowing on hackage or publically available in a nice form elsewhere.
17:39:00 <cedricshock> Nice! That's a pretty nice basis.
17:39:30 <dcoutts> oops, not Tomas, TomMD
17:39:31 <ddarius> @google Typed Logical variables in haskell
17:39:33 <lambdabot> http://linkinghub.elsevier.com/retrieve/pii/S1571066105805444
17:39:33 <lambdabot> Title: Elsevier Article Locator
17:39:39 <ddarius> Blech
17:40:07 <ddarius> @google "Typed Logical Variables in Haskell"
17:40:09 <lambdabot> http://citeseer.ist.psu.edu/claessen00typed.html
17:40:09 <lambdabot> Title: Typed Logical Variables in Haskell - Claessen, Ljungl (ResearchIndex)
17:40:18 <ddarius> @google Wired a functional logic library
17:40:22 <lambdabot> http://portal.acm.org/citation.cfm?id=1291201.1291207
17:40:22 <lambdabot> Title: A functional-logic library for wired
17:40:59 <ddarius> Plus some stuff on CHRs and related things.
17:43:06 <dogbite> how do you alias a pattern such as (x:xs) so that you can easily refer to the whole list?
17:43:19 <ddarius> list@(x:xs)
17:43:30 <dogbite> ddarius: thanks!
17:44:08 <cedricshock> LogicT looks like a parser.
17:44:45 <cedricshock> It looks more like a parser than most parsers.
17:49:41 <conal> dcoutts: i got gtk installed.  do you know what the gtkglext package is?
17:50:42 <dcoutts> conal: it's a gtk extension that provides an OpenGL widget, gtk2hs has bindings for it
17:50:53 <dcoutts> it's not too bad
17:51:21 <conal> dcoutts: useful then.  thx.
17:51:24 <dcoutts> conal: I use it for a first year undergraduate functional programming practical
17:51:43 <conal> dcoutts: how do i enable it?
17:51:49 <TomMD> dcoutts: You did FP as an undergrad? Where?
17:52:02 <dcoutts> TomMD: did and teach :-) Oxford
17:52:10 <TomMD> Ah!
17:52:39 <dcoutts> conal: it should be enabled automatically if it's detected but you can use --enable-opengl to make it fail loudly if it cannot be configured/detected
17:52:52 <dcoutts> conal: the gtk2hs ./configure script I mean
17:53:59 <dcoutts> TomMD: http://haskell.org/gtk2hs/archives/2005/11/01/university-courses-using-gtk2hs-for-teaching/
17:54:00 <lambdabot> http://tinyurl.com/5zdjyo
17:54:19 <dcoutts> TomMD: and I've taught basically the same practical last year and this year too
17:54:22 <conal> dcoutts: thx.  oh -- i see i have to find a package called gtkglext
17:54:37 <dcoutts> TomMD: though with 3D the last two years :-)
17:54:56 <dcoutts> conal: oh, yes, sorry, the haskell package has the same name as the C package :-)
17:55:24 <SamB> what does "strictly positive" mean in the context of inductive types?
17:56:02 <conal> dcoutts: okay.  progress!  i'm off to dinner, and i'll try some more later.
17:56:23 * SamB just tried to do this:
17:56:33 <SamB> Inductive sem : Type :=
17:56:33 <SamB> | LAM : (sem -> sem) -> sem
17:56:33 <SamB> | PAIR : sem -> sem -> sem
17:56:33 <SamB> | SYN : tm -> sem.
17:59:48 <dolio> LAM isn't strictly positive, I think.
18:00:00 <dolio> I forget what the exact rules are, though.
18:00:07 <SamB> well, yes, so Coq says...
18:00:22 <SamB> someone woke up in #coq though, so ...
18:01:11 <dolio> I believe being on the left of the function arrow in the (sem -> sem) part is a problem.
18:01:16 <vixey> if it allowed LAM like that you'd trivially prove False
18:01:32 <dolio> Or perhaps it's the right, I forget exactly.
18:01:36 <vixey> LAM id = forall sem, sem
18:02:25 <vixey> (ident -> sem) -> sem is ok
18:03:02 <SamB> wait, that person is now here
18:03:07 <SamB> how confusing
18:03:31 <SamB> how many of you are there hiding here?
18:04:31 <SamB> vixey: so, would I actually be able to prove False with this datatype?
18:05:00 <SamB> I've only proved False once so far
18:06:35 <dolio> 'data T = D (T -> Bool)' is negative, and 'data S = C ((S -> Bool) -> Bool)' is non-strictly positive (negated twice).
18:12:18 --- mode: irc.freenode.net set +o ChanServ
18:18:24 <dolio> SamB: funny : sem -> (sem -> sem) ; funny (LAM f) s = f s
18:18:40 <dolio> haha : sem -> sem ; haha t = funny t t
18:18:59 <dolio> haha (LAM haha) = funny (LAM haha) (LAM haha) = haha (LAM haha)
18:19:42 <SamB> why did you give funny such a funny looking type?
18:19:51 <SamB> why not sem -> sem -> sem?
18:20:02 <dolio> I'm cribbing from somewhere else. :)
18:20:12 <dolio> Although the types are different there.
18:27:33 <dolio> Note, that doesn't prove false, but you could instead make the constructor 'LAM : (sem -> False) -> sem' if negative types are allowed.
18:28:11 <dolio> In which case 'funny : sem -> sem -> False' and 'haha : sem -> False', so 'h (LAM h) : False'.
18:29:48 <dolio> So _|_ has been introduced as a value of type False.
18:33:32 <mauke> lispy: grep -l
18:38:06 <jaredj>         args <- getArgs
18:38:06 <jaredj>         if null args then usage else return ()
18:38:47 <jaredj>         [...]
18:38:52 <jaredj> is there a better way to say?
18:39:05 <mauke> when (null args) usage
18:39:17 <jaredj> @hoogle when
18:39:18 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
18:39:34 <jaredj> thanky!
18:39:48 <mauke> @src when
18:39:48 <lambdabot> when p s = if p then s else return ()
18:41:15 <lispy> mauke: thanks
18:41:30 <jaredj> aw. python: print "usage: %s arg1 arg2" % programName. haskell: +++++...
18:41:33 <lispy> mauke: that does work, I overlooked it because i didn't grok the explanation on --help
18:42:13 <mauke> jaredj: haskell: printf "usage: %s arg1 arg2\n" programName
18:42:38 <lispy> ?hoogle printf
18:42:39 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
18:42:39 <lambdabot> Text.Printf :: module
18:42:39 <lambdabot> Text.Printf.PrintfType :: class PrintfType t
18:42:45 <jaredj> right, but is it idiomatic?
18:42:55 <lispy> it's in the standard libs
18:43:06 <TSC> Is my haddock out of date: dist/build/tmp/./Graphics/Rendering/Diagrams.hs:"dist/build/tmp/./Graphics/Rendering/Diagrams.hs": 45:5: Parse error
18:43:30 <TSC> the line is:     , (##), union, unionA
18:43:38 <lispy> TSC: I can't tell what that output is about, but there is a haddock2 if you have ghc6.8
18:43:44 <TSC> Ahh
18:43:59 <TSC> Can it be run by cabal?
18:44:11 <lispy> I believe so
18:44:30 <TSC> Thanks (:
18:47:56 <TSC> Success!  It works; thanks again
18:49:30 * LEDOhm  Listens to:  [ MINI-ma-L-drid ] >>>> http://84.76.138.117:8000 <<<< [Minimal-Techno & Tech-House Radio] - stream - mp3 - 128kbps - stereo
18:49:52 <mauke> LEDOhm: stop that. no one cares here either
18:53:15 * bd_ is currently playing: M.C.Cage - 4'33" -SLOW mix- (06h44m24s/Inf)
18:53:28 <Cale> ahahahaha
18:54:53 <jaredj> :t flip
18:54:54 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
18:55:09 <jaredj> :s flip
18:55:17 <jaredj> :source flip
18:55:45 * jaredj has nothing to say about this choice of music
18:56:16 * LEDOhm  Listens to:  [ MINI-ma-L-drid ] >>>> http://84.76.138.117:8000 <<<< [Minimal-Techno & Tech-House Radio] - stream - mp3 - 128kbps - stereo
18:56:59 * vixey listens to Swamp vom Jupiter
18:57:31 <vixey> flip f y x = f x y
18:57:36 <red75> @djinn const ? a -> (b -> a)
18:57:37 <lambdabot> Cannot parse command
18:57:56 <EvilTerran> LEDOhm, btw, that strikes me as something more suitable for #haskell-blah (the offtopic) than #haskell
18:58:09 <Saizan> ?djinn a -> b -> a
18:58:10 <lambdabot> f a _ = a
18:58:32 <mauke> EvilTerran: he's doing it in #perl too (and got kicked for it, autorejoined, reannounced, and got banned)
18:59:04 <EvilTerran> ... the stream doesn't even work
19:00:10 <EvilTerran> shame. i quite like minimal techno
19:01:27 <EvilTerran> mauke, has LEDOhm said anything else? might as well nip it in the bud here too, otherwise
19:01:37 * LEDOhm  Listens to:  [ MINI-ma-L-drid ] >>>> http://84.76.138.117:8000 <<<< [Minimal-Techno & Tech-House Radio] - stream - mp3 - 128kbps - stereo
19:01:45 <mauke> he hasn't
19:01:56 * LEDOhm  Listens to:  [ MINI-ma-L-drid ] >>>> http://84.76.138.117:8000 <<<< [Minimal-Techno & Tech-House Radio] - stream - mp3 - 128kbps - stereo
19:01:57 <EvilTerran> ?where ops
19:01:58 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
19:02:06 * LEDOhm  Listens to:  [ MINI-ma-L-drid ] >>>> http://84.76.138.117:8000 <<<< [Minimal-Techno & Tech-House Radio] - stream - mp3 - 128kbps - stereo
19:02:24 * LEDOhm  Listens to :  [ MINI-ma-L-drid ] >>>> http://84.76.138.117:8000 <<<< [Minimal-Techno & Tech-House Radio] - stream - mp3 - 128kbps - stereo
19:02:31 <EvilTerran> ... guys?
19:02:35 * LEDOhm  Listens to:  [ MINI-ma-L-drid ] >>>> http://84.76.138.117:8000 <<<< [Minimal-Techno & Tech-House Radio] - stream - mp3 - 128kbps - stereo
19:02:40 --- mode: ChanServ set +o dcoutts
19:02:40 <vixey> LEODhm: Please stop
19:02:44 * LEDOhm  Listens to:  [ MINI-ma-L-drid ] >>>> http://84.76.138.117:8000 <<<< [Minimal-Techno & Tech-House Radio] - stream - mp3 - 128kbps - stereo
19:02:45 --- kick: LEDOhm was kicked by dcoutts (dcoutts)
19:02:50 --- mode: dcoutts set +b *!*n=ledohm@84.76.133.*
19:02:51 <wagle> he's spamming all the channels
19:02:53 --- kick: LEDOhm was kicked by dcoutts (dcoutts)
19:03:05 <EvilTerran> vixey, i'm pretty sure it's just a spambot. not sure what it hopes to achieve exactly, but still
19:03:12 <EvilTerran> dcoutts++
19:03:25 --- mode: ChanServ set -o dcoutts
19:06:00 <dons> hmm
19:13:17 <lispy> could someone ban LEDOhm from #haskell-blah as well
19:13:37 <dons> nope :(
19:13:44 <bd_> lispy: let a freenode staffer know
19:13:51 <mauke> and ##c++ while you're at it
19:14:17 <red75> Hi all. I'm tring to implement clusterizer of 3d vectors. State monad should be a good choice to being with, will it?
19:14:57 <dons> yeah, possibly. picking the data types for the vectors are probably most important though
19:16:21 <red75> Hmm. data V3 a = V3 a a a. Can't think of it other way...
19:17:06 <dons> ok, that looks good
19:17:16 <dons> data V3 a = V3 !a !a !a   is what i'd go with
19:17:21 <dons> and use -funbox-strict-fields
19:17:30 <dons> since they're probably Ints or Words are they?
19:17:47 <red75> doubles, actually.
19:17:51 * dcoutts prefers being specific and using the UNPACK pragma instead of -funbox-strict-fields
19:19:07 <red75> There's no standard vector library, AFAIK. It's strange.
19:19:25 <lispy> Whenever I read -funbox-strict-fields I imagine people saying it as there it's the slimjim on the "snap into a slimjim" commercials
19:19:30 <dons> its cheap enough to write your own, that i guess no one bothers.
19:20:06 <dons> dcoutts: amazing core i'm getting with head, on uvectors,
19:20:07 <dons>   sumU . takeWhileU (< 7).  enumFromToU 1 $ 10000000
19:20:33 <dons> goes to
19:20:34 <dons> Main.$wfold =
19:20:34 <dons>   \ (ww_sNL :: Int#) (ww1_sNP :: Int#) ->
19:20:34 <dons>     case ># ww1_sNP 10000000 of wild_aKu {
19:20:34 <dons>       False ->
19:20:37 <dons>         case <# ww1_sNP 7 of wild2_aK1 {
19:20:39 <dons>           False -> ww_sNL;
19:20:42 <dons>           True ->
19:20:44 <dons>             Main.$wfold (+# ww_sNL ww1_sNP) (+# ww1_sNP 1)
19:20:47 <dons>         };
19:20:50 <dons>       True -> ww_sNL
19:20:58 <dons> if you replace the enumFromTo with a replicateU, the takewhile disappears as well,
19:21:10 <Saizan> isn't it weird that there's no complexity cost for the operations in fgl's documentation?
19:21:12 <dons> ghc figures out the replicate value is a constant, < 7, and boils that test off
19:23:04 <red75> :t enumFromToU
19:23:05 <lambdabot> Not in scope: `enumFromToU'
19:23:19 <red75> unsigned?
19:23:19 <dons> :t enumFromTo
19:23:20 <lambdabot> forall a. (Enum a) => a -> a -> [a]
19:23:30 <dons> no, UArr (see code.haskell.org/~dons/code/uvector )
19:23:46 <dons> not vectors of the kind you're talking about though, unboxed strict arrays
19:25:13 <red75> oops. unboxed. yes, i'm going to use it for storage. tuple of tree, to be exact.
19:36:56 <red75> How'd you get core output? i can't find such switch in ghc.
19:40:04 <dons> ghc -O2 -ddump-simpl
19:40:08 <dons> i use a script to wrap it all up
19:40:29 <dons> http://hpaste.org/7290 colourised core
19:40:31 <jaj> hmm, anybody familiar with HDBC here? I get: "prepare 95: INSERT INTO `posts` (id, date, time, ?, ?, ?) VALUES (NULL, date('now'), time('now'), ?, ?, ?): near \"?\": syntax error"
19:40:32 <dons> if you use hscolour
19:40:52 <jaj> normally it should accept the question marks and escape them later on
19:41:22 <EvilTerran> jaj, you can't use ?s in column, table, or database names
19:41:30 <EvilTerran> only values
19:42:00 <red75> thanks.
19:42:11 <EvilTerran> this applies to parameterised queries in most SQL interfaces, i believe
19:42:15 <jaj> EvilTerran: is there a reason for this or is it just because of it was chosen to implement it this way?
19:42:44 <EvilTerran> because this means the DB engine can optimise the compiled query much more effectively
19:43:24 <EvilTerran> as it doesn't re-compile and re-optimise for each use of a prepared query
19:44:07 <jaj> ok, it's just that otherwise you could just work with Maps without caring about the order
19:44:19 <EvilTerran> er?
19:46:09 <EvilTerran> also, as your database, table, and column names should be coming from a pre-defined list that won't change during execution, it's easy to validate them so it's safe to concatenate them into the query string
19:46:22 <edward1> Heh, anyone feel like proofreading http://comonad.com/reader/2008/the-cofree-comonad-and-the-expression-problem/ before it makes it to planet haskell and gets fossilized for an hour or so with me unable to tweak wording? =)
19:46:24 <EvilTerran> alternatively, stored procedures!
19:46:25 <lambdabot> Title: The Comonad.Reader  The Cofree Comonad and the Expression Problem, http://tinyurl.com/5m4vjv
19:46:35 <EvilTerran> coffee comonad?
19:46:50 <jaj> what I intended to do was having a Data.Map with the column names and values and then the order of the different elements in the Map doesn't matter
19:48:13 <EvilTerran> hmm
19:48:22 <edward1> EvilTerran: I swear it needs a new name =)
19:48:31 <EvilTerran> that doesn't strike me as, er, very clean
19:48:38 <EvilTerran> edward1, what, the coffee comonad?
19:49:00 <EvilTerran> jaj, would it not be neater to use a record to represent a row in the table?
19:49:01 <Twey> Hehe
19:49:02 <edward1> evil: yeah
19:49:11 <EvilTerran> seeing as different columns can be different types and so forth
19:51:30 <dogbite> i'm trying to post some source code to my wordpress blog.  it is a literate haskell file i want to post
19:51:59 <dogbite> but it is reformatting my '>' symbols, etc
19:52:08 <dogbite> even if they're in '<pre>' blocks
19:52:10 <dogbite> any advice?
19:52:13 <edwardk> dogbite: yeah i just gave up =)
19:52:14 <dogbite> i know this isn't a wordpress channel
19:52:46 <EvilTerran> dogbite, format it with hsColour, then paste the resulting HTML?
19:52:54 <edwardk> dogbite: it likes to eat the extra spaces after the >'s?
19:53:14 <dogbite> EvilTerran: yeah hscolour... i didn't like the formatting but maybe i'll go that way
19:53:25 <EvilTerran> dogbite, alternatively, i believe there are plugins to various blogging softwares to make lhs-style code marked with >s at the starts of lines work
19:54:30 <edwardk> If someone finds one for wordpress I'll happily switch to posting in literate haskell. Would save me a lot of work =)
19:55:12 <EvilTerran> it'd probably hook into hsColour to do the formatting, mind
19:55:19 <dogbite> yeah, this is such a mess
19:55:22 <dogbite> i'm using hscolour
19:55:53 <edwardk> I currently use: http://ideathinking.com/wiki/index.php/WordPress:CodeHighlighterPlugin
19:55:55 <lambdabot> Title: WordPress:CodeHighlighterPlugin - IdeA thinKING, http://tinyurl.com/5wkwov
19:56:37 <edwardk> which handles Haskell reasonably well (although its default choice for highlighting strings is as bad as shapr's emacs colors...)
19:59:30 <red75> edward1: four = Left (/2) >>$<< (4.0, True)
19:59:31 <dogbite> http://tinyurl.com/6p5gtv
19:59:33 <lambdabot> Title: Differences and Intersections on Infinite Lists.  tech guy in midtown
19:59:40 <bd_> :t (>>$<<)
19:59:42 <lambdabot> Not in scope: `>>$<<'
19:59:43 <dogbite> I hate the formatting
19:59:47 <red75> should it be two?
19:59:50 <dogbite> whatcha gunna do.  try to fix it later.
19:59:54 <dogbite> thanks for your help guys
19:59:57 <edwardk> red: woops i meant to make the rhs 8 =) i mispasted =)
20:00:25 <edwardk> the version in the attached source code is 8 =)
20:01:07 <edwardk> fixed thx
20:01:18 <red75> it's nothing
20:01:58 <edwardk> bd_t: its an operator in the post i linked to above
20:02:44 <bd_> ah
20:03:04 <red75> i do not grasp theoretical part however, so i cannot say anything about it.
20:03:23 <bd_> I have a headache atm, so perhaps I'll save the article for later :)
20:03:56 <edwardk> the basic idea is if i have a pair of functions and either one or the other of two potential values i can pair them off and only a single case will apply.
20:04:14 <edwardk> and conversely if i have one of two functions and a pair of values i get the same thing.
20:04:42 <edwardk> this then generalizes to handle a functor folded in upon itself in a couple of ways
20:21:52 <ski> conal : ping
20:52:38 <lispy> I have cyclical module imports compiling under ghc and I'd like to avoid boot files.  Other suggestions?
20:52:55 <lispy> I can make a new module to break the cycle, but that always feels so clunky
20:53:17 <ddarius> Use dependency inversion.
20:53:31 <lispy> ddarius: aka move things around?
20:54:04 <ddarius> Possibly, more like parameterize things.
20:54:29 <lispy> ddarius: I'm not seeing it
20:57:20 <lispy> What I need is for a piece of data to be defined once in my program
20:57:39 <lispy> But now that I've defined it once and imported it from all the modules that need it, I have cycles
20:58:31 <lispy> It's also something that should/could be in an "environment" that gets passed around, but I would have to modify a LOT of code to do that and many functionns would pass it around without acting on it
20:58:56 <lispy> I need a global ;)
20:59:37 <edwardk> lispy: heh you could use the cc shan/oleg trick where needed =)
21:00:06 <lispy> edwardk: haha
21:00:26 <lispy> Actually, much to me amusment/amazement darcs already has a module, ./src/Darcs/Globals.lhs
21:00:35 <lispy> I will now move my definition there and see what happens
21:13:03 <jaj> 06:11 <jaj> @type read, 06:11 <lambdabot> thread killed
21:13:57 <lispy> :t read
21:13:59 <lambdabot> forall a. (Read a) => String -> a
21:14:01 <conal> ski: pong
21:14:40 <jaj> lispy: yeah was just a timeout because it was under load I guess
21:15:25 <ski> conal : you were talking about some `STM'-based thing for computing with "holes to be filled later", yesterday
21:16:23 <conal> ski: yeah
21:16:51 <ski> conal : i was thinking it appeared related to dataflow variables, as in Oz
21:17:18 <conal> oh.  i don't know about dataflow variables.
21:18:20 <conal> ski: i'll do some googling and follow my nose.  thx.
21:18:42 <ski> also, i was wondering, re <http://www.haskell.org/pipermail/haskell-cafe/2008-April/042252.html>, that this business of forcing by calling the thunk and *then* setting the result reminded me of a problem with implementing lazy suspensions
21:18:42 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2008-April/042252.html>
21:19:46 <ski> a "tail-call" thing, explained in <http://srfi.schemers.org/srfi-45/> (follow the "SRFI Document" link)
21:21:07 <conal> ski: yes, the caching is sort of emulating what a lazy language RTS already does for pure values.  that's why i prefer using pure values rather than STM in this case.
21:21:21 <ski> conal : dataflow variables should be explained in CTM (Concepts, Techniques, and Models of Computer Programming, by Peter van Roy and Seif Haridi), which your library might carry
21:21:25 <conal> ski: and because the semantics is pure.
21:22:06 <ski> *nod*
21:22:12 <conal> ski: i'll track down CTM some day, though no library anywhere here would have it.  i live way out in the sticks.
21:22:44 <ski> i'm not sure if the problem (and solution) described in that SRFI applies in your case, but i think it's worth a look, at least
21:22:50 <ski> ok
21:23:35 <conal> ski: i appreciate the pointers.
21:24:45 <ski> m (i didn't have much more constructive to say about this, at this point ..)
21:31:30 <geezusfreeek> ooh interesting stuff
21:31:47 <geezusfreeek> yes, the stm solution is looking less and less pretty now
21:32:14 <conal> geezusfreeek: oh hey -- i was just emailing you.
21:32:24 <dufflebunk> I'm thinking of making an interface to a C library in Haskell. One of the C functions takes a callback function as an argument. Is it possible to implement the interface so that I can use a Haskell function as the callback?
21:32:34 <conal> geezusfreeek: I think I'll shift my attention back to representing futures directly as values, so that caching happens automatically.
21:32:45 <geezusfreeek> dufflebunk: the GLUT bindings do it somehow, so i would say yes
21:32:45 <conal> geezusfreeek: For testing, I'm working on a simple functional 3D library, which will complement FRP.  I want to use it both for 3D toys/puzzles/games and for GUIs, as I'd like to leave behind GUI libs that are conventional, bloated, ad hoc, 2D and imperative.
21:33:52 <dufflebunk> geezusfreeek: Thanks, I'll start there.
21:34:19 <bd_> dufflebunk: foreign export ?
21:34:35 <bd_> I haven't used it myself, note
21:35:00 <ddarius> dufflebunk: Read the FFI
21:35:35 <geezusfreeek> conal: nice. i will be continuing for a while to look into alternative implementations for futures, but i may put it on the backburner if you happen to roll out a prototype of your progress so far in favor of playing around with it instead
21:36:01 <conal> geezusfreeek: i'll let you know.
21:36:33 <conal> geezusfreeek: i do have an implementation of the paper, but it's not very well tested or measured.
21:36:47 <conal> geezusfreeek: and not yet released
21:37:09 <lispy> dufflebunk: yeah, do as ddarius recommends, look at the FFI examples/manual and also search the haskellwiki
21:37:29 <lispy> dufflebunk: I'm pretty sure i've seen an example of what you want and I think it was even in the FFI manual
21:38:43 <geezusfreeek> conal: and if i get nowhere within a week i will probably just concede defeat and ask if you wouldn't mind me collaborating with you or forking from your code in order for me to just get on with making some game libs and games, as that is my ultimate goal modulo some side-quests like this stm stuff
21:38:51 <ddarius> @where ffi
21:38:51 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
21:39:06 <geezusfreeek> :)
21:39:48 <conal> geezusfreeek: that'd work great for me.  i bet you'd give me great feedback and suggest improvements.
21:39:58 <geezusfreeek> conal: i would hope so, anyway
21:53:58 <gwern> 'Git is Linus’s own creation, started (I’m told) when Linus learned that the lead Monotone dev was on holiday and wasn’t about to start hacking on Monotone to improve performance until his return.'
22:06:14 <sjanssen> @yow
22:06:14 <lambdabot> Did I do an INCORRECT THING??
22:17:07 <bos> http://reddit.com/info/6hqws/comments/
22:17:27 <bos> new RWH chapters for your reading pleasure
22:21:48 <conal> bos: first time i've looked at your book.  what's the web technology under presenting the content and taking comments?
22:22:32 <bos> conal: a little bit of django and jquery
22:22:57 <bos> conal: which i used as frameworks to build the front and back ends
22:23:27 <conal> bos: nifty!
22:23:52 <bos> thanks!
22:53:19 <conal> bos: i like the writing.  looks like a winner!
22:53:24 <bos> thanks!
22:53:55 <notostraca> Has anyone else had trouble installing cabal-install?
22:54:25 <notostraca> I have tracked down all the dependencies, I think
22:55:04 <notostraca> Error message:
22:55:06 <notostraca> Building cabal-install-0.4.6...
22:55:06 <notostraca> Hackage/Tar.hs:26:7:
22:55:07 <notostraca>     Could not find module `Data.ByteString.Lazy':
22:55:07 <notostraca>       it is a member of package bytestring-0.9.1.0, which is hidden
22:55:30 <notostraca> I have downloaded bytestring
22:55:43 <notostraca> configured, built and installed it
22:57:24 * mwc tries to get ghc 6.8.2 running on powerpc-32/linux
22:57:30 <mwc> if anybody has a binary they'd like to share...
22:58:00 <geezusfreeek> nothingmuch: add "bytestring" to the dependencies in the cabal file
22:58:16 <geezusfreeek> ^ notostraca
22:58:21 <notostraca> I think its already there
22:58:49 <notostraca> yep
22:58:51 <notostraca> if flag(bytestring-in-base)
22:58:52 <notostraca>       build-depends: base >= 2.0 && < 2.2
22:58:52 <notostraca>     else
22:58:52 <notostraca>       build-depends: base < 2.0 || >= 3.0, bytestring >= 0.9
22:59:29 <notostraca> and I'm pretty sure ghc 6.8.2 has base >= 3.0
22:59:43 <geezusfreeek> hmm
23:00:06 <notostraca> what's bugging me is that it is "hidden"
23:00:19 <qimera> anybody here with experience using the haskell OpenGL bindings?
23:00:20 <geezusfreeek> notostraca: cabal hides all packages by default
23:00:35 <notostraca> how do I change that?
23:00:52 <notostraca> I have done ./Setup install, as root
23:01:48 <megeria> notostraca: what does it say when you type in ghc-pkg list bytestring?
23:02:23 <geezusfreeek> qimera: not extensive, but some
23:03:47 <qimera> geezusfreek: cool, do you know why the perspective function isn't changing anything?  i'm trying to set a wider field of view and farther far plane, but no matter the values i pass to perspective, nothing changes.
23:04:19 <qimera> i also tried the frustum function, but it also didnt change anything.  both of these in main, before entering the mainloop
23:04:38 <geezusfreeek> qimera: you are certain you are not popping the matrix, loading identity, forgetting to flush or swap the buffers, anything like that?
23:04:59 <sjanssen> notostraca: watch the output of 'Setup configure --verbose' and see if bytestring-in-base is set to false
23:05:16 <qimera> geezusfreeek: let me explicity set proj before perspective and modelview after and try that...
23:05:25 <cjs> Hey, what was that post about doing the fibonacci thing with memoization?
23:07:42 <geezusfreeek> cjs: that is a pretty common example of memoization, so it's not very obvious to me what post you are talking about
23:08:09 <cjs> Oh, there was some blog post that walked one through it slowly, from naive to memoized.
23:08:22 <cjs> I wanted to send it to a friend, but I can't find it any more.
23:08:53 <geezusfreeek> cjs: well, i kind of like this http://www.cs.utexas.edu/~wcook/Drafts/2006/MemoMixins.pdf
23:09:17 <geezusfreeek> it probably goes into way more than you want
23:09:49 <geezusfreeek> it just generalizes memoization in the form of a monad
23:10:09 <cjs> Oh wow. Way cool.
23:10:27 <cjs> It goes further than I want for this particular purpose, but I want that for other stuff. Thanks!
23:10:37 <geezusfreeek> heh, no prob
23:11:00 <qimera> geezusfreeek: odd, so I was calling loadIdentity at the beginning of each display call, but even when you explicity set the matrixMode $= Modelview 0 , loadIdentity seems to reset both the modelview and projection matrices
23:11:19 <qimera> i took that out and the perspective parameters now change stuff
23:11:32 <geezusfreeek> qimera: is your code trivial enough to hpaste it?
23:11:34 <megeria> cjs: don't know if you read this one but its funny http://www.willamette.edu/~fruehr/haskell/evolution.html
23:11:35 <lambdabot> Title: The Evolution of a Haskell Programmer
23:11:48 <cjs> Oh yeah.
23:11:50 <qimera> geezusfreeek: its pretty trivial yes, let me clean it up a bit first
23:11:54 <geezusfreeek> alright
23:16:34 <qimera> geezusfreeek: here it is, im actually not sure it was even that loadidentity call now, but u can see it at http://hpaste.org/7293
23:17:08 <qimera> just trying to do basic basic stuff...like spin a triangle, before I try anything else
23:17:22 <qimera> to compile is just ghc -package GLUT
23:17:31 <geezusfreeek> your perspective transformations usually should be set in the reshape function
23:17:46 <geezusfreeek> or that is what i am used to anyway
23:18:32 <geezusfreeek> generally projection and viewport transformations are set in the reshape function on the projection matrix, and for everything else you use modelview matrix
23:19:45 <qimera> geezusfreeek: ill try moving perspective func to reshape but it would eb strange if that fixed it, as setting the perspective projection matrix can be done from anywhere with the C API....
23:20:31 <geezusfreeek> true, but i just mean perhaps it is being messed up by the viewport being changed after setting it or something… this is a way of opengl programming i am unused to, so i'm just guessing
23:21:34 <qimera> yeah its pretty weird hehe
23:21:36 <qimera> trying that now
23:21:45 <geezusfreeek> generally in reshape you would go to projection matrix, load identity, set viewport, _then_ set projection, then switch back to modelview
23:22:38 <qimera> roger that
23:23:00 <qimera> i think that may have fixed it
23:23:13 <geezusfreeek> yay!
23:23:21 <qimera> yeah, its behaving as expected now
23:23:25 <qimera> you rock geezusfreeek!  thanks
23:23:31 <geezusfreeek> no prob
23:31:05 <notostraca> geezusfreek: ghc-pkg list bytestring
23:31:06 <notostraca>     bytestring-0.9.0.1, bytestring-0.9.1.0
23:31:49 <notostraca> wait a minute
23:31:52 <notostraca>     bytestring-0.9.0.1, bytestring-0.9.1.0
23:31:59 <notostraca> huh?
23:32:16 <geezusfreeek> that seems fine to me
23:32:18 <notostraca>  oh. /Library/Frameworks/GHC.framework/Versions/608/usr/lib/ghc-6.8.2.20080211/package.conf:
23:32:24 <notostraca> hmmm
23:32:38 <conal> i'm trying to build gtk2hs and am getting:
23:32:39 <conal> ./tools/c2hs/c2hsLocal.exe +RTS -M120m -RTS --cppopts='-include "gtk2hs-config.h"' --precomp=glib/glib.precomp glib-object.h
23:32:39 <conal> c2hsLocal.exe: glib-object.h: File does not exist
23:32:59 <conal> any suggestions?  i do have glib-object.h.
23:33:12 <conal> (i'm on windows)
23:33:19 <geezusfreeek> notostraca: try manually adding -package bytestring to the ghc options in the cabal file. if that works, something really weird is going on, but it would provide a temporary fix at least
23:33:50 <notostraca> thanks, I'll try it
23:34:06 <geezusfreeek> notostraca: or you could bypass cabal entirely and use ghc --make, which doesn't hide packages by default
23:36:17 * notostraca_ claps hands like a little girl
23:36:22 <notostraca_> it works!
23:36:46 <notostraca_> thanks a bunch, geezusfreek
23:37:28 <geezusfreeek> no prob, although that seems to be a worrying sign that something is pretty messed up with either ghc-pkg or cabal
23:37:43 <notostraca_> yeah, probably
23:37:55 <notostraca_> but I'll keep at it.
23:41:29 <Papageno> This isn't really in Haskell but I though you guys might be able to help me with this. If I have a list data structure in which swapping two equal-length contiguous chunks of entries is as expensive as swapping just two entries, what sort can I use that will be fastest considering this benefit?
23:43:11 <geezusfreeek> hmm… interesting data structure
23:44:35 <bd_> geezusfreeek: doubly linked lists have that property
23:44:46 <geezusfreeek> bd_: ah! yes
23:44:47 <megeria> Papageno: is the cost of reading the same as swapping?
23:45:25 <cjs> Hm. Something is tweaking me about a sort of merge sort.
23:45:35 <Papageno> Reading is less expensive than swapping
23:45:42 <geezusfreeek> i'm just guessing, but it seems to me that property wouldn't be useful for sorting random data but might be useful for partially sorted data somehow
23:46:26 <qimera> ls
23:46:31 <qimera> sorry, its late, :)
23:46:34 <qimera> goodnight \o
23:47:21 <Papageno> It seems almost like maybe the property is only good at reducing auxiliary space cost. But maybe in some sort of merge or heap sort it would even speed it up.
23:47:36 <Papageno> The data at the beginning is randomly ordered
23:48:26 <bd_> Papageno: Does it have to be a swap, or can you do, for lack of a better term, a 'cut and paste' operation? I could see that being useful in the merge phase of a merge sort
23:49:02 <Papageno> I don't quite understand what you mean by a 'cut and paste.' Can you elaborate on what that would be?
23:49:31 <bd_> eg, if we start with 123456789, move the '234' between 8 and 9 to get: 156782349
23:49:43 <bd_> ie, let everything inbetween shift over
23:51:46 <megeria> Papageno: i guess it depends on the relative cost of comparing vs swapping but if comparing is really cheap maybe a selection sort?
23:52:29 <megeria> Papageno: in theory if comparison is costless you could do a scan for the smallest element and swap that up front and repeat
23:55:10 <Papageno> Hmm... maybe. Well, I can just tell you what my structure is: I have an unsigned number (32 bits) and I'm reordering the bits according to some "value" of each bit where the value is stored in a longer unsigned number s.t. each bit has a set number of corresponding bits in this number. And because I can do something like x = ((b >> i) ^ (b >> j)) & ((1 << n) - 1); b = b ^ ((x << i) | (x << j)); to swap bit sequences in b
23:55:10 <Papageno> of length n at i and j, I can swap large chunks at the same cost of a single bit (except that if n is fixed I can precalc (1<<n)-1)
23:56:33 <Papageno> And to read I just logically and my bit field
23:56:44 <Papageno> And each time I swap my bits I'd have a corresponding swap in my value field
23:57:19 <Papageno> And in fact I'm doing this in parallel to many numbers which may have different bits but the bits at the same location share the same "value"
23:58:09 <Papageno> Sorry, I meant to say that to read I would logically and my value field
