00:01:01 <vixey> flip const = flip (\x _ -> x) = (\_ x -> x) = (\_ -> \x -> x) = (\_ -> id) = const id
00:01:41 * ski_ curses vixey and his fast fingers
00:01:51 <ski_> ;)
00:02:07 <paolino> @type flip const :: a -> a -> a
00:02:08 <lambdabot> forall a. a -> a -> a
00:02:55 <paolino> ok, const id :)
00:03:19 <dolio> @type flip asTypeOf
00:03:20 <lambdabot> forall a. a -> a -> a
00:03:45 <vixey> :t asTypeOf
00:03:46 <lambdabot> forall a. a -> a -> a
00:03:51 <vixey> @src asTypeOf
00:03:52 <lambdabot> asTypeOf = const
00:03:56 <vixey> o_O
00:04:02 <paolino> I use that for a not updating Map.insertWith
00:06:14 <dolio> @type 2 `asTypeOf` (3 :: Int)
00:06:16 <lambdabot> Int
00:06:27 <vixey> :/
00:06:30 <vixey> @type 2 :: Int
00:06:32 <lambdabot> Int
00:06:45 <dolio> It's from before that was allowed.
00:06:52 <vixey> oh I see
00:07:01 <vixey> I thought :: was always part of Haskell
00:07:15 <dolio> Not in the middle of expressions, I think.
00:07:24 <vixey> hey I guess that explains why the picked :: rather than : ?
00:11:04 <Cale> Huh?
00:11:12 <Cale> Type annotating expressions has always been allowed, I'm pretty sure.
00:12:19 <Cale> Yeah, expression type signatures are in the Haskell 1.0 report.
00:12:24 <dolio> Huh.
00:12:44 <Cale> It's adding type signatures to pattern variables which is a GHC extension.
00:13:43 <dolio> I'm not sure why you'd need asTypeOf, then.
00:13:43 <vixey> pattern variables... like case  x of y :: Int -> ..?
00:13:52 <vixey> I don't know why that would ever be done
00:14:37 <cpoucet> vixey: case read x of ..
00:14:48 <vixey> :t read
00:14:49 <lambdabot> forall a. (Read a) => String -> a
00:15:00 <vixey> hm
00:15:16 <dolio> I guess there are potentially situations where you might need asTypeOf if you don't have scoped type variables.
00:15:21 <vixey> case read x of i :: Int -> Left i ; s :: String -> Right s -- ?
00:15:42 <cpoucet> no
00:15:53 <cpoucet> one 'a'
00:17:38 <cpoucet> Oh wait
00:17:47 <cpoucet> yeah, that won't work
00:17:58 <ski_> foo (x :: Int) = ...
00:18:07 <ski_> foo = \(x :: Int) -> ...
00:18:19 <ski_> case ... of x :: Int -> ...
00:19:24 <ski_> dolio : hm, that could be it
00:20:16 <dolio> ski_: I can't remember the last time I needed expressions annotated with scoped type variables, though. :)
00:20:35 <ski_> probably existentials
00:21:00 <ski_> or inner definitions inside polymorphic functions
00:22:25 * ski_ str Hughes had some example of a value binding which didn't get accepted because of DMR wanted type signature, but type signature couldn't mention some nonlocal tyvar
00:26:13 <nomeata> gwern: hi. thx for the patches. I wonder why darcswatch didnâ€™t pick them up, maybe a parsing bug.
00:28:55 <nomeata> gwern: ah, yes, bug in the mail reading code. patches were recorded, but the update did not happen
00:32:45 <solrize_> signatures in pattern variables is really useful
00:32:58 <solrize_> x :: Integer = d + e + f
00:33:19 <vixey> better than
00:33:23 <vixey> x = d + e + f :: Integer -- ?
00:33:26 <solrize_> if that counts as a (trivial) pattern
00:33:33 <solrize_> vixey, yes, in a messy expression
00:33:40 <vixey> :S
00:33:51 <solrize_> e.g.      x :: Int =  f a (g b)
00:33:54 <cpoucet> vixey: I haven't yet needed types on expressions
00:33:59 <solrize_> where the type is otherwise determined by the type on a
00:34:02 * vixey neither
00:34:25 <solrize_> e.g. f is something like (t -> t2) -> String -> t2
00:34:36 <solrize_> wait
00:34:38 <solrize_> well you know what i mean
00:35:03 <cpoucet> solrize_: that made no sense whatsoever
00:35:39 <nomeata> gwern: anyway, thx for the patches, applied them all.
00:36:37 <dolio> I'd probably rather write '\(x :: a) -> e' than '(\x -> e) :: a -> b'.
00:37:11 <vixey> can't you write (\x -> e) instead?
00:37:27 <cpoucet> yes
00:37:30 <dolio> Not if x requires annotation to compile correctly.
00:37:41 <cpoucet> dolio: how often does that occur?
00:37:51 <dolio> Occasionally.
00:37:55 <vixey> when that happens? .. it's like you have some transformer stack and havent used the procedure in it yet?
00:38:07 <vixey> I can't remember any other occurences
00:38:15 <vixey> and it goes away once you make the link
00:38:35 <dolio> If it were supported in @check, people would use it all the time.
00:38:49 <dolio> Instead they annotate stuff in the middle of expressions, which is terrible.
00:38:53 <vixey> maybe it's more important when you write modules/libs for use from other programs?
00:41:42 <solrize_> cpoucet:maybe   f :: (Num t1) => t -> t1 -> t
00:41:58 <solrize_> anyway ther'es been times when i wanted something like that
00:46:52 <ski_> \(f :: a -> _) -> ...
00:54:03 <dolio> @type let f x = (do (_ :: Int) <- cast x ; return "Got Int") `mplus` (do (_ :: String) <- cast x ; return "Got String") `mplus` return "Got something else" in f
00:54:05 <lambdabot> forall a. (Typeable a) => a -> Maybe [Char]
00:54:57 <vixey> > f "Got something else"
00:55:02 <lambdabot>  Add a type signature
00:55:10 <vixey> > f "Got something else" :: Maybe [Char]
00:55:10 <lambdabot>        add an instance declaration for
00:55:10 <lambdabot>       (SimpleReflect.FromExpr (Maybe [...
00:55:26 <vixey> > dolio.f "Got something else" :: Maybe [Char] -- :S
00:55:27 <lambdabot>   Not in scope: `dolio'
00:55:45 <vixey> I can't use it
00:55:55 <cpoucet> vixey: just use 'f'
00:55:55 <dolio> It was just a @type
00:56:17 <cpoucet> @type \shoot foot -> shoot `on` foot
00:56:18 <dolio> You can't do that in > because the extra parser blows up.
00:56:19 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
00:57:40 <dolio> > let f x = case cast x of Just (x :: Int) -> "Got Int" ; Nothing -> "Got something else" in f "foo"
00:57:40 <lambdabot>  Parse error in pattern at "->" (column 42)
00:58:03 <cpoucet> {}
00:58:22 <dolio> The @run parser doesn't do pattern type signatures, it seems.
00:58:36 <sjanssen> nope
00:59:06 <mae> so, if one of you were to *gasp* use a haskell database library, would you use haskelldb, takusen, or hdbc/hsql directly?
00:59:25 <dolio> @let f x = (do (_ :: Int) <- cast x ; return "Got Int") `mplus` (do (_ :: String) <- cast x ; return "Got String") `mplus` return "Got something else"
00:59:26 <lambdabot>  Parse error in pattern
00:59:42 <dolio> > f "foo"
00:59:43 <lambdabot>  Add a type signature
00:59:45 <sjanssen> dolio: let uses the same parser, naturally
01:00:09 <dolio> I wasn't sure. @type doesn't.
01:00:12 <vixey> @docs Typeable
01:00:12 <lambdabot> Typeable not available
01:00:16 <dolio> But that's a different plugin, I guess.
01:00:25 <vixey> @docs Sound
01:00:25 <lambdabot> Sound not available
01:00:42 <sjanssen> dolio: @type also doesn't have the same code injection vulnerabilities
01:02:32 <dolio> @type \(x :: forall a. a -> b) -> x x
01:02:34 <lambdabot>     A pattern type signature cannot bind scoped type variables `b'
01:02:34 <lambdabot>       unless the pattern has a rigid type context
01:02:34 <lambdabot>     In the pattern: x :: forall a. a -> b
01:04:45 <dolio> @type \(x :: forall a. a -> Int) -> x x
01:04:46 <lambdabot> (forall a. a -> Int) -> Int
01:12:00 <quicksilver> I don't suppose anyone has tried render to texture with haskell/opengl
01:12:14 <quicksilver> I'm trying to do it with copyTexImage2D and it ain't working
01:21:13 <cjs> Is there some handy package for dealing with unix command line argument processing in haskell?
01:21:34 <vixey> yes
01:21:48 <vixey> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html
01:21:49 <lambdabot> http://tinyurl.com/yyvufm
01:28:55 <cjs> Thanks.
01:33:42 <cjs> @type Data.Map.lookup
01:33:44 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
01:33:52 <cjs> Man, sometimes Haskell is soooo cool.
01:33:59 <cjs> I just realized how that works.
01:34:16 <Baughn> cjs: ..but that function is considered Bad
01:34:33 <quicksilver> well its type signature is bad.
01:34:40 <quicksilver> it's quite good as a function ;)
01:34:44 <quicksilver> just has a slightly too general type.
01:34:46 <Baughn> Mostly because lots of monads don't have reasonable fail implementations. And MonadFail doesn't exist.
01:34:54 <cjs> Is it? I really like the idea of specifying how failure works by chosing the monad, which is implicit in the type you request as the return type.
01:35:04 <vegai> so what you're all saying is that Haskell is not so cool after all? :)
01:35:16 <quicksilver> cjs: but monads don't support failure.
01:35:19 <Baughn> The problem, apparently, is that you can pick a monad that will crash your program on failure
01:35:28 <Baughn> ...personally, I don't mind. I /know/ what monad I'm using.
01:35:40 <quicksilver> cjs: it's a bug in the specification of Monad
01:35:43 <cjs> Crash as in core dump, or crash as in exception that terminates the program?
01:35:43 <vixey> @src lookup
01:35:43 <lambdabot> lookup _key []          =  Nothing
01:35:43 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
01:35:44 <lambdabot>                         | otherwise = lookup key xys
01:35:50 <vixey> um....
01:36:03 <vixey> @src Data.Map.lookup
01:36:04 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
01:36:14 <quicksilver> cjs: if the type was 'MonadWhoCanFail m' then we'd be quite happy ;)
01:36:24 <quicksilver> some people call that MonadZero. MonadError is related.
01:36:25 <cjs> quicksilver: I'll buy that for a dollar.
01:36:27 <vixey> where is the source code for Data.Map.lookup?
01:36:33 <mauke> cjs: crash as in runtime exception
01:36:40 <quicksilver> vixey: on the website, where all the other source is.
01:36:51 <vixey> sorry which website?
01:36:54 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html
01:36:56 <lambdabot> http://tinyurl.com/34gle9
01:37:00 <vixey> thanks
01:37:02 <int-e> @source Data.Map
01:37:03 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
01:37:15 <vixey> :o
01:37:19 <vixey> excellent!
01:37:23 <cjs> mauke: I see. Well, yes, I can see that it's annoying that the type checking system can't catch that.
01:37:26 <vixey> I never notced there was source code with this
01:37:42 <vixey> :t fail
01:37:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
01:37:45 <cjs> vixey: You've been missing a lot. :-)
01:37:51 <vixey> @src fail
01:37:51 <quicksilver> int-e: the web page is nicer thant he direct link
01:37:52 <lambdabot> fail s      = error s
01:37:55 <vixey> :t error
01:37:57 <lambdabot> forall a. [Char] -> a
01:37:58 <quicksilver> int-e: on the one hand, it actually works.
01:38:06 <quicksilver> int-e: on the other hand it's hyperlinked and stuff :)
01:38:10 <cjs> Ha, no wonder this article is so cool: http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/18
01:38:14 <lambdabot> Title: Haskell hacking
01:38:16 <vixey> Baughn: It wouldn't really be a crash would it ?
01:38:17 <cjs> It's dons' blog.
01:38:23 <int-e> quicksilver: Yes I know that the link was broken.
01:38:26 <quicksilver> int-e: ah :)
01:38:36 <quicksilver> even when it worked it wasn't as nice as the hyperlinked haddock.
01:38:59 <dibblego> ?type \f g a b -> case (a, b) of (Nothing, Nothing) -> True; (Just a', Nothing) -> f a'; (Nothing, Just b') -> g b'; (Just a', Just b') -> f a' || g b' -- can this be written with liftM2 somehow?
01:39:01 <lambdabot> forall t t1. (t -> Bool) -> (t1 -> Bool) -> Maybe t -> Maybe t1 -> Bool
01:39:19 <int-e> it is, I didn't know that. I haven't looked at those docs in ages.
01:39:36 <dibblego> actually, I think it can (along with Maybe a -> a -> a)
01:39:39 <Baughn> vixey: It would cause the program to abruptly exit, likely unexpectedly. Close enough.
01:39:46 * int-e types 'x Data/Map' on the shell prompt to read the source code
01:39:54 <vixey> let q f Nothing =True ; Just x -> f x)
01:40:02 <quicksilver> dibblego: (maybe True f a) || (maybe True g b)
01:40:04 <quicksilver> dibblego: I think ?
01:40:22 <dibblego> I don't think so
01:40:32 <quicksilver> ?type \f g a b -> (maybe True f a) || (maybe True g b)
01:40:35 <lambdabot> forall a a1. (a -> Bool) -> (a1 -> Bool) -> Maybe a -> Maybe a1 -> Bool
01:40:42 <quicksilver> it has the right type.
01:41:04 <dibblego> @check \f g a b -> case (a, b) of (Nothing, Nothing) -> True; (Just a', Nothing) -> f a'; (Nothing, Just b') -> g b'; (Just a', Just b') -> f a' || g b' == (maybe True f a) || (maybe True g b)
01:41:07 <lambdabot>  OK, passed 500 tests.
01:41:32 <vixey> :t ((||)`on`maybe True)
01:41:35 <lambdabot>     Couldn't match expected type `Bool'
01:41:35 <lambdabot>            against inferred type `Maybe a -> Bool'
01:41:35 <lambdabot>     Probable cause: `maybe' is applied to too few arguments
01:41:50 <vixey> aw
01:41:59 <dolio> fromMaybe
01:42:39 <dibblego> ?type \f g a b -> fromMaybe True (liftM2 (\a' b' -> f a' || g b') a b)
01:42:41 <lambdabot> forall a1 a2. (a1 -> Bool) -> (a2 -> Bool) -> Maybe a1 -> Maybe a2 -> Bool
01:43:50 <ski_> @type curry (uncurry (||) . (?f *** ?g))
01:43:52 <lambdabot> forall a b. (?g::b -> Bool, ?f::a -> Bool) => a -> b -> Bool
01:50:17 <quicksilver> dibblego: there is something funny about the use of True and ||
01:50:27 <quicksilver> dibblego: I would imagine you would either want False and || or True and &&
01:50:33 <quicksilver> since they're the units.
01:50:44 <dibblego> indeed, it's bothering me too
01:50:58 <quicksilver> dibblego: and I think quickcheck lied to you.
01:51:08 <quicksilver> I think it defaulted some type to () and didn't check well :)
01:51:17 <dibblego> I don't trust lambdabot ever since Cale screwed with it (or GHC 6.8.2; not sure which)
01:51:21 <dibblego> right
01:51:41 <quicksilver> lambdabot has always had extended defaulting. Don't think we can blame cale for that.
01:51:44 <haskbob> hello does anyone know when the next release of ghc is scheduled
01:51:52 <dibblego> no, it hasn't
01:52:00 <dibblego> I think maybe it is since it runs on 6.8.2
01:52:11 <Cale> It's had it for longer than I've been maintaining lambdabot certainly.
01:52:32 <quicksilver> haskbob: there isn't a schedule AFAIK. I would expect 6.8.3 within a month or two but I don't hinkk there are precise plans for 6.10 yet.
01:52:34 <dibblego> there was a time where it would ask for a type signature rather than generate ()
01:52:46 <quicksilver> depends on the circumstance.
01:52:51 <quicksilver> the defaulting rules are a bit odd.
01:53:01 <pejo> haskbob, some comment on ghc-users said around ICFP this year iirc.
01:53:05 <quicksilver> I'm sure the 6.6 version did extended defaulting.
01:53:09 <mauke> http://www.haskell.org/pipermail/glasgow-haskell-users/2008-March/014467.html
01:53:10 <lambdabot> Title: Release plans, http://tinyurl.com/58zzwv
01:53:18 <quicksilver> @check a == b
01:53:20 <lambdabot>  Falsifiable, after 0 tests:
01:53:25 <haskbob> thanks
01:53:25 <quicksilver> @check \a b -> a == b
01:53:27 <lambdabot>  OK, passed 500 tests.
01:53:30 <quicksilver> hmm
01:53:42 <Cale> @check a == a
01:53:43 <lambdabot>  OK, passed 500 tests.
01:53:47 <mauke> @check (==)
01:53:48 <lambdabot>  OK, passed 500 tests.
01:53:56 <mauke> @check (/=)
01:53:56 <lambdabot>  Falsifiable, after 0 tests: (), ()
01:53:58 <vixey> @check \a b -> a == b
01:53:59 <lambdabot>  OK, passed 500 tests.
01:54:04 <vixey> @check \a b c -> a == b && a == c
01:54:06 <lambdabot>  OK, passed 500 tests.
01:54:09 <dibblego> quicksilver, what did it lie about anyway? the function you gave is inequivalent?
01:54:23 <Cale> quicksilver: Expr ;)
01:54:26 <dibblego> @check \f g a b -> case (a, b) of (Nothing, Nothing) -> True; (Just a', Nothing) -> f a'; (Nothing, Just b') -> g b'; (Just a', Just b') -> f a' || g b' == (maybe True f a) || (maybe True (g :: Int -> Bool) (b :: Maybe Int))
01:54:27 <lambdabot>  OK, passed 500 tests.
01:54:33 <quicksilver> dibblego: I think so, yes. It would be equivalent if your function had been continuous in the sense I had expected.
01:54:34 <mauke> @check null . drop 1 . nub
01:54:35 <Cale> > a == b
01:54:35 <lambdabot>  OK, passed 500 tests.
01:54:36 <lambdabot>  False
01:54:41 <quicksilver> hmm
01:54:48 <quicksilver> maybe it was right ;)
01:55:16 <Cale> You really can't expect quickcheck to give you sane results all the time without pinning down some of the type variables.
01:56:13 <dibblego> I am using \f g a b -> fromMaybe True (liftM2 (\a' b' -> f a' || g b') a b) but it still doesn't feel right
02:05:04 <dmwit> \f g a b -> fromMaybe True (liftM2 (||) (fmap f a) (fmap g b))
02:05:11 <mauke> ooh, I want a deriving extension
02:05:30 <cpoucet> :t maybe
02:05:32 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
02:05:37 <mauke> that is: if a class has no methods, it should be autoderivable
02:05:52 <dmwit> Oh, I see what you want now.
02:06:23 <cpoucet> dmwit: fromMaybe True $ (||) <$> (f <$> a) <*> (g <$> b)
02:06:25 <Baughn> Or if all the methods have default implementations
02:06:52 <Baughn> While you're at it, you should expand the interface enough so the current derivations can be written in haskell. ;)
02:07:02 <dmwit> cpoucet: That doesn't look better to me.
02:07:04 <dmwit> Just different.
02:07:11 <cpoucet> I'm golfign
02:07:17 <dmwit> ok
02:07:19 <dmwit> =)
02:08:00 <dmwit> > True `mappend` True
02:08:02 <lambdabot>   add an instance declaration for (Monoid Bool)
02:08:02 <lambdabot>     In the expression: True `...
02:08:04 <dmwit> bummer
02:08:15 <dmwit> Aha!
02:08:33 <dmwit> \f g a b -> all . catMaybes $ [fmap f a, fmap g b]
02:08:36 <dmwit> Beautiful!
02:08:44 <cpoucet> now
02:08:47 <cpoucet> @pl that :)
02:08:49 <lambdabot> (line 1, column 7):
02:08:49 <lambdabot> unexpected ")"
02:08:49 <lambdabot> expecting white space or simple term
02:09:09 <cpoucet> @pl  \f g a b -> all . catMaybes $ [fmap f a, fmap g b]
02:09:11 <lambdabot> ((((all . catMaybes) .) .) .) . (. flip (flip . ((:) .) . fmap) []) . flip . (((.) . (:)) .) . fmap
02:09:15 <dmwit> dibblego: ping
02:09:25 <dibblego> dmwit, I'm watching, I like your last one :)
02:09:33 <dmwit> =)
02:09:33 <dibblego> dmwit, nice, thanks
02:09:45 <cpoucet> dmwit: that's the second time a list was very useful, last time it was something similar, some other monad
02:09:46 <dibblego> dmwit, that was what was irking me
02:10:00 <cpoucet> > all []
02:10:03 <lambdabot>  Couldn't match expected type `a -> Bool'
02:10:07 <dmwit> oh
02:10:07 <cpoucet> :t all
02:10:11 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
02:10:13 <cpoucet> > all id []
02:10:14 <dmwit> s/all/and/
02:10:16 <lambdabot>  True
02:10:19 <dmwit> or whatever
02:10:24 <dmwit> > or []
02:10:25 <lambdabot>  False
02:10:30 <dmwit> oh, hm
02:10:33 <dmwit> That's bad.
02:10:36 <cpoucet> no it's not
02:10:37 <cpoucet> you want identity
02:10:52 <dmwit> > any id [] -- not better
02:10:53 <lambdabot>  False
02:11:13 <dmwit> Another beautiful theory ruined by the facts.
02:12:06 <cpoucet>  \f g a b -> uncurry (||) . (null &&& or) .  catMaybes $ [fmap f a, fmap g b]
02:12:20 <dmwit> heh
02:13:12 <dmwit> \f g a b -> liftM2 (||) null or $ catMaybes [fmap f a, fmap g b]
02:13:23 <dmwit> =/
02:13:27 <cpoucet>  \f g a b -> ((||) <$> null <*> or) .  catMaybes $ [fmap f a, fmap g b]
02:13:29 <cpoucet> reader monad
02:13:40 <dmwit> yep
02:13:53 <dmwit> There must be something else we can do here...
02:14:03 <dmwit> Oho!
02:14:04 <cpoucet>  \f g a b -> or . flip (map [null, or]).  catMaybes $ [fmap f a, fmap g b]
02:14:22 <cpoucet>  \f g a b -> or . flip (map ($)) [null, or] .  catMaybes $ [fmap f a, fmap g b]
02:14:27 <dmwit> hmm
02:14:31 <cpoucet> oh no, wn't work
02:27:12 <zeno_> ive distilled what im trying to do into a snippit, but cant tell whats wrong, http://hpaste.org/7246, does anyone know?
02:29:14 <zeno_> ah never mind i got it
02:29:53 <dmwit> You need to be able to accept *any* (A) type, not just the Ai instance.
02:29:54 <bd_> and I was just about so say something too :)
02:30:20 <dmwit> Bah, him figuring it out shouldn't stop you. =)
02:39:11 <dibblego> @check \f g a b -> case (a, b) of (Nothing, Nothing) -> True; (Just a', Nothing) -> f a'; (Nothing, Just b') -> g b'; (Just a', Just b') -> f a' || g b' == fromMaybe True (liftM2 (\a' b' -> f a' || g b') a b)
02:39:13 <lambdabot>  OK, passed 500 tests.
02:39:19 <zeno_> if I have a class like (B b) => A a b | g -> b where... how do i specify in the insance what B is for that instance?
02:39:29 <dibblego> @check \f g a b -> case (a, b) of (Nothing, Nothing) -> True; (Just a', Nothing) -> f a'; (Nothing, Just b') -> g b'; (Just a', Just b') -> f a' || g b' == fromMaybe True (liftM2 (\a' b' -> f a' || g b') (a :: Maybe Int) (b :: Maybe Int))
02:39:31 <lambdabot>  OK, passed 500 tests.
02:39:58 <dibblego> I don't think that should be passing
02:41:53 <zeno_> dmwit:  if I have a class like (B b) => A a b | g -> b where... how do i specify what B is for instance A SomeInstance where... ?
02:44:38 <mauke> you don't specify anything. B is B.
02:44:52 <mauke> also, what is g?
02:45:34 <zeno_> sorry g should be replaced with a
02:48:43 <zeno_> mauke: how do i specify what instance of B should be used in SomeInstance?
02:49:59 <mauke> how do you specify the instance of A?
02:50:18 <mauke> answer: by putting the type in the parameter list of the instance declaration
02:54:06 <quicksilver> zeno_: you don't.
02:54:15 <quicksilver> zeno_: for any given type 'b' there is only one instance of B
02:54:19 <quicksilver> zeno_: instances are global things.
02:54:26 <quicksilver> zeno_: so the type 'b' either has a B instance or it doesn't
02:59:37 <Deewiant> @scheck \f g a b -> case (a, b) of (Nothing, Nothing) -> True; (Just a', Nothing) -> f a'; (Nothing, Just b') -> g b'; (Just a', Just b') -> f a' || g b' == fromMaybe True (liftM2 (\a' b' -> f a' || g b') (a :: Maybe Int) (b :: Maybe Int))
02:59:38 <lambdabot>   Failed test no. 66. Test values follow.: {-3->True;-2->True;-1->True;0->Tru...
03:00:08 <dibblego> yay for scheck!
03:00:10 <Deewiant> dibblego: always try smallcheck as well. :-)
03:00:13 <dibblego> thanks
03:00:33 <mauke> @vixen ich lach mich scheckig
03:00:33 <lambdabot> where on a map is Panama?
03:00:38 <dibblego> I'm actually using another language where things like liftM2 might be bogus as well
03:00:57 <Deewiant> which language is that?
03:01:11 <dibblego> Scala (I wrote liftM2 myself)
03:01:24 <Deewiant> heh, cool
03:01:33 <zeno_> quicksilver: could you possibly show me what that instance should look like? i cant find any associated type examples
03:03:11 <zeno_> http://hpaste.org/7250
03:04:13 <zeno_> isnt scala java FP?
03:04:30 <dibblego> not really; it's just Java fixed up quite a bit
03:04:38 <dibblego> it has some FP ideas in it though
03:04:45 <dibblego> it's impure and strict
03:06:48 <quicksilver> zeno_: how can I possibly know what it might look like? :)
03:06:53 <quicksilver> zeno_: it depends what the class B is supposed tobe.
03:07:01 <quicksilver> zeno_: and that doesn't look like associated types to me.
03:07:29 <quicksilver> mixing FDs and ATs is probably asking for pain.
03:07:34 <quicksilver> what are you trying to do, in fact?
03:07:48 <mauke> http://hpaste.org/7250#a1
03:08:38 <dibblego> > any id []
03:08:39 <lambdabot>  False
03:11:01 <zeno_> quicksilver: without the associated types (like
03:11:01 <zeno_> module Game where
03:11:01 <zeno_> -- This module attemps to define a structure that will model most games.
03:11:01 <zeno_> import System.Time
03:11:01 <zeno_> import Data.Maybe
03:11:18 <cpoucet> zeno_: stop!
03:11:21 <cpoucet> use @paste please
03:11:26 <zeno_> crap i hit copy on hpaste thing
03:11:28 <zeno_> sorry
03:11:33 <zeno_> my bad :(
03:11:37 <cpoucet> np
03:11:42 <zeno_> http://hpaste.org/7251
03:11:52 <zeno_> my client didnt ask me even it jsut pasted it all :(
03:11:53 <vixey> lambdabot will announce it for you if you let her
03:12:17 <vixey> zeno_: irssi asks
03:12:19 <zeno_> well, anyways, thats what it is without the associated types but it doesnt compile
03:12:50 <zeno_> ok cool ill try that one
03:13:53 <andrew___> its zeno
03:14:11 <andrew___> i can even run this one without X it seems :)
03:14:34 <quicksilver> andrew___: I think you misunderstand what associated types are.
03:14:43 <quicksilver> andrew___: let's get some terminology straight first
03:14:46 <quicksilver> | a -> b
03:14:53 <quicksilver> that's a functional dependency
03:15:46 <quicksilver> now you don't have any multi-parameter classes so I doubt you need fundeps here.
03:15:48 <dolio> You didn't really need to paste that again. It's still in the top 10 newest on hpaste.
03:15:51 <quicksilver> what seems to be the problem?
03:16:30 <dolio> And you should really annotate existing existing pastes when they're all dealing with the same problem, since that makes it easier to see all at once.
03:17:07 <quicksilver> hmm. the GameAction class looks a bit suspicious.
03:17:19 <quicksilver> since you would be able to use any action in any game.
03:17:22 <andrew___> dolio: ok im sorry
03:18:14 <andrew___> quicksilver: i want games to only be able to use (a few) types of actions
03:18:19 <dolio> quicksilver: The original problem is that he's effectively calling 'getStatus (startingState g)' which goes from 'Game g => g' to 'GameStatus' through an ambiguous 'GameState s => s'.
03:19:23 <dolio> When in fact 'startingState' should probably be 'g -> s' where s is associated to g, instead of it being 'forall s. GameState s => g -> s'.
03:20:26 <andrew___> how do you associate s to g?
03:20:37 <dolio> (It could be existential, too, but that's unlikely to be what he wants, I think).
03:21:17 <quicksilver> to me this looks like a terrible over-use of classes
03:21:23 <quicksilver> I wouldn't use classes at all for this I suspect
03:21:26 <quicksilver> certainly not in a first draft.
03:21:28 <dolio> Well, if you're using functional dependencies, you make Game into a multi-parameter type class, and have s fucntionally depend on g.
03:21:52 <quicksilver> or make GameAction multi-parameter
03:22:01 <dolio> It's a distinct possibility that you are over-engineering things, yes.
03:22:02 <quicksilver> so it's an action 'a' in the context of a Game 'g'
03:22:20 <quicksilver> It may well be that you don't want three classes at all, you want one class.
03:22:32 <andrew___> i can get it to compile by changing to http://hpaste.org/7251#a1, but i dont know how to write an instance then
03:22:34 <quicksilver> Game g s a
03:22:54 <quicksilver> getting it to compile is a rather limited goal :)
03:23:01 <quicksilver> a better goal would be understand what you want it to do
03:23:06 <quicksilver> and work out how to do it :)
03:23:31 <quicksilver> Why is a gamestate different from a game?
03:23:34 <quicksilver> why two classes?
03:23:38 <quicksilver> why not set g == s and combine them?
03:23:53 <andrew___> quicksilver: its a snapshot, e.g. one chess position, rather than the entire chess game
03:24:03 <quicksilver> yes
03:24:10 <quicksilver> but why does "the entire ches game" want to be a class.
03:24:12 <quicksilver> I'm not convinced.
03:24:37 <quicksilver> If I was doing something like this I'd probably use the state as the central datum to attach the class to.
03:24:40 <andrew___> i guess it could
03:24:51 <quicksilver> Although as I say I'm not convinced you should be using classes at all.
03:24:54 <quicksilver> This smells of OOP.
03:25:00 <quicksilver> haskell classes are not oop classes :)
03:26:10 <dolio> Making startingState into 'exists s. GameState s => g -> s' would be very OOP.
03:26:18 <dolio> Which is a clue, I guess.
03:26:49 <andrew___> quicksilver: ya im kind of trying to emulate oop, its what i knew before haskell
03:27:15 <quicksilver> ;)
03:27:32 <quicksilver> haskell classes are something rather different from OOP classes
03:27:32 <andrew___> ill just eleminate the entire Game file for now =p
03:27:43 <quicksilver> they do admiteedly overlap in a couple of interesting areas
03:27:58 <quicksilver> but really haskell type classes are a way of overloading.
03:31:21 <dolio> Type classes are kind of like definitions in mathematics.
03:31:59 <andrew___> ya ill just steer clear of those till i have monads mastered =p
03:32:09 <dolio> 'A group is a set G with an inverse G -> G and a binary operation G -> G -> G'
03:32:27 <dolio> 'class Group g where inverse :: g -> g ; binaryOp :: g -> g -> g'
03:33:45 <andrew___> hmmm it seems this client only lets you be in 1 channel at a time
03:34:07 <andrew___> i guess i could just run a bunch of them
03:34:34 <Deewiant> which client is that?
03:35:46 <andrew___> irssi (just installed it)
03:36:06 <cpoucet> andrew___: you can be in many channelsl
03:36:12 <Deewiant> I'm using irssi and this is my 14th channel :-P
03:36:14 <quicksilver> "/join #newchannelname"
03:36:15 <cpoucet> andrew___: press ctrl+n and ctrl+p
03:36:41 <cpoucet> maybe he already joined another channel and can't read us
03:36:53 <Deewiant> heh
03:36:55 <quicksilver> ;)
03:37:08 <andrew___> cpoucet: ah thanks :)
04:07:40 <__pao__> hi all :-)
04:08:35 <__pao__> in order to install cabal-install I need to checkout from darcs and install from source, right?
04:08:54 <dcoutts> __pao__: yes, until we make a release in a few weeks
04:10:48 <__pao__> dcoutts: thanks... would you generally suggest darcs 1.0.9 or 2.0.0pre4? is 2.0.0 backward compatible with old repos?
04:11:18 <dcoutts> __pao__: I've no idea about which darcs to use at the moment, ask someone else
04:11:31 <dcoutts> I'm not well informed on the issue
04:11:39 <__pao__> dcoutts: ok, thanks
04:12:03 <__pao__> dcoutts: are you using darcs 1 for cabal devel?
04:12:15 <dcoutts> __pao__: yes
04:12:40 <dcoutts> when everyone else switches we'll switch too
04:13:25 <__pao__> dcoutts: thats a good indirect advice on darcs version :-)
04:13:35 <dcoutts> __pao__: I guess so :-)
04:14:12 <kfish> it's good to wait till its widely available, eg. packaged in a released ubuntu
04:14:30 <dcoutts> heh, we might have to wait a long time
04:14:54 <dcoutts> ubuntu still uses ghc-6.6 iirc
04:15:17 <kfish> sure, which is why i try to make sure stuff works with it :-)
04:15:22 <__pao__> dcoutts: you're right, april release ubuntu spots 6.6
04:16:12 <dcoutts> kfish: how do we get them to keep up a bit better? can we get someone more involved or does it just rely on the debian packages keeping up?
04:16:14 <__pao__> which is the "right tool" to develop C-Haskell bindings?
04:16:25 <dcoutts> __pao__: c2hs or hsc2hs
04:16:54 <kfish> dcoutts, afaik ubuntu doesn't have its own haskell team, it just pulls from debian (ie. ubuntu universe)
04:17:01 <__pao__> dcoutts: It definitely an upstream (debian) problem
04:22:13 <__pao__> 6.8 went in debian unstable december the 18th... too late for ubuntu hardy
04:25:27 <maltem> Hm? I thought 6.8 would be in Hardy
04:25:37 <maltem> packages.ubuntu.com is down...
04:27:02 <dolio> 6.8 is in hardy.
04:27:10 <maltem> right
04:28:00 <maltem> now, stupid work is calling...
04:29:32 <__pao__> ops... sorry for the wrong info... you're right
04:33:30 <don333> I don't quite get what is allowed as a pattern in case expressions
04:33:49 <don333> that's what I mean - http://hpaste.org/7254
04:34:19 <don333> GHC even warns me that "Pattern match(es) are overlapped"
04:34:44 <mauke> first starts with a lowercase letter, which means it's a variable
04:34:59 <mauke> a variable in a pattern matches anything and is bound to the value that is matched
04:35:37 <don333> well, "first" in my example is of type String (or [Char] for that matter)
04:35:46 <mauke> irrelevant
04:36:11 <don333> isn't 'first
04:36:14 <don333> '
04:36:22 <don333> a function?
04:36:27 <mauke> no
04:37:10 <don333> mauke: ok, that explains the result
04:37:28 <mauke> o_O
04:39:45 <don333> and how do you write a case expression with result of a function of the left hand side?
04:39:55 <don333> is it possible?
04:39:57 <mauke> you don't
04:40:04 <mauke> you need guards for that
04:40:34 <__pao__> join #gammu
04:40:34 <don333> mauke: thanks again
04:41:05 * don333 goes to study pattern guards
04:41:15 <mauke> the only things you can use in patterns are constructors, variable names and _
04:41:33 <mauke> pattern guards are something else altogether :-)
04:42:37 * don333 has even more to study, as it seems
04:42:37 <quicksilver> don333: case s of s | s == first -> "The first" | s == second -> "The second"
04:42:51 <mauke> case s of s is useless
04:43:08 <mauke> might as well write 'if s == first then ...'
04:43:16 <quicksilver> guards look nicer than if
04:43:17 <quicksilver> IMO
04:43:28 <mauke> case () of _ | ...
04:43:30 <quicksilver> and case s of s feels logical although you can write case s of _ if you prefer
04:43:33 <quicksilver> or indeed that.
04:43:52 <quicksilver> but case s of s is reasonable even if pointess
04:44:05 <DuClare> Is it normal for ghc to have hundreds of child threads?
04:44:47 <quicksilver> no.
04:44:53 <DuClare> :(
04:57:28 <Taggnostr> I want to start with haskell, do you suggest hugs or ghc?
04:57:52 <dolio> ghc
05:08:32 <eugman|college> Anyone have a good simple example I can use of how it's possible to avoid much of the old while/for flow structure with haskell? The example I have so far is using foldl to sum a list
05:08:47 <mauke> I'd use 'sum' to sum a list
05:10:30 <eugman|college> yes, it'd make more sense to use something built in but I'm just trying to demonstrate differences from the normal imperative mindset
05:10:31 <Botje> eugman|college: you could use fmap / map to map over containers
05:11:17 <Botje> use fold to flatten a tree and then map over it or somesuch
05:11:31 <Saizan_> > filterM (const [False ..]) [1..3]
05:11:35 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
05:12:15 <mauke> > transpose ["abc", "def"]
05:12:17 <lambdabot>  ["ad","be","cf"]
05:12:42 <mauke> > replicateM 3 "01"
05:12:43 <lambdabot>  ["000","001","010","011","100","101","110","111"]
05:13:37 * dolio should go look up dpiponi's Gray code monad.
05:14:04 <eugman|college> thanks
05:22:13 <sioraiocht> @src transpose
05:22:13 <lambdabot> transpose []             = []
05:22:13 <lambdabot> transpose ([]   : xss)   = transpose xss
05:22:13 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
05:22:45 <sioraiocht> that function hurts my head
05:24:35 <Botje> x : [h | (h:t) <- xss]) just takes the first column
05:24:47 <Botje> and (xs : [ t | (h:t) <- xss]) are the other columns
05:27:00 <andrew__1> whats a function like replicateM, but leaves out duplicates? e.g. repX 2 "12" == ["12", "21"]
05:27:40 <vixey> filter noDuplicates . replicateM ?
05:27:41 <Botje> nub . replicateM?
05:27:49 <mauke> permute
05:27:56 <andrew__1> mauke: thx
05:28:02 <mauke> which doesn't exist :-)
05:28:17 <vixey> noDuplicates x = length x == length (nub x)
05:28:30 <nornagon> aoeu
05:28:31 <andrew__1> Botje: woudlnt that calcuate all the replicateM, and be horribly inefficient?
05:28:41 <Botje> yes, yes it would.
05:28:49 <vixey> > let noDuplicates x = length x == length (nub x) in filter noDuplicates . replicateM $ 2 $ "12"
05:28:50 <lambdabot>  Couldn't match expected type `[[a]]'
05:28:53 <SamB_XP> andrew__1: okay, what is your actual desire?
05:28:56 <nornagon> er
05:28:58 <vixey> > let noDuplicates x = length x == length (nub x) in filter noDuplicates (replicateM 2 "12")
05:28:59 <lambdabot>  ["12","21"]
05:29:03 <vixey> > let noDuplicates x = length x == length (nub x) in filter noDuplicates (replicateM 3 "123")
05:29:04 <lambdabot>  ["123","132","213","231","312","321"]
05:29:04 <SamB_XP> you just want the permutations of a list?
05:29:48 <andrew__1> yeah
05:30:02 <andrew__1> oh no sorry
05:30:06 <SamB_XP> because, see, a question involving replicateM is probably not the best way to find the answer to that ;-)
05:30:29 <andrew__1> i want what vixey wrote but not calculating all of the replicateM
05:32:24 <SamB_XP> perhaps this will help? http://www.mail-archive.com/haskell-cafe@haskell.org/msg36877.html
05:32:26 <lambdabot> Title: Re: [Haskell-cafe] Re: Generic permutations, http://tinyurl.com/6dhv94
05:33:07 <vixey> > let permute [] = [[]] ; permute (x:xs) = inserts x `concatMap` permute xs in permute "xyzw"
05:33:08 <lambdabot>  ["xyzw","yxzw","yzxw","yzwx","xzyw","zxyw","zyxw","zywx","xzwy","zxwy","zwxy...
05:33:21 <vixey> > let permute [] = [[]] ; permute (x:xs) = inserts x `concatMap` permute xs in permute "p-q"
05:33:22 <lambdabot>  ["p-q","-pq","-qp","pq-","qp-","q-p"]
05:33:25 <andrew__1> SamB_XP: thanks
05:33:36 <matthew_-> does ghc try to identify when its typechecker is looping without progress?
05:33:54 <SamB_XP> matthew_-: not really
05:34:01 <vixey> it's impossible for the typechecker to loop unless you use some extensions
05:34:23 <SamB_XP> matthew_-: but it does give up after a certain number of steps "in"
05:34:38 <SamB_XP> (which is configurable)
05:34:49 <mauke> :t inserts
05:34:50 <lambdabot> forall t. t -> [t] -> [[t]]
05:34:58 <vixey> > let permute [] = [[]] ; permute (x:xs) = permute xs >> inserts x in permute "p-q"
05:34:59 <lambdabot>  Couldn't match expected type `[b]'
05:35:01 <vixey> > let permute [] = [[]] ; permute (x:xs) = permute xs >>= inserts x in permute "p-q"
05:35:03 <lambdabot>  ["p-q","-pq","-qp","pq-","qp-","q-p"]
05:35:03 <matthew_-> vixey: yeah, I use a lot of extensions ;)
05:35:14 <vixey> > let permute [] = return [] ; permute (x:xs) = permute xs >>= inserts x in permute "p-q"
05:35:15 <lambdabot>  ["p-q","-pq","-qp","pq-","qp-","q-p"]
05:35:19 <matthew_-> SamB_XP: yeah, is that seperate from the context stack?
05:35:31 <EvilTerran> ?index inserts
05:35:31 <matthew_-> or is that what you're talking about?
05:35:31 <lambdabot> bzzt
05:35:32 <vixey> @type let permute [] = return [] ; permute (x:xs) = permute xs >>= inserts x in permute
05:35:33 <lambdabot> forall a. [a] -> [[a]]
05:35:37 <vixey> aww
05:35:43 <vixey> I was hoping for some monad thing :P
05:35:57 <EvilTerran> vixey, i think the type of inserts prevents that
05:36:19 <vixey> inserts '?' "xyz" = ["?xyz","x?yz","xy?z","xyz?"]
05:36:23 <SamB_XP> matthew_-: I think it probably only counts the kinds of recursion that would be forbidden without the extensions that allow it to loop
05:37:06 <matthew_-> hmm
05:37:18 <EvilTerran> inserts x xs = [ys ++ [x] ++ zs | (ys,zs) <- zip (inits xs) (tails xs)] -- i imagine
05:37:43 <SamB_XP> matthew_-: because obviously, in any loop, those kinds of recursion must occur...
05:37:58 <matthew_-> so I have this test and with the MonomorphismRestriction it doesn't type check - error, bang etc. But this I'm used to - with the monomorphism restriction off it's taking a VERY long time to type check, even by my standards...
05:38:05 <vixey> > let inserts e [] = [[e]] ; inserts e (x:xs) = (e:x:xs) : map (x:) (inserts e xs) in inserts '?' "xyz"
05:38:07 <lambdabot>  ["?xyz","x?yz","xy?z","xyz?"]
05:38:07 <EvilTerran> | ys <- inits xs | zs <- tails xs], if you prefer the gratuitous extension
05:38:49 <SamB_XP> matthew_-: what other extensions are you using?
05:39:06 <EvilTerran> > let inserts x xs = [ys ++ [x] ++ zs | (ys,zs) <- zip (inits xs) (tails xs)] in inserts '?' "xyz"
05:39:07 <lambdabot>  ["?xyz","x?yz","xy?z","xyz?"]
05:39:12 <matthew_-> SamB_XP: at this point, it would be simpler to name ones I'm not using ;)
05:39:14 <SamB_XP> because the MR is not one of those that allow loops in the typesystem...
05:39:19 <matthew_-> oh I know
05:39:29 <SamB_XP> so, what CLASS extensions are you using?
05:39:30 <matthew_-> the other extensions are in the library
05:39:41 <johnnowak> sometimes i wish lambdabot were restricted to private chat
05:39:42 <matthew_-> oh, undecidable and overlapping in various places
05:39:45 <vixey> > (\xs -> zip (inits xs) (tails xs)) "foobar"
05:39:46 <lambdabot>  [("","foobar"),("f","oobar"),("fo","obar"),("foo","bar"),("foob","ar"),("foo...
05:39:49 <matthew_-> I don't have incoherent
05:39:50 <EvilTerran> lifting the MR instead of adding more explicit types will probably make the exponential typechecking cases more likely
05:40:17 <SamB> yes, probably
05:40:18 <vixey> > (\xs -> zip (inits xs) (tails xs) >>= \(p,q) -> p++'?':q) "xyz"
05:40:19 <lambdabot>  "?xyzx?yzxy?zxyz?"
05:40:25 <matthew_-> ahh, good point
05:40:34 <SamB> incoherent is not necessary for looping
05:40:39 <matthew_-> indeed not
05:40:49 <matthew_-> but IME, it tends to result in things going bang
05:40:57 <EvilTerran> johnnowak, we're collaborating here - it'd be annoying to have to work in pm and paste things back in when appropriate
05:40:58 <vixey> @pl (\e xs -> inits xs `zip` tails xs >>= \(p,q) -> [p++e:q])
05:40:59 <lambdabot> flip ((>>=) . liftM2 zip inits tails) . (`ap` snd) . (. fst) . flip flip [] . ((flip . ((:) .)) .) . flip ((.) . (++)) . (:)
05:41:09 <vixey> hehehe
05:41:13 <SamB> matthew_-: hence the name
05:41:14 <dolio> Undecidable instances allow looping.
05:41:16 <dolio> Of course.
05:41:20 <EvilTerran> i'm perfectly capable of working in pm if it's not for general consumption
05:41:37 <matthew_-> oh and MPTC and FunDeps and TypeFamilies and GADTs and ScopeTyVars and lots of other goodies
05:41:44 <SamB> dolio: oh, duh
05:41:49 <vixey> anyway I think EvilTerrans original inserts was the best..
05:41:49 <SamB> DUH DUH
05:42:06 <SamB> it's named for that very fact
05:42:21 * SamB feels silly not to remember that
05:42:39 <matthew_-> hmm. nearly up to 8 mins of type checking...
05:43:19 <matthew_-> but memory usage is not changing at all, which makes me think it's not making any progress
05:43:28 <dolio> It has to be a loop.
05:43:37 <EvilTerran> might be a ghc bug
05:43:45 <dolio> Not even a big HList program would take 8 minutes to type check. :)
05:43:50 <EvilTerran> the type families implementation is still a little dubious
05:44:07 <matthew_-> lol
05:44:08 <matthew_-> *** Exception: stack overflow
05:44:21 <matthew_-> dolio: this stuff is *much* worse than HList
05:44:30 <EvilTerran> ... from ghc? that's *gotta* be a bug
05:44:54 <MyCatVerbs> dolio: I thought Hindley-Milner was doubly-exponential in the worst case?
05:45:02 <matthew_-> EvilTerran: from GHC
05:45:38 <kfish> yay unbounded recursion
05:45:51 <dolio> Yeah. I can't say I've seen that aside from toy examples.
05:46:28 <dolio> Even HList probably isn't getting worst case behavior. It just does a lot more stuff than usual in the type system.
05:47:00 <matthew_-> the reason why I'd prefer no MR to extra type sigs is that the type sigs are about 100 lines long
05:47:12 <SamB> matthew_-: well, to work around it, use the +RTS option to increase the maximum stack size
05:47:30 <matthew_-> SamB: yeah, assuming it's making progress at all.
05:47:32 <SamB> 100 lines long
05:47:35 <SamB> ?
05:47:37 <matthew_-> which I've no idea about
05:47:38 <matthew_-> yeah
05:47:56 <matthew_-> well, the sig will be about 4 lines. The type class contexts will be the rest and will be huge
05:48:10 <SamB> well, I'm saying you should increase the low-level stack and see if it hits it's context stack limit or whatever
05:48:24 <SamB> ah, type class contexts
05:48:35 <SamB> why do you have such large contexts?
05:48:47 <matthew_-> because I'm monumentally abusing the type system?
05:49:10 <matthew_-> I have lists, sets, maps, numbers, arithmetic and a lot of other stuff going on in the type system
05:49:15 <dolio> For instance, 'f0 x = (x,x) ; f1 = f0 . f0 ; f2 = f1 . f1 ; f3 = f2 . f2 ; f4 = f3 . f3 ; f5 = f4 . f4'
05:49:28 <vixey> :t let f0 x = (x,x) ; f1 = f0 . f0 ; f2 = f1 . f1 ; f3 = f2 . f2 ; f4 = f3 . f3 ; f5 = f4 . f4' in f5
05:49:29 <lambdabot> Not in scope: `f4''
05:49:31 <dolio> f4 will take a few seconds to check, and f5 I don't feel like waiting for.
05:49:40 <vixey> :t let f0 x = (x,x) ; f1 = f0 . f0 ; f2 = f1 . f1 ; f3 = f2 . f2 ; f4 = f3 . f3 ; f5 = f4 . f4 in f5
05:49:47 <lambdabot> ghc-6.8.2: out of memory (requested 1048576 bytes)
05:49:49 <vixey> :t let f0 x = (x,x) ; f1 = f0 . f0 ; f2 = f1 . f1 ; f3 = f2 . f2 ; f4 = f3 . f3 ; f5 = f4 . f4 in f4
05:49:56 <lambdabot> ghc-6.8.2: out of memory (requested 1048576 bytes)
05:50:54 <vixey> oh
05:50:57 <vixey> :t let f0 x = (x,x) ; f1 = f0 . f0 ; f2 = f1 . f1 ; f3 = f2 . f2 ; f4 = f3 . f3 in f4
05:51:06 <lambdabot> forall t. t -> ((((((((((((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t,
05:51:06 <lambdabot>  t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))))), ((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t,
05:51:06 <lambdabot> t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t,
05:51:06 <lambdabot> t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))))), (((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t,
05:51:09 <lambdabot>  t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))))), ((((((t, t),
05:51:12 <lambdabot> [1644 @more lines]
05:51:16 <vixey> but is that O(2^n) to typecheck?
05:51:17 <ivanm> lambdabot spam! :o
05:51:29 <vixey> I don't think so.. just the size of the output
05:52:10 <dolio> I think | :type f4 | = | :type f3 |^2?
05:54:20 <dolio> @oeis 2 4 16
05:54:21 <lambdabot> Superperfect numbers: sigma(sigma(n)) = 2n where sigma is the sum-of-divisors...
05:54:21 <lambdabot> [2,4,16,64,4096,65536,262144,1073741824,1152921504606846976]
05:54:42 <dolio> @oeis 2 4 16 256
05:54:42 <lambdabot> 2^(2^n).
05:54:42 <lambdabot> [2,4,16,256,65536,4294967296,18446744073709551616,340282366920938463463374607...
05:55:37 <matthew_-> SamB: mmm, well using ghc rather than ghci does indeed tell me to try using +RTS to increase stack size
06:02:52 * edward1 waves hello.
06:03:11 <vixey> Hi
06:04:09 <edwardk> Does anyone have any code fragments that highlight comonads in a useful way? I'm debating about putting together a little 'cofib' suite of small comonadic applications so i can test my toy comonad transformer library
06:07:44 <ivanm> edwardk: you actually want something to be useful?!?!?! :o
06:08:13 <ivanm> my maths supervisor almost fainted when I asked him about how a proposed project could be useful... ;-)
06:10:17 <mm_freak_work> @pl \xs -> (length xs, head xs)
06:10:18 <lambdabot> liftM2 (,) length head
06:10:41 <EvilTerran> or (,) <$> length <*> head, or length &&& head
06:10:55 <EvilTerran> ?type (&&&)
06:10:56 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
06:11:03 <quicksilver> edwardk: I've seen no interesting 'useful' examples of comnads, personally.
06:11:18 <quicksilver> edwardk: except for the environment comonad which is really no more interesting than the reader monad.
06:11:22 <mm_freak_work> well, i'll just use the pointy version i guess =)
06:11:33 <mauke> :t join (***)
06:11:34 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
06:12:06 <mm_freak_work> the arrow version works, but i don't understand it, so i won't use it
06:12:53 <EvilTerran> it's pretty straightforward, if you just read "Arrow a => a" as (->)
06:13:02 <edwardk> quicksilver: fair nuff =P
06:13:08 <edwardk> ivanm: yes, i do =)
06:13:13 <quicksilver> edwardk: so, I'd be pleased to see some :)
06:13:20 <EvilTerran> ?pl (b -> c) -> (b -> c') -> b -> (c, c')
06:13:20 <lambdabot> (line 1, column 4):
06:13:20 <lambdabot> unexpected ">"
06:13:20 <lambdabot> expecting variable, "(", operator or ")"
06:13:25 <EvilTerran> ?djinn (b -> c) -> (b -> c') -> b -> (c, c')
06:13:26 <lambdabot> f a b c = (a c, b c)
06:13:31 <edwardk> quicksilver: i have a zipper comonad, i just need a generic way to take a derivative of a data structure
06:13:40 <EvilTerran> as there's only one sensible definition in that case
06:13:58 <mm_freak_work> i still won't use it, until i understand arrows =)
06:14:13 * EvilTerran doesn't understand arrows, but uses it :P
06:14:47 <edwardk> in it an actual w a -> a is basically a 'given a zipper at this position compute a value by looking around' style computation, then extend for the zipper comonad is 'ok, now that you can do that, walk to every position in the structure and call that apply that function.
06:14:52 <ivanm> what, edwardk expects things to be useful and mm_freak_work wants to understand stuff....
06:15:05 <ivanm> next people will be saying that they think haskell should work and be efficient ;-)
06:16:17 <Deewiant> mm_freak_work: just imagine that Control.Arrow is actually Data.Tuple and you'll be fine. ;-)
06:16:48 <Deewiant> (it's what I do)
06:17:30 <Saizan_> edwardk: but the "walk to every position" part is very zipper dependant right? or you've an interface to write it generically for every zipper?
06:18:29 <edwardk> saizan: i need a nice way to take a derivative, with that you can walk to every position easily by trial and error if nothing else ;)
06:19:24 <malcolmw> kolmodin: thx for the msg with a patch for HaXml/bytestring
06:19:26 <edwardk> at this point it may be that you give it a traversal function and a derivative manually
06:19:50 <malcolmw> kolmodin: the darcs version already contained that fix
06:20:57 <mm_freak_work> Deewiant: maybeâ€¦  i don't knowâ€¦  up to now i've never done anything with them
06:21:18 <mm_freak_work> i've read somewhere that you can even generalize monads to arrows
06:21:20 <Deewiant> I find them extremely convenient when working with tuples
06:21:30 <Deewiant> haven't used them with anything more esoteric than that
06:22:16 <Saizan_> edwardk: it's just that in general there are many directions where you can move, but i guess seeing types as sum and products gives more uniform view?
06:22:31 <Saizan_> "a"
06:22:33 <edwardk> saizan: exactly
06:23:17 <edwardk> saizan: so i'm thinking i'll have to slap together a template haskell derivative function or something to make it easier to use unless someone already has one
06:23:49 <quicksilver> generic zippers aren't very interesting, in some ways
06:23:56 <edwardk> i think i may have looped through this problem 6 months ago, but i have managed to forget whether i actually finished it =)
06:24:00 <quicksilver> for real code you often want useful names for the constructors
06:24:05 <edwardk> quicksilver: agreed
06:24:07 <quicksilver> but in principle it's not hard to do.
06:24:13 <quicksilver> (with TH or similar)
06:24:26 <quicksilver> uniplate might even manage actually
06:24:28 <quicksilver> I can't remember
06:24:33 <quicksilver> I think I thought it through once :)
06:24:38 <pavizard> hey, I need some help with a list, anyone could help?
06:24:39 <edwardk> quicksilver: i admit i kinda like using more 'names' for directions than the lisp-like sufficient-but-non-descriptive 'up down left right
06:25:08 <edwardk> i.e. i'm in an application i can go left or right, or at a lambda term i want to go into the body ot the type, etc.
06:25:22 <edwardk> then your directions work like better names
06:26:23 <Saizan_> pavizard: better to just ask :)
06:27:41 <edwardk> anyways the zipper comonad is just an obvious generalization of sigfpe's pointer comonad
06:29:03 <pavizard> popularTrack :: [Catalogue] -> [List]
06:29:03 <edwardk> its kinda neat in that you could use it with a double-sided infinite list for ANKOS-style 1-D cellular automata. your 'rule' is the function from w a -> a, and you just iterate the extension of that rule k times to see the kth iteration of the automata
06:29:04 <pavizard> popularTrack = map (\(Catalogue t a p l n g) -> List (n))
06:29:06 <pavizard> with the above I get the following result printed
06:29:08 <pavizard> track: [List {nu = 0},List {nu = 4},List {nu = 0}]
06:29:10 <pavizard> I have an iSort and ins function as follows
06:29:12 <pavizard> iSort  :: [Int] -> [Int]
06:29:13 <pavizard> iSort [] = []
06:29:15 <pavizard> iSort (x:xs) = ins x (iSort xs)
06:29:17 <pavizard> ins :: Int -> [Int] -> [Int]
06:29:18 <Saizan_> (i actually used the 2-dimensional list zipper comonad for CA when starting using haskell, but i could only get space leaks :\)
06:29:19 <pavizard> ins x [] = [x]
06:29:20 <pavizard> ins x (y:ys)
06:29:22 <pavizard> 	|x <= y  = x:(y:ys)
06:29:24 <pavizard> 	|otherwise = y : ins x ys
06:29:25 <pejo> Is there some often used function that discards a parameter?
06:29:26 <pavizard> My question is, how can I have the elemens n of the whole list sorted?
06:29:27 <pavizard> so I could get this as a result
06:29:28 <mauke> pavizard: stop pasting in the channel
06:29:29 <pavizard> track: [List {nu = 0},List {nu = 0},List {nu = 4}]
06:29:47 <bd_> pavizard: please use hpaste.org for long pastes
06:29:57 <Deewiant> pejo: const?
06:29:59 <pavizard> @mauk sorry
06:29:59 <lambdabot> Maybe you meant: ask map smack
06:30:00 <mauke> sort . popularTrack
06:31:35 <pavizard> @Saizan_ I have posted my question at http://hpaste.org/7255 thanks
06:31:36 <lambdabot> Unknown command, try @list
06:31:49 <edwardk> saizan: heh
06:33:40 <Saizan_> pavizard: if you want to use your iSort as it is you can do "map List . iSort . map nu . popularTrack"
06:34:38 <Saizan_> pavizard: but your ins and iSort can be generalized to every Ord a => a type, and you can derive Ord for List
06:34:55 <Saizan_> in that case you could just write iSort . popularTrack
06:38:34 <sclv_> edwardk: vis a vis useful comonads, this is probably already super-overtly obvious to you, but I thought that UniqueSupply was the cannonical example?
06:39:48 <pavizard> @Saizan like this ? popularTrack = map (\(Catalogue t a p l n g) ->  map List.iSort.map nu.popularTrack
06:39:49 <lambdabot> Unknown command, try @list
06:40:36 <Saizan_> no
06:40:51 <sclv_> pavizard: if you preface your msgs with a @, lambdabot tries to parse them as commands. plz. don't do that.
06:41:25 <pavizard> sclv_: oh thanks for that
06:41:38 <Saizan_> pavizard: popularTrack = map List . iSort . map (\(Catalogue t a p l n g) ->  n)
06:44:15 <pavizard> :Saizan_ Thank you! it works,
06:47:53 <edwardk> sclv: do you have a unique supply comonad handy?
06:49:12 <edwardk> sclv: i can see the reader comonad, but a an action in the reader comonad returns a value, there is no way to indicate that it consumed something from the supply unless i'm being dense
06:52:24 <edwardk> i'm actually quite serious a unique supply comonad would make my life easier in a lot of ways coz i wanted one for another toy ;)
06:55:16 <tac-tics> People and their crazy comonads
06:55:58 <edwardk> tactics i'm starting to get quite the collection of them going
06:56:05 <tac-tics> What are comonads useful for besides confusing people like me?
06:56:27 <sclv_> edwardk: http://hackage.haskell.org/packages/archive/value-supply/0.1/doc/html/Data-Supply.html
06:56:29 <lambdabot> http://tinyurl.com/2br6aj
06:56:41 <edwardk> tactics: comonads are useful for a bunch of stuff that is very different from what monads are useful for
06:57:40 * sclv_ idly wonders if random could be a comonad too.
06:57:50 <kfish> programming is all about taming the infinite, comonads let you classify it
06:58:35 <tac-tics> Yes, but what can I use one for?
06:58:53 <tac-tics> Where's my spacesuit analogy for comonads?
06:59:07 <dolio> You mean you want a bad analogy?
06:59:19 <tac-tics> yes
06:59:24 <tac-tics> or any
06:59:26 <tac-tics> =-P
06:59:29 <edwardk> sclv: ah. so (Supply a -> b) >-> (Supply b -> c) is a supply action that takes a supply, splits it and feeds it to each action?
06:59:37 <edwardk> now it makes sense to me
06:59:48 <edwardk> tactics: think of comonads as parts of the space suit ;)
07:00:06 <tac-tics> where does the toxic waste fit in, then?
07:00:25 <sclv_> edwardk: yep. once the smare folks write the paper and produce the code, it looks pretty obvious in retrospect :-)
07:00:26 <edwardk> tactics: you can take a comonad that describes how much each of the pieces of your space suit cost, then you can forget all the details and just look at the total
07:01:11 <tac-tics> like foldr?
07:01:52 <edwardk> tactics: monads 'as containers' lets you think of an operation that takes a part and builds a new container right? then you can smash together containers of containers?
07:02:11 <tac-tics> yeah
07:02:34 <edwardk> comonads work differently think of a comonad as an operation that can take a whole container and generate a single item, and then has rules for recycling the old container by placing it around that item.
07:03:16 <edwardk> extract :: w a -> a 'deconstructs' w in some sense so every comonadic action 'discards the wrapper'
07:04:17 <tac-tics> and expand(?) :: w a -> w (w a) fattens it up, right?
07:04:19 <edwardk> 'extend' (the dual of >>=) recycles the old wrapper. so if you have a function f :: (w a -> b)      then extend f :: w a -> w b turns it into an action that 'keeps the wrapper around'
07:04:48 <edwardk> tactics: yeah 'cojoin' or 'duplicate' depending on who you talk to =)
07:05:27 <tac-tics> Ah, the role of comonads as the dual of monads is becoming clear. Monads are about nuclear waste, while comonads are about recycling.
07:05:51 <pitseleh> hello, i'm a haskell beginner and i'm a little confused
07:05:59 <mib_igrwqtf7> hi all, I nee some help for defining mutual recursive data types
07:06:00 <tac-tics> welcome to #haskell!
07:06:09 <edwardk> tactics: so lets take an example, the reader comonad. in the reader monad you have an (e -> a). in the reader comonad you just have an (e,a) you can always toss the environment. you can always duplicate it by generating (e,(e,a))
07:06:11 <pitseleh> :) thanks tac-tics
07:06:12 <matthew_-> pitseleh: I'm not a beginner and I'm still confused ;)
07:06:23 <bugQ> pitseleh: I'm intermediate in my haskell knowledge and still confused. :)
07:06:26 <tac-tics> matthew_-: hah, yeah.....
07:06:26 <Deewiant> haskell will do that to ya
07:06:33 <pitseleh> matthew_-, bugQ, that helps to know
07:06:44 <edwardk> heh i'm still a comparative newbie around here myself ;)
07:06:45 <bugQ> ah, ninja'd.
07:07:01 <tac-tics> so reader can be implemented in either?
07:07:45 <pitseleh> darn java freenode
07:08:00 <wjt> why would you want a reader comonad, though?
07:08:03 <edwardk> tactics: basically. 'reader' works a little differently for a comonad. because 'ask : m e' but ''coask :: w a -> e" reflects the different designs
07:08:16 <mib_igrwqtf7> I writed a function: xmlScenario2Scenario (XmlScenario description steps) = Scenario description [xmlStep2Step x | x<-steps]
07:08:25 <pitseleh> urmm, i've created two data types, Shape and Point, and combined them in data PositionedShape = Shape Point
07:08:38 <edwardk> which for w a = (e,a)  is just 'fst' =)
07:08:38 <mauke> pitseleh: no, you didn't
07:08:53 <mauke> pitseleh: you created a type PositionedShape that contains a Point
07:09:03 <mib_igrwqtf7> but I need to pass the "scenario" for xmlStep2Step
07:09:06 <nominolo> any phd student from kent hanging out here?
07:09:06 <mauke> pitseleh: "Shape" is the name of PositionedShape's data constructor there
07:09:09 <pitseleh> mauke, yes, correct distinction, my bad
07:09:40 <edwardk> tactics: the 'state' comonad works a bit differently. the state monad is basically a black box into which you drop a state and you get an action. a 'context' comonad knows its state and the function to apply to it a priori
07:09:41 <pitseleh> mauke, ah i understand
07:09:41 <mauke> mib_igrwqtf7: let sc = Scenario description [xmlStep2Step sc x | x<-steps] in sc
07:09:49 <pitseleh> mauke, thank you :)
07:10:13 <edwardk> so you can run a 'context' comonad at any time to get out its answer. but since it still carries around the state with it you can ask it to run with a modified state and get another answer at any point
07:10:16 <mauke> yay!
07:10:19 <mib_igrwqtf7> mauke ok....  thanks a lot
07:10:30 <pejo> nominolo, Beelsebob?
07:10:43 <mauke> > let xs = 42 : xs in xs
07:10:44 <lambdabot>  [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,...
07:10:58 <tac-tics> I think I'm going to hold out for the tutorial
07:10:58 <nominolo> pejo: who's behind that nick?
07:11:06 <nominolo> do you know?
07:11:15 <mauke> > let xs = 1 : map (* 2) xs in xs
07:11:16 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
07:11:24 <pejo> nominolo, Thomas Davie I think. Whois him when he's around. :-)
07:11:43 <edwardk> so f i have a context comonad foo :: Context Int [Float], foo carries around an Int, and a function Int -> [Float], and can always just apply the two pieces to give you back a [Float], otoh, i can take that comonad and run it with different Ints
07:11:52 <tac-tics> or at least, I can't fool around with learning new category theory, because I'm at work
07:12:05 <edwardk> tactics: fair nuff
07:12:06 <bugQ> > [sum [1..n] | n <- [1..]]
07:12:07 <lambdabot>  [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276...
07:12:13 <saml> Parsec's parse returns Either ParseError a .  is this a good practice? or should I just return a and let users catchError ?
07:12:50 <edwardk> sclv: i think i'll roll the supply comonad into the library
07:12:51 <mauke> > [ n * succ n `div` 2 | n <- [1 ..] ]
07:12:53 <lambdabot>  [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276...
07:13:01 <nominolo> pejo: ok, thanks
07:13:30 <mauke> :t ((`div` 2) . ap (*) succ)
07:13:31 <lambdabot> forall a. (Integral a) => a -> a
07:15:27 <edwardk> now i need a Supply comonad transformer =)
07:15:58 <mib_igrwqtf7> mauke let sc = ... in sc resulted in a loop
07:16:40 <mauke> > let x = x + 1 in x
07:16:55 <lambdabot>  thread killed
07:16:56 <mauke> obviously that doesn't work for all operations
07:16:58 <quicksilver> saml: you can catchError from Either ParseError a
07:17:04 <quicksilver> :t catchError
07:17:05 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
07:17:17 <bugQ> ?src iterate
07:17:17 <lambdabot> iterate f x =  x : iterate f (f x)
07:17:22 <quicksilver> saml: catchError works for all error monads, Either ParseError is an error monad.
07:17:29 <bugQ> is there an iterate with state?
07:17:46 <mauke> :t unfoldr
07:17:47 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
07:17:52 <quicksilver> bugQ: iteratae over a tuple?
07:18:11 <saml> oh instance (E.Error e) => E.MonadError e (Either e)
07:18:20 <bugQ> unfoldr is it, thanks.
07:18:28 <quicksilver> > iterate (\(s,v) -> (s+v,v+1)) (0,0)
07:18:29 <lambdabot>  [(0,0),(0,1),(1,2),(3,3),(6,4),(10,5),(15,6),(21,7),(28,8),(36,9),(45,10),(5...
07:18:31 <bugQ> I don't want a list of tuples.
07:18:33 <tromp> > 75*150
07:18:35 <lambdabot>  11250
07:18:43 <mauke> see also: scanl, mapAccumL
07:18:46 <quicksilver> bugQ: well it's not very hard to map snd afterwards, is it? :P
07:18:53 <saml> so i think Either is the best way to represent error condition
07:18:54 <quicksilver> or map fst.
07:19:06 <quicksilver> saml: I think it is a good way in many cases, yes.
07:19:12 <mib_igrwqtf7> is there any kind of idiom (or pattern) for instantiating mutual recursive data types?
07:19:28 <saml> thanks quicksilver
07:19:44 <sclv_> endwardk: glad I could point you to something useful :-)
07:19:58 <mauke> saml/samrâ€½
07:20:14 <saml> no i'm not SamB
07:20:35 <saml> oh i see what you did.
07:20:43 <bugQ> :)
07:20:52 <mauke>  flickl
07:21:54 <bugQ> what would a flick function do, anyway?
07:26:53 <quicksilver> mib_igrwqtf7: it's not normally a problem. What in particular?
07:27:32 <byorgey> tying the knot?
07:27:45 <byorgey> > let x = Just y ; y = Just x  in x
07:27:45 <lambdabot>      Occurs check: cannot construct the infinite type:
07:27:45 <lambdabot>       a = Maybe (Maybe...
07:28:11 <byorgey> er, I mean
07:28:19 <byorgey> > let x = 1 : y ; y = 0 : x in x
07:28:20 <lambdabot>  [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0...
07:28:46 <mib_igrwqtf7> quicksilver I've this function:  xmlScenario2Scenario XmlScenario description steps = Scenario description [xmlStep2Step x | x <- step]
07:29:23 <mib_igrwqtf7> quicksilver howver, I want to expose Scenario for xmlStep2Step function
07:29:59 <byorgey> mib_igrwqtf7: just give the Scenario value a name with a where or let.
07:30:28 <byorgey> xmlScenario2Scenario .... = result  where result = Scenario description [xmlStep2Step x result | x <- steps]   -- something like this?  is that what you want?
07:34:51 <mib_igrwqtf7> byorgey yah, is something like this that I want. however, IÂ´m getting in a loop
07:35:12 <quicksilver> it is often not a good idea to tie loops in data structures :)
07:35:21 <quicksilver> although it can be very clever in certain circs, definitely.
07:35:44 <byorgey> mib_igrwqtf7: well, I guess I'm not terribly surprised =)
07:36:29 <quicksilver> mib_igrwqtf7: why do you want the structure to contain references to itself?
07:36:32 <byorgey> but if you're getting in a loop that means that you have a circular data dependency
07:36:37 <quicksilver> mib_igrwqtf7: and how do you expect it not to loop?/
07:36:45 <quicksilver> it is, of course, quite possible to set these things up not to loop
07:36:52 <quicksilver> but there must be a reason you think it won't
07:37:20 <byorgey> Haskell won't magically resolve circular data dependencies for you =)
07:37:59 <mib_igrwqtf7> so.... what you mean is that mutual recursive data types should be avoided in haskell?
07:40:20 <quicksilver> mib_igrwqtf7: absolutely not.
07:40:33 <quicksilver> mib_igrwqtf7: I certainly don't mean that.
07:40:43 <quicksilver> What you're doing is not a mutually recursive type, anyway.
07:40:48 <mib_igrwqtf7> quicksilver I agree with you
07:40:49 <quicksilver> it's recursive data.
07:41:06 <quicksilver> the issues are no more or less true in haskell than any other language
07:41:11 <quicksilver> recursion can lead to loops
07:41:12 <quicksilver> :)
07:41:14 <mib_igrwqtf7> quicksilver data type, I mean
07:41:17 <quicksilver> you need to think about your recursion.
07:41:26 <quicksilver> mib_igrwqtf7: no, not type. data.
07:41:33 <quicksilver> this isn't an example of a recursive type.
07:41:38 <quicksilver> it's an example of recursive data.
07:41:51 <quicksilver> data List a = Nil | Cons a (List a)
07:41:57 <quicksilver> ^^ that's a recursive data *type*
07:42:05 <quicksilver> let x = 1+x
07:42:11 <quicksilver> ^^ that's recursive data
07:42:18 <quicksilver> > let x = 1+x in x
07:42:23 <mib_igrwqtf7> quicksilver actually, I hava a scenario data type defined as Scenario ... [Step] and a Step data type defined as Step ... Scenario ....
07:42:33 <lambdabot>  thread killed
07:42:35 <quicksilver> OK. Then that is mutually recursive data.
07:42:38 <quicksilver> erm
07:42:41 <quicksilver> OK. Then that is mutually recursive data type..
07:42:44 <quicksilver> you are quite right.
07:42:59 <quicksilver> but that doesn't mean that the Scenario inside the Step is the same as the Scenario outside the step.
07:43:05 <quicksilver> normally the scenario inside would be different.
07:43:11 <quicksilver> and then there would be no data-recursion.
07:43:16 <quicksilver> [1,2,3,4,5]
07:43:27 <quicksilver> ^^ that's a recursive type (list) but totally non-recursive data.
07:44:41 <qwr> > let l = 1:l in l
07:44:43 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
07:45:07 <quicksilver> now that *is* data recursion.
07:45:14 <quicksilver> but it's an example of one which happens to work out ok.
07:45:25 <quicksilver> would probably be better to call it value recursion, for clarity.
07:45:31 <Deewiant> > fix (((0:).)<$>((1:).)<$>zipWith(+)<*>tail)
07:45:32 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
07:45:37 <mib_igrwqtf7> quicksilver ok
07:48:16 <byorgey> and Deewiant has posted an example of value recursion which you should completely ignore for now. =)
07:49:05 <Deewiant> > fix ((0:) . scanl (+) 1)
07:49:09 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
07:57:42 <edwardk> So far I have Supply, Reader(T)/((,)e), Context(T), Cofree, Identity, SIGFPE's Pointer, a half-started Zipper, and some laws for building comonads from a comonad and a copointed endofunctor with a distributive law. Any others leap to mind?
07:58:16 <edwardk> Cofree is also known as the Branching Stream comonad
07:59:05 <edwardk> I might put in a simple Stream comonad for the same reason that people use Reader rather than ReaderT Identity
08:01:15 <MathHat> Coffee is also known as the Rejuvinating Stream
08:01:15 <edwardk> I think a product of cofree comonads (like the coproduct of free monads) also makes sense.
08:01:34 <edwardk> math: =)
08:05:52 <Saizan_> the parallel to Writer is Supply?
08:06:18 <edwardk> i've seen a few would-be writer comonads but i didn't see one that convinced me
08:07:19 <edwardk> they are all written like they are working with a monad
08:08:18 <quicksilver> assuming "mib_igrwqtf7" is "rodrigo.bonifacio"
08:08:31 <quicksilver> then it looks like he's trying to copy the OO style of having a 'Parent' reference in a tree
08:08:32 <ahunte1> @src thenM
08:08:32 <lambdabot> Source not found. That's something I cannot allow to happen.
08:08:43 <quicksilver> this is neither necessary nor a good idea in FP, I think.
08:12:38 <edwardk> mnislaih: did you ever do anything else with that parameterized effect monad stuff?
08:14:04 <sclv_> what's the difference between context and reader?
08:15:00 <sclv_> ah, nevermind, just looked it up.
08:18:14 <edwardk> http://comonad.com/haskell/ctl/dist/doc/html/ctl/Control-Comonad-Reader.html vs. http://comonad.com/haskell/ctl/dist/doc/html/ctl/Control-Comonad-Context.html =)
08:18:23 <lambdabot> http://tinyurl.com/5wd9ps
08:25:56 <saml> exclude :: (Eq k) => [(k, a)] -> [k] -> [(k,a)]   is there such function?
08:26:18 <quicksilver> no
08:26:34 <mnislaih> hi edwardk
08:26:45 <edwardk> heya, long time no talk =)
08:26:49 <mnislaih> I managed to get spj to fix the issue with do notation :)
08:26:54 <edwardk> nice!
08:27:11 <quicksilver> :t \m kk -> filter (not.(`elem` kk).fst) m
08:27:11 <mnislaih> and I changed my exceptions monad to put the exceptions in the constraint side of the signature, after some suggestions of you
08:27:12 <lambdabot> forall a b. (Eq a) => [(a, b)] -> [a] -> [(a, b)]
08:27:14 <edwardk> i might actually dust of my security monads then
08:27:20 <quicksilver> saml: but it's not hard to write ^^
08:27:24 <EvilTerran> ... what issue?
08:27:55 <mnislaih> otherwise, if-then-else and case statements would not type, if the alternatives were throwing different exception sets, which is common
08:28:12 <sclv_> edwardk: I suppose you could conceptually do a writer comonad to a set, no? not sure what the use/implementation would be...
08:28:32 <mnislaih> the exceptions framework ended up being pretty sweet, and I might revive my blog for it
08:29:03 <saml> quicksilver, oh fst!! i was converting it to Map and Map.keys ...etc
08:29:46 <edwardk> sclv: i think it comes out as a sort of conditional logging thing? like you build up the path to the computation you are in and can interact with that. not sure it makes sense
08:30:30 <edwardk> my usual answer is to just run all the arrows backwards and see what i get ;)
08:31:07 <edwardk> in writers' case i'm not currently able to make sense of the result
08:32:12 <quicksilver> @type \m kk -> Data.Map.toList $ foldr Data.Map.delete (Data.Map.fromList m) kk
08:32:14 <lambdabot> forall a a1. (Ord a) => [(a, a1)] -> [a] -> [(a, a1)]
08:32:19 <quicksilver> saml: there is the Data.Map version
08:32:37 <quicksilver> saml: better complexity, of course, if kk is long.
08:32:45 <quicksilver> saml: but the list version is fine for simple cases.
08:33:05 <Deewiant> and that one needs Ord, not Eq.
08:33:26 <quicksilver> indeed.
08:33:36 <quicksilver> not sure how critical that was for saml.
08:33:52 <quicksilver> In practice, any type which supports sensible Eq should support sensible Ord.
08:34:01 <edwardk> i've wound up with a few cases, in general i get some sort of Either involved. and data Foo e a = Foo (e -> a) (Either a e) doesn't appear to add any value over Context at first glance
08:34:19 <Deewiant> of course it's possible that you have senseless Eq which means there's no way of getting Ord ;-)
08:34:33 <edwardk> oh wait
08:34:38 <edwardk> i think supply IS the cowriter
08:34:41 <edwardk> duh
08:35:05 <edwardk> you have something you can split, m -> m * m  as opposed to m * m -> m
08:35:11 <quicksilver> Deewiant: perhaps, yes :)
08:35:14 <saml> for complexity wise, filtering association list would be better than converting it to Map and forth?
08:35:23 <EvilTerran> ... maybe
08:35:26 <Deewiant> I've been using such a type internally just so that I don't have to use fooBy closeEnoughToEquality inplace of just foo with an Eq instance
08:35:37 <quicksilver> saml: well, it's a complex story
08:35:46 <quicksilver> saml: if m is long and kk is short, the list version is better
08:36:05 <quicksilver> saml: because it's linear in m, I think
08:36:48 <quicksilver> I think the list one is O(m * kk) and the map one is O(m log m + kk log m)
08:37:06 <quicksilver> I didn't think very much about it.
08:37:16 <saml> oh list one is still multiple.. I forgot about elem part.
08:39:44 <quicksilver> saml: there is a third solution where you put the kk in a set but leave m as a list
08:39:55 <quicksilver> saml: which is probably the fasted, being only m log kk
08:39:57 <quicksilver> saml: I think
08:40:15 <quicksilver> saml: in practice use the list version unless you identify a speed problem.
08:40:51 <saml> yup. i'll just use list version. simple and clean.
08:48:31 <DuClare>      â”œâ”€urxvtâ”€â”€â”€bashâ”€â”€â”€ghc-6.8.2â”€â”€â”€243*[{ghc-6.8.2}]
08:48:33 <DuClare>      â”œâ”€urxvtâ”€â”€â”€bashâ”€â”€â”€ghc-6.8.2â”€â”€â”€118*[{ghc-6.8.2}]
08:49:06 <sclv_> hmmm... so say you have a supply of Refs -- then you can get genuine writer-like functionality...
09:01:29 <matthew_-> is there any way of getting ghc to tell you what it's trying to do when type checking?
09:01:46 * matthew_- hopes desperately the answer doesn't involve gdb
09:02:08 <matthew_-> like getting it to list out the contexts it is trying to satisfy?
09:04:01 <mnislaih> q
09:04:08 <mnislaih> oops
09:04:31 <Philippa> matthew_-: not that I'm aware of, I've mentioned similar ideas in the past
09:04:51 <matthew_-> I almost do want an interactive step mode for the type checker phases
09:05:12 <dons> there's a lot of debugging flags
09:05:17 <dons> i've not lookked at the type checker ones
09:06:00 <zeno> @hoogle Int -> [a] -> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a
09:06:01 <lambdabot> Hoogle Error: Parse Error: Unexpected character '://en.wiki'
09:06:03 <matthew_-> no -D seems to mention type checker ...
09:06:13 <dons> matthew_-: best ask SPJ then
09:06:17 <zeno> huh i put in http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a not wikipidia link
09:06:35 <zeno> ok wth my client is expanding [ [ a ] ]
09:07:34 <sclv_> @hoogle Int -> a -> [a]
09:07:35 <lambdabot> Prelude.replicate :: Int -> a -> [a]
09:07:35 <lambdabot> Data.List.replicate :: Int -> a -> [a]
09:08:00 <saml> > replicate 5 [1,2,3]
09:08:02 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3]]
09:08:28 <zeno> whats the function that does x 3 "12" == ["111", "112", ...
09:08:47 <vixey> @let x = replicateM
09:08:48 <lambdabot> <local>:9:4:     Ambiguous type variable `m' in the constraint:       `Monad ...
09:08:51 <vixey> boo
09:08:59 <vixey> > let x = replicateM in x 3 "12"
09:09:00 <lambdabot>  ["111","112","121","122","211","212","221","222"]
09:09:02 <saml> > combination 3 "12
09:09:02 <lambdabot>  Improperly terminated string at ""12" (column 15)
09:09:06 <zeno> thanks
09:09:24 <vixey> > sequence (repeat
09:09:25 <lambdabot> Unbalanced parentheses
09:09:29 <vixey> > sequence (replicate 3 "12")
09:09:31 <lambdabot>  ["111","112","121","122","211","212","221","222"]
09:09:34 <zeno> @src replicateM
09:09:34 <lambdabot> replicateM n x = sequence (replicate n x)
09:09:42 <vixey> :o
09:09:46 <zeno> @src sequence
09:09:47 <lambdabot> sequence []     = return []
09:09:47 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
09:09:47 <lambdabot> --OR
09:09:47 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
09:10:38 <zeno> vixey: shouldnt sequence l just return l then?
09:10:45 <matthew_-> hmm, -ddump-tc /might/ work I suppose
09:10:53 <vixey> > sequence "xyz"
09:10:54 <lambdabot>  Couldn't match expected type `m a' against inferred type `Char'
09:10:58 <vixey> > sequence ["xyz"]
09:10:59 <lambdabot>  ["x","y","z"]
09:11:09 <vixey> > sequence ["xyz", "p-q"]
09:11:10 <lambdabot>  ["xp","x-","xq","yp","y-","yq","zp","z-","zq"]
09:11:24 <zeno> vixey: why does it do that?
09:11:37 <matthew_-> gah, nope, it won't dump until tc is finished.
09:11:58 * matthew_- spies other interesting -dump flags
09:12:42 <MathHat> the v <- x line on that definition for sequence will put each item in the list x into v once.
09:13:17 <vixey> zeno: I see it like this: sequence [list1, list2, list3, ...] makes every possible new list [e1,e2,e3,...] where e1 in chosen from list1, e2 chosen from list2, ...
09:13:50 <vixey> > sequence [[1],[2],[3]] -- will give [1,2,3]
09:13:52 <lambdabot>  [[1,2,3]]
09:14:12 <vixey> > sequence [[1],[2,22],[3,33,333]]
09:14:13 <lambdabot>  [[1,2,3],[1,2,33],[1,2,333],[1,22,3],[1,22,33],[1,22,333]]
09:14:28 <zeno> ok thx
09:14:36 <zeno> i wsa just trying to figure out why from its source
09:14:45 <MathHat> > sequence ["a","b","c"]
09:14:46 <lambdabot>  ["abc"]
09:14:49 <vixey> you know what <- means in the list monad?
09:14:50 <MathHat> > sequence $ sequence ["a","b","c"]
09:14:53 <lambdabot>  ["a","b","c"]
09:14:58 <zeno> vixey: nope
09:15:15 <vixey> list monad is like
09:15:21 <MathHat> > sequence $ sequence ["ab","c"]
09:15:22 <vixey> (>>=) = flip concatMap
09:15:22 <lambdabot>  ["ab","ac","cb","cc"]
09:15:23 <vixey> return = (:[])
09:15:39 <vixey> so I think of <- in do notation as selecting an element out of the list
09:15:52 <vixey> this is actually done for every element in turn though and you get a list of all the solutions
09:15:54 <quicksilver> matthew_-: GHC has only just gained support for value-level debugging
09:16:04 <quicksilver> matthew_-: and already you're asking for type-level debugging
09:16:06 <quicksilver> MathHat: ;)
09:16:08 <quicksilver> matthew_-: ;)
09:16:19 <vixey> > do x <- "xy" ; y <- "p-q" ; return [x,y]
09:16:20 <lambdabot>  ["xp","x-","xq","yp","y-","yq"]
09:16:24 <matthew_-> quicksilver: I enjoy driving development ;)
09:16:38 <matthew_-> aka being a royal pita
09:16:57 <vixey> zeno: so sequence [list1, list2, list3] = do e1 <- list1 ; e2 <- list2 ; e3 <- list3 ; return [e1,e2,e3]
09:17:11 * matthew_- fears the multi GB tc trace log being generated
09:17:16 <vixey> zeno: but of course it works for more than 3 lists, so it's written recursively
09:17:24 <vixey> that's that bit  <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
09:17:32 <vixey> the terminal case makes sense too?
09:18:17 <MathHat> what still confuses me is mzero, though.
09:18:30 <vixey> :t mzero
09:18:32 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
09:18:38 <zeno> vixey: ah ok thx
09:18:51 <zeno> didnt even know lists were a monad :)
09:18:55 <vixey> zeno: ever used Prolog?
09:20:03 <byorgey> oh, interesting, sequence . sequence === id for lists-of-lists
09:20:09 <byorgey> hmm, is that true for any monad-of-monads?
09:20:24 <byorgey> I suspect not
09:20:33 <MathHat> > sequence $ sequence ["ab","c"]
09:20:34 <lambdabot>  ["ab","ac","cb","cc"]
09:20:43 <zeno> vixey: nope just python/java
09:20:48 <vixey> > (sequence . sequence) (Just Nothing)
09:20:48 <lambdabot>  Couldn't match expected type `[[a]]'
09:20:48 <byorgey> oh, it isn't the identity, never mind =)
09:21:10 <MathHat> sequence takes a list of monads
09:21:15 <byorgey> er, and sequence only works on a list of monads...
09:21:20 <byorgey> right, I has the dumb today =P
09:21:23 <vixey> > (sequence . sequence) [Nothing]
09:21:24 <lambdabot>  Couldn't match expected type `[]' against inferred type `Maybe'
09:21:27 <vixey> :(
09:21:28 <vixey> me too
09:21:34 <zeno> sequence $ sequence ["ab","cd"]
09:21:41 <zeno> > sequence $ sequence ["ab","cd"]
09:21:43 <lambdabot>  ["aabb","aabd","aacb","aacd","adbb","adbd","adcb","adcd","cabb","cabd","cacb...
09:21:53 <MathHat> yeah, it gets complicated fast.
09:22:27 <Saizan_> byorgey: in which case you get id?
09:22:41 <zeno> sequence [0..] [0..]
09:22:43 <byorgey> > sequence $ sequence ["a","b","c"]
09:22:44 <lambdabot>  ["a","b","c"]
09:22:46 <zeno> > sequence [0..] [0..]
09:22:47 <lambdabot>        add an instance declaration for (Enum ([t] -> a), Num ([t] -> a))
09:23:07 <MathHat> > sequence [[0..],[0..]]
09:23:08 <lambdabot>  [[0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[0,6],[0,7],[0,8],[0,9],[0,10],[0,11],[...
09:23:18 <Saizan_> > sequence ["a","b","c"]
09:23:20 <lambdabot>  ["abc"]
09:23:36 <byorgey> Saizan_: so you get id if you have a list of one list, or a list of singleton lists
09:24:05 <zeno> sequence id
09:24:12 <vixey> :t sequence
09:24:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
09:24:23 <vixey> > sequence [Just 1, Just 2, Just 3]
09:24:24 <lambdabot>  Just [1,2,3]
09:24:30 <vixey> > sequence [Just 1, Nothing, Just 3]
09:24:30 <lambdabot>  Nothing
09:24:42 <zeno> sequence [IO "hi"]
09:24:59 <zeno> > sequence [IO "hi"]--gah keep forgetting > :(
09:25:02 <lambdabot>   Not in scope: data constructor `IO'
09:25:14 <zeno> > sequence [print "hi"]--gah keep forgetting > :(
09:25:15 <lambdabot>  <IO [()]>
09:25:26 <vixey> sequence [turnOn Tap, fill Kettle, turnOff Tap, boil Kettle, ...] :P
09:26:10 * vixey goes to make a cup of tea..
09:26:18 <MathHat> > sequence (map Just [1..]) : [Nothing]
09:26:21 <lambdabot>  [Exception: stack overflow
09:26:23 <MathHat> ha.
09:26:48 <sclv_> > nub . fmap nub . sequence $ sequence ["ab","cd"]
09:26:49 <lambdabot>  ["ab","abd","acb","acd","adb","adcb","adc","cab","cabd","cad","cdb","cd"]
09:27:54 <sclv_> now as to what that is...?
09:28:02 <sclv_> > length . nub . fmap nub . sequence $ sequence ["ab","cd"]
09:28:03 <lambdabot>  12
09:28:10 <sclv_> > length . nub . fmap nub . sequence $ sequence ["ab","cd", "ef"]
09:28:11 <MathHat> yeah, it's sure interesting.
09:28:11 <lambdabot>  452
09:28:17 <sclv_> > length . nub . fmap nub . sequence $ sequence ["abc","def"]
09:28:18 <lambdabot>  108
09:28:22 <zeno> let g (x:y) = (x y) in g [1,2]
09:28:40 <zeno> that error for some reason :\
09:28:44 <sclv_> > length . nub . fmap nub . sequence $ sequence ["ab"]
09:28:45 <lambdabot>  1
09:28:51 <byorgey> oh, that's a generalized Eulerian wreath sub-coproduct, of course
09:28:53 <sclv_> @oeis 1 12 452
09:28:54 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
09:28:57 <MathHat> > let g (x:y) = (x y) in g [1,2]
09:28:57 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t] -> t1
09:28:57 <lambdabot>     Prob...
09:29:01 <MathHat> > let g (x:y) = (x,y) in g [1,2]
09:29:02 <lambdabot>  (1,[2])
09:29:06 <sclv_> @oeis [1, 12, 452]
09:29:07 <lambdabot> Sequence not found. You speak an infinite deal of nothing
09:29:12 <sclv_> @oeis 1, 12, 452
09:29:13 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
09:29:20 <sclv_> @oeis [2,4,6]
09:29:21 <lambdabot> Sequence not found. It can only be attributed to human error.
09:29:25 <sclv_> @oeis [2, 4, 6]
09:29:25 <lambdabot> Sequence not found.
09:29:35 <sclv_> how do i make teh oeis!
09:29:40 <byorgey> @oeis 1 2 3
09:29:41 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
09:29:41 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
09:29:47 <byorgey> @oeis 1 12 452
09:29:48 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
09:29:51 <sclv_> meh.
09:29:57 <byorgey> that means there's no result.  I still don't know why it gives that error.
09:30:07 <sclv_> > length . nub . fmap nub . sequence $ sequence ["ab","cd", "ef", "gh"]
09:30:14 <lambdabot>  Exception: Time limit exceeded
09:30:23 <zeno> @src oeis
09:30:24 <lambdabot> Source not found. It can only be attributed to human error.
09:30:25 <pavizard> :Saizan I would like to ask you , regarding my previous question, http://hpaste.org/7255 how could I have the list sorted by n, but at the results including all the rest of the elements of the list? thanks!
09:30:37 <sclv_> wow -- it must grow fast.
09:30:54 <byorgey> I'm running it now
09:31:09 <byorgey> still running
09:31:40 <MyCatVerbs> Hrmn. Is there some standard way of subtyping integers, please? Preferrably something less verbose than data Foo = Foo Integer deriving (Show,Ord,Eq), instance Num Foo where... ?
09:31:49 <byorgey> still running, using 10% of my 2GB...
09:32:17 <sclv_> haha this is up there with okasaki's spectacular failure sequence.
09:32:26 <byorgey> sclv_: what's that?
09:32:37 <MathHat> MyCatVerbs: can't think of any...
09:32:43 <sclv_> of course nub probably isn't helping things.
09:32:43 <zeno> MyCatVerbs: newtypes?
09:32:50 <sclv_> @go okasaki "spectacular failure"
09:32:52 <lambdabot> http://okasaki.blogspot.com/2008/04/spectacular-failure.html
09:32:52 <lambdabot> Title: Teaching, Playing, and Programming: A Spectacular Failure
09:33:17 <byorgey> sclv_: yeah, probably not... it's still running, btw =)
09:33:57 <Saizan_> pavizard: you mean the full Catalouge?
09:34:14 <pavizard> :Saizan_ yes, but sorted by n :(
09:34:16 <MyCatVerbs> zeno: I presume it's impossible to do something like newtype Foo = Foo Integer deriving (Eq,Ord,Show,Read,Num) -- ?
09:34:45 <Saizan_> pavizard: and still using your iSort? because we could use sortBy
09:34:52 <byorgey> well, let's see, sequence ["ab", "cd", "ef", "gh"] has 2^4 = 16 strings of length 4
09:34:54 <zeno> MyCatVerbs: http://www.cs.sfu.ca/CC/SW/Haskell/hugs/tutorial-1.4-html/moretypes.html
09:34:56 <lambdabot> Title: A Gentle Introduction to Haskell: Types, Again, http://tinyurl.com/24yzho
09:35:14 <byorgey> so sequence on that list would contain... 4^16 strings.
09:35:16 <byorgey> > 4^16
09:35:17 <pavizard> :Saizan , I don't need the iSort to be used, if there is a better way
09:35:19 <lambdabot>  4294967296
09:35:29 <byorgey> 4.29 billion.
09:35:38 <Saizan_> ?type sortBy
09:35:42 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
09:35:52 <vixey> > (sequence.sequence) ["ab", "cd", "ef", "gh"]
09:35:53 <lambdabot>  ["aaaaaaaabbbbbbbb","aaaaaaaabbbbbbbd","aaaaaaaabbbbbbbf","aaaaaaaabbbbbbbh"...
09:35:55 <byorgey> times 16 chars, times 12 bytes per char for strings...
09:36:13 <vixey> > (sequence.sequence) ["xy", "pq"]
09:36:14 <lambdabot>  ["xxyy","xxyq","xxpy","xxpq","xqyy","xqyq","xqpy","xqpq","pxyy","pxyq","pxpy...
09:36:16 <MathHat> > length $ sequence ["ab", "cd", "ef", "gh"]
09:36:17 <byorgey> @go 4^16 * 16 * 12 bytes in GB
09:36:17 <lambdabot>  16
09:36:18 <lambdabot> No Result Found.
09:36:28 <MyCatVerbs> zeno: danke.
09:36:28 <MathHat> > length $ (sequence.sequence) ["ab", "cd", "ef", "gh"]
09:36:32 <byorgey> @go (4^16 * 16 * 12) B in GB
09:36:33 <lambdabot> Terminated
09:36:33 <lambdabot> No Result Found.
09:36:43 <Saizan_> pavizard: you can use let getn (Catalouge _  _ _ _ n _) = n in sortBy (comparing getn)
09:36:54 <MyCatVerbs> zeno: so no. :)
09:36:59 <zeno> let scream x = (sequence.sequence) x in ["ah", "ar", "ag", "ag", "ah"]
09:37:09 <byorgey> yeah, I think I'm going to tell my computer to stop calculating the nub of a 4.29 billion-element list now ;)
09:37:23 <zeno> MyCatVerbs: np, there might be but i dont know it
09:37:45 <zeno> byorgey: giving up already?
09:38:04 <byorgey> zeno: hehe
09:38:04 <int-e> nub [0..] :: [Word32] ?
09:38:08 <MathHat> > let scream = sequence . sequence in scream ["ar", "ag", "ah"]
09:38:09 <lambdabot>  ["aaaarrrr","aaaarrrg","aaaarrrh","aaaarrgr","aaaarrgg","aaaarrgh","aaaarrar...
09:38:21 <MathHat> nice idea, zeno.
09:38:27 <zeno> thx =p
09:39:14 <sclv_> @oeis 1 16 6561 4294967296
09:39:15 <lambdabot> n^(2^n).
09:39:15 <lambdabot> [0,1,16,6561,4294967296,23283064365386962890625,63340286662973277706162286946...
09:40:08 <Igloo> What's the proper name for things like    forall x . p(x)   ?
09:40:38 <mrd> universal quantification?
09:41:00 <Igloo> I want to include existential quantification too
09:41:23 <pavizard> :Saizan_, is the    comparing    in prelude? I am not sure how to use it
09:41:28 <mrd> quantification?
09:41:42 <mrd> first order logic
09:41:46 <zeno> whats next nihilistic types? (they can include anything)
09:42:17 <zeno> actually that would be T a = T a =p
09:42:28 <zeno> data ^
09:42:32 <Igloo> Or alternatively, does anyone have any hints to make them look pretty when LaTeXed?
09:42:46 <mrd> \forall, \exists
09:43:04 <Igloo> It's the spacing around the . that looks wrong to me
09:43:09 <mrd> ah
09:43:36 <int-e> \,.\, or some other small whitespace should do the trick?
09:43:45 <mrd> admittedly, i like to use \forall_x
09:45:03 <Igloo> Hmm, I'm sure someone somewhere must have written a nice package or macro for it
09:47:11 <yav> Igloo: latex should know how to layout quantifiers when it is in math mode.
09:47:50 <yav> lhs2tex has support for using custom latex symbols, if you are typestting haskell
09:48:32 <Igloo> Well, maybe it's just me, but I don't think the spacing around the .'s in $\forall p \in P . \exists e \in E . e = \mathop{f}(p)$ looks good
09:49:45 <mrd> i wouldn't put the dot there
09:49:59 <mrd> well not the first one
09:50:11 <Saizan_> pavizard: comparing is in Data.Ord iirc
09:50:15 <Saizan_> ?index comparing
09:50:15 <lambdabot> bzzt
09:50:27 <Saizan_> ?type Data.Ord.comparing
09:50:29 <mrd> do you want more space between the E and the e?
09:50:29 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
09:51:03 <Igloo> yup
09:52:28 <mrd> http://en.wikibooks.org/wiki/LaTeX/Mathematics#Controlling_horizontal_spacing
09:52:29 <lambdabot> http://tinyurl.com/5goj5b
09:57:37 <pavizard> :Saizan_  I get this error Undefined variable "comparing"
09:57:58 <allbery_b> what version of ghc?
09:58:37 <MathHat> I've seen a latex module that parses haskell into pretty symbols, somewhere...
09:59:05 <pavizard> allbery_b: I am using win hugs  Version 2006
09:59:47 <zeno> is there a faster way to tell if theres no duplicates other than (\x -> length (nub x) == length x)?
09:59:56 <Saizan_> pavizard: did you put import Data.Ord at the beginning of your file?
10:00:09 <allbery_b> winhugs.  hrrrrm.  I think comparing is relatively new, no idea if Hugs ever got updated to have it
10:00:11 <pavizard> no
10:00:20 <allbery_b> oh, that would do it too
10:01:23 <dcoutts> zeno: yes, you can sort and group, that's O(n log n) rather than O(n^2)
10:01:33 <pavizard> :Saizan_ Is the sortBy also included in Data.Ord ?
10:03:38 <zeno> dcoutts ok, thanks
10:04:26 <pavizard> :Saizan_ I think I need to type import List for the sortBy, right?
10:07:17 <Saizan_> pavizard: yes
10:09:34 <pavizard> :Saizan_ Thanks for that, I now have this error Instance of Monad ((->) [Catalogue]) required for definition of popularTrack
10:15:57 <tuukkah> could anyone help me make fenfire compile on ghc 6.8? specifically, i have no idea what's changed since 6.6 and the cabal changes seem to be nontrivial
10:16:22 <sclv_> the cabal manual pages online list the big changes
10:16:51 <tuukkah> does there happen to be a howto for conversion?
10:16:53 <sclv_> mainly you just need to add new build-depends fields due to the base split.
10:17:24 <tuukkah> rawSystemVerbose and withC2hs seem to have disappeared?
10:17:33 <dcoutts> tuukkah: http://haskell.org/haskellwiki/Upgrading_packages
10:17:55 <dcoutts> tuukkah: Cabal's internal api has changed significantly
10:19:45 <dcoutts> tuukkah: looking at the fenfire Setup.hs, it looks like you do not need the .chs suffix rule since cabal knows about c2hs itself
10:21:05 <tuukkah> dcoutts, our version is a tweaked version of the normal one: we need to work around a c2hs bug with __attribute__(A)=
10:21:49 <dcoutts> tuukkah: are you sure? as far as I know the c2hs parser is ok with __attribute__s
10:21:59 <dcoutts> at least the latest released version is
10:22:03 <mux> I remember it is ok with that too
10:22:11 <mux> it was supposed to pass the full Linux source tree right?
10:22:13 <tuukkah> maybe it's fixed by now
10:22:15 <dcoutts> tuukkah: I know it used to have that problem
10:22:19 <mux> that must contain some __attribute__ stuff
10:22:25 <dcoutts> mux: oh yes
10:22:29 <dcoutts> loads :-)
10:22:38 <dcoutts> loads of other weird gun C extensions
10:22:41 <tuukkah> the question is whether everyone's c2hs supports it or not :-(
10:22:43 <dcoutts> gun/gnu
10:22:45 <mux> they like it like that
10:22:53 <monochrom> heh, linux source tree as C parser benchmark
10:22:54 <mux> I personally don't but - oh well
10:22:55 <dcoutts> tuukkah: build-tools: c2hs >= 0.15.1
10:23:51 <monochrom> hrm, if c2hs can even parse the linux source tree, I should trust it.
10:23:56 <pavizard> :Saizan_ this is what I have used  http://hpaste.org/7256 , but i get an error..hum
10:24:09 <mux> c2hs lacks a few things that I found in hsc2hs
10:24:22 <mux> so I tend to use hsc2hs since I usually don't even need the advanced features of c2hs
10:24:23 <dcoutts> mux: and vica versa
10:24:39 <dcoutts> monochrom: yes though it doesn't guarantee that it calculates sizes of types correctly
10:24:43 <mux> I write FFI bindings and storable instances by hand
10:24:45 <tuukkah> dcoutts, right
10:24:56 <Saizan_> pavizard: that 'do' is misplaced, we're not using monads here, let ... in can be used without do
10:25:26 <mux> dcoutts: sounds like terribly wasted effort to me :-(
10:25:40 <mux> hsc2hs & c2hs merging would be a nice SoC, but it is too late for that
10:25:56 <dcoutts> mux: they're completely different approaches, not easy to merge
10:26:11 <mux> dcoutts: good; a SoC has to be minimally challenging :-)
10:26:30 <dcoutts> mux: but it should not be too hard to improve and verify the c2hs code for calculating structure sizes and offsets
10:27:11 <mux> dcoutts: I guess #ident and #ident_str isn't hard to add to c2hs as well?
10:27:22 <dcoutts> mux: what do they do?
10:28:14 <mux> mm, I must have got the name wrong
10:28:23 <pavizard> ?type Data.Ord.in
10:28:24 <lambdabot> Not in scope: `Data.Ord.in'
10:28:25 <mux> they allow you to insert some C macros in haskell code
10:28:28 <mux> let me get some example
10:28:57 <pavizard> how can import the "in" ?
10:28:58 <dcoutts> mux: you mean a C constant you get from expanding a C macro?
10:29:09 <mux> oh, it's #const and #const_str
10:29:11 <mux> yep.
10:29:18 <mux> archiveBuildApiVersion :: Int
10:29:18 <mux> archiveBuildApiVersion = #const ARCHIVE_API_VERSION
10:29:28 <dcoutts> mux: so long as it does not involve running C code then yes
10:29:45 <dcoutts> mux: ie if it's a simple C const, not an expression
10:29:51 <mux> right
10:30:02 <mux> #const isn't that clever as well
10:30:14 <mux> it just takes #const to be an integral thing, and #const_str to be a string
10:30:18 <mux> dead useful though
10:30:23 <dcoutts> no? I thought it might put the code into the .c file and evaluate it
10:30:38 <mux> maybe I remember it wrong
10:33:08 <pavizard> :Saizan , do you have any idea how can I import "in",    i get an error for this, not sure how I can import it
10:33:09 <pavizard>  n in sortBy (comparing getn)
10:34:40 <monochrom> "in" is builtin keyword, never imported. if you get an error for "in", it is an error caused by something else.
10:35:12 <Saizan_> pavizard: in is a keyword, not a function, however you can also define getn elsewhere or just use a lambda
10:35:43 <sauxdado> > let in = 42 in in
10:35:43 <lambdabot>  Parse error at "=" (column 8)
10:35:52 <mux> well yes
10:35:59 <mauke> this is not fortran
10:36:07 <mux> the syntax is let ... in
10:36:09 <monochrom> "let getn (Catalogue _ _ _ _ n _) = n in sortBy (comparing getn)" is perfectly valid code.
10:36:19 <mux> so you cannot just use "in" here
10:36:25 <Spark> heh
10:36:28 <mux> you're confusing the hell out of the parser
10:36:33 <Spark> thank god languages are sane these days
10:36:45 <pavizard> :monochrom but I get this error Syntax error in input (unexpected keyword "in")
10:36:51 <mux> but this error messages makes me wonder...
10:36:54 <mux> > let in 3
10:36:55 <lambdabot>  3
10:36:57 <monochrom> paste?
10:36:59 <mux> heh, indeed
10:36:59 <Spark> let let = in in = let let
10:37:03 <mux> you can have empty let blocks
10:37:14 <monochrom> I hate it when asker errors are so black-box.
10:37:20 <mux> now that's a powerful tool for obfuscation.
10:37:23 <vixey> > let in let in let in let in let in let in let in let in let in let in let in let in ()
10:37:24 <lambdabot>  ()
10:37:28 <Spark> mux: it's pretty easy to read though
10:37:29 <mauke> aaah
10:37:41 <mauke> > let let in in ()
10:37:41 <lambdabot>  Parse error at "let" (column 5)
10:37:47 <mauke> oh, right
10:37:50 <mux> Spark: that's easily fixed with some pointfree code
10:37:53 <geezusfreeek> whaâ€”?
10:37:55 <mauke> > let _ = let in in ()
10:37:55 <lambdabot>  Parse error at "in" (column 16)
10:37:57 <vixey> > let __ = let in __ in __
10:37:59 <Spark> it's no more obfuscating than just ((((((((((()))))))))))
10:38:12 <lambdabot>  thread killed
10:38:27 <mauke> > let _ = let in () in ()
10:38:28 <lambdabot>  ()
10:39:00 <mauke> > let 3 = let 2 = let in 1 in 2 in 3
10:39:01 <lambdabot>  3
10:39:02 <EvilTerran> > let () = let in () in ()
10:39:03 <lambdabot>  ()
10:39:15 <mux> > let in let letin = 42 in let in letin
10:39:17 <lambdabot>  42
10:39:17 <Deewiant> > let x = let in x y = 1 in y
10:39:17 <lambdabot>  Parse error at "=" (column 20)
10:39:28 <int-e> > let _ = let in () where in ()
10:39:29 <lambdabot>  ()
10:39:34 <mux> hah
10:39:37 <Deewiant> > let in 1
10:39:39 <lambdabot>  1
10:39:46 <Deewiant> O_o, didn't know that's valid
10:39:48 <mauke> > let where in 1
10:39:49 <lambdabot>  Parse error at "where" (column 5)
10:39:51 <EvilTerran> ... can we trick the parser into letting us use &nbsp; in identifiers
10:39:52 <mauke> :(
10:39:54 <Deewiant> > 1 where
10:39:54 <lambdabot>  Parse error at "where" (column 3)
10:39:55 <EvilTerran> ?
10:39:57 <sclv_> > let () = let in 1 where () = let
10:39:57 <lambdabot>  Parse error at end of input
10:39:59 <pavizard> hum..
10:40:06 <Deewiant> I doubt it
10:40:11 <EvilTerran> Deewiant, where{} is only valid after a binding or a case block
10:40:21 <roconnor> > let in = in in in
10:40:22 <lambdabot>  Parse error at "=" (column 8)
10:40:24 <vixey> > case let in () of () -> ()
10:40:26 <lambdabot>  ()
10:40:30 <Deewiant> silly lambdabot
10:40:36 <mux> > let in let {} in let in let {} in 42
10:40:37 <lambdabot>  42
10:40:52 <Deewiant> > let x = 1 where in x
10:40:52 <sclv_> > let () = let where () = let in 1
10:40:53 <lambdabot>  Parse error at "where" (column 14)
10:40:53 <lambdabot>  1
10:40:58 <vixey> > case of _ -> 1
10:40:58 <lambdabot>  Parse error at "of" (column 6)
10:41:00 <sclv_> > let () = let where () = let in 1 23
10:41:00 <lambdabot>  Parse error at "where" (column 14)
10:41:02 <sclv_> > let () = let where () = let in 123
10:41:03 <lambdabot>  Parse error at "where" (column 14)
10:41:06 <sclv_> blah
10:41:09 <Deewiant> > let x = 1 where let in x
10:41:09 <lambdabot>  Parse error at "let" (column 17)
10:41:12 <vixey> > case let {} in [] of _ -> ()
10:41:13 <lambdabot>  ()
10:41:20 <geezusfreeek> > let (-) = 1 in let (--) = (-) in let (-) = (+) in let (+) = (-) in let (++) = (+) in 1+2
10:41:20 <lambdabot> Unbalanced parentheses
10:41:44 <geezusfreeek> no don't even bother reading it
10:41:51 <mauke> -- is a comment
10:41:57 <geezusfreeek> that would be the problem
10:41:58 <Deewiant> > let letin = 1 where wherelet = let in letin in letin
10:41:59 <lambdabot>  1
10:42:10 <mauke> latin-1
10:42:14 <geezusfreeek> > let (-) = 1 in let (-+) = (-) in let (-) = (+) in let (+) = (-) in let (++) = (+) in 1+2
10:42:15 <lambdabot>  3
10:42:16 <vixey> >                                                                                        1
10:42:17 <lambdabot>  1
10:42:20 <int-e> let b = 23; a = b where b = 42 in a -- who wins? :)
10:42:24 <geezusfreeek> yay, a big mess for nothing!
10:42:25 <EvilTerran> > case let in () of () -> let in () where
10:42:26 <lambdabot>  ()
10:42:37 <vixey> 42
10:42:43 <vixey> > let b = 23; a = b where b = 42 in a
10:42:45 <lambdabot>  42
10:42:50 <monochrom> pavizard:  http://hpaste.org/7256#a2
10:43:09 <Deewiant> > let b = 23; a = b where a = 42 in a
10:43:10 <lambdabot>  23
10:43:25 <sauxdado> haha
10:43:29 <geezusfreeek> woah waht?
10:43:39 <int-e> Deewiant: let a = a where a = 42 in a  works, too. (result is 42)
10:43:43 <sauxdado> it's a feature!
10:43:49 <Deewiant> int-e: yep :-)
10:43:57 <EvilTerran> > let a = a where a = 42 in a
10:43:58 <lambdabot>  42
10:44:00 <EvilTerran> er
10:44:01 <Deewiant> the where binding shadows
10:44:06 <EvilTerran> > let b = b where a = 42 in a
10:44:07 <lambdabot>  a
10:44:12 <EvilTerran> i see
10:44:19 <EvilTerran> that seems unintuitive, to me
10:44:29 <vixey> > [([([([([([([([([([()])])])])])])])])])]
10:44:30 <lambdabot>  [[[[[[[[[[()]]]]]]]]]]
10:44:32 <nejucomo> Is it possible to compare error values?
10:44:36 <int-e> EvilTerran: the 'where' is part of the binding of b.
10:44:39 <Deewiant> > error 1 == error 1
10:44:40 <lambdabot>   add an instance declaration for (Num [Char])
10:44:50 <geezusfreeek> oh i didn't see that the where was different in the second one
10:44:51 <Deewiant> > error "1" == error "1"
10:44:52 <lambdabot>  Exception: 1
10:45:04 <EvilTerran> int-e, i thought the where was scoped to the definition of b, though
10:45:12 <int-e> > a
10:45:13 <lambdabot>  a
10:45:14 <Deewiant> geezusfreeek: that was the whole point - messing with all your heads ;-)
10:45:19 <geezusfreeek> grr
10:45:19 <nejucomo> > error "1" == error "2"
10:45:20 <lambdabot>  Exception: 1
10:45:21 <int-e> EvilTerran: it is. you got a different a.
10:45:34 <EvilTerran> nejucomo, you can't do that, no
10:45:40 * EvilTerran catches on to what int-e is saying
10:45:40 <nejucomo> > :t (error "1" == error "1")
10:45:41 <lambdabot>   parse error on input `:'
10:45:48 <Deewiant> :t (error "1" == error "1")
10:45:50 <vixey> :t (==)
10:45:50 <lambdabot> Bool
10:45:51 <lambdabot> forall a. (Eq a) => a -> a -> Bool
10:45:56 <vixey> > error "1"
10:45:57 <lambdabot>  Exception: 1
10:46:00 <Deewiant> :t error "1"
10:46:02 <lambdabot> forall a. a
10:46:02 <EvilTerran> inside b, the where{} takes priority, like parameters do
10:46:14 <EvilTerran> outside b, where{} is not in scope
10:46:19 <Deewiant> exactly
10:47:14 <EvilTerran> > let b = a where a = 42 in b -- so *this* is the correct alpha-conversion, not what i had before
10:47:16 <lambdabot>  42
10:47:38 <nejucomo> Hrm...  So I feel like error is the proper way to implement a given pattern, because it represents an invariant violation, but at the same time I want unit tests which check bad invariants.
10:47:52 <geezusfreeek> > oin [['h'], join ["el"], "l", join (join (join [[["o"]]]))]
10:47:52 <lambdabot>   Not in scope: `oin'
10:47:55 <EvilTerran> nejucomo, you could use MonadError
10:47:57 <geezusfreeek> > join [['h'], join ["el"], "l", join (join (join [[["o"]]]))]
10:47:58 <lambdabot>  "hello"
10:48:17 <EvilTerran> which gives you exception-like constructs without _|_s
10:48:40 <nejucomo> :t MonadError
10:48:41 <Deewiant> > cycle "o hell"
10:48:41 <lambdabot> Not in scope: data constructor `MonadError'
10:48:42 <lambdabot>  "o hello hello hello hello hello hello hello hello hello hello hello hello h...
10:48:46 <EvilTerran> it's a class
10:48:51 <EvilTerran> in Control.Monad.Error
10:49:00 <nejucomo> Thanks...
10:49:01 <vixey> @src join
10:49:01 <lambdabot> join x =  x >>= id
10:49:02 <Deewiant> @info MonadError
10:49:02 <lambdabot> MonadError
10:49:09 <vixey> @src (>>)
10:49:09 <lambdabot> m >> k      = m >>= \_ -> k
10:49:18 <EvilTerran> ?src Either >>=
10:49:18 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
10:49:26 <Deewiant> @pl f m k = m >>= \_ -> k
10:49:26 <lambdabot> f = (. const) . (>>=)
10:49:46 <tromp> :t join
10:49:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
10:49:54 <Deewiant> @src [] (>>=)
10:49:55 <lambdabot> xs >>= f     = concatMap f xs
10:50:12 <tuukkah> bummer, even debian testing and ubuntu have too old c2hs
10:50:27 <vixey> (>> k = ((\_ -> k) =<<)
10:50:28 <Deewiant> hence [] join == concatMap id == concat
10:50:34 <vixey> (>> k) = ((\_ -> k) =<<)
10:50:39 <EvilTerran> ?src Either (>>=)
10:50:39 <lambdabot> Left  l >>= _ = Left l
10:50:39 <lambdabot> Right r >>= k = k r
10:50:42 <EvilTerran> ?src Either return
10:50:43 <lambdabot> return        = Right
10:50:52 <EvilTerran> tuukkah, there's your definition of the basic error monad :)
10:50:56 <EvilTerran> er, nejucomo.
10:51:02 <EvilTerran> (you guys're the same colour here...)
10:51:05 <vixey> :t \k -> (>>= const k)
10:51:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m b -> m a -> m b
10:51:25 <Deewiant> @pl \k -> (>>= const k)
10:51:26 <lambdabot> flip (>>)
10:51:37 <tuukkah> EvilTerran, i know the problem :-)
10:53:23 <nejucomo> Hrm...  I don't understand that source EvilTerran.  I don't grok monads yet.
10:53:59 <EvilTerran> well, the definition of "return" means that return x = Right x
10:54:13 <EvilTerran> ie, a "normal" action in the monad gives you Right <something>
10:54:44 <EvilTerran> the definition of >>= gives you that, if one action is Left <something>, the whole action's Left <something>
10:54:57 <EvilTerran> s/action's/sequence of actions is/
10:55:02 <EvilTerran> ?src Either fail
10:55:04 <lambdabot> fail msg      = Left (strMsg msg)
10:55:15 <nejucomo> Also, I'm not sure if this is the right tool for my approach, because I'd like to do this in pure code.
10:55:25 <EvilTerran> and *that* tells you that failures in the monad are translated into Lefts
10:55:37 <EvilTerran> it's a pure haskell monad
10:55:57 <EvilTerran> it's not like you're stepping into IO for it
10:56:17 <EvilTerran> and it's a lot purer than trying to use normal errors
10:57:06 <vixey> grrr
10:57:08 <vixey> :t (>>=)
10:57:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:57:15 <EvilTerran> 'cos those are affected by such things as order of evaluation
10:57:16 <nejucomo> Hm...  So where I currently have "f n 0 = error ..." how would I express the error condition?
10:57:24 <vixey> that Either Monad
10:57:36 <vixey> :t (Right 1 >>=)
10:57:38 <lambdabot> forall t a b. (Error a, Num t) => (t -> Either a b) -> Either a b
10:57:40 <EvilTerran> f n 0 = Left "..."; f ... = Right <the old body>
10:57:45 <pavizard> :monochrom that's fine, it works to me now, thanks, do you know how I can change the asc or dec order of the output list ?
10:57:46 <vixey> Why does it have to be Error a?
10:58:01 <vixey> can't it just be forall a?
10:58:04 <Deewiant> @instances Error
10:58:05 <lambdabot> IOError, String
10:58:13 <EvilTerran> Left contains an error, Right a success
10:58:38 <EvilTerran> vixey, because "fail" is in Monad
10:58:49 <nejucomo> So this is similar to Maybe, correct?  Except both cases carry a value.
10:58:54 <EvilTerran> exactly
10:58:57 <dmwit> EvilTerran: So?
10:59:13 <EvilTerran> dmwit, so you need a way to convert the string given to fail into the a in Error a
10:59:18 <dmwit> Why would fail restrict the non-Monad part of the type?
10:59:28 <dmwit> oh
10:59:30 <geezusfreeek> > let (||||) = 'h' in let in let (|||) = "l" in let (|||||) = ['e', 'l'] in let (||) = [['o']] in [[(||||)], [(|||||)] >>= id, (|||), join [[(||) >>= id] >>= id]] >>= id -- i must be bored
10:59:31 <lambdabot>  "hello"
10:59:32 <EvilTerran> unless you're just gonna throw it away
10:59:42 <nejucomo> It seems like I would have to alter every caller of my function in order to handle that error condition, and in a normal (non-unit test) environment, I'd rather just have an error and immediate exit.
10:59:45 <dmwit> instance (Error a) => Monad (Either a)
10:59:46 <dmwit> got it
10:59:57 <vixey> :t (Right undefined >>=)
10:59:58 <EvilTerran> fail is also responsible for religious extremism, poverty in africa, and global warming
10:59:58 <lambdabot> forall a a1 b. (Error a1) => (a -> Either a1 b) -> Either a1 b
11:00:13 <Deewiant> what's wrong with fail? :-P
11:00:22 <dmwit> Everything!
11:00:28 <mauke> the type
11:00:30 <Deewiant> evidently, but why
11:00:32 <dmwit> The problem with fail is that it's not mzero.
11:00:38 <Deewiant> ah, it shouldn't be in Monad?
11:00:42 <dmwit> right
11:00:45 <mauke> fail :: (MonadFail m) => m a
11:00:54 <mauke> ^ much better
11:01:26 <nejucomo> I think for now I just won't write unit tests that violate invariants.
11:01:44 <dmwit> Unit tests!
11:01:49 <vixey> > Right 1 >>= \j -> Right 2 >>= \k -> Right 3 >>= \l -> Right l :: Either String Int
11:01:50 <lambdabot>  Right 3
11:01:55 <dmwit> QuickCheck is much better. =)
11:01:57 <vixey> > Right 1 >>= \j -> Left "humf" >>= \k -> Right 3 >>= \l -> Right l :: Either String Int
11:01:57 <lambdabot>  Left "humf"
11:02:17 <Deewiant> unless the bulk of your functions do IO :-P
11:02:20 * nejucomo rtfg's QuickCheck.
11:02:38 <dmwit> ?quickcheck let invariant = even in invariant n ==> odd (n + 1)
11:02:38 <lambdabot> Unknown command, try @list
11:02:45 <dmwit> ?check let invariant = even in invariant n ==> odd (n + 1)
11:02:46 <lambdabot>  Arguments exhausted after 0 tests.
11:02:55 <dmwit> *blink*
11:03:04 <dmwit> ?check let invariant = even in invariant (n :: Int) ==> odd (n + 1)
11:03:05 <lambdabot>  Couldn't match expected type `Int' against inferred type `Expr'
11:03:13 <Deewiant> @check \n -> even n ==> odd (n+1)
11:03:14 <lambdabot>  OK, passed 500 tests.
11:03:19 <Deewiant> dmwit: needs moar lambda
11:03:22 <dmwit> ah
11:03:26 <Deewiant> @ty n
11:03:28 <lambdabot> Expr
11:03:29 <Deewiant> > even n
11:03:31 <lambdabot>  False
11:03:32 <Deewiant> :-)
11:03:40 <dmwit> =((
11:03:59 <mauke> > odd n
11:04:00 <lambdabot>  True
11:04:07 <mauke> > even m
11:04:08 <lambdabot>  False
11:04:20 <dmwit> It's odd that ?check knows about Expr.
11:04:37 <ToRA> @scheck \n -> even n ==> odd (n+1)
11:04:38 <lambdabot> Done.
11:04:57 <ToRA> @scheck \n -> even (n::Int) ==> odd (n+1)
11:04:58 <lambdabot> Done.
11:05:02 <ToRA> "Done" ?
11:05:09 <Deewiant> ==> is quickcheck, not smallcheck
11:05:15 <Deewiant> @scheck True
11:05:18 <lambdabot>   Completed 1 test(s) without failure.
11:05:22 <Deewiant> hmm
11:05:31 <Deewiant> @scheck id
11:05:32 <lambdabot> Add a type signature
11:05:36 <Deewiant> @scheck (+1)
11:05:37 <lambdabot> Add a type signature
11:05:38 <ToRA> @scheck \n -> if even (n::Int) then odd (n+1) else True
11:05:40 <lambdabot>   Completed 13 test(s) without failure.
11:05:42 <Deewiant> @scheck (+1 :: Int -> Int)
11:05:43 <lambdabot>  Parse error at "::" (column 5)
11:05:48 <Deewiant> @scheck ((+1) :: Int -> Int)
11:05:49 <lambdabot>       add an instance declaration for (SmallCheck.Testable Int)
11:05:49 <lambdabot>     In the ex...
11:06:03 <dmwit> ?scheck liftM2 (||) even odd
11:06:04 <lambdabot>   Completed 13 test(s) without failure.
11:06:05 <Deewiant> @ty \n -> even n ==> odd (n+1)
11:06:07 <lambdabot> forall a. (Integral a) => a -> Property
11:06:08 <bos> @seen cosmicray
11:06:08 <lambdabot> Last time I saw cosmicray was when I left ##logic, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books, #haskell-hac07, #haskell-hac4,
11:06:08 <lambdabot>  #haskell-overflow, #haskell-soc, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #
11:06:08 <lambdabot> jtiger, #parrot, #perl6, #rosettacode, #scala, #scannedinavian, #thunks, #unicycling and #xmonad 5d 23h 48m 32s ago, and .
11:06:12 <bos> augh.
11:06:12 <lambdabot> bos: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:06:18 <Deewiant> @scheck (id :: (Integral a) => a -> Property)
11:06:19 <lambdabot> Done.
11:06:31 <Deewiant> @scheck (id :: Property -> Property)
11:06:32 <lambdabot> Done.
11:06:43 <Deewiant> @instances SmallCheck.Testable
11:06:45 <lambdabot> Couldn't find class `SmallCheck.Testable'. Try @instances-importing
11:06:48 <Deewiant> shrug
11:08:33 <byorgey> http://wso.williams.edu/~byorgey/diagrams/diagram3.html
11:08:42 <ToRA> is anybody here involved in working on lazy smallcheck?
11:08:47 <tuukkah> what should i use instead of the old Data.ByteString.copyCStringLen?
11:10:07 <tuukkah> packCStringLen? is that the exact same thing?
11:11:30 <dmwit> byorgey: Is that... is that your library? O_o
11:11:37 <byorgey> dmwit: yup! =D
11:11:42 <dmwit> It's pretty!
11:12:08 <vixey> that's awesome
11:12:15 <byorgey> well, thanks.  in this case that's mostly due to the fact that Ford circles are awesome =)
11:12:46 <byorgey> I hope to release v0.1 (still very primitive, but usable for drawing pretty things as you can see) tomorrow.
11:12:47 <dmwit> Well... yeah.
11:12:57 <dmwit> Sweet!
11:13:18 <byorgey> future versions will hopefully also be useful for drawing actual diagrams, with, you know, text and arrows and stuff =)
11:13:40 <sauxdado> have you considered svg?
11:13:51 <dmwit> So you have circles only for now, I guess?
11:13:54 <dmwit> Circles and colors.
11:14:19 <byorgey> dmwit: actually, I have rectangles and polygons too
11:14:33 <dmwit> Oh, cool.
11:14:40 <byorgey> sauxdado: my library is built on top of Cairo, which I think can do svg output
11:15:46 <byorgey> right now I only have png as an output possibility but it should hopefully be trivial to add svg, ps, and pdf, since cairo already supports those.
11:16:27 <MathHat> yay cairo!
11:16:31 <MathHat> boo pango!
11:16:38 <dcoutts> heh
11:16:56 <dcoutts> you need pango do get really good text output with cairo
11:17:14 <MathHat> yes, but I've had nothing but trouble trying to build it lately
11:17:39 <dcoutts> MathHat: what, the actual C lib or the binding?
11:18:32 <MathHat> the lib.  probably a stupid of mine.
11:21:31 <pavizard> How can I have the following n result in descending order?
11:21:32 <pavizard> let getn (Catalogue _ _ _ _ n _) = n in sortBy (comparing getn)
11:21:51 <Deewiant> reverse it? :-)
11:21:55 <dcoutts> @seen mnislaih
11:21:55 <lambdabot> I saw mnislaih leaving #haskell and #ghc 1h 3m 6s ago, and .
11:22:48 <unenough> @seen @seen
11:22:48 <lambdabot> I haven't seen @seen.
11:23:03 <Deewiant> hm, there's no 'flip comparison' function
11:23:25 <bos> dcoutts: ping
11:23:42 <dcoutts> bos: pong
11:23:45 <eugman|college> Well, my class/speech/lecture thing went well.
11:23:47 <dmwit> Deewiant: flip (comparing getn) -- ?
11:24:02 <bos> dcoutts: i tried adding "Cabal-version: >= 1.2.3.0 && < 1.3" to cabal-rpm, and now i can't upload it to hackage
11:24:08 * bos pulls hair out
11:24:09 <Deewiant> dmwit: :-D I meant LT to GT and vice versa.
11:24:26 <dcoutts> bos: someone else reported that bug today, I wasn't aware of it
11:24:26 <dmwit> Deewiant: For a correctly written function... flip does exactly that.
11:24:27 <Deewiant> \c -> case c of LT -> GT; GT -> LT; x -> x
11:24:34 <unenough> eugman|college, what about?
11:24:55 <Deewiant> dmwit: I was going to say it's not the same for NaNs but then I remembered that Haskell doesn't handle NaNs that well anyway. ;-)
11:25:41 <Deewiant> > compare (0/0) 1
11:25:43 <lambdabot>  GT
11:25:46 <Deewiant> > (0/0) > 1
11:25:47 <lambdabot>  False
11:26:01 <dmwit> ew
11:26:15 <sauxdado> > 0/0
11:26:16 <lambdabot>  NaN
11:26:19 <eugman|college> I tought the class basic haskell today
11:26:27 <dcoutts> bos: the intent of the check was to stop uploads of things that required a newer version of cabal than was on the server, but we're inadvertently catching packages that require older versions
11:26:37 <sauxdado> eugman|college: sweet!
11:26:48 <eugman|college> yar.
11:27:01 <dcoutts> bos: but in any case, you do not need to specify cabal-version, just build-depends: Cabal >= 1.2.3.0 && < 1.3
11:27:10 <bos> dcoutts: yes. also, cabal-upload doesn't print anything by default if an upload fails, so i have to retry with -v.
11:27:52 <dcoutts> bos: yes, we're waiting for an improvement in the cgi lib so it can report plain text error messages rather than html
11:28:10 <dcoutts> bos: there's an open ticket on that
11:28:12 <bos> dcoutts: cool
11:28:27 <pavizard> :Deewiant :) thanks!
11:29:07 <Deewiant> pavizard: but like dmwit said, using flip should also work. Plus it's probably more efficient. :-)
11:29:11 <dcoutts> bos: so cabal-rpm should be able to be built using any cabal version, but it has to compile against a specific api version, hence build-depends, not cabal-version, make sense?
11:29:57 * dmwit considers
11:30:22 <dmwit> I wonder whether using flip adds O(n * log n) work or O(1) work.
11:30:31 <bos> dcoutts: yes
11:30:51 <Deewiant> why wouldn't it be O(1)?
11:31:23 <sauxdado> i would hope flip doesn't add any work.
11:31:27 <pavizard> :Deewian why flip is more efficient? (Education question :) )
11:31:37 <dmwit> Deewiant: Well, if it flips the arguments on each call...
11:31:53 <Deewiant> reversing travels the whole list an additional time
11:32:02 <dmwit> sauxdado: That's absurd, how would that possibly work?
11:32:20 <sauxdado> @src flip
11:32:20 <lambdabot> flip f x y = f y x
11:32:22 <Deewiant> even if flip flips on each call instead of at compile time (as I would hope it does), it's only a constant time hit for each comparison
11:32:36 <byorgey> right, O(1) for each comparison, which is O(n lg n) overall
11:32:40 <dmwit> Deewiant: Yes... for each comparison.
11:32:42 <pavizard> @src reverse
11:32:42 <lambdabot> reverse = foldl (flip (:)) []
11:32:50 <dmwit> Deewiant: That's an additional O(n * log n) work.
11:33:03 <dmwit> Deewiant: So... reversing may actually scale *better* than flip. =)
11:33:05 <Deewiant> right, good point, since it's already O(n log n).
11:33:25 <byorgey> dmwit: interesting question.  I think it probably does have to do extra work on each call
11:33:30 <Deewiant> But, like said, why wouldn't the flip be done at compile time?
11:33:39 <dmwit> Why would it be?
11:33:51 <pavizard> :Deewiant so , should i better use reverse then instead ? :p
11:34:09 <dmwit> pavizard: It's not likely to matter unless we're talking about lists millions of entries long.
11:34:32 <Deewiant> what he said.
11:34:47 <dmwit> pavizard: Be careful, you are now in a channel full of academics; practical matters are secondary. =)
11:34:59 <pavizard> hehe, not really it doesn't really make any difference for my coursework :) but thank you guys for leting me know about it,
11:35:00 <byorgey> it's not likely to matter even if we ARE talking about lists millions of entries long =)
11:35:14 <dmwit> ...yeah
11:35:48 <pavizard> :byorgey are the equal ?
11:35:48 <byorgey> memory usage could probably be better using flip
11:35:57 <pavizard> yes
11:36:16 <byorgey> since the elements in the sorted list could be generated (and consumed by something else) before the rest are generated
11:36:26 <byorgey> whereas using a reverse, you have to sort the entire list before you can produce any output
11:37:04 <dmwit> sort is already strict
11:37:12 <dmwit> > head $ sort [1..10^10]
11:37:16 <lambdabot> Terminated
11:37:26 <dmwit> Well... that's not good proof.
11:37:35 <dmwit> But sort is not online, in any case.
11:37:36 <Deewiant> testing with GHCi, reverse is a bit faster in exchange for memory
11:37:40 <tac-tics> > head (sort [1..])
11:37:44 <lambdabot> Terminated
11:38:23 <eugman|college> so can anyone state succintly when to use foldr or foldl instead of the other?
11:38:50 <dmwit> Use foldr when your operation is right-associative, foldl when it's left-associative. ;-)
11:39:02 <Deewiant> foldr is good for laziness, foldl' for strictness, foldl is never good. ;-P
11:39:06 <dmwit> And when it's left-associative, use foldl'.
11:39:31 <byorgey> eugman|college: this wiki page has an excellent discussion of that question: http://haskell.org/haskellwiki/Stack_overflow
11:39:54 <Socrates`> How can I use lambdabot to check a type for me?
11:40:00 <Deewiant> compiling with ghc -O2, flip compare is consistently faster.
11:40:04 <ohub> :t foldr
11:40:07 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:40:07 <vixey> Socrates`: Yes you can
11:40:12 <vixey> use @type
11:40:19 <vixey> (:t works in channel though)
11:40:22 <Deewiant> which, I would guess, means that the flip is indeed done at compile time.
11:40:27 <Socrates`> Thanks vixey
11:40:53 <Deewiant> yeah, the timings appear to match using just sortBy compare to get ascending order.
11:41:17 <byorgey> Deewiant: it doesn't necessarily mean that.
11:41:30 <Deewiant> no, not necessarily.
11:41:31 <byorgey> it just means that the constant factors associated with reversing are much higher (which I would expect).
11:41:35 <Deewiant> which is why I said "I would guess". ;-)
11:42:10 <byorgey> fair enough =
11:42:16 <byorgey> =)
11:42:29 <Deewiant> but note that without optimization reversing was faster.
11:42:58 <byorgey> ah, interesting
11:45:55 <dcoutts> mnislaih: I think I might drop the ANSI console bold stuff in the cabal --help output since I don't think we can make it work
11:46:12 <dcoutts> mnislaih: it relies on looking at the default flags, but those are initially empty
12:12:39 <tibbe> dcoutts: can I make a tiny cabal feature request? I want cabal help to work in addition to cabal --help. Many other tools support that and I type it by relfex
12:13:09 <dcoutts> tibbe: what tools do that? seems to me more consistent for it to be --help
12:13:22 <tibbe> dcoutts: at least git
12:13:32 <tibbe> dcoutts: darcs
12:13:54 <tibbe> dcoutts: they support both
12:13:55 <tac-tics> svn has --help too
12:14:01 <tac-tics> svn help or svn --help
12:14:14 <dcoutts> I wonder if it's just because unrecognised commands yield the help page
12:14:23 <tibbe> dcoutts: peforce. many tools also have <tool> help <command>
12:14:25 <dcoutts> do you get the same for git foobar ?
12:14:37 <tac-tics> svn: invalid option: --foo
12:14:44 <tibbe> dcoutts: no, not for foobar
12:14:54 <tibbe> dcoutts: git: 'foobar' is not a git-command. See 'git --help'.
12:15:22 <tibbe> dcoutts: can I file a feature request for it? :)
12:15:46 <dcoutts> tibbe: lemme look, if it's easy I'll do it otherwise I'm not sure I can be bothered :-)
12:15:57 <dcoutts> tibbe: it might go against our command abstraction
12:16:00 <tibbe> dcoutts: it's in the bug tracker now :p
12:16:26 <tibbe> are you telling me THE USER that I should care about the shortcomings of your implementation!!!111 ;)
12:17:16 <dcoutts> tibbe: do you also expect cabal install help to work?
12:17:24 <lilac> http://hpaste.org/7258 <-- i'm a haskell newbie, looking for constructive criticism on how i might have written this better
12:17:31 <dcoutts> tibbe: or just cabal help ?
12:18:36 <mauke> Errors looks like a Writer monad
12:18:37 <lilac> in particular, i'm pretty unhappy about the definitions of 'trigraphs' and 'translateToBasicSourceCS' and i'm wondering if there's a better way of expressing those in haskell
12:18:59 * lilac looks up Writer monad
12:19:51 <tibbe> dcoutts: no but cabal help install
12:19:56 <mauke> isSpace(x) better written as isSpace x
12:20:17 <dcoutts> tibbe: oh, that might be tricky
12:20:40 <dcoutts> tibbe: you'll note that currently "cabal --help install" gives you the global help
12:20:46 <tibbe> dcoutts: but cabal help would be a nice start
12:20:47 <mauke> actually, | any ($ x) [isAlphaNum, isSpace, (`elem` "_{}[]#()<>%:;.?*+-/^&|~!=,\\\"'")] = return x
12:20:52 <dcoutts> tibbe: while "cabal install --help" gives you the install help
12:21:17 <tibbe> dcoutts: right, there's some special handling of --help in there already if I remember correctly. maybe it could be extended
12:21:20 <dmwit> I would write trigraphs a little differently, let me paste...
12:21:36 <tibbe> dcoutts: maybe just rewrite the command line although you might consider that ugly
12:21:40 <nejucomo> Why doesn't this parse:
12:22:07 <mauke> lilac: sequence (map ...) is mapM
12:22:49 <Deewiant> @src mapM
12:22:50 <lambdabot> mapM f as = sequence (map f as)
12:23:17 <nejucomo> TestCase $ return (s == collapse [a, b]
12:23:17 <nejucomo>                        where s = "HelloWorld!"
12:23:17 <nejucomo>                        (a, b) = take_drop 5 s
12:23:22 <lilac> mauke: that ($ x) trick is neat
12:23:44 <nejucomo> (I left off the final close paren when I cut'n'pasted.)
12:23:46 <mauke> nejucomo: you can't use 'where' in expressions
12:23:53 <dmwit> http://hpaste.org/7258#a1
12:23:56 <nejucomo> Oh.
12:24:01 <dmwit> hpaste bot doesn't seem active.
12:24:17 <mauke> preflex_: seen hpaste
12:24:18 -preflex_(n=preflex@d83-189-67-177.cust.tele2.de)- hpaste was last seen on #haskell 11 days, 18 hours, 6 minutes and 16 seconds ago, saying: Haskell paste bin: http://hpaste.org/
12:24:31 <dmwit> whoa
12:24:38 <dmwit> lambdabot: seen hpaste
12:24:43 <dmwit> ?seen hpaste
12:24:43 <lambdabot> I haven't seen hpaste.
12:25:02 <Deewiant> @uptime
12:25:02 <lambdabot> uptime: 1d 13h 25m 47s, longest uptime: 1m 10d 23h 44m 29s
12:25:10 <dmwit> preflex_: help
12:25:11 -preflex_(n=preflex@d83-189-67-177.cust.tele2.de)- try 'help help' or see 'list' for available commands
12:25:12 <Cale> nejucomo: Yeah, 'where' is part of the syntax of declarations. If you want to make local bindings in an expression, use let <decls> in <expr>
12:25:25 <tibbe> dcoutts: so I added a ticket for posterity, have to run now
12:26:06 <dmwit> It's like a really bare-bones lambdabot.
12:26:21 <dmwit> Also, what's the deal with the dashes around its name when it speaks?
12:26:29 <vixey> ?where ?where
12:26:29 <lambdabot> ?where ?where
12:26:37 <vixey> dmwit ^ so that doesn't work
12:26:48 <dmwit> eh?
12:26:53 <mauke> dmwit: it uses NOTICE instead of PRIVMSG
12:26:56 <Deewiant> dmwit: it uses NOTICE instead of PRIVMSG
12:26:58 <Deewiant> :-)
12:27:00 <vixey> if you got two lambdabots here, they would talk to each other
12:27:17 <vixey> if bots used /notice, they can't quine indefinitely
12:27:25 <dmwit> oh
12:28:01 <Cale> Yeah, too bad many IRC clients fail to render NOTICEs correctly.
12:28:38 <Deewiant> well, there's no standard as to what's "correct". :-)
12:28:50 <Deewiant> but true, many fail in rendering them in any sensible way
12:29:22 <Cale> Well, okay, but it really should look very much like PRIVMSG, since they're very similar according to the standard.
12:29:27 <lilac> I'm using ghc 6.6.1 and I can't find the Writer monad defined anywhere -- there's no Control.Monad.Writer
12:29:43 <Cale> lilac: Perhaps you don't have the mtl library installed?
12:29:49 <mauke> you're probably missing extralibs
12:29:52 <Cale> er s/library/package/
12:30:09 <Cale> It normally comes with GHC, but doesn't come with the barebones release.
12:33:04 <mnislaih> dcoutts: mnislaih is watching football right now :)
12:34:12 <mnislaih> dcoutts I will take a look the day after tomorrow, the default flags are not empty, are they ?
12:48:59 <ptolomy2> Hm. I'm a little surprised that my hand-made monad ends up being slower than the ErrorT StateT stack I was using before.
12:49:50 <ptolomy2> I'm probably doing something wrong.
12:51:07 <lilac> OK, here's what I've got now: http://hpaste.org/7258#a2
12:52:47 <lilac> this seems pedantic, but is my use of whitespace within normal parameters (esp. in trigraphs)? could i lay it out in a way which would make it easier to read for seasoned haskellers?
12:54:59 <dmwit> lilac: Have you looked at Parsec?
12:55:53 <Cale> lilac: It's all right. I'd consider lifting 'trigraph' up out of the where clause, since it's a little awkward there. I also tend to prefer having the individual patterns in a case indented just a little more than the 'case' keyword itself, though that clearly isn't required.
12:57:04 <lilac> dmwit: yep, Parsec is where I started, but I thought I'd try doing it by hand first (this is my first excursion into the world of Haskell)
12:57:14 <dmwit> Ah, okay.
12:57:35 <dmwit> I'll quit annotating with it, then. =)
12:58:03 <lilac> dmwit: well, notes on how to do it with parsec would be appreciated ;-)
13:00:09 <Bonus> how would i make a function that, say,
13:00:18 <Bonus> returns 1 when something expects an Int out of it
13:00:27 <Bonus> or returns 'a' when something calling it expects a Char
13:00:42 <dmwit> Sounds like a type-class to me!
13:00:53 <Bonus> hmm
13:01:00 <dmwit> It also sounds like a homework problem to me. ;-)
13:01:06 <Bonus> hehe no no
13:01:09 <Bonus> i'm just wondering
13:01:12 <Bonus> for instance
13:01:24 <dmwit> class Representative a where representative :: a
13:01:26 <Bonus> the =~ function in Text.Regex.Posix
13:01:37 <dmwit> instance Representative Int where representative = 0
13:01:41 <Bonus> returns a number of matches or a bool
13:01:46 <Bonus> depending on what's expected of it
13:01:51 <dmwit> instance Representative Char where representative = 'a'
13:01:54 <Bonus> i'm just wondering how that's implemented
13:01:55 <Bonus> aha
13:02:00 <dmwit> Yeah, it's a type-class.
13:02:04 <mauke> Bonus: look at 'read', that's a simpler example
13:02:08 <dmwit> Polymorphism on return type for the WIN!
13:03:03 <Bonus> aha i didn't know Int was a typeclass
13:03:05 <Bonus> how silly of me
13:03:11 <Bonus> i just thought that was stuff like Eq and Num
13:03:19 <Mappypants> hi hi.  anyone have any good ideas for an introductory haskell course final project?  I am trying to find something to do that is manageable, not too complex, yet still worthwhile as a final project.  we haven't covered state/monads or even IO.
13:03:20 <mauke> Int isn't a class
13:03:43 <Bonus> aha hmm
13:03:49 <dmwit> No, Int is an instance of many classes.
13:03:56 <dmwit> But it is not itself a class.
13:05:21 <Bonus> aha now i see where my problem was
13:05:33 <Bonus> i didn't know you could just tack on that Int implements some functions
13:05:36 <Bonus> e.g. tack them on to Int
13:05:44 <Bonus> i thought you could do that to just your own data types
13:06:24 <mauke> no, you can make any type an instance of any class, not just your own
13:06:32 <Bonus> freaking awesome
13:06:52 <Bonus> doesn't that lead to trouble though?
13:06:54 <Bonus> like monkey patching
13:07:07 <mauke> you can't override existing instances
13:07:16 <Bonus> aha
13:07:19 <Bonus> nice
13:07:54 <lilac> but you can make Integer an instance of Floating, presumably?
13:08:34 <mauke> yes
13:08:49 <Bonus> when I have "class Something a where"
13:08:50 <dcoutts> mnislaih: yes, in most cases the initial flags are empty
13:08:52 <mauke> not that it would make sense
13:08:53 <Bonus> how is that generally read
13:08:55 <Bonus> i mean the a
13:08:59 <dcoutts> mnislaih: especially in cabal-install
13:09:07 <Bonus> it's a type variable, yes?
13:09:13 <mauke> yeah
13:09:33 <Bonus> can you do stuff like
13:09:34 <lilac> do people ever see problems where two library vendors both supply an instance for the same type for the same class?
13:09:36 <Bonus> class Something a b where
13:09:59 <lilac> i ask because concept maps in C++ (which are conceptually similar to type classes in Haskell) have that as an anticipated issue
13:10:28 <Bonus> well isn't it so that if there's conflicts you don't import everything to the global namespace?
13:10:42 <Bonus> but like qualified
13:10:51 <Deewiant> except that instances are always in the global namespace and always imported when you import the defining module :-P
13:10:52 <mauke> class instances are global
13:10:53 <Heffalump> lilac: I don't think so. Typically it's the responsibility of either the type declarer or the class declarer to declare the instance. Usually one is obviously "above" the other in the stack of stuff.
13:11:03 <Bonus> oh
13:11:07 <Heffalump> What's more frequent is people wanting to locally override the standard instance.
13:11:17 <mauke> Bonus: that's an extension called multiparameter typeclasses
13:12:02 <lilac> Heffalump: in the C++ case, the anticipated problem is, vendor A provides a type class C, vendor B provides a type T, vendors C and D both want to use A and B's stuff, so both create 'instance C T', and you want to use C and D's stuff together
13:12:22 <Heffalump> ok, I suppose that's possible. I've not encountered it.
13:14:00 <lilac> there's also the issue of multiple instances for a single type -- for instance, localized comparisons for String -- which I think both C++ and Haskell have only inelegant solutions for
13:15:33 <dmwit> newtype?
13:15:44 <dmwit> I guess that could be considered inelegant.
13:16:53 <dmwit> I'm not sure what would be better, though.
13:17:27 <tac-tics> Internationally sound strings are not a very haskellesque datastructure.
13:18:37 <dmwit> ?
13:19:18 <lilac> dmwit: something like "frenchSorted ss = (Cmp String = FrenchCmp) => sort ss" ?
13:19:33 <tac-tics> To do things where localization affects string operations, you'd need to carry a Localization object along with the raw unicode
13:19:52 <dmwit> lilac: sortBy frenchCmp?
13:19:55 <lilac> dmwit: with a corresponding "instance FrenchCmp = Cmp String where" or similar
13:19:56 <dmwit> :t sortBy
13:19:57 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
13:20:15 <dmwit> Also: newtype
13:20:19 <dmwit> as I said before.
13:20:35 <mauke> let ?cmp = FrenchCmp in sort omg
13:20:47 <dmwit> newtype French = French String
13:20:57 <dmwit> instance Ord French where compare = ...
13:21:37 <dmwit> sortFrench s = let (French sorted) = sort (French s) in sorted -- the least elegant part, I guess
13:21:44 <lilac> dmwit: now imagine your class has four methods, and you're calling someone who's calling someone who's calling someone who's sorting. i'd prefer not to pass the relevant things through all those intermediaries. i think newtype would be better than the generalization of the sortBy solution
13:22:02 <Bonus> guys can i paste 6 lines here?
13:22:04 <dmwit> "would be"...
13:22:09 <dmwit> newtype *already exists*
13:22:15 <Bonus> about a problem
13:22:17 <dmwit> Bonus: Please use hpaste instead.
13:22:20 <tac-tics> @paste
13:22:21 <Bonus> ok
13:22:21 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:22:33 <ptolomy2> If my handcoded replacement monad for ErrorT (StateT IO) is less efficient, should I be surprised?
13:22:38 <Bonus> why does this yell at me http://hpaste.org/7261
13:23:19 <dmwit> Because Num isn't Int.
13:23:19 <Bonus> it says something about t being a rigid variable
13:23:26 <lilac> dmwit: newtype isn't an elegant solution, though, really
13:23:37 <dmwit> The argument to "chr" has to be an Int, but it could be any instance of Num there.
13:23:50 <Bonus> aha it needs to be an int?
13:23:51 <Bonus> ah
13:23:56 <sjanssen> @seen glguy
13:23:56 <lambdabot> glguy is in #haskell. I last heard glguy speak 3h 54m 22s ago.
13:23:57 <dmwit> :t chr
13:23:58 <lambdabot> Int -> Char
13:24:02 <glguy> 4?
13:24:04 <dmwit> Has to be an Int. =)
13:24:11 <sjanssen> glguy: why are all the links on hpaste javascript?
13:24:18 <Bonus> but if i remove the second one
13:24:20 <Bonus> it still doesn't work
13:24:22 <Bonus> with +
13:24:28 <Bonus> but (+) needs two Nums
13:24:36 <dmwit> Right.
13:24:37 <glguy> sjanssen: they aren't all javascript, they work as normal links too
13:24:40 <dmwit> You have to convert a Num to an Int.
13:24:44 <dmwit> Let's see here...
13:24:47 <dmwit> :t toInteger
13:24:47 <glguy> sjanssen: the javascript lets you click on the whole row, for example
13:24:48 <lambdabot> forall a. (Integral a) => a -> Integer
13:24:53 <dmwit> almost
13:24:55 <dmwit> ?src Num
13:24:55 <lambdabot> class  (Eq a, Show a) => Num a  where
13:24:55 <lambdabot>     (+), (-), (*)           :: a -> a -> a
13:24:55 <lambdabot>     negate, abs, signum     :: a -> a
13:24:55 <lambdabot>     fromInteger             :: Integer -> a
13:25:01 <lilac> :t round
13:25:03 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
13:25:11 <glguy> sjanssen: but the whole thing works with javascript turned off
13:25:18 <sjanssen> glguy: ah, I see
13:25:22 <dmwit> Bonus: Sounds like Num is too general.
13:25:33 <sjanssen> glguy: it confuses vimperator's 'hints' mode
13:25:37 <Bonus> aha
13:25:56 <dmwit> Bonus: Try using (Integral t) => t -> t -> a, and add a cast.
13:26:00 <glguy> sjanssen: I've never used vimerator
13:26:03 <glguy> p*
13:26:05 <Bonus> cool will do, thanks :)
13:26:10 <yav> the guy and email about the xml thing
13:26:58 <pavizard> how can I define a new line to be given when the elements of each x are read?
13:26:59 <pavizard> justTheStrings :: [Catalogue] -> [Char]
13:27:01 <pavizard> justTheStrings ((Catalogue t a p l n g):xs) = unwords [t, a, p, (show l), (show n), g ]
13:27:04 <lilac> well, thanks for your help, everyone...
13:35:44 <dmwit> pavizard: unlines
13:43:07 <kiris> insertAfter x xs ys = concatMap f xs where
13:43:07 <kiris>     f x | x == 1    = x:ys
13:43:07 <kiris>         | otherwise = [x]
13:43:12 <kiris> is there a better way to express this?
13:43:30 <kiris> er, that's wrong
13:43:35 <kiris> i'll make a nopaste
13:43:51 <dmwit> ?hpaste is preferred for its syntax highlighting. =)
13:43:52 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:44:19 <kiris> that's what i meant, brother
13:44:48 <kiris> didn't announce it: http://hpaste.org/7262
13:45:33 <byorgey> kiris: so, e.g. insertAfter 3 [1,3,2,4,3,5] [6,7] should be [1,3,6,7,2,4,3,6,7,5] ?
13:45:35 <kiris> basically, if i find an element x in a list xs, then insert ys after that element
13:45:47 <dmwit> That's about as good as it gets, I think.
13:45:55 <byorgey> I agree.
13:46:04 <kiris> byorgey: [1,3,6,7,2,4,3,6,7,5], yes
13:46:09 <kiris> righteo
13:47:03 <kiris> thanks
13:47:17 <byorgey> you could always express  concatMap f xs  as xs >>= f.  but in this case IMO that would be slightly obfuscatory.
13:47:27 <dibblego> ?hoogle Maybe a -> Maybe a -> Maybe a
13:47:28 <lambdabot> Data.Generics.Aliases.orElse :: Maybe a -> Maybe a -> Maybe a
13:48:05 <byorgey> dibblego: mplus, perhaps?
13:48:06 <dibblego> > Just 7 `Data.Generics.Aliases.orElse` Just 8
13:48:07 <lambdabot>   Not in scope: `Data.Generics.Aliases.orElse'
13:48:16 <byorgey> > Just 7 `mplus` Just 8
13:48:17 <lambdabot>  Just 7
13:48:19 <dibblego> > Just 7 `mplua` Just 8
13:48:19 <lambdabot>   Not in scope: `mplua'
13:48:27 <dibblego> > Just 7 `mplus` Nothing
13:48:28 <lambdabot>  Just 7
13:48:37 <dibblego> > Nothing `mplus` Just 7
13:48:38 <lambdabot>  Just 7
13:48:42 <dibblego> > Nothing `mplus` Nothing
13:48:43 <lambdabot>  Nothing
13:48:47 <dibblego> thanks :)
13:48:51 <byorgey> sure =)
13:48:52 <kiris> byorgey: hm, indeed, that might be less obvious
13:50:27 <kiris> i could express it as (concatMap (fiz (==x) (:ys) (:[])) xs) provided a definition of fiz of a type like (a -> Bool) -> (a -> b) -> (a -> b) -> b, similar to `maybe'
13:50:42 <kiris> but unless that's standard (which i highly doubt as it's a litle weird), it's a bit silly to define
13:50:56 <DRMacIver> Oh dear. It looks like one of the top search phrases for reaching my blog is "Haskell sucks" :)
13:51:16 <kiris> DRMacIver: made by naughty commenters, of course!?
13:51:23 <DRMacIver> Um. Well...
13:52:22 <DRMacIver> (The reason that reaches my blog is probably because of the "Tell us why your language sucks" post I made a while ago, in which I detailed some problems I saw with Haskell and asked other people to do the same for languages they used and liked)
13:52:39 <joey> @type foldM (>>=)
13:52:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> [a -> m (m a)] -> m (m a)
13:52:56 <joey> @type foldM ((>>=) . (>>=))
13:52:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> [m b -> (a -> m b) -> m a] -> (a -> m b) -> m a
13:53:24 <kiris> it's beautiful ;___;
13:54:04 <awesame> DRMacIver: I'd like to read that post!
13:54:18 <monochrom> Haskell sucks! It doesn't use Chinese.
13:54:27 <monochrom> Java sucks! It doesn't use Chinese.
13:54:40 <vixey> does any language use Chinese?
13:54:50 <monochrom> Japanese uses Chinese.
13:55:20 <awesame> so, ruby doesn't suck?
13:55:23 <monochrom> Later in this century many African countries may switch to Chinese too. :)
13:55:25 <DRMacIver> awesame: http://www.drmaciver.com/2008/02/tell-us-why-your-language-sucks/
13:55:26 <lambdabot> Title: 11 David R. MacIver 17 » Blog Archive 28 » Tell us why your language sucks 37
13:55:54 <DRMacIver> awesame: There was also a reddit comment thread on it which had some interesting stuff, but I can't be bothered to dig it up. :)
13:56:06 * vixey idly wonders if Chinese is easier/harder to learn than Hebrew
13:56:27 <sauxdado> I would say harder, but it depends on what languages you already know.
13:56:27 * kiris wonders about non idle wondering
13:56:52 <vixey> I only know English.. and not very well either :/
13:56:58 <monochrom> Chinese is character-based, while English (for example) is alphabetic. There are actually people who are dylexic in one form but not the other.
13:57:28 <sauxdado> vixey: they're both pretty tricky. Chinese might actually be easier if you're good at remembering both the character and its pronunciation.
13:58:05 * kiris subtly plugs lojban
13:58:23 <DRMacIver> Yes. Then you and the other four lojban speakers can have secret conversations. :)
13:59:28 <sauxdado> lojban would be harder than either.
13:59:40 <vixey> Oh I wasn't hoping to learn a language to actually talk to people with :)
13:59:43 <sauxdado> mostly because you can't "immerse yourself in the culture" which is an important part of learning any language.
13:59:56 <sauxdado> since there practically is no culture. There's a few texts.
14:00:22 <sauxdado> also because lojban is so weird and alien but that's actually a comparatively minor issue.
14:01:43 <edwardk> drmaciver: i'd learn lojban, if it was useful for something other than talking to the kind of people who learn lojban ;)
14:02:00 <DRMacIver> That would be why I didn't learn lojban. :)
14:02:04 <DRMacIver> (I briefly looked into it a while ago)
14:02:24 * sauxdado decides he might as well plug Esperanto
14:02:46 <edwardk> yeah same here, i picked up the idea of the surface syntax, said, wow, neat, a lingua franca balanced for a power-balance in the world that doesn't exist and whih annoys everyone equally, and left =)
14:03:11 <DRMacIver> sauxdado: The funniest thing about Harry Harrison novels is that it's the future and everyone speaks Esperanto. :)
14:03:17 <kiris> edwardk: interesting statement.
14:03:36 <sauxdado> (i started learning esperanto 3 days ago and can already more or less chat in it with a dictionary. It really is simpler than natural languages. It's pretty cool)
14:03:39 <maltem> hu? Temas pri Esperanto hodiaÅ­? :-)
14:03:44 <DRMacIver> edwardk: Sounds about right. :)
14:03:54 <DRMacIver> edwardk: Incidentally, your recent blog posts are deeply scary.
14:04:01 <edwardk> dr: ?
14:04:29 <DRMacIver> Or have I got you confused with a different edward k?
14:04:35 <edwardk> thats me
14:04:57 <edwardk> i wound up on an interesting tangent. lots of neat stuff to put together there
14:05:05 <sauxdado> maltem: kial vi ne estas en ##esperanto? venu :)
14:05:09 <DRMacIver> Just commenting. :) They seem to have the effect of making me go "Hmm. That looks neat" and then my head explodes.
14:05:34 <edwardk> currently trying to figure out more comonads to mix in on the anamorphism side which is why i started building a comonad transformer library
14:05:44 <edwardk> er s/ana/cata
14:06:22 <DRMacIver> At the risk of sounding like a Java programmer, do you have any particular use cases for this stuff?
14:06:25 <dons> http://reddit.com/info/6hknz/comments is nice
14:06:32 <edwardk> the ana side is kinda boring, the free monad and Either pretty much cover all the good cases over there
14:07:00 <edwardk> dr: actually i was planning on collecting a small 'cofib' suite of examples to help get people used to the ideas
14:07:50 <edwardk> also i have a zipper comonad i've been playing with  that can be used for nice cellular automata-like things
14:08:23 * monochrom joins medical research and writes paper "we can predict head explosion six seconds before. our test subject, DRMacIver's brain, consistently goes into 'hmm it's nice' state and such-and-such area becomes active six seconds before explosion."
14:08:23 <DRMacIver> That would be good. I'm rather weak on anything past the basics (monads, folds, unfolds, etc) and I suspect part of that is that I haven't got a sense of what on earth most of it is for.
14:09:20 <edwardk> dr: actually if you look at the more advanced morphisms they all do one extra thing or provide one extra bit of functionality, so lets pick one. say, a 'apomorphism'
14:09:21 <byorgey> monochrom: I believe the correct medical term you should use is 'asplosion'.
14:09:29 <DRMacIver> monochrom: Neat is not the same as nice. :)
14:09:34 <byorgey> 'explosion' is just used informally
14:09:57 <edwardk> normally an anamorphism lets you take a function like (a -> f a) and use it to generate an infinitely big sequence of nested f's right? call that Nu f.
14:10:14 <DRMacIver> an anamorphism is an unfold, right?
14:10:27 <monochrom> (Nu suggests greatest fixed point)
14:10:27 <Heffalump> yes
14:10:33 <DRMacIver> (I have trouble keeping track of all the different morphisms)
14:10:34 <DRMacIver> ok
14:10:43 <dibblego> a generalised unfold
14:10:54 <edwardk> an apomorphism lets you take a function from (a -> f (Either (Nu f) a) and generate an infinitely big sequence of nested f's. the trick is that at any point you can give the 'whole tail' instead of another seed.
14:11:44 <sauxdado> DRMacIver: what language you think they'll speak in the future?
14:11:46 <edwardk> so if you give an apomorphism to generate a list, you can eventually 'get out of the way' and hand over another list you had lying around. like if i consed 3 elements onto an infinite list. i don't want the noose of the unfold hanging around my neck forever
14:11:47 <monochrom> King Henry had a crush on two girls. One was Anna Morphism and the other was Katarina Morphism.
14:12:42 <edwardk> the other morphisms all add one tiny bit of functionality here or there like that
14:12:42 <sauxdado> DRMacIver: all bets are off really, although it's pretty safe to say it won't be esperanto. But the importance of english is unlikely to be "eternal"
14:14:02 <byorgey> monochrom: and...?
14:14:27 <byorgey> monochrom: I thought you were going to tell a little moralistic fairy tale to help us remember which is which
14:14:43 <sauxdado> hopefully a really dirty one
14:14:48 <monochrom> I'm still trying to make it up. :)
14:14:56 <edwardk> histo lets you look at earlier results to build your answer, futu lets you return more than one level of your functor at a time.
14:15:08 <byorgey> monochrom: hehe =)
14:15:25 <monochrom> Something about Anna keeps talking non-stop? :)
14:15:25 <byorgey> sauxdado: no, dirty moralistic fairy tales go in #haskell-blah =)
14:16:00 <byorgey> yes, and Katarina likes summarizing things
14:16:03 <edwardk> para makes it easy to write 'factorial' in a natural way because its as strong as primitive recursion.
14:16:28 <dibblego> paramorphism is catamorphism with an extra argument in the passed function iirc
14:16:30 <DRMacIver> edwardk: ok. I think I see.
14:16:31 <byorgey> so one day their brother Hilo has the brilliant idea to make Katarina summarize whatever Anna says
14:16:37 <dibblego> ?type foldr
14:16:39 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:16:40 <ddvlad|> hi everyone, i'm missing something here, aren't i: http://hpaste.org/7265 ?
14:16:52 <DRMacIver> edwardk: I was having trouble parsing what you meant, but it seems to make sense. :)
14:16:56 <dibblego> paramorphism :: forall a b. (a -> [a] -> b -> b) -> b -> [a] -> b -- I think?
14:17:31 <edwardk> para works up from the leaves of your functor, but instead of just giving you the functor wrapped around the folded answer it also gives you a copy of the folded up data structure that it worked on so you can do whatever you need to do to it
14:17:35 * kiris figured out towers of hanoi with a bowl of oranges. stacking oranges is tricky business
14:18:00 <monochrom> stacking bowls is easier
14:18:20 <kiris> I tell a lie, it was nectarines
14:18:22 <byorgey> ddvlad|: isn't port 22 SSH?
14:18:36 <Zao> byorgey: Generally, yes.
14:18:45 <byorgey> why would Google let you ssh to google.com?
14:18:50 <ddvlad|> byorgey: sorry, it got changed stupidly. I've tried 80 first, and it still does not work
14:18:56 <byorgey> oh, ok =)
14:18:59 <edwardk> so if i have a tree functor, then para takes a function from (f (Nu f, a) -> a) so to generate the answer for each node that will be given to the node above you you have access to the the structure of all your children (the Nu f term) and you have access to all of the answers your DIRECT descendants gave
14:19:41 <ddvlad|> varying hosts and ports obviously didn't help :-(
14:20:42 <Saizan_> edwardk: it's funny that in the stdlib [] is the functor, while when talking about morphisms it's 1+(,)a
14:21:13 <sclv_> ?remember sven dumschingbadumschingsching r versatz = interleave r versatz (dumdideldum moll_akkord) (Trans 3 (dumdideldum dur_akkord))
14:21:14 <lambdabot> Okay.
14:21:21 <dons> hehe
14:21:35 <Zao> Amusingly enough, showing the hostEntry on windows results in a non-exhaustive match for Family here.
14:22:03 <kiris> i read that as rumplestiltskin
14:22:21 <ddvlad|> Zao: I get AF_INET on linux
14:24:13 <Zao> This is a nightly GHC build though, so it may be broken.
14:25:41 <Bonus> is it possible to use let with guards
14:26:31 <edwardk> saizan: yeah
14:26:39 <Saizan_> > let foo | True = 1 | False = 2 in foo
14:26:41 <lambdabot>  1
14:26:58 <Bonus> i meant like
14:27:09 <edwardk> saizan: i'll admit the foo-morphisms kinda suck in a language with types. works very nicely in my toy project without them. no InF/outF noise ;)
14:27:12 <Zao> ddvlad|: Try 0x5000 as port.
14:27:12 <Bonus> let foo = 5 in | True = 1 | False = 2
14:27:15 <Bonus> si that possible
14:27:20 <Zao> ddvlad|: You seem to have your endian wrong.
14:28:04 <edwardk> there i can reuse the (:) constructor for both the folded and unfolded version of the functor
14:28:09 <Saizan_> edwardk: isn't it a pain to compose those combinators correctly without types?
14:28:11 <byorgey> > let foo = 5 in case () of _ | True = 1 | False = 2
14:28:11 <lambdabot>  Parse error at "=" (column 36)
14:28:19 <edwardk> i get buried in other issues, but those parts clean up nicely =)
14:28:37 <byorgey> Bonus: there's some way to do it...
14:28:42 <edwardk> actually the nice part is all my monads share a ton of code
14:28:51 <Bonus> hmm
14:29:22 <edwardk> the downside is to get overloading i have to be careful that functions that can mean different things in different contexts get constructed as constructors not functions
14:29:22 <Botje> > foldl1 f [1..3]
14:29:23 <lambdabot>  Add a type signature
14:29:30 <Botje> > foldl1 f [1..3] :: [Expr]
14:29:31 <lambdabot>   add an instance declaration for (Num [Expr])
14:29:31 <lambdabot>     In the expression: 1
14:29:40 <Botje> > foldl1 f [a,b,c] :: [Expr]
14:29:41 <lambdabot>  Couldn't match expected type `[Expr]' against inferred type `Expr'
14:29:43 <edwardk> so in there + * / , ; >>= Return are all constructors not functions
14:29:44 <Botje> gah
14:29:44 <Zao> ddvlad|: http://www.nabble.com/Network.Socket-Woes-td15899916.html
14:29:46 <Botje> > foldl1 f [a,b,c]
14:29:46 <lambdabot> Title: Nabble - Haskell - Haskell-Cafe - Network.Socket Woes
14:29:47 <lambdabot>  f (f a b) c
14:29:53 <ddvlad|> Zao: it worked. Thank you for your time. I'll go read up on some endianness issues.
14:30:15 <edwardk> then when you use a 'view' function to get the right interpretation of that free magma THEN you know what it meant =)
14:30:18 <ddvlad|> A Haskell mail client stub might still be doable for homework :-)
14:30:18 <Zao> ddvlad|: Use the PortNumber constructor instead.
14:30:29 <byorgey> > let foo = 5; x | True = 1 | False = 2 in x  -- Bonus, how about this?
14:30:30 <lambdabot>  1
14:30:52 <yitz> > let foo = 5 in case () of _ | True -> 1 | False -> 2
14:30:54 <lambdabot>  1
14:30:55 <Zao> ddvlad|: PortNum does not do the endianess conversion. PortNumber does.
14:30:57 <edwardk> saizan: but yes, i typically work in haskell then type the result in after replacing the InF/outF placeholders with id =)
14:31:10 <byorgey> Bonus: otherwise I don't understand exactly what you want to do.
14:31:16 <ddvlad|> Zao: thanks, that's a new thing I learnt today :-)
14:32:35 <Saizan_> edwardk: so you have an eval function at runtime to resolve overloading?
14:32:49 <edwardk> otoh: without types i get a lot of options, like you can use * for >>= if you REALLY want to since its the multiplicative structure of the monad. + for mplus, Nil can be used as False, Nil, Nothing ...
14:33:23 <edwardk> saizan: yeah, so in a pattern foo (Bar : baz) is just sugar to say call the baz function on this argument and then pattern match
14:33:34 <Zao> Bug reporting time.
14:34:20 <edwardk> saizan: and to allow you to overload them to 'return' functions you can define things like (f & g) a = (f a, g a) where & is a constructor of arity 2 'overapplied'
14:34:32 <Bonus> byorgey i meant something like this http://hpaste.org/7267
14:34:33 <loupgaroublond> when i use ghc --make on a file, it seems to compile fine, but i get no executable, and when i try to run it with just 'ghc foo.hs' i get a bunch of random linking errors
14:35:02 <loupgaroublond> the paste is here: http://hpaste.org/7266
14:35:05 <edwardk> saizan: its kinda cute in a zen like way
14:35:06 <byorgey> loupgaroublond: you probably need to use -main-is if your file does not contain a module named Main
14:35:21 <loupgaroublond> byorgey, it's got a main
14:35:21 <edwardk> saizan: no type system, so i can do all the 'subtyping' i ever could want.
14:35:39 <byorgey> loupgaroublond: yes, but the name of the module is not Main
14:35:53 <byorgey> loupgaroublond: which is why no executable is produced.
14:35:56 <Saizan_> edwardk: i don't really get how it works from those examples, but looks interesting :)
14:35:59 <loupgaroublond> byorgey, ah
14:36:05 * loupgaroublond is rusty...
14:36:15 <byorgey> loupgaroublond: so just compile with --make -main-is Foo
14:36:27 <edwardk> saizan: i think i pasted a small fragment of my prelude into @hpaste a few days back, checking
14:36:28 <edwardk> @hpaste
14:36:29 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:36:48 <loupgaroublond> byorgey, it's just some code that has to run in a monad, that i need to test, anyways
14:37:04 <loupgaroublond> i can rename the module
14:37:05 <pavizard> When I use unwords I get a "pop" in the end, any idea how I can avoid that?
14:37:07 <loupgaroublond> but thanks
14:37:19 <edwardk> saizan: http://www.hpaste.org/7182
14:37:36 <edwardk> you can tell the obvious morphism-bent of the prelude coz i was on a kick that day ;)
14:38:01 <edwardk> 'boolean' is a view function, it takes some mess of constructors and tries to give you back a True constructor or a False constructor
14:38:27 <byorgey> Bonus: http://hpaste.org/7267#a1
14:38:42 <edwardk> since & | and Not are functors i can define it using 'cata' which automatically works over the free monad product of all of the functors given because map just recurses and works on the new constructor it sees
14:38:45 <byorgey> Bonus: I don't think you can do what you pasted there, but I posted two alternate approaches which have the same result
14:38:59 <Bonus> aha i see
14:39:02 <Bonus> byorgey thanks! :)
14:39:13 <edwardk> hence i use an initial-algebra (a boolean-algebra natch!) to decompose booleans
14:39:16 <byorgey> Bonus: sure =)
14:39:37 <Bonus> won't it compute it twice though
14:39:40 <Bonus> with the where
14:39:48 <byorgey> Bonus: compute what twice?
14:39:50 <Bonus> uuh
14:39:52 <Bonus> the split
14:40:02 <byorgey> Bonus: no
14:40:19 <byorgey> one name, one evaluation.  that's graph reduction for you =)
14:40:26 <Bonus> haha oh i see
14:40:29 <Bonus> what if we did
14:40:37 <Bonus> where fs = splitAt x
14:40:47 <Bonus> and then called (fs x) in our function
14:41:01 <Bonus> i mean (fs xs)
14:41:23 <byorgey> yes, then it would probably be computed twice
14:41:28 <Bonus> aha i get it
14:41:29 <Bonus> cool
14:41:34 <Elly> is there a haskell implementation that is more experimentation-friendly than ghc? (I'm specifically looking for a REPL in the style of mzscheme or smlnj)
14:41:51 <opqdonut> happy?
14:41:52 <vixey> Elly: What is that?
14:41:56 <opqdonut> was nhc supposed to be simple
14:42:00 <Elly> vixey: read-eval-print loop
14:42:19 <vixey> I mean what is it specifically about mzscheme/smlnj
14:42:22 <Elly> happy describes itself as a parser generator
14:42:27 <Elly> vixey: oh, just that they have a REPL at all
14:42:30 <loupgaroublond> how come cabal reports a cabal file as having no libraries, when it has both libraries and executables?
14:42:32 <Elly> ghc doesn't seem to and I want one
14:42:38 <vixey> ghci has one
14:42:40 <quicksilver> Elly: ghci ?
14:42:44 <vixey> ghci is very good
14:42:44 <byorgey> Elly: it does! it is called ghci =)
14:42:49 <Elly> aha!
14:42:50 <Elly> thanks :)
14:42:51 <quicksilver> Elly: it's not perfect but it's the best REPL haskell has.
14:43:09 <quicksilver> you can't interactively define new types.
14:43:17 <quicksilver> but you can do functions and values
14:43:19 <Elly> :(
14:43:24 <quicksilver> and you can always stick a type in a small file
14:43:27 <quicksilver> and load it into the repl
14:43:28 <Elly> I like smlnj's repl
14:43:32 <quicksilver> so it's not really a big deal.
14:45:13 <ddvlad|> is there by any chance a pop3 or imap library that i couldn't find via google?
14:45:27 <vixey> I like SLIME :P
14:45:33 <vixey> It's the best REPL in the world
14:46:10 <Elly> I must not be using ghci right
14:46:29 <czakey> i wonder how to write a spellchecker module for lambdabot
14:46:42 <Elly> I tried an example from "A Gentle Introduction to Haskell", namely "take 0 _ = []"
14:46:43 <czakey> using  /usr/share/dict/words
14:46:48 <Elly> and it said "parse error on input '='"
14:46:52 <vixey> let take 0 _ = []
14:46:56 <vixey> write that instead
14:47:00 <Elly> aha!
14:47:07 <vixey> you wouldn't use the let in a .hs file though
14:47:08 <Elly> is there a reason ghci says 'Prelude>' as a prompt?
14:47:19 <vixey> Prelude is the module[s] you're in
14:47:21 <czakey> any suggestions on wrting it?
14:47:24 <Elly> ah, okay
14:47:29 <vixey> you can go :m + <other module> to load more
14:47:47 <Vq^> Elly: you could write it in a file instead, it would probably be simpler
14:47:56 <vixey> by the way, what I normally do is have an editor open, say with foo.hs, and then :load foo every so often whin I make changes
14:48:06 <Bonus> yeah me too
14:48:08 <vixey> then you can query it, try out function calls etc
14:48:10 <Bonus> i write functions in an editor
14:48:14 <Bonus> then i play around with them
14:48:15 <Elly> If I do that I need to figure out how to write a main function :(
14:48:17 <Bonus> then i go back to writing them
14:48:21 <vixey> Elly, no you don't :P
14:48:24 <Bonus> nope, try it
14:48:40 <Elly> aha!
14:48:41 <vixey> Elly, just stick take 0 _ = [] in a .hs file (hm.. take already exists, maybe use a different name?)
14:48:42 <Elly> it works :)
14:48:54 <Elly> thank you guys
14:49:02 <Vulpyne> Given a list of Eithers, what's the best way to call one function on a list of the Lefts and another on the list of Rights?
14:49:24 <vixey> @hoogle [Either a b] -> ([a],[b])
14:49:24 <Vq^> Vulpyne: +++
14:49:25 <lambdabot> No matches, try a more general search
14:49:41 <byorgey> @type (+++)
14:49:42 <lambdabot> Not in scope: `+++'
14:49:49 <byorgey> lies!
14:49:49 <Vulpyne> Hmmm.
14:50:05 <Vulpyne> I was already doing nasty stuff with ***. :)
14:50:19 <Bonus> you mean like if you have a list of [Left 2, Right 'a', Left 5, Right 'b']
14:50:23 <Vq^> > map ((+1) +++ (+10)) [Left 10, Right 10]
14:50:25 <lambdabot>  [Left 11,Right 20]
14:50:25 <Bonus> and you want to map f to the lefts
14:50:27 <Vulpyne> Bonus: Correct.
14:50:28 <Bonus> and g to the rights
14:50:36 <Bonus> hmm
14:50:44 <Vulpyne> let (!parsed,!failed) = (map (\(Right i) -> i) *** (map (\(Left i) -> i))) (partition (either (const False) (const True)) (map parsePacket ps))
14:50:49 <Vulpyne> That's what I was doing now, when trying to be tricky.
14:51:09 <Bonus> yeah how about you make a function that pattern matches with Right and Left
14:51:11 <Bonus> and then map it
14:51:23 <vixey> > let sift [] = ([],[]) ; sift (Right x:es) = case sift es of (l,r) -> (x:l,r) ; (Left x:es) = case sift es of (l,r) -> (l,x:r) in sift [Left 2, Right 'a', Left 5, Right 'b']
14:51:24 <lambdabot>  Parse error at "=" (column 92)
14:51:29 <byorgey> Vulpyne: as Vq^ showed above, +++ does exactly what you want.
14:51:47 <byorgey> no need for complicated trickery!
14:51:50 <vixey> > let sift [] = ([],[]) ; sift (Right x:es) = case sift es of (l,r) -> (x:l,r) ; sift (Left x:es) = case sift es of (l,r) -> (l,x:r) in sift [Left 2, Right 'a', Left 5, Right 'b']
14:51:51 <lambdabot>  Parse error in pattern at "=" (column 97)
14:51:54 <Vulpyne> Ahh, I missed that.
14:51:57 <Vulpyne> Vq^: Thanks.
14:53:22 <vixey> > let sift [] = ([],[]) ; sift (Left x:es) = first (x:) $ sift es ; sift (Right x:es) = second (x:) $ sift es in sift [Left 2, Right 'a', Left 5, Right 'b']
14:53:23 <lambdabot>  ([2,5],"ab")
14:53:30 <byorgey> if f and g are arrows, f +++ g represents a sort of 'multiplexed' channel where inputs are tagged to show which data stream they belong to, and f is used to process one stream, and g the other
14:54:41 <Elly> hmm
14:55:03 <Elly> so I have declared a function 'nth' which gets the nth element of a list, which I believe to be correct (it's syntactically correct and looks the same as it does in SML)
14:55:18 <Elly> but when I do: nth 3 [1, 2, 3, 4, 5], haskell says "No instance for (Num [a])"
14:55:22 <Elly> (ghci, rather)
14:55:41 <opqdonut> are you passing the args in the correct order?-)
14:55:43 <byorgey> Elly: if you get the type of nth  (enter ':type nth' at the prompt) what does it say?
14:55:55 <Elly> *Main> :type nth
14:55:55 <Elly> nth :: (Num t) => t -> [[a]] -> [a]
14:56:08 <opqdonut> heh
14:56:11 <Elly> oh, oops!
14:56:20 <Vq^> :)
14:56:21 <opqdonut> that looks a tad too specific
14:56:27 <Elly> I think I want t -> [a] -> a
14:56:33 <opqdonut> always give your functions explicit types
14:56:33 <byorgey> right
14:56:34 <Elly> if those mean the same thing they do in SML
14:56:39 <ddarius> :t (!!)
14:56:39 <opqdonut> provides an additional sanity check
14:56:41 <lambdabot> forall a. [a] -> Int -> a
14:56:46 <byorgey> Elly: right, your function only works on lists of lists.
14:56:56 <Elly> oh
14:57:00 <Elly> returning [] is probably not right
14:57:19 <Elly> it doesn't like nil, though
14:57:23 <Vq^> it could be
14:57:36 <byorgey> Elly: yeah, if you return [], then your function must always return a list
14:57:36 <opqdonut> Elly: how about Maybe?
14:57:46 <nejucomo> After reading the library docs for System.Process it seems like I need to pass handles to runProcess.  How do I create "pipes" so that I can read and write to the subprocess?
14:57:46 <Elly> I have that as my 'out of list' case: nth 0 _ = []
14:58:33 <Vq^> Elly: that sounds right, but as opqdonut said Maybe might be more fitting
14:59:02 <byorgey> returning [] in that case only makes sense if you want your function to return lists as its output
14:59:04 <Vulpyne> Ahh, actually, that wasn't what I needed.
14:59:25 <byorgey> Elly: nth 0 represents a sort of 'error case', right?
14:59:28 <Elly> how would one do it with maybe
14:59:30 <Elly> byorgey: yep
14:59:33 <nejucomo> The only way I've found for creating handles is System.IO's openFile.
14:59:37 <byorgey> @src Maybe
14:59:37 <lambdabot> data Maybe a = Nothing | Just a
14:59:38 <Elly> I really wanted 'raise Subscript'
14:59:41 <Vulpyne> map ((+1) +++ (+10)) [Left 10, Right 10] actually applies each function once per item. What I need is for each function to be called with a list of all the rights, and all the lefts.
14:59:44 <pavizard> I've got a little problem with unwords, and unlines, please take a look, thanks http://hpaste.org/7268
14:59:44 <Elly> but I have no idea what that looks like in haskell
15:00:07 <byorgey> Elly: if a is a type, Maybe a is a type which might be a value of type a (Just a) or it might be Nothing.
15:00:19 <byorgey> > [ Just 3, Just 4, Nothing ] :: Maybe Int
15:00:19 <lambdabot>  Couldn't match expected type `Maybe Int'
15:00:20 <Elly> in SML that is Option :)
15:00:29 <byorgey> > [ Just 3, Just 4, Nothing ] :: [Maybe Int]
15:00:30 <lambdabot>  [Just 3,Just 4,Nothing]
15:00:33 <byorgey> Elly: ah, yes it is =)
15:00:52 <byorgey> Elly: so you could make your function be of type Int -> [a] -> Maybe a
15:00:53 <Vq^> > let nth _ [] = []; nth 0 (x:_) = [x]; nth n (_:xs) = nth (pred n) xs in nth 2 [1,2,3]
15:00:54 <lambdabot>  [3]
15:00:56 <Vq^> > let nth _ [] = []; nth 0 (x:_) = [x]; nth n (_:xs) = nth (pred n) xs in nth 2 [1,2]
15:00:58 <lambdabot>  []
15:00:58 <Elly> w00t :)
15:01:15 <Vq^> Elly: something like that?
15:01:21 <Vulpyne> I guess there isn't an idiomatic way.
15:01:22 <nejucomo> Does anyone have experience with reading/writing to subprocesses?
15:01:35 <pavizard> Reagrding the pop , here http://hpaste.org/7268 i found what was wrong, what about the other characters appearing? thanks
15:01:36 <Elly> mine looks like: nth 0 (x : xs) = Just x ; nth 0 _ = Nothing ; nth n (x : xs) = nth (n - 1) xs
15:01:38 <byorgey> Vulpyne: ah, you want something like partitionEithers
15:01:45 * Elly will be back later
15:01:50 <byorgey> Vulpyne: I don't know if that ever actually got added to the standard libraries
15:01:55 <Vulpyne> byorgey: Yep, something that'll partition and strip off the type constructor.
15:01:59 <byorgey> Elly: looks good!
15:02:41 <Vulpyne> I felt like I was somewhat on the right track with the arrow stuff, but there were complications, especially since both of the functions to be called are IO.
15:02:48 <byorgey> Vulpyne: yeah, people have wanted this before, and there were various proposals that languished due to disagreements over the best names for these combinators
15:03:01 <Vulpyne> I see.
15:03:03 <Vulpyne> Well, thanks.
15:03:14 <byorgey> but I think perhaps they are actually in the HEAD version of the libraries now, I'm not 100% sure
15:03:16 <Vulpyne> I guess I will have to be satisfied with it ot being pretty.
15:03:21 <Vulpyne> not being pretty, that is.
15:03:24 <byorgey> although in either case that doesn't help you much right now =)
15:03:25 <byorgey> yeah
15:03:36 <Vulpyne> It works fine the way I was doing it, it's just ugly. :)
15:03:45 <Vq^> it shouldn't be hard to write partitionEithers
15:04:56 <Vulpyne> Maybe I'll do that just for fun.
15:05:13 <ptolomy2> j/quit
15:05:36 <Vq^> partitionEithers :: [Either a b] -> ([a], [b])
15:05:55 <vixey> let partitionEithers = sift
15:05:57 <vixey> :P
15:05:59 <vixey> @src partitionEithers
15:05:59 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
15:06:02 <vixey> oh
15:06:42 <vixey> how can it be written using list comprehensions?
15:07:15 <vixey> > let sift xs = [ (l,r) | Left l <- xs ; Right r <- xs ] in sift [Left 'x',Right 3,Left 'y',Right 5]
15:07:15 <lambdabot>  Parse error at ";" (column 38)
15:07:20 <vixey> > let sift xs = [ (l,r) | Left l <- xs , Right r <- xs ] in sift [Left 'x',Right 3,Left 'y',Right 5]
15:07:21 <lambdabot>  [('x',3),('x',5),('y',3),('y',5)]
15:07:51 <Vulpyne> partitionEithers l = ([x | Left x <- l],[x | Right x <- l]) is the naive way.
15:07:58 <vixey> > let sift xs = ([ l | Left l <- xs],[ r | Right r <- xs]) in sift [Left 'x',Right 3,Left 'y',Right 5]
15:07:59 <lambdabot>  ("xy",[3,5])
15:08:17 <vixey> > let sift xs=([l|Leftl<-xs],[r|Rightr<-xs]) in sift [Left 'x',Right 3,Left 'y',Right 5]
15:08:17 <lambdabot>   Not in scope: data constructor `Rightr'
15:08:24 <vixey> > let sift xs=([l|Left l<-xs],[r|Right r<-xs]) in sift [Left 'x',Right 3,Left 'y',Right 5]
15:08:25 <lambdabot>  ("xy",[3,5])
15:08:26 <Vulpyne> I'd like to do it without walking the list tiwce, though.
15:08:30 <nejucomo> Are there "pipes" or "in-memory handles" in the stdlib?
15:08:33 <vixey> > let sift [] = ([],[]) ; sift (Left x:es) = first (x:) $ sift es ; sift (Right x:es) = second (x:) $ sift es in sift [Left 2, Right 'a', Left 5, Right 'b']
15:08:34 <lambdabot>  ([2,5],"ab")
15:08:40 <vixey> that traverses once
15:09:08 <Vulpyne> ([l|Left l<-xs],[r|Right r<-xs]) traverses once?
15:09:24 <Vulpyne> Because the compiler is smart enough to fuse it?
15:09:40 <Saizan_> ?type foldr (either (first . (:)) (second . (:))) []
15:09:42 <lambdabot> Not in scope: `first'
15:09:42 <lambdabot> Not in scope: `second'
15:09:45 <vixey> > let f (Left x) = first(x:) ; f (Right y) = second(y:) in (fold \x ys->f x ys) ([],[]) [Left 2, Right 'a', Left 5, Right 'b']
15:09:45 <lambdabot>  Parse error at "\x" (column 64)
15:09:59 <Saizan_> ?type foldr (either (Control.Arrow.first . (:)) (Control.Arrow.second . (:))) []
15:10:00 <lambdabot>     Couldn't match expected type `([a], [b])'
15:10:01 <lambdabot>            against inferred type `[a1]'
15:10:01 <lambdabot>     In the second argument of `foldr', namely `[]'
15:10:02 <vixey> > let f (Left x) = first(x:) ; f (Right y) = second(y:) in fold (\x ys->f x ys) ([],[]) [Left 2, Right 'a', Left 5, Right 'b']
15:10:03 <lambdabot>   Not in scope: `fold'
15:10:07 <vixey> > let f (Left x) = first(x:) ; f (Right y) = second(y:) in foldr (\x ys->f x ys) ([],[]) [Left 2, Right 'a', Left 5, Right 'b']
15:10:08 <lambdabot>  ([2,5],"ab")
15:10:35 <vixey> f (Left x)=first(x:) ; f (Right y)=second(y:) <- how else can this be written?
15:10:36 <vixey> :t either
15:10:38 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
15:10:56 <vixey> @pl \x -> f (x:)
15:10:56 <lambdabot> f . (:)
15:11:30 <vixey> > foldr (first.(:)`either`second.(:)) ([],[]) [Left 2, Right 'a', Left 5, Right 'b']
15:11:31 <lambdabot>      precedence parsing error
15:11:31 <lambdabot>         cannot mix `either' [infixl 9] and `(.)...
15:11:44 <vixey> > foldr (either(first.(:))(second.(:))) ([],[]) [Left 2, Right 'a', Left 5, Right 'b']
15:11:45 <lambdabot>  ([2,5],"ab")
15:12:11 <Vulpyne> Sweet.
15:12:28 <Vulpyne> Interesting.
15:12:53 <Vulpyne> I should get more familiarity with foldr.
15:13:21 <Saizan_> @tell Cale lambdabot should have Control.Arrow imported for @type, i think
15:13:21 <lambdabot> Consider it noted.
15:13:44 <vixey> Vulpyne: I think of it like this, a list is a:(b:(c:(d:[])))
15:13:58 <dons> :t (***)
15:14:00 <nejucomo> Is there a way to get a string representation of some identifier for any value?
15:14:00 <lambdabot> Not in scope: `***'
15:14:01 <dons> oh huh
15:14:07 <nejucomo> (Even non-instances of Show?)
15:14:10 <vixey> Vulpyne: foldr f z [a,b,c,d] = (f a (f b (f c (f d z))))
15:14:15 <dons> nejucomo: not of variable names.
15:14:15 <vixey> > foldr f z [a,b,c,d]
15:14:16 <lambdabot>  f a (f b (f c (f d z)))
15:14:22 <dons> you can for data (and constructors)
15:14:35 <vixey> Vulpyne: so it replaced the lists cons (:) and nil [], with your own functions/values
15:14:37 <Vulpyne> vixey: Yeah, I know the basics, I just haven't used it enough for it to come to mind when thinking of solutions. :)
15:14:38 <Cale> Saizan_: It doesn't?
15:14:38 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
15:14:39 <dons> nejucomo: sometimes people play games like this with template haskell
15:14:50 <Saizan_> @type (***) -- Cale
15:14:52 <lambdabot> Not in scope: `***'
15:14:54 <Cale> huh...
15:14:56 <nejucomo> templates?!  Yikes.
15:15:22 <vixey> Vulpyne: and another useful thing to think about if it's transforming the list, for f = (\x ys -> ...) is that x is an element of the list, and ys is the rest of the processed list
15:15:40 <vixey> but I don't really have any good model to think about the crazy stuff ski was doing :)
15:16:02 <nejucomo> There's no way to print say, the address, of a given value?
15:16:43 <vixey> foldr (:) [] = id
15:17:04 <Cale> Would people mind if I @undef for a moment?
15:17:17 <Vulpyne> Interesting.
15:17:19 <Vulpyne> vixey: Thanks.
15:17:48 <Cale> @undef
15:17:49 <lambdabot> Undefined.
15:17:59 <vixey> foldr (\x ys -> ys ++ [x]) [] = reverse
15:18:29 <Cale> :t (***)
15:18:30 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
15:18:32 <Cale> aha
15:18:56 <Cale> Something someone had defined was preventing ghci from importing L.hs (since it wouldn't load)
15:19:04 <Cale> which is why Control.Arrow wasn't being imported.
15:19:17 <luqui> I have a question about sharing: http://hpaste.org/7271
15:19:18 <dons> ah
15:19:28 <Saizan_> how is Control.Arrow imported for @run then? it was working
15:20:01 <Saizan_> mmh, maybe not
15:20:58 <Saizan_> well vixey was using first and second
15:21:41 <Cale> Well, I don't know.
15:21:44 <vixey> oh sorry
15:21:51 <vixey> I didn't mean to break things
15:21:58 <Cale> On code.haskell.org, I couldn't get L.hs to load in GHCi.
15:22:06 <Cale> (there was a type error)
15:22:28 <Cale> It's okay, no harm done :)
15:22:47 <Vulpyne> Next dumb question: (putStrLn *** putStrLn) ("1","2") :: (IO (), IO ())
15:22:53 <Vulpyne> *** doesn't seem too happy about IO functions.
15:23:35 <Vulpyne> Actually, it's not really a question, but it looks quite odd. :)
15:23:42 <Saizan_> it gets messy because you've to use the Kleisli (?) newtype wrapper
15:23:45 <Cale> Uh, what's wrong with that?
15:23:58 <Saizan_> if you want IO ((),())
15:24:09 <Vulpyne> That's somewhat more what I was expecting.
15:24:18 <Bonus> is there such a function already in the standard library which turns [x] into Just x and [] into Nothing
15:24:42 <bos> listToMaybe
15:24:46 <Saizan_> > listToMaybe [1,2]
15:24:48 <lambdabot>  Just 1
15:24:49 <Cale> Oh, you'd have to liftM2 (,)
15:24:51 <Bonus> kewl
15:24:52 <bos> @hoogle [a] -> Maybe a
15:24:53 <lambdabot> Data.Maybe.listToMaybe :: [a] -> Maybe a
15:24:53 <lambdabot> Data.List.find :: (a -> Bool) -> [a] -> Maybe a
15:24:54 <Bonus> thanks guys
15:24:57 <sauxdado> @src listToMaybe
15:24:57 <lambdabot> listToMaybe []        =  Nothing
15:24:58 <Cale> :t liftM2 (,) putStrLn putStrLn
15:24:58 <lambdabot> listToMaybe (a:_)     =  Just a
15:24:59 <lambdabot> String -> (IO (), IO ())
15:25:02 <Cale> er...
15:25:12 <Cale> ... right.
15:25:28 <sauxdado> listToMaybe is something very simple involving a comonad, is it not?
15:25:35 <Cale> :t liftM2 (,) (putStrLn "x") (putStrLn "y")
15:25:36 <lambdabot> IO ((), ())
15:25:39 <vixey> @src listToMaybe
15:25:39 <lambdabot> listToMaybe []        =  Nothing
15:25:39 <lambdabot> listToMaybe (a:_)     =  Just a
15:25:41 <Saizan_> you'd need like bisequence for (,) :)
15:25:50 <Vulpyne> cale: Well, what I have is a ([a],[b]) and I want to call a different IO function on each one.
15:26:00 <sauxdado> > coeval [1]
15:26:01 <lambdabot>   Not in scope: `coeval'
15:26:51 <Vulpyne> I'm mostly just screwing out, since it's pretty obvious I could just use fst and snd. :)
15:26:55 <bos> sauxdado: there's no standard library for comonadic programming
15:26:57 <Vulpyne> Screwing around.
15:26:58 <Saizan_> ?ty (Kleisli putStrLn *** Kleisli putStrLn) ("1","2")
15:26:59 <lambdabot>     Couldn't match expected type `t1 -> t'
15:27:00 <lambdabot>            against inferred type `Kleisli IO (String, String) ((), ())'
15:27:15 <Saizan_> ?ty runKleisli (Kleisli putStrLn *** Kleisli putStrLn) ("1","2")
15:27:17 <lambdabot> IO ((), ())
15:27:19 <sauxdado> boo :(
15:27:40 <mib_nuno> hello
15:27:46 <Cale> That's still the Kleisli arrow for ((->) e)
15:27:59 <Cale> putStrLn is not an IO action
15:28:03 <Cale> It's a function.
15:28:25 <mib_nuno> Does anyone kow what the state of Haskell interop with .NET is?
15:28:40 <bos> mib_nuno: negligible
15:28:53 <Saizan_> Cale: sure?
15:28:53 <czakey> hm
15:28:58 <Saizan_> ?src Kleisli
15:28:59 <lambdabot> Source not found. You untyped fool!
15:29:05 <Saizan_> ?type Kleisli
15:29:07 <lambdabot> forall a (m :: * -> *) b. (a -> m b) -> Kleisli m a b
15:29:19 <czakey> how to add some string from function
15:29:23 <Cale> er...
15:29:24 <Saizan_> ?type putStrLn
15:29:25 <lambdabot> String -> IO ()
15:29:28 <czakey> to system?
15:29:28 <Cale> Right.
15:29:32 <czakey> i mean
15:29:34 <czakey> :t system
15:29:35 <lambdabot> Not in scope: `system'
15:29:36 <Cale> So that would be Kleisli IO
15:29:38 <Cale> hmm
15:29:46 <Cale> :t Kleisli putStrLn
15:29:48 <lambdabot> Kleisli IO String ()
15:29:48 <Saizan_> yeah
15:29:56 <Cale> :t join (***) (Kleisli putStrLn)
15:29:57 <lambdabot> Kleisli IO (String, String) ((), ())
15:30:09 <Cale> :t runKleisli (join (***) (Kleisli putStrLn))
15:30:10 <lambdabot> (String, String) -> IO ((), ())
15:30:15 <mib_nuno> I saw Andrew Appleyard's thesis (Salsa) but I don't think it's a available for download.
15:30:25 <mib_nuno> ...on .net interop
15:30:44 <czakey> I have something like
15:30:54 <czakey> system "something somethingelse"
15:31:09 <czakey> and I wont to do something like
15:31:23 <czakey> something = "somestring"
15:31:47 <czakey> system somestring "something somethingelse"
15:31:49 <byorgey> :t runKleisli (join (***) (Kleisli putStrLn) >>> arr (const ()))
15:31:50 <lambdabot> (String, String) -> IO ()
15:31:53 <byorgey> =D
15:32:21 <Vulpyne> Hmm.
15:32:44 <bos> byorgey: what tortuous things are you trying to do?
15:33:02 <Vulpyne> cza: Are you talking about string concatenation?
15:33:18 <Vulpyne> Whatever he did, it doesn't look too much like what I was trying to do. :)
15:33:53 <byorgey> bos: evil ones, I assure you =)
15:34:21 <czakey>  system "something" ++ word ++ "somethingelse"
15:34:26 <Saizan_> ?type uncurry (liftM2 (,)) . join (***) putStrLn
15:34:27 <lambdabot> (String, String) -> IO ((), ())
15:34:33 <czakey> doesn't work
15:34:51 <Saizan_> so many ways to abuse combinators :)
15:34:58 <Vulpyne> cza: Try parenthizing.
15:35:07 <Vulpyne> system ("something" ++ word ++ "somethingelse")
15:35:12 <TomMD> czakey: Do you want: > system $ "cmd" ++ str ++ "somethingelse"
15:35:23 <czakey> aaah yup
15:35:35 <czakey> its too late for me I think ;>
15:35:46 <czakey> just mometary lapse of idea
15:35:56 <Vulpyne> It's going on your record!
15:35:57 <czakey> but lack of power ;>
15:37:32 <Vulpyne> Funky. fst $ ((putStrLn . ("x"++)) *** (putStrLn. ("y"++))) ("1","2") works.
15:37:41 <Vulpyne> And so does snd.
15:37:57 <Vulpyne> Since it's just returning the IO actions in a tuple.
15:44:30 <CVirus> abs x = if x >= 0 then x else -x ..... How can I call this function with a negative number ?
15:44:47 <vixey> > abs (negative 7)
15:44:48 <lambdabot>   Not in scope: `negative'
15:44:55 <ddarius> > abs (-1)
15:44:57 <lambdabot>  1
15:44:57 <vixey> @let negative x = subtract 0 x
15:44:58 <lambdabot> Defined.
15:44:59 <Bonus> abs (-9)=
15:44:59 <vixey> > abs (negative 7)
15:45:00 <lambdabot>  7
15:45:00 <Bonus> ?
15:45:03 <augustss> > abs (-10)
15:45:04 <lambdabot>  10
15:45:06 <Zao> CVirus: You can call it with any number.
15:45:23 <Vulpyne> You just have to parenthize negative numbers usually.
15:45:24 <Zao> You cannot get a negative number as the result.
15:45:30 <Vulpyne> abs (-2)
15:45:56 <CVirus> Thanks alot
15:46:09 <CVirus> it's just the parentheses i was missing
15:46:11 <Vulpyne> It's because - can be either unary or infix.
15:46:17 <vixey> - is odd
15:46:57 <CVirus> > putStrLn "Testing"
15:46:58 <lambdabot>  <IO ()>
15:47:02 <CVirus> huh ?
15:47:10 <Vulpyne> lambdabot doesn't do IO.
15:47:11 <Bonus> that's what putStrLn returns
15:47:15 <CVirus> i see
15:47:23 <ddarius> > writeFile "/etc/passwd" ""
15:47:25 <lambdabot>  <IO ()>
15:47:29 <CVirus> hehe
15:48:01 <Vulpyne> Does it create the IO actions, the just never get executed?
15:48:08 <ddarius> Vulpyne: Yes.
15:48:09 <CVirus> /dev/sda would be wiser :-p
15:48:15 <Vulpyne> Fun.
15:48:56 <ddarius> :t negate
15:48:58 <lambdabot> forall a. (Num a) => a -> a
15:51:46 <pjd_> IO should have a better show instance
15:53:17 <Saizan_> it has one only in lambdabot, however how could it be much better?
15:53:55 <Vulpyne> > return [1,2,3] :: IO [Int]
15:53:56 <lambdabot>  <IO [Int]>
15:54:24 <pjd_> Saizan_: it could show you what the action is composed of
15:54:53 <pjd_> based on whatever the internal representation is
15:58:17 <ddarius> pjd_: I believe all current implementations use an opaque functional representation internally (notwithstanding the fact that the IO type is abstract)
15:58:54 <pjd_> ddarius: it must be non-opaque at some level, no?
16:00:22 <sw17ch> Is there a way to use anything in Network.* to retrieve a list of all the interfaces/addresses owned by the machine?
16:00:36 <ddarius> pjd_: Ultimately it's a bunch of bits (or maybe not...).  A bunch of hex code is probably worse than <IO \()>
16:00:50 <Zao> sw17ch: getAddrInfo on your nodename?
16:01:09 <pjd_> ddarius: surely that <IO> is not already compiled to machine code
16:01:12 <sw17ch> Zao, where nodename is what? :) localhist?
16:01:14 <sw17ch> err... host
16:01:34 <ddarius> pjd_: By the time a 'show' function got to it, it would be.
16:02:11 <Zao> sw17ch: There's a getNodeName in Posix somewhere.
16:02:33 <EvilTerran> it'd be possible to write an IO-alike monad that supported, eg, random numbers, output, etc
16:02:53 <pjd_> ddarius: unless it ran in interpreted mode?
16:02:55 <EvilTerran> but fell back to <IO ...> if you tried to do anything unsupported
16:03:24 <Zao> nodeName of getSystemID.
16:03:25 <ddarius> pjd_: Even GHCi uses bytecode compiling (though it does keep enough information around nowadays to give useful output).  lambdabot doesn't use GHCi
16:03:44 <Saizan_> EvilTerran: there's still teh problem of >>=, the second parameter is a function, so you can't inspect it
16:03:45 <ddarius> pjd_: Furthermore, having a function to do that would (most likely) break referential transparency.
16:04:07 <pjd_> ddarius: how so?
16:04:25 <sw17ch> what module is getSystemID in?
16:04:44 <sw17ch> Zao: what module is getSystemID in?
16:04:50 <EvilTerran> Saizan_, indeed, but you can inspect the end result
16:04:58 <pavizard> Eureka! lol I am just happy, solved a little problem i had, thanks everyone here :)
16:05:14 <Zao> sw17ch: System.Posix.Unistd
16:05:18 <EvilTerran> if you just wanted randoms and string output, you could use MonadWriter and MonadRandom
16:05:18 <Bonus> if liftM f is equivalent to m a >>= return . f
16:05:31 <Saizan_> EvilTerran: but only if you execute the first action?
16:05:32 <EvilTerran> wrap 'em up to look like IO
16:05:40 <Bonus> is mapM f equivalent to m lst >>= return . map f
16:06:29 <EvilTerran> Saizan_, yes. but i'm saying you can have a load of actions in this restricted monad that simulate their IO equivalents
16:06:34 <ddarius> pjd_: It most likely would show variable names and not expand everything thus you wouldn't be able to replace a variable bound to 2+2 with the expression 2+2 without effecting semantics.
16:06:40 <EvilTerran> and others which just bail out when you run them
16:06:42 <sw17ch> Zao, close... but i'm really trying to reproduce the output of ifconfig without consulting /proc/net/dev like it does
16:06:51 <Saizan_> EvilTerran: ah, so you're aiming to show the overall result? i thought pjd_ wanted to show the "computation"
16:06:55 <EvilTerran> better include a MonadError in that monad as well...
16:07:22 <Zao> sw17ch: Since you're inherently platform specific in any way, just dig around there or in /dev?
16:07:30 <sw17ch> Zao, `ip route` manages to show routes without consulting anything in proc...
16:07:42 <EvilTerran> i just want to be able to have
16:07:43 <Zao> sw17ch: Then grab the source and see how they do it?
16:07:55 <Zao> sw17ch: And what's wrong with /proc? It's there for a reason.
16:08:08 <Bonus> @src mapM
16:08:08 <lambdabot> mapM f as = sequence (map f as)
16:08:09 <EvilTerran> > print . (+1) =<< randomIO
16:08:10 <lambdabot>  <IO ()>
16:08:11 <EvilTerran> work
16:08:43 <sw17ch> Zao: hah, truth be told, Starcraft, when used through Wine, binds to the "first" network interface it finds.... i'm trying to figure out either 1) how to change the order of the interfaces, or 2) where that interface list comes from to begin with :)
16:09:16 <Zao> sw17ch: Read the wine source then? Shouldn't take more than a week or two to get through it all.
16:09:17 <sw17ch> Haskell just has a better way of interacting with the networking libraries than C (if C had a REPL, i'd be happy)
16:09:21 <sw17ch> :P
16:09:35 <EvilTerran> C does have a REPL, kinda. gdb.
16:09:41 <pjd_> sw17ch: there are a few REPLs for C
16:09:52 <pjd_> cint
16:09:55 <sw17ch> pjd_: not as good as ghci is though :)
16:11:12 <ddarius> GHCi is a pretty crappy REPL as far as REPLs go.
16:11:29 <dons> do you use the tab completion?
16:11:32 <vixey> I thought it was useful
16:11:40 <sw17ch> dons: in GHCi, yes
16:13:30 <EvilTerran> ... there's tab completion?!
16:13:39 <EvilTerran> ... hm. not here. **stabs windows**
16:14:52 <sw17ch> >Prelude Network.Socket> get{tab} => getAddrInfo      getChar          getContents      getLine          getNameInfo ...
16:15:08 <Saizan_> someone know how to make emacs transimt tabs to ghci rather than inserting some spaces?
16:15:32 <JaffaCake> ddarius: crappy in what way in particular? what would you like to see in GHCi?
16:15:56 <ddarius> JaffaCake: The ability to enter the full Haskell language.
16:16:05 <JaffaCake> right, ok
16:16:16 <JaffaCake> I might try to add that at some point
16:16:34 <sw17ch> JaffaCake, yeah... now that i think about it... the way irb does blocked statements is pretty slick
16:16:47 <ddarius> Yeah, it did seem like more of a time/priorities thing.
16:17:15 <JaffaCake> well, the model is that the GHCi command line is like being inside a top-level do-block
16:17:43 <sw17ch> though, irb doesn't have tab completion
16:18:05 <nejucomo> :t (.)
16:18:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:18:21 <shachaf> sw17ch: irb has tab completion.
16:18:28 <shachaf> sw17ch: require 'irb/completion'
16:18:30 <nejucomo> Weird... That's not the type ghci tells me.
16:18:37 <shachaf> nejucomo: Cale changed it.
16:19:10 <shachaf> nejucomo: (.) = fmap in Caleskell, with the (r ->) functor. You can ignore that, if you want. :-)
16:19:16 <Cale> Yeah, I put a more general version in lambdabot
16:19:27 <JaffaCake> :t Prelude..
16:19:28 <lambdabot> parse error on input `Prelude..'
16:19:34 <Cale> :t (Prelude..)
16:19:37 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
16:19:41 <shachaf> @ty (P..)
16:19:43 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
16:19:54 <sw17ch> shachaf, well thanks!
16:19:57 <sw17ch> shachaf++
16:20:32 <JaffaCake> :i .
16:20:35 * shachaf doesn't have tab completion in ghci at the moment, actually.
16:20:48 <shachaf> JaffaCake: There's no :i in \b.
16:20:50 * sw17ch doesn't know how it got in his ghci
16:20:55 <shachaf> For some reason it compiled without readline support.
16:20:57 <JaffaCake> oh well
16:20:58 <luqui> oh!  (Prelude..) is very confusing looking
16:20:59 <shachaf> It's annoying.
16:21:10 <JaffaCake> luqui: I'm glad you said that :)
16:21:29 <JaffaCake> since I'm proposing to change it in Haskell'
16:21:42 <luqui> JaffaCake, really, to what?
16:21:46 <JaffaCake> Prelude.(.)
16:22:02 <shachaf> JaffaCake: And the infix version?
16:22:06 <luqui> and a section would be Prelude.(f .)
16:22:09 <JaffaCake> `Prelude.(.)`
16:22:10 <shachaf> JaffaCake: Still "Prelude.."?
16:22:17 <shachaf> That's not consistent.
16:22:23 <shachaf> > 5 `(+)` 3
16:22:24 <lambdabot>  Parse error at "(+)`" (column 4)
16:22:37 <luqui> I have rather wanted a more powerful `` for a long time
16:22:44 <luqui> so this is a reasonable compromise
16:22:54 <JaffaCake> shachaf: it's fine, take a look at the proposal
16:22:58 <shachaf> Yes, but I really doubt that'd go into H'.
16:23:08 <shachaf> @go haskell prime proposals
16:23:11 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/
16:23:12 <lambdabot> Title: Haskell Prime - Trac
16:24:00 <shachaf> JaffaCake: Operators that use "." are the biggest problem, right?
16:24:05 <shachaf> (Prelude.+) isn't as confusing.
16:24:39 <shachaf> JaffaCake: Which proposal is it?
16:24:49 <JaffaCake> shachaf: yes, the fact that . is both the qualification symbol and part of an operator leads to confusion
16:24:59 <JaffaCake> http://hackage.haskell.org/trac/haskell-prime/wiki/QualifiedOperators
16:25:02 <lambdabot> Title: QualifiedOperators - Haskell Prime - Trac, http://tinyurl.com/6bvdqp
16:25:13 <Cale> I really wish that something like | had been picked as the module path separator.
16:25:46 <Cale> (.) is by far my most commonly used operator symbol, and having qualified names in a composition chain makes things annoying to read.
16:25:47 <shachaf> (`plus`) isn't allowed?
16:25:51 <shachaf> Is there a reason for that?
16:25:52 <JaffaCake> well, I think we should have picked something else for qualification
16:27:45 <JaffaCake> shachaf: look at the grammar, the relative precedence of () and `` is explicit
16:28:08 <JaffaCake> Cale: I agree, but it's too late to change that now
16:28:32 <Cale> JaffaCake: right.
16:28:34 <luqui> I don't agree with the last point.  I think it would break a fair amount of code.
16:28:51 <luqui> it would break every program that uses the old qualified operator syntax
16:29:11 <Cale> luqui: Sure, but what if that code didn't exist, would you pick '.'?
16:29:43 <luqui> probably would, for canonicity reasons
16:29:46 <shachaf> By the way, what is http://haskell.org/haskell98/ ? What is it doing there?
16:30:06 <JaffaCake> luqui: qualified operators aren't common, I think
16:30:33 <JaffaCake> shachaf: no idea.  Looks like it should be removed
16:30:41 <luqui> JaffaCake, we have different definitions of "common" I think.  When talking about language changes, 5% is very common
16:31:11 <JaffaCake> we're not aiming for 95% compatibility with H'
16:31:25 <luqui> oh, ok.
16:31:27 <Cale> The whole compatibility issue with H' annoys me.
16:31:36 <JaffaCake> in fact, I expect that a lot of code will need changes
16:31:37 <Cale> I wish we could just define a new language already. :)
16:31:48 <JaffaCake> but maybe only import changes
16:32:01 <JaffaCake> Cale: I think you already did ;)
16:32:06 <shachaf> Is there going to be an âˆ«H ? :-)
16:32:18 <CVirus> Got a Haskell quiz in 5 hours and I'm not done with studying yet nor I slept :-(
16:32:21 <luqui> I like that name
16:32:28 <luqui> though it is missing a differential form...
16:32:34 <Cale> JaffaCake: ;)
16:32:41 <nejucomo> I know that "TClass a => ..." requires there to be an instance for a, but what is the syntax when a must be the instance of two different type classes?
16:32:58 <shachaf> luqui: Well, you don't really need that, if H is a function.
16:32:58 <luqui> (TClass a, TClass2 a) => ....
16:33:00 <EvilTerran> (Foo a, Bar a) => ...
16:33:03 <nejucomo> Thanks.
16:33:04 <Cale> JaffaCake: It's almost funny how much you can change the flavour of Haskell by playing around with the Prelude alone.
16:33:26 <JaffaCake> I'd like to trim the Prelude down quite a bit for H'
16:33:40 <luqui> JaffaCake, why?
16:33:43 <JaffaCake> it has too much junk
16:33:45 <luqui> does it get in your way too much?
16:34:00 <JaffaCake> e.g. it has a few IO functions, I don't think they belong there
16:34:06 <luqui> too much junk sounds like a solely aesthetic argument.
16:34:17 <JaffaCake> well yes, of course
16:34:44 <ddarius> Solely aesthetic judgements are acceptable.
16:34:56 <luqui> fair enough....
16:35:42 <luqui> the reasons I would consider trimming the prelude would be: (1) if it used names that I want to use, or (2) if it's concievable that an implementation could not implement some of it
16:36:15 <luqui> (1) has not happened to me enough to care, (2) is concievable (if you want, say, a IO-free dialect)
16:36:34 <JaffaCake> I don't think (2) is an issue, but (1) certainly is
16:36:42 <luqui> wait... you want to get rid of the IO functions, and yet main :: IO ()
16:36:47 <JaffaCake> also (3) to modularise the libraries
16:37:18 <luqui> JaffaCake, do you have a concrete instance of (1) that comes up a reasonable amount?
16:37:27 <JaffaCake> if I remove the IO stuff from the Prelude, then it becomes possible to completely swap the IO library out for something new without affecting the language
16:37:43 <JaffaCake> luqui: well, count the number of 'map's in the libraries
16:37:44 <luqui> yes, except the fact that you need to import a library to even define main
16:38:02 <luqui> JaffaCake, so you suggest that we remove _map_ from the prelude?
16:38:09 <JaffaCake> maybe :)
16:38:25 <JaffaCake> I wouldn't mind importing Data.List to get the list version, say
16:38:43 <JaffaCake> and C folks don't mind saying
16:38:45 <luqui> I'm going to have to disagree there.  If there's one function that appears in every file I write...
16:38:49 <JaffaCake> #include <stdio.h> to get printf
16:39:47 <Cale> I also really like to be able to write programs without having to import anything though. It would be nice if it didn't create such a fundamental limitation...
16:40:21 <Cale> Maybe the default context should be something configured at the compiler commandline?
16:41:06 <luqui> hmm... seems like a mistake, in that the compiler is not part of the language definition
16:41:07 <JaffaCake> Cale: I think that goes in the wrong direction - you want to understand a source file by looking at the file alone
16:41:08 <ddarius> Cale: And then we can add PRAGMAs to set those flags!
16:41:15 <luqui> lol
16:41:19 <Cale> heh
16:41:42 <Cale> It certainly would be nice though, to make it easy to swap out the base package.
16:41:47 <daveux> Hey, I have a TimeDiff td, and I have tdSec td :: Int and tdPicosec td :: Integer, and I want a decimal second value like 1.333 (1 second, 333 milliseconds). How do I do this?
16:42:24 <daveux> tdSec td + tdPicosec td / 1000000000000 gives me Int vs. Integer errors
16:42:46 <luqui> daveux, for one, you can't use / on integers
16:43:11 <luqui> but fromIntegral will solve all your problems
16:43:26 <daveux> right, sorry, I meant I am trying to do TimeDiff -> Float
16:43:32 <daveux> I was very confused just now
16:43:44 <JaffaCake> daveux: use the time package if you can
16:43:44 <luqui> fromIntegral will do that too...
16:43:48 <luqui> oh, right
16:44:02 <JaffaCake> daveux: Data.Time instead of System.Time
16:45:08 <Cale> JaffaCake: A lot of the controversies would be solved, I think, if there were a standard way to pick which tree of packages you wanted to involve yourself in -- though there's probably some concern that this will cause the language to fracture too much.
16:46:10 <Cale> We could provide a set of packages for students and teachers with less polymorphism, if they have not enough time to teach things like functors properly, and another for weirdos like me who want to unify half the prelude into a single function :)
16:46:59 <JaffaCake> Cale: so all you have to do right now is 'import Prelude(); import HaskCale'
16:47:09 <JaffaCake> that's not too hard, is it?
16:47:24 <Cale> But that doesn't work. :)
16:47:31 <daveux> JaffaCake, I'm confused: I don't see anything there that will let me System.Time.TimeDiff -> Float
16:47:55 <Cale> The rest of the packages are compiled against the original prelude.
16:48:06 <Cale> and so they use the original definition of Monad, not my definition of Monad.
16:48:08 <JaffaCake> daveux: I mean use Data.Time exclusively instead of System.Time - it's a bigger task, but Data.Time is much better
16:48:10 <Cale> and things like that.
16:48:49 <Cale> If you want to change the abstractions in the Prelude, you have to rebuild everything which uses them against those changes.
16:48:51 <JaffaCake> Cale: I see - we do have GHC_PACKAGE_PATH for that use
16:49:07 <JaffaCake> to switch to an alternative set of packages, that is
16:49:08 <Saizan_> well the rest of the packages are also _written_ for the original prelude
16:49:28 * tverwaes kicks Botje 
16:50:12 * Botje nukes tverwaes from orbit
17:02:20 <daveux> Ok, I have a Data.Time.Clock.NominalDiffTime, how do I make a Float seconds value from it?
17:02:33 <glguy> fromRational?
17:02:38 <glguy> toRational
17:02:42 <daveux> hmm
17:03:03 <dmwit> Why would you want to?
17:03:12 <dmwit> ?src Real
17:03:12 <lambdabot> class  (Num a, Ord a) => Real a  where
17:03:12 <lambdabot>     toRational      ::  a -> Rational
17:03:20 <dmwit> toRational could work.
17:03:22 <zeno> Cale: how could you unify prelude into a function?
17:04:01 <dmwit> zeno: let (.) = fmap, (++) = mappend, infixl 0 $, at a guess
17:04:05 <daveux> fromRational . toRational did the trick.
17:04:24 <dmwit> daveux: Out of curiosity, what are you doing with the Float once you have it?
17:04:50 <daveux> I'm constructing a raw event stream representing MIDI events, then writing that to disk
17:04:59 <dmwit> zeno: And I guess he'd take fail out of Monad. =)
17:05:14 <daveux> I have timediffs from a base time, and they correspond to keypresses.
17:05:25 <EvilTerran> ?hoogle Fractional
17:05:25 <lambdabot> Prelude.Fractional :: class Num a => Fractional a
17:05:32 <dmwit> Ah.
17:05:35 <Botje> > foldr f (var "0") [a,b,c,d]
17:05:35 <daveux> In the end, you play your keyboard like a piano, and it makes a midi.
17:05:36 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr (Sym a))
17:05:37 * dmwit doesn't know much about midi
17:05:41 <daveux> nor do I
17:05:42 <zeno> @src infixl
17:05:42 <lambdabot> Source not found. That's something I cannot allow to happen.
17:05:42 <Botje> gah
17:06:00 <dmwit> zeno: infixl, infixr, infix are keywords defining which way operators associate.
17:06:35 <zeno> dmwit: there was a cool program that let you break chords down into thier notes so you could move them around like midi, but it wasnt free
17:06:38 <EvilTerran> daveux, i think realToFrac may do what you want in one step
17:06:54 <dmwit> zeno: Yeah, that program is exciting!
17:07:33 <zeno> dmwit: you know the one? i was thinking of writing a similar version in haskell (once im any good at it)
17:07:43 <dmwit> yow
17:07:49 <dmwit> Have you done any sound processing before?
17:07:53 <EvilTerran> ?yow
17:07:54 <lambdabot> Pardon me, but do you know what it means to be TRULY ONE with your BOOTH!
17:08:59 <dons> ?bug
17:09:00 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
17:09:03 <zeno> dmwit: nope but i want to make music on the computer (eventually)
17:09:27 <zeno> or at least mess with others
17:11:01 <solrize> turning note sets back into chords is sort of like inverting type erasure, it can in many cases be done but it's nontrivial
17:11:23 <solrize> there is an algorithm for it in "mental processes" by christopher longuet-higgins
17:11:39 <solrize> that i think has been extended by music geeks since then
17:11:45 <dmwit> http://www.celemony.com/cms/index.php?id=dna
17:11:46 <lambdabot> Title: celemony_ :: Direct Note Access
17:11:57 <dmwit> It looks (and sounds) AWESOME.
17:12:13 <zeno> yeah that was it
17:12:21 <jberryman> solrize: what do you mean? naming chords?
17:12:34 <solrize> yeah, and turning pitches into chords
17:12:38 <dmwit> Strangely, the audio mixing on that video kind of sucks.
17:12:48 <solrize> sounds similar to what celemony claims to do
17:13:33 <sauxdado> i have no idea how to turn pitches into chords
17:13:44 <dmwit> Pitch -> chord is easy.
17:13:51 <sauxdado> it's not.
17:13:54 <dmwit> ?
17:14:09 <dmwit> Maybe we have different meanings of pitch and chord, then.
17:14:12 <jberryman> I suppose it would be ugly, because note names don't really reflect their relationships very well
17:14:18 <zeno> i wonder would it work for other types of music? i just see them using guitarrs and stuff
17:14:31 <dmwit> They do it on voice, too, at the beginning.
17:14:37 <zeno> ah ok
17:14:38 <solrize> i think there was a program at ccrma that did it for harpsichord
17:14:41 <sauxdado> dmwit: what chord is this? C E G A
17:14:56 <jberryman> am7 6
17:14:57 <dmwit> Who cares?
17:15:04 <sauxdado> dmwit: you're saying it's easy.
17:15:12 <dmwit> Ah.
17:15:17 <dmwit> We *do* have different meanings. =)
17:15:41 <zeno> would have known that chord if i didnt quit piano :\
17:15:49 <dmwit> sauxdado: The answer to your question, of course, is that it depends on context.  So yes, doing what you are talking about automatically can be tricky.
17:16:14 <sauxdado> i think it's a lot like translation
17:16:20 <dmwit> sauxdado: But playing C E G A from a speaker, or creating the waveform that would create the sound of C E G A: *way* easy. =)
17:16:27 <sauxdado> sometimes it depends on context so much that not even humans can tell exactly which one it is
17:16:28 <solrize> gene smith wrote something about it that used a bunch of combinatorial group theory
17:16:40 <sauxdado> music is not math, it's language
17:16:44 <sauxdado> with all the complications that follow
17:17:01 <jberryman> many languages, I would say
17:17:04 <solrize> dmwit, yeah, it's the inverse problem that ccrma worked on
17:17:05 <sauxdado> sure
17:17:15 <solrize> i.e. given an audio recording, generate the sheet music
17:17:32 <dmwit> Ah, yes, now I remember why I thought that video was hilarious.
17:17:39 <solrize> they had a demo where you could put in a harpsichord recording and play it back out as a piano recording
17:17:42 <solrize> or something like that
17:17:47 <dmwit> He pronounces MIDI "meaty". =P
17:18:31 <sauxdado> in classical music sometimes you see things like enharmonic key substitution where the same chord is played twice in a row, but the second time with completely different "notes"
17:18:41 <sauxdado> there's no way you can tell that from hearing the recording :)
17:18:44 <Zao> Could someone with a windows box please try the following in ghci?
17:18:44 <Zao> Network.BSD.getHostByName "localhost"
17:19:06 <solrize> sauxdado, right, that's where the algorithm comes in, it figures out where all the keys and modulations are
17:19:19 <dmwit> sauxdado: Well, there's *some* way, since people listening to it can sometimes tell. ;-)
17:19:21 <sauxdado> solrize: so this is actually possible?
17:19:28 <sauxdado> solrize: i'm very interested
17:19:43 <solrize> sauxdado it's sort of like type inference :)
17:19:53 <sauxdado> i can't figure out the keys but some algorithm can? :) where can i read about this?
17:19:57 <EvilTerran> Zao, HostEntry {hostName = "dijkstra", hostAliases = [], hostFamily = *** Exception: Network\Socket.hsc:(1678,17)-(1767,13): Non-exhaustive patterns in case
17:20:07 <Zao> EvilTerran: And what Windows/GHC version is that?
17:20:12 <sauxdado> solrize: type inference is math, music is language :)
17:20:17 <EvilTerran> Zao, XP Pro, 6.8.2
17:20:26 <Zao> EvilTerran: Thank you. It's not just me then.
17:20:30 <zeno> i thought music had alot to do with math
17:20:31 <solrize> sauxdado read any book on music theory and tell me it's not math :)
17:20:40 <sauxdado> solrize: it's not math.
17:20:42 <solrize> and read some books about linguistics and tell me that's not math either :)
17:20:45 <dmwit> It's not math.
17:20:46 <sauxdado> solrize: it's not math.
17:20:51 <dmwit> It's too gross to be math.
17:21:00 <zeno> what language?
17:21:01 <solrize> http://portal.acm.org/citation.cfm?id=576439
17:21:05 <lambdabot> Title: Mental Processes
17:21:08 <zeno> english is at any rate :)
17:21:25 <sauxdado> thanks
17:21:32 <Zao> EvilTerran: Any IPv6 on that box?
17:21:36 <EvilTerran> yes
17:21:47 <EvilTerran> not doing anything, AFAIK, but it's there
17:21:57 <Zao> Interesting.
17:22:19 <Zao> Anyone with Windows and just ipv4?
17:22:39 <Elly> anyone recommend a good Haskell tutorial for people who already know other functional languages? (in my case, SML)
17:22:45 <solrize> ftp://ftp.cogsci.ed.ac.uk/pub/steedman/music/l_h_theory.pdf
17:22:55 <solrize> elly, YAHT
17:23:05 <dmwit> ?where gentle
17:23:05 <lambdabot> http://www.haskell.org/tutorial/
17:23:05 <Elly> Yet Another Haskell Tutorial?
17:23:08 <cjb> Elly: right
17:23:13 <Plareplane> http://www.haskell.org/tutorial/intro.html
17:23:14 <lambdabot> Title: A Gentle Introduction to Haskell: Introduction
17:23:20 <dmwit> The gentle intro is a better pace for someone who already knows SML.
17:23:23 <Elly> ahh, I was reading that before
17:23:26 <Botje> @pl \x -> (1,x)
17:23:26 <lambdabot> (,) 1
17:23:38 <EvilTerran> Botje, sadly we don't have sections of ,
17:23:47 <Botje> it'd look a bit weird
17:23:55 <sauxdado> solrize: there're elements of math in both music and language but ultimately neither is a formal system - both are meant for human consumption, and we people are very, very good at dealing with ambiguities. That's the difference.
17:23:58 <Botje> (,2) 42
17:24:00 <EvilTerran> (1,) x looks fine to me
17:24:15 <EvilTerran> altho (1,,2) is starting to look a bit odd
17:24:15 <solrize> http://www.musiccognition.nl/blog/   this looks cool
17:24:16 <lambdabot> Title: Music Matters
17:24:28 <sauxdado> solrize: that's why translation is such a difficult problem, and i expect similar problems to arise with music processing.
17:24:59 <solrize> sure, it's a bunch of heuristics, just like natural language processing
17:25:43 <sauxdado> right - hardly math, and clearly requires "strong AI" to be done "nicely"
17:26:07 <solrize> sauxdado well more mathematical than that
17:26:23 <solrize> sort of like type inference in the presence of errors
17:26:33 <dmwit> I don't think it needs strong AI.
17:26:40 <sauxdado> dmwit: translation doesn't?
17:26:46 <dmwit> Oh, translation.
17:26:59 <sauxdado> dmwit: if you think translation does but music processing doesn't, it is probably because you don't know enough about music.
17:27:03 <solrize> so maybe there's some places where you have to give up, but you can get most of it
17:27:10 <jberryman> sauxdado: I agree with you. I think the most important parallel to math in musi is the idea of the algorithm.
17:27:11 <dmwit> Well, analyzing music should be a mostly probablistic problem, I would think.
17:27:24 <jberryman> motives, the fugue, serial music
17:27:27 <sauxdado> dmwit: sure, just like translating.
17:27:34 <wadcom> hi
17:27:35 <dmwit> sauxdado: Perhaps.  Though I do know enough to know that, e.g. V is most often followed by I.
17:27:49 <wadcom> http://hpaste.org/7273 anyone, please? ;-)
17:28:13 <dmwit> So if you see C E G B followed by F A C, it's probably V7-I.
17:28:24 <sauxdado> dmwit: right; of course, V does not necessarily include any of the pitches V, VII, II
17:28:29 <Elly> what does a lambda look like in haskell? in SML the syntax is (fn x => ...)
17:28:33 <dmwit> sauxdado: Of course.
17:28:36 <wadcom> elly:
17:28:44 <wadcom> elly: \x -> ...
17:28:45 <sauxdado> dmwit: "V" could for example be sharp I, sharp III, sharp V
17:28:49 <Elly> ah, thanks :)
17:29:03 <Elly> that's more concise than (fn x => ...)
17:29:04 <Zao> :t \x y (z,w) -> x
17:29:06 <lambdabot> forall t t1 t2 t3. t -> t1 -> (t2, t3) -> t
17:29:13 <sauxdado> dmwit: is that still "V"? We humans know that it works. Does a computer know?
17:29:16 <dmwit> sauxdado: I would call that a V/V.
17:29:27 <sauxdado> dmwit: it's not. It's a tritone substitution.
17:29:38 <solrize> wadcom sounds like you want a type class?
17:29:55 <dmwit> sauxdado: err...? oh, yeah, you're right
17:30:07 <sauxdado> dmwit: in any case, all those things only make sense in the context of particular kinds of music
17:30:25 <wadcom> solrize: ehm, how would it fit here?
17:30:26 <sauxdado> music is not even one language - it's many
17:31:05 <jberryman> it would be insanely hard to make a reasonably correct analysis of anything reasonably interesting
17:31:35 <Zao> I'd like to see you analyze Aphex Twin.
17:31:44 <dmwit> Easy.
17:31:52 <dmwit> It's a self-portrait, in oscilloscope mode.
17:31:54 <sauxdado> thankfully people seem to be capable of both composing and listening to music without much automation :)
17:31:55 <solrize> wadcom you'd have a class for those different types of parse functions.  you'd still be writing the functions separately per type
17:32:23 <wadcom> solrize: but how would it help to remove duplication? I'm not quite seeing that
17:33:06 <solrize> wadcom right, it wouldn't remove the duplication.  hmm.
17:33:23 <jberryman> sauxdado: :) thinking about this has made me appreciate my human brain. soggy and confused as it is
17:33:37 <Elly> how does one write comments in haskell? :O
17:33:44 <dmwit> --
17:33:44 <dons> > -- like this
17:33:45 <lambdabot>   parse error on input `}'
17:33:48 <Elly> ah, thanks :)
17:33:51 <sauxdado> dons: way to go :)
17:33:51 <dons> > 1 + {- or like this -} 2
17:33:52 <lambdabot>  3
17:34:00 <dmwit> {- -} nest
17:34:12 <dons> > 1 + {- or {- like -} this -} 2 -- see ?
17:34:14 <lambdabot>  3
17:34:15 <solrize> wadcom, hmm, i guess there can be a polymorphic HOF
17:34:19 <dmwit> > 1 + {- but not {- like this -} 2
17:34:19 <lambdabot>  Unterminated nested comment at "+" (column 3)
17:34:28 <Elly> comments nesting is good
17:34:38 <dmwit> yeah
17:35:08 <wadcom> solrize: yeah, the question is how to "pass" a pattern to match inside that HOF
17:35:18 <solrize> i think you'd have to pass a function into it
17:36:08 <wadcom> solrize: ...which would have 'case' in it. And that's exactly what I want to get rid of :-)
17:36:44 <dmwit> wadcom: You could pass a verification function and a translation function.
17:36:57 <Cale> The fact that comments properly nest in Haskell was a rather good sign for me when I was first learning it, that its designers were not generally sloppy people.
17:36:58 <solrize> mkParse: (String -> [Token]) -> ([Token] -> Either String Treenode)
17:37:34 <dmwit> hof (words s) ((== 2) . length) (\[k, v] -> return (k, v)) "Can't parse a key-value pair: "
17:38:17 <wadcom> dmwit: what if pattern match fails in the lambda expression?
17:38:24 <dmwit> It's kind of like a backwards catamorphism.
17:38:38 <dmwit> wadcom: It doesn't.  The verification condition guarantees it.
17:38:54 <wadcom> dmwit, yeah, right
17:39:30 <dmwit> It doesn't save very much, in my opinion.
17:39:37 <dmwit> But at least you don't have a case statement.
17:39:37 <wadcom> yeah
17:39:53 <wadcom> case statement actually looks clearer to me
17:40:04 <dmwit> Part of the problem is that you're using parsing functions that return two different types.
17:40:08 <wadcom> verification is implicit there, which is very convenient
17:40:19 <dmwit> If you used a consistent return type you'd be in much better shape.
17:40:26 <wadcom> dmwit, that's a good point
17:40:27 <EvilTerran> you could do something hairy to enforce safety more vigorously in the types
17:40:29 * dmwit mentions Parsec for like the third time today
17:40:53 <EvilTerran> which'd itself be a pattern-match, of course
17:41:16 * wadcom wanted to stay away from parsec for now for educational purposed ;-)
17:41:26 <dmwit> ok =)
17:41:28 <EvilTerran> but something in the style of the existing "maybe" and "either" functions, or like "list :: (a -> [a] -> b) -> b -> [a] -> b"
17:41:43 <dmwit> Yeah, I was going to suggest and antiEither.
17:42:03 <wadcom> ok, thanks guys
17:42:03 <dmwit> antiEither p left right = if p then Right right else Left left
17:42:28 * Zao fondly recalls the "Left is discriminating left handers" discussion on -cafe.
17:42:42 <glguy> q_q
17:42:43 * EvilTerran was, ahem, left out of that one
17:43:16 <EvilTerran> ... i really quite like the idea of programming only with total functions, using that CPS-esque approach
17:44:09 <jberryman> if I make a function to generate a list, and use bits of the list in working with other functions, do i have to worry about haskell doing the calculations to generate the list again and again? or do the thunks that have been calculated just stay in memory? or does it depend?
17:44:15 <EvilTerran> altho i guess you could just tell ghc to give a warning on incomplete patterns or whatever
17:44:33 <EvilTerran> jberryman, it depends on implementations
17:44:40 <dmwit> jberryman: It's implementation-specific.
17:44:57 <EvilTerran> but, in most implementations, a value bound to a name will only be calculated once while that name stays in scope, and other values won't
17:45:07 <dmwit> jberryman: But GHC is pretty performance-oriented, so unless you're doing something very surprising, I wouldn't worry about it.
17:46:06 <EvilTerran> so using (length xs) repeatedly would result in it being calculated repeatedly, but naming it in a where or a let/in or whatever stops that happening
17:47:11 <jberryman> thanks. and if i test a condition in a gaurd and use something that i tested in the corresponding definition can I assume it won't be recalculated?
17:47:23 <zeno> jberryman: haskell has arrays too i think
17:47:37 <zeno> but lists are so powerful
17:47:39 <EvilTerran> jberryman, only if you bind it to a name
17:48:08 <EvilTerran> note that the contents of a where{} clause is in scope in the guards in the same block
17:48:12 <dmwit> In general, you cannot assume anything about evaluation order.
17:48:47 <dmwit> But in practice, what EvilTerran says is correct: named things are calculated once.
17:50:11 <jberryman> thank you. that clears up a lot of questions.
17:50:20 <EvilTerran> common subexpression elimination is perfectly implementable, but it's of debatable use, as it can cause unexpected space leaks
17:50:31 <EvilTerran> from things staying cached "in scope" much longer than you expect
17:51:26 <EvilTerran> jberryman, but, as dmwit says, there's very little need to worry about this sort of thing unless you're chugging through huge amounts of data
17:52:33 <jberryman> I'm factoring numbers ;)
17:52:55 <jberryman> I think i only write toy programs that chug through huge amounts of data
17:53:22 <dmwit> Ah, don't worry, your list of primes is safe with GHC. ;-)
18:07:27 <dibblego> is liftM2 the right function to use to return indicies from a list? e.g. f ['a', 'b', 'c'] [0, 2] -> ['a', 'c']
18:07:38 <dibblego> I've been using Java, sorry
18:07:48 <dibblego> I am totally switched off to thinking
18:07:55 <sarehu> dibblego: no, map
18:08:11 <sarehu> > map (['a','b','c'] !!) [0,2]
18:08:12 <lambdabot>  "ac"
18:08:13 <dibblego> sarehu, [0, 2] may not be sorted
18:08:33 <dibblego> won't that blow out?
18:08:38 <sarehu> what do you mean
18:08:45 <dibblego> many list traversals
18:08:48 <monochrom> > map (['a','b','c'] !!) [2,0]
18:08:49 <lambdabot>  "ca"
18:09:00 <sarehu> yes.  liftM2 does many list traversals too
18:09:12 <dibblego> I guess
18:09:47 <sarehu> (since it just throws the cartesian product into a function)
18:09:48 <monochrom> I think liftM2 hides positions.
18:10:07 <sarehu> > liftM2 (,) "abc" "def"
18:10:07 <lambdabot>  [('a','d'),('a','e'),('a','f'),('b','d'),('b','e'),('b','f'),('c','d'),('c',...
18:10:57 <monochrom> By that I mean: when you have liftM2 blah to call your blah, your blah is not told the indexes of the list elements it receives.
18:11:28 <sarehu> you can have an O(n log n) function for getting indices... but you have to write it yourself..
18:11:35 <awesame> is there some standard function to turn a [(a, b)] into a Data.Map a b?
18:11:46 <sarehu> Data.Map.fromList
18:12:01 <awesame> ah, thanks sarehu
18:12:15 <awesame> somehow my vgrep failed to find that in the Data.Map docs
18:12:31 <saml> what does withState do?  Apply this function to this state and return the resulting state.  <- doesn't ring the bell for me.
18:12:39 <sarehu> ah heck, you can have a linear function for getting indices if you use an array and bucket sort
18:12:48 <shapr> @users
18:12:48 <lambdabot> Maximum users seen in #haskell: 468, currently: 416 (88.9%), active: 17 (4.1%)
18:13:04 <saml> withState f m = State $ runState m . f   -- this is source of withState
18:26:23 <ski> @type \f m -> State $ runState m . f
18:26:24 <lambdabot> forall s a. (s -> s) -> State s a -> State s a
18:26:33 * gwern sighs. it feels to me like haskell land has been awfully boring lately; I hope that's just because of Summer of Code
18:26:38 <ski> @type mapState
18:26:39 <lambdabot> forall a s b. ((a, s) -> (b, s)) -> State s a -> State s b
18:28:24 <sjanssen> gwern: just normal wax and wane, I think
18:29:24 <gwern> sjanssen: I was hoping to ascribe it to all the students doing exams, but this isn't the right time of the spring, and xmonad development has been very slow recently as well
18:31:34 <gwern> (all the activity recently seems to just be newbies learning what's already in xmc and the rare bug fix)
18:32:11 <gwern> (yi's active, but it's hard to hack on and fragile (needs a darcs cabal, for example), and darcs is just painful to hack on)
18:32:29 <sjanssen> gwern: xmonad is reaching completion, I think
18:33:13 <monochrom> After accomplishing world domination, life is bound to be boring.
18:33:19 <gwern> what a sad thought. reaching completion is in a way like dying, although I suppose WMs are inherently fairly limited
18:33:47 * gwern weeps for thought of all the other worlds I cannot conquer; gwern then catches a cold and is deaded
18:33:50 <SamB> monochrom: but what about those danged rebels?
18:34:07 <monochrom> I suggested screen saver a while ago. May be considered an addition to xmonad or a separate project.
18:34:22 <gwern> SamB: we'll let the dire wolves eat them before they escape back into the desert
18:34:32 <monochrom> The screen saver plays a haskell lecture video or slide show.
18:35:11 <gwern> monochrom: licensing would be troublesome
18:35:29 <SamB> gwern: how?
18:35:39 <SamB> it just streams them off the intarweb
18:35:57 <gwern> SamB: what, does xmonad not work if you're offline?
18:36:07 <gwern> then why should this putative screensaver?
18:36:24 <gwern> even something like electricsheep works offline
18:36:44 <SamB> true...
18:37:01 <monochrom> Caching cannot be made illegal in practice.
18:37:07 <awesame> okay, seeking another function
18:38:01 * gwern greets monochrom's argument with the scorn it merits
18:38:11 <eu-prleu-peupeu> i cant find any jobs in haskell
18:38:12 <awesame> I want something like lookup that takes a list of keys and returns a list of values.  I think map lookup isn't good enough because it will iterate multiple times.
18:38:35 <eu-prleu-peupeu> haskell is a jobless programming language... ence a not so good investment
18:38:50 <awesame> there are haskell jobs, but maybe not many
18:38:59 <gwern> eu-prleu-peupeu: strangely, whenever I open up emails dealing with haskell in gmail, I see no shortage of ads
18:39:09 <monochrom> I don't think eu-prleu-peupeu is looking for a discussion.
18:39:17 <SamB> eu-prleu-peupeu: ye of little fate
18:39:24 <awesame> however, I find it easy to imagine that haskellers would be in high demand for a small number of positions
18:39:30 <SamB> gwern: yes but most of those are for ML jobs
18:39:44 <SamB> apparantly eu-prleu-peupeu doesn't believe in transferable skills
18:39:49 <eu-prleu-peupeu> :)
18:39:56 <gwern> awesame: if map lookup is the clean solution, why not use it? sounds like premature optimization to me. nothing to say it won't get fused/transformed/optimized into a non-iterate-multiple-times-whatever
18:40:26 <EvilTerran> awesame, if you're really worried about performance, use Data.Map instead of lists
18:40:31 <gwern> SamB: ah, good point. I sort of have the background assumption that an expert Haskell programmer can be a good/great programmer in any FP lang :)
18:40:44 <awesame> EvilTerran: well, I start with a list
18:41:10 <SamB> gwern: I believe Jane Street Capital rather agrees with you on that point ;-)
18:41:16 <awesame> so what I'm doing now is a specific version of something I could abstract better using this function I want
18:41:34 <awesame> converting to a map or iterating multiple times would be slower than what I'm doing now
18:41:48 <gwern> awesame: are you sure? you've benchmarked it?
18:41:53 <EvilTerran> awesame, if, say, both lists of keys are sorted, it'd probably be best to roll your own
18:42:03 <gwern> SamB: as it happens, I've noticed JSC keeps popping up...
18:42:20 <SamB> gwern: I obviously have as well ;-)
18:42:33 <awesame> gwern: I'm not going to freaking benchmark a cleanup.  if there isn't a function that says what I want to say, I'm just going to leave my code the way it is.
18:42:34 <EvilTerran> there doesn't seem to be that much support in the bibraries for working with ordered lists
18:42:57 <awesame> gwern: my objection to "map lookup" isn't really that it would slower, but that it doesn't say what I want.
18:43:34 <awesame> *would be slower
18:43:38 <zeno> > print "whatever\nx"
18:43:39 <lambdabot>  <IO ()>
18:43:47 <SamB> awesame: you could make a name for what you are doing...
18:43:53 <zeno> how do you make it expand newlines?
18:43:59 <EvilTerran> [v | (k,v) <- table, k' <- list, k == k']?
18:44:10 <EvilTerran> as i say, if you have ordered lists, there's far faster approaches
18:44:14 <EvilTerran> zeno, "it"?
18:44:20 <zeno> prelude
18:44:25 <gwern> awesame: then don't say things like converting to a Map  or doing a map *would be* slower; you don't know that, and you apparently don't care enough to know that. say 'it would make my code longer', or 'it would be less readable' or 'I don't understand that stuff'
18:44:26 <EvilTerran> lambdabot doesn't, as a spam-prevention (amoung other) method
18:44:35 <monochrom> zeno: putStr "whatever\n"
18:44:38 <EvilTerran> ah. you want putStr(Ln)
18:44:40 <zeno> ah thanks
18:44:47 <EvilTerran> ?src print
18:44:47 <lambdabot> print x = putStrLn (show x)
18:44:51 <EvilTerran> simple :)
18:46:40 <monochrom> I think it's a great challenge for most people to express what they really have in mind.
18:46:55 <awesame> gwern: those things all specifically say something that, unoptimized, would be slower, and that's my problem with them.   If I were sorting, for example, I'd be happy to write "sort my list", but not "bubble-sort my list", even if both were silently turned into "quicksort my list"
18:47:56 <awesame> there's a difference between "using appropriate data structures and algorithms" and "premature optimization"
18:48:00 * gwern disagrees that a map lookup says how, not what
18:48:39 <awesame> ah. well that at least makes your position reasonable
18:48:48 <awesame> but I feel like it does say how
18:49:07 <sjanssen> all programs must say how at some level
18:49:19 <augustss> Prolog...
18:49:26 <sjanssen> bah
18:49:29 <monochrom> cuts
18:49:50 <augustss> No cuts, no builting numbers
18:49:56 <augustss> builtin
18:49:59 <gwern> if I said 'for whatever in stuff; do lookup; done', I'd agree that it is a 'how'. but a 'map lookup'? that just says 'I want lookup done on everything in the list, I don't care about evaluation order, nor am I going to tell you anything more than the function application part'
18:50:59 <sauxdado> the concepts are almost dual
18:51:18 <monochrom> With Prolog you just shift your levels.  "I want to explore ancestory" is what, "ancestor(X,Y) :- parent(X,Y) or ..." is how.
18:51:42 <SamB> using Data.Map doessn't say much about how or why...
18:51:59 <awesame> Data.Map says use a balanced binary tree!
18:52:09 <SamB> well, in practice, yes
18:52:16 <awesame> and the docs say "log n" all over the place
18:52:40 <SamB> but in theory I could have locally changed it to a ... trie?
18:52:51 <awesame> if you don't care about the log n, why write Data.Map rather than using association lists?
18:52:58 <sjanssen> SamB: not with the current interface (Ord constraint is not sufficient)
18:53:16 <SamB> hmm.
18:53:22 <awesame> maybe Data.Map says less about how than association lists do
18:53:44 <SamB> okay, well, so if you include the documentation, it does pretty much specify that binary search will be used
18:54:33 <gwern> documentation always lies
18:56:34 <awesame> it's an interesting question how to best write what you mean and optimize later
18:56:40 <monochrom> "what" and "how" are relative. A client's how is a vendor's what.
18:57:12 <awesame> but I kind of feel like if you can't optimize by replacing underlying function implementations, you're not saying what you mean
18:57:20 <awesame> "map lookup" fails that test
18:57:43 <awesame> whereas "mapLookup = map lookup" doesn't
18:58:00 <jamii> awesame: Look at the edison library. It has an assoc class of which binary trees are only one instance.
18:58:34 <jamii> awesame: I'll be adding generalised tries to the core library over the summer with the same interface as map
18:58:52 <jamii> awesame: As well as pure hashmaps, given time
18:58:54 <awesame> jamii: neat!
18:58:56 <SamB> which core library?
18:59:08 <SamB> not GHC's base, I assume?
19:00:34 <jamii> SamB: Eventually, assuming all goes well. My gsoc project is to spruce up Data.Map and friends.
19:00:56 <SamB> actually, at the moment not even Data.Map is in base...
19:01:03 <SamB> it's in collections...
19:02:19 <gwern> @seen dons
19:02:19 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc and #haskell. I last heard dons speak 1h 28m 6s ago.
19:02:23 <jamii> SamB: True. By core I mean the libraries that are distributed with GHC.
19:02:58 <gwern> @ask dons hey, when you were forking the FPS stuff from darcs, why did you leave behind the mmap bindings? did darcs simply not have them back then?
19:02:58 <lambdabot> Consider it noted.
19:03:37 <sjanssen> gwern: IIRC, mmap was removed because it isn't portable to Windows
19:04:22 <SamB> sjanssen: how so?
19:04:56 <gwern> sjanssen: I was wondering if it was portable or not, since I saw dons' bytestring-mmap package was POSIX based
19:04:58 <SamB> windows has support for memory mapping...
19:05:17 <gwern> but it seemed gratuitiously so to me since it was using POSIX file functions which darcs seemed to do without just fine
19:05:34 <cjs> Gha, hate vim, gotta switch to Yi.
19:06:36 * SamB wonders why it is taking coq so long to unprove something
19:18:43 <jamii> If I :set +s in ghci should I expect that to change running time or the amount of memory required to run a computation?
19:23:02 <monochrom> I feel that awesame's criterion implies that for every conceivable task (there are infinitely many) you must coin a name and add it to a library.
19:24:34 <monochrom> For example next time you need to do something like "filter (< 0) . mapLookup" you have to create a new name "mapLookupExceptJustTheNegatives".
19:24:46 <gwern> monochrom: you remind me of an information theoretic paper I once read on libraries which iirc proved that libraries in the general case were useless :)
19:25:22 <monochrom> Haha, but I bet in this case "general case" is meaningless.
19:25:57 <gwern> monochrom: personally, I'm convinced the authors should've turned it into an optimization problem and then applied the no free lunch theorems. would've been a shorter paper...
19:27:42 <monochrom> I mean this. What we want computers to do in practice is hardly a significant portion of whatever a theoretician considers "general case". In a theoretician's eye our programs always just do the corner cases.
19:30:47 <monochrom> So, when it is theoretically proved "X is useless for the general case", it may be a meaningless result, since we just want to do a corner case, and X is useful for just that corner case, and no one is expecting X to cover the general case anyway.
19:31:37 <sauxdado> in theory, theory and practice are the same...
19:32:53 <monochrom> That draws an artificial line between theory and practice. If you draw an artificial distinction, of course you will conclude that there is a distinction.  It is great circular logic.
19:33:14 <dibblego> monochrom, that is so spot-on
19:33:43 <pavizard> When I type this,   everything is fine but if i swap  line 2 <> line 1 or delete line 1, then I get Program error: Prelude.read: no parse , any idea?
19:33:44 <pavizard> putStrLn $ "Tracks in Catalogue: " ++ (show contents)
19:33:46 <pavizard>  writeFile "catalogue.txt" (show contents)
19:33:46 <sauxdado> monochrom: in theory, though, there is no distinction.
19:34:02 <geezusfreeek> then again, there is the saying about the difference between theory and practice. "In theory, there is no difference between theory and practice. In practice, there is."
19:34:03 <monochrom> Of course in my foregoing discussion I did that too. But in my foregoing discussion, I referred to theory that some theoreticians actually do, not every possible theory.
19:34:30 <monochrom> There are theories that exactly match practice. They are just less noticed or used.
19:35:24 <monochrom> One reason they are less noticed or used is that some people really like to self-perpetuate the myth "theory is different from practice".
19:35:45 <monochrom> Another reason is they are harder to come up with, and some of them harder to use.
19:35:49 <Saizan> pavizard: does that contents comes from something like "liftM read (readFile "catalogue.txt")"?
19:35:50 <geezusfreeek> monochrom: don't get me wrong, i agree.
19:37:21 <pavizard> :I don't have liftM, but i've got cat <-  readFile "catalogue.txt"
19:37:52 <pavizard> :Saizan where tha cat goes in a function, and what is returned, I want it to be added to my txt file, so I rewrite it
19:38:15 <jamii> damn, the extra zero on the input would be why that simulation was taking so long
19:39:35 <Saizan> pavizard: yeah, that's what i meant, the problem is that readFile is lazy, so it won't have finished to read the String from the file when you start writing in it if you don't force it explicitly
19:40:24 <Saizan> pavizard: that's why it works if you first print (show contents) to the screen
19:40:51 <pavizard> :Saizan, I see, is there any command except of putStrLn, which indicates the "readFile " ?
19:41:16 <pavizard> :Saizan, I see, is there any command except of putStrLn, which terminates the "readFile " ? ** correction
19:41:26 <Saizan> yes
19:41:38 <pavizard> :)
19:41:53 <Saizan> you can do "evaluate (length cat)"
19:42:01 <pavizard> :)
19:42:25 <pavizard> let me try
19:42:27 <Saizan> using length is just an hack to make it create the full list
19:43:04 <Saizan> ?index evaluate
19:43:05 <lambdabot> Control.Exception, Test.QuickCheck, Debug.QuickCheck
19:44:10 <Saizan> you've to import Control.Exception, or define evaluate x = x `seq` return ()
19:44:37 <EvilTerran> i thought evaluate explicitly meant something slightly different to that
19:46:31 <EvilTerran> there's a >>= involved or something
19:46:47 <Saizan> well, evaluate returns the argument, but we don't need it here
19:47:47 <EvilTerran> "Note: the first equation (evaluate x `seq` y    ==>  y) implies that (evaluate x) is not the same as (return $! x). A correct definition is (evaluate x = (return $! x) >>= return)"
19:48:04 <EvilTerran> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#7
19:48:05 <lambdabot> http://tinyurl.com/sqmlj
19:48:29 <Saizan> right
19:49:05 <pavizard> :Saizan, Thanks a lot it's fine now :)
19:49:19 <Saizan> still not very interesting here, it reminds of the difference between undefined and const undefined :)
19:50:13 <Saizan> pavizard: no problem
19:53:09 <Saizan> btw, windows doesn't have file locking when an handle is open for reading?
20:00:33 <Zao> Saizan: There's an exclusive read flag, I believe.
20:03:47 <dibblego> > phi
20:03:47 <lambdabot>   Not in scope: `phi'
20:04:54 <pavizard> :Saizan, regarding the readFile question before, do I have to use the evaluation for the writeFile too for the same reasons? cheers
20:10:41 <Saizan> pavizard: no, writeFile is already strict in its arguments
20:10:45 <TSC> writeFile isn't lazy, IIRC
20:11:16 <pavizard> :TSC thanks
20:11:18 <Saizan> and it writes before returning
20:13:05 <Saizan> weird, what's the term for something like "its effects are performed before those of subsequent actions"? synchronous?
20:15:30 <sclv__> reading back a bit -- hashmaps are part of the gentrie soc project!?
20:17:34 <Adamant> Saizan: that's what Verilog uses IIRC
20:18:27 <Adamant> you can group multiple actions to occur at once by using the <= operator instead of =
20:18:32 <solrize> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/type-level-0.2   ZOMG
20:18:34 <lambdabot> http://tinyurl.com/67scm5
20:20:04 <dibblego> is there a verb for 'union'?
20:20:13 <dibblego> unify
20:20:49 <Saizan> unite?
20:20:54 <Cale> union.
20:20:59 <solrize> you mean like "<verb> is to 'x union y' as "add" is to x+y"?
20:21:04 <solrize> i think you'd just use union
20:21:08 <dibblego> I want unionate x and y
20:21:15 <dibblego> ok
20:21:20 <Cale> Or "take the union of"
20:21:20 <dibblego> *I want to...
20:21:54 <solrize> yeah, what cale says
20:21:57 <solrize> or "find the union of"
20:22:05 <solrize> "compute the union of" etc.
20:27:50 <geezusfreeek> conal: you around?
20:28:47 <conal> yep
20:29:13 <geezusfreeek> i'm interested in your thoughts on my odd new monad from the mailing list
20:30:01 <geezusfreeek> particularly whether you see any potential problems areas and if you can think of a better name for it
20:30:17 <conal> geezusfreeek: i haven't tried to internalize it.  oh -- just now saw your latest note.
20:30:56 <conal> geezusfreeek: if you're more-or-less satisfied with it (for now), i'll read it.
20:30:57 <geezusfreeek> the naming might be enough to help meâ€¦ i think i am having trouble grasping my own code because the naming is so bad
20:31:17 <geezusfreeek> i think it would be worth reading at its current stage
20:31:25 <conal> will do.
20:31:59 <geezusfreeek> and apologies for the lack of comments
20:32:19 <paczesiowa> could any of you give me example of usage of function hTIntersect ?
20:32:32 <geezusfreeek> @hoogle htIntersect
20:32:33 <lambdabot> No matches found
20:32:52 <geezusfreeek> oh HList
20:32:59 <paczesiowa> yeah
20:33:25 <geezusfreeek> i've always been afraid to even look at HList ;)
20:34:02 <conal> geezusfreeek: btw, the improvingvalues+unamb is looking more appealing to me, now that the STM direction is not staying simple.
20:34:13 <geezusfreeek> conal: yeahâ€¦ :(
20:35:13 <geezusfreeek> then again, this caching/ivar stuff could easily be abstracted out of the reactive stuff completely, but it is still a fair bit of "extra"
20:35:38 <sclv> I've been trying to relate my own issues with stm caching to the discussion, but i think I'm working on an orthagonal problem because it makes sense for me that values should only be cached if the whole transaction completes successfully...
20:35:41 <conal> geezusfreeek: having its own abstraction is a plus
20:36:00 <sclv> i.e. the whole notion of a "pure" function needing to be cached is odd to me.
20:36:36 <geezusfreeek> sclv: well, that is what the IVar stuff does by itself without this new stuff i just made today
20:37:31 <conal> We are making an odd use of STM: pure computations involving values that aren't yet known.
20:38:23 <Saizan> paczesiowa: hTIntersect (HCons 'a' Nil) (HCons (4::Int) $ HCont 'b' Nil) == HCons 'a' Nil -- is this right?
20:40:02 <Saizan> has anyone used fgl/Data.Graph.Inductive here?
20:40:14 <paczesiowa> Saizan: that works, but I have to add "instance TypeEq Char Int HFalse" to make it typecheck
20:40:55 <paczesiowa> maybe I don't understand why is it so hard to have TypeEq for all types
20:41:11 <geezusfreeek> sclv: what are your issues with stm caching? perhaps they are still related in some way?
20:41:22 <awesame> @src words
20:41:23 <lambdabot> words s = case dropWhile isSpace s of
20:41:23 <lambdabot>     "" -> []
20:41:23 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
20:41:59 <Saizan> paczesiowa: oh, maybe it wasn't packaged with the "smart" TypeEq? in the paper there's one that should work for every type, but only in GHC and it's quite type-checker dependant
20:42:09 <geezusfreeek> it would be nice to come up with a somewhat standardized solution if it is possible
20:42:22 <sclv> geezusfreeek: http://code.haskell.org/~sclv/hvac/Network/Frameworks/HVAC/Cache.hs
20:42:24 <lambdabot> http://tinyurl.com/5hws6o
20:42:33 <awesame> aw, I was hoping words would be written in terms of a function that abstracted "isSpace" out of that
20:42:37 <sclv> It works but I haven't tested it for speed.
20:42:52 <sclv> its more standard memoization/caching techniques applied over the STM monad.
20:43:22 <paczesiowa> Saizan: I'll keep reading then (I stopped after those records showed up because I don't need them/ I don't understand that I really need them)
20:44:11 <sclv> what I'd really like to do is adopt conal's "sink" model and see if I can't eventually get something that accepts cache invalidation messages.
20:44:49 <sclv> awesame: you can just copy the code and do it yourself.
20:45:03 <awesame> sclv: yeah, but that's still disappointing
20:45:25 <sclv> as i recall there's some sort of split combinator slated for inclusion in the libs soon.
20:48:09 <geezusfreeek> sclv: i haven't heard about it. do you know what it is supposed to do, exactly?
20:48:45 <sclv> the split combinator?
20:49:39 <geezusfreeek> yeah
20:49:42 <sclv> hmm... this was part of the thread: http://www.nabble.com/Proposal:-Add-split-and-splitWith-(trac--2048)-td14898094i20.html
20:49:43 <lambdabot> Title: Nabble - Haskell - Libraries - Proposal: Add split and splitWith (trac #2048), http://tinyurl.com/68bb84
20:50:23 <geezusfreeek> sclv: oh, for lists! i thought you were talking to me about stm still :P
20:50:39 <geezusfreeek> and i had no idea what split would mean in that context
20:50:43 <sclv> now *that* would be interesting.
20:51:08 <sclv> full-fledged nested transactions would be really nice, if irritating.
20:51:14 <sclv> (to implement, that is)
20:55:31 <dmwit> :t unfoldr
20:55:33 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
20:55:53 <dmwit> ?hoogle ([a] -> (b, [a])) -> [a] -> [b]
20:55:53 <lambdabot> No matches, try a more general search
20:56:01 <dmwit> Huh, I could have sworn there was something like that already.
20:56:47 <zeno> @hoogle ([a] -> Maybe [a, b]) -> b -> a
20:56:48 <lambdabot> No matches, try a more general search
20:56:57 <zeno> @hoogle ([a] -> [a, b]) -> b -> a
20:56:58 <lambdabot> No matches, try a more general search
20:57:13 <dmwit> What would [a, b] be?
20:57:24 <zeno> no idea, just trying to find something like it
20:57:38 <geezusfreeek> sclv: oh i see. your need is not to cache results _from_ stm but simply to cache data _using_ stm
20:57:40 <dmwit> [a, b] isn't a well-formed type, so you won't find anything that way.
20:57:44 <dmwit> ?hoogle [a, b]
20:57:45 <lambdabot> Data.Map.assocs :: Map k a -> [(k, a)]
20:57:45 <lambdabot> Data.Map.toList :: Map k a -> [(k, a)]
20:57:45 <lambdabot> Data.Map.toAscList :: Map k a -> [(k, a)]
20:57:48 <dmwit> ...
20:57:54 * dmwit shuts his pie-hole
20:57:58 <zeno> dmwit: ah forgot lists can have different types of elements
20:58:03 <sclv> geezusfreeek: except the data that I cache is produced from stm transactions.
20:58:21 <sclv> so its a useful property for me that if the transaction rolls back, all its results do.
20:58:28 <dmwit> zeno: Err... lists can't have different types of elements.
20:58:29 <geezusfreeek> ah
20:58:54 <zeno> typo :( /s/can/can't
20:59:06 <dmwit> ok =)
20:59:57 <sclv> if the frp model you want isn't fundamentally transactional, then yeah, it seems like stm will ultimately be a weird choice.
21:00:50 <sclv> the other thing you can do, of course, is just live with the rollbacks of caches if you can demonstrate your system won't rollback too much overall. and if you can't, then maybe there are other efficiency issues...
21:01:32 <sclv> zeno: try this
21:01:33 <dmwit> Heh: "Since this is a declarative language, surely we shouldn't be using active verbs like this?  OK I lost that argument way back in the mists of Haskell 0.0."
21:01:58 <geezusfreeek> sclv: i looked at using stm so that i could use orElse to help me with the timing, among other things. by using stm for futures i can have fairly low-overhead, deterministic combinators. that was the original plan anyway. i think it's still doable
21:02:00 <sclv> @hoogle ([a]->[(a,b)] ) -> b -> a
21:02:01 <lambdabot> No matches, try a more general search
21:02:12 <sclv> hah, well formed but still not sure what it would do.
21:03:19 <geezusfreeek> the use of orElse does mean that small rollbacks are common though, but not so much on a large scale
21:03:35 <sclv> maybe you can restrict the use of stm to where the "or else" bits are necessary rather than letting it propagate through the whole system -- or you already do that?
21:04:11 <geezusfreeek> the whole thing kind of depends on futures for its semantics
21:05:15 <geezusfreeek> the idea here is that events come in, the frp system is run, and computations are driven by the incoming events rather than on a strictly as-needed basis, hence the importance of the caching
21:05:43 <geezusfreeek> that way even if the next output is not known, intermediate values still don't have to be redone the next time around
21:06:51 <sclv> gotcha. what's the problem with just calling out to MVars via UnsafeIOToSTM? (this may be a very stupid question)
21:07:24 <sclv> of course you're "breaking" what STM should do -- but if you're turning it into something else so this doesn't disrupt any user expectations, it might be the most obvious route.
21:07:31 <geezusfreeek> sclv: not a stupid question. conal has a working implementation using just that
21:08:19 <geezusfreeek> but it has some things i see as inelegant. so far, the stm approach _has_ actually been cleaner, most of the time. it is just taking a bit of foresight to avoid problems since when they do appear they are horrible
21:09:40 <sclv> gotcha. stm all of a sudden gets very tricky when you try to get it to do things that its not supposed to, and then thinking about threads and locking comes back in spades. :-)
21:09:48 <conal> geezusfreeek: are the aspects you don't like in the current Reactive or the simple-reactive paper, or both?
21:13:06 <geezusfreeek> conal: that's an unexpectedly hard question to answerâ€¦ the paper addressed some of it, but i still just have this feeling that it could be done more cleanly. for example, racing threads just seems not ideal to me
21:13:23 <conal> geezusfreeek: okay, thanks.
21:13:57 <geezusfreeek> of course, things are not looking so clean for stm right now either
21:14:08 <geezusfreeek> i'm having fun exploring it though
21:15:26 <conal> sure.  i'm not terribly keen on the threads & racing, though i like the Future representation, which matches the semantics exactly.  and i like the semantics of unamb, separate from its implementation.
21:16:04 <sclv> geezusfreeek: ok, maybe my question wasn't clear -- I'm suggesting an STM based implementation that caches using mvars rather than tvars, using unsafeIOToStm ? conal's implementation has no STM as I recall...
21:16:08 <conal> geezusfreeek: and somehow i get the sense that the implementation is trying too hard, by bringing in threads.
21:16:08 <geezusfreeek> conal: i have to give it to you, the semantics in your paper rock
21:16:18 <conal> :) !
21:16:43 <geezusfreeek> sclv: oh, just the caching!
21:16:44 <conal> sclv: i don't think anyone has tried that angle.
21:16:52 <geezusfreeek> hmm, i haven't looked at that yet
21:17:06 <sclv> it should be simple to drop into your original code.
21:17:20 <geezusfreeek> that would definitely eliminate the need for this new monad and cruft
21:17:24 <sclv> like i said, it "breaks" stm, but in a constrained way...
21:17:35 <geezusfreeek> since it would wouldn't be rolled baclk
21:17:36 <geezusfreeek> *back
21:17:52 <geezusfreeek> conal: what do you mean "trying too hard"?
21:18:14 <geezusfreeek> sclv: nice idea. i will look into that
21:19:10 <conal> geezusfreeek: i'm using threading to solve a problem that isn't about concurrency.  just about comparing two values (times) that become more and more known.
21:19:26 <geezusfreeek> conal: oh, i was mixed up about which implementation you were talking about i guess
21:19:49 <conal> though, coincidentally (?) improving values were invented for (semantically determinate) concurrency.
21:20:08 <geezusfreeek> i think it is no coincidence
21:20:31 <conal> i'd like to understand the connection in purposes better than i do now.
21:20:32 <geezusfreeek> the two futures are concurrent to each other. we just don't want to see that concurrency from a higher level
21:22:17 <conal> geezusfreeek: FRP is *full* of concurrency (determinate and continuous), semantically.  But most of the implementation doesn't need concurrency.  Previous implementation didn't use concurrency at all, though they have the same semantics.
21:22:29 <conal> (just as concurrent, semantically)
21:26:35 <OceanSpray> why are forall statements associated with type expressions rather than type declarations?
21:26:57 <conal> OceanSpray: for higher-rank polymorphism.
21:27:50 <OceanSpray> that is to say, you don't write "forall a. f a :: Type" but rather "f :: forall a. a -> Type"
21:27:59 <OceanSpray> what, higher rank polymorphism?
21:28:02 <OceanSpray> I don't understand.
21:29:08 <conal> OceanSpray: if forall were part of type declaration syntax, we couldn't express things like "f :: (forall a. a -> a) -> ..."
21:29:08 <awesame> one thing I miss from OO languages when I use Haskell is the namespacing you get with dispatching on the 0th arg
21:29:35 <sclv> f :: a -> (forall b. b -> c) -> (c -> a -> d) -> d
21:29:35 <OceanSpray> oh, right.
21:29:45 <conal> awesame: yep.  convenient.  though restrictive without multi-methods.
21:29:50 <awesame> I like being able to make foo.get and bar.get be completely unrelated functions
21:30:03 <awesame> yeah, multi-methods would be even better
21:30:10 <OceanSpray> multiple dispatch?
21:30:16 <conal> yes
21:30:32 <OceanSpray> would it conflict with Haskell's static type system?
21:30:45 <sclv> you can simulate most of that with polymorphism though, no?
21:31:20 <OceanSpray> Wow, that feeling of deja vu is extremely strong.
21:31:31 <awesame> sclv: if I understand what "polymorphism" refers to, no, because polymorphic functions are the same function across a variety of types -- I want dramatically different functions
21:31:46 <OceanSpray> I distinctly remember asking the same question and getting the same answer.
21:31:57 <sclv> class CanGet a b | a -> b where get :: a -> b
21:32:04 <awesame> they only share a name because the mapping from english to code is Higly Imperfect
21:32:15 <awesame> oh, I see
21:32:33 <sclv> instance CanGet ClassA where get = \a b c d -> whatever
21:32:50 <conal> there are different flavors of polymorphism.  ML & Haskell emphasize parametric polymorphism.
21:32:57 <sclv> instance CanGet ClassB where get = \z -> soomething totally else.
21:33:29 <awesame> I'm still not too clear on the terminology -- I thought polymorphism referred to types like Foo a, Bar b => (a -> b)
21:34:05 <awesame> isn't [a] a "polymorphic type"?
21:34:32 <conal> awesame: *parametrically* polymorphic.
21:34:45 <awesame> oh, parametric, right
21:35:30 <awesame> hm, maybe type classes do what I want
21:35:51 <sclv> you can get multiple dispatch with that too, to a point... but it'll get painful quick.
21:36:54 <awesame> no, so the problem with type classes is that the member functions all have to share a type
21:37:00 <awesame> I want unrelated types
21:37:24 <conal> awesame: totally unrelated?  just for recycling names?
21:37:29 <sclv> awesame: first, I really don't think that you usually do want unrelated types. Second, the code I just gave you will do that...
21:37:31 <awesame> yeah, just for namespacing
21:37:52 <awesame> oh!  because of currying!
21:37:59 <sclv> I actually like that generally if you see a function you know its type without having to think about its arguments.
21:38:54 <awesame> it's nice sometimes, but I still find myself naming functions things like "formGet" where the first parameter is almost always going to be "form", and so on
21:38:54 <conal> awesame: maybe you could do "class HasFoo a where foo :: a".  but you'd lose type inference.
21:39:58 <sclv> right. the code was sloppy -- you'd actually need instance CanGet DataA (Int -> String) etc. and instance CanGet DataB (String -> String -> (Int,Float)) etc....
21:40:07 <awesame> if I called something like that "get", I'd be allocating too general a name to something too specific, so I make it more descriptive, but then all the code looks redundant
21:40:59 <sclv> awesame: once all your variables are named f g, x, y, and z, descriptive function names will be a blessing :-)
21:41:06 <awesame> heh
21:42:40 <shapr> YOW!
21:43:01 <zgold> Anybody familiar with gtk2hs? I'm looking for a widget for a list of items where each item is selectable (like a file selector, but not for files) and im having trouble finding one.
21:44:05 <sclv> seriously. you'll soon be at a point where you look at a variable named xs' and think "did they really need to stick all that in its name?"
21:45:20 <Elly> heh
21:45:28 <Elly> I used to use descriptive variable names...then I learned SML
21:45:33 <Elly> now I call them one- and two-letter names
21:47:34 <awesame> haskell is definitely exerting pressure toward shorter names
21:47:42 <awesame> perhaps I will be happiest if I just give in
21:47:52 <Elly> SML does it much more
21:48:05 <Elly> I find myself writing code where all the variables have one-letter names, but it's still readable!
21:49:31 <goalieca> > 342 * 54344.2 / 2355.5
21:49:32 <lambdabot>  7890.348715771598
21:49:49 <goalieca> lambdabot, cookie
21:50:38 <sclv> awesame: leave the kingdom of the nouns behind!
21:51:11 <sclv> a function is f, a string is s, an error is e, and a list has an s. what more do you need?
21:51:37 <sclv> oh, and a map is m.
21:52:51 <awesame> ha, it's practically hungarian notation, minus the meaningful part of the names
21:53:20 <conal> keep the nouns, and drop the verbs.  functional programming is about being, not doing.
21:53:42 <awesame> I know what to do if I have more than one function, but what if I have more than one error?
21:53:45 <sclv> nouns are just verbs waiting to happen. :-)
21:53:57 <sclv> e'
21:54:32 <awesame> you haskellers and your priming
21:54:41 <conal> sclv: i like e', and i hadn't heard that connection.  say more?
21:55:01 <awesame> although, I have to admit, xs' now sounds like a really great, meaningful variable name
21:55:10 <awesame> the haskell worms are eating my brain
21:55:28 <sjanssen> yes, xs' tells me all sorts of things
21:55:37 <sclv> conal: i think we just crossed wires. e' was just my suggestion for a 2nd error.
21:56:06 <sjanssen> it is a list, probably an elaborated version of another list in scope called xs, if any elements of xs' are in scope, I can bet they're called x'
21:56:12 <conal> sclv: oh!  i thought you meant the language e', which relates strongly to nouns vs vbs.
21:56:19 <conal> sclv: verbs
21:58:43 <conal> i'm off to bed.  woodpeckers sound the alarm early.
21:58:51 <awesame> if I'd never seen (x:xs), I'd probably have been writing (item:items) all this time, and now that just seems like a lot of keystrokes for nothing
21:59:13 <awesame> or (first:rest), or something
21:59:15 <sclv> cheers conal -- i'm off to read about the e' language :-)
21:59:34 <conal> sclv: fun!  let me know how it hits you.
22:00:27 <conal> good night #haskell.  type safely.
22:00:55 <Elly> sclv: for me lists have an r or a t, actually (heresy, I know)
22:00:58 <Elly> (r = rest, t = tail)
22:01:11 <Elly> I have been known to use x : xt
22:01:51 <sclv> sometimes it feels a bit obscure. like:
22:01:54 <sclv> @src transpose
22:01:54 <lambdabot> transpose []             = []
22:01:54 <lambdabot> transpose ([]   : xss)   = transpose xss
22:01:54 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
22:02:12 <sclv> xss is a list of xs here
22:02:25 <sclv> but then you have h and t for head and tail.
22:02:37 <sclv> it takes some thinking to come up with what makes sense in some of these contexts. :-)
22:03:06 <Elly> economy of expression is important :P
22:03:33 <sclv> like if you have (x:y:xs) then y seems wrong, and x' seems wrong, and the only sane thing seems x and x2, which just seems ugly...
22:03:35 <Elly> I think haskell/SML/scheme are all secretly affected by awareness of alpha-variance and thus feel no need to use long variable names :P
22:03:51 <Elly> hm...if you're doing that, I'd do x1 : x2 : xs
22:04:30 <sclv> right: I have a grudge against numbers in variable and function names though for some reason...
22:04:35 <Elly> hm
22:04:37 <Elly> how come?
22:04:45 <sclv> too noisy.
22:05:13 <sclv> xa:xb:xs maybe...
22:05:23 <Elly> I'm not a fan of that really
22:05:37 <Elly> yeah, I would use x1/x2/... just because they look like subscripts sort of
22:06:21 <sclv> one day true unicode programming will become a reality, then this will all be obvious :-)
22:07:51 <mokomull> yeah, I want to name variables æ—¥æœ¬èªž
22:07:52 <mokomull> :D
22:09:19 <Elly> heh
22:09:22 <Elly> that'll be fun to type
22:09:28 <mokomull> yeah
22:09:34 <mokomull> especially with the IME shift to get it done
22:09:50 <Elly> I have no idea how to type in any of the asian languages
22:10:43 <mokomull> it's rather simple... the most popular methods for both Chinese and Japanese are basically type the pronunciations on a qwerty keyboard, then choose the right character out of a list
22:11:29 * shachaf wants unicode in Nethack.
22:11:50 * Elly edges away from shachaf
22:11:50 <mokomull> I'm just happy to have it in rxvt
22:12:01 <shachaf> No more "Your knapsack cannot accommodate any more items."!
22:12:51 <Elly> I want a roguelike that isn't written in C first :P
22:13:07 <sclv> I just want to know what sort of monster a èªž would be.
22:13:15 <shapr> Looks pretty
22:13:52 <shachaf> They can add all those hallucination monsters.
22:14:44 <shachaf> "diagonally moving grid bug" :-)
22:15:26 <sclv> a lich should obviously be represented by a lamdba.
22:15:31 <awesame> sclv: that would be a language monster
22:15:55 <shachaf> They should add (:[]) , too.
22:16:23 <Elly> actually
22:16:27 <Elly> in the PLT scheme basis library
22:16:37 <Elly> they got sick of typing 'lambda' so they use unicode lambdas instead
22:17:01 * abrasive waits for someone to write NetHackskell
22:17:06 <awesame> but how do they type them?
22:17:06 <mokomull> oh G-d, PLT Scheme ><
22:17:22 <shachaf> awesame: Ctrl-\ in DrScheme, I think.
22:17:24 <mokomull> I usually flip to my LaTeX input table and press \lambda :P
22:17:46 <mokomull> (SCIM is cool and has weird and geeky input methods to complete itself)
22:17:52 * shachaf types ctrl-shift-3bb in urxvt.
22:18:15 <Elly> I've no idea how to do it in xterm-unicode
22:18:28 <shachaf> Elly: Why don't you use urxvt? :-)
22:18:29 <mokomull> 3bb?
22:18:40 <mokomull> 3bb is Ã±?
22:18:56 <awesame> someone needs to sell programmable keyboards with keys for things like lambda and <-
22:19:15 <shachaf> mokomull: Ã± is f1.
22:19:26 <mokomull> sounds like you want APL back :)
22:19:38 <awesame> replace f7-f12, who uses those anyway?
22:19:52 <sclv> os x . :-(
22:19:55 <sclv> also, quark!
22:20:23 <sclv> and, uh... WordPerfect 5
22:21:12 <awesame> so ctrl-lambda is f7, big deal
22:24:03 <zgold> gtk2hs documentation is _so_ bad
22:31:56 <kolmodin> @yarr good morning!
22:31:56 <lambdabot> Gangway!
22:40:52 <glguy> anyone want to share their improvements? :) http://hpaste.org/7276
22:51:10 <dmwit> :t mapAccumL
22:51:11 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
22:51:27 <dmwit> glguy: It might help me read it if I know what the high-level goal is. =)
22:51:57 <dmwit> :t foldl
22:51:59 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:57:46 <quicksilver> awesame: someone does.
22:58:27 <quicksilver> awesame: http://www.artlebedev.com/everything/optimus/
22:58:32 <quicksilver> awesame: totally customisable :)
22:58:32 <lambdabot> Title: Optimus Maximus keyboard
22:58:48 <awesame> oh, are they selling that thing now?
22:59:08 <awesame> I remember seeing it a while ago, but you couldn't buy it yet
22:59:23 * quicksilver nods
22:59:27 <quicksilver> I believe they are.
22:59:32 <quicksilver> you can buy it a key at a time too
23:03:01 <dmwit> :t zipWithM
23:03:03 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
23:03:27 <glguy> make_bottom xs = zipWithM f xs (tail xs)
23:03:28 <glguy>   where f x y = delete x (delete y [1..3])
23:03:46 <glguy> so: [1,2,3] ->
23:03:47 <dmwit> :t (sequence .) . zipWithM
23:03:49 <lambdabot>     Couldn't match expected type `[m a]'
23:03:49 <lambdabot>            against inferred type `[b] -> m1 [c]'
23:03:49 <lambdabot>     Probable cause: `zipWithM' is applied to too few arguments
23:04:02 <dmwit> oops
23:04:07 <dmwit> :t (sequence .) . zipWith
23:04:08 <lambdabot>     Couldn't match expected type `[m a]'
23:04:08 <lambdabot>            against inferred type `[b] -> [c]'
23:04:08 <lambdabot>     Probable cause: `zipWith' is applied to too few arguments
23:04:16 <dmwit> :t (sequence .) . zip
23:04:18 <lambdabot> forall a b. (Monad ((,) a)) => [a] -> [b] -> (a, [b])
23:04:23 <glguy> > sequence [ [3] , [1] ]
23:04:24 <lambdabot>  [[3,1]]
23:04:30 <glguy> [1,1,3] ->
23:04:39 <glguy> > sequence [ [2,3] , [2] ]
23:04:40 <lambdabot>  [[2,2],[3,2]]
23:05:48 <glguy> lots of time is spent in "rename"
23:06:10 <dons> glguy: http://www.haskell.org/pipermail/haskell-cafe/2008-April/042303.html :)
23:06:12 <lambdabot> Title: [Haskell-cafe] Re: [Haskell] Matrix multiplication, http://tinyurl.com/6ywvuc
23:06:13 <dons> fusion fun fun
23:08:27 <dmwit> :t \f -> (sequence .) . zipWith f
23:08:29 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => (a1 -> b -> m a) -> [a1] -> [b] -> m [a]
23:08:42 <dmwit> Okay, now I know what zipWithM does. =)
23:09:01 <dmwit> :t M.delete
23:09:03 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> M.Map k a
23:09:10 <dmwit> :t delete
23:09:12 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
23:10:38 <dmwit> ?check \f xs ys -> transpose (zipWith f xs ys) == zipWithM f xs (ys :: Int)
23:10:38 <lambdabot>  Couldn't match expected type `Int' against inferred type `[b]'
23:10:45 <dmwit> ?check \f xs ys -> transpose (zipWith f xs ys) == zipWithM f xs (ys :: [Int])
23:10:46 <lambdabot>  Falsifiable, after 0 tests: <() -> Int -> [()]>, [], [1,2]
23:11:16 <dmwit> oh
23:14:07 <dmwit> Well, I can't make heads or tails of this code, so I've got no suggestions. =P
23:30:55 <glguy> dons: so do you know what optimizations are enabled by the Haskell code that that C code can't do?
23:45:04 * minivan feeds a proggit troll.
23:46:24 <dolio> @quote qwe1234
23:46:24 <lambdabot> qwe1234 says: you might pass for somebody intelligent when you keep your mouth shut.
