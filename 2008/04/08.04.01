00:00:02 <Jedai> > Sum 5 * Sum 10
00:00:03 <lambdabot>   add an instance declaration for (Num (Sum t))
00:00:11 <dmwit> > ((++"hello ") ++ reverse) "dlrow"
00:00:12 <lambdabot>  "dlrowhello world"
00:00:22 <dmwit> interesting
00:00:56 <dmwit> Okay, that makes perfect sense.  Neat!
00:01:01 <dmwit> monoid++
00:03:30 <dmwit> It's a bummer though; it would have been nice to have an instance (a -> a) with mempty = id, mplus = (.).
00:04:01 <allbery_b> newtype
00:04:14 <dmwit> yeah
00:04:34 <dmwit> ?src Endo a
00:04:34 <lambdabot> Source not found. You type like i drive.
00:04:43 <dmwit> ?source Data.Monoid
00:04:43 <lambdabot> http://darcs.haskell.org/packages/4/Data/Monoid.hs
00:04:47 <allbery_b> @src Endo
00:04:47 <lambdabot> Source not found. Are you on drugs?
00:05:03 <Jedai> ?src Endo mempty
00:05:03 <lambdabot> Source not found. Sorry.
00:05:15 <dmwit> Anyway, Endo is what I wanted.
00:06:11 <Jedai> > (Endo reverse ++ Endo reverse) "hello"
00:06:12 <lambdabot>  Couldn't match expected type `t1 -> t'
00:06:40 <Jedai> > (Endo reverse `mplus` Endo reverse) "hello"
00:06:41 <lambdabot>  Couldn't match expected type `t1 -> t'
00:06:44 <dmwit> > appEndo (Endo reverse ++ Endo reverse) "hello"
00:06:44 <lambdabot>  "hello"
00:07:14 <dmwit> Also, that would be `mappend`, I think.
00:07:43 <ahunter> > let x = 3 :: Int in fromInteger . toInteger x :: Double
00:07:43 <lambdabot>  Couldn't match expected type `f Integer'
00:08:03 <dmwit> > let x = 3 :: Int in fromInteger . toInteger $ x :: Double
00:08:03 <lambdabot>  3.0
00:08:13 <Jedai> dmwit: That's what I thought too (mplus) is MonadPlus, isn't it ? but since you used mplus in your comments
00:08:27 <dmwit> Yeah, I'm just dumb. =P
00:08:39 <dmwit> You have to be careful, dumb is contagious.
00:08:45 <ahunter> dmwit: thanks. btw, is that the best way to convert x from Int to Double?
00:08:52 <Jedai> dmwit: No problem, I already have it :-)
00:08:55 <dmwit> :t fromIntegral
00:08:56 <lambdabot> forall a b. (Num b, Integral a) => a -> b
00:09:07 <dmwit> ahunter: Use that instead, I guess.
00:09:10 <ahunter> that looks a little cleaner.
00:09:29 <ahunter> :t toIntegral
00:09:30 <lambdabot> Not in scope: `toIntegral'
00:09:39 <dmwit> No such thing, sorry. =)
00:09:49 <ahunter> :t round
00:09:50 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
00:09:59 <ahunter> Think that'll do...
00:10:00 <Jedai> ahunter: There's a page on the wiki on numeric conversion
00:10:02 <dmwit> See also: floor, ceiling
00:10:28 <Jedai> :t realToFrac
00:10:29 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
00:10:47 <dmwit> :t approxRational
00:10:48 <lambdabot> forall a. (RealFrac a) => a -> a -> Rational
00:10:55 <dmwit> Now that is a truly remarkable function.
00:11:51 <dmwit> > approxRational pi 0.001
00:11:52 <lambdabot>  201%64
00:12:18 <dmwit> > 201/64
00:12:19 <lambdabot>  3.140625
00:12:37 <ahunter> > approxRational pi (pi + 0.0001)
00:12:38 <lambdabot>  0%1
00:12:49 <ahunter> oooh
00:12:56 <dmwit> The second argument is the epsilon within which you want the estimate to lie.
00:13:09 <dmwit> > approxRational pi 1
00:13:09 <lambdabot>  3%1
00:13:28 <ahunter> that was my second guess.  I've been doing enough real analysis recently that my first guess was "find a rational number between these two reals."
00:13:29 <dmwit> > approxRational pi 0.00000001
00:13:30 <lambdabot>  100798%32085
00:14:04 <dmwit> ahunter: It doesn't just find *some* rational in that range; it finds the "simplest" rational (for a really nice definition of simplest).
00:14:27 <shachaf> > approxRational pi 0.000001 -- Easier to remember. :-)
00:14:27 <lambdabot>  355%113
00:14:38 <dmwit> pretty
00:14:41 <dmwit> > 355/113
00:14:41 <lambdabot>  3.1415929203539825
00:14:58 <ahunter> dmwit: no, I was thinking that maybe approxRational 3 4 gave you 7/2. :P
00:14:59 <Jedai> > pi
00:15:00 <lambdabot>  3.141592653589793
00:15:08 <Japsu> > 355/113 - pi
00:15:09 <lambdabot>  2.667641894049666e-7
00:15:14 <dmwit> ahunter: heh
00:15:35 <Japsu> > log (exp 1)
00:15:36 <lambdabot>  1.0
00:15:46 <dmwit> > approxRational (exp 1) 0.0003
00:15:47 <lambdabot>  193%71
00:16:03 <dmwit> ?quote approx
00:16:03 <lambdabot> No quotes match. Where did you learn to type?
00:16:07 <dmwit> ah well
00:16:16 <dmwit> I should go do something actually productive.
00:16:39 <Japsu> productiveness is overrated
00:19:42 <dons> ?seen glguy
00:19:42 <lambdabot> I saw glguy leaving #haskell 32m 2s ago, and .
00:36:29 <luqui> > approxRational 30 1
00:36:30 <lambdabot>  29%1
00:36:33 <luqui> that seems... wrong
00:36:52 <dmwit> 29 < 30
00:37:03 <dmwit> Therefore, 29/1 is simpler than 30/1.
00:37:21 <dmwit> > approxRational 30 0.99999
00:37:22 <lambdabot>  30%1
00:37:36 <luqui> hmm okay
00:38:21 <ahunter> @src runState
00:38:21 <lambdabot> Source not found. Just try something else.
00:38:33 <dmwit> ?src State
00:38:33 <lambdabot> Source not found. My mind is going. I can feel it.
00:38:54 <luqui> newtype State s a = State { runState :: s -> (a,s) }
00:38:59 <dmwit> newtype State s a = State { runState :: (s -> (a, s)) }
00:39:08 <luqui> ha! beatcha!
00:39:11 <dmwit> blah, beat
00:39:15 <dmwit> =P
00:39:15 <luqui> again!
00:39:24 * dmwit takes some typing lessions
00:44:59 <dolio> Static typing lessons?
00:45:55 <dmwit> I have typing lesions all over my skin.
00:49:17 <ahunter> OK, this is stupid, but why can't I find Control.Monad.State?
00:49:54 <dolio> Perhaps your Haskell install is playing an April fools day prank on you.
00:50:58 <dolio> Or, check if mtl is installed.
00:53:00 <ahunter> mtl?
00:53:10 <mountain> A puzzle: http://www.cs.uu.nl/wiki/bin/viewfile/Afp/Assignments?rev=2;filename=Assign7.pdf , I tried it for half a day, but no result. any body can help? or some hint?
00:53:12 <lambdabot> http://tinyurl.com/2rfrae
00:53:48 <dmwit> ahunter:
00:53:51 <dmwit> ?where hackage
00:53:51 <lambdabot> http://hackage.haskell.org/
00:53:57 <dolio> Monad template library (I think). It's the package with Control.Monad.State, Reader, Writer...
00:54:17 <dolio> It usually comes with GHC, but some distributions package it separately.
00:55:30 <ahunter> dolio: interesting.  happen to know if it's in some debian package offhand, while I dig through aptitude?
00:55:44 <mountain> The main problem is that - could we write a well-typed function that can take arbitrary parameters?
00:55:52 <dmwit> ahunter: It's in a package
00:56:07 <dmwit> libghc6-mtl-dev I think
00:56:09 <dolio> ahunter: Look for a package named mtl.
00:56:17 <dolio> Or, with mtl in it, that is.
00:56:29 <ahunter> ah, found it--dmwit is right, thank you...
00:58:12 <dmwit> mountain: It shouldn't be too difficult.
00:58:32 <dmwit> mountain: As a hint, it looks like what you're learning about right now is type-classes, so see if you can use them to do what you want.
00:58:53 <dmwit> mountain: Note that "count" must, in fact, have different types in each of the invocations in the example.
00:59:06 <dmwit> mountain: (Which is fine; that's what type classes are all about.)
00:59:15 <mountain> thanks
01:03:28 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6765
01:05:11 * dolio still can't connect to hpaste...
01:05:18 <dmwit> WFM
01:06:46 <dolio> Man, 2003 was a big year for jokes on the haskell list, it seems.
01:07:06 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6766
01:09:05 <dolio> Galois homework help, bank account scam with Haskell Curry...
01:09:42 <dolio> Increase performance with Y-agra.
01:17:01 <dmwit> ?pl \m -> const (f . (+1) $ m)
01:17:01 <lambdabot> const . f . (1 +)
01:17:11 <ahunter> Erm...do I need special compiler flags to compile stuff that uses MTL (specifically, Control.Monad.State)
01:17:40 <dmwit> You shouldn't.
01:17:45 <dmwit> Why?
01:18:13 <ahunter> Compiling a trivial test program that uses Control.Monad.State, I get a bunch of linker errors about missing references to <long,mangled name that includes C.M.S>
01:18:26 <dolio> Sounds like you need --make
01:18:35 <ahunter> Fixed.
01:18:36 <dolio> At a guess, at least.
01:18:42 <cjs> that's an interesting problem, that second one.
01:18:53 <dmwit> cjs: Yup, not too much more difficult, though.
01:21:33 <dmwit> :t lift ask
01:21:35 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, MonadReader a m) => t m a
01:22:01 <dmwit> ?unmtl ReaderT a Reader b
01:22:01 <lambdabot> err: `Reader b' is not applied to enough arguments, giving `/\A. b -> A'
01:22:10 <cjs> How do I do a lambda with no args?
01:22:17 <dmwit> ?unmtl ReaderT a Reader b c
01:22:17 <lambdabot> err: `Reader b' is not applied to enough arguments, giving `/\A. b -> A'
01:22:21 <ahunter> OK, I grow slowly closer to being able to use State transformers...
01:22:36 <dmwit> cjs: f = 3?
01:22:56 <dmwit> cjs: But if you're doing the second part of the second problem, you have to be a bit more clever than that. =)
01:22:56 <cjs> I want an anonymous function with no args, something like \ -> 3.
01:23:12 <quicksilver> cjs: in haskell there is no difference between 3 and \ -> 3
01:23:17 <quicksilver> cjs: therefore, we just write 3
01:23:19 <dolio> There are no anonymous functions with no args.
01:23:34 <dolio> Unless you count something like \() -> ...
01:23:42 <quicksilver> cjs: (you can't tell the difference between a function and a value in a lazy language)
01:23:45 <cjs> I don't; that's got an argument.
01:23:48 <dmwit> dolio: That has an argument.
01:23:54 <cjs> Hmmm. Interesting.
01:24:08 <dmwit> cjs: Do you want a hint?
01:24:13 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6767
01:24:47 <cjs> Give me a few minutes.
01:24:56 <dolio> dmwit: Yeah, but it looks similar to, say, a zero-argument procedure in scheme.
01:25:06 <dmwit> dolio: ah
01:25:11 <ahunter> http://hpaste.org/6767 I think I may be doing this backwards, but can someone tell me why I'm getting infinite type errors here?  I'm trying to set up some threaded state through an IO monad using StateT (obviously the state is an RNG.)
01:25:21 <dolio> And it's what you'd use in O'Caml to eta-expand to delay evaluation.
01:25:56 <dmwit> :t StateT
01:25:57 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
01:26:28 <ahunter> :t StateT produces StateT :: (s -> m (a, s)) -> StateT s m a on actual GHCI. :P
01:26:29 <lambdabot> parse error on input `.'
01:26:54 <dmwit> :t randomR
01:26:55 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
01:27:10 <dmwit> ahunter: Try to reconcile those two types. ;-)
01:27:36 <dmwit> ahunter: randomR isn't monadic enough.
01:27:38 <ahunter> ok, yeah, that's not going to work so hot, is it.
01:28:26 <dmwit> ahunter: (Probably the same problem in the next line, too.)
01:28:32 <ahunter> dmwit: can I lift randomR somehow?
01:28:59 <dmwit> :t lift
01:28:59 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
01:29:08 <dmwit> hum
01:29:18 <dmwit> ?hoogle State s a -> StateT s m a
01:29:18 <lambdabot> No matches, try a more general search
01:29:24 <ahunter> just saying "getRandomR range = State (lift $ randomR range)" gives me both type and kind errors, unfortunately
01:29:30 <ahunter> which is not surprising
01:29:36 <ahunter> erm, StateT, but same errors.
01:29:47 <dmwit> ahunter: Well, you can.
01:29:59 <dmwit> ahunter: I have some philosophical issues with what you're doing here, though. =P
01:30:11 <ahunter> dmwit: shoot
01:30:22 <dmwit> ahunter: (What you can do is put a well-placed return to put the result of randomR into the IO monad.)
01:30:48 <dmwit> ahunter: I'm worried a little bit about mixing the random-ness and the IO-ness here, though, unless it's to learn how to use transformers.
01:30:49 <ahunter> Or whatever monad I'm transforming State around, I'd assume.
01:31:13 <dmwit> of course
01:31:20 <ahunter> dmwit: I'm working on a benchmark program that needs to (predictably) use a RNG to generate data whivh is then used inside the IO monad.
01:31:31 <dmwit> ?go MonadRandom
01:31:32 <lambdabot> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
01:31:32 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
01:32:46 <dmwit> ahunter: I would prefer to get all the random numbers necessary in a State monad, then runState from within the IO monad.
01:35:50 <ahunter> dmwit: I see...and then just handle holding on to the generator and passing it to the next point the program needs random numbers by hand?
01:36:44 <ahunter> I had thought the point of StateT as all is that I could be working monadically (in IO, STM, Maybe, whatever) and always have a state handy to pull things out of
01:37:14 <dmwit> ahunter: No, I don't think keeping the generator around is a great idea; I agree that that's what State is for.
01:37:34 <dmwit> ahunter: As I say, I'd generate all my randomness up front, then just keep the results and throw away the generator.
01:37:48 <dmwit> Here, let me annotate your example to show what I mean.
01:38:01 <ahunter> dmwit: cool, that'd be vrey informative, thanks
01:38:52 <ahunter> dmwit: my concern is that the structure of the benchmark I'm working on (I'm translating something specific) may not really bend to that--what it does later often depends on both the random numbers selected earlier and the th code thus executed, but I can try
01:39:21 <dmwit> ahunter: Ah, well in that case StateT is certainly indicated.
01:40:00 <dmwit> :t State
01:40:01 <lambdabot> forall s a. (s -> (a, s)) -> State s a
01:40:07 <dmwit> :t randomR
01:40:08 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
01:40:24 <ahunter> with some thought, though, I think I may be able to push the RNGs forward, I'll definitely try to, as I see the advantage
01:42:30 <dmwit> :t evalState
01:42:30 <lambdabot> forall s a. State s a -> s -> a
01:42:34 <Staz> Does anybody have a url to a site detailing why foldr has the type (a -> b -> b) -> b -> [a] -> b ?
01:42:38 <ask42> Hello! I am trying to build ghc from a src tarball. I'd like to generate the file libHSghc_p.a but am unable to achieve this. I tried to "export ways=profc" and called make, but the file is not made. Does anybody know how to generate the "_p" files?
01:43:00 <Jedai> @where folds
01:43:00 <lambdabot> http://cale.yi.org/index.php/Fold_Diagrams
01:43:25 <hpaste>  dmwit annotated "(no title)" with "separation" at http://hpaste.org/6767#a1
01:43:38 <Staz> Jedai : thankyou
01:43:41 <Jedai> Staz: This site has some diagrams to understand foldr and foldl
01:43:57 <dmwit> ahunter: That annotation was for you.
01:44:47 <dmwit> ahunter: That's not exactly how I would write it, probably, but it's probably also a bit more readable than how I would write it. =P
01:45:09 <ahunter> Thanks.  I also worked out the proper placement of Return in case I need the StateT.  That was lots of help. :P
01:46:38 <ahunter> dmwit: oh, and fyi, I annotated your annotation so it works :P
01:46:50 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/6767#a2
01:47:21 <Staz> Jedai : I understand how it works -- just not the type.
01:47:42 <dmwit> Ah, yeah, fmap . replicate is not what you wanted.
01:47:46 <quicksilver> Staz: it takes a function to fold, an initial value, and a list to fold over.
01:47:49 <Jedai> Staz: What's the problem with the type ?
01:47:51 <quicksilver> Staz: which part of the type is foxing you?
01:48:10 <Staz> I guess the function (a -> b -> b) seems a little weird
01:48:24 <ahunter> dmwit: yeah, that gets me one random number 20 times :P
01:48:33 <Staz> doesn't every element in a list have the same type?
01:48:44 <Jedai> Staz: Yes, it's a
01:48:57 <Jedai> Staz: The initial value has type b
01:49:23 <Jedai> Jedai: f is called with the last element of the list and the initial value
01:50:18 <Jedai> Staz: And it must return a value of type b so that is can be called again with the penultimate element of the list and the result of the last call, and so on
01:50:38 <Jedai> @src foldr
01:50:39 <lambdabot> foldr f z []     = z
01:50:39 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
01:50:43 <Staz> I'll ponder that -- cheers Jedai :)
01:50:47 <quicksilver> Staz: as a particular case you could have a = b
01:51:02 <quicksilver> Staz: then foldr :: (a -> a -> a) -> a -> [a] -> a
01:51:14 <quicksilver> Staz: that's a valid type for it, but it's a sub-case
01:51:19 <quicksilver> the separate b is slightly more general.
01:51:26 <Staz> ahh that makes sense
01:51:39 <quicksilver> the accumulator doesn't have to be the same type as the list
01:51:47 <quicksilver> although in a lot of the common examples, it will be.
01:52:09 <quicksilver> > foldr (\a b -> b ++ show a) "" [1..9]
01:52:11 <lambdabot>  "987654321"
01:52:14 <Staz> got a good example where it isn't?
01:52:24 <quicksilver> Staz: there. the list is integers but the accumulator is strings
01:54:37 <Jedai> > foldr (\x ~(xs,ys) -> (ys,x:xs)) ([],[]) [1..10]
01:54:38 <lambdabot>  ([2,4,6,8,10],[1,3,5,7,9])
01:54:44 <Staz> quicksilver : what on earth happens in here? --> (\a b -> b ++ show a)
01:55:00 <Staz> '\a' is a bit of syntax I have not seen before
01:55:44 <Jedai> Staz: If you haven't seen the lambda expression yet it may be too soon to worry yourself over the type of foldr
01:56:08 <Jedai> Staz: (\x -> x + 2) is the function which add 2 to its parameter
01:56:17 <Jedai> > (\x -> x + 2) 5
01:56:18 <lambdabot>  7
01:56:31 <quicksilver> Staz: that's a little function with two parameters called a and b
01:56:37 <quicksilver> Staz: a is an integer, b is a string
01:56:52 <quicksilver> Staz: "show" converst the integer to a string, and ++ concatenates that string onto b.
01:57:14 <Staz> I have read chapters [1..6] in the Haskell SOE today -- have not seen amda expressions yet.
01:57:21 <Staz> s/amda/lamda/
01:57:54 <Jedai> Staz: \ looks a little bit like the greek letter lambda (if you haven't done any lambda-calculus it shouldn't say you anything...)
01:58:06 <Staz> Jedai : doesn't the function (+ 2) do the same thing?
01:58:11 <quicksilver> yes
01:58:18 <quicksilver> (+2) is shorthand for (\x -> x+2)
01:58:23 <Staz> ahh :)
01:58:29 <quicksilver> and (2+) is shorthand for (\x -> 2+x)
01:58:35 <quicksilver> and (+) is shorthand for (\x y -> x + y)
01:58:43 <Jedai> Staz: Yes, it's a "section", you can do that with any binary operator
01:59:16 <Jedai> Staz: But lambda expressions are more general : (\x y -> if x then y else 0)
01:59:35 <Jedai> That can't be expressed with section
02:00:07 <cjs> So what's the issue with "instance Count (a -> Int) where ..."
02:00:24 <cjs> I can do (a -> b), but not (a -> Int).
02:00:30 <Staz> Jedai, quicksilver : thank you very much for your help. I'll read over our conversation thoroughly.
02:02:17 <quicksilver> cjs: it's an over-conservative haskell-98 restriction
02:02:26 <quicksilver> cjs: you can turn it off in GHC with -XFlexibleInstances
02:02:38 <cjs> Ah, ok.
02:02:41 <quicksilver> (the haskell98 workaround is a newtype)
02:06:32 <cjs> Damn, I spent like half an hour trying to work around that, thinking there must be something bad about it.
02:11:16 <glowwormy> Hi
02:14:35 <glowwormy> > map (+1) [1..10]
02:14:35 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
02:16:08 <glowwormy> I have the following infinite list depending on a parameter t:
02:16:31 <glowwormy> preproj t= (0,1): (1,t): map ( \(x,y) ->  (t*y - x, (t*t - 1)*y -t*x)) (preproj t)
02:16:59 <glowwormy> If I use it like this and want to access, say the 10000 entry, it takes very long.
02:17:27 <glowwormy> However, if I hardcode t and make an infinite list without parameter, then it is very fast.
02:17:41 <glowwormy> Any Idea how I can solve this?
02:18:31 <solrize_> hmm
02:18:45 <solrize_> sounds like you need a strictness annotation?
02:19:26 <glowwormy> I never used strictness...
02:19:33 <glowwormy> where would I need it?
02:19:36 <solrize_> i'm not sure how to do it and am too sleepy to figure it out
02:19:45 <solrize_> hmm
02:20:06 <glowwormy> Strictness about t then?
02:20:11 <solrize_> maybe not
02:20:34 <solrize_> what happens if you write it explicitly as a recurrence
02:21:10 <glowwormy> As a function you say?
02:21:20 <solrize_> yeah
02:23:32 <glowwormy> Yes, this is much faster.
02:23:52 <glowwormy> I would have expected the list to be faster...
02:24:10 <glowwormy> Can you explain why?
02:24:43 <solrize_> that formula gets really enormous as you go further out in the list
02:25:44 <Jaak> and ghc strictness analysis is poo
02:26:14 <Jaak> last time i checked it couldnt even make foldl properly strict
02:27:28 <glowwormy> How can I define the right strictness?
02:27:43 <solrize_> if you just want the 10000th entry maybe you can use iterate
02:27:49 <solrize_> :t iterate'
02:27:49 <lambdabot> Not in scope: `iterate''
02:27:53 <solrize_> :(
02:28:02 <vegai> :t iterate
02:28:03 <lambdabot> forall a. (a -> a) -> a -> [a]
02:28:20 <vegai> oh.
02:29:04 <solrize_> i'm not sure
02:31:19 <Staz> @src foldl
02:31:19 <lambdabot> foldl f z []     = z
02:31:19 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
02:31:32 <Staz> lamdabot ftw
02:32:00 <solrize_> @src foldl'
02:32:00 <lambdabot> foldl' f a []     = a
02:32:00 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
02:32:01 <Staz> possible to view function src from my 'hugs' interpreter?
02:32:34 <dc-Ankan> @seen skorpan`
02:32:35 <lambdabot> I haven't seen skorpan`.
02:34:24 <solrize_> > let preproj t= (0,1): (1,t): map ( \(x,y) ->  let a=(t*y - x, (t*t - 1)*y -t*x) in a `seq` a) (preproj t) in take 5 preproj 0.5
02:34:25 <lambdabot>  Couldn't match expected type `[a]'
02:34:53 <solrize_> > let preproj t= (0,1): (1,t): map ( \(x,y) ->  (t*y - x, (t*t - 1)*y -t*x)) $! (preproj t) in (take 5 $ preproj 0.5)
02:34:53 <lambdabot>  Couldn't match expected type `[(t, t1)]'
02:35:15 <solrize_> > let preproj t= (0,1): (1,t): (map ( \(x,y) ->  (t*y - x, (t*t - 1)*y -t*x)) $! (preproj t)) in (take 5 $ preproj 0.5)
02:35:16 <lambdabot>  [(0.0,1.0),(1.0,0.5),(0.5,-0.75),(-0.75,-0.875),(-0.875,0.3125)]
02:35:30 <solrize_> > let preproj t= (0,1): (1,t): (map ( \(x,y) ->  (t*y - x, (t*t - 1)*y -t*x)) $! (preproj t)) in (preproj 0.5 !! 20)
02:35:31 <lambdabot>  (0.9732532501220703,0.577946662902832)
02:35:37 <solrize_> > let preproj t= (0,1): (1,t): (map ( \(x,y) ->  (t*y - x, (t*t - 1)*y -t*x)) $! (preproj t)) in (preproj 0.5 !! 50)
02:35:37 <lambdabot>  (6.980724282894535e-2,-0.9802613317067452)
02:35:42 <solrize_> > let preproj t= (0,1): (1,t): (map ( \(x,y) ->  (t*y - x, (t*t - 1)*y -t*x)) $! (preproj t)) in (preproj 0.5 !! 2000)
02:35:42 <lambdabot>  (-0.43608006578614267,-1.015507490276128)
02:35:46 <solrize_> > let preproj t= (0,1): (1,t): (map ( \(x,y) ->  (t*y - x, (t*t - 1)*y -t*x)) $! (preproj t)) in (preproj 0.5 !! 10000)
02:35:49 <lambdabot> Terminated
02:35:57 <solrize_> > let preproj t= (0,1): (1,t): (map ( \(x,y) ->  (t*y - x, (t*t - 1)*y -t*x)) $! (preproj t)) in (preproj 0.5 !! 3000)
02:35:58 <lambdabot>  (0.819772800822788,-0.403311902807598)
02:36:02 <solrize_> > let preproj t= (0,1): (1,t): (map ( \(x,y) ->  (t*y - x, (t*t - 1)*y -t*x)) $! (preproj t)) in (preproj 0.5 !! 4000)
02:36:03 <lambdabot>  (0.7906022344438454,0.8410896390308725)
02:36:05 <glowwormy> t shoulb be an integer...
02:36:06 <Jaak> .
02:36:13 <solrize_> > let preproj t= (0,1): (1,t): (map ( \(x,y) ->  (t*y - x, (t*t - 1)*y -t*x)) $! (preproj t)) in (preproj 1 1000)
02:36:14 <lambdabot>  Couldn't match expected type `t1 -> t'
02:36:19 <glowwormy> but it doesn't really matter.
02:36:20 <solrize_> > let preproj t= (0,1): (1,t): (map ( \(x,y) ->  (t*y - x, (t*t - 1)*y -t*x)) $! (preproj t)) in (preproj 1 !! 1000)
02:36:21 <lambdabot>  (-1,-1)
02:36:25 <solrize_> > let preproj t= (0,1): (1,t): (map ( \(x,y) ->  (t*y - x, (t*t - 1)*y -t*x)) $! (preproj t)) in (preproj 2 !! 1000)
02:36:25 <lambdabot>  (1000,1001)
02:36:29 <solrize_> > let preproj t= (0,1): (1,t): (map ( \(x,y) ->  (t*y - x, (t*t - 1)*y -t*x)) $! (preproj t)) in (preproj 5 !! 1000)
02:36:30 <lambdabot>  (618234476048015915158674605576541752161658359067893258598806779985811140254...
02:36:35 <solrize_> > let preproj t= (0,1): (1,t): (map ( \(x,y) ->  (t*y - x, (t*t - 1)*y -t*x)) $! (preproj t)) in (preproj 3 !! 1000)
02:36:35 <lambdabot>  (422469633339230487870672560234148278257985284025068109801028013731430858437...
02:36:37 <Jaak> stop. it.
02:36:50 <solrize_> anyway the $! seems to have sped it up?
02:37:06 <Japsu> code golf <3
02:37:18 <Jaak> that's not code golf
02:37:30 <Botje> strictness golf!
02:37:40 <Jaak> not even that, that was just spam :P
02:39:59 <glowwormy> No, it didn't speed up.
02:40:09 <glowwormy> The function is still much faster.
02:41:13 <dolio> cjs: The second part is a little tricky.
02:41:24 <cjs> Indeed.
02:41:40 <glowwormy> which second part?
02:42:02 <cjs> Actually, I can't even get the first part.
02:42:02 <Jaak> > let preproj t = let f (x,y) = (t*y - x, (t*t - 1)*y -t*x); loop = (0,1): (1,t) : map f loop in loop in (preproj 5) !! 1000
02:42:03 <lambdabot>  (618234476048015915158674605576541752161658359067893258598806779985811140254...
02:42:11 <Staz> penutimate == "next to the last". What is the terminology for "next to the first"?
02:42:28 <solrize_> second ...
02:42:36 <dolio> :)
02:42:39 <Staz> s/penutimate/penultimate/
02:42:42 <dmwit> cjs: You should be able to get both parts with no GHC extensions.
02:42:57 <dolio> Staz: Second?
02:43:01 <Staz> haha good point
02:43:19 <cjs> Well, I'll sleep on it.
02:43:26 <vegai> are you sure you cannot turn it into cool latinese? :P
02:43:27 <yitz> Staz: postinitial
02:43:31 <vegai> ah, there we go
02:43:39 <Staz> very nice :)
02:43:50 <Staz> I must need sleep!
02:44:03 <Staz> that was a rediculous question
02:45:37 <glowwormy> The loop version is as fast as the function!
02:48:45 <glowwormy> So the trick is to define the function of t first and then the infinite list?
02:49:27 <dmwit> :t runStateT
02:49:28 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
02:49:55 <Jaak> trick is to fool ghc's strictness analyser. it should also be fast if you throw some seqs or bang patterns around
02:50:12 <dmwit> ?src MonadTransformer
02:50:12 <lambdabot> Source not found. Do you think like you type?
02:50:37 <dmwit> ?src MonadTrans
02:50:37 <lambdabot> Source not found. That's something I cannot allow to happen.
02:50:41 <cjs> Ooo, lambdabot is snarky.
02:51:53 <solrize_> i think glowwormy is using hugs
02:52:05 <glowwormy> nope, ghci
02:52:12 <solrize_> oh ok
02:52:26 <glowwormy> The Glorious Glasgow Haskell Compilation System, version 6.6
02:55:46 <dmwit> ?source Control.Monad.Reader
02:55:46 <lambdabot> http://darcs.haskell.org/packages/3/Control/Monad/Reader.hs
02:55:57 <dmwit> bah
02:58:00 <Cheery> I'd like to know more about haskell's runtime.
02:58:14 <Cheery> I thought first thing preferable to look into would be the GC
02:58:37 <Cheery> but I can't find the GC.
03:00:52 <cjs> What's the clever way to do an hGetChar n times?
03:00:59 <dmwit> replicateM
03:06:04 <cjs> Nice.
03:14:11 <dmwit> Hum.
03:14:18 <dmwit> I find problem 4 there to be quite tricky.
03:14:41 <dmwit> I don't really understand how to implement monad transformers, really.
03:15:57 <sjanssen> @src ReaderT
03:15:57 <lambdabot> Source not found. I am sorry.
03:16:01 <sjanssen> bah
03:16:15 <sjanssen> dmwit: problem 4?
03:17:12 <dmwit> http://www.cs.uu.nl/wiki/bin/viewfile/Afp/Assignments?rev=2;filename=Assign7.pdf
03:17:13 <lambdabot> http://tinyurl.com/2rfrae
03:17:28 <dmwit> Somebody in here was asking about their homework. =)
03:17:43 <dmwit> I got interested, and now I'm neglecting mine.
03:17:44 <dmwit> heh
03:18:07 <sjanssen> oh, they do know that the author hangs out here, right? :)
03:18:39 <dmwit> Heh, I don't know.
03:19:05 <dmwit> They were pretty respectful of the no-homework policy, though, they just wanted a nudge.
03:19:53 <sjanssen> fun homework
03:19:56 <dmwit> agreed
03:22:16 <TSC> The "count" function looks interesting
03:24:17 <cjs> Very.
03:25:49 <Staz> @src scanl
03:25:49 <lambdabot> scanl f q ls = q : case ls of
03:25:49 <lambdabot>     []   -> []
03:25:49 <lambdabot>     x:xs -> scanl f (f q x) xs
03:30:45 <kosmikus> dmwit: who's asked, and when?
03:31:06 <dmwit> Whoo boy.
03:32:11 <hpaste>  dmwit pasted "scrollback" at http://hpaste.org/6768
03:32:20 <dmwit> kosmikus: Did I say too much?
03:32:29 <dmwit> (Did I do a bad thing?)
03:33:17 <TSC> It seemed clear to me too that classes were the way to go, given the first question
03:33:29 <kosmikus> dmwit: no, not at all
03:33:40 <kosmikus> dmwit: thanks
03:36:27 <kosmikus> TSC: indeed, I would have expected that to be quite obvious
03:39:04 <kosmikus> TSC, dmwit: then again, I'm not sure if this actually was one of my students ...
03:39:12 <dmwit> true
03:39:17 <Jedai> glowwormy:  If you're still around, I could tell you what was the problem with your preproj (not strictness)
03:39:34 <dmwit> kosmikus: But I'm not your student, and I knew that type classes were the way to go...
03:39:39 <jpnp> Hi, are there any vim users here?
03:39:39 <jpnp> What do you use for indenting .hs/.lhs/
03:39:55 <dmwit> jpnp: :set autoindent is basically the state of the art just now.
03:40:27 <kosmikus> dmwit: sure :)
03:40:36 <opqdonut> most people use emacs for indenting haskell :>
03:41:06 <cjs> I'm a vim user, and yes, autoident.
03:41:13 <jpnp> I'd like something that Does The Right Thing with Bird Tracks
03:41:24 <cjs> Ouch.
03:41:49 <dmwit> mmm
03:42:01 <dmwit> jpnp: How much do you like to hack on vimscript? =P
03:42:34 <cjs> BTW, also: set expandtab.
03:42:42 <jpnp> dmwit: Never done so, and was hoping to spend my time hacking haskell ;-)
03:43:42 <cjs> Actually, there is a way to get vim to do the right thing with bird tracks, or might be. I can't remember the setting, but you can get it to repeat an initial character from a previous line.
03:43:57 <dmwit> jpnp: Well, make sure you :set ft=lhs, but I really don't think there's anything explicitly fori t.
03:44:22 <dmwit> (If you open a file with extension .lhs, that will get set for you.)
03:46:46 <dmwit> What's the other minimal pair for defining a monad?
03:46:55 <dmwit> return/(>>=) or join/???
03:47:08 <dmwit> Hmm, must be a triple.
03:49:55 <dolio> return/join
03:50:04 <dolio> Since you have fmap from it being a functor.
03:50:11 <dmwit> :t fmap
03:50:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:50:17 <dmwit> aha
03:50:37 <dolio> m >>= f = join (fmap f m)
03:51:48 <dmwit> ?src Functor
03:51:48 <lambdabot> class  Functor f  where
03:51:48 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
03:55:01 <nornagon> :t \f m -> join (fmap f m)
03:55:02 <lambdabot> forall a (m :: * -> *) a1. (Monad m, Functor m) => (a -> m a1) -> m a -> m a1
03:55:23 <nornagon> that doesn't quite click
03:56:07 <matthew_-> what's the rejection ratio for ICFP?
03:56:33 <dolio> :t \m f -> join (fmap f m)
03:56:34 <lambdabot> forall a (m :: * -> *) a1. (Monad m, Functor m) => m a -> (a -> m a1) -> m a1
03:57:01 <dolio> :t (>>=)
03:57:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
03:57:54 <dmwit> nornagon: fmap f x -- (f :: a -> m b, x :: m a), and fmap applies f to each value that "x" contains, so we get (fmap f x :: m (m b)).
03:58:13 <dmwit> nornagon: Then "join" turns the "m (m b)" into a plain old "m b".
04:00:11 <quicksilver> matthew_-: specifically I don't know, but for good conferences it's normally about 90%.
04:00:32 <matthew_-> oh, 10:1 ish then?
04:00:50 <quicksilver> yeah
04:00:54 <matthew_-> I thought it was scarier than that - 100:1 but I must be exaggerating
04:01:07 <quicksilver> good conferences tend to vary from 5:1 to 10:1, from the referees I've spoken to
04:01:28 <matthew_-> HW07 was 4:1
04:01:34 <matthew_-> ish, from what I've heard
04:02:56 <nornagon> dmwit: ah, d'oh :)
04:03:42 <nominolo> Wow, Fortress choses the same date for 1.0 as Haskell did 18 years ago.  Coincident?
04:04:18 <matthew_-> haskell can legally drink?
04:04:26 <matthew_-> I like it even more ;)
04:04:30 <dmwit> And then some.
04:04:43 <dmwit> Isn't Haskell nearly 30 years old now?
04:04:52 <matthew_-> are you including gopher in that?
04:05:11 <daniel_larsso1> haskell was born in the late 80s I thought
04:05:17 <nominolo> the haskell 1.0 report is from  1 Apr 1990
04:05:37 <nominolo> late 80s was conception date ;)
04:05:50 <daniel_larsso1> Yes )
04:06:14 <sjanssen> nominolo: are you sure that's right?
04:06:28 <sjanssen> IIRC, it was the first version of GHC that came out on April 1
04:06:53 <nominolo> http://66.102.9.104/search?q=cache:aobrnV7FHtwJ:research.microsoft.com/~simonpj/papers/haskell-retrospective/HaskellRetrospective-2.pdf+haskell+1.0&hl=sv&ct=clnk&cd=27&gl=se&client=firefox-a
04:06:54 <lambdabot> http://tinyurl.com/398oor
04:07:12 <nominolo> it's certainly debatable
04:07:58 <sjanssen> nominolo: nope, you're right
04:11:21 <Ogedei> gentoo's ghc package does not appear to provide the runhaskell command. is there some equivalent trick using ghci or something?
04:11:32 <sjanssen> Ogedei: use runghc
04:11:40 <Ogedei> sjanssen: thanks!
04:15:25 <cjs> So if I've got a server asynchronously reading responses and generating requests, which requests are generated based on information recently received in the responses, what's the best way to go about that? A couple of threads and STM?
04:18:18 <quicksilver> probbably more than a couple of threads
04:18:26 <quicksilver> probably two per connection
04:18:44 <quicksilver> and STM if the problem wrrants it but MVars and Chans for simpler cases.
04:19:21 <yitz_> cjs: req depend on resp in that same connection, or any recent res[?
04:20:54 <cjs> Any recent ones.
04:21:10 <yitz_> cjs: in any case, there are several classical solutions to this, depending on expected load. Often best to use a single thread in your app, and let the app server decide on when to spawn.
04:21:17 <cjs> Basically, trade data just keeps pouring in, and I make decisions based on what the current state of the world is.
04:21:32 <cjs> app server?
04:22:29 <yitz_> ah, this is a raw server, not running in a web server or other server framework?
04:22:41 <cjs> Right.
04:22:57 <cjs> I receive market data and generate orders.
04:23:34 <yitz_> you also control the client app?
04:24:06 <cjs> Actually, I am the client app. I talk to a market data server and an order server, both of which are run by someone else.
04:25:18 <sjanssen> when/how do you decide to make orders?
04:25:24 <yitz_> so you're not really a server then - you pull in data as it becomes available and process it?
04:26:16 <quicksilver> cjs: you might have a need for STM but from what you're saying, you don't.
04:26:34 <quicksilver> The "point" of STM is the rollback support. If you don't have a need to rollback on inconsistent reads, you don't need STM.
04:26:35 <Ogedei> is the Control.Applicative library included in GHC? (I get a 'could not find module' error when building XMonad)
04:26:49 <yitz_> so why not just keep polling for data, accumulate it, process whenever you have enough, all in one thread?
04:26:53 <quicksilver> cjs: I would guess you could get quite far with one single MVar bundling up your knowledge of the world.
04:26:57 <cjs> Ah, ok. So I just have some sort of state data.
04:27:09 <dmwit> Ogedei: It might be in a package, maybe mtl?
04:27:10 <quicksilver> (that's isomorphic to what in other languages you'd think of as a global lock)
04:27:14 <yitz_> that's what I would do.
04:27:27 <dmwit> Ogedei: There's also an #xmonad if you have more xmonad-specific questions later.
04:27:27 <quicksilver> Ogedei: in GHC 6.6 and later, yes.
04:27:43 <cjs> Actually, I always have enough data; it comes in very quickly, from what I hear.
04:28:14 <yitz_> well, you have to decide when to poll and when to report :)
04:29:18 <quicksilver> you can have one thread constantly working on incoming data
04:29:23 <quicksilver> (or many)
04:29:27 <quicksilver> and one thread "doing stuff".
04:29:38 <cjs> That's basically what I was thinking, quicksilver.
04:30:07 <sjanssen> and I'd certainly look at STM if the data comes in as fast as you say
04:30:55 <quicksilver> since cjs is quite new to this, I'd almost suggesting looking at an MVar solution firrst
04:31:05 <quicksilver> to gain a better appreciation of what you can do without STM, and how STM helps.
04:31:15 <cjs> I think that's a good idea, actually.
04:31:34 <cjs> I'm not actually sure how much "locking" I'd really need, actually.
04:31:52 <quicksilver> STM lets you make multiple reads from shared variables optimistically and transparently rollback if they turn out to be inconsistent due to a concurrent modification.
04:31:59 <quicksilver> that's basically the story
04:32:14 <quicksilver> a simple single whole-world MVar lets you grab a 'whole consistent story' at a point in time.
04:32:25 <quicksilver> you then have two choices : (a) hold the MVar, i.e. lock it
04:32:30 <quicksilver> then the updateer threads will block
04:32:34 <quicksilver> or (b) don't hold the MVar
04:32:38 <quicksilver> then the updater threads continue
04:32:45 <quicksilver> but you have "possibly out-of-date" data.
04:32:58 <quicksilver> of course, in the everchanging real world, all data is possibly out of date, by definition.
04:33:13 <quicksilver> so "possibly up to 5 seconds out of date but definitely consistent" may be fine.
04:34:34 <yitz_> cjs: if it's possible for there to be inconsistencies, i would just start with stm and not waste time with locking. if not, i would just use an mvar
04:35:44 <yitz_> cjs: most importantly, write two separate functions for pull data/ report. Then you can easily experiment with various things. Start with repeatedly poll and report in a single thread for simplicity, see how that goes.
04:38:32 <vegai> amusing that the ohloh page for hs-plugins says "mostly written in shell script"
04:38:59 <vegai> I suppose it's true; the configure script is 111K
04:39:02 <muneson> dir
04:39:20 <muneson> (sorry about that; wrong window :)
04:43:25 <cjs> It's not actually "report"; it's "generate orders." I was asking, actually, because there's no real synchronization of any kind between the two things; they operate entirely independently, really.
04:43:34 <cjs> Anyway, thanks for the advice. I just wanted a sanity check.
04:45:55 <cjs> Time to head home. Long day.
04:52:15 <SamB> vegai: but the configure script is written in m4!
04:52:54 <vegai> no, the generated configure script is sh
04:53:06 <SamB> yes, but that's object code
04:53:18 <vegai> but it's in the repo, so ...
04:53:24 <vegai> I don't know if those tags are generated automatically
04:53:31 <SamB> they are
04:53:35 <vegai> well, that explains it
04:53:42 <SamB> obviously, someone should fix up ohcount
04:55:04 <gour> vegai: hi, it seems that xmonad should follow haskell-x11 versions?
04:55:29 <vegai> gour: indeed
04:55:44 <gour> not a big problem, but still...
04:55:59 <vegai> they're both my packages in community, so it should be workable
04:57:32 <vegai> if someone else depends on haskell-x11, that's a bit nastier
04:57:58 <SamB> do you break compatability often?
04:58:13 <gour> vegai: i'm not aware of one
04:58:23 <vegai> as often as I need to
04:58:37 <SamB> maybe you should future-proof??
04:58:40 <vegai> no.
04:58:57 <vegai> :)
04:58:59 <SamB> what are the last 3 ways you broke compatability?
04:59:43 <vegai> 1) when I updated to haskell-x11-1.4.2, 2) when I updated to haskell-x11-1.4.1, 3) when I updated to haskell-x11-1.4.0
05:00:22 <SamB> okay, how about highlights of the compatability-breaking changes in 1.4.0?
05:00:46 <vegai> hmm?
05:01:06 <SamB> did you actually break source compatability ?
05:01:15 <vegai> no. The versions are checked
05:01:27 <SamB> then what's the big deal?
05:01:43 <vegai> that we have only the latest version of any package available
05:01:54 <SamB> ... only?
05:01:57 <vegai> yes
05:02:10 <SamB> since when?
05:02:20 <vegai> well.. since the distro started, I think
05:03:06 <SamB> wait -- there's a distro in this conversation somewhere???
05:03:09 <vegai> oh, I'm talking on #haskell. Sorry :) We were talking about Arch Linux.
05:03:25 <SamB> oooh
05:03:31 <SamB> now it all makes sense!
05:03:59 <SamB> yeah, future proofing that is rather impossible ;-)
05:04:45 <vegai> yep
05:05:29 <SamB> man, jhc takes a while to print out these fullcheck errors...
05:05:56 <gour> SamB: how useful it is?
05:06:34 <SamB> gour: useful what is? jhc?
05:06:43 <gour> yes
05:06:52 <SamB> well, it's interesting to hack on
05:07:00 <SamB> does that count as useful?
05:07:37 <gour> a bit ;)
05:08:06 <SamB> hmm, now can I trace the type-level Lambda Calculus interpreter...
05:08:18 <vegai> anyone giving a damn about a small problem in lambdabot latest darcs head?
05:08:29 <vegai> I might need some help in tracking it down
05:08:48 <ivanm> vegai: what kind of small problem? the "give the end user root access to the box lambdabot is running on" type of problem? :p
05:08:49 <SamB> I don't know if I give a damn or not
05:09:07 <vegai> in Config.hs, if config.commandPrefixes does not include "@", lambdabot doesn't start properly
05:09:18 <vegai> my guess is that "@" is hardcoded somewhere
05:09:26 <SamB> hmm, definately a small problem
05:09:31 <SamB> my suggestion is this:
05:09:33 <vegai> and a quick grepping seems to suggest that too. But I'm too scared to touch anything :P
05:09:36 <SamB> find | xargs grep '@'
05:09:39 <vegai> yes
05:09:40 <SamB> oh.
05:09:53 <SamB> well, where did it turn up?
05:11:12 <vegai> in many places in Plugins/, but...
05:12:28 <SamB> many places?
05:16:33 <vegai> 4 modules
05:16:55 <vegai> I'll try to pinpoint which causes this
05:19:13 <vegai> aha, OfflineRC.hs
05:20:34 <hpaste>  vegai pasted "lambdabot's Plugin.OfflineRC.feed has hardcoded "@"" at http://hpaste.org/6769
05:32:57 <vegai> @let a = 3
05:32:58 <lambdabot> Defined.
05:33:00 <vegai> > a+3
05:33:01 <lambdabot> Terminated
05:33:04 <vegai> @undef
05:33:04 <lambdabot> Undefined.
05:33:17 <vegai> I suppose I'm not using that part right
05:33:49 <vegai> aha, it's in namespace "L"
05:45:25 <tromp> > a
05:45:26 <lambdabot>  a
05:45:40 <tromp> > a+1
05:45:40 <lambdabot>  a + 1
05:46:37 <tromp> > enumFrom a
05:46:38 <lambdabot>  Exception: not a number
05:46:40 <shapr> @yow !
05:46:40 <lambdabot> WHOA!!  Ken and Barbie are having TOO MUCH FUN!!  It must be the
05:46:40 <lambdabot> NEGATIVE IONS!!
05:46:55 <tromp> morning, Shae
05:54:25 <tromp> :t filterM
05:54:26 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
05:55:22 <tromp> > filterM (const [False,True]) [1..3]
05:55:22 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
05:57:05 <tromp> > mapM (const [False,True]) [1..3]
05:57:06 <lambdabot>  [[False,False,False],[False,False,True],[False,True,False],[False,True,True]...
05:58:00 <tromp> > mapM (const ['F','T']) [1..5]
05:58:01 <lambdabot>  ["FFFFF","FFFFT","FFFTF","FFFTT","FFTFF","FFTFT","FFTTF","FFTTT","FTFFF","FT...
05:59:08 <tromp> @src mapM
05:59:08 <lambdabot> mapM f as = sequence (map f as)
06:00:26 <tromp> @src filterM
06:00:26 <lambdabot> Source not found. :(
06:02:47 <tromp> > mapM (const "FT") [1..5]
06:02:48 <lambdabot>  ["FFFFF","FFFFT","FFFTF","FFFTT","FFTFF","FFTFT","FFTTF","FFTTT","FTFFF","FT...
06:03:20 <shapr> hoi tromp
06:03:48 <ddarius> > replicateM 5 "FT"
06:03:49 <lambdabot>  ["FFFFF","FFFFT","FFFTF","FFFTT","FFTFF","FFTFT","FFTTF","FFTTT","FTFFF","FT...
06:04:36 <tromp> @src replicateM
06:04:37 <lambdabot> replicateM n x = sequence (replicate n x)
06:05:39 <ddarius> sequence is the distributive law of the list monad over a commutative monad, I believe, which makes it a fairly significant function.
06:07:39 <quicksilver> I don't really see how you can view it thus.
06:07:46 <quicksilver> replicateM is *defined* using sequence.
06:07:54 <quicksilver> how can you see sequence as a property of replicateM?
06:08:57 <quicksilver> (you'd need an independent way to define replicateM)
06:12:07 <ddarius> quicksilver: What are you talking about?
06:13:09 <ddarius> I have to go to work
06:13:53 <quicksilver> ddarius: sequence is only a law if the two sides have independent meanings
06:13:57 <quicksilver> ddarius: so the law can be checked.
06:14:08 <quicksilver> since replicateM is defined using sequence, I don't see how it's a law.
06:14:10 <quicksilver> it's a definition.
06:14:24 <quicksilver> (unless you have some other way to define replicateM independently)
06:14:33 <quicksilver> or, were you not talking about replicateM at all? :)
06:16:47 <tromp> he talked only of sequence
06:17:18 <byorgey> @type sequence
06:17:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
06:17:21 <quicksilver> yes, you're presumably right.
06:17:30 <quicksilver> I assumed he was talking about your @src
06:17:36 <quicksilver> since his comment was immediately after.
06:22:49 <bogner> is it possible to do a pattern match in reverse order, ie, make the last one defined tried first?
06:23:05 <Zao> bogner: Reverse the order :)
06:23:11 <EvilTerran> \x y z -> case (z,y,x) of ...
06:23:13 <bogner> d:
06:23:24 <bogner> i don't mean the argument list, sorry
06:23:36 <Zao> bogner: Patterns are always matched top-down.
06:23:47 <bogner> okay. that's what i figured
06:26:00 <bogner> i was trying to (i want to say overload, but with the same type) in a different file. i wanted to define a specialized pattern match and add t to an existing function. that seems impossible though, and i can think of good reasons for it to be impossible, so i'll let it alone
06:27:22 <quicksilver> bogner: yes, you can't split a function definition between files
06:27:37 <quicksilver> bogner: you can certainly acheive that kind of thing, though, by building up a big Data.Map or similar.
06:27:55 <EvilTerran> ?go data types a la carte
06:27:56 <lambdabot> http://lambda-the-ultimate.org/node/2700
06:27:56 <lambdabot> Title: Data Types a la Carte | Lambda the Ultimate
06:28:16 <EvilTerran> may be relevant
06:28:44 <Deewiant> > let combos xs n = iterate (liftM2 (:) xs) [""] !! n in combos "TF" 5
06:28:45 <lambdabot>  ["TTTTT","TTTTF","TTTFT","TTTFF","TTFTT","TTFTF","TTFFT","TTFFF","TFTTT","TF...
06:29:21 <Japsu> > replicateM 5 "TF"
06:29:22 <lambdabot>  ["TTTTT","TTTTF","TTTFT","TTTFF","TTFTT","TTFTF","TTFFT","TTFFF","TFTTT","TF...
06:29:36 * Japsu claims victory
06:30:09 <Deewiant> obscure stuff with the list monad for teh win
06:30:13 <Japsu> yep
06:30:32 <Deewiant> hell, I don't get the liftM2 in mine, @pl just gave it to me :-P
06:30:33 <Japsu> replicateM and sequence are really useful in the list monad
06:30:37 <Japsu> hehehe
06:30:59 <Japsu> > sequence ["TF", "QW"]
06:30:59 <lambdabot>  ["TQ","TW","FQ","FW"]
06:32:04 <shepheb> @type sequence
06:32:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
06:33:01 <tromp> > sequence ["AD","C"]
06:33:01 <lambdabot>  ["AC","DC"]
06:33:17 <gnuvince> \m/
06:33:40 <shap1>  /w\
06:33:49 <matthew_-> any lhs2tex gurus here?
06:34:03 <matthew_-> with particular reference to hyphenation
06:34:44 <bogner> thanks for your help guys, bye for now
06:35:09 <kosmikus> matthew_-: lhs2tex doesn't influence hyphenation?
06:37:48 <matthew_-> kosmikus: true
06:38:08 <matthew_-> I need to indicate that something specified in a %format directive should never be broken
06:38:36 <kosmikus> put it in a box?
06:38:38 <matthew_-> but the problem is that at that point you're already in maths mode and I can't see how to prevent hyphenation in maths mode - you can't just stick an mbox around it
06:38:43 <matthew_-> %format ~> = "\sim\mspace{-3mu}>"
06:39:07 <matthew_-> putting mbox{ ... } doesn't work because you have to be outside maths mode to use mbox
06:39:21 <kosmikus> oh, and \mspace can be broken?
06:39:30 <matthew_-> would appear so
06:39:51 <oToom> MY BOOK HAS ARRIVED!
06:39:54 <kosmikus> is that \mspace or \mskip?
06:40:04 <matthew_-> I'm using mspace
06:40:11 <Zao> oToom: Good for you, lad.
06:40:17 <kosmikus> does it help to surround the whole thing with \mathbin{...} ?
06:40:25 <quicksilver> hyphenation? I didn't think mathmode ever hyphenated.
06:40:30 <quicksilver> do you just mean a line break?
06:40:45 <kosmikus> quicksilver: just words :)
06:41:11 <matthew_-> quicksilver: yes, sorry, it's not hyphenating, it's just putting in a line break which I need to prevent
06:41:18 <quicksilver> you certainly should \mathbin the whole thing
06:41:25 <quicksilver> or \mathop
06:41:28 <quicksilver> depending on taste
06:41:34 <matthew_-> ahh! mathbin works. many thanks
06:41:42 <quicksilver> (slightly different spacing)
06:41:58 <quicksilver> you should always mathop or mathbin single 'operators' made from multiple symbols.
06:42:18 <kosmikus> agreed
06:42:40 <kosmikus> although most infix operators really should be mathbin, not mathop
06:42:50 <matthew_-> I see, I didn't know either of those
06:43:04 <matthew_-> mathop seems to be keen to overfill hboxes... I think I'll stick with mathbin
06:44:03 <matthew_-> many thanks indeed.
06:45:08 <shapr> oToom: Which book?
06:45:09 <yitz_> ping malcolmw
06:45:17 * shapr hugs kosmikus
06:45:37 <kosmikus> shapr: what for? :)
06:46:09 <shapr> kosmikus: Cause I like you!
06:46:34 <malcolmw> yitz: pong
06:46:52 <shapr> And for being helpful and responsive.. hugs are tactile karma!
06:47:14 <yitz_> malcolmw: hi! trying to solve the "unescape" problem someone posted for HaXml a few days ago
06:47:36 <malcolmw> yitz_: yes, I remember it
06:47:50 <yitz_> it seems the problem is that xmlLex calls xmlAny with initial [Where] = [] instead of [NotInTag]
06:48:15 <yitz_> so there's no way to lex anything that doesn't begin with a tag - it thinks the content is a tag name
06:48:42 <quicksilver> yitz_: could this be related to a bug I haven't tracked down where &#38; escapes get lost by haxml?
06:49:01 <yitz_> > chr 38
06:49:01 <lambdabot>  '&'
06:49:14 <yitz_> mm, maybe, not clear why though
06:50:39 <yitz_> malcolmw: i'll paste what i have so far
06:51:16 <hpaste>  aaim annotated "In Desperate Need of Assistance.." with "proper exponentiation type" at http://hpaste.org/6762#a1
06:51:51 <hpaste>  yitz pasted "HaXml unescape, doesn't work" at http://hpaste.org/6771
06:56:06 <yitz_> malcolmw: should i submit a bug somewhere?
06:56:39 <MarcWeber> Is the right way to wait for termination of a thread creating an MVar passing it to the thread?
06:57:09 <quicksilver> yes
06:57:10 <Saizan> MarcWeber: yep
06:58:41 <malcolmw> yitz_: if you can send me an email with what you have discovered, I'll be more likely to remember it and fix haxml.
06:59:35 <yitz_> ok. and yes, it could be the & is related, if it is that & escapes are missed inside attrs.
07:00:16 <malcolmw> hmm, yes sounds likely
07:00:54 <malcolmw> thanks for investigating it - I didn't get very far with it, and have been busy with other things
07:21:54 * byorgey throws lambdas made of 4.2 SECOND LAG
07:22:34 <shapr> whoa!
07:22:56 <shapr> Wow, hpaste is nearly up to 7k pastes.
07:22:59 <shepheb> is there a translation of Meijer91 into Haskell for those more comfortable with the latter than his abstract notation? I recognize a lot of Haskell structures correspond directly (Either is the sum type, etc) but it would still be less dense.
07:28:29 <byorgey> shepheb: is that the Bananas, lenses, etc. paper?
07:31:45 <yitz_> shapr: how's disk space holding out?
07:33:13 <shapr> yitz_: Back to 2.5 gb free once I deleted the archive dir.
07:33:31 <yitz_> sounds like it's hanging in there
07:33:55 <shapr> Yeah, hpaste could have many more cool features.
07:35:07 <yitz_> sure. a looser limit on the paste size would probably be the most requested.
07:35:38 <shapr> Yeah, I think so.
07:36:02 <yitz_> shapr: btw, "remember me" doesn't work for me
07:36:08 <shapr> But I'd like to have a no-disk-usage ghci available in each paste page.
07:36:33 <shapr> If that ghci had the paste loaded, you could interactively do stuff.
07:37:05 <shapr> I'd have to move hpaste to my home box though, no way my virtual server would survive that sort of load.
07:37:14 <yitz_> shapr: cool. hardest part would be security.
07:37:22 <shapr> hs-plugins has some security.
07:37:46 <yitz_> you'd need at least everything they have for lambdabot.
07:37:52 <yitz_> that's a lot.
07:38:11 * shapr shrugs
07:38:40 <shapr> I have 4gb in my desktop, and I could double that for not much money.
07:38:56 <yitz_> hpaste is on your desktop?
07:38:59 <shapr> And I have 750gb of drive space.
07:39:21 <shapr> Nah, it's on my extremely wimpy $15/month virtual server in Atlanta right now.
07:39:40 * yitz_ sighs relief
07:40:46 <shepheb> byorgey: yes
07:40:57 <yitz_> if you need more storage, you could mount a cheaper on-line disk space service for the older pastes.
07:41:18 <byorgey> shepheb: I don't think there's a translation, but there ought to be.  Let's write one! =)
07:41:44 <shapr> yitz_: Yeah, but I like to have physical access to my server, and I just got a static ip at home, so I'll likely do that.
07:42:35 <yitz_> you mean you'll move the whole thing there, or just mounted disk space?
07:42:35 <shepheb> byorgey: it's pretty clear that a lot of the things in that paper correspond to Haskell structures (Either, tuples) and wisdom (any linear recursion can be written as a foldr (== catamorphism))
07:42:51 <shapr> yitz_: I'll probably move the whole thing.
07:43:07 <shepheb> but a translation would make it a valueable reference for plenty of Haskell programmers whose abstract notation buffers aren't up to the original
07:43:17 <byorgey> shepheb: certainly.  I think a fairly direct translation should be possible.
07:43:31 <shapr> I'm tempted to purchase a Haskell dev box designed for multicore use, what's the cheapest way to get the most intel/amd cores?
07:43:39 <yitz_> really. i admire your courage. good luck with all the constant dos attacks, bot-based dictionary attacks, etc.
07:44:16 <pejo> shapr, a friend just got a dual quadcore from Dell fairly cheap.
07:44:27 <shapr> yitz_: I used to maintain and host lambdabot, and maintain the previous haskell wiki, and I started #haskell, I've dealt with lots of it :-)
07:44:55 <yitz_> hosting services have full-time staff to deal with those things. that's what you're paying for. $15 is a good deal.
07:44:55 <shapr> pejo: More than $3k usd?
07:45:44 <byorgey> shepheb: well, maybe instead of a full "translation", a sort of  "companion" document that translates the examples, theorems, proofs, etc. into Haskell notation.
07:45:46 <pejo> shapr, hm, yeah think he landed around 26k SEK. Still an insane amount of power for that money though.
07:46:17 <shepheb> @go 26000 SEK in USD
07:46:17 <lambdabot> 26,000 Swedish kronor = 4,371.224 U.S. dollars
07:46:37 <sek> who wouldn't want 26000 seks :-)
07:48:13 <quicksilver> you can get an 8 core mac for less than $4300
07:49:42 <quicksilver> (if you can get an 8 core mac for less than an 8 core dell somethin has gone wrong somewhere...)
07:54:49 <pejo> quicksilver, I think the mac is even more expensive here.
07:57:14 <Saul_> Is there a datatype similar in complexity behaviour as an array, but with the ability to add values to it?
07:59:02 <quicksilver> pejo: dell's website is too broken for me to find a comparable quote. The price difference is less than I expected.
07:59:07 <quicksilver> Saul_: Short answer No.
07:59:11 <quicksilver> Saul_: Long answer Yes.
07:59:12 <quicksilver> ;)
07:59:17 <Saul_> :)
07:59:18 <paolino> :i IntMap
07:59:24 <quicksilver> Saul_: I would recomment Data.Sequence
07:59:28 <quicksilver> IntMap is another option.
07:59:38 <quicksilver> or just resize an array just like you would in C or C++.
08:01:54 <quicksilver> pejo: looks like the bottom of the range mac pro is 24K SEK if you buy it from apple sweden. I'm sure the dell had a better paper spec, although the mac will be better engineered.
08:02:13 <paczesiowa> @seen dcoutts_
08:02:13 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #ghc and #haskell. I don't know when dcoutts_ last spoke.
08:05:05 <Saul_> quicksilver: Thanks
08:05:21 <Saul_> quicksilver: Although how would you resize an array in C?
08:05:50 <shepheb> byorgey: the real vital part is to translate the laws in the shopping list to Haskell
08:06:40 <Lemmih> @seen Saizan
08:06:40 <lambdabot> Saizan is in #haskell-soc, #haskell-overflow, #haskell-blah and #haskell. I last heard Saizan speak 1h 9m 30s ago.
08:07:08 <byorgey> shepheb: you're talking about page 9?
08:08:40 <quicksilver> Saul_: keep count of actual allocated size and used size.
08:08:55 <quicksilver> Saul_: when the latter exceeds the former, allocate a new array of double the size and copy over.
08:09:45 <Saul_> quicksilver: sounds goog
08:09:48 <Saul_> good*
08:10:24 <wagle_home> there is a remalloc() too
08:11:23 <wagle_home> glib (not glibc) has something too
08:11:37 <Zao> wagle_home: realloc
08:11:55 <wagle_home> ah
08:12:31 <quicksilver> Saul_: yeah, but who likes copying? it's teh suck.
08:12:37 <quicksilver> use data.sequence like god intended.
08:13:28 <Saul_> I think I will for now
08:13:32 <Lemmih> Saizan: ping.
08:13:56 <Saul_> Although if I get a lot of data, I'm going to need to store everything in a database anyway
08:17:16 <Saul_> but that is going to be horrible probably
08:27:48 <byorgey> shepheb: looking at that bananas paper again, the Haskell translation of everything can be found in Control.Arrow =)
08:28:21 <byorgey> we have: A||B on types is (A,B) in Haskell;  the corresponding f||g is f *** g
08:28:46 <byorgey> A|B on types is Either A B; the corresponding f|g is f +++ g
08:29:22 <byorgey> f \triangle g  is f &&& g
08:29:49 <byorgey> f \triangledown g  is f ||| g
08:30:34 <byorgey> then of course pi` = fst, pi' = snd, i' = Left, i' = Right
08:31:03 <shepheb> byorgey: yes. the last bit to get a handle on it is the meaning of L-subscripts
08:31:14 <byorgey> L-subscripts?
08:31:23 <byorgey> which page is this?
08:31:58 <shepheb> page 12 and onward
08:32:10 <shepheb> see (CataEval)
08:32:48 <byorgey> well, L in particular is defined on pg. 10
08:32:53 <byorgey> X_L = 1 | A||X
08:33:03 <byorgey> i.e. X_L is [X]
08:33:19 <byorgey> oh, wait, not quite
08:33:38 <byorgey> X_L is just (in Haskell)  Either () (a,X)
08:34:03 <byorgey> so mu L  is the fixpoint of that, which gives you the list type
08:34:33 <roconnor> [A] = mu X.X_L
08:34:55 <byorgey> right
08:35:04 <shepheb> fixpoints still make my brain hurt.
08:35:54 <shepheb> though I think I might be doing MONAD vs. warm fuzzy thing, making it hard rather than easy.
08:36:11 <shepheb> essentially, when the contained X is itself X_L, behold a list?
08:36:23 <byorgey> exactly.
08:36:34 <byorgey> 1 | A||(1 | A||(1 | A||...
08:36:47 <byorgey> i.e. Either () (a, Either () (a, Either () (a, ...
08:37:29 <shepheb> brain asplosion in progress.
08:37:57 <byorgey> which could be  Left ()  (the empty list)
08:38:15 <byorgey> or you could have Right (1, Left ())  (the list [1])
08:38:33 <mwd> hallo
08:38:33 <byorgey> or Right (1, Right (2, Left ())) and so on
08:38:42 <byorgey> shepheb: does that help?
08:38:45 <byorgey> hi mwd
08:38:50 <shepheb> very much
08:39:13 <shepheb> anyway, L here could I suppose be any (bi?)functor?
08:39:21 <byorgey> any functor.
08:39:31 <shepheb> trees, etc.
08:40:58 <byorgey> right.  the type of binary trees is the fixpoint of a different functor.
08:40:59 <mwd> I whant to read 4 byte from a file, I know this 4 bytes represent an 32 bit in int littleendin. Any pointer to examples docs please (havent found anything in the std lib yet)
08:41:09 <quicksilver> mwd: Data.Binary
08:41:12 <mwd> even though i think it's there
08:41:15 <quicksilver> mwd: in particular, Data.Binary.Get
08:42:13 <roconnor> quicksilver: um, you need to do something special to read littleendin.
08:42:48 <shepheb> X_L = 1 | A||X||X for example.
08:42:53 <mwd> quicksilver: is this within the std lib? cannot find the docs on haskell.org
08:43:10 <byorgey> shepheb: right.
08:43:18 <quicksilver> roconnor: and that something special is contained in Data.Binary.get
08:43:27 <quicksilver> mwd: the std lib is slightly amorphous, but no.
08:44:07 <roconnor> oh
08:44:12 <roconnor> @type Data.Binary.get
08:44:13 <lambdabot> forall t. (Data.Binary.Binary t) => Data.Binary.Get.Get t
08:44:22 <shepheb> I guess the best Haskell translation of that would be X_L into (Funtor l) => l X   , L becomes an opaque Functor.
08:44:36 <glen_quagmire> @where Binary
08:44:36 <lambdabot> http://www.cse.unsw.edu.au/~dons/binary.html
08:45:29 <mwd> quicksilver: so, where do I find the docs? (I'm new to haskell still haven't worked out all bout hoogle, hackage and so on
08:46:08 <quicksilver> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary-0.4.1
08:46:10 <lambdabot> http://tinyurl.com/28wqy4
08:46:10 <byorgey> shepheb: yes, that works.
08:46:19 <quicksilver> in particular, http://hackage.haskell.org/packages/archive/binary/0.4.1/doc/html/Data-Binary-Get.html
08:46:20 <lambdabot> http://tinyurl.com/27z765
08:46:26 <quicksilver> getWord32le :: Get Word32
08:46:27 <mwd> thx
08:46:43 <byorgey> shepheb: then you can define  newtype Mu f = Mu (f (Mu f))   =)
08:46:43 <quicksilver> if you really just have 1 wrod to read it may be easier to do it manually
08:46:47 <quicksilver> but Get is useful
08:47:23 <mwd> quicksilver: well I whant to read an vorbis header, this are (length, string) tuples
08:47:50 <shepheb> byorgey: I'm hungry and my brain is still racing ahead with stuff here. I may indeed write up these translations of Meijer et al. 's "shopping list" of rules, as a personal-exercise-cum-blog-post.
08:48:09 <byorgey> shepheb: then if you have  data L a b = Nil | Cons a b,  Mu (L a)  is isomorphic to [a]  =)
08:48:18 <byorgey> shepheb: cool, sounds like a great idea =)
08:48:18 <mwd> quicksilver: and: well I dont know how to convert data, or how to read something in and get a function convert it .... as i sayed, i'm quet a beginner
08:48:25 <byorgey> enjoy your lunch.
08:49:30 <shepheb> byorgey: thanks for setting off this latest brain explosion.
08:49:40 <byorgey> shepheb: you're welcome, any time =)
08:49:50 <Nafai> Wish I didn't have to work, I want to hack on some Haskell stuff :/
08:51:43 <byorgey> I remember with fondness the first time I read that bananas+lenses paper... it was last spring, while sitting outside on a beautiful day eating Thai food =)
08:54:30 <hpaste>  nomeata pasted "arbitary number of arguments to add" at http://hpaste.org/6772
08:55:03 <nomeata> Hi. I just pasted some small code where I wonder why ghc does not use an instance until I tell it the exact types
08:55:14 <glen_quagmire> :t sum
08:55:15 <lambdabot> forall a. (Num a) => [a] -> a
08:55:23 <nomeata> Error included in the paste. Can someone have a look please?
08:55:24 <byorgey> @tell shepheb be sure to look at http://www.willamette.edu/~fruehr/haskell/evolution.html , scroll down to the "Ph.D. Haskell programmer" section... =)
08:55:24 <lambdabot> Consider it noted.
08:55:34 <glen_quagmire> > let plus = sum in plus [1,2,3,4,5]
08:55:36 <lambdabot>  15
08:56:01 <Deewiant> byorgey: oh, so *that's* what the bananas+lenses bit is about!
08:56:09 <byorgey> Deewiant: yup =)
08:58:16 <s710b> where is the difference between these statements:
08:58:19 <quicksilver> mwd: I have read binary files by hand, it's not too clunky.
08:58:20 <s710b> www = x+x where x=5
08:58:24 <s710b> lll = let x=5 in x+x
08:58:39 <nomeata> (Im trying some type hackery to have a function more that takes an arbitrary number of Ints as arguments and adds them up)
08:58:45 <s710b> is there any difference?
08:59:11 <Botje> s710b: the x is still valid if www has alternatives
08:59:25 <Botje> the let is only valid in that one instance of lll
08:59:57 <s710b> ah, i see. thanks
09:01:44 <visq> Heffalump: thanks a lot for the suggestions you gave recently - type-level is great :)
09:05:45 <nomeata> strange, it works when I replace the hardcoded Ints with a any typeclass (e.g. Integral)
09:06:20 <hpaste>  nomeata annotated "arbitary number of arguments to add" with "Now it works: addd with arbitrary number of arguments" at http://hpaste.org/6772#a1
09:06:28 <roconnor> 3^100
09:06:33 <roconnor> > 3^100
09:06:34 <lambdabot>  515377520732011331036461129765621272702107522001
09:07:56 <nomeata> can some explain that to me?
09:08:54 <quicksilver> nomeata: try adding undecidable-instances
09:09:56 <quicksilver> nomeata: (it's not undecidable, but I think it's not provably decidable using GHC's heuristic)
09:10:21 <nomeata> quicksilver: nope, does not help
09:10:39 <glen_quagmire> why is more :: Integer -> a?
09:11:00 <glen_quagmire> more :: (Num a) => a -> b   ??
09:11:14 <quicksilver> nomeata: it's something to do with FlexibleInstances
09:11:19 <nomeata> glen_quagmire: it should be possible to fix it all to integers, shouldnt it?
09:11:23 <quicksilver> nomeata: it *might* even be a bug. It's certainly odd.
09:11:39 <quicksilver> nomeata: I would post it to glasgow-haskell-users
09:11:58 <glen_quagmire> I would write somethign like:   (+) >?> 1 >?> 2 >?> 3  .. to mean 1 + 2 + 3 + ...
09:12:18 <nomeata> quicksilver: ok, Ill do that
09:12:25 <glen_quagmire> so, i can generalize for any function
09:12:52 <glen_quagmire> hrm this sounds like monad
09:15:35 <oToo1> this haskell book is fucking awsome!
09:15:47 <gour> which one?
09:16:01 <oToo1> Programming in Haskell - Graham Hutton
09:16:32 <gour> ahh, that one didn't see, but, right, heard lot of good things
09:16:43 <gour> any news about realworld book?
09:16:58 <ttt--> the haskell wikibook is awesome too
09:17:46 <glen_quagmire> Java in a Nutshell is awesome too. it's like having javadoc offline.
09:18:53 <yuriyp> What about this book - "Haskell - The Craft of Functional Programming" ?
09:19:00 <yuriyp> Any opinions?
09:19:03 <gour> i've that one and i like it
09:19:23 <gour> sometimes it's a bit slow though...
09:20:15 <yuriyp> gour: I agree. What I don't like about it is that sometimes the excersises are badly defined.
09:21:08 <shachaf> gour: News? There's a beta/alpha, you can read some of what's written, so far.
09:21:32 <glen_quagmire> i don't like books that have exercises without explanations. those boooks make me turn on my computer and try out stuff.
09:21:43 <gour> shachaf: many chapter are still missing...
09:22:03 <quicksilver> glen_quagmire: that sounds like a good thing?
09:22:11 <yuriyp> what is this realworld book?
09:22:15 <shachaf> gour: Sure, but they're being added.
09:22:28 <shachaf> @go real world haskell
09:22:29 <lambdabot> http://www.realworldhaskell.org/
09:22:29 <lambdabot> Title: Real World Haskell
09:22:33 <glen_quagmire> i just like to read books on the bus without computer. and still makes me learn something
09:22:37 <quicksilver> true
09:22:39 <quicksilver> so do I
09:22:46 <gour> me too
09:22:46 <quicksilver> although, I never go on a bus without my computer
09:23:18 <quicksilver> I might get bored!
09:23:27 <quicksilver> must ... have .. entertainment .. devices
09:23:37 <quicksilver> laptop, psp, ipod, phone,...
09:24:02 <Deewiant> quicksilver: just how long is your average bus ride? :-P
09:24:20 <glen_quagmire> so i just end up checking out girls on the bus
09:24:25 <quicksilver> 10 - 15 minutes
09:24:49 <Deewiant> quicksilver: and that's long enough to boot up a computer and do something?
09:25:10 <EvilTerran> ... ds, blackberry, wardriving box, mindstorms set...
09:25:21 <glen_quagmire> we all get nervous when youtube vidoe doesnt' start promptly. it's postmodern impatient syndrome
09:25:40 <Deewiant> I get annoyed when it does start promptly, in a background tab
09:26:17 <glen_quagmire> i can write a haskell compiler in 15 minutes. at least that's how hyper active this generation is
09:26:19 <quicksilver> Deewiant: real computers don't need to boot up
09:26:26 <quicksilver> Deewiant: you open them and they are exactly how you left them.
09:26:42 <quicksilver> (this is the main thing I like about laptops. persistent desktop state over weeks)
09:27:21 <Deewiant> when I stop doing something I tend to close the related programs, so I don't need persistent state :-)
09:28:09 <idnar> quicksilver: you don't need a laptop just for software suspend
09:28:21 <araujo> mmm
09:28:32 <quicksilver> idnar: I didn't say you did.
09:28:41 <quicksilver> idnar: (but laptops are more convenient on the bus, to be fair)
09:28:45 <glen_quagmire> lambas can be suspended with environment and resume reduction
09:28:55 <quicksilver> Deewiant: but the point is, I don't stop doing them.
09:29:02 <quicksilver> Deewiant: writing a haskell program takes weeks
09:29:07 <quicksilver> (especially if you only do it on bus rides)
09:29:23 <quicksilver> my day job has, so far, taken two years and still isn't finished :)
09:29:39 <glen_quagmire> it's amazing that music continues play from where it left off when i open my laptop again
09:29:57 <Deewiant> quicksilver: I tend to shutdown my text editor when I'm done for the day :-)
09:30:08 <glen_quagmire> i wonder what happens to MMORPG session
09:30:15 * EvilTerran leaves firefox open for weeks on end sometimes
09:30:36 <EvilTerran> also half-read PDFs
09:30:52 <nomeata> quicksilver: sent to the list
09:31:45 <glen_quagmire> forefox will take 3GB of memory if you let it open with buggy flash application
09:32:50 <quicksilver> yeah, I'm temporarily switched to safari because of that
09:33:02 <quicksilver> I'll probably go back to firefox if they manage to produce a non-leaking version :)
09:33:15 <Deewiant> 3 is much nicer regarding memory usage
09:33:41 <jrx> @src sequence
09:33:41 <lambdabot> sequence []     = return []
09:33:41 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
09:33:41 <lambdabot> --OR
09:33:41 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
09:33:56 <oToo1> what is haskell capable of?
09:34:05 <Deewiant> @faq can haskell do everything?
09:34:05 <lambdabot> The answer is: Yes! Haskell can do that.
09:34:16 <oToo1> hes bound to say that
09:34:20 <oToo1> so it can make game hacks?
09:34:22 <glen_quagmire> hasekll is another form of turning machine
09:34:22 <oToo1> i dont think so
09:34:38 <oToo1> @faq Can haskell create game hacks
09:34:38 <lambdabot> The answer is: Yes! Haskell can do that.
09:34:39 <Deewiant> @faq can one hack games with haskell?
09:34:39 <lambdabot> The answer is: Yes! Haskell can do that.
09:34:42 <glen_quagmire> i mean, haskell language is another way of describing turing machine
09:34:42 <oToo1> bullshit!
09:35:07 <oToo1> @faq can haskell take a shower?
09:35:07 <lambdabot> The answer is: Yes! Haskell can do that.
09:35:08 <Jaak> um. every programming language is...
09:35:13 <sclv> watch the language. this is a family channel. :-)
09:35:13 <glen_quagmire> i haven't seen a good game written in haskell
09:35:14 <oToo1> thats all he says!
09:35:30 <byorgey> oToo1: seriously, why do you think you couldn't create game hacks with Haskell?
09:35:31 <glen_quagmire> there are many space invader, tetris...
09:35:45 <byorgey> although I must admit I'm not entirely sure what you mean by "game hacks"
09:35:45 <oToo1> because it has no API' calls?
09:35:47 <oToo1> Like errr
09:35:54 <oToo1> Like aimbotsa?
09:36:02 <oToo1> automaticly aims at the players head lol
09:36:06 <glen_quagmire> game sdks usually use C++
09:36:13 <oToo1> Yes.
09:36:19 <Deewiant> System.Win32 probably has everything you need
09:36:20 <oToo1> So haskell cannot create game hacks ;)
09:36:26 <oToo1> @faq ur wrong
09:36:26 <lambdabot> The answer is: Yes! Haskell can do that.
09:36:26 <quicksilver> aimbots work by intercepting the network protocol, don't they?
09:36:28 <Jaak> glen_quagmire: what about "Frag"
09:36:31 <glen_quagmire> i heard it's not as easy to call C++ library
09:36:36 <byorgey> oToo1: haskell has an excellent foreign function interface which can be used to bind to external libraries.
09:36:38 <Deewiant> oToo1: what are you missing?
09:36:41 <quicksilver> if I'm write, then haskell can do that just as well as any other language.
09:36:48 <quicksilver> s/write/right/
09:36:49 <glen_quagmire> Jaak: oh yah. that's nice.
09:36:59 <byorgey> right,you could also write your own library.
09:37:18 <Jaak> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Game
09:37:20 <lambdabot> http://tinyurl.com/yqov7f
09:37:22 <ttt--> @faq Positivism!
09:37:22 <lambdabot> The answer is: Yes! Haskell can do that.
09:37:34 <byorgey> oToo1: so, you're right that you couldn't immediately start writing such things in Haskell, since the libraries don't exist to support it.
09:37:38 <oToom> How can this be a family channel when the faq tells lies?
09:37:47 <quicksilver> oToom: it's a joke
09:37:49 <byorgey> oToom: but it could certainly be done.
09:37:51 <quicksilver> families are allowed to have jokes.
09:37:55 <glen_quagmire> i'm a family guy. that's why
09:38:04 <oToom> So am i
09:38:06 <oToom> im the son
09:38:08 <oToom> Bahahaha
09:38:11 <quicksilver> Doing some research I see that some aimbots work by scanning the computer's memory.
09:38:11 <Deewiant> byorgey: isn't System.Win32 sufficient? or is it missing much of the Win32 API?
09:38:15 <oToom> can i spam ur silly willies?
09:38:25 <byorgey> Deewiant: I don't know, and I don't want to know  ;)
09:38:27 <quicksilver> You could do that in haskell too but you'd need to bind something under windows.
09:38:33 <quicksilver> under linux it would be trivial.
09:38:43 <oToom> do what?
09:38:45 <oToom> spam this?
09:38:48 <Deewiant> byorgey: ah, I see ;-)
09:39:10 <sclv> apparently, you already are.
09:39:11 <oToom> h4x
09:39:11 <oToom> 0mg
09:39:11 <oToom> h4x
09:39:11 <oToom> 0mg
09:39:12 <oToom> h4x
09:39:12 <oToom> 0mg
09:39:14 <oToom> h4x
09:39:16 <oToom> 0mg
09:39:18 <oToom> h4x
09:39:20 <oToom> 0mg
09:39:21 <Jaak> /kickban oToom
09:39:22 <oToom> h4x
09:39:24 <oToom> 0mg
09:39:24 <Jaak> pls
09:39:24 --- mode: ChanServ set +o quicksilver
09:39:26 <oToom> h4x
09:39:28 <oToom> 0mg
09:39:30 --- kick: oToom was kicked by quicksilver (quicksilver)
09:39:42 <sclv> ?where ops
09:39:42 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
09:39:52 <sclv> ah, too late.
09:39:58 <glen_quagmire> if there's a virtual machine that can call c/c++/java libraries and ghc has a backend for that, would it be easy to call other library functions?
09:40:20 <quicksilver> subject to the design of the ghc backend for that
09:40:20 <Jaak> @go ffi
09:40:22 <lambdabot> http://en.wikipedia.org/wiki/Fatal_familial_insomnia
09:40:22 <lambdabot> Title: Fatal familial insomnia - Wikipedia, the free encyclopedia
09:40:25 <Deewiant> for C++ it's not possible since the ABI depends on the compiler
09:40:28 <Jaak> bah... wrong command
09:40:31 <byorgey> shame, oToom started out well enough...
09:40:35 <quicksilver> presumably that would be something that you would build in to such a backend
09:40:42 <byorgey> hahahaha
09:40:48 * h4x 0mg :P
09:40:52 <oToom> 0mg h4x
09:40:53 <quicksilver> oToom: lively discussion of what haskell can do is great
09:40:56 <quicksilver> oToom: spamming isn't
09:41:03 <oToom> it was an example
09:41:18 <quicksilver> glen_quagmire: however you'd need to think about how you link the type systems.
09:41:29 <byorgey> thanks, but we've seen examples of spam before =P
09:41:35 <quicksilver> glen_quagmire: that is why C FFI is simpler, in a nutshell: because C has a simple type system.
09:42:15 <glen_quagmire> linking type systems == data marshalling ?
09:42:15 <EvilTerran> oToom, an example of what?
09:42:37 <EvilTerran> oToom, apart from being a moron, i mean?
09:42:40 <quicksilver> glen_quagmire: yes.
09:42:57 <quicksilver> glen_quagmire: how do you convert a java type to a haskell type (if it was a java VM)
09:43:04 <glen_quagmire> let's make ISO standard for programming language types
09:43:05 <quicksilver> glen_quagmire: resp perl6, if it was pugs. Etc.
09:43:11 <quicksilver> there are some :)
09:43:15 <shachaf> @faq How many shells could a Haskell sell if a Haskell could sell shells?
09:43:15 <lambdabot> The answer is: Yes! Haskell can do that.
09:43:19 <quicksilver> they aren't desperately useful.
09:43:28 <quicksilver> COM and CORBA are both 'sort-of' solutions to this kind of problem.
09:43:35 <quicksilver> I suppose XML-RPC and SOAP are, too.
09:43:50 <quicksilver> all of them are verbose and rather wedded to an OO view of the world.
09:43:54 <yitz_> quicksilver: XMLSchema
09:43:55 <n00b> hey mapM_ can it be applied to a series of IO
09:44:07 <shachaf> @ty mapM_
09:44:07 <byorgey> @type mapM_
09:44:10 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
09:44:11 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
09:44:15 <quicksilver> n00b: if you've already got a series of IO actions, maybe you just need sequence_
09:44:25 <quicksilver> n00b: sequence_ and mapM_ are closely related
09:44:30 <n00b> ok
09:44:37 <shachaf> @@ (@src mapM_) , in fact. :-)
09:44:37 <lambdabot>  , in fact. :-)
09:44:45 <shachaf> @src mapM_
09:44:45 <lambdabot> mapM_ f as = sequence_ (map f as)
09:44:52 * shachaf has to figure out this @@ thing.
09:45:06 <n00b> cool
09:45:09 <n00b> :)
09:45:15 <quicksilver> yitz_: yes.
09:49:02 <yitz_> @help @
09:49:02 <lambdabot>  @ [args].
09:49:02 <lambdabot>  @ executes plugin invocations in its arguments, parentheses can be used.
09:49:02 <lambdabot>  The commands are right associative.
09:49:02 <lambdabot>  For example:    @ @pl @undo code
09:49:02 <lambdabot>  is the same as: @ (@pl (@undo code))
09:49:21 <oToom> EvilTerran: dont call me a moron ;)
09:50:04 <oToom> whos server is the bot on?
09:50:16 <oToom> cuz its always online am i right in saying?
09:50:45 <shachaf> oToom: Cale is running her at the moment.
09:51:02 <Cale> It's running on code.haskell.org though
09:51:16 <Cale> I just make sure that it stays running :)
09:51:19 <shachaf> Cale: Did you talk with stylus yesterday?
09:51:23 <EvilTerran> oToom, i won't if you don't act like one. i call 'em as i see 'em.
09:51:29 <EvilTerran> mate.
09:51:38 <Cale> Yeah, and the channel limit is now infinite. I should merge the two :)
09:51:41 <desegnis> oToom: those women just like chatting all day long, no wonder she's always online
09:52:08 <shachaf> Cale++ stylus++
09:52:11 <shachaf> lambdabot++
09:52:31 <Jaak> i++
09:52:36 <shachaf> @karma i
09:52:36 <lambdabot> i has a karma of 3
09:52:37 <Jaak> @karma i
09:52:37 <lambdabot> i has a karma of 3
09:52:43 <mauke> @karma c
09:52:43 <lambdabot> c has a karma of 15
09:52:55 <desegnis> yay for c--
09:53:08 <ttt--> @karma ttt--
09:53:08 <lambdabot> You have a karma of 0
09:53:10 <MyCatVerbs> @karma j
09:53:10 <lambdabot> j has a karma of 3
09:53:17 <n00b> can i say mapM_ (enable := False) [closeb, openb, saveb .....]
09:53:22 <MyCatVerbs> Hah! Nested loops for the win!
09:53:58 <shachaf> n00b: If (enable := False) gets one argument and returns a monadic result.
09:54:09 <ttt--> @uptime
09:54:12 <byorgey> n00b: what is the type of (enable := False)?  I kind of doubt it is a function.
09:54:13 <desegnis> n00b, that's like saying, can i say mapM_ blab blub :)
09:54:16 <lambdabot> uptime: 14s, longest uptime: 1m 10d 23h 44m 29s
09:54:20 <shachaf> You might want something like (\x -> enable x := False), though?
09:54:32 <quicksilver> n00b: yes, you say it, roughly.
09:54:41 <Cale> There we go. Now there's only one lambdabot :)
09:54:42 <quicksilver> n00b: just have to guess which version you mean :)
09:55:05 <quicksilver> mapM_ (\x -> set x [enable := False]) [closeb,openb,saveb,...]
09:55:08 <quicksilver> is my guess
09:55:11 <n00b> basically enable := False is IO func
09:55:12 <quicksilver> if you're using WXhaskell
09:55:24 --- mode: quicksilver set -o quicksilver
09:55:24 <n00b> yeah i am using wxhaskell
09:55:59 <yitz_> @botsnack
09:56:04 <lambdabot> :)
09:56:10 <quicksilver> n00b: yes, then I believe my version is correct.
09:56:15 <yitz_> Cale: one, or zero?
09:56:21 <quicksilver> You would write "set openb [enable := False]"
09:56:38 <Cale> yitz_: one
09:56:43 <quicksilver> so you write "mapM_ (\x -> set x [enable := False]) [openb,closeb,...."
09:56:54 <yitz_> ah, good. :)
09:56:59 <n00b> well i did that, but i wanna apply it to all my buttons at once
09:57:30 <shachaf> n00b: That should do it, no?
09:57:34 <quicksilver> n00b: yup. and that's why my example does.
09:58:03 <skorpan> what is the function which converts an Integer to a float?
09:58:09 <Deewiant> @ty fromIntegral
09:58:10 <lambdabot> forall a b. (Num b, Integral a) => a -> b
09:58:35 <quicksilver> skorpan: there are two conversion functions you need. fromIntegral and realToFrac
09:58:37 <skorpan> let gr = [3,4,4,3,3,4,4,3,5,4,3,4,3,3,4,3,3,3,3,3,3,4,3,3,3,4,5,5] in (sum gr) / (length gr)
09:58:38 <quicksilver> ;)
09:58:39 <Deewiant> @ty unsafeCoerce
09:58:40 <lambdabot> Not in scope: `unsafeCoerce'
09:58:42 <Deewiant> if you're so inclined ;-)
09:58:45 <skorpan> that's basically what i want to do. please, help.
09:58:51 <shachaf> skorpan: fromIntegral
09:58:59 <shachaf> (Or fromInteger, for an Integer.)
09:59:22 <mauke> > let gr = [3,4,4,3,3,4,4,3,5,4,3,4,3,3,4,3,3,3,3,3,3,4,3,3,3,4,5,5] in sum gr / fromIntegral (length gr)
09:59:24 <lambdabot>  3.5357142857142856
09:59:34 <skorpan> thanks
09:59:39 <shachaf> Or you oculd use genericLength.
09:59:48 <shachaf> > let gr = [3,4,4,3,3,4,4,3,5,4,3,4,3,3,4,3,3,3,3,3,3,4,3,3,3,4,5,5] in sum gr / genericLength gr
09:59:49 <lambdabot>  3.5357142857142856
10:00:02 <shachaf> > let gr = [3,4,4,3,3,4,4,3,5,4,3,4,3,3,4,3,3,3,3,3,3,4,3,3,3,4,5,5] in sum gr % length gr -- Also works?
10:00:04 <lambdabot>  99%28
10:00:07 <skorpan> that's btw my average grade on a scale "fail, 3, 4, 5"
10:00:08 <skorpan> :)
10:00:08 <mauke> yeah, but who computes the length in Doubles?
10:00:26 <skorpan> not taking the fails into account..
10:00:35 <yitz_> skorpan: I though it was an approximation to pi
10:00:42 <byorgey> > let gr = [3,4,4,3,3,4,4,3,5,4,3,4,3,3,4,3,3,3,3,3,3,4,3,3,3,4,5,5] in sum gr `div` length gr  -- close enough
10:00:42 <lambdabot>  3
10:00:46 <EvilTerran> > genericLength [1..] == (1/0 :: Double)
10:00:46 <skorpan> yitz_: that's what i'm aiming for from this moment on
10:00:49 <lambdabot>  Exception: stack overflow
10:00:51 <EvilTerran> aww
10:00:55 <EvilTerran> :P
10:01:03 <tromp> :t length
10:01:04 <lambdabot> forall a. [a] -> Int
10:01:19 <idnar> @type genericLength
10:01:20 <lambdabot> forall b i. (Num i) => [b] -> i
10:01:54 <shachaf> @src genericLength
10:01:54 <lambdabot> genericLength []    = 0
10:01:54 <lambdabot> genericLength (_:l) = 1 + genericLength l
10:02:54 <byorgey> @src length
10:02:55 <lambdabot> Source not found. That's something I cannot allow to happen.
10:03:08 <EvilTerran> it'll be the same, i'd expect
10:03:24 <byorgey> but with specialized RULES?
10:03:59 <allbery_b> or just a specific type instead of Num a => a
10:05:22 <Deewiant> > let len = foldr (const (+1)) 0 in len [0..50]
10:05:23 <lambdabot>  51
10:05:58 * wagle_home starts hunting for a list of length 1.3 + 4.8i + 32.7j - 44.1k 
10:05:59 <EvilTerran> > let len = sum . zipWith const (repeat 1) in len [0..50]
10:06:01 <lambdabot>  51
10:06:16 <tromp> > let len = sum . map (const 1) in len [0..50]
10:06:17 <lambdabot>  51
10:06:30 <wagle_home> oops  s/length/genericLength/
10:06:36 <byorgey> > let len = 51 in len [0..50]
10:06:37 <lambdabot>   add an instance declaration for (Num ([t] -> a))
10:06:43 <byorgey> hehe, doh!
10:07:07 <byorgey> that's what I get for trying to be a smart-aleck
10:07:55 <Deewiant> yes, haskell was smarter than you ;-)
10:08:04 <wagle_home> > let len [0..50] = 51 in len [0..50]
10:08:04 <lambdabot>  Parse error in pattern at "in" (column 22)
10:08:38 <Deewiant> > let len [0,1,2,3] = 4 in len [0..3]
10:08:39 <lambdabot>  4
10:08:39 <tromp> you need to spell out 0:1: ....:50:[] :(
10:08:58 <tromp> oh, that syntax works too
10:09:34 <Deewiant> sure, it's just sugar for that
10:09:44 <Deewiant> whereas [a..b] is sugar for the enumFromTo function
10:11:40 <tromp> > length [0..]
10:11:43 <lambdabot> Terminated
10:11:47 <ttt--> let True = False in 3 == 3
10:11:53 <ttt--> > let True = False in 3 == 3
10:11:53 <lambdabot>  True
10:12:17 <wagle_home> uhh
10:12:27 <tromp> > let 0=1 in 0
10:12:28 <lambdabot>  0
10:12:29 <ttt--> why is that allowed
10:12:31 <EvilTerran> that only works because let bindings are irrefutable/lazy
10:12:45 <EvilTerran> > case False of ~True -> 3 == 3 -- equivalent
10:12:46 <lambdabot>  True
10:12:58 <EvilTerran> > case False of True -> 3 == 3 -- different
10:12:58 <lambdabot>   Non-exhaustive patterns in case
10:13:03 <ttt--> > let True = undefined in 3 == 3
10:13:04 <lambdabot>  True
10:13:07 <desegnis> > let True = True in True -- wtf?
10:13:07 <lambdabot>  True
10:13:24 <Baughn> > let True = False in True
10:13:25 <lambdabot>  True
10:13:41 <desegnis> ah. so what does let True = ... bind?
10:13:48 <wagle_home> nothing
10:14:08 <wagle_home> pattern had no variables
10:14:17 <Lemmih> desegnis: Think 'let Just x = ...; Nothing = ... in'.
10:14:20 <Vulpyne> Would using Data.Traversable.fmapDefault be the idiotmatic way to traverse a Seq?
10:14:21 <kpreid> desegnis: it's a failed pattern match, but it's never forced so you never see the failure
10:14:40 <desegnis> ah, thanks, I see now
10:15:17 <wagle_home> > let [x] = [1] in 2
10:15:18 <lambdabot>  2
10:15:27 <wagle_home> > let [x] = [] in 2
10:15:28 <lambdabot>  2
10:15:34 <wagle_home> > let [x] = [] in x
10:15:35 <lambdabot>   Irrefutable pattern failed for pattern [x]
10:15:42 <desegnis> alright, alright :)
10:16:05 <wagle_home> i wanted to see what happened
10:16:48 <bos> @seen dons
10:16:50 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I don't know when dons last spoke.
10:18:13 <ttt--> > let [x] = [[1]] in x
10:18:14 <lambdabot>  [1]
10:18:38 <ttt--> > let [x+1] = [[1]] in x
10:18:38 <lambdabot>  Parse error in pattern at "in" (column 19)
10:19:34 <EvilTerran> lambdabot doesn't do n+k patterns, for some reason
10:19:40 <EvilTerran> ?type let [x+1] = [[1]] in x
10:19:41 <lambdabot> forall t. (Num t, Integral [t]) => [t]
10:20:32 <wagle_home> > let [x+1] = [1] in x
10:20:32 <lambdabot>  Parse error in pattern at "in" (column 17)
10:20:48 <EvilTerran> ... did you not hear what i just said? :P
10:21:07 <wagle_home> @type let [x+1] = [[1]] in x
10:21:08 <lambdabot> forall t. (Num t, Integral [t]) => [t]
10:21:33 <wagle_home> why can it type it, but not parse it?
10:22:20 <Cale> wagle_home: Because it parses every expression that it's about to evaluate in order to ensure that it's actually a valid Haskell expression
10:22:51 <Cale> (before it ever gets into the hands of GHC)
10:23:05 <wagle_home> doesnt it have to parse it to type it?
10:23:50 <Saizan> wagle_home: no, it's feeded directly to ghci, which has a more complete parser
10:23:54 <desegnis> I guess Cale tweaked lambdabot to omit parsing of n+k patterns when evaluating, but did not hack the type checker accordingly
10:24:20 <Saizan> it has always been like that :)
10:24:22 <Cale> Uh, no
10:24:41 <desegnis> uh, learnt something new then
10:24:45 <Cale> It's just that the Haskell parser which it uses doesn't support n+k patterns.
10:25:10 <allbery_b> specifically, it runs the expression through the Language.Haskell stuff before handing it off to ghc/i as a sanity check
10:25:19 <allbery_b> Language.Haskell is well known to be incomplete
10:25:22 <bos> @seen andyjgill
10:25:22 <lambdabot> I haven't seen andyjgill.
10:25:22 <raf> hello can some one help me i have some haskell quistions plz
10:25:44 <shapr> raf: Go ahead and ask your questions, but don't paste code.
10:26:21 <desegnis> I see (though I don't see why that sanity check is needed)
10:26:22 <raf> what is the type for (++)
10:26:28 <shapr> @type (++)
10:26:28 <lambdabot> forall m. (Monoid m) => m -> m -> m
10:26:51 <shapr> raf: If you have GHC or hugs installed, you can run them interactively and use :t (++)
10:26:57 <Deewiant> (actually [a] -> [a] -> [a])
10:27:12 <desegnis> raf: Note that lambdabot uses a special (more general) version of (++)
10:27:18 <wagle_home> @instances Monoid
10:27:18 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
10:27:27 <raf> ok i am going to try it
10:27:34 <dino-> Huh, I didn't know that about (++) here with lammy.
10:27:53 <glguy> It's to help us answer questions like the previous one
10:28:02 <dino-> Is that something that's in the future for us all outside of the bot?
10:28:06 <byorgey> whee
10:28:19 <glguy> dino-: if you define it locally
10:28:22 <shapr> glguy: Hey is there a new release of hpaste soon?
10:28:23 <wagle_home> @dwim
10:28:23 <lambdabot> Unknown command, try @list
10:28:35 <wagle_home> darn, still not implemented
10:28:41 <yitz_> dino-: I think we're trying it out. Perhaps someday it will be adopted.
10:28:51 <dino-> I see. Thank you.
10:29:17 <dino-> This seems seemingly related to the 'where are they hiding my monad comprehensions' issue
10:29:37 <Cale> A wizard has turned you into a whale. Is this awesome (Y/N)?
10:29:50 <yitz_> Anyway you can assume it's [a]->[a]->[a] as usual and everything ought to work fine.
10:30:11 <yitz_> Cale: blub blub blub
10:30:54 <wagle_home> i thought first of the whale in the hitchhikers guide to the galaxy..  was awesome for a while, i suppose
10:30:56 <byorgey> Cale: take wizard
10:31:18 <wagle_home> light wizard
10:31:44 <yitz_> throw wizard
10:32:12 <wagle_home> Meddle not into the affairs of wizards, for they become soggy and hard to light.
10:32:49 <wagle_home> @go "Meddle not into the affairs of wizards, for they become soggy and hard to light."
10:32:50 <lambdabot> No Result Found.
10:32:53 <wagle_home> aww
10:33:44 <wagle_home> oh..  my memory is bad..  makes more sense now:
10:33:57 <wagle_home> @go "Meddle not into the affairs of wizards unless you are soggy and hard to light."
10:33:58 <lambdabot> No Result Found.
10:34:09 * shapr laughs
10:34:55 <desegnis> @seen gandalf
10:34:55 <lambdabot> I haven't seen gandalf.
10:36:30 <raf> shapr i have try it and for (++) in WinHugs i get type type    : [a] -> [a] -> [a]
10:36:50 <shapr> raf: Ok, in the future when you want to know the type of something, try that.
10:37:12 <wagle_home> raf, lambdabot has its own version of haskell
10:37:27 <raf> i mean some thing like " some thing" is typ String
10:37:29 <zeno_> > version
10:37:29 <lambdabot>   Not in scope: `version'
10:37:36 <Baughn> @version
10:37:36 <lambdabot> lambdabot 4p597, GHC 6.8.2 (Linux i686 2.40GHz)
10:37:36 <lambdabot> darcs get http://code.haskell.org/lambdabot
10:37:51 <glguy> raf: lambdabot just uses non-standard definitions
10:37:52 <gnuvince> @src Ord
10:37:52 <lambdabot> class  (Eq a) => Ord a  where
10:37:52 <lambdabot>     compare      :: a -> a -> Ordering
10:37:52 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
10:37:52 <lambdabot>     max, min         :: a -> a -> a
10:38:36 <raf> :(
10:40:40 <wagle_home> @src Monoid
10:40:40 <lambdabot> class Monoid a where
10:40:40 <lambdabot>     mempty  :: a
10:40:40 <lambdabot>     mappend :: a -> a -> a
10:40:40 <lambdabot>     mconcat :: [a] -> a
10:41:30 <shapr> @users
10:41:30 <lambdabot> Maximum users seen in #haskell: 469, currently: 466 (99.4%), active: 25 (5.4%)
10:41:40 <wagle_home> *shock*  lambdabot has the src for something!
10:41:42 <shapr> Wasn't it up to 48x yesterday?
10:43:19 <wagle_home> mconcat :: (Monoid m) => m a -> a           ?
10:43:34 <matthew-_> @src lambdabot
10:43:35 <lambdabot> Source not found. My mind is going. I can feel it.
10:43:41 <matthew-_> lol! how apposite
10:43:49 <matthew-_> it's not even self aware
10:44:10 <wagle_home> @vixen how do you think of yourself?
10:44:10 <lambdabot> however you want
10:45:59 <Jaak> @hoogle guard
10:45:59 <lambdabot> Control.Monad.guard :: MonadPlus m => Bool -> m ()
10:45:59 <lambdabot> Language.Haskell.TH.Guard :: data Guard
10:45:59 <lambdabot> Language.Haskell.TH.Syntax.Guard :: data Guard
10:49:53 <glen_quagmire> > guard True
10:49:54 <lambdabot>   add an instance declaration for (Show (m ()))
10:50:05 <glen_quagmire> > guard True :: []
10:50:05 <lambdabot>      `[]' is not applied to enough type arguments
10:50:05 <lambdabot>     Expected kind `?', but ...
10:50:13 <glen_quagmire> > guard True :: [Int]
10:50:14 <lambdabot>  Couldn't match expected type `Int' against inferred type `()'
10:50:37 <tromp> > guard True :: [()]
10:50:38 <lambdabot>  [()]
10:51:12 <wagle> @src guard
10:51:12 <lambdabot> guard True  =  return ()
10:51:12 <lambdabot> guard False =  mzero
10:51:22 <glen_quagmire> :t [()] -- this might be the only thing that itself is a type
10:51:23 <lambdabot> [()]
10:51:24 <yitz_> > guard True >> [42]
10:51:25 <lambdabot>  [42]
10:51:34 <yitz_> > guard False >> [42]
10:51:35 <lambdabot>  []
10:51:42 <tromp> > guard True :: Id ()
10:51:42 <lambdabot>   Not in scope: type constructor or class `Id'
10:52:10 <tromp> > guard True :: ()
10:52:11 <yitz_> tromp: Identity, but it's not an instance of MonadPlus
10:52:11 <lambdabot>  Couldn't match expected type `()' against inferred type `m ()'
10:52:29 <yitz_> > guard True :: Identity ()
10:52:30 <lambdabot>   add an instance declaration for (Show (Identity ()))
10:52:42 <wagle> > guard True :: return ()
10:52:43 <lambdabot>   add an instance declaration for (Show (return ()))
10:52:51 <yitz_> > runIdentity (guard True :: Identity ())
10:52:52 <lambdabot>   add an instance declaration for (MonadPlus Identity)
10:53:09 <wagle> oh there you go
10:53:24 <wagle> @instances MonadPlus
10:53:24 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
10:54:11 <wagle> > guard True >> Just 42
10:54:12 <lambdabot>  Just 42
10:55:52 <tromp> > guard True :: Just ()
10:55:53 <lambdabot>   Not in scope: type constructor or class `Just'
10:56:03 <tromp> > guard True :: Maybe ()
10:56:04 <lambdabot>  Just ()
10:57:03 <Baughn> ..what
10:57:05 <Baughn> @src guard
10:57:06 <lambdabot> guard True  =  return ()
10:57:06 <lambdabot> guard False =  mzero
10:59:31 <Baughn> > guard True :: [a] <-- "Expected type: [a], inferred type: [()]". Why does this fail?
10:59:31 <lambdabot>  Parse error at "<--" (column 19)
10:59:38 <Baughn> > guard True :: [a] -- "Expected type: [a], inferred type: [()]". Why does this fail?
10:59:38 <lambdabot>   [a]
10:59:38 <lambdabot>       Inferred type: [()]
10:59:38 <lambdabot>     In the expression: guard True :: [a]
10:59:38 <lambdabot>     ...
11:00:09 <allbery_b> because you want it to be more polymorphic than it is?
11:00:14 <Botje> guard :: (MonadPlus m) => Bool -> m ()
11:00:34 <mrd> () is not a
11:00:36 <Baughn> Oh. Yes, I suppose I do.
11:01:00 <MyCatVerbs> @src guard
11:01:00 <lambdabot> guard True  =  return ()
11:01:00 <lambdabot> guard False =  mzero
11:01:35 <Baughn> So how would I say "the type of this function should be a list type, but I don't care what it's a list /of/"?
11:01:41 <idnar> glen_quagmire: what about () by itself?
11:01:53 <wagle> () is not a monoid
11:01:56 <mauke> `asTypeOf` []
11:02:10 <Baughn> > guard True `asTypeOf` []
11:02:10 <lambdabot>  [()]
11:02:11 <idnar> oh, I didn't realise he meant "thing that is a monoid"
11:02:11 <wagle> () is not a MonadPlus, i mean
11:02:20 <Baughn> @src asTypeOf
11:02:21 <lambdabot> asTypeOf = const
11:02:21 <idnar> or monadplus
11:02:47 <Baughn> @type asTypeOf
11:02:48 <lambdabot> forall a. a -> a -> a
11:02:53 <monochrom> Maybe you don't care but Haskell does.  guard x cannot be of type [a].
11:03:03 <MyCatVerbs> wagle: sure it is. () `mappend` () = (). The zero element is (). That fulfills the monoid laws, so what's the issue?
11:03:12 <idnar> uhm, I was referring to this: < glen_quagmire> :t [()] -- this might be the only thing that itself is a type
11:03:16 <wagle> () is not a MonadPlus, i mean
11:03:17 <Baughn> MyCatVerbs: Nobody instanced it
11:03:18 <tromp> you cld make () instance of Monoid...
11:03:30 <wagle> @instances MonadPlus
11:03:30 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
11:03:38 <idnar> @instances Monoid
11:03:38 <Botje> :t [((),())]
11:03:38 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
11:03:40 <lambdabot> [((), ())]
11:03:44 <idnar> ^^^ first one in the list
11:03:54 <wagle> >>>>>>>>>>>>>>>>>>> () is not a MonadPlus, i mean <<<<<<<<<<<<<<<<<<<<<<<<<<
11:03:54 <MyCatVerbs> Baughn: sure? It's right there in Data.Monoid.
11:04:14 <Baughn> MyCatVerbs: I admit defeat
11:04:14 <idnar> wagle: you've created a monster
11:04:14 <matthew-_> Endo?
11:04:20 <MyCatVerbs> Baughn: ;)
11:04:21 * wagle wonders if three times is the charm
11:04:38 <tromp> what's the shortest compilable haskell program?
11:04:55 <wagle> main = main
11:04:57 <MyCatVerbs> wagle: well, you could make a monad instance with () >>= f = (), return _ = () and () >> () = ().
11:04:57 * monochrom tries the empty program.
11:05:16 <Baughn> @src IO mzero
11:05:16 <lambdabot> mzero       = ioError (userError "mzero")
11:05:18 <byorgey> tromp: aha, some people were talking about this the other day.  Someone came up with something really clever but I can't remember what it was...
11:05:26 <MyCatVerbs> wagle: I think that's sufficiently useless to fulfil the monad laws. Then you just instance MonadPlus trivially.
11:05:31 <byorgey> I think you can do one character shorter than main=main
11:05:41 <Deewiant> m@main=m
11:05:48 <matthew-_> ewww
11:05:54 <wagle> hahah
11:05:55 <matthew-_> you can do aliases on functions?
11:06:00 <byorgey> I don't think that works, does it?
11:06:01 <idnar> ahaha awesome
11:06:02 <mauke> MyCatVerbs: kind error
11:06:06 <monochrom> The empty program doesn't work. Without a module declaration, module Main is assumed. Then main is not found.
11:06:19 <Deewiant> > let f@g = f in f
11:06:20 <lambdabot>  Exception: <<loop>>
11:06:22 <Baughn> m@main=m works
11:06:27 <MyCatVerbs> mauke: oh shit aye, my bad. Dammit.
11:06:33 <byorgey> wow, amazing =)
11:06:35 <Deewiant> > let f@g = f in g
11:06:36 <lambdabot>  Exception: <<loop>>
11:06:36 <tromp> nice one, wagle
11:06:48 <tromp> i get a.out: <<loop>>
11:07:07 <monochrom> @ is alias on patterns in general, not just functions.
11:07:13 <byorgey> > let g 0 = 1; f@g n = n * f (n - 1)  in g 5
11:07:13 <lambdabot>  Parse error in pattern at "in" (column 37)
11:07:25 <byorgey> > let g 0 = 1; (f@g) n = n * f (n - 1)  in g 5
11:07:26 <lambdabot>  Parse error in pattern at "in" (column 39)
11:07:30 <monochrom> a@(x:y:xs) = ...  is another example.
11:07:43 <tromp> what's the shortest program returning without error?
11:08:02 <Baughn> "main=return()"
11:08:07 <Deewiant> main=print""
11:08:08 <tromp> main=getChar
11:08:16 <glen_quagmire> > let { g 0 = 1; f@(g) n = n * f (n-1); } in g 5
11:08:16 <lambdabot>  Parse error in pattern at ";" (column 37)
11:08:27 <idnar> Deewiant: print takes an argument
11:08:31 <yitz_> but main = ... is not a pattern match
11:08:37 <Deewiant> idnar: that's the ""
11:08:44 <Deewiant> idnar: alternatively, main=print 0
11:08:51 <idnar> Deewiant: whoops, for some reason my brain parsed that as "main=print"
11:08:58 <idnar> probably because Baughn's line was right before it
11:09:10 <sjanssen> does main=main count?
11:09:14 <Baughn> It errors
11:09:21 <glen_quagmire> > let { g 0 = 1; g n = n * f (n-1); f 0 = 0; f n = n * g (n-1); } in g 5
11:09:22 <lambdabot>  0
11:09:23 <byorgey> it's not the shortest anyway =)
11:09:26 <sjanssen> it may or may not return, depending on how smart your compiler is :)
11:09:37 <mauke>  <tromp> what's the shortest program returning without error?
11:09:40 <yitz_> If Cale has his way, someday we'll be able to say main=(++)
11:09:49 <sjanssen> byorgey: what is shorter than that
11:09:56 <idnar> yitz_: main doesn't take any arguments, how would that work?
11:10:06 <byorgey> sjanssen: see above.   m@main=m   =)
11:10:06 <sjanssen> yitz_: that doesn't unify with IO a
11:10:12 <glen_quagmire> > let main = main in main
11:10:13 <sjanssen> byorgey: ha, nice
11:10:13 <lambdabot>  Exception: <<loop>>
11:10:33 <Baughn> > let m@main=m in main
11:10:34 <lambdabot>  Exception: <<loop>>
11:10:39 <sjanssen> perhaps main=mzero
11:10:45 <Deewiant> sjanssen: also an error
11:10:47 <Baughn> @src IO mzero
11:10:47 <lambdabot> mzero       = ioError (userError "mzero")
11:10:50 <byorgey> sjanssen: Deewiant came up with that one =)
11:10:54 <yitz_> Don't know how it works now either
11:10:59 <sjanssen> ah, didn't think that yielded an error
11:11:26 <sjanssen> oh, I know!  Turn on the overloaded strings extension and you can have main=""
11:11:29 <glen_quagmire> > let m@f = m in f
11:11:30 <lambdabot>  Exception: <<loop>>
11:11:58 <glen_quagmire> > let f = f in f
11:11:59 <lambdabot>  Exception: <<loop>>
11:12:22 <idnar> sjanssen: the prelude would need a string overload for IO
11:12:30 <byorgey> sjanssen: hm, neat idea, but that doesn't work for me
11:12:40 <byorgey>  No instance for (Data.String.IsString (IO a))
11:13:25 <EvilTerran> so define it!
11:13:43 <mauke> that tkaes more code than main=return()
11:13:44 <sjanssen> idnar, byorgey: right, you have to cheat
11:14:11 <byorgey> oh, sorry, I didn't realize cheating was allowed ;)
11:14:17 <idnar> haha
11:14:17 <Botje> main=main compiles
11:14:59 <Nafai> Okay, I'm taking lunch.
11:15:02 <Nafai> Time for Haskell!
11:15:39 <byorgey> Nafai: hurrah! =)
11:15:43 <Nafai> Question for y'all
11:15:48 <Nafai> I'm trying to use hsemail
11:15:57 <yitz_> hmm, m@main=m compiles. ok, ok.
11:15:59 <Nafai> I've got code that parses an e-mail
11:16:10 <Nafai> And it returns one of these: http://cryp.to/hsemail/docs/Text-ParserCombinators-Parsec-Rfc2822.html#t%3AMessage
11:16:13 <lambdabot> http://tinyurl.com/2jpkq3
11:16:24 <tromp> > let main=getStr in main
11:16:24 <lambdabot>   Not in scope: `getStr'
11:16:25 <Nafai> In other words, a list of Fields
11:16:43 <Nafai> What's the best way to easily extract out just the fields I want given that structure?
11:16:55 <sjanssen> what is the shortest non-diverging program we've got so far?
11:17:09 <wagle> oo..  a halting problem!
11:17:10 <Deewiant> sjanssen: main=print 0, or main=getChar
11:17:16 <Deewiant> same length
11:17:20 <sjanssen> or main=readLn
11:17:27 <Deewiant> oo, shorter
11:17:37 <mauke> does that type?
11:17:41 <Deewiant> but no
11:17:42 <matthew-_> no
11:17:43 <Deewiant> it's called getLine
11:17:50 <sjanssen> @type readLn
11:17:51 <lambdabot> forall a. (Read a) => IO a
11:17:55 <matthew-_> @type main
11:17:56 <lambdabot> Not in scope: `main'
11:17:59 <Deewiant> @index readLn
11:17:59 <lambdabot> System.IO, Prelude
11:18:01 <sjanssen> mauke: not without some help, I suppose
11:18:04 <mauke> Ambiguous type variable `a' in the constraint:
11:18:04 <matthew-_> oh ffs. stupid b
11:18:07 <EvilTerran> that works, there's a Read instance for ()
11:18:24 <sjanssen> mauke: if cheating is allowed, turn on ghci's extended defaulting :)
11:18:26 <MyCatVerbs> See, this is why stack languages are so awesome. "" is a valid program.
11:18:28 <Deewiant> needs monomorphism restriction
11:19:06 <matthew-_> surely, needs *no* monomorphism restriction?
11:19:13 <Deewiant> of course :-)
11:19:19 <Nafai> byorgey: Any ideas? :)
11:20:55 <tromp> main=isEOF
11:21:10 <sjanssen> nice
11:21:19 <sjanssen> tromp++
11:21:21 <mauke> try.hs:1:5: Not in scope: `isEOF'
11:21:24 <mauke> fail
11:21:24 <tromp> Euler.hs:43:5: Not in scope: `isEOF'
11:21:41 <sjanssen> oh, it's hIsEOF, or something like that
11:21:41 <yitz_> Nafai: getDate (Date t)=Just t; getDate _= Nothing
11:21:46 <sjanssen> tromp-- false alarm
11:21:52 <sebell> isEOF is System.IO
11:21:56 <sebell> And not Prelud
11:21:56 <glen_quagmire> main=yield
11:22:14 <sebell> @index yield
11:22:15 <lambdabot> GHC.Conc, Control.Concurrent
11:23:33 <sjanssen> yield isn't even in H '98!
11:24:14 <sebell> main=readLn is shorter, but I like main=print"" as well
11:24:15 <glen_quagmire> are you coming up with a shortest program that returns immediately? that uses only Prelude?
11:24:53 <mauke> a shortest program that is not an infinite loop or an error
11:24:57 <sjanssen> glen_quagmire: shortest program that doesn't diverge and doesn't return an exception, I think
11:26:00 <tromp> shortest program with return code 0
11:26:13 <mauke> current winner: main=print""
11:26:26 <tromp> or main=getChar
11:26:28 <sjanssen> tromp: this makes assumptions about the Haskell system you're using
11:26:38 <Deewiant> I prefer mine as it terminates without input ;-)
11:26:55 <Deewiant> okay, true, if stdin isn't buffered then that returns immediately as well
11:26:56 <sebell> Deewiant: Which is that?
11:27:00 <Deewiant> sebell: print""
11:27:10 <sebell> Deewiant: Oh, yes I arrived at that as well.
11:27:15 <rdtsc> main=0
11:27:23 <sebell> rdtsc: Boo
11:27:27 <Deewiant> > let main = 0 :: IO () in main
11:27:29 <lambdabot>   add an instance declaration for (Num (IO ()))
11:27:29 <lambdabot>     In the expression: 0 :: I...
11:27:31 <tromp> we have 10 co-winners like main=print 7
11:27:39 <Deewiant> and main=print()
11:27:40 <mauke> main=print()
11:27:45 <Deewiant> and main=print''
11:27:50 <mauke> no
11:27:52 <sjanssen> Deewiant: nope
11:27:57 <Deewiant> no?
11:28:05 <Deewiant> > let main = print'' :: IO () in main
11:28:09 <lambdabot>   Not in scope: `print'''
11:28:14 <Deewiant> oh, darn, right
11:28:22 <mauke> > print ''
11:28:22 <lambdabot>  Improperly terminated character constant at "''" (column 7)
11:28:24 <Deewiant> so 12
11:28:25 <shapr> So what's cool and new in the Haskell world?
11:28:32 <Deewiant> mauke: oh, and good point that, too :-)
11:28:36 <mauke> main=print$0
11:28:41 <araujo> shapr, new himerge release!
11:28:45 <Deewiant> okay, so 24
11:28:49 <Deewiant> err
11:28:50 <Deewiant> 22
11:29:18 <shapr> araujo: Cool!
11:29:26 <araujo> haha
11:30:04 <sjanssen> so somebody just write a program that generates all possible programs up to that length so we can know for sure
11:30:19 <Deewiant> grepping the Prelude docs for all monad / IO functions is easier
11:30:25 <Deewiant> and I did that, and didn't find anything shorter ;-)
11:30:39 <yitz_> This is yet another reason why we need to change main to be of type MonadIO m => m (). Then we could say main=get or main=ask.
11:31:09 <sjanssen> yitz_: main needs to be a monomorphic type to be useful, I think
11:31:15 <EvilTerran> yitz_, you'd need some heavy-duty defaulting for that
11:31:36 <yitz_> EvilTerran: yes :)
11:31:38 <tromp> just consider all
11:31:38 <tromp> > replicateM 6 "0123456789abc...ABC..."
11:31:41 <lambdabot>  ["000000","000001","000002","000003","000004","000005","000006","000007","00...
11:31:57 <yitz_> sjanseen: why?
11:32:02 <sjanssen> yitz_: also, MonadIO m => m () and (MonadState m s, MonadIO m) => m () aren't the same type
11:32:22 <Deewiant> > length $ replicateM 6 "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
11:32:27 <sjanssen> I suppose forall m. MonadIO m => m () would work -- but it isn't useful at all
11:32:32 <lambdabot> Terminated
11:32:40 <Peaker> @src replicateM
11:32:44 <lambdabot> replicateM n x = sequence (replicate n x)
11:32:47 <yitz_> as EvilTerran says, we would need some defaulting there...
11:33:05 <sjanssen> yitz_: ask yourself, what operations are available in *all* MonadIO?
11:33:21 <yitz_> liftIO
11:33:26 <sjanssen> liftIO and the Monad operations -- you might as well use IO
11:33:38 <sjanssen> get does not have type forall m. MonadIO m => m ()
11:33:47 <EvilTerran> sjanssen, ah, but if all the System.IO functions were already wrapped in liftIO...
11:33:50 <yitz_> but hey, we can dream.
11:34:02 <sjanssen> EvilTerran: that is orthogonal
11:34:38 <EvilTerran> that's what i'm after, rather than a more general type for main
11:34:51 <sjanssen> yitz_: my point is that generalizing main to MonadIO doesn't actually allow anything more
11:35:13 <bos> i wonder why we don't have a corresponding MonadSTM
11:35:16 <yitz_> > replicateM 6 "ab"
11:35:17 <lambdabot>  ["aaaaaa","aaaaab","aaaaba","aaaabb","aaabaa","aaabab","aaabba","aaabbb","aa...
11:35:33 <sjanssen> bos: I prefer a general MonadBase class (as seen in monadLib)
11:36:16 <sjanssen> > replicateM 3 [False ..]
11:36:16 <lambdabot>  [[False,False,False],[False,False,True],[False,True,False],[False,True,True]...
11:37:05 <bos> sjanssen: yes, monadLib is nice, but i don't think it's going to displace mtl.
11:37:26 <sjanssen> bos: MonadBase could certainly go in mtl
11:37:35 <bos> mtl is woven into the fabric of the universe, for better or worse.
11:37:38 <bos> sjanssen: true.
11:38:59 <yitz_> bos: mtl will undergo major change in the move away from fundeps. Maybe now's the time for something else.
11:39:37 <bos> yitz_: i'd be surprised if those changes happen this decade.
11:39:48 <sjanssen> yitz_: we won't be able to start the move away from fundeps very soon
11:39:55 * wagle_home . . o o O O { what's mtl? }
11:40:18 <sjanssen> maybe associated types will be ready in GHC 6.10, whenever that comes out
11:40:22 <bos> monad transformer library.
11:40:29 <wagle_home> thanks
11:40:51 <bos> i think we'll have a good year or two of people poking at ATs and going "buuh?" before they leak into the mainstream.
11:41:02 <shapr> ATs rock.
11:41:05 <yitz_> sjanssen: that will be its first version, but i think the api will need to change a lot after that to get out wrinkles
11:41:21 <shapr> Lots of good stuff that could be done with associated types.
11:41:32 <sjanssen> yitz_: I'm saying not even the implementation is finished in GHC
11:41:38 <monochrom> mtl = mocca tzai latte
11:41:50 <sjanssen> we can't build on top of nothing :)
11:41:56 <yitz_> @go mtl
11:41:58 <lambdabot> http://www.mtl-inst.com/
11:41:58 <lambdabot> Title: Group Site Overview
11:42:02 <shapr> monochrom: Hey, did you look at that poisonous people film I mentioned?
11:42:14 <monochrom> No.
11:42:16 <yitz_> sjanssen, yes, i was taking it even a step further
11:42:36 <bos> shapr: you might get a kick out of reading "the no asshole rule"
11:42:55 <idnar> tzai?
11:43:06 <monochrom> mutated spelling for chai :)
11:45:05 <yitz_> hey - after the company with stock symbol mtl and the scientific instruments company, our mtl is *third* on google. for a tla - wow!
11:45:22 <gwern> @remember Erik-Naggum You have failed to consider the ramifications of the solutions and pose a problem that simply would not exist if you did. This taxes my patience, which is already legendary in its general absence.
11:45:23 <lambdabot> It is forever etched in my memory.
11:45:46 <gwern> @quote patience
11:45:46 <lambdabot> Erik-Naggum says: You have failed to consider the ramifications of the solutions and pose a problem that simply would not exist if you did. This taxes my patience, which is already legendary in its
11:45:46 <lambdabot> general absence.
11:46:59 <tromp> weird; main@m=m compiles too
11:47:24 <yitz_> maybe it's google skewing the results based on its knowledge of my search history though.
11:47:36 <Deewiant> tromp: of course, it doesn't matter in parameters either
11:47:39 <Deewiant> > let f x@y = x in f 1
11:47:40 <lambdabot>  1
11:47:42 <idnar> tromp: that's the same as m = m
11:47:43 <Deewiant> > let f x@y = y in f 1
11:47:44 <lambdabot>  1
11:47:55 <idnar> except with the "main" binding
11:48:06 <tromp> idnar, it also defines main
11:48:20 <Deewiant> > let f@g = 1 in (f, g)
11:48:21 <lambdabot>  (1,1)
11:48:30 <tromp> i though all bla@ bindings wld be local
11:49:54 <gwern> http://en.wikiquote.org/wiki/Erik_Naggum?april_fool <-- hilarious incidentally
11:49:54 <lambdabot> Title: Erik Naggum - Wikiquote
11:51:06 <idnar> gwern: ?april_fool?
11:51:20 <shapr> Has anyone here had anything to do with Earned Value Management?
11:51:40 <monochrom> "My other car is a cdr." haha
11:51:46 <Peaker> one thing that bothered me with the monadic style of some computations is that it forced specifying a total order between operations, when in fact maybe just a partial order exists -- it seems that arrows can correct this, are they used for this purpose?
11:52:19 <shapr> Peaker: Not that I know of, and spj agrees with you, he'd like to have 'commutative monads'
11:52:30 <Peaker> who's spj?
11:52:38 <shapr> Simon Peyton-Jone
11:52:39 <shapr> s
11:53:08 <monochrom> &&& and *** may be defined to relax order.  Note that >>> still insist on order.
11:53:16 <roconnor> I wonder if applicative functors come closer to commutative monads.
11:53:24 <Peaker> hey, he works at Microsoft... do many Haskellers work at Microsoft?
11:53:29 <monochrom> Yeah, consider applicative too.
11:53:37 <cjb> Peaker: Microsoft Research, yes.
11:53:37 <paczesiowa> Peaker: only the best:>
11:54:02 <Peaker> But what does Microsoft ever do that has anything to do with cool stuff like FP? :-)
11:54:10 <Deewiant> F#?
11:54:14 <unenough> it's a shame that a company with such great research minds has such sucky products
11:54:27 <roconnor> Technically ap still defines order I guess, but it certainly feels less sequenced.
11:54:30 <cjb> MSR is not dissimilar to a university research group.  They don't integrate with MS much.
11:54:31 <Peaker> monochrom, does it allow specifying any general partial order?
11:54:42 <monochrom> I don't know yet.
11:55:03 <unenough> Deewiant, my anti-microsoftian automatic reaction says that F# is no good. i'm trying to supress it because i really know nothing about f#.
11:55:38 <monochrom> Microsoft is large. Do not try to stereotype everything about it.
11:55:38 <roconnor> Microsoft developed a computer verified proof of the four colour thereom using Curry-Howard.
11:56:18 <roconnor> (does Microsoft Research count as Microsoft?)
11:56:25 <mattam> roconnor: not sure
11:56:26 <cjb> I don't think of MSR as being much like MS
11:56:36 <Peaker> well, building a partial-order graph of monadic operations with &&& and *** and such seems awkward...
11:56:39 <cjb> particularly since I know many of the academics came from other university edepartments
11:56:42 <roconnor> how about in the legal sense?
11:56:42 <shapr> Peaker: Anyway, Simon Peyton-Jones is pretty much the biggest name behind Haskell.
11:56:46 <cjb> and still behave exactly as they did before moving to MSR
11:56:49 <cjb> SPJ being a fine case in point
11:56:58 <Peaker> shapr, cool, glad to be on his side :-)
11:57:21 <shapr> Peaker: SPJ explicitly mentions that he wishes for commutative monads in "The Hairshirt Retrospective"
11:57:27 <monochrom> IMO arrow is a data-flow language in text.
11:57:32 <shapr> There are some likely ways to get commutative monads, but they're not easy to use.
11:57:34 <yitz_> I think that F# is basically an ocaml variant that is specially designed to allow convenient access to the .NET library. So given that .NET is not going away for a long time, I would say that F# is about the best you could hope for.
11:57:47 <roconnor> presumably a commutative applicative functor is one where fmap flip = flip?
11:57:52 <Baughn> With Data.Binary and lazy I/O, is there any way I can distinguish errors in decoding from any other error?
11:58:11 <mattam> What's a commutative monad ?
11:58:12 <shapr> Personally, I think nanevski's split of monads into the possibility and necessity calculus seems likely, and Ed told me recently about a better way than that (but I forget the details).
11:58:37 <roconnor> mattam: not sure.  maybe one where liftM flip = flip  :D
11:58:45 <shapr> Something about monadic coproducts maybe? I don't remember exactly what Ed said.
11:58:49 <Peaker> shapr, to me it sounds like text-encoding of partial graphs is difficult, and is another example of where I'd want a specialized UI to compose parts of my program
11:59:18 <Peaker> s/partial graphs/partial-order graphs
11:59:20 <roconnor> @type flip
11:59:22 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
11:59:35 <roconnor> I guess I should say liftM3 flip = flip
11:59:54 <yitz_> until someone figures out a better way to integrate Haskell with .NET. :)
11:59:56 <roconnor> or liftM2 ?
11:59:57 <mattam> Peaker: These are called Hasse diagrams I think
12:00:06 <Deewiant> liftM2.
12:00:09 <roconnor> liftM2 flip = flip
12:00:16 <idnar> liftMN flip
12:00:17 <Peaker> mattam, indeed
12:00:35 <Peaker> mattam, could be nicer to create a Hasse diagram, than to textually encode it with some new "do" syntax...
12:00:46 * mattam is actually proving   forall F G : subset A, subset_inclusion F G -> 
12:00:47 <mattam>     forall x y, greatest_lower_bound F x ->
12:00:47 <mattam>       greatest_lower_bound G y -> x <= y.
12:01:00 <shapr> roconnor: Actually, I think commutative monads would work like different sized rings on a string, where each monad flavor were its own size of ring. That way, one m1 computation would have total order according to the other m1 computations, but only a partial order compared to m2 computations.
12:01:43 <roconnor> shapr: I don't think that is the type of commutativity we are talking about here.
12:01:54 <shapr> oh
12:02:00 <Peaker> shapr, would I be right in saying that automatically parallelizing pure computations is much easier than doing the same for monadic ones?   If I am, this may ease the parallellisation problem
12:02:27 <mattam> Peaker: I don't know what kind of code would require that kind of thing :) Do you have an example ?
12:02:53 <shapr> I'm not an expert, but I think it's always easier to parallelize computations that don't mutate memory.
12:02:57 <cjb> Peaker: yes.
12:02:58 <roconnor> I believe we are talking about when do {x <- a ; y <- b; f x y}  = do {y <- b; x <- a; f x y}
12:03:24 <Peaker> mattam, well, with the hype around multicores, its great to have the ability to just throw pure FP computations to different processors.  However, a total-order monadic IO computation must be sequential (even though it probably has less strict dependencies than that) and cannot make use of the other processors
12:03:48 <shapr> roconnor: Well, that's not what I was talking about :-)
12:04:15 <Peaker> but it does sound like arrows also can be used to specify a partial order, rather than the monadic total order... isn't that true?
12:04:21 <shapr> roconnor: I was talking about the ability to declare when a particular monadic computation can be commuted past another computation.
12:04:27 <roconnor> shapr: I more or less understood what you said. :)
12:04:30 <forkiliens> hi everybody. who uses monads in his daily (?) job/use of haskell?
12:04:34 <shapr> forkiliens: I do!
12:04:35 <mattam> Peaker: ok, I see what you mean now.
12:04:44 <Deewiant> probably everybody
12:04:57 <sebell> moi
12:05:06 <roconnor> shapr: right, which is a reasonable interpretation of "comunative monad", but not the ususal understanding of this term.
12:05:07 <lispy> forkiliens: I'm not sure you can do real work in Haskell without them
12:05:07 <shapr> roconnor: So, what's different about what you and I were talking about?
12:05:08 <Peaker> forkiliens, a use of a list comprehension is a use of a monad
12:05:27 <forkiliens> how did you learn best to use them ? by doing exercises, or by trying out things that come up in your mind?
12:05:29 <shapr> Hasse diagrams are nifty! http://en.wikipedia.org/wiki/Hasse_diagrams
12:05:33 <forkiliens> @shapr
12:05:33 * lambdabot karate-chops  into two equally sized halves
12:05:38 <roconnor> shapr: We are talking about monadic opertaion in a single monad commuting with each other.
12:05:51 <forkiliens> Peaker: i know that :)
12:05:54 <roconnor> do {x <- a ; y <- b; f x y}  = do {y <- b; x <- a; f x y}
12:06:04 <shapr> forkiliens: http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
12:06:05 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
12:06:09 <forkiliens> i was asking for _everyday_ experience.
12:06:16 <forkiliens> you wrote it?
12:06:25 <forkiliens> @ shapr
12:06:25 <shapr> No, Dan Piponi wrote that.
12:06:45 <shapr> I'd suggest you read that first, and then read http://www.haskell.org/all_about_monads/html/index.html
12:06:45 <lambdabot> Title: All About Monads
12:06:59 <forkiliens> ok, i'm reading the chapter from The craft of functional programming & all -about monads
12:07:06 <forkiliens> :)
12:07:10 <Peaker> forkiliens, I have wrote about 3 Haskell programs so far :-)
12:07:20 <lispy> forkiliens: everyday use, I'm going to use monads for IO, errors and maybe, and then monad transformers for all the non-standard stuff
12:07:22 <shapr> @shapr shapr
12:07:22 * lambdabot puts on her slapping gloves, and slaps shapr
12:07:24 <forkiliens> Peaker: where?
12:07:55 <MyCatVerbs> \bot has a gender now?
12:07:58 <Peaker> forkiliens, I am a newbie, my programs aren't worth distributing yet :-)   One is a bouncing text screen saver, and another is an initial attempt at a declarative GUI framework
12:08:11 <shapr> MyCatVerbs: Yeah, for years.
12:08:12 <Peaker> (very initial)
12:08:24 <lispy> ?vixen Are you a girl?
12:08:24 <lambdabot> yup, i'm all woman
12:08:41 <MyCatVerbs> shapr: damn anthromorphisation.
12:08:45 <monochrom> mattam: in "subset_inclusion F G", which one is the larger set, F or G?
12:08:52 <roconnor> Peaker: you are a newbie, and you are trying to make a declarative GUI framework?
12:08:58 <forkiliens> Peaker: ok, but it's the same with me. i'm using haskell for about a month or so...
12:08:59 <mattam> G
12:09:12 <shapr> I've seen some newbies pass my knowledge level in a month or so.
12:09:15 <monochrom> Then x<=y should be false.
12:09:23 <forkiliens> roconnor: that's not the way to encourage people....
12:09:31 <lispy> roconnor: I would guess that says we have a weakspot in libraries
12:09:45 <Peaker> roconnor, I am trying to
12:09:52 <shapr> Peaker: Go for it!
12:10:02 <Peaker> roconnor, I am a Haskell newbie, I've been programming for quite a while
12:10:11 <forkiliens> Peaker: why not trying out....  you learn best by doing it yourself... at least _i_ learn best this way :)
12:10:20 <roconnor> forkiliens: I want Peaker to a least be aware that this is a problem that has confounded experts for 15 years or more.
12:10:31 <mattam> monochrom: Oh right, I wrote glb. Thanks.
12:10:40 <roconnor> Peaker: but as long as you are aware, I say go for it.  outsiders often have new perspective.
12:10:41 <Peaker> roconnor, And I learn from those experts. I read a lot :)
12:10:45 <forkiliens> roconnor: I think he'll find out... :)
12:10:59 <Peaker> roconnor, I have a declarative GUI for editing an integer, yay :-)
12:10:59 <forkiliens> you see. he already has. :9
12:11:19 <shapr> forkiliens: So how'd you get interested in Haskell?
12:11:21 <roconnor> Peaker: have you studied GuiTV?
12:11:24 <mattam> monochrom: the lemma is called upper_bound_inclusion though :)
12:11:27 <Peaker> roconnor, The Eros thing?
12:11:33 * roconnor uses GuiTV for all his Haskell Gui programing
12:11:45 <Peaker> oh, nope, I'll take a look at that, thanks
12:11:45 <monochrom> Then you need least_upper_bound instead.
12:12:06 <roconnor> Peaker: Eros allows users to do what GuiTV lets programmers do.
12:12:25 <forkiliens> shapr: short way: read Paul graham stuff -> decided to learn lisp -> tried out haskell -> wow ...
12:12:31 <roconnor> (and is implemented on top of GuiTV)
12:12:38 <shapr> forkiliens: Cool!
12:12:51 <gbacon> forkiliens: enjoy the ride
12:13:00 <forkiliens> :)
12:13:09 <mattam> monochrom: Don't worry. Coq wouldn't let me prove it anyway.
12:13:13 * roconnor has made only 1 GUI program in haskell.
12:14:01 * monochrom made 0.4 but deleted it.
12:14:09 <Peaker> roconnor, oh, I see
12:14:23 <forkiliens> i have a "practical" question: I'm trying to get sth. done outside haskell, which means:
12:14:32 <roconnor> monochrom: fortuantely my application is tiny enough for me to complete it.
12:14:34 <Peaker> I wonder if Paul Grahamm has tried Haskell out
12:14:37 <forkiliens> run texvc to render latex
12:14:48 <Peaker> I think he oversimplifies/dumbs it down a "bit" when he puts languages on an axis, with "lisp" at one end
12:14:57 <roconnor> Peaker: If he did, he probably got bulbed.
12:15:05 <Peaker> roconnor, what'st hat?
12:15:13 <shapr> "blub"
12:15:19 <shapr> @go The Blub Paradox
12:15:20 <lambdabot> http://www.paulgraham.com/avg.html
12:15:20 <lambdabot> Title: Beating the Averages
12:15:29 <roconnor> Peaker: its a verbification of "blub"
12:15:42 <monochrom> forkiliens: System.Process or System.Cmd has functions for that.
12:15:43 <roconnor> which is a reference to one of his more famous essays
12:15:49 <forkiliens> unfortunately i can't read the output of the program in haskell. I have problems with the type (IO ExitCode)
12:15:49 <Deewiant> roconnor: intentionally misspelled?
12:15:55 <Peaker> also, I read his example of using a list to represent point types, and realizing that being a list instead of a strict-type declaration made it possible for his point to live in N dimensions rather than 2 (if defined as x,y), and therefore lenient typing is better than strict typing, yay
12:16:08 <forkiliens> ok, but how do your read for instance: system "ls"
12:16:10 <roconnor> Deewiant: nah, I'm just illiterate.
12:16:30 <monochrom> OK, System.Cmd won't do. It has to be System.Process.
12:16:33 <Deewiant> forkiliens: runInteractiveProcess gives you handles from which you can read
12:16:35 <forkiliens> then you get some output on the interpreter... but i can't "read" this output to process it further
12:16:42 <roconnor> Deewiant: OMG
12:16:50 <Deewiant> @hoogle runInteractiveProcess
12:16:50 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
12:16:54 <Baughn> With Data.Binary and lazy I/O, is there any way I can distinguish errors in decoding from any other error?
12:16:57 <monochrom> Try System.Process.runInteractiveCommand
12:17:03 <roconnor> Deewiant: sorry, I just realized that I had read blub as bulb all this time.
12:17:12 <roconnor> Deewiant: ALL this time
12:17:18 <monochrom> ExitCode does not have the output :)
12:17:19 <Deewiant> roconnor: :-D
12:17:24 <forkiliens> ah, ok.
12:17:25 <roconnor> Deewiant: ... stupid brain doing error correction.
12:17:32 <tromp> > reverse "bulb"
12:17:32 <forkiliens> thaks deewiant.
12:17:33 <lambdabot>  "blub"
12:17:47 <forkiliens> reverse "reverse"
12:17:53 <roconnor> This is going to be hard for me to unlearn.
12:18:01 <forkiliens> > reverse "reverse"
12:18:01 <lambdabot>  "esrever"
12:18:09 <Deewiant> forkiliens: runInteractiveCommand might be simpler though. I think it might be implemented in terms of *Process.
12:18:32 <forkiliens> @hoogle runInteractiveProcess
12:18:33 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
12:18:40 <forkiliens> @hoogle runInteractiveCommand
12:18:40 <lambdabot> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
12:18:58 <monochrom> forkiliens: Moreover, don't forget that you may (or may not) need to forkIO to have two threads, one feeding stuff to the external program, one getting stuff out, concurrently.
12:19:44 <forkiliens> forkIO, what's that?
12:19:53 <Deewiant> monochrom: eh? doesn't laziness mean you can give all the input at once and read the output at your leisure?
12:20:10 <gwern> hey, all you native english speakers. If I used the word 'elan' in normal conversation, would you understand me? show of hands
12:20:18 <cjb> Nope.
12:20:23 <forkiliens> lol
12:20:25 <Baughn> Not a chance
12:20:31 <monochrom> forkIO creates new threads.
12:20:36 <forkiliens> i'm not native but would understand it. lol
12:20:42 <monochrom> Laziness doesn't solve all problems.
12:20:53 <Deewiant> gwern: I learned a new word this day
12:21:07 <Deewiant> apparently lan though
12:21:20 <gwern> Deewiant: not elan I hope
12:21:29 <forkiliens> i would use "passion" for elan
12:21:31 <Deewiant> gwern: certainly
12:21:36 <forkiliens> i'm not native either
12:21:43 <sebell> gwern: I would say that elan is an adopted French word
12:21:49 <monochrom> I don't know elan. Is it a new country?
12:21:54 <gwern> Deewiant: depends. that's the original spelling, but as borrowed, english drops it
12:21:56 <shapr> gwern: I'd understand elan.
12:21:58 <mrd> Educational LANguage?
12:22:01 <augustss> Helan gr, sjung...
12:22:09 <shapr> augustss: God morgon!
12:22:15 <forkiliens> mrd: yes!! lol
12:22:20 <Deewiant> gwern: rather, english doesn't care much about spelling rules ;-)
12:22:28 <augustss> shapr: morgon?
12:22:29 <forkiliens> elan = Educational LANguage.... :)
12:22:34 <shachaf> Deewiant: No, but it cares about spelling.
12:22:35 <gwern> monochrom: no, it's the first name of a little boy kidnapped by the Cubans... aw, I'm joking
12:22:47 <shapr> augustss: Jag var i Vegas... och sovde inte...
12:22:53 <monochrom> Cubans are nice people.
12:22:55 <augustss> aha
12:22:58 <Deewiant> shachaf: Yes, but it's pretty arbitrary as to what is correct and what's not.
12:23:10 <gwern> ok, so about 4/8 people know it
12:23:16 <shapr> augustss: Hur gar det?
12:23:30 <mrd> i've seen elan used but not used it myself
12:23:35 <yitz_> Deewiant: no, it cares a *lot* about spelling rules. I once worked on a text-to-seech system that tried to have a full set. There were many, many rules.
12:23:39 <mrd> then again, i'm not french
12:24:03 <mrd> c'est nes pas une pipe
12:24:11 <shapr> Je ne parle pas francais.
12:24:20 <shapr> Mina en puhu suomea
12:24:32 <dmhouse> mrd: *ceci n'est pas une pipe, I believe.
12:24:39 <mrd> see, i'm not french
12:24:39 <shapr> I can speak southern drawl though.
12:24:43 <Deewiant> yitz_: I mean stuff like aether versus ether versus ther, elan versus lan
12:25:04 <gwern> Ceci n'est pas un francaise
12:25:08 <Deewiant> oxford spelling versus british spelling versus australian spelling versus american spelling
12:25:24 <forkiliens> @ all : who uses the net to learn a new language. i mean: it's the ideal place...
12:25:38 <monochrom> I used the net to learn Haskell.
12:25:40 <yitz_> Deewiant: well, those letters are not really part of the English alphabet officially.
12:25:42 <mrd> PL?
12:26:03 <monochrom> I used the net to learn Haskell. I much regret it.  Bird's book is so much better and more complete.
12:26:42 <forkiliens> language = natural language ... english, french etc.. :)
12:26:52 <shapr> augustss: hopp faderallan lallan lej ?
12:27:00 <mrd> without hearing it spoken? nah
12:27:08 <Deewiant> yitz_: and yet, the only correct way of spelling soupcon is soupon, for instance :-)
12:27:09 <forkiliens> since youtube....
12:27:22 <forkiliens> mrd: it's possible to hear it spoken..
12:27:58 <monochrom> Bird's book has monad transformers and strictness issues (e.g., foldl' ). You can't easily find both in a single coherent place on the net.
12:28:12 <shachaf> gwern++
12:28:17 <forkiliens> who is this guy bird?
12:28:19 <shapr> monochrom: You could fix that!
12:28:25 <shapr> forkiliens: Richard Bird, another famous FP guy.
12:28:30 <yitz_> Deewiant: grep '^soup.on$' /usr/share/dict/words => soupcon
12:28:31 <Deewiant> yitz_: 'facade', on the other hand, is nowadays fairly acceptable with only a c, I think.
12:28:31 <monochrom> I could also keep recommending Bird's book.
12:28:45 <Deewiant> yitz_: I don't trust such dictionaries. ;-)
12:29:23 <Deewiant> yitz_: but I suppose that that'll be naturalized soon enough, as well.
12:29:31 <opqdonut> yitz_: hardly, unless 'pc' is one character :)
12:29:37 <forkiliens> what's his book called?
12:29:59 <monochrom> Introduction to Functional Programming using Haskell, 2nd edition.
12:30:02 <opqdonut> yitz_: nvm, misread
12:30:51 <yitz_> Deewiant: what with Unicode and all...
12:31:09 <sethk> I have [(String,String)] and (String,String)    these are name/value pairs.  call the non-array value (newname, newvalue) and the list [(oldname,oldvalue)].  I need to check whether newname appears as one of the oldnames's.  If so, concatenate newvalue to oldvalue.  If not, add (newname, newvalue) to the end of the list
12:31:33 <Botje> :t lookup
12:31:34 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
12:31:36 <Botje> that can be of help.
12:31:43 <opqdonut> yep
12:31:50 <sethk> Botje, thanks, I'll look at it now.
12:31:55 <mrd> :t M.insertWith
12:31:55 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
12:31:59 <Deewiant> :t elem
12:32:00 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
12:32:23 <mrd> > M.toList . M.insertWith (++) "a" "2" . M.fromList $ [("a", "1")]
12:32:24 <lambdabot>  [("a","21")]
12:32:37 <mrd> > M.toList . M.insertWith (flip (++)) "a" "2" . M.fromList $ [("a", "1")]
12:32:38 <lambdabot>  [("a","12")]
12:32:49 <sethk> mrd, neat.  Now I need 15 minutes to figure out what it does.  :)
12:33:15 <forkiliens> monochrom: very cheap : 70.99  ... :) but seems to be good, at least what i can read from amazon
12:33:35 <monochrom> Yeah, only complaint is cost.
12:33:42 <yitz_> @type break
12:33:43 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:33:53 <sethk> mrd, actually ( :)  )  I need the values (where I concatenate) to have a space between them.
12:34:13 <sethk> yitz_, not sure what that does for me.
12:34:19 <mrd> > M.toList . M.insertWith (flip (++) . (++" ")) "a" "2" . M.fromList $ [("a", "1")]
12:34:20 <lambdabot>  [("a","12 ")]
12:34:27 <mrd> > M.toList . M.insertWith (flip (++) . (" "++)) "a" "2" . M.fromList $ [("a", "1")]
12:34:28 <lambdabot>  [("a","1 2")]
12:34:42 <yitz_> sethk: break gives you everything up to where the predicate matches, then everything after.
12:34:45 <sethk> mrd, thanks.  Let me grab that before it scrolls into the ether.
12:34:46 <Peaker> I didn't know Haskell had a motto "avoid success at all costs"
12:35:04 <monochrom> Don't take that motto seriously.
12:35:10 <yitz_> > let (h, t:ts) = break (== 7) [1..10] in (h, t, ts)
12:35:11 <lambdabot>  ([1,2,3,4,5,6],7,[8,9,10])
12:35:13 <Peaker> heh, yeah :-)
12:35:19 <mrd> yea, we avoid success at reasonable costs
12:35:36 <monochrom> Or rather, be careful what "success" means.  Some "success"es should be avoided by everyone, not just Haskell.
12:35:54 <monochrom> E.g., "success in selling snake oils" should be avoided, period.
12:36:05 <mrd> sethk: it uses Data.Map, which is really what you're expressing.  and i doubt that can be used as a homework soln.
12:36:13 <sethk> yitz_, I see what it does, but I'm missing where it's relevant.  My list is unordered so maybe that's more than I need?
12:36:16 <gwern> it's hard to plumb the full meaning of that phrase
12:36:20 <mrd> monochrom: that can be quite lucrative though
12:36:23 <sethk> mrd, I haven't done homework in 35 years
12:36:34 <mrd> neither have many students I know
12:36:41 <Deewiant> :-D
12:36:41 <gwern> 'Conquer the world by finding elegant and rigorous ways to do everything' doesn't quite have the same connotations
12:36:45 <sethk> mrd, I write software to do something, not for an exercise
12:36:50 <mrd> i'm just kidding you
12:36:59 <sethk> mrd, yes, I know that
12:37:06 <yitz_> sethk: you need to find one element of your list, change it, and leave the parts before and after to stay the same.
12:37:12 <mrd> anyway you may want to adjust your types to use Data.Map
12:37:30 <sethk> yitz_, oh, ok, as a way of knowing whether the value already exists in the list.
12:37:50 <sethk> mrd, I did think of Map, but it seems like overkill in this case.
12:37:55 <mrd> Map String String instead of [(String, String)]
12:37:59 <yitz_> mmm, more as a way to get at the different pieces you need
12:38:21 <sethk> mrd, I'm thinking that my data sets are small.  then again, the overhead of map won't matter if the data sets are small.
12:38:22 <mrd> well, it gives you insertWith, which is what you want
12:38:44 <sethk> mrd, yes, reading it now.
12:39:35 <sethk> mrd, ok, so I need a function to concatenate the values with the space between to use insertWith?
12:39:46 <mrd> yes
12:39:58 <mrd> iow, (flip (++) . (" "++))
12:40:25 <mrd> ?pl \ a b -> a ++ " " ++ b
12:40:25 <lambdabot> (. (' ' :)) . (++)
12:40:26 <yitz_> > unwords ["these", "are", "words"]
12:40:27 <lambdabot>  "these are words"
12:40:41 <mrd> ?pl \ a b -> b ++ " " ++ a
12:40:41 <lambdabot> flip (++) . (' ' :)
12:40:41 <sethk> mrd, why's that better than    value ++ " " ++ newvalue     ?
12:41:09 <yitz_> > words "these are words"
12:41:10 <lambdabot>  ["these","are","words"]
12:41:12 <mrd> you mean \ newvalue value -> ...?
12:41:21 <Peaker> @src words
12:41:22 <lambdabot> words s = case dropWhile isSpace s of
12:41:22 <lambdabot>     "" -> []
12:41:22 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
12:41:34 <mrd> that's fine
12:41:34 <Peaker> why isn't it generalized to join/split functions?
12:41:50 <mrd> i just think pointlessly nowadays
12:41:55 <yitz_> Peaker: you are not the first to ask that question :)
12:41:59 <sethk> I don't understand the difference between insertWith and insertWithKey
12:42:10 <unenough> yeah, take a function instead of isSpace
12:42:11 <sethk> mrd, I tend to write code that I will understand tomorrow.  :)
12:42:49 <yitz_> @src unwords
12:42:49 <lambdabot> unwords [] = ""
12:42:49 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
12:42:50 <mrd> i think that was a simple enough example. it can get worse.
12:42:56 <sethk> the function signature is different for insertWithKey
12:43:20 <mrd> ea
12:43:47 <yitz_> sethk: it's for when you need to use also the key (other than for the lookup) when computing the new value
12:44:01 <sethk> yitz_, k
12:45:46 <monochrom> My favourite books on functional programming:  http://www.vex.net/~trebla/photo/unorganized/20070513183534-v.jpg
12:47:14 <opqdonut> ooh, okasaki
12:47:19 <opqdonut> bound
12:47:35 <Botje> bondage?
12:47:48 <Botje> oh :p
12:47:51 <monochrom> Yes, it's such a good book I deliberately sought hard cover. :)
12:48:10 <monochrom> I also have hard cover K&R. :)
12:48:27 <mrd> there is hardcover okasaki?
12:48:30 <monochrom> Kernighan visited U of Toronto and I also got his autograph :)
12:48:37 <mrd> huh
12:48:37 * xerox only has paperback
12:48:57 <xerox> ...but I have a Benoit Mandelbrot autograph! :-)
12:49:11 <sethk> monochrom, I saw Richie at Bell Labs a few times, and korn.
12:49:29 <monochrom> I hope the Mandelbrot autograph doesn't have fractional dimension. XD
12:49:44 <sethk> monochrom, it will become unstable over time.
12:49:49 <Zao> xerox: http://www.acc.umu.se/~torben/images/mandelbrot.jpg
12:49:50 <xerox> It *might*, is quite rough.
12:50:00 <xerox> Zao: oh, cute.
12:50:07 <monochrom> chicken cute :)
12:50:18 <monochrom> I want his chicken!
12:50:44 <Zao> You can't have our Torben :P   http://www.acc.umu.se/~torben/xml/celebs.xml
12:50:44 <lambdabot> Title: [Torben] - Me and my celebrity friends
12:51:58 <monochrom> Oh, I see.  Torben is sacred.  Please send me my regards to Torben.
12:52:04 <hpaste>  (anonymous) pasted "bublesort" at http://hpaste.org/6773
12:52:56 <monochrom> Sorry, bubble sort is too hard for me.
12:53:27 * monochrom only understands insertion sort, then merge sort, quick sort, radix sort.
12:55:27 <FalconNL> Can anyone tell me if it is possible to remove the duplication in ADTs when all constructors have the same parameters?
12:55:28 <FalconNL> for instance, I'd like to transform
12:55:29 <FalconNL> --every constructor follows the pattern of name x y
12:55:31 <FalconNL> data TerrainCell = Forest Int Int | Mountain Int Int | Swamp Int Int
12:55:32 <FalconNL> into something along the lines of
12:55:33 <DRMacIver> Hm. cabal install appears to have got itself really confused.
12:55:34 <FalconNL> data TerrainCell = (Forest | Mountain | Swamp) Int Int
12:55:34 <DRMacIver> Sigh.
12:55:36 <FalconNL> (which obviously isn't valid Haskell)
12:55:53 <Heffalump> not short of replacing it with a different type declaration + a type alias for a tuple
12:55:58 <Heffalump> or a two-level type
12:56:12 <Cale> FalconNL: data Terrain = Forest | Mountain | Swamp; data TerrainCell = TC Terrain Int Int
12:56:13 <dbpatterson> how does ghc search for modules? I have a folder examples and a module common.hs in it, looking for Examples.Common doesnt find it...
12:56:26 <mrd> dbpatterson: might be case sensitive
12:56:30 <cjb> dbpatterson: maybe if your folder was Examples and your file was Common.hs?
12:56:31 <opqdonut> FalconNL: well just say data TerrainType = Forest | ... and data Terrain = T Terrain Int Int
12:56:34 <opqdonut> oh, late
12:56:53 <FalconNL> Cale, opqdonut: yeah, that'll work. Thanks.
12:57:21 <dbpatterson> mrd, cjb: oh I know how to get around it, I was just wondering because this is from an example library from someone else, and I was wondering if there is just an option I need to change to make it work (without manually changing that)
12:57:36 <dbpatterson> to make it look case insensitively
12:57:39 <cjb> dbpatterson: well, some filesystems (e.g. Windows) are case-insensitive
12:57:58 <dbpatterson> cjb: ahh, that might do it.
12:59:02 <cjb> OS X is case-insensitive but case-preserving, I think.
13:05:48 <dbpatterson> sclv_: you here?
13:07:30 <gwern> how strange. there's no haskell hacking I feel like doing
13:08:12 <roconnor> gwern: I could give you suggestions.
13:08:13 <gwern> problem is, people aren't replying to me
13:08:50 <gwern> roconnor: I already have a list, but do you have anything particularly interesting or relevant to my interests in mind?
13:10:35 <roconnor> gwern: take Haskell Charts and augustss's numeric string expression library and combine them to allow one to easily plot simple math functions with automatic labels.
13:10:54 <Heffalump> numeric string expression?
13:11:10 <roconnor> gwern: as the next step towards replaceing the awfulness that is gnuplot.
13:11:40 <roconnor> Heffalump: how should I call: http://augustss.blogspot.com/2007/04/overloading-haskell-numbers-part-1.html ?
13:11:42 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2gh7aw
13:11:45 <gwern> I don't know what either is; well, reading about those two will help my awful world-beating ennui
13:12:33 <Heffalump> oh, right. Something to do with DSELs.
13:12:36 <sjanssen> roconnor: symbolic arithmetic?
13:13:05 <Heffalump> the string bit is just to print out the formula, is it?
13:13:12 <Heffalump> yes, what sjanssen said.
13:13:27 <sjanssen> roconnor: that is actually a very good idea
13:13:40 <roconnor> sjanssen: of course it is. :P
13:13:48 <gwern> roconnor: I don't quite see how they go together
13:14:18 <roconnor> gwern: well, gnuplot lets you plot simple (and not so simple) math expressions
13:14:36 <roconnor> gwern: and gnu plot will make a nice title for you that has your expression.
13:14:48 <roconnor> gwern: I always wanted to replace gnuplot with a haskell library
13:15:13 <roconnor> gwern: but I didn't see how to get the nice titles without forcing the user to write things out twice.
13:15:15 <gwern> ok.. so 'gnuplot = "y = x+1"' gives you a nice little linear chart?
13:15:21 <roconnor> once as a string and once as an expression.
13:15:47 <roconnor> but augustss shows how you can get both a string and an expression from the same bit of code.
13:16:20 <gwern> ah, so you're thinking 'roconnorplot arg = gnuplot title arg where title = augustssparse arg'?
13:16:28 <roconnor> you can even go on to use his automatic differentiation to try an implement cool non-uniform sampling.
13:16:38 <Heffalump> the other thing to look at is his recent post about interpreting functions
13:16:39 <roconnor> but one step at a time.
13:17:26 <Heffalump> then you can literally specify a Haskell function and still print out its definition
13:17:57 <roconnor> gwern: more like 'roconnorplot arg = chartplot title arg where title =augustssinterpret  arg'?
13:18:06 <sjanssen> > var "x" ^ 2
13:18:07 <lambdabot>  x*x
13:18:20 <sjanssen> > var "x" ^ 2 + var "y" ^ 2
13:18:21 <lambdabot>  x*x+y*y
13:18:38 <gwern> hmm... so what would be the use case of a roconnorPlot :: (Num a) => (a -> a -> a) -> Graph as opposed to roconnorPlot :: String -> Graph?
13:18:41 <roconnor> sjanssen: hush you.
13:18:50 <roconnor> ;)
13:18:55 <Heffalump> gwern: much cooler.
13:19:05 <Heffalump> you'd have to parse the String
13:19:16 <sjanssen> > map (\n -> sust x n (var "x" ^ 2 + var "y" ^ 2)) [0..]
13:19:16 <lambdabot>   Not in scope: `sust'
13:19:18 <roconnor> gwern:  roconnorPlot :: (Num a) => (a -> a -> a) -> Graph is typesafe.
13:19:18 <gwern> Heffalump: I don't do graphing. I'm finding it hard to see how the former is more useful
13:19:22 <Heffalump> and so no type safety or even syntax safety
13:19:23 <sjanssen> > map (\n -> subst x n (var "x" ^ 2 + var "y" ^ 2)) [0..]
13:19:24 <lambdabot>  Couldn't match expected type `String' against inferred type `Expr'
13:19:35 <Heffalump> it's nothing to do with graphing, it's about the standard benefits of a DSEL.
13:19:37 <roconnor> gwern: and it is extensable.
13:19:42 <sjanssen> > map (\n -> subst "x" n (var "x" ^ 2 + var "y" ^ 2)) [0..]
13:19:43 <lambdabot>  [y*y,1+y*y,4+y*y,9+y*y,16+y*y,25+y*y,36+y*y,49+y*y,64+y*y,81+y*y,100+y*y,121...
13:19:43 <Heffalump> you get all the usual features of the host language
13:20:12 <Heffalump> and you don't need a parser
13:20:15 <Heffalump> or a type-checker
13:20:19 <Botje> > (var "a" + var "b")^2
13:20:20 <lambdabot>  (a+b)*(a+b)
13:20:33 <Botje> aww, it doesn't process any further
13:20:43 <monochrom> http://www.vex.net/~trebla/weblog/fpbooks.xhtml :)
13:22:18 <Heffalump> "any further"?
13:22:41 <Botje> yeah, like a^2 + 2*a*b + b^2
13:22:47 <Heffalump> ah
13:22:49 <Heffalump> @type (^)
13:22:50 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
13:23:01 <Heffalump> I suspect it's related to the fact that a and b are different type variables
13:23:05 <Heffalump> > 2*var "a"
13:23:06 <lambdabot>  2*a
13:23:20 <MyCatVerbs> > foldr f (take 4 $ repeat a)
13:23:20 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr [Expr])
13:23:26 <Heffalump> > var "a" ^ var "b"
13:23:32 <lambdabot> Terminated
13:23:48 <Heffalump> oops..
13:24:02 <Heffalump> ok, so what's going on there is that ^ is a library function.
13:24:02 <MyCatVerbs> > foldr f (take 4 $ repeat (var "a"))
13:24:03 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr [Sym a])
13:24:09 <sjanssen> > var "a" ** var "b"
13:24:09 <lambdabot>  a**b
13:24:13 <Heffalump> And it works by repeated subtraction (or perhaps repeated division)
13:24:25 <gwern> roconnor: ok, I think I follow. so haskellCharts is a library conceptually haskellCharts :: PlotWindowType a => a -> Graph, and you are suggesting that PlotWindowType variables can be turned into Strings by augustss, and the String used as part of the generated Graph
13:24:25 <sjanssen> repeated division
13:24:28 <Heffalump> so it tries to unfold the exponent, and makes a mess.
13:24:34 <Heffalump> or rather, an infinite loop
13:24:40 <gwern> roconnor: but does Haskell Charts allow you to have headers?
13:25:06 <roconnor> gwern: I'm not sure, but it definitely allows a legend.
13:25:36 <gwern> http://dockerz.net/software/chart/doc/html/Graphics-Rendering-Chart-Renderable.html has a Legend datatype
13:25:37 <lambdabot> http://tinyurl.com/389u67
13:26:23 <roconnor> gwern: what I'm suggesting is that simple math expressions can be transformed into both Strings and PlotType.
13:27:13 <forkiliens> what is more likely used: ghci or hugs, and why?
13:27:13 <gwern> roconnor: but I think simple math expressions are already plottybe
13:27:25 <mrd> ghci
13:27:31 <forkiliens> why?
13:27:33 <gwern> an example the haskell charts gives is 'Prelude Graphics.Rendering.Chart.Simple> plotWindow [0,0.1..2.9] sin'
13:27:39 <roconnor> gwern: sure, but they are not obviously strings.
13:27:47 <mrd> because it works great and does everything ghc does?
13:27:47 <gwern> looks like a split apart math expression to me
13:28:01 <forkiliens> roconner: what's this discussion about math expressions, i'm interested
13:28:04 <gwern> forkiliens: because it is superior on most technical grounds to hugs
13:28:20 <Heffalump> the only advantage hugs has I know of is that it loads up faster
13:28:23 <gwern> forkiliens: except possibly with windows usability issues
13:28:27 <forkiliens> ok, i used it too, but wasn't sure which one was better. thanks
13:28:36 <roconnor> forkiliens: I'm trying to find nice ways of reimplementing gnuplot.
13:28:44 <Heffalump> (and as an independent implementation, it's good for testing standards-complience)
13:28:45 <forkiliens> oh.
13:28:48 <Heffalump> s/complience/compliance/
13:29:12 <forkiliens> roconnor: any process?
13:29:49 <gwern> sure, but yhc or nhc would also be good for standards checking
13:30:26 <sjanssen> gwern: yhc and nhc aren't nearly as complete as Hugs
13:30:51 <gwern> I guess augustss doesn't have any more complete setup of that blog post's code. pity
13:30:52 <forkiliens> if you define a monad, do you proof that they have the monad properties?
13:31:22 <forkiliens> stupid question. i'm just curious ...
13:31:23 <Cale> forkiliens: yes
13:31:40 <bos> defining a monad doesn't prove this for you. you have to (if you feel like it) do it yourself.
13:31:41 <sjanssen> @hackage numbers
13:31:41 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
13:31:50 <sjanssen> gwern: you didn't look very hard :)
13:32:07 <gwern> @quote monad law
13:32:07 <lambdabot> No quotes for this person. This mission is too important for me to allow you to jeopardize it.
13:32:07 <monochrom> I haven't defined my own monad for a long time.
13:32:18 <gwern> sjanssen: I was looking on his blog :(
13:32:20 <gwern> @quote law
13:32:20 <lambdabot> monochrom says: The Three Laws of Types. (1) Must protect programmer. (2) Must obey programmer, when not in conflict with (1). (3) Must protect computer, when not in conflict with (1) or (2).
13:32:32 <gwern> @quote laws
13:32:32 <lambdabot> Daveman says: Cale, what if I don't want to obey the laws?  Do they throw me in jail with the other bad monads?
13:32:33 <forkiliens> i wondered if a term rewriting system could proof things like that, or automated proof systems.
13:32:34 <roconnor> forkiliens: by starting wtih Haskell Chart, and using http://augustss.blogspot.com/2007/04/overloading-haskell-numbers-part-1.html to automatically produce strings for the lengend from the expression to be plotted
13:32:36 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2gh7aw
13:33:20 * gwern will go have a snack now and return to this charts stuff later
13:34:05 <forkiliens> or at least try to...
13:34:14 <Peaker> what's "Unique Supply" monad useful for?  Why not just iterate a list normally?
13:35:18 <monochrom> Code re-use.
13:35:20 <Cale> Peaker: Well, it can help enforce the invariant that elements are used only once.
13:36:27 <monochrom> Re-use Re-factor Re-curse
13:36:34 <Peaker> Cale, But one can "use" the element after extracting it multiple times...?
13:36:36 <roconnor> wow, the PR machine for xmonad is really at work with thier latest press release
13:36:45 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6774
13:36:46 <Peaker> Cale, Doesn't "forM_" enforce that property too?
13:37:14 <sjanssen> Peaker: sometimes the iteration is more complicated than forM_ can provide
13:37:25 <roconnor> ``Founded on a theory of generalised derivatives of datatypes, the tiling window management model is expected to produce obvious improvements in productivity, scalability and ease of use for GNOME users.
13:37:42 <sjanssen> Peaker: consider a compiler that needs to generate fresh symbol names -- forM probably won't work there :)
13:37:55 <Heffalump> theory of generalised derivatives? That's a bit of an elaborate way of putting "zipper"...
13:37:56 <roconnor> "generalised derivatives of datatypes" -> a pair of lists
13:38:00 <hpaste>  evans pasted "lista3" at http://hpaste.org/6775
13:38:07 <Heffalump> a zipper is a bit more than a pair of lists
13:38:22 <sjanssen> xmonad's zipper isn't much more than that :)
13:38:24 <byorgey> a pair of lists, plus a focused element!
13:38:31 <Heffalump> it's not a tree?
13:38:32 <byorgey> the focused element always feels left out
13:38:35 <roconnor> "Founded on a pair of lists, the tiling window management model is expected to produce obvious improvements in productivity, scalability and ease of use for GNOME users.
13:38:38 <lament> it's enough to just have a pair of lists, really
13:38:51 <shepheb> well, lists are unary trees
13:38:55 <Heffalump> if you are differentiating a list, then yes, a pair of lists + a focus is the result
13:39:01 <lament> roconnor: that always pissed me off about darcs
13:39:02 <Heffalump> but I thought xmonad used a proper tree
13:39:03 <roconnor> "Founded on a pair of a list and a non-empty list, the tiling window management model is expected to produce obvious improvements in productivity, scalability and ease of use for GNOME users.
13:39:05 <hpaste>  (anonymous) annotated "lista3" with "(no title)" at http://hpaste.org/6775#a1
13:39:16 <lament> "Originally developed by physicist David Roundy, darcs is based on a unique algebra of patches."
13:39:20 <Peaker> sjanssen, ah, I see! you want to restrict the State monad to the correct functionality subset you will need then
13:39:21 <Heffalump> lament: but it's much more true about darcs, even if the theory is a bit on the woolly side.
13:39:24 <Peaker> sjanssen, thanks
13:39:43 <Heffalump> there really is some theory behind it, and it's genuinely new and innovative stuff
13:39:50 <lament> Heffalump: yeah, but buzzwords are still buzzwords.
13:39:51 <monochrom> Gosh, that xmonad press release attains a new level of hogwash.
13:39:57 <Heffalump> which is the buzzword?
13:40:08 <lament> Heffalump: in that sentence, "physicist" and "algebra"
13:40:10 <byorgey> ...everyone does realise what day it is, right? ;)
13:40:12 <Twey> xmonad crashed on me :-(
13:40:16 <Twey> byorgey: Heh
13:40:37 <Philippa> lament: it's genuinely an algebra, what else are you supposed to call it? Physicist is less relevant
13:40:39 <sjanssen> Peaker: the truth is that most monads can be replaced with manual parameter passing -- the idea is to package up these patterns in libraries
13:40:41 <Heffalump> but they're both true
13:40:53 <byorgey> Twey: boo, what happened?  want to talk about it?
13:40:54 <Heffalump> physicist is somewhat irrelevant but it does give you an idea of where it's coming from
13:40:58 <lament> Philippa: yes, and enterprise synergy is genuinely enterprise synergy
13:41:06 <lament> buzzword doesn't mean lies
13:41:10 * byorgey LOVES enterprise synergy!
13:41:19 <byorgey> it's so synergistic and enterprise-y
13:41:28 <Philippa> lament: it does mean wishy-washy bullshit though
13:41:41 <Twey> byorgey: The mod key stopped working, then a little while later xmonad just bombed out completely and restarted X
13:41:42 <Philippa> whereas really, where *outside* the haskell community is algebra a buzzword?
13:41:50 * Twey wonders idly if there's a log somewhere.
13:41:54 <Philippa> in most places it's more of a deathy silenceword
13:41:59 <byorgey> Twey: check ~/.xsession-errors
13:42:01 <Heffalump> Twey: of this channel? see the topic
13:42:01 <lament> Philippa: that's the point! These are buzzwords, they're just haskelly buzzwords as opposed to "normal" buzzwords
13:42:07 <Heffalump> oh, of xmonad, sorry :-)
13:42:13 <roconnor> byorgey: ugh.  Damn april 1st.
13:42:15 <lament> Philippa: every haskeller will go "ooh, an ALGEBRA"
13:42:17 <Peaker> sjanssen, Yeah, I see
13:42:20 <byorgey> roconnor: hehe
13:42:29 <Heffalump> lament: but they'd be right to do so, even if it's not a very good algebra.
13:42:30 <Philippa> lament: I don't, a good many others don't
13:42:35 <Heffalump> It's better than any other VC system around.
13:42:38 <lament> "darcs is the best! it's based on an ALGEBRA"
13:42:42 <roconnor> byorgey: well played
13:43:01 <Zao> I thought that darcs was based on Kludge Theory.
13:43:05 <Philippa> lament: as haskellers we generate new (or at least the same old thing encoded again) algebras all the damn time
13:43:21 <Philippa> some of us even knowingly generate coalgebras too
13:43:29 <lament> Philippa: exactly. i don't see how the fact that there's an algebra deserves a special mention on the front page
13:43:32 <roconnor> byorgey: this is what I get for reading half a press release and stoping after I'm disgusted.
13:43:37 <Heffalump> zao: as far as your average algebraic theory goes, it is. As far as your average VC system goes, it's not.
13:43:38 <Twey> byorgey: Don't think it goes back far enough... I'll just have to wait and see if it happens again :-\
13:43:47 <Heffalump> lament: but it is something unique to darcs. Why shouldn't it advertise it?
13:43:48 <roconnor> byorgey: I see that it gets sillier
13:43:57 <byorgey> roconnor: hehe, indeed =)
13:43:58 <Heffalump> It implies to people that they might be able to reason about what darcs is doing, for example.
13:44:03 <lament> Philippa: patches form some algebraic structure in any version control system.
13:44:07 <Heffalump> "enterprise synergy" doesn't really tell people much.
13:44:23 <Heffalump> lament: yes, but darcs is explicit about that. With other systems you have to guess or work it out for yourself.
13:44:45 <Philippa> "enterprise synergy" pretty much means "two great things that taste great together!"
13:44:45 <roconnor> I'm not convinced other VCS have a consistent algebra.
13:44:51 <byorgey> Twey: that's too bad. =(  If it does happen again, say something in #xmonad.  Any crash is one crash too many.
13:44:52 <Cale> "Corporate synergy occurs when corporations interact congruently" -- from Wikipedia
13:45:01 <Heffalump> roconnor: I'm not entire convinced darcs does either :-)
13:45:08 <sjanssen> roconnor: gnome 3.0 didn't tip you off?
13:45:16 <Philippa> Cale: or "we're working together and it isn't a complete mess"
13:45:19 <Twey> byorgey: 'kay :-)
13:45:26 <roconnor> sjanssen: nope, I use kde
13:45:38 <monochrom> There is no relation between datatype differentiation and tiling.  You can found tiling on anything.  You can use datatype differentiation to found anything.  "Founded on datatype differentiation, the tiling model..." is as nonsense as "Using batteries, the laptop..."
13:46:35 <lament> using an algebra, darcs...
13:46:52 <monochrom> Of course it also depends on the "..."
13:47:09 <Philippa> lament: at a bare minimum that implies a formal model
13:47:28 <lament> allright, allright. You can have your algebra. :)
13:47:35 <monochrom> "Founded on datatype differentiation, the tiling model increases productivity".  "Using batteries, the laptop can run Linux."  Total irrelevance.
13:47:42 <lament> but "physicist" in the same sentence is clearly too much
13:47:54 <byorgey> it seems monochrom also didn't get the memo about what day it is. ;)
13:48:14 <roconnor> lament: he should have used "doctor" instead. :P
13:48:15 <monochrom> Um, ok, I'll stop.  Thanks for the laugh. :)
13:48:25 <Apocalisp> @quote \.\.\.
13:48:25 <lambdabot> lament says: three laws of robotics: 1) don't do anything unless you ABSOLUTELY HAVE TO 2) ...other laws to be written as they become required
13:48:36 <Twey> monochrom: Heh
13:48:41 <roconnor> @quote lament
13:48:42 <lambdabot> lament says: three laws of robotics: 1) don't do anything unless you ABSOLUTELY HAVE TO 2) ...other laws to be written as they become required
13:48:46 <monochrom> But where is it posted?  I don't see it on -cafe etc.
13:48:58 <roconnor> monochrom: I read it on planet haskell.
13:49:16 <byorgey> monochrom: oh, I don't mind, you may continue.  I just thought you were still taking it seriously. =)
13:49:35 <monochrom> I like lament's laziness laws.
13:50:09 <monochrom> I took it seriously until you reminded me.  Mia culpa.
13:50:16 <byorgey> hehe
13:50:19 <cjb> monochrom: Mea.
13:50:28 <monochrom> Damn Latin.
13:50:39 <lament> Mi culpa es tu culpa.
13:50:47 <cjb> lament: hah!
13:50:52 <byorgey> "GNOME developers are able to take advantage of powerful user interface tools based on reactive programming, lazy evaluation, co-monadic effects and delimited continuations, previously unavailable to people who's name wasn't "Oleg"."  heh
13:50:53 <monochrom> haha
13:51:33 <lament> @oleg
13:51:38 <lament> boo
13:51:40 <lambdabot> Defined.
13:51:51 <byorgey> @quote OlegFacts
13:51:51 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
13:51:52 <lament> what?
13:52:00 <byorgey> lament: spell-corrected to 'let' apparently =)
13:52:26 <lament> @quote oleg
13:52:26 <lambdabot> emu says: olegarithmic
13:54:02 <lament> @quote oleg
13:54:02 <lambdabot> Pseudonym says: "Assuming an advanced compiler, your code will be sent to Oleg who will implement it in the type system."
13:54:52 <byorgey> @quote OlegFacts
13:54:52 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
13:54:56 <byorgey> @quote OlegFacts
13:54:56 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
13:55:05 <Saizan> there's only one
13:55:08 <byorgey> grr, there used to be more I thought
13:55:27 <byorgey> someone added more the other day, guess \bot went down before saving them.
13:56:01 <sethk> the syntax to control what's exported?  Is it   module Xyz (abc, def) where ...             ?
13:56:09 <byorgey> sethk: yup.
13:56:17 <sethk> byorgey, thanks
13:56:26 <byorgey> I wonder if Oleg knows how legendary he is.
13:58:45 <gwern> byorgey: I'm sure he does. I've made appropriate obeisances in emails to him when I was packaging up ZFS
13:59:13 <byorgey> hehe, I see =)
14:02:42 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6777
14:03:39 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6778
14:03:41 <__pao__> hi all :-)
14:04:03 <__pao__> is it possibile to define a data type with ghci?
14:04:17 <monochrom> No.
14:04:46 <__pao__> monochrom: thanks
14:07:28 <catface> can anyone fix this duplicate instances problem? http://hpaste.org/6778
14:07:40 * Peaker wonders why so many Haskell papers refer to "implementation details" as "plumbing"
14:08:25 <Jiten> Well, I think it fits quite well the way I've started thinking about the program flow when using haskell :)
14:09:10 <Peaker> in the case of sequential monads, I visualize the binding as forming a long pipe, so that may work :)
14:09:16 <Jiten> I mean, you could think of every function as a tube where you put data in the other end and data out the other end :)
14:09:35 <byorgey> Peaker: functional programming tends to center around functions which manipulate data.  the data 'flowing' through the 'plumbing' of the functions is a natural metaphor.
14:10:20 <monochrom> IIUC it is because whenever you write "(...) => Test a" the computer does not look at what's inside (...) until a very late stage.  That means at an early stage it sees "instance Test a" twice.
14:10:26 <byorgey> right, you also often hear people refer to something like  f . g . h as a 'pipeline' =)
14:10:35 <DRMacIver> Hm
14:10:43 <catface> i see
14:10:50 <DRMacIver> Agda claims a dependency on QuickCheck >= 2.0. As far as I can tell no such version exists.
14:10:53 <catface> thanks
14:11:04 <DRMacIver> And I can't find a darcs for quickcheck
14:11:06 <byorgey> DRMacIver: It does, but it's not on Hackage.
14:11:08 <Heffalump> DRMacIver: might be part of a future plan to integrate the two.
14:11:25 <DRMacIver> Ah, found the darcs.
14:11:28 <DRMacIver> Problem solved. :)
14:11:31 <Heffalump> http://darcs.haskell.org/QuickCheck
14:11:32 <glguy> Those instances overlap because they can't deal with a type that is an instance of both C1 and C2
14:11:33 <lambdabot> Title: Index of /QuickCheck
14:12:23 <glguy> and you haven't (and can't) tell the compiler that an instance of C1 is never an instance of C2 or visa versa
14:13:57 <catface> thanks
14:13:58 <sethk> I'ved moved something to it's on module, and I want to hide implementation.  I currently use a type (defined in a type statement) in the other .hs file.  Can I make that type available without exporting it's definition?
14:14:21 <glguy> add it to the module exports list with ()
14:14:27 <glguy> module Main (MyType()) where
14:14:44 <sethk> glguy, ok, and using () hides the details?
14:14:54 <roconnor> catface: typically we use newType to slide around these sorts of issues, but you may know this already.
14:14:57 <roconnor> newtype
14:14:59 <gwern> man, nofib's makefiles are so messed up, I can't even figure out
14:15:49 <byorgey> sethk: it hides the constructors, yes
14:17:00 <catface> thanks
14:17:11 <roconnor> glguy: do you need the () in module Main (MyType()) where ?
14:17:38 <glguy> I don't know that its necessary, I consider it a good habit in my code
14:18:17 <roconnor> glguy: Hmm, you are probably right.
14:18:39 <glguy> roconnor: doesn't seem to be required
14:18:41 <roconnor> okay, I'll try it out in my new code.
14:18:43 <glguy> in Haskell 98
14:19:03 <roconnor> glguy: I'm with you that it is probably a good idea.
14:23:25 <gwern> hm. seems nofib wants fptools... which got broken up years ago
14:23:57 <gwern> whenever I see this sort of thing, I wonder how people check in patches. how the deuce are they even running the make files much less compiling?
14:25:48 <monochrom> The author probably still has fptools on his disk. :)
14:26:29 <gwern> must be
14:27:41 <gwern> wonderful. config.mk is a configure-generated file
14:29:00 <gwern> @hoogle ST
14:29:00 <lambdabot> Control.Monad.ST :: module
14:29:00 <lambdabot> Data.Array.ST :: module
14:29:00 <lambdabot> Control.Monad.ST.ST :: data ST s a
14:29:23 <monochrom> Yes, once upon a time, we believed in autoconf, automake, autodevelop, autodebug, autopackage, autoinstall.
14:30:01 <monochrom> Then we decided we would not like to take ourselves out of the loop.
14:30:20 <gwern> monochrom: y'all didn't have cabal, so I am a bit sympathetic
14:30:27 <gwern> on the other hand, I dunno any reason cabal couldn't've been developed years earlier
14:30:41 <bos> gwern: insufficient people power.
14:31:01 <monochrom> gwern: insufficient bot power.
14:31:04 <gwern> @hoogle MutableArray
14:31:05 <lambdabot> No matches found
14:31:20 <Jaak> @google MArray
14:31:21 <lambdabot> http://www.marray.com/
14:31:21 <lambdabot> Title: Marray Inc.
14:31:23 <gwern> @hoogle newVector
14:31:23 <lambdabot> No matches found
14:31:27 <Jaak> bah, hoogle*
14:31:33 <dmwit> ?tell cjs Yup, you're on the right track, but try generalizing the Int in "instance Countable (a -> Int)" a little bit.
14:31:33 <lambdabot> Consider it noted.
14:31:59 <gwern> ok... I thinketh this little benchmark is too bitrotten
14:32:30 <dmwit> Oh, gwern!
14:32:43 <dmwit> I was thinking about the grenade problem a bit more this morning.
14:32:54 <dmwit> I think the states are the cross product of which color you have and which question you lie on.
14:33:16 <gwern> dmwit: as was I. I'm still convinced three questions suffice, as with no lies, 2 questions can do it
14:33:30 <dmwit> So with three questions, there are 9 states, and as you said you can only tell between 8 states with three questions.
14:34:03 <dmwit> But with four questions, there are 12 states, and you can tell between 16 possible states, so 4 is enough questions.
14:34:17 <gwern> dmwit: I worked through 'r or b?' 'r or b?' 'b or g?' and it *almost* works, there's just two answers which are indistinguishable
14:34:24 <dmwit> gwern: right
14:34:52 <gwern> well, we already knew 4 questions suffice
14:34:58 <shachaf> Which is the grenade problem?
14:35:01 <dmwit> gwern: I've worked through all possible three-question sequences, so...
14:35:16 <glguy> dmwit: what problem are you referring to? do you have a URL?
14:35:16 <dmwit> shachaf: Assume an adversary has a grenade that is either red, green, or blue.
14:35:33 <dmwit> shachaf: How many questions do you need to discover what color it is, assuming he can lie at most once?
14:36:50 <gwern> I've been musing more complex questions, like perhaps you could make the first question a question he must lie on; and then it's the 3-grenade case with no lying and 2 more questions obviously suffice for a total of 3
14:37:03 <dmwit> Right, but how do you make him lie?
14:37:17 <gwern> but unfortunately all the ones I've come up with involve prediction and suchlike, which seems like cheating to me
14:37:27 <dmwit> If it's a question you both know the answer to, there's no incentive for him to lie, and if you don't know the answer but he does, you can't know whether he lied or not...
14:38:09 <dmwit> (And if he doesn't know the answer, "I don't know" is not a lie. =P)
14:38:12 <gwern> dmwit: well, I cam up with some cute ones like 'is the xor of the true answers to the two previous questions True?'
14:38:26 <dmwit> ah
14:38:30 <\z> is it possible to run QuickCheck directly from within HUnit as an HUnit test?
14:38:39 <dmwit> But he can't change whether he lied in the past, so I agree; that seems like cheating. =)
14:38:53 <ketil> I keep asking this, but what is the argument against 'fail' again?
14:39:02 <gwern> dmwit: I have an intuition it's possible to devise a question such that if he doesn't lie, he contradicts himself
14:39:05 <glguy> Is it red? Is it blue? have you lied?
14:39:06 <shachaf> ketil: Against?
14:39:19 <glguy> i guess he could lie
14:39:22 <glguy> on the last question :)
14:39:36 <gwern> glguy: precisely
14:39:54 <gwern> glguy: it'd probably be easier if he has to lie once, but that's not the way the problem is setup
14:40:00 <ketil> shachaf, yes.  Or in favor, if you have them.
14:40:00 <glguy> oh
14:40:02 <Jaak> dmwit: ah, that was fun exercise
14:40:05 <glguy> can *can* lie once?
14:40:13 <glguy> he can*
14:40:16 <dmwit> glguy: Right, he lies *at most* once.
14:40:17 <ketil> Is it just that it is a member of Monad and not MonadZero?
14:40:17 <shachaf> ketil: Oh, I see. That type of argument. :-)
14:40:27 <gwern> (the lie being optional makes things that much harder)
14:40:33 <dmwit> Jaak: Which one, the grenade one?
14:40:53 <Jaak> no, the count thingy
14:41:01 <dmwit> Jaak: Ah, yes, I agree!
14:41:03 <dmwit> very fun
14:41:30 <ketil> shachaf, No, not that type of argument - I wanted to use it, but worry that it isn't kosher.
14:42:01 <shachaf> Which is the count thingy? :-)
14:42:21 <gwern> too many conversations goin' on :)
14:42:22 <dmwit> shachaf: Implement a function count so that:
14:42:42 <dmwit> shachaf: (a) [count, count 1 2 3, count (+) id] :: [Int] === [0, 0, 0]
14:42:58 <dmwit> shachaf: (b) [count, count 1 2 3, count (+) id] :: [Int] === [0, 3, 2]
14:43:26 <dmwit> shachaf: (i.e. a count that polymorphically returns 0 for any number of arguments or that polymorphically returns the number of arguments it is applied to)
14:43:52 <Jaak> don't post solutions, yet
14:44:09 * EvilTerran has a pretty good idea
14:44:16 <EvilTerran> i've read a lot of olegs :P
14:44:28 <dmwit> Right, it's a homework problem that hasn't come due yet, so be careful what you say. =)
14:44:40 <ketil> shachaf, but I think I got it on my own - I should use mzero in monadplus instead.
14:44:52 <dmwit> The one restriction is that you have to use H98 -- no GHC extensions.
14:45:15 <shachaf> ketil: mzero might be best, but then it has to be MonadPlus.
14:46:14 <orzo> how do i convert a Ptr CChar to an Int for printing purposes
14:46:16 <ketil> shachaf, is it abuse to use it for when I just need some way of "failing" to produce a value, and no other monad functionality?
14:46:43 <ehird> http://www.lisperati.com/landoflisp this may be a joke, but is severely misguided
14:46:50 <ehird> & quite rude towards haskell
14:46:50 <monochrom> We love homeworks!  They're delicious.
14:46:56 <ehird> i don't think the author has ever used haskell
14:46:58 <cjb> don't trust any webpages you read today :)
14:47:07 <cjb> it's clearly a joke
14:47:10 <ketil> shachaf, i.e. just use MonadPlus a => as a shorthand for "a should be Maybe or []"
14:47:25 <ehird> cjb: yes
14:47:37 <ehird> but it's also a real comic
14:47:46 <ehird> & it says its a preview of a book. Also, it's after april fools time
14:47:51 <shachaf> ketil: Many MonadZeros are also MonadPluses.
14:47:53 <Feuerbach> how to make haddock generate HTMLized source and links to it? as in online docs
14:47:57 <shachaf> So it shouldn't be too much of a problem.
14:48:01 <ehird> 'My April 1st Surprise- New Comic Novella on Lisp and FP Programming' -- reddit posting
14:48:05 <ehird> so I guess it's not 100% april fools
14:49:04 <ehird> but its attitude to haskell is really quite annoying
14:49:18 <dmwit> ?localtime dmwit -- still April Fool's
14:49:19 <lambdabot> Local time for dmwit is Tue Apr  1 14:49:57
14:49:48 <ehird> that's after 12am if I am not mistaken
14:50:29 <gwern> huh. here's a old benchmark from '92; the ASpecT compiler created a 412k binary which ran in 9.8s on a Sun 4/20(SLC); ghc 6.8.2 with optimizations on creates a 528K binary which runs in 0.17s on my 2.4ghz quadcores :)
14:50:48 <cjb> wow
14:50:56 <cjb> that comic must have taken a very long time to make
14:51:08 <tromp> who asked about grenades?
14:51:17 <ehird> cjb: which is why i said -- not april fools
14:51:20 <cjb> you'd think, for something so verbose, the author might have spent the two minutes required to learn that Haskell does in fact embrace side-effects
14:51:21 <ehird> and it says its a preview for a book
14:51:28 <cjb> ehird: oh, it's certainly april fools
14:51:29 <gwern> the fastest timing for hbc was 78s....
14:51:34 <ehird> but yeah, it's like a "don't do haskell, kids. it's bad for ya"
14:51:38 <gwern> haskell compilers have come a long way
14:51:44 <ehird> cjb: the reddit submission title acknowledge it was on april 1st
14:51:45 <edwinb> heh, I laughed out loud when Haskell came in...
14:51:53 <ehird> i would think that that kinda precludes it being a joke
14:51:59 <cjb> hm.
14:52:01 <ehird> because normally they're not made obvious BEFORE clicking the link
14:52:27 <ehird> 'sterile totaltarian state'
14:52:28 <ehird> i mean seriously
14:52:38 <ehird> of course its exaggerated for comic effect even if not april fools
14:52:41 <ehird> but still darned rude
14:52:54 <lament> april 1 sucks.
14:53:14 * EvilTerran finishes reading it
14:53:19 <EvilTerran> wow, way to miss the point
14:53:21 <dmwit> Aww, come on, do we really have to have a war?
14:53:33 <ehird> this person even wrote http://lisperati.com/haskell/
14:53:33 <tromp> i think it takes 5 questions to find grenade color
14:53:39 <ehird> so i guess he must have 'found lisp' or something
14:53:46 <ehird> or decided haskell was 'too primitive'
14:53:53 <dmwit> tromp: Four suffices.
14:54:12 <EvilTerran> i like how they ask rhetorical questions like "why restrict yourself to a world without side-effects" or whatever, but then don't make any attempt to answer them
14:54:25 * EvilTerran files it under "miscellaneous T - troll"
14:54:39 <tromp> dmwit: ok, then the questions must refer to each other, i guess
14:54:52 <dmwit> tromp: No, that's not necessary either.
14:55:17 <dmwit> tromp: Four questions of the form "Is your grenade X?" where X is a color are enough to pin down the color of the grenade without a doubt.
14:55:31 <gwern> tromp: try thinking, how many questions if you can assume no lies?
14:56:21 <tromp> i thought there are only 3 possible colors?
14:56:26 <dmwit> correct
14:56:49 <gwern> I don't quite get that comic; is he attacking haskell? supporting it? humorously reflecting on how some lispers see haskell?
14:57:15 <EvilTerran> gwern, as i said, i'd consider it an elaborate troll
14:57:33 <tromp> then Four questions of the form "Is your grenade X?" are not enough
14:57:42 <EvilTerran> regardless of the point he's trying to make - it seems designed to annoy haskellers, lispers, and bystanders alike
14:57:45 <dmwit> tromp: err, hmmm
14:57:48 <gwern> EvilTerran: yeah, but the last frame is attacking uncontrolled side effects
14:57:51 <dmwit> tromp: You could be right.
14:58:23 <tromp> you can't embed 3 hmming spheres into {0,1}^4
14:58:35 <tromp> 3 disjoint hamming spheres
14:58:45 <daveux> can someone tell me why this curry fails: countWith = length . filter
14:59:03 <dmwit> tromp: But I think if you ask the sequence, "rgb", then you narrow it down to at most two colors, and if there are two possible colors, the lie is used up.
14:59:09 <gwern> oh dear. is tromp a person who knows the math behind my little puzzle?
14:59:50 <dmwit> oh
14:59:52 <ehird>  gwernhe's a lisper
14:59:54 <dmwit> Yeah, that's not true.
15:00:01 <dmwit> huh
15:00:08 <dolio> Lispers don't need to unit test their code, either.
15:00:11 <ehird> gwern: & serious, though chatty
15:00:13 <gwern> ehird: am not; I use emacs and that's about it
15:00:19 <tromp> i'm not a lisper:(
15:00:20 <ehird> gwern: i meant
15:00:22 <ehird> the guy
15:00:28 <gwern> oh
15:00:34 <ehird> comic guy
15:00:43 <ehird> dolio: Well, tests of any kind are useful...
15:00:45 <ehird> Even in lisp
15:00:47 <daveux> nm, had the arguments backwards
15:01:17 <dolio> No, no, everything just works, because it's lisp.
15:01:26 <ehird> dolio: heh :)
15:02:20 <lament> lisp and haskell are similar: if you manage to get something running at all, problems such as making sure it runs without bugs are trivial
15:02:30 <daveux> Ok, no, didn't work:
15:02:42 <daveux> countWith :: (a -> Bool) -> [a] -> Int
15:02:45 <ehird> lament: lisp is a little more malleable in that respect though
15:02:49 <daveux> countWith = length . filter
15:02:54 <daveux> why doesn't this work?
15:03:12 <shachaf> @ty (length .) . filter
15:03:13 <lambdabot> forall a. (a -> Bool) -> [a] -> Int
15:03:13 <EvilTerran> (.) :: (b -> c) -> (a -> b) -> (a -> c)
15:03:15 <dmwit> tromp: Oh, a connection to error-correction.
15:03:18 <EvilTerran> ?type length
15:03:18 <dmwit> tromp: Very cool!
15:03:18 <lambdabot> forall a. [a] -> Int
15:03:20 <EvilTerran> ?type filter
15:03:20 <shachaf> daveux: (.) is only for one argument.
15:03:21 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
15:03:28 <EvilTerran> the types don't fit
15:03:36 <shachaf> (f . g) x = f (g x)
15:03:44 <shachaf> (length . filter) x = length (filter x)
15:03:46 <daveux> Ok, I see
15:03:49 <daveux> unfortunate
15:04:03 <shachaf> You can define (dot) or (.:) or some other name.
15:04:05 <ehird> that lisperati guys tutorial sucks
15:04:06 <ehird> Well, remember that Haskell supports pattern matching- This means, we can just drop the p (polygon) parameter from both sides and the compiler cna still make sense of it:
15:04:08 <shachaf> @let (.:) = (.) . (.)
15:04:09 <lambdabot> <local>:2:7:     Ambiguous type variable `f' in the constraint:       `Functo...
15:04:14 <ehird> pattern matching's got nothing to do with it
15:04:18 <Maddas> ehird: Did you expect anything else?
15:04:34 <ehird> Maddas: no :|
15:04:35 <shachaf> @ty let (.:) = (.) . (.) in length .: filter
15:04:36 <lambdabot> forall a. (a -> Bool) -> [a] -> Int
15:04:58 <Maddas> ehird: You'll find a lot of bad tutorials for any language out there. It's often not worth the time to try to find all the faults :-)
15:05:38 <masklinn> How would you handle sorting e.g. a list on various criteria? First try criteria 1, if it yields an equality try 2, ...
15:06:09 <monochrom> Use sortBy, and provide your cascade of criteria.
15:06:11 <EvilTerran> sortBy
15:06:25 <EvilTerran> the Monoid instance of Ordering is probably useful
15:06:43 <tromp> i haven't quite figured out the sort of codes you can get with cross referencing questions:(
15:06:55 <EvilTerran> it results in the leftmost value that isn't EQ
15:06:58 <masklinn> I'd found sortBy, but both comparing only seems to work for a single criteria, and I don't really see how to combine/chain Ordering instances
15:07:13 <EvilTerran> > EQ `mappend` LT
15:07:14 <lambdabot>  LT
15:07:17 <EvilTerran> > EQ `mappend` EQ
15:07:18 <lambdabot>  EQ
15:07:18 <dmwit> tromp: I don't think cross-references are helpful here.
15:07:20 <EvilTerran> > LT `mappend` EQ
15:07:21 <lambdabot>  LT
15:07:23 <masklinn> mmm
15:07:25 <EvilTerran> > LT `mappend` GT
15:07:26 <lambdabot>  LT
15:07:28 <EvilTerran> etc
15:07:29 <masklinn> wow
15:07:32 <dmwit> tromp: Unless you cross-reference into the future, which seems a bit odd.
15:07:44 <sfultong> http://www.lisperati.com/landoflisp/
15:07:56 <dmwit> tromp: (Though, you obviously have the more rigorous background of us, so I could easily be wrong.)
15:08:04 <EvilTerran> sfultong, we just had that
15:08:06 <dmwit> sfultong: Yup, we've been discussing that (briefly). =)
15:08:15 <tromp> well, it takes 5 if changing one answer preserves the truth value of the other answers
15:08:40 <sfultong> those lispers with their evil side-effects
15:09:00 <ehird> sfultong: we've been talking about it
15:09:33 <dmwit> sfultong: No need to be adversarial, lisp and Haskell can happily co-exist. =)
15:10:03 <HaskellNewb> How can I clear the command prompt? What's the command in IO ()?
15:10:10 <ehird> dmwit++
15:10:22 <ehird> Haskell: none. why do you want to?
15:10:22 <masklinn> thanks a lot EvilTerran
15:10:28 <sfultong> dmwit: well, ok... we can have a temporary alliance.... until C-derivative languages are dead
15:10:28 <ehird> its kinda annoying when a program claers the screen
15:10:29 <gwern> neat. nofib includes a prolog interpreter
15:10:33 <HaskellNewb> ehird: playing a game, want to hide previous info
15:10:47 <ehird> sfultong: nothing wrong with lisp
15:10:54 <ehird> HaskellNewb: print out a load of newlines
15:11:07 <HaskellNewb> ehird: that's what I do, but it's ugly
15:11:10 <gwern> sfultong: I say we eat the lispers! a single unified FP lang is needed to take on the C clan
15:11:24 <dmwit> HaskellNewb: Check the VT100 docs for the escape sequence to send.
15:11:31 <dmwit> Hold on, I may have it handy.
15:11:34 <EvilTerran> masklinn, np :)
15:11:40 <HaskellNewb> thanks dmwit, that'd be awesome
15:11:52 <EvilTerran> masklinn, if you don't want to use Monoid, it's pretty easy to implement an operator to do the same thing yourself
15:11:53 <gwern> it's strange how many old programs I can only find in nofib
15:11:58 <gwern> it's some sort of graveyard
15:12:04 <ehird> nofib=
15:12:08 <orzo> is it ok to use Data.List.Partition on a list of lines read lazily from a file?
15:12:47 <shachaf> Insn't it \esc[H\esc\J ?
15:13:02 <dmwit> http://www.cs.utk.edu/~shuford/terminal/vt100_reference_card.txt
15:13:25 <dmwit> From there: "Reset ESC c".
15:13:32 <Valodim> haha, wow that comic is tough
15:13:36 <HaskellNewb> thanks dm
15:13:38 <gwern> ''So eventually, I took the Mini-Prolog that comes with Hugs http://haskell.org/hugs, written in Haskell then, and translated it into C++, replacing its slow parser with a Flex/Bison combination. In the translation, I had to work around Haskell's laziness, and I successively flattened out the recursive function calls until arriving at a single loop with jumps, an essentially simplified interpreted version of the WAM. This Mini-Prolog ...
15:13:39 <glguy> playing with hamming codes it seems like you'd need 5 questions to be able to tolerate one lie
15:13:40 <lambdabot> Title: Hugs 98
15:13:48 <gwern> ... has examples of three different CLP engines. Some bug in the Prolog cut, I recall.' <-- ew
15:13:53 <dmwit> glguy: That's what tromp concluded, too.
15:13:56 * shachaf would just use "clear > f", and look at f.
15:14:03 <shachaf> Reset might do more than you want.
15:14:07 <glguy> then what was the 4 question solution?
15:14:22 <dmwit> glguy: It was a lie!  like cake
15:14:52 <HaskellNewb> dmwit: how do I use these commands?
15:14:59 <HaskellNewb> it's not native to the prelude right?
15:15:10 <shachaf> HaskellNewb: Reset will also clear colors and so on.
15:15:17 * shachaf would suggest just clearing the screen.
15:15:30 <HaskellNewb> I don't know how to clear the screen, if you know how that'd be awesome
15:15:42 <dolio> Woo, I can connect to hpaste again.
15:15:53 <dmwit> HaskellNewb: Just use putStr to print those characters.
15:16:28 <HaskellNewb> putStr (ESC c)?
15:16:28 <gwern> ' Veritas is a design logic that provides dependent types and subtypes. It is implemented within the functional programming language Haskell. Interesting aspects of this implementation, in particular those relating to dependent types, to the representation of terms and signatures, to syntactic variants (controlled by attributes) and to a concrete notation for derivations are discussed. ' <-- hm
15:16:36 <shachaf> putStr "\27[H\27[J"
15:16:51 <HaskellNewb> oh, wow
15:16:53 <HaskellNewb> thanks
15:16:59 <shachaf> Or, for reset, putStr "\27c"
15:17:03 <gwern> glguy: is your 5 question answer using only 'is your grenade red/blue/green?'
15:17:11 <Valodim> haha, that last panel in the land of lisp comic makes it all relative again
15:17:13 <Valodim> good read :)
15:17:30 <HaskellNewb> you are magic sachaf
15:17:31 * monochrom wants to suggest nanocurses and hscurses
15:17:41 <HaskellNewb> so these commands in VT, if I print the ascii value I get the effect?
15:17:46 <glguy> gwern: the simplest 5 questions are: is it red? is it red? is is blue? is it blue? is it green?
15:17:54 <glguy> err
15:17:55 <gwern> Valodim: that's what I thought, the last panel makes the author's viewpoint ambiguous
15:17:56 <glguy> I guess
15:17:56 <dmwit> Yeah, a curses implementation would probably be nicer.
15:18:01 <glguy> just the first 4 :)
15:18:09 <dmwit> glguy: Depends on what "simple" means.
15:18:18 <dmwit> glguy: This also does it, I think: rrrgg
15:18:22 <glguy> gwern: the simplest 4 questions are: is it red? is it red? is is blue? is it blue?
15:18:27 <gwern> glguy: and if you ask questions like 'is it red or blue?'
15:18:34 <Valodim> well I do believe the author has a little more perspective than to declare us a totalitarian system ;)
15:18:47 <dmwit> gwern: We already covered that: it's equivalent to "Is it not green?".
15:18:58 <dmwit> (Or, not "Is it green?")
15:19:36 <gwern> dmwit: ah, right.
15:20:14 <monochrom> "If someone asked you 'is it green' would you reply yes?"
15:20:32 <Valodim> @faq If someone asked you 'is it green' would you reply yes?
15:20:33 <lambdabot> The answer is: Yes! Haskell can do that.
15:20:53 <dmwit> monochrom: Isn't that the same?
15:20:55 <dolio> http://www.giantitp.com/comics/oots0327.html
15:20:57 <lambdabot> Title: Giant In the Playground Games
15:21:02 <monochrom> No.
15:21:24 <glguy> monochrom's question eliminates the effectiveness of lying
15:21:30 <dmwit> Why?
15:21:38 <dmwit> I don't see it.
15:21:39 <glguy> err
15:21:40 <tromp> is it red? is it red? is it blue? is it blue? can be answered with yes,no,no,no
15:21:41 <glguy> no
15:22:00 <dmwit> tromp: Correct, then the fifth question decides between red and green.
15:22:16 <glguy> dmwit: no, we know it is red then
15:22:17 <monochrom> See also those puzzles like "there is an angel and a demon, you don't know which is which...".  That is the approach of the solution.
15:22:26 <dmwit> glguy: No you don't.
15:22:27 <glguy> monochrom: that approach doesn't work here
15:22:27 <tromp> no, glguy, it can be green
15:22:41 <glguy> no, it is red, he can only lie once
15:22:50 <glguy> bha!!
15:22:53 <dmwit> glguy: Right, if it's green, he lied the first time.
15:22:55 <glguy> :)
15:23:25 <glguy> so back to my original 5 simple questions
15:25:07 <dolio> The answer is green. There are no red or blue grenades. :)
15:25:59 <dmwit> Why hello thar, Gordia!
15:26:37 <dolio> Thank you, thank you.
15:27:36 <ehird> i want hasklisp
15:27:38 <ehird> its lisp
15:27:40 <ehird> with haskell syntax
15:27:45 <ari> Liskell?
15:27:46 <ehird> as an opponent to liskell
15:27:51 <ehird> ari: other way around
15:27:56 <ehird> liskell=haskell lisp syntax
15:28:00 <ari> Ahhhh
15:28:00 <ehird> mine=lisp, haskell syntax
15:28:01 * ari sees
15:28:03 <idnar> Hasp
15:28:04 <ehird> :p
15:28:05 <dolio> You could use ML. Close enough.
15:28:24 <ehird> idnar: where is that name generator in lambdabot
15:28:45 <idnar> don't ask me, ask dons
15:28:50 <__pao__> which is the equivalent of "group" in prelude?
15:29:17 <tromp> 4 cross referencing questions sufficew
15:29:18 <dobblego> group?
15:29:52 <__pao__> dobblego: not in scope
15:29:59 <dolio> It's in Data.List
15:30:09 <__pao__> dolio: thanks
15:31:33 <__pao__> if I'm not wrong there's a way to query lambdabot for the implementation of a library function... isn't there?
15:31:42 <monochrom> @src group
15:31:42 <lambdabot> group = groupBy (==)
15:31:52 <monochrom> Some are missing.
15:31:56 <BMeph> I.e., yes. :)
15:32:03 <__pao__> :-)
15:32:21 <__pao__> monochrom: is a lambdabot feature, right? I cannot get the same result in ghci...
15:32:27 <monochrom> Right.
15:32:28 <dmwit> correct
15:32:55 <fophillips> Does something like Data.Graph exist for GHC?
15:33:17 <monochrom> Yes.
15:33:33 <__pao__> monochrom: thanks :-)
15:33:33 <fophillips> What is it called?
15:33:45 <monochrom> It is really called Data.Graph
15:34:39 <fophillips> Oh, heh
15:34:55 <shachaf> @@ __pao__: (@where goa)
15:34:55 <lambdabot>  __pao__: http://www.cse.unsw.edu.au/~dons/code/goa/
15:35:42 <Saizan> shachaf: that's very leet :)
15:36:00 <lament> I want to draw simple images (chord shapes) and save them as .jpg or .png or something. What's a good library for that?
15:36:14 <__pao__> shachaf: that's my very own installable lambdabot? :-)
15:36:28 <shachaf> __pao__: And integrated with ghci.
15:36:51 <__pao__> shachaf: wow... thank you very much
15:37:15 * shachaf should get a \b plugin for irssi...
15:42:05 <shepheb> Feuerbach: isn't that precisely the job of logHook, to send info on things like workspace change
15:42:11 <shepheb> mischan
15:45:38 <EvilTerran> lament, GD?
15:46:10 <EvilTerran> @hackage gd
15:46:10 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/gd
15:46:17 <lament> EvilTerran: thanks!
15:46:31 <EvilTerran> hm... "This is a binding to a (currently very small) subset of the GD graphics library." =/
15:46:34 <sfultong> heh...
15:46:36 <sfultong> http://xmonad.org/news.html#6
15:46:37 <lambdabot> Title: xmonad : news
15:47:27 <EvilTerran> lament, in general, look through http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Graphics
15:47:27 <shepheb> @seen byorgey
15:47:28 <lambdabot> byorgey is in #xmonad, #haskell and #haskell-blah. I last heard byorgey speak 1h 22m 52s ago.
15:47:29 <lambdabot> http://tinyurl.com/yqov7f
15:47:48 <lament> EvilTerran: i did, i somehow skipped that one
15:47:57 <EvilTerran> lament, failing that, i'd suggest outputting postscript
15:47:59 <EvilTerran> ;)
15:48:06 <jao> hmmm, xmonad-contrib install using cabal fails to compile for me
15:48:06 <lament> i don't know postscript
15:48:12 <EvilTerran> it's not that hard
15:48:33 <gnuvince_> Have you guys seen the evil Republic of Haskell? :)
15:48:40 <EvilTerran> gnuvince_, yes, twice
15:48:41 <lament> also i would still have to convert it to an image.. extra pain
15:49:08 <gnuvince_> I really didn't see the punch coming :)
15:49:17 <EvilTerran> i'm tempted to make an embedding for a typecheckable subset of postscript as an EDSL in haskell, actually
15:51:17 <shepheb> gnuvince_: yeah, it's been discussed over the last hour-ish
15:51:58 <lament> EvilTerran: have you seen functional metapost
15:52:21 <EvilTerran> no
15:52:24 <EvilTerran> ?
15:53:24 <EvilTerran> ?go functional metapost
15:53:26 <lambdabot> http://cryp.to/funcmp/
15:53:26 <lambdabot> Title: Functional MetaPost
15:53:48 <EvilTerran> hm. looks like i've been beaten to the punch somewhat. :P
15:54:32 <shepheb> anyone have advice for or against different blog engines and hosts wrt posting Haskell?
15:54:41 <hpaste>  jao pasted "errors on cabal install xmonad-contrib" at http://hpaste.org/6779
15:56:30 <nominolo_> jao: can you post the output of ghc-pkg list?
15:56:48 <EvilTerran> jao, looks like a version mismatch somewhere
15:57:29 <nominolo_> jao: most likely xmonad is built against a different version of x11 than xmonad-contrib
15:57:31 <gwern> shepheb: it can be done in 4 questions, it seems
15:57:32 <gwern> er. I meant shacaf
15:57:44 <__pao__> evil republic of haskell?
15:57:45 * gwern really is impressed how much faster freenet is these days
15:57:59 <EvilTerran> gwern, you mean shachaf?
15:58:05 <ehird> gwern: freenet is basically child porn + UFO conspiracies
15:58:13 <ehird> at least in my experience
15:58:14 <ehird> > do [1,2,3];[4,5,6]
15:58:14 <lambdabot>  [4,5,6,4,5,6,4,5,6]
15:58:17 <shachaf> EvilTerran: Regarding a /msg and a conversation in #xmonad. :-)
15:58:28 <nominolo_> __pao__: yeah, considering that drcode was at the last hackathon this is quite disappointing comic
15:58:37 <nominolo_> __pao__: or just a really bad analog
15:58:41 <nominolo_> y
15:59:08 <gwern> ehird: it's not *that* bad
15:59:17 <__pao__> nominolo_: I miss completly all the background info :-)
15:59:30 <ehird> do x <- [1,2,3]; return (x+3)
15:59:31 <ehird> > do x <- [1,2,3]; return (x+3)
15:59:32 <lambdabot>  [4,5,6]
15:59:37 <ehird> wahey, i get the list monad
15:59:38 <ddarius> gwern: ehird only goes to the child porn parts perhaps
15:59:39 <ehird> :D
15:59:44 <ehird> ddarius: ouch
15:59:55 <ehird> that *was* worded badly, wasn't it
16:00:04 <EvilTerran> somewhat :P
16:00:10 <gwern> ddarius: touche
16:00:13 <nominolo_> __pao__: apparently he is not totally serious either, http://reddit.com/r/programming/info/6e86f/comments/c03lqe3
16:00:17 <lament> this gd package relies on the user having the gd library and doesn't even say how to link with it :(
16:00:32 <gwern> ehird: the 'in my experience' really opened you up there
16:00:40 <ehird> gwern: yeah
16:00:45 <lament> haskell programmers don't need docs, ever! that's how good haskell is.
16:01:02 <ddarius> lament: We have documentation.  It's stored in the .hs files.
16:01:23 <lament> ddarius: this package links with a library in C.
16:01:49 <ehird> nominolo_: also pretentious: http://reddit.com/r/programming/info/6e86f/comments/c03lq2k
16:02:26 <ehird> > do []
16:02:26 <lambdabot>  []
16:02:28 <nominolo_> ehird: well, i could identify this as a joke ;)
16:02:31 <ehird> > do [1];[]
16:02:31 <lambdabot>  []
16:02:47 <ehird> > do x<-[1,2,3];if x==2 then[] else x
16:02:47 <lambdabot>   add an instance declaration for (Num [a])
16:02:51 <ehird> > do x<-[1,2,3];if x==2 then[] else return x
16:02:52 <lambdabot>  [1,3]
16:02:55 <ehird> hmm
16:03:03 <ehird> that's nice
16:03:05 <ehird> nominolo_: :(
16:03:12 <kpreid> > do "12"; "34"
16:03:13 <lambdabot>  "3434"
16:03:18 <shepheb> no Planet Haskell bloggers with thoughts on which engine?
16:03:21 <ehird> ah, it will work on strings, of course
16:03:22 <ehird> that's nice
16:03:23 <dmwit> > do x <- [1, 2, 3]; guard (x /= 2); return x
16:03:24 <lambdabot>  [1,3]
16:03:34 <ehird> but the list monad won't work with multiple types
16:03:39 <ehird> that's the different between Amb and []
16:03:48 * nominolo_ always swears at how bad blogger is
16:03:50 <ehird> and ListT m is not a monad in all cases
16:03:52 <ehird> AmbT m is
16:03:57 <ehird> ergo, Amb/AmbT rox
16:04:00 <kpreid> @let prog1 a b = do x <- a; b; return x
16:04:00 <lambdabot> Defined.
16:04:04 <gwern> http://blameitonthevoices.blogspot.com/2008/03/board-discussion.html <-- a discussion worthy of reddit
16:04:05 <lambdabot> http://tinyurl.com/344587
16:04:11 <nominolo_> but it's easier than running my own
16:04:17 <kpreid> hm, that won't help...
16:04:20 <ehird> kpreid: lisp reject? ;)
16:04:27 <kpreid> @undefine
16:04:28 <lambdabot> Undefined.
16:04:39 <dmwit> ?let ensure p x = guard (p x) >> return x
16:04:39 <lambdabot> Defined.
16:04:39 <shachaf> @ty (<*)
16:04:40 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
16:04:42 <ehird> gwern: Kind of odd seeing as that is a *chan
16:04:47 <ehird> gwern: You'd expect something less funny.
16:04:55 <dmwit> > [1, 2, 3] >>= ensure (/= 2)
16:04:56 <lambdabot>  [1,3]
16:04:57 <ehird> Or at least, if not less funny, less intellectual
16:05:09 <dmwit> :t L.ensure
16:05:10 <lambdabot> forall b (m :: * -> *). (MonadPlus m) => (b -> Bool) -> b -> m b
16:05:27 <dmwit> I use that one all the time.
16:05:48 <nominolo_> gwern: definitely nimbostratus
16:07:08 <gwern> ehird: stopped clock
16:08:37 <ehird> gwern: was that meant to make any sense
16:08:44 <ehird> oh
16:08:47 <ehird> of course
16:08:57 <ehird> silly me, not knowing 1337 ABBREVIATIONS for common phrases
16:09:20 * EvilTerran has no ide what either of you are talking about
16:09:48 <ehird> EvilTerran: we're no strangers to loooove
16:09:53 <EvilTerran> apart from 4chan
16:10:03 <EvilTerran> oh god not this again
16:11:14 <ehird> /insert rest of song here
16:11:23 * EvilTerran notes that all the "Featured Videos" on youtube are still rickrolls
16:11:27 <shepheb> byorgey: you use Wordpress, how is it for Haskell?
16:12:15 <ehird> shepheb: wordpress is horridly designed and badly implementing it
16:12:17 <ehird> some people like it
16:12:17 <ehird> :)
16:12:28 <ehird> (it mostly works)
16:12:28 <gwern> my program has no nose!
16:12:40 <EvilTerran> oh nose!
16:13:20 <ehird> gwern: did you design it with NoseT?
16:13:43 <gwern> no...
16:14:04 <ehird> then you have no chance
16:14:05 <ehird> sorry
16:14:15 <shepheb> .oO( could a poor implementation of a bad design possibly yield good? low percentage, but conceivable. )
16:15:00 <ari> Not if you use a sane definition of "poor implementation", namely one that doesn't allow for accidental success
16:15:22 <ehird> shepheb: no
16:15:31 <pjd> shepheb: worse is better
16:15:32 <ehird> if that was true
16:15:36 <ehird> PHP would have a chance to be good
16:15:48 <ehird> pjd: worse is better is very well desfined, and shepheb's idea is not WIB
16:15:57 <pjd> (corollary: sometimes worse is just worse)
16:16:17 <shepheb> ehird: but PHP is already implemented, so of course it has no chance anymore
16:16:37 <ehird> pjd: worse -- i do not think it means what you think it means in the context of worse is better
16:19:11 <gwern> I'm not sure it gives you that option?
16:21:26 <bos> wow, boost makes haskell competitive with C++ for compilation speed.
16:26:29 <byorgey> mauke: ah, right =)
16:26:36 <byorgey> oops, wrong chan =P
16:28:01 <byorgey> shepheb: I love Wordpress in general, but I can't say it supports Haskell in particular very well
16:28:18 <ehird> byorgey: Have you ever read its source?
16:28:20 <ehird> Unbearable..
16:28:39 <byorgey> ehird: I have, unfortunately, and I completely agree.
16:32:17 <ehird> byorgey: One thing Matt Mullenweg is most definately NOT is a programmer
16:33:26 <byorgey> heh
16:35:21 <monochrom> That gets into the question: what is a programmer?
16:35:46 <EvilTerran> ?quote programmer
16:35:46 <lambdabot> dons says: my feeling is that the Java programmers will welcome us as liberators
16:35:47 <byorgey> someone who knows Haskell, of course
16:36:04 <monochrom> Great answer :)
16:36:24 <__pao__> good night everyone (where it applies) :-)
16:36:33 <dobblego> monochrom, I have discussions around that question regularly
16:36:34 * __pao__ thanks everyone for the help
16:36:45 <dobblego> ehird, *definitely
16:37:08 <ehird> dobblego: Always get that one wrong.
16:37:09 <ehird> Thanks.
16:37:21 <dobblego> ehird, np ;)
16:37:29 <ehird> A programmer is hard to define, yes. But so are most things we talk about..
16:37:39 <ehird> But we have an initial definition: 'not Matt Mullenweg'
16:37:40 <ehird> :)
16:37:59 <dobblego> why and who is that?
16:38:57 <Syzygy-> @seen dpiponi
16:38:58 <lambdabot> I haven't seen dpiponi.
16:39:03 <Syzygy-> Meh
16:40:16 <ehird> dobblego: he is the main architecht of Wordpress
16:40:26 <ehird> @seen lambdabot
16:40:26 <lambdabot> Yes, I'm here. I'm in #gentoo-uy, #friendly-coders, #dreamlinux-es, #thunks, #haskell-hac07, #haskell_ru, #haskell.dut, #haskell.de, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #
16:40:26 <lambdabot> haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell-books, #rosettacode, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #jtiger, #haskell-soc, #haskell-
16:40:26 <lambdabot> overflow, #haskell-blah, #scala, #darcs, #jhc, #ghc and #haskell
16:40:29 <dobblego> ah right; *architect ;)
16:40:45 <ehird> dobblego: shush, I have been able to type less and less accurately lately
16:45:01 <xif> hi. what does the "where" keyword mean?
16:45:18 <Excedrin> it's like let
16:45:19 <xif> (and where can I find such information, in general?)
16:45:20 <EvilTerran> ehird, btw, i find a nice trick for remembering "definitely" is to just tack "ly" onto the end of "definite" :)
16:45:42 <mauke> xif: it introduces an associated block of declarations
16:45:43 <xif> Excedrin: I'm reading a book which provides code where there's just "let"
16:46:02 <mauke> @where report
16:46:02 <lambdabot> http://www.haskell.org/onlinereport/
16:46:03 <xif> err, there's just "where
16:46:09 <Excedrin> http://www.haskell.org/onlinereport/decls.html
16:46:09 <mauke> ^ language definition
16:46:09 <lambdabot> Title: The Haskell 98 Report: Declarations
16:46:27 <xif> mauke: OK, any other place I should look up stuff like that?
16:47:06 <ehird> xif: a tutorial
16:47:06 <xif> preferably something with an index :)
16:47:08 <ehird> gentle intro or YAht
16:47:19 <ehird> gentle intro is neither an introduction nor gentle but it is a good reference
16:56:00 <Trinithis> is it possible to do prolog-like difference lists in haskell?
16:56:16 <EvilTerran> ... can you elaborate?
16:56:19 <bd_> !faq
16:56:22 <bd_> ?faq
16:56:22 <lambdabot> The answer is: Yes! Haskell can do that.
16:57:07 <bd_> so what's a difference list?
16:57:16 <Trinithis> like where you have an 'infinite' list where you know the beginning but define the end later
16:57:29 <bd_> er?
16:57:40 <Trinithis> [1,2,3,xs]-xs === [1,2,3]
16:57:48 <Trinithis> so to speak
16:57:57 <Trinithis> but you don't know what xs is
16:58:43 <EvilTerran> ... you mean representing the list xs as the function (xs++)?
16:58:50 <bd_> let l = [1,2,3] ++ xs
16:58:54 <Philippa> Trinithis: you can't define the list later, but you don't have to construct it all
16:58:54 <Trinithis> xs = [1,2,3,hole]-hole; hole = [4,5,hole2]
16:58:55 <bd_>     otherstuff = f l
16:59:00 <bd_>     xs = makeXs otherstuff
16:59:03 <bd_> in  l
16:59:05 <bd_> for example?
16:59:29 <EvilTerran> Trinithis, ... some libraries do what i suggested there to save on concatenations
16:59:33 <bd_> of course, f must not force the list in a way that will create a time paradox
16:59:40 <Philippa> Trinithis: let hole = drop 3 nats; nats = [1..] in hole
16:59:45 <bd_> EvilTerran: If you're worried about the cost of concatinations, use Data.Seq
16:59:48 <Philippa> except it's not really a hole
16:59:55 <EvilTerran> Trinithis, and then you (.) the pseudo-lists together
16:59:56 <Philippa> > let hole = drop 3 nats; nats = [1..] in hole
16:59:56 <bd_> concatinations in Data.Seq are O(lg n + lg m)
16:59:56 <lambdabot>  [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,...
16:59:59 <bd_> er
17:00:08 <bd_> O(lg(n+m)) rather
17:00:16 <Trinithis> EvilTerran: ok. kinda like ShowS?
17:00:17 <EvilTerran> bd_, and concatenations in what i suggested are O(1). different tools for different jobs. :)
17:00:25 <Philippa> that's just basic lazy evaluation, of course - but you don't need to use difference lists to achieve it. You'll have to do pattern-matching a bit more manually, you don't have unification
17:00:27 <EvilTerran> Trinithis, exactly like ShowS.
17:00:49 <bd_> EvilTerran: yours isn't a concatenation :)
17:00:59 <Trinithis> :) there are 2 versions of difference lists, the (.) version and the version i alluded to
17:01:07 <bd_> EvilTerran: also, yours is eventually O(n) technically
17:01:16 <bd_> (assuming it's not fused away)
17:01:28 <EvilTerran> bd_, Data.Seq's are great for general use, but they're rather heavyweight if you're just building up a list without looking at it and then flattening it out
17:01:56 <EvilTerran> which is why it's how ShowS, for instance, works.
17:02:03 <Trinithis> if anyone curious about the type of list i was talking about, here's an effective tutorial in prolog: http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node57.html#subsec.l7.diff.structures
17:02:04 <bd_> ic
17:02:04 <lambdabot> Title: 7.1.2 CFG recognition using difference lists, http://tinyurl.com/2q9aqm
17:03:16 <obk> speaking of difference lists, they provide a very effective way to control parallel execution, when combined with a "futures/promises" data type, which Haskell _almost_ has
17:03:23 <Philippa> Trinithis: you could definitely write the parser, you just don't want to do it via unification in practice
17:03:42 <obk> Unification isn't required for difference lists
17:04:35 <Trinithis> what is unification
17:04:48 <Philippa> Trinithis: you're talking about prolog and you don't know what unification is?!
17:05:10 <Philippa> obk: I know it's not. It does, however, make a big difference to how you can readily use them
17:05:19 <dolio> f (x:y:zs) ws | zs == ws = ...
17:05:34 <Trinithis> im new at it. i understood the link i gave. (i probably understand the concept already tho)
17:05:39 <dolio> That's the rough equivalent of the prolog.
17:05:50 <dolio> Of course, it won't work on infinite lists.
17:05:53 <obk> Philippa: Not really. Unification means two things; one is deferred assignment to variables, the second is a whole mess of matching graphs. The 1st is relevant, the 2nd isn't.
17:06:14 <obk> If you look at flat Prolog, they don't have "unification" in the sense of the 2nd part, only the 1st part
17:06:42 <dolio> But I suppose prolog won't unify infinite lists, either (aside from, perhaps, special cases).
17:06:46 <obk> That is, the ability to do: "call f(x) /* x is not known */, ... , call g(x) /* g will assign to x */
17:06:46 <Pseudonym> Even flat versions of Prolog have a general equality test.
17:06:48 <Trinithis> alright. that's what i figured. so haskell does not support it?
17:07:07 <Twey> > [1, 2] ++ [1..]
17:07:08 <lambdabot>  [1,2,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
17:07:14 <Philippa> Trinithis: in Haskell, if you want unification you have to implement it yourself. Haskell is not a logic language
17:07:14 <Twey> > [1..] ++ [1..]
17:07:15 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:07:19 <Trinithis> ok
17:07:30 <Twey> Trinithis: Curry is, though.
17:07:32 <obk> Pseudonym: Equality is not NP complete, Unification (if you take it far enough) could be :-)
17:07:51 <Pseudonym> obk: Obviously, Prolog unification isn't.
17:08:04 <Trinithis> Twey: is Curry nifty?
17:08:05 <Philippa> obk: if you're going to go that far you need to talk about what you're unifying anyway
17:08:06 <obk> true, but it is very messy
17:08:12 <Philippa> hell, higher-order unification's undecidable
17:08:16 <obk> Single assignment is so much simpler
17:08:16 <Twey> Trinithis: Curry seems very nifty.
17:08:28 <Pseudonym> Trinithis: Having said that, if you want strongly-moded logic programming, you can get _this_ close in Haskell.
17:08:30 <Twey> Trinithis: Not well supported/used, though.
17:08:40 <Trinithis> ah
17:08:57 <obk> The thing most people miss is the 1st part - the ability to use a variable _before_ assigning to it
17:08:57 <Pseudonym> Most things that you want strongly-moded logic variables for can be done with lazy evaluation.
17:09:04 <obk> Something I would dearly love to see in Haskell
17:09:08 * Pseudonym points people to the credit card transform
17:09:19 <Philippa> obk: "variable"? What variable?
17:09:19 <Twey> It combines constraint and functional programming
17:09:32 <obk> that is, I can't do in haskell "g(x), x = f(y)" in that order
17:09:32 <Philippa> you don't assign to variables in Haskell, you only bind to them
17:09:44 <Pseudonym> obk: What is this "order" of which you speak?
17:09:50 <obk> Specifically, doing "y = f(x), x = g(y)"
17:09:58 <obk> textual order!
17:09:59 <Philippa> obk: yes you can
17:10:05 <obk> Doesn't compile
17:10:08 <Pseudonym> let { z = g x; x = f y } in z
17:10:09 <Trinithis> Pseudonym: I just thought it would be cool to implement a queue with a dlist. but i would have to think of another approach
17:10:10 <Pseudonym> Works fone
17:10:19 <shachaf> > let x = 0 : y; y = 1 : x in x
17:10:20 <EvilTerran> obk, try not using commas
17:10:23 <Philippa> let f = id; g = id; y = f x; x = g y in 1
17:10:25 <lambdabot>  [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1...
17:10:30 <obk> Hmmm
17:10:43 <EvilTerran> > let (x,y) = (1:y, 0:x) in x -- or, if you must use commas...
17:10:44 <lambdabot>  [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0...
17:10:45 <Philippa> (obviously I cba to make it do something...)
17:10:47 <Pseudonym> Trinithis: You do know that difference lists aren't fucntional, right?
17:10:51 <Pseudonym> You can only "use" them once.
17:11:19 <Trinithis> Pseudonym: I know. just wasnt sure how far lazyness could go
17:11:20 <Philippa> obk: welcome to a lazy language with general recursion
17:11:35 <Pseudonym> Trinithis: As it happens, Haskell has all the functionality of difference lists.
17:11:52 <Pseudonym> They don't look like Prolog difference lists, because they're strongly moded, and don't use logic variables.
17:11:56 <monochrom> And welcome to a modern language in general, i.e., no worries about "forward declaration".
17:12:26 * Philippa demonstrated briefly at the start of the conversation the fact you can take the 'rest' of a list without having evaluated it
17:12:30 <Trinithis> Pseudonym: are you talking about the composition of list concats variant?
17:12:52 <Philippa> you can't actually update it, there is no mutable update, but if you can express it simply as "and build this later" it'll work
17:13:09 <Pseudonym> Trinithis: That's one approach, yes.
17:13:29 <Pseudonym> There's also the double-list queue.  I think they're called O'Keefe queues.
17:13:43 * Pseudonym points out that Richard O'Keefe is a regular contributor to haskell-cafe
17:13:49 <Philippa> OTOH, writing parsers in Haskell is easy enough anyway
17:14:15 <dbpatterson> is anyone here familiar with hstringtemplate?
17:14:37 <Pseudonym> It amazes me sometimes about the sorts of people who hang out in the cafe.
17:15:22 <Trinithis> ... in a bad way of course :D
17:15:29 <Pseudonym> No, in a good way.
17:15:41 <Pseudonym> What other mailing list would contain SPK, rok and Doug McIlroy?
17:15:45 <Pseudonym> SPJ
17:15:47 <Pseudonym> Not SPK
17:17:09 <Trinithis> gtg
17:17:34 <Philippa> *blink* - honestly, how do you learn prolog without knowing about unification?
17:18:01 <Pseudonym> Philippa: It can be done, actually.  But you don't get to write _much_.
17:18:02 <Twey> CS courses.
17:18:19 * Twey 'learnt' Prolog without knowing about unification.
17:18:24 <Pseudonym> The sorts of Prolog that they write in AI 101 is less sophisticated than "SQL in 21 days".
17:18:37 <edwinb> I'd have thought you could get away with some simple stuff...
17:18:46 <Twey> Pseudonym: Yep
17:18:53 <Pseudonym> In fact, Prolog in AI 101 pretty much _does_ use it as a better SQL syntax.
17:18:59 <Twey> (not that I took AI 101)
17:19:56 <Pseudonym> But to be fair, it can't truly be said that you "learn Prolog" under such circumstances.
17:19:56 <Saizan_> my question is: how do you keep motivated enough to really learn prolog after learning about unification?
17:19:58 <Philippa> 'lo edwinb
17:20:08 * Philippa did a module about prolog itself as opposed to AI, which may explain it
17:20:22 <Pseudonym> Yeah.
17:20:31 <Philippa> we didn't get run through the WAM or anything, that would've been too brainbreaking for a class where there were still people who didn't get recursion, but hey
17:20:35 <Pseudonym> Oh, Lee Naish and Leon Sterling were two of my undergrad lecturers.
17:20:43 <Pseudonym> We learned Real Logic Programming.
17:20:47 <edwinb> hmm, my course didn't cover prolog at all
17:20:58 <Philippa> it was optional at UoN, presumably still is
17:21:03 <edwinb> not sure how many do these days either
17:21:04 <Philippa> not required for any of the AI modules either
17:21:33 <edwinb> we don't even have an FP coures of any form here, which is very sad
17:22:06 <Philippa> ow. gmh's haskell course was one of the few bits in the first year where I learned anything that wasn't just syntax over stuff I already knew
17:22:08 <Pseudonym> Personal opinion: If you're doing an actual Computer Science degree, as opposed to Script Kiddieing for Dummies, you need to learn a logic language to a minimal level of understanding, and hence understand unification.
17:22:09 <ehird> prolog is kinda boring
17:22:12 <ehird> too verbose
17:22:14 <ehird> but interesting
17:22:23 <Pseudonym> ehird: The same can be said of ML.
17:22:33 <ehird> Pseudonym: nah, ml ain't that verbose
17:22:34 <ehird> & is quite fun
17:22:36 <Pseudonym> Prolog and ML are of a similar age, and it kinda shows.
17:22:44 <ehird> i like ml's kooky symbols
17:23:22 <dolio> Kooky symbols?
17:23:26 <Philippa> there's a thought: it's occurred to me that I'm probably inclined to design syntax on the assumption that anyone who cares about "hard to make" distinctions can use syntax highlighting where it's reasonably easy to do so
17:23:35 <Philippa> you definitely couldn't do that back then
17:24:03 <allbery_b> discrimination against screen readers
17:24:48 <ehird> allbery_b: a x equals f x plus five where f x equals f open parenthesis x plus one close parenthesis
17:24:53 <Philippa> allbery_b: there're far more ways to convey that kind of info in audio than visually, actually
17:25:08 <Philippa> at least, given that we don't typeset code as its typed
17:25:12 <Pseudonym> I hate to sound prejudiced, but vision-impaired programmers really have an uphill battle, like a wheelchair-bound welder.
17:25:27 <Philippa> Pseudonym: I'm pretty sure I know of at least one
17:25:34 <Pseudonym> I know a programmer who is bedridden and unable to type, and it's hell for her.
17:26:05 <Pseudonym> But then, Stephen Hawking still manages to manipulate the Einstein field equation in his head...
17:26:21 <Philippa> I don't think the input device is the problem for a vision-impaired programmer in most cases
17:26:34 * Pseudonym nods
17:26:58 <Pseudonym> Hawking at least has the advantage that he's doing geometry for a living, which means he can think in pictures.
17:27:09 <Philippa> I know I think in graphs sometimes
17:27:19 <Pseudonym> Yeah, and category diagrams.
17:27:25 <ehird> colorforth!
17:27:28 <ehird> :
17:27:29 <ehird> p
17:27:54 <Philippa> part of the point being that I don't think I actually process code the same way as text most of the time
17:28:05 * allbery_b wonders if anyone's done a language where the syntactic elements are colors
17:28:15 <Pseudonym> Me neither.  I program _into_ a syntax, not _in_ a syntax.
17:28:17 <Philippa> allbery_b: yep, at least one
17:28:36 <dons> greg meredith's nice haskell article, http://reddit.com/info/6e8sf/comments/
17:28:37 <Pseudonym> Has anyone done a tone-based programming language?
17:28:43 <edwinb> I suppose there is http://www.dangermouse.net/esoteric/piet.html
17:28:43 <lambdabot> Title: DM's Esoteric Programming Languages - Piet
17:29:00 <Twey> allbery_b: http://www.dangermouse.net/esoteric/piet.html
17:29:00 <lambdabot> Title: DM's Esoteric Programming Languages - Piet
17:29:04 <Twey> Damn
17:29:07 <Twey> Beaten to it
17:29:08 <allbery_b> that was the next thought, yes.  (I know there's an auditory system monitoring framework)
17:29:08 <edwinb> heh
17:29:08 <Twey> :-D
17:29:10 <Philippa> edwinb: and you can probably transliterate brainfuck into something using ANSI colour codes
17:29:16 <edwinb> no doubt
17:29:30 <Philippa> though obviously I don't need to tell you about brainfuck transliterations
17:30:41 <allbery_b> hrm.  I was thinking something more interesting, actually.  primary colors and chording
17:30:53 * Twey has a strange fondness for the colour #8ae234.
17:31:04 <allbery_b> probably too few syntactic elements available if you stay in the agerage-human-visible octave
17:31:48 <Pseudonym> Well, like some Asian languages, it'd be a combination of tone and phoneme.
17:32:43 <ehird> Twey: example plz
17:33:09 <ehird> oooh
17:33:10 <ehird> that's nice
17:33:18 <Twey> ehird: javascript:void document.style.backgroundColor = '#8ae234';
17:33:21 <Twey> Oh, you got it.  :-P
17:33:26 <Twey> It is indeed
17:33:33 <diboss> quick question, how many haskell programmers are there? any available estimates out there?
17:33:43 <Twey> I just noticed it yesterday in one of the gnome-terminal colour schemes
17:33:57 <Twey> It's just yellow enough to enhance the green
17:34:23 <ehird> diboss: 'Stand up, Haskell programmers. That means both of you.'
17:34:35 <ehird> @seen
17:34:39 <diboss> lol
17:34:40 <ehird> hmm
17:34:41 <Excedrin> diboss: at least tens, possibly three times that number
17:34:41 <ehird> @stats
17:34:41 <lambdabot> Unknown command, try @list
17:34:44 <ehird> urgh
17:34:45 <ehird> :)
17:34:47 <ehird> Oh well
17:34:49 <ehird> At least 434
17:34:52 <ehird> :p
17:35:01 <diboss> ehird, that what I was just going to say
17:35:05 <Pseudonym> How many people work at Galois?
17:35:08 <Pseudonym> About half of them!
17:35:15 <ehird> Twey: fyi:
17:35:16 <ehird> javascript:void(document.body.style.backgroundColor = '#8ae234');
17:35:23 <diboss> I use D primarily right now, but I think Haskell would be fun to learn (used to Lisp)
17:35:29 <ehird> Pseudonym: So... one?
17:35:42 <Pseudonym> diboss: Definitely on the right track with that "fun" thing that you're after.
17:36:03 <diboss> It came well-recommended by one of my professors
17:36:14 <Twey> ehird: No, void is an operator, the brackets are unnecessary
17:36:23 <Pseudonym> Who's the professor, if I may ask?
17:36:35 <ehird> Twey: Try it yourself.
17:36:37 <Twey> .body or .documentElement will both do, I was thinking of the latter
17:36:43 <ehird> I can guarantee you: mine works, yours doesn't
17:36:48 <diboss> Pseudonym: A Dr. Frost from University of Windsor
17:36:49 <ehird> even with my revision
17:36:52 <ehird> without the ()s
17:36:56 <Twey> ?
17:37:04 <ehird> Twey: void needs the parens.
17:37:07 <ehird> because you have =
17:37:10 <ehird> it parses as (void foo)=2
17:37:17 <Twey> Oh
17:37:24 <Twey> Yeah.
17:37:30 * Twey blames the 'flu.
17:37:31 <Twey> >.>
17:37:33 * Pseudonym looks him/her up
17:37:57 <Twey> That's pretty daft really.
17:38:05 <Twey> void should have a really low operator precedence.
17:38:09 <ehird> Twey: Even more odd is the need for 'void'..
17:38:22 <Twey> It's not like you'd ever *want* it on the LHS of an assignment.
17:38:31 <diboss> He does languages, just solved some 40 year old unsolved parser thing
17:38:53 <Pseudonym> "Parser Combinators for Ambiguous Left-Recursive Grammars"
17:38:54 <Twey> ehird: That's because the javascript: scheme navigates to the result of the JS expression
17:38:57 <Pseudonym> Sounds like a very cool paper.
17:39:07 <guenni> is there some game engine written in Haskell?
17:39:09 <wagle_home> what does void foo = 2  mean?
17:39:10 <Twey> ehird: So void makes sure that's undefined
17:39:12 <idnar> or rather, navigates to a document with the contents of the result
17:39:18 <ehird> I like #0398C6
17:39:22 <Pseudonym> Yup, I've never heard of this Dr. Frost, but he's One Of Us(tm).
17:39:22 <ehird> Twey: Yeah, well.
17:39:48 <Twey> Hm, yes, that's quite nice too.
17:39:48 <diboss> One of us? Lol
17:40:09 <idnar> couldn't you just do javascript:document.style.backgroundColor = '#8ae234';undefined ?
17:40:10 <Twey> I think it's referred to as 'Bahama blue' by some DIY store I once visited.  :-P
17:40:10 <Adamant> we accept you, one of us
17:40:14 <diboss> so I was wondering if Haskell is worth the learning curve (I hear it's big)
17:40:22 <Twey> diboss: Sure is
17:40:24 <Pseudonym> Seems to be a NLP guy, who's seriously into lazy functional/combinator parsing.
17:40:26 <Adamant> what languages do you know?
17:40:30 <ehird> idnar: that would navigate to 'undefined
17:40:44 <Twey> ehird: undefined is treated specially.
17:40:47 <Twey> idnar: Yes, you could.
17:40:54 <Twey> But that's extra characters :-)
17:40:58 <diboss> C/C++, Java, Scheme/Lisp, D
17:41:07 <Twey> diboss: It'll probably change the way you look at programming.
17:41:15 <Adamant> if you know Scheme Haskell isn't a huge leap
17:41:19 <ehird> Twey: Try #7DCB6E
17:41:23 <Philippa> *blink* - give or take the fact I wanted sugar, that's a /lot/ like something I've talked to a few people about
17:41:24 <ehird> Adamant: wrong
17:41:25 <Twey> Which is a worthy goal all in itself :-)
17:41:29 <Adamant> it would be easier if you had tried a ML before
17:41:33 <idnar> void is really weird
17:41:39 <Adamant> ehird: I'm no expert but I disagree
17:41:39 <guenni> don't listen to them diboss they told me that too
17:41:48 <Philippa> edwinb: you remember me mentioning wanting to overload let a few times?
17:41:50 <diboss> Oh, I did do Miranda years ago (Dr. Frost taught that)
17:41:57 <ehird> diboss: Oh, then it'll be trivial.
17:42:01 <ehird> Miranda is highly related to Haskell
17:42:13 <diboss> guenni: well, you're still here, so I guess you liked it
17:42:15 <guenni> they just try to lure you into it
17:42:23 <Twey> ehird: Hmm, not sure if I like that one
17:42:25 <Pseudonym> Yeah.
17:42:32 <ehird> Miranda is Haskell's parent
17:42:33 <Pseudonym> If you know Miranda, Haskell is its direct descendant.
17:42:34 <Twey> ehird: It's just a *bit* too yellow.
17:42:43 <Pseudonym> So that's great, you've already got the basics worked out.
17:42:43 <guenni> diboss: well I'm a masochist
17:42:47 <diboss> ok, guess I have something to learn in the next little bit
17:42:55 <wagle_home> scheme to basic haskell isnt a huge leap..  advanced haskell is a bit of a leap
17:43:01 <idnar> Twey: it works if you have more than one statement, though
17:43:12 <idnar> although I guess you could just stick the void on the last one
17:43:25 <wagle_home> its advanced haskell that is the really really interesting part
17:43:43 <Twey> Yep
17:43:52 <ehird> Twey: #C0D5E5
17:43:58 <guenni> wagle_home: where does advanced haskell start?
17:45:16 <wagle_home> types, monads, ...
17:45:39 <sm> .. understanding compiler errors, ..
17:45:41 <ehird> wagle_home: that's ADVANCED?
17:45:50 <ehird> that's like Trivial Haskell
17:46:07 <bd_> ehird: You underestimate the power of compiler errors
17:46:09 <guenni> true
17:46:17 * Philippa should probably state for the record that she's not saying she did what Dr Frost's doing beforehand - I'd had the idea of something equivalent to memoise as will a number of other people but there's plenty novel in that implementation
17:46:20 <Twey> ehird: Very corporate
17:46:25 <ehird> bd_: Eh, I haven't had THAT much problem understanding them
17:46:28 <wagle_home> ok, fine, you say whats advanced..  scheme doesnt really have them
17:46:29 <guenni> cause I'm still strugling with types
17:46:55 <bd_> ehird: usually sure, but try some advanced type system hackery...
17:46:59 <ehird> Twey: For really dark colours, #030F18 is nice
17:47:04 <ehird> bd_: So don't do that.
17:47:10 <ehird> Twey: It's like 100% chocolate
17:47:15 <guenni> and types and Monads seem to be essential, difficult but I hadn't considered them advanced either
17:47:30 <edwinb> Philippa: mmm?
17:47:44 <wagle_home> i read two books on haskell, and both barely talked about types or monads
17:48:00 <guenni> ehird: so what do you consider advanced?
17:48:05 <wagle_home> advanced compared to other languages
17:48:06 <Philippa> edwinb: the parsing paper mentioned above's doing something that'd be a prime candidate for it, only it has to fudge the identifiers
17:48:36 <wagle_home> you can do very tricky things with types
17:48:37 <edwinb> oh yes? I didn't look at it...
17:48:42 <Twey> ehird: Eh?  It's bluish
17:49:34 <guenni> wagle_home: yes I agree, is there some paper that focuses on this?
17:49:40 <ehird> Twey: Very dark though
17:49:45 <ehird> guenni: Very crazy stuff
17:49:46 <ehird> :D
17:49:54 <Twey> ehird: Chocolate would surely be more of a #130308
17:49:55 <Philippa> edwinb: it's got a memoise combinator, which you supply a "label" value so they don't have to pass around a fresh name supply (mdo'd do for that otherwise, I guess) and you just define foo = memoise FOO $ ... foo ...
17:50:02 <wagle_home> @hoogle papers
17:50:02 <lambdabot> No matches found
17:50:06 <wagle_home> o.O
17:50:15 <ehird> Twey: 100% chocolate
17:50:21 <ehird> Twey: have you ever seen how dark that is?
17:50:24 <Philippa> obviously this'd be much nicer if you could just have olet foo = ... foo ... and get back something that does the fresh name and memoise call stuff for you
17:50:50 <ehird> Twey: its certainly not brown
17:50:56 <Twey> ehird: It's really blue?
17:51:09 <Philippa> (where olet = "overloaded let")
17:51:46 <guenni> Is there a paper that demonstrates what neat stuff you can do with types?
17:51:50 <wagle_home> guenni, poke around www.haskell.org, or ask other people here
17:52:00 <Cale> Twey: Of course it's blue
17:52:32 <byorgey> ehird: careful calling things trivial, please, it won't do to put off people who don't find it so trivial =)
17:52:42 <guenni> wagle_home: will do
17:52:46 <ehird> byorgey: that's true
17:52:52 <ehird> but types and monads aren't advanced haskell
17:52:53 <ehird> forsure
17:53:18 <ehird> Twey: It's black, but not totally black. closer to mine than yours
17:53:20 <idnar> monads aren't?
17:53:26 <byorgey> @go Monad Reader
17:53:27 <lambdabot> http://www.haskell.org/haskellwiki/The_Monad.Reader
17:53:27 <lambdabot> Title: The Monad.Reader - HaskellWiki
17:53:31 <Cale> Twey: Red: 3, Green: 15, Blue: 24
17:53:44 <wagle_home> guenni, ^^^ monad reader
17:53:46 <Cale> (that's the same in decimal)
17:53:47 <idnar> you can write quite a lot of Haskell code (including code that uses the list and IO monads) without really understanding monads
17:54:17 <byorgey> ehird: I wasn't disagreeing, just taking issue with the way you phrased your response
17:54:42 <Twey> Cale: Huh, that's about the same as ehird's I think
17:55:11 <Cale> Twey: oh, oops, got the people mixed up :)
17:55:20 <idnar> I would still describe dark chocolate as more brown than blue
17:55:37 <Cale> Twey: yeah, it's ehird's colour in decimal
17:55:48 <Twey> Ah, yeah.  Heh
17:55:51 <idnar> #130308 is probably too red, though
17:56:01 <Twey> I converted it to hex but didn't realise it was the same as ehird's
17:56:08 <Cale> Sort of a sky blue colour which has been darkened to the point of almost being black.
17:56:16 <Twey> Yeah.
17:56:37 <ehird> eh
17:56:39 <ehird> looks right to me
17:56:40 <ehird> :)
17:57:42 <Twey> Heh
17:59:16 <idnar> grhgh
17:59:28 <idnar> oops, wrong window
18:00:20 <Cale> Heh, that was meant for #gurgling
18:00:49 <idnar> I was about to complain about my code being broken, but it's not even Haskell code, so this really is the wrong place :P
18:01:13 <byorgey> idnar: you can still complain, but we'll probably say something like 'told you so' ;)
18:01:36 <jorick> what's #gurgling?
18:01:37 <idnar> bwahaha
18:01:50 <Twey> You realise we just started #gurgling.
18:02:14 <idnar> well, it turns out the problem was subclassing the wrong thing (my code is written in Python)
18:02:26 <idnar> so "told you so" seems pretty appropriate
18:02:48 <Pseudonym> Ha ha, you used Python.  Sucks to be you.
18:03:04 <byorgey> told you so
18:03:27 <Pseudonym> Had you used Haskell, the compiler would have found all your bugs for you.
18:04:17 <idnar> right now, I can't even imagine what this code would look like in Haskell, so I'm not sure if that's actually true >:)
18:04:39 <byorgey> idnar: so are you going to join #gurgling, or what?
18:07:53 <sw17ch> does a modification to an Array in haskell do a memcpy like a ByteString?
18:11:24 <Saizan_> sw17ch: if it's a pure array yes
18:12:05 <Saizan_> sw17ch: well not sure about memcpy, however it copies
18:12:06 <sw17ch> Saizan_, hmm... well, how about i describe my problem and perhaps some one knows a good container data type for this :)
18:12:24 <Saizan_> try :)
18:12:37 <sw17ch> large N x N (x N)? grid
18:13:00 <sw17ch> filled with zeros at the start, random mutations cause things to change
18:13:17 <dmwit> STArray!
18:13:19 <sw17ch> basically, i'm shooting for a large 2D virtual machine in which to play with Digital Evolution
18:13:33 <sw17ch> but don't want to have most of the overhead in the copy portion
18:13:39 <sw17ch> @where STArray
18:13:39 <lambdabot> I know nothing about starray.
18:13:42 <sw17ch> oh, hmm...
18:13:54 <Saizan_> ?hoogle STArray
18:13:54 <lambdabot> Data.Array.IArray.listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
18:13:54 <lambdabot> Data.Array.MArray.newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)
18:13:54 <lambdabot> Data.Array.ST.runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
18:13:54 <sw17ch> @hoogle STArray
18:13:54 <lambdabot> Data.Array.IArray.listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
18:13:55 <lambdabot> Data.Array.MArray.newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)
18:13:56 <lambdabot> Data.Array.ST.runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
18:13:57 <sw17ch> woops
18:14:02 <jadrian> hello all
18:14:04 <Saizan_> ?wiki Array
18:14:04 <lambdabot> http://www.haskell.org/haskellwiki/Array
18:14:11 <dmwit> Hiya, jadrian!
18:14:20 <jadrian> hello dmwit
18:14:25 <jadrian> I was wondering
18:14:33 <sw17ch> dmwit, what's the difference?
18:14:46 <dmwit> sw17ch: I have no idea.
18:14:53 <jadrian> do you guys know of any common functions of order higher than 2
18:14:54 <jadrian> ?
18:14:56 <dmwit> =P
18:15:02 <Saizan_> sw17ch: a STArray works inside the ST monad, so it's mutable
18:15:06 <jadrian> I mean in the haskell libs
18:15:10 <jadrian> any common ones?
18:15:11 <Excedrin> map?
18:15:12 <Twey> printf?
18:15:30 <sw17ch> Saizan_, suppose i should go figure out what the ST monad is first :)
18:15:30 <Saizan_> sw17ch: but you may want to use IOArray if you're already in IO
18:15:34 <BMeph> unfoldr?
18:15:34 <jadrian> well excluding polymorphic ones that can be applied to any type
18:15:35 <roconnor> callCC
18:15:54 <roconnor> @type callCC
18:15:55 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
18:16:07 <Saizan_> sw17ch: the ST monad is the IORefs and similar part of IO
18:16:11 <jadrian> ah callCC would do
18:16:25 <jadrian> I was looking for something less exoteric than that though :)
18:16:32 <roconnor> callCC : ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
18:16:38 * sw17ch watches as his brain floats away..
18:16:46 <jadrian> @type unfoldr
18:16:47 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
18:17:00 <roconnor> callCC isn't exoteric. :)
18:17:17 <sw17ch> is IOArray standard?
18:17:17 <jadrian> ok so unflodr would count as order 2...
18:17:19 <allbery_b> exotic, esoteric, or "yes"?
18:17:47 <roconnor> esoteric I guess
18:17:57 <Saizan_> sw17ch: yes
18:18:08 <sw17ch> ?hoogle IOArray
18:18:08 <lambdabot> No matches found
18:18:09 <Saizan_> sw17ch: however if the matrix is sparse a Data.Map could do
18:18:18 <jadrian> ops yes I mean esoteric
18:18:23 <sw17ch> Saizan_, no, quite dense
18:18:27 <sw17ch> or at least, that's the eventual goal
18:18:52 <jadrian> roconnor: it's esoteric in the sense that I've never used it nor tried to understand it before :)
18:19:00 <jadrian> roconnor: but yes it is a good example!
18:19:06 <jadrian> roconnor: thanks!
18:19:20 <gwern> what does this kind of error in haddock mean? 'Var/Type length mismatch:
18:19:20 <gwern> [s{tv agSD} [tv], a{tv agSE} [tv]]
18:19:20 <gwern> []
18:19:20 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
18:19:26 <Saizan_> sw17ch: http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-MArray.html
18:19:28 <lambdabot> http://tinyurl.com/2rsgh5
18:19:33 <Saizan_> ?wiki Array
18:19:34 <lambdabot> http://www.haskell.org/haskellwiki/Array
18:19:34 * jadrian should read about continuations :S
18:19:52 <roconnor> @djinn ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
18:19:52 <lambdabot> f a b = a (\ c _ -> b c) b
18:20:10 <gwern> @messages
18:20:10 <lambdabot> byorgey asked 32m 18s ago: would you mind updating the wiki with some info about your recent patches? whatever someone upgrading to 0.8 would like to know. http://haskell.org/haskellwiki/Xmonad/
18:20:10 <lambdabot> Notable_changes_since_0.7
18:20:22 <Saizan_> sw17ch: this page has a comparison of the various Array types http://www.haskell.org/haskellwiki/Arrays
18:20:23 <lambdabot> Title: Arrays - HaskellWiki
18:20:27 <gwern> @message lambdabot @messages
18:20:27 <sw17ch> No text in the wiki page...
18:20:27 <lambdabot> Maybe you meant: messages messages?
18:20:34 <sw17ch> oh, there we go
18:20:46 <roconnor> @free ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
18:20:46 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
18:20:59 <roconnor> @free callCC::((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
18:20:59 <lambdabot> (forall q f1. (forall x f2 f3. h . f2 = f3 . g                               =>                                h (q x f2) = f1 (f x) f3)              =>               (forall f4 f5. h . f4 = f5 . f
18:20:59 <lambdabot>                            =>                              h (k q f4) = p f1 f5)) => h . f6 = f7 . f => h (callCC k f6) = callCC p f7
18:21:20 <roconnor> good to know
18:21:28 <dmwit> ?tell lambdabot ?messages
18:21:28 <lambdabot> Nice try ;)
18:21:33 <dmwit> heh
18:21:46 <idnar> heh
18:22:29 <jadrian> roconnor: what was that free thing??
18:22:43 <dmwit> It generates free theorems.
18:23:03 <sw17ch> Saizan_++
18:23:10 <idnar> what's with all the whitespace?
18:23:14 <jadrian> as in "theorems from free" from phill w?
18:23:21 <dmwit> I think so, yes.
18:23:37 <Saizan_> @free map
18:23:38 <lambdabot> Expected variable or '.'
18:23:53 <roconnor> @free undefined :: a
18:23:53 <lambdabot> f undefined = undefined
18:24:01 <roconnor> :)
18:24:03 <Saizan_> @free map :: (a -> b) -> [a] -> [b]
18:24:03 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
18:24:48 <roconnor> @free unsafeCast :: a -> b
18:24:48 <lambdabot> g . unsafeCast = unsafeCast . f
18:24:56 <roconnor> :)
18:25:13 <sw17ch> alright, another funny question... how does one... continue to do something *forever* inside IO?
18:25:23 <EvilTerran> ?src forever
18:25:23 <lambdabot> Source not found. You speak an infinite deal of nothing
18:25:23 <kpreid> sw17ch: forever a = a >> forever a
18:25:33 <sw17ch> looks like IOArray is what I'm looking for... but my problem set requires me to do the same sequence of things again and again
18:25:35 <sw17ch> hmm
18:25:37 <gwern> @hoogle forever
18:25:37 <lambdabot> Control.Monad.forever :: Monad m => m a -> m ()
18:26:01 * roconnor finds forever surprisingly useful.
18:26:13 <sw17ch> is there a forever with conditions?
18:26:21 <kpreid> @type \a -> fix (a >>)
18:26:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
18:26:28 <kpreid> sw17ch: that wouldn't be forever!
18:26:36 <EvilTerran> ?type fix (>>)
18:26:36 <kpreid> @hoogle whileM
18:26:37 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m b)
18:26:37 <lambdabot>     Probable cause: `>>' is applied to too few arguments
18:26:37 <lambdabot>     In the first argument of `fix', namely `(>>)'
18:26:37 <lambdabot> No matches found
18:26:38 <gwern> @hoogle until
18:26:39 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
18:26:42 <EvilTerran> ?type fix . (>>) -- even
18:26:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
18:26:48 <sw17ch> hah, i was just going to look for "until"
18:26:55 <gwern> kpreid: only a diamond is forever
18:26:58 <idnar> @type forever a = a >> forever a
18:26:59 <lambdabot> parse error on input `='
18:27:05 <EvilTerran> sw17ch, you'd want whileM/untilM, if such a thing existed
18:27:05 <idnar> @type \a -> a >> forever a
18:27:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
18:27:14 <sw17ch> EvilTerran, yes, that's what i'm thinking
18:27:17 <roconnor> gwern: isn't box forever?
18:27:24 <sw17ch> box?
18:27:25 <roconnor> diamonds are eventually.
18:27:27 <Saizan_> but it's easy to write
18:27:30 <idnar> hahaha
18:27:34 <Saizan_> hahahahah
18:27:45 <EvilTerran> sw17ch, you might be able to do something snazzy with foldM
18:27:54 <EvilTerran> the IO monad is forever!
18:27:59 <kpreid> sw17ch: whileM p a = do b <- p; if b then a >> whileM p a else return ()
18:28:05 <Saizan_> well box is not forever per se, afaiu :)
18:28:07 <kpreid> sw17ch: easy! (clunky)
18:28:09 <EvilTerran> ... 'til unsafePerformIO do us part
18:28:42 <roconnor> Saizan_: forever = not eventually not ?
18:28:50 <sw17ch> kpreid, and if i want the output from the previous pass to be sent to the next it would be
18:28:57 <sw17ch> whileM p a = do b <- p; if b then a >>= whileM p a else return ()
18:29:23 <kpreid> sw17ch: well, you could use an IORef along with that, and you need to accept the parameter too, but yeah
18:29:42 <sw17ch> b/c i want to pass the same IOArray each time
18:30:01 <Saizan_> roconnor: yes, but don't you also need fixpoints to express forever/eventually? (we are talking about mu-calculus right?)
18:30:02 <roconnor> although box is not necessarily forever.
18:30:22 <roconnor> aka box is possibly not forever.
18:30:48 <roconnor> Saizan_: I'm just talking about a common interpretation of modal logic.
18:31:55 <gwern> modal logic - another thing I always intended to learn
18:33:43 <jadrian> roconnor: the callCC example is cool. Do you know of any more common function of order 3 and above by any chance? I've been going through the libs documentation but no luck :S
18:34:04 <roconnor> jadrian: they are pretty rare
18:34:17 <jadrian> roconnor: yeap :S
18:34:19 <sw17ch> @type newArry
18:34:20 <lambdabot> Not in scope: `newArry'
18:34:22 <sw17ch> @type newArray
18:34:23 <lambdabot> Not in scope: `newArray'
18:34:40 <jadrian> roconnor: I've been playing around with functions up to order 5 :)
18:35:07 <jadrian> roconnor: but now I wanted to check some actually useful functions to use them as examples
18:35:16 <roconnor> jadrian: My favourite is ((((a -> b) -> a) -> a) -> b) -> b
18:35:33 <jadrian> roconnor: been there done that ;)
18:35:42 <roconnor> oh
18:35:46 <roconnor> what does it do?
18:35:55 <jadrian> roconnor: in fact that was the highest I went to
18:36:05 <roconnor> what level is callCC?
18:36:30 <jadrian> roconnor: that would be 3rd
18:36:41 <roconnor> @type callCC
18:36:42 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
18:36:43 <Saizan_> roconnor: i've seen used forever only in temporal logics, but i admit i know little in the field
18:36:44 <BMeph> ?src when
18:36:44 <lambdabot> when p s = if p then s else return ()
18:36:50 <jadrian> roconnor: in the sense that the lowest it can be specialized to is 3
18:37:11 <shachaf> @unmtl Cont r (Cont r a) -> Cont r a
18:37:11 <lambdabot> Cont r (Cont r a) -> Cont r a
18:37:13 <shachaf> @unmtl Cont r (Cont r a)
18:37:13 <lambdabot> (((a -> r) -> r) -> r) -> r
18:37:33 <monochrom> There are two callCC's.  An advanced one is: ((forall b. a -> m b) -> m a) -> m a.  See also the haskell wiki article "cont monad done right" or something.
18:38:06 <roconnor> jadrian: I'm pretty sure that callCC is level 4 with the regular continuation monad, where m b = (b -> r) -> r
18:38:13 <monochrom> http://www.haskell.org/haskellwiki/MonadCont_done_right
18:38:13 <lambdabot> Title: MonadCont done right - HaskellWiki
18:38:14 <jadrian>  monochrom: hm nice thanks
18:38:27 <monochrom> oops, ((a -> (forall b. m b)) -> m a) -> m a
18:38:49 <ddarius> gwern: I can probably rustle up a good modal logic article.
18:38:53 <monochrom> Oh I guess the two sigs are isomorphic. forall hoisting etc.
18:38:59 <Pseudonym> monochrom: I was about to say, yes.
18:39:36 <ddarius> gwern: Also diamonds eventually become graphite.
18:40:00 <roconnor> would ((a -> m Void) -> m a) -> m a work?
18:40:01 <monochrom> diamonds are not forever?!
18:40:11 <roconnor> and be closer to haskell 98?
18:40:15 <jadrian> roconnor: hmm right I just counted the arrows, but the fact that it has the MonadCont restriction there might change things
18:40:21 <shapr> @seen Lemmih
18:40:21 <lambdabot> I saw Lemmih leaving #haskell 5h 47m 40s ago, and .
18:40:23 <shapr> aww
18:40:26 <shapr> @seen Saizan
18:40:26 <lambdabot> I saw Saizan leaving #haskell.it, #haskell-soc, #haskell-overflow, #haskell-blah and #haskell 2h 36m 26s ago, and .
18:40:38 <roconnor> jadrian: look at the specific Cont r a instance.
18:41:08 <gwern> ddarius: you means debeers lied to us?
18:41:11 <gwern> but we trusted them
18:41:33 <monochrom> I think  ((a -> m Void) -> m a) -> m a  works too.
18:41:35 <jadrian> roconnor: so wouldn't it be 5 if m b = (b -> r) -> r ?
18:41:48 <jadrian> roconnor: yeap I will
18:42:09 <roconnor> jadrian: I count 4
18:43:03 <roconnor> ((a -3> (b -4> r) -3> r) -2> (a -3> r) -2> r) -1> (a -2> r) -1> r
18:43:58 <jadrian> roconnor: you're rightm, 4
18:44:06 <Saizan_> shapr!
18:44:20 <roconnor> @get-shapr
18:44:20 <lambdabot> shapr!!
18:44:35 <shachaf> That should be set up to ring his phone.
18:45:06 <shapr> You called?
18:45:10 * shapr grins
18:45:18 <roconnor> jadrian: calCC is used in real life.  I don't even know what ((((a -> b) -> a) -> a) -> b -> b does.
18:45:18 <Saizan_> :)
18:45:22 <shapr> Saizan_: Just wondering if you could comment on the stability of HAppS...
18:45:36 * shachaf has helped someone set up his phone so that it would ring when someone sent them a message, then use a text-to-speech program to speak it.
18:45:37 <shapr> I'd like to build a webapp in Haskell, but I'd also like to be able to rely on the APIs.
18:46:24 <jadrian> roconnor: mine doesn't do anything useful, I used it to study the behaviour of exceptions at higher order types
18:46:32 <jadrian> roconnor: (call by value)
18:46:33 <Saizan_> shapr: well, we've a proper release now, and things have settled a lot
18:46:40 <shapr> Ah, spiffy.
18:47:14 <Saizan_> the current work is on the multimaster/sharding backend now, i think
18:47:15 <shapr> Ok then, I'll try it.
18:47:18 * monochrom sends a pdf to shachaf's phone. it's the "free theorems" paper. have fun with Greek letters read out loud.
18:47:26 <sw17ch> > foldr1 (*) (reverse [1..10]) :: Expr
18:47:27 <lambdabot>  10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (2 * 1))))))))
18:47:36 <sw17ch> > foldr1 (*) (reverse [1..n]) :: Expr
18:47:37 <lambdabot>  Exception: not a number
18:47:39 <sw17ch> boo
18:47:40 <hpaste>  mblondin pasted "(no title)" at http://hpaste.org/6780
18:47:44 <shachaf> monochrom: It's not my phone, and it only speaks a few seconds of it anyway.
18:47:48 <sw17ch> > foldl1 (*) (reverse [1..10]) :: Expr
18:47:48 <lambdabot>  10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1
18:48:50 * BMeph nudges monochrom, and points at the "Bananas..." paper...
18:49:50 <monochrom> ooohhh, brackets....
18:49:56 <Saizan_> shapr: there has been a couple blog posts by mightybyte and there are examples under HAppS-Server/Examples , still lacking in documentation :)
18:49:59 <shachaf> > compare 1 n
18:50:00 <lambdabot>  LT
18:50:01 <dolio> Yeah, that's a good one. It has symbols I don't even know how to pronounce.
18:50:02 <shachaf> > compare n m
18:50:03 <lambdabot>  GT
18:50:39 * jadrian is off to bed
18:50:41 <Saizan_> and uses || for product.. where's that from?
18:50:43 <jadrian> thanks guys
18:50:46 <shachaf> Saizan_: HAppS is becoming stable(r)?
18:51:02 <dolio> Plenty of "superscript black dot"
18:51:20 <Saizan_> shachaf: yeah, amazing eh?:)
18:51:32 * shachaf should look into it.
18:51:52 <dolio> "left accented pi"
18:52:04 <Saizan_> shachaf: it's on hackage too! cabal install HAppS-Server
18:52:57 <hpaste>  mblondin pasted "(no title)" at http://hpaste.org/6781
18:54:51 <dolio> average = DIV compose open-banana (0 superscript-black-dot upsidedown-triangle (+) compose id||left-accented-pi) triangle (0 superscript-black-dot upsidedown-triangle (+1) compose right-accented-pi close-banana :)
18:55:58 <gwern> you know one that really bothers me about cabal?
18:56:12 <gwern> how it's error messages go "oh noes, the `foo bar' happened"
18:56:27 <gwern> the use of ` means you can't copy and paste it! it's so annoying
18:57:01 <gwern> if it had been 'foo bar', you could double click to get it, and then triple click to the next level of quoting
18:57:06 <gwern> but with a backtick, oh no
18:57:23 <EvilTerran> i think it's taking its cue from ghci
18:57:35 <Saizan_> gwern: open a ticket or send a patch :)
18:57:47 <EvilTerran> and, going back further, tex etc
18:58:01 <gwern> Saizan_: maybe I will!
18:58:17 * gwern is mad as heck and probably isn't going to take it any more
18:58:45 <catface> > liftM print getLine
18:58:46 <lambdabot>  <IO (IO ())>
18:59:42 <shachaf> Saizan_: Would you recommend using the hackage version over a darcs version?
19:00:15 <gwern> @hoogle SHA1
19:00:15 <lambdabot> No matches found
19:00:36 <shachaf> gwern: What do you mean?
19:00:48 <idnar> > print =<< getLine
19:00:48 <lambdabot>  <IO ()>
19:00:54 <shapr> Saizan_: Thanks
19:00:59 <shachaf> gwern: Double-click on the "foo" selects "`foo".
19:01:13 <shachaf> gwern: Triple-click selects "foo bar" (without the quotes).
19:01:22 * gwern thought I was clear enough in my rant
19:01:35 <shachaf> Quadruple click selects "\"oh noes, the `foo bar' happened\""
19:01:45 <shachaf> gwern: How would you want it to work?
19:02:12 <Saizan_> shachaf: not particulary
19:02:14 <gwern> shachaf: why on earth would you want "`foo"? into what could you possibly paste that where a leading backtick means anything
19:02:45 <shachaf> "Oh no, 'foo bar' happened" does the same thing, no?
19:02:50 <dolio> What if you want to paste it into a latex document?
19:02:52 <shachaf> gwern: How would you want it to behave?
19:03:16 <EvilTerran> gwern, it means quasiquoting in scheme... :P
19:03:22 <gwern> shachaf: what I have is Shim/Hsinfo.hs:184:38: Not in scope: `SHA1.hash'', where if I doublecluck on the missing stuff, with the intent of pasting it into the file to *fix* the problem, I instead get '`SHA1.hash', which is not valid Haskell
19:03:52 <gwern> EvilTerran: how wonderful for the many schemers?
19:03:54 <Saizan_> but that's not cabal, it's ghc, no?
19:04:00 <shachaf> gwern: What's your error?
19:04:05 * gwern thought that was just ' anyway
19:04:08 * shachaf doesn't get "`SHA1.hash".
19:04:16 <gwern> that might be common and emacs lisp tho
19:04:16 <ddarius> gwern: I like this 4 page bit on modal logic: http://web.mit.edu/holton/www/courses/freewill/modlog.pdf  An interesting, more formal approach is "A Judgemental Reconstruction of Modal Logic".
19:04:26 <EvilTerran> ' is normal quoting. you can splice inside a ` with a ,
19:04:31 <monochrom> I think you should direct the complaint to the author of double-clicking.
19:04:42 <gwern> Saizan_: the same idea obtains when cabal complains a module/file is missing
19:04:49 <gwern> I've been tediously going through sdist failures in yi
19:04:49 <ddarius> I think you should direct the complaint to the author of the universe.
19:04:50 <EvilTerran> anyway. it's late, i'm going to bed before i spout any more heretical nonsense. :P
19:05:17 <gwern> and it's even more tedious copy and pasting and every fracking time having to remove the leading backtick
19:05:26 <gwern> ddarius: thanx
19:05:30 <monochrom> ` is clearly a punctuation, not a letter.  If double-clicking is to select a word in the English sense, it shouldn't extend to ` or ' or , or " or
19:05:30 <shachaf> `EvilTerran'
19:05:50 <shachaf> monochrom: How about "bar'"?
19:05:56 <shachaf> What should be selected?
19:06:09 <monochrom> IMO bar
19:06:37 <shachaf> What if you have a function called "bar'"?
19:06:48 * shachaf probably agrees, though.
19:06:50 <EvilTerran> i think SciTE does it right - it depends on where you double-click
19:06:54 <monochrom> hello
19:06:58 <shachaf> That's what multiple clicks are for.
19:06:58 <EvilTerran> going for the middle of a word, you get the word
19:07:05 * shachaf has some Unicode trouble -- what is that?
19:07:12 <glen_quagmire> you have to recompile Scite i think. to change syntax coloring
19:07:24 <monochrom> open double quotes, close double quotes
19:07:25 * shachaf likes urxvt's double-click behavior, mostly.
19:07:27 <EvilTerran> going for somewhere near the end of a word, you get that word and the whitespace/punctuation by that end
19:07:36 <catface> > print <<= getLine >>= print
19:07:37 <lambdabot>   Not in scope: `<<='
19:07:39 <monochrom> I put it there so you can also test your double-click on them.
19:07:45 <shachaf> It's even (usually) smart enough to select URLs properly.
19:08:04 <EvilTerran> glen_quagmire, don't think so. you can install custom lexers without re-compiling, AFAIK. that might just be on windows with DLLs, though.
19:08:17 <ddarius> EvilTerran: That kind of crap aggravates me to no end.
19:08:35 <shachaf> monochrom:  and  ?
19:08:39 <monochrom> Yes
19:08:40 <idnar> > print =<< getLine >>= print
19:08:40 <lambdabot>      precedence parsing error
19:08:40 <lambdabot>         cannot mix `(=<<)' [infixr 1] and `(>>=...
19:08:41 <EvilTerran> ddarius, what, highlighting stuff around the word when you double-click near the end?
19:08:44 <idnar> heh
19:08:49 <ddarius> EvilTerran: Yes
19:08:54 <EvilTerran> i find it really handy, myself. i guess it depends on what you're used to.
19:08:55 * shachaf can type it, but it's only visible in the typing area. :-)
19:09:01 <monochrom> hehe
19:09:42 <EvilTerran> and SciTE was my first primary code editor, and remains so to this day, so i'm really quite used to it :)
19:09:52 <shachaf> monochrom: Double-clicking the word selects the whole thing (all of "hello").
19:10:04 <shachaf> But then, this terminal isn't necessarily smart about Unicode.
19:10:20 <monochrom> same behaviour here. I much regret it.
19:10:29 <idnar> in my terminal, I get "hello"
19:10:39 <idnar> but triple-click always selects the whole line
19:10:40 <monochrom> computing is in such a dark age. programmers make no sense.
19:10:52 * shachaf checks what gvim does.
19:10:58 <idnar> "hello" as in without the unicode quotes
19:11:03 <shachaf> (Of course, in vim, you'd use the keyboard.)
19:11:07 <idnar> I run vim in a terminal too, so I get the same behaviour there
19:11:18 <ddarius> monochrom: Agreed.
19:11:38 <shachaf> Double-click, "foo", triple-click, the whole thing (including '"'s).
19:11:52 <glen_quagmire> source code editing should be like Wii. no more typing
19:12:36 <shapr> glen_quagmire: Um, what?
19:12:39 <lament> my terminal (iTerm) doesn't select the unicode quotes
19:12:45 <glen_quagmire> source code should look like 3d maze. no more text file
19:13:03 <shapr> glen_quagmire: That's a great idea, why don't you implement it in Haskell?
19:13:04 <catface> let print1 a = print a >> return a in print1 =<< print1 =<< (getLine >>= print1 >>= print1)
19:13:06 <catface> > let print1 a = print a >> return a in print1 =<< print1 =<< (getLine >>= print1 >>= print1)
19:13:06 <lambdabot>  <IO [Char]>
19:13:09 <EvilTerran> glen_quagmire, you've watched too many hollywood movies
19:13:28 <lament> glen_quagmire: it's been done
19:13:29 <ddarius> shapr: They should make a dasher interface for the Wii...
19:13:35 <shapr> Yeah, would be cool.
19:13:39 <qwr> glen_quagmire: working code should arise from a wave of hand ;)
19:15:29 <glen_quagmire> sign languages are great. we do similar with coding
19:15:45 <shapr> Yeah, good idea, go for it!
19:16:18 <shapr> glen_quagmire: Are you going to start with a bluetooth binding for Haskell so you can read input from the Wii?
19:17:09 <glen_quagmire> no. i prefer writing papers and done with it. and let others do the coding
19:17:14 <shachaf> Do you really need a Bluetooth binding to communicate with one specific device (and one specific driver)?
19:17:18 <shapr> glen_quagmire: oh
19:17:24 <dmwit> :t (<*)
19:17:24 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
19:17:36 <shapr> shachaf: I don't know, maybe just a minimal binding that others could extend later?
19:17:39 <kpreid> ddarius: one way to try that would be to port dasher to flash
19:17:45 <glen_quagmire> i mean, i don't haev a good idea on how that'll work anyways.
19:18:00 <shapr> Well, you could get a good idea by trying it.
19:18:18 <shachaf> At first glance, there seems to be something called "libwiimote".
19:18:24 <shapr> Ah, spiffy!
19:18:50 <shachaf> (Replaced with "libcwiid", rather.)
19:18:53 <dmwit> > getLine >>= \x -> return x <* replicateM 4 (print x)
19:18:54 <lambdabot>  <IO [Char]>
19:18:57 <cjb> kpreid: there's a Java Dasher applet.
19:18:58 <dmwit> catface: ^^^
19:19:03 * cjb == ex-Dasher maintainer :)
19:19:15 <cjb> there's an xorg-input-wiimote too
19:19:20 <cjb> it uses libwiimote IIRC
19:19:43 <dmwit> ?pl \x -> return x <* replicateM 4 (print x)
19:19:43 <lambdabot> liftM2 (<*) return (replicateM 4 . print)
19:20:34 <kpreid> cjb: wii browser doesn't run Java
19:20:37 <dmwit> :t \x -> fmap (const x) (replicateM 4 (print x))
19:20:38 <lambdabot> forall a. (Show a) => a -> IO a
19:20:49 <shapr> Sounds like I should get some wiimotes...
19:20:57 <OceanSpray> hey guys, I'm using xmonad!
19:20:58 <kpreid> cjb: connecting the remote to a regular computer is probably a better idea
19:21:01 <shapr> OceanSpray: Cool!
19:21:03 <dmwit> OceanSpray: Awesome!
19:21:18 <kpreid> shapr: note to use the pointing functionality you need a pair of IR sources
19:21:19 <dmwit> OceanSpray: Join us in #xmonad for a WM par-tay!
19:21:23 <shapr> cjb: Any idea if more XOs will be available for public purchasing sometime soon?
19:21:39 <shapr> kpreid: Sure, my friend starting using candles when his bar broke.
19:21:54 <cjb> shapr: Not likely.  As ever, go to eBay.
19:21:59 <shapr> Ah well
19:22:17 <shapr> I keep hoping :-)
19:22:25 <shapr> You're right, the XO is the most hackable platform.
19:22:51 <cjb> I don't really understand why people want us to sell them again
19:23:02 <cjb> they are on ebay.  they are much cheaper than we sold them for.
19:23:32 <cjb> why is it necessary to get one from us, when it's not at all related to our goals?
19:23:51 <dmwit> Some people like to support interesting projects?
19:24:08 <shapr> Well, if the supply dries up, and I start doing interesting things with an XO, how will my friend get XOs?
19:24:31 <shapr> er, friends*
19:25:02 <cjb> You can support us by buying one on ebay and donating the difference back to us to get more laptops for kids.
19:25:03 <shapr> but you have a good point, it's not related to the goals of OLPC
19:25:08 <shapr> heh, fair enough :-)
19:25:37 <lament> glen_quagmire: http://www.purplehatstands.com/bequnge/screenshots.php
19:25:43 <lambdabot> Title: BeQunge
19:26:29 <dmwit> Hokay.
19:26:30 <dmwit> So.
19:26:59 <lament> cjb: because buying from ebay is unnecessarily dangerous
19:27:02 <lament> for one
19:27:10 <lament> i would NOT buy a computer on ebay.
19:27:53 <cjb> that's up to you.  many people disagree.
19:28:12 <glen_quagmire> lament: oh nice
19:29:01 <Cale> lament: Even if someone had given them an A++++++++++++++++++++++++++++++++++++++++++++? ;)
19:29:34 <shapr> lament: So if I buy two, and sell you one... would that work?
19:29:34 <dejones> Cale: be careful with computers from Ebay...  those rating systems suck  ;)
19:29:47 <lament> shapr: yes, if you check that it works fine.
19:29:47 <dmwit> How do I convince somebody that they should learn Haskell to work on our senior project?  (Do I even want to?)
19:29:57 <cjb> dmwit: high school or college?
19:30:00 <shachaf> Cale: I demand at least 8 'A's before I trust anyone on eBay.
19:30:00 <dmwit> college
19:30:01 <cjb> probably not
19:30:08 <cjb> there's nothing worse than a bad Haskell programmer :)
19:30:16 <dmwit> That's what I was thinking. =P
19:30:19 <dejones> dmwit: what's the project?
19:30:20 <shachaf> cjb: Sure there is.
19:30:20 <lament> hey! why are you insulting me :(
19:30:27 <dmwit> dejones: That's up to us.
19:30:41 <dejones> cjb: how is there nothing worse than a bad Haskell programmer...?  Gotta learn somehow!
19:30:51 <dejones> dmwit: ahh, I was curious if you had already decided.
19:30:52 <Cale> There's a bad PHP programmer.
19:31:07 <dmwit> It's not even a reflection on the coder; I think everybody's first FP code probably sucks. =P
19:31:27 <dmwit> dejones: Well, I want to design a better shell language or get compositing support in xmonad.
19:31:32 <glen_quagmire> dmwit: make a game in haskell so that i can spend my time wisely
19:31:35 <dmwit> dejones: But he didn't sound too excited about those ideas.
19:31:52 <glen_quagmire> addictive games are works of arts
19:32:27 <glen_quagmire> is this pair programming class? eXtreme Programming
19:32:43 <solrize> http://www.lisperati.com/landoflisp/   <--- you all saw this?  hehe
19:32:48 <dmwit> glen_quagmire: yeah =/
19:32:53 <dejones> dmwit: well, find some common ground for the project, but I don't think there's anything wrong with learning a new language for a project.  I learned Ruby on Rails and Ruby for my senior project.  Ruby, of course, is not as challenging as Haskell, but both are fun to learn.  :)
19:33:33 <glen_quagmire> probably the project should be graphic and clickable to impress professor
19:33:38 <dmwit> glen_quagmire: http://tower.bloxx.fizzlebot.com/ -- here ya' go, compiled the Haskell to Flash, I hope you don't mind ;-)
19:33:38 <lambdabot> Title: Tower Bloxx by Digital Chocolate
19:34:40 <glen_quagmire> 64bit linux sucks. too lazy to set up flash plugin
19:36:17 <glen_quagmire> i recommend C#.NET.ASP web shopping cart with Web2.0 drag and drop shopping cart with enterprise databases
19:37:24 <lament> in defense of lisperati.com, there's http://lisperati.com/haskell/ too
19:37:58 <ddarius> Flash should be purged from the universe anyway
19:38:33 <glen_quagmire> the only reason why flash should stay is salad fingers
19:39:59 <solrize> yeah, lisperati.com/haskell was written by the same guy
19:40:26 <solrize> it's all in good fun imho
19:42:06 <dejones> glen_quagmire: omg... nooo shopping carts!!
19:44:57 <lament> i think that not only it's in good fun, it's a pretty accurate description of haskell
19:46:22 * roconnor feels bad at working as a murderous oppressor
19:47:43 <lament> (and lisp)
19:48:30 <Adamant> roconnor: which one?
19:48:53 <roconnor> one of the robots behind the judge.
19:49:32 <lament> yeah but the idea that they're murderous oppressors is _lisper propaganda_
19:50:25 <lament> which is more or less correct, just ask #lisp :)
19:52:03 <lament> @faq Does haskell turn people into murderous oppressor robots?
19:52:04 <lambdabot> The answer is: Yes! Haskell can do that.
19:52:09 <roconnor> I don't know why the hero didn't just use Quickcheck.
19:52:22 <roconnor> that would have saved all this trouble.
19:52:31 <TomMD> I think Conrad went a bit overboard.
19:52:31 <lament> because the entire plot is lisper propaganda
19:52:54 <hooloovoo> Too bad we are lazy murderous oppressor robots
19:53:17 <vincenz> I would say rejoice the fact, for it gives us an identity.
19:53:24 <lament> roconnor: have you read 1984?
19:54:32 <roconnor> lament: nope
19:54:39 <dmwit> It is a parody.
19:54:40 <lament> oh
19:54:50 <lament> then you don't really understand the plot
19:55:25 <dolio> It's all about Macintoshes, right?
19:55:41 <dmwit> =)
19:55:54 <vincenz> Apples
19:56:02 <lament> roconnor: they draw a parallel with countries in 1984, which were equally evil and oppressive, and had strong propaganda directed against the other country
19:58:11 <lament> and the cat dies in the end, suggesting side effects might not be that great after all :)
20:01:51 <roconnor> lament: damn it, I only read upto "the end"
20:02:11 <lament> haha
20:03:18 <roconnor> that's the second time I've been caught today.
20:05:58 <roconnor> lament: it seemed like a reasonable place to stop at the time.
20:30:09 <monochrom> I saw "the end" but I also saw the  button. Out of curiosity I continued clicking.
20:31:34 <roconnor> I scrolled down and no longer saw the arrow
20:32:45 <monochrom> The comic was too big. Required much scrolling back and forth.
20:33:15 <monochrom> I wonder why programmers just assume everyone is using 82" HDTVs.
20:33:39 <SamB> because programmers always get the widest possible monitor, so they can fit more code on it?
20:34:18 <monochrom> They certainly always get paid money to keep buying larger screens and more multihead hardware.
20:34:29 <roconnor> If only he had used <LINK REL=next>
20:34:33 <hooloovoo> I <3 my 2x 20" monitors at work
20:34:44 <roconnor> then I would have had the bottons at hand no matter where I scrolled
20:35:30 <roconnor> buttons
20:35:45 <monochrom> I'll try to remember that when it's my turn to make web pages.
20:36:32 <shachaf> roconnor: Where do you get the buttons?
20:36:48 <idnar> what's this?
20:37:00 <SamB> shachaf: magic!
20:37:11 <roconnor> shachaf: I put them next by my toolbar bookmarks.
20:37:19 <roconnor> but they can be moved anywhere
20:37:35 <SamB> roconnor: hmm, do you need an extension for that now?
20:37:39 <shachaf> Which browser?
20:37:42 <roconnor> yep
20:37:53 * shachaf can press space at the end of a page in Opera to go to the next one.
20:37:59 <Jedai> @hoogle monoto
20:38:00 <lambdabot> Data.Set.mapMonotonic :: (a -> b) -> Set a -> Set b
20:38:00 <lambdabot> Data.Map.mapKeysMonotonic :: (k1 -> k2) -> Map k1 a -> Map k2 a
20:38:17 <Jedai> @hoogle map
20:38:17 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
20:38:17 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
20:38:17 <lambdabot> Data.ByteString.map :: (Word8 -> Word8) -> ByteString -> ByteString
20:38:17 <shachaf> (It's sometimes smart enough to figure the next page out even without <link />.)
20:39:01 <dmwit> I use to have an extension for that in FF, but it overloaded other  keys to do the same thing and it got too confusing3.
20:39:17 <dmwit> As you can maybe tell, I sometimes press keys I didn't mean to press. =P
20:39:57 <SamB> dmwit: I do that all the time in screen
20:40:06 <monochrom> "link widgets"?  https://addons.mozilla.org/en-US/firefox/addon/2933 ?
20:40:18 <SamB> today I discovered the silence feature that way
20:40:44 <dmwit> "silence"?
20:41:02 <SamB> yes, it alerts you when nothing happens in a particular window
20:41:14 <dmwit> um
20:41:30 <dmwit> Doesn't that happen kind of often?
20:41:36 <SamB> well, yes ;-)
20:41:53 <idnar> haha
20:41:55 <SamB> that's why it waits until nothing has been happening for a certain amount of time
20:42:14 <monochrom> It solves the quiescence problem!
20:42:33 <SamB> useful for alerting you to when the compile has failed
20:44:05 <shachaf> SamB: What about making the compiler beep when it fails?
20:44:22 <dmwit> compile || beep
20:44:23 <Pseudonym> How about making it insult you, like lambdabot.
20:44:28 <SamB> shachaf: hmm, that would be annoying for local usage
20:44:42 <shachaf> SamB: Then tell screen to show you that. :-)
20:44:47 <SamB> Pseudonym: screen doesn't know how to detect insults, and anyway when JHC fails it's usually not my fault
20:45:04 <Pseudonym> How about then make it insult the JHC developers?
20:45:06 <SamB> shachaf: well, what about when you don't run it in screen?
20:45:17 <SamB> Pseudonym: well, I am one...
20:45:23 <dmwit> You can detect when you're in screen by $TERM.
20:45:33 <Pseudonym> So you get two features and only have to implement one!
20:45:37 <shachaf> SamB: Then screen's silence feature won't help you. :-)
20:45:52 <shachaf> SamB: (You can run it as compile || beep, I mean.)
20:45:52 <dmwit> Plenty of .zshrc's do just such a thing to create different aliases in screen and in local usage.
20:45:57 <shachaf> Huh, dmwit said that already.
20:45:58 <SamB> shachaf: true, but it also wouldn't beep at me
20:46:28 <monochrom> "Expected type does not match inferred type.  You code like a Monte Carlo simulation."
20:47:03 <SamB> for me, the expected case is for JHC to fail
20:47:21 <shachaf> SamB: I don't mean making JHC itself beep.
20:47:29 <SamB> because I'm generally trying to make it do things it couldn't do before
20:47:29 <shachaf> SamB: But doing that as part of your compilation.
20:47:34 <SamB> shachaf: oh. I see.
20:47:37 <SamB> that would indeed work
20:48:52 <SamB> 'twould work better if I used the BASIC shell, I think
20:49:35 <SamB> hmm, also if screen did something for me when a beep was sent...
20:50:40 <shachaf> The BASIC shell?
20:51:04 <SamB> wait, I'm using the wrong character code ... \b is backspace...
20:51:18 <shachaf> \a?
20:51:37 <SamB> yes, I see that in the manpage
20:51:51 <SamB> well, it does tell me that a bell has been sounded in window 1
20:52:41 <SamB> or if I'm in window 1 it will either blink the screen or beep
20:52:57 <SamB> but the screen flash is barely visible...
20:53:19 <dmwit> You could aplay  something.
20:53:41 <dmwit> Although I guess that's not as useful remotely.
20:53:48 <shachaf> SamB: You can set the flash duration, can't you?
20:54:18 <shachaf> Or make it print a message in the status bar.
20:54:27 <SamB> shachaf: how?
20:54:41 <shachaf> :set vbell_msg, I think.
20:55:02 <gwern> @seen shapr
20:55:02 <lambdabot> shapr is in #haskell-blah, #scannedinavian and #haskell. I last heard shapr speak 1h 25m 28s ago.
20:55:30 <SamB> hmm, it doesn't do that unless your terminal doesn't support a visual bell
20:56:23 * shachaf isn't sure how you havre things set up anymore. :-)
21:00:43 <gwern> 'This Comic has been Interpreted...
21:00:44 <gwern> ...as more critical of Haskell than I intended- The Lisp guys in the cartoon are pretty bumbling and their offhanded complaints of "why box yourself in with Haskell" isn't really a meaningful critique of Haskell. Note that they are responsible for creating a propaganda movie of Haskell and that their use of unsafe coding techniques apparently killed the cat at the end of the cartoon :)
21:00:50 <gwern> A serious critique of the Monadic approach of Haskell is possible but I agree my comic doesn't contain it.
21:01:24 <dons> yeah, i read it as way more positive
21:01:27 <Pseudonym> Geez, it's a sorry day when you have to explain yourself like that.
21:01:31 <dons> the lisp guys were bumbling and silly :)
21:01:39 <dons> and lived in the south..
21:01:44 <shachaf> LISP guys often are. :-)
21:01:53 <shachaf> (As are Haskellers, of course.)
21:01:59 <Pseudonym> Lots of planets have a South.
21:02:12 <Pseudonym> But yeah, most Haskellers live in Europe.
21:02:17 <dons> see also http://www.lisperati.com/haskell/
21:02:29 <dons> for related works, including lolbotz
21:03:09 <Cale> Also, Lisp was responsible for deforestation
21:03:20 <dons> gwern: where's that from?
21:03:29 <SamB> Cale: you know, that sounds horrible out of context...
21:03:52 <Pseudonym> Someone call Al Gore.
21:04:22 <SamB> so what lisp had deforestation?
21:06:23 <dons> i note my xmonad apr1 joke fell a bit flat. we had a fun time in #xmonad though
21:06:34 * dons should remember not to write these things past midnight
21:06:46 <SamB> what was the joke?
21:07:12 <Nafai> I thought it was funny
21:07:13 <dons> "<monochrom> Gosh, that xmonad press release attains a new level of hogwash"
21:07:27 <dons> "<roconnor> wow, the PR machine for xmonad is really at work with thier latest press release"
21:07:29 <Nafai> I'm trying to convince someone in another channel to use xmonad :)
21:07:37 <dons> Nafai: thanks :)
21:07:59 <SamB> indeed he is
21:08:20 <Saizan_> aaa
21:08:22 <monochrom> dons: I did not know it was April Fool's joke. I forgot April 1 altogether. Please do not be deterred.
21:08:22 <SamB> someone is calling you a nutcase
21:08:29 <dons> monochrom: did you miss the joke, or just thought it was bad :)
21:08:35 <dons> ah ok, so just thought i'd gone insane
21:08:36 <dons> that's fine.
21:09:00 <dons> SamB: logs?
21:09:23 <SamB> I dunno if there are any?
21:09:38 <dons> shrug
21:09:40 <SamB> Nafai: do you know? radix?
21:10:48 <Nafai> Not public, that I know of
21:11:16 <dons> monochrom: you didn't suspect for a moment, "the desktop metaphor for user interaction is replaced by a more efficient "Rubik's cube" model of window/workspace arrangment." ?
21:11:59 <monochrom> I only read the excerpt from roconnor. It didn't contain that.
21:12:38 <gwern> dons: LtU
21:12:39 <SamB> dons: what, rubik's cube is NOT more efficient than desktop?
21:12:53 <dons> yeah, maybe it is!
21:13:07 <dons> sounds like it might be a bit slow to get windows into the arrangment you want
21:13:10 <dolio> Sounds like something that'd be in compiz.
21:13:10 <dons> unless you get good at it
21:13:15 <SamB> not so much if you start TWISTING, I guess
21:13:17 <gwern> a rubik's cube would be an awful lot of workspaces
21:13:29 <dons> not that many..
21:13:38 <Cale> Heh, I was just thinking xmonad should incorporate 3D like compiz so you can do that ;)
21:13:39 * shachaf has 13 workspaces.
21:13:40 <SamB> dons: he's thinking 6*9
21:13:52 <shachaf> Earlier today all of them were full. :-)
21:14:18 <SamB> Cale: you want ... a tiling composite manager?
21:14:18 <roconnor> dons: I only read upto the point I quoted, and gave up in disgust. :)
21:14:22 <Cale> Heh, one workspace for each permutation of the Rubik's cube would be fun :)
21:14:32 <dons> roconnor: oh dear.
21:14:51 <dons> advertising speak is a subtle language
21:15:17 <monochrom> Corporate hogwash is great for April Fool's jokes.
21:15:31 <shachaf> SamB: Oh, do you use xmonad?
21:15:40 <shachaf> SamB: You can make things work nicely with beeps.
21:15:54 <SamB> beeps?
21:16:01 <mauke> where is this announcement?
21:16:11 <SamB> apparantly I have to go to bed now
21:16:15 <SamB> byes!
21:16:18 <monochrom> xmonad home page
21:16:20 <dobblego> apparently
21:16:38 <dons> http://xmonad.org/news.html#6
21:16:39 <lambdabot> Title: xmonad : news
21:16:43 <shachaf> SamB: I mean, for compilation.
21:24:01 <Twey> :t read
21:24:04 <lambdabot> forall a. (Read a) => String -> a
21:35:01 <cjs> Hey, where would one download ghc 6.8.2 for Windows?
21:35:01 <lambdabot> cjs: You have 1 new message. '/msg lambdabot @messages' to read it.
21:35:53 <catface> can you do non-monadic IO, like reading from a named file with a maybe result?
21:36:31 <Cale> catface: Uh, you'd still use the IO monad for that...
21:36:36 <Mephisto-kun> catface: Maybe is a monad... ;)
21:36:44 <Cale> catface: You'd just additionally have the Maybe monad there...
21:37:29 <gwern> @hoogle Int -> Fd
21:37:29 <lambdabot> No matches, try a more general search
21:37:40 <Mephisto-kun> So, like Churchill's remark, you'd wind up using two monads, trying to avoid using one. :)
21:38:11 <catface> ok, what if you want a plain string
21:38:44 <Cale> catface: Note that any computation which extracts the contents of a file must involve the IO monad, because it might produce a different result every time.
21:39:17 <catface> mmm good point
21:39:18 <Jedai> catface: You can't do IO outside of the IO monad, that's the whole point of the IO monad, restricting side-effect to a well delimited part of the program
21:39:19 <Cale> If the computation were just a String for instance, it would always be the same string.
21:39:19 <cjs> catface: the point of Monadic I/O is to be able to say in what sequence you want the I/O to be done, e.g., read from the file then do some calculation, as opposed to, say, doing the calculation first and then reading from the file. When you think about it that way, perhaps you can see that non-monadic I/O doesn't make sense.
21:39:50 <Cale> catface: What you *can* do, is write an IO action which reads from a file, and passes the resulting string off to some pure code which uses it.
21:40:09 <Cale> catface: and then, say, gets back some result and prints it on the screen
21:40:40 <Cale> catface: So your pure function which depends on the contents of that file can just take a String as a parameter.
21:44:25 <Cale> catface: Of course, if you want to discuss alternate systems altogether for handling I/O in a pure language, there are lots of other options. In fact, any sort of combinator library would do -- the fact that IO is a monad is really inessential.
21:44:57 <Cale> But in order to keep things straight, you really want the types to inform you when it is that things depend on the world and when they don't.
21:46:32 <catface> thanks
21:47:07 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO -- I have a short tutorial here you might be interested in, if you're starting out with IO in Haskell.
21:47:07 <lambdabot> Title: Introduction to IO - HaskellWiki
21:47:37 <Cale> It doesn't really get into the details of what actions are available, just the overall plan of how you join them together.
21:59:38 <monochrom> Cale: idea for lambdabot's @slap command: splits object into two parts by Tarski-Banach and re-assembles to get two replicas of object.
22:00:43 <Cale> *cough* a finite number  ;)
22:01:02 <monochrom> Oops.  s/two/several/
22:04:02 <Cale> there we go :)
22:04:10 <Cale> oh, gone
22:05:55 <vegai> dons: hey, found a teeny problem in lambdabot
22:06:03 <Cale> vegai: what is it?
22:06:09 <vegai> http://hpaste.org/6769
22:06:34 <vegai> the hardcoded "@" there causes lambdabot to fail at start if "@" is not in the list of commandPrefixes
22:06:47 <Cale> okay
22:07:06 <Cale> I suppose we can replace it with the head of the commandPrefixes list...
22:11:06 <vegai> ok, if that's enough... I can send a patch
22:11:16 <Cale> I've just done it :)
22:11:23 <Cale> Let me rebuild
22:11:29 <vegai> right, yeah. It was kinda trivial :)
22:12:20 <Cale> I've sort of gotten stuck maintaining lambdabot despite not knowing how most of the stuff in it works. :)
22:12:51 <Cale> However, it does mean that I can use it as a platform for library change propaganda ;)
22:12:54 <Cale> :t (++)
22:12:55 <lambdabot> forall m. (Monoid m) => m -> m -> m
22:13:49 <dons> Cale serves at the pleasure of lambdabot
22:13:56 <vegai> :)
22:14:17 <Trinithis> anyone know what snoc lists are?
22:14:18 <dons> Cale, you clearly deserve the job, http://www.cse.unsw.edu.au/~dons/irc/haskell-08.html
22:14:19 <lambdabot> Title: #haskell @ freenode.org stats by dons
22:14:27 <dons> Trinithis: yeah, see the 'dlist' package on hackage.
22:14:31 <dons> it has a nice description
22:14:40 <mauke> data Tsil a = Snoc (Tils a) a | Lin
22:15:24 <dons> oh, that kind of snoc list
22:15:31 <Trinithis> dons: link?
22:15:35 <dons> ?hackage dlist
22:15:35 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist
22:15:40 <vegai> "dons is a very aggressive person. He/She attacked others 10 times."
22:15:40 <dons> is a list type supporting efficient snoc
22:15:50 * dons smacks vegai 
22:15:55 <vegai> yeach! 11
22:16:00 <Trinithis> snoc meaning...
22:16:06 <dons> vegai++ arch!
22:16:12 <dons> Trinithis: cons backwards
22:16:16 <Trinithis> o
22:16:26 <dons> )
22:16:29 <dons> :)
22:16:35 <Trinithis> quite punny
22:20:39 <Cale> hmm, I suppose I should push all these changes back into the main \b repo now :)
22:26:06 <Cale> uhh...
22:26:40 <Cale> How can there be conflicts when I try to push if there are no remote changes to pull in?
22:27:42 <dons> darcs bug maybe.
22:27:49 <Lycurgus> get a production quality source control system maybe
22:27:50 <dons> darcs whatsnew in the central repo?
22:27:58 <dons> sigh
22:28:13 <Cale> No changes!
22:28:17 <dons> not helpful, Lycurgus, unless you've helped improve darcs.
22:28:28 <dons> darcs pull ?
22:28:38 <Lycurgus> there doesn't seem to be anything for it
22:28:41 <Cale> Pulling from "/srv/code/lambdabot/"...
22:28:41 <Cale> No remote changes to pull in!
22:28:56 <Cale> Maybe I should try pulling the other way.
22:28:57 <Lycurgus> they seem to be bent on ignoring this obvious requirement
22:29:01 <dons> should be fine then, Cale. try pushing to a copy local.
22:29:19 <Lycurgus> (i.e. that a source control system must be "rock solid")
22:29:27 <dons> Lycurgus: wrong channel, try #darcs
22:29:51 <Lycurgus> I raised the point 2 years ago (in #darcs and here) and it obviously hasn't gone away.
22:30:05 <dons> are you looking to fix it in here now?
22:30:36 <Lycurgus> only by suggesting that people use another till they fix darcs
22:30:44 <dons> ok, so just carping from the sidelines.
22:30:46 <Lycurgus> except where necessary
22:31:16 <Lycurgus> that's my policy/strategy for conserving resources while doing the right think
22:31:19 <Lycurgus> *thing
22:31:23 <Cale> That's rather strange. The conflict (upon just doing the pull from my own repo to the central one and resolving conflicts by hand), the conflict seemed to consist of duplicating a large section of the file...
22:31:44 <Cale> That is, it looked something like:
22:31:44 <Cale> a
22:31:45 <Cale> b
22:31:46 <Cale> c
22:31:52 <Cale> v v v v
22:31:53 <Cale> a
22:31:54 <Cale> b
22:31:55 <Cale> c
22:32:00 <Cale> ^ ^ ^ ^
22:32:06 <dons> oh, so maybe a funny merge
22:32:14 <dons> i've never seen that
22:32:21 <dons> whitespace ?
22:32:26 <Cale> I'm not sure.
22:32:34 <Cale> Maybe. It's resolved now anyway.
22:32:56 <dons> lambdabot's getting quite a big repo. some 6 years of dev now
22:32:59 <Cale> hmm
22:33:31 <Cale> When I try to do a record now, after resolving that conflict, it says "No changes!"
22:33:52 <Cale> I should definitely try pulling this into a new repo and making sure it works :)
22:33:59 <dons> yep
22:34:08 <Cale> darcs check reports that everything's okay, at least
22:34:47 <sjanssen> Cale: sounds like two patches made the exact same change?
22:34:58 <Cale> sjanssen: that seems likely, actually.
22:35:11 <sjanssen> darcs treats this as a conflict
22:35:20 <dons> ah ha, yes.
22:35:42 <dons> you resolved it, so now are likely good to go
22:35:53 <dons> so false alarm -- darcs worked as intended, i think
22:36:43 <mcnster> @seen dcoutts_
22:36:43 <lambdabot> dcoutts_ is in #ghc, #haskell-overflow, #haskell, #gentoo-haskell and #haskell-soc. I don't know when dcoutts_ last spoke.
22:37:18 <Cale> @slap Cale
22:37:25 * lambdabot smacks Cale about with a large trout
22:37:45 <Cale> heh, I suppose it'll take a bunch of slapping before we see the new addition
22:37:57 <mcnster> :)
22:38:31 <mcnster> @help
22:38:34 <BMeph> s/addition/adiction/ ;)
22:38:35 <Trinithis> Cale: what did you add? new slapping toys?
22:38:37 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:38:47 <mcnster> @list
22:38:49 <Cale> Trinithis: just one, suggested by monochrom
22:38:52 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
22:38:55 <BMeph> Eraddiction* ;p
22:39:09 <BMeph> Bah! Addiction* ;p
22:40:25 <Cale> dons: did you hear about the good news regarding lambdabot's status on the network?
22:40:37 <Cale> dons: It can now join infinitely many channels :)
22:47:46 <Twey> I did
22:47:58 <Twey> We got her to join #gurgling :-D
22:48:34 <roconnor> @seen lambdabot
22:48:34 <lambdabot> Yes, I'm here. I'm in #gentoo-uy, #friendly-coders, #dreamlinux-es, #thunks, #haskell-hac07, #haskell_ru, #haskell.dut, #haskell.de, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #
22:48:34 <lambdabot> haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell-books, #rosettacode, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #jtiger, #haskell-soc, #haskell-
22:48:34 <lambdabot> overflow, #haskell-blah, #scala, #darcs, #jhc, #ghc and #haskell
22:48:59 <roconnor> what is rosettacode?
22:49:02 <dons> Cale: oh??
22:49:07 <dons> special concession?
22:49:10 <Cale> yeah
22:49:14 <dons> sweet!
22:49:18 <dons> how'd that get arranged?
22:49:24 <Cale> asked an oper
22:49:30 <dons> good thinking, 99.
22:50:33 <Cale> I think it was shachaf's idea, unless I have short term memory loss, and stylus was the operator who did it :)
22:51:06 <shachaf> Cale: Yes, I was asking about extending my own channel limit (no luck), and realized that it would be useful for combining the bots.
22:51:27 <dons> so that was considered a persuasive argument?
22:51:35 <dons> even old lisppaste had a limit
22:52:34 <lament> Cale: map joinChannelByName$concat$iterate(\l->concat$map(\a->[x:a|x<-['a'..'z']])l)[""]
22:53:07 <lament> (since we can join an infinite number, might as well prepare an infinite list of them)
22:54:28 <Syzygy-> lament: ...
22:54:46 <Twey> > map (*2) [1..]
22:54:47 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
22:54:51 <Syzygy-> Do we really want to CREATE infinitely many channels on the server just because the opers were good to us?
22:55:07 <lament> of course. We'll just do it lazily!
22:55:10 <Deewiant> Syzygy-: it was a map, not mapM, so it doesn't /do/ anything, yet. ;-)
22:55:13 <Twey> Heheh
22:56:00 <Syzygy-> Deewiant: There is that...
22:56:02 <quicksilver> we should submit a patch to ChanServ so that if some says in a channel "I wish we had a lambdabot", one joins :)
22:56:22 <Syzygy-> o.O
22:56:26 <Syzygy-> Yeah
22:56:48 <Syzygy-> shachaf++ -- lambdabot limits
22:56:54 <shachaf> quicksilver: Just let anyone use @join?
22:57:30 <Syzygy-> shachaf: With that anyone can produce the equivalent of mapM ... by @-composition, can't they?
22:58:10 <bd_> quicksilver: Depending on the ircd, messages may not be passed to a server which does not have a user on a given channl
22:58:13 <bd_> channel*
23:04:03 <quicksilver> shachaf: I was joking :)
23:04:20 <quicksilver> bd_: but ChanServ is on every channel which asks for it, at least.
23:04:35 <quicksilver> (every registered channel perhaps?)
23:04:38 <bd_> So they have to ask for chanserv before asking for lambdabot? :)
23:04:41 <shachaf> You should patch the IRC server instead.
23:04:45 <shachaf> quicksilver: No, it's a choice.
23:04:51 <bd_> Just ask for lambdabot directly ;)
23:04:57 <quicksilver> yes. patching the IRC server is a better idea.
23:05:01 <quicksilver> make it AI-complete.
23:05:05 <quicksilver> I want a doughnut!
23:05:10 <quicksilver> With sprinklies!
23:05:16 <shachaf> Make all of lambdabot built into the IRC server!
23:05:22 * shachaf wants lambdabot in his client.
23:05:23 <vegai> Server: No, doughnuts are bad for you.
23:05:39 <bd_> OPER I want a doughnut.
23:05:40 <shachaf> So I can embed things like (@ty ...) in a message.
23:05:54 <Syzygy-> @ty ...
23:05:55 <lambdabot> parse error on input `...'
23:06:02 <Syzygy-> What's @ty?
23:06:12 <Cale> vegai: There's a typo in that message, the comma shouldn't be there. ;)
23:06:13 <idnar> @ty 123
23:06:14 <lambdabot> forall t. (Num t) => t
23:06:20 <Syzygy-> Ahhhhh
23:06:21 <vegai> heh
23:06:47 <Syzygy-> Leaving computer again. *poof*
23:16:01 <[CitationNeeded]> http://sqweek.dnsdojo.org/language-evolution.jpg
23:16:25 <Cale> haha
23:18:16 <Pseudonym> Haskell: (2*)
23:31:05 <adu> ya!
23:36:06 <adu> but actually.... they're wrong
23:36:39 <adu> its <lambda><bvar><ci>x</ci></bvar><apply><times/><cn>2</cn><ci>x</ci></apply></lambda>
23:39:34 <cjs> That's great.
23:40:05 <Korollary> cheap shot
23:40:54 <adu> theres always the thing the subtext guy pointed out:
23:40:56 <adu> http://www.charlespetzold.com/etc/CSAML.html
23:40:56 <lambdabot> Title: C# Application Markup Language (CSAML): A Preview
23:51:02 <lament> > tail$join$iterate(>>=((flip map ['a'..'z']).(flip(:))
23:51:02 <lambdabot> Unbalanced parentheses
23:51:43 <Twey> Is this the new style of programming?
23:51:47 <Twey> Spaceless?  :_P
23:51:58 <lament> > tail$join$iterate(>>=((flip map ['a'..'z']).(flip(:))))[""]
23:51:59 <lambdabot>  ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s"...
23:53:35 * lament is proud :)
23:53:35 <Cale> > [1..] >>= flip replicateM ['a'..'z']
23:53:36 <lambdabot>  ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s"...
23:54:30 <lament> Cale: ahh
23:58:08 <lament> the list monad is such an odd environment to think in
23:58:42 <Cale> It's all about selecting things.
23:59:02 <Cale> Pick a length, pick that many elements of ['a'..'z']
