00:00:07 <cjs_> http://hpaste.org/7090
00:00:44 <cjs_> The weird thing is, if I reduce that to just the if, and call it with "processLoop bs processors `finally` (sequence_ ...", it works ok.
00:01:00 <cjs_> Oh, crap. "do".
00:02:18 <cjs_> mmm, no, that's not it.
00:03:23 <sjanssen> cjs_: you recursively call processLoop
00:03:45 <cjs_> Oh, duh.
00:06:36 <takamu> hi
00:16:18 <cjs_> Darn, this protocol is a pain.
00:17:02 <cjs_> So I finally get my reader thread reading nicely from an infinite bytestream, but when I close the socket on my end, my program always prints "testconnect: <socket: 3>: hLookAhead: invalid argument (Bad file descriptor)".
00:20:19 <quicksilver> infinite bytestream as in lazy IO?
00:20:46 <quicksilver> because, if so, lazy IO is incompatible with sensible handling of exceptions.
00:20:57 <cjs_> Yes, lazy IO.
00:21:00 <cjs_> Is it? Crap.
00:21:16 <quicksilver> lazy IO is harmful.
00:21:35 <quicksilver> But seriously, it is too abstract.
00:21:38 <cjs_> So why does Data.Binary use it?
00:21:57 <quicksilver> lazyIO abstracts to an infinite stream.
00:22:07 <quicksilver> and infinite (pure) streams don't have exceptions, they're too simple.
00:22:09 <quicksilver> it's the price you pay.
00:22:17 <quicksilver> Data.Binary doesn't use lazy IO.
00:22:27 <quicksilver> Data.Binary uses bytestrings. How you obtain the bytestring is your business.
00:22:37 <cjs_> Hm. I thought it used Data.ByteString.Lazy.
00:22:49 <quicksilver> it does.
00:23:04 <quicksilver> Data.ByteString.Lazy is not lazy io by definition.
00:23:19 <cjs_> Hm. It's just because I'm using hGetContents?
00:23:21 <quicksilver> It contains a few misguided broken primitives which happen to use lazy IO.
00:23:22 <quicksilver> right.
00:23:55 <quicksilver> I should point out for context that I'm well known to being ridiculously negative about lazy IO.
00:24:03 <quicksilver> dons and dcoutts___ would give you a more balanced picture, say.
00:24:30 <cjs_> So I ought to be using, hmm... what? I'm reading items consisting of an Int16LE length followed by that many bytes - 2 of data.
00:24:56 <cjs_> And I expect to be processing something on the order of 5000 of the messages per second, at times.
00:28:50 <quicksilver> On the other hand, this is a pretty good example of one of the reasons it is harmful, inability to catch IO exceptions.
00:30:01 <quicksilver> I'd read those bytes explicitly (strictly) personally.
00:30:21 <quicksilver> unless you don't expect them to fit into memory.
00:32:12 <cjs_> The problem is, if I do a strict read, I can't use Data.Binary, can I?
00:32:16 <takamu> is there some blog or web page about this weekend hackathon?
00:32:20 <quicksilver> sure you can.
00:32:24 <cjs_> Or can I?
00:32:29 <quicksilver> I'm just talking about using hGet instead of hGetContents
00:32:41 <bd_> cjs_: you can turn a strict bytestring into a lazy bytestring
00:32:48 <quicksilver> then you pass that to Data.Binary as before.
00:32:54 <bd_> @hoogle Data.Bytestring.Bytestring -> Data.Bytestring.Lazy.Bytestring
00:32:55 <lambdabot> No matches, try a more general search
00:32:58 <bd_> hmmm
00:33:00 <cjs_> The problem is, it's the get I wrote that knows how much to read.
00:33:02 <quicksilver> bd_: you can, but you don't need to.
00:33:25 <cjs_> Given a handle, I cannot tell how much to read until I read the next two bytes.
00:33:36 <quicksilver> cjs_: yeah, you might want to do that bit yourself at the 'top-level'
00:33:58 <cjs_> I used to do that. But then don't I lose a lot of the efficiency of the whole Data.Binary model?
00:34:30 <quicksilver> I don't think so.
00:35:01 <quicksilver> I don't see how you can avoid this, really. If you want sensible IO error reporting, then you have to do the IO in the IO loop
00:35:05 <quicksilver> IYSWIM.
00:35:37 <quicksilver> I don't think it's an efficiency issue unless the expected packet size will exceed your memory
00:35:44 <quicksilver> in which case you will need to do something more sophisticated.
00:36:44 <bd_> quicksilver: the IO exception will propagate back down into IO, won't it?
00:36:55 <bd_> even with unsafeInterleaveIO in there for the lazy read
00:37:06 <quicksilver> bd_: yes, but not in a conveninet way
00:37:20 <cjs_> No, the packets are quite small: generally 50-100 bytes; never larger than 64K.
00:37:40 <quicksilver> bd_: you will be in an entirely different part of the program when it does.
00:37:56 <ketil> cjs_: I'm happy with lazy IO.  But I use it (readFile/hGetContents) in the context where I want to stream in the contents of a file, and not do anything else with the file afterwards.
00:38:00 <quicksilver> and quite unable to work out what raised the exception and why.
00:38:11 <quicksilver> ketil: this is a different issue.
00:38:14 <bd_> quicksilver: not if you force the data you're reading
00:38:27 <quicksilver> ketil: this is the problem that you are actually expecting an exception.
00:38:33 <quicksilver> bd_: in which case there is no point using lazy IO :P
00:38:48 <bd_> quicksilver: sure there is - it means you don't have to worry about computing the size of the structure
00:38:51 <quicksilver> ketil: (that is, eventually you expect to get an exception)
00:38:56 <ketil> quicksilver, okay.  (You wanted a balanced view about lazy/strict IO earlier on.)
00:39:32 <quicksilver> ;)
00:39:36 <ketil> When it comes to exceptions, I subscribe to the "let it crash" viewpoint.
00:39:50 <ketil> I.e. when it comes to exception handling, I don't.
00:39:52 <ketil> :-)
00:40:14 <quicksilver> which is perfectly sensible for a large class of programs
00:40:22 <quicksilver> like your classic simple shell utilities.
00:40:23 <cjs_> Oh, well my input is actually call coming through one set of functions, so it's not really a problem in that way. The lazy ByteString is just turned straight into a lazy list of messages.
00:41:05 <cjs_> Not so good for me; I may have open orders on the market at the time of, say, losing my connection.
00:41:10 <quicksilver> right.
00:41:24 <quicksilver> I would never use lazy IO anywhere in any program which involved money.
00:41:45 <bd_> right, if you force the list pair and catch any exception, you /should/ be able to detect an IO error
00:41:48 <bd_> in theory
00:42:02 <quicksilver> it's like deciding to drive in a safe car because you have precious cargo and then strapping live grenades to all the windows and holding one in your teeth.
00:42:39 <quicksilver> the *point* of using haskell in important programs is its well defined semantics. lazy IO ruins everthing.
00:44:45 <cjs_> Anyway, so what's the most efficient way of doing strict I/O?
00:45:27 <quicksilver> I would think hGet in bytestring.laz is pretty good.
00:49:48 <cjs_> I was under the impression that stringing all those Data.Binary.Gets together would be faster, but perhaps I'm wrong.
00:51:59 <paolino> @babel live grenade
00:51:59 <lambdabot>   bzzt.
00:56:51 <dmwit> ?babel en es live grenade
00:56:52 <lambdabot>   granada viva
00:57:50 <paolino> ?babel en it live grenade
00:57:50 <lambdabot>   granata in tensione
00:58:16 <mauke> @babel en de live grenade
00:58:25 <lambdabot>   Phasengranate
00:58:28 <mauke> haha
00:59:49 <paolino> mah, never heard "granata in tensione" before
01:00:06 <gnut> does anyone here have darcs 2.0.0 running?
01:00:28 <gnut> I was able to compile the code, but running darcs add crashes.
01:00:54 <adiM> @pl l x = length x - 1
01:00:55 <lambdabot> l = subtract 1 . length
01:06:54 <Cale> I do.
01:07:56 <Cale> darcs add seems to work for me
01:08:22 <Cale> Erm, oh, I have 2.0.0pre3 actually
01:09:11 <gnut> Cale: but you also perhaps have a working version :)
01:09:15 <gnut> I'm running on solaris x86
01:09:49 <Cale> I'm on Ubuntu x86
01:09:59 <gnut> it compiles fine, i can run "darcs initialize" fine... just the add part gives me error
01:10:17 <Cale> What error?
01:10:25 <adiM> @pl   quantize x values = snd $last $ zip (takeWhile (x>=) values) [0..]
01:10:25 <lambdabot> quantize = ((snd . last) .) . flip flip [0..] . (zip .) . takeWhile . (>=)
01:10:25 <gnut> let me copy it here
01:10:36 <adiM> @pl   quantize values x = snd $last $ zip (takeWhile (x>=) values) [0..]
01:10:36 <lambdabot> quantize = ((snd . last) .) . flip flip [0..] . (zip .) . flip (takeWhile . (>=))
01:10:51 <adiM> @pl   quantize values  = snd $last $ zip (takeWhile (x>=) values) [0..]
01:10:51 <lambdabot> quantize = snd . last . flip zip [0..] . takeWhile (x >=)
01:10:54 <Cale> (not that I'm likely to be able to interpret it)
01:11:41 <adiM> @pl   quantize values  = fst $last $ zip [0..] (takeWhile (x>=) values)
01:11:41 <lambdabot> quantize = fst . last . zip [0..] . takeWhile (x >=)
01:12:00 <adiM> @pl   quantize x values  = fst $last $ zip [0..] (takeWhile (x>=) values)
01:12:00 <lambdabot> quantize = ((fst . last . zip [0..]) .) . takeWhile . (>=)
01:14:22 <gnut> ./darcs add aclocal.m4
01:14:22 <gnut> darcs: bug in darcs!
01:14:22 <gnut> fromJust errorsrc/Darcs/SlurpDirectory.lhs:347 compiled Apr 21 2008 01:11:30 at src/Darcs/SlurpDirectory.lhs:347 compiled Apr 21 2008 01:11:30
01:14:22 <gnut> I'm unable to check http://darcs.net/maintenance to see if this version is supported.
01:14:22 <gnut> If it is is supported, please report this to bugs@darcs.net
01:14:24 <gnut> If possible include the output of 'darcs --exact-version'.
01:15:40 <gnut> Cale: that's the error. the --exact-version says unknown, but it gives the compile time.
01:16:53 <Cale> gnut: that's similar to what I get from darcs --exact-version
01:17:33 <gnut> actually, i get this error for darcs whatsnew, changes, or pretty much anything that queries the _darcs folder?
01:17:45 <Cale> and my darcs --version gives  "2.0.0pre3 (unknown)" -- though I'm rebuilding the actual release of darcs now
01:17:51 <Cale> hmm
01:18:00 <mux_> that'll teach them to use fromJust ;-)
01:18:32 <Cale> I suppose we could look at that code.
01:18:43 <gnut> my darcs --version gives 2.0.0 (unknown)
01:19:25 <Jaak> works for me (tm)
01:19:32 <Jaak> (gentoo, 64bit, 2.0.0)
01:20:12 <Jaak> built with ghc 6.8.2
01:20:23 * Jaak is off now
01:21:10 <gnut> solaris x86, 32bit, 2.0.0, ghc 6.8.2, gcc 3.4.5
01:21:41 <Cale> Did you build that darcs yourself or did you get a binary from somewhere?
01:22:41 <Cale> There is indeed a fromJust on that line of SlurpDirectory.lhs
01:22:59 <gnut> i built it myself
01:23:22 <gnut> i have darcs 1.0.9 which i got from the darcs page, but 2.0.0 i'm building... again :)
01:24:12 <gnut> make check shows a bunch of FAILED
01:27:43 <Baughn> > let loop = loop in 1: loop
01:27:46 <Cale> gnut: I wonder what the most useful thing you could report would be...
01:27:58 <lambdabot>  thread killed
01:28:18 <Baughn> Cale: So, as I was saying, there's a patch at http://brage.info/~svein/cale now that will fix that.
01:28:32 <Cale> Okay, I'll try that :)
01:28:42 <gnut> hmmm
01:29:01 <Baughn> Cale: And you might try screen-away.pl or something so you get notified of messages when you've been away
01:29:34 <Cale> Baughn: actually, I'm pretty sure I've applied that...
01:30:17 <Baughn> > let loop = loop in 1: loop -- Nope, not all of them
01:30:22 <Cale> darcs reports that all the patches have already been applied
01:30:27 <Baughn> ..huh
01:30:32 <lambdabot>  thread killed
01:30:32 <Baughn> Maybe need to rebuild lb?
01:30:36 <Cale> I'll rebuild and see if anything changes.
01:32:20 <Cale> gnut: Perhaps put the output from make check in a message along with your system information and send something to the darcs mailing list.
01:32:28 <gnut> ok
01:33:24 <Cale> gnut: The fact that it's the fromJust on line 347 of SlurpDirectory.lhs will also probably be useful.
01:33:37 <Cale> But I'm not sure exactly what that code does.
01:35:06 <Cale> It does seem kind of silly that genslurp_helper gives an IO action producing a Maybe Slurpy, and then genslurp immediately applies fromJust
01:36:57 <Cale> The case that it returns Nothing is when some file (whose name is an input) is neither a regular file, nor is it a directory or (a symbolic link when some other directory name is ".")
01:37:54 <Cale> lambdabot: @quit
01:38:14 <Baughn> > let loop = loop in 1: loop -- Nope, not all of them
01:38:15 <Cale> > let loop = loop in 1: loop
01:38:34 <lambdabot>  thread killed
01:38:40 <lambdabot>  thread killed
01:38:58 <Baughn> I don't suppose claiming that it works here would help?
01:39:14 <Cale> Well, runplugs emits [1 and then loops at least.
01:40:03 <Baughn> That's how it's supposed to work. I wonder if there's something different in the environment..
01:40:30 <Cale> lambdabot> > let loop = loop in 1: loop
01:40:30 <Cale> lambdabot>  thread killed
01:40:38 <Cale> same thing happens in local mode
01:41:01 <Baughn> ..hang on
01:41:14 <Baughn> What does "grep -r "thread killed" lambdabot-source/" say for you?
01:41:37 <Baughn> There's no output here - it's not mentioned once - but /something/ is printing it, so..
01:42:35 <Cale> Well, every binary matches. I bet it's a GHC runtime thing.
01:42:51 <gnut> Cale: thanks. i'll send out the message... going to bed.
01:43:15 <Baughn> > let x=x in x
01:43:30 <lambdabot>  thread killed
01:43:42 <Baughn> Cale: This might be a.. are you compiling with -threaded?
01:44:38 <Cale> I think so.
01:44:44 <Cale> It's in the .cabal file at least.
01:44:54 <dmwit> Didn't dons tackle this problem a while ago?
01:45:00 <dmwit> Did he ever find out what was happening?
01:45:08 <Baughn> Cale: And runplugs does print "exception: <<loop>>"?
01:45:16 <Cale> no.
01:45:24 <Baughn> ..then it's not being compiled with -threaded.
01:45:43 <Baughn> Or it's being ignored, or /something/
01:46:15 <Cale> oh, runplugs isn't being compiled with -threaded
01:46:15 <Cale> lambdabot is though
01:46:33 <Baughn> The deadlock detection needs to be in effect in runplugs, though. ;)
01:46:58 <Baughn> ..still, that makes me wonder why it's working here. Everything being compiled threaded unconditionally?
01:49:48 <Baughn> ..
01:50:56 <Baughn> Or that might cause everything to break. This is extremely confusing.
01:51:09 <Cale> Okay, compiling with -threaded does nothing. It still doesn't detect loops.
01:51:49 <Baughn> Cale: I just realized
01:51:57 <Cale> Oh, perhaps RunPlugs should be compiling the program it creates with -threaded?
01:52:02 <Baughn> Cale: I've got a patch applied to ghc that fixes this. You don't. ^_^
01:52:10 <Cale> ah
01:52:21 <Baughn> Cale: The xcpu handler breaks deadlock detection, otherwise
01:54:04 <Cale> All right then. I'll upgrade when a new GHC comes out and that should fix it :)
01:54:24 <Baughn> Ah, now you're assuming I'll finish a patch in time for it to make it into that ghc
01:54:36 <Baughn> ..let's hope so.
02:17:06 <dcoutts_> ketil: pong
02:17:35 <dcoutts_> @seen ketil
02:17:35 <lambdabot> ketil is in #haskell. I don't know when ketil last spoke.
02:38:48 <BattlePope|Uni> pretty extreme
02:39:54 <anon> ok
02:41:00 <overflow> AHHHHHHHHhhh
02:41:14 <aaaaaaaaaaaaaaaa> wut
02:41:19 <quicksilver> ?
02:41:20 <adsasfsgfas> oh good
02:41:31 <adsasfsgfas> :(
02:41:33 --- mode: ChanServ set +o quicksilver
02:41:39 <quicksilver> what's up? is it about haskell?
02:41:41 <adsasfsgfas> can i have ops
02:41:50 <quicksilver> Nope.
02:41:55 <adsasfsgfas> you guys suck
02:42:01 <ejt> heh
02:42:10 <quicksilver> Ok, who votes I report him to his director of studies?
02:42:18 <quicksilver> university login IDs are traceable.
02:42:21 <quicksilver> ;P
02:49:52 --- mode: quicksilver set -o quicksilver
03:37:25 <Bonus> say you have
03:37:52 <Bonus> [[(0,1),(0,3),(0,4)],[(1,2),(1,8)]]
03:38:01 <Bonus> how do you go about converting that to just
03:38:09 <Bonus> [[1,3,4],[2,8]]
03:38:19 <Japsu> > map (map snd) [[(0,1),(0,3),(0,4)],[(1,2),(1,8)]]
03:38:19 <Bonus> like in the most elegant way
03:38:23 <lambdabot>  [[1,3,4],[2,8]]
03:38:24 <Bonus> yeah thats what i did
03:38:33 <Bonus> i did (map . map) snd the_list
03:38:56 <Bonus> > (map . map) snd [[(0,1),(0,3),(0,4)],[(1,2),(1,8)]]
03:38:57 <lambdabot>  [[1,3,4],[2,8]]
03:38:59 <Bonus> kewl
03:53:47 <Bonus> hGetLines handle = hGetContents handle >>= return . lines
03:53:51 <Bonus> hmmm is that generally ok?
03:54:00 <Bonus> for getting the lines in a file into a list?
03:54:38 <mauke> hGetLines = liftM lines . hGetContents
03:56:14 <sjanssen> s/liftM/fmap
03:56:33 <Bonus> what does fmap do
03:57:03 <sjanssen> it is equivalent to liftM here -- I just object to liftM's existence on moral grounds :)
03:57:10 <Bonus> haha
03:57:14 <funktio> s#s/liftM/fmap#s/liftM/fmap/#
03:57:49 <funktio> meta-regex, final "/" was missing :P
03:58:25 * sjanssen doesn't care at all
03:58:26 <xerox> s/fmap/\./  :)
03:58:35 <sjanssen> xerox: heathen
03:58:55 <chr1s> .sp
03:59:14 <chr1s> disregard that ;)
04:00:08 <xerox> We run ghci -fno-implicit-prelude -fheathenry
04:00:10 <mauke> funktio: the final / is optional in vim
04:00:20 <quicksilver> lines <$> hGetContents handle
04:00:26 <quicksilver> is much more leet.
04:00:31 <quicksilver> and easier to read IMO, too
04:00:52 <sjanssen> quicksilver: you lose points for losing Haskell '98 compatiblity
04:00:54 <funktio> mauke: ah, didn't know that
04:02:10 <mauke> liftA lines . hGetContents
04:02:59 <Bonus> are all these methods we listed so far lazy though?
04:03:36 <quicksilver> sjanssen: no, I don't. I just include (<$>) = fmap into my code, with appropriate type sig.
04:03:37 <sjanssen> Bonus: yes
04:03:53 <quicksilver> sjanssen: if h98 compat is an issue.
04:04:50 <ketil> Looks like Haskell is closer to Perl than to Python (more than one way to do it)...
04:06:18 <sjanssen> \h -> case hGetContents h of IO f -> IO $ \s -> case f s of (# s', lines x #) -- best version
04:06:28 <SamB> ketil: python has plenty of ways to do it too
04:06:52 <Bonus> yeah but generally less
04:06:52 <Lycurgus> perl or python, a rock and a hard place
04:06:57 <SamB> probably not as many reasonable ways as in perl
04:07:00 <Bonus> guys
04:07:02 <Bonus> python is awesome
04:07:05 <SamB> but plenty of unreasonable ones
04:07:15 <Bonus> hehe i trust you've seen this http://www.willamette.edu/~fruehr/haskell/evolution.html
04:07:16 <lambdabot> Title: The Evolution of a Haskell Programmer
04:07:16 <Lycurgus> python is lame
04:07:21 <SamB> and typically two or more reasonable ones
04:07:31 <Lycurgus> but not as lame as Ruby
04:07:35 <SamB> haskell is also lame
04:07:54 <Lycurgus> yes but it has redeeming significance
04:08:03 <Bonus> i like it that python has been shifting a lot to lazyness
04:08:13 <SamB> not so lame that it isn't my favorite language so far, but...
04:10:06 <funktio> @pl \x -> map (f . x)
04:10:07 <lambdabot> map . (f .)
04:10:08 <Deewiant> haha http://community.livejournal.com/evan_tech/248736.html
04:10:12 <lambdabot> Title: evan_tech -- distributed bug tracking
04:10:13 <Deewiant> "For whatever reason these all seem to involve the most obscure technologies available: in the above list I see fossil, bazaar, monotone, and even Haskell."
04:10:31 <Deewiant> Shocking! I mean, even /Haskell/ of all things!
04:10:54 <SamB> hooray
04:10:59 <SamB> Haskell is still obscure ;-P
04:11:11 <funktio> @pl \x -> map (f . g x)
04:11:12 <lambdabot> map . (f .) . g
04:11:29 <SamB> we haven't yet failed at our #1 goal
04:11:39 <Lycurgus> yeah to headhunters and the mob of computing dilletantes it's obscure
04:11:46 <Lycurgus> everybody"
04:11:53 <Lycurgus> else knows what it is
04:13:06 <SamB> why nobody told the headhunters?
04:13:32 <SamB> they don't want the headhunters spamming gmane.comp.lang.haskell?
04:14:12 <Deewiant> > let f = (+1); g = (*); in (.) (.) ((f .) . g) 3 [1,2]
04:14:13 <lambdabot>  [4,7]
04:15:22 <Lycurgus> i have a strong memory of being told, c. 1993 that "C was beginning to be used commercially" in an in person interview with an IT recruiter in jersey
04:16:46 <SamB> hahahahaaha
04:17:22 <SamB> beginning, why, I wouldn't be surprised if C usage had almost reached it's decline by that point...
04:17:55 <Lycurgus> well, the C++ transition was getting goint
04:17:58 <Lycurgus> *going
04:18:07 <Bonus> ugh C++ is the worst
04:18:53 <arnar_> wow.. 1993.. that's about the time I started being interested in girls
04:19:02 <arnar_> ;P
04:19:10 <Lycurgus> ML didn't have referential transparency?
04:19:13 * EvilTerran doesn't even remember 1993 specifically
04:19:27 <SamB> incidentally, I was 7 in 1993
04:19:29 <Bonus> i was about 6
04:19:35 <EvilTerran> 4 :P
04:19:42 * arnar_ feels old..
04:19:48 <Lycurgus> (i take it rt = functional purity)
04:19:56 <SamB> well, 6 for more than 2/3s of it
04:20:05 <SamB> Lycurgus: quite so
04:20:09 <EvilTerran> Lycurgus, indeed, ML doesn't enforce purity
04:20:09 <takamu> Is there a simple function to emit a beep from a Haskell program? (I don't want to learn a full-fledged sound library)
04:20:33 <EvilTerran> print ^G to stdout?
04:20:48 <takamu> mm i will try
04:20:52 <SamB> aka '\a'
04:21:29 <Bonus> in conventional languages
04:21:37 <Bonus> does a function have side effects when it changes state
04:21:40 <Bonus> or also when it depends on state
04:22:17 <arnar_> Bonus: it doesn't have side effects if it doesn't change the state.. but if it depends on the state it is not "deterministic"
04:22:19 <takamu> it doesnt work
04:22:26 <Bonus> aha, kewl
04:22:29 <takamu> in ghci nor ghc
04:24:00 <takamu> ah, ok, now i see the problem
04:24:05 <dcoutts> Boney: eg in gcc, they have function attributes you can use to help gcc with optimisation, one is for functions that are totally pure, meaning no side effect and only looking at by-value args (not looking at pointer types) and another for no-side effects but may read memory
04:24:16 <takamu> it works on a tty, but not on a xterm
04:24:32 <takamu> maybe some configuration problem
04:24:38 <takamu> of my terminal
04:24:52 <arnar_> dcoutts: guess you meant "Bonus" :)
04:24:57 <Bonus> haha
04:25:05 <Bonus> interesting
04:25:51 <byorgey> heh, silly tab completion... =)
04:28:26 <dcoutts> arnar_: erm, yes :-)
04:50:39 <bakert> Can anyone give me a simple example of a function (say "f") that calls another function f'?  I'm trying to describe the convention to someone and I need an example ...
04:50:48 <bakert> From the Prelude or something
04:51:02 <mauke> @hoogle '
04:51:02 <lambdabot> Hoogle Error: Parse Error: Unexpected character '''
04:51:12 <bakert> :)
04:51:26 <mauke> f = f'
04:51:33 <bakert> :p
04:52:10 <HairyDude> any agda hackers here?
04:52:52 <Bonus> f k x = k x
04:52:52 <Bonus> ?
04:53:07 <bakert> mauke: would you say that that IS a convention.  that is, where f calls f'.  or would you say it is more normally like foldl' where a different implementation of the same thing?
04:53:07 <Deewiant> f = id
04:53:19 <idnar> bakert: what convention are you referring to, exactly?
04:53:23 <mauke> bakert: no idea
04:53:30 <idnar> bakert: the ' in the name?
04:53:32 <Bonus> bakert: map?
04:53:48 <idnar> @src foldl
04:53:48 <lambdabot> foldl f z []     = z
04:53:48 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
04:53:51 <bakert> idnar: well say i do some "marshalling" in the original function f and then i want to recurse after that
04:53:52 <idnar> bah
04:53:53 <idnar> @src foldr
04:53:54 <lambdabot> foldr f z []     = z
04:53:54 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:53:58 <bakert> i would call the recursing thing f'
04:54:04 <bakert> but perhaps i just made up a bad habit :)
04:54:04 <idnar> I must be thinking of something else
04:54:11 <bakert> f x = f' x + 7
04:54:14 <bakert> f' x = ...
04:54:24 <EvilTerran> idnar, no, foldr/l in @src used to use (l)go
04:54:24 <bakert> but i wanted a real world example
04:54:33 <EvilTerran> but that's an optimisation
04:54:39 <idnar> EvilTerran: ah, ok, so I'm not imagining it
04:54:42 <mauke> let x' = x + n; x'' = f x' - x'
04:54:54 <idnar> I know someone used to complain about showing the definition with that optimization ;)
04:54:57 <idnar> bakert: ah, ok
04:55:12 <bakert> I'm trying to describe this convention, which I may have just made up, to a non-Haskeller
04:55:17 <bakert> and I just wanted a simple example
04:55:21 <bakert> but I can't find one :(
04:55:30 <bakert> you know preferably from real guru code
04:55:33 <bakert> not my random daubings
04:55:44 <Bonus> well map calls a function for every element in a list?
04:55:53 <bakert> but it doesn't use "prime"
04:55:55 <bakert> '
04:55:59 <bakert> which is what i am describing
04:56:03 <Bonus> aha hmm
04:56:06 <bakert> a naming convention like
04:56:09 <bakert> f = ...
04:56:13 <funktio> from Data.List: mergesort cmp = mergesort' cmp . map wrap
04:56:15 <bakert> fProper = ...
04:56:16 <idnar> map doesn't really use a "bootstrap" function
04:56:26 <bakert> funktio: that sounds cool
04:56:31 <bakert> @src mergesort
04:56:32 <lambdabot> Source not found.
04:56:36 <bakert> oh well
04:56:40 <bakert> you gave it to me !!!
04:56:41 <bakert> :)
04:56:43 <bakert> i'll use that
04:56:44 <bakert> thanks
04:56:57 <funktio> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html
04:56:58 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2gpya5
04:56:59 <funktio> np
04:57:49 <funktio> sum is defined similarly
04:58:46 <bakert> @src sum
04:58:46 <lambdabot> sum = foldl (+) 0
04:58:59 <Deewiant> not foldl'? O_o
04:59:03 <bakert> you mean in Data.List
04:59:08 <bakert> ok cool
04:59:11 <bakert> i have written my note
04:59:13 <funktio> yes, there it uses explicit recursion
04:59:14 <bakert> thanks guys
05:01:16 <jaj> Hi! I just wanted to ask if nobody in here has a working port of ghc6.8 for openbsd by chance?
05:08:45 <blarz> jaj: kili@ is working on it AFAIK
05:09:52 <jaj> blarz: great, thank you!
05:10:49 <blarz> jaj: http://marc.info/?l=openbsd-cvs&m=120760091826068&w=2
05:10:51 <lambdabot> Title: 'CVS: cvs.openbsd.org: www' - MARC
05:21:20 <tromp> > > let f = (+1); g = (*); in (.) (.) ((f .) . g) 3 [0..4]
05:21:21 <lambdabot>   parse error on input `>'
05:21:36 <tromp> > let f = (+1); g = (*); in (.) (.) ((f .) . g) 3 [0..4]
05:21:38 <lambdabot>  [1,4,7,10,13]
05:23:28 <araujo> hello
05:23:48 <tromp> :t let f = (+1); g = (*); in (.) . (f .) . g
05:23:50 <lambdabot> forall (f :: * -> *) a. (Functor f, Num a) => a -> f a -> f a
05:32:45 <LordBrain> :t let f = (+1); g = (*); in (.) . (f .) . g
05:32:47 <lambdabot> forall (f :: * -> *) a. (Functor f, Num a) => a -> f a -> f a
05:33:26 <LordBrain> my ghci doent offer the same type signature for that
05:33:28 <Deewiant> @unpl (.) . (f .) . g
05:33:29 <lambdabot> (\ i b c -> f (g i (b c)))
05:33:33 <EvilTerran> :t let f = (+1); g = (*); in (P..) P.. (f P..) P.. g
05:33:34 <lambdabot> forall a a1. (Num a1) => a1 -> (a -> a1) -> a -> a1
05:33:39 <EvilTerran> ?src (.)
05:33:39 <lambdabot> (f . g) x = f (g x)
05:33:42 <Deewiant> LordBrain: it's Caleskell, substitute fmap for (.)
05:33:43 <EvilTerran> cheeky!
05:34:42 <LordBrain> i don't understand that
05:34:59 <EvilTerran> LordBrain, lambdabot thinks (.) is the same as fmap
05:35:02 <Deewiant> lambdabot uses a custom prelude
05:35:11 <Deewiant> in which, among other things, (.) == map == fmap == (<$>)
05:35:17 <EvilTerran> :t let f = (+1); g = (*); in fmap `fmap` (f `fmap`) `fmap` g
05:35:18 <lambdabot> forall (f :: * -> *) a. (Functor f, Num a) => a -> f a -> f a
05:35:21 <Deewiant> (precedence aside)
05:35:31 <EvilTerran> :t map
05:35:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:35:36 <EvilTerran> oo-err
05:35:51 <ddarius> let f = (+1); g = (*) in (P..) P.. (f P..) P.. g
05:35:53 <Deewiant> the original was \x -> map (f . x)
05:35:56 <ddarius> :t let f = (+1); g = (*) in (P..) P.. (f P..) P.. g
05:35:56 <Deewiant> er
05:35:57 <lambdabot> forall a a1. (Num a1) => a1 -> (a -> a1) -> a -> a1
05:35:58 <LordBrain> why would we want that?
05:36:00 <Deewiant> s/x/g x/
05:36:05 <tromp> > (.) (+1) [0..9]
05:36:15 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
05:36:21 <Deewiant> fmap generalizes (.) and map, from what I understand
05:36:41 <LordBrain> is this a proposal?
05:36:49 <mauke> > (* 2) . subtract 1 . [1 .. 5]
05:36:49 <Deewiant> perhaps, I don't know
05:36:50 <lambdabot>  [0,2,4,6,8]
05:37:22 <EvilTerran> i don't think making (.) = fmap is a serious proposal
05:37:35 <EvilTerran> i haven't seen it on the haskell' trac
05:37:49 <quicksilver> I think it is serious, in that Cale is seriously suggesting it.
05:38:06 <quicksilver> I don't think it has much chance of being part of H', which is probably why he didn't submit it there.
05:38:10 <EvilTerran> i see
05:38:17 <EvilTerran> makes sense
05:38:31 <LordBrain> it's for H'' then i guess...
05:39:15 <LordBrain> i suppose it saves a few keystrokes..
05:39:21 <LordBrain> lol
05:39:30 <pjd_> LordBrain: not just that
05:39:40 <LordBrain> elaborate
05:39:42 <LordBrain> if you can
05:40:30 <LordBrain> is it more in line with a pre-existing notation in mathematics?
05:41:19 <pjd_> LordBrain: the one example is the functor law fmap (f . g) = fmap f . fmap g
05:41:33 <pjd_> which becomes (f . g) . x = f . (g . x)
05:43:40 <LordBrain> ok..
05:44:09 <EvilTerran> > (+1) . [1,2,3]
05:44:10 <lambdabot>  [2,3,4]
05:44:43 <EvilTerran> LordBrain, i find the "instance Functor (->) e where fmap = (.)" makes more sense if you think of (->) as being like Map
05:45:12 <EvilTerran> fmap :: (a -> b) -> Map k a -> Map k b
05:45:33 <EvilTerran> (.) :: (a -> b) -> ((->) k a) -> ((->) k b)
05:45:49 <EvilTerran> ?. pl djinn (a -> b) -> ((->) k a) -> ((->) k b)
05:45:50 <lambdabot> Cannot parse command
05:45:54 <EvilTerran> huh
05:45:58 <EvilTerran> ?djinn (a -> b) -> ((->) k a) -> ((->) k b)
05:45:59 <lambdabot> Cannot parse command
05:45:59 <xerox> infixify it
05:46:10 <EvilTerran> ?. pl djinn (a -> b) -> (k -> a) -> (k -> b)
05:46:10 <lambdabot> f = (.)
05:46:12 <EvilTerran> how rude
05:47:09 <quicksilver> infix versions of functions give you more concise expression, at the cost of more intellectual input required to read them
05:47:19 <quicksilver> aka : they are better when you're used to them, but confusing when you're not.
05:47:27 <quicksilver> a typical trade-off in language/library design
05:48:07 <pjd_> application is usually thought of as infix, though
05:48:56 <pjd_> hence <$>
05:49:46 <LordBrain> it would be hard for juxtaposition to symbolize a prefix operator
05:51:54 <EvilTerran> given that a prefix operator is juxtaposed with its parameters...
05:52:01 <halberd> has anyone implemented the "train of functions" technique from J, in Haskell?
05:52:10 <LordBrain> hmm reifying application seems to point out a deficiency in the everything-is-prefix lispy notations
05:52:51 <LordBrain> i'm not familiar with train of functions
05:52:58 <LordBrain> it sounds fun tho
05:53:10 <EvilTerran> choo choo!
05:53:16 <LordBrain> :)
05:55:15 <halberd> the way it would work is (train [f, g]) x = (f x) (g x), (train [f, g, h]) x = g (f x) (h x), (train [a, ...]) = train [a, train[ ...]] if [a, ...] is even length, train [a, b, ...] = train [a, b, train[ ...]] if [a, b, ...] is odd length
05:55:26 <halberd> that would be for monadic trains
05:55:48 <paczesiowa> what about train transformers?
05:55:54 <pjd_> the first example is <*> / ap
05:55:57 * EvilTerran does not follow
05:56:22 <halberd> i don't know anything about train transformers
05:56:50 <LordBrain> train [f, g, h) x = g (f x) (h x)
05:56:52 <LordBrain> hmmm
05:57:00 <halberd> train takes a list of functions and wires them together in a certain way
05:57:19 <halberd> with base cases if there are 2 or 3 functions, and defined recursively for more functions
05:57:40 <EvilTerran> ... why?
05:57:52 <halberd> because apparently it works in J
05:57:58 <halberd> it's useful in J
05:57:59 <EvilTerran> i mean, what for?
05:58:10 <EvilTerran> can you give a use case?
05:59:11 <ddarius> halberd: In Haskell, combinators are ususally used.  Anyway, 'train' wouldn't typecheck.
05:59:13 <paczesiowa> that J looks like gzipped perl
05:59:29 <ziman> lol
06:00:24 <paczesiowa> quicksort=: (($:@(<#[) , (=#[) , $:@(>#[)) ({~ ?@#)) ^: (1<#)
06:00:46 <xerox> I think your cat just passed over your keyboard, beware.
06:01:12 <EvilTerran> zhe goggles, zhey do NOTHINK!
06:01:27 <funktio> I like that it's more natural language neutral than most other programming languages
06:01:37 <paczesiowa> no, passed out cats press only 1 key, that looks like dancing cats
06:01:50 <EvilTerran> caffienated cats
06:05:17 <desegnis> funktio, I think I'd prefer propaedeutically learning English instead of learning J
06:05:46 <funktio> desegnis: why? J is lots of fun
06:05:52 <mux_> I think I'd prefer learning japanese instead of learning J
06:06:07 <funktio> I don't understand why people complain about non-word characters
06:06:32 <opqdonut> imo APL is in some way more elegant
06:06:54 <mux_> you don't? it's quite straightforward
06:06:54 <mux_> words convey meaning
06:07:08 <desegnis> funktio, then maybe I'll start to learn J when I fell like having fun
06:07:15 <mux_> (($:@(<#[) does not :-)
06:07:29 <desegnis> s/fell/feel
06:08:23 <halberd> it's actually difficult to find a simple example of using train in haskell
06:08:56 <halberd> the problem is that all of APL's operators automatically work on scalars and lists, but you have to do some verbose wiring to get Haskell to do the same
06:09:19 <paczesiowa> you just need some typeclass magic
06:09:20 <LordBrain> hmm
06:09:58 <Philippa> or more sensibly, a way of keeping track of all the nested functors
06:10:03 <LordBrain> i agree that J is cryptic looking, but i'm reluctant to judge, as i suspect some people say that about haskell
06:10:23 <halberd> it's probably just that I don't know idiomatic Haskell, tell me what would be the concise way to write flip (\x -> map (\y-> y-x))
06:10:55 <shepheb> @pl flip (\x -> map (\y-> y-x))
06:10:56 <lambdabot> flip (map . subtract)
06:11:03 <halberd> ok
06:11:40 <Deewiant> @ty let train [f,g] x = (f x) (g x); train [f,g,h] x = g (f x) (h x); train all@(a:b:rest) x = if even (length all) then train (a : train (b:rest) x) x else train (a : b : train rest x) x in train
06:11:41 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
06:11:41 <lambdabot>     Probable cause: `g' is applied to too few arguments
06:11:41 <lambdabot>     In the first argument of `(f x)', namely `(g x)'
06:12:11 <paczesiowa> how about a game? "cat /dev/urandom | J" and linenumber with syntax error is your score
06:12:14 <halberd> so train [flip (map . subtract), sum, (/), length]
06:12:21 <LordBrain> lol
06:12:37 <paczesiowa> I just got to 2nd level in perl
06:12:37 <Deewiant> so now make train typecheck :-P
06:12:41 <desegnis> @type flip (map . subtract)
06:12:42 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> a -> f a
06:13:01 <halberd> that would compute y - mean y
06:13:28 <halberd> in J it's really concise with a train, (- sum % #)
06:13:37 <paczesiowa> y is a number?
06:13:38 <Deewiant> map (subtract mean) y where mean = mean y
06:13:48 <Deewiant> hm, too many means
06:13:57 <paczesiowa> what do you mean?
06:13:59 <Deewiant> anyhoo, that's clearer to me ;-)
06:14:08 <halberd> or just (- mean) using a 2-train
06:14:11 <halberd> a hook
06:14:42 <mm_freak_work> hi people
06:15:04 <LordBrain> yeah concise....
06:15:22 <LordBrain> yet somehow painful
06:15:47 <halberd> well i like it, i don't think it's painful
06:16:00 <mm_freak_work> what is the best method to get an integer square-root?  (truncate . sqrt . fromIntegral) unfortunately doesn't work, because it's lossy
06:16:29 <mm_freak_work> GMP features mpz_sqrt(), so maybe haskell has an interface to it?
06:16:31 <LordBrain> maybe it's awesome when you've conquered the learning curve
06:16:40 <mauke> > scanl [1, 3 ..]
06:16:41 <lambdabot>  Couldn't match expected type `a -> b -> a'
06:16:46 <mauke> > scanl (+) 0 [1, 3 ..]
06:16:47 <lambdabot>  [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,4...
06:16:48 <halberd> it was annoying at first because I was expect something like  (- mean) to partially - with the function mean
06:16:55 <halberd> partially apply -
06:17:21 <mm_freak_work> mauke: so what?
06:17:44 <mauke> what
06:17:58 <halberd> the designers of J figured that people are less likely to do partial application than they are to do trains
06:18:10 <mm_freak_work> mauke: try finding the square root of 1000000000 that way =)
06:18:19 <LordBrain> i still dont understand train
06:18:33 <halberd> so they added a special operator, &, for partial application, and let train be the default when you string functions together
06:19:05 <halberd> well LordBrain if x is a list of integers then (- mean) x becomes, by definition of a 2-train, x - (mean x)
06:19:33 <LordBrain> oh i see, that's kind of nice
06:19:34 <halberd> which means for each element of x, subtract it from the mean of the whole list x
06:19:37 <LordBrain> it's the 3 train that i dont get tho
06:19:53 <quicksilver> mm_freak_work: sadly ghc doesn't provide interfaces to any of the neat libgmp tricks.
06:20:09 <mm_freak_work> =/
06:20:11 <quicksilver> mm_freak_work: perhaps because they keep talking about moving away from gmp anyhow.
06:20:14 <quicksilver> it's a shame.
06:20:21 <quicksilver> It's not very hard to FFI them I don't think.
06:20:23 <LordBrain> well it's linked so you could probably do some FFI stuff
06:20:24 <halberd> well mean is a 3-train, (sum % #)
06:20:25 <mauke> > fst . head . dropWhile ((<= 1000000000) . snd) $ zip [-1 ..] (scanl (+) 0 [1, 3 ..])
06:20:26 <lambdabot>  31622
06:20:31 <mm_freak_work> why should they?  GMP is fine
06:20:33 <mauke> > 31623^2
06:20:34 <lambdabot>  1000014129
06:20:38 <mauke> mm_freak_work: what do I win?
06:20:44 <halberd> so (sum % #) x = (sum x) % (# x)
06:20:58 <halberd> which sums the elements of x and divides that sum by the number of elements in x
06:21:10 <mm_freak_work> mauke: the point is:  i need a fast integral square-root function
06:21:16 <pejo> mm_freak_work, license issues.
06:21:35 <pejo> quicksilver, isn't there a problem with FFI:ing GMP, since it's integrated in the RTS?
06:21:52 <pjd_> halberd: in Haskell you could write (/) <$> sum <*> length
06:22:08 <pjd_> or liftA2 (/) sum length
06:22:16 <mauke> modulo types
06:22:18 <mm_freak_work> pejo: you can FFI another copy of GMP (bad solution, but it should work)
06:22:42 <halberd> well i gotta go nice talking, i recommend J having used it for a day
06:22:42 <quicksilver> pejo: maybe. I can't remember.
06:22:52 <mauke> :t (%) <$> sum <*> length
06:22:53 <lambdabot> [Int] -> Ratio Int
06:23:50 <pjd_> s/length/genericLength/
06:24:24 <tromp> > iterate (\k -> (k + 1000000000 `div` k) `div` 2), 1000000000
06:24:25 <lambdabot>   parse error on input `,'
06:24:47 <tromp> > iterate (\k -> (k + 1000000000 `div` k) `div` 2) 1000000000
06:24:48 <lambdabot>  [1000000000,500000000,250000001,125000002,62500004,31250009,15625020,7812541...
06:25:23 <tromp> > take 20 $ iterate (\k -> (k + 1000000000 `div` k) `div` 2) 1000000000
06:25:24 <lambdabot>  [1000000000,500000000,250000001,125000002,62500004,31250009,15625020,7812541...
06:26:13 <tromp> > drop 20 $ iterate (\k -> (k + 1000000000 `div` k) `div` 2) 1000000000
06:26:15 <lambdabot>  [31622,31622,31622,31622,31622,31622,31622,31622,31622,31622,31622,31622,316...
06:26:16 <Peaker> why do we need (.), fmap and <$> ? aren't they all pretty much the same?
06:26:39 <Deewiant> in lambdabot they are
06:26:40 <tromp> > drop 10 $ iterate (\k -> (k + 1000000000 `div` k) `div` 2) 1000000000
06:26:42 <lambdabot>  [976902,488962,245503,124788,66400,40730,32640,31638,31622,31622,31622,31622...
06:26:42 <Deewiant> exactly the same
06:26:52 <opqdonut> Deewiant: well (.) is just a more strictly typed fmap
06:27:01 <opqdonut> and <$> is infix sugar for fmap
06:27:01 <Deewiant> yep, so I'm told :-)
06:27:07 <Deewiant> along with map
06:27:09 <opqdonut> yeah
06:27:14 <shepheb> liftM as well
06:27:17 <pjd_> Deewiant: <$> = fmap, but the rest of the Applicative functions are a bit different
06:27:26 <Peaker> couldn't it be nice to replace all of these with (.) only?
06:27:46 <pjd_> the real question is the relationship between Functor, Applicative/Alternative, Monad/MonadPlus, ...
06:31:05 <Peaker> @src Alternative
06:31:05 <lambdabot> class Applicative f => Alternative f where
06:31:05 <lambdabot> 	empty :: f a
06:31:05 <lambdabot> 	(<|>) :: f a -> f a -> f a
06:31:20 <Peaker> why is it called Alternative?
06:32:52 <pjd_> Peaker: probably from the paper's parser background
06:33:35 <pjd_> if you look at lists as choices, then <|> is the union
06:33:56 <pjd_> (to consider another example)
06:34:17 <Peaker> who subclasses Alternative?
06:34:21 <Peaker> @src Arrow
06:34:21 <lambdabot> class Arrow a where
06:34:21 <lambdabot>     arr, pure   :: (b -> c) -> a b c
06:34:21 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
06:34:21 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
06:34:21 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
06:34:23 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
06:34:25 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
06:34:42 <Peaker> hmm. why isn't it subclassing stuff?
06:35:55 <pjd_> Peaker: IINM a bunch of those methods are redundant, but there so that instances can provide more optimized implementations
06:36:03 <Japsu> @quote smalltalk
06:36:04 <lambdabot> LoganCapaldo says: ruby isn't trying to out-python python, its trying to out-smalltalk perl :)
06:36:14 <Japsu> <3
06:39:25 <Peaker> pjd_, I just thought - having defaults for more optimized ones in instances seems too specific - many other functions can be optimized when applied to specific instances - maybe a more general optimization technique should be allowed?
06:40:32 <pjd_> Peaker: i imagine so, but that's getting into more complicated territory
06:49:38 * mxc has just been awed by powerset
06:53:02 <pjd_> mxc: filterM (const [True, False]) ?
06:53:09 <mxc> y
06:59:39 <LordBrain> yeah neat
07:00:57 <mxc> @hoogle Ix
07:01:00 <lambdabot> Data.Ix :: module
07:01:00 <lambdabot> Data.Ix.Ix :: class Ord a => Ix a
07:01:00 <lambdabot> Data.Array.IArray.ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
07:01:57 <LordBrain> monads are like a drug
07:03:00 <opqdonut> ?quote
07:03:01 <lambdabot> JamesMckinna says: We are once again left with the miserable prospect that it is equality that divides us.
07:04:37 <profmakx> no way LordBrain. Monads are like THEM! You suspect them behind every corner
07:05:27 <LordBrain> hmmm but THEM is more threatening
07:07:45 <LordBrain> and less mind altering
07:15:50 <mm_freak_work> tromp: your method of simply dropping doesn't work
07:20:54 <mm_freak_work> isqrt n = fromJust $ find (isSqrtOf n) $ iterate (\x -> div (x + div n x) 2) n
07:21:11 <jorick> @hoogle bracket
07:21:12 <lambdabot> Control.Exception.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
07:21:12 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
07:21:12 <lambdabot> Control.Exception.bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
07:21:17 <mm_freak_work> bad method, but it works
07:28:06 <ulfdoz> @src Control.Monad.liftM
07:28:06 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
07:33:49 <mxc> @hoogle memoize
07:33:50 <lambdabot> No matches found
07:34:50 <mxc> ok, so isn't one huge advantage of a pure language that pure functions can be generally memoized
07:35:11 <mxc> not by pure code themselves, but safely by the compiler
07:35:49 <mxc> so, 1) is there any flag which will allow you to give a compiler hint ot say: memoize this function?
07:36:21 <Beelsebob> mxc: yes, define a constant for it's result
07:36:33 <Beelsebob> constants are memorised, functions are not
07:39:53 <jorick> forkIO l where l = readFile "f" >>= writeFile "f" >> l
07:40:31 <jorick> <interactive>: f: openFile: resource busy (file is locked)
07:41:06 <jorick> is this a bug in haskell or am i doing it wrong ?
07:42:12 <mm_freak_work> @pl \x -> (isqrt x)^2 == x
07:42:13 <lambdabot> (==) =<< (^ 2) . isqrt
07:42:29 <mm_freak_work> @src =<<
07:42:30 <lambdabot> f =<< x = x >>= f
07:43:00 <mm_freak_work> @pl \x -> (isqrt x :: Integer)^2 == x
07:43:01 <lambdabot> (==) =<< (^ 2) . (:: Integer) . isqrt
07:44:08 <desegnis> jorick, Prelude.readFile does a lazy read, which makes your program behave bad (even though the locking may happen only on Windows)
07:45:06 <desegnis> jorick, you'd have to either use readFile from the strict byte string library, or open-read-close the file explicitly
07:45:50 <desegnis> You may consider it a bug though that Prelude.readFile reads lazily
07:46:25 <jorick> so i can simply replace all my readFile's by another one?
07:47:26 <quicksilver> It is not a bug that readFile is lazy, because that was intended.
07:47:31 <quicksilver> It is however a mistake.
07:47:32 <quicksilver> IMO.
07:48:16 <mxc> ok, so on a serious note about memoization and parallelizability, which are supposed to be the two gifts that we get for free by using pure haskell, say i have a dynamic programming situation where f(a,b,...) is called repeatedly and recursively
07:48:38 <quicksilver> if anyone told you that you got memoization for free by using haskell
07:48:41 <quicksilver> then go and stab them in the face
07:48:47 <quicksilver> they lied to you
07:49:07 <mxc> i thought that that was the point of referential transparency
07:49:29 <mxc> er the upside
07:49:43 <jorick> how do i hide stuff from the prelude ?
07:50:00 <dolio> import Prelude hiding (...)
07:50:06 <jorick> thx
07:50:46 <mxc> so, i'm killing myself to learn haskell, when the big big advantage over ocaml isn't really even exploited?
07:51:03 <mxc> haskell is definitely fascinating, and i love the challenge
07:51:08 <quicksilver> mxc: then you misunderstood.
07:51:09 <Botje> you can still kill yourself =)
07:51:21 <quicksilver> referential transparency makes memoization simple to understand
07:51:26 <quicksilver> it doesn't make it happen for free
07:51:35 <quicksilver> automatic memoization is a terrible memory leak
07:51:39 <mxc> agree
07:51:45 <quicksilver> you still need to ask for it when you want it.
07:51:52 <mxc> right, how do you ask for it?
07:52:14 <quicksilver> let x = f 1 2 3 in g x x
07:52:19 <mxc> i guess i was hoping that there is some ghc extension that allows you to basically say 'memoize this'
07:52:26 <quicksilver> that shares the result of f
07:52:31 <quicksilver> x is only calculated once
07:53:24 <mxc> thats not very general
07:53:24 <pejo> mxc, if you already know O'caml, what is the biggest problem with learning Haskell?
07:53:41 <mxc> i know that you're going to smack me, but monadic programming
07:53:53 <sw17ch> mxc, i have a hard time with that one too :)
07:53:53 <quicksilver> mxc: how general do you want?
07:54:01 <quicksilver> mxc: you might have to explain a little more about what you're expeting.
07:54:28 <jorick> so to have readFile be strict i have to convert all my strings to bytestrings ?!
07:54:32 <quicksilver> if you want to memoize results of a function against particular input values
07:54:34 <quicksilver> jorick: no
07:54:46 <quicksilver> jorick: you can just read it into a string and `seq` the length.
07:54:50 <quicksilver> bit of a pain.
07:55:12 <quicksilver> mxc: ...then you can do that fairly efficiently with a lazily filled in list, array or map.
07:55:26 <mxc> map
07:55:50 <mxc> in this case
07:56:05 <mxc> so i guess that thats basically the sme as the array in the knapsack exampl
07:56:58 <mxc> just not sure exactly how to go about implementing it
07:58:28 <osfameron> memoizing in haskell does seem surprisingly complicated
07:58:38 <quicksilver> perhaps http://www.haskell.org/haskellwiki/Memoization is helpful
07:58:40 <lambdabot> Title: Memoization - HaskellWiki
07:58:45 <jorick> i pasted the code here, can anyone take a look? http://hpaste.org/7092
07:59:02 <osfameron> compared to Perl,say (use Memoize; memoize \&function)
07:59:43 <halberd> it would be nice to have an "optimization build" that would keep track of statistics and whether it is a good idea or not to memoize certain functions
07:59:45 <quicksilver> jorick: try readFileStrict f = do { s <- readFile f; length s `seq` return s }
07:59:54 <quicksilver> halberd: it would indeed.
08:00:01 <quicksilver> it's a very hard problem to solve in general
08:00:05 <halberd> and then the optimization build, based on its profiling, could output code that would memoize what needed to be
08:00:07 <quicksilver> statistics generation would be a good way to try
08:00:10 <halberd> not static analysis
08:00:14 <halberd> based on runtime performance
08:00:14 <jorick> what does `seq` do? i've seen it before and i never fully understood it
08:00:35 <quicksilver> jorick: it forces the thing on the left to be calculated before the thing on the right
08:00:55 <quicksilver> the main reason you normally need it is to cope with the broken-ness of readFile and getContents
08:01:29 <profmakx> > 1/0
08:01:33 <lambdabot>  Infinity
08:01:37 <profmakx> strange
08:01:51 <quicksilver> why strange?
08:01:53 <mxc> quicksilver, halberd, i agree that generally doing it is very hard, but there should be a way to give a compiler hint to memoize certain functions
08:02:01 <jorick> okay, i think i understand now ... you get the length and thereby force the list to be built
08:02:07 <quicksilver> jorick: right.
08:02:16 <halberd> no the compiler should be able to figure it out by itself
08:02:21 <halberd> it's not that hard a problem
08:02:21 <profmakx> since when is division by zero not punishable by death?
08:02:28 <quicksilver> profmakx: since IEEE
08:02:41 <halberd> it would just have to memoize the function and see how often the memoization actually gets used
08:02:42 <mxc> like when you know that a function will be called say O(n^4) times with just O(n) distinct args
08:02:49 <halberd> then decide, afterwards, whether it was a good idea to memoize
08:02:58 <profmakx> ah well. Electrical Engineers it was right?
08:03:05 <quicksilver> profmakx: quite
08:03:14 <halberd> i.e. memoize the function and for each stored value, also store how much it cost to compute that value
08:03:22 <quicksilver> mxc: it's not that simple though, since it also depends how much space is taken by the memoization
08:03:24 <halberd> then keep a running tally of how often each memoized value was used
08:03:28 <quicksilver> and how badly that thrashes your cache
08:03:34 <quicksilver> and how expensive it is to recalculate
08:03:37 <halberd> and from that it can compute how much time was saved by memoization
08:03:47 <mxc> well, a first step is to let the programmer make the decision
08:03:56 <quicksilver> it can quite easily be faster to recalculate instead of generating the code to access the memoized versin.
08:03:59 <mxc> and then he can at least turn it on and off
08:04:04 <halberd> or it could simply test them both ways
08:04:10 <mxc> yeah
08:04:29 <mxc> for recombinant binomial trees, its pretty much a layup
08:04:46 <halberd> but it's not that hard a problem for the compiler to figure out, say, that a naive definition of fibonacci needs to be memoized
08:05:01 <mxc> where you have 2^n calls on n^2 different arguments
08:05:18 <mxc> halberd, i think that that is pretty difficult
08:05:24 <halberd> not through actually testing it
08:05:35 <halberd> the memoized version would be asymptotically better than the non-memoized version
08:05:42 <halberd> which would be obvious to the profiler
08:05:47 <halberd> so it could automatically memoize it
08:06:41 <quicksilver> you get memory leaks though
08:06:47 <quicksilver> and it's not obvious when to throw away the cache
08:06:57 <quicksilver> and whether or not you need ot have a strategy to 'GC' the cache
08:07:04 <quicksilver> or throw it away all at once.
08:07:14 <quicksilver> I don't pretend these aren't interesting questions, because they are.
08:07:19 <mxc> agree
08:07:21 <halberd> if your choices are "memoize" or "do not memoize," for fibonacci the choice is clear
08:07:27 <quicksilver> I'm just pointing out some of the ways in which it's not trivial.
08:07:38 <quicksilver> and represents an interesting area for research
08:07:42 <halberd> if you want to get into all sorts of architecture specific fuzzy gradations of full memoization, then it gets harder
08:07:47 <mxc> quicksilver, halberd but if your choice is memoize everything or not, itsvery difficult
08:07:59 <halberd> but just the simple choice between memoization and no memoization is very clear for a function like fibonacci
08:08:10 <mxc> but, if i could set a flag for a given function somehow
08:08:12 <quicksilver> halberd: did you not see my point about memory leaks?
08:08:19 <quicksilver> halberd: it's not remotely clear.
08:08:24 <halberd> which is worse, a memory leak or exponential runtime?
08:08:24 <quicksilver> when do you let go of the cache?
08:08:31 <mxc> quicksilver - i agree that you can, but there are plenty of cases where thats perfectly acceptable
08:09:10 <halberd> if you are fully memoizing you never let go of the cache
08:09:20 <halberd> which is still better than exponential runtime
08:10:46 <nejucomo> Hi folks, I'm new to haskell, still grokking, ...
08:11:02 <quicksilver> nejucomo: warning. You will always be still grokking :)
08:11:08 <nejucomo> I'd like to create my own exception type, TestFailure.
08:11:33 <halberd> I agree that if you want to have choices like "let go of the cache" then it is more difficult, but the simple choice between memoized and not memoized is obvious
08:11:36 <halberd> to a profiler
08:12:01 <nejucomo> So I declare the type with "data TestFailure", and then make it an instance of Typeable, but I'm not sure how to return a TypeRep for typeOf.
08:12:08 <quicksilver> nejucomo: deriving Typeable
08:12:16 <quicksilver> nejucomo: nobody writes their own Typeable instances :)
08:12:32 <nejucomo> Ah, so I don't need "instance Typeable TestFailure where ..." at all?
08:12:35 <quicksilver> halberd: if it was obvious, then I contend all RDBMS would support automatically materialized views.
08:12:40 <quicksilver> nejucomo: no, get the compiler to do it.
08:12:50 <quicksilver> data TestFailure = ..... deriving Typeable
08:12:57 <quicksilver> halberd: which is an isomorphic problem.
08:13:07 <nejucomo> Ok, that brings me to my next point.  When can I use "deriving" and when can't I, and what does it do?
08:13:07 <quicksilver> however, I don't believe any of them do, because it's HARD :)
08:13:23 <quicksilver> nejucomo: you can use it to derive certain type classes which the cmopiler knows how to write.
08:13:25 <halberd> it's hard to do perfectly, I'll grant you that
08:13:42 <quicksilver> nejucomo: in haskell98, it's Ord, Enum, Eq, and a few more.
08:13:53 <quicksilver> GHC adds Typeable and Data
08:13:57 <halberd> but it's easy to do if you are only choosing between memoization on/memoization off and not worrying about garbage collection when memoization is on
08:13:59 <quicksilver> (Read, Show are haskell 98)
08:14:21 <nejucomo> Ok, so there's a set of derivable classes that the compiler knows about?
08:14:24 <quicksilver> right.
08:14:31 <nejucomo> Thanks.
08:14:53 <arnar_> quicksilver: can't I define my own typeclasses?
08:15:01 <quicksilver> arnar_: yes, you can.
08:15:07 <quicksilver> arnar_: did I say you couldn't?
08:15:11 <arnar_> no :)
08:15:24 <arnar_> "the compiler knows about" was confusing me :)
08:15:52 <nejucomo> Ah yes, I tried that before and ghci says I need "-fglasgow-exts" to make it work.  I wanted to make compiler-agnostic code.  Is that feasible these days, or is haskell pretty compiler-specific?
08:16:08 <LordBrain> Is there currently a way to access the fields of a record which reuse the same field names?  i know i could write to them... but i mean read access
08:16:31 <quicksilver> nejucomo: defining your own exception is GHC specific.
08:16:33 <nejucomo> So if I weren't using GHC how would I define my own Typeable in order to make my own Dynamic Exception?
08:16:43 <nejucomo> Ah.  That's explains it.  ;-)
08:16:48 <LordBrain> like i have r1 { x :: Int, y ::Int}  and r2 { x::Integer, y:: Integer}
08:17:04 <quicksilver> LordBrain: sure, by patter matching
08:17:30 <quicksilver> case r1 of  (R1 { x = vx; y = vx)) -> ... use vx and vy ...
08:17:46 <LordBrain> can i leave off the y?
08:18:03 <Bonus> why does a haskell one liner generate a 1 meg exe?
08:18:14 <LordBrain> powerful language haha
08:18:17 <Bonus> haha
08:18:32 <quicksilver> LordBrain: yes.
08:18:42 <nejucomo> Why wouldn't something like this work:  class Exception a where { throw :: a -> IO b; catch :: IO b -> (a -> IO b) -> IO b }
08:18:42 <quicksilver> LordBrain: record pattern matches only have to list the bit you care about.
08:18:48 <quicksilver> LordBrain: and the ; was a typo, it's ,
08:19:01 <LordBrain> ok
08:19:22 <quicksilver> nejucomo: bit of a long story.
08:19:38 <quicksilver> nejucomo: that would work, if you don't mind that 'catch' has to know which kind of exception to catch in order to catch it.
08:19:50 <LordBrain> what was your one liner Bonus ?
08:20:02 <quicksilver> Bonus: because it links statically
08:20:03 <Bonus> well not really a one liner
08:20:06 <Bonus> 8 lines
08:20:10 <Bonus> just interested generally
08:20:21 <quicksilver> Bonus: dynamic linking is being worked on but disk space is cheap :)
08:20:25 <nejucomo> quicksilver: So there'd be no "general catch"?  That makes sense.
08:20:35 <Bonus> hehe aha i didn't know its statically linked
08:20:37 <Bonus> inriguing
08:21:06 <tromp> i guess even main = return () could be half a Meg
08:21:07 <gwern> @seen dons
08:21:08 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc and #haskell. I don't know when dons last spoke.
08:21:26 <LordBrain> is there any ghc specific notations involving records?
08:21:27 <gwern> tromp: the RTS is about that size, yes
08:23:30 <gwern> http://haskell.org/ghc/docs/latest/html/libraries/Cabal/Distribution-Extension.html says ExtensibleRecords, RecordWildCards, and RecordPuns
08:23:41 <lambdabot> http://tinyurl.com/2b93uq
08:23:47 <LordBrain> it links statically to libgmp  too... that's kind of a pain for using it at work
08:23:59 <quicksilver> LordBrain: being able to use 'x' in two different record types is already a GHC extension
08:24:09 <LordBrain> ooooooooh
08:24:40 <LordBrain> i was thinking there was some kind of extension, but i couldn't remember
08:25:15 <LordBrain> is that extension going to be in the new standard?
08:25:50 <nejucomo> BTW- Is there a standard unit testing framework?
08:26:01 <LordBrain> quicktest
08:26:06 <tromp> main=return() gives 332800 bytes executable after stripping
08:26:23 <quicksilver> or HUnit
08:26:30 <quicksilver> quicktest is a bit different from standard unit testing
08:26:34 <quicksilver> it's extremely cool though
08:26:49 <quicksilver> erm, quickcheck it's called :)
08:27:10 <quicksilver> @check \a b -> a + b == (b + a :: Int)
08:27:14 <lambdabot>  OK, passed 500 tests.
08:27:41 <gwern> @check \x -> x =\ x
08:27:42 <lambdabot>   Not in scope: `=\'
08:27:50 <opqdonut> you mean /= ?
08:27:59 <LordBrain> it's upside down
08:28:07 <quicksilver> gwern is australian
08:28:07 <gwern> @check \x -> x /= x
08:28:11 <lambdabot>  Falsifiable, after 0 tests: ()
08:28:11 <LordBrain> lol
08:28:12 <tromp> >  332800 / 4368
08:28:13 <lambdabot>  76.19047619047619
08:28:17 <gwern> bleh. who thought that was an easy operator to remember?
08:28:24 <gwern> that's why I never use it
08:28:35 <quicksilver> I find it fairly easy
08:28:39 <quicksilver> the order is the same as the C !=
08:28:44 <quicksilver> but it's a strike instead
08:29:07 <LordBrain> yeah, it looks like C /= "devide equal"
08:29:26 <osfameron> why didn't they use != like everyone else?
08:29:32 <LordBrain> divide..
08:29:47 <opqdonut> well not everyone uses !=
08:29:48 * gwern just uses not (foo == bar)
08:29:59 <LordBrain> hmmm ! is strict too
08:29:59 <opqdonut> some use <> and some ~=
08:30:08 <quicksilver> osfameron: when haskell was started, I think C was the only one using !=
08:30:14 <osfameron> ah
08:30:18 <quicksilver> pascal and fortran both use <>, I think?
08:30:21 <opqdonut> yeah
08:30:44 <quicksilver> ah, no. fortran is .ne.
08:30:46 <opqdonut> prolog uses =/=, which is pretty cute :)
08:31:13 * qwr . o O ( <> looks visually nicer than != anyway... diamond ;) )
08:31:40 <quicksilver> algol used the actual =/= sign in papers, but <> on ascii settings.
08:31:49 <quicksilver> lisp uses words I think?
08:31:55 <opqdonut> yep
08:32:03 <quicksilver> so, conclusion: there wasn't really a standard when haskell's operators were chosen.
08:32:18 <LordBrain> there still isnt really, is there?
08:32:25 <LordBrain> :/
08:32:29 <quicksilver> LordBrain: yes, almost all languages use !=
08:32:39 <quicksilver> if you count "almost all" by number of lines of code written
08:32:50 <quicksilver> c,c++,java,perl,python,php....
08:32:52 <LordBrain> hehehe
08:32:53 <LordBrain> ok
08:32:57 <quicksilver> (all very much the same family, of course)
08:33:07 <qwr> perl uses ne also. ;)
08:33:09 <LordBrain> what does ocaml use?
08:33:15 <qwr> != and <>
08:33:20 <quicksilver> qwr: most of those languages use something else too
08:33:37 <quicksilver> qwr: != is 'reference equality' in java, 'numeric' in perl, etc etc
08:33:39 <qwr> LordBrain: != is pointer non-equivalence in ocaml
08:33:44 <quicksilver> nobody knows what it is in php
08:33:50 <quicksilver> because nobody knows what php means.
08:33:53 <atsampson> occam uses <> (presumably from Algol/Pascal)
08:34:01 <wolverian> php uses !=======
08:34:14 <LordBrain> lol
08:34:14 <byorgey> SQL is also <>
08:34:15 <opqdonut> :P
08:34:39 <quicksilver> byorgey: SQL is != as well, though.
08:34:40 <LordBrain>  /= is easier to type than !=
08:35:18 <byorgey> LordBrain: well, if that's your criterion, we should just use 'f'
08:35:25 <byorgey> if (3 f 6) then ...
08:35:28 <LordBrain> lol
08:35:33 <LordBrain> or ne
08:35:37 <osfameron> g or h would be even easier
08:35:41 <atsampson> and "d" could be the random choice operator?
08:35:46 <opqdonut> :D
08:36:31 <byorgey> osfameron: yes, but those are reserved for addition and bitwise nand
08:37:02 <osfameron> heh
08:37:41 <LordBrain> the need to recall /= happens often enough, that by the third time or so it's in your fingers before your head
08:37:58 <gwern> @ask dons well, roundy rejected my cleaned-up patch: 'Not applied.  I believe two build systems is one too many.'. What do I do now?
08:37:59 <lambdabot> Consider it noted.
08:38:17 <gwern> LordBrain: honestly, pattern matching is common enough I rarely find any need for /=
08:38:34 <gwern> pattern matching, guards, and HOFs generally do the trick for me
08:39:07 <LordBrain> yeah, well you're just going out of your way to avoid assimilation
08:40:01 <LordBrain> you've probably used it twice, so you just need one more time
08:40:33 <gwern> madness
08:40:42 <LordBrain> resistence is futile
08:41:35 * gwern is an insulator
08:42:51 <ski> opqdonut : actually prolog uses (\=)/2 .. while (=\=)/2 (not (=/=)/2) is for numeric expression equality)
08:43:16 <ski> (opqdonut : there's also (\==)/2 for nonidentity ..)
08:44:40 <opqdonut> ski: ah, misremembered
08:54:51 <mxc> hm
08:55:01 <mxc> so, graph reduction kind of gives you free memoization
08:55:16 <mxc> or does it
08:55:35 <opqdonut> yeah
08:55:43 <opqdonut> if something has a name it gets evaluated at most once
08:55:49 * lispy laughs at "train transformers"
08:55:56 <opqdonut> but that's a very limited sort of memoization
08:56:33 <mxc> like for working with recombinant binary trees
08:58:24 <byorgey> lispy: ?
09:05:55 <lispy> byorgey: it was a conversation in the scroll back
09:06:10 <lispy> byorgey: someone asked how to simulate J's function trains in haskell
09:06:21 <lispy> byorgey: and it led to someone joking about transformer trains :)
09:06:46 <byorgey> lispy: ah, I see =)
09:06:53 <lispy> er, well up to me permuting the order of the words
09:06:59 * byorgey scrolls
09:16:10 * byorgey offers organic peanut butter and jelly lambdas
09:17:44 <quicksilver> mmm peanut butter and jelly
09:18:09 <opqdonut> mmm organic lambdas
09:35:56 <monochrom> @seez wli
09:35:56 <lambdabot> Last time I saw wli was when I left ##logic, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books, #haskell-hac07, #haskell-hac4, #
09:35:56 <lambdabot> haskell-overflow, #haskell-soc, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #
09:35:56 <lambdabot> jtiger, #parrot, #perl6, #rosettacode, #scala, #scannedinavian, #thunks, #unicycling and #xmonad 1d 6h 54m 53s ago, and .
09:36:33 * vincenz whistles
09:36:44 <bos> oh, yuck.
09:38:47 <byorgey> funny, I wonder why there's both #haskell.ru and #haskell_ru
09:46:50 <Lycurgus> byorgey: one or both were made by mistake.
09:47:09 <Lycurgus> s/mistake/exploration/
09:47:24 <byorgey> probably.
09:47:58 <xerox> It was the same for -it and .it but we got rid of one.
10:06:13 <dons> and .
10:06:13 <lambdabot> dons: You have 7 new messages. '/msg lambdabot @messages' to read them.
10:12:58 <mofmog> so i have a program that simulates conway's game of life. For some reason, if i run it interpreted, it runs fine. However, if i run it compiled, the game won't update itself to the new state
10:13:04 <mofmog> it'll literally just hang
10:13:37 <tromp> io buffering issue?
10:13:42 <dcoutts_> mofmog: threads?
10:13:55 <mofmog> dcoutts: oh could be
10:14:08 <mofmog> i'm using threadDelay to make the updates visible
10:14:24 <mofmog> that is, so it doesn't update too fast to tell what's going on
10:14:34 <dcoutts_> mofmog: using some external C code?
10:14:43 <mofmog> no
10:14:59 <dcoutts_> mofmog: ghci use the -threaded rts, by default compiled progs use the single threaded rts
10:15:10 <mofmog> oh i see
10:15:12 <dcoutts_> try compiling with ghc -threaded
10:15:18 <mofmog> alright thaks
10:15:40 <dcoutts_> mofmog: but most progs that are not doing FFI should not have any different behaviour between the two, so it'd be good to understand what is going on
10:16:03 <mofmog> well i have a small knowledge of threads
10:16:21 <mofmog> all i know is very abstractly how a deadlock or incorrect result could occur etc
10:17:16 <mofmog> hmm
10:17:18 <mofmog> it still hangs
10:22:06 <cjs_> Hey, stupid question, but: when I read, "instance Monad (Cont r) where...", that "Cont r" is the type constructor, not the type name, right?
10:22:33 <cjs_> (I.e., when the type is "newtype Cont r a = Cont { runCont :: ((a -> r) -> r) }".
10:23:01 <xerox> Yup, it is a type constructor of kind * -> *
10:23:27 <cjs_> So "r" is "((a -> r) -> r)"?
10:23:38 <xerox> ?kind Cont Int
10:23:40 <lambdabot> * -> *
10:23:47 <xerox> No, r is just r.
10:24:22 <cjs_> Well, it looks to me (naively) that the constructor takes just one thing, so that r must be the r on the left, right?
10:25:00 <xerox> Right.
10:25:21 <xerox> Cont r is a thing that given an a, returns an (a->r)->r
10:25:33 <cjs_> Ok, so that's not the constructor, or I've got my terminology wrong when I say constructor.
10:25:45 <mofmog> alright this is terribly annoying... why in the heck does the compiled one not work even with -threaded
10:25:53 <cjs_> Ok, I get that. I think. If only I can remember it.
10:26:02 <cjs_> This is hurting my tiny little brain.
10:26:07 <xerox> Something that takes a type and returns a type is called a type constructor indeed! And Cont r is such a thing as we just said.
10:26:27 * cjs_ explodes.
10:27:02 <xerox> It is just a function in the realm of types.
10:27:30 <cjs_> I know. But somehow I seem to have difficulty with this. Sad, isn't it.
10:27:41 <xerox> Look at this:
10:27:44 <xerox> ?kind Cont
10:27:46 <lambdabot> * -> * -> *
10:28:04 <mauke> ?kind Map
10:28:05 <lambdabot> Not in scope: type constructor or class `Map'
10:28:05 <cjs_> Right, so give Cont a type, and it produces a type.
10:28:06 <xerox> Cont is a thing that takes a type and returns a thing that takes a type and returns a type
10:28:08 <mauke> ?kind M.Map
10:28:10 <lambdabot> * -> * -> *
10:28:20 <xerox> No! Give Cont a type, and it produces a type constructor.
10:28:44 <cjs_> That makes sense. But then I get to this: http://www.haskell.org/all_about_monads/html/contmonad.html and it suddenly seems so much more difficult.
10:28:44 <lambdabot> Title: The Continuation monad
10:28:46 <elliottt> cjs_: it's not until all the arrows in the kind of Cont are removed that you get a type
10:29:03 <xerox> Thanks to some theorem we can also say that if you give Cont two types, you get a type back.
10:29:20 <arnar_> hey folks..
10:29:32 <arnar_> anyone know of an implementation of A* or similar in hs?
10:29:41 <xerox> But if you give him just one, it is still left with one degree of freedom.
10:31:14 <cjs_> Right. I'm not so bad there. It's the bind operation that's making my head spin.
10:31:43 <xerox> Well, yeah. Cale sometimes explains the monad with some "question" analogy. I'm unable to reproduce it here now, sorry.
10:33:53 <cjs_> Actually, it's just this particular monad that's killing me. I was ok with some of the others.
10:34:46 <andrei> arnar_, Dijkstra's algorithm is almost certaintly there
10:35:38 <cjs_> I'll give it a few more days. Darnit, this language takes *weeks* to learn.
10:36:10 <elliottt> cjs_: it's worth it :)
10:36:14 <EvilTerran> it's good for you
10:36:51 <cjs_> I dunno about that. You think I found Java frustrating before this....
10:36:55 <EvilTerran> haskell forces you to use tricks and thinking patterns that're useful in most languages
10:37:13 <paczesiowa> haskell forces me to have fun
10:38:01 <EvilTerran> and, yes, those thinking patterns are also fun :)
10:38:03 <EvilTerran> hm...
10:38:06 <EvilTerran> ?go jaskell
10:38:07 <lambdabot> http://codehaus.org/~yan/
10:38:07 <lambdabot> Title: Yan Container Manual
10:38:31 <EvilTerran> ah: http://codehaus.org/~yan/jaskell/
10:38:31 <lambdabot> Title: The Jaskell Programming Language Manual
10:38:43 <cjs_> It's like way back when I spent a year at university, and discovered discrete math, and realized that all the time I'd been using maybe an adze, and then suddenly someone gave me a circular saw...
10:38:49 <cjs_> ...and then I cut my arm off.
10:39:18 <EvilTerran> ... that jaskell thing's weird. never mind.
10:39:38 <cjs_> I'm not even going to look. Java has caused me so much misery.
10:39:46 <cjs_> (Thus my presence here.)
10:40:19 <Saizan> "[1,["abc",'x']] is a list whose first element is a number and the second element is another list." brrr
10:40:32 <EvilTerran> maybe you'll be able to use YHC to compile haskell for the JVM so it can interact with java code
10:40:49 <Zao> Saizan: Too bad that lists are homogenous.
10:41:52 <EvilTerran> saizan, instance Num [Char], instance IsString Char >:]
10:41:54 <cjs_> I have no wish to interact with Java code.
10:42:15 <paczesiowa> EvilTerran: why would you interact with java? what libraries are you missing?
10:42:18 <EvilTerran> it'd make it possible to gently migrate a project from java to haskell, i was thinking
10:42:28 <cjs_> I've hardly touched it for five years, and I'm personlly bent on getting out of Ruby, myself.
10:42:28 <Saizan> EvilTerran, that's a clear sign that IsString is evil
10:42:49 <cjs_> paczesiowa: The XML of all XML libraries!
10:43:01 <EvilTerran> i'd think it more a clear sign that abusing IsString is evil
10:43:09 <paczesiowa> cjs_: say what?
10:43:15 <EvilTerran> seeing as i also abused Num to the same effect there
10:43:52 <cjs_> paczesiowa: there's no question that not only is Haskell lacking in libraries, but particularly XML libraries.
10:44:14 <paczesiowa> cjs_: what's wrong with hxt?
10:44:15 <cjs_> Starting with ghc, whose syntax should be XML.
10:44:27 <dons> hehe
10:44:31 <paczesiowa> cjs_: Oh, I get it:P
10:44:34 <dons> wait right here!
10:44:40 <cjs_> Hey, who knows that great cartoon someone showed me here?
10:45:01 <cjs_> lambda calc. -> LISP -> W3C.
10:47:00 <cjs_> Oh no! It hurts! It's real!
10:47:03 <cjs_> http://www.w3.org/2005/04/FSWS/Submissions/30/tenpoints.html
10:47:06 <lambdabot> Title: W3C Rule Workshop Proposal
10:47:37 <cjs_> "What makes sense is a functional approach to using and composing Web Services, building upon the lambda-calculus...."
10:48:17 <dons> yay!
10:48:26 * dons is full of espresso and lambdas
10:48:34 <cjs_> Show us!
10:51:09 * monochrom hands dons some Java beans.
10:51:47 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/xml-1.2.6
10:51:49 <lambdabot> http://tinyurl.com/3eza4f
10:51:54 <dons> a new lightweight xml parser ...
10:52:26 <monochrom> interesting
10:52:30 <elliottt> and generator :)
10:52:36 <paczesiowa> in what way lightweight? is hxt slow?
10:52:43 <dons> i think of it as the tagsoup of xml libs
10:52:51 <dons> similar philosophy/utility
10:55:25 <olsner> @ty (++)
10:55:28 <lambdabot> forall m. (Monoid m) => m -> m -> m
10:55:39 <olsner> aah, polymorphism <3
10:56:23 <xerox> 
10:56:36 <saml> > 1 ++ 2
10:56:37 <lambdabot>  Add a type signature
10:57:02 <xerox> maybe 11 ++ 22 works if you cross your eyes
10:57:08 <EvilTerran> ?src Sum
10:57:08 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
10:57:18 <EvilTerran> > Sum 1 ++ Sum 2
10:57:19 <lambdabot>  Sum {getSum = 3}
10:57:25 <EvilTerran> :t Sum 1 ++ Sum 2
10:57:26 <lambdabot> forall t. (Num t) => Sum t
10:57:34 <EvilTerran> > 1 ++ 2 :: Sum Int
10:57:35 <lambdabot>   add an instance declaration for (Num (Sum Int))
10:57:36 <ptolomy2> I'm excited about the recent incremental performance improvements to Data.ByteString.. is the proper way to deal with such upgrades to use cabal, or will it eventually get merged into a GHC release?
10:57:45 <EvilTerran> bah. no derived Num instance for Sum?
10:58:08 <dcoutts_> ptolomy2: both
10:58:15 <EvilTerran> they'll probably put the latest stable version in each even GHC release
10:58:42 <ptolomy2> like, in 6.8.3, or 6.10?
10:59:11 <dcoutts_> not sure, we should check if 0.9.1.0 is ok to go with 6.8.3
10:59:13 <EvilTerran> 6.8.4?
10:59:26 <dcoutts_> there probably will not be a 6.8.4
10:59:28 <pierre-> #oasis
10:59:30 <EvilTerran> i forget, does ghc use 6.8.odd for test releases and 6.8.even for stable?
10:59:43 <pierre-> err, sorry
10:59:56 <dcoutts_> EvilTerran: eg 6.9 is unstable 6.8.x is stable
11:00:23 <dcoutts_> EvilTerran: no odd/even stuff on the third 6.8.x digit
11:00:24 <EvilTerran> oh, i see. so the third digit doesn't follow the odd/even un/stable thing, but the second does?
11:00:28 <dcoutts_> right
11:00:36 <EvilTerran> right. ta :)
11:01:37 <cjs_> Ok. The particular image I was thinking of appears to have been stolen from or been stolen by http://rds.yahoo.com/_ylt=A0oGki0I1gxIDnsAC6BXNyoA;_ylu=X3oDMTBzdmZsbTcxBHNlYwNzcgRwb3MDMTAEY29sbwNzazEEdnRpZAM-/SIG=132vptd2o/EXP=1208887176/**http%3a//homepages.inf.ed.ac.uk/wadler/papers/xml-essence/xml-essence-slides.pdf
11:02:17 <EvilTerran> heh
11:04:53 <EvilTerran> 't's funny 'cos it's true
11:06:15 <gwern> with any luck, igloo will boot bytestring out of ghc entirely
11:06:27 <LordBrain> hmm lamdabot didn't give us a tinyurl for that
11:06:47 <gwern> > 2 + 2
11:07:22 <pejo> gwern, can you get stuff from hackage installed for the shootout?
11:07:36 <gwern> @bot
11:08:01 <gwern> pejo: you could probably appeal to the shootout devs, I suppose
11:08:24 <gwern> pejo: but I have no objection to bytestring being distributed with GHC, the problem is GHC *using* bytestring
11:09:32 <LordBrain> what's wrong with using bytestring in ghc?
11:09:32 <cjs_> I think the bot's dead again.
11:09:39 <cjs_> Linking problems.
11:10:36 <gwern> LordBrain: are you on haskell-cafe? we were just discussing it
11:10:45 <LordBrain> nope..
11:10:49 <gwern> LordBrain: the problem is things are statically compiled, and so one library gets statically compiled against say 0.9.0.1, and another against 0.9.0.4; and you try to write something using libraries A and B - your app will now fail to compile
11:12:24 <LordBrain> you mean fail to link right?
11:12:25 <dons> I hope everyone's excited:
11:12:27 <dons> http://www.haskell.org/pipermail/haskell/2008-April/020360.html
11:12:31 <dons> ANNOUNCE: Galois web libraries for Haskell
11:12:56 <dcoutts_> dons: nice
11:12:58 <gwern> LordBrain: the solution is to compile everything against same bytestring, but this doesn't always work - how do you compile GHC against a different bytestring? it's infeasible
11:13:04 <dons> yay :)
11:13:22 <dons> US Government++ open source friendly :)
11:13:25 <gwern> dons: weren't most of those already on hackage?
11:13:41 <dons> gwern: 2 were. (utf8-string, selenium).
11:13:50 <dons> these are all new releases too, even the ones we'd already leaked
11:14:06 <gwern> hm. wasn't curl already up there too?
11:14:15 <gwern> I know I was looking at it earlir for darcs
11:14:22 <cjs_> I was about to make some smartass XML comments, but, instead, thank you for utf8-string!
11:14:25 <dons> an old version was sitting on code for a month or two, iirc.
11:14:29 <dons> cjs_: :)
11:14:49 <gwern> dons: speaking of darcs, any ideas? (lambdabot is down so if you left me a message I didn't get it)
11:15:16 <elliottt> dcoutts_: would it be possible to make hackage not report haddock failures as build failures?
11:15:43 <dcoutts_> elliottt: it's certainly be useful for them to be reported separately
11:15:49 <dcoutts_> it's/it'd
11:15:55 <cjs_> Hey, dons, you work for Galios?
11:15:56 <elliottt> :)
11:16:33 <dcoutts_> elliottt: I'm not at all familiar with the current building code, though I do have plans to replace it with something better :-)
11:16:38 <gwern> dcoutts_: and also installing sutff would be useful - did yu see the fellow complaining about how build-failure is useless for his package since it just errors as cant find -gtk?
11:16:45 <dons> cjs_: yeah. so does yav_, elliottt, SyntaxNinja, glguy, andyjgill
11:16:58 <dcoutts_> elliottt: ie the current server-side build-it-in-a-chroot system
11:17:19 <dcoutts_> in fact it's not even clear where the code that does that actually is, it's not in hackage-scripts
11:17:27 <elliottt> oh goodness
11:17:31 <elliottt> that's not so great :)
11:17:33 <dcoutts_> elliottt: ask ross
11:17:38 <elliottt> will do.
11:17:51 <elliottt> maybe we can get it committed and start working
11:18:12 <dcoutts_> elliottt: if/when I have my way we'll have separate clients doing the builds and reporting back to the server rather than the server doing the builds
11:18:40 <cjs_> My God.
11:18:45 <elliottt> dcoutts_: that would be pretty cool :)
11:19:08 <dcoutts_> elliottt: we started work at the hackathon to get cabal-install to generate build reports in a form suitable to report back to the hackage server
11:19:19 <elliottt> awesome :)
11:19:27 <elliottt> do you have any usage stats on cabal-install at the moment?
11:19:35 <elliottt> (i've started using it for all my cabal needs)
11:19:50 <dcoutts_> elliottt: not yet, we should use the server logs to find out, it uses a separate agent-id
11:20:04 <elliottt> ah, cool
11:20:09 <dcoutts_> elliottt: the idea being that anyone could anonymously and automatically report build results (to the server they downloaded the package from)
11:20:23 <elliottt> yeah, that would be fantastic
11:20:36 <elliottt> is there anything i can do to help? :)
11:20:47 <dcoutts_> elliottt: or special dedicated cabal-install build bots that do nothing but look for new packages and build them, the latter would be more useful in-house, and the former more useful for hackage
11:21:08 <elliottt> and both are viable, given cabal-install
11:21:20 <jorick> if i do hGetLine on a a handle, and the client sends me 4GB of data (without any newlines), what will happen ?
11:21:33 <dcoutts_> elliottt: sure, there's the server side story we need to work out, I've got some ideas for an architecture
11:21:49 <sethk> jorick, well, for one thing, you'll be processing it for a long time  :)
11:22:00 <elliottt> dcoutts_: basically, how to deal with the reported information?
11:22:12 <sethk> jorick, I believe you'll run out of memory
11:22:19 <dcoutts_> elliottt: right, the server needs to have a schema for the uploaded data, it has to validate and store it
11:22:41 <dcoutts_> elliottt: and provide the data back to other clients so they can do analyses and present summaries/reports
11:22:48 <jorick> is there a way to safely read from it? (eg give an exception if more than X bytes)
11:23:03 <elliottt> dcoutts_: it doesn't seem like it should be too difficult to fit into the current hackage script set
11:23:18 <dcoutts_> elliottt: basically I think hackage should just manage information and not really do any work itself, all work should be done by external clients
11:23:31 <sethk> jorick, I've never tried doing it that way.  I'd have to look at the source to know
11:23:31 <elliottt> dcoutts_: yeah, i think that's sensible.
11:23:52 <dcoutts_> elliottt: I'm not so sure, I think the framework could be better and easier to deploy and easier to add/remove features
11:23:56 <elliottt> dcoutts_: especially if a load of people are using cabal-install :)
11:24:02 <SamB> what sort of schema?
11:24:04 <jorick> ok
11:24:17 <dcoutts_> SamB: a Haskell data type probably, but versioned
11:24:19 <elliottt> dcoutts_: are you thinking about a rewrite?
11:24:22 <sethk> jorick, you could read it in as binary chunks, but that's kind of ugly
11:24:50 <arnar_> sorry to barge in.. I have a very simple algorithm (bfs) to implement, I can type down the type signature, just wondering what are the appropriate data structures to use.
11:24:56 <LordBrain> use getContents, and take a certain amount at a time
11:25:05 <dcoutts_> elliottt: well, I think now is the right time to think carefully about the hackage server side framework since I think we'll be wanting to add loads and loads of features to it in the next few years
11:25:10 <LordBrain> hGetContents is lazy
11:25:13 <jorick> i think i'm going to write my own hGetLine' :: Handle -> Int -> IO String
11:25:20 <dcoutts_> elliottt: we don't want a big monolithic mess
11:25:29 <elliottt> :)
11:25:48 <sethk> jorick, that sounds reasonable
11:26:18 <jorick> arnar_, a queue would be nice
11:26:23 <dons> http://reddit.com/info/6gknt/comments/  yay
11:26:33 <dcoutts_> elliottt: what kind of server side frameworks are you familiar with? I'm not familiar with any in any real detail, though I know a bit about happs.
11:26:35 <dons> "Web apps in Haskell just got a lot easier: Galois open sources Haskell web libraries"
11:26:39 <arnar_> jorick: ok.. for the "open list" - but I need to keep track of the "path" to each node..
11:26:49 <mrd> dons: do you work on those?
11:26:56 <elliottt> dcoutts_: i've done a load of stuff with fastcgi
11:27:02 <elliottt> not that that's particularly a framework :)
11:27:05 <arnar_> so the type signature would be sth. like:   bfs :: (Eq a) => (a -> [a]) -> a -> a -> Maybe [a]
11:27:06 <dons> mrd, yep.
11:27:08 <jorick> arnar_, so keep a list of node?
11:27:13 <mrd> sweet
11:27:14 <elliottt> dcoutts_: and i've done a bit with happs, but nothing big.
11:27:18 <sethk> dons, nice looking package
11:27:20 <jorick> nodes*
11:27:36 <dcoutts_> elliottt: any thoughts either way? happs' db stuff sounds like it'd be useful
11:27:40 <elliottt> dcoutts_: i think it would be worthwhile using something like fastcgi, and just abstracting the application enough so that it could be removed sometime in the future
11:27:54 <dons> some up mods on that reddit article would be nice :)  commercial haskell houses don't release stuff every day :)
11:28:00 <arnar_> jorick: does the list contain values or references?
11:28:06 <arnar_> I'm concerned about the size
11:28:25 <elliottt> dcoutts_: does the current happs still store everything in memory?
11:28:30 <dcoutts_> elliottt: are there any pure haskell fastcgi hosts? eg so one can really easily set up a test server on one's desktop
11:28:53 <elliottt> dcoutts_: hrm... there's lighttpd
11:28:53 <dcoutts_> elliottt: happs can do either, you can do whatever you like and you can take advantage of the in memory db stuff
11:29:00 <arnar_> I'll just do it straight fwd for now.. optimize later :)
11:29:09 <dcoutts_> elliottt: ah, but something we can deploy with 'cabal install hackage' :-)
11:29:14 <Nafai> dons: Thanks to you and Galois for releasing these!
11:29:20 <elliottt> dcoutts_: ok.  the in memory db thing was always what was making me look for things other than happs :)
11:29:44 <elliottt> dcoutts_: that would be nice, but i think that the layout of web apps doesn't lend itself to the cabal packaging format ;(
11:29:46 <dcoutts_> elliottt: so for hackage with happs you'd use disk for the tarballs and memory for the indexes for example
11:30:05 <elliottt> dcoutts_: that makes sense
11:30:08 <dcoutts_> elliottt: no? anything we could do to help that?
11:30:18 <elliottt> i'm sure :)
11:30:58 <elliottt> dcoutts_: i guess the problem is that there's not a very standard way of installing web apps
11:31:02 <dcoutts_> elliottt: I don't necessarily mean a big instance, like the central hackage server, but for testing/experimentation
11:31:05 <elliottt> dcoutts_: that's where app servers really help out
11:31:24 <dcoutts_> elliottt: cabal install hackage-lite && ./hackage -port 8080
11:31:42 <elliottt> dcoutts_: so in that case, i would say that happs would work well.
11:31:46 <dcoutts_> so a single-purpose in process host
11:32:05 <elliottt> dcoutts_: however, you've still got that web root problem
11:32:35 <elliottt> dcoutts_: how would you package up scripts/images/etc to install into a web root using cabal?
11:32:48 <dcoutts_> elliottt: right, I think for happs people use apache to forward and proxy requests to a local happs on a private localhost port
11:33:25 <elliottt> dcoutts_: yeah.  that seems the easiest route, as i'm not sure how well happs serves static data
11:34:16 <dcoutts_> elliottt: yeah, I'm not sure about scripts/images etc
11:34:39 <dcoutts_> it doesn't obviously fit the --libdir --bindir stuff
11:34:40 <Lemmih> The HAppS web-server is decent. It should pull more than 1k/rps on any modest hardware.
11:34:42 <elliottt> dcoutts_: so does that still make happs a good choice for the hackage-light?
11:34:57 <dcoutts_> elliottt: sure
11:35:01 <elliottt> Lemmih: thanks :)
11:35:13 <dcoutts_> elliottt: cabal can install data files that one needs at runtime
11:35:37 <elliottt> dcoutts_: yeah, that would be slick
11:35:57 <dcoutts_> elliottt: that's because if it's a single program that is the server then the file layout isn't important, so long as the process can find the data files at runtime (and cabal provides a way to do that)
11:36:28 <dcoutts_> elliottt: the hard case is where you have to construct a specific file layout in some other server's web root
11:36:31 <elliottt> dcoutts_: ah, excellent
11:36:55 <elliottt> dcoutts_: yeah.  that's what i wasn't sure how to do when i tried packaging the hackage scripts a while back
11:36:59 <dcoutts_> but if the server is just a haskell prog then that's easy
11:37:19 <dcoutts_> elliottt: right, getting the compiled cgi progs into the right places
11:38:20 <dcoutts_> elliottt: so I was thinking of lambdabot as an example, it has lots of relatively separate features, most of them maintain some bits of state
11:38:41 <czakey> btw
11:38:43 <dcoutts_> and it's possible to add features fairly easily or select only a subset
11:38:55 <czakey> if I want to use haskell from web interface
11:38:59 <elliottt> dcoutts_: this would be really useful
11:39:07 <czakey> I must use HAppS, right?
11:39:29 <czakey> because I'm not interested using Haskell from CGI
11:39:33 <czakey> I think...
11:39:40 <dcoutts_> elliottt: of course Well-Typed LLP would love to work on such a project for a client ;-)
11:40:07 <elliottt> dcoutts_: hehehe
11:40:07 <dcoutts_> elliottt: but lots of this are useful to the community as a whole so we want to go in that direction anyway
11:40:38 <dons> czakey: well, fastcgi is also fine. there's happs if you want a builtin server
11:40:58 <elliottt> dcoutts_: i agree.  it would be nice to have a more flexible hackage :)
11:41:32 <dcoutts_> yes, it should be really useful for managing a set of related packages being worked on by a team of devs
11:41:56 <elliottt> dcoutts_: almost like a sourceforge for haskell apps :)
11:41:57 <dcoutts_> gathering build results, tests, coverage, docs, QA checks, perf tests etc etc
11:42:06 <dcoutts_> elliottt: right, only better :-)
11:42:11 <elliottt> hehe
11:43:09 <dcoutts_> elliottt: btw, glad to hear you're using cabal-install :-)
11:43:25 <dcoutts_> I hope you're reporting the annoyances you run into in the trac
11:43:35 <gwern> hopefully not as ugly
11:43:47 <elliottt> dcoutts_: i haven't really run into any
11:43:59 <dcoutts_> elliottt: wow, that must be a first :-)
11:44:10 <elliottt> dcoutts_: the only thing that i found was a bit funny was using cabal upgrade, which produced some strange errors when bytestring was updated
11:44:14 <dons> we're careful with our versioning
11:44:36 <dcoutts_> elliottt: ah that'll be because SyntaxNinja wrote cabal upgrade ;-)
11:44:42 * dcoutts_ jests
11:44:44 <elliottt> hehe
11:44:52 <elliottt> i think i've already chided him for that :)
11:45:54 <elliottt> dcoutts_: it's an excellent tool, makes installing packages a breeze :)
11:46:10 <dcoutts_> :-)
11:46:30 <dcoutts_> elliottt: thanks, I spend much of my time thinking about the problems it has :-)
11:46:43 <gwern> we have cabal upgrade now?
11:46:45 <gwern> how does that work?
11:46:57 <dcoutts_> gwern: depends what you think it should do :-)
11:47:02 <elliottt> pulls down all new versions of installed packages, and installs them
11:47:12 <dcoutts_> though not in the right order necessarily
11:47:23 <elliottt> :)
11:47:47 <gwern> hm. cabal upgrade doesn't seem to call cabal update first
11:47:53 <dcoutts_> nope
11:47:55 <gwern> that's not good
11:48:11 <gwern> bug or feature?
11:48:30 <dcoutts_> it's hard to know when it's ok to go and use the network
11:48:42 <elliottt> i guess it's similar to apt-get
11:48:48 <dcoutts_> without the user explicitly saying it's ok, by saying cabal update
11:48:50 <elliottt> you always apt-get update before apt-get upgrade
11:49:09 <gwern> dcoutts_: well, in sh terms you'd try 'cabal update; cabal upgrade'
11:49:20 <dcoutts_> yep
11:49:22 <gwern> use the network if you can, but if you can't oh well too bad
11:49:45 <gwern> dcoutts_: and incidentally, wouldn't cabal upgrade usually need network access? I can't imagine who downloads and caches the tarball without installing/upgrading with them
11:50:04 <dcoutts_> gwern: we do have cabal fetch for exactly that purpose
11:50:08 <dcoutts_> so you may well have them locally
11:51:06 <gwern> dcoutts_: is cabal upgrade supposed to be atomic? or can some fail?
11:51:17 <dcoutts_> gwern: some can fail
11:51:17 <gwern> and the rest continue to succeed
11:51:20 <dcoutts_> yes
11:51:44 <dcoutts_> it doesn't try to install things that depend on the packages that failed
11:51:53 <dcoutts_> so you don't get a cascade of failures
11:52:16 <gwern> hm
11:52:55 <dcoutts_> so it reports at the end: couldn't install X because it depends on Y which failed to install
11:57:22 <gwern> 'cabal: Error: some packages failed to install:
11:57:23 <gwern> HDBC-odbc-1.1.4.3 failed during the configure step. The exception was:
11:57:24 <gwern>  exit: ExitFailure 1
11:57:34 <gwern> <-- what a brillaintly useful error message
11:57:53 <dcoutts_> yeah I know, but people complained when we didn't show the error message
11:58:37 <bugQ> Heyt, at least it's not EpicFailure.
11:58:41 <bugQ> *hey.
11:58:49 <dcoutts_> EpocFailure surely?
11:59:03 <dcoutts_> gwern: hopefully we can find some compromise where we don't show the dull obvious ones
11:59:11 <bugQ> that's Epoch, no?
11:59:16 <dcoutts_> oh, yes :-)
11:59:26 <dcoutts_> gwern: or just generally classify the errors better so we have more info about them
11:59:41 <gwern> data ExitStatus = EpicFail | ExitAwesum
12:00:53 <gwern> dcoutts_: I suppose the hard thing is that Cabal only learns from GHC 0 or 1 exit codes, no? GHC doesn't do any more elaborate exit codes
12:01:27 <dcoutts_> gwern: right
12:01:42 <dcoutts_> gwern: but in this case we'd hope that ghc had printed some error message
12:02:58 <gwern> dcoutts_: it does, but way the heck back
12:03:19 <dcoutts_> gwern: right, perhaps we could capture the stdout and stderr
12:03:25 <gwern> I suppose you could capture a copy of stderr
12:03:39 <dcoutts_> yes
12:21:12 <arnar_> How do I refer to rigid type variables from one scope up: http://hpaste.org/7093  ?
12:21:52 <arnar_> I want the a type var in bfs' to be the same as in the bfs
12:22:02 <arnar_> the compiler treats them as two different vars.. :/
12:22:09 <duschendestroyer> is there a way to use literal numbers in data types? .. i want something like myVector :: Vector 3 Float to deal with the dim at compile time
12:22:55 <opqdonut> yeah
12:23:12 <opqdonut> or rather, it can be done in the type system and compile-time
12:23:30 <opqdonut> but there isn't really syntax sugar for it, unless you want to use a preprocessor or something
12:24:10 <arnar_> nm.. suppressing the type decl. for bfs' did it
12:24:40 <arjanb> arnar_: using -fglasgow-exts may help too
12:25:10 <arnar_> arjanb: ok.. thanks. What specifically does that do?
12:26:00 <arjanb> turns on the common ghc extensions
12:26:24 <arnar_> ok
12:27:02 <arnar_> I'm working with my  module in ghci.. doing ":load mod" to reload it.. does that work with defining {-# OPTIONS_GHC ... ?
12:27:26 <duschendestroyer> isn't there a straightforward way to decode the length in the type?
12:30:21 <dolio> duschendestroyer: http://hpaste.org/7094
12:31:58 <duschendestroyer> dolio: nice
12:32:15 * SamB looks for an RSS feed of type-derivative papers
12:33:33 <dolio> arnar_: In the future, if you do need to refer to variables, you do it like this: http://hpaste.org/7093#a1
12:35:58 <arnar_> dolio: nice.. thanks
12:36:05 <arnar_> the "forall" is necessary as well?
12:36:54 <dolio> Yeah. It doesn't do the lexical scoping if you don't use explicit foralls.
12:37:25 <arnar_> thanks
12:44:17 <adiM> @pl     total row = foldr ((+).snd) 0 row
12:45:03 <SamB> which is an excellent way to avoid the possibility of the extension breaking or changing the meaning of Haskell 98 code
12:45:39 <Twey> adiM: total = foldr ((+) . snd) 0
12:46:35 <dmwit> total = sum . map snd -- ?
12:46:36 <Twey> But it looks to me like you'd be better off with total = (foldr (+) 0) . (map snd)
12:46:51 <Twey> Oh, yeah.  That's what sum does.  Heh
12:47:30 <dmwit> foldr will stack-explode for even modestly sized lists, there.
12:47:35 <arnar_> @src sum
12:47:51 <dmwit> sum = foldl (+) 0
12:47:55 <dmwit> But, I often define
12:48:00 <dmwit> sum = foldl' (+) 0
12:48:04 <opqdonut> mhmm
12:48:12 <opqdonut> i call that sum' usually :P
12:48:12 <xerox> Congradulations to all the students accepted for this year Summer of Code! Yay!
12:48:15 <Twey> Isn't it effectively the same?
12:48:22 <arnar_> dmwit: what if 0 is not the unit?
12:48:32 <Twey> And why is \bot unhappy with us?  :-(
12:48:48 <dmwit> arnar_: Then you should use msum and a good instance of Monoid.
12:49:00 <arnar_> ah, ok
12:50:24 <SamB> perhaps a newtype?
12:51:54 <adiM> dmwit, Twey: wouldn't total= sum . map snd iterate the list twice, while (fold (+). snd) 0 iterate it once?
12:51:58 <SamB> hmm, google are awfully presumptuous with their "just installed" pages for firefox extensions...
12:52:10 <augustss> Am I the only one that hates the word newtype?
12:52:46 <SamB> augustss: why do you hate it?
12:52:58 <SamB> it does what it says -- makes a new type
12:53:21 <monochrom> I don't hate anything. But I know newbies read too much into the words "data", "type", "newtype", and get confused.
12:53:25 <SamB> sometimes, I wish C could do that
12:53:26 <Twey> adiM: No, map is lazy
12:53:29 <thoughtpolice> dons: see you uploaded a bunch of great stuff to hackage, stuff you use at galois I assume?
12:53:30 <augustss> But it's not a new type, it's just a type isomorphic to an existing type
12:53:43 <monochrom> But it's also a new type.
12:53:48 <SamB> augustss: but distinct from
12:53:52 <augustss> OK, I don't hate newtype, I just dislike iot
12:54:02 <SamB> what would you prefer it be called?
12:54:11 <augustss> isotype perhaps
12:54:20 <SamB> and that would help how
12:54:33 <SamB> then the newbies would think this somehow related to an ISO standard!
12:54:40 <monochrom> We wouldn't argue over the semantics of "new".
12:54:43 <allbery_b> I have to admit the relationships between data, type, newtype are not the clearest
12:54:47 <SamB> or, worse, chemistry
12:54:55 <augustss> well, it doesn't really help, it could be called glurph if we wanted
12:55:18 <adiM> Twey: I thought that lazy meant that it will not evaluate the expression. I thought that the compiler will store shometing like [snd i | i <- list] without evaluating each element, but still applying the function to everything
12:55:23 <augustss> data could have been called newtype, it would have made as much sense
12:55:35 <SamB> augustss: I don't think much would help except getting a decent canonical tutorial together and well-linked that explained it...
12:56:08 <Twey> adiM: It applies the function when you need the value
12:56:08 <augustss> SamB: I don't care about the newbies, I care about me :)
12:56:13 <allbery_b> I'd kinda prefer type were called typealias or something like that.  I'm not sure what would be a good name for newtype though
12:56:17 <augustss> I also dislike the name Haskell
12:56:27 <SamB> augustss: you are confused by the name newtype?
12:56:29 <monochrom> I have seen newbies here having read decent tutorials and still say "why is data called data, why is type called type".
12:56:39 <Twey> adiM: Thus, you can do this: take 10 $ map (*2) [1..]
12:56:41 <augustss> allbery_b: typealias would be more like type
12:56:50 <monochrom> There is no end to these semantics bickerings.
12:57:02 <adiM> Twey: Ah, now it makes sense.
12:57:02 <allbery_b> augustss: I thought that was ewhat I said?
12:57:09 <augustss> SamB: Not confused, I just think it's ugly
12:57:09 <saml> data Type = TVar String | TApp Type Type | TConst String      how can I parse  "a -> [Int] -> m b"  where ->, Int, []  are TConst
12:57:16 <monochrom> I have learned a way out, IMO the only way out.  Semantics doesn't exist.  It's all syntax.
12:57:24 <augustss> allbery_b: sorry, I read new type
12:57:25 <SamB> I would have no objection to "type alias" replacing "type"
12:57:31 <SamB> in a gradual manner
12:57:45 <allbery_b> newtype, hm, `distinct'?
12:57:57 <xerox> "type a" "type al" ... "type alias" minor version by minor version? heh
12:58:02 <SamB> would anyone like me to implement it now for GHC and JHC?
12:58:08 <allbery_b> (since it introduces a distinct instance of an existing type)
12:58:12 <saml> TApp (TApp (TConst "->") (TVar "a")) (TApp (TConst "[]") (TConst "Int")) ...
12:59:01 <allbery_b> maybe `distinguish'
12:59:06 <Bonus> how come i can do
12:59:17 <Bonus> ... exitWith ExitSuccess >>= hGetContents >>= ...
12:59:19 <SamB> allbery_b: unfortunately we can't just make a new "distinct type" declaration
12:59:39 <Bonus> hGetContents expects a handle type
12:59:42 <SamB> or, wait, yes we can
12:59:44 <allbery_b> yeh, I know, I'm just noodling how I wish it had been done.  clearly not something that can be done with Haskell now
12:59:50 <SamB> since type isn't a legal variable ;-)
13:00:34 <dolio> If you're going to make "type alias" is there some other word where "type _" would make more sense than newtype?
13:00:47 <monochrom> Bonus: Strange!
13:00:52 <wolverian> hm, is there haskell bindings for gtksourceview2?
13:00:52 <allbery_b> distinction?
13:01:00 <allbery_b> wolverian: part of gtk2hs
13:01:08 * Heffalump would quite like people not to make gratuitous syntax changes
13:01:09 <allbery_b> hm, ver 2 not sure of
13:01:11 <wolverian> the bindings on ubuntu are for sourceview1
13:01:17 <Heffalump> those names may not be perfect, but they're adequate
13:01:18 <allbery_b> ask dcoutts
13:01:31 <wolverian> dcoutts_, are there haskell bindings for gtksourceview2? :)
13:01:31 <SamB> Heffalump: these would not break compatability
13:01:33 <dcoutts> wolverian: it should be fairly straightforward to update to gtksourceview2 if you want that
13:01:44 <dcoutts> wolverian: we accept patches :-)
13:01:47 <wolverian> okay. well, I don't have specific requirements yet.
13:01:48 <SamB> the sooner they happen, the sooner we can get them into the next standard
13:01:51 <Heffalump> even adding gratuitous extra syntax to confuse people would be bad
13:02:06 <dcoutts> wolverian: the api changes are pretty small so adapting the existing bindings should be easy to convert
13:02:16 <allbery_b> considering the confusion caused by the existing names, I'm not sure how much of an argument that is
13:02:16 <SamB> Heffalump: not intended to confuse people...
13:02:18 <Twey> ({({(newtype distinct)})})
13:02:20 <monochrom> Bonus: I see, it's because exitWith :: ... -> IO a.  It can pretend to return anything.  The idea is it doesn't matter, program execution can't continue anyway.
13:02:22 <Heffalump> well, it would
13:02:23 <SamB> Heffalump: these would be an extension
13:02:28 <SamB> to start with
13:02:39 <Heffalump> having two names for one thing is just silly
13:02:49 <Bonus> aha, yeah i know it doesnt matter
13:02:55 <Bonus> i was just thinking why the type system lets it through
13:02:56 <SamB> well, the old way would eventaully become deprecated
13:03:05 <allbery_b> I was wondering about that.  I'd think IO () would make more sense
13:03:10 <allbery_b> like in haskel''''?
13:03:14 <Heffalump> thus moving us to the heading of "gratuitous syntax changes"
13:03:29 <SamB> Heffalump: yes, so?
13:03:39 <SamB> you think it would make code too wide?
13:03:51 <SamB> augustss: what think you?
13:03:55 <Heffalump> no, I think it would cause way more pain than any possible benefit
13:03:57 <SamB> monochrom: you?
13:04:27 <monochrom> "if b then exitWith ... else getChar"  you will want exitWith to be polymorphic, not just IO().
13:05:14 <Bonus> ah so exitWith is doing polymorphic typing
13:05:18 <Bonus> i have to read up on that
13:05:24 <Bonus> but what *does* it actually return?
13:05:25 <Heffalump> @type exitWith
13:05:30 <Heffalump> Bonus: probably undefined
13:05:35 <monochrom> It has no chance to return anything.
13:05:43 <Bonus> so it can return undefined as any type that's expected of it?
13:06:02 <Bonus> yeah it doesn't return anything actually because the program ends but you know
13:06:05 <Bonus> theoretically
13:06:21 <augustss> I think we should abolish all keywords in Haskell
13:06:22 <monochrom> It returns the sound of a tree that falls down in a forest but no one is around to hear it.
13:06:25 <SamB> @go imprecise exceptions
13:06:28 <Bonus> haha
13:06:41 <SamB> bad lambdabot
13:06:55 <monochrom> I'm serious. In this case what it returns is pure philosophy.
13:06:58 <Bonus> > show "im gaye"
13:07:06 <Bonus> gah still doesnt work!
13:07:16 <SamB> http://research.microsoft.com/research/pubs/view.aspx?type=Publication&id=383
13:07:21 <Bonus> if we abolished all keywords in haskell wouldn't it become a sort of a static lisp?
13:07:51 <SamB> Bonus: noone would want to abolish all keywords
13:07:57 <monochrom> If you play with continuations and callcc, you will understand more what goes on and why its type is polymorphic, even polymorphic when you let automatic type inference kick in.
13:08:01 <SamB> change the existing ones, fine
13:08:17 <Heffalump> keywords are a necessary evil given the limitations of parsing technology
13:08:27 <Heffalump> I'm all for abolishing them apart from that.
13:08:48 * allbery_b not so certain of that
13:09:20 <Bonus> yeah i still have learn about callcc, the cont monad and exceptions
13:09:29 <allbery_b> good way to introduce strange errors.  (FORTRAN IV, anyone?)
13:09:30 <Bonus> i'm happy i now understand the general concept of monads though
13:09:38 <Bonus> a few days ago it just clicked
13:09:47 <monochrom> PL/I rules.  if if=then then then=else else else=if
13:09:54 <Heffalump> bonus: it all seems very simple in retrospect, doesn't it? :-)
13:09:59 <Bonus> yeah haha
13:10:04 <Bonus> exactly what i was thinking
13:10:12 <Bonus> also i felt compelled to write a tutorial about monads
13:10:13 <Heffalump> monochrom: if people choose to write obfuscated code that's up to them
13:10:16 <allbery_b> I'm recalling the story of the probe that malfunctioned because of a dropped comma in a DO
13:10:25 <monochrom> I'm being sarcastic!
13:10:29 <Heffalump> strangely I've never felt compelled to do that. I have explained them on here a few times though.
13:10:45 <Heffalump> monochrom: I thought you were arguing against removing keywords.
13:11:38 <Bonus> i think a lot of the tutorials on monads lose a lot of clarity because they want the explanation to be theoretically correct
13:12:14 <Bonus> it think for newbies it would be nice if there was a tutorial that explains them a bit more loosely and doesn't worry so much on being 100% correct in theory
13:12:27 <monochrom> There are now phishing techniques available to pretend to re-define keywords.
13:13:15 <jorick> getCurrentTime >>= return . read . formatTime defaultTimeLocale "%s" :: IO Int
13:13:45 <dcoutts> nominolo: congratulations
13:14:01 <dcoutts> http://code.google.com/soc/2008/haskell/about.html
13:14:12 <nominolo> yay!
13:14:27 <dcoutts> nominolo: look who got the highest ranked project :-)
13:14:46 <nominolo> dcoutts: my student dashboard didn't show me what i got assigned to
13:14:56 <dcoutts> you can't see the absolute ranking scores but they're in order
13:14:56 <monochrom> dt f = f + 1
13:14:57 <nominolo> dcoutts: i only got the congrat email
13:15:01 <jorick> is there a better way to get the number of seconds since the epoch?
13:15:02 <SamB> hooray for Language.C
13:15:05 <nominolo> dcoutts: i see
13:15:17 <SamB> I hope it goes better this year than last!
13:15:19 <dcoutts> SamB: indeed :-)
13:15:34 <nominolo> dcoutts: were there other applications for this proposal?
13:17:05 <dolio> Ooo, generalized tries.
13:17:14 <dolio> It's about time.
13:17:31 <nominolo> oh cool, we get a parallelised physics engine
13:17:45 <nominolo> -"ised"
13:18:09 <monochrom> Does it do parallel universe physics?
13:20:25 <dons> http://reddit.com/info/6gl5l/comments/ yay
13:20:30 <dons> Haskell projects announced for the Google Summer of Code! [programming] (code.google.com)
13:20:33 <dons> good news day.
13:20:57 <cjb> no fair, you guys got more slots than OLPC :)
13:21:02 <SamB> dons, yes, we just noticed
13:21:11 <SamB> cjb: well, what is OLPC actually doing?
13:21:20 <SamB> also don't they get funding from other sources?
13:21:34 <SyntaxNinja> yo
13:21:52 <dcoutts> hia SyntaxNinja
13:21:54 <cjb> SamB: yeah, we get donations from large companies sometimes.
13:22:30 <SamB> I think GSOC is perhaps more about helping students than helping projects
13:22:30 <SyntaxNinja> hiya dcoutts
13:22:50 <olsner> ooh, stand-alone C99 parser ... add your own templates and you almost have a C++ compiler :>
13:22:53 <cjb> SamB: I wasn't really griping.  Haskell is cool too
13:26:11 * SamB runs kdirstat to get an idea where his disk space has gone...
13:40:53 <dancor> @pl f = if x == True then True else False
13:40:59 <dancor> :pl f = if x == True then True else False
13:41:21 <dancor> @bot
13:41:33 <elliottt> ?bot
13:42:28 <opqdonut> not alive
13:42:50 <lament> in any case we know the @pl plugin can't handle if/then/else
13:43:27 <lament> also, your expression is already pointfree
13:43:34 <lament> (perhaps you meant f x?)
13:43:39 <dolio> It turns it into if'.
13:43:52 <lament> it should do nothing to that expression since it's pointfree already
13:43:54 <dons> ?quit bot
13:44:20 <dolio> Yesterday it was trying to reconnect, but couldn't because freenode wouldn't drop the ghost.
13:47:51 <saml> @where parsec
13:49:11 <EvilTerran> ?bot
13:50:08 <dons> cale's out
13:50:28 <elliottt> he's the bot? :)
13:51:47 <dons> yeah, py-oauth looks simple enough
14:11:11 <adiM> Is there a function with the signature IO [String] -> [String]
14:11:24 <SamB> adiM: no...
14:11:24 <adiM> I want to get rid of the IO from a list of strings
14:11:35 <SamB> are you in a do block?
14:11:55 <adiM> I want to read a list of strings from a file and convert them to floats and do some processing on them
14:12:14 <SamB> well, you more or less need to do that in a do block
14:12:16 <dobblego> adiM, you don't want to remove that IO (and even if you did, you can't)
14:12:27 <dobblego> adiM, you perform that computation inside your do block
14:12:43 <Bonus> do something lik
14:13:12 <Bonus> main = openFile "yourfile.txt" ReadMode >>= hGetContents >>= putStr . parseContents
14:13:23 <Bonus> where parseContents is a function you'll write
14:13:31 <opqdonut> with type String->String
14:13:32 <Bonus> it will accept a string and return a string
14:13:33 <Bonus> yeah
14:13:47 <Bonus> or at the end do
14:13:50 <dolio> @type readFile
14:13:53 <Bonus> putStr . parseContents  . lines
14:13:59 <dolio> Oh, right.
14:14:00 <Bonus> so then it will get [String]
14:14:05 <Bonus> and each will be a line in the file
14:15:47 <saml> @pl f a b = a ++ " " ++ b
14:17:04 <dolio> (++) . (++ " ")
14:17:39 <adiM> Bonus: Thanks, that method is working for my toy example. I will try it on the main problem. Thanks
14:17:47 <Bonus> cool
14:21:52 <mofmo1> alright, so what could cause a program to work differently compiled and under ghci?
14:22:13 <dolio> Infinite loops.
14:22:22 <dons> mofmo1: type defaulting, too.
14:22:28 <dons> handle flushing
14:22:37 <mofmo1> oh that might be it
14:22:49 <olsner> output buffering has caught me a few times
14:22:50 <dolio> Inlining unsafePerformIO. :)
14:22:58 <dons> ghci's for testing only.
14:23:02 <dons> yes, optimisations firing
14:23:06 <dons> no strictness analysis in ghci
14:23:17 <mofmo1> i have a cellular automata program that updates the state under ghci but hangs under ghc
14:23:19 <sjanssen> ghci is -threaded, while ghc is not by default
14:23:31 <dons> we should have a wiki page
14:23:39 <mofmo1> even with the -threaded option i still get weird behaivor
14:23:43 <dons> since some of the differences can be interpreted as bugs
14:24:00 <mofmo1> dons: exactly my problem
14:25:04 <sjanssen> mofmo1: are you using threads? FFI? Buffered IO?
14:25:44 <mofmo1> sjanssen: buffered io
14:26:00 <mofmo1> well not really all taht buffered
14:26:07 <mofmo1> lemme hpaste what i think the culprits are
14:26:16 <sjanssen> ghci sets standard in and out to NoBuffering, but ghc is line buffered by default
14:26:35 <mofmo1> i have hFlush stdout
14:26:40 <mofmo1> in the main
14:26:47 <stwange> what's the name for a function where f(x) = y but many different x's can evaluate to y? I know the informal term is many-to-one, but I can't find the actual name of it. Like a hash function.
14:27:40 <mofmo1> it's either bijective, surjective or injective
14:28:03 <dolio> Nah, it's not injective.
14:28:09 <dolio> I don't know if there's a special term for that.
14:28:10 <Cale> "not injective"
14:28:24 <Cale> Is the special term for it ;)
14:28:27 <olsner> exjective? :P
14:28:28 <stwange> it's not bijective either... and I don't think it's surjective because that mentions it being reversible
14:28:44 <monochrom> many-to-one is just fine.
14:28:50 <Cale> It very well could be surjective.
14:29:01 <olsner> or ejective, that sounds better
14:29:02 <Cale> Consider the case where the codomain is a single point.
14:29:03 <monochrom> both many-to-one and not injective.
14:29:23 <dolio> Cale: Your bot is misbehaving again. :)
14:29:27 <Cale> mbot?
14:29:29 <monochrom> It could be surjective but it could also be not surjective.
14:29:31 <stwange> thanks, I'll stick with many-to-one and just explain it :)
14:29:32 <dolio> \bot
14:29:33 <Cale> Or lambdabot?
14:29:44 <dolio> > 1 + 2
14:29:45 <Cale> grumble
14:30:36 <monochrom> Same symptoms as last night?
14:30:51 <Cale> FreeNode seems really poor at detecting when a connection has been dropped.
14:31:24 <mofmo1> So I dont think the problem is in Main http://hpaste.org/7096
14:31:27 <Cale> Lambdabot was trying to reconnect but isn't smart enough to take another nick and ghost the old lambdabot itself.
14:31:38 <mofmo1> everything comes out right until i get to evalLoop
14:32:33 <Cale> mofmo1: btw, the standard way to indent if-then-else is like:
14:32:35 <Cale> if foo
14:32:37 <Cale>    then bar
14:32:40 <Cale>    else quux
14:33:04 <mofmo1> oh right
14:33:15 <mofmo1> anyways here's evalLoop and the stuff it calls
14:33:16 <mofmo1> http://hpaste.org/7097
14:33:42 <mofmo1> i wasnt really sure how to do helper functions right so update board is terribly ugl
14:34:18 <mofmo1> but that's secondary to ghc working differently than ghci
14:34:55 <mofmo1> and the Board data type is Board (x,y) d list-holding-the-data
14:35:22 <mofmo1> (x,y) is a location cursor inside list-holding-the-data and d is the line length of the Board.
14:35:23 <Cale> I'd probably factor things a little differently with regard to printing -- separate it into converting the board into a string (which is a pure function) and actually doing the I/O (which is then trivial)
14:35:51 <Cale> er, hmm
14:35:59 <mofmo1> wait i do sort of do that
14:37:34 <Cale> So everything I need to try this is in these pastes?
14:37:39 <mofmo1> no
14:37:50 <mofmo1> i also think the adt i came up for this is totally inefficient
14:38:08 <mofmo1> is there any way to paste all my files? i might go over the limit
14:38:09 <adiM> @pl f x = "a" ++ show x
14:38:11 <lambdabot> f = ('a' :) . show
14:38:32 <adiM> @pl f x = "abc" ++ show x
14:38:32 <lambdabot> f = ("abc" ++) . show
14:38:38 <Cale> mofmo1: You can always just add the rest in an annotation
14:40:20 <mofmo1> should be four separate files
14:40:20 <mofmo1> http://hpaste.org/7098#a1
14:40:31 <mofmo1> Main.hs, Eval.hs, Board.hs, ParseFile.hs
14:40:49 <mofmo1> or you can delete the intermedialte module ablhalbh where import albhalbha stuff
14:40:56 <mofmo1> i dont think anything overlaps
14:41:46 <Cale> I think ParseFile got cut off?
14:42:03 <mofmo1> oh
14:42:05 <Cale> mm, and the end of Board
14:42:10 <mofmo1> board and parsefile got cut off
14:42:42 <mofmo1> http://hpaste.org/7099
14:43:30 <mofmo1> http://hpaste.org/7099#a1
14:43:38 <mofmo1> alright, board is the top, parsefile is the annotation
14:45:02 <dolio> @seen SamB
14:45:03 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
14:45:08 <SamB> I am here
14:45:25 <dolio> You said you wanted stuff on differentiation of data types earlier?
14:45:25 <SamB> Cale: something is not right!
14:45:34 <Cale> oh damn
14:45:36 <Cale> that again.
14:45:37 <SamB> dolio: I specifically mentioned an RSS feed
14:45:44 <dolio> Ah.
14:45:49 <SamB> atom would of course do just as well...
14:46:08 <Cale> lambdabot: @quit
14:46:09 <dolio> I don't know if you've seen this, but you might find section 4 of this interesting: http://www.cs.nott.ac.uk/~pwm/thesis.pdf
14:46:15 <Cale> @seen Cale
14:46:19 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
14:46:23 <Cale> huh.
14:46:41 <dons> crashed.
14:46:46 <SamB> Cale: what, you didn't think the bottom was going to disappear between invocations, did you?
14:46:48 <Cale> @seen Cale
14:46:53 <lambdabot> You are in #ghc and #haskell. I last heard you speak just now.
14:47:01 <Cale> SamB: hm?
14:47:09 <Cale> SamB: I removed State/seen
14:47:20 <Cale> SamB: But then when it quit, it rewrote it.
14:47:20 <SamB> the state for the seen plugin was still the same heap object!
14:47:31 <Cale> huh?
14:47:33 <SamB> wasn't it?
14:47:49 <SamB> why would lambdabot reread the state file in the middle of a run?
14:47:54 <Cale> No, lambdabot quit, and was restarted by my shell script.
14:48:06 <SamB> oh, right
14:48:20 <SamB> but it tried to write the _|_ back to the file ^_^
14:49:02 <monochrom> @seez wli
14:49:06 <Cale> btw, if you know what's wrong with the Seen plugin, a patch to fix it would be really cool
14:49:09 <lambdabot> I haven't seen wli.
14:49:21 <ddarius> What has changed with it?
14:49:30 <Cale> I haven't touched it.
14:50:01 <Cale> If the file State/seen exists when lambdabot starts, it's broken.
14:50:16 <Cale> And it never writes the state correctly to that file, it seems.
14:50:26 <Cale> (it always makes a blank file)
14:50:40 <mofmo1> cale: did it compile for you?
14:50:51 <SamB> Cale: is it trying to read state lazily?
14:51:00 <Cale> I'm missing gameBoard3
14:51:04 <mofmo1> oh
14:51:05 <mofmo1> right
14:51:10 <Cale> SamB: I don't know :)
14:51:42 <mofmo1> http://hpaste.org/7099#a2
14:51:45 <mofmo1> second annotation
14:51:49 <SamB> is it using Data.ByteString.Lazy?
14:52:46 <adiM> @pl prepend str list = unwords $ map ((str ++). show) list
14:52:46 <lambdabot> prepend = (unwords .) . map . (. show) . (++)
14:52:47 <Cale> Hmm, it's using Data.ByteString.Char8's readFile, but then making a lazy bytestring using fromChunks
14:53:21 <SamB> Cale: hmm, that shouldn't be the issue then :-(
14:53:38 <Cale> mofmo1: Cool, so this is working in ghci
14:53:46 <mofmo1> of course
14:54:02 <monochrom> Eh, working in ghci, not working after compilation?
14:54:07 <mofmo1> yeah
14:54:09 <bos> damn, hackage is really annoying to deal with lately.
14:54:12 <mofmo1> if you invoke main
14:54:13 <Cale> okay, I'll compile it
14:54:15 <mofmo1> type in no
14:54:18 <mofmo1> and itll run gameBoard3
14:54:22 <mofmo1> if that's not obvious
14:54:41 <Cale> hmm, that's interesting :)
14:54:41 <monochrom> What are the symptoms? Wrong I/O order?
14:54:48 <Cale> ah, that could be it
14:54:51 <mofmo1> nothing happens/bad output
14:54:55 <ddarius> bos: ?
14:55:01 * Cale tries something
14:55:04 <mofmo1> for example gameBoard3 is a glider and it doesn't glide it jumps all ove rthe place
14:55:26 <mofmo1> after CGoL i'm going on to CGoL2 complete with comonadic evaluation -_-
14:55:29 <Cale> yep
14:55:33 <Cale> it was I/O buffering
14:55:36 <bos> ddarius: the server side is much more anal than local builds, so uploading is a matter of repeated trial and error.
14:55:37 <mofmo1> oh i see
14:55:44 <Cale> Add  hSetBuffering stdout NoBuffering
14:55:45 <mofmo1> so how do i fix this
14:55:48 <Cale> to the top of main
14:56:02 <bos> ddarius: build locally, everything is fine. upload, server complains. try to fix. can't reproduce locally. upload. new failure. pull hair out.
14:56:05 <Cale> Or add explicit hFlush calls
14:56:12 <monochrom> I prefer programmed flusing, but I'm a performance freak.
14:56:14 <Cale> (if you really care about buffering)
14:56:29 <Cale> That's probably not going to make a hell of a lot of difference here :)
14:56:42 <visof> can we do the application of AI by FP ?
14:56:44 <mofmo1> so yeah, what's the most efficient functional way to evaluate a CA state?
14:56:49 <Cale> The threadDelays are actually where most of the time is spent.
14:56:57 <mofmo1> really?
14:57:07 <mofmo1> when i get boards with line sizes of 100 and 100 rows
14:57:11 <mofmo1> it gets realllly slow
14:57:14 <Cale> (er, I'm assuming there are threadDelays)
14:57:28 <mofmo1> of course that's n^2 growth
14:57:40 <Cale> ah, yeah
14:58:00 <Cale> You should probably use UArrays for the boards.
14:58:04 <mofmo1> i was thinking the comonadic way won't be all that faster
14:58:07 <mofmo1> UArrays?
14:58:20 <Cale> Unboxed arrays.
14:58:27 <mofmo1> i dont know if it's that i make NEW gameboards in evaluating life or if lists are O(n) time for accessing
14:58:29 <mofmo1> or both
14:58:43 <Cale> An unboxed array of booleans is stored as a bit pattern
14:58:56 <Cale> So although you
14:59:02 <mofmo1> O(1) time for accessing?
14:59:04 <roconnor> I want to take the ration of two NominalDiffTimes.  How do I convert them to Doubles or whatever?
14:59:06 <Cale> yep
14:59:12 <mofmo1> do you think that's the bottleneck?
14:59:19 <roconnor> Oh right, fromIntegral or something
14:59:34 <Cale> but O(n) time for updates, but that doesn't matter so much, since the values will be tiny so long as the thing fits on your screen :)
15:00:05 <mofmo1> cool
15:00:06 <mofmo1> thanks
15:00:16 <Cale> If you're using lists to represent your boards, then yeah.
15:00:30 <Cale> Lists are only good for things which are accessed roughly linearly.
15:00:39 <mofmo1> thanks, gotto go to class now
15:00:41 <Cale> (which is really really common, but isn't the case here)
15:06:43 <fnord123> I saw the summer of code project to add dynamically loaded plugins for ghc at http://code.google.com/soc/2008/haskell/appinfo.html?csaid=69C2ABD1E013EE0C
15:06:45 <lambdabot> Title: Google Code - Summer of Code - Application Information, http://tinyurl.com/4jazzr
15:06:48 <dons> Igloo: why isn't hmp3 packaged on debian? we get lots of queries in #xmonad about "what nice console music player" it is.
15:07:19 <fnord123> I'm curious what the intended use of this will be? why would someone want dynamically loaded code in something you run like a script?
15:08:23 <fnord123> the examples given could be implemented with different pieces piping into each other like llvm does (afaik)
15:10:16 <monochrom> E.g., I have a server written in haskell. Oops, I find a bug. I modify a module a bit, compile, then unload the old module binary and load the new module binary.
15:10:57 <monochrom> Also s/I find a bug/I want a new feature/
15:12:18 <sw17ch> dons, you work for Galois right?
15:12:54 <dolio> That's not the kind of dynamic loading that project is about.
15:12:54 <Igloo> dons: Only because no-one has packaged it
15:13:14 <dolio> It's about adding passes to GHC's compile process.
15:13:17 <thoughtpolice> fnord123: well the project is about giving users the ability to write plugins for *ghc* so you can add optimization passes, etc.
15:13:37 <dons> sw17ch: yeah
15:13:41 <thoughtpolice> you can already dynamically load plugins at runtime in your application via hs-plugins/ghc-api
15:14:15 <sw17ch> dons, this JSON library is sweet. :) pass the thanks along for opening it
15:14:24 <dons> yay
15:14:40 <monochrom> oops
15:15:20 <shapr> Yow!
15:15:38 <dons> now i can push those patches to lambdabot to support rss and xml
15:15:45 <shapr> yay!
15:16:02 <shapr> It's nice to have energy.
15:17:14 <monochrom> You always have energy. If anything, you always have mass.
15:17:47 <ddarius> And thus are full of inertia.
15:18:14 <SamB> dons: support doing what with them?
15:18:45 <fnord123> ok so it's essentially in line with Don's dynamic program structures, like Yi, and like XMonad has. I considered that to be something useful for long running programs. It surprised me that such a strategy would be used for a program like ghc
15:18:46 <dons> SamB: i've some nice plugins for grabbing rss and xml sources (weather, trains)
15:19:23 <dons> fnord123: the ghc plugins idea came from using hs-plugins for things.
15:19:28 <dons> drop-in optimisations
15:19:40 <SamB> dons: eh?
15:19:46 <fnord123> which is what yi does, isn't it?
15:19:51 <fnord123> what yi uses, pardon
15:20:19 <SamB> ooooh
15:20:24 <SamB> plugins for GHC, neat idea
15:20:25 <dons> yay!
15:20:40 <SamB> GHC is hopefully not long-running, but it is long-installed for sure
15:20:57 <shapr> dons: Are the SoC slots public info now?
15:21:03 <dons> yep
15:21:33 <shapr> Ok then, I'm glad the NDP project made it in!
15:21:45 <fnord123> ok, it makes sense. so my next question is how people are finding dependency management for xmonad.contrib. am I missing out by not having cabal-install installed?
15:21:57 <shapr> I think Language.C will be far more useful than anyone suspects.
15:22:18 <thoughtpolice> wasn't Language.C already proposed previously and worked on in a SoC?
15:22:20 <SamB> shapr: most likely
15:22:27 <fnord123> I think Language.C will be amazinf
15:22:29 <SamB> thoughtpolice: in theory yes
15:22:31 <adiM> @pl f x = g h i (f x)
15:22:32 <lambdabot> f = fix (g h i .)
15:22:37 <elliottt> fnord123: cabal install forced me to install the x11-xft package
15:22:46 <adiM> @pl f x = g h i (j x)
15:22:46 <lambdabot> f = g h i . j
15:22:54 <elliottt> however, you can pass it --flags=-use_xft to disable that.
15:22:57 <SamB> thoughtpolice: but apparantly it didn't end up with a usable result
15:26:09 <SamB> hmm, I finally installed iceweasel and suddenly my firefox icon now looks like an iceweasel instead of a globe
15:26:34 <SamB> all I did was open the properties dialog...
15:27:42 <adiM> How do I convert from an Int to float?
15:27:52 <adiM> fromIntegral works only from Integer
15:27:52 <ddarius> @quote fromIntegral
15:27:53 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
15:27:58 <monochrom> Yeah! :)
15:28:01 <ddarius> :t fromIntegral
15:28:05 <lambdabot> forall a b. (Num b, Integral a) => a -> b
15:28:26 <Baughn> > fromIntegral (3 :: Int) :: Double
15:28:27 <lambdabot>  3.0
15:28:32 <adiM> Thanks, I was confused between fromInteger and fromIntegral
15:28:43 <roconnor> @hoogle realfrac
15:28:46 <lambdabot> Prelude.RealFrac :: class (Real a, Fractional a) => RealFrac a
15:29:01 <roconnor> @hoogle real
15:29:02 <adiM> @show fromIntegral
15:29:02 <lambdabot> Prelude.Real :: class (Num a, Ord a) => Real a
15:29:02 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => a -> b
15:29:02 <lambdabot> Data.Complex.realPart :: RealFloat a => Complex a -> a
15:29:02 <lambdabot> "fromIntegral"
15:51:10 <adiM> how do I take every 5th element from a list?
15:52:25 <dibblego> > map fst (filter (\(_, i) -> i `mod` 5 == 0) (zip ['a'..'z'] [0..]))
15:52:25 <lambdabot>  "afkpuz"
15:52:40 <dons> > let f [] = []; f (_:_:_:_:a:rest) = a : f rest ; f xs = xs in f ['a'..'z']
15:52:41 <lambdabot>  "ejotyz"
15:53:15 <dons> indicies are for arrays, patterns are for lists :)
15:54:06 <dbueno> dons: How do I take every 1000'th element of a list? ;-]
15:54:28 <dons> with a pattern, of coruse
15:54:31 <dibblego> > replicate 1000 "_:"
15:54:32 <lambdabot>  ["_:","_:","_:","_:","_:","_:","_:","_:","_:","_:","_:","_:","_:","_:","_:",...
15:54:33 <adiM> :D
15:54:35 <monochrom> hahahahaha
15:54:41 <ivanm> dibblego: lol
15:54:52 <tibbe> good evening #haskell
15:54:56 <dons> heya tibbe
15:55:12 <monochrom> @remember dons [on how take every 1000'th element of a list] with a pattern, of coruse
15:55:12 <lambdabot> Nice!
15:56:04 <dons> > head . snd $ splitAt 999 [1..]
15:56:05 <lambdabot>  1000
15:56:20 <ivanm> is it a coincidence that lambdabot thinks anything @remembered about dons is nice? :p
15:56:34 <monochrom> Yeah, some kind of loop over splitAt.
15:56:43 <Jedai> dbueno: unfold (get n) where get n xs = let (as,bs) = splitAt n xs in if null bs then Nothing else Just (head bs, tail bs)
15:57:10 <Jedai> Or something...
15:57:21 <dons> oh, an unfold
15:57:28 <dons> i'd not have thought of that.
15:57:33 <dbueno> Jedai: Thanks, but I was just ribbing dons because of his comment about indices/arrays, patterns/lists
15:58:32 <Jedai> dbueno: Yeah, but this question is often asked, maybe a "splitEvery" should really get into Data.List
15:58:49 <augustss> Jedai: yes!
15:58:58 <lament> nice: http://blogs.concedere.net:8080/blog/discipline/software+engineering/?permalink=Hell-is-Other-Peoples-Code.html
15:59:03 <lambdabot> Title: discipline and punish, http://tinyurl.com/5yocg6
15:59:17 <lament> "software engineering isn't about solutions at all. It's about problems. This seems counter-intuitive -- until the day you have to maintain a bunch of legacy code. On that day you'll quickly realize that solutions are the biggest problem of all."
15:59:22 <dbueno> Jedai: I think that's a good suggestion, and I like your unfold.
15:59:52 <gnuvince_> Jedai: what would splitEvery do? splitEvery :: Int -> [a] -> [[a]]?
16:00:29 <Jedai> gnuvince_: Yes, and split the list in packet of length n (except the last in some case)
16:00:39 <dons> bytestring as a breakSubstring for this
16:00:41 <dibblego> ?type \x v -> if(Data.Foldable.foldr (const (const False)) True x) then mzero else return v -- does this function exist somewhere?
16:00:42 <lambdabot> forall a (t :: * -> *) (m :: * -> *) a1. (MonadPlus m, Data.Foldable.Foldable t) => t a -> a1 -> m a1
16:00:53 <dons> -- > tokenise x y = h : if null t then [] else tokenise x (drop (length x) t)
16:00:54 <dons> -- >     where (h,t) = breakSubstring x y
16:01:02 <dons> if you want to find all tokens, for example
16:01:12 <dons> breakSubstring's like splitAt
16:01:37 <dons> doubt it, dibblego
16:01:46 <adiM> How about this for dropping n'th element
16:01:49 <adiM> > let dropN k [] = []; dropN k list = (head list) : (dropN k $ drop (k-1) list) in dropN 5 [1..100]
16:01:49 <lambdabot>  [1,5,9,13,17,21,25,29,33,37,41,45,49,53,57,61,65,69,73,77,81,85,89,93,97]
16:02:15 <adiM> Did I just write my fist recursive function :)
16:02:29 <adiM> -fist-  first
16:02:33 <ivanm> maybe... have you written one before?
16:02:54 <adiM> not something so "complicated"
16:03:15 <dolio> @let stopWhen p f x = if p x then Nothing else Just (f x)
16:03:16 <lambdabot> Defined.
16:03:59 <dolio> > unfoldr (stopWhen null $ splitAt 5) [1..20]
16:04:00 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20]]
16:04:12 <dolio> > unfoldr (stopWhen null $ first head . splitAt 5) [1..20]
16:04:13 <lambdabot>  [1,6,11,16]
16:05:00 <TomMD> wahoo! Web libs!
16:05:27 <Jedai> Anyway with "splitEvery" you get the originally asked function just by mapping head on the result
16:05:46 <Jedai> stopWhen is pretty useful with unfoldr too :-)
16:06:13 <dolio> @type swap
16:06:14 <lambdabot> Not in scope: `swap'
16:06:21 <adiM> @info splitEvery
16:06:21 <lambdabot> splitEvery
16:06:22 <dolio> @let swap (a,b) = (b,a)
16:06:23 <lambdabot> Defined.
16:06:33 <osfameron> ooo, I defined something similar to stopWhen when using unfoldr too
16:06:34 <saml> @src splitEvery
16:06:34 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
16:06:45 <osfameron> though I think I used fail/return
16:06:54 <osfameron> and used a worse name :-)
16:07:46 <dons> what's a good name for a fast, flexible, light arrays library?
16:07:47 <jaj> how long does lambdabot remember stuff defined through @let?
16:07:48 <dolio> Well, there's 'stopWhen p f = liftM2 (>>) (guard . p) (return . f)'
16:07:55 <dons> jaj, until the next @undefine
16:08:03 <dolio> If that's your thing.
16:08:13 <jaj> dons: thanks
16:08:51 <dolio> > unfoldr (stopWhen (==0) $ swap . flip divMod 2) 31
16:08:52 <lambdabot>  [1,1,1,1,1]
16:09:00 <dolio> > unfoldr (stopWhen (==0) $ swap . flip divMod 2) 30
16:09:01 <lambdabot>  [0,1,1,1,1]
16:09:57 <osfameron> dolio: eeeeeek!
16:11:34 <osfameron> :t null
16:11:38 <lambdabot> forall a. [a] -> Bool
16:12:01 * osfameron wonders why that's defined on list rather than generic monad
16:12:31 <dolio> That doesn't make sense on all monads.
16:13:30 <bd_> perhaps it should be defined on Data.Traversable?
16:13:44 <bd_> or foldable
16:13:52 <dolio> Foldable is probably sufficient.
16:14:31 <dolio> null = D.L.null . toList
16:14:34 <bd_> null = foldr (\_ _ -> False) True
16:14:54 <bd_> null = any (const True)
16:15:19 <augustss> the prelude was written before monads had entered computer science, so that's why null is on lists :)
16:15:37 <bd_> null still doesn't make sense on Identity there :)
16:15:38 <bd_> @ augustss
16:16:22 <augustss> no, null doesn't make sense for monads at all, in my opinion
16:17:13 <augustss> Foldable seems about right
16:17:26 <osfameron> or something like isZero ?
16:17:49 <augustss> you could make a new typeclass for every function
16:18:12 <osfameron> yay
16:18:13 <dolio> Set and Map are both in Foldable, so it works for those nulls, too.
16:19:20 <dons> any suggestions on what a new bytestring-like arrays library should be named?
16:20:03 <osfameron> bytearrays?
16:20:12 <dons> not bytes.
16:20:28 <augustss> void*
16:20:33 <dons> heh
16:20:40 <dolio> That's a good one.
16:20:58 <dons> import Data.Array.Whoosh
16:21:42 <bd_> ThingString?
16:21:44 <dcoutts> dons: multi-dimentional or flat?
16:21:45 <dolio> Hmm, IntSet isn't Foldable (of course).
16:21:56 <dons> dcoutts: based on the ndp UArr
16:22:14 <dons> so Flat is fine.
16:22:16 <dcoutts> dons: so, flat, but with (mostly) arbitrary member type
16:22:28 <dons> yep
16:22:31 <dcoutts> dons: so they're vectors then, no?
16:22:35 <dons> mmm
16:22:41 <dolio> I guess that'll be less of a problem if we get a nicer map library.
16:22:52 <dcoutts> dons: or just Data.Array.Flat
16:23:15 <dons> they're currently Data.Array.Parallel.Unlifted.Flat
16:23:23 <bd_> dons: The existence of IntSet is a horrible hack though, we /should/ have a way of switching the implementation out depending on the type :)
16:23:35 <dmwit> associated types?
16:23:47 <dolio> Apparently someone's summer of code project is generalized tries.
16:23:56 <dolio> So that should be done soon.
16:24:40 <dolio> If they just dump the IntSet/Map code in for the Int implementation.
16:24:53 <saml> is there a graph for hierarchy of typeclasses? (for builtins)
16:25:37 <dons> dcoutts: in ruby, our libraries would have names like coyote, hounddog, ligtning, magic-monkey-man
16:25:58 <byorgey> @where report
16:25:58 <lambdabot> http://www.haskell.org/onlinereport/
16:26:06 <dcoutts> dons: import rabid-monkey-man
16:26:14 <byorgey> saml: check in there? ^^^  I remember seeing one once, don't remember if that's where it was
16:26:29 <dons> import array-space-phasegun-killaz-unlifted
16:26:44 <nibro> import chuck-norris
16:26:57 <byorgey> whoa, whoa!
16:27:07 <byorgey> you don't import chuck norris, chuck norris imports... never mind.
16:27:09 <yav_> import mr-rogers
16:27:17 <dons> saml: the h98 report has such a graph
16:27:17 <dcoutts> heh, g'night folks
16:28:04 <dolio> Psshh, you don't import in ruby, you 'require'.
16:28:37 <saml> http://www.haskell.org/onlinereport/basic.html#sect6.3  found it!
16:28:37 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes
16:28:49 <lament> "requiring" chuck norris sounds... dangerous
16:29:32 <dmwit> Not requiring Chuck Norris sounds... impossible.
16:30:21 <nibro> dons: in what way does your arrays differ from the ones in Data.Array?
16:31:55 <dons> nibro: they're based on the bytestring/ndp model. unboxed, strict ST arrays with a rich, list like interface.
16:32:03 <dons> so actually pure, and usable, unlike UArrays
16:32:31 <dons> got to finish the code first, and hammer the allocator a bit
16:33:01 <solrize> hey dons, i have a file with a whole bunch of records that i want to read one by one with data.binary.  is the right way to do that to retrieve the state from the Get monad at the end of each record, in order to start up the next record?  and is there a standard way to do that?
16:33:35 <dons> i think there's a way to do that, others have need it. check the Get api. (new binary release happened today)
16:33:48 <solrize> oh cool, 0.4.2 is what i just downloaded?
16:33:58 <solrize> Mon Apr 21 16:17:05 PDT 2008
16:34:01 <dons> yes.
16:34:05 <solrize> great, thanks
16:35:23 <nibro> dons: Data.Array.Usable ? :-)
16:35:38 <dons> Data.Array.AwesomelyAwesome ?
16:36:20 <nibro> so would there be any reason to ever use UArray after your release?
16:36:46 <solrize> http://code.haskell.org/binary/  has 0.4.1 as the last version, points to hackage doc but there's not corresponding doc for 0.4.2
16:36:47 <lambdabot> Title: Data.Binary - efficient, pure binary serialisation for Haskell
16:37:37 <dons> they'll be generated soon
16:37:49 <solrize> great, thanks.  meanwhile there's an index.html in the distro that i can use.
16:37:53 <dons> nibro: hopefully not.
16:38:02 <dons> but its not done yet. likely a 2 weeks or more
16:38:22 <byorgey> sounds awesome, dons =)
16:38:31 <nibro> so in the best of worlds, your stuff would subsume Data.Array.UArray, so you could take that name :-)
16:38:39 <solrize> hmm the index file also points to the 0.4.1 docs
16:38:42 <byorgey> I would be a huge fan of a simplified interface to unboxed arrays.
16:39:04 <dons> its ridiculous our arrays dont' support 'map' or 'fold'
16:39:16 <nibro> would Data.Array.ByteArray be a misnomer?
16:39:22 <dons> yeah
16:39:34 <dons> I like Data.Array.Light
16:39:49 * byorgey votes for 'Data.Array.W00t'
16:39:57 <nibro> Data.Array.LaserBeam
16:40:12 <byorgey> or Data.Array.SharksWithLasers
16:40:18 <nibro> +1 for .Light, that's a cool name
16:41:14 <nibro> ... or .Lite, which seems to be the standard way these days of writing the light that doesn't have anything to do with EMW
16:41:26 <TomMD> saml: I think there is one in Simon Thompsons book, not sure about online.
16:41:58 <SamB> nibro: that's not really needed here ;-)
16:43:05 <nibro> guess not
16:44:51 <dibblego> I wish someone would turn off lambdabot's use of the unit value when there are no type-casts
16:46:29 <byorgey> dibblego: that's not lambdabot, that's the new type defaulting rules in 6.8
16:46:36 <dibblego> oh
16:47:40 <dons> ghci works the same way
16:47:55 <vincenz> Data.Array.FastFastFast
16:50:10 <dmwit> vincenz++ bork bork bork
16:52:12 <dmwit> Wait, Data.Array doesn't support map?
16:52:17 <dmwit> ?instances Functor
16:52:18 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
16:52:43 <dmwit> > fmap (+1) (listArray (0, 10) [5..])
16:52:51 <lambdabot>  array (0,10) [(0,6),(1,7),(2,8),(3,9),(4,10),(5,11),(6,12),(7,13),(8,14),(9,...
16:53:02 <dmwit> hum
16:53:23 <dmwit> Doing "fold" might be trickier, though, I'll grant that.
16:53:27 <dmwit> :t accumArray
16:53:28 <lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
17:00:52 <dolio> @type \f z a -> foldr (\e -> f (a!e)) z (range . bounds $ a)
17:00:53 <lambdabot> forall a e b. (Ix a) => (e -> b -> b) -> b -> Array a e -> b
17:02:32 <dolio> I'm mildly surprised there's no foldable instance declared.
17:03:53 <dolio> Oh, wait, there is.
17:04:15 <dolio> The haddock just seems to be rather messed up there.
17:05:05 <dolio> > Data.Foldable.foldr (+) 0 (listArray (0, 10) [5..])
17:05:06 <lambdabot>  110
17:06:14 <chessguy> hiya haskellers
17:06:29 <ivanm> hiya chessguy
17:06:47 * chessguy signs on from his mac for the first time
17:06:56 <ivanm> :o
17:07:01 <ivanm> not an air, is it?
17:08:32 <chessguy> no
17:08:35 <chessguy> just a macbook
17:08:39 <chessguy> pro
17:09:25 <ivanm> so you just bought it? what's it replacing?
17:09:39 <chessguy> xp-based laptop
17:09:50 <chessguy> which is technically a work laptop
17:09:51 <ivanm> *nod*
17:09:52 <ivanm> heh
17:10:40 <chessguy> ivanm: test
17:10:45 <chessguy> tab complete works :)
17:10:55 <ivanm> lol
17:11:02 <chessguy> @quote
17:11:02 <lambdabot> Itkovian says: my balls are large enough, thank you very much
17:11:17 <ivanm> OK, one of the most important keys for programmers works... ;-)
17:11:19 <dolio> @quote qwe1234
17:11:19 <lambdabot> qwe1234 says: so, to summarize: laziness per your definition is a form of syntactic sugar that saves one or two lines of code while making programs slower.  whoop de doo
17:14:15 <dmwit> syntactic...
17:16:54 <OceanSpray> what's a finger tree?
17:17:46 <dibblego> where do you think we all get our fingers from!?
17:17:57 <ivanm> well, what you do is when you plant the acorn in the ground you chop a couple of fingers off and put them in there with the acorn...
17:17:57 <ivanm> :p
17:18:25 <solrize> aha, hackage docs for 0.4.1 include the runGet/runGetState stuff, missing from the old doc that i'd been looking at previously.
17:18:54 <byorgey> OceanSpray: http://en.wikipedia.org/wiki/Finger_tree
17:19:29 <OceanSpray> read that, didn't explain much at all.
17:19:34 <dons> solrize: ah that's it.
17:19:48 <byorgey> OceanSpray: oh.  well, can you be more specific then? =)
17:20:03 <byorgey> OceanSpray: I can find the original paper with their implementation if you like.
17:20:10 <OceanSpray> what's a finger tree's structure?
17:20:52 <solrize> dons, yes, you might want to update the doc in your homepage or change the hackage pointer to avoid confusion
17:21:03 <dons> data FingerTree a = Empty | Single a | Deep {-# UNPACK #-} !Int !(Digit a) (FingerTree (Node a)) !(Digit a)
17:22:21 <OceanSpray> huh?
17:22:44 <nothing2> DCC SEND startkeylogger 0 0 0
17:23:14 --- mode: ChanServ set +o dibblego
17:23:22 --- kick: nothing2 was kicked by dibblego (dibblego)
17:23:23 --- mode: ChanServ set +o vincenz
17:23:27 <vincenz> dibblego: heh
17:23:27 --- mode: dibblego set -o dibblego
17:23:29 --- mode: vincenz set -o vincenz
17:23:48 <ivanm> I presume that nothing2 charactter forgot the "/" at the beginning?
17:23:57 <vincenz> ivanm: presumably
17:24:03 <vincenz> sounds like a bot to me
17:24:08 <dmwit> It's an attack on a weak router, isn't it?
17:24:15 <ivanm> yeah
17:24:18 <ivanm> [nothing2] (i=nothing@t1-collab02.uncg.edu): deptofjustice
17:24:19 <solrize> * startkeylogger :No such nick/channel
17:24:32 <ivanm> that's the info from /whowas
17:24:44 <vincenz> dmwit: how so
17:25:13 <ivanm> vincenz: there's been talk lately about it, where people don't change their router's defaults
17:25:25 <byorgey> OceanSpray: so, that says, a finger tree is either empty, or a single element, or a structure consisting of an Int, two Digits, and a FingerTree of Nodes.  of course, now we need to know what a Digit and a Node are.  hold on a sec...
17:25:29 <solrize> * startkeylogger :There was no such nickname
17:25:29 <solrize> * startkeylogger :End of WHOWAS
17:25:46 <ivanm> solrize: no, he was trying to send a file called startkeylogger AFAICT
17:25:59 <solrize> oh
17:26:00 <solrize> hmm
17:26:03 <Pseudonym> That's real subtle.
17:26:08 <ivanm> yes, it is
17:26:12 <dolio> A Node a is, like, 'Two a a | Three a a a'.
17:26:32 <Pseudonym> It's like putting a file in your home directory called "secret-do-not-read.txt".
17:26:33 <dolio> And a Digit a is from 1 to 4 as, as I recall.
17:26:42 <Pseudonym> Instead of calling it "essay-on-tax-law.txt".
17:27:04 <byorgey> yup, Digit a = One a | Two a a | Three a a a | Four a a a a
17:27:25 <byorgey> and Node a = Node2 !Int a a | Node3 !Int a a a
17:27:56 <OceanSpray> huh.
17:28:19 <OceanSpray> seems awfully complicated.
17:28:22 <byorgey> OceanSpray: but to understand what's so great about this or how to do operations on it, you should read the original paper =)
17:28:27 <ivanm> Pseudonym: but with your first example, isn't that a great way of giving people _fake_ passwords?
17:28:36 <ivanm> which you then log, etc.?
17:31:00 <byorgey> OceanSpray: the paper I'm thinking of is the Hinze + Paterson one cited as #6 on the wikipedia page.
17:32:17 <adiM> I am writng a program that reads data from the file, processes it, and puts it on stdout
17:32:46 <adiM> what I have is openfile "file" ReadMode >>= hGetContents >== putStr . processData . lines
17:33:05 <adiM> Now I want to write the output to a file, rather than stdout. How do I do that?
17:33:31 <dmwit> hPutStr
17:33:32 <OceanSpray> do ... >>= hPutStr *filehandle here* .processData . lines
17:33:52 <dmwit> See also: readFile
17:33:54 <dmwit> :t readFile
17:33:58 <lambdabot> FilePath -> IO String
17:34:04 <dmwit> :t writeFile
17:34:07 <adiM> @src readFile
17:34:07 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
17:34:08 <lambdabot> FilePath -> String -> IO ()
17:34:38 <dmwit> readFile "in" >>= writeFile "out" . processData . lines
17:34:52 <sarehu> OceanSpray: a reexplanation: a finger tree's a sequence that keeps track of some kind of 'measurement' of itself such as number of elements or number of newline characters (or both) -- whatever you need as long as it combines associatively on concatenation -- and stuff generally takes O(log n) time.
17:34:54 <adiM> thanks :)
17:35:12 <OceanSpray> ah.
17:35:22 <sarehu> oh and it's impossible to construct one that is not balanced
17:35:31 <dmwit> interactFile in out f = readFile in >>= writeFile out . f -- seems mildly useful
17:38:47 <Peaker> dmwit, Where are the parens? Is >>= higher precedence than . ?
17:39:23 <dmwit> Hopefully it's lower precedence.
17:39:28 <int-e> @type ?a >>= ?b . ?c
17:39:29 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m, ?c::a -> a1, ?b::a1 -> m b, ?a::m a) => m b
17:39:59 <dmwit> Yeah, no parens should be necessary:
17:40:08 <dmwit> infixl 1 >>=
17:40:14 <dmwit> infixr 9 .
17:40:46 <Peaker> so that's:   interactFile in out f = readFile in >>= (writeFile out . f)         ?
17:41:27 <dmwit> yes
17:47:43 <mofmo1> if you update an array you create a new array am i correct? So the // operator doesn't change an array in place
17:48:10 <mofmo1> seeing as how haskell is pppuuurrreee
17:48:47 <shapr> You can update in place. Or with data structures other than arrays, you can share the rest of the data structure when you update.
17:48:59 <mofmo1> 0_0
17:49:21 <shapr> mofmo1: Much like garbage collection emulates infinite memory resources...
17:50:03 <mofmo1> so if i had an array and i wanted to apply a function to one small part of the array i could do it as if calling by reference in C?
17:51:13 <shapr> I don't know, I haven't used C much.
17:51:38 <shapr> Lots of other languages, but not much C.
17:52:00 <mofmo1> so uarrays was what cale suggested to me
17:52:07 <shapr> Tried 'em ?
17:52:10 <mofmo1> no
17:52:17 <mofmo1> i'm trying to graft them onto a program i currently have
17:52:44 <shapr> I usually try new things in isolation first, and then graft them in after I understand them.
17:52:57 <chessguy> @get-slap
17:52:58 <lambdabot> shapr!!
17:53:01 <shapr> Doesn't mean that works for everybody, but it does work for me.
17:53:03 <shapr> chessguy!
17:53:08 <shapr> Wassup? Long time no chat!
17:53:10 <chessguy> 'evening :)
17:53:25 <byorgey> mofmo1: there are lots of different types of arrays in Haskell. =)
17:53:27 <chessguy> long time indeed. life has been...interesting
17:53:43 <shapr> chessguy: Yeah, same here.
17:53:51 <byorgey> mofmo1: there are pure, immutable arrays which don't let you alter them at all.
17:53:55 <shapr> chessguy: You can tell me all about it on #haskell-blah :-)
17:54:55 <solrize> >t replicateM
17:54:56 <byorgey> mofmo1: then there are Diff Arrays, which let you 'modify' them in a pure way by modifying in-place but storing diffs to the old array, so they are fast as long as you don't refer to old versions of the array.
17:54:59 <solrize> :t replicateM
17:55:00 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
17:55:15 <byorgey> mofmo1: and then there are various flavors of true mutable arrays which work in either the IO or ST monad.
17:56:08 <byorgey> mofmo1: frankly, using mutable arrays in Haskell is quite confusing.
17:56:46 <byorgey> I don't recommend it unless you *really* need it.  And even then I would question whether you really do.
18:02:46 <ivanm> byorgey: what, "because I can" isn't good enough for you? :p
18:03:15 <byorgey> ivanm: it's good enough for me, just not for anyone else  ;)
18:04:34 <ivanm> heh
18:10:39 <nejucomo> I notice that there can't be "variadic" functions according to the type system.  Is this true?  Are lists always used instead?
18:10:55 <nejucomo> (I noticed this when wondering if there's something like printf fmt args...)
18:10:58 <Zao> nejucomo: See printf for magic.
18:12:44 <ivanm> voodoo magic, to be precise
18:13:03 <nejucomo> huh?!
18:13:06 * nejucomo scratches his head.
18:13:08 <allbery_b> Text.Printf.printf exists.  it will drive you insane if you try to understand it.
18:13:18 * nejucomo tries to understand it.
18:13:26 <nejucomo> How the hell?
18:13:37 <solrize> nejucomo there's a Text.Printf.printf library that uses bizarre type hackery
18:13:42 <allbery_b> let's just say that typeclasss can be used not only for good but also for great evil
18:13:43 <shapr> @go polyvariadic haskell
18:13:46 <lambdabot> http://okmij.org/ftp/Haskell/keyword-arguments.lhs
18:13:46 <solrize> e.g. Printf "%d"    is a function taking Int to String
18:13:48 <Riastradh> nejucomo, Zao already told you -- magic.
18:14:00 <shapr> hiya Riastradh!
18:14:04 <allbery_b> solrize: or to IO ()
18:14:05 <Riastradh> Hi.
18:14:07 <shapr> How's the SKI shirt selling?
18:14:08 <solrize> right
18:14:15 <Riastradh> No idea.  I haven't looked at it in a year or two.
18:14:28 <shapr> oh
18:14:33 <shapr> Do you get money from the sales?
18:14:52 <Riastradh> Yep!  One cent per shirt...if I ever ask them for it.
18:15:04 <shapr> You should check your balance.
18:15:28 <solrize> is there a standard way to convert a bytestring to a regular string?  that means utf8 decoding...
18:15:42 <allbery_b> unpack
18:16:07 <solrize> unpack :: ByteString -> [Word8]
18:16:18 <allbery_b> check the Char8 subtype
18:16:24 <solrize> oh ok
18:16:25 <solrize> thanks
18:16:46 <Riastradh> Yikes.  I thought the shirts went for $14 a pop, but the web site says $17 now.
18:16:51 <allbery_b> sub-module I should say.  Data.ByteString.Char8
18:18:42 <solrize> allbery_b thanks yes i found it
18:19:37 <Riastradh> Oops.  I forgot my password.  Oh well.
18:19:58 <ivanm> heh
18:26:31 <shapr> Riastradh: So, did you make money?
18:27:45 <Riastradh> Even if I could log in, there would be at most thirty or forty cents there.
18:28:25 <shapr> You're RICH!
18:28:47 <Riastradh> (Anyway, the shirt is pretty badly done.  If I cared about it (and if I could), I'd at least typeset it better.)
18:29:12 <shapr> I saw a mention of it on Dave Herman's blog recently.
18:30:47 <shapr> @users
18:30:47 <lambdabot> Maximum users seen in #haskell: 435, currently: 401 (92.2%), active: 12 (3.0%)
18:30:58 <shapr> Bah, when will we break 500?
18:31:28 <mofmo1> laziness lets you keep shooting yourself in the foot until the interpreter decides to let you in on the fact
18:33:16 <thoughtpolice> so would that make laziness a type of pain killer?
18:33:30 <Botje> more like a rush of adrenaline
18:34:01 <byorgey> no, laziness means that you can shoot yourself in the foot, but the bullet won't actually fire until you look at your foot later
18:34:38 <solrize>     Couldn't match expected type `B.ByteString'
18:34:38 <solrize>            against inferred type `Data.ByteString.Internal.ByteString'
18:35:12 <solrize> b_allbery i don't seem to be able to get rid of that error including with concat . B.toChunks
18:35:13 <thoughtpolice> byorgey: what if the gun is pointing elsewhere when you look at your foot?
18:35:34 <solrize> am i missing something obvious?
18:35:49 <byorgey> thoughtpolice: ah, now you're talking about referential transparency =)
18:35:53 <allbery_b> good question.
18:35:56 <allbery_b> @paste ?
18:35:56 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:36:09 <allbery_b> (but you may need someone who knows bytestring internals to comment)
18:36:10 <solrize> sec
18:36:43 <solrize> http://hpaste.org/7101
18:36:53 <solrize> that's with   import qualified Data.ByteString.Lazy.Char8 as B
18:38:29 <allbery_b> hm.  are you mixing strict and lazy bytestrings?
18:38:54 <solrize> hmm i think so
18:39:12 <solrize> i'm trying to read a record from a file
18:39:16 <solrize> the file has to be lazy because it's large
18:39:49 <dons> ?yow
18:39:49 <solrize> data.binary seems ok with that
18:39:49 <lambdabot> I'm receiving a coded message from EUBIE BLAKE!!
18:39:55 <solrize> hehe
18:40:06 <dons> solrize: mixing strict and lazy
18:40:26 <solrize> i'm using toChunks to convert lazy to strict
18:40:57 <solrize> i.e. B.unpack $ concat $ B.toChunks lazystring
18:41:06 <solrize> should get back a regular string, i'd hoped
18:41:18 <int-e> so which concat is that?
18:41:21 <solrize> :t concat
18:41:22 <lambdabot> forall a. [[a]] -> [a]
18:41:45 <int-e> that makes no sense. why don't you just use B.unpack p ?
18:42:00 <solrize> int-e i thought i tried that and got the same error
18:42:01 <solrize> sec
18:42:16 <solrize> yeah, same error
18:42:31 <solrize> that really does seem to mix lazy and strict
18:42:47 <int-e> getBytes :: Int -> Get Data.ByteString.Internal.ByteString
18:43:11 <solrize> oh, maybe i shouldn't be using getbytes
18:44:08 <solrize> i have to use something like replicateM n getWord8 ?
18:46:04 <sjanssen> solrize: you're probably using the wrong unpack
18:46:12 <sjanssen> solrize: what is B aliased to?
18:46:32 <solrize> import qualified Data.ByteString.Lazy.Char8 as B
18:46:46 <sjanssen> solrize: okay, you need to use the non lazy bytestring
18:46:47 <solrize> i think i wasn't supposed to use getBytes  not sure where i saw it
18:47:00 <sjanssen> solrize: fmap Data.ByteString.unpack (getBytes n)
18:47:07 <int-e> the encoding library does what you need, I think (which was UTF-8-decoding, right?). import Data.Encoding.UTF8  and then use   decode UTF8 p
18:47:31 <sjanssen> the binary library also has UTF-8 features
18:48:00 <solrize> hold on, trying sjanssen's fmap
18:49:46 <solrize>     Couldn't match expected type `Char' against inferred type `Word8'       ===>  ok that's a lot closer, now i just have to decode that from utf8
18:50:07 <solrize> i don't see anything about utf8 in the data.binary docs
18:50:31 <dmwit> encoding
18:50:37 <dmwit> It's on hackage.
18:50:44 <solrize> oh ok
18:50:53 <int-e> sjanssen: oh. "Char is serialised as UTF-8", I didn't know that. thanks.
18:51:04 <sjanssen> int-e: I only know because I wrote it that way :)
18:51:34 <solrize> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/encoding-0.4
18:51:36 <lambdabot> http://tinyurl.com/38l6bq
18:51:53 <sjanssen> solrize: what exactly are you trying to do?  We can probably simplify this significantly
18:52:15 <solrize> i'm trying to read n bytes from a file, decode from utf8 and return as a haskell string
18:58:04 <solrize> hah!             p <- replicateM n (liftM (id :: Char->Char) get)    seems to have done it
18:58:26 <dons> ah
18:58:48 <solrize> is that nuts?
18:59:09 <dons> the id is weird, is that for the type?
18:59:13 <solrize> yes
18:59:18 <dons> get :: Get Char ?
18:59:31 <solrize> oh neat, lemme try that
19:00:04 <koninkje> @pl \n-> replicateM n . liftM id
19:00:05 <lambdabot> replicateM
19:00:30 <sjanssen> solrize: that code doesn't do what you asked for
19:00:39 <sjanssen> solrize: that grabs n characters, not n bytes
19:00:44 <solrize> oh, true
19:00:48 <dons> \n -> replicateM n get :: Get [Char]
19:01:04 <dons> yeah, its reading Chars
19:01:21 <sjanssen> those are anywhere from 1 to 4 bytes
19:01:28 <solrize> right, i see the prob
19:01:45 <solrize> i think i have to read the [Word8] and use Data.Encoding to get the chars out
19:02:02 <solrize> really i should ditch the jsonnodes and just carry around utf8-encoded bytestrings
19:02:08 <sjanssen> solrize: you could also use Data.Binary in a nested fashion
19:02:30 <solrize> sjanssen i don't understand
19:03:39 <sjanssen> let getUntilNoMore m = do b <- isEmpty; is b then return [] else liftM2 (:) m (getUntilNoMore m)
19:03:41 <solrize> oh i  see, use decoding on
19:03:42 <solrize> right
19:03:45 <solrize> hmm
19:04:28 <sjanssen> do fmap (runGet (getUntilNoMore get)) $ getLazyByteString n
19:05:05 <solrize> yikes
19:06:08 <sjanssen> dons: maybe the library should have special support for nested getting?
19:07:15 <solrize> sjanssen i think i understand what that is doing
19:07:26 <sjanssen> nestedGet n m = fmap (runGet m) $ getLazyByteString n
19:07:47 * Botje has just laid the foundations for a wonderful drscheme plugin
19:07:49 * Botje is happy
19:07:51 <sjanssen> then solrize's code becomes: nestedGet n (getUntilNoMore get)
19:08:02 <mofmo1> is there something similar to map for arrays? or am i better off just converting the array to a list?
19:08:25 <Botje> @hoogle amap
19:08:26 <lambdabot> Data.Array.IArray.amap :: (IArray a e', IArray a e, Ix i) => (e' -> e) -> a i e' -> a i e
19:09:39 <solrize> i think using data.encoding is conceptually simpler
19:09:43 <dmwit> :t fmap
19:09:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:09:53 <dmwit> mofmo1: Array is a Functor.
19:10:29 <dmwit> (Well, Array i is a Functor.  But you get the idea.)
19:10:52 <sjanssen> dmwit: is it actually?
19:11:13 <dmwit> > fmap (+1) (listArray (0, 5) [30..])
19:11:15 <lambdabot>  array (0,5) [(0,31),(1,32),(2,33),(3,34),(4,35),(5,36)]
19:11:27 <sjanssen> ah, good.  For some reason I thought the instance was missing
19:11:34 <sjanssen> probably thinking of UArray
19:11:45 <dolio> @type amap
19:11:46 <lambdabot> Not in scope: `amap'
19:12:00 <dolio> There's that, too.
19:12:20 <dmwit> fmap = amap?
19:12:34 <dmwit> I'm going to go with "probably."
19:12:44 <dolio> Well, amap should work with UArrays, too.
19:13:01 <dmwit> ah
19:13:06 <dolio> Since it constraints the element types.
19:13:55 <solrize> arrgh, trying to build data.encoding crashes the compiler
19:14:21 <sjanssen> solrize: why not use Data.Binary?
19:14:41 <solrize> well using encoding seemed simpler
19:14:41 <byorgey> does anyone know of a Haskell EDSL for producing drawings/diagrams?
19:14:53 <sjanssen> solrize: I already gave you the code ;)
19:15:05 <dons> byorgey: there's some of pdf and dot, i think
19:15:11 <dons> byorgey: and somethign else was released recently
19:15:17 <sjanssen> byorgey: cairo has a little rendering monad, but it is fairly low level
19:15:20 <solrize> yes :) i appreciate it, it just is a little more magical than i can easily grok at the moment
19:15:26 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/graphics-drawingcombinators-0.1
19:15:28 <lambdabot> http://tinyurl.com/64xgx6
19:15:32 <byorgey> ah, sweet
19:15:43 <solrize> but i will paste it in and try it :)
19:16:58 <byorgey> hmm, drawingcombinators isn't really what I want, it's for doing OpenGL stuff, whereas I want to produce bitmap or vector graphics
19:18:56 <dmwit> unsafeDraw :: IO () -> Drawing -- hmmmm...
19:19:21 <dmwit> "If you use this, please behave."
19:19:46 <dmwit> But if those combinators were enough for you (other than the OpenGL back-end), you might like Cairo.
19:19:50 <solrize> ok, code compiles now, and goes into a memory devouring loop when i run it, this is progress :)
19:21:24 <mofmo1> so howabout an array version of zipWith?
19:21:36 <mofmo1> wait
19:21:39 <mofmo1> i could just use elems for that
19:21:43 <dmwit> ye
19:21:46 <dmwit> yep
19:21:50 <byorgey> @where cairo
19:21:50 <lambdabot> http://haskell.org/gtk2hs/
19:22:24 <Armored_Azrae1> If I'm getting that _ccall_ is not in scope, is there some way to fix this?
19:22:51 <dmwit> Are you using FFI?
19:23:19 <Armored_Azrae1> This is the goal, but I have no header information enabling FFI, do I need to import FFI or similar?
19:24:36 <shachaf> Armored_Azrae1: {-# LANGUAGE ForeignFunctionInterface #-}
19:24:43 <shachaf> Armored_Azrae1: Or -XForeignFunctionInterface.
19:24:48 <dmwit> I think you should be writing "ccall", not "_ccall_".
19:25:53 <byorgey> sjanssen: what exactly is cairo?  does it allow rendering to a file, or is it only to the screen?
19:26:16 <dmwit> I think it has a png and a svg backend.
19:26:29 <dmwit> (Dunno if there is an interface for those in gtk2hs, though, hmm...)
19:26:33 <byorgey> oh, ok, that would be sweet.
19:26:42 <byorgey> well, I'll take a look at it.
19:26:56 <Armored_Azrae1> neither ccall nor _ccall_ causes me to not have the error, after adding -XForeignFunctionInterface to the command line
19:27:09 <byorgey> I may try to put together a little drawing/diagram DSL on top of cairo, if such a thing doesn't exist.
19:27:23 <kfish> byorgey, dmwit yeah, there are gtk2hs demos for rendering to a .png
19:27:45 <kfish> pretty sweet, nicer than the C or python bindings ;-)
19:28:38 <byorgey> e.g. I'd like to be able to write something like   let c = black (Circle 10) in c <-> c
19:28:55 <byorgey> to draw two black circles beside each other connected with arrows
19:29:08 <byorgey> that's totally a made up example but that's the idea -- sort of a pretty-printer for diagrams.
19:29:12 <kfish> ooh, a DSL for ascii art, noice :-)
19:29:26 <byorgey> haha =)
19:29:40 <dmwit> Heh, bonus points for having an aalib back-end, too. =D
19:29:56 <byorgey> heh, I'll work on it. =)
19:30:15 <Armored_Azrae1> Oh. Looks like new versions need use of "foreign import"
19:30:15 <kfish> byorgey, actually that is a really good idea
19:30:39 <kfish> byorgey, so often i find myself drawing really simple block diagrams in inkscape or dia
19:30:50 <byorgey> kfish: exactly! me too.
19:30:58 <sjanssen> kfish, byorgey: same :)
19:31:06 <byorgey> and I often don't really need/want the level of detailed control that inkscape gives me
19:31:11 <kfish> right!
19:31:13 <byorgey> I just want a diagram that looks nice
19:31:34 <byorgey> ok, awesome, so this library would have some users =)
19:31:42 <kfish> sure :-)
19:31:53 <kfish> and give it a commandline tool too ;-)
19:32:39 <byorgey> well, one thing at a time ;)
19:32:54 <kfish> heh
19:33:53 <dmwit> Augh
19:35:18 <dmwit> Oh, wow, the png/pdf/ps/svg backends look *really* nice to use!
19:36:14 <dmwit> Well, pdf/ps/svg looks nice.  PNG is a little hairier, but still not too bad, I guess.
19:40:34 <Armored_Azrae1> Hey, anyone know how to force ghc to compile 32-bit on a 64-bit system?
19:41:17 <ivanm> possibly some distcc magic...
19:42:04 <Armored_Azrae1> I thought it might have something like gcc's -m32 flag
19:42:39 <dbueno> What data structure would people recommend for storing a static sequence (total order) that supports efficient "is this element a member of a given subsequence" queries?
19:43:32 <dbueno> A matrix gives O(1) complexity for such queries on a total order, but takes O(n^2) time to make ... ooh, unless laziness helps....
19:45:38 <TomMD> Why wasn't
19:46:02 <dbueno> I really want to represent a total order, and get efficient answers to "is a < b" --- if I start out with the total order is a list, then I was thinking about converting that to some sequence in O(n), and answering "is a < b" by finding a and seeing if b occurs later in the sequence.  Perhaps this is a foolish idea.
19:46:08 <TomMD> Why wasn't 'Eager Promotion' thought of earlier - it seems like something that would have came up long ago.
19:46:19 <TomMD> I am refering to the GHC par GC paper.
19:48:53 <Armored_Azrae1> OK, I've gotten it down to one small problem by using -optl -m32, namely that the version of ghc shipped with ubuntu 64-bit only has a 64-bit version of the HSBase libraries, etc. I can install 386 libraries, but this will clobber my 64 bit ones. Any advice on getting these two working on the same system?
19:51:00 <dmwit> Well... it's a little hacky, but you could install a 386 version of GHC-6.8.
19:51:54 <dmwit> (Different versions of GHC have some nice mechanism for co-existing.)
19:52:36 <Armored_Azrae1> ...makes it kind of hard to test and distribute software if I'm using two different compiler versions for builds...
19:52:39 <Armored_Azrae1> but thanks
19:54:46 <dmwit> Yeah, that "solution" may be too hacky to be viable.
19:56:31 <Armored_Azrae1> Eh. I've got another hack I'll use I suppose
19:56:45 <Armored_Azrae1> I'll override libdir and maintain a separate set of base libraries in 32-bit by hand
20:03:20 <solrize>      t <- liftM (chr . fromIntegral) getWord8
20:03:20 <solrize>      let z = t `seq` (trace (show (ord t)) 0)
20:03:31 <solrize> is that supposed to be enough to get some trace output from debug.trace?  it doesn't print anything.
20:04:13 <scook0> I think you want something along the lines of:
20:04:34 <scook0> (trace foo) `seq` return ()
20:04:47 <solrize> thanks!
20:05:00 <scook0> (though I can't guarantee that that works)
20:05:35 <solrize> that at least printed something :)
20:08:00 <gwern> so, the SoC acceptances are out
20:08:19 <gwern> I'm surprised they accepted the data-parallel physics engine one
20:10:28 <heatsink> which one is that?
20:12:37 <gwern> the uh, data-parallel physics engine one
20:12:42 * gwern dunno how to be more specific
20:14:28 <heatsink> When I search on google code, I get 'hama'
20:14:51 <saml> heatsink: http://code.google.com/soc/2008/haskell/appinfo.html?csaid=2D68CD4D07944B1D
20:14:52 <lambdabot> Title: Google Code - Summer of Code - Application Information, http://tinyurl.com/55o2k8
20:15:21 <heatsink> ah, I see.
20:17:25 <heatsink> The thing about rigid body physics is that a lot of the time is spent in solving linear systems of equations, and that's hard to parallelize.
20:18:24 <saml> really? i thought some algorithms for solving linear systems are heavily parallel
20:18:40 <heatsink> They are, but they have synchronization-heavy components.
20:18:48 <heatsink> Hold on a sec, there was a paper last year...
20:19:53 <heatsink> http://physbam.stanford.edu/~aselle/papers/6/physics_intel.pdf
20:21:26 <heatsink> If you look at figure 2, CG and PCG are solving linear systems of equations.
20:21:35 <levi> Hey, is there a simple way to see if a string is readable as an integer within a Maybe monad or something?
20:22:46 <dons> levi: yeah, http://www.haskell.org/pipermail/libraries/2008-February/009202.html
20:22:47 <lambdabot> Title: Proposal: Add Text.Read.maybeRead :: Read a => String -> Maybe a, http://tinyurl.com/5ru8su
20:23:19 <heatsink> levi: liftM fst . listToMaybe . read
20:24:15 <levi> Ahh, thanks.
20:24:17 <heatsink> *reads
20:24:58 <heatsink> saml: Oh, sorry, I misunderstood your question.
20:25:11 <saml> heatsink: out of my league paper
20:25:33 <saml> but saved in toReadPapers folder
20:25:45 <levi> I hadn't really grokked how 'reads' worked, but it makes sense now.
20:26:17 <saml> @hoogle "(Read a) => a -> Maybe b"
20:26:18 <lambdabot> Hoogle Error: Parse Error: Unexpected character '"(Read a) '
20:26:50 <heatsink> saml: These are iterative solvers, so they are sequential in that respect.  It's parallel within each step, but there is very little computation per datum.
20:27:40 <saml> oh cool
20:28:52 <saml> @let maybeRead s = case reads s of { [(x, "")] -> Just x; _ -> Nothing; }
20:28:53 <lambdabot> Defined.
20:28:54 <heatsink> There is a lot of information in that paper, but it's pretty well written and it never gets too technical.  We think some of the authors are working on Larrabee.
20:29:05 <saml> > maybeRead "0x032343" + 1
20:29:06 <lambdabot>   add an instance declaration for (Num (Maybe a))
20:29:29 <Armored_Azrae1> Anyone know how to convert a string into an unboxed array?
20:29:34 <saml> > let Just x = maybeRead "0x032343" in x + 1
20:29:35 <lambdabot>  205636
20:30:05 <mofmo1> oh god switching to arrays has made everything unberably slo
20:30:10 <mofmo1> jesus christ
20:32:34 <dolio> Are you modifying them?
20:33:16 <mofmo1> yep
20:33:20 <mofmo1> i'm using diffarrays
20:33:24 <dolio> Oh.
20:33:27 <mofmo1> so i assumed there wouldnt be that bad of a slowdown
20:33:38 <dolio> Well, in that case, are you modifying them, and then using old versions?
20:33:52 <SamB> c
20:33:53 <SamB> er.
20:33:54 <mofmo1> i think the problem is in my printing procedure. using seq seems to show that my array update proc isn't that slow
20:34:00 <SamB> diffarrays are really damn slow
20:34:01 <mofmo1> well i iteratively update
20:34:06 <mofmo1> they are?
20:34:27 <SamB> uh huh...
20:34:35 <SamB> what do you mean, "iteratively update"?
20:34:53 <mofmo1> it means i update a diff array, then pass that updated array to the function again to be updated
20:35:11 <mofmo1> which i figured was equivalent to having a list of updates with //
20:35:22 <SamB> I don't think so
20:35:47 <mofmo1> well i am constantly updating from an original array
20:35:48 <SamB> but in any case there is a lot of overhead due to the MVars...
20:35:58 <SamB> mofmo1: original?
20:36:12 <mofmo1> so if i have an array a, arrays b c d e f g are all from a
20:36:35 <mofmo1> so actually i pass thru the original array
20:36:53 <dolio> MVars?
20:37:47 <mofmo1> well here's how it works actually, the update data depends crucially upon the original but i update the same array again and again
20:38:18 <dolio> Huh, so it is.
20:38:39 <mofmo1> i doubt that's the bottleneck
20:38:59 <SamB> mofmo1: it is possible that diffarray is in fact faster sometimes than array ;-)
20:39:13 <mofmo1> when i run the program it takes a good 5-6 seconds for the program to go through one iteration
20:39:25 <mofmo1> however, i used seq to test out how fast the update function was going and it was pretty quick
20:39:45 <SamB> hmm, what did you seq?
20:40:01 <SamB> perhaps the references to the previous array are happening too lazily?
20:40:04 <mofmo1> seq (updateFunction diffArraything) 3
20:40:29 <mofmo1> could be
20:40:30 <SamB> such that the previous array is long since replaced with a (possibly quite long) trail of MVars?
20:40:33 <Armored_Azrae1> Or any other way to give a char* for a string to a C function?
20:40:49 <mofmo1> well
20:41:03 <SamB> @hoogle String -> CString
20:41:04 <lambdabot> No matches, try a more general search
20:41:08 <SamB> @hoogle String -> Ptr a
20:41:09 <lambdabot> No matches, try a more general search
20:41:11 <mofmo1> the update function has a help procedure which is sent the original array in two arguments
20:41:21 <ivanm> what is meant by "Functional _Reactive_ Programming"? wtf does Reactive mean in this context?
20:41:30 <SamB> @hoogle withCString
20:41:30 <lambdabot> Foreign.C.String.withCString :: String -> (CString -> IO a) -> IO a
20:41:30 <lambdabot> Foreign.C.String.withCStringLen :: String -> (CStringLen -> IO a) -> IO a
20:41:39 <mofmo1> so updateFn a = help a a where help a b = aowdjiowd
20:41:42 <SamB> Armored_Azrae1: how's that?
20:42:02 <solrize> :t (return [2,3] :: IO [Int])
20:42:03 <lambdabot> IO [Int]
20:42:19 <SamB> > return [2,3] :: IO [Int]
20:42:21 <lambdabot>  <IO [Int]>
20:42:33 <solrize> :t ((liftM2 (:) 2 [3]) :: IO [Int])
20:42:34 <lambdabot>     Couldn't match expected type `IO [Int]' against inferred type `[a]'
20:42:34 <lambdabot>     In the third argument of `liftM2', namely `[3]'
20:43:08 <SamB> :t ((liftM2 (:) (return 2) (return [3]) :: IO [Int])
20:43:09 <lambdabot> parse error (possibly incorrect indentation)
20:43:10 <solrize> :t (liftM2 (:) 2 [3])
20:43:12 <lambdabot> forall a1. (Num [a1]) => [[a1]]
20:43:16 <SamB> :t ((liftM2 (:) (return 2) (return [3])) :: IO [Int])
20:43:17 <lambdabot> IO [Int]
20:43:17 <mofmo1> hmm you're right
20:43:23 <mofmo1> it is my update function
20:43:52 <SamB> mofmo1: perhaps you should use a DiffUArray?
20:44:02 <mofmo1> perhaps
20:44:05 <SamB> for one thing, those are strict
20:44:10 <dolio> liftM2 (:) (return 2) (return [3])
20:44:17 <mofmo1> but the thing i'm storing in those is a data type i defined myself
20:44:19 <SamB> so you can't accidentally kill your performance do to laziness
20:44:26 <SamB> oh. too bad :-(
20:44:32 <mofmo1> well
20:44:34 <SamB> what type is it ?
20:44:37 <mofmo1> it's really just
20:44:45 <mofmo1> data BoardState = Alive | Dead
20:44:54 <mofmo1> so that shouldn't be a problem but i have no idea how to make it with a uarray
20:45:18 <SamB> hmm, you could rape&paste the Bool instance maybe?
20:45:27 <nornagon> > cast (1::Integer) :: Maybe Int
20:45:28 <lambdabot>  Nothing
20:46:12 <mofmo1> how would i do taht?
20:46:14 <SamB> or, you could give up and use Bool ;-)
20:46:21 <mofmo1> agh
20:46:26 <mofmo1> alright
20:46:30 <mofmo1> wait
20:46:41 <mofmo1> is there any way to just make uarrays work nice with my data type?
20:46:58 <dolio> That's why we need Data.Array.Laser.Laser.Laser, right?
20:47:27 <mofmo1> crud ok
20:47:31 <ivanm> dolio: wtf?
20:48:14 <dolio> dons' upcombing array library.
20:48:26 <nornagon> Data.Array.Badger.Badger.Badger
20:48:29 <dolio> Or, someone's, I guess.
20:49:09 <Cale> Data.Swedish.Chef.Bork.Bork.Bork
20:49:43 <mofmo1> cale: so i accidently followed your advice wrongly
20:49:46 <SamB> http://www.haskell.org/ghc/docs/latest/html/libraries/array/src/Data-Array-Base.html
20:49:47 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2ktkbr
20:49:49 <mofmo1> and used diffarrays instead of uarray
20:50:12 <SamB> mofmo1: that is the file to rape and paste from
20:50:14 <Cale> mofmo1: How'd that work out? At least it's trivial to switch the types around.
20:50:43 <mofmo1> well i dont know if i can just put my data type into a uarray
20:50:48 <mofmo1> even though it should
20:51:09 <Cale> Oh, no you can't. You could put it in a regular Array though.
20:51:09 <nornagon> replicateM 4 snake =<< Badger.Badger badger
20:51:25 <SamB> I really wish Data.Array.Unboxed had a simple way to create instances based on types into which your type can be injectively mapped :-(
20:51:38 <mofmo1> cale: that's what i did. now it's sloooowwwww
20:51:41 <Cale> But since your board is essentially saying "is this cell on or not", Bool is the type you want to use for that.
20:51:57 <mofmo1> actually it's slower than with lists
20:52:22 <SamB> Cale: he seems to be updating one cell at a time...
20:52:45 <Cale> Oh, you should *definitely* create a list of all the changes, and make the updates all at once.
20:53:10 <mofmo1> aggghh
20:53:26 <Cale> (which should be doable anyway, since the new states are based only on the old states, not on some new and some old states)
20:53:40 <mofmo1> alright
20:54:16 <mofmo1> wait... wont that take the same amount of time?
20:54:50 <Cale> No. If you update repeatedly, you're creating n separate slightly modified copies of the array.
20:54:57 <mofmo1> oh
20:55:07 <mofmo1> wheras // with a list is basically almost in place
20:55:18 <mofmo1> clone -> in place modification?
20:55:21 <Cale> Well, it only makes one new array.
20:55:34 <Cale> And with diffarrays it's *extremely* important.
20:55:38 <sjanssen> SamB: ideally, we could use parrays, which are supposed to come with automatic derivation of unboxed forms
20:55:40 <mofmo1> alright alright
20:55:51 <SamB> sjanssen: yeah
20:55:57 <mofmo1> i'm taking a break
20:56:01 <Cale> Since there, each // will make accessing the old copies a little bit slower.
20:56:44 <SamB> Cale: well, I think he wasn't using appropriate strictness either
20:56:46 <Cale> (DiffArrays use mutable update behind the scenes to make updates O(1), but accesses to the old version are handled by a list of changes relative to the current version)
20:57:11 <Cale> (and the more updates that have been done, the longer that chain of indirection gets)
20:57:12 <SamB> which would make O(1) update into O(n) update
20:57:39 <SamB> and possibly make them happen much too late...
20:57:55 <SamB> well, actually I suppose if he displayed the whole array after each //, it would be no problem...
20:58:57 <SamB> Cale: hmm, doesn't it store the updates as a list anyway?
21:00:06 <Cale> SamB: I'd have to look at it closely again, but I believe that each application of // updates the old array with a list of inverted updates and a pointer to the new array.
21:01:00 <Cale> SamB: So when you apply // again to the new array, then that pointer points at another one of these structures with a list of inverted updates and a pointer to the new array.
21:01:38 <Cale> So instead of having to check one list of inverted updates, you have to check n of them.
21:02:20 <Cale> (and maybe they're smaller so it's roughly equivalent asymptotically, but I bet there's some serious constant factor there)
21:03:53 <solrize> is there any doc around about how to use debug.trace?  it's printing stuff in a weird order, probably due to my being confused about laziness.
21:04:17 <sjanssen> IIRC, the definition is: newtype DiffArray i e = DA (MVar (Either ActualArray ([(i, e)], DiffArray i e)))
21:04:38 <mofmo1> ugh its still slower than lists though it actually runs at a decent pace now
21:05:02 <mofmo1> time to switch to unboxed arrays i guess
21:05:53 <mofmo1> yea, i really doubt that accessing was a bottleneck
21:06:03 <mofmo1> unless unboxed arrays are O(1) for update too
21:06:30 <sjanssen> mofmo1: how big is your array?
21:06:35 <mofmo1> it varies
21:06:46 <mofmo1> i have one array that's about 800
21:06:52 <sjanssen> I'd use Data.Map
21:07:16 <sjanssen> or maybe IntMap if your indices are Int
21:07:58 <sjanssen> or is this code supposed to be lightning fast?
21:09:33 <mofmo1> well it's a game of life simulator
21:09:45 <mofmo1> so it should be fast enough to handle really large game states
21:09:53 <sjanssen> so you'll have frequent, sparse updates
21:10:07 <mofmo1> well i'm updating EVERYTHING at the same time
21:10:46 <Cale> hmm, gmail has colourful tags now
21:11:24 <mofmo1> if only there was a data type that was O(1) for both updates AND accesses
21:12:02 <sjanssen> mofmo1: well, since you're updating the whole array simultaneously it doesn't matter that updates are O(n)
21:12:15 <solrize> mofmol, see http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Arrays
21:12:16 <lambdabot> http://tinyurl.com/2288uq
21:12:27 <solrize> i think you want STUArray
21:12:49 <mofmo1> sjanssen: simultaneously? not even close hahaha
21:12:55 <mofmo1> i'm doing one cell at a time
21:13:01 <sjanssen> mofmo1: then don't do that :)
21:13:12 <mofmo1> or more accurately, i calculate one cell at a time, put what is to be updated in a list THEN i update at once
21:13:15 <bugQ> Is there a quick way (existing module) to build an L-system?
21:13:37 <mofmo1> although i guess i could optimize it to not store updates if there's nothing changed
21:13:56 <Cale> bugQ: I have some code in Nymphaea which does that.
21:14:11 <bugQ> oo, found HaskLS.
21:14:32 <Cale> Yeah, lots and lots of L-system generators have been done in Haskell. :)
21:14:46 <Cale> The list monad makes it especially easy.
21:15:08 <bugQ> yes, might as well write my own for practice
21:15:28 <sjanssen> mofmo1: have you considered using another algorithm and data structure?
21:15:50 <mofmo1> i was considering groking the comonadic way but everything my level seems to be for one dimension
21:16:03 <Cale> > let exp x = case x of 'a' -> "aba"; b -> "bb" in "a" >>= exp >>= exp
21:16:05 <lambdabot>  "ababbaba"
21:16:08 <sjanssen> mofmo1: Haskell is pretty well suited to use a sparse representation, rather than an array covering the entire board
21:16:14 <Cale> > let exp x = case x of 'a' -> "aba"; b -> "bb" in "a" >>= exp >>= exp >>= exp
21:16:15 <lambdabot>  "ababbababbbbababbaba"
21:17:42 <bugQ> woo
21:19:34 <bugQ> um, how did you get away without quoting the 'b'?
21:20:05 <solrize> hahahaha
21:20:16 <solrize> oh noooo :)
21:20:18 <mofmo1> it's not a very good lambdabot
21:20:19 <solrize> > b
21:20:20 <lambdabot>  b
21:20:24 <solrize> > a + b
21:20:25 <lambdabot>  a + b
21:20:44 <bugQ> but it works in ghci as well.
21:21:26 <bugQ> creepy...
21:22:39 <bugQ> oh, hah. it's interpreting b as a placeholder var, so it's the "else".
21:23:14 <mofmo1> hahahah it works really quickly now that i told it to only update cells that would be different in the next state
21:23:31 <mofmo1> i dont expect this hack to scale up well to populous boards
21:24:28 <bugQ> let exp x = case x of 'a' -> "aba"; b -> "bb" in "c" >>= exp >>= exp
21:24:31 <bugQ> > let exp x = case x of 'a' -> "aba"; b -> "bb" in "c" >>= exp >>= exp
21:24:32 <lambdabot>  "bbbb"
21:24:35 <bugQ> yeah, ok.
21:27:49 * dfranke returns triumphantly from no-bandwidth land.
21:29:21 * bugQ hails the triumphant return.
21:38:22 <Pseudonym> I know I've asked this before, but is there a reason why Haskell' won't consider _both_ FDs and ATs?
21:38:40 <Pseudonym> Perhaps making FDs syntactic sugar for ATs?
21:38:53 <ivanm> AT = Abstract Type?
21:38:59 <Pseudonym> Associated type
21:39:09 <sclv> has it been proven yet that ATs can encode everything FDs can?
21:39:09 <ivanm> OK, and FD?
21:39:27 <Pseudonym> Functional dependency
21:39:32 <Pseudonym> sclv: No idea.
21:39:44 <Pseudonym> If not, it seems wrong to get rid of DFs.
21:39:44 <dolio> I believe so.
21:39:46 <Pseudonym> FDs.
21:39:52 <ivanm> and both of these are related to what?
21:39:55 <sclv> ATs also aren't finished yet, as I recall -- there are undefined parts of their implementation in interaction with other type extensions.
21:40:12 <Pseudonym> Is there a simple translation from FDs to ATs?
21:40:21 <sclv> as I recall, yes.
21:40:31 <sclv> or, erm, the other way around.
21:40:44 <Pseudonym> So in principle, one could be sugar for the other.
21:41:05 <sclv> FDs can encode anything ATs can, but the converse hasn't been proven.
21:41:06 <solrize> http://hpaste.org/7101#a1  more data.binary weirdness, any idea why i can have two trace calls in a row, and it only runs one of them?
21:41:11 <sclv> and ATs aren't finished as a whole yet.
21:41:33 <sclv> the switch will be massive when it comes, and probably slightly painful, although also pretty cool.
21:43:38 <sclv> solrize: why does your first trace call not look like the rest?
21:44:00 <solrize> i only had updated one them when i pasted that, but i updated it and it made no difference
21:44:08 <sclv> which one doesn't run?
21:44:08 <Pseudonym> The thing is, I can envisage situations where FDs are the more appropriate way to express something, and situations where ATs are.
21:44:32 <solrize> the second one ("again: ...") is the only one that runs
21:44:33 <Pseudonym> Like records vs non-record constructors.
21:44:42 <Pseudonym> But records are just syntactic sugar.
21:44:54 <Pseudonym> Which makes me think that it should be possible to do the same thing with FDs and ATs.
21:45:13 <sclv> the first one isn't written the same: it's just trace (blah) `seq` return 0
21:45:16 <solrize> it seems to blast out of the case expression during or after the getLazyByteString and never gets the third trace
21:45:16 <ivanm> what _are_ FDs and ATs?
21:45:22 <sclv> while the second is trace (blah) 0 `seq` return 0
21:45:45 <sclv> you can probably do just "trace blah $ return ()" and be fine...
21:45:55 <sclv> trace has a seq inside it.
21:47:00 <solrize> http://hpaste.org/7101#a2  i did it that way, same result
21:47:05 <sclv> Pseudonym: but, again, they're not proven to be equivalent. So ATs could be sugar for FDs, but not the other way -- and its complicated to make them that.
21:48:44 <solrize> http://hpaste.org/7101#a3  also fixed the other ones
21:51:16 <sclv> huh. trace is weird.
21:51:17 <dolio> FDs will be sugar for type families by 6.10, if I understand correctly.
21:52:17 <dolio> And type families are really where "associated types" become inexpressible by functional dependencies.
21:52:49 <dolio> Since they can be used independently of type classes.
21:55:21 <Heffalump> dolio: I don't think that's decided yet
21:55:29 <Heffalump> (whether they'd be sugar or not)
21:55:50 <dolio> Huh.
21:55:59 <dolio> Isn't that what the big poll on the cafe is about?
21:56:08 <SamB> Heffalump: it will probably happen sooner or later
21:56:11 <Heffalump> also, there's not much difference between writing type instance ... and instance ..., so the fact that they can be used outside type classes doesn't really mean much
21:56:15 <Heffalump> dolio: what big poll?
21:56:27 <dolio> Trying to figure out what people think FDs should mean so they can be properly translated into the new machinery?
21:56:52 <Heffalump> oh, right
21:57:27 <Heffalump> you mean the thread started by Martin Sulzmann or Tom Schrijvers looking for examples of multi-range FDs?
21:57:38 <dolio> Yeah.
21:57:46 <Heffalump> They might just be writing a paper
21:58:04 <dolio> Could be.
21:59:10 <functor> Does anyone out there have experience in using the buildExpressionParser function defined inText.ParserCombinators.Parsec.Expr? ..I have a question.
21:59:31 <Heffalump> I agree that if ATs are successful FDs will end up being sugar for them or just killed off. I'm just not sure it'll happen in 6.10.
22:01:22 <cjs__> Question: When would want want to use Strict ByteStrings instead of Lazy ones?
22:02:00 <cjs__> Re-reading the docs, it sounds as if it would only be in pathological situations, at least if performance is the concern.
22:02:13 <dolio> I suppose data families is an actual thing functional dependencies can't mimic.
22:08:02 <RyanT5000> are there any pure functional languages that are neither applicative nor concatenative
22:08:07 <RyanT5000> ?
22:08:58 <johnnowak> RyanT5000: FL might qualify
22:10:39 <johnnowak> RyanT5000: i believe backus considered it a restricted type of applicative programming
22:11:43 <RyanT5000> hm
22:12:42 <johnnowak> you could make the argument that concatenative languages are also just a restricted type of applicative languages
22:13:02 <johnnowak> i'm not sure there's much of a difference between 'a b c d' and 'd (c (b a))'
22:13:11 <RyanT5000> yeah
22:13:59 <RyanT5000> i just made up a language that doesn't even really use the idea of a function
22:14:12 <RyanT5000> i'm pretty sure it's turing-complete, but i haven't proven it yet
22:14:21 <RyanT5000> (i haven't even figured out what all the progress rules are yet)
22:15:21 <johnnowak> you might consider dataflow languages to be in their own category
22:15:34 <johnnowak> although concatenative languages are also just a particular kind of dataflow language
22:15:49 <RyanT5000> right
22:16:11 <RyanT5000> yeah, i'm trying to figure out whether what i've come up with is like anything else
22:16:14 <RyanT5000> it's *really* bizarre
22:16:33 <johnnowak> seems unlikely :)
22:16:34 <RyanT5000> i don't even really know how to describe it right now
22:22:19 <Korollary> does it have loops?
22:22:26 <RyanT5000> Korollary:
22:22:28 <RyanT5000> er
22:22:29 <RyanT5000> Korollary: no
22:22:50 <RyanT5000> it's purely declarative
22:22:57 <Korollary> logic?
22:23:31 <RyanT5000> Korollary: via library, probably - there'd need to be some kind of literal "true"/"false" thing
22:24:05 <Korollary> how is it declarative if you have no functions, predicates and connectives?
22:24:09 <RyanT5000> lol
22:24:19 <RyanT5000> well, there are connectors, but i don't know how to describe them yet
22:25:17 <RyanT5000> maybe i'm not totally sure what i meant by "purely declarative" - but values never change
22:25:36 <RyanT5000> (as in haskell)
22:26:20 <RyanT5000> as i said, i'm not totally sure how to describe it at all yet
22:26:48 <RyanT5000> i was able to write "map" in it
22:26:57 <Korollary> how do you write 1+1 in it?
22:27:29 <RyanT5000> Korollary: i haven't dealt with any kind of data aside from pairs yet
22:28:12 <RyanT5000> Korollary: the only operation right now, basically, is cons, and i'm currently trying to figure out exactly how one would go about unpacking cons cells
22:28:24 <RyanT5000> also, calling it an "operation" is kind of dubious
22:28:31 <Korollary> You need 1+1 before cons and pairs per se.
22:28:38 <RyanT5000> why?
22:28:56 <Korollary> for Turing completeness if that is your goal
22:29:27 <RyanT5000> i'm pretty sure i could make an encoding analogous to church numerals
22:30:07 <Korollary> but can you add?
22:30:23 <RyanT5000> i haven't figured that out yet! i haven't even invented the encoding yet :P
22:30:39 <RyanT5000> the only thing i've written - which i haven't tested because i can't figure out how to write an interpreter yet - is map
22:30:43 <RyanT5000> and it only works on infinitely long lists :P
22:31:14 <johnnowak> turing complete languages are boring anyway
22:31:16 <dolio> What are you mapping if you don't have functions?
22:31:24 <glguy> ?seen dons
22:31:24 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc and #haskell. I last heard dons speak 1h 10m 18s ago.
22:31:28 <RyanT5000> dolio: i kind of have something like functions
22:31:46 <RyanT5000> suffice it to say that if you saw what i made, you'd recognize it as map
22:32:06 <johnnowak> how are they not functions?
22:32:14 <RyanT5000> they can't be applied
22:32:29 <Korollary> but map specifically applies functions
22:32:48 <RyanT5000> yeah, the thing i made is equivalent in purpose and usage
22:33:01 <RyanT5000> the syntax is a little different, but not more than lisp's map is from haskell's
22:33:07 <RyanT5000> (well, there isn't really "syntax" yet)
22:33:22 <Korollary> you can either have functions, or not have map.
22:33:39 <RyanT5000> fine, call it "map-like-thing"
22:34:00 <RyanT5000> the point is, you give it a list and a function-like thing, and you get another list that's been transformed
22:34:12 <johnnowak> can you write map in the language?
22:34:16 <RyanT5000> anyway, i don't really want to argue the merits of this thing until 1) i figure out whether i can actually evaluate it and 2) i figure out whether *i* like it
22:34:35 <RyanT5000> you can make functions as a compound datastructure
22:34:53 <RyanT5000> but you have to pick some arbitrary conventions
22:35:03 * johnnowak is scare
22:35:05 <johnnowak> *D
22:35:19 <RyanT5000> i.e.: "functions" could be a library feature
22:35:20 <RyanT5000> lol
22:35:44 <johnnowak> never liked them anyway
22:35:50 <RyanT5000> right now, this thing is about 6x as complicated as lambda calculus
22:35:54 <Korollary> functions are sorta like a library feature in assembly
22:35:56 <RyanT5000> but i think i can simplify it
22:36:06 <RyanT5000> Korollary: yeah, that's true :)
22:36:14 <dolio> Can you write down map so we can see it?
22:36:40 <mm_freak> Char should be an instance of Integral and Bits at least  it sucks to have to convert back and forth all the time unnecessarily
22:36:48 <RyanT5000> no; right now everything's in weird graph-like drawings i made up
22:37:01 <dolio> Hmm.
22:37:07 <RyanT5000> i don't have a text syntax yet
22:37:20 <RyanT5000> and my "sketch syntax" is basically incomprehensible to anyone but me right now
22:37:23 <johnnowak> RyanT5000: upload drawing!
22:37:36 <RyanT5000> in a few days :)
22:37:40 * johnnowak stamps
22:37:45 <RyanT5000> lol
22:37:56 <johnnowak> either you upload it or i have to return to doing work
22:37:57 <RyanT5000> i have to practice a song (performance tomorrow)
22:38:11 <RyanT5000> i'll be back on before the end of the week, probably
22:38:17 <Korollary> @localtime johnnowak
22:38:17 <lambdabot> Local time for johnnowak is 2008-04-22 01:38:17 -0400
22:38:29 <johnnowak> i woke up at 7PM...
22:38:40 <dons> glguy: ?
22:38:43 <RyanT5000> anyway, thanks for the pointers to FL and such, johnnowak
22:38:48 <johnnowak> no problem
22:39:09 <Korollary> johnnowak: fun weekend eh?
22:39:42 <johnnowak> no...
22:40:02 <Korollary> good old insomnia?
22:40:08 <johnnowak> i'm just so excited about types i can't sleep!
22:40:20 <johnnowak> or something like that.
22:40:21 <Korollary> types in general?
22:40:32 <Korollary> or haskell's types?
22:41:23 <johnnowak> more like this paper on the type system i'm working on that needs to be done asap as part of my undergrad thesis
22:41:52 <Korollary> ah. fun.
22:59:06 <cjs__> Is there some nice syntax for currying arbitrary arguments to a function? E.g., I have "f a b c d e", and I want "g b d = f 1 b 2 d 3"?
22:59:35 <mrd> ?pl \ b d -> f 1 b 2 d 3
22:59:36 <lambdabot> flip flip 3 . flip (f 1) 2
22:59:43 <mrd> enjoy
22:59:56 <solrize> ugh
23:00:15 <mrd> yeah :/
23:00:17 <solrize> > let g b d = f a b c d e in g 1 2 3 4 5
23:00:20 <lambdabot>  Add a type signature
23:00:30 <solrize> wait that's not what i meant :)
23:00:48 <mrd> > a+0::Expr
23:00:50 <lambdabot>  a + 0
23:01:13 <solrize> > let g b d = f a b c d e; (d,e)=('d','e'); f j1 j2 j3 j4 j5 = [j1,j2,j3,j4,j5] in g 1 2 3 4 5
23:01:13 <lambdabot>  Couldn't match expected type `Expr' against inferred type `Char'
23:01:24 <solrize> hmm
23:01:27 <solrize> oh well
23:03:37 <cjs__> Errr...."nice try"?
23:03:53 <solrize> sorry, i gave up (in the middle of something)
23:05:52 <cjs__> I guess 'g b d = f "X" b "Y" d "Z"' works fine for me, actually.
23:05:53 <Cale> cjs__: There's lambda
23:06:09 <Cale> (\b d -> f 1 b 2 d 3)
23:06:12 <dolio> lambda doesn't seem so bad to me.
23:06:26 <cjs__> Yes, lambda works for me, too.
23:08:52 <gnut> hi all
23:09:20 <gnut> What does "$" mean in Haskell? It wasn't mentioned in the book I learned from, and it's pretty hard to search for "$" on the net.
23:09:49 <dolio> f $ x = f x
23:10:06 <gnut> is it for strictness evaluation?
23:10:18 <dolio> No, it's for low-precedence function application.
23:10:38 <dolio> f g x = (f g) x, but f $ g x = f (g x)
23:11:08 <gnut> ah
23:11:09 <gnut> okay.
23:11:15 <cjs__> Also handy to specify mapping across the first argument of something:
23:11:16 <cjs__> sequence_ (map ($ response) (map process processors))
23:11:18 <dolio> Which, as you can see in the second example, avoids parentheses.
23:11:52 <gnut> hmm
23:12:03 <gnut> i should use that more often then... too many parentheses
23:12:06 <cjs__> Or, more simply, "sequence_ (map ($ response) listOfRspsonseAcceptingFunctions)
23:13:38 <gnut> thanks
23:14:54 <gnut> I tried to mail a bug report to darcs-users, does darcs-users not accept messages from hotmail?
23:16:08 <quicksilver> gnut: it probably doesn't accept messages from non-subscribers
23:16:16 <gnut> ah.. okay.
23:16:16 <quicksilver> gnut: most mailing lists don't these days because of spam
23:16:35 <gnut> didn't know that... i don't usually subscribe. i usually read the archives.
23:16:37 <quicksilver> you can normally subscribe without actually receiving mail if you like.
23:16:39 <gnut> okay.
23:16:48 <quicksilver> for exactly this reason :)
23:21:05 <shachaf> @src mapM_
23:21:06 <lambdabot> mapM_ f as = sequence_ (map f as)
23:21:48 <shachaf> (Or "sequence_ (sequence listOfResponsesAcceptingFunctions response)", if you prefer. :-) )
23:22:00 <solrize> yah!!!!!!!!!  data.binary sped up my program from 10 hours to 5 minutes.  i am suddenly a lot happier with haskell :)
23:23:50 <awesame> what does Control.Monad.Fix.fix do?
23:24:01 <awesame> I understand "fixed point" but not "least fixed point"
23:24:45 <solrize> fix f = let x = f x in x
23:25:02 <dolio> You order values by their defined-ness.
23:25:08 <dolio> _|_ is least defined.
23:25:49 <dolio> For, say, Ints, all normal ints are equally defined (I believe).
23:25:55 <solrize> i think that just runs the actions f x, f f x, f f f x, ... forever
23:25:56 <dolio> Some types have more structure.
23:26:09 <dolio> Like, 1:_|_ is more defined than _|_
23:26:20 <dolio> 1:2:_|_ is more defined than 1:_|_
23:26:35 <awesame> okay, that makes some sense
23:27:06 <awesame> so how would you go about finding a least defined fixed point?
23:27:08 <EvilTerran> it gets the least defined fix point because, for any part of the result, if _|_ is a fixed-point for that part, the result of fix f is _|_ for that part
23:27:13 <dolio> So, 'fix f' finds the fixpoint 'x' that's least by that ordering and also satisfies 'f x = x'
23:27:13 <gnut> dolio: sorry for the newbie type questions on syntax... what's _|_ mean? I see that often, too.
23:27:38 <EvilTerran> generally because that part in the result depends on the same part in the parameter
23:27:45 <solrize> gnut: for full explanation, see   http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
23:27:53 <gnut> solrize: thanks
23:27:55 <cjs__> _|_ = bottom, or non-termination.
23:28:09 <EvilTerran> for instance, the whole result of id depends on its parameter, so id _|_ = _|_, so fix id = _|_
23:28:24 <gnut> cjs__: okay. thanks.
23:29:09 <levi> My program is exhausting the stack on some inputs.  Is there an easy way to see where it died?
23:30:23 <EvilTerran> i actually find the "fix f ~~ last (iterate f undefined)" explanation to be surprisingly helpful
23:32:28 <EvilTerran> because, if (iterate f undefined) reaches a point after which each value is the same as the one before, that's what the "last" value would be, and that's the value of (fix f)
23:33:36 <EvilTerran> and the limit of (iterate (1:) undefined) at infinity is (repeat 1)
23:34:18 <EvilTerran> awesame, gnut, etc - does that help it make sense?
23:35:29 <awesame> yeah, the (iterate f undefined) idea helps
23:35:53 <gnut> yeah
23:42:55 <glguy> :  ( seq quot -- n )
23:42:55 <glguy>     [ * ] compose 1 swap reduce ; inline
23:43:12 <glguy> the font used in my workspace can't render that, but my gvim can
23:46:40 <olsner> aah, big pie <3
23:49:13 <functor> Question: In what library can I find a function for hyperbolic arc-cotangent?
23:49:36 <solrize> urk... hmm
23:49:43 <dolio> @type acosh
23:49:44 <lambdabot> forall a. (Floating a) => a -> a
23:49:50 <dolio> @type atanh
23:49:51 <solrize> :t atanh
23:49:51 <lambdabot> forall a. (Floating a) => a -> a
23:49:52 <lambdabot> forall a. (Floating a) => a -> a
23:49:53 <solrize> oops
23:50:05 <dolio> Prelude?
23:50:09 <functor> nope
23:50:10 <solrize> :t acoth
23:50:11 <lambdabot> Not in scope: `acoth'
23:50:19 <solrize> :t cotangent
23:50:20 <lambdabot> Not in scope: `cotangent'
23:50:22 <dolio> Ah.
23:50:39 <solrize> > let acoth x = atanh (1/x) in acoth 1
23:50:41 <lambdabot>  Infinity
23:50:47 <solrize> > let acoth x = atanh (1/x) in acoth 0.1
23:50:48 <lambdabot>  NaN
23:50:54 <solrize> > let acoth x = atanh (1/x) in acoth 3.0
23:50:54 <lambdabot>  0.3465735902799726
23:51:34 <sieni> > let acoth x = 0.5 log ((x+1)/(x-1)) in acoth 1.0
23:51:35 <lambdabot>        add an instance declaration for (Fractional ((a -> a) -> t -> a1))
23:51:40 <solrize> > tanh 0.34657
23:51:41 <lambdabot>  0.33333014196953836
23:51:47 <sieni> > let acoth x = 0.5 log ((x+1.0)/(x-1.0)) in acoth 1.0
23:51:47 <lambdabot>        add an instance declaration for (Fractional ((a -> a) -> t -> a1))
23:51:56 <sieni> > let acoth x = 0.5 * log ((x+1.0)/(x-1.0)) in acoth 1.0
23:51:58 <lambdabot>  Infinity
23:52:04 <sieni> > let acoth x = 0.5 * log ((x+1.0)/(x-1.0)) in acoth 0.5
23:52:05 <lambdabot>  NaN
23:52:20 <sieni> > let acoth x = 0.5 * log ((x+1.0)/(x-1.0)) in acoth 3.0
23:52:21 <lambdabot>  0.34657359027997264
23:52:45 <functor> ehh 1/ atanh x works fine =]
23:52:54 <solrize> atanh 1/x
23:53:06 <functor> thanks oh yes
23:53:53 <olsner> bos: re stringsearch: "Strict targets return Int indices and lazy targets return Int64 indices.", but all the functions return Int64 (and none Int)
23:54:18 <solrize> olsner, whew :)
23:55:02 <olsner> solrize: these are *important* issues :P
