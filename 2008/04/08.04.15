00:00:24 <Korollary> it's as generalized as can be
00:00:46 <ulfdoz> The Goal is, to match iteratively a substring of a string.
00:00:50 <pantsd> rocking
00:07:50 <Cale> ulfdoz: null :: [a] -> Bool
00:08:10 <Cale> ulfdoz: Whereas stm :: ST s [String]
00:08:35 <Cale> ulfdoz: So in order to apply null, you need to use fmap
00:09:34 <Cale> Or you can simply use a do block to name the result of stm, and then return the result of applying null
00:09:53 <Cale> runST (do v <- stm; return (null v))
00:11:51 <ulfdoz> And what's the point of runST, if not extracting the second arg of the ST?
00:12:15 <sjanssen> so does anyone know why we have both:
00:12:18 <sjanssen> @free head
00:12:19 <lambdabot> f . head = head . $map f
00:12:22 <sjanssen> @ft head
00:12:23 <lambdabot>  forall T1,T2 in TYPES. forall h1 :: T1 -> T2, h1 strict.
00:12:23 <lambdabot>    forall x1 :: [T1].
00:12:23 <lambdabot>      h1 (t1 x1) = t1 (map h1 x1)
00:12:51 <sjanssen> does anyone actually use ft?  I'm considering removing it
00:16:58 <OceanSpray> I don't get the forall a. stuff.
00:17:08 <OceanSpray> what's that for?
00:17:21 <sjanssen> @type id
00:17:22 <lambdabot> forall a. a -> a
00:18:09 <sjanssen> for every single type, which we'll call 'a', id has the type 'a' to 'a'
00:18:40 <sjanssen> OceanSpray: they're generally not necessary, but ghci sticks them in when -fglasgow-exts are on
00:18:43 <sjanssen> @type runST
00:18:44 <lambdabot> forall a. (forall s. ST s a) -> a
00:18:55 <OceanSpray> oy
00:21:59 <Cale> In the type of runST, the forall s makes sure that the parameter you pass to runST is really polymorphic in the type s.
00:22:23 <takamu> hi
00:22:26 <Cale> hello
00:26:12 <sjanssen> Cale: I'm making some large changes in lambdabot -- I've removed hoogle, djinn and ft from the repo in favor of using the version packaged on hackage
00:26:28 <Cale> sjanssen: cool.
00:26:30 <sjanssen> so before you rebuild lambdabot, you'll want to install those
00:26:37 <Cale> Yep :)
00:26:40 <sjanssen> and make sure they're on $PATH
00:26:48 <paolino> modularity :P
00:26:53 <Cale> They're installable from Hackage?
00:27:03 <sjanssen> Cale: yep, 'cabal install' should even work
00:27:27 <dolio> Next thing you know he'll be getting rid of the 3 or 4 different haskell parsers in lambdabot.
00:27:35 <Cale> Cool. I have cabal-install set up in my user directory on code, so it shouldn't be a problem.
00:27:44 <Cale> heh
00:27:44 <sjanssen> except for ftshell, I had to rejig dependencies there
00:27:54 <sjanssen> dolio: I'm not that brave!
00:28:00 <dolio> :)
00:28:09 <sjanssen> though I do want to remove the nasty little perl script dons stuck in :)
00:42:19 <quicksilver> sjanssen: what does the nasty little perl script do?
00:46:22 <sjanssen> quicksilver: it asks timeanddate.com for the time in a city
00:46:33 <sjanssen> and, actually, it looks like it isn't even used any more
00:48:34 <OceanSpray> too... much... orz
01:30:30 <Baughn> @let 1 + 1 = 3
01:30:45 <lambdabot> thread killed
01:32:44 <Cale> @let 1 + 1 = 3
01:32:45 <lambdabot> Defined.
01:32:52 <Cale> > 1 + 2
01:32:54 <lambdabot> Terminated
01:33:00 <Cale> @undef
01:33:01 <lambdabot> Undefined.
01:33:28 <Cale> > let 1 + 1 = 3 in map (+1) [1,1,1,1]
01:33:29 <lambdabot>  [3,3,3,3]
01:43:10 <chylli> identify 3843054
01:43:43 <glguy> oops
01:43:46 <czShadoW> Nice password.
01:44:01 <glguy> looks like ******* here
01:44:43 <sjanssen> not here :/
01:44:58 <sjanssen> chylli: better change your password
01:45:12 * glguy sends sjanssen off to read bash.org
01:46:19 <kaol> > map (const '*') "dsjfhdsf"
01:46:21 <lambdabot>  "********"
01:51:21 <cjs> Hey, so what's the deal with the hardcoding of /opt/local/lib/libreadline in ghc 6.8.2?
01:57:49 <funktio> let permutation = (==) `on` sort . show in permutation 87109 79180
01:57:52 <funktio> > let permutation = (==) `on` sort . show in permutation 87109 79180
01:57:54 <lambdabot>  True
01:58:21 <solrize_> :t on
01:58:23 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
01:59:33 <Cale> @djinn (b -> b -> c) -> (a -> b) -> a -> a -> c
01:59:33 <lambdabot> f a b c _ = a (b c) (b c)
01:59:42 <Cale> heh, not quite
02:00:09 <funktio> @src on
02:00:10 <lambdabot> (*) `on` f = \x y -> f x * f y
02:00:41 <solrize_> hmm i think i get it
02:01:24 <solrize_> hm maybe not.
02:01:34 <funktio> solrize_: something like this is a common use for on:  sortBy (compare `on` length)
02:01:44 <funktio> it sorts a list of lists based on their length
02:01:55 <solrize_> yeah, that's the kind of example i was looking for
02:02:19 <solrize_> thanks
02:02:41 <ziman> it's like binary function composition :)
02:03:18 <funktio> yeah :)
02:06:51 <quicksilver> or it's like a homomorphic image
02:06:55 <quicksilver> if you're into that kind of thing
02:08:16 <solrize_> it does look like a homomorphic image but somehow doesn't fit the picture.  i'll have to think about it when i'm awake, it's 0200 here.
02:10:41 <quicksilver> solrize_: if (+) is an operator (A -> A -> x) and f is a homomorphism (B -> A)
02:10:58 <quicksilver> solrize_: then (+)^{f} is an operator (B -> B -> x)
02:11:20 <quicksilver> solrize_: and, under certain conditions, the properties of (+)^{f} are the same properties as (+)
02:11:34 <quicksilver> solrize_: that's the "preimage of (+) under the homomorphism f"
02:11:35 <quicksilver> or something
02:11:39 <quicksilver> I forget the standard wording.
02:11:45 <quicksilver> in haskell, (+) `on` f
02:12:23 <solrize_> yeah i understand that, i just think of homomorphisms as having some particular structure at each end (e.g. group homomorphism, ring homorphism etc)
02:13:03 <quicksilver> yes. well under some circumstances if f is a homorphism and (+) is natural w.r.t that structure
02:13:11 <quicksilver> then (+)^{f} will still be natural
02:13:20 <quicksilver> and indeed {f} induces a structure on B
02:13:22 <solrize_> i'm not sure what natural means
02:13:22 <quicksilver> from the structure on A
02:13:27 <quicksilver> nothing precise
02:13:30 <solrize_> oh
02:13:31 <quicksilver> it would depend on the domain
02:13:47 <solrize_> i know it's a term from category theory but i don't know much of that
02:13:50 <quicksilver> if A is a group and (+) is multiplication then f induces a group on a quotient of B
02:13:56 <opqdonut> another way of putting is that "f is compatible with (+)"
02:14:01 <solrize_> yeah
02:14:09 <opqdonut> *putting it
02:14:11 <quicksilver> so f lifts structures from A back to B
02:14:15 <quicksilver> (back to a quotient of B)
02:14:18 <quicksilver> B/f
02:14:45 <solrize_> sure, what i mean is i don't see such a structure in `on` f
02:16:07 <solrize_> i mean if there were g::a->a   preserved under `on`, that would be more like what i think of as homomorphisms
02:16:25 <quicksilver> yes, the structure isn't definitely there.
02:16:26 <quicksilver> I agree.
02:16:52 <quicksilver> it's more like if "f" preserves the following laws about (+), then f lifts a (+)-structure from A back to B/f
02:17:08 <quicksilver> there is an important *if*
02:17:26 <solrize_> yeah in practice i expect there's a few idioms like that sorting one and i'd like to just look at those.  i wish the docs gave examples and explanations
02:18:12 <solrize_> ya know, maybe i should plop all the core lib docs into wikibooks and start annotating them like "a tour through the haskell prelude"
02:18:26 <solrize_> and hope other ppl joined into doing that
02:18:50 <opqdonut> :)
02:23:03 <sjanssen> can template Haskell change the imports of a module?
02:24:57 <solrize_> err import is not in an expression so can you use the $| around it?
02:25:07 <solrize_> liskell maybe...
02:28:17 <solrize_> anyway i dunno i'm just guessing
02:51:24 <aLone> hy, i need bugs, if u have, pm me, thx friend
02:52:02 <Stinger_> need bugs ...
02:52:10 <opqdonut> ._.
02:52:42 <quicksilver> bad luck, we don't have bugs here
02:52:49 <quicksilver> because of static typing, all our code is bug-free
03:04:03 <Jaak> @pl \f g -> f >>= \t -> g >> return t
03:04:03 <lambdabot> (. ((. return) . (>>))) . (>>=)
03:04:08 <Jaak> jeebus
03:04:45 <opqdonut> @do f >>= \t -> g >> return t
03:04:45 <lambdabot> f >>= \t -> g >> return t not available
03:04:59 <quicksilver> @redo  f >>= \t -> g >> return t
03:04:59 <lambdabot> do { t <- f; g; return t}
03:05:04 <opqdonut> ah, redo
03:05:19 <Jaak> this doesn't help me at all
03:05:33 <quicksilver> I agree that's quite a common idiom
03:05:44 <quicksilver> along with do { e ; t <- f; g; return t}
03:05:56 <quicksilver> i.e. "do stuff around f but preserve its return value"
03:06:03 <Jaak> mhmhh
03:06:05 <opqdonut> parsec has some combinators for that
03:06:15 <opqdonut> they'd probably generalize pretty well too
03:06:44 <quicksilver> it's a bit like bracket
03:06:49 <quicksilver> except not about exceptions :)
03:07:00 <opqdonut> yeh
03:07:02 <Jaak> oh, it just so happens that i'm working in parsec monad :P
03:07:03 <quicksilver> it's related to the notion of around-advice
03:07:11 <opqdonut> Jaak: :P
03:07:37 <opqdonut> Jaak: try between
03:07:39 <opqdonut> :t between
03:07:40 <lambdabot> Not in scope: `between'
03:07:50 <opqdonut> :t Text.ParserCombinators.Parsec.Combinator.between
03:07:51 <lambdabot> forall tok st open close a. Text.ParserCombinators.Parsec.Prim.GenParser tok st open -> Text.ParserCombinators.Parsec.Prim.GenParser tok st close -> Text.ParserCombinators.Parsec.Prim.GenParser tok
03:07:51 <lambdabot> st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
03:08:01 <opqdonut> great typesig...
03:08:19 <Jaak> between pzero g f -- i guess
03:08:34 <opqdonut> yeah, sounds good
03:08:41 <quicksilver> I actually think it's a great example of where do notation shines :)
03:08:44 <quicksilver> I would write
03:08:57 <quicksilver> do { openparen ; e <- expression ; closeparen ; return e }
03:09:03 <quicksilver> for a bracketed-expression parser
03:09:19 <quicksilver> I think that's about as clear and concise as you can hope for
03:09:27 <quicksilver> between expression openparen closeparen
03:09:28 <opqdonut> and (surprise, surprise) parsec has a combinator for that too
03:09:30 <quicksilver> I don't like as much.
03:09:43 <quicksilver> because I like the things to come int he order they come in
03:09:57 <quicksilver> IE I like my haskell code to resemble the BNF grammar, approximately
03:10:04 <opqdonut> well yeah, the do notation resembles the underlying cfg more closely
03:10:05 <opqdonut> yeah
03:22:15 <curried> anyone familiar with the xml-rpc library ?
03:32:30 <cjs> Haskell.org is having issues?
03:32:40 <cjs> @hoogle maybeToList
03:32:40 <lambdabot> Data.Maybe.maybeToList :: Maybe a -> [a]
03:32:41 <opqdonut> yeah, complicated childhood
03:33:08 <cjs> I really need to get a lambdabot of my own one day.
03:44:12 <dolio> openparen *> expression <* closeparen
04:00:26 <paolino> @hoogle ifM
04:00:26 <lambdabot> System.Directory.createDirectoryIfMissing :: Bool -> FilePath -> IO ()
04:00:26 <lambdabot> Foreign.C.Error.throwErrnoIfMinus1 :: Num a => String -> IO a -> IO a
04:00:26 <lambdabot> Foreign.C.Error.throwErrnoIfMinus1_ :: Num a => String -> IO a -> IO ()
04:00:55 <paolino> @update
04:00:55 <lambdabot> Unknown command, try @list
04:01:45 <DavidLeon> is there some haskell sample apps GUI stuffs
04:01:46 <DavidLeon> *are
04:02:09 <DavidLeon> and some community like some opensource haskell specific site
04:03:09 <Baughn> DavidLeon: Hackage?
04:03:09 <lambdabot> Baughn: You have 2 new messages. '/msg lambdabot @messages' to read them.
04:03:30 <DavidLeon> ?hackage
04:03:30 <lambdabot> http://hackage.haskell.org
04:03:43 <DavidLeon> Baughn: umm, thx
04:03:50 <DavidLeon> hackage?
04:03:58 <DavidLeon> err
04:04:07 <DavidLeon> why lambdabot doesn't send me PM
04:04:14 <DavidLeon> Baughn: hackage?
04:04:23 <Baughn> If you send it PMs, it'll send you PMs back
04:04:29 <Baughn> DavidLeon: What about it?
04:04:52 <DavidLeon> Baughn: i thought DavidLeon: Hackage? triggers that
04:05:06 <Baughn> It does not.
04:16:35 <DavidLeon> any GUI snapshot of haskell available?
04:18:51 <paolino> what is a Gui snapshot ?
04:21:12 <DavidLeon> GUI app
04:21:44 <DavidLeon> sorry for not expressing clearly
04:22:29 <paolino> bindings to gtk is the most supported  gui, AFAIK
04:23:35 <paolino> but still not so easy to get them running
04:24:20 <DavidLeon> paolino: thank you very much
04:24:23 <paolino> haskell is not mature in that direction as most languages are
04:24:27 <DavidLeon> so haskell targets on data processing?
04:24:51 <paolino> sure
04:24:52 <Baughn> Haskell targets.. haskell, mostly
04:25:24 <Baughn> We're striving with all our might to avoid popularity, for if we achieve popularity we can no longer keep changing the language
04:26:54 <DavidLeon> Baughn: you can , just you will be blamed :p
04:27:07 <DavidLeon> weird
04:27:17 <DavidLeon> i thought haskell is almost well done and fixed
04:27:54 <DavidLeon> what kind of stuff you guys change of haskell ?
04:27:55 <Baughn> Hardly. Look at all the GHC extensions.
04:28:15 <Baughn> And we still don't have any good solution to data accessors
04:28:25 <DavidLeon> data accessors?
04:28:26 <DavidLeon> what's that
04:28:46 <Baughn> data Foo = Foo { foo :: Int, bar :: String }
04:29:09 <Baughn> foo, bar <- Accessors. Sadly, they're *global*, meaning you can't have two data structures with the same field names.
04:29:41 <DavidLeon> oh , that's bad enough /o\
04:29:43 <Baughn> GHC has one extension that helps a little, but the final solution has not yet been found
04:30:24 <DavidLeon> that's something impossible to be solved?
04:30:34 <DavidLeon> either use some token as seperator
04:30:44 <DavidLeon> Foo{foo for foo and Foo{bar for bar
04:30:53 <Baughn> Of course it can be solved
04:30:57 <Baughn> It just /hasn't/ been, yet
04:31:17 <Baughn> DavidLeon: That solution is no better than just embedding the ADT name in the accessor names
04:32:00 <DavidLeon> Baughn: what kind of problem data accessors still confront?
04:32:17 <DavidLeon> for that particular extension
04:32:49 <Baughn> DavidLeon: Mostly, that the people who can solve it disagree about what the solution is
04:33:15 <Baughn> I'm not really much into it. I'm still too much in awe of the ghc developers.
04:33:36 <DavidLeon> how long ghc has been developed?
04:33:57 <Baughn> http://en.wikipedia.org/wiki/Glasgow_Haskell_Compiler <-- 1989
04:33:58 <lambdabot> Title: Glasgow Haskell Compiler - Wikipedia, the free encyclopedia
04:34:13 <DavidLeon> oh
04:34:23 <DavidLeon> hah, so haskell is quite old
04:34:33 <nornagon> you could say so :P
04:35:12 <Baughn> We're using haskell'98 now, but.. yes
04:35:19 <Baughn> Er
04:35:26 <Baughn> Okay. Mostly I'm *not* using haskell'98.
04:35:37 <Baughn> More like GHC'08. :P
04:35:55 <Baughn> (And haskell' is already out of date. The indignity.)
04:38:51 <paolino> in fact I tend to use tuples , not to hate accessors every 2 lines
04:39:38 <paolino> Baughn: what extension helps ?
04:39:52 <paolino> *which
04:41:11 <quicksilver> I don't see any logic there
04:41:17 <quicksilver> use tuples not to have accessors?
04:41:28 <quicksilver> you can use data Foo = Foo Int String
04:41:38 <quicksilver> no accessors there :) well, no field selectors, to be precies
04:41:58 <paolino> right , then I use a tuple instead
04:42:18 <quicksilver> why use a tuple instead of data Foo = Foo Int String ?
04:42:36 <quicksilver> (I mean, I know some answers to that question, but you're conflating two issues)
04:42:47 <quicksilver> using a tuple is giving up on having explanatory types
04:43:05 <paolino> probably , I just hate \n -> n {deps = tf (deps n)}
04:43:39 <paolino> which I thought it has to do with accessors
04:43:49 <quicksilver> you prefer \(a,b) -> (a, tf b) ?
04:44:12 <mauke> \(Foo a b) -> Foo a (tf b)
04:44:27 <quicksilver> exactly what I was about to say.
04:44:33 <quicksilver> but I wanted to understand what paolino meant
04:44:41 <resiak> id *** tf
04:44:44 <funktio> second tf :P
04:44:48 <opqdonut> :)
04:44:59 <quicksilver> that doesn't scale to n-tuples though
04:45:08 <quicksilver> which I assume is the issue.
04:45:53 <paolino> mmhh, it's not that I prefer it, but  I hate to use higher things, when they give no advantage on clearity
04:46:17 <paolino> and I suppose data is built on tuples
04:46:37 <mauke> tuples are built on data
04:46:44 <quicksilver> \(Foo a b) -> Foo a (tf b) is much much nicer
04:46:50 <quicksilver> it gives your functions the right types
04:47:01 <quicksilver> the type 'Foo' is much more useful that the type '(Int,String)'
04:47:22 <quicksilver> (mauke is right, too, data is fundamental, tuples are just one example with funky syntac)
04:47:48 <quicksilver> there are two reasons to use tuples that I'm aware of
04:47:56 <quicksilver> (1) as throwaway types you can't be bothered to name
04:48:05 <quicksilver> (2) to reuse library functions which work on tuples
04:48:10 <paolino> quicksilver: but why I should mention 'a' in \(Foo a b) -> Foo a (tf b)
04:48:20 <quicksilver> paolino: that's a very interesting question.
04:48:28 <quicksilver> paolino: but that happens in the tuple version as wel, doesn't it?
04:48:33 <quicksilver> \(a,b) -> (a,tf b)
04:48:33 <paolino> that is all my point
04:48:44 <quicksilver> I completely agree with that point.
04:48:49 <mauke> so, functional references
04:48:57 <paolino> I thought wrongly tuples were more basic then data
04:49:04 <quicksilver> I'd love a nicer syntax for \n -> n { foo = tf (foo n) }
04:49:15 <SamB> @src (,)
04:49:15 <lambdabot> Source not found. Maybe you made a typo?
04:49:18 <SamB> aww
04:49:33 <quicksilver> I have code scattered with stuff like this : modifyMVar_ mphmv (\mph -> return (mph { mphState = Playing p l}))
04:49:47 <quicksilver> which is a bit annoying
04:50:29 <paolino> is this \n -> n { foo = tf (foo n) } fast as the same tuple op ?
04:50:46 <paolino> if the data was a tuple
04:51:04 <mauke> it's longer so it must be slower
04:51:17 <paolino> to run ?
04:51:28 <mauke> ignore me, I'm trolling
04:51:36 <quicksilver> paolino: yes, it's as fast.
04:51:38 <quicksilver> it's the same thing.
04:51:50 <paolino> ok, then I will use it more
04:51:57 <quicksilver> I agree 100% it's ugly
04:52:00 <ToRA> quicksilver: surely someone has written  a th script to take data Foo { x :: A, y :: B } and generate modify_x :: (A -> A) -> Foo -> Foo, modify_y, etc..?
04:52:05 <quicksilver> ToRA: yes.
04:52:10 <quicksilver> ToRA: the question is the best way to do it
04:52:16 <quicksilver> probably lenses, methinks
04:52:20 <quicksilver> aka functional references
04:52:32 <quicksilver> I thnk ndm's Data.Derive can do it or at least something similar.
04:52:51 <quicksilver> it's on my list of "things to think through and learn how to do properly"
04:52:54 <quicksilver> but I haven't done it yet.
04:53:03 <paolino> well, how they could push data families in the language before these things ?
04:53:41 <quicksilver> ;)
04:53:52 <quicksilver> because data families were easier?
04:54:12 <paolino> also data modifications have their role in "resl" programs
04:54:16 <paolino> "real"
04:54:31 <quicksilver> well at one level this is only a trivial syntactic issue
04:54:37 <quicksilver> it doesn't affect expressibility
04:54:43 <quicksilver> however, I also, like you, find it annoying
04:54:46 <quicksilver> and look for better ways
04:54:57 <paolino> quicksilver: did you read that paper on data families ?
04:55:05 <quicksilver> no, I don't thnk so
04:55:06 <paolino> icfp 08 ?
04:55:32 <paolino> do that, and tell me if that is any easy ;-)
04:55:44 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6991
04:55:53 <paolino> it's just much more tripping
04:55:55 <paolino> :)
04:55:56 <quicksilver> I didn't say it was easy.
04:56:04 <quicksilver> Just easier than solving the record modification problem.
04:56:07 <quicksilver> ;)
04:56:19 <roderyk> can someone check out http://hpaste.org/6991 ; I'm still struggling with understanding basic IO () ; )
04:56:28 <paolino> ok, I rant off
04:56:39 <quicksilver> roderyk: add "return ()" after the one which returns a Bool which you don't care about.
04:56:49 <roderyk> ah, ok
04:56:49 <quicksilver> roderyk: you'll need to make it a little do block
04:56:53 <quicksilver> or just write >> return ()
04:57:04 <roderyk> I see now; thanks
04:57:13 <quicksilver> FWIW, people say not to use HashTable
04:57:17 <quicksilver> but I don't want to distract you :)
04:57:18 <quicksilver> it does work.
04:57:35 <roderyk> quicksilver: any particular ugly reasons not to use it?
04:57:49 <quicksilver> roderyk: the API is all in IO
04:57:52 <quicksilver> which is a bit unpleasant
04:58:03 <quicksilver> and the supposed speed benefits don't materialize in practice, apparently.
04:58:07 <quicksilver> I haven't tested that.
04:58:31 <paolino> (ehm , last one , lets collect all 09 soc money for new record syntax !)
04:59:10 <roderyk> quicksilver: yes, I've been having a little trouble understanding why it's all IO... ><  Is there a common lib for working with some kind of (key,val) maps that's non IO?
04:59:20 <quicksilver> roderyk: Data.Map
04:59:22 <paolino> Data.Map
04:59:27 <paolino> and friends
04:59:30 <quicksilver> roderyk: much nicer interface for most purposes.
04:59:48 <quicksilver> of course, it doesn't do inplace modification. Instead 'insert' returns the new one and you still have the old one.
04:59:54 <quicksilver> but it's pretty efficient nonetheless
05:00:01 <roderyk> I will look into that, probably will save me a heap of trouble :)
05:00:19 <swiert> ?
05:00:40 <quicksilver> swiert: ? ?
05:00:52 <swiert> quicksilver: woops. Sorry - typo.
05:01:33 * quicksilver nods
05:11:19 <mapreduce> :t partition
05:11:21 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
05:11:38 <mapreduce> :pl (a -> Bool) -> [a] -> [[a]]
05:12:05 <mapreduce> @hoogle (a -> Bool) -> [a] -> [[a]]
05:12:05 <lambdabot> Distribution.Simple.Utils.breaks :: (a -> Bool) -> [a] -> [[a]]
05:12:34 <mapreduce> > breaks (\x == 3) [1,2,3,2,3,22,2,3]
05:12:34 <lambdabot>  Parse error at "==" (column 12)
05:12:42 <mapreduce> > breaks (\x -> x == 3) [1,2,3,2,3,22,2,3]
05:12:43 <lambdabot>   Not in scope: `breaks'
05:13:05 <mapreduce> > Distribution.Simple.Utils.breaks (\x -> x == 3) [1,2,3,2,3,22,2,3]
05:13:06 <lambdabot>   Not in scope: `Distribution.Simple.Utils.breaks'
05:13:23 <paolino> mapreduce: looking for split ?
05:13:33 <mapreduce> :t split
05:13:34 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
05:13:51 <paolino> I didn't say it exists :)
05:13:57 <mapreduce> I want to split in more than one place.
05:14:19 <paolino> it's not in any base library that I know
05:14:31 <quicksilver> no, it's not
05:14:33 <mapreduce> I could concoct it from partition.
05:14:35 <quicksilver> it comes up every week or two
05:14:41 <paolino> eh
05:14:46 <quicksilver> @index partition
05:14:46 <lambdabot> Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
05:14:56 <quicksilver> :t break
05:14:56 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
05:15:02 <quicksilver> hmr. partition is just break?
05:15:06 <quicksilver> or they renamed it?
05:15:30 <paolino> quicksilver: partition is a filter
05:15:48 <funktio> > partition even [1..5]
05:15:50 <lambdabot>  ([2,4],[1,3,5])
05:15:54 <funktio> > break even [1..5]
05:15:54 <lambdabot>  ([1],[2,3,4,5])
05:16:07 <mapreduce> @src break
05:16:07 <lambdabot> break p =  span (not . p)
05:16:13 <bolrod> > partition (==3) [1..10]
05:16:14 <lambdabot>  ([3],[1,2,4,5,6,7,8,9,10])
05:16:16 <mapreduce> @src span
05:16:16 <lambdabot> Source not found. Are you on drugs?
05:16:20 <paolino> :t unfoldr
05:16:21 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
05:16:22 <bolrod> hmmm
05:16:44 <quicksilver> paolino: oh. right.
05:16:51 <quicksilver> good point :)
05:18:10 <jcaldwell> HsSyc does not implement a load feature...
05:21:37 <paolino> :t \f -> unfoldr (\x -> if null x then Nothing else Just $ break  f x)
05:21:38 <lambdabot> forall a. (a -> Bool) -> [a] -> [[a]]
05:22:22 <ToRA> > let split pred = takeWhile (not . null) . unfoldr (Just . (second $ drop 1) . break pred) in split even [1..10]
05:22:22 <lambdabot>  [[1],[3],[5],[7],[9]]
05:22:37 <paolino> > unfoldr (\x -> if null x then Nothing else Just $ break  f x) (==',') "mio,tuo"
05:22:42 <lambdabot>      The section `(== ',')' takes one argument,
05:22:42 <lambdabot>     but its type `[a]' has none
05:23:12 <ToRA> > let split = \f -> unfoldr (\x -> if null x then Nothing else Just $ break  f x) in split even [1..10]
05:23:13 <lambdabot>  [[1],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
05:23:18 <mapreduce> ToRA: Did you use @pl for that?
05:23:46 <ToRA> mapreduce: erm, can't remember - it was probably involved, it's the version i've had kicking around since last year
05:24:30 <mapreduce> Interesting.
05:24:40 * mapreduce wanders off to wrap unfoldr around his head.
05:24:48 <ToRA> actually, i assume pl would take out the pred argument in my version
05:25:15 <ToRA> @pl \pred -> takeWhile (not . null) . unfoldr (Just . (second $ drop 1) . break pred)
05:25:15 <lambdabot> (takeWhile (not . null) .) . unfoldr . ((Just . second (drop 1)) .) . break
05:25:24 <ToRA> yummy
05:25:25 <paolino> > (\f ->unfoldr (\x -> if null x then Nothing else Just $ let (xs,_:ys) = break  f x in (xs,ys))) (==',') "mio,tuo"
05:25:26 <lambdabot>   Irrefutable pattern failed for pattern (xs, _ : ys)
05:27:45 <trez> > liftM2 (^) [1..10] [1,2] :: [Expr]
05:27:45 <lambdabot>  [1,1 * 1,2,2 * 2,3,3 * 3,4,4 * 4,5,5 * 5,6,6 * 6,7,7 * 7,8,8 * 8,9,9 * 9,10,...
05:28:41 <Vq^> what is Expr?
05:29:24 <funktio> @src liftM2
05:29:24 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
05:31:08 <mapreduce> @check \xs -> let split pred = takeWhile (not . null) . unfoldr (Just . (second $ drop 1) . break pred) in xs==join "," $ split (\x -> x==',') (xs :: [String])
05:31:09 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
05:31:18 <mapreduce> @t join
05:31:18 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
05:31:22 <mapreduce> :t join
05:31:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
05:31:23 <chylli> identify 3843054
05:31:53 <ToRA> mapreduce: by join you mean \sep ->  concat . intersperse sep ?
05:32:33 <mapreduce> @check \xs -> let split pred = takeWhile (not . null) . unfoldr (Just . (second $ drop 1) . break pred) in let join sep = concat . intersperse sep in xs==join "," $ split (\x -> x==',') (xs :: [String])
05:32:34 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `Bool'
05:33:21 <ToRA> mapreduce: my version of split will fail that check, as it treats duplicated adjacent separators as one
05:34:31 <mapreduce> Fair enough.
05:37:50 <ToRA> @scheck  \xs -> let split pred = takeWhile (not . null) . unfoldr (Just . (second $ drop 1) . break pred) in let join sep = concat . intersperse sep in xs == join [True] (split id xs)
05:37:51 <lambdabot>   Failed test no. 2. Test values follow.: [True]
05:42:34 <ivanm> is there a list somewhere of which unis have people working on our favourite programming language?
05:46:12 <oklopol> ivanm: you prolly mean Java?
05:46:21 <ivanm> @slap oklopol
05:46:21 <lambdabot> stop telling me what to do
05:46:37 <ivanm> then again, I _did_ use that wording to get some kind of stupid response :p
05:46:53 <oklopol> i figured i had no choice :)
05:47:04 <chr1s> ivanm: I'm a student at Utrecht, and there's definitely a lot of Haskelling going on here.
05:47:25 <jtraub> Hello
05:47:38 <Botje> my uni is pretty devoid of haskell atm :(
05:47:39 <jtraub> can i ask here some dumb questions about Haskell?
05:47:53 <Botje> sure
05:48:41 <ivanm> chr1s: ummm.... English preferred :p
05:49:30 <chr1s> ivanm: everybody speaks English and the master is in English.
05:49:42 <chr1s> ivanm: http://www.cs.uu.nl/wiki/bin/view/Center/WebHome
05:49:46 <ivanm> chr1s: yes, but once you walk outside the university... :p
05:51:14 <chr1s> ivanm: it's not too bad, actually. but sure, if you want a university in England then Utrecht is a rather bad choice ;)
05:51:37 <ivanm> well, I'd accept scotland or wales... :p
05:52:17 <ivanm> but my biggest problem with utrecht is having to learn a new language just to be understood by the people who live there ;-)
05:54:05 <tromp> u have to learn english?
05:54:53 <ivanm> tromp: no.... but I'd have to learn whatever language is spoken in the netherlands (dutch?)...
05:55:01 <pejo> ivanm, going abroad is an excellent opportunity to learn a new language though! (And I'm guessing you could get by without learning for a whole bunch of years).
05:55:39 <ivanm> pejo: true... but I already have two other languages that I really should be proficient in so that I could talk to rellies, etc. that I don't know too well :s
05:55:39 <tromp> there's few dutch who don't speak english
05:57:55 <oklopol> everyone knows english.
05:58:15 <ivanm> oklopol: I beg to differ
05:58:24 <jtraub> If i understood correctly typeclasses are similar to interfaces in PHP/Java
05:58:30 <jtraub> right?
05:59:41 <paczesiowa> yes
06:00:08 <oklopol> ivanm: everyone in europa knows english
06:00:15 <oklopol> bit better? :|
06:00:37 <oklopol> i want to make a bigger statement than "yes, many danish people know english."
06:00:54 <ivanm> oklopol: no, because I know people in Europe who _don't_ know english!
06:01:14 <shepheb> I think it depends a lot on if, and for how long, English has been the second language taught in schools.
06:01:20 <oklopol> ivanm: like that proves anything! :D
06:01:23 <ivanm> and where
06:01:29 <oklopol> oh, right, it does.
06:01:31 <Gilly> how do we define 'to know', 'to be aware of'? :)
06:02:24 <oklopol> hi Gilly Gilliard, long time no see
06:02:30 <vincenz> to-know :: (Knowledge k, Person p, Monad m) => k -> p -> m Bool
06:02:52 <Gilly> hello :)
06:03:02 <oklopol> know(Person, Datum)
06:03:02 <pejo> ivanm, well, people here are telling you that the dutch speak english. Take their word for it. :-)
06:03:41 <ivanm> pejo: heh, fine... but whilst the courses, etc. might be in English even a fair amount of the web site is in dutch!
06:03:50 <paolino> vincenz: the monad is for it can change over time ?
06:04:09 <vincenz> yep
06:04:14 <mib_wb8p29> Hello, although I'm relatively new to Haskell, I was able to gather some experience.  One thing that I do not understand at all, however, are the numerical data types.  For examples, how to convert an Integer to an Int64 or Word64.  Does anybody have useful pointers?
06:04:26 <vincenz> :t fromIntegral
06:04:27 <lambdabot> forall a b. (Num b, Integral a) => a -> b
06:04:36 <vincenz> > fromIntegral (1 :: Integer) :: Word64
06:04:37 <lambdabot>  1
06:05:02 <ivanm> pejo, oklopol: but anyway, yes I was originally aiming more towards UK-based unis
06:05:59 <oklopol> i wouldn't know much about those
06:06:10 <oklopol> we use java here in finland :<
06:06:22 <ivanm> _everywhere_?
06:06:29 <oklopol> even many lecturers are pissed about it
06:06:33 <oklopol> no, don't think so
06:06:39 <ivanm> why?
06:06:41 <mib_wb8p29> vincenz: Thanks!  Is there any documentation explaining the rational behind such design?
06:06:43 <oklopol> just assumed a town name would be too cryptic
06:06:54 <oklopol> ivanm: well, it's not a very academic language.
06:07:12 <vincenz> mib_wb8p29: Rationale?
06:07:15 <ivanm> oklopol: I meant why do they have to use it, even if the lecturers don't like it?
06:07:23 <vincenz> mib_wb8p29: They are different types, fromIntegral converts from one integral type to another
06:07:27 <paolino> @let split cond xs = let (a,b) = break cond xs in if null xs then [] else a:split (drop 1 b)
06:07:27 <lambdabot> <local>:1:71:     Ambiguous occurrence `split'     It could refer to either `...
06:07:28 <mib_wb8p29> Sorry, rationale, yes.
06:07:48 <paolino>  @let splat cond xs = let (a,b) = break cond xs in if null xs then [] else a:splat (drop 1 b)
06:07:52 <paczesiowa> mib_wb8p29: we don't like hidden type converting
06:07:53 <oklopol> ivanm: i think it has to do with the fact java is very popular when applying for a *job*... which is of course a bit stupid
06:08:06 <vincenz> mib_wb8p29: I meant, what do you mean by rationale.
06:08:06 <paolino> @let splat cond xs = let (a,b) = break cond xs in if null xs then [] else a:splat (drop 1 b)
06:08:06 <lambdabot> Couldn't match expected type `[a]'
06:08:20 <ivanm> ahhh, circular reasoning! java is popular because everyone only knows java! ;-)
06:08:23 <paczesiowa> mib_wb8p29: wo don't want to test (1::Int) for equality with (1::Word64)
06:08:24 <oklopol> yes.
06:08:32 <paczesiowa> *we
06:09:06 <oklopol> ivanm: that's the circular reasoning that makes our world revolve around backwards-compatibility
06:09:14 <ivanm> true
06:09:25 <paolino> @let splat cond xs = let (a,b) = break cond xs in if null xs then [] else a:splat cond (drop 1 b)
06:09:26 <lambdabot> Defined.
06:09:34 <mib_wb8p29> By rationale, I mean, I think I understand the design motivation behind the 'numerical towers' of other languages, such as Lisp, but it's not clear to me why arithmetic in Haskell is designed the way it is.
06:09:46 <vincenz> mib_wb8p29: Different types for different needs
06:09:50 <paolino> > splat (==',') "mio,tuo,suo"
06:09:51 <lambdabot>  ["mio","tuo","suo"]
06:09:51 <ziman> mib_wb8p29, haskell is quite strongly typed and there are no implicit conversions between integral types (as they are in C between short <-> long, for example)
06:10:01 <oklopol> in my opinion, the human race should abandon everything created sofar every 20 years, and start over
06:10:14 <ivanm> oklopol: OK, there goes the wheel...
06:10:18 <oklopol> :)
06:10:23 <oklopol> well perhaps not everything.
06:10:37 <paolino> books included ?
06:10:40 <oklopol> hm
06:10:47 <vincenz> Will we be allowed computers in reinventing?
06:10:51 <oklopol> hard to say, hard to say..
06:11:28 <ivanm> oklopol: OK, you've twenty years to work out what we get to keep before we dump everything starting from <looks at watch>... now!
06:11:31 <oklopol> if i was wise enough to answer all this, i would start the revolution, and we would have the first do-over in 2010.
06:11:34 <oklopol> but i don't
06:11:37 <oklopol> *am not
06:11:46 <oklopol> omg!
06:11:52 * oklopol gets on it!
06:13:36 <oklopol> the problem is, if what is kept is decided on popular vote, it would be the opposite of retrying to come up with a better world, as most revolutionary things aren't that well known
06:14:25 <oklopol> okay, okay, i'll stop already ;)
06:14:27 <mib_wb8p29> vincenz, ziman:  Thanks!  I suppose I'll just have to go on using the stuff!
06:14:32 <oklopol> gotta eat something anyway
06:16:45 <oklopol> (base 10 numbers would not survive, i think they've corrupted our minds long enough)
06:16:49 <oklopol> (->)
06:16:55 <ivanm> wtf? how?
06:17:19 <ivanm> they're the most "natural" way of counting for people with a total of 10 digits on their primary manipulators
06:17:27 <ivanm> s/people/a species/
06:18:07 <paolino> hens will vote for base 3
06:18:31 <paolino> cows are ok with computers
06:18:47 <ivanm> paolino: heh
06:19:06 <paolino> horses they go higher order and count base 4
06:20:11 <vincenz> We all know that the only animamls that program are lolcats, in lolcode
06:21:21 <ivanm> vincenz: true
06:21:47 * paolino hopes someone kept the threadId for this one
06:22:39 <ivanm> paolino: oh, I thought _you_ had it!
06:22:50 <shepheb> cats have 5 digits per foot too, so I think we're stuck with base 10.
06:23:24 <matthew_-> they have an extra tail too
06:23:55 <paolino> ivanm, I left it in the writerT monoid , sorry
06:24:23 <ivanm> anyway.... back to my (restated) original question.... which unis in the UK have people working on haskell?
06:24:28 <ivanm> or with haskell
06:24:43 <ivanm> preferably something to do with maths, even more preferably in the field of combinatorics
06:24:52 <ivanm> because I've been blindly searching and struck a blank :(
06:25:57 <EvilTerran> york and oxford spring to mind as using haskell within their CS depts
06:26:25 <ivanm> yes, checked them... york didn't have much info, and oxford didn't seem to have many people doing maths-y stuff with haskell :s
06:26:39 * ivanm wonders if he should ask sigfpe ;-)
06:27:04 <oklopol> 10 is such a large base people can actually learn to calculate in it, without understanding even the concept of carrying. 10 is such a large base you cannot *visualize* a right / left shift, unlike say with 2... 10 is not a prime base, that's just ugly, it has two random factors... no one uses their fingers to calculate, and if they did, i recommend *binary*
06:27:05 <EvilTerran> yeah, most of the use of haskell here is "programming languages and tools"-style theoretical stuff
06:27:19 <oklopol> but i've had this conversation so many times, please don't egg me on :D
06:27:55 * EvilTerran doesn't quite see the attraction of a prime base
06:28:02 <EvilTerran> base 12 FTW!
06:28:16 <ivanm> base i ftw!
06:28:26 <Spark> base whatever-the-fuck-everyone-else-is-using
06:28:28 * ivanm thinks we should do all our operations mod 1 :p
06:29:10 <oklopol> EvilTerran: prime base was the weakest of these points
06:29:17 <EvilTerran> k
06:29:22 <oklopol> it's more of a visual defect for me
06:29:24 <oklopol> well
06:29:30 <oklopol> not visual, but i mean, .
06:29:39 <asmanian> oklopol: whats the problem of a base being not prime?
06:29:50 <oklopol> as i said, no problem
06:29:55 <oklopol> the others were the problems.
06:30:04 <asmanian> hmkay
06:30:05 <oklopol> this is just something that makes 10 seem arbitrary
06:30:48 <ivanm> EvilTerran: but yes, I want to _use_ haskell, not work out how to improve the language
06:30:49 <asmanian> right, 10 is per se ugly but no need to explain its simply there for historical reasons
06:30:51 <ivanm> or reason about it
06:30:59 <osfameron> why would you want to left-shift/right-shift in real life?
06:31:35 <oklopol> osfameron: comparison
06:31:46 <oklopol> you wanna know how much bigger a number is than another
06:31:53 <asmanian> multipling / dividing by 10?
06:31:59 <oklopol> you look at lenght, and with base 2 you can take a mental logarithm
06:32:07 <osfameron> asmanian: which is so difficult in the current system?
06:32:23 <asmanian> no buts that what a shift in base 10 actually does
06:32:33 <asmanian> so its the reason why I would do it
06:32:34 <osfameron> ah ok
06:32:51 <osfameron> but there's no advantage to a prime base then, as it seems to work fine in base 10 too?
06:33:12 <oklopol> osfameron: *small base* is the point.
06:33:24 <oklopol> not prime base
06:33:34 <asmanian> but for real life a too small base is unpractical
06:33:42 <oklopol> welll
06:33:43 <asmanian> because you have lots of carry-overhead
06:33:46 <shepheb> 16 then.
06:33:48 <oklopol> that's where base 16 comes along
06:33:51 <shepheb> handily a power of
06:33:51 <asmanian> when adding or something
06:33:52 <shepheb> 2
06:33:54 <oklopol> you can do both 2 and 16, trivially
06:34:21 <oklopol> this is so awesome i don't understand why anyone would teach any other base to anyone :D
06:34:28 <asmanian> no need to say base 10 was "invented" long before machines based on binary where largely used ;)
06:34:29 <oklopol> anyway, i'll remove myself from this conversation *now*
06:35:06 <jtraub> I am trying to understand difference between type and datatype. And i can not get it
06:35:31 <paolino> there is the killthread action !
06:36:12 <jtraub> also i have problems with understanding of difference between data constructor and type constructors
06:36:29 <jtraub> Can anybody point me in right direction?
06:37:51 <gour> what is the status of shim, i.e. does it work with 6.8.x?
06:38:27 <ivanm> gour: IIRC, it's dead
06:38:29 <mux_> jtraub: data is to create user-defined datatypes whereas with type, you just define a syntactic alias
06:38:32 <mux_> does that help some ?
06:38:37 <quicksilver> jtraub: type is just for making a shorthand renaming
06:38:42 <gour> ivanm: really? :-(
06:38:42 <quicksilver> jtraub: but gives no type safety
06:38:49 <quicksilver> jtraub: data actaully creates new types
06:38:49 <mauke> jtraub: data constructors construct values; type constructors construct types
06:38:56 <paolino> jtraub: datatype has data constructors so you can use them to pass real datas between funcions
06:39:57 <jtraub> Ok. types are used to create sinonyms
06:40:27 <paolino> you can use them in function signatures
06:40:47 <jtraub> i can use both datatypes and types in signatures. right?
06:41:07 <paolino> yes
06:42:19 <jtraub> I found http://www.haskell.org/haskellwiki/Type to be helpful
06:42:20 <lambdabot> Title: Type - HaskellWiki
06:42:41 <quicksilver> yes, but a type synonym created by the 'type' keyword isn't binding
06:42:50 <quicksilver> so if you do "type Name = String"
06:42:57 <quicksilver> then define f :: Name -> Int
06:43:03 <quicksilver> you'd be able to pass Strings as well as Names to f
06:43:10 <quicksilver> it's just for convenience / clarity / documentation
06:43:22 <quicksilver> it doesn't increase actual safety
06:43:42 <jtraub> Hm. Pascal does in the same situation
07:12:31 * byorgey tosses lambda-crepes with nutella
07:31:46 <hpaste>  roderyk pasted "struggling with separating the IO from the logic; help?" at http://hpaste.org/6992
07:33:09 <vincenz> roderyk: you need a return
07:33:27 <roderyk> vincenz: at the end of files ?
07:33:35 <vincenz> no
07:33:39 <vincenz> at the end of that function it's complaining about
07:33:53 <vincenz> return $ map (\x -> (c, [x])) $ cleanupDir f
07:36:38 <roderyk> vincenz: return not applied to enough arguments
07:37:11 <hpaste>  vincenz annotated "struggling with separating the IO from the logic; help?" with "(no title)" at http://hpaste.org/6992#a1
07:37:19 <twanvl> files is an IO function, because you use getDirectoryContents
07:37:50 <twanvl> you could do that in the main function, and then pass the contents to files instead
07:45:25 <roderyk> twanvl: sorry, but I still don't follow how exactly to move the map into the main function; at some point the IO() needs to be converted into Strings in order to work with it further and I'm apparently missing that step
07:48:51 <quicksilver> roderyk: twanvl is suggesting moving the getDirectoryContents into the main function
07:48:53 <Botje> I'm trying out parsec 3 with bytestrings, but my parser typechecks as ParsecT String u Identity a
07:48:57 <quicksilver> roderyk: if I understand him right.
07:49:09 <Botje> is that because I'm using normal Strings in some matches?
07:49:13 <quicksilver> roderyk: then all your IO is in the main function and the other one can be pure
07:49:31 <sfultong> @bot
07:49:31 <lambdabot> :)
07:49:40 <sfultong> > nub [1,2,2,3]
07:49:43 <lambdabot>  [1,2,3]
07:49:53 <sfultong> > nub . repeat $ 1
07:49:58 <lambdabot> Terminated
07:50:45 <Botje> ah
07:50:46 <byorgey> note if you type  nub . repeat $ 1  into ghci it will print  '[1' before hanging
07:50:50 <Botje> I think I may have found it
07:51:03 <byorgey> Botje: glad we could help =)
07:51:22 <sfultong> byorgey: I noticed that, and that's why I tried it here :-P
07:51:28 <null_pointer> SOS http://mibbit.com/pb/DDZJpO , I see some issue with XML-RPC on Windows
07:51:29 <lambdabot> Title: Mibbit: PasteBin
07:52:00 <sfultong> lambdabot, you are just too resilient
07:52:14 <Botje> hahaa
07:52:19 * Botje triumphs
07:52:24 <vincenz> byorgey: actually
07:52:34 <vincenz> > take 3 . show . nub . repeat $ 1
07:52:37 <Botje> using LanguageDef forces a language to only work for Strings
07:52:40 <lambdabot> Terminated
07:52:46 <vincenz> > take 2 . show . nub . repeat $ 1
07:52:46 <lambdabot>  "[1"
07:52:50 <vincenz> ;)
07:52:52 <Botje> switching it to GenLanguageDef B.ByteString ... made it work
07:52:53 <sfultong> woah
07:52:55 <vincenz> lambdabot does an implicit show
07:52:55 <Botje> \o/
07:53:04 <vincenz> and usually takes enough and not too much so we don't ge spammed
07:53:06 <vincenz> hence the ...
07:53:17 <vincenz> obviouly, it doesn't have enough to fill that line buffer
07:53:47 <vincenz> > var . repeat $ "a"
07:53:48 <null_pointer> SOS http://mibbit.com/pb/DDZJpO , I see some issue with XML-RPC on Windows
07:53:48 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
07:53:48 <lambdabot> Title: Mibbit: PasteBin
07:53:55 <vincenz> > var . repeat $ 'a''
07:53:55 <lambdabot>  Improperly terminated character constant at "'" (column 19)
07:53:59 <vincenz> > var . repeat $ 'a'
07:54:00 <lambdabot>  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
07:54:15 <vincenz> > var . ('. repeat $ 'a'
07:54:15 <lambdabot> Unbalanced parentheses
07:54:20 <vincenz> > var . ('\BS':) . repeat $ 'a'
07:54:22 <lambdabot>  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
07:54:39 <byorgey> Botje: nice =)
07:55:26 <byorgey> null_pointer: are you a bot or a real person?  In either case, is this about Haskell?
07:55:42 <null_pointer> real person
07:55:49 <Botje> heh.
07:55:52 <byorgey> ok, good to know =)
07:55:58 <Botje> that would be a silly way of failing the turing test
07:55:59 <null_pointer> yes , i can figure the thing
07:56:04 <sfultong> have we had any bots in here that have discussed haskell?
07:56:07 <null_pointer> can't i mean
07:56:10 <Botje> "are you a real person?" "no" "YOU FAIL!"
07:56:18 <byorgey> Botje: hehehe
07:56:34 <byorgey> Botje: I just figure most bots wouldn't be programmed to respond to such a direct question =)
07:57:22 <byorgey> null_pointer: ok, sorry about that, you repeated yourself verbatim twice, so I thought...
07:58:02 <null_pointer> can somebody help me or should I through my computer out of the Windows :-)
07:58:24 <sfultong> well, you could throw windows out of your computer
07:58:31 <sfultong> that might help, if applicable
07:59:02 <byorgey> null_pointer: looks like it has something to do with a spurious character getting added when you paste, or something like that
07:59:07 <null_pointer> if you confirm my worries work well on alternatives
07:59:22 <null_pointer> no
07:59:39 <null_pointer> I need to press ^Z to signidy EOF
07:59:45 <byorgey> line 12 col 14  corresponds to the ^Z
07:59:49 <null_pointer> signify
08:00:06 <null_pointer> with pressing this nothing heppens ?
08:00:23 <null_pointer> is that becase Haskell is lazy ?
08:00:30 <byorgey> null_pointer: what happens if you paste it, then hit 'return' and then ^Z on a new line?
08:00:42 <null_pointer> same thing
08:00:53 <null_pointer> lexical error :-(
08:02:12 <byorgey> grr
08:02:17 <byorgey> @slap Windows
08:02:18 * lambdabot smashes a lamp on Windows' head
08:02:30 <byorgey> null_pointer: ok, now does it work?
08:02:45 <null_pointer> byorgey: no
08:03:00 <byorgey> hm, I thought the intimidation tactics would help for sure ;)
08:03:48 <null_pointer> byorgey: you mean I should try ^[other characters] ?
08:04:36 <byorgey> I don't know
08:07:26 <hpaste>  (anonymous) annotated "struggling with separating the IO from the logic; help?" with "(no title)" at http://hpaste.org/6992#a2
08:08:03 <roderyk> tried to move all the IO () into main, but still struggling with getting it to map over all categories...
08:09:06 <Botje> roderyk: have you looked at mapM or mapM) ?
08:09:10 <Botje> *mapM_
08:10:20 <schme> Is this a good spot to ask an emacs haskell-mode related question?
08:10:28 <Botje> you could merge cleanupDir and getDirectoryContents as follows: files c = cleanupDir `liftM` getDirectoryContents ...
08:10:31 <quicksilver> roderyk: I'm not sure if you're asking (a) how to do it or (b) how to separate IO
08:10:50 <quicksilver> roderyk: you can't expect to separate the IO from a loop which uses IO at every stage.
08:11:00 <quicksilver> if it's calling getDirectoryContents on every iteration
08:11:07 <quicksilver> then it's intrinscially an IO loop
08:11:28 <roderyk> quicksilver: don't really need to separate, just want it all to typecheck and compile :)
08:11:46 <roderyk> Botje: will look into that, thanks
08:12:08 <Botje> why are you doing cats !! 1?
08:12:26 <roderyk> I was trying to get a simpler example working
08:12:36 <Botje> ah
08:13:26 <paolino> :t fmap
08:13:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:14:06 <quicksilver> roderyk: forM_ cats $ \cat -> ...
08:14:12 <quicksilver> would be a typical way then.
08:14:24 <mbenson> @src foldr
08:14:24 <lambdabot> foldr f z []     = z
08:14:24 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:14:45 <paolino> @id Functor
08:14:45 <lambdabot>  Functor
08:14:48 <gnuvince> @src liftM
08:14:48 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
08:14:55 <hpaste>  Botje annotated "struggling with separating the IO from the logic; help?" with "mapM_ (untested)" at http://hpaste.org/6992#a3
08:15:06 <paolino> @src Functor
08:15:07 <lambdabot> class  Functor f  where
08:15:07 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
08:15:22 <hpaste>  quicksilver annotated "struggling with separating the IO from the logic; help?" with "like this?" at http://hpaste.org/6992#a4
08:15:35 <paolino> is Functor derivable ?
08:15:45 <quicksilver> roderyk: annotated a possible version
08:15:58 <quicksilver> paolino: only for newtypes (for which everything is derivable)
08:16:12 <paolino> not for data , ah ok
08:16:37 <quicksilver> Data.Derive can probably do it
08:16:42 <quicksilver> I imagine DrIFT can
08:16:54 <quicksilver> I suppose they'd just fmap every positive occurance of a
08:17:10 <paolino> data Match a = Targets a | Depends a, this is the data
08:17:15 <quicksilver> yes, Data.Derive can do it.
08:17:47 <int80_h> hi guys
08:18:13 <int80_h> I need to redirect output of ghci, -o (from the man page) doesn't work. Any ideas on how to get ghci to do this?
08:18:29 <paolino> @hoogle Data.Derive
08:18:32 <int80_h> specifically, I want to redirect the output of :browse
08:18:35 <lambdabot> No matches, try a more general search
08:19:56 <quicksilver> int80_h: I would just use standard redirection abilities of your OS
08:20:20 <quicksilver> ghci -e ':browse Data.Map' > mapoutput
08:20:30 <quicksilver> in a bourne-style shell
08:20:35 <quicksilver> paolino: it's a program.
08:20:37 <quicksilver> @where Data.Derive
08:20:38 <lambdabot> I know nothing about data.derive.
08:20:43 <quicksilver> @where Derive
08:20:43 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
08:20:46 <quicksilver> that one
08:20:49 <int80_h> oh thanks quicksilver
08:20:54 <paolino> a preprocessor ?
08:21:31 <quicksilver> paolino: well, it's a metaprogram.
08:21:40 <quicksilver> (obviously, if it's deriving instances)
08:22:22 <quicksilver> the most natural thing to do is use its TH mode, probably.
08:22:37 <mbenson> > foldr (+) 6 [1,2,3]
08:22:37 <lambdabot>  12
08:22:51 <roderyk> Botje, quicksilver: thanks :)
08:23:18 <mbenson> > foldr (/) 2 [8,12,24,4]
08:23:19 <lambdabot>  8.0
08:23:20 <lispy> hmmm...someone said my name but the scroll back is long since gone
08:23:41 <lispy> > foldr div 2 [8,12,24,4]
08:23:41 <lambdabot>  8
08:23:54 <mbenson> foldl (/) 2 [4,24,12,8]
08:24:09 <mbenson> > foldl (/) 2 [4,24,12,8]
08:24:10 <lambdabot>  2.1701388888888888e-4
08:25:41 <vincenz> haskell is very lispy
08:26:04 <lispy> vincenz: yeah :)
08:26:31 <mauke> > foldr (/) 2 [8,12,24,4] :: Expr
08:26:32 <lambdabot>  8 / (12 / (24 / (4 / 2)))
08:28:18 <paolino> @hoogle a -> m b -> m a
08:28:19 <lambdabot> Prelude.const :: a -> b -> a
08:28:19 <lambdabot> Prelude.asTypeOf :: a -> a -> a
08:28:19 <lambdabot> Prelude.seq :: a -> b -> b
08:28:59 <vincenz> paolino: what do yo want to do?
08:29:11 <paolino> move the m
08:29:14 <vincenz> :t \a b -> return a
08:29:15 <lambdabot> forall t a (m :: * -> *). (Monad m) => a -> t -> m a
08:29:30 <mauke> :t liftM . const
08:29:31 <lambdabot> forall a1 (m :: * -> *) a. (Monad m) => a -> m a1 -> m a
08:29:31 <vincenz> paolino: do you want the 'm b' action to occur?
08:29:33 <vincenz> two options are:
08:29:35 <vincenz> :t \a b -> return a
08:29:36 <vincenz> or
08:29:36 <lambdabot> forall t a (m :: * -> *). (Monad m) => a -> t -> m a
08:29:40 <vincenz> :t \a b -> b >> return a
08:29:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => b -> m a -> m b
08:30:07 <vincenz> 'move the m' is ill defined
08:30:12 <paolino>  m is only a functor
08:30:27 * quicksilver takes paolino's m and moves it
08:30:35 <quicksilver> I expect you want fmap const then
08:30:52 <quicksilver> \a b -> fmap (const a) b
08:30:57 <vincenz> :t fmap . const
08:30:57 <quicksilver> :t \a b -> fmap (const a) b
08:30:58 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => a1 -> f a -> f a1
08:30:58 <lambdabot> forall a a1 (f :: * -> *). (Functor f) => a -> f a1 -> f a
08:32:46 <paolino> > fmap (const 1) (Just 2)
08:32:47 <lambdabot>  Just 1
08:32:54 <paolino> :)
08:33:26 <vincenz> @pl \a b -> b >> return a
08:33:27 <lambdabot> flip (>>) . return
08:33:46 <vincenz> > (flip (>>) . return) 1 (Just 2)
08:33:47 <lambdabot>  Just 1
08:33:53 <paolino> I have no sane definition of return
08:34:08 <paolino> :t return
08:34:08 <vincenz> > (flip (>>) . return) 1 ['a','b','c'
08:34:08 <lambdabot>  Parse error at end of input
08:34:09 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
08:34:10 <vincenz> > (flip (>>) . return) 1 ['a','b','c']
08:34:11 <lambdabot>  [1,1,1]
08:34:30 <vincenz> flip (>>) . return === fmap . const    ?
08:36:25 <MyCatVerbs> Anyone know offhand if binary convolution is commutative, please?
08:39:29 <byorgey> MyCatVerbs: I know what a convolution is, but what's binary convolution?
08:39:36 <vincenz> My thoughts exactly
08:40:18 <vincenz> > sum [a,b,c]
08:40:18 <lambdabot>  0 + a + b + c
08:40:42 <byorgey> a normal convolution is commutative if the underlying multiplication and addition operations are.
08:43:44 <MyCatVerbs> byorgey: convoluting two matrixes, working on real numbers.
08:44:26 <byorgey> what's 'binary' about that?  just curious =)
08:44:31 <MyCatVerbs> byorgey: well, IEEE floating point, so probably they don't actually *quite* satisfy the properties of a field, but close enough for government work an numerical analysis.
08:44:44 <byorgey> ah
08:44:54 <MyCatVerbs> *and numerical analysis
08:45:41 <MyCatVerbs> byorgey: the fact that the operator takes two operands? I've heard it called that, though I'm not entirely sure why. Perhaps one could generalise the operation to three or more operands? *shrug*
08:45:51 <byorgey> I see, possibly
08:48:51 <MyCatVerbs> byorgey: oooh. It's associative and distributive and has an identity element too (specifically, the Dirac delta) and it's also associative with scalar multiplication too, if you're working on reals or complexes. Nice.
08:49:12 <byorgey> cool. but not commutative?
08:49:29 <MyCatVerbs> byorgey: Yes, it's communative. So foldl (convolute) ... should always return the same result as foldr convolute, I think.
08:49:37 <byorgey> oh, ok.
08:50:54 <MyCatVerbs> Hang on though, commutivity and associativity aren't enough to prove that foldl == foldr, I think.
08:52:28 <quicksilver> yes they are
08:52:33 <byorgey> sure they are.
08:52:36 <quicksilver> associativity means it doesn't matter where the brackets go
08:52:46 <quicksilver> commutativity on top of that means you can reorder things entirely
08:52:54 <MyCatVerbs> Oh, right.
08:52:59 <quicksilver> so it becomes effectively a permutation independent n-ary op
08:53:06 <MyCatVerbs> Sorry, I was thinking of the matrix chain multiplication problem.
08:53:11 <byorgey> and in particular it means you can move 'z' from the beginning (foldl) to the end (foldr)
08:53:19 <quicksilver> commutativity without associativity isn't enough
08:53:28 <quicksilver> commutative but not associative leaves you with a mess :)
08:53:37 <MyCatVerbs> But having the values passed around as (value,multiplications-done) pairs instead.
08:53:59 <MyCatVerbs> Of course, matrix multiplication isn't commutative and that wouldn't be associative. Nevermind.
08:54:04 <byorgey> commutative but not associative means you can prove  foldl f z xs == foldr f z (reverse xs), I think
08:54:33 <byorgey> assuming finite xs
08:56:04 <MyCatVerbs> byorgey: foldl _ _ xs is _|_ for infinite xs anyway.
08:56:16 <byorgey> MyCatVerbs: ah, good point
08:58:43 <vincenz> > foldl const 1 [1..]
08:58:46 <lambdabot> Terminated
08:58:53 <vincenz> > foldl (flip const) 1 [1..]
08:58:55 <lambdabot> Terminated
09:06:03 <paolino> @hoogl (a,b) -> (b,a)
09:06:03 <lambdabot> Maybe you meant: hoogle hoogle+
09:06:15 <paolino> @hoogle (a,b) -> (b,a)
09:06:16 <lambdabot> No matches, try a more general search
09:06:20 <ziman> > foldr const 1 [1..]
09:06:21 <lambdabot>  1
09:06:34 <ziman> > scanl const 1 [1..]
09:06:35 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
09:07:35 <ziman> :t uncurry.flip.curry
09:07:36 <lambdabot> forall a b c. ((a, b) -> c) -> (b, a) -> c
09:07:40 <sclv> @djinn (a,b) -> (b,a)
09:07:41 <lambdabot> f (a, b) = (b, a)
09:07:55 <byorgey> paolino: strangely, that function is nowhere to be found in the standard libraries.  Although I think it has been added to Data.Tuple in the HEAD.
09:07:56 <Jaak> @type (id &&& id) >>> first snd >>> second fst
09:07:57 <lambdabot> forall a b. (a, b) -> (b, a)
09:08:44 <byorgey> @type first snd >>> second fst
09:08:46 <ziman> :t uncurry.flip.curry $ id
09:08:48 <lambdabot> forall a b a1 b1. ((a, b), (a1, b1)) -> (b, a1)
09:08:48 <lambdabot> forall a b. (b, a) -> (a, b)
09:08:50 <Jaak> bah
09:08:52 <Jaak> @type snd &&& fst
09:08:53 <lambdabot> forall a b. (a, b) -> (b, a)
09:09:04 <Jaak> obviously...
09:09:08 <byorgey> hehe
09:09:39 <sclv> @ty uncurry (zipWith (flip (,))) . unzip
09:09:40 <lambdabot> forall a b. [(a, b)] -> [(b, a)]
09:09:49 <AndreWe> How can I draw some vector graphics? I'm using Debian lenny with ghc.
09:10:09 <AndreWe> Unfortunately, there is no gtk2hs package, and I did not manage to compile it myself.
09:11:13 <paolino> I have a funcion [a] -> [[a]] which produces some subsets of [a], then I need to apply to [(a,b)] so to get [[(a,b)]] , but I need it to work only on the a's .Should I go through Map, or I miss something mor easy ?
09:12:17 <sclv> @hoogle on
09:12:17 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
09:12:17 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
09:12:17 <lambdabot> Data.Function :: module
09:12:19 <vincenz> paolino: 'need it to work only on the a's' ?
09:12:44 <byorgey> paolino: if f :: [a] -> [[a]], and xs :: [(a,b)], you want  map (f &&& id)
09:12:59 <vincenz> :t \f -> (f &&& id)
09:13:00 <lambdabot> forall b c. (b -> c) -> b -> (c, b)
09:13:00 <byorgey> er, no you don't, wait...
09:13:11 <vincenz> :t \f -> (f *** id)
09:13:12 <lambdabot> forall b c a. (b -> c) -> (b, a) -> (c, a)
09:13:13 <vincenz> ;)
09:13:36 <Jaak> @type first
09:13:37 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
09:13:38 <vincenz> that won't work thto
09:13:38 <byorgey> but even map (f *** id) isn't right
09:13:42 <vincenz> indeed
09:13:47 <Jaak> @type first :: (b -> c) -> (b, a) -> (c, a)
09:13:47 <sclv> @ty sortBy (compare `on` fst)
09:13:48 <vincenz> you'll get ([a], b)
09:13:48 <lambdabot> forall b c a. (b -> c) -> (b, a) -> (c, a)
09:13:48 <lambdabot> forall a b. (Ord a) => [(a, b)] -> [(a, b)]
09:13:51 <vincenz> sclv: on won't help
09:13:55 <quicksilver> AndreWe: I have used openGL although it's hardly a simple solution ;)
09:14:04 <quicksilver> AndreWe: compiling gtk2hs might be a better bet.
09:14:24 <paolino> vincenz I suppose the best thing is parametrize that function on a selector one
09:14:25 <quicksilver> wxWidgets can do some simple drawing too.
09:14:34 <vincenz> paolino: possibly
09:14:38 <byorgey> paolino: I don't think you can do that.  the problem is that there's nothing in the type of [a] -> [[a]] that guarantees that the output is subsets of the input.
09:14:42 <vincenz> paolino: or
09:14:48 <byorgey> so there's no way to 'carry around' some b's with the a's
09:14:59 <vincenz> map (\(l,b) -> zip l $ repeat b)
09:15:03 <vincenz> that works
09:15:20 <AndreWe> quicksilver: Thank you.
09:15:21 <vincenz> map (\(l,b) -> zip l $ repeat b) . map (f *** id) $ input
09:15:34 <vincenz> @pl \(l,b) -> zip l $ repeat b
09:15:34 <lambdabot> uncurry ((. repeat) . zip)
09:15:37 <vincenz> bah
09:15:54 <vincenz> :t uncurry zip $ second repeat
09:15:54 <lambdabot>     Couldn't match expected type `(b, c)'
09:15:54 <lambdabot>            against inferred type `a -> [a]'
09:15:54 <lambdabot>     In the first argument of `second', namely `repeat'
09:15:59 <vincenz> :t uncurry zip . second repeat
09:16:00 <lambdabot> forall a a1. ([a], a1) -> [(a, a1)]
09:16:09 <byorgey> vincenz: I don't think that's wat paolino wants
09:16:18 <vincenz> map (uncurry zip . second repeat) . map (f *** id) $ input
09:16:19 <sclv> @hoogle groupBy
09:16:19 <lambdabot> Data.List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
09:16:19 <lambdabot> Data.ByteString.groupBy :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
09:16:19 <lambdabot> Data.ByteString.Char8.groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
09:16:20 <vincenz> byorgey: I think it is
09:16:28 <vincenz> byorgey: he should be clearer, however
09:16:30 <sclv> @google clusterBy
09:16:33 <lambdabot> http://blog.moertel.com/articles/2007/09/01/clusterby-a-handy-little-function-for-the-toolbox
09:16:33 <lambdabot> Title: ClusterBy: a handy little function for the toolbox
09:17:22 <vincenz> sclv: that uses Map, so requires Ord
09:17:25 * vincenz likes his better
09:17:35 <byorgey> paolino: for example, if f [1,2,3] = [[1,2], [2,3]], you want to be able to somehow 'apply' f to [(1,'a'),(2,'b'),(3,'c')] and get out [[(1,'a'),(2,'b')], [(2,'b'),(3,'c')]], right?
09:17:46 <vincenz> byorgey: mine does that
09:18:03 <byorgey> vincenz: are you sure?
09:18:08 <vincenz> let's put it to the test
09:18:13 <vincenz> byorgey: please give me an f' that does part one
09:18:39 <byorgey> @let f' xs = [take 2 xs, tail xs]
09:18:39 <lambdabot> Defined.
09:18:50 <vincenz> > let f xs = [take 2 xs, tail xs] in map (uncurry zip . second repeat) . map (f *** id) $ [(1,'a'), (2, 'b'), (3, 'c')]
09:18:51 <lambdabot>   add an instance declaration for (Num [a])
09:19:14 <vincenz> :t map (f *** id)
09:19:15 <lambdabot> forall b c b' (f :: * -> *). (Functor f, SimpleReflect.FromExpr c, Show b) => f (b, b') -> f (c, b')
09:19:19 <paolino> if there is Ord a I can make a Map a b, before
09:19:19 <paolino> well Ord doesn't ensure unicity :-/
09:19:22 <paolino> isn't a constraint for that ?
09:19:27 <byorgey> see, you don't even want to map f
09:19:30 <sclv> @google deriving worker wrapper
09:19:32 <lambdabot> http://blog.unsafeperformio.com/?cat=11
09:19:32 <lambdabot> Title: Functional Thinking  worker-wrapper
09:19:35 <byorgey> it applies to the list as a whole
09:19:43 <vincenz> byorgey: point taken :)
09:19:51 <vincenz> for shame
09:20:04 <vincenz> paolino: why don't you explain what in english you want to do
09:20:10 <vincenz> paolino: instead of giving a specific coding problem
09:20:20 <vincenz> maybe there's simply a better way
09:20:57 <quicksilver> or you can use Data.List.lookup
09:21:01 <quicksilver> which just requires Eq
09:21:07 <quicksilver> but has poor complexity
09:21:08 <byorgey> paolino: I guess I still don't understand what you mean when you say "I only want it to work on the a's".
09:21:20 <byorgey> I don't understand why you can't just apply your function to the [(a,b)] list.
09:21:28 <paolino> byorgey: your example is the right one
09:21:40 <byorgey> > f' [1,2,3]
09:21:41 <lambdabot>  [[1,2],[2,3]]
09:21:44 <byorgey> > f' [(1,'a'),(2,'b'),(3,'c')]
09:21:44 <lambdabot>  [[(1,'a'),(2,'b')],[(2,'b'),(3,'c')]]
09:22:15 <byorgey> is that not what you want?
09:22:30 <paolino> but that will break into f
09:22:39 <byorgey> huh?
09:23:53 <paolino> actually f :: Set a -> [Set a]
09:23:58 <paolino> which can help
09:26:15 <paolino> I will reap a piece of working code tonight and put it on hpaste ,now I'm too tired to focus
09:34:03 <vincenz> paolino: say in english what your program is supposed to do
09:34:10 <vincenz> paolino: instead of golfing on a possibly ill-defined spec
09:38:15 <byorgey> vincenz: it's ok, golfing on ill-defined specs is fun =)
09:38:58 <byorgey> and I'm not sure how expressing things in English makes them more precisely defined ;)
09:39:25 <ddarius> byorgey: Precision isn't the issue.
09:39:41 <vincenz> Ambiguity i
09:39:42 <vincenz> s
10:18:28 <glen_quagmire> what's the difference between |- (deduction)  and ---------- (implication) ?
10:18:46 <glen_quagmire> A |- x:e    given A, we can deduce x has type e
10:19:11 <vincenz> glen_quagmire: typically you have
10:19:20 <vincenz> A |- x:e
10:19:21 <vincenz> -------
10:19:25 <vincenz> A |- something else
10:19:54 <glen_quagmire> when you can deduce x:e from A, then you can deduce something else from A ?
10:19:59 <vincenz> right
10:20:02 <vincenz> e.g.
10:20:17 <vincenz> L, x : T |- e : T2
10:20:19 <vincenz> ------------------------
10:20:25 <vincenz> L |- \x -> e : T -> T2
10:21:49 <ToRA> _ |- _ : _  is a syntactic structure, and ---------- tells you what instances of the syntax you can instantiate/make, based on other ones.
10:21:50 <glen_quagmire> why not: (L,x:T |- e:T2) |- \x -> e : T -> T2
10:21:59 <ToRA> "other ones" includes theorems which you can always write.
10:22:11 <vincenz> glen_quagmire: you're overloading the |- smbol
10:28:23 <byorgey> glen_quagmire: the --------- is just normal logical implication.  |- is a special relation on environments and type judgments.
10:29:21 <vincenz> It's all syntax
10:29:25 <vincenz> the symbols are whatever you define them to be
10:29:32 <vincenz> that's math for you, one syntactic transformation to the next
10:32:02 <glen_quagmire> that pretty much sums it up. and the rest is to see examples and figure out.
10:32:16 <glen_quagmire> i mean get accustomed
10:32:33 <glen_quagmire> alright school time
10:33:55 <lament> that's very intuitionistic
10:41:13 <lament> is it just me or is the cyan in the highlighted example completely unreadable? http://www.cs.york.ac.uk/fp/darcs/hscolour/
10:41:14 <lambdabot> Title: hscolour
10:51:09 <Duddle> not completely unreadable, but not nice either
10:54:04 <byorgey> lament: that's pretty bad.  It is either completely unreadable or close to being unreadble, depending on whether you are using hyperbole.
11:00:12 <sethk> hello, all.  I have a program which has a fairly large data set.  I'm now getting "Prelude.(!!): index too large" after the program runs for a while.  Any ideas?
11:01:14 <byorgey> sethk: you are probably using an index that is too large.
11:01:31 <sethk> byorgey, if you mean larger than the data structure, no
11:01:38 <sethk> I'm not explicitly using an index at all
11:01:58 <byorgey> sethk: seriously though, it's hard to know what to suggest without more information =)
11:02:12 <sethk> the largest explicit index in the program is 2.  There are no cases where the second argument of !! is anything other than 0, 1, or 2
11:02:31 <sethk> It's an implicit use of !!, I imagine
11:02:44 <byorgey> well, could there be any cases where !! 2  is called on an empty list, say?
11:02:50 <byorgey> it could be
11:03:04 <byorgey> I'm not sure off the top of my head what would implicitly use !!
11:03:16 <byorgey> > [] !! 2
11:03:18 <lambdabot>  Exception: Prelude.(!!): index too large
11:03:41 <byorgey> sethk: how big is the program?
11:03:46 <byorgey> can you paste it on hpaste.org?
11:04:21 <sethk> byorgey, sure.  It's 111 lines.  I'm not sure how much use it is without the data, but we can certainly try it.  First let me put in a few trace statements and see which function is failing.
11:04:31 <byorgey> ok.
11:08:02 <sethk> byorgey, found it, and it's me.
11:08:12 <byorgey> hehe, ok =)
11:08:26 <sethk> byorgey, I have an empty string where I wasn't expecting one, so the !! argument really is out of range
11:08:41 <byorgey> right.  this is why !! is a bad idea =)
11:08:56 <ziman> pattern matching! :)
11:09:11 <sethk> byorgey, indeed
11:09:37 <byorgey> down with partial functions!
11:11:49 <esap> Just return Maybe
11:11:50 <CosmicRay> is anyone aware of a Haskell library with algorithms for solving the bin-packing problem?
11:11:56 <vincenz> esap: you Just is a return in Maybe
11:12:01 <vincenz> esap: you mean: Just is a return in Maybe
11:12:25 <esap> vincenz: that was an answer to "down with partial functions" :-)
11:16:45 <vincenz> Maybe 'return's Just
11:19:38 <lament> "Just return Maybe" does sound really weird
11:21:19 <lament> > (Just return) :: Maybe (a -> Maybe a)
11:21:19 <lambdabot>  Add a type signature
11:21:27 <lament> you're joking right?
11:21:43 <esap> lament: The Maybe monad is a way to simulate partial functions in total functional programming
11:22:34 <quicksilver> :t (Just return) :: Maybe (a -> Maybe a)
11:22:35 <lambdabot> forall a. Maybe (a -> Maybe a)
11:22:46 <quicksilver> lament: I think that's a LB parsing bug
11:23:09 <quicksilver> lament: fails to correctly parse the type sig part and pass it onto ghc
11:23:11 <quicksilver> I'm not sure.
11:23:27 <quicksilver> but note that > and :t use different parsers, hence the difference :)
11:24:01 <byorgey> > Just return
11:24:02 <lambdabot>  Add a type signature
11:24:03 <lament> witness the power of haskell - why have one parser when we can have two
11:24:21 <byorgey> > Just (return :: a -> Maybe a)
11:24:21 <lambdabot>  Add a type signature
11:24:27 <lament> :t Just return
11:24:28 <lambdabot> forall a (m :: * -> *). (Monad m) => Maybe (a -> m a)
11:24:47 <lament> > Just
11:24:47 <lambdabot>  Add a type signature
11:24:56 <lament> > Nothing
11:24:59 <lambdabot>  Nothing
11:25:17 <byorgey> > Just (return :: Int -> Maybe Int)
11:25:19 <lambdabot>  Just <Int -> Maybe Int>
11:26:22 <lament> is it the custom show function that breaks?
11:26:35 <esap> > (undefined :: Int -> Int)
11:26:36 <lambdabot>  <Int -> Int>
11:26:53 <lament> > Just :: (Int -> Maybe Int)
11:26:54 <lambdabot>  <Int -> Maybe Int>
11:27:06 <esap> whoa, it printed out the value of 'undefined' :-)
11:27:09 <lament> > Just :: (* -> *)
11:27:09 <lambdabot>  Parse error at "*" (column 10)
11:27:12 <lament> hey! :D
11:27:29 <byorgey> esap: no, it printed the *type* of undefined =)
11:27:44 <lament> > undefined :: Int
11:27:45 <lambdabot>  Undefined
11:27:55 <esap> byorgey: well I asked for the value :-)
11:28:06 <esap> > 10 + 20
11:28:06 <lambdabot>  30
11:28:10 <esap> > undefined
11:28:11 <lambdabot>  Undefined
11:28:16 <byorgey> > read "Undefined" :: Int
11:28:17 <lambdabot>  Exception: Prelude.read: no parse
11:28:39 <esap> :t undefined
11:28:40 <lambdabot> forall a. a
11:30:26 <esap> > let a = a in a
11:30:26 <lambdabot>  Exception: <<loop>>
11:30:31 <nomeata> Hi. Cryptos SHA1 returns a Word160. How can I turn that to a nice string?
11:31:05 <lament> > let (a :: Int -> Int) = a in a
11:31:05 <lambdabot>  Parse error in pattern at "in" (column 27)
11:31:24 <lament> what parse error?
11:31:32 <esap> > let a = a in (a :: Int -> Int)
11:31:33 <lambdabot>  <Int -> Int>
11:31:36 <tromp> nomeata, try show
11:31:55 <lament> "let (a :: Int -> Int) = a in a" works in my ghci
11:32:08 <nomeata> tromp: "Word160 3257622417 2016683529 1116565329 2999299916 199125570"
11:32:32 <esap> lament: requires -fglasgow-exts
11:32:38 <lament> oh
11:34:03 <quicksilver> lament: I don't even know why > needs a parser at all.
11:34:10 <quicksilver> lament: no doubt there is a reason :)
11:35:29 <esap> > let a = a in (a :: Int -> Int) 10
11:35:30 <lambdabot>  Exception: <<loop>>
11:36:05 <esap> :t let a = a in a 10
11:36:05 <lambdabot> forall t. t
11:36:28 <esap> :t let a = a in a 10 20 30 40
11:36:29 <lambdabot> forall t. t
11:37:28 <esap> :t let a = a in a 10 20 (30 40)
11:37:28 <lambdabot>     No instance for (Num (t -> t1))
11:37:28 <lambdabot>       arising from the literal `30' at <interactive>:1:22-26
11:37:28 <lambdabot>     Possible fix: add an instance declaration for (Num (t -> t1))
11:37:58 <esap> :t let a = a in a 10 20 (30, 40)
11:37:59 <lambdabot> forall t. t
11:38:56 <sjanssen> quicksilver: > has a parser to avoid code injection attacks
11:38:59 <esap> once you get to _|_, it seems you can add as many arguments as you wish. What a nice way to store data in a black box :-)
11:39:42 <esap> Just need some way of getting at it :-)
11:39:51 <sjanssen> lament, quicksilver: also, "let (a :: Int -> Int)" isn't Haskell '98
11:39:58 <quicksilver> sjanssen: hmm. Intuitively that doesn't sound necessary. Can't you just embed it syntactically such that it is a syntax error if it isn't an expression?
11:40:03 <Peaker> > unsafePerformIO (return 5)
11:40:04 <lambdabot>   Not in scope: `unsafePerformIO'
11:40:13 <quicksilver> sjanssen: and then trust the type inferrer + restricted import list
11:40:22 <sjanssen> quicksilver: this is rather difficult
11:40:36 <Baughn> quicksilver: The GHC parser wasn't written with security in mind
11:40:38 * Peaker notices capabilities ;)
11:40:54 <sjanssen> quicksilver: remember you have to worry about ';' and unbalanced parens
11:41:25 <Peaker> isn't all that's unsafe in the IO module?
11:41:35 <Baughn> Peaker: Not hardly
11:41:45 <mahogny> the unsafest things are not in there o_O
11:41:45 <Peaker> what else is unsafe?
11:41:54 <Baughn> Foreign, for example
11:42:02 <sjanssen> quicksilver: the previous attack was something like: > (); take _ = "some IRC meta characters here"
11:42:16 <Peaker> Foreign lets you access arbitrary symbol names? In what executable?
11:42:22 <quicksilver> sjanssen: *nods*
11:42:26 <Baughn> Peaker: And unsafeFreeze/Thaw in data.array could conceivably let you corrupt the runtime
11:42:34 <mahogny> you can trash the type system security with some mutable references
11:42:35 <esap> :t let a = a in (a 10 20 30 40, a)
11:42:36 <lambdabot> forall t t1. (t, t1)
11:43:10 <quicksilver> sjanssen: I was thinking "module LBExec where {expr = ($usercode)}"
11:43:21 <Peaker> maybe it would be a good idea to have a secure/safe subset of Haskell (without various memory corruptible libs) as a language
11:43:28 <quicksilver> sjanssen: but I appreciate $usercode could start with ); take_ = ...
11:43:34 <Peaker> (not just for lambdabot)
11:43:34 <esap> whoa, it didn't even specialize the type to a function to allow function application... hmm...
11:43:34 <Baughn> > [1..3] ++ [last [1..]]
11:43:36 <lambdabot> Terminated
11:43:43 <quicksilver> Peaker: it's called Haskell98 :)
11:43:49 <quicksilver> (among other things.)
11:43:55 <Peaker> quicksilver, it does not include Typeable and all that?
11:43:56 <quicksilver> some would argue that the unsafe stuff isn't haskell at all
11:44:06 <sjanssen> Peaker: Typeable is safe
11:44:09 <quicksilver> haskell98 does not include typeable either
11:44:15 <quicksilver> sjanssen: not if you're allowed to write new instances, it isn't
11:44:23 <Peaker> sjanssen, I thought you could instantiate Typeable and destroy type safety if you implement it wrong
11:44:39 <Baughn> quicksilver: It doesn't help that the documentation fails to document /how/ you're supposed to do that
11:44:48 <sjanssen> doesn't Typeable hide the necessary machinery to actually define new instances?
11:44:49 <Peaker> how about lambdabot running Haskell98? :)
11:46:32 <quicksilver> sjanssen: no.
11:46:37 <quicksilver> sjanssen: (maybe it should :)
11:47:01 <Peaker> Typeable sounds like a hack :) (I don't know it very well, though)
11:47:15 <quicksilver> the implementation of Typeable is a hack.
11:47:19 <quicksilver> the specification of it is not.
11:47:34 <Peaker> why does a strong compile-time type system need Typeable?
11:48:13 <Baughn> As an escape hatch. It exists for the same reason goto does.
11:48:31 <sclv_> hey guys: http://reddit.com/r/programming/info/6fvnw/comments/ I figure there's a one-liner that uses traverse, but I'm too lazy to figure it out.
11:48:48 <Peaker> Baughn, I don't find goto very necessary either :)
11:48:56 <Baughn> It means that you *can* write dynamically-typed code at need when the type system fails you, and use that ability to prototype a new system that won't need you to. ;)
11:49:23 <sclv_> you also need it for generics
11:49:26 <Peaker> Baughn, that sounds great, if indeed it means that only haskell/ghc hackers should ever use it
11:49:59 <Baughn> Peaker: I wouldn't go that far, but of course only people who understand it should use it
11:50:23 <Peaker> sclv, why?
11:50:25 <Baughn> Anyway, haskell implementors are allowed to assume a certain level of intelligence on part of the users. That's one reason we strive so hard to avoid success. ;P
11:51:01 <Peaker> Baughn, that doesn't bother me, what bothers me is that Typeable and a few other things mean that Haskell type safety cannot be used to enforce security
11:51:04 <Baughn> sclv_: Generics, as in the C++/Java notion? Doesn't parametric polymorphism deal well enough with that?
11:52:01 <Baughn> Peaker: You're right, and developing a system to safely run untrusted code in haskell should be very interesting
11:52:05 <Baughn> Not to mention /reasonable/
11:52:25 <Baughn> You would have to limit what it can do, yes. No Typeable.
11:52:33 <Peaker> Baughn, I find it ugly that lambdabot needs to use syntax/parsing hackery instead of relying on the type system
11:52:49 <Baughn> Peaker: That's because haskell doesn'T use lisp syntax. Bad haskell.
11:53:12 <Peaker> Baughn, also capabilities would fix it
11:53:19 <Baughn> It does rely on the type system for code safety, but not for ensuring that the code is parsed correctly in the first place
11:53:30 <Peaker> Baughn, if lambdabot runs code with limited capabilities and security enforcement then you don't have to worry
11:53:34 <esap> Peaker: I don't think Typeable causes any problems with checking security. Can you explain?
11:53:42 <Baughn> Peaker: Not really. The parser in LB is there to avoid an attack at an earlier level.
11:53:54 <Heffalump> do you mean untrusted binary or source code?
11:53:56 <Peaker> esap, Typeable and other things let you create type-unsafe programs
11:54:07 <Peaker> Heffalump, untrusted source code
11:54:14 <sclv_> generics as in scrap your boilerplate
11:54:20 <Heffalump> LB works by only running code it compiled itself in a limited module environment, forking a new process and time limiting that
11:54:20 <Baughn> Heffalump: Untrusted binary code
11:54:23 <sclv_> @go "Scrap Your Boilerplate"
11:54:26 <Peaker> Heffalump, I assume binaries are "trusted" which allows me to get both security and optimizations/performance
11:54:27 <lambdabot> http://www.cs.vu.nl/boilerplate/
11:54:27 <lambdabot> Title: Scrap your boilerplate ... in Haskell
11:54:34 <Heffalump> Untrusted binary code is a dead loss without PCC etc.
11:54:37 <lament> hm, so in Ada you can say: type Speed_Range is range 0 .. 1000;
11:54:46 <Baughn> Heffalump: Yes, so let's do that. ;)
11:54:55 <sclv_> oleg proved that a malicious programmer can use typeable to create runtime errors.
11:55:09 <Peaker> Heffalump, I want to replace process/OS-based security with a strong security based on type safety
11:55:16 <sclv_> but if you limit it to auto-deriving, then you're safe.
11:55:17 <Heffalump> sclv_: that's obvious, isn't it?
11:55:20 <Heffalump> right.
11:55:27 <quicksilver> Peaker: Typeable (or specifically, Dynamic) appears to be useful for things like Dynamic Exceptions.
11:55:31 <quicksilver> That's what it was there for.
11:55:33 <gwern> language based security, eh? then you'll want something better than haskell
11:55:41 <quicksilver> you can trivially do an ADT for any finite number of data types
11:55:48 <quicksilver> Typeable just lets you make that open.
11:55:52 <Peaker> quicksilver, I hope that "dynamic exceptions" can be replaced by exception-encompassing types and type inference
11:55:52 <Heffalump> I think the LB approach is a bit of a blunt instrument for more sophisticated applications.
11:56:05 <Peaker> gwern, why?
11:56:08 <quicksilver> I don't use Dynamic in any real code myself
11:56:09 <Baughn> quicksilver: It should be fine if you just require Typeable to be derived and not instanced, wouldn't it?
11:56:28 <gwern> Peaker: look at how many restrictions lambdabot needs to run pure stuff safely
11:56:51 <Peaker> gwern, Yeah, that's what bothers me - I am wondering how many changes would have to take place to make Haskell safe that way
11:56:54 <sclv_> typeable/dynamic is handy for things like type-indexed collections too.
11:57:48 <gwern> Peaker: and that;s without considering how to handle resource issues like unbounded recursion
11:57:57 <Peaker> gwern, Disallowing new Typeable instances, using capabilities for generation of IO monadic values, removing some unsafe stuff (Baughn mentioned unsafeFreeze/Thaw in data.array as another problem)
11:58:34 <Peaker> gwern, resource thrashing is possible in all security models...
11:59:36 <nomeata> @djinn a -> ([a],b)  -> ([a],b)
11:59:36 <lambdabot> f _ (a, b) = (a, b)
12:00:01 <gwern> Peaker: hm? I thought capability systems generally guaranteed that only the specified amount of resource could be used up and no more, unless that's what you mean by resource thrashing
12:00:02 * esap would remove 'undefined' totally. Though that will make programming harder...
12:00:03 <quicksilver> Baughn: yes.
12:00:20 <Twey> > let f = f in f
12:00:21 <lambdabot>  Exception: <<loop>>
12:00:25 <Peaker> gwern, if you represent a resource count with a capability, you can implement quotas with capabilities, but its just a quota
12:00:26 <Twey> Peaker: ^
12:00:29 <quicksilver> what would that acheive, esap?
12:00:49 <gwern> Peaker: but in general I was saying that one of the points of language-based security was to be able to throw out all the runtime checks and even get rid of memory management and allow everything to run in-kernel, in which case non-termination would be a problem
12:00:51 <esap> quicksilver: All functions would be total
12:01:13 <Heffalump> esap: how does that work with laziness?
12:01:38 <Baughn> gwern: So you'd still need to keep track of threads and be able to kill them. That should be doable.
12:01:43 <Peaker> gwern, if allocation is done in the language without using a capability (and even E, I believe does this), then memory resources have to be managed by an underlying runtime/OS
12:02:04 <Heffalump> Baughn: unfortunately a non-GCing Haskell thread is unkillable right now
12:02:05 <quicksilver> esap: that's an interesting point of view. c.f. Turner.
12:02:09 <Heffalump> which is why LB forks
12:02:23 <quicksilver> esap: I note that, however, non-turing-complete languages have not proved as useful in practice.
12:02:41 <Baughn> Heffalump: Because that's easier, yes. There are no deep reasons it couldn't be killed, are there?
12:02:55 <Peaker> gwern, Maybe the language can pass around a capability to allocate memory and runtime implicitly down the stack, and explicitly over MVar's/etc, but I guess its less important
12:02:56 <esap> Heffalump: I'm not sure - if not otherwise, you could use lambda abstractions to delay computation...
12:03:08 <Heffalump> esap: i.e. make Haskell strict?
12:03:27 <Heffalump> Baughn: no, it's just the current implementation of the GHC RTS
12:03:33 <quicksilver> in total languages strict vs lazy has no semantic consequences
12:03:38 <quicksilver> the compiler can choose as it wishes
12:03:45 <Peaker> gwern, if can first get simple language-based access-security working while using simple quotas on memory/runtime, it'd be huge progress
12:03:48 <esap> Heffalump: There would be no notion of strictness (e.g. you couldn't express the strictness equation f(_|_) = _|_ :-)
12:04:01 <Heffalump> quicksilver: you mean in languages that enforce termination statically?
12:04:17 <gwern> Peaker: heh. I suppose so - perfect is the enemy of better, after all
12:04:44 <Peaker> gwern, and we're so far off perfect its a little sad :)
12:04:45 <Heffalump> Baughn: though putting a check inside a tight loop might be bad for performance
12:05:36 <Baughn> Heffalump: So the killer would have to note that it's in a tight loop and alter the code to insert a test. Or just kill the thread outright and do whatever it'd be doing when running the test.
12:05:59 <Heffalump> Baughn: you can't kill Haskell threads externally, that's the problem
12:06:06 <Heffalump> they are very lightweight things
12:06:16 <quicksilver> Heffalump: well yes, a total language does indeed enforce termination statically
12:06:18 <Heffalump> oh, I guess in principle you could tell the scheduler to get rid of them. Hmm.
12:06:24 <quicksilver> Heffalump: that's a consequence of totality
12:06:25 <esap> quicksilver: I guess one big problem is how to type arbitrary interpreters. You would need to have an infinite hierarhcy of languages with increasing expressive power
12:06:29 <Heffalump> quicksilver: oh yeah :-)
12:06:34 <Baughn> The capability could be added. It would be tricky, but it would also allow you to /remove/ any tests for termination signals
12:06:42 <Baughn> Or possibly signals in general
12:07:02 <Baughn> I suppose that would only add a very tiny bit of speed, but if it's free with letting you break tight loops, why not?
12:07:05 <gwern> Peaker: I think the problem is that we don't have any good compromise among all the solutions - if we want a dynamic pimped-out lisp machine style OS, we seem to forfeit the capability security model and language-based security and the other benefits of micro/nanokernels, and those all seem to make difficult to impossible the radical differences allowed by an exokernel, and so on
12:07:50 <gwern> each revolutionary proposal offers great potential over the crap compiled monolithic stuff we have now, but all together they seem to be going in many mutually contradictory directions
12:08:09 <Peaker> gwern, I think the notion of hardware protection, and with it the *kernel concept should go away
12:08:42 <Peaker> gwern, I believe protection should be implemented by the compiler
12:09:19 <gwern> Peaker: but then you need a One True Language, no? all others must go through it or suffer emulation/sandboxing penalties
12:09:39 <Baughn> gwern: No, just a One True ABI
12:09:47 <Peaker> gwern, "One true runtime", perhaps. Another possibility is to simply have multiple "trusted compilers" rather than one.  you'd still disallow the use of C and other unsafe languages
12:10:09 <Baughn> C can be made safe pretty easily
12:10:15 <Heffalump> if you want to be able to load binaries, you still need PCC
12:10:22 <Heffalump> whatever your compiler does
12:10:23 <Baughn> ..in the sense of not corrupting anything /but/ C, anyhow
12:10:29 <gwern> PCC?
12:10:35 <Heffalump> proof-carrying code
12:10:57 <Baughn> Or compile to an intermediate level that's inherently safe, and distribute that
12:10:59 <Peaker> Baughn, that will lose the benefits of the system (capabilities/etc), though
12:11:06 <Baughn> Or just distribute the source
12:11:16 <Peaker> Heffalump, why not re-compile?
12:11:20 <Peaker> Heffalump, (why distribute binaries?)
12:11:29 <mrd> insert verification conditions in the output of the C compiler so that a proof can be generated and checked
12:11:30 <Baughn> Peaker: It would allow you to run legacy code. That /is/ important.
12:11:40 <Peaker> Baughn, legacy is overrated, but yeah :)
12:11:45 <vorner> Peaker: I know a person who broke such kind of protection. It was a competition, where people submited code and the system compiled it and run. Some actions were not allowed, but they disallowed them in compilation. He just generated the code in memory and run it.
12:11:45 <nibro> grr, why does the snapshot dist of ghc pack its own version of pwd??
12:11:51 <mrd> while the C code may not do what you want, you can use PCC to check that it doesn't do anything you consider bad
12:11:51 <gwern> Peaker: it is commercially unacceptable to make distributing binaries infeasible :)
12:11:54 <jsnx> Peaker: lock-in? trade secret?
12:12:03 <Peaker> vorner, how can one "jump" to code in memory?
12:12:07 <nibro> shouldn't a source dist be platform-independent?
12:12:15 <Peaker> jsnx, what?
12:12:20 <jsnx> Peaker: using unsafe operations
12:12:29 <jsnx> Peaker: i was talking about binaries
12:12:31 <Baughn> vorner: If they failed to disallow "run arbitrary data as code", they should have used a different language. ;)
12:12:41 <Peaker> gwern, well, it is possible to distribute mid-layer binaries that are still safe (preoptimizations)
12:12:54 <Peaker> gwern, (ignoring for a moment that I think closed source has no place :-)
12:12:56 <vorner> Peaker: well, in the restricted environment you speak of probably not, but then you can modify the binary after compilation
12:12:59 <smtms> Peaker, have you heard of the Singularity OS by Microsoft Research?
12:13:19 <Peaker> vorner, how do you modify arbitrary binaries in memory?
12:13:26 <vorner> Peaker: on disk
12:13:28 <Peaker> smtms, yeah
12:13:34 <vorner> with hex editor
12:13:41 <jsnx> Peaker: what about easing installation for users?
12:13:42 <esap> running arbitrary data as code is sometimes useful - though you need run-time type checking algorithm for it.
12:13:44 <Peaker> vorner, A safe system will not let you modify safe binaries
12:13:48 <vincenz> with PEEK and POKE!
12:13:50 <Baughn> vorner: You'll want to make sure that the code is only compiled to a potentially unsafe (with arbitrary editing) form once it's on the final computer that will run it
12:13:57 <Peaker> vorner, a "trusted binary code" string would be an opaque uneditable object
12:13:57 <jsnx> Peaker: i like that i can ship haskell to people without GHC, fro example
12:14:05 <Baughn> vorner: Then it /doesn't matter/ that it can be made unsafe - you'd only be able to crack yourself
12:14:28 <gwern> (after all, that was the original reason Stallman wanted the GNU system to be interpreted - harder to close the source if you must distribute and run as source)
12:14:39 <Peaker> jsnx, In the current world - just use the current systems. I am proposing something radical - in hopes of replacing the current world. In the radical system, everyone will have the runtime already installed
12:14:51 <jsnx> Peaker: i agree with that long term
12:15:02 <vorner> Peaker: then you have the problem that only trusted people are allowed to make code
12:15:23 <Peaker> vorner, no, anyone can ask the compiler to make trusted binary code
12:15:28 <Peaker> vorner, the "trusted compiler"
12:15:41 <jsnx> Peaker: reflections on trusting trust...
12:15:42 <vorner> Peaker: how does the compiler sign the code as trusted?
12:15:43 <Baughn> vorner: The trusted compiler would be /your/ compiler, running on /your/ machine
12:16:02 <Peaker> vorner, it does not need to sign it, just generate an opaque ADT whose opaqueness is enforced by the type system
12:16:07 <jsnx> but you got the compiler that compiled that compile from somewhere
12:16:21 <Baughn> jsnx: Well, you can't have everythign
12:16:21 <Peaker> jsnx, you start from a system image
12:16:33 * vorner still does not get it. Is the compiler on the syntem, where it will run?
12:16:41 <Peaker> vorner, yeah
12:16:48 <Baughn> vorner: The compiler runs on the same machine that the code will run on
12:16:53 <Peaker> vorner, note that a simpler way to implement this is with OP
12:17:01 <Peaker> (orthogonal persistency)
12:17:06 <Baughn> vorner: It would be impossible to transfer binary code between systems. Or at least very warning-dialog-box-prone.
12:17:12 <kolmodin> bringert: hia! are you the maintainer of quickcheck2 ?
12:17:14 <Peaker> vorner, no "files" in a "global namespace" that anyone can meddle with
12:17:24 <vorner> ah, ok, I see
12:17:37 <vorner> restrict when it gets in and then let it do what it likes
12:17:51 <esap> it's hard to send opaque black boxes by mail :-)
12:18:11 <Peaker> esap, the opaque ADT can contain a non-opaque "source representation"
12:18:40 <Peaker> esap, it can even hide the fact that there's an opaque optimized binary there, and have the source representation be editable, such that the opaque optimized binary is regenerated automatically as the "source" changes
12:18:50 <vorner> still it seems to me that if there is a bug in the system and you breach it, it gets everything. Now, you breach one level of security
12:18:59 <Peaker> vorner, that is true today too
12:19:08 <Peaker> vorner, a single volunerability in the kernel, for example
12:19:09 <Baughn> vorner: If there's one bug in the kernel, you breach everything
12:19:12 <Peaker> vorner, or in one root process
12:19:27 <Baughn> vorner: This would allow a /smaller/ trust interface, which means it's inherently easier to secure
12:19:47 <Baughn> And type systems can even be amenable to security by /proof/
12:19:49 <Peaker> the smallest trust interface may be something like EROS OS, but I still believe this kind of system is the better way to go
12:20:00 <Peaker> s/EROS OS/Coyotos
12:20:34 <vorner> smaller? The thing checking if it is safe is smaller?
12:20:54 <Baughn> Yes
12:20:54 <Baughn> vorner: Right now, a bug in any kernel driver can allow you to take over the system. With capabilities and type-safety, even the most sever bug would only allow you to control that single device.
12:20:56 <esap> Peaker: I think my definition of opaque is different than yours.
12:21:14 <Baughn> vorner: There are O(n) drivers and O(1) typecheckers/compilers, so.. ;)
12:21:31 <Peaker> esap, I made a mistake there, yeah.  s/contain/associated-with
12:21:39 <vorner> Baughn: well, you usually do not interract directly with diveci drivers
12:21:50 <Baughn> vorner: Granted, on a PC architecture you can probably leverage "control over one device" to "control over full system", but that's fixable too
12:22:24 <vorner> and still, a compiler seems to me like a very huge thing, compared with most drivers
12:22:41 <Baughn> A compiler /is/ a huge thing. It's larger than any single driver.
12:22:51 <Baughn> It simply isn't as large as a complete kernel - not nearly
12:22:53 <vorner> and you communicate with the driver by some kind of character device interface
12:23:09 <Peaker> vorner, any root process OR kernel code can be exploited.. a compiler consists of a lot of code, but probably only a subset of it is required to be correct for the safety to be preserved
12:23:14 <Baughn> Also, there are layers even in the compiler. The absolutely critical-for-security part can be much smaller than the whole thing
12:23:25 <Peaker> Baughn, as a complete kernel + _all_ root processes
12:23:49 <Baughn> vorner: It's not at all inconceivable (or unusual) for there to be driver bugs that are exploitable via that character (pipe) interface
12:24:08 <olsner> hmm, has lambdabot unwiped the forgotten quotes now?
12:24:21 <vorner> still, I have a feeling about a bubble-like security
12:24:32 <Baughn> Heck, it could simply be a buffer overflow, given that they're written in C now
12:24:33 <gwern> @quote stereo
12:24:33 <lambdabot> No quotes match. My pet ferret can type better than you!
12:24:39 <Peaker> vorner, there will always be "single points of failure" in security
12:24:52 <gwern> vorner: formal proofs are 'bubble-like' too
12:24:53 <vorner> I do not say it couldn't work, but it seems odd to me
12:24:56 <Peaker> vorner, the smaller and easier-to-verify they are, the better. A compiler is a better on than a kernel, drivers and a bunch of root processes
12:24:58 <vorner> too radical, probably :D
12:25:13 <olsner> @quote harmful
12:25:14 <lambdabot> No quotes match. Do you think like you type?
12:25:45 <Saizan> Peaker: so you're going to force everything to be compiled with a single compiler and have only language-level interfaces? no binary ones?
12:26:06 <Peaker> Saizan, that's a possibility, yeah.  Perhaps multiple languages/trusted compilers can coexist
12:26:13 <esap> Peaker: If you want to send opaque data from one place to another, you should first encrypt it, and consider the private key as a way to open the black box
12:26:17 <Baughn> Saizan: I see no reason there couldn't be binary-level access
12:26:39 <Baughn> Saizan: It'd just be a much richer interface than we have now. It wouldn't be tuned for C, as everything is now
12:27:02 <Peaker> esap, the opaque data is not necessarily secret. the other side does not know that it is indeed "safe". It knows that whatever it generates from the source is safe, so you'd want to send the source
12:27:09 <Saizan> Baughn: that means i can probably write to that interface bypassing the type-system
12:27:11 <Baughn> So not "Kernel only works with this language here, where old kernels worked with everything", it's "This kernel works with Haskell, where old kernels preferred C"
12:27:17 <vorner> But if it is rich enough, it will be difficult to check it is safe
12:27:34 <Baughn> Saizan: Of course
12:27:41 <Peaker> Saizan, the idea is that interface, if exists, is one that can only be used by the various compilers on the system
12:27:52 <esap> Peaker: It depends on what you want to use the opaque data for
12:27:53 <Baughn> Saizan: The type system isn't meant to protect the computer from its owner. The owner decides which compilers to install.
12:28:08 <Baughn> Saizan: If the owner decides to install something that will allow you to run arbitrary code, well, that's /his/ problem
12:28:25 <Peaker> esap, well, in the case of an opaque binary data representing optimized machine code
12:28:51 <Peaker> esap, but that data may be a hidden implementation detail of the runtime, and never actually exist as something exposed to the user
12:28:55 <esap> Peaker: Well I wouldn't consider binary code opaque :-)
12:29:11 <Peaker> esap, if you don't consider it opaque and you allow editing it - then you lose the safety
12:29:16 <vorner> esap: it depends - opaque to who, or what ;-)
12:29:25 <Peaker> esap, you want to disallow editing that which you allow jumping to
12:30:04 <Baughn> esap: The computer's owner would have the capabilities to allow both editing and jumping. He would take care not to distribute /both/ of them to the same process, except for compilers.
12:30:33 <Peaker> vorner, I think it should be feasible to get a "safe Haskell", for example - a Haskell that dose not have any possibility of memory corruption. Then changing the IO actions to capability-based ones should make it access-safe too
12:30:40 <Peaker> s/dose/does
12:31:54 <Peaker> Baughn, I wouldn't say that "editing" in general is a capability.. Creating binary pieces that are "jumpable to" is a capability, but "editing" capabilities are just capabilities to mutable objects - which are "given" to an object's creator
12:32:07 <Baughn> Peaker: Mm. I was about to say that, actually.
12:32:08 <Peaker> s/given/created by
12:32:19 <Baughn> Peaker: Though I'd take offense to "mutable". ;)
12:32:37 <hmich> something is wrong with the latest Data.Array documentation page
12:32:42 <hmich> http://haskell.org/ghc/docs/latest/html/libraries/array/Data-Array.html
12:32:43 <lambdabot> http://tinyurl.com/2uoebz
12:32:47 <Peaker> Baughn, heh, you still have IORefs/etc
12:32:52 <OceanSpray> :t (\)
12:32:54 <lambdabot> parse error on input `)'
12:33:15 <Baughn> :t (\\)
12:33:16 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
12:33:39 <Baughn> \ is the escape char, so a function /called/ \ is always written \\
12:33:49 <Saizan> hmich: look at http://haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-IArray.html
12:33:49 <lambdabot> http://tinyurl.com/5q8qp6
12:34:13 <desegnis> hmich, yeah, they somehow don't get Haddock to properly list reexports
12:34:18 <Peaker> Baughn, btw: As I said before, the compiler can be an implementation detail, so that you only see "source code", and its compiled by a JIT or implicitly, so you don't actually need a Jumpable type.  If a Jumpable type exists, there's no problem with having a Jumpable->String that lets you change the binary blob, but you lose its Jumpability..
12:34:45 <Baughn> Peaker: The "Jumpable" type would just be a function, of course
12:34:48 <hmich> Saizan: yeah, I use it currently. By the way, it links to GHC.Arr, which is also missing
12:35:02 <Baughn> Or an action
12:35:11 <Peaker> Baughn, So you'd have  machineCode :: (a->b) -> String ?
12:35:30 <Peaker> Baughn, its probably better to just hide the existence of jumpable binary blobs :)
12:35:49 <Baughn> Peaker: I don't think that function is expressable in the haskell type system
12:36:02 <Baughn> You'd have to cheat and have a class that is "instanced" for every possible function type
12:36:32 <Peaker> Baughn, you wouldn't ever want that functionality as a user anyhow
12:36:42 <esap> Peaker: That function is impossible to implement.
12:36:44 <Baughn> Peaker: No, but an implementor would
12:36:57 <Peaker> esap, a compiler may be able to implement it with trickery?
12:37:39 <Baughn> Actually, I suppose (a->b) would do fine
12:38:07 <xif> is there any way to get paid for learning Haskell?
12:38:15 <Baughn> You'd just have to make it (a->b)->Maybe String - it'd return Nothing when the function is of more than one parameter, so you'd get to pass in undefined or something to decurry it
12:38:24 <Baughn> Or add proper partial evaluation. :P
12:38:29 <desegnis> Peaker: There should be functions of the same type and the same behaviour (thus being equal) that compile to different machine code
12:38:36 <Heffalump> xif: find a funded university course?
12:39:06 <Baughn> desegnis: True. Stick it in IO, I guess.
12:39:19 <desegnis> yep
12:39:29 <xif> Heffalump: unlikely, this is the US
12:39:42 <xif> they make us _pay_ for courses here
12:39:43 <esap> Peaker: The problem with that function is that it has to open the abstraction inherent in functions.
12:40:21 <vorner> xif: but you could probably be paid after learning haskell ;-)
12:40:23 <Peaker> esap, yeah, if that function exists its within a compiler/runtime implementation - and it probably doesn't :)
12:40:49 <xif> vorner: really?  I kind of doubt that ;)
12:40:50 <proq> xif: sure there is. find someone stupid enough to hire you for a haskell job
12:41:15 <proq> desperate enough, etc.
12:41:29 <esap> Peaker: What would happen if you use 'machineCode machineCode', would it output (part of) the source code of the compiler?
12:41:30 <vorner> xif: sell software and write it in haskell ;-)
12:41:55 <xif> proq: I would guess it's hard enough to find a job writing Haskell even if you're an expert
12:42:01 <proq> this works with other smart but less-popular languages as well
12:42:05 <Baughn> esap: Sure. Why wouldn't it?
12:42:40 <Peaker> esap, machine code of the compiler, maybe, why not?
12:42:47 <xif> Haskell now is probably where Python was a few years ago.
12:42:53 <proq> xif: not necessarily. you just need to find the right company
12:43:08 <xif> only the lucky 10% of the top-talented 10% might get a job.
12:43:13 <vorner> why not work on your own?
12:44:13 <xif> vorner: I asked about getting paid for leaning Haskell, not for learning _entrepreneurship_ and Haskell ;)
12:44:54 <Peaker> xif, if you sell systems or services based on systems, then the buyers will often not care if they are written with Haskell or BASIC
12:45:23 <xif> Peaker: sure, but that would require the aforementioned entrepreneurship skills...
12:45:26 <esap> Peaker: I bet you could write the "code whose source code cannot be output by 'machineCode'" by using machineCode :-) And then asking its source code would loop....
12:45:59 <Peaker> esap, I think generating machine code from any function will always terminate?
12:46:07 <Peaker> esap, also, why is it a problem if you cause a loop?
12:46:13 <esap> Peaker: unless you add too powerful primitives :-)
12:46:21 <Toxaris> Peaker: consider a looping type checker
12:46:27 <Toxaris> Peaker: or a looping macro expansion system
12:46:33 <Baughn> esap: There is no way you can drag the halting problem into this
12:46:46 <Baughn> The /compiler/, sure. Not the decompiler.
12:46:51 <Peaker> Toxaris, Are there type systems that can practically prove termination?
12:46:52 <Toxaris> but I have no idea what you are really talking about :)
12:47:58 <lispy> Peaker: I think both Agda and Epigram are both total languages (meaning programs in them terminate), but what do you mean by "practically"?
12:48:00 <Peaker> esap, ah, I understand what you mean now - if "machineCode" just fetches already compiled code there's no problem. If it actually compiles - and loops - so what?
12:48:16 <Peaker> lispy, usable to write non-toy programs :)
12:48:38 <Corun_> It's a bit hard to see, but, this was marked by my haskell lecturer: http://obfuscated.co.uk/stuff/tf.jpg It's legendary. (Code not mine)
12:49:05 <lispy> Ah, yeah that's harder to talk about.  But, usually if you used one for real work you'd just restrict the total code to a core where things like IO are not allowed
12:49:37 <lispy> Peaker: I think some people did this for a OS kernel though
12:50:09 <esap> Peaker: Practically, having programs that loop is not a problem. In theory it just means your 'machineCode' can't do what it claims to every function.
12:50:14 <lispy> Corun_: completely illegible on me screen :(
12:50:43 <edwardk> peaker: its easy to prove termination, just write a type system in which you can't do arbitrary recursion. you aren't turing complete, but termination checking is easy. see coq, epigram, etc.
12:50:49 <Corun_> It's the red stuff that's important
12:50:49 <andyjgill> Could someone summarize the state of play of the graphics libraries (not GUI's, graphics) for Haskell, or point me to an uptodate web page? There seems to a be a plethora of choices.
12:51:08 <Peaker> edwardk, not being Turing complete is a little too limiting isn't it?
12:51:11 <lispy> andyjgill: Hey, I saw your blog post, thanks for the improvements to HPC
12:51:21 <Heffalump> Corun_: lol
12:51:42 <andyjgill> Now problem, lispy, I hope it helps you with coverage testing
12:51:45 <Toxaris> Peaker: why? there are various degrees of not turing complete. it all depends on your actual task
12:51:52 <edwardk> peaker: coq is pretty expressive despite being non-turing. there are a number of certifying compilers, etc. written in it.
12:51:58 <Peaker> Toxaris, I want a general-purpose programming language
12:52:08 <chylli`> identify 3843054
12:52:15 <lispy> andyjgill: well, it will certainly make coverage analysis easier for darcs.  Any idea when your changes will appear in ghc?
12:52:32 <Peaker> edwardk, can it express all programs expressable in a Turing Complete language that terminate?
12:52:36 <Heffalump> 6.10 is due out at ICFP time
12:52:44 <andyjgill> I hope they will appear in 6.8.3, because there were no API changes.
12:52:49 <esap> Peaker: not being Turing complete is not necessarily limiting. Turing-completeness is in a sense limiting (it limits what kind of type checking can be done)
12:52:51 <Heffalump> oh, cool
12:52:51 <andyjgill> 6.8.3 = may
12:53:00 <lispy> andyjgill: nice
12:53:01 <edwardk> peaker: well, technically no, because then you have to know they terminate ;)
12:53:44 <xif> are there people here who participate in ICFP?
12:53:55 <andyjgill> Yes.
12:53:57 <lispy> xif: definitely
12:53:58 <edwardk> peaker: keep in mind you can take an arbitrary complicated program and run it an arbitrary number of steps, you just have to tell it a number of steps beyond which you won't run. thats not a PRETTY solution, but it lets you run arbitrary code basically.
12:53:59 <Peaker> esap, edwardk: Well, not being able to implement a Turing Machine or any Turing Complete language interpreter in it seems quite limited and not usable for a general-purpose language. Hell, Game of Life is turing complete :)
12:54:16 <Heffalump> xif: the conference or the programming contest?
12:54:17 <edwardk> peaker: yeah but you don't run the game of life indefinitely. ;)
12:54:24 <Peaker> edwardk, Ah, I see
12:54:30 <gwern> @seen dcoutts
12:54:30 <lambdabot> I saw dcoutts leaving #ghc, #haskell, #gentoo-haskell, #haskell-soc and #haskell-hac4 1d 11h 19m 25s ago, and .
12:54:33 <edwardk> and your physical hardware will crash out before an infinite number of iterations anyways ;)
12:54:33 <xif> Heffalump: programming contest
12:54:37 <edwardk> so is it practically limiting?
12:54:40 <nibro> where can I get a copy of the ghc-6.8.2 package without reinstalling all of ghc?
12:54:49 <edwardk> i'm all out of infinite tape ;)
12:54:49 <Heffalump> xif: I have done, yes, though I've basically stopped due to lack of time
12:55:08 <Heffalump> also I suspect there won't be one this year, given there is no sign of any organisers being announced
12:55:14 <Toxaris> is there information about this years icfp contest available yet? have i missed something?
12:55:14 <mrd> i highly doubt most programs you write lack a proof a termination
12:55:17 <edwardk> that said you often have to contort your thinking to shoehorn some general purpose code into coq, etc.
12:55:17 <andyjgill> likewise. I enjoyed the ones I did.
12:55:17 <nibro> Heffalump: I bet winning it once is good enough eh? ;
12:55:19 <xif> lispy: like, there's a team of people in the channel?  several teams?
12:55:21 <mrd> it just may not be explicitly stated
12:55:35 <Heffalump> nibro: well, we did try a couple of more times, but the only way is down :-)
12:55:36 <xif> Heffalump: (you won the ICFP?!)
12:55:37 <lispy> xif: yes and yes usually
12:55:52 <lispy> xif: iirc, #oasis was started for an icfp team
12:56:03 <xif> lispy: that's awesome!  who participates usually?
12:56:19 <Heffalump> xif: yes, me, Igloo, kosmikus and dcoutts in 2004.
12:56:29 <lispy> I participated once, and I bet many here could say that
12:56:30 <nibro> I bet a lot of haskellers participate regularaly
12:56:32 <xif> Heffalump: wow. that's leet
12:56:33 <esap> Peaker: The problem is with the "standard" assumption that you have infinite memory or infinite time. Just drop those assumptions and lack of Turing completeness doesn't seem that bad.
12:56:52 <Peaker> esap, I see - sounds interesting
12:57:05 <Peaker> esap, Now I need to add some more to my already bloated TOLEARN list :)
12:57:31 <Toxaris> what's the point in using my computer, it's not even turing complete, it has only 4Gig RAM :(
12:57:41 <nibro> does anyone know where I can get a copy of the ghc-6.8.2 package without reinstalling all of ghc?
12:57:41 <Toxaris> (actually, it has only 2 :((()
12:57:44 <vorner> Hm, but you may want to write an infinite program. Lets say a web server - it should not terminate (not if it does not get an external command), right?
12:58:02 <Heffalump> wow, there's a patch in GHC HEAD that claims a 7% geomean performance improvement
12:58:13 <Peaker> vorner, well, you could limit it to run just 100 years :)
12:58:13 <edwardk> vorner: you work with 'codata' then and treat the stream of requests as codata, and do bounded work on each request.
12:58:27 <Toxaris> vorner: I guess the theory people would call that a coprogram
12:58:33 <esap> vorner: You can write infinite loops even in languages that are not turing complete. You don't need Turing completeness to write a non-terminating program.
12:58:59 <Peaker> but you cannot write a non-terminating program in a total language?
12:59:15 <nibro> Heffalump: what's the definiton of geomean?
12:59:17 * vorner wants to see the compilar prooving this...
12:59:24 <nibro> Heffalump: sounds quite awesome anyway :-)
12:59:28 <mrd> you can write a corecursive program
12:59:39 <edwardk> peaker: well, then your main function isn't total now is it? =)
12:59:41 <JoshTriplett> Do any standard Haskell functions exist to do sampling with/without replacement?
12:59:45 <Toxaris> even that depends on the meaning of "total" I guess. functions are total, but not all programs are (must be in every language) functions
12:59:50 <Heffalump> nibro: geometric mean over nofib
13:00:03 <JoshTriplett> Presumably taking an instance of RandomGen.
13:00:36 <nibro> Heffalump: 7% over nofib?? that's an incredible boost, what did they do?
13:00:53 <esap> I think you can write a non-terminating program in a total language, _if_ you assume that the input is infinite.
13:01:00 <Toxaris> for a webserver, you want a total function (Request -> Answer) which is called for every request in an infinite loop, or something like this.
13:01:08 <Heffalump> >> * Revive the static argument transformation  This
13:01:08 <Heffalump> >> patch revives the Static Argument Transformation,
13:01:08 <Heffalump> >> thanks to Max Bolingbroke.  It is enabled with
13:01:22 <Heffalump> that's all I know (apart from the headline results I didn't paste)
13:01:38 <Heffalump> I just happened to be reading the commit messages as I updated my GHC darcs repo
13:01:40 <esap> The thing is, it will terminate _if_ the input is finite
13:01:42 <nibro> right, SPJ said something about Max having supplied a cool patch
13:01:57 <nibro> he just didn't say quite how cool it really was
13:02:01 <Peaker> what does SPJ work on at Microsoft?
13:02:09 <Heffalump> Peaker: anything he wants
13:02:13 <Heffalump> though in practice, GHC
13:02:18 <edwardk> peaker: this little thing called GHC, and anything else he feels like
13:02:28 <Peaker> ah. What does Microsoft get out of it?
13:02:55 <Heffalump> having a (very) good researcher working for them
13:02:57 <Beelsebob> Peaker: top quality research into compiling functional programs
13:02:58 <Heffalump> this is how MSR works
13:03:03 <thoughtpolice> presumably i would say they get SPJ :)
13:03:41 <Peaker> So Microsoft is really only interested in all the Haskell people for F#?
13:03:55 <Toxaris> isn't that how most research institutions work?
13:03:57 <thoughtpolice> for MSR I would assume having some of the best researchers working in their field of choice to be good enough compensation to them
13:04:02 <Heffalump> no, they're interested in them for being good researchers
13:04:17 <Peaker> Heffalump, how does it translate into income for MS?
13:04:23 <lament> is F# basically stillborn?
13:04:23 <Heffalump> it doesn't directly
13:04:25 <edwardk> peaker: not so much, they've been doing GHC for a lot longer than F# has been a thought in Don Syme's head.
13:04:33 <Heffalump> F# is taking off big time
13:04:49 <edwardk> lament: its here, its practical, it even has a kind of monad (workflow)
13:05:05 <thoughtpolice> once visual studio support for F# is first class I expect lots of really good things, but from what I hear it's taking off nicely
13:05:10 <Beelsebob> Peaker: in general, the way it ends up as money is that clever people come up with things that can be patented
13:05:11 <Heffalump> they are throwing quite a bit into making it into a product (and have committed to doing so)
13:05:13 <Peaker> with all the Haskell guys in MS, why would F# lack any Haskell goodie?
13:05:19 <thoughtpolice> and syme has been working on it quite a bit.
13:05:23 <Heffalump> different people, different focus
13:05:34 <Heffalump> F# targets .NET integration first and foremost
13:05:43 <Heffalump> and makes (quite a few) language compromises to get that
13:05:47 <lament> so somebody actually uses F#?
13:05:51 <edwardk> peaker: f# is good at .net interop and is ml-like, which means it shares ml's advantages and limitations w.r.t to haskell.
13:06:01 <Heffalump> lament: yes.
13:06:11 <Peaker> edwardk, Deals with the devil for I/O?
13:06:12 <thoughtpolice> lament: what suggests otherwise? the blogosphere?
13:06:51 <lament> thoughtpolice: the same :)
13:06:53 <edwardk> peaker: that for one, strictness and the value limitation for another. it gets some stuff back from .net in the way of operator overloading, etc. but its type inference suffers a bit, etc.
13:06:59 <edwardk> its a very different point in the design space
13:07:28 <lament> i'm using C# at work and would gladly use F# instead, were it not for all those other developers on the project
13:07:40 <Heffalump> they interop quite well, AIUI
13:07:49 <thoughtpolice> F# is a really good idea I think - it brings a lot of the strengths of FP to .net which I think is a good platform. besides F# the only other real functional language I've seen on .net has been nemerle
13:07:55 <lament> Heffalump: that doesn't mean i can write programs that nobody else can read
13:08:02 <thoughtpolice> but nemerle appears to be kind of dead, and I wasn't looking too hard for alternatives
13:08:32 <Peaker> Deals with the devil for I/O seems like a big step backwards though
13:08:39 <edwardk> i mostly just like that f# can talk to all the same stuff as c# and has parametric polymorphism, not just generics.
13:08:49 <Heffalump> lament: fair point
13:08:56 <Heffalump> Peaker: sure, but .NET integration is a big thing for MS
13:09:16 * Heffalump goes to bed
13:09:21 <Peaker> Heffalump, also I guess for MS its just deals with themselves! :)
13:09:36 <jsnx> lolz
13:09:43 <edwardk> if c# had a way to do 'extension interfaces' so you can go back and retrofit apis as well as its 'extension methods' and a form of parametric polymorphism that didn't require round tripping through reflection, i'd be pretty damn happy with it.
13:09:45 <thoughtpolice> i was thinking of downloading the XNA toolkit and maybe writing a game or something with F#
13:09:56 <thoughtpolice> of course, XNA studio doesn't have support for building with F# code yet
13:10:08 <thoughtpolice> so you basically just have to have all the F# code in a DLL and just call to that
13:10:38 <lament> heh, F# has for loops
13:10:42 <JoshTriplett> @hoogle RandomGen g => g -> Integer -> [a] -> [a]
13:10:42 <lambdabot> No matches, try a more general search
13:10:47 <JoshTriplett> @hoogle RandomGen g => g -> b -> [a] -> [a]
13:10:48 <lambdabot> No matches, try a more general search
13:11:06 <JoshTriplett> @hoogle sample
13:11:06 <lambdabot> Control.Concurrent.SampleVar :: module
13:11:06 <lambdabot> Control.Concurrent.SampleVar.SampleVar :: type SampleVar a
13:11:06 <lambdabot> Control.Concurrent.SampleVar.newEmptySampleVar :: IO (SampleVar a)
13:11:25 <JoshTriplett> @hoogle withoutreplacement
13:11:26 <lambdabot> No matches found
13:11:46 <edwardk> i am amused at the dozen methods you have to implement to make a workflow as opposed to the two you have to implement to make a monad, because of strictness.
13:12:06 <JoshTriplett> @hoogle b -> [a] -> IO [a]
13:12:06 <lambdabot> No matches, try a more general search
13:12:20 <lament> "workflow" somehow sounds even scarier than "monad"
13:12:23 <edwardk> yeah
13:12:33 <Saizan> ?where uniplate
13:12:33 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/uniplate/
13:12:38 <lament> it has that enterprisy ring to it
13:12:40 <edwardk> it is more evocative to the general public about what the idea is though, i have to admit
13:13:25 <edwardk> 'monad' scares people unduly for some reason.
13:13:40 <edwardk> and 'warm-fuzzy-thing' is a little too verbose =)
13:13:56 <edwardk> i'm just waiting for 'coworkflow' =)
13:14:00 <lament> haha
13:14:21 <lament> and workfloids
13:14:42 <Peaker> are comonads in the stdlib? Who uses them?
13:14:58 <edwardk> peaker: i do quite a bit, and no they are not.
13:15:35 <Peaker> edwardk, what do you use them for?
13:15:47 <byorgey> workfloids!  I like it! =D
13:16:03 <lament> what's f# for functor
13:16:14 <lament> something like container?
13:16:24 <byorgey> workfloids are a set of composable worklets, together with an identity task which accomplishes no real work.
13:16:35 <idnar> haha
13:16:47 <edwardk> mostly abusing the cofree comonad of a functor and the reader comonad. i've found some uses for the reader comonad in a hoas-style ssa low level intermediate language representation when trying to use 'safe hoas' in haskell.
13:17:12 <edwardk> the cofree comonad is useful for thinking about generalized 'unfold' operations
13:17:53 <edwardk> i should probably put together a bunch of the ones i use into a 'comonad transformer library' since i also use the reader comonad transformer a bit =)
13:18:47 <Peaker> edwardk, I don't know what hoas/ssa are :)
13:18:52 <Peaker> edwardk, what are you writing there?
13:19:49 <edwardk> as for why they are useful, if you take 'arrows' and break them apart into something simpler for instance, 'arrows' without 'pure/arr', which we'll call 'categories'...
13:19:54 <edwardk> then there are categories in which you can work with the reader comonad, but not the reader monad, because the reader monad requires exponentials but the reader comonad just requires cartesian product
13:20:38 <fanw> question: is there a way to print something inside a do notation while the monads are not IO monad? I'm looking at some haskell code and try to figure out how it works
13:21:04 <byorgey> fanw: well, there's 'trace'
13:21:04 <Peaker> edwardk, not sure what exponentials/cartesian product means in this context
13:21:06 <edwardk> peaker: http://comonad.com/haskell/categories/dist/doc/html/categories/ is where i started going with it, but i shelved the Control.Category stuff until i could figure out a good way to deal with newtypes in them
13:21:09 <byorgey> @type trace
13:21:11 <lambdabot> Not in scope: `trace'
13:21:17 <byorgey> er
13:21:24 <edwardk> peaker: that only works with 6.9 though (ghc-head)
13:21:37 <byorgey> fanw: anyway, you just replace 'expression' with  'trace "Print this" expression'
13:21:55 <byorgey> fanw: and "Print this" will be printed when the expression is evaluated
13:22:26 <fanw> Say i have code like this:solve e' = do
13:22:33 <edwardk> cartesian product means you have something that behaves like (,) in haskell, and exponentials means that you can pass around functions as first class values and apply them. if you know Control.Arrow, 'Arrows' have cartesian products, and 'ArrowApply' has exponentials.
13:22:57 <fanw> solve e=do
13:23:04 <fanw> is<-m
13:23:12 <fanw> neww= f is
13:23:20 <fanw> newW<- f is
13:23:36 <fanw> cross the line "	neww= f is"
13:23:48 <edwardk> peaker: but in general in haskell comonads are generally useful for completely different tasks than monads are =)
13:23:57 <Peaker> edwardk, I think I have a lot of reading to do in order to follow that. I read about the basic things about Arrows/Comonads, but haven't read about cartesian/exponentials.  (,) is just the writer monad isn't it?
13:23:59 <byorgey> fanw: sure, then you could say, for example,  solve e = do { is <- trace "m" m; newW <- trace "f is" (f is) .... and so on
13:24:00 <fanw> can i just add "print this" say after "is<-m"?
13:24:34 <edwardk> peaker: ((,)e) is the writer monad if e is a monoid, because then you get a rule for 'gluing them together'
13:24:55 <byorgey> fanw: does my example make sense?
13:24:56 <Peaker> edwardk, if e is not a monoid, then ((,)e) is not a monad, is it?
13:25:12 <edwardk> on the other hand ((,)e) is the reader comonad, because its "easy to keep 'e' around."
13:25:28 <fanw> byorgey, do i need to import something to get it to work?
13:25:35 <fanw> i have ghc 6.8
13:25:40 <Peaker> edwardk, so ((,)e) is the reader monad if e is not a monoid?  Just like ((->)e) ?
13:25:42 <byorgey> @hoogle trace
13:25:43 <lambdabot> Debug.Trace.trace :: String -> a -> a
13:25:43 <lambdabot> Debug.Trace :: module
13:25:43 <lambdabot> Debug.Trace.traceShow :: Show a => a -> b -> b
13:25:49 <byorgey> fanw: yup, Debug.Trace
13:25:51 <edwardk> extend f (e,x) = (e,f x)
13:25:59 <fanw> i see, let me try
13:26:11 <edwardk> where extend is the 'dual' of bind
13:26:24 <xerox> Supponiamo che gli eventi siano indipendenti. Allora possiamo fissare la misura di probabilit dell'evento e
13:26:26 <xerox> errr
13:26:28 <xerox> > second f (x,y) :: (Expr,Expr)
13:26:28 <lambdabot>  (x,f y)
13:26:48 <edwardk> a comonad has 'extract' or 'coreturn' and 'extend' or 'cobind', extract :: w a -> a, is easy for (,e), its just 'snd'
13:27:02 <byorgey> @babel it en Supponiamo che gli eventi siano indipendenti. Allora possiamo fissare la misura di probabilit dell'evento e
13:27:03 <edwardk> and extend :: (w a -> b) -> w a -> w b    is also easy
13:27:08 <lambdabot>   We suppose that the events are independent. Then we can fix the measure of probabilit of the event and
13:27:22 <xerox> hehe.
13:27:26 <byorgey> =)
13:27:34 <nibro> grr
13:27:39 <xerox> crash course on finite probability spaces
13:27:44 <byorgey> ...I probably could have figured that out if I squinted at it.
13:27:51 <edwardk> duplicate is the dual of join, which is the 'category theoretic' way to define a monad/comonad. and can be derived from or derive cobind/extend or bind/>>= respectively.
13:28:04 <nibro> Wrap_hsc_make.c: undefined reference to '_impure_ptr'
13:28:21 <nibro> could anyone tell me what that means?
13:28:41 <Peaker> edwardk, that part about comonads I (vaguely) understand (it will remain vague until I use them, probably)
13:28:44 <nibro> (for the record I'm trying to install regex-posix on cygwin)
13:29:33 <byorgey> edwardk: this is quite enlightening!  hmm... so is ((->) e) the writer comonad too?
13:30:02 <byorgey> I don't know if that's even meaningful, but... =)
13:30:04 <edwardk> byorgey: well, we refer to (,)e as the 'reader' comonad, because it provides an 'environment' 'e' that you carry around.
13:30:17 <byorgey> ok, right, I can see that
13:30:23 <edwardk> and that you can read from in your comonadic 'action'
13:31:01 <edwardk> and since you 'extend' rather than 'bind' you don't have to have a rule for combining 'two different e's like you do with the writer. you just need to keep the e you have.
13:31:05 <fanw> byorgey: how do i print the value of a variable with trace?
13:31:47 <byorgey> fanw: use traceShow
13:32:12 <fanw> @hoogle traceShow
13:32:13 <lambdabot> Debug.Trace.traceShow :: Show a => a -> b -> b
13:32:18 <byorgey> 'expr' becomes 'traceShow x expr'  to show the value of x
13:32:30 * paolino wonders why there is no pick :: Map a b -> a -> Maybe (b,Map a b) function thus making that operation 2*log n
13:32:36 <edwardk> the analogy i usually use for monads and comonads is that if you like to think of monads as a black box you can return values into and a rule about how to collapse 'boxes of boxes' you can think of a comonad as a wrapper that lets you do extra things to its contents, but which you can throw the wrapper away at any time.
13:33:23 <lament> sounds... way more useful :)
13:33:37 <edwardk> a non-empty list is a comonad, because i can always take its first element since i know its always there and throw away the rest of the information. the identity 'monad' is also the identity comonad, because its easy to throw away the wrapper.
13:34:09 <byorgey> edwardk: ok, so 'coreturn' is like throwing away the wrapper, and 'extend' is like doing something to the value while deciding to keep the wrapper around a bit longer?
13:34:50 <edwardk> exactly
13:35:05 <Saizan> also using information from the wrapper
13:35:07 <byorgey> edwardk: how would you implement 'extend' for the nonempty list comonad?
13:35:11 <byorgey> Saizan: right
13:36:05 <roconnor> tails
13:36:18 <Saizan> fmap f . tails
13:36:38 <nibro> Saizan: does HAppS use regex-posix a lot?
13:36:40 <byorgey> aha, I see
13:36:58 <edwardk> easy enough, i didn't have to write it ;)
13:37:01 <fanw> byorgey++
13:37:08 <byorgey> and is that the only implementation that satisfies the comonad laws?
13:37:26 <Peaker> @type tails
13:37:27 <lambdabot> forall a. [a] -> [[a]]
13:37:31 <mrd> colaws?
13:37:36 <Peaker> @src tails
13:37:36 <lambdabot> tails []         = [[]]
13:37:36 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
13:37:44 <byorgey> cosatisfies the comonad colaws?
13:37:47 <fanw> byorgey: traceShow is not in scope even with DebugTrace imported
13:37:55 <mrd> colaw slaw
13:37:57 <edwardk> it should be
13:38:02 <byorgey> mrd: hahaha
13:38:48 <byorgey> fanw: hm, so it isn't.  strange.
13:39:07 <edwardk> anyways given any functor you can make a 'cofree' comonad.
13:39:12 <Saizan> a similar comonad is the one derived from the list zipper, where you also get the init instead of only the tail in the wrapper
13:39:18 <fanw> is it 6.9 feature?
13:39:21 <byorgey> the output of @hoogle traceShow seems to be from an older version of Debug.Trace
13:39:45 <fanw> it is no longer in hoogle website
13:40:00 <edwardk> data Cofree f a = Cofree a (f (Cofree f a)); instance Functor f => Functor (Cofree f) where fmap f (Cofree a b) = Cofree (f a) (fmap (fmap f) b)
13:40:27 <edwardk> then 'extract' is easy, extract (Cofree a _) = a
13:40:36 <byorgey> right
13:40:54 <edwardk> and 'extend' is done in the spirit of fmap, i leave it as an exercise coz the implementation i have is on a server i don't have access too here at work ;)
13:41:02 * Apocalisp lifts himself into the Coffee comonad
13:41:15 * byorgey tries to implement extend
13:42:04 <edwardk> and you can build up some common functors off of just that even, if you take the 'unit' functor that maps everything to bottom:  data Unit; instance Functor Unit where fmap f _ = undefined
13:42:22 <edwardk> then 'Cofree Unit' is isomorphic to the identity monad.
13:42:32 <edwardk> and the 'free monad' of unit is isomorphic to 'Maybe'
13:43:01 <Saizan> Cofree Identity ~ Stream?
13:43:03 <edwardk> where data Free f a = Roll (f (Free f a)) | Place a
13:43:22 <edwardk> yeah cofree identity is an infinite list
13:43:57 <edwardk> and Free Identity looks like 'Nat' if you quantify over it properly
13:44:17 <lament> is there a sane introduction to all this stuff?
13:44:30 <edwardk> lament: i blogged the free monad stuff a few days ago, one sec.
13:44:35 <byorgey> edwardk: sorry, how do you define Free ?
13:44:47 <edwardk> byorgey: look up about 6 lines ;)
13:44:58 <byorgey> oh, sorry =)
13:44:59 <edwardk> data Free f a = Roll (f (Free f a)) | Return a  is the version i used in the post
13:45:02 <lament> edwardk: i think i saw it. It's way over my head :(
13:45:09 <vincenz> Any good papers out there on how to implement STM?
13:45:18 <edwardk> i admit i probably should have quit before the 'Succ' example =)
13:45:20 <vincenz> edwardk: Free fR-oll?
13:45:44 <edwardk> vincenz: ?
13:45:49 <vincenz> free for all
13:45:56 <edwardk> vincenz: hah
13:46:49 <edwardk> basically i wrote the blog post to build up enough shared terminology that i could explain why hoas is hard, and why the 'safe' version of hoas can't do certain things.
13:47:31 <byorgey> edwardk: is your blog on Planet Haskell? I don't remember seeing your post
13:48:34 <edwardk> byorgey: I put in a request to get added about 3 weeks ago, but i guess i haven't made it into the next batch or whatever
13:48:58 <byorgey> edwardk: yeah, ok, it takes ibid a while sometimes =)
13:49:14 <edwardk> before that i used to have a problem with my rss feed that causes some of my posts to misformat and i wasn't posting much before the last few weeks
13:49:18 <byorgey> edwardk: in the meantime, do you have a link?  I'd be very interested in reading it
13:49:21 <edwardk> shapr started sitting on me to try to get me to post
13:49:26 <byorgey> hehe
13:49:26 <edwardk> http://comonad.com/reader
13:49:29 <lambdabot> Title: The Comonad.Reader
13:49:39 <byorgey> hehe, nice blog name =)
13:49:41 <edwardk> the last 3 posts are all tangentially related to the topic
13:49:50 <edwardk> seemed appropriate to the topic today ;)
13:52:24 <byorgey> edwardk++
13:52:36 * edwardk boings. karma. woot.
13:52:40 <byorgey> Thanks for the explanations!  I've got lots to sort through now =)
13:52:46 <edwardk> heh
13:52:59 <edwardk> feel free to ask questions. i love this stuff, but it seems to bore a lot of folks on here ;)
13:53:02 <glguy> Seems like there hasn't been a lot of karma being passed around lately
13:53:17 <byorgey> edwardk: ok, I'll definitely take you up on that.  doesn't bore me =)
13:53:40 <byorgey> glguy: I've noticed that too.
13:53:44 <edwardk> oh and if you want code i can drum up working examples/use cases of any of this. i should probably post more of it up there
13:53:47 <olsner> glguy++ for noticing :P
13:54:01 <Saizan> edwardk: please do!!
13:54:18 <byorgey> please do, I've already subscribed =)
13:54:55 <edwardk> saizan: i was planning on posting up the cofree comonad before i went on about how the free monad and the fegaras/sheard catamorphism are the same thing. (i tripped over that fact by accident when i was looking at the two types one after the other)
13:55:11 <edwardk> and then what that says about why you can't build general recursion over a 'safe' hoas.
13:55:27 <edwardk> at least that is my current plan
13:56:21 <edwardk> mostly coz i got pissed off when i tried to make a 'fegaras/sheard' / 'boxes go bananas' style hoas representation for a very simple dependently typed lambda calculus and failed utterly because of the typechecking rule for Pi
13:56:40 <edwardk> everything else worked quite nicely
13:56:48 <edwardk> but one line of code there i can't write =)
13:57:03 <cdsmithus> An easy (hopefully) question.  I have an infinite list.  How do I get a list of ordered pairs of stuff from the first list?
13:57:15 <mattam> talk about the power of pi...
13:57:41 <edwardk> mattam: =/
13:57:43 <vincenz> > e^^(0:+1)
13:57:43 <lambdabot>        add an instance declaration for (Integral (Complex t))
13:57:43 <lambdabot>     In the expr...
13:57:50 <vincenz> > exp(0:+1)
13:57:51 <lambdabot>  0.5403023058681398 :+ 0.8414709848078965
13:57:57 <vincenz> > exp(1/(0:+1))
13:57:58 <lambdabot>  0.5403023058681398 :+ (-0.8414709848078965)
13:58:08 <mattam> cdsmithus: how do you order 1:2:1:2:1...?
13:58:29 <cdsmithus> mattam: Hmm?  I don't understand the question.
13:58:53 <edwardk> cdsmithus: so you want [1..] to become [(1,2),(3,4),..] ?
13:58:59 <mattam> cdsmithus: how do you order the infinite list 1:2:1:2:1...?
13:59:01 <vincenz> > ln (-1 :+ 0) / (0 :+ (-1))
13:59:01 <lambdabot>      precedence parsing error
13:59:01 <lambdabot>         cannot mix prefix `-' [infixl 6] and `(...
13:59:01 <cdsmithus> mattam: by ordered-pairs, I mean 2-tuples
13:59:07 <vincenz> > ln ((-1) :+ 0) / (0 :+ (-1))
13:59:07 <lambdabot>   Not in scope: `ln'
13:59:10 <lament> > let foo (a:b:c) = (a,b):foo c in take 10 $ foo [1..]
13:59:11 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20)]
13:59:12 <vincenz> > log ((-1) :+ 0) / (0 :+ (-1))
13:59:12 <lambdabot>  (-3.141592653589793) :+ 0.0
13:59:14 <mattam> oh
13:59:18 <vincenz> > log ((-1) :+ 0) / (0 :+ 1)
13:59:18 <lambdabot>  3.141592653589793 :+ 0.0
13:59:21 <vincenz> that's the power of pi
13:59:22 <cdsmithus> edwardk: I want [(1,1), (1,2), (2,1),(2,2)...]
13:59:34 <lament> cdsmithus: i just pasted one way to do it.
13:59:35 <vincenz> cdsmithus: easy
13:59:48 <vincenz> > [(a,b) | a <- [1..], b <-[1..a]]
13:59:49 <lambdabot>  [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(4,4),(5,1),(5,2),(5,...
14:00:16 <mattam> vincenz: ;)
14:00:27 <cdsmithus> vincenz: okay, that works for half of it anyway.  Thanks.  The rest I can get by inverting those.
14:00:55 <vincenz> oh
14:00:57 <vincenz> you want a cartesian one?
14:00:59 <vincenz> easy peasy
14:01:20 <lament> s/..a/../
14:01:31 <vincenz> > [(a,b) | a <- [2..], b <- [1..], (b, a-b)]
14:01:32 <lambdabot>  Couldn't match expected type `Bool' against inferred type `(t, t)'
14:01:36 <lament> oh, that won't work
14:01:45 <melani9> www.thePHPportal.tk I need help, I can't see my website! SQL error
14:01:50 <vincenz> > [(b,a-b) | a <- [2..], b <- [1..]]
14:01:51 <lambdabot>  [(1,1),(2,0),(3,-1),(4,-2),(5,-3),(6,-4),(7,-5),(8,-6),(9,-7),(10,-8),(11,-9...
14:01:51 --- mode: ChanServ set +o vincenz
14:01:53 --- kick: mattam was kicked by vincenz (vincenz)
14:01:55 --- kick: melani9 was kicked by vincenz (vincenz)
14:02:01 --- mode: vincenz set +b *!*n=ircap8@*.Red-79-145-91.staticIP.rima-tde.net
14:02:02 --- kick: melani9 was kicked by vincenz (vincenz)
14:02:25 * vincenz kicks his TAB-key
14:02:36 * allbery_b suspected as ,uch
14:02:39 <allbery_b> much
14:02:42 <edwardk> > [(b,a-b) | a <- [2..], b <- [1..]]
14:02:42 <lambdabot>  [(1,1),(2,0),(3,-1),(4,-2),(5,-3),(6,-4),(7,-5),(8,-6),(9,-7),(10,-8),(11,-9...
14:02:43 --- mode: vincenz set -o vincenz
14:02:47 <edwardk> er
14:02:50 <edwardk> > [(b,a-b) | a <- [2..], b <- [1..a]]
14:02:51 <lambdabot>  [(1,1),(2,0),(1,2),(2,1),(3,0),(1,3),(2,2),(3,1),(4,0),(1,4),(2,3),(3,2),(4,...
14:03:01 <vincenz> > [(b,a-b) | a <- [2..], b <- [1..a-1]]
14:03:02 <lambdabot>  [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,4),(2,3),(3,2),(4,1),(1,5),(2,4),(3,...
14:03:07 <edwardk> [(b,a-b) | a <- [2..], b <- [1..a-1]]
14:03:11 <lament> heh
14:03:11 <edwardk> yeah
14:03:12 <vincenz> \/
14:03:14 <vincenz> \o/
14:03:21 <lament> disgusting
14:03:26 <edwardk> i had the right one but i pasted the wrong one =)
14:04:02 <cdsmithus1> Not sure why I got disconnected.  Thanks for the help.
14:04:23 <vincenz> > [(b,a-b) | a <- [2..], b <- [1..a-1]] -- cdsmithus there ya ho
14:04:23 <lambdabot>  [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,4),(2,3),(3,2),(4,1),(1,5),(2,4),(3,...
14:04:24 <edwardk>  > [(b,a+1-b) | a <- [1..], b <- [1..a]]
14:04:34 <edwardk> > [(b,a+1-b) | a <- [1..], b <- [1..a]]
14:04:35 <lambdabot>  [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,4),(2,3),(3,2),(4,1),(1,5),(2,4),(3,...
14:04:46 <cdsmithus1> Cool, got it.
14:05:07 <vincenz> Staz: you a spammer?
14:05:12 --- mode: ChanServ set +o vincenz
14:07:27 <vincenz> Anyone familiar with how stm is implemented?
14:08:14 <edwardk> vincenz: http://home.comcast.net/~pjbishop/Dave/GVTL-TL2-Disc06-060711-Camera.pdf is a good paper on the topic
14:08:16 <lambdabot> http://tinyurl.com/5k2rhp
14:08:23 <vincenz> edwardk: gracias senor
14:08:48 <edwardk> at least its my favorite of the algorithms coz its pretty slick
14:08:58 <glguy> vincenz: despite the comic hostname, Staz seems legit by the logs
14:09:12 <edwardk> some of the locking approaches can be faster in practice iirc, but this has the lockfree stuff going for it in terms of at least some thread always making progress
14:09:15 <vincenz> glguy: ok
14:09:22 <s|k_> heh
14:09:35 <vincenz> edwardk: Just wondering what happens when your gc relocates your data
14:10:30 <edwardk> then it keeps you in stock with a forwarding pointer until its updated you, generally no?
14:11:32 <monochrom> Yeah, I have seen Staz said legit, on-topic things here.
14:11:43 --- mode: vincenz set -o vincenz
14:14:10 <vincenz> What about lament? He's like palomer2
14:14:49 <monochrom> Naw, I don't think so, yet.
14:15:14 <sjanssen> @palomer
14:15:14 <lambdabot> That's nuts!
14:15:18 <sjanssen> @palomer
14:15:18 <lambdabot> They're telling you lies!
14:15:30 <monochrom> But I admit you read this channel more often than I do. Perhaps don't trust me.
14:16:12 <sjanssen> vincenz: I haven't seen evidence of that
14:16:16 * edwardk dodges vincenz's itchy ban-hammer.
14:16:25 <vincenz> sjanssen: fair enough
14:16:38 <Trinithis> is being like palomer a good thing? :D
14:16:48 <vincenz> Trinithis: if you like bans,yees.
14:16:51 <edwardk> gotta run
14:17:07 <sjanssen> vincenz wants to follow the Bush doctrine of preemptive strike :)
14:17:25 <sjanssen> we've got to strike to down the "axis of trolls"
14:17:28 <vincenz> sjanssen: Are you at all familiar with the internals of STM?
14:17:39 <sjanssen> vincenz: not the internals, no
14:24:30 <Saul_> The tilde (~) is a laziness operator?
14:24:42 <vincenz> Saul_: in patterns?
14:24:49 <Saul_> like the opposite of the exclamation mark?
14:24:56 <vincenz> Saul_: it is in patterns
14:25:14 <Saul_> Yeah it's a pattern
14:26:12 <Saul_> But that is basically default behaviour except when using exclamation marks in the data type definition right?
14:26:12 <sjanssen> Saul_: I wouldn't call them the opposite
14:26:27 <sjanssen> they're sometimes called irrefutable matches, because they always succeed
14:27:12 <sjanssen> > case [] of ~(_:_) -> "x"; [] -> "y"
14:27:12 <lambdabot>      Warning: Pattern match(es) are overlapped
14:27:12 <lambdabot>              In a case alterna...
14:27:21 <sjanssen> > case [] of ~(_:_) -> "x"
14:27:21 <lambdabot>  "x"
14:27:30 <byorgey> > let x .* xs = map ((:[]) . (,) x) xs ; y *. ys = map ((:[]) . flip (,) y) ys ; (.+) = zipWith (++) ; (x:xs) >*< (y:ys) = [(x,y)] : (x .* ys) .+ (y *. xs) .+ ([] : xs >*< ys) in   concat $ [1..] >*< [1..]
14:27:31 <lambdabot>  [(1,1),(1,2),(2,1),(1,3),(3,1),(2,2),(1,4),(4,1),(2,3),(3,2),(1,5),(5,1),(2,...
14:27:47 <vincenz> byorgey: neerd
14:27:57 <byorgey> it's a convolution! =)
14:28:01 <MyCatVerbs> This reminds me. Is is possible to have strict fields in a datatype that uses record syntax, please?
14:28:03 <byorgey> oops, got the order wrong...
14:28:13 <sjanssen> MyCatVerbs: yes
14:28:20 <byorgey> > let x .* xs = map ((:[]) . (,) x) xs ; y *. ys = map ((:[]) . flip (,) y) ys ; (.+) = zipWith (++) ; (x:xs) >*< (y:ys) = [(x,y)] : (x .* ys) .+ ([] : xs >*< ys) .+ (y *. xs) in   concat $ [1..] >*< [1..]
14:28:21 <lambdabot>  [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,4),(2,3),(3,2),(4,1),(1,5),(2,4),(3,...
14:28:25 <byorgey> there we go
14:28:44 <MyCatVerbs> sjanssen: how, please? Trying the obvious didn't work for me, and looking into the Haskell 98 report didn't clear it up. :/
14:28:45 <Saul_> ok weird stuff
14:28:56 <sjanssen> MyCatVerbs: stick the ! in front of the type, as usual
14:29:06 <byorgey> vincenz: it works for any lists, not just [1..]
14:29:17 <sjanssen> > case [] of (_:_) -> "x"
14:29:18 <lambdabot>   Non-exhaustive patterns in case
14:29:32 <sjanssen> damnit, why do we have warning on in lambdabot?
14:29:58 <vincenz> to help the noobies
14:30:11 <Saizan> a line of warning?
14:30:21 <Saizan> byorgey: convolution as in power series?
14:30:24 <MyCatVerbs> sjanssen: so data Foo = Foo { bar :: !Integer } -- ?
14:30:28 <byorgey> Saizan: yes.
14:30:51 <byorgey> Saizan: I wrote that code by staring at Doug McIlroy's functional pearl, in fact =)
14:31:28 <byorgey> and replacing * by (,) and + by ++, essentially
14:31:44 <monochrom> I love eating noobies. Err noodles.
14:31:45 <sjanssen> MyCatVerbs: correct
14:31:47 <byorgey> with some contortions due to the fact that (,) and ++ are not commutative like * and + are.
14:31:59 <MyCatVerbs> sjanssen: ahhhhh thank you very much. I'd been trying: data Foo = Foo { ! bar :: Integer } -- and tearing my hair out when it (predictably, come to think of it) didn't work. :)
14:33:28 <orzo> hello
14:34:21 <byorgey> cdsmithus1: see my code above for an alternative solution that works for any infinite list, not just ones with elements in Enum.  maybe a bit over the top, but... =)
14:34:23 <Botje> I have data ASTDecl = ASTFunction String ASTNode | ASTVariable String ASTNode. Is there a way to extract all the strings from an [ASTDecl] ? I could use two list comprehensions or a seperate mapping function. Any other options?
14:35:34 <byorgey> Botje: just write  getString :: ASTDecl -> String, then map that over the list?  is that what you mean by "a separate mapping function"?
14:35:44 <Botje> yeah
14:36:02 <Botje> if I need such a thing i'll write it
14:36:03 <byorgey> you could probably do something with some sort of generic system (SYB, Uniplate) but that seems like way overkill here.
14:36:11 <Botje> but it's a bit silly for one check
14:36:16 <byorgey> yup.
14:36:21 <Botje> byorgey: actually, i'm planning on using uniplate for this project
14:36:43 <Botje> so if uniplate can do it easily i'd love to know :)
14:37:12 <pejo> Botje, compilers and similar stuff give remarkable savings in code size with some generic programming
14:37:40 <Botje> pejo: i'm all ears, really
14:37:41 <byorgey> ok.  I don't know whether Uniplate would actually work or not... I know you can pull out all the instances of a certain constructor in a value of some recursive data type, but that's not quite the same thing.
14:37:55 <Botje> I read the uniplate and SYB  papers and decided I liked uniplate better
14:38:31 <Botje> This will be my first major haskell project (an ML compiler) so any tips or tricks are welcome
14:38:47 <Saizan> Botje: i think with uniplate that will become: concatMap universeBi
14:38:54 <pejo> Botje, uniplate has sacrificed something to make it simpler. You can check Supero and yhc for examples on how to use it, if the manual isn't revealing.
14:38:57 <fnoble> does anyone know of a simple intro to generic zippers?
14:39:42 <wtfZut> Hello, I have a propel, which at first seemed trivial, but Ive been thru the docs over and over again, and I simply cant find a good way to parse a string and retrieve a timestamp. It seems all functions which are instances of ParseTime dont want to let me have a good old timestamp.
14:39:49 <wtfZut> problem* :)
14:40:13 <fnoble> i think ive got my head around the Huet zipper, but reading through olegs stuff on the generic formulation its all going over my head
14:40:16 <elliottt> wtfZut: a unix timestamp?
14:40:19 <Botje> fnoble: I rather liked the wikibooks article
14:40:21 <wtfZut> yes
14:40:23 <vincenz> fnoble: http://notvincenz.blogspot.com/2007/07/higher-order-zippers.html
14:40:24 <lambdabot> Title: lambda.oasis: Higher Order Zippers
14:40:35 <Botje> http://en.wikibooks.org/wiki/Haskell/Zippers
14:40:35 <lambdabot> Title: Haskell/Zippers - Wikibooks, collection of open-content textbooks
14:40:45 <elliottt> ah.  you could parse to something like utctime, then turn that into a timestamp, but you're right, there's no way to just do that :)
14:40:49 <Botje> pejo: i'll look at those when I get stuck, thanks!
14:41:46 <Botje> Saizan: actually, I was wondering what the point of "biplate" was
14:41:51 <Botje> the paper wasn't really clear on that
14:43:20 <wtfZut> actually elliottt, I do not see an easy way for that either.
14:43:49 <quicksilver> wtfZut: by 'timestamp' you mean 'seconds since the epoch' ?
14:43:56 <wtfZut> yes indeed.
14:44:04 <wtfZut> as far as Ive seen, the UTCTime gives me days, and then seconds, meaning I have to recalculate it?
14:44:34 <elliottt> :t parseTime defaultTimeLocale "%s" "35"
14:44:36 <lambdabot> Not in scope: `parseTime'
14:44:36 <lambdabot> Not in scope: `defaultTimeLocale'
14:44:40 <quicksilver> wtfZut: utcTimeToPOSIXSeconds :: UTCTime -> POSIXTime
14:44:53 <wtfZut> neat
14:44:56 <wtfZut> hehe :D
14:45:02 <elliottt> utcTimeToPOSIXSeconds `fmap` parseTime defaultTimeLocale "%s" "35"
14:45:15 <quicksilver> then if you just want it as a number, you can use 'round'
14:45:17 <pejo> Botje, are you talking about the HW'07 paper? Have you seen Section 4?
14:45:18 <wtfZut> where did u find that function in the docs tho?
14:45:21 <quicksilver> to convert that to an integer
14:45:23 <wtfZut> under POSIXTime?
14:45:25 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/libraries/time/Data-Time-Clock-POSIX.html
14:45:26 <lambdabot> http://tinyurl.com/25otgv
14:46:24 <wtfZut> I see, thanks a lot!!
14:46:30 <Saizan> nibro: can you read my pm?
14:46:30 <quicksilver> np
14:46:35 <quicksilver> it's all a bit subtle, in a way
14:46:41 <quicksilver> just because haskell tries to be careful
14:46:46 <quicksilver> posix times ignore leap seconds
14:46:50 <quicksilver> that's why it gets fiddly.
14:48:07 <Botje> pejo: yeah, i saw it
14:48:12 <Botje> but didn't understand much of it
14:48:17 <Botje> then again, it was 03:00
14:48:28 <Botje> i'll try to re-read it now :)
14:48:49 <wtfZut> Indeed it is subtle, if u click your way to Data.Time.Clock, you are in a ded end, the posix can only be found if u view the library as a tree, from http://www.haskell.org/ghc/docs/latest/html/libraries/
14:49:49 <quicksilver> wtfZut: yes, that's true too :)
14:50:14 <nibro> Saizan: no, I haven't received any pm from you
14:50:58 <nibro> Saizan: did you see the ones I sent you?
14:51:17 <Saizan> nibro: yes
14:51:51 <Saizan> nibro: anyway, did you try compiling HAppS-Server without regex-compat, too?
14:52:04 <nibro> Saizan: indeed I did
14:52:43 <nibro> Saizan: for some reason I had to remove the Facebook file for it to compile at all (ghc got stuck in an infinite loop on it)
14:53:05 <Saizan> it's not infinite, just very long and memory consuming :)
14:53:16 <nibro> Saizan: ah :-)
14:53:50 <nibro> Saizan: I also removed the dependency on unix and the -DUNIX flag, still worked fine for me
14:53:53 <MyCatVerbs> Saizan: deciding between the difference between the two is impossible, though!
14:54:04 <nibro> Saizan: or rather, then it worked fine :-)
14:54:44 <Saizan> nibro: ah, that's fixed in the repo
14:54:52 <Saizan> since today :)
14:55:00 <olsner> ... only with infinite time and patience can the halting problem be solved
14:55:04 <nibro> for HAppS-HTTP as well?
14:55:33 <nibro> Saizan: I grabbed it from the darcs repo
14:55:36 <Saizan> nibro: for HAppS-State and HAppS-Server, HTTP is just an alias for Server, right?
14:55:51 <Botje> pejo: okay, I re-read sections 4 and 5
14:55:56 <nibro> Saizan: right, package Server ~ repo HTTP :-)
14:56:09 <Botje> looks like I'll be needing BiPlate after all :)
14:56:40 <nibro> Saizan: Lemmih told me you had fixed that for State and indeed there was no -DUNIX flag there, but for Server it was still there
14:56:46 <Botje> it also said using Typeable and Data is the slowest and least safe way
14:56:53 <pejo> Botje, ndm tried explaining all this to me earlier. My conclusion was that I don't care about Haskell'98, so I might as well use biplate. :-)
14:57:02 <Botje> :)
14:57:18 <Botje> I was wondering that too :)
14:57:36 <Saizan> nibro: i could have forgotten to push, checking..
14:58:23 <nibro> Saizan: there were some patches there now when I pulled
14:58:56 <Saizan> nibro: ah ok
14:59:14 <pejo> Botje, (any factual errors are of course mine, I haven't had time to follow up and learn how to use it yet so my understanding is very limited).
14:59:16 <Saizan> ue Apr 15 19:23:38 CEST 2008  Andrea Vezzosi <sanzhiyan@gmail.com> * update .cabal file for windows
15:00:00 <Botje> pejo: i'll learn as I go along :) thanks anyway!
15:00:36 <nibro> Saizan: weird.. hmm, when I did darcs get in dl'ed the patches, and then said "unapplying patches: 10" or some such
15:02:17 <Saizan> nibro: you mean darcs pull? weird however
15:03:21 <nibro> Saizan: I mean darcs get
15:03:59 <nibro> Saizan: now I did a pull though, and I get tons of errors related to bytestring :-(
15:04:45 <Saizan> when building?
15:05:16 <nibro> yes
15:05:22 <Saizan> did you upgrade the bytestring package recently?
15:05:31 <nibro> yes, just before building
15:05:46 <nibro> but it seems some package is still depending on 0.9.0.1, sigh
15:05:51 <Saizan> yeah
15:05:57 <nibro> is there an easy way to find out which?
15:06:04 <Saizan> you've to rebuild those packages with the new bytestring
15:06:12 <nibro> I thought I did that :-\
15:07:10 <Saizan> nibro: make sure you clean the build directory when rebuilding, ghc is not smart enough to rebuild a module just because there's a new version of a package
15:07:28 <Saizan> nibro: ghc-pkg describe pkgname tells you the dependencies
15:07:42 <nibro> thanks, just what I needed :-)
15:08:24 <nibro> Saizan: ... or rather, it wasn't
15:08:47 <nibro> isn't there a command to tell me what packages *depend* on X, rather than having to look at all of them and see what they depend on?
15:08:51 <Botje> my error reporting function is now appropriately named "yell" :)
15:08:55 <Saizan> no :(
15:09:04 <nibro> ah well
15:09:43 <vincenz> yell = error . map toUpper
15:09:44 <Saizan> so, regex-compat doesn't build on windows?
15:10:34 <nibro> Saizan: not the 0.93 version anyway, or it could be me that's just stupid
15:11:08 <nibro> Saizan: I get errors about missing references to _impure_ptr or some such
15:13:04 <Botje> vincenz: heh. I just might do that :)
15:13:31 <Saizan> nibro: oh 0.71.0.1 is the stable one
15:13:53 <Saizan> but i see that cabal would have installed 0.93
15:14:16 <nibro> Saizan: right, and that's the one I tried to manually install too
15:15:19 <Saizan> however we don't use it anymore, so :)
15:15:32 <nibro> an even better solution :-)
15:16:36 <nibro> hmm, if I unregister a package and then install the same one again, would dependencies on that package work again?
15:17:02 <nibro> I'm starting to think that's the easiest way to find what packages depend on bytestring 0.9.0.1
15:18:00 <Saizan> they should
15:18:46 <Saizan> nibro: oh, if you unregister bytestring-0.9.0.1 ghc-pkg list will put the dependecies in {} brackets
15:21:21 <nibro> cgi, time, ghc, Win32 and regex-* got {}-ed
15:21:27 <nibro> do you depend on cgi?
15:21:46 <Saizan> no
15:22:23 <Saizan> i think you might just need a 'runghc Setup.hs clean' at this point?
15:22:47 <nibro> hmm, if I reinstalled a package but ghc wasn't clever enough to recompile, could it be listed with the wrong version then?
15:24:08 <nibro> the errors I got were not of the nice variety (couldn't match this type with that) but rather a ghc panic trying to link the same file twice
15:24:25 <nibro> or rather, the same object
15:25:01 <paczesiowa> nibro: try to downgrade bytestring
15:25:16 <Saizan> i'm not so familiar with how ghc manages these things
15:25:45 <paczesiowa> nibro: you can't rebuild ghc with new bytestring (because ghc (the package) is built in in the compiler)
15:26:03 <Saizan> paczesiowa: we're not rebuilding ghc
15:26:12 <Saizan> paczesiowa: not using the ghc package
15:26:17 <Saizan> *nor
15:27:25 <nibro> paczesiowa: I was afraid that would be the answer
15:27:31 <nibro> Saizan: I asked about that earlier
15:27:51 <paczesiowa> Saizan: oh I see. I had these kind of problems (linking with different versions of bytestring) when using new bytestring and hs-plugins (which needs ghc, which needs builtin od bytestring)
15:27:55 <byorgey> sigh. it seems that bytestring-0.9.0.4 has caused more dependency grief than all the other packages on hackage put together =P
15:28:28 <nibro> paczesiowa: I have exactly that problem
15:28:46 <Staz> vincenz : I swear I am not a spammer :)
15:28:49 <Saizan> nibro: you're using hs-plugins?
15:28:57 <nibro> and the problem is that some other package that HAppS depends on requires bytestring 0.9.0.4
15:29:15 <nibro> Saizan: I would *like* to, but I can't get it to install properly
15:29:36 <Saizan> nibro: ah ok, to use hs-plugins stick to 0.9.0.1
15:29:44 <nibro> Saizan: I want to try out Lemmih's happs port for hsp
15:29:44 <paczesiowa> nibro: but  had that problem only in ghci, compiled code worked ok (but it might be because of hs-plugins which has smart module loader)
15:30:14 <nibro> Saizan: I would, but there's some package that you depend on that requires 0.9.0.4
15:30:18 <Saizan> nibro: i've all of HAppS installed using bytestring-0.9.0.1
15:30:45 <nibro> Saizan: hmm, then I guess I'll have to dig up an older version of whatever package that was
15:31:14 <paczesiowa> speaking of hs-plugins, how do I install that on windows? cabal wants sh, cabal in cygwin needs gcc
15:31:39 <nibro> paczesiowa: install gcc?
15:31:44 <Saizan> paczesiowa: use mingw sh
15:32:01 <vincenz> Staz: fair enough :) You just had a funky domain-name
15:32:20 <paczesiowa> nibro: so I need minigw setup with cygwin?
15:33:44 <nibro> paczesiowa: I didn't understand that question :-)
15:33:58 <paczesiowa> shouldn't ghc install contain simple sh (like it has gcc)?
15:33:59 <nibro> paczesiowa: I ran cygwin setup and told it to install gcc
15:34:22 <paczesiowa> nibro: is there a difference between cygwin's gcc and minigw?
15:34:56 <nibro> paczesiowa: I have no idea
15:35:16 <paczesiowa> I hate windows:/
15:35:53 <nibro> argh, when I try to reinstall bytestring-0.9.0.1 I get a permission denied error on packageconf.. ???
15:36:27 <Saizan> if you were on linux i'd say use sudo :)
15:36:45 <nibro> haha
15:37:04 <nibro> I haven't had that problem with any other package though
15:37:58 <Saizan> sure there wasn't another process reading it?
15:38:20 <nibro> quite
15:38:31 <ziman> @pl f s = case s of (t:ts) -> (replicate 20 t) ++ ts; _ -> s
15:38:32 <lambdabot> (line 1, column 24):
15:38:32 <lambdabot> unexpected ">" or "-"
15:38:32 <lambdabot> expecting variable, "(", operator or end of input
15:39:23 <ziman> @pl \s -> case s of (t:ts) -> (replicate 20 t) ++ ts; _ -> s
15:39:23 <lambdabot> (line 1, column 24):
15:39:23 <lambdabot> unexpected ">" or "-"
15:39:23 <lambdabot> expecting variable, "(", operator or end of input
15:39:47 <ziman> hmm
15:40:04 <allbery_b>  @pl doesn't support case statements (in the general case they can't be made pointfree)
15:40:59 <ziman> yes, thanks
15:42:05 <nibro> meh
15:42:12 <nibro> now I can't install any package at all as global
15:42:48 <Saizan> if i were you i'd start from scratch :\
15:43:06 <nibro> by reinstalling ghc?
15:43:11 <Saizan> yup
15:43:51 <nibro> alright, installing now
15:45:23 <Saizan> is there any existing tool to reflow a 2-column pdf to 1-column?
15:45:40 <nibro> acrobat? :-)
15:47:21 <nibro> argh!
15:47:35 <nibro> I still can't install things globally
15:47:37 <nibro> grr
15:47:44 <nibro> oh well, at least I can try to install them locally now
15:52:42 * nibro is off to walk the dogs
15:58:09 <paczesiowa> ok, I installed gcc, but hs-plugins fails to configure, that tiny c-test program has misplaced quotes aroung paths
15:58:56 <paczesiowa> and this time TERM=dumb doesn't help:/
16:08:00 <FunctorSalad> I has the dumb... for (Monad m), is there a function from (a -> m b) to m (a->b)? can't think of it
16:08:58 <vincenz> FunctorSalad: that would never work
16:09:00 <FunctorSalad> nvm, I think it's impossible (considering the case m = free group functor)
16:10:09 <byorgey> yeah, pretty sure it's impossible, though not sure how to prove it off the top of my head
16:10:53 <FunctorSalad> (of course I guess I mean a function natural in a and b)
16:12:07 <FunctorSalad> vincenz: how do you see that so quickly?
16:16:26 <lament> if a is Integer, (a -> m b) is show, what would you like the result to be?
16:16:49 <lament> it's a list of functions, each returning a character
16:17:52 <FunctorSalad> you mean m=IO?
16:17:55 <lament> presumably the first function would return the first character, and the second function would return the second character... etc
16:17:56 <FunctorSalad> b=()
16:18:03 <lament> no, m b = [Char]
16:19:26 <FunctorSalad> I see. since the output of the original function can growth without bounds, that wouldn't work
16:19:38 <FunctorSalad> or wait, lists can be infinite in haskell
16:20:19 <Runar> OK, I compiled Agda2. Now... how do I make it go?
16:21:16 <nibro> paczesiowa: that doesn't sound promising for my upcoming attempt :\
16:21:24 <Saizan> Runar: have you read the README?
16:22:19 <Runar> There's something about a stand-alone executable, but I can't find that this has been linked.
16:22:36 <lament> FunctorSalad: the point is that b and m b are very very different types
16:23:03 <nibro> Saizan: how come you depend on HaXml-1.13 and not any higher versions?
16:23:40 <Runar> OK, found it. Never ye mind.
16:24:28 <twanvl> ?type \mf a -> liftM ($a) mf -- the other way around is possible
16:24:29 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> a -> m b
16:25:23 <FunctorSalad> lament: in this case it would seem to work though. given f: a -> [b], let L: [a -> b] be defined by L !! i = [ \a -> (f a) !! i ]. (of course that's not valid haskell, but conceptually)
16:25:41 <paczesiowa> nibro: do you know automake or whatever tool that makes those configure checks?
16:26:14 <FunctorSalad> hmm, (f a) may fail to have i elements though
16:26:15 <nibro> paczesiowa: yeah, you need to install autoconf and automake from cygwin setup too
16:26:24 <pjd_> FunctorSalad: generally, a function like that requires "unwrapping" m b
16:26:55 <pjd_> which you can't do for monads in general;  but specific instances can have specific ways
16:27:00 <pjd_> like !! for lists
16:27:12 <macondo> I've seen that you can either compile or interpret a haskell program, but which is more haskellian?
16:27:15 <FunctorSalad> pjd_: yeah but here you are allowed to wrap them back up again "pointwisely"
16:27:41 <Pseudonym> macondo: Whatever makes sense.
16:27:45 <paczesiowa> nibro: that's not the problem, problem is hacking those configure scripts to succeed
16:27:55 <Pseudonym> I often debug in the interpreter, then run in the compiler.
16:28:03 <FunctorSalad> pjd_: I don't think it generalizes either, but I don't see why
16:28:12 <pjd_> FunctorSalad: i'm not sure what you mean
16:28:33 <nibro> paczesiowa: ouch
16:28:41 <Pseudonym> It's part of Haskell culture that no language or implementation features are "off limits".
16:28:47 <FunctorSalad> pjd_: I mean I do have an m in m (a -> b), so I wouldn't really have to return unwrapped (m b) 's
16:29:00 <nibro> paczesiowa: I hope I'll soon get to that point of things too :)
16:29:01 <Pseudonym> Except possibly unsafePerformIO.
16:29:21 <pjd_> FunctorSalad: well, the wrapping of (a -> b) is independent of the unwrapping of m b
16:29:31 <macondo> Pseudonym: is a Haskell executable program equivalent to a C++ one?
16:29:49 <pjd_> IOW, you can take (a -> m b) to m (a -> m b)
16:29:50 <jsnx> :t return id
16:29:51 <lambdabot> forall a (m :: * -> *). (Monad m) => m (a -> a)
16:29:52 <Pseudonym> macondo: Under what equivalence relation?
16:30:07 <Saizan> nibro: because the other have a different api, not sure if that matters anymore now
16:30:11 <FunctorSalad> pjd_: yeah I see no obvious way to do this, but any ideas for a proof?
16:30:17 <pjd_> but getting rid of the inner m b is an independent problem, which you can't do
16:30:28 <pjd_> join only works for m (m b)
16:31:03 <macondo> Pseudonym: that it's self contained that is to say it doesn't depend on external applications and is executed directly by the OS
16:31:24 <pjd_> FunctorSalad: i think it comes down to a proof "by definition":  monads (in generality) do not define any function m b -> b
16:31:37 <Pseudonym> macondo: Yes, if you statically link.  If not, then it's equivalent to a C++ executable that uses system shared libraries.
16:31:57 <pjd_> you comonads do
16:32:03 <Pseudonym> Some do that.  Hell, some C++ programs in Windows ship with the DLL for MFC.
16:32:25 <FunctorSalad> pjd_: definitions have consequences though. we would need a counterexample monad to show that such a function isn't a consequence of the def. of monad
16:32:34 <jeffz> programs are supposed to redistribute mfc,  it's not part of windows
16:32:43 <Pseudonym> So no, GHC is no worse in that respect.
16:32:46 <macondo> Well, that's because there's no package manager in Windows, you have to distribute all the libraries again
16:33:15 <Pseudonym> macondo: It's also because Windows has no solution for DLL versioning, apart from "just ship it".
16:33:24 <Pseudonym> But yeah.
16:34:08 <twanvl> FunctorSalad: how about the writer monad, m a = (a,w)
16:34:08 <macondo> Pseudonym: yeah, I think that's one of the best things of linux
16:34:12 <Pseudonym> On most Linux distros, you need to install the run-time of libstdc++ to run many applications.
16:34:14 <lament> macondo: the only things executed "directly by the OS" are statically linked binaries and nobody uses those anymore
16:34:44 <FunctorSalad> twanvl: ok. so the task would be to turn a -> (b,w) into (a->b,w)...
16:34:45 <pjd_> FunctorSalad: i guess the obvious way of doing it is counting the balance of the m's in the monad methods
16:34:59 <Pseudonym> So I maintain that the correct answer is: GHC is no worse than C++ in this respect.
16:35:04 <macondo> lament: I know, what I wanted to know was whether you needed something as an interpreter or not
16:35:17 <Pseudonym> And like in C++, you can statically link if you want.
16:35:30 <macondo> I have to go, see you later
16:35:42 <pjd_> return introduces one m, so it takes the nesting from n to n+1
16:35:47 <Pseudonym> Technically speaking, most C++ code under Linux is interpreted, the interpreter being ld-linux.so.
16:35:49 <Pseudonym> Cya macondo.
16:35:55 <pjd_> fmap/liftM leaves it unchanged, so it's just n to n
16:36:08 <twanvl> so you need: (a->(b,w)) -> (a->b, w);  now take a = Void, then you need  (Void -> (b,w)) -> (Void->b, w) =  ~(b,w) -> (~b,w)
16:36:29 <pjd_> join goes from n+2 to n+1
16:36:30 <hpaste>  functor pasted "(no title)" at http://hpaste.org/6997
16:36:36 <twanvl> So you would need to conjure up a w from somewhere
16:36:55 <twanvl> Although, since the writer monad requires a monoid, this is actually possible.
16:37:01 <FunctorSalad> twanvl: ok, but Void seems to be an exceptional case
16:37:20 <FunctorSalad> but wait, I think we can do something with naturality
16:37:25 <twanvl> One exceptional case is enough
16:37:35 <byorgey> FunctorSalad: but if you're going to write a polymorphic function (a -> (b,w)) -> (a->b,w), then it has to work for all types
16:37:36 <pjd_> (more accurately, fmap/liftM would be n+1 to n+1)
16:37:39 <byorgey> including Void
16:37:59 * lament wonders if ld.so qualifies as an "interpreter"
16:38:15 <Pseudonym> lament: I don't see why not.
16:38:15 <FunctorSalad> of course one exception is enough, but if it's the only exception you could just add a != Void to the hypotheses
16:38:30 <lament> Pseudonym: common sense? :)
16:39:05 <pjd_> FunctorSalad: so no monad method ends with with less than n+1 levels of nesting
16:39:43 <Pseudonym> lament: The correct terminology for ld.so is a "loader".
16:39:43 <pjd_> so any composition of them must result in at least 1 level
16:40:00 <thoughtpolice> okay, so i'm trying to put what I've learned from TAPL to use by writing a lambda calculus evaluator basically
16:40:14 <pjd_> FunctorSalad: does that make sense?
16:40:17 <Pseudonym> But then, you could probably argue that a JIT-compiling virtual machine is also a "loader".
16:40:25 <thoughtpolice> i just started and i'm working on the parser before anything else
16:40:39 <thoughtpolice> the thing is there's kind of an ugly hack I don't like and I can't see a clean way to resolve it
16:40:44 <FunctorSalad> pjd_: yes, but I don't see how the arrows enter into your argument
16:40:46 * pjd_ would like to point out that the CPU is an interpreter
16:40:57 <byorgey> thoughtpolice: what's that?
16:40:58 <thoughtpolice> primarily I have to lift variables out of the Expr datatype so I can preserve any type information that I parsed with the string
16:41:12 <thoughtpolice> byorgey: http://hpaste.org/6996
16:41:15 <pjd_> FunctorSalad: arrows?
16:41:23 <thoughtpolice> I tried making the parser applicative to get a feel for Control.Applicative
16:41:55 <lament> Pseudonym: i guess a 'loader' at some point replaces the actual code being executed by the CPU with the code of the program it loads
16:42:02 <thoughtpolice> I thought it came out pretty well considering I don't have much experience with parsec and no experience with applicative, it's just that I have to lift Var out and create a duplicate datatype that bothers me.
16:42:19 <lament> Pseudonym: which is very different from an interpreter, given a von neumann architecture
16:42:47 <functor> thoughtpolice, did you have en answer to the parser question ?
16:42:51 <Pseudonym> lament: As does a JIT-compiling VM, no?
16:42:58 <nibro> Saizan: how long is reasonable to wait for that Facebook compilation?
16:43:29 <lament> Pseudonym: isn't it very threaded?
16:43:39 <FunctorSalad> pjd_: I just meant the "->". and if you define level of nesting as total number of "m"s in the term, then a -> m b and m (a->b) have the same level... monad operations can result in the same level of this kind of nesting, no?
16:43:43 <Pseudonym> It depends on the JIT.
16:43:57 <Philippa> Pseudonym: in general, loaders and linkers can be specced by way of an amount of metadata and some source-to-source transformations, whereas a JIT can't
16:44:20 <Pseudonym> Philippa: Isn't relocation a source-to-source transformation?
16:44:32 <Philippa> Pseudonym: bingo, the source is raw machine code
16:44:38 <pjd_> FunctorSalad: i wouldn't say it's the same level
16:44:54 <thoughtpolice> functor: ?
16:44:54 <byorgey> thoughtpolice: oh, I see, because you want to be able to write a  varParser function, but it needs to be used in two places, and if you want to use an applicative style...
16:44:56 <FunctorSalad> pjd_: yeah but how do you define the total nesting level then?
16:45:01 <Pseudonym> So what about an emulator?
16:45:07 <Philippa> the JIT may only have 2 levels to worry about as well, but if so that's because the metadata's encoded in the source level and it's got to worry about a /different/ target level
16:45:12 <thoughtpolice> byorgey: I don't have to use an applicative style, I just thought it would be a neat experiment
16:45:29 <thoughtpolice> byorgey: I feel I could almost certainly fix it if using a monadic-do notation but this is just an exercise
16:45:32 <byorgey> thoughtpolice: no, it's very nice, I like writing parsers in that style too
16:45:39 <functor> thoughtpolice, I thought you had said something about  http://hpaste.org/6997
16:45:44 <pjd_> FunctorSalad: the number of m's around a type/expression
16:45:53 <thoughtpolice> byorgey: it feels pretty natural, considering I've never used applicative I liked it :)
16:45:53 <Philippa> ultimately, a link-loader doesn't have to know anything about computation-in-general
16:46:12 <Philippa> an emulator's just a particularly weird flavour of interpreter :-)
16:46:41 <pjd_> but with the proviso that (a -> m b) is a wholly separate type from (a -> m b)
16:46:44 <Philippa> but the distinction is generally that it's specced in terms of some piece of hardware (if hypothetical)
16:46:47 <Pseudonym> I guess what I'm saying is that the line is fuzzy.  Of cours it's useful to distinguish between the terms "interpreter" and "loader".
16:47:00 <Philippa> I'm saying I don't see the fuzziness
16:47:03 <byorgey> thoughtpolice: I mean, you can always have varParser return a tuple (v,ty) and then make some auxiliary functions to construct a Fn or Var using that
16:47:03 <sieni> and there are really weird kind of emulator/simulators as well
16:47:06 <pjd_> they're as different as Int or String, as far as types are concerned
16:47:08 <Pseudonym> But in principle, you could implement binaries on an OS using the hash-bang mechanism.
16:47:11 <thoughtpolice> byorgey: but yeah, basically my problem is I can't find a good way to keep explicit type information on a variable with me
16:47:17 <pjd_> so you can wrap either of those in as many m's as you like
16:47:23 <Philippa> it's like complaining that JIT blurs the lines between compilation and interpretation - they're still functions with different types
16:47:24 <Pseudonym> Where the hash-bang part points to a loader.
16:48:03 <pjd_> to get m (m (a -> m b)), or m (m (a -> b))
16:48:03 <byorgey> thoughtpolice: but in some sense, I'd say that the fact that you have a separate function varParser which gets used in two places, means that having a separate data type to represent a var-type combination is actually the right thing to do.
16:48:03 <FunctorSalad> pjd_: well, ok, I sort of see it now and am too lazy to think of a more formal proof for now ;)
16:48:04 <byorgey> it does reflect the structure of the grammar well.
16:48:11 <Philippa> yeah, but that's just a different flavour of metadata on top
16:48:26 <lament> Philippa: turing-complete type extensions, on the other hand, do blur the line between compilation and interpretation :)
16:48:27 <pjd_> but the inner bits (the -> type constructions) could just as well have been x and y
16:48:35 <Philippa> when we call the thing a hash-bang calls an interpreter, that's from the shell's point of view - its job is to provide meaning to the script
16:48:46 <byorgey> thoughtpolice: personally I don't think having a separate data type for a variable + type is a bad thing, I'd just call it something other than Var2.
16:48:46 * Pseudonym nods
16:48:53 <thoughtpolice> byorgey: hm, it most definitely seems easier just to keep Var's in their own datatype and have a constructor for Expr wrap Var2
16:49:07 <byorgey> thoughtpolice: yup
16:49:17 <Pseudonym> I'm not saying "oh, don't use the word loader, just call it an interpreter".
16:49:40 <Pseudonym> Stuff over here is definitely a "loader", and stuff over there is definitely an "interpreter".
16:49:44 <sclv_> @seen conal
16:49:45 <lambdabot> conal is in #haskell and #ghc. I don't know when conal last spoke.
16:49:46 <pjd_> (...i meant "proviso that (a -> m b) is a wholly separate type from (a -> b)", of course)
16:49:50 <Philippa> yeah. I'm just saying that in that particular case it can be clearly described as "loader being used as an interpreter"
16:50:00 <Pseudonym> But there's a continuum of possibilities between the two.
16:50:03 <byorgey> thoughtpolice: a Var2 is a separate entity, and it can be used in multiple ways in the construction of Expr values.  It just so happens that one of those ways is that a Var2 *is* an Expr value, in and of itself
16:50:03 <Philippa> cf #! /usr/bin/hello
16:50:16 <Philippa> I don't see that continuum in and of itself
16:50:19 <functor> I've been working on a function parser my self. It works VERY WELL, with the exception of a few minor glitches. Perhaps we can all work on it together and post it as an open source module on haskell.org
16:50:24 <Pseudonym> And the "you can think of a loader as an interpreter" is a useful piece of intuition, IMO.
16:50:30 <byorgey> it is a bit annoying that you need yet another data constructor to wrap that, but it's not so bad really.
16:50:41 <Philippa> sure. You can think of pretty much anything that takes input as an interpreter though
16:50:57 <Pseudonym> If you can think of the input as code, then yes.
16:51:01 <lament> (and why not)
16:51:03 <byorgey> thoughtpolice: and I'll bet that when you write the interpreter, you'll have some functions foo :: Var2 -> blah and you'll be glad it's a separate thing.
16:51:07 <thoughtpolice> byorgey: yeah I see your point
16:51:08 <twanvl> FunctorSalad: another try: the error monad,   f id :: Either e (Either e a -> a)
16:51:12 <Philippa> oh, it's definitely an encoding of /something/ :-)
16:51:21 <FunctorSalad> pjd_: some types are related though... you can turn (m c) into m (c|d) for example, since there is a natural way to map c intro c|d. but ok, I believe you that a->mb and a->b are not related like that
16:51:22 <Philippa> "what is computation? What is computational content?"
16:51:32 <FunctorSalad> *into
16:51:38 <functor> I feel like there are too many questions about function parsers
16:51:44 <thoughtpolice> byorgey: actually I was trying to implement a typechecker + type inferencer (I *think* I get the unification algorithm) as well, then below that a reducer to some core, and then maybe use harpy to generate code :)
16:52:01 <pjd_> FunctorSalad: right
16:52:02 <byorgey> thoughtpolice: wow, quite the project!  sounds awesome. =)
16:52:05 <Philippa> to me, the only bit that gets blurry is when the linking/loading metadata has computational content
16:52:09 <lament> Philippa: on the other hand, it is pretty silly to think of gcc as an interpreter :)
16:52:11 <thoughtpolice> byorgey: it may take me forever, though.
16:52:18 <byorgey> thoughtpolice: probably =)
16:52:23 <thoughtpolice> byorgey: just getting the parser right will probably be quite a challenge :)
16:52:26 <Philippa> lament: "it's a program that specifies the following binary output:"
16:52:27 <thoughtpolice> i have lots of reading material thougha
16:52:33 <Pseudonym> Philippa: It's not so silly to think of cpp as an interpreter.
16:52:34 <thoughtpolice> and I've been going insane out of my mind with boredom
16:52:38 <byorgey> thoughtpolice: I'm partway through TAPL, and I've only made it as far as implementing an interpreter for the untyped lambda calculus =)
16:52:39 <Pseudonym> Sorry, I meant to direct that at lament.
16:52:52 <lament> an interpreter converts code to side effects
16:53:01 <lament> a compiler converts code to more code
16:53:09 <Pseudonym> lament: So an XSLT implementation is an interpreter, or not?
16:53:14 <Philippa> lament: congratulations, you just made a stupid assumption :-)
16:53:15 <Pseudonym> How about m4?
16:53:22 <Philippa> how about a pure lambda calculus interpreter?
16:53:24 <thoughtpolice> byorgey: hah, at least you've done that. i'm starting from nearly no experience with writing a lambda calculus :)
16:53:30 <pjd_> FunctorSalad: put another way, what you're really asking for is a function :: x -> m y, along with a function :: x -> y
16:53:52 <pjd_> where x = (a -> m b) and y = (a -> b)
16:53:59 <lament> Philippa: a pure LC interpreter converts LC code into a side effect of possible nontermination
16:53:59 <Runar> where can I get HsReadlineConfig.h ?
16:54:28 <Philippa> lament: smartarse. Pure STLC, then
16:54:31 <sieni> lament: can't a compilation not terminate?
16:54:42 <byorgey> Runar: I don't know, what's that?
16:55:01 <pjd_> rather, you're looking for a function :: x -> m y, which would be return composed with a function :: x -> y
16:55:03 <thoughtpolice> byorgey: but yeah thanks for the thought. :)
16:55:15 <byorgey> thoughtpolice: =)
16:55:23 <lament> Philippa: it's pretty sane to call a STLC interpreter a compiler
16:55:37 <Runar> Agda2 includes HsReadlineConfig.h
16:55:50 <lament> Philippa: "Suck this, Lisp! We have REAL macros!"
16:55:54 <pjd_> this latter function would :: (a -> m b) -> (a -> b)
16:57:18 <pjd_> which is the composition of a function (m b -> b) with the (a -> m b) function you're given
16:59:22 <byorgey> Runar: hm, on my system it seems to be part of the readline library that comes with ghc
16:59:33 <Runar> which ghc?
16:59:35 <conal> sclv_: howdy
16:59:41 <byorgey> Runar: you can download the readline package from hackage.haskell.org if you don't already have it
16:59:51 <byorgey> Runar: looks like it comes with 6.6 as well as 6.8.
17:00:08 <FunctorSalad> pjd_: thanks for your help, but I'm too tired now (2 am ;))
17:00:20 <pjd_> FunctorSalad: maybe it helps later :)
17:00:50 <pjd_> FunctorSalad: i guess a key insight is that  (a -> x) is generally an opaque type
17:01:25 <pjd_> FunctorSalad: all you can do with it is pre- and post-compose functions to change the type parameters
17:01:42 <FunctorSalad> pjd_: hmm, if a is non-empty you can fix some element z of a and get a function from a->x to x
17:01:47 <roconnor> @type (>.>)
17:01:47 <lambdabot> Not in scope: `>.>'
17:02:19 <lament> compiler :: a -> b; interpreter :: a -> IO b; preprocessor/macroexpander/reducer :: a -> a; JITinterpreter :: (a -> b) -> a -> IO b
17:02:21 <MyCatVerbs> Philippa: a pure STLC interpreter converts LC code into a side effect of possibly taking longer to complete than the sun will continue to output energy for, even though it will in theory eventually terminate.
17:02:25 <EvilTerran> ?hoogle >=>
17:02:26 <lambdabot> Control.Monad.(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
17:02:31 <pjd_> FunctorSalad: right, which is changing the first parameter
17:03:09 <FunctorSalad> pjd_: I see how arbitrarily picking an element from every (non-empty) type a would be problematic though
17:03:10 <MyCatVerbs> Philippa: since "strictly terminating" doesn't guarantee "faster than O(n^n^x^y), where x and y are international phone numbers". ^_^
17:03:13 <Philippa> MyCatVerbs: not necessarily
17:03:25 <lament> a pure STLC _reducer_ converts STLC to STLC
17:03:37 <lament> it's a special case of a compiler
17:03:41 <Philippa> you can write a pure STLC interpreter which is itself a pure function - it's your means of computing that which would have a side-effect
17:03:45 <MyCatVerbs> Philippa: how not? You have plans for a longer-lasting version of Sol? :)
17:03:51 <nibro> paczesiowa: I just installed plugins without problems :D
17:03:55 <Pseudonym> lament: Just a suggestion, but I think the Aho and Ullman T-diagrams are a better notation here.
17:04:02 <paczesiowa> nibro: I hacked that configure script
17:04:12 <nibro> paczesiowa: I never needed to
17:04:29 <jsnx> what is the usual way to make a function memo-izing?
17:04:39 <jsnx> combinators?
17:04:47 <lament> Pseudonym: what's the problem with this one? :)
17:04:58 <paczesiowa> nibro: anything not usual with your windows/cygwin?
17:05:02 <MyCatVerbs> Philippa: I still think lament's distinction of an interpreter being something that outputs side effects and a compiler as something that outputs (presumably transformed in some way) code is a pretty damn good rule of thumb for practical purposes.
17:05:13 <nibro> paczesiowa: I don't think so
17:05:18 <Pseudonym> lament: I like pictures.
17:05:23 <paczesiowa> nibro: what hs-plugins version?
17:05:28 <nibro> paczesiowa: I installed gcc, autoconf and automake
17:05:32 <nibro> paczesiowa: 1.2
17:05:36 <Philippa> MyCatVerbs: you can refine it. Look at 'computational content' and where it came from
17:05:47 <paczesiowa> nibro: where did you get that?
17:05:48 <Philippa> (and be careful of quines!)
17:06:02 <nibro> paczesiowa: I got it from hackage via cabal install :-)
17:06:42 <paczesiowa> nibro: damn, I downloaded first thing I found when googling for hs-plugins
17:06:47 <Saizan> ?where hs-plugins
17:06:47 <lambdabot> http://code.haskell.org/~dons/code/hs-plugins
17:06:47 <paczesiowa> nibro: which is 1.0
17:07:03 <nibro> paczesiowa: dons isn't the maintainer anymore
17:07:14 <nibro> argh
17:07:21 <MyCatVerbs> Philippa: it bisects the space of program-consuming programs quite neatly though, with very few ambigous cases. Plus it fits the widely-accepted informal definitions of the terms "compiler" and "interpreter" as programs that output programs and programs that perform the actions that the input program would perform.
17:07:34 <nibro> now suddenly I can't install things locally either
17:07:44 <paczesiowa> anyway, after succesful configure it looks like not ghc-6.8 friendly
17:07:48 <nibro> permission denied writing the user package conf
17:07:55 <paczesiowa> I definetely need newer version
17:08:03 <MyCatVerbs> nibro: you're using --user, right?
17:08:08 <paczesiowa> ?where cabal-install
17:08:08 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
17:08:16 <nibro> paczesiowa: I'd grab 1.2 if I were you, especially since it worked so easily for me
17:08:25 <nibro> MyCatVerbs: I do yes
17:08:25 <Philippa> MyCatVerbs: it sure doesn't bisect the space of program-consuming programs, there's a much wider class of metaprograms than that! It's somewhat sloppy regarding the informal definitions, because the informal definitions hold up better regarding pure input
17:08:55 <Philippa> the informal definition for interpreter being more like "does what the input program does"
17:08:55 <nibro> MyCatVerbs: I had problems earlier with permissions on the global package conf, now suddenly it starts giving me problems with the user one too :-(
17:09:05 <sclv_> Philippa: examples?
17:09:08 <MyCatVerbs> nibro: you aren't switching user or anything crazy are you?
17:09:10 <Philippa> formalising just a little is dangerous!
17:09:23 <nibro> MyCatVerbs: certainly not
17:09:23 <Philippa> sclv: typecheckers, verifiers, testing programs...
17:09:33 <nibro> MyCatVerbs: and it worked a few seconds ago when installing plugins
17:09:49 <MyCatVerbs> Philippa: okay, but it nicely bisects the space if *useful* program-consuming programs.
17:09:49 <nibro> MyCatVerbs: it stopped working between one package and the next
17:09:51 <Saizan> nibro: do you run as administrator or not? a permission denied exception can mean various things on windows
17:09:53 <sclv_> i'd classify those all as forms of compilers.
17:09:54 <MyCatVerbs> s/if/of/
17:10:10 <lament> Philippa: i honestly can't think of any programs that i would call interpreters that don't fit my definition.
17:10:20 <Philippa> MyCatVerbs: No. Again, I've used useful programs that aren't either compilers or interpreters
17:10:29 <nibro> Saizan: I do believe I have admin rights with this account
17:10:39 <nibro> Saizan: but I'm not sure
17:10:41 <MyCatVerbs> Philippa: please elaborate?
17:10:48 <nibro> Saizan: still, it worked just seconds ago...
17:10:52 <Philippa> lament: you've gone out of your way to eliminate pure lambda calculi though. How about turing machine executors, or the equivalents for many other formalisms?
17:11:44 <lament> Philippa: if it _actually_ doesn't have any side effects, it's equivalent to a null program
17:11:58 <Philippa> MyCatVerbs: programs like lint have a lengthy history, for example. Tools exist for instrumenting existing code, and the AOP guys have a big thing about code weavers...
17:12:02 <MyCatVerbs> Philippa: I honestly am not aware of any useful program-consuming programs that can't really be pigeonholed as compilers or interpreters... uh, well, scratch that, actually I guess there are also static program analysis programs.
17:12:09 <nibro> hmm, seems it's a problem with cabal install
17:12:13 <Saizan> nibro: check if you can modify/move your package.conf manually (backup first)
17:12:19 <lament> MyCatVerbs: haddock, hscolour.
17:12:23 <nibro> I have no problem installing via runhaskell Setup install
17:12:48 <MyCatVerbs> lament: ah, of course, thank you.
17:13:00 <Philippa> lament: wrong. You're making assumptions about the range of possible substrate systems
17:13:09 <paczesiowa> nibro: thanks, I'll try later 1.2. I'd loose all night hacking configure scripts of old version
17:13:25 <Philippa> now, anything that doesn't have a side-effect when you attempt to run it /on real-world hardware/, sure...
17:13:34 <lament> Philippa: i don't understand, give an example?
17:13:43 <Philippa> but how many layers of interpretation might there be between that and the programs we're actually discussing?
17:14:07 <Philippa> the side-effects're in the substrate's semantics, not the program's
17:14:08 <MyCatVerbs> Philippa: if by "code weavers" you're talking about what I think you're talking about, then those surely count as compilers. They're programs that input an aspect-annotated dialect of Java and output standard Sun-Microsystems-brand Java.
17:14:26 <Saizan> nibro: uhm, a similar bug has been reported
17:14:39 <nibro> Saizan: I'm glad to hear that
17:15:01 <Philippa> MyCatVerbs: it's plenty possible to envisage a variant that's source-to-source. And there's a range of optimisations that can be implemented without resort to actual (partial) evaluation, too
17:15:24 <Philippa> code rewriting doesn't have to give a damn about the semantics of the code being rewritten
17:15:41 <MyCatVerbs> Philippa: uh, it has to preserve them to be useful.
17:15:44 <Philippa> so in no sense is that an interpretation of the rewritten code
17:16:01 <sclv_> static program analysis is a form of compiler too, no?
17:16:04 <Philippa> so you get some flavour of parametricity, big deal
17:16:19 <Philippa> sclv: abstract interpretation, if you're going to look at it that way
17:16:28 <Philippa> but abstract interpretation isn't a subset of interpretation
17:16:39 <Pseudonym> sclv: I think of a compiler (or, I guess, a compilation _phase_) as a combination of analysis and synthesis.
17:16:41 <sclv_> source-to-source is just compiling to source.
17:16:42 <Philippa> again, new semantics
17:16:54 <Saizan> nibro: but noone has a clue of why :)
17:16:57 <Philippa> sclv: so id is a compiler?
17:16:58 <Pseudonym> You analyse the program to gather whatever information about it you need, then use that information to generate object code.
17:17:01 <MyCatVerbs> Philippa: yeah, fine, but didn't I just say that source-to-source translation was a form of compilation? Are you busy telling me that it's not interpretation here, or did I get lost somewhere along the line?
17:17:01 <Cale> FunctorSalad: For specific domains a, there are such functions, but there's nothing which is completely polymorphic in a
17:17:26 <nibro> Saizan: that sounds promising
17:17:31 <Pseudonym> Even you only need to tokenise the input code, that's still analysis.
17:18:03 <Philippa> MyCatVerbs: "translation" is a bit of a stretch there
17:18:04 <Saizan> nibro: if you have any more details please tell
17:18:06 <MyCatVerbs> Philippa: also sure. id is the trivial compiler, mapping code in any given language to code in the same language with identical semantics.
17:18:23 * ddarius splits the world into static analysis and dynamic analysis.
17:18:32 * Botje joins them back together with arrows
17:18:43 * Philippa splits the world into split worlds and unsplit ones
17:18:43 <MyCatVerbs> Philippa: everything sane or useful in comp sci and maths has a trivial case that's still valid. Why should compilation be an exception?
17:19:01 <glen_quagmire> > let id s = s in id "int main() {printf("hi");}"
17:19:03 <lambdabot>   Not in scope: `hi'
17:19:09 <nibro> Saizan: no more details I'm afraid, one minute it worked and the next it didn't
17:19:11 <Cale> FunctorSalad: If you think about what such a map would have to do, it would have to produce an action which executed the entire range of the function (a -> m b) it was given (or, if you'll allow for partiality, part of it), and give a function which encoded the results of doing so.
17:19:12 * Pseudonym splits the word into 0 and 1
17:19:13 <MyCatVerbs> glen_quagmire: escape your doublequotes.
17:19:22 <nibro> Saizan: I can give you the exact error message if it helps
17:19:27 <Philippa> MyCatVerbs: you misunderstand the attack - you've got a half-baked level of formalism that doesn't actually cover all the informal understanding and will often make the informal crowd WTF
17:20:00 <Philippa> at this point, you may as well go the further step
17:20:09 <OceanSpray> lemme get this straight...
17:20:11 <FunctorSalad> Cale: ISTR that under some circumstances polymorphic functions are automatically natural transformations (in this case, natural in a and b)... the arbitrary choices we did in the examples certainly don't seem natural
17:20:27 <Saizan> nibro: yes thanks, and if cabal install starts working again or not
17:20:32 <OceanSpray> Capitalized identifiers are only defined at top level, and thus cannot be shadowed.
17:20:36 <Cale> FunctorSalad: right.
17:20:46 <Pseudonym> Oh, I've got a good example.
17:20:46 <OceanSpray> Is that how it is?
17:20:47 <MyCatVerbs> Philippa: so I've run head-first into the adage that "you can't proceed from the informal to the formal by formal means"?
17:20:49 <Pseudonym> PS -> PDF converters.
17:20:57 <Pseudonym> Both compiler and interpreter.
17:21:21 <Philippa> MyCatVerbs: That, and you started with a formalism we both know isn't perfect to start with!
17:21:24 <ddarius> Pseudonym: I imagine most compilers are both compiler and interpreter.
17:21:26 <MyCatVerbs> Philippa: okay the, so exactly how far would you go with this? How would you formalize it?
17:21:36 <nibro> any ideas where the module Text.RJson comes from?
17:21:47 <glen_quagmire> @where rjson
17:21:47 <lambdabot> I know nothing about rjson.
17:21:58 <Pseudonym> ddarius: In the sense that some analyses require abstract interpretation, constant folding or something like that.
17:21:59 <Cale> FunctorSalad: I've occasionally found it useful to define purify :: (Ord a) => (a -> m b) -> [a] -> m (a -> b)
17:22:03 <Philippa> I wouldn't go much further, but I'd talk about 'computational content'. Which I won't bother formalising at all, but the end result is much closer to "interpreters do what the program does"
17:22:06 <Pseudonym> But I wouldn't say "most".
17:22:14 <Pseudonym> Some compilers are very simple-minded.
17:22:19 <glen_quagmire> nibro: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/RJson-0.3.3
17:22:21 <Philippa> while not giving silly results in the case of pure functional languages
17:22:25 <lambdabot> http://tinyurl.com/yswrr4
17:22:46 <nibro> glen_quagmire: thanks a lot :)
17:22:48 <Philippa> going any further is a great way to keep philosophers busy
17:23:13 <Philippa> (oh, important point: I'm implicitly assuming that a language is a combination of syntax /and/ semantics)
17:23:24 <dmhouse> I just used Haskell to calculate the expected number of fingers drank during one round of a drinking game. I wonder whether that's what SPJ, Hughes et al had in mind when they designed the language.
17:23:52 <glen_quagmire> waht does drank mean?
17:24:07 <MyCatVerbs> dmhouse: no, but it's *exactly* what the people who implemented ghci were thinking of.
17:24:15 <Pseudonym> dmhouse: That, and so much more.
17:24:35 <dmhouse> glen_quagmire: as in, the number of penalties you incur.
17:24:51 <glen_quagmire> @wikipedia drinking game
17:24:52 <lambdabot> No Result Found.
17:25:31 <glen_quagmire> haskell was designed to create #haskell irc channel
17:25:32 <dmhouse> (Typically you'll drink one or two "finger's worth" of beverage, i.e. place that number of fingers on the side of the glass and drink that depth of liquid.)
17:25:46 <dmhouse> *fingers' worth
17:26:04 <Cale> Drank is the past tense of drink. Drunk is the past tense of that same verb when preceded by an auxiliary verb.
17:26:49 <MyCatVerbs> Cale: "drank" was the means. "Drunk" was the end.
17:26:52 <Cale> "I drank the juice", "I have drunk the juice"
17:26:52 <roconnor> Cale:  isn't Drunk the past particple?
17:27:31 <glen_quagmire> "did drink" is better style. did :: Verb -> Verb
17:27:57 <glen_quagmire> what is drunken ?
17:28:06 <jsnx> Cale: and what about "the number of fingers drunk" ?
17:28:07 <MyCatVerbs> glen_quagmire: shouldn't that be did :: Verb -> Past Verb ?
17:28:18 <dmhouse> glen_quagmire: a merry state of affairs?
17:28:31 <jsnx> glen_quagmire: verbal adjective
17:28:35 <dmhouse> "Drunken" would be an adjective as far as I can tell.
17:28:37 <MyCatVerbs> dmhouse: the end goal of an acceptable evening.
17:28:40 <glen_quagmire> data Verb = Verb Id | Past Verb
17:28:47 <ddarius> Once again, grammar incites noise on the #haskell IRC channel.
17:29:07 <dmhouse> Trust a discussion on grammar to stem from a conversation on drinking games.
17:29:14 <dmhouse> Only on IRC, ladies and gentlemen.
17:29:24 <MyCatVerbs> glen_quagmire: I just wanted to see a "Past" monad emerge from the conversation. :P
17:29:26 <jsnx> "have drunk" forms the "past perfect" (perfect meaning "completed" here)
17:29:46 <glen_quagmire> MyCatVerbs: oh that's better
17:30:25 <nibro> Saizan: here goes
17:30:26 <nibro> Unable to rename "C:\\Documents and Settings\\...\\i386-mingw32-6.8.2\\package.conf" to "C:\\Documents and Settings\\...\\i386-mingw-6.8.2\\package.conf.old"
17:30:26 <nibro> Saving old package config file... ghc-pkg.exe: C:\Documents and Settings\...\i386-mingw-6.8.2\package.conf: renameFile: permission denied (Permission denied)
17:30:26 <nibro> cabal.exe: Error: some packages failed to install:
17:31:04 <glen_quagmire> you might not have permission to write
17:31:20 <dmhouse> Yes, English has two forms of the perfect, with or without auxiliary. (E.g. ran, have run.) They probably have different names, but being a native speaker, I don't know much English grammar.
17:31:22 <nibro> glen_quagmire: but I've been installing packages there all night! :)
17:31:36 <nibro> glen_quagmire: and I can do it with runhaskell Setup, just not with cabal install
17:31:43 <MyCatVerbs> dmhouse: please can we never talk about linguistics, ever?
17:31:48 <glen_quagmire> is this vista nibro ?
17:32:00 <dmhouse> MyCatVerbs: :) but it's fun!
17:32:08 <nibro> glen_quagmire: nope, XP
17:32:15 <MyCatVerbs> dmhouse: I already escaped French and English and German and Welsh classes. I don't want this, of all sacred places, to turn into one.
17:32:29 <glen_quagmire> cabal.exe is cygwin or normal windows application?
17:32:30 <FunctorSalad> dmhouse: I think "ran" is called simple past, not perfect
17:32:31 <jsnx> :t liftM snd (\s -> if s == "s" then Just s else Nothing)
17:32:32 <lambdabot>     Couldn't match expected type `(a, b)'
17:32:32 <lambdabot>            against inferred type `Maybe [Char]'
17:32:32 <lambdabot>     In the expression: if s == "s" then Just s else Nothing
17:32:37 <MyCatVerbs> dmhouse: no, dammit, no. This is #haskell, not #un-translation-box
17:32:54 <jsnx> :t liftM snd (\s -> if s == "s" then (Just s, 1) else (Nothing, 2))
17:32:55 <lambdabot> forall b. (Num b) => [Char] -> b
17:33:00 <dmhouse> MyCatVerbs: you had to study Welsh? Are you Welsh? (Oh, and for someone who dislikes linguistics, you chose a poor nick ;))
17:33:14 <jsnx> :t fmap snd (\s -> if s == "s" then (Just s, 1) else (Nothing, 2))
17:33:15 <lambdabot> forall b. (Num b) => [Char] -> b
17:33:36 <shachaf> dmhouse: That's "my cat ${verb}s", for some verb.
17:33:40 <nibro> glen_quagmire: it's a normal Haskell app afaict
17:33:49 <shachaf> dmhouse: Not "verbs" as in "verbing weirds language".
17:33:56 <MyCatVerbs> dmhouse: yes, yes (fuck Plaid Cymri, also fuck Plaid fucking Cymri) and cats are more important, respectively.
17:34:09 <nibro> glen_quagmire: confirmed, it runs under plain old cmd as well
17:34:44 <glen_quagmire> nibro: i guess the cabal package tries to write file as different user than yourself
17:35:12 <MyCatVerbs> dmhouse: this is supposed to be a bastion of mathematical coherence in the midst of the raging storm of chaos that is human communication. Please don't pollute it with actual human communication. :(
17:35:38 <TomMD> @src iterate
17:35:38 <lambdabot> iterate f x =  x : iterate f (f x)
17:35:58 <jsnx> :t liftM snd (\s -> if s == "s" then (Just s, 1) else (Nothing, 2))
17:35:58 <lambdabot> forall b. (Num b) => [Char] -> b
17:36:05 <dmhouse> MyCatVerbs: I'm sure there's some irony in there somewhere.
17:36:08 <jsnx> the above line does not work in my GHCi
17:36:17 <shachaf> jsnx: :m + Control.Monad.Reader?
17:36:21 <jsnx> what do i do to lift things into Maybe?
17:36:27 <shachaf> jsnx: That's using the (r ->) monad.
17:36:31 <nibro> gah, all that trouble for nothing at all
17:36:32 <dmhouse> Control.Monad.Reader or Control.Monad.Instances.
17:36:39 <shachaf> jsnx: You probably want liftM snd . (\s -> ...)
17:36:50 <shachaf> jsnx: (Actually, you want fmap, not liftM.)
17:37:03 <nibro> Lemmih's happs-hsp depends on hinotify and rjson that both only run on linux :\
17:37:16 <jsnx> shachaf: they do the same thing, right?
17:37:17 <shachaf> Actually, that won't work either.
17:37:21 <shachaf> jsnx: What are you trying to do?
17:37:26 <MyCatVerbs> dmhouse: I'll leave that up to metallurgists to sort out.
17:37:37 <jsnx> liftM snd (\s -> if s == "s" then (Just s, 1) else (Nothing, 2))
17:37:42 <jsnx> > liftM snd (\s -> if s == "s" then (Just s, 1) else (Nothing, 2))
17:37:44 <lambdabot>  <[Char] -> Integer>
17:37:54 <dmhouse> MyCatVerbs: *rimshot*
17:37:56 <Philippa> MyCatVerbs: currently, we're one of the places where maths meets reality head-on. Sometimes that means trying to tackle the fuzzy messes, no?
17:37:58 <jsnx> > liftM snd (\s -> if s == "s" then (Just s, 1) else (Nothing, 2)) $ "s"
17:37:58 <lambdabot>  1
17:38:07 <shachaf> jsnx: liftM == (.) here.
17:38:23 <ddarius> fuzzy messes are fun to tackle
17:38:24 <shachaf> > snd . (\s -> if s == "s" then (Just s, 1) else (Nothing, 2))
17:38:25 <lambdabot>  <[Char] -> Integer>
17:38:46 <jsnx> what the heck?
17:38:48 <Philippa> I should note that the fact I'm currently dating a linguist does not influence me in any way here whatsoever :-)
17:39:21 <jsnx> oh, that's why you leapt to his defense on LtU
17:39:24 <MyCatVerbs> Philippa: but could we please be careful to stay away from questions like "what is truth?" As in, bargepole distance, and then some.
17:40:01 <jsnx> shachaf: why does (.) do that?
17:40:03 <Philippa> MyCatVerbs: the correct answer for #haskell is generally either a formal definition within a given system or "damned if I care"...
17:40:08 <Cale> So guys, what is truth?
17:40:17 <Cale> ;)
17:40:21 <shachaf> jsnx: What do you expect it to do?
17:40:37 <shachaf> @ty (\s -> if s == "s" then (Just s, 1) else (Nothing, 2))
17:40:38 <Philippa> but you can get a lot of approaches to building systems out of playing with the options and building different formalisms from them
17:40:41 <lambdabot> forall t. (Num t) => [Char] -> (Maybe [Char], t)
17:40:44 <nibro> oh well, time to call it a day, thanks for all the help guys :-)
17:40:46 <ddarius> Cale: A terminal object in a poset category.
17:40:48 <Philippa> cf intuitionistic vs classical logic
17:40:58 <MyCatVerbs> Cale: it's the result when evaluating the proposition "forall m where m is male, has m slept with Cale's entire female ancestral line for the previous fourty generations?" </grumpy>
17:41:01 <twanvl> > True -- <---- truth
17:41:02 <jsnx> fail -- tried to apply a (a, b) -> b to a Maybe something
17:41:02 <lambdabot>  True
17:41:09 <FunctorSalad> ddarius: I thought it was a map from the terminal object into the subobject classifier.
17:41:15 <Philippa> jsnx: the linguist I'm dating's female, btw
17:41:21 <jsnx> oh, oops
17:41:25 <FunctorSalad> (or actually, it's part of the definition of that subobject classifier)
17:41:32 <jsnx> i just assumed with such a short name it must be a man
17:41:43 <jsnx> i'm happy to drop the assumption, though
17:42:04 <jsnx> oops
17:42:09 <FunctorSalad> ddarius: ah, you mean the cat of propositions ordered by implication
17:42:27 <FunctorSalad> propositional cat has run out of propositions
17:42:35 <jsnx> > liftM snd (\s -> if s == "s" then Just (s, 1) else Nothing ) $ "s"
17:42:36 <lambdabot>  Couldn't match expected type `(a, b)'
17:42:47 <MyCatVerbs> Philippa: I may be (and it's probably alarmingly hypocritical on my part if I am) allergic to formalisms that I can't simulate or work out how to accomplish anything with.
17:42:49 <jsnx> that's what i meant
17:43:40 <Philippa> MyCatVerbs: I definitely don't get on well with them, but in the first instance I tend to assume that's my failing rather than theirs. I really ought to play with a sugared pi calculus sometime, for example
17:43:46 <shachaf> jsnx: Why should that work?
17:43:52 <MyCatVerbs> Philippa: formalism for formalism's sake merely irritates me.
17:43:55 <shachaf> jsnx: It's still in the (r ->) monad.
17:43:58 <Philippa> (sugared to the extent of having something like datatypes, but not to the point of embedding the lambda calculus!)
17:43:59 <ddarius> Philippa: Yes you should.
17:44:11 <shachaf> > fmap snd . (\s -> if s == "s" then Just (s, 1) else Nothing) $ "s"
17:44:11 <lambdabot>  Just 1
17:44:12 <jsnx> shachaf: well, how do i get it into the maybe monad and lift?
17:44:14 <shachaf> > fmap snd . (\s -> if s == "s" then Just (s, 1) else Nothing) $ "sa"
17:44:14 <lambdabot>  Nothing
17:44:36 <jsnx> shachaf: so fmap then
17:44:47 <shachaf> jsnx: liftM would work too.
17:44:52 <MyCatVerbs> Philippa: yeah, same. Then I just get mopey and depressed and just pretend they don't exist so that I won't have to care about my inability to make heads or tales of them. Except that I'll *still* worry about it. :P
17:44:53 <shachaf> > liftM snd . (\s -> if s == "s" then Just (s, 1) else Nothing) $ "s"
17:44:54 <lambdabot>  Just 1
17:44:59 <jsnx> oh, yikes
17:45:03 <jsnx> i missed the compose
17:45:10 <EvilTerran> ... we suggested that some time ago
17:45:45 <jsnx> EvilTerran: eh?
17:46:01 <jsnx> some time ago, i had wrong thing
17:46:23 <glen_quagmire> data Foo a = A ==> a    hah didn't know this
17:47:12 <EvilTerran> jsnx, ":36] <shachaf> jsnx: You probably want liftM snd . (\s -> ...)"
17:47:28 <jsnx> EvilTerran: oic
17:47:34 <jsnx> i'm sorry, i guess
17:52:42 <byorgey> glen_quagmire: hmm, I think you need a : at the beginning of infix data constructors
17:52:58 <byorgey> so that would have to be  data Foo a = A :==> a  or something like that
17:54:35 <dbueno> I think there's a bug in the Data.Graph.Inductive.Dominators.dom function, but I'd like confirmation.  I sent mail to ghc-users 4 days ago, but no one has replied; should I try another mailing list?
17:55:05 <Philippa> dbueno: try haskell-cafe for max distribution?
17:55:50 <dbueno> Philippa: I initially was going to, but, it is a built-in GHC library so.... In any case, it's probably appropriate now.
17:56:23 <Philippa> dbueno: it's not just GHC it ships with, those libs're at least nominally shared between several implementations
17:56:42 <ddarius> dbueno: There are very few "built-in GHC libraries"
17:56:43 <dbueno> Philippa: Oh, I didn't know that.
17:57:09 <dbueno> ddarius: I have no experience with other Haskells --- I'll keep that in mind.
17:58:27 <byorgey> dbueno: the most appropriate list, if you're worried about appropriateness, would be libraries@haskell.org.  But I agree that haskell-cafe@ would be more likely to get a response, and would also be appropriate. =)
18:00:11 <dbueno> byorgey: It makes me feel better knowing the libraries are shared.
18:00:38 <byorgey> dbueno: ok, right =)
18:00:59 <ddarius> dbueno: I don't know if they still do, but there was a time when Hugs, NHC and GHC all shared the same CVS repository.
18:01:15 <dbueno> byorgey: However, I hadn't recalled the existence of the libraries@ mailing list; so thanks for reminding me.
18:02:07 <dbueno> ddarius: Library repo, or compiler repo?
18:02:13 <ddarius> Both.
18:10:27 <halberd> sql is a powerful tool for its problem domain, how come features from sql like join and indexing aren't incorporated directly into other programming languages?
18:10:41 <Pseudonym> G'day kryptos23.  CAN YOU SEE ANYTHING Q?
18:11:28 <clanehin> halberd: there was a SPJ paper, iirc, about adding sql-like semantics to list comprehensions.
18:11:40 <halberd> select is basically a filter, except that it can be indexed to work faster
18:11:51 <glen_quagmire> byorgey: oops yes. :==>
18:12:10 <halberd> i've never seen a function like join in a conventional programming language
18:12:10 <kryptos23> hi Pseudonym : what?
18:12:18 <clanehin> halberd: http://research.microsoft.com/users/simonpj/papers/list-comp/index.htm
18:12:19 <lambdabot> Title: Comprehensive Comprehensions, http://tinyurl.com/5l53l9
18:12:20 <thoughtpolice> clanehin: comprehensive comprehensions have been added to GHC 6.10
18:12:26 <Pseudonym> Oh, I thought your nick was a reference to the sculpture at Langley.
18:12:43 <halberd> and i've never seen anything like grouping in a conventional programming language
18:12:56 <halberd> at least, not built right into the language
18:13:07 <clanehin> halberd: sql tables are rather complicated data structures, usually if you want to use them, it's worth your while to set up an actual database
18:13:12 <byorgey> halberd: grouping and sortby are now built into GHC 6.10, apparently =)
18:13:32 <halberd> ok
18:13:45 <Pseudonym> @go kryptos
18:13:46 <lambdabot> http://en.wikipedia.org/wiki/Kryptos
18:13:48 <Pseudonym> That.
18:14:00 <halberd> well what makes them complicated clanehin, they are complicated on the inside but not from the outside
18:14:23 <byorgey> halberd: it's a good question though. there's a good deal of cross-fertilization between FP and database research.
18:14:42 <ddarius> SQL is just a special case of logic programming.
18:14:57 <halberd> everything is a special case of logic programming
18:15:01 <byorgey> halberd: read that paper that clanehin linked to, I think you will find it interesting =)
18:15:12 <Pseudonym> Type checking is a special case of logic programming.
18:15:57 <sclv_> there are also similar constructs with LINQ
18:16:27 <clanehin> halberd: to get good performance and scalability, takes an enormous amount of work, easier to build bindings to an sql server than make an implementation for each language
18:18:21 <halberd> a sql server actually takes commands in the form of text, doesn't it?
18:18:32 <SamB> halberd: implementation detail
18:18:43 <SamB> maybe it does; maybe it doesn't
18:18:50 <halberd> in practice
18:19:18 <clanehin> well sql is the language, I think, so it would have to be plaintext, unless I'm confused
18:19:19 <SamB> anyway, modern ones have mechanisms to keep this safe & performant
18:19:27 * ddarius can't wait for "comprehensive comprehensions" to die.
18:19:42 <SamB> well, there could be a client library that parsed the SQL commands
18:20:01 <Saizan> you can have preprocessed queries
18:20:03 <SamB> or even accept ASTs directly
18:20:27 <halberd> so using an external SQL server to store data for your program would be slower than storing the data directly from your program
18:20:28 <SamB> and yes, you can have precompiled SQL expressions with "holes" in them...
18:20:48 <halberd> because the SQL server must parse text before it can execute your command
18:21:01 <SamB> halberd: you are thinking too linearly
18:21:25 <clanehin> halberd is correct, I think, but more by definition of "SQL" than any technical requirement on what a database server can do.
18:21:47 <SamB> how so?
18:21:48 <jeffz> halberd: what about the case of sqlite, there is no server.
18:21:52 <halberd> but if you had an implementation of SQL for your own programming language, no parsing would be done at runtime and it would be comparable in efficiency for certain tasks to a hash map or array
18:21:56 <SamB> SQL doesn't dictate client/server interfaces
18:22:27 <SamB> and I fail to see how having the implementation in your own programming language helps any of that
18:22:36 <halberd> so that you could use databases instead of hashes or arrays, and it would be almost as efficient as using actual hashes or arrays, plus you have the expressive bonus of sql queries
18:22:38 <clanehin> SamB: Standard Query Language, it /is/ a client/server protocol, unless I'm very confused.
18:22:42 <Saizan> you can imagine an SQL query to be "compiled" and run multiple times, and indeed this happens already
18:23:04 <SamB> and considering how abysmal Data.HashTable's performance is, "comparable" isn't exactly a compliment ;-)
18:23:19 <SamB> clanehin: I think you are very confused
18:23:29 <SamB> clanehin: I have never seen an RFC for such a thing
18:23:43 <SamB> or even an RFC number
18:23:53 <ddarius> clanehin: SQL stands for "Structured Query Language"
18:24:07 <jcreigh> clanehin: AFAIK, there's no wire protocol, just a definition for the language
18:24:12 <clanehin> oh yeah, I'm very confused.
18:24:33 <SamB> I bet halberd is more confused ;-)
18:24:58 <SamB> halberd: what does the language in which the SQL implementation is written have to do with anything at all?
18:25:01 <clanehin> Despite dropping some confusion, is it not by definition a /language/?
18:25:15 <SamB> clanehin: ah, but what is a language?
18:25:37 <halberd> if you incorporate the SQL implementation into the compiler for the language you can optimize it in ways that you couldn't do otherwise
18:25:48 <SamB> halberd: name just one
18:26:30 <SamB> and anyway, if you incorporate the SQL implementation in the compiler for the language, doesn't that mean that the compiler hackers suddenly need to be competent at DBMS programming?
18:26:41 <halberd> for example if the compiler determines that you only ever use a particular SQL table as if it were a hash table, it could replace the table with an actual hash table
18:27:00 <SamB> halberd: I don't see how
18:27:12 <halberd> through static program analysis
18:27:25 <jcreigh> does that mean "magic"?
18:27:26 <SamB> this seems highly unlikely to actually happen
18:27:42 <SamB> would you care to implement this?
18:28:17 <clanehin> I have been in the habit for some time of thinking of SQL as the particular language that describes what to do to the database, so an SQL database is really just a database whos server accepts directives in SQL.  It could use some other language, too.
18:28:20 <halberd> using a table as if it were a hash table means that you only ever make statements like "select something from table where col1 = somevalue"
18:28:49 <halberd> that is possible to determine by analysing all of the instances where table is used and seeing if they are of that form
18:28:56 <SamB> clanehin: SQL is not limited to mere textuality
18:29:24 <SamB> halberd: don't you usually store the database on disk somewhere?
18:29:38 <SamB> halberd: in any case, can you implement this?
18:29:51 <SamB> or do you know of a system that does?
18:30:00 <fnoble> SamB: what is SQL beyond just the textuality?
18:30:04 <halberd> no, I have been talking about using database tables as simply an in-memory data structure like an array or hash map
18:30:11 <SamB> fnoble: abstract syntax trees
18:30:49 <SamB> halberd: why would you do that if you could just use Data.Map for what you were doing?
18:31:23 <halberd> because if you are using a table as your data structure you can perform other SQL operations on the table if it turns out you want them
18:31:34 <fnoble> but SQL specifies the specific language you must use, so you could parse it into an AST but it itself is just the language
18:31:53 <SamB> halberd: wouldn't you then just CHANGE your table? you'd clearly need to change much anyway...
18:32:01 <halberd> i.e. if it turns out you were wrong about "only" needing a hash map and want to do something slightly more involved, like a join
18:32:06 <ddarius> Philippa's future corpse rolls over in her grave.
18:32:16 <SamB> ddarius: hmm?
18:32:35 <halberd> no, performing a join on a database table doesn't require that you change the table
18:32:41 <SamB> halberd: and why do you keep talking about hashes?
18:33:25 <clanehin> SamB: I thought you were talking about some kind of binary protocol.
18:33:36 <ddarius> [19:23] <Philippa> (oh, important point: I'm implicitly assuming that a language is a combination of syntax /and/ semantics)
18:33:39 * vincenz eats cookies and watches
18:33:47 <halberd> you can use a database table as if it were a hash
18:33:54 <halberd> that's the purpose of creating indexes
18:33:59 <halberd> to use the table as a hash
18:34:09 * vincenz passes some popcorn to byorgey 
18:34:22 <vincenz> kfish: nice blogpost
18:34:42 <kfish> vincenz, cheers :-)
18:35:07 <SamB> clanehin: well, SQL doesn't specify an interaction model
18:35:13 <SamB> clanehin: there need be no protocol
18:36:44 <clanehin> SamB: Perhaps I err to do this, but I use protocol very loosely to mean any model of interactive, machine to machine communication
18:36:48 <vincenz> kfish: I really liked the sprintf paper
18:36:55 <SamB> also, the SQL standard is not particularly useful, in itself -- it's more usefull as a starting design or a thing to explain your implementation in terms of
18:36:57 <vincenz> kfish: the kahua slides were completely incomprehensible, however :|
18:37:03 <vincenz> kfish: at least, without explanation
18:37:21 <SamB> clanehin: well, for instance, sqlite is entirely in-process ...
18:37:45 <vincenz> children, children
18:37:57 <SamB> and other SQL implementations might have APIs that accept textual commands, but translate these into a binary protocol before sending them to the server...
18:38:17 <SamB> and most implementations have ways to create a sort of "query template"
18:38:22 <sclv_> which blogpost?
18:38:59 <halberd> let me be succinct:  if you implemented database tables as an in-memory data structure, you could use it in place of things such as arrays and hashes, with comparable speed to those especially if you can perform some language optimizations, and you get the additional advantage of being able to perform more complex operations on your data, if you need it or even if you just might possibly need to do it in the future
18:39:05 * sclv_ checks planet.haskell.org
18:39:22 <chessguy> uh. that was succinct?
18:39:42 <halberd> for large values of succinct
18:39:46 <chessguy> :)
18:39:49 <sclv_> halberd: how do you think database tables are implemented to begin with?
18:39:52 <kfish> sclv, about the continuation fest
18:39:57 <SamB> where you give the implementation a query with holes in it, and then give it things to put in those holes later on (usually many times)
18:39:58 <sclv_> right -- i see now.
18:40:36 <SamB> halberd: well, usually database tables are not the clearest way to express things...
18:40:44 <vincenz> kfish: then again, I'm a bit of a continuation-lover, especially delimited ones :)
18:41:00 <SamB> if they are, you might as well just use a real DBMS...
18:41:03 <dolio> delimited are better than undelimited. :)
18:41:09 <kfish> vincenz, heh :-)
18:41:14 <chessguy> SamB!
18:41:18 <vincenz> dolio: undelimiited are ill-formed imho
18:41:22 <SamB> chessguy: what?
18:41:29 <chessguy> SamB, hi!
18:41:36 <SamB> chessguy: why the !?
18:41:36 <chessguy> been a while
18:41:38 * vincenz watches the two lovebirds unite
18:41:46 <dolio> vincenz: Could be because we're all too functionally minded. :)
18:41:57 <SamB> oh, I haven't been active much during the daytime lately ...
18:42:01 <kfish> oleg was right that everyone already understands (delimited) continuations, especially when he talked about checkpoint/restore rather than reset/shift
18:42:03 * chessguy drops some bird droppings on vincenz' head
18:42:18 * vincenz pops another popcorn into his mouoth as he watches #haskell amusedly
18:42:35 <chessguy> "another popcorn" is that even grammatically correct?
18:42:37 <vincenz> kfish: my issue with call/cc is that you can always just place an implict reset point at the very top
18:42:41 <vincenz> chessguy: Does it matter?
18:42:49 <chessguy> nah
18:42:51 <dolio> vincenz: I have a thesis of some sort that goes into a continuation calculus, where everything (including functions) are reduced to continuations (which are primitive, more or less).
18:42:55 <halberd> the thing that got me thinking about this is the statement that inner joins are a generalization of following pointers
18:43:00 <SamB> vincenz: you can what?
18:43:04 <chessguy> my hobby: pretending to be a grammar nazi
18:43:06 <ddarius> call/cc is ugly
18:43:19 <SamB> ddarius: indeed
18:43:24 <vincenz> dolio `ap` #oasis
18:43:31 <SamB> it makes my brain explode when I try to figure out what it can mean
18:43:53 <SamB> since I get confused about what the continuations can consist of, in a shared mutable state context...
18:43:57 <solrize> @src on
18:43:57 <lambdabot> (*) `on` f = \x y -> f x * f y
18:44:08 <kfish> the talk about callcc in ruby (at the continuation fest) was funny -- it was by the guy who implemented it, and it was a long rant about why not to use it
18:44:08 <solrize> @hoogle on
18:44:09 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
18:44:09 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
18:44:09 <lambdabot> Data.Function :: module
18:44:36 <SamB> kfish: sweet
18:44:43 <solrize> scheme has had it forever
18:44:53 <jcreigh> kfish: almost nobody uses callcc in Ruby anyway.
18:45:16 <ddarius> solrize: Continuations aren't ugly, just call/cc is not the best primitive.
18:45:20 <SamB> kfish: what were some of the reasons?
18:45:41 <SamB> I don't think I can understand undelimited continuations
18:46:04 <snhmib> it's not possible to make a class and then 2 (or more) instances of that class and then make a list that has things of both instances right?
18:46:18 <SamB> I can only understand them if you implement them in either something high-level like  Haskell or something low-level like C ;-)
18:46:32 <kfish> SamB, yeah, basically that no-one uses them (in ruby) and they confuse people, and ruby has higher-level stuff for what most people actually want to do
18:46:41 <hpaste>  snhmib pasted "thingie" at http://hpaste.org/6998
18:46:46 <snhmib> uhm like this ^
18:47:11 <ddarius> SamB: Continuations make assembly boring.
18:47:33 <SamB> ddarius: that's okay
18:47:37 <SamB> most assembly is boring anyway
18:48:06 <ddarius> SamB: By "assembly", I meant assembly language, not assembly code.
18:48:11 <SamB> oh
18:48:15 <SamB> what do you mean?
18:48:41 <vincenz> call/cc in assembly == goto
18:49:02 <ddarius> SamB: The fun and cool part about assembly is the crazy control effects that you can get via stack manipulation and such, but CPS allows you to do the same thing at a higher level.
18:49:05 <Saizan> snhmib: not like that, you can do it with existentials, like data Any = forall a. AClass a => Any a, mapM someFunc [ Any $ This "or", Any $ That "thingie" ]
18:49:32 <ski> vincenz : rather the call of a continuation is more comparable with a jump
18:49:41 <snhmib> o_O
18:49:42 <SamB> ddarius: well, that's what I meant about low-level languages...
18:49:44 <Saizan> snhmib: but it's not something i would reccomend if you're just starting using haskell
18:49:45 <erg0t> vincenz: there is the concepto of procedure too, in x86 you have call and ret, and some instrucion like enter and leave to create/destroy a stack frame
18:49:46 <ddarius> An "Assembly for Haskell Programmers" is something that is in my list of ideas.
18:50:26 <ddarius> erg0t: Unless you are optimizing for code size, no one really uses enter and leave.
18:50:28 <SamB> vincenz: in C, we have setjmp/longjmp
18:50:34 <erg0t> I know
18:50:42 <erg0t> push ebp mov ebp, esp
18:50:44 <erg0t> enter is slow
18:50:56 <vincenz> erg0t: erm, I know
18:51:08 <kfish> SamB, and getcontext(), setcontext()
18:51:11 <SamB> Borland Turbo Pascal maybe uses enter and leave
18:51:49 <snhmib> Saizan: i suppose so... i have enough problems with the haskell i already know without adding more funky stuff =)
18:51:57 <jcreigh> CPU instructions designed for direct human use are weird.
18:52:25 <halberd> Here's something:  people use joins and groups when they are dealing with databases, but apparently they haven't found much call for it when working with data other than databases
18:52:30 <halberd> why would that be?
18:53:09 <halberd> is that due to an inherent quality of data other than the kind of data stored in databases, or are people just not using those functions because they aren't available for non-database data?
18:53:16 <snhmib> because they call it different when it's not a database
18:53:22 <SamB> halberd: combination
18:53:33 <halberd> what quality would that be then
18:53:34 <SamB> but what does that have to do with where the data resides?
18:53:36 <ddarius> > group "hello"
18:53:37 <lambdabot>  ["h","e","ll","o"]
18:53:50 <halberd> that's an optimization concern
18:56:10 <halberd> i mean it answers the question of why people don't just put their program in a database table, use the database joins or groups to process it, then drop the table when they're done--because that would be slow and kludgy
18:56:37 <halberd> s/program/data/
18:57:05 <clanehin> halberd: because usually in a programming language, even haskell, you use a little more micromangement in how exactly the join/group is done, and so it's done as several connected function calls, as opposed to, "hey go join these", and nothing ends up being named "join" in the code, nor is there a generic join that works for every data structure you might explicitly choose
18:57:33 <SamB> but see also http://haskell.org/haskellwiki/Libraries_and_tools/Database_interfaces/HaskellDB
18:57:33 <lambdabot> http://tinyurl.com/6jvrol
19:00:23 * SamB wishes someone would get the GHC head to stop segfaulting
19:03:57 <halberd> actually, there is one place I know where sql syntax is used to process in-memory program data, namely in SAS, although you could say that SAS is not normally "general purpose"
19:05:18 <solrize> so there are two haskell json parsers linked from json.org, quite a bit different from each other despite coming from the same origin.  any idea which one to use?
19:05:33 <solrize> http://www.tom.sfc.keio.ac.jp/%7Esakai/d/data/200604/JSON.hs  ;  http://darcs.haskell.org/SoC/haskellnet/Text/JSON.hs
19:06:03 * qwr would take the last one...
19:06:13 <solrize> ok thanks
19:09:28 <solrize> i had to download a couple other modules for that, how do i tell ghc where to find them?  i think i did this before, but forgot
19:10:07 <SamB> er... canibalism?
19:11:36 <Cale> You can put them in the same directory as the program you're writing, named after their module path (or in subdirectories which correspond to the module path)
19:12:13 <Cale> For instance, if the module is Foo.Bar.Baz, you can name it Foo.Bar.Baz.hs, or Foo/Bar/Baz.hs
19:12:27 <solrize> aha, i needed -i.
19:12:29 <solrize> thanks
19:12:39 <Cale> Or if the module is a cabal package, you can just install it properly :)
19:12:41 <solrize> and i needed --make
19:12:46 <solrize> i don't think it's cabal
19:12:52 <solrize> it's just dribble off the net
19:12:58 <solrize> and it uses this parser package
19:13:20 <solrize> i can't help thinking that it would run a lot faster with data.binary or something like that
19:14:20 <solrize> how can i tell if it's cabal?  is it hard to cabalize something?
19:14:36 <Saizan> solrize: it comes with a .cabal files
19:14:48 <Saizan> and no, it's not hard, especially if it's pure haskell code
19:14:55 <solrize> nope, no cabal file, it didn't even include the parser lib it depended on, i had to find that with google
19:15:08 <solrize> json is a pretty important protocol and the python module i'm using is a C extension
19:15:23 <solrize> so it seems worth having one for haskell that's written for speed
19:15:38 <bos> what makes you think a pure haskell version wouldn't be fast?
19:15:56 <mrd> json is just javascript syntax
19:16:09 <ddarius> mrd: json is less than javascript syntax
19:16:22 <mrd> ya, even easier
19:16:25 <solrize> bos i think a pure haskell version can be fast but i don't have the sense that this -particular- pure haskell version is fast
19:16:36 <solrize> but if i can get it working, i'll see in a minute :)
19:16:37 <bos> you can easily write a fast-enough json parser in about 40 lines of code.
19:16:57 <solrize> i just snarfed this one from a url that i found at json.org
19:17:16 <bos> the book i'm working on includes json parser and pretty printer examples.
19:17:18 <Saizan> there's RJson on hackage, but it's more than just a parser
19:18:27 <solrize> oh i didn't know about that.  maybe i should use it.
19:19:43 <sclv_> rjson lets you serialize both ways with json
19:20:07 <solrize> oh i didn't even notice whether this other lib can dump json instead of just parsing it
19:20:12 <solrize> and i'm going to need that
19:20:18 <solrize> i'm trying to switch this python app from xml to json
19:20:30 <solrize> and code a bunch of the intermediate steps in haskell
19:20:42 <solrize> in the hope that it will run faster
19:21:13 <sclv_> i think they all let you output json back out... but rJson lets you serialize both ways most structures deriving Data, using syb generics.
19:21:33 <sclv_> its pretty cool, but generics are a tad slow. not slow at all compared to a dynamic language of course. :-)
19:21:41 <solrize> s$ runhaskell rj.hs
19:21:41 <solrize> <interactive>: internal error: loadObj: can't map `Text/Packrat/Parse.o'
19:21:41 <solrize>     (GHC version 6.8.2 for i386_unknown_linux)
19:21:41 <solrize>     Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
19:21:48 <lambdabot> Title: ReportABug - GHC - Trac
19:22:21 <solrize> hmm i deleted the .o files and it works now
19:22:23 <vincenz> :t lift
19:22:25 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
19:25:44 <SamB> [-3: E/FromHs.hs:(393,12)-(400,8)] *Main> :show bindings
19:25:44 <SamB> *** Exception: ghci/RtClosureInspect.hs:675:24-39: Irrefutable pattern failed for pattern (t : tt)
19:25:51 <SamB> isn't it lovely ;-) ?
19:26:00 <Beelsebob> @check let wordReverse = unwords . map reverse . words in \x -> (wordReverse (wordReverse x)) = x
19:26:00 <lambdabot>  Parse error at "=" (column 88)
19:26:08 <Beelsebob> @check let wordReverse = unwords . map reverse . words in \x -> (wordReverse (wordReverse x)) == x
19:26:14 <lambdabot>  Falsifiable, after 466 tests: "\960262\1098728\191779\237486\8199\138687\811...
19:26:19 <Beelsebob> interesting
19:28:17 <ddarius> Beelsebob: words is not injective so that can't possibly hold
19:28:26 <Beelsebob> ddarius: I know
19:28:46 <Beelsebob> it was mostly a demonstration to someone that quickcheck was actually useful
19:28:59 <SamB> @check \s -> unwords (words s) == s
19:28:59 <lambdabot>  OK, passed 500 tests.
19:29:04 <Beelsebob> so the fact that it found a bug in a nave implementation is actually quite a good thing :)
19:29:16 <SamB> @check (\s -> unwords (words s) == s)
19:29:17 <lambdabot>  OK, passed 500 tests.
19:29:30 <Beelsebob> SamB: probably want a data generator that generates strings with lots of different kinds of spaces in
19:29:36 <ddarius> @check liftM2 (unwords . words) id
19:29:36 <lambdabot>  Couldn't match expected type `a2 -> r'
19:29:40 <ddarius> @check liftM2 (==) (unwords . words) id
19:29:41 <lambdabot>  OK, passed 500 tests.
19:30:17 <SamB> @check \s -> any (==' ') s ==> unwords (words s) == s
19:30:18 <lambdabot>  Arguments exhausted after 0 tests.
19:30:23 <SamB> @scheck \s -> any (==' ') s ==> unwords (words s) == s
19:30:24 <lambdabot> Done.
19:30:25 <dolio> @check (\s -> all (not . isSpace) s)
19:30:26 <lambdabot>  OK, passed 500 tests.
19:30:31 <ehird> scheck?
19:30:37 <SamB> @lcheck \s -> any (==' ') s ==> unwords (words s) == s
19:30:37 <lambdabot> Maybe you meant: check scheck
19:30:46 <Beelsebob> is scheck strict check?
19:30:49 <SamB> ehird: uses SmallCheck
19:30:53 <Beelsebob> oh, okay
19:31:04 <Beelsebob> strictcheck would be an interesting thing to have in lbot
19:31:18 <SamB> what is strictcheck?
19:31:25 <SamB> I've heard of lazy smallcheck...
19:31:35 <ddarius> @where strictcheck
19:31:35 <lambdabot> I know nothing about strictcheck.
19:31:38 <Beelsebob> it's a tool olaf chitil wrote for finding out if your functions are as non-strict as they can be
19:32:12 <Beelsebob> so for example it will tell you that && is too strict because it shouldn't be strict in it's first argument
19:32:21 <Beelsebob> (the fact that this is impossible to write in Haskell is beside the point)
19:32:30 <ehird> Beelsebob: haha
19:32:33 <ehird> truly lazy functions
19:32:57 <ddarius> Beelsebob: A little concurrency and unsafePerformIO.
19:33:00 <SamB> wow. output from :print that doesn't fit in screen's scrollback buffer...
19:33:07 <ehird> @check id
19:33:07 <lambdabot>  Arguments exhausted after 0 tests.
19:33:12 <ehird> @check \x -> x
19:33:12 <lambdabot>  Arguments exhausted after 0 tests.
19:33:17 <ehird> should that not check True,False?
19:33:19 <ehird> @check \x -> not x
19:33:20 <lambdabot>  Falsifiable, after 1 tests: True
19:33:25 <ehird> @check \x -> not (not x)
19:33:25 <lambdabot>  Falsifiable, after 4 tests: False
19:33:27 <Beelsebob> ddarius: but concurrancy isn't available in standard haskell unless I'm mistaken?
19:33:36 <ddarius> Beelsebob: No it isn't.
19:33:46 <ehird> @check \x -> length (replicate undefined x) == x
19:33:46 <lambdabot>  Undefined
19:33:51 <ehird> @check \x -> length (replicate () x) == x
19:33:52 <lambdabot>  Couldn't match expected type `Int' against inferred type `()'
19:34:02 <ehird> @check \x -> length (replicate x ()) == x
19:34:03 <lambdabot>  Falsifiable, after 3 tests: -1
19:34:06 <ehird> Aha.
19:34:10 <ehird> Tricksy.
19:34:24 <Beelsebob> but it has proved useful in my work... it's managed to find a function that was too strict when I was relying on lazyness and not getting output
19:35:54 <solrize> ok this json module seems to read at least as fast as the python one, or anyway fast enough for my purposes.
19:37:18 <ehird> solrize: as fast as PYTHON?! wowzers
19:37:36 <solrize> ehird, as fast as the python simplejson module, which is actually written in C
19:37:45 <solrize> but probably spends a heck of a lot of its time in the python storage allocator
19:38:16 <solrize> i haven't been using bytestring much yet, but the vanilla haskell i/o actually is slower than python a lot of the time
19:38:22 <solrize> and data.map is slower than python dictionaries
19:38:49 <solrize> ghc compiles pure computational code a heck of a lot better though, that's for sure
19:43:49 <solrize> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/RJson-0.3.3 oh man this sounds scary
19:43:56 <lambdabot> http://tinyurl.com/yswrr4
19:44:36 <ehird> solrize: why
19:44:45 <sclv_> the interface is very simple tho -- the cool scary stuff should theoretically be well hidden.
19:45:44 <solrize> 1. depends on a bunch of external packages; 2. uses scary stuff (SYB); 3. blurb page warns that it hasn't been performance tested and might be slow (likely translation: IS slow)
19:46:03 <sclv_> slow relative to what tho is the question.
19:46:23 <solrize> slow relative to carefully coded asm?
19:46:45 <solrize> i mean, intel has added new machine instructions to SSE4.2 to make this stuff run fast, so it's a significant cpu load for a lot of applications
19:46:45 <sclv_> outside of iconv the dependencies are totally sane too.
19:46:57 <bos> Data.Map isn't noticeably slower than a python dict.
19:47:22 <solrize> more seriously, if it's as fast as the other package i guess it's ok for what i'm doing at the moment
19:47:49 <solrize> bos i remember doing a simple word counting test and data.map was like 10x slower, then dons optimized it til it was only 2x slower or something like that
19:48:04 <sclv_> that was a laziness issue, no?
19:48:06 <sclv_> or was it bytestrings?
19:48:12 <solrize> bytestrings
19:48:12 <lament> some article linked from reddit made a very good point about optimizing haskell
19:48:29 <lament> - only dons can do it :)
19:48:43 <Twey> Hahaha
19:48:48 <solrize> lament, yeah, it was like what cale said about unsafecoerce -- "don't use it unless your first name is simon"
19:48:55 <sclv_> bytestrings can actually be stored in a variant of an IntMap -- I hope those hayoo guys split that library soon.
19:49:13 <sclv_> (and then they should *blaze*)
19:50:29 <lament> (the article actually said that while the compiler can do pretty good optimizations, because of the complex nature of the optimizations normal programmers don't know how to adjust the program to get the optimizations to apply. Which is for the most part untrue, I suppose)
19:50:29 <solrize> sclv_ yeah, actually i'm not sure data.map itself was the cause of the slowness, it was mostly about generating a lot of very short bytestrings.  and dons fixed it by adding some rewrite rules to the compiler.  my memory is hazy.
19:51:09 <ddarius> lament: Usually the optimizations are designed to apply to idiomatic code.
19:52:22 <solrize> oh ok, this module does have a serializer so i think i will use it and i am set
19:52:47 <lament> ddarius: that's oversimplifying a bit. And seq is the very opposite of idiomatic.
19:55:34 <schme> Hello #haskell. I'm all new to haskell as of yesterday and I was wondering if there are any good books you would recommend?
19:56:27 <lament> schme: try YAHT, ask here when anything is unclear, and ask here again when it starts talking about monads.
19:56:42 <dolio> You know scheme?
19:56:46 <schme> Great. I'll google.
19:57:07 <schme> I know a bit of scheme sure. I'm more of a CL person though.
19:57:40 <solrize> http://lisperati.com/landoflisp/   :)
19:57:44 <schme> lament: YAHT the wikibook you mean?
19:57:45 <dolio> Ah, well, if you consider yourself to already have some functional programming background, you might be able to handle the Gentle Introduction.
19:57:56 <lament> schme: the pdf
19:58:01 <lament> don't know about the wikibook
19:58:07 <lament> but yeah, try the gentle introduction
19:58:22 <dolio> Scheme and CL might qualify as such a background.
19:58:26 <schme> Great. Let me rephrase this here then. Can you guys recommend a book in dead tree format?
19:58:54 * dolio hasn't ever actually seen a dead tree haskell book in person.
19:59:00 <schme> Arggh.
19:59:21 <lament> there's "the haskell school of expression", i don't know if it's any good but it's probably getting outdated
19:59:26 <shachaf> schme: Hutton's Programming in Haskell is nice.
19:59:28 <dolio> They tend not to be on bookstore shelves.
19:59:31 <shachaf> schme: If a little short.
19:59:32 <lament> there's "real world haskell" but it's not out yet
19:59:45 <solrize> the two books i see recommended all the time are Haskell School of Expression, and The Craft of Functional Programming
19:59:56 <schme> shachaf: Thanks. I'll get that.
19:59:59 <schme> and that too.
20:00:01 <solrize> realworldhaskell.org is a new book in progress that should be really good, but only a little bit is there now
20:00:23 <schme> I'll bookmark it for now. :)
20:00:25 <lament> the craft of functional programming is 1999; school of expression is 2000
20:00:35 <lament> it's probably better to print YAHT :)
20:00:36 <solrize> Haskell School of Expression is a good introduction but doesn't get much beyond that
20:00:38 <ddarius> lament: And you shouldn't write seq often.
20:00:51 <ddarius> That said, seq isn't completely unidiomatic.
20:00:52 <solrize> some parts of the wikibook are excellent others are missing or not very good
20:01:05 <schme> The pdf is not the same as the wikibook then?
20:01:08 <solrize> oh, "programming in haskell" by graham hutton just came out
20:01:18 <solrize> the wikibook imported most of YAHT and added some stuff
20:01:25 <lament> schme: outside dead tree, try reading A Gentle Introduction before YAHT
20:01:37 <lament> (and switch to YAHT if it proves too confusing)
20:01:46 <lament> it's called Gentle in a bit of a cruel pun
20:02:16 <schme> Well I'll grab both and figure out some way to read 'em.
20:02:50 <lament> good luck; also, whatever the books say, install ghc, and ask questions here :)
20:03:41 <schme> Yes. I did install ghc yesterday to run xmonad. Which is my main reason for checking out haskell anyway.
20:03:57 <cjs> HSoE gets a darn sight further than Hutton's book.
20:04:06 <solrize> cjs it does?  uh oh
20:04:14 <cjs> But I like Hutton's book as a quick intro.
20:04:37 <solrize> there is a huge gap between what's in the books and what you really have to know to do anything
20:04:41 <lament> yeah
20:04:50 <cjs> And Hutton's book covers some important topics better (IMHO) than HSoE. E.g., the Functional Parsers chapter is critical, or was for me.
20:04:52 <lament> any book that covers monad transformers? I assume real world will
20:05:00 <solrize> and you have to read a lot of research papers to have any idea what's going on
20:05:07 <lament> yeah
20:05:08 <schme> I see. Well that's ok. I just want books so I can read at work anyway.
20:05:13 <solrize> lament, there are a couple good online docs about monad transformers
20:05:18 <lament> i know
20:05:21 <solrize> i mean schme
20:05:25 <cjs> solrize: no. I'm now about three weeks into writing a trading system in Haskell, and doing ok. I started out with those two books.
20:05:46 <solrize> cjs interesting
20:05:50 <cjs> In fact, I'm still in them. I've pretty much covered Hutton's book, but there's still a lot I've not properly covered in HSoE.
20:06:28 <cubix> I've read most of the The Craft.. but I find I'm still pretty much lost when I look at real code..
20:06:28 * lament bets by the time real world haskell gets written, it will be horribly obsolete :D
20:06:36 <solrize> there's stuff in hsoe that i haven't covered but there a lot missing
20:06:43 <cjs> Keep in mind I'd poked at Haskell three or four times before over the last year or two before I started this. But only poked at it; read the books (but didn't take a serious stab at the exercises), wrote a couple of hundred lines of code, that was about it. Three weeks ago was when I started in on it full time.
20:06:50 <lament> cubix: it was written ten years ago.
20:06:51 <solrize> there was another good book in progress that suddenly disappeared from the web.  i think the author got a dead tree deal
20:06:58 <cjs> What's missing from HSoE?
20:07:14 <schme> I do have some general questions about haskell but I think I will save 'em 'til I've poked around with it some bit.
20:07:22 <dejones> cjs: I'd also like to know what is missing from HSoE that is covered in Hutton's book?
20:07:25 <lament> you have a full-tim haskell job?
20:07:28 <lament> +e
20:07:49 <cjs> Me? Yes. I made it for myself. :-)
20:08:00 <solrize> i'd have to look at my copy of hsoe again, i remember reading it and feeling not especially more equipped afterwards than before, to do stuff like grotty data conversions
20:08:07 <solrize> e.g. bytestring didn't exist when hsoe was written
20:08:10 <cjs> (I convinced a client that he wanted to write his trading system in Haskell instead of Java.)
20:08:10 <dejones> ahh
20:08:12 <cubix> cjs: what are you doing?
20:08:27 <solrize> cjs have you been reading joel reymont's stuff?
20:08:32 <joricj> how do i make hGetContents strict?
20:08:36 <cjs> It's an automated trading system that eats a market feed and generates orders.
20:08:49 <dejones> solrize, cjs: any idea which is better "Programming in Haskell" or "The Craft of Functional Programming" ??
20:08:55 <cubix> cjs: that's pretty cool
20:09:06 <solrize> dejones, no idea, the only dead tree book i have is hsoe
20:09:20 <dejones> solrize: dead tree book? lol
20:09:31 <dejones> as in, paper?
20:09:32 <dejones> heh
20:09:34 <solrize> yeah
20:09:36 <dejones> hehe
20:09:37 <cubix> beats live tree books..
20:09:51 <dejones> cubix: how do you know?  ever read a live tree book?!  :)
20:09:52 <dejones> hehe
20:09:55 <solrize> a doc (online) that i really like is "a tour through the haskell prelude"
20:09:59 <SamB> cubix: you mean because those waste RAM, or have inferior display devices?
20:10:01 <cjs> Ah, the OpenPoker guy? Yeah, I read that a couple of years ago when it came out. I'm not seeing the same issues, but then again, I'm not that far into it yet.
20:10:03 <solrize> i'd love to have a paper book that did that for the entire library
20:10:04 <dejones> cubix: at least, the font might be bigger with a live tree book :)
20:10:28 <solrize> cjs, yeah, the same guy, no i wasn't thinking of the probs of his poker server, just that he's doing some online trading stuff now
20:11:05 <cjs> dejones: I've not read _Craft_. However, I can highly recommend Hutton's book as a good, quick intro that touches on some important basic points. And it's fairly easy to quickly get through the basic FP stuff if you are already familiar with FP.
20:11:38 <dejones> cjs: Yah, I'm fine with FP... I was hoping more for a book that covers the advanced stuff, like Monads and data structures in FP.
20:12:05 <solrize> okasaki's book on functional data structures is fantastic
20:12:26 <dejones> solrize: buying that now.  :)
20:12:33 <solrize> cool :)
20:12:43 <dejones> yep, i'm excited
20:12:48 <dejones> but I want to buy another Haskell book too
20:12:55 <cubix> too bad he didn't use haskell instead of ML
20:12:57 <cjs> Ah, yes, I seem to recall that he was doing some trading systems. But he doesn't seem to write about it much.
20:13:02 <bos> save your money for a few months and buy mine :-)
20:13:11 <solrize> dejones maybe you better look at some of the blurbs and papers related to that book before buying it, it's a great book but might not be what you want
20:13:20 <sclv_> bos: yours surely won't cost *that* much? :-)
20:13:34 <dejones> http://www.amazon.com/Real-World-Haskell-Bryan-OSullivan/dp/0596514980/ref=sr_1_5?ie=UTF8&s=books&qid=1208315538&sr=1-5  --- you can pre-order Real World Haskell from Amazon?!?!
20:13:36 <lambdabot> http://tinyurl.com/6zuo6c
20:13:36 <sclv_> i figure one month of saving should have it covered.
20:13:39 <bos> sclv_: there's just the matter of it not yet being finished
20:13:54 * sclv_ laments the difficulty of irony on the internet.
20:14:04 <cjs> dejones: yeah, okasaki's book is great. But I didn't get one core principle of monads until I read the functional parsers chapter of Hutton's book (though it doesn't mention monads per say, it builds one).
20:14:07 <bos> dejones: wow, i had no idea!
20:14:21 <dejones> dons: you there?  We can pre-order Real World Haskell, is it publishing soon??
20:14:25 <lament> i lament the difficulty of irony on the internet every day
20:14:26 <dejones> @seen dons
20:14:26 <lambdabot> dons is in #haskell, #xmonad, #haskell-hac4 and #haskell-soc. I last heard dons speak 1d 6h 21m 13s ago.
20:14:31 <bos> no, it's not publishing just yet.
20:14:32 <cjs> I'm actually stuck on a monad-related problem right now, and that prompted me yesterday to start the _All About Monads_ tutorial, which is going well for me.
20:14:46 <solrize> did you see this recent oleg rant about monad transformers?
20:14:59 <dejones> bos: how soon...?
20:15:08 <solrize> http://lambda-the-ultimate.org/node/2749#comment-41078
20:15:09 <lambdabot> Title: April 1st special: The War of the Worlds | Lambda the Ultimate
20:15:10 <bos> dejones: months away
20:15:14 <dejones> bos: lol
20:15:19 <ddarius> dejones: bos, CosmicRay and dons are all coauthors of Real World Haskell
20:15:42 <dejones> bos: Yea, I figured out that bos was.  ;)
20:15:47 <dejones> ddarius: meant you
20:15:47 <dejones> hehe
20:15:58 <solrize> real world haskell is already much more useful than hsoe, because of the online chapter about regexps :)
20:16:01 <dejones> bos: if we pre-order, does that mean you'll get it done faster?  hehe
20:16:09 <dejones> ;)
20:16:18 <bos> dejones: if you preorder enough copies to pay for me to quit my day job, sure!
20:16:26 <cjs> BTW, despite none of the books covering Data.ByteString or Data.Binary, I started using them fairly quickly after starting in.
20:16:29 <bos> i figure about a million copies should do the trick.
20:16:57 <lament> why didn't you name the book "Harry Potter and the Real World Haskell"
20:16:58 <dejones> bos: lol, I'm a student; I don't have that kind of money!
20:17:06 <cjs> Hey, how come I've never heard of _Real World Haskell_? Anyway, I'm preordering it now.
20:17:20 <cjs> I hope it's a _Practical Common Lisp_ and not a _Practical OCaml_. :-)
20:17:25 <dejones> bos: approve my Google Summer of Code application, so I can have more $$ to contribute to Haskell and your book.  :P
20:17:25 <dejones> hehe
20:17:37 <bos> cjs: we're publishing chapters on the fly, so you can see for yourself.
20:17:39 <sclv_> i understood monads conceptually, but using one was beyond me until i had a snipped of code that i realized was really just a monad-in-disguise and then once i refactored it, everything opened up at once.
20:17:43 <solrize> cjs yeah i guess bytestring and data.binary are understandable.  a package i'm really interested in is happs and it's still quite incomprehensible after reading stuff like hsoe
20:17:48 <dejones> bos: what's the url to the online chapters?
20:18:00 <bos> @go real world haskell
20:18:02 <lambdabot> http://www.realworldhaskell.org/
20:18:02 <lambdabot> Title: Real World Haskell
20:18:07 <lament> is practical ocaml really bad?
20:18:15 <bos> yes, it's really bad.
20:18:19 <solrize> i've heard from many places that practical ocaml is terrible
20:18:26 <sclv_> solrize: happs isn't in a comprehensible state yet. :-P
20:18:28 <ddarius> cjs: There is another person that was writing a book that very likely will be a "Practical O'Caml".  bos, dons and CosmicRay know what they are talking about and have tons of feedback, so Real World Haskell should be pretty good.
20:18:48 <solrize> ocaml seems a lot easier to grok than haskell
20:19:01 * sclv_ makes an obligatory pitch for hvac.
20:19:25 <cjs> Practial OCaml completely turned me of OCaml, and this is coming to it as a fan of functional programming.
20:19:37 <lament> solrize: it's because in haskell, all the easy ways out are prohibited and you must look for a hard way
20:19:43 <cjs> It's quite possibly the biggest disservice to FP the world has ever seen.
20:19:46 <dejones> bos: any suggestions on which is better, The Craft of FP or Programming Haskell?
20:19:50 <lament> cjs: whoa.
20:20:01 <dejones> bos: I'd like to get a book to use until your's comes out ;)
20:20:33 <bos> dejones: i've never bought a haskell book.
20:20:39 <dejones> bos: fine! :P
20:21:07 <dejones> bos: does that mean I shouldn't buy your's?  ;)
20:21:23 <ddarius> dejones: It means you don't need to to learn Haskell.
20:21:25 <sclv_> i recommend papers and browsing source repos.
20:21:31 <dejones> ddarius: yea ;)
20:21:41 * dejones is being a smart-ass...
20:21:42 <bos> dejones: if you want to learn haskell by reading lots of papers and writing lots of slowly less and less crummy code, go for it.
20:21:42 <lament> amazon reviews for practical ocaml are fun
20:21:59 <dejones> bos: lol, nice one
20:22:01 <ddarius> bos: Reading lots of papers is fun!
20:22:12 <dolio> Practical Ocaml is the one that wasn't good, right?
20:22:15 <sclv_> if you want to learn ffi, browse bytestring.
20:22:16 <bos> ddarius: that's how i learned it. wouldn't swap the experience for anything.
20:22:16 <geezusfreeek> bos: that's what I did!
20:22:20 <SamB> bos: there is some other way?
20:22:25 <lament> "Worst programming book I have ever read", "Very bad book", "A shockingly bad book",
20:22:29 <lament> (...)
20:22:30 <sclv_> if you want silly efficiency browse the shootout entries.
20:22:46 <sclv_> if you want clean functional programming, browse the collections libs.
20:22:58 <ddarius> If you want to learn the FFI, read the FFI addendum.
20:22:58 <sclv_> if you want the basics, browse the prelude.
20:23:06 <solrize> dons blog has some good examples, i hope they go in the book
20:23:10 <SamB> sclv: which one?
20:23:14 <paczesiowa> have you ever had "user error (loadShared: couldn't load `gobject-2.0' because addDLL : unknown error)" ?
20:23:44 <SamB> paczesiowa: I think that's a wierdd GTK problem
20:23:45 <sclv_> transformer stacks and quickchecks, xmonad :-)
20:24:09 <dejones> bos: have you read Okasaki's Purely Functional Data Structures?
20:24:18 <solrize> so i'm looking at this json module, full of functions with types like    toDoc :: JsonNode -> Doc
20:24:26 <solrize> but Doc is not defined anywhere in it
20:24:26 <dejones> bos: that book was based upon his PhD thesis, so I guess it is like reading the papers combined into a single book  ;)
20:24:27 <bos> dejones: it's a brilliant book.
20:24:37 <sclv_> does it import Text.PrettyPrint.Something ?
20:24:42 <solrize> scov yes
20:24:43 <dejones> bos: yeah, I'm buying it now, so I was considering buying a Haskell book too...
20:24:47 <solrize> aha
20:24:47 <SamB> solrize: that would be it!
20:24:48 <solrize> thanks
20:24:48 <sclv_> doc is defined in that
20:25:06 <paczesiowa> SamB: I know. it works on linux, but that error on windows. but windows can run other gtk2hs apps
20:25:07 <sclv_> its for, obv., pretty printing.
20:25:22 <SamB> Doc usually is ;-)
20:25:37 <solrize> is there a way to figure out what module a symbol is defined in?
20:25:42 <SamB> the program I am hacking on right now uses no fewer than two types of that name, both for pretty printing
20:25:43 <sclv_> it could be for bugs bunny... :-P
20:25:44 <solrize> this thing imports a lot of packages
20:25:52 <paczesiowa> :info fst
20:26:01 <solrize> @hoogle Doc
20:26:01 <lambdabot> Language.Haskell.TH.PprLib.Doc :: type Doc
20:26:01 <lambdabot> Distribution.Simple.InstallDirs.DocDirVar :: PathTemplateVariable
20:26:01 <lambdabot> Distribution.Simple.InstallDirs.docdir :: InstallDirs dir -> dir
20:26:16 <lament> anybody knows this book? http://www.amazon.com/Haskell-Logic-Maths-Programming-Computing/dp/0954300696/ref=pd_sim_b_title_1
20:26:18 <lambdabot> http://tinyurl.com/5rg7jm
20:26:31 <solrize> i think i've seen some blurbs about that book
20:26:39 <solrize> didn't seem that interesting from a hacking point of view
20:27:43 <lament> it's cheap!
20:28:09 <solrize> hey yeah, for a computer book it is cheap
20:28:16 <solrize> 444 pages
20:28:20 <solrize> deal of the century
20:28:47 <cubix> very low quality print though
20:29:54 <schme> Where can I see what hardware platforms are supported by GHC?
20:30:05 <solrize> ghc can generate C code
20:30:20 <solrize> which is reasonably portable
20:30:21 <SamB> maybe he wants ghci too?
20:30:25 <solrize> oh
20:30:26 <solrize> hmm
20:30:28 <schme> Yes. I do want ghci.
20:30:29 <solrize> i dunno about that
20:30:36 <ddarius> http://www.haskell.org/ghc/download_ghc_682.html
20:30:37 <lambdabot> Title: GHC: Download version 6.8.2
20:30:37 <solrize> isn't it written in haskell?
20:31:27 <schme> Hehe.
20:31:37 <schme> Well I'll check later on today if I can get it running.
20:32:40 <lament> you can somehow install ghc and xmonad but not ghci?
20:33:23 <clanehin> lament: I think that ghc can be "not built for interactive use" or some such error, which I've gotten before.
20:34:01 <clanehin> lament: the dabian/ppc build of ghc was broken in that way for a while, don't know if it still is.
20:35:12 <clanehin> debian, even, not sure what process leads to these phonetic typos.
20:36:09 <SamB> solrize: GHCi requires (a) Linker.c and (b) a bytecode interpreter
20:36:25 <SamB> I believe both are rather platform-dependant...
20:37:39 <solrize> hmm
20:38:05 <solrize> i would think they could be about as portable as other interpreted languages i can think of
20:38:26 <SamB> not possible
20:38:27 <ddarius> GHCi can load compiled object files.
20:38:33 <SamB> and MUST
20:38:40 <SamB> it can't work without doing so
20:38:53 <SamB> -- it needs to load HSbase.o, for instance
20:39:05 <clanehin> solrize: you would think that, yes  :)
20:39:22 <solrize> yeah true, there's some system hackery needed
20:39:24 <solrize> still doesn't sound that bad
20:39:31 <adu> i feel like a newbie again
20:39:33 <solrize> i mean, python has to do stuff like that
20:39:41 <SamB> in fact, *all* code from packages must be loaded
20:39:53 <adu> do {map doDisplay xs ; return ()}
20:40:00 <SamB> well, for some reason I don't quite understand, GHCi has its own linker :-(
20:40:03 <SamB> that doesn't help
20:40:08 <adu> ^ this is returning [IO ()] and I want it to return IO ()
20:40:29 <Twey> So head it
20:40:33 <newsham> ?type seq
20:40:47 <lambdabot> forall a t. a -> t -> t
20:40:49 <clanehin> mapM_ doDisplay xs
20:40:53 <newsham> :type sequence
20:40:57 <adu> ah ok
20:41:01 <solrize> arggh, that pretty printer is dog slow
20:41:20 <newsham> ?hoogle [IO a] -> IO ()
20:41:20 <lambdabot> No matches, try a more general search
20:41:22 <SamB> also, Python, for instance, list I checked did not *need* to be able to load modules dynamically -- though on the systems I've used it on, that's been the done thing...
20:41:39 <newsham> ?hoogle Monad m => [m a] -> m ()
20:41:39 <lambdabot> Prelude.head :: [a] -> a
20:41:39 <lambdabot> Prelude.last :: [a] -> a
20:41:39 <lambdabot> Data.List.head :: [a] -> a
20:41:43 <solrize> er, there's an import statement
20:41:58 <SamB> (note that I mean extension modules)
20:42:01 <ddarius> :t sequence
20:42:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
20:42:04 <ddarius> :t sequence_
20:42:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
20:42:05 <SamB> (not plain old Python modules)
20:42:13 <solrize> the import statement can load extension modules
20:42:17 <SamB> solrize: it *can*
20:42:23 <SamB> on supporting platforms
20:42:39 <SamB> but I am under the impression that you can also link those statically somehow???
20:42:58 <solrize> hmm, i guess it might be possible to build python that way
20:43:56 <solrize> i think you'd normally only run the interactive interpreter (python's or ghci) on either windows or a unixy system, and for either of those, loading extensions is de rigeur
20:44:07 <SamB> but GHCi can't possibly operate that way -- it doesn't even support unboxed types
20:44:57 <adu> thanks
20:45:22 <SamB> (base being written in Haskell)
20:46:49 <sclv_> ?src sequence
20:46:49 <lambdabot> sequence []     = return []
20:46:49 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
20:46:49 <lambdabot> --OR
20:46:49 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
20:46:55 <sclv_> ?hoogle mapM
20:46:55 <lambdabot> Prelude.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
20:46:55 <lambdabot> Control.Monad.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
20:46:55 <lambdabot> Data.Traversable.mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
20:47:01 <sclv_> ?src mapM
20:47:01 <lambdabot> mapM f as = sequence (map f as)
20:50:33 <adu> YEY it worked
20:52:56 <adu> what does "de rigeur" mean?
20:53:42 <solrize> de rigeur => expected
20:53:55 <adu> ic
20:54:13 <solrize> misspelled
20:54:20 <solrize> http://www.dict.org/bin/Dict?Form=Dict2&Database=wn&Query=''de+rigueur''
20:54:21 <lambdabot> Title: dict.org- ''de rigueur'', http://tinyurl.com/5vmjor
20:55:22 <solrize> this json module really has a lot of boilerplate
20:56:16 <hpaste>  runar pasted "Inconsistent dependencies on bytestring?" at http://hpaste.org/6999
20:57:23 <gwern> runar_: ouch. so I see you've run into the multiple-versions bug
20:57:32 <runar_> what's that about?
20:57:58 <gwern> runar_: things compiled against different 0.9.x versions of bytestring aren't binary compatible
20:58:12 <runar_> uh on
20:58:24 <runar_> What to do? Recompile everything?
20:58:48 <gwern> runar_: the solution is to eradicate any bytestring other than 0.9.0.1 from your system, never let them back on, and recompile anything linked against the now-purged doubleplusungood libs
20:59:09 <adu> bad b.p.
20:59:29 <gwern> (at least, if you ever want to use something that uses the GHC API; the salient point is that you must have everything be consistent in which bytestring they were compiled with)
20:59:47 <adu> I am in love with the GHC API
21:00:17 <runar_> I have the latest darcs version of bytestring. No good?
21:00:30 <sclv_> this bug is coming up more and more.
21:00:55 <sclv_> i'm starting to think we should lobby for a new bytestring release policy.
21:01:07 <sclv_> i.e. big warnings on the hackage package
21:01:30 <gwern> sclv_: no kidding. it wasn't too bad when it was just yi or lambdabot hackers who were hitting it, but since 0.9.0.4 gets installed by default in stuff like gentoo, it's breaking out into mainstream success
21:01:38 <gwern> soon it will go platinum and start snorting coke
21:02:11 <adu> wxc/src/taskbaricon.cpp:35: error: 'class wxTaskBarIcon' has no member named 'IsOK'
21:02:17 <runar_> I think I saw it swinging a baby over a balcony just now
21:02:26 <sclv_> i don't know quite the issues and solution -- i just stay the heck away from new bytestrings until i upgrade ghc as a whole.
21:03:06 <runar_> I take it that bytestring is not included with ghc
21:03:16 <cjs> It is.
21:03:20 <gwern> runar_: well, that's sort of the problem
21:03:23 <cjs> At least it's included with my 6.8.2.
21:03:34 <cjs> Or isn't it? Maybe it's my package.
21:04:41 <gwern> cjs: well, GHC itself is compiled with bytestring in it, no? hence the problems with the GHC API
21:05:06 <sclv_> right -- you can't recompile "everything that depends on bytestring" without recompiling ghc too.
21:05:13 <sclv_> i think.
21:05:23 <cjs> There ya go. Fortunately, this kind of stuff isn't a problem for a "rebuilding everything is easy" kinda guy like me.
21:05:34 <sclv_> we also need to campaign to not have foax require bytestring > 9.0.1
21:05:48 <gwern> cjs: were you the one bragging on darcs-devel about nix?
21:05:52 <sclv_> rebuilding everything is sorta scary when yr. os
21:05:55 <sclv_> erm, os x
21:05:57 <runar_> How can I know what is compiled against which version of bytestring?
21:06:01 <cjs> Nope. I don't use darcs. (Yet.)
21:06:44 <sclv_> go back to the old bytestring, and ghc-pkg list should show what breaks.
21:06:56 <gwern> runar_: I don't know. I do know that since I use Cabal 1.5 or something like that, it'll warn me about inconsistent depdencies during a runhaskell configure. I *think* it mustbe parsing the package.confs
21:07:12 <cjs> Yeah, we're dealing with OSX pain here. But I was referring more to the fact that my build system for apps includes most not-perfectly-standard libs and so on, and builds everything into its own release directory, so I've got much fewer problems with OS and "external" software dependencies than a lot of shops.
21:07:58 <cjs> BTW, just to mention, ghc's package system is absolutely wonderful. I got my build system building and using packages installed in the local release dir in less than two hours.
21:08:11 <sclv_> the new readline stuff should make os x less painful soon too.
21:08:16 <cjs> I don't want to think about how many man days I've put into C libraries and ruby libs.
21:08:21 <runar_> crikey
21:08:22 <cjs> New readline stuff?
21:08:33 <cjs> For us, we just gave up, and use macports for everything now.
21:08:37 <runar_> I have a whole bunch of bytestring versions
21:08:38 <sclv_> oh man -- that's one for the haskell-whenever-news quotes file!
21:09:06 <sclv_> (cjs
21:09:09 <gwern> sclv_: hey, dons is a busy guy!
21:09:11 <sclv_> 's endorsement, that is)
21:09:16 <gwern> you want it weekly, step up to the plate
21:09:29 <sclv_> i say it with all due affection.
21:09:51 <cjs> Feel free to use it. It saved my client something like $750, too.
21:10:30 <gwern> oh hey
21:10:53 <gwern> I cam across a quote a while ago by an old psychologist which beautifully illustrates why I like high-level languages
21:11:23 <gwern> 'No organism can afford to be conscious of matters with which it could deal at unconscious levels.'
21:11:40 <gwern> ([[Gregory Bateson]])
21:12:41 <adu> OSX isn't painful
21:12:58 <adu> there are pros and cons to everything
21:13:10 <solrize> :t intersperse
21:13:11 <lambdabot> forall a. a -> [a] -> [a]
21:13:38 <cjs> For pulling down and installing standard unix software easily, Ubuntu is much easier. But not a discussion worth having, really.
21:14:22 <gwern> cjs: really? I would've thought you'd run into problems since they replaced /bin/sh->bash with ->dash
21:14:38 <paczesiowa> @tell dcoutts I think I found a bug in gtk2hs, more info: http://hpaste.org/7000
21:14:38 <lambdabot> Consider it noted.
21:14:48 <cjs> Nah. I'm a NetBSD guy, so I don't use bashisms.
21:15:11 * gwern meant all the other programs
21:15:22 <gwern> I experimented with repalcing bash with dash on my gentoo system; broke not a few compiles and init scripts
21:16:25 <sclv_> oh hey! whoo! 7k!
21:16:37 * sclv_ breaks out the streamers
21:16:39 <paczesiowa> 7k problems:>
21:16:56 <sclv_> I got 7k problems and mutable state ain't one.
21:17:00 <sclv_> hit it!
21:18:26 <runar_> OK, so I removed all but 0.9.0.1. Now I get a build error that 0.9.0.4 is missing.
21:18:45 <sclv_> ghc-pkg list and see what depends on it?
21:18:54 <paczesiowa> runar_: you have to rebuild all the packages that depend on bytestring
21:20:44 <clanehin> While using foralls, "Illegal polymorphic or qualified type" . . . what is a legal polymorphic or qualified type?
21:21:37 <sclv_> i shouldn't take over hwn anyway -- i'd just quote myself all the time.
21:21:51 <lament> gwern: lovely quote
21:22:00 <lament> more so wrt psychology than programming
21:22:50 <gwern> lament: I dunno. it seems extremely applicable to garbage collection; at least, my very first thought was that, and then I considered how habits and assumptions are necessary for a sane existence as a second thought
21:23:03 <lament> we have the perlis version of that - "#  A programming language is low level when its programs require attention to the irrelevant."
21:23:41 <sclv_> @quote perlism
21:23:41 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
21:23:45 <sclv_> @quote perlis
21:23:46 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
21:23:52 <cjs> Such as the minor version number of ByteString? :-)
21:23:57 <sclv_> the great quote massacre of 2008.
21:23:58 <lament> sclv_: http://www-pu.informatik.uni-tuebingen.de/users/klaeren/epigrams.html
21:24:01 <lambdabot> Title: Epigrams on Programming, http://tinyurl.com/ysyqg4
21:24:09 <lament> @quote quote
21:24:09 <lambdabot> jfredett says: i would @remember that, but when someone @quotes olsner, it'd be nsfw on the normal channel... :/
21:24:10 <gwern> lament: yes, that's another of my favorites
21:24:19 <cjs> (I have a perlis fortune file that prints me one every time I log in.)
21:24:32 <gwern> Perlis has so many good quotes; his epigrams are a textbook in and of themselves
21:25:09 <sclv_> nytol
21:25:29 <runar_> I'm still not sure how to find out which packages I need to rebuild. ghc-pkg list shows me the list of all packages. ghc-pkg check tells me that no packages are missing.
21:25:56 <adu> lament: in that case any language that is not natural is low-level
21:26:04 <gwern> 'It follows that all organisms must be content with rather little consciousness, and that if consciousness has any useful functions whatever (which has never been demonstrated but is probably true), then economy in consciousness will be of the first importance. No organism can afford to be conscious of matters with which it could deal at unconscious levels.'
21:26:52 <lament> adu: noup
21:27:05 <adu> no?
21:27:07 <lament> adu: there's quite a bit of relevant stuff natlangs gloss over
21:27:16 <lament> or are inefficient at dealing with
21:27:26 <clanehin> gwern: What was his definition of consciousness?
21:27:27 <lament> "i want to write a 3d game"
21:27:35 <adu> like the difference between tuples and lists?
21:27:51 <adu> a comma can mean so many things...
21:28:32 <lament> gwern: it's amazing how many humans don't realize that
21:28:40 <gwern> clanehin: I do not know
21:28:46 <adu> but when it comes to things like that, most of the game has already been written, because people don't want something new, they want a game that has already been written, with new graphics
21:29:19 <gwern> lament: there's another quote, which I can't seem to remember along the lines of 'civilization advances in direct proportion to the number of things that become habitual/no longer require thought'
21:30:16 <lament> gwern: mm, that's far less engaging
21:31:00 <lament> gwern: civilization advances, the number of artifacts increases, people use them habitually - where's insight in that?
21:31:07 <gwern> lament: the original was written much nicer than my paraphrase :(
21:31:19 * gwern really wishes I remembered where I read that second one
21:31:30 <runar_> gwern: Hah. The author reveals something about himself when he says that the usefulness of consciousness hasn't been demonstrated.
21:31:42 <adu> lol
21:31:49 <lament> runar_: has it?
21:32:03 <runar_> Useful to whom and to what end?
21:32:21 <gwern> runar_: epiphenomenalism is a very old position
21:32:41 <lament> runar_: he's talking in the context of evolutionary psychology. So useful in the evolutionary sense.
21:34:23 <adu> I wonder if anyone has tried to rip the head off Epiphenomenalists has tried to justify it as a demonstration in Epiphenomenalism
21:34:45 <lament> gwern: ew, that sounds philosophical :)
21:35:25 <runar_> I'll let them maintain that consciousness is useless, and go on using mine regardless.
21:35:26 <gwern> lament: it is, but it's also psychological. if you aren't an epiphenomenalist, then the various 'anti-freewill' results are difficult to explain
21:36:04 <adu> I have no choice but to believe in free will, it is my destiny...
21:36:46 <lament> gwern: "free will" sounds even more philosophical
21:36:47 <cjs> So fail always takes a String as an argument? What for? Maybe and List monads don't use it, right? Is it becuase others sometimes do?
21:37:05 <lament> gwern: (and even less scientific)
21:37:28 <dolio> It's to explain why fail was called.
21:37:53 <lament> it's a primitive mechanism of providing informative exceptions
21:37:59 <adu> cjs: ya, like fail "No error" (my favorite)
21:38:01 <lament> a pretty terrible one
21:38:07 <cjs> Hm. Is that message accessable somewhere? When I fail in the Maybe monad, "Nothing" comes out.
21:38:14 <dolio> > do { (_:_) <- return [] ; return () } :: Either String ()
21:38:16 <lambdabot>  Left "Pattern match failure in do expression at <irc>:1:5-9"
21:38:35 <gwern> lament: well alright: the various psychological experiments where the consciousness perceives its decision to take action as coming *after* the action is already being undertaken are difficult to explain in a framework where conscious events has a forward casual relationsip to brain activity
21:39:11 <lament> gwern: oh. As long as you don't mention "free will", it makes sense :)
21:39:29 <gwern> ok then...
21:39:54 <pantsd> how do I pattern match against IO (Maybe [HostAddress]) ?
21:40:43 <Beelsebob> pantsd: (Just (x:xs)) <- yourThingWithThatType ?
21:41:07 <geezusfreeek> ^ assuming it's not going to return Nothing
21:41:12 <lament> pantsd: the IO part you can't :)
21:41:23 <scook0> careful with those irrefutable patterns
21:41:25 <geezusfreeek> lament: you can if you import the right module ;)
21:41:41 <adu> pantsd: ya, technically only (<-) "matches" IO
21:41:43 <runar_> gwern: Of course you can't perceive decision until after the corresponding brain activity commences. What organ would you be using to perceive it otherwise?
21:41:45 <dolio> What you do is match against Maybe [HostAddress] in, say, f, and then you use 'yourThing >>= f'.
21:42:15 <pantsd> ahh
21:42:17 <pantsd> dolio: thanks :)
21:42:25 <dolio> Or maybe 'fmap f yourThing', depending on the exact type of f.
21:42:28 <scook0> do mxs <- yourThing ; case mxs of ...
21:42:35 <adu> so is this like the matrix? we don't make decisions, we just do things, then understand the decisions that are made for us?
21:42:37 <scook0> is another option
21:42:42 <dolio> That'll work too.
21:42:45 <lament> runar_: no, the perceived decision comes after the _action_
21:42:52 <dolio> But I'm unfairly prejudiced against 'case'. :)
21:43:02 <scook0> makes me wish we had \case
21:43:22 <scook0> or mcase
21:43:54 <gwern> runar_: but of course; but why can't this be the same thing as perception - consciousness of preceptions lags behind 'reality' because of physical constraints, but we still think we're in sync, and not the dozens or hundreds of milliseconds we're actually delayed by
21:44:07 <cjs> Speaking of which, I've just come up with a MonadPlus version of parent (for my Sheep in the _All About Monads_ tutorial), and I'm coming up with stuff like this:
21:44:27 <cjs> case mother s of Nothing -> fail "no mother"; Just m -> return m
21:45:00 <cjs> It seems that if Nothing represents a fail, and Just p represents a return p, there might be some way to sort of let it happen automatically?
21:45:20 <cjs> This is for "parentM :: (MonadPlus m) => Sheep -> m Sheep" BTW.
21:45:34 <cjs> I'll take a function name or something as a clue.
21:46:29 <lament> gwern: but consciousness is far slower than that. The lag is just too obvious and unavoidable
21:46:46 <Cale> cjs: Which exercise are you working on?
21:46:56 <Cale> cjs: I'll have a look for that :)
21:47:21 <runar_> Right, right. It would be presuming something about how consciousness works to expect action to wait to be registered.
21:47:38 <Cale> I just realised something. The All About Monads tutorial is getting the use of the word "monad" wrong half the time.
21:47:47 <cjs> It's exercise 4 from http://www2.lifl.fr/~boulet/formation/CALP/man/monads/html/exercises.html
21:47:49 <lambdabot> Title: Exercises, http://tinyurl.com/5ujxcu
21:47:58 <lament> as with programming languages, introspection is very slow :)
21:48:22 <Cale> cjs: ah
21:48:37 <Cale> cjs: Well, the typeclass constraint there is the biggest hint.
21:48:51 <Cale> class Monad m => MonadPlus m where
21:48:51 <hpaste>  solrize pasted "json writer" at http://hpaste.org/7001
21:48:56 <Cale>    mzero :: m a
21:49:07 <Cale>    mplus :: m a -> m a -> m a
21:49:08 <cjs> Ah...of course!
21:49:09 <runar_> Right, and the IO can commence without the program having logged it to the debugger. ;)
21:49:37 <solrize> oh i remember that monad article, it's good
21:49:50 <cjs> I shoulda looked at the functions I'd been shown recently in the text.
21:50:06 <Cale> "A list is also a monad" -- this is wrong in a nitpicky way. :)
21:50:18 <cjs> Cale: In what way?
21:50:27 <Cale> The type constructor for lists is a monad.
21:50:33 <Cale> Individual lists are not.
21:50:53 <ddarius> Cale wants the 'A' dropped.
21:51:06 <Cale> Yeah, that would work :)
21:51:10 <lament> Cale: people use "monad" to mean the weirdest things, such as "within the monad"
21:51:26 <solrize> cale did you ever see this?  it's an oleg rant about monad transformers.  http://lambda-the-ultimate.org/node/2749#comment-41078
21:51:30 <lambdabot> Title: April 1st special: The War of the Worlds | Lambda the Ultimate
21:51:56 <runar_> the "within" euphemism had me confused for a while when learning about monads
21:51:57 <Cale> solrize: Yeah, I'm not sure as to the extent to which I agree with him.
21:52:23 <solrize> ok, i just wanted to make sure you saw it, i'll have to ask you about it sometime, i couldn't understand it much
21:52:26 <lament> when Oleg complains that something to do with the type system is too difficult, perhaps people should listen
21:52:35 * gwern wonders whether Oleg's solution to transformers involves delimited continuations
21:52:36 <solrize> lament :)
21:52:57 <Cale> solrize: There's a sense in which monad transformers are doing something really nontrivial though. I think the problem is more about the way that people use monad transformers than it is with monad transformers themselves.
21:53:31 <Cale> Monad transformers are a tool for library authors, not for application programmers (and we're all both to some extent, but at varying times)
21:53:51 <solrize> i remember some paper discussed here a while ago, that was some kind of optimization for monad transformers that seemed like implementing a glorified continuation passing style inside the type system
21:53:59 <Cale> Every use of a monad transformer should be hidden behind a module boundary and a newtype constructor.
21:54:05 <ddarius> Cale: They can be both.
21:54:26 <Cale> If you have lots of monad transformers showing up in your types, then you're doing it wrong :)
21:54:41 <lament> solrize: tunneling or whatever?
21:54:59 <solrize> well i don't understand oleg's post but i get a vague sense that when you have monad transformers stacked N deep then you're getting more effects than you wanted by a factor of O(2**n)
21:54:59 <ddarius> Cale: I have some code that locally uses StateT.
21:55:06 <Cale> Well, okay, for very small cases, using a monad transformer unwrapped is all right.
21:55:07 <solrize> lament i don't remember
21:55:20 <solrize> yeah tunnelling maybe
21:55:23 <Cale> But if you're writing more than one or two lines in the transformed monad, newtype it.
21:55:53 <lament> i imagine it gets worse when bits of your app need different portions of the overall stack
21:56:04 <lament> so you break the stack into substacks, newtype each one...
21:56:10 <lament> (is that ever done?)
21:56:23 <ddarius> lament: Usually only if there is a good reason.
21:56:46 <Cale> lament: There are tricks you can do to encode partitions of the available effects at the type level...
21:57:05 <lament> if you have StateT over IO, and some code just needs StateT
21:57:13 <Cale> http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf
21:57:16 <scook0> Cale: is that (monad transformer) advice written down anywhere? it would be nice to be able to point people to it
21:57:23 <lament> (imagine another 20 monads in the stack, and the code needs some of those too)
21:57:27 <Cale> scook0: yes
21:57:34 <Cale> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
21:57:37 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
21:57:43 <scook0> (I ask because the other day I had someone asking about MTs)
21:58:04 <Cale> lament: You're not stacking monads, you're stacking monad transformers ;)
21:58:14 <lament> sure
21:58:18 <ddarius> lament: There's rarely ever a necessity to use a more restricted monad and 20 layers of monad transformers is beyond extreme.
21:58:40 <geezusfreeek> i've never really had much problem with transformers. they can get a little complex sometimes, but i think that is more the fault of poorly designed typeclasses in the standard libs than inherent problems with transformers
21:58:42 <Cale> lament: and if your stack ever gets that high, you should *definitely* be hiding that fact from the users of the monad.
21:58:45 <lament> 3 monad transformers ought to be enough for anyone!
21:58:50 <Cale> Indeed it should.
21:59:01 <geezusfreeek> hmm
21:59:01 <lament> Cale: right, but if a function needs only a portion of the stack
21:59:08 <solrize> 3?  wasn't it 640?
21:59:08 * geezusfreeek goes to count his largest transformer stack
21:59:12 <dejones> I just can't decide which book to buy, "The Craft of FP" or "Programming in Haskell."  :(
21:59:25 <dolio> Just use delimited continuations and monadic reflection, of course. :)
21:59:32 <Cale> Because by the time you get up to 20 monad transformers, combinations of those transformers must have some meaning which could be given a name.
21:59:32 <dejones> Cale: any advice on which book to get?
21:59:58 <lament> Cale: yeah, like "IO" :)
22:00:03 <Cale> dejones: I don't know. I haven't actually read either of them.
22:00:06 <chylli> identify 3843054
22:00:06 <Cale> lament: Sure :)
22:00:25 <Cale> chylli: Typing your password into the channel is not a good policy ;)
22:00:32 <lament> welcome to #nickserv!
22:00:38 <dejones> Cale: alright, thanks anyway.  :)
22:00:42 <dejones> lol
22:00:43 <geezusfreeek> lol
22:00:44 <Twey> /ghost chylli 3843054
22:00:48 <Twey> >.>
22:00:53 * dejones becomes chylli
22:00:55 <dejones> ;)
22:00:58 <Twey> Hehe
22:01:03 <Cale> dejones: Hutton's new book is supposed to be rather good, but I think it's also supposed to be introductory
22:01:05 <geezusfreeek> is that a phone number?
22:01:16 * geezusfreeek calls chylli
22:01:24 <ddarius> geezusfreeek: It's a phone number for someone.
22:01:28 <Cale> dejones: Craft of functional programming I suspect is rather deeper, but it's also older, and maybe a bit less gentle?
22:01:29 * lament calls Cthulhu
22:01:45 <dejones> Cale: Yah, my fear is that since I am an experienced programmer, that the books may be not very advanced... I'm a master's student.  ;)
22:01:50 <gwern> lament: did you remember to use the sigil with the little tree on top?
22:01:52 <dejones> Cale: I want a more advanced book.  :)
22:02:04 <gwern> use the star, and you'll be fighting off Great Old Ones with your bare hands!
22:02:07 <ddarius> Algebra of Programming...
22:02:09 <Cale> dejones: Have you checked your university library?
22:02:17 <dejones> Cale: I am also buying Okasaki's Purely Functional Data Structures.
22:02:20 <Cale> Yeah, you might be interested in Bird's book.
22:02:21 <gwern> (Tentacles! Tentacles.... Tentacles!)
22:02:25 <lament> gwern: ugh, just because i'm a Cthulhu cultist, doesn't mean I'm using Perl!
22:02:29 <dejones> Cale: Yah, I got Haskell School of Expression from my Univ library.  :)
22:02:43 <lament> gwern: there're limits, man.
22:02:46 <dejones> Cale: HSoE is good, but I want something newer...
22:02:47 <gwern> seriously, A Shoggoth on the Roof is one of my favorite musical soundtracks
22:02:55 <dejones> ddarius: Algebra of Programming?
22:03:13 <gwern> lament: I was referencing the opening song of  ''A Shoggoth On The Roof'', viz. 'Tentacles'
22:03:20 <Cale> dejones: Also, if you can stomach papers, reading individual papers is actually a really decent way to go once you've got yourself off the ground.
22:03:27 <lament> gwern: i just heard "sigil" :)
22:03:38 <lament> (haven't heard ASOTR)
22:03:39 <gwern> lament: the joke was duly appreciated
22:03:47 <ddarius> "if you can stomach papers" ?
22:03:48 <gwern> https://secure.wikimedia.org/wikipedia/en/wiki/A_Shoggoth_on_the_Roof <-- wonderbrah
22:03:51 <lambdabot> http://tinyurl.com/56vder
22:03:58 <gwern> 'A Shoggoth on the Roof is a parody musical of Fiddler on the Roof based on the works of H. P. Lovecraft. Published by the H. P. Lovecraft Historical Society, it is credited to a member of the society who is referred to only as "He Who (for legal reasons) Must Not Be Named".'
22:04:05 <dejones> Cale: yeah, I do like reading the papers.  :)
22:04:13 <dejones> but, it is hard to carry around the papers with me for reference. ;)
22:04:19 <dejones> much easier with a book
22:04:20 <gwern> ddarius: well sure, don't you read the bible? some papers taste sweet like honey to the tongue, but turn bitter and sicken in the stomach'
22:04:29 <lament> (also, that sigil stuff is not even by lovecraft)
22:04:35 <gwern> ddarius: and then the world ends - but that's not really germane to our discussion
22:04:47 <Cale> It would be cool if someone put together a book of the really important and well-written Haskell-related papers.
22:04:59 <geezusfreeek> looks like the deepest transformer stack i've ever made is only three + base monad
22:05:08 <dejones> Cale: Yes, that would be excellent.  :)
22:05:13 <geezusfreeek> hear hear
22:05:15 <jeffz> "the best of Haskell"
22:05:18 <dejones> Cale: Maybe we should start a wiki page for that?
22:05:34 <dejones> we could collect the urls to the papers, so they can be read like a book....
22:05:48 <Cale> Oh, there already are wiki pages that are *sort of* like that.
22:06:02 <ddarius> @wiki Functional pearls
22:06:02 <lambdabot> http://www.haskell.org/haskellwiki/Functional_pearls
22:06:02 <dejones> wiki page: "Learning Haskell for the Researcher."  ;)
22:06:05 <geezusfreeek> a more guided process than is usual would be nice though
22:06:07 <gwern> (copyright clearance would be ferocious, if any publisher would want to handle it)
22:06:09 <Cale> http://www.haskell.org/haskellwiki/Research_papers -- nicely categorised
22:06:10 <lambdabot> Title: Research papers - HaskellWiki
22:06:29 <dejones> geezusfreeek: I definitely agree that a guided page would be good.
22:06:31 <geezusfreeek> something more like a tour than a reference
22:06:34 <Cale> gwern: I've seen it done fairly often in other contexts.
22:07:18 <dejones> gwern: well, we don't have to publish the book exactly... just link the papers from the urls ;)
22:07:20 <Cale> gwern: For example, the textbook for my cognitive science course was just a collection of papers bound into a textbook.
22:07:44 * dejones assigns Cale to create the guided tour of Haskell research papers.  :P
22:07:45 <dejones> lol
22:07:53 <lament> by Friday
22:07:54 * dejones doesn't know nearly enough to do it.
22:08:46 <solrize> http://web.archive.org/web/20070316155319/http://www.eecs.harvard.edu/~ccshan/dynscope/talk.pdf  oleg slides for delimited binding stuff, his url is gone
22:08:47 <Cale> dejones: I recommend reading at least the start of all of SPJ's papers (when it gets into the detailed bits that are more directed towards the implementer, you may or may not care to pick apart the details)
22:08:52 <lambdabot> http://tinyurl.com/649472
22:08:54 <gwern> dejones: but then we wouldn't be able to make jokes like 'Many Bodhi-trees died to bring us this information.'
22:09:05 <dejones> lol
22:09:12 <solrize> awkward squad is a very enlightening paper
22:09:27 <Cale> I really loved the STM paper.
22:09:32 <solrize> that too
22:09:42 <gwern> (honestly, given the dicks Bothans were in the Expanded Universe, I feel no regret about those deaths)
22:09:52 <geezusfreeek> why functional programming matters, of course, would have to be there
22:10:04 <lament> functional programming matters?
22:10:20 <dejones> geezusfreeek: WhyFP should probably be first ;)
22:10:26 <geezusfreeek> yup yup
22:10:47 <lament> isn't why fp matters a little old?
22:11:01 <ddarius> lament: And yet it is still excellent.
22:11:06 <geezusfreeek> yes, but i don't think it is irrelevant yet
22:11:06 <Cale> WhyFP comes *so close* to being the ideal introduction to the ideas of functional programming, but it seems that people who are not ready for it don't really take it in.
22:11:29 <Cale> So it almost comes off as preaching to the choir, but there's a certain point at which you can get a lot out of it.
22:11:29 <ddarius> geezusfreeek: It's not even close to irrelevant.
22:11:31 * dejones loved WhyFP
22:11:43 <geezusfreeek> ddarius: i was very much understating :)
22:12:26 <geezusfreeek> Cale: well, it worked fine for me. i don't think i really was excited about fp until i read it
22:12:26 <lament> ddarius: i mean, "why should i read this paper on why FP matters when nobody has even heard of FP 20 years after the paper was published?"
22:12:46 <geezusfreeek> lament: surely you have read it?
22:13:16 <geezusfreeek> oh, quotes
22:13:21 <geezusfreeek> i see what you're doing, n/m
22:13:45 <ddarius> lament: OO took decades to become popular as well
22:14:31 <Cale> http://xkcd.com/411/ -- ahahaha
22:14:31 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
22:14:32 <dejones> anyone read Bird's "The Algebra of Programming" ?  It's $145 on Amazon.  :(
22:14:40 <lament> ddarius: good point
22:14:49 <dejones> ddarius: did you read The Algebra of Programming?
22:14:55 <dolio> At least it's newer than Can Programming Be Liberated from the von Neumann Style?
22:15:13 <ddarius> dejones: No, but it's one of the few Haskell-related books I'm actually interested in.
22:15:45 <adu> I don't remember what WhyFP was about, but I pity C++ programmers now for some reason...
22:15:49 <dejones> ddarius: yea, the topic seems quite interesting... just $145 is a lot for the book.  :(
22:16:00 <adu> I wonder if they're connected
22:16:11 <ddarius> Yeah, the price tag is why I haven't bought it.  Try your local university library.
22:16:31 <dejones> ddarius: hmm, but I want to own it.  ;)
22:16:39 <dejones> ddarius: I don't like giving books back that I enjoy.
22:16:52 <lament> for $145 it better have a really badass hardcover
22:16:52 <gwern> dejones: photocopy it. even at kinkos prices it'll be cheaper than a real copy
22:16:55 <lament> with like, metal locks
22:17:02 <lament> and possibly parchment pages
22:17:02 <ddarius> Actually, if I didn't think I already knew most of what it covers, I might've bought it anyway.
22:17:04 <dejones> gwern: that is true, actually, ha
22:20:06 <geezusfreeek> adu: i pity C++ programmers because i know what it's like most of them don't even seem to know there is a fence, let alone that the grass is greener on this side :)
22:20:26 <geezusfreeek> which is guess keeps them happier
22:20:38 <geezusfreeek> s/is/I/
22:21:05 <solrize> i still never get the sensation of soaring swoopiness from haskell that i got from lisp.  is it there to be found?
22:21:30 <ddarius> solrize: Were you doing some psychoactive drugs at the time?
22:21:37 <Cale> :)
22:21:41 <solrize> well yeah, that's what lisp is, i thought?  :)
22:21:56 <geezusfreeek> solrize: i could actually say the same thing in the other direction
22:22:06 <Cale> I found (common) lisp to be a bit of a let-down actually.
22:22:12 <ddarius> I've never had a sense of soaring swoopiness from any language.
22:22:14 <solrize> CL is a big mess
22:22:24 <Cale> Scheme is a lot nicer.
22:22:29 <geezusfreeek> i like lisp (well, scheme mainly), but it just hasn't seemed very ground-breaking to me
22:23:03 <ddarius> call/cc is interesting.  Macros aren't particularly, useful, but not particularly interesting.
22:23:16 <solrize> http://hpaste.org/7001  see any obvious speedups to this?  like using bytestrings, maybe :)
22:23:17 <dejones> define swoopiness?  lol
22:23:40 <solrize> list structures in every cloud :)
22:23:49 <adu> "swoopiness"?
22:23:55 <geezusfreeek> in fact, i'd say scheme is almost exactly what i would come up with myself if i sat down to make a language in lispy syntax
22:24:24 <adu> yeah, Scheme definitely pwns the Principle of Least Surprise
22:25:24 <adu> perhaps "pwn" was inappropriate
22:25:35 <adu> I meant "utilize"
22:26:02 <solrize> call/cc ?
22:26:32 <adu> well, that should have been (make-return)
22:27:27 <Cale> If I sat down and did something like that today, I think I'd end up with at least an IO monad. ;)
22:27:42 <geezusfreeek> well
22:28:04 <geezusfreeek> i would probably have further limited effects
22:28:15 <geezusfreeek> and monads would have definitely sprung up
22:28:24 <adu> are there any VP tools for monads and arrows?
22:28:33 <geezusfreeek> VP?
22:28:37 <adu> visual programming
22:28:40 <geezusfreeek> ah
22:29:19 <geezusfreeek> i personally think the do syntax as about as visual as you're going to get with monads, and as for arrows, i don't think arrows have been abused enough yet to warrant a VP environment for them
22:30:46 <paczesiowa> what was that global IORef hack and how dangerous it really was?
22:31:11 <dolio> Didn't PLT (or is it some other scheme?) recently add a new set of continuation primitives that were supposed to be better than call/cc?
22:31:28 <adu> paczesiowa: unsafePerformIO ?
22:31:56 <paczesiowa> adu: yeah, but I can't remember rest of the hack
22:32:22 <adu> did it involve ST?
22:33:04 <paczesiowa> I just need global value (assigned once, at the very beginning of main)
22:33:28 <paczesiowa> adu: I can't remember, I was to newbie then to understand it
22:34:25 <scook0> unsafePerformIO can be used to break type-safety, if you create a top-level polymorphic reference
22:34:33 <scook0> i.e. of type IO a
22:34:42 <scook0> (make that IORef a)
22:34:45 <adu> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO-Unsafe.html#v%3AunsafePerformIO
22:34:46 <lambdabot> http://tinyurl.com/5n7xdg
22:35:01 <Riastradh> dolio, it was PLT, and they introduced a native implementation of composable continuations, which are different from (not `better than') CWCC.
22:35:04 <adu> is that it?
22:35:38 <adu> composable continuations? wow!
22:35:45 <dolio> Oh, I see. Well, I'm more a fan of composable continuations myself.
22:36:00 <dolio> But maybe it's because I haven't gone around using the C operator as ddarius suggests.
22:36:31 <adu> so is that like regular continuations with CPS?
22:37:00 <paczesiowa> how about this question: what would you do to model global variable in haskell? carrying it along all the code seems wrong, can't hide it in a monad, because I'd have to lift every line of code
22:37:12 <Riastradh> adu, not unless you clarify what you mean by that.
22:37:25 <adu> CPS = continuation passing style?
22:37:37 <Riastradh> paczesiowa, you modify every line of code to reflect its dependence upon the global mutable.
22:37:46 <Riastradh> adu, `clarify', not merely `expand'.
22:38:22 <paczesiowa> Riastradh: I can't modify qt
22:38:34 <Cale> paczesiowa: what are you trying to do?
22:38:54 <Cale> paczesiowa: You can construct an IORef and pass it to where you need it.
22:39:01 <Cale> (typically)
22:39:14 <Cale> (provided that you're doing something in the IO monad)
22:39:34 <geezusfreeek> paczesiowa: most of the time if you think you need a global, you still don't really need a global ;)
22:39:58 <Cale> If it's a pure computation, I highly recommend just biting the bullet and adding a parameter to your functions where you need it.
22:40:09 <paczesiowa> Cale: I'm rewriting qt tutorial to haskell (just code). in c++ qt there is qapp (QApplication) which is global variable pointing to current program's qapplication. I qt-haskell bindings there is only way to create new qapp at the beginning of main
22:40:11 <adu> something like (call/cc (lambda (r) (begin something (define (func s) (fn (s thing))) (r (call/cc func))))
22:40:34 <Cale> paczesiowa: Right, so just pass that constructed value down to wherever it's used.
22:40:38 <paczesiowa> but there is no way to "get" current qapp and I really don't want to carry it around
22:41:24 <dolio> adu: Composable continuations let you set delimiters, and capture the continuation up to that delimiter.
22:41:35 <cjs> Heh. "Mildred...have you seen Fluffles?"
22:41:41 <adu> oh
22:41:51 <paczesiowa> if I know that it is only created once at the beginning, every modification is in IO, can't I use unsafePerformIO and probe that it's safe?
22:42:03 <geezusfreeek> paczesiowa: if you were to wrap it in a monad, you wouldn't have to lift _every_ line of code you could do very large chunks of code at a time like: lift $ do 
22:42:03 <paczesiowa> *prove
22:42:08 <dolio> So, a composable continuation returns to where it's called, and you can compose them with each other, like functions.
22:42:31 <Cale> Are you sure that just adding a parameter won't work?
22:42:50 <paczesiowa> Cale: it works of course
22:42:52 <Cale> Where are QApplication values used?
22:43:36 <paczesiowa> e.g. you can bind button click signals to qapp quit slots
22:44:12 <paczesiowa> but don't you think that lifting all GUI code or changing types of all the code just to hide one variable is weird?
22:44:33 <Cale> I think using a monad transformer is a bad idea for this.
22:44:41 <dolio> Also known as delimited continuations, subcontinuations (I believe)...
22:44:55 <Cale> But I'm not sure that just passing the variable around by hand is really too much work.
22:45:18 <awesame> doesn't all the GUI code have to be lifted anyway?  GUIs are side-effects...
22:45:31 <paczesiowa> I stay in IO
22:45:36 <Cale> awesame: This one would be in the IO monad.
22:46:14 <geezusfreeek> i guess i'm an odd camper because i'm not afraid to temporarily mutilate code for otherwise small changes like this
22:46:33 <geezusfreeek> and the refactor where i see duplication
22:46:38 <Cale> In these C++ examples I'm seeing, people are just passing the QApplication around directly.
22:46:48 <paczesiowa> if I copy plenty of c++ code (easily mindless transformed to haskell) and then I realise I have to pass qapp from 3 modules and 10 functions upwards it's kinda scary
22:46:56 <geezusfreeek> ah, so even the C++ stuff doesn't depend on a global?
22:47:18 <dejones> is this QT?
22:47:19 <paczesiowa> http://doc.trolltech.com/4.3/tutorial-t4.html this code depends on that global var
22:47:21 <lambdabot> Title: Qt 4.3: Qt Tutorial 4 - Let There Be Widgets
22:47:42 <paczesiowa> dejones: yeah
22:47:42 <Cale> paczesiowa: After you make the change, the type system will better express the dependence on that information.
22:47:56 <Cale> paczesiowa: It will be clear which functions do things with the QApplication and which don't.
22:48:05 <adu> YEY!
22:48:08 <dejones> paczesiowa: I don't think QApplication needs to be a global.
22:48:15 <adu> o wait, n/m
22:48:28 <dejones> paczesiowa: pretty certain that it shouldn't be global.
22:48:49 <paczesiowa> dejones: did you read that particular tutorial?
22:48:51 <paolino> what is wrong with a ReaderT ?
22:49:01 <dejones> paczesiowa: yea, they are not using a global in the code.
22:49:12 <Cale> uhh... there's a global in that code at all?
22:49:21 <paczesiowa> connect(quit, SIGNAL(clicked()), qApp, SLOT(quit()));
22:49:23 <Cale> dejones: right, it doesn't look like there's a global.
22:49:30 <paczesiowa> qApp
22:49:41 <Cale> paczesiowa: They're passing it explicitly as a parameter.
22:50:06 <Cale> er, oh
22:50:12 <Cale> Where is qApp declared?
22:50:19 <paczesiowa> I don't know c++, but I don't see that
22:50:20 <dejones> paczesiowa: qApp is declared by QT as a global so you can connect signals such as trying to quit from anywhere... but you don't have to do it that way.
22:50:23 <Cale> Is it a library-defined value?
22:50:31 <dejones> Cale: yes.
22:50:34 <geezusfreeek> "The QApplication object is accessible through the instance() function which return a pointer equivalent to the global qApp pointer."
22:50:35 <paczesiowa> "The qApp pointer is a global variable declared in the <QApplication> header file. It points to the application's unique QApplication instance."
22:50:48 <dejones> paczesiowa: it is defined by QT.
22:50:48 <Cale> Oh, well, why not use that then?
22:50:56 <adu> paczesiowa: maybe you can't find qApp being defined because it is produced by moc?
22:51:06 <dejones> paczesiowa: you don't have to use it though, you can catch the quit() signal with your widget.
22:51:22 <Cale> @where qt
22:51:22 <lambdabot> I know nothing about qt.
22:51:41 <Cale> Where is the haddock for the QT binding?
22:51:53 <Cale> (or the source code, I suppose)
22:52:04 <geezusfreeek> http://qthaskell.sourceforge.net/index.html ??
22:52:04 <lambdabot> Title: qtHaskell
22:52:26 <paczesiowa> geezusfreeek: sounds good, but I don't see equivalent in qt-haskell
22:52:26 <dejones> paczesiowa: why are you trying to use qApp?  I program with QT and C++ every day.  :)
22:52:31 <paolino> Cale: what is wrong with a ReaderT (IORef a) ?
22:52:59 <paczesiowa> dejones: I'm trying to semi-automatic translate c++ code to haskell
22:53:11 <Cale> paolino: It's clunky if you don't wrap it up in a newtype, and too heavyweight for this problem.
22:53:24 <dejones> paczesiowa: I'm working on a large project, thousands of lines of code, and we have never used qApp.  ;)
22:53:48 <adu> dejones: in Qt?
22:53:55 <dejones> adu: yes, Qt and C++.
22:53:58 <adu> o
22:53:59 <paczesiowa> that doesn't prove it's not needed:>
22:54:19 <dejones> paczesiowa: that's why I asked what you are trying to do with it... so I can tell you how to accomplish what you need without qApp ;)
22:54:37 <dejones> or at least try to :)
22:54:52 <paczesiowa> in qthaskell examples qapp is being passed around, but I would like simpler mindless method
22:54:54 <Cale> You could also simply write a function to peek at that pointer.
22:55:14 <Cale> (The Haskell binding to QT might already have such a function)
22:55:24 <paolino> Cale, ok , so nothing intrinsecally wrong
22:55:42 * paolino fears mtl lately
22:55:47 <paczesiowa> dejones: I know that there are other ways to do that, I just would like to stay as close to c++ as possible
22:56:04 <Cale> paolino: It's doable. It's just that monad transformers are more a tool of library design than of application programming.
22:56:16 <dejones> paczesiowa: right.  you still haven't told me what the qApp is used for... you just said it is passed around, but to accomplish what?
22:56:16 <adu> paolino: matrix template library?
22:56:29 <paczesiowa> Cale: there are no docs for qthaskell, and I don't see any function with name that sound like returning qapp
22:56:38 <paolino> simply monad transformers
22:56:50 <paczesiowa> dejones: rewriting qt tutorial:P
22:57:32 <Cale> app <- qApplication
22:57:41 <Cale> ;)
22:57:49 <geezusfreeek>  easy button
22:57:50 <Cale> The first line of the calculator example :)
22:58:10 <paolino> qApplication wraps instance
22:58:10 <paczesiowa> this is creating new qapplication
22:58:34 <paczesiowa> when I call it second time and try to bind to quit() slot it doesn't work
22:58:43 <geezusfreeek> i thought i read from the docs that it's a singleton
22:58:46 <Cale> mm, so what does qApp supposed to give you?
22:58:53 <geezusfreeek> i would think that it wouldn't make a new one every time
22:58:59 <Cale> is*
22:59:18 * geezusfreeek is not familiar with qt at all
22:59:43 <paczesiowa> wait, I'll hpaste
22:59:55 <dejones> paczesiowa: for that example, do this instead:      connect(quit, SIGNAL(clicked()), this, SLOT(closeWidget()));  void closeWidget() { this->close(); }
23:00:04 <hpaste>  Paczesiowa annotated "qt tutorial" with "qt tutorial 4" at http://hpaste.org/6983#a1
23:00:09 <dejones> paczesiowa: that will accomplish the same thing as qApp and quit().
23:00:46 <dejones> paczesiowa: you can use the QWidget method close() to close the widget instead of having the quit() slot handled by qApp.
23:01:40 <Cale> What are the second and fourth parameters of qObject_connectSlot?
23:01:56 <Cale> (just out of curiosity)
23:02:05 <paczesiowa> dejones: it really isn't problem itself, it's the general solution. there are plenty of more useful methods for qapp
23:02:15 <paczesiowa> Cale: names of Signal and Slot
23:02:25 <Cale> paczesiowa: Do they ever take parameters? :)
23:02:46 <paczesiowa> funny thing is, in c++ you can misspell them and it will compile fine and fail at runtime
23:02:53 <Cale> heh
23:02:59 <Cale> beautiful design
23:03:00 <paczesiowa> Cale: these don't, others do
23:03:06 <dejones> paczesiowa: http://doc.trolltech.com/4.2/mainwindows-application.html -- have a look here... most examples don't actually use qApp (that I know of)... they usually have the class you've declared for your GUI to handle those things like close() events.
23:03:12 <lambdabot> Title: Qt 4.2: Application Example
23:03:32 <dejones> paczesiowa: what's a useful method for qApp?  I don't know of any...
23:05:11 <paczesiowa> dejones: I have written 3 qt apps in my life (tutorial1, tutorial2 and tutorial3), so all I know is that there are funky looking functions in qt-haskell "documentation" like e.g. qApplication_desktopSettingsAware
23:05:50 <dejones> paczesiowa: from my experience, you don't use qApp.. you use the class you have created for your GUI, which may be a child class of QApplication, which gives you access to the methods that qApp would have.
23:05:59 <Cale> paczesiowa: I'm going to go with the "pass it around yourself" answer for now :)
23:06:30 <dejones> Cale, paczesiowa: I don't know about in Haskell, but seriously, qApp isn't used normally for the C++ programs.  :)
23:06:31 <Cale> paczesiowa: If you really find yourself needing access to that pointer, we can try to use the FFI to get at it.
23:07:07 <dejones> anyway, I gotta get some sleep
23:07:12 <dejones> g'night Cale and paczesiowa
23:07:12 <dejones> :)
23:07:14 <dejones> good luck!
23:07:15 <paczesiowa> bye
23:07:40 <paczesiowa> Cale: isn't it hard to FFI with c++ ?
23:08:00 <Cale> paczesiowa: It can be tricky.
23:08:10 <Cale> paczesiowa: We might have to determine the pointer's mangled name.
23:08:41 <paczesiowa> Cale: wouldn't that be unportable and g++ version varying?
23:08:44 <Cale> Clearly the QT binding people have figured it out :)
23:09:01 <paczesiowa> yeah, maybe I'll try to contact them
23:09:29 <Cale> You could just ask them to add you a function which peeks at that pointer (in IO)
23:09:47 <paczesiowa> but I'm worried that qthaskell is dead, they released only 1 version and that's it
23:11:12 <Cale> dejones claimed that qApp is basically never used in the C++ QT applications that he's seen, so perhaps it won't be a problem
23:11:16 <paczesiowa> sigh, it would be so much easier to use gnome&gtk
23:11:33 <Cale> Gtk2Hs is rather well supported.
23:12:11 <paczesiowa> Cale: I know that. I've written few gtk2hs apps, but I use kde and I don't like the way gtk apps look
23:12:38 <Cale> I should perhaps also point out that another solution to this problem of distributing variables constructed in main to event handlers (at least in small programs) can be solved by pushing the event handlers down into a let block inside your main.
23:13:04 <Cale> (then all the variables bound by earlier actions will be in scope)
23:13:50 <Cale> Of course, that doesn't scale so nicely, but it's still moderately handy to do sometimes.
23:13:57 <paczesiowa> yeah, that's the way I use gtk. but all I'm trying is to rewrite qt tutorial, not to use those hello-world apps:>
23:15:38 <dejones> paczesiowa, Cale: http://www.techlists.org/archives/programming/pythonlist/2004-01/msg01723.shtml
23:15:42 <lambdabot> Title: PyQT: qt.qApp, http://tinyurl.com/63zld3
23:15:48 <dejones> That's a response about qApp
23:16:05 <dejones> as I said, you create an object that inherits QApplication and you get all that you might use qApp for
23:16:05 <dejones> :)
23:16:14 <dejones> so, no need to pass qApp around
23:16:24 <dejones> anyway, g'night... (really going this time! :)  hehe
23:20:24 <paczesiowa> dejones: ok I'll make an exception and pass it in tutorial4:>
23:20:36 <dejones> :) g'night
23:23:10 <Frem> Stupid noob question: why does "test r x y = (r + x) xor (r + y)" give an infinite type?
23:23:32 <paczesiowa> don't you mean `xor` ?
23:23:32 <Cale> Frem: you possibly want `xor`
23:23:54 <Cale> Frem: That means "apply the function (r + x) to the parameters xor and (r + y)"
23:24:06 <Cale> Which of course isn't what you want at all :)
23:24:22 <Frem> Oh. Thank you. :-)
23:24:31 <Cale> Putting a function name in backticks (`) turns it into an infix operator.
23:24:53 <paczesiowa> > xor 1 0
23:24:55 <lambdabot>  Add a type signature
23:25:04 <paczesiowa> > xor (1::Int) 0
23:25:06 <lambdabot>  1
23:25:14 <paczesiowa> > (1::Int) `xor` 0
23:25:15 <lambdabot>  1
23:26:03 <Beelsebob> > (1 :: Int) `xor` 2
23:26:04 <lambdabot>  3
23:26:13 <Beelsebob> fair enough
23:29:28 <twb> If I make a type alias "type Board = (Side, Side)", can I "override" the instance of show :: (x,y) -> String with my own custom show :: Board -> String ?
23:29:51 <Riastradh> No.
23:30:00 <twb> I have to use "data Board = ..." right?
23:30:04 <Riastradh> Use a new type, not a type alias.
23:30:15 <Riastradh> That or `newtype Board = Board (Side, Side)'.
23:30:36 <twb> Hmm, I'll look up the semantics of that.
23:30:42 <paczesiowa> why do you always suggest newtype?
23:30:48 <Riastradh> I do?
23:31:00 <paczesiowa> "you" like "you all"
23:31:24 <paczesiowa> isn't it only optimization?
23:31:35 <sclv> as compared to data, not as compared to a type alias.
23:31:35 <geezusfreeek> paczesiowa: well, you sure can't define type class instances for aliases :)
23:31:45 <Riastradh> It expresses a slightly different intent from a new algebraic data type.
23:31:56 <cjs> Is there a standard function that does '\a -> return a'?
23:32:05 <paczesiowa> return?
23:32:08 <scook0> cjs: uh, return?
23:32:13 <sclv> also, newtype deriving is super lovely.
23:32:17 <cjs> Oops. Duh!
23:32:30 <scook0> eta-reduction ftw :)
23:32:50 <Riastradh> Specifically, `newtype' expresses the intent of looking at an existing type in a different way, without introducing any fundamentally new representation.
23:32:59 * cjs obviously still has a way to go before FP becomes instinctual.
23:33:24 <lament> 'type' does that
23:33:35 <paczesiowa> Riastradh: seems like (usually) unnecessarry optimization to me
23:33:36 <geezusfreeek> it's not just an optimization either. it has different semantics as well. for Foo _|_, if Foo is defined with data then just its contents are _|_, but if Foo is a newtype then the whole thing is _|_
23:34:04 <twb> Is there a more elegant way to define a mancala board's state than a 12-tuple of ints?
23:34:25 <paczesiowa> I'm pretty sure that newbies don't know the difference with bottoms
23:34:28 <lament> geezusfreeek: i think the reason for that rule is purely in ease of implementation
23:34:42 <Beelsebob> twb: I'd represent it as a list of piece positions
23:34:57 <paczesiowa> haskell is scary enough to beginners
23:34:59 <sclv> newtype deriving ftw!
23:35:01 <twb> Beelsebob: hmm, there are 6*12 pieces
23:35:04 <Riastradh> paczesiowa, I didn't say anything about optimization.  The difference of intent is more important, and it is only a convenient corollary that it permits certain optimization.
23:35:07 <geezusfreeek> lament: i think it actually reflects the intended usage. a newtype is just another way to look at its contents rather than a box
23:35:19 <twb> Beelsebob: and unlike chess, the pieces are all identical
23:35:53 <paczesiowa> twb: what's wrong with tuples?
23:35:58 <lament> geezusfreeek: as in, once people decided they want newtypes, they realized that by far the easiest way to implement them is as the old type. The rule about _|_ follows from that implementation, not necessarily from the abstract idea of what newtypes are supposed to accomplish.
23:36:05 <twb> paczesiowa: just that it gets tedious.
23:36:11 <Beelsebob> twb: yep, so data Position = R1C1 | R1C2 | ... | R2C6, newtype Board = Board [Position]
23:36:14 <sclv> i can't underline this enough -- if you newtype a monad stack, you can derive all the instances you want, and override all the instances you don't. If you use data, you don't get that.
23:36:31 <Beelsebob> ofc you may want to use Ints for the positions instead of enumerating them
23:36:33 <twb> Beelsebob: hmm, I shall have to think about that.
23:36:45 <paczesiowa> twb: how about writing first few primitive functions that work on those tuples?
23:36:47 <twb> Oops, I also forgot about capture trays
23:37:11 <Beelsebob> twb: advantage -- moving pieces about is easier, disadvantage -- displaying the board is harder
23:37:19 <twb> Beelsebob: I think you're right.
23:37:30 <lament> twb: I propose [Int]
23:37:31 <geezusfreeek> lament: but that semantic rule is what guarantees that a newtype really changes nothing about runtime behavior
23:37:57 <lament> ah, good point
23:38:08 <Beelsebob> twb: perhaps Position = LTray | RTray | Pot (Int,Int)
23:38:16 <sclv> on the other hand, for Board [Position] I'd use a type alias.
23:38:24 <dolio> Stricly speaking, you don't need to know the particular implementation of newtypes to get the rule about _|_.
23:38:38 <dolio> Which is probably good, because I imagine the report doesn't specify how to implement them.
23:38:38 <Beelsebob> sclv: I'd use newtype simply because I'd want to define show nicely on it
23:38:58 <lament> you don't need newtype for that
23:39:01 <dancor> @pl do{f<-metaf;args<-makeArgs;f args}
23:39:01 <lambdabot> (line 1, column 3):
23:39:01 <lambdabot> unexpected "{"
23:39:01 <lambdabot> expecting letter or digit, variable, "(", operator or end of input
23:39:12 <sclv> except then are you going to define a nice read too? elsewise, you're better off writing a custom showBoard function.
23:39:18 <paczesiowa> lists are ugly, they are meant to support nondeterminism. there is nothing nondeterministic about Board
23:39:18 <EvilTerran> @. pl undo do{f<-metaf;args<-makeArgs;f args}
23:39:18 <lambdabot> (makeArgs >>=) =<< metaf
23:39:23 <EvilTerran> huh
23:39:31 <EvilTerran> @undo do{f<-metaf;args<-makeArgs;f args}
23:39:31 <lambdabot> metaf >>= \ f -> makeArgs >>= \ args -> f args
23:39:40 <lament> if haskell had dependenly typed tuples
23:39:49 <lament> then it would be okay to use a tuple for the board position
23:39:53 <lament> but it doesn't, so it's not okay
23:40:00 <lament> because the size of the board should be changeable
23:40:03 <sclv> @palmoar
23:40:03 <lambdabot> Unknown command, try @list
23:40:05 <lament> hence, [Int]
23:40:19 <sclv> @palomer
23:40:19 <lambdabot> As someone who's studied GADTs, I've never found a use for them.
23:40:21 <geezusfreeek> i think a cyclic zipper would be awesome
23:40:25 <sclv> @palomer
23:40:25 <lambdabot> Category theory is the Paris Hilton of mathematics
23:40:33 <dancor> @pl metaf >>= \ f -> makeArgs >>= \ args -> f args
23:40:33 <lambdabot> (makeArgs >>=) =<< metaf
23:40:35 <dancor> wow
23:40:37 <sclv> oh man these are gold.
23:40:40 <lament> except not [Int], but type Board = [Int] and a bunch of functions on Board
23:40:42 <geezusfreeek> lol
23:40:49 <lament> geezusfreeek: oooh that's actually a good idea
23:41:02 <EvilTerran> dancor, i think you want metaf <*> makeArgs
23:41:17 <EvilTerran> or write Control.Applicative.<*> as Control.Monad.ap
23:41:19 <lament> geezusfreeek: although i think it would only make the program more complex :)
23:41:29 <geezusfreeek> probably
23:41:39 <lament> but that's very cute
23:41:44 <geezusfreeek> but i still wanted to say it just because it sounds cool
23:41:46 <sclv> what would make it cyclic -- if you hit the end, you "wrap" to the beginning?
23:42:02 <lament> there's no end and beginning
23:42:05 <lament> it's cyclic :)
23:42:18 <twb> 16:38 <Beelsebob> twb: perhaps Position = LTray | RTray | Pot (Int,Int)
23:42:27 <twb> Beelsebob: nah, 12 is small enough (unlike chess' 64)
23:42:34 <geezusfreeek> i imagine an implementation would look like the typical purely functional queue structure
23:42:50 <geezusfreeek> where you reverse the other side when you run out
23:42:52 <twb> Beelsebob: also mancala positions are really linear not a coordinate
23:43:09 <sclv> it would really just be a sequence.
23:43:15 <lament> that's not true for all games in the mancala family
23:43:18 <lament> some are played on 4 rows
23:43:24 <lament> 2 rows per player
23:43:29 <twb> lament: ssh, I will not listen!
23:43:56 <geezusfreeek> sclv: well, except that if you modify a cell then the cell 12 hops away should also have that modification
23:44:09 <lament> type Board = [Int] -- to me, hits the balance between clarity of expression and convenience
23:44:52 <twb> So a position is one of the two capture trays OR an int, such that A1 = 0 and B1 = 6
23:45:03 <twb> This would make sewing easier since then you just increment the Int
23:45:43 <olsner> sewing? sowing?
23:45:52 <twb> Or, since the capture trays are essentially just score, data Position = Board (Int, Int, [Int]) -- the two scores plus the positions of remaining pieces
23:45:58 <twb> olsner: sorry, right
23:46:22 <lament> EUREKA
23:46:31 <sclv> structurally I just meant a sequence has O(1) cons and snoc.
23:46:39 <geezusfreeek> ah, yes
23:46:40 <lament> type Position = (Int -> Int)   -- functions from state-before-turn to state-after-turn
23:46:58 <lament> then you fold all Positions over an initial board to replay the game!
23:46:59 <sclv> because, you know, mancala requires very high performance. :-)
23:47:09 <Beelsebob_> lament: hehe, I like that
23:47:15 <twb> And then a "Game" datatype is just (board, player1monad, player2monad)
23:47:15 <Beelsebob_> I'd call the type Move though
23:47:20 <lament> okay
23:47:24 <geezusfreeek> oh that is beautiful :P
23:47:30 <olsner> mancala's probably a comonad or some other uselessly abstract thing :P
23:47:49 <lament> you need a function makeMove -> Int -> Move -> Move
23:48:05 <lament> er
23:48:09 <lament> it should really be called Position, not Move
23:48:11 <hpaste>  Paczesiowa annotated "qt tutorial" with "qt tutorial 4 with global qapp hack" at http://hpaste.org/6983#a2
23:48:18 <lament> hold on let me hpaste this
23:48:19 <paczesiowa> I feel so dirty!
23:48:39 <Beelsebob_> lament: don't you mean makeMove :: Move -> Game -> Game?
23:49:22 <olsner> paczesiowa: wow :D
23:49:37 <twb> aha!
23:49:38 <lament> no. hold on
23:49:43 <twb> newtype Position = Int
23:49:57 <twb> Then I can redefine summation of positions such that 11+1 = 0
23:50:07 <Beelsebob_> hehe
23:50:46 <sclv> oh man. that can't all be necessary.
23:50:56 <twb> Elegance trumps necessity
23:51:14 <Beelsebob_> sclv: I don't think any of this is necessary... it's just lots of interesting ideas
23:51:23 <sclv> i'm talking r.e. the paste, not the game.
23:51:33 <Beelsebob_> oh, I see
23:52:10 <Beelsebob_> sclv: yeh, that really is quite nasty
23:52:13 <Beelsebob_> yay for nib files
23:52:26 <sclv> paczesiowa: can't you just create the IO ref in your main function, then pass it in to the myWidget function?
23:53:22 <dolio> Can't you just write a functional reactive programming framework on top of qthaskell?
23:53:38 <paczesiowa> sclv: that's not the point:>
23:54:02 <paczesiowa> dolio: I've never used any of those high-level gui toolkits
23:54:17 <dolio> Neither have I.
23:54:22 <dolio> They look nice in papers, though.
23:55:58 <twb> What's the haskell equivalent of Lisp's make-list :: Int -> x -> [x]
23:55:59 <sclv> or, um, if its global, why can't the myWidget function just call qApplication directly?
23:56:11 <paczesiowa> replicate?
23:56:17 <dolio> > replicate 5 2
23:56:17 <lambdabot>  [2,2,2,2,2]
23:56:22 <twb> Thanks
23:56:43 <sclv> i feel like i'm missing something fundamental here.
23:57:21 <sclv> one could also wrap all the nasty qApplication (or IORef to such) passing in a nice pretty ReaderT ?
23:57:35 <dolio> sclv: In general, you'd have more than one myWidget.
23:57:36 <paczesiowa> sclv: I don't know, I have to call at the beginning of main. if I call it again it doesn't work
23:57:47 <dolio> And don't want to stick your whole program in Reader, I guess.
23:57:54 <paczesiowa> dolio: correct
23:58:27 <sclv> I dunno -- sticking yr. whole program in reader seems preferable to this.
23:59:09 <paczesiowa> can you imagine thousands LOC wrapped in ReaderT just because of one stupid global var?
23:59:09 <sclv> (the unsafePerformIOs should be marked with NOINLINE pragmas too, no, just to be safe?)
23:59:35 <sclv> the're in IO anyway, what's the harm :-P
23:59:35 <twb> Is there a built-in datatype that implements a "cycle" of exactly n things that "wrap around", i.e. the largest thing (n-1) plus the first thing (1) is equal to the zeroth thing (0).
23:59:35 <EvilTerran> if you wrap the monad transformer stack in a newtype with module of appropriately-lifted fundamental actions, it shouldn't be too bad
23:59:36 <paczesiowa> and I think those unsafePerformIOs can be proven to be referentially transparent
23:59:44 <twb> Eek, home time!
23:59:59 <sclv> even as is, it can be cleaner.
