00:00:49 <jsnx> hello
00:01:05 <jsnx> > read "foo" : Int
00:01:08 <lambdabot>   Not in scope: data constructor `Int'
00:01:14 <jsnx> > read "foo" :: Int
00:01:16 <lambdabot>  Exception: Prelude.read: no parse
00:01:39 <Beelsebob> > read "98324" :: Int
00:01:39 <lambdabot>  98324
00:02:36 <jsnx> > reads "foo" :: Int
00:02:37 <lambdabot>  Couldn't match expected type `Int'
00:03:39 <jsnx> :t reads
00:03:40 <lambdabot> forall a. (Read a) => String -> [(a, String)]
00:03:57 <quicksilver> geezusfreeek: in wx (similar situation) they provide start :: IO () -> IO (0
00:04:06 <quicksilver> geezusfreeek: which you have to warp your 'main' in if you want stuf to work.
00:04:16 <quicksilver> geezusfreeek: I might guess there is something similar for haskell SDL.
00:04:28 <quicksilver> @where kuribas-indentation
00:04:29 <lambdabot> I know nothing about kuribas-indentation.
00:04:31 <geezusfreeek> so i have to somehow convince GHC not use look for a "main" function?
00:04:50 <geezusfreeek> *not to look
00:04:51 <quicksilver> Cale: eh? did the @where database get lost?
00:05:00 <OceanSpray> dang.
00:05:06 <quicksilver> geezusfreeek: I would think SDL provides a function to do it, but I'm not sure.
00:05:09 <OceanSpray> I installed yi, but can't find the executable.
00:05:15 <Cale> quicksilver: I think the State somehow got messed up
00:05:34 <geezusfreeek> quicksilver: well, i'm slapping my forehead now. found a nice readme in the source download for the sdl bindings
00:05:45 <geezusfreeek> i had used cabal-install, so i didn't see this before
00:05:46 <quicksilver> @where+ kuribas-indentation http://kuribas.hcoop.net/haskell-indentation.el
00:05:46 <lambdabot> Done.
00:06:05 <quicksilver> Cale: would be relatively simple in principle to grep the logs for @where+ statements and reinstate
00:09:47 <Cale> @quote
00:09:52 <lambdabot> matthew-_ says: wow, haskelldb is amazing. the type system tells me when I've forgotten to select certain columns!
00:09:57 <quicksilver> @tell kuribas haskell-indentation doesn't understand case-guards?
00:10:02 <lambdabot> Consider it noted.
00:10:07 <Cale> @where+ kuribas-indentation http://kuribas.hcoop.net/haskell-indentation.el
00:10:12 <lambdabot> Done.
00:12:20 <Cale> (I restored a bunch of state from the darcs lambdabot0
00:12:25 <Cale> )*
00:14:21 <mauke> @quote mauke
00:14:21 <lambdabot> mauke says: ｓｔｅｒｅｏ
00:14:28 <paolino> > runWriter (tell (Just ['a']))
00:14:28 <lambdabot>  ((),Just "a")
00:15:28 <jsnx> did readMaybe get accepted?
00:21:29 <geezusfreeek> grr, the readme is basically useless since it refers to files that don't exist
00:23:09 <quicksilver> Cale: nice!
00:25:09 <quicksilver> @quote quicksilver
00:25:09 <lambdabot> quicksilver says: someone with artistic talent should do a drawing entitled unsafePerformMetamorphosis
00:25:37 <quicksilver> @quote quicksilver
00:25:37 <lambdabot> quicksilver says: learning from other people's mistakes is so web 1.0
00:27:04 <Cale> haha
00:27:48 <hpaste>  povman pasted "Why not polymorphic?" at http://hpaste.org/7025
00:29:45 <quicksilver> povman: dreaded monomorphism restriction
00:30:05 <povman> how come the compiler didn't say that?
00:30:25 <quicksilver> povman: either turn that off, or add an explicit parameter to place
00:30:30 <mauke> > let f = length in (f "x", f [()])
00:30:30 <lambdabot>  (1,1)
00:30:38 <quicksilver> because your code was incorrect haskell :)
00:30:56 <povman> urh
00:30:58 <quicksilver> h98 says that let bidnings without parameters must be monomorphic
00:31:02 <quicksilver> the type infererer knows that, and your types didn't match.
00:31:07 <mauke> > let f = show in (f "x", f [()])
00:31:08 <lambdabot>  ("\"x\"","[()]")
00:31:23 <mauke> > let f <- Just show in return (f "x", f [()])
00:31:23 <lambdabot>  Parse error at "<-" (column 7)
00:31:27 <quicksilver> lambdabot has it turned off.
00:31:34 <mauke> > do f <- Just show; return (f "x", f [()])
00:31:34 <lambdabot>  Couldn't match expected type `Char' against inferred type `()'
00:31:38 <mauke> no, it doesn't
00:32:13 <povman> ahh i see...
00:32:19 <quicksilver> yes, it does.
00:32:34 <dolio> lambdabot might have the monomorphism restriction turned off.
00:32:37 <povman> cheerses then
00:32:38 <mauke> oh
00:32:50 <quicksilver>  let f = show in (f "a", f [()]) is invalid haskell98
00:33:05 <mauke> I think I get it
00:33:25 <quicksilver> povman: many people are not in favour of this restriction :) indeed it has been suggested to remove it for haskell'
00:34:03 <povman> what bad things can you do without it?
00:34:13 <quicksilver> it's a question of expectations and sharing
00:34:29 <quicksilver> people "expect" let bindings without parameters to indicate sharing
00:34:50 <Japsu> hmm
00:35:09 <Japsu> what makes that example invalid haskell98? where does the monomorphism restriction come into effect?
00:35:29 <quicksilver> Japsu: the type of show is polymorphic
00:35:42 <Japsu> :t show
00:35:46 <quicksilver> Japsu: when I "let" it into f, f gains a monomorphic type.
00:35:50 <lambdabot> forall a. (Show a) => a -> String
00:36:00 <quicksilver> (because let bindings without parameters must be monomorphic)
00:36:14 <quicksilver> then the type inferer tries to unify it with String -> String and also () -> String
00:36:18 <quicksilver> which is not possible
00:36:21 <Japsu> ahh, ok
00:37:41 <povman> it'd be nice to have named instances of classes, so you could pick which instance you wanted something to be in
00:37:53 <povman> eg different Shows for some type
00:38:10 <quicksilver> it would, in some ways.
00:38:20 <quicksilver> there turn out to be serious problems with this idea though
00:38:30 <povman> ?
00:38:46 <quicksilver> imagine two different Ord instances for one type
00:38:55 <quicksilver> now feed some elements into a Map using one instance
00:38:59 <quicksilver> and try to pull them out using another
00:39:11 <quicksilver> a second example would be two different Binary isntances for a type
00:39:26 <quicksilver> the assumption that global instances are, in deed, global runs pretty deep.
00:39:58 <opqdonut> well some type hackery could do away with the map problem
00:40:35 <povman> how about if it wasn't multiple instances of one class, but one instance per class with a variable
00:40:44 <povman> (but we already have that don't we :p)
00:40:44 <geezusfreeek> yay looks like i get to learn some FFI if i want to do this :\
00:40:53 <quicksilver> opqdonut: it's only an example of the problem, though.
00:41:16 <quicksilver> opqdonut: you end up having to embed "Which instances I used" inside every object whose invariant depends on instance choice
00:41:23 <opqdonut> yeah, it would need some serious reworking of the bassse libs
00:41:29 <quicksilver> for Map, that means embedding the Ord in the map itself
00:41:39 <quicksilver> fo ByteString, it means embedding the Binary instance into the ByteString
00:41:44 <quicksilver> this feels a bit weird...
00:41:46 <opqdonut> shuffling dictionaries, mhmm
00:41:59 <quicksilver> passing dictionaries by hand is often a more sane solution :)
00:42:03 <quicksilver> you can see what you're doing, then
00:42:40 <Japsu> hmm
00:43:00 <povman> it seems almost equivalent to make a data with fields for functions
00:43:09 <Japsu> if I want to have different Binary representations for a type, would newtyping them suffice?
00:43:10 <quicksilver> it is precisely equivalent, yes.
00:43:15 <quicksilver> that's what classes are, povman :)
00:43:19 <povman> i see.
00:43:25 <quicksilver> except that the fields get filled in automatically by the type checker
00:43:27 <opqdonut> Japsu: yeah
00:43:31 <Japsu> right
00:43:31 <quicksilver> choose the dictionary based on the type.
00:43:34 <opqdonut> that's what newtypes are for
00:44:08 <quicksilver> yes, newtypes is a good solution
00:44:09 <quicksilver> it feels clunky, but it solves all the problems here discussed :)
00:44:32 <quicksilver> manual "dictionary" passing is a good solution to some problems though
00:44:35 <quicksilver> people overuse classes
00:44:48 <quicksilver> classes are only the right choice when the global dictionary-per-type makes sense
00:44:56 <povman> the syntax is horrible though!
00:45:12 <quicksilver> higher order functions let you do much more flexible things
00:45:16 <quicksilver> mix and match "methods"
00:45:24 <quicksilver> it feels a bit like a prototype-based object system
00:45:33 <quicksilver> in that you can override the methods for any one value
00:45:36 <povman> and ghc's head explodes with polymorphic field selectors (or something?)
00:46:01 <quicksilver> rather than trying to shoehorn it into classes
00:46:08 <quicksilver> I think the head-explosion is for GADT-field-selectors
00:46:16 <quicksilver> polymorphism is fine, I use it all the time
00:46:21 <quicksilver> (normally with existential types)
00:46:44 <povman> oh yeah them
00:46:50 <povman> blegh
00:46:58 <povman> i stop talking now
00:47:33 <quicksilver> here's a simple example I pasted 6 months ago :)
00:47:34 <quicksilver> http://hpaste.org/3558
00:47:51 <quicksilver> "Behaviour" is like a manual dictionary
00:48:34 <povman> did you notice that defining Behaviour's is a pain in the syntax?
00:48:41 <opqdonut> hmm, nice
00:48:52 <opqdonut> povman: well no it is'nt really
00:48:59 <opqdonut> less characters than a type class :)
00:49:18 <povman> not the defn itself, the instances
00:49:33 <quicksilver> povman: it's mildly annoying that you have a paramete floating around alreadys
00:49:38 <quicksilver> (the 's' parameter)
00:49:41 <quicksilver> but otherwise it was ok
00:49:52 <povman> i mean with all the lambdas
00:50:27 <povman> unless i'm missing something about named fields and constructors
00:50:58 <povman> i have a similar thing: stringEditor = Editor "String Editor" (bui) val sel rep, where bui val sel and rep are functions
00:51:01 <quicksilver> yes, it owuld be nice to be able to write named fields in function notation
00:51:03 <quicksilver> instead of lambda notation
00:51:03 <quicksilver> but, it doesn't bother me too much
00:51:14 <povman> i'm too picky then :)
00:51:51 <quicksilver> feel free to newtype everything if you prefer, then :)
00:51:57 <quicksilver> but I find that worse, personally.
00:52:08 <quicksilver> and it's nice to be able to base some particles' behaviour on others'
00:52:20 <opqdonut> well you can use function notation in a where or let
00:52:36 <quicksilver> yup, but then you need an extra name for everything
00:52:41 <quicksilver> to join the fields to the where
00:52:52 <quicksilver> which is OK, too, but it's added back the token you just saved ;)
00:52:58 <Vq^> quicksilver: i would like two Ord classes actually
00:54:18 <povman> could you have something like
00:55:00 <DRMacIver> quicksilver: There's a GHC extension for pulling record fields in from their environment isn't ther?
00:55:48 <povman> maximum :: (Ord t) ==> (t a) => [a] -> a
00:56:02 <DRMacIver> Hm. I can't find it now. augustss was talking about it a while ago though.
00:59:09 <povman> where Ord would be a ... kind?
00:59:21 <DRMacIver> Ord is a type class
00:59:32 <Vq^> DRMacIver: not in that example
00:59:36 <DRMacIver> Oh. Sorry, yes
00:59:47 <DRMacIver> I just realised it didn't have the obvious type signature. :)
00:59:50 <DRMacIver> Still waking up
01:00:28 <Vq^> povman: so Ord is some kind of metatypeclass?
01:00:32 <povman> yeh
01:00:39 <Saizan> (ugh, an Uniq name supply implemented with an IORef Int in a reader monad over IO, in a typechecker prototype!)
01:00:41 <Vq^> povman: what functions is available for it?
01:00:46 <povman> the regular ones
01:01:10 <dblhelix> Saizan: reading the rank-n paper? :-)
01:01:27 <Saizan> dblhelix: the FPH one
01:01:50 <povman> actually that wouldn't achieve anything
01:02:08 <dblhelix> Saizan: FPH?
01:02:22 <povman> what we really want is parameterised type classes... or i just don't know what i'm talking about
01:02:27 * dblhelix (almost literally) wants to buy a vowel :-)
01:02:36 <Vq^> povman: you want maximumBy :P
01:02:39 <Saizan> dblhelix: First-Class Polymorphism for Haskell
01:02:59 <povman> that'll do
01:03:15 <Saizan> http://research.microsoft.com/~simonpj/papers/boxy/
01:03:15 <lambdabot> Title: Simon Peyton Jones: papers
01:03:32 <dblhelix> Saizan: ah, okay
01:03:58 <Vq^> povman: it's also fairly easy to create wrappers around types that have a special class instance
01:04:14 <povman> is this the newtype thing? what's that?
01:04:28 <Vq^> povman: you can use data as well
01:04:47 <olsner> hmm, I need a unionsWithM that can take a monadic union function (in IO, in this case)
01:04:52 <Vq^> data MyList a = MyList [a]
01:04:57 <olsner> I'd probably have to write that myself, right?
01:05:00 <Vq^> instance Ord MyList where ....
01:05:05 <povman> ohh of course...
01:05:13 <Saizan> dblhelix: i wanted to see if it could type test1 here http://hpaste.org/7024, but i get in trouble even for bar (modulo datatypes)
01:05:24 <opqdonut> olsner: yeah i guess it's the most straightforward way
01:05:26 <povman> i feel like such a noob when i come here
01:05:37 <opqdonut> you could combine sequence, mapM and filterM in some fashion to get that, probably
01:05:46 <Vq^> povman: same here :)
01:07:46 <olsner> hmm, could probably do something with first taking the symmetric difference and putting that in a do-nothing list then do intersectionWith (,) and do my IO-union on that list, then put it back together again
01:07:47 <dblhelix> Saizan: but that makes sense, right? baz bar shouldn't type, should it?
01:07:59 <geezusfreeek> okay, i'm using foreign export to make a haskell function available to a C file. what is the best practice for working this with cabal? should i include the _stub.h file in version control? as it is now, cabal tries to compile the C file before any of the haskell files, so the stub isn't generated yet and it fails
01:08:58 <olsner> this might not be as gruelsome as first anticipated... with that I can get a unionWithM that I can combine with foldM into unionsWithM
01:12:48 <dblhelix> Saizan: mmm, wait a minute... I misread your snippet... now it seems it should type
01:12:59 * dblhelix pours himself another cup of coffee
01:14:32 <geezusfreeek> oh well, i'll just add the stub to version control for now
01:14:39 <geezusfreeek> yay it compiles! at last
01:15:56 <geezusfreeek> now it's definitely bedtime
01:23:02 <Lemmih> Is it possible to reconstruct a data declaration from a proxy type using SYB?
01:29:05 <solrize> vs h = b:vs a
01:29:05 <solrize>    where (a,b) = h `divMod` 26
01:29:29 <solrize> is there a simple way to write that as an iterate or somethign?
01:30:01 <solrize> i.e. (n%26, (n/26)%26, (n/(26**2))%26, ...
01:30:33 <opqdonut> map (%26) $ iterate (/26) n
01:30:35 <opqdonut> ?
01:30:46 <solrize> hmm
01:30:52 <solrize> thanks i'll try that
01:31:15 <quicksilver> opqdonut: iterate (`div` 26) ITYM
01:31:29 <opqdonut> yeah
01:31:32 <quicksilver> opqdonut: the problem is if you only keep the sequence of remainders
01:31:36 <quicksilver> you don't know when to stop
01:31:44 <quicksilver> (zero remainder doesn't mean stop!)
01:31:52 <quicksilver> you do also need to keep the sequence of quoteitns
01:31:54 <solrize> yeah i'm just using take n $ ...
01:32:00 <solrize> i.e. i want a fixed number of remainders
01:32:03 <quicksilver> so it ends up being a list of pairs whichever way
01:32:11 <quicksilver> ah, well, if you know how many "digits" it is before hand
01:32:12 <quicksilver> then that's fine
01:32:30 <solrize> it seems a little ugly, doing the division twice like that instead of using divMod
01:32:59 <solrize> maybe i'll just stay with the recursive version since the map/iterate ends up a messier version of the same thing
01:34:17 <czakey> @botsnack
01:34:17 <lambdabot> :)
01:34:23 <solrize> i really have to resort to an experimental hackage module to encode a string as utf8 bytes?
01:34:41 <quicksilver> depends what you think 'experimental' means :)
01:34:49 <solrize> well, ghc crashed when i tried to compile it
01:34:54 <solrize> and the version number is < 1
01:35:39 <quicksilver> I believe you have a choice between utf8-string and encoding
01:36:06 <quicksilver> oh, and iconv
01:36:13 <solrize> hmm ok, encoding was the one that crashed, i'll try utf8-string
01:36:42 <quicksilver> of course, a simple utf8 encode function is about 5 lines of haskell
01:36:48 <quicksilver> and decode is only slightly worse
01:36:57 <solrize> oh, iconv looks good
01:37:24 <solrize> hmm it operates on bytestrings
01:37:45 <quicksilver> http://blog.kfish.org/2007/10/survey-haskell-unicode-support.html
01:37:45 <lambdabot> Title: blog.kfish.org: Survey: Haskell Unicode support
01:37:49 <quicksilver> might be interesting to you
01:39:23 <solrize> thanks, yes, it is interesting
01:39:59 <solrize> i know that standard unix tools like grep, wc, etc. are woefully slow unless you use LC_ALL=C so i hope the iconv library isn't the cause...
01:40:52 <solrize> i guess for this program i can live with a slowdown
01:43:15 <solrize> how is UnicodeString going to work?  will it be something like UCS4 under the covers?
01:48:16 <quicksilver> solrize: UTF8, I imagine
01:48:46 <quicksilver> if you wanted "something like UCS4" then you just want a packed array of Char
01:48:47 <quicksilver> I suppose
01:48:58 <quicksilver> better support for packed arrays is also on the requested feature list
01:49:02 <solrize> yeah, makes sense
01:51:45 <dcoutts_> solrize: in fact it doesn't matter what encoding it is underneath, we'll just pick whatever encoding is fastest
01:52:39 <solrize> right that makes sense too, i must have been thinking in terms of accessing random characters, and computing the length
01:52:46 <dcoutts_> hia krasimir
01:52:49 <krasimir> hi
01:52:55 <dcoutts_> @seen ibid
01:52:55 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
01:52:59 <dcoutts_> oops :-)
01:53:47 <krasimir> wasn't there a template for alex that works directly with bytestring? I remember that I heard something about that but I can't find it
01:54:23 <krasimir> oh. i found it
01:54:25 <krasimir> sory
01:55:24 <dcoutts_> krasimir: yes, I added it and I think it made it into the latest release
01:55:43 <dcoutts_> krasimir: I've not had much feedback on it though, I don't know if it's really any faster
01:55:57 <dcoutts_> krasimir: so let me know how you get on if you end up using it
01:58:30 <quicksilver> solrize: Yeah. If you wanted quick random access you'd want something more like packedChars
01:59:35 <quicksilver> like I say, convenient packed arrays or packed lists are independently handy
01:59:46 <quicksilver> (quite independent of questions about encoding)
02:00:08 <dcoutts_> I don't understand why people want random access into unicode text strings
02:00:19 <dcoutts_> nobody asks for fast random access into [Char]
02:00:27 <solrize> i have a question abouttoChunks -- how does it know where the chunks should be?
02:00:57 <dcoutts_> solrize: because the internal representation uses chunks
02:00:59 <quicksilver> dcoutts_: that's a very good point.
02:01:35 <solrize> i'm looking at this json module, which has a function that parses a ByteString
02:01:41 <dcoutts_> solrize: so it's really just exposing a view of the internal representation (it's not the actual internal representation)
02:02:34 <solrize> so if i want to use Data.ByteString.Lazy to read from a file, then i have to use toChunks to get strict bytestrings for the parser, but they have to start and end at the right places from the file
02:03:31 * dcoutts_ thinks parsers should use lazy bytestrings as input
02:03:39 <solrize> that would be really cool
02:04:44 <dcoutts_> solrize: so if your json parser requires strict bytestrings then you'll have to either read the file as a strict one, or if you only want to parse segments of the file then you'll have to split it yourself first
02:05:10 <solrize> the file is very large and contains a lot of json strings that i want to parse separately
02:05:15 <dcoutts_> solrize: of course you can always concatenate a list of strict bytestrings into a single strict bytestring, but it involves copying the whole lot
02:05:27 <solrize> the file is too large for that, it won't fit in ram
02:05:47 <dcoutts_> solrize: unless you happen to have a single chunk in which case it's O(1)
02:06:13 <solrize> these json strings will usually be a few hundred bytes to make a few kb, but depending on that doesn't seem nice
02:06:18 <solrize> make -> maybe
02:06:36 <dcoutts_> solrize: sounds like you need to identify how to split the big string into individual json strings
02:06:47 <dcoutts_> solrize: or does that in fact involve parsing them?
02:06:50 <solrize> yes, i had thought toChunks was the function for that
02:07:13 <dcoutts_> no that just splits arbitrarily based on the underlying representation
02:07:13 <solrize> well in my original input file, there's one json string per line, so identifying them is trivial
02:07:19 <dcoutts_> oh great
02:07:34 <dolio> That'd be lines.
02:07:38 <solrize> however the json module writes them out on multiple lines so they're deliminted by lines containing just a "}"
02:07:46 <dcoutts_> solrize: so (Strict.concat . Lazy.toChunks) . Lazy.lines
02:08:09 <solrize> hmm
02:08:24 <dcoutts_> an in practise most of those lines will be a single chunk so there will be no copying
02:08:31 <solrize> Lazy.lines gives an infinite stream of lines
02:08:37 <dcoutts_> you'll only get copying when a line spans a chunk boundary
02:08:37 <solrize> then Lazy.toChunks will give a stream of chunks
02:08:46 <dcoutts_> oh, wrong type...
02:08:55 <dcoutts_> map (Strict.concat . Lazy.toChunks) . Lazy.lines
02:09:18 <dcoutts_> for each line we turn it into a strict bytestring (usually zero-copy)
02:09:22 <solrize> aha, for each lazy.line, one or more chunks comes out and then the chunks get concatenated
02:09:23 <solrize> very nice
02:09:53 <solrize> what about recognizing lines that are just "}" ?
02:09:57 <dcoutts_> solrize: right, and since most of the time the IO chunk size is bigger than the line size then you don't get much copying
02:10:19 <dcoutts_> solrize: [ l | l <- lines input, l == pack "}" ]
02:10:55 <solrize> that selects just those "}" lines
02:11:07 <dcoutts_> right but you get the idea, it's not hard
02:11:13 <dcoutts_> just us ordinary operators and functions
02:11:14 <solrize> but yeah i see, pack is the way to convert a regular string to a bytestring
02:11:59 <hpaste>  solrize pasted "separating json records" at http://hpaste.org/7026
02:12:45 <solrize> bates is named after "bates stamp" (rubber stamp with a mechanism that generates an incrementing serial number)
02:12:57 <solrize> is that code pretty awful?
02:13:11 <solrize> it's based on something that i do with python iterators
02:14:21 <solrize> someone last night suggested map (drop 1) . Data.List.filter ((=="}") . head) . tails
02:14:25 <solrize> which wasn't quite the right thing
02:14:34 <solrize> maybe i can get something like that to work
02:15:29 <dcoutts_> sorry, it's not entirely obvious to me what it's supposed to be doing
02:16:03 <solrize> given a stream of lines like ["{","a","b","}","{","x","y","}", ...]
02:16:35 <solrize> it's supposed to split that into records: [["{","a","b","}"], ["{","x","y","}"] ... ]
02:17:14 <solrize> what i really want is just a list of bytestrings "{a,b}", "{x,y}" ...
02:17:37 <solrize> with newlines still in
02:18:39 <solrize> i like that bates stamp idiom in python because python iterators are mutable and there's just a ton of ways to screw up by advancing one too many times, forgetting to return the last record, etc
02:18:48 <solrize> and the stamping scheme fixes all that
02:18:51 <dcoutts_> solrize: so can't you just count the brackets?
02:18:57 <ToRA> > groupBy (\l r -> not $ last l == '}' && head r == '}') . words $ "{ a b c d , e f g } { h i j }"
02:19:00 <lambdabot>  [["{","a","b","c","d",",","e","f","g","}","{","h","i","j","}"]]
02:19:04 <solrize> that gets messy, there can be quoted strings inside the json that have brackets inside
02:19:09 <ToRA> erm
02:19:31 <ToRA> ok, more subtle than i thought...
02:19:32 <solrize> so the brackets aren't necessarily balanced unless you parse the strings
02:19:37 <dcoutts_> right
02:19:51 <opqdonut> just use parsec
02:20:07 <solrize> well the json module i'm using uses a parsec-like module already
02:20:10 <solrize> packrat parser
02:20:29 <solrize> it's pretty complicated, i don't understand it
02:21:00 <solrize> and it's "competing" speedwise with a python extension that's written in C
02:22:13 <solrize> anyway the json parser works pretty well, given a way to separate the json strings from one another
02:22:45 <solrize> so i got rid of the problem by using filter to get rid of the embedded newlines on output
02:22:55 <solrize> but that just seems ugly
02:24:03 <solrize> basically i'm trying to replace a chain of python scripts whose total running time is something like 10 hours, my life would be a lot easier if i can get it to under an hour
02:26:36 <solrize> which i think should be well within reach given the amount of redundant serialization in the python stuff, plus haskell being inherently a lot faster
02:26:50 <ToRA> > map unwords . groupBy (\l r ->  not $ (last l == '}' || head r == '{')) . words $ "{ a } { d }"
02:26:50 <lambdabot>  ["{ a }","{ d }"]
02:27:05 * solrize discovered the secret of making haskell run fast: use -O3  :)
02:28:12 <solrize> ToRA thanks, i'm still poring over that
02:28:24 <ToRA> solarize: it's probably very fragile though
02:28:38 <solrize> if i use lines instead of words it may be ok
02:29:31 <ToRA> i'm not sure about how safe the head / last are... it'll become messy with empy lines etc.
02:29:51 <solrize> or if i rewrite my bates-stamp version to use bytestrings then it should be plenty fast enough
02:30:06 <dcoutts_> solrize: btw, -O3 = -O2  and you get almost all the benefits at -O1 (= -O)
02:30:34 <solrize> i didn't try O2, but i found that -OO3 really beat -O
02:30:39 <solrize> -O3
02:30:47 <solrize> and -O made a huge difference over no optimization
02:30:52 <dcoutts_> -ON is capped at 2
02:31:28 <dcoutts_> solrize: if you find -O2 beats -O1 then great, use it, but don't take it as a general rule
02:31:28 <solrize> well ok, anyway -O2 was a significant speedup
02:31:57 <dcoutts_> there are many cases where -O2 just takes longer to compile and generates more code but doesn't run any faster
02:32:37 <solrize> i guess for now the compilation speed is ok, the programs are pretty small so they don't take too long
02:32:48 <solrize> but thanks
02:32:51 <dcoutts_> -O is a good default and use -O2 when timing results tell you that it's significantly better
02:33:33 <solrize> sounds reasonable
02:40:21 <solrize> anyway, i better get some sleep, thanks everyone and gnite
03:21:46 <quicksilver> dcoutts_: I always use -O11
03:22:02 <dcoutts_> hah
03:22:04 <opqdonut> :D
03:22:06 <quicksilver> dcoutts_: only the best optimisers will go up to 11
03:22:25 <dcoutts_> quicksilver: doesn't ndm's Super'O go to -O11?
03:22:29 <opqdonut> llvm actually has optimizationlevels up to 7
03:22:31 <dcoutts_> I seem to recall it does
03:22:47 <EvilTerran> -Orly
03:23:05 <opqdonut> what's the status on ghc alternatives btw?
03:23:20 <opqdonut> are they still pretty much h98?
03:23:28 <EvilTerran> ISTR yhc has some of the extensions
03:24:59 <dcoutts_> opqdonut: hugs has many of the same language extensions
03:25:29 <dcoutts_> then jhc, ehc, yhc and nhc98 have a scattering of common ones
03:25:58 <opqdonut> ehc?
03:26:04 * malcolmw was amused to see that the BBC's iPlayer volume control goes up to 11
03:26:10 * dcoutts_ hoped someone would pick up on ehc :-)
03:26:17 <dcoutts_> malcolmw: heh, nice
03:26:51 <dcoutts_> opqdonut: another as-yet-unreleased haskell compiler from the Utrecht guys
03:27:05 <dcoutts_> based on the Utrecht toolchain, attribute grammars etc
03:27:20 <malcolmw> dcoutts_: unreleased?  I thought it was now public
03:27:23 <dcoutts_> but also using grin as an intermediate language and bytecode, C or llvm as backends
03:27:38 <dcoutts_> malcolmw: yeah, public but not released
03:27:46 <dcoutts_> it's probably in some svn somewhere
03:27:56 <dcoutts_> I visited them the other day
03:27:57 <malcolmw> http://www.cs.uu.nl/wiki/Ehc/WebHome
03:28:29 <dcoutts_> and I asked about releases, they want to fix more bugs first before getting a flood of bug reports about known issues
03:28:39 <dcoutts_> hopefully we'll see something before ICFP
03:29:45 <malcolmw> there was an IFL presentation (maybe even a paper) about ehc last year
03:31:25 <malcolmw> yep, the paper was accepted for the final IFL proceedings: "The Structure of the Essential Haskell Compiler, or Coping with Compiler Complexity"
03:35:32 <quicksilver> malcolmw: yes, that always makes me smile :)
03:36:24 <quicksilver> dcoutts_: I think -O11 was a codename for supero
03:36:28 <dcoutts_> right
03:36:43 <dcoutts_> it's a good name
03:37:07 <dcoutts_> or perhaps -O!!1
03:37:37 * quicksilver thinks "flood of bug reports" is a poor excuse, personally.
03:37:47 <quicksilver> You don't have to run a bug tracker, or make it public, if you don't want to.
03:38:04 <dcoutts_> > let noooooo!!!!11 = 1 in 1!!!!1
03:38:05 <lambdabot>   Non-exhaustive patterns in function !!!!
03:38:40 <quicksilver> let !!!111oneoneone = 1 in...
03:39:14 <quicksilver> my brother works in a building which has '111oneoneone' engraved as its house number
03:39:20 <quicksilver> always makes me think of leetspeak
03:40:02 <dcoutts_> leetspeak or letspeak?
03:40:14 <czakey> :>
03:40:42 <dcoutts_> > let noooooo!!!!11 = 1 in 1!!!!11
03:40:42 <lambdabot>  1
04:14:23 <grom358> can anyone point me to the pros and cons of haskell compared to ocaml?
04:19:15 <sjanssen> grom358: you can hardly expect an unbiased opinion here :)
04:20:00 <grom358> I mean.. do you know of some web link that compares them? I'm trying to figure out which I want to spend some coding time in
04:20:56 <EvilTerran> well, that's an easy one. haskell.
04:21:32 <EvilTerran> ocaml has (IIRC) a more conventional type system, but i can't think of anything else off-hand that it has over haskell
04:21:52 <sjanssen> grom358: Haskell is pure and lazy, OCaml is strict and not pure
04:22:11 <sjanssen> each of these attributes can be pros or cons depending on who you ask :)
04:22:53 <dolio> Haskell is totally awesome - pro
04:22:59 <dolio> OCaml is hella lame - con
04:23:26 <sjanssen> grom358: what are you looking for in a language?
04:24:44 <dolio> Type classes vs. modules have their areas where one excels over the other.
04:25:07 <grom358> well I'm looking to learn functional programming. I like HOF and type inference. And I like the look of type classes from what I read so far
04:25:31 <osfameron> there are some comparisons on performance between ocaml/haskell
04:25:57 <sjanssen> grom358: Haskell probably has more to teach you than OCaml
04:26:01 <dolio> Haskell seems somewhat more closely connected to research than OCaml.
04:26:34 <sjanssen> with Haskell, you'll have to write purely functional code, you can't use the imperative crutches built in to OCaml
04:26:36 <dolio> As in, people doing research, not necessarily that OCaml is theoretically unfounded or something.
04:28:15 <dolio> OCaml's macro/metaprogramming system is supposed to be nice.
04:29:06 <dolio> More extensive than template haskell.
04:29:26 <grom358> I've been work on a little turn-based board game in python (in prototype stage atm). So its got a bit of state for the objects in the world. Thinking about moving over to functional language, especially for when I get to AI stuff.
04:29:45 <byorgey> Haskell has an awesome IRC channel - pro
04:35:54 <dolio> OCaml will better prepare you for ugly Coq syntax when you want to check out dependent typing.
04:36:08 <grom358> and I've never quite felt at home with noun-centric OO code
04:40:30 <grom358> well so far I've read YAHT
04:40:34 <byorgey> ...but Haskell will better prepare you for nice Agda syntax when you want to check out dependent typing. =)
04:40:56 <dolio> Yeah, but Agda is currently somewhat impoverished compared to Coq.
04:41:29 <dolio> Although it does have its things that it does nicely compared to Coq.
04:41:37 <byorgey> well, that probably doesn't make too much of a difference when just learning about dependent types.  at least, it hasn't made a difference to me yet.
04:42:18 <dolio> You're not modelling general recursion using coinductive types? :)
04:42:25 <byorgey> the most obvious difference to me so far is that Agda makes a lot of sense, while I found Coq to be incomprehensible. =)
04:42:35 <quicksilver> grom358: ocaml has some trivial but annoying hangups
04:42:53 <byorgey> dolio: why, no, I don't believe I am =)
04:42:53 <quicksilver> which despite being trivial stop me using it.
04:42:53 <dolio> Heh.
04:42:53 <quicksilver> constructors not being functions.
04:42:54 <quicksilver> the value restriction.
04:43:04 <quicksilver> 'fun' being too many characters long.
04:43:09 <byorgey> constructors aren't functions? then how do you construct things?
04:43:23 <quicksilver> they're a special syntactic token
04:43:26 <quicksilver> not an expression
04:43:27 <dolio> quicksilver: So Arc did get that right!
04:43:33 <quicksilver> so you can write "Just 1"
04:43:38 <quicksilver> but not "map Just [1]"
04:43:44 <quicksilver> because the former is a special form
04:43:51 <quicksilver> and the latter is trying to use 'Just' as a function.
04:43:59 <byorgey> oh, I see, so you can write Foo x y  (or the equivalent) but can't partially apply Foo, or pass it to another function, etc.?
04:44:04 <byorgey> right
04:44:05 <quicksilver> exactly.
04:44:07 <byorgey> that stinks.
04:44:08 <quicksilver> it's hella annoying.
04:44:18 <quicksilver> I ended up with a function-version of all my constructors.
04:44:23 <byorgey> hehe
04:44:34 <byorgey> foo x y = Foo x y
04:44:38 <quicksilver> and the value restriction is a disaster for writing combinators.
04:44:49 <quicksilver> you break abstraction by having parameters everythwere
04:44:53 <quicksilver> trivial but really annoying.
04:45:09 * sjanssen started a reddit flamewar about that once :)
04:45:19 * byorgey makes mental note to avoid learning OCaml as long as possible
04:45:34 <quicksilver> ocaml has some interesting things, though.
04:45:38 <quicksilver> "Extensible" ADTs
04:45:44 <quicksilver> they're quite interestin.
04:45:50 <quicksilver> ML functors are nice things.
04:46:00 <sjanssen> quicksilver: are those also called 'polymorphic variants'?
04:46:15 <quicksilver> a "Simpler" evaluation model arguably makes performance easier to understand
04:46:27 <quicksilver> sjanssen: yes, although I don't think that name is as clear :)
04:46:36 <sjanssen> quicksilver: yes, I agree
04:46:47 <sjanssen> I'd prefer "first class sum types", or something like that
04:46:56 <quicksilver> as someone else mentioned, the preprocessing stuff is neat
04:47:00 <quicksilver> but TH is actually cleverer
04:47:12 <quicksilver> TH is typed, ocamlp4 is not. Well, not in the same way.
04:47:22 <quicksilver> but TH is quite hard to use, many people find :)
04:47:38 <dolio> ocamlp4 actually lets you extend the parser, too, no?
04:47:45 <quicksilver> yes
04:47:54 <quicksilver> that's trivial but extremely handy
04:48:07 <quicksilver> many of these differences are "trivial" but represent a huge change in practice :)
04:49:15 <dolio> I don't know how trivial that is. I imagine extenstible parsers aren't easy.
04:51:47 <dolio> Of course, I haven't used it, so I don't really know.
04:54:09 <wjt> Is there a solid reason why map Just couldn't work?
04:55:49 <solrize> @pl \Just x -> x
04:55:49 <lambdabot> const id
04:55:51 <araujo> morning
04:56:01 * sjanssen suspects it is a deficiency in the compiler
04:56:14 <Deewiant> @pl \(Just x) -> x
04:56:14 <lambdabot> (line 1, column 8):
04:56:14 <lambdabot> unexpected "x"
04:56:14 <lambdabot> expecting operator or ")"
04:56:44 <MarcWeber> Having something like data Feed = forall ft. (FeedClass ft) => Feed ft
04:57:12 <MarcWeber> can't I just tell ghc to derive FeedClass Feed for me (calling the function defined for all ft instances) ?
04:57:18 <solrize> @pl \(Just x) -> x
04:57:18 <lambdabot> (line 1, column 8):
04:57:18 <lambdabot> unexpected "x"
04:57:18 <lambdabot> expecting operator or ")"
04:57:44 <MarcWeber> solrize: There is only unJust
04:57:49 <solrize> fromJust
04:57:55 <sjanssen> MarcWeber: I don't think cunning newtype deriving is quite that smart
04:58:14 <Deewiant> there's fromMaybe as well
04:58:23 <sjanssen> MarcWeber: it also isn't possible in all cases, depending on the definition of FeedClass
04:58:52 <MarcWeber> solrize: and maybe (default) (mapFunc) (Just / or Nothing)
04:59:32 <solrize> yeah i was looking for something more general, but not now .  i'll mess with it more later
04:59:38 <solrize> thanks
04:59:56 <MarcWeber> solrize: for what then?
05:00:12 <solrize> i mean thanks for the suggestions
05:00:33 <MarcWeber> I got that :) just beeing curious..
05:00:35 <solrize> i don't understand them right now but am in the middle of something
05:00:35 <solrize> oh
05:00:45 <solrize> umm, i'm trying to scrap some boilerplate :)
05:00:55 <solrize>        (Object m) `jS` field =
05:00:55 <solrize>           let String s = fj field m in s
05:00:55 <solrize>        (Object m) `jN` field =
05:00:55 <solrize>           let Number x = fj field m in x
05:00:55 <solrize>        fj f m = fromJust $ M.lookup f m
05:01:11 <solrize> the json module makes this union type
05:01:32 <solrize> and i want to pull the different types of values out of it
05:01:39 <solrize> which looks like pasting the same code over and over again
05:02:08 <solrize> but i think i am giving up on that approach and leaving it dynamic
05:02:25 <MarcWeber> sjanssen: It is straight forward http://rafb.net/p/xlAeRN70.html. In this case its just boilerplate code I have to write..
05:02:27 <lambdabot> Title: Nopaste - No description
05:02:28 <solrize> i'll just deconstruct the union wherever the parts are needed
05:02:36 <sjanssen> solrize: fj is equivalent to Data.Map.!
05:03:05 <sjanssen> MarcWeber: yep, you have to write it
05:03:14 <solrize> sjanssen, oh, heh, nice, thanks!
05:03:19 <sjanssen> MarcWeber: GHC could derive an instance for that class, but there are some that it can't
05:03:53 <sjanssen> consider: class Monoid a where mempty :: a; mappend :: a -> a -> a
05:03:59 <MarcWeber> sjanssen: I'm using ghc 6.8.2 . So which option to enable ?
05:04:22 <sjanssen> MarcWeber: 'could', not 'can' :)
05:05:23 <MarcWeber> solrize: I'v only started using RJson..
05:05:36 <solrize> RJson?  hmm i think that came up a couple nights ago
05:06:09 <solrize> oh yes, that used a bunch of scary packages so i stayed with JSON.hs
05:06:19 <MarcWeber> solrize: You are not talking about RJson? oh..
05:06:26 <MarcWeber> It has some union types as well
05:06:30 <solrize> no another package that i found at json.org
05:06:40 <solrize> rjson uses reflection and parsec and warns of being slow
05:06:56 <solrize> the json.org one uses a packrat parser which is reasonably fast (haven't compared with parsec)
05:07:08 <dolio> RJson only uses, like, two packages that don't come with GHC.
05:07:26 <solrize> but json is an important enough format that i hope someone writes a really optimized version sometime
05:08:10 <dolio> array and containers were split out of base in 6.8 or thereabouts.
05:08:35 <solrize> out of base?  they're still included with the compiler
05:08:53 <byorgey> yes, but in separate packages
05:08:58 <dolio> Yeah. They're just not all lumped in the base package anymore.
05:09:12 <dolio> So they can theoretically be updated without a full compiler update.
05:09:13 <solrize> you mean the compiler comes with this hackage stuff pre-installed?
05:09:36 <solrize> oh there's that library add-on thing
05:09:41 <dolio> It comes with parsec, too.
05:09:50 <solrize> yeah
05:10:08 <dolio> Although there's a newer version of that on hackage now than there is in 6.8.2.
05:10:18 <solrize> right, parsec3 does bytestrings
05:10:45 <solrize> i've heard that happy parsers are faster than parsec's though, not surprising since happy generates compiled code
05:10:59 <dolio> iconv and syb-with-class are the only things you'd definitely need from hackage.
05:11:13 <solrize> and the packrat parser is combinators but doesn't backtrack
05:11:32 <MarcWeber> solrize: I think it]'s the same with XML.. There are at least 4 idfferent XML parsers, one using Parsec, one using polyparse, not sure about which xst us really using.. Some bindings to xpath
05:11:39 <solrize> yeah i think the json module i'm using is simpler and less scary than using generics
05:11:47 <solrize> all the xml parsers are way confusing
05:11:54 <solrize> the good one is supposed to be hxt if i remember right
05:11:56 <solrize> and that uses arrows
05:12:20 <solrize> so i'm converting this stuff to use json instead of xml except at the last phase where xml is needed
05:12:24 <MarcWeber> solrize: So I wonder why HAppS is using HaXml..
05:12:25 <solrize> and then i'm just generating that xml as strings
05:13:01 <solrize> hmm i dunno, happs seems to attack every problem head-on
05:13:14 <shepheb> I think HAppS is older than HXT
05:13:18 <solrize> that could be
05:13:37 <henrylaxen> Another mystery for me.  When I run the two programs below,
05:13:37 <henrylaxen> death results in a stack underflow, while life happily returns
05:13:37 <henrylaxen> 99900.  Is it possible that Data.Map has problems with large
05:13:37 <henrylaxen> maps, or am I doing something stupid.  Any insights would be
05:13:41 <henrylaxen> appreciated
05:13:43 <henrylaxen>  
05:13:47 <henrylaxen>  
05:13:48 <solrize> *** Exception: Prelude.head: empty list
05:13:49 <henrylaxen> import qualified Data.Map as M
05:13:53 <henrylaxen> import Control.Monad.State
05:13:55 <henrylaxen>  
05:13:58 <solrize> henrylaxen please use hpaste.org
05:13:59 <henrylaxen> loopMap1 :: [Int] -> M.Map Int Int
05:14:01 <henrylaxen> loopMap1 l = execState (f l) M.empty where
05:14:03 <dolio> This is looking bad.
05:14:04 <solrize> stop!!!!
05:14:05 <henrylaxen>   f [] = do return ()
05:14:07 <henrylaxen>   f (l:ls) = do
05:14:11 <henrylaxen>     m <- get
05:14:13 <henrylaxen>     put $! M.insert l l m
05:14:17 <henrylaxen>     f ls
05:14:19 <henrylaxen>  
05:14:23 <henrylaxen> death = loopMap1 [1..100000] M.! 100
05:14:25 <henrylaxen>  
05:14:29 <henrylaxen> loopMap2 :: [Int] -> [Int]
05:14:31 <henrylaxen> loopMap2 l = execState (f l) [] where
05:14:35 <henrylaxen>   f [] = do return ()
05:14:37 <henrylaxen>   f (l:ls) = do
05:14:41 <henrylaxen>     m <- get
05:14:43 <henrylaxen>     put $! l:m
05:14:47 <henrylaxen>     f ls
05:14:49 <henrylaxen>  
05:14:53 <henrylaxen> life = loopMap2 [1..100000] !! 100
05:14:59 <henrylaxen> sorry, will do
05:16:14 <dolio> henrylaxen: What happens if you use 'import Control.Monad.State.Strict'?
05:16:52 * Beelsebob also ponders why he's using the state monad at all
05:17:05 <henrylaxen> that works fine, I'll go look at the source and see why.  Thanks
05:19:50 <DukeDave> henrylaxen: I had some woes with large Data.Map a while back.. Unfortunately I had to move on to another project :(
05:21:50 <dolio> The issue is the state monad in this case, it seem. I forget what exactly what the strict state monad is strict in, but this sort of case is the reason it's in the libraries.
05:24:09 <shepheb> it doesn't seem like that should use the state monad at all. foldl' would be better.
05:24:19 <henrylaxen> It looks like the only difference between State.Lazy and State.Strict is the way >>= is defined in the Monad instance.  Lazy uses 'let' and strict uses a case
05:25:04 <dolio> Yeah. let is lazy and case is strict.
05:25:10 <EvilTerran> ?hpaste in future, henrylaxen
05:25:11 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:25:41 <henrylaxen> EvilTerran: Yes, thank you, now I know.
05:28:54 <shepheb> is there a wiki page on imperative thinking and how to avoid it? this might be a good poster child. then show how it is replaced with: foldl' (flip (:)) [] [1..100000], and foldl' (\m x -> M.insert x x m) M.empty [1..100000]
05:29:39 <Beelsebob> indeed
05:30:12 <shepheb> or, for that matter, the vastly faster M.fromList (map (id&&&id) [1..100000])
05:30:20 <Beelsebob> yep
05:30:25 <dolio> > M.fromList $ zip [1..3] [1..3]
05:30:26 <lambdabot>  fromList [(1,1),(2,2),(3,3)]
05:33:18 <dolio> Anyhow, I guess with lazy state, the result is something equivalent to 'insert 100000 100000 (snd (insert 99999 99999 (snd ...)))'
05:35:55 <henrylaxen> dolio: Then why didn't 'life' also generate a stack overflow?
05:36:23 <dolio> Hmm...
05:36:49 <dolio> Oh, because a list doesn't have to evaluate all the way to look something up.
05:36:57 <Beelsebob> henrylaxen: because that's generating 100000 : 99999 : ....
05:37:06 <Beelsebob> instead of a very large closuer
05:37:09 <Beelsebob> closure*
05:37:31 <nibro> @src pokeByteOff
05:37:31 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
05:38:07 <dolio> So, '100000 : snd (x, 99999 : snd (y, 99998 ...))' can be evaluated incrementally.
05:38:53 <dolio> insert has to go all the way to the innermost (original) map to start evaluating.
05:39:45 <Beelsebob> yay... an excellent demonstration that the popular optimisation techniques aren't the way to go always
05:39:52 <solrize> is there a way to search a bytestring for a substring?
05:39:53 <Beelsebob> Map is slow here *because* it's strict
05:40:51 <dcoutts_> solrize: yes, check the haddock docs, though note that it's deprecated and renamed with a different type in the next version
05:40:59 <dolio> And the $! doesn't help, because the State action doesn't need to be evaluated to the end, either, I guess.
05:41:04 <solrize> hmm ok thanks
05:41:47 <solrize> i don't see it in the ByteString.Lazy.Char8 docs but i think i can get by with split
05:44:57 <solrize> aha, findSubstring, but it's only for strict bytestrings?
05:46:05 <Beelsebob> solrize: because it requries you to evaluate the whole string to do one search?
05:46:05 <dcoutts_> solrize: ah, yes true, we'll add the new breakSubstring function for both
05:46:34 <dcoutts_> Beelsebob: no, just that it was only implemented for strict and we were not happy with either the api or the impl
05:46:38 <solrize> cool, breakSubstring is just what i need.  thanks
05:46:49 <Beelsebob> ah, okay
05:46:52 <dcoutts_> we were not happy with the way it used Int indexes in the result
05:47:12 <saml> how would you parse expression "f 1 2 3"  as haskell data type?  Expr [Fun "f", Int 1, Int 2, Int 3]  ?
05:47:21 <dcoutts_> the rest of the bytestring api uses substrings rather than iterators (Int)
05:47:35 <solrize> i see some operations use Int64 which is probably a better choice
05:47:46 <solrize> the files i'm operating on are generally > 4GB so Int is quite dangerous
05:47:52 <dcoutts_> @type Lsit.span
05:47:53 <lambdabot> Couldn't find qualified module.
05:47:55 <Beelsebob> SamB: more likely App (App (App (Id "f") (Const 1)) (Const 2)) (Const 3)
05:47:57 <saml> many tutorials/books  have App Expr Expr  construct. i'm not sure how to do that
05:48:01 <dcoutts_> @type Data.List.break
05:48:02 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
05:48:27 <saml> Beelsebob: thanks
05:48:32 <dcoutts_> so we're proposing
05:48:32 <dcoutts_> breakSubstring :: ByteString -> ByteString -> (ByteString, ByteString)
05:48:57 <Beelsebob> oh, tab fail, no probs saml
05:49:04 <tromp> it would be nice if the plain Int was alrd 64 bit
05:49:07 <dcoutts_> where the first part is the prefix and the second is either empty (like break) or starts with the search string
05:49:18 <solrize> ideally i'd like a version where the break is -after- the match but i guess i can put up with a little consing to fudge that
05:49:22 <dcoutts_> tromp: it follows the arch word size
05:49:26 <henrylaxen> @help
05:49:26 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:49:36 <henrylaxen> @list
05:49:36 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
05:50:05 <dcoutts_> solrize: it's more general to break at the beginning, you can easily drop
05:50:31 <solrize> i can drop from the second part but i also have to ++ onto the first part
05:50:39 <dcoutts_> solrize: why?
05:50:54 <dcoutts_> you're trying to remove the search term?
05:51:05 <solrize> no i want the search term included in the first part
05:51:14 <dcoutts_> ohh
05:51:17 <solrize> "abcxydef" -> ("abcxy","def")
05:51:20 <dcoutts_> well that's also easy:
05:52:08 <dcoutts_> case breakSubstring key text of (prefix, found) | not (empty found) -> drop (length prefix + length key) text
05:52:08 <tromp> dcoutts: ah yes, i see that it is. nice:)
05:53:33 <solrize> dcoutts, hmm, thanks.  i'd need splitAt but that plays out about the same way
05:53:46 <matthew_-> is there a reason why take does not blow up with its arg is too big?
05:53:49 <matthew_-> > take 5 []
05:53:50 <lambdabot>  []
05:54:12 <dcoutts_> matthew_-: just a design choice, similarly for zip of unequal lengths
05:54:37 <dcoutts_> > zip [] [1..]
05:54:37 <lambdabot>  []
05:54:44 <solrize> > head []
05:54:45 <lambdabot>  Exception: Prelude.head: empty list
05:54:58 <nibro> @paste
05:54:58 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:55:03 <dcoutts_> solrize: there's a clear difference of type there of course
05:55:06 <solrize> if i get an exception like that, is there a way (e.g. compiler flag) to show the line number where the exception was?  and preferably a backtrace
05:55:10 <Beelsebob> I guess to do with the fact, that you can easily construct the other from this implementation
05:55:16 <Beelsebob> but not the other way round
05:55:18 <dcoutts_> solrize: you can use the ghci debugger
05:55:34 <solrize> this would be in compiled code
05:55:41 <dcoutts_> solrize: then no
05:55:42 <Beelsebob> back traces are very hard to recover
05:55:48 <Beelsebob> you can get something like one by using profiling
05:56:00 <dcoutts_> the ghci debugger can give you a backtrace for interpreted code
05:56:03 <Beelsebob> or by using Hat, and hat-stack
05:56:04 <solrize> yeah i guess i understand about backtraces given all the CPS conversion and so forth going on
05:56:26 <Beelsebob> dcoutts_: yeh, I was talking from the compiled code front
05:56:39 <dcoutts_> but why do we care?
05:56:42 <solrize> the other thing i'd really like (though maybe not in the bytestring spirit) is the location in the input file where the error was
05:56:59 <dcoutts_> debugging has an overhead anyway, it's not like we'd be turning it on in production binaries
05:57:15 <dcoutts_> solrize: ghci debugger does give that in the trace
05:57:34 <Beelsebob> dcoutts_: a fair point, but there are people in the world that still like to compile their code (don't ask me why)
05:58:03 <Beelsebob> also, there are debugging techniques out there that only work after the event anyway
05:58:05 <solrize> yeah but i need it with the compiler, i have to crunch gb's of this stuff
05:58:08 <dcoutts_> Beelsebob: I like to compile my code but I accept there's a trade-off
05:58:26 <Beelsebob> dcoutts_: yep, doesn't mean that you can't debug compiled code for example though
05:58:37 <dcoutts_> Beelsebob: indeed
05:58:44 <solrize> being able to do something like ftell on the file descriptor underneath the bytestring would be great
05:58:57 <nibro> could someone who knows hsc2hs have a quick look at this code to see if there are no glaring errors/idiocies in it?
05:59:00 <nibro> http://hpaste.org/7027
05:59:09 <dcoutts_> solrize: of course there may be none
05:59:36 <nibro> it compiles, so it must work right? :-)
05:59:38 <dcoutts_> nibro: ah win32 file change notification, great :-)
05:59:41 <solrize> well in the case where there's ftell...
05:59:47 <nibro> dcoutts_: indeed :-)
06:00:06 <dcoutts_> nibro: it'd be great if we could find some common higher level api between the win32 and linux file change apis
06:00:17 <dcoutts_> nibro: see the hinotify package for the linux case
06:00:31 <nibro> dcoutts_: aye, that's my plan, right after I get this low-level stuff for win32 working
06:00:35 <dcoutts_> great
06:00:42 <nibro> dcoutts_: I've already talked a bit to kolmodin about it
06:01:17 <dcoutts_> oh good, there are plenty of common issues, like how to deal with very fast events flows
06:02:21 <dcoutts_> nibro: you could use the array poking stuff rather than foldM_
06:02:53 <dcoutts_> similarly for reading/peeking
06:03:13 <nibro> dcoutts_: array poking stuff? :-)
06:03:31 <nibro> for the record, this is the first time I ever touch hsc2hs ;-)
06:03:51 <dcoutts_> nibro: Foreign.Marshal.Array
06:04:00 <solrize> this is really like learning programming all over again
06:04:37 <solrize> anyway, laterz.  thanks again as always.
06:05:21 <nibro> dcoutts_: thanks, I'll have a look at that
06:05:35 <nibro> dcoutts_: just for the record though, would the code I just wrote work?
06:05:47 <dcoutts_> nibro: I think the alignment is a bit big, though I'm never quite sure how to calculate it accurately
06:06:10 <dcoutts_> nibro: sizeOf is wrong, doesn't take into account the size of the filename
06:06:52 <dcoutts_> nibro: that C struct is really of variable size
06:07:03 <nibro> dcoutts_: ah, right, of course
06:07:50 <dcoutts_> nibro: you should also check if that WCHAR FileName[1] is supposed to be 0 terminated or not
06:07:59 <nibro> dcoutts_: it's not, that I know
06:08:48 <dcoutts_> so it'll be (#size FILE_NOTIFY_INFORMATION) + #size WCHAR * (length fniFileName - 1)
06:09:08 <nibro> hmm, why the -1?
06:09:13 <dcoutts_> the -1 is because #size FILE_NOTIFY_INFORMATION already includes the WCHAR FileName[1]
06:09:26 <nibro> dcoutts_: ah, thanks!
06:09:45 <dcoutts_> but that's also why I asked about 0 termination
06:09:58 <pejo> nibro/dcoutts, I think bos thought about the quick event flow for Python earlier on, so he might have some input.
06:10:09 <dcoutts_> pejo: yes
06:10:16 <nibro> pejo: aye, I read his blog entry
06:10:23 <dcoutts_> as did kolmodin
06:11:22 <dcoutts_> eg in many cases you only want to watch one file and you don't want to fire off an expensive action for every change
06:11:51 <dcoutts_> you might just want to fire one off if the file changed since the last action was launched
06:12:03 <dcoutts_> ie the actions are never concurrent
06:12:27 <nibro> dcoutts_: there's a problem there with that win32 file notification only works on directories
06:12:52 <dcoutts_> nibro: sure but it does tell you which file changed within the dir
06:13:33 <dcoutts_> the actual low level event processing is fairly cheap, it's the application responses that can be arbitrarily slow
06:13:54 <nibro> dcoutts_: alright, that sounds good :-9
06:13:55 <nibro> :-)
06:16:14 <nibro> dcoutts_: with a variable-sized struct, can I still use alignment = sizeOf?
06:16:31 <dcoutts_> hmm
06:16:32 <nibro> not totally sure what alignment is supposed to do...
06:18:07 <sw17ch> is there a quick way to ask lookup to search for the snd element of the pair rather than the first?
06:18:10 <sw17ch> :t lookup
06:18:12 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
06:18:19 <dcoutts_> nibro: hmm, in theory sizeof and alignment should not look at their args at all
06:18:25 <mauke> map swap
06:18:31 <mauke> where swap (a,b) = (b,a)
06:18:37 <dcoutts_> so apparently a variable sized struct cannot be in Storable at all
06:18:50 <EvilTerran> ?type snd &&& fst
06:18:50 <sw17ch> hmm.. alright. i figured
06:18:51 <lambdabot> forall a b. (a, b) -> (b, a)
06:19:25 <nibro> dcoutts_: eh...? :-\
06:19:42 <EvilTerran> ... could one write something :: Arrow (~>) => (a,b) ~> (b,a) -- ? it'd be useful addition to Control.Arrow, methinks
06:19:45 <nibro> dcoutts_: so then how would I write a binder?
06:20:07 <dcoutts_> nibro: you'd have to do it without using a Storable instance
06:20:31 <dcoutts_> nibro: yep, several functions rely on the fact that the size is a function of the type, not the value
06:20:42 <dcoutts_> nibro: eg alloca :: Storable a => (Ptr a -> IO b) -> IO b
06:21:13 <nibro> dcoutts_: fair enough, so I'll just write specialized 'pokeFNI' etc and use those in the rest of my code?
06:21:32 <dcoutts_> nibro: the Storable class and utils are just a convenience layer on top of the other FFI primitives
06:21:58 <Botje> ?type mirror
06:21:58 <lambdabot> Not in scope: `mirror'
06:22:36 <mauke> I just wrote a simple printf for bytestrings :-D
06:22:43 <EvilTerran> ?type arr (snd &&& fst)
06:22:44 <lambdabot> forall a b (a1 :: * -> * -> *). (Arrow a1) => a1 (a, b) (b, a)
06:22:49 <EvilTerran> well, that was easy
06:23:52 <nibro> dcoutts_: sigh, I need all the convenience I can get :-)
06:24:04 <dcoutts_> nibro: aye :-)
06:24:21 <nibro> dcoutts_: thanks a lot for the info, now I know a lot better where to go from here :-)
06:24:31 <dcoutts_> good good
06:24:34 * nibro is off for some lunch now
06:24:59 <dcoutts_> nibro: check what hinotify does, it must have the same problem
06:25:30 <dcoutts_> @where hinotify
06:25:30 <lambdabot> http://haskell.org/~kolmodin/code/hinotify/
06:26:26 <mauke> or http://rafb.net/p/FZQDBK58.html (my own inotify binding, in case you're interested)
06:26:26 <lambdabot> Title: Nopaste - No description
06:28:12 <henrylaxen> @source System.Directory
06:28:13 <lambdabot> http://darcs.haskell.org/packages/4/System/Directory.hs
06:41:27 <Ted`> http://ircx.forum0.info/ <--- plz register :) thanx
06:42:11 <pejo> @where ops
06:42:12 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
06:42:19 <pejo> Doh. Too slow.
06:42:24 <dcoutts_> @arr!
06:42:25 <lambdabot> I want me grog!
06:44:05 <eliot_> hi. I need quick help. A function returns "Data.ByteString.Internal.ByteString" but I need to pass it to function, which requires "Data.ByteString.Lazy.Internal.ByteString". What should I do?
06:45:29 <mauke> eliot_: L.fromChunks [str]?
06:51:52 <lesshaste> hi
06:52:36 <magthe> a bit off topic... anyone know of good audiocasts for programmers, ideally for functional programmers of course?
06:55:17 <takamu> hi
07:00:36 * EvilTerran concurs with mauke. Data.ByteString.Lazy.fromChunks "Convert a list of strict ByteString into a lazy ByteString"
07:00:43 <eliot_> mauke: thx. it works
07:01:57 <lesshaste> magagr, there are one or two haskell videos
07:02:08 <lesshaste> magagr, and quite a lot of undergrad material available on video/audio now
07:02:45 <lesshaste> magagr, try the usual web searching and mit opencourseware for example
07:04:49 <hpaste>  (anonymous) pasted "Pattern Matching" at http://hpaste.org/7029
07:05:47 <mauke> data Expr = Expr Binop Int Int; data Binop = Add | Sub
07:06:23 <mauke> data Expr = Expr{ binOp :: Binop, args :: (Int, Int) }; data Binop = Add | Sub
07:07:01 <mauke> binOp' = curry . Expr . binOp
07:09:45 <MyCatVerbs> @pl \s -> iden s == k
07:09:46 <lambdabot> (k ==) . iden
07:38:06 <hpaste>  nibro pasted "FILE_NOTIFY_INFORMATION take two" at http://hpaste.org/7032
07:38:21 <nibro> indeed I did :-)
07:38:31 <nibro> dcoutts_: care to take another look?
07:40:06 <dcoutts_> nibro: you can use the offsetof macro to work out where to peek/poke the WCHAR FileName[1];
07:40:18 <dcoutts_> nibro: rather than calculating let n = 3*(#size DWORD)
07:41:02 <dcoutts_> nibro: it's easier and guaranteed to agree with the C compiler irrespective of padding/alignment etc
07:41:25 <nibro> dcoutts_: hehe, I suspected there was something like that ;-)
07:42:06 <nibro> let n = (#offsetof FILE_NOTIFY_INFORMATION, FileName)  ?
07:42:08 <dcoutts_> nibro: incidentally, do you ever need to poke one of these structures? don't you always just read them?
07:42:25 <dcoutts_> nibro: something like that, I don't recall the name, it's in the hsc2hs manual though
07:42:31 <nibro> dcoutts_: indeed I do
07:42:53 <dcoutts_> nibro: so when do you have to write one of these records?
07:43:29 <nibro> dcoutts_: never, I meant indeed I do always just read them
07:43:45 <dcoutts_> nibro: oh ok, so you don't need pokeFNI at all
07:43:50 <nibro> dcoutts_: is this the manual: http://www.cse.unsw.edu.au/~chak/haskell/c2hs/docu/ ?
07:43:55 <lambdabot> Title: The Binding Generator C➔Haskell
07:44:04 <nibro> can't find anything about offset in there, I already looked for it
07:44:05 <dcoutts_> nibro: you're that's c2hs, not hsc2hs
07:44:14 <dcoutts_> you're//
07:44:25 <nibro> doh
07:44:27 <nibro> :-)
07:44:49 * MyCatVerbs grumbles at the lack of a poll/select equivalent.
07:44:50 <dcoutts_> nibro: and NextEntryOffset is presumably referring to the following record in some kind of array (of variable sized records)
07:45:24 <dcoutts_> MyCatVerbs: you've got lightweight threads so you do have poll/select
07:45:25 <nibro> dcoutts_: right, it is, though I only seem to need one at a time, not sure what to do with that one
07:45:48 <MyCatVerbs> dcoutts_: I know threads are theoretically just as capable. In practice, they're a pain in the arse for some structures.
07:46:12 <dcoutts_> nibro: so the higher level function you're constructing is something that returns [(Action, FilePath)]
07:46:15 <MyCatVerbs> dcoutts_: besides, what I want more often is the ability to poll on a set of MVars or Chans.
07:46:54 <nibro> dcoutts_: seems reasonable yes
07:47:30 <nibro> for the record the macro is #offset :-)
07:47:50 <dcoutts_> MyCatVerbs: mm, right, I wonder if there would be any performance advantage to having a primitive that can wait for any of several MVars
07:48:12 <dcoutts_> MyCatVerbs: rather than implementing such a function using more MVars/Chans and threads
07:50:54 <MyCatVerbs> dcoutts_: almost certainly, since "readManyChans" is precisely the function that I'm writing right now in order to prevent myself from going crazy.
07:51:35 <dcoutts_> MyCatVerbs: or perhaps mergeChans?
07:51:45 <dcoutts_> then you can read the merged chan
07:51:54 <MyCatVerbs> dcoutts_: [Chan a] -> IO a, naturally. Plus this involves playing with asynchronous exceptions too, in order to guarantee that I never lose messages.
07:52:32 <dcoutts_> mergeChans :: [Chan a] -> IO (Chan a)
07:52:41 <MyCatVerbs> dcoutts_: hrmn. Considered that, but in this case the set of channels being listened to is constantly being altered. Hell, the place I'm about to use this thing, the channels will have been freshly minted with newChan.
07:53:07 <MyCatVerbs> dcoutts_: plus I really don't want to leak threads, either.
07:53:36 <dcoutts_> surely readManyChans must use threads too, if it's to avoid busy waiting
07:53:57 <MyCatVerbs> dcoutts_: yes, but I kill them all when one of them finally gets something.
07:54:11 <dcoutts_> ok
07:54:43 <MyCatVerbs> dcoutts_: I don't care much about the performance in this case (last time I tried measuring the performance of the program I'm working on right now, it was eating something like 1 CPU second every couple of hours, so whatever.)
07:54:58 <MyCatVerbs> So long as I never busy-wait (always block properly instead) it's fine.
07:55:26 <dcoutts_> right
07:56:49 <MyCatVerbs> Ah, dammit.
07:57:20 <MyCatVerbs> I can't figure out how to do this without dropping messages on the floor.
08:09:17 <dancor> @pl \ x -> [x]
08:09:17 <lambdabot> return
08:09:21 <dancor> hah
08:09:26 <scook0> dancor: (:[])
08:11:41 <Japsu> > fix (:[])
08:11:43 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
08:11:43 <lambdabot>       Expected...
08:12:06 <MyCatVerbs> Ugh. I'm actually starting to think of places where I'd really like to steal C++'s constructors & destructors features.
08:13:11 <vincenz> > fix ([]:)
08:13:13 <lambdabot>  [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],...
08:13:51 <scook0> I like fix show
08:13:56 <MyCatVerbs> > fix show
08:13:57 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
08:14:00 <MyCatVerbs> Hehehehe.
08:14:33 <MyCatVerbs> > fix (\l -> 1 : map (+1) l)
08:14:33 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
08:14:48 <MyCatVerbs> > tails . fix $ (\l -> 1 : map (+1) l)
08:14:49 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
08:14:59 <vincenz> MyCatVerbs: what are you making
08:15:03 <MyCatVerbs> > (!! 40) . tails . fix $ (\l -> 1 : map (+1) l)
08:15:11 <lambdabot>  [41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,...
08:15:15 <MyCatVerbs> vincenz: I'm not, I'm messing around with \bot. ^_^
08:15:35 <scook0> > fix ((1:) . map (+1))
08:15:39 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
08:15:52 <vincenz> MyCatVerbs: previously
08:15:59 <vincenz> MyCatVerbs: you mentioned the Chan stuff and constructors
08:16:26 <gnuvince> :t fix
08:16:28 <lambdabot> forall a. (a -> a) -> a
08:17:13 <vincenz> @let break a = id
08:17:13 <lambdabot> Defined.
08:17:19 <vincenz> > fix  . break $ 1
08:17:19 <lambdabot> Terminated
08:17:28 <MyCatVerbs> vincenz: a program where one of the threads has a section where I need to look out for: events happening in a daughter process (say, segfaults), messages coming from the main control thread, and data from a Handle attached to the output of said controlling thread.
08:17:48 <Syzygy-> I have a function of typ a -> a -> Maybe a, and I want to basically fold this over a leaf-labeled binary tree.
08:17:54 <MyCatVerbs> vincenz: and roughly every three minutes, that daughter process will terminate and a new one will be started.
08:17:58 <vincenz> MyCatVerbs: I meant what does it do, not how
08:18:01 <MyCatVerbs> vincenz: (intentionally, that is)
08:18:11 <MyCatVerbs> vincenz: it's the world's most useless jukebox. ^_^
08:18:44 <Syzygy-> I started out by writing an "eval" function: eval L a = Just a; eval N a b = liftM2 m (eval a) (eval b)
08:18:52 <Syzygy-> However, this doesn't match liftM2.
08:18:55 <Syzygy-> Help?
08:19:27 <vincenz> erm
08:19:38 <vincenz> Syzygy-: why isi your unction a -> a -> Maybe a
08:19:44 <vincenz> s/unction/function
08:19:56 <vincenz> eval (L a) = return a
08:20:12 <Syzygy-> vincenz: Because the values it feeds in might work well, or they might trigger an error, at which case I want the entire tree to
08:20:16 <Syzygy-> "vanish"
08:20:34 <vincenz> eval (N a b) = (eval a) >>= \a' -> (eval b) >>= \b' -> m a' b'
08:20:56 <vincenz> or
08:20:56 <Syzygy-> This is an attempt to model multiplication along evaluation trees where a tree might get a result or it might be 0.
08:20:59 <vincenz> even better
08:21:00 <EvilTerran> liftM2 m `on` eval?
08:21:28 <scook0> Syzygy-: is the problem that you end up with (Maybe (Maybe a))?
08:21:31 <vincenz> eval (N a b) = join (m <$> eval a `ap` eval b)
08:21:35 <vincenz> use join
08:21:38 <vincenz> :)
08:22:13 <byorgey> hah! we were just talking about this pattern the other day =)
08:22:15 <vincenz> and people using liftM2 in the day and age of 'ap' should be shot
08:22:22 <scook0> vincenz: why <$> but not <*>?
08:22:28 <byorgey> and people using 'ap' in the day and age of <*> should be shot
08:22:28 <vincenz> scook0: I'm used to app
08:22:38 <vincenz> eval (N a b) = join (return m `ap` eval a `ap` eval b)
08:22:39 <scook0> heh
08:22:45 <vincenz> byorgey: ap is in Control.Monad
08:22:51 <EvilTerran> lift[MA]2 have their place in pointsfree programming
08:22:53 <vincenz> <*> is in something.mumble.something
08:22:56 <byorgey> vincenz: <$> is in Control.Applicative.
08:23:03 <vincenz> byorgey: exactly my point!
08:23:07 <vincenz> something.mumble.something
08:23:17 * EvilTerran doesn't get what vincenz is getting at
08:23:21 * byorgey either =)
08:23:30 <vincenz> Just a poor excuse to use ap?
08:23:50 <byorgey> Syzygy-: by the way, what ever happened to your paper where you used Haskell to compute with some sort of mathematical structures?
08:24:07 <EvilTerran> anyway, <*> cannot be in something.mumble.something, as it's got the wrong number of dots
08:24:07 <byorgey> did any reviewers ever get found?
08:24:08 <Syzygy-> So, what do I do if I want to do the same with liftM3? join m <$> eval a `ap` eval b `ap` eval c ?
08:24:24 <vincenz> Syzygy-: bibi
08:24:24 <byorgey> join (m <$> eval a <*> eval b <*> eval c)
08:24:25 <vincenz> nono even
08:24:27 <vincenz> join $ ...
08:24:27 <Syzygy-> byorgey: It got rejected by the algebra/topology journal the other week.
08:24:31 <vincenz> the join should come as last
08:24:38 <byorgey> Syzygy-: oh, boo, I'm sorry to hear that =(
08:25:04 <vincenz> btw, since we're using new and fancy features
08:25:12 <Syzygy-> byorgey: It wasn't a big surprise, and I understood the referee's arguments completely.
08:25:18 <byorgey> Syzygy-: fair enough.
08:25:21 <RudolfRentier> hi
08:25:29 <byorgey> hey RudolfRentier
08:26:06 <RudolfRentier> just a short question: how do i make this: show $ (tdPicosec $ diffClockTimes after before) / 1000000   work?
08:26:16 <opqdonut> :D
08:26:44 <Peaker> > show $ (tdPicosec $ diffClockTimes after before) / 1000000
08:26:44 <lambdabot>   Not in scope: `before'
08:26:49 <byorgey> @type tdPicosec
08:26:50 <lambdabot> Not in scope: `tdPicosec'
08:26:50 <RudolfRentier> "No instance for (Fractional Integer) arising from a use of `/'" and i don't know how to fix this
08:26:52 <Syzygy-> *C333> tree
08:26:52 <Syzygy-> M2 (M2 (L x) (L 1)) (M3 (L x) (L x) (L x))
08:26:52 <Syzygy-> *C333> eval tree
08:26:52 <Syzygy-> Just xy
08:26:55 <Syzygy-> Wooohoooo!
08:26:59 <paolino> use div
08:27:06 <Peaker> RudolfRentier, you could use `div` for truncating integer division
08:27:21 <Peaker> RudolfRentier, or you could use (fromIntegral) to convert the result to a float for /
08:27:21 <byorgey> RudolfRentier: ah, you need a 'fromIntegral' probably
08:27:21 <byorgey> or use `div` if you want integer division
08:27:29 <byorgey> show $ (fromIntegral . tdPicosec $ diffClockTimes ...
08:27:50 <Syzygy-> Now for the next evil question: is there a good way to distribute values among the leaves of a given tree? Say, I have integers 1..n and I want to distribute (take n list) among those integers so that list!!n replaces n.
08:27:51 <Peaker> in this case, . and $ would both do, wouldn't they?
08:27:59 <Syzygy-> Is this an easy and obvious thing to do?
08:28:18 <RudolfRentier> Peaker: hmm, doesn't work with fromIntegral "No instance for (Num ((a1 -> a1 -> a1) -> t -> a))"
08:28:27 <Peaker> Syzygy-, you could use mapM on the tree structure if it has monadic sequencing of its leaves
08:28:31 <hpaste>  nibro pasted "System.Win32.FileNotify" at http://hpaste.org/7033
08:28:43 <RudolfRentier> ups, forget that
08:28:56 <nibro> dcoutts_: care to take another look? :-)
08:28:58 <byorgey> Syzygy-: hm, you mean you have integers at the leaves of your tree?
08:28:58 <Peaker> Syzygy-, that was actually one of the examples of monads in the YAHT or gentle tutorial
08:29:03 <RudolfRentier> ah thanks very much :)
08:29:27 <Syzygy-> byorgey: Yup.
08:29:38 <EvilTerran> Peaker, is that the Traversable.mapM?
08:30:20 <byorgey> Syzygy-: so e.g.  given the list ["foo","bar"],  the tree  N (L 1) (N (L 0) (L 1)) should become N (L "bar") (N (L "foo") (L "bar"))?
08:30:30 <Syzygy-> Exactly!
08:30:51 <Peaker> EvilTerran, I am not sure, I just re-looked in the YAHT and they use mapTreeM. though I'd expect a generic monadic thing should be able to do it too
08:31:05 <byorgey> Syzygy-: and do you know anything about the structure of the integers in the tree, or they could be in any kind of order etc?
08:31:17 <Syzygy-> byorgey: Each occurs exactly once.
08:31:25 <byorgey> oh, I see
08:31:27 <Syzygy-> They cover the interval 1..n
08:31:30 <Peaker> Syzygy-, just use fmap on the tree, with (somelist!!) as a function?
08:31:39 <byorgey> yeah, that's the obvious solution
08:31:51 <Syzygy-> Ooookay. So I need to equip my tree with Monad...
08:31:59 <byorgey> Syzygy-: no, just Functor
08:32:09 <scook0> a Functor instance should be dead easy
08:32:09 <Syzygy-> Aight.
08:32:13 <wolverian> ..which ghc can probably derive for you?
08:32:23 <byorgey> no, not Functor
08:32:30 <byorgey> that only works for newtypes
08:32:30 <wolverian> aw.
08:33:02 <byorgey> Syzygy-: that solution is O(n^2) of course, I don't know if you can do any better given that you know each integer only occurs once... I suspect not.
08:33:13 <Syzygy-> I don't care about complexity.
08:33:15 <Peaker> Syzygy-, byorgey: Can use an array instead of a list
08:33:27 <Syzygy-> I want it to work for ~ 16 inputs and <10 nodes.
08:33:29 <byorgey> Syzygy-: oh! ok, then fmap (somelist!!) it is =)
08:33:41 <scook0> apparently Data.Derive supports Functor :)
08:33:45 <byorgey> well, fmap (\n -> somelist!!(n-1)) actually
08:33:55 <byorgey> if the numbers are 1..n
08:34:01 <byorgey> list indices are 0..(n-1)
08:34:10 <Peaker> @pl \n->(somelist!!(n-1))
08:34:10 <lambdabot> (somelist !!) . subtract 1
08:34:17 <Syzygy-> I have control over the numbers, but it might be easier for my collaborator if we handle that.
08:34:28 <scook0> a Data.Map is another option
08:34:43 <scook0> slightly less cumbersome than an array in my experience
08:34:45 <Peaker> I think maybe f . g could be less confusing as g . f  (screw math notations :-)
08:35:03 <Peaker> unix pipes ftw
08:35:04 <scook0> Peaker: f >>> g
08:35:06 <Deewiant> sjust use f >>> g
08:35:12 <scook0> Control.Arrow ftw
08:35:13 <Deewiant> s/^s//
08:35:14 <byorgey> scook0: ah, true!  convert the list to a Map Int a  first, then fmap it over the tree... O(n)
08:35:26 <EvilTerran> isn't the conversion O(n.log n)?
08:35:35 <Peaker> scook0, Deewiant are arrows built-in Haskell98?
08:35:45 <byorgey> EvilTerran: er, good point
08:35:49 <laz0r> hi #haskell, is it possible to combine the powers of emacs and lambdabot?
08:35:50 <byorgey> an array would be O(n)
08:35:56 <Deewiant> Peaker: nope
08:36:08 <wolverian> if you do in-order traversal you can also keep track of where you're in the list to get O(n)
08:36:17 <Syzygy-> Functor gave me kind mismatch.
08:36:18 <scook0> no, but a function-specific version of (>>>) is easily definable in H98
08:36:18 <wolverian> but I think you need your own function for that :)
08:36:20 <byorgey> laz0r: that would be frightening ;)
08:36:22 <Peaker> a Map here is silly - if you have completely dense index-based search
08:36:23 <scook0> (>>>) = flip (.)
08:36:29 <Deewiant> Peaker: but the stuff you use only for normal functions and tuples is generally definable in H98
08:36:30 <laz0r> byorgey: and totally awesome
08:36:35 <laz0r> wouldn't it?
08:36:38 <Syzygy-> Oh, wait...
08:36:38 <EvilTerran> the Arrow class is h98, i think, but the sugar most definitely isn't
08:36:42 <Deewiant> (>>>), (&&&), (***), first, second.
08:36:49 <EvilTerran> Syzygy-, what's your datatype?
08:36:52 <Syzygy-> Compiles! WOOO!
08:36:52 <byorgey> Syzygy-: data Tree a = .... ;  instance Functor Tree where fmap = ...
08:36:57 <Deewiant> oh, Control.Arrow is H98
08:37:02 <byorgey> Syzygy-: =D
08:37:03 <wjt> @let (·) = flip (.)
08:37:03 <lambdabot>  Illegal character ''\183''
08:37:05 <wjt> doh :(
08:37:11 <scook0> Peaker: I find haskell arrays to be a royal pain, to be avoided whenever possible
08:37:12 <Deewiant> even better
08:37:14 <laz0r> i am thinking of something like: select some expression -> see type of this expression
08:37:22 <Peaker> scook0, how come?
08:37:36 <Peaker> scook0, (I am rather new, I haven't actually used them yet)
08:37:44 <laz0r> and all the other fancy stuff lambdabot can do that i don't even know yet
08:38:02 <byorgey> haskell mutable arrays are a royal pain.
08:38:07 <scook0> messing about with Ix and bounds annoys me
08:38:10 <byorgey> immutable arrays, on the other hand, can be quite nice
08:38:17 <dcoutts_> nibro: looks plausible :-)
08:38:29 <dcoutts_> nibro: so you don't need sizeOfFNI at all
08:38:35 <byorgey> especially since they can be constructed lazily -- makes various dynamic programming algorithms really simple to write
08:38:39 <scook0> and there's no equivalent of Data.Map.lookup
08:38:49 <nibro> dcoutts_: I noticed that too
08:38:51 <laz0r> http://paste.lisp.org/display/29493 <- google finds this, but my lisp knowledge fails me...
08:38:52 <dcoutts_> nibro: and I don't quite follow how readDirectoryChangesW is working, I don't see the callback
08:39:14 <scook0> oh, and GHC's Ix derivations can be buggy
08:39:21 <dcoutts_> nibro: oh, nullFunPtr for the callback
08:39:27 <byorgey> laz0r: you can actually do that, I think, with the emacs haskell-mode
08:39:28 <nibro> dcoutts_: not quite
08:39:33 <Peaker> byorgey, by mutable arrays, you mean mutate-by-copy or real mutable?
08:39:50 <laz0r> byorgey: i know about haskell-mode... but i want more!
08:40:06 <nibro> dcoutts_: I've only implemented the synchronous version of readDirectoryChangesW
08:40:11 <byorgey> Peaker: well, either, really, but mutate-by-copy isn't so bad
08:40:20 <nibro> dcoutts_: this is not the function that actually does the notification
08:40:27 <Peaker> byorgey, how does it do real mutability?
08:40:28 <Syzygy-> WOOOOOOOOOOOOO!
08:40:31 <dcoutts_> nibro: ok
08:40:33 <Syzygy-> Things are doing what they should!!
08:40:39 <nibro> dcoutts_: those functions are already defined in the standard Win32 package
08:40:43 <byorgey> Peaker: with the IO monad, or ST monad
08:40:45 <scook0> Peaker: using the IO or ST monad
08:40:50 <dcoutts_> nibro: readChanges looks sane
08:40:53 * byorgey shudders
08:41:07 <scook0> speaking of which, I love to hate the ST monad, too
08:41:08 <nibro> dcoutts_: weee :-)
08:41:39 <Peaker> scook0, byorgey: Ah, does the Array module support both of those?
08:41:59 <byorgey> Peaker: well, various submodules of Data.Array
08:42:26 <byorgey> the plethora of array modules is really quite bewildering.
08:42:37 <scook0> the H98 Array module just has the standard immutable boxed Array
08:43:05 <byorgey> Syzygy-: hooray! =D
08:43:17 <laz0r> what about yi? it looks like it could be what i am actually looking for, but is it useable already?
08:43:34 <scook0> GHC's libs define typeclasses for mutable and immutable arrays, and have a few implementations of each
08:44:10 <vincenz> Syzygy-: Ping
08:44:23 <Syzygy-> pong
08:44:26 <vincenz> Syzygy-: You wanted to update a tree and keep its structure?
08:44:53 <Syzygy-> Yup. Got it now.
08:44:55 <conal> nibro: what's your interest in file notification?  i ask because i'd like to tie in data-driven functional reactivity to the file system.
08:45:01 <Syzygy-> Using a Functor instantiation.
08:45:07 <vincenz> Syzygy-: what code?
08:45:15 <Syzygy-> Just wrote it.
08:45:31 <vincenz> Syzygy-: @paste?
08:45:36 <conal> nibro: for triggering recompilation, testing etc
08:45:52 <Syzygy-> @paste
08:45:52 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:46:40 <hpaste>  Syzygy- pasted "Treeishness" at http://hpaste.org/7034
08:46:59 <vincenz> eww
08:47:14 <nibro> conal: my direct interest is for a webserver that automatically recompiles pages in the background as they are edited
08:47:30 <conal> nibro: cool. thx.
08:47:34 <Syzygy-> o.O
08:47:55 <dons> lambdabot: i think yi is getting quite close to usable
08:48:01 <dons> laz0r:
08:48:04 <opqdonut> :D
08:48:05 <byorgey> vincenz: ?
08:48:06 <dons> tab completion is fun
08:48:14 <vincenz> byorgey: !!
08:48:16 <opqdonut> ?remember dons lambdabot: i think yi is getting quite close to usable
08:48:16 <lambdabot> Nice!
08:48:28 <laz0r> dons: ok, cool, then i'll try harder building it
08:48:35 <byorgey> vincenz: I was wondering why you 'eww'ed at Syzygy-'s code
08:48:37 <dons> laz0r: use the darcs version, btw
08:48:40 <opqdonut> ?quote
08:48:40 <lambdabot> darius says: Well profiling does add a bit of reflection, but it should have the good sense not too go near the barbed wire fences and armed guards.
08:48:44 <vincenz> byorgey: that is my reason '!!'
08:48:47 <laz0r> dons: so far, didn't get it to work because of its dependencies
08:48:54 <vincenz> Syzygy-: Small nit, use 'pure a' instead of Just a
08:48:57 <laz0r> dons: i am using the one from code.haskell.org
08:48:57 <vincenz> Syzygy-: that way you make it generic
08:48:58 <Syzygy-> vincenz: What do you want me to use instead?
08:49:03 <laz0r> dons: i think
08:49:37 <laz0r> dons: yes, that one: http://code.haskell.org/yi/
08:49:38 <lambdabot> Title: Index of /yi
08:49:41 <dons> yep
08:49:46 <dons> yeah, the dependencies need polishing.
08:49:47 <vincenz> Syzygy-: I misunderstood your original problem-spec
08:49:50 <vincenz> but let me clear that up a bit
08:49:59 <dons> it took a couple of rounds of xmonad to make it super easy to build. yi needs the same pass
08:50:45 <conal> Syzygy-: i like vincenz's suggestion of 'pure', and then generalizing out Maybe to an Applicative
08:51:12 <vincenz> Syzygy-: is the [HC3] list guaranteed bounded?
08:51:15 <Syzygy-> But I don't CARE about generality right now. This is to avoid drawing and hand applying things to these trees for the 256 values we want to test.
08:51:16 <vincenz> (in length)
08:51:24 <Syzygy-> vincenz: The [HC3] will be of lenght 16.
08:51:29 <vincenz> oh
08:51:33 <hpaste>  vincenz annotated "Treeishness" with "very small fix" at http://hpaste.org/7034#a1
08:51:43 <Syzygy-> My ONLY reason for using [] instead of tuples is that 16-tuples get SO messy to work with.
08:52:00 <vincenz> Syzygy-: are the integers in the tree in order?
08:52:14 <Syzygy-> No. That's why I want to distribute integers.
08:52:19 <vincenz> ok
08:53:16 <laz0r> dons: why does yi need such specific versions of the regex libs? should it be save to just change that to whatever version i have?
08:53:35 <byorgey> Syzygy-: looks good to me.
08:53:44 <dons> laz0r: probably due to bug issues
08:53:51 <dons> maybe we can move it to use pcre-lite
08:53:58 <vincenz> byorgey: I'd probably use an array :)
08:54:08 <vincenz> byorgey: seeing a '!!' makes me shiver
08:54:34 <saml> what's a simple way to implement newId that generates auto incremented integers?  like,  sequence [newId, newId, ..]   would be [1,2,3...]
08:54:45 <saml> do I roll out custom monad?
08:55:02 <vincenz> saml: oh, there's a monad for that
08:55:06 <byorgey> vincenz: well, I probably would too, but for what Syzygy- wants to do, it's nicely concise and elegant.  Switching to an array or map or whatever would be a theoretical improvement but not a practical one.
08:55:29 <saml> http://www.haskell.org/haskellwiki/New_monads/MonadSupply  this is quite complicated for me
08:55:31 <lambdabot> Title: New monads/MonadSupply - HaskellWiki
08:55:33 <vincenz> that one
08:56:28 <vincenz> saml: simply o
08:56:30 <vincenz> do
08:56:43 <vincenz> runSupply (sequence [supply, supply, ...]) [1..]
08:58:08 <vincenz> saml: that monad is pretty bare to the bones for what you want, so if that' too complicated, then rolling your own probably won't help, except perhaps as exercise
08:58:43 <ToRA> @pl foldr ($)
08:58:43 <lambdabot> foldr id
08:59:35 <Syzygy-> Lunch!
09:01:16 <roconnor> What's the standard mathematical precedence level for ∘ ?
09:02:00 <ToRA> > let next = State (id &&& succ) in evalState (sequence [next, next, next]) 0
09:02:01 <lambdabot>  [0,1,2]
09:02:43 <dolio> roconnor: Do you have some context where it'd be ambiguous?
09:03:09 <roconnor> f ∘ g^2
09:03:17 <roconnor> f∘g^2
09:03:25 <dolio> Ah.
09:03:46 <dolio> I'd probably say ^ binds tighter.
09:04:05 <roconnor> > f . g ^ 2
09:04:05 <lambdabot>        add an instance declaration for
09:04:05 <lambdabot>       (SimpleReflect.FromExpr (f a), N...
09:04:12 <roconnor> oh right
09:04:32 <roconnor> dolio: okay
09:04:43 <Peaker> Baughn, you are quick to upgrade your kernel :)
09:04:47 <roconnor> dolio: I'd agree, but that's not what the Haskell 98 report does
09:04:54 <dolio> I don't do an astonishing amount of math, though.
09:05:06 <vincenz> byorgey: Why not a practical one, if anything I'd see it as a practical not a theoretical one
09:05:22 <byorgey> vincenz: because it makes the code longer and more complex.
09:05:43 <dolio> The report probably doesn't consider ^ on functions.
09:06:24 <twadleigh> roconnor:, dolio: In that case, I'm not sure it matters, as function composition is associative.
09:06:28 <vincenz> byorgey: and most likely faster
09:06:31 <Baughn> Peaker: It's just a reboot. Why should it take longer?
09:06:34 <vincenz> byorgey: that's rather practical for me )
09:06:36 <Baughn> Peaker: ..in fact, it's just a kexec
09:07:06 <byorgey> vincenz: of course, but since Syzygy- was only dealing with very small inputs, speed was not a practical consideration for him.
09:07:36 <byorgey> that's why I said in this particular case it was theoretical and not practical.
09:08:05 <janszn> @pl (1, \x y -> x*y `mod` n)
09:08:05 <lambdabot> (1, (. (`mod` n)) . (*))
09:08:06 <roconnor> twadleigh: depends on if you thing g^2 is g∘g, or \x -> (g x)^2
09:08:07 <dolio> twadleigh: (f . g) ^ 2 /= f . (g ^ 2), though.
09:08:10 <roconnor> *think
09:08:17 <vincenz> byorgey: I guess you and I place theory and practice in different places :)
09:08:43 <vincenz> byorgey: for me the practicality was the possibly improved speed, and the lost theoreticalicity, the more verbose code
09:09:06 <vincenz> theoreticality
09:09:46 <saml> in polymorphic typing without typeclass, should I still define functions  +int :: Int -> Int -> Int    and +float :: Float -> Float -> Float ?
09:10:06 <byorgey> vincenz: I don't think we're really disagreeing, just slightly different points of view =)
09:10:10 <saml> + :: a -> a -> a .  accepts   1 + "asdf"
09:10:12 <Peaker> Baughn, how do you use kexec to upgrade the kernel? Manually or with distro support?
09:10:19 <vincenz> byorgey: I agree :)
09:10:27 <Baughn> Peaker: Manually
09:10:30 <byorgey> if it were me, I would definitely use an array even if I didn't need the speed, because it was *theoretically* better =)
09:10:31 <Peaker> Baughn, btw: there have been kernel releases in the past where the first upgraders got foobar'd
09:10:40 <dolio> Slightly different is still different. Keep arguing!
09:10:43 <twadleigh> dolio: Ah, yes. And I'd say your example is a good argument for why '^' should bind more tightly.
09:10:50 <Baughn> Peaker: That's why I read the diffs.
09:11:07 <byorgey> saml: no it doesn't, if you have + :: a -> a -> a, all the a's must represent the same type.
09:11:09 <Baughn> Peaker: (They tend to be fairly small once you remove anything that doesn't actually get compiled)
09:11:10 <Saizan_> ?djinn a -> a -> a
09:11:11 <lambdabot> f _ a = a
09:11:29 <saml> my algorithm fails
09:12:06 <Peaker> Baughn, but how do you know if you will get fubar'd by reading the diff?
09:12:26 <Peaker> Baughn, surely it has cryptic changes in drivers and such :)
09:12:41 <Baughn> Peaker: I scan for calls to muAhAHaHaHa()
09:13:36 <Baughn> Peaker: ..mostly, I'm just looking for the hypothetical fix that will put my internal NIC back on eth0 (currently unused) instead of eth2. Which would be annoying, since it's a headless system.
09:14:46 <saml> without typeclass SomeCustomTypeNotInNum + SomeCustomTypeNotInNum would be well typed
09:19:09 * lesshaste notes the haskell to non-haskell talk ratio :)
09:19:48 <Saizan_> saml: yeah it would type but your (+) couldn't do anything with those values, the only functions of type  (a -> a -> a) are const and flip const
09:20:29 * dcoutts_ does $ cabal install pandoc
09:20:41 <dcoutts_> yay for easy installation :-)
09:20:43 <vincenz> Saizan: and const id
09:20:47 <shachaf> Saizan: And seq, if that counts.
09:20:54 <vincenz> and undefined
09:21:03 <shachaf> const id == flip const, no?
09:21:06 <Saizan> const id = flip const no?
09:21:11 <vincenz> Apparently ;)
09:21:25 <Saizan> and those pesky bottom/bottom-checking functions don't count!
09:22:03 <dolio> undefined counts, I'd say.
09:22:20 <saml> I don't understand this. typeclass seems to put restrictions on how type variables can be unified
09:22:47 <saml> so, can I say type system witout typeclass is more powerful?
09:23:03 <Saizan> saml: they also provide additional informations about the types that variable will be instantiated wiht
09:25:19 <shachaf> saml: For example, once (+) is restricted to a type like Int or Double, there's a specific implementation (declared in instance Num Int where (+) = ...) that can be used.
09:25:33 <Saizan> saml: e.g. since length :: [a] -> Int, it must work for lists of any type 'a', so it can't do anything interesting with the values of the list, and you know it will work the same for every 'a'
09:25:38 <Vulpyne> If anyone remembers the weird memory leak problem I had yesterday, the cause was actually pretty simple. Adding items to a TChan at a faster rate than they were consumed. :/
09:25:59 <quicksilver> Vulpyne: heh ;)
09:26:02 <quicksilver> that explains it.
09:26:19 <Vulpyne> I woke up this morning and had an epiphany, and sure enough, that was the reason. :)
09:26:41 <janszn> @pl foldr (\a b -> a+2*b)
09:26:41 <lambdabot> foldr ((. (2 *)) . (+))
09:27:36 <Saizan> that should maybe stressed in the documentation for Chan/TChan, you0re not the first one bitten by it
09:28:11 <conal> saml: typeclasses add power of expression about types, namely constraints/restrictions on use.
09:28:22 <mauke> restrictions = power
09:28:27 <Vulpyne> Maybe. It's kind of a dumb problem that should be obvious, but...
09:28:52 <shachaf> mauke: That's why I use HQ9+.
09:29:25 <mauke> oh yeah, baby
09:29:42 <mauke> sig-compatible interpreter: http://mauke.ath.cx/stuff/perl/hq9+.pl
09:30:04 <shachaf> mauke: That's HQ9++.
09:30:18 * Saizan wonders what's the nicer implementation of a bounded channel
09:30:19 <mauke> it's backwards compatible
09:30:30 <shachaf> mauke: HQ9+ : HQ9++ == C : C++ (even if the +s don't exactly match up).
09:30:50 <mauke> shachaf: just remove the \+\+|
09:30:57 <laz0r> dons: the regex deps are a problem, it won't build with my version (0.93)
09:31:29 <shachaf> mauke: You should add HQ9+- support sometime, too.
09:32:57 <mauke> shachaf: do you have a spec?
09:33:09 * shachaf looks for it.
09:35:37 <shachaf> Hmm, the only thing I can find is old #haskell logs.
09:43:42 <dolio> @karma HQ9
09:43:42 <lambdabot> HQ9 has a karma of 1
09:43:56 <opqdonut> @karma haskell'
09:43:56 <lambdabot> haskell' has a karma of 0
09:44:10 <dolio> @karma "c
09:44:10 <lambdabot> "c has a karma of 3
09:44:23 <shachaf> dolio: Oops.
09:44:38 <dolio> I noticed that I added to that the other day.
09:44:39 <shachaf> dolio: They should make an exception for that, like they did for C.
09:44:53 <shachaf> @karma (c
09:44:53 <lambdabot> (c has a karma of 1
09:44:59 <laz0r> dons: i installed the regex libs, now it builds, but i don't get a yi executable... maybe i need to install the vty lib too, gtk2hs is installed and yi didn't complain about its version
09:45:40 <opqdonut> @karma s
09:45:40 <lambdabot> s has a karma of 0
09:45:44 <opqdonut> @karma (s
09:45:44 <lambdabot> (s has a karma of 0
09:45:53 <opqdonut> hmm, one'd think that s++ would be more used than c++
09:46:28 <dolio> Why would one think that?
09:46:40 <laz0r> dons: the README says i should have an executable at ./dist/build/yi/yi but it seems a bit outdated
09:46:54 <dolio> Is there some talked-about s++ language I'm not aware of?
09:46:56 <dolio> s--
09:46:59 <SyntaxNinja> y0
09:47:41 <opqdonut> dolio: string catenation
09:47:49 <dolio> Ah.
09:47:52 <opqdonut> :)
09:49:20 <SyntaxNinja> @seen dons
09:49:20 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
09:49:35 <shachaf> SyntaxNinja: 4 minutes ago in #xmonad.
09:49:53 <mauke> preflex: seen dons
09:49:53 -preflex(n=preflex@d90-128-46-80.cust.tele2.de)- dons was last seen  on #xmonad 4 minutes and 7 seconds ago, saying: where would we display the icon?
09:50:31 <byorgey> woah, what's preflex?
09:50:35 <mauke> byorgey: my bot
09:50:43 <magthe> mauke: what does it do?
09:50:52 <SyntaxNinja> preflex: how powerful are you compraed to lambdabot?
09:51:01 <mauke> SyntaxNinja: not very :-)
09:51:12 <saml> preflex: (1 + 2)
09:51:12 <byorgey> preflex: hi
09:51:37 <mauke> it supports "seen", factoids, quotes, and a calculator
09:52:23 <mauke> oh, and karma
09:52:35 <nomeata> Is there a good reason that there is no function to reverse an Ordering, to turn a "reverse . sortBy f" in the (probably faster) "sortBy (inv . f)"
09:53:03 <dolio> sortBy (flip f)?
09:53:17 <nomeata> dolio: hmm. good idea, thx :-)
09:53:24 <Twey> Is sorting lazy?
09:53:46 <mauke> > take 10 $ sort [1 ..]
09:53:52 <lambdabot>  Terminated
09:55:50 <mauke> I think the only really cool thing about my bot is the calculator syntax
09:55:58 <mauke> (the calculator is also the only part written in C)
09:56:13 <byorgey> > head $ sort [3,4,5,6,2,6,6,3,2,4,4,2,1,2]  -- runs in O(n) time
09:56:13 <lambdabot>  1
09:56:30 <byorgey> Twey: so, it is lazy in a certain way.
09:56:46 <ddarius> mauke: What's the calculator syntax and why is it written in C?
09:57:06 <mauke> the calculator is older than the rest of the code
09:57:17 <mauke> the syntax is kind of hard to explain
09:57:25 <Twey> byorgey: Huh?  That's how I'd define 'strict' :-)
09:57:51 <Twey> Oh, I see
09:57:52 <mauke> simplified version: there are three types of tokens, values, operators and parens
09:58:00 <byorgey> Twey: I mean, sort can return the first element of the result without sorting the rest
09:58:04 <dolio> head . sort could take O(n log n) time.
09:58:16 <Twey> byorgey: Er, how?
09:58:18 <ddarius> "It includes an ML interpreter written in C" oy
09:58:25 <byorgey> dolio: oh?  I thought it was guaranteed to be O(n).  perhaps I was misinformed.
09:58:32 <Twey> It has to sort everything to discover the first element, doesn't it?
09:58:36 <ddarius> byorgey: It depends on the sort.
09:58:47 <dolio> No, I mean, the fact that it doesn't means it's lazier than a fully strict sort.
09:59:05 <mauke> values can "move" through operators and parens. opening parens can be inserted at the beginning, closing parens at the end
09:59:08 <twadleigh> Twey: It only has to look at everything to know what's first.
09:59:17 <byorgey> ddarius: right, I mean for the version in the Prelude
09:59:57 <byorgey> dolio: aha, I see.  the problem is that people are using 'sort' to refer both to the specific implementation in the Prelude, and a general function with similar semantics. =)
10:00:01 <mauke> so e.g. 2 + )) * 3 4 is a valid expression and equivalent to ((2 + 3)) * 4
10:00:21 <ddarius> mauke: ...
10:00:44 <mauke> do you like it? :-)
10:00:48 <dolio> The actual sort included in GHC should take O(n + k log n) for take k . sort.
10:00:59 <mohbana> how different is upcoming f# from microsoft going to be from Haskell?
10:01:01 <dolio> For k <= n, of course.
10:01:10 <byorgey> Twey: no, for example, you can just call 'minimum' on a list to discover the first element of the sorted list, but that obviously doesn't mean you know how all the others should be sorted
10:01:12 <ddarius> mauke: Is it written for people with dyslexia?
10:01:26 <mauke> haha
10:01:28 <ddarius> mohbana: F# isn't upcoming.
10:01:42 <ddarius> Also, F# is based on O'Caml.
10:01:47 <byorgey> dolio: ah, interesting.  good to know =)
10:02:26 <saml> can I have my own unary operator in haskell?
10:02:26 <ddarius> saml: No.
10:02:26 <mauke> ddarius: there's a natural interpretation for arbitrarily placed parens
10:02:27 <saml> ddarius: thanks
10:02:30 <byorgey> saml: you can sort of fake it, but not really
10:02:41 <byorgey> > let (!) n = product [1..n]  in (10!)
10:02:42 <lambdabot>  3628800
10:02:44 <Toxaris> > let (!) = product . enumFromTo 1 in (4 !)
10:02:45 <lambdabot>  24
10:02:48 <mauke> ddarius: this version of the calculator additionaly exploits the observation that you don't actually need the values to construct the parse tree of an infix expression
10:03:27 <mohbana> ddarius, well is it similar to haskell?
10:03:31 <lament> is f# more popular than haskell jobwise?
10:03:52 <ddarius> lament: There isn't really any way to tell.
10:04:01 <lament> mohbana: it's in the ML family, so it's- closer to Haskell than most other languages
10:04:07 <dons> i've not seen any F# jobs yet, but heard they exist
10:04:07 <ddarius> mohbana: It's similar to O'Caml which is vaguely similar to Haskell.
10:04:08 <elliottt> sjanssen: is there a safe way to get the return code from an external process in xmonad?
10:05:44 <saml> > let (!) x = trace (show x) x in 24!
10:05:44 <lambdabot>  Parse error at end of input
10:06:10 <saml> oh parenthesis
10:07:01 <Twey> < byorgey> > let (!) n = product [1..n]  in (10!) -- how is this not a unary operator?
10:07:27 <Twey> Oh!  Because the brackets are required?
10:07:44 <Twey> > let (!) n = product [1..n]  in 10!
10:07:45 <lambdabot>  Parse error at end of input
10:07:54 <byorgey> Twey: yup, it's an operator section
10:08:03 <Twey> Hm, OK
10:08:06 <byorgey> I mean, it is sort of a unary operator...
10:08:45 <Twey> It is a unary operator.
10:09:00 <saml> can I do this:   (!) x = trace (VarNameOfX ++ show x) x
10:09:13 <tromp> > let (!) n = product [1..n] in (!) 4
10:09:14 <lambdabot>  24
10:09:21 <saml> so that (asdf!)  will print   adsf 34   if adsf was 34
10:10:09 <byorgey> saml: sure
10:10:18 <Toxaris> saml: I don
10:10:30 <Saizan> you've to put the VarNameOfX yourself
10:10:39 <Toxaris> saml: I don't think so. expressions or variable names aren't reifed in running haskell programs
10:10:42 <Saizan> so no
10:10:42 <byorgey> Twey: it is a unary function, but you can't really use it as an operator, unless you do the section kludge
10:11:03 <ddarius> It's also not clear if the Report allows that
10:11:08 <Twey> Ah
10:11:08 <saml> that can make it easier to debug haskell program
10:11:10 <Twey> :-\
10:13:59 <ddarius> Introspection of that sort would directly break referential transparency.
10:16:28 <saml> maybe ! or trace should be dirty macro
10:17:03 <Toxaris> anyone has an idea how to give feedback about http://wiki.darcs.net/DarcsWiki/WindowsConfiguration ?
10:17:05 <lambdabot> Title: WindowsConfiguration - DarcsWiki
10:19:05 <wjt> @ty bracket
10:19:06 <lambdabot> Not in scope: `bracket'
10:19:10 <wjt> @index bracket
10:19:10 <lambdabot> Control.Exception, Distribution.Compat.Exception, Graphics.HGL.Draw.Monad, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL
10:19:25 <mauke> :t Control.Exception.bracket
10:19:26 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
10:20:16 <EvilTerran> you could do it in TH
10:20:18 <proq> does anyone have some source for a tiny haskell implementation?
10:20:25 <EvilTerran> $('asdf!)
10:20:50 <wjt> is there a general bracket' a z m = do { a; res <- m x; z; return res }  ?
10:21:00 <lispy> proq: Well, there is a typing haskell in haskell paper
10:21:11 <EvilTerran> ?type (*>)
10:21:11 <lispy> proq: that would get you some good example code for the type checker
10:21:12 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
10:21:42 <EvilTerran> wjt, if your Monad has its Applicative instance too, you could write that as a *> z <* m
10:21:47 <wjt> ?type ?a *> ?m <* ?z
10:21:48 <lambdabot> forall (f :: * -> *) a a1 b. (?z::f b, Applicative f, ?m::f a1, ?a::f a) => f a1
10:21:53 <wjt> ?type \a z m -> a *> m <* z
10:21:54 <lambdabot> forall (f :: * -> *) a a1 b. (Applicative f) => f a -> f b -> f a1 -> f a1
10:22:05 <wjt> coolidge
10:23:47 <daf> whoa
10:23:58 <daf> applicalicious
10:24:21 <proq> lispy: ok, I'll start with that. thanks  :)
10:25:13 <lispy> proq: Next, you may want to look at papers published by Simon Peyton-Jones, he has quite a few about implementing GHC
10:25:22 <lispy> proq: and also Simon Marlow
10:25:55 <lispy> proq: and then start a minimal, toy, haskell compiler so that the next person with your question can just get the source :)
10:25:57 <byorgey> proq: maybe look at Matthew Naylor's article in the most recent Monad.Reader, on a small Haskell interpreter written in Haskell?
10:26:08 <byorgey> @where Monad.Reader
10:26:08 <lambdabot> I know nothing about monad.reader.
10:26:14 <byorgey> @where MonadReader
10:26:14 <lambdabot> I know nothing about monadreader.
10:26:14 <lispy> ?where tmr
10:26:14 <lambdabot> http://www.haskell.org/haskellwiki/TheMonadReader
10:26:27 <byorgey> well, that's unintuitive
10:26:39 <byorgey> @where+ Monad.Reader http://www.haskell.org/haskellwiki/TheMonadReader
10:26:39 <lambdabot> It is forever etched in my memory.
10:27:02 <EvilTerran> saml, with Template Haskell, you can do something like: (!) name = [| trace $ $(LitE . StringL $ nameBase name) ++ " " ++ show $(VarE name) |]
10:27:13 <EvilTerran> and then $('foo!) would work
10:27:38 <byorgey> EvilTerran: neat =)
10:28:07 <EvilTerran> actually, that should be (!) name = [| trace $ $(litE . StringL $ nameBase name) ++ " " ++ show $(varE name) |]
10:29:56 <byorgey> why is it that whenever I set out to write a quick blog post they always end up turning into monstrous, multi-part expositions?
10:30:21 <EvilTerran> actually, i forgot the second parameter to trace there
10:30:31 <EvilTerran> ghci> let nameTrace name = [| trace ($(litE . StringL $ nameBase name) ++ " " ++ show $(varE name)) $(varE name) |]
10:30:31 <EvilTerran> ghci> :t nameTrace
10:30:31 <EvilTerran> nameTrace :: Name -> ExpQ
10:30:31 <EvilTerran> ghci> :t $(nameTrace 'otherwise)
10:30:31 <EvilTerran> $(nameTrace 'otherwise) :: Bool
10:30:33 <EvilTerran> ghci> $(nameTrace 'otherwise)
10:30:35 <EvilTerran> otherwise True
10:30:37 <EvilTerran> True
10:30:46 <EvilTerran> whups,that was longer than i thought. should've hpasted it.
10:31:03 <EvilTerran> sadly $('foo !) didn't work, you'd need to write $(('foo!))
10:32:07 <EvilTerran> you could also do something with quasiquoting, if/when it becomes available
10:32:21 <EvilTerran> (that's still TH, but the syntax is (arguably) nicer)
10:33:05 <dolio> How is that working? Isn't 'foo!) an unterminated character constant?
10:34:38 <byorgey> not with Template Haskell turned on
10:34:50 <dolio> Ah.
10:34:57 <byorgey> it's a quoted literal, or something like that
10:35:15 <dolio> Apparently my template haskell knowledge is lacking.
10:36:25 <byorgey> EvilTerran: that's actually a neat little debugging trick there.
10:37:45 <lament> sessionname default
10:37:51 <dcoutts_> @seen ibid
10:37:51 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
10:37:54 <lament> (whoops!)
10:37:59 <dcoutts_> bah, seen still borked
10:39:02 <dcoutts_> bos, dons: btw, did you find out a recommended online reseller of RWH or should I just use amazon?
10:39:07 <mauke> preflex: seen ibid
10:39:07 -preflex(n=preflex@d90-128-46-80.cust.tele2.de)- ibid was last seen on #haskell 1 day, 58 minutes and 25 seconds ago, saying: dons: ask me again in two hours, have to go now :)
10:39:31 <dolio> Someone get lambdabot some more bytes!
10:39:36 <saml> EvilTerran: hoa it works!!!
10:39:39 <dcoutts_> mauke: heh, that's just what I wanted to ask ibid about
10:40:16 <saml> I had to put definition of t to sepearte file. then calling $(t 'blah)  worked
10:42:13 <byorgey> mauke: hm, I think every time you do a 'seen' to preflex, it generates an urgency notification.  I keep getting flashed and coming over here and being very confused, since no one actually said my nick.
10:42:31 <byorgey> I'm guessing that's what it is, I actually don't know
10:42:41 <mauke> byorgey: what's beep_msg_level set to?
10:43:09 <byorgey> mauke: um... I don't know.  How do I check?
10:43:13 <dcoutts_> mauke: it seems to be a channel message
10:43:18 <mauke> /set beep_msg_level
10:43:32 <dcoutts_> byorgey probably has his client set to beep on channel messages
10:43:43 <byorgey> MSGS NOTICES DCC DCCMSGS HILIGHT
10:43:51 <mauke> MSGS?
10:43:54 <Baughn> byorgey: Turn off "NOTICES"
10:44:02 <mauke> oh, that's privates
10:44:10 <mauke> yeah, preflex replies using NOTICE
10:44:13 <dcoutts_> but why is preflex sending notices rather than ordinary messages?
10:44:14 <byorgey> Baughn: ok, thanks =)
10:44:26 <mauke> dcoutts_: notices are ordinary messages :-)
10:44:30 <Baughn> dcoutts_: Because the IRC standard specifies that bots should not respond to notices, ever
10:44:39 <mauke> the RFC recommends NOTICEs ... what Baughn said
10:44:50 <saml> how can I make [| trace ($(litE . StringL $ nameBase name) ...  be evaluated eagerly?  I put $! after trace but that gives me error
10:44:53 <dcoutts_> hmm, I've never seen any other bot do that
10:45:01 <mauke> because they're all broken
10:45:02 <Baughn> dcoutts_: No, because a lot of clients hilight on it
10:45:10 <Baughn> IRC is just plain broken. Oh well.
10:45:20 <dcoutts_> and because it's looks weird in most clients
10:45:28 * Baughn would quite like to see lambdabot start noticing
10:45:29 <mauke> see above
10:46:19 <mauke> NOTICE and PRIVMSG are more or less the same thing except NOTICEs never trigger an automatic reply
10:46:32 <mauke> there's no reason to display them specially
10:47:30 <stevan> hi, is it possible to do something equivalent to perl's "a 1 b" =~ m/a (\d) b/ where "1" would be saved for later use with haskell's regex library? i couldn't figure out how by trying the, to me, most obvious ways. thanks.
10:48:50 <bos> stevan: no.
10:49:24 <dcoutts_> bos: really? no capturing sub-expressions in any of the regex-* libs?
10:49:59 <bos> oh, i misread the m/ as an s/
10:50:04 <bos> so yes, you can do it.
10:50:19 <bos> @go haskell regexp tutorial
10:50:20 <lambdabot> http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
10:50:20 <lambdabot> Title: teideal glic deisbhéalach  Blog Archive  A Haskell regular expression tutoria ...
10:50:25 <bos> stevan: see above
10:54:07 <saml> let a = b -- is there a way t evaluate b even though a is not used yet?
10:54:36 <saml> well, let a = sep b b
10:55:33 <stevan> "a 1 b" =~ "a ([0-9]) b" :: String ==> "a 1 b", i would like that to return "1"...
10:55:42 <nomeata> How can I safely distinguish these cases: A: "file" is a valid symlink, B: "file" is a broken symlink, C: "file" does not exist?
10:55:57 <nomeata> readFile returns True for A, and False for both B and C
10:56:01 <laz0r> saml: wouldn't that be just let a = seq b?
10:56:23 <laz0r> or is sep something i don't know yet?
10:56:28 <nomeata> I can recognize B with readSymbolicLink, but that throws an exception when I try it on C.
10:56:28 <ADEpt> stevan: .... :: [(String,String,String)] ?
10:56:29 <ADEpt> stevan: or :: Array (Int,Int) String
10:57:13 <saml> laz0r: sorry, it's seq.
10:57:52 <mauke> nomeata: catch the exception
10:58:13 <mauke> why do you need to distinguish the cases?
10:58:42 <nomeata> mauke: because I need to write the symlink if its borken, and I have to delete it first if it does not exist.
10:58:57 <mauke> ah
10:59:05 <stevan> ADEpt: neither of those work at all. (String, String, String) ==> ("", "a 1 b", "")
10:59:56 <nomeata> or I just run "catch (removeFile file) (const (return ()))" before writing the symlink. probably the easiest.
10:59:58 <desegnis> saml: seq a x will force a when (seq a x) is evaluated, where seq a x = x
11:01:56 <mauke> getSymbolicLinkStatus f >>= isSymbolicLink
11:02:08 <desegnis> saml: Or if you need something for the IO monad, Control.Exception.evaluate may come in handy
11:02:53 <saml> desegnis: thanks
11:04:00 <Taejo> anyone happen to know what citation/referencing style ACM publications use?
11:04:15 <ADEpt> @index (=~)
11:04:15 <lambdabot> bzzt
11:06:37 <pejo> Taejo, ICFP has recommended harvard style for the last couple of years I think. But you should check the conference you are planning to submit to.
11:08:27 <Taejo> pejo: unfortunately, I'm not really submitting to; my university's CS dept has a "professional communications" short course, where students have to write a (play-play) report on a random topic and find an appropriate journal
11:09:13 <Taejo> so the paper doesn't really go into the journal (Journal of Management Info. Systems), but we need to know their referencing style (by today)
11:09:45 <Taejo> I hoped all ACM publications would be the same
11:10:11 <pejo> Taejo, there's probably a webpage with "instructions for authors" or similar for the journal in question.
11:10:44 <Taejo> pejo: thanks
11:11:44 <ADEpt> stevan: "a 1 b" =~ "a ([0-9]) b" :: [[String]]
11:11:55 <ADEpt> stevan: :: Array Int String should work as well
11:14:44 <stevan> cool. thanks.
11:15:24 <ADEpt> stevan: read haddock documentation on Text.Regex. It is all there in plain sight.
11:19:43 <stevan> could you please point me to the exact url where you found this [[String]] thing, i can't find it!
11:27:49 <Cale> stevan: You mean http://www.haskell.org/ghc/docs/latest/html/libraries/regex-base/Text-Regex-Base-Context.html ?
11:27:50 <lambdabot> http://tinyurl.com/yovda9
11:28:24 <Cale> stevan: That details the instances of RegexContext, which determine the various possible things which the =~ operator can provide.
11:31:57 <stevan> great, thanks!
11:35:32 <elzurk> hello all
11:35:53 <elzurk> I have a fibs function, which returns a list of fibs
11:36:09 <dancor> @pl \ x -> (x,x)
11:36:09 <lambdabot> join (,)
11:36:18 <elzurk> I can do take n fibs to return the first n fibs from the list
11:36:56 <elzurk> is there some other functionn that I can use that would return a list with the fibs less than a number?
11:37:08 <dancor> pair is a monad?
11:37:28 <shepheb> dancor: functions ((->) e) are a monad
11:37:32 <dancor> @pl \ x -> (x,x,x)
11:37:32 <lambdabot> join (join (,,))
11:37:37 <shepheb> @src (->) join
11:37:37 <lambdabot> Source not found.
11:37:48 <dancor> force not sound
11:38:44 <shepheb> that could be either a Spoonerization, or an oblique "actions, not words"
11:38:53 <dancor> @src (,)
11:38:53 <lambdabot> Source not found. Sorry.
11:38:57 <elliottt> elzurk: you could define an infinite list of fibs, then use takeWhile to get the ones you want
11:39:12 <desegnis> elzurk, you should probably get familiar with the Prelude functions on lists
11:39:16 <dancor> or peace mongering
11:39:44 <elzurk> I wasn't sure if takeWhile worked with infinite list
11:39:55 <elzurk> that's the one I was looking at
11:39:57 <desegnis> eh, spoilers destructing my educational ambitions :-)
11:40:13 <desegnis> elzurk, why should it not?
11:41:22 <elzurk> I guess I was getting it confused with something like filter.  I guess takeWhile will "break" as soon as the (a -> Bool) goes false, correct?
11:41:40 <elliottt> well, it will in a way :)
11:41:47 <elliottt> it will just stop evaluating the list
11:41:54 <elliottt> so the list will stop generating new elements
11:42:39 <elzurk> yes, lovely.  I'm liking the looks of this :)
11:42:49 <elliottt> :)
11:43:01 <olsner> @pl \k x y -> return (x++y)
11:43:01 <lambdabot> const ((return .) . (++))
11:43:42 <desegnis> Also, takeWhile is in some way a functional WHILE loop
11:43:51 <olsner> oh, I see now why liftM2 (++) doesn't do the right thing
11:45:05 <ADEpt> stevan: http://www.haskell.org/ghc/docs/latest/html/libraries/regex-base/Text-Regex-Base-Context.html
11:45:06 <lambdabot> http://tinyurl.com/yovda9
11:45:33 <awesame> Network.CGI.formEncode doesn't escape semicolons!
11:46:08 <awesame> in form encoding, semicolons can be used to separate entries, like this: foo=bar;baz=qux
11:46:24 <elliottt> awesame: do any browsers send it that way?
11:46:40 <awesame> elliottt: I don't know
11:46:47 <awesame> likely not
11:47:04 <elliottt> it probably never came up during testing then.  you should send in a patch :)
11:47:25 <awesame> what's the best way to do that?  I'd be happy to.
11:47:42 <elliottt> the darcs repo is publically available, then you can just send your patch to bjorn
11:48:06 <awesame> cool, I'll do that
11:48:36 <elliottt> :)
11:53:54 <dancor> @pl \ x -> (x, True)
11:53:54 <lambdabot> flip (,) True
11:56:47 <dancor> is there a good way to combine two arrays
11:56:55 <dancor> like an azip corresponding to amap
12:01:12 <shepheb> dancor: it would be more complicated, it would need extra logic for the indexing.
12:01:22 <shepheb> how to combine the indexing, I mean.
12:01:31 <conal> is Array in Applicative?
12:01:54 <conal> if so, then liftA2 (,)
12:02:15 <conal> but i wonder what the index range would be
12:21:57 <hpaste>  Vulpyne pasted "(no title)" at http://hpaste.org/7035
12:22:37 <Vulpyne> So, I wrote a little function to consume all items available in a TChan. I'm curious as to why the first function works okay (basically doing stuff in IO) but the STM one deadlocks.
12:23:25 <Cale> Vulpyne: Are there other processes in the system writing to the TChan?
12:23:34 <Vulpyne> Yeah.
12:23:57 <Vulpyne> When it's called, it's called with atomically (consumeTChan' ...)
12:24:01 <Cale> Vulpyne: The latter transaction is arbitrarily long, and other actions that interfere with its behaviour will trample it.
12:24:12 <Vulpyne> So it will have to keep retrying forever?
12:24:30 <Cale> Basically, until it's able to read the whole channel without something new being put into it.
12:25:13 <Vulpyne> Hmm, I would expect that to be possible. Stuff's not being added to the channel all that fast.
12:25:17 <Vulpyne> Probably under 100 items/sec.
12:25:53 <Vulpyne> I'm sure you're right about the reason it hung, though. Thanks.
12:27:14 <Cale> One thing is that as it retries, the probability that it's able to read the whole channel in any given amount of time drops, because new items are being added.
12:27:47 <Vulpyne> I see.
12:28:08 <Vulpyne> Is consuming the TChan is that manner a relatively good way to accomplish the goal?
12:28:28 <Cale> The first one is reasonable.
12:28:35 <Vulpyne> Okay, thanks.
12:28:47 <Cale> I would generally try to restrict transactions to doing a bounded amount of work.
12:29:15 <Vulpyne> Yeah, up until this point, it was pretty much a single thing in atomically.
12:29:21 <Vulpyne> But then I had the bright idea to get clever. :)
12:30:22 <Cale> Of course, the point of transactions is to have more than one thing inside the atomically, but yeah, if you have something which is O(n), and reads things which are being written to elsewhere, that may be problematic :)
12:31:28 <Vulpyne> *nod*
12:43:49 <byorgey> http://byorgey.wordpress.com/2008/04/17/an-interesting-monoid/
12:43:50 <lambdabot> Title: An interesting monoid  blog :: Brent -> [String]
12:44:18 <byorgey> seriously, how does this happen?  I set out to dash off a quick little interesting blog post, and end up with this (part I of II).
12:44:39 <byorgey> I guess this bodes well for any future paper-writing endeavors ;)
12:51:32 <olsner> hmm, does any haskell file module have a symlink function?
12:51:52 <olsner> or do I have to runCommand on ln? :S
12:58:26 <dons> dcoutts_: I'm thinking of stubbing out all the *.Fusion stuff in bytestring.
12:58:34 <dons> just leave the module as a place holder, but remove all the old gunk
13:04:30 <Vulpyne> createSymbolicLink :)
13:04:53 <Vulpyne> In System.Posix.Files.
13:05:30 <olsner> aha!
13:05:36 <olsner> Vulpyne++
13:06:09 <olsner> @hoogle System.Posix.Files
13:06:10 <lambdabot> No matches, try a more general search
13:07:50 <Vulpyne> You're lucky that I'm using it my current project. :)
13:08:48 <laz0r> dons: i see you are here: i've built yi successfully, but i don't get an executable
13:09:14 <laz0r> dons: do i have to use the examples/yi.hs file somehow to launch yi?
13:10:06 <conal> byorgey: i like your post!
13:10:19 <byorgey> conal: thanks! =)
13:10:39 <byorgey> conal: just wait 'til Part II, I've got some code which I think is nifty.
13:10:47 <byorgey> conal: have you ever seen anything like this discussed before?
13:11:27 <conal> byorgey: not in these general terms.  i use the Max monoid for the semantics of future values.  But it assumes a complete order, as you point out.
13:11:51 <byorgey> conal: right.
13:11:51 <conal> byorgey: it's also related to the composition of the function and conjunction monoids
13:12:30 <byorgey> conal: hm, could you elaborate on that a bit?  I'm familiar with those monoids but don't immediately see the connection.
13:12:47 <conal> byorgey: i think you're maintaining a data representation of a subset of (a -> Bool).
13:13:38 <byorgey> ok, right
13:14:04 <lament> conal: in your paper, is it really necessary to explicitly provide the reactive value "before any events"? Couldn't you just assign it to an event at minus infinity, and simplify the type?
13:14:07 <conal> byorgey: s/Bool/All
13:14:32 <conal> lament: which reactive value is that?
13:15:18 <lament> data Reactive a = a `Stepper` Event a -- the first "a", also known as a_0
13:15:21 <conal> byorgey: i bet you could derive your monoid elegantly by a formal interpretation that maps it into a -> All.
13:15:54 <conal> lament: thx.  now i see.  yes, i could do that, and i was tempted to.
13:17:04 <conal> lament: the reasons i didn't are (a) losing a bit of static checking (always defined), and (b) i wanted different applicative&monad instances for the two types.
13:18:18 <byorgey> conal: what's All?
13:18:38 <conal> byorgey: in Data.Monoid: newtype All = All { getAll :: Bool }
13:19:00 <byorgey> oh, the conjunction monoid, ok =)
13:19:06 <conal> byorgey:  yes.
13:19:34 <conal> byorgey: and the function monoid, which relies on the range type being a monoid (e.g., All)
13:19:52 <conal> lament: i don't think either reason is terribly strong.
13:19:54 <byorgey> ok, right.
13:20:01 <byorgey> conal: cool!  I'll have to think about that some.  and if you have any more thoughts on the topic I'd love to hear them.
13:21:27 <conal> byorgey: sure.  :)  i'd define a "semantic function" that maps from your representation to a->All, and then define your monoid instance's semantics as a monoid morphism, as in my icfp submission.
13:22:04 <conal> byorgey: then use that semantics as a spec for deriving or proving the correctness of your monoid implementation.
13:22:24 <conal> byorgey: if you want to play with that idea, i'd be happy to help.
13:22:43 <byorgey> conal: ok, thanks, I will probably take you up on that. =)
13:23:18 <conal> byorgey: great.  i really like the idea of interpreting representations in terms of simpler models.  especially with this idea of type class morphisms.
13:23:30 <byorgey> conal: yeah, that's a neat idea.
13:23:38 <conal> (which sound brainer than they really are.)
13:24:00 <byorgey> conal: what you've said makes sense on an intuitive level, I'm sure I'll have to puzzle over the details a bit.
13:24:25 <conal> byorgey: of course.  have fun, and let me know, okay?
13:24:35 <byorgey> conal: I will, don't worry =)
13:24:46 <byorgey> conal++
13:25:11 <dejones> I'm using Haskell XML Toolbox, and readDocument returns this type "IOStateArrow s b XmlTree" -- I was wondering if I could create a "type" alias for that, such as I would for this "type Foo = String" --  any suggestions?  http://www.fh-wedel.de/~si/HXmlToolbox/hdoc_arrow/Text-XML-HXT-Arrow-ReadDocument.html#v%3AreadDocument
13:25:14 <lambdabot> http://tinyurl.com/yybvmz
13:25:30 <conal> :)
13:25:46 <conal> @karma
13:25:46 <lambdabot> You have a karma of 3
13:25:49 <dejones> I'm not sure how to handle the s and b for the type alias.
13:25:50 <conal> wow!
13:26:04 <Heffalump> @karma dons
13:26:04 <lambdabot> dons has a karma of 140
13:26:12 <Heffalump> you've got some way to go there :-)
13:26:12 <dejones> conal: you can help me now, I'll give you karma too!  :)
13:26:13 <dejones> hehe
13:27:26 <dejones> @seen Cale
13:27:26 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
13:27:29 <dejones> :(
13:27:35 <conal> @karma lambdabot
13:27:35 <lambdabot> lambdabot has a karma of 1
13:27:40 <dejones> lol
13:27:42 <dejones> @karma Cale
13:27:42 <lambdabot> Cale has a karma of 71
13:27:50 <lament> @karma c
13:27:50 <lambdabot> c has a karma of 15
13:27:55 <dejones> @karma dejones
13:27:55 <lambdabot> You have a karma of 0
13:27:58 <dejones> hehe
13:27:58 <conal> @karma c++
13:27:58 <lambdabot> c++ has a karma of -8
13:28:03 <dejones> lol
13:28:11 <conal> @karma ocaml
13:28:11 <lambdabot> ocaml has a karma of 0
13:28:13 <lament> @karma lisp
13:28:13 <lambdabot> lisp has a karma of 0
13:28:13 <macondo> @karma lol
13:28:14 <lambdabot> lol has a karma of 0
13:28:20 <dejones> ok, someone help me
13:28:20 <dejones> :)
13:28:26 <dejones> read above
13:28:26 <dejones> hehe
13:28:35 <lament> lisp++ -- it deserves at least positive karma!
13:28:49 <redbeard0532> @karma haskell
13:28:49 <lambdabot> haskell has a karma of 22
13:29:34 <shachaf> @karma curry
13:29:34 <lambdabot> curry has a karma of 0
13:29:48 <lament> @karma sex
13:29:49 <lambdabot> sex has a karma of 1
13:29:51 <dejones> no clue how I can make a type alias for "IOStateArrow s b XmlTree" such as "type Foo = String"  ?
13:30:03 <conal> not much sex on this channel
13:30:09 <Toxaris> can someone tell me what the difference between a "free algebra" and an "initial algebra" is?
13:30:12 <Saizan> dejones: type Foo s b = IOStateArrow s b XmlTree ?
13:30:21 <lament> i assume lambdabot shares karma between here and -blah
13:30:33 <lament> which is all about sex (but not veggie sex)
13:30:34 <redbeard0532> @karma monad
13:30:34 <lambdabot> monad has a karma of 1
13:30:43 <dejones> Saizan: ohh, lol.. I didn't realize that the "Foo s b" were possible for type aliases!  :)
13:30:55 <yav> @karma karma
13:30:55 <lambdabot> karma has a karma of 5
13:31:32 <dejones> Saizan: thanks!
13:31:36 <dejones> Saizan++
13:31:37 <dejones> :)
13:31:43 <redbeard0532> @karma lambdabot
13:31:43 <lambdabot> lambdabot has a karma of 1
13:31:52 <redbeard0532> lambdabot++
13:31:56 <yav> poor lambdabot
13:32:04 <shachaf> @karma java
13:32:04 <lambdabot> java has a karma of -22
13:32:10 <dejones> haha
13:32:12 <conal> snap!
13:32:16 <yav> :-)
13:32:17 <dejones> Saizan++
13:32:18 <redbeard0532> java--
13:32:28 <dejones> why isn't it karma-ing Saizan?
13:32:31 <dejones> :(
13:32:32 <elliottt> @karma java
13:32:32 <lambdabot> java has a karma of -23
13:32:50 <roconnor> @karma Saizan
13:32:50 <lambdabot> Saizan has a karma of 8
13:33:08 <dejones> hmm
13:33:09 <Saizan> 2?
13:33:50 <dejones> Saizan: lambdabot didn't respond to my ++ so I thought it didn't give you karma...
13:34:06 <dejones> Saizan: thanks again.
13:34:07 <shachaf> dejones: She only responds to @karma{,+,-}
13:34:23 <conal> oh!
13:34:30 <olsner> how do I pass -package unix to runghc?
13:34:31 <conal> java--
13:34:34 <Saizan> dejones: no problem :)
13:34:37 <conal> @karma java
13:34:37 <lambdabot> java has a karma of -24
13:34:44 <conal> worked
13:34:45 <olsner> heh, poor java
13:34:59 <shachaf> This is sort of a one-way thing.
13:34:59 <elliottt> java--
13:35:01 <conal> i guess java is the standard test case for --
13:35:30 <byorgey> conal: also, if you try to do ++ on java, it decreases your karma instead ;)
13:35:35 <Saizan> Toxaris: mmmh, they are defined differently but maybe they coincide?
13:35:49 <conal> byorgey: tricky!
13:35:52 <dejones> @karma+
13:35:52 <lambdabot> usage @karma(+|-) nick
13:36:01 <dejones> @karma+ Saizan
13:36:01 <lambdabot> Saizan's karma raised to 9.
13:36:04 <dejones> alright!
13:36:06 <dejones> :)
13:36:14 <Toxaris> Saizan: that's what I hope for in a sense
13:36:43 <shachaf> I compiled fresh darcs ghc today, and ghci doesn't seem to be using readline?
13:37:01 <Toxaris> Saizan: What I have is a type class, and one of the instances is an algebraic data type containing the type class members as constructors. Now how do i call this?
13:37:20 <roconnor> > 324%2592
13:37:22 <lambdabot>  1%8
13:37:38 <Toxaris> Saizan: Hmm. "type class members functions", or are they called "methods", I don't know
13:38:41 <redbeard0532> is there anything like ghci that implements all language features?
13:38:51 <Saizan> Toxaris: they are called in both ways, however i'm not sure which name i'd use :)
13:38:52 <redbeard0532> layout, functions, etc
13:39:02 <dons> ghci is like ghci :)
13:39:06 <Saizan> i've not seen a formal definition of "free"
13:39:23 <dejones> dons: ghci is idempotent with ghci?
13:39:24 <dejones> ;)
13:39:47 <macondo> @src (%)
13:39:47 <lambdabot> x % y = reduce (x * signum y) (abs y)
13:40:11 <shachaf> dons: ?
13:40:15 <shachaf> Oh, never mind.
13:40:16 <macondo> utterly beautiful
13:40:38 <redbeard0532> it just seems that many things dont work in interactive mode, only when saved to a file
13:40:41 <dons> macondo: :)
13:40:42 <Toxaris> Saizan: wikipedia knows both free and initial algebras, but defines them in different terms :( But it's good to know that you support my guess that they probably mean the same thing
13:40:54 <dons> redbeard0532: right, its expressions, not declarations
13:41:06 <dons> you're in a do-block, at the ghci prompt
13:41:23 <redbeard0532> rephrased: is there a ghci that allows declarations?
13:41:31 <roconnor> @go 4 C in F
13:41:31 <dons> ghci allows declarations
13:41:32 <lambdabot> http://en.wikipedia.org/wiki/F-4_Phantom_II
13:41:35 <dons> let x = 1
13:41:35 <conal> byorgey: do you know about jsMath (http://www.math.union.edu/~dpvc/jsmath)?  it lets (part of) the latex rendering to be done on the client.  i've played with it some and have thought about using it in my blog.
13:41:52 <dons> (the same ones you can write in a do-block)
13:41:57 <byorgey> conal: I've heard of it, but never tried it out.
13:42:09 <conal> byorgey: one benefit is that the math zooms with the text.  also prints beautifully.  and presumably much smaller downloads.
13:42:26 <conal> so many things about the web follow the principle of decompress-then-transmit
13:42:47 * olsner cries. The package trouble I had was caused by forgetting the final 's' in System.Posix.Files
13:42:51 <byorgey> hehe
13:42:51 <dejones> roconnor: you got back the F4 phantom for "4 C in F" ?  lol
13:42:53 <redbeard0532> dons: if i'm not mistaking, there are some things you still cant do in ghci
13:43:01 <macondo> @src reduce
13:43:01 <lambdabot> reduce _ 0 = undefined
13:43:01 <lambdabot> reduce x y = (x `quot` d) :% (y `quot` d)
13:43:01 <lambdabot>     where d = gcd x y
13:43:02 <byorgey> conal: yeah, it sounds nice.  I should take a loot.
13:43:06 <byorgey> er, *look
13:43:21 <shachaf> > 4 * 9 / 5 + 32
13:43:22 <lambdabot>  39.2
13:43:24 <macondo> ah there's the magic
13:43:24 <dons> redbeard0532: right, you can't define types, instances, modules
13:43:41 <dons> redbeard0532: you are literally in a sequential do block, semantically
13:43:44 * shachaf almost always converts in the other directio, though. :-)
13:43:50 <dons> since you're typing things in in order
13:44:05 <dons> so the usual haskell magic of arbitrarily ordered decls, and mutual recursion, kind of breaks down
13:44:51 <shachaf> hbi let you do a lot of that, didn't it?
13:45:04 <dons> i don't think so.
13:45:09 <redbeard0532> dons, i would think that layout could still be made to work
13:45:11 * dons fires up hbi
13:45:17 <dons> redbeard0532: layout does work, yes.
13:45:27 <dons> {| or something introduces a layout block in ghci
13:45:27 * Heffalump is currently playing around with fsc
13:45:40 <shachaf> dons: :{ ?
13:45:45 <Toxaris> dons: how does that work?
13:45:45 <dons>     <topdecl> ;
13:45:46 <dons> 	Any top level declaration except <decl>.
13:45:53 <dons> hbi *does* allow top level decls
13:46:24 <dons> > type T = Int;
13:46:24 <lambdabot>  Parse error at "type" (column 1)
13:46:24 <dons> type T = Int
13:46:26 <dons> works.
13:46:28 <dons> hbi++
13:46:39 <dons> ok. so now we have something to complain to JaffaCake about
13:46:57 <dons> that's with HBI  -- Interactive Haskell B 1.3
13:47:11 <dons> you can make fixity decls too
13:47:12 <shachaf> Simon Marlow is in here?
13:47:14 <roconnor> > 7 % 42
13:47:14 <JaffaCake> heh
13:47:14 <lambdabot>  1%6
13:47:15 * shachaf didn't know that.
13:47:27 <dons> JaffaCake: did you know hbi allows any top level decl at the prompt?
13:47:49 <JaffaCake> now you mention it, I think I remember it doing that
13:47:57 <dons> well, it still does. :)
13:48:08 <JaffaCake> augustss++
13:50:13 <redbeard0532> is hbi still active?
13:51:19 <dons> http://www.cse.unsw.edu.au/~dons/tmp/hbi.txt
13:52:01 <shachaf> redbeard0532: Well, the last release was >10 years ago.
13:52:27 <dejones> redbeard0532: http://www.cs.chalmers.se/~augustss/hbc/hbc.html, page was last modified in 1998...
13:52:28 <lambdabot> Title: The HBC compiler
13:54:50 <Baughn> > let foo ((+1) -> x) = x in foo 1
13:54:51 <lambdabot>  Parse error at "->" (column 15)
13:57:24 <macondo> @help
13:57:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:57:32 <macondo> @list
13:57:32 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
13:58:34 <macondo> you are everywhere, dons
13:58:41 <macondo> ;)
13:58:56 <swiert> conal: just out of curiosity, what application did you have in mind for type class transformers?
13:59:51 <conal> swiert: do you mean type class morphisms?
14:00:03 <swiert> conal: yes.
14:00:50 <conal> swiert: for denotational semantics of data types.  my icfp submission has several examples.  and byorgey's latest blog post is another opportunity.
14:01:43 <redbeard0532> when is icfp this year?
14:02:09 <swiert> conal: what do you mean when you say "type class morphism"?
14:02:12 <olsner> gaah! getSymbolicLinkStatus /= getFileStatus :(
14:02:17 <conal> swiert: when i was writing down & factoring my frp semantics, i kept noticing the pattern.
14:03:44 <conal> swiert: what a natural transformation is to Functor, a monad morphism is to Monad, and a monoid homomorphism is to Monoid.
14:04:56 <swiert> conal: ok. So the arrows in the category induced by the type class, somehow.
14:05:24 <conal> swiert: e.g., (reactive) behaviors have a semantic function "at :: Behavior a -> (Time -> a)", and its Applicative instance is specified as at (pure a) = pure a; at (bf <*> bx) = at bf <*> at bx.
14:05:45 <conal> swiert: yes, i think so.
14:06:05 <swiert> conal: I've been looking for applications of "type class transformers". Suppose Haskell had first-class type classes - what functions might you write on them?
14:06:27 <swiert> conal: which is something entirely different, I think.
14:06:48 <conal> swiert: oh ... may be related somehow, though i don't see it now.
14:07:24 <conal> swiert: i guess the morphisms preserve the type class structure, while the transformers change it.
14:07:37 <lament> combine :: TypeClass -> TypeClass -> TypeClass -- ?
14:07:41 <swiert> conal: yes. that sounds right.
14:08:19 <byorgey> conal: but if type classes were first-class objects, you could write type class morphisms as functions, I think.  You just wouldn't be forced to write functions that correspond to valid morphisms.
14:09:53 <swiert> Maybe I should be a bit more specific: when type theorists describe a collection of types that share some property, they define something called a universe.
14:10:39 <swiert> So there's some kind of relation between type classes and universes.
14:10:56 <swiert> And type theorists manipulate universes, define universe transformers, etc.
14:11:32 <swiert> I was wondering if there are any examples of that kind of thing in Haskell.
14:12:01 <swiert> (lament: the operation you mentioned is pretty much a no-op in this setting, unfortunately.)
14:12:21 <conal> swiert: doesn't ring a bell for me, but i'd sure be interested to hear if you do find an application.
14:13:00 <swiert> conal: yeah. I've found a few fairly exotic ones, but nothing very convincing somehow.
14:26:58 <dejones> Haskell is so great; the complexity constantly makes my brain hurt.  :)
14:27:11 <dons> its supposed to be removing complexity :)
14:27:22 <dons> no side effects, no runtime type checks
14:27:30 <dons> no mutation, no race conditions, ... :)
14:27:44 <dejones> Well, I should say that the things that can be accomplished with Haskell add complexity, which makes my brain hurt.
14:28:24 <dogbite> if it's any consolation, it makes my brain hurt too
14:28:28 <lament> that hurting you feel is your brain cells dying
14:28:49 <Vulpyne> Realigning brains can hurt.
14:28:49 <dejones> dons: but, I absolutely agree that those other things remove other types of complexity.  ;)
14:29:08 <byorgey> Haskell may be less complex than other languages, but it's like the difference between being in an ugly, complex spaceship, and floating in space: at least in the spaceship you didn't have to contemplate the stars.
14:29:19 <Philippa> dejones: that, or it puts the actual complexity in a task in front of you instead of letting you bury it and subsequently mess it up
14:29:53 <dejones> Philippa: quite true.
14:29:57 <lament> that hurting you feel is your brain cells dying... due to lack of oxygen :)
14:31:34 <dejones> for example, "editRefs = foldl (>>>) this . map (\ (en, an) -> editRef en an) $ [ ("a", "href"), ("img", "src") ] where editRef = ..."
14:31:58 <dejones> dons: that example is combining a lot of concepts that are not so "normal" to me.  ;)
14:32:07 <dejones> but, I enjoy it.
14:33:22 <lament> that looks like the kind of intentional obfuscation haskellers seem to enjoy
14:33:28 <dejones> lol
14:34:11 <dejones> http://www.haskell.org/haskellwiki/HXT -- that example is from the Haskell XML Toolbox tutorial, and the guy is showing that you can "simplify" the functions ;)
14:34:12 <lambdabot> Title: HXT - HaskellWiki
14:35:14 <dejones> the code then becomes, "editRefs = seqA . map (uncurry editRef) $ [ ... ] where editRef = ...
14:35:16 <dejones> "
14:35:45 <dejones> I do like seeing the steps of how someone combines complex things into shorter compositions.
14:36:38 <redbeard0532> the uncurry is prolly the simplest simplification there
14:37:13 <redbeard0532> by that I mean its the only one i saw ahead of time... ;)
14:37:54 <dejones> lol
14:37:59 <Philippa> lament: for my money it could do with refactoring in terms of some explanatory where-bindings
14:38:38 <lament> ah, but that entire thing is itself a where-binding
14:38:42 <Philippa> also, you'd be better off having editRef (which is defined locally) take a pair to start with so the map can be just 'map editref'
14:39:19 <lament> good point
14:39:21 <Philippa> l the bits I'd suggest binding are 'foldl (>>>) this' and the list
14:39:23 <dejones> Philippa: ahh, yea, that does sound better.
14:39:47 <dejones> :)
14:40:19 <Philippa> if you can't see the domain concepts, the code's not high-level :-)
14:43:18 <redbeard0532> hmm what am i doing wrong:
14:43:22 <redbeard0532>  darcs pull --tag="4.1.0"
14:43:22 <redbeard0532> Pulling from "http://darcs.haskell.org/crypto"...
14:43:22 <redbeard0532> You don't want to pull any patches, and that's fine with me!
14:43:35 <sjanssen> redbeard0532: you already have that tag?
14:43:38 <olsner> hmm, I'd like to be able to put my IO-heavy haskell program in a read-only IO sandbox
14:44:03 <sjanssen> redbeard0532: oh, shouldn't it be darcs pull --tag=4.1.0 ?
14:45:41 <redbeard0532> sjanssen: thats equivalent
14:46:20 <redbeard0532> sjanssen: i have 4.0.3 but yi needs 4.1.0. is there a better way to switch versions?
14:46:34 * redbeard0532 is newish to darcs
14:55:21 <Saizan> redbeard0532: have you built and installed the package after pulling?
14:56:27 <redbeard0532> yup, Crypto-4.0.3 is listed in ghc-pkg -l
14:57:07 <Saizan> but you say you want 4.1.0 no?
14:57:34 <olsner> "Be careful, if the directory contains symlinks, the function will follow them." *phew* I almost ran my program with a call to that function
14:58:20 <olsner> that would have deleted about 450GiB
14:58:54 <lament> that's a lot of porn
14:59:04 <roconnor> > 1000 - 4 - 566
14:59:06 <lambdabot>  430
15:00:20 <olsner> lament: nah, porn only accounts for about 15% of that data
15:00:40 <macondo> > 0.15 * 450
15:00:41 <lambdabot>  67.5
15:00:56 <olsner> > 0.16 * 450
15:00:57 <lambdabot>  72.0
15:01:07 <olsner> hmm, closer to 16%
15:01:17 <macondo> that's a lot of porn
15:01:39 <redbeard0532> Saizan: yes
15:01:58 <redbeard0532> is the best bet to just delete that dir and redownload?
15:02:07 <Saizan> redbeard0532: how have you installed 4.0.3?
15:02:19 <reppie> testing is a religion
15:02:48 <olsner> @ty throwIO
15:02:49 <lambdabot> Not in scope: `throwIO'
15:02:52 <olsner> @ty throw
15:02:53 <lambdabot> Not in scope: `throw'
15:03:12 <ddarius> :t ioError
15:03:13 <lambdabot> forall a. IOError -> IO a
15:03:23 <mib_dtxncrg4> Hi all, I'm trying to install the array package. but one problem is being reported: Data/Array/Base.hs:431:0:parse error (possibly incorrect indentation)
15:03:55 <mib_dtxncrg4> Data/Array/Base.hs:431:0  parse error (possibly incorrect indentation)
15:04:21 <redbeard0532> Saizan: download; runghc Setup.h {configure --prefix=/usr/local, build, install}
15:04:50 <Saizan> mib_dtxncrg4: are you sure you don't have it already, "ghc-pkg list array" to check
15:05:17 <mib_dtxncrg4> yes... I'm sure that I dont have it
15:05:23 <Saizan> redbeard0532: by download you mean darcs pull?
15:05:50 <redbeard0532> yup
15:07:21 <travisbrady> anyone have any pointers on writing an rle function that yields triples of the form (value, start, runlength)?
15:07:52 <travisbrady> the example dons posted on his blog a while back does (value, runlength), but adding start to that is a bit harder, at least for me
15:08:24 <monochrom> I'm looking for newbies to eat.
15:08:37 <dejones> ?
15:08:47 * dejones passes monochrom a newbie.
15:08:52 <ddarius> zipWith (\i (x,y) -> (x,i,y)) [0..] (head&&&length) . group $ "aabbccccdf"
15:08:52 <dejones> :)
15:08:56 <ddarius> > zipWith (\i (x,y) -> (x,i,y)) [0..] (head&&&length) . group $ "aabbccccdf"
15:08:56 <lambdabot>  Couldn't match expected type `[(t, t1)]'
15:09:25 <ddarius> > zipWith (\i (x,y) -> (x,i,y)) [0..] . map (head&&&length) . group $ "aabbccccdf"
15:09:26 <lambdabot>  [('a',0,2),('b',1,2),('c',2,4),('d',3,1),('f',4,1)]
15:09:59 <ddarius> > map (head&&&length) . groupBy snd $ zip [0..] "aabbccccdf"
15:09:59 <lambdabot>      Occurs check: cannot construct the infinite type:
15:09:59 <lambdabot>       b = (a, b) -> Bo...
15:10:03 <travisbrady> ddarius: ahh, excellent thank you
15:10:11 <dejones> > foldl (++) "" ["n", "e", "w", "b", "i", "e"] -- for monocrom
15:10:11 <lambdabot>  "newbie"
15:10:17 <dejones> :P
15:10:31 <ddarius> > map (head&&&length) . groupBy ((==) `on` snd) $ zip [0..] "aabbccccdf"
15:10:32 <lambdabot>  [((0,'a'),2),((2,'b'),2),((4,'c'),4),((8,'d'),1),((9,'f'),1)]
15:10:33 <augustss_> yo!
15:10:46 <dejones> augustss_: you missed the hbi convo ;)
15:11:12 <augustss_> well, there are logs
15:11:15 <dejones> :)
15:11:44 <ddarius> A bunch of people saying how hbi was an improvement on its successors?
15:12:06 <tromp> > join ["n", "e", "w", "b", "i", "e"]
15:12:07 <lambdabot>  "newbie"
15:12:47 <dejones> tromp: monochrom doesn't seem to want our newbies.
15:13:13 <augustss_> dejones: yep, there's no reason not to allow top level declaration at the command prompt.
15:13:22 <mib_dtxncrg4> how can I install the array package, besides runhaskell, runghc, ...?
15:13:32 <ddarius> cabal install array
15:13:53 <monochrom> ghc -O2 --make Setup.hs; ./Setup
15:14:31 <dejones> augustss_: I believe redbeard0532 was asking about it.
15:14:39 <dejones> hbi, that is
15:14:54 <augustss_> I have no idea why it's not implemented in ghci
15:15:09 <augustss_> probably because hugs doesn't have it
15:15:40 <chessguy> hey byorgey, interesting blog today
15:15:51 <ddarius> What was the Gofer top-level like (assuming it had an interactive mode)?
15:16:06 <sjanssen> augustss_: how did hbi handle multiple line input?
15:16:07 <dejones> augustss_: did ghci spawn from hugs...?
15:16:37 <ddarius> dejones: GHC existed long before Hugs.
15:16:44 <augustss_> sjanssen: you could use {;} if I remember right.
15:17:02 <augustss_> ddarius: hugs existed long before ghci
15:17:05 <dejones> ddarius: I was asking about ghci...
15:17:20 <augustss_> dejones: the commands in ghci are patterned after hugs
15:17:26 <dejones> I see.
15:21:27 <mib_dtxncrg4> ok.... I tried to install cabal (downloaded it, make install, .....) but I think that "cabal" is not recongnized as a command in my environment (mac-os)
15:25:47 <chessguy> @seen byorgey
15:25:47 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
15:25:52 * chessguy kicks the bot
15:26:21 <ddarius> mib_dtxncrg4: The 'cabal' command is in the 'cabal-install' package.  The 'cabal' package is the supporting library.
15:26:50 <augustss_> @botsnack
15:26:50 <lambdabot> :)
15:28:21 <mib_dtxncrg4> ddarius: ok.. thanks. the distribution package is only available at: http://darcs.haskell.org/cabal-install/ .... I mean, does exist a zipped distribution?
15:28:21 <shachaf> preflex: seen byorgey
15:28:22 -preflex(n=preflex@d90-128-46-80.cust.tele2.de)- byorgey was last seen on #haskell 59 minutes and 12 seconds ago, saying: Haskell may be less complex than other languages, but it's like the difference between being in an ugly, complex spaceship, and floating in space: at least in the spaceship you didn't have to contemplate the stars.
15:28:23 <lambdabot> Title: Index of /cabal-install
15:29:09 <ddarius> mib_34qt8j8d: cabal-install is on Hackage just like everything else
15:29:28 <chessguy> preflex, help
15:29:35 <chessguy> preflex: list
15:29:41 <chessguy> hmph
15:29:43 <Japsu> preflex: version
15:29:43 -preflex(n=preflex@d90-128-46-80.cust.tele2.de)- 4.126
15:29:46 <Japsu> lol
15:29:51 <Japsu> now THAT'S informative
15:30:05 <chessguy> it could have been worse - it could have rounded
15:30:10 <Japsu> ;D
15:30:22 <chessguy> then again, maybe it did
15:31:26 <shachaf> preflex: seen test
15:31:27 -preflex(n=preflex@d90-128-46-80.cust.tele2.de)- Sorry, I haven't seen test
15:31:33 <shachaf> Hmm.
15:31:39 <ddarius> preflex: seen preflex
15:31:40 -preflex(n=preflex@d90-128-46-80.cust.tele2.de)- Sorry, I haven't seen preflex
15:31:44 <chessguy> preflex, seen chessguy
15:31:44 -preflex(n=preflex@d90-128-46-80.cust.tele2.de)- chessguy was last seen on #haskell 1 minute and 22 seconds ago, saying: then again, maybe it did
15:31:52 <chessguy> preflex, seen chessguy
15:31:52 -preflex(n=preflex@d90-128-46-80.cust.tele2.de)- chessguy was last seen on #haskell 8 seconds ago, saying: preflex, seen chessguy
15:32:16 <TomMD> Does preflex use one of the common Haskell IRC bot libs?
15:32:28 <chessguy> TomMD, there's more than one?
15:32:43 <TomMD> Are infinity and Lambdabot the same?
15:32:44 <Japsu> chessguy, there's even one?
15:32:45 <chessguy> preflex, @run 2
15:33:03 <chessguy> Japsu, sure, lambdabot
15:33:07 <ddarius> TomMD: Neither of those are IRC or IRC bot libraries.
15:33:08 <Japsu> Bah
15:34:06 <chessguy> preflex, tell chessguy test
15:34:31 <ddarius> preflex, karma- chessguy
15:34:49 <ddarius> preflex, karma chessguy
15:34:49 -preflex(n=preflex@d90-128-46-80.cust.tele2.de)- chessguy has no karma
15:34:53 * chessguy raises an eyebrow at ddarius 
15:35:03 <TomMD> ddarius: "infinity package (version 0.3)a tiny, pluggable irc bot "  Not correct?
15:35:16 <ddarius> IRC bot /= IRC bot library
15:35:33 <TomMD> lol, ok, if you want to split hairs.
15:35:45 <chessguy> lambdabot, tell byorgey i wonder if your partial knowledge monoid would be useful in contexts where we don't know precisely what we're looking for.
15:36:12 <TomMD> if it IS something instead of the library for something and it IS open source then I'll accept it as a 'library'.
15:36:43 <ddarius> TomMD: If you want to join hairs.
15:37:02 <chessguy> @hoogle split
15:37:02 <lambdabot> Data.ByteString.split :: Word8 -> ByteString -> [ByteString]
15:37:02 <lambdabot> Data.Set.split :: Ord a => a -> Set a -> (Set a, Set a)
15:37:02 <lambdabot> Data.Map.split :: Ord k => k -> Map k a -> (Map k a, Map k a)
15:38:38 <mib_dtxncrg4> just one more question..... for installing cabal-install, I need HTTP. however, a new problem arrise when I'm trying to install HTTP: 'Executable' stanza starting with field 'flag old-base description'
15:39:53 <shachaf> mib_dtxncrg4: Upgrade cabal?
15:40:58 <mib_dtxncrg4> two versions are installed: Cabal-1.1.6, Cabal-1.2.3.0
15:41:19 <mib_dtxncrg4> I've hide the Cabal-1.1.6
15:41:19 <elliottt> mib_dtxncrg4: ghc-pkg hide Cabal-1.1.6
15:41:24 <elliottt> ah, :)
15:41:35 <elliottt> did you clean and reconfigure?
15:41:43 <elliottt> (the package)
15:41:51 <mib_dtxncrg4> no... please, how can I do this?
15:41:58 <shachaf> mib_dtxncrg4: runghc Setup clean
15:42:23 <shachaf> (But if the configure didn't work in the first place, this might not help much.)
15:44:06 <hpaste>  travisbrady pasted "Removing print yields error" at http://hpaste.org/7036
15:44:16 <travisbrady> can anyone tell me what that means? ^^
15:45:38 <shachaf> travisbrady: The monomorphism restriction.
15:46:07 <shachaf> travisbrady: GHC doesn't know what type to give to encode unless you use it somewhere.
15:46:13 <elliottt> mib_dtxncrg4: runghc Setup clean
15:46:20 <shachaf> travisbrady: Or add an explicit type signature (probably preferable).
15:46:42 <elliottt> mib_dtxncrg4: any luck, or stil the same problem?
15:46:50 <mib_dtxncrg4> same problem
15:46:54 <mib_dtxncrg4> :(
15:47:24 <travisbrady> shachaf: thanks
15:47:25 <shachaf> Or add an explicit argument.
15:47:38 <MarcWeber> Which is the recommended way to install ghc-6.8 on debian ? using deb http://haskell-unsafe.alioth.debian.org/archive/i386 . unstable testing stable ?
15:47:42 <lambdabot> Title: Index of /archive/i386
15:47:43 <shachaf> travisbrady: Or use -XNoMonomorphismRestriction.
15:48:09 <elliottt> mib_dtxncrg4: you're sure that Cabal-1.1.6 is hidden?  I'm not sure what else could be creating this problem :/
15:49:10 <sieni> how many haskell coders would it take to change a light bulb?
15:49:49 <mib_dtxncrg4> yes, when I run ghc-pkg list, the response is (Cabal-1.1.6)...
15:49:57 <monochrom> Would you like a value-level answer or a type-level answer? :)
15:50:30 <elliottt> mib_dtxncrg4: well, that should do it.  i'm not sure how it could be confusing the flag definition with the old-style executable stanza :(
15:51:12 <sieni> monochrom: type-level please, since I have the value-level answer ,-)
15:54:03 <sieni> ... it must be infinitely many, since finitely many haskellers couldn't possibly have effected a change of state...
15:55:03 <monochrom> changing a light bulb is like turning an unevaluated thunk into evaluated.
15:55:47 <sieni> yeah, I guess that's why haskell is so appeliang to coders
15:56:22 <sieni> having sex is like turning a thought about it into action
15:56:55 <monochrom> sometimes there is no thought, just action.
15:57:06 <sieni> I guess I should be on stricter channels, I guess
15:58:36 <travisbrady> ddarius: re: this rle func zipWith (\i (x,y) -> (x,i,y)) [0..] . map (head&&&length) . group $ "aabbccccdf", why is the composition operator needed between th [0..] and the map?
15:59:05 <Botje> unsafePerformSex :: Person -> Person -> (Maybe Orgasm, Maybe STD, Maybe Pregnancy)
15:59:20 <travisbrady> :t zipWith
15:59:20 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
15:59:26 <monochrom> the composition operator is between zipWith (\i (x,y) -> (x,i,y)) [0..] and map (head&&&length).
16:00:07 <travisbrady> monochrom: oh i see, thank you
16:01:25 <mib_dtxncrg4> mib_dtxncrg4: thanks a lot... tomorrow I will try again!
16:01:44 <monochrom> why is he thanking himself?
16:01:55 <monochrom> let x = thank x in x?
16:03:33 <shachaf> monochrom: fix thank?
16:06:37 <shachaf> monochrom: ? <monochrom> the composition operator is between zipWith (\i (x,y) -> (x,i,y)) [0..] and map (head&&&length).
16:07:02 <shachaf> Oh, wrong person.
16:07:04 <shachaf> Sorry.
16:42:42 <Sadache> Hello everyone
16:43:41 <shachaf> Sadache: Hello.
16:43:47 <Sadache> I saw in an example of computations on lazy trees a trick that I would like to know its name
16:44:36 <dons> knot tying?
16:44:48 <Sadache> it is when we say where(tr,m)= someFunction then i use the m inside the the body of this function
16:45:12 <dons> inside the body of 'someFunction' ?
16:45:21 <Sadache> yes
16:45:27 <dons> where (tr, m) = .. f m ... ?
16:45:45 <Sadache> yeah something like that
16:45:49 <dons> so probably "knot tying", or maybe just laziness. but its relying on recursion and laziness
16:45:56 <Sadache> hold i have the example
16:46:05 <Sadache> can i paste it in here?
16:46:08 <dons> ?pate
16:46:08 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:47:28 <hpaste>  Sadache pasted "Lazy Trees" at http://hpaste.org/7038
16:48:47 <dons> hmm, that looks like a bug :)
16:49:00 <dons> f tr = tr where (tr, m) = walk tr
16:49:15 <hpaste>  Sadache pasted "Lazy Trees" at http://hpaste.org/7039
16:50:22 <shachaf> dons: That might be a tr'?
16:51:45 <Sadache> data Tree a = Leaf | Node a (Tree a) (Tree a)
16:51:57 <Sadache> addMax tr = tr’
16:52:08 <Sadache> where (tr’, m) = walk tr
16:52:11 <Saizan> it's using m in the definition of walk, that's "tying the knot"
16:52:21 <Sadache> walk Leaf = (Leaf, 0)
16:52:31 <dons> ah
16:52:41 <Sadache> walk (Node n l r) = (Node (n + m) l’ r’,
16:52:49 <Sadache> max3 n ml mr)
16:52:59 <Sadache> where (l’,ml) = walk l
16:53:08 <Sadache> (r’,mr) = walk r
16:53:25 <Sadache> max3 a b c = max a (max b c)
16:53:36 <Sadache> so that is tying the knot?
16:54:39 <Sadache> any tutorials or simple examples about that?
16:54:43 <Saizan> yeah, defining a value using itself
16:55:11 <Saizan> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
16:55:13 <dons> > let xs = 1:xs in xs
16:55:19 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
16:55:19 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
16:55:27 <dons> yay laziness
16:55:54 * shachaf prefers the fibonacci sequence that starts with 1.
16:56:25 <Saizan> me too, but 0 : 1 : looks nicer than 1 : 1 :
16:56:36 <shachaf> Saizan: It does?
16:56:44 <Saizan> to me, at least
16:57:02 <shachaf> Saizan: I think of it as "here are the first two terms of the sequence, and a method of computing the rest".
16:57:13 <Sadache> I see, i found a page about it in the wiki, it is so hard to reason in that way for imperative programmers :S
16:57:19 <Sadache> you guys rock
16:57:23 <Saizan> > fix $ (1:) . scanl (+) 1
16:57:36 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
16:58:04 <Saizan> shachaf: right
16:58:07 <Sadache> do you know any tutorials?
17:00:01 <Saizan> not specifically on this
17:00:03 <monochrom> "tying the knot" is just a special case of recursion.
17:00:20 <monochrom> Previously you have done it to functions. Now do it to values too.
17:00:44 <Sadache> so the only special thing about it is that it is dont to types?
17:01:02 <monochrom> Sorry, I cannot parse "dont to types".
17:01:51 <Sadache> sorry donE, I am having hard time with my azerty keyboard
17:01:54 <Saizan> altough you need laziness to make it work for types
17:02:00 <monochrom> done to values, not types.
17:02:11 <Sadache> ok
17:02:18 <Saizan> err, i meant values in constrast to functions
17:02:38 <Sadache> i see
17:03:11 <Sadache> great, i ve got to go to sleep, thanks for the answer
17:03:22 <monochrom> Perhaps a good transition is to begin with functions still, but make sure the functions don't use their parameters, e.g., functions with parameter type ().
17:03:52 <Sadache> but you can not pattern match functions, can u?
17:04:12 <monochrom> E.g., zeros () = 0 : zeroes ().  This you can reason about using what you already know.
17:04:55 <Sadache> what makes it crazy for me is when you start using part of the result inside the definition
17:05:06 <Sadache> like in (tr',m)
17:06:39 <Sadache> bye
17:14:59 <monochrom> I have a hypothesis that if you are imperative, you have to be the most devout imperative to understand pure lazy functional. You visualize the pointer graph, the cycles in that graph, the thunks, the events that trigger evaluation of the thunks, and then it all makes sense, at least for beginner examples.
17:15:28 <monochrom> If you're just "CS freshman" imperative, you won't get it.
17:15:54 <roconnor> and if you are mathematical?
17:16:06 <ddarius> roconnor: Then it should be no problem.
17:16:23 <monochrom> Oh, if you're mathematical, there are very easy mathematical approaches. :)
17:17:02 <ddarius> f(x) = 1 + x*f(x)
17:17:58 <roconnor> what is the type of x?
17:18:52 <ddarius> roconnor: How often do you hear mathematicians ask what the type of something is?
17:19:19 <roconnor> usually they have more context to go with.
17:19:20 <ddarius> roconnor: Preferably, it's a member of some division ring (I think that has enough structure)
17:19:44 <ddarius> But for simplicity, x \in R works
17:20:25 <macondo> ddarius: btw, is there a way to determine if a result is, say, a natural number?
17:21:21 <ddarius> I believe you asked a similar question and were given answers yesterday.
17:22:15 <macondo> I had to go and don't remember what the answers were, if any
17:24:10 <fnoble> ddarius: haskell would still get stuck if you tried to do anything with that function though?
17:24:17 <fnoble> even if it wasnt divergent
17:24:41 <ddarius> fnoble: Depends on the definition of + and *
17:26:39 <fnoble> for x being a real, I can't see how laziness would help :) it still must run forever?
17:26:54 <monochrom> He has to go again. :)
17:28:43 <ddarius> fnoble: There are no reals in computer programming, but if you stuck to constructible reals, I'm pretty sure I can make that definition work in Haskell for some values of x.
17:29:28 <ddarius> There's a reason I chose that particular function.
17:39:35 <roconnor> in "... with Curried types" should "Curried" have a capital C and no y?
17:41:18 <ddarius> Sure
17:41:29 <roconnor> that seems kinda fucked up.
17:41:50 <ddarius> roconnor: Note that my response would have been the same for every permutation
17:42:14 <roconnor> "curryed" seems wrong.
17:45:50 * EvilTerran would write it as one of [Cc]urried. definitely not [Cc]urryed.
17:53:26 <dancor> if i unregistered bystring-0.9.0.4, then re-downloaded Yi, how could it say: [20 of 78] Compiling Yi.Buffer.Implementation ( Yi/Buffer/Implementation.hs, dist/build/Yi/Buffer/Implementation.o )
17:53:52 <dancor> Failed to load interface for `Data.ByteString': no package matching bytestring-0.9.0.4 was found
17:54:18 <dancor> i could understand an error about something else being built against 0.9.0.4..
17:58:07 <fnoble> Curried should be spelled with a capital because it is named after a person
17:58:49 <fnoble> after Haskell Curry
18:01:31 <fnoble> as im sure people know already :)
18:05:29 <shachaf> preflex: seen Cale
18:05:30 -preflex(n=preflex@d90-128-46-80.cust.tele2.de)- Cale was last seen on #haskell 5 hours, 35 minutes and 6 seconds ago, saying: Of course, the point of transactions is to have more than one thing inside the atomically, but yeah, if you have something which is O(n), and reads things which are being written to elsewhere, that may be problematic :)
18:06:07 <Cale> @seen Cale
18:06:08 <roconnor> preflex: hey baby, can I buy you a drink?
18:06:11 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
18:06:19 <roconnor> @vixen hey baby, can I buy you a drink?
18:06:20 <Cale> hmm, I wonder what caused that.
18:06:25 <lambdabot> hiya
18:06:30 <dons> the State/seen file got corrupted
18:06:31 <ddarius> Cale: How'd you break @seen?
18:06:42 <dons> probably due to something powering down/crashing
18:06:56 <Cale> I haven't touched @seen, but it seems like something destroyed most of the State/ directory a while back
18:07:01 <roconnor> dons: need more transactions.
18:07:02 <Cale> I restored a bunch of it from darcs
18:07:20 <dons> yeah, its still broken
18:07:21 <dons> ?users
18:07:27 <dons> i was hoping it would flush
18:07:56 <Cale> @seen Cale
18:08:05 <Cale> ...
18:08:05 <lambdabot> You are in #ghc and #haskell. I last heard you speak just now.
18:08:07 <Cale> okay
18:08:11 <dons> ?users
18:08:16 <Cale> I just deleted the blank seen file which was there
18:08:19 <lambdabot> Maximum users seen in #haskell: 408, currently: 407 (99.8%), active: 2 (0.5%)
18:08:19 <dons> yep. good
18:17:33 <shapr> @yow !
18:17:33 <lambdabot> I like your SNOOPY POSTER!!
18:17:36 <shapr> Excitement!
18:17:40 <shapr> !paste
18:17:40 <hpaste> Haskell paste bin: http://hpaste.org/
18:17:42 <shapr> yay
18:17:54 <monochrom> snoopy poster?!
18:19:16 <ddarius> monochrom: If it made sense to you, you'd know you were suffering from brain damage.
18:24:06 <uebayasi> welcome back all :)
18:39:33 <solrize_> monochrom @ 1 hour ago : you are exactly right, lazy evaluation made no sense to me until I read SPJ's book about graph reduction
18:39:52 <monochrom> nice
19:01:55 <chessguy> 'ello
19:03:54 <geezusfreeek> 'ello
19:11:53 <OceanSpray> 'ello
19:14:31 <saml> hi OceanSpray
19:14:56 <roconnor> 'ello saml
19:15:34 <saml> $(putH 'ello)
19:25:04 <mofmo1> is there something similar to (define (foo args . arbitrary-length-args) blahblha)
19:25:15 <mofmo1> i'm interested in . arbitrary-length-args
19:25:37 <ddarius> @src printf
19:26:08 <ddarius> The simple solution is to pass a list...
19:26:40 <mofmo1> well that sort of defeats the purpose of what i'm doing
19:31:52 <geezusfreeek> is there no way to prevent a type class instance from being exported (to prevent orphan instances)?
19:32:10 <sw17ch> mofmo1, what are you trying to do?
19:33:56 <geezusfreeek> i'm dying to use some Applicative instances for some of the standard monads
19:34:15 <geezusfreeek> i guess i could just use ap
19:35:50 <Cale> One nice thing about Applicative is that the composition of monads, while not canonically a monad, is still an applicative functor.
19:36:32 <dibblego> > "ping?"
19:36:44 <Cale> (which is a trick you can pull with Conal's TypeCompose)
19:36:56 <Cale> Something wrong with lb?
19:37:01 <dibblego> seems so
19:37:02 <Cale> @bot
19:37:15 <Cale> huh...
19:37:31 <Cale> I'll speculatively restart it, even though it looks to still be running.
19:37:40 <elaforge> does this look familiar to anywone:
19:37:40 <elaforge>     unknown flags in  {-# OPTIONS #-} pragma: Foreign/C.lhser-} {-# LANGUAGE ForeignFunctionInterface
19:37:54 <elaforge> it's a confusing error ghci has started to give me when I load modules
19:37:56 <Cale> hmm
19:38:17 <elaforge> it apparently doesn't like my pragmas
19:38:55 <Cale> elaforge: That looks weird...
19:38:59 <elaforge> like it's getting garbage inside the pragma comment or something
19:39:09 <elaforge> the weirdest part is that it goes away if I try again
19:39:13 <elaforge> sometimes takes two tries
19:39:53 <elaforge> ghc also occaisionally refuses to compile saying it
19:39:55 <elaforge> couldn't parse the LANGUAGE in {-# LANGUAGE ForeignFunctionInterface #-}.
19:40:23 <elaforge> I "fixed" it by exchanging two pragmas
19:40:42 <Cale> That sounds like it warrants a trac ticket.
19:41:03 <elaforge> I'd like to be able to narrow it down more... I have no idea why this started happening
19:41:51 <elaforge> I'll try to get some more useful context and try filing a ticket
19:49:17 <geezusfreeek> @bot
19:49:17 <lambdabot> :)
19:51:02 <newsham> > ((+) `on` length) "foo" "barrr"
19:51:03 <lambdabot>  8
19:51:22 <geezusfreeek> :t on
19:51:23 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
19:51:34 <geezusfreeek> i always forget about on
19:54:36 <dancor> it seems like an on3 should be useful too
19:56:40 <ddarius> dancor: Why stop there?  What is on0, on1, on4?  How can you implement it inductively similar to the way ap allows going from liftM0 to liftMn
19:57:06 <geezusfreeek> it'd be nice if there was a nice mapM/foldM version: ((+) `on` length) ["foo", "bar", "wibble", "etc"]
19:57:53 <dancor> @pl \ f g -> f (g a) (g b) (g c)
19:57:53 <lambdabot> (`ap` ($ c)) . (`ap` ($ b)) . (. ($ a))
19:57:59 <geezusfreeek> then again just using composition wouldn't be too bad i guess
19:58:18 <geezusfreeek> … ew
19:58:29 <ddarius> That actually looks pretty nice.
19:58:52 <geezusfreeek> at least there is an obvious pattern
19:59:26 <newsham> geeze:  over :: ([b] -> c) -> (a -> b) -> [a] -> c ?
19:59:52 <newsham> ?djinn ([b] -> c) -> (a -> b) -> [a] -> c
19:59:52 <lambdabot> -- f cannot be realized.
20:00:03 <geezusfreeek> djinn hates lists :(
20:00:23 <geezusfreeek> is over built in?
20:00:24 <geezusfreeek> :t over
20:00:25 <lambdabot> Not in scope: `over'
20:00:37 <geezusfreeek> aw
20:01:04 <newsham> > let f `over` g = \xs -> f (map g xs) in (sum `over` length) ["foo", "bar", "baz"]
20:01:04 <lambdabot>  9
20:01:39 <newsham> like so?
20:01:45 <dancor> @pl f (map g xs)
20:01:45 <lambdabot> f (map g xs)
20:01:57 <newsham> ?pl \xs -> f (map g xs)
20:01:57 <lambdabot> f . map g
20:02:01 <newsham> thats what you meant, right?
20:02:07 <dancor> yes
20:02:53 <newsham> so whats the proper  (m b -> c) -> (a -> b) -> m a -> c ?  (or "m c"?)
20:03:08 <dejones> does anyone have a URL for examples of using @ for pattern matching parameters for a function?
20:03:38 <newsham> > let x@(y:ys) = "test" in (x,y,ys)
20:03:38 <lambdabot>  ("test",'t',"est")
20:04:24 <geezusfreeek> > let f `over` g = foldr1 f . map g in ((+) `over` length) ["foo", "bar", "baz"]
20:04:24 <lambdabot>  9
20:04:31 <geezusfreeek> ^ more like what i meant
20:04:56 <dejones> newsham: what if I have data Foo = Foo (String, String), or something like that...  can I do f@(Foo)?
20:05:03 <geezusfreeek> but relies on foldr1 so maybe isn't so useful
20:05:07 <dejones> or would it be f@(Foo f) ?
20:05:13 <dancor> f@(Foo (s1,s2))
20:05:15 <Cale> dejones: f@(Foo (x,y)) ?
20:05:33 <dejones> ty dancor, newsham, and Cale.
20:05:34 <dejones> :)
20:05:37 <dejones> how goes it Cale?
20:05:39 <ddarius> dejones: Read the Gentle introduction
20:05:41 <Cale> I'm well
20:05:47 <dejones> I haven't been here bothering you lately.  ;)
20:05:48 <dejones> hehe
20:05:51 <ddarius> :t foldr ap return
20:05:52 <lambdabot> forall a (m :: * -> *). (Monad m) => [a -> m a -> m a] -> a -> m a
20:05:56 <dejones> ddarius: thanks.
20:07:02 <geezusfreeek> huh that's a fun looking one
20:08:51 <dejones> would also f@((String s1, String s2)) match just like f@(Foo (x, y)) ?
20:09:54 <dancor> dejones: there is an easy way to find out..  (but no)
20:10:20 <dancor> well i mean it would match that type
20:10:28 <dancor> but they are different types
20:10:33 <dancor> so maybe yes..
20:10:39 <newsham> if you have the type    (String, String) then the match is gonna be something like p@(s1,s2)
20:11:21 <dejones> dancor: yea, I understand they are defined as different types...  I'm wanting to match a Pair of different types, such as (Int x, String s)
20:11:39 <newsham> thats just   f (x,s) = ....
20:12:14 <dejones> newsham: but the pattern match isn't stating the type...
20:12:20 <newsham> > let f (x,c) = replicate x c in f (3,'a')
20:12:21 <lambdabot>  "aaa"
20:12:26 <dancor> (String s)  would mean you've actually made a crazy data like  data MyInsanity = String Int
20:12:41 <newsham> the pattern match doesnt have to mention the type, but sometimes you want it ot mention the constructor.
20:12:45 <newsham> in this case the constructor is (,)
20:13:01 <newsham> > (,) 1 2
20:13:01 <lambdabot>  (1,2)
20:13:39 <newsham> so when you say   f (x,y) = ...     you're saying "match a constructor (,) and get its two halves as x and y"
20:13:47 <dejones> newsham: ahh..  yes, I want to mention the constructor in the Pair bc the types inside the Pair can be different... so I am trying to match on two different possible Pairs, such as f@(String s, Int x) and f@(String s, Double x)
20:13:50 <dejones> does that make sense?
20:14:15 <newsham> Double isnt a constructor and String isnt a constructor.
20:14:18 <dejones> newsham: Yah, I am wanting to pattern match on the constructors in the Pair  :)
20:14:31 <newsham> the String type is a synonym for [Char].  the constructor is (:)
20:14:44 <newsham> you dont necessarily have to match the constructor if you dont want to deconstruct the thing
20:14:48 <dejones> hmm
20:15:07 <newsham> > let (x:xs) = "test" in (x,xs)
20:15:08 <lambdabot>  ('t',"est")
20:15:18 <newsham> > let xs = "test" in xs
20:15:18 <lambdabot>  "test"
20:15:39 <newsham> I dont think there's any way to break a Double down into any constituent parts
20:15:56 <newsham> > let ((x:xs), y) = ("test", 123) in (x,xs,y)
20:15:57 <lambdabot>  ('t',"est",123)
20:16:02 <newsham> is that perhaps what you meant?
20:16:06 <dancor> @src Double
20:16:06 <lambdabot> data Double = D# Double#
20:16:25 <dancor> let f d@(D# dd) = 4 in f 4.2
20:16:26 <dejones> newsham: not exactly.. I'll explain more to clarify.
20:16:31 <dancor> # let f d@(D# dd) = 4 in f 4.2
20:16:34 <dancor> > let f d@(D# dd) = 4 in f 4.2
20:16:34 <lambdabot>  Parse error in pattern at "in" (column 21)
20:18:20 <dejones> I have two types, Attr and Content.  type Attr = String.  data Content = String | Data.Map Attr String.  so since Content can be two things, I want to be able to pattern match on the Pair (Attr, String) or (Attr, Map Attr String).  Does that make more sense?
20:19:14 <newsham> thats not a valid data definition is it?  you need a tag for the two types
20:19:43 <newsham> ie. data Content = AString String | AMap (Data.Map Attr String)
20:20:00 <newsham> so then you could define your function:   f (AString s) = ...;  f (AMap m) = ...
20:20:13 <dejones> type ElemContent = String
20:20:13 <dejones> data ElemMapValue = ElemContent
20:20:13 <dejones>                   | Map ElemAttr ElemContent
20:20:22 <dejones> that is exactly what I have and GHC doesn't complain...
20:20:38 <Cale> ElemContent and Map are now data constructors of ElemMapValue
20:20:43 <dejones> yea
20:20:48 <Cale> Which is wrong.
20:20:50 <dejones> lol
20:20:52 <dejones> Ok.
20:20:57 <newsham> you're defining ElemMapValue to have two constructors, one called "ElemContent" which has no data associated with it, and one called "Map" which has two data items, one is an ElemAttr, and one is an ElemContent
20:21:06 <newsham> which is not what you want it to be
20:21:52 <dejones> hmm
20:22:08 <newsham> you need to define two tags for the two alternate cases.
20:22:33 <newsham> data ElemMapValue = ElemContent ElemContent | Map (Data.Map ElemAttr ElemContent)
20:22:36 <newsham> for example
20:22:50 <Cale> uhh
20:22:50 <newsham> then:  f (ElemContent ec) = ...;   f(Map m) = ....
20:22:59 <Cale> Data.Map.Map ;)
20:23:18 <newsham> M.Map? :)
20:23:23 <Cale> yeah
20:23:36 <dejones> why ElemContent ElemContent... that saying ElemContent is the constructor for ElemContent in ElemMapValue?
20:23:52 <newsham> yah erhaps using the same name is not the best idea.
20:23:57 <newsham> but you need to define *some* tag
20:24:11 <dejones> I'm not sure what you mean when you say "tag" for that...
20:24:15 <dejones> I need to define some constructor?
20:24:16 <Cale> dejones: okay
20:24:22 <Cale> data Foo = A | B | C
20:24:32 <newsham> data EMVal = S String | M (M.Map ElemAttr ElemContent)
20:24:33 <Cale> This is a datatype with three defined values.
20:25:03 <Cale> We can even name one of the values "String" and one of them "Int", but it doesn't mean that the datatype will actually carry around a string or int
20:25:18 <Cale> data Foo = String | Int | Char
20:25:37 <Cale> is exactly the same thing as the above, with renamed values :)
20:25:44 <dejones> Ok
20:25:51 <Cale> That is, we literally have  String :: Foo
20:25:54 <Cale> and Int :: Foo
20:26:00 <Cale> (they're symbols)
20:26:06 <dejones> Ok, they're values... not types.
20:26:09 <dejones> rihgt?
20:26:11 <dejones> * Right
20:26:14 <Cale> right
20:26:25 <newsham> data Foo = A Int Int Int | B | C     is just like the earlier definition, except now the "A" alternative (using the "A" tag) caries around some int vaulues, too
20:26:46 <dejones> Oh
20:26:48 <newsham> (but still   data Foo = Int | B | C    does notcontain any Ints)
20:26:51 <Cale> The rhs of the = in a data declaration is a list of cases separated by |, where each case is the name of a data constructor, followed by zero or more fields
20:27:08 <Cale> Each field is given as its type
20:27:50 <dejones> does that mean, Foo = A Int Int Int | B | C.  To be a valid "A" it would have to contain 3 Ints?
20:28:00 <Cale> yeah
20:28:03 <dejones> Ok
20:28:09 <newsham> (A 3 3 3), (A 1 2 3), B and C   are all valid values for that Foo
20:28:17 <dejones> Gotcha
20:28:18 <dejones> :)
20:29:02 <newsham> now you could definie:  f (A x y z) = x + y + z;  f B = 1; f C = 2
20:29:19 <newsham> and f can handle any kind of Foo
20:29:31 <dejones> ah ha!
20:29:32 <dejones> :)
20:29:33 <newsham> f :: Foo -> Int
20:29:44 <dejones> there we go
20:29:45 <dejones> :)
20:29:54 <dejones> Thank you Cale and newsham
20:29:58 <Cale> :)
20:30:11 <dejones> @karma +1 Cale
20:30:11 <lambdabot> +1 has a karma of 0
20:30:16 <dejones> ha
20:30:17 <dejones> @karma
20:30:17 <lambdabot> You have a karma of 0
20:30:22 <dejones> @karma asdf
20:30:23 <lambdabot> asdf has a karma of 0
20:30:34 <dejones> @help karma
20:30:34 <lambdabot> karma <polynick>. Return a person's karma value
20:30:41 <dejones> lol
20:30:45 <Cale> @karma
20:30:45 <lambdabot> You have a karma of 71
20:30:48 <dejones> I can never remember how to give karma
20:30:52 <Cale> Cale++
20:31:02 <dejones> Cale++
20:31:05 <dejones> ?
20:31:07 <Cale> Or @karma+ Cale
20:31:09 <Cale> @karma
20:31:09 <lambdabot> You have a karma of 72
20:31:16 <dejones> @karma+ Cale
20:31:16 <newsham> "C++, even the name has destructive side effects." -overheard on #haskell-blah
20:31:16 <lambdabot> Cale's karma raised to 73.
20:31:18 <dejones> @karma+ newsham
20:31:18 <lambdabot> newsham's karma raised to 7.
20:31:22 <dejones> thank you both.
20:31:22 <dejones> :)
20:31:33 <Cale> @karma+ dejones
20:31:34 <lambdabot> dejones's karma raised to 1.
20:31:37 <dejones> lol
20:31:42 <dejones> for what...?
20:31:45 <dejones> ha
20:32:07 <ksandstr> tip of the hat over the internet, a pat on the back
20:32:17 <dejones> hehe, thanks
20:32:32 <dejones> I always greatly appreciate the wonderful help from all of you in #haskell
20:32:34 <ksandstr> or a pointless high-five, as it may be
20:32:36 <dejones> :)
20:32:49 <dejones> ksandstr: not pointless!  :)  encouraging high-five  ;)
20:33:15 <ksandstr> dejones: I had another expression instead of pointless, it starts with an "m" and is not family friendly
20:33:35 <gnut> hi all
20:33:38 <newsham> ?unpl high five
20:33:38 <lambdabot> high five
20:33:39 <Cale> hello
20:33:55 <gnut> is there any active development for a distributed haskell?
20:34:08 <gnut> i see lots of web pages, but all based on old ghc's and not much going on.
20:34:14 <dejones> ksandstr :)
20:34:26 <Cale> gnut: Most of the interesting stuff going on right now is directed at SMP
20:34:56 <gnut> Cale: do you have to explicitly call par and seq for that? or does ghc automatically parallelize the code for smp?
20:35:05 <dons> gnut: yeah, multicore hardware is way cheaper and more common :)
20:35:22 <dons> gnut: automatic parallelisation is only possible for some specific types
20:35:26 <gnut> dons: what if you have 2 multicore? since you can't afford a quad core...
20:35:26 <dons> such as arrays
20:35:29 <Cale> gnut: There's nothing *entirely* implicit.
20:35:43 <dons> its quite a complicated area
20:35:47 <gnut> yeah
20:36:00 <dons> good parallelisation requires careful balancing of algorithms and strategies
20:36:01 <dejones> oh, another question... data ElemMapValue = ElemMapValue ElemContent
20:36:01 <dejones>                   | ElemMapValue Map ElemAttr ElemContent
20:36:02 <gnut> i expect it to be given the lack of concurrent functional languages out there
20:36:16 <newsham> I imagine the fact that major software vendors are freaking about about the prospect of 16core desktops helps
20:36:17 <Cale> There's par, which is parallel Haskell. Then there's explicit concurrency (with things like transactions), and then there's a new system of data parallelism which should hopefully be usable in 6.10
20:36:18 <dejones> Cale, newsham: is it bad practice to use the "tag" as the same name as the data type you creatd?
20:36:22 <newsham> ps, isnt that more NUMA than SMP?
20:36:35 <Cale> dejones: Not particularly bad practice, if there's only one tag, that's pretty common.
20:36:37 <jeffz> gnut, quad core isn't much more expensive than dual core, $50 in some cases now
20:36:49 <gnut> Cale: new system? how does it look like?
20:37:04 <dejones> Cale: alright, so in my case, it seems to make sense?  :)
20:37:19 <Cale> gnut: You perform computations on a new datastructure, called the parallel array, and the workload is automatically split up across multiple processors.
20:37:21 <newsham> jeffz: bummer that my motherboard is socketted properly for a quad, the cpus are cheap, but the firmware on my mboard doesnt support it :(
20:37:37 <Cale> gnut: It's done fairly, and you can even nest the computations on these arrays.
20:37:37 <gnut> jeffz: hehe... well, i was thinking what if you have a bunch of quad cores then, and you wanted to put them to use as an eight-core...
20:38:08 <jeffz> newsham: shame, well, I have a quad but nothing interesting to run on it yet. working on that.
20:38:16 <gnut> Cale: sort of like a vector operation?
20:38:25 <newsham> "make -p" is interesting enough for me :)
20:38:36 <Cale> gnut: Kind of, but much fancier.
20:38:44 <gnut> ooooh
20:39:05 <Cale> There's a talk about it you could watch
20:39:11 <Cale> ...
20:39:21 <geezusfreeek> are we talking ndp here?
20:39:34 <Cale> yeah
20:39:40 <gnut> are there any good books out there on good parallel functional programming practices? on their data structures, styles, etc...?
20:39:51 <Cale> http://www.londonhug.net/2007/09/25/nested-data-parallelism-video-returns/
20:39:52 <lambdabot> Title: λondon HUG  Blog Archive  Nested Data Parallelism Video Returns!, http://tinyurl.com/2pw275
20:40:18 <dons> gnut: there's some great papers by Trinder and Hammond
20:40:33 <dons> and a book, i think
20:40:44 <dons> the erlang guys have written books about their specific model
20:40:51 <Cale> gnut: In fact, you can even have a parallel array of parallel arrays, and so on. :)
20:41:07 <gnut> dons: thanks
20:41:22 <dons> gnut: http://haskell.org/haskellwiki/Research_papers/Parallelism_and_concurrency#Parallel_Haskell
20:41:23 <lambdabot> http://tinyurl.com/t83sk
20:41:23 <gnut> dons: actually, are there even any erlang books besides the one joe armstrong wrote?
20:41:37 <dons> i recommend http://www.macs.hw.ac.uk/~dsg/gph/papers/abstracts/strategies.html
20:41:39 <lambdabot> Title: Algorithm + Strategy = Parallelism, http://tinyurl.com/22srxl
20:41:43 <dons> as a good paper on parallel haskell
20:41:58 <dons> well, there's joe's book.
20:42:27 <Cale> But yeah, I really recommend that video of SPJ on data parallelism :)
20:42:27 <geezusfreeek> yeah, strategies are a nice introduction to functional ways of approaching parallelism i think
20:42:40 <dejones> Cale: Thank you.. SPJ vids are excellent!
20:42:40 <dejones> :)
20:42:43 <dons> a nice high level view of what is going on
20:42:45 <geezusfreeek> the data parallelism stuff i good for hype though :)
20:42:54 <geezusfreeek> *si
20:42:58 <geezusfreeek> **is
20:43:14 <geezusfreeek> i need to slow down sometimes and reread what i type
20:43:44 <gnut> watching video
20:44:31 <geezusfreeek> and for concurrency i think nothing really beats getting enthused about STM
20:44:48 <dons> stm is nice
20:44:53 <geezusfreeek> i really take it for granted now
20:44:57 <dons> yeah
20:45:01 <Cale> STM is definitely the core of the right way to go for concurrency.
20:45:02 <dons> who thinks about locks anymore
20:45:07 <geezusfreeek> but i remember when i first learned about it i was amazed
20:45:17 <dons> concurrency seemed so hard in the 90s
20:45:19 <geezusfreeek> oh gosh yucky split!
20:45:30 <dons> back at school. all races and deadlocks and livelocks
20:45:36 * Cale shakes his fist at Freenode
20:45:46 <dons> you get what you paid for
20:45:48 <dejones> get'em Cale ;)
20:46:15 <dejones> I'd love to see a lock-less kernel... I wonder if STM will be able to accomplish that...
20:46:29 <newsham> so STM lets you perform limited transactions involving state updates.  how do people usually leverage that when you need to do some sort of effectual transaction?
20:46:32 <geezusfreeek> i was just about to say: i wish the linux kernel was so nice to fiddle with
20:46:34 <dejones> well, explicit locking that is.
20:47:02 <ksandstr> isn't rcu sort of close to that already
20:47:10 <dejones> geezusfreeek: yea, I took a linux kernel programming course... the many, many locking mechanisms were such a pain.
20:47:13 <geezusfreeek> i remember when i used to tinker with the linux kernel a bit i kept running into all kinds of confusing locking and concurrency problems
20:47:14 <Cale> newsham: Well, STM transactions have memory effects -- all other effects are just carried out in IO as usual.
20:47:20 <geezusfreeek> dejones: yes, me too
20:47:46 <geezusfreeek> my big project in that course was to try and encrypt the swap space
20:47:48 <newsham> cale: right, but lets say you have some IO that you want to perform in an atomic fashion.  whats the usual approach?
20:48:00 <newsham> implement some sort of lock type thing using STM?
20:48:07 <Cale> You might...
20:48:13 <adu> this is so weird
20:48:13 <geezusfreeek> i got close, but something kept unstaging pages queued for writing out to disk and i suspected it was some sort of locking issue
20:48:32 <geezusfreeek> so i had userspace programs trying to use encrypted memory directly :(
20:48:42 <dons> have a TVar on a resource token you need to run the action
20:48:51 <Cale> newsham: MVars (and their transactional equivalents) are still quite useful.
20:48:59 <dons> we often use MVars with () in them for this in classic concurrent haskell
20:49:03 <dejones> geezusfreeek: lol
20:49:25 <newsham> so current state of the art is to use STM mostly and still mix in MVars when necessary?
20:49:26 <dejones> geezusfreeek: that seems contradictory that user-space programs would encrypt the kernel swap space.  ;)
20:49:33 <adu> geezusfreeek, CryptoSwap?!?
20:49:39 <geezusfreeek> no, not like that
20:49:45 <dons> newsham: STM or MVars
20:49:48 <dons> all in the toolkit
20:50:03 <Cale> newsham: and if you need transactions which manipulate MVar like structures, use TMVars (which are easy to implement in terms of TVars)
20:50:10 <geezusfreeek> the kernel was encrypting it before writing it out to disk, but somehow some pages were being unstaged after being encrypted so that they were never written out
20:50:21 <dejones> heh
20:50:47 <geezusfreeek> and so the userspace programs owning the pages were able to see the encrypted data
20:51:00 <geezusfreeek> alright, going way off topic now
20:51:04 <dejones> :)
20:51:19 <dejones> interesting nonetheless!
20:51:20 <Cale> newsham: Another possibility is just keeping all interaction with a given resource confined to one thread.
20:51:40 <Cale> newsham: and then using channels (maybe transactional channels) to communicate with that thread
20:51:42 * dejones goes back to defining types in Haskell.  :)
20:52:10 <geezusfreeek> newsham: Real World Haskell will have a chapter on making a transactional database, IIRC
20:52:14 <geezusfreeek> is that right, dons?
20:52:30 <dons> yeah, STM definitely.
20:52:34 <geezusfreeek> sweet
20:53:10 <wagle> will it come with DWIM?
20:53:25 <adu> I'm so excited about Real World Haskell
20:54:20 <wagle> whats RW Haskell as opposed to Haskell'?
20:54:33 <newsham> a future OReilly book
20:54:37 <geezusfreeek> wagle: Real World Haskell is an upcoming book
20:54:49 <wagle> OOOOOooohh
20:55:17 <geezusfreeek> but how _soon_ i have no idea
20:55:30 <geezusfreeek> i would love to have a clue, if anybody knows? :)
20:56:21 <newsham> if only someone onthis channel knew such insider information
20:56:56 <geezusfreeek> someone, somewhere…
20:57:02 <jeffz> amazon says august 2008
20:57:14 <geezusfreeek> oh i looked on amazon and didn't see that
20:57:34 <dejones> you can pre-order RW Haskell on Amazon.  :)
20:57:49 <dejones> you get a discount to pre-order too.
20:59:11 <geezusfreeek> i plan to pre-order soon. i like to bulk up my amazon purchases so i'm building my queue back up first
21:00:56 <dejones> geezusfreeek: yea, get free shipping that way too
21:05:38 * ddarius thinks message passing is likely still the best way to go for coarse-grained concurrency.
21:11:09 <geezusfreeek> ddarius: i think message passing is great for distributed and/or untrusted environments, but in a local, trusted environment i have really grown fond of shared transactional memory
21:12:48 <geezusfreeek> i forecast that in the nearer future we have tons of cores build up, but after a while it will become more economical to decentralize the whole computer, and then message passing will take over for what "simple" parallelism and shared-memory concurrency will have served up to then
21:13:02 <geezusfreeek> but that may be a long way off
21:13:28 <Cale> Perhaps our programs just don't need to scale to the extent where it becomes an issue, but I get the sense that message passing concurrency ends up having many of the same problems as lock-based concurrency, but at a coarser scale.
21:14:03 <Cale> Processes become like generalised memory cells which are being updated concurrently by messages coming in from other processes.
21:14:27 <geezusfreeek> Cale: message passing is great when the system allows for things like futures, i think
21:14:48 <ddarius> Cale: Indeed.  But they tend to be controlled a lot better than memory cells, with more explicit and enforced protocols.
21:14:52 <mauke> > Just a `mplus` Just b
21:14:53 <lambdabot>  Just a
21:15:46 <geezusfreeek> E is a very interesting language due to its emphasis on futures (or maybe it calls them promises, i don't remember)
21:16:09 <newsham> futures sound too risky to me
21:16:21 <geezusfreeek> risky?
21:16:31 <newsham> should I call?  should I put?  what kind of margin?  what's my risk?
21:16:33 <ddarius> E is a very interesting language for reasons rather unrelated to futures.
21:16:35 <geezusfreeek> it's just the distributed version of lazy evaluation
21:17:02 <geezusfreeek> newsham: i think a decent type system would clear that stuff up for you :)
21:17:13 <redbeard0532> > lift (lift toUpper) "hello world"
21:17:14 <lambdabot>  Couldn't match kind `(* -> *) -> * -> *' against `?? -> ? -> *'
21:17:54 <redbeard0532> ﻿> liftM (liftM toUpper) "hello world"
21:19:04 <gnut> newsham: call? put? margin? risk? are you talking commodity futures?
21:19:26 <newsham> gnut: that was the pun.
21:20:12 <gnut> :)
21:20:27 <geezusfreeek> hmm… it occurs to me that promises are rather different from futures, and E has promises
21:24:14 <awesame> I take back my disparaging remarks made earlier today about Network.CGI.formEncode
21:25:05 <awesame> while the spec is unclear on whether semicolons need to be escaped, there is no interpretation under which they should be taken to delimit formencoded values
21:25:22 <awesame> it's python's parse_qs that is broken, not haskell's formEncode
21:26:50 <mauke> I think there is because perl's CGI.pm also treats ; as & in query strings
21:27:48 <awesame> ah, reading the source to parse_qs, it looks like it doesn't treat them like &
21:28:00 <awesame> it uses them to separate values in the list it returns
21:28:50 <awesame> so I think "foo=1;2;3" would do the same thing as "foo=1&foo=2&foo=3"
21:29:31 <awesame> no, I'm wrong
21:29:39 <awesame> it treats them as interchangeable
21:29:40 <gnut> so when is ghc 6.10 slated to come out? approximately?
21:30:08 <geezusfreeek> ; is often used to have special meaning, but i've never heard of any need to escape them
21:30:14 * jeffz offers gnut a crystal ball.
21:30:54 <ddarius> gnut: Do some simple linear extrapolation.
21:31:01 <gnut> okay.
21:31:07 <gnut> let me look fro the history of ghc releases
21:31:16 <geezusfreeek> gnut: and report back! ;)
21:31:29 * geezusfreeek is lazy
21:34:48 <gnut> sigh
21:34:52 <gnut> i'm going to guess dec 08
21:35:11 <gnut> 19 sep 05  6.4.1 released
21:35:20 <gnut> 11 oct 06 6.6.0 released
21:35:25 <gnut> 3 nov 07 6.8.1
21:35:50 <gnut> so i'm going to guess 6.10.0 is coming out on nov 25, 2008
21:36:18 <newsham> go linear prediction
21:36:25 <dolio> Actually, they've started releasing at x.y.1.
21:36:46 <redbeard0532> now guess what new features it will have
21:37:13 <dolio> A totally revamped type checker for one.
21:37:28 <dolio> That's still seems to be a work in progress, though.
21:37:58 <ddarius> I suspect GHC 6.10 will have something for everyone.  Fun for the whole family.
21:38:21 <mauke> "fun for the whole type family"
21:52:54 <halberd> quite frequently in math you write things like f / g instead of f(x) / g(x), where it is simply implicit that (f / g)(x) = f(x) / g(x)
21:53:46 <halberd> I wonder how nice it would be to be able to say things like (5+) / (3+)
21:54:02 <mauke> see http://mauke.ath.cx/stuff/haskell/fun.hs for an implementation
21:54:03 <Cale> You can do that with an appropriate instance of Num
21:54:21 <Cale> er, or Fractional, in that case
21:54:26 <mauke> *Main> (5+) / (3+) $ 2
21:54:27 <mauke> 1.4
21:54:49 <Cale> (though the Prelude definition of the Num is annoying, and so you end up having to write fake instances of Show and Eq for functions)
21:54:56 <Cale> the Num class*
21:55:57 <dolio> That won't get you f^n = f . f . ... . f, though, unfortunately.
21:56:28 <dolio> It'll be (f^n) x = (f * f * ... * f) x
21:56:45 <mauke> . needs Endo
21:56:59 <geezusfreeek> how far off is a spec for Haskell Prime? :) i'm finding myself dying for closure on some of these little nitpicky things
21:56:59 <dolio> Yeah.
21:57:30 <newsham> halberd: the funmath notation defines a hat modifier for that, it lifts the functions.  so like:   f +^ g = f x + g x
21:57:32 <dolio> Haskell' was supposed to be done in like -2 years.
21:57:39 <bd_> @hoogle a -> (a -> a) -> [a]
21:57:40 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
21:57:40 <lambdabot> Data.List.iterate :: (a -> a) -> a -> [a]
21:57:40 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
21:57:41 <newsham> wihch is liftM2 on ((->)r)
21:57:46 <geezusfreeek> hm
21:58:21 <newsham> there's also partial lifting for doing   f + 5 and 5 + f
21:59:16 <newsham> I've played with the notation a little in haskell: http://www.thenewsh.com/%7Enewsham/Hats.pdf
22:00:34 <dejones> is it possible to display the type of a function in a module I loaded with ghci?  I tried :t functionName, but I get "Not in scope"
22:00:49 <dejones> the module is my own code...
22:01:24 <mauke> is the module compiled?
22:01:37 <dejones> yea, I figured it out.. the function wasn't exported from the module.  :)
22:02:42 <dejones> thanks anyway mauke
22:07:23 <bogner> why doesn't runhaskell Setup.hs have an uninstall target?
22:13:50 <roconnor> 154836-153688
22:13:56 <roconnor> > 154836-153688
22:13:58 <lambdabot>  1148
22:31:42 <bogner> yi is too hard to compile, i've decided
22:54:32 <MarcWeber> @seen Igloo
22:54:32 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
22:54:45 <MarcWeber> wow :) lambdabot Are you ill?
22:55:14 <mauke> preflex: seen Igloo
22:55:14 -preflex(n=preflex@d90-128-46-80.cust.tele2.de)- Sorry, I haven't seen Igloo
22:55:31 <mauke> preflex: seen Igloo2
22:55:31 -preflex(n=preflex@d90-128-46-80.cust.tele2.de)- Igloo2 was last seen on #haskell 1 day, 5 hours, 33 minutes and 43 seconds ago, saying: dons: That's odd. -fglasgow-exts only turns on LANGUAGEs, but I didn't think there was one for rules
22:56:25 <bd_> hmm, should that be notice? I think mIRC directs NOTICEs to whatever channel happens to be on top at the time... not sure since I use irssi though
23:01:52 * wagle looks here for a polyglot that happens to know how a python program calls a method whose name it holds in a string
23:03:30 <pjd_> wagle: getattr
23:04:10 <cjb> wagle: yup, what he said
23:04:31 <wagle> well, thar she blows!  thanks
23:05:00 <cjb> method = getaddr(self, 'string'); method()
23:06:05 <lament> getattr
23:06:16 <ddarius> bd_: I believe the RFC says it should be that way, but it annoys some people and so lambdabot, and seemingly most bots, don't do it that way.
23:06:53 <bd_> the RFC says that, but the (unfortunately) most popular client interprets things a bit creatively I guess :/
23:14:00 <Cale> http://www.marriedtothesea.com/
23:14:01 <lambdabot> Title: Married To The Sea: "The Champagne of Comics"
23:18:33 <Japsu> @oeis 1 2 9
23:18:33 <lambdabot> Subfactorial or rencontres numbers, or derangements: number of permutations o...
23:18:33 <lambdabot> [1,0,1,2,9,44,265,1854,14833,133496,1334961,14684570,176214841,2290792932,320...
23:20:07 <Lycurgus> preflex: version
23:20:07 -preflex(n=preflex@d90-128-46-80.cust.tele2.de)- 7.809
23:20:22 <Cale> > let f 0 = 0; f 1 = 1; f n = n * (f (n-1) + f (n-2)) in map f [1..10]
23:20:25 <lambdabot>  [1,2,9,44,265,1854,14833,133496,1334961,14684570]
23:21:53 <Japsu> whee
23:23:19 <sjanssen> preflex: version
23:23:19 -preflex(n=preflex@d90-128-46-80.cust.tele2.de)- 7.954
23:23:21 <sjanssen> preflex: version
23:23:21 -preflex(n=preflex@d90-128-46-80.cust.tele2.de)- 4.741
23:23:22 <sjanssen> preflex: version
23:23:23 -preflex(n=preflex@d90-128-46-80.cust.tele2.de)- 6.331
23:23:23 <sjanssen> preflex: version
23:23:24 -preflex(n=preflex@d90-128-46-80.cust.tele2.de)- 4.811
23:23:35 <Cale> hm?
23:23:50 <Cale> What is preflex?
23:24:01 <sjanssen> preflex: seen Cale
23:24:01 -preflex(n=preflex@d90-128-46-80.cust.tele2.de)- Cale was last seen on #haskell 11 seconds ago, saying: What is preflex?
23:24:06 <MarcWeber> preflex: Who are you?
23:24:13 <sjanssen> Cale: I'm not sure, some log bot or the like
23:24:21 <Cale> @seen Cale
23:24:21 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
23:24:27 <sjanssen> huh
23:24:28 <Cale> huh, it died again?
23:24:32 <Cale> @seen Cale
23:24:32 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
23:24:35 <Cale> odd.
23:24:37 <sjanssen>  @seen has always been crappy
23:24:47 <lament> preflex: @yow
23:25:12 <Cale> The seen file is empty.
23:25:18 <Cale> @seen Cale
23:25:18 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
23:25:38 <Cale> @seen Cale
23:25:45 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
23:25:51 <Cale> d'oh
23:26:06 <Cale> @seen Cale
23:26:13 <lambdabot> You are in #ghc and #haskell. I last heard you speak just now.
23:26:16 <Tac-Tics> wagle: http://www.diveintopython.org/power_of_introspection/getattr.html
23:26:18 <Cale> mm
23:26:23 <lambdabot> Title: 4.4.&nbsp;Getting Object References With getattr
23:26:47 <Cale> Now the seen file doesn't even exist.
23:26:55 <Cale> @seen ddarius
23:27:01 <lambdabot> ddarius is in #haskell-soc, #haskell-overflow, #haskell-blah and #haskell. I don't know when ddarius last spoke.
23:27:58 <wagle> i was reading a python program (without knowing python), and it was mysteriously calling a method without naming anywhere but in tables of strings
23:28:43 <Tac-Tics> Python is pretty reflective, and that sort of behavior isn't uncommon
23:29:17 <wagle> i was looking at the getattr statement with no clue what it meant..  it was obvious what was going on once i knew what getattr did
23:32:48 <wagle> thanks for the url
23:33:41 <Tac-Tics> np
23:37:07 <uebayasi> Tim-Tams
23:53:13 * paolino sings a lullaby
