00:00:11 <EvilTerran> paczesiowa, no, because if thousands of lines end up explicitly in ReaderT, you are most definitely Doing It Wrong
00:00:25 <sclv> qapp = unsafePerformIO . newIORef =<< qApplication
00:00:47 <sclv> qApp = readIORef qapp
00:00:56 <paczesiowa> sclv: that binds qapp to main only
00:01:12 <paczesiowa> wait, you mean top-level?
00:01:20 <sclv> why not?
00:01:35 <sclv> and you don't unsafePerformIO qApp , because you'll be reading the IO ref in IO anyway.
00:02:07 * EvilTerran would definitely go for the wrapped transformer stack, er, "pattern"
00:02:16 <paczesiowa> but then how do I know that it gets assigned new qApplication before the first use?
00:02:37 <sclv> it gets assigned the first time its evaluated.
00:02:51 <sclv> which is necessarily before its used.
00:03:25 <paczesiowa> sclv: that 2nd unsafePerformIO is just for convenience, qApp is used directly in c++
00:04:10 <sclv> that's the danger -- the first unsafePerformIO is out of necessity, and after that its for convenience, and then just for kicks, and finally just to get right again. don't go down that road!
00:04:15 <paczesiowa> sclv: I'm not sure with all that laziness and stuff
00:04:42 <paczesiowa> sclv: how about if I prove that it is referentially transparent?
00:05:00 <paczesiowa> I'm certainly not going to prove anything later just "for kicks":>
00:06:13 <sclv> eh. either you're for purity or you're not. heathen :P
00:06:55 * Beelsebob_ considers appropriate use of unsafePerformIO to fit very well with purity actually
00:06:56 <dolio> Which part is supposed to be referrentially transparent?
00:07:08 <dolio> qapp isn't, I think.
00:07:10 <Beelsebob_> if you show that it's a pure function in the case you're using it in, you can drag it into the pure world
00:07:36 <paczesiowa> what purity matters when we call those "functions" (signals) by string-name?
00:07:38 <dolio> If you inline qapp you'll end up with different IORefs.
00:07:45 <sclv> I agree -- I use it for caching in hvac, as does spj in his paper on memoization. its just better to avoid when possible.
00:08:06 <sclv> I also use it for a random session ID generator, but that was a hack I can and should get rid of.
00:08:21 <Beelsebob_> in fact, I even use it in a couple of places where it isn't referentially transparent
00:08:46 * sclv plugs his ears and starts to recite the monad laws.
00:08:47 <paczesiowa> dolio: why? what does inlining matter?
00:08:48 <Beelsebob_> e.g. hat-delta computes the location of a bug, then uses unsafePerformIO to read a file to show you where the bug is
00:09:02 <Beelsebob_> which I'm fine with because I can guarentee it'll only run once
00:09:10 <dolio> Because executing newIORef twice is different than executing it once.
00:10:22 <paczesiowa> dolio: I guess you're right. breaking the law is hard:/
00:10:32 <dolio> For instance, if you inline qapp, you get 'qApp = unsafePerformIO $ readIORef (unsafePerformIO $ newIORef undefined)'
00:10:46 <dolio> Which looks like it's 'qApp = undefined'.
00:11:14 <dolio> qApp is probably safe to inline, though.
00:11:26 <paczesiowa> dolio: would noinline pragma made it safe again?
00:11:36 <dolio> As long as you're not changing the value throughout the program.
00:11:57 <paczesiowa> I'm not
00:12:18 <lament> @pl \x -> (a x) + (b x)
00:12:18 <lambdabot> liftM2 (+) a b
00:12:23 <dolio> Yeah, it's safe as long as you don't inline, I think.
00:12:29 <lament> ahh
00:12:43 <EvilTerran> lament, reader monad! :D
00:13:05 <EvilTerran> ... hence, you can also use liftA2 or <$> and <*>
00:13:22 <paczesiowa> dolio: thanks
00:13:30 <lament> where are those from?
00:13:39 <sclv> ?hoogle Applicative
00:13:39 <lambdabot> Control.Applicative :: module
00:13:39 <lambdabot> Control.Applicative.Applicative :: class Functor f => Applicative f
00:13:40 <EvilTerran> Control.Applicative
00:13:40 <paczesiowa> Control.Applicative?
00:13:48 <geezusfreeek> holy crap
00:14:03 <sclv> ?quote fuge
00:14:03 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
00:14:07 <sclv> ?quote fugue
00:14:07 <lambdabot> No quotes match. You untyped fool!
00:14:11 <EvilTerran> Applicative's a spiritual superclass of Monad
00:14:14 <geezusfreeek> okay i get it Control.Applicative okay okay
00:15:02 <sclv> @remember monochron Welcome to #haskell, where your questions are answered in contrapuntal fugues.
00:15:02 <lambdabot> Nice!
00:15:30 <geezusfreeek> nice indeed
00:15:33 <quicksilver> spiritual superclass sounds like the terminology from some wacko cult
00:15:53 <quicksilver> EvilTerran needs three more absolution experiences to join the spiritual superclass! Rejoice!
00:16:24 <blarz> hey, I'm compiling xmonad on OpenBSD, but I always get the following message when I try to do 'runhaskell Setup.lhs': "Could not find module `Distribution.Simple'" - where can I find this Distribution.Simple?
00:16:49 <scook0> blarz: it's part of cabal
00:17:22 <scook0> so you probably need to install the relevant distro package
00:17:42 <scook0> or wherever you got your GHC from
00:18:06 <blarz> hm, I i installed it from ports. But perhaps I should try reinstalling it.
00:18:47 <scook0> I know some packaging systems split GHC from most of its libraries
00:19:07 <quicksilver> I thought cabal was in the core libs, even then
00:20:35 <scook0> on my ubuntu box I had to install a separate cabal package
00:20:55 <ziman> @pl \x -> (f x) + (f x)
00:20:55 <lambdabot> liftM2 (+) f f
00:21:19 <lament> ouch
00:25:14 <dolio> @type join (+) . f
00:25:17 <lambdabot> forall a (f :: * -> *). (Functor f, SimpleReflect.FromExpr (f a), Num a) => f a
00:25:20 <dolio> @type join (+) . ?f
00:25:21 <lambdabot> forall a (f :: * -> *). (Functor f, ?f::f a, Num a) => f a
00:29:26 <lament> can i import a module hiding an instance?
00:29:51 <scook0> nope
00:29:59 <lament> :(
00:30:43 <paczesiowa> you can create new module, import old one and reexport everything but instances
00:31:31 <lament> ugh
00:32:06 <paczesiowa> I agree
00:33:17 <blarz> ah, now I see why it doesn't find Distribution.Simple, ghc is searching for it in my /home, as I installed xmonad in my home in the past. But how do I tell ghc that it should look in /usr/local/lib/ now and not /home/simon/lib?
00:34:18 <blarz> rm -rf ~/.ghc
00:35:40 <lament> ?instances Monoid
00:35:40 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
00:37:31 <solrize> @hoogle xor
00:37:31 <lambdabot> Data.Bits.xor :: Bits a => a -> a -> a
00:37:55 <Baughn> @instances Bits
00:37:55 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
00:38:02 <Baughn> @instances-importing Data.Bits Bits
00:38:02 <lambdabot> Int, Integer
00:38:50 <hpaste>  solrize pasted "is there a better way to do this?" at http://hpaste.org/7003
00:39:19 <solrize> basically i have a file full of json records each of which ends with a line containing just a right brace
00:39:25 <solrize> so i want to chop it into individual records that i can parse
00:40:02 <Baughn> Well.. parsec?
00:40:13 <solrize> uggh, overkill and probably awful slow
00:40:51 <quicksilver> !
00:40:59 <quicksilver> parsec is not awful slow
00:41:09 <quicksilver> parsec is rather fast.
00:41:22 <solrize> well i'm looking for "fast" as opposed to "rather fast" :)
00:42:04 <quicksilver> I would do map (drop 1) . filter ((=="}") . head) . tails $ file_lines
00:42:29 <solrize> i saw something in the parsec docs saying it could parse 1000's of lines a second, which is about the speed of turbo c++ actually compiling code on my 8 mhz pc/xt back in the day...
00:42:52 <solrize> quicksilver thanks
00:43:14 <quicksilver> but you rather quickly get to the point when it would be easier to have a real parser
00:43:32 <solrize> well i wanted to just chop this thing up into records that i could give to the json.hs parser
00:44:23 <paczesiowa> > [(0,0)..(2,2)]
00:44:24 <lambdabot>   add an instance declaration for (Enum (t, t1))
00:44:54 <solrize> maybe i should hack json.hs itself to parse a list of records.  i'm still awkward enough with haskell that i'm timid about attempting things like that, it just takes me forever to get anything to work
00:47:19 <paczesiowa> how do you guys usually translate two nested for statements?
00:48:38 <paczesiowa> @src enum
00:48:38 <lambdabot> Source not found. Just what do you think you're doing Dave?
00:48:43 <Mr_Awesome> paczesiowa: that depends entirely upon what youre trying to do
00:48:51 <solrize> hmm that function drops the first record and crashes with head [] at the end, but i can probably fix it
00:51:47 <paczesiowa> Mr_Awesome: usually single for statement (for (i=1; i<n;i++) f(i)) is translated to forM_ [1..n] f, how about for (i=1; i<n;i++) for (j=1; j<m;j++) f(i,j)
00:52:11 <paczesiowa> nested forMs seem ugly
00:52:26 <solrize> that's for monad action, but what's wrong with nesting?
00:53:01 <ziman> > [(1, 1)..(2, 3)]
00:53:01 <lambdabot>   add an instance declaration for (Enum (t, t1))
00:53:08 <paczesiowa> I'd rather have forM_ [(1,1)..(n,m)] f
00:53:11 <ziman> > [(1, 1)..(2, 3)] :: [(Int, Int)]
00:53:11 <lambdabot>   add an instance declaration for (Enum (Int, Int))
00:53:11 <lambdabot>     In the expression: [(...
00:53:42 <ziman> i thought (,) was Enum
00:53:51 <paczesiowa> me too
00:54:09 <solrize> anyway do you really want [f i j | i <- [1..n], j <- [1..m]]    ?
00:54:10 <ziman> however, you can still instantiate it yourself :)
00:54:58 <paczesiowa> ziman: that defeats ultimate goal to do everything in 1 line:>
00:55:01 <sjanssen> I'd probably do: sequence_ [f i j | i <- [1..n], j <- [1..m]]
00:55:03 <EvilTerran> solrize, that looks suspiciously like an opportunity to use liftM2
00:55:03 <Mr_Awesome> solrize: then applied to sequence_ ?
00:55:37 <solrize> i don't see where liftM2 fits in
00:55:48 <paczesiowa> @src Enum
00:55:48 <lambdabot> class  Enum a   where
00:55:48 <lambdabot>     succ                     :: a -> a
00:55:48 <lambdabot>     pred                     :: a -> a
00:55:48 <lambdabot>     toEnum                   :: Int -> a
00:55:48 <lambdabot>     fromEnum                 :: a -> Int
00:55:50 <lambdabot> [3 @more lines]
00:55:56 <sjanssen> sequence $ liftM2 f [1..n] [1..m]
00:56:21 <cjs> So is the Monad module some sort of historical name for Control.Monad?
00:56:46 <paczesiowa> > let f x y = print x >> print y in let (n,m) = (5,6) in sequence_ $ liftM2 f [1..n] [1..m]
00:56:47 <sjanssen> cjs: Monad is the module defined in the Haskell '98 spec
00:56:48 <lambdabot>  <IO ()>
00:57:14 <dolio> Haskell98 was pre-hierarchical libraries.
00:57:48 <cjs> Ah. But I usually see Control.Monad used instead; what standard is this part of? The informal "GHC and Hugs" standard?
00:58:24 <sjanssen> cjs: Control.Monad is more of a community/de facto standard
00:58:33 <paczesiowa> > succ LT
00:58:34 <lambdabot>  EQ
00:58:37 <paczesiowa> > succ EQ
00:58:37 <lambdabot>  GT
00:58:38 <solrize> sjanssen, oh cool (the liftM2 example), i would not have figured that out
00:58:41 <paczesiowa> > succ GT
00:58:41 <lambdabot> Terminated
00:58:55 <sjanssen> basically it contains whatever those with commit capability to the base repo want in it :)
00:59:22 <paczesiowa> > succ True
00:59:23 <lambdabot>  Exception: Prelude.Enum.Bool.succ: bad argument
00:59:28 <sjanssen> (though there is a process that proposals are supposed to go through)
00:59:29 <paczesiowa> > succ GT
00:59:30 <lambdabot> Terminated
00:59:37 <paczesiowa> weird
01:00:04 <paczesiowa> @pl \x y -> [x..y]
01:00:04 <solrize> > toEnum GT
01:00:04 <lambdabot> enumFromTo
01:00:05 <lambdabot> Terminated
01:00:11 <solrize> > toEnum EQ
01:00:11 <lambdabot>  Couldn't match expected type `Int' against inferred type `Ordering'
01:00:21 <solrize> :t GT
01:00:21 <paczesiowa> :t \x y -> [x..y]
01:00:23 <lambdabot>     Ambiguous occurrence `GT'
01:00:23 <lambdabot>     It could refer to either `Data.Ord.GT', imported from Data.Ord
01:00:23 <lambdabot>                           or `Data.Generics.GT', imported from Data.Generics
01:00:23 <lambdabot> forall t. (Enum t) => t -> t -> [t]
01:00:38 <solrize> :g Data.Ord.GT
01:00:42 <solrize> :t Data.Ord.GT
01:00:43 <lambdabot> Ordering
01:00:50 <solrize> > succ Data.Ord.GT
01:00:50 <lambdabot>  Exception: Prelude.Enum.Ordering.succ: bad argument
01:00:56 <solrize> heh
01:01:01 <solrize> :t Data.Generics.GT
01:01:02 <lambdabot> (forall a. (Data a) => a -> a) -> GenericT'
01:01:09 <paczesiowa> mystery solved
01:01:11 <solrize> > succ Data.Generics.GT
01:01:12 <lambdabot>        add an instance declaration for
01:01:12 <lambdabot>       (Typeable GenericT', Typeable (f...
01:01:20 <paczesiowa> ...or not
01:01:25 <solrize> hmm
01:02:30 <cjs> sjanssen: I see. Makes sense.
01:03:08 <solrize> Data.ByteString always means strict bytestrings ?
01:04:07 <quicksilver> yes, the lazy one has the word 'Lazy' in the name
01:04:41 <solrize> is there a strategy for turning lazy ones into strict ones?
01:04:54 <quicksilver> fromChunks and toChunks
01:04:58 <quicksilver> @hoggle Chunks
01:04:59 <lambdabot> Data.ByteString.Lazy.fromChunks :: [ByteString] -> ByteString
01:04:59 <lambdabot> Data.ByteString.Lazy.toChunks :: ByteString -> [ByteString]
01:04:59 <lambdabot> Data.ByteString.Lazy.Internal.foldrChunks :: (ByteString -> a -> a) -> a -> ByteString -> a
01:05:11 <solrize> that turns a lazy into a lazy
01:05:28 <solrize> no wait
01:05:32 <solrize> :t toChunks
01:05:33 <lambdabot> Not in scope: `toChunks'
01:05:43 <solrize> toChunks :: ByteString -> [ByteString]	Source
01:05:43 <solrize> O(n) Convert a lazy ByteString into a list of strict ByteString
01:06:05 <solrize> something is wrong there, lazy and strict bytestrings are the same type???
01:06:11 <sjanssen> no
01:06:11 <quicksilver> yes, the haddock habit of shortening identifiers leads to confusing documentation
01:06:19 <quicksilver> they are not really the same ByteString :)
01:06:25 <solrize> ohhhhhhh
01:07:02 <cjs> And don't forget the Char8 versions of each, too!
01:07:39 <solrize> so the json module has a function to parse a strict bytestring containing a json representation.  and i have a file with a zillion json records in it.  so i shoudl read the file as a lazy bytestring, using toChunks to peel off strict bytestrings with individual records and parse them?
01:07:40 <cjs> All of that was what I found somewhat confusing about ByteStrings. Especially when the typechecker let something pass but I didn't realize I was using lazy instead of strict, or vice versa, when I really wanted the other.
01:07:43 <solrize> yes it does use char8
01:08:00 <cjs> There are both Word8 and Char8 versions of ByteStrings.
01:08:31 <solrize> how are they different?
01:08:48 <quicksilver> Char8s are chars, really.
01:08:55 <quicksilver> it's just only the low 8 bits matter.
01:09:03 <quicksilver> Word8s are straight bytes.
01:09:22 <solrize> hmm
01:09:28 <cjs> I think the idea is that if you're going to be doing string processing on the data, conversions are easier if you use the Char8 version of ByteString.
01:09:33 <solrize> ic
01:09:47 <Baughn> Of course, if you /use/ the Char8 version, I'll have to kill you
01:09:55 * Baughn grumbles about unicode
01:10:09 <mauke> I use Char8!
01:10:19 <solrize> this data is full of hex encoded unicode
01:10:37 <Baughn> mauke: Then I'm sorry, but you must be destroyed.
01:10:48 <mauke> whyâ€½
01:10:52 <cjs> E.g., pack :: [Word8] -> ByteString versus pack :: String -> ByteString
01:11:12 <quicksilver> sometimes we work with 8-bit text files
01:11:13 <Baughn> For the crime of dropping perfectly good chars on the floor
01:11:15 <quicksilver> I do all the time.
01:11:22 <mauke> I don't drop chars on the floor
01:11:25 <quicksilver> in those cases, Char8 is just the ticket
01:11:29 <Baughn> How does pack :: String -> ByteString deal with chars > 255?
01:11:32 <cjs> Though that sounds dangerous to me; what does the String version do if it includes a Char > 255?
01:11:41 <quicksilver> exactly the same wauy putStrLn does :P
01:11:45 <mauke> mod 256, I hope
01:12:03 <mauke> but I don't use chars > 255 in my string literals
01:12:08 <cjs> Hm? Ought putStrLn not spit out UTF8 or whatever? How do you set what putStrLn prints?
01:12:20 <Baughn> cjs: You don't. And it doesn't.
01:12:27 <sjanssen> cjs: you can't, the standard IO library is broken (IMO)
01:12:27 <cjs> mod 256 sounds bad to me. That quietly destroys data.
01:12:35 <Baughn> cjs: It's a bug that's become a feature
01:12:47 <paczesiowa> cjs: use encoding package, it has reads and prints parametrized over encodings
01:13:00 <solrize> :t (++)
01:13:01 <lambdabot> forall m. (Monoid m) => m -> m -> m
01:13:03 * Baughn thinks pack/putStr should call error if they hit chars > 127
01:13:10 <solrize> (>>+) :: Monad m => m [a] -> m [a] -> m [a]
01:13:10 <solrize> ma >>+ mb = ma >>= \a -> mb >>= \b -> return (a++b)
01:13:28 <mauke> :t liftM2 (++)
01:13:28 <solrize> is that bogus?  it is written as if for general monads but really seems intended for lists
01:13:29 <lambdabot> forall a1 (m :: * -> *). (Monad m, Monoid a1) => m a1 -> m a1 -> m a1
01:13:55 <solrize> it's equivalent to do {a<-ma; b<-mb; return (a++b) }, i think
01:14:04 <quicksilver> yes, it's just liftM2 (++)
01:14:05 <cjs> Well, I'll look at the encoding issues later. It's not a particular concern for me with what I'm doing just at this moment, but being in Japan, in the general case dealing properly with characters outside ASCII/ISO-8859-1 is a great concern to me.
01:14:11 <solrize> oh
01:14:24 <solrize> hmm, does that suggest that whoever wrote this didn't grok monads?
01:14:27 <cjs> Baughn: I agree, to a great extent.
01:14:29 <quicksilver> not at all.
01:14:40 <cjs> Or they should take a type that is not Unicode, or whatever.
01:15:00 <Baughn> cjs: Living in Norway, I have the "advantage" that my chars are all <256.. which means they come out corrupted half the time instead of just going missing
01:15:15 <cjs> Actually, dealing with this in the type system would be pretty nice. It would save a lot of pain.
01:15:27 <cjs> Who knows, maybe I'll write that one day.
01:18:44 <solrize> someone is doing a SoC to have more thorough unicode treatment in ByteString, i think
01:19:38 <mauke> the existing ByteString is fine for simple IRC bots :-)
01:19:45 <MarcWeber> >where darcs
01:20:20 <cjs> ?quote simple
01:20:20 <lambdabot> No quotes match. Just try something else.
01:21:23 <hpaste>  lament pasted "Stupidly Functional Mancala Board" at http://hpaste.org/7004
01:21:48 <lament> mwahahaha
01:24:57 <lament> @pl \(x, y) -> x + y
01:24:57 <lambdabot> uncurry (+)
01:25:16 <solrize> @src foldrChunks
01:25:16 <lambdabot> Source not found. Just what do you think you're doing Dave?
01:28:33 * RayNbow blinks
01:28:44 <RayNbow> the Real World Haskell book has a release date according to Amazon? :P
01:31:34 <EvilTerran> hehe... "pure^H^H^H^Hstupidly functional programming"
01:31:58 <EvilTerran> "buzzword-reactive programming"?
01:32:44 <EvilTerran> "obfuscation-oriented programming"!
01:32:49 * EvilTerran wanders off, muttering to himself
01:33:45 <lament> @pl \x y -> f (zip x y)
01:33:45 <lambdabot> (f .) . zip
01:34:32 <mahogny> wonderful thought. at some point all the bad coders will go out of business because everything is written in haskell and they don't have what it takes to understand the code :)
01:35:38 <Stinger_> you have no idea about the sw industry do you? :)
01:35:43 <jeffz> yeah, if only.
01:36:23 <hpaste>  lament annotated "Stupidly Functional Mancala Board" with "A far saner version with lists" at http://hpaste.org/7004#a1
01:37:52 <EvilTerran> encore, this time with church encoding! :D
01:39:13 * lament corrects that horrible mappend definition
01:39:23 <lament> mappend = zipWith (+)
01:39:34 <EvilTerran> heh
01:40:01 <lament> it's reasonably pretty now
01:40:26 <EvilTerran> shouldn't mempty/mappend/mconcat be in a Monoid instance?
01:40:38 <lament> it should
01:40:41 <cjs> No, they'll just end up hiring programmers who don't understand the code very well, but can change it and degrade it, which will allow progressively worse programmers to be hired to change and degrade, until it gets down to the level of bad Java.
01:40:50 <lament> it's meant to be a monoid instance
01:40:59 <lament> unfortunately, i don't know how to make it a monoid instance without overlapping instances
01:41:25 <EvilTerran> ah... yes, because it's a type not a newtype.
01:41:26 <EvilTerran> doh.
01:41:49 <sclv> aaaand.... full circle.
01:43:25 * EvilTerran proposes a newtype with agressive use of NewtypeDeriving
01:43:51 <cjs> Ok, Haskell user locations updated. I'm now nukable from orbit.
01:44:09 <lament> so i just fake it, because really the only useful point of it being a monoid is being able to use mconcat (of course, not even that is really needed in this case, you could just do play turns = map sum (transpose turns))
01:47:41 * EvilTerran activates the re-entry thrusters on one of his orbital crowbars
01:58:36 <cjs> Itekimasu.
02:00:39 <uebayasi> i'm looking for NetBSD programmers :)
02:01:00 * mux_ is a FreeBSD programmer, sorry :p
02:01:00 <cjs> To write stuff in Haskell?
02:01:09 <cjs> Sign me up!
02:01:15 <uebayasi> heh, no :)
02:01:34 <Corun_> How can you be a "NetBSD" programmer...
02:02:01 <uebayasi> it's easier than Haskell ;)
02:02:18 <Corun_> That's like being a "deep water swimmer". For some reason, you can't swim in shallow water.
02:02:35 <mux_> I interpreted that as "NetBSD committer"
02:02:40 <mux_> anything else wouldn't make much sense
02:03:11 <EvilTerran> uebayasi, have you tried in #netbsd ?
02:03:21 <Corun_> Heh, cunnin'
02:03:34 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/7005#a1
02:03:36 <uebayasi> how do you interpret if i say "i'm looking for Haskell programmer"?
02:04:44 <uebayasi> EvilTerran, that line was just Re: against "hiring (Haskell) programmers" lines i saw :)
02:04:45 <Vq^> uebayasi: that you wish to observe one with your eyes
02:11:18 <solrize> toMaybe :: Bool -> a -> Maybe a
02:11:19 <solrize> toMaybe b x = if b then (Just x) else Nothing
02:11:22 <solrize> is that a code smell ?
02:12:56 <sjanssen> huh?
02:12:58 <EvilTerran> looka ok to me
02:13:12 <sjanssen> "is that a code smell"
02:13:13 <solrize> i just figured, if that's so useful it would be in Data.Maybe already
02:13:21 <EvilTerran> ?type \b x -> guard b >> return x -- generalising
02:13:21 <sjanssen> you pasted code, not a scent :)
02:13:23 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => Bool -> b -> m b
02:13:24 <solrize> i.e. if i'm using a function like that i'm doing something wrong
02:13:42 <EvilTerran> sjanssen, it's a jargon file ism
02:13:45 <solrize> evilterran is there a name for that?
02:14:14 <mux_> I think I'd call that one ifMaybe or maybeIf
02:14:19 <sjanssen> EvilTerran: oh?  I thought the term was newer than the jargon file
02:14:39 <Vq^> solrize: i've felt the use for something similar when doing unfolds
02:14:40 <EvilTerran> sjanssen, ah, you're right, it's not in the jargon file. c2 wiki.
02:14:50 <sjanssen> I think it is overused
02:15:15 <EvilTerran> http://c2.com/cgi/wiki?CodeSmell
02:15:16 <lambdabot> Title: Code Smell
02:19:49 <quicksilver> there are quite a few missing combinators aroud Bool/Maybe
02:20:16 <quicksilver> the one I find myself writing most often is whenJust :: Maybe a -> (a -> m ()) -> m ()
02:20:36 <mux_> oh yeah, whenJust is definitely very very useful
02:20:43 <mux_> I have needed it several times myself already
02:21:13 <ToRA> isn't that just a specialised (>>=) ?
02:21:18 <quicksilver> no
02:21:22 <quicksilver> it's a generalised >>=
02:21:28 <quicksilver> like a 'cross-monad' >>=
02:21:33 <ToRA> oh
02:21:34 <ToRA> yeah
02:21:39 <ToRA> sorry, being blind
02:22:01 <quicksilver> or, if you feel like being really clever, it's something to do with lifting the maybe into a MaybeT over the monad you first thought of and then runMaybeT'ing it
02:22:06 <solrize> whenJust = mapM_ . maybeToList               ?
02:22:28 <HunterXHunter> @seen Vagabond
02:22:29 <lambdabot> I haven't seen Vagabond.
02:25:04 <mux_> hey, do you guys know what is the expected release date of "real world haskell"?
02:25:30 <dolio> Amazon says August.
02:26:02 <mux_> heh, I must be dumb: I _am_ on amazon and couldn't see any release date
02:26:06 <mux_> I was considering pre-ordering it
02:26:59 <mux_> ah, found :)
02:27:09 <dolio> In the "Publisher" line.
02:30:34 <sioraiocht> does the OS X build of ghc 6.8 still require gnureadline.framework?
02:39:23 <mux_> hah, this lambda potato made me burst in laughs
02:40:18 <sioraiocht> hrm, anyone else had problems with libreadline and ghc 6.8 on leopard?
02:40:24 <sioraiocht> dyld: Library not loaded: /opt/local/lib/libreadline.5.2.dylib
02:40:24 <sioraiocht>   Referenced from: /usr/local/lib/ghc-6.8.2/ghc-6.8.2
02:40:24 <sioraiocht>   Reason: image not found
02:40:24 <sioraiocht> Trace/BPT trap
02:40:51 <Baughn> sioraiocht: Yes, you need to actually install readline.
02:40:52 <sioraiocht> i have gnureadline.framework installed, but i can't get gnureadline's dylib to build for me, i never have been
02:41:20 <sioraiocht> i have the static version installed
02:41:30 <Baughn> That won't be enoug
02:41:33 <sioraiocht> well
02:41:42 <sioraiocht> 686-apple-darwin9-gcc-4.0.1: -compatibility_version only allowed with -dynamiclib
02:41:42 <sioraiocht> make[1]: *** [libreadline.5.2.dylib] Error 1
02:41:46 <Baughn> Do you have fink or ports installed?
02:41:48 <sioraiocht> no
02:41:51 <sioraiocht> i hate both of them
02:41:57 * Baughn shrugs
02:41:58 <sioraiocht> i guess i could read their port files, though
02:43:16 <sioraiocht> but it also references the file is /opt/local
02:43:29 <sioraiocht> which is a non standard place to pub lib files, imo
02:43:47 <Baughn> That's true. A symlink works.
02:43:50 <quicksilver> it's a standard place for macports to put files :P
03:05:52 <sioraiocht> hrm
03:05:53 <sioraiocht> finally
03:06:00 * sioraiocht got it to work.
03:06:42 <sioraiocht> without effing macports =p[
03:21:22 <ski> quicksilver : Data.Foldable.forM_
03:23:53 <dolio> Ah yes.
03:24:09 <dolio> I should have noticed that from 'mapM_ . maybeToList'.
03:24:26 <dolio> (Which should be forM_ I suppose.)
03:35:45 <fons> hi all,
03:36:33 <fons> I have a container structure, member of Functor, Foldable and Traversable
03:37:33 <fons> I can easily obtain its values in a list with toList (which internally uses Data.Foldable.foldr)
03:39:25 <fons> but, How can I go the other way around? (i.e fill my container data structure with a list)
03:40:06 <fons> I have a solution based on STRefs which works but is quite ugly
03:41:55 <dolio> Well, if you have a container of the shape you want, you could probably use mapM in a state monad (which might be what you're doing).
03:42:56 <dolio> There's no Unfoldable, though.
03:48:24 <dolio> I'm not sure you could come up with a good signature for a general unfoldr, either, aside from looking at your data type as the fixed point of a functor (if it is one) and typing the anamorphism that way.
03:48:34 <dolio> Which is done in Control.Recursion in category-extras.
03:50:08 <fons> dolio: I'm going to upload my solution, it works, but it s a bit ugly I think
03:50:17 <dolio> Where you'd get a type like: Fixpoint f t => (b -> Maybe (f b)) -> b -> t
03:50:24 <fons> just one sec
03:53:07 <dolio> Foldable has a similar problem, as with 'foldr :: Foldable f => (a -> b -> b) -> b -> t a -> b' you can't take into account any structure your foldable has beyond a list.
03:53:53 <dolio> But it's more pronounced in Unfoldable, because instead of just forgetting structure that's already there, it'd have to make up structure out of nowhere.
03:54:52 <quicksilver> well normally that's traversable
03:54:52 <quicksilver> IMO.
03:54:56 <quicksilver> or Monoid.
03:55:00 <quicksilver> depending what you mean.
03:55:13 <quicksilver> Traversable lets you 'mirror' an existing shape
03:55:16 <quicksilver> with new values
03:55:26 <quicksilver> Monoid lets you build new ones
03:55:33 <quicksilver> (but without much control over the details of the shape)
03:56:59 <quicksilver> ski: good point about forM_ :)
03:57:45 <quicksilver> dolio: well Foldable is dual to monoid: since monoids are associative, there is no structure beyond the list. IYSWIM.
03:59:32 <dolio> Yeah, I see.
04:00:51 <quicksilver> traversable is enough to define zipWith
04:00:59 <quicksilver> which is a bit like what fons wants
04:01:09 <quicksilver> fons: did you see my 'zipWithTF' ?
04:01:29 <fons> quicksilver: no
04:01:41 <quicksilver> that seems close to what you're describing
04:01:42 <fons> quicksilver: but from what I'm reading I'm probably coding something really similar
04:01:47 <quicksilver> lets you zip any traversable with any foldable
04:01:52 <fons> quicksilver: can you give me a pointer?
04:01:55 <quicksilver> structure coming form the traversable 'on the left'
04:02:01 <quicksilver> @go FoldableAndTraversable
04:02:02 <lambdabot> No Result Found.
04:02:05 <quicksilver> bah!
04:02:13 <quicksilver> @wiki FoldableAndTraversable
04:02:13 <lambdabot> http://www.haskell.org/haskellwiki/FoldableAndTraversable
04:02:24 <quicksilver> down at the bottom.
04:02:59 <romildo> Hi.
04:03:34 <fons> quicksilver: import Data.Sequence?
04:03:49 <quicksilver> left over from an earlier draft
04:03:50 <quicksilver> I suspect :)
04:03:52 <romildo> it seems that Haskell does not accept accented latin1 characters in strings. Is it really the case?
04:03:56 <quicksilver> or, rather, some test code.
04:04:04 <quicksilver> which uses sequence to prove it works
04:04:13 <quicksilver> romildo: no.
04:04:24 <quicksilver> romildo: but, what you said didn't explain the problem in detail.
04:04:34 <quicksilver> do you have latin1 in a source file? or in user input?
04:05:07 <romildo> quicksilver, then, how can I have those characters in the messages my program outputs in a latin1 Linux system?
04:05:24 <romildo> in source file.
04:05:30 <quicksilver> source files have to be UTF8
04:05:40 <quicksilver> ghc doesn't support any other encodings
04:06:00 <quicksilver> output using standard primitves like hPutStrLn is 8-bit-chopped
04:06:08 <quicksilver> but 8-bit-chopped unicode is very close to latin1
04:06:13 <quicksilver> so that may be OK for what you want.
04:08:15 <romildo> Let's say I want to type the string literal "Versão" in Haskell. As my system locale is en_US.ISO-8859-1, how can I get it?
04:08:42 <quicksilver> you mean, in a source file?
04:08:48 <romildo> Exactly.
04:08:50 <quicksilver> that is a question for your editor.
04:08:50 <cjs> sioraiocht, did you get your MacOS X issues dealt with?
04:08:54 <quicksilver> your locale is quite irrelevant
04:09:01 <sioraiocht> cjs: edited the makefile for readline
04:09:02 <quicksilver> you must instruct your editor to save the file as UTF8
04:09:33 <sioraiocht> cjs: my problem was that gnu readline's makefile as is wouldn't compile the dynamic library properly
04:09:40 <sioraiocht> once I did that, it was fine
04:09:43 <romildo> ok. I think that will be easy for emacs.
04:09:49 <cjs> Oh! Within the ghc source, or a separate readline?
04:10:01 <sioraiocht> in gnureadline
04:10:10 <sioraiocht> i downloaded gnureadline 5.2
04:10:17 <sioraiocht> changed the makefile, and then installed it
04:10:20 <sioraiocht> and ghc worked fine
04:10:26 <cjs> We've never been able to get ghc6.8.2 to use anything but /opt/local/lib/ readline. We had it installed elsewhere, and it just hated it.
04:10:34 <cjs> Oh, wait, but we had 5.0 installed, not 5.2.
04:10:53 <cjs> Anyway, we finally gave up and started using macports for everything.
04:10:58 <sioraiocht> i HATE macports
04:11:21 <cjs> I don't like it much myself, but then again, I don't like Macs. :-)
04:11:26 <sioraiocht> ah
04:11:28 <sioraiocht> i <3 my mac
04:12:13 <fons> quicksilver: is there a proposal to include that zipwith code in the library?
04:12:21 <quicksilver> AFAIk, if you compile your own ghc you can do what you want wrt readline
04:12:23 <fons> in the mainstream libraries I meant
04:12:36 <sioraiocht> quicksilver: i couldn't get it to statically link against gnureadline
04:12:37 <quicksilver> but if you want ot use someone else's compile, the readline has to be where it expects?
04:12:49 <sioraiocht> quicksilver: yes
04:13:00 <quicksilver> fons: not as far as I know
04:13:08 <quicksilver> fons: I was hoping for comments on it, but none came :)
04:13:48 <fons> quicksilver: I like it
04:14:05 <fons> much more general than the ugly thing I came up with
04:14:31 <quicksilver> it's quite useful for, e.g., numbering the nodes in an AST tree
04:14:35 <quicksilver> or tricks like that
04:15:16 <hpaste>  fons pasted "my ugly solution to my problem" at http://hpaste.org/7006
04:16:28 <fons> quicksilver:  there's something I don't really understand
04:16:36 <fons> (the combinator used for example)
04:18:01 <fons> but, in particular what happens if the second argument of zipTF (the foldable) doesn't have as much elements as the first one (traversable)
04:18:37 <quicksilver> pattern match error in 'supply'
04:18:42 <quicksilver> supply = Supply (\(x:xs) -> (xs,x))
04:18:47 <quicksilver> not very clean, I guess :)
04:18:55 <quicksilver> but you can't emulate the list behaviour
04:18:59 <quicksilver> you can't just "stop short"
04:19:09 <fons> quicksilver: I know
04:19:10 <quicksilver> a "half-filled traversable" doesn't work!
04:19:11 <quicksilver> ;)
04:19:23 <fons> that's what I do in my nasty solution (I have just pasted it)
04:20:09 <quicksilver> fons: incidentally that's a really unnecessary use of ST :)
04:20:20 <quicksilver> fons: it could just be State [a]
04:20:43 <quicksilver> note that my 'Supply' is just a State [a] with a restricted interface.
04:21:08 <fons> quicksilver: isn't it faster?
04:21:43 <fons> if you use State, updating the inner list would be slower
04:21:51 <quicksilver> nope.
04:22:03 <quicksilver> quite the opposite
04:22:08 <quicksilver> the ST version will be slower
04:22:16 <quicksilver> all that overhead of creating/destroying refs :)
04:22:23 <quicksilver> I doubt it would be measurable though.
04:22:26 <quicksilver> it's only one ref.
04:24:46 <fons> quicksilver: but the list inside a State monad would be inmutable and thus, from what I know, updating it whould cause more overhead
04:25:22 <quicksilver> but you don't update it
04:25:28 <quicksilver> you just keep the reference to the tail
04:25:43 <quicksilver> a list inside an STRef is precisely as immutable, by the way
04:25:47 <quicksilver> it's the ref itself that's mutable
04:25:50 <quicksilver> not its contents
04:25:57 <mux_> http://www.hans-eric.com/2008/04/16/the-future-of-d-is-functional/
04:25:59 <lambdabot> Title: The Future of D is Functional, http://tinyurl.com/6fqtxk
04:26:10 <fons> quicksilver: you don't update the sate?
04:26:14 <fons> state?
04:26:26 <fons> then I cannot quite see how it can be done
04:26:41 <fons> would you mind modifying my example to show how could be done with State?
04:30:19 <hpaste>  quicksilver annotated "my ugly solution to my problem" with "State version" at http://hpaste.org/7006#a1
04:30:28 <quicksilver> fons: you'll find it looks rather similar ;P
04:30:45 <quicksilver> but it contains 1 fewer line!
04:30:49 <quicksilver> 1 fewer line = win
04:30:49 <fons> hehehe
04:30:55 <fons> thanks, let's see
04:32:31 <fons> quicksilver: ok, that's actually what I initially thought you meant
04:32:32 <quicksilver> basically an ST in which you use 1 single ref at a fixed type
04:32:41 <quicksilver> is quite isomorphic to State
04:32:54 <quicksilver> but slightly less efficient due to creation of the reference cell
04:33:12 <quicksilver> the "point" of ST is the ability to create new references during the action of various types
04:33:24 <quicksilver> and the mutable array stuff, too
04:33:44 <fons> quicksilver: but, I stil don't see why put/get are as efficient as writeSTRef/readSTRef
04:34:54 <quicksilver> fons: maybe you'd like to explain why you think writeSTRef/readSTRef should be faster?
04:35:03 <fons> hahah, ok
04:35:06 <quicksilver> ;)
04:35:14 <quicksilver> all they do is store references to haskell values in cells.
04:35:20 <quicksilver> the State version doesn't bother with an explicit cell
04:35:21 <dolio> Which would you expect to be more efficient? 'foo s a = (s', b)' or 'foo a = do s <- readSTRef r ; writeSTRef r s' ; return b'?
04:35:22 <fons> I surely have a unjustified assumption
04:35:30 <quicksilver> it just passes the value directly to the next action
04:35:44 <quicksilver> so effectively it uses function parameters as cells
04:35:55 <quicksilver> (the simplest way to model state in a functional language is just to recurse)
04:36:23 <fons> quicksilver: OK, thanks then
04:36:31 <quicksilver> it's actually not impossible that a good compiler would produce the same code for both :)
04:36:34 <quicksilver> but I'm fairly sure GHC won't
04:36:43 <quicksilver> I think the STRef version will come out with newIORef primops
04:37:00 <fons> lets see if I can define zipWithTF with statet
04:37:02 <fons> state
04:37:14 <quicksilver> note that my Supply is just a newtyped State
04:37:26 <quicksilver> it's a stack you can only pop from :)
04:38:48 <fons> ok ok
04:39:27 <fons> I still think your could should go into Data.Traversable
04:39:58 <fons> your code*
04:41:29 <quicksilver> I certainly wouldn't object.
04:41:34 <fons> with a nicer error handling though
04:41:36 <quicksilver> You could propose it on libraries@
04:41:38 <quicksilver> yeah ;)
04:41:42 <fons> error reporting I meant
04:41:48 <quicksilver> with an explanation of why you needed it.
04:44:56 <Jaak> @type let f f f = f 1 in f
04:45:04 <lambdabot>     Conflicting definitions for `f'
04:45:04 <lambdabot>     In the definition of `f'
04:46:03 <Jaak> @type let f = \f -> \f -> f 1 in f
04:46:05 <lambdabot> forall t t1 t2. (Num t1) => t -> (t1 -> t2) -> t2
04:51:32 <EvilTerran> ?type let f f = f 1 in f
04:51:33 <lambdabot> forall t t1. (Num t) => (t -> t1) -> t1
04:52:46 <EvilTerran> you can't have duplicate names in a single binding, but inner bindings shadow outer ones; the name of a function is bound in the let{} scope while its parameters are only bound in the body of the function, so a parameter can shadow the function name
04:53:48 <EvilTerran> this allows for the rather clever trick that, given a definition "foo x = <some recursive definition>", making that "foo foo x = <etc>" makes (fix foo) do what foo did previously
04:57:06 <matthew_-> why can't you have overlapping instances on type families?
04:59:32 <dolio> If you define overlapping instances in separate modules, it could make the type system unsound.
05:00:07 <dolio> F a in one module could reduce to a different type than F a in a different module.
05:00:35 <dolio> Depending on which is more specific.
05:00:47 <dolio> At least, that's my understanding.
05:00:49 <matthew_-> and why can't this happen with type classes?
05:01:08 <dolio> It can, but it doesn't matter, because that just causes different functions to be called.
05:01:49 <dolio> At least, it's not unsound.
05:01:59 <matthew_-> gotcha
05:02:14 <dolio> They're apparently implementing closed type families that will be able to overlap.
05:02:23 <dolio> Since they'll all have to be defined at once.
05:03:05 <matthew_-> ahh. cool
05:18:57 <mm_freak_work> hi there
05:19:42 <mm_freak_work> is there a way to express (printf "%6.3f") more nicely?
05:19:53 <ivanm> how is that not nice?
05:20:34 <mm_freak_work> i thought, there should be a way without borrowing C ideas
05:20:42 <idnar> I guess something like "formatFloat 6 3" might be nicer
05:21:05 <idnar> printf's formatting syntax ends up being a somewhat obscure meta-language
05:21:13 <ivanm> idnar: but it's not as composable...
05:21:41 <quicksilver> mm_freak_work: showEFloat showFFloat showGFloat
05:23:13 <mm_freak_work> hmm
05:23:52 <mm_freak_work> thank you
05:24:14 <mm_freak_work> if the format string is known at compile time, will it still be parsed at run time?
05:25:00 <mauke> yes
05:25:14 <mauke> (I think)
05:29:43 <Baughn> Constant folding is a wonderful thing, but that's asking a bit much
05:29:47 <fons> quicksilver: are you still around?
05:30:43 <mm_freak_work> k
05:30:49 <fons> quicksilver: I have coded an alternative version of your general zipWith just using state and with better error reporting
05:32:50 <mm_freak_work> can i make the IO functions respect locale settings like LANG and LC_*?
05:33:01 <Baughn> Nnn..o.
05:33:09 <mauke> depends
05:33:20 <Baughn> They're stuck on ascii, aren't they?
05:33:36 <mauke> if you mean character encoding, yes (it's actually latin-1)
05:33:40 <Baughn> ..that may not be quite right, but it simplifies things
05:33:41 <mm_freak_work> as far as i've seen, pretty much everything is stuck on bytes
05:33:52 <Baughn> mauke: Yes, and latin-1 comes out as a bunch of boxes for me
05:34:14 <Baughn> mm_freak_work: There is a utf-8 library you can use, at least. You're out of luck on other encodings.
05:35:18 <mm_freak_work> it would suffice to read UTF-8-encoded textâ€¦  i don't need to interpret the characters
05:35:28 <Baughn> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string-0.3 <-- Here you go, then
05:35:30 <lambdabot> http://tinyurl.com/67hepr
05:36:31 <quicksilver> fons: cool :)
05:36:34 <mauke> if you don't need to interpret the characters, where's the problem?
05:36:43 <trez> we
05:36:45 <mauke> just use ByteStrings or whatever
05:36:53 <hpaste>  fons annotated "my ugly solution to my problem" with "Alternative version of generalized zipWith" at http://hpaste.org/7006#a2
05:38:03 <mauke> how evil is using 'when (...) $ do' without increasing the indentation level in the next line?
05:38:21 <ddarius> mauke: You can't get out of the do then.
05:38:31 <mauke> exactly
05:38:44 <mauke> it's like "early return" in C
05:38:57 <dolio> Mildly evil?
05:39:00 <mm_freak_work> mauke: no, i need to parse UTF-8, i just don't need to interpret the characters (sorting, converting case, etc.)
05:39:12 <mauke> mm_freak_work: â€½
05:39:56 <mm_freak_work> that's why ByteString/lists won't help
05:42:29 <mm_freak_work> well, there is System.Locale, but it's extremely useless
05:44:46 <hpaste>  gnuvince pasted "(no title)" at http://hpaste.org/7007
05:44:51 <mm_freak_work> utf8-string will help for now, but more focus needs to be placed on locales and i18n in general IMO
05:46:39 <mauke> > let subsetp = (null .) . (\\) in "bar" `subsetp` "beard"
05:46:42 <lambdabot>  True
05:47:02 <ddarius> Take your Lispisms out of here!
05:47:39 <mauke> > let subsetp = (null .) . (\\) in "bara" `subsetp` "beard"
05:47:40 <lambdabot>  False
05:49:32 <gnuvince> :t (\\)
05:49:34 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
05:51:59 <mauke> A âŠ† B  â‡”  A \ B = âˆ…
05:54:43 <ddarius> Now You Know *que effect*
05:54:50 <ddarius> s/q/c
05:55:12 <hpaste>  ToRA annotated "my ugly solution to my problem" with "FromList variations" at http://hpaste.org/7006#a3
05:57:16 <fons> quicksilver: I appended my version to http://www.haskell.org/haskellwiki/FoldableAndTraversable just in case you are interested
05:57:18 <lambdabot> Title: FoldableAndTraversable - HaskellWiki
05:57:21 <ToRA> fons/quicksilver - sorry for hijacking - it's an interesting function to write & minimize
05:57:51 * ddarius waits for "Variations in C"
05:59:12 <fons> ToRA: ??
05:59:34 <ToRA> fons: i annotated your paste...
05:59:43 <fons> oh ok
05:59:49 <fons> sorry I didn't understand
06:00:00 <fons> sorry
06:01:38 <ToRA> i have ambivolent feelings about case statements in monadic code - though getting rid of them means I've probably written a much more obfusicated variation of fillFromList...
06:02:12 <fons> have you seen my previous annotation?
06:03:04 <ToRA> genZipWith - yeah, looks like a useful set of combinators to have in certain situations
06:04:29 <fons> fillFromList = flip $ zipWithTF (\_ x -> x)
06:05:07 <quicksilver> fons: incidentally I view "uses a State monad instead of Supply" as a disadvantage, not a bonus.
06:05:33 <ToRA> fons: what about fillFromList' ?
06:06:03 <fons> quicksilver: due to the mtl dependency ?
06:07:16 <fons> ToRA: to be honest I'm not that familiar with Arrows
06:08:03 <ToRA> fons: look at the example runs, fillFromList' only succeeds if there are enough elements, wheras fillFromList will give you a data structure with error in it somewhere
06:08:04 <fons> but even with that, your first fillFromList alternative is lazier, which is good I guess
06:08:26 <quicksilver> fons: no, because it's a worse type signature
06:08:37 <quicksilver> fons: it's like using (void*) instead of a struct, in C
06:08:44 <quicksilver> the Supply monad is what it *is*
06:08:49 <quicksilver> State is just an implementation.
06:08:54 <fons> quicksilver: to what type signature are you refering to?
06:09:03 <quicksilver> the monad used
06:09:06 <quicksilver> State/Supply
06:10:52 <fons> quicksilver: you might be right, but in my opinion using State has its advantages, you don't have to cook your own state monad and the code should be easier to understand (at least with the comments both have) becase familiarity with State is likely in the reader.
06:11:26 <quicksilver> bah!
06:11:35 <fons> heheh
06:11:39 <quicksilver> you've used a state monad and then written 'pop' which is basically my 'supply'
06:11:43 <quicksilver> how is that easier to understand? :P
06:11:53 <quicksilver> and the supply monad is an independently important and reusable monad
06:12:02 <quicksilver> documented elsewhere on the wiki
06:12:18 <quicksilver> btw it's a bit weird to stuff the function name (for error messages) in the sate
06:12:21 <quicksilver> state
06:12:25 <quicksilver> since it can't change. It isn't really part of the state.
06:13:46 <fons> quicksilver: can you think of a better way to generalize error reporting?
06:20:03 <helmut> Is there a predefined sequence of types with a bijection to \mathbb{N} or do I have to write my own?
06:20:44 <mauke> like Enum?
06:21:46 <helmut> uhm. reading the documentation I cannot see how that is a sequence of types.
06:22:25 <helmut> I need a type Zero and then some kind of way to get the sucessing and preceding type.
06:22:33 <mauke> oh, type-level naturals
06:22:49 <helmut> (if there is no preceding type the compilation should fail)
06:22:52 <mauke> I thought you meant a collection of types, each of which can be bijected to N
06:23:14 <mauke> there's nothing in the standard libraries but many people have written one
06:23:16 <quicksilver> fons: just pass around the parameter like you are doing.
06:23:17 <helmut> so what would you call that instead of "a sequence of types"?
06:23:24 <quicksilver> fons: but don't bother to stuff it in the state :)
06:23:28 <mauke> "type-level naturals"
06:23:32 <helmut> ok.
06:23:52 <helmut> thanks http://www.haskell.org/haskellwiki/Type_arithmetic
06:23:53 <lambdabot> Title: Type arithmetic - HaskellWiki
06:23:54 <fons> helmut:  I coded a type-level library which uses decimal representation not peano
06:24:09 <fons> helmut: but it has Succ and Pred, of course
06:24:41 <matthew_-> fons: many of us have done that a few times ;)
06:24:50 <matthew_-> base10 is pretty straight forward most of the time
06:24:54 <helmut> fons: I'd be glad to use
06:25:01 <fons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/type-level-0.1
06:25:02 <lambdabot> http://tinyurl.com/6glw5g
06:25:23 <fons> matthew_-: no intention to brag about it :S
06:25:30 <fons> just trying to help
06:25:46 <matthew_-> fons: sorry, me neither. That came out all wrong. Sorry.
06:25:52 <fons> helmut: the library is in the link I have just pasted
06:26:10 <fons> matthew_-:  np
06:26:22 <helmut> looks good
06:26:31 <matthew_-> fons: ahh, you were the guy who responded to my post to -cafe a while ago?
06:26:40 <matthew_-> I never replied back to you did I?
06:26:47 <fons> matthew_-: which one?
06:26:55 <matthew_-> session types
06:27:09 <fons> Right, it was me
06:27:32 <matthew_-> right, yes, of course you're more than welcome to reuse any work I've done, if it's of use
06:27:44 <matthew_-> and the usual licensing and copyright stuff, obviously.
06:28:05 <fons> helmut:  you might want to start reading http://hackage.haskell.org/packages/archive/type-level/0.1/doc/html/Data-TypeLevel-Num-Reps.html
06:28:10 <lambdabot> http://tinyurl.com/6je55f
06:28:23 <fons> as a teaser,
06:28:37 <fons> D1 :* D2 :* D0 represents the decimal number 120
06:29:29 <helmut> fons: 's non-portable though.
06:29:47 <fons> helmut: GHC-only yes due to various reasons
06:30:04 <fons> type operators and template haskell
06:30:22 <helmut> I'm reading the source atm.
06:30:29 <helmut> Mabe I can use a smaller thingy.
06:30:31 <fons> It might be possible to make it only MPTC-dependent
06:30:48 <mm_freak_work> @pl \a b -> f a b
06:30:48 <lambdabot> f
06:30:51 <matthew_-> no, I would expect you would require overlapping instances to do any work
06:30:55 <fons> type operators are intuitive though
06:31:00 <mm_freak_work> @pl \a b -> g (f a b)
06:31:00 <lambdabot> (g .) . f
06:31:20 <matthew_-> yeah, my version requires: {-# LANGUAGE MultiParamTypeClasses, FunctionalDependencies, FlexibleInstances, UndecidableInstances, OverlappingInstances, GADTs, KindSignatures #-}
06:31:28 <fons> matthew_-: isn't overlapping instances a common extension?
06:31:48 <matthew_-> fons: I haven't a clue. I tend not to care about anything outside GHC
06:31:56 <matthew_-> helmut: feel free to look at http://www.wellquite.org/non-blog/sessions-browseable/Control/Concurrent/Session/Number.hs
06:31:58 <mm_freak_work> @pl \a -> length . filter (uncurry (==)) . zip a
06:31:58 <lambdabot> ((length . filter (uncurry (==))) .) . zip
06:32:00 <fons> heheh, right, fair enough
06:32:01 <lambdabot> http://tinyurl.com/6ozotr
06:32:05 <EvilTerran> i think it's possible to do it without undecidable instances, altho it requires painful amounts of insight
06:32:25 <EvilTerran> (or i may be thinking of overlapping instances)
06:32:38 <matthew_-> you can normally expand out overlapping IIRC
06:32:42 <fons> EvilTerran: so painful that you don't even want to try to do it
06:32:44 <matthew_-> I think they do that in the HList paper
06:32:52 <EvilTerran> matthew_-, yeah, that's what i was thinking of
06:32:59 <matthew_-> you just end up with lots of type-level booleans
06:33:38 <EvilTerran> and it's def. possible to dispense with GADTs and kind signatures, altho the end result may be uglier to look at
06:33:56 <fons> matthew_-: Ever have you given Epigram a try?
06:34:04 <matthew_-> fons: oh yes
06:34:21 <matthew_-> we had a fling some time ago
06:34:29 <fons> Have you ever*
06:34:45 <matthew_-> and then I left her for a language in which you could actually do stuff
06:34:58 <matthew_-> the lack of IO was detrimental to our relationship
06:35:05 * fons is dylexic, no way to hide it
06:36:12 <fons> matthew_-:  I have never tried Eprimgram, but I'm curious. What's that "lack of IO" you are refering to?
06:36:44 <matthew_-> fons: well, you can't actually do anything in it
06:37:01 <matthew_-> it's a nice proof of concept and it is useful for exploring these things
06:37:16 <matthew_-> but it's not a viable tool in the same why that GHC with all the trimmings is a viable tool
06:37:17 <fons> but ....
06:37:26 <matthew_-> otoh, it can do some really damn clever stuff
06:38:36 <fons> OK, nice chat, and thank's for the generic zipWith code I have to go back to that crazy Haskell-to-VHDL compiler (sigh)
06:38:38 <fons> bye
06:51:40 <quicksilver> dcoutts_: is someone going to write a breif report on the hac?
06:51:46 <quicksilver> would be interesting to know how it went
06:51:57 <dcoutts_> quicksilver: I think bringert said he'd write something
06:52:15 <dcoutts_> though our blog isn't yet syndicated on planet haskell
06:52:36 <bringert> I was only planning to write about what the we Well-Typed guys did
06:52:49 <bringert> I didn't really make any survey of what everyone was up to
06:53:16 <dcoutts_> bringert: though perhaps some general info, not what everyone worked on
06:53:20 <bringert> yeah
06:53:30 <dcoutts_> basically how much fun we all had :-)
06:54:15 <dcoutts_> bringert: perhaps a breif mention that we were pondering setting up a hackathon steering committee
06:59:23 <quicksilver> bringert: the photo has a tantalising lack of labelling
06:59:33 <quicksilver> bringert: I demand to know who the small monkey dons(?) is holding is!
06:59:50 <bringert> quicksilver: I believe that it belongs to Heffalump
06:59:58 <bringert> but you'd better ask him
07:03:43 <romildo> Given the type "data Semester = Sem Integer Integer", where the first integer is the year, and the second is the semester (1, or 2), I need to make it an instance of class Reader. The input is in the form "year/semester". Would anyone show me how to implement that?
07:04:13 <mauke> MonadReader?
07:04:19 <mauke> oh, you mean Read
07:04:30 <romildo> yes, Read.
07:04:35 <romildo> I am asking because I am in a hurry.
07:04:44 <Saizan> ?src Read
07:04:44 <lambdabot> class Read a where
07:04:44 <lambdabot>   readsPrec    :: Int -> ReadS a
07:04:44 <lambdabot>   readList     :: ReadS [a]
07:04:44 <lambdabot>   readPrec     :: ReadPrec a
07:04:44 <lambdabot>   readListPrec :: ReadPrec [a]
07:05:13 <romildo> And it will take me some time to figure out how to implement it.
07:05:16 <mauke> is it ok if it blows up on malformed input?
07:06:14 <mauke> :t (***)
07:06:17 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
07:06:20 <romildo> mauke, what is the default behaviour for other types?
07:06:34 <mauke> depends on which function you use
07:06:51 <mauke> uncurry Sem . join (***) read . fmap tail . span ('/' /=)
07:07:05 <quicksilver> romildo: "deriving Read"
07:07:18 <romildo> I want it to parse command line options: "progname --semester 2008/2" for instance.
07:07:25 <mauke> I wouldn't use Read for that
07:07:33 <quicksilver> I would say, that's not what Read is for.
07:07:34 <quicksilver> ;)
07:07:39 <mauke> I also wouldn't make the semester number an Integer
07:07:45 <glen_quagmire> GetOpt?
07:07:56 <romildo> I am already using GetOpt.
07:08:40 <glen_quagmire> > words "progname --semester 2008/2" !! 2
07:08:42 <lambdabot>  "2008/2"
07:08:51 <quicksilver> let (x,'/':y) = break (=='/') "2008/1" in Sem (read x) (read y)
07:08:56 <quicksilver> is how I would do that.
07:09:07 <quicksilver> if you really do want numbers. And no validation :)
07:09:16 <mauke> :t uncurry ?sem . join (***) read . fmap tail . span ('/' /=)
07:09:17 <lambdabot> forall c c1. (Read c1, ?sem::c1 -> c1 -> c) => [Char] -> c
07:09:20 <quicksilver> but you probably want validation as a separate function anyway.
07:09:22 <romildo> quicksilver, nice.
07:09:51 <quicksilver> valid (Sem y s) = (y > 2005 && y < 2100) && (s `elem` [1,2])
07:09:53 <quicksilver> perhaps
07:11:33 <romildo> quicksilver, seems good to me. thanks.
07:12:40 <quicksilver> but using Int 1/2 for semester is indeed rather ugly
07:13:11 <quicksilver> data .. = Winter | Summer, or First | Second
07:13:15 <quicksilver> or whatevre you want to call them
07:13:34 <romildo> I do some arithmetic on semester...
07:14:46 <quicksilver> yuck :)
07:14:49 <quicksilver> what kind of arithmetic?
07:14:52 <romildo> to advance a number of semesters from a given one. something like "advance (Sem 2008 2) 3" giving "Sem 2010 1"
07:15:06 <romildo> I do arithmetic on the year and semester.
07:15:13 <mauke> newtype Semester = Sem Int
07:15:39 <mauke> "2008/2" ==> Sem (2008 * 2 + 1)
07:19:14 <hpaste>  vag pasted "Flag Problem" at http://hpaste.org/7008
07:25:15 <dcoutts_> @seen ~maciek~
07:25:15 <lambdabot> I haven't seen ~maciek~.
07:25:19 <dcoutts_> @seen ^maciek^
07:25:20 <lambdabot> I haven't seen ^maciek^.
07:37:12 <pjd_> romildo: you can do that with mod-4 arithmetic
07:39:30 <pjd_> or mod-2, anyway
07:40:17 <romildo> pjd_, yes, I am using mod-2 arithmetic for the advance function I mentioned.
07:43:20 <pjd_> romildo: making Semester a newtype of Int or such, as mauke suggested, is probably sensible
07:45:35 <romildo> Basically I will need to check if two semesters are both the first of the year, or the second of the year. Having two fields makes it easy for that.
07:46:09 <mauke> just use `mod` 2
07:46:40 <scook0> or define a function that projects the Int out into a pair of values
07:47:28 <hpaste>  romildo pasted "parsing semesters" at http://hpaste.org/7009
07:47:33 <mauke> it's called divMod :-)
07:47:40 <romildo> Ok. I have now the pasted definition for parseSem. Now I would like to know how to handle the exception raised when the parts are not valid integers.
07:47:41 <quicksilver> @seen dons
07:47:41 <lambdabot> dons is in #haskell, #xmonad, #haskell-hac4 and #haskell-soc. I last heard dons speak 49m 59s ago.
07:48:05 <scook0> mauke: sure, but it can be nice to have a named abstraction
07:50:59 <romildo> To be honest, I have not complete understood what mauk suggested until now. It is good solution. I will consider it later. Anyway I still need to parse it as a pair of integers, as this is the way we refers to semesters here at the university.
07:52:46 <fons> romildo: how about matching the string with a regular expression?
07:53:12 <quicksilver> :t reads
07:53:15 <romildo> fons, that also is acceptable.
07:53:15 <lambdabot> forall a. (Read a) => String -> [(a, String)]
07:53:32 <mauke> > reads "2001/2" :: [(Int, String)]
07:53:34 <lambdabot>  [(2001,"/2")]
07:53:39 <fons> romildo: you e nsure that no exceptions are generated by read
07:53:47 <mauke> > reads "error/2" :: [(Int, String)]
07:53:48 <lambdabot>  []
07:54:24 <quicksilver> > let parseInt :: String -> Int ; parseInt s = case reads s of [(x,"")] -> x ; _ -> error "That wasn't a number" in parseInt "2008"
07:54:26 <lambdabot>  2008
07:54:27 <romildo> reads also is good, as it returns failure as an empty list.
07:54:35 <quicksilver> > let parseInt :: String -> Int ; parseInt s = case reads s of [(x,"")] -> x ; _ -> error "That wasn't a number" in parseInt "xxxx"
07:54:35 <lambdabot>  Exception: That wasn't a number
07:54:39 <quicksilver> for example
07:54:48 <quicksilver> although you probaly don't want to use 'error' in practice.
07:54:52 <quicksilver> fons: wrong ;)
07:55:02 <quicksilver> fons: catching exceptions from pure code is bad.
07:55:26 <fons> fons: when did I mention anything realated to catching exceptions?
07:55:30 <fons> related*
07:56:09 <quicksilver> fons: "< fons> romildo: you e nsure that no exceptions are generated by read"
07:56:11 <romildo> I asked how I would handle the exceptions, because in the solution I had I used read.
07:56:20 <quicksilver> that's what I assumed you meant, fons.
07:56:42 <byorgey> I think fons meant that by using 'reads' instead of 'read', you ensure that... etc.  (?)
07:56:50 <fons> by matching against a regular expression first
07:57:08 <byorgey> oh, I see
07:57:10 <quicksilver> I think that a regular experssion is a more complex thing, really.
07:57:19 <quicksilver> you could use one, btu I wouldn't bother for this simple case.
07:57:28 <quicksilver> in fact, I never use regexes in haskell.
07:57:35 <quicksilver> I use simple string hacks for simple stuff
07:57:42 <quicksilver> and proper parsers for anything harder.
07:57:50 <scook0> it seems simpler just to ask reads whether it failed, than use regexes to ensure read won't fail
07:58:10 <quicksilver> in the context of haskell, regexps feel like just an embedded parsing language with limited power and horrible syntax :)
07:58:23 <quicksilver> whereas in perl I use them all the time because they are the simplest way to do certain things.
08:00:21 <hpaste>  vag annotated "Flag Problem" with "Slightly modified" at http://hpaste.org/7008#a1
08:00:57 <fons> BTW is there a way to process regex groups in haskell?
08:02:12 <quicksilver> sure
08:02:31 <quicksilver> although jsut because I"m a pedant, I would point out that this is a question about the regex library :)
08:02:35 <hpaste>  vag annotated "Flag Problem" with "or even more" at http://hpaste.org/7008#a2
08:02:42 <quicksilver> I don't really think of Text.Regex as being part of the haskell core libs
08:02:54 <fons> quicksilver: how?
08:03:20 <fons> I have been reading a regex tutorial and I don't seem to find a way to process regex subgroups
08:03:58 <quicksilver> it's all in the overloading, I believe
08:04:10 <quicksilver> I don't really agree with that piece of interface design :)
08:04:22 <quicksilver> but if you use the correct return type you get your grouped matches
08:04:39 <ziman> > "abbbc" =~ "a(b+)c" :: (String, String, String, [String])
08:04:39 <lambdabot>   Not in scope: `=~'
08:07:15 <fons> quicksilver: OK, I think its when the context is Array Int (no idea why)
08:08:03 <glen_quagmire> what's the purpose of typeclass?
08:08:27 <quicksilver> glen_quagmire: to overload operators.
08:09:13 <glen_quagmire> > let { f 1 = 1; f "1" = "1"; } in f "1"
08:09:14 <lambdabot>   add an instance declaration for (Num [Char])
08:09:14 <lambdabot>     In the pattern: 1
08:09:14 <lambdabot>     In t...
08:09:30 <quicksilver> fons: well there is also the more general "MatchResult", and the (b,b,b,[b]) ooption.
08:09:33 <glen_quagmire> oh haskell weon't overload
08:09:33 <hpaste>  romildo pasted "parsing a semester: new version" at http://hpaste.org/7010
08:09:44 <romildo> This is my new version of the parseSem function.
08:09:50 <quicksilver> @hoogle matchRegexAll
08:09:50 <lambdabot> No matches found
08:10:01 <quicksilver> fons: matchRegexAll is the non-overloaded version
08:10:05 <romildo> I think now it is complete.
08:10:25 <fons> ok
08:19:27 <glen_quagmire> @hoogle m a -> a
08:19:27 <lambdabot> Prelude.id :: a -> a
08:19:27 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
08:19:27 <lambdabot> Data.Function.id :: a -> a
08:19:50 <helmut> Could someone help me representing primitive recursive functions using haskell data?
08:19:55 <glen_quagmire> is it a good idea to provide extract :: MyMonad a -> a    ?
08:20:04 <helmut> I think I need some kind of type forall.
08:20:37 <byorgey> glen_quagmire: such a function only makes sense for certain monads.
08:20:45 <scook0> @type runIdentity
08:20:45 <lambdabot> forall a. Identity a -> a
08:20:59 <scook0> that's pretty much the only safe one
08:21:04 <wjt> @ty runReader
08:21:05 <lambdabot> forall r a. Reader r a -> r -> a
08:21:18 <scook0> then there's partial stuff like head and fromJust
08:21:40 <byorgey> well, and 'maybe' and 'fromMaybe'
08:21:41 <mauke> :t evalState
08:21:42 <lambdabot> forall s a. State s a -> s -> a
08:22:08 <scook0> byorgey: I was specifically addressing m a -> a
08:22:12 <helmut> uhm. how do I find out whether I need that?
08:22:40 <byorgey> scook0: right, I just meant that 'maybe' and 'fromMaybe' are 'in the same spirit'
08:22:52 <glen_quagmire> parser :: String -> Maybe Expr.     typeCheck :: Expr -> TC Expr.   eval :: Expr -> Eval Expr
08:22:55 <scook0> but yes, in general, you want your monad to have some kind of "eval" function
08:22:58 <vincenz> :t fromMaybe
08:22:58 <byorgey> you put in an  m a as well as some extra information, and get out an a
08:22:59 <lambdabot> forall a. a -> Maybe a -> a
08:23:20 <scook0> which can be maybe, or pattern-matching, or runState, or whatever
08:23:32 <helmut> I'm trying to define  data MuRec n -- taking n parameters where n is Zero or Succ (... Zero).
08:23:34 <scook0> it won't have the exact type m a -> a
08:23:40 <scook0> but it will be similar in spirit
08:23:40 <glen_quagmire> so, from parser, I can get Expr using pattern matching.  now I pass the Expr to typeCheck..  and I'm not sure how to call eval
08:23:59 <Saizan> helmut: taking n parameters at the type level?
08:24:00 <helmut> now I thought I'd need forall m. Project n m
08:24:29 <Saizan> helmut: data Mu f = Mu (f (Mu f)), usually
08:24:32 <helmut> Saizan: well I try to represend murecursive functions as data trees.
08:24:43 <byorgey> glen_quagmire: it depends on what 'TC' is.
08:24:59 <scook0> glen_quagmire: does TC actually do anything, or does it just "witness" that the term typechecks?
08:25:10 <helmut> Saizan: I'd be great if I could use the definitions from the book used by my cs lecture.
08:25:50 <Saizan> helmut: are they in haskell?
08:25:54 <helmut> Saizan: no
08:25:55 <glen_quagmire> TC would keep track of type variables...etc
08:26:11 <helmut> Saizan: I'm trying to convert them to haskell.
08:26:45 <glen_quagmire> now I have unification algorithm implemented, i'm wondering how that'll fit in current interpreter that runs parser and then eval
08:26:56 <vincenz> glen_quagmire: how is TC Expr defined?!
08:27:46 <malsyned> Is there a function in the standard libraries that takes a list and two indexes and returns the sub-list between those indexes?  like list slices in Python, for example?
08:27:58 <vincenz> yes
08:28:07 <mauke> vincenz: since when?
08:28:11 <vincenz> > let slice a b l = drop a . take b $ l
08:28:11 <lambdabot>  Parse error at end of input
08:28:16 <helmut> Saizan: I'm trying | forall. Substitute n (MuRec m) [MuRec n]
08:28:30 <helmut> err forall m.
08:28:31 <malsyned> It's implementation is pretty easy, like "slice min max list = take (max-min) $ drop min list" but if it's already written, no point including my own.
08:28:47 <vincenz> malsyned: see mine :)
08:28:49 <gnuvince> :t slice
08:28:50 <lambdabot> Not in scope: `slice'
08:29:02 <vincenz> @let slice a b l = drop a . take b $ l
08:29:03 <lambdabot> Defined.
08:29:04 <vincenz> :t slice
08:29:05 <lambdabot> forall a. Int -> Int -> [a] -> [a]
08:29:19 <vincenz> > slice 1 5 [1..10]
08:29:21 <lambdabot>  [2,3,4,5]
08:29:30 <helmut> I probably skip type checking for now and just use plain Integer
08:30:00 <vincenz> malsyned: so in answer (drop a . take b) === slice a b
08:30:33 <phlpp> @src permute
08:30:33 <lambdabot> Source not found. My brain just exploded
08:30:41 <phlpp> @src permutate
08:30:41 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
08:30:44 <phlpp> oh :F
08:32:06 <hpaste>  fons annotated "parsing a semester: new version" with "an alternative version using regular expressions" at http://hpaste.org/7010#a1
08:33:09 <fons> romildo: I pasted a new version which uses regular expressions
08:34:14 <fons> in my opinion it is shorter and nicer but I guess quicksilver is not going to agreee hehe :)
08:34:36 <quicksilver> it's only nicer if you already know regex syntax
08:34:43 <quicksilver> and if you don't believe regex syntax is ugly
08:34:45 <quicksilver> :-S
08:35:22 <fons> quicksilver: Do you happen to know about a regex DSL for haskell?
08:35:30 <quicksilver> sure. it's called parsec ;P
08:35:39 <quicksilver> and it's not even restricted to regular languages.
08:35:40 <yuriyp> @src transpose
08:35:40 <lambdabot> transpose []             = []
08:35:40 <lambdabot> transpose ([]   : xss)   = transpose xss
08:35:40 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
08:35:41 <quicksilver> bonus!
08:36:09 <osfameron> since when have regular expressions been regular?
08:36:17 <fons> I know parsec, but that's not what I meant
08:36:37 <fons> I meant a DSL in which you build regular expressions syntactically with a DSL
08:36:48 <vincenz> osfameron: Since the summer of '69
08:36:55 <quicksilver> but it's the same thing, surely?
08:36:58 <malsyned> vincenz: so the answer, then, is "no, the Prelude doesn't have a function like that, you have to build it yourself" ;)
08:37:08 <vincenz> malsyned: potay-toe, potah-toe
08:37:14 <yuriyp> @src transpose
08:37:14 <lambdabot> transpose []             = []
08:37:14 <lambdabot> transpose ([]   : xss)   = transpose xss
08:37:14 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
08:37:21 <quicksilver> I meant what would a DSL for regexes look like, if not very like a parser combinator library?
08:37:24 <vincenz> malsyned: it's based on just two functions, no logic, so can be placed inline :)
08:37:33 <fons> pretty much in the same way as it is possible to do type-safe database acess with other DSLs
08:37:37 <quicksilver> regexes are system of parser combinators encoded as strings...
08:37:44 <vincenz> malsyned: so the prelude has it, it just comes in a package of 2 ;)
08:37:48 <quicksilver> right, but that's what parser combinators are.
08:37:57 <byorgey> @go enumerating strings of regular languages
08:37:58 <lambdabot> http://www.cs.dartmouth.edu/~doug/nfa.ps.gz
08:38:15 <byorgey> not quite the same thing, but cool =)
08:38:18 <quicksilver> I would challenge you to write a DSL for regexes. I bet you come up with something which is isomorphic to a set of parser combinators :)
08:38:33 <quicksilver> of course, it might choose different naming conventions etc
08:38:40 <vincenz> quicksilver: that reminds me of that xkcdc coming
08:38:43 <fons> quicksilver: then according to your reosoning regular expressions shouldn't be used in haskell at all
08:38:47 <vincenz> quicksilver: "Stand back, I know regular expressions!"
08:38:49 <fons> reasoning
08:39:09 <quicksilver> fons: well, that is more-or-less my opinion.
08:39:21 <fons> fair enough then
08:39:45 <quicksilver> REs are a bit mor compact
08:39:49 <fons> my point is, people will keep using regular expressions
08:39:52 <quicksilver> at the cost of being more opaque :)
08:40:00 <quicksilver> but the advantage of REs is the notation, surely?
08:40:04 <quicksilver> (which is a 2-edged sword)
08:40:12 <quicksilver> once you give up the ultra-compact notation
08:40:15 <vincenz> can't you make parsec combinators that parse a RE
08:40:19 <vincenz> and then that generate a parec combinator?
08:40:23 <vincenz> surface syntax = RE
08:40:25 <vincenz> system = parsec
08:40:43 <quicksilver> yes, you can.
08:40:43 <vincenz> it unifies what you two are saying
08:40:47 <vincenz> usability vs implementation
08:40:49 <idnar> I think the main reason people use regular expressions is because they're conveniently available, and they already know them
08:40:53 <quicksilver> once you give up the ultra-compact notation,
08:40:57 <quicksilver> you have just another parsing DSL
08:41:04 <quicksilver> of course, you might have made a particular good one
08:41:07 <quicksilver> (which is great!)
08:41:12 <quicksilver> but it won't really be REs any more
08:41:16 <vincenz> re :: String -> Parser
08:41:22 <phlpp> where do i fand permute?
08:41:25 <phlpp> *find*
08:41:29 <fons> quicksilver: what about using quasiquoting with regular expressions?
08:41:35 <phlpp> even lambdabot forgot about the sources
08:41:36 <phlpp> -_-
08:41:45 <fons> the syntax is regular expressions as we have always seen them
08:41:49 <vincenz> @hoogle permute
08:41:49 <lambdabot> Text.ParserCombinators.Parsec.Perm.permute :: PermParser tok st a -> GenParser tok st a
08:41:49 <lambdabot> System.Console.GetOpt.Permute :: ArgOrder a
08:41:56 <vincenz> phlpp: I don't think it exists
08:41:59 <vincenz> phlpp: kinda lame function
08:42:01 <phlpp> hm, okay
08:42:03 <bringert> @seen dons
08:42:03 <lambdabot> dons is in #haskell, #xmonad, #haskell-hac4 and #haskell-soc. I last heard dons speak 29m 33s ago.
08:42:06 <fons> but if they are ill formed an error would be raised at compile time
08:42:25 <quicksilver> fons: yes, that would be an advantage.
08:42:50 <quicksilver> would be quite a nice test case for quasiquotes
08:42:56 <fons> I like regex syntax I just don't like the fact that the compiler doesn't protect you from typing invalid regular expressions
08:42:57 <phlpp> vincenz: i just thought of it to get some idea (i have to figure out how to write a permute function (e.g. of strings) in an other programming language
08:43:01 <phlpp> (an imperative one)
08:43:34 <fons> uhm it would be cool to implement a quasiquoter getting regular expressions as input
08:44:27 <fons> and even better, one could match regular expressions by using standard pattern matching
08:44:44 <mrd> um, can't you use constructors to build regexes directly?
08:44:59 <mrd> Star (Char 'a')
08:45:14 <quicksilver> yes
08:45:23 <quicksilver> and then you lose teh advantage of compactness
08:45:27 <fons> mrd:  the problem is that you get undesirable syntax as a result
08:45:32 <mauke> syntax matters
08:45:34 <quicksilver> which is, I presume RE's only advantage :)
08:45:37 <vincenz> fons: what' wrong with String -> Such a system
08:45:45 <quicksilver> vincenz: runtime instead of compile time
08:45:53 <quicksilver> is fons' point
08:45:57 <vincenz> put it in generic haskell
08:45:59 <quicksilver> this is a classis case for quasi quotin
08:46:01 <mrd> I guess TH could do it
08:46:08 <vincenz> Erm TH that is
08:46:17 <vincenz> $("regexstring")
08:46:26 <vincenz> an the nicce thing
08:46:30 <vincenz> if you don't care about compiletime
08:46:32 <vincenz> you just do
08:46:34 <quicksilver> incidentally there is already a RE -> parsec backend
08:46:35 <vincenz> re "regexstring"
08:46:40 <quicksilver> I think
08:46:44 <fons> vincenz: in addition, the syntax is less compact, you can see exactly what you are trying to parse by looking at the regex
08:46:57 <vincenz> fons: Hmm?
08:46:59 <vincenz> fons: what syntax?
08:47:00 <fons> well, my approach would be using quasiquoters
08:47:07 <vincenz> The string one?
08:47:10 <vincenz> $("*a")
08:47:29 <fons> vincenz: I'm talking about using combinators not Regexes
08:47:39 <vincenz> fons: And I think everyone else's point is
08:47:45 <fons> vincenz:  and quasiquoters are similar to TH
08:47:52 <vincenz> Have a function :   re :: String -> RegexpType
08:47:55 <vincenz> and i you ant, use TH
08:48:03 <vincenz> $(re "*a")
08:48:10 <fons> vincenz: but they allow to do parttern matching
08:48:12 <vincenz> s/ant/want
08:48:23 <fons> which could be cool
08:48:28 <vincenz> fons: I am not familiar with quasiquoters
08:48:54 <fons> check them: http://www.eecs.harvard.edu/~mainland/ghc-quasiquoting/
08:48:54 <lambdabot> Title: Quasiquoting Support for GHC
08:49:12 <fons> its similar to what you propose
08:49:26 * vincenz ahs and nods
08:51:17 <fons> with quasuiquotation, it would be something like [$regexp|a*|]
08:51:29 <vincenz> The patterns are neat
08:51:30 <fons> asuuming the quasiquoter is called regexp
08:51:48 <fons> vincenz: wouldn't it be cool to get patterns aorking for regular expressions?
08:51:52 <fons> working*
08:52:11 <vincenz> I do not know why you'd patternmatch on regexps
08:52:20 <mauke> now we just need to link ghc with perl's regex engine
08:52:23 <vincenz> since there's so many ways or represnting the same pattern
08:53:43 <quicksilver> mauke: there is a version linked against libpcre, I believe
08:54:08 <quicksilver> http://www.haskell.org/haskellwiki/Regular_expressions#regex-pcre
08:54:08 <lambdabot> Title: Regular expressions - HaskellWiki
08:54:12 <mauke> not the same thing :(
08:55:58 <vincenz> fons: simple example "aa*" and "a*a"
09:01:36 <fons> vincenz: I really meant something else, but I just figured it is impossible anyway
09:02:53 <vincenz> You coculd potentially pattern-match on the primitives
09:03:01 <vincenz> but then you might as well use the cnostructors
09:03:11 <vincenz> anyways, the quasi-quoters are really neat, thanks for the link
09:03:22 <fons> no problem
09:04:57 <fons> what I really meant is a way to use quasiquoter patterns to match regular expressions against strings and include the matching results in variables from the pattern
09:12:02 <lispy> dons, Cale: Can lambdabot do logging and if so, does she log #darcs?  I would like to start logging that channel and I'm not sure what my options are.
09:12:30 <Beelsebob_> lispy: why not just use a client that can log... like irssi
09:13:30 <lispy> Beelsebob_: actually I am, but I wanted a public log.  I guess I could symlink to my irssi log for darcs
09:13:41 <lispy> Beelsebob_: thanks for the idea
09:15:07 <EvilTerran> what does the logging for #haskell?
09:15:11 <glguy> clog
09:15:34 <EvilTerran> aha
09:15:40 * EvilTerran pokes clog
09:15:58 <glguy> irseekbot used to but it is in time-out
09:18:06 * EvilTerran was under the impression it got banhammered out of principle because they're apparently incapable of asking permission and being up-front
09:18:20 <glguy> what did I say?
09:18:36 <glguy> :)
09:18:39 <EvilTerran> heh
09:19:25 <EvilTerran> I kinda interpreted yours as saying it was previously welcome and might be welcome again in the future. nvm.
09:19:52 <glguy> I should have added a smirk to the end of my message ;)
09:20:02 <EvilTerran> yeah :P
09:20:29 <andyjgill> Has anyone here got GLFW working with OSX? I can get the initial example compiling, but not running.
09:22:31 * lament invokes hcf
09:22:33 <lament> hcf: could you log #darcs? Lispy's asking
09:22:54 <lispy> andyjgill: what is GLFW?
09:23:12 <andyjgill> A OpenGL based framework.
09:23:32 <andyjgill> http://haskell.org/haskellwiki/GLFW
09:26:47 <Jaak> > groupBy (/=) [1,2,3,1]
09:27:00 <lambdabot>  [[1,2,3],[1]]
09:29:13 <ziman> > groupBy (/=) [1,2,3,1,2,3]
09:29:13 <lambdabot>  [[1,2,3],[1,2,3]]
09:29:36 <EvilTerran> > groupBy (/=) [1,1,2,3,3,1,2,3]
09:29:36 <lambdabot>  [[1],[1,2,3,3],[1,2,3]]
09:29:55 <EvilTerran> ... interesting... so the grouping of later elements depends on what the first element is...
09:30:01 <EvilTerran> that's such an abuse of the function
09:30:03 <quicksilver> groupBy doesn't work very well if the op isn't an equivalent relation :)
09:30:11 <ddarius> @src groupBy
09:30:11 <lambdabot> groupBy _  []       =  []
09:30:11 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
09:30:11 <lambdabot>     where (ys,zs) = span (eq x) xs
09:30:15 <quicksilver> I suppose "Very well" is in the eye of the beholder.
09:30:20 <lispy> andyjgill: oh right, you're looking at gui libs
09:30:33 <matthew_-> you know you're in trouble when it compiles when you're not expecting it to...
09:30:34 <quicksilver> But I think the natural semantics for it are based on equiv relations
09:30:38 <andyjgill> Yes, well graphics libs.
09:30:38 <ziman> oh, equivalence
09:30:51 <lispy> andyjgill: I found HOpenGL to be mostly okay.  I have some examples (converted tutorials from C code) if you would find that helpful, BTW
09:31:05 <andyjgill> Sure, if you have pointers.
09:31:25 <EvilTerran> quicksilver, indeed, although implementations have to have the same (or more defined, i think) behaviour than the one given in the report
09:31:28 <lispy> andyjgill: http://projects.codersbase.com/repos/nehe-tuts/
09:31:29 <lambdabot> Title: Index of /repos/nehe-tuts
09:31:37 <EvilTerran> so that trick should be safe, albeit arcane
09:32:04 <lispy> andyjgill: only caveat, is that I wrote this long ago when I had a much weaker understanding of haskell.
09:32:23 <lispy> andyjgill: but the code should server to show you how to transition form regular opengl to HOpenGL
09:32:47 <dons> bringert: yo?
09:32:58 <andyjgill> Sure, thanks. I've found there is limited documentation on the Haskell graphics libs.
09:33:13 <bringert> dons: nothing special, just wanted to check that you got back home safely
09:33:19 <lispy> andyjgill: yes, and HOpenGL documentation that is findable tends to be a version or two behind the real api
09:33:31 <bringert> dons: seeing how I wrote here that everyone did: http://blog.well-typed.com/
09:33:33 <lambdabot> Title: blog.well-typed.com
09:34:40 <quicksilver> andyjgill: I have mostly learnt openGL by studying C examples and exploring types in ghci.
09:34:47 <quicksilver> andyjgill: I find :i and :b to be invaluable :)
09:34:51 <geezusfreeek> andyjgill: i have been using GLFW for a while now
09:34:51 <geezusfreeek> what is your problem?
09:34:51 <geezusfreeek> one thing GLFW is picky about on OS X is that it really wants to be in a .app bundle
09:34:52 <geezusfreeek> if it's not then the window is basically unusable
09:34:56 <geezusfreeek> if you download the GLFW source from the official GLFW site there are examples for OS X
09:34:58 <geezusfreeek> along with a little bundle.sh script that generates a .app bundle for you
09:35:00 <geezusfreeek> then you just have to copy your binary to myApp.app/Contents/MacOS/myApp
09:35:19 <andyjgill> Ah geezusfreeek, I've love a copy of that script.
09:35:24 <quicksilver> you can also use the little stub "macosx-app" taht comes with wxhaskell
09:35:34 <quicksilver> that does something similar
09:36:11 <andyjgill> I've been using that for a bit, but was really hacking rather than following instructions about building.
09:36:13 <dons> bringert: yay :)
09:36:19 <dons> bringert: yeah, got in about 18 hours ago.
09:36:28 <Vulpyne> http://hpaste.org/7011 - I'm having a pretty weird memory leak problem. Anyone have a moment to look at that and tell me if it's something obvious?
09:36:32 <dons> flight was good, no clouds, so got to see greenland, baffin island, etc
09:37:11 <Vulpyne> Basically, it's trying to keep a sliding window of the last 100 packets received and check for duplicates.
09:37:20 <andyjgill> I pulled i the EnableGUI script from WxHaskell, and this let me at least see a screen.
09:37:32 <geezusfreeek> andyjgill: did you get any of my messages a few minutes ago?
09:37:37 <geezusfreeek> i seem to have been disconnected
09:37:51 <andyjgill> Congrats on another successful hackathon!
09:38:02 <dcoutts_> :-)
09:38:07 <dcoutts_> yeah, was really fun
09:38:29 <andyjgill> geezusfreeek: yes, about 5 in a row, about the .app bundle problem.
09:39:18 <geezusfreeek> so i guess that was the wrong problem then? :\
09:39:35 <dons> ibid: can you get the well-typed blog on planet haskell yet?
09:40:23 <andyjgill> I simply dont know! I'm trying lispy's examples to see where I get.
09:40:28 <Vulpyne> :(
09:40:36 <ibid> dons: ask me again in two hours, have to go now :)
09:40:41 <dons> ok :)
09:40:46 <dons> ibid: oh, rwh is fixed now too
09:41:56 <andyjgill> Back at Galois, dons?
09:42:25 <dons> andyjgill: yep.
09:42:49 <mauke> oh, crap. I'm an idiot :/
09:43:03 <andyjgill> dons: I'll catch up with tomorrow when I'm in the office
09:43:13 <ddarius> mauke: A disturbing realization at first, but you get used to it.
09:43:36 <mauke> I wrote an IRC bot with multiserver support for sharing data across multiple networks
09:44:08 <mauke> but I use external data storage anyway, so I could just run multiple processes
09:47:39 <lispy> andyjgill: one thing you won't find in my examples is font rendering.  The next nehe tutorial covers that topic, but I was having a hard time figuring out how to get fonts to work in HOpenGL and never picked up the project after that.
09:48:17 <andyjgill> Sure. There are some OpenGL based frameworks for fonts, I believe.
09:48:55 <Vulpyne> http://hpaste.org/7011 - I'm having a pretty weird memory leak problem. Anyone have a moment to look at that and tell me if it's something obvious?
09:50:26 <andyjgill> geezusfreeek: have you a copy of the script for converting .app for osx graphics?
09:51:00 <geezusfreeek> it is in the source distribution of GLFW from http://glfw.sourceforge.net/
09:51:09 <geezusfreeek> with the examples
09:51:11 <lambdabot> Title: GLFW - An OpenGL Framework
09:51:14 <dons> hackathon on reddit, http://reddit.com/r/programming/info/6g0ae/comments/
09:51:35 <geezusfreeek> man my internet connection is flaky this morning
09:52:19 <sclv> Vulpyne: it looks like you should be looking at checkDups (this is probably obvious)
09:53:26 <andyjgill> Ahh. thanks
09:53:39 <Vulpyne> sclv: Well, I've looked at it, but it's pretty simple. All it does is add an item to the list, and then if the list is >= 100 in length, it drops the first item. So it doesn't seem that it would be possible for the list to grow past that.
09:53:48 <Vulpyne> sclv: Thanks for at least responding, by the way. :)
09:54:36 <Saizan> Vulpyne: you don't use nlv or hasdups before that case?
09:55:34 <Vulpyne> saizen: Before captchaThread and checkDups? Nope. captchaThread is started like: forkIO captchaThread blah S.empty blah blah
09:55:56 <Vulpyne> And captchaThread doesn't do anything with it except pass it along as it recurses, for checkDups' use.
09:56:21 <Saizan> ooh
09:56:43 <quicksilver> Vulpyne: does anything force nlv to be evaluated?
09:56:43 <Saizan> i didn't see that nlv is passed in the recursive case
09:56:53 <quicksilver> Vulpyne: I don't see what does.
09:57:08 <sclv> I worry about weird sharing properties that sequences might have...
09:57:13 <Saizan> you need to put a seq on nlv if nothing is using it
09:57:14 <Vulpyne> saizan: Well, it'll get passed to checkDups in the next recursion which walks the whole list checking for duplicates.
09:57:16 <Vulpyne> So I would think so.
09:57:38 <sclv> hmm -- maybe you should try to "force" length dups with a strictness annotation.
09:58:08 <quicksilver> Vulpyne: no, it doesn't
09:58:11 <Vulpyne> Well, it does print it out if it was =/ 0. Wouldn't that force it?
09:58:13 <quicksilver> Vulpyne: checkDups does nothign at all.
09:58:21 <quicksilver> Vulpyne: remember, lazy evaluation :)
09:58:23 <Vulpyne> Er, /=
09:58:30 <quicksilver> Vulpyne: checkDups becomes the next "nlv"
09:58:33 <quicksilver> but nothing inspects it
09:58:38 <quicksilver> so checkDups doesn't actually get run
09:58:40 <quicksilver> it's just a thunk
09:59:00 <quicksilver> then next time round you get another thunk, with the old thunk embedded.
09:59:13 <quicksilver> hmm. no.
09:59:14 <quicksilver> I lie.
09:59:22 <quicksilver> you do check hasdups == 0
09:59:25 <quicksilver> that will force the tunk
09:59:28 <quicksilver> but only in that case?
09:59:38 <quicksilver> hrm.
09:59:45 <Vulpyne> Hm.
09:59:56 <sclv> you still don't force the other stuff -- (!nlv,!hasdups) (just to be sure)
10:00:00 <Vulpyne> Well, as long as it was able to parse the packet, it'll print out the number of dups it has.
10:00:08 <Vulpyne> (And the case of not being able to parse is very rare.)
10:00:22 <Vulpyne> Which should force the evaluation, no?
10:00:30 <quicksilver> sclv: he does, I think. checking hasdups forces the evaluation of checkDups
10:00:35 <Vulpyne> I'll try with the added strictness though.
10:00:39 <quicksilver> ah
10:00:41 <quicksilver> but not wv
10:00:51 <quicksilver> it doesn't force the evaluation of the actual drop part
10:00:51 <sclv> right.
10:00:54 <quicksilver> hmm
10:00:59 <quicksilver> but that gets forced next time around
10:01:07 <quicksilver> (because toList is called on it)
10:02:09 <Saizan> i'd try with (!nlv,!hasdups) however, just to see if it matters
10:02:10 <dons> > let x@(a,b) = b in (7,9)
10:02:10 <lambdabot>      Occurs check: cannot construct the infinite type: t = (t1, t)
10:02:10 <lambdabot>       Expe...
10:02:12 <dons> Cale?
10:02:37 <dons> whoa.
10:02:39 <ddarius> dons: ?
10:02:46 * dons ponders :)
10:02:56 <quicksilver> > let x@(a,b) = (7,9) in b
10:02:57 <lambdabot>  9
10:03:02 <quicksilver> is that what you meant? :)
10:03:04 <ddarius> :t fix snd
10:03:05 <lambdabot>     Occurs check: cannot construct the infinite type: b = (a, b)
10:03:05 <lambdabot>       Expected type: (a, b) -> (a, b)
10:03:05 <lambdabot>       Inferred type: (a, b) -> b
10:03:09 <dons> my head is back to front :)
10:03:22 <quicksilver> dons is now known as snod
10:03:22 <dons> > let f x@(a,b) = b in f (7,9)
10:03:22 <EvilTerran> so you're a snoc-list?
10:03:22 <lambdabot>  9
10:03:29 <dons> the missing 'f'
10:06:18 <lispy> heh, does snod de-optimize programs?
10:06:23 <andyjgill> geezusfreeek: got the script working, thanks!
10:06:34 <geezusfreeek> andyjgill: np
10:07:48 <hpaste>  quicksilver pasted "usr/local/wxhaskell/bin/macosx-app" at http://hpaste.org/7012
10:08:12 <quicksilver> andyjgill: you might find that interesting in your quest to understand mac os x app bundling :)
10:08:16 * dcoutts_ pre-orders a copy of Real World Haskell from amazon.co.uk
10:08:23 <dcoutts_> bos, dons :-)
10:08:23 <quicksilver> andyjgill: that's what the wxhaskell guys supply to solve the same problem.
10:08:29 <quicksilver> dcoutts_: I was considering doing that
10:08:32 <lispy> dcoutts_: oh, it's available already?
10:08:37 <lispy> I mean, for pre-order
10:08:40 <quicksilver> dcoutts_: but I asked dons which bookseller paid him the most royalties
10:08:40 <dcoutts_> yep
10:08:42 <andyjgill> yes, I was using the wxhaskell solution already.
10:08:46 <quicksilver> dcoutts_: he said he'd check for me :)
10:08:48 <quicksilver> andyjgill: ah, right.
10:08:55 <lispy> can I buy it directly?
10:09:00 <quicksilver> andyjgill: I'll tell you waht I don't understand.
10:09:06 <dcoutts_> quicksilver: oh right, well I've not completed the order yet...
10:09:07 <quicksilver> andyjgill: why plain HOpenGL apps don't need this.
10:09:14 <lispy> Cut out the bookseller?  (This reminds me of buying albums from the artist)
10:09:16 <dcoutts_> bos: any idea?
10:09:26 <andyjgill> Err, dcoutts_, you have to finished the book *before* it gets published...
10:09:31 <gwern> heh. so I have a build script for darcs/cabalized packages; one of the steps is to do a darcs pull and if it fails, clean up the mess darcs leaves behind
10:09:32 <quicksilver> andyjgill: they run fine under macosx, get their own "application" layer and everything.
10:09:34 <sclv> out of the back of a station wagon on a cross country tour?
10:09:43 <Vulpyne> Adding the strictness annotations seems to have fixed it.
10:09:45 <dons> dcoutts_: heh :)
10:09:46 <dcoutts_> andyjgill: that's so Web 1.0, get with the times!
10:09:46 <andyjgill> You cant just buy a copy to see how it ends.
10:09:47 <gwern> any guesses as to what the cleanup command was and why it recently cost me an hour or so of work? :)
10:10:00 <Vulpyne> That's weird, because I would have thought that printing out the result would have forced evaluation.
10:10:25 <Vulpyne> Although, in the case of no duplicate, it may not have.
10:10:26 <bos> dcoutts_: hm?
10:10:37 <dcoutts_> bos: preferred book reseller for RWH?
10:10:49 * gwern supplies the answer: 'rm darcs*'
10:10:59 <lispy> gwern: oof
10:11:01 <dcoutts_> bos: ie do you get more from someone other than amazon or should I pre-order through them?
10:11:04 <bos> oh. no idea, sorry.
10:11:12 <dons> we could find out, I suspect
10:11:17 <gwern> because failed darcs pulls result in stuff like 'darcsG133GHK', that was the shell glob I came up with....
10:11:21 <andyjgill> quicksilver: I dont know why, sorry
10:11:21 <Vulpyne> Thanks for the help.
10:11:35 <dcoutts_> dons, bos: do, I want to link to something in a blog post
10:11:35 <quicksilver> andyjgill: I didn't really think you would. Just sharing my mystification with you.
10:11:45 <quicksilver> andyjgill: if you gain enlightenment later, though let me know :)
10:12:00 <bos> dcoutts_: if you like :-)
10:12:00 <dons> its great to see so much interest :)  i think we jumped up a few slots on the book rankings
10:12:01 <andyjgill> Sure. It seems a generic problem with graphic issues on macox
10:12:10 <dons> we were #54 in 'software dev' books last i looked
10:12:14 <dons> which is pretty cool
10:12:20 <byorgey> awesome!
10:12:21 <gwern> lispy: you can see why I was recently baffled when my carefully constructed, un-checkedin 'darcs.cabal' file disapeared... I had totally forgotten about that shell glob
10:12:31 <quicksilver> andyjgill: I suspect that HOpenGL must link against a C library stub which fixes this stuff.
10:12:35 <quicksilver> but that's guesswork.
10:12:36 <sclv> right: preordering from amazon is probably best for the hype factor if nothing else.
10:13:18 <andyjgill> But HOpenGL is used by the GLUT and GLFW libs?
10:13:30 <andyjgill> Does anyone know which is better supported, GLUT or GLFW?
10:13:58 <quicksilver> GLUT is well supported but very simple.
10:14:02 <quicksilver> GLFW does other stuff.
10:14:03 * gwern notes I've seen more stuff using GLUT than GLFW, fwiw
10:14:23 <quicksilver> sclv: yes, I was going to reorder just to hope to contribute some hype :)
10:14:46 <quicksilver> Vulpyne: I think it's odd. I would expect the if hasdups == 0 to force everything at most one iteration late.
10:14:47 * Baughn notes that GLUT is a tentacled horror by design
10:14:53 <quicksilver> Vulpyne: just looking over the code again.
10:15:09 <quicksilver> Baughn: most of the tentacles are hidden behind nice haskell types, though, in haskell GLUT.
10:15:13 <quicksilver> it's really not that bad.
10:15:29 <Baughn> quicksilver: There is no way to hide the designed-in global variables
10:15:55 <Vulpyne> quick: Yeah, I was pretty mystified.
10:16:11 <quicksilver> Baughn: well, there are ways actually. Although the haskell glut doesn't use them.
10:16:17 <quicksilver> I don't find the state machine abhorrent though.
10:16:22 <quicksilver> it's a good model for a graphics card.
10:16:27 <Vulpyne> quicksilver: Well, it's a fairly large, complicated program using threads and foreign libraries, there may have been some unusual interaction going on or whatever.
10:16:35 <quicksilver> preservingMatrix and translate are quite elegant.
10:16:37 <n00b> hey there guys i am writing a coordinate function that take 1 coordinate from a file them drop1 and write back the file (basically i am creating a find next function)
10:16:40 <Baughn> quicksilver: Sure. *One* graphics card, in a single-user environment.
10:16:40 <Vulpyne> The tchan message it receives is sent from a callback from the C pcap library.
10:16:47 <andyjgill> I'll give GLUT a go then, it sounds like.
10:16:47 <n00b> it doesn't seem to work
10:16:55 <n00b> gonna post the code
10:18:03 <dons> andyjgill: bytestring is now much much better tested, after the hackathon,
10:18:05 <dons>    http://galois.com/~dons/hpc_index_fun.html
10:18:07 <edwardk> hrmm, is there a haskell SDL binding out there? SDL + OpenGL always struck me as a 'better' way than limiting yourself to what GLUT supports out of the box, but maybe i just am biased.
10:18:31 <dons> andyjgill: and i found some bugs in the testsuite, thanks to hpc.
10:18:32 <Baughn> edwardk: Yes
10:18:43 <dcoutts_> andyjgill: and Gtk2Hs supports OpenGL widgets embedded in a Gtk GUI
10:19:08 <dcoutts_> dons: those figures do look pretty good now
10:19:11 * edwardk is just annoyed and waiting for the OpenGL Longs Peak stuff to actually materialize. i put a project on hold back in september waiting for a version that never came out.
10:19:19 <Baughn> edwardk: And yes, it supports opengl. The package's just called SDL.
10:19:36 <edwardk> er actually i put the kibosh on the project in july even
10:19:37 <edwardk> Baughn: nice
10:19:45 <dons> dcoutts_: yeah, i think i can get 100% top level coverage now
10:19:45 <dons> will need some custom strategies for the Chunk/newlines stuff in lazy
10:19:47 <dons> but otherwise fairly straight forward
10:19:55 <dons> should help with long term maintainence
10:19:55 <Baughn> edwardk: Do you really think OGL 3 will be /usable/ immediately after being released?
10:20:06 <dcoutts_> dons: turning the chunk size down to something small would help there
10:20:18 <dons> dcoutts_: yeah, that's one thing.
10:20:25 <dons> pity that's not really tunable at runtime
10:20:27 <sethk> edwardk, is anything complex ever immediately usable?
10:20:30 <edwardk> Baughn: no, but i figured that a version of opengl with inherently immutable card-side objects would be a much better fit to haskell than opengl 2's imperative salad.
10:20:34 <dons> we did find bugs in the past by settign size 1
10:21:07 <Baughn> edwardk: That is probably true, yes. I'm looking forward to it, but I wouldn't put anything on hold for it.
10:21:32 <edwardk> and i'd written enough 'old school' opengl over the last egads almost 15 years now?! that i never want to do it again
10:21:37 <mrd> would you say that the "imperative salad" got tossed?
10:22:02 <andyjgill> dons: looks good!
10:22:05 <conal> andyjgill: is glfw going to work out for you?
10:22:35 <andyjgill> I got glfw working, with help, but I am going to lot a glut next.
10:22:41 <andyjgill> lot=>look
10:22:45 <edwardk> Baughn: well, i was talking to a couple of guys who were involved in its construction and they said that it may be lifting some framebuffer/texture size limitations that for various reasons i need.
10:22:50 <dons> andyjgill: so its 3500 lines of Haskell, and 1500 lines of QuickCheck
10:23:02 <edwardk> Baughn: so there were other technical issues involved
10:23:10 <edwardk> not just syntactic ;)
10:23:31 <andyjgill> dons: any bugs found because of hpc testing?
10:23:39 <gwern> @seen dcoutts_
10:23:39 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #ghc and #haskell. I last heard dcoutts_ speak 3m 33s ago.
10:23:44 <dons> andyjgill: none in the library so far, but in the properties code, yes.
10:23:45 <gwern> oh. heh.
10:23:48 <dons> where i was testing the wrong function
10:23:55 <dons> or assuming i'd tested something, but hadn't
10:23:57 <andyjgill> Ahh. can you say more.
10:23:57 <conal> andyjgill: oh, okay.  there's also the question of GUI: e.g., wxhaskell, Gtk2Hs, or a 3D replacement.
10:24:02 <gwern> dcoutts_: hey, is there any documentation on how cabal works with buildinfo files?
10:24:12 <edwardk> they went silent before september though, and i haven't heard anything out of khronos or any of those groups since.
10:24:18 <dons> so there's a list of tests, and due to copy and paste, some things were calling the wrong functions to test
10:24:30 <dons> prop_foo = ... bar  ...  instead of 'foo'
10:24:38 <dons> so the test would pass, but its testing the wrong thing
10:24:41 <dons> hpc spots that nicely
10:24:48 <dons> as 'foo' shows up as untested
10:24:54 <conal> andyjgill: wxhaskell & Gtk2Hs both work with opengl, but they bring a lot of standard 2D OO imperative gui baggage with them
10:24:54 <andyjgill> Great!
10:24:54 <dons> there were half a dozen of those
10:25:07 <edwardk> i wonder if it wound up stillborn because they punted issues of things like curved surfaces etc which were more contentious, and when they had to push back the standard i think those issues tried to feature creep in and consensus broke down, etc.
10:25:15 <dons> it also highlighted some rather suspicious code in one function, that i ended up replacing
10:25:19 <dons> since i couldn't work out the logic
10:25:48 <dons> andyjgill: also, have a look at http://galois.com/~dons/Data.ByteString.Lazy.Char8.hs.html 'readInteger' near the bottom of the page
10:25:52 <dcoutts_> gwern: not a lot, if you use a custom setup.hs or the configure build type then it reads the .buildinfo file and combines it with the package configuration
10:25:59 <dons> hpc is revealing just how inadequeate the current test is for the read function
10:26:10 <conal> andyjgill: i'm interested in revisiting the Fruit work (http://www.apocalypse.org/pub/u/antony/work/pubs/genuinely-functional-guis.pdf) in a 3D GUI setting.
10:26:11 <lambdabot> http://tinyurl.com/296be3
10:26:13 <dcoutts_> gwern: there are api functions for writing .buildinfo files from Setup.hs scripts
10:26:14 <andyjgill> Ohh, painful.
10:26:23 <gwern> dcoutts_: I see. so it would not be read if the build-type were Simple?
10:26:26 <geezusfreeek> hey conal!
10:26:28 <dcoutts_> gwern: correct
10:26:36 <conal> geezusfreeek: hi!  how's it going?
10:26:37 <dons> andyjgill: one thing also was i had to work out how to enable asserts with -O on
10:26:42 <geezusfreeek> excellent
10:26:47 <dons> normally they're compiled away, meaning the asserts go untested
10:26:52 <dons> but hpc doesn't let me get away with that :)
10:26:58 <dcoutts_> gwern: at least I think so, anyway with Simple there would be no code to write the .buildinfo
10:27:06 <gwern> (bleh. I could've figured that out for myself if darcs wasn't such a slow compile)
10:27:11 <geezusfreeek> getting a lot of functionality in my reactive stuff now, and a decent start on the game libs
10:27:13 <dons> -fno-ignore-asserts reenables them
10:27:13 <quicksilver> edwardk: I'm not convinced that an appalling "object oriented" mess will be an improvement on a nice simple state machine.
10:27:17 <quicksilver> edwardk: we'll see
10:27:44 <edwardk> quicksilver: nor am i. i just want to be able to work with something that i don't have to go through a ton of extensions to get at what is now effectively core functionality.
10:27:55 <gwern> dcoutts_: strangely, I think configure was still getting run with Build-type: Simple
10:28:44 <geezusfreeek> sometime today, i expect, i will have an example identical to the GLFW example on the wiki except using my game+reactive lib
10:28:46 <edwardk> quicksilver: working in opengl pisses me off these days, direct3d has become a so much more straightforward api while opengl pretty much froze.
10:28:51 <andyjgill> conal: I think either glut or glfw would work fine as a base.
10:28:52 <dcoutts_> gwern: only if you were running a Setup.hs directly that was using defaulMainWithHooks defaultHooks
10:29:12 <dcoutts_> gwern: because defaulMainWithHooks defaultHooks /= defaulMain  (doh!!)
10:29:12 <quicksilver> edwardk: true. But Haskell makes it extremely easy to abstract over cumbersome interfaces.
10:29:23 <geezusfreeek> right now i just have a line going from the upper left hand corner to wherever the mouse is at the moment
10:29:23 <znutar> gl 3.0 seems to be a lot closer to the interface the graphics chips present to the driver than 2.x is from what I've seen
10:29:23 <quicksilver> edwardk: so you can program with extensions as if they were core and not worry too much :)
10:29:28 <gwern> dcoutts_: yup, that's it
10:29:31 <geezusfreeek> anyway, time to go to work. i will be back here once i get there
10:30:12 <conal> andyjgill: the glfw page says it is "a single library providing a powerful, portable API for otherwise operating system specific tasks such as opening an OpenGL window, and reading keyboard, time, mouse and joystick input."
10:30:32 <conal> does GLUT do these extras?
10:30:40 <geezusfreeek> conal: GLUT does way more than GLFW
10:30:54 <edwardk> quicksilver: the thing is, you still have to remember what way is the 'fast path' for what real world hardware to make viable opengl code. the one thing i LIKE about opengl 3 is the spec calls for it to either be "on the fast path" or for it to reject you. if nothing else that will make my life easier in some ways.
10:31:01 <geezusfreeek> conal: but GLUT runs its own event loop, which doesn't work out well for my purposes
10:31:21 <zgold> Does anybody have any experience using the Network module?
10:31:35 <geezusfreeek> i was really wanting to try with SDL but i couldn't get it to compile
10:31:42 <geezusfreeek> at some point in the future i might switch though
10:31:43 <conal> geezusfreeek: what sort of thing does GLUT do beyone GLFW?
10:31:49 <MyCatVerbs> zgold: sure. What do you need?
10:31:53 <conal> geezusfreeek: me to (with SDL)
10:32:06 <zgold> MyCatVerbs: How can i make a PortID (Using Network.Socket.PortNum # doesn't seem right)
10:32:14 <geezusfreeek> conal: it has all kinds of nice helpers for opengl itself, like shape primitives, projection functions, etc.
10:32:21 <dons> andyjgill: hpc encourages testing of instance declarations, too, fwiw.
10:32:33 <dons> something that's not a common thing to test.
10:32:33 <edwardk> quicksilver: the disparity between the speed of the fast path and everything else has grown to the point where rejection is the better option. =)
10:32:37 <geezusfreeek> on top of excellent support for I/O devices
10:32:38 <conal> geezusfreeek: thx.  does it *impose* an event loop?
10:32:40 <andyjgill> This was one thing I noticed when I starting using hpc, also.
10:32:50 <conal> geezusfreeek: i/o devices?
10:33:16 <geezusfreeek> i was about to clarify that GLFW, so far, has not seemed very limited as far as input devices does either, but i am less familiar with it
10:33:26 <MyCatVerbs> zgold: PortNumber . fromInteger
10:33:32 <geezusfreeek> conal: GLUT imposes the event loop
10:33:40 <geezusfreeek> conal: at least, i could not find a way to run my own
10:34:05 <conal> geezusfreeek: bummer.  how does it get in your way?  do you have another lib that also wants to be on top?
10:34:19 <conal> geezusfreeek: e.g., a gui lib?
10:34:21 <zgold> MyCatVerbs: thanks!  Will try that
10:34:36 <edwardk> i have found that most real applications outgrow GLUT pretty quickly
10:34:41 <MyCatVerbs> zgold: fromInteger converts an integer to a PortNumber, 'cuz PortNumber is a Num instance. http://www.haskell.org/ghc/docs/6.8.2/html/libraries/network/Network.html#t%3APortNumber
10:34:42 <lambdabot> http://tinyurl.com/55cl8d
10:34:54 <edwardk> but its useful for teaching intro graphics courses, etc.
10:34:56 <MyCatVerbs> zgold: then just slap the PortNumber constructor on the front and you're good to go. No worries.
10:35:10 <dcoutts_> conal: btw, gtk lets you run its event loop and then of course one can always use threads
10:35:12 <conal> edwardk: is glut an all-or-nothing deal?
10:35:12 <geezusfreeek> conal: i just wanted to be able to control when events are sunk into the reactive code instead of relying on callbacks (and having to change the callbacks every time they are called to reflect new global state)
10:35:20 <zgold> Ah right!  Totally didn't see that it derived num, im silly
10:35:58 <MyCatVerbs> zgold: :i DataType in ghci is your friend. Well, it's my friend, and I believe it's friendly enough that it'll want to play nicely with you, too.
10:36:13 <MyCatVerbs> zgold: lists all the instances for a particular type, amongst other things.
10:36:19 <geezusfreeek> alright off to work
10:37:06 <edwardk> conal: iirc there are some rendering things in glut (like generating torii or teapots) that aren't tied to it having complete control, but i've never used them outside of a glut application.
10:37:44 <mauke> whee, (\f -> f . map S.pack . channels $ config) . fix $ \self chans ->
10:39:53 <edwardk> conal: in practice you generally don't want to just do graphics. you want to do graphics and sound and ... sure you can typically do these things by talking to other threads etc. but it gets trickier to keep letting glut do your pumping when you switch platforms and want to do anything that 'feels' native.
10:40:23 <conal> edwardk: thanks.  glad to know.  so do you end up dropping down to plain-old-opengl?
10:40:42 <znutar> glut basically is only good for small things, by design.
10:41:14 <Baughn> glut is basically broken by design. You could use it to get an opengl context, but you'd be better off using something like sdl for that purpose
10:41:17 <zgold> MyCatVerbs: worked perfectly
10:41:22 <edwardk> more or less. its been a long time since i did a lot of opengl development, but i think the modern version would be to use something like SDL that has hooks into these other kinds of lbraries and is designed for consistent use.
10:41:49 <edwardk> then call into opengl directly or through its abstraction layer for it
10:42:53 <znutar> It's not so much broken as hard to work with.  It's like havign a morbidly obese person sitting next to you on the plane.  Not too bad for a short flight, but it wears on you before long
10:43:03 <edwardk> znutar: heh
10:43:33 <lament> a glutton, presumably
10:43:34 <Baughn> A morbidly obese person, who stutters, who's also the only way you can talk to the waitress
10:44:00 * Baughn has been victimized by glut in the past. Could you tell?
10:44:24 * mrd used gtkglext with gtk2hs with much success
10:44:28 <MyCatVerbs> zgold: spiffy! ^^
10:44:46 <dcoutts_> mrd: what was that for btw?
10:44:55 <mrd> my own amusement really.  i made a bunch of demos.
10:45:39 <edwardk> baughn: heh. i've just sat and watched people consistently paint themselves into a corner with it and then have to start over under a different framework
10:45:44 <dcoutts_> mrd: any you'd like to add to the gtk2hs demo collection?
10:45:53 <mrd> now, of course, I used to use SDL/OpenGL prior to haskell
10:46:12 <mrd> dcoutts_: I will see if any are clean enough for that.  it's all at home though.
10:46:26 <lament> opengl is hard
10:46:27 <lament> :(
10:46:38 <dcoutts_> mrd: our current gtk2hs/opengl demos are not very inspiring. I have a more impressive one but I use it for practicals so I can't really give out the source.
10:46:42 <edwardk> SDL came along after i had pretty much stopped doing a lot of opengl development
10:47:23 <EvilTerran> lament, let's go shopping!
10:47:50 <edwardk> i remember a good chunk of my dev time back then going into making something stable that could run consistently across opengl/direct3d and (ack!) glide. =)
10:47:54 <mrd> yeah, i really like gtk2hs, i just don't have any projects for it atm
10:48:26 <mrd> well that's not quite true. i was writing an editor with gtksourceview.
10:48:34 <paczesiowa> dcoutts_: did you get my msg about gtk2hs bug?
10:48:40 <mrd> but i'm trying to stay away from typing too much lately.
10:49:14 <lament> yay an editor
10:49:37 <dcoutts_> paczesiowa: not sure, I've been at the hackathon so not really checking my mail much
10:49:40 <dcoutts_> what bug was it?
10:50:26 <paczesiowa> dcoutts_: lambdabot was supposed to tell the other dcoutts, I didn't send an email:>
10:50:39 <paczesiowa> dcoutts_: http://hpaste.org/7000
10:51:11 <dcoutts_> heh
10:51:30 <pejo> dcoutts, what did you guys get done during the hackathon?
10:51:48 <dcoutts_> pejo: see blog.well-typed.com
10:52:02 <dcoutts_> paczesiowa: looks like a dll path problem
10:52:12 <dcoutts_> paczesiowa: presumably ghci -package gtk does not work either?
10:53:27 <paczesiowa> dcoutts_: other gtk apps work. I'll fire up vmware and check that ghci -package gtk
10:53:57 <dcoutts_> paczesiowa: most gtk apps on windows bundle their own copy of gtk
10:54:20 <dcoutts_> it's harder for gtk2hs because you expect to be able to generate a .exe in any dir and have it work
10:54:31 <paczesiowa> dcoutts_: I mean gtk2hs apps
10:54:43 <dcoutts_> where as most apps get to install their dlls in one specific application subdir
10:55:18 <pejo> dcoutts, sweet!
10:55:34 <Taejo> if anyone's interested, http://code.google.com/codejam/ (programming competition) is about to start
10:55:35 <lambdabot> Title: Google Code Jam
10:55:45 <dcoutts_> pejo: aye, it was pretty fun :-)
10:56:01 <dcoutts_> I should write a bit more about what I was working on at the hackathon
10:56:18 <paczesiowa> dcoutts_: ghci -package gtk works
10:56:36 <dcoutts_> paczesiowa: and the other hs-plugins thing still does not work?
10:56:56 <paczesiowa> dcoutts_: what other thing?
10:56:59 <dcoutts_> paczesiowa: if ghci -package gtk works then it should be ok
10:57:10 <dcoutts_> paczesiowa: your designer.exe error
10:57:28 <dcoutts_> which is using hs-plugins right?
10:57:36 <paczesiowa> I don't think so
10:57:53 <dcoutts_> well if it was an ordinary gtk2hs app you'd not get that error
10:57:58 <paczesiowa> I do load module which depends on gtk, but main app has gtk code too so it should be loaded already
10:58:11 <dcoutts_> you'd get an error from the OS saying it cannot find the dll, not a runtime error
10:58:22 <dcoutts_> you said you're using hs-plugins-1.2
10:58:44 <dcoutts_> paczesiowa: it sounds to me like a hs-plugins problem
10:58:55 <gwern> dcoutts_: is there a difference between 'extra-libraries: "X11"' and 'extra-libraries: X11'? no, right?
10:59:05 <dcoutts_> I figure I'm doing my job if ghci -package gtk works :-)
10:59:30 <dcoutts_> gwern: no difference I think, though I'd have to check to be sure
10:59:47 <paczesiowa> maybe we should blame windows
11:00:24 <dcoutts_> paczesiowa: I would blame hs-plugins
11:00:34 <paczesiowa> but it works on linux:/
11:00:35 * gwern suggests blaming Canada
11:00:37 <lament> hee @ "The meaning of fmap on behaviors mimics fmap on the meaning of behaviors"
11:00:54 <dcoutts_> paczesiowa: shared libs are totally different on windows vs linux
11:02:00 <paczesiowa> dcoutts_: btw why doesn't gtk2hs work with ghc-6.8.2 ?
11:02:27 <dcoutts_> paczesiowa: because ghc is not binary compatible between versions
11:02:42 <dcoutts_> everything you build with ghc-6.8.1 has to be rebuilt if you want to use it with ghc-6.8.2
11:02:53 <dcoutts_> I do have a gtk2hs build for ghc-6.8.2 as it happens
11:03:32 <dcoutts_> paczesiowa: http://haskell.org/~duncan/gtk2hs/gtk2hs-0.9.12.1.exe
11:05:01 <Baughn> http://brage.info/~svein/end.png <-- fix unsafePerformIO, I imagine
11:05:25 <zgold> MyCatVerbs: Wow, this is... surprisingly easy :)  Going well thus far, thanks for your help!
11:06:33 <paczesiowa> dcoutts_: so the problem is rebuilding installer with every release?
11:07:00 <MyCatVerbs> zgold: no worries.
11:07:00 <dcoutts_> paczesiowa: right, rebuilding gtk2hs and the installer
11:07:38 <n00b> hey guys here is my find function, it is not working as it should
11:07:38 <dcoutts_> it's not a huge amount of work, but it does take some time and I only have access to a windows machine occasionally
11:08:45 <hpaste>  n00b pasted "rep$" at http://hpaste.org/7013
11:09:00 <n00b> please look at it please
11:09:48 <paczesiowa> dcoutts_: you were right, I forgot I do initial load at the beginning (without any reload button click) and it fails on first "load_ obj"
11:10:08 <n00b> i should be producing a new list of the word entered is not in the old
11:10:10 <paczesiowa> dcoutts_: so I should bother dons then, right?
11:10:18 <n00b> it's not working as it should
11:10:35 <dcoutts_> paczesiowa: not sure if dons supports hs-plugins anymore, you can ask him if anyone does.
11:10:39 <hpaste>  gwern pasted "assorted darcs CPP problems" at http://hpaste.org/7014
11:11:00 * dcoutts_ heads home
11:11:07 <gwern> dcoutts_: buildinfo still isn't working for me :( I thought I had everything right; you can take a look?
11:11:18 <dcoutts_> gwern: if it's really quick
11:11:35 <gwern> I suspect I simply made a stupid mistake somewhere
11:11:38 <paczesiowa> dons: are you still hs-plugins maintainer?
11:11:40 <gwern> http://hpaste.org/7014
11:12:18 <paczesiowa> dcoutts_: thanks for help
11:12:41 <dcoutts_> gwern: what does your Setup.hs say?
11:12:46 <lispy> gwern: hmm...is libcurl part of darcs+
11:12:49 <dons> paczesiowa: somewhat.
11:13:01 <dons> i'm deprecating hs-plugins in favour of the vapourware ghc-api version
11:13:02 <Gilly> does hs-plugins have a homepage? there's this http://www.cse.unsw.edu.au/~dons/hs-plugins/ but in bottom it says last updated in 2005
11:13:04 <lambdabot> Title: hs-pluginsDynamically Loaded Haskell Modules
11:13:11 <lispy> dons: heh
11:13:15 <paczesiowa> dons: what is the status of windows version?
11:13:41 <dons> Gilly: that's the page. its more active than that though. see hackage.haskell.org for version 1.2
11:13:42 <gwern> lispy: no, it's kind of like hscurl.c imports curl the C library and adds some wrapper functions, and then URL.hs does an FFI to hscurl.c using hscurl.h
11:13:57 <dons> paczesiowa: it worked for 1.0, but something changed recently
11:14:01 <dons> so its currently broken, iric
11:14:13 <dcoutts_> gwern: did you paste the Setup.hs too?
11:14:26 <gwern> dcoutts_: no
11:14:35 <paczesiowa> dons: how about that ghc-api? which modules should I study?
11:14:39 <dcoutts_> gwern: and I presume you're building using runghc Setup.hs
11:14:51 <hpaste>  gwern annotated "assorted darcs CPP problems" with "setup.lhs" at http://hpaste.org/7014#a1
11:14:51 <Gilly> dons: interestingly at the same time i'm looking at this you start talking about ghc-api :) should i go for that instead?
11:14:53 <dcoutts_> rather than cabal-install
11:14:59 <vincenz> gwern: how do you get the time on the right?
11:15:05 <dons> Gilly: what do you need to do?
11:15:20 <dons> so hs-plugins has a package and .hi file parser, that often breaks when ghc changes
11:15:25 <dons> if we reuse ghc-api, then that won't happen.
11:15:33 <gwern> vincenz: it's some zsh feature
11:15:36 <dons> essentially, we reuse as much of ghc as we can, and give an hs-plugins api over the top
11:15:40 <dcoutts_> gwern: that should work, I don't see anything obviously wrong
11:15:41 <Gilly> dons: i'd like to be able to write haskell scripts that are loaded and run by another haskell program
11:15:43 <dons> that'll be maintainable in the long term
11:15:47 <gwern> dc-Ankan: runhaskell Setup configure -p --enable-split-objs --verbose=2 --user --prefix=$HOME/bin, actually
11:15:52 <gwern> er. dcoutts_
11:15:56 <dons> Gilly: as bytecode, or compiled?
11:16:18 <Gilly> preferably the user gets to write them as .hs and after that it doesn't matter how it internally works
11:16:35 <dons> yeah, so bytecode is likely an option there (and faster)
11:16:37 <Gilly> of course if we wouldn't need whole ghc installed it could be cool but i guess it might not be possible
11:16:44 <dons> yi used an interface to ghc-api to make this possilbe
11:17:40 <gwern> dcoutts_: you don't see any problems? oh dear. asking you was sort of my plan B
11:17:47 * gwern wonders why the heck it works for x11 then
11:17:55 <Gilly> ok... but it will still have to compile those and for that it will use what? an external executable or is whole ghc planted into my app?
11:18:13 <paczesiowa> dons: when should this new backend work? (just curiosity, hs-plugins work on linux, but I like my code to be portable)
11:18:21 <dons> well, it would use ghc-api, which takes a .hs string, and gives you back a bytecode object
11:18:31 <dons> paczesiowa: when someone works on it :)
11:19:22 <dcoutts_> gwern: yeah, using defaultUserHooks (or autoconfUserHooks) makes it read the .buildinfo on all other actions
11:19:32 <Gilly> okies, thanks - i'll look at it :)
11:19:51 <dcoutts_> gwern: you should get a message when you build that says "Reading parameters from " ...
11:19:59 <conal> dons: as far as you know, is there still no abstract syntax interface to ghc-api?  apps have to unparse to have ghc-api reparse?
11:20:00 <dcoutts_> at -v2 level
11:20:17 <paczesiowa> we definitely need more donses
11:20:38 <dcoutts_> conal: there's a GSoC project to improve the ghc api
11:20:53 <gwern> dcoutts_: I'll paste a build, but I don't see it
11:21:06 <hpaste>  gwern annotated "assorted darcs CPP problems" with "build" at http://hpaste.org/7014#a2
11:21:10 <EvilTerran> is a dons cell immutable? if so, you could make as many copies as you like without fear of side-effects...
11:21:19 <gwern> dcoutts_: this reading would be at the start of runhaskell Build?
11:21:34 <conal> dcoutts_: wow.  that's wonderful.  do you know of a feature wish list?
11:21:35 <gwern> EvilTerran: no, they have shared access to mutable resources like darcs repos
11:21:46 <dcoutts_> gwern: build -v2
11:21:52 <dcoutts_> or maybe -v3
11:22:10 <n00b> is there anyone who can help me, plzzz
11:22:10 <EvilTerran> gwern, huh, okay. i'm sure we can sort something out with STM, regardless.
11:22:19 <vincenz> gwern: just put them in STM-transactions so you can do speculative multi-dons'ing
11:22:31 * vincenz beeps EvilTerran 
11:22:31 <gwern> ah
11:22:36 <EvilTerran> ?quote meta-ask
11:22:36 <lambdabot> meta-ask says: don't ask to ask, just ask!
11:22:48 <dcoutts_> conal: there was a draft on the Haskell SoC wiki and the full thing should be published soon when the proposal acceptance phase is over
11:22:49 <hpaste>  gwern annotated "assorted darcs CPP problems" with "-v2" at http://hpaste.org/7014#a3
11:23:06 <gwern> dcoutts_: hum. so it does seem to be read
11:23:20 <dcoutts_> conal: I'm sure the student who gets it will also be keen to listen to what people want in the api
11:23:21 <ziman> this also means `don't ask to ask to ask, just ask to ask' :)
11:23:44 <dcoutts_> conal: so remember to ask Qs when we know for sure who's going to be doing that project
11:23:48 <quicksilver> edwardk: yes, I confess to not understand enough about the fast-path stuff
11:24:08 <quicksilver> edwardk: I just try stuff until it works and I daresay I'm using all kinds of calls which my card doesn't actually optimise ;)
11:24:16 <conal> dcoutts_: thanks for the suggestion.  will there be an announcement on the haskell list?
11:24:21 <dcoutts_> conal: I'm sure
11:24:55 <dcoutts_> gwern: oh good, and the cpp'ing is being done with -DHAVE_CURL ?
11:25:18 <dcoutts_> gwern: oh, I bet I know what it is
11:25:28 <dcoutts_> it's the library vs the executable
11:25:44 <dcoutts_> the .buildinfo file has the info for all the libs and the exes in the package
11:25:52 <gwern> dcoutts_: presumably if the cpp'ing were really being done with -DHAVE_CURL, the final binary would not be giving the error messages which correspond to JAVE_VURL *not* being defined
11:25:56 <edwardk> quicksilver: the stuff i have right now works if its on the fast path, if its not it brings my 8800 GTS to its knees ;)
11:26:04 <gwern> dcoutts_: hm?
11:26:19 <dcoutts_> but the syntax is confusing and I suspect you're just setting the flags for the library section, not the exe
11:26:27 <n00b> n00b pasted "rep$" at http://hpaste.org/7013
11:26:44 <n00b> help with my func ?
11:27:07 <sjanssen> gwern: the build output is cut off before Cabal starts compiling the Haskell files
11:27:16 <dcoutts_> gwern: see writeHookedBuildInfo, it takes a lib and several exes, see what output it produces when you set flags for the exe not the lib
11:27:25 <gwern> sjanssen: well, it's a lot of output, and takes a while
11:27:50 <geezusfreeek> n00b, what is the problem with it?
11:27:56 <dcoutts_> gwern: it's something like it uses a blank line to separate lib from exe from the following exe etc, not nice (I didn't write it :-) )
11:27:57 <sjanssen> gwern: we just need to see the first few GHC lines that actually have *.hs in them
11:28:04 <gwern> @hoogle writeHookedBuildInfo
11:28:10 <lambdabot> Distribution.PackageDescription.writeHookedBuildInfo :: FilePath -> HookedBuildInfo -> IO ()
11:28:21 <dcoutts_> @hoogle HookedBuildInfo
11:28:22 <lambdabot> Distribution.PackageDescription.HookedBuildInfo :: type HookedBuildInfo
11:28:22 <lambdabot> Distribution.PackageDescription.emptyHookedBuildInfo :: HookedBuildInfo
11:28:22 <lambdabot> Distribution.PackageDescription.readHookedBuildInfo :: Verbosity -> FilePath -> IO HookedBuildInfo
11:28:26 <dcoutts_> bah
11:28:43 <dcoutts_> type HookedBuildInfo = (Maybe BuildInfo, [(String, BuildInfo)])
11:29:18 <gwern> dcoutts_: I don't quite follow, so I need additional fields in darcs.cabal?
11:29:27 <dcoutts_> gwern: I suspect you need executable: darcs at the top
11:29:47 <hpaste>  gwern annotated "assorted darcs CPP problems" with "full build, sjansen" at http://hpaste.org/7014#a4
11:29:58 <dcoutts_> the top anonymous section is for the lib, exe sections have to be named it seems
11:30:13 <hpaste>  gwern annotated "assorted darcs CPP problems" with "full cabal as well" at http://hpaste.org/7014#a5
11:30:14 <dcoutts_> gwern: hope that helps, I'm off now
11:30:49 <gwern> dcoutts_: not really, I already have an executable: darcs
11:30:59 <edwardk> gotta run
11:31:21 <dcoutts_> gwern: in the .buildinfo ?
11:31:35 <gwern> dcoutts_: oh. no.
11:31:39 * gwern will try that
11:34:40 <gwern> '[132 of 132] Compiling Main             ( src/darcs.lhs, dist/build/darcs/darcs-tmp/Main.o )
11:34:40 <gwern> Linking dist/build/darcs/darcs ...
11:34:45 <gwern> Pulling from "http://darcs.net"...
11:34:46 <gwern> dcoutts_: I guess that was it
11:34:50 <gwern> This is the darcs darcs repository.
11:34:50 <gwern> yay
11:35:36 * gwern is learning so many obscure corners of cabal
11:35:58 <sjanssen> gwern: you shouldn't have extra-libraries: curl in the .cabal file, since it's a conditional dependency
11:36:20 <gwern> indeed
11:44:35 <gwern> 'People hacked on lots of projects, including Yi, Cabal, ByteString, a new web application interface, QuickCheck, CGI, first-order logic reasoning, Allegro bindings, Haddock, the community server, HAppS-HSP, replacing libgmp in GHC, Squiggle, restricted monads, and more.' <-- ? Was there a problem with libgmp?
11:45:03 <saml> I have a function toType :: Expr -> Type .     how can I check if [Expr] has all same Type ?
11:45:03 <Lemmih> gwern: I think Ian was working on removing the dependency on libgmp.
11:45:24 <saml> all (\x -> toType x)
11:46:13 <Igloo2> gwern: http://hackage.haskell.org/trac/ghc/wiki/ReplacingGMPNotes
11:46:14 <lambdabot> Title: ReplacingGMPNotes - GHC - Trac
11:46:54 <hpaste>  paolino pasted "constraint unneded" at http://hpaste.org/7015
11:47:41 <gwern> ah, licensings
11:47:48 <gwern> yeah, that's a good reason to replace it
11:47:53 <saml> no it doesn't work because toType doesn't return Bool
11:47:54 <paolino> compiling this code I get a cannot deduce Show b, is this logical ?
11:49:01 <MyCatVerbs> @pl \m a -> m >>= \f -> return (f a)
11:49:02 <lambdabot> flip (fmap . flip id)
11:49:18 <MyCatVerbs> ...what the Hell? flip id?
11:49:34 <gnuvince> :t flip
11:49:37 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
11:49:48 <desegnis> paolino: I miss the definition of Context in your paste
11:50:06 <MyCatVerbs> @pl \a m -> m >>= \f -> return (f a)
11:50:06 <lambdabot> fmap . flip id
11:50:24 <saml> > 1 + 1 -- to test if I have voice in this channel
11:50:26 <lambdabot>  2
11:50:30 <paolino> Context a ?
11:50:47 <helmut> Could someone invest some time to help me understanding a haskell representation of mu recursive functions? (probably a query and at least ten minutes)
11:50:51 <MyCatVerbs> saml: you don't have voice, but you aren't banned and the channel isn't set +m.
11:51:04 <desegnis> MyCatVerbs: id :: (a -> b) -> a -> b
11:51:26 <hpaste>  paolino annotated "constraint unneded" with "Context a" at http://hpaste.org/7015#a1
11:51:37 <desegnis> paolino, what, Context a?
11:51:41 <desegnis> ah
11:52:09 <MyCatVerbs> @src ($)
11:52:10 <lambdabot> f $ x = f x
11:52:15 <geezusfreeek> :t flip id
11:52:16 <lambdabot> forall b c. b -> (b -> c) -> c
11:52:27 <pejo> helmut, people usually get good answers when they just ask in the channel.
11:52:33 <desegnis> paolino, ok, Context a has no Show instance?
11:52:55 <paolino> it has
11:53:06 <desegnis> > sqrt `id` 16
11:53:07 <lambdabot>  4.0
11:53:18 <paolino> the asked constraint is Show b
11:53:37 <helmut> pejo: ok. I try to formulate my question on hpaste
11:54:06 <desegnis> paolino, that being exactly the same b as in the definition?
11:54:24 <helmut> pejo: pasting the question to the channel would not be nice (longish)
11:54:25 <MyCatVerbs> > let f = flip id in 16 `f` sqrt
11:54:26 <lambdabot>  4.0
11:54:59 <paolino> desegnis:     Could not deduce (Show b)
11:54:59 <paolino>       from the context (Show (Rulista a b), Show a)
11:55:02 <desegnis> > let (.) = flip id in 16.sqrt -- OO programming
11:55:03 <lambdabot>  4.0
11:55:15 <idnar> haha
11:55:56 <desegnis> paolino: I guess you have instance Show a => Show (Context a) then?
11:56:09 <saml> is there such funciton: [a] -> (a -> a -> Bool) -> Bool
11:56:32 <desegnis> paolino, note how you have "a b" here and "b a" there
11:56:38 <paolino> urgh
11:56:46 <Crecerelle> Hi :) Is there a known problem with gtk2hs and GHC 6.8.2? I can't get the Debian package to install, or get the tar release or a Darcs checkout to compile. Google didn't bring up much, so I'd like to check if it's a known problem before pestering someone...
11:57:02 <desegnis> @type foldr (&&)
11:57:03 <lambdabot> Bool -> [Bool] -> Bool
11:57:04 <Vulpyne> Is there any way I can kill a thread spawned with forkOS or forkIO if it's in a foreign call?
11:57:15 <desegnis> crap
11:58:06 <desegnis> anyway, saml, that should be some kind of fold
11:58:45 <paolino> desegnis, thanks :-/
11:59:11 <desegnis> paolino, are you going to tell me that the reversed order was the root of your problem? :)
11:59:32 <paolino> if you ask me to
11:59:37 <saml> desegnis: let me try . thanks
12:00:00 <gnuvince> dons: any idea when a new beta chapter for RWH will be available?
12:00:06 <hpaste>  helmut pasted "mu recursive" at http://hpaste.org/7016
12:02:22 <byorgey> saml: what exactly do you want to do?  Can you give an example of how such a function should work?
12:03:13 <takamu> hi
12:03:39 <byorgey> hi takamu
12:04:43 <helmut> pejo: ideas?
12:09:04 <pejo> helmut, not really. Not sure who might know either. :/
12:10:45 <helmut> pejo: maybe I can go on without knowing parameter lengths, but it would be really helpful
12:13:28 <vixey> does anyone have a sine wave example or something of Sound.OpenAL?
12:15:06 <byorgey> helmut: you want MuRec to be indexed by the number of parameters.
12:15:28 <helmut> byorgey: that means?
12:16:04 <byorgey> helmut: something like data MuRec n = Constant Integer | ...
12:16:34 <helmut> byorgey: I tried that and failed.
12:16:39 <byorgey> helmut: but the Substitute case is tricky, since you want something like   forall m. Substitute (MuRec n) [MuRec m]
12:17:02 <byorgey> helmut: the real answer is that you want a dependently typed language
12:17:04 <hpaste>  saml pasted "better way to do this??" at http://hpaste.org/7017
12:17:32 <byorgey> helmut: this sort of thing would be very natural to express in something like Agda
12:17:35 <helmut> byorgey: I tried exactly your Substitute proposale which didn't make ghci happy (in my context)
12:17:38 <vixey> saml:
12:17:49 <vixey> > zip [1,2,3,4] (tail [1,2,3,4])
12:17:50 <lambdabot>  [(1,2),(2,3),(3,4)]
12:17:54 <vixey> > map f $ zip [1,2,3,4] (tail [1,2,3,4])
12:17:55 <lambdabot>  Add a type signature
12:18:04 <vixey> > zipWith f [1,2,3,4] (tail [1,2,3,4])
12:18:05 <lambdabot>  Add a type signature
12:18:13 <vixey> well anyway, maybe you can use that
12:18:19 <byorgey> helmut: well, yes, what I wrote isn't actual code, just something sort of like what you want.  I'm sure it's possible but it's very tricky to get right with Haskell.
12:18:32 <byorgey> I don't really know precisely how you would do it.
12:18:56 <byorgey> helmut: note that you would also not really want to use [MuRec m], you'd want a list type indexed by length
12:18:58 <helmut> byorgey: I can see that it is tricky.
12:19:08 <byorgey> something like (List n (MuRec m))
12:19:19 <helmut> yes
12:19:34 <helmut> And I'd want a type for numbers between 0 and n
12:21:09 <byorgey> @type and
12:21:10 <lambdabot> [Bool] -> Bool
12:21:18 <byorgey> saml: ah, allOk xs f === and $ zipWith f xs (tail xs)
12:22:12 <byorgey> @let lengthsEq x y = (length (show x) == length (show y))
12:22:13 <lambdabot> Defined.
12:22:36 <byorgey> @let allOk f xs = and $ zipWith f xs (tail xs)
12:22:36 <lambdabot> Defined.
12:22:46 <byorgey> > allOk lengthsEq []
12:22:47 <lambdabot>  True
12:22:50 <byorgey> > allOk lengthsEq [1]
12:22:51 <lambdabot>  True
12:22:57 <byorgey> > allOk lengthsEq [1,4,5,2,7]
12:22:58 <lambdabot>  True
12:23:03 <byorgey> > allOk lengthsEq [1,4,5,23,7]
12:23:04 <lambdabot>  False
12:23:12 <helmut> > allOK lengthsEq [0,1]
12:23:13 <lambdabot>   Not in scope: `allOK'
12:23:19 <helmut> > allOk lengthsEq [0,1]
12:23:20 <lambdabot>  True
12:23:43 <byorgey> saml: does that make sense?
12:23:44 <nibro> @seen kolmodin
12:23:44 <lambdabot> kolmodin is in #haskell, #ghc, #haskell.se, #xmonad, #gentoo-haskell, #darcs, #haskell-hac4 and #friendly-coders. I last heard kolmodin speak 1h 34m 34s ago.
12:24:59 <vixey> Is Haskell a good choice for realtime audio sythesis?
12:25:07 <saml> byorgey: nice and elegant
12:26:39 <saml> @can haskell do real time audio synthesis?
12:26:40 <lambdabot> Maybe you meant: faq map run wn
12:26:50 <byorgey> vixey: I know people definitely do use it for that.
12:27:32 <saml> vixey: what do you have in mind? Reason?
12:32:38 <vixey> frag doesn't use OpenAL?
12:35:02 <Cale> http://uk.youtube.com/watch?v=PH-OhkrXXvA -- new Catsters video!
12:35:03 <allbery_b> frag predates the openal binding, I think
12:35:05 <lambdabot> Title: YouTube - Monoid objects 1
12:36:23 <exe> Cale: ^.^
12:37:13 <n00b> is it possibel to make a recursive break function
12:38:03 <Cale> n00b: What will it do?
12:38:20 <Cale> n00b: (of course, if you can describe what it does, it's very likely possible ;)
12:39:08 <n00b> i want it to break if it finds some chars in a string like ' ' # $ @ ^ % those stuff
12:39:26 <n00b> and retrun them in seperate string
12:39:43 <saml> f x >>= (\y -> return $ Constructor y)    -- is there a different way to do this without using do block?
12:39:46 <sw17ch> n00b, like filter?
12:39:59 <mrd> ?pl f x >>= (\y -> return $ Constructor y)
12:39:59 <lambdabot> Constructor `fmap` f x
12:40:07 <mrd> or liftM
12:40:09 <Cale> Those ' # $ @ ^ % are delimiters?
12:40:36 <n00b> so rbreak "the is# ststa" should give [the, is, #, "ststa"]
12:40:44 <saml> mrd thanks
12:40:58 <vixey> > sizeOf (undefined :: CShort)
12:40:58 <lambdabot>   Not in scope: type constructor or class `CShort'
12:41:03 <Cale> ah, okay, that's kind of different from what I was thinking...
12:41:09 <sw17ch> n00b, ... similar to the ruby/python split function?
12:41:19 <n00b> yeah
12:42:10 <sw17ch> yeah, that should be pretty easy :)
12:42:14 <Cale> Sure, it's possible to write that. Recursively applying break or span is probably a reasonable way to go.
12:42:16 <sw17ch> you're looking at the break function right?
12:42:21 <ziman> > groupBy ((==) `on` (`elem`" #$@^%")) "the is# ststa"
12:42:22 <sw17ch> but you just want it recursive?
12:42:23 <lambdabot>  ["the"," ","is","# ","ststa"]
12:42:44 <sw17ch> ziman, almost exactly what i was thinking
12:43:05 <byorgey> ziman: nice =)
12:43:18 <Cale> hmm, but apparently we don't want the spaces in the output?
12:43:28 <Cale> (those can of course be removed after)
12:44:19 <vixey> @index sizeOf
12:44:20 <lambdabot> Foreign.Storable, Foreign
12:44:36 <sw17ch> > ((groupBy ((==) `on` (`elem`" #$@^%"))) . (filter (/=" "))) "the is# ststa"
12:44:36 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
12:45:20 <n00b> yes recurse
12:45:22 <n00b> what is on?
12:45:25 <paolino> @instances Functor
12:45:26 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
12:45:36 <n00b> `on`
12:45:39 <vixey> @src on
12:45:39 <lambdabot> (*) `on` f = \x y -> f x * f y
12:45:51 <Cale> n00b: (f `on` g) x y = f (g x) (g y)
12:46:45 <paolino> > (+1) `fmap` (Left 1)
12:46:46 <lambdabot>  Left 1
12:47:02 <bos31337> what's thomas schilling's nick again?
12:47:32 <Cale> So ((==) `on` (`elem` " #$@^%")) is a function which determines whether or not two elements are both in or both not in " #$@^%".
12:47:44 <paolino> @src fmap (Either a)
12:47:44 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
12:48:20 <Cale> @src Either fmap
12:48:20 <lambdabot> fmap _ (Left x) = Left x
12:48:20 <lambdabot> fmap f (Right y) = Right (f y)
12:48:22 <Saizan> bos: nominolo?
12:48:38 <bos> ah, yes. thanks.
12:48:52 <n00b> @type
12:48:53 <lambdabot> <no location info>: not an expression: `'
12:48:54 <bos> i'm having some trouble with cabal internals, and wanted to prod nominolo. but he's not here.
12:49:00 <n00b> @type on
12:49:01 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
12:49:28 <paolino> lambdabot: don't use the scrambler with Cale ;-)
12:49:30 <vixey> If you use mallocBytes to get a Ptr to some memory, how could you fill it with data??
12:49:36 <vixey> sorry -?
12:49:42 <Saizan> there's still cabal-devel@
12:50:12 <Saizan> ?type poke
12:50:13 <lambdabot> Not in scope: `poke'
12:50:21 <Saizan> ?hoogle poke
12:50:21 <lambdabot> Foreign.Storable.poke :: Storable a => Ptr a -> a -> IO ()
12:50:22 <lambdabot> Foreign.Storable.pokeElemOff :: Storable a => Ptr a -> Int -> a -> IO ()
12:50:22 <lambdabot> Foreign.Storable.pokeByteOff :: Storable a => Ptr b -> Int -> a -> IO ()
12:50:34 <vixey> thank you
12:50:42 <Cale> n00b: If you're having trouble with it, you could also write  (\x y -> x `elem` " #$@^%" == y `elem` " #$@^%")
12:50:55 <Cale> n00b: which would be the same thing
12:51:52 <saml> i have    x :: Identity Type,  y :: Identity Type.      how can I do    x == y ?    Type is instance of Eq
12:52:38 <Cale> Ahaha, Identity isn't an instance of Eq for some reason.
12:52:47 <byorgey> blerg?
12:52:51 <Cale> You can runIdentity on both sides first.
12:52:52 <vixey> @index Short
12:52:52 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexArrays, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT, Graphics.X11.Xlib.Types
12:53:02 <dons> nice haskell/gtk article, http://www.kennknowles.com/blog/2008/04/16/drawing-fractals-in-haskell-with-a-cursor-graphics-dsel-and-a-cute-list-representation/
12:53:04 <lambdabot> Title: Mathematical Pamphlet » Drawing fractals in Haskell with a cursor graphics DSEL  ..., http://tinyurl.com/6gzfgp
12:53:55 <saml> Cale: thank you
12:54:45 <dejones> dons, cool article, thanks for the post.  :)
12:56:45 <vixey> @hoogle Float -> Integer
12:56:45 <lambdabot> No matches, try a more general search
12:56:51 <vixey> @hoogle Integer -> Float
12:56:52 <lambdabot> No matches, try a more general search
12:57:02 <vixey> :t fromIntegral
12:57:03 <lambdabot> forall a b. (Num b, Integral a) => a -> b
12:57:35 <vixey> :t fromIntegral.sin.fromIntegral
12:57:36 <lambdabot>     Ambiguous type variable `a' in the constraints:
12:57:36 <lambdabot>       `Integral a'
12:57:36 <lambdabot>         arising from a use of `fromIntegral' at <interactive>:1:0-11
12:59:19 <hpaste>  Vicky pasted "mute OpenAL" at http://hpaste.org/7020
12:59:28 <saml> top level definitions like:  f = 1     doesn't have type right?
12:59:47 <vixey> does anyone know why this doesn't produce any audio?
12:59:59 <vixey> or have some example OpenAL program I could look at..
13:00:06 <Cale> saml: They may have type signatures, but are not generally required to.
13:00:24 <vixey> saml: Both sides of the = have the a type (the same type)
13:00:41 <vixey> that is f and 1 are both Num
13:00:53 <Cale> They're both  (Num a) => a  rather
13:01:34 <vixey> I want to use OpenAL but I don't know how to :|
13:02:01 <pierre-> hello
13:04:22 <pierre-> when running ghc 6.8.1 under wine and doing "runghc Setup.hs build" i get the following: "Setup.hs: waitForProcess: invalid argument (Bad file descriptor)". how can i get rid of it?
13:05:43 <vixey> has nobody used Sound.OpenAL?
13:06:32 <Cale> pierre-: ...GHC under wine?
13:06:53 <Cale> pierre-: I suppose the idea is to generate windows binaries on a linux machine?
13:07:14 <geezusfreeek> an interesting idea...
13:07:19 <Cale> pierre-: I suspect it will be simpler just to get a windows machine to run GHC on...
13:08:00 <n00b> hey guys i am trying to create a find next function, i have the code, it doesn't work how i want it to, i write a file with all the coordinates of the words, each a take 1 then drop 1 when writing, if the user enters a new word it suppose to recreate the temp file with the new coordinates, but when i do that it doesn't seem to be updating the file with the new coordinates, it just keep dropping one from the previous coordina
13:08:27 <Cale> http://haskell.cs.yale.edu/haskellwiki/GHC_under_WINE -- hmm, apparently someone else has thought to do this.
13:08:28 <lambdabot> Title: GHC under WINE - HaskellWiki
13:10:06 <geezusfreeek> impressive that it seems to work as well as it does
13:10:15 <pierre-> Cale, yes, the idea is to generate windows binaries
13:10:36 <pierre-> that's not my idea, as you can see :-)
13:10:43 <Cale> geezusfreeek: Well I suppose if I can run Halflife 2, Portal and Oblivion rather nicely :)
13:13:11 <Cale> pierre-: Any specific reason that you're a point release back in your GHC version?
13:13:51 <Cale> pierre-: It might be worth a shot to upgrade. If that fails, maybe just try compiling the programs rather than using runghc.
13:14:02 <Cale> (If that works)
13:15:37 <pierre-> Cale, i'm using ghc 6.8.1 because gtk2hs installer for windows works with it
13:15:43 <Cale> ah, okay
13:16:07 <Cale> So try just compiling the program which you were going to run with runghc
13:16:48 <paczesiowa> pierre-: dcoutts posted this link earlier: http://haskell.org/~duncan/gtk2hs/gtk2hs-0.9.12.1.exe it works with ghc-6.8.2
13:19:14 <pierre-> paczesiowa, thank you
13:52:02 <gwern> > show "foo\\bar"
13:52:05 <lambdabot>  "\"foo\\\\bar\""
13:52:21 <gwern> > print $ show "foo\\bar"
13:52:22 <lambdabot>  <IO ()>
13:52:34 <gwern> > show "foo\bar"
13:52:35 <lambdabot>  "\"foo\\bar\""
13:55:22 * lispy is waiting for 6.8.3
13:55:43 <lament> ooh this is so pretty
13:55:51 <lispy> I heard it from a blog who heard it from a dev who...said that 6.8.3 would allow HPC to redirect tix files :)
13:55:53 <lament> data AddBounds a = MinBound | NoBound a | MaxBound deriving Eq
13:56:20 <lispy> what about Ord and Enum?
13:56:41 <lispy> Seems like, MinBound < MaxBound would be good
13:56:45 <lament> that gets trickier
13:57:24 <lament> ooh
13:57:35 <lament> it doesn't derive Ord "for an unfortunate technical reason"
13:58:52 <MyCatVerbs> Plus check that enumFrom minBound == enumFromThenTo minBound (succ minBound) maxBound ? :)
14:00:19 <lispy> Okay, so maybe Enum can be dropped.
14:00:42 <lament> Ord is obvious but not derivable
14:00:44 <lispy> I don't mind for succ MaxBound = MinBound in most cases, but Iknow it's not a good general policy :)
14:01:18 <lispy> lament: well, instance Ord should be easy I think
14:02:33 <lispy> lament: But, maybe you need a witness type on MinBound/MaxBound so you don't compare MinBounds of different types
14:18:24 <DRMacIver> Hm. Is there a good way to generate prettified html from a literate haskell file?
14:19:07 <vincenz> yes
14:19:11 <vincenz> hscolour -lit
14:19:35 <DRMacIver> Thanks
14:25:17 <alkoma> I see a reference about Shim on NM's blog, but the link is dead.  does anyone know about this project to integrate ghc-api into emacs?
14:30:17 <dons> some people use shim
14:33:02 <quicksilver> alkoma: shim is not dead, but I don't know where to direct you
14:33:09 <quicksilver> alkoma: I have heard people working on it recently
14:34:20 <vixey> sorry to repeat but is anyone aware of something that does sound synthesis with OpenAL?
14:34:37 <Sadache> I can't get grasp of pattern binding , anyone has a simple example (other than client server one)?
14:35:12 <Saizan> pattern binding?
14:35:30 <Saizan> you mean like in case .. of and function definitions?
14:35:38 <jfoutz> fact 0 = 1, fact n = n * (fact -1) ?
14:35:48 <jfoutz> er, heh
14:36:02 <jfoutz> fact 0 = 1, fact n = n * (fact n-1) ?
14:36:16 <Sadache> no the one like fibs'@(1:fibst)=
14:36:30 <Saizan> ah
14:36:44 <vixey> fibs' is the entire thing
14:36:51 <vixey> 1:fibst is bound like normal
14:37:01 <Saizan> > let foo xxs@(x:xs) = (xxs,x,xs) in foo [1..3]
14:37:02 <lambdabot>  ([1,2,3],1,[2,3])
14:37:16 <mauke> ARGH
14:37:28 <jfoutz> i think of the @ as "as" xxs "as" (x:xs) in vixey's example
14:37:38 <mauke> I'm starting to hate the standard libraries (again)
14:37:45 <alkoma> quicksilver: I googled a bit and found shim.el at http://code.haskell.org/shim/
14:37:45 <lambdabot> Title: Index of /shim
14:37:48 <Saizan> mauke: for what?
14:37:52 <vixey> > > (\ x@(y,z) -> [x,y,z] ) (9,6)
14:37:52 <lambdabot>   parse error on input `>'
14:37:55 <vixey> > (\ x@(y,z) -> [x,y,z] ) (9,6)
14:37:55 <lambdabot>      Occurs check: cannot construct the infinite type: t = (t, t1)
14:37:56 <lambdabot>       Expe...
14:38:03 <vixey> > (\ x@(y,z) -> (x,y,z) ) (9,6)
14:38:04 <lambdabot>  ((9,6),9,6)
14:38:19 <mauke> for defining Show instances without a corresponding Read, then hiding the data constructors so I can't even fix it myself
14:38:48 <mauke> (Socket is fixable. NominalDiffTime isn't)
14:39:35 <Sadache> ok, i like the 'as' decription, i guess i get it better this way
14:40:03 <jfoutz> the ' in variable names threw me off for a long time.
14:40:15 <jfoutz> sorta facing 2 issues there.
14:43:08 <mauke> :t realToFrac
14:43:09 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
14:46:36 <Gnezdo> > 0 == toInteger (-1 `Data.Bits.shift` 32 :: Data.Int.Int64)
14:46:36 <lambdabot>  True
14:46:50 <Gnezdo> yeah, so lambda bot is also affected by http://hackage.haskell.org/trac/ghc/ticket/2223
14:46:52 <lambdabot> Title: #2223 (Int64.toInteger) - GHC - Trac
14:50:39 <billbillb> assuming i have a list like this : x = [[1,2,3],[4,5,6],[7,8,9]]    how can i get all possible combinations of length(x)? for example [[1,4,7],[1,4,8].....]
14:51:17 <vixey> you can use the list monad
14:51:24 <vixey> > sequence [[1,2,3],[4,5,6],[7,8,9]]
14:51:24 <lambdabot>  [[1,4,7],[1,4,8],[1,4,9],[1,5,7],[1,5,8],[1,5,9],[1,6,7],[1,6,8],[1,6,9],[2,...
14:52:00 <vixey> > do { x <- [1,2,3] ; y <- [4,5,6] ; z <- [7,8,9] ; return [x,y,z] }
14:52:01 <lambdabot>  [[1,4,7],[1,4,8],[1,4,9],[1,5,7],[1,5,8],[1,5,9],[1,6,7],[1,6,8],[1,6,9],[2,...
14:52:37 <elliottt> > [ [x,y,z] | x <- [1,2,3], y <- [4,5,6], z <- [7,8,9]]
14:52:38 <lambdabot>  [[1,4,7],[1,4,8],[1,4,9],[1,5,7],[1,5,8],[1,5,9],[1,6,7],[1,6,8],[1,6,9],[2,...
14:52:49 <elliottt> might be easier to understand at a glance :)
14:53:11 <vixey> sugary
14:53:17 <ziman> @src sequence
14:53:17 <lambdabot> sequence []     = return []
14:53:17 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:53:17 <lambdabot> --OR
14:53:17 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
14:53:19 <billbillb> the problem with the 2nd solution is that i need the list to have different lengths
14:53:34 <jfoutz> > filterM (const [True,False]) [1,2,3]
14:53:35 <vixey> billbillb: This is a problem?
14:53:35 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
14:53:42 <vixey> > sequence [[1,2,3],[4],[7,8,9]]
14:53:43 <lambdabot>  [[1,4,7],[1,4,8],[1,4,9],[2,4,7],[2,4,8],[2,4,9],[3,4,7],[3,4,8],[3,4,9]]
14:54:11 <billbillb> thnx, thats what i need
14:55:42 <jfoutz> wow, sequence is cool
14:55:49 <ziman> that's brain-hurting :)
14:56:00 <ddarius> > sequence [Just 3, Just 4, Nothing]
14:56:01 <lambdabot>  Nothing
14:56:04 <ddarius> > sequence [Just 3, Just 4, Just 5]
14:56:05 <lambdabot>  Just [3,4,5]
14:56:18 <Saizan> ?src sequence
14:56:18 <lambdabot> sequence []     = return []
14:56:18 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:56:18 <lambdabot> --OR
14:56:18 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
14:56:34 <roconnor> > sequence [id, (*2), (+2)] 5
14:56:35 <lambdabot>  [5,10,7]
14:56:49 <jfoutz> hahaha
14:56:52 <vixey> iterate = sequence . repeat -- ?
14:57:05 <vixey> > (sequence . repeat) (1+) x
14:57:06 <lambdabot>  [1 + x,1 + x,1 + x,1 + x,1 + x,1 + x,1 + x,1 + x,1 + x,1 + x,1 + x,1 + x,1 +...
14:57:14 <vixey> no :/
14:57:33 <dons> cute.
14:57:40 <roconnor> I think iterate is unrelated to sequence
14:57:45 <ddarius> > (transpose . sequence . repeat) (1+) x
14:57:45 <dons> ?src sequence
14:57:45 <lambdabot>  Couldn't match expected type `t1 -> t'
14:57:45 <lambdabot> sequence []     = return []
14:57:45 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:57:45 <lambdabot> --OR
14:57:45 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
14:57:49 <dons> one is a fold
14:57:50 <olsner> hmm, I should've asked this an hour ago... are there any ready-made ini file parsers in haskell?
14:57:52 <jfoutz> ?src iterate
14:57:53 <lambdabot> iterate f x =  x : iterate f (f x)
14:57:55 <dons> Cale, oh, that's new.
14:58:02 <dons> olsner: hmm, check on hackage.
14:58:07 <dons> its /possible/
14:58:26 * vixey pokes lambdabot..
14:58:38 <olsner> otoh, what I'm *really* looking for may well be something else than INI for the config file
14:58:39 <ddarius> olsner: I'm pretty someone has written one, but I don't recall if it was distributed.  I also think that there is one inside of something else.
14:58:51 <vixey> > (transpose . sequence . repeat) (1+) x
14:58:51 <ddarius> olsner: Writing an INI parser would be trivial
14:58:52 <lambdabot>  Couldn't match expected type `t1 -> t'
14:59:07 <vixey> @src transpose
14:59:07 <lambdabot> transpose []             = []
14:59:07 <lambdabot> transpose ([]   : xss)   = transpose xss
14:59:07 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
14:59:07 <lispy> Hmm...so I take it "principled approach to version control" was never published?
14:59:46 <olsner> I've got something that mostly works now, but I got stuck a lot in the details of how to strip comments
15:02:52 <vixey> > ((sequence.sequence).(repeat.repeat)) (1+) x
15:02:52 <lambdabot>  Couldn't match expected type `(->) t' against inferred type `[]'
15:04:42 <olsner> and it doesn't quite do the right thing always... but currently does enough for me to write the config file I want to write
15:05:01 <jfoutz> @src fix
15:05:01 <lambdabot> fix f = let x = f x in x
15:07:44 <MyCatVerbs> > (listToMaybe . map fst . reads $ "400") + 1
15:07:44 <lambdabot>   add an instance declaration for (Num (Maybe a))
15:07:51 <vixey> > sequence (fix ((f .) :)) x
15:07:52 <lambdabot>  Couldn't match expected type `Expr' against inferred type `f a'
15:08:02 <MyCatVerbs> > (listToMaybe . map fst . reads $ "400") >>= liftM (+1)
15:08:02 <vixey> > sequence (fix (((1+) .) :)) x
15:08:03 <lambdabot>  Couldn't match expected type `Expr' against inferred type `f t'
15:08:03 <lambdabot>  Nothing
15:08:33 <MyCatVerbs> > (reads "400") :: [(Integer,String)]
15:08:33 <lambdabot>  [(400,"")]
15:09:19 <vixey> > sequence (fix ((id :) . (map (1+))) x
15:09:19 <lambdabot> Unbalanced parentheses
15:09:26 <vixey> > sequence (fix ((id :) . (map (1+)))) x
15:09:26 <lambdabot>   add an instance declaration for (Num (Expr -> Expr))
15:14:21 <ZenGeek> if i'm trying to covert a type to string type
15:14:30 <ZenGeek> but the type is not a normal type
15:14:32 <olsner> @ty <$>
15:14:33 <lambdabot> parse error on input `<$>'
15:14:38 <olsner> @ty (<$>)
15:14:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:14:48 <jfoutz> ZenGeek: show?
15:14:50 <ZenGeek> the type is FontStyle
15:15:05 <ZenGeek> would show work for FontStyle
15:15:10 <ZenGeek> show isnt working
15:15:23 <Cale> ZenGeek: Which FontStyle type is it?
15:15:31 <ddarius> What is a "normal type"?
15:15:46 <ZenGeek> there are types of FontStyle
15:15:49 <ZenGeek> hey Cale
15:16:00 <Cale> ZenGeek: If it's in a library which you wrote, then you can add 'deriving Show' to the data declaration, and it'll derive a show function from the structure of the type.
15:16:23 <ZenGeek> yes but its in wxhaskell
15:16:29 <ZenGeek> i didnt write it
15:16:32 <jfoutz> and if it's not you, could implement show to display useful stuff.
15:16:32 <Cale> ZenGeek: If it's not in a library you wrote, you'll just have to work something out for yourself. You might write an instance of Show by hand, for instance.
15:16:34 <ZenGeek> is there still a way?
15:16:46 <Cale> instance Show FontStyle where
15:16:48 <ZenGeek> right how would i do that
15:16:49 <Cale>    show x = ...
15:17:04 <ZenGeek> and where?
15:17:13 <ZenGeek> do i just write it anywhere?
15:17:24 <ddarius> Anywhere where FontStyle is in scope.
15:18:07 <Cale> uh, according to the documentation, FontStyle is already an instance of Shwo
15:18:09 <Cale> Show*
15:18:35 <ZenGeek> it should be.. i mean that would make sense
15:18:47 <ZenGeek> but i okay where do you see this?
15:18:51 <ZenGeek> Cale
15:19:01 <Cale> http://wxhaskell.sourceforge.net/doc/Graphics-UI-WXCore-Draw.html#t%3AFontStyle
15:19:02 <lambdabot> http://tinyurl.com/58v4ks
15:23:58 <ziman> @pl ($5).snd
15:23:59 <lambdabot> flip snd 5
15:24:13 <mauke> I'm pleasantly surprised
15:24:26 <mauke> I just hacked xmonad-style restarting into a program
15:24:37 <mauke> after getting it to compile it seems to Just Workâ„¢
15:24:44 <byorgey> mauke: awesome!
15:24:51 <byorgey> xmonad-style-restarting++
15:25:27 <olsner> @karma restarting
15:25:28 <lambdabot> restarting has a karma of 0
15:25:34 <olsner> @karma xmonad-style-restarting
15:25:34 <lambdabot> xmonad-style-restarting has a karma of 1
15:25:44 <byorgey> we should replace all that text on the front page of the wiki with the slogan "Haskell: It Just Worksâ„¢"
15:25:59 <jfoutz> well...
15:26:12 <jfoutz> building a universal binary is hard.
15:26:31 <jfoutz> a lot of the obj-c binding is hard.
15:26:50 <byorgey> ok, so we'll add a little footnote that says "some restrictions may apply"
15:27:00 <jfoutz> *perfect* :)
15:27:01 <dons> hmm.  we need a catchy name for 'xmonad-style-restarting'
15:27:08 <dons> yi uses it now too, and calls it 'xmonad-style reloading'
15:27:15 <byorgey> hehe
15:27:28 <dons> i wonder if there's a short HW paper in describing all the hot reloading techniques we have now
15:27:40 <byorgey> hotloading?
15:28:02 <byorgey> dons: only one way to find out =)
15:28:07 <jfoutz> isn't it the traditional kill 1 style reloading?
15:28:20 <dons> the state serialisation is the interesting part
15:28:37 <dons> the old state is passed as a parameter to the new code. and the app is written as a library
15:28:56 <dons> so you can upgrade code forever by composing the library entry points
15:29:10 <dons> its a very reliable, simple reloading style
15:29:23 <dons> which i think is why we're seeing more use : it fits with the current toolchain pretty well
15:29:32 <mauke> my program doesn't do the second part
15:29:42 <jfoutz> will it be in the book? :)
15:30:18 <dons> probably not. :) its a fairly obscure technique
15:30:35 <dons> it has probability=0 of being in the book, i think
15:31:05 <jfoutz> i'm really looking forward to it. i hope o'reilly passes on some money i give them to you.
15:31:33 <Japsu>            
15:31:53 <olsner> @ty \f -> (<$>) (f <$>)
15:31:54 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f1 (f a) -> f1 (f b)
15:47:49 <DRMacIver> hm. Who in here can I pester about planet haskell?
15:48:09 <Saizan> ibid!
15:48:41 <DRMacIver> ibid: Did you get my email recently about the blog move?
15:49:01 <needy101> hey guys i am writing a findNext function in haskell, is there  a way to make haskell destructive
15:49:04 <needy101> ??
15:49:37 <Bonus> what do you mean
15:49:47 <Botje> needy101: install it on a nuclear missile
15:50:00 <needy101> no not that
15:50:05 <dibblego> ?type find
15:50:06 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
15:50:12 <dibblego> that?
15:50:13 <ddarius> So on a set of measure zero, xmonad-style reloading will be in RWH, not bad.
15:50:27 <Botje> needy101: what should do this findNext do?
15:50:46 <Botje> and why do you think you need destructive operations for that?
15:50:53 <needy101> i am writing a findNext, i wrote all the positions where the word is found in a file (x,y) and then draw one from it each time
15:51:10 <needy101> so take 1 then drop 1 (saving the file)
15:51:20 <dibblego> needy101, it's highly likely that you do not want to be destructive
15:51:27 <needy101> so it as one less when it processes again
15:51:30 <Botje> so why do you need destruction for that?
15:51:44 <Bonus> just make a function that returns them all in a list?
15:51:56 <needy101> to delete the coordinate at the front of the list, so it can move to the next one
15:52:13 <dons> andyjgill: ask me tomorrow about how hpc helps managing rewrite rules
15:52:15 <dibblego> lists are immutable and cannot be deleted from
15:52:26 <hpaste>  needy101 pasted "findNext" at http://hpaste.org/7023
15:52:38 <needy101> i just posted what i have so far
15:53:05 <ZenGeek> need
15:53:10 <needy101> it works partially
15:53:26 <ZenGeek> you go to uwi?
15:54:10 <needy101> why ?
15:54:17 <Jaak> bah. monadic case suggar would be nice: casem ma of ... ==> ma >>= \a -> case a of ...
15:54:27 <ZenGeek> i go there
15:54:37 <needy101> ZenGeek why?
15:54:47 <ZenGeek> if you go there we have the same project due
15:54:59 <needy101> and ???
15:55:05 <ZenGeek> do you go there?
15:55:11 <needy101> yes
15:55:22 <ZenGeek> well then we could help each other
15:55:24 <ZenGeek> thats so kool
15:55:26 <ZenGeek> :)
15:55:26 <dibblego> how much Haskell do they teach at your university?
15:55:27 <ZenGeek> heyyy
15:55:40 <ZenGeek> umm
15:55:43 <ZenGeek> not much
15:55:47 <needy101> just first year
15:55:51 <dibblego> is uwi University of West Indies?
15:55:57 <needy101> pretty lame structure
15:55:58 <ZenGeek> yes
15:56:10 <ZenGeek> dibblego you know it?
15:56:21 <ZenGeek> yp needy my problem with find
15:56:33 <ZenGeek> is that i cant get it to highlight the word
15:56:46 <needy101> .ZenGeek, you did ur findnext function?
15:56:48 <andyjgill> dons: sure, I'll ask
15:56:48 <ZenGeek> when do you have it due tomorrow or friday?
15:57:15 <ZenGeek> as for the function part.. you have problems finding the word?
15:57:31 <dibblego> no, just interested in universities teaching these things
15:57:59 <ZenGeek> why is needy not excited that we go to the same school
15:58:07 <needy101> ZenGeek 2moro, this is not messenger ok, kindda reduce the talkin
15:58:48 <needy101> ZenGeek you wanna talk over messenger instead, kinda disturbing the irc
16:00:35 <needy101> guys r u helping me with the findNext ??
16:00:48 <needy101> need top know where i am going wrong?
16:00:52 <needy101> please
16:00:59 <needy101> this is due 2moro
16:01:01 <dibblego> by thinking you need destruction is wrong
16:01:12 <dibblego> it would help if you abandoned that idea, even if on faith
16:01:15 <Jaak> @type findNext
16:01:16 <lambdabot> Not in scope: `findNext'
16:02:13 <lament> i wish i had haskell in first year!
16:02:25 <SamB> first year what?
16:02:27 <Cale> needy101: Hehe, aside from expressing coherent ideas with each line, we also like to spell things properly on IRC. :)
16:02:39 <lament> SamB: math :D
16:02:40 <needy101> the function doesn't really destroy the list, just drop 1, so I can check the other
16:02:44 <SamB> lament: ah
16:02:54 <lament> or CS, doesn't matter
16:03:00 <SamB> lament: if you had said CS, I would have said "wtf did you take CS for?"
16:03:02 <needy101> Cale ok :)
16:03:04 <olsner> (:[]) is a pretty neat operator, not to mention a funny smiley
16:03:05 <lament> my math program had required CS courses
16:03:08 <Bonus> hehe that looks pretty imperative
16:03:12 <lament> they were java and centered on UML
16:03:23 <SamB> what a lame math program
16:03:36 <lament> well, they were required courses for the entire science faculty
16:03:55 <Valodim> "CS"?
16:04:00 <Cale> It's too bad that there aren't more faculties of mathematics.
16:04:01 <olsner> I express my disdain at UML, despite my mother apparently somehow being involved in its development
16:04:01 <dibblego> Cale, some people don't like spelling things properly
16:04:02 <SamB> what a lame school of arts/sciences
16:04:06 <vixey> (:[]) is a function
16:04:15 <vixey> return is a function
16:04:16 <needy101> dibblego that's right
16:04:21 <lament> olsner: so it was YOUR MOM!!!
16:04:22 <needy101> it;s a drag
16:04:33 * olsner ducks
16:04:45 <SamB> olsner: perhaps you oughtn't to have mentioned that
16:04:54 <SamB> now people are going to be sending her mailbombs c/o you
16:05:04 <lament> i like UML
16:05:07 <lament> UML <3
16:05:16 <dibblego> $ grep apparant .xchat2/xchatlogs/FreeNode-#haskell.log  | wc -l102
16:05:19 <SamB> lament: you must be insane!
16:05:21 <olsner> SamB: Yes. Bad idea. Can I take that back please?
16:05:22 <DRMacIver> lament: I think they can cure that these days.
16:05:38 <macondo> is there a built-in function to know if a result is an Integer?
16:05:47 <SamB> macondo: what?
16:06:07 <Cale> What I don't understand is that if in order to design OO programs, people end up using another language entirely, then why don't they just write a compiler for that language?
16:06:08 <ddarius> const True :: Integer -> Bool
16:06:26 <DRMacIver> Cale: I'm pretty sure it's been done
16:06:41 <lament> Cale: UML is for human interaction
16:06:43 <doublec> Yeah, in one of my previous jobs much of the code was generated from UML
16:06:57 <lament> Cale: it can be used for other purposes, but that's insane
16:07:14 <Cale> lament: Human interaction?
16:07:14 <doublec> It was insane
16:07:17 <lament> UML is a graphical conlang for describing OO systems
16:07:27 <macondo> SamB: for example to know if (x^0.5) is a natural number
16:07:31 <doublec> try doing version control merges on uml diagram changes :)
16:07:41 <mauke> macondo: that doesn't compile
16:07:42 <macondo> SamB: sorry, **
16:07:51 <mauke> with ** it never is
16:08:08 <lament> Cale: If you have a complex system of objects and you need to describe it to somebody, a picture is probably worth a 1000 words
16:08:08 <SamB> > 0**0
16:08:09 <lambdabot>  1.0
16:08:17 <Cale> lament: yeah... so if you're going to specify your system in this formalism, why not make that specification compilable?
16:08:33 <macondo> @src (**)
16:08:33 <lambdabot> Source not found. My brain just exploded
16:08:40 <macondo> @src **
16:08:40 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
16:08:52 <vixey> :t (**)
16:08:53 <lambdabot> forall a. (Floating a) => a -> a -> a
16:08:55 <lament> Cale: for the same reason that theorems, the way presented in math papers, are not computer-readable
16:09:00 <vixey> ?djinn forall a. (Floating a) => a -> a -> a
16:09:07 <mauke> @src Floating
16:09:07 <lambdabot> class  (Fractional a) => Floating a  where
16:09:07 <lambdabot>     pi                                                      :: a
16:09:07 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
16:09:07 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
16:09:07 <lambdabot>     (**), logBase                                           :: a -> a -> a
16:09:11 <lament> Cale: humans are way better at interpreting incomplete specifications
16:09:21 <Cale> lament: So you're saying that UML isn't very formal?
16:09:27 <dibblego> I think they suck at it personally
16:09:33 <lament> Cale: yes.
16:09:40 <Cale> lament: I was under the impression that it had really detailed specifications of what it meant.
16:09:53 <lament> Cale: sure, but that part of it is nuts
16:10:06 <DRMacIver> Isn't it a formal specification of a subset of the behaviour?
16:11:07 <vincenz> Cale: it is not formal and it is not executable
16:11:13 <vincenz> Cale: that's a known fact even in the uml community
16:11:35 <lament> Cale: when i say "I like UML" I mean I like how it provides a fairly simple way of describing systems of objects in a nicely visual way. It totally fails at everything else it tries to do, but that part is very nice and very important
16:11:53 <lament> (and by "describing", i mean "to humans")
16:12:11 <SamB> lament: which diagram types do you like?
16:13:10 <lament> SamB: object
16:13:35 <lament> those that describe data
16:13:40 <SamB> yeah, that diagram type is actually usefull
16:13:55 <Cale> vincenz: It seems like you could get something out of using it as a kind of "top level" for your application code.
16:14:15 <Cale> and of course, have a traditional OO language underneath that.
16:14:42 <SamB> I dunno what you mean
16:15:09 <lament> Cale: but that would be terrible
16:15:20 <lament> it's enough we have Peaker trying to do a graphical language
16:16:15 <SamB> I wonder if you could use UML in a class browser's UI?
16:16:29 <lament> i suppose sequence diagrams are nice too
16:17:04 <lament> http://upload.wikimedia.org/wikipedia/commons/2/20/Restaurant-UML-SEQ.gif
16:17:06 <lambdabot> http://tinyurl.com/6mqfgb
16:17:15 <lament> worthless for "programming", but good documentation
16:17:36 <Cale> lament: I'm just saying, if you're going to bother drawing the diagrams for yourself, it shouldn't be too much to ask for the computer to interpret them for you :)
16:17:53 <wjt> do people actually use UML other than as a standard when drawing boxes on whiteboards?
16:18:08 <Valodim> to annoy students
16:18:21 <ddarius> People follow standards for whiteboard drawings?
16:18:33 <SamB> I think maybe you could ask the computer to make sure you keep the UML diagrams matching the code
16:18:56 <lament> Cale: again, "If you're going to bother writing theorem proofs for yourself, it shouldn't be too much to ask the computer to verify them for you"
16:19:00 <lament> Cale: doesn't work like that
16:19:40 <vixey> yes it does
16:19:50 <lament> humans and computers don't speak the same language quite yet
16:19:54 <lament> UML is a human language
16:19:56 <vixey> yes they do
16:20:03 <lament> vixey: oh, sorry :)
16:20:04 <Cale> lament: Well, if my proofs were *about* programs, then yeah, I'd probably want the computer to turn them into executable code :)
16:20:05 <vixey> ?where Coq
16:20:05 <lambdabot> I know nothing about coq.
16:20:09 <macondo> > 1 + -1
16:20:09 <lambdabot>      precedence parsing error
16:20:09 <lambdabot>         cannot mix `(+)' [infixl 6] and prefix ...
16:20:14 <vixey> ?where Agdo 2
16:20:14 <lambdabot> I know nothing about agdo.
16:20:17 <vixey> etc
16:20:24 <Cale> ?where agda
16:20:24 <lambdabot> http://tinyurl.com/yp6zsr
16:20:26 <EvilTerran> ITYM Agda
16:20:27 <vixey> > 1 + (negative 1)
16:20:27 <Cale> hmm
16:20:27 <lambdabot>   Not in scope: `negative'
16:20:36 <lament> vixey: those are proof assistant, and programs written in them are nothing like the proofs mathematicians normally write.
16:20:38 <vincenz> > 1 + negate 1
16:20:39 <lambdabot>  0
16:20:40 <lament> *assistants
16:20:40 <EvilTerran> ?hoogle negate
16:20:40 <lambdabot> Prelude.negate :: Num a => a -> a
16:20:42 <vincenz> > 1 + (-1)
16:20:43 <lambdabot>  0
16:20:45 <vixey> so what
16:20:58 <vincenz> vixey: it's Agda'
16:21:03 <vincenz> oh, EvilTerran alreay corrected
16:21:10 <EvilTerran> and Cale :P
16:21:11 <Cale> lament: right, but they're formalisations of the ones which mathematicians might write -- so as programming languages, they're headed in the right direction, perhaps :)
16:21:12 <lament> vixey: ?
16:21:26 <EvilTerran> JAPE produces very conventional-looking proofs IMO
16:21:33 <lament> Cale: and the formalization of UML is the program itself :)
16:21:39 <EvilTerran> but it's nothing like a programming language
16:21:40 <lament> Cale: think of UML as the documentation
16:21:51 <Cale> lament: Sure, you don't want to try to interpret the really informal bits, or start requiring mathematicians to write things in overly formal ways.
16:21:55 <EvilTerran> ?go jape proof assistant
16:21:58 <lambdabot> http://comjnl.oxfordjournals.org/cgi/reprint/42/3/177.pdf
16:21:59 <SamB> lament: documentation for illiterates?
16:22:01 <EvilTerran> huh
16:22:03 <ziman> @hoogle on
16:22:04 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
16:22:04 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
16:22:04 <lambdabot> Data.Function :: module
16:22:09 <vincenz> @hoogle off
16:22:10 <lambdabot> Foreign.Storable.peekElemOff :: Storable a => Ptr a -> Int -> IO a
16:22:10 <lambdabot> Foreign.Storable.pokeElemOff :: Storable a => Ptr a -> Int -> a -> IO ()
16:22:10 <lambdabot> Foreign.Storable.peekByteOff :: Storable a => Ptr b -> Int -> IO a
16:22:18 <lament> SamB: no, simply documentation.
16:22:20 <Cale> lament: But the problem I'm expressing is that the formalisation of that informal language looks nothing at all like it
16:22:36 <Cale> lament: Wouldn't it be nicer if the formal language was closer to the specification language?
16:23:14 <lament> Cale: when i describe what my program does (in English), i use the rules of grammar etc. This has the nice effect that other English speakers can understand me.
16:23:19 * EvilTerran reads "specification language" as "type system" :P
16:23:31 <vixey> hehe
16:23:41 <lament> but English and the programming language are not related at all
16:27:37 <nibro> @hoogle Char -> Word16
16:27:38 <lambdabot> No matches, try a more general search
16:27:46 <nibro> @hoogle Char -> Word1
16:27:46 <lambdabot> No matches, try a more general search
16:27:48 <nibro> @hoogle Char -> Word8
16:27:48 <lambdabot> Data.ByteString.Internal.c2w :: Char -> Word8
16:28:02 <nibro> hmm
16:28:55 <nibro> @hoogle Word16
16:28:56 <lambdabot> Data.Word.Word16 :: data Word16
16:30:54 <dmwit> Hello all!
16:30:58 <Bonus> hey guys im reading the monad tutorial
16:31:00 <Bonus> this piece of code
16:31:02 <Bonus> mothersPaternalGrandfather s = (Just s) `comb` mother `comb` father `comb` father
16:31:06 <Bonus> how would this be parenthesised
16:31:17 <Bonus> ltr or rtl?
16:31:34 <dmwit> Default is right-associative, I think.
16:31:43 <Bonus> yeah i thought so
16:31:56 <dmwit> (Just s) `comb` (mother `comb` (father `comb` father))
16:32:10 <ddarius> I don't think it matters for this example.
16:32:29 <vixey> Bonus: where is this code from?
16:32:34 <Bonus> http://www.haskell.org/all_about_monads/html/meet.html
16:32:34 <dmwit> Which tutorial, out of curiosity?
16:32:35 <lambdabot> Title: Meet the Monads
16:32:45 <SamB> @go mothersPaternalGrandfather s = (Just s) `comb` mother `comb` father `comb` father
16:32:47 <lambdabot> http://www.haskell.org/all_about_monads/html/meet.html
16:32:47 <lambdabot> Title: Meet the Monads
16:33:02 <Bonus> i'm starting to understand monads a bit like properly but not fully yet though
16:33:10 <Saizan> it's ltr, unless it can't typechek.
16:33:10 <SamB> vixey, dmwit: you don't know how to google ???
16:33:13 <nibro> any hsc literates in here?
16:33:25 <dmwit> SamB: Didn't think of it.  That's clever. =)
16:34:10 <ddarius> dmwit: Didn't think of Googling?  What kind of programmer are you?
16:34:23 <dmwit> a lousy one =/
16:34:36 <SamB> well, googling isn't always practical
16:34:43 <vixey> one that writes their own code ^-^
16:34:56 <dmwit> vixey: That's what I said. ;-)
16:35:10 <ddarius> vixey: Write it from the metal up?
16:35:20 <Bonus> i thoguht it would be like mothersPaternalGrandfather s = ((((Just s) `comb` mother) `comb` father) `comb` father)
16:35:34 <vincenz> Bonus: sheep!
16:35:37 <vixey> > x `f` y
16:35:37 <SamB> in this instance, I probably thought of it because the code looked rather familiar...
16:35:38 <dmwit> > x `f` y `f` z
16:35:39 <lambdabot>  Add a type signature
16:35:39 <lambdabot>  Add a type signature
16:35:44 <dmwit> > x `f` y `f` z :: Expr
16:35:44 <lambdabot>  Add a type signature
16:35:49 <SamB> @pl x `f` y `f` z
16:35:49 <lambdabot> x `f` y `f` z
16:36:01 <vixey> @pl (x `f` y) `f` z
16:36:01 <lambdabot> x `f` y `f` z
16:36:08 <Bonus> because the combinator takes a Maybe m and a (m -> Maybe m)
16:36:08 <vixey> @pl x `f` (y `f` z)
16:36:08 <lambdabot> x `f` (y `f` z)
16:36:14 <Bonus> and the accessor is the (m -> Maybe m)
16:36:28 <dmwit> I stand corrected.
16:36:41 <Bonus> heh i don't know either :D
16:36:41 <SamB> but isn't comb just >>=, then?
16:36:47 <Bonus> yeah it is
16:36:54 <Bonus> but in this tutorial it's implemented
16:36:58 <Bonus> and then used
16:36:59 <SamB> which is well known to be associated
16:37:03 <SamB> er.
16:37:05 <SamB> or not.
16:37:11 <SamB> and I spelled that wrong
16:37:17 * SamB ... confused with >>
16:37:22 <Bonus> ah yes
16:37:28 <Bonus> as far as I see it's not associative
16:37:44 <vincenz> @pl \x y z f -> x `f` y `f` z
16:37:44 <lambdabot> ((flip . ap id) .) . flip . flip id
16:37:45 <dmwit> (>>=) and (>>) are both left-associative...
16:37:57 <SamB> (>>) has the associative property, though
16:38:00 <dmwit> ?pl \f x y z -> x `f` y `f` z
16:38:00 <lambdabot> (.) =<< (.)
16:38:02 <EvilTerran> >> is associative, >>= isn't
16:38:03 <EvilTerran> >=> is
16:38:19 <dmwit> SamB: Oh, oh.
16:38:20 <ddarius> Bonus: It's type demonstrates that it can't be associative, but it's type demonstrates what associativity it must be for the above code to work.
16:38:27 <SamB> @go >>
16:38:28 <lambdabot> No Result Found.
16:38:34 <SamB> google be lame
16:38:47 <ddarius> @google ">>"
16:38:47 <lambdabot> No Result Found.
16:43:20 <EvilTerran> @go &gt;&gt;
16:43:21 <lambdabot> No Result Found.
16:43:31 <dmwit> ?go ">>"
16:43:31 <lambdabot> No Result Found.
16:43:36 <vixey> @src >>
16:43:36 <lambdabot> m >> k      = m >>= \_ -> k
16:43:47 <vixey> >>= \_ ->
16:43:48 <dmwit> It probably doesn't index weird characters.
16:44:12 <SamB> since when is ">>" wierd?
16:44:24 <ZenGeek> hey anyone knows about IORef s
16:44:25 <dmwit> Well, there's plenty of '>' characters on the web.
16:44:25 <vixey> (>>= o) = (>>= \_ -> o)
16:44:46 <dmwit> vixey: no
16:45:02 <EvilTerran> ?type (.const).(>>=)
16:45:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
16:45:05 <vixey> (o <<) = (>>= \_ -> o)
16:45:19 <dmwit> That would imply "o = \_ -> o", which doesn't seem right for most values of "o".
16:45:25 <dmwit> oh
16:45:26 <EvilTerran> (>>) = (.const).(>>=)
16:45:28 <dmwit> ok =)
16:45:35 <EvilTerran> :D
16:45:48 <EvilTerran> dmwit, or any value - i'm pretty sure that has to have infinite type
16:46:08 <EvilTerran> ?type let o = \_ -> o in o
16:46:09 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t
16:46:09 <lambdabot>     Probable cause: `o' is applied to too few arguments
16:46:09 <lambdabot>     In the expression: o
16:46:10 <dmwit> :t let o = const o in o
16:46:11 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
16:46:11 <lambdabot>     Probable cause: `const' is applied to too few arguments
16:46:11 <lambdabot>     In the expression: const o
16:46:12 <dmwit> yep
16:46:25 <EvilTerran> ?type fix const -- let's make this pointless
16:46:25 <Botje> ZenGeek: chances are someone does. just state your question :)
16:46:26 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
16:46:26 <lambdabot>     Probable cause: `const' is applied to too few arguments
16:46:26 <lambdabot>     In the first argument of `fix', namely `const'
16:57:03 <ZenGeek> hey
16:57:17 <ZenGeek> does anyone know if there is a type called Filename?
16:57:30 <ZenGeek> nm
16:57:31 <Cale> Yeah, it's just a synonym for String
16:57:32 <Saizan> there's FilePath
16:57:41 <Cale> er...
16:57:56 <Cale> yeah, FilePath is :)
16:58:28 <ZenGeek> FilePath is a type?
16:58:36 <ZenGeek> hey Cale.. i didnt want to disturb you
16:58:41 <Cale> yeah, it's a synonym for String
16:58:43 <ZenGeek> thought you were gaming
16:58:53 <Cale> Don't worry, I'm paused :)
16:58:59 <bugQ> Is that just to make function types more descriptive?
16:59:05 <Cale> yeah
16:59:07 <ZenGeek> oh kool.. this save function is giving me hell
16:59:15 <ZenGeek> i didnt with Ref
16:59:22 <ZenGeek> IORef
16:59:29 <dmwit> Hell sounsd bad; give it back.
16:59:39 <ZenGeek> but i ...dont know.. i dont understand
16:59:47 <ZenGeek> okay.. i give it back
17:00:00 <dmwit> ;-)
17:00:09 <dmwit> So, what don't you understand?
17:00:15 <dmwit> IORefs, or something to do with file writing, or...?
17:00:18 <dons> hmm, none of my rewrite rules are firing.
17:00:21 <dons> what's going on.
17:00:30 <EvilTerran> do you need to compile with optimisations on?
17:01:03 <ZenGeek> umm
17:01:15 <ZenGeek> i dont understand IORefs
17:01:27 <ZenGeek> dmwit
17:01:29 <dmwit> IORefs are pointers.
17:01:38 <ZenGeek> how do I use it?
17:02:12 <dmwit> readIORef is the dereference operator for reading, and writeIORef is the dereference operator for writing, I guess.
17:02:34 <Cale> That won't make any sense to a non-C-user.
17:02:37 <lament> ZenGeek: do you know C?
17:02:41 <dmwit> true
17:02:52 <ZenGeek> noo
17:02:56 <dmwit> ZenGeek: What languages do you know?  Any, besides Haskell?
17:02:59 <Cale> Think of an IORef as a box which has some value in it at any particular time.
17:03:05 <EvilTerran> to be more general, they're references. hence the name. :P
17:03:08 <Cale> readIORef will get that value out
17:03:15 <Cale> writeIORef will change the value to something else
17:03:24 <ZenGeek> none besides haskell (which i dont even really know yet)
17:03:29 <lament> in short, it's exactly what you're not supposed to do in Haskell :)
17:03:30 <ZenGeek> okay
17:03:34 <dmwit> Oh!  Okay, great.
17:03:43 <EvilTerran> you might want to avoid IORefs for a while if you're just starting out
17:03:44 <ZenGeek> newRef creates
17:03:54 <dmwit> I was just going to suggest the same thing as EvilTerran.
17:04:00 <Cale> No, in this case, an IORef is the right solution :)
17:04:05 <EvilTerran> there's other, cleaner ways to get similar effects, even in a pure language
17:04:06 <Cale> (I know a little more context :)
17:04:07 <dmwit> IORef's are sort of counter to the Haskell party line.
17:04:09 <EvilTerran> ah
17:04:13 <dmwit> ok
17:04:17 * EvilTerran hands over to Cale
17:04:22 * EvilTerran joins the party line
17:04:25 <EvilTerran> woo, conga!
17:04:31 <bugQ> cha cha cha.
17:04:43 <ZenGeek> i want to save a file
17:04:47 <ZenGeek> like you do in word
17:04:55 <ZenGeek> but i dont want the box to come up
17:05:09 <ZenGeek> ill try the IO.but im not getting it
17:05:26 <Cale> ZenGeek: Well, just try it and see if you have problems :)
17:05:41 <mauke> boxÂ¿
17:05:44 <Cale> ZenGeek: When you do the Save As or load, you'll set the IORef to the current filename
17:06:18 <ZenGeek> but how do i say its an IO
17:06:28 <Cale> ZenGeek: An IO action?
17:06:30 <EvilTerran> Cale, IORefs might be the right solution here, but the sort of problem to which they are might be a bit beyond the abilities of someone just learning to program/learning haskell, is my concern
17:06:31 <ZenGeek> and its tellong me IORef not in scope
17:06:46 <ZenGeek> and i imported DATA.LIST
17:06:50 <Cale> ZenGeek: Make sure that you're importing Data.IORef
17:06:52 <EvilTerran> again, you have more background knowledge than me. ZenGeek may be understating his abilities ;)
17:06:52 <dmwit> ZenGeek: Do you have "import Data.IORef" at the top?
17:06:58 <Cale> Also module names are case sensitive :)
17:07:06 <Cale> Data.List is the name of the list module :)
17:07:09 <fons> ZenGeek, import Data.IORef
17:07:29 <ZenGeek> okay..but still in other parts of the code
17:07:33 <ziman> @pl \x y -> fromIntegral $ (mod `on` round) x y
17:07:34 <ZenGeek> its not in scope
17:07:34 <lambdabot> (fromIntegral .) . (mod `on` round)
17:07:38 <ZenGeek> like for the main frame
17:08:07 <ZenGeek> EvilTerran..im not understating
17:08:45 <EvilTerran> don't worry, i'm just blathering
17:09:09 <EvilTerran> it's gone 1am here.
17:09:25 <ZenGeek> lol you dont have work in the morning?
17:09:57 <EvilTerran> nah. got a meeting in the afternoon, but that's all for tomorrow
17:10:03 <vixey> why not make on an operoter
17:10:04 <EvilTerran> {-# CHANNEL AllowIncoherentEvilTerran #-}
17:10:10 <vixey> then you could write (mod on round)
17:10:23 <EvilTerran> vixey, that's what the ``s are for
17:10:32 <nibro> is toEnum . fromEnum the "correct" way of translating between Char and Word16?
17:10:41 <dmwit> vixey: Feel free to define (*&) = on if you like.
17:10:51 <dmwit> nibro: That depends on what you mean by correctness.
17:11:03 <EvilTerran> operators have to be either alphanumeric characters wrapped in ``s, or punctuation characters
17:11:03 <dmwit> nibro: That will translate the bits, but not do, say, UTF-16 encoding.
17:11:18 <EvilTerran> it's betweEnum!
17:11:56 <nibro> dmwit: I'm trying to write a Storable instance for a hsc struct-like type that contains a String, and should be written as an array of Word16
17:12:00 <ziman> @pl \x y -> exp(y*log(x))
17:12:00 <lambdabot> (exp .) . (*) . log
17:12:18 <vixey> @unpl (exp .) . (*) . log
17:12:18 <lambdabot> (\ d j -> exp ((log d) * j))
17:12:29 <ziman> is there an offline version of @pl?
17:12:30 <nibro> dmwit: And the Word16s represent Unicode characters
17:12:32 <dmwit> nibro: Take a look at the various encoding libraries available on hackage, then, it probably ought to be a UTF-16 string.
17:12:36 <vixey> ?where lambdabot
17:12:36 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
17:12:49 <dmwit> ziman: You can install lambdabot locally.  So, yes.
17:13:01 <nibro> dmwit: thanks, I'll have a look
17:13:12 <EvilTerran> isn't exp(y*log x) = x**y ?
17:13:25 <ziman> i see
17:13:35 <EvilTerran> not that @pl can tell stuff like that
17:13:43 <mauke> @check \x y -> exp(y*log x) == x**y
17:13:44 <lambdabot>  Falsifiable, after 0 tests: 0.0, 0.0
17:13:54 <EvilTerran> it only has a few fairly straightforward transformations
17:14:01 <dmwit> > 0 ** 0
17:14:02 <lambdabot>  1.0
17:14:06 <dmwit> huh
17:14:25 <EvilTerran> > exp 0
17:14:25 <lambdabot>  1.0
17:14:26 <ziman> > log 0
17:14:27 <lambdabot>  -Infinity
17:14:29 <EvilTerran> ... funny
17:14:33 <fons> > 0 ^ 0
17:14:33 <EvilTerran> ah
17:14:34 <lambdabot>  1
17:14:40 <dmwit> > exp (0 * log 0)
17:14:41 <lambdabot>  NaN
17:14:46 <EvilTerran> > 0 * log 0
17:14:47 <lambdabot>  NaN
17:14:51 <dmwit> yeah
17:14:53 <EvilTerran> ay, there's the rub
17:15:13 <EvilTerran> @check \x y -> (x /= 0) ==> (exp (y*log x) == x**y)
17:15:14 <lambdabot>  Falsifiable, after 0 tests: -1.5, -1.0
17:15:33 <EvilTerran> of course, there'll be rounding trouble
17:15:43 <mauke> > log (-1)
17:15:44 <lambdabot>  NaN
17:16:00 <EvilTerran> ah, but of course. as i said, it's late :P
17:16:00 <mauke> @check \x y -> x > 0 ==> exp(y*log x) == x**y
17:16:01 <lambdabot>  Falsifiable, after 7 tests: 1.6666666666666667, 4.8
17:16:05 <dmwit> ?check \x y -> (x > 0) ==> (exp (y * log x) == x ** y)
17:16:06 <lambdabot>  Falsifiable, after 5 tests: 3.0, 0.5
17:16:10 <EvilTerran> aaand there's your rounding errors
17:17:58 <dons> Igloo2: ah! i need -fglasgow-exts to enable rewrite rules in the local code.
17:18:09 <dons> Igloo2: there's no RewriteRules pragma , is there?
17:20:28 <Igloo2> dons: What happens if you don't use -fglasgow-exts?
17:20:49 <dons> Igloo2: no rewrite rules get used in code that uses the library
17:21:18 <nibro> dmwit: I'm looking at the Encode package, and it seems to suggest that toEnum . fromEnum is the way to go :\
17:21:36 <nibro> http://hackage.haskell.org/packages/archive/Encode/0.7/doc/html/Encode.html
17:21:40 <lambdabot> http://tinyurl.com/6ex9bo
17:21:40 <Igloo2> dons: That's odd. -fglasgow-exts only turns on LANGUAGEs, but I didn't think there was one for rules
17:22:13 <dons> i remember now that you do need it for rules.
17:22:20 <dons> i think that's mentioned on the rules wiki page
17:22:46 <dmwit> nibro: yuck =/
17:22:50 <mauke> is ghc's error output format documented anywhere?
17:23:13 <dons> nibro: is it optimised away?
17:23:44 <dmwit> dons: That's beside the point, this is for converting Char -> Word16.
17:23:59 <nibro> dons: what dmwit said :-)
17:24:15 <dons> oh, instead of fromIntegral . ord
17:24:16 <dons> ?
17:24:33 <dmwit> dons: To deal with Unicode properly...
17:24:40 <gwern> @seen Cale
17:24:41 <lambdabot> Cale is in #haskell-overflow, #haskell-blah, #ghc and #haskell. I last heard Cale speak 17m 34s ago.
17:24:47 <nibro> dons: I'm looking for the "correct" way to represent a unicode Char as a C-like Word16
17:24:57 <dons> oh, 'encode' is the problem
17:24:59 <dons> i see.
17:25:07 <gwern> Cale: oy, your nymphaea got linked: http://www.kennknowles.com/blog/2008/04/16/drawing-fractals-in-haskell-with-a-cursor-graphics-dsel-and-a-cute-list-representation/
17:25:07 <lambdabot> Title: Mathematical Pamphlet » Drawing fractals in Haskell with a cursor graphics DSEL  ..., http://tinyurl.com/6gzfgp
17:25:10 <dmwit> nibro: Try the "encoding" package.
17:25:14 <nibro> dons: well, decode as well
17:25:22 <dmwit> nibro: It has a Data.Encoding.UTF16 module, which sounds promising.
17:25:52 <nibro> dmwit: indeed it does, I'll have a look at that, thanks
17:28:18 <gwern> dons: I saw somewhere in the darcs comments that lazy bytestrings give you O(1) appends/concatenation; true?
17:28:39 <nibro> dmwit, dons: encode :: enc -> String -> ByteString
17:28:59 <nibro> can a ByteString really represent Word16 faithfully?
17:29:00 <dmwit> nibro: Yeah, it seems like you'll need to know your endianness with that library.
17:29:21 <dmwit> nibro: ByteString models [Word8], but two Word8's gets you a Word16. ;-)
17:29:22 <nibro> dmwit: how would I know that? :-)
17:29:55 <nibro> dmwit: ah, of course :-D
17:30:07 <dmwit> nibro: This is starting to sound like a lot of work, huh? =P
17:30:20 <dons> gwern: they give you O(n/k) appends/concat
17:30:27 <nibro> dmwit: this is for a low-level binding to part of the Win32 API, it's already a lot of work ;-)
17:30:27 <dons> where k = 32k
17:30:55 <vincenz> infinite loop
17:30:56 <nibro> dmwit: how would I know my endianness?
17:31:00 <gwern> dons: ah. that takes into account the forcing per 32k chunk then
17:31:03 * nibro is not a C programmer...
17:31:32 <dmwit> ?go detect endianness
17:31:34 <lambdabot> http://www.rdesktop.org/archive/2001/msg00720.html
17:31:34 <lambdabot> Title: Re: "endian.h" and portability
17:31:46 <nibro> ooh, nifty :)
17:32:52 <nibro> except of course that didn't contain any info I needed... =P
17:33:39 <dmwit> Yeah, it sure doesn't show how to do it in Haskell, eh?
17:34:42 <nibro> dmwit: when does anything ever? :-(
17:34:43 <SamB> dons: don't you mean O(length of spine)?
17:37:00 <nibro> dmwit: at least now I've learnt that endianness comes from Gulliver, always something :)
17:37:08 <dmwit> heh
17:37:37 <dmwit> There's a rather long thread on Haskell cafe about this, actually.
17:38:57 <nibro> really?
17:39:16 <dancor> is yhc->js the cool way to do client-side web stuff
17:39:18 <nibro> I just found something saying that Windows is designed to run on little-endian architectures
17:39:31 <dmwit> dancor: It's certainly the slow way to do client-side web stuff.
17:39:56 <nibro> dancor: HSP for the win! :-D
17:40:26 <dancor> those are the only two options right, unless you give up and just use js or flash, right?
17:40:52 <nibro> I don't know of any others out there
17:41:24 <dons> yes, length of spine, which can be approximated by the n/k number
17:41:49 <nibro> dmwit: is windows always little-endian?
17:41:56 <dmwit> nibro: I don't know.
17:43:01 <dmwit> nibro: Once you do know the endianness, Data.Binary.(Get|Put) seems to have primitives for dealing with ByteString's, though.
17:43:12 <nibro> dmwit: ooh, interesting
17:43:37 <nibro> dmwit: I think I'll just have to try it with little endian and see what happens :)
17:43:44 <dmwit> nibro: This discussion may be interesting to you: http://www.haskell.org/pipermail/haskell-cafe/2007-September/thread.html#31594
17:43:44 <lambdabot> Title: The Haskell-Cafe September 2007 Archive by thread, http://tinyurl.com/68hx2v
17:43:53 <gwern> > "\"" ++  show "\"foo bar\\ bar bar\"" ++ "\""
17:43:54 <lambdabot>  "\"\"\\\"foo bar\\\\ bar bar\\\"\"\""
17:44:03 <gwern> > "\"\"\\\"foo bar\\\\ bar bar\\\"\"\""
17:44:04 <lambdabot>  "\"\"\\\"foo bar\\\\ bar bar\\\"\"\""
17:46:25 <nibro> dimwit: thanks, that was somewhat enlightening
17:46:33 <nibro> oops
17:46:59 <nibro> late night (non-)freudian slip I guess... ;-)
17:47:08 <dmwit> =)
17:47:19 <nibro> dmwit: though I guess you must be used to it :-)
17:47:22 <dmwit> Don't worry, the similarity is intentional.
17:47:26 <dmwit> yep =)
17:47:42 <nibro> dmwit: I figured you would have picked it on purpose
17:48:17 <fons> > typeOf (
17:48:17 <lambdabot> Unbalanced parentheses
17:48:26 <fons> > typeOf True
17:48:27 <lambdabot>  Bool
17:48:53 <dmwit> :t True
17:48:54 <lambdabot> Bool
17:48:57 <dons> ?bug
17:48:57 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
17:51:32 * dmwit is mildly surprised there is no System.isBigEndian :: IO Bool.
17:54:51 <wagle> no enum to specify big, middle, little?
17:55:20 <nibro> hmm, Data.Binary.Get supplies a getWord16le :: Get Word16, but why doesn't it provide a readAsWord16le :: ByteString -> [Word16]?
17:55:33 <nibro> strange interface :-)
17:56:57 <nibro> @ty while
17:56:57 <dmwit> wagle: What's middle-endian?
17:56:58 <lambdabot> Not in scope: `while'
17:57:04 * dmwit goes googling again
17:57:06 <nibro> @ty whileM
17:57:07 <lambdabot> Not in scope: `whileM'
17:57:07 <wagle> @go middle-endian
17:57:08 <lambdabot> http://en.wikipedia.org/wiki/Endianness
17:58:46 <dmwit> Sure, let's have an Endianness data type, I'm fine with that.
17:59:21 <EvilTerran> dmwit, the american date syntax is middle-endian
17:59:30 <dmwit> yeah =/
17:59:33 <gwern> how I hate middle-endianness
17:59:43 * EvilTerran uses ISO dates wherever he can
17:59:44 <dmwit> That's why I never use American date syntax, despite living in America.
18:00:01 <EvilTerran> wholly unambiguous, as no-one uses yyyy-dd-mm
18:00:13 <EvilTerran> and it sorts nicely :)
18:00:18 <dmwit> yep =)
18:00:36 <lament> i am, starting 2008-16-04
18:01:08 <dmwit> ~% sed '3!d' todo
18:01:08 <dmwit> 080418  2000 2200 EAST house            open house for priority residents
18:01:12 <nibro> dmwit: I'll keep laboring tomorrow, thanks for all the help :)
18:01:19 <dmwit> Makes for a very handy vim-based calendar app. =)
18:01:28 <gwern> EvilTerran: I don't like it; raises a Y10k problem, starting with an unbounded number
18:01:42 <EvilTerran> :P
18:01:56 <EvilTerran> putting it anywhere else would cause just as much trouble
18:02:14 <EvilTerran> unless you want to put a two-digit exponent before the year or something
18:02:21 <gwern> that's why small-endian makes more sense; at least the initial values will always be bounded - there are only so many days and months
18:02:22 <dmwit> null-terminated year?
18:02:26 <EvilTerran> 04-2008-04-16
18:02:51 * wagle starts using ["0"..] ++ "2008" for years
18:03:17 <dmwit> EvilTerran: Well, that just makes a Ygoogol problem... ;-)
18:03:36 <gwern> EvilTerran: well, it'd make more sense in a left-to-right writing system to have numbers go smallendian - instead of ...00000002008 CE, it'd be 800200000...., so you could go '9/10/20000000998987 CE'
18:03:42 <dmwit> Actually, I'm in favor of having a Ygoogol problem, what could be better than mixing Goggle and the Y combinator?
18:04:15 <EvilTerran> 03-476-09-04 -- fall of the roman empire
18:04:18 <gwern> (not that we or our systems'll be around to see the problem)
18:05:09 <dmwit> I think there's actually an April Fool's RFC about dealing with unbounded date sizes in a backwards-compatible way.
18:05:27 <gwern> neat. ln pls?
18:05:41 <dmwit> RFC 2550
18:06:22 <gwern> 'RFC 2550 (rfc2550) - Y10K and Beyond
18:06:24 <gwern> nice
18:06:37 <EvilTerran> 05-31???-??-?? -- horus heresy
18:06:38 <EvilTerran> etc
18:06:39 * dmwit has The Complete April Fool's Days RFCs
18:07:09 <haskelln00b> congrads
18:07:32 <gwern> 'Unfortunately, the current fixes for Y2K lead inevitably to a crisis in the year 10,000 when the programs are again designed to fail.' <-- strangely, '99 was the same year Stewart Brand wrote in The Clock of the Long Now that we should try writing 02008, to encourage long-term thinking
18:07:52 <EvilTerran> i guess you could put enough digits in the exponent that all current models of the universe predict its annihilation in a tiny fraction of the number of years representable
18:08:25 <dmwit> We'll be in a less material world by then.
18:08:30 <gwern> EvilTerran: horus heresy? man, that's so geeky
18:09:02 <EvilTerran> gwern, nyah. it was the first example of a five-figure date that sprang to mind
18:09:12 <EvilTerran> but, yes, i *am* so geeky. :D
18:09:14 <gwern> which says something...
18:09:42 * EvilTerran never even properly collected warhammer or 40k or whatever
18:09:42 <dmwit> EvilTerran: ??? -- one year before Christ was born
18:09:59 <EvilTerran> i have a half-finished imperial guard army, but that's all...
18:10:45 <EvilTerran> dmwit, / is the character ASCIIbetically before 0, we can use that as a "-1" digit :P
18:10:57 <lament> 02008 is funny
18:11:01 <dmwit> eeeew
18:11:11 <dmwit> I say we just don't talk about dates at all.
18:11:16 <dmwit> That will save a lot of heartache.
18:11:27 <lament> also, for some reason when people write binary numbers, they tend to put a bunch of zeros in front
18:11:31 <lament> as in 00000101
18:11:41 <EvilTerran> which'd give us 02-/9-mm-dd
18:11:42 <gwern> 'As discussed in 2.4.1, the end of the universe is predicted to occur well before the year 10 ** 30.  However, if there is one single lesson to be learned from the current Y2K problems, it is that specifications and conventions have a way of out living their expected environment.  Therefore we feel it is imperative to completely solve the date representation problem once and for all.'
18:11:55 <lament> <3
18:12:11 <lament> 10 ** 30 years should be enough for anybody!
18:12:47 <mrd> what's the expected halflife of a proton?
18:13:12 <lament> it's never been observed
18:13:16 <lament> so there's only a _lower_ bound
18:13:16 <mrd> ya just speculated :)
18:13:19 <saml> how can I detect if fail is called or not in a monad?
18:13:44 <lament> but apparently 10^36 years in some theories
18:13:48 <dmwit> saml: It depends on the monad.
18:13:53 <gwern> mrd: oh sure, like we'll still be using proton-based computers at that point
18:14:16 <dons> "Recent experiments at the Super-Kamiokande water Cherenkov radiation detector in Japan indicate that if protons decay at all, their half-life must be at least 10^35 years."
18:15:33 <dons> protons are the basis for purely functional, side-effect free programming :)
18:15:33 <lament> proton decay is unpleasant
18:15:50 <lament> it implies a very boring end for the universe
18:16:38 <dolio> Pfff. Just feed them into a magnetic monopole.
18:16:43 <dolio> Then they go boom.
18:17:05 <dons> heh
18:17:21 * EvilTerran is more bothered by the Big Rip interpretation
18:17:23 <SamB> we should just write 00002008-04-16
18:17:31 <saml> ah. i think I probably want throwError instead of fail
18:17:48 <EvilTerran> ?hoogle throwError
18:17:55 <lambdabot> Control.Monad.Error.Class.throwError :: MonadError e m => e -> m a
18:18:05 <EvilTerran> that seems plausible
18:18:07 <EvilTerran> or maybe mzero
18:19:49 <SamB> lol @ "YXK problem"
18:23:49 <mib_4fycgt> any uwi students in here?
18:51:13 <SamB>    5) Survivability of dates past the end of the universe is uncertain.
18:54:02 <gwern> SamB: I like that one. it takes the over-engineering to the max
18:54:26 <gwern> 'Yeah, but can your date system REPRESENT DATES WHEN TIME STOPS?!11'
18:54:48 <SamB> if it were truly overengineered, they would have figured out how to make sure the dates would survive past the end of the universe
19:01:26 <sw17ch> SamB: so, does this assume the end of the universe is due to Heat Death or The Big Rip?
19:05:49 <brothers> sw17ch: overflow in the date format causes the end of the universe
19:05:55 <brothers> talk about fail fast
19:11:28 <saml> f = do { i <- get; put (i+1);  return ... }    what should be the type of f ?
19:11:33 <mm_freak_> @pl \x -> f (flip g x)
19:11:33 <lambdabot> f . flip g
19:11:42 <saml> f :: MonadState Integer MyType ?
19:11:57 <vixey> saml: Why don't you let the compiler tell you?
19:12:06 <saml> vixey: it says ambiguous
19:12:21 <saml> it cannot infer type of i i think.
19:12:27 <vixey> hm
19:13:43 <mm_freak_> @pl \i -> map (flip rotateL i)
19:13:43 <lambdabot> map . flip rotateL
19:14:14 <mm_freak_> hmmâ€¦  that gives me a compiler error, while my original version runs fine
19:15:15 <vixey> mm_freak_: Monomorphismagic?
19:16:05 <mm_freak_> vixey: -v
19:16:59 <vixey> ?
19:17:10 <saml> to create a monad that uses State and Error monad, do I have to use monad transformers?
19:22:13 <solrize> anyone know if there is a way to pass a -L option to the cabal setup.hs build operation?
19:22:42 <gwern> solrize: a ldd option?
19:22:49 <solrize> err, where?
19:22:53 <solrize> i mean to tell it where to get a library from
19:23:02 <solrize> ghc -Lwherever
19:23:09 <gwern> solrize: ld-options: isn't appropriate?
19:23:22 <solrize> i don't see anything about that in the help text
19:23:24 <solrize> i'll try it
19:23:25 <solrize> thanks
19:23:50 <solrize> didn't help
19:24:09 <solrize> i may not have done it right though
19:24:10 <gwern> fwiw, darcs configure scripts generate 'ld-options:  -lcurl -lz -L/usr/lib64 -lgnutls -L/usr/lib64 -ltasn1 -L/usr/lib64 -lgcrypt -lgpg-error' for linking, to give you an idea of format
19:24:31 <solrize> hmm
19:24:46 <solrize> i tried passing --ld-options=-Llocation on the setup.hs command line
19:24:48 <gwern> or you might want 'extra-libraries:'
19:25:06 <saml> how can I instanciate MonadError ?  instance MonadError String MyType where wont' do
19:25:54 <solrize> hmm
19:25:59 <gwern> anyone here a c expert? you know why 'static const char user_agent[] =
19:26:00 <gwern> -  "darcs/" PACKAGE_VERSION " libcurl/" LIBCURL_VERSION;
19:26:04 <gwern> might cause problems?
19:26:24 <gwern> which look like './src/hscurl.c:43: error: expected â€˜,â€™ or â€˜;â€™ before â€˜PACKAGE_VERSIONâ€™'
19:26:42 <solrize> it doesn't recognize --extra-libraries
19:26:59 <solrize> but it's interesting, it means --ld-options is recognized, since it didn't complain about that
19:30:04 <Saizan> is there a flag to improve support for impredicativity?
19:30:28 <solrize> gwern i don't think i understand the darcs stuff, i'm just trying to compile a library from hackage
19:30:32 <solrize> o,[erdocatovotu
19:30:36 <solrize> oops
19:30:58 <gwern> solrize: oh, why didn't you say so. which one?
19:31:15 <solrize> codecs/Crypto-4.1.0
19:31:59 <solrize> actually i really sort of have my ghc misconfigured, i wonder if i can do something about that
19:32:05 <Saizan> saml: MyType has to be a monad, and you need some extensions enabled, like FlexibleInstances, MultiParameterTypeClasses, maybe others
19:32:17 <gwern> solrize: what's the error?
19:32:31 <solrize> /usr/bin/ld: cannot find -lgmp
19:32:50 <solrize> i have the gmp .so files in my ~/hs directory so i want to tell the linker to look there
19:33:38 <gwern> solrize: hm. I know of hs-source-dirs, and include-dirs, but not sure about link dirs
19:33:47 <solrize> hmm
19:34:17 <solrize> it does like --ld-options
19:34:28 <daveux> Can anyone help us get Haskore running?
19:35:54 * gwern shudders a little. unless henning finally got around to updatuing haskore for 6.8.x, I don't want to try
19:36:47 <solrize> http://www.haskell.org/pipermail/libraries/2007-April/007449.html  hmm
19:36:47 <lambdabot> Title: cabal ignores ld-options?
19:37:18 <daveux> we can load Haskore into ghci just fine
19:37:23 <daveux> we just can't make anything play
19:37:54 <daveux> SOE recommends that we run hugs and define testLinux :: Music -> IO () or some crap.
19:40:49 <solrize> is there a standard way to deal with this kind of stuff?  or does every installation script just assume that the user has root on the target box and is willing to install stuff in system directories?  the latter is annoying.
19:41:04 <daveux> gwern, do you know anyone with Haskore experience?
19:41:12 <daveux> We just need to get it playing something/....
19:42:13 <gwern> daveux: just the maintainer
19:42:27 <daveux> can you put me in touch, please?
19:42:40 <solrize> oh i see, there's a much bigger doc page for cabal
19:42:59 <newsham> do you know why it is failing, daveux?  strace might be helpful, if is just a file perimssion type issue.
19:43:12 <daveux> no failure, we just don't know what to do!
19:43:38 <daveux> We're asked to define some function testLinux, which refers to some function test... we can't find where these functions are or how we define them....
19:43:38 <newsham> oh i think i confused what you said with what solrize said.
19:44:04 <gwern> daveux: the cabal file should list henning's address
19:44:07 <gwern> or the README
19:44:13 <solrize> sorry, i don't know anything about haskore beyond having seen some descriptions in HSOE
19:44:13 <daveux> ok
19:44:34 <Saizan> ?seen augustss
19:44:34 <lambdabot> I saw augustss leaving #haskell 16h 37m 52s ago, and .
19:45:13 <Saizan> anyone have a link for augustss's lambda cube type checker/intepreter?
19:45:49 <Saizan> oh, found it
19:45:58 <newsham> daveux: the PS file on the website defines testLinux
19:46:04 <daveux> ok
19:46:11 <newsham> (the web site also says the html tutorial is out of date, you're not using that are you?)
19:46:28 <daveux> We're using many pairwise contradictory tutorials
19:46:32 <newsham> testLinux m = do { test m; system "playmidi -rf test.mid"; return () }
19:46:42 <daveux> yeah, we saw that... now we need to find test
19:46:51 <gwern> hm. what hackage category should darcs go into?
19:46:56 <gwern> Development?
19:47:05 <newsham> test m = outputMidiFile "test.mid" (testMidi m)
19:47:10 <newsham> just a page previous
19:47:12 <daveux> yes, just found that
19:47:12 <gwern> System might make sense
19:47:20 <gwern> or Text
19:48:17 <newsham> daveux: did you see tutorial.lhs in the src directory?
19:48:30 <newsham> its the whole tutorial in literate haskell format
19:48:37 <daveux> Thank you, we didn't see that.
19:48:56 <daveux> Now we need to debug this playmidi binary...
19:48:58 <solrize> aha!   --ghc-options="-L$HOME/hs" did it.
19:57:30 <brad__`> okay i preordered "real world haskell"
19:57:40 <brad__`> my only request: no lame cover
19:58:07 <lament> o'reilly animal-engraving style lambda potato!
19:58:21 <brad__`> the gnu folks have the right idea, just some understated text and a mildly elitist drawing
19:59:03 <brad__`> but please, no wrox-style giant pics of the authors
19:59:10 <brad__`> and no exclamation marks
19:59:29 <solrize> those would be strict constructors
19:59:33 <brad__`> and no copy claiming "direct information from the world's leading developers!!!"
19:59:33 <lament> and no ugly fractal patterns
19:59:39 <byorgey> Real World :: !Haskell
19:59:48 <solrize> yeah
20:00:18 <lament> otoh it's just the cover
20:00:23 <lament> SICP doesn't exactly have the best cover ever
20:00:34 <lament> K&R does, though
20:00:35 <brad__`> agreed lament
20:01:23 <brad__`> no i get to put in my two cents on the cover, after all this fricking book was 49.99!!! thats almost unheard of for a softcover tech book these days
20:01:35 <brad__`> so for my 50.00 preorder, i get to say "no lame cover"
20:02:01 <solrize> 49.99 is almost unheard of because most others cost more :((
20:02:26 <brad__`> if it weren't for the authors, i wouldn't have even bought it, the idea of tech books is so...1996
20:02:27 <solrize> Word160 is not an Integral?   hmm.
20:02:56 <newsham> where does one preorder RWH?
20:03:00 <solrize> spamazon
20:03:01 <brad__`> amazon
20:03:04 <brad__`> just search for it
20:03:11 <jeffz> http://reddit.com/r/programming/info/6fxll/comments/
20:03:37 <vincenz> googlezon
20:05:19 <solrize> the reddit thread is funny
20:05:39 <newsham> shouldnt the cover be a lamma?
20:11:12 <solrize> hmm, Data.Digest.SHA1 has a toInteger function that conflicts with the prelude function of the same name... is there a way to get that one without having to spell it out everywhere?
20:11:39 <solrize> i.e. "import Data.Digest.SHA1 renaming toInteger as shaInteger"   equivalent?
20:11:49 <newsham> import Other.Module hiding(toInteger)
20:11:57 <solrize> thanks
20:12:10 <newsham> or import qualified Data.Digest.SHA1 as S    and use S.toInteger ?
20:12:22 <newsham> or use  Data.Digest.SHA1.toInteger?
20:12:24 <solrize> yeah i thought of that, but it means i then have to use S.hash etc
20:12:34 <solrize> Data.Digest.SHA1.toInteger is the extra typing i wanted to avoid
20:12:50 <newsham> I think you can import it twice, once "qualified" and once not.
20:12:53 <roconnor> There should be a flag to make unqualified and non-explict imports a compile error, and cabal should use that flag.
20:12:55 <solrize> oh that would do it
20:12:55 <newsham> so you can do S.toInteger and hash.
20:13:19 <newsham> but hiding may be easiest
20:13:40 <solrize> next is how do i convert a string to [Word8]?
20:14:01 <newsham> ... or define     ti = Data.Digest.SHA1.toInteger and use "ti" instead?
20:14:15 <solrize> oh good point, thanks
20:14:16 <roconnor> solrize using what encoding?
20:14:24 <newsham> pack :: String -> B.ByteString
20:14:24 <newsham> pack xs = B.pack $ map (fromIntegral.fromEnum) xs
20:14:25 <newsham> ?
20:14:33 <solrize> roconnor, let's say utf8
20:14:44 <solrize> hmm
20:14:55 <newsham> err, wait, you just want [word8],  thats the fromIntegral.fromEnum part
20:15:22 <solrize> > liftM (fromIntegral.fromEnum) "foobar" :: [Word8]
20:15:26 <lambdabot>  [102,111,111,98,97,114]
20:15:29 <solrize> aha
20:15:30 <solrize> thanks
20:15:31 <newsham> > fromIntegral (fromEnum 'c') :: Word8
20:15:32 <lambdabot>  99
20:15:47 <roconnor> solrize: that's not utf8, unless it is all ascii characters
20:16:20 <newsham> yah you need encoding for utf8
20:16:29 <solrize> hmm, how do i do that?
20:16:37 <newsham> with some utf8 codec?
20:16:49 <solrize> yeah i guess i have to find that
20:16:56 <solrize> i like to think this will all be easy someday
20:16:59 <solrize> thanks
20:17:00 <newsham> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string-0.3
20:17:02 <lambdabot> http://tinyurl.com/67hepr
20:18:17 <newsham> yah, tis too bad all the IO isnt over [Word8] with predefined codecs for ascii, utf8, etc..
20:19:39 <vincenz> :t ap
20:19:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
20:20:29 <newsham> > ap [(+1), (*2)] [4,5]
20:20:30 <lambdabot>  [5,6,8,10]
20:20:54 <solrize> newsham it would be nice if Data.Char had all those codecs
20:21:05 <sw17ch> where does uncurry get it's name from?
20:21:17 <roconnor> sw17ch: it's the opposite of curry
20:21:18 <solrize> sw17ch you understand currying?
20:21:24 <roconnor> @type curry
20:21:25 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
20:21:29 <sw17ch> solrize: i think i do
20:21:44 <roconnor> @check uncurry . curry = id
20:21:44 <lambdabot>  Parse error at "=" (column 17)
20:21:49 <roconnor> @check uncurry . curry === id
20:21:51 <lambdabot>   Not in scope: `==='
20:21:53 <solrize> sw17ch  f (x,y)   in curried form is   f x y
20:22:20 <solrize> :t uncurry
20:22:21 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
20:22:23 <sw17ch> so currying really is just a matter of making tuples into... whatever that's called
20:22:34 <newsham> ?let tflip (a,b) = (b,a)
20:22:35 <lambdabot> Defined.
20:22:43 <newsham> > curry tflip 3 4
20:22:44 <lambdabot>  (4,3)
20:22:52 <newsham> > tflip (3,4)
20:22:53 <lambdabot>  (4,3)
20:23:20 <sw17ch> uncurry (+) (1,2)
20:23:22 <sw17ch> > uncurry (+) (1,2)
20:23:23 <lambdabot>  3
20:23:25 <sw17ch> ah, i see
20:23:31 <newsham> ?src curry
20:23:31 <lambdabot> curry f x y = f (x, y)
20:23:33 <shachaf> @ty (uncurry.flip.curry) id
20:23:34 <lambdabot> forall a b. (b, a) -> (a, b)
20:23:34 <sw17ch> curry (+) 1 2
20:23:34 <newsham> ?src uncurry
20:23:34 <lambdabot> uncurry f p = f (fst p) (snd p)
20:23:37 <sw17ch> > curry (+) 1 2
20:23:37 <lambdabot>   add an instance declaration for (Num (a, b))
20:24:01 <sw17ch> > curry (fst) 1 2
20:24:02 <lambdabot>  1
20:24:05 <sw17ch> oic
20:24:24 <sw17ch> that's a lot simpler than the name implies to a newbie :P
20:24:50 <newsham> the uncurried form takes both args at once as a tuple.
20:24:50 <sw17ch> (i've been doing this for about a year, am i still a newbie?)
20:25:03 <newsham> the curried form takes the args one at a time
20:28:27 <sw17ch> btw, who's responsible for @pl?
20:28:51 <roconnor> maybe Curry.
20:29:03 <roconnor> Did he prove that lambda calculus can be translated to combinators?
20:29:10 <solrize> :t unhoward
20:29:11 <lambdabot> Not in scope: `unhoward'
20:29:13 <solrize> darn
20:29:18 <sw17ch> well, whoever made it... i'm hoping i can buy them a drink or something some day :)
20:29:55 <kfish> roconnor, not quite
20:30:17 <solrize> i think there's a paper about @pl
20:30:56 <newsham> darcs changes shows twanvl and sjanssen making the most recent changes
20:31:08 <newsham> but several other contributors
20:31:28 <solrize> you've also got to try @djinn
20:31:38 <solrize> @djinn a -> a
20:31:44 <lambdabot> f a = a
20:31:50 <vixey> roconnor: hahaha
20:31:50 <saml> :/exit
20:31:57 <roconnor> @djinn ((a,b) -> c) -> a -> b -> c
20:31:57 <lambdabot> f a b c = a (b, c)
20:32:10 <roconnor> @. djinn type uncurry
20:32:11 <lambdabot> f a (b, c) = a b c
20:32:28 <vixey> @remember <sw17ch> btw, who's responsible for @pl? <roconnor> maybe Curry. Did he prove that lambda calculus can be translated to combinators?
20:32:28 <lambdabot> It is stored.
20:34:01 <newsham> ?djinn ((a,b) -> c) -> Either (a -> c) (b -> c)
20:34:01 <lambdabot> -- f cannot be realized.
20:34:02 <sw17ch> Haskell's the first language that has constantly surprised me with what it can do even after a year of working with it
20:34:30 <newsham> ?djinn ((Either a b) -> c) -> (a -> c, b -> c)
20:34:30 <lambdabot> f a = (\ b -> a (Left b), \ c -> a (Right c))
20:34:56 <Saizan> sw17ch: so true!
20:34:57 <vixey> what's new sw17ch?
20:35:09 <OceanSpray> What's the deal with _|_ and infinite recursion?
20:35:23 <vixey> oh @pl
20:35:48 <sw17ch> I just leaned about liftIO and I'm finally getting the hang of =<< and >>= and friends... and suddenly things are just so plain...
20:35:56 <sw17ch> but @pl and Eval astonished me :)
20:36:04 <Saizan> OceanSpray: _|_ read as bottom, is the value representing non-termination in denotational semantic
20:36:09 <sw17ch> > foldr (+) 1 [1..5] :: Expr
20:36:09 <lambdabot>  1 + (2 + (3 + (4 + (5 + 1))))
20:36:22 <OceanSpray> > _|_
20:36:22 <lambdabot>  Parse error at "|_" (column 2)
20:36:26 <OceanSpray> lol
20:36:33 <sjanssen> OceanSpray: what's the deal with them?  They're equivalent
20:36:38 <Saizan> it's not valid haskell syntax
20:36:46 <sjanssen> if you mean non-termination rather than infinite recursion
20:36:55 <newsham> > undefined
20:36:56 <lambdabot>  Undefined
20:37:00 <sw17ch> also, some of the methods near the bottom of this (http://www.willamette.edu/~fruehr/haskell/evolution.html) just baffle me
20:37:00 <lambdabot> Title: The Evolution of a Haskell Programmer
20:38:16 <solrize> heh yeah they are supposed to be obscure
20:38:26 <newsham> what's the value of (fact 0 = 1; fact n = n * fact (n - 1)) when the first arg is -1?
20:38:38 <solrize> _|_
20:38:41 <vixey> newsham: It doesn't have a value in that case
20:39:32 <vixey> hm
20:39:40 <vixey> _|_ counts as a value?
20:39:48 <vixey> I thought it was like infinity
20:39:55 <shachaf> > let x = undefined in 5
20:39:56 <lambdabot>  5
20:39:58 <vixey> (a symbol with meanings but not a number)
20:40:10 <newsham> ?type undefined
20:40:11 <lambdabot> forall a. a
20:40:15 <shachaf> vixey: He didn't say "number". :-)
20:40:18 <newsham> bottom has whichever type you want
20:40:21 <newsham> including number :)
20:40:22 <solrize> it's like a black hole, your program fails if you actually try to compute it
20:40:33 <shachaf> I think this would have a value with some Num types, though.
20:40:36 <vixey> @src undefined
20:40:36 <lambdabot> undefined =  error "Prelude.undefined"
20:40:46 <newsham> > 3 + undefined
20:40:46 <lambdabot>  Undefined
20:40:50 <solrize> if you want a thorough explanation, the best one i know of is here: http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
20:40:50 <vixey> undefined = undefined -- is another definition
20:40:53 <newsham> > '3' : undefined
20:40:53 <lambdabot>  Undefined
20:41:29 <newsham> > let u = u in u
20:41:29 <lambdabot>  Exception: <<loop>>
20:41:44 <newsham> ?type let u = u in u
20:41:45 <lambdabot> forall t. t
20:42:05 <shachaf> > let fact :: Int8 -> Int8; fact 0 = 1; fact n = n * fact (n - 1) in fact (-1) -- newsham: For example.
20:42:05 <lambdabot>  0
20:42:25 <newsham> ?type fix id
20:42:27 <lambdabot> forall a. a
20:43:02 <newsham> > 3 + fix id
20:43:03 <lambdabot>  Exception: <<loop>>
20:45:34 <sw17ch> my senior project is almost done...
20:45:45 <sw17ch> i'm down to arguing with Gtk, Pango, and Cairo
20:54:07 <newsham> whats the project and which lang?
20:55:51 <sw17ch> Language is haskell
20:56:05 <sw17ch> Project is a scope sensitive call reference graph
20:56:08 <sw17ch> i'm analyzing lisp/scheme
20:56:20 <sw17ch> err... scope sensitive reference craph
20:56:23 <sw17ch> graph*
20:56:24 <newsham> static analysis?  dynamic?
20:56:49 <sw17ch> it's fairly static... it's more a proof of concept than actually being really smart
20:57:30 <sw17ch> right now all it does is look the common lisp defun symbol and saves off the symbol name
20:57:46 <sw17ch> given that this is a two credit deal, it was hard to do anything too sophisticated
20:57:50 <solrize> does anyone here maintain the ghc trac?  i think i have an account on the thing but am not sure how to check
20:58:31 <sw17ch> but what i have now is the ability to take a list as a scope and then plot out references from that scope's point of view
20:58:39 <sw17ch> it's a bit kludgy though
20:59:04 <OceanSpray> Haskell's let ... in ... is analogous to Scheme's letrec.
20:59:17 <sw17ch> yes?
20:59:18 <OceanSpray> Is it possible to implement letrec in Haskell as a function?
21:00:07 <OceanSpray> well, you know what I mean.
21:00:13 <Saizan> well, you can use let to implement fix
21:00:16 <newsham> > let fact = fix (\f n -> if n == 0 then 1 else n * f (n-1)) in fact 5
21:00:16 <lambdabot>  120
21:00:22 <newsham> like that you mean?
21:00:26 <vixey> OceanSpray: no
21:00:41 <OceanSpray> lemme restate that.
21:00:44 <vixey> 'let' exists and works similarly to schemes letrec though
21:00:47 <newsham> or do you mean you're somehow passing in code with unbound vars to a letrec function?
21:00:59 <dolio> You can't inroduce new variable binding forms without something like macros.
21:01:01 <OceanSpray> actually, nevermind this question, since Haskell has no macros.
21:01:13 <Saizan> and you can also implement fix with only lambdas + a recursive newtype
21:01:16 <newsham> maybe what you want is the "fix" fixed point operator?
21:01:35 <OceanSpray> Oy, forget it.
21:01:42 <OceanSpray> The question was stupid to begin with.
21:03:04 <dolio> You'd also probably have trouble getting let to be appropriately polymorphic, even if you had macros (assuming you're translating let v = x in e into (\v -> e) x).
21:04:09 <newsham> (what about TemplateHaskell?)
21:04:39 <dolio> Yeah, well, TH doesn't let you define new syntax.
21:04:41 <solrize> http://hackage.haskell.org/trac/ghc/ticket/2225   attempt to install encoding module failed
21:04:48 <dolio> So it'd look ugly. :)
21:04:49 <lambdabot> Title: #2225 (hackage library encoding-0.4 crashes ghc 6.8.2) - GHC - Trac
21:08:18 <Saizan> solrize: you should probably add your dist at least, and, was it a clean build?
21:08:40 <solrize> "This is on i386 ubuntu gutsy."
21:08:46 <solrize> do i need to add more than that about the dist?
21:08:57 <Saizan> by dist i mean the dist directory :)
21:09:19 <Saizan> the one cabal creates when compiling
21:09:40 <solrize> ic
21:09:46 <solrize> there is a setup-config and a build in there
21:10:08 <solrize> i should tar it up and attach it?
21:51:04 <shapr> It's oh so quiet...
21:51:07 <shapr> @users
21:51:07 <lambdabot> Maximum users seen in #haskell: 481, currently: 409 (85.0%), active: 6 (1.5%)
21:51:10 <shapr> It's oh so still...
21:51:19 <Heffalump> morning
21:51:29 <shapr> GOOD MORNING!
21:51:32 * shapr boings furiously
21:51:45 * vixey waves hi
21:51:53 <dolio> 51 minutes into the morning here.
21:52:14 <shapr> Same here.
21:52:18 <shapr> dolio: Where are you?
21:52:23 <dolio> Ohio.
21:52:26 <shapr> oh
21:52:31 <shapr> I'm in Boston.
21:52:37 <dolio> Nice.
21:53:18 <shapr> Only twelve hours drive from here!
21:53:44 <dolio> Practically nothing.
21:54:20 <shapr> heippa hei Dessous!
21:54:35 <dolio> vixey: Are you fax?
21:54:41 <Dessous> hmm?
21:54:45 <vixey> yes
21:54:50 <dolio> Okay.
21:55:00 * dolio tries to keep the names straight.
21:55:22 <shapr> Dessous: hyvÃ¤Ã¤ huomenta!
21:55:30 <Dessous> Huomenta
21:55:42 <shapr> Dessous: How's code treating you?
21:55:58 <Dessous> good i think
21:56:12 <shapr> Spiffy, have you written anything nifty lately?
21:56:25 <shapr> I've been writing vba code for excel 2007 the last three days. My brain hurts!
21:56:37 <shapr> I started out trying to write higher order functions in vba. Did not work!
21:56:58 <Heffalump> you might be able to do it with class modules
21:57:32 <shapr> vsto allows higher order functions. But that's not an option, sadly.
21:57:42 <Heffalump> vsto?
21:58:01 <shapr> It's the new .net scripting for office.
21:58:07 <shapr> Visual Studio Tools for Office, I think.
21:59:29 <shapr> xemacs and haskell-mode just do not integrate well on win32
21:59:45 <shapr> Maybe I should try gnumacs.
21:59:55 <shapr> Heffalump: Do you use emacs on win32 for Haskell dev?
22:01:15 <Heffalump> shapr: xemacs
22:01:27 <shapr> Do you use the latest haskell-mode as well?
22:01:32 <Heffalump> can't remember
22:02:21 <shapr> Well, I'm having problems with the latest haskell-mode, if have any advice, I'd be appreciative.
22:02:37 <OceanSpray> And I thought Haskell was the end of the line.
22:02:39 <Heffalump> whatever I use works ok for me. It's not perfect though.
22:02:49 <OceanSpray> Then I stumble upon Epigram.
22:03:15 <OceanSpray> Tell me, is there a succession of ever more abstract and powerful programming languages or something?
22:03:19 <shapr> OceanSpray: yup
22:03:21 <vixey> OceanSpray: Check out Agda 2 and Coq
22:03:41 <shapr> OceanSpray: Thing is, it's hard to recognize the next step in the succession until you understand this step.
22:04:14 <dolio> Epigram, Coq, Agda, ... are all in the neighborhood of the calculus of constructions.
22:04:28 <dolio> People don't seem to have anywhere to go from there yet.
22:04:41 <dolio> Although, I suppose you can add other fancy stuff, like linear typing and whatnot.
22:05:18 <solrize> agda2 is being developed by mrs. coq?
22:05:26 <shapr> Substructural typesystems?
22:05:29 <vixey> solrize: yeah
22:05:37 <vixey> It's hard to write a type checker of CoC :/
22:05:39 <vixey> really hard....
22:05:57 <dolio> vixey says it's hard, but everyone else says it's easy. :)
22:06:03 <vixey> :p
22:06:16 <solrize> CoC -is- a type checker, i thought
22:06:21 <augustss_> vixey: it's easy
22:07:11 <vixey> I have 6 failed attempts hece
22:07:13 <augustss_> solrize: Agda was developed my Mrs coq, but not Agda2
22:07:22 <solrize> ah, ok
22:07:49 <augustss_> vixey: i've even blogged about it :)
22:08:52 <vixey> I've read tonnes, all these, the CoC papers.. but I still couldn't write a checker
22:09:07 * vixey doesn't really understand it
22:10:02 <OceanSpray> You go from machine code, to assembler, to C, to Java/C++, to Python/Perl/Ruby, to Lisp/Scheme, to Haskell/ML, to Epigram/Adga/Coq, to ...?
22:10:32 <solrize> machine code
22:10:36 <augustss_> http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html
22:10:37 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2saxu3
22:10:40 <OceanSpray> back again.
22:11:06 <lament> OceanSpray: to C#
22:11:12 <Cale> hahaha
22:11:16 <lament> it's at the forefront of programming languages
22:11:16 <Cale> C# 3.0 ;)
22:11:19 <lament> it's got LINQ!
22:11:19 <vixey> OcearSpray: how the heck did you get this far without Prolog?
22:11:44 <solrize> conor has a blog post about an assembly code monad
22:12:05 <augustss_> and there's harpy
22:12:11 <newsham> i didnt go to lisp/scheme after python/perl/ruby
22:12:17 <newsham> is that wrong?
22:12:23 <lament> yes. Go back and try again.
22:12:23 <Cale> hehe
22:12:41 <solrize> hmm maybe that wasn't conor.  do you know which one i mean?  it came up here a week or so ago
22:13:00 <solrize> the idea was to write something like hoare triples in a type system
22:13:22 <augustss_> Hoare Type Theory?
22:13:32 <solrize> they didn't call it that
22:14:02 <newsham> well i've done some lisp and scheme prior to perl/ruby/python
22:14:25 <newsham> also I did some BASIC before assembler, i expect thats allowed?
22:14:41 <Saizan> i forgot C..
22:14:45 <augustss_> solrize: greg morrisett has done some cool stuff along those lines
22:14:51 <Saizan> but i did pascal!
22:14:58 <solrize> yeah, that's somewhat different though
22:15:00 <newsham> oh, i forgot about pascal.
22:15:14 <augustss_> newsham: BASIC before assembly is allowed
22:15:32 <solrize> this post i'm thinking of had code that looked sort of like harpy, but with types
22:16:16 <augustss_> interesting.  real code or just dreaming?
22:16:20 <solrize> dreaming
22:16:28 <solrize> i'm trying to find it
22:17:06 <solrize> i asked someone here how hard it would be to extend it to the full instruction set of a modern cpu and i think the answer was, straightforward but a ton of work
22:19:43 * vixey needs simply trivial
22:21:19 <augustss_> vixey: how many type checkers have you written for other languages?
22:22:09 <vixey> not many.. I wrote one in haskell and one in prolog which could check flip id and stuff
22:22:44 <augustss_> write one for the simply typed lambda calculus first
22:23:17 <cjs> itekimasu.
22:23:58 <augustss_> ohio gozaimasu
22:25:48 <uebayasi> okaeri
22:26:08 <vixey> what should I do after STLC?
22:26:22 <cjs> tadaima!
22:26:38 <uebayasi> augustss_, is it a joke? ;)
22:26:40 <augustss_> vixey: perhaps the polymorphic lambda calculus, i.e., system F
22:26:59 <dolio> "I'm leaving" "Good morning" "Welcome back" "I'm back"?
22:27:02 <cjs> Augustss! Long time no see.
22:27:15 <augustss_> uebayasi: it is morning here
22:27:26 <augustss_> cjs: ditto
22:27:27 <uebayasi> in case it was not ... ohio -> ohayo ;)
22:27:50 <augustss_> uebayasi: I've never seen it written, I think
22:28:22 <uebayasi> i always say that on netbsd icb :)
22:28:40 <Cale> ohayou, if you're being really mechanical about your transliteration :)
22:29:02 <uebayasi> dolio, all correct
22:29:24 <dolio> @yow!
22:29:24 <lambdabot> Hmmm ... an arrogant bouquet with a subtle suggestion of POLYVINYL
22:29:24 <lambdabot> CHLORIDE ...
22:30:12 <augustss_> vixey: but I'd say type checking of system F is more complex than of CoC
22:30:41 <newsham> augustss: you're the one w/ the blog with the "cube" interpretter?
22:30:49 <augustss_> yes
22:30:50 <vixey> well I'll try it out anyway
22:30:57 <newsham> ty, I really enjoyed that.
22:31:05 <augustss_> :) thanks
22:31:07 <solrize> http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=71#more-71  here's that post.  link is from roconnor
22:31:07 <lambdabot> Title: FP Lunch » Blog Archive » Proof by Smugness
22:31:13 <newsham> I havent fully digested it (only read it twice so far) but hoping to play w/ the interpretter itself soon
22:32:22 <augustss_> solrize: ah, ok.  i remember that one
22:32:37 <augustss_> solrize: works ok with 3 instructions
22:34:38 <solrize> yeah, it's on my long list of things i'd like to understand someday
22:34:58 <lament> i'd like to understand women
22:36:37 <newsham> lament: stick to category and type theory
22:38:01 <uebayasi> i once thought i could understand or at least feel like a woman when i use another button of "washlet", which is supposed to be used by women
22:38:06 <uebayasi> ... it was not
22:38:17 <solrize> so can agda be seen as a haskell dialect with more precise types, i.e. after you run the agda typechecker can you then erase the types and run what's left through ghc and compile it?
22:38:24 <solrize> modulo syntax sugar
22:39:03 <solrize> oh this "power of pi" paper looks good
22:40:00 <newsham> there should be a channel for haskell programmers trying to find (coq, agda, epigram)
22:40:03 <newsham> :)
22:40:10 <vixey> ok
22:40:23 <vixey> I will join
22:40:40 <hpaste>  Saizan pasted "higher-rank polymorphism weirdness" at http://hpaste.org/7024
22:41:08 <Saizan> ^^^^ is there any way to avoid inst?
22:41:25 <Saizan> it feels like i'm doing an explicit type instantiation there
22:44:15 <newsham> vix: me too.
22:45:19 <solrize> saizan it looks cool, whatever it is
22:47:31 <Saizan> solrize: it's a non-sensical reduced example of me trying to understand http://www.mail-archive.com/haskell@haskell.org/msg20758.html and getting weird type errors :)
22:47:31 <lambdabot> Title: [Haskell] Genuine shift/reset in Haskell98
22:48:18 <solrize> saizan, yeah, i mean i "run out of registers" trying to follow it, i should in principle be able to write out the types on all the terms and see if there's an error
22:48:25 * vixey considers #types
22:48:33 <solrize> it seems like a good exercise that i'm not up to at the moment
22:49:07 <solrize> vixey, how about a reading group for TAPL?
22:49:10 <solrize> brb
22:50:35 <Saizan> iirc #logic was for type theory (and it was all over my head the few times i joined some time ago)
22:50:55 <solrize> it is empty now
22:51:04 <vixey> ##logic
22:51:34 <solrize> wow
22:51:41 <solrize> that looks more mathematically oriented
22:51:59 <vixey> It's not empty
22:52:37 <solrize> heh, looks like a bunch of ppl from here (plus a bot)
22:52:42 <Saizan> however type theory and such has always been on topic on #haskell iirc, even if we might give precedence to newbies asking for help
22:53:07 <Saizan> s/iirc//
22:53:36 <lament> +Smerdyakov
23:07:27 <newsham> so which, if any, languages with more advanced type systems are suitable for writing real world code?
23:07:56 <newsham> and are any synergistic with haskell?  (can I xlate agda back into agda and vice versa?)
23:07:58 <vixey> Coq
23:08:29 <mauke> agda <=> agda? should be easy
23:08:39 <newsham> haskell :)
23:08:43 <mauke> .oO( id :: agda -> agda )
23:08:49 <vixey> Not all Agda 2 programs
23:08:58 <vixey> many though
23:09:16 <vixey> You can compile Coq directly to Haskell (or ML or Scheme)
23:09:36 <newsham> right but doesnt it generate unreadable code?
23:09:38 <vixey> basically Agda 2 looks like Haskell so it sometimes work
23:11:31 <Saizan> you can call haskell from agda, but losing typeclass polymorphism
23:12:18 <vixey> newsham: the scheme it generates looks a bit weird becase everything is curried
23:12:48 <vixey> it's readable though (the .v is a lot more readable though..)
23:18:29 <paolino> @instances Monoid
23:18:31 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
23:19:24 <Trinithis> @src Last
23:19:24 <lambdabot> Source not found. Just try something else.
23:22:10 <solrize> Smerdyakov wrote a compiler in coq
23:22:28 <solrize> that was one of the feats that got me interested in fancy types
23:23:25 <lament> smerdyakov++
23:24:31 <vixey> Xavier Leroy wrote a compiler in Coq too
23:29:33 <solrize> neat
23:33:43 <paolino> @src Monoid (a,b)
23:33:43 <lambdabot> Source not found. Take a stress pill and think things over.
23:34:18 <vixey> @src Monoid (,)
23:34:18 <lambdabot> Source not found. I've seen penguins that can type better than that.
23:34:27 <vixey> @src Functor (,)
23:34:27 <lambdabot> Source not found. That's something I cannot allow to happen.
23:34:43 <vixey> @src Monoid (,a)
23:34:43 <lambdabot> Source not found. I am sorry.
23:34:47 <vixey> @src Monoid (,) a
23:34:47 <lambdabot> Source not found. The more you drive -- the dumber you get.
23:35:12 * paolino never thought lambdabot is funny, even when she is right
23:35:50 <lament> @quote
23:35:50 <lambdabot> JohnMeacham says:  Is it ironic I had to look up and read a tutorial on the haskell regular expression syntax I invented?
23:36:03 <lament> @quote
23:36:04 <lambdabot> bos says:  i'm very pleased by the recent progress of the C++ standard.  it's gradually eroding the performance advantage of C++ compilers over GHC, without the simons having to do anything.
23:36:11 <lament> I agree. Her jokes suck.
23:36:26 <dolio> @src (,) mempty
23:36:26 <lambdabot> Source not found. :(
23:37:37 <mauke> preflex: remember bos i'm very pleased by the recent progress of the C++ standard.  it's gradually eroding the performance advantage of C++ compilers over GHC, without the simons having to do anything.
23:38:33 <paolino> > runWriter (tell (['a'],[1]))
23:38:35 <lambdabot>  ((),("a",[1]))
23:45:37 <geezusfreeek> hmm
23:46:09 <geezusfreeek> i managed to get the SDL bindings to build and install on OS X, but i can't seem to link to it properly
23:46:27 <geezusfreeek> Undefined symbols: "_SDL_main", referenced from: -[SDLMain applicationDidFinishLaunching:] in libSDLmain.a(SDLMain.o)
23:47:30 <geezusfreeek> googling it turns up a one relevant resultâ€¦ another time it was brought up here, but apparently not solved
23:48:18 <geezusfreeek> at least searching along with "haskell"
23:55:34 <quicksilver> geezusfreeek: sounds like you might be using it wrong.
23:55:40 <quicksilver> geezusfreeek: are you compiling with --make ?
23:55:44 <OceanSpray> Configuring yi-0.4...
23:55:44 <OceanSpray> Setup.hs: At least the following dependencies are missing:
23:55:44 <OceanSpray>     fingertree -any
23:55:50 <OceanSpray> where do I get fingertrees?
23:55:56 <Zao> hackage?
23:56:03 <quicksilver> geezusfreeek: and are you using whatever magic sdl needs to take over the main sub?
23:56:20 <geezusfreeek> quicksilver: the magic main stuff is what i think i am not understanding
23:56:31 <mauke> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fingertree-0.0
23:56:32 <geezusfreeek> i have never used SDL before, even in C
23:56:34 <lambdabot> http://tinyurl.com/2t8z7n
23:58:16 <geezusfreeek> i see all kinds of tips for getting it to work with C/C++, but i can find no such thing for working with GHC
