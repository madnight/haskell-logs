00:07:14 <solrize_> float dot_product(nelts :: Integer, x :: Vector(nelts), y :: Vector(nelts))
00:49:12 <halberd> http://www.bparkis.com/node/15
00:49:13 <lambdabot> Title: 2-d Grammars | www.bparkis.com
00:51:31 <sjanssen> @yow
00:51:31 <lambdabot> I am a jelly donut.  I am a jelly donut.
00:54:35 <Twey> <3
01:06:53 <edbond> how can I convert IO [FilePath] to [String] ?
01:09:09 <shachaf> edbond: You can't, exactly, but you can turn it into one temporarily, if you promise to re-wrap it in IO later.
01:09:12 <dobblego> you don't because you can't; isn't that great? :)
01:09:23 <shachaf> edbond: (FilePath = String, by the way.)
01:09:51 <edbond> yes. I read about that. Take a look at hpaste, please.
01:10:20 <Jedai> Which hpaste ?
01:10:23 <dobblego> edbond, which link?
01:10:29 <edbond> http://hpaste.org/7077
01:11:13 <dobblego> you'll have to change that return type
01:11:51 <vorner> whenever you do something that "changes the world outside", you have to return IO
01:12:18 <vorner> and whenever you get IO, you have to either not use it or return it too
01:12:31 <glguy> http://hpaste.org/7077#a1
01:14:31 <edbond> great! thanks a lot.
01:14:33 <shachaf> You should probably not be using system for this anyway.
01:15:03 <Jedai> Oups, liftM is wrong in my response (though I think cmd should be rewritten as I did)
01:15:17 <shachaf> Except possibly for the "git pull".
01:17:26 <Jedai> Why are you importing GHC.IOBase ?
01:18:18 <Jedai> @hoogle ExitCode
01:18:19 <lambdabot> System.Exit.ExitCode :: data ExitCode
01:18:19 <lambdabot> System.Process.getProcessExitCode :: ProcessHandle -> IO (Maybe ExitCode)
01:19:22 <edbond> @hoogle System.Cmd.system
01:19:23 <lambdabot> No matches, try a more general search
01:19:45 <Jedai> @hoogle system
01:19:45 <lambdabot> System.Cmd.system :: String -> IO ExitCode
01:19:45 <lambdabot> Distribution.System :: module
01:19:45 <lambdabot> System.Cmd.rawSystem :: String -> [String] -> IO ExitCode
01:20:43 <shachaf> How about http://hpaste.org/7077#a5 ?
01:20:53 * shachaf still thinks system is a bad idea.
01:24:11 <edbond> cool! system isn't bad. it will be great to check if FilePath a directory or not.
01:25:50 <shachaf> edbond: doesDirectoryExist.
01:26:06 <shachaf> edbond: But what if, for example, a file name has a space in it?
01:28:24 <edbond> I should use setCurrentDirectory instead of `cd`
01:39:27 <jsnx> @seen Cale
01:39:27 <lambdabot> Cale is in #haskell-overflow, #ghc and #haskell. I last heard Cale speak 6h 18m 33s ago.
01:39:47 <Saul_> dons: You there?
01:40:21 <jsnx> @tell Cale i made a few modules that incorporate your sugaring of (.), (++) and liftM -- let me know what you think: https://svn.j-s-n.org/public/haskell/rehash
01:40:22 <lambdabot> Consider it noted.
01:44:28 <Saul_> @tell dons That program I showed you yesterday at http://hpaste.org/7070 actually works as expected (even without -threaded). The problem seemed to be my browser, that single-threadedly refreshes different tabs. I used telnet instead just now and it works like a charm.
01:44:29 <lambdabot> Consider it noted.
01:51:15 <arussel> is cabal a kind of apt-get for haskell, or more just like a make ?
01:51:31 <Lemmih> arussel: It is both.
01:52:49 <arussel> Lemmih: so there is a way to solve this: http://pastebin.com/m326cac52 without installing manually all needed packages ?
01:53:12 <Lemmih> arussel: Install cabal-install.
01:53:46 <Lemmih> arussel: It also looks like you have an old version of ghc.
01:54:38 <arussel> Lemmih: I am using package from debian testing. Is it better to just get everything from source ?
01:55:03 <Lemmih> arussel: There are also binary packages available.
01:55:37 <arussel> Lemmih: ok, so ghc, cabal, cabal-install, and then evrything with cabal ?
01:55:48 <Lemmih> arussel: Yep.
01:57:03 <arussel> Lemmih: thanks
02:07:24 <dcoutts> gwern: pong
02:09:58 <Cale> @tell jsnx good show!
02:09:58 <lambdabot> Consider it noted.
02:33:16 <Baughn> Cale: http://brage.info/~svein/cale <-- Updated patch bundle, this time with support for loops. Runplugs handled it fine, but the cleanup code in eval.hs removed all the output.
02:40:59 <Cale> lambdabot: @restart
02:40:59 <lambdabot> Unknown command, try @list
02:41:03 <Cale> lambdabot: @quit
02:41:23 <Cale> Baughn: there you go :)
02:41:27 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
02:41:33 <Baughn> > 1:undefined
02:41:41 <lambdabot>  [1Exception: Prelude.undefined
02:42:00 <Baughn> > let x=x in 1:x
02:42:23 <lambdabot>  thread killed
02:42:31 <bd_> > let x=x in x
02:42:37 <bd_> hm, no loop detction?
02:42:44 <Baughn> Ooh, right
02:42:53 <lambdabot>  thread killed
02:42:57 <Baughn> Of course. Since I installed an xcpu handler, the rts stops detecting loops
02:43:06 <Baughn> I have a patch to ghc you could add if you want to fix that. ;)
02:44:44 <bd_> not my bot :)
02:45:02 <Baughn> What's going on is that I have an xcpu handler set to break evaluation of infinite loops and print a timeout exception.. but that same handler makes the rts think it could conceivably break a deadlock. Which it can't, deadlocks not taking any cpu time and all.
02:45:31 <bd_> loops are deadlocks?
02:45:43 <bd_> also argh my uni's routing broke again
02:45:45 <Baughn> As far as the rts is concerned, yes.
02:46:13 <Baughn> http://hackage.haskell.org/trac/ghc/ticket/2180 <- Details
02:46:15 <lambdabot> Title: #2180 (Any installed signal handler stops deadlock detection, but XCPU never hap ...
02:47:44 <Baughn> ..which reminds me, I really should /fix/ that bug
02:49:23 * bd_ hates how darcs patches are almost unreadable in raw form (no context, huge log of references at the bottom)
02:49:56 <Baughn> They aren't meant to be readable. FWIW, you can make darcs write a standard unified patch instead
02:50:00 <bd_> Heck, does it really need to include the full log messages for all of them? :/
02:50:06 <bd_> Baughn: yes, but people /don't/
02:50:13 <Baughn> bd_: Yes. It does.
02:50:41 <Baughn> Or at least it needs to identify every patch leading up to them
02:50:45 <bd_> meaning one needs to pull the patch in order to examine it, and then it gets a bit harder to remove the patch later
02:50:51 <ertai> bd_: context stops at tags, so less you tag longer context are
02:51:27 * bd_ is not in control of how often ghc maintainers tag :)
04:38:02 <arussel> I am trying to install yi, I did: cabal install yi-gtk
04:38:35 <arussel> and got: http://pastebin.com/m5f26ecb8
04:38:52 <arussel> what is the magic formula I need to install yi ?
04:50:23 <Baughn> arussel: yi hasn't been updated to work with ghc 6.8
04:50:35 <Baughn> It might be a simple fix, but.. for now, you'd need 6.6
04:53:44 <arussel> Baughn: I installed the latest ghc because I couldn't get cabal to build yi: http://pastebin.com/m326cac52
04:55:37 <Baughn> arussel: Hang on
04:55:47 <Baughn> arussel: In this latest paste, you're trying to install yi 0.4..
04:55:55 <Baughn> In the last one, it was yi 0.2
04:56:13 <Baughn> And it appears that 0.4 /does/ work with 6.8, while 0.2 works with 6.6
04:57:11 <arussel> ok ,  so building from source should work. I'll try
04:58:01 <arussel> for yi-0.4, it still want: Cabal >=1.5.1, fingertree -any, utf8-string -any, Crypto ==4.1.0
04:58:12 <Baughn> Right, so install those
04:58:24 <arussel> where do I find Cabal 1.5.1 ?
04:58:31 <Baughn> That's the darcs version
04:58:46 <Baughn> Oh, and you need to configure with --user to make it use anything installed by cabal-install (or configured with --user)
04:59:11 <arussel> Baughn: ok, thanks
05:10:52 <vincenz>  /away
05:13:17 <dcoutts_> Baughn, arussel: cabal-install uses --user be default
05:13:21 <dcoutts_> be/by
05:14:15 <Baughn> Exactly
06:03:40 <Sadache> Hello All
06:04:31 <Sadache> I am using the record syntax, and i am finding it very annoying that i cant use the same selector twice
06:04:40 <Sadache> any tricks for that?
06:05:02 <Sadache> i use id in almost all my records
06:06:33 <EvilTerran> you can hack something with typeclasses, but there's quite a bit of boilerplate involved
06:06:56 <EvilTerran> ... "id" is an odd choice, though, seeing as it clashes with a prelude definition
06:06:57 <EvilTerran> ?src id
06:06:57 <lambdabot> id x = x
06:07:38 <Sadache> i meant indentifier
06:07:50 <EvilTerran> if all your types use the same type for identifiers (say, Int), it's fairly straightforward
06:08:10 <EvilTerran> class Identifier a where identifier :: a -> Int
06:08:25 <EvilTerran> data Foo = Foo { fooId :: Int, ... }
06:08:35 <EvilTerran> instance Identifier Foo where identifier = fooId
06:08:49 <EvilTerran> similarly for Bar and barId, etc
06:08:51 <Vq^> what about this?  http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#disambiguate-fields
09:36:06 <eugman> Failed to load interface for `Control.Monad.State':       <------ any ideas why?
09:37:02 <macondo> @src reduce
09:37:02 <lambdabot> reduce _ 0 = undefined
09:37:02 <lambdabot> reduce x y = (x `quot` d) :% (y `quot` d)
09:37:02 <lambdabot>     where d = gcd x y
09:39:31 <dons> cool, http://reddit.com/info/6gg4c/comments/
09:39:33 <Lemmih> eugman: In what context?
09:40:24 <eugman> I tried to compile a guessing game example and it gave me that error
09:41:04 <Lemmih> eugman: Then you probably need --make.
09:43:04 <Lemmih> eugman: Or install mtl if you don't have it already.
09:43:32 <eugman> I wasn't using --make so i probably need make but i'll try to see if I have mtl installed
09:53:29 <midfield> hey all, having a cabal problem.  i have ghc 6.8.2 installed on vista 64, it doesn't seem to pick up ghc-prof-options.
09:53:37 <midfield> like -auto-all
09:53:57 <dcoutts_> midfield: are you configuring to build profiling libs?
09:54:27 <midfield> runhaskell Setup.lhs configure "--enable-library-profiling"
09:54:27 <dcoutts_> midfield: cabal configure --enable-profiling-libraries (or -p for short)
09:54:51 <dcoutts_> miasma: erm, yes you're right --enable-library-profiling not --enable-profiling-libraries
09:55:31 <midfield> yeah, i'm doing runhaskell Setup.lhs build -v2 to see the ghc build line, i see -prof but no -auto-all
09:56:24 <Sadache> anyway to curry the second parameter of a function without using a lambda?
09:56:27 <dcoutts_> midfield: hmm, so what Cabal version is that?
09:56:42 <Twey> Sadache: flip it
09:56:46 <midfield> hmmm i guess i'll try --ghc-options=-auto-all
09:57:28 <midfield> it was whatever came installed with the default ghc 6.8.2
09:57:28 <Twey> Sadache: let f = flip myFunc $ secondArg in f firstArg
09:57:40 <midfield> is there a command i can try to check out which version?
09:57:44 <Sadache> cant i just turn it into an infix, like  'myTwoParamsFunc' x
09:57:58 <midfield> ah ghc-pkg gives cabal 1.2.3.0
09:58:10 <Twey> You can do that too, yes, but it uses backslashes and you can't forget the brackets
09:58:27 <Twey> (`myFunc` secondArg)
09:58:30 <Twey> Er
09:58:32 <Twey> backticks
09:58:57 <newsham> > (flip replicate 'a') 5
09:59:00 <lambdabot>  "aaaaa"
09:59:09 <newsham> > (`replicate` 'a') 5
09:59:10 <lambdabot>  "aaaaa"
10:00:42 <dcoutts_> midfield: mm, I can reproduce it with that version and the latest dev version
10:01:54 <Sadache> it didnt work for me it gives me "Improperly terminated character constant" for map ('walkTree'  f) subTrees
10:02:59 <newsham> back tick, not apostrophe
10:03:03 <newsham> ` not '
10:03:18 <midfield> ah well, anyhow my cabal hack has verified what i wanted to know -- the vast majority of the time in my program is apparently spend in data.binary.encode.  strange, i thought it was going to be killer fast!
10:03:43 <Sadache> ah ok, i ll have to find that then
10:03:46 <newsham> btw, have you considered perhaps changign the order of walkTree args?  or are there times when the other ordering is preferred?
10:04:04 <Sadache> newsham: can i paste code here?
10:04:05 <dcoutts_> midfield: I think I've found the source of the bug, thanks for pointing it out
10:04:13 <newsham> ?paste
10:04:14 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:04:49 <midfield> or at least it's an issue with ntfs and lots of little files.....
10:06:53 <Sadache> http://hpaste.org/7080
10:07:42 <newsham> the last line uses 'walkTree' where you want `walkTree`
10:07:56 <newsham> the (`) character is often on the same key as the tilde (~) key
10:08:06 <Sadache> ok
10:08:40 <midfield> dcoutts_: no prob, thanks for the quick response!
10:08:51 <newsham> apostrophe (') is for characters: 'a',   back-tick (`) is to turn a prefix command into an infix command (3 `plus` 5)
10:09:02 <Sadache> i found it
10:10:23 <Sadache> thanks
10:10:26 <Botje> back-ticks are with µ and £ for me.
10:10:42 <newsham> you have mu and lb keys?
10:10:50 <Botje> yes
10:10:55 <Botje> the joy that is azerty
10:11:03 <newsham> crazy
10:11:05 <Botje> i have § and ç too
10:11:20 <Sadache> i have an azerty keyboard and a qwerty windows
10:11:28 <Sadache> so i wont find it this way
10:11:37 <newsham> I have to do weird things to get ωeird characters
10:12:31 <newsham> ｌｉｋｅ＀ｔｈｅｓｅ
10:12:44 <Botje> ah, doublespaced characters
10:12:47 <Botje> they're fun, yes :)
10:13:58 <newsham> in the future elite-speak will be unicode multicharset based?
10:14:16 <Twey> newsham: 'lb key?'  We don't call it a 'lb key.'  'lb' is the weight measurement :_)
10:14:19 <Twey> :-)
10:14:29 <BCoppens> newsham: ¥€ß
10:14:37 * Twey shudders.
10:14:39 <Twey> It's already here
10:14:51 <Twey> Someone evidently doesn't use MSN very much :-P
10:14:57 <newsham> ?elite lambdabot needs leet 2.0 unicode edition
10:14:58 <lambdabot> lam8da807 N33dS |EE7 2.0 UNicOd3 3DItION
10:15:09 <BCoppens> Twey: brrr
10:15:21 <Twey> omg i r haP ツ
10:15:36 <mofmog> oh lord, this text rendering system will not do at all
10:15:57 <mofmog> great, now i have to rewrite my evaluation algorith to fix it
10:16:07 <BCoppens> =)
10:16:15 <macondo> great character
10:16:40 * vorner can do better...
10:17:09 * BCoppens finds all japanese characters great ;)
10:17:33 <vorner> BCoppens: and ☠ pictures too? ☺…
10:17:59 <BCoppens> yes, they are the greatest!
10:18:20 <Sadache> can we use them as operators?
10:18:22 <Twey> Appropriate for the channel... λ
10:18:32 <Twey> Sadache: Unicode chars?
10:18:41 <Sadache> yes
10:18:54 <Twey> Sadache: So long as they're non-alphabetic (as seen by Data.Char.isAlpha)
10:18:54 <Sadache> in APL they are used
11:11:37 <dcoutts_> gwern: the C compiler always runs cpp for C files, so it's a matter of having the right includes and include search dirs
11:12:23 <dcoutts_> gwern: so presumably hscurl.c #includes the autoconf config.h or something like that, right?
11:12:39 <gwern> dcoutts_: I tried adding 'cpp-flags: -DPACKAGE_VERSION="2.0.0"', but I don't think it worked
11:12:46 <xif> shachaf: I'll look it up again when I know more Haskell :)
11:13:02 <gwern> it does an '#include "hscurl.h"'
11:13:03 <dcoutts_> gweiqi: no, cpp is for haskell code, but cc-options will be passed when compiling C code
11:13:09 <gwern> (and also three standard C headers, looks like)
11:13:41 <shachaf> xif: OK. :-)
11:13:46 <gwern> dcoutts_: so it should've been cc-options then?
11:13:51 <dcoutts_> gwern: so the normal darcs build system passes it as a -D flag then? rather than having autoconf generate a header file?
11:13:58 <Sadache> i want to do sqlJoin::Ord c=> [a]-> [b] -> (a->c)->(b->c) -> [(a,b)] using maps, any one can point me to examples of using maps in haskell
11:14:20 <Sadache> sqlJoin:: Ord c=> [a]-> [b] -> (a->c)->(b->c) -> [(a,b)]
11:14:48 <gwern> dcoutts_: as near as I can tell, but figuring out what autoconf does is hard :)
11:14:59 <shachaf> @docs Data.Map
11:15:00 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
11:15:06 <shachaf> Someone should really update that.
11:15:10 <shachaf> s/base/containers/
11:15:13 <dcoutts_> gwern: right :-) I've seen autoconf based systems that work either way
11:15:46 <gwern> interesting, the error changes when I use cc-options
11:15:47 <Sadache> the link is broken
11:15:47 <dcoutts_> gwern: generally if they end up with loads of options then they bung them all into a generated config.h, and if only a few then they pass them as cc options
11:16:09 <dcoutts_> gwern: what now?
11:17:08 <shachaf> Sadache: Yes, s/base/containers/
11:17:12 * gwern tries with quotes this time
11:17:16 <paolino> Sadache, better ask here than read those docs, which have no examples
11:17:20 <shachaf> http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html
11:17:21 <lambdabot> http://tinyurl.com/2mpwee
11:17:21 <paolino> file:///usr/share/doc/ghc6-doc/html/libraries/base/Data-Map.html
11:17:39 <paolino> ops
11:17:40 <dcoutts_> gwern: ah yes, if you need to pass actual " chars then they'd have to be escaped
11:17:51 <shachaf> paolino: Well, that link works here. :-)
11:17:59 <paolino> sorry
11:18:23 <Sadache> ok,i want to have a new map, then i want to fill it with the first list
11:18:34 <dcoutts_> gwern: eg if you're trying to do the equivalent of: gcc foo.c -D'VERSION="2.0.0"'
11:18:40 <paolino> fromList
11:18:51 <paolino> takes associacions
11:19:07 <Sadache> fromList does it take a selector for the key
11:19:08 <gwern> hm. seems to be compiling with quotes...
11:19:08 <Sadache> ?
11:19:31 <jadrian> guys, off topic question but some of you might have seen this kind of math before
11:19:38 <jadrian> I want something like a set {*}
11:20:01 <paolino> > Map.fromList [(1,"paolino"),(2,"Sadache")]
11:20:01 <lambdabot>   Not in scope: `Map.fromList'
11:20:13 <paolino> > Data.Map.fromList [(1,"paolino"),(2,"Sadache")]
11:20:14 <lambdabot>   Not in scope: `Data.Map.fromList'
11:20:14 <jadrian> but such that  {*}x{*} is not isomorphic to {*}
11:20:24 <roderyk> how does runhaskell differ from compiling with ghc (compiling with ghc -prof complains about not available modules, even though it all works fine - and the modules are imported - with runhaskell)
11:20:28 <jadrian> the element of each set is unique
11:20:31 <shachaf> > M.fromList [(1,"paolino"),(2,"Sadache")]
11:20:33 <lambdabot>  fromList [(1,"paolino"),(2,"Sadache")]
11:20:35 <gwern> dcoutts_: right now I'm using 'cc-options:      -DPACKAGE_VERSION="2.0.0"'
11:20:39 * gwern wonders when cabal will parallelize builds :(
11:21:04 <gwern> (ew, a ton of link errors! wonder what that is all about)
11:21:12 <paolino> @let m = M.fromList [(1,"paolino"),(2,"Sadache")]
11:21:14 <lambdabot> Defined.
11:21:26 <dcoutts_> gwern: well, I've just been rebuilding my desktop with a new quad-core amd64 so I'm also pretty keen to get parallel builds :-)
11:21:36 <paolino> > m M.! 1
11:21:36 <lambdabot> Terminated
11:21:58 <shachaf> paolino: m isn't a good name. :-)
11:22:00 <shachaf> @undef
11:22:01 <lambdabot> Undefined.
11:22:02 <eugman> So, lets say I have a program that is based on main = interact (unlines . map someFunction . lines)  . If i just run it from the command line is there a way I can make it so a person can get out of it short of ctrl+c ?
11:22:16 <paolino> @let x = M.fromList [(1,"paolino"),(2,"Sadache")]
11:22:16 <lambdabot> Defined.
11:22:28 <shachaf> Nope, no single-letter name.
11:22:28 <paolino> > x M.! 1
11:22:28 <lambdabot> Terminated
11:22:29 <shachaf> @undef
11:22:30 <lambdabot> Undefined.
11:22:32 <shachaf> @let em = M.fromList [(1,"paolino"),(2,"Sadache")]
11:22:33 <lambdabot> Defined.
11:22:33 <dcoutts_> gwern: and I expect our GSoC proposal to implement a make style lib for Cabal to be accepted
11:23:04 <shachaf> > f x :: Expr
11:23:06 <lambdabot>  f x
11:23:16 <paolino> ok
11:23:28 <paolino> > em M.! 1
11:23:29 <lambdabot>  "paolino"
11:24:01 <paolino> > M.map length em
11:24:02 <lambdabot>  fromList [(1,7),(2,7)]
11:24:07 <gwern> dcoutts_: I too have a quad-core I'd like to use (make can do it!)
11:24:33 <dcoutts_> gwern: yep, make is pretty good for that
11:24:42 <gwern> they haven't sent out the acceptances yet?
11:24:42 <Sadache> no actually i have a list [a] and i want to turn it into a map passing a selector [a-> b]
11:24:48 <roderyk> http://hpaste.org/7082  how can I force evaluation earlier to avoid big heap @ print?
11:24:49 <dcoutts_> gwern: tomorrow
11:25:27 <Toxaris> eugman: you could call error. but maybe, if you want a more complicated user interface, interact is not the tool to choose?
11:26:25 <paolino> Sadache , I don't know what is a selector [a - > b]
11:26:39 <gwern> eugman: presumably C-d would work as well
11:26:57 <Sadache> paolino: (a->c) a key selector
11:27:10 <gwern> since C-d marks end of stream?
11:27:14 <paolino> ah, ok
11:28:11 <eugman> Oh I did not know that
11:28:32 <paolino> I posted something like that a while ago http://hpaste.org/6943
11:28:48 <paolino> but someone sis it was too specific
11:28:55 <paolino> *said
11:30:13 <Sadache> want it be faster using a map? this way I turn the first list into a map, then i return the second list with matches from the map
11:30:15 <Sadache> sqlJoin::Ord c=> [a]-> [b] -> (a->c)->(b->c) -> [(a,b)]
11:30:22 <Sadache> sqlJoin:: Ord c=> [a]-> [b] -> (a->c)->(b->c) -> [(a,b)]
11:31:10 <Sadache> this way, it will take only putting the first list into a map to start yielding results of the join
11:31:44 <Sadache> (the code you posted was for me too, i was the one who asked for it )
11:32:00 <paolino> my solution is with ordered lists, same complexity as map, but surely there are better solutions :)
11:32:42 <Sadache> but your solution didnt have the lists ordering logic
11:33:42 <Sadache> and correct me if i am mistaken, I guess in your solution it needs to order both lists before yielding results, right?
11:33:54 <Sadache> maybe it is still as fast as the one with map
11:34:03 <Sadache> i really dont know
11:36:43 <Sadache> with the one based on a map, i could do an external join, then specialize to left, right and inner join using a guard
11:44:33 <dcoutts_> gwern: I've been reading the darcs-devel thread on whether to use cabal or not, it's interesting
11:44:42 <dcoutts_> some people have very strong opinions
11:45:30 <dcoutts_> it's a bit of a shame that people think that Cabal's feature set is set in stone and that there's no point in reporting what features are needed for various projects
11:46:21 <dcoutts_> gwern: I wonder if you can figure out exactly what kind of configure tests are wanted for darcs, especially the zlib one
11:46:58 <gwern> dcoutts_: indeed. I don't entirely understand Roundy and Meachem's antipathy
11:47:13 <gwern> dcoutts_: how do you mean?
11:47:24 <dcoutts_> gwern: there are (at least) two ways of looking at configure tests, one is to say we inspect the environment and adjust the build configuration accordingly eg disabling a feature
11:47:47 <dcoutts_> gwern: the other is to say that, this optional feature requires zlib to be installed
11:48:12 <dcoutts_> gwern: the first is easy to explain and is ok if you assume the environment is constant
11:48:25 <dcoutts_> the latter is much more useful to packaging systems
11:48:31 <chessguy> @src Ord
11:48:31 <lambdabot> class  (Eq a) => Ord a  where
11:48:31 <lambdabot>     compare      :: a -> a -> Ordering
11:48:31 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
11:48:31 <lambdabot>     max, min         :: a -> a -> a
11:48:36 <chessguy> @src Enum
11:48:36 <lambdabot> class  Enum a   where
11:48:36 <lambdabot>     succ                     :: a -> a
11:48:36 <lambdabot>     pred                     :: a -> a
11:48:37 <lambdabot>     toEnum                   :: Int -> a
11:48:39 <lambdabot>     fromEnum                 :: a -> Int
11:48:41 <lambdabot> [3 @more lines]
11:48:45 <chessguy> @more
11:48:46 <lambdabot>     enumFrom                 :: a -> [a]
11:48:46 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
11:48:47 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
11:49:10 <dcoutts_> gwern: because then the package manager can decide (if the user wants the zlib feature) that it'll actually go and install zlib to satisfy the dependency
11:49:20 <vincenz> hly moly
11:49:24 <vincenz> spammerooney
11:49:56 <dcoutts_> gwern: the other major issue seems to be the package renaming one, which really is a mess, but then assuming that a module name existing in any package is just as fragile
11:50:59 <paolino> Sadache: once first list is in a map, how you get the same selected element from the second list ?
11:51:24 <dcoutts_> gwern: so is that zlib feature test about enabling/disabling an optional feature?
11:51:40 <dcoutts_> gwern: or is it simply a unconditional required dependency?
11:52:24 <dcoutts_> gwern: it's quite true of course that cabal currently doesn't sensibly check for required C libs, but that's not so hard to fix, we've got a bug open about that
11:52:34 <gwern> dcoutts_: most of it seems to be testing to enable optional features - ie bytestring tests to see whether bytestring is available and usable, else it falls back to old FastPackedString; tests for Curl to see whether it can be used, else falls back to libwww, else falls back to just using 'error "curl/libww not compiled in'
11:52:53 <gwern> (although that means you can't do a darcs get or darcs pull...)
11:53:32 <gwern> and then there's all the machinery to automagically find out what version of darcs this is, how many patches since the last release, parsing the changelog, and stuffing all of that into appropriate places in .hs files
11:53:38 <Sadache> paolino: I go through the second list and if it matches anything in the map i return it, other wise i go to next
11:54:10 <chessguy> @pl \s -> (t s, g c t s)
11:54:10 <lambdabot> liftM2 (,) t (g c t)
11:55:17 <gwern> then there's some odd stuff about checking for quickcheck, regex, and html
11:55:32 <gwern> I *think* those are mandatory
11:55:54 <chessguy> @type &&
11:56:08 <chessguy> @type (&&)
11:56:09 <lambdabot> thread killed
11:56:09 <dcoutts_> gwern: right, so in Cabal, feature decisions are supposed to be visible to the user (and package manager), not just buried in the code
11:56:14 <lambdabot> Bool -> Bool -> Bool
11:56:15 <chessguy> ...
11:56:40 <dcoutts_> gwern: but then we have a mechanism to select the features to use automagically
11:57:06 <gwern> and there's an entire WorkAround module for GHCs without createLink, createDirectoryIfMissing, or POsix file modes, and to work around buggy versions of other stuff
11:57:09 <gwern> and then there's mmap, which is used on Posix, but defaults to off on windows
11:57:16 <gwern> and aw man, there's just a lot of stuff configure.ac does
11:57:24 <dcoutts_> gwern: we could and probably should extend that mechanism to let Setup.hs scripts do tests to determine the default values of configurations flags
11:57:47 <krist> is there an uncurry3 anywhere?
11:58:03 <dcoutts_> gwern: if you could make a summary / list of these issues and send it to the cabal-devel list, that'd be enormously helpful
11:58:23 <Baughn> @hoogle (a -> b -> c -> d) -> (a,b,c) -> d
11:58:28 <lambdabot> No matches, try a more general search
11:58:29 <dcoutts_> gwern: I think that might be more productive than me asking in darcs-devel
11:58:33 <gwern> what, of problems with cabalizing darcs?
11:58:54 <krist> i guess it's kind of specialised
11:59:02 <krist> i'll just define it as a utility function in my project
11:59:06 <dcoutts_> gwern: right, explaining what darcs does in its configure.ac and we can think about how that maps to cabal and what features are missing in cabal
11:59:41 <gwern> if I remember
11:59:49 <dcoutts_> gwern: thanks
12:01:09 <Botje> @pl \f (a,b,c) -> f a b c
12:01:09 <lambdabot> (line 1, column 8):
12:01:09 <lambdabot> unexpected ","
12:01:09 <lambdabot> expecting letter or digit, operator or ")"
12:01:09 <lambdabot> ambiguous use of a non associative operator
12:01:16 <nibro> @hoogle uncurry3
12:01:17 <lambdabot> No matches found
12:01:21 <nibro> bah
12:01:25 <Botje> fail :(
12:01:35 <krist> it's for mapM_ (vertex . uncurry3 Vertex3) points
12:01:53 <Botje> you'll have to define it yourself
12:02:00 <krist> yeah
12:04:09 <chessguy> http://hpaste.org/7083
12:04:20 <chessguy> can someone give  me a quick nudge here
12:04:27 <chessguy> or a whack with a 2x4 would probably work too
12:05:19 <roderyk> http://hpaste.org/7082  Can someone take a look at this? I converted the let db = ... to a foldr' but that only gave me a gain from 69MB to 65MB heap usage. I think the problem is the Map.filter, but I'm not sure. I rewrote it with an aux and Map.fold with no change
12:06:14 <paolino> Sadache , http://hpaste.org/6943#a1
12:06:40 <Botje> chessguy: isn't the def of allSquares missing something?
12:07:09 <chessguy> err, yeah
12:07:28 <Botje> i'm assuming it's a c? :)
12:07:28 <chessguy> should have a [0..63] on the end
12:07:32 <Botje> oh
12:07:44 <Botje> well, a list comprehension would certainly help
12:07:53 <krist> that Square deriving Enum is cool.
12:08:38 <chessguy> it's the isLive definition that's broken
12:08:57 <sjanssen> roderyk: I think you want to use a foldl rather than foldr
12:08:59 <Sadache> great, thank you paolino
12:09:03 <sjanssen> actually, foldl'
12:09:26 <Sadache> but paolino do u think that it is better?
12:09:33 <chessguy> i thought i could pattern match a piece that way
12:09:59 <paolino> yes
12:10:05 <vincenz> chessguy: what is the 's'
12:10:10 <sjanssen> roderyk: also, you should use insertWith'
12:10:11 <roderyk> sjanssen: I was originally using a foldr; but the only strict fold I could find was a foldl', so I just rewrote that bit :)
12:10:26 <chessguy> err, the letters are backwards
12:10:27 <chessguy> sigh
12:10:32 <chessguy> the s is actually the Maybe Piece
12:10:40 <vincenz> chessguy: what is it supposed to do?
12:10:41 <Sadache> ok thanks
12:10:47 <paolino> np
12:10:58 <chessguy> vincenz, grab the pieces for the current side to move
12:11:01 <Botje> livePieces c = [ x | Just x@(p, Piece col _) <- allSquares, col == toMoveColor c ]
12:11:11 <Botje> with allSquares as before
12:11:16 <vincenz> chessguy: oh, all the movable ones
12:11:22 <Botje> and possibly () around the Just
12:11:24 <sjanssen> roderyk: does the order of the elements in each list matter?
12:11:30 <vincenz> chessguy: shouldn't' you pass in the current color then/
12:11:35 <vincenz> ah, nm
12:11:38 <Jedai> I put a slighly reworded version
12:11:56 <roderyk> sjanssen: no
12:12:00 <Jedai> Which is not announced, why ? http://hpaste.org/7083#a1
12:12:18 <Botje> hpaste is also dead
12:12:31 <krist> Botje: that is really lovely code
12:12:52 <sjanssen> roderyk: you might consider using type Value = Set FilePath
12:12:57 <Botje> thanks :)
12:13:26 <sjanssen> roderyk: (>1) . length . nub -- is O(n^2)
12:13:27 <vincenz> chessguy: http://hpaste.org/7083#a2
12:13:41 <xerox> not . null . nub
12:13:41 <Jedai> Ah oops, didn't see you needed to only get the piece of one color...
12:13:41 <vincenz> add another parens on the right side of that pattern
12:13:51 <sjanssen> xerox: I'd prefer no nub at all :)
12:14:08 <sjanssen> xerox: that's also not the same thing
12:14:22 <xerox> put an tail there :)
12:14:46 <Jedai> vincenz version is good :)
12:15:19 <roderyk> sjanssen: ah, didn't think about the O(n^2)... As for insertWith', it doesn't seem to make any difference
12:15:25 <roderyk> Will look into Set FilePath
12:15:41 * gwern likes to Set.toList . Set.fromList trick if you don't need a stable sort
12:15:53 <sjanssen> roderyk: how many files do you have?
12:16:05 <vincenz> :t listFromMaybes
12:16:06 <lambdabot> Not in scope: `listFromMaybes'
12:16:13 <vincenz> @hoogle [Maybe a] -> [a]
12:16:14 <lambdabot> Data.Maybe.catMaybes :: [Maybe a] -> [a]
12:16:23 <roderyk> sjanssen: well, I'd like to be able to find duplicates in my entire /home/... ;-)
12:16:27 <chessguy> vincenz,  Not in scope: `A1..'
12:16:36 <Sadache> paolino: I love haskell, a verry concise solution you did, thanks again
12:17:01 <vincenz> chessguy: add a space
12:17:09 <vincenz> module syntax
12:17:21 <Sadache> i just changed the ordinant to function in the parameters not to create an instance for each time i want to use the method
12:17:35 <sjanssen> roderyk: also, return $! (hash . B.unpack) l
12:17:46 <sjanssen> roderyk: that is probably your largest memory waster right there
12:18:19 <ziman> @hoogle (Monad m, Monad n) => m a -> n a
12:18:19 <lambdabot> Prelude.id :: a -> a
12:18:19 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
12:18:19 <lambdabot> Data.Function.id :: a -> a
12:18:31 <sjanssen> roderyk: why do you convert Word160 to a String?
12:18:50 <chessguy> vincenz, http://hpaste.org/7083#a3
12:18:55 <gwern> sjanssen: don't some crypto libs use word160?
12:18:57 <vincenz> chessguy: http://hpaste.org/7083#a4
12:19:14 <sjanssen> gwern: sure, but why convert it to a String to be used as a key in a Map
12:19:26 <sjanssen> Word160 will almost certainly be faster
12:20:02 <krist> hi, cale
12:20:03 <roderyk> sjanssen: because Word160 in the crypto is not an Ord?
12:20:10 <sjanssen> roderyk: ah, that is unfortunate
12:20:15 <roderyk> I think that was why I just hacked it to a string
12:20:20 <vincenz> chessguy: http://hpaste.org/7083#a5
12:20:24 <vincenz> chessguy: that one complies
12:20:31 <vincenz> you were also missing 'deriving Eq' on PieceColor
12:20:35 * gwern can't answer that. I assumed it was going to be printed out at some point
12:20:42 <sjanssen> roderyk: that qualifies as a bug IMO, you might want to send a mail to the crypto maintainer
12:20:45 <chessguy> yeah, i figured out the deriving Eq :)
12:20:53 <chessguy> thanks
12:21:17 <Cale> hi
12:21:33 <chessguy> hi Cale
12:28:17 <Sadache> http://hpaste.org/7084
12:30:51 <paolino> ;-)
12:31:54 <eugman> is there a distinction between [char] and string?
12:31:58 <Baughn> No.
12:32:24 <Twey> eugman: type String = [Char]
12:32:26 <krist> there is no spoon
12:32:28 <Baughn> It's a type synonym - they're expanded before /anything/ else is done, so they're absolutely identical
12:32:51 <eugman> ok
12:33:01 <Baughn> (GHC does like to say String instead of [Char], though. I wonder what rules cause that..)
12:33:22 <roderyk> after applying all suggestions, I got a sample output to drop from 66M to 42M. Something is still chewing up my memory like crazy but all I can figure out is its something called Generation: 0. When I try to compile my program with -prof I get errors that modules like Data.Digest.SHA1 are not found (even though they clearly work otherwise...)
12:33:57 <vincenz> roderyk: you might have to install the profiling versions
12:34:21 <roderyk> of those libs? can't I somehow tell ghc to only compile my stuff with prof?
12:34:34 <vincenz> Don't think that'll work
12:34:40 <Baughn> roderyk: "Generation: 0" is a GC term referring to memory areas. Anything that is collected on the first GC will be in G0; anything that doesn't will (eventually, after more GCs?) be promoted to generation 1..
12:35:10 <eugman> So, what does Occurs check: cannot construct the infinite type: t = [t] mean exactly?
12:35:12 <roderyk> Baughn: ah, ok
12:35:21 <Baughn> roderyk: So all that tells you is that the data being collected isn't used very long. Which is always the case.. it's the generational hypothesis, the only thing that makes a generational GC worthwhile at all
12:35:51 <Cale> eugman: It means that the expression you wrote would have to have a type which is effectively an infinitely nested list type.
12:35:54 <Baughn> roderyk: More or less "Data will probably survive an amount of time proportional to the amount it has lived so far"
12:36:08 <Cale> eugman: (which typically indicates something is wrong)
12:36:22 <Cale> > let x = head x in x
12:36:23 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
12:36:23 <lambdabot>       Expected...
12:36:41 <eugman> hmm
12:36:43 <Cale> > let x = [x,x] in x
12:36:44 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
12:36:44 <lambdabot>       Expected...
12:37:03 <gwern> profiling can be hard to set up
12:37:05 <gwern> because you nede to install everything profiled
12:37:07 <gwern> somethings can't be profiled; for example, Yi can't be profiled since it uses GHC as a library
12:37:13 <krist> (\x -> x x) again?
12:37:22 <Cale> > (\x -> x x)
12:37:23 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
12:37:23 <lambdabot>     Probab...
12:37:26 <krist> :D
12:37:31 <Cale> That's slightly different :)
12:37:31 <gwern> (man, this bites. identical cabal file, more or less identical repo, but one builds cleanly and  t'other fails with horrible link errors.)
12:38:09 <dcoutts_> gwern: both from clean dist/ ?
12:38:15 <krist> cale: well, isn't [t] short-hand for some monady stuff which would be a function application of some sort?
12:38:19 <dcoutts_> gwern: what kind of linker errors?
12:38:27 <Cale> krist: [t] means the type of lists of values of type t
12:38:46 <Cale> :t [1,2,3]
12:38:47 <lambdabot> forall t. (Num t) => [t]
12:38:50 <krist> n/m
12:38:55 <Cale> :t ["hello", "world"]
12:38:56 <lambdabot> [[Char]]
12:39:00 <Jaak> @type (\x -> x x) :: (forall a. a -> b) -> b
12:39:01 <lambdabot> forall b. (forall a. a -> b) -> b
12:39:10 <Jaak> :)
12:42:24 <Cale> I wonder if there's a suitable selection of higher rank types to make the y combinator typecheck.
12:42:36 <gwern> dcoutts_: annoying stuff like 'hscurl.c:(.text+0x464): undefined reference to `curl_easy_setopt'
12:42:59 <dcoutts_> gwern: perhaps not linking to libcurl properly?
12:43:16 <dcoutts_> gwern: I assume curl_easy_setopt is defined in libcurl
12:43:25 <gwern> no doubt there's a subtle change somewhere which messed things up
12:43:48 <chessguy> > map (`div` 8) [0..63]
12:43:49 <lambdabot>  [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4...
12:43:56 <krist> cale: i got GBA series 1,2 & 3 plus the miniseries and webisodes. :P
12:44:00 <chessguy> > map (`mod` 8) [0..63]
12:44:01 <lambdabot>  [0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5...
12:44:17 <gwern> dcoutts_: presumably
12:44:23 <krist> cale: er, BGA
12:44:24 <Valodim> > cycle [0..7]
12:44:28 <lambdabot>  [0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5...
12:44:31 <Cale> krist: BSG? :)
12:44:46 <chessguy> @pl \n -> n `d` 8
12:44:46 <lambdabot> (`d` 8)
12:44:49 <krist> cale: that's the one
12:44:54 <Cale> cool
12:45:07 <krist> Acronyms.BSG hiding (BGA)
12:48:05 <chessguy> @src Eq
12:48:05 <lambdabot> class  Eq a  where
12:48:05 <lambdabot>     (==), (/=)   :: a -> a -> Bool
12:48:26 <byorgey> > liftM2 (zipWith ((+) . (*8))) (map (`div` 8)) (map (`mod` 8)) $ [0..63]
12:48:27 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
12:50:34 <macondo> so that does basically nothing?
12:51:26 <bos> @seen dons
12:51:26 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc and #haskell. I last heard dons speak 1h 6m ago.
12:51:39 <byorgey> macondo: it's the identity on lists of integers, yes
12:51:57 <Cale> macondo: It illustrates the relationship between div and mod
12:51:58 <byorgey> at least, lists of positive integers, I'm not sure if it works for negative integers too
12:51:59 <roderyk> turns out the memory killer is "hashes <- mapM (\x -> hashFile x) files"
12:52:04 <byorgey> it should I think
12:52:15 <Cale> > liftM2 (zipWith ((+) . (*8))) (map (`div` 8)) (map (`mod` 8)) $ [-10..0]
12:52:16 <lambdabot>  [-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0]
12:52:18 <olsner> > liftM2 (zipWith ((+) . (*8))) (map (`div` 8)) (map (`mod` 8)) . map negate $ [0..63]
12:52:19 <lambdabot>  [0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-2...
12:52:28 <byorgey> @check \xs -> liftM2 (zipWith ((+) . (*8))) (map (`div` 8)) (map (`mod` 8)) $ xs == xs
12:52:29 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Bool'
12:52:38 <roderyk> not sure why; files <- filterM doesFileExist fs  is just as big of a (length list)
12:52:42 <byorgey> @check \xs -> liftM2 (zipWith ((+) . (*8))) (map (`div` 8)) (map (`mod` 8)) xs == xs
12:52:43 <lambdabot>  OK, passed 500 tests.
12:52:50 <eugman> Hmmm, how do I apply words to the result of a getline and then send the word list to a function?
12:53:08 <Baughn> roderyk: How many files are we talking here?
12:53:35 <sjanssen> roderyk: did you get my comment about about strict returning the hash from hashFile?
12:53:36 <Cale> do l <- getLine; f (words l)
12:53:44 <gwern> gods fornicate me for a whore! it was extra-libraries: curl that was needed, but I'll be dashed if I ken why t'one and not t'other yens for it
12:54:04 <olsner> f . words <$> getline ;-)
12:54:09 <sjanssen> roderyk: you're keeping all of your files in memory
12:54:10 <roderyk> Baughn: 21 files for testing
12:54:11 <Baughn> roderyk: I imagine the memory use is in thunks built by the hashFile function, not the length of the list as such
12:54:18 <Baughn> roderyk: RIght. 21 hashes don't take much memory
12:54:32 <olsner> or f . words =<< getline
12:54:43 <eugman> olsner, I understood cale's response but what is this magic you speak of
12:54:53 <Baughn> roderyk: 21 chains of thunks that, when forced, will build a hash.. do. For one thing they'd include the entire file
12:54:57 <sjanssen> roderyk: return $! (has . B.unpack) l
12:54:58 <roderyk> sjanssen: return $! (hash . B.unpack) l doesn't help
12:55:02 <Baughn> roderyk: You'll want to make hashFile strict
12:55:03 <sjanssen> hmm
12:55:31 <gwern> dcoutts_: hey, does specifying an uninstalled library in extra-libraries: do anything bad?
12:55:33 <bos> @hoogle traverse
12:55:34 <lambdabot> Data.Traversable.traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:55:34 <lambdabot> Data.Foldable.traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
12:55:51 <Baughn> roderyk: (That /could/ be done by adding an evaluate call at the end, but you'd still be loading /each file/ into memory before hashing it, instead of doing it incrementally. Assuming that is, in fact, what happens - I haven't read the code.
12:55:52 <dcoutts_> gwern: it means it'll fail at link time
12:56:02 <Cale> eugman: More or less another way to write the same thing without the do-notation.
12:56:06 <bos> hmm, it would be nice if hoogle could tell us which package a module lived in.
12:56:17 <Cale> eugman: The do-notation desugars into applications of >>= and >>
12:56:18 <roderyk> Baughn, sjanssen: Bytestring.readFile is lazy. is that the problem?
12:56:22 <dcoutts_> gwern: oh, you mean a lib that is available in the local dirs rather than globally installed?
12:56:26 <roderyk> should I just open and close a handle manually?
12:56:27 <olsner> eugman: the first one is possibly more magic than what is really appropriate ;-) the second one is using =<< for sequencing instead of do-blocks
12:56:36 <Baughn> roderyk: No. If it /wasn't/, that /would/ force it to load the entire file.
12:56:41 <sjanssen> roderyk: which ByteString are you using? (by the way, you really should put your imports in the paste too)
12:56:44 <dcoutts_> gwern: it's possible with an appropriate lib dirs
12:56:52 <gwern> dcoutts_: well, I mean if the uninstalled library isn't actually used - ie I might want to specify :extra-libraries: curl, www, but the configure passes CPP flags such that say Curl only gets used
12:56:58 <Baughn> roderyk: Can I see the hashFile code?
12:56:58 <olsner> b =<< a === do x <- a; b a
12:57:03 <olsner> *b x
12:57:07 <eugman> olsner, I tried desurging it myself but couldn't get it to work. However <$> looks unfamiliar to me
12:57:17 <gwern> dcoutts_: so I automatically cover the case where curl is uninstalled, and configure enables the libwww code instead
12:57:22 <Cale> olsner: Actually, are you sure the first version has the right type?
12:57:27 <sjanssen> gwern: you're generating a .buildinfo, right?  You can stick extra-libraries in there
12:57:31 <Cale> olsner: You need an extra join I think.
12:57:47 <gwern> sjanssen: good point
12:58:09 <Cale> :t \f -> f . words <$> getLine
12:58:11 <lambdabot> forall b. ([String] -> b) -> IO b
12:58:16 <Cale> :t \f -> fmap (f . words) getLine
12:58:17 <lambdabot> forall b. ([String] -> b) -> IO b
12:58:20 <dcoutts_> gwern: yeah, use .buildinfo, having both may work ok with gnu ld, but not all linkers necessarily.
12:58:24 <Cale> :t \f -> join (fmap (f . words) getLine)
12:58:25 <lambdabot> forall a. ([String] -> IO a) -> IO a
12:58:35 <dcoutts_> gwern: eg it'd definately fail with the ghci linker
12:58:45 <chessguy> @type let f = `div` 8 in f
12:58:46 <lambdabot> parse error on input ``'
12:58:55 <olsner> Cale: yeah, it depends on what f is, and my two alternatives are different :P
12:59:01 <roderyk> Baughn, sjanssen: ah, sorry. http://hpaste.org/7082#a2
12:59:02 <chessguy> @type let f = (`div` 8) in f
12:59:03 <lambdabot> forall a. (Integral a) => a -> a
12:59:17 <chessguy> well that's silly
12:59:26 <Cale> Of course, join and fmap combine to make >>=
12:59:38 <roderyk> at least now I have an idea what's wrong.. it's loading all the files into memory :)
12:59:48 <fnord123> is there something like github but for darcs?
13:00:57 <gwern> fnord123: not really. there's community hosting provided at *.haskell.org
13:03:35 <Baughn> roderyk: You're using strict bytestring, not lazy. That read is strict.
13:04:08 <Sadache> is there any shortcut to sum (map (fst) [(1,'a'),(2,'b')]) in standard libraries?
13:04:34 <Baughn> roderyk: Beyond that I'd have to check the implementation of Crypto, but I /would/ expect it to be appropriately strict
13:04:43 <Sadache> like sum (fst) [(1,'a'),(2,'b')]
13:05:02 <Heffalump> I doubt it, that's already pretty concise IMO
13:05:06 <Baughn> roderyk: It's just that the way you've written this requires the entire file to be in memory before any hashing can take place. Import Data.ByteString.Lazy instead, and see if it doesn't magically fix itself.
13:05:13 <Heffalump> if you don't like the parens use sum $ map fst [...]
13:05:14 <wjt> let fstSum = sum . map first
13:05:31 <roderyk> Baughn: oh my, you're right. importing Data.ByteString.Lazy drops the mem usage
13:06:02 <roderyk> Baughn, sjanssen: many thanks... I've been sitting over this so long ><
13:06:06 <Baughn> roderyk: That's what you get for not reading the documentation. That for the readFile you were using explicitly claims it's /strict/. :P
13:06:23 <Baughn> roderyk: And "strict read" = "Can't do anything with data until it's all in memory"
13:06:24 <roderyk> Baughn: I did read the docs; no idea how I missed that :P
13:06:27 <Sadache> Heffalump: that will do it thank you
13:08:16 <Sadache> wjt: or sumOn f= sum . map f
13:08:52 <eugman> Gah, I can't seem to do this right. Right now I'm trying to make a simple function to build on but I can't seem to get it right. I want a function that takes a list of words, prints the first one and then sends the list to itself without the first one
13:09:08 <eugman> whoops, i guess I repeated myself slightly
13:09:24 <Baughn> roderyk: Out of curiosity, how much did it drop?
13:11:29 <cjb> eugman: so, in pseudocode, words (x:xs) = show x + words xs ?
13:12:58 <eugman> cjb, right but I keep screing something up
13:14:48 <Sadache> cant i pass a function to map with putting it between parens
13:14:50 <Sadache> ?
13:15:05 <roderyk> Baughn: from 48M to 3M
13:15:21 <Baughn> I was hoping it would be something like that. :)
13:15:43 <Heffalump> Sadache: yes
13:16:03 <Heffalump> your parens around (fst) in your original question are completely redundant
13:16:05 <Sadache> it doesnt work for me
13:16:28 <Heffalump> > sum (map fst [(1, 'a'), (2, 'b')])
13:16:30 <lambdabot>  3
13:16:35 <Sadache> sum $ map (facesNumber) rs gives an error
13:16:48 <Heffalump> then you have some other problem
13:16:54 <Heffalump> > sum $ map fst [(1, 'a'), (2, 'b')]
13:16:55 <lambdabot>  3
13:16:56 <Sadache> sorry sum $ map facesNumber rs gives an error
13:17:12 <Botje> Sadache: "gives an error" is really not very easy to help with. can you be more precise?
13:17:13 <Heffalump> you have quite a serious problem if it works with those parens and not without them
13:17:13 <Sadache> when i put the parens, it removes the error
13:17:27 <Heffalump> since they should be completely equivalent
13:18:56 <Sadache> sum $ map facesNumber.fst ms
13:19:09 <Sadache> gives a type error like
13:19:35 <Sadache> *** Term           : ms
13:19:43 <chessguy> Sadache, it has to be sum $ map (facesNumber.fst) ms
13:19:45 <Sadache> *** Type           : [(Repartition,Commun)]
13:20:03 <Sadache> so i cant write it without parens?
13:20:24 <chessguy> not if you're going to compose two functions to pass in
13:20:27 <shachaf> Sadache: You can, but it'll mean something else.
13:20:34 <shachaf> Sadache: That's what parentheses are for. :-)
13:20:44 <Sadache> ok :) thanks
13:20:57 <Sadache> i see now the problem, thanks
13:20:58 <shachaf> Sadache: Function application is the most "sticky"; f x . g y means ((f x) . (g y))
13:21:09 <chessguy> Sadache, you could write sum $ map foo ms
13:21:10 <chessguy> where foo = facesNumber . fst
13:21:23 <chessguy> (except properly indented)
13:22:08 <Sadache> i thought that f.g is exactly like (f.g)
13:22:21 <Heffalump> it is, up to precedence
13:22:33 <Heffalump> it's the same if you think of a syntax tree, but parens affect parsing
13:23:29 <Sadache> but map f.g xs  get parsed as map f(g(xs))
13:24:06 <Baughn> Shouldn't that get parsed as (map f).g xs?
13:24:12 <allbery_b> (map f) . (g xs)
13:24:17 <vincenz> ouch
13:24:28 <vincenz> wadler's work was called 'irrelevant'
13:24:30 <Baughn> Function application binds tightest of all
13:24:47 <Sadache> at least it is not parsed as map (f.g) xs
13:25:06 <Baughn> > map f.g xs
13:25:07 <lambdabot>   Not in scope: `xs'
13:25:11 <Baughn> > map f.g xs :: Expr
13:25:12 <lambdabot>   Not in scope: `xs'
13:25:23 <Baughn> > map f.g a :: Expr
13:25:24 <lambdabot>  Couldn't match expected type `Expr'
13:25:32 <Heffalump> vincenz: where?
13:25:38 <Baughn> ..I know that thing works for /other/ people
13:25:46 <wjt> @type f
13:25:49 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
13:25:50 <xerox> > map f . g :: [Expr]
13:25:51 <lambdabot>  Couldn't match expected type `Expr' against inferred type `f b'
13:25:54 <vincenz> Heffalump: http://groups.google.com/group/clojure/browse_thread/thread/d94f9434155703fd
13:25:57 <lambdabot> Title: Lazier sequences - Clojure | Google Groups, http://tinyurl.com/62f6q9
13:26:03 <vincenz> time to throw some oil on the flame
13:26:04 <Baughn> @type (f,g,a)
13:26:06 <lambdabot> forall a a1. (SimpleReflect.FromExpr a1, SimpleReflect.FromExpr a) => (a, a1, Expr)
13:26:07 <chessguy> > map f.g [1..5] :: Expr
13:26:08 <lambdabot>  Couldn't match expected type `Expr'
13:26:15 <opqdonut> chessguy: parenthesis
13:26:15 <chessguy> > map (f.g) [1..5] :: Expr
13:26:16 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[b]'
13:26:16 <xerox> It's a list!
13:26:19 <Baughn> > map f.g a
13:26:20 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr (f (f1 a)))
13:26:30 <chessguy> opqdonut, that was the point
13:26:47 <vincenz> Heffalump: http://reddit.com/info/6ggon/comments/
13:26:58 <Baughn> > map f.g h
13:26:59 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr (f (f1 a)))
13:27:36 <chessguy> vincenz, his _terminology_ was called irrelevant, taht's a little different
13:27:46 <arnar_> hey folks..
13:28:01 <vincenz> chessguy: bah, starting to start fire here :|
13:28:24 <arnar_> is there some built-in shortcut for this:  do { x <- whatever1 ; whatever2 ; return x }  ?
13:28:30 <vincenz> yes
13:28:43 <vincenz> whatever1 >>= \x -> whatever2 >> return x
13:28:50 <arnar_> ah..
13:28:51 <arnar_> thanks
13:28:56 <arnar_> :src (>>)
13:29:00 <vincenz> though that's not very different
13:29:09 <vincenz> another idea
13:29:15 <allbery_b> @src Monad (>>)
13:29:15 <lambdabot> Source not found. My brain just exploded
13:29:17 <vincenz> liftM head $ sequence [whatever1, whatever2]
13:29:34 <allbery_b> hm  default definition of (>>) is in terms of (>>=) anyway
13:29:36 <arnar_> heh :)
13:29:42 <arnar_> allbery_b: ok.. thx
13:29:49 <allbery_b> but individual monads supply their own definitions of (>>=) and sometimes (>>)
13:29:53 <arnar_> this seems to come up often with the eof parser
13:30:09 <arnar_> parse something.. invoke eof.. return "something"
13:30:20 <allbery_b> default x >> y = x >>= \_ -> y
13:30:50 <Baughn> @. pl undo do x <- foo; bar; return x
13:30:51 <lambdabot> (bar >>) . return =<< foo
13:32:29 <vincenz> arnar_: liftM head $ sequence [whatever1, whatever2]
13:33:05 <mg262> I'm just starting with Haskell and I had a beginner's question ... is this an appropriate place to ask it?
13:33:09 <vincenz> or define
13:33:11 <allbery_b> certainly
13:33:12 <arnar_> vincenz: yeah.. the do block is better though :)
13:33:20 <Baughn> mg262: No better place
13:33:23 <vincenz> before a b = do { x <- a; b; return x }
13:33:31 <mg262> thanks!
13:33:41 <vincenz> parser `before` eof
13:33:50 <mg262> I find myself writing things like
13:33:52 <mg262> stripbraces :: Monad m => String -> m String
13:33:52 <mg262> stripbraces c = stripleft '{' c >>= stripright '}'
13:33:58 <arnar_> vincenz: yeah.. was writing that when I thought of coming here to ask if there was sth. like it in the lib :)
13:34:12 <mg262> and it feels a little ugly to have the 'c' in there...
13:34:19 <mg262> I want to write something like
13:34:38 <mg262> stripbraces = stripleft '{' >>. stripright '}'
13:34:41 <mg262> instead
13:34:50 <allbery_b> @unpl \c -> stripleft '{' c >>= stripright '}'
13:34:50 <lambdabot> \ c -> (stripleft '{' c) >>= (stripright '}')
13:34:50 <mg262> now, I have the impression that you can create your own operators... but
13:34:54 <mg262> now, I have the impression that you can create your own operators... but
13:34:55 <allbery_b> hm
13:35:01 <vincenz> @undo \ c -> (stripleft '{' c) >>= (stripright '}')
13:35:02 <lambdabot> \ c -> (stripleft '{' c) >>= (stripright '}')
13:35:05 <allbery_b> @pl \c -> stripleft '{' c >>= stripright '}'
13:35:05 <lambdabot> (stripright '}' =<<) . stripleft '{'
13:35:05 <vincenz> @pl \ c -> (stripleft '{' c) >>= (stripright '}')
13:35:05 <lambdabot> (stripright '}' =<<) . stripleft '{'
13:35:09 <allbery_b> backewards, duh
13:36:43 <mg262> thanks...
13:36:55 <mg262> what is the lambdabot doing? It's a bit confusing...
13:36:55 <gwern> @hoogle system
13:36:56 <lambdabot> System.Cmd.system :: String -> IO ExitCode
13:36:56 <lambdabot> Distribution.System :: module
13:36:56 <lambdabot> System.Cmd.rawSystem :: String -> [String] -> IO ExitCode
13:37:45 <Baughn> mg262: Applying "simplification" rules to drastically complicate a statement by getting rid of all points
13:37:56 <Baughn> mg262: Well, you lucked out this time. That one looks workable.
13:38:21 <mg262> I see -- thanks!
13:39:44 <allbery_b> Be aware, btw, that removing all points can change the behavior of a top level expression unless you also disable the monomorphism restriction
13:40:41 <Baughn> Change the behaviour? I thought it'd simply fail to compile
13:40:45 <mg262> Um... that's over my head I am afraid; I've only been using Haskell for a couple of days.
13:41:27 <allbery_b> Sometimes it fails to compile, other times it just changes the type in an unexpected way
13:41:46 <Baughn> mg262: Under certain unusual circumstances, the typechecker manages to figure out that a statement with points is valid, but doesn't do the same for the equivalent pointless version. Among other things. You can disable the check, which will make things work if it is, in fact, valid and make them go pear-shaped if it isn't.
13:42:24 <allbery_b> mg262: basically, if you have a function that doesn't take any explicit arguments but takes an implicit one (that is, a pointfree definition), the typechecker will restrict it to a more limited type than it would naturally take.
13:42:45 <Baughn> mg262: Also, the problem can always be solved by adding an explicit type signature
13:43:01 <Baughn> mg262: Which is good sense for all top-level statements anyhow, especially when you're new. So don't worry about it.
13:43:39 <mg262> Right -- thank you. I am giving explicit type signatures to all the functions I write anyway, so things should be all right.
13:43:50 <allbery_b> Sometimes this will result in a type error later on, but if you don't happen to do anything that forces a particular type (or typeclass) then you can end up with a surprise at runtime when your "obviously should produce a Double" turns out to never have decimal points because it got MMRed into an Int
13:43:57 <mg262> Is it generally considered cleaner to write point-free code?
13:44:06 <allbery_b> Not fully pointfree
13:44:24 <Baughn> mg262: It's considered cleaner to write cleaner code
13:44:38 <Baughn> Exactly what that /means/ is highly subjective - where it isn't, it tends to be obvious
13:45:03 <Baughn> So use pointsfree where it makes sense (eg. "map (+2) list"), and don't where it makes things more complicated
13:45:07 <mg262> I didn't like the original example
13:45:09 <allbery_b> Point-free code has some advantages from the standpoint of reasoning about types.  From a *coding* standpoint, it's often clearer to include points (variables)
13:45:09 <mg262> stripbraces c = stripleft '{' c >>= stripright '}'
13:45:38 <mg262> because it seem to imply that there was some asymmetry between stripleft and stripright
13:45:44 <Baughn> mg262: If you find yourself typing that sort of thing a lot, you can make it a separate function
13:45:45 <mg262> *seemed to
13:45:51 <allbery_b> I would argue that, while the pointfree version of that isn't nearly as bad as some of them get, the original is still a bit more comprehensible
13:45:52 <gwern> is anyone here familiar with the 'system' function in System.Cmd? how would I pass the shell a '-r' option using it?
13:46:05 <Baughn> mg262: Alternately, the do-syntax version should be fairly clean
13:46:19 <allbery_b> gwern: you don't.  Use runInteractiveProcess and do it yourself.
13:47:12 <mg262> Anyway -- thanks for all the help!
13:48:04 <gwern> allbery_b: I see.
13:48:04 <gwern> @hoogle runInteractiveProcess
13:48:04 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
13:49:17 <gwern> allbery_b: ouch. all I want is to add an option, is all that really necessary?
13:49:20 <allbery_b> The standard C library's system() and wrappers of it in other languages (including Haskell) are quite simplistic.  If you want anything it doesn't already do, you have no choice but to use lower level facilities.  (Perl is an exception, but only in later versions; the original Perl system() was just as restrictive)
13:49:50 <allbery_b> system() gives you "/bin/sh" "-c" (your single string argument).  period.
13:50:03 <allbery_b> No option to wedge a -r into sh's argument.
13:50:56 <gwern> hm. I may have a portability problem to begin with - I want to use -r to get a restricted shell, but I suspect window's shell thingy doesn't respect -r like /bin/sh does
13:51:01 <allbery_b> I generally consider it a quick-and-dirty function that is often better handled in some other way
13:51:33 <allbery_b> oh yeh, CMD.EXE doesn't do restricted mode, you *must* use Windows groups to achieve that
13:51:58 <gwern> :(
13:52:10 <fnord123> sjanssen: with X11-xdamage, do you think it's worthwhile to have autoconf stuff to have a stubbed interface or shall I just make the module used and if someone doesn't support xdamage then they simply can't import it?
13:52:20 <fnord123> Xinerama has a conditional compilation system
13:52:25 <fnord123> @seen sjanssen
13:52:25 <lambdabot> sjanssen is in #xmonad, #haskell-soc and #haskell. I last heard sjanssen speak 54m 58s ago.
13:52:50 <gwern> well, maybe that's not so bad - I don't know what you could put in a darcs hook that would work on both windows and unixes
13:52:51 <allbery_b> actually, sh -r is generally considered a bad idea because unless you are very careful about the environment you present to the user it's easily circumvented
13:53:27 <gwern> allbery_b: it's better than just 'sh' though, no?
13:53:30 <allbery_b> Windows group policy is a good example of the correct way to do it, to be honest
13:53:36 <allbery_b> not by much
13:55:12 * gwern will take what I can get
13:57:24 <allbery_b> sh -r is only better than sh if you construct an entire carefully encapsulated environment.  Otherwise all you do is annoy people who know what they're doing while providing a rather simplistic hoop for troublemakers to hop through
13:58:10 <allbery_b> (in particular, if there is anything on $PATH that also knows how to do system(), it's trivial to escape your restricted shell)
13:59:14 <Baughn> Worse. You'd be assuming that /none/ of the programs in your path have exploitable security holes.. that under other circumstances wouldn't be holes at all
13:59:23 <Baughn> Nobody will be looking for those
13:59:24 <allbery_b> exactly
13:59:54 <allbery_b> and there's an insane number of commonly used and "safe" programs that make it utterly trivial to break out of a restricted shell.
14:01:01 <allbery_b> you annoy folks who know what they're doing and "restrict" troublemakers with a single layer of kleenex
14:01:53 <qwr> trying to close holes is anyway stupid security
14:02:42 <qwr> (as opposed to just taking a thing that knows only how to do the necessery stuff)
14:05:03 <eugman> How do I filter a list based on wether those items are in another list?
14:05:11 <gwern> qwr: alas, I know of no capability-security based approaches darcs could take
14:05:41 <qwr> eugman: filter (`elem` list)
14:05:55 <gwern> eugman: offhand, I'd say convert into sets, do a difference of the two sets, and then convert back into a list
14:06:14 <gwern> but qwr's approach works as well (different complexity though, no?)
14:06:58 <qwr> gwern: if the set isn't stupid, should be different?
14:08:35 <gwern> qwr: well, for really long lists I think you'd pay the O(n) cost or whatever of elem N times, right? since filter here is akin to map (\x -> if x `elem` otherSet then [] else x)
14:08:48 <eugman> The list is short fortunately
14:09:37 <gwern> (and N*N would be O(N^2) if I follow, which is bad)
14:09:56 <qwr> gwern: the stupid list aproach is obviously O(nm) - multiple of both list lengths
14:10:36 <gwern> hm? oh, you're right
14:10:37 <qwr> gwern: i think tree based set should allow some kind of nlogn for the whole operation?
14:10:49 <gwern> after all, can't assume the two lists are the same size
14:11:31 <gwern> qwr: I would expect something like that - going through set doesn't make a stable sort; throwing out constraints usually leads to speed improvements :)
14:12:51 <gwern> let's see.... fromList is O(n*log n), toList is O(n), and difference is O(n+m); so add'em together
14:33:53 <bos> @seen dons
14:33:53 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc and #haskell. I last heard dons speak 2h 48m 27s ago.
14:35:08 <nooga> ;|
14:53:18 <gwern> I've always wondered whether wormholes and relativistic time travel imply P=NP
14:53:48 <Beelsebob> gwern: no
14:53:55 <gwern> *or
14:53:57 <Beelsebob> it just allows for non-determanism
14:54:08 <Beelsebob> (and hence allows you to compute NP easily)
14:54:22 * clanehin repeatedly says things in #darcs that get responses in #haskell.
14:59:07 <Sadache> good night everyone
14:59:20 <Sadache> and thanks again for help
15:05:55 <lispy> Whoa, non-determanism is implied by relativity?
15:06:23 <jorick> i would like to have a log file in such a way that it always has maximum 1000 lines. when new lines get added (probably fairly often), i want the first ones to disappear. how would i go about this?
15:10:11 <kfish> lispy, god does not play dice
15:11:06 <lispy> jorick: fseek ?
15:11:29 <lispy> jorick: are you okay with rewriting the file on each line?
15:11:35 <jorick> could you give a bit more information?
15:11:36 <jorick> well
15:11:41 <jorick> i'd rather not actually
15:12:03 <lispy> jorick: well, fseek is just a way in C, to go to a specific place in a file...I'm not serious about that solution.
15:12:39 <Cale> lispy: By relativity?
15:12:44 <jorick> oh, i thought i recognized it :D
15:13:13 <lispy> jorick: I don't know of a nice way to do this actually.  I know of a nice way to store it in memory, but I don't know a way to minimize the disk writes unless you can write each line as a record and treat it like a binary file or some such
15:13:46 <monochrom> It seems sufficient to store 1000 pointers in memory.
15:13:48 <jorick> i think i just thought of something
15:15:19 <jorick> but it only works when i make all the lines the same length (to have the X bytes of the file indicate the index in the file where the readin begins)
15:15:31 <jorick> the first X bytes
15:15:51 <monochrom> Here is an idea borrowed from Thunderbird. In memory remember which lines to delete and which to keep (just pointers), but don't modify the file yet. After a large number of lines to add/delete is accumulated, create the new file and then replace the old file in one swoop.
15:16:22 <jorick> ah, that's a nice idea indeed.
15:17:23 <monochrom> Thunderbird tries to accumulate 100KB (or whatever you like) of stuff to delete before purge them from files.  Stuff to add is immediately appended to files.
15:49:57 <gwern> man. I wish haddock had better error messages
15:50:53 <MyCatVerbs> gwern: have you tried battering it and serving with chips?
15:52:46 <gwern> MyCatVerbs: no; I need to watch my cholesterol
15:54:14 <MyCatVerbs> gwern: why? It's not going to go anywhere.
15:54:20 <MyCatVerbs> gwern: oh wait, that's the problem, isn't it?
15:55:33 <gwern> indeed. cholesterol is like a bad guest
15:56:25 <MyCatVerbs> Or a turd in a salad bowl.
15:56:35 <MyCatVerbs> Or a dead mouse in a cupboard.
15:57:12 <gwern> it just won't leave when the welcome is worn out
15:57:54 <dmwit> Frying it up makes it taste better, but it still isn't nutritious.
15:58:44 <MyCatVerbs> dmwit: haddock? Not nutritious? What planet are you on?
15:59:17 <dmwit> It's an analogy!  Nutrition = knowledge of what's wrong.
15:59:21 <dmwit> Taste = readability.
15:59:38 <dmwit> You could always fry it up (make it more readable), but that alone doesn't help solve the problem...
16:00:33 <nooga> i just ate a kilo of grilled pork xD
16:13:31 <vincenz> nooga: I hope you're not muslim then
16:13:57 <allbery_b> or jewish
16:14:12 <vincenz> if it is kosher it's fine, I thought
16:14:22 <allbery_b> pork is not kosher
16:14:26 <vincenz> nver?
16:14:29 <allbery_b> never
16:14:34 <vincenz> Actually, those two make sense.
16:14:49 <vincenz> Since it stops people from being cannibals (It's been proven that burned human meat and pork taste nearly the same)
16:15:08 <vincenz> Anywho, OT
16:15:41 <allbery_b> actually, from a historical standpoint bith the jewish and muslim restrictions are more closely related to the problem that raising pigs takes up resources needed to keep humans alive in arid and semi-arid environments
16:15:45 <pizza_> yuck, pork
16:15:48 <pizza_> i prefer human
16:15:59 <allbery_b> (pigs eat the same things people do, but more of it; and they fgoul water supplies)
16:16:08 <vincenz> allbery_b: pigs and people, one and the same
16:16:54 <thoughtpolice> #haskell -> #cannibalism-facts ?
16:18:18 <vincenz> thoughtpolice: You must be new
16:18:24 <vincenz> Obviously it's
16:18:36 <vincenz> Monad m => #haskell -> m #cannibalism-facts
16:19:20 <thoughtpolice> vincenz: :) something must have seriously gone awry in policy the past 4 days I've been out
16:20:01 <thoughtpolice> it's the twilight zone, only my IRC client lets me see blue as well as white and black
16:20:27 <vincenz> No, that's just the stuff we put in your drink
16:21:22 <thoughtpolice> spiked drinks == :(
16:21:36 * Cale makes silly close-up pictures of his face with his new camera.
16:22:08 <Cale> http://cale.yi.org/autoshare/me-silly.jpeg
16:22:26 <dmwit> Serious cat!
16:22:45 <Cale> http://cale.yi.org/autoshare/Meow.jpg
16:23:20 <dmwit> Wow, you have a very versatile face!
16:23:27 <Cale> hehe
16:23:55 <dmwit> What, that *should* parse as "Me, ow", right? ;-)
16:25:49 <Cale> heh
16:29:00 <gwern> I is -Wall cat. This are serious warning.
16:32:13 <clanehin> Cale has pretty eyes.
16:33:30 <gwern> clanehin: I dunno. I find all that hair pretty distracting
16:33:40 <gwern> it's almost a unibrow
16:35:25 <gwern> 'Victorian criminologist Cesare Lombroso identified unibrows as a sign of criminality'
16:35:31 <Binkley> Does anybody know: 1) what flag to pass to hsc2hs to make it keep temp files, and 2) how to get Cabal to pass that flag to hsc2hs?
16:36:40 <clanehin> gwern: are you actually doing a lolcat?
16:36:54 <clanehin> I mean a lambdacat
16:37:11 <gwern> clanehin: no. but it's a long-standing suggestion of mine
16:37:25 <dmwit> It's a race!
16:37:28 <Binkley> well, someone should do some new lambdacats
16:37:56 <gwern> Binkley: the maintainer is busy; I already emailed my suggestion
16:38:29 <Binkley> gwern: an actual image, or just a suggestion for an image?
16:38:50 <dogbite_> hello all, i have a question about an error that ghc is giving me.
16:38:56 <dogbite_> i have defined the following:
16:38:57 <dogbite_> combinePreds f ps = f . sequence ps
16:38:58 <dogbite_> andPreds          = combinePreds and
16:39:14 <gwern> Binkley: well, I linked to the base srs cat image to use, so it would've been a few minutes max
16:39:24 <Cale> dogbite_: My guess without seeing the error is that you're being bitten by the monomorphism restriction.
16:39:38 <dogbite_>     No instance for (Monad ((->) a))
16:39:38 <dogbite_>       arising from use of `combinePreds'
16:39:38 <dogbite_>       at HHData/Time/RecurringDays.hs:13:20-35
16:39:38 <dogbite_>     Possible fix: add an instance declaration for (Monad ((->) a))
16:39:38 <dogbite_>     In the expression: combinePreds and
16:39:40 <dogbite_>     In the definition of `andPreds': andPreds = combinePreds and
16:39:44 <Binkley> gwern: heh, well, ok. there are some automated lolcat makers out there...
16:39:47 <Cale> dogbite_: oh, okay, that's different :)
16:39:49 <Binkley> that's what we need
16:39:50 <dmwit> import Control.Monad.Reader
16:39:54 <Binkley> a lolcat generator written in haskell
16:39:57 <Cale> right
16:39:58 <dmwit> :t and
16:40:04 <lambdabot> [Bool] -> Bool
16:40:07 <Cale> Or:  import Control.Monad.Instances
16:40:18 <dogbite_> which import is preferred?
16:40:24 <Cale> Either is fine.
16:40:35 <Cale> Really the instance ought to be in the Prelude, but it's not.
16:41:03 <dmwit> dogbite_: See also: all, any
16:41:04 <dmwit> :t all
16:41:06 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
16:41:52 <dogbite_> yes, i can't use all or any because
16:41:57 <dogbite_> this is a list of predicate functions
16:42:03 <dogbite_> not booleans
16:42:04 <dmwit> So?
16:42:10 <dmwit> Functions are first-class in Haskell. ;-)
16:42:24 <dmwit> :t andPreds ps x = all ($ x) ps
16:42:26 <lambdabot> parse error on input `='
16:42:33 <dmwit> :t let andPreds ps x = all ($ x) ps in andPreds
16:42:34 <lambdabot> forall a. [a -> Bool] -> a -> Bool
16:43:24 <dogbite_> well i should revise my statement.  i'm new to haskell so i shouldn't say "can't".  :-)
16:43:41 <dogbite_> i actually asked in here once before and sequence was suggested....
16:43:46 <dmwit> Oh.
16:43:47 <dmwit> heh
16:43:48 <dogbite_> this import is causing an error..
16:43:53 <dogbite_> trying to figure it out...
16:44:14 <Cale> hmm
16:46:31 <dmwit> dogbite_: Often, at the beginning, puzzling through errors for more than thirty seconds or so isn't really helpful.
16:46:33 <dogbite_> any clue on what this sort of error means?
16:46:34 <dogbite_> HHData/HHVector.o: In function `rGT_info':
16:46:35 <dogbite_> (.text+0x4d): undefined reference to `timezm1zi1zi1_DataziTimeziClockziUTC_zdf8_closure'
16:46:36 <dcoutts_> Binkley: looking at hsc2hs --help it looks like --no-compile should help
16:46:38 <dogbite_> HHData/HHVector.o: In function `rGT_srt':
16:46:39 <dmwit> So feel free to post the code and error here at any time.
16:46:43 <dmwit> dogbite_: --make
16:46:50 <dogbite_> what's --make?
16:46:55 <Cale> dogbite_: Oh, that's usually from not including the right packages.
16:46:57 <dogbite_> oh into ghc?
16:47:00 <thoughtpolice> dogbite_: pass it to ghc
16:47:02 <dmwit> dogbite_: Use ghc --make instead of ghc, it will link in stuff.
16:47:04 <dogbite_> okay
16:47:05 <Cale> --make will discover the right packages to use
16:47:11 <thoughtpolice> dogbite_: it automatically finds the packages you need and links them in
16:47:13 <Cale> You could also use -package time  here
16:47:17 <dcoutts_> Binkley: you can make cabal pass any extra flags to any program cabal knows about, just use --PROG-option(s)=
16:47:21 <thoughtpolice> in all but the most trivial cases you'll probably use --make
16:47:23 <thoughtpolice> for it's simplicity
16:47:50 <Cale> Or if you were using cabal, you'd add the time package to your build-depends line.
16:48:20 * dcoutts_ wants cabal to be a bit more like ghc --make / hmake
16:48:24 <Binkley> dcoutts: yeah, I found --no-compile...
16:48:34 <dogbite_> oh now i'm confused.  i actualy just resumed some work on this project.  got away from it for 3 weeks or so
16:48:41 <dogbite_> and i'm seeing something at the bottom of my Makefile
16:48:45 <dogbite_> that looks autogenerated
16:48:56 <dogbite_> is there some haskell tool that reads Makefiles and
16:48:56 <Binkley> dcoutts: but, I added this to my .cabal file:
16:49:03 <dogbite_> inserts haskell dependencies at the bottom?
16:49:04 <Binkley> "hsc2hs-options: --no-compile"
16:49:07 <dmwit> Whoa, a Makefile?
16:49:14 <Binkley> and got an "Unknown fields:" error
16:49:28 <dcoutts_> Binkley: there's no such field
16:49:34 <shapr> hi Binkley!
16:49:36 <Binkley> hi shapr
16:49:43 <shapr> Long time no see on #haskell!
16:49:49 <dcoutts_> Binkley: you can pass --PROG-option= to cabal configure or build
16:49:55 <Binkley> shapr: yeah, I only come in when I need help ;-)
16:49:55 <dmwit> dcoutts_: If you don't specify which packages it depends on, how can cabal give meaningful errors on machines that don't have those packages?
16:49:57 <Botje> hey
16:50:00 <Binkley> shapr: with haskell, that is
16:50:04 <shapr> ha
16:50:08 <Botje> daan leijen (the parsec guy) now works for microsoft
16:50:16 <dcoutts_> Binkley: ie cabal build --hsc2hs-option=--no-compile
16:50:21 <Binkley> dcoutts: got it, thanks
16:50:45 <SamB> Botje: I thought we'd decided that xerox was the new parsec guy ;-P
16:50:51 <vincenz> Hey Binkley
16:50:52 <dmwit> dogbite_: I don't think there's much in the way of Haskell make-tools.  Most people use cabal, instead.
16:51:00 <Binkley> hi vincenz
16:51:18 <dogbite_> i'm fine using cabal
16:51:24 <dcoutts_> dmwit: when you're just hacking around you should be able to just build stuff, then it should generate a skeleton .cabal file with the right build-depends so you can distribute it
16:51:25 <dogbite_> i just need to learn it.  i'll google.
16:52:05 <dmwit> dcoutts_: Oh, okay.  Sure, that would be nice.
16:52:11 <SamB> dcoutts_: isn't that what we have gwern for?
16:52:58 <dcoutts_> SamB: heh
16:53:13 <monochrom> gwern is our build bot? :)
16:53:17 <dcoutts_> dmwit: and if you're missing a build-depends it should tell you what it needs and/or just use it and carry on
16:53:22 <dcoutts_> it means cabal would have to do module dep chasing itself
16:53:23 <shapr> cjb: How large is your screen?
16:53:42 <dcoutts_> to map imports back to packages that provide those modules
16:53:50 <SamB> dcoutts_: how can it do that in the presence of #ifdef ?
16:54:01 <gwern> ...
16:54:34 <monochrom> hehe
16:54:35 <dcoutts_> SamB: run cpp (or any other preprocessor) first
16:54:48 <SamB> dcoutts_: well, I meant wouldn't it depend on things?
16:54:59 <gwern> I *was* going to mention I finalized my Darcs cabalization and was sending off my patches tonight, but now I don't feel like it!
16:55:06 * gwern sniffs
16:55:09 <SamB> gwern: sorry
16:55:23 <dcoutts_> SamB: in general, dep chasing has to be interleaved with running pre-processors
16:55:23 <SamB> I didn't mean to offend you -- only to tease you
16:55:28 * monochrom gives gwern some sugar lambdas.
16:55:41 <gwern> sweet
16:56:11 <clanehin> I can't figure how to do simple outline fonts in gimp.  I can make it on realistically on fire, or out of granite, just not with a black outline.
16:56:39 <SamB> perhaps, in the presence of ifdefs, cabal should punt and give the longest and shortest possible dependancy lists?
16:56:39 <dcoutts_> SamB: of course, it's a big dependency graph and exploring it has to be interleaved with running actions
16:57:03 <SamB> along with a list of what had files ifdefs, perhaps
16:57:52 <SamB> gwern: do you feel like it yet?
16:57:53 <Botje> clanehin: convert the text layer to a selection, then stroke selection
16:58:14 <dcoutts_> SamB: of you can't discover deps without actually trying to build
16:58:14 <dcoutts_> of/oh
16:58:25 <dcoutts_> SamB: because of the interleaving thing
16:58:50 <dcoutts_> SamB: I don't think there's any point in trying to pretend otherwise
16:58:52 <gwern> SamB: I dunno
17:01:04 <SamB> oh, you had mentioned something about Cabal's JHC support...
17:02:21 <gwern> cabal must support JHC; doesn't it have a module for JHC?
17:02:37 <gwern> ./Distribution/Simple/JHC.hs
17:02:39 <dcoutts_> gwern: yes, but it's pretty hard to test
17:02:40 <clanehin> Botje: thanks
17:03:11 <dcoutts_> SamB, gwern: and I don't get many patches for the JHC support
17:03:12 <SamB> ... might actually be useful if John gets things working with the normal "base" package instead of our current lame one ;-)
17:03:18 <dcoutts_> SamB: yes!
17:03:24 <dcoutts_> send more patches :-)
17:04:08 <gwern> dcoutts_: well, what cabalized package *could* you compile with JHC? I had a pretty dismal experience when I tried
17:04:09 <dcoutts_> SamB: I'd be very happy to see cabal's jhc support tested and improved. I tried myself but got stuck trying to build filepath with jhc.
17:04:19 <SamB> see, at this point I'm not even going to bother trying to use cabal with JHC, because I just know some module is going to be missing
17:04:19 <dcoutts_> gwern: yeah, me too
17:04:48 <SamB> just like you two have apparantly found
17:04:55 <dcoutts_> SamB: that was my experience, not missing modules but differences with ghc wrt to -cpp
17:05:09 <gwern> heh. I can't even compile jhc anymore.  something got messed up - the sed arguments are reversed, so they all fail
17:05:18 <SamB> if the package would work with JHC, probably JHC's fake cabal support would too ;-)
17:05:27 <SamB> gwern: sed??
17:05:42 * dcoutts_ would also have Cabal do the cpping, not ghc/jhc -cpp
17:06:29 <gwern> SamB: yeah, the makefule very early on does some sed string replacements
17:06:35 <gwern> the arg order is wrong, so it breaks
17:06:43 <gwern> I sent a patch, but it never got applied
17:06:44 <SamB> hmm, maybe the fact that JHC currentlly calls out to cpp(1) instead of cpphs(1)
17:06:47 <gwern> (no idea why)
17:06:53 <SamB> gwern: which patch?
17:06:59 <SamB> I bet john forgot
17:07:13 <dcoutts_> SamB: ghc also uses cpp not cpphs
17:07:34 <SamB> dcoutts_: why?
17:07:35 <dcoutts_> SamB: I'd prefer to see cabal using cpphs directly and never use ghc/jhc -cpp
17:07:39 <gwern> SamB: it was a while ago
17:07:54 <dcoutts_> SamB: why does ghc use cpp not cpphs? license issues :-(
17:08:06 <SamB> who wrote cpphs?
17:08:10 <dcoutts_> SamB: they don't want to use gpl progs
17:08:19 <dcoutts_> even though cpp and gcc are also gpl
17:08:19 <SamB> dcoutts_: so... GCC?
17:08:24 <dcoutts_> well, exactly
17:08:40 <dcoutts_> SamB: cpphs is even available as lgpl
17:08:56 <SamB> dcoutts_: and that isn't good enough somehow?
17:08:58 <dcoutts_> as a library, the cpphs prog is gpl, but it's only a thin wrapper over the lib
17:09:05 <gwern> bah, just relicense cpphs
17:09:12 <dcoutts_> SamB: it's hard to get a straight answer
17:09:17 <SamB> when anyway it's not even important to use as a library?
17:09:31 <clanehin> gwern: I think cale's cat should say, don't use undecidable instances, but I'm not sure how to kitty pidgen it.
17:09:35 <SamB> ... since, um, cpp isn't a library at all?
17:09:35 <gwern> bloody hell, just rewrite it then! how hard could it be?
17:09:50 <SamB> gwern: this IS cpp we are talking about ...
17:10:00 <gwern> (it does string mangling, haskell is fine at that)
17:10:16 <SamB> and it's bloody difficult to convince someone to rewrite a perfectly good program because of supposed licensing issues
17:11:37 <Binkley> clanehin: something along the lines of "DO NOT WANT"
17:12:17 <gwern> SamB: a haskell cpp wouldn't need to be terribly complex, I don't think. I mean, do we even want trigraph replacement?
17:12:20 <SamB> can not has undecidable instances?
17:12:30 <gwern> or linesplicing?
17:12:42 <SamB> hmm. no, that doesn't say the right thing...
17:12:48 <gwern> heck, doesn't cpp's linesplicing phase cause actual problems with haskell?
17:12:57 <SamB> that sounds like "you mean I can't have undecidable instances?"
17:13:36 <SamB> "yucky undecidable instances"?
17:13:50 <gwern> SamB: undecidable instances - DO NOT WANT
17:14:05 <gwern> undecidable instances? UR DOING IT WRONG
17:14:32 <dogbite_> okay, some quick cabal help?
17:14:33 <dogbite_> HHData/HHVector.hs:6:7:
17:14:33 <dogbite_>     Could not find module `Data.Time.Clock':
17:14:33 <dogbite_>       it is a member of package time-1.1.1, which is hidden
17:15:40 <SamB> hmm, I need me a lolcats lexicon
17:15:51 <gwern> SamB: there is one, btw
17:16:05 <SamB> dogbite_: add to build-depends
17:16:09 <SamB> gwern: in print?
17:16:25 <gwern> it's pretty good
17:16:27 <gwern> dogbite_: build-depends: time?
17:16:35 <dogbite_> wait, my name is 'dogbite_'.  that's weird.
17:16:39 <dogbite_> i wonder when i gained an underscore
17:16:43 <gwern> SamB: er, no
17:16:44 <dogbite_> okay i will try
17:16:45 <gwern> too soon
17:16:50 <gwern> too difficult copyright issues
17:16:55 <SamB> dogbite_: when your ISP started to suck
17:17:05 <SamB> gwern: copyright?
17:17:13 <allbery_b> someone's already on with the other?  or you got dropped and rejoined before the irc server had noticed the old connection was gone
17:17:24 <SamB> gwern: oh, for the examples?
17:17:27 <gwern> a book w/o lolcat images would be worthless; a book w/ lolcat images would be a legal nightmare
17:17:28 <dmwit> dogbite_: Is the time package in your build-depends line?
17:17:45 <SamB> gwern: ah.
17:18:14 <dogbite_> i'm adding things to build-depends.  getting there!
17:18:22 <dogbite_> i don't like this underscore nonesense
17:18:34 <dmwit> Try /nick dogbite
17:18:40 <SamB> you'd need to get some organized chaos going in order to build up a stock of publishable images, eh?
17:19:05 <gwern> 'Yes, I'd like to use 50 images; no, I don't think fair use will protect us; and, uh, getting copyright clearance is utterly impossible..... hey, wait, where are you going, this book will really sell! Hey come back! (please?)'
17:19:23 <gwern> SamB: that's why wikpedia projects are so anal about licensing
17:19:33 <Binkley> gwern: Creative Commons is the answer to that
17:19:35 <gwern> it's a lot easier to get Free licenses up front than after the fact
17:19:39 <Binkley> there are lots of kitties out there
17:19:39 <SamB> gwern: clearly, this project would need to be equally anal
17:19:43 <Binkley> some of them are licensed for CC commercial use
17:19:49 <SamB> that's what I meant about this organized chaos
17:20:14 <gwern> Binkley: but not the canonical ones
17:20:20 <gwern> the historically important ones
17:20:27 <Binkley> gwern: no, but that's why this would be interesting
17:20:32 <Binkley> it would be a fresh, new look at the lolcat medium
17:20:36 <gwern> *maybe* you could get a few, but most of them are utterly impossible to track down
17:20:38 <dogbite> okay so the compile worked!  it didn't traverse the full source tree though
17:20:53 <gwern> dogbite: maybe it didn't need to
17:20:58 <dogbite> it went into my HHData directory but not
17:21:01 <dogbite> HHData/Time
17:21:13 <SamB> gwern: I'm seriously not waiting 1140 years to buy one!
17:21:17 <SamB> er.
17:21:18 <SamB> 140
17:21:43 <gwern> SamB: alas...
17:21:47 <dogbite> one thing that i had in my Makefile was a 'test' target which ran
17:21:50 <dogbite> quickcheck.hs
17:22:16 <gwern> SamB: look on the bright side, legally they're probably already 'published', so they aren't in the situation of unpublished materials which have even longer copyrights
17:23:31 <SamB> hmm, we should try to get our lambdacats appropriately CC'd or MIT'd
17:24:25 <gwern> SamB: that would be a good idea, yes
17:24:42 <dogbite> okay, regarding not traversing -- you were right
17:24:49 <dogbite> my main was not importing something.
17:25:38 <gwern> I suspected as much. you weren't building out of an sdist tarball after all
17:27:32 <Binkley> @quote
17:28:50 <mauke> @bot
17:34:10 <ripplepay> data Set a    = Tip
17:34:11 <ripplepay>               | Bin {-# UNPACK #-} !Size a !(Set a) !(Set a)
17:34:24 <ripplepay> what does {-# UNPACK -#} mean?
17:34:26 <dogbite> any best practices on running the quickcheck.hs script?
17:34:45 <dogbite> in my test target it gave that script every source file
17:36:33 <vincenz> ripplepay: I think that's a compiler pragma to inline those ifelds
17:36:35 <vincenz> ripplepay: nonetheless
17:36:44 <vincenz> {- -} is comments for what yu're concerned
17:36:57 <vincenz> it just so happens that {-# #-} are compiler pragmas
17:37:23 <SamB> which are, in fact, not comments
17:37:44 <cjb> can you prove that they aren't comments?  :)
17:37:48 <SamB> you can get syntax errors in them!
17:38:01 <vincenz> Experiments do no proof signify
17:38:15 <SamB> it's called proof by example
17:38:20 <vincenz> No it's not
17:38:27 <ripplepay> what are ifelds? should that have been ifields?
17:38:28 <vincenz> You can only disproof something by example.
17:38:29 <SamB> or perhaps counterexample
17:38:56 <ripplepay> ah, guessing you meant field
17:39:02 <SamB> I can disprove the proposed "{-# #-} are comments" by writing one with a syntax error
17:39:07 <vincenz> Oh right
17:39:28 * vincenz remembers what was on his todolist
17:39:29 <ripplepay> so every argument to the Bin constructor is a field
17:39:30 <SamB> > {-# RULES "hi" #-} ()
17:39:34 <vincenz> ripplepay: yes
17:39:35 <gwern> dogbite: if you're working in a darcs repo, why not set a post-commit hook to run the script? 'runhaskell quickcheck.hs `find . -name "*.hs"`'...
17:39:40 <vincenz> ripplepay: they're just strictified and inlined
17:40:07 <ripplepay> I understand strictified but not inlined
17:40:50 <SamB> is lambdabot missing?
17:41:00 <vincenz> Well now I'm not sure, since I'm not overly familiar with GHC-pragmas.  But I think this one places the Size field -directly- inside the Bin, instead of through a pointer
17:41:16 <gwern> MIA
17:41:53 <ripplepay> hm, I guess since I know little of compiler internals I might as well not worry too much
17:42:06 <vincenz> ripplepay: If you're just learning Haskell, ignore it
17:42:15 <vincenz> ripplepay: hence 'comments'
17:42:19 <ripplepay> :)
17:42:59 <SamB> hmm, it isn't working :-(
17:43:08 <allbery_b> @bot
17:43:34 <ripplepay> I noticed there's some repetition in Data.Set and Data.Map, since both use the AVL tree data structure and it got me wondering if there was some way to share the AVL parts of the code
17:43:54 <gwern> SamB: hey, where's the JHC mailing list?
17:44:27 <SamB> is it ... gmane.com.lang.haskell.jhc.devel ?
17:44:37 <Cale> Data.Set uses an AVL tree?
17:44:51 <ripplepay> http://darcs.haskell.org/ghc-6.6/packages/base/Data/Set.hs
17:44:53 <ripplepay> I think so
17:45:17 <gwern> SamB: that's a newgroup, looks like
17:45:17 <Cale> I know it's a binary balanced tree, but I didn't think it was an AVL tree.
17:45:37 <gwern> SamB: anyway, I sent my darcs cabalization patches if you still care
17:45:42 <ripplepay> what kind of tree do you think it was?
17:45:59 <ripplepay> (if it has a name...)
17:46:11 <SamB> http://news.gmane.org/gmane.comp.lang.haskell.jhc
17:46:28 <Cale> Just a plain binary search tree.
17:46:32 <vincenz> Cale: or red black :)
17:46:42 <Cale> All the interesting balancing is done in the operations.
17:46:59 <gwern> never mind, I've found the actual mailing list
17:47:00 <Cale> mm... it's counted at least of course
17:47:02 <vincenz> Cale: I wonder why those sets are inlined
17:47:03 <vincenz> erm
17:47:04 <SamB> Cale: when else can it be done?
17:47:06 <vincenz> strictified
17:47:13 <dogbite> okay i wasn't working on darcs but yeah i just wrote a shell script to do what you suggest
17:47:21 <dogbite> i just jumped to cabal.  one step at a time. :-)
17:47:25 <dogbite> still in subversion
17:47:34 <Cale> SamB: I mean, as opposed to being enforced by invariants on the structure itself.
17:47:55 <SamB> Cale: I think the invariants exist
17:48:18 <SamB> perhaps they are proved in the associated paper(s)?
17:48:27 * gwern pities the foo' who uses a CVCS instead of a DVCS!
17:48:41 <gwern> I wonder whether Mr. T still pities the fool?
17:48:58 <vincenz> gwern: T is dead, I thikn people mostly use scheme nowadays
17:49:02 <glguy> ?seen cale
17:49:13 <Cale> glguy: uh, I'm right here :)
17:49:25 <Cale> SamB: Of course they are :)
17:49:28 <gwern> vincenz: har har
17:49:38 <gwern> T still lives on in the optimization papers!
17:49:39 <SamB> Cale: but glguy just popped in
17:49:43 <gwern> @seen glguy
17:49:50 <SamB> and apparantly didn't realize that lambdabot is down
17:49:58 <sarehu> is it ethical to hire somebody with Haskell on their resume if it's a .NET shop?
17:50:17 <gwern> glguy: why does hpaste accept only such short pastes? why does it mess up UTF-8?
17:50:19 <SamB> glguy popped in immmediately before vincenz stated that T is dead and people use scheme now
17:50:37 <glguy> "T is dead"?
17:50:45 <vincenz> glguy: obscure language
17:50:49 <dogbite> okay, a bit ago i asked about this bit of code
17:50:49 <dogbite> combinePreds f ps = f . sequence ps
17:50:50 <dogbite> andPreds          = combinePreds and
17:51:06 <dogbite> this isn't necessary because i can
17:51:12 <glguy> gwern: the UTF-8 is mangled by hscolour, the pastes are truncated because it isn't intended as a file hosting site
17:51:13 <dogbite> replace it with what again?
17:51:14 <SamB> sarehu: you want to know if it violates the geneva convention?
17:51:16 <gwern> an obscure Lisp dialect best known for the Lisp compilation research done in't
17:51:23 <glguy> gwern: these things are fixed in the new, but not live hpaste
17:51:27 <sarehu> SamB: something like that :P
17:51:38 <glguy> so it's just a matter of effort of setting up the new site
17:51:44 <SamB> sarehu: well, I hear C# is getting better...
17:51:51 <gwern> glguy: too unstable to go live?
17:51:55 <SamB> what version of C# is in question?
17:52:01 <sarehu> 2.0
17:52:11 <TomMD> I've just been reading SPJ et al. new paper on GC - is this planned for GHC 6.10 and in GHC-head?  Or is it further down the road than that?
17:52:57 <sarehu> but with a lot of code written for 1.1 back before they upgraded :)
17:53:00 <thoughtpolice> TomMD: simonmar has been working on the parallel GC stuff for a while (he had a working version but it didn't have any performance enhancements)
17:53:07 <thoughtpolice> I speculate it'll make it into GHC 6.10, though
17:53:11 <glguy> gwern: I just haven't done it
17:53:14 <vincenz> TomMD: link?
17:53:30 <gwern> glguy: fie on you
17:53:35 <thoughtpolice> vincenz: http://research.microsoft.com/~simonpj/papers/parallel-gc/index.htm
17:53:47 <SamB> sarehu: hmm, not 3.0? that might be considered unnethical, however perhaps it is better to let the potential hiree make the decision?
17:54:02 <glguy> gwern: and neither has anyone else ;)
17:54:43 <sarehu> SamB: hmm yes but if he goes insane could I be held legally accountable?
17:54:49 <SamB> hmm, the vc# homepaage has an article on lazy evaluation on it...
17:54:58 <SamB> sarehu: don't think so, not if you warn him
17:55:10 <gwern> glguy: who else could?
17:55:40 <thoughtpolice> TomMD: iirc, the parallel-gc stuff was originally scheduled to make it into 6.8, but like I said the prototype the had offered no significant performance increases so I guess simon held it off. from some mailing lists posts though, yeah it's scheduled for 6.10
17:55:45 <TomMD> thoughtpolice: Good news!  It will be interesting to see how this goes.
17:56:12 <gwern> if there were no real performance increases why bother?
17:56:17 <thoughtpolice> so it's been a long time waiting but i'm looking forward to it. some of the standalone increases provided by the parallel-gc as shown in that paper look nice.
17:56:37 <TomMD> So many great Haskell developments seemingly around the corner.  So exciting!
17:57:04 <thoughtpolice> gwern: the new stuff they have scheduled for ghc 6.10 does offer increases, the stuff they had before (I believe an intern at MSR worked on the initial parallel-gc stuff) didn't offer any increase
17:57:10 <thoughtpolice> and simon has been working on it since then I speculate
17:57:42 <thoughtpolice> TomMD: quite so! I'm looking forward to comprehensive comprehensions, view patterns, the new GC, and especially the new native codegen backend!
17:57:45 <gwern> ah
17:58:01 <SamB> the original parallel GC work was fine, I think, but just not enough
17:58:18 <SamB> so simon had to make other changes before any benefit was seen
17:58:28 <gwern> TomMD: eh, it's always that way. a while back, it was a new Yi release, darcs 2.0, QC and haddock 2.0, new bytestrings, ghc 6.8.x, the xmonads etc. things march on
17:58:49 <thoughtpolice> SamB: yeah they wanted some kind of increase, from what I heard the main issue was parallelising minor collections
17:58:50 <SamB> gwern: eh, darcs 2.0 is pretty damn recent...
17:58:57 <thoughtpolice> good to see it's finally been done though
17:59:14 <thoughtpolice> ghc 6.10 is looking more promising all the time. and yes, people say that about every release - shouldn't stop anybody this time.
17:59:19 <gwern> SamB: well, there'd been mutterings about it for months
17:59:43 <gwern> thoughtpolice: I worry about breakage. 6.8.x was very painful and soured some peopple
17:59:46 <TomMD> gwern: Packages are great too, but I am particularly excited about: DPH, par GC, HARTS (still going?), type families, and what thoughtpolice mentioned.
18:00:17 <gwern> HARTS?
18:00:29 <thoughtpolice> gwern: yes, we'll just have to see how it plays out. that's a part of it, too
18:00:39 <TomMD> gwern: Looking for a link now, one sec.
18:00:41 <thoughtpolice> TomMD: yes, I forgot type families. the new typechecking stuff is complete, quite exciting. :)
18:01:09 <SamB> gwern: oh, there will be more breakage
18:01:11 <thoughtpolice> TomMD: will DPH be ready in 6.10?
18:01:15 <gwern> with any luck, darcs type witnesses will work again
18:01:32 <TomMD> thoughtpolice: I don't have any information on that, sorry.
18:01:33 <SamB> I hear that DPH is ready, but not very optimized
18:02:30 <thoughtpolice> it's fine
18:02:33 <thoughtpolice> anyway, i'm out
18:02:37 <TomMD> later
18:06:19 <TomMD> gwern: I can't find a link, but Mark Jones (of PDX) is working on the "High Assurance Run Time System (HARTS)".  The idea is a formally proven RTS (starting with the GC)
18:06:46 <dogbite> thanks everybody for all your help
18:06:51 <TomMD> There is the obvious issue that you can't have the formally proven RTS and the current one (with par GC) at the same time - so sad.
18:06:51 <dogbite> this forum is great
18:07:08 <gwern> hm. doesn't sound very useful; formally proven things have a tendency to quickly become unformal because of changing needs
18:07:35 <SamB> TomMD: why not?
18:07:53 <SamB> you just need to prove the parallel GC...
18:08:03 <TomMD> gwern: And at the other end of the scale is Peng Li's work on a new RTS - I really liked the look of that too!
18:08:29 <TomMD> SamB: Yes, but I don't believe that is what's being done - thus you would have two collectors to choose from, not one ring to rule them all...
18:08:37 <gwern> eh. if the RTS isn't smaller or faster, I have a hard time caring
18:08:52 <SamB> or more capable
18:09:02 <gwern> smaller RTSs would be good because people keep going 'Hello World is 550KB OMG WTFBBQ!!1'
18:09:25 <SamB> gwern: is that all C/Cmm code?
18:09:26 <TomMD> gwern: http://www.seas.upenn.edu/~lipeng/homepage/papers/lmpjt07hw.pdf
18:09:42 <gwern> SamB: dunno
18:09:48 <gwern> ask the GHC experts here
18:09:51 <TomMD> That is the 'new' RTS from Peng Li (Andrew Tolmach, Simon M.  few others).
18:10:44 <TomMD> SamB: I believe it is C/Cmm that takes up ~ half a meg for the RTS.  But take that with a grain or more of salt as I am not a GHC expert.
18:12:04 <clanehin> http://www.downstairspeople.org/img/lambdacat-undecidable-instances.jpg
18:13:09 <gwern> clanehin: I think it'd flow better if you scrap first line
18:13:15 <gwern> and then put one line on top, one on bottom
18:13:25 <gwern> brevity iz soul of lol, kthnxbai
18:13:41 <clanehin> I wanted to put a line on the bottom, but it covers up his face.
18:13:47 <gwern> also, you might want to darken that image a bit. it's awfully bright
18:13:56 <gwern> split it across the nose
18:14:01 <shapr> clanehin: Wow, that's great!
18:15:53 <gwern> clanehin: you could try another - '(.) is nao 'fmap'? I know nuffink! Nuffink!'
18:16:19 <clanehin> I've probably spent as much time on it as I'm going to :)
18:16:20 <gwern> or maybe 'I maded you a new lambdabot - but I eated it'
18:18:55 <clanehin> gwern: I like that last one, but I need a kitteh.
18:20:21 <gwern> clanehin: look for 'I maked you a cookiee - but I eated it'
18:21:58 <dolio> http://icanhascheezburger.com/2007/01/15/i-made-you-a-cookie/
18:23:00 <gwern> aw. I was close
18:23:15 <clanehin> I can has original?
18:23:26 <dolio> I don't know how you'd go about finding the picture without text, though.
18:23:49 <gwern> dolio: generally you search flickr
18:24:16 <gwern> ...or you click on the 'source' link :)
18:24:18 <gwern> http://flickr.com/photos/babykailan/116751981/in/set-968657/
18:24:19 <SamB> there is a link on that page to here
18:24:29 <SamB> er. to flickr
18:24:39 * gwern thinks the with-tail vesion is just as sad
18:24:58 <SamB> unfortunately, the flickr photo is "all rights reserved"...
18:25:17 <gwern> could just ask'em
18:25:26 <shapr> @yow !
18:25:28 <shapr> @users
18:25:30 <shapr> um
18:26:39 <TomMD> 406 users (max seen: 485)
18:26:40 <SamB> http://flickr.com/search/?q=cat&l=commderiv&ss=2&ct=5
18:27:03 <gwern> TomMD: droll. very droll.
18:27:41 <gwern> http://flickr.com/photos/golf_pictures/2187242989/ <-- 'i can has seqs?'
18:27:42 <gnuvince_> @src transpose
18:28:03 <TomMD> sorry, I'm not going to do that one.
18:28:17 <gnuvince_> lambdabot: src transpose
18:28:27 <gwern> see, I'm joking he needs some strictness to be less bloated, but it also looks like he's propositioning the viewer to enter into sexual relations
18:28:32 <gwern> seqs, sex, get it?
18:30:08 <SamB> Yow!  Legally-imposed CULTURE-reduction is CABBAGE-BRAINED!
18:30:18 <gwern> ...no? no one appreciated my funny?
18:30:26 <SamB> shapr: sorry for the delay
18:30:37 <SamB> I had to read the source to yow.el to figure out how to do that :-(O
18:31:08 * gwern wonders why M-x yow keeps returning the same quote
18:31:27 <SamB> good question!
18:31:55 <vincenz> gwern: hven't you heard? haskell is pure
18:32:26 <Lycurgus> is it supposed to be connecte to a qotd server?
18:32:29 <gnuvince_> Emacs Lisp is not
18:33:36 <dolio> Yow! Something about HARD ROLLS and COLE SLAW!
18:33:36 <Lycurgus> puro vita
18:34:05 <SamB> in my case, it is because the yow.lines file has only one line...
18:34:49 <bos> @seen dons
18:35:13 <bos> aie, no lambdabot!
18:36:04 <monochrom> She's dating.
18:36:11 <vincenz> monochrom: mbot?
18:36:21 * bugQ yelps something about MINASTRONE!
18:36:26 <monochrom> % 1+1
18:36:31 <monochrom> Seems so!
18:36:37 <vincenz> Are they even old enough?
18:36:53 <shapr> Yow!  Legally-imposed CULTURE-reduction is CABBAGE-BRAINED!
18:36:55 <vincenz> oh wait, 1 bot year is 3.14 human years
18:36:56 <dolio> She's 19.
18:37:03 <shapr> Whoa, I got the same yow.
18:37:24 <vincenz> dolio: how old is mbot?
18:37:41 <SamB> shapr: apparantly debian messed up the list :-(
18:37:47 <dolio> I don't know. Probably the same, unless @vixen is disabled there. :)
18:38:22 <vincenz> Sounds almost..
18:39:32 <dolio> <mbot> 19/f/California
18:39:55 <bugQ> NOW, I'm taking the NEXT FLIGHT to ACAPULCO so I can write POEMS about BROKEN GUITAR STRINGS and sensuous PRE-TEENS!!
18:40:10 <bugQ> oh, but they're already teens.
18:45:19 <jorick> store cid msgs = writeFile (logname cid) (unlines msgs)
18:45:19 <jorick> retrieve cid = readFile (logname cid) >>= return . lines
18:45:27 <Cale> Did lambdabot die *again*?
18:45:29 <Cale> @bot
18:45:39 <monochrom> No, she's gone dating with mbot.
18:45:48 <jorick> Hub.hs: test.log: openFile: resource busy (file is locked)
18:45:56 <Cale> there's no obvious failure here
18:45:58 <Cale> @quit
18:46:23 <jorick> i want to add logging to my server, this doesn't seem to work
18:46:23 <Cale> mm...
18:46:30 <jorick> what should i do ?
18:47:13 <Cale> mm.. the bot was trying to reconnect and failing because freenode wouldn't drop the ghost.
18:47:17 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
18:56:57 <Lycurgus> pray?
18:57:35 <dmwit> Exorcisms are expensive these days.
18:57:45 <dmwit> Praying is a cheap and often effective method.
18:58:42 <Lycurgus> I could do a solumn novena for a haskell port of log4j
18:58:51 <Lycurgus> *solemn
18:59:17 <cjs_> Really? I used to be a log4j fiend, but since I started doing TDD, I hardly miss it.
19:01:26 <Lycurgus> TDO = DOS Typed Data Objects?
19:02:37 <Lycurgus> (I actually heard of the log4net rip first)
19:03:26 <Lycurgus> or at least first used there
19:09:25 <Cale> Someone should write j pi/2 + log 4
19:10:27 <scook0> > log (0 :+ 4)
19:10:28 <lambdabot>  1.3862943611198906 :+ 1.5707963267948966
19:11:27 <dons> Foreign.C.Math.j{0,1} ?
19:12:05 <dons> http://hackage.haskell.org/packages/archive/cmath/0.3/doc/html/Foreign-C-Math-Double.html#v%3Aj0   fwiw
19:12:07 <lambdabot> http://tinyurl.com/6zj5gx
19:12:09 <Twey> @src (:+)
19:12:09 <lambdabot> Source not found. I am sorry.
19:12:15 <Twey> :-\
19:12:25 <kpreid> Twey: :+ is a constructor.
19:12:37 <Twey> .yyy.
19:12:39 <dons> ?src Complex
19:12:39 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
19:12:48 <Twey> A non-alphanumeric constructor?
19:12:49 <dons> ?src Rational
19:12:50 <lambdabot> type Rational = Ratio Integer
19:12:57 <kpreid> An infix constructor!
19:13:03 <Twey> Highly strange :-\
19:13:06 <dons> the most awesomely awesome of constructors
19:13:13 <kpreid> Remember, : is uppercase punctuation.
19:13:18 <Twey> Hmmm, I see
19:13:21 <allbery_b> yes, inficx constructolrs are legal, just have top start with a colon (the list constructor (:) being a degenerate case)
19:13:21 * dons would love to know if anyone's ever used the cmath package :)
19:13:25 <Twey> Pretty cool actually.
19:13:35 * Twey likes.
19:13:37 <SamB> dons: what's cmath?
19:13:47 <dons> lots of nice stuff
19:13:58 <SamB> (:) is not a degenerate case, actually
19:13:59 <dons> Twey: note there's infix class names too
19:14:09 <SamB> (:) is in fact a special name
19:14:17 <SamB> it doesn't need to be imported
19:14:20 <dons> http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#infix-tycons
19:14:21 <lambdabot> Title: 8.4. Extensions to data types and type synonyms, http://tinyurl.com/2cmgjm
19:14:25 <SamB> it can't be hid
19:14:36 <SamB> there can only be ONE (:)
19:14:43 <macondo> Does Haskell have something related to mathematic limits?
19:15:25 <SamB> rather like the two []s, the two ()s, and all those tuple type/data constructors...
19:15:43 <SamB> along with the (->) type constructor
19:15:44 <dons> macondo: could you elaborate?
19:16:04 <gnut> hi all
19:16:19 <SamB> allbery_b: got all that?
19:17:35 <gnut> will ghci look for modules in the current directory?
19:17:43 <dons> yeah
19:17:47 <dons> :l Foo
19:19:35 <macondo> dons: when you can't divide by a number say 0, you have to use limits. Does Haskell have a function to solve them?
19:20:48 <monochrom> limits are uncomputable in general, if I understand the question.
19:21:22 <gnut> does any language take limits? besides mathematical software such as mathematica or matlab or maple, etc...?
19:22:56 <monochrom> I believe no. Most language designers aren't interested in that kind of math.
19:23:30 <mmorrow> i think also there's a distinction between symbolically deriving one, and numerically computing one
19:23:31 <SamB> at least not in the strange way you'd have to be interested in it to make it part of the language
19:23:50 <macondo> and another math question: why doesn't Haskell have built-in complex numbers?
19:24:11 <SamB> macondo: when did they take them out?
19:24:13 <dolio> > e ^ (0 :+ pi)
19:24:14 <lambdabot>        add an instance declaration for (Integral (Complex t))
19:24:14 <lambdabot>     In the expr...
19:24:19 <dolio> > exp (0 :+ pi)
19:24:20 <lambdabot>  (-1.0) :+ 1.2246063538223773e-16
19:25:12 <dons> macondo: they're in the standard library
19:25:15 <monochrom> > sqrt((-1) :+ 0)
19:25:17 <lambdabot>  0.0 :+ 1.0
19:25:18 <dons> ?docs Data.Complex
19:25:19 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Complex.html
19:25:59 <SamB> really, the only built-in things in Haskell are those types I mentioned earlier
19:26:09 <SamB> (Well, I might have forgotten a few...)
19:26:40 <dons> well, some things are needed for desugaring, so are effectively built-in
19:26:46 <monochrom> Recall that Haskell does not need much builtin like other languages. It's abstract enough to relegate most things to libraries.
19:27:14 <dons> interesting, http://reddit.com/r/programming/info/6ghg7/comments/
19:27:18 <dons> STM, FRP
19:27:21 <monochrom> Example: while-loops need to be builtin elsewhere, can be user-defined in Haskell.
19:30:06 <SamB> well, okay, so a few of the list methods and the Monad and Num classes are effectively builtin...
19:30:15 <SamB> as is the Eq class, I guess...
19:30:41 <SamB> and the Read, Show, Enum, and Ord classes, for those derivings...
19:31:04 <dolio> Reliance on Enum is built in to [a..b] syntax.
19:31:11 <SamB> oh, true
19:31:16 <SamB> oh, forgot Ix
19:31:41 <monochrom> Haskell defies conventional wisdom.
19:31:46 <SamB> and I suppose IO is effectively built in...
19:32:18 <dolio> I don't know how built-in Monad is as far as the report goes.
19:32:31 <SamB> well, the do notation desugaring...
19:32:53 <dolio> Although apparently it's built-in enough to GHC that defining custom (>>=) and such isn't used.
19:34:07 <dolio> if then else is hard-wired to Bool.
19:35:48 <cjs_> In Data.Binary, how does one put a ByteString as just its bytes, without the "serialization" stuff ahead of it?
19:35:55 <dons> pattern matches fail with 'fail'
19:36:05 <dons> cjs_: put x :: ByteString ?
19:36:17 <dons> it just appends it the output stream uninterpreted
19:36:34 <bos> dons: did that patch to GhciSession work for you?
19:36:53 <dons> yeah. cheers, bos.
19:36:59 <cjs_> I am getting eight bytes prepended to it, which is the length of the ByteString.
19:37:09 <dons> cjs_: oh, right! yes.
19:38:17 <dons> cjs_: putByteString
19:38:21 <dons> instance Binary B.ByteString where
19:38:21 <dons>     put bs = do put (B.length bs)
19:38:22 <dons>                 putByteString bs
19:38:55 <SamB> hehe
19:38:59 * dons notes Data.Binary is a tiny tad faster with the new bytestring library
19:39:09 <dons> throughput was a few percent higher than before
19:39:13 <tromp> > 240/1876.0
19:39:14 <lambdabot>  0.1279317697228145
19:39:22 <cjs_> Ah, happy day. Thanks dons.
19:39:50 <cjs_> Duh, I was using getByteString in the get section, too! I ought to read my own code....
19:40:31 <allbery_b> SamB: believe it or not, I was simplifying.  I'm quite aware that there's special syntax involved at some level (...but consider some of it to be bugs, in particular that ghc doesn't let you provide your own (:) implementation)
19:40:31 <TomMD> > unwords . filter (/= "not") . words $ "I am not working!"
19:40:32 <lambdabot>  "I am working!"
19:40:49 <dons> cjs_: you might want to try deriving the code? there's a script that comes with the binary library
19:40:52 <SamB> allbery_b: I don't see how that can be a bug
19:41:18 <SamB> allbery_b: I think the Monad and Num issues are more serious
19:41:36 <allbery_b> same way the restrictions on replacing (>>=) are considered bugs by the ghc documentation (IIRC)
19:41:43 <cjs_> I'm actually not using a standard serialization format; it's a custom pseudo-binary format from a (non-Haskell) source.
19:41:43 <monochrom> : is a reserved word in the Haskell report. Conforming implementations are therefore required to reject user definitions.
19:41:49 <cjs_> Anyway, I've got that bit working now.
19:41:56 <allbery_b> mind you, it's not a good *idea*...
19:42:29 <SamB> monochrom: how many actually do, rather than just not working properly if you try?
19:42:54 <tromp> > 2104-1636
19:42:55 <lambdabot>  468
19:43:04 <monochrom> Not sure there is a difference.
19:43:06 <dolio> GHC rejects it, I think.
19:43:28 <tromp> > 2872 - 1636
19:43:29 <lambdabot>  1236
19:43:33 * SamB notes that in JHC, there is a declaration of (->)...
19:43:40 <SamB> @kind (->)
19:43:43 <lambdabot> ?? -> ? -> *
19:43:52 <dolio> foo.hs:1:16: Illegal binding of built-in syntax: :
19:43:59 <SamB> data (->) :: ?? -> ? -> *
19:44:12 <SamB> in Jhc.Basics
19:44:22 <SamB> at least, in my tree there is one
19:44:36 <SamB> I don't know how far behind John is at the moment...
19:45:08 <monochrom> It's trivial to reject user definitions of reserved words, isn't it?  Just outlaw them at suitable positions on the LHS.
19:46:07 <SamB> monochrom: well, what about the definitions in GHC.*/Hugs*/Jhc.* modules?
19:47:01 <SamB> I suppose you could only allow them with -fno-implicit-prelude or equivalent...
19:47:33 <monochrom> GHC.* modules are compiled under a non-conformance extension, obviously.
19:47:47 <monochrom> You may as well raise hell for Int#
19:47:51 <allbery_b> ghc allows some "built-in" syntax to be overridden that way.  see the bugs section
19:48:17 <allbery_b> where it discusses the things that someone thinks *should* be overrideable that way but currently aren't
19:48:26 <monochrom> The important point is if you switch off non-conformance extensions you should be unable to define :
19:50:11 <monochrom> A self-bootstrapping compiler must feature non-conformant extensions. It's an easy proof by mentioning IO.
19:50:22 <dolio> GHC.List doesn't appear to define (:).
19:50:45 <SamB> I believe GHC.Base, however, does
19:51:03 <SamB> @src []
19:51:03 <lambdabot> data [] a = [] | a : [a]
19:51:20 <SamB> hmm. perhaps not quite like that though
19:51:24 <dolio> Ah, there it is.
19:51:39 <dolio> No, that's a quote.
19:52:09 <allbery_b> IIRC there's something about how "it is defined as if it were (that declaration) but in fact it is invalid syntax"
19:53:28 <SamB> actually -- that is exactly the definition that appears in GHC.Base
19:53:39 <SamB> except in GHC.Base there's a comment afterwards
19:54:20 <SamB> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html#[]
19:54:21 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html#[]
19:55:33 <bos> @seen lambdabot
19:55:33 <lambdabot> Yes, I'm here. I'm in #haskell-hac4, #gentoo-uy, #friendly-coders, #dreamlinux-es, #thunks, #haskell-hac07, #haskell_ru, #haskell.dut, #haskell.de, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr,
19:55:33 <lambdabot>  #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell-books, #rosettacode, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #jtiger, #haskell-
19:55:33 <lambdabot> soc, #haskell-overflow, #haskell-blah, #scala, #darcs, #jhc, #ghc and #haskell
19:55:36 <dolio> Color me surprised.
19:55:37 <bos> eek
19:55:54 <SamB> dolio: surprised that GHC uses that definition?
19:55:57 <monochrom> #thunks ??!!
19:56:16 <SamB> dolio: well, it has to generate the code for that type SOMEHOW
19:56:23 <dolio> Yeah. I would have figured it'd just special case the definition.
19:56:31 <SamB> that would be too much work
19:56:34 <dolio> Instead of special casing a syntax exception so you can write that definition.
19:56:53 <SamB> it's far simpler to special-case the syntax than to special-case the definition
19:56:55 <SamB> trust me!
19:57:04 <dolio> Very well. :)
19:57:47 <cjs_> Hm. So I'm at the point where I can use Data.binary to read an item out of a file, by making a lazy ByteString from the file. But I can't seem to figure out how I read a list of these items from the file, until the list ends.
19:57:54 <cjs_> http://hpaste.org/7087
19:58:48 <bd_> I think you can just encode resps directly
19:58:55 <bd_> not sure though
19:59:23 <cjs_> Err...decode, you mean. (It's readTestData in the paste that should be printing until it's eaten all of the input.)
19:59:41 <cjs_> Right now it prints just the first RawResponse that it decodes.
20:00:05 <bd_> :t Data.Binary.encode
20:00:08 <lambdabot> forall a. (Data.Binary.Binary a) => a -> BSLC.ByteString
20:00:19 <cjs_> So I'm really supposed to be using this guy, right? "newtype Get a = Get { unGet :: S -> (a, S) }"
20:00:26 <SamB> dolio: anyway, GHC uses that strategy with just about every wired-in algebraic datatype it uses, regardless of special syntax...
20:00:28 <bd_> cjs_: I think there's an instance for Binary a => Binary [a], so just try encoding the list directly
20:01:21 <allbery_b> huh.  I see 6.8 removed many of the restrictions on rebindable syntax that used to exist (implicit fromIntegral and do's use of (>>=) being two that I recall)
20:01:24 <SamB> dolio: it might or might not have information about the constructors wired in to the compiler, but even if it does, it uses a data declaration to generate the corresponding code
20:01:28 <cjs_> That gets me: [RawResponse "*** Exception: too few bytes. Failed reading at byte position 26735
20:01:43 <dolio> SamB: Tuples being the exception?
20:01:49 <cjs_> Which is particularly odd, given that the file is only 46 bytes long (with theree responses in it).
20:01:53 <SamB> dolio: what makes you say that?
20:02:08 <SamB> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-Tuple.html
20:02:10 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/4aj6oy
20:02:20 <cjs_> bd_: It was "let s = decode r :: [RawResponse]" that you meant, right?
20:02:30 <halberd> mathematicians prefer concise symbols
20:02:40 <halberd> conventional programming languages emphasize descriptive names
20:02:41 <dolio> Oh, wow.
20:02:55 <dolio> SamB: I didn't see a GHC.Tuple, is why.
20:03:08 <SamB> dolio: but notice how it doesn't export them except if the compiler is NHC
20:03:13 <halberd> maybe there's something wrong with conventional programming languages because they make you use so many descriptive names
20:03:13 <bd_> cjs_: yes, essentially, but also encode (s :: [RawResponse]) essentially
20:03:24 <bd_> (the :: bit isn't needed, just for showing what I mean)
20:04:16 <cjs_> Oh, I know what happeed, bd_. What I get is not encoded with the regular list encoding, but is just a stream of responses. My input does not come from a Haskell encoding; it comes from a network server.
20:04:23 <dolio> SamB: Yeah. It makes tuple constructors on the fly, no?
20:04:24 <bd_> ahh
20:04:31 <halberd> I wonder how it would affect programming style if at the start of a section of code you had to declare all your variables to be one letter, only allowed to use 2 letters if you run out of 1 letter names
20:04:46 <bd_> in that case, I'm not sure, I haven't used Data.Binary that deeply :)
20:04:53 <dolio> I have no trouble getting GHC to do 153-tuples.
20:04:54 <halberd> it would encourage a more points free programming style and make you only use variables for things that are really meaningful
20:05:02 <SamB> dolio: eh?
20:05:17 <halberd> in addition to making code more concise
20:05:22 <SamB> dolio: so you are saying it doesn't actually *use* these definitions?
20:05:44 <SamB> I'm sure it uses the "deriving" stuff, at least...
20:06:09 <halberd> in math when you use a symbol you explain exactly what it means, then don't use a descriptive name because you expect the reader to remember what it means
20:06:15 <SamB> because according to my calculations, that last one there is the 61-tuple constructor...
20:06:18 <SamB> before the comment..
20:06:21 <dolio> Yeah. Eq and Ord are only derived up to the report requirement, I assume.
20:06:26 <allbery_b> halberd:  I seem to reczll some very early microcomputer BASIC implementations that did something like that.  (I don't mean MS-BASIC only treating the first 2 letters as significant)
20:06:47 <halberd> there might be an advantage to that same technique in programming, verbosely explaining what a variable means but only using a short non-descriptive name for it afterwards
20:06:51 <allbery_b> recall, even
20:06:53 <dolio> SamB: Yeah, but go into GHCi and type in ':t (,,,, ... more than the biggest in Data.Tuple ... ,)
20:07:08 <cjs_> bd_: Do you know this monad stuff well enough to help me figure out how to do this? I've got the feeling that this is really normal, everyday Haskell stuff, just that I'm not good enough at that yet.
20:07:18 <dolio> It'll give you a type for tuples well bigger than the ones in that file.
20:08:08 <halberd> i'm learning J
20:09:08 <_dml> can anyone explain to me why instance declarations must have distinct type variables?  it's a frustrating limitation
20:09:33 <bd_> cjs_: I know about monads, but not about Data.Binary :)
20:09:59 <cjs_> It doesn't look too tough, reading the soruce.
20:10:55 <SamB> http://hpaste.org/7088
20:11:10 <SamB> dolio: doesn't seem to work...
20:11:26 <dolio> SamB: Yeah, apparently you can't use constructors that big.
20:11:37 <SamB> not "that big", really
20:11:43 <cjs_> bd_: decode is just "runGet get".
20:12:01 <SamB> just that those symbols are only defined by the data declarations...
20:12:27 <SamB> and since there isn't one for base_DataziTuple_Z149T...
20:13:48 <halberd> is J really as incredibly concise as it is for the examples people give?
20:13:55 <SamB> btw, this seems to indicate that in reporting which module defined a symbol, :i apparantly just grabs the mdule from the qname...
20:13:56 <bd_> cjs_: however runGet doesn't give you the remaining bits
20:14:17 <cjs_> No. But runGetState does: "runGetState :: Get a -> L.ByteString -> Int64 -> (a, L.ByteString, Int64)"
20:14:21 <SamB> halberd: apparantly it can be
20:14:33 <SamB> but it's not terribly easy to read
20:14:35 <cjs_> So maybe it's that thing that I want to work in there somehow.
20:14:39 <SamB> or write
20:14:48 <SamB> and it isn't even statically typed
20:14:48 <halberd> it's not that hrd
20:15:25 <dolio> SamB: If you use prefix syntax, it doesn't seem to complain.
20:15:44 <SamB> dolio: I *did* use prefix syntax
20:15:47 <SamB> what did you do?
20:16:05 <halberd> you just have to learn what everything means then it's not hard
20:16:08 <halberd> it's just a new syntax
20:16:13 <bd_> cjs_: oh, well there you go :) Just loop applying that
20:16:34 <SamB> halberd: if it were "just a new syntax", it wouldn't be so incredibly concise would it?
20:16:49 <halberd> learning what everything means is just a new syntax
20:17:01 <dolio> SamB: :t let x = 1 :: Int in (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x
20:17:04 <cjs_> bd_: right, if I can figure out the details. (Like I said, I'm not very good at Haskell yet.)
20:17:18 <halberd> i mean it will still be slower to read, once you know it, because each line contains more content than one line of another language
20:17:23 <halberd> but that's expected and not a disadvantage
20:18:21 <cjs_> BTW, hpaste doesn't seem to be announcing here today.
20:18:22 <cjs_> http://hpaste.org/7087#a1
20:18:41 <bd_> cjs_: are you expecting your lazy bytestring to be connected to a socket? or to a file?
20:18:42 <halberd> the last example from the end of the first tutorial was %./ #&> C. p which determines the order of the group generated by the permutation p
20:18:53 <cjs_> bd_: a socket. I'm just using a file for testing.
20:18:54 <SamB> @tell glguy hpaste isn't announcing right now...
20:18:54 <lambdabot> Consider it noted.
20:19:00 <halberd> pretty amazing even though they use the special function C. to compute cycle orders
20:19:31 <bd_> cjs_: Note that you may have to jump through some hoops to receive messages smaller than the lazy bytestring's block size (ie, it might block until it fills a chunk)
20:19:44 <SamB> halberd: amazing in it's resemblance to line noise, or?
20:19:57 <cjs_> Oh, you mean block for more than I'm trying to read? Uh oh.
20:20:08 <halberd> not really samb i typed that expression from memory because i know what it means
20:20:18 <halberd> this is after using J for about half an hour
20:20:29 <SamB> or, if you read the symbols one at a time, to satchel's cursing?
20:21:11 <halberd> p is a permutation (a column vector permuting first 9 integers)
20:21:22 <halberd> C. computes the cycle orders of p
20:21:27 <bd_> cjs_: http://hpaste.org/7087#a2
20:21:39 <halberd> actually no, C. computes the cycles of p
20:21:56 <halberd> > unboxes a cycle and # counts the number of elements in the cycle
20:21:57 <lambdabot>  Parse error at "of" (column 41)
20:21:58 <bd_> cjs_: and yeah, it's fixable, but you'll have to dive into the guts of the lazy bytestring. That is, you'll have to implement the lazy read function yourself
20:22:08 <halberd> and you hook them together with &, function composition
20:22:14 <halberd> so #&> counts the lengths of the cycles
20:22:24 <halberd> and %./ computes the LCM of the cycle lengths
20:22:27 <SamB> halberd: lambdabot doesn't seem to be following
20:22:37 <bd_> wait
20:22:41 <halberd> lol
20:22:43 <bd_> cjs_: nevermind, it actually handles t properly
20:22:43 <halberd> ah sorry
20:23:01 <bd_> cjs_: http://haskell.org/ghc/docs/latest/html/libraries/bytestring/src/Data-ByteString-Lazy.html#hGetContentsN <-- the bytestring folk think of everything :)
20:23:02 <lambdabot> http://tinyurl.com/3o4ods
20:23:05 <halberd> it's straightforward once you know the syntax
20:23:26 <cjs_> bd_: Phew!
20:23:33 <SamB> bd_: eventually, yes ;-)
20:23:56 <halberd> like regular expressions
20:24:02 <bd_> Unfortunately it seems they didn't think of Bytestring.Lazy.lines :)
20:24:39 <halberd> J is similar in conciseness and style to regular expressions, used for matrix computation
20:26:49 <dons> bd_: ByteString.Lazy.Char8.lines
20:26:56 <bd_> doh
20:27:00 <dons> (assumes latin1 encoding, so in Char8 :)
20:27:12 <SamB> dons: how does that assume latin1?
20:27:18 <SamB> that assumes only ASCII-compatible
20:27:26 <halberd> basically J derives its power from: 1. functions can often apply to data of any dimension (implicit multi-dimensional maps)
20:27:38 <halberd> 2. there is a large amount of concisely named primitives
20:27:40 <SamB> would work equally well on UTF-8, shift_JIS...
20:27:52 <dons> SamB: well, lines doesn't -- it only needs 0x10 to be a newline
20:27:58 <bd_> dons: you mean 0x0a :)
20:28:03 <dons> that's the one :)
20:28:08 <halberd> 3. the meaning of a function depends on the context in which it is used, whether it is used as a function of 1 argument or as an infix function, and on the type of its arguments (scalar/vector/matrix)
20:28:16 * bd_ was *this* close to making the same mistake
20:28:21 <halberd> context dependency is crucial
20:28:30 <SamB> dons: yes, my point ;-)
20:28:37 <cjs_> bs_: BTW, that "(resp, remain) <- parsTestData bs" actually needed to be "let (resp, remain) = parseTestData bs" for me.
20:28:40 <halberd> 4. "adverbs" (higher-order functions)
20:28:42 <SamB> halberd: and that is why it isn't statically typeable
20:28:45 <SamB> 3.
20:28:58 <SamB> well, a big part of it
20:29:02 <dons> pedantry is Sam's favourite game. :)
20:29:19 <SamB> dons: possibly
20:29:30 <halberd> I think you can have context sensitivity in conjunction with static typing
20:29:32 <SamB> I think I sometime annoy my professors with it ;-)
20:29:39 <halberd> polymorphism is a form of context sensitivity
20:30:02 <halberd> e.g. the function you use depends on whether it is being called on one argument or 2, and on the type of the arguments
20:30:04 <SamB> maybe some of the adverbs made it worse?
20:30:14 <halberd> and polymorphism can be present in a statically typed language
20:30:33 <SamB> said in #haskell, that's not quite a tautology...
20:30:38 <SamB> but comes rather close
20:30:53 <cjs_> bd_: Also, any idea what's up with the Int64 that runGetState reuturns as the third item in the tuple?
20:31:05 <halberd> J isn't statically typed but I think something like J probably could be statically typed
20:31:33 <bd_> cjs_: how many bytes it consumed, I think
20:31:36 <SamB> oh, maybe it's the way looping is handled in J?
20:31:51 <halberd> what about looping?
20:31:53 <SamB> I think there is some ultra-dynamic stuff going on or something...
20:32:06 <SamB> I forget...
20:32:12 <SamB> I really need to go to bed now :-(
20:32:19 <SamB> if not before
20:32:26 <halberd> any language can be statically typed to some extent
20:32:28 <SamB> before would be better
20:32:39 <halberd> in certain circumstances
20:32:42 <SamB> well, yes, but data Duck = ... isn't too useful ;-P
20:32:57 <halberd> a static type is simply a proved assertion about the program's behavior
20:33:00 <SamB> and now, to bed I go!
20:33:03 <halberd> and you can make such proofs in any language
20:33:21 <halberd> or, "about" any language
20:34:17 <cjs_> bd_: Yes, it's how much it just consumed. I wonder what folks use that for?
20:34:18 <halberd> for example if you have a dynamically typed variable that you can prove is only ever assigned integers over its scope, then you can drop the type tag on that variable and make it statically typed, for that particular case
20:34:37 <halberd> because you know it is always an integer
20:34:46 <halberd> so there is no need for dynamic type checks, once you've proved that
20:37:02 <bd_> cjs_: Beats me :)
20:40:56 <allbery_b> counted-size superstructures?
20:41:12 <allbery_b> e.g. (#records)(rec 1)(rec 2)...(rec n)
20:44:18 <allbery_b> as to J:  I looked into it, hm, early 80s?  don't remember any of it, but did retain enough basic concepts that helped me figure out functional and point-free programming when I started learning Haskell
20:44:44 <ddarius> J has some nice things for point-free programming
20:44:59 <allbery_b> been a long time but I can't recall when exactly I looked at it
20:45:42 <allbery_b> I did eventually conclude that the implicit variables were something of a cheat in terms of "pointfree"
20:48:18 <allbery_b> (the [ and ] verbs)
20:49:19 <ddarius> allbery_b: Don't those essentially work out to const and flip const ?
20:50:08 <allbery_b> hm, actually it wasn't so "eventually"; the introduction to J at a local computer user group introduced them as part of "point-free" programming, but in fact they acted as points)
20:50:40 <allbery_b> ddarius:  const effectively consumes an argument.  [ and ] effectively duplicate it.
20:51:28 <allbery_b> that is, if you want to pass the same argument to two functions in haskell you use something like join in (-> e).  in J you can use (say) ] multiple times
20:51:33 <shapr> argh
20:53:23 <roconnor> @wn cavat
20:53:25 <lambdabot> No match for "cavat".
20:53:33 <roconnor> @spell caviat
20:53:42 <allbery_b> caveat?
20:53:44 <ddarius> caveat?
20:53:44 <dolio> Caveat?
20:53:48 <allbery_b> heh
20:53:49 <roconnor> ah right
20:53:49 <glguy> caveat?
20:53:50 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
20:53:54 <roconnor> @wn caveat
20:53:54 <lambdabot> *** "caveat" wn "WordNet (r) 2.0"
20:53:54 <lambdabot> caveat
20:53:54 <lambdabot>      n 1: a warning against certain acts; "a caveat against unfair
20:53:54 <lambdabot>           practices" [syn: {caution}]
20:53:54 <lambdabot>      2: (law) a formal notice filed with a court or officer to
20:53:56 <lambdabot>         suspend a proceeding until filer is given a hearing; "a
20:53:58 <lambdabot>         caveat filed against the probate of a will"
20:54:10 <newsham> would adding a few more combinators make doing points-free a lot easier?
20:54:38 <glguy> depends on the combinators
20:55:04 <ddarius> And how much "a lot" is.
20:55:19 <newsham> "depends" -> "yes"?
20:56:08 <newsham> there is some set of combinators for which that statement would be true?
20:56:54 <dons> the Pointless library has a larger set of them
20:56:59 <dons> specifically for avoiding more points.
20:57:39 <newsham> is that in the ghc dist?
20:57:48 <EvilTerran> nyet
20:57:57 <newsham> where can I find?
20:58:07 <EvilTerran> hackage?
20:58:08 <dons> http://www.cse.unsw.edu.au/~dons/Pointless/Combinators.hs
20:58:17 <dons> not hackage. they're from Minho Uni.
20:58:34 <EvilTerran> ah
20:58:35 <dons> see the whole set, http://www.cse.unsw.edu.au/~dons/Pointless/
20:58:36 <lambdabot> Title: Index of /~dons/Pointless
20:59:08 <gwern> dons: what's the point of the whole set?
20:59:13 <newsham> ty
20:59:34 <EvilTerran> that seems... gratuitous
21:00:11 <dons> research into hylomorphisms?
21:00:46 <EvilTerran> i'd more go for something with (.:), swap, specialisations of Control.Arrow, ...
21:00:49 <sjanssen> gwern: there are not points, that is the point
21:00:49 <gwern> er... I guess I'll take it at your word that that's a useful agglomeration of code
21:00:52 <dons> http://wiki.di.uminho.pt/twiki/bin/view/Research/PURe/HaskellCommunitiesAndActivities
21:00:54 <lambdabot> http://tinyurl.com/44yauf
21:01:27 * gwern groans in sjanssen's direction
21:01:40 <dons> the least visible major european haskell research group.
21:02:07 <dons> though Ulisses Costa's on p.h.o these days
21:02:11 <EvilTerran> RecursionPatterns looks interesting
21:02:51 <gwern> hmm. didn't I uploade halex and haglr?
21:03:40 <zgold> if i have one thread saying text <- hGetLine handle and another thread which tries to hPutStr handle "blah" will the blah be sent ?
21:04:17 <dolio> category-extras has most of the stuff in RecursionPatterns, I think.
21:04:23 <dolio> And some that aren't in there.
21:04:25 <allbery_b> depends on what else is going on, but if nothing else interferes it should
21:04:35 * EvilTerran looks
21:04:59 <allbery_b> (assuming the handle is bidirectional, of course)
21:05:03 <EvilTerran> ah, yes, that one. that seems likely
21:05:06 <dons> that lib introduced the _L idiom for bottom, which i think is clever
21:05:21 <EvilTerran> zgold, allbery_b - might it depend on the buffering behaviour?
21:05:49 <allbery_b> right, hPutStr doesn;t send a newline automatically so even line buffering won't help
21:06:02 <EvilTerran> i mean, the blah will be sent, but it likely won't be printing until a \n gets sent
21:06:14 <allbery_b> but it just occurred to me that Haskell Handles don't support that kind of bidirectionality
21:06:41 <allbery_b> (barring the OS doing so, for example FreeBSD's bidirectional pipes)
21:06:46 <dons> ?let _L :: a ; _L = undefined
21:06:57 <lambdabot> Defined.
21:07:04 <zgold> allbery_b: so is there no way to handle this situation?
21:07:09 <allbery_b> wait, even then it wouldn't work
21:07:18 <allbery_b> zgold:  not if they are one and the same Handle, no
21:07:30 <zgold> Crud.
21:07:39 <allbery_b> but if they are (say) different Handles representing read and write ends of a Unix pipe it would
21:07:41 <zgold> Can I interupt the first read somehow?
21:07:44 <allbery_b> perhapsd you want MVars?
21:07:44 <EvilTerran> wait, *h*PutStr. nvm.
21:08:04 <zgold> (These are network sockets)
21:08:06 <newsham> > fix id == _L
21:08:16 <EvilTerran> the same end of the socket?
21:08:21 <lambdabot>  thread killed
21:08:39 <zgold> EvilTerran: the handle comes from 'accept'
21:08:48 <allbery_b> same socket handle would not work
21:09:03 <zgold> Can you get a writeable handle then with network socket on accept?
21:09:16 <zgold> aka how do you establish 2 way communication?
21:09:21 <EvilTerran> ... doesn't that give you a Socket, not a Handle?
21:09:36 <zgold> @type accept
21:09:38 <lambdabot> Not in scope: `accept'
21:09:46 <allbery_b> it is writeable.  just not in such a way that a single Handle is loopback, i.e. a write to a handle h is read back from exactly the same handle h
21:10:09 <EvilTerran> accept :: Socket -> IO (Socket, SockAddr) according to my docs
21:10:24 <zgold> Socket :: IO (Handle,HostName,PortNumber)
21:10:25 <allbery_b> the other end of the socket would be a different handle (and would involve the low level connect() call, not accept())
21:10:29 <zgold> Hm
21:10:39 <zgold> I need to get out the other end somehow
21:10:51 <zgold> accept :: Socket -> *
21:10:58 <allbery_b> perhaps you should explain what you are actually trying to do
21:11:07 <zgold> Simple network communication between 2 programs
21:11:14 <allbery_b> in high level terms
21:11:20 <allbery_b> two *programs* is fine.
21:11:26 <zgold> Yes, it is two programs
21:11:32 <zgold> one calls "connectTo" the other "accepts"
21:11:41 <zgold> both ends need to read and write from the other
21:11:51 <allbery_b> you said two threads, which implies the same program, and in that case the handle is shared between all threads of the same program
21:11:56 <allbery_b> in *different* programs, it should work
21:11:57 <zgold> Well, the server has 2 threads
21:12:03 <allbery_b> because they aren't shared
21:12:11 <zgold> the "accept"ing program forks a thread everytime it gets a new connection
21:12:28 <zgold> and if for example
21:12:42 <zgold> it gets something from a handle which it needs to then respond by writing something to another handle it has
21:12:48 <sjanssen> @src Handle
21:12:48 <lambdabot> Source not found. My brain just exploded
21:12:53 <zgold> it is then hPutStr while in another thread hGetstr
21:13:09 <sjanssen> zgold: I believe this is fine
21:13:38 <zgold> Well, the current response is that hGetStr says "end of line" and i dont think the data is being sent
21:14:08 <sjanssen> zgold: do you have code you can paste?
21:14:18 <zgold> Whoops
21:14:24 <zgold> We forgot a "\n" on the hPutStr
21:14:28 <zgold> haskell is perfect, as alwyas
21:14:46 <mofmog> oh lord, my evaluation/data type for cellular automata is too slow
21:15:20 <zgold> allbery_b: thanks very much for your help and patients :)
21:15:44 <allbery_b> no problem.  I thionk I'm still confused by the way you described what you were doing, but if it works, fine :)
21:16:02 <zgold> Its a game server and a client
21:16:10 <zgold> The server keeps a list of handles of the people its spoken to
21:16:17 <zgold> and the server sometimes marshalls data from one client to the other
21:16:54 <zgold> (A -> B) the server is listening on A and B, gets something from A which says "send this to B" it then sends to B, interrupting the previous read from B
21:25:42 <halberd> it's amazing that J apparently doesn't have a primitive for matrix multiplication
21:25:56 <halberd> you have to construct it out of other primitives
21:26:06 <halberd> i must be wrong about this
21:28:23 <glguy> the language FAQ says to use: +/ . *
21:28:30 <halberd> yes that's what i found too
21:28:51 <halberd> it makes no sense, how could you have an array programming language without fast matrix multiplication?
21:30:40 <allbery_b> hm, I'm not sure I'd call J an "array" language so much as a *vector* language
21:31:18 <allbery_b> arrays are sort of like vectors with shaping imposed on them
21:32:23 <allbery_b> and you're building matrix multiplication out of vector operations
21:32:39 <halberd> there are faster ways to multiply matrices
21:33:05 <halberd> they include matrix inversion operations and a weird one called "matrix division"
21:33:20 <halberd> which just multiplies by the inverse
21:33:35 * allbery_b remembers that one, come to think of it
21:38:18 <cjs_> zgold: I am doing this now, with one thread reading (and blocking until data arrives) from a socket, and a different thread writing stuff.
21:38:50 <cjs_> When I need to synchronize in some way, e.g., wait for an input message to be parsed before I continue sending, I use an MVar.
21:39:46 <cjs_> But I'm not sure what you mean by, "interrupting the previous read on b"; the two directions of a socket are independent.
21:40:22 <zgold> cjs_: dunno, but it works
21:41:37 <cjs_> I expect that there's no "interrupting" of any reads; the threads just run independently.
21:41:52 <dogbite> how do you load the IO module in ghci?
21:42:13 <cjs_> :m +IO
21:42:16 <dogbite> thanks
21:42:26 <zgold> cjs_: it causes an EOF to show up on the hGetLine
21:42:48 <cjs_> That would be the remote end closing the socket....
21:42:58 <zgold> Ah, yes it would.
21:43:16 <zgold> I'm just running test code
21:43:25 <zgold> making sure things go back and fourth... and the tests obviously exit when done
21:45:54 <cjs_> BTW, I went through all of this, and am now switching to using Data.Binary, and parsing a lazy ByteString (from hGetContents) rather than reading from a handle.
21:53:06 <halberd> J is an array programming language
21:53:35 <halberd> multi dimensional arrays always have to be represented as "vectors" since memory is 1-dimensional
21:54:13 <cjs_> Hm. So when I use hPut, but don't flush, and it's a small amount of data, the file ends up empty when I exit. Ought it not be flushed before being closed by the RTS?
21:56:08 <Heffalump> does the RTS close it?
21:56:24 <cjs_> Maybe not. That would produce results consistent with this.
21:56:32 <cjs_> But you'd think it would....
21:56:39 <bd_> cjs_: it'll only be closed if it's GC'd/finalized before the process exits, which I don't think is guarenteed
21:56:54 <bd_> actually, does even GCing a handle close it...?
21:57:06 <Heffalump> if it doesn't have a table of its own of them, it would have to do a full GC to find it
21:57:14 <Heffalump> bd_: I think so, yes.
21:57:27 <dons> cjs_: i think that's the expected behaviour. -- the RTS doesn't close open handles on exit, afik
21:57:33 <cjs_> bd_: Ah. It's not likely to be, since it's held in a closure.
21:57:33 <dons> try,
21:57:33 <dons> import System.IO
21:57:39 <dons> main = do h <- openFile "/tmp/y" WriteMode; hPutStr h "test"
21:58:08 <dibblego> is 0 positive?
21:58:38 <dons> > signum 0
21:58:39 <lambdabot>  0
21:58:43 <dons> > signum 1
21:58:44 <lambdabot>  1
21:58:46 <dons> > signum (-1)
21:58:47 <lambdabot>  -1
21:58:49 <bd_> ah yes, it does have a finalizer
21:58:56 <bd_> cf GHC.Handle.newFileHandle
21:59:01 <cjs_> dons: In that particular case, the data are written to the file.
21:59:40 <dons> cjs_: oh, interesting. not on my system when compiled
21:59:42 <dons> but in ghci, it does.
21:59:44 <cjs_> Hm. So basically, I'll just have to store a reference to that handle somewhere so that the main thread can close it before exiting.
22:00:06 <dons> is the resource scoped in some way, so you know when you can close it?
22:00:14 <cjs_> Oh, I used runhaskell. You're right; when compiled it doesn't.
22:01:36 <cjs_> Well, I know I *have* to close it on program exit. :-) Basically, it's a separate reader thread that just reads until the remote end is closed (which never happens) or I shutdown my side of the socket, and I've got a little logging routine like so:
22:02:08 <cjs_> http://hpaste.org/7089
22:02:49 <cjs_> Note that there's a lot of crap in there you can ignore, but you get the general idea: logResponse returns a ResponseProcessor that will log to the file, and it keeps the handle in a little closure that it generates.
22:03:14 <cjs_> So I guess what I really want is also a way to generate a shutdown routine.
22:03:26 <dons> could you wrap the main code with a bracket or `finally`
22:03:34 <dons> to do the hFlush;hClose at the end
22:04:05 <cjs_> And create the handle in a closure that both the ResponseProcessor and its shutdown routine see (i.e., in scope).
22:04:58 <cjs_> You mean the "main :: IO ()" main? It can't see that handle.
22:05:52 <cjs_> Maybe I'm going the wrong way with this method of program organization. Essentially, I have a lot of ResponseProcessors, and they really need only local data, and I guess a shutdown routine. I'd normally make these objects with an appropriate interface, were I in an OO language.
22:06:58 <cjs_> So this is heading a bit towards a LISPy "use closures to implement OO" approach. The next obvious step would be for a responseProcessor to be a compound object consisting of several functions: process, shutdown, etc.
22:07:17 <cjs_> But perhaps we usually do this in a different way in Haskell?
22:07:22 <dons> hmm. sounds a bit noun-ish, but you're in the land of verbs :)
22:07:49 <cjs_> Yes, it's something I'm struggling with, a little bit.
22:07:51 <dons> sometimes its useful to bundle up partially applied functions, but usually just the handle it self is enough.
22:08:08 <dons> for ensuring resources are finalised, finalisers or bracket/finally blocks are useful
22:09:32 <cjs_> I guess my question is, what's the best way to limit the scope of the various bits of "private" data my various ResponseProcessors use?
22:10:46 <Mathlosopher> Hi, I was wondering if anyone could offer me some advice on writing a MUD in haskell?
22:11:12 <zgold> import Network
22:11:21 <Mathlosopher> hi zach
22:11:26 <Mathlosopher> you're in my class
22:11:29 <Cale> Mathlosopher: Uh, sure, do you have a more specific question?
22:11:29 <Mathlosopher> this is Josh
22:11:32 <Mathlosopher> yeah
22:11:38 <Mathlosopher> I do
22:11:48 <Mathlosopher> I'm actually kind of befuddled on a few points
22:11:51 <Cale> okay
22:12:18 <lament> that's not a question :)
22:12:27 <Mathlosopher> I guess the whole point of the MUD is that you have some sort of world state independent of users and then they change it.  But what should I be using for this, STM?  and if so, how would I go about it?
22:12:31 <dons> cjs_: lexically, if at all possible, though if you can't be sure when a finaliser needs to run ,you can use the GC (by wrapping the object in a ForeignPtr)
22:13:14 <Cale> Mathlosopher: You might use some STM to help manipulate things which are shared between each of the user threads in a safe way.
22:13:20 <zgold> Mathlosopher: can maintain it however you see fit.  Could use a monad I guess, but some sort of IORef would likely be good
22:13:36 <gwern> Mathlosopher: are you the fellow who a few weeks previous was talking about his MUD in haskell?
22:13:45 <Mathlosopher> no
22:13:52 <Mathlosopher> I heard someone had done it, actually
22:13:56 <Mathlosopher> read it on a message board.
22:14:02 <Cale> If you're using lots of threads, then MVars or transactional memory would be better than IORefs
22:14:03 <Mathlosopher> but this was after I had thought of doing it for a project
22:14:08 <gwern> Mathlosopher: oh. well, uh, there's another fellow who wrote a MUD in haskell
22:14:12 <gwern> maybe look him up
22:14:22 <Mathlosopher> that'd be great.  do you have any contact info?
22:15:06 <gwern> well, slocate informs me I have some darcs repo called 'mud'
22:15:07 <gwern> maybe that's it
22:15:16 <cjs_> dons: By lexically, you mean the way I'm already doing it with that closure?
22:15:30 <Mathlosopher> interesting
22:15:39 <gwern> Mathlosopher: http://cdsmith.twu.net/demos/mud <-- darcs repo
22:15:43 <Cale> Chris Smith has a link to what is apparently the beginnings of a MUD in Haskell using STM, but the link is broken.
22:16:04 <Mathlosopher> I get a forbidden error
22:16:22 <gwern> Cale: really? I just darcs pulled, didn't see any error
22:16:49 <ohub> yep, forbidden
22:17:17 <lament> I would start with trying to design the data structure for the entire game world
22:17:35 <lament> (no programming involved)
22:17:42 <Mathlosopher> I'm thinking of just making it a bunch of independent rooms
22:17:48 <gwern> hm, I just did a darcs get and it seemed to work
22:17:55 <gwern> although that might be because of the darcs global cache
22:17:57 <Mathlosopher> and you have a table of which are connected by unique room IDs
22:18:57 <lament> i would probably do it as a general "object system" like smalltalk
22:19:05 <gwern> ah well, if the link doesn't work for you but does for me, nothing I can do about it
22:19:11 <lament> with things like rooms, players, objects all represented by the same Haskell type
22:19:11 <gwern> good night everyone
22:19:11 <Cale> oh, the darcs get works
22:19:19 <Cale> But the link doesn't.
22:19:33 <Mathlosopher> interesting idea
22:19:49 <Mathlosopher> how would I do that, though, since they're fundamentally different?
22:21:06 <lament> Mathlosopher: they're not. It's a hierarchy of objects that are all contained in other objects.
22:21:08 <Cale> Mathlosopher: Well, you could make them all String -> String maps, as an oversimplification.
22:21:21 <lament> Inventory objects are contained in players and NPCs, players are connected in rooms.
22:21:23 <Mathlosopher> true
22:21:35 <lament> If you ever played a MUSH, that's how they're all designed.
22:21:47 <lament> (or if you ever played an interactive fiction game)
22:22:17 <Mathlosopher> I have.  Hmm..
22:22:31 <Mathlosopher> so, then, players also contain things in them, yes?
22:22:49 <lament> sure
22:22:51 <Mathlosopher> so how would I implement something this general.  Since it's haskell, I assume it's possible, but I don't know how
22:23:49 <cjs_> Is "data Thing = Thing { name :: String, contents :: [Thing] }" too simple?
22:24:18 <lament> yes, a little
22:24:29 <lament> what MUSHes use is pretty much exactly XML:
22:24:38 <Cale> You'll probably want some numeric properties as well :)
22:24:43 <cjs_> Probably need some attachments to other things, as well....
22:24:43 <lament> an object has a type, a bunch of attributes which can be anything, and contents
22:24:54 <Cale> yeah, that's sensible
22:25:20 <lament> in fact MUSHes totally reinvent XML for no apparent reason :)
22:25:23 <Cale> The attributes you'll probably limit to some tagged union.
22:25:45 <lament> in some mushes, you're allowed to _program_ new types of objects in-game
22:26:01 <Mathlosopher> that's where the whole domain specific language thing comes in?
22:26:08 <lament> yes
22:26:21 <Mathlosopher> I'm probably not going to do much of that at this point, since it's only for a class project and I don't have a ton of time
22:26:22 <lament> in the mushes i've played, there's a horrible ugly scripting language built into the game
22:26:23 <cjs_> Actually, attributes are, what, just stuff you can do things to? Maybe you watch each Thing to have a list of functions which are the verbs you can do to it or with it or whatever.
22:26:23 <Cale> (that is, the types of the attributes, not the attributes themselves)
22:26:48 <Mathlosopher> I didn't think of that at all before.  brilliant!
22:26:52 <lament> cjs_: in the mushes i've played, attributes were like slots of an object
22:26:57 <Cale> cjs_: For a MUD? Maybe hitpoints, etc?
22:27:08 <lament> (in a dynamic setting like Javascript - you can create new ones on the fly)
22:27:24 <lament> for player objects, hitpoints is a relevant attribute
22:27:28 <Mathlosopher> the actual MUD bit is going to be simple.  it's just mainly going to be walking around and exploring with a tiny fight engine built in
22:27:38 <lament> for say weapon objects, there could be some "damage modifier" attribute.
22:28:01 <Mathlosopher> so an object just has a list of attributes that I can instantiate as whatever I want?
22:28:04 <lament> but you don't really need the dynamic approach
22:28:13 <lament> Mathlosopher: right, so it's basically reimplementing Javascript
22:28:23 <Mathlosopher> spiffy
22:28:42 <lament> but you could go the other way and have everything hard-coded
22:28:51 <Cale> I'd probably end up using lots of Data.Map values for that approach.
22:28:52 <lament> have a different data declaration for each type of object
22:29:02 <lament> have a set of type classes to manage it all
22:29:09 <Cale> (lists make bad dictionaries, generally)
22:29:14 <Mathlosopher> at this point, I have a bunch of data declarations
22:29:16 <lament> then the MUD would be nearly impossible to extend sanely :)
22:29:25 <Mathlosopher> yeah, I think I'm going to change it now
22:29:29 <Mathlosopher> this has given me a new view
22:29:50 <Mathlosopher> can you give me an example of how I would implement something like that?
22:29:57 <lament> note that i'm being sort of the devil's advocate here - recommeding a dynamic approach in Haskell :)
22:30:15 <Mathlosopher> true, but it's better from the game side.  at least that's how it sounds
22:30:37 <lament> so the object type has a bunch of attributes, and a list of contents
22:31:03 <lament> the world can then be represented by a root object
22:31:05 <Mathlosopher> and how do I get around having to hard code the attributes?
22:32:01 <lament> store them in a Data.Map
22:32:09 <Mathlosopher> hm, ok
22:32:12 <Trinithis> lament: how do you do 'oo polymorphism' in haskell?
22:32:36 <Cale> Mathlosopher: and perhaps have some union type for the various possible types which the attributes can have
22:32:41 <lament> yeah
22:32:44 <Mathlosopher> so, an object is basically a huge map
22:32:49 <Mathlosopher> of attributes?
22:32:54 <lament> not really huge
22:33:03 <Cale> Mathlosopher: together with a map of children
22:33:04 <lament> you don't actually need many attributes for a simple mud
22:33:09 <Mathlosopher> yeah
22:33:17 <Mathlosopher> well, since things are contained inside of each other
22:33:24 <lament> not sure if the children should be in a map
22:33:30 <Mathlosopher> if I modify a child, wouldn't haskell then remave everything from the top up?
22:33:36 <Mathlosopher> top down, sorry
22:33:40 <Mathlosopher> and that seems rather inefficient
22:33:50 <Mathlosopher> unless I use some sort of dynamic memory here
22:33:56 <Mathlosopher> IORefs or STM or something
22:33:58 <Cale> Mathlosopher: Don't worry too much about it :)
22:34:09 <Cale> Mathlosopher: It'll involve copying a few pointers here and there.
22:34:32 <lament> you could have a table of unique IDs for each object
22:34:38 <Cale> If you change one element of a Data.Map, it only takes O(log n) time
22:34:41 <lament> and objects would reference other objects by those IDs
22:35:19 <Mathlosopher> hmm
22:35:22 <Cale> Data.Map is stored as a binary balanced tree, and when you do an update, only the path up to the root is "copied"
22:35:39 <Cale> The rest is just shared.
22:35:46 <Mathlosopher> efficient
22:35:47 <lament> oh, sweet, binary trees are faster than hashtables?
22:36:12 <Cale> They're comparable.
22:36:29 <lament> trees in general seem horribly underused
22:36:31 <Cale> You should certainly not use Data.HashTable though, since it's a horrible implementation.
22:36:43 <Trinithis> lament: from what i gather, hashs are just a tad faster, but trees have the advantage of being ordered
22:36:44 <Mathlosopher> what's wrong with it?
22:36:50 <lament> (other than simply using trees for straightforward representation of hierarchical structures)
22:36:57 <Cale> It's always slower than Data.Map, less scalable, and all the manipulation functions are in IO
22:37:06 <Mathlosopher> ah, that's not good
22:37:22 <Mathlosopher> a lot of the MUD will be in IO already.  I'd like to keep at least some of it more pure
22:37:34 <Cale> Nobody has much motivation to fix it because Data.Map exists, and it probably should just be removed.
22:37:44 <Mathlosopher> and avoid using monads in general as much as possible.  because my understanding of them is still somewhat imperfect
22:37:49 <lament> so i think i wouldn't actually storing objects as a tree
22:38:03 <Mathlosopher> just ID references to them?
22:38:07 <lament> yeah
22:38:28 <lament> so "Contents" is just another attribute, a list of IDs
22:38:53 <Mathlosopher> what I was thinking of doing, was giving every object an ID, and then when you want information about an object, another function will do something like take the ID and give you a description
22:39:09 <lament> sure. "Description" being an attribute
22:39:14 <Mathlosopher> yeah
22:39:25 <Mathlosopher> I guess that brings me to another concern
22:39:30 <Mathlosopher> I'll need a simple parse
22:39:30 <Mathlosopher> r
22:40:06 <Mathlosopher> would this be a place for an in game scripting language of sorts
22:40:19 <Mathlosopher> parser turns the text into commands that the internals understand in this language?
22:40:31 <Mathlosopher> rather than something dumber
22:40:57 <Cale> Well, Parsec is a rather handy way to construct parsers.
22:41:23 <halberd> the more J I learn, the more I like it
22:41:54 <halberd> I especially like the concept where you learn an expression to do something instead of memorize a function name to do it
22:42:38 <halberd> and that once learned, the expression is short enough to retype with no trouble, just as if it were an arbitrary name
22:42:42 <Mathlosopher> one thing I'm wondering about: if you want to do something to an object and there can be multiple ways of referring to it, what's a good way to take this into account?
22:43:06 <zgold> Isn't that exactly what MVars etc. are for?
22:43:22 <Mathlosopher> not quite sure what you mean
22:43:44 <Mathlosopher> in the parser, if I want to "look" at something, but I could call it more than one thing
22:44:04 <Mathlosopher> should I just include all possible ways of referring to something in attributes
22:44:20 <Mathlosopher> or, is there a more clever way
22:44:45 <Cale> Mathlosopher: mm... that's possible -- or maybe have some kind of dictionary of real names for things
22:44:59 <Cale> hmm
22:45:26 <Mathlosopher> this may be simple, but I'd like it to at least feel somewhat playable
22:45:44 <Trinithis> take a string to a type and see if that type is in the room
22:45:46 <lament> Many interactive fiction games implement this by storing an attribute - a list of synonyms
22:46:09 <Cale> lament seems to know how people solve these problems :)
22:46:10 <Trinithis> or rather a list of potential types and see if any of thoes are in the room
22:46:21 <Mathlosopher> you seem to know a lot about interactive fiction games.  have you made them before, lament?
22:46:35 <xpika> i went for a programming job interview the other day
22:46:38 <lament> Mathlosopher: sadly, no :)
22:46:51 <lament> but i'm interested in the whole thing
22:47:03 <Mathlosopher> the more I learn about this, the more interesting it gets
22:47:15 <lament> you might also talk to people from Twisted
22:47:22 <Mathlosopher> I kind of want to read about interactive fiction and MUD, MUSH, etc game design now
22:47:30 <Mathlosopher> Twister?
22:47:34 <Mathlosopher> *Twisted
22:47:36 <lament> it's a python web framework
22:47:40 <Mathlosopher> ah
22:47:42 <lament> they decided they wanted to write an online adventure game
22:47:57 <lament> shortly afterwards they decided they need gigantic infrastructure to really make it work
22:48:26 <Cale> A lot of muds get by with a really simple command system.
22:48:29 <lament> true
22:48:40 <lament> you can easily have everything hardcoded
22:48:45 <lament> without all this mess with attributes
22:49:00 <Mathlosopher> that would make the project easier, but I think it wouldn't be as fun
22:49:03 <Cale> Well, aside from that
22:49:08 <Mathlosopher> and I want this to be something I want to come back to after
22:49:16 <Cale> I just mean how it gets input from the user.
22:49:25 <lament> data MonsterType = Monster { name :: String, attack :: Int, damage :: Int, level :: Int, hitpoints :: Int } -- boriiiing
22:49:50 <Mathlosopher> exactly
22:49:52 <Cale> Typically commands are not much more complicated than  <verb> <noun>
22:50:10 <Mathlosopher> generally, yeah
22:50:46 <Mathlosopher> so it sounds like an object should have objects that are in it and commands you can do to it, as well as some other properties, like whether or not it can move, or something
22:51:00 <halberd> somebody needs to make an open source J
22:51:01 <Cale> and shorthands can be restricted to uniquifying prefixes
22:51:20 <Cale> yeah
22:51:36 <Cale> Whether it can be put in a container is perhaps a useful one :)
22:51:45 <Cale> Whether it can be picked up.
22:52:16 <lament> for rooms, a list of exits
22:52:22 <Cale> Depending on how fancy your battle system is, there might be lots of attributes related to that.
22:52:32 <Mathlosopher> so should I separate boolean properties like that from others?
22:52:40 <Mathlosopher> oh, better idea
22:52:46 <lament> you should think carefully about what the type of the attributes will be
22:52:56 <Mathlosopher> a property is general, and I just use the | when I define the data type
22:53:02 <Mathlosopher> or something like that
22:53:07 <lament> a tagged union of... stuff
22:53:08 <Cale> Yeah, you'll have something like
22:53:10 <Mathlosopher> I see
22:53:18 <Cale> data Value = I Integer | S String
22:53:24 <Cale> data Value = I Integer | S String | B Bool
22:53:32 <Cale> Maybe support some others if you want.
22:53:37 <Mathlosopher> yeah, this will make things much much cleaner
22:54:00 <lament> | ObjectID | List [Value] | Price Zorkmid
22:54:13 <Mathlosopher> haha, zork
22:54:15 <Mathlosopher> never played it
22:54:19 <Mathlosopher> but I was reading about it the other day
22:54:24 <lament> er, ObjectID ID
22:54:50 <shachaf> Zorkmids are used in more than Zork.
22:55:02 <Mathlosopher> so, I would put the general definitions in one module, then export that to player, room, etc, where I would have more specific functions and whatnot?
22:55:12 <dibblego> do most of QuickCheck's Arbitrary instances check boundary values?
22:55:19 <dons> yeah
22:55:39 <dons> the numeric types don't have special code for maxBound actually
22:55:50 <dibblego> which Gen combinator do they use to ensure a boundary code is not used more than once?
22:56:00 <dibblego> or is frequency used to just keep it to a minimum?
22:56:05 <dons> frequency , yeah.
22:56:10 <dibblego> ok thanks
23:01:27 <Mathlosopher> I think this is going to get pretty interesting
23:02:04 <Mathlosopher> I'd really like to see that mud skeleton mentioned earlier
23:02:15 <Mathlosopher> what do I need to do to get it when I get access forbidden?
23:03:37 <dons> shapr: this looks like you -- but funnier -- http://mugshotdujour.com/wp-content/uploads/2008/04/matthew-gibeault.jpg
23:03:42 <lambdabot> http://tinyurl.com/62x34h
23:04:04 <dons> compare and contrast, with the real shapr, http://www.scannedinavian.com/~shae/lift-concat.jpg
23:04:10 <dons> without moustache, sadly
23:04:20 <lament> masklinn: http://en.wikipedia.org/wiki/MUSH
23:04:22 <lament> err
23:04:25 <lament> i meant Mathlosopher
23:04:33 <masklinn> heh
23:04:40 <Mathlosopher> I meant the haskell mud skeleton mentioned much earlier
23:04:56 <lament> yes, but that's still good reading :)
23:05:04 <Mathlosopher> of course
23:05:09 <Mathlosopher> actually, I already have that up
23:05:16 <lament> oh :)
23:05:18 <Mathlosopher> I obsessivly wiki things
23:05:28 <Mathlosopher> it's the closest thing I have to a religion
23:05:39 <Mathlosopher> a bit of humor there
23:05:51 <lament> wikipedia is wonderful :)
23:06:52 <Mathlosopher> indeed.  kind of annoying how the media always lambasts it
23:07:19 <lament> it's envy
23:09:09 <Cale> I guess observing that wikipedia is awesome is too easy and doesn't make for enough controversy.
23:10:28 <Mathlosopher> haha
23:11:01 <Mathlosopher> I'm starting to get worried.  I have a little under 3 weeks to get this thing done
23:12:36 <Cale> Mathlosopher: How long have you been programming in Haskell?
23:13:20 <Mathlosopher> since january
23:13:22 <Mathlosopher> it's for a class
23:13:30 <Mathlosopher> though, it's something I want to continue with
23:16:40 <ketil> @seen dons
23:16:41 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc and #haskell. I last heard dons speak 12m 30s ago.
23:17:30 <ketil> dons: tried to look in the ByteString sources to see what changes caused the Map speedup, but perhaps it's easier to just ask?
23:18:03 <Mathlosopher> well, folks, thank you for your help
23:18:11 <ketil> @seen dcoutts_
23:18:11 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-soc, #ghc and #haskell. I don't know when dcoutts_ last spoke.
23:18:14 <Mathlosopher> I'm sure I'll be back needing more ofi t
23:18:39 <Cale> Mathlosopher: no problem, let us know if you have any questions :)
23:18:54 <Mathlosopher> much obliged.  are you guys usually here at this time?
23:19:41 <bos> ketil: the old Ord instance used memcmp all the time
23:20:10 <ketil> bos: and the new one?
23:20:12 <bos> ketil: the new one uses a haskell comparison function for small strings, and memcmp beyond some size limit
23:20:26 <ketil> which file contains the instance?
23:20:30 <bos> for sufficiently small strings, the cost of an FFI call dominates
23:21:15 <bos> you can probably find it as fast as i can :-)
23:22:15 <bos> in fact, since darcs.haskell.org is dead, i can't tell you where the code has changed.
23:22:19 <jsnx> is there a document explaining which packages should go in which categories?
23:22:20 <lambdabot> jsnx: You have 1 new message. '/msg lambdabot @messages' to read it.
23:22:48 <bos> jsnx: you mean on hackage? no. just try to be sensible.
23:22:57 <ketil> bos: found it, I think.
23:23:19 <jsnx> well, i mean, what should go under Data.* or Control.*
23:23:46 <gnut> is darcs the versioning system of choice here?
23:23:59 <Cale> gnut: Pretty much :)
23:24:06 <gnut> Cale: :)
23:24:20 <gnut> i'm no darcs expert, and i'm pushing a copy of my local repository onto my machine at work
23:24:25 <jsnx> bos: i am packaging some syntax sugar and i was originally going to put it under Control, but that seems wrong
23:24:37 <gnut> but it has conflicts since i edited it before going home from work on thursday
23:24:56 <dons> ketil: inlining.
23:25:00 <gnut> what's darcs methodology for handling that? does it show the conflicts?
23:25:28 <bos> jsnx: oh! you mean where in the package naming hierarchy stuff belongs. still, i don't think that matters.
23:25:46 <bos> the current hierarchy is fairly daft, so you can't make it worse.
23:26:11 <dons> bos, darcs.haskell.org doesn't lookk like is down?
23:26:34 <Cale> gnut: It'll generally tell you which files have conflicts, and it will edit them so that both versions are present between markers and you just fix them up and record a patch that resolves the conflicts.
23:26:40 <bos> it was just darcs being a slow arse as usual.
23:26:57 <ketil> In the ord instance at  http://code.haskell.org/~dons/tests/bytestring/Data.ByteString.hs.html , line 309-319....
23:26:58 <lambdabot> http://tinyurl.com/44da6r
23:27:02 <bos> dons: so the Ord speedup is just inlinePerformIO?
23:27:20 <ketil> The only magic I find is short-circuiting for empty strings.  that's it?
23:27:23 <dons> no, there was an explicit INLINE that was producing terrible code
23:27:52 <dons> i then removed some of the extra uneeded checks, as well, and confirmed the memcmp wasn't too expensive
23:27:53 <bos> oh. interesting.
23:28:09 <bos> well! so much for the folk wisdom.
23:28:22 <dons> i should investiate at some point why it was going so badly wrong
23:28:27 <sjanssen> dons: which function was being inlined?
23:28:27 <bos> that 6x speedup is teh win.
23:28:35 <dons> sjanssen: compareBytes
23:28:54 <ketil> 6x speedup sounds good.  For what size of strings is that?
23:29:11 <dons> ketil: word-sized (7-8 chars on average)
23:29:42 <ketil> (I have an application storing keys of 10-30 chars, I pack them in Int/Integers and Map those)
23:30:12 <ketil> (Perhaps I should try to use Bytestrings as keys directly?)
23:30:22 <dons> yes, it might be ok now.
23:30:36 <dons> we've had a few 'dictionary' like problems over the last 12 months, that are solved by this change
23:31:02 <ketil> My alphabet is quite limited [ACGT], so it's very packable.
23:31:17 <roconnor> [ICFP]
23:31:26 <ketil> Or I can wait for Adrian & al's trie - which I hope will be even faster :-)
23:31:30 <gnut> my code isn't that big... it's one file that's 13kb and another that's 1 kb, but when i try to darcs push to a remote repo, it'staking up a lot of cpu on the remote node... slow!
23:31:47 <gnut> there are conflicts between the two though. maybe it's marking? but then it fails at the end.
23:31:47 <sjanssen> dons: nice code coverage
23:31:57 <dons> sjanssen: :) long plane flights
23:31:57 <ketil> gnut: pull and resolve first?
23:32:07 <sjanssen> dons: did the original test suite cover all this, or did you add tests after checking out hpc output?
23:32:16 <dons> originally it was 43%
23:32:24 <gnut> ketil: i can't do a pull since the machine I'm on is behind a firewall :)... (at home)... so I push
23:32:28 <dons> mostly i had to add ones for IO, for Char8, and for rewrite rules
23:32:30 <gnut> but would pull make a difference?
23:32:42 <dons> there were some other odditiies (findSubstring), and new stuff not tested so well
23:32:55 <ketil> gnut: I mean pull from the target repo, and resolv conflicts locally, then push.  Don't know if it'll help though :-)
23:33:03 <gnut> oh
23:33:10 <gnut> ketil: okay. i'll try that.
23:36:28 <cjs_> What's the function to half-close (close for writing) a socket?
23:37:58 <bd_> cjs_: in C it's shutdown(), but hardly anyone uses that these days...
23:39:18 <cjs_> Anybody with request-half-close-response-close client-server model still is.
23:39:26 <bd_> I suppose.
23:41:36 <cjs_> Hm. Anyway, I guess I can live with a full shutdown for this purpose, except that then my thread reading from that socket dies with an exception, I think.
23:42:06 <cjs_> What's the idiom for doing something after an IO action, whether an error is thrown or not?
23:42:26 <sjanssen> @hoogle finally
23:42:26 <lambdabot> Control.Exception.finally :: IO a -> IO b -> IO a
23:44:40 <bd_> :t bracket
23:44:43 <lambdabot> Not in scope: `bracket'
23:45:04 <bd_> @hoogle bracket
23:45:05 <lambdabot> Control.Exception.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
23:45:05 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
23:45:05 <lambdabot> Control.Exception.bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
23:45:27 <olsner> hmm, "Perhaps you haven't installed the profiling libraries for package parsec-3.0.0?"
23:45:35 <olsner> how do I get them installed from cabal?
23:46:08 <dons> -p flag
23:46:16 <olsner> cabal install -p?
23:46:44 <olsner> ah, there I see it
23:47:05 <mauke> cjs_: Network.Socket.shutdown
23:48:59 <gnut> hrm... seems i might be running into exponential time darcs conflicts? since i'm on 1.0.9
23:49:19 <gnut> might need darcs 2.0, which i can't seem to get compiled for solaris x86...
23:49:58 <mauke> are you pulling multiple patches at once?
23:50:07 <gnut> mauke: yes
23:50:28 <mauke> the last time this happened to me I could avoid it by doing it in smaller batches
23:50:59 <gnut> what about if i copied the file over and recorded locally?
23:52:08 <mauke> no idea
23:52:38 <gnut> i'm trying it now
23:52:43 <gnut> it looks like it's still slow
23:54:30 <gnut> mauke: are you running darcs 2?
23:54:36 <mauke> no
23:56:33 <cjs_> Weird. The second computation I pass to finally is being run twice.
23:57:13 <cjs_> Yikes. Or now four times, in another situation.
23:57:20 <sjanssen> cjs_: that shouldn't happen
23:58:36 <sjanssen> cjs_: how are you using it?
