00:16:43 <solrize> http://erikdemaine.org/papers/BufferTrees_SICOMP/   monstrous coolness, we've got to implement this stuff :)
00:16:45 <lambdabot> Title: Lars Arge, Michael A. Bender, Erik D. Demaine, Bryan E. Holland-Minkley, and J.  ...
00:19:22 <solrize> http://erikdemaine.org/papers/BRICS2002/
00:19:22 <lambdabot> Title: Erik D. Demaine: Cache-Oblivious Algorithms and Data Structures
00:28:03 <dolio> @yow!
00:28:03 <lambdabot> Are you mentally here at Pizza Hut??
00:30:32 <Jedai> solrize: Is it adapted to the functional style ?
00:30:45 <solrize> if you use enough monads, sure :0
00:30:49 <solrize> :)
00:32:07 <hpaste>  dolio annotated "ST in Agda (first go)" with "Success?" at http://hpaste.org/6802#a5
00:32:34 <dolio> @seen quicksilver
00:32:34 <lambdabot> quicksilver is in #haskell-soc, #ghc and #haskell. I last heard quicksilver speak 14h 30m 35s ago.
00:33:24 <dolio> @quote JonHarrop
00:33:24 <lambdabot> JonHarrop says: Absolutely, but you don't want laziness everywhere all the time because it means you can't write fast code.
00:33:35 <solrize> that doesn't look too much weirder than olegized haskell :)
00:33:55 <dolio> Wow, my code is weirder than Oleg code?
00:34:41 * solrize hasn't seen any oleg agda code, but be very afraid
00:34:56 <solrize> what's :=:  ?
00:34:59 <dolio> Agda is too convenient for him, I imagine.
00:35:26 <dolio> It's type equality captured in a datatype.
00:35:42 <dolio> a :=: b means that a ~ b, or that a is b, if you will.
00:35:44 <Saizan> mmh i wonder how you're supposed to type all the unicode symbols you find in agda examples, SCIM in latex mode?
00:35:45 <solrize> hmm
00:36:07 <dottedmag_ws> Is hackage.h.o down?
00:36:40 <dolio> Saizan: That's essentially how I do it. Emacs has its own unicode input system, I guess, but it's similar.
00:37:12 <Saizan> dottedmag_ws: it seems so
00:37:31 <dolio> The howto on how to install the emacs mode tells you how to enable it. I'd really recommend using the emacs mode (even if you don't use emacs) since it's much more helpful than running on the command line.
00:38:31 <Saizan> yeah, i'm using it
00:38:33 <dolio> solrize: The last three annotations on that page are Haskell, by the way, not Agda.
00:38:44 <solrize> yeah, saw those
00:41:39 <jsnx> how does unsafePerformIO interact with do blocks?
00:42:25 <mauke> how does exp interact with ( )?
00:42:43 <jsnx> if i say `unsafePerformIO $ do { s <- peekCString ; return $ s !! 0 }` does it do what i expect?
00:42:50 <jsnx> mauke: ?
00:42:56 <jsnx> :t exp
00:42:58 <lambdabot> forall a. (Floating a) => a -> a
00:43:53 <mauke> I think that code is safe as long as the C string never changes
00:44:13 <jsnx> mauke: okay, great
00:45:21 <Twey> @src exp
00:45:21 <lambdabot> Source not found. Sorry.
00:45:28 <Twey> Exponent?
00:45:32 <TSC> > exp 1
00:45:34 <lambdabot>  2.718281828459045
00:45:36 <TSC> e^x
00:45:51 <TSC> i.e. exp x = e^x
00:46:33 <HunterXHunter> > exp 10
00:46:34 <lambdabot>  22026.465794806718
00:46:44 <HunterXHunter> > e^10
00:46:45 <lambdabot>  e * e * (e * e) * (e * e * (e * e)) * (e * e)
00:47:01 <dolio> Uh oh.
00:47:10 <jsnx> dolio: ?
00:47:12 <Twey> Eh
00:47:14 <TSC> > (exp 1) ^ 10
00:47:15 <lambdabot>  22026.465794806707
00:47:15 <Twey> Ah
00:47:25 <jsnx> :t e
00:47:26 <lambdabot> Expr
00:47:31 <Twey> > e
00:47:32 <lambdabot>  e
00:47:38 <Twey> e is e is e, huh.
00:47:44 <Twey> > pi
00:47:44 <mauke> > i
00:47:45 <lambdabot>  3.141592653589793
00:47:45 <lambdabot>  i
00:47:51 <jsnx> we've got some CAS magic in place it seems
00:47:55 <HunterXHunter> > pi ^10
00:47:56 <lambdabot>  93648.047476083
00:47:57 <dolio> *ST> :t replicateST 5 (newSTRef 0) ==> Failure
00:48:06 <Twey> let e = 5 in e
00:48:09 <Twey> > let e = 5 in e
00:48:10 <lambdabot>  5
00:48:23 <Twey> Can shadow it though eh.
00:48:29 <TSC> Of course
00:51:08 <Jedai> jsnx: It's the Expr type, pretty nifty to see the expanded version of a computation (there's a blog article on the subject somewhere)
00:51:34 <Jedai> > scanl (+ x) 0 [1..5]
00:51:34 <lambdabot>  Couldn't match expected type `b -> Expr'
00:51:48 <Jedai> > scanl (+) x [1..5]
00:51:49 <lambdabot>  [x,x + 1,x + 1 + 2,x + 1 + 2 + 3,x + 1 + 2 + 3 + 4,x + 1 + 2 + 3 + 4 + 5]
00:53:15 <TSC> > foldr (+) x [a,b,c,d,e]
00:53:15 <lambdabot>  a + (b + (c + (d + (e + x))))
00:53:16 <Jedai> > let fib = x : y : zipWith (+) fib (tail fib) in fib
00:53:17 <lambdabot>  [x,y,x + y,y + (x + y),x + y + (y + (x + y)),y + (x + y) + (x + y + (y + (x ...
00:53:35 <Twey> scanl (+) 0 [1 .. 5]
00:53:38 <Twey> > scanl (+) 0 [1 .. 5]
00:53:39 <lambdabot>  [0,1,3,6,10,15]
00:53:51 <Twey> Mmmmm
00:54:12 <matthew-_> > (scanl (+) 0 [1 .. 5]) :: Expr
00:54:12 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
00:54:16 <Jedai> Twey: The magic is that x is predeclared as Var "x"
00:54:16 <matthew-_> > (scanl (+) 0 [1 .. 5]) :: [Expr]
00:54:17 <lambdabot>  [0,0 + 1,0 + 1 + 2,0 + 1 + 2 + 3,0 + 1 + 2 + 3 + 4,0 + 1 + 2 + 3 + 4 + 5]
00:55:05 <Jedai> If you ask specifically for [Expr], the literal will be inferred as Expr so it works too
00:55:17 <Twey> Oh I see.
00:55:27 <Twey> Expr is the thunk type?
00:55:41 <opqdonut> Expr is a hack :>
00:55:58 <Jedai> Twey: It's just a hack, a normal sum type with some nifty instances
00:56:06 <Jedai> @where Expr
00:56:06 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
00:56:12 <opqdonut> > fun "x" $ var "x"
00:56:13 <lambdabot>  Add a type signature
00:56:17 <opqdonut> > fun "x" $ var "x" :: Expr
00:56:18 <lambdabot>  x x
00:56:46 <opqdonut> and then we just have predeclared x=var"x";y=var"y";f=var"f" and so on
00:57:29 <opqdonut> and some numeric etc instances
01:02:42 <hpaste>  dolio annotated "ST in Agda (first go)" with "Alas and alack" at http://hpaste.org/6802#a7
01:14:37 <matthew-_> does anyone know where and when the next "fun in the afternoon" is?
01:19:07 <quicksilver> matthew-_: AFAIK it has not been arranged. It ought to be in May.
01:19:07 <lambdabot> quicksilver: You have 1 new message. '/msg lambdabot @messages' to read it.
01:19:20 <quicksilver> @messages
01:19:20 <lambdabot> dolio said 14h 11m 10s ago: ST in Agda2. No unsafe coerce. http://hpaste.org/6802
01:20:52 <matthew-_> ok, so can someone explain why there's almost a month gap between the 48-hour author response and the actual notification for ICFP?
01:21:01 <matthew-_> what on earth goes on during that month?
01:21:35 <quicksilver> dolio: Yes, I would have thought any type-level-list version would need to be statically deducible.
01:21:39 <quicksilver> dolio: I'm not sure, though.
01:22:30 <scook0> matthew-_: bear in mind that the results are announced at ICFP (the conference)
01:23:07 <quicksilver> scook0: I think matthew-_ is talking about paper submissions, not the programming contest.
01:23:18 <scook0> heh, never mind then
01:23:41 <matthew-_> yeah, the paper submissions
01:24:25 <matthew-_> do they occassionally invite people to rewrite papers? like: "we think this work is good, but first learn english and rewrite and resubmit in the next month and we'll consider it"...?
01:25:14 <dolio> quicksilver: Yeah, I guess it's back to the drawing board. I'm pleased it's as close as it is, though.
01:35:06 <HunterXHunter> > sum [1..5] :: Expr
01:35:10 <lambdabot>  0 + 1 + 2 + 3 + 4 + 5
01:36:26 <HunterXHunter> sum $ map (*x) [1..5]
01:36:30 <HunterXHunter> > sum $ map (*x) [1..5]
01:36:31 <lambdabot>  0 + 1 * x + 2 * x + 3 * x + 4 * x + 5 * x
01:38:04 <HunterXHunter> > iterate (^2) x
01:38:05 <lambdabot>  [x,x * x,x * x * (x * x),x * x * (x * x) * (x * x * (x * x)),x * x * (x * x)...
01:38:17 <HunterXHunter> > iterate (+2) x
01:38:18 <lambdabot>  [x,x + 2,x + 2 + 2,x + 2 + 2 + 2,x + 2 + 2 + 2 + 2,x + 2 + 2 + 2 + 2 + 2,x +...
01:38:27 <vegai> huh, that's nifty
01:38:31 <HunterXHunter> > iterate (+x) x
01:38:32 <lambdabot>  [x,x + x,x + x + x,x + x + x + x,x + x + x + x + x,x + x + x + x + x + x,x +...
01:40:48 <HunterXHunter> > gcd 1 2 :: Expr
01:40:48 <lambdabot>  abs 1 `rem` abs 2
01:41:16 <HunterXHunter> > abs 1 `rem` abs 2 :: Expr
01:41:17 <lambdabot>  abs 1 `rem` abs 2
01:43:02 <HunterXHunter> > [1..5] :: Expr
01:43:03 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
01:43:21 <HunterXHunter> > [1..x]
01:43:22 <lambdabot>  Exception: not a number
01:43:56 <mauke> > [1..5] :: [Expr]
01:43:56 <lambdabot>  [1,2,3,4,5]
01:44:37 <HunterXHunter> how do I add Expr to GHCi ?
01:46:59 <scook0> @where expr
01:46:59 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
01:47:51 <scook0> HunterXHunter: ^^ that's the code behind Expr
01:48:10 <Saizan> dolio: a maybe silly question, but can you define something like zipWithN in Agda? or the lack of polymorphism prevents this?
01:49:06 <dolio> You mean, like, 'zipWithN 4 (\a b c d -> ...) ...'?
01:49:21 <Saizan> yeah
01:49:31 <dolio> I don't know. I haven't tried yet.
01:49:59 <Saizan> mmh, maybe with a modified function type that lets you count the arity..
01:50:15 * Saizan tries
01:53:20 <EvilTerran> given that even the most polymporphic return type ([a] in haskell) is disjoint from even the most polymorphic arrow type (a -> b), i'd expect it to work
01:53:35 <EvilTerran> if that makes sense
01:54:05 <EvilTerran> they wouldn't fall under "overlapping instances" :P
01:59:02 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6813
02:01:37 <EvilTerran> anonymous, i note that won't work unless the file ends in a newline character
02:02:29 <EvilTerran> (i think - provided manyTill fails if it doesn't find its second parameter)
02:04:36 <quicksilver> yes, I'm sure it does.
02:04:53 <quicksilver> still that's probably not a terrible thing.
02:05:01 <quicksilver> Files should contain final newlines, as god intended.
02:05:20 * Botje just got back from philip wadler's talk about positive and negative subtyping
02:05:28 <Botje> it was interesting :)
02:05:40 <quicksilver> did it involve T-shirts?
02:05:46 <Botje> yes
02:05:55 <Botje> well, one tshirt
02:05:56 <Botje> :p
02:06:23 <quicksilver> wadler talks generally involve multiple T-shirts.
02:06:28 <quicksilver> Must have been wadler lite.
02:06:44 <Botje> question from the audience: "the whole talk you've been saying it's always the red bit's fault. why is the lambda on your shirt red?"
02:07:18 <quicksilver> a fair question.
02:07:48 <EvilTerran> ah yes, lambdaman
02:08:20 <Botje> perhaps he lite'd himself because the audience was mostly people interested in aspects
02:08:51 <quicksilver> you mean "idiots" ?
02:08:53 <EvilTerran> that's make me want to "lite myself", at least. on fire, that is.,
02:08:54 <quicksilver> ;P
02:09:37 <EvilTerran> quicksilver, oy, i happen to know at least a couple of very smart people who're interested in aspects
02:09:47 <quicksilver> "My new programming language Guh Libble is really cool. You can program completely ignoring security concerns and just add a security aspect later."
02:09:49 <EvilTerran> ...probably not more than two, actually. maybe you have a point.
02:10:19 <quicksilver> EvilTerran: I don't mince words. Of course aspects are an interesting idea and smart people might explore them to see if there are useful ideas.
02:10:29 <EvilTerran> but then, they're both lecturers at Oxford, so count as three normal intelligent people each ;)
02:10:51 <quicksilver> but what I've read about aspects on the reliable intertubes makes me feel ill :)
02:10:58 <EvilTerran> (Oege de Moor is very into aspects at the moment. that and writing java in a lazy functional style)
02:11:14 <EvilTerran> (i hear he's always been a bit quirky)
02:11:27 <mauke> write once, run away
02:11:40 <EvilTerran> @remember mauke write once, run away
02:11:40 <lambdabot> Done.
02:11:52 <Botje> quicksilver: the whole separation of concerns bit is interesting, though
02:12:02 <quicksilver> Botje: yes, of course.
02:12:09 <quicksilver> separation of concerns is a sound idea ;)
02:12:13 <Botje> instead of putting everything you need taken care of in a big monad transformer stack, just let the compiler do it for you :p
02:12:28 <Botje> .oO(aspectHaskell)
02:12:33 <quicksilver> but you have to be realistic about which concerns you can separate, and which ones are fundamentally intermingled.
02:12:54 <quicksilver> Botje: you can sort of do that with the MonadFoo-style classes.
02:12:57 <mauke> PHP: separating logic from programming since 1994
02:13:02 <dmwit> Hi, Im wondering how i can create a boat in haskel and if someone can post me a example.
02:13:11 <mapreduce> Aspects is inspired by what you can do trivially within lisp.  The ironic thing is, someone then ported it from Java to lisp.
02:13:15 <quicksilver> foo :: (MonadFoo m, MonadBar m) => m ()
02:13:33 <mauke> yeah, as a library
02:13:37 <quicksilver> Botje: you have a bunch of functions which all have different sets of 'MonadFoo' style constraints.
02:14:02 <quicksilver> Botje: then ultimately you combine them together and the compiler 'works out' the set of constraints (or capabilities) the whole program needs.
02:14:32 <Botje> sounds interesting, do you have any reading material or googlable terms?
02:14:43 <quicksilver> no, I don't think so.
02:14:46 <quicksilver> Just folklore ;)
02:14:59 <quicksilver> doesn't have to be monads, either. It's not just a monad idea.
02:15:06 <quicksilver> using typeclasses to collect constraints is more general.
02:15:35 <quicksilver> given our monad-centric libraries though, it does tend to be.
02:16:01 <Botje> but how would you apply that to, say, restricting certain web pages to certain kinds of users?
02:16:04 <quicksilver> basically the typechecker uses the typeclasses to collect the effects or capabilities than the program needs.
02:16:18 <quicksilver> MonadAdminUser m => m ()
02:16:20 <quicksilver> I guess :)
02:16:38 <Botje> then the next question is, how do you load that data at runtime :)
02:16:45 <quicksilver> that's a bit trickier.
02:16:58 <quicksilver> at least hte basic type structure has to be there at compile time, yes.
02:17:03 <Botje> yeah
02:17:06 <quicksilver> matthew_-'s session types are not unrelated.
02:17:38 <mauke> @hoogle [a] -> ([a], a)
02:17:38 <lambdabot> No matches, try a more general search
02:17:48 <Botje> but i don't see how you could fix it without resorting to hacks like "if (isAdmin user) then cast user :: AdminUser else cast user :: NormalUser " or somesuch
02:18:44 <Saizan> or use dependent types! though i can't write a typelevel list in agda, and that scares me.
02:18:53 <yuriyp> @src readLn
02:18:56 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
02:19:29 <yuriyp> @src readIO
02:19:29 <lambdabot> Source not found. :(
02:21:57 <quicksilver> Botje: well you'd need a "collectCapabilities" primitive, yes
02:22:08 <quicksilver> Botje: to look up the privileges and set up the right types.
02:22:15 <Botje> hmm
02:22:21 <Botje> perhaps template haskell could do it, then
02:22:22 <quicksilver> Botje: but you'd only have to write that once, and it might be amenable to metaprogramming.
02:22:25 <quicksilver> right.
02:25:49 <hpaste>  scook0 pasted "a mini-DSEL for rolling dice" at http://hpaste.org/6814
02:27:54 <solrize_>  cute
02:28:50 <Botje> @pl \a b -> liftM2 (+) (roll a) (roll b)
02:28:50 <lambdabot> (. roll) . liftM2 (+) . roll
02:29:21 <quicksilver> Botje: liftM2 (+) `on` roll
02:29:22 <quicksilver> I think
02:29:26 <mauke> @pl \roll a b -> liftM2 (+) (roll a) (roll b)
02:29:26 <lambdabot> flip =<< (((.) . liftM2 (+)) .)
02:29:41 <solrize_> i saw some paper a while back claiming aspects and monads were basically the same thing?
02:29:50 <scook0> in this case I have to deconstruct the syntax tree anyway
02:30:01 <scook0> so pointlessness doesn't buy me anything
02:30:05 <Botje> solrize_: wouldn't surprise me if monads could be used to implement aspects
02:30:25 <solrize_> http://citeseer.ist.psu.edu/410310.html   this isn't it
02:30:25 <lambdabot> Title: Monads as a theoretical foundation for AOP - De Meuter (ResearchIndex)
02:30:51 <Botje> but I don't think you can use monads to simulate the weaving aspect (heh) of AOP
02:30:57 <solrize_> http://c2.com/cgi/wiki?AspectOrientedProgramming
02:30:58 <lambdabot> Title: Aspect Oriented Programming
02:31:08 <solrize_>     *
02:31:08 <solrize_>           o For example, in HaskellLanguage you can write a graph-searching procedure that can either do a depth-first search and return the first result, or do a breadth-first search and return a list of results, merely by running it in a different monad.
02:31:20 <solrize_> i've never understood what aop was
02:31:36 <solrize_> so i saw some paper saying it was monads and said "oh all right then"
02:31:40 <Botje> it's basically automated tree rewriting
02:31:45 <solrize_> hmm
02:31:56 <Botje> you can say "whenever this method is called, patch in this code"
02:32:05 <solrize_> sort of like generics?
02:32:12 <Botje> or "this method should throw a compile error if it is called from within this package"
02:32:32 <Botje> << food
02:32:46 <solrize_> ok
02:32:54 <solrize_> bon appetit
02:33:25 <quicksilver> it's adding cut points to your code for other changes
02:33:34 <quicksilver> it's "like" OO inheritance
02:33:37 <quicksilver> but along another axis
02:33:45 <quicksilver> adding an axis is "like" subclassing, only different.
02:34:34 <solrize_>     *
02:34:34 <solrize_> In a sense, AspectOrientedProgramming is the opposite of FunctionalProgramming. The core mindset of FunctionalProgramming is computation without relying on SideEffects; in a sense, the core mindset of aspects is adding SideEffects. Aspects are like the DecoratorPattern applied to functions.
02:35:56 <Saizan> and you can use typeclass-methods as those cut-points sometimes, hence the connection with monads
02:36:20 <quicksilver> yes.
02:37:26 <quicksilver> a problem is, many people have an objection to OO-style inheritance and over-riding.
02:37:39 <quicksilver> Finding that it's not very use to get right, and not neessarily a good model.
02:37:47 <quicksilver> the aspect stuff inherits some of those problems.
02:37:53 <quicksilver> Of course, the key is choosing the cut points.
02:38:10 <quicksilver> if you deisng your program in such a way that the cut points represent sensible abstractions, then it can work fine.
02:38:27 <quicksilver> But really, then, you're just saying "modularise your program correctly using relevant abstraction"
02:38:37 <quicksilver> which is, *duh*, what good programming is about anyway.
02:39:03 <solrize_> :t (#)
02:39:04 <lambdabot> parse error on input `)'
02:39:11 <quicksilver> solrize_: # is magic.
02:39:22 <quicksilver> solrize_: it's reserved in standard haskell and used for evil stuff by GHC.
02:39:33 <solrize_> heh
02:39:41 <solrize_> Power serious: Haskell magic
02:39:41 <solrize_> revert (0:ft) = rs where rs = 0 : 1/(ft#rs)
02:39:56 <solrize_> http://www.cs.dartmouth.edu/%7Edoug/powser.html
02:39:57 <lambdabot> Title: Power serious
02:40:22 <quicksilver> solrize_: eh. I'm wrong.
02:40:26 <solrize_> oh it's something he defines in that lib
02:40:28 <quicksilver> solrize_: it's not reserved by haskell, actually.
02:40:34 <quicksilver> it is a valid identifier.
02:40:36 <solrize_> i thought it was a builtin
02:40:44 <solrize_> yeah theres stuff like Int# or whatso
02:41:12 <solrize_> it's cool that doug mcilroy is hacking in haskell
02:41:47 <quicksilver> I'm not sure why lambdabot gives that error.
02:41:51 <quicksilver> probably a bug in LB's pre-parser?
02:42:05 <quicksilver> > let (#) = (+) in 3 # 4
02:42:08 <lambdabot>  7
02:42:29 <quicksilver> I thought its use was discouraged, because of the magichash stuff though.
02:42:33 <quicksilver> certainly you don't see it used very often.
02:42:43 <quicksilver> the explicit typeclass paper uses it for dictionary application.
02:43:01 <Saizan> (#) doesn't work in :t becuase -fglasgow-exts is enabled there
02:44:33 <solrize_> http://www.cs.dartmouth.edu/%7Edoug/music.ps.gz  the paper is cute too, should go in haskell wiki
02:44:37 <solrize_> a link to it i mean
02:45:05 <quicksilver> solrize_: it's a wiki. Add it.
02:45:24 <quicksilver> Saizan: -fglasgow-exts moves # from symbol to identifier?
02:45:57 <solrize_> heh, already there, under functional pearls
02:49:05 <hpaste>  dolio pasted "zipWithN" at http://hpaste.org/6815
02:49:20 <dolio> Saizan: ^^
02:49:37 <Saizan> quicksilver: it seems so
02:50:48 <HunterXHunter> how do i input multi-lines in GHCi?
02:51:15 <quicksilver> you don't, I'm afraid.
02:51:18 <quicksilver> make it one long line
02:51:55 <quicksilver> do putStrLn "hello" ; putStrLn "world" ; line <- getLine ; putStrLn ("You said " ++ line)
02:51:58 <quicksilver> for example.
02:52:11 <Twey> Aren't the braces necessary?
02:52:17 <quicksilver> don't think so.
02:52:31 <quicksilver> only if you are nesting two blocks
02:52:37 <quicksilver> :t do putStrLn "hello" ; putStrLn "world" ; line <- getLine ; putStrLn ("You said " ++ line)
02:52:38 <lambdabot> IO ()
02:52:47 <Twey> Doesn't seem to be.
02:52:49 <Twey> Ah
02:53:41 <quicksilver> basically, because I omitted the braces, that *is* in layout mode
02:53:50 <quicksilver> but even in layout mode, you are allowed explicit ;
02:54:09 <quicksilver> do putStrLn "hello" ; putStrLn "crazy"
02:54:11 <Saizan> dolio: ah! it seems i missed a lot, never seen Set1 before :)
02:54:16 <quicksilver>    putStrLn "world"
02:54:19 <quicksilver> is valid.
02:55:54 <Twey> quicksilver: Oh, OK
02:56:36 <quicksilver> Twey: I use that style in parsing monads, for example
02:57:00 <quicksilver> do key "if" ; e <- expr ; key "then" ; t <- expr ; return (If e t)
02:57:09 <quicksilver> (then next line would be a different statement form)
02:57:21 <quicksilver> I find otherwise your grammar takes up too much space!
02:57:43 * Twey nods.
02:57:49 <Twey> This makes sense :-)
02:57:58 <dolio> Saizan: Doesn't work quite as 'zipWithN n ...' though. You have to specify the whole type scheme if you want it to work.
02:59:08 <hpaste>  dolio annotated "zipWithN" with "usage" at http://hpaste.org/6815#a1
02:59:16 <dolio> But it works.
03:03:22 <Saizan> i was expecting that, it's a bit too much to infer
03:03:45 <Saizan> now i'll try to understand the code :)
03:29:49 <nominolo> is hackage down?
03:30:16 <quicksilver> nominolo: looks like it.
03:30:52 <nominolo> @localtime dons
03:30:54 <lambdabot> Local time for dons is Fri Apr  4 03:30:52 2008
03:31:28 <nominolo> guess it's going to take a while to go back up.  everyone's sleeping...
03:32:35 <yuriyp> :t (%)
03:32:38 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
03:32:49 <yuriyp> @where (%)
03:32:50 <lambdabot> I know nothing about (%).
03:32:54 <yuriyp> @where %
03:32:55 <lambdabot> I know nothing about %.
03:33:41 <HunterXHunter> > add (1 2)
03:33:42 <lambdabot>   add an instance declaration for (Num (t -> Integer))
03:33:55 <yuriyp> @hoogle %
03:33:56 <lambdabot> Data.Ratio.(%) :: Integral a => a -> a -> Ratio a
03:34:11 <HunterXHunter> > (+) (1 2)
03:34:11 <lambdabot>   add an instance declaration for (Num (t -> a))
03:34:20 <nominolo> > 1 + 2
03:34:21 <lambdabot>  3
03:34:27 <nominolo> > (+) 1 2
03:34:28 <lambdabot>  3
03:34:40 <HunterXHunter> >abs (-90)
03:34:46 <nominolo> > ((+) 1) 2
03:34:46 <lambdabot>  3
03:34:47 <HunterXHunter> > abs (-90)
03:34:48 <lambdabot>  90
03:36:45 <HunterXHunter> @localtime
03:36:56 <HunterXHunter> @localtime melbourne
03:38:53 <desegnis> lambdabot has "add"?
03:39:05 <desegnis> @check \x y -> add x y == (x+y :: Integer)
03:39:05 <lambdabot>  OK, passed 500 tests.
03:39:25 <nominolo> :t add
03:39:26 <lambdabot> forall a. (Num a) => a -> a -> a
03:39:44 <nominolo> @index add
03:39:44 <lambdabot> bzzt
03:40:31 <HunterXHunter> > add 1 2
03:40:32 <lambdabot>  3
03:48:03 <HunterXHunter> > let some n | n > 0 = n| otherwise = -n
03:48:03 <lambdabot>  Parse error at end of input
03:48:25 <HunterXHunter> > let some n | n > 0 = n| otherwise = -n in -24
03:48:26 <lambdabot>  -24
03:55:16 <byorgey> > let some n | n > 0 = n| otherwise = -n in some -24
03:55:16 <lambdabot>   add an instance declaration for (Num (a -> a))
03:55:24 <byorgey> > let some n | n > 0 = n| otherwise = -n in some (-24)
03:55:24 <lambdabot>  24
03:57:30 <HunterXHunter> is otherwise a haskell keyword?
03:57:37 <EvilTerran> ?src otherwise
03:57:37 <lambdabot> otherwise = True
03:57:40 <Twey> HunterXHunter: otherwise = True
03:57:42 <Twey> Aw
03:57:43 <Twey> :-D
03:57:46 <EvilTerran> HunterXHunter, not as such, no
03:57:56 <HunterXHunter> ok
03:58:18 <HunterXHunter> > let some n | n > 0 = n| True = -n in some (-24)
03:58:19 <lambdabot>  24
03:59:33 <HunterXHunter> ?src if
03:59:33 <lambdabot> Source not found. Maybe you made a typo?
03:59:36 <Twey> HunterXHunter: Basically, it goes down the guards until it finds one that's true
03:59:42 <Twey> And True is always true
03:59:44 <HunterXHunter> I see
04:00:09 <Twey> HunterXHunter: So if you put otherwise first it'll always be executed :-)
04:00:20 <Twey> Hey, isn't that a defined execution order?
04:02:06 <quicksilver> yes.
04:02:15 <quicksilver> if anyone told you haskell didn't have a defined execution order, they were lying to you.
04:02:20 <quicksilver> go and beat them for a bit.
04:02:54 <HunterXHunter> > let some n | True = 69 | n > 0 = n| True = -n in some (-20)
04:02:55 <quicksilver> however, the haskell execution order isn't *completely* defined.
04:02:55 <lambdabot>  69
04:03:07 <quicksilver> and an optimising compiler has therefore got some freedom to reorder some things.
04:04:04 <Twey> quicksilver: Oh :-P
04:04:17 <quicksilver> in practice extent haskell implementations stick almost entirely to the 'obvious non-strict evaluation order'
04:04:27 <Twey> Yes
04:04:30 <quicksilver> but strictness optimisations change it slightly.
04:05:17 * Twey nods.
04:06:14 <HunterXHunter> > (x+x)^5
04:06:15 <lambdabot>  (x + x) * (x + x) * ((x + x) * (x + x)) * (x + x)
04:06:37 <quicksilver> ironically, the prelude implementation for ^ doesn't use repeated squarin.
04:06:54 <quicksilver> it would be nice in some ways if Expr should show the sharing.
04:06:57 <quicksilver> hard to do, though.
04:07:02 <quicksilver> (hard to do nicely)
04:08:43 <SamB> quicksilver: what does it use?
04:08:52 <SamB> just repeated multiplication?
04:09:05 <Twey> @src (^)
04:09:05 <lambdabot> Source not found. You speak an infinite deal of nothing
04:09:08 <Twey> :-(
04:09:14 <Twey> @src Int (^)
04:09:14 <lambdabot> Source not found. It can only be attributed to human error.
04:09:20 <Twey> Huh.
04:14:17 <EvilTerran> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Real.html#^
04:14:17 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Real.html#^
04:21:29 <quicksilver> SamB: I think so. For some instances at least.
04:29:15 <Peaker> hey, do any of you use Haskell as a testing infrastructure/platform for products of other languages?
04:34:19 <quicksilver> Peaker: no but I've often thought of it as a nice idea.
04:34:59 <Peaker> quicksilver, Yeah, I usually used Python, but especially for system testing, where the "debugging loop" may take minutes (starting up the system, setting it up, etc) and then you hit all your Python typos... could be nice to have type inference :-)
04:37:16 <Botje> Peaker: doesn't python have a -c mode like ruby and perl?
04:37:23 <Botje> which allows you to catch syntax errors?
04:37:42 <Peaker> Botje, syntax errors are caught, but variable/attribute/method name errors are not considered syntax errors
04:37:51 <Botje> hmm
04:37:57 <Peaker> Botje, and wrong argument list orders, or even argument list counts, etc are not syntax errors
04:38:27 <Peaker> using a language like Java may help that but the extra declaration clutter would not be worth it...
04:38:35 <Botje> at least perl errors about unknown variables
04:38:47 <EvilTerran> when you use strict; anywayt
04:39:04 <Botje> if you don't use strict you're not writing perl :)
04:39:12 <EvilTerran> heh
04:40:44 <Botje> Peaker: and surely wrong argument counts could be caught?
04:40:48 <Peaker> Botje, Perl wouldn't catch arglist errors/etc.. Variable name typos in Python could heuristically be found as they could in Perl, with "pylint" or such, but its just one of many
04:41:18 <Peaker> Botje, nope, because some_object.some_func(1,2,3)  cannot know what type some_object is, so what 'some_func' is being called, it is undecidable
04:41:33 <Botje> bah.
04:41:43 <Botje> you'd guess they would at least try
04:42:00 <EvilTerran> you could check a certain amount staticall
04:42:03 <EvilTerran> y
04:42:21 <EvilTerran> warn for the cases that can't be determined one way or t'other
04:42:32 <Peaker> I think maybe pylint does, but heuristics make noise :-)
04:42:43 <mapreduce> So you're saying that Python users don't actually want runtime errors? ;)
04:43:22 <Peaker> mapreduce, I may be a minority, but I dislike dynamic typing.  The only reason I preferred using it was because there's no language of that kind that I know of that has type inference, so static typing implies annoying verbosity
04:43:22 <Botje> phil wadler mentioned python is introducing types (and checking), is this true?
04:43:45 <mapreduce> Peaker: Of what kind?
04:43:57 <Peaker> Python 3 is introducing "annotations" which are an extension to the syntax that lets you add arbitrary data to your code, so that a code processor could use it to do anything, including type checking
04:44:53 <Peaker> mapreduce, In Java, for example, specifying the type of the argument and also the type of the parameter, and the type of each variable in the function, etc - when it could all be inferred
04:45:01 <Peaker> mapreduce, its redundant
04:45:39 <mapreduce> Peaker: Yes, but you said there's no language of the same kind as Python that has type inference.  By what would a language be the same kind as Python?
04:45:49 <mapreduce> Haskell is an existing language that has type inference.
04:46:21 <Peaker> mapreduce, Haskell is functional, and Python is imperative/OO
04:46:32 <Philippa> Peaker: tried ocaml?
04:46:43 <Peaker> Philippa, nope, but its also mainly functional, isn't it?
04:47:07 <mapreduce> Peaker: Are you familiar with The Awkward Squad?
04:47:13 <Peaker> mapreduce, nope, what's that?
04:47:37 <mapreduce> @go awkward squad haskell simon peyton jones
04:47:38 <lambdabot> http://research.microsoft.com/~simonpj/papers/marktoberdorf/
04:47:38 <lambdabot> Title: Simon Peyton Jones: papers
04:49:23 <mapreduce> That addresses the imperative part.  Scala is a language that has type inference and OO, but limited type inference because subtyping in OO makes some inference impossible.
04:49:27 <Peaker> mapreduce, cool, that's a reply to my testing question, right?
04:49:54 <mapreduce> No, it's an attempt to put Haskell in the same category as Python wrt imperative.
04:49:58 <mapreduce> Or even a better one.
04:52:18 <quicksilver> a great example of the annoyance of not having type inference in a system with sophisticated types is STL in C++
04:52:23 <quicksilver> if you've ever had to write:
04:52:48 <quicksilver> std::map<int , std::list<std::string> >::iterator foo = list.begin();
04:53:08 <quicksilver> then you've felt the frustration "But the compiler *knows* what type list.begin() has, why do I have to tell it?
04:53:10 <Peaker> mapreduce, Haskell seems great, I might eventually replace all my Python with Haskell, when I am comfortable... but its not exactly the same category.  Haskell requires a bit more learning curve and thought for things that are first-class primitives in Python (not necessarily a bad thing)
04:53:33 <Peaker> quicksilver, yep.. I wonder why so few have inference
04:53:53 <quicksilver> of course, it's a good thing that C++ understands that iterators have types like that
04:54:01 <quicksilver> I like the fact that the iterator is type checked
04:54:08 <quicksilver> but I hate having to declare the variable.
04:54:20 <quicksilver> (not that I use much C++, but I have done in the past)
04:54:47 <resiak> quicksilver: hence 'auto' in C++0x^H^H10
04:54:49 <baaba> good thing c++0x is getting a fix for that :P
04:54:51 <Peaker> I dislike C++.. Too complicated, horrible syntax, lack of inference, many pitfalls, no checked exceptions, etc etc
04:54:53 <baaba> huhu
04:55:08 <mapreduce> Peaker: "no checked exceptions" might be a plus.
04:55:23 <Peaker> mapreduce, how so?  It loses many of the static-language advantages
04:55:36 <mapreduce> There are better ways of dealing with that situation than exceptions.  See Maybe in Haskell.
04:55:42 <mapreduce> Or Either.
04:55:49 <quicksilver> resiak: I didn't even know about that.
04:55:53 <mapreduce> Or conditions in lisp.
04:56:09 <quicksilver> resiak: (but then, I haven't followed C++ for ages)
04:56:09 <resiak> quicksilver: not having to type out the type of an iterator is the normal reason given for its creation
04:56:11 <Peaker> mapreduce, well, how do you report an error condition in a C++ constructor?
04:56:13 <quicksilver> nod
04:56:27 <Peaker> mapreduce, Well, I'm speaking of C++, it doesn't have Maybe or error conditions :-)
04:56:34 <quicksilver> if constructors can fail, then they shouldn't have the type C++ forces them to have
04:56:37 <resiak> quicksilver: me either.  That's about the only thing I know anything about :)
04:56:46 <quicksilver> but, that's a C++ restriction.
04:56:49 <Peaker> quicksilver, if constructors can't fail, then they are not very useful
04:56:55 <quicksilver> actually, I don't mind C++ exceptions.
04:57:01 <mapreduce> Peaker: Make a function that does the checking that the constructor did, and make the constructor invisible.
04:57:16 <quicksilver> Peaker: if the default int(0) construct can fail, then you have a slightly painful language ;)
04:57:16 <mapreduce> Then the constructor doesn't need to be able to fail.
04:57:27 <Peaker> mapreduce, you want the "checking"+"operation" to be atomic, the constructor cannot do the "operation" without the checking
04:57:40 <jcaldwell> anyone know whats up with http://hackage.haskell.org/packages/hackage.html - No response.  Is it down or did it move?
04:57:45 <Peaker> mapreduce, the result is that you move code out of constructors into special "init" methods
04:57:54 <Peaker> mapreduce, Which results in the language benefits collapsing one after the other...
04:58:10 <mapreduce> @go constructors considered harmful
04:58:11 <lambdabot> http://gbracha.blogspot.com/2007/06/constructors-considered-harmful.html
04:58:11 <lambdabot> Title: Room 101: Constructors Considered Harmful
04:58:40 <baaba> heh
04:58:53 <baaba> kinda haughty there
04:59:11 <baaba> "to understand why i'm right, you have to understand what 'object oriented' REALLY means, like i do"
04:59:38 <baaba> (i didn't finish reading yet, just commenting on appearances because they're funny)
04:59:40 <mapreduce> I think what should be considered harmful is statically-typed OOP.
05:00:24 <Peaker> mapreduce, why do you think checked exceptions in C++ would be a bad idea?
05:00:51 <mapreduce> Peaker: Because the only language I've seen them used in, Java, has similar syntax to C++, and they're bad in Java.
05:01:01 <quicksilver> I'm too busy to read all of that, but I think he makes some good points.
05:01:24 <mapreduce> Bad because they don't compose well, and force people to make an early decision.
05:01:24 <Peaker> mapreduce, I think they're bad in Java because of lack of inference
05:01:27 <quicksilver> although the general notion of constructor is a useful one, and I'm not talking about OOP exclusively.
05:01:34 <mapreduce> Inference wouldn't improve it.
05:01:36 <baaba> and besides java's exceptions aren't fully checked - you can still throw a bunch of stuff from a method that's marked as not throwing anything
05:01:38 <quicksilver> "0" is a constructor, and so it "Just"
05:01:55 <mapreduce> baaba: Java has both checked and unchecked exceptions.
05:02:01 <quicksilver> but I agree that if you're trying to build the kind of system they want to build, you wouldn't normally export the constructor.
05:02:08 <baaba> mapreduce, yeah that was my point
05:02:18 <baaba> my wording was a bit poor
05:02:26 <mapreduce> baaba: Java's checked exceptions are fully checked :)
05:02:43 <quicksilver> in a sense, haskell has unchecked and checked exceptions.
05:02:44 <Peaker> mapreduce, I think checked exceptions could work if there were generic-enough ways to specify what it raised.  Or at least, the distinction between cannot-throw and can-throw is very meaningful
05:03:03 <quicksilver> Either is an example of a checked exception and 'throw' is an example of an unchecked one.
05:03:07 <mapreduce> Peaker: I think monads are a better way.
05:03:33 <quicksilver> monads don't, in and of themselves, solve the exception hierarchy problem.
05:03:33 <Peaker> mapreduce, they let you do this checking in the type system, and have inference, so it does sound so :)
05:03:41 <quicksilver> On the other hand, I think that problem is exagerrated.
05:03:50 <mapreduce> quicksilver: What exception hierarchy problem?
05:03:51 <Peaker> quicksilver, I am not sure exceptions really map well to a "hierarchy"
05:03:52 <quicksilver> But maybe I don't work often enough in the kind of system which encounters it.
05:04:23 <Peaker> I think catching exceptions based on their generic type "KeyError" in Python for example, is wrong and does not work.  Catching should be based on much more fine-grained specification
05:04:41 <quicksilver> it's not so much coarse-grained catching
05:04:48 <quicksilver> as coarse-grained declaring
05:04:54 <Peaker> type is ok if the thrower and catcher are from the same code and can have a unique type for that purpose
05:04:56 <quicksilver> foo throws AnyIOError
05:05:12 <quicksilver> because foo calls al kinds of methods which themselves throw 'subtypes' of AnyIOError
05:05:34 <mapreduce> Scala uses pattern matching to catch exceptions, and despite being a Java-based language it doesn't have checked exceptions.
05:05:35 <quicksilver> like I say, I don't actually worry about this problem. When I encounter it in practice, I solve it in that particular case.
05:05:43 <quicksilver> but some people get very het up about it.
05:05:49 <Peaker> yeah, foo() should not propagate them as is, but convert them to "ErrorInA(old_error)" maybe
05:05:56 <mapreduce> The reason being that they cause more problems than they solve in what the designers saw of their use in Java.
05:11:01 <Peaker> I like the monad diagrams in the "tackling the awkward" paper
05:14:02 <HunterXHunter> how do I see the source code of variable in GHCi ?
05:14:17 <HunterXHunter> ?src add
05:14:17 <lambdabot> Source not found. I've seen penguins that can type better than that.
05:19:37 <kuribas> What is the syntax for functional dependencies?
05:20:01 <kuribas> Is there only one pipe character, or can there be more after the class keyword?
05:20:55 <doserj> class A n m k l | n -> m, k -> l, l -> n
05:23:25 <shepheb> HunterXHunter: GHCi can't do that. it's a lambdabot feature. there's an installable, command-line \bot somewhere, though.
05:23:31 <Jedai> HunterXHunter: You can't see the source code of variable in GHCi (not yet)
05:23:39 <kuribas> doserj: I see, thanks.
05:26:37 <HunterXHunter> > ?src odd
05:26:47 <shepheb> @src odd
05:26:47 <lambdabot> odd = not . even
05:26:52 <lambdabot>  thread killed
05:27:05 <HunterXHunter> @src even
05:27:05 <lambdabot> even n = n `rem` 2 == 0
05:27:17 <shepheb> (most \bot commands are @-prefixed)
05:27:25 <HunterXHunter> ok
05:28:04 <opqdonut> ?scheck \x -> x `mod` 2 == x `rem` 2
05:28:09 <lambdabot>   Failed test no. 1. Test values follow.: -1
05:28:22 <opqdonut> so i thought
05:28:33 <opqdonut> > (rem -1 2, mod -1 2)
05:28:48 <lambdabot>  thread killed
05:28:50 <shepheb> big lag.
05:28:53 <opqdonut> yeah
05:29:15 <shepheb> box seems to be busy, and ordinary commands are taking so long that the time-out kills it.
05:29:28 <opqdonut> well anyway, that's (-1,1)
05:29:43 <opqdonut> ?scheck \x -> x `mod` 2 == 0 ==> x `rem` 2 == 0
05:29:43 <lambdabot> Done.
05:29:47 <opqdonut> that'll probably work
05:29:49 <opqdonut> yeah
05:30:13 <HunterXHunter> where do I see the commands for lambdabot?
05:30:23 <Saizan> @help list
05:30:23 <lambdabot> list [module|command]
05:30:23 <lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
05:33:50 <HunterXHunter> @karma
05:33:50 <lambdabot> You have a karma of 0
05:34:19 <HunterXHunter> @unlambda
05:34:20 <lambdabot> Done.
05:38:48 <mkdnro> hi, is hackagedb down?
05:39:30 <Saizan> mkdnro: it looks like that, there were some problems with the server yesterday too
05:39:53 <mkdnro> ok, thanks
05:40:00 <HunterXHunter> which GUI library is mostly used and stable?
05:40:15 <Saizan> HunterXHunter: gtk2hs
05:40:57 <HunterXHunter> Saizan: does it work on windows?
05:41:36 <EvilTerran> yes
05:41:37 <Saizan> HunterXHunter: sure, but the current windows installer is for ghc 6.8.1
05:43:34 <quicksilver> HunterXHunter: wxHaskell is also used quite a bit and also stable, IMO.
05:44:13 <HunterXHunter> which one is the easiest to use?
05:44:16 <Saizan> there has been a new release last month, right?
05:44:20 <HunterXHunter> install and code-wise
05:45:08 <quicksilver> I'm not sure, really.
05:45:17 <quicksilver> I've only used wx personally.
05:45:33 <quicksilver> I suggest you have a look at some code examples on the web
05:45:38 <quicksilver> and see which looks nicest to you.
05:46:52 <shepheb> Saizan: I thought I heard something about a 6.8.2 Windows bundle
05:47:43 <HunterXHunter> wxHaskell looks nicer
05:48:09 <Saizan> shepheb: oh, well, i didn't see it on the site
05:48:26 <Saizan> but i've not searched a lot :)
05:48:56 <HunterXHunter> does HOpenGL come standard with haskell?
05:49:12 <quicksilver> yes.
05:49:17 <qwr> wxwidgets c++ api is a goddamn ugly hack. probably its implementation isn't any better...
05:49:28 <quicksilver> well, if you get one of the 'all-in-one' installer packages.
05:49:35 <quicksilver> qwr: in what way?
05:49:48 <qwr> quicksilver: stupid use of C macros
05:50:06 * quicksilver shrugs
05:50:29 <quicksilver> doesn't seem to affect how you use it.
05:50:35 <qwr> quicksilver: even in C++ it could have been done much better. gtkmm is an example
05:50:44 <quicksilver> I've used it in haskell and poked at it in C++ to add new bindings.
05:50:58 <quicksilver> and it seems quite functional to me
05:51:17 <qwr> quicksilver: maybe. i just don't code written by people who designed that api. or copied it willingly from MFC.
05:51:32 <qwr> s/don't code/don't trust code/
05:54:35 <skorpan> \s -> system $ "mpc" ++ s
05:54:44 <skorpan> @pl \s -> system $ "mpc" ++ s
05:54:44 <lambdabot> system . ("mpc" ++)
06:01:38 <kuribas> Does anyone know a reference to the *exact* syntax of functional dependencies?
06:01:51 <quicksilver> No.
06:01:56 <quicksilver> There may not be one.
06:01:58 <quicksilver> ;)
06:02:06 <HunterXHunter> is there a game engine for haskell?
06:02:21 <quicksilver> | a b c -> d , f g -> h
06:02:26 <quicksilver> is the general pattern
06:02:48 <quicksilver> so, fundeps = <list of fundep separated by ,>
06:02:59 <quicksilver> fundep = <list of tyvars> -> <tyvar>
06:03:07 <quicksilver> fundep = <list of tyvars seperated by spaces> -> <tyvar>
06:03:15 <quicksilver> kuribas: is that what you need?
06:03:23 <quicksilver> HunterXHunter: not a generic one, no.
06:03:23 <kuribas> Quicksilver: yes
06:03:37 <quicksilver> HunterXHunter: "Frag" is a complete and fairly interesting example game though.
06:03:38 <HunterXHunter> damn
06:03:42 <quicksilver> HunterXHunter: long the general liines of Quake.
06:03:54 <kuribas> quicksilver: Maybe I'll find it in the ghc source.
06:04:09 <quicksilver> kuribas: yeah, it'll be there somewhere. dunno where. In the happy files, I guess?
06:04:30 <kuribas> quicksilver: That sounds logical :)
06:05:22 <HunterXHunter> FunGEn seems dead
06:05:39 <HunterXHunter> but it looks promising
06:05:44 * skorpan just started out writing an mpd client in haskell
06:07:39 <shepheb> PE 76 is frustrating me. I seem to have discovered the interesting mathematics, but it still takes many minutes.
06:10:09 <dejones> dons: cool stuff that gnome will use xmonad.  :)  congrats.
06:10:36 <shepheb> dejones: (check the post's date)
06:10:47 <dejones> dons: hahaha
06:10:52 <Peaker> Gnome will use xmonad? When?
06:10:55 <dejones> shepheb: n1
06:10:58 <Peaker> April 1st? :)
06:11:08 <dejones> I was reading through Google Reader... didn't see the date.  ;)
06:11:14 <dejones> That's a great one.
06:11:17 <dejones> dons: you got me!
06:11:18 <shepheb> yeah, it was an AFJ from dons.
06:11:36 * Peaker uses compiz
06:15:29 <resiak> so, did anyone get around to binding up the necessary compositing stuff to add bling to xmonad?
06:16:33 <shepheb> resiak: there's a GSoC proposal about adding compositing support to xmonad.
06:16:56 <HunterXHunter> how is xmonad different to normal monad?
06:17:17 <shepheb> HunterXHunter: xmonad is a project, a tiling window manager for X11 written in Haskell
06:17:22 <shepheb> xmonad.org
06:17:28 <HunterXHunter> oh ok
06:17:42 <Botje> HunterXHunter: the X stands for "extra"
06:17:49 <Botje> much, I suppose, like the X in your name :)
06:17:52 <HunterXHunter> not X window?
06:18:19 <resiak> shepheb: hooray!
06:18:47 <shepheb> resiak: a proposal, though. no guarantees it'll get chosen, or done.
06:20:01 <resiak> shepheb: sure, i know
06:48:42 <CosmicRay> @seen bos
06:48:42 <lambdabot> I saw bos leaving #haskell and #ghc 13h 32m 47s ago, and .
06:55:07 <HunterXHunter> @seen Hunter
06:55:07 <lambdabot> I haven't seen Hunter.
06:55:38 <Beelsebob> @seen HunterXHunter
06:55:38 <lambdabot> HunterXHunter is in #haskell. I last heard HunterXHunter speak 31s ago.
07:12:08 <HunterXHunter> @seen Robert
07:12:08 <lambdabot> I haven't seen Robert.
07:12:18 <HunterXHunter> @seen wossname
07:12:18 <lambdabot> I haven't seen wossname.
07:34:00 <HunterXHunter> has haskell been used in commercial projects?
07:34:18 <quicksilver> yup.
07:34:25 <HunterXHunter> example?
07:34:30 <gnuvince> galois.com
07:34:40 <allbery_b> http://haskell.org/haskellwiki/Haskell_in_industry
07:34:43 <lambdabot> Title: Haskell in industry - HaskellWiki
07:36:30 <gbacon> I've looked in http://wiki.darcs.net/DarcsWiki/ConflictsFAQ, but is there no straightforward way to see a concise lists of conflicted files with darcs?
07:36:32 <lambdabot> Title: ConflictsFAQ - DarcsWiki
07:36:53 <pejo> HunterXHunter, cufp.galois.com has plenty of examples
07:37:49 * desegnis is always amazed recognizing the "typical" personnel manager is concerned mainly about C++
07:39:32 <shepheb> a
07:39:38 <shepheb> bah
07:41:57 <CosmicRay> is anyone else having trouble getting to hackage this morning?
07:43:03 <kuribas> dolio: ping
07:43:56 <allbery_b> <Igloo> I e-mail the local admin last night, but I think after he went home. I can't log in to the machine
07:44:01 <allbery_b> (re hackage)
07:45:47 <CosmicRay> ah, thanks.
07:45:52 <CosmicRay> it seems darcs.haskell.org is down too.
07:46:03 <CosmicRay> ah, same machine.
07:46:03 <CosmicRay> doh.
07:46:04 <allbery_b> I think they're both vms on the same physical machine
07:46:13 <allbery_b> or something
07:47:36 <Volatile> Is it possible to define functions/types using utf-8 characters in haskell?
07:47:42 <CosmicRay> hrm, who here works at galois?
07:47:57 <CosmicRay> Volatile: IIRC, it is.
07:48:06 <opqdonut> yeah in ghc
07:48:11 <allbery_b> Volatile: with sufficiently recent ghc
07:48:33 <allbery_b> and the first character must be "lowercase" I think, unless it's an operator
07:48:40 * Volatile just tried in 6.8.2
07:48:41 <Volatile> hm
07:48:43 <allbery_b> (in which case it must be a unicode "symbol")
07:49:19 <Volatile> I wonder if my LaTeX input method produces the right chars...
07:49:29 <desegnis> use -XUnicodeSomething
07:49:30 <allbery_b> what are you trying to define?
07:49:42 <Volatile> desegnis; ah! That could do it
07:50:27 <desegnis> -XUnicodeSyntax it was
07:50:43 <Volatile> allbery_b; just playing around a bit... I was thinking of writing a finite state machine in haskell using mathematical operators (delta and whatnot) instead of "run" and other such nonsense
07:51:19 <allbery_b> okay, just keep inmind that normal haskell rules apply, and unicode does distinguish between lowercase and uppercase and symbol
07:51:33 <Volatile> Would the following line be erroneous: data ∑ = I | O
07:51:49 <allbery_b> should be ok as that's uppercase
07:52:34 <Volatile> This, however, is what ghc thinks of it: hm.hs:12:5: parse error on input `'
07:53:19 <desegnis> Volatile: Use an ordinary upper case sigma
07:53:30 <desegnis> that is, Σ
07:53:36 <allbery_b> oh, right, if that's the symbol variant it won't work
07:53:38 <CosmicRay> does anybody here have a copy of fastcgi sitting around that they could send me while I wait for hackage or darcs.haskell.org to come back up?
07:53:46 <Volatile> Ah
07:54:34 <Volatile> desegnis; thanks! Now I know that my way of inputing greek essentially is "broken"
07:54:51 <Volatile> (Or, to be more exact, it puts in exactly what I want, but not what haskell wants)
07:55:18 <desegnis> yeah, your character is described as the summation sign
07:55:31 <Volatile> oh
07:55:43 <quicksilver> there are two capital sigmas
07:55:45 <quicksilver> maybe more.
07:55:52 <quicksilver> one is a greek alphabet capital letter
07:55:57 <quicksilver> (and would be valid as a type or constructor)
07:56:12 <quicksilver> the other is a mathematical operator
07:56:12 * Volatile knows
07:56:12 <allbery_b> yeh, unicode is kinda messed up.
07:56:12 <quicksilver> (and would be valid as an operator, I think)
07:56:16 <opqdonut> unicode is kinda flawed that way
07:56:19 <quicksilver> using both in the same haskell program would be very confusing for your readers :)
07:56:20 <opqdonut> trying to give semantics to glyph
07:56:21 <opqdonut> s
07:56:29 <opqdonut> quicksilver: exactly
07:56:29 * Volatile tries to use ∑ as an operator
07:56:58 <desegnis> infix sum operator? :)
07:57:00 <opqdonut> (btw, my irc client renders all your new-fangled unicode characters as '?')
07:57:08 <Volatile> desegnis; hehe, yep :D
07:57:22 <quicksilver> there would be problems if unicode didn't admit semantics, too.
07:57:30 <quicksilver> I think they were between a rock and a hard place.
07:57:35 <quicksilver> both approaches would have disadvantages.
07:59:37 <Volatile> desegnis; ∑ is now an infix operator that takes in two lists of ints and returns 1
08:00:19 <Jedai> Volatile: looks useful ;)
08:00:31 <Volatile> :)
08:00:54 <mrd> Volatile: i tried to do the same thing, but it got annoying since I can't use \Sigma for example as a variable name
08:01:00 <Volatile> Jedai; it compiles, which is it's only purpose. :)
08:01:24 <desegnis> Oh, Unicode distinguished small letter final sigma (ς) and Greek small letter stigma (ϛ), where the former is also called like the latter in modern Greek, but is not to be confused with the latter. ...
08:01:36 <Volatile> mrd; yeah, it sucks. However, having a real greek IM should help me get rid of the problem, I hope
08:01:41 <mrd> no
08:01:47 <mrd> the reason is that \Sigma is capital
08:02:02 <mrd> the tex-input method works fine
08:02:41 <Volatile> mrd; \Sigma is a mathematical symbol, and uppercase. It is different from the greek uppercase Sigma.
08:02:54 <Volatile> Trust me, I'm currently using one as a data, and the other as an infix operator.
08:02:55 <mrd> \sum is the math operator
08:03:01 <Volatile> hm
08:03:06 <Volatile> then my IM is truly broken.
08:03:10 <mrd> which IM?
08:03:15 <Volatile> ah
08:03:16 <Volatile> wait
08:03:35 <Volatile> maybe it's me that apparently is heavily incompetent
08:03:48 <Volatile> mrd; oh, my bad
08:04:36 <Volatile> \s ≠ \Sigma, for obvious reasons.
08:04:58 <Volatile> mrd; thanks for pointing that error out for me. :)
08:05:11 <mm_freak_work> hi people
08:05:11 <desegnis> Volatile, your Σ could be even more fun if you used Iota and Omikron instead of I and O
08:05:44 <Volatile> oo :)
08:06:07 <Jedai> I have mixed feelings on Unicode in code... From one pov it's really cool and look nice, from the other it leads to various problems like those symbols that looks the same
08:06:45 <Volatile> Well, those probles aren't really unicode's fault.. :)
08:06:49 <Jedai> And it's hard to input !
08:07:30 <Volatile> Jedai; well, mostly not the subset you need... :)
08:07:46 <mm_freak_work> somehow i don't get how to create an ST MArray properly…  do i just use newArray somewhere in the ST monad and type inference will do the rest?
08:07:58 <mrd> mm_freak_work: well
08:08:02 <mrd> yes and no
08:08:14 <quicksilver> often you need a type sig somewhere.
08:08:17 <mrd> you can help it along with an explicit type annotation.  but if you use runSTArray, it shouldn't need it
08:08:42 <mm_freak_work> ok, thank you
08:08:46 <mm_freak_work> that answers my question
08:08:56 <mrd> the main problem is that you can't give a type annotation involving "ST s" without an extension
08:09:15 <mrd> so you could either dodge the problem by putting an annotation somewhere inside an expression which avoids having to state "ST s"
08:09:22 <mm_freak_work> well…  i was going to use runSTArray anyway
08:09:22 <mrd> or enable something which turns on lexical type variables
08:10:00 <mrd> if you use runSTArray, in my experience, that should be sufficient for type inference
08:10:01 <mm_freak_work> its type suggests that you can use it with extensions only anyway
08:10:11 <mm_freak_work> at least quantification
08:10:18 <desegnis> Jedai, we really need OCR software optimized for source code
08:10:31 <mrd> you can use ST without extensions, but giving a type sig might be difficult.  there's tricks like "asTypeOf" too
08:11:18 <Jedai> desegnis: To be able to just write symbol on touch screen ?
08:11:28 <desegnis> right
08:11:44 <desegnis> although that probably introduces new problems
08:11:59 <mrd> tex-input is pretty convenient
08:14:50 <takamu> hi
08:16:19 <byorgey> hey takamu
08:16:36 <HunterXHunter> can I safely assume otherwise is defined in haskell 98?
08:16:56 <HunterXHunter> or do people prefer to use True?
08:17:06 <mrd> otherwise is defined
08:17:11 <HunterXHunter> mmmkay
08:17:35 <mm_freak_work> mrd: how can you emulate 'forall'?
08:18:11 <mrd> you don't: you just let the type checker figure that part out, while giving it a signature for the other part
08:18:59 <mrd> maybe something like newArray (1::Int, 10) (0::Int)
08:20:24 <gour> hi, is there something like pytz (http://pytz.sourceforge.net/) available for haskell?
08:20:24 <lambdabot> Title: pytz - World Timezone Definitions for Python
08:20:37 <mrd> a time library ships with ghc
08:22:09 <kuribas> lambdabot: tell dolio I have added the extensions to haskell-indentation.el: http://kuribas.hcoop.net/haskell-indentation.el.
08:23:01 <kuribas> @tell dolio I have added the extensions to haskell-indentation.el: http://kuribas.hcoop.net/haskell-indentation.el.
08:23:01 <lambdabot> Consider it noted.
08:23:07 <gour> mrd: thanks. let me check it
08:24:04 <quicksilver> kuribas: which ones? mptcs and fundeps?
08:24:51 <kuribas> quicksilver: Type families and fundeps.
08:25:22 <kuribas> And guards with commas.
08:27:39 * quicksilver nods
08:27:43 <quicksilver> cool.
08:27:58 <quicksilver> kuribas: does your parser recurse to process multiline do blocks?
08:28:06 <quicksilver> kuribas: if so, I think that explains why I'm hitting the eval depth.
08:28:56 <orzo> I'm using GHC from macports on Mac OS X 10.5.  However, I want to build aps targetted for 10.4.  What do I need to do?
08:29:08 <quicksilver> pray. cry.
08:29:14 <orzo> heh
08:29:24 <quicksilver> I honestly don't know, but I think I know who does.
08:29:24 <sw17ch> ouch :)
08:29:40 <kuribas> quicksilver: Yes it does.
08:30:16 <quicksilver> you need Christian Maeder and/or Manuel Chakravarty.
08:30:23 <quicksilver> they are the guys who understand ghc on macs.
08:30:39 <quicksilver> orzo: what you want is possible, I believe. But I don't know how to do it myself.
08:30:40 <Volatile> hm, can I tell haskell that I want it not to include (.) from Prelude?
08:30:50 <quicksilver> import Prelude hiding ((.))
08:31:02 <orzo> do those guys come here and have irc nicks?
08:31:03 <quicksilver> kuribas: right, well that explains that.
08:31:06 <HunterXHunter> > let pattern 2 = 1;pattern 3 = 2;pattern 4 = 3 in pattern 4
08:31:09 <lambdabot>  3
08:31:13 <quicksilver> kuribas: I have quite long do blocks.
08:31:16 <kuribas> quicksilver: Could you show me some code that has this problem?
08:31:21 <quicksilver> kuribas: did you increase the default as you suggested you might?
08:31:27 * dolio downloads.
08:31:45 <kuribas> quicksilver: Yes, I did.  But the lenght of a block shouldn't make a difference.
08:31:49 <quicksilver> orzo: the latter, occasionally, under the name ChilliX
08:31:53 <kuribas> quicksilver: Unless there is a bug.
08:32:02 <Volatile> quicksilver; ah, thanks
08:32:15 <quicksilver> kuribas: I was imagining <doblock> = <stmt> <doblock>
08:32:22 <quicksilver> kuribas: that recurses one level deep for each line
08:32:26 <quicksilver> in a naive recdescent parser
08:32:35 <dolio> kuribas: What all has changed?
08:32:49 <quicksilver> orzo: http://hackage.haskell.org/trac/ghc/ticket/1540
08:32:51 <lambdabot> Title: #1540 (GHC on Macs) - GHC - Trac
08:32:55 <quicksilver> orzo: contains some relevant nuggets.
08:33:00 <quicksilver> orzo: loads rather slowly at the moment though
08:33:09 <kuribas> dolio: I added functional dependecies, and I made "data" and "type" an expression :-)
08:33:18 <dolio> Ah, okay.
08:33:27 <kuribas> dolio: And I made it possible to write "data instance".
08:33:50 <kuribas> quicksilver: For such things I use a "while" loop.
08:34:06 <quicksilver> kuribas: ah, that's OK. it's not that, then.
08:34:24 <quicksilver> kuribas: I don't have anythign like a minimal example, I'm afraid.
08:34:30 <quicksilver> kuribas: I'll try to cut one down for you.
08:34:42 <kuribas> quicksilver: You can give maximal example too :-)
08:35:02 <HunterXHunter> > let BigOrDumb b d = (b || d) == d in BigOrDumb True False
08:35:02 <lambdabot>   Not in scope: data constructor `BigOrDumb'
08:35:54 <HunterXHunter> wheres my syntax error?
08:36:07 <shepheb> functions need to start with a lowercase letter
08:36:11 <HunterXHunter> oh
08:36:13 <shepheb> bigOrDumb
08:36:17 <HunterXHunter> > let bigOrDumb b d = (b || d) == d in bigOrDumb True False
08:36:18 <lambdabot>  False
08:36:25 <HunterXHunter> not dumb
08:40:30 <Volatile> B . [I,O,O] ∈  f -- Look, readable haskell! \o/
08:41:15 <quicksilver> for values of 'readable' approaching J
08:41:23 <Volatile> J?
08:42:03 <Volatile> quicksilver; I never really understood the concept of "run", "next" and "finally" or what they're called until I was given the notation above... :)
08:42:25 <Volatile> (Which, btw, was today)
08:43:36 <HunterXHunter> so all variables in haskell must stat with lowercase ?
08:43:40 <Volatile> (The only mathematical convention I had to circumvent was the F becoming an f...)
08:44:00 <sieni> HunterXHunter: yes
08:44:05 <Volatile> HunterXHunter; yes. Variables and functions. Not data definitions, though.
08:44:17 <HunterXHunter> oh ok
08:44:19 <Volatile> and not modules
08:44:28 <HunterXHunter> I only started learning haskell last night
08:45:08 <HunterXHunter> I'm going to port my 8 puzzle solver later :D
08:45:55 <sieni> well module and type names have to start with an uppercase letter
08:46:00 <quicksilver> Volatile: J is a language reknowned for concise single character syntax.
08:46:39 <quicksilver> http://en.wikipedia.org/wiki/J_programming_language
08:49:14 <Volatile> quicksilver; ah, that J...
08:49:53 <Volatile> ...and people think perl looks like line noise...
08:52:12 <kuribas> quicksilver: I've got to go.  Could you email me the program otherwise?
08:54:29 <Volatile> (Hmm, J actually seems kinda neat...)
08:55:40 * Volatile is thinking of making a J utf-8-implementation in Haskell, just for fun... :)
08:55:49 <byorgey> Volatile: J is pretty neat =)
08:56:14 <bogner> J?
08:56:15 <byorgey> Volatile: J utf-8?  You mean... APL? ;)
08:56:36 <byorgey> bogner: jsoftware.com
08:56:51 <quicksilver> kuribas: Yes. I'm not sure I have an email address for you.
08:57:27 <Volatile> byorgey; yes, but standardized! \o/
08:57:33 <byorgey> hehe
08:57:35 <Volatile> (In a good way)
08:57:53 <kuribas> quicksilver: You can find it in the elisp file.
08:58:02 <byorgey> it could be fun implementing a subset of J.  Good luck making it fast though. ;)
08:58:08 <Volatile> Shouldn't APL have it's own unicode page? :)
08:58:08 <quicksilver> kuribas: ah, will do.
08:58:12 <quicksilver> byorgey: someone is doing that, I think.
08:58:17 <byorgey> quicksilver: oh?
08:58:19 <quicksilver> byorgey: someone in this IRC channel, I mean
08:58:21 <quicksilver> don't remember the name.
08:58:27 <Volatile> oh
08:58:33 <mapreduce> byorgey: Why would J be slow?
08:58:51 <HunterXHunter> J reminds me of line noise
08:58:57 <sieni> Volatile: unicode has the whole apl character set
08:59:05 <Volatile> \o/
08:59:18 <byorgey> mapreduce: I just mean that the language primitives are quite high-level, so it would take some work to make sure that your implementation is efficient.
08:59:32 <mapreduce> More so than Haskell?
08:59:57 <byorgey> AIUI, the J interpreter from jsoftware has quite a lot of tricks up its sleeve.
09:00:13 <byorgey> mapreduce: no idea, I've never tried implementing either one, so this is just speculation =)
09:00:28 <Volatile> hahaha
09:00:42 * Volatile lols at the "whilst" J control sequence
09:00:50 <Volatile> s/sequence/structure/
09:00:59 <byorgey> whilst?
09:01:03 <byorgey> I don't remember that one
09:01:06 <Volatile> while, skip teste
09:01:14 <Volatile> skips the test first iteration
09:01:16 <Volatile> :D
09:01:22 <byorgey> oh, so do..while
09:01:27 <Volatile> exactly
09:01:45 <byorgey> control structures in J are such a horrible idea
09:01:50 <tromp> wonder how many 1-letter programming languages there are
09:01:58 <Volatile> tromp; propably 28
09:02:05 <tromp> i know of c,d,j,r
09:02:10 <byorgey> they had such a nice, elegant language and then had to go and ruin it by including control structures
09:02:11 <Volatile> b
09:02:28 <byorgey> don't forget a
09:02:29 <Volatile> byorgey; ah. A shame.
09:02:32 <tromp> i only count ones that have wikipedia entries...
09:02:41 <byorgey> and k
09:02:48 <kuribas> And q.
09:02:48 <tromp> so b and k fail:(
09:02:55 <Volatile> hehe
09:02:59 <sw17ch> How many bits long is a Char?
09:03:00 <byorgey> what, K doesn't have a wikipedia entry?  that's surprising
09:03:00 <Volatile> tromp; b is what c was made from
09:03:02 <rdtsc> e and s
09:03:14 <sw17ch> the maxBound is 1114111, so... 21 bits
09:03:21 <sw17ch> but is there a significance to that?
09:03:28 <Volatile> http://en.wikipedia.org/wiki/B_(programming_language)
09:03:54 <quicksilver> sw17ch: that's what unicode is.
09:03:57 <quicksilver> sw17ch: *shrug*
09:04:07 <tromp> oh, right you are, volatile
09:04:12 <sw17ch> quicksilver: my understanding was that unicode wasn't a fixed bit length
09:04:14 <Volatile> oh, there is E, E and e
09:04:29 <sw17ch> i'm just playing with System.Random...
09:04:35 <quicksilver> sw17ch: unicode is a character set, not an encoding.
09:04:36 <byorgey> and http://en.wikipedia.org/wiki/K_(programming_language)
09:04:42 <tromp> http://en.wikipedia.org/wiki/List_of_programming_languages helps
09:04:43 <lambdabot> Title: Alphabetical list of programming languages - Wikipedia, the free encyclopedia
09:04:49 <quicksilver> sw17ch: and the unicode character set goes up to that number.
09:04:54 <opqdonut> there's also Q
09:04:55 <quicksilver> sw17ch: or, one version of it does
09:05:07 <quicksilver> so called "code points"
09:05:18 <sw17ch> quicksilver: well, that's what i was getting at. which version is haskell using?
09:05:21 <sw17ch> (by default)
09:05:21 <byorgey> https://secure.wikimedia.org/wikipedia/en/wiki/List_of_programming_languages
09:05:24 <lambdabot> http://tinyurl.com/5ukyeq
09:05:30 <sieni> sw17ch: I guess it depends on what encoding the implementation uses for storing Chars
09:05:35 <quicksilver> sw17ch: the standard, whatever it is
09:05:40 <sieni> sw17ch: I guess GHC uses WTF-8
09:05:43 <quicksilver> how it is encoded is a separate question, of course.
09:05:49 <quicksilver> you guess wrong.
09:05:50 <tromp> b,c,d,e,f,h,j,k,l,q,r,s,t,v,y
09:05:53 <Volatile> oh
09:05:53 <quicksilver> GHC uses wchar_32t
09:05:58 <quicksilver> you whatever it's called
09:05:59 <Volatile> and MUMPS is called M nowadays
09:06:03 <quicksilver> (on unix compiles)
09:06:12 <sieni> quicksilver: ok
09:06:18 <Volatile> tromp; don't forget that there are three different E/e:s
09:06:31 <byorgey> the missing ones are A, G, I, M, N, O, P, U, W, X, Z
09:06:45 <Volatile> well, M exists
09:06:46 <quicksilver> I have a suspicion it's ISO 10646-1
09:06:49 <quicksilver> Z exists.
09:06:50 <Volatile> http://en.wikipedia.org/wiki/MUMPS_programming_language
09:06:51 <lambdabot> Title: MUMPS - Wikipedia, the free encyclopedia
09:07:09 <sw17ch> quicksilver: mm... alright, thanks. I was just a little caught off guard when my random Char list produced a bunch of unicode escape strings
09:07:10 <Volatile> A _should_ exist, afaik...
09:07:16 <sw17ch> i guess i shouldn't be surprised
09:07:24 <byorgey> MUMPS is not a programming language, it is a torture device
09:07:30 <quicksilver> ;)
09:07:54 <PenguinOfDoom> whew! I was a bit worried that you guys were discussing how to best implement algorithms in INTERCAL
09:08:03 <byorgey> oh, good idea!
09:08:09 <PenguinOfDoom> :(
09:08:14 <byorgey> ;)
09:08:31 <PenguinOfDoom> Just you start, and I'll shutdown my laptop faster than you can say "bitwise operations are great"
09:08:55 <Volatile> ooh
09:09:02 <bogner> the one letter languages that aren't taken yet, according to wikipedia: G,I,M,N,O,P,U,W,X
09:09:17 <Volatile> PenguinOfDoom; well, why non TRINTERCAL while whe're at it? :)
09:09:28 <Volatile> Hmm
09:10:15 <Volatile> In formal theory, the function X can be used to describe EVERYTHING... But does it count as a language. (And am what I'm saying at all understandable in English right now...)
09:10:55 <yuriyp> @hoogle flush
09:10:55 <lambdabot> GHC.ConsoleHandler.flushConsole :: Handle -> IO ()
09:10:55 <lambdabot> System.IO.hFlush :: Handle -> IO ()
09:11:20 <rdtsc> One letter languages are not google-friendly. Might as well name the language "Britney"...
09:11:20 <rey_> bogner, check again: http://en.wikipedia.org/wiki/G_programming_language :)
09:12:19 <mapreduce> rdtsc: I think J predates google.
09:12:46 * byorgey goes off to invent the P programming language
09:12:49 <mapreduce> @go j programming language
09:12:51 <lambdabot> http://www.jsoftware.com/
09:12:52 <lambdabot> Title: J Home
09:12:57 <mapreduce> *shrug*
09:13:08 <bogner> rey_: does it count if it's been renamed?
09:13:19 <byorgey> it will be descended from Haskell but use one or two-character symbols for all Prelude functions
09:13:42 <rey_> I think it does :)
09:14:11 <byorgey> and it will also have added primitives for calculating orbits and such, and I will sell it to astronomers
09:14:23 <byorgey> I'll be RICH!
09:14:33 <Volatile> byorgey; with utf-8-support, why the need for two-character symbols?
09:14:39 <sethk> byorgey, I think you're a bit spaced out.
09:14:43 <byorgey> haha
09:14:48 <bogner> byorgey: make function names of more than 2 characters illegal, to encourage good scope!
09:14:56 <Volatile> hehe
09:14:57 <byorgey> Volatile: the utf-8 version will be called P+
09:15:01 <Volatile> oo
09:15:03 <byorgey> bogner: good idea!
09:15:13 <yuriyp> when I compile a script to exe and run it, it buffers output
09:15:17 <HunterXHunter> I'm waiting for the Z programming language
09:15:27 <yuriyp> is there a switch or somethign to prevent it from happening?
09:15:39 <rey_> http://99-bottles-of-beer.net/language-x++-69.html
09:15:41 <byorgey> HunterXHunter: it already exists, apparently =)
09:15:41 <lambdabot> Title: 99 Bottles of Beer | Language X++
09:15:47 <HunterXHunter> bah it already exist
09:15:48 <HunterXHunter> http://en.wikipedia.org/wiki/Z_(programming_language)
09:15:48 <rey_> does X++ count as a single letter?
09:15:54 <byorgey> yuriyp: hSetBuffering stdout NoBuffering
09:16:45 <Volatile> hm
09:16:55 * Volatile is still trying to find the X he was talking about
09:17:08 <yuriyp> @hoogle hSetBuffering
09:17:09 <lambdabot> System.IO.hSetBuffering :: Handle -> BufferMode -> IO ()
09:17:49 <rdtsc> I'm going unicode, the ? programming language is mine!
09:18:11 <Twigathy> Well then I'll take ¿
09:18:13 <Volatile> Hehe
09:18:15 <yuriyp> byorgey: thanks, that worked!
09:18:19 <byorgey> hm, how many programming languages have Greek letters as their name?
09:18:20 <Twigathy> grah, fail encoding :o
09:18:33 <byorgey> yuriyp: great, you're welcome!
09:18:45 <Volatile> Well, I'll take the  language then, since it's actually a character... ;)
09:19:07 <Volatile> Aww, google sucks...
09:19:14 <sieni> Volatile: :-
09:19:24 <Volatile> :)
09:19:29 <Volatile> :
09:19:29 <bogner> ? is barely unicode, are mayan numerals in unicode?
09:19:40 <Volatile> EVERYTHING is is unicode
09:20:16 <rdtsc> bogner: it was a weird glyph that didn't render
09:20:22 <Volatile> ᚐ would be a nice name...
09:20:44 <bogner> fair enough. bbiab
09:21:56 <mapreduce> Names are old hat, here's a picture of a horse instead. <horse.jpg>
09:21:58 <mapreduce> huh?
09:22:06 * Volatile gives up finding X
09:22:14 <Volatile> old hat?
09:22:30 <mapreduce> An expression meaning "unfashionable".
09:22:31 <rdtsc> There is no programming language called Lambda? That's strange...
09:22:39 <Volatile> oh
09:22:49 <Volatile> rdtsc; there's always unlamda
09:23:44 * Volatile sees if Haskell has real support for Ogham text
09:24:37 <roconnor> > 308*logBase 10 2
09:24:38 <lambdabot>  92.7172386645062
09:25:47 <Volatile> hm... since Ogham has chars that always starts and ends an ogham text, shouldn't they not only be allowed but mandatory in ogham function names?
09:26:39 <HunterXHunter> _
09:26:39 <HunterXHunter>    \
09:26:39 <HunterXHunter> /   \_/
09:28:13 <gnuvince> Cute lambda
09:28:27 * shepheb tries to define (/\) and (\/), and is delighted that they work
09:28:28 <Volatile> λ <-- mine is better
09:28:31 <HunterXHunter> gnuvince: thanks
09:28:46 <shachaf> Volatile: In this font, that one looks horrible.
09:28:51 <Volatile> aww
09:28:56 * Volatile lost
09:29:19 <shachaf> Volatile: (But I'm used to it by now.)
09:29:48 <shepheb> low standards for the win?
09:30:23 <Volatile> shachaf; Install new fonts ftw? :)
09:31:28 <shachaf> Volatile: Someday, yes.
09:32:01 <shachaf> \    /
09:32:01 <shachaf>  \--/
09:32:01 <shachaf>   \/
09:32:39 <Volatile> ooh, is that a ∀?
09:32:59 <Volatile> ehm, as in "forall"
09:33:10 <shachaf> Volatile: Yes, but I don't see that one (2200) at all.
09:33:41 <Nafai> byorgey: Thanks for the help the other day
09:35:11 <byorgey> Nafai: you're welcome!  Did you get it to work?
09:35:26 <Nafai> Mostly
09:35:33 <Nafai> http://hpaste.org/6784#a3
09:35:49 <Nafai> I'm not getting the from data for a particular test, but I'm not sure if that's my problem or not
09:37:06 <byorgey> Nafai: cool, looks good to me
09:37:46 <byorgey> Nafai: oho, wait!
09:38:03 <byorgey> Nafai: could there be multiple To or From fields in a list of headers?
09:38:58 <byorgey> if so, you'll want mappend to combine the to and from data rather than just choosing the first one that isn't Nothing
09:39:40 <byorgey> I think you can do that just by saying e.g.  fromHeader = fromHeader h1 `mappend` fromHeader h2  instead of `mplus`
09:39:52 <Nafai> Good question
09:40:20 <Nafai> I was assume since it was a list of NameAddr's it combined them all to one strcuture
09:40:23 <byorgey> since the Monoid instance for Maybe has  instance (Monoid a) => Monoid (Maybe a) where ... Just x `mappend` Just y = Just (x `mappend` y)
09:40:25 <Nafai> Er, structure
09:40:31 <byorgey> yeah, that could be
09:40:40 <Nafai> But I'll try that real quick
09:40:50 <byorgey> In any case it probably wouldn't hurt
09:41:17 <byorgey> if you only ever get one To field and one From field it will just act exactly the same
09:41:38 <roconnor> byorgey: that instance seems wrong.
09:41:45 <byorgey> roconnor: which one?
09:41:53 <roconnor>  instance (Monoid a) => Monoid (Maybe a)
09:42:07 <roconnor> or at least wrong as the default
09:42:12 <roconnor> but maybe I'm wrong
09:42:20 <byorgey> roconnor: well, perhaps, but that's what it is
09:42:29 <byorgey> I thought it a little strange myself
09:42:47 <roconnor> byorgey: we don't have to accept it.  We change change the world.  Start a revolution!
09:42:47 <byorgey> that's the instance for Maybe that's defined in Data.Monoid
09:42:53 <byorgey> hehe
09:44:11 <ddarius> roconnor: What do you think it should be?
09:44:16 <Volatile> shachaf; http://www.code2000.net/code2000_page.htm
09:44:23 <lambdabot> Title: Download Code2000
09:45:25 <byorgey> the obvious  instance Monoid (Maybe a)  is actually provided by  the MonadPlus instance for Maybe
09:45:57 <byorgey> and there's also the First, Last, etc. newtypes in Data.Monoid
09:48:07 <Nafai> It must just be my source data isn't being parsed right
09:48:10 <Nafai> As far as I can tell
09:48:58 <byorgey> Nafai: can't you print out the parsed message, before you run it through processMessage?
09:50:36 <Nafai> Probably, just trying to figure out how :)
09:55:16 <byorgey> Nafai: maybe just something like replace 'either errorMessage processMessage' with 'either print print'?
09:56:11 <hpaste>  Nafai annotated "Email Stats program, start" with "(no title)" at http://hpaste.org/6784#a4
09:56:24 <Nafai> That's what I did
09:56:34 <Nafai> So I'm thinking there are problems with the email parsing library
09:57:09 <HunterXHunter> lambda was "A symbol of gay pride in widespread use in the gay community, particularly in the 1970s and 1980s."
09:57:15 <byorgey> Nafai: oh, boo =(
09:57:23 <ZurnaNet41> Hi guys , could you please check this webpage out, and give me your feedback www.eismanicaclara.com
09:57:44 <EvilTerran> enjoy your k-line
09:57:45 <Nafai> Yeah, I need to figure out who is in chrage of it and see what I need to do :)
09:58:05 <EvilTerran> ?where ops
09:58:05 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
09:58:27 <ZurnaNet41> Hi guys , could you please check this webpage out, and give me your feedback www.eismanicaclara.com
09:58:35 <ohub> haha :)
09:58:42 <shachaf> ∀
09:58:47 <shachaf> Seems to  work now.
09:58:57 <Volatile> ooh
09:59:06 --- mode: ChanServ set +o Igloo
09:59:09 <EvilTerran> o/` ops ops ops / where are teh ops o/`
09:59:22 <ZurnaNet41> Hi guys , could you please check this webpage out, and give me your feedback www.eismanicaclara.com
09:59:39 --- kick: ZurnaNet41 was kicked by Igloo (Igloo)
09:59:45 --- mode: ChanServ set +o bos
09:59:46 * EvilTerran nores that the banlist may be full again
09:59:55 <bos> ah, igloo beat me to it.
10:00:00 <Igloo> Yeah, I'm going to empty it I think
10:00:04 <bos> good plan.
10:00:08 --- mode: bos set -o bos
10:02:31 --- mode: Igloo set -b *!*@CPE00012e15cab1-CM00194757ed42.cpe.net.cable.rogers.com
10:02:31 --- mode: Igloo set -b *!*@78.154.5.144
10:02:40 --- mode: Igloo set -b *!*@201.160.161.86.cable.dyn.cableonline.com.mx
10:02:40 --- mode: Igloo set -b Carolyna_!*@*
10:02:40 --- mode: Igloo set -b *!*=PJIRCWeb@86.105.61.*
10:02:40 --- mode: Igloo set -b *!*i=sucka@*.cpe.net.cable.rogers.com
10:02:42 <HunterXHunter> <- ZurnaNet41 has disconnected (K-lined) yay
10:02:43 --- mode: Igloo set -b *!*=Hugo_Gom@89.214.120.*
10:02:45 --- mode: Igloo set -b *!*@ml82.128.13.107.multilinks.com
10:02:48 --- mode: Igloo set -b *!*@82.128.27.*
10:02:50 --- mode: Igloo set -b *!*n=POCT@*.direct-adsl.nl
10:02:53 --- mode: Igloo set -b Jim_Ross!*@*
10:02:55 --- mode: Igloo set -b *!i=ircap*@*
10:02:58 --- mode: Igloo set -b IRSeekBot!*@*
10:03:00 --- mode: Igloo set -b *!*@195-23-162-228.net.novis.pt
10:03:03 --- mode: Igloo set -b Morningsickness!*@*
10:03:05 --- mode: Igloo set -b *!*n=tulpit@*.cpe.net.cable.rogers.com
10:03:08 --- mode: Igloo set -b *!*@209.217.118.34
10:03:10 --- mode: Igloo set -b *!*=pathfind@66.175.214.*
10:03:13 --- mode: Igloo set -b *!*=BigGayBi@*.dsl.snantx.swbell.net
10:03:15 --- mode: Igloo set -b *!*=KD-Misaf@85.108.5.*
10:03:18 --- mode: Igloo set -b *!*n=irc@unaffiliated/regecks-x1337
10:03:20 --- mode: Igloo set -b *!*n=uriko04@*.dsl.bell.ca
10:03:23 --- mode: Igloo set -b *!*@4.38.41.141
10:03:25 --- mode: Igloo set -b *!n=Jenny_2@*
10:03:28 --- mode: Igloo set -b *!*@85.104.93.*
10:03:30 --- mode: Igloo set -b Wikipedia-Gast*!*@*
10:03:33 --- mode: Igloo set -b *!*=RedAlert@*.in-addr.btopenworld.com
10:03:35 --- mode: Igloo set -b *!*n=cvdsfg@*.adsl.forthnet.gr
10:03:38 --- mode: Igloo set -b *!*=gschuett@4.38.41.*
10:03:39 <roconnor> ban list, you will be missed ;(
10:03:40 --- mode: Igloo set -b *!*SoulShin@*.wanadoo.fr
10:03:43 --- mode: Igloo set -b squiggles!*@*
10:03:45 --- mode: Igloo set -b *!*=Administ@*.dsl.hstntx.swbell.net
10:03:48 --- mode: Igloo set -b *!*@222.231.63.18
10:03:50 --- mode: Igloo set -b *!*@218.22.112.166
10:03:53 --- mode: Igloo set -b WP-Gast*!*@*
10:03:55 --- mode: Igloo set -b *!*=ObeLisK_@*.w.pppool.de
10:03:58 --- mode: Igloo set -b *!*=Godsmith@unaffiliated/jargon
10:04:00 --- mode: Igloo set -b *!*@159.148.18.129
10:04:03 --- mode: Igloo set -b *!n=gschuett@*
10:04:05 --- mode: Igloo set -b *!*n=maoiwn@*.dsl.snantx.sbcglobal.net
10:04:07 <Zao> hFlush banlist
10:04:08 --- mode: Igloo set -b *!*@62-167-236-67.static.adslpremium.ch
10:04:10 --- mode: Igloo set -b *!*WP-Gast@*
10:04:13 --- mode: Igloo set -b *!n=ircap*@*
10:04:15 --- mode: Igloo set -b *!*@99.242.25.*
10:04:18 --- mode: Igloo set -b *!*n=KLBKSo*@88.237.18.*
10:04:20 --- mode: Igloo set -b *!*=KLBKSohb@*
10:04:23 --- mode: Igloo set -b AngelinaJolie26!*@*
10:04:25 --- mode: Igloo set -b *!*n=karlo@85.234.164.*
10:04:28 --- mode: Igloo set -b *!*@203186060211.ctinets.com
10:04:30 <Jaak> whoa
10:04:30 --- mode: Igloo set -b *!*@unaffiliated/l7
10:04:35 <PenguinOfDoom> Quite a collection!
10:04:37 <Saizan> gosh, one at a time?
10:04:45 <shepheb> seems like their should either be a clear-all function, or unlimited size
10:04:50 <HunterXHunter> no wonder it was full!
10:05:10 <PenguinOfDoom> shepheb: I think freenode's ircd allows channel mode changes 6 at a time
10:05:21 <PenguinOfDoom> but igloo's software computron is suboptimal.
10:08:53 <allbery_b> <shepheb> seems like their should either be a clear-all function, or unlimited size
10:09:22 <allbery_b> some clients do have clear-all, but it will still do them one at a time (well, 4 at a time max.)
10:09:39 <allbery_b> /mode #channel +bbbb pattern pattern pattern pattern
10:10:44 <dons> clearing out the bans, eh
10:12:47 <hpaste>  jmei pasted "(no title)" at http://hpaste.org/6817
10:12:59 --- mode: Igloo set -o Igloo
10:14:00 <byorgey> #haskell is suddenly inundated with bitter, desperate banned people who had set up their IRC clients to try autoconnecting every five minutes
10:14:37 <Twey> Hahahaha
10:15:09 <Zao> I've seen those in another channel. It's always fun when the bot smacks them every other week or so.
10:15:34 <lament> @botsmack
10:15:34 <lambdabot> :)
10:17:26 <ivant> @src $!
10:17:26 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
10:17:34 <ivant> @src ($!)
10:17:34 <lambdabot> Source not found. Take a stress pill and think things over.
10:18:47 <quicksilver> f $! x = x `seq` f x
10:19:07 <ivant> thanks, I was just checking my sanity :-)
10:21:42 <dons> ?users
10:21:42 <lambdabot> Maximum users seen in #haskell: 459, currently: 459 (100.0%), active: 30 (6.5%)
10:22:22 <ivant> can someone explain me how thunks are represented in GHC? I understand the theory, just want to know mo gory details
10:22:30 <ivant> s/mo/more/
10:23:01 <Zao> ivant: I'm sure that there's a section on the ghc wiki about it.
10:23:15 <ivant> Zao, thanks, I'll take a look then
10:32:04 <ivant> I can't find the right page on ghc wiki, but that's ok
10:32:25 <dons> check the STG paper
10:32:35 <dons> ?go spineless tagless G machine
10:32:37 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
10:32:37 <lambdabot> Title: Implementing lazy functional languages on stock hardware: the Spineless Tagless  ...
10:33:38 <ivant> since GHC represents the graph using combinators, and combinators don't have any free variables, does this mean that in thunk we don't need to save the environment, as it is contained in the representation of the combinator?
10:33:56 <QplQyer> anyone succeeded in installing ghc-6.8.2 or wxhaskell 0.10.3 in (k)ubuntu 7.10 here?  Compiling ghc from source gives me a panic at lookupVers1 base:GHC.Prim Int#{tc} and wxhaskell posed some problems as well
10:40:41 <s710b> QplQyer, i installed 6.8.2 on ubu 7.10 without problems. I needed to install X11 package from hackage, everything else was in the repositories
10:41:00 <s710b> err wait
10:41:33 <s710b> i needed X11 only for xmonad i think
10:42:42 <QplQyer> hmm but ghc 6.8.2 is not in the repositories, did you install it from source then?
10:42:55 <s710b> yes
10:43:11 <QplQyer> ah kay
10:43:14 <shepheb> QplQyer: many people use the GHC binaries from the GHC site.
10:43:27 <s710b> i cant remember having any problems
10:44:21 <QplQyer> I tried the ones from the site I believe, but ran into some problems
10:44:29 <s710b> shepheb, the binaries didnt work for me so i installed from source
10:45:09 <shepheb> s710b: on Ubuntu 7.10? do you have an unusual architecture?
10:46:00 <s710b> shepheb, no, everything is standard here. A dependency was missing
10:46:26 <Saizan> s710b: readline?
10:47:10 <s710b> Saizan, no, it was something like lib6....
10:51:01 <QplQyer> shepheb, thanks for reminding me about that, seems the binary does work.  I probably installed it wrong before :)
10:55:06 <int80_h> greetings :)
11:03:13 <ivant> suppose we have a thunk. When it is being forced, in STG it updates itself when the value is computed. What happens if two threads try to force the same thunk? Would they try to compute it concurrently, or would one of them block until the value is computed?
11:05:36 <allbery_b> thunks are marked active while being evaluated to whnf (this is part of how loops are detected)
11:07:13 <ivant> isn't just having a pointer to the same place is a more efficient way of detecting a loop? Of course this means that we need to check it before jumping to that address
11:08:19 <Botje> are you saying that only one place should be able to reference a datastructure?
11:10:09 <allbery_b> ivant:  on entry to a thunk you replace its entrypoint with a pointer to a failure.  if some complex loop reenters it it instantly fails
11:10:15 <ivant> Botje, no. Does it imply that?
11:11:00 <ivant> allbery_b, why not represent loop = loop as a single word which contains address of its location?
11:11:45 <allbery_b> no reason you can't, unless STG requires it for some reason
11:11:55 <allbery_b> but what of more complicated loops?
11:12:02 <ivant> allbery_b, like what?
11:12:15 <allbery_b> a = b; b = a -- a simple example
11:12:37 <allbery_b> you can make longer chains, with branches even
11:12:45 <ivant> allbery_b, you have a point, thanks
11:14:04 <ivant> so, does it mark the thunk with the current thread id when it is being evaluated?
11:21:16 <ivant> ok, I found the answer to the last question in the paper
11:22:37 <grahamhutton> @users
11:22:37 <lambdabot> Maximum users seen in #haskell: 461, currently: 460 (99.8%), active: 19 (4.1%)
11:26:02 <HunterXHunter> almost broke the record tsk tsk
11:27:17 <dons> 479 is the high score
11:27:28 <CCCCOMBOBREAKER> oh :(
11:27:36 <HunterXHunter> lol
11:27:39 <HunterXHunter> owned
11:28:18 <roconnor> dons: what are the other 440 people doing?
11:29:23 <ivan> joining a channel is just a vote of confidence
11:29:35 <allbery_b> sleeping, eating lunch, paying attention to other channels
11:30:31 <sieni> probably not having sex anyway
11:30:58 <Japsu>  
11:31:23 <allbery_b> only if they're idling in #haskell-blah :)
11:31:58 <qwr> would it better, when all 460 would be writing here at same time?
11:32:46 <Consul> Don't mind me, I'm just scanning Flickr for Japanese nature and outdoors photos. :-)
11:36:38 <dons> the channel is a bit weird today
11:36:43 <dons> lots of new faces
11:40:06 * EvilTerran was thinking about threaded realtime chat a while ago
11:40:52 <HunterXHunter> I was new 2 days ago
11:42:33 <EvilTerran> it'd make busy channels more manageable if messages could be marked as being in response to another message
11:42:49 <EvilTerran> (assuming people actually used it - that's the tricky bit)
11:43:54 <idnar> EvilTerran: the main problem is implementing it in a backwards-compatible fashion, and getting support into people's clients
11:44:09 <ivant> dons, I'm not new, I'm just rare in IRC :-)
11:44:18 <shepheb> EvilTerran: but then newbies wouldn't gain as much brain explosion material from lurking here.
11:44:27 <EvilTerran> yeah. i was thinking it might be possible to build something on top of, say, IRC
11:45:23 <EvilTerran> so you could have channels where every message from people using the system was tagged with some unique id, and some would also be tagged with an "in reply to" or something
11:45:41 <EvilTerran> (all courtesy of the custom/extended client software)
11:47:07 <EvilTerran> "#123[idnar#234] iah iah cthlulhu f'thaghn" kinda thing
11:48:38 <EvilTerran> "<cthulhu> #1[EvilTerran#123] you rang?"
11:48:45 <idnar> heh
11:49:03 <allbery_b> cthulhu always calls collect
11:49:23 <EvilTerran> then the custom clients could display discussion trees, like on mailing lists and whatnot
11:49:52 <lament> 1-800-CAL-CTLU
11:50:23 <idnar> EvilTerran: you could also have some heuristics for guessing threading based on "directed" comments (like this one)
11:50:27 <EvilTerran> indee
11:50:34 <idnar> (similar to what some mail clients do with Re: in the subject)
11:51:20 <EvilTerran> if you're gonna have heuristics, it'd of course be necessary to let people re-arrange the tree themselves to fix errors
11:51:38 * allbery_b wants threading on top of jabber, which should be easy to add modulo client support
11:56:00 <EvilTerran> as i said, the fiddly bit would be getting people using it
11:56:22 <EvilTerran> it'd be really hard to make the interface slick enough that people would bother picking out what they're replying to
11:57:20 <byorgey> yeah, you'd just need really good heuristics
11:57:24 <EvilTerran> especially as, for something as keyboard-oriented as chat, it'd have to be easy to use from just the keyboard
11:57:40 <byorgey> maybe with a brain interface you could extract the necessary information to decide which message is being replied to =)
11:57:43 <EvilTerran> (although offering mouse control as well wouldn't be a problem)
11:57:44 <mapreduce> EvilTerran: I know a way.  When I'm talking to you I'll preface the line with "EvilTerran: " and your client can do some kind of highlighting.  It won't work if two conversations overlap in users or if I'm talking to myself.
11:58:05 <byorgey> haha
11:58:12 <EvilTerran> mapreduce, that kinda works, but i could've said something to someone else before you replied to me, either
11:58:13 <mrd> brainterface
11:58:35 <EvilTerran> so, yeah, it remains heuristics. that's why i was thinking something explicit (but optional) would be helpful
11:58:56 <mrd> that's either a brain interface, or a bra interface
11:59:33 <byorgey> hmm... a bra interface would be decidedly less useful for this purpose
12:00:01 <allbery_b> matching ket interface?
12:00:03 <byorgey> my little brother asked my mom the other day what a bra is
12:00:06 <EvilTerran> you *could* do timestamps instead of explicit ids, but that wouldn't work unless the stamps were decided by some central authority (the server or something)
12:00:13 <mapreduce> "That stupid hook.. I have done this before, honest!"
12:00:16 <mrd> whaa
12:00:22 <byorgey> turns out he heard some surfer dudes on a TV show calling each other "bra", as in "what's up, bra" =)
12:00:26 <mrd> what's the age difference?
12:00:47 <EvilTerran> you could have a bot, i guess, that'd echo back each line said in #foo in #foo-ids, with an id attached
12:01:03 <byorgey> mrd: he is 9, and also adopted =)
12:01:27 <mrd> i see.  i was pretty sure you're older than I
12:01:38 <EvilTerran> byorgey, heh. that's not quite as bad as the kid who saw "c'mon" in text and thought it was pronounced "cee-mon"
12:01:48 <byorgey> EvilTerran: hehe
12:03:19 <byorgey> if (26 > age mrd) then IsOlder byorgey mrd else YoungerOrEqual byorgey mrd
12:03:47 <mrd> EQ
12:05:03 <mapreduce> IsNotYoungerOrOlder
12:05:55 <shepheb> this is starting to sound like a TDWTF. bool isTrue (bool x) { if (x == true) { return true; ...
12:08:01 <EvilTerran> } else { return FileNotFound; } }
12:08:10 <monochrom> hehe
12:08:27 <mrd> DoesNotCompute
12:08:45 <shepheb> that Yes, No, FileNotFound "boolean" enum cracked me up.
12:09:40 <mrd> True | False | _|_
12:09:44 <shepheb> Maybe and Either would really help those poor p - oh wait, their languages don't have algebraic data types. or type inference of any kind.
12:10:08 <monochrom> To complete it as a TDWTF, you have to add: else if (x == false) { return false; }  /* the punch line comes */  else { throw HaltingProblemException("the value " + x + "doesn't terminate"); }
12:10:43 <monochrom> a Java/C++ version of what mrd said. :)
12:13:51 <tromp> whats TDWTF?
12:14:04 <Deewiant> thedailywtf.com
12:15:23 <Feuerbach> excuse me for a little offtopic, but what APL-like language would you suggest for a novice? J? K?
12:16:37 <monochrom> Haskell.
12:17:32 <Japsu> I would not.
12:17:43 <Feuerbach> monochrom: sorry, it's insufficiently cryptic
12:18:25 <EvilTerran> malbolge
12:18:25 <monochrom> > (+ 3) . [10, 30, 20]
12:18:28 <lambdabot>  [13,33,23]
12:18:44 <monochrom> IMO (+ 3) . [10, 30, 20] is more cryptic than J, K, APL.
12:18:52 <HunterXHunter> eww C code
12:19:29 <Deewiant> monochrom: of course, you don't have to define (.) as fmap. :-P
12:20:15 <Feuerbach> monochrom: you cheater
12:20:17 <monochrom> Also don't forget to look into Control.Arrow and Control.Applicative.  >>> *** &&& <*> &#*$ wtf lol bbq
12:20:25 <byorgey> Feuerbach: I recommend J.
12:20:45 <Otoom> Hey all!
12:21:06 <MyCatVerbs> > (==3) <$> [1..5]
12:21:07 <lambdabot>  [False,False,True,False,False]
12:21:23 <Feuerbach> byorgey: thanks
12:21:38 <byorgey> hey oToom
12:21:47 <monochrom> Do J, K, APL allow you to define new cryptic operators?
12:22:09 <monochrom> Do they allow you to define a new type class to have cryptic operator overloading?
12:22:26 <mrd> that's right, haskell supports language-level crypticology
12:22:54 <monochrom> IMO allowing you to add cryptic stuff is preferred to just providing builtin cryptic stuff.
12:23:06 <Cale> monochrom: (.) being fmap is really not all that cryptic :)
12:23:11 <mrd> built-in crypticism can be learned from manuals
12:23:21 <mrd> added crypticism can be left undocumented!
12:23:22 <monochrom> Similarly, a person with the ability to gain more knowledge is preferred to a person just possessing knowledge.
12:23:42 <mrd> or is that crypticality
12:23:43 <monochrom> CDRW > CD-ROM
12:24:12 <Japsu> no, this is sparta.
12:24:54 <Feuerbach> Cale, monochrom: I must admit, quite cryptic. Why doesn't it work in my ghci?
12:25:04 <quicksilver> haskell supports language-level steganography
12:25:07 <monochrom> Cale cheated.  Not me. :)
12:25:11 <quicksilver> you can have a program which apparently does something harmless
12:25:15 <quicksilver> like print "hello world"
12:25:22 <Cale> Feuerbach: Basically, lambdabot loads a module which redefines (.)
12:25:23 <Deewiant> Feuerbach: because it's only defined in lambdabot.
12:25:24 <quicksilver> and conceal the real program at the type level!
12:25:52 <Cale> Feuerbach: It simply redefines it as fmap, which is a generalisation of both function composition and the map operation on lists.
12:26:06 <Cale> :t fmap
12:26:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:26:24 <monochrom> Some people say monad is cryptic too, even though you write English words like "do".
12:26:25 <Cale> In the case of function composition, the 'f' there is (->) e
12:26:31 <Cale> So you get:
12:26:36 <Feuerbach> yep, I know about fmap
12:26:41 <Cale> (a -> b) -> ((->) e a) -> ((->) e b)
12:26:44 <Cale> which is:
12:26:51 <Cale> (a -> b) -> (e -> a) -> (e -> b)
12:27:08 <Feuerbach> but it's still magic, right? because just changing (.) to `fmap` doesn't work, too
12:27:28 <Cale> Well, I hide the original one, of course.
12:27:29 <Feuerbach> > ((+1) `fmap` (^2)) 3
12:27:30 <lambdabot>  10
12:27:33 <Feuerbach> hmm
12:27:38 <Feuerbach> it doesn't work in ghci either
12:27:47 <Cale> Oh, you need an instance of Functor
12:27:50 <monochrom> Yeah, import Prelude hiding ( (.) )   then define your own (.)
12:28:01 <Cale> Which is missing from the Prelude, but is in Control.Monad.Instances
12:28:06 <Feuerbach> Cale: got it, thanks
12:28:18 <oToom> Hey byorgey hows it going?
12:28:25 <monochrom> Hijacking + and - is in the works.
12:28:26 <Cale> Sometime we'll get this straightened out, and it'll work from ghci :)
12:28:31 <byorgey> oToom: pretty good, you?
12:28:40 <oToom> byorgey: yh im good thanks.
12:28:58 <oToom> Cale: My book came in the end, and so did my visa, ima buy some more. Can you recomend any other books?
12:30:26 <Cale> oToom: Well, there's one by Bryan O'Sullivan, Don Stewart, and John Goerzen which is not out yet, but it's something to watch for, called "Real World Haskell"
12:30:53 <oToom> Ah, i will look for it when it comes on amazon, thanks Cale
12:31:17 <Saizan> there are some chapters online i recall?
12:31:23 <Cale> Saizan: yeah
12:31:26 <DRMacIver> Ok. I'm totally lost in the curl bindings. If I wanted to use it to download something to a file, how on earth would I go about doing that? :)
12:31:27 <Cale> http://book.realworldhaskell.org/beta/
12:31:27 <lambdabot> Title: Real World Haskell
12:32:30 <Cale> DRMacIver: Hmm, that's annoying, the haddock fails to build on hackage
12:33:02 <DRMacIver> It emitted a huge pile of warnings when I built it. That's probably related.
12:33:34 <DRMacIver> (Well. Some warnings anyway)
12:35:34 <Cale> DRMacIver: I think you use  curlGetString "http://www.example.com/index.html" method_GET
12:35:35 <lambdabot> Title: Example Web Page
12:35:40 <Cale> heh
12:36:33 <Cale> and that, when executed, should return a pair consisting of a CurlCode (whatever that is), and a String, which is the contents of the document
12:36:36 <DRMacIver> Cale: That seems like it would only be valid for textual data though, or is representing a chunk of binary data as a Haskell string not going to cause problems?
12:37:09 <Cale> It probably won't cause any problems, it'll just be somewhat inefficient.
12:37:47 <DRMacIver> ok
12:38:06 <hpaste>  gwern pasted "wonder if this is a free license?" at http://hpaste.org/6818
12:38:32 <gwern> <-- wut the hpaste sez
12:38:36 <kpreid> hpaste: that license is BSD with advertising clause.
12:38:40 <kpreid> er, gwern:
12:38:42 <ivant> @index par
12:38:42 <lambdabot> GHC.Conc, Control.Parallel, Graphics.HGL.Utils, Graphics.HGL
12:38:51 <vss> hi
12:38:53 <sclv> sigh. buggy 6.8.2 type family support i kill you.
12:39:05 <gwern> kpreid: yeah, but I'm concerned about the last clause
12:39:06 <sclv> i don't even need real families, just a nice equality constraint.
12:39:20 <gwern> I dunno, is forbidding endorsement a nonfree clause?
12:39:31 <vss> how do I find out the implementation of 'return' in MonadError e (Either e) ?
12:39:32 <Cale> gwern: That looks like BSD
12:39:50 <sclv> instance (Typeable b, s~ r) => Sat (TupleUpD (String, ValidationFunc s a b) (String, ValidationFunc r a Dynamic))
12:40:03 <sclv> silly panic.
12:40:11 <Cale> gwern: http://en.wikipedia.org/wiki/BSD_license
12:40:12 <lambdabot> Title: BSD licenses - Wikipedia, the free encyclopedia
12:40:26 <kpreid> gwern: read about what people have said about BSD-w/-advertising-clause
12:40:32 * gwern is reading it e'en now
12:40:47 <shepheb> gwern: there's a couple of errors in it, though. for example, it doesn't say that the warranties are not applied.
12:40:49 <gwern> (I am really only familiar with the more common 3-clause)
12:40:51 <kpreid> gwern: this is not a recent invention; I'm sure it's been analyzed (or opinion-ized) thoroughly
12:41:09 <sclv> ?src Either return
12:41:09 <lambdabot> return        = Right
12:41:12 <Cale> vss: Well, return isn't implemented in that class
12:41:19 <Cale> vss: It's in Monad, of course
12:41:24 <gwern> 'The advertising clause was removed from the official BSD license text on 22 July 1999 by William Hoskins, the director of the office of technology licensing for Berkeley.[5] Other BSD distributions removed the clause, but NetBSD still uses the original version of the license and many similar clauses remain in BSD-derived code from other sources.' <-- well sure, but what does that mean?
12:42:10 <sieni> gwern: the most important thing is that the advertising clause is incompatible with gpl
12:42:30 <gwern> but still Free, according to the article
12:42:41 <vss> Cale: well, how do I find that out?
12:42:52 <gwern> huh. does Cabal still have the BSD4 option?
12:42:58 <sclv> is there any way to get equality-constraint-like functionality without using buggy equality constraints, or do i need to give up on this particular path until stable type families?
12:42:59 <byorgey> gwern: no
12:43:29 <Cale> vss: return is a method of the Monad class, so you'd look for the instance of Monad for Either e
12:43:34 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-Error.html
12:43:36 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2knezz
12:43:46 <gwern> byorgey: no? why it'd get removed? the Typing haskell in Haskell code is BSD4 and seems worth packaging to me
12:43:53 <Cale> There's the source code for Control.Monad.Error, which happens to export that instance
12:44:14 <Cale> and you can see that it defines  return = Right
12:44:23 <sieni> gwern: yes, according to fsf, the original bsd license is a gpl-incompatible free software license
12:44:25 <byorgey> gwern: I don't recall why.  let me see if I can dig it out of the cabal-devel list.
12:44:43 <Cale> vss: another way, in this case, is just to apply return to a value and see what you get
12:44:47 * gwern supposes I could use OtherLicenses or whatever tho
12:44:55 * vss is confused
12:45:07 <bringert> @seen dons
12:45:07 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 57m 29s ago.
12:45:27 <Cale> vss: The polymorphism of return ensures that you will always get the same thing, regardless of the input value
12:45:37 <vss> Cale: I don't see the URL you posted defining the return function for Either
12:45:37 <Cale> > return 5 :: Either String Integer
12:45:38 <lambdabot>  Right 5
12:45:47 <Cale> instance (Error e) => Monad (Either e) where
12:45:48 <Cale>     return        = Right
12:45:48 <Cale>     Left  l >>= _ = Left l
12:45:48 <Cale>     Right r >>= k = k r
12:45:55 <Cale> You don't see that code there?
12:46:02 <vss> no
12:46:13 <gwern> 'Thus, there is now a new BSD license which does not contain the advertising clause. Unfortunately, this does not eliminate the legacy of the advertising clause: similar clauses are still present in the licenses of many packages which are not part of BSD. The change in license for BSD has no effect on the other packages which imitated the old BSD license; only the developers who made them can change them. '
12:46:17 <Cale> It's maybe about 1/3 of the way through the file...
12:46:37 <vss> is it this URL you are referring to?
12:46:38 <vss> http://haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-Error-Class.html
12:46:42 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/6j39p2
12:46:47 <Cale> no
12:46:53 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-Error.html
12:46:55 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2knezz
12:47:14 <gwern> oh, the Berkeley thing is for the advertisement clause when it mentions Berkeley, ok
12:47:20 <phlpp> @go 120 Pesos in usd
12:47:21 <lambdabot> 120 Mexican pesos = 11.35428 U.S. dollars
12:47:35 <phlpp> @go 120 Pesos in eur
12:47:36 <lambdabot> 120 Mexican pesos = 7.26859996 Euros
12:48:06 <gwern> hm. in theory I could edit the Typing haskell in haskell code, and then license my new modified version as BSD3 no?
12:48:10 <ivant> why do I keep getting messages like "undefined reference to `__stginit_parallelzm1zi0zi0zi0_ControlziParallel_'" during linkage (ghc6.8.2)?
12:48:14 <Cale> gwern: yes
12:48:16 <vss> doh
12:48:19 <Cale> ivant: --make
12:48:20 <gwern> since BSDs aren't copyleft
12:48:38 <HunterXHunter> @go 100 aud in usd
12:48:39 <lambdabot> 100 Australian dollars = 91.46 U.S. dollars
12:48:42 <vss> cale: ok... how did you surf to that URL? asking hoogle for MonadError directs to the one that I posted
12:48:50 <HunterXHunter> @go 100 cad in usd
12:48:51 <lambdabot> 100 Canadian dollars = 98.8045 U.S. dollars
12:48:52 <shepheb> is the BSD3 license licensed under its own terms?
12:49:07 <ivant> Cale, thanks, that worked. Should I tell it to use some library if I don't want to use --make?
12:49:09 <Cale> vss: I went here in the documentation: http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error.html
12:49:11 <lambdabot> http://tinyurl.com/2cvgfn
12:49:11 <mauke> @karma+ >>=
12:49:11 <lambdabot> >>='s karma raised to 1.
12:49:19 <byorgey> gwern: this doesn't really explain the 'why' all that well, but http://hackage.haskell.org/trac/hackage/ticket/205
12:49:19 <lambdabot> Title: #205 (Remove BSD4 from Cabal.Distribution.License.License) - Hackage - Trac
12:49:20 <Cale> vss: and then I clicked on the source code link in the top right
12:49:21 <mrd> shepheb: if not, is the license of the BSD3 license itself licensed?
12:49:35 <Cale> ivant: yeah -package parallel
12:49:41 <Cale> ivant: (in this case)
12:49:53 <ivant> Cale, thanks a lot! I have completely forgotten that
12:51:28 <vss> cale: yeah, but my point is that Hoogle doesn't send me there... Now when I navigated to that page directly from the libraries documentation page, I can see all I need
12:51:36 <vss> cale: thanks
12:51:55 <gwern> 'I doubt any Haskell software actually uses the BSD4 license, and it is likely to confuse users as it looks like a newer version of BSD3. ' <-- oops?
12:51:58 <Cale> vss: That's something to take up with ndm :)
12:52:53 <vss> ok, thanks
12:53:04 <Cale> gwern: That's not a BSD4 license you have there
12:53:29 <Cale> gwern: http://www.netbsd.org/about/redistribution.html#default -- this is a BSD4 license
12:53:30 <lambdabot> Title: NetBSD Licensing and Redistribution
12:54:18 <Cale> Specifically, note the clause which requires advertising materials to display an acknowledgement
12:55:17 <phlpp> @go 400 Pesos in eur
12:55:18 <lambdabot> 400 Mexican pesos = 24.2286665 Euros
12:56:24 <gwern> dagnabbit. I hate these stupid errors with continued lines
12:56:41 <Cale> gwern: In fact, I don't see how that differs from a BSD3 license.
12:56:54 <roconnor> @go 1 CAD in USD
12:56:54 <lambdabot> 1 Canadian dollar = 0.988045 U.S. dollars
12:57:09 <Cale> :(
12:57:15 <mauke> @go 1 usd in eur
12:57:16 <lambdabot> 1 U.S. dollar = 0.640163882 Euros
12:57:22 <Cale> Come on Canadian dollar!
12:57:25 <mauke> omgwtf
12:57:27 <phlpp> @go 1 eur in usd
12:57:27 <lambdabot> 1 Euro = 1.5621 U.S. dollars
12:57:43 <phlpp> > 1/0.640163882
12:57:44 <lambdabot>  1.5620999998872165
12:58:04 <mauke> > 1/0.640163882 :: Rational
12:58:05 <lambdabot>  500000000%320081941
12:58:12 <phlpp> :>
12:58:38 <Cale> Of course, it's really irrational ;)
12:58:49 <phlpp> :>
12:59:00 <mauke> > approxRational (1/0.640163882) 0.001
12:59:01 <lambdabot>  25%16
12:59:34 <mauke> (%) `on` (^2)
12:59:43 <Cale> When I start my own country, our dollar will be defined to be sqrt(2) Canadian dollars.
13:01:57 <roconnor> Cale: will you print your bills on A7 paper?
13:02:07 <phlpp> Cale: let me know when your country is started :>
13:02:28 <Cale> roconnor: hehe, that would be perfect
13:03:10 <gwern> when I start my country, I'm going to base my currency on public key crypotgraphy; after I coin a few billion dollars signed by my private key, I'll destroy it.
13:03:19 <gwern> that way, inflation will be 0%. forever.
13:03:26 <Cale> gwern: good idea!
13:03:33 <roconnor> gwern: that's not the definition of inflation.
13:03:38 <gwern> or until my private key is brute-forced
13:04:02 <gwern> roconnor: well, at least there will be no currency based inflation. I can't do much about debts and that sort of inflation
13:04:35 <Cale> gwern: Sure you can. Prohibit the creation of any other forms of money.
13:04:48 <gwern> Cale: and cripple my nation's economy?
13:05:09 <roconnor> gwern: inflation is a measure of the purchasing power.  The purchasing power of your static currency would probably increase signifigantly as the world economy grows.
13:05:44 <Cale> roconnor: Why shouldn't prices simply fall?
13:06:09 <sclv>     Cannot match a monotype with `forall s. s'
13:06:11 <sclv> sigh.
13:06:21 <roconnor> Cale: You are asking as a matter of pollicy, if we should let prices fall?
13:06:26 <mrd> you'll have deflation as your currency gets scarce
13:07:00 <Cale> Let's suppose that we can track the money perfectly and so the amount of money circulating is held constant.
13:07:05 <sclv> haskell's type system is such a tease.
13:07:33 <gwern> what is wrong with a declaration like ' elit (LitChar 'ÿ'))]),'? ghci is complaining
13:08:17 <gwern> 'lexical error in string/character literal (UTF-8 decoding error)'
13:08:36 <Cale> Then if we get more productive, producing more apples say, the price of any individual apple should fall accordingly.
13:09:10 <gwern> (a '\ÿ' doesn't seem to help)
13:09:16 <Cale> Of course, we might have to chop our currency into finer and finer bits, but that's not a problem.
13:09:22 <quicksilver> gwern: your editor didn't save it in UTF8?
13:09:36 <mrd> Cale: of course, because it's Real money
13:10:04 <gwern> quicksilver: I dunno. I thought my entire system was good with utf8, but it was someone else's file
13:10:14 <gwern> how would I make sure it was saved utf8?
13:10:20 <roconnor> Cale: I don't think letting prices fall is so terrible.  I think the arugment is the the unpredictiability in the fluctuations in prices would be anoying.
13:10:25 * mrd wants a bank balance not finitely representable.  suck on that, financial wonks.
13:10:49 <gwern> on the other hand, inflation adds risk to holding currency
13:11:20 <gwern> hmmm... it displays fine in emacs, but if I look at the section in less, I see 'elit (LitChar '<FF>'))]),'
13:11:21 <roconnor> gwern: inflation itself doesn't add risk, it's unpredictiabily in value that adds risk.
13:11:49 <Cale> Well, inflation is essentially a tax which can be extracted from money holders by the people who print money.
13:11:50 <gwern> when has inflation ever been long-term predictable for fiat currency?
13:11:50 <roconnor> Cale: and that this unpredicability would add some friction to the economy.
13:12:15 <roconnor> gwern: since the early to mid 90's
13:12:40 <sethk> Cale, indeed.  When pressed about the evils of government, the only example WF Buckley came up with was inflating the currency
13:12:51 <ivan> gwern: every central bank seems to have a consistent target
13:12:53 <Cale> There's another very odd problem with the way that our money system works. Let's suppose that everyone was to want to pay off all their debts.
13:13:07 <sethk> gwern, actually, strangely enough, fiat currencies have a better record than backed currencies
13:13:10 <Cale> And nobody was going to go into debt until this process is complete.
13:13:25 <sethk> Cale, that's called a depression
13:13:42 <gwern> sethk: I find that hard to believe, given the hyperinflation records of fiat currency - china, germany, zimbabwe...
13:13:45 <Cale> Not only that, but it's impossible.
13:14:10 <sethk> Cale, well, sure, because as much as we talk about "printing money", very little of the currency actually exists
13:14:12 <gwern> (you know the early experiments in fiat currency in China blew themselves up because of inflation?)
13:14:19 <Cale> sethk: right
13:14:40 <roconnor> Cale: banks make profit by raking in some of the collateral that was put up.
13:14:43 <Cale> sethk: and all the interest payments have to come from the real printed money
13:14:50 <sethk> gwern, sure, there are lots of examples like that, but the aggregate data tells a different story
13:14:51 <roconnor> Cale: this is essentially their payment for the service they provide.
13:15:13 <sethk> Cale, well, maybe.  Mostly you increment a number in a database somewhere
13:15:20 <roconnor> Cale: so after everything is settled the banks will own some stuff, as they should.
13:15:52 <bringert> dons: care to join us in #haskell-hac4 ?
13:15:53 <Cale> Quite a lot of stuff!
13:15:56 <gwern> 'file' says "SourcePrelude.hs: ISO-8859 English text, with very long lines, with CRLF line terminators".... now how do I fix that I wonder
13:15:57 <roconnor> Cale: this stuff is distributed to the employees, shareholders, executives, etc.
13:16:05 <roconnor> Cale: and everyone is happy.
13:16:24 <mrd> tr -d '\r'
13:16:44 <roconnor> Cale: not so much stuff I don't think.
13:16:44 <Cale> Except for the people who had their houses taken away :)
13:16:48 <gwern> mrd: heh. I think the real problem for me here is the locale encoding here
13:16:49 <mrd> or C-x RET f unix
13:17:57 <roconnor> Cale: even those people will probably have quite a bit of equity left.
13:19:10 <roconnor> Cale: possibly even more equity than if they had to barter with gold. ... although that may be a question worth investigating in some detail.
13:19:34 * roconnor ponders
13:21:16 <hpaste>  ivant pasted "big GC overhead" at http://hpaste.org/6819
13:21:57 <ivant> guys, can you explain to me, why this program uses 90% of the time for GC?
13:22:26 <gwern> heh. so I added ';; -*- coding: utf-8 -*-' to the file, switched to lisp-mode, and saved
13:22:32 <gwern> take that, unicode-decode error!
13:23:15 <roconnor> Cale: but the short story is that our currency system isn't a crazy as the internet might lead you to believe.
13:23:17 <gnuvince> encodings--
13:23:40 <monochrom> when you deride encodings, you also deride ascii, an encoding.
13:23:54 <roconnor> Cale: but I didn't understand until one day a few of my friends sat me down and we went through a compleling mini example with banks and customers and widgets.
13:23:57 <mauke> perl -i -pe 'BEGIN { binmode STDIN, ":encoding(latin1)"; binmode STDIN, ":crlf"; binmode STDOUT, ":utf8"; }' SourcePrelude.hs
13:24:01 <gwern> monochrom: you should write a Unix koan based on that
13:24:22 <sclv> god you start playing with interesting type things a little and its so easy to wander off the highway into broken territory.
13:24:44 <monochrom> what is a koan?
13:25:04 <roconnor> Cale: the bank loaned out some money, the customers spend a year trading widgets, then of course there wasn't enough money for everyone to pay the bank back.
13:25:06 <Cale> roconnor: There's a strange assumption which I see made and I haven't quite understood why people make it -- that if inflation was too low, then there would be unemployment.
13:25:11 <cjb> monochrom: a parable, usually in Zen Buddhism.
13:25:12 <NekoIncardine> Oooh, a question I can answer before I start trying to figure out a component of a difficult problem! :o
13:25:15 <roconnor> Cale: so the bank raked in a few widgets too.
13:25:15 <gwern> https://secure.wikimedia.org/wikipedia/en/wiki/Hacker_koan <-- fun
13:25:29 <NekoIncardine> ... And while typing that, cjb beats me to it. A good example of one, though, is "What is the sound of one hand clapping?"
13:25:35 <roconnor> Cale: which seemed potentially fair for the service they provide.
13:25:36 <sieni> monochrom: it's a paradoxical puzzle that one has to solve
13:25:46 <monochrom> And why do you surf the wikipedia through encryption? :)
13:25:59 <sieni> monochrom: usually in zen buddhism as cjb said
13:26:12 <roconnor> Cale: yeah.  I don't know why that would be other than...
13:26:26 <roconnor> Cale: the fact that there is wages have a bit of psycology to them.
13:26:42 <roconnor> Cale: people don't like their wages being cut.
13:27:03 <roconnor> Cale: this is the only reason I can possibly imagine that Canada targets 2% inflation rather than 0% inflation.
13:27:12 <sethk> The real problem is the effects of loss of confidence in the banking system.
13:27:22 <ivant> 2%? unbelievable
13:27:30 <sethk> roconnor, actually, as constituted, a minimum amount of inflation is necessary
13:27:43 <sethk> roconnor, to compensate for the inertia in the system
13:27:44 <sieni> cjb: I wouldn't say that a koan is a parable
13:28:10 <roconnor> Cale: basically everyone gets a 2% wage defacto wage cut per year, and so if some needs to have their wage cut, their employer can simply not give them a wage increase without the embarassment of cutting their wages.
13:28:15 <Cale> ivant: I'll have a look
13:28:16 <cjb> sieni: it's the closest single-word I could find; I admit it's not a good comparison.
13:28:16 <gwern> 'One day, a novice was hacking on some code. "Cursed encodings!" he said "The world would be better rid of you" as he sweated over string conversion utilties. The master monochrom passing by overheard, and said - " when you deride encodings, you also deride ascii, an encoding.' and the novice was enlightened'
13:28:31 <roconnor> sethk: what is inertia?
13:28:45 <roconnor> sethk: Is it this wage thing I was talking about?
13:30:00 <sethk> roconnor, related, yes.  Inflation does allow people's salaries to lose value painlessly (at least psychologically painlessly), but the need for it is to compensate for the fact that the financial system can't respond instantly to changes.
13:30:10 <sieni> cjb: yes, I guess parables and koans are somewhat similar in some sense, but koans are not meant to be understood at an intellectuual level at all
13:30:15 <hpaste>  sclv pasted ""Cannot match a monotype"" at http://hpaste.org/6820
13:30:34 <roconnor> The governer of the bank of canada says that we may want to start considering lowering our inflation target, on the other hand, we should be wary of messing with success.
13:31:16 <cjb> sieni: Yup.  If I had to get from "I don't know what this word means" to "I have some idea which category of notion this word represents", though, I think parable gets farther down in the tree than anything else I can think of.  That's all.
13:31:19 <NekoIncardine> ... Why do I get the sense, looking at my snippets of concept-proving code, that I am looking at my problem entirely the wrong way?
13:31:20 <sclv> I should explain -- I really want a way to specialize the (forall s. s) to an arbitrary s
13:31:20 <roconnor> sethk: I agree that the financial system cannot respond instantly to changes, but I don't see what that has to do with an inflation target policy.
13:31:39 <Cale> sclv: It doesn't specialise like that
13:31:50 <Cale> sclv: The only value of type (forall s. s) is undefined
13:31:58 <sclv> Right, which is fine.
13:32:03 <sclv> As long as it can unify.
13:32:46 <sethk> roconnor, Because zero inflation has a negative impact on the willingness to take risks, because you can get burned more easily.
13:32:49 * NekoIncardine working on a Sudoku solver in Haskell, and is trying to figure out two things that should be all he needs to solve it. One is a couple different basic list manipulations, while the other may be more difficult.
13:32:51 <sclv> I actually want code that has an s where the forall is and where the r is, and it works like that, but the user has to provide some irritating type signatures where the s isn't fixed.
13:33:31 <sclv> So I tried using type equality coercions, with an s in one place, an r in the other, and an s ~r constraint, which works conceptually but doesn't work in 6.8.2 because of bugs.
13:33:46 <roconnor> sethk: that doesn't make any sense to me.  You can get burned just as easily with a 2% target or a 0% target, or a 10% for that matter.
13:34:06 <sethk> roconnor, I'm not explaining it well.  I'll see if I can find a reference.
13:34:06 * gwern does a happy dance. thih now worketh
13:34:07 <roconnor> ... or a 10% target for that matter.
13:34:08 <gwern> even if inflation was known in advance, adjusting for it'd be dead weight loss, I'd think
13:34:11 <gwern> http://ditz.rubyforge.org/ <-- this annoys me. what with pandoc for HTML output, this shouldn't be hard to write in haskell at all, and yet our only distributed bug tracker is the sucky distract
13:34:12 <lambdabot> Title: Ditz
13:34:20 <sclv> So now I'm trying to only allow validationfuncs for the time being that aren't dependent on s. but they need to be executed in arbitrary enviornments thare are dependent on s.
13:34:27 <Cale> NekoIncardine: what do you need to know?
13:35:13 <sclv> and the (fmap . fmap) toDyn code that works without the forall breaks with it because of the monomorphic pattern bindings restriction.
13:35:25 <NekoIncardine> Basically, I want to have one item of type "Board" that stands outside of recursive calls. This item (consisting of 81 tiles) would be manipulated by recursively-called "solve" functions... Let's see if I can wrap my head around the idea enough to explain it clearly.
13:35:27 <sclv> if any of that makes any sense.
13:36:00 <roconnor> @type fmap fmap fmap
13:36:02 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
13:36:13 <Cale> NekoIncardine: I'm not sure I understand what you mean by "stands outside of"
13:36:23 <NekoIncardine> There are 81 tiles on the Board. A Tile can consist of an Integer if it is solved, or an array of up to 9 integers if it is not - the 9 integers, of course, representing the possibilities valid for that tile.
13:36:33 <Cale> NekoIncardine: right.
13:37:01 <Cale> NekoIncardine: Or a Set.
13:37:13 <NekoIncardine> Valid, right now I have it written as an Array.
13:37:33 <Cale> and array of Bool?
13:37:35 <NekoIncardine> Basically, my method idea is something like this: Take a tile that hasn't been solved yet, but has only one possibility. (When the puzzle is input, this will be the default state for all tiles which are not blank.)
13:37:37 <Cale> an*
13:38:00 <NekoIncardine> An array of Booleans would also work, I'm just not sure precisely how to manipulate that yet. When I figure out the list manipulations more that should come to me.
13:38:16 <Cale> NekoIncardine: Lists and arrays are not the same thing
13:38:27 <Cale> (and Haskell has both)
13:38:40 <sclv> because of that darn restriction a functor with a polymorphic component is no longer a functor!
13:38:55 <Cale> sclv: hmm
13:38:58 <NekoIncardine> ... This is something that was not made clear to me when I went over this earlier. I'll have to figure that part out.
13:39:30 <sclv> i.e.  "Couldn't match expected type `forall s1. ValidationFunc s1 a b' against inferred type `f (f1 a1)'"
13:40:07 <NekoIncardine> Anyways, that tile is then switched from type Unsolved (the array) to type Solved (the integer) - that Integer is then REMOVED from the array or list for each unsolved tile that shares a row, column, or group with the solved tile. If THAT tile becomes or already solved in the process, then we go back to "Take a tile that hasn't been solved yet, but has only one possibility" and solve that...
13:40:09 <NekoIncardine> ...tile recursively.
13:40:13 <gwern> would a type checker for haskell be in Compilers/Interpreters or Language?
13:40:35 <sclv> so I need to collapse the polymorphism before I can fmap into it...
13:40:54 <NekoIncardine> Erm, "If THAT tile is reduced to or only has one possibility left in the process", since it odesn't automatically become Solved in datatype terms
13:40:55 <Heffalump> Language IMO
13:41:00 <Cale> sclv: uh, I successfully created a Functor from something which has an existential type
13:41:20 <gwern> 'k
13:42:17 <NekoIncardine> Once we're back out to the first call and have resolved it, we go on to the next (remaining) pre-input tile and solve for that one.
13:42:26 <sclv> hmm... let me try to distill this down.
13:42:51 <NekoIncardine> In theory, the end result if the puzzle can be solved by this basic logic, is 81 calls, recursive or base-case, each switching a tile from an unsolved list or array to a Solved integer.
13:43:57 <NekoIncardine> Once it has run out of base-cases to try, it outputs the result - possibly a solved puzzle, but no guarantees of course (since the logic isn't exactly robust).
13:44:43 <NekoIncardine> Does my premise make sense here?
13:45:25 <Cale> sclv: er, polymorphic type, I should say -- it's actually universal
13:45:50 <Cale> NekoIncardine: sure
13:46:18 <Cale> NekoIncardine: Of course, remember that the current board will be both a parameter to the recursive function and at least part of its result
13:47:16 <NekoIncardine> Yes... which is the challenge I have to work out, since otherwise I'd end up with, for example, two different resolutions to tile #2 (the Board is simply an Array of 81 tiles, so I can simply assign one number to each)
13:47:21 <Cale> sclv: specifically, I went with data List a = List (forall b. ((a -> b -> b) -> b -> b))
13:48:43 <NekoIncardine> Unless... I can just have the board after each one recursive call check if the tile currently marked 'unsolved' for the NEXT recursive call is solved in the output from said previous call.
13:49:21 <Cale> NekoIncardine: Well, think of it as iterating a function until no changes occur.
13:50:35 <NekoIncardine> Hrm... I'm not precisely sure what you mean by that. One question: How do I set the contents of an instance of an Array?
13:50:37 <Cale> NekoIncardine: You then just need a function which refines a board -- taking the known tiles and erasing those possibilities from that row, column, and box
13:50:43 <cubix> is there an equivalent to funcall in CL in haskell?
13:50:57 <Cale> cubix: Just call the function.
13:51:10 <Cale> cubix: There's no difference between function variables and other variables.
13:51:12 <NekoIncardine> Hrm....
13:51:25 <cubix> cale: hmm, ok, thanks
13:51:27 <mrd> cubix: there is ($) if you want an explicit operator
13:51:31 <NekoIncardine> Then it's time for me to start on this, one step at a time.
13:51:32 <mrd> @src ($)
13:51:32 <lambdabot> f $ x = f x
13:51:41 <Cale> NekoIncardine: does that make sense?
13:51:49 <NekoIncardine> I think so.
13:51:52 <mrd> sometimes that is useful, for example, map ($ 1) [(+1), (*2)]
13:51:57 <NekoIncardine> data Tile = Solved Integer | Unsolved (Array Integer Char)
13:51:58 <NekoIncardine> data Board = Array Integer Tile
13:52:11 <NekoIncardine> That's the basic data structure I am currently using, after some previous discussion here.
13:52:24 <cubix> mrd: ok.. I'll try that.. thx
13:52:24 <Cale> NekoIncardine: You probably want  data Board = Board (Array (Integer, Integer) Tile)
13:52:43 <Cale> NekoIncardine: Unless you really do want to index the positions on the board by plain Integers.
13:52:47 <hpaste>  sclv annotated ""Cannot match a monotype"" with "Simpler case" at http://hpaste.org/6820#a1
13:52:51 <mrd> cubix: but remember that "f $ x = f x", if you have f, and x, just do "f x"
13:52:53 <gwern> @hoogle Pretty
13:52:54 <lambdabot> No matches found
13:52:59 <NekoIncardine> Currently, I was working on the assumption of going by that route, yes Cale.
13:53:02 <gwern> @hoogle comma
13:53:02 <lambdabot> Text.ParserCombinators.Parsec.Token.comma :: TokenParser st -> CharParser st String
13:53:02 <lambdabot> Language.Haskell.TH.PprLib.comma :: Doc
13:53:02 <lambdabot> Text.ParserCombinators.Parsec.Token.commaSep :: TokenParser st -> CharParser st a -> CharParser st [a]
13:53:14 <gwern> @hoogle integer
13:53:14 <lambdabot> Text.ParserCombinators.Parsec.Token.integer :: TokenParser st -> CharParser st Integer
13:53:14 <lambdabot> Language.Haskell.TH.PprLib.integer :: Integer -> Doc
13:53:14 <lambdabot> Prelude.Integer :: data Integer
13:53:36 <Cale> NekoIncardine: Regardless, don't forget the data constructor :)
13:53:58 <NekoIncardine> I can do a Tuple-Integer method, yes, but it still means about as much complexity for finding the row, column, and group (modulo function vs. just using 'fst' and 'snd', and I still have to use a case function for group)
13:54:33 <Cale> NekoIncardine: You shouldn't really use fst and snd so often.
13:54:36 <NekoIncardine> data Board = Board (Array (Integer, Integer) Tile) <- So I define Board recursively, using itself then a tile?
13:54:39 <sclv> I think that case illustrates what I'm dealing with -- if I could force unification before the fmap I'd be happy.
13:54:44 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6821
13:54:46 <Cale> NekoIncardine: Tuples are almost always dealt with by pattern matching
13:54:50 <NekoIncardine> Erm, itself, then an array of tiles?
13:54:52 <gwern> @hoogle render
13:54:52 <lambdabot> No matches found
13:55:01 <Cale> NekoIncardine: No.
13:55:11 <gwern> shoot. when a module goes 'import Pretty' what is Pretty?
13:55:12 <Cale> NekoIncardine: The second "Board" is the name of the data constructor for your type
13:55:35 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6822
13:55:56 <__pao__> http://hpaste.org/6822
13:55:57 <Cale> NekoIncardine: It could also read 'Bd' or anything else really. It's unrelated to the first occurrence of Board on that line, as it's in a separate namespace.
13:56:07 <__pao__> Empty do construct
13:56:09 <NekoIncardine> Ah.
13:56:16 <__pao__> can anyone give a look to the paste?
13:56:21 <gwern> 'Could not find module `Pretty': it is a member of package ghc-6.8.2, which is hidden' <-- I don't really want to add ghc as a dependency
13:56:22 <NekoIncardine> So "data Board = Brd (Array (Integer, Integer) Tile)" would be functionally equivalent then?
13:56:27 <roconnor> sethk: ah, well
13:56:28 <NekoIncardine> That makes it make more sense.
13:56:50 <dainanaki> i'm trying to sort a list of files by their modification time, and this is the closest thing that I can come up with: 'sorter list = sortBy (mapM $ getModificationTime list) list'
13:57:19 <gwern> the readme mentions '    PPrint.hs
13:57:20 <gwern>       A pretty printing library, which builds on the pretty printing
13:57:21 <gwern>       library included in the standard Hugs distribution.
13:57:28 <dainanaki> anyone have advice on how to get this working while maintaining type [FilePath] -> [FilePath]
13:57:29 <dainanaki> ?
13:57:31 <Cale> sclv: Your problem is with $
13:57:32 <gwern> what is the equivalent library these days?
13:58:47 <Cale> sclv: err...
13:59:06 <NekoIncardine> Hrm... Okay, so rewritten:
13:59:08 <Cale> heh, this is an interesting error :)
13:59:11 <sclv> yeah, no. I just replaced the $ and .s with explicit parens and it still breaks.
13:59:17 <NekoIncardine> data Tile = Solved Integer | Unsolved (Array Integer Char) {- This is a comment! -}
13:59:19 <NekoIncardine> data Board = Board (Array Integer Tile)
13:59:50 <hpaste>  Cale annotated ""Cannot match a monotype"" with "hehe" at http://hpaste.org/6820#a2
14:00:17 <mrd> next time i get a ghc error, i will insert "hehe" into my code and see if that fixes it
14:00:19 <jrx_> dainanaki: in fact you can't. Redult of this operation depends on the state of the world, so without unsafePerformIO you won't do that
14:00:31 <Cale> Look at that type error!
14:00:36 <Cale>       Expected type: Foo (forall s1. s1) a
14:00:37 <Cale>       Inferred type: Foo (forall s1. s1) a
14:00:59 <sclv> zounds.
14:01:46 <Cale> sclv: Using $ and friends with higher rank polymorphism doesn't work.
14:01:48 <dainanaki> jrx_, if i put my code in the pastebin would you mind looking at it? I'm writing an ls clone to try and learn haskell better
14:01:59 <Cale> sclv: But I'm not sure exactly what's going on now :)
14:02:05 <sclv> hmmm...
14:02:23 <jrx_> dainanaki: of course, you're welcome
14:02:36 <Cale> sclv: Why use the type forall a. a ?
14:02:46 <s710b> @src hTell
14:02:47 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
14:02:52 <Cale> sclv: Why not () or data Void
14:02:54 <Cale> ?
14:03:16 <sclv> because it needs to unify with something else with a concrete type -- maybe I can't get away with that anyway.
14:03:48 <hpaste>  dainanaki pasted "opts.hs" at http://hpaste.org/6823
14:04:02 <idnar> Cale: that's starting to look like C++ compiler errors
14:04:03 <Cale> Foo (forall s. s) a  is not the same as  forall s. Foo s a
14:04:17 <hpaste>  dainanaki pasted "testProg.hs" at http://hpaste.org/6824
14:05:29 <dainanaki> jrx_, there you go
14:06:02 <Cale> aha!
14:06:03 <NekoIncardine> Okay... Now that I've defined Tile and Board, next I need to figure out a method for building a board from a defined input.
14:06:11 <Cale> I think I see the problem.
14:06:40 <Cale> hmm
14:06:51 <Cale> Let me think about this some more :)
14:07:01 * NekoIncardine opens Hpaste.org, now noticing that it is there o_o
14:09:09 <NekoIncardine> Hrm... At least in principle, I take a list of 81 or 89 ( '/n' included) characters. I then put the first character into the Board, then recursively call the inputting method on the tail of the list.
14:09:56 <Cale> okay, there's certainly something bizarre going on :)
14:10:03 <NekoIncardine> Hrm... The method would need two inputs, though - the Board and the LIst. And I have to figure out how to 'save' the board for the next use.
14:10:27 <jrx_> dainanaki: pretty long enum ;), what are your problems with this code?
14:10:38 <NekoIncardine> ... I realized I haven't seen anything about how to make multi-input functions yet. X_x;
14:10:52 <hpaste>  Cale annotated ""Cannot match a monotype"" with "pwned" at http://hpaste.org/6820#a3
14:11:22 <Cale> NekoIncardine: you just list the multiple parameters
14:11:31 <dons> "Conventional programming languages use abstractions like shared memory and
14:11:32 <Cale> f x y = sqrt (x^2 + y^2)
14:11:32 <dons> transaction consistency that violate the laws of physics."
14:11:45 <Cale> dons: wtf?
14:12:12 <dons> " Normally this
14:12:12 <dons> doesn't matter, but in the presence of errors, it is impossible to write
14:12:12 <dons> correct software based on such abstractions.
14:12:13 <dons> Erlang uses no such assumptions."
14:12:20 <Cale> dons: check out my hpaste there, btw :)
14:12:27 <NekoIncardine> makeBoard :: Board [Integer] <- Like that?
14:12:40 <vegai> Cale: I think there are couple more places where hardcoded "@" is used, btw
14:12:43 <Cale> dons: Does that look like a typechecker bug to you :)
14:12:43 <NekoIncardine> If I want one item of type Board and a list of Integers, that is?
14:12:47 <dons> hmm...
14:12:54 <vegai> in lambdabot. But I'm too tired to check them all out for you now, hopefully later
14:12:54 <bogner> is Graphics.X11.Xlib.Window a type synonym? how can i find out such things?
14:13:14 <Cale> NekoIncardine: Board -> Integer -> something
14:13:16 <dons> bogner: its a synonym , yeah.  check the haddock definitions
14:13:30 <Cale> er
14:13:34 <dons> Cale, that looks weird.
14:13:35 <Cale> NekoIncardine: Board -> [Integer] -> something
14:13:42 <Cale> dons: yeah :)
14:13:57 <dons>       Expected type: Foo (forall s1. s1) Integer
14:13:58 <dons>       Inferred type: Foo (forall s1. s1) Integer
14:14:07 <dons> yeah, bug i'd say
14:14:11 <NekoIncardine> Ah. So makeBoard :: Board -> [Integer] if I want to take the Board and [Integer] list as inputs? Do I need to specify the format for output in this line of the method?
14:14:15 <Cale> dons: also note how applying foo2 to something of the very same type doesn't fail
14:14:17 <dons> some case not handled quite right
14:14:19 <dainanaki> jrx_: well, i'm trying to keep all of the command line args of the type [FilePath] -> [FilePath] so that I can translate the arguments into an ArgType list and then do a foldl across it giving it the specified directory and a function that will return the appropriate function for each argument. That way it'll compose the returned functions.
14:14:26 <dons> yeah
14:14:42 <dainanaki> At least that's the idea, it may not work out like I hoped.
14:14:51 * NekoIncardine replaces "Integer" with "Char", though x_x
14:15:15 <idnar> dons: what the heck is that? (re: violating the laws of physics)
14:15:24 <NekoIncardine> Now, to find out if I have this idea right.
14:16:09 <sclv> haha zow
14:16:37 <dons> idnar: oh, just a funny intro to erlang, to motivate message passing
14:16:41 <dons> rather than shared staet
14:17:00 <Cale> I don't see what Erlang people have against transactional memory though.
14:17:20 <ddarius> "Message Passing: Because We Are Not Communists"
14:17:24 <mrd> it's shared memory
14:17:31 <dons> well, its a threat -- shared memory that works
14:17:36 <Cale> mrd: Yes, but without any of the problems of shared memory.
14:17:43 <dons> and all our machines are shared memory multicores
14:17:45 <mrd> well it does have one, and it's a doozie
14:17:57 <Cale> mrd: What's that?
14:17:59 <mrd> distributed memory isn't really around much
14:18:30 <Cale> huh?
14:18:40 <mrd> i think message passing is still the best for distributed computing
14:18:45 <dons> erlang's not so compelling on a shared memory machine
14:18:48 <Philippa> Cale: I suspect transactions are the wrong default for many of their tasks
14:19:06 <dons> anyway, you need a suite of options for concurrency
14:19:26 <Cale> I think message passing will actually have many of the problems of shared memory, but on a larger scale.
14:19:34 <dons> is the erlang runtime smp capable now?
14:19:38 <Cale> Basically, processes act like memory cells.
14:19:56 <Philippa> dons: has been for some time, I believe
14:20:12 <mrd> yeah i can imagine some problems with message passing
14:20:25 <Cale> You eliminate the finest grained problems with shared memory, but you re-encounter them on a larger scale.
14:20:28 <mrd> like if one process is waiting for a message from another process which is waiting for a message from that first process
14:20:36 <dons> you need the -smp flag, which can be compiled into newer erlangs
14:20:36 <Cale> yeah
14:20:53 <mrd> there are some formalisms for message passing though
14:20:56 <Cale> Or, for instance, you can have the bank-account problem.
14:21:08 <hpaste>  NekoIncardine pasted "makeBoard premise" at http://hpaste.org/6825
14:21:15 <Philippa> Cale: not having transactions at the finest grain can be a good thing though
14:21:38 <Philippa> at the larger scale, you can use transactions again or another solution - but you're at a level where you can pick the right solution out of the library
14:21:38 <Cale> But it spoils compositionality.
14:21:39 <NekoIncardine> I get a sense that there's no way this code bit will ever work, but I'd like to see if I have the right idea at least.
14:21:58 <Philippa> sometimes compositionality everywhere is a bad idea
14:21:59 <jrx_> dainanaki: I think you shoud make some separation
14:22:00 <vegai> even though dons disagrees, I still think erlang has transactional memory
14:22:16 <ddarius> Both transactions and message passing are highly successful, non-mutually exclusive methods for dealing with concurrency.
14:22:21 <Cale> Philippa: how so?
14:22:23 <vegai> called mnesia
14:22:25 <jrx_> dainanaki: between command line arguments that change program behaviour
14:22:26 <Philippa> especially compositionality relying on the same form of composition
14:22:31 <dons> vegai: only if you use your data base for control flow.
14:22:31 <Philippa> Cale: when it forces you to do stupid things
14:22:35 <dons> or structuring threds
14:22:40 <jrx_> dainanaki: and input data, like directory names
14:22:49 <dons> databases use transactions, but that doesn't mean they're the same as transactional memory
14:22:53 <Cale> Philippa: But you're already forced to do stupid things because you don't have this compositionality.
14:23:05 <Philippa> different classes of stupidity
14:23:18 <vegai> dons: I don't see the difference :-/
14:23:46 <dainanaki> jrx_: will do, thanks
14:23:51 <Philippa> all else being even, getting to pick which way you risk being stupid is an improvement
14:23:52 <dons> the grain is different. databases aren't used for control flow
14:23:55 <Cale> Philippa: Like creating processes which do nothing except manage other processes and (hopefully) maintain all the communication between that set of processes and the outside world.
14:23:59 <dons> they're not a concurrency structuring mechanism
14:24:10 <dons> you don't say, multiplex file descriptors with a database
14:24:15 <dons> while you do with STM.
14:24:31 <dons> meanwhile, you would implement your database on top of the  STM primitives
14:24:32 <Philippa> Cale: given that that also has consequences for reliability ("let it crash"), I'm not so convinced that's stupid
14:24:37 <Cale> and if you need to do it again in a different way, you're out of luck
14:24:54 <Philippa> hell, I've wilfully built that design
14:24:58 <dons> its a specific, limited use of transactions, versus ubiquitous, generic support for transactions, vegai
14:25:09 <jrx_> dainanaki: you can do it with your existing code, by e.g. filtering the list of ArgVals in search for ArgDirs
14:25:11 <Philippa> (FCVO "outside world")
14:26:02 <dons> Philippa: yeah, looks like -smp was supported since around late 2006
14:26:17 <jrx_> dainanaki: and later operate on [FilePath], if you want to make any actions depending on external environment, they must be held in IO monad
14:26:18 <Cale> One thing I can see being useful would be a way to temporarily isolate some set of processes while a bunch of communication happens.
14:26:40 <gwern> hm. ndm uploaded yhccore to hackage. didn't know it could work with ghc
14:26:41 <Philippa> yep, and if you've got a proxy sitting on their pipes that's easily done
14:26:58 <gwern> dons: if you care, I've uploaded Typing Haskell in Haskell to Hackage
14:27:07 <Cale> (that is, an arbitrary set)
14:27:10 <vegai> dons: ah, thanks for the example (multiplexing file descriptors)
14:27:35 <dons> ah ok
14:27:38 <gwern> @seen lispy
14:27:38 <lambdabot> I saw lispy leaving ##logic, #haskell-blah, #darcs, #ghc and #haskell 8h 3s ago, and .
14:28:11 <Cale> But even then, it seems like you'd need to know which processes those processes you want to isolate will need to communicate with.
14:29:41 <gwern> ACTION is envious of ditz. why don't we have such a tool? I want it in haskell! 'Ditz is a simple, light-weight distributed issue tracker designed to work with distributed version control systems like darcs and git. Ditz maintains an issue database file on disk, written in a line-based and human-editable format. This file is kept under version control, alongside project code. Changes in issue state is handled by version control like code change: included a
14:29:59 <thoughtpolice> gwern: i tried it yesterday, i honestly like it a lot :)
14:30:00 <dainanaki> jrk_: thanks for the help
14:30:04 <dons> we had the first lightweight distrivbuted bug tracker, gwern
14:30:06 <dons> distract.
14:30:18 <gwern> distract was impossible to use though
14:30:22 <Heffalump> integrating with a VCS like that is perfect though
14:30:26 <dbpatterson> sclv: you here?
14:30:32 <sclv> yep
14:30:35 <Heffalump> and you could imagine adding it as a patch type to darcs to do even better
14:31:06 <gwern> Heffalump: a patch type? you mean like how the 'mv'/'rm' ones differ from deletions/insertions?
14:31:08 <dbpatterson> sclv: easy way to match against / with hvac?
14:31:21 <Heffalump> gwern: right
14:31:26 <sclv> that should be the default
14:31:36 <dbpatterson> no.. 404 should be default, no?
14:31:43 <thoughtpolice> i like the way ditz does it; it integrates with your VCS nicely since it's just a YAML file, it is flexible, pretty intuitive and has most of what you would need for a issue tracker.
14:31:56 <monochrom> Hmm, distract, derail, sabotage... these sound like fun names for projects. :)
14:32:04 <NekoIncardine> http://hpaste.org/6825 <- Having made a premise for code for making a Board... I need to figure out if I'm on the right track or not.
14:32:06 <thoughtpolice> i played around a bunch yesterday with it and I was really impressed. :)
14:32:07 <gwern> YAML? how convenient, I helped add some YAML packages to hackage...
14:32:17 <sclv> hmm... i see.
14:32:38 * monochrom goes invent a new programming language and tool chain.  compiler is called distract.  runtime is called derail.  installer is called sabotage.
14:32:39 <gwern> thoughtpolice: but it doesn't look very sophisticated at all; it looks like you could do the same exact thing with people editing a normal text file
14:32:53 <thoughtpolice> gwern: yeah, I assume yaml was chosen so merge issues within the bugs file wouldn't be insane
14:32:54 <gwern> monochrom: no 'extinguish'?
14:33:00 <sclv> you want to match / and nothing else.
14:33:04 <dbpatterson> sclv: happs solves this in a really ugly way - matching GET or POST only match a url that is empty - but perhaps the best way is to have a terminate combinator?
14:33:09 <dbpatterson> yes... for the index page...
14:33:13 <monochrom> Perhaps you can make that the debugger :)
14:33:17 <thoughtpolice> gwern: you're probably right, all ditz does is create a 'bugs.yaml' file in the directory you initialize it in and ditz just works on that
14:33:25 <Tobsan> &win 27
14:33:26 <dbpatterson> idea of terminator is h t would match just index
14:33:27 <Tobsan> oops
14:33:42 <dbpatterson> whereas h *> renderf ... would match anything...
14:33:55 <dbpatterson> it would allow the happs behavior
14:33:57 * gwern emerges rubygems to play with ditz
14:34:05 <NekoIncardine> And of course a problem comes up immediately as I learn that if statements use an entirely different format than I expected.
14:34:11 <gwern> also, if I'm going to re-implement it, I need a clever name
14:34:17 <dbpatterson> h |// "GET" t, but wouldnt limit you to it...
14:34:20 <dons> > if True then 1 else 2 -- ?
14:34:24 <lambdabot>  1
14:34:32 <dbpatterson> (oh, and t is probably a terrible name for it, if you even like the idea..)
14:34:39 <dons> > let x | True = 1 | otherwise = 2       in x
14:34:39 <lambdabot>  1
14:34:57 <ddarius> dons: Which, unforgiveably, is not C syntax.
14:35:02 <Cale> NekoIncardine: if *expressions*
14:35:11 <Cale> if foo
14:35:11 <dons> ddarius: ah
14:35:13 <Cale>    then bar
14:35:16 <Cale>    else quux
14:35:23 <thoughtpolice> gwern: it is quite simplistic under the hood I would think, but it is a good way to address the issue and has a good amount of functionality.
14:35:27 <dons> yeah,its like C's ternary operator, NekoIncardine
14:35:34 <thoughtpolice> gwern: i was happy, at least.
14:35:35 <dons> not like the if statement in C
14:35:36 <dbpatterson> sclv: maybe |x ?
14:35:45 <Cale> The 'then' and 'else' are part of the 'if', and at the same level, so they should be indented the same, and more than the 'if'
14:36:01 <gwern> thoughtpolice: it commits the unforgivable sin of being in not-haskell
14:36:05 <Cale> This is not always required, but should be :)
14:36:06 <ddarius> NekoIncardine: What are you expecting x:Unsolved ('1':[]) to do in that code?
14:36:15 <ddarius> (also, '1':[] is just "1"
14:36:17 <ddarius> )
14:36:30 <sclv> you can probably do this by having (h ||\\ \404edPage -> foo) <|> (h *> indexStuff)
14:36:39 <NekoIncardine> Cale: So if (LINES) then (MORE LINES) else (STILL MORE LINES) is a way to think of it then?
14:36:46 <thoughtpolice> gwern: haha. :) on a related note I was thinking of writing something in ruby and maybe using ditz to do the issue tracking. i will probably be taken care of by FP ninjas shortly.
14:37:03 <sclv> i.e. if you match on a page and its not there, then it gives a 404, if you fail to match on any page (i.e. an empty path) then you return the index.
14:37:11 <NekoIncardine> ddarius: x:Unsolved('1':[]) is supposed to add a Tile to Board 'x', whose contents are Unsolved with a single-char array inside.
14:37:16 <Cale> NekoIncardine: Uh, I suppose, yeah :)
14:37:19 <ddarius> thoughtpolice: You've already been taken care of, you just haven't noticed yet.
14:37:29 <Cale> NekoIncardine: if <expr1> then <expr2> else <expr3>
14:37:41 <NekoIncardine> All right... That part makes sense and now appears to run correctly in WinHugs now.
14:37:49 <Cale> NekoIncardine: The 'else' part is not optional, since the expression must have a value in all cases.
14:37:56 <dbpatterson> sclv: okay, that will work... it still is sort of ugly to have random trailing url bits that are ignored... but thanks...
14:38:12 <NekoIncardine> Hrm... So I do need to specify an output too then. I'll fix that in a sec.
14:38:23 <sclv> it won't ignore the bits though -- if you return a 404 when it hits anything.
14:38:27 <NekoIncardine> I also need a case for the EOF character.
14:38:30 <Cale> map (\x -> if x >= 0 then 1 else -1) [-10..10]
14:38:31 <thoughtpolice> ddarius: lazy; they probably haven't needed the result of my taking care of yet.
14:38:32 <Cale> > map (\x -> if x >= 0 then 1 else -1) [-10..10]
14:38:33 <lambdabot>  [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,1,1,1,1,1,1]
14:38:55 <idnar> thoughtpolice: have you looked at Redmine?
14:39:02 <sclv> you can write a 404 page that returns the whole requestURI
14:39:14 <dbpatterson> sclv: oh I meant on valid matches
14:39:22 <dons> for those interested in mentoring/participating in the SoC haskell project round, your last chance to nominate as a mentor is the next day or so
14:39:26 <dons> sign up http://code.google.com/soc/2008/mentor_home.html
14:39:27 <thoughtpolice> idnar: nope. link? :)
14:39:27 <dbpatterson> like, I have url h |/ "page"
14:39:27 <lambdabot> Title: Google Code - Summer of Code - Edit Profile
14:39:28 <hpaste>  NekoIncardine pasted "Slightly updated makeBoard" at http://hpaste.org/6827
14:39:37 <dbpatterson> it will match "/page/foo" wont it?
14:39:45 <dbpatterson> so long as there isnt another handler to match foo...
14:39:46 <dons> Cale, ddarius ...
14:39:51 <dons> sclv: you too!
14:39:53 <dbpatterson> or a 404 on every url...
14:40:13 <ddarius> dons: Thanks
14:40:26 <Cale> NekoIncardine: You're writing lists of characters the hard way.
14:40:33 * NekoIncardine has a doctor's appointment in ~ one hour, so I want to figure this first bit out before then. Then after that he returns to start working on each remaining piece.
14:40:33 <idnar> thoughtpolice: http://weblogs.mozillazine.org/roadmap/archives/2008/04/popularity.html
14:40:35 <lambdabot> Title: Brendan's Roadmap Updates: Popularity, http://tinyurl.com/6k68ea
14:40:36 <idnar> uhhhh
14:40:41 <idnar> thoughtpolice: sorry, http://www.redmine.org/
14:40:42 <dbpatterson> ie, I would need to put in a h |\\ \404edpage -> foo underneath every single |/ "bar" match, wouldnt I?
14:40:42 <lambdabot> Title: Redmine - Overview - Redmine
14:40:46 <sclv> hmm.. yeah, i tried to make hvac not opinionated, but i guess my low opinion of 404 pages slipped through...
14:40:54 <dbpatterson> sclv: :)
14:40:54 <Cale> > '1':'2':[]
14:40:55 <lambdabot>  "12"
14:41:07 <Cale> NekoIncardine: You can use double quotes too :)
14:41:11 <NekoIncardine> Ah.
14:41:21 <NekoIncardine> Double quote = easy modo list then?
14:41:30 <dbpatterson> sclv: I havent looked too much, but would creating a combinator that only matches an empty path be difficult (if not I'll give it a shot)..
14:41:30 <Cale> NekoIncardine: Strings are lists of characters
14:41:37 <NekoIncardine> That makes sense.
14:41:39 <Cale> :t "Hello"
14:41:40 <lambdabot> [Char]
14:41:42 <dbpatterson> havent looked at your code*
14:41:46 <thoughtpolice> idnar: ooh, looks interesting. :)
14:41:47 <dons> ddarius, Cale, remember there's a free tshirt involved
14:41:59 <Cale> > "Hello" == 'H':'e':'l':'l':'o':[]
14:42:00 <lambdabot>  True
14:42:02 <NekoIncardine> At this point it doesn't matter, but I can keep that in mind for the future at least.
14:42:04 <dbpatterson> that would kind of kill all these problems at once...
14:42:12 <ddarius> dons: Yeah, I'd heard of that...
14:42:19 <Cale> dons: Heh, maybe I should sign up and then not actually apply for any projects :)
14:42:38 <dons> Cale, that's right. you can just help vote and direct students, without mentoring actual summer projects
14:42:44 <sclv> dbpatterson: yeah, it would be trivial. not sure what to name it though.
14:42:48 <dons> help decide what projects to fund
14:42:56 <NekoIncardine> Hrm...
14:42:56 <Cale> dons: The other time, I signed up and did nothing, and still got the shirt :)
14:43:04 <dons> right :)
14:43:20 <dbpatterson> sclv: |x is my first nomination... but of course there might be a better name for it...
14:43:35 <vincenz> Cale: tshirt
14:43:36 <vincenz> ?
14:43:36 <dbpatterson> the idea being that this is the end of the line... and that all your combinators start with |
14:43:42 <Cale> vincenz: yeah
14:43:44 * NekoIncardine ponders doing a Summer of Code project instead of an Internship. Wonders what sort of work he might implement... Once I have understanding of Haskell better from this project, maybe I'll want to give it a more serious go for a real project O_o
14:43:45 <vincenz> donde?
14:43:54 <sclv> that doesn't work -- combinators can only be symbols, not alphanums.
14:44:00 <sclv> |. maybe.
14:44:00 <dbpatterson> oh hmm...
14:44:07 <dbpatterson> |. wouldnt be bad at all
14:44:19 <NekoIncardine> Anyways... Do I have the right idea on how to add items to the Board 'x'?
14:44:33 * monochrom considers |×
14:44:34 <NekoIncardine> And then make a recursive call with that modified board?
14:45:01 <gwern> thoughtpolice: the FP ninjas have already slain you; it's just that the evaluation of the slaying hasn't been forced yet
14:45:13 <Twey> Ahahahaha
14:45:19 <Twey> <3
14:45:25 <monochrom> Also garbage collection hasn't kicked in.
14:46:25 * monochrom experiments using Java finalizers to do lazy evaluation.
14:47:37 <sclv> dbpatterson, while you're here, what do you think of this: http://hpaste.org/6828
14:47:59 <sclv> the plus side: validation returns any value, not just strings, heterogeneously.
14:48:13 <sclv> the down side, for now, you need explicit type signatures.
14:48:26 <NekoIncardine> "x:Unsolved('1':[])" <- Am I correct in thinking this will take X and add a new item to the end of it, thus modifying x for when I call it in the next
14:48:30 <NekoIncardine> line?
14:48:39 <tromp> :t chr
14:48:40 <sclv> also to just validate one thing you'd need a wrapper like Box ("contents", lengthAtLeast 3 :: ValidationFunc Sess String String) )
14:48:40 <lambdabot> Int -> Char
14:48:46 <tromp> :t ord
14:48:46 <lambdabot> Char -> Int
14:48:53 <tromp> > map ord "Hello"
14:48:54 <lambdabot>  [72,101,108,108,111]
14:49:07 <tromp> > map ord "hello"
14:49:08 <lambdabot>  [104,101,108,108,111]
14:49:16 <sclv> anyone here running a recent HEAD of ghc by the way?
14:49:35 <Heffalump> how recent?
14:49:44 <dbpatterson> sclv: it is sort of long, but if it allows things to be typed that is good... hmm, but I thought things were typed already based on the way they were used in the lamda function? is that not the case?
14:49:46 <Heffalump> I've got 20080316 and 20080323 installed
14:49:57 * NekoIncardine wait. o_o
14:50:19 <sclv> this is for validation only -- currently it takes a list of ValidationFunc s String String, and returns a list of strings.
14:50:59 <sclv> the rewrite lets you use heterogenious tuples, but my type-hacking skills aren't up to the task of eliminating the type signatures, although I suspect that eventually ghc will let me write it the way I want.
14:51:00 <dbpatterson> yeah, I understood that, I guess I had just assumed (woops) that it was figured out based on the types of the function you pass to actually use the params...
14:51:14 <tromp> > map chr . scanl (+) 104 [-3,7,0,3]
14:51:14 <lambdabot>   add an instance declaration for (Num (f Int))
14:51:25 <monochrom> http://www.poromenos.org/node/89  more on hello world
14:51:25 <tromp> > map chr . scanl (+) 104 $ [-3,7,0,3]
14:51:26 <lambdabot>  "hello"
14:51:26 <dons> tromp: do it! lambdabot said so
14:51:27 <lambdabot> Title: Printing "Hello world!" using curve fitting techniques (or: The "Hello world!" f ...
14:51:28 <oToom> > sum[1..999],
14:51:29 <lambdabot>  Parse error at end of input
14:51:33 <oToom> > sum[1..999],
14:51:33 <lambdabot>  Parse error at end of input
14:51:35 <oToom> > sum[1..999]
14:51:36 <lambdabot>  499500
14:51:49 <oToom> > sum 9*4
14:51:49 <lambdabot>   add an instance declaration for (Num [a])
14:51:49 <dons> i wonder how many people do try to add an instance for Num (f X)
14:51:56 <sclv> dbpatterson: well, it would be pretty trivial to let it take a list of ValidationFunc s String anything and return a list of anything, but that still wouldn't help if you wanted an Int, a String, and, erm, I dunno, a Float or something.
14:52:10 <oToom> > 9*6
14:52:11 <tromp> adding a $ is generally easier:)
14:52:11 <lambdabot>  54
14:52:35 <dbpatterson> sclv: it could of course be made cleaner when you have other validation functions that are typed already (ie, typeIsInt for example), right?
14:52:36 <NekoIncardine> http://hpaste.org/6827 <- Hrm... getting an error on line 17, whose meaning I am not fathoming but which I think means I'm failing to write expressions properly.
14:52:49 <tromp> > chr 42
14:52:50 <lambdabot>  '*'
14:53:32 <sclv> unfortunately, no. its the sessions that are killing me.
14:53:54 <sclv> the validation functions are typed by session as well as input and output.
14:54:00 <tromp> funny that the answer to the ultimate question of ... everything is the code of *
14:54:03 <NekoIncardine> " 	makeBoard x:Unsolved ('1':[]):Board (tail y) " is my idea on how to fix this (in the first if statement), but it doesn't seem to fix the glitch there either.
14:54:27 <sclv> so if you write a custom one to deal with one session type, then it would work, but one that's polymorphic over session types needs you to manually refine its type.
14:54:27 <NekoIncardine> Tromp: When was ASCII defined, dare I ask?
14:54:53 <tromp> wikipedia should know
14:54:59 <dbpatterson> sclv: how do the session types vary?
14:55:03 <monochrom> In the 70's. Yeah, wikipedia.
14:55:37 <tromp> but adams didn't pick 42 for that reason:)
14:55:50 <opqdonut> :D
14:55:58 <sclv> if I had the chops, I could probably force the validators to never talk to sessions and somehow make it work, but I don't seem to be able to get everything to work out right...
14:57:20 <sclv> the session is strongly typed and can be anything you want as long as it can be treated as an SEType for HStringTemplate -- the easiest way is to derive Typeable and Data, as in the top of common.hs
14:57:20 <dbpatterson> sclv: hmm, well is there any concrete (as apposed to theoretical, of which it is obvious) reason why you couldnt have a validator guarantee the type and continue if it doesnt match?
14:58:04 <sclv> not sure what you mean?
14:58:06 <dbpatterson> sclv: but there is no way to just deal with everything as SEType and forget the specifics in the validators?
14:58:52 <sclv> its a problem with type unification -- the whole monad is parameterized over the session, and since validators are the monad transformed with ErrorT, then they are too.
14:59:40 <dbpatterson> sclv: ie, validInteger is  (read string) :: Integer with exception handling
15:00:05 <sclv> hmmm... I think for now I'll have both versions (withValidation and withValidation') and try to get it right for the second later.
15:00:32 <sclv> dbpatterson: see readValidated. it does that.
15:00:46 <oToom> Cya all.
15:00:50 * dbpatterson needs to read more of the code
15:01:09 <sclv> you just have to show it to a string again before you return it from a set of validators at this point.
15:01:50 <sclv> and then read it again later, which is fine, and you know is safe already -- its just nice to avoid that extra work and have the type system prove that its safe.
15:01:50 <dbpatterson> sclv: and with withValidation' it can leave you with the type as it is...
15:02:33 <dbpatterson> aside from a little line noise, withValidation' is good... and especially at pre-0.2 it cannot be complained about :)
15:17:25 <dons> Igloo: what do you think about warning when numeric types are be defaulted to Int ?
15:17:56 * NekoIncardine leaves for now. I'll be back significantly later tonight to continue trying to figure all of this out. X_x;
15:18:13 <NekoIncardine> Farewell, and thanks to all of you. :)
15:19:15 <dons> Igloo: how could we preven this scenario, http://article.gmane.org/gmane.comp.lang.haskell.cafe/38380
15:19:16 <lambdabot> Title: Gmane -- Mail To News And Back Again
15:20:12 <Igloo> dons: If you use -Wall then all type defaults are warned about
15:20:30 <Igloo> I think H' ought to remove defaulting; that would nicely fix the problem
15:20:55 <ddarius> Removing defaulting wouldn't be a bad idea in lieu of a better approach.
15:21:18 <Igloo> dons: That thread isn't about defaulting, though, it's just plain old type inference
15:21:27 <dons> Igloo: right.
15:21:53 <dons> so the situation where you've a large amount of Num polymorphism, constrained only by the an odd Int function here or there
15:22:05 <dons> maybe just warning about the length, take, drop functions?
15:22:17 <Igloo> dons: I don't see how you'd warn about that except in a very ad-hoc way
15:22:20 <hpaste>  igel pasted "Quicksort" at http://hpaste.org/6829
15:22:22 <ddarius> "Warning: You are using the length function"
15:22:26 <dons> :)
15:22:36 <Igloo> dons: Also, I don't think anyone would enable that warning
15:22:39 <gwern> just lobby the haskell' people to make the prelude all Integer :)
15:22:51 <gwern> you'll win in the long run! bwa ha ha
15:22:51 <dons> can we turn off defaulting ?
15:22:54 <dons> default() -- ?
15:23:06 <mauke> length __attribute__((__warning__, "You are using the length function!")) :: [a] -> Int
15:23:21 <ddarius> dons: Yes
15:23:43 <ddarius> Actually, just having the default default be () might be satisfactory.
15:23:44 <dons> but the normal inference is the problem here
15:24:26 <Igloo> Yes; I'm not really sure exactly what it is you are asking for
15:24:46 <dons> well, i don't know how we'd warn about this problem area
15:24:52 <dons> so was asking for ideas :)
15:25:28 <dons> "accidental" Int constraints breaking code
15:25:51 <dons> type inference considered dangerous
15:26:22 <ddarius> dons: "Warning: You are lacking top-level type signatures."
15:26:27 <dons> Cale, this guy looks sincere, and needs your help, http://reddit.com/info/6emth/comments (the submitter, who talks in comments)
15:26:51 <dons> ddarius: main = print (take (length [1..]) [1..]
15:27:09 <dons> or, actually,  main = print (take (last [1..]) [1..]
15:27:29 <dons> i guess in real programs you do use top level type annotations
15:27:35 <dons> so this is a rare problem ?
15:29:29 <OscarZ> hi
15:29:39 <ddarius> dons: If you are "relying" on unbounded Integers, I'd suspect you'd annotate a type to that effect -somewhere-.
15:29:58 <dons> yeah, that's plausible
15:30:13 <dons> so this case was subtle, since [1..] "looks" infinite
15:30:24 <OscarZ> anyone got into haskell through GED by Douglas Hofstadter?
15:30:34 <OscarZ> GEB sorry
15:30:42 <OscarZ> Gdel, Escher, Bach that is
15:31:05 <dbpatterson> OscarZ: didnt he write that in the 70s?
15:31:28 <OscarZ> yeah
15:31:41 <OscarZ> 79 i think
15:32:08 <dbpatterson> wasnt haskell not created for another decade after that?
15:32:14 <idnar> I got into mathematics with GEB; does that count?
15:32:21 <OscarZ> yeah
15:32:26 <dons> GEB does inspire some haskellers
15:32:35 <idnar> most of what I know about basic number theory is from reading GEB :P
15:32:40 * ddarius didn't find GEB at all inspiring in any respect.
15:32:49 <OscarZ> that inspires me.. why is that ?
15:33:01 <OscarZ> ddarius: how come ?
15:33:48 <ddarius> OscarZ: Why should it have?  It just didn't have anything in it that inspired me in any way.
15:34:23 <dons> friendly time, ddarius :)
15:35:03 <gwern> it was a good book; made me look into lisps which made me look into haskell :)
15:35:09 <ddarius> dons: It's just not a question that can be answered.
15:35:20 <dons> i agree. tone is important to watch, though
15:35:45 <idnar> I don't think I'd say it "inspired" me at all; but I certainly found it to be both enjoyable and informative (well, for me, at the time)
15:36:03 <Botje> from now on, write all your IRC lines in the Mood monad
15:36:20 <Botje> normal `liftM` "like this :)"
15:36:24 <idnar> Botje: can't I use liftMood :/
15:36:34 <Botje> heh. and that's a big type error
15:36:45 <idnar> I think I first read it when I was like 12 or something, so I ended up reading it quite a few times in order to make sense of stuff
15:36:46 <vincenz> Hofstadter's next book "A strange loop" is rather dissapointing
15:36:46 <Botje> look! I crashed oklopol's connection!
15:36:59 <idnar> vincenz: I haven't read that one, maybe I should
15:36:59 <sclv> metamathmagical themas is awesome.
15:37:02 <gwern> vincenz: that was terrible, but it wasn't his 'next book'
15:37:12 <vincenz> gwern: there was in between?
15:37:21 <OscarZ> i find it interesting that here i find a lot of people who recognize the book.. but eg. on some other programming language channel say c++ on something, no one would recognize it
15:37:21 <gwern> Le Ton De Beau Marot kicked ass I though, and some of metamagical themas were true gems
15:37:29 <vincenz> gwern: the strange loop one was him constantly complaining about people that didn't like his work, and moanign about his dead wie
15:37:31 <OscarZ> it isnt a math book per se isnt it ?
15:37:46 <sclv> i dig how he's got this whole thing on rubiks algorithms and somehow he's trailing off into meditations on world peace, etc.
15:38:05 <idnar> OscarZ: well, it's about mathematics, not programming in the sense of C++ et al
15:38:07 <sclv> generally i find his stuff more emotionally satisfying than always mind expanding...
15:38:13 <vincenz> gwern: not to mention overdoing it, overplaying it, overzealing it, working too much with it, overwriting it, ...you get hte idea
15:38:19 <gwern> vincenz: oh yes. there were a number of books. _Fluid analogies_, a Pushkin translation, _Le Ton De Bau Marot_ (which had lots of whining about his wife, but much better than Strange Loop), Metamagical Themas, and so on
15:38:19 <OscarZ> vincenz: give the guy a break.. he had some hard time :(
15:38:48 * vincenz nods at gwern 
15:38:56 <idnar> OscarZ: I think people that work with Haskell tend to be far more grounded in the mathematical basis of what they're doing than, say, C++ programmers (which is probably due to how the language works)
15:38:58 <vincenz> OscarZ: I had high expecations and it failed in that regard
15:39:15 <Feuerbach> can I hide an instance declaration from imported module?
15:39:24 <gwern> OscarZ: yeah, but you know what? many people have even harder times, and when they write bestsllers with a large waiting population, they manage to deliver value for money
15:39:29 <vincenz> Feuerbach: classes are not scoped
15:39:55 <idnar> OscarZ: how do you "give the guy a break"? it's not like pretending the book is better than it is will help ;)
15:40:09 <idnar> there may be understandable reasons for why things are the way they are, but that doesn't really change the outcome
15:40:28 <vincenz> Not to mention, if he wanted to write on that topic, then write on that, don't make a sequel to GEB to write on this
15:41:05 <gwern> that was supposed to be a GEB sequel? that made it even more lame
15:41:36 * vincenz goes to check
15:41:37 <vincenz> I thought so
15:42:24 <vincenz> gwern: Yes, it's the "what I Wasn't able to say in GEB" bok
15:42:25 <vincenz> book
15:42:52 <OscarZ> vincenz, gwern: i think "I am a strange loop" is to GEB what "A brief history of time" is to the theory of general relativity
15:43:23 <vincenz> OscarZ: and what a hammer is to  bird?
15:44:00 <vincenz> Anywho, I'll stop, this is OT. Apologies.
15:44:01 <dons> spj gave a talk today about 'caging the effects monster'. we don't seem to have slides, but someone's blogged about  it, http://reddit.com/r/programming/info/6en91/comments/
15:44:02 <OscarZ> the way i saw it.. it was just an attempt to popularize it..
15:44:06 * gwern was about to say Book:Book::Theory:Book doesn't really work
15:44:22 <dancor> cabal configure does not have -O2, is that bc O2 is for noobs?
15:44:25 <vincenz> OscarZ: GEB was popularized...
15:44:51 <vincenz> OscarZ: I just checked the book, it said that, in short, what he was unable to say in GEB
15:45:00 <dancor> or does cabal -O mean ghc -O2
15:45:05 <gwern> dancor: you need a flag
15:45:18 <gwern> --enable-optimizations, iirc, would become -O2 since -O is by default
15:45:19 <vincenz> gwern: is there a good "how to cabal" tuotrial?
15:45:33 <ddarius> @where cabal
15:45:33 <lambdabot> http://www.haskell.org/cabal
15:45:38 <vincenz> gwern: seeing you're the cabal's grand pooba
15:45:40 <dons> dancor: -O is the default. use --ghc-options=-O2
15:45:43 <gwern> vincenz: yes. you send a link to me and then look at my patches :)
15:45:47 * gwern jokes
15:45:58 <dons> i like -O2, and i don't think we've numbers for the performance difference on packages though
15:46:06 <gwern> vincenz: the only real cabal tutorial-tutorial I am aware of is in the wikibook
15:46:19 <gwern> see https://secure.wikimedia.org/wikipedia/en/wiki/Cabal_software
15:46:33 <gwern> it links to http://en.wikibooks.org/wiki/Haskell/Packaging
15:46:47 * vincenz dosn't want to se eyour patches *shudder*
15:46:51 <gwern> might be a little out of date, though, I suppose
15:46:56 <OscarZ> vincenz: why did you read the book?
15:47:04 <OscarZ> what did you expect of it ?
15:47:13 <gwern> vincenz: what? why notz? such things hurt mine feelings
15:47:31 <vincenz> gwern: KTHX BYE
15:48:04 <vincenz> OscarZ: Let's do this in haskell-blah
15:48:12 <OscarZ> sure
15:51:06 <__pao__> @hoogle words
15:51:06 <lambdabot> Prelude.words :: String -> [String]
15:51:06 <lambdabot> Data.List.words :: String -> [String]
15:51:06 <lambdabot> Data.ByteString.Char8.words :: ByteString -> [ByteString]
15:52:21 <__pao__> @src words
15:52:21 <lambdabot> words s = case dropWhile isSpace s of
15:52:22 <lambdabot>     "" -> []
15:52:22 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
15:52:33 <shapr> @users
15:52:33 <lambdabot> Maximum users seen in #haskell: 466, currently: 458 (98.3%), active: 25 (5.5%)
15:52:37 * shapr boings
15:53:32 <__pao__> @src dropWhile
15:53:32 <lambdabot> Source not found. My mind is going. I can feel it.
16:03:22 <OscarZ> but isnt there some sort of causal construct in our brain that is able to define itself somehow, in the same way as Gdel statement was able to define itself and cause havoc in the logic? :D
16:04:01 <gwern> @hoogle mdo
16:04:01 <lambdabot> No matches found
16:04:41 <EvilTerran> that one's not a function
16:04:53 * thetallguy boings back at shapr
16:05:15 <glen_quagmire> @oeis 1 2 3
16:05:15 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
16:05:15 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
16:05:26 * thetallguy wonders if a pogo stick and a unicycle could be combined.
16:05:43 <dons> this is why they don't let you design unicycles or pogosticks, thetallguy
16:06:03 <Excedrin> hmm, the unistick...
16:06:17 <gwern> hm... the bistick...
16:06:19 <Botje> pogocycle sounds better :)
16:06:20 <EvilTerran> @where+ mdo http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#mdo-notation
16:06:20 <lambdabot> Nice!
16:06:31 <ddarius> thetallguy: Wouldn't that just be a unicycle with bad shocks?
16:06:31 * thetallguy was thinking that shapr rides a unicycle a whole bunch and boings a whole bunch, so the probability of him boinging while unicycling was rather high...
16:06:34 <EvilTerran> gwern, there you go ^
16:06:54 * gwern actually needed to know that the LANGUAGE pragma was RecursiveDo
16:06:59 <thetallguy> ddarius: alas, they don't have shocks, as far as I know.
16:07:17 <EvilTerran> ah. it mentions that in that section
16:07:25 <Excedrin> I've got it! It's a stick with a seat on it, and it's called the unistick! combining non-essential features of the unicycle and pogostick
16:08:04 <gwern> Excedrin: brilliantly useless
16:08:16 <thetallguy> dons: how do you know the won't let me?  The web lets anyone publish designs.  And manufacturers aren't exactly picky.
16:08:29 <dons> conal's new paper, http://reddit.com/info/6enc1/comments/
16:08:36 <dons> thetallguy: ok. now i'm scared.
16:08:48 <Excedrin> gwern: I think it's quite useful, any time you need to sit...
16:08:50 <thetallguy> dons: as well you should be
16:08:53 <dons> a tallguy sized pogo-cycle eh?
16:09:02 <dons> that sounds like it would be battle ready
16:09:06 <thetallguy> dons: there's nothing scarier than my imagination in gear.
16:09:23 <dons> hmm. the pogocycle.
16:09:29 <dons> that's a good name, i think
16:09:41 <thetallguy> dons: fortunately, my implementation skills lag far behind.
16:10:24 <thetallguy> dons: so you're safe
16:11:36 <dons> but you got me all excited about pogocycles now
16:12:20 <thetallguy> http://www.youtube.com/watch?v=lxdHZSKJoHA
16:12:21 <lambdabot> Title: YouTube - POGOCYCLE - THERE IS SUCH A THING.
16:12:28 <dons> omg
16:12:57 <Excedrin> http://lerp.com/~sic/unistick.jpg
16:13:24 <Botje> this is clearly the internets at work.
16:13:31 <gwern> Excedrin: but will it blend?
16:13:33 <thetallguy> this one shows the "suicide mount" http://www.youtube.com/watch?v=hA8SSQ_InkA&NR=1
16:13:33 <lambdabot> Title: YouTube - 3d Unicycling
16:13:44 <dons> http://www.soc1024.com/wp-content/uploads/2007/08/img_0760.JPG
16:15:19 <gwern> http://wordaligned.org/articles/programming-nirvana-plan-b <-- I don't like this article because the lambda spud at the end looks to me like Goatse :(
16:15:21 <lambdabot> Title: Programming Nirvana, Plan B
16:17:03 <ddarius> dons: What the heck is that?
16:17:16 <gnuvince_> I wish there was a video of SPJ's talk at ACCU 2008
16:17:29 <gwern> ddarius: obviously you stand on top
16:17:47 * gwern still hasn't figured out the propulsion mechanism though
16:18:08 <gwern> perhaps it is only intended for going downhill
16:18:55 <EvilTerran> i think you're meant to get it moving by hopping
16:19:14 <guenni2> most people here will already know this, I just found it though and think it's funny as hell http://www.willamette.edu/~fruehr/haskell/evolution.html
16:19:15 <lambdabot> Title: The Evolution of a Haskell Programmer
16:21:24 <dons> is there much haskell at willamette these days?
16:22:57 <dons> check out the slides, http://www.willamette.edu/~fruehr/haskell/lectures/tutorial.html
16:22:57 <lambdabot> Title: CCSC Haskell tutorial
16:23:00 <dons> awesomely retro
16:23:05 <dons> nice lambda
16:23:39 <sclv> ooh. conal's paper is very nice. still seems like its more in the far-off-researchy phase than something practical to play with yet...
16:24:05 <dons> conal: your website is down?
16:24:22 <dons> http://conal.net/blog/posts/simply-efficient-functional-reactivity/
16:24:23 <lambdabot> http://tinyurl.com/6ma42k
16:24:38 <ddarius> "Microsoft has bought into Haskell ..."
16:25:06 <ivan> Haskell.NET coming soon
16:25:18 <ivan> oh wait, it's already here
16:25:26 <Zao> ivan: Ignoring that Visual Haskell and that other project already exists.
16:25:29 <conal> dons: upgrading wordpress right now.  just started 1 min ago.  will be done in 2.
16:26:17 <dons> conal: go go go :)
16:26:17 <gwern> -_- I have 332 Setup.hs's on my system. oy
16:27:01 <kfish> hi gwern
16:27:23 <s710b> @src scanl
16:27:23 <lambdabot> scanl f q ls = q : case ls of
16:27:23 <lambdabot>     []   -> []
16:27:23 <lambdabot>     x:xs -> scanl f (f q x) xs
16:27:25 <gwern> 'lo kfish
16:27:50 <sclv> conal: are you planning to work on (or encourage others to) some nice gtk code or such to play with based on yr. new formulation of frp?
16:29:46 <gwern> what does one call those #! things?
16:29:54 <dbpatterson> hashbang?
16:30:13 <sclv> i have a hard time getting my mind around this stuff without some nice examples...
16:30:28 <gwern> hm, [[Shebang (Unix)]]
16:30:34 <dons> sclv: gtk rather than wx-based?
16:30:39 <conal> sclv: wxhaskell at first.
16:30:53 <conal> crap.  i'm locked out of my blog.  hm.
16:31:37 * gwern can't compile wxhaskell, even the recent ones. it makes me very sad
16:32:12 <sclv> yeah, i don't really care which, just excited to see this in action -- each part of the paper makes sense on its own, at least a little to me, but putting them together is beyond me.
16:33:37 <sclv> particularly interested, of course, in the possibility of an frp-like formulation for a generalized data model layer.
16:36:21 <thetallguy> conal: perhaps you can climb in through port 80?
16:37:30 <vincenz> conal: verty painful
16:37:44 <vincenz> conal: "Conal Elliott is currently undergoing scheduled maintenance."  Dentist?
16:37:56 <gwern> 'When I’m in the middle of a deep C groove, I can almost hear Maxwell’s demons screaming in agony as they flip the transistors inside my CPU, begging, pleading for mercy. The output of my C code is a gift made by millions of subservient, recalcitrant malcontents, an offering to the crazed god who demands of them “flip this” and “set that”. '
16:38:16 <jsnx> iowa is cool
16:38:24 <jsnx> i went to school there
16:43:54 <gwern> '"No–one in their right mind would suggest writing a mission–critical device driver in Ocaml, but nobody thinks twice about writing mission–critical device drivers in Assembly or Ada."
16:44:01 <gwern> Real Astronauts refuse to pilot spacecraft using software in which buffer overflows do not result in death!'
16:44:27 <Tobsan> @type flip
16:44:30 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
16:44:38 <Tobsan> @type concatMap
16:44:39 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
16:44:51 <Tobsan> thank you!
16:46:00 <byorgey> Tobsan: if you wish to thank lambdabot, you can issue the @thanks command =)
16:46:23 <gwern> @thanks
16:46:23 <lambdabot> you are welcome
16:46:30 <Tobsan> lol, didnt even know that existed
16:46:31 <Tobsan> @thanks
16:46:31 <lambdabot> you are welcome
16:46:34 <Tobsan> nice
16:47:12 <dbpatterson> gwern: reddit-bot?
16:47:18 <dbpatterson> or, proggit-bot?
16:47:40 <gwern> dbpatterson: pardon?
16:49:31 <dbpatterson> gwern: that was just posted on reddit....
16:49:56 <gwern> dbpatterson: oh. yes, I was reading reddit
16:50:56 <clanehin> From reading reddit, you'd think haskell was the second most popular language in the world after erlang.
16:50:57 <dbpatterson> I was joking that you were a reddit bot...
16:51:06 <dbpatterson> clanehin: dont forget lisp...
16:51:32 <Cale> clanehin: You mean that it isn't? There may be hope yet!
16:51:39 <clanehin> Myself, I don't see lisp on reddit so much.
16:52:26 <dbpatterson> hmm... I feel like there are lots of pseudo-paulgraham evagelists popping up semi-frequently.... but that may be distorted memory
16:52:55 <EvilTerran> i think they died out a bit when their idol turned out to be a grand old man
16:53:14 <gwern> arc hurt the lispers
16:53:30 <EvilTerran> precisely
16:53:40 <ddarius> And arc hysteria has blown over a few months after it started as I predicted.
16:54:12 <gwern> ddarius: arc hysteria = popularity, interest, or the criticism of it?
16:54:21 <dbpatterson> maybe all of the above?
16:54:24 <pjd> did any lispers take more than cursory notice of Arc?
16:55:00 <pjd> the hysteria seemed to be mostly from non-lispers
16:55:02 <ddarius> gwern: Yes.
16:55:22 <gwern> ddarius: that joke was old when RMS did it
16:55:27 <byorgey> pjd: I don't think that's true.  I know some lispers who are very excited about arc.
16:55:39 <ddarius> gwern: Indeed.  It is an insanely old "joke."
16:56:36 <clanehin> Answering yes to a multiple choice question?
16:57:09 <gwern> clanehin: no, the issue is 'or'
16:57:22 <dbpatterson> arc seemed to truly die when he put out his 'challenge' and examples came back showing that all he had basically done was do what lisp people always do - write some macros...
16:57:37 <gwern> the common sense understanding is that he'll supply the True value from the list of false, not True, if you follow
16:58:25 <clanehin> That isn't the definition of a multiple choice question?
16:58:46 * ddarius no longer knows what gwern is talking about.
17:01:09 <gwern> @hoogle Maybe String -> String
17:01:10 <lambdabot> System.Locale.iso8601DateFormat :: Maybe String -> String
17:02:12 <Baughn> Shouldn't that show fromJust too?
17:02:12 <gwern> kind of sad how the Barracuda devs felt the need to roll their own Data.Char.UTF8
17:02:49 <gwern> Baughn: maybe; it does match - Maybe a -> a
17:03:20 <pjd> @hoogle Maybe a -> a
17:03:20 <lambdabot> Data.Maybe.fromJust :: Maybe a -> a
17:03:20 <lambdabot> Data.Maybe.fromMaybe :: a -> Maybe a -> a
17:03:20 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
17:04:59 <facedown> ?
17:06:13 <gwern> facedown: there's an old bashism on #wikipedia: "for some reason, when people hang out on IRC long enough, they start to think they can make valid arguments of the form '???'."
17:06:33 <gwern> (w00t; barracuda finally installed from sdist, without data.char.utf8)
17:07:16 * gwern needs to go eat now. yay food
17:11:06 <jsnx> gwern: do not understand joke
17:11:27 <monochrom> ???
17:11:39 <pjd> 3. Profit!
17:13:43 <idnar> hahaha
17:18:14 <misterPhyrePhox> why isn't this a valid haskell98 instance declaration: instance (Real a) => Primitive a where { ... }
17:18:32 <misterPhyrePhox> what's the point of having type classes if you can't make them generic? or am i doing it wrong?
17:19:01 <mauke> imagine it was
17:19:17 <mauke> then: instance (Primitive a) => Real a
17:19:23 <mauke> WHAT NOW?!
17:20:07 <misterPhyrePhox> OH SHI-!
17:20:20 <misterPhyrePhox> ok, i see
17:20:32 <misterPhyrePhox> but i see that kind of stuff all the time in the haskell libraries
17:20:47 <misterPhyrePhox> like an arbitrary example: class Monad m => MonadState s m | m -> s where
17:20:56 <Botje> that's a fundep
17:20:58 <misterPhyrePhox> does the | m -> s make it legal? i never figured out what that meant
17:21:15 <misterPhyrePhox> functional dependency?
17:21:20 <monochrom> {-# LANGUAGE FlexibleInstances #-} makes it legal.
17:21:32 <Botje> misterPhyrePhox: it means that for every type m, there's only one instance m s that satisfies it
17:21:40 <Botje> and if you know m, you thus know s
17:22:15 <Botje> *instance of MonadState s m
17:22:36 <misterPhyrePhox> so can i use a fundep to make my instance declaration legal?
17:22:57 <misterPhyrePhox> does the fundep tell the compiler that the inverse instance (as mauke posited) is legal?
17:22:59 <Botje> you only have one parameter, so there's no fun to dep on :)
17:23:09 <misterPhyrePhox> oh :[
17:23:31 <misterPhyrePhox> so there's no way to make that legal haskell98?
17:23:32 <mauke> wtf?
17:23:44 <monochrom> illegal in haskell98
17:23:50 <mauke> misterPhyrePhox: the example you pasted is a constraint on 'class', not a magic 'instance'
17:24:04 <misterPhyrePhox> mauke, i don't understand
17:24:16 <mauke> the line starts with 'class', not 'instance'
17:24:51 <monochrom> I am too polite to say that there is too much misinformation around.
17:25:12 <Botje> translation: "THE DUMB. IT IS EVERYWHERE!"
17:25:18 <misterPhyrePhox> durr
17:25:21 <monochrom> don't want to be labelled as poisonous member, you know.
17:25:34 <misterPhyrePhox> i'm just a haskell noob
17:26:03 <misterPhyrePhox> this type stuff is hard
17:26:20 <misterPhyrePhox> and mauke, the line i pasted starts with instance, what?
17:26:33 <Saizan> misterPhyrePhox: first of all you need to focus on the difference between declaring a class and instancing it
17:26:43 <pjd> Ob: http://arcanux.org/lambdacats/dumb.jpg
17:26:54 <mauke> <misterPhyrePhox> like an arbitrary example: class Monad m => MonadState s m | m -> s where
17:27:01 <misterPhyrePhox> oh
17:27:10 <misterPhyrePhox> oh yeah, gah
17:27:27 <misterPhyrePhox> i thought you were talking about my original line
17:27:55 <misterPhyrePhox> yeah i got confused :[
17:28:43 <misterPhyrePhox> ok, i'll just use the FlexibleInstances extension
17:28:45 <misterPhyrePhox> thanks for your help
17:28:49 <misterPhyrePhox> double thanks for calling me dumb
17:28:54 <misterPhyrePhox> that's how you'll get the python converts!
17:29:07 <monochrom> No, I don't consider you dumb. The extensions are hard.
17:29:34 <monochrom> For example if you turn on FlexibleInstances, that solves one problem but introduces more and harder ones.
17:30:19 <misterPhyrePhox> yeah
17:30:31 <gwern> dumb isn't not grokking extensions; dumb is cashing a Knuth check
17:30:39 <monochrom> I have seen a glimpse of the new problems, but I don't know all of them and I don't know the exact new rules.
17:30:50 <sclv> misterPhyrePhox: just so yr, clear, as far as i could tell, that was a joke at the expense of the chan fumbling to answer your questions.
17:31:24 <glen_quagmire> no body is dumb including myself
17:31:32 <misterPhyrePhox> oh, i thought "poisonous member" was referring to myself
17:31:36 <misterPhyrePhox> excuse my misplaced RAGE!!!
17:32:22 <sclv> i ask dumb questions here all the time.
17:32:25 <mauke> EXPERT RAGER
17:33:36 <sclv> usually ghc will tell you what extension you need, actually. FlexibleInstances and FlexibleContexts are some of the most common and there's lots of code that uses them -- they're also widely implemented so they're "almost standard" (and will be with haskell')
17:33:57 <mofmog> so i'm trying to compile a program that uses hscurses but apparently this doesn't work
17:34:09 <johnnowak> here's a bizarre question: is there any typed language with parametric polymorphism that has a pointfree type notation?
17:34:16 <mofmog> it works in ghci, but when i compile it, ghc apparently can't find the c files or something
17:34:20 <sclv> for just starting out, I recommend throwing in a {-# OPTIONS -fglasgow-exts #-} and being done with it. of course, for real code, you want to refine that to the proper language pragmas.
17:34:31 <Botje> mofmog: be sure to use --make
17:34:32 <misterPhyrePhox> sclv, yeah, ghc did tell me, but i try to stick to haskell98 when i can't since i don't fully understand the extensions
17:34:38 <misterPhyrePhox> *when i can :)
17:34:40 <mofmog> Botje: i tried that
17:35:19 <Botje> dunno then
17:35:25 <sclv> the most dangerous ones -- undecidable and incoherent instances are off even with glasgow exts, so you're on ok territory there.
17:35:35 * Botje `ap` sleep
17:36:04 <misterPhyrePhox> DANGER IS MY MIDDLE NAME
17:36:37 <sclv> mofmog: is the program failing in linking?
17:37:19 <sclv> if so you need to figure out which libs it binds to (curses libs, i'd imagine) and pass them in directly along with your source files on the command line.
17:37:40 <sclv> ghc passes files it can't understand directly to the linker.
17:37:41 <mofmog> sclv: yeah i think
17:37:51 <mofmog> =/
17:39:45 <sclv> if the hscurses lib was built properly however, and if the program itself only talks to hscurses and doesn't otherwise bind to the lib, this shouldn't be an issue. now that you're in such a spot though, not a big deal.
17:40:17 <mofmog> when i use ghc-pkg it's listed
17:40:33 <mofmog> so um
17:40:38 <sclv> give it a shot and see if it fixes the issue at least...
17:41:12 <mofmog> i dont even know where everything is
17:41:22 <sclv> you on unix?
17:41:24 <mofmog> yes
17:41:29 <glen_quagmire> using parsec's TokenParser, how can I parse whitespace (mandatory) separated tokens?
17:41:31 <sclv> locate curses.a
17:41:39 <sclv> or $locate curses.dylib
17:41:43 <sclv> then just pass that in
17:42:39 <monochrom> glen_quagmire: like, e.g., "a+" is one token and "a +" is two?
17:42:40 <glen_quagmire> l = makeTokenPaser (haskellDef { ... });  now, l ignores whitespaces
17:42:46 <glen_quagmire> monochrom: yes!
17:43:05 <monochrom> I'm afraid it can't do that. But I'll double-check.
17:43:15 <mofmog> ghc -package hscurses /usr/lib/libncurses.a -o test cursestest.hs
17:43:22 <mofmog> libncurses.a was the closest i coudl get
17:43:23 <mofmog> hmm
17:44:16 <glen_quagmire> currently i'm just using whitespace = whiteSpace l {- optional whitespace -}   ws = space >> whitespace {- mandatory -}   and use them to build custom parser
17:44:55 <monochrom> You need to design your languageDef from scratch, almost.  For example identStart and identLetter = oneOf "abc+-*".  That will cause "a+" to be one token since both 'a' and '+' are now identifier constituents.
17:45:28 <glen_quagmire> hrm i see. so my parser probably can't be shorter
17:45:51 <chadz> if i have a takusen db function which works when invoked in ghci, yet causes the cgi application to segfault when called within the CGI monad, what should I look into? i've tried error handling to no avail
17:46:02 <glen_quagmire> so, i'm just using makeTokenParser to automatically skip whitespaces and comments. that's still a lot of gain
17:46:33 <mofmog> "/home/andrew/lib/hscurses-1.3/ghc-6.8.2/libHShscurses-1.3.a(Curses.o): In function `r8Jx_info':
17:46:34 <mofmog> ghc31984_0.hc:(.text+0x10959): undefined reference to `mousemask'"
17:48:27 <gwern> tried compiling with -fvia-c?
17:50:00 <mofmog> still doesn't work
17:50:05 <mofmog> possibly trouble with the package itself?
17:50:28 <mofmog> it works a little crazy inside ghci but i thought that was expected
17:50:34 <gwern> hard to say. the curses packages are tricky to link against
17:50:53 <gwern> you could try installing and uses nanocurses, unless you're using the more complex hscurses features
17:51:20 <mofmog> i'll try that instead ig uess
17:51:37 <mofmog> geez, you'd think simple text stuff would be easier
17:51:46 <monochrom> heh
17:52:28 <reltuk> anyone particularly familiar with ghc's packages mechanism?
17:52:43 <monochrom> In all probability it may be just a simple linking omission.
17:53:19 <glen_quagmire> reltuk: i am master of ghc's packages mechanisms
17:54:06 <chadz> "blog.fcgi: exception :: Database.InternalEnumerator.DBException"
17:54:20 <reltuk> I'm trying to construct some policies and helper scripts that will allow me to easily relocate ghcs and installed cabal packages
17:54:26 <chadz> not sure why I get this -- the code work swell from within ghci.
17:54:40 <gwern> mofmog: as I said, it can be, but if you want curses - well, it's an old crufty nasty C library
17:55:02 <gwern> mofmog: look at the terminal code for space invaders on hackage; it's nice and clean because it isn't going through curses
17:55:41 <reltuk> so far, the best idea I've got is to build and install the cabal package to it's own --prefix, and use --user with an overriden HOME to get a singular package.conf file for that cabal package
17:56:12 <reltuk> then I can replace instances of --prefix in that file with something like @@PREFIX@@, and place it somewhere like share/pkg_name/package.conf
17:56:42 <gwern> @hoogle ParserCombinators
17:56:43 <lambdabot> No matches found
17:57:10 <mofmog> gwern: what does it use?
17:57:34 <gwern> mofmog: I'm not entirely sure. not curses though
17:57:48 <gwern> (it's been a while since I cleaned it up and packaged it, ken?)
17:58:12 <reltuk> then if I want to consume a number of these cabal package artifacts, I grab all their package.conf's rewrite their @@PREFIX@@ to be the actual root of the artifacts, and place those resulting package.confs on my GHC_PACKAGE_PATH before invoking Cabal
18:00:59 <gwern> reltuk: crazyness. so what need prompts your effort?
18:01:26 <sclv> mofmog: can you compile anything that links against the curses lib?
18:01:42 <sclv> it could be as simple as that the curses lib isn't linked right to begin with
18:02:40 <mofmog> sclv: nope
18:02:46 <mofmog> it works sorta in ghci
18:02:52 <mofmog> so i just sorta assumed a simple --make woudl work
18:03:06 <sclv> huh
18:03:26 <gwern> mofmog: as I said, often -fvia-C fixes the problem for me
18:03:31 <reltuk> gwern: trying to add something like first-class haskell support to a build system at work
18:04:11 <gwern> reltuk: oh. nice, I suppose. it would probably be worthwhile to ask the cabal-dev list their thoughts?
18:04:11 <mofmog> i'm going to try reinstalling all this
18:04:25 <mofmog> failing that, i guess i'll just reuse AnsiScreen from Invaders
18:05:00 <reltuk> gwern: good idea =).  I also might be able to just chroot for every build, and thus avoid the prefix-rewriting hackery
18:05:16 <gwern> chroot might cause problems if you'd like to run as user
18:08:23 <conal> okay, wordpress db hell is over, and blog is back: http://conal.net/blog/
18:08:24 <lambdabot> Title: Conal Elliott
18:09:24 <reltuk> good call...or maybe patch the package stuff so that package.conf could contain relative paths, and it resolves them using another PATH-type environment variable of roots to search
18:09:51 <reltuk> I will invoke cabal-dev@  =)
18:14:59 <conal> dons: there?
18:20:17 <conal> i guess the reddit for my paper got deleted after my blog borked.  new reddit: http://reddit.com/info/6enns/comments/
18:24:05 <glen_quagmire> in type theory, what does /\ usually stand for?
18:24:24 <Saizan> and?
18:24:35 <conal> glen_quagmire: type abstraction.
18:24:40 <glen_quagmire> |- /\ alpha . lambda x : a . x .....
18:24:51 <conal> glen_quagmire: right.  abstraction over types.
18:24:54 <Saizan> oh, a lambda on types then, yes
18:24:57 <conal> (lambda abstraction)
18:25:22 <glen_quagmire> so how should I understand it? abstraction sounds too abstract to me
18:25:35 <glen_quagmire> can I read it  forall ?
18:25:49 <glen_quagmire> forany sounds like it
18:25:58 <glen_quagmire> for any alpha, lambda blah blah ...
18:25:59 <conal> glen_quagmire: how about lambda, but over types, as Saizan said.  it goes with an application for a type argument.
18:26:16 <glen_quagmire> oh that makes sense
18:26:21 <gwern> hm. I'm almost done with barracuda
18:26:38 <conal> glen_quagmire: it's for explicit polymorphism ("the polymorphic lambda calculus") rather than our more familiar implicit polymorphism (no explicit lambda & application for types).
18:26:46 <glen_quagmire> so it's a function that will take a type  and evaluate body
18:26:47 <gwern> that's been a good 'un for libraries. a crypto library, an xml parsec library, an ad hoc networking library, and of course barracuda itself
18:26:56 <conal> glen_quagmire: i think, e.g., ghc core has type abstraction (lambda) and application.
18:27:03 <conal> glen_quagmire: right
18:27:05 <Saizan> the type of /\ alpha . lambda (x : alpha) . x is indeed forall alpha . alpha -> alpha
18:27:39 <glen_quagmire> it gets hairy. type of types is kind. type of kinds is sort
18:27:47 <glen_quagmire> type of terms is type.
18:28:05 <conal> glen_quagmire: see the lambda cube if interested.
18:28:17 * glen_quagmire is reading Henk paper
18:28:38 <conal> glen_quagmire: that's the one
18:29:26 <jair_> Hello! Does someone know how can I call Haskell functions from Python?
18:29:41 <newsham> hi
18:29:42 <glen_quagmire> meaning of a |- b   is in the environment a,  b ?
18:29:58 <allbery_b> jair_: take a look at MissingPy?
18:29:58 <glen_quagmire> @google missing py
18:29:59 <lambdabot> No Result Found.
18:30:08 <allbery_b> @go MissingPy
18:30:11 <lambdabot> http://quux.org:70/devel/missingpy
18:30:21 <newsham> jair: the same way you would call C from python followed by the same way you would call haskell from C ?
18:30:48 <allbery_b> ...ooooookaaaayyyyyy...
18:31:44 <glen_quagmire> to understand lambda cube,  i need to know system f. to know that, i need simply typed lambda calculus. it's a dependency hell
18:32:45 <gwern> glen_quagmire: nah. dependency hells are circular graphs
18:33:42 <gwern> that's not even a directed graph
18:33:44 <jair_> allbery_b: thanks! It looks great
18:34:00 <jair_> newsham: yeah, I was trying to avoid that.
18:34:19 <newsham> success i presume
18:34:29 <allbery_b> one worry is I think I read recently that MisingPy doesn't work with ghc 6.8.2
18:34:48 <allbery_b> check the haskell-cafe archives
18:34:56 <glen_quagmire> do some colleges teach these things during undergrad? i personally never heard of lambda calculus during undergrad
18:35:02 <newsham> i would think using ctypes + ffi would be fairly straightforward
18:35:16 <Cale> glen_quagmire: I should hope so.
18:35:21 <reltuk> gopher?
18:35:23 <Cale> glen_quagmire: At least the basics.
18:35:29 <glen_quagmire> type theory in undergrad?
18:35:36 <glen_quagmire> oh i see
18:35:47 <Cale> Well, maybe not extensive type theory, but basic lambda calculus.
18:35:50 <glen_quagmire> no wonder employers prefer ivy league
18:36:07 <Cale> It would actually make a great replacement for Turing machines.
18:36:52 <glen_quagmire> my undergrad theory class started at FSM and stopped at turing machine
18:37:08 <jair_> allbery_b: hmm, It allows you to cal python from Haskell, but not Haskell from python. I guess i'll have to walk the C route
18:37:39 <gnuvince_> @help pl
18:37:39 <lambdabot> pointless <expr>. Play with pointfree code.
18:40:52 <newsham> quagmire: mine as well
18:41:26 <newsham> my programming languages grad class covered semantics and lambda calc
18:42:02 <newsham> but the grad theory class just went deeper on fsm's, push downs and turing machines
18:42:36 <glen_quagmire> it's all because of Java
18:42:51 <newsham> this type theory book looks aimed at undergrad http://www.cs.ukc.ac.uk/people/staff/sjt/
18:42:53 <lambdabot> Title: Computer Science: Home page for SJ Thompson
18:43:07 <newsham> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/ i mean
18:43:08 <lambdabot> Title: Type Theory and Functional Programming
18:43:54 <glen_quagmire> thanks newsham
18:49:58 <gwern> hm. do libraries need to be threaded, or is that just a concern for executables?
19:00:04 <mrd> execs
19:05:15 <dbpatterson> is there a prelude function to text primeness? (before I start using my simple one all over the place)
19:05:24 <dbpatterson> or even a standard library one...
19:05:32 <dbpatterson> s/text/test/
19:05:46 <ddarius> dbpatterson: Nope.  This isn't J.
19:05:58 <ddarius> @hoogle isPrime
19:05:58 <lambdabot> No matches found
19:06:18 <dbpatterson> alright, thought I'd check (didnt see anything in hoogle, but figured I could be using the wrong name..)
19:06:32 <ddarius> @hoogle primes
19:06:33 <lambdabot> No matches found
19:06:53 <gwern> problem is, any prime function would have endless religious wars over its definition
19:06:56 <Korollary> @hoogle Integer -> Bool
19:06:56 <lambdabot> Data.Time.Calendar.isLeapYear :: Integer -> Bool
19:06:56 <lambdabot> Data.Time.Calendar.Julian.isJulianLeapYear :: Integer -> Bool
19:06:56 <lambdabot> Data.Time.Calendar.OrdinalDate.isLeapYear :: Integer -> Bool
19:07:06 <gwern> I mean, haveyou *seen* some of the primality threads on -cafe??
19:08:09 <dbpatterson> gwern: that is true... we could always have a set of _name_Prime functions...
19:08:20 <dbpatterson> as in gwernPrime
19:08:24 <dbpatterson> (I am very much joking)
19:08:36 <ddarius> gwern: Anybody who's using a "standard" isPrime function, doesn't need it for serious use.
19:08:54 <dbpatterson> ddarius: that was what I wanted...
19:09:07 <gwern> ddarius: yes, that's sort of what I mean. haskell is not mathy enough for anybody to safely avoid rolling their own...
19:09:29 <ddarius> ("serious" here means things like -large- primes or large quantities of them or something)
19:10:01 <dbpatterson> question about ghci - when I :load a module that has not been compiled, I get all the functions into scope.. when it has been compiled, they arent.. why? and how do I 'import' them properly?
19:10:21 <ddarius> dbpatterson: It's a "convenience" feature of GHCi for debugging.
19:10:32 <ddarius> (/testing/playing around)
19:10:56 <dbpatterson> which is? importing all the functions?
19:11:04 <dbpatterson> (import is probably the wrong word for it)
19:11:15 <ddarius> Importing unexported functions when interpreting.
19:11:39 <dbpatterson> is there any way to import unexported functions when not interpreting?
19:11:52 <ddarius> I don't believe so.
19:12:00 <dbpatterson> so I have to delete the executables/object files when I want to do that?
19:15:11 <ddarius> dbpatterson: That or simply comment out the export list in the file.
19:16:55 * dbpatterson thinks he should add a module where statement to this module in particular...
19:19:23 <gwern> @seen dons
19:19:23 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 2h 42m 9s ago.
19:19:33 <gwern> @tell dons http://www.haskell.org/pipermail/haskell-cafe/2008-January/038557.html <-- 'sdone
19:19:33 <lambdabot> Consider it noted.
19:25:55 <keseldude> dons: Do you mind if I PM you a quick question about lambdabot?
19:26:28 <gwern> keseldude: dons hasn't been in for almost 3 hours. you might as well just leave him a message for whenever he gets back
19:26:29 <SamB> why do you want to pm it?
19:28:07 <keseldude> ok
19:28:09 <EvilTerran> maybe one of us other than him can help you
19:28:59 <keseldude> I built my own lambdabot with ghc6.8.2 on os x 10.5.2, and I'm trying to have all of the random functions in scope
19:29:47 <SamB> keseldude: why don't you ask Cale -- Cale is the current maintainer anyway
19:31:18 <Cale> Uh, they should be in scope...
19:31:32 <Cale> at least, System.Random is included in imports.h in the newest version
19:31:58 * keseldude checks
19:35:39 <ddarius> xmonad is so handy
19:35:48 <gwern> how so?
19:35:53 <mauke> xmonad is so dreamy~
19:36:09 <gwern> xmonad is so hunky!
19:36:22 <ddarius> gwern: I just referred to it's source code.  I knew I'd get exactly what I'd need from it.
19:36:46 <ivanm> ddarius: the meaning of life? :p
19:37:05 <Cale> I just referred to it is source code.
19:37:13 <Cale> ;)
19:37:17 <ddarius> Bugger you Cale.
19:37:20 <gwern> ddarius: what were you after? I've ripped a fair bit on occasion
19:37:32 <gwern> (the whole compile-and-reload system, for starters :)
19:37:36 <ddarius> gwern: http://lambda-the-ultimate.org/node/2749#comment-41075
19:37:38 <lambdabot> Title: April 1st special: The War of the Worlds | Lambda the Ultimate
19:37:48 <gwern> hm. what *is* the point of the extensions: field in cabal files?
19:38:22 <Cale> gwern: To automatically apply those extension flags when compiling
19:38:51 <gwern> Cale: but, you already apply those with LANGUAGE pragmas
19:39:11 <Cale> You can, sure.
19:39:11 <Cale> More traditionally, they were applied with compiler flags.
19:39:24 <gwern> oh. so it's like the ghc-options: -fglasgow-exts/OPTIONS_GHC -fglasgow-exts thing?
19:39:31 <keseldude> Cale: It says imports.h doesn't exist (and it doesn't... even after pulling the latest version)
19:39:34 <gwern> one is per file the other per project?
19:39:43 <Cale> keseldude: where are you pulling from?
19:40:04 <keseldude> code.haskell.org/lambdabot iirc
19:40:14 <Cale> oh, look at that, it doesn't
19:40:24 <Cale> dammit darcs...
19:40:30 <keseldude> :P
19:41:43 <Cale> ... what the
19:41:58 <Cale> It says the file is already in the repository when clearly it can't be.
19:42:50 <keseldude> hmm
19:42:59 <Cale> I'll sort it out.
19:43:05 <keseldude> ok thank you :)
19:44:04 <Cale> okay try now :)
19:44:27 <Cale> (i.e. pull that patch :)
19:44:34 <Cale> er, hmm
19:45:00 <keseldude> :)
19:45:01 <Cale> You might need to symlink the imports.h into State/ but I'm not sure
19:45:15 <Cale> Let's see if I can get darcs to add that one too
19:45:44 <Cale> oh, huh
19:45:49 <Cale> It doesn't like symlinks.
19:46:12 <ddarius> Cale: What would happen if a Windows user pulled from your repository?
19:46:40 <Cale> ddarius: they would curl up into a ball and cry, because Windows was installed on their machine.
19:46:53 <ddarius> But what would darcs do?
19:47:09 <Cale> complain, or make a copy of the file
19:48:37 <Cale> Besides, doesn't windows have symbolic links now?
19:48:57 <keseldude> State/L.hs:4:0: error: State/imports.h: Too many levels of symbolic links
19:48:59 <keseldude> :S
19:49:17 <Cale> keseldude: where does that link point?
19:49:37 <Cale> keseldude: it should point to the imports.h in the parent directory
19:49:45 <keseldude> that's where it points
19:50:01 <Cale> and is the one in the parent directory a text file?
19:50:03 <keseldude> I haven't made symlinks in a while, but I'm pretty sure I didn't mess it up
19:50:12 <keseldude> $ ln -s imports.h State/imports.h
19:50:32 <mauke> ELOOP
19:50:35 <Cale> nope
19:50:39 <mauke> that points to itself
19:50:47 <keseldude> orly
19:50:51 <mauke> ya srsly
19:51:00 <Cale> You can ls -l the file to check
19:51:17 <SamB> it does, though
19:51:17 <mauke> ln -s ../imports.h State/imports.h
19:51:17 <Cale> cd State
19:51:19 <SamB> relative symlinks are not relative to where YOU are
19:51:22 <Cale> ln -s ../imports.h .
19:51:25 <SamB> they are relative to where THEY are
19:51:26 <keseldude> ooh
19:51:55 <SamB> which I find to be a perpetual nuisance
19:53:45 <piojo> hi, guys. I know that the ST monad is for writing imperative functions/algorithms... but it seems I cannot write "let {a=a+1}" but I can write "let {temp=a;a=temp+1}". is there something radically wrong with my approach?
19:54:00 <mauke> yes
19:54:09 <mauke> you're doing nothing with the ST monad
19:54:15 <mauke> that's just a normal recursive definition
19:54:25 <mauke> > let a = a + 1 in a
19:54:26 <lambdabot>  Exception: <<loop>>
19:54:35 <mauke> > let temp = a; a = temp + 1 in a
19:54:36 <lambdabot>  Exception: <<loop>>
19:54:39 <mauke> same thing
19:54:56 <keseldude> um Cale: what do I do with the lines v v v v v v v and *********** above describeSequence in L.hs?
19:55:07 <mauke> those are darcs merge conflict markers
19:55:27 <piojo> mauke: but in ST, I can define "a" beforehand, and works (because temp is defined based on the previous definition of "a")
19:55:37 <mauke> what?
19:56:36 <piojo> mauke: let {a = 0; ... do stuff with "a", then; temp = a; a = temp+1}
19:56:57 <mauke> that's invalid
19:57:05 <mauke> and it has nothing to do with ST
19:57:11 <gwern> keseldude: my rule of thumb is to do 'darcs revert', revert everything, and try again
19:57:19 <mauke> > let {a = 0; temp = a; a = temp+1} in a
19:57:20 <lambdabot>      Conflicting definitions for `a'
19:57:20 <lambdabot>     In the binding group for: a, temp, a
19:57:30 <keseldude> heh ok
19:57:33 <piojo> mauke: i used separate lets. i didn't realize that makes a difference
19:57:42 <piojo> within the same "do" block
19:57:45 <mauke> piojo: it creates nested scopes
19:57:59 <mauke> but it still won't change the value of an existing variable
19:59:06 <piojo> mauke: ahh. that's fine, actually. i don't really need it to change, i just need it to look like it has a new value for the rest of the function body. (i know what I'm doing is convoluted, it's because of a homework assignment that would be better written in C)
19:59:30 <piojo> mauke: basically, i'm having weird issues simply because i'm misusing haskell?
19:59:36 <Cale> keseldude: you decide which version you want to keep and delete the other
19:59:49 <mauke> piojo: what are you trying to do?
20:00:02 <keseldude> ah
20:00:24 <BMeph> piojo: In Soviet Russia, haskell misuses YOU! :)
20:00:32 <piojo> :)
20:00:36 <ddarius> piojo: You are having weird issues because you are misunderstanding Haskell (or at least monads).
20:00:53 <piojo> mauke: i'm just trying to write imperative code in haskell
20:00:58 <mauke> why?
20:01:11 <mauke> is that what the assignment says? :-)
20:01:43 <keseldude> yay no errors
20:01:44 <piojo> mauke: no, it just says to use  a high level language. i chose haskell because i want to practice something that's not straightforward
20:01:59 <mauke> so what are you trying to do?
20:02:16 <piojo> it's a short algorithm that calculates some cubes without any multiplication
20:02:27 <piojo> based on addition
20:02:59 <piojo> it's not a big deal--i'm not looking for a nicer way to solve the problem because the teacher won't understand it if i diverge too far from the (similar) algorithm in the book
20:03:00 <mauke> I don't think you need imperative code for that
20:03:12 <piojo> mauke: i really want to imitate the algorithm in the book, though
20:03:20 <mauke> usually you can keep your whole state in function parameters
20:03:34 <mauke> turn loops into recursive functions, etc
20:04:31 <piojo> mauke: i know i should, but just this time, i'm not trying to have good programming practice--i don't want my teacher not to be able to understand my code--he's a C and assembler guy
20:05:08 <mauke> then why does the assignment ask for high-level code?
20:05:18 <piojo> i'm not sure. i think he believes C is high level
20:05:21 <mauke> haha
20:05:28 <piojo> well, it's the first week of the course
20:05:32 <piojo> we don't know assembler yet
20:05:59 <mauke> :t runST
20:06:01 <lambdabot> forall a. (forall s. ST s a) -> a
20:06:06 <mauke> good luck explaining that
20:06:13 <piojo> i hope he doesn't ask me to...
20:06:19 <piojo> :)
20:06:35 <scook0> is there no easy way to define a pair of mutually recursive, abstract data types?
20:06:52 <piojo> mauke: thank you-- you did answer my two questions, even though i'm willfully writing with terrible style
20:06:52 <ddarius> scook0: ?  Just define them in the same module.
20:07:01 <scook0> ddarius: that's what I'm trying to avoid
20:07:21 <mauke> > let a = 0; a' = a + 1; a'' = a' + 1 in a''
20:07:22 <lambdabot>  2
20:07:28 <ddarius> scook0: Then you can have a module MyADT and a module MyADT.Internal that exports more.
20:07:30 <scook0> but I might be out of luck
20:07:49 <erg0t> piojo: nice nick xD
20:08:04 <ddarius> (after that, you just need to beat your head against recursive imports)
20:08:28 <piojo> piojo: thanks. a couple mexican friends of mine used to say i looked like piojo lopez, so i took it as a handle.
20:08:34 <scook0> it seems there's no "good" solution
20:08:58 <piojo> erg0t: oops: i copied my own nick instead of yours ^^^
20:09:05 <erg0t> you know what means "piojo"?
20:09:06 <ddarius> scook0: In this case, the "good" solution would be to have them be in the same module.
20:09:15 <piojo> erg0t: yeah =/
20:09:30 <scook0> but that has two problems:
20:09:39 <scook0> (1) they're not abstract with respect to each other
20:09:54 <scook0> (2) the module will become very large
20:10:23 <ddarius> scook0: If all you need is the interface, make them depend on interfaces (typeclasses) instead of the actual ADT.
20:11:10 <scook0> hmm, that might work
20:11:19 <scook0> though it would pollute the types a little
20:11:43 * scook0 feels like he has a knack for choosing problems that are not a good fit for Haskell :/
20:12:01 <gwern> hee hee. piojo is a louse?
20:12:56 <ddarius> scook0: That kind of issue is rather common across programming in general.  The solution I just described is a pretty typical one regardless of language.
20:14:36 * ddarius wonders if you can take the "fixpoint" of ML functors.
20:15:02 <keseldude> Cale: I'm getting the somewhat infamous setResourceLimit error now
20:15:22 <piojo> gwern: i'm not just any louse!
20:15:24 <Cale> keseldude: what platform?
20:15:53 <gwern> piojo: oh really? you seem like a pretty lousy louse
20:16:11 <piojo> gwern: haha, i haven't heard a good (bad) pun in a while
20:16:15 <Cale> keseldude: Do you have the file  scripts/Resource.hs ?
20:16:24 <gwern> I mean, who ever heard of a talking louse?
20:16:27 <keseldude> OS X 10.5.2 64 bit
20:16:30 <gwern> piojo: dude, you need to read some reddit then
20:16:34 <keseldude> yes, I do
20:16:37 <gwern> we've got puns all over the place
20:16:42 <hpaste>  keseldude pasted "lambdabot Resource.hs" at http://hpaste.org/6831
20:16:53 <Cale> yeah, that's the one
20:16:57 <ddarius> Reading reddit is not something anyone needs to do.
20:17:02 <piojo> gwern: i think i did see a pun on reddit a few days ago... i only read the programming page, though
20:17:58 <gwern> piojo: http://reddit.com/info/6e7v6/comments/ <-- I got some good ones in on this one recently
20:18:09 <Cale> keseldude: Someone submitted that as a fix for setResourceLimit. I'm not sure what might need to be done, but the basic idea is that setCPULimit n  should set a limit of n seconds.
20:18:36 <Cale> keseldude: The one in GHC might work, but it was broken on the machine where we're running lambdabot.
20:19:17 <keseldude> ah
20:19:35 <piojo> gwern: that is a weird, weird thread...
20:20:08 <ddarius> gwern... I have to say, when you sink below the level of 4chan there are issues
20:20:26 <gwern> piojo: that's why I liked it
20:20:54 <gwern> ddarius: don't judge me! don't you dare judge me! Ceiling_Cat KNOWS WHAT YOU DO
20:21:37 <keseldude> Cale: how do I use the one in GHC? :-[
20:22:00 <ari> What really makes me despair is the pun threads on reddit
20:23:36 <Cale> import System.Posix.Resource
20:23:53 <Cale> and then   setResourceLimit ResourceCPUTime (ResourceLimits n n)
20:24:08 <Cale> Thanks freenode
20:24:16 <keseldude> :P
20:24:20 <keseldude> in Resource.hs?
20:24:45 <Cale> Yeah, you could try replacing setCPULimit with that
20:24:50 <int80_h> is everyone back now?
20:25:09 <keseldude> except 'build' bugs me about not having setCPULimit
20:25:32 <vincenz> let fib n = let a = array (0,n) $ [(0,0), (1,1), (2,1)] ++ [(i,e) | i <- [3 .. n], let i' = i `div` 2, let e = (a!i')*(a!i'-1) + (a!i')*(a!i'+1)] in a ! n in fib 10000
20:25:34 <Cale> No, I mean replace the definition of setCPULimit such that it calls setResourceLimit
20:25:40 <keseldude> oh, I see
20:25:46 <vincenz> @bot
20:25:46 <lambdabot> :)
20:25:47 <Cale> setCPULimit n = setResourceLimit ResourceCPUTime (ResourceLimits n n)
20:25:54 * vincenz poke the bot
20:26:18 <Cale> > let fib n = let a = array (0,n) $ [(0,0), (1,1), (2,1)] ++ [(i,e) | i <- [3 .. n], let i' = i `div` 2, let e = (a!i')*(a!i'-1) + (a!i')*(a!i'+1)] in a ! n in fib 10000
20:26:19 <lambdabot>  5221944407065762533458763553583121912899821245236918901921167416419769539857...
20:26:25 <vincenz> > let fib n = let a = array (0,n) $ [(0,0), (1,1), (2,1)] ++ [(i,e) | i <- [3 .. n], let i' = i `div` 2, let e = (a!i')*(a!i'-1) + (a!i')*(a!i'+1)] in a ! n in fib 10000
20:26:26 <lambdabot>  5221944407065762533458763553583121912899821245236918901921167416419769539857...
20:26:29 <vincenz> > let fib n = let a = array (0,n) $ [(0,0), (1,1), (2,1)] ++ [(i,e) | i <- [3 .. n], let i' = i `div` 2, let e = (a!i')*(a!i'-1) + (a!i')*(a!i'+1)] in a ! n in fib 100000
20:26:30 <lambdabot>  1001764965203423232489536175780127875223912737784875709632508486855447029778...
20:26:39 <vincenz> fast enough or ya?
20:26:41 <vincenz> s/or/for
20:26:45 <vincenz> > let fib n = let a = array (0,n) $ [(0,0), (1,1), (2,1)] ++ [(i,e) | i <- [3 .. n], let i' = i `div` 2, let e = (a!i')*(a!i'-1) + (a!i')*(a!i'+1)] in a ! n in fib 1000000
20:26:47 <lambdabot>  1298185283915500388063298247863441413872367188174228023178682743387730526229...
20:27:02 <vincenz> 1000000th fibonnaci in < 3 seconds :)
20:27:27 <vincenz> > let fib n = let a = array (0,n) $ [(0,0), (1,1), (2,1)] ++ [(i,e) | i <- [3 .. n], let i' = i `div` 2, let e = (a!i')*(a!i'-1) + (a!i')*(a!i'+1)] in a ! n in fib 10000000
20:27:33 <lambdabot> Terminated
20:31:11 <BMeph> vincenz: bzzt ;)
20:31:20 <vincenz> I got 1Mth
20:31:21 <vincenz> just not 10Mt
20:37:05 <gwern> 'We know certain Ajax libraries are popular. Is JavaScript popular? It's hard to say. Some Ajax developers profess (and demonstrate) love for it. Yet many curse it, including me. I still think of it as a quickie love-child of C and Self. Dr. Johnson's words come to mind: "the part that is good is not original, and the part that is original is not good."'
20:37:52 <davidL> > fix((1:).scanl(+)1) !! 100000
20:37:54 <lambdabot>  Terminated
20:38:30 <davidL> > fix((1:).scanl(+)1) !! 1000
20:38:30 <lambdabot>  7033036771142281582183525487718354977018126983635873274260490508715453711819...
20:39:39 <glen_quagmire> > let {f l = 1 : l; a (x:xs) (y:ys) = (x+y) : a xs ys; } in fib 100000 where { fib n = take n s1; (s1, s2, s3) = (f s2, f s3, a s1 s2) }
20:39:39 <lambdabot>  Parse error at "where" (column 70)
20:40:31 <vincenz> won't work
20:40:34 <vincenz> my algorithm is sublinear
20:40:41 <vincenz> it's quadratic
20:40:44 <vincenz> (in the inverse sense)
20:40:48 <roconnor> @hoogle elem
20:40:48 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
20:40:48 <lambdabot> Data.List.elem :: Eq a => a -> [a] -> Bool
20:40:48 <lambdabot> Data.Foldable.elem :: (Foldable t, Eq a) => a -> t a -> Bool
20:43:21 <roconnor> @hoogle prefix
20:43:21 <lambdabot> Distribution.Simple.InstallDirs.prefix :: InstallDirs dir -> dir
20:43:22 <lambdabot> Data.Generics.Basics.Prefix :: Fixity
20:43:22 <lambdabot> Text.ParserCombinators.Parsec.Expr.Prefix :: GenParser t st (a -> a) -> Operator t st a
20:43:32 <roconnor> @hoogle hasprefix
20:43:32 <lambdabot> No matches found
20:43:44 <roconnor> @hoogle [a] -> [a] -> Bool
20:43:45 <lambdabot> Data.List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
20:43:45 <lambdabot> Data.List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
20:43:45 <lambdabot> Data.List.isInfixOf :: Eq a => [a] -> [a] -> Bool
20:44:20 <vincenz> for a language with has-a typing
20:44:26 <vincenz> curious it uses is-a naming
20:45:16 <roconnor> hasPrefixOf = flip isPrefixOf
20:46:08 <jsnx> what is the correct foreign declaration for `char* strings[]` ?
20:46:18 <jsnx> Ptr CString?
20:46:21 <mdmkolbe|ubuntu> I need to find the strongly connected components of a graph.  Is Data.Graph.Inductive the right tool to use?  Is there any good documentation for it?
20:46:31 <jsnx> Ptr Ptr CString?
20:47:11 <scook0> CString is Ptr CChar
20:47:23 <glen_quagmire> > let { f l = 1 : l; a (x:xs) (y:ys) = (x+y) : a xs ys; (s1, s2, s3) = (f s2, f s3, a s1 s2); fib n = s1 !! n; } in fib 100000
20:47:25 <lambdabot> Terminated
20:47:50 <scook0> so (I think) Ptr CString, or (equivalently) Ptr (Ptr CChar)
20:48:12 <jsnx> scook0: that's what i thought to...
20:48:52 <scook0> assuming I'm reading that C signature correctly
20:48:58 <ddarius> mdmkolbe|ubuntu: That would work.  Data.Graph is a simpler library that specifically has a function for SCCs (though I'm sure Data.Graph.Inductive does as well)
20:49:59 <mdmkolbe|ubuntu> ddarius: oh, I had assumed that D.G.I was the implementation of D.G.  I guess I'll use D.G; it has better docs, thx.
20:51:56 <elaforge> yaaa, Foreign.with doesn't zero out the memory it allocates.  event c++ tries to not return uninitialized memory...
20:52:01 <LordBrain> evening haskellers
20:59:45 <roconnor> @hoogle group
20:59:46 <lambdabot> Data.List.group :: Eq a => [a] -> [[a]]
20:59:46 <lambdabot> Data.ByteString.group :: ByteString -> [ByteString]
20:59:46 <lambdabot> Data.ByteString.Char8.group :: ByteString -> [ByteString]
20:59:54 <roconnor> @hoogle groupby
20:59:54 <lambdabot> Data.List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
20:59:54 <lambdabot> Data.ByteString.groupBy :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
20:59:54 <lambdabot> Data.ByteString.Char8.groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
21:00:04 <roconnor> @type on
21:00:09 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
21:01:09 <brad____`> interesting that some ByteString stuff just flew by, i want to use ByteStrings in a program i would otherwise use Strings...are there any functions on Strings missing from the ByteString lib these days? from what i can tell, everything is there
21:02:48 <mdmkolbe|ubuntu> Hmm, I in my graph I have two kinds of edges: weak and strong.  It would be nice if the SCC would report whether the SCC contains nodes with a strong edge between them.  Is there an easy way to do that or should I just do it as a post process path after the SCC algorithm?
21:05:29 <mae> hi
21:05:30 <BMeph> mdmkolbe|ubuntu: Maybe have a graph with just the strong edges, and one with all of them?
21:06:38 <mdmkolbe|ubuntu> well, the SCCs are determined by all the edges so I have to use all the edges, I just need to know if the SCC contains a strong edge.
21:07:05 <mdmkolbe|ubuntu> (If the SCC holds a strong edge, then it is an exception that I need to throw)
21:07:18 <mdmkolbe|ubuntu> (but weak edges in the SCC is fine)
21:07:31 <roconnor> @index on
21:07:31 <lambdabot> bzzt
21:07:40 <roconnor> @hoggle on
21:07:40 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
21:07:40 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
21:07:40 <lambdabot> Data.Function :: module
21:07:48 <roconnor> @src on
21:07:48 <lambdabot> (*) `on` f = \x y -> f x * f y
21:07:51 <vincenz> f on g x y = f (g x) (g y)
21:07:57 <vincenz> f `on` g x y = f (g x) (g y)
21:08:18 <vincenz> like
21:08:19 <roconnor> I still find Data.Function funny
21:08:21 <vincenz> compare `on` snd
21:08:30 <vincenz> yeah, funny name :)
21:08:33 <vincenz> since it's not really Data
21:09:21 <mae> herro
21:09:24 <mdmkolbe|ubuntu> vincenz: bah! functions are data
21:09:50 <roconnor> I think group is not a good function
21:09:57 <roconnor> I should write my own version
21:10:09 <vincenz> mdmkolbe|ubuntu: oh yeah?
21:10:16 <vincenz> mdmkolbe|ubuntu: then tell me how to get the values out of the closures
21:10:33 <mdmkolbe|ubuntu> vincenz: of course.  the closure is the value.
21:10:40 <vincenz> bah
21:10:47 <vincenz> function is ill-defined then
21:10:49 <mdmkolbe|ubuntu> first class functions means that code is data
21:11:00 <vincenz> no it doesn't
21:11:05 <vincenz> it means that a pointer to code is data
21:11:08 <vincenz> that's not so novel
21:11:10 <vincenz> you can do taht in C
21:11:23 <vincenz> people just like to hype a lot around it
21:11:24 <mdmkolbe|ubuntu> I never said it was novel
21:11:51 <BMeph> roconnor: What's so not good about it? :)
21:12:15 <mdmkolbe|ubuntu> the connection becomes really strong with things like church numerals etc in which data and code are the same things
21:12:17 <roconnor> BMeph: the lists are always non empty, and always the same.
21:12:20 <vincenz> BMeph: it works oddly on ill-defined equalities
21:12:31 <mae> name one thing i can do in haskell where i don't go "aww damn, you mean i have to build the platform because it doesn't exist?"
21:12:31 <roconnor> BMeph: the resulting data structure just isn't useful as is
21:12:51 <roconnor> I always want a "header" on my group saying the name of the group they are in.
21:12:59 <roconnor> (after using groupBy)
21:13:08 <vincenz> roconnor: so something like
21:13:26 <vincenz> > map (head *** id) . groupBy (==) $ [1,1,2,2,3,3,3,]
21:13:27 <lambdabot>  Parse error at "]" (column 51)
21:13:28 <vincenz> > map (head *** id) . groupBy (==) $ [1,1,2,2,3,3,3]
21:13:30 <lambdabot>  Couldn't match expected type `([a], b')'
21:13:36 <vincenz> > map (head &&& id) . groupBy (==) $ [1,1,2,2,3,3,3]
21:13:36 <lambdabot>  [(1,[1,1]),(2,[2,2]),(3,[3,3,3])]
21:14:00 <roconnor> vincenz: throw in a little `on` and you have it
21:14:33 <roconnor> map (f . head &&& id) . groupBy ((==) `on` f)
21:14:40 <vincenz> yeah
21:14:42 <vincenz> I Was going to write that :)
21:14:46 <vincenz> f is the accessor :)
21:14:47 <roconnor> that is a useful function
21:14:56 <vincenz> though I Wonder
21:14:57 <vincenz> is it
21:15:07 <vincenz> (f . head &&& id) or ((f . head ) &&& id)
21:15:19 <roconnor> ((f . head ) &&& id)
21:15:26 <vincenz> I mean, which binds more tightly.
21:15:30 <roconnor> oh
21:15:32 <roconnor> who knows
21:15:48 <vincenz> The second is correct yes, but too many ugly () :)
21:15:51 <scook0> (.) is level 9
21:16:01 <scook0> (&&&) is level 3
21:16:11 <vincenz> 9?
21:16:13 <vincenz> that's quite a lot
21:16:23 <vincenz> so . trumps everything except f-app
21:16:30 <scook0> yeah
21:16:36 <vincenz> neat :)
21:16:41 <scook0> actually, just yesterday I was trying to find an example of a 9
21:16:45 <vincenz> that makes pointle programming even easier.
21:16:50 <vincenz> pointless
21:17:02 <scook0> but I didn't realise that (.) was one
21:17:21 <scook0> (^) is 8, for example
21:17:26 <allbery_b> ($) ?
21:17:34 <scook0> 0
21:17:37 <allbery_b> wait, thats 0
21:17:38 <allbery_b> yeh
21:17:50 * allbery_b is evidently running in reverse tonight
21:18:20 <scook0> I thought of ($) too, but managed to stop myself before saying anything :)
21:19:04 <idnar> heh
21:19:32 <newsham> what are the numbres you're talking of?
21:19:34 <vincenz> I really love how people say that function-application is the 'space' operator
21:19:38 <vincenz> newsham: priorities
21:19:53 <scook0> oh, hackage is back up! \o/
21:20:13 <newsham> oh, i thought it was something deep and mathematical.
21:20:48 <BMeph> newsham: rather, operator precedence.
21:21:14 <TomMD> up... down... up... down... is this a server or a stock?
21:21:27 <BMeph> It's maybe 'quasi-mathematical'. Or would that be meta-mathematical? :)
21:21:27 * vincenz aughs
21:21:34 <vincenz> There's this webpage on the programming language 'Anub's
21:21:46 <vincenz> it actually has 'determinism' as one of the core programming techniques.
21:21:58 <roconnor> vincenz: I once told someone that white space associates to the left.  He almost left the room at that point.
21:22:37 <vincenz> roconnor: the whole 'white-space' thing is rather novel to me since a coupleh of months.  It's an interesting way to look at it, and rather accurate since mathematicians do actually use a different symbol for f-app
21:22:59 <scook0> "juxtaposition" seems more appropriate than "whitespace"
21:23:18 <vincenz> say that to the inventors of the programming language 'whitespace'
21:24:40 <allbery_b> juxtaposition is accurate; you're talking tokens.  of course in WHitespace the roles of token and space are swapped...
21:24:55 <vincenz> or rather, unified :)
21:24:56 <allbery_b> er, the roles of space and noon-space are swapped in the defintion of tokens
21:25:47 <vincenz> It would be really neat.  I coud be writing this text to you   right     now and   you wouldn't know    that      it secretively      contains  code    .
21:26:28 <mauke> push 0?
21:26:35 <newsham> > (unwords.words) "right     now and   you wouldn't know    that      it secretively"
21:26:36 <lambdabot>  "right now and you wouldn't know that it secretively"
21:26:40 <roconnor> vincenz: kinda looks like DeCSS.  you are under arrest buddy.
21:28:07 <edwardk> hrmm. anyone around who knows enough category theory to be dangerous and has ghc 6.9 installed that wants to look at a bunch of CT in haskell stuff?
21:28:31 <roconnor> @type getArgs
21:28:33 <lambdabot> Not in scope: `getArgs'
21:28:35 <edwardk> http://comonad.com/haskell/categories/dist/doc/html/categories/index.html and http://comonad.com/haskell/categories/ (I think the darcs repo will download fine, but i haven't tested it)
21:28:37 <lambdabot> http://tinyurl.com/6gzdxb
21:28:38 <roconnor> @hoogle args
21:28:39 <lambdabot> Distribution.Simple.Args :: type Args
21:28:39 <lambdabot> Data.Typeable.typeRepArgs :: TypeRep -> [TypeRep]
21:28:39 <lambdabot> GHC.Environment.getFullArgs :: IO [String]
21:28:52 <roconnor> @hoogle IO [String]
21:28:52 <lambdabot> GHC.Environment.getFullArgs :: IO [String]
21:28:52 <lambdabot> System.Environment.getArgs :: IO [String]
21:29:32 <edwardk> (it needs 6.9 coz i'm using class associated types for initial and terminal objects, products, sums, exponentials, coexponentials, so that i can do things like dual categories
21:35:35 * edwardk watches as the entire channel falls asleep ;)
21:39:18 <gwern> edwardk: where's Control.Category.Based? is that provided by 6.9?
21:39:33 <edwardk> gwen: i probably forgot to add it to darcs, one sec.
21:39:51 <edwardk> looks like i did, one sec
21:41:24 <gwern> forgot Control.Category.Bifunctor.Monoidal too
21:41:32 * shapr throws lambdas at edwardk 
21:41:32 <edwardk> gah
21:41:39 * gwern suggests maybe a 'darcs add -r *'
21:42:49 <edwardk> there =)
21:43:15 <edwardk> i was missing quite a few of them. monoidal, pentagonal, cartesian, comma, algebra, instances, and kleisli =/
21:43:41 <roconnor> @hoogle delay
21:43:42 <lambdabot> GHC.Conc.threadDelay :: Int -> IO ()
21:43:42 <lambdabot> GHC.Conc.registerDelay :: Int -> IO (TVar Bool)
21:43:42 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
21:43:46 * gwern will check...
21:43:54 * edwardk dodges the lambdas (somewhat belatedly)
21:44:06 <gwern> ok, now it errors at no Control.Category
21:44:12 <edwardk> yay =)
21:44:17 <gwern> which is probably because I'm on 6.8.2
21:44:54 <edwardk> yeah, Control.Category is in 6.9, added around october this last year, and the rest of this needs type families (which only works in 6.9)
21:45:16 <roconnor> > maxBound
21:45:17 <lambdabot>  ()
21:45:20 <roconnor> > maxBound :: Int
21:45:21 <lambdabot>  2147483647
21:45:35 <roconnor> @go 2147483647 mircoseconds
21:45:36 <lambdabot> No Result Found.
21:45:39 <edwardk> Control.Category is just "class Category k where id :: k a a; (.) :: k b c -> k a b -> k a c" and definitions for (<<<) and (>>>) in terms of (.)
21:45:41 <roconnor> @go 2147483647 mircoseconds in minutes
21:45:42 <lambdabot> No Result Found.
21:45:54 <edwardk> but the class associated types will kill it pretty much dead in 6.8 iirc
21:45:57 <shapr> roconnor: mircoseconds?
21:46:14 <gwern> fair enough. I've been meeaning to pull a fresh ghc
21:46:24 <edwardk> writing this was my motivation. ;)
21:46:24 <roconnor> @go 2147483647 microseconds
21:46:32 <edwardk> i was running like 6.6 before
21:46:33 <edwardk> =)
21:46:40 <lambdabot> Plugin `search' failed with: thread killed
21:46:49 <roconnor> @go 2147483647 microseconds in minutes
21:46:50 <lambdabot> 2,147,483,647 microseconds = 35.7913941 minutes
21:46:59 <roconnor> hm
21:47:15 <NekoIncardine> ... Do I want to know? O_o;
21:47:20 <roconnor> Can thread delay can only wait upto half an hour?
21:47:31 <roconnor> is that a posix thing?
21:47:38 <dons> roconnor: its weird, no?
21:47:38 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
21:47:50 <roconnor> dons: seems error-prone
21:47:52 <dons> well, its an Int thing, and yeah, only half an hour
21:47:57 <dons> combine them :)
21:48:09 <dons> do threadDelay maxBound ; threadDelay maxBound
21:48:20 <roconnor> dons: each threadDelay command introduces more error
21:48:23 <roconnor> :P
21:48:34 <dons> an Integer threadDelay that was atomic would be nice, hiding the underlying threadDelay
21:49:00 <roconnor> dons: is it a posix thing?
21:49:02 <dons> i think it could be written fairly easily
21:49:07 <TomMD> roconnor: You can schedule actions for later times using control-timeout or control-event.
21:49:09 <dons> well, not sure if its posix, or a runtime choice
21:49:28 <dons> roconnor: oh, note, that on 64 bits its not half an hour, is it?
21:49:45 <roconnor> nope
21:49:46 <edwardk> ok, so now that most of the basics work, next step, fixed points, recursion, free/cofree monads/comonads, and a bunch of category transformers
21:49:47 <ddarius> :t threadDelay
21:49:48 <lambdabot> Not in scope: `threadDelay'
21:49:52 <dons> its an Int
21:49:54 <ddarius> @hoogle threadDelay
21:49:54 <lambdabot> GHC.Conc.threadDelay :: Int -> IO ()
21:49:54 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
21:49:57 <dons> so 64 bits
21:50:31 <dons> delay# time# s
21:50:37 <dons> :t GHC.Prim.delay#
21:50:37 <lambdabot> forall d. GHC.Prim.Int# -> GHC.Prim.State# d -> GHC.Prim.State# d
21:50:47 <dons> ok, that's fine.
21:50:50 <roconnor> @go 2^63 microseconds in years
21:50:50 <lambdabot> (2^63) microseconds = 292,277.266 years
21:51:06 <ddarius> The Pentium rdtsc uses 64-bits and counts ticks if I remember correctly.
21:51:17 <dons> so that might effect a long running xmonad session
21:53:33 <roconnor> @src forever
21:53:33 <lambdabot> Source not found. That's something I cannot allow to happen.
21:53:43 <dons> forever a = a >> forever a
21:53:53 <ddarius> fix . (>>)
21:56:49 <roconnor> @type when
21:56:50 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
21:57:10 <newsham> dons > lambdabot
21:58:04 <dons> its more of a symbiotic relationship
21:58:38 <roconnor> @type maybe
21:58:39 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
21:58:46 <roconnor> @type fromMaybe
21:58:47 <lambdabot> forall a. a -> Maybe a -> a
21:59:45 <Cale> http://www.mazapan.se/games/BurnTheRope.php :)
21:59:47 <lambdabot> Title: Mazapn.se - You Have To Burn The Rope
22:02:31 <Cale> Games for those with extremely short attention spans.
22:03:22 <dons> Cale, have you see 'phun' ?
22:03:38 <dons> http://www.vrlab.umu.se/research/phun/ see also youtube
22:03:39 <lambdabot> Title: Phun - visual and interactive 2D physics - VRlab - Ume&aring; University
22:04:01 <dons> its really weirdly addictive building little 2d machines
22:04:04 <Cale> Ah, yeah :)
22:04:25 <Cale> http://magic.pen.fizzlebot.com/ -- in a similar vein :)
22:04:26 <lambdabot> Title: Magic Pen by Alejandro Guillen
22:06:45 <paczesiowa> is it possible to catch errors/exceptions (like undefined) inside gtk app, display them inside same dialog and return to event processing loop?
22:08:10 <dons> yeah, if you're in IO
22:08:14 <roconnor> ``terminateProcess should not be used under normal circumstances''
22:08:16 <dons> use Control.Exception.catch
22:08:23 <roconnor> What should be used under normal circumstances?
22:08:46 <Cale> Catching exceptions thrown from pure code is difficult and not generally worthwhile.
22:09:49 <NekoIncardine> All right... Time for me to get serious on fixing and setting up this Sudoku solver. X_;
22:10:16 <dons> its useful in some interactive apps, to ensure things never crash
22:10:27 <dons> much better to say, try again, than to lose work
22:10:55 <NekoIncardine> http://hpaste.org/6827 <- This throws a Type Error at line 17, expecting "Array Integer Tile" and getting "[Char]". I'm not really sure where to begin fixing this...
22:12:27 <NekoIncardine> My first question: Lines 19 and 20 are two separate statements. Am I handling that in the proper fashion, or do I need to attempt to merge them into one statement?
22:12:47 <NekoIncardine> (Similarly lines 23 and 24, etc.)
22:13:21 <bos> any users of Data.Generics around?
22:13:49 <NekoIncardine> Oh, yes... I'm told (user)++ is the way to thank people around here. Is that correct? :)
22:14:05 <TSC`> NekoIncardine: Your type for makeBoard says it takes 1 argument (a "Board") but then you have "makeBoard x y = ..."
22:14:30 <NekoIncardine> ... Really? The way I heard it described earlier, I needed two types. o_o
22:14:42 <NekoIncardine> Erm, that method was for two input types that is
22:15:08 <TSC> What is the function supposed to do?
22:16:01 <shachaf> @karma (user)
22:16:01 <lambdabot> (user) has a karma of 1
22:16:04 <NekoIncardine> It is supposed to take the first character out of the [Char] (head y); if that character is 1, then it appends a new Unsolved to Board, with just '1' as the Array contents
22:16:48 <NekoIncardine> Once I have it fixed for this first case there will be similar ones for '2' .. '9'.
22:17:16 <NekoIncardine> If the character is ' ', then it instead adds an Unsolved with the 'freshtile' string as the Array contents.
22:17:48 <NekoIncardine> I'm immediately getting the sense I've mixed up types, a LOT, which I'm guessing is the first piece of the issue.
22:18:01 <NekoIncardine> But I'm not even sure I have the commands formatted correctly and wish to figure that out as well.
22:19:03 <TSC> What should makeBoard return?
22:19:18 <NekoIncardine> Ultimately, it should return a Board containing 81 tiles.
22:19:38 <NekoIncardine> (In other words, a Sudoku board with no progress made towards a solution.)
22:20:34 <NekoIncardine> The tiles are a one-dimensional array or list, as I found it easier to just assign one number and use a few commands (that I didn't paste in) to figure out which row/column/group the tile is in.
22:21:08 <TSC> But makeBoard will never finish; it always calls itself
22:21:10 <NekoIncardine> I have verified that those commands work since they're just Integer -> Integer ... And suddenly part of the MakeBoard problem's clear to me.
22:21:28 <paczesiowa> catching exceptions seems to work only per (e.g.) button click basis (catching exceptions inside every button click handler) , ins't it possible to catch all error with smth like: "mainGUI `Control.Exception.catch` \e -> print e >> mainGUI" ?
22:22:13 <NekoIncardine> makeBoard :: Board -> [Char] Should be: makeBoard :: Board [Char] -> Board, correct?
22:22:30 <TSC> I think Board -> [Char] -> Board
22:23:09 * NekoIncardine needs to add an if/then/else case for returning now too, he sees... Or to wit, makeBoard x [], correct?
22:23:13 <idnar> Board [Char] -> Board is a kind error
22:23:47 <NekoIncardine> " makeBoard x [] = x" means that if the [Char] list is empty, return x, correct?
22:24:06 <TSC> That's right
22:24:42 <glguy> > "\42\&3"
22:24:46 <lambdabot>  "*3"
22:25:25 <hpaste>  NekoIncardine pasted "makeBoard take 3" at http://hpaste.org/6832
22:25:47 <TSC> You can add to your existing pastes with annotate, by the way
22:25:52 <NekoIncardine> Oh.
22:25:57 <NekoIncardine> ... I'll remember that after this x_x
22:26:29 <NekoIncardine> Either way, I also changed line 20's 'then' line, trying to merge what was two separate functions into one.
22:26:42 <NekoIncardine> I'm not sure I have the format right at all though, is part of the problem.
22:27:35 <TSC> You don't seem to have it quite right (:
22:27:55 <NekoIncardine> data Tile = Solved Integer | Unsolved [Char]
22:27:56 <NekoIncardine> data Board = Board [Tile]
22:27:58 <NekoIncardine> ^- Would this be more accurate for the top lines if I wish to manipulate lists?
22:28:01 <ivanm> is it just me, or is the lambdacatz site down?
22:28:14 <TSC> NekoIncardine: If you're still learning, lists are definitely better than arrays
22:28:31 <NekoIncardine> All right. *Switches both to lsits*
22:28:43 <TSC> However, why not "data Tile = Solved Integer | Unsolved [Integer]" ?
22:28:45 <NekoIncardine> Now, though, I still have to figure out how to make the makeBoard calls do what I desire.
22:29:42 <NekoIncardine> TSC: Hrm... Either way could work. Thinking in chars is advantageous for the literal sudoku definition (where '1'..'9' could be "abcdefghi" or nine shapes as well)
22:29:50 <TSC> Sure
22:29:57 <TSC> My point was that they ought to be the same
22:30:07 <NekoIncardine> Hrm.
22:30:19 <NekoIncardine> That is a point I didn't consider.
22:30:30 <NekoIncardine> Hrm... Both Char or both Integer though.
22:30:42 <NekoIncardine> Dammit, don't have my coinflip script handy in chatzilla!
22:31:08 <NekoIncardine> *Flips a real coin instead, goes Integer*
22:31:40 <roconnor> Hmm, I need a module for transparently handling persestent HTTP connections.
22:31:46 <NekoIncardine> Helps differentiate the I/O components (which makeBoard is the second-to-last step of, behind printing the end result)
22:31:52 <NekoIncardine> From the actual code.
22:32:12 <NekoIncardine> Next, though... The intent of the main portion of the makeBoard code.
22:32:42 <TSC> Ohhhhh
22:32:52 <TSC> Now, I think I know what it's supposed to do
22:33:10 <TSC> It takes a list of characters (one per square) and transforms it into your Board data type
22:33:12 <TSC> Is that right?
22:33:14 <NekoIncardine> In pseudocode: IF ( head y == '1'..'9' ) THEN makeBoard (input Board with Unsolved(that character) added to the end) (tail y)
22:33:18 <NekoIncardine> Correct.
22:33:24 <NekoIncardine> Quite literally making the board.
22:34:00 <TSC> If the character is given (1-9), shouldn't it be "Solved" instead of "Unsolved" ?
22:34:04 <TSC> (for that tile)
22:35:57 <NekoIncardine> The idea is that a tile isn't "Solved" until there's only one character left, *AND* that tile has been removed from the possibilities in the rest of that row/column/group
22:36:16 <TSC> Ok
22:37:03 <NekoIncardine> I may be taking an unintuitive route there, I'm not 100% sure, I just decided on what made sense to me.
22:37:13 <TSC> That seems reasonable to me
22:37:49 <TSC> It seems like in makeBoard you are trying to build up the Board, and then return it when it's finished
22:38:02 <NekoIncardine> Correct. "Finished" meaning "all 81 tiles put in place"
22:38:06 <TSC> Right
22:38:28 <NekoIncardine> Technically I should have a second piece in there to test the length of the board to verify validity; I'll wait on that until the main part's finished.
22:38:39 <TSC> And the first parameter is an "accumulator" where you build up the board
22:38:56 <NekoIncardine> If I'm reading the word choice correctly, yes.
22:39:16 <TSC> You can do this without an accumulator, and it will probably be easier
22:39:35 <TSC> That is, the type should be "[Char] -> Board", which matches what the function should do
22:39:47 <hpaste>  (anonymous) annotated "makeBoard take 3" with "(no title)" at http://hpaste.org/6832#a1
22:40:12 <NekoIncardine> Hrm.
22:41:05 <NekoIncardine> So there's a recursive method for makeBoard :: [Char] -> Board to create the full board?
22:41:17 <TSC> That's right
22:41:28 <NekoIncardine> Hrm.
22:42:06 <NekoIncardine> The first question I have, then, is the 'base case'; makeBoard [] doesn't have any input indicating a board. How do I get the Board out of that? O_o;
22:42:37 <NekoIncardine> In the Board->Char->Board method, it's simply "makeBoard x [] = x", but here?
22:42:40 <TSC> makeBoard [] = Board []
22:42:49 <TSC> That is, an empty input gives an empty board
22:43:26 <NekoIncardine> ... Which means that when I empty the list out, I end up with an empty board? I'm not seeing the logic.
22:43:48 <TSC> Are you familiar with the function "map" ?
22:44:09 <NekoIncardine> I have not read anything on it in the tutorials I have viewed, no.
22:44:33 <reltuk> does anyone know how relative paths in package.conf files are interpreted?
22:45:10 <TSC> NekoIncardine: map does something similar (but not quite the same) as what you're trying to do
22:45:20 <NekoIncardine> Hrm.
22:45:26 <TSC> > let f x = x + 1 in map f [1,2,3,4]
22:45:27 <lambdabot>  [2,3,4,5]
22:45:42 <TSC> But the important bit is:
22:45:44 <TSC> @src map
22:45:44 <lambdabot> map _ []     = []
22:45:44 <lambdabot> map f (x:xs) = f x : map f xs
22:46:07 <NekoIncardine> Hrm. o_O
22:46:22 <TSC> The first case says, if the input list is empty, return an empty list
22:46:41 <NekoIncardine> MAkes sense.
22:47:05 <TSC> The second case says: take the first element, do something to it, process the rest of the list, then glue the "processed first element" to the "processed rest" and return that
22:47:06 <NekoIncardine> The second case, then, says "map FUNCTION (LIst)", Do function on list's first item, then map on the rest of the list?
22:47:18 <TSC> Yep
22:53:25 <sieni> hmm... I wonder why freenode does a ctcp version request on connect
22:53:47 <sieni> at least my version string isn't that informative
22:54:18 * NekoIncardine distracted...
22:54:31 <TSC> Big Freenode Brother wants your version info
22:54:53 <NekoIncardine> Sieni: I think it's to watch for different sorts of bot. I know that they give you a warning if you're using SysReset mIRC to disable any Fserv functions you may have.
22:55:52 <sieni> well, at least on irssi you can just set your version string to whatever you want which I have promptly done because of idiots doing a /ctcp version on a whole channel
23:00:10 <NekoIncardine> Hrm...
23:01:11 * sieni is out of fags
23:01:43 <Riastradh> Is there something wrong with CTCP version requests?
23:01:48 <NekoIncardine> So if I'm getting you correctly, TSC, "makeBoard y = map (add char to Board, possibly with a separate parsing method) y" ?
23:02:14 <NekoIncardine> Riastradh: To some IRC-goers, it's a sign of disrespect, as it indicates suspicion of bot, FServe, etc. use without cause.
23:02:22 <TSC> Yeah, if you filter out the "bad" characters first (newlines and such)
23:02:46 <TSC> Then you can write a function to convert a single character to a tile, then use it with map
23:02:50 <mauke> I use ctcp version to determine someone's OS
23:03:07 <NekoIncardine> Ah... A case function would make that simple indeed.
23:03:27 <Riastradh> Whole-channel CTCP versions are often done out of curiosity concerning the relative usage of different IRC clients.
23:03:57 <NekoIncardine> "map charToTile y" if the method were charToTile would be the correct form, correct?
23:04:27 <TSC> That's right
23:04:44 <sieni> Riastradh: I don't mind people doing /ctcp version requests for a single nick, but doing it for a whole 400 person channel doesn't serve any benign purpose
23:04:44 <NekoIncardine> ... Except how do I then conver that into a Board. I'll have an array of tiles, but not the actual Board form.
23:05:09 <TSC> A list of tiles, you mean
23:05:16 <NekoIncardine> Correct.
23:05:18 <Riastradh> sieni, why not?  Is there something wrong with being curious about the distribution of clients in a channel?
23:05:36 <TSC> The "Board" data constructor will convert the list of Tiles into the Board type
23:05:49 <NekoIncardine> Riastradh: Again, see my comment about disrespect. Additionally, in the wake of active spying on IRC in some areas for varied malign purposes.
23:06:03 <NekoIncardine> TSC: Ah.
23:08:26 <sieni> Riastradh: well, I guess I don't get mad if a well known person on a channel does a request like that, but I do get annoyed when people I barely know do such mass requests
23:08:47 * glguy tries to figure out how this topic even arose
23:09:05 <sieni> glguy: blame me ,-)
23:09:17 <shachaf> glguy: <sieni> hmm... I wonder why freenode does a ctcp version request on connect
23:09:27 <Riastradh> Sorry; I'll shut up now -- this is not Haskell-related.
23:09:35 <glguy> if you don't like CTCP requests.. turn them off, if you don't like unsolicited privmsgs... turn them off. if you don
23:09:40 <glguy> 't like _ turn it off
23:12:22 <sieni> glguy: yes, I have a made up version string
23:13:03 <glguy> :( I can't seem to get it to send to me
23:13:17 <hpaste>  NekoIncardine annotated "makeBoard take 3" with "makeBoard take 5 (and other commands now!)" at http://hpaste.org/6832#a2
23:14:44 <TSC> "makeBoard y :: map charToTile y" is a bit wrong
23:14:50 <Cale> NekoIncardine: It looks like there are tabs in your file, just so you're aware
23:14:56 <TSC> First, it should be "=" instead of "::"
23:15:12 <sieni> hmm interesting
23:15:14 <TSC> Second, you need to use the Board data constructor to construct the Board from the list
23:15:18 <NekoIncardine> CAle: YEs... DIdn't realize that was an issue. o_O
23:15:33 <Cale> NekoIncardine: It can be, since alignment of things can matter.
23:15:42 <sieni> glguy: try again now
23:15:47 <NekoIncardine> Ah... I thought tabbing was how you handled Alignment.
23:15:52 <Cale> NekoIncardine: It's best to get your editor to automatically convert them to spaces.
23:15:54 <glguy> hurray :)
23:16:03 * NekoIncardine just spaces manually.
23:16:11 <Cale> NekoIncardine: well, it doesn't mix nicely when the first thing you have to align with has other characters before it
23:16:27 <NekoIncardine> Hrm... What's the common number of spaces, for reference?
23:16:38 <sieni> glguy: apparently the privmsg filtering for unregistered users on freenode also filters ctcp version replies :-D
23:16:43 <Cale> Also, the Haskell compiler will treat tabs as aligning to the next 8-space boundary.
23:16:44 <NekoIncardine> In C it is tabbing, in Java it's two spaces..
23:17:08 <elaforge> I think ghc should disallow mixed tab/space
23:17:19 <Cale> Usually we just use 2 or 3 spaces indentation, but more often we 'hang' things off of wherever they started.
23:17:30 <Cale> elaforge: I think ghc should disallow tabs altogether.
23:17:35 <sieni> elaforge: well, it would be against the haskell standard
23:18:02 <elaforge> Cale, they're useful when you use proportional fonts
23:18:11 <TSC> It should be a SIN
23:18:14 <elaforge> lispindent style hanging off doesn't work with those either
23:18:14 <Cale> http://reddit.com/info/6emth/comments/c03mspn -- this (which I wrote just today), explains how indentation works in Haskell.
23:18:49 <Cale> elaforge: You shouldn't be using proportional fonts with Haskell unless your editor is sufficiently advanced to parse it :)
23:19:11 <elaforge> Cale, but I do, and I like them
23:19:14 <Cale> It would actually be pretty interesting to have an editor which knew about the layout rule and blocks :)
23:19:21 <hpaste>  travisbrady pasted "Cabal problem" at http://hpaste.org/6833
23:19:31 <elaforge> and *you* try to get rob pike to add a haskell parser to acme :P
23:19:55 <travisbrady> i'm trying to install bytestring-mmap and finding lots of problems with Cabal, this is on 6.8.2
23:20:28 <travisbrady> mac os 10.5, the package Manuel Chakravarty put together
23:21:09 <NekoIncardine> TSC: "makeBoard y = Board (map charToTile y)" <- Is that what I should be going for?
23:21:42 <TSC> Yep
23:22:15 <NekoIncardine> ERROR file:.\TestIchi.hs:36 - Inferred type is not general enough <- The new error I'm getting. (36 = the first caseline in charToTile)
23:22:21 <Cale> travisbrady: I wonder where you should get libdl from...
23:22:30 <NekoIncardine> ... Oh.
23:22:34 <NekoIncardine> I need to line them up. X-x
23:22:51 <travisbrady> Cale: how do you mean?  could it be a path thing?
23:23:17 <NekoIncardine> .... Which didn't fix the glitch.
23:23:21 <NekoIncardine> While I'm thinking about this:
23:23:23 <NekoIncardine> Cale++
23:23:24 <NekoIncardine> TSC++
23:23:30 <NekoIncardine> ^- Like that for Karma increases correct?
23:23:35 <Cale> yeah
23:23:39 <Cale> can't load .so/.DLL for: dl (dlopen(libdl.dylib, 10): image not found)
23:23:49 <Cale> travisbrady: that's the error you're getting, right?
23:24:04 <travisbrady> Cale: yes
23:24:15 <Cale> So that sounds like the library is missing.
23:24:21 <travisbrady> Cale: i also get loads of problems when trying to use runhaskell
23:26:29 <travisbrady> Cale: hmm, i have that file in 3 spots on my machine, one of which is on my path
23:27:27 <hpaste>  NekoIncardine annotated "makeBoard take 3" with "makeBoard take 6" at http://hpaste.org/6832#a3
23:27:29 <Cale> Is either of them /usr/lib or /usr/local/lib ?
23:29:11 <Cale> travisbrady: I don't know how the OS X ld search path is configured, but some apple documentation is telling me that those two directories are the default.
23:29:48 <NekoIncardine> So now, my question is, charToTile seems to report a glitch on the first case-checking line, where the Inferred Type is not general enough.
23:30:03 <NekoIncardine> To wit, in that new iteration:
23:30:07 <travisbrady> Cale: /usr/lib yes
23:30:10 <NekoIncardine> ERROR file:.\TestIchi.hs:21 - Inferred type is not general enough
23:30:12 <NekoIncardine> *** Expression    : charToTile
23:30:14 <NekoIncardine> *** Expected type : a -> Tile
23:30:16 <NekoIncardine> *** Inferred type : Char -> Tile
23:30:21 <Cale> NekoIncardine: char, because it's not capitalised, is a type variable
23:30:53 <NekoIncardine> ... God damn it. AFter three years of doing stupid capitalization glitches in every programming language I have ever used, you would THINK I would know better.
23:30:55 <Cale> NekoIncardine: hence, you're telling it that charToTile takes a parameter of any type at all :)
23:31:55 <elaforge> Cale, at one point I wanted to a lispindent tab style that would set the tabstops to the "usual" places, depending on the current sexpr
23:32:08 <elaforge> Cale, it would be the only way to line things up right with proportional fonts
23:32:31 * NekoIncardine fixes the difference between 1 and [1] manually on a guess... Whoo! It now loads!
23:33:22 <NekoIncardine> Next up, a print method for OUTPUTTING a board.
23:33:33 <hpaste>  Cale annotated "makeBoard take 3" with "more readable definition of your default board" at http://hpaste.org/6832#a4
23:34:23 <NekoIncardine> Thank you muchly for that, Cale. I'll quickly switch that in, and start looking through the tutorials and figuring out the output format.
23:34:49 <Cale> NekoIncardine: Well, a board at present is just a string?
23:35:00 <Cale> NekoIncardine: Or a list of tiles?
23:35:00 <NekoIncardine> If it is entirely solved, yes.
23:35:13 <NekoIncardine> It's a list of tiles, any one of which can be either solved (an integer) or unsolved (a list of integers)
23:35:53 <Cale> Okay, so we probably want to output spaces or something for unsolved spots.
23:36:07 <Cale> Unless you want to try and get fancy.
23:36:23 <NekoIncardine> Nah. I'd confuse myself AND my teacher getting fancy ;P
23:37:01 <Cale> So to do that, you're going to map a function over the list of tiles, which is going to turn each tile into a character.
23:37:17 <Cale> Then you'll probably want to chop the list up into 9 lists of length 9
23:37:27 <NekoIncardine> Then just output those?
23:37:28 <Cale> and then display those as separate lines
23:38:01 <NekoIncardine> That's three basic steps. Board -> [Char], [Char] -> [[Char]] (LIst of List of chars?), then actually printing.
23:38:51 <NekoIncardine> The second one is a pure guess of course.
23:40:39 <Cale> yeah
23:41:30 <Cale> For actually printing, you might want to use the function  putStrLn, along with the function unlines
23:41:42 <Cale> > unlines ["Hello", "there", "world!"]
23:41:46 <lambdabot>  "Hello\nthere\nworld!\n"
23:42:09 <Cale> :t putStrLn
23:42:10 <lambdabot> String -> IO ()
23:42:30 <Cale> (It takes a string, and gives an action for printing that string on the screen.)
23:43:13 <travisbrady> Cale: setting LD_LIBRARY_PATH to /usr/lib knocked out one error
23:43:29 <Cale> travisbrady: what's the next?
23:43:33 <NekoIncardine> Hrm... So I have printBoard which runs 'map tileToChar x', giving me [Char]. Next I need to figure out how to turn that into 9 strings of 9...
23:43:56 <hpaste>  travisbrady pasted "Runhaskell problem on Mac" at http://hpaste.org/6836
23:44:09 <Cale> NekoIncardine: you might have a look at take and drop
23:44:16 <travisbrady> Cale: ^^, i thought Manuel's package came with libgmp
23:44:21 <Cale> NekoIncardine: or for that matter, splitAt
23:44:26 <NekoIncardine> take and drop... Sounds like what I need.
23:44:50 <Cale> > splitAt 9 "012345678901234567890123456789"
23:44:50 <lambdabot>  ("012345678","901234567890123456789")
23:45:58 <Cale> NekoIncardine: Of course, rather than give you the easy solution entirely in terms of library functions, I'll let you think about it a bit :)
23:46:16 <Cale> travisbrady: that's interesting
23:46:17 <NekoIncardine> Hrm... Is there something similar to "splitAt [9,18,27,36,45,54,63,72] (map tileToChar x) that would work?
23:46:42 <travisbrady> Cale: this thread address the problem: http://www.haskell.org/pipermail/glasgow-haskell-users/2007-December/013875.html, but i haven't found a solution yet
23:46:43 <lambdabot> Title: ANNOUNCE: GHC version 6.8.2, http://tinyurl.com/6gh8d4
23:46:48 <Cale> travisbrady: I haven't used OS X in a long time though, so maybe it'd be a good idea to send an email to Manuel.
23:47:07 <NekoIncardine> ... Ah!
23:47:24 <travisbrady> Cale: yeah, perhaps i ought to just try all this on one of my production linux boxes
23:48:19 <NekoIncardine> HRm... I see a way to do it with just a nested-as-deuce take 9 (drop 9 (take 9( etc.etc.
23:48:33 <NekoIncardine> Or nested splitAts.
23:48:50 <Cale> NekoIncardine: right... and so you might want to know about  iterate
23:48:54 <Cale> @src iterate
23:48:54 <lambdabot> iterate f x =  x : iterate f (f x)
23:49:00 <Cale> > iterate f x
23:49:01 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
23:49:03 <travisbrady> Cale: thanks for your help
23:49:12 <Cale> travisbrady: np
23:49:32 <NekoIncardine> ... Whoa. That adds up pretty fast. o_o; Does it go up infinitely or does it self-set the limit once, for example, x becomes empty?
23:49:42 <Cale> It goes on infinitely.
23:49:56 <Cale> So you'll need to cut the list off when it becomes empty using takeWhile
23:50:24 <NekoIncardine> @src takeWhile
23:50:24 <lambdabot> takeWhile _ []                 =  []
23:50:24 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
23:50:24 <lambdabot>                    | otherwise =  []
23:50:46 <NekoIncardine> @src splitAt
23:50:46 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
23:51:00 <Cale> Hehe, that's not the real source, but it's a valid spec :)
23:51:10 <NekoIncardine> The latter or former one?
23:51:12 <Cale> (for splitAt)
23:51:33 <Cale> The real source is a bit more efficient.
23:51:37 <travisbrady> can anyone tell me what "'Executable' stanza starting with field 'flag split-base
23:51:37 <travisbrady> description'" means? in attempting to install bytestring-mmap
23:51:40 <NekoIncardine> So... Could I make "splitWhileAt n xs = (takeWhile n xs, drop n xs)"?
23:51:52 <NekoIncardine> And would that iterate properly?
23:52:01 <Cale> travisbrady: sounds like a .cabal syntax error
23:52:15 <NekoIncardine> @src dropWhile
23:52:15 <lambdabot> Source not found. My brain just exploded
23:52:16 <Cale> NekoIncardine: not quite...
23:52:27 <Cale> oh, that's odd
23:52:28 <NekoIncardine> Shoulda figured it wouldn't be quite that easy.
23:52:34 <NekoIncardine> ... Oh, is there a dropWhile?
23:52:36 <Cale> :t dropWhile
23:52:37 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
23:52:40 <Cale> yeah, there is
23:53:05 <NekoIncardine> Hrm...
23:53:18 <NekoIncardine> I see why. splitWhileAt doesn't iterate even though its source methods do.
23:53:27 <NekoIncardine> To go that route I'd have to define splitWhileAt iteratively.
23:53:29 <Cale> :t iterate
23:53:30 <lambdabot> forall a. (a -> a) -> a -> [a]
23:53:53 <Cale> NekoIncardine: however, you can iterate and later map...
23:54:06 <NekoIncardine> Hrm.
23:54:17 <Cale> > iterate (drop 3) ['a'..'z']
23:54:18 <lambdabot>  ["abcdefghijklmnopqrstuvwxyz","defghijklmnopqrstuvwxyz","ghijklmnopqrstuvwxy...
23:54:30 <NekoIncardine> Not quite sure what you mean by that.... Oh.
23:54:31 <Cale> > map (take 3) (iterate (drop 3) ['a'..'z'])
23:54:31 <lambdabot>  ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz","","","","","","","","...
23:54:50 <NekoIncardine> takeWhile 3 in this case. ;p
23:55:04 <Cale> takeWhile wants a function
23:55:42 <Cale> Specifically, you probably want the function that tests that a list is nonempty
23:55:50 <NekoIncardine> ... Hrm.
23:55:52 <Cale> null is the function which tests if a list is empty
23:55:59 <Cale> > null ""
23:56:00 <lambdabot>  True
23:56:04 <Cale> > null "hello"
23:56:05 <lambdabot>  False
23:56:15 <Cale> So not . null is the function which is the opposite
23:57:00 <NekoIncardine> map (takeWhile not.null 9) (iterate (drop 9) x) then?
23:58:17 <Cale> careful
23:58:33 <Cale> Well, play around with it in ghci :)
23:58:43 <NekoIncardine> WinHugs in my case but I just looked the function up
