00:00:48 <solrize> hmm, the cabal install for data.binary doesn't include profiling?
00:01:07 <solrize> is there a way to fix that, or turn off profiling for just that module while still profiling the outer program?
00:02:32 <olsner> cabal install -p
00:02:38 <olsner> -p enables profiling
00:02:57 <solrize> hmm, i don't have cabal
00:03:02 <solrize> i used runhaskell Setup.hs install
00:03:06 <solrize> can i just add -p ?
00:03:18 <olsner> could be a configure alternative
00:03:31 <olsner> try runhaskell Setup.hs configure --help
00:03:38 <solrize> thanks
00:03:42 <solrize> yes putting it on the install line didn't work
00:03:54 <solrize> yep, -p in configure   thanks
00:05:10 <reemusk> check out this awesome game http://game2.mafiadeath.com/r/60880.php
00:05:12 <lambdabot> Title: MafiaDeath - Select Game
00:06:34 <solrize> err, do i want to look at that?   is reemusk someone from here?
00:06:40 <solrize> :whois reemusk
00:06:43 <olsner> looks like spam
00:07:56 <EvilTerran> somewhat yes
00:11:14 <olsner> most real people don't post a link the first thing they say
00:12:35 <solrize> hmm program now spends 25% of its time in sha1
00:12:39 <solrize> not good
00:13:12 <solrize> earlier timing of 5 minutes to run the whole thing was misunderestimate :)
00:16:00 <solrize> is there a way to tell what compile options Setup.hs build is using?  in particular does it use -O2 by default?
00:16:37 <glguy> -O1
00:17:01 <solrize> hmm
00:17:16 <solrize> can i change that?
00:23:49 <sjanssen> solrize: which sha1 are you using?
00:24:03 <solrize> Data.Digest.SHA1  written in haskell
00:24:22 <sjanssen> ah, the crypto library may be slow
00:24:23 <solrize> there are a couple other modules that wrap openssl so i'm trying to see if i can get one of those to expose sha1
00:24:51 <sjanssen> if not, writing the C bindings yourself should be quite easy
00:25:33 <solrize> yeah, shouldn't be too bad, it's just another thing to figure out
00:26:43 <solrize> not sure if i'll bother--at least for the moment, with the json parser gone, the speed of this thing is getting near tolerable
00:28:23 <solrize> but, i have the feeling that it's still awfully slow in objective terms (i.e. at least 10x slower than if i wrote the whole thing in c)
00:28:48 <sjanssen> on the other hand, using a fast sha1 could potentially cut out 25% of your run time :)
00:29:01 <solrize> true :)
00:29:04 <sjanssen> sha1 should be pretty much instant, right?
00:29:20 <solrize> hmm
00:29:35 <Baughn> sha1 is also /broken/. Don't use it.
00:29:42 <solrize> 0$ openssl speed sha1
00:29:42 <solrize> Doing sha1 for 3s on 16 size blocks: 2797797 sha1's in 2.97s
00:29:49 <solrize> it's broken?  it seems to be working
00:30:03 <Baughn> These days you've got.. um, sha-256, mostly. That one hasn't been even slightly broken yet.
00:30:14 <Baughn> solrize: You know what I mean
00:30:21 <solrize> oh i see, i thought you meant hte implementation didn't work
00:30:32 <solrize> i'm not using it for crypto right now, just using it to stir up data
00:31:27 <Baughn> I just prefer not to use it for anything. Even if it might be okay in your scenario, that takes careful thinking, and someone else might "misuse" the code later - sha-256 just works. So far.
00:32:01 <solrize> yeah, true
00:32:33 <solrize>      hash                FacetHash                                            366       82769  26.0   24.4    26.5   25.5
00:32:56 <Cale> If you don't want a cryptographic hash, there are much cheaper things you can do.
00:33:04 <Baughn> Mm. Like crc32
00:33:22 <Baughn> And nobody's going to mistake a crc32 signature for something secure
00:33:35 <solrize> so openssl can do 1M sha1's/sec    while the crypto lib does 82000 in 3-4 sec
00:33:40 <solrize> i need more than 32 bits
00:33:46 <Baughn> crc64?
00:33:59 <solrize> 64 might be enough
00:34:06 <solrize> using sha1 was conceptually simplest
00:34:11 <solrize> and in python was not much of a bottleneck
00:34:15 <Baughn> Use crc1024 if you like. It's easy to expand..
00:34:45 <solrize> openssl is 30x faster than the haskell lib, if i can just use it then everything will be fine :)
00:35:04 <Baughn> Although crc64, on a 64-bit computer, /should/ be very nearly instant - faster than memory bandwidth, anyhow
00:36:11 <solrize> yeah probably, it's pretty short strings going in so all L1 cache lookups
00:37:16 <solrize> surprisingly the thing is spending 23.5% of its time in the data.binary reader, which was running ridiculously fast when i wasn't computing anything with the output
00:37:38 <solrize> might be a lazy evaluation thing but i thought it had to parse each whole record just in order to find where the next one started
00:37:46 <Baughn> Usually not, not
00:37:48 <Baughn> *no
00:38:11 <Baughn> The encoding can vary, but all the default ones just put a length record at the start of each record
00:38:29 <solrize> this was a customized one that didn't quite work that way
00:38:47 <solrize> is there a way to tell from the profile how much time is spent in alloc/gc ?
00:39:09 <Baughn> Not the profile, but yes
00:39:35 <Baughn> +RTS -sstderr
00:40:05 <solrize> running
00:41:10 <solrize> 13% gc time   i guess that's not bad
00:42:22 <solrize> 14,030,941,716 bytes allocated in the heap
00:42:22 <solrize> 345,564,936 bytes copied during GC (scavenged)
00:42:46 <solrize>       26755 collections in generation 0 (  3.55s)
00:42:46 <solrize>         281 collections in generation 1 (  0.17s)
00:43:18 <solrize> assuming almost all the copying is in generation 0, does that mean the ephemeral heap is 345M/26K approx?
00:43:24 <solrize> i.e. about 15k
00:43:33 <solrize> i.e. fits in L1 :)
00:43:59 <Baughn> You can get more details with -Sstderr
00:44:17 <solrize> whoa!  ton of stuff coming out
00:45:20 <Baughn> It prints one line per gc. The descriptions are at the very first line, so make sure you catch those.
00:46:28 <solrize> yeah, it says the alloc bytes (= entire heap?) and "copied bytes"
00:46:35 <solrize> and live bytes
00:46:53 <solrize> which is making it up to about 1 megabyte before dropping to 150k
00:47:10 <solrize> i.e. it's reading and writing records of maybe 1 kbyte each
00:47:19 <Baughn> Alloc bytes = amount of memory allocates since last gc
00:47:31 <solrize> but allocating 1m of live heap for each one
00:47:33 <Baughn> Copied bytes = amount of data still live in the areas GCed
00:47:52 <Baughn> Live bytes = amount of data still live overall, assuming that all data in deeper generations are still live
00:47:56 <Baughn> ..or so I think.
00:48:00 <solrize> right
00:48:18 <solrize> so it allocates 0.5M for each gen0 gc
00:48:34 <solrize> which means that lots of mem accesses are missing L1 but probably hitting L2
00:48:54 <Baughn> Yep. That's tunable, and note that the cost of a gc is proportional to the amount of memory copied, not the amount allocated.
00:48:59 <solrize> and also the total cons rate is awfully high
00:49:44 <solrize> right, there's the gc cost but there's also the cost of computing on the live data, which is much lower if the region the live data lives in is smaller
00:50:55 <Baughn> Yes, but it's not as if it'll get spread out randomly in that region
00:51:13 <Baughn> Though a GC does tend to have the effect of increasing cache locality
00:51:43 <solrize> i can't really tell.  also i'm kind of shocked that 1M of live data is getting consed for each of these dinky records.  although the json printer may be responsible for most of it.  (I got rid of the parser but am still using the printer)
00:52:05 <Baughn> The prfiler /can/ tell you what causes /that/.
00:52:12 <solrize> oh good point
00:52:38 <Baughn> One thing to keep in mind is that allocation is a /lot/ cheaper with a copying GC than with malloc/free, or any other kind of GC for that matter
00:52:42 <solrize> yeah, alloc% is split up about the same way as time%
00:52:51 <solrize> i.e. hash and json printing are using about equal amounts
00:53:09 <Baughn> The allocation is just an atomic pointer increment, and the GC doesn't ever touch dead data
00:53:54 <solrize> right it's the actual accesses that can cause cache misses if there's too much consing
00:54:47 <solrize> it would be interesting to try jhc which uses region inference instead of gc where it can
00:55:37 <solrize> I think an L1 hit is something like 2 cycles and an L2 hit is around 15 cycles and a miss is 100's of cycles
00:56:06 <solrize> and that if i really want to write fast code i'm going to be using the FFI a lot ;)
00:57:25 <Baughn> solrize: A /complete/ miss is 100s of cycles, yes
00:57:43 <Baughn> But the average cost of a miss is a lot lower, due to speculative prefetching and whatnot
00:58:22 <solrize> http://softwarecommunity.intel.com/isn/downloads/intelavx/AES-Instructions-Set_WP.pdf   bwa ha ha
00:58:23 <lambdabot> http://tinyurl.com/5gccns
00:59:13 <Baughn> April 2008, eh?
00:59:20 <Baughn> A pity. That would've been a /good/ extension.
00:59:25 <solrize> eh?
00:59:34 <solrize> it's not from april 1 :)
00:59:40 <solrize> it's real
00:59:45 <Baughn> It doesn't say. I assumed it was.
00:59:49 <Baughn> Oh well, then it's a good thing
00:59:57 <solrize> they also added finite field arithmetic
01:00:03 <solrize> http://softwarecommunity.intel.com/isn/downloads/intelavx/Carry-Less-Multiplication-and-The-GCM-Mode_WP%20.pdf
01:00:04 <Baughn> (Except it'll probably get used for DRM)
01:00:04 <lambdabot> http://tinyurl.com/5fngzj
01:00:55 <solrize> yeah probably.  i'm surprised they put it in, i figured there must have been u.s. govt hassles or they would have done it a lot earlier like Via did.
01:01:26 <solrize> anyways though, i'm using amd64's which i think don't have much predictive prefetching, they improved it a lot in the next generation
01:01:37 <solrize> i mean i'm using athlon 64's
01:24:51 <mofmog> what's the correct way to display ascii characters? i've been trying "\164" for example, but all i get is this silly diamond character
01:25:31 <solrize> > print "\164"
01:25:35 <lambdabot>  <IO ()>
01:25:44 <solrize> > show "\164"
01:25:44 <lambdabot>  "\"\\164\""
01:25:47 <solrize> hmm
01:26:18 <EvilTerran> > showLitChar '\164' ""
01:26:19 <lambdabot>  "\\164"
01:26:27 <EvilTerran> that's in Data.Char
01:26:30 <nomeata> mofmog: 164 is not ascii anymore, is it? whatâ€™s your locale and encoding?
01:26:42 <mofmog> i just want a fancy box
01:26:56 <mofmog> 164 was some random number
01:27:31 <nomeata> mofmog: well, haskell does not do any encoding conversion, so if you use e.g. utf8, you will have to put the correct multi-byte-sequence in your string
01:27:36 <nomeata> > show "Ã¤"
01:27:37 <lambdabot>  "\"\\228\""
01:27:49 <nomeata> > show "Î±"
01:27:49 <lambdabot>  "\"\\945\""
01:27:51 <EvilTerran> you might need to fiddle with the encoding and font on your terminal for things to appear correctly
01:28:04 <nomeata> hmm. at least I thought so. maybe lambdabot uses utf8-string or something
01:28:35 <nomeata> mofmog: try echo what_you_want | ghc -e 'interact (show)' and see what haskell makes of it
01:28:57 <nomeata> $ echo Î±|ghc -e 'interact show'
01:28:57 <nomeata> "\206\177\n"
01:29:01 <cjs__> > putStrLn "\x40\x41\x42"
01:29:02 <lambdabot>  <IO ()>
01:29:07 <cjs__> Bah!
01:29:21 <cjs__> > "\x40\x41\x42"
01:29:22 <lambdabot>  "@AB"
01:30:11 <nomeata> @tell dons just a quick reminder: you wanted to update http://code.haskell.org/lambdabot/_darcs/prefs/email
01:30:11 <lambdabot> Consider it noted.
01:30:47 <nomeata> > "\206\177"
01:30:48 <lambdabot>  "\206\177"
01:31:48 <EvilTerran> > var "\206\177"
01:31:49 <lambdabot>  Î±
01:32:05 <nomeata> :t var
01:32:05 <EvilTerran> > var "\945"
01:32:06 <lambdabot>  ±
01:32:07 <lambdabot> forall a. String -> Sym a
01:32:29 <mofmog> so my terminal supports unicode but ghc does not!
01:32:31 <EvilTerran> > "Â±"
01:32:32 <lambdabot>  "\177"
01:32:44 <EvilTerran> > 945 `mod` 256
01:32:45 <lambdabot>  177
01:32:48 <EvilTerran> hm
01:32:58 <EvilTerran> i guess that kinda makes sense
01:33:26 <nomeata> mofmog: not exactly, you just have to do it manually (there are libraries around, e.g utf8-haskell). But yes, unicode in haskell is not as nice as it should be.
01:33:40 <nomeata> EvilTerran: whatâ€™s var?
01:33:44 <EvilTerran> nomeata, var is what the simplereflect thing uses to make things ::Expr appear unquoted, but its also handy for making it look like \b is saying things
01:33:45 <mofmog> ech, i can live with bolded O's
01:33:56 <EvilTerran> > f x :: Expr
01:33:57 <lambdabot>  f x
01:34:13 <EvilTerran> for instance, x = var "x"
01:34:56 <EvilTerran> ?where simplereflect
01:34:56 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
01:35:06 <solrize> > map (, 1) [1..5]
01:35:06 <lambdabot>  Parse error at "1)" (column 8)
01:35:10 <solrize> > map ((,) 1) [1..5]
01:35:11 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5)]
01:35:21 <solrize> that looks backwards
01:35:37 <EvilTerran> ?t (,)
01:35:38 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
01:35:41 <EvilTerran> ?type (,)
01:35:42 <lambdabot> forall a b. a -> b -> (a, b)
01:35:47 <solrize> > map (/ 2) [1..5]
01:35:48 <lambdabot>  [0.5,1.0,1.5,2.0,2.5]
01:35:57 <EvilTerran> > map ((/) 2) [1..5]
01:35:58 <lambdabot>  [2.0,1.0,0.6666666666666666,0.5,0.4]
01:36:05 <solrize> aha
01:36:20 <EvilTerran> (,) is parenthesised, so you're using it as a prefix, not as a right section
01:36:25 <solrize> yeah i get it now
01:36:30 <EvilTerran> :)
01:36:39 <solrize> > [(k,1) | k <- [1..5]]
01:36:40 <lambdabot>  [(1,1),(2,1),(3,1),(4,1),(5,1)]
01:36:40 <solrize> there
01:37:00 <EvilTerran> it would be nice to be able to write (,x) or (x,), but i don't think that's gonna happen any time soon
01:38:44 <solrize> > map (flip (,) 1) [1..5]
01:38:45 <lambdabot>  [(1,1),(2,1),(3,1),(4,1),(5,1)]
01:38:51 <solrize> yuch
01:39:23 <solrize> what i really want is something like m `difference` s   where m is a data.map and s is a data.set containing keys from m
01:40:31 <EvilTerran> :t Data.Map.difference
01:40:32 <lambdabot> forall k a b. (Ord k) => M.Map k a -> M.Map k b -> M.Map k a
01:41:21 <EvilTerran> :t \m s -> Data.Map.filter (not . (`Data.Set.elem` s))
01:41:22 <lambdabot> Not in scope: `Data.Set.elem'
01:41:41 <EvilTerran> :t \m s -> Data.Map.filter (`Data.Set.notMember` s)
01:41:42 <lambdabot> forall t a k. (Ord k, Ord a) => t -> S.Set a -> M.Map k a -> M.Map k a
01:41:59 <solrize> yeah i could do that, but it looks up each element of the set, unlike the map.difference operation which just iterates down the (sorted) lists in parallel
01:42:03 <solrize> i guess it doesn't matter much for this
01:42:10 <EvilTerran> er
01:42:11 <solrize> i just like to do things the natural way
01:42:12 <EvilTerran> :t \m s -> Data.Map.filter (`Data.Set.notMember` s) m
01:42:13 <lambdabot> forall a k. (Ord k, Ord a) => M.Map k a -> S.Set a -> M.Map k a
01:42:33 <EvilTerran> you could turn the Set into a Map and use that
01:42:46 <solrize> yeah i guess i will
01:42:53 <EvilTerran> not sure whether there'd be a neat way of doing that
01:44:39 <solrize> M.fromList ([(k,1) | k <- [k1,k2,k3...]])
01:45:25 <EvilTerran> :t \m s -> M.difference m (S.fold (\k -> M.insert k ()) M.empty s)
01:45:26 <lambdabot> forall a a1. (Ord a1) => M.Map a1 a -> S.Set a1 -> M.Map a1 a
01:53:34 <quicksilver> solrize: sounds like premature optimisation unless it's a really really big set/map :)
01:54:02 <solrize> yeah, i'm impressed by how little time is being spent in map operations in this program, it was fairly significant in the python version
01:54:19 <EvilTerran> i think both of my ones there will have the same O(n.log n) complexity in the size of the set
01:54:31 <electron_x> hello just wandering why don't they wrewrite haskell in haskell?
01:54:42 <solrize> http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html#9   says O(n+m)
01:54:43 <lambdabot> http://tinyurl.com/2mpwee
01:54:48 <electron_x> if haskell is such a good language?
01:54:48 <EvilTerran> electron_x, you mean like GHC's written in haskell?
01:54:55 <electron_x> yeah
01:54:57 <quicksilver> electron_x: GHC is written in haskell.
01:55:00 <quicksilver> (primarily)
01:55:21 <electron_x> wouldn't that lift productivity?
01:55:29 <quicksilver> it did.
01:55:32 <quicksilver> that's why they chose it.
01:55:48 <electron_x> wait i though ghc was written in C?
01:55:50 <solrize> ghc seems to be about the most serious language implementation around
01:55:55 <quicksilver> solrize: the efficient conversion from map to list is probably fromAscList . toAscList
01:55:57 <solrize> hugs is written in c
01:55:58 <quicksilver> electron_x: nope. Haskell.
01:56:16 <electron_x> okay that pretty cool
01:56:34 <electron_x> percent wise how much of it is haskell?
01:56:35 <solrize> although i've heard it claimed, that the whole hugs implementation (in c) is smaller than ghc's type checker (in haskell)
01:56:41 <EvilTerran> quicksilver, that'll be O(n.log n) again, won't it?
01:57:00 <EvilTerran> solrize, ghc's type checker does have a lot of extensions, mind
01:57:09 <solrize> i'm not too worried about this conversion; as quicksilver says, it's premature optimization
01:57:13 <quicksilver> EvilTerran: No. fromAscList and toAscList are O(n).
01:57:28 <electron_x> so what haskell version do they use to compile the new haskell version?
01:57:31 <EvilTerran> oh, cool
01:57:36 <quicksilver> electron_x: the last one. And then the new one.
01:57:36 <quicksilver> :)
01:57:56 <quicksilver> e.g., 6.8.0 can be compiled with 6.6.0
01:58:08 <quicksilver> then you can compile it again, with the 6.8 that you just built
01:58:09 <solrize> does ghc's type checker do stuff that jhc's can't?
01:58:10 <cjs__> I understand that it can be ported to a machine without a working Haskell compiler, though it's not entirely trivial.
01:58:14 <electron_x> quicksilver what percent of haskell is in pure haskell?
01:58:24 <quicksilver> (and it will be a bit faster, because it's a better compiler)
01:58:30 <quicksilver> electron_x: around 90% I think.
01:58:31 <electron_x> also how big is the code base?
01:58:41 <quicksilver> There is a runtime system written in a mixture of C-- and C.
01:58:58 <quicksilver> and of course there are some native bindings to access OS-specific functionality.
01:59:00 <EvilTerran> solrize, i'd imagine so. stuff like type families, etc. the more esoteric and recent extensions.
01:59:16 <electron_x> i have to say that is pretty cool i thought ghc was written in c
01:59:42 * EvilTerran notes quicksilver's neglected to mention the Evil Mangler ;)
02:00:15 <solrize> http://www.haskell.org/haskellwiki/GHC/Indexed_types   type families
02:00:18 <lambdabot> Title: GHC/Type families - HaskellWiki
02:00:30 <quicksilver> :t Data.Map.fromAscList . map (\x -> (x,())) . Data.Set.toAscList
02:00:34 <lambdabot> forall a. (Eq a) => S.Set a -> M.Map a ()
02:00:40 <quicksilver> solrize: there you go, FWIW.
02:00:46 <solrize> quicksilver, thanks
02:01:11 * quicksilver wishes tuple sections worked and he could have written the cryptic map (,())
02:01:20 <solrize> yeah i was going to use fromList since the list of keys in that set is constant
02:01:21 <solrize> hehehe
02:01:35 <Deewiant> map (flip (,) ()) isn't cryptic enough? :-P
02:02:02 <quicksilver> that's cryptic but too verbose.
02:02:09 <quicksilver> cryptic is only fun when it's concise.
02:02:10 <EvilTerran> :t map (`(,)` ())
02:02:11 <lambdabot> parse error on input `('
02:02:13 <EvilTerran> aw
02:02:31 <Deewiant> it's one character shorter than the lambda version
02:02:31 <solrize> exfields = ["foo", "bar", "baz"]
02:02:31 <solrize> ex_map = M.fromList [(k,()) | k <- exfields]
02:03:23 <osfameron> tuple sections would be nice.  Are they banned for a good reason?
02:03:42 <EvilTerran> i think because ((,),) doesn't quite mean what you might expect
02:04:17 <quicksilver> EvilTerran: eh?
02:04:30 <quicksilver> osfameron: because they are too easy to do by mistake, is the justification I heard.
02:04:36 <osfameron> ah
02:04:42 <quicksilver> osfameron: if you have long multiline tuples and copy-paste a whole line
02:04:45 <quicksilver> adding an extra comma
02:04:48 <quicksilver> you get a weird type error
02:04:54 <quicksilver> I don't find that very satisfying, myself
02:05:06 <quicksilver> if you copy-paste whole lines in most other circumstances you get weird type errors too
02:05:11 <EvilTerran> it's not (\x y z -> ((x,y),z)), it's (\x -> ((\y z -> (y,z)), x))
02:05:11 <quicksilver> don't know why this one is different :P
02:05:35 <solrize> i'm used to the C/Python/Java(?) convention where you can have an extra comma at the end of the list and it's ignored, i.e. [1,2,3,] is the same as [1,2,3]
02:05:49 <solrize> that gets rid of the weird looking convention of lines beginning with ,
02:06:01 <solrize> when you have lists spread out over many lines
02:13:45 <cjs__> Not in C. But Ruby has it.
02:14:15 <cjs__> solrize: Does the "comma at beginning of line or item" format bother you?
02:15:04 <solrize> i'm used to it now, but it seemed a bit weird at first
02:15:05 <EvilTerran> i didn't think C had that. perl does.
02:15:08 <solrize> C does have it
02:15:27 <cjs__> Really? That's a new one on me. It didn't in 1983.
02:16:32 <solrize> #include <stdio.h>
02:16:32 <solrize> int junk[] = {1, 2, 3, };
02:16:32 <solrize> main() { printf ("%d\n", sizeof junk); }
02:16:33 <solrize> works
02:17:13 * EvilTerran pretty much always uses -Wall - that might make it grumble, even if it's valid
02:17:58 <solrize> #include <stdio.h>
02:17:58 <solrize> int junk[] = {1, 2, 3, };
02:17:58 <solrize> int main() { printf ("%d\n", sizeof junk); return 0;}
02:18:01 <solrize> no complaints
02:18:09 <solrize> from -Wall
02:18:12 <solrize> i should start using that
02:18:17 <solrize> i hardly ever write C any more
02:18:21 <solrize> and i make a lot more mistakes than i used to
02:18:27 <solrize> i want to start using ada
02:18:34 <solrize> GNAT
02:22:46 <nomeata> Iâ€™m going to do some (relatively simple) matrix calculations for some geometry things, mostly multiplication with a vector and inversion. Is there a good library, or what is a good type for such matrixs?
02:23:26 <cjs__> How do I trace something when I'm not in IO?
02:23:30 <EvilTerran> ?hoogle trace
02:23:31 <lambdabot> Debug.Trace.trace :: String -> a -> a
02:23:31 <lambdabot> Debug.Trace :: module
02:23:31 <lambdabot> Debug.Trace.traceShow :: Show a => a -> b -> b
02:23:50 <EvilTerran> nomeata, Data.Array is good for matrices
02:24:19 <EvilTerran> ?hackage hmatrix
02:24:19 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmatrix
02:24:23 <nomeata> EvilTerran: With an Array Int (Array Int a), or using some div/mod calculation to get tuples as indices
02:24:55 <EvilTerran> Array (Int,Int) a
02:25:13 <EvilTerran> there's an instance (Ix a, Ix b) => Ix (a,b)
02:25:19 <nomeata> ah, right, now I see that.
02:25:36 <cjs__> Hm. I have no traceShow. :-(
02:26:00 <EvilTerran> pretty easy to define yourself, mind
02:26:43 <EvilTerran> ?type trace . show
02:26:44 <lambdabot> Not in scope: `trace'
02:26:50 <EvilTerran> ?type Debug.Trace.trace . show
02:26:52 <lambdabot> forall a a1. (Show a1) => a1 -> a -> a
02:27:10 <nomeata> (or maybe I just use ((Double,Double,Double),(Double,Double,Double),(Double,Double,Double)), I only need 3Ã—3 matrices anyways. Not sure whatâ€™s easier...
02:27:42 <EvilTerran> well, the tuples give you statically-checked sizes, but you can traverse Arrays easier
02:28:06 <EvilTerran> you can also traverse tuples with, say, SYB, though
02:28:10 <nomeata> EvilTerran: hmm, right.
02:32:03 <quicksilver> nomeata: If you really do only use 3x3 then I think the fastest will be data Matrix = !Double !Double !Double !Double !Double !Double !Double !Double !Double
02:32:11 <quicksilver> nomeata: (with a constructor name!)
02:32:21 <quicksilver> nomeata: but of course it's a pain writing algorithms for that.
02:32:26 <quicksilver> mind you, you only have to do it once
02:32:30 <quicksilver> then they're written.
02:32:43 <quicksilver> the simplest to work with is likely to be [[Double]]
02:32:44 <nomeata> oh, speed is not the issue I think. But Iâ€™ll go with the tuples of tuples, I only need few operations anyways.
02:33:04 <nomeata> and then I can just copy the forumlay from wikipedia :-)
02:33:49 <solrize> Loading package binary-0.4.2 ... linking ... done.
02:33:50 <solrize> <interactive>: internal error: loadObj: can't map `Records.o'
02:33:50 <solrize>     (GHC version 6.8.2 for i386_unknown_linux)
02:33:50 <solrize>     Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
02:33:50 <solrize> Aborted (core dumped)
02:33:52 <lambdabot> Title: ReportABug - GHC - Trac
02:33:52 <solrize> bah
02:34:02 <solrize> it even crashed my shell
02:37:58 <MarcWeber> Do you know where to get Text.Packrat.Parse used by JSON.hs ?
02:38:16 <solrize> yeah, where did i find it
02:38:29 <solrize> but i just quit using it, it's rather slow
02:39:19 <solrize> http://darcs.haskell.org/SoC/haskellnet/Text/Packrat/
02:39:20 <lambdabot> Title: Index of /SoC/haskellnet/Text/Packrat
02:41:02 <solrize> so what is the idea with this indexed type stuff, and more and more things like it that approach but don't attempt indexing types by data?  is it because they want to keep inference tractable?
02:41:10 <solrize> i.e. not have proof obligations on the user?
02:41:38 <quicksilver> I'm not sure if that's the reason or not.
02:41:58 <quicksilver> I was assuming the reasons were more to do with the structure of GHC Core and system Fc
02:42:11 <quicksilver> i.e. what type extensions map well to that structure.
02:42:15 <quicksilver> btu I could well be wrong.
02:42:22 <quicksilver> ChilliX: would be the one to ask if he's around
02:42:27 <solrize> hmm
02:42:42 <solrize> i thought Fc was what they did to make GADT's work
02:42:50 <solrize> and that for type families they had to do something fancier
02:43:09 <MarcWeber> solrize: Thx
02:43:12 <solrize> but, Henk (the language, not the person) was an SPJ invention, so why not use it in GHC?
02:43:49 <solrize> that is similar to what jhc uses, i think
02:45:04 <quicksilver> solrize: Fc is all that's needed for type families, that much I know.
02:45:12 <solrize> cool
02:46:17 <quicksilver> I don't know why GHC doesn't use Henk, or indeed what the key differences are between Henk and Core
02:47:06 <solrize> henk has a much fancier type system where every term has an annotation
02:47:38 <solrize> type inference is undecidable in it, i think
02:47:58 <quicksilver> type inference is undecidable in System F too
02:48:05 <quicksilver> and indeed in GHC Core
02:48:14 <solrize> hmm ok
02:48:28 <quicksilver> note that GHC Core is explicitly typed, there is no inference.
02:48:38 <quicksilver> The inference is performed on haskell before the Core translation
02:48:48 <solrize> i see, that makes sense
02:50:22 <nomeata> Graphics.Rendering.Cairo.Matrix is a nice matrix library, especially as I wanted to use it with cairo anyways :-)
02:51:05 <quicksilver> The henk paper ends with the sentence "we plan to move towards an implementation in GHC"
02:51:17 <quicksilver> I don't know what happened to that plan. perhaps Fc replaced it.
02:51:42 <solrize> it looked like a powerful idea
02:52:21 <quicksilver> ChilliX: can you comment?
03:01:22 <ToRA> solarize: wasn't it that to make GADT's work they had old core (basically F + data) + ad hoc stuff thrown in just for GADTs; then for type families, gadts and newtypes to be brought together they introduced Fc (Sys F + type equality coercions) which neatly allows all (and more) to be represented?
03:01:47 <quicksilver> yes
03:01:59 <quicksilver> GADTs were implemented directly in Core, previously.
03:02:03 <quicksilver> as a "special feature"
03:02:12 <quicksilver> now they are implemented using Fc instead
03:20:56 <Peaker> Monoid doesn't extend monad, why does Alternative extend Functor/Applicative ?
03:21:34 <Peaker> also, isn't Alternative redundant to Monoid?
03:21:52 <quicksilver> Alternative has a different kind to Monoid
03:22:06 <quicksilver> (Monoid has a different kind to Monad)
03:22:11 <solrize> http://hpaste.org/7105  any idea why this is so slow?  several msec per call
03:22:52 <Peaker> what benefits does Alternative get from extending Applicative though?
03:23:02 <quicksilver> Peaker: it is intended to woerror on input `='
07:50:08 <ivanm> @type let recurseM f x = let xf = x >>= f in xf : recurseM f xf in recurseM
07:50:10 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m a) -> m a -> [m a]
07:50:15 <ivanm> @type iterate
07:50:16 <lambdabot> forall a. (a -> a) -> a -> [a]
07:50:33 <bugQ> right then, thanks.
07:50:39 <ivanm> @hoogle (Monad m) => (a -> m a) -> m a -> [m a]
07:50:40 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
07:50:40 <lambdabot> Data.List.iterate :: (a -> a) -> a -> [a]
07:50:55 <ivanm> wait, I take it back.... iterate isn't it
07:51:02 <bugQ> no?
07:51:17 <ivanm> look at the types....
07:51:21 <byorgey> @type scanl
07:51:23 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
07:51:26 <ivanm> and the type of your function looks wrong as well
07:51:32 <ivanm> bugQ: what would f be?
07:51:38 <ivanm> @src iterate
07:51:38 <lambdabot> iterate f x =  x : iterate f (f x)
07:51:45 <ivanm> ^^ notice the difference?
07:52:05 <kosmikus> let recurseM f x = iterate (>>= f) x
07:52:09 <bugQ> right.
07:52:25 <bugQ> thanks, that's all I needed
07:52:52 <ivanm> kosmikus: would that typecheck?
07:53:03 <bugQ> it does.
07:53:05 <ivanm> @type let recurseM f x = iterate (>>= f) x in recurseM
07:53:06 <lambdabot> forall b (m :: * -> *). (Monad m) => (b -> m b) -> m b -> [m b]
07:53:18 <ivanm> hmmmm..... so it does
07:53:27 <bugQ> but it's silly to define if I can use iterate (>>= f)
07:53:39 <ivanm> *shrug* if you do it a lot, it makes more sense
07:54:00 <kosmikus> probably makes sense to call it iterateM
07:54:07 <bugQ> right.
07:54:43 <bugQ> > let exp x = case x of 'o' -> "pm"; 'm' -> "o"; 'p' -> "g"; c -> [c] in iterate (>>= exp) "omg"
07:54:44 <lambdabot>  ["omg","pmog","gopmg","gpmgog","ggogpmg","ggpmggog","gggoggpmg","gggpmgggog"...
07:54:47 <bugQ> woo1
07:54:50 <bugQ> er, woo!
07:55:00 <bugQ> my little L-system.
08:02:32 <bugQ> > let exp x = case x of 'o' -> "pm"; 'm' -> "og"; 'p' -> "m"; 'g' -> "" in iterate (>>= exp) "omg"
08:02:33 <lambdabot>  ["omg","pmog","mogpm","ogpmmog","pmmogogpm","mogogpmpmmog","ogpmpmmogmogogpm...
08:02:42 <bugQ> yeah, that one's more interesting.
08:02:46 <Syzygy-> bugQ: Good. Now make it do a fern.
08:03:39 <bugQ> why? it's already been done.
08:04:33 <byorgey> make it do a cheeseburger!
08:04:37 <bugQ> heh.
08:05:09 <byorgey> > let exp x = case x of 'q' -> "cheeseburger"; c -> [c] in iterate (>>= exp) "q"
08:05:10 <lambdabot>  ["q","cheeseburger","cheeseburger","cheeseburger","cheeseburger","cheeseburg...
08:07:14 <wjt> any hxt ninjas around?  following http://www.haskell.org/haskellwiki/HXT/Practical I've written some stuff to parse Twitter's status XML, but it seems to examine every tag twice.  <http://hpaste.org/7108>
08:09:18 <Saizan> wjt: does it give one result with the outer id, and one with the id inside user?
08:09:54 <wjt> doh, yes, it does
08:10:07 <wjt> this is because i'm using deep each time
08:10:23 <quicksilver> yeah, you have to watch out for that kind of thing
08:10:29 <quicksilver> hxt combinators are very powerful
08:10:36 <quicksilver> sometimes more powerful than you expected :)
08:10:43 <bugQ> e> let exp x = case x of 'n' -> "rn"; 'r' -> "e"; 'e' -> "f"; 'f' -> "fe" in iterate (>>= exp) "n"
08:10:48 <bugQ> oops
08:10:50 <bugQ> > let exp x = case x of 'n' -> "rn"; 'r' -> "e"; 'e' -> "f"; 'f' -> "fe" in iterate (>>= exp) "n"
08:10:51 <lambdabot>  ["n","rn","ern","fern","fefern","feffefern","feffefeffefern","feffefeffeffef...
08:11:15 <wjt> ah, so using getChildren >>> isElem >>> hasName "id" does the right thing
08:11:17 <wjt> Saizan: thanks!
08:11:47 <bugQ> Syzygy-: you like your fern?
08:11:49 <Saizan> no problem :)
08:12:41 <wjt> hmm so actually i never want to be using deep at all.  I just want to getChildren >>> getStatus on the root node
08:12:49 <byorgey> bugQ: haha, awesome! =)
08:13:21 <sfultong> Are there any haskell libraries that allow reflection?
08:13:53 <Syzygy-> :)
08:14:33 <MyCatVerbs> sfultong: "Scrap Your Boilerplate" does some form of reflection, though I have no idea whether it'd suffice for whate'er it is you need.
08:15:11 <quicksilver> sfultong: you can get a surprising way towards reflection with Typeable.
08:18:31 <sfultong> thanks... actually, my needs might be simpler.  I'm writing a language that compiles to haskell, and I was hoping that somehow I could specify that I would be using a certain haskell module, and a list of exported functions from that module would automatically be available to me...
08:18:43 <ion_> Hi. Is it considered bad practice to use the Unicode keywords listed in the beginning of <http://hackage.haskell.org/trac/haskell-prime/wiki/UnicodeInHaskellSource>?
08:18:43 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/UnicodeInHaskellSource>?
08:18:44 <Lycurgus> doesn't really fit with the effective haskell effective philosophy does it?
08:19:30 <Lycurgus> (i.e reflection. the sort of thing you would expect lisp implementations for example to be strong in)
08:19:41 <Lycurgus> strike one effective
08:20:31 <byorgey> ion_: well, at the very least, it means your Haskell code won't be portable at all.
08:20:51 <Lycurgus> although as "the java for academics" you might think it would since the latter does.
08:20:55 <ion_> Yeah...
08:21:13 <Lycurgus> as does .net
08:21:14 <byorgey> ion_: I assume you are referring to using â‡’ instead of => and so on?
08:21:19 <ion_> Yes
08:21:26 <Lycurgus> which brings up the point that f# might
08:21:30 <byorgey> as far as I know, jhc is the only compiler that supports those
08:21:38 <takamu> hi
08:21:55 <ion_> byorgey: The article says that ghc supports them with -fglasgow-exts. I havenâ€™t tested that, though.
08:22:13 <byorgey> oh, really?
08:22:22 <byorgey> oh, yes, I see, it does say that doesn't it. =)
08:22:52 <byorgey> ion_: well, I don't know whether it would be considered bad practice or not, but it's certainly not very common.
08:23:22 <ion_> Yeah... Itâ€™s just that the symbols would be so pretty. ;-)
08:23:30 <byorgey> true. =)
08:26:43 <ion_> Funny, the list doesnâ€™t contain Î» for \
08:27:39 <byorgey> hmm... maybe because lambda is not punctuation, so having it be syntax would require a special case in the lexing rules?
08:27:58 <byorgey> i.e. currently, Î»x would parse as a single identifier
08:28:04 <ion_> True
08:28:11 <quicksilver> @tell JaffaCake It's really nice to see visible progress on H'. Efforts very much appreciated.
08:28:12 <lambdabot> Consider it noted.
08:28:15 <nejucomo> No module reference cycles in GHC?
08:28:53 <quicksilver> @go ghc manual How to compile mutually recursive modules
08:28:55 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html
08:28:55 <lambdabot> Title: 5.6. Filenames and separate compilation
08:29:00 <quicksilver> nejucomo: there you go.
08:29:35 <sfultong> Are cyclic module imports considered bad form?
08:29:40 <ion_> Btw, lambdabot is not using NOTICEs for automatic messages in accordance with RFC. :-)
08:30:27 <nejucomo> sfultong: If ghc --make can't handle it out of the box, I consider it bad form.
08:30:45 <byorgey> sfultong: I think the general recommendation is to avoid them if possible.  Pull out the cyclic stuff into a separate module, and make everything else import it.
08:31:01 <byorgey> that will probably result in better organization anyway.
08:31:09 <nejucomo> But I'll ask you this:  Are mutually recursive functions bad form?
08:31:36 <quicksilver> nejucomo: no.
08:31:44 <quicksilver> nejucomo: but they form a single unit, conceptually.
08:31:48 <quicksilver> you study them together
08:31:49 <Arnar_> nominolo: not at all.. in fact they are very useful at times
08:31:56 <quicksilver> as such, it's hard to imagine a module boundary splitting them
08:31:58 <Arnar_> sorry.. nejucomo
08:32:18 <quicksilver> I have never had a case where recursive module dependencies seems like a good solution.
08:32:23 <quicksilver> so I've never used them.
08:32:30 <quicksilver> I have been told that such cases do exist, though.
08:32:33 <quicksilver> I think they're rather rare.
08:32:37 <scook0> I've felt frustrated at not being able to define a mutually recursive pair of abstract types
08:33:03 <quicksilver> scook0: you can, as long as you're prepared to have a 'notionally private' Foo.Internals modules
08:33:16 <quicksilver> scook0: and adopt the 'convention' that nothing else is allowed to import it
08:33:21 <scook0> but then they aren't abstract with respect to each other
08:33:29 <scook0> which was kind of the point
08:34:09 <scook0> my particular example was monsters, which can contain an inventory of items
08:34:32 <scook0> but if an item is a corpse, it needs to contain information about the monster it came from
08:34:34 <nejucomo> Yeah, I certainly agree that mutually recursive functions are much more commond than mutually recursive modules.
08:34:35 <sfultong> scook0: oo, rogue-like game?
08:34:40 <scook0> indeed
08:35:01 <scook0> with a little Î» running around :)
08:35:06 <sfultong> hehe, nice
08:35:17 <sfultong> I've got a rogue-like on the back burner
08:35:23 <quicksilver> scook0: hmm interesting.
08:35:30 <quicksilver> scook0: *thinks about that for a bit*
08:35:54 <quicksilver> scook0: I think that's a special case for corpses. I woudl factor the dependencies like this
08:36:03 <scook0> my current plan is to make a new "corpse data" structure, rather than storing the monster directly
08:36:14 <quicksilver> Game.Item.Corpse >> Game.Monster >> Game.Item
08:36:15 <scook0> and if I really do need that monster, I'll stash it in a Dynamic or something
08:36:28 <quicksilver> scook0: so 'general items' don't depend on monsters
08:36:29 <quicksilver> just corpses
08:36:38 <quicksilver> that breaks the loop.
08:38:08 <scook0> I'm thinking of Monster >> Item >> CorpseData
08:38:17 <scook0> where Monster has a function Monster->CorpseData
08:38:55 <scook0> design has been pretty tough overall
08:39:12 <scook0> I seem to have a knack for picking problems that are hard to express in Haskell :)
08:39:14 <sfultong> yeah, I would imagine that you wouldn't need all the information of the monster in the corpse... probably just a tiny bit
08:39:25 <scook0> most of the time that's true
08:39:37 <scook0> but if I later want to revive the monster, it would be nice to have all the original data
08:39:46 <scook0> but my plan is to use Dynamic if that comes up
08:39:50 <scook0> to break the cycle
08:39:51 <sfultong> ah, I see
08:40:54 <quicksilver> I think Dynamic is vile.
08:41:03 <quicksilver> cyclic dependency would be preferable to that
08:41:08 <quicksilver> (in my personal opinion, no more)
08:41:16 <scook0> cyclic deps are a pain, though
08:41:34 <scook0> it would be ok if GHC was smart enough to infer hs-boot from my type signatures
08:42:22 <scook0> does cabal have any hs-boot support? I gave up before checking
08:42:35 <byorgey> entry in the Haskell FAQ: "Q: is there anything that is difficult to express in Haskell?  A: Yes, for example, re-animating monster corpses is tricky."
08:43:52 <sfultong> scook0: you could always factor out a "Container" datatype, and then make Corpse and Monster instances of that...
08:44:07 <quicksilver> scook0: such problems are very interesting, because it's hard to really get your teeth into
08:44:21 <quicksilver> scook0: ...type system questions of expressibility without concrete examples.
08:44:26 <quicksilver> (hit return a bit too early there)
08:44:39 <quicksilver> sfultong: in haskell nothing is an instance of a datatype
08:44:41 <quicksilver> :)
08:45:00 <sfultong> well, by instance, I meant "had a constructor in"
08:45:45 <sfultong> so you could have... Data Container = Corpse { m : Monster } | Monster { i : Items }
08:47:05 <kosmikus> sfultong, scook0: not yet very advanced (and I don't know if it ever will be), but I've recently uploaded LambdaHack to Hackage
08:47:16 <byorgey> @pl \xs (a,b) -> (xs!!a, xs!!b)
08:47:17 <lambdabot> (`ap` snd) . (. fst) . ap (flip . (((.) . (,)) .) . (!!)) (!!)
08:47:21 <byorgey> gah
08:47:25 <sfultong> kosmikus: neat, I'll have to check it out
08:47:41 <byorgey> @type \xs (a,b) -> (xs!!a, xs!!b)
08:47:44 <lambdabot> forall a. [a] -> (Int, Int) -> (a, a)
08:48:07 <byorgey> @type \xs -> join (***) (xs!!)
08:48:08 <lambdabot> forall c. [c] -> (Int, Int) -> (c, c)
08:48:59 <tromp> :t (***)
08:49:01 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
08:49:07 <eugman|college> I'm not in a position to test at the moment, but can anyone tell me if a file writen in notepad and then sftp'd over to a linux server would be able to be compile fine by ghc? Or would there be character issues?
08:49:53 <quicksilver> eugman|college: AFAIK notepad is safe for ascii
08:50:01 <quicksilver> no idea what it does with non-7-bit chars
08:50:06 <quicksilver> probably some sad codepage thing
08:50:21 <byorgey> tromp: for the (->) arrow, (f *** g) (a,b) = (f a, g b)
08:50:29 <scook0> quicksilver: I think the concern is with line-endings
08:50:35 <byorgey> i.e. it applies the functions f and g 'in parallel' to the two components of a tuple
08:50:38 <quicksilver> line endings shouldn't be an issue
08:50:40 <scook0> which *should* be fine, but you never know
08:50:40 <quicksilver> I don't think
08:50:59 <eugman|college> scook0, correct
08:51:08 <eugman|college> scook0 and any other os difference i may be unaware of
08:51:12 <adiM> I cannot understand how to use fgl. I tried http://hpaste.org/7109 but don't understand why a3 does not work. It should be equal to a2?
08:51:13 <tromp> ic, byorgey
08:52:14 <sfultong> damn, it seems I'll have to manually parse module headers to see what functions they export...
08:52:20 <sfultong> how tedious
08:52:39 <scook0> eugman|college: I did a unix2dos on a random .hs file, and it still works fine
08:52:44 <scook0> so you should be ok
08:55:54 <adiM> Any hints on how to use fgl?
09:15:10 <jorick> has anyone here used haskell to generate music ?
09:15:38 <jorick> my IRC server is basically done, so i'd like to embark on a bigger venture
09:17:40 <funktio> The Haskell School of Expression has something about music
09:19:16 <dons> jorick: yeah, there's been quite some interest in the last 2 years
09:19:16 <lambdabot> dons: You have 7 new messages. '/msg lambdabot @messages' to read them.
09:19:26 <dons> jorick: see the music generation paper at the last haskell workshop
09:19:42 <dons> there's a bit of a livecoding music scene too
09:20:06 <dons> http://haskell.org/haskellwiki/Applications_and_libraries/Music_and_sound#Music_composition
09:20:07 <lambdabot> http://tinyurl.com/68bd4m
09:22:46 <jorick> cool
09:23:00 <jorick> i got visitors brb
09:42:05 <dcoutts_> scook0: yes, hs-boot files should work fine with cabal, if you have problems with it report it
09:42:45 <dcoutts_> scook0: at least in recent cabal versions, not in 1.2.x
10:06:16 <wjt> dcoutts: any particular reason why g_get_user_cache_dir and chums aren't wrapped in gtk2hs?
10:06:49 <dcoutts_> wjt: nobody has asked for them, feel free to send patches
10:09:21 <wjt> dcoutts_: okay, will do if i get around to it.
10:09:50 * wjt TODO-lists
10:10:07 <blarz> @users
10:10:08 <lambdabot> Maximum users seen in #haskell: 438, currently: 436 (99.5%), active: 11 (2.5%)
10:15:17 <gbacon> great announcement from Galois!
10:16:47 <Arnar_> hmm... why doesn't lambdabot announce hpastes?
10:17:05 <desegnis> she never did
10:17:15 <Arnar_> really?
10:17:22 <desegnis> the hpaste account does/did that
10:17:31 <desegnis> @seen hpaste
10:17:31 <lambdabot> I haven't seen hpaste.
10:17:40 <desegnis> hm
10:17:42 <Arnar_> oh.. ok
10:18:48 <Arnar_> anyways.. I was wondering if anyone fancied having a look and telling me if I was doing sth. mind-blowingly stupid here: http://hpaste.org/7112
10:19:13 <Arnar_> both bfs and dfs seem to work as expected
10:23:31 <dons> Igloo: so is GHC using a faststring rewrite rule now?
10:23:54 <Toxaris> Tim Chevalier on last year's icfp contest mailing list: "No need to worry; we at Portland State are organizing the contest this year."
10:24:00 <Toxaris> http://mail.cs.uu.nl/pipermail/icfpcontest-discuss/2008-April/000252.html
10:24:02 <lambdabot> Title: [Icfpcontest-discuss] This Year's Contest, http://tinyurl.com/5sh8gm
10:25:51 <dons> gbacon: :)
10:26:05 <gbacon> @karma+ dons
10:26:06 <lambdabot> dons's karma raised to 141.
10:26:09 <gbacon> @karma+ Galois
10:26:10 <lambdabot> Galois's karma raised to 1.
10:26:23 <ion_> @karma- ion_
10:26:23 <lambdabot> You can't change your own karma, silly.
10:26:42 <Igloo> dons: Yup
10:26:59 <dons> Igloo: and they're firing nice?
10:27:23 <dons> Igloo: how about getting rid of the ghc-api bytestring dependency?
10:35:49 <Igloo> dons: Seem to work, yeah
10:36:12 <Igloo> dons: Decoupling bytestring is on my list, but patches will make it happen faster  :-)
10:36:27 <Taejo> I'm getting a stack overflow... can I make GHC 6.6 tell me which function is munching stack?
10:41:42 <dons> Igloo:  i need to get ghc head building on openbsd first...
10:41:49 <PeakerWork> hmm, quicksilver explained to me before that Alternative is not the same kind as Monoid, and I see that - however it seems that the kind of Alternative is a sub-kind of the more general kind of Monoid. Meaning that any Alternative instance can be a Monoid instance, but not vice versa..  Bringing me to ask, isn't it better that everyone use Monoid instead of Alternative? That would make all the code of Monoid reusable on all those ins
10:41:49 <PeakerWork> tances...
10:41:58 <Igloo> dons: Oh, what's the problem?
10:42:41 <dons> Igloo: http://hackage.haskell.org/trac/ghc/ticket/2063
10:42:50 <lambdabot> Title: #2063 (Breackage on OpenBSD due to mmap remap) - GHC - Trac
10:43:03 <dons> i currently try to uncherry pick that patch, to get a working ghc
10:43:11 <dolio> I'd wager that most functions that use Alternative also use Applicative, which every Alternative is.
10:43:42 <Igloo> Ah, right
10:43:57 <dolio> So Alternative saves you from writing '(Applicative f, Monoid (f a)' in many cases.
10:44:13 <mofmog> yay, my CA simulation now has color
10:44:52 <dolio> Not to mention that Monoid instances for various types don't match the monoid that their Alternative instance describes.
10:46:26 <cjb> glguy, dons: it would be fun to have a remote client for hpaste, ie. "cat foo.hs | hpaste"
10:46:36 <cjb> (and it could return the URL that the new paste is available at)
10:46:50 <ion_> There's pastebinit(1), hpaste suppot could be added to it.
10:47:07 <cjb> oh, hadn't heard of that.  looks perfect.
10:47:16 <roconnor> @go 1 eur in USD
10:47:19 <lambdabot> http://www.x-rates.com/d/USD/EUR/graph120.html
10:47:19 <lambdabot> Title: Exchange Rates Graph (Euro, American Dollar)
10:47:20 <Toxaris> PeakerWork: (Alternative f) is similar to (Applicative f, forall a. Monoid (f a)), which cannot be expressed in Haskell to my knowledge
10:47:22 <cjb> I suppose it uses mechanize or something?
10:47:46 <ion_> Uh, it's probably not written in Haskell.
10:47:58 <mofmog> so i never a got a good answer to this: what's hug's advantage over ghci?
10:48:10 <Valodim_> I don't think there is one
10:48:17 <xerox> none? (it's "hugs")
10:48:21 <mofmog> so... what's the point?
10:48:23 <Valodim_> it's said to give better error messages
10:48:39 <Valodim_> but I heard from some people they are less informative once you worked with haskell for a while
10:48:43 <dolio> hugs was around before ghci.
10:48:45 <Toxaris> mofmog: hugs used to be easier to use as ghci in the past, from what I've heard
10:48:51 <xerox> maybe faster.
10:48:58 <Valodim_> unlikely
10:49:09 <mofmog> so... it's essentially obsolete
10:49:38 <Saizan_> faster at loading files maybe
10:49:45 <xerox> I think ndm does all his coding in hugs, winhugs precisely.
10:50:17 <Toxaris> the only good thing about hugs is WinHugs (which is good because the builtin-windows console sucks, and ghci runs in a console)
10:50:38 <mofmog> so really if you run a unix derivative there is no point tohugs
10:51:02 <Toxaris> hmm, ok, not true, another good thing is that there is a second complete Haskell implementation other then ghc, which is good for haskell as a whole I guess
10:51:08 <Toxaris> competetion is always good
10:54:42 <lament> there's nhc98 and yhc
10:58:12 <Toxaris> lament: call me ignorant if you want
10:58:36 <Toxaris> but maybe, "... another complete Haskell implementation other then the predominant ghc ..."
11:00:11 <dons> hugs sole advantage these days is cheaper installs on windows
11:00:35 <Toxaris> no that's not what I mean. I mean yet another sense of another which allows the existence of nhc98 etc.
11:00:35 <vincenz> dons: GHC costs money on windows?
11:00:38 <dons> the error messages are more confusing than ghc, its slower than ghci, less libraries work with hugs, its unmaintained.
11:00:53 <dons> hugs is also good as a haskell98 lint tool
11:01:01 <vincenz> harsh
11:01:06 <dons> if you write a library, and believe it is h98, or h98+FFI,
11:01:08 <Toxaris> dons: which sence of "cheap"? installing ghc on windows is a download-click-done experience
11:01:10 <dons> hugs is a good way to check
11:01:27 <dons> Toxaris: agreed. its a smaller package, that's all
11:01:36 <dons> hugs isn't suitable for real world use.
11:02:27 <lament> harsh
11:02:50 <lament> Toxaris: look what the availability of multiple implementations did to Scheme, though
11:03:04 <dons> yes, its good that hugs isn't diverting developer effort much
11:06:13 <Toxaris> I understand that this is the case because ghc "won" in a sense, and all new stuff is implemented for ghc now. Is that understanding correct?
11:06:31 <dons> and hugs wasn't trying to be a fast system
11:06:54 <dons> ghc beat hbc, in that domain. probably because MSR hired the core devs
11:07:05 <dons> so it got consistent development for 15 years
11:08:25 <Toxaris> so was there a phase in time when there was competetion on the Haskell compiler market, and ghc turned out the be the "winner", incorporating ideas / goals of other systems on the way?
11:08:56 <dons> yes, mid 90s. hbc had the performance lead for most of the 90s
11:09:18 <dons> hbc probably still has a better code generator, but ghc has the runtime and *serious* optimisations
11:09:57 <lament> hbc is dead now?
11:10:06 <dons> its not active.
11:10:31 <Toxaris> that seems to suggest that competetion was good for haskell at that time (or at least not bad). maybe it would be good now, too?
11:10:46 <dons> definitely. any pressure performance-wise helps ghc
11:10:55 <dons> just benchmarking ghc against itself is useful
11:11:08 <dons> we use C, OCaml, Clean as benchmarks now
11:11:24 <dons> jhc is useful, but needs a more obvious process to push ghc further
11:12:00 <__pao__> how stable is ghc on linux 64 bit?
11:12:17 <dons> very? the main devs use amd64/linux
11:12:35 <dons> i suspect 64 bit linux is better supported than 32 bit now
11:12:35 <__pao__> dons: thanks
11:13:00 <vram> I just started learning haskell today ( and the IRC as well ). I have a dumb question. Is this a good place/time to ask?
11:13:04 <vincenz> Toxaris: The main difficulty is the amount of setup required to get a haskell compiler rolling
11:13:11 <dons> vram: definitely! welcome!
11:13:13 <__pao__> dons: ... and I suspect that there is no single advantage in using 32bit, right?
11:13:14 <Jaak> vram: always
11:13:15 <xerox> __pao__: are you italian? In which case I must point out there exist #haskell.it :D
11:13:23 <dons> __pao__: hmm, less memory traffic
11:13:47 <vincenz> dons: that's a rather big advantage :)
11:13:55 <vincenz> computing power is overrated
11:14:12 <__pao__> xerox: ;-)
11:14:45 <xerox> ?users #haskell.it
11:14:45 <lambdabot> Maximum users seen in #haskell.it: 7, currently: 8 (114.3%), active: 4 (50.0%)
11:14:47 <xerox> yay!
11:14:48 <allbery_b> 32 bit pointers and ints are a little faster than 64 bit
11:16:14 <Toxaris> vincenz: well, it's a real language. the typical team (like 0.3 postdocs, 1 phd student, 1 student programmer) will not succeed.
11:17:12 * allbery_b wonders how lambdabot came up with those numbers
11:17:46 <int-e> hmm, lazily?
11:17:52 <dons> its filtering bots?
11:17:57 <vram> In the haskell wikibook, the following two commands are given.  "let r = 25 :: Double" and "let r = 25 :: Num a => a" . Both should produce the same result for a subsequent line "2*pi*r". But the second produces an error. Why? (sorry for the quotes, don't know of a way to distinguish code from prose)
11:18:05 <dons> like when my filesystem reports 105% due to root partitions
11:18:22 <dons> ?let r = 25 :: Num a => a
11:18:27 <lambdabot> Defined.
11:18:34 <dons> > 2*pi*r
11:18:37 <lambdabot> Terminated
11:18:40 <dons> vram: what error do you get?
11:18:41 <vincenz> Toxaris: "It's a real language" is a rather fuzzy claim
11:18:41 <allbery_b> silly bot
11:18:52 <dons> > 2*pi*r
11:18:52 <lambdabot> Terminated
11:18:57 <dons> > 2*pi
11:18:58 <lambdabot>  6.283185307179586
11:19:03 <vincenz> > r
11:19:04 <lambdabot> Terminated
11:19:13 <vincenz> > r :: Integer
11:19:14 <dons> ?undefine
11:19:15 <lambdabot> Terminated
11:19:15 <lambdabot> Undefined.
11:19:17 <allbery_b> was r already there?
11:19:17 <vram> The exact error msg: Prelude> 2*pi*r  <interactive>:1:5:     Couldn't match expected type `Double'            against inferred type `Integer'     In the second argument of `(*)', namely `r'     In the expression: (2 * pi) * r     In the definition of `it': it = (2 * pi) * r
11:19:19 <dons> ?let r = 25 :: Num a => a
11:19:20 <lambdabot> Defined.
11:19:23 <int-e> @type r
11:19:24 <Jaak> > let r = 25 :: Num a => a in 2*pi*r
11:19:25 <lambdabot>     Ambiguous occurrence `r'
11:19:25 <lambdabot>     It could refer to either `L.r', defined at <local>:1:0
11:19:25 <lambdabot>                           or `SimpleReflect.r', imported from SimpleReflect at State/imports.h:71:0-32
11:19:25 <lambdabot>  157.07963267948966
11:19:27 <allbery_b> yeh, I  thought so
11:19:30 <dons> vram: oh, its defaulting.
11:19:34 <dons> ah
11:19:38 <dons> Cale. grr
11:19:39 <allbery_b> it's the MMR, since the type is on the value, not the variable
11:19:42 <roconnor> ugh.  My haskell program sometimes spins
11:19:43 <int-e> @type L.r
11:19:44 <lambdabot> forall a. (Num a) => a
11:19:45 <Toxaris> r defaults to Integer, and pi to Double.
11:19:46 <allbery_b> and let is lazy so it's only caught on use
11:19:50 <roconnor> Not sure how to debug it.
11:20:03 <olsner> > let (r :: Num a => a) = 25 in 2*pi*r
11:20:03 <lambdabot>  Parse error in pattern at "in" (column 28)
11:20:07 <dons> Prelude> let r = 25 :: Num a => a
11:20:07 <dons> Prelude> :t r
11:20:07 <dons> r :: Integer
11:20:15 <olsner> > let r :: Num a => a = 25 in 2*pi*r
11:20:15 <lambdabot>  Parse error at "=" (column 21)
11:20:16 <Toxaris> which shows that the MMR and defaulting is bad.
11:20:26 <dons> vram, let r :: Num a => a ; r = 25
11:20:43 <simony> Toxaris, Continuing PeakerWork's question: Why would you want to express that rather than just saying all these 3 instances?
11:20:46 <vram> dons, I'll try that
11:20:59 <Cale> dons: what?
11:21:02 <Cale> @undefined
11:21:02 <lambdabot> Undefined.
11:21:10 <Toxaris> simony: you're talking about Alternative?
11:21:12 <Cale> > let r = 25 :: Num a => a in 2*pi*r
11:21:13 <lambdabot>  157.07963267948966
11:21:15 <simony> Toxaris, Yeah
11:21:46 <Toxaris> simony: but I don't see what 3 instances you mean
11:21:50 <simony> Toxaris, I think that if you have multiple classes with the exact same semantics - you reduce expressiveness
11:22:14 <simony> Toxaris, (or if one class is a more general case of another, as in Monoid vs Alternative)
11:22:53 <Toxaris> simony: to my knowledge, it is not possible to express the semantics of Alternative using some "type expression" over Monoid
11:24:35 <dons> SimpleReflect.r
11:25:13 <mofmog> so apparently putting bools into a DiffUArray doesn't work
11:25:26 <Toxaris> simony: because (Alternative f) means (Applicative f, forall a . Monoid (f a)) with the Monoid instances all "the same" in same sense I have trouble expressing in english
11:25:28 <vram> Hmm. Both "let r = 25 :: Num a => a in 2*pi*r" and "let r :: Num a => a ; r = 25" seem to work, but the original "let r = 25 :: Num a => a" doesn't. If this is expected, need to change the wikibook as well.
11:25:39 <dons> mofmog: DiffUArray's are slow
11:25:44 <mofmog> ack
11:25:54 <mofmog> i thought they'd be quicker than vanillar dffarrays
11:26:24 <Toxaris> simony: even the (forall a . Monoid (f a)) part above is not allowed in type constraints
11:26:41 <Toxaris> simony: (do you understand my point?)
11:27:18 <Taejo> Stack space overflow: current size 8388608 bytes.
11:27:19 <Taejo> Use `+RTS -Ksize' to increase it.
11:27:19 <Taejo> max@think:~/devel/word-games$ ./to2too +RTS -Ksize 1000000
11:27:19 <Taejo> bad RTS option: -Ksize
11:27:25 <dons> mofmog: oh quite possibly
11:27:27 <Taejo> what does this mean?
11:27:38 <dons> -K1M
11:27:45 <dons> -K10M
11:27:46 <mofmog> dons: I've had people suggest I use Data.Map but that seems to have the same problem as using lists...
11:27:52 <Taejo> dons: thanks
11:27:54 <dons> mofmog: what problem?
11:27:56 <lament> yay, dynamic typing
11:28:06 <mofmog> well i'm doing a CA simulator
11:28:11 <lament> i passed my python function the name of a file instead of the actual file, and it didn't complain even at runtime
11:28:21 <lament> instead, it cheerfully iterated over the characters of the file name
11:28:23 <mofmog> so far it works fine with DiffArrays holding the cells but with larger boards it slows down considerably
11:28:25 <Toxaris> simony: now, that was about the formal semantics of the type classes, but there are the informal semantics, too, as specified in the "monoid laws" and the "alternative laws". since the "alternative laws" specifiy a connection to applicative which isn't specified in the monoid laws, it makes sense to have a different name for Alternative
11:28:29 <dons> lament: heh
11:28:37 <mofmog> i used to have it working off of lists but that was muuuch slower than using diffarrays
11:28:44 <dons> mofmog: could you use real mutable arrays?
11:28:52 <mofmog> i -could-
11:29:08 <mofmog> that'd be uarrays correct? I thought that a DiffUArray would be ismilar
11:29:14 <Cale> mofmog: Are they unboxed, or boxed diff arrays?
11:29:27 <mattrepl> I'm likely doing something really dumb, but in some code I'm importing "Text.ParserCombinators.Parsec" and ghc tells me it can't the interface file.  That's completely reasonable, but I don't know where it would be and why it isn't picked up since Parsec is included in GHC now (this is on Mac OS X, one of the test binary distributions from a few months back)
11:29:29 <mofmog> as of now they are boxed and it's relatively slow
11:29:46 <mattrepl> *find
11:29:59 <Cale> Unboxing is probably the largest thing you can do to speed up things like this.
11:30:19 * dons programs in H'
11:30:20 <dons> extensions: BangPatterns, TypeOperators, MagicHash, ExistentialQuantification, UnboxedTuples, ScopedTypeVariables, CPP, ForeignFunctionInterface, UnliftedFFITypes, TypeFamilies, Rank2Types
11:30:42 <mofmog> Cale: I changed the BoardState stuff to just simple bools and I changed DiffArray to DiffUArray but it's complaining that i'm putting Bools into the DiffUArray
11:30:43 <Toxaris> simony: e.g. we have (Alternative f) => forall f . (f <$> x) <|> (f <$> y) == f <$> (x <|> y)
11:31:20 <mauke> what's UnliftedFFITypes?
11:31:32 <Toxaris> simony: (at least I think that this should hold ...) and the same is not true for all monoids, because there is no connection between <$> and mappend.
11:31:37 <mofmog> i even tested some stuff in ghci: for example listArray (1,5) [True, True, True, False, False] :: DiffUArray Int Bool
11:31:41 <mofmog> gives an error
11:31:51 <Saizan_> mauke: does ghc-pkg list includes "parsec" ? and, are you compiling with --make ?
11:32:17 <mauke> Saizan_: yes and yes
11:32:26 <Saizan_> err
11:32:29 <Cale> mofmog: Huh, that's a strange omission.
11:32:34 <Saizan_> mattrepl: that was for you ^^^^
11:32:37 <simony> Toxaris, sorry, was away, the forall is inside, I get it, thanks
11:32:39 <Cale> mofmog: Maybe go with UArray and see how that goes
11:32:44 <mofmog> alright
11:32:51 <Cale> mofmog: import Data.Array.Unboxed and change the type to UArray
11:32:58 <mattrepl> Saizan_:  got it, and no to both
11:33:02 <simony> Toxaris, but why is Alternative related to Applicative? Why subclass something if you don't use any of its methods?
11:33:22 <mattrepl> I guess Manuel's dist didn't include it, thanks
11:33:24 <Toxaris> simony: because the methods are used in the laws
11:33:41 <Saizan_> ?hackage parsec
11:33:42 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parsec
11:34:09 <dons> http://reddit.com/info/6gpsq/comments/ just for the quote, "Lately I've been writing programs with Haskell and noticed that I am not using design patterns anymore"
11:34:10 <Toxaris> simony: maybe Alternative should only subclass Functor, I'm not sure
11:34:47 <mattrepl> Saizan_:  thanks
11:34:52 <Toxaris> simony: in any case, there should be two Alternatives (for the "orElse" semantics and for the "plus" semantics)
11:36:03 <Toxaris> simony: but these are only definable in terms of <*> I guess. But I'm not sure. They are normally defined for MonadPlus in terms of >>=.
11:37:46 <simony> Toxaris, what "orElse"?
11:38:03 <Toxaris> simony: I consider the whole category-theory inspired part of the Haskell libraries to be work-in-progress which may well be designed differently in future languages, when people actually understand what they are doing from the beginning :)
11:38:45 <Toxaris> (x `orElse` y) means that x is executed. if it fails, y is executed.
11:39:03 <Toxaris> (x `plus` y) means that both x and y are executed and their results mixed together
11:39:07 <vram> > let r = 25
11:39:07 <lambdabot>  Parse error at end of input
11:39:34 <Toxaris> Maybe's <|> and mplus are "orElse"-like, and []'s <|> and mplus are "plus"-like
11:39:52 <Arnar_> @t orElse
11:39:52 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
11:39:53 <Toxaris> this is explained somewhere on the Haskell wiki
11:40:05 <Arnar_> @type orElse
11:40:06 <lambdabot> forall a. Maybe a -> Maybe a -> Maybe a
11:40:10 <vincenz> dons: that was already posted today..
11:40:27 <Toxaris> Arnar: orElse doesn't really exists :( in current Haskell, both plus and orElse are called mplus most of the time, and sometimes (<|>).
11:40:38 <Toxaris> Arnar: ok, looks like I'm wrong
11:40:54 <Arnar_> Toxaris: seems to be only for Maybe in the prelude
11:41:04 <Toxaris> Arnar: but I'm talking about a more general orElse, also working for every Error monad
11:41:14 * Saizan_ wonders whre that orElse is coming from
11:41:15 <Arnar_> yup
11:41:21 <Arnar_> @index orElse
11:41:22 <lambdabot> Data.Generics.Aliases, Data.Generics, GHC.Conc, Control.Concurrent.STM
11:41:44 <dons> vincenz: with a crappy title
11:41:57 <vincenz> dons: bah
11:41:58 <mofmog> alright i've switched over succesfully. not a lot of speedup however
11:42:00 <dons> vincenz: a good title is the most important thing on reddit.
11:42:25 <vram> Another quick question. Is there a way to know the type of a variable in ghci ?
11:42:35 <byorgey> vram: use :type
11:42:36 <dons> compare and contrast: "Parallel generational-copying garbage collection with a block-structured heap :: PDF"   -- 12 pts
11:42:45 <dons> "GHC's new parallel garbage collector: multicore GC for Haskell " -- 66 pts
11:42:55 <vram> +byorgey
11:43:00 <vram> byorgey+
11:43:06 <vincenz> vram: two +s
11:43:07 <vram> byorgey++
11:43:20 <pejo> dons, the first one gives a lot more information though.
11:43:42 <vincenz> dons: you're becoming redditized :)
11:43:54 <dons> titles aren't about packing the most information into a single sentence
11:44:21 <dons> this is just stupidly simple stuff. think about Wadler's paper titles, for similar reasons
11:44:28 <mofmog> hmm, it seems as if my algorithm is to blame here
11:45:31 <vram> > let r = 25 :: Num a => a in 2*pi*r
11:45:32 <lambdabot>  157.07963267948966
11:47:11 <Saizan_> mofmog: maybe your algorithm needs a mutable one
11:48:08 <mofmog> well i changed the structure to UArrays
11:48:18 <mofmog> and it runs about the same unelss i'm sing the wrong operator here
11:48:38 <Saizan> UArrays are unboxed immutable
11:48:41 <dons> mofmog: are you using -O ?
11:48:51 <mofmog> dons: yes
11:48:54 <dons> maybe your bottlenecks lie elsewhere
11:49:01 <mofmog> i'm pretty sure it does
11:49:18 <mofmog> wait so what about DiffUArrays? Arent they mutable?
11:49:27 <mofmog> but then dons told me they're slow
11:49:42 <mofmog> (and they dont work with bools which is silly)
11:50:00 <Saizan> mofmog: an overview on the various arrays http://www.haskell.org/haskellwiki/Arrays
11:50:02 <lambdabot> Title: Arrays - HaskellWiki
11:50:28 <Saizan> mofmog: however the raw mutable ones are IOArray or STArray (and the U variants)
11:50:47 <olsner> I-owe-you-Array? :P
11:51:13 <kosmikus> dons: is the cryptol homepage supposed to be offline?
11:51:15 <mofmog> hrmm... i'm sort of scared of grafting IO or something on
11:51:24 <dons> kosmikus:  hmm.
11:51:43 <dons> kosmikus: I will talk to the cryptol guys. they need a better web presence
11:51:46 <simony> Toxaris, I thought <*> was just infix for fmap?
11:51:53 <simony> oh wait that's <$> ?
11:51:53 <Saizan> DiffArrays use a mutable representation but exposes an immutable api, so they should be a good compromise but it seems they are not optimized enough
11:52:00 <simony> @src (<$>)
11:52:01 <lambdabot> f <$> a = fmap f a
11:52:03 <simony> oops
11:52:10 <simony> @src (<*>)
11:52:11 <lambdabot> Source not found. Just try something else.
11:53:04 <simony> Toxaris, I think it will be easier to understand with an example.. When are these things used?
11:53:27 <kosmikus> dons: if it is supposed to be no longer online, then you might want to remove the link at http://galois.com/cryptol.php
11:53:28 <lambdabot> Title: Cryptol
11:53:49 <dons> kosmikus: i think it should be online
11:55:19 <Toxaris> simony: <*> is like ap, but more general
11:56:55 <Toxaris> > pure "first answer" <|> pure "another answer" :: Maybe String -- simony: <|> has the orElse semantics here
11:56:56 <lambdabot>  Just "first answer"
11:57:12 <kosmikus> dons: ok ;)
11:57:23 <Toxaris> > pure "first answer" <|> pure "another answer" :: [String] -- simony: not <|> has "plus" semantics, both answers are preserved
11:57:24 <lambdabot>  ["first answer","another answer"]
11:59:26 <Toxaris> simony: does that help?
12:00:06 <Toxaris> simony: there is a Haskell wiki page about the difference between plus and orElse (for MonadPlus, but the same thing should apply for Alternative)
12:00:30 <Toxaris> simony: by the way, I don't think we need MonadPlus, (Monad f, Alternative f) should be enough
12:01:21 <Toxaris> now about my examples: I basically want to <|> work like it does with maybes, and introduce <+> which work like <|> work with lists
12:01:30 <Toxaris> some functors would allow both operators, e.g., lists
12:02:43 <Toxaris> simony: or consider Parsec. Parsec's <|> is a "orElse"-<|>, but Parsec can also express <+> with:  x <+> y = try x <|> y
12:03:02 <Toxaris> other parser combinator libraries already provide <|> and <+>, but with different names
12:03:11 <Toxaris> like <++ and +++ or something like that.
12:03:27 <Toxaris> wouldn't it be nice to have this distinction in a common framework
12:05:04 <Taejo> @src words
12:05:04 <lambdabot> words s = case dropWhile isSpace s of
12:05:04 <lambdabot>     "" -> []
12:05:04 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
12:05:21 <Saizan> Toxaris: parsec's x <+> y = try x <|> y is still an orElse, y is not executed if x succedes
12:05:55 <Taejo> @src break
12:05:55 <lambdabot> break p =  span (not . p)
12:06:02 <Taejo> @src span
12:06:03 <lambdabot> Source not found. There are some things that I just don't know.
12:06:09 <Taejo> @type span
12:06:10 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:06:38 <Taejo> > span (=='/') "foo/bar"
12:06:39 <lambdabot>  ("","foo/bar")
12:06:45 <Taejo> > span (!='/') "foo/bar"
12:06:45 <lambdabot>   Not in scope: `!='
12:06:50 <Taejo> > span (/='/') "foo/bar"
12:06:50 <lambdabot>  ("foo","/bar")
12:07:01 <Toxaris> Saizan: I think it is. e.g. (try (return 1) <|> return 2) >>= guard . (== 2)) should succeed
12:07:14 <Toxaris> Saizan: but i'm not too sure
12:08:13 <Saizan> i'm pretty sure it doesn't, parsec doesn't collect multiple results
12:09:15 <simony> Toxaris, I am sorry, I am on/off around keyboard :) I am definitely reading what you're writing though
12:09:31 <simony> Toxaris, also doing a lambdabot query to fill in some gaps in the background ;)
12:10:04 <Toxaris> :t try
12:10:05 <lambdabot> Not in scope: `try'
12:10:08 <Toxaris> :(
12:10:15 <mauke> do, or do not. there is no try.
12:10:40 <allbery_b> :t Text.ParserCombinators.Parsec.try
12:10:41 <lambdabot> forall tok st a. Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
12:10:49 <allbery_b> gesundheit.
12:12:55 <Taejo> how do I build profiling libraries for a Cabal package?
12:13:37 <Saizan> Taejo: configure with -p
12:14:00 <Saizan> iirc, check configure --help if i'm wrong
12:15:08 * byorgey hands out lambda-pears
12:16:07 <Toxaris> > Text.ParserCombinators.Parsec.parse ((Text.ParserCombinators.Parsec.try (return 'A') Text.ParserCombinators.Parsec.<|> return 'B') >>= guard . (== 'A')) "" ""
12:16:09 <lambdabot>   Not in scope: `Text.ParserCombinators.Parsec.<|>'
12:16:28 <Toxaris> :t (Text.ParserCombinators.Parsec.<|>)
12:16:30 <lambdabot> forall tok st a. Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
12:16:45 <Toxaris> allbery_b: still :(
12:16:55 <Toxaris> Saizan: anyway, you're right.
12:16:56 <Arnar_> > Text.ParserCombinators.Parsec.parse ((Text.ParserCombinators.Parsec.try (return 'A') `Text.ParserCombinators.Parsec.(<|>)` return 'B') >>= guard . (== 'A')) "" ""
12:16:56 <lambdabot>  Parse error at ".(<|>..." (column 116)
12:19:45 <Toxaris> simony: ok, looks like I'm wrong about parsec, but you get the idea and it is applicable to other parser combinator approaches. And I guess it is sensible to express that Parsec only supports orElse but not plus, so that I can write a parser wich works in every parser monad which supports plus, and the type checker would realize that Parsec is not suitable for my parser
12:28:44 <simony> Does anyone remember a function whose @type will show a forall that's not at the outermost level?
12:29:32 <nibro> simony: a standard function, or just any function at all?
12:29:38 <paolino> :t runST
12:29:39 <lambdabot> forall a. (forall s. ST s a) -> a
12:30:41 <simony> thanks
12:30:45 <kpreid> runST's s is a phantom type, though...
12:30:58 <sjanssen> huge traffic on haskell-cafe over the past 12 hours
12:31:02 <simony> anything simpler?
12:31:40 <monochrom> f :: (forall a. a->a) -> Int -> Int; f g x = g x
12:32:33 <nibro> f :: (forall a. a->a) -> Int -> Bool -> (Int, Bool); f g x y = (g x, g y)
12:32:43 <simony> what's the difference between that and  "f :: forall a. (a->a) -> Int -> Int; f g x = g x" ?
12:33:17 <nibro> simony: your type wouldn't work for my example, it shows you the difference
12:33:36 <nibro> well, it wouldn't work for monochrom's either
12:33:42 <monochrom> My example is useless, but fills your request for "simpler".
12:34:11 <simony> why does this type not fit monochrom's example?  "f :: forall a. (a->a) -> Int -> Int; f g x = g x" ?
12:34:23 <monochrom> It does.
12:34:40 <nibro> monochrom: no, it doesn't
12:34:43 <simony> ok, then why doesn't it fit nibro's example?
12:34:56 <damg> class (Eq c) => C c where \ foo :: c a -> a \ Kind error: 'c' is applied to too many arguments. *scratching the bean on the neck*
12:35:01 <simony> I thought the forall a. would only matter if 'a' is referenced somewhere else
12:35:24 <damg> do I have to provide an Eq constraint to a, too ?
12:35:43 <simony> @src Eq
12:35:43 <lambdabot> class  Eq a  where
12:35:43 <lambdabot>     (==), (/=)   :: a -> a -> Bool
12:35:48 <nibro> damg: type constructors cannot instantiate Eq
12:35:54 <ndm> @seen malcolmw
12:35:54 <lambdabot> I saw malcolmw leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 2h 57m 16s ago, and .
12:36:17 <simony> damg, (Eq a) -- note that 'a' is used as a type there, which means its kind is *, not (*->*) so it cannot be applied to a type argument
12:36:37 <damg> ah
12:37:11 <damg> ok, looks like I'll have to restudy the idea of classes. Thank you for information! :-)
12:38:26 <nibro> simony: there's no difference between "f :: (a -> a) -> Int -> Int" and "f :: forall a . (a -> a) -> Int -> Int"
12:38:49 <simony> nibro, so what does moving the forall inside the first arg/func do?
12:38:53 <nibro> both types say, take a function from some a to the same a, and an Int, and produce an Int
12:39:01 <nibro> note the "from some a"
12:40:01 <nibro> "f :: (forall a . a -> a) -> Int -> Int" says take a function that can be applied to *all* a, and return the same a it was applied to, and then an Int and return an Int
12:40:27 <nibro> @let foo :: Int -> Int; foo x = x
12:40:28 <lambdabot> Defined.
12:40:57 <nibro> @let f :: (a -> a) -> Int -> Int; f g x = g x
12:40:57 <lambdabot> Couldn't match expected type `a' against inferred type `Int'
12:41:11 <nibro> @let f :: (forall a. a -> a) -> Int -> Int; f g x = g x
12:41:12 <lambdabot>  Parse error
12:41:23 <nibro> ah, lambdabot doesn't do forall's, pity
12:41:30 <nibro> but that one would have worked anyway
12:41:52 <nibro> but note how the one that didn't work complained that it couldn't be sure that a = Int
12:42:16 <simony> I thought it means that the type inference managed to deduce a more specific type than you mentioned?
12:42:24 <nibro> it's supposed to take a function from *some* a to the same a, and there's no guarantees that that a will be Int
12:42:46 <nibro> no, that definition would never work, since a /= Int
12:43:07 <nibro> @let g = f g x = g x
12:43:08 <lambdabot>  Parse error
12:43:09 <monochrom> @djinn (a->a)->(b->b)
12:43:10 <lambdabot> f _ a = a
12:43:17 <simony> yeah, I see, but since 'a' is only used inside the parens, I am still unsure what it means to put the forall in there
12:43:24 <nibro> @let g f x = f x
12:43:25 <lambdabot> Defined.
12:43:28 <nibro> @ty g
12:43:30 <lambdabot>     Ambiguous occurrence `g'
12:43:30 <lambdabot>     It could refer to either `L.g', defined at <local>:2:0
12:43:30 <lambdabot>                           or `SimpleReflect.g', imported from SimpleReflect at State/imports.h:71:0-32
12:43:38 <nibro> eh
12:43:47 <allbery_b> @ty L.g
12:43:48 <lambdabot> forall t t1. (t -> t1) -> t -> t1
12:44:40 <nibro> simony: consider the type of show
12:44:44 <nibro> @ty show
12:44:45 <lambdabot> forall a. (Show a) => a -> String
12:45:15 <nibro> show can be applied to an argument of any type that instantiates Show
12:45:45 <nibro> you could pass it to a function that takes as its argument a function of exactly that type
12:45:57 <simony> when the forall is outside its easy, I am wondering when it matters when the forall is put inside
12:46:12 <nibro> say f :: (forall a. (Show a) => a -> String) -> Int -> String
12:46:23 <nibro> or even better
12:46:27 <nibro> say f :: (forall a. (Show a) => a -> String) -> Int -> Bool -> String
12:46:41 <nibro> f g x y = g x ++ g y
12:47:06 <nibro> note that with this definition, I'm applying the function argument g to arguments x and y of different types
12:47:21 <monochrom> I suggest studying logic. This is exactly the same situation as "forall x. (Px implies Q)" vs "(forall x. Px) implies Q".
12:47:36 <simony> nibro, thanks!
12:47:59 <nibro> simony: np :-)
12:55:55 <paolino> monochrom: the second reads : independently of what it is x , P x implies Q ?
12:57:06 <dolio> The second is, given a proof that Px holds for all x, you can prove Q.
12:57:39 <dolio> I think.
12:58:21 <monochrom> paolino's statement should be formalized as the first.
12:58:32 <paolino> ah
12:59:34 <monochrom> The first formula is almost never encountered in life. Thus humans have little experience with it, and have the feeling that it is counterintuitive.  (intuition = experience)
13:03:02 <monochrom> Let Px = "x is learning haskell", Q = "I am ditching python".
13:03:57 <monochrom> Let me be in an office with John, Bob, and Mary, and that's it.
13:04:03 <paolino> ?babel en it ditch
13:04:04 <lambdabot>   fossa
13:04:45 <monochrom> forall x. (Px implies Q) = (if John is learning haskell, I'm ditching python) and (if Bob is learning haskell, I'm ditching python) and (if Mary is learning haskell, I'm ditching python).
13:05:14 <Taejo> is there a profiling option to include library functions as call centres?
13:05:14 <monochrom> (forall x. Px) implies Q = if John, Bob, and Mary are all learning haskell, I'm ditching python.
13:05:20 <Taejo> *cost centres
13:05:48 <paolino> monochrom: then first ands are or ?
13:06:02 <Saizan> Taejo: maybe look at SCC pragmas
13:06:09 <monochrom> No, I made sure I made no mistake there.  forall = big and.
13:06:34 <Taejo> Saizan: it's an option, but does mean I have to edit the library source code
13:08:12 <Saizan> Taejo: you could annotate the line whre you use those functions
13:08:17 <monochrom> I suppose sometimes "or" means "and" and "and" means "or" in English.
13:09:12 <paolino> with forall x. (Px implies Q) if John is learning haskell I'm ditching python independently of if Bob is learning haskell ?
13:09:22 <byorgey> those first things are "and" in the sense that you can prove all three of those statements.
13:09:26 <monochrom> First example of confusion.  "you ditch python and I'm going to report it to Guido" = if you ditch python, I'm going to report it to Guido = not(you ditch python) or I'm going to report it to Guido.
13:09:29 <dolio> Well, you can fiddle that first one around to look like (Px1 or Px2 or Px3) -> Q, I suspect.
13:09:41 <byorgey> right.
13:09:47 <dolio> Instead of (Px1 -> Q) and (Px2 -> Q) and (Px3 -> Q)
13:10:17 <monochrom> Second example of confusion.  "if b then P else Q" = (b implies P) and (not b implies Q) = (b and P) or (not b and Q).
13:11:19 <idnar> uh what
13:11:22 <idnar> I don't follow that last one
13:11:37 <monochrom> Combine second example with first example.  (b and P) or (not b and Q) = "if b, P; or if not b, Q".
13:12:13 <monochrom> But of course it's also (b implies P) and (not b implies Q) = "if b, P; and if not b, Q".
13:12:21 <monochrom> Therefore "and" = "or".
13:12:43 <Saizan> (forall x. (Px -> Q) is like \Pi x:P.Q in System F, right?)
13:12:52 <monochrom> forall = Pi.
13:13:13 <idnar> (b implies P) and (not b implies Q) = (not b or P) and (b or Q) ... how do you go from there to (b and P) or (not b and Q)?
13:13:34 <monochrom> distribute, simplify.
13:13:48 <idnar> hmm
13:14:04 <idnar> oh ok
13:14:14 <idnar> man, I guess my boolean algebra is rusty
13:14:31 <idnar> anyhow yeah, English sucks
13:14:44 <monochrom> Good conclusion.
13:15:35 <paolino> I suppose other languages don't
13:16:27 <kosmikus> Haskell doesn't ;)
13:16:39 <dons> hehe
13:16:54 <monochrom> I only know English and Chinese. They both suffer the same problem here. However, the statement "English sucks" does not imply anything about other languages, while we're logical at it.
13:17:03 <idnar> paolino: as a native English speaker, I'm most familiar with English's sucktitude
13:17:24 <idnar> I don't feel as qualified to comment on other languages
13:17:40 <paolino> anyway , thanks monochrom, I need to trust someone every now and then
13:17:47 <dons> kosmikus:  http://www.cryptol.net/ seems up
13:18:00 <monochrom> A less ambiguous informalization of "forall x. (Px implies Q)" may be: if John is learning haskell, I'm ditching python. if Bob is learning haskell, I'm also ditching python. etc.
13:18:06 <dons> kosmikus: was that the site that was down earlier?
13:19:19 <kosmikus> dons: well, it's not down, but I get a Network Solutions page saying, among other things, "cryptol.net expired on 04/13/2008 and is pending renewal or deletion."
13:19:29 <kosmikus> and I still get that page
13:19:58 <paolino> monochrom: . is shortest than  and (or/and) or
13:20:03 <monochrom> Here is a very intrinsic reason why everyone is inclined to confuse "and" with "or". And so it ought to pervade all languages. Let S = {1,2,3}.
13:21:00 <dons> kosmikus: hmm.
13:21:10 <dons> so it expired, and the renewel was sent to the wrong address
13:21:14 <monochrom> There are many ways to say S={1,2,3}.  One way: "the elements of S are 1 and 2 and 3", or even formally "1 in S and 2 in S and 3 in S".  This uses and.
13:21:17 <dons> kosmikus: so it should definitely be back up in a day or so
13:21:23 <dons> kosmikus: and its up for me here.
13:21:35 <kosmikus> dons: I don't really need it. I just wanted to let you know because I noticed it.
13:21:38 <monochrom> Second way: x in S iff x=1 or x=2 or x=3.  This uses or.  Thus the confusion.
13:21:59 <dons> kosmikus: yeah, the cryptol team is a bit embarrassed. they've not been maintaining the site properly :)
13:23:43 <lament> English doesn't suck :(
13:30:12 <kamaji> hey all, why is "not (n <- list)" in a guard not valid?
13:30:46 <kamaji> or is the <- operator only for that set/list notation
13:30:54 <Taejo> kamaji: (n <- list) is not an espression
13:31:16 <kamaji> I thought <- meant "member of"?
13:31:26 <Taejo> kamaji: no
13:31:37 <byorgey> kamaji: if you want to test for inclusion, use the 'elem' function
13:31:43 <byorgey> > 3 `elem` [1,2,4]
13:31:47 <lambdabot>  False
13:32:11 <kamaji> byorgey: ok
13:32:15 <byorgey> (n <- list) is special syntax that roughly means "let n take on each value from the list in turn"
13:33:08 <kamaji> So I can use it in a where clause?
13:33:17 <byorgey> kamaji: which?
13:33:22 <kamaji> <-
13:33:24 <byorgey> no
13:33:29 <byorgey> only in a list comprehension
13:33:53 <byorgey> (actually, it can be used for an entirely different purpose in a pattern guard, but you probably don't need to worry about that =)
13:34:04 <kamaji> oh ok
13:34:04 <monochrom> <- is for list comprehension and do notation only
13:34:13 <byorgey> oh, duh, and do notation =)
13:34:17 <lament> and for monad comprehension!
13:34:23 <byorgey> I knew there was another use of <- I was forgetting ;)
13:34:27 <kamaji> oh god, so many things i've never heard of ;_;
13:34:53 <lament> kamaji: fear not. List comprehensions are just convenient syntax sugar and you can totally live without them, anyway.
13:35:16 <lament> and in that context, <- is part of list comprehensions, not a standalone operator
13:35:17 <byorgey> kamaji: heh, don't worry about it, you'll get there =)
13:35:20 * monochrom hands lament some sugar letter L's for comfort concerning our attack on English :)
13:35:33 <lament> <3
13:36:00 <monochrom> ambiguity is great for humour and poetry, don't get me wrong.
13:36:04 <lament> yes
13:36:08 <lament> english is wonderfully expressive
13:36:15 <paolino> kamaji: use list comprehension whenever you need to make happy a pythonista reading your code
13:36:37 <lament> of course, every human language with a strong literary tradition is going to be wonderfully expressive
13:36:45 <byorgey> heh, they are sometimes useful for more than that =)
13:36:50 <lament> but english is probably better for poetry than most languages (than any other language?)
13:37:08 <kamaji> I was trying to use list comprehension, but I couldn't figure out a way to make it work (i'll paste something later - I want to see if I can get this working first)
13:37:11 <lament> (very similar to how perl is the best language for cryptic one-liners)
13:37:21 <paolino> easier
13:37:25 <monochrom> But when people argue and mince words just because there is a slight misunderstanding over "and" vs "or", I feel sad. Their time could be used more productively.
13:38:38 <lament> misunderstandings can usually be preempted by accurate use of language
13:39:38 <byorgey> kamaji: good luck! feel free to paste if you get stuck, we're here to help.
13:39:39 <monochrom> education for accurate use, ambiguity and subtlety awareness, and logic is in order
13:39:59 <kamaji> byorgey: thanks =)
13:40:10 <lament> monochrom: should all be part of English courses :)
13:45:33 <Toxaris> lament: why is "probably better for poetry than most languages"?
13:45:44 <Toxaris> lament: ... english ...
13:46:05 <kamaji> I think it has the most words
13:46:12 <lament> Toxaris: extremely expressive, many synonyms with subtly different, deep connotations
13:46:22 <kamaji> ^
13:46:37 <lament> Toxaris: syllable structure allows for complicated rhyme and meter schemes
13:46:48 <lament> (compare to say spanish - much more limited)
13:47:38 <lament> poetry is a lot like those cryptic perl one-liners: saying a lot with little
13:47:45 <byorgey> SYLL-a-ble STRUCT-ure al-LOWS for... COM-pli-CA-ted RHYME and ME-ter SCHEMES
13:48:16 <byorgey> a perfect example! =)
13:48:30 <opqdonut> :P
13:48:39 <dolio> "COM-pli-CA-ted"?
13:48:55 <byorgey> sure.  how do you pronounce "complicated"?
13:49:03 <byorgey> there's a secondary stress on the 'ca'.
13:49:27 <dolio> Eh. Not as much as the COM when I say it.
13:49:40 <byorgey> right, it's a secondary stress.
13:49:41 <Toxaris> *secondary*
13:49:51 <byorgey> but it still fits an iambic meter.
13:50:10 <Toxaris> ok I see. Still, I dislike english for it's simple one information per word scheme
13:52:27 <Toxaris> which makes one use long chains of words like in "I will be being ..." to express a simple idea
13:54:49 <clanehin_> Who says "I will be being?"  "I will be going to the store."  Granted, that's a lot of verbs, but it's very specific in terms of at that exact time, I will be doing that.  Rarely used.
13:55:42 <Taejo> is there a way to see which functions are taking stack space and which are tail-recursing?
13:56:44 <Beelsebob> -prof -auto-all
13:57:06 <Taejo> Beelsebob: and where in the profile can I see this info?
13:57:27 <Beelsebob> you can get it to do stack graphs of what functions took up space when
13:57:28 <Heffalump> I'd suggest a heap profile
13:57:32 <Beelsebob> indeed
13:57:36 <Taejo> ok, cool
13:57:42 <kamaji> with list comprehension, how would I define a recursive list where the new element is added after the list? for example instead of ones = 1 : ones, I would have ones = ones:1 ?
13:57:43 <lament> Toxaris: it's not a very big deal
13:58:09 <Heffalump> you need to be careful about the concept of "stack space" and "tail recursion"; in a lazy language they aren't necessarily what you care about.
13:58:20 <kamaji> wait, scratch that :|
13:58:23 <Beelsebob> kamaji: in general, adding items to the end of lists is inefficient -- you have to use ++ to step down the list
13:58:25 <lament> Toxaris: most languages really suck at this, except for like Inuit
13:58:31 <lament> Toxaris: english is pretty average
13:59:03 <Saizan> > let ones = ones ++ [1] in ones -- boom
13:59:19 <lambdabot>  thread killed
13:59:44 <Syzygy-> > let ones = ones ++ [1] in last ones
13:59:59 <lambdabot>  thread killed
14:00:17 <tromp> u can't even test for null
14:03:11 <Toxaris> lament: well, i'm neither author nor linguist, so I'm not too deep into this topic. I've learned some latin and ancient greek at school, and I'm generally more impressed of their approach to forming words and adding information
14:04:01 <kamaji> Syzygy-: sorry, I can't seem to figure out what "in last ones" part does :\
14:04:06 <Toxaris> this is especially true for greek, which allows to express such things as "We have done something one time in the past which was very important for us" in one word
14:04:06 <lament> Toxaris: oh, i agree, it's pretty impressive
14:04:26 <lament> Toxaris: but the problem is that those things work only for a set of special cases
14:04:38 <lament> Toxaris: and otherwise, the regularity of latin and greek hinders them
14:04:39 <dolio> > last [1..10]
14:04:40 <lambdabot>  10
14:04:45 <lament> english, on the other hand, is a huge mess of random crap
14:04:59 <Toxaris> english is untyped
14:05:06 <lament> basically :)
14:05:06 <kamaji> but what is the "in" part?
14:05:25 <dolio> Part of let expressions.
14:05:30 <dolio> > let x = 5 in x
14:05:31 <lambdabot>  5
14:05:42 <dolio> let DECLARATIONS in EXPRESSION
14:05:44 <lament> Toxaris: i'm a native speaker of a language (Russian) morphologically similar to latin and greek, and i think english is more powerful
14:07:32 <wolverian> lojban!
14:07:45 * dolio writes all his poetry in lojban.
14:07:54 <kamaji> oh, so let expressions are just like variables (only you can't change them)?
14:08:19 <dolio> They're a way to define local bindings.
14:08:31 <Botje> kamaji: in haskell, variables aren't.
14:08:31 <Toxaris> kamaji: yes, if you stretch "just like" far enough.
14:08:57 <kamaji> heh
14:09:13 <Philippa> kamaji: let expressions are just like blocks in C or Java, except there's only the one non-declaration statement (it's after the 'in') and the variables are immutable
14:09:36 <Philippa> but they're sufficiently alike that there are impure functional languages where you use let statements /exactly/ like C or Java blocks
14:09:44 <monochrom> python is just like haskell, only you can't statically type, you can't override layout, you can't STM, you can't use continuations, you can't ...
14:10:00 <seabre> Hello, I'm pretty new to haskell, and I'm having problem with figuring out how with some code I've written: http://hpaste.org/7115  . Hugs says it's a type problem...but I don't exactly understand why as all of the arguments are integers..
14:10:16 <Botje> :type (^)
14:10:25 <Botje> @type (^)
14:10:27 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
14:10:53 <monochrom> use fromIntegral to convert between Int and Integers.  both ways.
14:11:06 <seabre> oh ok
14:12:00 <Botje> seabre: tetration (x,y) is probably not what you want
14:12:27 <Botje> you want tetration x y
14:12:57 <Taejo> awesome: my program seems to work on small training data, now I just need to fix the space leak so I can use big data
14:14:16 <Philippa> monochrom: the difference is that the form I'm describing actually does get used as a compiler IR
14:14:28 <Philippa> they genuinely /are/ closely related
14:14:43 <Philippa> (consider the relationship between let and do...)
14:16:04 <Toxaris> lament: but I think I see your point, if i try to look at languages from a (programming) language designer's point of view. english is relatively composable, there are uniform abstractions and easy mechanisms to extend the language to new domains, there is good localization support ...
14:16:32 <Toxaris> lament: the "but" is left from an early draft of that sentence.
14:17:05 <Toxaris> lament: it fit's better here: but i'm supposed to use this time to learn danish, not chat about and in english, so that's it for me now
14:18:28 <Toxaris> lament: thanks for explaining your point.
14:19:13 <lament> i'm sure danish is a fine language too :)
14:20:13 <kamaji> hmm, sorry to annoy you all again, but what is wrong with "let test list = list ++ [n] | n <- [1..] in test [1,2]"     ?
14:20:24 <Apocalisp> Jåh, det er det.
14:20:34 <Apocalisp> (fnys)
14:20:45 <kamaji> can I not use | there?
14:21:25 <Botje> kamaji: [n | n <- ....]
14:21:29 <dolio> > let test list = list ++ [ [n] | n <- [1..] ] in test [1,2]
14:21:30 <lambdabot>   add an instance declaration for (Num [t])
14:21:30 <Botje> not [n] | n <- ...]
14:21:40 <Botje> or that.
14:22:28 <dolio> [ n | n <- [1..] ] = [1..], of course.
14:23:21 <Botje> I hope GHC 11 will have DWIM and direct neural interface.
14:24:54 <kamaji> ohhhhhhhhhhhh
14:24:57 <grahamhutton> dolio: what do you mean by =?  Equality for infinite structures normally means bisimilarity (or equivalent)
14:24:59 <kamaji> light dawns on marble head
14:25:04 <kamaji> thanks everyone ^^
14:27:12 <dolio> It means that substituting one for the other in your program will not change the results.
14:27:32 <grahamhutton> ok (contextual equivalence)
14:27:36 <dolio> Unless I'm mistaken on the strictness of list comprehensions somewhere.
14:27:37 <Saizan> map id = id
14:28:04 <Philippa> Saizan: that's one of those weird ones that's not /quite/ true but good enough we let it typecheck :-)
14:28:34 <Philippa> so yeah, good counterexample
14:29:40 <Toxaris> is this list comprehension desugared to (map id [1..])? I would have expected something like ([1..] >>= return) :: [Int]
14:30:19 <dolio> I don't know what GHC does, but the report has a set of rules for interpreting list comprehensions.
14:30:26 <Saizan> i hope it's actually optimized to [1..] in the end
14:31:08 <grahamhutton> [1..] >>= return is the same as [1..], by one of the monad laws (m >>= return = m)
14:33:12 <dolio> [ e | True ] = [e], [ e | q] = [ e | q, True ], [ e | b, Q ] = if b then [ e | Q ] else [], [ e | p <- l, Q ] = let ok p = [ e | Q] ; ok _ = [] in concatMap ok l, [ e | let decls, Q] = let decls in [ e | Q ]
14:35:08 <dolio> So, [ n | n <- [1..] ] turns into something like 'let ok n = [n] ; ok _ = [] in concatMap ok [1..]' by the rules.
14:36:00 <Toxaris> so it's basically ([1..] >>= return), but worded differently
14:36:17 <dolio> Effectively.
14:36:48 <dolio> The question is whether GHC is smart enough to figure out that you can turn it into [1..]
14:37:22 <Toxaris> grahamhutton: now you use "is the same" in a unspecified way similar to dolio's use of =
14:37:28 <Toxaris> hmm too late
14:37:54 <Philippa> Toxaris: no he didn't, he quoted the law immediately afterwards
14:38:48 <Toxaris> Philippa: and the law uses =
14:38:59 <dmwit> [f | x <- m, p] = do { x <- m; guard p; return f }
14:39:40 <dmwit> Where f and p can refer to x.
14:39:43 <Philippa> Toxaris: yep, although it's commonly taken to be the sense dolio was actually using
14:39:49 <Philippa> indeed, /defined/ to be
14:50:00 <Taejo> does compiling with -p -auto-all affect the speed of my code if I don't run with profiling?
14:50:41 <dolio> Philippa: I thought your reply to oleg about monad transformers was interesting. (A bit of a belated, but I didn't read it until somewhat recently.)
14:52:06 <Philippa> dolio: thanks. Did anything stick out for you? I suspect I may come back to the issue where I nearly pulled a Fermat, because I'm pretty certain that can be done...
14:52:14 <dolio> Philippa: It kind of mirrored one thing I was thinking when looking at Disciple, that it doesn't appear to let me define my own effects.
14:53:02 <Philippa> Yeah. I still haven't had a good look myself - we got a talk about what I presume was Disciple's state at the time at AngloHaskell though
14:55:46 <simony> @src MonadPlus
14:55:46 <lambdabot> Source not found. I am sorry.
14:57:50 <therp> "pulled a Fermat" :)
14:58:43 <Philippa> therp: I'd done somewhat more thinking about it that day than the post suggests, but didn't produce any actual source. The only difficulty I'd have in producing something in Scheme would be the fact I've barely written any though
14:59:02 <Philippa> something that types OK in Haskell would be rather more of a challenge
14:59:39 <therp> Philippa: sorry, I'm not aware of the actuall content of your mail. but whatever it is, I find "pulled a Fermat" quite amusing
14:59:42 <dons> Taejo: yes.
14:59:48 <Philippa> (I'm sure it's doable in principle, in practice I intend to come back to it when I've been hit by the relevant bit of inspiration)
14:59:55 <dons> it puts lots of ticks in the code, and interferes with optimisations
15:01:22 <dons> rewrite rules likely don't fire as well
15:01:43 <Taejo> dons: thanks
15:02:56 <SamB> Philippa: that seems to be a popular approach to problem solving ;-)
15:03:43 <fnord123> Hi all, I'm trying to understand Comonads and came across sigfpe's post here: http://sigfpe.blogspot.com/2008/03/comonadic-arrays.html I'm not sure I completely follow it and was wondering if someone knew of a distillation that was more along the lines of "if you want to do X or Y, then you could do it in ___ way, but if you use a comonad, it's even easier" (i.e. why will someone use a comonad?).
15:03:44 <lambdabot> Title: A Neighborhood of Infinity: Comonadic Arrays
15:05:20 <fnord123> I think I understand that comonadic arrays are useful because you can access neighbouring elements in the array, where map would not be able to...
15:05:54 <Philippa> SamB: I've got plenty of stuff to get on with in the meantime, and I know that I'm more or less missing the relevant tools to do it now so I'm better off soaking up appropriate knowledge for a while if I want to get it done anyway
15:08:38 <fnord123> aw crud, sigfpe's cellular automata post (http://sigfpe.blogspot.com/2006/12/evaluating-cellular-automata-is.html) says almost exactly what I've just said. as soon as i ask, I find out or figure out the answer myself. :-/
15:08:39 <lambdabot> Title: A Neighborhood of Infinity: Evaluating cellular automata is comonadic, http://tinyurl.com/2e55ly
15:09:29 <Jaak> comonads is quite good abstraction to represent context dependant computation in. and pointer in array is pretty context dependant
15:11:31 <simony> Toxaris, in the case of Maybe, is there a difference between <|> and >> ?
15:12:05 <simony> oops they're the opposite
15:12:49 <simony> never mind :)
15:12:59 <Toxaris> > Nothing >> (Just 42)
15:13:14 <lambdabot>  thread killed
15:13:27 <Toxaris> > Nothing >> Just "42"
15:13:28 <lambdabot>  Nothing
15:13:37 <Toxaris> > Nothing <|> Just "42"
15:13:38 <lambdabot>  Just "42"
15:14:17 <Toxaris> > Just "1" >> Just "42"
15:14:18 <lambdabot>  Just "42"
15:14:26 <Toxaris> > Just "1" <|> "Just 42"
15:14:26 <lambdabot>  Couldn't match expected type `Maybe [Char]'
15:14:35 <Toxaris> > Just "1" <|> Just "42"
15:14:37 <lambdabot>  Just "1"
15:14:49 <Toxaris> simony: in what sense are they opposite?
15:15:11 --- mode: ChanServ set +o glguy
15:15:23 <Philippa> Toxaris: <|> is 'catch'
15:15:40 <simony> Toxaris, >> tries to take the "least", with a right-bias,  and <|> tries to take the "most" with a left-bias
15:15:42 <Philippa> "do something else on Nothing", whereas >> is "do something else on Just"
15:15:46 <simony> Toxaris, where most/least are Just/Nothing
15:15:46 --- topic: set to '["The Haskell programming language" ,"http://haskell.org " ,"Paste: http://hpaste.org " ,"Logs: http://tunes.org/~nef/logs/haskell/ ","Call for papers: http://haskell.org/haskell-symposium/2008/CFP.html "]' by glguy
15:15:58 --- mode: ChanServ set -o glguy
15:16:55 <Toxaris> ok I see interesting perspective
15:17:53 <Toxaris> if (>>) on Maybe means to take the "least", does it make sense to call Maybe a "strict monad"?
15:18:31 <Toxaris> (actually, I remember chatting with someone about the meaning of "strict monad" some months ago)
15:21:20 <Jedai> @hoogle <|>
15:21:21 <lambdabot> Control.Applicative.(<|>) :: Alternative f => f a -> f a -> f a
15:21:22 <lambdabot> Text.ParserCombinators.Parsec.Prim.(<|>) :: GenParser tok st a -> GenParser tok st a -> GenParser tok st a
15:21:54 <Jedai> @src Maybe <|>
15:21:55 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
15:22:02 <Jedai> @src Maybe (<|>)
15:22:03 <lambdabot> Nothing <|> p = p
15:22:03 <lambdabot> Just x  <|> _ = Just x
15:22:14 <Philippa> Toxaris: yes, I'd call Maybe a strict monad
15:22:19 <Jedai> @src Maybe mplus
15:22:20 <lambdabot> Nothing `mplus` ys = ys
15:22:20 <lambdabot> xs      `mplus` ys = xs
15:25:19 <fnord123> Jaak: what else might a comonad be a useful abstraction for?
15:25:46 <simony> @src mplus
15:25:47 <lambdabot> Source not found.
15:25:50 <simony> @src MonadPlus
15:25:50 <lambdabot> Source not found. Maybe you made a typo?
15:25:52 <simony> Why?
15:26:16 <Jaak> fnord123: streams
15:26:43 <Jedai> simony: mplus is an instance method so you must give the instance
15:26:52 <Jedai> @src Either mplus
15:26:53 <lambdabot> Left _ `mplus` n = n
15:26:53 <lambdabot> m      `mplus` _ = m
15:27:02 <Jedai> @info MonadPlus
15:27:03 <lambdabot> MonadPlus
15:27:56 <byorgey> @src Maybe mplus  -- same as <|> for Maybe
15:27:56 <lambdabot> Source not found.
15:28:03 <byorgey> @src Maybe mplus
15:28:04 <lambdabot> Nothing `mplus` ys = ys
15:28:04 <lambdabot> xs      `mplus` ys = xs
15:28:11 <Valodim> how do I drop the return of a function?
15:28:20 <Valodim> is there a more elegant way than
15:28:20 <Valodim> x >> return ()
15:28:33 <fnord123> streams where your computation depends on other parts of the stream? like hamming codes, perhaps? or would you say any and all streams?
15:28:34 <byorgey> not really
15:29:11 <Jedai> Valodim: no, you can always define "ignore a = a >> return ()" though
15:29:38 <Valodim> hum. I think I'll stick to >> then
15:29:39 <Valodim> thanks
15:31:44 <Jaak> fnord123: take a look at http://lambda-the-ultimate.org/node/988
15:31:49 <lambdabot> Title: The essence of Dataflow Programming by Tarmo Uustalu and Varmo Vene | Lambda the ...
15:32:26 <lament> lambda, the ultimate dataflow?
15:32:37 <Jaak> :)
15:33:30 <Valodim> why is there stuff like liftM2, liftM3, liftM4??
15:33:50 <Valodim> wouldn't liftMX with the first arugment as an int do the same job, just more haskell-ish?
15:34:07 <Jaak> what would the type be?
15:34:26 <lament> dependent :)
15:34:30 <Valodim> dang
15:34:31 <Jaak> very :P
15:34:38 <lament> Valodim: think of tuples
15:35:35 <fnord123> Thanks Jaak.
15:35:36 <ddarius> (>>) is like multiplication, <|> is like summation
15:35:57 <lament> Valodim: you think liftM is ugly, look at http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Enum.html#maxBound
15:35:59 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/6msavf
15:36:00 <lament> scroll down like half way
15:36:08 <simony> according to:  http://www.mail-archive.com/haskell@haskell.org/msg18075.html   is MonadPlus redundant to Monoid, or is it still useful, but also useful to have that as an adapter?
15:36:09 <lambdabot> Title: Re: [Haskell] MonadPlus vs. Monoid
15:36:10 <ddarius> <|> is mplus
15:36:19 <dolio> http://hpaste.org/6815 zipWithN
15:36:26 * Jaak is off now
15:36:33 <lament> that code is horrendous :(
15:36:53 <simony> Toxaris, oops, I missed your question above, I don't know what a "strict monad" means
15:39:09 <simony> why is the type of hpaste the same type of fmap? :-)
15:39:29 <ddarius> It's not quite the same
15:39:39 <lament> it's not quite the same - it's much less valid :)
15:40:01 <mofmo1> so readline returns a Maybe... how do i deal with multiple readlines elegantly inside main?
15:40:09 <ddarius> It's perfectly valid, albeit there are no non-bottom implementations of it.
15:40:34 <lament> @djinn (a -> b) -> f a -> f b
15:40:34 <lambdabot> -- f cannot be realized.
15:40:45 <mofmo1> or should i or should i distribute out the readlines ?
15:41:30 <Jedai> I think I saw a nicer zipWithN somewhere
15:41:41 <TomMD> @djinn (a -> f b) -> f a -> f b
15:41:41 <lambdabot> -- f cannot be realized.
15:41:47 <dolio> Mine isn't nice? :)
15:41:48 * ddarius is far behind on haskell-cafe.
15:42:00 <Jedai> dolio: Your's is in Agda
15:42:38 <Jedai> s/Your's/yours/
15:42:54 <mauke> :t map . transpose
15:42:55 <lambdabot>     Couldn't match expected type `a -> b'
15:42:55 <lambdabot>            against inferred type `[[a1]]'
15:42:55 <lambdabot>     Probable cause: `transpose' is applied to too many arguments
15:43:00 <mauke> er
15:43:03 <Jedai> Anyway it worked in a simple Hindley-Milner type system
15:43:09 <mauke> :t map ?f . transpose
15:43:10 <lambdabot> forall b a. (?f::[a] -> b) => [[a]] -> [b]
15:44:00 <Toxaris> simony: well, to be strict basically means to not return something "bigger" then the input
15:44:25 <simony> does anyone know if Alternative, as Toxaris said, should actually have inherited Functor, rather than Applicative?
15:44:36 <ddarius> You can make a bunch of functions that can be used together to get a zipWithN like effect, much like ap can be used to get a liftMN effect.
15:45:37 <Jedai> @hoogle ZipList
15:45:38 <lambdabot> Control.Applicative.ZipList :: newtype ZipList a
15:45:38 <lambdabot> Control.Applicative.ZipList :: [a] -> ZipList a
15:45:38 <lambdabot> Control.Applicative.getZipList :: ZipList a -> [a]
15:46:40 <mauke> > let f x y z = x * y + z in getZipList $ pure f <*> ZipList [1,2,3] <*> ZipList [4,5,6] <*> ZipList [1,-2,0]
15:46:41 <lambdabot>  <Plugins.Eval>:1:10: parse error on input `='
15:46:59 <vincenz> :t ZipList
15:47:01 <lambdabot> forall a. [a] -> ZipList a
15:47:11 <vincenz> > Ziplist [1]
15:47:12 <lambdabot>   Not in scope: data constructor `Ziplist'
15:47:16 <vincenz> > ZipList [1]
15:47:17 <lambdabot>   add an instance declaration for (Show (ZipList t))
15:47:27 <mauke> > let f x y z = x * y + z in f
15:47:28 <lambdabot>  <Integer -> Integer -> Integer -> Integer>
15:47:42 <vincenz> @src getZipList
15:47:43 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
15:47:48 <vincenz> @src Control.Applicative.getZipList
15:47:49 <lambdabot> Source not found. Are you on drugs?
15:47:52 <mauke> @src ZipList
15:47:52 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
15:47:57 <Toxaris> vincenz: newtype ZipList a = ZipList {getZipList :: [a]}
15:48:03 <vincenz> Toxaris: ah, thanks :)
15:48:16 <Toxaris> vincenz: so it's just a newtype over lists to allow a different Applicative instance
15:48:24 * vincenz nods
15:48:36 <vincenz> I thought was like a zipper
15:48:39 <vincenz> Or a DLIst
15:50:26 <saml> > [(+1)] :: [Int -> Int]
15:50:27 <lambdabot>  [<Int -> Int>]
15:52:55 <Jedai> > let f x y z = x * y + z ; z = zipWith ($) in (repeat f) `z` [1, 2, 3] `z` [4,5,6} `z` [1,-2,0]
15:52:56 <lambdabot>  Parse error at "}" (column 81)
15:53:38 <Jedai> > let { f x y w = x * y + w ; z = zipWith ($) } in (repeat f) `z` [1, 2, 3] `z` [4,5,6} `z` [1,-2,0]
15:53:38 <lambdabot>  Parse error at "}" (column 85)
15:53:51 <ddarius> You have a '}' instead of a ']'
15:54:00 <Jedai> > let { f x y w = x * y + w ; z = zipWith ($) } in (repeat f) `z` [1, 2, 3] `z` [4,5,6] `z` [1,-2,0]
15:54:02 <lambdabot>  [5,8,18]
15:54:14 <Jedai> ddarius: Thanks ^^
16:01:19 <mofmo1> getFile = do {x <- readfile z; E.catch (return x) (\e -> do {putStrLn "Bad file."; getFile;}
16:01:22 <mofmo1> seems to not work
16:01:38 <dolio> Jedai: http://hpaste.org/7116
16:01:39 <mofmo1> for some reason catch doesnt catch the fact that "x" in "return x" might be a bad value
16:01:51 * dolio goes to dinner.
16:02:28 <tromp> :t E.catch
16:02:30 <lambdabot> Couldn't find qualified module.
16:02:41 <mofmo1> E is Control.Exception
16:02:53 <tromp> :t Control.Exception.catch
16:02:54 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
16:02:56 <mauke> mofmo1: er, 'return' doesn't throw exceptions
16:03:11 <mofmo1> so... i want getFile to return an IO String
16:03:21 <tromp> you can only hope to catch in readFile
16:03:40 <mofmo1> hrmm ok
16:03:58 <dons> http://reddit.com/info/6gqx0/comments/ yay darcs 2
16:04:57 <mofmo1> can i put a do thunk into it?
16:05:00 <mofmo1> i'm assuming yes
16:05:45 <tromp> there's no thunk type:)
16:06:06 <tromp> u can put any IO a there
16:06:46 <mofmo1> cool it works
16:07:50 <Jedai> dolio: That's pretty nice, looks like it could be more generally useful
16:08:09 <EvilTerran> in a manner of speaking, there is a distinction between "thunk types" and non-thunks
16:08:22 <EvilTerran> types of kind # are never thunks :P
16:09:33 <tromp> yes, there are the unthunkables
16:14:33 <saml> that's a good domain name: unthunkables.com
16:14:49 <mauke> unthunkabl.es
16:17:55 <lament> the thunk which can be thunked is not the true thunk.
16:18:11 <lament> Haskell: We put the "thunk" in "thunktion"!
16:18:55 <mauke> Ã¾unk
16:19:52 <saml> @go what is thunk in  haskell
16:19:53 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Laziness
16:20:13 <adiM> Does someone have some examples showing how to use the functional graph library in haskell
16:21:09 <adiM> I tried an example shown in http://hpaste.org/7109.
16:21:17 <adiM> a1 = (...) & empty works
16:21:25 <adiM> a2 = (...) & a1 works
16:21:44 <adiM> but when I try a3 = (...) & (...) & empty, I get errrors
16:24:09 <int-e> adiM: apparently & is left associative, so you need (...) & ((...) & empty)
16:25:18 <Cale> How convenient ;)
16:26:05 <int-e> it has no fixity declaration at all.
16:26:10 <kamaji> what does "Warning: Pattern match(es) are overlapped" mean?
16:26:32 <adiM> int-e: d'oh. That was it. Somehow the papers gave the impression that & will figure out things on its own.
16:26:47 <glguy> > let f (x:xs) = 1; (x:xs) = 2 in f [3]
16:26:49 <lambdabot>   add an instance declaration for (Num [t])
16:26:49 <lambdabot>     In the expression: 2
16:26:49 <lambdabot>     In a...
16:27:01 <glguy> > let f (x:xs) = 1; f (x:xs) = 2 in f [3]
16:27:02 <lambdabot>      Warning: Pattern match(es) are overlapped
16:27:02 <lambdabot>              In the definition...
16:27:12 <glguy> see how the second case will never happen
16:27:15 <EvilTerran> kamaji, it means one branch of your code will never be followed, as its pattern is obscured by a higher up pattern in the same matching
16:27:20 <glguy> it's pattern is overlapped with with the first
16:27:38 <int-e> > let f (1:xs) = 1; f (x:xs) = 2 in f [3]
16:27:39 <lambdabot>  2
16:27:54 <EvilTerran> partial overlapping isn't warned about, because it's not a problem and often useful
16:28:25 <mauke> > let f x = x; let f 1 = 2 in f 1
16:28:25 <lambdabot>  Parse error at "let" (column 14)
16:28:27 <adiM> Is there some way I can make & behave in the same way as $
16:28:28 <EvilTerran> but you get a warning if a pattern completely subsumes a lower one, as that means the second one will never match *anything*
16:28:37 <mauke> > let f x = x; f 1 = 2 in f 1
16:28:38 <lambdabot>      Warning: Pattern match(es) are overlapped
16:28:38 <lambdabot>              In the definition...
16:28:40 <EvilTerran> adiM, with difficulty
16:29:32 <EvilTerran> import it qualified, then say infixr [insert number here] &; (&) = (Data.[Whatever].&)
16:29:37 <kamaji> so it's if you have two contradicting patterns?
16:29:41 <kamaji> I'm not sure I quite get it
16:30:15 <EvilTerran> two patterns in the same pattern-match where the earlier one can match anything that would otherwise be matched by the later one
16:30:21 <saml> > let {f x = x; f 1 = 2;}
16:30:21 <lambdabot>  Parse error at end of input
16:30:42 <kamaji> oh right
16:30:44 <kamaji> got it
16:30:46 <EvilTerran> so the later one will never be matched against successfully
16:31:01 <adiM> EvilTerran, what should be the number with infixr?
16:31:09 <EvilTerran> whatever seems appropriate
16:31:19 <kamaji> so the first pattern always takes precedence?
16:31:23 <int-e> adiM: an integer from 1 to 9
16:31:31 <saml> adiM: infixr 0 $
16:31:33 <EvilTerran> yes, they're tried in the order they're written
16:31:38 <int-e> oh. 0 to 9
16:31:39 <kamaji> oh yeah >_>
16:32:29 <EvilTerran> adiM, it's the precedence of the operator. 0 is lowest precedence, like $, and 9 is highest
16:32:55 <EvilTerran> :: is lower precedence than everything, and juxtaposition (the " " in "f x") is higher
16:33:29 <mauke> and record update is highest!
16:33:40 <EvilTerran> ah, yes. forgot that one
16:33:54 <adiM> thanks for explaining.
16:34:05 <EvilTerran> @ in patterns is higher precedence than juxtaposition, too, although lower than record matching
16:34:52 <saml> > f a {a = 1} + 1
16:34:52 <lambdabot>      `a' is not a record selector
16:35:10 <mofmo1> how do i handle exceptions coming out of read?
16:35:35 <EvilTerran> ?src Read
16:35:35 <lambdabot> class Read a where
16:35:35 <lambdabot>   readsPrec    :: Int -> ReadS a
16:35:35 <lambdabot>   readList     :: ReadS [a]
16:35:35 <lambdabot>   readPrec     :: ReadPrec a
16:35:35 <lambdabot>   readListPrec :: ReadPrec [a]
16:35:39 <EvilTerran> use readPrec
16:35:46 <mauke> mofmo1: use reads
16:35:52 <EvilTerran> er, readsPrec. yes, or reads.
16:36:32 <mauke> > reads "()xyz"
16:36:33 <lambdabot>  [((),"xyz")]
16:36:52 <mofmo1> er
16:37:03 <mofmo1> read as in the thing that takes a string and outputs a number?
16:37:11 <lament> > reads "1+2+[3,4]"
16:37:12 <lambdabot>  []
16:37:13 <saml> > maybeRead "2343"
16:37:13 <lambdabot>   Not in scope: `maybeRead'
16:37:18 <Jedai> > reads "hello" :: [(Int,String)]
16:37:20 <lambdabot>  []
16:37:23 <mauke> mofmo1: read doesn't return a number
16:37:36 <mauke> mofmo1: it returns whatever you want, as long as it's an instance of Read
16:37:42 <mofmo1> oh i see
16:37:48 <mofmo1> OH
16:38:00 <saml> read is Deserialization
16:38:01 <mofmo1> so i could do "read x1 :: IO Int
16:38:05 <Jedai> > reads "23h" :: [(Int,String)]
16:38:06 <lambdabot>  [(23,"h")]
16:38:08 <mofmo1> and then get an IO Int
16:38:09 <mofmo1> alright
16:38:13 <mauke> > read "" :: IO Int
16:38:13 <lambdabot>   add an instance declaration for (Read (IO Int))
16:38:13 <lambdabot>     In the expression: read...
16:38:22 <mauke> no, IO a is not an instance of Read
16:38:32 <Jedai> mofmo1: No, not IO Int, just Int
16:38:35 <Valodim> any way to get a windows tray icon in haskell?
16:38:46 <mofmo1> oh damn
16:39:08 <mofmo1> hrm. how do i go around seeing whether or not read parses right with catch?
16:39:16 <mauke> mofmo1: use reads instead
16:39:39 <saml> mofmo1: http://www.haskell.org/pipermail/libraries/2008-February/009213.html
16:39:41 <lambdabot> Title: Proposal: Add Text.Read.maybeRead :: Read a => String -> Maybe a, http://tinyurl.com/6yeemn
16:40:46 <saml> > let canParse s = case reads s of [(x, "")] -> True; _ -> False in canParse "243"
16:40:47 <lambdabot>  Add a type signature
16:41:38 <saml> i think canParse is impossible
16:41:40 <adiM> EvilTerran: Thanks, here is the modified code that works perfectly. http://hpaste.org/7109#a1
16:42:48 <EvilTerran> :)
16:43:09 <Syzygy-> ?pl \x y z -> x ++ y ++ z
16:43:09 <Syzygy-> ?pl \x y z -> x ++ y ++ z
16:43:09 <lambdabot> (. (++)) . (.) . (++)
16:43:09 <lambdabot> (. (++)) . (.) . (++)
16:43:15 <Syzygy-> Ah. There we are.
16:43:17 <EvilTerran> seems odd that they haven't given it such a fixity decleration themselves. i'd suggest filing a bug report, seeing as you'd never want that to be left-associative.
16:43:21 <Syzygy-> Had some HORRIBLE lag there for a while.
16:43:50 * SamB wonders if he should feel pleasantly surprised that gmail, upon detecting firebug, merely commented that it would probably slow gmail down and linked to a page with instructions to prevent the slowdown...
16:44:21 <saml> gmail is already slow without firebug
16:44:39 <SamB> saml: true enough
16:44:54 <SamB> probably needs some Google Gears love
16:45:08 <simony> hey, why is MonadReader's local requiring that the function be env->env, why can't it create an env of a new type, and then convert a Reader monad of the new environment type to one of the old type?
16:45:43 <SamB> simony: mostly because that would make it much harder to write the type signature for the class...
16:45:47 <EvilTerran> ?type curry ((++) . uncurry (++))
16:45:48 <lambdabot> forall a. (Monoid a) => a -> a -> a -> a
16:45:57 <simony> SamB, it should be possible, though?  Even for ReaderT?
16:46:03 <SamB> and because that would mean that instances had to be parametric in environmnet type
16:46:06 <EvilTerran> > curry ((++) . uncurry (++)) "ab" "cd" "ef"
16:46:06 <lambdabot>  "abcdef"
16:46:06 <Pseudonym> It's not a problem for Reader or ReaderT.
16:46:13 <Pseudonym> It's a problem for MonadReader.
16:46:15 <EvilTerran> Syzygy-, better?
16:46:15 <SamB> simony: sure you can do it for those two
16:46:54 <simony> why can't MonadReader stay the same but add an "m2" which is locally specified (MonadReader m2)=>   in the type of "local" ?
16:47:09 <EvilTerran> or (((++) .) . (++))
16:47:10 <mauke> because there is no runReader
16:47:18 <SamB> that would be too general a type
16:47:24 <EvilTerran> (or (++) .: (++), with the combinator defined)
16:47:27 <Bonus> what does ~ in pattern matching to
16:47:28 <Bonus> do*
16:47:35 <Bonus> like blah ~(x:xs)
16:47:37 <mauke> Bonus: lazy destructuring
16:47:43 <Bonus> oh
16:47:45 <EvilTerran> altho my way does the (++)s with the wrong associativity, i guess
16:47:48 <SamB> Bonus: it makes the pattern match succeed, and puts off the binding part
16:47:48 <Bonus> i thought it was lazy by default
16:48:01 <Bonus> aha
16:48:01 <EvilTerran> > case Nothing of Just x -> "this doesn't work"
16:48:02 <lambdabot>   Non-exhaustive patterns in case
16:48:02 <mauke> that would make pattern matching useless
16:48:07 <simony> mauke, when I define the instance of MonadReader I already have a "runReader", no?
16:48:10 <EvilTerran> > case Nothing of ~Just x -> "this does"
16:48:10 <lambdabot>  Parse error in pattern at "->" (column 25)
16:48:13 <mauke> simony: where?
16:48:17 <SamB> and, you know, the part where that value gets reduced to WHNF
16:48:17 <allbery_b> basically the pattern match doesn't happen until the value is rerquested.  top level pattern matches are strict by default unless you use ~; let pattern matches are lazy
16:48:22 <EvilTerran> er
16:48:28 <EvilTerran> > case Nothing of ~(Just x) -> "this does"
16:48:29 <lambdabot>  "this does"
16:48:35 <allbery_b> (and case, which is what top level matches turn into)
16:48:42 <EvilTerran> > case Nothing of ~(Just x) -> "but you can't look at " ++ x
16:48:42 <simony> mauke, "instance MonadReader ((->) a) where local ... =" has "runReader" which is id.  For other instances it has runReader too
16:48:43 <lambdabot>   Irrefutable pattern failed for pattern (Data.Maybe.Just x)
16:48:54 <Syzygy-> EvilTerran: How would .: be defined?
16:49:02 <mauke> simony: yes, but not for (MonadReader m2)
16:49:03 <EvilTerran> ?type runReader
16:49:04 <lambdabot> forall r a. Reader r a -> r -> a
16:49:18 <EvilTerran> Syzygy-, the usual definition is "(f .: g) x y = f (g x y)"
16:50:09 <Syzygy-> Aight.
16:50:39 <EvilTerran> or (.).(.)
16:50:47 <Syzygy-> Oh. The boobies combinator.
16:50:53 <mauke> fmap fmap fmap
16:51:14 <EvilTerran> ... or (.)(.)(.), the Eccentrica Gallumbits combinator
16:51:26 <Syzygy-> Oooooookay. What is it about this combinator that makes it this pervy?
16:51:41 * Syzygy- associates straight from fmap fmap fmap to fap fap fap
16:52:16 <simony> mauke, why doesn't MonadReader have "runReader" as a method too?
16:52:17 <Beelsebob> >.<
16:52:19 <mauke> class Fuctor f where fap :: (a -> b) -> f a -> f b
16:52:55 <mauke> simony: what would its type be?
16:52:55 <EvilTerran> "fuctor? nearly killed 'er!"
16:52:55 <EvilTerran> (sorry)
16:53:19 <proqesi> *functor
16:53:29 <mwotton> do i need to do anything special to have Setup.hs see the packages i installed with cabal as a user?
16:53:40 <saml> @hoogle fap
16:53:41 <lambdabot> No matches found
16:53:55 <allbery_b> usually the --user flag (to the configure and install steps)
16:54:00 <wadcom> hi
16:54:06 <EvilRanter> hm. peer.
16:54:10 <simony> mauke, class MonadReader m env where runReader :: m env a -> env -> a
16:54:47 <mauke> simony: that would make ReaderT useless
16:54:58 <mauke> runReaderT doesn't return a
16:55:06 <mwotton> allbery_b: you rock. thanks.
16:57:59 <SamB> hmm, apparantly google has a relaxed attitude towards gmail javascript hax...
16:58:22 <SamB> they even have code to help your hax not break...
16:59:28 <dibblego> apparently
17:09:59 <SamB> funky how HTTP requests aren't served on a "first request, first response" basis ;-)
17:10:25 <simony> mauke, I made it!  but I had to use a glasgow ext. I can make a MonadReader class with a local that looks like: local :: (Monad (m2 oldenv), MonadReader m2 oldenv) => (oldenv -> env) -> m env a -> m2 oldenv a
17:13:24 <simony> mauke, can that work with a ReaderT too?
17:14:51 <dons> huh, darcs-2.0 put  is really fast
17:14:55 <dons> darcs++
17:17:20 <simony> then why are they giving up? :)
17:18:41 <OceanSpray> what's the relationship between the simply-typed lambda calculus and dependent types?
17:19:05 <OceanSpray> The notation for Epigram looks disturbingly familiar.
17:21:38 <twanvl> OceanSpray: roughly dependent types = lambda calculus + dependent sum and product types (exists and forall / pair and function)
17:22:04 <simony> MonadWriter class seems to be using glasgow-exts.. does it exist in Haskell98's stdlib? If so, how?
17:22:19 <elliottt> simony: it's not haskell98
17:22:48 <elliottt> it requires multi param type classes and functional dependencies and some other bits :)
17:23:26 <simony> elliottt, oh, so its not in the stdlib unless you -fglasgow-extts?
17:23:46 <elliottt> well, it's in extralibs (with ghc)
17:24:01 <simony> ah. when are these things going to go into Haskell08?
17:24:02 <simony> :)
17:24:03 <elliottt> so if you want to declare an instance of MonadWriter, you have to use -fglasgow-exts
17:24:17 <elliottt> hehe :)
17:25:06 <simony> is anyone maintaining a list of "problems" (things that aren't cleanly solved) of the Haskell type system?
17:25:20 <Jedai> simony: Haskell08 ? You're optimist ! When is Haskell' sheduled anyway ? (if it is sheduled at all)
17:25:36 <Pseudonym> No.  When someone comes up with a problem, they write a paper with the solution.
17:25:43 <simony> Pseudonym, hehe
17:25:50 <simony> Pseudonym, I have a problem but not a solution :)
17:25:55 <Jedai> simony: You can consult the Haskell' wiki and tickets
17:25:56 <od> is there any way to run parsec backwards on a string without having to reverse the string
17:26:02 <elliottt> simony: what's the problem?
17:26:06 <simony> Jedai, I don't think there is a solution
17:26:27 <byorgey> od: no, I don't think so.
17:26:35 <simony> My problem is the ugliness of creating a newtype for a Monad Transformer stack, along with a lot of named lifters... (liftFirstMonad = id, liftSecondMonad =lift, liftOtherMonad = lift . lift ... and so on
17:26:49 <Jedai> od: With the latest parsec (3) maybe
17:27:07 <elliottt> simony: that should only be necessary if you've got a big stack of the same transformer
17:27:19 <twanvl> simony: try to use classes like MonadSomething instead
17:27:23 <elliottt> otherwise, it should just work
17:27:29 <Pseudonym> First off, there's O(n) work.
17:27:35 <Pseudonym> In creating those lifters.
17:27:43 <simony> twanvl, that's not good, I use multiple instances of the same Monad type in my stack
17:27:54 <Pseudonym> Secondly, you probably shouldn't be thinking in terms of lift-to-this and lift-to-that.
17:28:13 <twanvl> simony: which monad?
17:28:15 <elliottt> you can derive all the Monad* instances for the different transformers that you need the functionality of
17:28:17 <Pseudonym> You should probably be thinking of the stack as a whole, and then making operations that are logically significant.
17:28:22 <Pseudonym> Rather than physically significant.
17:28:47 <simony> elliottt, No, I have a Monad stack composed of a reader, two states, and an internal monad on top, and each has a different purpose. I have  liftGui, liftModel, liftEnv  and just lift for the two states, reader monad, and the internal monad defined.. they were ugly to define but thus they are not ugly to use
17:28:56 <Pseudonym> So instead of liftToThirdMonad (put s), you should be making putGuiState s
17:29:04 <twanvl> Pseudonym: did you just call a stack of monad trasformers "physical"?
17:29:10 <saml> simony: what's wrong with liftGui, liftModel...etc?
17:29:10 <Pseudonym> Why yes, I did.
17:29:28 <saml> in Java, you need getters. in haskell, you need lift functions
17:29:35 <simony> Pseudonym, but putGuiState would then also need modifyGuiState, and other State functions, so I'd rather expose just liftGui
17:29:52 <simony> saml, there's nothing wrong with _using_ them.  Defining them is a lot of boilerplate ugliness :)
17:29:57 <saml> maybe we need to wrap liftGui..etc in a namespace
17:29:58 <twanvl> When you have multiple state variables it is usually easier to create a record type
17:30:19 <Pseudonym> simony: Or even better, don't expose putGuiState either./
17:30:26 <elliottt> simony: why not make your state a pair, then write putGuiState/etc in terms of the element in the pair, then you'd only need one StateT
17:30:52 <twanvl> then you say: getGuiState = gets guiState;  putGuiState g = modify \s -> s{ guiState = g } -- etc.
17:31:01 <Pseudonym> simony: Another option is that if there's an IO underneath, use a ReaderT with a record of IORefs.
17:31:03 <simony> saml, I would like to be able to do something like:  newtype MyMonadStack = MyMonadStack (guiEnv=ReaderT GUIEnv (modelst=StateT ModelState (guist=StateT GuiState InternalMonad a))))
17:31:19 <simony> Pseudonym, I don't want to use IORefs, they are ugly :-)
17:31:31 <Pseudonym> That's why you hide them behind an abstract interface.
17:31:34 <simony> Pseudonym, if I use IORefs and generally just IO and avoid a transformer stack sure it "solves" the problem
17:31:56 <simony> elliottt, Yes, but that is much more clumsy
17:32:08 <simony> elliottt, and it requires duplicating get/put from state to work on the tuple elements
17:32:26 <simony> elliottt, or I'd have to directly work with a tuple when using the state, which is even worse
17:33:01 <elliottt> simony: you wouldn't have to work directly with the tuple if you defined the interface to your state
17:33:03 <twanvl> simony: records help here, and you can reuse the gets and modify functions for getting and setting the state
17:33:04 <simony> Pseudonym, well, if your suggestion is to just avoid a transformer stack, then I agree its a usable workaround.  I am mentioning a problem with a transformer stack though
17:33:25 <Pseudonym> Either way, you should be hiding your stuff behind an abstract interface.
17:33:31 <Pseudonym> So you can use IORefs later if you want to.
17:33:34 <simony> elliottt, then I would have to define get, put, and modify at least, which were already defined for me by State. I don't think its nice to duplicate the effort of implementing modify in terms of get/put all over again
17:33:36 <dmwit> http://neilmitchell.blogspot.com/2008/04/summer-of-code-2008.html # is this for real?
17:33:37 <lambdabot> Title: Neil Mitchell's Haskell Blog: Summer of Code 2008
17:33:44 <dmwit> That seems like a lot to accomplish in one summer.
17:33:48 <simony> twanvl, records?
17:33:50 <dmwit> (Which would be awesome!)
17:34:16 <saml> a phd student mentoring another phd student
17:34:20 <Pseudonym> It is a lot, but if anyone can do it, nbm can.
17:34:31 <twanvl> record:  data MyStateType = MyStateType { guiState :: GuiState, otherState :: OtherState, etc }
17:34:33 <SamB> @oes okasaki
17:34:33 <lambdabot> "Lazy binary" representation of n. Also called redundant binary representatio...
17:34:33 <lambdabot> [0,1,10,11,20,101,110,111,120,201,210,1011,1020,1101,1110,1111,1120,1201,1210...
17:34:37 <Pseudonym> Hang on, need to reboot.
17:34:45 <SamB> @oes okasaki horribly
17:34:50 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
17:34:52 <simony> twanvl, that does not define a modify function for me automatically
17:35:22 <twanvl> simony: indeed you have to write it yourself, but it becomes very short
17:35:41 <Pseudonym> OK, maybe I don't.
17:35:45 <simony> twanvl, Well, what if there were 15 functions and not just 3 in State?
17:35:54 <simony> twanvl, I'd have 15 short ones to duplicate to work on my tuple? :)
17:36:03 <SamB> @oes okasaki failure
17:36:03 <lambdabot> Maximal number of symbols in terms generated by an inefficient set of rewrite...
17:36:03 <lambdabot> [1,2,4,8,16,32,273,65569,4294967361,15177100720513508366558296147058741458143...
17:36:13 <simony> twanvl, I think its nicer to "inherit" all the State functionality by defining a single lifter
17:36:24 <twanvl> simony: if you have 15 different state variables you will already have a very large program
17:36:51 <simony> twanvl, not 15 state variables, 15 functions as in get/put/modify/other_conveniences_built_on_top
17:37:05 <simony> twanvl, get/put/modify are the first 3
17:37:17 <twanvl> are there any others you need?
17:37:17 <dmwit> SamB: Whoops, that tenth one is really quite large!
17:37:36 <simony> twanvl, I don't know, I'd rather have all the State goodness available to me by default though
17:37:55 <simony> twanvl, for all I know there may be many interesting functions that do nice things to MonadState that I would love to use, and don't know yet :)
17:38:20 <simony> twanvl, and using this tuple inhibits my use of them
17:38:27 <dolio> @seen Jedai
17:38:28 <lambdabot> Jedai is in #perl6 and #haskell. I last heard Jedai speak 11m 38s ago.
17:38:57 <twanvl> simony: In my experience get/put/modify are enough
17:38:59 <Jedai> dolio: Yes ?
17:39:08 <dolio> Jedai: http://hpaste.org/7116#a1
17:39:14 <simony> twanvl, Well, I'm trying to talk about the principle of the thing :-)
17:39:22 <simony> twanvl, It applies to other kinds of monads too
17:39:30 <twanvl> simony: and for get you are already in the optimal situation, you can simply say "gets guiState"
17:39:42 <simony> twanvl, if I had a stack with auto-defined lifters for named stack elements, that would solve my problem neatly
17:39:49 <od> is parsec 3 maintaned by someone else? it seems like 2.0 is the highest on the old site
17:39:57 <simony> @type gets
17:39:59 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
17:40:22 <simony> twanvl, Hmm?
17:40:57 <twanvl> simony: a record declaration like the one I showed earlier introduces a 'getter' function for each field
17:41:08 <Jedai> dolio: Nice, Haskell type system really allows for some complicated things now :)
17:41:28 <simony> twanvl, yeah, its a usable workaround here, but there's a root problem to solve
17:42:36 <mofmo1> omg my program is a memory hog
17:43:14 <twanvl> simony: I don't really see the problem. Issues with larger monad stacks only come up in larger programs (by definition), and in larger programs you want to make better interfaces anyway, with special functions providing just the needed functionality.
17:44:33 <simony> twanvl, having a liftGui or liftSpecialMonad exposes a rich world of SpecialMonad's interface functions to use on the monad -- why would I want to write specific functions that limit me to reimplement clumsy wrappers of these rich interfaces?
17:44:57 <byorgey> mofmo1: well, send it to its room until it learns to share.
17:45:22 <twanvl> simony: because the Gui module should not let other code mess directly with the state, instead you want showWindow, addWindow, drawCircle, etc.
17:45:28 <Pseudonym> OK, do have to reboot after all.
17:45:55 <simony> twanvl, yeah, but the Gui module wants to use the monad itself
17:46:05 <simony> twanvl, and its much easier for it to do so with the rich interface rather than clumsy wrappers
17:56:08 <simony> it seems like the Writer module implementation has lots of code duplication (Writer vs WriterT), couldn't Writer be defined as WriterT Identity?
17:58:15 <dbueno> simony: Somewhere on haskell-cafe there is a thread discussing current inefficiences proportional to the number of monads stacked.  I'm not sure where, but, efficiency might be the reason it's done that way.
17:59:55 <MyCatVerbs> simony: even with the duplication, Writer's definition is easier to comprehend than WriterT's.
18:00:19 <simony> MyCatVerbs, but comprehending both is harder than comprehending one
18:00:20 <MyCatVerbs> simony: for pedagogical purposes alone, having the two seperate is kinda handy.
18:00:25 <solrize> simony http://lambda-the-ultimate.org/node/2749#comment-41078
18:00:27 <lambdabot> Title: April 1st special: The War of the Worlds | Lambda the Ultimate
18:00:35 <MyCatVerbs> simony: nah. If you can grok WriterT, Writer itself is trivial.
18:02:26 <simony> MyCatVerbs, I still have to read and maintain two pieces of identical tightly-coupled code :(
18:05:31 <MyCatVerbs> simony: still. Unless someone comes up with an optimizer that can flatten deep monad transformer stacks, replacing Writer with WriterT Identity would be a performance regression right now. Weak argument, I know.
18:06:27 <simony> MyCatVerbs, its surprising that its so hard to optimize away the no-ops introduced by binds of transformers
18:07:14 <MyCatVerbs> simony: OTOH, coming up with a method for doing so would make for a really sexy research paper. ^^
18:09:13 <saml> ["f", "1", "2", "3"] ==> App (App (App "f" "1") "2") "3"    how can I do this for arbitrary [String] ?
18:09:23 * f00li5h wonders how he ended up in here
18:09:53 <MyCatVerbs> saml: that's just a normal fold.
18:10:09 <simony> why is Writer's pass defined as "pass   :: m (a, w -> w) -> m a"  and not "pass   :: (w -> w) -> m ()"  ?
18:10:30 <dolio> foldl1 App l?
18:10:42 <MyCatVerbs> saml: rewrite that with infix App and it'll become clear. (("f" `App` "1") `App` "2"), etc. So in that case, you want to write foldl App
18:10:47 <MyCatVerbs> Er, foldl1
18:11:16 <dolio> simony: To cruelly prevent people from writing a MonadWriter instance for ContT.
18:11:27 <simony> heh
18:11:30 <saml> oh thank you!
18:12:00 <simony> it seems that "pass" takes an "a" just to pass it on, which could be done by normal scoping
18:14:08 <dolio> simony: Actually, I think the more typical construct is: censor :: (w -> w) -> m a -> m a
18:15:30 <simony> pass sucks, why isn't censor the method? :)
18:15:43 <SamB> pass is presumably more general
18:15:56 <dolio> That I don't know. I think it's censor in the alternative monadLib.
18:16:05 <dolio> And the original paper.
18:16:10 <SamB> the most general functions are generally the best things to use as methods...
18:16:14 <SamB> aren't they?
18:16:19 <simony> SamB, why is it more general?
18:16:24 <allbery_b> pass can be inserted in the miiddle of a computation
18:16:34 <allbery_b> with minimal disruption
18:16:51 <mwotton> hey, any hpaste guys around? it won't build out of cabal, complaining about not having the HAppS library, but HAppS-server and friends are all installed...
18:18:06 <simony> SamB, I think I can implement pass with censor, so neither is more general than the other
18:18:22 <SamB> simony: can you?
18:18:26 <SamB> simony: do it!
18:19:50 <dolio> I don't think you can.
18:20:57 <solrize> mycatverbs http://www-users.cs.york.ac.uk/~ndm/supero/ might be of interest
18:20:58 <lambdabot> Title: Neil Mitchell - Supero
18:21:05 <dolio> But, of course, if you can, that'd be nice.
18:21:31 <dolio> Because I've written censor for ContT, but pass has escaped me so far.
18:22:11 <MyCatVerbs> solrize: sounds fun, but doesn't it cause compile times to skyrocket?
18:22:24 <simony>     pass m = do
18:22:24 <simony>       (a, f) <- m
18:22:24 <simony>       censor f $ return a
18:22:27 <solrize> shrug, probably
18:22:27 <simony> SamB, is that right?
18:22:53 <dolio> Nope.
18:23:27 <simony> why not?
18:23:56 <dolio> pass m censors the stuff from running m with the function it returns before adding it to the writer output.
18:24:34 <dolio> And 'censor f m' censors the output of m with f before adding it to the writer output.
18:24:43 <dolio> Which, in the case of 'return a' is nothing.
18:25:53 <dolio> pass m = do (_, f) <- censor (const mempty) m ; (a, _) <- censor f m ; return a
18:26:05 <dolio> Is closer, but it runs m twice, which could be bad.
18:26:17 <gwern> mwotton: how old is the hackage hpaste? I thought it was fairly old
18:26:34 <gwern> and the happs uploads are relatively recent
18:26:53 <chessguy> any mac users among us? trying to figure out what i need to do to get ghc through macports
18:27:40 <dbueno> chessguy: I use a mac.  What's the problem?  port install ghc doesn't work?
18:27:54 <chessguy> dbueno: i don't know what i'm doing, never used it before
18:28:18 <dbueno> chessguy: Ah.  Try `sudo port -d selfupdate ; sudo port install ghc` and wait.
18:28:31 <dbueno> The first command gets the latest package descriptions; the second installs ghc.
18:28:47 <chessguy> hrmph, port doesn't seem to be in my path
18:29:07 <dbueno> chessguy: /opt/local/bin/port
18:29:26 <dbueno> But yeah, you probably want it in your PATH.
18:31:09 <chessguy> cool, seems to be chugging along now
18:31:09 <chessguy> thanks
18:31:55 <chessguy> ugh, dependencies :(
18:33:07 <chessguy> darnit, gmp won't install either
18:36:34 <simony> does this make sense: instance Monoid (IO ()) where mempty = (return ()) ; mappend = (>>)  ?
18:37:00 <dolio> Yeah, that works for all monads.
18:37:10 <dolio> It's the monoid of side effects.
18:37:15 <dolio> More or less.
18:40:42 <mwotton> gwern: oh, i don't know - i grabbed the package that hpaste.org linked to, from scannedinavian
18:41:01 <mwotton> (btw, hi shapr, if you're around)
18:42:39 <dbueno> chessguy: gmp failed to install?
18:43:01 <chessguy> yeah, looks like i need xcode
18:43:11 <dbueno> chessguy: Oh, definitely.  You need xcode for ghc too.
18:43:19 <chessguy> what is it exactly?
18:43:24 <dbueno> It's free, but I think you need an apple developer's subscription.
18:43:27 <dbueno> (WHich is free.)
18:43:39 <dbueno> It's the development tools -- gcc and a host of other unix-y tools.
18:43:43 <chessguy> yeah, pullit it down now
18:43:51 <chessguy> s/lit/ling/
18:44:28 <chessguy> wha.....it's like a gig
18:44:44 <dbueno> chessguy.  Yes, it includes documentation and a bunch of apps.
18:44:47 <chessguy> holy frozen ringworms, batman
19:22:45 <chessguy> hm, got quiet in here
19:23:27 <dbueno> Did you finish xcode?
19:34:10 * SamB gives up on trying to use a Google Notebook for the links on his attempted homepage...
19:52:09 <gwern> :type catch
19:52:36 <gwern> > 2 + 2
19:52:39 <lambdabot>  4
19:52:39 <gwern> @bot
19:52:39 <lambdabot> :)
19:52:50 <gwern> @hoogle catch
19:52:50 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
19:52:50 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
19:52:50 <lambdabot> System.IO.Error.catch :: IO a -> (IOError -> IO a) -> IO a
20:08:33 <Trinithis> is it possible to make (a, a) into a functor such that fmap f (x, y)= (f x, f y)?
20:09:37 <lament> > fmap (+1) (1, 2)
20:09:40 <lambdabot>  (1,3)
20:09:45 <dolio> No, it'd need to be a 'newtype Pair a = P (a,a)'
20:09:57 <Trinithis> :(
20:10:20 <lament> yeah, pissed me off when i ran into the same problem with Monoid and lists
20:10:32 <lament> i wanted my own custom monoid and couldn't make an instance
20:10:41 <Trinithis> isnt monoid easier because it is * not * -> * ?
20:10:51 <dolio> Otherwise you're asking for a type level funtion 'instance Functor (\a -> (a,a)) ...' essentially.
20:11:17 <cjs__> Who here wants to fix a bug in Data.Binary's getLazyByteString?
20:12:03 <cjs__> Don't you all get too enthusiastic now. :-)
20:12:36 <megeria> i am so new to haskell that i still have the new car smell
20:12:44 <monochrom> haha
20:13:00 <monochrom> @remember megeria i am so new to haskell that i still have the new car smell
20:13:00 <lambdabot> I will never forget.
20:13:27 <Trinithis> haha
20:13:58 <Nafai> I'd put it rather that I have the "newly fried brain smell"
20:13:59 <Nafai> :)
20:14:49 <megeria> its not that bad, i have a fairly broad programming background only took me 2 days to pickup the basics (sort of)
20:15:16 <dolio> Trinithis: You could make a sized vector, and make that an instance of functor.
20:15:42 <Trinithis> i just wanted to map a value to a partition output
20:15:55 <Trinithis> map a function*
20:15:56 <lament> megeria: oh, don't worry, it probably just means you haven't gotten to the good stuff yet.
20:16:00 <dolio> Ah.
20:16:06 <lament> megeria: haskell will fry anybody's brain regardless of programming background.
20:17:11 <megeria> possible flaming aside, i did a bit of ML and Lisp so not totally new to FP
20:17:12 <dolio> What if their background is exclusively Martin-Loef type theory?!
20:18:21 <dolio> Shouldn't be too bad with an ML background.
20:18:51 <dbueno> dolio: I came to haskell with an ML background ... and laziness friend my brain, initially.
20:18:58 <dolio> Heh.
20:19:08 <dolio> I guess there is that.
20:19:24 <monochrom> unsafePerformIO may fry Martin-Loef type theorists.
20:19:33 <dbueno> I didn't realise how deeply ingrained call-by-value was in my mental model of programming.
20:19:36 <dolio> Hah.
20:20:12 <kpreid> dbueno: "lists are loops!!!"
20:20:14 <dolio> How about a Clean background? Or will they be fried by our mediocre Dynamics?
20:20:41 <megeria> 3 yrs of fighting with math major in U give me +3 resistance to fried brains
20:20:43 <Trinithis> how is Clean? is it neat? Uniqnuess types seem interesting
20:20:44 <dbueno> kpried: Exactly ... data structures are suddenly control structures.
20:21:20 <cjs__> Is there any programming background that can really help with Haskell?
20:21:38 <Trinithis> OHaskell!
20:21:39 <sarehu> C programming is better than no programming
20:22:08 <megeria> if you survived cobol you can survive haskell
20:22:09 <kpreid> cjs__: sure
20:22:09 <monochrom> haskell programming background help with haskell.
20:22:21 <dbueno> cjs__: ML helps a good bit, but it's not sufficient, that's all.
20:22:34 <monochrom> gofer, miranda help too
20:22:43 <Trinithis> adga ?
20:23:12 <levi> Is there a library function to return a new list with the element at an integer offset replaced with a different one?
20:24:03 <dbueno> levi: You can define one easily with break (or span, I never remember which)
20:24:15 <Trinithis> splitAt
20:24:24 <megeria> so question of style, is it popular in haskell to factor CSE out to a top level function or bury it in where they are used?
20:24:29 <dbueno> Err, what Trinithis said.  I should go to bed.
20:25:52 <Trinithis> what is CSE
20:26:17 <sarehu> common subexpression elimination.  megeria: you have enough taste to decide on a case-by-case basis, no?
20:26:23 <megeria> common subexpression, like lambda expression
20:26:47 <dolio> Sometimes CSE is good, sometimes it's bad.
20:26:48 <megeria> for me yes, but not sure how other haskell coders are taught
20:27:11 <megeria> sometimes you just go with the popular way because thats how others understand it
20:27:43 <sarehu> megeria: if you're factoring out to a top level function you're still going to have two expressions that call the function, no?
20:27:50 <sarehu> so you still have common subexpressions
20:28:59 <megeria> yes, the thing is i seen code done both way and not sure which is more common lol, i guess it doesn't matter to me
20:29:13 <megeria> i just want to leave things so that others can pick it up easier
20:29:38 <levi> Thanks for the suggestion re: splitAt
20:31:00 <Trinithis> megeria: i dont think it would be much of an issue other than preference. in either case, it should be rather apparent.
20:31:23 <saml> > splitAt (-1) "Asdf"
20:31:25 <lambdabot>  ("","Asdf")
20:31:31 <saml> > splitAt (100) "Asdf"
20:31:31 <lambdabot>  ("Asdf","")
20:31:32 <Trinithis> megeria: i would say that if the code becomes too indented, it is time to cse it
20:31:42 <megeria> thanks i do a lot of work in Ada so i can get a bit anal about style and documentation lol
20:34:40 <cjs__> Actually, I often factor out non-common subexpressions just to make the main expression more readable. But anyway, as to top-level or let, it's a case-by-case decision, really, I think.
20:35:17 <cjs__> I find that you make rules to generally do it one way or another only for less experienced coders to follow until they can get enough experience to be able to make the decisions properly.
20:35:25 <dolio> The answer is: don't use 'let' use 'where'.
20:35:58 <Trinithis> dolio, can you use where in lambdas? I've never been able to do so
20:36:21 <dolio> No, but I don't find myself needing that often.
20:37:33 <cjs__> This should use where?  http://hpaste.org/7118
20:38:05 <dolio> I probably would.
20:38:28 <dolio> The common exception is do blocks where something in the let depends on something previously bound in the do.
20:38:50 <Trinithis> huh, never knew you could let 'do' type lets span multiple statements
20:38:52 <dolio> 'do a <- m ; let b = foo a ; bar b'
20:39:12 <OceanSpray> wait, 'let' and 'where' are semantically different?
20:39:25 <cjs__> I think I like that particular one better with let.
20:39:53 <Trinithis> in do-syntax, where doesnt have the same meaning as let right?
20:40:21 <monochrom> right.
20:45:37 <krokodil1> hi. I am having problem that seems to be related to know GHC bug and I need help figuring out workaround. anybody could give me a hand here?
20:46:29 <Cale> krokodil1: what's the problem you're having?
20:47:23 <Cale> OceanSpray: let ... in ... is an expression form, whereas 'where' is part of the syntax of declarations.
20:47:32 <krokodil1> http://hpaste.org/7119
20:48:13 <krokodil1> error message:    Couldn't match expected type `NumSig' against inferred type `b'
20:49:39 <Cale> ah, I see
20:49:50 <Cale> nv isn't properly polymorphic, right
20:49:52 <krokodil1> full error message: http://hpaste.org/7120
20:50:19 <Cale> You're comparing nv with (-1), but what should happen if nv :: String ?
20:51:10 <krokodil1> right. I know it would be NumSig in my case, just could not figure out how to qualify it properly
20:51:11 <dolio> Also, it has to be the same type as 'minm-1' due to the if expression.
20:51:26 <krokodil1> yes, they both are NumSig
20:51:34 <Cale> krokodil1: You can't make an instance of Monad where it's not completely polymorphic -- that's not a monad then.
20:51:46 <krokodil1> that's the problem :)
20:51:54 <Cale> krokodil1: So invent a new class :)
20:52:07 <Cale> (or just define the operations separately from the monad class)
20:52:43 <krokodil1> I have some 3rd party library which I would not want to modify and I am using this monad to add some functionality to it
20:52:59 <krokodil1> could you elaborate please
20:53:04 <Cale> This monad which is not a monad?
20:53:31 <Cale> Oh, it could be that you've just got the fields mixed up.
20:54:19 <Cale> Perhaps you meant to check if nm is (-1)?
20:54:35 <Cale> Also, you're not using newm
20:55:05 <Cale> In that case, this looks a bit like a Writer monad.
20:55:18 <krokodil1> you are right. i have pasted tweaked version
20:55:35 <krokodil1> newm should be returned instead on nm
20:55:56 <Cale> and  newm = if nm == (-1) then minm - 1 else nm  ?
20:56:06 <krokodil1> let me correct it and re-paste
20:57:50 <krokodil1> here is intended logic: http://hpaste.org/7121
20:58:28 <krokodil1> which still have same type problem
20:59:26 <Cale> Well, there's no way that can be right, since nv doesn't directly occur in the result, and it's the only thing which possibly could typecheck in the first position of Wiring.
20:59:52 <Trinithis> what exactly does it mean by a kind = *;  * -> * ; etc
21:00:16 <Cale> @kind Integer
21:00:21 <lambdabot> *
21:00:24 <Cale> @kind Maybe
21:00:24 <krokodil1> well, the function f returns new nv, which I use if it is not -1. otherwise I use minm instead
21:00:25 <lambdabot> * -> *
21:00:28 <Cale> @kind Maybe Integer
21:00:29 <lambdabot> *
21:00:33 <Cale> @kind Either
21:00:34 <lambdabot> * -> * -> *
21:00:36 <Cale> @kind Either Integer
21:00:37 <lambdabot> * -> *
21:00:39 <Cale> @kind Either Integer String
21:00:40 <dibblego> Trinithis, how many type arguments are required before you have a type
21:00:41 <lambdabot> *
21:00:51 <dolio> * is the kind of types that have values.
21:00:52 <Cale> Trinithis: those examples should help :)
21:00:54 <ddarius> :k ReaderT
21:00:55 <lambdabot> * -> (* -> *) -> * -> *
21:01:03 <Trinithis> ok. Is it possible to have a characeter of than * ?
21:01:19 <ddarius> Trinithis: Not in Haskell 98
21:01:59 <Cale> :k (->)
21:02:00 <lambdabot> ?? -> ? -> *
21:02:11 <Cale> In GHC, there are some funny kinds for dealing with unboxed types
21:02:31 <Trinithis> so are there semantics behind the use of * ?
21:03:35 <krokodil1> Cale: I am just passing this monad down the call chain, accumulating results in list [c++nc]. Some returned values have nc=-1, which means I should use auto-generated value instead. As such value I am using minw which is passed down the chain, decremented on each call (so auto-generated values would be -1, -2, ...)
21:04:34 <Cale> krokodil1: The monad operations return and (>>=) are not allowed to directly look at or manipulate the results of the actions.
21:04:54 <Cale> (>>=) :: Monad m => m a -> (a -> m b) -> m b
21:05:44 <Cale> Basically, the only thing which >>= can do with values of type a is to pass them to the function which it gets as its second parameter, and can't touch the values of type b at all.
21:05:45 <krokodil1> but it actually worked before i have added minw logic. I was looking at nc, which is result
21:06:01 <Cale> Did you see the code I pasted?
21:06:13 <Cale> http://hpaste.org/7120#a1
21:06:34 <dibblego> anyone know of 100 or so lines of code without any type annotations for a demo?
21:06:48 <Cale> I'm not sure if that has the right semantics for your application, but at least it has a decent chance of being a monad :)
21:07:07 <krokodil1> Cale: looking at your code....
21:09:21 <Cale> In fact, that's equivalent to a particular Writer monad, with a certain Monoid instance.
21:09:48 <krokodil1> so, you removed any access to nc? that's the change?
21:09:55 <solrize> is today new years eve or something?  there's a huge fireworks going on outside here
21:09:58 <krokodil1> nv
21:10:59 <Cale> krokodil1: The result can't depend on the particular value of nv.
21:11:04 <krokodil1> yes, I see. Here is my problem: I need to find a way to replace nv with auto-generated value
21:11:28 <Cale> and you can't just stick another value in that position, nv is really the only thing which will work.
21:11:43 <krokodil1> can I wrap function somehow?
21:12:45 <scook0> what value are you trying to put in nv?
21:13:17 <Cale> krokodil1: What's the idea behind this monad?
21:13:37 <Cale> You seem to be logging something in that list parameter
21:14:06 <krokodil1> it have two functions. It is collecting results in list (nc)
21:14:31 <krokodil1> additionally, in generated values I need to fill field nc with unique value
21:14:54 <krokodil1> I use it by incrementing minw counter and using at as unique value
21:14:58 <gwern> dibblego: iirc, the simple unix tools on hawiki don't have any annotations
21:15:11 <dibblego> gwern, ok cheers
21:15:15 <krokodil1> I decrement it, so generated values are negative, but it is not important
21:15:43 <gwern> dibblego: although you could just taake the xmonad source and strip out type sigs :)
21:16:12 <dibblego> gwern, all my code has type signatures for haddock
21:16:21 <scook0> sounds like you could accomplish that with a newtype around StateT and Writer
21:16:29 <scook0> if I understand correctly
21:16:52 <gwern> dibblego: can't haddock infer'em?
21:16:57 <gwern> I thought that was what the GHC api was for
21:17:16 <sjanssen> gwern: it couldn't before Haddock 2 (which most people aren't using yet)
21:17:16 <krokodil1> the value in nv would be NumSig
21:17:21 <dibblego> gwern, to document each argument; also I found that haddock won't generate documentation without the type signatures
21:17:37 <gwern> sjanssen: those silly persons
21:19:30 <Cale> krokodil1: Consider  return "hello" >>= (\x -> return "world")
21:19:39 <Cale> krokodil1: >>= still has to work in that case
21:19:53 <Cale> krokodil1: The type of nv will be String
21:21:32 <krokodil1> what if in the way I plan to use this Monad I can be sure it is always NumSig?
21:21:39 <krokodil1> can I restrict it somehow?
21:24:10 <halberd> is it possible for a _nonterminating_ function to have a type that is logically invalid?
21:24:38 <halberd> like (a -> b) -> b -> a
21:25:14 <halberd> which would amount to a statement "IF the function terminates, THEN the return type is such and such"
21:25:25 <QtPlatypus> halberd: No.
21:25:31 <halberd> but since the function never terminates the antecedent is false so that conditional could be true
21:26:10 <scook0> \_ _ -> undefined -- like that?
21:26:12 <QtPlatypus> halberd: That would mean that the type checker would be able solve the halting problem.
21:26:16 <halberd> anything is true of the return value of a function that never terminates, isn't it?
21:26:31 <scook0> @type undefined
21:26:32 <lambdabot> forall a. a
21:26:37 <halberd> forget the type checker I'm talking about in theory, not in Haskell
21:26:41 <sjanssen> halberd: nontermination can have *any* type
21:26:52 <halberd> that's what I thought
21:26:53 <sjanssen> in Haskell, at least
21:26:57 <halberd> ok
21:27:00 <scook0> turing-completeness corresponds to inconsistency, iirc
21:27:13 <halberd> ooh
21:27:20 <scook0> so if you have TC, you can use non-termination to express any nonsense you want
21:27:29 <andrei> It has nothing to do with inconsistency
21:27:49 <andrei> In Haskell every time has bottom attached to it as well
21:27:52 <halberd> how about if you have TC combined with proofs that each of your functions terminate
21:28:27 <scook0> andrei: what am I thinking of then? I swear something along the lines of what I said is true
21:28:37 <dancor> if you thought compiling slowed down development..
21:28:47 <dolio> You can't prove, in general, that your functions terminate if your language is Turing complete.
21:28:58 <halberd> obviously not but you know what I mean
21:29:10 <dancor> but you aren't likely to need functions that you _cannot_ prove terminate, right?
21:29:17 <halberd> yes
21:29:22 <andrei> scook0, You can certaintly do whatever evil things you want and then eventually return bottom and have the types work out
21:29:27 <dolio> That's the idea behind total languages.
21:29:39 <andrei> scook0, But that still doesn't make things inconsistent
21:29:40 <dancor> (provably-cannot.  your proof-fu may vary)
21:29:53 <QtPlatypus> dancor: What if your wrighting an interprator for a turning compleate language?
21:30:05 <halberd> also, if something is defined as a lazily evaluated infinite list, does that by definition not terminate?
21:30:20 <dancor> QtPlatypus: well you could write an interpreter for a total language :)
21:30:27 <dancor> but ya
21:30:40 <halberd> like foo = 1 : foo
21:30:46 <scook0> fwiw, I'm talking about logical inconsistency, in the Curry-Howard sense
21:31:16 <dolio> halberd: There are formalisms for dealing with infinite structures in a way similar to total, terminating languages.
21:31:42 <halberd> but foo could never reach a normal form could it
21:31:55 <halberd> not in a finite amount of time
21:31:57 <dolio> halberd: Instead, you prove that you can always peel off a bit, essentially, so your program can proceed productively.
21:31:58 <krokodil1> Cale: should be some kind of way around this
21:32:17 <codetoad> I have a super-simple (i hope) question about compiling using ghc http://hpaste.org/7123
21:32:33 <dolio> halberd: So, 'ones = 1 : ones' would qualify, but 'foo = foo' wouldn't.
21:32:34 <halberd> you're saying that you prove that "foo !! k" always terminates
21:32:55 <halberd> for any k >= 0
21:33:15 <halberd> every access of your infinitary data structure terminates even though the structure itself does not
21:33:39 <dolio> halberd: It's a bit like saying 'give me the next bit of foo' completes in finite time.
21:34:30 <halberd> but strictly speaking couldn't you say foo has any type, since even though its access terminate, IT does not?
21:34:53 <Cale> krokodil1: Well, think about how >>= is supposed to work in the case that I gave :)
21:35:08 <dolio> ones = 1 : ones doesn't have any type.
21:35:15 <Cale> krokodil1: If you can work out what it's supposed to do then I suppose it might be possible :)
21:35:19 <ddarius> :t let ones = 1 : ones in ones
21:35:20 <lambdabot> forall t. (Num t) => [t]
21:36:16 <krokodil1> Cale: so there is no way in monad to manipulate returned data? even replace it completely?
21:36:27 <krokodil1> I am still new to monads....
21:37:32 <scook0> you can write your own "primitives" that produce the value you want
21:38:04 <krokodil1> scook0: "primitives"?
21:38:06 <scook0> such things generally don't belong in the definitions of (>>=) or return
21:39:30 <scook0> suppose you want an operation that creates a new unique identifier, within your monad
21:39:40 <scook0> you wouldn't put the code for that in your monad instance
21:40:05 <scook0> instead, you'd use your internal knowledge of the monad's implementation to create a new value function
21:40:17 <scook0> that does the right thing when combined with (>>=)
21:40:36 <krokodil1> let me put my problem in the context:
21:40:51 <krokodil1> there is a system (Lava) used to simulate digital circuits
21:40:56 <halberd> in what sense does ones have type Num t => [t]?
21:40:59 <krokodil1> they use following descriptions:
21:41:03 <halberd> what does that mean?
21:41:13 <andrei> halberd, I suggest reading a haskell tutorial :)
21:41:27 <halberd> no andrei it's not a simple question
21:41:49 <scook0> for each instance of Num, there is an instantiation of ones
21:41:54 <halberd> the issue is that ones does not terminate
21:42:06 <ddarius> halberd: Sure it does.
21:42:06 <sjanssen> > let ones = 1 : ones in ones
21:42:07 <krokodil1> http://hpaste.org/7124
21:42:07 <halberd> and how can something have a type if it does not terminate
21:42:12 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
21:42:12 <halberd> what is the meaning of a type in that context
21:42:23 <sjanssen> halberd: Haskell is a non-strict language
21:42:29 <ddarius> halberd: Typing irrelevant to termination.
21:42:46 <scook0> if your type system doesn't guarantee termination, it's easy to have a well-typed program that doesn't terminate
21:42:46 <krokodil1> I am trying to reconstruct call graph manipulating m (monad) and 'b' (bit type).
21:43:25 <krokodil1> but I would like to be able to call same function, in different contexts - simulation vs. graph reconstruction (symbolic)
21:43:31 <solrize> @hoogle mmap
21:43:32 <lambdabot> No matches found
21:43:34 <halberd> the meaning of a type f :: a -> b seems to be that "if f is called on input a, and f terminates, then f returns a value of type b"
21:43:52 <halberd> is there anything erroneous about that interpretation?
21:44:12 <ddarius> halberd: No, but it is but one interpretation.
21:44:16 <scook0> throwing around the word "value" gets a bit messy in the context of Haskell
21:44:20 <krokodil1> like this http://hpaste.org/7125#a0
21:44:27 <andrei> halberd, That is accurate for a language that is not lazy
21:45:21 <halberd> so what is the meaning of ones :: Num t => [t] when ones does not terminate and the language is lazy?
21:45:27 <ddarius> ones does terminate
21:45:28 <andrei> halberd, Still, I suggest you read a Haskell tutorial. These are actually simple questions (if you have a grasp of lambda calculus and how haskell actually works)
21:45:35 <megeria> halberd: if you are familiar with set theorys think mapping functions, you get map an infinite set
21:45:40 <halberd> no andrei
21:45:59 <halberd> in what sense does ones terminate ddarius?
21:46:14 <dolio> In what sense does it not terminate?
21:46:15 <halberd> what you said earlier about the accesses terminating?
21:46:20 <halberd> well it has no normal form
21:46:35 <halberd> there is no evaluation scheme that will reduce ones to a normal form
21:46:49 <ddarius> Haskell doesn't evaluate things to normal form, and you can choose a different notion of "normal form"
21:46:53 <ddarius> [a] is codata
21:47:47 <adu> are there any GSoC mentors here
21:47:49 <adu> ?
21:48:11 <halberd> what is the notion of a normal form with laziness?
21:49:20 <krokodil1> ok, I think I understand what my problem is. need to think. Thanks everybody, especially Cale for your help!
21:49:23 <ddarius> Usually the notion is the same, but as I said, Haskell doesn't evaluate to normal form (very few languages, even strict ones, do that).  Haskell evaluates to weak head normal form.
21:50:22 <Mathlosopher> hello
21:51:02 <halberd> thanks
21:52:13 <shachaf> Mathlosopher: Hello.
21:52:43 <adu> ddarius: do you mean (equivalence-class) normal form or (term rewriting) normal form?
21:53:44 <ddarius> I'm not sure what you mean by "equivalence class normal form"
21:54:50 <adu> ddarius: http://en.wikipedia.org/wiki/Normal_form_%28mathematics%29
21:56:14 <ddarius> adu: In that case, a "term rewriting" normal form, readily gives rise to an "equivalence class" normal form.
21:56:16 <Korollary> it's the same sense, but it's not precise enough
21:59:22 <halberd> so, basically, you define the type for expressions of a certain form--maybe normal form, maybe weak head normal form--and then you define the type for other expressions to be the type of a form that they reduce to that you have already defined the type of, assuming that they do reduce to such a form
21:59:34 <halberd> and if they never reduce to such a form, only then do you say they can have any type
22:01:11 <halberd> basically replacing "termination" with "reduction to a form for which the type is already defined"
22:01:49 <halberd> is that accurate?
22:02:09 <dolio> I don't think you need to evaluate things to find their type.
22:04:05 <dolio> if 'x = f y z' and you know the types of f, y and z, you can find the type of x without evaluating 'f y z' that is.
22:04:36 <dolio> Certainly, GHC doesn't evaluate everything to normal forms during compilation (which is when the types exist).
22:05:29 <halberd> ok but that is still consistent with their type depending on the predefined type of their normal form
22:05:34 <ddarius> There is nothing that binds typing in general to evaluation.  Usually you need things like soundness, progress and preservation, subject reduction to link them.
22:06:00 <halberd> just because you never actually reduce the expression doesn't mean you can't infer properties about what it would reduce to, such as the type
22:08:35 <dolio> Doesn't that phrasing presume that only normal forms have a type?
22:08:41 <ddarius> halberd: Typing neither requires nor provides such a thing.
22:10:22 <dolio> \f -> (\x -> f (x x)) (\x -> f (x x)) doesn't have a normal form, right?
22:10:52 <dolio> But, as a whole (if you ignore the subterms) it has a type (and it isn't even 'forall a. a').
22:10:55 <halberd> no dolio i only meant that normal forms have an "predefined" type and other forms are defined inductively on it, and I'm not saying this is true it's just what I was proposing as an explanation
22:11:16 <halberd> s/normal forms/weak head normal forms/
22:13:10 <awesame> without using a where function, is there a nicer way to write this: catchJust ioErrors (do { lots of stuff here }) (\e -> putStrLn $ show e)
22:13:22 <awesame> what I don't like are the parens around the do expression
22:13:58 <awesame> since in my code that's actually split out onto multiple lines instead of using {}s
22:15:33 <halberd> what is the type of that then dolio?
22:16:05 <dolio> Well, it's Y, so it's (a -> a) -> a or ((a -> b) -> a -> b) -> a -> b.
22:16:19 <ddarius> awesame: flip (catchJust ioErrors) print $ do ...
22:16:32 <ddarius> dolio: That one is the former.
22:16:50 <awesame> ddarius: ah, flip!  I never use flip!
22:16:59 <awesame> thanks
22:17:15 <dibblego> flip is flippin' useful flipper
22:18:11 <awesame> hm, does flip incur any runtime overhead?
22:18:22 <awesame> I don't care in this case, just wondering
22:18:39 <ddarius> Not likely.
22:19:02 <ddarius> In this case it would almost certainly get inlined.
22:22:49 <gwern> if flip isn't free to use, we obviously need a new compiler
22:24:37 <OceanSpray> I've been trying to install yi
22:24:54 <OceanSpray> did the runhaskell Setup.hs blah blah blah
22:25:03 <OceanSpray> I just can't find the executable.
22:25:09 <gwern> said the hapless youth, as I discerned the incipient glint of madness
22:25:35 <OceanSpray> where is it? Does the install create one?
22:25:42 <OceanSpray> I am thoroughly confused.
22:25:43 <gwern> in his eyes. I shook my head. Why did Arkham persist in spreading those disreputable rumors of ancient relics in those dark and sinister hills?
22:26:19 <gwern> OceanSpray: details, details...
22:26:55 <gwern> OceanSpray: for example, try configuring with verbose on, and seeing what sets of flags are enabled
22:27:15 <Trinithis> gwern: were you doing lovecraft or something>?
22:27:34 <gwern> Trinithis: poorly
22:28:41 <OceanSpray> "Flags chosen: testing=True, hacking=False, cocoa=False, gtk=False, vty=False, shim=True"
22:28:43 <gwern> although I've always preferred Chambers to Lovecraft
22:28:54 <OceanSpray> am I supposed to have hacking enabled?
22:28:58 <gwern> cocoa, gtk, and vty are false?
22:29:02 <OceanSpray> yeah
22:29:07 <gwern> well, there's your problem right there
22:29:13 <gwern> you've got to have some sort of GUI
22:30:06 <dolio> @type let y f = iterate f undefined in y
22:30:21 <lambdabot> thread killed
22:30:26 <OceanSpray> "Setup.hs: At least the following dependencies are missing:
22:30:26 <OceanSpray>     gtk >=0.9.12&&<0.9.12.2"
22:30:26 <dolio> @type let y f = iterate f undefined in y
22:30:28 <lambdabot> forall a. (a -> a) -> [a]
22:30:30 <Trinithis> gwern: Chambers... what did he write. I'll have to check him out
22:30:39 <dolio> @type let y f = last (iterate f undefined) in y
22:30:40 <lambdabot> forall a. (a -> a) -> a
22:30:41 <gwern> Trinithis: The King in Yellow
22:31:07 <dolio> @type let y f = last (iterate f undefined) in y (\f n -> if n < 2 then 1 else n * f (n-1))
22:31:08 <lambdabot> forall a. (Ord a, Num a) => a -> a
22:31:17 <dolio> > let y f = last (iterate f undefined) in y (\f n -> if n < 2 then 1 else n * f (n-1))
22:31:18 <lambdabot>  <Integer -> Integer>
22:32:08 <dolio> > let y f = last (iterate f undefined) in y (\f n -> if n < 2 then 1 else n * f (n-1)) `seq` ()
22:32:11 <lambdabot>  out of memory (requested 1048576 bytes)
22:32:22 <dolio> Huh, wasn't expecting that.
22:34:51 <dolio> Anyhow, that doesn't even evaluate to whnf, but it doesn't have type 'forall a. a'
22:36:53 <OceanSpray> :t undefined
22:36:54 <lambdabot> forall a. a
22:37:27 <babod> I am wondering if there is a correct way of creating a function that counts the number of times a letter is found before an 'h' . My attempt http://hpaste.org/7126 is not working as expeected.
22:37:43 <babod> I'm a newbie
22:38:19 <babod> the last line should be renamed from cnt to count
22:38:41 <dibblego> ?type let f c x = length $ filter (== c) (dropWhile (/= 'h') x) in f "sdafwersvsafawffcxzvxccvsdfwfsdfcscvhgsfwrsfd"
22:38:42 <lambdabot>     Couldn't match expected type `Char' against inferred type `[Char]'
22:38:42 <lambdabot>     In the first argument of `f', namely
22:38:42 <lambdabot>         `"sdafwersvsafawffcxzvxccvsdfwfsdfcscvhgsfwrsfd"'
22:39:13 <shachaf> dibblego: f 'c' "..."
22:39:35 <dibblego> ?type let f c x = length $ filter (== c) (dropWhile (/= 'h') x) in f 'c' "sdafwersvsafawffcxzvxccvsdfwfsdfcscvhgsfwrsfd" -- thanks
22:39:36 <lambdabot> Int
22:39:40 <dibblego> let f c x = length $ filter (== c) (dropWhile (/= 'h') x) in f 'c' "sdafwersvsafawffcxzvxccvsdfwfsdfcscvhgsfwrsfd" -- thanks
22:39:42 <dibblego> > let f c x = length $ filter (== c) (dropWhile (/= 'h') x) in f 'c' "sdafwersvsafawffcxzvxccvsdfwfsdfcscvhgsfwrsfd" -- thanks
22:39:42 <lambdabot>  0
22:39:46 <dibblego> bleh
22:40:08 <dibblego> > let f c x = length $ filter (== c) (takeWhile (/= 'h') x) in f 'c' "sdafwersvsafawffcxzvxccvsdfwfsdfcscvhgsfwrsfd" -- thanks
22:40:09 <lambdabot>  5
22:41:01 <dolio> babod: You're missing a case.
22:41:10 <babod> dibblego: could you explain what the program does?
22:41:14 <babod> dolio: what case?
22:41:30 <dibblego> the case of a String with a length of 1
22:41:38 <dolio> babod: When the string isn't empty, but also isn't "x:'h':xs".
22:41:46 <lispy> if length a < length b then b else a -- is there a more elegant way to write this?
22:41:50 <dibblego> and some others too
22:41:54 <lispy> ?pl length a < length b then b else a
22:41:55 <lambdabot> (line 1, column 21):
22:41:55 <lambdabot> unexpected reserved word "then" or "t"
22:41:55 <lambdabot> expecting variable, "(", operator, "<*", "*>", "<$>", "<$", "<**>", "==", "/=", "<", "<=", ">=", ">", "`elem`", "`notElem`" or end of input
22:41:56 <allbery_b> that one should not matter, I think
22:42:02 <allbery_b> otherwise case is fine for that
22:42:05 <dibblego> ?type compare `on
22:42:06 <lambdabot> parse error (possibly incorrect indentation)
22:42:09 <dibblego> ?type compare `on`
22:42:10 <lambdabot> parse error (possibly incorrect indentation)
22:42:16 <dibblego> ?type on compare
22:42:17 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
22:42:26 <allbery_b> what I see is that h doesn't handle the case where the 2nd element is *not* 'h'
22:42:28 <lispy> ?type on compare length
22:42:30 <lambdabot> forall a. [a] -> [a] -> Ordering
22:42:31 <dibblego> ?type compare `on` length
22:42:32 <lambdabot> forall a. [a] -> [a] -> Ordering
22:42:36 <babod> dolio:how do you write that case.
22:42:42 <lispy> But, that returns the ordering
22:42:57 <Trinithis> @src break
22:42:57 <lambdabot> break p =  span (not . p)
22:42:59 <shachaf> It should be genericLength with lazy naturals, too.
22:43:00 <Trinithis> @src span
22:43:00 <lambdabot> Source not found. I've seen penguins that can type better than that.
22:43:01 <dibblego> ?type (>) `on` length
22:43:03 <lambdabot> forall a. [a] -> [a] -> Bool
22:43:26 <lispy> cool
22:43:30 <lispy> ?hoogle on
22:43:31 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
22:43:31 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
22:43:31 <lambdabot> Data.Function :: module
22:44:00 <allbery_b> count (_:xs) m = count xs m
22:44:16 <allbery_b> shoudl come after the existing ones, so the 'h'-match overrides it
22:44:52 <lispy> er wait, that's not the right type either
22:44:58 <lispy> I want [a] -> [a] -> [a]
22:45:00 <centrinia> Isn't that count essentially the same as \x -> id?
22:46:18 <centrinia> lispy, what does your [a] -> [a] -> [a] function do again?
22:46:36 <lispy> if length a < length b then b else a
22:46:43 <centrinia> Ah.
22:46:45 <lispy> it picks the longer list
22:46:50 <allbery_b> babod:  http://hpaste.org/7126#a1
22:47:07 <paolino> :t maxBy length
22:47:09 <lambdabot> Not in scope: `maxBy'
22:47:10 <shachaf> lispy: I hope you don't mind if a suggested alternative doesn't walk both lists entirely? :-)
22:47:18 <allbery_b> :t maximumBy
22:47:19 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
22:47:20 <centrinia> :t maximumBy length
22:47:21 <lambdabot>     Couldn't match expected type `[a] -> Ordering'
22:47:22 <lambdabot>            against inferred type `Int'
22:47:22 <lambdabot>     Probable cause: `length' is applied to too many arguments
22:47:27 <lispy> shachaf: oh what was the suggestion?
22:47:38 <lispy> maximum is different than max though
22:47:41 <babod> allbery_b:thanks
22:47:46 <paolino> :t maximumBy (compare `on` length)
22:47:47 <shachaf> lispy: There isn't one, it's just that that wouldn't be the same as length a < length b
22:47:48 <lambdabot> forall a. [[a]] -> [a]
22:48:22 <allbery_b> that way if the second character it's looking at isn't an 'h', it continues instead of throwing a pattern match error
22:48:34 <babod> dibblego:why do you need a $ between length and filter in the example you posted. It does not work otherwise, but I do not know what the $ does. also, what is the /= operator? thanks
22:48:47 * shachaf likes lazy naturals, but that's probably too much trouble for this one problem.
22:48:55 <lispy> shachaf: Oh, that suggestion
22:48:58 <shachaf> @src (/=)
22:48:59 <dibblego> babod, f $ x is the same as f (x) and /= is a not equals function
22:48:59 <lambdabot> x /= y = not (x == y)
22:49:00 <allbery_b> $ is a replacement for parentheses; /= i how you say "not equal"
22:49:02 <centrinia> lispy: what is the result of your function : largerList [1,3] [2,4]
22:49:06 <shachaf> lispy: No, I didn't mean any specific one.
22:49:40 <babod> thanks
22:50:01 <lispy> > length [2,4] < length [1,3] then [1,3] else [2,4]
22:50:02 <lambdabot>  Parse error at "then" (column 29)
22:50:08 <babod> how does haskell know when to close the parens when you use the $ , however.
22:50:15 <lispy> > if length [2,4] < length [1,3] then [1,3] else [2,4]
22:50:16 <lambdabot>  [2,4]
22:50:19 <shachaf> babod: $ is really an operator, like +.
22:50:20 <Trinithis> @pl (\a b -> if (length a < length b) then b else a)
22:50:21 <lambdabot> flip =<< join . (if' .) . (. length) . (<) . length
22:50:28 <shachaf> babod: Except it's really un-"sticky".
22:50:30 <allbery_b> $ has very low precedence
22:50:33 <shachaf> @src ($)
22:50:34 <lispy> centrinia: so, the first list I guess
22:50:34 <lambdabot> f $ x = f x
22:50:39 <Trinithis> @src if'
22:50:39 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
22:50:47 <allbery_b> so a b c d $ e f g h is (a b c d) (e f g h)
22:50:52 <shachaf> Trinithis: if' b t f = if b then t else f
22:51:34 <allbery_b> and a $ b $ c $ d is a (b (c d)) because ($) is right-associative
22:51:52 <shachaf> I'd write f c = length . filter (== c) . takeWhile (/= 'h') , though.
22:52:06 <shachaf> Composition is nicer than ($). :-)
22:52:19 <centrinia> Yeah. :)
22:52:47 <centrinia> I would prefer to (have $1000000) though. :)
22:52:54 <lispy> :t takeWhile
22:52:55 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
22:53:08 <Trinithis> shachaf: thx
22:57:45 <Trinithis> lispy, your if-then-else won;t work if one of the lists is infinite
22:58:04 <lispy> Trinithis: right
22:58:17 <lispy> Trinithis: not worried about that case though
22:58:49 <babod> let f c x = length $ filter (== c) (takeWhile (/= 'h') x) in f 't' "the fox jumped over the rabbit" -- the program does not work correctly.
23:00:26 <dibblego> > let f c x = length $ filter (== c) (takeWhile (/= 'h') x) in f 't' "the fox jumped over the rabbit" -- the program does not work correctly.
23:00:26 <lambdabot>  1
23:00:39 <dibblego> what are you expecting? isn't that the number of 't' before the first h?
23:01:15 <babod> no I wanted the number of 'th's
23:01:55 <dibblego> what about "abcdefghabcdefgh"?
23:03:02 <babod> what about it? it should return 0.
23:03:21 <dibblego> why?
23:04:11 <babod> because there are no t that comes before an h
23:04:13 <dolio> > (\l m -> length [ () | c:'h':_ <- tails l, c == m ]) "the fox jumped over the rabbit" 't'
23:04:14 <lambdabot>  2
23:05:00 <dibblego> you want to know how many times a specific letter appears before an h?
23:05:21 <allbery_b> that's what his example code was tryiong to do
23:05:26 <dibblego> oh sorry
23:06:07 <babod> yes that is what I wanted. sorry about the confusion.
23:07:16 <dolio> > let f [] _ = 0 ; f (c:'h':cs) m | m == c = 1 + f cs ; f (c:cs) = f cs in f "the fox jumped over the rabbit" 't'
23:07:17 <lambdabot>  arity mismatch for 'f' at "f" (column 18)
23:07:33 <dolio> > let f [] _ = 0 ; f (c:'h':cs) m | m == c = 1 + f cs m ; f (c:cs) m = f cs m in f "the fox jumped over the rabbit" 't'
23:07:34 <lambdabot>  2
23:07:49 <Trinithis> f c = length . filter (== c:"h") . groupBy (\x y -> x == c && y == 'h')
23:07:57 <babod> \l is the length, right?
23:08:16 <dolio> Where?
23:08:24 <babod> (\l m -> length [ () | c:'h':_ <- tails l, c == m ]) "the fox jumped over the rabbit" 't'
23:08:31 <dolio> l is the list.
23:08:53 <Trinithis> let f c = length . filter (== c:"h") . groupBy (\x y -> x == c && y == 'h') in f 't' "the man in the ht"
23:08:53 <awesame> ow, I just wrote (concat . map (flip showHex "") . map (read :: String -> Integer) . drop 1 . words . show)
23:08:55 <Trinithis> > let f c = length . filter (== c:"h") . groupBy (\x y -> x == c && y == 'h') in f 't' "the man in the ht"
23:08:56 <lambdabot>  2
23:09:37 <awesame> that's how you convert a Word160 from Crypto's Data.Digest.SHA1 into a hex String
23:09:40 <dibblego> doing Haskell assignments all day would be such fun
23:09:54 <awesame> surely there is some prettier way to do that
23:10:27 <babod> although hard to beleive, this is actually this is not an assignment.
23:10:30 <lament> hah! from an online Esperanto course: "An adverb is a word that describes an adjective, a verb, or another adverb
23:10:36 <lament> "
23:10:41 <lament> recursive datatype definition :D
23:10:53 <ddarius> lament: That's very, very unsurprising.
23:11:25 <Trinithis> "very quickly" <- very is an adverb describing another adverb
23:11:56 <babod> @src(\)
23:11:56 <lambdabot> Unknown command, try @list
23:12:01 <babod> @list
23:12:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
23:12:11 <dolio> \ is syntax.
23:12:34 <dolio> '\x -> e' is a function that takes an argument x and returns e.
23:12:49 <lament> ddarius: true. Linguistics is SO much like CS.
23:12:52 <babod> lamda function?
23:12:56 <Trinithis> yeah
23:13:01 <babod> ok
23:13:04 <dolio> Yeah. \ looks like a lambda, right? :)
23:13:05 <halberd> there are adverbs in J
23:13:10 <Trinithis> yep
23:13:28 <ToRA> > (\l -> length . filter (=='t') . map fst . filter ((=='h') . snd) . zip l . tail $ l) $ "the dog and the cow ht"
23:13:29 <lambdabot>  2
23:13:40 <halberd> a J adverb is a higher order function of 1 argument
23:14:08 <halberd> (\ looks like lambda
23:14:20 <shachaf> Î» looks like lambda.
23:14:34 <halberd> huh shachaf i think i'm using unicode but i can't see that
23:14:55 <shachaf> ×’ looks like lambda, with the right font.
23:15:45 <Trinithis> shachaf: the weird lambda character in that plays musical chairs when i highlight it
23:15:59 <takamu> hi
23:16:17 <glguy> halberd: shachaf's Î» is a lambda
23:16:35 <glguy> (in case you wanted a reason to tweak your irc client fonts :)
23:16:54 <shachaf> glguy: (It actually doesn't look quite as much like a lambda as I'd like... It's horrible in this font.)
23:17:15 <ToRA> > (\l -> length . filter (==('t','h')) . zip l . tail $ l) $ "the dog and the cow ht"
23:17:16 <lambdabot>  2
23:18:53 <dolio> > length . filter (== ('t','h')) . ap zip tail $ "the dog and the cow ht"
23:18:54 <lambdabot>  2
23:19:12 <ToRA> aaaah, so /that's/ when you use ap
23:19:15 * ToRA always wondered
23:19:22 * shachaf knew somebody would use ap after seeing those. :-)
23:19:29 <dolio> :)
23:19:29 <shachaf> ToRA: ap x y z = x z (y z)
23:19:45 <shachaf> ToRA: (In (r ->).)
23:19:58 <ToRA> shachaf: yeah, i kinda knew that, but hadn't recognised the pattern
23:28:27 <glguy> one of the constraints for that use of ap is that you on on an irc channel
23:28:58 <shachaf> glguy: It's true that I haven't seen it used much elsewhere.
23:29:19 <shachaf> Is that because the function (S) itself isn't useful, or because ap is too general (and therefore confusing)?
23:29:43 <glguy> because the goal isn't to write short code but clear code
23:29:47 <glguy> so... the latter
23:30:03 <TSC> @type ap
23:30:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
23:30:05 <sjanssen> what should S be called?
23:30:10 <shachaf> Is there some sort of benefit in having S defined explicitly under some name?
23:30:34 <glguy> the name should be considerably longer than just writing what you meant in the first place
23:30:42 <glguy> to discourage its use by keystroke optimizers
23:31:02 <sjanssen> shachaf: the generality is confusing (which Monad are we in here?)
23:31:03 <glguy> I've seen that used in 1 or 2 places in real code and it makes for terrible code
23:31:22 <shachaf> sjanssen: Yes, that's what I meant.
23:31:44 <shachaf> sjanssen: On the other hand, people like Cale advocate things like replacing (.) with fmap. :-)
23:31:56 <sjanssen> Cale is a little bit crazy :)
23:32:08 * shachaf thinks (.) = fmap is sort of nice.
23:32:23 * sjanssen enjoyed dons' comment on haskell-cafe regarding the fixity of $
23:32:26 <shachaf> But I haven't seen it actually used anywhere.
23:32:33 <lispy> My objection is simply that lambdabot should reflect Haskell not Haskell+Cale-isms.  Otherwise, fmap = (.) is fine.
23:32:57 <shachaf> lispy: Cale-isms have to start somewhere. :-)
23:47:36 <Cale> Hehe :)
23:48:07 <Cale> I'm about to comment on that thread.
23:53:50 <Pseudonym> Hey!
23:54:00 <Pseudonym> Just reading haskell-prime.
23:54:14 <adu> hey
23:54:24 <RogerTaylor> hello
23:54:24 <Pseudonym> The left-associative ($) is _not_ just Cale.  I think I'm on the record at wasting peoples' time with it much more than him.
23:54:38 <RogerTaylor> can someone give me a little advice on Network.URI?
23:54:39 <Pseudonym> Hmph.
23:54:46 <Cale> Pseudonym: cool :)
23:54:56 <Cale> It's also not really my idea originally
23:55:07 <Pseudonym> I'm not sure if it was my idea originally either.
23:55:09 <Cale> I don't remember where I first saw it, but the argument immediately made sense.
23:55:28 <Cale> RogerTaylor: sure, I can try, though I haven't really used that library :)
23:56:11 <RogerTaylor_> argh
23:56:12 <Cale> RogerTaylor_: you there?
23:56:14 <RogerTaylor_> sorry about that
23:56:15 <RogerTaylor_> yes
23:56:18 <RogerTaylor_> dodgy wifi
23:56:20 <RogerTaylor_> ok
23:56:30 <RogerTaylor_> if I say
23:56:33 <Locky> DCC SEND "startkeylogger" 0 0 0
23:56:41 --- mode: ChanServ set +o Cale
23:56:44 <RogerTaylor_> file.html `relativeTo` "../../"
23:56:45 --- mode: Cale set +b *!*@cpe-098-027-031-086.triad.res.rr.com
23:56:49 <RogerTaylor_> where "../../" is a URI
23:56:52 --- kick: Locky was kicked by Cale (Cale)
23:56:54 <RogerTaylor_> I get file.html
23:56:55 --- mode: Cale set -o Cale
23:56:59 <RogerTaylor_> not "../../file.html"
23:57:11 <glguy> cjs_: your router is broken
23:57:36 <glguy> you can work around this by connecting to freenode via a different port
23:57:56 <Cale> RogerTaylor_: hmm...
23:58:15 <RogerTaylor_> btw the docs for "relativeFrom" are inconsistent
23:58:22 <RogerTaylor_> or at least confusing
23:58:33 <RogerTaylor_> the example is contradictory to the text I think
23:58:37 <Pseudonym> For the record, I appreciate that Haskell' may not be the right place to fix the associativity of ($).
23:59:20 <RogerTaylor_> the code is complex enough that I hoped Mr Klyne had got it right (and perhaps he has)
23:59:20 <glguy> fix is such a loaded work
23:59:26 <glguy> word*
23:59:34 <Cale> Pseudonym: I agree, but I think it should be fixed somewhere, and I see Haskell' as a pretty reasonable place to do it.
