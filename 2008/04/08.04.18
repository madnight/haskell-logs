00:13:06 <solrize_> wagle, if you refer to foo.bar where foo doesn't have a bar attribute, python calls foo.__getattr__('bar') and uses whatever comes back as foo.bar
00:13:43 <solrize_> oh whoops, actually getattr(foo, 'bar')
00:13:49 <solrize_> getattr is not a method, i keep forgetting that
00:14:42 <Tac-Tics> I sent him a link to diveintopython which explains it
00:15:53 <quicksil1er> bah.
00:16:01 <quicksil1er> (bots using notice)--
00:17:02 <solrize_> oh cool
00:49:41 <paczesiowa> is type system expressive enough to enforce single (no more, no less) usage of a function?
00:49:57 <opqdonut> yes
00:50:09 <opqdonut> also, have a look at uniqueness typing
00:50:16 <opqdonut> the way io implements I/O
00:50:28 <paczesiowa> I meant haskell type system
00:50:40 <Lycurgus> what do you think we thought
00:50:42 <Lycurgus> ?
00:50:46 <paczesiowa> clean?
00:51:04 <Lycurgus> this isn't #clean.
00:51:36 <dolio> IO forces linearity by construction, really. Not exactly with types.
00:51:45 <opqdonut> yeah well uniqueness typing is possible in haskell too IIRC
00:51:58 <paczesiowa> opqdonut: any useful links?
00:52:05 <opqdonut> dolio: oh, what was the language that used uniqueness typing then?
00:52:16 <dolio> Clean.
00:54:39 <solrize_> there's a haskell dialect called disciplined disciple, which has a quite fancy effect typing system
00:54:46 <solrize_> it looks interesting
00:57:19 <paczesiowa> if we hide some computation in a monad, and then provide some unMonad function :: OurMonad a -> IO a, which will run that to-be-called-just-once function, we can still run it twice inside IO
00:57:44 <quicksilver> uniqueness typing is not possible in haskell's type system.
00:57:53 <quicksilver> not unless there is a subtle enocding I h'm not seeing.
00:57:56 <opqdonut> quicksilver: not even with ghc exts?
00:59:14 <paczesiowa> I'm asking because there are plenty of libraries with some startup function which must only be called once (qt,gtk,curl) and it would be nice to encode that in type system instead of comment in documentation
01:01:12 <quicksilver> paczesiowa: I think you have to be clear.
01:01:21 <quicksilver> If you mean "IO action to be performed only once"
01:01:25 <quicksilver> then yes, you can definitely encode that.
01:01:36 <quicksilver> quite different from "function to only be called once"
01:01:44 <paczesiowa> quicksilver: yeah, I meant that
01:01:44 <sjanssen> quicksilver: how can you encode that?
01:01:50 <quicksilver> the latter doesn't make much sense really in a non-strict ref transparanet world.
01:01:54 <sjanssen> how do we disallow "onlyOnce >> onlyOnce"?
01:02:21 <sjanssen> perhaps this could be done with generalized monads?
01:02:24 <quicksilver> start :: Gtk () -> IO ()
01:02:35 <quicksilver> then force the "program" to be written in Gtk ().
01:02:44 <sjanssen> quicksilver: main = start x >> start x
01:02:49 * quicksilver nods
01:02:59 <quicksilver> true. That would have to be a runtime error.
01:02:59 <sjanssen> or main = forkIO (start x) >> start x
01:03:14 <quicksilver> or you hide (>>) in IO
01:03:17 <quicksilver> yes, that's the answer.
01:03:21 <quicksilver> you hide (>>) in IO.
01:03:23 <quicksilver> you hide everything in IO.
01:03:27 <quicksilver> except start.
01:03:28 <sjanssen> huh?
01:03:37 <quicksilver> well rename the monads if you like :)
01:03:50 <quicksilver> but you have an "outer" monad, call it Main ()
01:03:55 <quicksilver> and you hide its monadness
01:04:00 <quicksilver> but you force "main" to have that type.
01:04:10 <quicksilver> you don't have (>>) for that type.
01:04:15 <opqdonut> how about (main,main)
01:04:19 <opqdonut> or something like that
01:04:23 <sjanssen> so Main isn't a Monad at all
01:04:30 <quicksilver> all you have is start :: Gtk () -> Main ()
01:04:31 <sjanssen> (just to simplify)
01:04:37 <quicksilver> sjanssen: yes, good point.
01:04:47 <sjanssen> so start :: Gtk () -> Main
01:04:51 <quicksilver> opqdonut: referencing an action twice in a tuple doesn't make it happen twice.
01:04:54 <paczesiowa> we still have to run it somehow
01:05:03 <opqdonut> quicksilver: yeah i guess
01:05:08 <opqdonut> you can "force" sharing
01:05:28 <sjanssen> opqdonut: but paczesiowa is asking about initialization *actions*
01:06:00 <opqdonut> yeah that does make it different
01:06:02 <quicksilver> paczesiowa: yes, you'd need to slightly play with the rules of the RTS/linking.
01:06:02 <quicksilver> but it is expressible in the type system.
01:06:02 <quicksilver> which is what you asked :)
01:06:19 <paczesiowa> you cheat:>
01:06:42 <sjanssen> quicksilver: now how do we compose several "only once" actions?
01:06:44 <quicksilver> no, I don't think so.
01:06:50 <quicksilver> sjanssen: typeclasses, I hope.
01:06:57 <quicksilver> sjanssen: but I haven't quite thought this part through.
01:07:39 <quicksilver> GTK actions run in MonadGTK m => m ()
01:07:43 <sjanssen> what if we change the kind of IO, and have type witnesses that represent each initialized thing?
01:08:01 <quicksilver> I was thinking of using typeclasses to represent capabilties
01:08:08 <quicksilver> MonadGTK m means "GTK has been initialised"
01:08:12 <quicksilver> or "you can do GTK stuff here"
01:08:14 <sjanssen> IO (GtkInit :*: HttpInit :*: ()) a
01:08:26 <quicksilver> I think that also might work.
01:08:31 <opqdonut> mm, nice
01:09:13 <quicksilver> I've often thought it would be nice to have MonadGL m => for a slightly different, but related, reason
01:09:24 <quicksilver> to actually forbid certain actions from doing generalised IO
01:09:37 <quicksilver> so you can declare "This action does 3D graphics, but no other kinds of IO"
01:09:51 <quicksilver> some libraries have invariants like "between this call and this call you can only use this kind of call"
01:10:01 <quicksilver> which you can encode using typeclasses-as-capabilities or something similar.
01:10:10 <quicksilver> the types get a bit syntactically heavy after a while though
01:10:17 <olsner> isn't this somewhat similar to session types?
01:10:27 <quicksilver> yes, I believe it is
01:10:37 <olsner> the whole moving between states and certain things being dis/allowed in certain states
01:10:57 <olsner> find some way to combine session types with arbitrary monads and you have it ;-)
01:34:45 <mauke> Cale: preflex is my bot
01:34:56 <Cale> Does it do anything else?
01:35:01 <mauke> preflex: list
01:35:02 -preflex(n=preflex@d90-128-46-80.cust.tele2.de)- Factoid: [+, -, ., ?, delete, forget, get, store]; Help: [help, list]; Karma: [++, --, karma]; Seen: [seen]; Quote: [quote, remember]; WCalc: [calc, wcalc]; Version: [version]
01:35:12 <solrize_> @pl \Foo x -> Bar x
01:35:16 <lambdabot> const Bar
01:35:30 <Cale> bzzt
01:35:34 <ejt> :)
01:35:37 <solrize_> @pl \(Foo x) -> Bar x
01:35:37 <lambdabot> (line 1, column 7):
01:35:37 <lambdabot> unexpected "x"
01:35:37 <lambdabot> expecting operator or ")"
01:36:18 <sjanssen> mauke: is preflex written in Haskell?  Is the code available?
01:36:48 <mauke> http://mauke.ath.cx/tmp/preflex/
01:36:50 <lambdabot> Title: Index of /tmp/preflex
01:36:54 <mauke> it's a work in progress
01:38:51 <sjanssen> looks like lambdabot with less suck
01:41:25 <Cale> neat
01:47:53 <czakey> cool ;>
01:50:28 <dolio> preflex: factoid
01:50:36 <dolio> preflex: factoid get
01:53:31 <solrize_>    line <- getLine
01:53:31 <solrize_>    let n = read line
01:53:48 <solrize_> should that be the same as   n <- getLine >>= read     ?
01:53:58 <mauke> no, liftM read getLine
01:53:59 <sjanssen> solrize_: no
01:54:08 <mauke> also, readLn
01:54:19 <solrize_> hmm ok thanks
01:54:35 <solrize_> i'm not sure why it doesn't work but liftM sounds right
01:54:44 <mauke> because read doesn't return IO a
01:54:45 <solrize_> readLn even better
01:54:57 <mauke> >>= needs (a -> IO a)
01:55:02 <solrize_> ohh, ic.  thanks.
01:56:25 <quicksilver> mauke: please make preflex not use notice :P
01:56:30 <mauke> why?
01:56:40 <quicksilver> because several IRC clients, including mine, highlight notice
01:56:48 <quicksilver> because they're normally used by networks for important stuff
01:57:01 <mauke> just make it not highlight notices
01:57:02 <quicksilver> like password requests from chanserv and maintenance notices from ops
01:57:16 <quicksilver> but I want to highlight my password requests and op notices!
01:57:17 <quicksilver> that's useful.
01:57:28 <mauke> you can always selectively highlight messages from services
01:57:34 <sjanssen> some clients treat notices as personal messages
01:57:40 <quicksilver> I can indeed. But I don't want to.
01:57:45 <quicksilver> I want you to stop making preflex use notice.
01:57:47 <quicksilver> that would be simpler.
01:57:56 <quicksilver> Let me ask another way: what advantage is there to preflex using notice?
01:58:08 <mauke> no bot chaining
01:58:12 <sjanssen> mauke: there was a period that lambdabot used notices, but this was changed due to user pressure
01:59:16 <mauke> I think this special treatment of notices is broken
01:59:55 * quicksilver shrugs. The effect will be that #haskell will always be highlighted, which will mean that I won't bother to check it when its highlighted.
02:00:05 <quicksilver> which will mean that I won't respond to queries people ask me quickly.
02:00:14 <mauke> just don't highlight notices sent to channels
02:00:30 <mauke> I can't even begin to comprehend how that behavior is useful
02:03:46 <mauke> quicksilver: doesn't irssi use SNOTES for server notices (as opposed to NOTICES)?
02:05:57 * quicksilver shrugs
02:06:00 <quicksilver> I don't really know.
02:06:04 <quicksilver> I'll look into it if I have to.
02:06:17 <quicksilver> I'm in lots of channels with lots of bots.
02:06:21 <quicksilver> Only #emacs uses notice.
02:15:08 <solrize_> i can export newtypes from modules, can't i?
02:15:27 <TSC> Sure, they're like data
02:16:08 <solrize_> hmm thanks.  ghc is complaining but i better go to bed, i just noticed how late it is.  i'll look into it tomorrow.  nite all
02:21:44 <solrize_> hmm no paste announcement
02:21:56 <solrize_> http://hpaste.org/7040    i should be able to import this into another file and use those types, right?
02:21:58 <ejt> is there an equivalent of etags for Haskell ?
02:22:00 <Zao> solrize_: The bot is dead.
02:22:05 <solrize_> zao, oh.
02:23:44 * ejt finds hasktags
02:24:20 <solrize_> bbiab
02:26:45 <TSC> solrize_: You might need to export the constructor too; I can't remember the import/export details
02:27:37 <solrize_> JAuthor is the constructor i thought
02:28:46 <mauke> there are two: type constructor and data constructor
02:32:31 <ivan_> hi, how do i talk to a com-port in haskell?
02:33:29 <Lemmih> ivan_: I'd figure out how to do it from C first.
02:34:09 <ivan_> Lemmih: just to write/read the the com file?
02:35:00 <Zao> Generally, most platforms have some file or device you can open if you just want to communicate.
02:35:14 <Zao> If you need to change parameters like baud rate and whatnot, you need to FFI against some native library.
02:56:53 <paolino> :t ap
02:56:57 <paolino> :t ap
02:57:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
02:57:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
03:02:06 <solrize_> mauke, the data constructor is just:   jauthor (Object jn) = mcheck jn ["name","id"] `seq` JAuthor jn
03:02:19 <mauke> no, the data constructor is JAuthor
03:02:22 <solrize_> mcheck just makes sure those fields are present in the dictionary and throws an error if they're not
03:02:28 <mauke> jauthor is a variable
03:02:33 <solrize_> hmm
03:02:49 <solrize_> there's a type constructor different from JAuthor?  it's just a newtype
03:03:14 <mauke> newtype JAuthorÂ¹ = JAuthorÂ² (M.Map String JsonNode)
03:03:30 <mauke> JAuthorÂ¹ is the type constructor, JAuthorÂ² the data constructor
03:03:40 <solrize_> aha, i see, but, er, how do i export both?
03:03:49 <mauke> JAuthor(..)
03:03:51 <quicksilver> JAuthor(JAuthor)
03:03:55 <quicksilver> or JAuther(..)
03:04:01 <mauke> the (..) means "all data constructors/fields"
03:04:07 <solrize_> oh ok, lemme try that
03:04:08 <solrize_> thanks
03:04:30 <solrize_> aha!  worked!  thanks!  i wouldn't have figured that one out.
03:10:47 <TSC> Is it possible to do a non-blocking read from a Handle (which is really a network socket) ?
03:11:21 <TSC> hGetBufNonBlocking, perhaps
03:11:32 <Lemmih> TSC: Are you sure you want to do that?
03:11:53 <TSC> I want to see if any input is available
03:12:03 <TSC> (and read it if there is any)
03:12:07 <solrize_> ghc has lightweight threads, normally you'd use one and just let it block when waiting
03:12:42 <TSC> And then use MVars/TVars/TChans to communicate the input?
03:12:54 <solrize_> yeah, so far i've only used Chan
03:12:55 <quicksilver> TSC: I normally find it makes for much simpler program to use blocking threads.
03:12:58 <solrize_> which is pretty simple
03:13:15 <TSC> That's what I've done in the past; I thought without threads might be simpler
03:13:27 <solrize_> nah
03:13:41 <sarehu_> well, hGetBufNonBlocking exists, so you can always try and see
03:13:54 <quicksilver> non-blocking IO is nightmarish ;) threads are a simpler model.
03:14:01 <quicksilver> the problem with non-blocking IO is partial reads.
03:14:08 <quicksilver> what if the OS decides to only give you half a line?
03:14:21 <quicksilver> will you manual store the partial read and try again later?
03:14:27 <TSC> Yes, that's a complication
03:14:34 <TSC> Threads it is; thanks all
03:14:35 <quicksilver> obviously this problem is soluble.
03:14:40 <quicksilver> but I find threads simpler :)
03:14:51 <mauke> my quote plugin fails and I don't understand why :(
03:16:43 <mauke> the error indicates that "fromList [\"bos\",\"gumbybrain\"]" couldn't be read
03:17:22 <solrize_> fromList doesn't look like a constructor
03:17:33 <quicksilver> it's a pseudo-constructor
03:17:40 <solrize_> read recognizes it?
03:17:49 <quicksilver> :t |>
03:17:54 <lambdabot> parse error on input `|>'
03:17:56 <quicksilver> :t (|>)
03:17:58 <lambdabot> Not in scope: `|>'
03:17:59 <mauke> > read "fromList [\"bos\",\"gumbybrain\"]" :: Set String
03:18:01 <lambdabot>   Not in scope: type constructor or class `Set'
03:18:10 <mauke> > read "fromList [\"bos\",\"gumbybrain\"]" :: Data.Set.Set String
03:18:10 <lambdabot>   Not in scope: type constructor or class `Data.Set.Set'
03:18:14 <quicksilver> > Set.fromList
03:18:15 <lambdabot>   Not in scope: `Set.fromList'
03:18:18 <quicksilver> > S.fromList
03:18:20 <lambdabot>  <[()] -> Set ()>
03:18:23 <quicksilver> ah
03:18:26 <mauke> > read "fromList [\"bos\",\"gumbybrain\"]" :: S.Set String
03:18:27 <lambdabot>  fromList ["bos","gumbybrain"]
03:18:31 * quicksilver nods
03:18:49 <mauke> this doesn't make any sense
03:20:14 <quicksilver> I agree.
03:20:19 <quicksilver> Are you reading it as the wrong type?
03:20:23 <quicksilver> stupid question, I know, but...
03:20:48 <mauke> AFAICS the type signatures should pin it down
03:21:15 <quicksilver> is there one too many levels of quoting?
03:21:20 <quicksilver> and the error message is confusing you?
03:21:29 <quicksilver> an extra layer of 'show' on the string or something stupid?
03:23:14 <solrize_> so what's the way of writing data constructors with code attached?  e.g.   data Even = Even Integer
03:23:22 <solrize_> where Even 2 works and Even 3 throws an error
03:23:54 <solrize_> i thought that was in the wikibook but i don't see it
03:24:18 <Botje> write mkEven that checks it for you
03:24:21 <mauke> solrize_: impossible
03:24:23 <EvilTerran> or "even"
03:24:25 <EvilTerran> or whatever
03:24:30 <solrize_> oh ok, thanks, ic.
03:24:42 <solrize_> g'nite for real this time i hope.
03:24:46 <solrize_> zzz
03:24:59 <EvilTerran> maybe even make an abstract type, so people can't abuse the constructor by circumventing mkEven
03:26:31 <mauke> :t typeOf
03:26:32 <lambdabot> forall a. (Typeable a) => a -> TypeRep
03:27:15 <EvilTerran> unfortunately, the lack of any kind of view would make that a little clunky to use, but i find a CPS deconstructor (maybe, either, etc) isn't so bad
03:38:03 <dcoutts_> @seen ibid
03:38:03 <lambdabot> ibid is in #haskell. I don't know when ibid last spoke.
03:40:14 <EvilTerran> mornin' duncan
03:40:21 <dcoutts_> hia EvilTerran
03:40:41 * EvilTerran has a collection this afternoon =/
03:41:23 <dcoutts_> EvilTerran: good luck!
03:41:31 <EvilTerran> thankee :)
03:41:45 <wjt> EvilTerran: in what?
03:44:53 <ibid> dcoutts_: hm?
03:44:56 <ibid> oh yeah, planet
03:45:01 <ibid> on it
03:47:17 <dcoutts_> ibid: cool, thanks! :-)
03:48:30 <ibid> as soon as i locate the needles of planet requests in the haystack of my inbox...
03:48:33 <ibid> :)
03:48:49 <ibid> ah, there
03:57:07 <kuribas> quicksilver: Did you have any more problems with haskell-mode?
03:57:23 <quicksilver> kuribas: yes. it doesn't grok case-guards
03:57:30 <quicksilver> kuribas: says 'invalid token ->'
03:58:01 <kuribas> quicksilver: Paste please?
03:59:05 <quicksilver> case (a,b) | foo ->
03:59:31 <Botje> shouldn't there be an "of" ?
04:00:14 <quicksilver> yes
04:00:17 <quicksilver> case x of  (a,b) | foo ->
04:00:20 <quicksilver> sorry ;)
04:00:50 <ibid> done
04:07:08 <mauke> quicksilver: I found the error, and now I don't understand how the other plugins kept working :/
04:07:57 <mauke> Typeable++
04:09:52 <dcoutts_> ibid: thanks!
04:13:49 <AndreWe> I want to convert a file that contains an array of floats, how can read a float from a file?
04:14:30 <mauke> in which format?
04:14:59 <AndreWe> The floats have been serialized directly from memory, let's say by a C program.
04:15:07 <mauke> ouch
04:15:10 <AndreWe> :)
04:15:27 <AndreWe> In which format would you save floats, mauke?
04:15:55 <quicksilver> mauke: ;)
04:16:05 <smtms> AndreWe, deserialize them just like they were serialized
04:16:07 <mauke> AndreWe: ascii
04:16:49 <AndreWe> smtms: I would like to use Haskell to deserialize them.
04:17:26 <mauke> AndreWe: get the file into memory somehow, then cast the pointer and dereference
04:17:28 <AndreWe> What I'm looking for is a function String -> [Float].
04:17:38 <mauke> no, you don't want String
04:17:51 <AndreWe> mauke: How do I cast with Haskell?
04:17:57 <mauke> :t castPtr
04:18:00 <lambdabot> Not in scope: `castPtr'
04:18:20 <mauke> @hoogle castPTr
04:18:21 <lambdabot> Foreign.Ptr.castPtr :: Ptr a -> Ptr b
04:18:21 <lambdabot> Foreign.StablePtr.castPtrToStablePtr :: Ptr () -> StablePtr a
04:18:21 <lambdabot> Foreign.Ptr.castPtrToFunPtr :: Ptr a -> FunPtr b
04:19:26 <AndreWe> mauke: Could you give an example on how to use this?
04:19:30 <mauke> useAsCStringLen data (\(p, n) -> peekArray n (castPtr p))
04:19:36 <mauke> where data is a ByteString
04:20:39 <AndreWe> ok, and I how do I get the ByteString out of the file?
04:20:53 <mauke> readFile filename
04:21:11 <mauke> wait, how big is your file?
04:21:16 <AndreWe> mauke: Thank you very much.
04:21:19 <AndreWe> It's 8MB.
04:21:27 <mauke> ok, that should fit into memory
04:22:02 <AndreWe> I hope so. ;-)
04:23:03 <mauke> make sure the result of the first line has the type IO [CFloat]
04:23:28 <mauke> (castPtr uses the surrounding type context to determine the target type)
04:24:31 <mauke> wait, that's wrong!
04:25:10 <dcoutts_> nibro: ping
04:25:33 <mauke> AndreWe: useAsCStringLen data (\(p, n) -> peekArray (n `div` sizeOf (0 :: CFloat)) (castPtr p))
04:31:36 <kuribas> quicksilver: I'll fix it later.
04:32:22 <quicksilver> kuribas: thanks :)
04:32:38 <quicksilver> kuribas: I also had a problem with char literals but I downloaded a new version from your page and that was fixed.
04:32:41 <nibro> dcoutts_: pong
04:32:44 <quicksilver> kuribas: so I guess you spotted that one yourself.
04:32:56 <kuribas> no?
04:33:09 <dcoutts_> nibro: we should decide about the GSoC project mentoring
04:33:22 <kuribas> quicksilver: I don't know, I didn't change anything about char literals...
04:34:00 <opqdonut> anyone know of llvm bindings for haskell?
04:34:12 <opqdonut> googling mostly turns up stuff related to llvm as a ghc target
04:34:51 <opqdonut> and http://www.serpentine.com/blog/2008/01/03/llvm-bindings-for-haskell/
04:34:53 <lambdabot> Title: teideal glic deisbhÃ©alach » Blog Archive » LLVM bindings for Haskell, http://tinyurl.com/69yjgd
04:35:24 <paolino> is there a way to define a function f x pattern matching on f (g x) ?
04:35:34 <opqdonut> paolino: not really
04:35:46 <opqdonut> g has to be a type constructor G
04:36:02 <opqdonut> you can use ghc rewrite rules to rewrite f.g to something
04:36:31 <paolino> opqdonut then I have to start with f x = case g x of ?
04:36:50 <opqdonut> ??
04:37:38 <paolino> probably I didn't get the question right if that is not clear :-/
04:38:49 <opqdonut> yeah, i'd think so too :)
04:38:52 <opqdonut> what do you want to do?
04:39:08 <xerox> paolino: they are in the workings
04:39:16 <paolino> then is there another way to define a function f  then f x = case g x of  {P1 -> z1 ; P2 -> z2}
04:39:29 <opqdonut> well you can use guards
04:39:49 <paolino> ok
04:39:52 <xerox> paolino: http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
04:39:53 <mauke> paolino: I think that's the most straightforward way
04:39:54 <lambdabot> Title: ViewPatterns - GHC - Trac
04:41:06 <paolino> yeah xerox, I was remembering something
04:41:14 <dcoutts_> hia xerox, how're things?
04:41:41 <xerox> dcoutts_: hello :) quite good, I'm deeply immersed in stuff.
04:42:01 <dcoutts_> xerox: I can believe it, we don't here much from you these days
04:42:44 <xerox> Yeah. I decided that I want to 1) graduate soon and 2) have some good vacation this summer :)
04:43:45 * paolino hopes to meet xerox on the top of a mountain track this summer
04:44:45 <dcoutts_> xerox: perhaps we can hold the next european hackathon in southern europe
04:45:17 <xerox> dcoutts_: that would be nice! Maybe at Moggi's university
04:45:35 <dcoutts_> xerox: if you'll be a local organiser :-)
04:46:07 <dcoutts_> next one in europe will be in about a year as the next one will hopefully be with ICFP in the US
04:46:29 <xerox> That would be in two years time right? I think there was a rule about which side of the atlantic ocean based on year's parity
04:47:38 <mxc> anyone have a strong view on polymorphic variants?
04:47:38 <xerox> Hmm, I see. I'd love to organize the event.
04:48:06 <dcoutts_> xerox: no, in one year
04:48:15 <dcoutts_> xerox: hackathons are every 6 months roughly
04:48:27 <dcoutts_> one follows ICFP and one in the winter/spring
04:48:40 <xerox> Nice.
04:48:52 <dcoutts_> which makes 3 in Europe, 1 in the US, every two years
04:49:45 <xerox> OK we'll think about it then :)
04:59:46 <dcoutts_> xerox: we're forming a hackathon steering committee to help organise future hackathons, basically to find venues and give advice to the local organisers
05:04:01 <dcoutts_> yay, http://blog.well-typed.com/ is now syndicated on planet.haskell.org
05:04:02 <lambdabot> Title: blog.well-typed.com
05:04:08 * dcoutts_ plans to do more blogging in future
05:06:03 <pejo> dcoutts, avoiding to write thesis? :-)
05:06:54 <dcoutts_> pejo: heh, yeah
05:07:05 <dcoutts_> I mean no, of course I'm writing my thesis! :-)
05:10:22 <ivanm> dcoutts_: didn't someone at oxford's comlab just do a paper on procrastination? :p
05:10:28 <ivanm> based it on you, did they? ;-)
05:10:42 * dcoutts_ grins
05:13:05 <Lemmih> nibro: trhsx doesn't support TH?
05:13:54 <pejo> ivanm, I think it works pretty much for any student closing in on their thesis
05:19:48 <nibro> Lemmih: it should, though I believe there were some changes to TH syntax that haven't been reflected in trhsx a while back
05:20:36 <ivanm> pejo: hang on, I haven't even _started_ coding for my honours one! and I've still got till the end of the year!
05:20:47 <ivanm> so it's in no way related to how long you've got till it's due :p
05:21:31 <AndreWe> mauke: Thanks, it works now. :)
05:27:55 <mxc> @hoogle mean
05:27:56 <lambdabot> No matches found
05:28:04 <mxc> @hoogle average
05:28:05 <lambdabot> No matches found
05:28:08 <mxc> hm
05:28:21 <mxc> is hstats the only statistics package?
05:32:19 <mxc> @hoogle fromIntegral
05:32:19 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
05:38:48 <paolino> is possible to use local on the inner monad of ReaderT a (Reader b)
05:38:50 <paolino> ?
05:39:16 <paolino> :t local
05:39:17 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
05:40:23 <Lemmih> paolino: \x y -> lift (local x y)
05:40:55 <quicksilver> that's quite an interesting thing to want to do.
05:41:08 <paolino> Lemmih , y is t m a
05:41:25 <quicksilver> You can also pretend that ReaderT a (Reader b) is MonadReader (a,b)
05:41:27 <quicksilver> if you want to.
05:41:36 <quicksilver> conceivable that might be easier to manage
05:41:37 <chessguy_> @src Monad
05:41:37 <lambdabot> class  Monad m  where
05:41:37 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
05:41:37 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
05:41:37 <lambdabot>     return      :: a -> m a
05:41:37 <lambdabot>     fail        :: String -> m a
05:42:01 <paolino> quicksilver: that breaks encapsulation
05:42:14 <quicksilver> on the contrary, it adds more encapsulation
05:42:25 <quicksilver> MonadReader (a,b) is a more abstract type
05:42:33 <quicksilver> ReaderT a (Reader b) is concrete
05:43:45 <paolino> then I do not understand :d
05:44:13 <quicksilver> ReaderT a (Reader b) x is a concrete type
05:44:19 <quicksilver> it specificies a precise implementation
05:44:27 <quicksilver> MonadReader (a,b) m => m x
05:44:53 <quicksilver> is more abstract, it simply means "any monad m which gives me some way to have an environment of type (a,b)"
05:45:08 <quicksilver> it might just add extra work, in a simple program
05:45:15 <quicksilver> I just mention it out of interest.
05:45:31 <paolino> I'm wrapping a Reader a with ReaderT b , is that the case ?
05:45:53 <paolino> Reader a functions are already written
05:47:09 <paolino> you want me to write a monad ?
05:47:26 * quicksilver shrugs
05:47:30 <quicksilver> you have writen a monad.
05:47:35 <quicksilver> ReaderT b Reader a is a monad :P
05:47:44 <paolino> ok
05:47:53 <quicksilver> you don't have to do what I'm suggesting. It may not make your code simpler.
05:47:58 <sethk> quicksilver, is the T in the name for transformer?
05:48:01 <quicksilver> sethk: yes.
05:48:06 <sethk> quicksilver, thanks
05:48:13 <quicksilver> I was offering it as an insight into what's possible.
05:48:19 <quicksilver> It might make certain code simpler.
05:49:16 <paolino> does it imply to touch the Reader a part of the code ?
05:49:18 <hkBst> is hugs dead?
05:49:52 <sethk> hkBst, not sure, with ghci I have no reason to follow hugs
05:50:03 <dcoutts_> hkBst: it's in maintenance mode
05:50:20 <chessguy> anybody else read byorgey's two blogs about the partial order monad?
05:50:37 <chessguy> err, partial knowledge
05:50:43 <chessguy> and monoid
05:50:45 * chessguy sighs
05:51:34 <sethk> can anyone explain succinctly the idea of monoid vs monad?
05:51:35 <ivanm> sethk: AFAIK, people still use hugs because it's smaller
05:51:41 <hkBst> dcoutts_: it will come out of that when Haskell' arrives? Any eta on that btw?
05:51:43 <ivanm> especially for 1st year CS students or something
05:52:00 <centrinia> A monoid is a semigroup. A monad is a category. :p
05:52:07 <chessguy> @source monoid
05:52:07 <lambdabot> monoid not available
05:52:12 <EvilTerran> sethk, well, for starters, a Monad takes a type parameter and a Monoid doesn't
05:52:12 <chessguy> @source Monoid
05:52:12 <lambdabot> Monoid not available
05:52:24 <dcoutts_> hkBst: no idea, you'd have to ask ross and ndm
05:52:29 <centrinia> !whatis monoid
05:52:33 <sethk> EvilTerran, centrinia, ok, time to break out the category theory book I guess
05:52:36 <EvilTerran> sethk, a Monoid is something with an associative operator and an identity element on that operator
05:52:45 <exe> sethk: did you see The Catsters' videos?
05:52:46 <centrinia> And closed.
05:52:51 <sethk> exe, no
05:52:54 <ndm> hkBst: better asking ross, i do the Wnidows port of Hugs, but no core Hugs hacking
05:52:54 <EvilTerran> sethk, while a Monad is something with a return and a bind function
05:53:03 <exe> They give an example of that, sethk.
05:53:04 <EvilTerran> Monad + Monoid = MonadPlus, approximately
05:53:09 <mauke> @src Monoid
05:53:09 <lambdabot> class Monoid a where
05:53:09 <lambdabot>     mempty  :: a
05:53:09 <lambdabot>     mappend :: a -> a -> a
05:53:09 <lambdabot>     mconcat :: [a] -> a
05:53:19 <sethk> EvilTerran, practically, though, when do you use the monoid?  I understand when you use monad
05:53:43 <EvilTerran> well, the Monoid instances for Ordering and Maybe are quite useful
05:53:46 <mauke> when you need to combine multiple things into one thing
05:53:46 <centrinia> sethk: A list is a monoid.
05:53:49 <EvilTerran> ?src Ordering mplus
05:53:50 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
05:53:54 <chessguy> oh, thanks mauke
05:53:54 <EvilTerran> ?src Ordering mappend
05:53:55 <lambdabot> Source not found. Do you think like you type?
05:53:59 <EvilTerran> ?src Maybe mappend
05:54:00 <lambdabot> Source not found. stty: unknown mode: doofus
05:54:00 <exe> http://channel9.msdn.com/ShowPost.aspx?PostID=358968 -> sethk this tutorial introduces monads from monoids, I think it might help you.
05:54:02 <EvilTerran> harumph
05:54:03 <lambdabot> Title: Brian Beckman: Don't fear the Monads
05:54:11 <dcoutts_> sethk: there are lots of examples in Cabal in fact
05:54:13 <sethk> exe, thanks, I'll read it.
05:54:20 <exe> sethk: it's a video :-p
05:54:23 <scook0> in fact, lists represent the free monoid!
05:54:24 <sethk> dcoutts, in the cabal source, you mean?
05:54:41 <dcoutts_> sethk: yes, command line flags and sets of command line flags are monoids, PackageIndexes are monoids
05:54:42 <centrinia> Free monoids don't cost anything.
05:54:43 <sethk> exe, Hmm., not sure whether I can handle the technical complexities of a video  :)
05:54:50 <sethk> dcoutts, thanks
05:55:06 <scook0> > "abc" `mplus` "def" `mplus` "ghi"
05:55:07 <lambdabot>  "abcdefghi"
05:55:18 <sethk> centrinia, under the usual meaning of free, free _anything_ doesn't cost anything   :)
05:55:29 <exe> sethk: it's an introduction to monad for imperative programmers (C++)
05:55:34 <scook0> > (Sum 1) `mappend` (Sum 2) `mappend` (Sum 3)
05:55:34 <lambdabot>  Sum {getSum = 6}
05:55:37 <EvilTerran> I believe a monad is also a monoid, but a Monad is not always a Monoid :P
05:55:42 <centrinia> cost (Free _) = 0
05:55:56 <sethk> exe, thanks, but I did finally figure out the monad concept.  At least I think I did.
05:55:58 * EvilTerran can't remember what the operator and id element are, though
05:56:16 <scook0> "a monad is also a monoid" is a little imprecise, since they have different kinds
05:56:22 <EvilTerran> (>=>) and (return ()) would work for Monad m => m ()
05:56:37 <exe> sethk: he introduces what is a monoid first, then shows how a monad can be seen 'as' a monoid
05:56:51 <exe> scook0: well... more or less the idea is there :-p
05:56:52 <sethk> exe, I'll watch it, it can't hurt.  :)
05:57:01 <centrinia> What is the identity element for a monad?
05:57:04 <scook0> EvilTerran: isn't that (>>) and (return ()) ?
05:57:09 <EvilTerran> er, yes
05:57:40 * EvilTerran just has vague recollections of the category theoretic definition of a monad involving a monoid
05:58:00 <scook0> though I suppose (>=>) and (return) could be another one
05:58:12 <EvilTerran> yeah, for (a -> m a)
05:58:18 <EvilTerran> it's MonadEndo!
05:58:48 <scook0> KleisliEndo, perhaps :)
05:59:21 <EvilTerran> ... indeed. MonadEndo would make it sound like there should be Endo and EndoT types...
05:59:31 <scook0> the CT connection probably involves join somewhere
06:02:05 <quicksilver> EvilTerran: yes, monads do contain some laws which look like the monoid laws
06:02:19 <quicksilver> EvilTerran: furthermore, they generate monoids in various ways.
06:03:00 <scook0> I recall some monad/monoid stuff from the catsters videos, but the details escape me
06:03:11 <EvilTerran> quicksilver, generate? as in the two we mentioned above?
06:03:40 <EvilTerran> "not a monoid itself, but can be used in the definition of a monoid in various straightforward ways"
06:03:47 <exe> R. Bird shows in his book Introduction to functional programming, how we could see (more or less) a monad as a monoid.
06:03:54 <exe> (using Haskell)
06:05:12 <ddarius> A monad is a monoid object in Cat.
06:05:19 <lesshaste> is there something like a top ten list of the coolest haskell programs :)
06:05:24 <quicksilver> EvilTerran: for example.
06:05:30 <lesshaste> I always need material to show off to non-haskell believers
06:05:41 <scook0> lesshaste: darcs, xmonad
06:05:47 <mauke> ghc
06:05:47 <scook0> (and GHC, of course)
06:05:55 <mauke> preflex :-)
06:06:29 <lesshaste> thanks.. I didn't know about darcs at all
06:06:36 <exe> lambdabot ^.^
06:07:00 <lesshaste> what is preflex?
06:07:11 <mauke> lesshaste: a bot I've written a few days ago
06:07:20 <lesshaste> mauke: oh I see
06:07:21 <lesshaste> :)
06:07:34 <ndm> lesshaste: hoogle?
06:07:37 <lesshaste> those apps are cool.. how about much smaller apps?
06:07:49 <ddarius> xmonad is pretty small.
06:07:55 <hkBst> lesshaste: you mean one-liners? :)
06:08:04 <lesshaste> hkBst: well.. one pagers :)
06:08:13 <lesshaste> something I can actually explain in full
06:08:31 <lesshaste> the sort of thing you use to motivate functional programming to students
06:08:35 <mauke> http://mauke.ath.cx/stuff/haskell/fun.hs
06:08:40 <xerox> lesshaste: this works? :) http://darcs.haskell.org/~paolo/nymphaea/
06:08:41 <lesshaste> hoogle is wild!
06:08:41 <lambdabot> Title: Nymphaea - Cairo based Lindenmayer Systems renderer
06:08:42 <scook0> > filterM (const [False ..]) "abcd" -- a classic!
06:08:44 <lambdabot>  ["","d","c","cd","b","bd","bc","bcd","a","ad","ac","acd","ab","abd","abc","a...
06:08:54 <ndm> lesshaste: xmonad is pretty small
06:09:10 <xerox> lesshaste: ~100 lines iirc.
06:09:34 <lesshaste> oh! sorry I should have checked xmonad more carefully
06:10:05 <swiert> regarding monoids vs monads. The slogan to remember is that a monad is a monoid in the category of endofunctors.
06:10:05 <xerox> xmonad is like ~1000 lines
06:10:08 <mauke> lesshaste: give them 'fmap fix return'
06:10:29 <mauke> trying to understand that in one go with no haskell experience should be enough to make their brains explode three times over
06:10:31 <lesshaste> http://darcs.haskell.org/~paolo/nymphaea/ doesn't seem to work in firefox.. I mean going over or clicking on "theory" does nothing for example
06:10:36 <lambdabot> Title: Nymphaea - Cairo based Lindenmayer Systems renderer
06:10:40 <quicksilver> swiert: yes, but that you have to remember what "monoid in a category" means
06:10:46 <lesshaste> mauke: I don't understand it!
06:10:48 <xerox> lesshaste: that's because I never wrote that page.
06:10:51 <quicksilver> swiert: which is not the same as the simple definition of monoid.
06:11:03 <swiert> quicksilver: that's easy. A monoid is a category with one object.
06:11:03 <lesshaste> xerox: :)
06:11:10 <swiert> :)
06:11:11 <ddarius> quicksilver: It's pretty close.
06:11:18 <elzurk> I realize this is far from pretty, but should it not work?
06:11:21 <elzurk> let isPrime n = (length [x | x <- [1..(floor (sqrt n))], mod n x == 0]) == 1
06:11:31 <ddarius> lesshaste: Read "Why Functional Programming Matters"
06:11:40 <lesshaste> ddarius: oh yes I have that thanks
06:11:43 <elzurk> if I call isPrime 7, I get an error
06:11:46 <quicksilver> ddarius: true
06:11:56 <mauke> elzurk: no, you can't call sqrt on integers
06:12:42 <quicksilver> swiert: that begs more questions, again.
06:12:47 <elzurk> isPrime 7.0 is not happy either
06:12:52 <quicksilver> swiert: the category of endofunctors has many objects.
06:13:00 <mauke> elzurk: right, because you can't call mod on floats
06:13:01 <quicksilver> swiert: a monoid has one object
06:13:14 <elzurk> mauke: arrrg, ic
06:13:17 <quicksilver> swiert: so what on earth is a 'monoid in the category of endofunctors' suposed to mean?
06:13:26 <quicksilver> swiert: I do, actually, know the answer, by the way.
06:13:32 <mauke> elzurk: sqrt (fromIntegral n)
06:13:36 <quicksilver> I'm just explaining my opinion on why that's a poor slogan.
06:14:29 <lesshaste> nubBy(((>1) .) . gcd) [2..]
06:14:30 <lesshaste> ?
06:14:40 <lesshaste> fiblist = 0 : 1 : (zipWith (+) fiblist (tail fiblist))
06:14:43 <lesshaste> :)
06:14:50 <elzurk> mauke, thanks!
06:15:53 <lesshaste> can anyone explain "fix ((1:) . scanl (+) 1)" ?
06:15:58 <hkBst> lesshaste: solutions to http://projecteuler.net/ might be small enough and neat to explain :)
06:15:59 <swiert> quicksilver: sure. Scrolling back, there seemed to be a bit of confusion about the relationship.
06:16:00 <lambdabot> Title: Project Euler
06:16:15 <lesshaste> hkBst: thanks
06:16:23 <EvilTerran> lesshaste, expand the definitions of fix and scanl
06:16:31 <lesshaste> EvilTerran: right
06:16:37 <lesshaste> EvilTerran: is there a haskell bot here?
06:16:44 <mauke> @src fix
06:16:44 <lambdabot> fix f = let x = f x in x
06:16:49 <mauke> @src scanl
06:16:49 <lambdabot> scanl f q ls = q : case ls of
06:16:49 <lambdabot>     []   -> []
06:16:49 <lambdabot>     x:xs -> scanl f (f q x) xs
06:16:50 <EvilTerran> == let x = 1 : scanl (+) 1 x
06:16:55 <EvilTerran> ... in x
06:16:55 <lesshaste> thanks :)
06:17:08 <lesshaste> @src nubBy
06:17:08 <lambdabot> nubBy eq []             =  []
06:17:08 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
06:17:11 <mauke> > scanl f z [a, b, c, d, e]
06:17:14 <lambdabot>  [z,f z a,f (f z a) b,f (f (f z a) b) c,f (f (f (f z a) b) c) d,f (f (f (f (f...
06:17:18 <swiert> quicksilver: I was a little imprecise about monoids. The important thing is a monoid in a category, not how to model monoids in general in category theory.
06:17:51 <swiert> quicksilver: But I do find the "monad-as-monoid" definition quite useful - I tend to forget the laws in the Kleisli presentation.
06:20:25 <EvilTerran> ?src scanl
06:20:25 <lambdabot> scanl f q ls = q : case ls of
06:20:26 <lambdabot>     []   -> []
06:20:26 <lambdabot>     x:xs -> scanl f (f q x) xs
06:20:43 <EvilTerran> oh, wait, we already had that. nvm.
06:21:01 <EvilTerran> ... anyway, the [] case can never happen, as we're dealing with an infinite list here
06:23:04 <EvilTerran> which makes things a lot easier to expand out
06:24:11 <lesshaste> hkBst: of course I would have to solve them all elegantly first it seems :)
06:24:12 <EvilTerran> because you can pretend the definition's just scanl f q (x:xs) = q : scanl f (f q x) xs
06:24:17 <quicksilver> swiert: in my mind the problem is that monoid has a generally accepted definition which is very simple, and many people understand it.
06:24:47 <quicksilver> swiert: and according to that simpel definition it's not remotely obvious what "monoid in the category of endofunctors" is supposed to be.
06:25:01 <quicksilver> swiert: of course when you do know how it all works, it's easy enough to divine, but...
06:29:50 <paolino> @src Reader
06:29:51 <lambdabot> Source not found. Do you think like you type?
06:30:09 <paolino> @src Control.Monad.Reader
06:30:09 <lambdabot> Source not found. Maybe if you used more than just two fingers...
06:30:14 <ddarius> Generalizing from a monoid in Set to a monoid in an endofunctor category seems pretty straightforward given a basic understanding of category theory.
06:30:21 <mauke> @unmtl Reader e a
06:30:22 <lambdabot> e -> a
06:30:41 <ddarius> Worst-case scenario, there is now a 8:28 minute Catster video on it.
06:31:04 <paolino> @src Control.Monad.MonadReader
06:31:04 <lambdabot> Source not found.
06:31:46 <quicksilver> ddarius: FSVO basic, yes. FOVO basic, no.
06:31:53 <quicksilver> it really depends how much cat theory you ave.
06:32:11 <hkBst> lesshaste: :)
06:32:21 <ddarius> If you know enough to know what an endofunctor category is, you're probably set.
06:32:25 <ivanm> does the bibliography at haskell.readscheme.org get updated anymore? the "recent additions" has the last paper being from around 2000 :s
06:33:00 <Botje> have you checked the reading material at haskell.org ?
06:34:01 <ivanm> Botje: I came across the readscheme one as it seemed to be searchable and listed by index
06:34:09 <ivanm> I've seen the one at haskell.org though, yes
06:34:49 <ivanm> but it seems to be only on haskell development, rather than usage AFAICT (i.e. I was looking for papers on research done _using_ haskell, not _about_ haskell)
06:43:37 <swiert> quicksilver: I agree that the basic definition of a monoid is simple. But I don't think it's that hard to generalise to a monoid in a category.
06:44:10 <swiert> quicksilver: the complication in this case comes from working in a functor category, which is always a bit weird - kind of like programming with higher-order functions takes a while to get used to.
07:00:08 <centrinia> Is it possible to almost all Data.List functions with map and foldl or foldr?
07:00:53 <centrinia> s/possible to almost/possible to implement almost/
07:01:46 <wjt> you can implement map and foldl in terms of foldr ;_)
07:02:50 <centrinia> What about intersect, union, elem and others?
07:03:17 <ivanm> possibly elem...
07:03:37 <centrinia> What about union and intersect?
07:03:51 <wjt> @src intersect
07:03:51 <lambdabot> intersect = intersectBy (==)
07:03:53 <wjt> @src intersectBy
07:03:53 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
07:04:00 <wjt> @src any
07:04:00 <lambdabot> any p =  or . map p
07:04:05 <wjt> @src or
07:04:05 <lambdabot> or    =  foldr (||) False
07:04:20 <ivanm> elem' x xs = foldr (\ y t -> t || x == y) xs
07:04:35 <wjt> so all you need to do is express the list comprehension in terms of things known to be implementable with foldr and you're done
07:04:36 <matthew_-> what's the default fixity for infix ops?
07:04:51 <ivanm> it's a per-op basis, isn't it?
07:06:05 <matthew_-> eh? I mean one I define
07:06:15 <matthew_-> if I don't explicitly set a fixity, what fixity does it take?
07:06:45 <centrinia> 2
07:07:27 <matthew_-> ahh cool. thanks
07:07:40 <matthew_-> it's a shame that :i doesn't report that
07:07:44 <centrinia> I just like typing in the number 2 sometimes. :p
07:07:56 <centrinia> 2 might or might not be the default fixity. :p
07:08:12 <matthew_-> right.
07:08:46 <centrinia> If you really need to know, just define a fixity 5 operator and see if an unspecified fixity operator is higher or lower.
07:09:01 <centrinia> If it is higher than 5, try 7.
07:09:05 <matthew_-> for efficiency, I could do a binary search
07:09:11 <centrinia> Yeah.
07:09:16 <centrinia> That was what I was alluding to.
07:09:24 <matthew_-> brill. Maybe I could just read the docs too
07:09:40 <centrinia> Grown men don't read docs.
07:09:46 <nornagon> @index setEnv
07:09:47 <lambdabot> System.Posix.Env, System.Posix
07:10:18 <ToRA> Any operator lacking a fixity declaration is assumed to be infixl 9
07:10:43 <matthew_-> Any operator lacking a fixity declaration is assumed to be infixl 9
07:10:47 <matthew_-> doh!
07:10:56 * ivanm woners if he should say it as well ;-)
07:10:56 <matthew_-> @quote stereo
07:10:57 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
07:10:59 <centrinia> :t infixl
07:11:00 <lambdabot> parse error on input `infixl'
07:11:01 <matthew_-> oh ffs!
07:11:17 <centrinia> infixl is not a function?
07:12:00 <matthew_-> no, otherwise it could be passed around and change behaviour dynamically!
07:12:00 <desegnis> > let infixl 5 (+++); a +++ b = a + b; a *** b = a * b in 1 +++ 2 *** 3
07:12:00 <lambdabot>  Parse error at "(+++)..." (column 14)
07:12:08 <desegnis> > let infixl 5 +++; a +++ b = a + b; a *** b = a * b in 1 +++ 2 *** 3
07:12:10 <lambdabot>  7
07:12:47 <desegnis> > let infixl 10 +++; a +++ b = a + b; a *** b = a * b in 1 +++ 2 *** 3
07:12:47 <lambdabot>  Illegal precedence 10 at "+++;" (column 15)
07:12:53 <desegnis> > let infixl 7 +++; a +++ b = a + b; a *** b = a * b in 1 +++ 2 *** 3
07:12:54 <lambdabot>  7
07:13:03 <desegnis> > let infixl 0 +++; a +++ b = a + b; a *** b = a * b in 1 +++ 2 *** 3
07:13:03 <lambdabot>  7
07:13:18 <desegnis> bah
07:13:21 <matthew_-> bar
07:13:23 <matthew_-> good idea
07:13:26 * matthew_- heads to the bar
07:13:36 <desegnis> Foo!
07:13:39 <centrinia> > let foo = bar; bar = baz; baz = 42 in foo
07:13:39 <lambdabot>  42
07:14:25 <desegnis> > let infixl 9 +++; a +++ b = a + b; a *** b = a * b in 1 +++ 2 *** 3
07:14:25 <lambdabot>  9
07:14:27 <desegnis> finally
07:15:06 <desegnis> > let infixl 9 +++; a +++ b = a + b; a *** b = a * b in 3 *** 2 +++ 1
07:15:07 <lambdabot>  7
07:15:31 <centrinia> > let foo t = 5+t; infixl (foo 4) +++; a +++ b = a + b; a *** b = a * b in 1 +++ 2 *** 3
07:15:31 <lambdabot>  Parse error at "(foo" (column 25)
07:15:37 <centrinia> Darn.
07:15:43 <desegnis> So the default is to bind tightest, I guess.
07:16:11 <desegnis> (Sorry for my noisy way of finding out)
07:16:14 <centrinia> > let infixl 9 +++; a +++ b = a + b; infixl 10 ***; a *** b = a * b in 1 +++ 2 *** 3
07:16:14 <lambdabot>  Illegal precedence 10 at "***;" (column 46)
07:16:18 <centrinia> Yeah.
07:16:35 <centrinia> I thought there was a fixity of 10.
07:25:48 <Syzygy-> ?index on
07:25:48 <lambdabot> bzzt
07:25:51 <Syzygy-> No.
07:25:55 <Syzygy-> Where is `on` defined?
07:26:05 <Syzygy-> ?hoogle on
07:26:06 <ziman> Data.Function
07:26:07 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
07:26:07 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
07:26:07 <lambdabot> Data.Function :: module
07:26:10 <Syzygy-> Thanks.
07:29:09 <LordBrain> how mature is wxHaskell?
07:29:12 <elzurk> I'm confused, can't seem to be able to translate: for i in range(x): for j in range(x): list.append(i*j)
07:29:25 <elzurk> can someone enligthen me?
07:29:51 <LordBrain> yeah, that's simple... just use a comprehension
07:29:55 <ToRA> >let x = [1,2,3] in let list = [ (i*j) | i <- x ; j <- x ] in list
07:30:07 <ToRA> > let x = [1,2,3] in let list = [ (i*j) | i <- x , j <- x ] in list
07:30:16 <lambdabot>  [1,2,3,2,4,6,3,6,9]
07:30:54 <elzurk> I tried: [x | x <- [1..n], (map (\n -> n * x) [1..n])], but I guess that's not right
07:30:58 <LordBrain> lke ToRA  said
07:31:08 <ToRA> > let x = 10 in let list = [ (i*j) | i <- [1..x] , j <- [1..x] ] in list
07:31:09 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,2,4,6,8,10,12,14,16,18,20,3,6,9,12,15,18,21,24,27,30,4...
07:31:27 <ToRA> sorry, i forgot what range does in python...
07:31:40 <gnuvince> range(10) == [0..9]
07:31:56 <LordBrain> so it should be x-1
07:32:00 <LordBrain> and start with 0
07:32:16 <LordBrain> you see elzurk ?
07:32:48 <elzurk> I think I do. Cool, just plain old set notation
07:32:55 <LordBrain> [ i * j | i <- [0..x-1], j <- [0..x-1] ]
07:32:59 <LordBrain> yeah
07:33:11 <elzurk> this is, oh, so schweet!
07:33:20 <elzurk> thanks
07:43:11 <byorgey> ToRA: btw, you can combine those multiple lets into one
07:43:46 <byorgey> > let x = 10; list = [ (i*j) | i <- [1..x] , j <- [1..x] ] in list
07:43:47 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,2,4,6,8,10,12,14,16,18,20,3,6,9,12,15,18,21,24,27,30,4...
07:44:22 <byorgey> it's a bit shorter that way, and actually more powerful since you can have mutually recursive bindings, which you can't do with nested lets
07:44:39 <byorgey> > let x = 0 : y ; y = 1 : x in take 20 x
07:44:40 <lambdabot>  [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1]
07:45:33 <desegnis> > take 20 (fix (0:1:))
07:45:33 <lambdabot>      The operator `:' [infixr 5] of a section
07:45:33 <lambdabot>         must have lower precede...
07:45:50 <desegnis> > take 20 (fix (\xs -> 0:1:xs))
07:45:50 <lambdabot>  [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1]
07:46:15 <Deewiant> > take 20 (cycle [0,1])
07:46:16 <lambdabot>  [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1]
07:46:16 <ndm> > take 20 $ cycle [0,1]
07:46:17 <lambdabot>  [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1]
07:46:29 <ndm> recursive let's are very rarely useful
07:46:52 <desegnis> Coming from Haskell it's funny to think that some FP people define let's in terms of the fix combinator
07:47:18 <desegnis> (let's = semantics of let)
07:48:52 <ndm> desegnis: how would you define the semantics of let?
07:51:15 <desegnis> ndm, not sure off-hand about mutually recursive functions, but for plain recursive definitions you just define (let x = Term(x)) by (let x = fix (\y -> Term(y)))
07:57:05 <dolio> Mutual recursion isn't any harder.
07:57:33 <Jaak> *sigh* how to do something like: foo :: Num a => [(String, a)] ... f = map fst foo
07:57:36 <dolio> > let (x,y) = fix (\(x,y) -> (0:y, 1:x)) in x
07:57:37 <lambdabot>  Exception: <<loop>>
07:58:43 <Jaak> > let foo = [("hi", 1)] :: Num a => [(String, a)]; f = map fst foo in f
07:58:44 <lambdabot>  ["hi"]
07:59:06 <Jaak> strange. i'm getting "Ambiguous type variable" errors...
07:59:27 <dolio> > let (x,y) = fix (\ ~(x,y) -> (0:y, 1:x)) in x
07:59:27 <lambdabot>  [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1...
07:59:53 <saml> > map fst [("asdf", 2)]
07:59:54 <lambdabot>  ["asdf"]
08:00:02 <saml> :t map fst [("asdf", 2)]
08:00:08 <Jaak> @type let foo = [("hi", 1)] :: Num a => [(String, a)] in map fst foo
08:00:08 <lambdabot> [[Char]]
08:00:09 <lambdabot> [String]
08:00:14 <Jaak> sob!
08:00:22 <Jaak> why doesn't this work for me
08:01:15 <desegnis> dolio, just using tuples... of course
08:01:48 <saml> > let f = [("asdf", 1)] :: (Num a) => [(String, a)] in map fst f
08:01:48 <lambdabot>  ["asdf"]
08:01:48 <Jaak> @type let foo = [("hi", 1)] :: Num a => [(String, a)] in (map fst foo, foo)
08:01:49 <lambdabot> forall a. (Num a) => ([String], [(String, a)])
08:01:54 <desegnis> Btw, has Hayoo been announced somewhere (when?), and what is its relation to hoogle?
08:01:59 <quicksilver> Jaak: well I suspect it doesn't mean what you want it to mean.
08:02:02 <saml> Jaak: it worketh
08:02:06 <quicksilver> Jaak: it means that all the numbers are the same type 'a'
08:02:12 <quicksilver> Jaak: I would guess that's not what you meant :P
08:02:15 <Jaak> i know this
08:02:22 <elzurk> can I time how long something takes in ghci?
08:02:48 <saml> > [("asdf", 2 :: Int), ("asdf", 3.53)] :: (Num a) => [(String, a)]
08:02:49 <lambdabot>        add (Fractional a) to the context of
08:02:49 <lambdabot>         the polymorphic type `for...
08:03:01 <Jaak> saml: that's not what i want to do
08:03:22 <Jaak> all the second components are of same type
08:03:24 <mux_> hayoo sure is cute
08:03:48 <desegnis> elzurk: :set +s
08:03:50 <saml> Jaak: could you post your code in hpaste.org?
08:03:53 <desegnis> elzurk: (s for statistics)
08:04:31 <Jaak> you won't be able to run the code
08:04:47 <quicksilver> Jaak: well what do you want to do, and what part doesn't work?
08:05:00 <elzurk> desegnis: thanks!
08:05:49 <Jaak> i have... builtins :: (Comonad d, Monad t) => [(String, Value d t)] and i just want to extract the first components... but it just tells me that "Ambiguous type variable `d' in the constraint"
08:05:59 <Jaak> sure, i could just duplicate the list... but that's stupid
08:07:23 <desegnis> Jaak, an ambigious type variable probably means that you forget to specify a concrete type for d on the caller site
08:07:42 <Jaak> *sigh*
08:08:30 <quicksilver> Jaak: builtins promises to work for *any* d and *any* t, chosen by the caller
08:08:34 <quicksilver> Jaak: is that what you mean?
08:08:50 <Jaak> yes, any Monad t and Comonad d
08:09:10 <desegnis> ah wait, according to your examples it seems you wanted polymorphic values, then my comment would not make sense...
08:09:29 <Jaak> do i really have to just copy paste the first components?
08:09:35 <Saul_> I'm trying to install the FastCGI package by Lemmih, but I'm getting errors
08:09:45 <Saul_> Can anyone help?
08:09:52 <Lemmih> Saul_: We can try.
08:10:23 <Jaak> i don't understand why it works with Num...
08:10:28 <quicksilver> Jaak: ok, well when extracting the first components.
08:10:34 <quicksilver> Jaak: you need to fix the type of the second.
08:10:47 <quicksilver> Jaak: (as far as it knows, the first component may depend on the type of the second)
08:10:47 <Jaak> my god...
08:10:55 <quicksilver> does that make it any clearer?
08:11:06 <Jaak> no, it doesn't
08:11:12 <Jaak> why it works with Num?
08:11:14 <quicksilver> for all the type-system can tell, the String may be differnt for ThisCoMonad and ThatCoMonad
08:11:19 <quicksilver> because Num defaults.
08:11:29 <Saul_> http://hpaste.org/7045
08:11:35 <quicksilver> so it needs to know which Monad and CoMonad before it can safely extract the string.
08:11:36 <Jaak> hm
08:11:40 <sm> morning
08:11:42 <Saul_> Lemmih: I posted the errors on the paste above
08:12:11 <desegnis> Jaak: I guess it works with Num because of type defaulting
08:12:19 <Jaak> aah, okay, so i just have to trick the type system.
08:12:29 <Lemmih> Saul_: Hand me the url.
08:12:32 <desegnis> Jaak: a is implicitly defaulted to Integer
08:12:37 <nibro> Saul_, Lemmih: I think you're missing an -fvia-C in there
08:12:43 <Saul_> Lemmih: http://hpaste.org/7045
08:12:43 <Lemmih> Oh, there it is.
08:12:45 <dons> some stories for today, http://reddit.com/r/programming/info/6g9ea/comments/   http://reddit.com/r/programming/info/6g9dy/comments/  and  http://reddit.com/r/programming/info/6g9dq/comments/
08:12:45 <Jaak> by doing something like map fst (builtins :: [(String, Valude Id Id)])
08:12:52 <Jaak> Value*
08:13:00 <Jaak> makes sense now
08:13:23 <Lemmih> nibro: -fvia-c is never necessary.
08:13:28 <Jaak> quicksilver: thanks
08:13:42 <Saul_> Lemmih: Still it's probably a C error
08:13:47 <Lemmih> Saul_: haskell-fastcgi is a binding to fastcgi. You need to install fastcgi first.
08:14:06 <Saul_> Lemmih: Ah of course :)
08:14:11 <Saul_> Lemmih: Thanks
08:14:18 <quicksilver> Jaak: sure :)
09:04:25 <eugman|college> So I'm going to make a text adventure this weekend for LD 11 and a school project and I was trying to figure out something. I was thinking of starting with a simple two word parser and just have a self calling function for the game loop that just passes the whole game state after a new one is constructed from the old one. What I don't know is what would be a good way to go from know the command to telling the program what to do.
09:06:02 <shepheb> eugman|college: I've used a Data.Map from Strings to some type of command functions, in the past. those command functions take the argument, handle it however, and update the game state.
09:07:12 <eugman|college> That sounds good I'll look into it.
09:08:39 <sethk> I'm getting the wrong answer with isSymbolicLink from Posix.Files.  Ring any bells for anyone?
09:20:31 <halberd> what is the Haskell name for the function \ a b -> a b  ?
09:20:47 <halberd> oh, id
09:20:57 <dcoutts_> @type \ a b -> a b
09:20:59 <lambdabot> forall t t1. (t -> t1) -> t -> t1
09:21:04 <byorgey> halberd: it's id, or ($) for a more specific version
09:21:07 <dcoutts_> @hoogle (t -> t1) -> t -> t1
09:21:07 <lambdabot> Did you mean: (t -> T1) -> t -> T1
09:21:07 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
09:21:07 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
09:21:20 <byorgey> @type ($)
09:21:21 <lambdabot> forall a b. (a -> b) -> a -> b
09:21:21 <dcoutts_> yay for hoogle :-)
09:21:38 <byorgey> @. hoogle type \ a b -> a b
09:21:40 <lambdabot> Did you mean: Forall t T1. (t -> T1) -> t -> T1
09:21:40 <lambdabot> Prelude.const :: a -> b -> a
09:21:40 <lambdabot> Prelude.seq :: a -> b -> b
09:21:47 <dcoutts_> byorgey: heh, nice
09:21:54 <byorgey> it didn't work though =(
09:22:07 <byorgey> didn't like the explicit forall, I think
09:22:08 <dcoutts_> @djinn (a -> b) -> a -> b
09:22:09 <lambdabot> f a = a
09:31:10 <halberd> I have a set of line segments in the plane and I want to find all of those that intersect a given disc
09:31:12 <halberd> any ideas?
09:31:22 <dolio> @djinn (a -> b) -> Either (Not a) b
09:31:22 <lambdabot> -- f cannot be realized.
09:32:20 <tromp> for each line compute distance of disc center to line
09:32:23 <halberd> other than the obvious try-every-one of course
09:32:54 <matveev> hi, what the proper english name for the function transformation f(x,y,...) -> N*f(x/N,y/N,...)
09:34:06 <byorgey> halberd: hm? how could you do it any other way than simply trying each one?
09:34:27 <halberd> well you would probably use some kind of tree code
09:34:41 <halberd> that's what I was doing before only I was only doing it to see if I could find either endpoint of the line segment in the disk
09:34:48 <byorgey> halberd: but you'd still have to examine each line segment.
09:34:53 <halberd> but I realized that the line segment can cross the disk with neither endpoint inside it
09:34:57 <byorgey> right.
09:35:05 <halberd> ah, well I am allowing for a preprocessing step
09:35:23 <halberd> and then I want to check a bunch of disks for intersection with the same set of line segments
09:35:43 <byorgey> halberd: oh, I see, if you want to check a bunch of disks, that's different.
09:35:56 <halberd> n disks, n line segments
09:36:26 <byorgey> yeah, some sort of space partition with the lines in it could help
09:36:35 <byorgey> i.e. a quadtree or something like that
09:37:07 <halberd> the problem (although I haven't thought too hard about this particular part of the problem) is that I can't represent the line segments as points
09:37:12 <byorgey> so if you know that a disk falls in region A, and a bunch of lines fall completely within region B which is disjoint from A, you can throw out all those line segments without testing each one
09:38:21 <halberd> it may also be of use that all the disks have the same size
09:38:32 <halberd> and all the line segments are approximately the same length
09:40:58 <halberd> actually to be slightly more specific all of the line segments are ranked by priority and I want to find the highest priority line segment that intersects any given circle
09:43:04 <fons> Hi
09:43:31 <fons> Has anyone managed to install a working ghc on a leopard/ppc machine?
09:43:46 <fons> I'm a bit desperate
09:44:00 <pejo> fons, the 6.8.2 in macports supposedly works.
09:44:13 <paolino> halberd: disks are intersecting ?
09:44:23 <fons> pejo: with ppc?
09:44:36 <halberd> yeah they can intersect
09:44:37 <pejo> fons, yes, they've patched it.
09:44:48 <halberd> they shouldn't intersect much
09:44:53 <halberd> and also the line segments shouldn't cross much
09:44:53 <fons> ufff, I hope it works
09:45:02 <fons> It's going to take forever to compile
09:45:03 <paolino> much ?
09:45:20 <halberd> the data is coming from user input
09:45:32 <halberd> but usually there shouldn't be much intersection
09:45:58 <paolino> and they cover completely a part of the plane ?
09:46:19 <halberd> they are joined end to end in a plane curve
09:46:36 <dons> ?users!
09:46:37 <lambdabot> Maximum users seen in #haskell: 447, currently: 444 (99.3%), active: 12 (2.7%)
09:46:38 <dons> ?yow!
09:46:38 <lambdabot> Mary Tyler Moore's SEVENTH HUSBAND is wearing my DACRON TANK TOP in a
09:46:39 <lambdabot> cheap hotel in HONOLULU!
09:47:48 <eliot_> hello everyone. Do you know any library for haskell that supports making SOAP calls to a service on the web?
09:47:53 <bogner> i'm having trouble compiling yi with ghc 6.8. i get an error "No Instance for (RegexLike Regex B.ByteString)"
09:48:13 <dons> eliot_: soap. hmm, there's xml-rpc and json-rpc stuff.
09:48:20 <dons> eliot_: check on hackage.haskell.org
09:48:22 <dons> under the web category
09:48:37 <paolino> halberd: can you tell, what does that mean in simpler terms ? Disks are filled circles ?
09:49:06 <dons> eliot_: 'HAIFA' is a large xml and soap/1.1 impl.
09:49:10 <dons> though i've not used it.
09:49:13 <halberd> yes disks are circles including the interior
09:49:18 <dons> http://www.dcs.shef.ac.uk/~simonf/HAIFA.html
09:49:19 <lambdabot> Title: HAIFA
09:49:29 <halberd> I think I'll just go with brute force I guess, at least for now
09:49:32 <halberd> it shouldn't be too slow
09:50:41 <eliot_> dons: i've tried haxr (xml-rpc) lib, but have some problems with it. You've mentioned json-rpc but I can't any package on hackage that would support it. Do you know it's name?
09:51:00 <eliot_> dona: can't find*
09:51:15 <dons> eliot_: its about to be released. rjson might be enough (the rpc handling is only an extra little tweak over json serisliation)
09:51:38 <paolino> halberd: those are errors domains on sample datas ?
09:51:42 <fons> OK, before I spend a whole day compiling GHC for leopard/ppc with macports ... did anyone succesfully managed to use it?
09:51:55 <halberd> no I'm trying to smooth a curve
09:52:01 <halberd> in a particular way
09:52:07 <bogner> oh, seems like my bytestring is too new.
09:52:17 <halberd> that eliminates any thin jagged spikes in the curve even if those spikes have a long arc length
09:52:51 <eliot_> dons: ok, I'll give rjson a try. Do you know if there's any development version available (darcs?) that supports rpc?
09:53:03 <halberd> so like, if I have an outline of a car including the antenna, I want to turn that into the outline of the car without the antenna
09:53:11 <dons> there's a json-rpc library at galois we're about to release
09:53:17 * fons will then try it out and see what happens. sigh
09:53:19 <dons> should be available monday or tuesday
09:53:34 <dons> its only a small extension to json though
09:53:52 <paolino> halberd: sounds like a clustering problem
09:53:58 <halberd> maybe
09:54:23 <halberd> but what I'm trying is, I start at one point on the curve and try to find a point as far along the curve as possible that is within a given step size
09:54:24 <eliot_> dons: that sounds great! I'm looking forward to this release. Where will it be available from?
09:54:32 <halberd> the step size being the radius of the circle
09:54:50 <halberd> so that if I get to a point just before the antenna, it will jump right over the base of the antenna
09:54:54 <dons> eliot_: it'll all be on hackage
09:54:56 <halberd> ignoring the whole thing
09:55:03 <eliot_> gr8. big thx!
09:55:04 <eliot_> bye
09:55:40 <halberd> assuming that my step size is wider than the base of the antenna
09:57:21 <halberd> I want to "pinch off" narrow features of the curve
10:00:08 <byorgey> halberd: oh, so these aren't just any circles, but circles with centers at the endpoints of the segments?
10:00:20 <halberd> circles with centers on the segments, not necessarily the endpoints
10:01:11 <byorgey> oh, ok, I get it now.  and the furthest-along point you're trying to find could be in the middle of a segment, right?  not just an endpoint?
10:01:17 <halberd> yep
10:01:29 <halberd> also by the way if you have any alternative idea for pinching off narrow parts of the curve, that would also be a help
10:04:06 <halberd> I've also thought of calculating the area nearby a given line segment--on an antenna that would be small, on the edge of a circle it would be large
10:04:43 <halberd> so then I could discard the line segments whose nearby areas are small
10:04:56 <halberd> areas inside the (closed) curve
10:05:33 <halberd> but that seems more difficult computationally
10:09:08 <halberd> I suppose I could construct a line segment perpendicular to a given segment of the curve, and take the length of that line segment before it intersects another line segment to be a rough measure of how much area is nearby
10:18:14 <paolino> halberd: if you choose rapresentants points on the curve you can easily identify those that are very unbalanced in respect to their neighbours, those are to be pinched off with their population
10:18:29 <halberd> unbalanced?
10:19:22 <paolino> on a straight line the points sees their 2 neighbours on opposite sides, total balance
10:19:52 <halberd> that would only pinch off the very tip of the antenna
10:20:02 <paolino> first turn
10:20:36 <halberd> it could work
10:21:04 <halberd> thanks I think I'll probably try using that too
10:21:32 <halberd> do you want me to use your name
10:22:16 <paolino> only if I help coding
10:22:24 <halberd> I'm doing a project, if I use your idea I am going to credit you for it
10:22:37 <halberd> so should I just say "paolino"?
10:24:26 <halberd> ok thanks
10:24:26 <paolino> halberd: see my pm
10:27:19 <bos31337> dcoutts: ping
10:28:48 <dcoutts_> bos31337: hia
10:29:32 <bos31337> dcoutts_: i have a cabal configurations question for you.
10:29:39 <dcoutts_> ok
10:30:02 <bos31337> in cabal-rpm, i need to call the equivalent of "setup configure" to generate the necessary files for me to be able to run sdist.
10:31:01 <dcoutts_> bos31337: well, you can do sdist without configure, you just don't get the platform independent pre-processed files
10:31:24 <bos> dcoutts_: exactly, so it's kind of useless that way :-)
10:31:34 <dcoutts_> well, depends what you're trying to do
10:31:56 <dcoutts_> if you're making a src rpm isn't it exactly what you want?
10:32:27 <dcoutts_> bos: ok so you want to configure first, what is the issue
10:32:27 <bos> no, a src rpm has be built from a tarball, which needs a spec file injected into it.
10:32:52 <bos> the problem is that when i try to call configure internally, it barfs due to configurations issues.
10:33:08 <Nafai> Simple question
10:33:16 <dcoutts_> bos: what kind of issues?
10:33:18 <Nafai> I want an array of 100 booleans, all false
10:33:22 <Nafai> How would I do that?
10:33:24 <Nafai> s/array/list/
10:33:46 <bos> dcoutts_: such as "cannot satisfy dependency base<3"
10:33:56 <allbery_b> > replicate 100 False -- ?
10:33:57 <bos> dcoutts_: my original program was written before configurations came along.
10:33:57 <lambdabot>  [False,False,False,False,False,False,False,False,False,False,False,False,Fal...
10:34:08 <Nafai> allbery_b: Thanks :)
10:34:48 <bos> dcoutts_: if i call configure from the command line, it gets the default values for the flags right.
10:35:07 <bos> dcoutts_: i'm just having a bit of trouble figuring out where in the code the buildinfo is set up to have the correct configurations defaults.
10:35:17 <dcoutts_> bos: ah so you're calling finalisePackageDescription?
10:35:27 <bos> no, i'm not.
10:35:37 <dcoutts_> bos: how are you configuring in the code?
10:35:50 <bos> i'm using flattenPackageDescription
10:36:04 <dcoutts_> bos: ok, that's no good for your purpose
10:36:32 <bos> the thing is, finalizePackageDescription takes a zillion parameters.
10:36:54 <dcoutts_> bos: right, though none of them are that hard
10:37:06 <dcoutts_> eg you can pass Nothing for the installed packages
10:37:15 <dcoutts_> and several others are just constants
10:37:20 <bos> yeah.
10:37:25 <dcoutts_> bos: check the cabal-install code for examples
10:37:30 <bos> ok, i'll try that.
10:37:46 <bos> thanks.
10:37:59 <dcoutts_> bos: flatten combines both sides of mutually exclusive configurations for example, so it's no good for trying to satisfy dependencies
10:38:10 <dcoutts_> but it's fine for some other uses
10:38:42 <dcoutts_> bos: please also keep notes on where the Cabal library API is crap
10:38:56 <dcoutts_> bos: we want to improve it for tools like yours and IDEs etc
10:39:07 <dcoutts_> things that are not the standard command line tool
10:39:41 <dcoutts_> bos: specific or general feature requests in the trac are also much appreciated
10:40:56 <bos> it's not giving me much trouble, it's just rather big.
10:41:49 <bos> so there's a lot of needle-in-haystack fun.  i need to call this function.  oh, what's this type it needs?  how do i create a value? etc, etc.  the usual kind of stuff, nothing bad at all.
10:41:51 <dcoutts_> bos: I added a guide to the source code on the hackage wiki btw
10:42:10 <bos> oh, cool.
10:43:30 <dcoutts_> bos: perhaps you could send a list of your use cases to the cabal-devel list some time, it'd be interesting for us to think about how the api could be improved
10:45:53 <bos> dcoutts_: i'll try to find time :-(
10:45:59 <dcoutts_> bos: no rush
10:54:58 <bos> dcoutts_: got the gordian knot cut
10:57:05 <bos> dcoutts_: thanks for the help
10:57:58 <bogner> anyone here use yi? compiling it doesn't seem to create a binary... i'm not sure how to use it
11:04:03 <MyCatVerbs> bogner: compiling the yi package off hackage will get you a Yi library.
11:04:24 <byorgey> geez, compiling Yi now spews a metric crapload of warnings =P
11:04:26 <MyCatVerbs> bogner: to get an actual executable, you'll want to compile either the yi-vty or yi-gtk package.
11:04:47 <bogner> oh, that makes sense. thanks MyCatVerbs
11:05:10 <MyCatVerbs> bogner: no worries.
11:05:28 <Nafai> @users
11:05:28 <lambdabot> Maximum users seen in #haskell: 447, currently: 435 (97.3%), active: 13 (3.0%)
11:05:35 <bogner> where's the darcs yi-gtk? i'm running darcs yi
11:18:55 <awesame> how do monads sequence operations?
11:19:05 <lament> With >>= :)
11:19:25 <dolio> With data dependencies.
11:19:32 <awesame> I was reading in "the craft of functional programming" about the identity monad, and it looks like it just throws some function applications in between operations
11:19:47 <dolio> Not all monads sequence things.
11:19:54 <awesame> ah, okay
11:19:59 <dolio> (->) e doesn't, for instance.
11:19:59 <awesame> it's super unclear about that
11:20:04 <lament> awesame: the identity monad is the identity monad
11:20:08 <lament> awesame: meaning, it doesn't actually do anything
11:20:20 <awesame> got it
11:21:29 <Jaak> i like identity comonad more
11:23:13 <awesame> so I suppose the list monad isn't really sequencing operations fully either, right?
11:23:21 <mehrheit> > var "test"
11:23:22 <lambdabot>  test
11:23:28 <mehrheit> @index var
11:23:28 <lambdabot> bzzt
11:24:01 <dolio> Not really. Things in the list monad run in depth first search order, more or less.
11:24:18 <bd_> :t var
11:24:22 <lambdabot> forall a. String -> Sym a
11:24:24 <Deewiant> What's the point of the identity monad? Where would one use it?
11:24:39 <bd_> Deewiant: When you write some monadic function, but then want to make a non-monadic version
11:25:05 <bd_> eg, in a project of mine, I have some monadic traversal functions over a complex datastructure. By using Identity, I can easily turn them into non-monadic ones
11:25:06 <dolio> Often, you can write a FooT, and get Foo via FooT Identity.
11:25:23 <Deewiant> So shouldn't everyone write all functions monadically and not non-monadically for maximum genericity?
11:26:09 <vincenz> dolio: sure, theoretically, practically there's a bit more plumbing
11:26:21 <bd_> We should write all functions using arrows :D
11:26:38 <awesame> so in the IO monad, if I bind a bunch of putStrLns in sequence, what stops them from being evaluated out-of-order?
11:26:42 <Deewiant> bd_: Yeah, okay, that too. :-)
11:26:56 <bd_> or Control.Applicative :D
11:27:02 <awesame> there's no data dependency there
11:27:09 <nibro> http://hpaste.org/7047
11:27:11 <bd_> awesame: the >>= (or >>) operator gives the explicit order
11:27:12 <dolio> Eh? Just writing FooT seems to work in the majority of cases I've seen.
11:27:21 <bd_> awesame: (putStrLn "foo") >> (putStrLn "bar")
11:27:27 <nibro> could someone help me straighten out the concurrency here?
11:27:33 <dolio> Or are you talking about needing generalized newtype deriving?
11:27:36 <bd_> is ths same as do { putStrLn "foo"; putStrLn "bar" }
11:27:39 <awesame> bd_: I see that you use it to write down the explicit order.  I'm asking how it accomplishes that.
11:27:52 <bd_> awesame: The >>= and >> operators have those semantics in IO.
11:27:55 <dolio> Oh, wait, you shouldn't even need that.
11:28:08 <bd_> awesame: Do you mean how it's implemented in GHC? There's more than one way to implement IO
11:28:27 <bd_> for the programmer, all that should matter is the semantics of the Monad operations
11:28:27 <awesame> yeah, I guess I'm wondering how it's implemented
11:28:34 <Deewiant> @src IO
11:28:34 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
11:28:45 <bd_> @src Monad IO
11:28:45 <lambdabot> Source not found. The more you drive -- the dumber you get.
11:28:49 <bd_> @src (>>=) IO
11:28:50 <lambdabot> Source not found.
11:28:55 <Deewiant> @src IO (>>=)
11:28:55 <awesame> I'm guessing that I can't write my own monads that completely sequence operations
11:28:55 <lambdabot> m >>= k     = bindIO m k
11:29:05 <bd_> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IOBase.html#IO
11:29:07 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2rxblz
11:29:11 <bd_> awesame: Not unless they're based on IO
11:29:17 <bd_> or depending on your needs, St
11:29:29 <geezusfreeek> nibro: i'm looking at your code pretty far out of context. what is it supposed to do and what is it actually doing?
11:29:39 <nibro> geezusfreeek: not surprised :)
11:30:03 <bd_> awesame: note that this is guts-of-the-compiler code in GHC-IOBase, it's obviously non-portable, and different compilers use different methods.
11:30:27 <nibro> geezusfreeek: I want it to fork off the loop and then continue with the code
11:30:54 <nibro> geezusfreeek: i.e. I want it to print both "start loop" and "forked"
11:30:58 <geezusfreeek> awesame: surely you could use seq to manually control the evaluation order of your own monad if you wanted
11:31:10 <nibro> geezusfreeek: it prints "start loop", but never reached "forked"
11:31:28 <bd_> geezusfreeek: seq doesn't prevent multiple evaluation, in theory
11:31:53 <bd_> also, that's horrible :P
11:31:54 <nibro> geezusfreeek: and it also never prints "watchDirectory returned"
11:31:58 <geezusfreeek> bd_: ah right, just because your can force evaluation on one thing doesn't mean you're preventing it elsewhere, n/m
11:32:26 <geezusfreeek> bd_: yes, it's horrible :P
11:32:28 <bd_> geezusfreeek: in particular, if the same thunk is forced by two threads at the same time, it may be fully (or partially!) evaluated twice
11:32:49 <geezusfreeek> nibro: hmm... that's odd
11:33:22 <awesame> so, with State
11:33:46 <geezusfreeek> nibro: what does watchDirectory do? i suppose it can hang?
11:34:13 <nibro> geezusfreeek: aye, watchDirectory waits on a directory until there are changes to be seen
11:34:16 <awesame> if I have some code that modifies the state, the monad guarantees that the "modification" will happen before any subsequently-sequenced access
11:34:34 <awesame> but sequenced accesses could occur out-of-order, right?
11:35:05 <nibro> geezusfreeek: hmm, I wasn't quite correct it seems
11:35:10 <bd_> awesame: what do you mean?
11:35:33 <dolio> I think state fully sequences operations.
11:35:47 <awesame> bd_: I'm just trying to trace how data dependencies would sequence operations
11:35:54 <nibro> geezusfreeek: it does print both "forked" and "watchDirectory returned", only I couldn't get watchDirectory to return before it seems
11:35:59 <bd_> awesame: look at the state implementation :)
11:36:19 <geezusfreeek> nibro: ah, so the problem is not concurrency
11:36:32 <bd_> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-State-Lazy.html
11:36:32 <nibro> geezusfreeek: but it won't print "start loop" again afterwards
11:36:33 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/6nnf3q
11:37:06 <nibro> geezusfreeek: and no, OneShot is not in evs
11:37:07 <awesame> the problem is that the implementations don't tell me what I need to know -- I'm simultaneously unsure which things are meant to be sequenced, and how any sequencing is accomplished
11:37:31 <dolio> It ends up like: 'let (a,s') = f s ; (b,s'') = f s' ; (c, s''') = f s'' ; ...'
11:37:38 <nibro> geezusfreeek: how come it doesn't print "forked" until after watchDirectory returns?
11:37:39 <bd_> awesame: Well, generally speaking, put x >> ... >> get will ensure the put occurs before the get
11:37:41 <awesame> so looking at the identity monad, for example, it wasn't clear to me that it wasn't somehow managing to sequence operations in a way I didn't understand
11:37:49 <geezusfreeek> nibro: perhaps it's just a problem with trace. i have never used trace, but perhaps it is getting optimized out?
11:37:59 <awesame> I understand how to use monads, but want a better understanding of how they work
11:38:04 <geezusfreeek> nibro: oh wait, it's printing it _after_?
11:38:12 <geezusfreeek> maybe a buffering issue
11:38:26 <nibro> geezusfreeek: hmm, but how come then it won't restart the loop?
11:39:12 <geezusfreeek> are you completley unable to get watchDirectory to work a second time?
11:39:53 <geezusfreeek> i'm just suspecting that if "start loop" doesn't print until after "watchDirectory returned" the first time that behavior may be repeating
11:40:17 <nibro> geezusfreeek: right, so the fact that it won't print the rest later on is due to buffering problems?
11:40:24 <geezusfreeek> maybe
11:40:30 <dons> cute http://reddit.com/info/6gacz/comments/
11:40:44 <geezusfreeek> trace is dodgy anyway, i would guess, since it relies of unsafe IO
11:41:44 <dons> "no threading (shared-memory concurrency is not supported by ocaml, in haskell it's buggy)" -- them's fighting words
11:42:17 <geezusfreeek> but, again, i have never used trace
11:42:38 <geezusfreeek> dons: something must have gone horribly wrong for him to think that
11:42:49 <dons> i'm sending him a mail.
11:43:53 <dons> gwern: btw, your cabalisation patches were rejected for fairly clear reasons, I thought.
11:43:54 <Deewiant> the original release was in 2006-12, maybe that was the state then and he hasn't updated the page (or his views)?
11:44:10 <dons> likely.
11:44:10 <bd_> awesame: the Identity monad is just a function, basically :) >>= is flip ($), with some newtype stuff to change the types
11:44:31 <dons> i'd be impressed if he really did find bugs in 2006 though
11:44:41 <dons> shared memory concurrency is one of the more heavily hammered bits of ghc
11:44:58 * dons ponders how many galois products rely on it
11:46:31 <monochrom> Why do the people imagine a vain thing?
11:47:35 <nibro> geezusfreeek: setting buffering to LineBuffering makes some of the traces come faster, so it seems buffering is (part of) the issue
11:47:57 <nibro> geezusfreeek: but the normal call to print I have in the callback never prints anything
11:48:26 <nibro>  callback = \event -> trace "callback: start" $ do
11:48:26 <nibro>             print event
11:48:26 <nibro>             trace "callback: done printing" $ return ()
11:48:33 <gwern> dons: yes, but I think they are fixable reasons
11:48:38 <dons> gwern: yeah
11:48:44 <gwern> he's carping over whitespace and patch organization
11:49:04 <dons> its an indicator of patch quality - not conflating multiple issues
11:49:14 <dons> so something good to avoid
11:49:16 <nibro> it says "callback: start" over and over again, but never "done printing"
11:49:28 <dons> a simple, 6.6-compatible cabal file might have a chance
11:50:31 <geezusfreeek> nibro: any reason event might take a while to evaluate?
11:50:34 * gwern supposes I will redo the work and try to organize it nicer in fresh patches
11:50:52 <gwern> dons: what was 6.8 specific about my darcs.cabal? I avoided section syntax
11:50:55 <dons> "the single golden patch" approach to contributing to new projects
11:51:17 <dons> try to inspre confidence in the existing members that you know exaclty what you're doing, and will follow their advice
11:51:40 <nibro> geezusfreeek: not that I can see, a single call to watchDirectory has it evaluated instantaneously, or near as I can see
11:51:58 <nibro> geezusfreeek: gotta run now, thanks for the help so far, I'll keep digging :-)
11:52:26 <geezusfreeek> nibro: define "evaluated" then, because binding it to e doesn't necessarily mean it is evaluated
11:52:41 <geezusfreeek> it just means the IO actions necessary to evaluate it are done
11:52:58 <nibro> geezusfreeek: if I only call watchDirectory and then print the result, it happens fast
11:53:04 <geezusfreeek> ah
11:53:09 <geezusfreeek> then i don't know :)
11:53:10 <mehrheit> @where parallel
11:53:10 <lambdabot> http://www.haskell.org/ghc/dist/current/docs/users_guide/lang-parallel.html
11:53:27 <gwern> (and actually, even using section syntax wouldn't make it 6.8 only - xmonad uses section syntax and works with 6.6 iirc)
11:53:45 <dons> no, its not quite like that.
11:53:52 <dons> xmonad uses cabal 1.2.x syntax
11:54:02 <dons> which means 6.6 users need first to update their cabal
11:54:11 <dons> i think this is what david was objecting to
11:54:43 <gwern> couldn't've been, as I said, I didn't use section syntax
11:55:09 <gwern> and afaik, 'tested-with' and 'build-type' fields are old ones too
11:55:18 <dons> did you test with 6.6 and its cabal, and 6.8 with its?
11:55:27 <dons> or does your 6.6 have an updated cabal?
11:55:50 <dons> since darcs is such a widely used sytsem, build changes are *extremely* sensitivie -- it can hurt a lot of extra deps are introduced, for example
11:55:57 <bogner> ï»¿hey dons, do you know where the yi-gtk and yi-vty darcs repos are these days? teh packages on hackage list you as maintainer, and the yi page on haskell.org doesn't mention them, yet building yi from darcs just gives me a library...
11:56:41 <gwern> dons: I don't have 6.6 installed; I found it too hard to have gentoo keep both installed
11:56:46 <dons> hmm, i'm not the maintainer, bogner
11:56:54 <dons> gwern: ok, that's problematic.
11:57:05 <dons> you could grab the 6.6 .tgz from haskell.org/ghc
11:57:06 <roconnor> > exp (exp (exp 0.5))
11:57:08 <lambdabot>  181.33130360854574
11:57:18 <dons> if you're trying to write portable build systems, this is key to having a good test environment
11:57:23 <gwern> bogner: it's just the one yi package these days
11:57:24 <gwern> bogner: it builds in vty/gtk support based on cabal flags, and you specify'em as CLI options
11:57:44 <wjt> > iterate exp 0.5
11:57:45 <lambdabot>  [0.5,1.6487212707001282,5.2003257647899614,181.33130360854574,5.638772246433...
11:59:34 <bogner> gwern: do you what the options are? i can't find anything that says how to specify them, and compiling yi is giving me no executable at all
12:00:50 <gwern> bogner: well, what is configure -v saying? if you're using darcs yi, you should be seeing something like 'Flags chosen: testing=True, hacking=False, cocoa=False, gtk=True, vty=False,
12:00:54 <gwern> shim=True
12:02:02 <Kewa1> version
12:04:44 <bogner> oh, nice, i didn't know about the -v option to configure. i'm used to non-haskell configure, which usually tells me all that when it finishes configuring
12:05:04 <roconnor> @spell rasterized
12:05:15 <gwern> I've honestly forgotten what non -v configure looks like; does it not say anything?
12:06:09 <gwern> roconnor: looks right to me
12:10:03 <roconnor> @spell disjuncts
12:10:17 <roconnor> Are the two parts of a disjunction the disjuncts?
12:10:27 <roconnor> or am I just making that up
12:11:28 <bogner> gwern: it says something to the effect of "configuring app..."
12:11:48 <bogner> gwern: thank you, yi works now!
12:14:18 <roconnor> @wn multivariate
12:14:20 <lambdabot> *** "multivariate" wn "WordNet (r) 2.0"
12:14:20 <lambdabot> multivariate
12:14:20 <lambdabot>      adj : pertaining to any procedure involving two or more variables
12:21:34 <roconnor> @wn pigeon
12:21:36 <lambdabot> *** "pigeon" wn "WordNet (r) 2.0"
12:21:36 <lambdabot> pigeon
12:21:36 <lambdabot>      n : wild and domesticated birds having a heavy body and short
12:21:36 <lambdabot>          legs
12:21:45 <roconnor> @wn pidgin
12:21:45 <lambdabot> *** "pidgin" wn "WordNet (r) 2.0"
12:21:45 <lambdabot> pidgin
12:21:45 <lambdabot>      n : an artificial language used for trade between speakers of
12:21:45 <lambdabot>          different languages
12:56:19 <wjt> hmm, is there a standard name for:
12:56:36 <wjt> flatten [] = []; flatten ((x,y):xys) = x:y:xys
12:57:44 <Heffalump> I doubt it, I'm not aware of any standard functions that operate on tuples like that.
12:57:59 <Heffalump> obviously concat . map (\(a, b) -> [a, b]) is one way of writing it
12:58:12 <Heffalump> oh, did you mean x:y:xys or x:y:flatten xys ?
12:58:17 <geezusfreeek> :t let flatten [] = []; flatten ((x,y):xys) = x:y:xys in flatten
12:58:18 <lambdabot>     Occurs check: cannot construct the infinite type: t = (t, t)
12:58:18 <lambdabot>       Expected type: [t]
12:58:18 <lambdabot>       Inferred type: [(t, t)]
12:58:31 * Heffalump realises it must have been the latter for the above reason
12:58:41 <Heffalump> @pl \(a, b) -> [a, b]
12:58:42 <lambdabot> uncurry ((. return) . (:))
12:58:49 <Heffalump> eww
12:59:30 <geezusfreeek> what is that supposed to be, some sort of an unzipper?
12:59:40 <wjt> oh yeah, obviously the version that type checks
13:00:12 <geezusfreeek> oh, not an unzipper
13:00:54 <geezusfreeek> do you mean for it to have type [(a, a)] -> [a]?
13:00:57 <wjt> yes, i do
13:01:20 <wjt> it's to find words which can be touch-typed symmetrically; that is, if you type a j it should be followed by an f
13:02:21 <wjt> so i find all permutations of zip rightHand leftHand then flatten it
13:02:21 <geezusfreeek> i know of no such standard function
13:02:35 <wjt> no, i can't see a nicer way to write it than directly
13:02:49 <Heffalump> "directly"?
13:03:06 * Heffalump thinks his way is nicer (and slightly shorter) than the direct recursion
13:03:25 <wjt> Heffalump: why?
13:03:55 <Heffalump> Well, it's just a matter of taste, obviously. But it's somewhat point-free in a reasonably natural way.
13:04:07 <geezusfreeek> wjt: i agree with Heffalump. his version is shorter and more natural to me
13:04:59 <wjt> hmm, true
13:05:59 <geezusfreeek> (and can be inlined if you only need it once)
13:13:03 <ski> @src concatMap
13:13:03 <lambdabot> concatMap f = foldr ((++) . f) []
13:14:48 <augustss> Hmmm, wonder why it's not 'concat . map f'
13:16:00 <wjt> i wondered this; apparently the foldr definition is fused better
13:16:44 <conal> doesn't speak well for fusion
13:18:09 <geezusfreeek> speaking of compiler optimizations, anybody know if there is a good writeup anywhere of the inner workings of JHC? the few tests i have tried with JHC in the past were blazing fast
13:18:34 <geezusfreeek> then again, i could just look at source
13:22:44 <tibbe> @unmtl State
13:22:45 <lambdabot> err: `State' is not applied to enough arguments, giving `/\A B. A -> (B, A)'
13:22:55 <tibbe> how does unmtl work?
13:23:45 <sjanssen> @unmtl State s a
13:23:46 <lambdabot> s -> (a, s)
13:24:09 <sjanssen> @unmtl StateT s (ReaderT r IO) a
13:24:09 <lambdabot> s -> r -> IO (a, s)
13:26:20 <opqdonut> huh?
13:26:34 <opqdonut> what does lambdabot mean with "iving `/\A B. A -> (B, A)'"
13:26:40 <opqdonut> ah, /\ is type-level lambda?
13:26:45 <sjanssen> opqdonut: yep
13:26:51 <opqdonut> ah, a capital lambda, right?
13:27:00 <sjanssen> correct
13:27:02 <opqdonut> :))
13:27:07 <Heffalump> @unmtl StateT s (StateT s a)
13:27:07 <lambdabot> err: `StateT s (StateT s a)' is not applied to enough arguments, giving `/\A. s -> s -> a (A, s, s)'
13:27:16 <Heffalump> @unmtl StateT s (StateT IO s a)
13:27:16 <lambdabot> err: `StateT s (IO -> s (a, IO))' is not applied to enough arguments.
13:27:34 <Heffalump> @unmtl StateT s (StateT s IO) a
13:27:34 <lambdabot> s -> s -> IO (a, s, s)
13:27:55 <sjanssen> (a, s, s) hee hee
13:32:57 <capiCrimm> anyone recommend a classic program to write that would help someone learn haskell?
13:34:44 <lament> Scheme? :)
13:35:10 <capiCrimm> lament, I was thinking something smaller. Plus I'd like to do it from scratch rather then follow a tutorial
13:35:24 <tromp> an SK reducer?
13:35:39 <lament> scheme is pretty small
13:35:49 <lament> just don't follow the tutorial
13:36:17 <capiCrimm> lament, I've implemented it before. I know. I just wanted something like 99 problems in lisp, but haskell oriented.
13:36:37 <tromp> you can do the Euler project...
13:36:50 <bugQ> I learned haskell by playing with simple functions, then data types, then type classes, then monads...
13:37:36 <shachaf> @wiki 99 Haskell exercises
13:37:36 <lambdabot> http://www.haskell.org/haskellwiki/99_Haskell_exercises
13:37:41 <capiCrimm> bugQ, on that note, does anyone know of the video's where they were explaining monads in math.
13:37:52 <capiCrimm> shachaf, but that's still lisp oriented. :p
13:38:03 <capiCrimm> tromp, what is an SK reducer, can't find anything about it.
13:38:26 <tromp> look for combinatory logic
13:38:50 <tromp> it's like the simplest universal language
13:38:59 <tromp> a cousin of lambda calculus
13:39:02 <lament> if you did scheme before, you don't really have to do a SK reducer :)
13:39:42 <lament> k = const
13:39:50 <lament> s x y z = (x z) (y z)
13:40:42 <capiCrimm> looks like a fun little simple project though. I think the Euler project looks like more fun though.
13:43:52 <lament> SK reducer ought to be a one-liner with parsec
13:44:39 <shachaf> capiCrimm: Project Euler might be fun (I've only done a bit of it, so far), but it's not very Haskell-oriented.
13:45:52 <capiCrimm> shachaf, it is mathy though, which means I can do a lot without having to worry about monads and such.
13:46:11 <shachaf> capiCrimm: I thought you wanted to learn Haskell? :-)
13:46:47 <lament> capiCrimm: oh, so you want a _practical_ project :)
13:46:51 <lament> write some kind of a game
13:46:56 <lament> with opengl
13:47:07 <shachaf> lament: I think capiCrimm just said the opposite?
13:47:14 <capiCrimm> lament, I'm pretty sure I'd run into side-effects fairly quick
13:47:36 <lament> capiCrimm: that's the challenging part of haskell programming...
13:47:52 <mokomull> You could always imeplement the standard BrainFuck interpereter :P
13:48:14 <geezusfreeek> mokomull: that is a little too easy though, in my opinion
13:48:35 <mokomull> True.  It's a start... I'm trying to use it as a crash course in state monad
13:48:43 <mokomull> and failing miserably.  I can't get anything to compile ><
13:48:53 <shachaf> mokomull: Write it without State first.
13:49:03 <shachaf> mokomull: Then convert it.
13:49:14 <geezusfreeek> i did mine with just a zipper
13:50:24 <mokomull> thing is, it's weird having the "memory" not be mutable ... I could make it simply a list, but then it's really really slow to change an element :P
13:50:41 <mokomull> and the [] characters seem to be a bit harder than the others to implement
13:50:52 <shachaf> mokomull: That's why geezusfreeek used a zipper. :-)
13:51:10 <dons> or use mutable state to represent mutable state
13:51:20 <mokomull> zipper?
13:51:30 <shachaf> dons: <mokomull> True.  It's a start... I'm trying to use it as a crash course in state monad
13:51:31 <dons> its a nice purely functional structure with a cursor
13:51:33 <mokomull> dons: that's what I'm trying, and monads are currently raping my mind.
13:51:50 <dons> ah ok. well, all that was formerly implicit is now explicit and laid bare.
13:52:03 <sjanssen> dons: you reply too quickly on reddit :)
13:52:05 <dons> the way of the monad is the way to understanding what imperative programming *is* :)
13:52:11 <Heffalump> Cale: you seem to have several defunct lambabot processes on code.haskell.org, btw
13:52:12 <lament> zipper seems by far the best choice
13:52:13 <dons> sjanssen: oh ?
13:52:18 <dons> heh
13:52:21 * dons wins this round
13:52:25 <lament> the numerical position of the memory pointer is not actually relevant
13:52:36 <Cale> @bot
13:52:36 <lambdabot> :)
13:52:40 <lament> so if you store the memory as an array and the pointer as an index into that array, you keep extra information that you don't actually need
13:52:45 <lament> with a zipper, you avoid taht
13:52:46 <Cale> Okay, I'll see about getting rid of the dead ones.
13:52:47 <Heffalump> there's a non-defunct one too
13:52:56 <lament> (of course you might need the numerical position for easier debugging)
13:53:02 <shachaf> Is cjb's Gobby server still up?
13:53:04 <geezusfreeek> dons: that makes a nice quote
13:53:16 <shachaf> It seems that it is.
13:53:33 <dons> geezusfreeek: thank you, i assign it to the public domain
13:53:39 <mokomull> so basically zipper splits a list into two chunks, the piece behind the pointer and the piece ahead of the pointer?
13:53:41 <sjanssen> dons: it's nice to learn about this bug -- I think I've hit it before but didn't realize it
13:53:41 <geezusfreeek> yay!
13:54:09 <shachaf> Which quote?
13:54:22 <dons> sjanssen: yeah, i'm glad to see people pushing on the Control.Parallel stuff
13:54:23 <shachaf> mokomull: Yes.
13:54:35 <shachaf> mokomull: Did you see SPJ's presentation with xmonad?
13:54:37 <dons> since we've always suspected there were suboptimal things
13:54:40 <geezusfreeek> mokomull: yes, where the head of one of the lists is the "current" element
13:55:21 <geezusfreeek> shachaf: the way of the monad is the way to understanding what imperative  programming *is*
13:55:22 <mokomull> SPJ?  I guess not, shachaf ... but I am currently running XMonad ... it's actually what's inspired me to get back into trying to understand this crap :P
13:55:32 <geezusfreeek> oops, that should have been in quotes
13:55:33 <Cale> Easier just to kill them all ;)
13:55:42 <shachaf> geezusfreeek: Oh.
13:55:46 <shachaf> @wiki Video presentations
13:55:51 <lambdabot> http://www.haskell.org/haskellwiki/Video_presentations
13:56:01 <shachaf> mokomull: You might want to watch it.
13:56:18 <mokomull> I shall.
13:56:19 <midfield> any windows ghc/haddock users out there?
13:56:37 <wolverian> hm, where the crap is Control.Parallel.Stragies on ubuntu hardy? :(
13:56:46 <wolverian> s/Stragies/Strategies/
13:57:02 <wolverian> ah. it doesn't have the package. hmm.
13:57:08 <mokomull> wolverian: I don't know, but Debian really cocked up quite a bit of the Haskell libs as far as I can tell ... they forgot to build libghc6-x11-dev with Xinerama, for one.
13:57:50 <wolverian> heh.
13:57:57 <dons> mokomull: oh hmm.
13:58:04 <wolverian> dammit, we're so close to release I'm pretty sure they won't want to sync it from debian... oh well, one can always try
13:58:27 <mokomull> which in turn made XMonad believe I had one huge screen, leaving a corner of an application in space that doesn't actually exist, since my screens are different heights.
13:58:39 <Heffalump> wolverian: it's probably in a different (.deb) package
13:59:25 <wolverian> Heffalump, different?
13:59:42 <Heffalump> libghc6-something-dev
13:59:58 <wolverian> on debian it's in libghc6-parallel-dev
14:00:00 <Heffalump> or is that what you meant by "it doesn't have the package"?
14:00:02 <Heffalump> ah, right.
14:00:02 <wolverian> on ubuntu, I can't find it.
14:00:05 <wolverian> right.
14:00:09 <wolverian> requesting a sync...
14:00:41 <midfield> or has anyone seen "The program haddock is required but it could not be found" even though i have haddock (vers 2.0.0.0)
14:01:00 <shachaf> midfield: Is it in your PATH?
14:01:57 <mokomull> wolverian: If the dependencies check out, you might get away with installing the Debian package manually.
14:02:08 <wolverian> mokomull, yar.
14:02:20 <midfield> i can type "haddock --version"
14:04:54 <midfield> the extra strange thing is i get this message for binary and tagsoup but not haddock itself.  when i do runhaskell Setup.lhs haddock on haddock, i get "Magic number mismatch" messages
14:05:54 <midfield> hmm, googling a bit maybe i should install haddock 0.8 instead.
14:06:26 <elliottt> you could try updating cabal
14:06:36 <elliottt> that fixed some odd haddock issues for me a while back :)
14:07:42 <gwern> the only problem I've had with haddock 2.0 is the problem with 'type' declarations and '-- ^' stuff
14:09:12 <elliottt> dcoutts: when you get a second, i've got a hackage question for you :)
14:17:03 <gwern> hm. are there any haskell compilers which support the -cpp option besides GHC?
14:17:57 <dons> they all support CPP
14:18:01 <dons> through various ways and means
14:18:50 <gwern> dons: I'm trying to figure out whether I want {-# OPTIONS -cpp #-}\n{-# OPTIONS_GHC -fglasgow-exts #-}' or just one OPTIONS_GHC
14:20:15 <dons> LANGUAGE CPP ?
14:21:12 <gwern> dons: oh no, we can't do that. because it'd break 6.6 and 6.4, y'see
14:21:59 <lament> heh @ david roundy
14:22:00 <lament> "Franchise
14:22:00 <lament> is made up of some pretty ugly code, with a small amount of pretty
14:22:03 <lament> beautiful code."
14:22:08 <midfield> downgrading to haddock 0.9 fixed it, thanks
14:22:50 <gwern> lament: yes, he's a barrelful of laughs
14:26:34 <xif> hello Haskell friends
14:26:35 <sjanssen> gwern: doesn't language: CPP in the .cabal file work?
14:27:04 <xif> I have just learned of Template Haskell and am much intrigued!
14:27:22 <sjanssen> gwern: IIRC, Cabal uses the correct flags no matter which GHC version is used
14:27:28 <Heffalump> xif: it's convenient if all else fails
14:27:45 <xif> Heffalump: "all else" usually being?
14:28:00 * Twey waves to xif.
14:28:00 <Heffalump> Language: CPPHS really should be added too
14:28:08 <Heffalump> xif: type classes of some form, I guess.
14:28:39 <xif> Twey: so you have come here as well
14:28:52 <xif> following my blazing trail, no doubt.
14:28:55 <sjanssen> Heffalump: I believe you activate that through build-tools
14:29:03 <xif> Heffalump: cool
14:29:07 <Twey> xif: Of course. *deadpan*
14:29:16 <xif> Twey: did you know Heffalump won ICFP?
14:29:37 <Twey> I didn't.
14:29:59 * Twey finds.
14:30:35 <xif> we're probably the only ones in the channel who haven't won some sort of an international tournament for geniuses, and/or attained a PhD at age 22.
14:31:00 <Twey> I'm aware :<
14:31:21 <TomMD> xif: Not so!
14:31:24 <Philippa> heh. I dropped out of my undergrad course at 24
14:32:03 * Twey dropped out of his 'high school' at age 18 :-\
14:32:03 <Toxaris> Everyone is allowed to use Haskell, as long as he or she holds multiple PhD degrees.
14:32:12 <TomMD> xif: I would really like to fight the image that #haskell is full of PhDs... at least until I have a PhD.
14:32:19 <Twey> Hahaha, TomMD
14:32:23 <Heffalump> sjanssen: why, though?
14:32:45 <xif> TomMD: which would be next week? ;)
14:32:50 <Twey> Toxaris: Dare I ask what happens if they don't?  :-P
14:33:05 <TomMD> xif: Alas, I am not even accepted to a University right now.
14:33:41 * Heffalump doesn't think a PhD is that big a deal. All it implies in itself is that you're moderately competent (probably) and managed to stick it out for n years.
14:34:03 <TomMD> Heffalump: The point to me is that I would have time to pursue my own research interests.
14:34:11 * quicksilver notes that one of the main GHC honchos is phd-less.
14:34:25 <dons> he just has a turing award ;)
14:34:28 <lament> Haskell is not just for PhDs. Certainly you can use Haskell if you have multiple Masters degrees and a special recommendation.
14:34:30 <dons> (well, should get one!)
14:34:32 <Heffalump> TomMD: oh, sure. I just meant in the sense of people feeling intimidated by #haskell being perhaps a bit full of them.
14:34:41 <TomMD> Ah, yes
14:34:48 <Toxaris> Twey: I tried to make a funny reference to Henry Fords: "Any customer can have a car painted any colour that he wants so long as it is black"
14:35:18 <xif> Heffalump: I hope I didn't embarrass you or anything
14:35:31 <xif> I still can't get over the fact people here actually won that tournament.
14:35:38 <Twey> Toxaris: I knew the quote, but completely missed the connection.  :-)
14:35:41 <Heffalump> xif: well, someone has to...
14:35:48 <Twey> Haha
14:35:54 <Twey> Heffalump: It's like the lottery
14:36:00 <Twey> Heffalump: It happens to someone else
14:36:04 <xif> except it has nothing to do with luck :)
14:36:10 <Twey> Yes.
14:36:12 <Heffalump> I think it is rather like the lottery, actually :-)
14:36:28 <Toxaris> xif: if it helps you, there are also a lot of people here who lost one or several icfp contests
14:36:37 <lament> icfp - the DNA thing?
14:36:40 <Heffalump> You need to be good programmers etc to get to a certain level in the tournament (say top-10 or so). Beyond that it's down to a lot of luck who actually wins.
14:37:01 <TomMD> I like ants... that is the one you won along with Ian, dcoutts and ?, right?
14:37:03 <Twey> Like job applications?  :-)
14:37:05 <xif> Toxaris: yeah, I bet many here barely could get past second place!
14:37:08 <Heffalump> Twey: and kosmikus, yes
14:37:30 <xif> Heffalump: how is it about luck, at any stage?
14:37:46 <xif> isn't it about the people who manage to find the best solutions?
14:38:08 <xif> (obviously, that requires some measure of unpredictable creativity)
14:38:12 <Heffalump> xif: precisely
14:38:15 <Toxaris> sure, and lottery is about people who manage to have the winning number
14:38:30 <TomMD> In the case of ants, it was about people who 1) found the fastest way to get off the ant hill 2) formed a perfect 'will never loose food from the ant pile' setup.
14:38:34 <xif> Heffalump: OK, but that's not luck in the common sense.
14:38:41 <Heffalump> and, IMO, a higher level of skill makes some difference to the probability of finding the match between problem and solution, but not a massive amount
14:38:45 <Heffalump> TomMD: right.
14:38:48 <xif> Heffalump: nobody says Niels Bohr is "lucky" for coming up with QM etc.
14:38:59 <Heffalump> TomMD: well, and how to collect food quickly in general
14:39:09 <Heffalump> I think that's the main reason we won, our ants were really really good at that.
14:39:23 <TomMD> Sure - not trying to minumise anything - but those two points I found to be unique compared to other groups I looked at.
14:39:40 <Heffalump> xif: That doesn't mean that there wasn't an element of luck that he succeeded where other equally "clever" people failed.
14:39:58 <Heffalump> TomMD: I'm not being defensive, just commenting on what I thought actually mattered.
14:40:11 <Heffalump> Protecting food was important, but quite easy and a lot of teams managed that.
14:40:30 <Heffalump> Getting off the hill we did really well (thanks to Igloo spending a lot of time and intelligence hand-coding it)
14:40:40 <Toxaris> xif: there is a different between real work and a three day contest. if you have a lot of time (like your whole live), your iq will show through. if you only have one weekend, it may be more about luck, I guess
14:40:48 <IsoPallo> The Slylandro in StarControl 2 were really good at collecting materials and that was not a good thing...
14:40:49 <Heffalump> and collecting food we did well due to a combination of luck and judgement
14:41:04 <xif> Heffalump: well, it's unpredictable to some degree. it's still very much affected by hard work and dedication. also, while not attaining first/second place doesn't mean you're a bad programmer, attaining 1st/2nd place does mean you're among the best programmers in the world.
14:41:05 <Toxaris> xif: but still, genius helps :)
14:41:08 <Heffalump> TomMD: yep, agreed.
14:41:09 <TomMD> I think that was the coolest challenge to hit ICFP.  I hope this years will rival the ants.
14:41:27 <Heffalump> TomMD: I doubt there will be one this year, given that the organisers haven't been announced yet.
14:41:30 <quicksilver> the lement of luck in anythign strongly time-limited.
14:41:31 <quicksilver> IMO.
14:41:40 <Heffalump> xif: agreed. (for some rather limited definition of "best programmers")
14:41:43 <quicksilver> if the contest had lasted, say, 2 weeks, then skill would have dominated.
14:42:00 <quicksilver> in such a short period of time though, luck plays a big role in "happening to spot the clever trick"
14:42:04 <quicksilver> (or indeed many tricks)
14:42:32 <quicksilver> none of which is intended as a criticism of the contest.
14:42:38 <TomMD> Oh No!  This is terrible news.  Ever since learning about the contest I had looked forward to seeing it each year.
14:42:43 <xif> quicksilver: I disagree. solving a problem quickly is a skill.
14:42:44 <Toxaris> does anyone knows anything about that no-contest-this-year thing?
14:42:58 <quicksilver> xif: I strongly disagree with that.
14:42:59 <Heffalump> I don't know anything, I just would guess that they don't have anyone to organise it.
14:43:12 <quicksilver> When solving a problem requires "spotting a trick"
14:43:14 <Heffalump> Since otherwise the webpage would say who is doing so.
14:43:20 <Toxaris> there was some talk on last-years mailing list lately wasn't there
14:43:20 <quicksilver> as many hard or interesting maths problems do
14:43:24 * Toxaris checks mail
14:43:37 <quicksilver> then I've seen excellent candidates happen to take longer to spot the trick
14:43:38 <Heffalump> quicksilver: ICFP contests vary between "spotting a trick" and "finding a good heuristic/algorithm"
14:43:44 <quicksilver> because they go down the wrong alley.
14:43:55 <quicksilver> Heffalump: yes, tehre are elements of both in every contest in fact
14:44:06 <quicksilver> Heffalump: my contention is that the 'spotting' part contributes a luck factor.
14:44:07 <Heffalump> I think ants was mostly the latter, whereas say two years ago was mostly the former.
14:44:13 <Heffalump> quicksilver: agreed.
14:44:20 <quicksilver> the algorithm part is mostly a skill factor
14:44:26 <Toxaris> Johan Jeuring on April 15th:
14:44:26 <Toxaris> "I've been informed that there will very likely be more information next week."
14:44:28 <Heffalump> But there is some luck in finding heuristics too
14:44:35 <quicksilver> (And experience, but who can distinguish skill from experience is a good scholar)
14:44:38 <Heffalump> Toxaris: oh, cool.
14:44:47 * Heffalump scales back his scepticism then
14:44:53 <quicksilver> Endo seemed to include a considerable 'spotting' part
14:44:58 <quicksilver> but I say that was someone who didn't compete
14:45:00 <quicksilver> merely observed
14:45:15 <Heffalump> yes, that seemed to be a treasure hunt mostly
14:45:24 <Heffalump> though someone did approach it as an optimisation problem and did very well
14:45:25 <quicksilver> The parcels one seemed to be heavily algortihm
14:45:31 <quicksilver> a few years ago
14:45:36 <Heffalump> yeah
14:45:37 <quicksilver> quite interesting, that one, I thought.
14:45:41 <Heffalump> as was the racing car one
14:47:07 <Heffalump> btw, I was part of a team that made enough of a balls-up of that contest that we got a special mention from John Hughes in his ICFP presentation :-)
14:47:28 <s7101> i have a problem compiling yi. does anybody know how to solve this problem? (hpasted)
14:47:46 <s7101> http://hpaste.org/7049
14:48:07 <dons> Heffalump: cool :)
14:48:34 <TomMD> Does anyone use named Datagram sockets to communicate between different (haskell) programs?  Maybe its just me.
14:48:57 <dons> hmm, i think Manuel might have, for some cluster stuff we did
14:49:12 <dons> roll-your-own-MPI
14:49:35 <dons> might be misremembering
14:50:19 <TomMD> I have a IPC library ("ipc" on hackage) which is quite basic for now.  I am trying to figure out where to go with it.  1) abandon it 2) Make tools that automagically generate SE-Linux policies based on the IVC 3) Flesh out the IVC to allow more operations / use cases.
14:50:43 <dons> hmm. 2) sounds fun-ish
14:50:56 <dons> 3) might benefit more people
14:51:43 <bos31337> IVC?
14:51:57 <TomMD> IPC, sorry.
14:52:25 <TomMD> Not that IVC isn't fun.
14:55:02 <bos> dons: does xmonad use a Writer monad anywhere?
14:55:26 <dons> no, just ReaderT ... (StateT ...
14:56:52 <bos> the hardest damn thing about this book is coming up with endless little examples.
14:57:33 <Heffalump> exercises are even harder to write than examples
14:57:49 <wjt> dcoutts: i remember you saying someone was working on a Haskelly portage replacement.  did it get anywhere?
14:59:05 <bos> Heffalump: yeah, but i've been ignoring those, so they're not bothering me :-)
15:00:19 <IsoPallo> Should I know Arrows? Or will I be happy everafter with Monads?
15:00:49 <IsoPallo> I spied Arrows a little and they seem to contain More Things :(
15:02:17 <monochrom> Thou shalt know thy Arrows.
15:02:48 <IsoPallo> Damn.
15:02:56 <IsoPallo> There is no helping it then.
15:03:04 * IsoPallo downloads papers
15:03:29 * Heffalump has tried to use Arrows several times when Monads failed him, and each time decided that they also failed him
15:03:43 <monochrom> As a transitional aid, note that "x -> m y" for monad m is a special case of "a x y" for arrow a.
15:04:38 <monochrom> Arrow is a generalization of function. You can now have side-effecting functions, like all your C and Java friends.
15:04:51 <quicksilver> as a more concrete aid, x -> [y] and x -> IO [y] are both quite interesting arrows.
15:05:11 <quicksilver> it's kind of 'studying concatmap-like computation'
15:05:24 <quicksilver> and 'concatMapM'
15:05:46 <monochrom> x -> IO [y] can be thought of as I/O-performing non-deterministic function.
15:06:24 <quicksilver> I gained quite an insight to arrows by playing with haxml, which doesn't actually use arrows by name.
15:06:32 <quicksilver> but the combinators it uses are very arrow like
15:06:36 <quicksilver> and it made me think.
15:06:41 <monochrom> Yes, x->[y].
15:06:52 <shapr> quicksilver: What did you think?
15:07:15 <monochrom> But note x->[y] is still restrictive, i.e., no I/O, no state, no this, no that...
15:07:15 <quicksilver> shapr: I thought 'Oh, I begin to see how arrows can be a useful building block of computation'
15:07:46 <monochrom> So HXT uses arrows in full glory. HXT arrows can do I/O and state.
15:07:50 <quicksilver> the wikibook page on arrows (unless it has changed) totally failed to motivate any arrow different from the basic function arrow.
15:08:04 <quicksilver> which left me wanting more! :)
15:08:22 <monochrom> @type hGetChar
15:08:22 <dancor> what's a list-like structure with fast appends and unterrible close-to-end random access
15:08:25 <lambdabot> Not in scope: `hGetChar'
15:08:31 <quicksilver> dancor: Sequence
15:08:48 <byorgey> dancor: Data.Sequence ?
15:09:18 <monochrom> @type System.IO.hGetChar
15:09:19 <lambdabot> GHC.IOBase.Handle -> IO Char
15:09:46 <monochrom> @type Kleisli System.IO.hGetChar
15:09:47 <lambdabot> Kleisli IO GHC.IOBase.Handle Char
15:09:53 <monochrom> Instant arrow!
15:09:58 <gwern> dancor: well, lazy bytestrings have fast appends, as do dlists. dunno about random access towards the end, but that sounds zipper like
15:10:44 <monochrom> > runKleisli (Kleisli System.IO.hGetChar >>> Kleisli putChar)
15:10:46 <lambdabot>   Not in scope: `System.IO.hGetChar'
15:10:46 * bos tries to concoct a small monad transformer example that needs explicit use of lift
15:10:55 <monochrom> @type runKleisli (Kleisli System.IO.hGetChar >>> Kleisli putChar)
15:10:56 <lambdabot> GHC.IOBase.Handle -> IO ()
15:11:06 <quicksilver> bos: ReaderT (State s) ?
15:11:16 <bos> the problem with mtl, from this perspective, is that every monad and transformer is an instance of every class.
15:11:16 <quicksilver> bos: lift get to get at the stuate, lift put to put it.
15:11:29 <quicksilver> bos: well you don't need lift if you're using the class tricks
15:11:32 <quicksilver> unless you double up
15:11:37 <quicksilver> ReaderT a (Reader b)
15:11:40 <bos> exactly :-(
15:11:51 <quicksilver> I would motivate it the other way round
15:11:56 <quicksilver> we'd use lift if we didn't have the classes
15:12:05 <quicksilver> then explain that the classes mean you normally don't
15:12:06 <bos> and stacking transformers like that, while valid and reasonable, make the poor reader head explode messily.
15:12:06 <gwern> 'The original green card became a yellow card when the System/370 was introduced, and later a yellow booklet. An anecdote from IBM refers to a scene that took place in a programmers' terminal room at Yorktown in 1978. A luser overheard one of the programmers ask another âDo you have a green card?â The other grunted and passed the first a thick yellow booklet. At this point the luser turned a delicate shade of olive and rapidly left the room, never ...
15:12:15 <gwern> ... to return.'
15:12:17 <bos> quicksilver: yeah
15:12:52 <monochrom> And the poor Reader head explode, too. :)
15:14:40 <dancor> is it easy to stop a Sequence from growing over a certain size
15:14:48 <dancor> maybe i want more like a bounded queue
15:15:19 <quicksilver> dancor: sequences are a reasonable way to implement bounded queues.
15:15:27 <quicksilver> dancor: I use them that way in several programs.
15:16:03 <dancor> and you just do the O(log n) drop on every add once they hit the max size?
15:16:15 <quicksilver> bos: it may also be worth pointing out you can instantiate the classes in other ways
15:16:25 <quicksilver> dancor: Yes. because I believe that O(log n) = O(1)
15:16:27 <quicksilver> for suitable n.
15:16:31 <dancor> heh yes
15:16:53 <quicksilver> bos: like you can newtype ReaderT a Reader b and make it an instance of MonadReader (a,b)
15:16:59 <quicksilver> bos: which is nicer than messing with lifts :)
15:17:13 <quicksilver> bos: I was talking about this to paolino earlier today.
15:17:21 <quicksilver> but maybe that's TMI.
15:19:37 <dancor> quicksilver: oh, look it actually is O(1) if you are just dropping one element
15:20:10 <dancor> (i think)
15:21:43 <quicksilver> dancor: it might be. it's pretty clever.
15:21:54 <quicksilver> dancor: I always forget how clever fingertrees are :)
15:26:59 <quicksilver> :t signum
15:27:00 <lambdabot> forall a. (Num a) => a -> a
15:27:06 <quicksilver> what's standard C for signum?
15:29:49 <monochrom> I think there is none.
15:30:45 <quicksilver> how strange.
15:52:43 * byorgey hands out lambda-shaped bowls of polenta
15:53:19 * IsoPallo eats with fingers
15:54:13 * IsoPallo looks for the grappa
16:04:41 <dons> gwern: good work on the darcs patch
16:04:52 <dons> gwern: is the segfault gone now? (was its origin determined?)
16:05:36 <chessguy_> @seen byorgey
16:05:37 <lambdabot> byorgey is in ##logic, #xmonad, #haskell-blah and #haskell. I last heard byorgey speak 5m 11s ago.
16:05:56 <byorgey> hey chessguy_
16:06:16 <chessguy> hiya byorgey. great blog entries the other day
16:06:21 <byorgey> thanks =)
16:06:33 <chessguy> seems like a really interesting idea
16:06:57 <chessguy> i was wondering about using that kind of model for cases where you don't even really know for sure what you're looking for
16:07:51 <byorgey> chessguy: sorry, I actually have to go right now, but I'd love to talk about it with you later!
16:08:04 <chessguy> byorgey, cool beans. we'll catch up sometime
16:08:10 <byorgey> ok, sounds good =)
16:17:40 <TomMD> > unwords . map (\x -> if x == "have" then "don't have" else x) . words $ "You have packet loss"
16:17:51 <lambdabot>  "You don't have packet loss"
16:21:12 <saml> > [x | x <- []]
16:21:13 <lambdabot>  []
16:21:25 <saml> > [(x,1) | x <- []]
16:21:26 <lambdabot>  []
16:29:32 <DRMacIver> Any idea why I'd be getting this error trying to build Data.Derive? http://hpaste.org/7051
16:29:48 <DRMacIver> As far as I can tell containers is not hidden and works fine elsewhere...
16:35:22 <chessguy__> @pl \x -> if x == "have" then "don't have" else x
16:35:22 <lambdabot> flip if' "don't have" =<< ("have" ==)
16:35:29 <DRMacIver> Sigh.
16:35:40 * DRMacIver pulled out some old code from a while ago to use in a simple task
16:35:54 <DRMacIver> And either it's totally bitrotted or my GHC install is completely fucked
16:38:29 <elliottt> DRMacIver: this is ndm's derive package?
16:38:33 <DRMacIver> Yeah
16:38:50 <DRMacIver> It's not the only problem I'm having though. I'm also getting bizarre dependency issues with bytestring.
16:39:04 <elliottt> bizarre how?
16:40:51 <DRMacIver> http://hpaste.org/7052
16:41:04 <gwern> dons: as I said, I think the segfault was in the old definition of wfindPS. I didn't track it down any further than the last two lines, but I suspect there was a missing null pointer check
16:41:15 <elliottt> ah, did you update bytestring?
16:41:28 <DRMacIver> Yes
16:41:29 <dons> and its gone now, gwern ?
16:41:38 <elliottt> ok.  you'll have to recompile all the things that use it
16:42:14 <DRMacIver> I thought I had.
16:42:18 <elliottt> hrm
16:42:21 <DRMacIver> Oh. Except Data.Derive. *headsmack*
16:42:32 <elliottt> :)
16:42:43 <DRMacIver> ok. Back to the previous problem... :)
16:42:58 <elliottt> ok, so that claimed that containers was hidden
16:43:02 <DRMacIver> Yeah
16:43:52 <elliottt> http://www.cs.york.ac.uk/fp/darcs/derive/derive.cabal
16:44:12 <elliottt> i'd imagine you're using ghc-6.8
16:44:30 <DRMacIver> Yep
16:45:32 <elliottt> did you try cleaning, and re configuring?
16:45:35 <DRMacIver> Yep
16:45:45 <elliottt> goodness.  i'm not entirely sure then :)
16:46:10 <DRMacIver> Hm. The darcs version of Data.Derive appears to compile
16:46:13 <DRMacIver> I'll just use that
16:46:17 <elliottt> oh weird
16:46:18 <elliottt> ok then :)
16:46:24 <gwern> dons: so far as I've seen. it's not reappeared, and no one else has reported it
16:46:32 <DRMacIver> Thanks for your help. :)
16:46:37 <elliottt> hehe, sure :)
16:46:52 <gwern> although darcs darcs just switched to default bytestring, so it should get some more testing soon
16:47:06 <DRMacIver> Hm
16:47:09 <DRMacIver> Same problem.
16:47:10 <elliottt> how strange, version 0.1.1 in  hackage looks exactly the same
16:47:35 <DRMacIver> i.e. same bytestring dependency issues
16:47:41 <elliottt> ah, ok
16:48:06 <elliottt> what's at line 104 in Dependencies.hs?
16:48:54 <DRMacIver> http://hpaste.org/7053
16:49:02 <DRMacIver> 104 in the file is the start of the binary instance for JUTF8
16:49:28 <elliottt> ah, did you rebuild binary?
16:49:34 <DRMacIver> Yes
16:49:39 <elliottt> how odd.
16:49:40 <DRMacIver> I'll try again though
16:50:08 <elliottt> my solution when i had this same problem was to rollback to my old version of bytestring :)
16:50:37 <DRMacIver> I'm not actually sure how to do that.
16:50:53 <elliottt> i think you're far enough into the process now that you should see it out
16:50:53 <DRMacIver> I've had remarkably little luck in the past at telling ghc to fuck off and just uninstall the damn package. :)
16:50:59 <elliottt> hehe
16:51:22 <DRMacIver> Ok. I've just rebuild Binary. Again. Same error. :)
16:52:42 <dons> do you only have one version of bytestring installed now?
16:52:46 <DRMacIver> I have two.
16:52:54 <dons> that's probably not good
16:52:54 <DRMacIver> 0.9.1 and 0.9.4
16:53:05 <DRMacIver> err
16:53:14 <dons> the error is to do with libs compiled against 0.9.0.1 , then linking later things with 0.9.0.4
16:53:21 <dons> the 'merge' of symbols
16:53:36 <dons> you'll need to ensure all  libs are compiled with either one or the other bytestrings
16:53:44 <DRMacIver> Yes, I realise that. But I've recompiled everything I can think of that would depend on 0.9.0.1
16:54:04 <dons> unless you unregister 0.9.0.1 though, its hard to enforce that
16:54:10 <dons> and unregister libs inbetween
16:54:26 <dons> so what is your current error?
16:54:34 <elliottt> same one in the first paste
16:54:46 <dons> which mentions 0.9.0.1?
16:54:50 <elliottt> yeah
16:54:58 <elliottt> Couldn't match expected type `bytestring-0.9.0.1:Data.ByteString.Lazy.Internal.ByteString'
16:55:09 <dons> so something's still compiled against the wrong thing.
16:55:10 <elliottt> against inferred type `ByteString'
16:55:12 <dons> binary perhaps?
16:55:17 <elliottt> tried that
16:55:24 <elliottt> no luck :/
16:55:28 <DRMacIver> I've recompiled binary. I'll unregister the old bytestring and recompile again.
16:55:39 <dons> ghc-pkg list
16:55:47 <dons> to ensure you've the right things available
16:56:44 <DRMacIver> Never mind, found the problem.
16:56:53 <elliottt> ah, what was it?
16:56:55 <DRMacIver> I had some user local packages installed it seems.
16:57:03 <elliottt> ah ha
16:57:09 <DRMacIver> And it was looking at those, which hadn't been recompiled, in preference to the system ones which had.
16:57:11 <dons> --user things, yes.
16:57:45 <DRMacIver> Thanks dons. Making me look at ghc-pkg again is what made me notice that. :)
16:58:30 <dons> cool
17:51:02 <EvilTerran> good evening
17:53:22 <ivanm> good morning ;-)
17:53:35 <EvilTerran> well, yes
18:02:15 <solrize> does every module name have to start with an upper case letter, and if i import it then the filename has to start the same way?
18:02:27 <mokomull> hmm... I wasn't expecting that video presentation to be the couple hours that it is :X
18:03:13 <mokomull> solrize: I'm new at this, but I haven't seen any that weren't that way, so I'd personally stick to convention anyway
18:04:11 <solrize> thanks
18:04:24 <Cale> mokomull: Which video were you watching?
18:04:43 <mokomull> The OSCON video of SPJ.
18:05:03 <Cale> solrize: yes, they must be capitalised.
18:05:11 <solrize> thanks cale
18:05:43 <Cale> The filenames aren't strictly required to be the same, but it makes your life easier if they are, because GHC will be able to find them automatically.
18:05:58 <Cale> (otherwise, you'll have to specify all the files on the commandline)
18:06:23 <mokomull> That's rather nice, compared to Java, which won't compile a class which doesn't match the filename.
18:07:14 <EvilTerran> especially as the module defaults to being called Main
18:07:50 <EvilTerran> so, if the right naming were enforced, you'd need to put explicit module declerations on all (but one) of the .hs files in a directory, which'd be kinda tedious
18:08:04 <EvilTerran> ... and, on reflection, is exectly what java does. as i said, "kinda tedious". :P
18:09:49 <TomMD> andyjgill: Do you know which courses (if any) you'll be teaching?
18:15:42 <andyjgill> Not officially, but I'm expecting an advanced FP class in the first semester.
18:34:46 <solrize> is there a way to pull a value out of a constructor expression without pattern matching it with a let or something like that?  I.e. I have  newtype A = A Integer   and I want to get the integer out.
18:35:14 <solrize> I could use a data declaration with a record name etc. but that means more cruft, more namespace pollution etc.
18:37:15 <EvilTerran> that's how you have to do it
18:37:25 <EvilTerran> that or write an extractor function to do the same thing
18:37:55 <EvilTerran> newtype A = A { getA :: Integer } --or-- getA (A a) = a
18:38:35 <EvilTerran> or, if you really like CPS, runA f (A a) = f a
18:39:18 <solrize> hmm yeah too messy for this immediate thing, but that's an idiom i'll have to get to understand for other reasons.  thanks
18:39:48 <EvilTerran> it'd look nice infix, too... (+1) `runA` anA or whatever
18:40:10 <EvilTerran> i'd just go for the record syntax
18:40:34 <EvilTerran> it works for newtypes, too, so you don't need to switch to a data decl
18:41:05 <solrize> oh that's handy
18:41:47 <solrize> i had an access function already that pulled a value out of a map (assuming it was present).  i just rewrote it to lift the result into a monad so I can use Maybe when I'm not sure the value is there.
18:41:52 <solrize> that got around this problem
18:42:00 <EvilTerran> ?type \x -> case x of Nothing{} -> False; Just{} -> True -- here's another quirk of the record syntax
18:42:04 <lambdabot> forall t. Maybe t -> Bool
18:42:50 <solrize> :t mzero
18:42:51 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
18:43:08 <EvilTerran> you can use empty {}s on any constructor, not just those declared with record syntax. Just{} isn't *that* much nicer than (Just _), but it starts to make a real difference when the constructor has several parameters
18:43:33 <EvilTerran> ?type (\(,){} -> True) -- or is it really *any* constructor?
18:43:34 <lambdabot> forall t t1. (t, t1) -> Bool
18:43:39 <EvilTerran> awesome :D
18:43:57 <solrize> i'm not really grokking this, but that's ok
18:44:10 <EvilTerran> don't worry, it's not really relevant, it's just something i think is cool
18:44:31 * lispy just read droundy's email about Franchise.  I can't help but feel the ton is anti-Cabal.
18:44:55 <EvilTerran> Foo{} in a pattern basically means "Foo followed by the right number of _s to fully apply it", owing to a quirk of the report's definition of record syntax
18:45:04 <lispy> Especially when dcoutts_ replied that Cabal 2 will have the features that he feels are missing currently
18:45:23 * lispy is sad about the future of darcs and feels Franchise is a bad move
18:46:02 <ivanm> lispy: yeah...
18:49:19 <solrize> jArray (Object m) fieldname = do
18:49:19 <solrize>   Array x <- M.lookup fieldname m
18:49:19 <solrize>   return x
18:49:31 <solrize> is there  a better way to write that?
18:49:44 <Lycurgus> Franchise is a Cabal fork/alternative?
18:49:44 <solrize> M = Data.Map
18:50:37 <gwern> Lycurgus: alternative
18:50:54 <gwern> lispy: the tone is anti-cabal, definitely. doesn't he as much as say he expects it to be an un-cabal?
18:51:10 <gwern> how does Hugs support CPP, anyone know? doesn't seem to be a -cpp
18:51:41 * Lycurgus shakes head and mumbers about sw engineering dilletantes.
18:51:52 <Lycurgus> *mumbles
18:52:50 <gwern> Lycurgus: honestly, I'd worry about using something being written by a burnt-out dev; I'd worry more though if roundy were evangelizing it though, which he doesn't seem to be doing
18:52:51 <Lycurgus> get with the fucking progamme
18:53:17 <gwern> ok... so nhc has -cpp, but does yhc?
18:53:18 <Lycurgus> burnt-out dev?
18:53:46 <Lycurgus> what a world, what a world
18:54:37 <Lycurgus> nothing wrong with the form but the beings inside are skankifacted by their primitve social orders
18:55:14 <lispy> Yeah, I'm sad that his darcs2 announcement was more of a sabatouge(sp?)
18:55:33 <lispy> I mean, with the comments that people should switch and that it will be effectively unmaintained (at least by him) within a year
18:56:26 <lispy> But, yeah, I'm frustrated by this franchise vs. cabal crap
18:56:34 <gwern> eh, what's wrong with it is misapplication of effort; why is roundy working as a physicist and not a darcs dev? and so on. I don't want to denigrate his job, but I suspect long-term value-wise, the world would be better with his job and hobby being switched
18:56:59 <lispy> cabal is not perfect, I like to discourage foo-specific build/distribution tools, but supporting cabal is a compromise I'm quite willing to make if it gets more fricken haskellers involved in darcs.
18:57:31 <lispy> gwern: hehe
18:57:39 <gwern> lispy: with any luck, he'll amuse himself for a little while, feel better, and abandon it
18:58:14 <lispy> I'd never want to use Franchise because I'm now afraid once it meets his needs all development/maintanence will cease
18:58:22 <gwern> lispy: what's foo in your sentence? language or application?
18:58:30 <lispy> gwern: yes
18:58:49 <lispy> (logical or works in your second question to answer it)
18:59:40 * lispy shrugs
18:59:55 <lispy> I'm just sad that darcs is probably coming to and end
18:59:58 <gwern> lispy: going by logical or/and is funny the first time, dickish the second
19:00:14 <lispy> gwern: noted :)
19:00:33 <exe> Haha.
19:00:43 * exe hugs lispy 
19:00:43 <gwern> (not if I have anything to say about it)
19:00:55 <solrize> :t (do 3)
19:00:56 <lambdabot> forall (t :: * -> *) t1. (Num (t t1)) => t t1
19:01:01 <lispy> gwern: I'm tired and terse, but I'm not trying to be a jerk, so sorry if it come off as one today.
19:03:51 <lispy> Before I seriously offend anyone or otherwise damage my reputation, I'm going to take my tired, frustrated self and do something else.  G'night #haskell!
19:04:03 <gwern> night
19:09:43 <sjanssen> gwern: "the world would be better with his job and hobby being switched" -- maybe not the whole world, but Haskell hackers and darcs users in general would be happy :)
19:10:01 <sjanssen> gwern: I believe Cabal uses cpphs for Hugs
19:12:04 <gwern> sjanssen: that would make sense. I'm having a hard time figuring YHC out. the docs say just --cpp, but grepping through the yhc source I see stuff like '$(YHC) -cpp'
19:12:26 <sjanssen> Cabal has YHC support now?
19:13:29 <gwern> I remember one maintainer disdaining my patches because they broke on NHC, iirc, which would seem to imply yhc could handle cabal
19:13:52 <gwern> since yhc is supposed to be a fork of nhc no?
19:14:49 <sjanssen> it is a fork, but I still don't think Cabal has support for it
19:15:00 <sjanssen> or at least it didn't at one time
19:15:30 <SamB> they aren't forked anymore
19:15:34 <SamB> they are merged!
19:15:43 <gwern> eh?
19:15:56 <SamB> they are two different things, but part of the code is in common
19:17:30 <gwern> SamB: do you know whether YHC accepts '-cpp' and '--cpp'?
19:17:56 <SamB> not really
19:18:49 <gwern> phooey. so who on #haskell knows a lot about yhc/develops it?
19:19:10 <gwern> '_darcs/pristine/Make/Docs.hs:    -- note, must pass -cpp or droppings will be left behind' <-- hm
19:21:15 <gwern> @seen ndm
19:21:15 <lambdabot> I haven't seen ndm.
19:21:30 <solrize> :t MonadState
19:21:31 <lambdabot> Not in scope: data constructor `MonadState'
19:21:41 <solrize> :k MonadState
19:21:42 <lambdabot> Class `MonadState' used as a type
19:21:51 <solrize> :k Monad
19:21:52 <lambdabot> Class `Monad' used as a type
19:21:54 <solrize> err
19:22:47 <gwern> sjanssen: darcs changes says 'Add a Cabal file for Yhc, which can now build Yhc successfully'
19:22:50 <pjd_> solrize: types have kinds;  type classes just have methods
19:22:55 <gwern> so maybe
19:22:59 <gwern> YHC core is on hackage as well
19:23:07 <dobblego> :k []
19:23:08 <lambdabot> * -> *
19:23:09 <sjanssen> gwern: that isn't necessarily the same thing
19:23:11 <dobblego> :k [Int]
19:23:12 <lambdabot> *
19:23:18 <solrize> @src StateT
19:23:18 <lambdabot> Source not found. You type like i drive.
19:23:31 <gwern> sjanssen: no, but it's another reed of evidence in favor
19:23:33 <sjanssen> gwern: last I heard, YHC can't bootstrap itself
19:24:14 <gwern> it's more likely that a compiler which can be built with cabal would also support cabal than a compiler support cabal but shun being built with it. even ghc uses cabal for the libraries, at least
19:25:26 <sjanssen> you'd think so, but that's not necessarily true
19:25:46 <sjanssen> gwern: have you tried grep -i yhc `find` # in your Cabal repo? :P
19:26:17 <gwern> '_darcs/pristine/Distribution/Compiler.hs:knownCompilerFlavors = [GHC, NHC, YHC, Hugs, HBC, Helium, JHC]' <-- they forgot EHC
19:26:40 <sjanssen> that probably doesn't imply actual support
19:26:49 <ivanm> OK, apart from GHC and Hugs, do any of those actually _work_?
19:26:55 <sjanssen> esp. considering HBC and Helium . . .
19:27:00 <ivanm> and I thought helium was only a subset...
19:27:03 <sjanssen> ivanm: to varying degrees
19:27:13 <sjanssen> yhc works for many Haskell '98 programs
19:27:19 <ivanm> work == support full H98
19:27:21 <sjanssen> similar with nhc
19:27:35 <gwern> well, JHC can compile *some* stuff (but don't ask me what)
19:27:36 <ivanm> *nod* though nhc is only a bytecode compiler, right?
19:27:40 <ivanm> gwern: lol
19:27:54 <sjanssen> ivanm: even GHC and Hugs have small bits of incompatibilities with Haskell '98
19:28:02 <gwern> JHC has been known to make grown computers weep
19:28:24 <ivanm> sjanssen: true.... but how small are these bits?
19:28:30 <pjd_> they grow computers now?
19:28:30 <sjanssen> probably not much
19:28:41 <ivanm> pjd_: yes, biochips
19:34:10 * gwern decides that -cpp is a GHC-ism
19:34:25 <sjanssen> gwern: why are you trying to determine that?
19:35:40 <gwern> sjanssen: I'm replacing '{-# OPTIONS ' with '{-# OPTIONS_GHC', is why
19:36:43 <sjanssen> I'm surprised darcs doesn't run cpp over the entire code base
19:37:13 <sjanssen> way simpler just to set that in .cabal or your makefile rather than each source file
19:37:44 <gwern> sjanssen: that would break things
19:37:56 <gwern> as I discovered when I did infact set extensions: CPP at one point :)
19:38:04 <sjanssen> gwern: whoa, what?
19:38:20 <gwern> sjanssen: did you know that GHC/CPP will break multi-line string literals?
19:38:24 <sjanssen> ah yes
19:38:25 * gwern didn't
19:38:32 <sjanssen> darcs uses multi-line string literals?
19:38:37 <sjanssen> nobody uses those! :)
19:39:03 <gwern> and guess what, darcs generates a big fact multi-line string literal as the very first step in the make...
19:39:04 <gwern> *fat
19:40:19 * sjanssen sees it now
19:41:32 <ivanm> gwern: so is this the real reason why droundy is wanting to stop maintaining darcs? :p
19:42:53 <gwern> ivanm: actually, the problem is that if you run the tests, GHC crashes in the middle of type-checking some of the type witneeses, summoning the Great Old Ones from beyond the stars to ravage the world as was foretold long ago in a JFP paper!
19:43:12 <gwern> (he got tired of fighting them off and having his soul devoured every time he did some debugging)
19:44:23 <ivanm> gwern: pffffttt, is that all?
19:44:46 <ivanm> cthulhu shows up all the time at userfriendly.org, and _they_ don't seem to have any problems! :p
19:44:51 <gwern> ivanm: well, he's been maintaing darcs for, what, 8, 9 years now?
19:44:53 <eugman|college> Ok, so i think I have a basic I dea of how monads work. Can anyone give me a general description of how the writer or reader ones work?
19:44:57 <gwern> that's a lot of tentacle raping
19:45:26 <ivanm> heh
19:45:30 <ivanm> eugman|college: magic
19:45:31 <ivanm> ;-)
19:46:02 <sjanssen> eugman|college: what they do, or how they work?
19:47:24 <eugman|college> A bit of both, I'm going to need to figure out if i'm going to use either for my game
19:47:42 <sjanssen> gwern: is src/Context.hs the only file that uses string gaps?
19:48:56 <eugman|college> I understand how monads sort of wrap functions in order to create a linear order but i don't understand some of the fancier stuff yet
19:49:08 <gwern> sjanssen:
19:49:09 <gwern> yes
19:49:25 <gwern> sjanssen: I actually have a replacement for it to use a single large string
19:49:26 <sjanssen> gwern: so there doesn't really seem any good reason to use string gaps there
19:49:41 <sjanssen> nevermind, you've realized that then
19:49:47 <gwern> stringify, that is, not context
19:50:00 <gwern> (context is generated, obviously there's no reason to edit it)
19:50:15 <sjanssen> eugman|college: do you know State yet?  Reader is like state in that you can read some shared data, but different from state in that you can modify it
19:50:33 <gwern> well, it broke the cabal build, so I had to fix it
19:51:40 <sjanssen> @unmtl Reader r a
19:51:40 <lambdabot> r -> a
19:51:48 <sjanssen> @unmtl Writer w a
19:51:48 <lambdabot> (a, w)
19:52:42 <eugman|college> no, I guess I need to read about that
19:53:23 <sjanssen> you don't have to, I was just looking for a shortcut
19:54:07 <sjanssen> eugman|college: have you seen 'All About Monads'?  It has nice little demonstrations of State, Writer and Reader
19:54:33 <eugman|college> Sounds familiar, lemme look
20:00:22 <eugman|college> I don't know but i'll try to read all of it
20:03:18 <OceanSpray> I'd like to see some obfuscated Haskell code.
20:03:31 <ivanm> @go obfuscated haskell contest
20:03:33 <lambdabot> http://www.haskell.org/haskellwiki/Obfuscation
20:03:33 <lambdabot> Title: Obfuscation - HaskellWiki
20:04:12 <gwern> OceanSpray: obfuscated haskell code is kind of pointless. imperative low-level stateful code offers so much more scope
20:04:27 <gwern> I mean, just translate everything into pointless combinators and you're done
20:07:26 <Twey> Hm
20:07:35 <Twey> How does one write let as a lambda?
20:08:39 <gwern> Twey: rewrite all the nested lambdas to avoid name shadowing?
20:17:05 <solrize>          case n@(read yyyy :: Int) of ...              <--- not allowed?
20:17:19 <solrize> i.e. can't bind a variable in a case expression like that?
20:17:23 <Cale> solrize: right
20:17:34 <solrize> ok
20:17:38 <solrize> tx
20:18:38 <solrize> JO = (JBook . Object)       <--- not allowed?  (JBook and Object are both type constructors)
20:18:53 <solrize> I want JO x = JBook (Object x)
20:19:50 <solrize> oh i see, since it starts with an upper case letter it thinks it's a type
20:19:54 <solrize> but it's really a function
20:20:00 <solrize> doh :)
20:20:08 <lament> well, make up your mind, is it a type or a function? :)
20:20:36 <Twey> Eh?
20:20:37 <solrize> i think mkJO = JBook . Object   fixed it
20:20:39 <Cale> Or is it a type function? :)
20:20:41 <Twey> I think you can do that...
20:20:42 <Twey> Ah
20:20:42 <lament> type JO x = JBook (Object x)  -- it's a type!
20:20:44 <Twey> Haha
20:20:45 <solrize> but i'm not sure since i have other errors to fix
20:20:54 <solrize> lament hmm, i may do it that way
20:20:59 <Cale> solrize: yeah
20:21:10 <lament> solrize: you should. It is a type constructor.
20:21:13 <Cale> solrize: They're data constructors, not type constructors.
20:21:42 <solrize> oops, right
20:21:52 <solrize> anyway the type decl didn't work
20:22:36 <lament> did you try to type it as JBook . Object?
20:23:15 <solrize> no i went back to mkJO
20:23:52 <solrize> rj.hs:34:16:
20:23:52 <solrize>     Illegal operator `.' in type `JBook . Object'
20:23:52 <solrize>       (Use -XTypeOperators to allow operators in types)
20:24:00 <solrize> that's from type JO = JBook . Object
20:24:00 <solrize> heh
20:24:13 <lament> you can't really do that
20:24:22 <lament> type checking is done at compile time
20:24:25 <lament> but . is a function
20:24:31 <lament> its value will not be known until run time
20:24:36 <solrize> so what does -XTypeOperators end up doing?
20:24:47 <lament> fail, i suspect
20:24:55 <solrize> i'd think it could statically resolve a construction like that
20:25:05 <lament> how?
20:25:09 <solrize> anyways mkJO worked so i'll stay with it for now
20:25:17 <lament> it would have to keep a dictionary of "allowed functions"
20:25:26 <lament> "functions allowed at compile time"
20:25:29 <lament> in other words, macros
20:25:37 <solrize> i mean "type JO" so it's a type not a function
20:25:37 <povman> @pl maybe 0 id
20:25:37 <lambdabot> maybe 0 id
20:25:52 <solrize> i.e. in a type declaration it would know that . was operating on types
20:25:59 <solrize> data constructors
20:26:04 <lament> solrize: it doesn't matter what it operates on
20:26:05 <povman> :t (maybe 0 id)
20:26:10 <lambdabot> forall a. (Num a) => Maybe a -> a
20:26:14 <lament> the point is, (.) is a normal haskell function
20:26:20 <lament> and functions are not allowed in type definitions
20:26:23 <povman> @hoogle Maybe a -> a
20:26:25 <lambdabot> Data.Maybe.fromJust :: Maybe a -> a
20:26:25 <lambdabot> Data.Maybe.fromMaybe :: a -> Maybe a -> a
20:26:25 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
20:26:43 <Cale> You might be interested in Conal's  TypeCompose library.
20:26:47 <lament> so you have to do type JO x = JBook (Object x)
20:27:02 <solrize> well i tried that and it failed too
20:27:06 <solrize> :t maybe
20:27:07 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:27:23 <solrize> > maybe 3 (*2)
20:27:25 <lambdabot>  <Maybe Integer -> Integer>
20:27:34 <solrize> > maybe 3 (*2) 5
20:27:35 <lambdabot>   add an instance declaration for (Num (Maybe a))
20:27:38 <solrize> > maybe 3 (*2) (Just 5)
20:27:39 <lambdabot>  10
20:27:44 <solrize> > maybe 3 (*2) Nothing
20:27:44 <lambdabot>  3
20:27:59 <solrize> hey neat
20:28:07 <povman> it was fromJust that i was looking for
20:28:09 <solrize> i didn't know about that
20:28:09 <povman> *fromMaybe
20:28:16 <solrize> :t fromMaybe
20:28:17 <lambdabot> forall a. a -> Maybe a -> a
20:28:28 <povman> > fromMaybe 3 Nothing
20:28:30 <lament> solrize: why did it fail?
20:28:31 <lambdabot>  3
20:29:07 <solrize> rj.hs:34:0: Not in scope: data constructor `JO'
20:29:20 <solrize> oh wait
20:29:34 <solrize> rj.hs:34:19: Not in scope: type constructor or class `Object'
20:29:42 <solrize> Object is a data contstructor
20:30:00 <solrize> so that's a kind error, i guess
20:30:31 <lament> Object does not take an argument?
20:30:46 <solrize> yes, it takes an arg
20:30:55 <Cale> It's a namespace problem.
20:31:09 <Cale> If Object is a data constructor, then it doesn't belong in types :)
20:31:10 <solrize> it's part of a sum type
20:31:19 <lament> oh, right
20:31:35 <solrize> data JsonNode = Number a | Object (Map String JsonNode) | ...
20:31:35 <lament> Cale: which is silly
20:31:41 <Cale> hm?
20:31:53 <Cale> Yeah, the type here is JsonNode then :)
20:32:28 <solrize> right
20:33:34 <lament> sounds like a time to switch to agda :D
20:34:09 <Cale> uhh...
20:34:18 <lament> :D
20:34:20 <solrize> hehe
20:34:40 <lament> (i assume agda has no problems with using data constructors in type declarations?)
20:34:46 <Cale> I thought agda still distinguished between types and values.
20:35:53 <lament> but isn't a dependent type a type with a data constructor in it?
20:42:02 * Cale_ grumbles about the router...
20:42:38 <povman> oh noes - if I have data A a b = A (a -> b), and i have x = A id and y = x, is there any way of determining x == y?
20:42:46 <solrize> hmm is there a doc about how to use the debugger?
20:42:54 <Cale_> povman: no
20:43:00 <solrize> oh there it is
20:43:03 <povman> Cale_: n000000......
20:43:13 <solrize> http://www.haskell.org/ghc/dist/current/docs/users_guide/ghci-debugger.html
20:43:15 <lambdabot> Title: 3.5. The GHCi Debugger, http://tinyurl.com/2nxab2
20:43:27 <povman> but surely it points to the same bit of memory?
20:43:30 <Cale> povman: Functions are opaque, you can't test them for equality.
20:43:47 <Cale> povman: Not necessarily.
20:44:06 <Cale> povman: During garbage collection, for instance, they might point to different values.
20:44:17 <povman> gotcha.. alright i'll put identifiers in A and test with them
20:44:35 <povman> thxs
20:44:47 <Cale> Of course, if the domain is finite, you can test functions for equality.
20:45:01 <Cale> (supposing that they're assumed to be total functions)
20:45:32 <Cale> There are some other interesting domains which it's possible to test function equality over as well.
20:45:43 <Cale> For example, infinite sequences of booleans.
20:45:54 <povman> how?
20:46:17 <Cale> http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
20:46:19 <lambdabot> Title: Mathematics and Computation » Seemingly impossible functional programs, http://tinyurl.com/2umqwh
20:46:46 <Cale> The idea is that total functions of infinite sequences of booleans can only ever look at finitely many of the elements of the sequence.
20:46:59 <Cale> (you just don't know beforehand how many)
20:53:14 <povman> wow.
20:56:49 <solrize> how much decidability does that really need?
20:56:52 <povman> since this is a von neumann architecture i'm on, shouldn't it theoretically be possible to use the same technique to compare any functions ?
21:25:03 <solrize> @hoogle Bool -> Int
21:25:03 <lambdabot> Data.Time.Calendar.MonthDay.monthLength :: Bool -> Int -> Int
21:25:03 <lambdabot> Data.Time.Calendar.MonthDay.monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
21:25:36 <chris___> if i have a coordinate (x,y), how can i get that coordinate rotated by n, (x',y')?
21:26:10 <chris___> (counterclockwise or clockwise, doesn't matter)
21:26:14 <solrize> er, trigonometry?  complex  numbers?
21:26:21 <chris___> trig, i guess
21:26:46 <solrize> n = angle in radians?
21:27:04 <chris___> right!
21:27:14 <geezusfreeek> chris___: well, if you rotate about (x, y) then any rotation (of (x, y) will result in (x, y) :)
21:27:24 <andyjgill> evening room
21:27:33 <geezusfreeek> chris___: (what I mean is you also have to specify the center of rotation)
21:27:42 <Cale> More useful would be to rotate about (0,0)
21:28:02 <chris___> geezusfreeek: well 0,0
21:28:02 <chris___> right, cale
21:28:02 <Cale> http://en.wikipedia.org/wiki/Rotation_matrix
21:28:03 <solrize> :t atan2
21:28:11 <lambdabot> forall a. (RealFloat a) => a -> a -> a
21:28:40 <Cale> Essentially, you want to multiply by the matrix [cos t, -sin t; sin t, cos t]
21:28:42 <solrize> > sqrt (-3)
21:28:44 <lambdabot>  NaN
21:28:50 <geezusfreeek> a rotation matrix is certainly the most useful in combination with other transformations
21:28:51 <solrize> how do you write a complex number?
21:28:57 <solrize> that's the easiest way to do this in the plane
21:29:04 <Cale> > sqrt (-3) :: Complex Double
21:29:05 <lambdabot>  -0.0 :+ 1.7320508075688772
21:29:33 <geezusfreeek> :t (:+)
21:29:34 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
21:29:49 <chris___> well i guess i'll look for some info about what matrices are
21:29:57 <solrize> chris___ just a sec
21:31:00 <Cale> Well, if you'd just like a formula then, it'd be (x * cos t - y * sin t, x * sin t + y * cos t)
21:31:15 <Cale> t is the angle (in radians of course)
21:31:22 <solrize> > Complex x y * cis n
21:31:22 <lambdabot>   Not in scope: data constructor `Complex'
21:31:48 <solrize> how do you get the real and imag parts from a complex?
21:31:52 <Cale> If you want to rotate about another point, then first translate the plane such that this point is at the origin, apply the rotation, and then translate back.
21:32:18 <pjd_> @hoogle Complex a -> a
21:32:19 <lambdabot> No matches, try a more general search
21:32:29 <chris___> that makes sense, cale
21:32:34 <solrize> @hoogle Complex a -> (a, a)
21:32:35 <lambdabot> No matches, try a more general search
21:32:48 <Cale> > (x :+ y) * exp ((0:+1) * t)
21:32:48 <lambdabot>  Couldn't match expected type `Complex t'
21:33:12 <solrize> i think lambdabot hasn't imported complex?
21:33:18 <Cale> It has.
21:33:25 <Cale> It's just that x and y are not complex values.
21:33:27 <solrize> > 3 :+ 3
21:33:28 <lambdabot>  3.0 :+ 3.0
21:33:56 <solrize> > let (x,y) = (3,4) in (x :+ y) * cis(pi/4)
21:33:57 <lambdabot>  (-0.7071067811865474) :+ 4.949747468305833
21:34:16 <solrize> > let (x,y) = (3,3) in (x :+ y) * cis(pi/4)
21:34:17 <lambdabot>  1.2988742026376343e-16 :+ 4.242640687119285
21:34:38 <solrize> so i think that is the simplest way
21:35:10 <chris___> what's :+?
21:35:25 <solrize> > let (x,y) = (3,5) in (realPart z, imagParg z) where z = (x :+ y) * cis(pi/4)
21:35:25 <lambdabot>  Parse error at "where" (column 47)
21:35:37 <solrize> a :+ b     =   a + b*i
21:35:42 <solrize> i = sqrt(-1)
21:35:54 <chris___> i see
21:35:56 <solrize> it's just a way of writing complex numbers
21:36:01 <solrize> you're familiar with this?
21:36:07 <chris___> nope
21:36:12 <solrize> http://en.wikipedia.org/wiki/De Moivre's theorem
21:36:13 <lambdabot> Title: DE - Wikipedia, the free encyclopedia
21:36:21 <solrize> http://en.wikipedia.org/wiki/De_Moivre's_theorem
21:36:37 <solrize> sigh, try this one: http://en.wikipedia.org/wiki/De_Moivre%27s_formula
21:36:50 <solrize> the sigh was for me, taking those tries to get the url, i wasn't sighing at you :)
21:37:17 <solrize> is this for a class?  i guess if you're not familiar with complex arithmetic maybe it's better to do it with trigonometry
21:37:34 <davidL> :t cis
21:37:35 <lambdabot> forall a. (RealFloat a) => a -> Complex a
21:37:46 <chris___> indeed, i'd prefer trig
21:37:46 <solrize> cis x = cos x :+ sin x
21:37:49 <solrize> ok
21:37:53 <chris___> i'm messing about with drawing in opengl
21:37:59 <solrize> ic
21:38:02 <chris___> http://hpaste.org/7054
21:38:10 <solrize> hmm, opengl may let you put in transformation matrices directly
21:38:24 <chris___> i could use the opengl reotate function but i wanted to work on a list of coordinates
21:38:37 <solrize> that rotateS function looks about right
21:39:05 <chris___> it's sort of similar to the drawing section of SICP, which is supposed to demonstrate composition
21:39:06 <solrize> say you want to rotate the segment (0,1)
21:39:21 <solrize> it becomes (-sin n, cos n)
21:39:32 <solrize> and (1,0) becomes (cos n, -sin n)
21:40:02 <chris___> okay..
21:40:09 <solrize> wait did i get that wrong?
21:40:18 <solrize> oh rotate counterclockwise
21:40:34 <solrize> no it was right
21:40:36 <chris___> well the direction doesn't matter
21:40:41 <chris___> i'm just slow
21:42:00 <solrize> sorry, i'm slow too, it's been ages since i've done this
21:42:03 <chris___> well this rotateS function's giving me odd results.
21:42:46 <chris___> (0.5,0.0) rotated by 90.0 counterclockwise should be (0.5,0.0) but it's not producing that
21:43:23 <chris___> (it *should* be (0.5,0.0), right? i'm getting confused)
21:43:23 <solrize> anyway, try:  (x, y) -> (-x sin n + y cos n, x cos n - y sin n)
21:43:38 <solrize> 90.0 = pi/2
21:43:40 <solrize> so let's see
21:43:48 <chris___> -x sin n + y cos n
21:43:52 <chris___> i don't understand this expression
21:43:59 <chris___> where does the -x come in?
21:44:20 <solrize> say you're rotating the point (1,0)
21:44:24 <solrize> no wait
21:44:32 <solrize> say you're rotating (0,1)    where does it go?
21:44:57 <chris___> rotating by 90 cc, (1,0), i would expect
21:44:58 <solrize> do i have this completely wrong?  cale, help :).  maybe i have the axes mixed up
21:45:08 <chris___> whoops
21:45:12 <solrize> -1, 0
21:45:23 <chris___> (0,1) 90 cc.. yeah.. that
21:45:38 <solrize> so let's see
21:45:58 <Cale> Uh, of course, you should make the multiplication explicit when writing this in Haskell.
21:46:24 <solrize> > let (x,y,n) = (0,1,pi/2) in (-x*sin n + y*cos n, x*cos n - y*sin n)
21:46:25 <lambdabot>  (6.123031769111886e-17,-1.0)
21:46:32 <solrize> close enough for govt work :)
21:46:41 <chris___> well i sometimes i can't tell if it's haskell wizardry with the oddness of - or multiplication
21:46:48 <solrize> > let (x,y,n) = (0,0.5,pi/2) in (-x*sin n + y*cos n, x*cos n - y*sin n)
21:46:49 <lambdabot>  (3.061515884555943e-17,-0.5)
21:47:30 <solrize> say n is very small, like 0.01
21:47:36 <solrize> you want to rotate the point (1,0)
21:47:38 <solrize> where does it go?
21:47:47 <solrize> to somewhere slightly to the left and above where it started
21:47:58 <solrize> to the left -> you have to subtract something from the x component
21:48:08 <solrize> that's the -x sin n
21:48:14 <solrize> because sin n is small when n is small
21:48:30 <mar77a> sin n is bounded!
21:48:32 <chris___> okay
21:52:59 <chris___> http://img293.imageshack.us/img293/4793/screenshothelloworldfb7.png
21:53:01 <lambdabot> http://tinyurl.com/6n45wq
21:53:16 <chris___> the dot on the right is (0.5,0.0)
21:53:31 <chris___> the one on the left is *supposed to be* (0.5,0.0) rotated by 90 degrees
21:53:41 <solrize> can you put a third dot at 0,0 ?
21:53:45 <chris___> yeah
21:53:55 <solrize> and how do you know which is which?  can you make them different colours?
21:54:21 <chris___> ah, well i can tell. plus i added the (0.5,0.0) one first
21:54:29 <solrize> that's colours with a "u" because cale is here :)
21:54:38 <chris___> and me :P
21:54:44 <solrize> cool :)
21:54:52 <Twey> And me
21:54:55 <Twey> :-P
21:55:00 <solrize> blimey, we're being overrun :)
21:55:08 <chris___> http://img170.imageshack.us/img170/2392/screenshothelloworld1pp1.png
21:55:12 <chris___> a middle one!
21:55:13 <lambdabot> http://tinyurl.com/5fxd2t
21:55:18 <chris___> at (0.0,0.0)
21:55:32 <solrize> ok, let's see the code?
21:55:39 <Twey> Er, three dots?
21:56:03 <chris___> http://hpaste.org/7054#a1
21:56:27 <solrize> rotateS (90.0)
21:56:31 <solrize> that's 90 radians
21:56:47 <solrize> use pi/2
21:56:56 <chris___> oh
21:57:51 <chris___> k, pi/2 gives me a 180 degree rotation
21:58:04 <chris___> so do i have to provide rotateS with a ratio of pi?
21:58:12 <solrize> pi/2 = 90 degrees
21:58:20 <solrize> lemme look at that code again
21:58:36 <solrize> x radians = x * (180/pi) degrees
21:58:51 <Cale> chris___: radians measure angles as lengths along the circle whose radius is 1
21:59:38 <Cale> Since that circle has circumference 2pi, a half circle (180 degrees) is pi, and a quarter circle is pi/2
21:59:45 <solrize> can you put up the new picture chris?
22:00:06 <chris___> solrize: it's three dots in a row  â. . .â
22:00:31 <solrize> > sin (pi/2)
22:00:32 <lambdabot>  1.0
22:00:41 <chris___> cale: ohhh
22:01:29 <solrize> wait, you've rotated all three points
22:01:40 <solrize> no?
22:01:50 <chris___> oh, i hope not
22:01:53 * chris___ adds parentheses
22:01:55 <Cale> The cosine of an angle t gives the x-coordinate of the point on that circle which is obtained after travelling a distance t counterclockwise along the unit circle starting at the point (1,0)
22:02:08 <Cale> Similarly, the sine of t gives the y-coordinate of that point.
22:02:24 <chris___> solrize: no, i haven't
22:02:28 <solrize> ok
22:02:49 <solrize> paste the latest code?
22:03:10 <Twey> Wah what
22:03:27 <chris___> netsplit, young tueis
22:03:29 <chris___> solrize: http://hpaste.org/7054#a2
22:03:37 <Twey> Ah
22:04:05 <Twey> chris___: do lo jbobau ka'e tavla xu
22:04:17 <chris___> Cale: let me just draw everything you just said on paper
22:05:00 <chris___> twey: go'i .u'i
22:05:21 <solrize> let rotateS n (x,y) = (-x*sin n + y*cos n, x*cos n - y*sin n) in rotateS (pi/2) (0.5,0)
22:05:27 <solrize> > let rotateS n (x,y) = (-x*sin n + y*cos n, x*cos n - y*sin n) in rotateS (pi/2) (0.5,0)
22:05:27 <lambdabot>  (-0.5,3.061515884555943e-17)
22:05:40 <solrize> ok, i did something wrong :)
22:05:56 <Cale> That seems right.
22:06:17 <solrize> it should go to (0, 0.5)
22:06:25 <Cale> er, oh, right
22:06:36 <Cale> yes
22:06:57 <Cale> > let rotateS n (x,y) = (x*cos n - y*sin n, x*sin n + y*cos n) in rotateS (pi/2) (0.5,0)
22:06:57 <lambdabot>  (3.061515884555943e-17,0.5)
22:07:02 <Cale> there
22:07:08 <solrize> aha
22:07:09 <Cale> You had something strange there :)
22:07:41 <solrize> thx
22:08:00 <chris___> is 3.06...e-17 == 0.0 or am i exceptionally confused?
22:08:13 <solrize> yes, floating point roundoff :)
22:08:44 * chris___ tries it
22:11:27 <chris___> so.. circumference = pi * diameter, and the diameter is 2, then the circumference is pi*2
22:11:32 <chris___> right, haha. i've caught up, sort of
22:14:45 <solrize> bah, i finally got my very first "professonal" haskell program (i.e. one used for doing something at work) to run, and it's 2x slower than the python program it's supposed to replace
22:15:06 <chris___> blimey, i thought python was slow
22:15:33 <solrize> yeah, i think the python program spends most of its time in extension modules that are written in C
22:15:39 <chris___> ah, true
22:15:48 <shachaf> chris___: The program is slow, not the implementation (or the language). :-)
22:16:04 <shachaf> (Language implementation, I mean.)
22:16:19 <solrize> but, i think the haskell program is suffering badly from reading and writing large text files using ordinary strings instead of bytestrings
22:16:38 <solrize> so that's the next thing to fix
22:16:49 <solrize> i figured, get it to work, then optimize afterwards
22:17:24 <Rapiere> solrize: from some haskell learning, bytestring are nearly ten times faster than original string implementation
22:17:39 <solrize> yeah, i guess i should figure out how to use the profiler
22:17:41 <pjd_> chris___: Python is pretty good, as far as its class of language goes
22:17:47 <solrize> maybe i'm getting hosed by lazy evaluation
22:18:23 <solrize> also, i suspect this json module i'm using is pretty suboptimal speedwise
22:18:38 <chris___> pjd_: well i wasn't judging it as a language, just the speed of the popular implementations
22:19:05 <pjd_> chris___: right, i meant the implementation
22:19:13 <Twey> chris___: pjd_'s observation holds true on that count too
22:19:16 <solrize> python is reasonably fast compared with other scripting languages, but if you compare it to a reasonable lisp implementation, it's awful
22:19:39 <solrize> and the language itself is sort of a sugared lisp with extreme reflectiveness and dynamicness
22:19:39 <chris___> twey: that python is pretty good for its job?
22:19:39 <Twey> solrize: IME, SBCL is generally slower than CPython
22:19:54 <solrize> SBCL slower than cpython when you use the SBCL compiler??!!
22:20:02 <chris___> really?
22:20:19 <Twey> I did a pretty unprofessional benchmark, and it was
22:20:30 <solrize> my haskell code is really painful and full of type juggling boilerplate too, but that's because i don't know what i'm doing
22:20:53 <Twey> Wouldn't be highly surprised to find I was barking up the wrong tree, but that's what it seemed to show
22:21:01 <solrize> check the alioth shootout
22:21:02 <Twey> Open to better attempts :-P
22:21:27 <solrize> one thing about python, a lot of the C extensions are carefully tuned
22:21:32 <solrize> i don't get that impression for ghc
22:23:51 <solrize> the haskell code took almost no debugging though, every function took multiple rewrites to fix the type errors but then just worked
22:24:01 <Twey> solrize: http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=sbcl&lang2=python
22:24:04 <lambdabot> Title: Lisp SBCL benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Langua ..., http://tinyurl.com/5raapj
22:24:13 <Twey> Seems generally faster but pretty heavy on memory
22:25:26 <chris___> ..is SBCL on the left or the right?
22:25:54 <Twey> With Psyco it's pretty close, though: http://shootout.alioth.debian.org/gp4sandbox/benchmark.php?test=all&lang=psyco&lang2=sbcl
22:25:55 <lambdabot> Title: Python Psyco benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Extra!, http://tinyurl.com/5gyayv
22:26:39 <chris___> are the language at the top's results on the left?
22:26:56 <Twey> chris___: Not necessarily
22:27:12 <Twey> chris___: The top language's better results extend towards the left
22:27:18 <Twey> Sorry, the right
22:27:20 <chris___> :S
22:27:41 <Twey> The bottom language's better results (and therefore the top language's worse results) extend towards the left
22:28:36 <chris___> okay
22:28:56 <chris___> http://shootout.alioth.debian.org/gp4sandbox/benchmark.php?test=all&lang=psyco&lang2=ghc
22:28:56 <lambdabot> Title: Python Psyco benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Extra!, http://tinyurl.com/65u9zs
22:29:07 <chris___> presumably that one bar where python does well is an optimised C library
22:29:24 <solrize> oh man, GHC is a heck of a lot slower with profiling on
22:29:41 <pjd_> an important factor, of course, is SBCL type declarations
22:29:59 <chris___> indeed, i like that about sbcl and CL
22:30:10 <pjd_> a more apples-to-apples comparison would be Pyrex with equivalent type declarations
22:31:23 <solrize> what's CAF?
22:33:07 <pjd_> http://www.haskell.org/haskellwiki/Constant_applicative_form ?
22:33:07 <lambdabot> Title: Constant applicative form - HaskellWiki
22:33:13 <solrize> thanks
22:33:41 <solrize>  CAF                     Main                                                 288          25   0.2    0.0    48.9   63.4
22:34:13 <solrize> prog is apparently spending half its time and 63% of its mem allocation doing CAF
22:34:43 <bd_> solrize: pass -prof or -prof-all to GHC to get a more useful result
22:34:50 <bd_> or manually mark cost centers
22:35:04 <solrize>  ghc -prof -auto-all  -L/home/phr/hs rj.hs --make
22:35:10 <solrize> that's what i did, is that right?
22:35:38 <bd_> yeah, should be... what are you passing to +RTS?
22:35:42 <solrize> it doesn't recognize -prof-all
22:35:49 <bd_> er, -auto-all, oops
22:35:55 <solrize>  +RTS -p
22:36:12 <bd_> hmm
22:36:17 <bd_> try +RTA -Pa, I think
22:36:21 <bd_> iirc that was it
22:36:22 <solrize> trying again with -O2
22:36:37 <bd_> oh, yes, always optimize when profiling in haskell :)
22:36:59 <solrize> it's not compiling enough
22:38:22 <solrize> running
22:39:13 <solrize> oh forgot to run with those flags
22:40:33 <solrize>   parse                  Text.JSON                                            297     6379821   6.6   19.5    62.9   57.8
22:40:42 <solrize> json parser is the big culprit again
22:41:02 <solrize> json output is also slow
22:41:50 <solrize> so if i can figure out how to use the ffi and wrap CJson maybe this thing can fly
22:43:11 <solrize> anyway in some ways this is sort of a relief, the program reads in a bunch of json records, and slices and dices and writes out each one.  so if all the time is spent in the json module I don't have to be that careful in the slice and dice code
22:43:30 <newsham> ?seen augustss
22:43:30 <lambdabot> I saw augustss leaving #haskell 4h 51m 38s ago, and .
22:45:19 <solrize> maybe haskell suffers because it doesn't have a primitive string type like python and clean do.  even if i replace the i/o with bytestrings i'd have to use bytestrings pervasively in the data structures to not dissipate that advantage, right?
22:47:22 <newsham> solrize: got ffi?
22:47:27 <pjd_> solrize: a good string type is certainly a prerequisite for good string processing performance
22:47:48 <solrize> newsham ghc comes with an ffi, i've looked at its docs a little bit
22:48:02 <lament> does ghc actually store strings as lists of chars?
22:48:09 <lament> there's no optimization?
22:48:23 <newsham> where "chars" means 32bit integers
22:48:31 <lament> that's fine
22:48:34 <lament> the list part, though
22:49:40 <nornagon> lament: it depends, i think
22:49:48 <nornagon> ghc does a bunch of strictness analysis during compilation
22:51:05 <lament> and depending on the result, it might store them as actual strings?
22:51:10 <Cale> Uh, but really it does store them as linked lists of 32 bit wide chars :)
22:51:22 <solrize> there's no bytestring.lazy.lines ?
22:51:25 <Cale> Because otherwise polymorphic functions on lists wouldn't work on them :)
22:51:41 <lament> there's gotta be a way to optimize that at least sometimes
22:51:50 <Cale> Yeah, it's called Data.ByteString :)
22:51:57 <lament> like, putStrLn "hello world" clearly doesn't need a list of chars
22:52:11 <lament> (generated for the literal "hello world")
22:52:46 <lament> this channel gets so much convo about Data.ByteString
22:52:52 <lament> it's probably the most commonly mentioned module
22:53:15 <lament> everybody started using haskell for string processing? :)
22:53:17 <solrize> will Data.ByteString.readFile read the entire file strictly?
22:53:39 <lament> hee
22:53:57 * lament thinks of python and .xreadlines()
22:54:12 <Cale> solrize: yeah
22:54:23 <solrize> noooo i can't even ctrl-c it
22:54:29 <Cale> The lazy version of bytestring won't though
22:54:35 <lament> solrize: haha
22:54:36 <lament> trapped!
22:54:53 <lament> bytestrings can be lazy?
22:54:56 <solrize> but i can't extract lines from lazy bytestring
22:55:28 <lament> bytestring doesn't have a .readlines() analog?
22:55:29 <kfish> how about using listlike?
22:55:35 <kfish> @where listlike
22:55:35 <lambdabot> I know nothing about listlike.
22:55:41 <solrize> strict bytestrings have a lines function
22:55:44 <solrize> but lazy doesn't
22:56:06 <lament> can't be that difficult to add
22:56:09 <solrize> looks like jusg an oversight?
22:56:12 <solrize> just
22:56:20 <kfish> @where+ listlike http://software.complete.org/software/projects/show/listlike
22:56:20 <lambdabot> Done.
22:56:25 <solrize> that can't be, they must have had a reason for leaving it out
22:56:34 <newsham> utf8.hs has lines :: ByteString -> [ByteString]
22:56:38 <lament> it must be unpossible!
22:57:09 <Cale> Data.ByteString.Char8
22:57:21 <Cale> :t Data.ByteString.Char8.lines
22:57:28 <Cale> ...
22:57:33 <lambdabot> BSC.ByteString -> [BSC.ByteString]
22:57:37 <solrize> yeah but those are strict and the input file is huge
22:57:47 <Cale> :t Data.ByteString.Lazy.Char8.lines
22:57:48 <lambdabot> BSLC.ByteString -> [BSLC.ByteString]
22:58:08 <sjanssen> solrize: lines is strict?  I don't think that is true
22:58:26 <sjanssen> (not totally strict, at least)
22:58:28 <solrize> what i mean is there's a lines function in the strict bytestring module
22:58:34 <solrize> but i don't see one in the lazy bytestring module
22:58:44 <solrize> http://haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString-Lazy.html
22:58:45 <lambdabot> http://tinyurl.com/yspt37
22:58:50 <pjd_> lament: xreadlines was deprecated long ago, of course
22:59:04 <sjanssen> solrize: remember you need to use Data.ByteString.Lazy.Char8!
22:59:08 <solrize> but there's one in .char8
22:59:11 <solrize> aha, ok
22:59:40 <solrize> why can't the regular one split into lines?  anyway it's ok
23:00:11 <solrize> oh now i have to use toChunks to convert the individual lines to strict
23:00:13 <sjanssen> solrize: because line splitting works on sequences of characters, not sequences of bytes
23:00:14 <Cale> solrize: Because lines only make sense when your data is composed of characters :)
23:00:17 <lament> pjd_: that's just because readlines() does the same thing now.
23:00:24 <solrize> no readlines reads all the lines
23:00:29 <solrize> you're supposed to use the file iterator
23:00:33 <pjd_> lament: iter() does the same thing now
23:00:33 <solrize> for line in stdin: ...
23:00:38 <lament> oh, right
23:00:46 <lament> looks much nicer too :)
23:01:18 <lament> although it's a little "scripty" to assume that everybody wants to read a file by lines
23:04:48 <newsham> you dont need to read it by lines.
23:05:02 <newsham> you can iterate over bytes pretty easily
23:05:05 <solrize> hmm, seems to work, now to time it
23:05:25 <mokomull> man, my life would have been so much easier yesterday had I a) looked harder at Control.Monad.State instead of ST, and b) understood that the State type was how to transform it, not the actual state itself
23:06:10 <chris___> mokomull: here's something to chuckle about: http://chrisdone.com/stuff/javascript-state-monad.js.html
23:06:10 <Cale> The type State s a represents computations which manipulate a state of type s while producing a value of type a
23:06:11 <lambdabot> Title: State monad in Javascript
23:07:00 <mokomull> yes, I'm quite aware of that *now*
23:07:16 <Cale> Nicely done, but completely misses the point of the monad abstraction.
23:07:18 <mokomull> after I watched that long freaking presentation just to hear him explain the IO monad
23:07:40 <mokomull> and then it just clicked
23:07:45 <mokomull> I still don't understand wtf ST does yet
23:08:17 <chris___> cale: it gets worse: http://chrisdone.com/stuff/javascript-parser-monad.js.html
23:08:18 <lambdabot> Title: Parsec combinators (monads!) for Javascript
23:08:30 <Cale> oh, ST s a (ignore the s for now) is the type of computations which can manage a heap of mutable variables while producing a value of type a
23:08:43 <scook0> it's not that hard to understand what ST does
23:08:50 <scook0> but understanding *how* it does it is a bit more subtle
23:09:38 <solrize> using bytestring got just a slight speedup.  the basic problem here is that JSON.hs is a pig.
23:09:53 <Cale> Basically, in the ST monad, you get some primitives:  newSTRef :: a -> ST s (STRef s a),  readSTRef :: STRef s a -> ST s a,  writeSTRef :: STRef s a -> a -> ST s ()
23:10:23 <Cale> STRefs are essentially mutable cells in which values can be put and updated and read back.
23:10:32 <Cale> Further, there's a function:
23:10:47 <Cale> runST :: (forall s. ST s a) -> a
23:11:05 <Cale> which runs such an ST action, producing a pure result
23:11:25 <Cale> So you can do computations with arbitrary amounts of state, but no other effects, and at the end, get a pure result.
23:11:46 <chris___> Cale: in what way does it miss the point?
23:12:19 <pjd_> chris___: the monadic operations are all specialized
23:12:20 <Cale> chris___: Well, the way that things are designed there, it looks impossible to write code which would reliably work across all monads.
23:12:50 <Cale> chris___: For there to be any point in calling something a monad, you have to be able to write code which works in any monad.
23:12:51 <pjd_> chris___: it's not actually bindM, but bindState
23:12:52 <chris___> oh, yeah, i agree
23:13:02 <mokomull> I had been trying to figure out how to get around using STRef, thinking I was using something like State instead
23:13:07 <mokomull> Now I understand the difference.
23:13:55 <chris___> i'm not sure if javascript supports polymorphism, it was more of an exercise of how the computations are implemented
23:14:04 <Cale> yeah
23:14:20 <Cale> It looks like a decent implementation
23:14:38 <Cale> (otherwise)
23:15:23 <chris___> good fun
23:15:30 <Cale> You might be able to do some kind of dictionary passing sort of thing. OO languages tend to have trouble getting the sort of polymorphism which really makes monads easy to use though.
23:15:48 <Cale> It tends to be rather difficult to have dispatch on result type.
23:15:59 <Cale> (which you need for return)
23:16:09 <chris___> hm, yeah
23:16:39 <chris___> i'd never realised that
23:16:49 <chris___> it seems obvious with type inference in mind
23:17:08 <mokomull> so what is this s parameter of ST s a ?
23:17:35 <mokomull> is it more or less the states of everything I need it to be, somehow automagical?
23:17:38 <pjd_> Cale: i've always wondered about using polymorphic continuations for that
23:17:39 <Cale> mokomull: It's a trick to prevent the STRefs in one ST computation leaking out and breaking referential transparency.
23:18:20 <mokomull> so basically I should more or less ignore its existence, then
23:18:46 <Cale> mokomull: Since runST will only accept an ST computation which is completely polymorphic in the type parameter s, and since s is bound in the parameter type for the function, the result type 'a' can't contain an 's'
23:19:17 <Cale> and so runST (newSTRef 10) won't work, for example
23:19:34 <Cale> Because there's an s in the type of that STRef
23:19:49 <Cale> So you'll get an error about how the type variable is escaping.
23:19:56 <mokomull> interesting
23:20:27 <wadcom> hi
23:20:30 <Cale> hello
23:20:56 <mokomull> so the type s never is actually filled in by anything, then
23:20:59 <chris___> if your language supported generic functions, perhaps you could use that. e.g. (foo (return a)) where foo expects a specific type and thus can say what `return' is
23:21:06 <wadcom> is there a better way (higher order function?) to write the following:
23:21:09 <wadcom> do { x <- names; return $ map ("zzz" ++) x;}
23:21:23 <wadcom> Prelude> :t names
23:21:23 <wadcom> names :: IO [FilePath]
23:21:36 <Cale> mokomull: If you want, you can imagine that runST fills it in with an appropriate type of heap for storing the contents of your STRefs, but yeah, it's not really filled in.
23:21:47 <geezusfreeek> names >>= return . map ("zzz" ++)
23:22:04 <geezusfreeek> or return . map ("zzz" ++) =<< names
23:22:08 <Cale> fmap (map ("zzz" ++)) names
23:22:16 <vincenz> Hi Cale!
23:22:16 <geezusfreeek> err, even better :P
23:22:20 <wadcom> cale: yeah!
23:22:28 <Cale> vincenz: hello :)
23:22:33 <wadcom> that's what I was looking for :-)
23:22:34 <takamu> hello
23:22:42 <Cale> takamu: hi!
23:22:51 <mokomull> this makes a rather lot more sense now
23:22:54 <vincenz> Cale: Is our mvp part of the team this year?
23:23:08 <Cale> When is the contest?
23:23:15 <vincenz> Dunno, prolly july again
23:23:33 <Cale> Well, I can probably do it.
23:23:36 * sjanssen bets it is scheduled over his birthday for the third year in a row
23:24:52 <Cale> Heh, if it's another virtual machine game, it would be fun to create "Team Instantly Disqualified", where we put all our results on a public wiki.
23:26:56 <Cale> ooh! New BSG episode for me to download!
23:27:10 <chris___> BSG = ?
23:27:15 <solrize> icfp?
23:27:18 <Cale> Battlestar Galactica
23:27:19 <geezusfreeek> battlestar galactica?
23:27:32 <Cale> International(?) Conference for Functional Programming
23:27:44 <solrize> yeah i was wondering if you were discussing the icfp contest
23:28:17 <chris___> i've never actually seen BSG but randomly heard recently that it's a really high quality sci-fi
23:28:37 <Cale> chris___: Yes, I highly recommend it, even if you don't usually like scifi.
23:28:46 <geezusfreeek> chris___: from the beginning though!
23:29:14 <geezusfreeek> admittedly, i kind of got bored with it after a while, but now that i know they are actually planning an ending i might catch back up
23:29:17 <Cale> Yeah, watch the miniseries first, and then go through in order. There's lots of stuff which won't make any sense at all if you start in the middle :)
23:30:30 <chris___> oh, blimey. :p i have this problem where i discover a tv program and watch seasons back to back over a period of days and it starts infesting my mind and dreams. good fun
23:30:37 <Cale> chris___: heh
23:30:48 <geezusfreeek> chris___: or if you would rather try some quality scifi with a somewhat lower commitment (since there are very few episodes) then check out Firefly :)
23:31:09 <Cale> chris___: If I recall correctly, I watched the first 3 seasons of the US Office in a single 24 hour period.
23:31:34 <geezusfreeek> woahâ¦ that's too much comedy for me
23:31:35 <Cale> I miss Firefly.
23:31:43 <chris___> Cale: ahaha. brilliant. haven't seen the US one yet. i loved the UK Office and Extras, have you seen that?
23:31:53 <aFlag> why does :t (\x -> x x) gives me an error? Shouldn't the type (a -> b) -> b work for that?
23:31:54 <Cale> Yeah, I was sure to see the UK one first.
23:31:59 <geezusfreeek> yeah, Serenity didn't really give me much closure on Firefly
23:32:05 <chris___> i think i watched both Extras seasons  back to back in a couple days
23:32:07 <Cale> aFlag: nope :)
23:32:15 <Cale> aFlag: It would require an infinite type
23:32:31 <Cale> aFlag: and those aren't allowed simply because they're usually type errors
23:32:45 <Cale> aFlag: However, you can get the effect using a newtype wrapper.
23:33:34 <Cale> newtype Rec a = In { out :: Rec a -> a }
23:33:39 <Cale> y :: (a -> a) -> a
23:33:39 <Cale> y = \f -> (\x -> f (out x x)) (In (\x -> f (out x x)))
23:33:40 <geezusfreeek> i'm more curious about what a value of type (a -> b) -> b would look like
23:33:52 <Cale> const undefined
23:33:55 <geezusfreeek> s/value/function/
23:34:01 <geezusfreeek> Cale: cheating :P
23:34:07 <Cale> (\f -> f undefined)
23:34:13 <chris___> (\x -> x x) takes a function of type (\x -> x x) which takes a ...
23:34:32 <chris___> whoops
23:35:11 <chris___> x -> (x -> ... infinity)
23:35:15 <chris___> is this where the type system would get up to?
23:35:26 <geezusfreeek> one that still have that type after strict evaluation :P
23:35:45 <Cale> I think it's actually  ((... -> a) -> a) -> a
23:36:08 <sjanssen> > (\x -> x x)
23:36:10 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
23:36:10 <lambdabot>     Probab...
23:36:16 <Cale> yep
23:36:20 <chris___> ah, aye
23:36:22 <geezusfreeek> @djinn (a -> b) -> b
23:36:23 <lambdabot> -- f cannot be realized.
23:36:23 <chris___> i get it
23:36:24 <sjanssen> thank you, ghc!
23:37:40 <geezusfreeek> okay my tiredness is giving me a strange sense of humorâ¦ i think it's bedtime
23:37:43 <aFlag> hm, let me see. If I understand. First ghc assumes x :: a -> b. Then a has to be unified with a -> b, which is the type of x, so we have x :: (a -> b) -> b, but that a is not really that, we have unified that, so it's x :: ((a -> b) -> b -> b) -> b, and so on. Is that reasoning right?
23:37:44 <Cale> Yeah, so that newtype is a nice little trick to get around that problem.
23:38:20 <Cale> aFlag: basically, yeah, a = a -> b
23:38:32 <aFlag> right, got it
23:38:58 <chris___> i am so TaPL after SICP
23:39:04 <chris___> er, reading TaPL
23:39:19 <aFlag> printf uses a trick like that Rec newtype, right?
23:39:31 <Cale> Printf uses typeclass swindling.
23:40:01 <Cale> It's basically just really really polymorphic.
23:40:05 <geezusfreeek> chris___: good ideaâ¦ i bought TaPL not so long ago and it is even better than i expected
23:40:09 <aFlag> hm
23:40:26 <chris___> geezusfreeek: wow, really? how heavy on the math is it?
23:40:47 <Cale> The mathematics in it basically has no prerequisites.
23:40:59 <geezusfreeek> chris___: pretty heavy but it explains _everything_ for you
23:41:02 <Cale> It's formal logic, basically.
23:41:23 <chris___> sounds brilliant. did you get it from Amazon?
23:41:27 <geezusfreeek> yes
23:42:02 * geezusfreeek also has Advanced Topics in Types and Programming Languages on his reading queue
23:42:17 <Cale> I'll warn you that I found it a bit dry, but I think there's really nothing that anyone could do about that. Type theory just is a bit dry by nature.
23:42:21 <chris___> Â£30, not bad. *checks barnes and noble* (i can only buy things with Paypal)
23:42:27 <geezusfreeek> thumbed through itâ¦ looks less applied, but interesting
23:42:27 <Cale> (at least, that part of it)
23:42:41 <chris___> ah
23:42:47 <Cale> Hehe, I have a pirate ATTaPL.
23:43:05 <aFlag> I read like half of TaPL, it wasn't all that hard to follow
23:43:07 <geezusfreeek> i got the dead tree version
23:43:45 <chris___> indeed. i ordered SICP yesterday, should get here this week. i'm not into screen reading
23:43:59 <Cale> There's some really applied stuff in ATTaPL, it's just that practical programming languages haven't really caught up yet.
23:44:10 <geezusfreeek> sicp is something i think i could stand to have in paper form as well, come to think of it
23:44:15 <geezusfreeek> don't know if it's worth the money though
23:44:41 <geezusfreeek> Cale: well, i mean the book doesn't apply much, although the ideas are certainly applicable
23:44:55 <geezusfreeek> not as much as in TaPL, is all i mean
23:45:25 <Cale> hmm...
23:45:34 <Cale> Maybe :)
23:46:09 <Cale> I kind of ignored much of the ML implementations of things in TaPL.
23:46:29 <chris___> geezusfreeek: i think if one does all the exercises and lectures and really completes all of SICP instead of dabbling, then it's worth it. i'm really inspired by that guy who completed the whole of SICP in a year, recently.
23:46:55 <geezusfreeek> come to think of it i have ignored the implementations as well
23:47:15 <Cale> One of the early ML examples abused exceptions to needlessly break referential transparency and that kind of put me off of those bits :)
23:47:59 <geezusfreeek> chris___: i think i would lose patience with trying to go through _all_ of sicp just because i'd have to go through things i consider "obvious" to find the gems
23:48:16 <Cale> Watching the lectures is really fun though
23:48:27 <geezusfreeek> the music is especially entertaining ;)
23:48:33 <chris___> bach, right?
23:49:04 <chris___> jesu, joy of man's desiring :P
23:49:05 <geezusfreeek> chris___: i don't remember the tune right now, but i do recall thinking of bach at the time
23:49:12 <geezusfreeek> ah, yes
23:49:51 <Cale> One thing I really like about the lectures is how often the techniques they discuss translate into Haskell features.
23:50:13 <Cale> Also, the discussion of the open problems with lazy evaluation and side effects was amusing. :)
23:51:01 <geezusfreeek> it made me giggle, for sure
23:51:42 <Cale> But what struck me the most I think was just how much of that content has been completely ignored by popular programming.
23:51:42 <chris___> i like how theoretical and agnostic it is to the Latest Thing yet still feels very practical to me
23:52:12 <Cale> Especially the warnings about why OO might not be a good idea a lot of the time.
23:52:44 <chris___> indeed
23:52:56 <chris___> i liked the definition of an object as something with identity
23:53:16 <chris___> (as opposed to "an instance of a class"...)
23:53:22 <Cale> Indeed.
23:54:11 <Cale> It comes a lot closer to the original approach to OO
23:54:45 * Cale is off to watch BSG now :) I'll probably be back after :)
23:54:50 <chris___> bye bye
