00:00:16 <lispy> ?let (./) (a:as) (b:bs) = (a/b) : ((as .- map (*(a/b)) bs) ./ (b:bs)
00:00:16 <lambdabot>  Parse error
00:00:41 <Runaro> ?let (./) (a:as) (b:bs) = (a/b) : ((as .- map (* (a/b)) bs) ./ (b:bs))
00:00:41 <lambdabot> Defined.
00:00:49 <lispy> thanks
00:01:35 <lispy> > (1:repeat 0) ./ (1:(-1):(-1):repeat 0)
00:01:35 <lambdabot>  [1.0,1.0,2.0,3.0,5.0,8.0,13.0,21.0,34.0,55.0,89.0,144.0,233.0,377.0,610.0,98...
00:02:57 <Runaro> ?let p = (++ repeat 0)
00:02:58 <lambdabot> Defined.
00:03:06 <lispy> ?check \n -> n >= 0 ==> ((fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)) !! n) == ((1:repeat 0) ./ (1:(-1):(-1):repeat 0)) !! n)
00:03:06 <lambdabot> Unbalanced parentheses
00:03:11 <lispy> doh!
00:03:17 <Gilly> > (1:repeat 0) ./ ((1:-1:repeat 0) .* (1:0:-1:repeat 0))
00:03:18 <lambdabot>   Not in scope: data constructor `:-'
00:03:20 <Runaro> > [1] ./ [1,(-1),(-1)]
00:03:21 <lambdabot>  Exception: <local>:22:0-64: Non-exhaustive patterns in function ./
00:03:32 <Runaro> > p [1] ./ p [1,(-1),(-1)]
00:03:32 <lambdabot> Terminated
00:03:33 <Gilly> > (1:repeat 0) ./ ((1:(-1):repeat 0) .* (1:0:(-1):repeat 0))
00:03:33 <lambdabot>  Couldn't match expected type `Double'
00:03:44 <Runaro> > (p [1]) ./ (p [1,(-1),(-1)])
00:03:45 <lambdabot> Terminated
00:03:47 <Runaro> bah
00:04:10 <Runaro> ++ doesn't work the way I expected
00:04:16 <dejones> Cale: still awake?
00:04:25 <Cale> dejones: yep
00:04:43 <lispy> ?check \n -> n >= 0 ==> ((fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)) !! n) == ((1:repeat 0) ./ (1:(-1):(-1):repeat 0) !! n)
00:04:44 <lambdabot>  OK, passed 500 tests.
00:04:46 <Gilly> hrm, what's wrong with my syntax?
00:05:01 <lispy> There we have it folks.
00:05:03 <Cale> Runaro: oh, MR
00:05:24 <Cale> @undef
00:05:24 <lambdabot> Undefined.
00:05:33 <Cale> @let p x = x ++ repeat 0
00:05:34 <lambdabot> Defined.
00:05:58 <lispy> you stinker Cale, you just deleted my test case :)
00:06:03 <Runaro> > p [1] ./ p [1,(-1),(-1)]
00:06:04 <lambdabot> Terminated
00:06:07 <dejones> Cale: I finally read all of the P \= NP paper... heh.  So, the paper seems to really lack in that he didn't provide a proof for why more than a polynomial number of inputs must be examined for the knapsack problem, he simply provided some cases in which you might... instead of that for all cases, you must.
00:06:15 <lispy> ?check \n -> n >= 0 ==> ((fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)) !! n) == ((1:repeat 0) ./ (1:(-1):(-1):repeat 0) !! n)
00:06:15 <lambdabot>   Not in scope: `./'
00:06:38 <Cale> dejones: yeah
00:06:44 <dejones> Cale: Just wondering if I seem on track in the lack of evidence in the paper.  :)
00:06:55 <lispy> wait, someone wrote a reasonable P \= NP paper that was actually being considered?
00:07:02 <Cale> lispy: er, oops? :)
00:07:06 <Cale> lispy: no
00:07:25 <Cale> ?let (.-) = zipWith (-)
00:07:25 <lambdabot> Defined.
00:07:27 <Cale> ?let (.+) = zipWith (+)
00:07:28 <lambdabot> Defined.
00:07:31 <Cale> ?let (.*) (a:as) (b:bs) = a*b : ((map (*a) (0:bs)) .+ (map (*b) (0:as)) .+ ((0:as) .* (0:bs)))
00:07:32 <lambdabot> Defined.
00:07:35 <lispy> BTW, I don't mind about the undef, it's too bad we can't do more editing/viewing of the definitions though
00:07:36 <Cale> ?let (./) (a:as) (b:bs) = (a/b) : ((as .- map (* (a/b)) bs) ./ (b:bs))
00:07:36 <lambdabot> Defined.
00:07:39 <vincenz> Question about GHC: does it really compile data declarations into church encodings?
00:08:13 <Runaro> ?src (++)
00:08:13 <lambdabot> (++) []     ys = ys
00:08:13 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
00:08:25 <dejones> Cale: Well, I guess I can go ahead and solve P /= NP now since that guy didn't.  ;)
00:08:28 <Runaro> ?src repeat
00:08:29 <lambdabot> repeat x = xs where xs = x : xs
00:08:42 <lispy> My hunch is that P = NP but in such a way that it's impractical and doesn't advance the theory
00:09:01 <Cale> Runaro: The ++ in lambdabot isn't the one in the prelude though, it's a more general thing.
00:09:25 <Runaro> alright then
00:09:26 <povman> @pl (\x -> map ($ x))
00:09:26 <lambdabot> map . flip id
00:09:32 <Cale> :t (++)
00:09:33 <lambdabot> forall m. (Monoid m) => m -> m -> m
00:09:58 <Cale> Runaro: Basically, anything which acts like concatenation :)
00:10:00 <Runaro> nice and general
00:11:32 <Runaro> like a concatenation, so any catamorphism?
00:11:55 <povman> googling "map . flip id" comes up with a few people doing the same @pl
00:12:34 <povman> does anyone know of a library with that function?
00:12:37 <dolio> @type map . flip id
00:12:37 <lambdabot> forall (f :: * -> *) b c. (Functor f) => b -> f (b -> c) -> f c
00:12:52 <povman> (since it probably also contains other stuff i'd enjoy)
00:12:55 <Runaro> ?check \n -> n >= 0 ==> ((fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)) !! n) == ((1:repeat 0) ./ (1:(-1):(-1):repeat 0) !! n)
00:12:56 <lambdabot>  OK, passed 500 tests.
00:12:57 <dolio> @type flip sequence
00:12:58 <lambdabot> forall a b. b -> [b -> a] -> [a]
00:12:59 <Cale> Runaro: any operation which is associative and has an identity
00:13:07 <masklinn> @unpl map . flip id
00:13:07 <lambdabot> (\ g -> map (\ c -> c g))
00:13:09 <povman> :t sequence
00:13:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
00:13:40 <povman> dolio: what was that?
00:13:47 <povman> @type sequence
00:13:47 <Pseudonym> > (0 : 1 : repeat 0) ./ (1 : -2 : 1 : repeat 0)
00:13:48 <lambdabot>  [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,...
00:13:50 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
00:13:54 <Pseudonym> Nice.
00:14:11 <dolio> > sequence [(+1) , (*2) , (^3)] 2
00:14:11 <lambdabot>  [3,4,8]
00:14:28 <hpaste>  morrow annotated "L.hs current local defs" with "some more" at http://hpaste.org/6927#a1
00:14:45 <dolio> > (map . flip id) 2 [(+1) , (*2) , (^3)]
00:14:46 <lambdabot>  [3,4,8]
00:14:47 * povman explodes
00:15:00 <povman> which monad is that?
00:15:06 <dolio> (->) r
00:16:06 <Cale> > (do x <- id; y <- reverse; z <- map toUpper) "Hello"
00:16:06 <lambdabot>  Parse error at ")" (column 44)
00:16:13 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "Hello"
00:16:14 <lambdabot>  ("Hello","olleH","HELLO")
00:16:15 <Pseudonym> > (0 : 1 : repeat 0) ./ (1 : -3 : 3 : -1 : repeat 0)
00:16:15 <lambdabot>  [0.0,1.0,3.0,6.0,10.0,15.0,21.0,28.0,36.0,45.0,55.0,66.0,78.0,91.0,105.0,120...
00:16:18 <Runaro> @unpl map . flip id
00:16:18 <lambdabot> (\ g -> map (\ c -> c g))
00:16:45 <lispy> Cale: oh, I never really thought to do it like that, cute
00:16:47 <hpaste>  morrow annotated "L.hs current local defs" with "(no title)" at http://hpaste.org/6927#a2
00:17:37 <povman> hey that's neat
00:18:13 <povman> it's like a better version of composition
00:18:19 <Cale> It's one of the nicest monads, and it's unfortunately not in the Prelude.
00:18:35 <Cale> You have to import Control.Monad.Instances
00:18:40 <Cale> Or else Control.Monad.Reader
00:18:46 <dolio> It's not even in base.
00:19:07 <lispy> I think Control.Monad.Reader is not such an obvious name for someone looking for that ability.
00:19:20 <lispy> I know why it makes sense though.
00:19:35 <Pseudonym> I've been thinking about the arrow A a b = W a -> M b
00:19:46 <dolio> Oh, I guess Instances is in base.
00:20:04 <Pseudonym> Seems to me that because there's a (->) in the middle, there should be a "nicer" proc/do-like syntax.
00:20:23 <Pseudonym> Because the standard arrow proc syntax is horrible.
00:21:05 <lispy> Pseudonym: for some reason, I thought someone had proposed something akin to do-notation for arrows.  Did I dream this?
00:21:18 <Pseudonym> lispy: For general arrows, yes.
00:21:33 <Pseudonym> But it seems to me that this special case is a) quite general, and b) doesn't require the horrible syntax.
00:21:45 <lispy> oh, I see what you're talking about
00:22:58 <dolio> No one's come up with a good syntax for W a, to my knowledge.
00:23:25 <Pseudonym> http://www.cs.helsinki.fi/u/ekarttun/comonad/
00:23:27 <lambdabot> Title: Comonads and Haskell
00:24:16 <Pseudonym> But essentially, that syntax is just continuation-passing.
00:24:30 <Pseudonym> It doesn't seem to have much advantage over monads.
00:24:39 <Pseudonym> Or at least to my eyes.
00:26:05 <lispy> I'm trying to find a paper that was presented here: http://www.brics.dk/~danvy/icfp05/
00:26:07 <lambdabot> Title: 10th ACM SIGPLAN International Conference on Functional Programming (ICFP 2005)
00:26:21 <lispy> The subject was type witnesses, anyone know which paper I'm thinking of?
00:28:24 <Pseudonym> "Witnessing side-effects"?
00:28:33 <Runaro> > (0 : 1 : repeat 0) ./ (1 : : 0 : (-1))
00:28:33 <lambdabot>  Parse error at ":" (column 28)
00:28:42 <Runaro> > (0 : 1 : repeat 0) ./ (1 : 0 : (-1))
00:28:43 <lambdabot>   add an instance declaration for (Num [Double])
00:29:00 <Runaro> > (0 : 1 : repeat 0) ./ (1 : 0 : (-1) : repeat 0)
00:29:01 <lambdabot>  [0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0...
00:29:22 <Pseudonym> Abstract: We present a new approach to the old problem of adding side effects to purely functional languages. Our idea is to extend the language with "witnesses," which is based on an arguably more pragmatic motivation than past approaches. We give a semantic condition for correctness and prove it is sufficient. We also give a static checking algorithm that makes use of a network flow property equivalent to the semantic condition.
00:29:24 <Pseudonym> That the one?
00:30:27 <lispy> Pseudonym: maybe, how did you find this stuff?
00:30:36 <Pseudonym> ACM Digital Library
00:30:43 <Pseudonym> http://portal.acm.org/toc.cfm?id=1086365&coll=ACM&dl=ACM&type=proceeding&idx=SERIES824&part=series&WantType=Proceedings&title=ICFP&CFID=23412494&CFTOKEN=48489721
00:30:45 <lambdabot> Title: ICFP: ICFP '05, http://tinyurl.com/5vw7lw
00:32:42 <lispy> Pseudonym: thanks very much
00:37:08 <takamu> hello
00:41:16 <Pseudonym> Must away.
00:41:17 <Pseudonym> Nytol!
00:41:26 <olsner> nytol?
00:41:36 <dolio> It helps you get your Zs.
00:45:01 <dolio> I'm not sure what to make of those comonad combinators. I wouldn't necessarily expect a comonad syntax to be just like do notation.
01:07:06 <ski> dolio : *nod*
01:15:12 <ski> a .>> b  =  a =>> \_ -> coeval b
01:15:22 <ski>          =  a =>> \a -> const (coeval b) (coeval a)
01:15:29 <ski>          =  a =>> (const (coeval b) . coeval)
01:15:32 <ski>          =  fmap (const (coeval b)) a
01:16:24 <ski> in light of this, `(.>>)' seems like a quite useless combinator to me, since the comonadic "context" of `b' is just discarded, so we could just as well have defined
01:16:45 <ski> (.>>) :: Comonad w => w a -> b -> w b
01:17:03 <ski> wa .>> b  =  fmap (const b) wa
01:17:10 <ski> (instead of the current
01:17:26 <ski>  (.>>) :: Comonad w => w a -> w b -> w b)
01:17:28 <ski> )
01:18:10 <ski> and then, passing `coeval foo' instead of `foo' as right argument to `.>>'
01:20:42 <ski> (actually, we can s/Comonad/Functor/ in the type signature, which tells us that this combinator doesn't really do something specifically depending on comonads, thus making this dubious as a *comonad* combinator)
01:46:59 <GeoffSK> Can anyone help - how do i get iGHC to locate Network in "import Network" ?
01:48:56 <kfish> GeoffSK, what platform are you on / how did you install ghc?
01:49:36 <GeoffSK> ubuntu, and it was part of the synaptic(?) package install
01:49:58 <kfish> install libghc6-network-dev
01:50:46 <GeoffSK> thanks, i'll try it
01:55:29 <GeoffSK> kfish - thanks, that fixed it
02:26:41 <ndm> @seen kosmikus
02:26:41 <lambdabot> kosmikus is in #haskell-hac4, #gentoo-haskell, #darcs, #ghc and #haskell. I last heard kosmikus speak 14h 48m 42s ago.
03:07:20 <Cale> @yow
03:07:20 <lambdabot> My mind is a potato field ...
03:07:23 <Cale> @keal
03:07:23 <lambdabot> primary elemental assumption of integer coefficients to roots in counting sytem is wrong
03:07:41 <Cale> @protontorpedo
03:07:41 <lambdabot> troll?
03:07:43 <Cale> @protontorpedo
03:07:44 <lambdabot> hey guys can haskeel be used to produce fast webapps?
03:07:56 <Cale> @palomer
03:07:56 <lambdabot> woof
03:08:13 <Cale> @b52s
03:08:13 <lambdabot> She drove a Plymouth Satellite faster than the speed of light!
03:08:33 <Cale> @slap ChanServ
03:08:33 * lambdabot jabs ChanServ with a C pointer
03:09:00 <Cale> @keal
03:09:01 <lambdabot> actually it bug in math
03:09:03 <Cale> @keal
03:09:03 <lambdabot> haskell always said undefined
03:09:10 <Cale> > undefined
03:09:14 <lambdabot>  Undefined
03:09:26 <Cale> @palomer
03:09:26 <lambdabot> Scalliwags!
03:10:01 <Japsu> hmm
03:10:05 <Japsu> :t Undefined
03:10:06 <lambdabot> Not in scope: data constructor `Undefined'
03:12:43 <therp> japsu: that's more like > error "Undefined"
03:14:11 <Japsu> right
03:15:01 <quicksilver> > error "Oops"
03:15:02 <lambdabot>  Exception: Oops
03:43:03 <DRMacIver> "Bug report: I am using IE6". It's nice to see people being so honest. :)
03:43:24 <DRMacIver> (latest post in the hayoo thread)
03:49:39 <titusg> it will be nice if/when hayoo supports text browsers
03:57:29 <pleaseandthankyo> what are police there for really(i am sure more than half is not enforcing governmental laws)? how to get on the side of the police when encountered? should i pay money to the police/tip whenever they shows up or in advance?
03:58:00 <Cale> pleaseandthankyo: This channel is about the Haskell programming language.
03:59:33 <Gilly> he also thinks #gentoo folks would like to talk about that
04:00:22 <mauke> and #drupal #emacs #irssi #maemo #wowace #lisp #defocus #openmoko #ubuntu+1 #git #archlinux #haskell #gsoc ##c ##c++ #perl ##php #gentoo
04:00:41 <earthy> with Haskell you don't need the language police, right, you have the compiler enforce its 'laws'. :P
04:00:59 <tibbe> is the latest cabal on hackage supposed to build on GHC 6.4.1?
04:02:25 <nornagon> earthy: most of them, at least.
04:02:28 <Cale> tibbe: heh, I doubt it would.
04:02:40 <Cale> tibbe: (but maybe?)
04:02:41 <tibbe> hmm
04:02:46 <hpaste>  (anonymous) annotated "Sweet lettrer" with "faustina4uu" at http://hpaste.org/6237#a1
04:02:49 <Cale> 6.4.1 is really old
04:02:51 <tibbe> I'm trying to build xmonad using 6.4.1
04:02:54 <tibbe> true
04:03:02 <earthy> nornagon: yeah, the monad laws aren't enforced
04:03:03 <tibbe> but it's what's available on my system at work
04:03:08 <earthy> (but that's because, really, they can't)
04:03:18 <tibbe> and building ghc is a pain due to the mix of 64 and 32-bit environment we run under
04:03:25 <nornagon> ugh, hpaste spam? :(
04:17:40 <ivanm> with this new hayoo engine, is it meant to replace/complement hoogle? or is it something completely seperate?
04:17:52 <ertai> is there a function from Integer to Int
04:18:08 <ertai> should be easy I think, but...
04:18:20 <EvilTerran> ?type fromIntegral
04:18:21 <lambdabot> forall a b. (Num b, Integral a) => a -> b
04:18:27 <EvilTerran> ?type fromInteger
04:18:28 <lambdabot> forall a. (Num a) => Integer -> a
04:18:33 <EvilTerran> ?type fromEnum
04:18:34 <lambdabot> forall a. (Enum a) => a -> Int
04:18:49 <EvilTerran> I think the first is what people usually use
04:18:55 <ertai> sorry not really awake
04:19:22 <EvilTerran> np :)
04:27:40 * mattr__ trying to grok an error
04:28:32 <hpaste>  matt__ pasted "I know why it won't work, I just don't understand the error" at http://hpaste.org/6929
04:30:04 <byorgey> interesting =)
04:30:34 <byorgey> I guess GHC.Prim.Any is some sort of internal representation for something whose type is not yet known
04:31:00 <mattr__> cool
04:31:15 <byorgey> mattr__: if you say  let (Just x) = Nothing :: Maybe Int,  and then type x, it will fail with a more normal-looking exception telling you that pattern matching failed
04:31:28 <quicksilver> mattr__: I get "*** Exception: <interactive>:1:4-19: Irrefutable pattern failed for pattern Data.Maybe.Just x"
04:31:34 <quicksilver> which is more what I would expet.
04:31:51 <mattr__> anytime I can get ghc to give up a strange run-time is a win
04:31:56 <mattr__> quicksilver: cheers
04:32:03 <byorgey> I tried it, and I get the same error as mattr__
04:32:04 <quicksilver> I'm using 6.6.1 though
04:32:10 <quicksilver> probably a 6.8 'issue'
04:32:20 <mattr__> i am on 6.8.2
04:32:26 <byorgey> me too
04:34:52 <paolino> anyone knows a software for drawing maps/graphs where edges are also normal nodes so I can put interedges edges ?
04:36:09 * paolino is little disappointed that Cmap doesn*t do that
04:36:37 <Baughn> paolino: ..does /anything/ do that?
04:37:11 <Baughn> paolino: If you want a node, convert your edge to a node and two edges?
04:37:16 <paolino> not that I've found
04:37:32 <Baughn> It sort of contradicts the definition of "graph"
04:37:48 <paolino> Baughn: that changes the meaning of edges
04:38:12 <Baughn> paolino: You're already doing that; edges aren't nodes.
04:39:13 <paolino> I mean reification is not always the right way to go
04:40:08 <paolino> data Node a = Leaf a | Egde (Node a) (Node a) is not a graph ?
04:40:30 <paolino> well a list of them
04:40:56 <Baughn> I guess that depends on who you ask. It surely isn't a /conventional/ graph.
04:41:20 <paolino> probably data Node a = Leaf a | Edge a (Node a) (Node a)
04:42:17 <Baughn> Looks more like some sort of.. cyclic... trie
04:42:22 <Baughn> I'm not sure /what/ to call it, really
04:43:06 <paolino> any way Dia goes a little far than  Cmap, but then when I move pieces  it leaves them around :)
04:44:46 <paolino> Baughn: it is data Node a = Leaf a | Edge a a a in a Map a (Node a) , better
04:44:50 <Baughn> paolino: Apparently, "cyclic trie" is exactly what it is. So there you go. ;)
04:45:47 <paolino> I thought trees were graphs
04:46:06 <QtPlatypus> paolino: trees are a subset of graphs.
04:46:28 <Baughn> paolino: They can be represented as graph. So can yours.
04:47:43 <paolino> Cmap is java, this put a stone on it
04:49:56 <Baughn> paolino: Edges still don't have edges, but of course, that's easy to avoid. Just don't label them "edges" when they're really nodes. ;)
04:50:05 <Baughn> It's just a matter of naming
04:54:41 <paolino> mmhh, say A depends on B , and call AB the edge, then say AB depends on C, if AB is a node the edge between A and AB has no semantic, this is what I don't like of reification
04:56:17 <Baughn> Well, it's your choice. It's just easier to talk about graphs if everyone uses the same names.
04:58:52 <Peaker> do you allow nodes and edges of differing types in a graph?
04:59:39 <Baughn> What?
05:00:10 <Peaker> well, he could have a "dependency" also be a node, of a different kind
05:00:30 <Baughn> That's what I was suggesting
05:00:54 <Baughn> That'd be a union type, though. Not really "different types", "combination type".
05:01:10 <quicksilver> yes it's very common to have 'types' of node in a graph
05:01:21 <quicksilver> a 'type' of node is just a subset of nodes, after all.
05:05:55 <paolino> if A depends on B and depends is a node the meaning of the two edges just born is undefined , and worse nothing identifies them as forming one edge
05:08:12 <paolino> while the meaning of depends was probably well defined by the problem
05:08:52 <Peaker> paolino, why is the dependency itself a node, that needs to have edges?
05:09:28 <Baughn> paolino: What sort of program are you writing, really? A make-alike?
05:10:07 <paolino> because there is another kind of edge meaningful when pointed to a depends-kind one
05:10:36 <paolino> Peaker: yes
05:10:57 <paolino> ehm Baughn: yes
05:11:16 <Baughn> paolino: Okay. So if you have A depending on B and C depending on AB... shouldn't C actually depend on A?
05:11:30 <paolino> possibly
05:11:55 <paolino> actually was AB depending on C
05:12:03 <Baughn> The AB edge would contain the information required to transform B into A, right?
05:12:16 <paolino> right
05:12:17 <Baughn> Oh.. so AB needs a program that C provides, or something like that?
05:12:36 <paolino> ok
05:12:46 <Baughn> Hm
05:13:09 <paolino> the problem is not the code, is documentation :)
05:13:54 <quicksilver> I think you have two things you want to separate.
05:14:03 <quicksilver> A and B are presumably something like 'targets'.
05:14:05 <paolino> I will use colors to identify the edge made of two edges and a node
05:14:07 <Baughn> Nodes represent files, edges represent dependencies.. edge-edges would be meta-dependencies
05:14:09 <quicksilver> AB is presumably something like an 'action'
05:14:11 <Baughn> So meta-edges? ;)
05:14:21 <quicksilver> 'an action to build B out of A'
05:14:23 <quicksilver> or similar.
05:14:31 <quicksilver> now that *action* may have prerequisites
05:14:39 <quicksilver> but they're probably not really related to A and B
05:14:46 <quicksilver> just something general about the nature of the action.
05:14:49 <quicksilver> I'm only guessing here.
05:14:54 <paolino> oh, they are :P
05:15:09 <paolino> in fact C depends on A
05:15:12 <Baughn> paolino: I give. It /does/ make sense for your edges to have edges.
05:15:27 * paolino exults
05:15:32 <Baughn> Not sure what I'd call them, and it definitely isn't a graph anymore, but..
05:16:03 <Baughn> paolino: ...hang on. A depends on B, AB depends on C, and C depends on A?
05:16:18 <Baughn> paolino: You've got cycles in your graph
05:16:35 <Baughn> (Not that that's so odd. GHC depends on happy, happy depends on GHC.. great going)
05:16:46 <paolino> ehm you got first depends wrong
05:17:01 <Baughn> Oh. Well, never mind
05:18:01 <Baughn> paolino: In make you'd represent the meta-edge as "B (or was it A?) depends on C", but your way seems cleaner
05:20:34 <paolino> actually it's A.hs compilation to A.hi which depends on the presence of the imported modules of A.hs which we call x.hi, eventually this dependence , from x.hi and the compilation, depends on A.hs via a preprocessing action
05:22:40 <quicksilver> malcolmw: By the way, my supposed problem about &#38; was PEBKAC.
05:22:59 <paolino> A.hi
05:22:59 <paolino> |
05:22:59 <paolino> ­|
05:22:59 <paolino> ___________ x.hi
05:22:59 <paolino> |     /
05:23:00 <paolino> |   /
05:23:02 <paolino> A.hs
05:23:02 <malcolmw> quicksilver: PEBKAC?
05:23:18 <quicksilver> malcolmw: Problem Exists Between Keyboard And Chair
05:23:56 <quicksilver> malcolmw: my "getText" combinator was pulling text content out of CStrings but it didn't look inside CRef (RefChar c) _
05:24:17 <quicksilver> malcolmw: now it does (getText (CRef (RefChar c) _) = [toEnum c])
05:24:20 <quicksilver> malcolmw: and all is well :)
05:24:24 <malcolmw> quicksilver: ah.  makes sense
05:24:52 <quicksilver> malcolmw: a Show instances for Content would have made that easier to debug ;) Because I would have seen the CRef elements and realised what I was doing wrong.
05:25:06 <malcolmw> quicksilver: point noted
05:25:26 <malcolmw> quicksilver: others have asked for that as well
05:28:50 <quicksilver> :( @ darcs message. almost throwing in the towel, I feel :(
05:32:03 <gnuvince> ~me
05:34:17 <shepheb> I felt that way about it at first too, but there's a later post on the -cafe from droundy that doesn't have the same tone. essentially (paraphrasing): darcs is much faster for many operations on small and mid-size respoitories. it has always had problems on large repos. some operations will be better, some worse, on large repos.
05:34:40 <quicksilver> shepheb: I didn't mean that part so much
05:34:50 <quicksilver> as his continuing recommendations that people choose another dvcs
05:35:04 <quicksilver> and his calls for more contributors
05:35:08 <quicksilver> those sounds like death-throes
05:35:11 <quicksilver> I hope I'm wrong!
05:37:19 <paolino> code or money contributors ?
05:37:49 <quicksilver> code
05:39:39 <paolino> darcs is the most widespread haskell product ?
05:40:15 <Lacrymology> is there a way to import things besides Prelude into hugs without loading a file?
05:40:19 <quicksilver> possibly?
05:40:35 <quicksilver> (that was to paolino)
05:40:41 <quicksilver> Lacrymology: yes, but I don't know what it is.
05:43:15 <paolino> quicksilver: letting it die would kill the idea that haskell is ready to  become useful for the masses, which is good or bad
05:44:41 <paolino> I'm already seing my friends tapping my shoulders with a sarcastic look in the eyes :)
05:46:09 <pejo> paolino, if we can get F# to steal all the ideas from Haskell that means the mission is accomplished I'd say.
05:47:56 <quicksilver> paolino: eh?
05:48:03 <quicksilver> paolino: only fools would think that
05:48:13 <quicksilver> paolino: if darcs fails, it fails for being too ambitious in conception
05:48:21 <quicksilver> the language it was written in is not the point.
05:48:31 <quicksilver> Anyone could rewrite hg or git or bzr in haskell if they chose
05:48:43 <Baughn> How could darcs fail? It's already useful.
05:48:43 <shepheb> or darcs in C
05:50:44 * nominolo_ is learning git now
05:50:51 <paolino> pejo: is F# contributed by SPJ ?
05:51:01 <nominolo_> noooo
05:52:21 <ivanm> its the flying frog guy, is it not?
05:53:59 <hpaste>  Lacrymology pasted "(no title)" at http://hpaste.org/6930
05:54:14 <Lacrymology> can someone take a look at that please?
05:54:59 <Lacrymology> what's the problem with that strOp? I can't see why it won't work
05:55:03 <Lacrymology> load
05:56:14 <shepheb> if F# turns out to suck, that will set FP back in the minds of many. but I like to think they'll do it right.
05:57:10 <Lacrymology> ookay, nevermind
05:59:42 <quicksilver> ivanm: no, the frying frog guy is keen on F# but had no part in its creation that I'm aware of.
06:00:18 <quicksilver> SPJ has certainly had some kind of involvement in F#, but it wasn't central I don't think.
06:00:30 <ivanm> ahh, k
06:00:53 <quicksilver> I think SPJ gave some advice to the CLR team, too.
06:01:06 <opqdonut> yea clr seems pretty nice
06:01:16 <ivanm> quicksilver: CLR?
06:01:26 <opqdonut> common language runtime
06:01:46 <ivanm> oh, the .NET thing?
06:02:22 <quicksilver> write, which F# and C# both target.
06:02:27 <quicksilver> right.
06:02:32 <quicksilver> homonyms--
06:04:07 <opqdonut> :D
06:06:34 <mdurr> anyone know of an XML combinator that works close to Text.XHtml or Text.Html?
06:21:49 <mdurr> nevermind, I think hxt will do
06:29:24 <paolino> eh , reading around F#, haskell never get mentioned
06:33:48 <byorgey> wait, GHCi is not implemented in Haskell?
06:33:58 <quicksilver> of course it is.
06:34:14 <quicksilver> (as much as ghc is, at least)
06:34:33 <byorgey> that's not what Matthew Naylor says in his Monad.Reader article.
06:34:46 <byorgey> "There are several Haskell interpreters, such as Hugs and GHCi, but none (as far
06:34:49 <byorgey> I’m aware) are implemented in Haskell
06:35:08 <quicksilver> He is mistaken.
06:35:30 <quicksilver> Although, ghci is a bit of a strange architecture, compared to a 'naive' interpreter.
06:35:35 <quicksilver> It does have hooks straight into the runtime.
06:35:50 <quicksilver> it manages to run the interpreted code 'directly' in its own runtime
06:36:04 <quicksilver> rather than needing a runtime of its own
06:36:13 <byorgey> I see.
06:36:14 <quicksilver> and it can load native code / compiled code.
06:36:22 <quicksilver> maybe that is the distinction he is trying to make?
06:36:50 <swiert> quicksilver: I think so - ghci interprets bytecode.
06:37:03 <swiert> quicksilver: and doesn't evaluate Haskell expressions directly.
06:37:34 <quicksilver> I contend that isn't a particularly meaningful distinction.
06:37:41 <quicksilver> but I do take the point.
06:37:48 <quicksilver> there is a continuum between compilers and interpreters
06:38:02 <quicksilver> and ghci is further down that continuum than your average naive interpreter will be.
06:39:01 <dancor> it's looking like when fdRead blocks, it blocks everything not just one forkIO thread.  true story?
06:39:17 <quicksilver> very likely.
06:39:18 <pejo> Wasn't his article a well written educational article that shows how to write an interpreter in Haskell?
06:39:24 <swiert> quicksilver: sure - it really depends on your definition of "implemented in Haskell" .
06:39:31 <hpaste>  gogonkt pasted "colinux & archlinux notes" at http://hpaste.org/6931
06:39:47 <quicksilver> dancor: you need -threaded, I guess.
06:39:48 <malcolmw> quicksilver: AFAIK, the actual interpreter of bytecodes in ghci is not written in Haskell
06:39:56 <quicksilver> dancor: but perhaps you don't really want fdRead?
06:40:08 <quicksilver> dancor: the GHC RTS handles blocking IO for you in the normal case.
06:40:14 <quicksilver> malcolmw: I didn't know that.
06:40:20 <dancor> quicksilver: well i might actually want fdRead. i'm having trouble working with pty's
06:40:52 <quicksilver> swiert: yes, if the emphasis is intended to be "implemented in *pure* Haskell" then, yes. ghci's interpreter is directly hooked to the C/C-- RTS.
06:40:59 <malcolmw> quicksilver: the UI is in haskell, and the compiler to bytecodes is in haskell, but not the interpreter.  Same as yhc.
06:41:15 <quicksilver> Interesting.
06:41:17 <dancor> can i get -threaded with cabal
06:41:54 <dancor> or just ghc-options: -threaded and call it a day
06:42:43 <quicksilver> no idea. Any cabal experts?
07:05:42 <paolino> is there an easy way to make a filterM for Map ?
07:06:30 <paolino> :t filterM
07:06:30 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
07:07:25 <paolino> @src filterM
07:07:25 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
07:07:48 <paolino> @hoogle rutabaga
07:07:48 <lambdabot> No matches found
07:09:06 <Saizan> ?google site:hpaste.org purify
07:09:08 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
07:09:09 <quicksilver> paolino: fromList . filterM . toList
07:09:13 <quicksilver> paolino: (roughly!)
07:09:23 <MarcWeber> Are there some proposals on how to store relational data in memory?
07:09:23 <lambdabot> MarcWeber: You have 1 new message. '/msg lambdabot @messages' to read it.
07:09:35 <mxc> question about concurrency, if i have a system which, to simplify, has two threads, thread A and thread B.  thread A is basically a REPL which in procedural terms would set a shared variable and thread B is an infinite loop which uses the shared variable, what is the proper, functional, haskell way to realize that?
07:09:55 <Botje> an MVar?
07:10:55 <Botje> so thread two can do something like forever (takeMVar input >>= putMVar output)
07:11:29 <Botje> well, putMVar output . eval :)
07:14:00 <quicksilver> mxc: definitely an MVar.
07:14:33 <mxc> ty
07:18:02 <Peaker> hopefully explicit threads are not the future :)
07:19:04 <gnuvince> Hopefully
07:20:54 <mxc> forkIO + MVars considered harmful?
07:21:15 <ksandstr> sort of like goto is
07:21:29 <mxc> ok, new question
07:21:40 <mxc> what is the ideal way to implement that sort of behavior?
07:21:43 <Peaker> mxc, my personal idealistic view
07:21:53 <ksandstr> it gets stuff done and doesn't require a double degree, but some people frown on things that aren't beautiful
07:22:39 <Peaker> I just hope that a high-enough-level specification of a program, perhaps with some _separate_ optimization hints, can decide the "ugly" things out of the context of the program code: A) Evaluation order and strictness issues.  B) Parallelization
07:22:49 <mxc> ksandstr - i actually kind of agree
07:22:49 <quicksilver> mxc: explicit threads are a perfectly good solution to certain problems.
07:22:59 <quicksilver> mxc: don't let Peaker put you off too much.
07:23:15 <Peaker> I am not trying to be a putoff, forkIO works *now* :-)
07:23:29 <Peaker> I am talking about an utopian future :)
07:23:29 <mxc> peaker - in terms of optimization, like say making fib run faster, i agree
07:23:35 <ksandstr> and sometimes a good goto is precisely what you need
07:24:04 <Peaker> mxc, threading, strictness and evaluation order are optimizations (if you are willing to stretch that to include whether or not the program terminates)
07:25:16 <mxc> peaker - but my question is regarding situation where the program behavior is naturally threaded, for example, a continual ping where the user can type in a new IP while its running to change whats being pinged
07:25:23 <quicksilver> yes
07:25:31 <quicksilver> if you are interating with an environemtn
07:25:39 <quicksilver> e.g. other IP servers
07:25:49 <quicksilver> then threading is often a good model for that kind of thing
07:26:01 <Peaker> mxc, Why do you consider that "naturally threaded"?
07:26:11 <Peaker> mxc, concurrency and threading are different things
07:28:30 <sek> does anyone know of a library/easyily-available-source-code for a decent integer factorisation implementation?
07:30:16 <tromp> http://www.gap-system.org/Packages/factint.html
07:30:18 <lambdabot> Title: GAP package FactInt
07:30:40 <sek> needless to say i meant in haskell :-)
07:31:06 <sclv> are you looking for an example of a particular algorithm?
07:31:08 <tromp> a nice porting challenge:)
07:31:16 <sclv> or rather for performance?
07:31:43 <sek> anything other than my 5 line crude brute force to (sqrt n) method really:)
07:33:05 <sclv> ok -- there's a cute numerical library floating around with wheel sieve code and all as i recall.
07:33:57 <sek> ah that sounds good
07:34:02 <mxc> peaker - for example, one thread on an infinite loop that outputs something based on a shared variable, waits 10 seconds and repeats and another thread that allows a user at any time to update teh shared variable
07:34:54 <mxc> peaker - definitely {\em could} be written wihtout threads, but wouldn't be ideal
07:35:05 <sclv> there's also this (use the merge version) for a relatively simple solution:
07:35:09 <sclv> http://www.haskell.org/haskellwiki/Prime_numbers
07:35:10 <lambdabot> Title: Prime numbers - HaskellWiki
07:35:21 <Peaker> mxc, I don't know how that would look like in an ideal software world
07:35:28 <Baughn> > chr 766
07:35:30 <lambdabot>  '\766'
07:35:40 <Peaker> mxc, but I don't think explicitly specifying those as threads would be the way
07:35:52 <quicksilver> mxc: anything which involves timing, like wait 10 seconds, and stuff
07:35:59 <quicksilver> mxc: is essentially specified using a thread-like model.
07:36:18 <quicksilver> mxc: so threads are the natural implementation of that spec
07:36:27 <quicksilver> it's an intrinsically thready spec, if you like :)
07:37:05 <mxc> quicksilver - yes.  i get that its not elegant behavior, i'm trying to see how much i can get out of haskell as a practical language.  did a lot with ocaml, taking on a new challenge. and, by the way, learning haskell makes learning ocaml look like a complete walk in the park
07:37:09 <Peaker> program = concurrent [(every (seconds 10) (use someRef)), (widgetEditing someRef)]
07:37:33 <quicksilver> mxc: I like threads.
07:37:39 <mxc> :)
07:37:44 <quicksilver> mxc: I think using threads for that is fine.
07:37:52 <quicksilver> Peaker: call it what you like. That is explicit threading.
07:38:05 <quicksilver> Hiding behind a [IO ()] doesn't make it any less threading :P
07:38:06 <mxc> quicksilver - so basically forkIO + MVars is the haskell way
07:38:09 <quicksilver> yup.
07:38:15 <quicksilver> for the kind of problem you're talking about.
07:38:42 <quicksilver> for more sophisticated problems you might imagine a so-called "reactive" system with code responding to external stimuli
07:38:42 <Peaker> quicksilver, but it doesn't require MVar/etc
07:38:51 <quicksilver> and the threading behind the scenes.
07:39:02 <quicksilver> Peaker: doesn't it? what type is someRef if not MVar?
07:39:31 <Peaker> quicksilver, represents some "identity", its not a channel you "wait" on, though
07:39:55 <quicksilver> MVars aren't channels.
07:40:00 <quicksilver> Do you know what MVar is?
07:40:03 <quicksilver> no offence :P
07:40:13 <quicksilver> and MVar is a variable with synchronisation proprties.
07:40:21 <quicksilver> that's what you need, if you have concurrent access.
07:40:22 <sclv> sek: can't seem to find the one I recall. but there is also this: http://andrew.bromage.org/darcs/numbertheory/Math/
07:40:24 <lambdabot> Title: Index of /darcs/numbertheory/Math
07:40:31 <sclv> and this: http://www.polyomino.f2s.com/david/haskell/codeindex.html
07:40:32 <lambdabot> Title: Code Index
07:41:00 <sclv> which looks like it has Elliptic Curve and some variation on the Rational Sieve, which is pretty fun.
07:41:28 <Peaker> quicksilver, It was my understanding that MVar's are a non-buffered channel, as you wait-to-send, and wait-to-receive?
07:42:01 <Peaker> quicksilver, or a single-value as a buffer, more accurately
07:42:49 <nominolo_> you could put a queue in there
07:42:58 <sclv> I think these are all better algorithms, but they also seem to be written as much for learning as for efficiency. for heavy duty number crunching, c is probably still where its at for this stuff (the fancy factorizers do insane things with IO to deal with the very large amounts of working data they generate, enormous sparse matrixes to process, etc.)
07:45:27 <sek> sclv, many thanks, i'm looking into them now
07:45:31 <Peaker> quicksilver, you can't modify an MVar without someone first "emptying" it (reading its current value), right?
07:46:39 <sclv> this is true.
07:46:51 <tromp> :t ap
07:46:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
07:47:03 <tromp> :t fmap
07:47:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:47:41 <tromp> @pl \x->all (/=0 . (mod x))
07:47:41 <lambdabot> all . (/=) . (0 .) . mod
07:47:54 <Peaker> so I don't see why its wrong to say MVar is a channel?
07:48:30 <Peaker> @pl \x->all ((/=0) . (mod x))
07:48:31 <lambdabot> all . ((0 /=) .) . mod
07:48:40 <Peaker> ?
07:48:42 <sclv> Peaker: but you need a locking primitive that looks like an mvar in spirit if not in form.
07:49:13 <sclv> when your updater thread is updating it, it needs to do so atomically otherwise you could read an inconsistent state.
07:49:14 <Peaker> sclv, Well, maybe the implementation does, I don't know how to implement it yet :-)
07:49:49 <Peaker> sclv, maybe the implementation of the ref-type uses some MVars under the hood...
07:50:38 <sclv> ?hoogle modifyMVar_
07:50:38 <lambdabot> Control.Concurrent.MVar.modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
07:51:01 <sclv> (keeps the take and put bits "under the hood" for you)
07:51:46 <sclv> modifyMVar_ myMVar (return "oh! i'm the new value")
07:52:11 <Peaker> well, maybe "someRef" above refers to an abstract entity, but what actually happens under the hood is that "deltas" or "differentials" on its value are sent on a channel to all those who "observe" that ref
07:52:53 <Peaker> I am trying to say that the above "ref" is too abstract/high-level to say whether its an IORef, MVar, or something else entirely implemented in those terms
07:53:42 <quicksilver> Peaker: and I'm tryign to say that you are kidding yourself, and MVar is already the correct level of abstraction :P
07:54:34 <Peaker> quicksilver, MVar wouldn't be able to transparently propagate differentials when the value changes
07:55:57 <tromp> @src ap
07:55:57 <lambdabot> ap = liftM2 id
07:56:39 <sclv> Peaker: you're familiar with FRP?
07:56:54 <tromp> @pl \x -> (f x) (g x)
07:56:55 <lambdabot> ap f g
07:57:14 <quicksilver> yes. You could have a much more complex thing which does deltaa
07:57:23 <Peaker> sclv, read some, but I need to read a lot more
07:57:24 <quicksilver> but that's a much more complex specification than needed for this problem.
07:57:25 <quicksilver> IMO.
07:57:43 <Peaker> quicksilver, I want to build a "world" of deltas where all computations are done differentially
07:57:49 <quicksilver> (You could also imagine something which implemented MVar's interface and used deltas behind the scenes)
07:58:17 <sclv> what you're describing (update without explicit polling and differential streams of information) is very similar to some of the work being done in FRP.
07:58:23 <Peaker> quicksilver, well, not all, you'd still have normal "pure" computations as you do now, but you would also have differential ones that you can compose into higher order ones, which are completely differential
07:58:39 <mxc> strange, anyone on GHC 6.8.2 on osx 10.5?
07:59:11 <mxc> er nevermind
07:59:26 <sclv> but as far as I understand it, conal's new paper is the first that seems to be able to sanely combine the two issues and strongly move away from "pull" mvc -- but then I'm really not going to fully claim to understand conal's new paper...
08:00:23 <quicksilver> the thing to remember about conal's papers
08:00:27 <quicksilver> and similar efforts
08:00:34 <quicksilver> is they aren't all-or-nothing, in reality.
08:00:47 <quicksilver> You can start with the architecture we have and start making portions of your code 'more reactive'
08:01:04 <quicksilver> the design space is interesting. and large.
08:02:30 * sclv laments again that cells' model seems inherently too reliant on IO to be translated.
08:03:53 <sclv> quicksilver: this not-all-or-nothing is distinct from the yampa-style approach, right?
08:04:10 <quicksilver> sclv: yes, it is :)
08:04:24 <quicksilver> sclv: I mean, you can learn lessons from the papers and start to use the techniques for some of your code
08:04:34 <quicksilver> without re-engineering your entire app as arrows.
08:04:53 <quicksilver> have some reactive "event handlers" or "animations" etc
08:05:41 <Peaker> I need to read more about FRP, but I started recently with Haskell and I have more basic gaps in my Haskell knowledge :-(
08:06:46 <mxc> strange,  running ghc --make MyUglyHaskell.hs  seems to change the buffereing on my shell
08:07:50 <Lacrymology> Peaker: you a python person, I knows you!
08:08:05 <Peaker> yes, I am
08:08:18 <Lacrymology> =)
08:08:23 <Lacrymology> haskell's wonderful
08:08:31 <Peaker> indeed :)
08:08:46 <Lacrymology> I made a parametric parser for about anything, it's about 160 lines
08:08:55 <Lacrymology> with comments and whitelines included
08:09:07 <Peaker> I used Python for years, thinking that dynamic typing is the best workaround to avoid textually specifying all the types, I thought type inference was impractical (not sure why) but now I found that dynamic typing is an unnecessary workaround
08:09:38 <cjb> there are certainly a lot of people who use Python and have no interest in using Haskell.
08:09:48 <cjb> so I don't think we need to decide that they're crazy or anything.  :)
08:09:57 <Peaker> Lacrymology, cool.. is it like parsec, or solves a different problem?
08:09:58 <Lacrymology> Peaker: python's still amazing. I wouldn't recommend haskell for game scripting, here at work
08:10:13 <Lacrymology> I wouldn't recommend lua either, and that's what we use, but whatever
08:10:39 <mxc> wow
08:10:44 <Lacrymology> Peaker: it's a more theoretical approach, it solves the problem of teaching people in uni
08:10:45 <mxc> done
08:10:45 <Peaker> Lacrymology, Yeah, I wouldn't quit my daily Python job just yet.  I think that Haskell, on the "practical" side of things, is not quite "Ready" (TM) yet.
08:11:36 <Peaker> Lacrymology, I think Haskell can and should be visualized as executing on an example input as you write it, and I am trying to work/research that idea, but I am struggling with much more basic things as a Haskell newbie :)
08:12:01 <Lacrymology> but basically it defines a data Parser = [symbol] -> ([symbol],result) for any types "symbol" and "result"
08:12:18 <Nafai> Peaker: I'm not sure that I really knew of the concept of type inference (or at least thought about it much) before I started learning Haskell
08:12:32 <Peaker> Lacrymology, what bothered me with various Pythonic/C parser frameworks is that they were all hard coded for strings...
08:13:07 <Lacrymology> well, you DO usually parse source code ;)
08:13:36 <Peaker> Nafai, ironically, now that I am toying with Haskell, I don't feel I need the type inference, as the type signature is great documentation and unlike Java/C++/etc its not mangled in the actual code, but in separate lines
08:14:10 <Peaker> Lacrymology, Hopefully only until we get rid of textual serialization for code :)
08:14:18 <sclv> Lacrymology: what amazes me is actually what a huge subset of all real-world-problems can be reenvisioned as parser/compiler issues.
08:14:36 <Peaker> sclv, examples?
08:14:43 <Saizan> Peaker: but you additionally don't have to write them yourself :)
08:14:50 <sclv> pretty printing is "compiling to text"
08:15:10 <Peaker> Lacrymology, does your parser build a FSM for O(1) symbol handling, supporting context-free grammars?
08:15:14 <sclv> event controllers are "parsing a context"
08:15:34 <Peaker> sclv, what are "event controllers"?
08:15:56 <mxc> peaker lacrymology et all, i used to work with a firm which did an amazing amount with ocaml.  its amazing how much FP + static typing can get you
08:16:10 <mrd> all problems can be turned into "language" problems
08:16:20 <Peaker> sclv, basically parsing/building is [de]serialization, and indeed pretty printing, textual languages, protocols, binary formats are all instances of this
08:16:24 <sclv> i'm being handwavey here -- but, say, anything where you have an interactive app and it gets a "something changed" event and needs to figure out what to do next.
08:16:34 <mxc> i'm fully convinced that the current rise of FP wil make a huge difference in qualiy of software
08:16:53 <mrd> thats the basis of computability theory
08:19:41 <sclv> whats nice is that so many problems *benefit* from being turned into "language" problems.
08:20:22 <Lacrymology> Peaker: no, it doesn't. As I said it's pretty simple and only wants to give some insight of the power of first order functions to students
08:20:54 <Lacrymology> and I don't know what's an FSM for that matter
08:21:09 <Lacrymology> flying spaghetti monster?
08:21:15 <Peaker> Lacrymology, ... or Finite State Machine
08:21:18 <Lacrymology> oh
08:21:33 <Lacrymology> well, then it does do
08:21:38 <Lacrymology> there's a function token
08:21:51 <Peaker> Lacrymology, O() of handling a token?
08:23:00 <Lacrymology> Peaker: however much haskell takes. I think it does things smartly, but worse case would be O(len(token))*O(Eq(symbol))
08:23:16 <Lacrymology> token = [symbol]
08:23:42 <Peaker> Lacrymology, that's great.. parsec is not as good, if I read correctly
08:23:56 <Lacrymology> Peaker: but haskell does things smartly, so if you call token with the same token-value pairs it won't recalculate
08:24:03 <Lacrymology> lazy = good
08:24:07 <Peaker> parsec becomes exponential/backtracking when combining grammars
08:35:57 <Peaker> When I have "callCC $ \exit -> do ...."  calling exit goes where? just outside the entire block under callCC?
08:37:25 <scook0> it jumps to just after the callCC
08:37:27 <scook0> so yes
08:37:59 <Peaker> great, thanks
08:38:47 <Peaker> I thought that a "continuation" was treated as a function.. that if you "call" it, it will return to you once its "done".  Or is it true but simply never considered "done", so never actually returns, therefore it is a "jump"?
08:39:19 <Baughn> Peaker: A continuation has no end, that's true
08:39:21 <mrd> it is a jump,more so
08:39:26 <Baughn> Except perhaps the end of the program
08:39:26 <scook0> a regular (undelimited) continuation will never return to the point just after you invoke it
08:39:40 <Peaker> scook0, are there delimited continuations?
08:39:48 <scook0> oh, you bet :)
08:40:20 <Beelsebob> @src Data.Map.insertWith
08:40:20 <lambdabot> Source not found. Just what do you think you're doing Dave?
08:40:23 <Beelsebob> bah
08:40:52 <Peaker> scook0, examples?
08:42:13 <scook0> iirc:
08:42:40 <scook0> reset $ do ... shift (\exit -> ...) ...
08:42:54 <scook0> when you invoke exit, it will jump out of the shift as though it were a callCC
08:43:02 <scook0> but when it hits the end of the reset block
08:43:09 <scook0> it will jump back to just after you invoked exit
08:43:19 <scook0> and when it falls off the shift block
08:43:29 <scook0> it will jump all the way out of the reset block
08:43:47 <scook0> (it's been a while since I learned all this, so some of it could be wrong)
08:44:21 <Peaker> sounds like a weird way to implement loops with breaks
08:44:39 <Peaker> all this jumping around, is it considered good practice? :)
08:44:57 <scook0> I couldn't really say
08:45:24 <scook0> presumably it's useful for something
08:45:33 <scook0> there should be some papers out there that discuss it
08:45:45 <scook0> but last time I tried I found them mostly unapproachable
08:47:57 <quicksilver> Peaker: it's not useful very 'often' in 'normal' programming.
08:48:09 <quicksilver> Peaker: when it's useful, it's useful, though :)
08:48:15 <Peaker> quicksilver, examples?
08:48:16 <quicksilver> people often implement parts of it by hand.
08:48:18 <sclv> first class continuations are sort of like goto, i've heard it explained -- you need them as a low level construct but only to build other control structures on top of...
08:48:43 <Peaker> sclv, a goto that can only jump to after the callCC, though?
08:48:55 <quicksilver> Peaker: complex partial-abort-with-value, partial-abort-with-rollback style semantics
08:49:14 <Peaker> quicksilver, where can I read about that?
08:49:36 <sclv> Peaker: well, actually you can do much fancier things with continuations...
08:50:33 <sclv> a continuation that only can do "exit" is generally called one-shot, and its much more widely implemented than the full deal, as i recall...
08:50:38 <quicksilver> I don't have a good reference off the top of my head.
08:50:55 <quicksilver> you could try reading some olegs
08:51:12 <sclv> oleg is supposed to be giving a talk on using delconts for a web application structure soon.
08:51:18 <quicksilver> Peaker: http://okmij.org/ftp/Computation/Continuations.html
08:51:19 <lambdabot> Title: Continuations and delimited control
08:51:38 <Peaker> thanks
08:51:50 <sclv> lots of continuation stuff is more of a scheme research issue though, no? oleg also tends to use ocaml quite a bit for this stuff..
08:51:58 <quicksilver> WARNING Reading Olegs can make your brain explode.
08:52:28 <quicksilver> there is an implementation of typed delimited continuations in almost-pure haskell which requires unsafeCoerce.
08:52:40 <quicksilver> I would love to have a deep understanding of why that unsafeCoerce is needed, but I don't.
08:54:26 <Saizan> quicksilver: do you have a deep understanding of the implementation at all?
08:57:15 <Peaker> its nice that data-constructors can use nice syntax like :+ for delimiting which helps readability.  Maybe type constructors could use similar syntax for readability.  The built-in types do it:  a->b  is a type, (->) a b   is less readable.  Arrow a b c  could probably benefit from such syntax
08:57:38 <kpreid> Peaker: you can do that
08:57:50 <Peaker> kpreid, type constructor delimiters can be defined?
08:58:01 <Deewiant> type (:->) = Arrow -- or something?
08:58:05 <kpreid> for example, ~> is an infix type constructor
08:58:06 <EvilTerran> ?type arr :: Arrow (~>) => (a -> b) -> (a ~> b)
08:58:07 <lambdabot> forall a b (~> :: * -> * -> *). (Arrow ~>) => (a -> b) -> ~> a b
08:58:09 <kpreid> er, type variable
08:58:22 <EvilTerran> it's a ghc extension, i believe
08:58:41 <Peaker> ah, cool
08:58:52 <EvilTerran> you can also have infix class names, in class declerations and contexts (but, strangely, not in instance heads)
08:59:07 <mattam> quicksilver: If it's the same one that I did in Coq, I'd like to know too. Are you refering to type-safe delimited continuations using generalized monads ?
08:59:11 <byorgey> huh, doesn't that type have some missing parens?
09:01:44 <quicksilver> mattam: I think I'm talking about this one.
09:01:46 <quicksilver> Saizan: No.
09:01:48 <quicksilver> mattam: http://www.haskell.org/haskellwiki/Library/CC-delcont
09:01:49 <lambdabot> Title: Library/CC-delcont - HaskellWiki
09:06:29 <shepheb> I get Connection Reset when trying to upload an image to the Haskell wiki
09:07:01 <cjb> How large is it?
09:07:05 <mattam> quicksilver: Ok, doesn't seem to be the same.
09:07:14 <shepheb> 861KB
09:09:20 <Baughn> Except perhaps the end of the program
09:09:25 * Baughn blinks
09:15:23 <mattam> quicksilver: I was refering to that: http://www.mail-archive.com/haskell@haskell.org/msg20758.html
09:15:24 <lambdabot> Title: [Haskell] Genuine shift/reset in Haskell98
09:19:34 <quicksilver> mattam: interesitng. I don't understand the difference between the implementations.
09:19:40 <quicksilver> No time to grok it now :)
09:35:33 <n00b> i wrote a haskell replace function, but it is not check if there is a char b4 the word in question. i don't want it to replace if there is a char infront or behind
09:35:36 <tromp> >3^2
09:35:47 <tromp> :t (**)
09:35:50 <lambdabot> forall a. (Floating a) => a -> a -> a
09:35:57 <hpaste>  replace pasted "n00b" at http://hpaste.org/6933
09:36:06 <tromp> :t (^)
09:36:07 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
09:38:00 <tromp> @pl \p->p*p
09:38:00 <lambdabot> join (*)
09:38:22 <n00b> any help plzzzzzzzzzzzzzz
09:40:14 <fxr> @seen MarcWeber
09:40:14 <lambdabot> MarcWeber is in #haskell, #darcs and #ghc. I last heard MarcWeber speak 2h 30m 42s ago.
09:42:04 <n00b> is there anyone in here???
09:43:15 <kpreid> why, yes
09:43:53 <n00b> i posted a replace function
09:44:09 <Peaker> Reading papers is hard for me, because instead of using only Haskell syntax, they use that AND a lot of math symbols that correlate in some unknown way to the Haskell ones..
09:44:19 <n00b> i want it to check the character before the word i am searching for
09:44:23 <kpreid> n00b: perhaps you should arrange so that when you invoke replace on the tail of the list, you skip over the ones which are letters
09:44:23 <Peaker> I wish they just used one set of symbols everywhere (preferrably Haskell syntax)
09:44:49 <kpreid> n00b: rather than just advancing exactly one character
09:44:56 <quicksilver> Peaker: mathematicians always invent new pretty symbols for their papers. It's part of the fun.
09:45:03 <quicksilver> Peaker: any particular symbol causing you pain?
09:45:43 <n00b> and how do i go about accomplishing that? could i do a isAlpha on the char to check?
09:45:49 <shepheb> I have trouble with that too; math notation doesn't bother me in general, but it's the custom stuff that I can't handle. I can't carry that big a dictionary
09:45:53 <Peaker> quicksilver, reading FRP from first principles, and now I see: "at" with a ~ on top of it, and [[b]] (not a list of lists..) and a '=' with 'def' on top of it
09:45:54 <kpreid> n00b: sure
09:46:11 <kpreid> n00b: your 'otherwise' case moves forward one character
09:46:22 <tromp> @let primes = 2:[x|x<-[3..],all((/=0).mod x)(takeWhile(<x)primes)]
09:46:25 <lambdabot> Defined.
09:46:30 <kpreid> n00b: instead, move over all alphas and then one more
09:47:05 <quicksilver> Peaker: =^{def} means "is defined to be"
09:47:23 <quicksilver> Peaker: as opposed to "merely happens to be equal", which is what "=" means.
09:47:29 <Peaker> quicksilver, but isn't = always =^{def} ?
09:47:33 <Peaker> oh
09:47:35 <quicksilver> Peaker: (so haskell's "=" is "=^{def}", yes)
09:47:54 <quicksilver> "==" is the closes thing haskell has to "=" in the other sense.
09:48:01 <tromp> > take 20 primes
09:48:02 <lambdabot>  Exception: <<loop>>
09:48:19 <quicksilver> Peaker: [[b]] means "the interpretation or implementation of b in some model"
09:48:21 <Peaker> any idea what [Time x a] would mean? 'x' would be cartesian product maybe?
09:48:39 <tromp> @let primes = 2:[x|x<-[3..],all((/=0).mod x)(takeWhile((<=x).(^2))primes)]
09:48:39 <quicksilver> Peaker: at least, that's what it normally means.
09:48:39 <tromp> > take 20 primes
09:48:39 <quicksilver> x is probably cartesian product, yes.
09:48:40 <lambdabot> <local>:7:0:     Multiple declarations of `L.primes'     Declared at: <local>...
09:48:40 <lambdabot>  Exception: <<loop>>
09:48:53 <Peaker> there's also  |_ e _|
09:48:54 <tromp> @undef primes
09:48:54 <lambdabot> Undefined.
09:49:02 <quicksilver> the word used for [[ - ]] is normally "denotation".
09:49:13 <tromp> @let primes = 2:[x|x<-[3..],all((/=0).mod x)(takeWhile((<=x).(^2))primes)]
09:49:13 <lambdabot> Defined.
09:49:16 <tromp> > take 20 primes
09:49:17 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
09:49:23 <quicksilver> Peaker: at^{~} I can't immediately guess.
09:49:39 <kpreid> Peaker: |_ _| is long-standing notation for floor
09:50:13 <quicksilver> yes, |_ 5.9 _| is 5
09:50:33 <Peaker> oh, its not floor here, he explains: "we write |_ -- _| for the value denoted by the Haskell term --, ...
09:50:42 <tromp> @pl \x -> all((/=0).mod x)(takeWhile((<=x).(^2))primes)
09:50:42 <lambdabot> ap (all . ((0 /=) .) . mod) (flip takeWhile primes . (. (^ 2)) . flip (<=))
09:50:42 <quicksilver> ah.
09:50:47 <quicksilver> it's another kind of denotaiton bracket then
09:50:51 <quicksilver> like [[ - ]]
09:50:52 <quicksilver> ;)
09:51:11 <Peaker> heh.. they should just define everything in Haskell/pseudo-haskell
09:51:28 <ddarius> Peaker: No, they should just define their terms as it looks like they do.
09:52:13 <Peaker> ddarius, makes skimming that much more difficult :)
10:05:31 <n00b> kpreid can't seem to get it to work
10:07:59 <n00b> guess i am hopeless
10:09:54 <byorgey> hpaste is down for anyone else?
10:09:55 <cjb> n00b: haskell's pretty hard, I don't think it means you're hopeless :)
10:11:33 <Peaker> the FRP from first principles explains that "Events" are implements as an infinite list of Maybes, which seems to imply that event-less times (represented by Nothing) incur computation overhead.  Is that really how FRP systems are implemented? Why not use a list that only includes the "just" values?
10:11:42 <Peaker> are implements->are implemented
10:11:47 <elliottt> byorgey: me too
10:11:47 <lambdabot> elliottt: You have 1 new message. '/msg lambdabot @messages' to read it.
10:12:49 <sclv> ah -- there you are
10:12:53 <byorgey> Peaker: I don't know a whole lot about it, but I think that's an implementation detail.  Some FRP implementations incur computation overhead for event-less times, and some don't.
10:13:07 <sclv> what's the question?
10:13:16 <byorgey> Peaker: maybe the point is that semantically, you can think about it *as if* it is an infinite list of Maybes
10:13:23 <elliottt> well, i think i ended up figuring it out.
10:13:32 <elliottt> so, i was confused why this didn't work:
10:13:34 <Peaker> byorgey, I see
10:13:42 <byorgey> Peaker: conal would be a good person to ask about this, though
10:13:48 <elliottt> $a.b:{b|$b$};separator=', '$
10:13:53 <elliottt> to make a comma separated list
10:13:53 <Peaker> byorgey, I think he's busy writing a paper for a deadline
10:13:57 <Bonus> hey guys, i made a function that for some natrual number n gives all combinations of 3 numbers a, b, c where a^2+b^2+c^2 = n --> http://dpaste.com/43972/
10:14:06 <Bonus> do you think it's okay or is there some way that could be written better?
10:14:35 <elliottt> however, $first(a.b):{b|$b$}$$rest(a.b):{b|, $b$}$ works just as well :)
10:14:38 <Peaker> another question is why Ord/Eq methods had to be explicitly lifted to Behaviors (==*, >*), and not specified as Ord/Eq instances..
10:15:41 <sclv> oh, yeah. its a quirk of the grammar. i think i implemented it right -- that separators should only be automatically tossed between elements of a list, not explict templates.
10:15:41 <Cale> Bonus: those list comprehensions are sort of pointless...
10:15:50 <elliottt> sclv: yeah, i think you did too
10:16:04 <Bonus> yeah?
10:16:10 <sclv> $a.b; separator=', '$ should also do the job though?
10:16:19 <Cale> [(a,b,c) | (a,b,c) <- foo]  is the same thing as  foo
10:16:30 <elliottt> sclv: hah, yeah, you're right :)
10:16:32 <elliottt> goodness.
10:16:34 <Bonus> ah yeah now that i see it :D
10:16:38 <resiak> Hmm.  Suppose f :: a -> b does not terminate; is it deemed strict?  After all, f _|_ = _|_.
10:16:38 <Bonus> you're right
10:17:01 <elliottt> i got too caught up in all this anonymous template business :)
10:17:02 <kpreid> Peaker: is the type of ==* Behavior a -> Behavior a -> Behavior Bool?
10:17:29 <kpreid> Peaker: if so, then it's because == is a -> a -> Bool -- note that the result is always a Bool
10:17:41 <sclv> man i really need to document this stuff. don't suppose you'd be up for writing a guest blog entry or wiki entry based on your experiences?
10:17:49 <Peaker> kpreid, ah, that explains it, thanks!
10:17:55 <byorgey> Peaker: he just submitted that paper a few days ago.
10:18:21 <Peaker> @seen conal
10:18:21 <lambdabot> I saw conal leaving #haskell and #ghc 12h 39m 5s ago, and .
10:18:25 <elliottt> sclv: yeah, i'd be happy to help out.  it's been trouble for me because i didn't know anything about string template in general before using your library, so i wasn't really sure about what i could do in the first place :)
10:19:42 <elliottt> sclv: it has worked out really well though.  i recommend it to anyone that needs that sort of thing
10:19:44 <Cale> Bonus: It also looks like you're putting things in the list which is less than n, and then filtering it out again, which seems like it's probably a bit wasteful...
10:20:17 <Bonus> yeah
10:20:28 <sclv> :-)
10:20:31 <Bonus> basically i build up all the combinations
10:20:33 <Bonus> and then i filter them
10:20:35 <byorgey> Bonus: that implemention will do a lot of unnecessary work, since e.g. quantumStatesUC n (1,1,1) calls qSUC n (2,1,1) and qSUC n (1,2,1), each of which call qSUC n (2,2,1)... so a bunch of results are calculated multiple times and then filtered out with nub
10:20:50 <sclv> there's crazy complex power in there -- even the main docs don't seem to really capture all the use patterns, even though they explain the individual bits. i sort of really got what it could do only through implementing it. so another voice explaining what the gotchas were would be pretty useful.
10:21:08 <Bonus> yeah, there's lots of redundant calculation going on :\
10:21:08 <elliottt> :)
10:21:39 <elliottt> yeah, i'd like to know more about what it's capable of.  their docs aren't all that great from the standpoint of "i've got the interface to the code working, what can i do with the template its self"
10:21:57 <byorgey> Bonus: I would suggest breaking it into two steps: (1) generate only those solutions for which a <= b <= c, (2) generate all permutations of those if you need them
10:22:09 <byorgey> the reason is that (1) can be done more efficiently, with no repeated computations
10:22:14 <Bonus> aha
10:22:34 <Bonus> i'll try to take at it from that perspective
10:22:34 <Bonus> thanks
10:23:15 <byorgey> just say [ (a,b,c) | c <- [1..n], b <- [1..c], a <- [1..b], a^2 + b^2 + c^2 == n ] or something like that
10:23:44 <Bonus> HMMM
10:23:47 <byorgey> you could probably also do it recursively in a way similar to what you already have
10:24:00 <Bonus> haha i didnt think of it that way
10:24:26 <byorgey> actually I guess c only needs to go up to (floor (sqrt n))
10:25:01 <Bonus> true
10:25:30 <Peaker> and b only needs to go up to floor (min c (n-(c^2))) ?
10:25:51 <Peaker> and a only up to (min b (n-(c^2)-(b^2))) ?
10:27:03 <Cale> If you're going to remain recursive like that, you can keep a <= b <= c by making the recursive cases (a,b,c+1), (a,b+1,c+1) and (a+1,b+1,c+1)
10:27:37 <Bonus> hmm yeah
10:27:42 <Bonus> that makes sense
10:31:05 <cygnusv> hello!
10:31:18 <Cale> But yeah, since you're only looking for the points whose norm is n, it's probably best to remove that degree of freedom altogether
10:31:32 <Cale> cygnusv: hello
10:32:45 <cygnusv> i need some help....i'm trying to download somthing from http://code.haskell.org but i don't know how :(
10:32:46 <lambdabot> Title: Index of /
10:33:22 <cygnusv> i've tried with darcs but it fails
10:33:29 <Cale> cygnusv: What are you trying to download?
10:33:42 <vincenz> @pl \a -> (a,[])
10:33:42 <lambdabot> flip (,) []
10:33:42 <cygnusv> code.haskell.org/HSP
10:33:48 <vincenz> > (,[]]) 1
10:33:48 <lambdabot>  Parse error at "[]])" (column 3)
10:33:52 <vincenz> > (,[]) 1
10:33:52 <lambdabot>  Parse error at "[])" (column 3)
10:33:57 <vincenz> you can't section tuples?
10:34:02 <Peaker> hmm.. a lot of the papers discussing arrows accompany arrow combinations with diagrams to explain the topology of the computation.. This strongly implies that an editor should probably edit the diagram directly, rather than its encoding as &&& and >>>/etc
10:34:40 <Baughn> Peaker: Those are explanatory devices, helpful when you have many more readers than writers, as for example in a paper
10:34:42 <Cale> cygnusv: Try one of the subdirectories of that.
10:34:48 <Baughn> Peaker: It may not be as efficient on working code
10:35:04 <gwern> @quote UN
10:35:04 <lambdabot> No quotes match. Do you think like you type?
10:35:16 <cygnusv> ialso have tried that
10:35:28 <Peaker> Baughn, I am not sure I can think of disadvantages of the diagram compared to the &&&/>>> notation
10:35:35 <gwern> @remember <shapr> GHC has more flags than the UN.
10:35:35 <lambdabot> Nice!
10:35:35 <Cale> darcs get http://code.haskell.org/HSP/hsp -- at least this worked for me
10:35:35 <lambdabot> Title: Index of /HSP/hsp
10:35:57 <dolio> When you use arrows heavily, there's a syntax for them rather than the bare combinators.
10:36:15 <cygnusv> Invalid repository:  http://code.haskell.org/hsp/hsp
10:36:16 <dolio> Which is probably easier than using the combinators.
10:36:24 <Peaker> dolio, yeah, but still the diagrams are considered more readable..
10:36:31 <cygnusv> darcs failed:  Failed to download URL http://code.haskell.org/hsp/hsp/_darcs/inventory : HTTP error (404?)
10:36:33 <Cale> cygnusv: Try with capital HSP for the first one.
10:36:45 <Cale> http://code.haskell.org/HSP/hsp
10:36:46 <lambdabot> Title: Index of /HSP/hsp
10:36:52 <Cale> Not http://code.haskell.org/hsp/hsp
10:37:08 <Cale> (which doesn't exist)
10:37:30 <monochrom> @quote GHC has more flags
10:37:30 <lambdabot> No quotes for this person. Just what do you think you're doing Dave?
10:37:37 <monochrom> @quote shapr GHC has more flags
10:37:38 <lambdabot> No quotes for this person. I've seen penguins that can type better than that.
10:37:42 <monochrom> @quote <shapr> GHC has more flags
10:37:43 <lambdabot> <shapr> says: GHC has more flags than the UN.
10:37:48 <monochrom> @quote gwern
10:37:48 <lambdabot> No quotes match. :(
10:37:52 <cygnusv> thanks!!
10:38:22 <Baughn> @faq Can you have more flags?
10:38:22 <lambdabot> The answer is: Yes! Haskell can do that.
10:38:23 <cygnusv> i feel really stupid now
10:38:24 <monochrom> Perhaps lambdabot's @quote should remove < and > across the board.
10:38:58 <monochrom> Or better yet, when it sees you using < and > , it educates you eagerly.
10:38:58 <cygnusv> thank you, Cale
10:39:02 <Peaker> why doesn't @quote simply search?
10:39:03 <Cale> cygnusv: no problem
10:39:16 <monochrom> It does simply search.
10:39:50 <shepheb> I think a large block of the database is missing?
10:39:50 <shepheb> @quote dons
10:39:52 <lambdabot> No quotes match.
10:40:00 <Bonus> how would i generate permutations of a tuple?
10:40:01 <Bonus> e.g.
10:40:05 <Bonus> i have (2,4,1)
10:40:10 <dolio> @quote <dons>
10:40:10 <lambdabot> No quotes match. My brain just exploded
10:40:13 <Bonus> and i want all permutations returned to me in a list
10:40:22 <dolio> @quote .*<dons>
10:40:22 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
10:40:29 <gwern> man, how do the quotes keep going missing? aren't they serialized and saved?
10:40:34 <kpreid> Bonus: it would be easier to permute a list
10:41:04 <Bonus> yeah i guess
10:41:12 <Bonus> but i'm having trouble conjuring up the algorithm :)
10:41:22 <dolio> @quote qwe1234
10:41:22 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
10:41:26 <dolio> Oh man.
10:41:31 <monochrom> @quote
10:41:31 <lambdabot> bos says:  i'm very pleased by the recent progress of the C++ standard.  it's gradually eroding the performance advantage of C++ compilers over GHC, without the simons having to do anything.
10:41:46 <gwern> Bonus: I have two algorithms which generate the permutations of a [String] based on capitalization :)
10:41:54 * gwern thinks that is probably not helpful
10:42:07 <dolio> @quote stereo
10:42:07 <lambdabot> No quotes match. There are some things that I just don't know.
10:42:11 <Bonus> haha yeah i need numbers pretty much :)
10:42:23 <shepheb> a whole load of classic quotes aren't being searched anymore
10:42:37 <mrd> stereo was removed because it beeped C*le too much
10:42:40 <gwern> game over, man! game over!
10:43:13 <dolio> Yeah, but I was quoted as being glad the stereo quote was gone, so I got pinged all the time for a while.
10:43:30 <dolio> I thought that was still in there.
10:43:46 <dolio> There seems to be nothing by me anymore.
10:43:55 <dolio> @quote JonHarrop
10:43:55 <lambdabot> No quotes match. stty: unknown mode: doofus
10:44:03 <dolio> @quote simonpj
10:44:03 <lambdabot> No quotes match. Do you think like you type?
10:44:04 <mrd> and lambdabot makes reality true, so you must not exist
10:44:22 <shepheb> @quote recursively
10:44:22 <lambdabot> No quotes match. You untyped fool!
10:44:31 <gwern> I am not quoted, therefore I do not exist?
10:44:32 <dolio> Lots missing.
10:44:53 <shepheb> yeah, where's "The truth is that d*ns and lambdabot recursively coded each other."
10:45:00 <dolio> @quote lambdabot Exception
10:45:00 <lambdabot> lambdabot says: Exception: I'm a moron
10:45:21 <kpreid> @let permute (x:y:xs) = (map (x:) $ permute (y:xs)) ++ (map (y:) $ permute (x:xs)); permute xs = xs
10:45:22 <lambdabot> <local>:2:92:     Occurs check: cannot construct the infinite type: t = [t]  ...
10:45:26 <kpreid> @let permute (x:y:xs) = (map (x:) $ permute (y:xs)) ++ (map (y:) $ permute (x:xs)); permute xs = [xs]
10:45:27 <lambdabot> Defined.
10:45:33 <kpreid> > permute [1,2,3,4]
10:45:36 <lambdabot>  [[1,2,3,4],[1,2,4,3],[1,3,2,4],[1,3,4,2],[2,1,3,4],[2,1,4,3],[2,3,1,4],[2,3,...
10:45:40 <dolio> There only seem to be about 4 quotes now.
10:45:49 <kpreid> Bonus: how's that?
10:45:50 <Bonus> oooh thanks!
10:45:52 <Bonus> :D
10:46:11 <kpreid> > length $ permute [1,2,3]
10:46:11 <lambdabot>  4
10:46:21 <kpreid> > permute [1,2,3]
10:46:21 <lambdabot>  [[1,2,3],[1,3,2],[2,1,3],[2,3,1]]
10:46:26 <kpreid> hm, misses some
10:46:40 <kpreid> ah, of course, it only puts the first two in the first position
10:46:48 <kpreid> I've solved this before but I forget how
10:46:56 <gnuvince> > permute [1]
10:46:57 <lambdabot>  [[1]]
10:47:08 <tromp> > permute []
10:47:08 <lambdabot>  [[]]
10:47:27 <gnuvince> ah, I didn't see the ; permite xs = [xs]
10:47:32 <Cale> We spent yesterday talking about it :P
10:47:35 <wagle_home> > permute [1,2]  -- breaks
10:47:36 <lambdabot>  [[1,2],[2,1]]
10:47:43 <wagle_home> oh..  guess not
10:47:45 <shepheb> kpreid: the last value never matches as x in (x:y:xs)
10:47:56 <kpreid> shepheb: just so
10:48:14 <wagle_home> thats what i was trying to do
10:48:53 <dolio> @quote Cale
10:48:53 <lambdabot> Cale says: "Betta watch your back when I'm packin' a nine/I'll pump you fulla holes like the rational line"
10:48:58 <Cale> > select [1,2,3]
10:48:58 <lambdabot>   Not in scope: `select'
10:49:26 <Cale> @let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
10:49:26 <lambdabot> Defined.
10:49:45 <shepheb> I think that's the one good thing about the quote problems: it found that gem. it cracked me up yesterday.
10:50:53 <Cale> > let perms [] = [[]]; perms xs = [y:zs | (y,ys) <- select xs, zs <- perms ys] in perms [1,2,3]
10:50:53 <lambdabot>  [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
10:52:04 <Peaker> > select [1,2,3]
10:52:05 <lambdabot>  [(1,[2,3]),(2,[1,3]),(3,[1,2])]
10:52:33 <tromp> pick would also be a good name
10:53:17 <dolio> Then you need to write MonadSelect (and monad comprehensions) so you can make an instance for Random(T).
10:53:34 <dolio> And get random permutations with the same code.
10:53:34 <Peaker> @pl f (a, b) = (a, x:b)
10:53:35 <lambdabot> f = second (x :)
10:54:01 <mrd> haskell has smileys
10:54:13 <Peaker> @src second
10:54:13 <lambdabot> Source not found. I feel much better now.
10:54:16 <Peaker> @type second
10:54:17 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
10:54:35 <Peaker> hmm.. how did the above become an arrow?
10:54:48 <Cale> > join (evalStateT . mapM (const $ StateT select)) [1,2,3]
10:54:49 <lambdabot>  [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
10:54:49 <dolio> (->) is an arrow.
10:55:08 <tromp> sure looks like one
10:55:09 <Cale> > join (evalStateT . mapM (const $ StateT select)) [1,2,3,4]
10:55:10 <lambdabot>  [[1,2,3,4],[1,2,4,3],[1,3,2,4],[1,3,4,2],[1,4,2,3],[1,4,3,2],[2,1,3,4],[2,1,...
10:56:10 <byorgey> Peaker: with a = (->), that type becomes (b -> c) -> (d,b) -> (d,c)
10:56:16 <Cale> Monad transformers are fun :)
10:56:53 * dolio has deja vu.
10:56:54 <monochrom> You Only Lift Twice.
10:57:06 <mrd> > second f :: (Expr, Expr)
10:57:06 <lambdabot>  Couldn't match expected type `Expr' against inferred type `(d, b)'
10:57:12 <shepheb> Cale: that's making my brain hurt. and you said it yesterday too, but this one is worse.
10:57:34 <Cale> I'm pretty sure this is the same one as yesterday.
10:57:49 <dolio> You were using replicateM yesterday.
10:57:53 <Peaker> Cale, what state is there in that? How does that work?
10:58:00 <Cale> Oh, yeah, but then I used mapM later :)
10:58:12 <Cale> The state is the list of remaining elements.
10:58:18 <Peaker> Cale, I thought StateT is useful only if you use get/put
10:58:32 <shepheb> :t select
10:58:33 <lambdabot> forall t. [t] -> [(t, [t])]
10:58:38 <Cale> :t StateT select
10:58:39 <lambdabot> forall t. StateT [t] [] t
10:58:51 <shepheb> whoa
10:59:02 <Cale> StateT select is used to nondeterministically pick elements from the state list.
10:59:10 <shepheb> :t StateT
10:59:11 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
10:59:15 <dolio> Oh, the join is duplicating the list.
10:59:19 <Cale> The state after running it leaves out the selected element
10:59:27 <Cale> The join is just in the reader monad
10:59:31 <dolio> Yeah.
11:00:22 <shepheb> okay, I can reconcile the types mentally. that makes it feel /possible/.
11:00:34 <Cale> If we pick as many elements from the list as there are elements in the list, then we've selected a permutation.
11:01:18 <Cale> By mapM'ing (const (StateT select)) over the list, we select the right number of elements
11:01:32 <Cale> (no need to compute the length of the list first)
11:01:39 <dolio> It's cute.
11:01:41 <Cale> and the state is initialised to the list as well
11:01:58 <Cale> (all the join does is to duplicate that parameter)
11:02:37 <Cale> Peaker: following that? :)
11:03:03 <Peaker> Cale, was away for a sec, and now someone's here. Thanks for the explanation I'll be sure to read it later :)
11:03:20 <Cale> all right :)
11:03:25 <shepheb> Cale: I am, in an awed "I can't see how one actually invents this" sort of way.
11:04:28 <Cale> I guess I started to learn to look for cases where a monad transformer data constructor can be applied.
11:04:54 <Cale> Once you have the idea of applying the StateT constructor, all the rest can be found by experimentation
11:05:13 <Cale> Another neat case was in the Cont monad
11:05:27 <Jaak> @type ContT
11:05:28 <lambdabot> forall a (m :: * -> *) r. ((a -> m r) -> m r) -> ContT r m a
11:05:34 <Cale> @type Cont
11:05:35 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
11:05:36 * shepheb duct tapes his cranium for this part.
11:05:56 <Jaak> shepheb: worry not, it will be implosion
11:06:15 <Cale> The problem was to take a bunch of 'with' style functions, and produce a combined one which makes all the resources available
11:06:27 <Cale> If you don't know what I mean by a with-style function...
11:06:32 <shepheb> I do
11:06:58 <shepheb> there are plenty in xmonad
11:06:59 <Cale> er, yeah, easier than finding an example :)
11:07:01 <Cale> right
11:07:21 <Cale> :t Foreign.Marshal.Array.withArray
11:07:22 <lambdabot> forall a b. (Foreign.Storable.Storable a) => [a] -> (GHC.Ptr.Ptr a -> IO b) -> IO b
11:07:36 <Cale> anyway...
11:08:12 <Jaak> @type sequence . map Cont
11:08:13 <lambdabot> forall a r. [(a -> r) -> r] -> Cont r [a]
11:08:20 <tromp> @src select
11:08:20 <lambdabot> Source not found.
11:08:21 <Jaak> @type runCont . sequence . map Cont
11:08:21 <lambdabot> forall a r. [(a -> r) -> r] -> ([a] -> r) -> r
11:08:26 <tromp> :t select
11:08:27 <Jaak> nice, nice
11:08:27 <lambdabot> forall t. [t] -> [(t, [t])]
11:08:32 <Cale> Yes :)
11:08:46 <shepheb> tromp: Cale defined it a little while ago.
11:08:57 <tromp> @undef select
11:08:57 <lambdabot> Undefined.
11:09:01 <tromp> @let select (x:xs) = (x,xs) : map (second (x:)) (select xs)
11:09:02 <lambdabot> Defined.
11:09:10 <Cale> tromp: undef doesn't work like that, by the way
11:09:19 <Cale> tromp: It just undefines everything
11:09:23 <tromp> ouch
11:09:40 <tromp> how to redefine one thing?
11:09:51 <Cale> also you missed the base case :)
11:09:55 <Cale> tromp: you can't
11:10:01 <Cale> give it a new name :)
11:10:05 <Cale> @unef
11:10:05 <lambdabot> ()
11:10:07 <Cale> @undef
11:10:07 <lambdabot> Undefined.
11:10:11 <lament> how do i use haddock?
11:10:12 <tromp> @let select [] = []
11:10:12 <lambdabot> Defined.
11:10:16 <Cale> @let select [] = []; select (x:xs) = (x,xs) : map (second (x:)) (select xs)
11:10:17 <lambdabot> <local>:1:0:     Warning: Pattern match(es) are overlapped              In th...
11:10:20 <Cale> sigh
11:10:22 <Cale> @undef
11:10:22 <lambdabot> Undefined.
11:10:24 <Cale> @let select [] = []; select (x:xs) = (x,xs) : map (second (x:)) (select xs)
11:10:24 <lambdabot> Defined.
11:10:25 <tromp> sorry:(
11:10:31 <lament> i mean, what's the usual command line to invoke haddock? Haddock -B <dir> file.hs ?
11:10:31 <Cale> s'ok
11:10:47 <dolio> @unef do { a <- m ; b <- n ; return (a + b) }
11:10:48 <lambdabot> do { a <- m; b <- n; return (a + b)}
11:10:50 <lament> cause if i try that, i get "parse error on input `data'"
11:10:51 <tromp> you can't use two @let's for the 2 cases?
11:11:01 <Cale> tromp: maybe...
11:11:17 <Cale> tromp: actually, that's plausible, as it's just writing them into a fine
11:11:19 <Cale> file*
11:11:52 <Cale> @unef join (*)
11:11:52 <lambdabot> ((*) >>= \ a -> a)
11:12:11 <dolio> Oh.
11:12:16 <dolio> Wouldn't have guessed that.
11:12:42 <Cale> lament: hmm
11:12:58 <monochrom> lament: I use haddock -B /usr/local/lib/ghc-6.8.2 -h file.hs
11:13:08 <idnar> unef?
11:13:10 <tromp> what's @unef?
11:13:13 <monochrom> "-h" means "generate html".
11:13:20 <lament> useful
11:13:21 <dolio> It gets spelling corrected to unpl.
11:13:23 <Cale> tromp: something which is spell corrected to @unpl
11:13:24 <lament> i still get parse error :(
11:13:27 <idnar> oh
11:13:38 <lament> ghci reads the file, but haddock dies
11:13:51 <shepheb> Cale: sorry I dropped my connection there; with-functions and Cont?
11:14:11 <shepheb> lament: Haddock < 2 doesn't know all the syntax that GHC 6.8 knows
11:14:26 <lament> it's haddock 2.0.0
11:14:29 <Cale> :t runCont . sequence . map Cont
11:14:30 <lambdabot> forall a r. [(a -> r) -> r] -> ([a] -> r) -> r
11:14:30 <tromp> does lambdabot have a help command, like @help unpl ?
11:14:34 <lament> here, i'll hpaste my module
11:14:38 <Deewiant> @help unpl
11:14:38 <lambdabot> pointful <expr>. Make code pointier.
11:14:41 <Cale> shepheb: check that out :)
11:14:45 <lament> i mean i won't, cause hpaste is down
11:15:00 <Cale> In a similar vein...
11:15:00 <tromp> @help pl
11:15:01 <lambdabot> pointless <expr>. Play with pointfree code.
11:15:18 <Cale> > \n -> runCont . replicateM n . Cont
11:15:19 <lambdabot>  Add a type signature
11:15:21 <Cale> :t \n -> runCont . replicateM n . Cont
11:15:21 <monochrom> lament: Does haddock work for some trivial module?
11:15:22 <lambdabot> forall a r. Int -> ((a -> r) -> r) -> ([a] -> r) -> r
11:15:32 <sclv> how hard would it be to fix lambdabot so it could handle local undefines?
11:15:55 <lament> monochrom: good point
11:16:01 <lament> it doesn't
11:16:05 <tromp> we really just need a redefine
11:16:06 <Cale> shepheb: with-style functions are continuation passing style, so it's obvious in hindsight
11:16:33 <monochrom> Very messed up haddock you possess... :)
11:17:20 <lament> yay! i fixed it
11:17:21 <monochrom> Lacrymol1gy: Your name sounds very sad. :)
11:17:28 <lament> i just need a module declaration
11:17:36 <monochrom> Oh! haha...
11:17:37 <lament> haddock dies with an unfriendly message without a module declaration
11:17:42 <Cale> shepheb: brain explosion? I think it's pretty sane actually :)
11:18:26 <shepheb> Cale: I'm mostly hung up because I don't understand Cont at all, or continuations more than the general sense of "passing a function to call instead of returning"
11:18:50 <Cale> :t Cont
11:18:51 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
11:18:51 <shepheb> I've never worked with continuations
11:19:30 <Cale> The Cont constructor takes a with-style function that has a continuation of type r, and wraps it up as a (Cont r a) value
11:19:47 <Cale> Of course, Cont r is a monad, so we get to use monad combinators then :)
11:19:59 <shepheb> if I had to guess, I would expect that   f >>= g under cont passes g as a continuation to f?
11:20:56 <Cale> Well, one way you can think of (Cont r a) computations is as magic boxes which answer questions of type r about a hypothetical value of type a
11:21:19 <shepheb> @src Cont (>>=)
11:21:19 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
11:21:48 <Cale> You can give such a computation a question (a -> r), and it responds with a value of type r
11:22:12 <Cale> (it might be easiest to think of r as Bool)
11:22:30 <shepheb> :t runCont
11:22:31 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
11:22:42 <Cale> runCont asks the question :)
11:23:42 <shepheb> the value a never exists?
11:24:03 <Cale> It might :)
11:24:10 <Cale> @src Cont return
11:24:10 <lambdabot> return a = Cont ($ a)
11:24:34 <Cale> (return x) is a box which answers questions honestly about the value x :)
11:24:56 <Cale> But the funny thing which Cont computations can do is instead just ask something else a question.
11:27:21 <Cale> So  x >>= f, when given a question c, asks x the question "how would the Cont computation constructed by f when given your value respond when asked c?"
11:30:06 <Cale> If that makes any sense :)
11:30:16 <Deewiant> *head asplode*
11:30:26 <shepheb> Cale: I'm working on it, and reading the wikibook page to get a leg up on Cont.
11:30:39 <Cale> It's probably easiest just to stare at the types
11:30:59 <Cale> rather than worrying about what the things actually *do*, because in some sense, it's entirely determined by the type
11:31:12 <Cale> Djinn can even infer it :)
11:31:21 <Cale> @djinn-env
11:31:22 <lambdabot> data () = ()
11:31:22 <lambdabot> data Either a b = Left a | Right b
11:31:22 <lambdabot> data Maybe a = Nothing | Just a
11:31:22 <lambdabot> data Bool = False | True
11:31:22 <lambdabot> data Void
11:31:23 <lambdabot> type Not x = x -> Void
11:31:26 <lambdabot> class Eq a where (==) :: a -> a -> Bool
11:31:30 <Deewiant> @djinn (a -> r) -> r
11:31:30 <lambdabot> -- f cannot be realized.
11:31:49 <Cale> @djinn-add type Cont r a = ((a -> r) -> r)
11:32:05 <Cale> @djinn Cont r a -> (a -> Cont r b) -> Cont r b
11:32:05 <lambdabot> f a b c = a (\ d -> b d c)
11:32:49 <dolio> I think I find it easier to think in terms of the sequence of computation for Cont.
11:33:09 <dolio> In fact, I think the monadic style makes it easier to figure out what's goin on than in, say, Scheme.
11:33:29 <shepheb> the connection with the \-calculus way of encoding sum types as functions helped.
11:34:32 <shepheb> okay, I'm getting there
11:34:44 <dolio> Since instead of, say, "(+ 1 (call/cc ...))" you have "one >>= \a -> callCC (...) >>= \b -> return (a + b)".
11:34:53 <dolio> So the evaluation order is clearer.
11:35:16 <nomeata> shepheb: what wikibook page exatcly are you reading on Cont?
11:35:28 <shepheb> nomeata: http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
11:35:36 <nomeata> shepheb: merci
11:35:39 <dolio> In 'a >>= f >>= g >>= ...' the continuation of 'a' is '\x -> f x >>= g >>= ...' and so on.
11:35:51 <dolio> Or something close.
11:39:01 <dolio> And 'm :: Cont r a' is something that calls its continuation '\x -> f x >>= g >>= ...' with something of type a.
11:39:07 <lament> yay <3 haddock
11:41:26 <dolio> It's even weirder in strict languages when you use let.
11:43:52 <ehird> lament: wow you found osmething you liked
11:43:53 <ehird> shocking
11:45:02 <dolio> You have to think about whether in 'let foo = ... call/cc ... in ...bar...' the continuation in foo captures the all of bar, or if it only captures the continuation where it's used in bar.
11:47:15 <shepheb> in a chain of Cont actions, f >>= g >>= h, the types are f :: a -> Cont r b , g :: b -> Cont r c, h :: c -> Cont r d    ? and the overall type is .... d -> Cont r a ? gah.
11:48:04 <Lacrymology> monochrom: it's all about Tool
11:48:14 <dolio> shepheb: Thta doesn't look right.
11:48:16 <lament> ehird: for about thirty seconds, before i found out you have to escape quotation marks in comments (\") if you want them to show up as quotation marks in the doc
11:48:46 <dolio> shepheb: Should be 'a -> Cont r d'.
11:48:55 <Otoom> Gues, in this.  sum [n | n <- [1..1000-1], n `mod` 5 == 0 || n `mod` 3 == 0] what is the n for?
11:49:01 <Otoom> Whats it mean?
11:49:05 <ehird> lament: yeah that sucks
11:49:17 <byorgey> Otoom: n <- [1..1000-1] says "try every value of n from 1 to 999"
11:49:22 <kpreid> Otoom: "n <-" is where n is bound
11:49:38 <kpreid> Otoom: "[ n |" says the elements of the result list are the values of n
11:49:48 <Otoom> So if i put x i would change  ], n to ], x `mod` etc etc
11:50:07 <byorgey> right
11:50:18 <Otoom> Ah im getting the hang of this now =D
11:50:25 <byorgey> > [ (n,2) | n <- [1..5] ]
11:50:25 <lambdabot>  [(1,2),(2,2),(3,2),(4,2),(5,2)]
11:50:34 <byorgey> > [ (n,2) | n <- [1..5], even n ]
11:50:35 <lambdabot>  [(2,2),(4,2)]
11:50:53 <Otoom> Thats like the one in Programming in haskell book =D
11:51:06 <byorgey> is it? I'm just making up random examples =)
11:51:12 <Otoom> Lol yeah it is.
11:51:29 <byorgey> > [ (x,y) | x <- [1..3], y <- [2..5] ]  -- how about with two variables?
11:51:29 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(2,2),(2,3),(2,4),(2,5),(3,2),(3,3),(3,4),(3,5)]
11:51:45 <Otoom> thats exactly the same =D
11:53:00 <Otoom> >sum [x | x <- [1..999], x `mod` 3 ==0 || x `mod` 5 == 0]
11:53:12 <Otoom> > sum [x | x <- [1..999], x `mod` 3 ==0 || x `mod` 5 == 0]
11:53:12 <lambdabot>  233168
11:53:15 <Otoom> =D
11:53:23 <Otoom> can i also ask
11:53:35 <Otoom> why do i need sum [x | x
11:53:38 <Otoom> why not just
11:53:45 <Otoom> sum [x <- [1..999 etc
11:53:54 <byorgey> Otoom: that's just the way it is =)
11:53:56 <shepheb> > [ 4 | x <- [1..4] ]
11:53:56 <lambdabot>  [4,4,4,4]
11:53:58 <Otoom> okay
11:54:00 <Deewiant> > sum [x + x | x <- [1..999] ]
11:54:01 <lambdabot>  999000
11:54:04 <shepheb> it can be arbitrary
11:54:12 <Otoom> Y'all too good at Haskell =D
11:54:13 <byorgey> I could imagine having [x <- [1..999] ... ] as syntax sugar for [x | x <- [1..999] ...
11:54:19 <byorgey> but it isn't =)
11:54:31 <byorgey> Otoom: often, you want something other than just [ x | ...  for example:
11:54:35 <shepheb> [1.999] >>= \x -> ...
11:54:35 <trez> > [x+1|x<-[a,b,c,d]]
11:54:35 <lambdabot>  [a + 1,b + 1,c + 1,d + 1]
11:54:38 <byorgey> > [ x * 3 | x <- [1..10] ]
11:54:39 <lambdabot>  [3,6,9,12,15,18,21,24,27,30]
11:54:47 <Otoom> dont confuse me just yet =D
11:55:02 <shepheb> man, that reflection is such a great teaching tool
11:55:19 <shepheb> foldr f z [a,b,c]
11:55:22 <shepheb> > foldr f z [a,b,c]
11:55:22 <tromp> @let choose2 k = k * (k-1) `div` 2
11:55:22 <lambdabot> Defined.
11:55:22 <lambdabot>  f a (f b (f c z))
11:55:33 <tromp> @let sumKsUnder k n = k * choose2 (1 + (n-1)`div`k)
11:55:34 <lambdabot> Defined.
11:55:45 <tromp> > sumKsUnder 3 1000 + sumKsUnder 5 1000 - sumKsUnder 15 1000
11:55:46 <lambdabot>  233168
11:56:17 <byorgey> hehe, clever tromp =
11:56:20 <Otoom> > [5 | x <- [1..100]]
11:56:20 <lambdabot>  [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
11:56:21 <byorgey> er, =)
11:56:25 <Otoom> haha
11:56:27 <Otoom> nice
11:56:34 <Otoom> when doing that
11:56:39 <kpreid> Otoom: better [5 | _ <- ...
11:56:42 <Otoom> x is taking 1 by one
11:56:51 <Otoom> correct?
11:56:56 <dolio> > replicate 100 5
11:56:56 <lambdabot>  [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
11:56:57 <Otoom> oh no
11:57:01 <Otoom> lmao
11:57:02 <Otoom> nice
11:57:08 <Deewiant> > repeat 5
11:57:08 <lambdabot>  [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
11:57:15 <trez> > [5..]
11:57:15 <lambdabot>  [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31...
11:57:16 <Otoom> are they standard functions?
11:57:23 <byorgey> yes.
11:57:28 <Otoom> cool
11:57:38 <wagle> > [5,5..]
11:57:39 <lambdabot>  [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
11:57:59 <Otoom> > [5,5,6,6..]
11:57:59 <lambdabot>  Parse error at "..]" (column 9)
11:58:02 <Otoom> damnit
11:58:04 <Otoom> :P
11:58:12 <byorgey> Otoom: hehe, it's not THAT smart =)
11:58:13 <mrd> @oeis 5,5,6,6
11:58:14 <lambdabot> pi(n), the number of primes <= n. Sometimes called PrimePi(n) to distinguish ...
11:58:14 <lambdabot> [0,1,2,2,3,3,4,4,4,4,5,5,6,6,6,6,7,7,8,8,8,8,9,9,9,9,9,9,10,10,11,11,11,11,11...
11:58:14 <Deewiant> > cycle [5,5,6,6]
11:58:14 <lambdabot>  [5,5,6,6,5,5,6,6,5,5,6,6,5,5,6,6,5,5,6,6,5,5,6,6,5,5,6,6,5,5,6,6,5,5,6,6,5,5...
11:58:18 <Otoom> damn
11:58:29 <dolio> [a,b..] is sugar for enumFromThen a b
11:58:42 <dolio> And [a,b..c] is enumFromThenTo a b c
11:59:07 <Otoom> > sum [ 2 | z <- [1..10]]
11:59:07 <lambdabot>  20
11:59:10 <Otoom> =D
11:59:17 <Otoom> 2 x 10 in other words
11:59:21 <byorgey> yup =)
11:59:21 <Otoom> haha nice
11:59:24 <Otoom> im getting this
11:59:24 <Otoom> now
11:59:31 <Otoom> easier now than it was at the start,
12:00:00 <trez> > sum [ 2 | z <- [1..10]] :: Expr
12:00:00 <lambdabot>  0 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2
12:00:41 <Otoom> haha
12:00:55 <tromp> > primes
12:00:55 <lambdabot>   Not in scope: `primes'
12:00:56 <mrd> you can tell it's a foldl
12:00:57 <Deewiant> Otoom: that (Expr) isn't standard, though.
12:01:19 <mrd> > foldr (+) 0 [1 .. 10] :: Expr
12:01:20 <lambdabot>  1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + 0)))))))))
12:01:20 <tromp> @let primes = 2:[x|x<-[3..],all(\p->x`mod`p>0)(takeWhile(\p->p*p<=x)primes)]
12:01:21 <lambdabot> Defined.
12:01:42 <Deewiant> mrd: you can't tell between foldl and foldl'
12:01:50 <mrd> > nubBy (\ x y -> y `mod` x == 0) [2..]
12:01:50 <Otoom> > sum [ x | x <- [0..31373], x `mod` 2 ==0]
12:01:51 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:01:51 <lambdabot>  246066282
12:02:01 <mrd> Deewiant: you could if you changed the parameters
12:02:03 <Otoom> yay correct answer
12:02:11 <Otoom> The question was, Get the Sum of all the even numbers between 0 and 31373
12:02:19 <Deewiant> mrd: how?
12:02:29 <mrd> > foldl (\ x y -> 1) 0 undefined
12:02:30 <lambdabot>  Undefined
12:02:32 <mrd> oops
12:02:36 <tromp> > sumKsUnder 2 31373
12:02:37 <lambdabot>  246066282
12:02:38 <Deewiant> bah, undefined :-)
12:02:40 <Otoom> People: how would i go about doing this What is the 10001st prime number?
12:02:41 <Otoom> =D
12:02:48 <mrd> hmm weird
12:02:49 <Deewiant> > primes !! 10001
12:02:50 <lambdabot>  104759
12:02:51 <mrd> is foldl too strict?
12:02:57 <Otoom> holy cack
12:03:00 <mrd> @src foldl
12:03:00 <lambdabot> foldl f z []     = z
12:03:00 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:03:03 <Otoom> whats the !! mean?
12:03:07 <byorgey> Otoom: you have to define 'primes' first though =)
12:03:08 <mrd> Otoom: list index
12:03:08 <atsampso1> > primes !! 1
12:03:09 <lambdabot>  3
12:03:14 <atsampso1> 3 isn't the first prime number ;)
12:03:15 <Deewiant> > [1,2,3,4,5] !! 0
12:03:16 <lambdabot>  1
12:03:21 <mrd> > primes !! 0
12:03:22 <lambdabot>  2
12:03:22 <tromp> > primes!!0
12:03:23 <lambdabot>  2
12:03:23 <Deewiant> atsampso1: shh, it was only a hint ;-)
12:03:27 <mrd> happy?
12:03:38 <tromp> > primes!!1000
12:03:39 <lambdabot>  7927
12:03:41 <tromp> > primes!!10000
12:03:41 <mrd> > nubBy (\ x y -> y `mod` x == 0) [2..] :: [Expr]
12:03:42 <lambdabot>  104743
12:03:42 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:03:43 <Deewiant> @src primes
12:03:43 <lambdabot> Source not found. You speak an infinite deal of nothing
12:04:00 <Otoom> sooo... doing it in the form of [x|x <- [1..10001], .....
12:04:02 <Otoom> what would i do.
12:04:34 <byorgey> Otoom: no, you want the 10001st prime, not the last prime less than 10001
12:04:50 <mrd> > nubBy (\ x y -> y `mod` x == 0) [2..] !! 10000
12:04:53 <Otoom> oh yeah.
12:04:55 <lambdabot> Terminated
12:04:56 <Otoom> how i do it?
12:05:02 <byorgey> Otoom: a simple way to do it might be to say  primes = [ p | p <- [1..], isPrime p ]
12:05:05 <mrd> (ain't efficient)
12:05:20 <byorgey> Otoom: then write an 'isPrime' function that tells you whether a number is prime
12:05:33 <byorgey> then get the 10001st element of the 'primes' list
12:05:38 <Otoom> thats the part i need help with -D#
12:05:41 <byorgey> quite inefficient, but it should work
12:05:42 <Otoom> =D *
12:05:42 <mrd> > runSTArray (newArray (1,10) 0)
12:05:43 <lambdabot>   Not in scope: `newArray'
12:06:13 <byorgey> Otoom: well, first, what's the type of 'isPrime'?
12:06:22 <mrd> mm why doesn't lambdabot have Data.Array.MArray in scope
12:06:32 <Otoom> hold on
12:06:34 <mrd> > runSTArray (Data.Array.MArray.newArray (1,10) 0)
12:06:34 <lambdabot>   Not in scope: `Data.Array.MArray.newArray'
12:06:38 <mrd> > runSTArray (Data.Array.ST.newArray (1,10) 0)
12:06:39 <lambdabot>   Not in scope: `Data.Array.ST.newArray'
12:06:39 <Otoom> @src primes
12:06:39 <lambdabot> Source not found. Take a stress pill and think things over.
12:06:46 <tromp> @pl \ x y -> y `mod` x == 0
12:06:46 <Otoom> @src primes
12:06:47 <lambdabot> flip flip 0 . ((==) .) . flip mod
12:06:47 <lambdabot> Source not found. Just try something else.
12:06:53 <Otoom> @src primes !!
12:06:53 <lambdabot> Source not found. Wrong!  You cheating scum!
12:07:00 <Otoom> hmm#
12:07:03 <Otoom> stuff u bot =D
12:07:11 <byorgey> Otoom: there is no such thing, not in the standard libraries
12:07:24 <Deewiant> well, @src knows about stuff outside the standard libraries :-)
12:07:30 <Otoom> oh so the bot has it declared within him~?
12:07:32 <Otoom> sort of thing
12:07:32 <Deewiant> outside Haskell even
12:07:35 <Deewiant> @src []
12:07:36 <lambdabot> data [] a = [] | a : [a]
12:07:41 <byorgey> ok, yes, but not stuff that people define with @let =)
12:07:59 <Otoom> brb shower
12:08:07 <byorgey> Otoom: no, someone defined 'primes' earlier by saying @let primes = ...
12:08:09 <mrd> who runs lambdabot now
12:08:19 <byorgey> mrd: Cale does, I think
12:08:23 <tromp> @let primes = 2:[x|x<-[3..],all(\p->x`mod`p>0)(takeWhile(\p->p*p<=x)primes)]
12:08:24 <lambdabot> <local>:5:0:     Multiple declarations of `L.primes'     Declared at: <local>...
12:08:46 <mrd> @tell cale can you have MArray/ST stuff in scope for @run?
12:08:46 <lambdabot> Consider it noted.
12:09:20 <tromp> @let slowprimes = nubBy(\x y->y`mod`x==0)[2..]
12:09:20 <lambdabot> Defined.
12:09:30 <tromp> > slowprimes!!10000
12:09:33 <mrd> too slow
12:09:36 <lambdabot> Terminated
12:09:42 <tromp> > slowprimes!!1000
12:09:42 <lambdabot>  7927
12:10:42 <mrd> > drop 10000 $ nubBy (\ x y -> y `mod` x == 0) [2..]
12:10:49 <lambdabot> Terminated
12:10:55 <mrd> not lazy enough!
12:11:33 <tromp> it tries dividing each x by 2..x-1
12:11:46 <tromp> instead of by all primes up to sqrt(x)
12:12:49 <Jedai> @let betterPrimes = 2:[x|x<-[3..],all(\p->x`mod`p>0)(takeWhile(\p->p*p<=x)primes)]
12:12:50 <lambdabot> Defined.
12:13:04 <Jedai> >betterPrimes !!5000
12:13:25 <Jedai> Still too slow
12:13:34 <Jedai> > betterPrimes !!5000
12:13:35 <lambdabot>  48619
12:13:41 <Jedai> > betterPrimes !! 10000
12:13:42 <lambdabot>  104743
12:13:56 <Jedai> Ah,no, fine
12:14:01 <sethk> :t openFile
12:14:02 <lambdabot> Not in scope: `openFile'
12:14:08 <tromp> > slowprimes!!100000
12:14:08 <sethk> :t IO.openFile
12:14:10 <lambdabot> FilePath -> GHC.IOBase.IOMode -> IO GHC.IOBase.Handle
12:14:14 <lambdabot> Terminated
12:14:16 <tromp> > primes!!100000
12:14:18 <lambdabot>  1299721
12:14:23 <tromp> > primes!!1000000
12:14:28 <shepheb> Jedai: do you really mean "primes" at the end there, or "betterPrimes"?
12:14:29 <lambdabot> Terminated
12:14:49 <Jedai> @let betterPrimes = 2:[x|x<-[3..],all(\p->x`mod`p>0)(takeWhile(\p->p*p<=x) betterPrimes)]
12:14:49 <lambdabot> <local>:7:0:     Multiple declarations of `L.betterPrimes'     Declared at: <...
12:15:13 <Deewiant> > let primes = 2 : filter (\x -> all (\y -> mod x y /= 0) (takeWhile (<= floor (sqrt.fromIntegral$ x)) primes)) [3,5..] in primes !! 10000
12:15:13 <Jedai> shepheb: Well they're the same ^^'
12:15:14 <lambdabot>  104743
12:15:31 <Deewiant> hmm, I have been beatten by multiple minutes
12:15:33 <Deewiant> ah well
12:15:49 <Jedai> shepheb: Though I meant betterPrimes
12:26:15 <tromp> i'm timing printing all primes < 2 billion
12:28:27 <shepheb> is there a proof of there being infinite primes?
12:28:41 <idnar> yes, several
12:28:53 <Cale> shepheb: Yes, it's often one of the first proofs you see in a mathematics program
12:28:58 <sieni> what's an infinite prime?
12:29:04 <Cale> sieni: hehe
12:29:18 <Cale> I think we can assume he means infinitely many primes :)
12:29:30 <sieni> ^_^
12:29:51 <dolio> > 10^1000
12:29:51 <lambdabot>  1000000000000000000000000000000000000000000000000000000000000000000000000000...
12:29:52 <shepheb> Cale: well, there was a fair bit of undergrad math as part of my CS (at Waterloo), but I couldn't remember that, or convince myself either way off the top of my head.
12:29:58 <Cale> The standard proof starts by assuming for purposes of contradiction that instead there are only finitely many primes.
12:30:00 <tromp> it's an ordinal >= omega with no ordinal factor other than 1 and itself:)
12:30:08 <Cale> Say, p_1,...,p_n
12:30:08 <idnar> http://en.wikipedia.org/wiki/Prime_number#There_are_infinitely_many_prime_numbers
12:30:10 <lambdabot> http://tinyurl.com/4jx7x
12:30:26 <Cale> Then we can form their product, which is divisible by each of them
12:30:32 <Cale> p_1 p_2 ... p_n
12:30:36 <Cale> and then add one to it
12:30:36 <sieni> shepheb: well, the easiest proof is that if p were the largest prime, then p!+1 wouldn't be divisible by any of the numbers 2,...,p
12:30:58 <idnar> heh, I think I learned the version using factorials from GEB:EGB
12:31:02 <sieni> shepheb: so p!+1 must be a prime or have a prime factor larger than p
12:31:03 <Cale> p_1 p_2 ... p_n + 1 cannot be divisible by any of the p_k's
12:31:09 <shepheb> ah yes, I have seen that.
12:31:16 <roconnor> my proof that there are not a finite number of primes -> http://www.natutech.nl/00/NT/nl/49/nieuws/10525/Euclides_bewijzen%A0per_computer.html
12:31:18 <lambdabot> Title: Natuurwetenschap & Techniek : Euclides bewijzen per computer, http://tinyurl.com/5kq8od
12:33:10 <Cale> ah, computer proofs, so needlessly unreadable :)
12:33:26 <jberryman> what is the best way to compute all the factors of an integer. I have a function for the prime factors, and a braindead inefficient version for all factors
12:33:44 <Cale> jberryman: Recombine the prime factors in all possible ways
12:33:48 <Otoom> > [(x, y) <- [1..9]]
12:33:48 <lambdabot>  Parse error at "<-" (column 9)
12:33:53 <Otoom> hmm ah well
12:33:56 <roconnor> Cale: at least they are correct.
12:34:09 <shepheb> Otoom: need the output part on the left of a |
12:34:17 <Otoom> oh yh
12:34:27 <Cale> roconnor: But in a technical way which is thoroughly unconvincing :)
12:34:27 <Otoom> > [(x, y) | x <- [1..9]]
12:34:28 <lambdabot>  [(1,y),(2,y),(3,y),(4,y),(5,y),(6,y),(7,y),(8,y),(9,y)]
12:34:39 <Jedai> tromp: So how did the timing go ?
12:34:42 <jberryman> Cale: yeah, i'm having trouble wrapping my head around hoew to do that
12:34:50 <tromp> Jedari: still going
12:34:54 <Otoom> > [(x, y) | x <- [1..9], y <-  [1..3]]
12:34:55 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(5,...
12:34:57 <thetallguy> ugh.  echoing recent discussions on the cafe, the fact that take and drop have Int arguments is lame.
12:35:14 <roconnor> Cale: are you a luddite?
12:35:15 <Jedai> tromp: I have a prime generator here that do it in 1.5s
12:35:19 <Cale> jberryman: You might start by writing a function which given a list xs, produces a list of all the sublists of xs.
12:35:39 <roconnor> Cale: computer checked proofs are way more convincing that someone wavying their hands.
12:35:40 <tromp> that's why i want to know how slow a naive haskell version is
12:35:42 <Cale> roconnor: Not at all. I just find proofs written for computers to be horrible.
12:35:47 <Jedai> tromp: Very
12:36:02 <roconnor> Cale: do you find algorithms written for computers horrible as well?
12:36:21 <Jedai> tromp: If you mean the false sieve that's showed as example of functional programming simplicity...
12:36:49 <Cale> roconnor: There are practical considerations which make the Curry Howard isomorphism irrelevant here.
12:37:04 <tromp> i mean the oneliner we defined above
12:37:30 <tromp> primes = 2:[x|x<-[3..],all(\p->x`mod`p>0)(takeWhile(\p->p*p<=x)primes)]
12:37:30 <Jedai> tromp: Which one, nubBy version or the one with all and takeWhile ?
12:37:52 <Cale> roconnor: and yeah, compared to English descriptions of what to do, algorithms written for a computer are often pretty obscure.
12:38:09 <tromp> i'm guessing you cant do much faster in a one liner
12:38:14 <Jedai> tromp: Yes, it's a false sieve, and so it's very slow
12:38:22 <Deewiant> tromp: replace [3..] with [3,5..] ;-)
12:38:28 <tromp> how long is your real sieve?
12:38:48 <Otoom> > [(y,z) | y <- [1..9], z <- [1..2]]
12:38:48 <lambdabot>  [(1,1),(1,2),(2,1),(2,2),(3,1),(3,2),(4,1),(4,2),(5,1),(5,2),(6,1),(6,2),(7,...
12:38:57 <Deewiant> Jedai: how is that false?
12:39:13 <tromp> it still does divisions
12:39:39 <Deewiant> how does that make it 'false'? :-P
12:39:51 <Jedai> tromp: Well, it's not my real sieve and you can do many version I guess, but the one I just tested is 4 lines long, 12 if you count some utility functions
12:40:16 <tromp> can you show those 4 lines?
12:40:56 <roconnor> Cale: I wasn't really meaning to draw on Curry-Howard, I was just making an analogy.  It just so happens that the analogy is actually formal.
12:41:01 <Jedai> Deewiant: You really didn't follow the debate on this ? The problem is each number is checked against each primes inferior to it (or to its sqrt)
12:41:22 <roconnor> Cale: But I'm glad you are fair and find algorithms written for computers horrible as well.
12:41:29 <Jedai> Deewiant: In a "real" sieve, you check out each number only one time
12:41:49 <Jedai> tromp: I think this version is on the Wiki
12:41:53 <Deewiant> ah, I see what you're getting at
12:42:37 <Jedai> Deewiant: Anyway search Haskell-Cafe and you'll see a great debate on the question (sparkled by a paper which you can find in the functional pearl I think)
12:43:20 <Deewiant> thanks, I will
12:43:41 <Jedai> tromp: http://www.haskell.org/haskellwiki/Prime_numbers has it
12:43:42 <lambdabot> Title: Prime numbers - HaskellWiki
12:43:55 <tromp> thx
12:44:41 * int80_h is setting up a haskell station at home, slowly but surely
12:45:17 <Jedai> tromp: It's the one with diff and merge (which are more generally useful functions)
12:46:01 <__pao__> is lamdabot dead?
12:46:07 <shepheb> > 1+1
12:46:07 <lambdabot>  2
12:46:12 <__pao__> ops
12:46:15 <__pao__> sorry
12:46:54 <nomeata> @darcs
12:46:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
12:46:59 <nomeata> @lambdabot
12:46:59 <lambdabot> Unknown command, try @list
12:47:03 <nomeata> @list
12:47:03 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
12:47:09 <shepheb> ?botsnice
12:47:09 <lambdabot> :)
12:47:15 <shepheb> hpaste bot is still MIA
12:48:34 <nomeata> ouh, sorry, I started trying stuff with /msg lambdabot, but forgot about it the next few lines :-)
12:49:16 <__pao__> nomeata: it has been useful ;-)
12:49:45 <shepheb> a new meaning for learning from someone else's mistake
12:50:28 <__pao__> :-)
12:51:20 <__pao__> what's the haskell for python ", ".join(["1","2","3"])?
12:51:31 <shepheb> :t intersperse
12:51:32 <lambdabot> forall a. a -> [a] -> [a]
12:51:35 <__pao__> what's the best, general way to get these answers?
12:51:46 <Heffalump> concat $ intersperse ", " ["1", "2", "3"]
12:51:48 <Jedai> __pao__: intercalate ", " ["1"...]
12:51:58 <Heffalump> oh, is intercalate in the library now?
12:52:07 <byorgey> Heffalump: yes, in 6.8
12:52:08 <Jedai> Heffalump: Yes, since 6.8 sure
12:52:19 <__pao__> thanks every one
12:52:21 <shepheb> oh, I thought it was still just in \bot's Caleskell
12:52:23 <byorgey> __pao__: the best, most general way is to ask here =)
12:52:37 <__pao__> byorgey: ;-)
12:52:44 <sm> __pao__: I think: 1. ask here, 2. hoogle for likely words, 3. check haskell wikibook for examples
12:52:45 <Jedai> @hoogle intercalate
12:52:45 <lambdabot> Data.List.intercalate :: [a] -> [[a]] -> [a]
12:52:45 <lambdabot> Data.ByteString.intercalate :: ByteString -> [ByteString] -> ByteString
12:52:45 <lambdabot> Data.ByteString.Char8.intercalate :: ByteString -> [ByteString] -> ByteString
12:53:00 <__pao__> sm: precious ;-)
12:53:17 <__pao__> @src intercalate
12:53:18 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
12:53:32 <tromp> Jedai, the 'real' sieve is taking way longer than 1.5 s
12:53:57 <sethk> For Data.Set, I have two Data.Set String sets.  I then use intersection to find the common members.  Now I want the first set with the intersection elements removed.  Does difference help me with that?
12:54:23 <__pao__> @src intersperse
12:54:23 <lambdabot> intersperse _   []     = []
12:54:23 <lambdabot> intersperse _   [x]    = [x]
12:54:23 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
12:54:25 <Jedai> tromp: To display all number < 2000000, here it takes 1.5s (of course compiled and redirected to /dev/null, you're measuring the speed of your terminal else)
12:54:37 <Jedai> s/number/primes/
12:54:47 <tromp> i said 2 billion:)
12:54:59 <sethk> I can use filter and member
12:55:27 <sjanssen> sethk: 'difference s t' is the set of elements of s not contained in t
12:55:28 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
12:55:36 <tromp> also , i redirect to /dev/null :)
12:55:39 <byorgey> sethk: can't you just do   difference a (intersection a b) ?
12:55:43 <tromp> -bash-3.2$ time ./primes> /dev/null
12:55:44 <sethk> sjanssen, ok, which is just what I need.  Thanks
12:55:51 <sethk> byorgey, yes, good point
12:56:42 <dolio> @seen shapr
12:56:43 <lambdabot> shapr is in #scannedinavian, #haskell-blah and #haskell. I last heard shapr speak 15h 40m 48s ago.
12:56:56 <tromp> difference a b shld be the same
12:57:20 <nomeata> dons: Hi. Are the darcs2git translators for ohloh running regularily? I miss some recent commits on HAppS and xhtml.
12:57:28 <sethk> tromp, oh, you're right
12:57:36 <sethk> don't need the intersection at all  :)
12:57:37 <dcoutts> @seen dons
12:57:37 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc and #haskell. I last heard dons speak 14h 48m 26s ago.
12:57:46 <Jedai> tromp: 2 billions, I'll assume that you means 2 * 10^9 ?
12:57:55 <dcoutts> nomeata: he's almost certainly traveling atm
12:58:08 <__pao__> @hoogle style
12:58:08 <lambdabot> Text.ParserCombinators.Parsec.Language.haskellStyle :: LanguageDef st
12:58:08 <lambdabot> Text.ParserCombinators.Parsec.Language.javaStyle :: LanguageDef st
12:58:21 <nomeata> dcoutts: ok, thx
12:58:41 <__pao__> is there an ufficial style guide / coding convention for haskell?
12:59:29 <mrd> choose cryptic variable names loosely based on greek characters from esoteric academic papers
12:59:39 <mrd> try to put as much code as possible on one line
12:59:41 <byorgey> __pao__: not really.  there are various conventions, but not really written down anywhere
12:59:49 <byorgey> __pao__: also, ignore mrd ;)
13:00:18 <__pao__> mrd: LOL
13:00:33 <Jedai> __pao__: You can start by looking at the standard libs
13:00:33 <byorgey> mrd: you forgot: run everything through @pl
13:00:37 <mrd> ooh
13:00:49 <__pao__> :-)
13:00:52 <mrd> practice pointless programming
13:00:58 <mrd> pitilessly
13:01:05 <__pao__> mrd: LOL
13:01:10 <doserj> if you can't think of a esotiric name, define an infix operator...
13:01:29 <unsolvedEQ> hey guys i am implementing my replace function, i use isAlpha to check the char b4 the word i wanna find, but it is givin me an error. can anyone lead me on the right path
13:01:32 <unsolvedEQ> plzzzz
13:01:53 <byorgey> all infix operators should be at least 4 characters long and use at least 2 different ascii characters, ideally with at least one repeated.
13:02:07 <mrd> and read the GHC source code for style tips
13:02:14 <Jedai> Don't think it's a joke, recently I caught myself doing a pointfree function whereas the pointfull version was both shorter and more readable, frequenting #haskell can be dangerous !! ^^
13:02:16 <byorgey> for example >>&+, **|*, $^^/, and so on
13:02:18 <__pao__> mrd: you seem half serious :-)
13:02:23 <mrd> now take the complement of my advice
13:02:40 <__pao__> mrd: that's probably not far from truth :-)
13:03:01 <Jedai> unsolvedEQ: I suppose you didn't check my proposition on hpaste ?
13:03:35 <dolio> hpaste is dead, for me at least.
13:03:58 <unsolvedEQ> hpaste is down
13:04:00 <Jedai> dolio: Yes, but it was a long time ago, when hpaste was still alive
13:04:42 <Jedai> unsolvedEQ: You're still speaking about this function that should replace all occurence of a word in a string ?
13:04:42 <unsolvedEQ> well ....  r logs saved?
13:04:52 <unsolvedEQ> yes
13:04:57 <__pao__> haskell indenting is either smart or very well designed...
13:05:08 <Botje> not really
13:05:12 <Jedai> unsolvedEQ: But only if the word is preceded and followed by non-word character ?
13:05:18 <Botje> "count number of spaces before line one, count number of spaces before line two" :)
13:05:35 <__pao__> I don't know how it works but everything reasonable I put at it, works
13:05:45 <mrd> __pao__: yea, it's a simple rule
13:06:02 <mrd> __pao__: the first expression in a block sets the indent level of that block
13:06:27 <__pao__> mrd: you can break a line on an infix op, right?
13:06:31 <mrd> yes
13:07:10 <__pao__> as I told you, I've never cared to understand because it works :-)
13:07:12 <__pao__> fine :-)
13:08:11 <Cale> __pao__: Basically, if you indent things more when they're nested inside something, and you line them up when they're at the same level, everything will just work :)
13:08:22 <mrd> except if statements
13:08:28 <Cale> even if expression
13:08:29 <Cale> s
13:08:33 <Cale> if foo
13:08:36 <Cale>    then bar
13:08:38 <mrd> right right, but not inside 'do'
13:08:40 <Cale>    else quux
13:08:47 <Cale> Even inside 'do'
13:08:48 <mrd> it should be able to line up if-then-else at same indent
13:09:01 <mrd> you can have that outside of 'do' but not inside of 'do'
13:09:03 <dolio> then and else are nested inside if.
13:09:04 <Cale> But the 'then' and 'else' are part of the 'if'
13:09:10 <Cale> So they need to be indented more.
13:09:19 <mrd> not outside of 'do'
13:09:25 <mrd> and also, not in any other language :)
13:09:33 <Cale> Sure, the rule is actually more relaxed than my statement would suggest.
13:10:12 <__pao__> well indenting "if" even if not required is always reasonable... isn't it?
13:10:19 <Cale> yes
13:10:21 <mrd> it makes "if-then-elseif-..." move ever rightward.  which isn't bad, because it advocates my evil plan to have "cond" in Haskell.
13:10:35 <Cale> If you always indent things more than the thing they're nested inside, and at the same level when they're at the same level, then you'll always be okay.
13:10:38 * mrd rubs his hands
13:10:47 <Cale> mrd: Do you know the case trick?
13:10:50 <mrd> yes
13:10:54 <Cale> case () of
13:10:59 <Cale>   _ | ... -> ...
13:10:59 <mrd> #define cond case () of _
13:11:01 <Cale> etc.
13:11:03 * mrd cackles
13:11:11 <Cale> heh
13:11:32 <Cale> You can also write a pretty nice cond
13:11:36 <__pao__> mrd: can you enlight me on cond?
13:11:45 <Cale> data Cond a = Bool :-> a
13:11:50 <mrd> __pao__: cond is if-then-else but without all the wordy mumbojumbo
13:11:54 <Cale> cond :: [Cond a] -> a
13:11:58 <vincenz> Cale: esplin?
13:12:00 <vincenz> esplain?
13:12:09 <Cale> vincenz: I think the type speaks for itself :)
13:12:09 <mrd> heh
13:12:10 <mrd> nice
13:12:27 <vincenz> oh~
13:12:29 <vincenz> !
13:13:40 <__pao__> Cale: I cannot grasp :-> ... is a special operator?
13:13:40 <Cale> One of the benefits of using a lazy language is that we can provide our own control structures like that :)
13:13:47 <Cale> __pao__: It's a data constructor
13:13:55 <Cale> (an infix data constructor)
13:14:13 <Cale> So, for instance   True :-> 5  is a value of type Cond Integer
13:14:44 <Cale> Of course, when you actually use cond, the Boolean values will typically be expressions in terms of variables which might be True or False
13:14:57 <Cale> cond's job would then be to pick the first one which gives True
13:14:58 <__pao__> Cale: got it, thaks...
13:15:16 <mrd> cond [x > 5 :-> "yay", x < 1 :-> "nooo", otherwise :-> "blah"]
13:15:26 <n00b> yes it is followed a non character
13:17:00 <mrd> > otherwise
13:17:01 <lambdabot>  True
13:17:11 <__pao__> you could add a constructor for "else" as well
13:17:51 <__pao__> wow, otherwise is defined... no need for and else constructor :-)
13:17:59 <kpreid> did anyone figure out what happened to the quote database?
13:18:19 <Cale> kpreid: hm?
13:18:25 <Cale> kpreid: Did something kill it?
13:18:28 <kpreid> yes.
13:18:29 <dolio> There are only about 4 quotes.
13:18:31 <Cale> huh...
13:18:44 <mrd> lambdabot has been practicing editorial control
13:18:45 <__pao__> what are the lexical restrictions for infix operator definition?
13:19:06 <kpreid> for example, it has no quotes of me :-)
13:19:25 * kpreid notes that the quote db could be reconstructed from irc logs of @remember, if necessary...
13:19:36 <Cale> __pao__: If it's a data constructor, it must start with colon : -- otherwise, it consists of symbol characters, which are ...
13:19:51 <Cale> ascSymbol 	 -> 	 ! | # | $ | % | & | * | + | . | / | < | = | > | ? | @
13:19:52 <Cale> 	| 	\ | ^ | | | - | ~
13:20:12 <mrd> @ is legit?
13:20:20 <mrd> not reserved?
13:20:25 <Cale> mrd: As long as it's not the only thing in the name.
13:20:39 <mrd> > let x @@ y = x+y in 1 @@ 2
13:20:40 <lambdabot>  3
13:20:41 <mrd> wild
13:21:35 <Cale> Unicode symbol characters are also supposed to be allowed. I'm not sure how well that works at present though.
13:21:56 <Cale> I can see if darcs has an old version of the quote db
13:21:56 <__pao__> Cale: where would I have found such info? is it there a good reference? I'd like to learn how to learn :-)
13:22:13 <Cale> __pao__: I just looked it up in the Haskell Report.
13:22:21 <Cale> http://haskell.org/onlinereport/
13:22:28 <__pao__> Cale: thanks
13:22:38 <Cale> (under lexical structure)
13:23:25 <Cale> There's also http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html which I don't think is entirely complete, but might be an easier way to discover some things :)
13:23:27 <lambdabot> Title: Tour of the Haskell Syntax
13:24:10 <Cale> For a reference of what functions are available, it's important to know about http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
13:24:35 <Cale> It's also a good idea to read the Prelude that's included in the Report.
13:24:47 <Cale> For other libraries not necessarily included with GHC, http://hackage.haskell.org/packages/archive/pkg-list.html
13:25:01 <__pao__> Cale: the report is easily readable?
13:25:23 <Cale> __pao__: It's not exactly a tutorial, but it can be done :)
13:25:31 * __pao__ is avidly bookmarking everything
13:25:36 <Cale> __pao__: I do recommend reading at least the Prelude though.
13:25:59 <Cale> You'll probably end up writing half of it yourself anyway :)
13:26:29 <__pao__> Cale: Part II, libraries
13:26:45 <Cale> well, section 8
13:26:56 <Cale> (of Part 1, actually)
13:27:00 <Cale> http://www.haskell.org/onlinereport/standard-prelude.html
13:27:00 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
13:27:25 <Cale> The other libraries included in the report are perhaps good reading, but the ghc docs have a better reference of them.
13:27:38 <Cale> (and updated versions)
13:27:56 <Cale> The Prelude (somewhat unfortunately) hasn't changed since Haskell 98 though.
13:28:38 <opqdonut> mhmm
13:28:50 <opqdonut> we really need some sort of "alternative prelude"
13:28:58 <opqdonut> with all the nice stuff from the wiki etc
13:29:28 <Cale> We need a new base package, and lots of stuff built against it.
13:30:40 <roconnor> > (\x -> 4*x*(1-x)) (1/3)
13:30:40 <lambdabot>  0.888888888888889
13:30:58 <__pao__> Operators are functions with a special name. Their name may consist of the following symbols !#$%&*+./<=>?@\^|-~ . The name of a constructor operator must start with a colon (:). When you write down the type of an operator you have to put the name between parentheses:
13:30:59 <opqdonut> yay, the logistic parabola
13:31:03 <opqdonut> go chaos go
13:31:09 <sjanssen> Cale: the Prelude shouldn't change until we get a new version of the report
13:31:10 <__pao__> from the anu.edu reference
13:31:14 <__pao__> really useful
13:31:27 <sjanssen> it is bad to change the standard library without a standards process, IMO
13:31:42 <ski> > let (+) = False in not (+)
13:31:43 <lambdabot>  True
13:31:55 <Cale> sjanssen: However, the new Report's process seems to indicate that it's only interested in standardising things which have been implemented.
13:32:08 <opqdonut> yep
13:32:20 <Cale> sjanssen: I actually kind of agree with that perspective. We should implement first, try it, and then standardise it.
13:32:35 <roconnor> > (\x -> 2*x^2 - (4/3)*x^3) (1)
13:32:36 <lambdabot>  0.6666666666666667
13:32:52 <sjanssen> Cale: breaking all code without a standard is no good
13:33:08 <Cale> We can fix it :)
13:33:11 <sjanssen> (I'm assuming code breakage, with things like Functor => Monad, removing fail, etc.)
13:33:32 <Cale> At least all the code on Hackage should be easy to fix up.
13:33:59 <Cale> I think it already reports build failures.
13:34:00 * mrd will break your code for free
13:34:01 <sjanssen> Cale: and all of the changed packages will be incompatible with old version of GHC
13:34:17 <Cale> sjanssen: yeah... they're already pretty incompatible with old versions of GHC.
13:34:33 <sjanssen> Cale: that isn't really true, most packages work with 6.6 and 6.8 right now
13:34:41 <Cale> Sure, 6.6
13:34:46 <Cale> But try 6.4 :)
13:34:46 <mrd> unless they use cabal
13:34:53 <n00b> here is the replace function i have
13:34:56 <Cale> Even 6.6 is questionable
13:34:56 <n00b> import Char
13:34:57 <sjanssen> mrd: huh?
13:35:21 <n00b> replace _    _  [] = []
13:35:32 <sjanssen> Cale: I think the Haskell' committee needs to accept that a standard has to lead on some changes
13:36:09 <n00b> http://mibbit.com/pb/zHu7Nr
13:36:10 <lambdabot> Title: Mibbit: PasteBin
13:36:12 <Cale> I'm okay with breaking the world, but I suppose I don't have any money staked on it :)
13:36:35 <sjanssen> Cale: yeah, commercial users are yet another issue
13:36:36 <Cale> I think we should just focus on making the libraries and language as awesome as possible, and not worry so much about backwards compatibility :)
13:36:50 <sjanssen> and we can't forget about all the educational users, books, etc.
13:36:52 <n00b> look at my replace code, it seems to go weird when checking the char b4 the word\
13:37:28 <mrd> breaking the world is important in ensuring that we avoid success at all costs
13:37:55 <Cale> mrd: right :)
13:38:25 <ski>   isObject c = c `elem` " \t\n\r\f\v.!?,();/[]`{}<>"
13:38:29 <glguy> n00b: ((isAlpha a) == True)    is   isAlpha a
13:38:34 <sjanssen> Cale: very few of the Prelude's problems are actually systemic
13:38:57 <Cale> sjanssen: what do you mean by that?
13:39:09 <tromp> Jedai, still here?
13:39:10 <Cale> sjanssen: That they would require changes to the compiler?
13:39:18 <Jedai> tromp: Yes ?
13:39:28 <glguy> n00b: isAlpha (xs !! (1 + length find))
13:39:29 <sjanssen> Cale: just about everything except for the issues with Monad and Functor could be changed without replacing Prelude
13:39:30 <tromp> the 'real' sieve is no faster than the naive one
13:39:43 <tromp> well, less than 10% faster
13:39:44 <sjanssen> Cale: import Prelude (); import PreludeTwoPointOh
13:39:45 <Jedai> tromp: Really ?
13:39:50 <Cale> sjanssen: What about all the problems with Num?
13:39:50 <ski> foo == False  =  not foo
13:39:52 <glguy> n00b: x == False    is not x
13:39:57 <sjanssen> Cale: right, Num is the other
13:40:02 <Jedai> tromp: Depends on the number, no ?
13:40:13 <tromp> i tried up to 20Million
13:40:41 <tromp> naive:78 sec  real: 69 sec
13:41:08 <tromp> hmm, ok, slightly more than 10%
13:41:08 <Cale> sjanssen: I'd also like a way to smoothly move to a new base package, or even have multiple base packages, and dependency graphs of packages installed on top of them.
13:41:32 <Cale> (and then you wouldn't need to explicitly worry about importing some new prelude)
13:42:06 <ski> n00b : is the paste supposed to end with `{-' ?
13:42:40 <Cale> Another thing is that it's also not so simple to cancel out the Prelude definitions like that, because if you import other modules, especially Data.List, you'll find you need to hide things from there as well :)
13:42:59 <Cale> (like when I redefined (++))
13:43:00 <n00b> ok
13:43:11 <n00b> sorry, it was a copy and paste syntax erro
13:43:27 <n00b> ok
13:43:43 <ski> n00b : do you mind if we paste annotations on hpaste, instead ?
13:43:46 <ski> !hpaste
13:43:53 <ski> @hpaste
13:43:53 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:43:53 <n00b> ok
13:44:09 <n00b> hpaste is down
13:44:30 <ski> oh .. so it seems to be
13:44:35 <Jedai> tromp: With 10000000, I got a 2* factor
13:45:19 <Jedai> tromp: With 1000000, I got a 4*
13:45:37 * ski tries to figure out how to annotate/paste with `mibbit.com' ..
13:46:46 <Jedai> Seems like the accumulation of merge isn't doing good things to our performance... I would like to try with the Sieve of the paper
13:47:08 <__pao__> Cale: sjanssen: don't want to be indiscreet ... what do you do with haskell? research or work? fun? small or big project?
13:47:40 <tromp> i compiled both versions with -O
13:47:50 <sethk> __pao__, I use it exclusively for work
13:48:01 <tromp> GHC  6.8.2
13:48:03 <n00b> will hpaste be up soon?
13:48:04 <shepheb> __pao__: sjanssen is lead dev for xmonad: http://xmonad.org
13:48:06 <lambdabot> Title: xmonad : a tiling window manager
13:48:33 <__pao__> shepheb: thanks
13:48:37 <Jedai> tromp: -O2 is now better most of the time
13:49:03 <sethk> shepheb, I didn't know that existed.  It looks very interesting
13:49:09 <Jedai> tromp: With 20 millions, I get "real" : 57s and "false" : 88s
13:49:27 <shepheb> sethk: if you've never used a tiling WM before, it's a little odd. but I love it.
13:49:49 <sethk> shepheb, odd things that I never used before keep me from being bored to death
13:50:12 <sylvan> @paste
13:50:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:50:26 <mrd> hpaste: url
13:50:26 <hpaste> Haskell paste bin: http://hpaste.org/
13:50:37 <sethk> shepheb, I wonder how it would work on the embedded system I'm working on.  It has two 320x280 LCD screens
13:50:45 <Jedai> Apparently we have a problem asymptotically... On small numbers the difference is huge and theoretically, it should still be asymptotically, but that's not the case, interesting
13:50:46 <ski> sylvan,mrd : still down
13:50:47 <tromp> -O2 no faster
13:50:50 <tromp> for this one
13:53:53 <sylvan> I'm trying to get the parallel strategies working, but it seems like it doesn't use more than one core (compiled with -threaded and run with +RTS -N2 -RTS). Ideas? Code: main = print $ parMap rnf fib $ take 40 $ randomRs (30,35) (mkStdGen 123)
13:54:30 <shepheb> sethk: actually, xmonad is great for handling multiple screens. that's not a lot of real estate for multiple windows per screen, though.
13:54:52 <sethk> shepheb, no, but it's what the device has.  :)
13:55:42 <sethk> shepheb, it's asking me for X11 >=1.4.1  Hackage?
13:56:13 <sethk> oh, wait, your hackage page has pointers.  never mind
13:56:58 <sjanssen> __pao__: I use Haskell for fun
13:57:12 <sjanssen> __pao__: I'm just an undergrad student for now
13:57:56 <__pao__> sjanssen: that multihead config on xmonad site is yours? :-)
13:58:11 <__pao__> sjanssen: where are you from?
13:58:15 <Jedai> tromp: It seems like the "real" version is trashing the GC...
13:58:35 <shepheb> sethk: see #xmonad; we're in there too. glad you're trying it!
13:58:44 <sjanssen> __pao__: nah, that's glguy's
13:58:48 <sethk> shepheb, k, thanks
13:58:50 <sjanssen> __pao__: Nebraska
13:58:55 <Jedai> tromp: For 2e6 we already have more than 1/3 of the time in the GC
13:59:10 <Cale> __pao__: I've been paid to write Haskell in the past, but I mostly use it for fun.
13:59:14 <sethk> sjanssen, I recommend you remain an undergraduate for as long as possible.  Beats the real world by a mile.  :)
13:59:34 <__pao__> sethk: I agree :-)
14:00:24 <ski> n00b impersonated pasted "replace" at http://paste.lisp.org/display/58905
14:00:37 <tromp> interesting, Jedai
14:00:54 <__pao__> Cale: it's sad to hear that... past :-)
14:01:09 <tromp> i'll abort my timing up to 2Billion:(
14:01:13 <__pao__> Cale: are you from USA as well?
14:01:44 <Jedai> tromp: I'm sure if you profiled that you would find that you pass most of your time in the GC
14:01:58 <Jedai> I wonder if we can mitigate this.
14:02:58 <sethk> Jedai, sure, just don't let anyone profile it  :)
14:03:45 <Jedai> For 1e7 we already pass 11.5/19s in the GC...
14:07:44 <Cale> __pao__: I'm from Canada.
14:08:09 <Cale> __pao__: I'm not really looking for a career in computer programming :)
14:08:20 <__pao__> Cale: researcher?
14:08:22 <Cale> __pao__: I'd much rather end up in mathematical research :)
14:08:39 <__pao__> Cale: are you a student?
14:09:04 <Cale> __pao__: yeah
14:09:51 <__pao__> I once was a student... I'm feel I'm old when I IRC ;-)
14:10:57 <Cale> I might do some programming for a few years though. There's potentially a job wherein I would help join up a bunch of doctors' computer systems in order to collect data on the effectiveness of treatments.
14:11:32 <Cale> I wouldn't want to get stuck doing that for more than 2 years or so though :)
14:11:41 <__pao__> Cale :-)
14:12:46 <__pao__> I was wondering if there exist a "market" for haskell programmers...
14:12:56 <__pao__> but I'm sure it does not .-)
14:13:36 <__pao__> Cale: are you going to use haskell for that work?
14:16:40 <ski> ski annotated #58905 with "possible clear-up" at http://paste.lisp.org/display/58905#1
14:16:43 <ski> n00b : ^
14:18:00 <byorgey> __pao__: there definitely exists a market for Haskell programmers.
14:18:41 <byorgey> just the other day someone from a company that uses Haskell was saying how they are almost constantly looking for people to hire.
14:26:26 <tromp> @let prime=let ps=2:3:2:5:scanl(+)5 ps in zipWith(\x y->(y,x`mod`y==0))ps [2..]
14:26:31 <lambdabot> Defined.
14:27:08 <tromp> take 20 prime
14:27:11 <tromp> > take 20 prime
14:27:12 <lambdabot>  [(2,True),(3,True),(4,False),(5,True),(6,False),(7,True),(8,False),(9,False)...
14:28:42 <MyCatVerbs> @pl \f -> writeChan (f params)
14:28:42 <lambdabot> writeChan . ($ params)
14:32:03 <__pao__> byorgey: really nice to hear!
14:32:57 <__pao__> byorgey: can you tell the company name
14:34:55 <tromp> > let p = 3:0:2:3:scanl(+)2 p in p
14:34:55 <lambdabot>  [3,0,2,3,2,5,5,7,10,12,17,22,29,39,51,68,90,119,158,209,277,367,486,644,853,...
14:37:31 <__pao__> Cale: can you give me some info/pointer/google search keywords about the Num, Monad, Functor you were discussing?
14:39:50 <awesame> I want to pattern-match strings that start with "env"
14:40:18 <awesame> I wanted to write ("env":rest), but ended up having to write ('e':'n':'v':rest)
14:40:27 <awesame> is there a better way to do that?
14:40:38 <gwern> awesame: that's what I've always done
14:41:05 <gwern> anyway, wouldn't "string":foo be against a [String], not a String?
14:41:10 <jsnx> :t Data.Function.fix
14:41:10 <lambdabot> forall a. (a -> a) -> a
14:41:19 <jsnx> what can i actually do with fix?
14:41:23 <awesame> gwern: it would, but do you see what I meant?
14:41:35 <ski> @type Data.List.stripPrefix
14:41:35 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe [a]
14:41:48 <gwern> awesame: I do, but there's a reason, I suppose?
14:41:56 <awesame> I'd like to pull the [] off the end of "env"
14:42:02 <jsnx> > fix (+ 0)
14:42:02 <lambdabot>  Exception: <<loop>>
14:42:06 <ski> > map (stripPrefix "env") "bork" "envorinment"
14:42:06 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
14:42:07 <jsnx> heh
14:42:11 <awesame> I just thought it would be nice to use fewer characters
14:42:17 <ski> > map (stripPrefix "env") ["bork","envorinment"]
14:42:18 <lambdabot>  [Nothing,Just "orinment"]
14:42:22 <gwern> awesame: why not go foo:[], and then use the variable foo in that case?
14:42:32 <ski> (/me can't spell)
14:42:49 <jsnx> ski: pwned
14:43:16 <awesame> ski: interesting, but I don't think it helps me
14:43:17 <ski> possibly use `Data.List.stripPrefix' together with pattern-guards
14:43:22 <Peaker> Cale, I now read your explanation from above. I'm not sure - but I think I understand the gist of it.. seems like a weird hack though :)
14:43:48 <ski>   | Just rest <- "env" `Data.List.stripPrefix foo  =  ..rest..
14:44:02 <ski> s/ foo/` foo/
14:44:53 <awesame> oh, I see what you're saying ski
14:45:03 <awesame> maybe I could work out a way to write that neatly
14:45:05 <ski> ideally, we'd write
14:45:14 <ski> bar ("env" ++ rest) = ..rest..
14:45:15 <Cale> __pao__: I might, I don't know. I'm not even sure I'm going to do that job yet.
14:45:18 <ski> but this doesn't work
14:45:21 <awesame> but ('e':'n':'v':rest) isn't so bad
14:45:29 <ski> (though they've made a special case in Erlang for this !)
14:45:29 <Cale> __pao__: Num, Functor, and Monad are all classes defined in the Prelude.
14:45:36 <ski> so
14:45:40 <Saizan> ?hoogle echo
14:45:40 <lambdabot> System.IO.hSetEcho :: Handle -> Bool -> IO ()
14:45:40 <lambdabot> System.IO.hGetEcho :: Handle -> IO Bool
14:45:40 <ski> bar foo
14:45:46 <ski>   | Just rest <- "env" `Data.List.stripPrefix` foo  =  ..rest..
14:45:49 <ski> works
14:46:00 <jsnx> is the only purpose of Data.Function.fix to facilitate type inference?
14:46:14 <__pao__> Cale: you were talking about problems related to them to be overcome by haskell'
14:46:20 <Cale> Peaker: I think it has a certain elegance to it ;)
14:46:32 <ski> or indeed, `bar ('e':'n':'v':rest) = ..rest..' for short values of `"env"'
14:46:45 <jsnx> > fix ((+1) . head)
14:46:45 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
14:46:46 <lambdabot>       Expected...
14:46:46 <Cale> __pao__: Yeah. Monad includes a function which it shouldn't, called fail, and isn't a subclass of Functor like it should be.
14:47:08 <jsnx> > fix head
14:47:09 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
14:47:09 <lambdabot>       Expected...
14:47:15 <Peaker> Cale, I think that the tuple (state, value) is an internal implementation detail of State and should not be exposed :)
14:47:25 <Cale> __pao__: Num is a subclass of Eq and Show when it probably shouldn't be, and includes signum and abs, which aren't definable for lots of things which you might otherwise want to make instances of Num.
14:47:26 <__pao__> Cale: what about Num?
14:47:28 <jsnx> > fix ((:[]) . head)
14:47:28 <lambdabot>  Exception: <<loop>>
14:47:31 <jsnx> heh
14:47:32 <awesame> I think what I want is a new constructor for lists that takes two lists
14:47:33 <n00b> ski thanks man :)
14:47:47 <__pao__> Cale, thanks a lot
14:47:58 <awesame> can ++ be used in pattern matches?
14:48:07 <Cale> awesame: nope, since it's not a data constructor
14:48:16 <Cale> awesame: (and it wouldn't uniquely match)
14:48:33 <ski> awesame : http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#pattern-guards
14:48:34 <awesame> it wouldn't?
14:48:35 <lambdabot> Title: 8.3. Syntactic extensions, http://tinyurl.com/y6v6by
14:48:51 <Peaker> Cale, given that it is trivial to implement fmap for all monads via liftM, wouldn't it be possible to retroactively say:  class (Functor m) [where fmap=liftM] => Monad m where ...  -- let me implement the superclass method as a default?
14:48:53 <Cale> awesame: Well, consider  f (xs ++ ys) = (length xs, length ys)
14:49:10 <awesame> oh, right
14:49:10 <Cale> awesame: What's the result of that function when passed the list [1,2,3,4,5] ?
14:49:23 <ski> awesame : look up that ghc extension
14:49:27 <lament> isn't this pretty
14:49:28 <lament> equalUpToTransposition a b = (a ==) `any` (shiftedVersions b) where shiftedVersions b = [Set.map (transpose n) b | n <- [0..11]]
14:49:48 <ski> s/(shiftedVersions b)/shiftedVersions b/
14:49:48 <awesame> the first one would have to be, uh, constant?  static?  literal?  whatever the local word for that is
14:50:01 <Cale> Peaker: Well, it would require some extension.
14:50:04 <awesame> or rather, one of them would have to be that way
14:50:15 <Peaker> Cale, that way nobody is unhappy about breaking backwards compatibility
14:50:16 <Saizan> Peaker: those has been proposed a few times before, but no one has worked out the details and implemented it
14:50:19 <lament> ski: true! even prettier
14:50:23 <Peaker> Saizan, ah
14:50:34 <ski> (awesame : note that Erlang does support this special case `++' in the case the left argument is already known)
14:50:37 <awesame> so for example f ("env" ++ rest) = rest would match uniquely, if ++ were a constructor
14:50:46 <Cale> There are lots of subtleties to it dealing with separate compilation and the module system.
14:50:52 <slava_> that's how factor's inverse library works
14:50:54 <ski> n00b : wait
14:50:58 <awesame> ski: neat
14:51:20 <roconnor> What notation would people use for the image of a set S under a function f?
14:51:24 <roconnor> in math
14:51:25 <slava_> roconnor: f(S)
14:51:33 <Cale> Yeah, f(S), generally.
14:51:37 <ski> n00b : do you want `replace "foo" "bar" "foo"' to abort the program, or so you want `"bar"' as answer ?
14:51:38 <roconnor> :/
14:52:12 <Cale> We just implicitly apply the powerset functor, since it's usually obvious that S is a set of elements of the domain of f.
14:52:32 <Cale> Of course if you want to be picky, you can just write something like {f(s) : s in S}
14:52:32 <slava_> powerset is a functor? never thought of that
14:52:52 <roconnor> Cale: and yet you claim that mathematics work in an untyped language :P
14:53:02 <ski> slava_ : it's actually two (covariant) functors
14:53:06 <Cale> roconnor: I never claimed that.
14:53:14 <roconnor> Cale: oh
14:53:24 <Cale> roconnor: I claim that it doesn't need an *extra* type system, because it already has one.
14:53:27 <slava_> ski: what are they?
14:53:33 <Cale> roconnor: It has propositions :)
14:53:35 <roconnor> Cale: didn't you say that mathematicians use ZFC?
14:53:40 <Cale> yep
14:53:55 <roconnor> how do you know what f(S) means without types?
14:53:58 <Cale> If you want to say that something is an element of some set, you just say it.
14:54:05 <Cale> roconnor: Common sense.
14:54:10 <roconnor> pfft
14:54:20 <roconnor> there is totally a type system at work and you know it.
14:54:26 <Cale> roconnor: We don't write mathematics for machines, we write it for other mathematicians.
14:54:41 <Cale> roconnor: Other mathematicians are smart and can infer things from context.
14:55:03 <Cale> roconnor: and so long as they don't get confused, everything is fine
14:55:07 <roconnor> they are smart and can infer things because they have a type theory in mind.
14:55:35 <Cale> roconnor: If by 'type theory', you mean "they know what propositions hold of elements of S", then sure.
14:56:02 <Cale> They know what the domain of f is, and they know that S is a set of elements of that domain, and not an element of it, so they do the obvious thing.
14:56:31 <Cale> It's not strictly rigourous, but it's rigourisable, which is all that matters.
14:56:39 <n00b> ski yes
14:56:51 <n00b> it is giving me an error
14:56:53 <roconnor> it's rigourisable by using types!
14:56:57 <n00b> ski Program error: {head []}
14:57:00 <Cale> Sure, but nobody cares.
14:57:01 <Cale> :)
14:57:03 <lament> roconnor: or sets. or whatever.
14:57:24 <roconnor> lament: well, my point is that sets are insufficent.
14:57:32 <Cale> We're interested in f(S), not that some type theory makes it okay to write f(S).
14:58:16 <Cale> another way to rigourise it is simply to write f[S] or use some other notation instead, which is defined appropriately
14:58:23 <ddarius> @wn rigourise
14:58:25 <lambdabot> No match for "rigourise".
14:58:29 <Cale> But usually the distinction is not important.
14:58:55 <dolio> @wn rigorize
14:58:55 <lambdabot> No match for "rigorize".
14:59:12 <slava_> @wn rogourize
14:59:12 <lambdabot> No match for "rogourize".
14:59:14 <slava_> hehe
14:59:23 <roconnor> Cale: how do you feel about f"S
14:59:49 <glguy> rogue-erize?
15:00:15 <Cale> roconnor: Looks like some second derivative of f, or, well, I'd go looking for a notation section if I saw that in a book.
15:00:26 <Cale> Of course, any notation is fine if you define it up front.
15:01:03 <dolio> !paste
15:01:03 <hpaste> Haskell paste bin: http://hpaste.org/
15:01:04 <roconnor> Cale: Suppes uses that notation for image, but I'm not sure I like it, because it looks like some second derivative of f. :)
15:01:05 <Cale> im f|S would also work.
15:01:18 <Cale> yeah, that's what I think too.
15:01:18 <roconnor> f|S could be good.
15:01:21 <ski> slava_ : `exist_f(S)  =  {y : B | exists x : A. y = f(x) /\ x in S}  =  {f(x) : B | x in S}' and `all_f(S)  =  {y : B | forall x : A. y = f(x) => x in S}'  iirc
15:01:48 <roconnor> Cale: actually f|`S comes to mind
15:01:51 <ski> n00b : and do you want that error to happen ?
15:01:56 <Cale> roconnor: with a spear?
15:01:58 <roconnor> Cale: but with a real hook (not ascii art)
15:02:04 <roconnor> yes
15:02:13 <ski> roconnor : something like `exist_f(S)'
15:02:15 <roconnor> that seems vaguely familiar
15:02:15 <n00b> ski, just return the list
15:02:17 <Cale> Yeah, some people use that symbol for restriction rather than |
15:02:20 <n00b> unedited
15:02:26 <ski> ok
15:02:30 <roconnor> oh
15:02:32 <roconnor> hmm
15:02:32 <Cale> Also, sometimes, for whatever reason, the domain of restriction is subscripted
15:02:39 <Cale> So you have f|_S
15:02:54 * roconnor checks to see if funmath has some notation for me.
15:03:06 <ski> n00b : now, is `isPrefixOf "abcd" "ab"' supposed to give `True' ?
15:03:15 <Cale> I would also consider  im_S f
15:03:32 <n00b> false
15:03:48 <Cale> If the emphasis was on the operation which takes the image of S under various functions.
15:04:10 <ski> slava_ : those two are the existential/direct and the universal image, of course .. the inverse image powerset functor is the cotravariant one (as i'm sure you know)
15:04:20 <n00b> ski the cd makes it falses, the functions check the char after the word and b4 the word
15:04:48 <ski> n00b : but `isPrefixOf as bs = and $ zipWith (==) as bs' makes it `True'
15:06:04 <n00b> ski that's why use the (isAlpha (last(take(succ (length find)) xs))) == False, to check the val after, just wanna check the value b4 now
15:07:09 * ddarius has no idea why n00b say "b4"
15:07:14 <ddarius> +s
15:07:23 <Cale> I suppose that another way to explain my point of view is that the types in mathematics are effectively (set theoretic) classes -- which are simply propositions with a single free variable.
15:08:10 <Cale> The proposition that defines what it means for something to be a group gives rise to a class of groups, for instance.
15:08:19 <glguy> ddarius: in the line containing "isAlpha((((((((...", the "b4" is what amuses you?
15:08:45 <shapr> @yow !
15:08:45 <lambdabot> I didn't order any WOO-WOO ... Maybe a YUBBA ... But no WOO-WOO!
15:08:47 <shapr> @users
15:08:47 <lambdabot> Maximum users seen in #haskell: 477, currently: 440 (92.2%), active: 22 (5.0%)
15:08:48 <shapr> mmm
15:08:49 <ski> n00b : have you read my first annotation at <http://paste.lisp.org/display/58905#1> ?
15:09:10 <Cale> Of course, people don't usually think of it quite like that, but effectively if we're to have anything like types, that seems to work well enough.
15:09:13 <Peaker> active in the last ... ?
15:09:44 <n00b> ski yes
15:09:57 <Cale> So there's a "type" for every possible proposition which may or may not be satisfied by some sets.
15:10:10 <ddarius> glguy: He consistently uses b4, but, thankfully, doesn't seem to use any other "net slang"
15:10:16 <n00b> ski test it and i keep getting an error
15:10:32 <glguy> let isPrefixOf as bs = and $ zipWith (==) as bs in "asdf" `isPrefixOf` ""
15:10:34 <Cale> Which would be extremely inappropriate as a type theory for a programming language, but it works out well for mathematics :)
15:10:37 <glguy> > let isPrefixOf as bs = and $ zipWith (==) as bs in "asdf" `isPrefixOf` ""
15:10:38 <lambdabot>  True
15:10:41 <glguy> oops
15:10:54 <ski> n00b : do you understand why `(isAlpha (last(take(succ (length find)) xs))) == False' can be shorter written as `not (isAlpha (head back))' .. including the `where (front,back) = splitAt (length find) xs' ?
15:12:59 <n00b> i understand that but it keeps giving me an error when i test it
15:13:15 <n00b> ski Program error: {head []}
15:15:02 <Cale> n00b: head is an inherently dangerous function to apply for that very reason
15:15:03 <ski> n00b : that is because `not (isAlpha (head back))' (as well as your original code) said to give an error in that case
15:15:11 <Cale> > head []
15:15:12 <lambdabot>  Exception: Prelude.head: empty list
15:15:26 <Cale> > case [] of [] -> 0; (x:xs) -> 1
15:15:27 <lambdabot>  0
15:15:28 <ski> n00b : however, have some patience .. i'm making another annotation, with this changed
15:18:19 <ski> n00b : what should `replace "foo" "bar" "foo!"' give ?  and what should `replace "foo" "bar" "foox"' give ?
15:19:06 <ski> (in the case `replace "foo" "bar" "foo"' i believe you want `"bar"')
15:20:26 <n00b> ski replace "foo" "bar" "foo!" should give bar!
15:20:53 <ski> and the second case ?
15:20:55 <ski> note that
15:20:59 <ski> > isAlpha 'x'
15:21:01 <lambdabot>  True
15:22:58 <ski> n00b : well ?
15:23:02 <Peaker> > isAlpha 'א'
15:23:02 <lambdabot>  Improperly terminated character constant at "'א'" (column 9)
15:24:25 <n00b> `replace "foo" "bar" "foox"' give ? should return the list foox
15:24:39 <n00b> ski should just return
15:25:09 <ski> return *what* ?
15:25:28 <ski> what should `replace "foo" "bar" "foox"' return ?
15:25:41 <ski> maybe it should return "barx" ?
15:26:10 <ski> maybe it should return "" ?
15:26:20 <ski> i can't read your mind
15:26:24 <n00b> ski foox
15:26:56 <n00b> `replace "foo" "bar" "foox"' returns foox
15:27:03 <ski> really ?
15:27:27 <n00b> ski foo and foox is different
15:27:37 <ski> `| isAlpha a -> replace find rep as' says to recursively discard letters, in case of no match
15:28:09 <ski> `| otherwise -> a : replace find rep as' says to keep non-letters, in case of no match
15:29:13 <glguy> > map isAlpha "א"
15:29:13 <lambdabot>  [True]
15:32:27 <ski> n00b : what did you intend by writing `|((isAlpha a) == True) = replace find rep as' ?
15:34:03 <ptolomy2> Anyone aware of an existing Trie implementation for ByteStrings?
15:34:04 <n00b> ski (isAlpha (last(take(succ (length find)) xs))) == False
15:34:41 <n00b> ski i was just trying something, it didn't work though
15:34:45 <ptolomy2> My experiments showed a 256-ary array-based version to be 3x faster tha Map, and a IntMap-based one about twice as fast.
15:34:54 <ptolomy2> But for the array one, memory overhead had to be heavy.
15:36:26 <ski> n00b : ok .. so, you only want `find' to match if there's not a letter after the matching characters in `xs', right ?
15:39:06 <n00b> ski before and after rather
15:39:32 <ddarius> > isAleph (head "א")
15:39:32 <lambdabot>   Not in scope: `isAleph'
15:39:41 <n00b> i know how to check the value after, it's the value vefore the matching word that is the problem
15:39:51 <Peaker> > "אבג"
15:39:52 <lambdabot>  "\1488\1489\1490"
15:40:08 <Peaker> Does ghc parse strings as utf8?
15:40:08 <ski> n00b : ok .. hm
15:40:26 <roconnor> f ⊷ S
15:40:38 <n00b> replace "set" "queues" "the is a sset" it check the val before the set which is s and the value after t
15:40:52 <glguy> Peaker: no, but a Char is a unicode code-point
15:41:10 <glguy> There are libraries for various encodings, like utf-8
15:41:25 <roconnor> ⊷ is defined to be "image of"
15:41:25 <Peaker> how come א was parsed into \1488 ? is that octal?
15:41:33 <roconnor> but it's not something I can google
15:41:44 <Peaker> it can't be octal oops :)
15:42:06 <ddarius> Why can I read Hebrew?
15:42:20 <Peaker> ddarius, what do you mean?
15:43:16 <Peaker> http://blog.kfish.org/2007/10/survey-haskell-unicode-support.html: "... Haskell source is interpreted as UTF-8, ..."
15:43:23 <lambdabot> http://tinyurl.com/5pub2n
15:45:08 <ddarius> roconnor: That doesn't look at all like anything I'd call "image of"
15:45:13 <ski> n00b : in case `find' does not match the prefix of the currently considered tail of the list, you want to *keep* the first character of the tail, is that right ?
15:45:44 <Peaker> א is \05d0 and its utf8 encoding is \xd7\x90
15:46:06 <Peaker> so where does \1488 come from?
15:46:16 <Peaker> > "א"
15:46:16 <lambdabot>  "\1488"
15:46:20 <mauke> > 0x5d0
15:46:21 <lambdabot>  1488
15:46:24 <Peaker> oh
15:46:31 <ddarius> Good job X-Chat handling RtL languages...
15:46:33 <Peaker> decimal for characters isn't something I've seen before
15:46:51 <Peaker> ddarius, its not xchat, its _everything_.  Mixing Hebrew and English is a horrible experience in general
15:46:53 <ski> n00b : e.g. `replace "foo" "bar" "apa!"' will give `"apa!"' ?
15:47:25 <Peaker> ddarius, Very few let you control the direction rather than trying to deduce it from the characters
15:52:18 <roconnor> ddarius: me neither.  But presumably the unicode people got it from somewhere.
15:52:27 <roconnor> I wonder where
15:56:27 <Cale> Yay, even more Catsters videos!
15:56:30 <n00b> ski `replace "foo" "bar" "apa!"' will give `"apa!"' >> yes
15:56:35 <Cale> http://uk.youtube.com/watch?v=be7rx29eMr4
15:56:35 <lambdabot> Title: YouTube - Metric spaces and enriched categories 1
15:56:39 <Cale> http://uk.youtube.com/watch?v=wnRqo7UHa-k
15:56:39 <lambdabot> Title: YouTube - Eckmann-Hilton 2 (beware typo at 4:13)
15:57:05 <n00b> yeah keep the first char of the tail so it can be checked
15:59:47 <ski> and `replace "foo" "bar" "foo foo"' ?
16:00:19 <ddarius> Cale: Checking (and correcting) their work is an implicit exercise for the watcher.
16:00:26 <Cale> heh
16:05:25 <ski> ski annotated #58905 with "still not the intended semantics" at http://paste.lisp.org/display/58905#2
16:06:03 <ski> n00b : that's still not exactly what you want, but hopefully you can work from that and make an attempt to write more exactly what you want
16:06:35 <ski> (also check that the assumptions on what `replace' should give in the various examples are what you intend)
16:08:19 <ski> n00b : iiuyc, you need to keep track of at which points you want to match .. e.g. in `replace "foo" "bar" "xfoo ..."' you do not want to match `"foo"' with the tail of `"xfoo ..."' .. so you must keep track of this somehow
16:08:53 <ski> one way would be to skip (and output) the whole of `"xfoo"' until you hit either end of input, or a non-letter
16:09:49 <ski> another way would be to keep track of whether the character before the current tail was a letter
16:12:39 <n00b> ski ok
16:14:26 <Cale> ddarius: It's not such a bad writeo :)
16:16:59 <ski> (n00b : .. i could write code for what i think you want, but then you wouldn't learn as much .. try to understand what the annotation does, and try to work from there .. if you get stuck again, then i, if i have time, or possibly someone else can have a look at it and come with suggestions)
16:31:23 <n00b> ski here's the way i implemented it first
16:31:25 <n00b> http://paste.lisp.org/display/58912
16:34:56 <ski> n00b : next time, please annotate the existing paste (if the pasting service supports annotation, like lisppaste and hpaste does), instead of making a new one
16:36:21 <ddarius> ski lays the netiquette smack down
16:41:53 <ski> n00b impersonated annotated #58905 with "another imp  (from http://paste.lisp.org/display/58912)" at http://paste.lisp.org/display/58905#3
16:43:41 <n00b> ski i want to cut it down and make it shorter without affecting the functionality
16:46:45 <glguy> !paste
16:46:45 <hpaste> Haskell paste bin: http://hpaste.org/
16:47:24 <glguy> elem (head list) whitespace == False    is   notElem (head list) whitespaces
16:47:41 <glguy> == False and == True are red flags
16:48:16 <dolio> http://okasaki.blogspot.com/2008/02/boolean-confusion.html
16:48:18 <lambdabot> Title: Teaching, Playing, and Programming: Boolean Confusion
16:48:43 <lament> what's the idiomatic way of folding a list of functions over a value?
16:49:10 <glguy> foldr (.) id
16:49:10 <glguy> ?
16:49:21 <ddarius> Which used to be mconcat
16:49:27 <lament> thanks
16:49:30 <dolio> @type appEndo . mconcat . map Endo
16:49:32 <lambdabot> forall a. [a -> a] -> a -> a
16:49:43 <ski> glguy : The connection was refused when attempting to contact hpaste.org.
16:49:54 <glguy> yikes :)
16:50:38 <lament> :t mconcat
16:50:39 <lambdabot> forall a. (Monoid a) => [a] -> a
16:50:44 <glguy> n00b: x == [] is null x
16:50:53 <lament> why "used to be mconcat"?
16:51:10 <dolio> The monoid instance for (->) got changed.
16:51:40 <dolio> Now it's 'f `mappend` g = \x -> f x `mappend` g x'
16:52:14 <dolio> > mconcat [show, show] 5
16:52:15 <lambdabot>  "55"
16:52:47 <Cale> > (show ++ show) 5
16:52:48 <lambdabot>  "55"
16:52:52 <dolio> The old one is Endo now.
16:52:55 <glguy> concat $ sequence [ show, show ] 5
16:53:24 <ddarius> The new one is probably a better default theoretically speaking, but the Endo one seems to come up more often.
16:53:25 <dolio> (appEndo . mconcat . map Endo) [(+1) , (*2)] 5
16:53:31 <dolio> > (appEndo . mconcat . map Endo) [(+1) , (*2)] 5
16:53:32 <lambdabot>  11
16:53:43 <Cale> We should probably have a compose function in the Prelude.
16:53:48 <ski> compose = foldr (.) id
16:54:00 <Cale> exactly, yeah
16:54:06 * glguy hasn't seen Endo used as more than a #haskell curiosity
16:54:46 <ddarius> The (->) ones doesn't get used that much either.  Both are probably underutilized.
16:55:17 <dolio> It's used in Data.Foldable, but that's probably not much more significant.
16:57:15 <SamB> another thing about the old (->) Monoid instance is that it needed more extensions than the new one...
16:57:45 * shapr is tired
16:57:47 <Cale> The names of the monoid operations are too unwieldy.
16:58:03 <SamB> eh?
16:58:05 <ddarius> Cale: True.
16:58:17 <Botje> hmm
16:58:18 <ddarius> We need ⊕
16:58:27 <Cale> I like the idea of stealing ++
16:58:27 <Botje> i'm standing at a crossroads in my compiler
16:58:34 <Botje> should I use uniplate or syb?
16:58:36 <SamB> Cale: but what about MonadPlus?
16:58:51 <SamB> everyone wants to steal the same names!
16:58:53 <ddarius> Botje: I haven't used Uniplate, but it appeals to me more than SYB.
16:59:05 <ddarius> SamB: That's fine when they are all the same thing.
16:59:14 <SamB> ddarius: that's fine in MATH
16:59:18 <SamB> but programming langauges?
16:59:38 <dolio> mplus and mappend aren't actually the same for Maybe.
16:59:42 <Botje> ddarius: thanks, i'm reading the paper now and so far it seems nicer than SYB
16:59:47 <dolio> You'd need to decide which you want.
16:59:49 <Cale> SamB: That's true, but I'm starting to wonder whether going the route of Alternative might be better.
16:59:51 <Botje> I hope it also has monadic transformations and stuff
16:59:57 <SamB> Alternative?
17:00:09 <Cale> It's a class in Control.Applicative
17:00:09 <ddarius> Botje: It's not as powerful as SYB.
17:01:13 <Cale> We'd still want to separate left catch things from ones where all paths are taken.
17:01:20 * glguy tries to imagine why he wants his mechanical pencil to be anti-biotic...
17:01:33 <Cale> So you'd still maybe want <+> or something to distinguish
17:01:37 <dolio> In case you like to chew on it?
17:01:43 <SamB> glguy: because you are japanese, duh
17:01:51 <SamB> they have anti-biotic playgrounds, don't they?
17:01:56 <SamB> it's really damn unhealthy though
17:02:23 <SamB> <+> means "place a space between two documents"
17:02:29 <s710b> :t \x y z -> (x,y:z:[])
17:02:30 <lambdabot> forall t a. t -> a -> a -> (t, [a])
17:02:38 <s710b> Whats the difference between 't' and 'a'?
17:02:52 <SamB> s710b: they aren't the same variable
17:03:32 <Botje> SamB: in tuples you can have different types, in lists you have to have the same type
17:03:41 <Botje> soh
17:03:42 <s710b> huh? i thought it would be 'a' and 'b' instead of 't'
17:03:46 <Botje> s710b even
17:03:51 <Botje> s710b: that doesn't matter much :)
17:03:56 <Cale> s710b: It picks the letters somewhat randomly.
17:03:59 <SamB> also, the reason why GHC calls the second one 'a' is probably that the list datatype was defined with a variable named 'a'
17:04:28 <Cale> Yeah, there's some kind of strange internal logic to it :)
17:04:33 <s710b> ah, ok. i thought 't' had to be sthg special :)
17:04:47 <Cale> All lowercase names at the type level are variables.
17:05:04 <Cale> So it doesn't matter if you write  a  or  char or whatever :)
17:05:05 <SamB> no, 't' is just what GHC decided to call that one on it's own
17:05:11 <SamB> since it had no where else to get a name
17:05:56 <Cale> In fact, you can probably very easily confuse beginners by naming type variables the same thing as existing types, but with a lowercase letter ;)
17:06:15 <Cale> Just :: maybe -> Maybe maybe
17:07:06 <ddarius> Just :: int -> Maybe int
17:08:08 <s710b> Just :: dontConfuseMe -> Maybe dontConfuseMe
17:14:41 <Botje> okay
17:14:52 <Botje> given that I have no experience with boilerplate removal libs
17:14:55 <Botje> i'll go with uniplate
17:15:46 <Botje> if it doesn't suffice I can at least mostly reuse my functions for SYB :)
17:20:54 <dobblego> what's the girl's name on YouTube with those mathematics videos?
17:21:04 <Botje> catsters?
17:21:10 <dobblego> ah thanks
17:21:19 <Botje> that's the name of te group at least
17:21:53 <ddarius> Eugenia Cheng
17:22:01 <dobblego> cheers
17:31:48 <sw17ch> I just evaluated a cake to weak head normal form, and the oven is finishing the evaluation.
17:33:55 <wagle_home> dobblego, oh cool..  thanks
17:34:14 <dobblego> wagle_home, no problem, any time, but what for?
17:37:14 <wagle_home> the catsters videos
17:37:26 <gwern> @seen faxathasia
17:37:26 <lambdabot> I haven't seen faxathasia.
17:37:43 <dobblego> wagle_home, oh, no problem still :)
17:37:50 * SamB wishes for *optimal* layout combinators with alignmnet...
17:38:08 <gwern> @seen faxathisia
17:38:08 <lambdabot> faxathisia has changed nick to vixey.
17:38:08 <lambdabot> I saw vixey leaving #rosettacode 5h 37m 52s ago, and .
17:38:20 <newsham> anyone know if there are any physics type systems like magic pen or crayon physics deluxe implemented in haskell?
17:38:20 <gwern> hm.
17:38:51 <dolio> Oh, (physics type) systems.
17:39:20 * dolio read that as physics (type systems) at first.
17:39:41 <newsham> like this: http://www.youtube.com/watch?v=QsTqspnvAaI
17:39:42 <lambdabot> Title: YouTube - Crayon Physics Deluxe
17:39:58 <geezusfreeek> i was thinking about making a binding to chipmunk physics sometime in the future, actually
17:40:14 <newsham> chipmunk physics?
17:40:16 <pa-ching> class Dialatable Time where [...]
17:40:27 <geezusfreeek> http://wiki.slembcke.net/main/published/Chipmunk
17:40:27 <lambdabot> Title: Chipmunk in Main
17:40:34 <geezusfreeek> it's very excellent for 2d
17:42:49 <newsham> wow, cool videos on thier site
17:44:29 <gwern> @remember JohnMeacham  Is it ironic I had to look up and read a tutorial on the haskell regular expression syntax I invented?
17:44:29 <lambdabot> Done.
17:44:38 <geezusfreeek> from searching some transcripts of #haskell it seems that dmwit had previously thought about making a binding for it
17:45:45 <newsham> what about just writing a new on ein haskell? ;-)
17:46:02 <newsham> wow, these videos are super cool
17:46:05 <geezusfreeek> i don't really know anything about that
17:46:24 <gwern> @ask vixey Hey, whatever happened to your Janus interpreter?
17:46:25 <lambdabot> Consider it noted.
17:47:22 <gwern> 'Janus is also the name of a time-reversible programming language written at Caltech in 1982.' <-- if you were wondering
17:50:39 <tromp> :t mod
17:50:40 <lambdabot> forall a. (Integral a) => a -> a -> a
17:52:46 <tromp> :t let f = 0:scanl(+) 1 f in f
17:52:47 <lambdabot> forall t. (Num t) => [t]
18:05:30 <electron_x> just wandering how do i do tail recursion in haskell
18:05:40 <Botje> you just .. do it
18:05:43 <Botje> @src map
18:05:43 <lambdabot> map _ []     = []
18:05:43 <lambdabot> map f (x:xs) = f x : map f xs
18:05:55 <electron_x> i made a length func but seems to stack overflow even though it has an accum
18:06:09 <Botje> can you paste it?
18:06:13 <Botje> or put it on hpaste?
18:06:49 <electron_x> i did this len l a = len l (a+1)
18:06:57 <electron_x> len [] a = a
18:07:02 <Botje> okay
18:07:10 <electron_x> change the a above to (x:xs)
18:07:11 <electron_x> srry
18:07:16 <Botje> .. what?
18:07:21 <electron_x> in the first func
18:07:21 <Botje> can you paste exactly what you had?
18:07:35 <electron_x> i don't have it here but thats the jist of it
18:07:50 <Botje> it doesn't typecheck
18:07:57 <electron_x> len (x:xs) a = len xs (a+1)
18:08:06 <electron_x> len [] a = a
18:08:16 <electron_x> len :: [a] -> b
18:08:23 <electron_x> len :: [a] -> Int srry
18:08:40 <Botje> again, that doesn't typecheck :)
18:08:45 <electron_x> and i would use it like this len [1,2,3,4] 0
18:08:49 <electron_x> lol
18:08:54 <Botje> :ty let len (x:xs) a = len xs (a+1) in len
18:08:55 <electron_x> how come?
18:09:03 <Botje> @ty let len (x:xs) a = len xs (a+1) in len
18:09:03 <lambdabot> forall t a t1. (Num a) => [t] -> a -> t1
18:09:14 <Botje> types are important in haskell :)
18:09:33 <Botje> it's [a] -> b -> b here
18:09:42 <mauke> electron_x: it overflows in a, not len
18:09:59 <electron_x> i'm confused
18:10:12 <mauke> lazy evaluation
18:10:30 <Botje> electron_x: if you say a+1, haskell doesn't evaluate it right away
18:10:39 <Botje> it only does so when you actually want the value of a
18:10:40 <electron_x> oh
18:10:57 <electron_x> should i use the where clause then?
18:10:58 <Botje> but in the meantime, a is a "thunk" (unevaluated expression) that keeps growing larger and larger
18:11:06 <electron_x> currLen = a + 1
18:11:11 <mauke> doesn't help
18:11:14 <Botje> that won't help
18:11:15 <mauke> that's still lazy
18:11:38 <electron_x> wierd why wouldn't it?
18:11:44 <mauke> why would it?
18:11:52 <Botje> a would only get evaluated when currLen would
18:11:59 <Botje> which only happens at the end of your calls, atm
18:12:13 <electron_x> so it would go all the way to the end of the recursion?
18:12:18 <Botje> one fix is: len _ a | a `seq` False = undefined
18:12:31 <mauke> pfft, len xs $! (a+1)
18:12:35 <Botje> the other is to do len (x:xs) a = len xs $! 1 + a
18:12:44 <electron_x> what is $
18:12:47 <mauke> or compile with -O2
18:12:52 <mauke> or just use 'length'
18:13:03 <mauke> @src ($!)
18:13:03 <lambdabot> f $! x = x `seq` f x
18:13:20 <Botje> f $! x means: evaluate x, throw that away, then evaluate f x
18:13:25 <electron_x> omg this is really confusing
18:13:56 <Botje> and len shouldn't stack overflow on a list of 4, really
18:14:11 <sw17ch> eh, it gets much better
18:14:11 <electron_x> i did [1..1000000]
18:14:21 <gwern> @seen dons
18:14:21 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc and #haskell. I last heard dons speak 3h 15m 25s ago.
18:14:23 <mauke> > length [1..1000000]
18:14:24 <lambdabot>  1000000
18:14:26 <sw17ch> @src length
18:14:27 <lambdabot> Source not found. Where did you learn to type?
18:14:31 <Botje> > let len (x:xs) a = len xs $! a + 1; len [] a = a in len [1..1000000]
18:14:31 <lambdabot>  <Integer -> Integer>
18:14:35 <Botje> > let len (x:xs) a = len xs $! a + 1; len [] a = a in len [1..1000000] 0
18:14:36 <lambdabot>  1000000
18:14:38 <Botje> silly function.
18:14:51 <mauke> > let len (x:xs) a = len xs (a + 1); len [] a = a in len [1..1000000] 0
18:14:52 <lambdabot>  1000000
18:14:57 <mauke> the magic of -O2!
18:15:03 <electron_x> lol
18:15:19 <electron_x> i want to know how to do proper stackless tail recursion
18:15:33 <electron_x> not use -02 :)
18:15:34 <dobblego> take a look at seq or $! then
18:15:41 <dobblego> ?src foldl'
18:15:41 <lambdabot> foldl' f a []     = a
18:15:41 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
18:15:45 <mauke> what you wrote is proper stackless tail recursion
18:15:58 <electron_x> which doesn't works :)
18:16:09 <geezusfreeek> right because it's creating a huge chain of thunks
18:16:16 <mauke> it constructs the value 1 + (1 + (1 + (1 + ...))))) in a very efficient manner
18:16:27 <Botje> *G*
18:16:31 <mauke> it overflows during the evaluation of that value
18:16:44 <Botje> s/evaluation/construction
18:16:49 <mauke> what?
18:16:50 <newsham> "chain of thunks" would be a nice icfp team name
18:16:57 <mauke> no, construction runs in O(1) space
18:17:00 <Cale> mauke: isn't that backward?
18:17:00 <electron_x> see that would have worked in prolog :)
18:17:12 <Botje> electron_x: haskell is not prolog.
18:17:13 <geezusfreeek> yeah, it's the construction that causes the overflow
18:17:29 <mauke> ‽
18:17:38 <Cale> It constructs (((...((0 + 1) + 1) + 1 ...) + 1) + 1) + 1
18:17:41 <Botje> in haskell you don't need the extra parameter either
18:17:46 <ski> ski annotated #58905 with "cleanup" at http://paste.lisp.org/display/58905#4
18:17:50 <ski> bah, n00b left
18:17:59 <Cale> It's not the construction, but the evaluation after which causes the stack overflow.
18:18:01 <Botje> len (x:xs) = 1 + len xs
18:18:11 <Botje> len [] = 0
18:18:13 <mauke> Botje: that's not tail recursive
18:18:37 <ddarius> Cale: That's what mauke said.
18:18:51 <Cale> <mauke> it constructs the value 1 + (1 + (1 + (1 + ...))))) in a very efficient manner
18:18:52 <Botje> it's idiomatic haskell. let the compiler do the dirty work
18:18:56 <mauke> modulo associativity
18:19:07 <electron_x> can someone write a stack less length func for me without any fancy operators
18:19:16 <mauke> electron_x: len = length
18:19:19 <mauke> done
18:19:22 <tromp> @let f = (0:scanl(+) 1 f
18:19:22 <lambdabot>  Parse error
18:19:26 <dobblego> Botje, it isn't idiomatic Haskell
18:19:28 <tromp> @let f = 0:scanl(+) 1 f
18:19:28 <lambdabot> <local>:2:17:     Ambiguous occurrence `f'     It could refer to either `L.f'...
18:19:30 <tromp> :t f
18:19:31 <lambdabot> forall a. (FromExpr a) => a
18:19:42 <sw17ch> what does the # after certain variables and values mean?
18:19:48 <tromp> :t let f = (0:scanl(+) 1 f
18:19:49 <lambdabot> parse error (possibly incorrect indentation)
18:19:50 <jsnx> electron_x: yeah, you'd need an accumulating parameter
18:19:53 <sw17ch> for example in the definition of length in prelude
18:19:53 <tromp> :t let f = 0:scanl(+) 1 f
18:19:54 <lambdabot> <local>:2:17:
18:19:54 <lambdabot>     Ambiguous occurrence `f'
18:19:54 <lambdabot>     It could refer to either `L.f', defined at <local>:2:0
18:19:58 <sw17ch> http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-List.html#length
18:19:59 <lambdabot> http://tinyurl.com/23ncyu
18:20:03 <ddarius> Cale: And that is followed by '[20:16] <mauke> it overflows during the evaluation of that value' and both statements agree exactly with what you said.
18:20:08 <tromp> :t let g = 0:scanl(+) 1 g
18:20:09 <lambdabot> <local>:2:17:
18:20:09 <lambdabot>     Ambiguous occurrence `f'
18:20:09 <lambdabot>     It could refer to either `L.f', defined at <local>:2:0
18:20:21 <mauke> :t 2
18:20:21 <electron_x> that len func looks crazy
18:20:22 <lambdabot> forall t. (Num t) => t
18:20:25 <ski> tromp : you're forgetting `in'
18:20:29 <electron_x> 2#
18:20:32 <electron_x> e.t.c
18:20:36 <geezusfreeek> sw17ch: it means the value is unboxed
18:20:38 <tromp> ah
18:20:41 <electron_x> why do you have to use unwrapped vals
18:20:45 <tromp> how can i define that f in ghci?
18:20:49 <newsham> > let length (x:xs) = 1 + length xs; length [] = empty in length "testing"
18:20:50 <lambdabot>   add an instance declaration for (Num (f a))
18:20:50 <Cale> > let len xs = len' 0 xs where len' n [] = n; len' n (x:xs) = n `seq` len' (n+1) xs in len [1..1000]
18:20:51 <lambdabot>  1000
18:21:09 <ski> @let L.f = 0 : scanl (+) 1 L.f
18:21:10 <lambdabot>  Parse error in pattern
18:21:10 <electron_x> let len xs = len' 0 xs where len' n [] = n; len' n (x:xs) = n `seq` len' (n+1) xs in len [1..1000]
18:21:12 <Cale> There's a strict tail recursive length
18:21:24 <electron_x> let len xs = len' 0 xs where len' n [] = n; len' n (x:xs) = n `seq` len' (n+1) xs in len [1..1000000]
18:21:39 <ski> > let len xs = len' 0 xs where len' n [] = n; len' n (x:xs) = n `seq` len' (n+1) xs in len [1..1000000]
18:21:40 <lambdabot>  1000000
18:21:42 <electron_x> what does seq do
18:22:07 <dobblego> tromp, you precede it with 'let'
18:22:08 <mauke> > let len [] = 0; len (_:xs) = 1 + len xs in len [1..1000000]
18:22:09 <lambdabot>  1000000
18:22:17 <mauke> > let len [] = 0; len (_:xs) = 1 + len xs in len [1..10000000]
18:22:20 <geezusfreeek> a `seq` b means evaluate a and return b
18:22:21 <lambdabot>  Exception: stack overflow
18:22:21 <tromp> if i type "let f = 0:scanl(+) 1 f" in ghci, it gets type f :: [Integer]
18:22:35 <electron_x> is it build in?
18:22:35 <Cale> electron_x: seq x y, when evaluated, will cause x to be evaluated before resulting in y
18:22:39 <Cale> electron_x: yes
18:22:41 <Saizan> tromp: forgot an 'in' ?
18:22:49 <electron_x> so i should use that
18:22:55 <Cale> electron_x: However, it's essentially the same thing as pattern matching
18:22:56 <newsham> > let length (x:xs) = 1 + length xs; length [] = z in length "testing"
18:22:56 <lambdabot>  1 + (1 + (1 + (1 + (1 + (1 + (1 + z))))))
18:23:00 <Saizan> :t let f = 0:scanl(+) 1 in f
18:23:01 <lambdabot>     Couldn't match expected type `[t]'
18:23:01 <lambdabot>            against inferred type `[a] -> [a]'
18:23:01 <lambdabot>     In the second argument of `(:)', namely `scanl (+) 1'
18:23:02 <Cale> You could also use bang patterns.
18:23:04 <Botje> tromp: it's valid syntax if you're in a monad (in the case of GHCI: the IO monad)
18:23:09 <Cale> which force the evaluation in a similar way
18:23:14 <mauke> > let len [] a = a; len (_:xs) a = len xs (a+1) in len [1..10000000] 0
18:23:17 <lambdabot>  10000000
18:23:24 <Saizan> :t let f = 0:scanl(+) 1 f in f
18:23:25 <Cale> > let len xs = len' 0 xs where len' n [] = n; len' (!n) (x:xs) = len' (n+1) xs in len [1..10000000]
18:23:25 <lambdabot>  Parse error in pattern at "in" (column 78)
18:23:25 <lambdabot> forall t. (Num t) => [t]
18:23:41 <Botje> *burp*
18:23:41 <tromp> i can do :t let f = 0:scanl(+) 1 f in f but that doesn define f
18:23:42 <Cale> Except the bot isn't configured to use bang patterns, it seems.
18:23:43 <Botje> time for sleep
18:23:51 <electron_x> why did mauke's version work/
18:24:03 <mauke> electron_x: because lambdabot compiles with optimizations enabled
18:24:04 <electron_x> > let len [] a = a; len (_:xs) a = len xs (a+1) in len [1..100000000] 0
18:24:05 <tromp> how can i define f of the general type?
18:24:08 <lambdabot> Terminated
18:24:11 <electron_x> oh
18:24:30 <Cale> electron_x: With optimisations, the compiler will automatically discover places which can be made strict.
18:25:17 <electron_x> i think now i know why people don't use haskell more
18:25:24 <electron_x> its freaken confusing
18:25:35 <mauke> no, it's very simple
18:25:40 <electron_x> lol
18:25:48 <electron_x> not for a c programmer
18:25:49 <mauke> you're just using the wrong mental model
18:25:55 <Cale> electron_x: Initially it might be, if you already know an imperative language.
18:25:55 <sw17ch> electron_x: i'm a C programmer :P
18:26:01 <electron_x> even prolog seemed but easier
18:26:02 <jeffz> electron_x: I'm a C programmer
18:26:04 <sw17ch> electron_x: it's made me a much better one
18:26:17 <dobblego> electron_x, most of the people in this channel can use C quite effectively
18:26:23 <geezusfreeek> i'm also a c programmer, but i much prefer haskell
18:26:29 <mauke> if you think C isn't confusing, explain why [] is commutative in C :-)
18:26:29 <Cale> electron_x: These are the sorts of details you don't usually worry about until your second month or so.
18:27:15 <electron_x> Cale: i have only been learning it for 3 days now :)
18:27:15 <dobblego> electron_x, when you say confusing, you might consider instead using the word 'different' and reserving judgement for now
18:27:21 <Cale> Strictness annotations are the sort of thing which are needed maybe once or twice in a large project :)
18:27:32 <Cale> (depending on what you're doing)
18:27:37 <dolio> That's always a favorite in the IOCCC. 5["jigginz"]
18:27:56 <newsham> haskell programming isnt like C programming.
18:28:07 <newsham> which might come as a shock after learning many languages that are like C programming
18:28:18 <dobblego> electron_x, one of Haskell's primary objectives is to not be confusing and it has achieved it quite successfully; which is why you'll see the responses you do :)
18:28:29 <BrahmsC> what is haskell good for ?
18:28:35 <Cale> BrahmsC: Programming :)
18:28:36 <dobblego> a "user interface" as SPJ would put it
18:28:39 <SamB> mauke: that's not confusing unless you are trying to read code...
18:28:43 <araujo> Cale, hah
18:28:58 <dobblego> BrahmsC, seducing women
18:29:05 <Cale> What is any general purpose programming language good for? :)
18:29:20 <newsham> perl is good for recycling line noise.
18:29:21 <BrahmsC> Cale: oh! i mean C is for lower level programming, what is haskell specialty
18:29:26 <electron_x> so how many of you here use haskell at work?
18:29:30 <Cale> BrahmsC: Well, it's quite high level.
18:29:33 <dobblego> electron_x, I do
18:29:42 <dobblego> electron_x, among many languages
18:29:46 <electron_x> does your boss object?
18:29:47 <kilimanjaro> BrahmsC, PhD theses? You can do whatever you want with it, really
18:29:59 <dobblego> electron_x, my boss asks me questions when his Haskell doesn't work properly
18:30:07 <electron_x> lol
18:30:07 <roconnor> I use Haskell to prototype before moving onto Coq.
18:30:22 <kilimanjaro> roconnor, what doy ou use Coq for?
18:30:25 * electron_x googles Coq
18:30:26 <Cale> BrahmsC: I've found it's quite nice for combinatorial search algorithms, but I'm sure it's quite nice for a lot of things :)
18:30:32 <sw17ch> electron_x: my haskell generates my C
18:30:35 <newsham> roc: wow, hardcore.
18:30:36 <sw17ch> *sometimes*
18:31:09 <SamB> I seem to like compilers
18:31:30 <mauke> I've prototyped Haskell code in C before :-)
18:31:33 <roconnor> kilimanjaro: I've implemented the constructive real numbers.  Computing with real numbers is potentially useful for verifying hyrid-system designs, etc.
18:31:36 <sw17ch> electron_x: haskell is good if only because it makes you think far differently about programming.
18:31:41 <electron_x> coq sounds interesting
18:31:43 <roconnor> hybrid-systems
18:32:02 <roconnor> electron_x: it's like Haskell, but with dependent types, and no IO.
18:32:06 <kilimanjaro> roconnor, what's the definition of constructive real numbers?
18:32:25 <electron_x> does anyone here use oCaml?
18:32:51 <roconnor> kilimanjaro: there are lots of definitions.  A common definition is a constructive sequence that is constructively Cauchy.
18:33:10 <electron_x> i think the silence means i have committed heresy
18:33:15 <mauke> electron_x: I used to
18:33:26 <Cale> electron_x: Lots of people here have, I'm sure. :)
18:33:38 <electron_x> mauke: why did you stop?
18:33:42 <Cale> electron_x: I haven't used it extensively, but I've looked at it.
18:33:43 <SamB> electron_x: I think the silence is just mostly people not answering in the affirmative...
18:33:53 <kilimanjaro> roconnor, I've never heard the word "constructive" used before like that so I'm just curious, but that answer is sort of like if you had asked "What's baseball" and I say "It's a game that is played with bases and balls"
18:34:12 <roconnor> electron_x: Coq is writen in Ocaml.  Everytime something sucks about CoqIDE, I blame OCaml. :P
18:34:17 <mauke> electron_x: well, I learned Haskell, and after that OCaml just seemed so ugly and inflexible
18:34:35 <roconnor> kilimanjaro: constructive logic is an extension of classical logic
18:34:37 <electron_x> oh i see
18:34:41 <newsham> why cant the ML guys adopt some of haskell syntax?
18:34:47 <geezusfreeek> i started my ventures into functional programming with ocaml, but i didn't like it
18:34:48 <roconnor> kilimanjaro: it adds two new connectivs
18:34:48 <jsnx> i'm having some real trouble with the State Monad
18:34:50 <newsham> pattern matching in function definitions would be nice
18:34:51 <geezusfreeek> luckily haskell redeemed me
18:35:04 <roconnor> kilimanjaro: the constructive disjunction, and the constructive existential quantifier.
18:35:05 <Cale> newsham: they really ought to, but are probably stuck with legacy codebases :)
18:35:10 <newsham> jsnx: do you have questions?
18:35:18 <jsnx> newsham: yes
18:35:33 <jsnx> i am trying to make a `State (Ptr a) b`
18:35:43 <jsnx> and i keep having to declare all the instances
18:35:44 <roconnor> kilimanjaro: when you have a proof of A or B (or being the constructive disjunction) then it is either a proof of A or a proof of B.
18:35:51 <SamB> Cale: why don't they come up with a new syntax that new code can use, or something?
18:35:52 <jsnx> or huge type contexts
18:36:08 <jsnx> MonadState (Ptr b) (State (Ptr a))) => State (Ptr a) b
18:36:12 <Cale> SamB: good question :)
18:36:12 <jsnx> for example
18:36:32 <newsham> hmm...  why?
18:36:41 <Cale> SamB: It's also possible that everyone who would want to do that has simply moved to Haskell.
18:36:42 <jsnx> GHCi demans it
18:36:45 <roconnor> kilimanjaro: when you have a proof that there exists x:A. B(x) (exists being the constructive existential quantifier) then you have a pair (a, p) where a is of type A, and p is a proof of B(a).
18:37:01 <geezusfreeek> one more thing about strictness annotations before it gets too stale… the main reason you generally don't have to worry about it using them most of the time is because, in addition to the fact that it can be compiled in for you in most cases, higher level control structures also exist that have strictness already built in as well
18:37:01 <Saizan> jsnx: are you trying to use it with pointers of different types?
18:37:07 <geezusfreeek> like foldl'
18:37:07 <jsnx> Saizan: yes
18:37:13 <jsnx> but not at the same time
18:37:17 <Cale> jsnx: What are you doing with the pointers?
18:37:18 <geezusfreeek> which is what i would probably use if i was writing a len function
18:37:24 <kilimanjaro> roconnor, ok, so you are interested in the numbers that can be constructed by some algorithm, all natural numbers fall into this category, you make the integers and rationals, all is fine, then reals have uncomputable elements so you are working just with the subset that is "constructable"?
18:37:28 <jsnx> plusPlus
18:37:31 <jsnx> deRef
18:37:36 <jsnx> just one pointer at a time
18:37:39 <Cale> jsnx: You can't actually dereference them in that monad.
18:37:51 <jsnx> with unsafePerformIO i can
18:37:59 <mauke> ...
18:38:06 <jsnx> and they are statically arrays
18:38:07 <geezusfreeek> > let len = Data.List.foldl' (const . (1+)) 0 in len [1..1000000]
18:38:07 <lambdabot>  1000000
18:38:13 <Cale> jsnx: that's... uh... how we say, "made of fail".
18:38:29 <SamB> Cale: I thought that was how the people talked in #zsnes
18:38:41 <roconnor> kilimanjaro: right, constructive real numbers are those real numbers where there exists a provably terminating algorithm for computing some rational approximation of the real number to arbitary precision.
18:38:45 <jsnx> Cale: they are array literals in a C file, linked into the haskell app
18:38:56 <newsham> perhaps you want StateT IO?
18:38:58 <kilimanjaro> roconnor, ok, that makes sense
18:39:00 <Cale> jsnx: You should use the array marshalling library.
18:39:04 <electron_x> >:type seq
18:39:16 <jsnx> okay, let's try this again
18:39:20 <electron_x> >seq
18:39:20 <SamB> Cale: does that actually copy the arrays?
18:39:42 <jsnx> i want to make a nice little monadic interface to walk up and down pointers
18:39:43 <electron_x> hmm
18:39:51 <kpreid> ?type seq
18:39:52 <lambdabot> forall a t. a -> t -> t
18:39:57 <electron_x> ah
18:40:00 <Cale> hmm
18:40:01 <electron_x> ?type seq
18:40:03 <lambdabot> forall a t. a -> t -> t
18:40:05 <kpreid> :t seq
18:40:06 <lambdabot> forall a t. a -> t -> t
18:40:06 <jsnx> i'm using the State Monad and would like to understand it better
18:40:10 <kpreid> @type seq
18:40:11 <lambdabot> forall a t. a -> t -> t
18:40:22 <electron_x> whats the dot after the t
18:40:35 <newsham> it ends the "forall a t" part
18:40:37 <allbery_b> the end of the forall clause
18:40:44 <jsnx> in particular, I don't see why i have to make all these verbose class contexts
18:41:02 <electron_x> > forall 2 3
18:41:02 <lambdabot>   Not in scope: `forall'
18:41:10 <newsham> jsnx: I also dont see why :)
18:41:18 <jsnx> newsham: okay, cool
18:41:24 <newsham> ex: its part of the type decl, not part of the code
18:41:25 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-Storable.html
18:41:26 <lambdabot> http://tinyurl.com/5qhtwj
18:41:36 <electron_x> >seq 2 3
18:41:37 <geezusfreeek> electron_x: forall just means "given any a and any t"
18:41:40 <jsnx> Cale: that's in IO, right?
18:41:49 <Saizan> jsnx: show some code, it might be either the dreaded monomorphism restriction or a lack of context for the type inference to work
18:41:52 <Cale> Well, yes, of course.
18:42:01 <jsnx> Saizan: aye, uploading it
18:42:05 <Cale> Pointer manipulation *is an IO operation*
18:42:09 <geezusfreeek> so (forall a t. a -> t -> t) means "take any a and any t and return a t"
18:42:20 <jsnx> Cale: not if there are no other files involved...
18:42:23 <electron_x> thats confusing
18:42:24 <ivanm> is there a function that would automatically escape characters in a string?
18:42:30 <geezusfreeek> it is usually implicit in function types
18:42:34 <Cale> jsnx: It has side effects.
18:42:35 <mauke> ivanm: show
18:42:41 <jsnx> Cale: like?
18:42:45 <SamB> jsnx: wait, your arrays are made of pointers???
18:42:48 <Cale> jsnx: Like updating things.
18:42:52 <electron_x> >2 'seq' 3
18:42:54 <jsnx> Cale: like what?
18:42:59 <jsnx> SamB: yes
18:43:00 <electron_x> >2 seq 3
18:43:00 <Cale> jsnx: Like your array.
18:43:06 <kpreid> electron_x: ` not ' and a space
18:43:06 <Saizan> electron_x: you need a space
18:43:06 <newsham> > show (show "testing\nthis\"out\123foo.")
18:43:07 <lambdabot>  "\"\\\"testing\\\\nthis\\\\\\\"out{foo.\\\"\""
18:43:10 <kpreid> > 2 `sea` 3
18:43:10 <lambdabot>   Not in scope: `sea'
18:43:14 <SamB> so ... wouldn't it be better to generate Haskell values at compile time?
18:43:15 <electron_x> ah
18:43:17 <jsnx> Cale: how does it update it?
18:43:20 <electron_x> > 2 seq 3
18:43:20 <lambdabot>        add an instance declaration for (Num ((a -> b -> b) -> t -> a1))
18:43:25 <jsnx> SamB: you can't
18:43:29 <jsnx> SamB: there are too many
18:43:36 <Cale> jsnx: and the present contents of the array will influence the results of dereferencing the pointer of course.
18:43:37 <jsnx> GHC chokes and dies
18:43:56 <electron_x> > seq 3
18:43:56 <lambdabot>  Add a type signature
18:43:57 <roconnor> > 2 `seq` 3
18:43:57 <Cale> jsnx: Basically, unsafePerformIO -> you're doing it wrong.
18:43:58 <lambdabot>  3
18:44:02 <Cale> Trust us :)
18:44:03 <SamB> you could, of course, also just use unsafeInterleaveIO to generate them dynamically...
18:44:05 <jsnx> Cale: if i dereference a pointer and read from it, i don't see how that changes anything at all
18:44:12 <jsnx> Cale: spoken like a true UNIX hater
18:44:14 <electron_x> why do i need ' around seq
18:44:21 <kpreid> electron_x: you don't
18:44:25 <kpreid> > seq 2 3
18:44:25 <Cale> jsnx: It's a kind of input effect.
18:44:25 <lambdabot>  3
18:44:26 <roconnor> `foo` make a function infix
18:44:31 <newsham> jsnx: it points to mutable state which could be different next time you read from it
18:44:32 <jsnx> Cale: what?
18:44:33 <electron_x> > 2 seq 3
18:44:34 <lambdabot>        add an instance declaration for (Num ((a -> b -> b) -> t -> a1))
18:44:38 <kpreid> electron_x: a `b` c is another way of writing b a c
18:44:39 <Cale> jsnx: It's like readFile
18:44:42 <jsnx> newsham: the data is not mutable
18:44:51 <jsnx> newsham: the only pointers to it are const
18:44:55 <electron_x> > 2  3
18:44:56 <kpreid> electron_x: so 2 `seq` 3 is the same as seq 2 3
18:44:56 <lambdabot>   add an instance declaration for (Num (t -> a))
18:44:57 <newsham> oh, you're saying its safe to unsafeperform
18:44:59 <electron_x> > 2 + 3
18:45:00 <lambdabot>  5
18:45:05 <jsnx> newsham: which is why i do it
18:45:07 <electron_x> i can do that
18:45:16 <Saizan> isn't this like foreign importing a function as pure?
18:45:19 <ivanm> mauke: doesn't that escape the quotes as well?
18:45:19 <mauke> > 2 `mod` 3
18:45:20 <lambdabot>  2
18:45:24 <electron_x> seq 2 4
18:45:24 <mauke> ivanm: yes
18:45:30 <electron_x> > seq 2 4
18:45:30 <lambdabot>  4
18:45:36 <electron_x> > seq 2 4 4
18:45:36 <lambdabot>   add an instance declaration for (Num (t -> a))
18:45:38 <roconnor> electron_x: operator symbols are infix by default, but can be made prefix
18:45:39 <kpreid> > (+) 2 4
18:45:40 <lambdabot>  6
18:45:54 <electron_x> i see
18:46:09 <jsnx> Cale: if a file were guaranteed read only, i would do it
18:46:12 <Cale> jsnx: If your array is actually pure, I recommend getting it into something like a Data.Array array.
18:46:21 <YourAlgebra> has anyone heard from dibblego
18:46:26 <jsnx> Cale: GHC can't do it
18:46:28 <Cale> YourAlgebra: he's been around
18:46:32 <jsnx> Cale: really, i tried
18:46:33 <Cale> jsnx: Sure it can.
18:46:34 <ddarius> @seen dibblego
18:46:34 <lambdabot> dibblego is in #jtiger, #scala and #haskell. I last heard dibblego speak 4h 26m 27s ago.
18:46:35 <dobblego> @seen dibblego
18:46:35 <lambdabot> dibblego is in #jtiger, #scala and #haskell. I last heard dibblego speak 4h 26m 28s ago.
18:46:39 <jsnx> Cale: no, it can't
18:47:04 <YourAlgebra> wow... that thing keeps tabs
18:47:13 <ddarius> lambdabot sees all
18:47:20 <YourAlgebra> DOBBLEGO!
18:47:25 <dobblego> hello YourAlgebra
18:47:35 <YourAlgebra> long time no see!
18:47:48 <dobblego> indeed it is
18:47:57 <YourAlgebra> why no java?
18:48:19 <jsnx> Cale: i tried, really
18:48:24 <electron_x> ?type forall
18:48:25 <lambdabot> Not in scope: `forall'
18:48:29 <dobblego> I have recently pledged to make more effort to hang around people smarter than myself
18:48:29 <jsnx> Cale: my only option is a ByteString
18:48:30 <Cale> jsnx: You could at least use unsafeForeignPtrToStorableArray
18:48:58 <Cale> jsnx: Which is only unsafe in the sense that it can't tell whether the bounds you provide are accurate.
18:49:27 <jsnx> Cale: my array is actually a serialized trie which has offsets in it, and i use the offsets to tell me how much further to walk in the trie
18:49:41 <jsnx> Cale: this doesn't seem like i can abstract away the pointers
18:50:07 <YourAlgebra> what about the people who want to be around smart people than themselfs
18:50:09 <kpreid> surely you can use array indexes instead?
18:50:10 <Cale> jsnx: Do you know the total size?
18:50:17 <jsnx> https://svn.j-s-n.org/public/haskell/cedict/Data/Char/CEDICT/C/PtrWalker.hs
18:50:18 <Cale> Yeah, use array indexes.
18:50:19 <lambdabot> http://tinyurl.com/5l2c5j
18:50:20 <jsnx> Cale: yes
18:50:41 <dobblego> YourAlgebra, that's precisely why I am here for example, stay and learn!
18:51:08 <YourAlgebra> Sure!
18:51:13 <jsnx> Cale: aesthetically, i am apalled by the idea of a copying a large array into Haskell for no safety or speed gain
18:51:31 <dobblego> YourAlgebra, there was someone here not long ago who'd just started (3 hours) with Haskell
18:51:37 <Cale> It's an enormous safety gain.
18:51:51 <jsnx> Cale: you have yet to explain how
18:52:03 <Cale> Okay, suppose some C function deallocates the array.
18:52:08 <YourAlgebra> neat
18:52:13 <Cale> The Haskell GC is unaware of that.
18:52:16 <jsnx> Cale: i don't have any C functions
18:52:23 <Cale> Uh...
18:52:28 <jsnx> Cale: i have C arrays
18:52:35 <Cale> Why do you have C arrays?
18:52:46 <jsnx> Cale: because i can make huge static arrays in C
18:52:46 <Cale> Why not just use Haskell arrays?
18:52:57 <jsnx> Cale: because GHC throws up
18:53:02 <Cale> huh?
18:53:07 <atp> that would be a bug
18:53:10 <Cale> Let's fix *that* program. :)
18:53:11 <atp> you should report it
18:53:19 <jsnx> i have
18:53:22 <jsnx> on this channel
18:53:24 <jsnx> on trac
18:53:27 <jsnx> on the mailing list
18:53:28 <atp> what the trac number
18:53:32 <atp> *'s
18:53:35 <YourAlgebra> dobblego; i'm learning actionscript, mxml, lotus script, javascript, and C# at the same time
18:53:42 <jsnx> SPJ says "well, this is a problem, we have not fixed it yet"
18:53:52 <YourAlgebra> and jdbc
18:54:01 <jsnx> Cale: fixing that problem would take 1337 C programming skills
18:54:27 <atp> leet C programming skills are hardly in short supply around here
18:54:27 <Cale> jsnx: What's the actual problem?
18:54:43 <Saizan> jsnx: first of all: type PtrWalker a b = (MonadState (Ptr a) (State (Ptr a))) => State (Ptr a) b, so later deRef :: Storable b => PtrWalker b b
18:54:46 <kilimanjaro> YourAlgebra, hehe, if that's the case you might consider changing nicks from "YourAlgebra" to "YourCrazy"
18:54:47 <Cale> I'm sure there's another way we can easily do it :)
18:55:05 <atp> i'd like to see the bug on trac
18:55:06 <YourAlgebra> kilimanjaro; school and work is doing it to me
18:55:15 <atp> just so i can digest what the problem is more thoroughly
18:55:31 <Cale> Like, read the data from a file.
18:55:39 <Cale> (surely that works)
18:55:40 <Saizan> jsnx: also it's because of the monomorphism restriction that you've to write those type signatures
18:55:43 <ddarius> kilimanjaro: I have to agree with YourAlgebra.  You could easily have to learn all those languages simultaneously just for a job.
18:55:49 <jsnx> Saizan: thank you
18:56:13 <kilimanjaro> ddarius, I wasn't talking about the number of languages, but the choice of languages
18:56:32 <kilimanjaro> I want to live in a Haskell haven
18:56:36 <ddarius> kilimanjaro: I didn't just say "that many", I said "those".
18:56:45 <kilimanjaro> ddarius, I accused you of nothing
18:56:53 <gwern> @seen dons
18:56:53 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc and #haskell. I last heard dons speak 3h 57m 57s ago.
18:57:00 <ddarius> kilimanjaro: And I accused you of nothing.
18:57:01 <jsnx> Saizan: so, i'll try disabling monomorphism first...
18:57:09 <YourAlgebra> i'll brb
18:57:34 <electron_x> why does seq need two values if it ignore the other?
18:57:49 <kilimanjaro> ddarius, then we are at agreement. Pistols, in the town commons, tomorrow at noon. Dress nicely, so that you may make a good impression on Peter at the gate!
18:58:04 <ddarius> electron_x: The whole point of seq is the "value it ignores".
18:58:17 <Cale> YourAlgebra: Which kind of Algebra are you? An affine Hecke algebra perhaps?
18:58:19 <electron_x> why?
18:58:42 <electron_x> seems like a waste to me
18:58:44 <ddarius> electron_x: Because otherwise it'd just be const.
18:59:05 <atp> jsnx: i can't seem to find your bug on trac, what's it called
18:59:56 <mauke> > flip const (1 `div` 0) "hi"
18:59:56 <lambdabot>  "hi"
18:59:59 <jsnx> atp: searching, searching
19:00:00 <mauke> > seq (1 `div` 0) "hi"
19:00:02 <lambdabot>  Exception: divide by zero
19:00:22 <mauke> > seq (1 `div` 1) "hi"
19:00:23 <lambdabot>  "hi"
19:00:32 <jsnx> http://hackage.haskell.org/trac/ghc/ticket/2002
19:00:33 <lambdabot> Title: #2002 (problems with very large (list) literals) - GHC - Trac
19:00:43 <electron_x> damn
19:00:59 <jsnx> anyways, this is why i need C and unsafePerformIO
19:01:07 <atp> ah, i see, i was searching for array
19:01:25 <jsnx> atp: arrays have to built from lists
19:01:27 <Cale> jsnx: Why are you not just loading the data from a file?
19:01:54 <jsnx> Cale: i have my reasons
19:02:00 <dancor> haha
19:02:10 <electron_x> can someone take a look at this http://pastebin.com/d2ab12f0a
19:02:28 <Cale> Cabal can install any necessary data files along with your program
19:02:29 <jsnx> Cale: what does it matter, really? are larger static constants such a bad idea?
19:02:39 <jsnx> Cale: my users will not have cabal
19:02:44 <jsnx> Cale: they have anger
19:02:57 <dancor> jsnx: maybe after there are bytestring literals
19:03:00 <Cale> what?
19:03:10 <mauke> electron_x: seq 0 has no effect
19:03:12 <jsnx> dancor: there already are
19:03:22 <electron_x> it still stack overflows
19:03:24 <jsnx> dancor: ByteStrings can do it
19:03:43 <Cale> electron_x: Your seq expression is buried inside the function parameter.
19:03:56 <jsnx> Cale: basically, the static data is for ease of distribution
19:04:01 <Cale> electron_x: also it just evaluates 0
19:04:16 <jsnx> Cale: this little dictionary is proof-of-concept
19:04:25 <electron_x> Cale; what about this? http://pastebin.com/d38a796a5
19:04:52 <thoughtpolice> you need -XOverloadedStrings and 0.9.0.4, and you can then do "hello world" :: ByteString which is pretty nice
19:05:26 <thoughtpolice> bytestring versioning issues are currently the main issue I kind of have with cabal right now; you'll build against one, upgrade and then lots of new stuff will break. ghc 6.8.3 should fix this right?
19:05:33 <Cale> electron_x: the seq has to get evaluated to have any effect
19:05:41 <thoughtpolice> (as well as cabal 1.3?)
19:05:54 <Cale> electron_x: and seq 0 x will never do anything but waste time evaluating 0 before returning x
19:06:09 <Cale> electron_x: (which, if it were just written as x, was already going to be evaluated)
19:06:58 <Cale> electron_x: Haskell is typically lazily evaluated. It might help if I explain lazy evaluation.
19:07:12 <Cale> Let's look at the function  double x = x + x
19:07:14 <electron_x> it evaluates things only when it needs them
19:07:22 <Cale> and the expression   double (double 5)
19:07:32 <electron_x> ok
19:07:36 <Cale> In a strict language, this is evaluated as follows:
19:07:39 <Cale> double (double 5)
19:07:44 <Cale> -> double (5 + 5)
19:07:47 <Cale> -> double 10
19:07:50 <Cale> -> 10 + 10
19:07:52 <Cale> -> 20
19:07:52 <electron_x> yes
19:08:04 <Cale> Innermost leftmost first
19:08:19 <Cale> But we can also evaluate things outermost first
19:08:20 <electron_x> thats how i'm thinking about it
19:08:26 <dobblego> YourAlgebra, I don't particularly like learning Haskell; more so the interesting mathematical programming concepts that Haskell is useful for expressing
19:08:30 <Cale> That would go like this:
19:08:34 <Cale> double (double 5)
19:08:40 <Cale> -> (double 5) + (double 5)
19:08:46 <Cale> -> (5 + 5) + (double 5)
19:08:50 <Cale> -> 10 + (double 5)
19:08:54 <Cale> -> 10 + (5 + 5)
19:08:57 <Cale> -> 10 + 10
19:08:59 <Cale> -> 20
19:09:13 <electron_x> ok i see now
19:09:16 <Cale> Note however, that some time was wasted because double 5 got evaluated twice
19:09:23 <Cale> So lazy evaluation fixes that
19:09:44 <gwern> come to think of it; I have a segfaulting darcs binary. is there any clever GHC option to get me the last calling function?
19:09:49 <Cale> It says that if a parameter to a function is duplicated in the body, the results of evaluating the parameter (if that occurs) are shared between the copies
19:10:11 <Cale> So if you'll permit me to use  let ... in ...  to represent this sharing, the evaluation would go like:
19:10:16 <Cale> double (double 5)
19:10:22 <Cale> -> let x = double 5 in x + x
19:10:29 <Cale> -> let x = 5 + 5 in x + x
19:10:31 <Cale> -> let x = 10 in x + x
19:10:34 <Cale> -> 20
19:10:41 <mauke> or double (double 5) -> x@(double 5) + x -> x@(y@5 + y) + x -> x@10 + x -> 20
19:11:02 <Cale> If you want to use a strange notation, yeah :)
19:11:13 <electron_x> not strange notation please :)
19:11:13 <dolio> Burn!
19:11:16 <electron_x> no*
19:11:28 <mauke> hey, haskell already uses var@
19:11:29 <Cale> electron_x: Does what I wrote make sense?
19:11:32 <mauke> just not in this context
19:11:35 <Cale> mauke: but in patterns :)
19:11:37 <electron_x> Cale: yes
19:11:52 <electron_x> Cale: so how do i make my func work then?
19:11:55 <awesame> I am failing to come up with a pointfree way to write (foo >>= \a -> return (a++b))
19:11:58 <Cale> electron_x: Okay, so you can see now why tail recursive functions will build up large expressions in their parameters
19:12:04 <mauke> @pl  (foo >>= \a -> return (a++b))
19:12:04 <lambdabot> (++ b) `fmap` foo
19:12:05 <Cale> electron_x: let's look at one more program
19:12:09 <atp> i've often wondered how thunks are evaluated in a multi-threaded context without introducing race conditions
19:12:18 <electron_x> ok
19:12:22 <Cale> atp: they race but it doesn't matter.
19:12:25 <awesame> oh, fmap, duh
19:12:32 <atp> Cale: it doesn't?
19:12:44 <Cale> atp: Things are pure, so it must give the same result.
19:12:48 <dolio> atp: If they get evaluated twice, you do extra work, but the result is the same.
19:12:50 <byorgey> awesame: \a -> return (a++b) == \a -> return ((++b) a) == \a -> (return . (++b)) a == return . (++b)
19:12:54 <atp> Cale: couldn't expensiveFunction be evaluated twice (or 64 times, or whatever)?
19:13:07 <atp> ah
19:13:12 <Cale> atp: Plus, if there's even a slight difference in timing, one will hit the grey hole left by the other, and block.
19:13:19 <byorgey> awesame: and then f >>= return . y is the same as fmap f y
19:13:21 <atp> grey hole?
19:13:36 <awesame> byorgey: even better
19:13:46 <byorgey> equational reasoning ftw! =)
19:14:08 <Cale> atp: While an expression is being updated by evaluation, it's replaced by a pointer to a program which will make the process wait. (or die, in single threaded programs)
19:14:22 <atp> ah, i see.
19:14:47 <Cale> atp: There is a little window where they'll both evaluate it, but it's rare and safe.
19:14:55 <atp> so the double evaluation of a thunk is only possible if the other thread gets control in between the dereferencing and the replacement
19:14:57 <atp> right
19:14:57 <Cale> electron_x: Okay...
19:15:02 <atp> thanks cale
19:15:15 <Cale> electron_x: Let's look at foldl
19:15:18 <Cale> @src foldl
19:15:18 <lambdabot> foldl f z []     = z
19:15:18 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
19:15:23 <jsnx> Saizan: okay, i seem to have got it now
19:15:29 <Cale> Now, let's suppose I evaluate:
19:15:34 <Cale> foldl (+) 0 [1,2,3,4]
19:15:53 <Cale> -> foldl (+) (0+1) [2,3,4]
19:15:59 <jsnx> i just made `deRef :: PtrWalker a a` and that cleans everything up
19:15:59 <Cale> -> foldl (+) ((0+1)+2) [3,4]
19:16:06 <Cale> -> foldl (+) (((0+1)+2)+3) [4]
19:16:12 <Cale> -> foldl (+) ((((0+1)+2)+3)+4) []
19:16:18 <Cale> -> (((0+1)+2)+3)+4
19:16:20 <electron_x> ok
19:16:38 <Saizan> jsnx: fixing the PtrWalker definition, right?
19:16:43 <Cale> Now, that reduction there is indeed done by a tight loop -- but it's not doing the addition.
19:16:53 <jsnx> Saizan: it just has Storable in it
19:16:53 <electron_x> -> ((1+2) + 3) e.t.c
19:16:53 <Cale> Instead, you can see that it's building up a large expression.
19:17:10 <jsnx> Saizan: or maybe i did not understand your meaning with "fix"
19:17:31 <Cale> One which is at least as large as the original list (and may be larger, if the list itself was a small expression that generated a long list as it was evaluated)
19:17:33 <YourAlgebra> back
19:17:45 <Cale> So how do we prevent this?
19:17:53 <electron_x> yes
19:17:56 <jsnx> Saizan: it's in the same place
19:17:57 <jsnx> https://svn.j-s-n.org/public/haskell/cedict/Data/Char/CEDICT/C/PtrWalker.hs
19:17:57 <lambdabot> http://tinyurl.com/5l2c5j
19:17:59 <electron_x> let ?
19:18:03 <Cale> We want a variant of foldl which will perform the evaluation as it goes.
19:18:14 <Cale> And for this, we'll use seq
19:18:25 <Cale> (and let, but seq is the important bit)
19:18:32 <Cale> foldl' f z [] = z
19:18:50 <Cale> foldl' f z (x:xs) = let y = f z x in seq y (foldl' f y xs)
19:19:22 <Saizan> jsnx: you had the MonadState context wrong before, but since you've removed it.. fine :)
19:19:26 <electron_x> Cale can you bracket that a bit
19:19:31 <jsnx> Saizan: heh
19:19:32 <Cale> sure
19:19:44 <Cale> foldl' f z (x:xs) = let {y = f z x} in (seq y (foldl' f y xs))
19:19:51 <electron_x> thanks
19:20:07 <Cale> I'd use layout, but this is IRC, and that's annoying to get right on IRC :)
19:20:28 <electron_x> so y is bound to a function
19:20:28 <Cale> So we define y as the result of applying f to z and x
19:20:37 <Cale> This doesn't evaluate y on its own!
19:21:00 <Cale> But we know that if a let-expression is being evaluated, the 'in' part of it will be.
19:21:07 <Cale> and so the seq will get evaluated
19:21:26 <Cale> and the seq says to evaluate y before continuing with foldl' f y xs
19:21:41 <electron_x> oh i see
19:21:44 <jsnx> Saizan: i'm trying to make a `skipN :: Int -> PtrWalker a b`
19:21:52 <electron_x> but why does seq say that
19:21:59 <Cale> That's basically its definition.
19:22:04 <Cale> It's a language primitive.
19:22:12 <jsnx> GHCi objects because put implies PtrWalker a ()
19:22:31 <Cale> Really, if we have any nitpicking people in the crowd, they might point out that it doesn't *really* say that, but you can mostly assume that it does.
19:22:31 <electron_x> Cale; should i think of it as a magical builtin func?
19:22:39 <jsnx> must i have a return at the end of every function that's supposed to go in a State monad?
19:22:44 <Cale> It's somewhat magical, but we could implement it for most types.
19:22:55 <mauke> electron_x: yes
19:22:57 <Cale> for example, on lists, it would look like this:
19:23:08 <Cale> seq x y = case x of [] -> y; (x:xs) -> y
19:23:24 <Cale> The case expression would force the evaluation of x, to see which branch matches
19:23:32 <jsnx> Saizan: (code has been updated again)
19:23:32 <electron_x> Cale: just one thing
19:23:35 <Cale> and then the result would by y, regardless.
19:23:42 <mauke> Cale: couldn't a compiler notice that the branches are the same and merge them?
19:23:48 <electron_x> you have foldl' x [] = x
19:24:04 <electron_x> wouldn't nvm
19:24:11 <electron_x> just realized
19:24:12 <Cale> mauke: Indeed it could, but it wouldn't be terribly sane to do that.
19:24:23 <mauke> why?
19:24:52 <mauke> ah, because it's a semantic change
19:25:10 <mauke> if x is bottom, you get a different result so you have to force it anyway
19:25:13 <Cale> mauke: Not necessarily... in fact, I think it would still be valid Haskell...
19:25:28 <Cale> You could evaluate y first, and then before returning the result, evaluate x
19:25:33 <Saizan> jsnx: why  PtrWalker a b? that should be  PtrWalker a (), because of the type of put
19:25:37 <electron_x> Cale; so should i be doing that for all tail recursive funcs/
19:25:40 <electron_x> ?*
19:25:40 <lambdabot> Maybe you meant: . ? @ v
19:25:50 <Saizan> ?type put
19:25:50 <Cale> electron_x: I'd only do it if you have problems.
19:25:53 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
19:26:01 <Cale> electron_x: Usually compiling with optimisations will do it for you.
19:26:03 <jsnx> Saizan: yeah, you're right, i think
19:26:12 <Cale> electron_x: Just stick -O2 on your ghc commandline :)
19:26:17 <electron_x> Cale; can the compiler be relied on?
19:26:46 <jsnx> electron_x: as a yes or no question, that's a doozy either way
19:26:51 <electron_x> what about realy complex functions
19:27:04 <Saizan> jsnx: in your use of put, m = PtrWalker a, s = Ptr a
19:27:06 <ddarius> electron_x: Strictness analysis is undecideable.
19:27:13 <gwern> oh wow, this is fun. so I need Directory installed with profiling to profile darcs, but the hackage Directory can't be installed!
19:27:14 <Cale> Well, you can harm performance adding unnecessary seqs just as much as you can help it.
19:27:33 <electron_x> that kinda sucks
19:27:42 <gwern> I guess I'll spend tonight yak-shaving
19:27:55 <Cale> electron_x: I should also let you know that there's a slightly nicer notation for this
19:28:07 <Cale> electron_x: But it's a GHC extension (and not supported by lambdabot atm)
19:28:23 <electron_x> Cale: is it in hugs?
19:28:28 <Cale> hmm, I'm not sure
19:28:44 <ddarius> I'm pretty sure it isn't.
19:28:52 <Cale> If you add {-# LANGUAGE BangPatterns #-} to the top of your file, or compile with -XBangPatterns, then you can just stick a ! before any variable
19:29:01 <Cale> and it will seq that variable automatically for you
19:29:08 <electron_x> cool
19:29:16 <SamB> hmm, I'm not sure I much like wadler/daan's printing combinators :-(
19:29:19 <ddarius> Cale: "binding"
19:29:30 <electron_x> is lazy evaluation a good thing?
19:29:36 <Cale> electron_x: yes, very much so
19:29:47 <SamB> they looked so nice in theory, but actually getting them to print prettily seems a chore
19:29:51 <ddarius> It has benefits and costs just like everything else.
19:29:52 <electron_x> are there things that can't be done without it?
19:30:06 <Cale> electron_x: There are things which are very annoying to write without it.
19:30:10 <mauke> > take 6 (map (^2) [10 ..])
19:30:11 <lambdabot>  [100,121,144,169,196,225]
19:30:21 <mauke> [10 ..] wouldn't terminate without laziness
19:30:23 <Cale> electron_x: and yeah, it lets you work with infinite data structures
19:30:30 <SamB> electron_x: in a pure setting, yes, there are things that cannot be done without it
19:30:42 <electron_x> pretty cool
19:30:43 <Cale> It allows you to break down problems in new ways that you couldn't in a strict language.
19:30:49 <SamB> in an impure setting, probably not, but the code would be horrificly ugly
19:30:54 <ddarius> SamB: Only when you consider (asymptotic) performance.
19:30:54 <SamB> and a lot harder to reason about
19:30:57 <Cale> And that allows library functions to be more useful in some cases.
19:31:10 <SamB> ddarius: so?
19:31:24 <electron_x> thanks for the tute Cale
19:31:28 <Cale> electron_x: no problem
19:31:38 <Cale> electron_x: Let us know if you have any questions of course :)
19:31:44 <electron_x> :0 thanks
19:31:49 <SamB> ddarius: I generally like my computations to run in a timely manner, don't you
19:31:50 <SamB> ?
19:32:10 <Cale> electron_x: By the way, foldl' is in Data.List
19:32:20 <ddarius> SamB: That's not necessarily how "there are things that cannot be done without it" would be taken.
19:32:22 <jsnx> Saizan: thanks for your help, i've got this working now
19:32:23 <mauke> > let fib = 0 : 1 : zipWith (+) fib (tail fib)  in  fib
19:32:24 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
19:32:37 <jsnx> writing C in haskell is actually a lot of fun
19:33:02 <Saizan> surely better than C in C!
19:33:12 <jsnx> Saizan: indeed!
19:33:18 <SamB> there are definately things that can't be pretty without laziness, that'
19:33:19 <Cale> electron_x: So you can write your length function in terms of it as  myLength xs = foldl' (\acc x -> acc + 1) 0 xs
19:33:25 <SamB> s for sure...
19:33:45 <electron_x> didn't want to rely on any functions though
19:33:46 <ddarius> there definitely things that can't be pretty without side-effects, that's for sure...
19:33:54 <gwern> oh noes. is hpaste down?
19:33:58 <Cale> electron_x: Of course, you could also write it directly in terms of seq, but you'd be surprised how many places which need strictness are really foldl' cases.
19:34:11 <SamB> ddarius: probably true ;-)
19:34:16 <electron_x> :)
19:34:19 * electron_x goes of to process his new found knowledge
19:34:23 <wagle_home> @hpaste
19:34:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:34:30 <awesame> one thing I found useful for thinking about laziness is python's generators
19:34:45 <Cale> electron_x: The general rule of thumb about where strictness is desirable is when you're collapsing a lot of data down to a small summary which doesn't have many parts that can be separately computed.
19:34:57 <Cale> oh
19:34:58 <Cale> hehe
19:34:58 <gwern> http://pastebin.com/m415c3c27 <-- profiling compile error, HALP!
19:35:03 <wagle_home> hpaste seems down
19:35:09 <Cale> Oh well, his brain might have exploded anyway :)
19:36:03 <Saizan> so, that's your declared intention when you teach to a noobie?:D
19:36:41 <Cale> Saizan: Well, I try to make their brain explode in the gentlest possible manner.
19:36:55 <gwern> anyone know what directory might error while compiling a profiling lib?
19:36:58 <gwern> *why
19:37:36 <Saizan> it works when you compile it normally?
19:37:49 <gwern> Saizan: ayuh
19:37:50 <Saizan> ah, yes
19:37:58 <thoughtpolice> Cale: brain explosion in small doses is good, and you do it well. :)
19:38:17 <gwern> or, it did before
19:38:20 <gwern> hm.
19:38:46 <Saizan> error: HsDirectoryConfig.h: No such file or directory <-- this seems the root of it all
19:39:05 <gwern> yeah
19:39:08 <jsnx> Cale: i didn't mean to blow you off earlier
19:39:17 <Cale> jsnx: that's all right :)
19:40:04 <gwern> strangely... if you compile normally, that's not a compilation problem
19:40:07 <SamB> we should show random slogans on the homepage, like "Making your brain explode in the gentlest possible manner since 19xx"
19:40:22 <gwern> (dammit Ross!)
19:40:58 <gwern> where's the darcs repo for directory anyway?
19:41:27 <jsnx> SamB: or (from the math channel just now) "little polynomial needs to be punished!"
19:41:46 <adu> i love polynomials
19:42:00 <jsnx> and someone else loves to punish them...
19:42:09 * ddarius is more of a series guy.
19:42:38 <adu> ddarius: well, I suppose all polynomials can be expressed as a series with lots of zero coefficients...
19:42:45 * SamB wants a more logical pretty printer
19:42:51 <gwern> @where directory
19:42:51 <lambdabot> I know nothing about directory.
19:43:00 <ddarius> SamB: There is more than one available.
19:43:23 <ddarius> pretty printer that is, not necessarily logical pretty printer
19:43:46 <SamB> logical, as in, putting newlines higher up the parse tree...
19:43:53 <gwern> is directory one of the libraries only maintained in GHC?
19:45:45 <Saizan> gwern: well, it was in base, however it compiles with profiling fine here.
19:46:25 <gwern> Saizan: the hackage tarball?
19:46:34 <Saizan> gwern: after s/Configure/Simple/ in build-type of course,
19:46:38 <Saizan> yes
19:46:49 <gwern> oh. I guess I'll try that
19:47:03 <Saizan> cabal-install 0.4.6, Cabal 1.3.10
19:47:12 <Saizan> not sure if those matters :)
19:47:46 <gwern> no, that doesn't help
19:51:37 <adu> so how will I find out about my google soc application?
19:56:20 <adu> and the deadline for submitting has passed, so the channel topic should probably be changed
19:57:27 <gwern> @remember directory http://darcs.haskell.org/packages/directory/
19:57:27 <lambdabot> Okay.
19:58:47 <dobblego> ivan, are you at UQ on the north side of Brisbane?
19:59:24 <iebnn> haskell:lisp
19:59:38 <ivanm> dobblego: West side, yes ;-)
19:59:43 <ivanm> north side has QUT, not UQ
19:59:48 <ivanm> why do you ask?
19:59:54 <dobblego> ivan, I work at Milton
20:00:09 <ivanm> ahhh
20:04:01 <iebnn> isnt there a lisp implementation of haskell?
20:04:07 <dobblego> @where liskell
20:04:07 <lambdabot> http://clemens.endorphin.org/liskell
20:04:33 <ddarius> There something in CL somewhere.
20:05:04 <Cale> That's a lisp-like syntax for Haskell :)
20:05:33 <enticingjelly> :t liftM any
20:05:34 <lambdabot> forall a (m :: * -> *). (Monad m) => m (a -> Bool) -> m ([a] -> Bool)
20:05:56 <roconnor> @src any
20:05:56 <lambdabot> any p =  or . map p
20:06:18 <Cale> @src or
20:06:18 <lambdabot> or    =  foldr (||) False
20:06:35 <ddarius> Therefore, any p = foldr ((||) . p) False
20:06:43 <roconnor> @type \p -> (foldM (||) False) . mapM p
20:06:44 <lambdabot>     Couldn't match expected type `m Bool' against inferred type `Bool'
20:06:44 <lambdabot>       Expected type: Bool -> Bool -> m Bool
20:06:44 <lambdabot>       Inferred type: Bool -> Bool -> Bool
20:06:46 <dobblego> ivanm, do you happen to catch the train to uni? I'm wondering if I may have seen you about ;)
20:08:55 <roconnor> @type \p -> (foldM ((||) .p) False)
20:08:56 <lambdabot>     Couldn't match expected type `m a' against inferred type `Bool'
20:08:56 <lambdabot>     In the first argument of `foldM', namely `((||) . p)'
20:08:56 <lambdabot>     In the expression: (foldM ((||) . p) False)
20:09:20 <roconnor> @type \p -> (foldM ((||) .p) (return False))
20:09:20 <lambdabot>     Couldn't match expected type `m a' against inferred type `Bool'
20:09:21 <lambdabot>     In the first argument of `foldM', namely `((||) . p)'
20:09:21 <lambdabot>     In the expression: (foldM ((||) . p) (return False))
20:09:50 <ivanm> dobblego: nope, just bus
20:10:10 <ivanm> I live out near sunnybank
20:13:38 <Saizan>  @type \p -> (foldM (flip $ (||) .p) (return False))
20:13:43 <Saizan> @type \p -> (foldM (flip $ (||) .p) (return False))
20:13:44 <lambdabot>     Couldn't match expected type `m Bool' against inferred type `Bool'
20:13:44 <lambdabot>       Expected type: Bool -> a -> m Bool
20:13:44 <lambdabot>       Inferred type: Bool -> a -> Bool
20:13:48 * Syzygy- met dpiponi today
20:13:51 <Syzygy-> Good fun
20:14:12 <ddarius> the first argument to foldM has to have a monadic result.
20:15:27 <ivanm> dobblego: besides, even if I did catch the train, how would you know who I was? :p
20:16:29 <dobblego> ivanm, duh, by your name tag of course :)
20:17:55 <ivanm> heh
20:18:35 <SamB> which would say what?
20:18:42 <SamB> "Unknown"?
20:28:52 <enticingjelly> I need a function m a -> m ()
20:29:04 <enticingjelly> so that I can use guard and when with functions which have a return value
20:29:08 <mauke> :t (>> return ())
20:29:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
20:29:23 <enticingjelly> mauke, yes, I thought about that, too, but isn't there a nicer way?
20:29:27 <enticingjelly> that's a bit ugly
20:29:45 <mauke> whatever :: (Monad m) => m (); whatever = return ()
20:30:05 <mauke> ignore :: (Monad m) => m a -> m (); ignore = (>> whatever)
20:30:30 <enticingjelly> ok, so I need to do it myself... thanks
20:31:32 <ddarius> whatever is usually called done
20:32:57 <lament> :t replicateM 1
20:32:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
20:33:00 <lament> err
20:33:02 <lament> :t replicateM_ 1
20:33:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
20:33:08 <lament> voila
20:33:13 <lament> :P
20:33:37 <enticingjelly> heh 8)
20:33:39 <enticingjelly> nice one
20:34:36 <roconnor> @type liftM (const ())
20:34:37 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m ()
20:34:42 <atp> or fmap (const ())
20:35:07 <atp> :t fmap (const ())
20:35:08 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f ()
20:35:13 <atp> more general :)
20:35:50 <lament> something's fishy about that one
20:36:31 <atp> why
20:36:49 <roconnor> @type const (return ())
20:36:49 <lambdabot> forall (m :: * -> *) b. (Monad m) => b -> m ()
20:37:22 <lament> will it discard the previous monadic action?
20:37:32 <roconnor> nope
20:37:34 <atp> > fmap (const ()) (return "a")
20:37:35 <lambdabot>   add an instance declaration for (Show (f ()))
20:37:43 <roconnor> fmap does a substitution
20:38:01 <atp> > fmap (const ()) (Just "a")
20:38:02 <lambdabot>  Just ()
20:38:21 <atp> looks like it works
20:38:41 <roconnor> > const (return ()) (Just "a")
20:38:42 <lambdabot>   add an instance declaration for (Show (m ()))
20:38:48 <gwern> @hoogle trace
20:38:48 <lambdabot> Debug.Trace.trace :: String -> a -> a
20:38:48 <lambdabot> Debug.Trace :: module
20:38:48 <lambdabot> Debug.Trace.traceShow :: Show a => a -> b -> b
20:39:05 <lament> yeah, nice
20:40:31 <atp> fmap f m = m >>= return . f, isn't it?
20:40:35 <atp> for a monad m
20:40:42 <mauke> @src liftM
20:40:43 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
20:40:46 <atp> isn't that one of the functor/monad laws
20:42:09 <dobblego> yes
20:42:17 <dobblego> liftM = fmap
20:42:25 <dobblego> fmap f = return . f
20:42:30 <atp> we should make (.) = fmap
20:42:40 <dobblego> ?type (.)
20:42:41 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
20:42:57 <BMeph> atp: Done already.
20:42:57 <lambdabot> BMeph: You have 1 new message. '/msg lambdabot @messages' to read it.
20:43:06 <Saizan> ?type map
20:43:07 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
20:43:14 <atp> BMeph: done already?  when?
20:43:29 <atp> it looks like (.) is specific to the (r->) functor
20:44:35 <dobblego> Haskell' perhaps
20:44:41 <atp> i hope so
20:44:55 <BMeph> ?ty (++)
20:44:56 <lambdabot> forall a. [a] -> [a] -> [a]
20:44:57 <atp> i often use fmap infix because it behaves so much like function composition
20:45:09 <scook0> > (+1) . [1..3]
20:45:10 <lambdabot>  [2,3,4]
20:45:19 <atp> hm
20:45:34 <atp> :t (+1) .
20:45:35 <lambdabot> parse error (possibly incorrect indentation)
20:45:39 <atp> :t ((+1) .)
20:45:40 <lambdabot> forall b a. (Num b) => (a -> b) -> a -> b
20:45:55 <atp> :t (. [])
20:45:55 <scook0> the \bot redefinition is non-standard, though
20:45:56 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
20:45:56 <lambdabot>     In the second argument of `(.)', namely `[]'
20:46:00 <atp> ah
20:46:14 <TSC> :t ((+1) `fmap`)
20:46:15 <lambdabot> forall a (f :: * -> *). (Functor f, Num a) => f a -> f a
20:46:16 <atp> fmap is a pretty awesome function
20:46:43 <scook0> > fmap fmap fmap (+1) (*) 2 3
20:46:44 <lambdabot>  7
20:47:06 <atp> see in that case infix is much more readable
20:47:15 <atp> but typing `fmap` all the time is sort of boring
20:47:29 <scook0> atp: <$>
20:47:32 <Saizan> > (+1) . [2]
20:47:32 <lambdabot>  [3]
20:47:43 <SamB> atp: in Caleskell, (.) = fmap
20:47:43 <atp> yah but then i need Control.Applicative for no good reason
20:48:08 <atp> yeah, Cale is right on about a lot of stuff
20:48:17 <scook0> heh, half my code has import Control.Arrow; import Control.Applicative at the top for no good reason
20:48:17 <atp> like what dummy got rid of monad comprehensions?
20:48:28 <lament> scook0: just to look cooler?
20:48:44 <SamB> atp: I think it was a relative of the dummy who thought up the MR
20:48:53 <atp> ah yes, the mr
20:48:56 <scook0> because I like (&&&) and (<$>)
20:49:01 <atp> everyone's favorite restriction
20:49:28 <atp> the prelude should also not define any of its functions in terms of Int
20:49:29 <s710b> what is the MR?
20:49:35 <atp> monomorphism restrictino
20:49:37 <atp> restriction
20:49:38 <atp> even
20:49:45 <s710b> ah, thx
20:49:49 <atp> you can turn it off, most of us do :)
20:49:59 <atp> at least in ghc... dunno about hugs
20:50:01 <lament> so like half the discussion in #haskell is "Stupid monomorphism restriction!" and the other half is "I want more general map and monad comprehensions!"
20:50:11 <lament> ...something must be done :)
20:50:30 <atp> also, fold, foldr, foldl in the prelude should be replaced by Data.Foldable
20:50:41 <dobblego> I'm liking it so far :)
20:50:49 <atp> and anything that is inherently a fold should be in terms of it (which is, let's face it, a ton of stuff)
20:50:50 <lament> down with the Prelude!
20:50:53 <atp> YES!
20:50:56 <lament> viva la revolucion!!!
20:51:19 <lament> i don't think even haskell prime wants to go that far
20:51:43 <atp> making (++) and map and filter a-likes for every foldable data structure i make is really annoying
20:52:02 <lament> there's clearly many possibilities for library cleanup, but i have a strong feeling that they will only be addressed in Haskell's successor
20:52:25 <lament> (miranda is to haskell as haskell is to)
20:52:30 <atp> speaking of which, map?
20:52:41 <atp> how many maps are there, anyway?
20:52:51 <dobblego> ?instances Functor
20:52:52 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
20:52:53 <atp> map, fmap, >>= ?
20:53:10 <atp> well, i guess >>= is concatMap
20:53:14 <lemur> hey buddies
20:53:17 <dolio> You could go ahead and write your own prelude/etc replacement.
20:53:23 <dolio> It's just a matter of getting other people to use it.
20:53:23 <SamB> atp: flipped, yes
20:54:00 <dolio> map, fmap, liftM, liftA, (<$>)
20:54:17 <SamB> liftA?
20:54:27 <dolio> Applicative.
20:54:33 <SamB> ah
20:54:47 <dolio> Allegedly there to let people use it to define Functor instances.
20:55:06 <SamB> @hoogle (a -> b) -> f a -> f b
20:55:07 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
20:55:07 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
20:55:07 <lambdabot> Data.Function.($) :: (a -> b) -> a -> b
20:55:12 <SamB> hmm.
20:55:16 <dolio> But I'm not sure that's a compelling motivation.
20:55:18 <SamB> not quite what I Had in mind!
20:55:49 <dolio> There's also Data.Traversable.fmapDefault
20:56:16 <dolio> Which is also for defining Functor instances, only in terms of Traversable.
20:56:32 <lament> :t liftA
20:56:33 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
20:56:49 <BMeph> I liked (++) as a Monoid, it makes more sense to me than "mappend."
20:56:58 <lament> :t (++)
20:56:59 <lambdabot> forall a. [a] -> [a] -> [a]
20:57:17 <dolio> > EQ ++ GT
20:57:17 <lambdabot>  GT
20:57:21 <BMeph> I keep trying to pronounce the thing as "map-pend," and then catch myself.
20:57:24 <dolio> Huh.
20:57:31 <lament> ESCHEW ALL CONCRETENESS
20:57:32 <dolio> @type (++)
20:57:33 <lambdabot> forall a. [a] -> [a] -> [a]
20:57:43 <lament> :t mappend
20:57:44 <lambdabot> forall a. (Monoid a) => a -> a -> a
20:57:46 <dolio>  @type is wrong again.
20:58:25 <Cale> hmm
20:58:31 <Cale> Let me look at what L.hs has in it
20:59:09 <Cale> hmm, it looks okay...
20:59:16 <Cale> But it has a definition of prime
20:59:19 <Cale> @undef
20:59:20 <lambdabot> Undefined.
20:59:26 <Cale> @type (++)
20:59:27 <lambdabot> forall m. (Monoid m) => m -> m -> m
20:59:37 <Cale> @let prime=let ps=2:3:2:5:scanl(+)5 ps in zipWith(\x y->(y,x`mod`y==0))ps [2..]
20:59:37 <lambdabot> Defined.
20:59:39 <captluo> Is there a brainfuck syntax available for haskell?
20:59:41 <Cale> @type (++)
20:59:42 <lambdabot> forall m. (Monoid m) => m -> m -> m
20:59:45 <Cale> hmm
20:59:49 <lament> ?instances Monoid
20:59:50 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
21:00:01 <Cale> Okay, I have no idea what's going on there.
21:00:16 <captluo> or a Brainfuck -> Haskell translator
21:00:20 <Cale> When that happens @undefine seems to help, but I'm not sure why.
21:00:25 <lament> how come there're so few monoids
21:01:13 <Cale> lament: What other instances would you like?
21:01:24 <BMeph> Yes - why is Int not listed? ;p
21:01:37 <Cale> Int is covered by Product and Sum
21:01:48 <lament> oh, good point
21:01:49 <BMeph> Eh, okay.
21:02:34 <Cale> > foldl (++) zero . map Product [1..20]
21:02:35 <lambdabot>  Couldn't match expected type `[a]'
21:02:38 <Cale> > foldl (++) zero . map Product . [1..20]
21:02:39 <lambdabot>   add an instance declaration for (Enum [a], Num [a])
21:02:42 <Cale> > foldl (++) zero . map Product $ [1..20]
21:02:43 <lambdabot>  Product {getProduct = 2432902008176640000}
21:02:59 <Cale> ah, right, 'getProduct' :)
21:03:03 <BMeph> Cale: is that defn. of prime any more efficient than the nubBy one? :)
21:03:05 <Cale> > getProduct . foldl (++) zero . map Product $ [1..20]
21:03:06 <lambdabot>  2432902008176640000
21:03:06 <lament> this is not very clean
21:03:32 <mauke> > getProduct . mconcat . map Product $ [1..20]
21:03:33 <lambdabot>  2432902008176640000
21:03:48 <Cale> BMeph: probably by a bit...
21:03:51 <mauke> > getProduct . mconcat $ [1..20]
21:03:51 <lambdabot>        add an instance declaration for (Enum (Product a), Num (Product a))
21:04:00 <mauke> someone needs to add that :-)
21:04:14 <Cale> hmm
21:04:23 <BMeph> Word.
21:04:43 <BMeph> That is, I agree, not that I want Word specifically... ;)
21:05:08 <Cale> Er, yes, it's actually much much faster.
21:05:56 <dolio> Yeah, the monoid newtypes lack a lot of the instances of the things they wrap.
21:06:10 <Cale> > take 1000 [x | (x,y) <- prime, y]
21:06:11 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
21:06:15 <mauke> ZipList also needs instances
21:06:16 <Cale> > length (take 1000 [x | (x,y) <- prime, y])
21:06:17 <lambdabot>  1000
21:06:38 <Cale> > length (take 1000 (nubBy (\x y -> y `mod` x == 0) [2..]))
21:06:39 <lambdabot>  1000
21:06:45 <Cale> > length (take 10000 (nubBy (\x y -> y `mod` x == 0) [2..]))
21:06:49 <dolio> It'd be easy if generalized newtype deriving were allowed, but that might be a no-no in base.
21:06:52 <lambdabot> Terminated
21:06:55 <BMeph> Cale: Excellent, I'll give you credit for it in my "BagO' Tricks" module, UNODIR... :)
21:06:56 <Cale> > length (take 10000 [x | (x,y) <- prime, y])
21:06:59 <lambdabot> Terminated
21:07:04 <Cale> BMeph: it's not mine
21:07:13 <Cale> BMeph: I copied it back from L.hs
21:07:21 <Cale> BMeph: Since I had to clear L.hs
21:07:44 <Cale> (For whatever reason, lambdabot starts reporting the wrong types sometimes)
21:08:28 <Cale> anyway, it's hard to see it with lambdabot, but yeah, that's rather fast :)
21:08:59 <Cale> Looks like some kind of wheel :)
21:09:04 <BMeph> So, would that make it dons', or is he just another link in the "Chain of Custody?" ;)
21:09:29 <Cale> L.hs is where all the definitions go that people make with @let
21:09:37 <Cale> You'd have to look through the logs.
21:09:55 <BMeph> Hmm... Ambiguous! =8*O
21:11:02 <enticingjelly>     Can't make a derived instance of `Monad TestRuntime'
21:11:02 <enticingjelly>       (even with cunning newtype deriving:
21:11:02 <enticingjelly>        the eta-reduction property does not hold)
21:11:02 <enticingjelly>     When deriving instances for `TestRuntime'
21:11:04 <enticingjelly> noooooo
21:12:11 <Cale> enticingjelly: Doing something strange and recursive?
21:12:19 <enticingjelly> Cale, not really...
21:12:38 <Cale> What's the definition of TestRuntime?
21:12:40 <enticingjelly> Cale, just added a Map to the state
21:12:45 <enticingjelly> newtype TestRuntime a = TestRuntime {
21:12:45 <enticingjelly>       runTR :: StateT (Int, TestCache a) IO a
21:12:45 <enticingjelly>     }
21:12:52 <enticingjelly> without (TestCache a) it works
21:13:09 <lament> why is newtype deriving at all difficult?
21:13:10 <Cale> ah, but the Map has to have the result type
21:13:23 <Cale> Which means that's not obviously a monad anymore
21:13:36 <enticingjelly> hm?
21:13:52 <Cale> That 'a' there is the same as the 'a' at the end
21:13:56 <lament> yeah.. that's a pretty strange type you have
21:13:59 <enticingjelly> oh.
21:14:00 <enticingjelly> ooh.
21:14:10 <enticingjelly> thanks a lot
21:14:11 <dolio> In 'm a -> (a -> m b) -> m b' the types in TestCache have to change.
21:14:15 <Cale> No problem
21:14:18 <lemur> ok I came up with an idea for a file system
21:14:31 <enticingjelly> that's what I get for always using "a" as type variable name %)
21:14:54 <Cale> Now you get to use b!
21:14:54 <Twey> @src const
21:14:55 <lambdabot> const x _ = x
21:15:04 <enticingjelly> Cale, I used v for the value ;)
21:15:05 <Twey> Haha, Cale
21:15:20 <lemur> how about an FS that takes all the files and writes them all over the disk multiple times so to minimize seek time, when seeking to a file, only seek the closest copy to where the head is at the time
21:15:42 <sjanssen> lemur: why not just use a smaller partition?
21:15:49 <lament> just get a smaller hard drive
21:15:56 <lemur> never thought of it that way
21:16:30 <lament> and i'm sure seeking to a file is not the bottleneck in disk IO
21:16:31 <Cale> I suppose you could do that though, but it'll increase your write time...
21:16:35 <lemur> ok how about a file system then that partitions itself into little sections and tries to group seemingly related files into sections with each other
21:17:14 <Cale> lemur: I think Microsoft's defragmenter tries to do that.
21:17:28 <lemur> oh, I didn't realize what channel I'm in
21:17:33 * Twey laughs.
21:17:37 <lemur> sorry Haskell guys
21:17:44 <lemur> (you're a lot more polite than the other channel)
21:17:45 <Cale> hehe, yeah, this is sort of offtopic ;)
21:18:06 <lament> how about a filesystem where all data is kept as THUNKS
21:18:56 <sjanssen> lament: stack overflow, please pass +RTS -k <size> as an argument in your bootloader
21:18:58 <Cale> lament: I will store my pr0n as  Double -> Double -> Colour  functions!
21:19:05 <enticingjelly>     Inferred type is less polymorphic than expected
21:19:07 <enticingjelly> oh come on.
21:19:25 <Cale> enticingjelly: That usually means you gave an incorrect type signature.
21:19:51 <Cale> enticingjelly: Or your code ended up making some assumption about the values you're working with that you didn't want to.
21:19:52 <enticingjelly> let's see...
21:20:00 <lament> (calculating the remaining disk space is not guaranteed to terminate)
21:20:12 <sjanssen> lament: oh, and don't forget to deepSeq the disk regularly
21:20:16 <sjanssen> lament: haha
21:20:24 <mauke> sync;sync;sync
21:20:53 <lemur> has anyone tried to write an OS in haskell
21:21:05 <mauke> @ho haskell house
21:21:05 <lambdabot> Maybe you meant: hoogle hoogle+ . ? @ bf echo ft ghc id pl rc show thx v wn yow
21:21:08 <mauke> @go haskell house
21:21:10 <lambdabot> http://programatica.cs.pdx.edu/House/
21:21:10 <lambdabot> Title: House
21:21:13 <enticingjelly> Cale, I added type signatures to some functions and it made the error go away...
21:21:25 <lament> in order to be sane, a haskell OS needs to be built on a very non-von neumann architecture :)
21:21:36 <Cale> enticingjelly: hmm, I don't know :)
21:21:47 <enticingjelly> Cale, oh. no, it didn't, they are wrong %)
21:21:48 <Cale> enticingjelly: maybe some MR strangeness
21:21:52 <Cale> ah
21:22:02 * sjanssen wants a real zipper filesystem ala Oleg
21:22:17 <enticingjelly> Cale, oh. now I corrected them and it seems to work.
21:22:25 <Cale> lament: Reduceron!
21:22:48 <enticingjelly> Cale, yes, it works now... adding type signatures helped
21:22:56 <Cale> enticingjelly: okay... :)
21:23:24 <lament> Cale: oh, wow. i didn't know that existed.
21:24:08 <Cale> There was a talk about it a while back, I could see if I could find it.
21:24:15 <lament> hardware garbage collection! nice
21:24:25 <Cale> http://video.google.com/videoplay?docid=-1518197558546337776
21:24:26 <lambdabot> Title: reduceron.mov
21:25:46 <lament> so where can you buy one?
21:26:02 <dolio> The future!
21:26:34 <lament> a reduceron in every pot!
21:26:35 <Cale> Where can you buy an FPGA?
21:27:13 <lament> "Running at only 91.5MHz on an FPGA, the Reduceron is faster than mature bytecode implementations of Haskell running on a 2.8Ghz PC"
21:27:17 <lament> sounds like a deal
21:27:21 <Cale> :)
21:28:33 <lament> so you can buy fpga and make one at home?
21:28:42 <BMeph> Cale: altova.com ;)
21:29:34 <Cale> lament: Yeah, the idea of an FPGA is that it's programmable hardware.
21:29:49 <BMeph> Er, NM, wrong work link. ;p
21:30:20 <BMeph> I meant www.altera.com
21:38:47 <Cale> lament: btw, I'm not sure that it's yet faster than GHC though
21:38:58 <lament> nope, i've read the paper
21:39:02 <Cale> lament: But obviously it's a good idea :)
21:39:04 <lament> they're faster than bytecode
21:39:09 <lament> but slower than compiled code
21:39:34 <lament> but that's with a naive implementation
21:39:59 <lament> of course, lisp machines are pretty cool too, and look how many are around :)
21:40:00 <Hellhole> hmm
21:40:19 <Cale> lament: But FPGAs are something which people can actually buy :)
21:41:26 <Cale> (and perhaps they will eventually be good enough to give a real advantage over compiling to existing architectures, who knows)
21:41:42 <gxng> hey cale
21:41:48 <Cale> gxng: hello
21:41:56 <gxng> hows it going
21:42:11 <Cale> I'm well
21:42:12 <gxng> ive still got that haskell ++ to firgure out lol
21:42:31 <lament> > (haskell ++)
21:42:31 <lambdabot>   Not in scope: `haskell'
21:42:39 <Cale> List concatenation, or lambdabot's name for the monoid operation?
21:43:09 <gxng> opps
21:43:15 <gxng> haskell++
21:43:25 <gxng> prob no1 knows wah da hell im talkn bout..
21:43:37 <mauke> it helps if you speak in whole words
21:43:44 <Cale> hehe
21:43:45 <gxng> lol just my prof's extension of haskell
21:44:19 <Twey> Uh-oh
21:44:29 <Cale> Who's your prof?
21:44:31 <gxng> o weell nm
21:44:43 <gxng> lol i came on here a few days ago..
21:44:45 <mauke> bjarne stroustrup
21:44:48 <gxng> nah
21:44:52 <gxng> not dat famous
21:45:05 <lament> "Haskell++" sure sounds promising.
21:45:15 <Cale> Might recognise the name from the mailing list though :)
21:45:16 <gxng> actually dont even thinks hes famous at all
21:45:17 <lament> oh, http://www.cs.chalmers.se/~rjmh/Software/h++.html
21:45:18 <lambdabot> Title: Haskell++
21:45:30 <gxng> lol wah mailing list?
21:45:33 <Cale> The Haskell community is mostly pretty tight knit.
21:45:38 <lament> John Hughes is pretty famous
21:45:49 <Cale> The Haskell and Haskell-cafe mailing lists.
21:45:54 <gxng> ok
21:46:03 <Cale> http://www.haskell.org/haskellwiki/Mailing_Lists
21:46:04 <lambdabot> Title: Mailing lists - HaskellWiki
21:46:08 <gxng> prof. probst
21:46:11 <gxng> ringa  bell?
21:46:30 <gxng> btw he dont even own a computer
21:46:35 <gxng> lol
21:46:59 <lament> it's hard to make an extension to haskell without a computer
21:47:02 <gxng> i think he's a microbiologist by training
21:47:16 <Cale> Nope, I haven't seen any of him on the mailing list
21:47:19 <gxng> well hes one of the ppls who beleive in human brain compiler
21:48:05 <enticingjelly> Cale, I don't get it :( http://rafb.net/p/Dkn5lg20.html
21:48:06 <lambdabot> Title: Nopaste - No description
21:48:09 <gxng> as in im assuming he compiles in his head and if all semantics and syntax and his extensions are rite..then that means it would compile for real
21:48:29 <enticingjelly> Cale, why does it think there's two different types?
21:48:35 <enticingjelly> newtype TestRuntime a v = TestRuntime (StateT (Int, FValue a) IO v) deriving (Monad, MonadIO, MonadState (Int, FValue a))
21:48:51 <gxng> hmm is there always dis much ppls in here all times of day?
21:48:58 <enticingjelly>     callTrace :: Show a => FFunVal a -> [FValue a] -> m (Maybe (FValue a))
21:49:03 <mauke> @users
21:49:04 <lambdabot> Maximum users seen in #haskell: 477, currently: 410 (86.0%), active: 12 (2.9%)
21:49:11 <Zao> gxng: Yes. Haskellers have lazy sleep.
21:49:16 <Cale> enticingjelly: What type does it infer when you leave off the type sig?
21:49:25 <enticingjelly> Cale, which type sig?
21:49:30 <Cale> enticingjelly: (for callTrace)
21:49:32 <gxng> lol haskell jokes
21:49:47 <enticingjelly> Cale, it's part of a class declaration :/
21:49:53 <Cale> oh
21:49:57 <gxng> my prof often uses social life, religion and other mundane stuff for analogies of haskell..kinda weird
21:50:01 <Cale> hmm, can I see more of your file?
21:50:15 <lament> religion is hardly mundane
21:50:17 <enticingjelly> Cale, of course, I'll paste something for you.
21:50:21 <gxng> to me it is
21:50:21 <gxng> lol
21:50:25 <enticingjelly> oh, wait a minute, I want to try something first.
21:50:29 <Cale> gxng: is this your prof? http://ifgi.uni-muenster.de/~probsfl/
21:50:31 <lambdabot> Title: Florian Probst - Institute for Geoinformatics - Muenster
21:50:52 <gxng> damn i tot lamdabot was a real bot
21:51:03 <gxng> no im in montreal, canada
21:51:08 <Cale> ah
21:51:26 <gxng> not that it was my choice...
21:51:50 <Cale> Concordia?
21:52:00 <enticingjelly> Cale, ah, got it
21:52:05 <gxng> lol ya...how come u didnt say mcgill..
21:52:06 <enticingjelly> Cale, forgot to parameterize the class
21:52:16 <gxng> hey cale u from where?
21:52:17 <enticingjelly> Cale, so then the type of its functions wasn't bound.
21:52:25 <enticingjelly> Cale, if I understand correctly %)
21:52:46 <gxng> damn i thought irc was dying out guess not:P
21:52:49 <Cale> gxng: Google gave more convincing hits for Probst Concordia than Probst McGill
21:52:59 <gxng> lol
21:53:03 <gxng> damn google
21:53:06 <Cale> I'm from Ontario
21:53:11 <Cale> enticingjelly: ah okay
21:53:17 <gxng> over rated used abused and blah
21:53:35 <gxng> damn next door...always dreamed to move west...god damned qc n its crapo
21:53:55 <gxng> cool fellow canadian
21:53:56 <gxng> lol
21:54:15 <gxng> then gain u use rogers...
21:54:50 <enticingjelly> wow
21:55:01 <enticingjelly> now I have to derive Ord on one thousand types in one thousand source files
21:55:02 <Cale> phear my ridiculously long and complicated hostname
21:55:15 <lament>  /me notes that we already had this discussion about probst and haskell++ ( http://tuukka.iki.fi/tmp/haskell-2007-11-26.html )
21:55:15 <lambdabot> Title: haskell-2007-11-26
21:55:22 <Cale> enticingjelly: You have a lot of source code there. :)
21:55:23 <enticingjelly> (uh. no. that would mean I had one source file per type %) )
21:55:33 <enticingjelly> Cale, I'm exaggerating %)
21:55:35 <lament> evidently not much has changed since then
21:55:39 <gxng> ya..see hsitory repeats itself
21:55:42 <enticingjelly> Cale, it's actually just 1500 lines
21:55:47 <enticingjelly> Cale, but boy does it feel like much.
21:55:53 <gxng> 2007?
21:55:58 <gxng> lol
21:56:09 <Cale> enticingjelly: Yeah, 1500 lines is a lot of Haskell code.
21:56:15 <gxng> ,fi wahs dat? fiji island?
21:56:22 <gxng> or finland
21:56:25 <enticingjelly> Cale, yeah, 1500 lines of java would be nothing...
21:56:39 <gxng> nm
21:56:46 <enticingjelly> Cale, another thing I like: if it compiles, it's likely to work
21:57:06 <gxng> funny how u got tons of ppls in here but few ppls talkn here
21:57:32 <lament> enticingjelly: that's just a consequence of the rule that says "every function can be changed to a different function with the same type signature"
21:57:32 <Cale> gxng: Most channels are like that.
21:57:35 <jeffz> gxng: I'm tempted to talk about your apparent lack of literacy skills, but was trying to decide against it.
21:57:41 <lament> a basic consequence of the curry-howard isomorphism
21:57:44 <gxng> lol
21:57:45 <Cale> gxng: People leave their computers on all the time
21:58:02 <gwern> whew. this bytestring problem is a nightmare
21:58:02 <gxng> real shorthand typn
21:58:20 <gwern> @seen dons
21:58:20 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc and #haskell. I last heard dons speak 6h 59m 24s ago.
21:58:23 <enticingjelly> lament, what exactly do you mean?
21:58:31 <gxng> no wonder the planet is going to hell with all that energy use
21:58:59 <gwern> @tell dons we've added a comment to http://bugs.darcs.net/issue697 about bytestring; the problem seems to be an imperfect copy of some bytestring function
21:58:59 <lambdabot> Consider it noted.
21:59:06 <gxng> lol i havent been on irc in wah over 5 yrs or more:P
21:59:20 <lament> gxng: since November of last year, apparently.
21:59:29 <gxng> I like to say my writing has improved:)
21:59:45 <gxng> u?
22:00:00 <dobblego> urs iz gr8t
22:00:19 <dobblego> gr8 even (I'm still learning)
22:00:53 <gxng> imagine using ur own shorthand writng to program in haskell or any langauge..no consistent standards so other ppls wont be able to read your coidng:P chaos
22:01:03 <Cale> lnk cr b82rez 2ge4
22:01:42 <gxng> never never much cared for sms lol
22:01:50 <lament> > intersperse 'o' $ repeat 'l'
22:01:51 <lambdabot>  "lololololololololololololololololololololololololololololololololololololol...
22:01:59 <gxng> spammer
22:02:06 <mauke> ll ws gedn hir b
22:02:14 <Cale> > cycle "desu"
22:02:15 <lambdabot>  "desudesudesudesudesudesudesudesudesudesudesudesudesudesudesudesudesudesudes...
22:02:28 <Twey> Hahahaha
22:02:51 <gxng> wow n dis is wah humans spend time on eh? lol
22:03:14 <mauke> "lol" is not a statement terminator
22:03:23 <dolio> Normally we come up with different ways to generate Fibonacci numbers.
22:03:24 <gxng> lol.
22:03:27 <lament> it is. "lol" is like "kana" in japanese
22:03:41 <Syzygy-> > cycle $ replicate 8 "Badger " ++ replicate 2 "Mushroom "
22:03:42 <lambdabot>  ["Badger ","Badger ","Badger ","Badger ","Badger ","Badger ","Badger ","Badg...
22:03:56 <Syzygy-> > unwords $ cycle $ replicate 8 "Badger " ++ replicate 2 "Mushroom "
22:03:56 <lambdabot>  "Badger  Badger  Badger  Badger  Badger  Badger  Badger  Badger  Mushroom  M...
22:03:57 <Twey> lament: More 'yo ne' nowadays.
22:04:06 <Twey> Heck, what am I saying
22:04:10 <Twey> 'lol' stands in for anything
22:04:24 <mauke> marklar
22:04:37 <Cale> lol lol lolled lol's lol, lol.
22:04:41 <gxng> lol arent we supposed b talkn bout haskell in here?
22:04:44 <gxng> heh
22:04:52 <lament> gxng: well, are you?
22:05:00 <Twey> Heh
22:05:05 <gxng> if i keep askn about haskell++
22:05:09 <gxng> no1s got ne idea
22:05:10 <gxng> lol
22:05:20 <lament> gxng: you should tell your prof that the name Haskell++ is already taken
22:05:24 <mauke> ｌｏｌｏｌｏｌｏｌｏｌｏｌｏｌｏｌｏｌｏｌｏｌｏｌｏｌｏｌｏｌｏｌｏｌｏｌｏｌｏ
22:05:26 <gxng> really?
22:05:28 <gxng> hmm
22:05:30 <gxng> nah
22:05:40 <gxng> dont want to be on his bad side
22:05:40 <gxng> lol
22:06:27 <gxng> i was wondering is it only guys in here?
22:06:40 <Cale> nope, there are some women too
22:06:50 <lament> 234, to be exact
22:06:51 <mauke> hay asl?!?!?!
22:06:52 <gxng> in my class i had 3 gals out of wah 40+ ppls
22:06:53 <gxng> lol
22:06:56 <enticingjelly> :t evalStateT
22:06:57 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m a
22:07:14 <gxng> still rare for gals to be in cs
22:07:32 <gxng> how can u tell whos female or male?
22:07:34 <gxng> some bot?
22:07:36 <gxng> lol
22:07:45 <gxng> maybe we can program a haskell prog...
22:07:54 <Cale> gxng: By actually knowing the people, mostly :)
22:07:55 <dolio> @vixen a/s/l
22:07:55 <lambdabot> 19/f/California
22:07:57 <Syzygy-> And where, oh where, is Philippa when we nened her?
22:08:06 <Syzygy-> *need
22:08:07 <gxng> o...always down to the ol fashioned ways of socail eng.
22:08:08 <gxng> lol
22:08:12 <gxng> social
22:08:17 <lament> > fix ("lo" ++)
22:08:17 <lambdabot>  "lololololololololololololololololololololololololololololololololololololol...
22:08:49 <gxng> cali...nice place
22:09:07 <lament> ("but how does it end?")
22:09:11 <gxng> cale: u mean to say that thers over 200 females who prog in haskell?
22:09:26 <Cale> gxng: I'm pretty sure there are, but I didn't say that.
22:09:32 <gxng> lol
22:09:50 <gxng> probably in the entire world im rite
22:09:55 <gxng> still a pretty sml %
22:09:59 <mauke> gxng: seriously, you need to stop using "lol". and work on your spelling.
22:10:35 <gxng> no rebels here?
22:10:47 <gxng> no democracy eitehr
22:10:52 <gxng> heh
22:11:05 <QtPlatypus> Spelling like that is only cute if your a kitteh.
22:11:13 <jeffz> gxng: why do you think it is a good idea to type in what you call shorthand?
22:11:14 <ddarius> Just people who like to speak proper English (in an English speaking forum)
22:11:19 <gxng> kittns dont type
22:11:19 <Syzygy-> Plenty of both, but we prefer to be able to comprehend each other.
22:11:36 <Spark> > let lol = 'l'::'o'::(tail lol) in lol
22:11:36 <lambdabot>  Parse error at "'o'::..." (column 16)
22:11:50 <Spark> one day... i'll learn the syntax
22:11:52 <Spark> one day
22:11:52 <ddarius> Spark: This isn't SML.
22:11:54 <Syzygy-> Spark: : not ::
22:11:59 <Spark> that's the one
22:12:05 <Twey> Hehe
22:12:11 <Syzygy-> let lol = 'l':'o':lol in lol
22:12:12 <gxng> nice to know that english rules
22:12:15 <lament> > intercalate " LOLZ " $ words "Please use valid, grammatical English"
22:12:16 <lambdabot>  "Please LOLZ use LOLZ valid, LOLZ grammatical LOLZ English"
22:12:17 <Syzygy-> > let lol = 'l':'o':lol in lol
22:12:18 <lambdabot>  "lololololololololololololololololololololololololololololololololololololol...
22:12:33 <gxng> now how can he use lol and i cant?
22:12:38 <gxng> democracy my butt
22:12:51 <mauke> what gave you the impression that IRC was a democracy?
22:12:55 <QtPlatypus> http://arcanux.org/lambdacats.html
22:13:01 <lambdabot> Title: Lambdacats
22:13:01 <lament> i earned the right to say LOL once in a while by being really grumpy and bitter the rest of the time
22:13:03 <Spark> lol = "lol" ++ lol is the same as what lament did though
22:13:08 <gxng> ur right...i assume to much
22:13:12 <Syzygy-> gxng: Notice how all the rest I write is decently typed.
22:13:26 <mauke> dependently typed!
22:13:30 <Syzygy-> Spark: No, it isn't.
22:13:32 <lament> decent typing!
22:13:32 <gxng> yes that would mean your r civilized
22:13:38 <Syzygy-> > let lol = "lol" ++ lol in lol
22:13:38 <lambdabot>  "lollollollollollollollollollollollollollollollollollollollollollollollollol...
22:13:45 <gxng> and more spamming
22:13:45 <Spark> oops
22:13:46 <Syzygy-> Notice the dupulications of 'l' in that
22:13:47 <enticingjelly> :t runStateT
22:13:48 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
22:13:50 <lament> GHC 6.9, now with indecent typing extensions
22:14:00 <Spark> that was just a typo
22:14:01 <gxng> heh
22:14:05 <Twey> > let lol = "lo" ++ lol in lol
22:14:05 <lambdabot>  "lololololololololololololololololololololololololololololololololololololol...
22:14:06 <Spark> or more of a thinko
22:14:19 <Spark> or just an early-morning-o
22:14:21 <Twey> Heh
22:14:25 <Twey> We all get 'em
22:14:46 <lament> Spark: sure, that's exactly what fix does
22:14:46 <Syzygy-> Gotta love the lambdakittehs
22:15:15 <enticingjelly> :t evalStateT
22:15:16 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m a
22:15:18 <enticingjelly> :t runStateT
22:15:19 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
22:16:29 <lament> > iterate ("lo" ++) ""
22:16:30 <lambdabot>  ["","lo","lolo","lololo","lolololo","lololololo","lolololololo","lololololol...
22:16:43 <lament> s/""/"l"/
22:16:50 <Twey> Haha
22:16:56 <Twey> Nice.
22:17:24 <Spark> > let lol = "lo" ++ lol ++ "ol" in lol
22:17:25 <lambdabot>  "lololololololololololololololololololololololololololololololololololololol...
22:17:52 <Spark> > let lol = lol ++ "ol" in reverse lol
22:17:53 <lambdabot>  Exception: <<loop>>
22:17:53 <Syzygy-> Spark: Also not g ood. It'd end with "....lololool"
22:18:09 <Spark> Syzygy-: in the middle you mean
22:18:12 <Twey> > cycle "lo" ++ "l"
22:18:13 <lambdabot>  "lololololololololololololololololololololololololololololololololololololol...
22:18:17 <lament> Syzygy-: it'd... end?
22:18:26 <Syzygy-> Spark: No. At the end. On the other side of \infinity
22:18:37 <Twey> Which is therefore a highly pressing problem.
22:18:42 <Syzygy-> :)
22:18:46 <Twey> :-)
22:18:57 <lament> to summarize, haskell is the language of choice for pointless retarded one-liners
22:18:58 <gxng> so much spam
22:19:02 <lament> although i'm sure perl would be on par
22:19:09 <Spark> i was just thinking that
22:19:14 <Twey> Y'know, we'll finish calculating those infinities any time now.
22:19:24 <Spark> the endless constructs in perl are a bit like the various building blocks in haskell
22:19:32 <Spark> 5 million ways of doing something trivial
22:19:44 <Twey> lament: Yes, but our pointless retarded one-liners are much more elegant than Perl's pointless retarded one-liners.
22:19:50 <sieni> > take 5 $ cycle "lo"
22:19:51 <lambdabot>  "lolol"
22:20:00 <mauke> Twey: that depends on the one-liner
22:20:02 <chylli> hi, I want to try a simple example of HAppS, but I dont find where is HAppS.Protocols.SimpleHTTP2
22:25:26 <enticingjelly> is there some printf style formatting?
22:26:29 <alc> Text.Printf
22:26:32 <mauke> @index printf
22:26:32 <lambdabot> Text.Printf
22:26:39 <enticingjelly> thanks a lot.
22:27:42 <mauke> > printf "%c" $ length [0 .. 64]
22:27:43 <lambdabot>  Add a type signature
22:27:46 <mauke> > printf "%c" $ length [0 .. 64] :: String
22:27:47 <lambdabot>  "A"
22:28:49 <enticingjelly> yep, works
22:35:30 <Zootal> Can some kind soul tell me what this means:
22:35:31 <Zootal> `Expression' is not applied to enough type arguments
22:35:43 <Zootal> I can't find it in the docs anywhere, and I have not clue what it is trying to tell me
22:35:46 <Zootal> It occurrs here:
22:35:58 <Zootal> type Address = (Int, Int)
22:35:58 <Zootal> type Range r = ( r, r )
22:35:58 <Zootal> type Expression e = e
22:35:58 <Zootal> type Cell = ( Address, Expression )
22:35:58 <Zootal> type SpreadSheet = ( [Cell] )
22:35:59 <Zao> Zootal: If it's long, hpaste.
22:36:03 <mauke> > Nothing :: Maybe
22:36:04 <lambdabot>      `Maybe' is not applied to enough type arguments
22:36:04 <lambdabot>     Expected kind `?', b...
22:36:17 <mauke> Zootal: Expression is not a type
22:36:48 <Zootal> hmm..how do I define it such that I can define the type later?
22:37:08 <mauke> just define the type later
22:37:14 <mauke> or what do you mean?
22:37:33 <Zootal> Well...Expression, in this context, is the expression we find in a cell in a spreadsheet
22:37:45 <Zootal> it can be an integer, or an addresses of another cell
22:38:10 <Zootal> (this is a school assignment, btw)
22:38:24 <Zootal> and I need to define a data type definition for Expression
22:38:25 <mauke> data Expression = Constant Int | Address Cell
22:38:43 <mauke> hmm, that's slightly misleading
22:38:48 <Zootal> lol
22:39:00 <mauke> data Expression = Constant Int | Indirect Address  {- or something like that -}
22:39:16 <Zootal> Can I just do this:
22:39:30 <Zootal> data Expression = Int | Address
22:39:30 <Zootal> ?
22:39:41 <mauke> no, you need a constructor for each branch
22:40:06 <koninkje> Zootal: depending on what you're after, you may want to kust define a class which "Expression" belongs to (for any "e"), then define your functions to use that class
22:40:12 <mauke> otherwise values can have ambiguous types
22:40:39 <Zootal> that could work - I'm not sure that is the expected answer.
22:40:48 <koninkje> e.g. "class Monad (Either a) where..." when Either generally requires two types
22:41:55 <Zootal> We haven't covered classes in class (no pun intended)
22:42:19 <Zootal> I'm not sure that is the expected way to do it - we have been given very little exposure to Haskell, before we got thrown to the Lions
22:42:35 <koninkje> Another way to overengineer the solution is to use coproduct types ;)
22:42:46 <QtPlatypus> I wish I could have a lazy file system.
22:42:46 <mauke> aIIRRR
22:43:19 <mauke> when I see "coproduct" I have to think of "copro"
22:43:27 <koninkje> -> http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf
22:43:36 <Zootal> Why would type Range r = ( r, r ) be valid, but type Expression e = e not?
22:43:49 <Zootal> or is Range not valid either?
22:44:07 <mauke> they're both valid
22:44:19 <mauke> but neither Range nor Expression are types
22:44:19 <koninkje> bear in mind that "type" only creates a synonym for another type that's already around; "data" is what you use to make something new
22:44:26 <mauke> Range Int or Expression String are
22:45:23 <koninkje> defining "type Range r = (r,r)" means that enywhere you see "Range r" you can just replace it with "(r,r)"
22:46:05 <Zootal> yah - because a range is a pair of either (Int,Int), or (Expression, Expression)
22:47:09 <koninkje> The point is, you're not defining anythiung new in the code. It's just a synonym that's helpful for reading the code. When it's compiled it just uses the tuple
22:48:15 <koninkje> Whereas "data Range r = Range (r,r)" or "data Range r = Range r r" etc, is actually defining a new datastructure which contains the tuple or pair of elements
22:50:20 <koninkje> for what you're doing "type" is probably just fine, but the distinction is good to bear in mind since defining something like Expression = Val Int | Addr Blah requires you to use "data"
22:53:00 <Zootal> I think for simplicity purposes, I'll leave it as:
22:53:06 <Zootal> type Expression = Int
22:53:13 <Zootal> as this compiles, and will probably do what I need it to
22:54:09 <enticingjelly> I use newtype if I want to make the type an instance of something later
22:54:45 <enticingjelly> with keeping the possibility of making another type which looks the same but behaves differently in instances
23:21:39 <andy753421> Hello, I'm looking for a brief overview of haskell features. I've found http://cs.anu.edu.au/student/comp1100/haskell/tourofsyntax.html and http://haskell.org/haskellwiki/A_brief_introduction_to_Haskell
23:21:40 <lambdabot> Title: Tour of the Haskell Syntax
23:22:07 <nolrai_> > do {Just 1 <- return (Just 2); Control.Monad.Error.throwError "chris"; return 1;}
23:22:11 <lambdabot>   add an instance declaration for (MonadError [Char] t)
23:22:24 <andy753421> both of those seem very nice but are fairly incomplete, does anyone know of anything simmilar that has more features included (such as 'instance')
23:22:36 <nolrai_> > do {Just 1 <- return (Just 2); Control.Monad.Error.throwError "chris"; return 1;} :: Either String Int
23:22:39 <lambdabot>  Left "Pattern match failure in do expression at <irc>:1:4-9"
23:23:12 <lament> andy753421: look at YAHT
23:23:39 <lament> andy753421: also, A Gentle Introduction is pretty good if you can read it
23:25:28 <andy753421> lament: alright, i'll take a look at those
23:26:26 <jberryman> Dumb question, but could someone explain the dots in the following expression?: isqrt = floor . sqrt . fromIntegral
23:27:05 <sjanssen> jberryman: function composition
23:27:09 <lament> jberryman: it's the little o sign
23:27:17 <lament> it's just so small that you can't see the hole in the middle
23:27:18 <sjanssen> equivalent to isqrt x = floor (sqrt (fromIntegral x))
23:28:39 <Riastradh> Is it actually equivalent to that, or does the monomorphism not manifest its malevolent mug here?
23:28:47 <Riastradh> ...`monomorphism restriction', even.
23:29:14 <jberryman> that's what I assumed, but I wasn't able to figure out how to "call it" in that form
23:30:00 <Zootal> myFunction (s:ss) = fst s : myFunction ss gives me expected results, but....
23:30:14 <Zootal> it throws an error when it reaches the end of the list
23:30:35 <Zootal> What am I missing, that I can stop this when it iterates through the last element in s?
23:31:04 <Cale> Zootal: Define myFunction []
23:31:42 <Cale> Zootal: Then look at the definition of 'map' perhaps :)
23:32:06 <Twey> Zootal: myFunction = map fst
23:32:12 <Twey> :-)
23:32:34 * Zootal thinks about this...
23:33:40 <Zootal> bwahahaha....
23:33:42 <sjanssen> Riastradh: yes, you're right -- my defn. is more general
23:33:47 <Zootal> It's late, and I'm getting stupid.....
23:33:55 <Zootal> dom :: [( (Int, Int), Int)] -> [(Int, Int)]
23:33:55 <Zootal> dom [] = []
23:33:55 <Zootal> dom (s:ss) = fst s : dom ss
23:34:02 <Zootal> this works as advertised
23:34:21 <sjanssen> Zootal: dom = map fst -- :)
23:34:36 * Zootal does not understand
23:34:49 <sjanssen> @src map
23:34:49 <lambdabot> map _ []     = []
23:34:49 <lambdabot> map f (x:xs) = f x : map f xs
23:35:14 <lament> oh really!
23:35:32 <Cale> lament: Oh really what?
23:35:42 <sjanssen> lament: YA RLY
23:35:43 <sjanssen> :)
23:36:41 <Zootal> :q
23:36:51 <Zootal> oops....sorry, wrong window....
23:37:09 <jberryman> VIM ftw
23:37:17 <sjanssen> Zootal: but don't you want to save your changes?!
23:37:39 <geezusfreeek> :q!
23:37:43 <Zootal> lol...loosing everything I've done up to now would be...bad
23:37:59 <thetallguy> $$hkekegteco
23:38:14 <lament> :t map
23:38:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:38:24 <sjanssen> lament: hahahaha
23:38:37 <sjanssen> stick that in your pipe and smoke it, Cale!
23:39:02 <Cale> sjanssen: what?
23:39:06 <lament> i assume @src doesn't actually poke inside lambdabot to see what definition it uses
23:39:16 <sjanssen> Cale: @src map and @type map don't match
23:39:21 <Cale> lament: nope
23:39:24 * sjanssen isn't going to let this go
23:39:25 <geezusfreeek> yes, smoke the type of map!
23:39:28 <Cale> lament: It just has a database.
23:39:36 <lament> but really this is pretty confusing
23:39:41 <Cale> (a.k.a. a text file)
23:39:46 <lament> especially for newcomers
23:39:52 <lament> not that newcomers even know about @src but still
23:43:42 <Cale> It's not like everything in lambdabot works the same way in ghci anyway :)
23:44:03 <sjanssen> fairly close
23:44:13 <sjanssen> we even use -fextended-defaulting, IIRC
23:45:03 <Cale> But we import a ton of stuff which needs explaining, some of which isn't in the standard distribution.
23:45:27 <sjanssen> new symbols are different from redefined symbols
23:45:50 <lament> :t liftM
23:45:50 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
23:46:05 <lament> @instances Functor
23:46:06 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
23:46:30 <lament> why are monads not fuctors anyway?
23:46:40 <Cale> Prelude bug
23:46:45 <sjanssen> lament: there is no good reason
23:46:46 <geezusfreeek> that came up in the mailing list recently, i think
23:46:56 <lament> Cale: then why are they not functors in lambdabot?
23:47:07 <Cale> lament: Because changing those classes is hard.
23:47:08 <sjanssen> lament: I asked augustss once (he was on the committee), and he couldn't give a reason
23:47:19 <Cale> lament: You have to recompile everything against the new base.
23:47:54 <Zootal> Next noobie question:
23:47:54 <Zootal> spanRefs :: Address -> Address -> [Address]
23:47:54 <Zootal> spanRefs [] [] = []
23:47:54 <Zootal> spanRefs a1 a2 = [a1]
23:48:05 <Zootal> What am I doing wrong with spanRefs [] [] = []?
23:48:07 <lament> oh, really? you can't just define new instances for system classes?
23:48:17 <Zootal> I can't use spanRefs [] = []
23:48:22 <Zootal> because spanRefs takes two arguments
23:48:32 <Cale> lament: You mean to redefine Monad so that it enforces that there be instances of Functor?
23:48:33 <lament> Zootal: is [] an Address?
23:48:42 <geezusfreeek> Zootal: [] is the wrong type
23:48:57 <Cale> Zootal: all the definitions for a function have to have the same number of parameters.
23:49:01 <sjanssen> lament: instance Monad m => Functor m -- overlaps in a very bad way
23:49:04 <geezusfreeek> what is the function you're defining supposed to do?
23:49:36 <lament> sjanssen: with what?
23:50:06 <sjanssen> lament: all Monad types that already have an instance for Functor
23:50:30 <jsnx> maybe it's time to fork haskell and get this Functor/Monad stuff sorted -- GNHC is Not a Haskell Compiler
23:50:32 <lament> oh, right
23:50:48 <Zootal> Hmm...Address is (Int,Int), but I don't really need to trap for [] being passed
23:51:03 <Cale> It also overlaps with all functors which are not monads.
23:51:05 <jsnx> Zootal: there's no way to pass []
23:51:08 <lament> but GHC even allows overlapping instances
23:51:11 <geezusfreeek> the solution suggested in the claiming list i think was to make (class Functor m => Monad m)
23:51:18 <geezusfreeek> *mailing list
23:51:23 <Zootal> yah - I was thinking interating through the list, when I realized I wasn't passing a list
23:51:25 <lament> Cale: what do you mean?
23:51:30 <Zootal> no brain cells...must sleep...
23:51:52 <Cale> lament: Instances are not selected based on other typeclass constraints. They're selected based on the structure of the type alone.
23:52:15 <Cale> lament: This is because you never know when compiling a module whether some future module will define new instances.
23:52:28 <geezusfreeek> of course, that solution requires all Monads to also be Functors, but that's not necessarily a bad thing
23:52:40 <geezusfreeek> just like (class Functor a => Applicative a)
23:52:43 <Cale> All monads are functors.
23:52:54 <bd_> Cale: but not all Monads are Functors
23:52:57 <Zootal> g'night all. YOu have saved my life. Or at least kept me from dropping this @#$ class I'm taking :)
23:52:58 <geezusfreeek> but that is not enforced, right?
23:53:05 <sjanssen> geezusfreeek: correct
23:53:09 <Cale> bd_: That can be considered a bug :)
23:53:14 <bd_> Cale: indeed :)
23:53:16 <bd_> hmm
23:53:17 <geezusfreeek> yes
23:53:21 <Cale> It's not currently enforced, but it could be.
23:53:23 <sjanssen> this should change in Haskell'
23:53:28 <sjanssen> is there a ticket for this?
23:53:30 <geezusfreeek> actually, aren't all monads applicative?
23:53:38 <bd_> perhaps when defining a class Something a => SomethingElse b, you should be able to provide a default instance for Something a in the body?
23:53:53 <sjanssen> geezusfreeek: in actuality yes, in the base library, no
23:54:08 <geezusfreeek> right, that's the distinction i meant to point out
23:54:34 <Cale> bd_: That would be nice, but this isn't so bad even
23:54:42 <geezusfreeek> the only problem with making class Applicative m => Monad m is that now in order to define a monad you have to also define a functor and an applicative
23:54:44 <Cale> bd_: You can always just write:
23:54:50 <Cale> instance Functor MyMonad where
23:54:53 <Cale>   fmap = liftM
23:55:04 <bd_> sure, you can, but that breaks source compatibility
23:55:09 <bd_> if it's made mandatory that is
23:55:18 <bd_> and it's also annoying :)
23:55:21 <Cale> Well, it'll only help find bugs.
23:55:33 <lament> oh, so Monads aren't Functors, they're Applicatives which are Functors...
23:55:46 <Cale> I consider it a bug whenever someone's defined a Monad instance without the corresponding Functor instance.
23:55:47 <geezusfreeek> well, which does mean that monads are functors
23:55:54 <lament> i'm liking Clean's idea of classes (only one function per class) more and more :)
23:55:56 <bd_> lament: All monads are functors, mathematically, but there's nothing that forces you to tell haskell that.
23:56:19 <Cale> lament: ew.
23:56:52 <Cale> That makes classes way more arbitrary -- we need to be able to express complete coherent ideas with them.
23:57:06 <lament> right, but look where that leads to :)
23:57:08 <geezusfreeek> dependent types ftw!
23:57:20 <lament> the complete, coherent idea of monads was expressed just fine
23:57:22 <Cale> The right answer I think is class aliases.
23:57:32 <jsnx> geezusfreeek: there are dependent types in clean?
23:57:39 <Cale> (why hasn't anyone implemented those yet?)
23:57:42 <geezusfreeek> not that i know of, that's not what i meant
23:57:51 <jsnx> oic
23:57:56 <geezusfreeek> i was responding to "we need to be able to express complete coherent ideas with them"
23:58:29 <nolrai_> is there an extention of zipWith to types other than lists?
23:58:38 <newsham> is there a parsec thing for paren parsing?
23:58:50 <dancor> so is there no poll/select for System.Posix.IO?  i'm curious how ghc does it on Handle's..
23:58:50 <geezusfreeek> nolrai_: i think applicative would cover that need
23:58:58 <newsham> ie: do { char ch1; x <- act; char ch2; return act } ?
23:59:07 <newsham> return x
23:59:19 <sjanssen> dancor: GHC's poll/select stuff is built in to the RTS
23:59:51 <sjanssen> dancor: when you need to read from several Handles, use threads
