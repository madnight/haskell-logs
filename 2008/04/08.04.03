00:00:27 <RyanT5000> i'm pretty sure the direction of associativity is arbitrary
00:00:54 <RyanT5000> to be honest i don't have the best argument in the world for this particular "feature"
00:01:02 <RyanT5000> i'm mostly trying to figure out what it would mean
00:01:09 <johnnowak> you give this example: (letrec x (f x) x)... which translates to (((letrec x), (f x), x), yes?
00:01:32 <RyanT5000> well, you've got a triplet, but assuming you treat it left-associatively, yes
00:01:58 <RyanT5000> (letrec x (f x) x) = ((letrec x) (f x) x)
00:02:12 <johnnowak> i see. so letrec returns
00:02:13 <RyanT5000>  = (((letrec x) (f x)) x)
00:02:21 <johnnowak> er.. letrec returns a partially applied macro of sorts
00:02:25 <RyanT5000> basically
00:02:25 <johnnowak> when you do (letrec x)
00:02:34 <RyanT5000> yep
00:02:51 <johnnowak> i think not being able to have N-ary macros is a pretty severe restriction
00:03:07 <RyanT5000> when is it important?
00:03:08 <johnnowak> even simple things like "cond" can't be done
00:03:23 <RyanT5000> well, you can always chuck all your arguments in parentheses
00:03:34 <johnnowak> or sql or html overlays
00:03:42 <RyanT5000> lol?
00:03:45 <johnnowak> or 'do'
00:03:54 <johnnowak> all sorts of things
00:03:57 <RyanT5000> wait a second
00:04:10 <RyanT5000> (cond (p1 e1) (p2 e2)) can't be done
00:04:13 <RyanT5000> but
00:04:22 <RyanT5000> (cond ((p1 e1) (p2 e2))) can
00:04:50 <lament> ugley
00:05:07 <RyanT5000> it's not really that much uglier
00:05:19 <RyanT5000> it's very parallel to lisp's let syntax
00:05:34 <johnnowak> yes, but then how do you do let!
00:05:48 <RyanT5000> what does let! do again?
00:05:54 <johnnowak> er.. that was just an exclaimation.
00:05:58 <RyanT5000> oh
00:05:58 <johnnowak> exclamation even
00:06:00 <RyanT5000> >.>
00:06:03 <johnnowak> you'd need to do this:
00:06:04 <johnnowak> (let (((x 5)) x))
00:06:23 <johnnowak> which is fairly obscene
00:06:40 <RyanT5000> well if you want to allow a list of let-bindings
00:06:46 <johnnowak> and you do
00:06:54 <Staz> hmm - what's the best way to to filter a list of tuples. The criteria is the head == "foo".
00:07:02 <Staz> err
00:07:03 <RyanT5000> you can do (let ((x 5) (z 3)) x)
00:07:08 <Staz> fst == "foo"
00:07:19 <johnnowak> RyanT5000: ah, i suppose you can, can't you.
00:07:25 <RyanT5000> filter ((== "foo") . fst)
00:07:32 <quicksilver> Staz: filter (\x -> fst x == "foo")
00:07:44 <quicksilver> Staz: or, if you like being cute, filter ((=="foo").fst)
00:07:53 <RyanT5000> i love being cute
00:08:10 <Staz> I understand exactly what is going on in your example quicksilver.
00:08:15 <Staz> I'll have to read up about the '.'
00:08:27 <quicksilver> ;)
00:08:41 <RyanT5000> johnnowak: maybe i should make some way of introducing list-parsed regions
00:08:48 <johnnowak> RyanT5000: Joy version: [fst "foo" =] filter ... much nicer!
00:09:09 <RyanT5000> johnnowak: it could be a macro! with syntactic sugar [ ]
00:09:29 <RyanT5000> johnnowak: let [x 5, y 6]
00:09:31 <Cale> Staz: (.) is just function composition which you might remember having a small circle as its symbol in mathematics
00:09:42 <Cale> Staz: It's defined by  (f . g) x = f (g x)
00:10:11 <Cale> So it takes two functions f and g, and produces the function which when applied to an argument x, gives f (g x)
00:10:27 <RyanT5000> johnnowak: but that would require me to introduce a list type :P
00:11:00 <RyanT5000> johnnowak: and i daren't define nil in my standard
00:11:01 <RyanT5000> lol
00:11:29 <johnnowak> seems you've already added 10 pages to the standard to get rid of nil :)
00:11:45 <RyanT5000> johnnowak: nah; i think once the dust settles this will be pretty uncomplicated
00:11:52 <RyanT5000> johnnowak: it's just complicated to think through the first time
00:12:03 <RyanT5000> johnnowak: we're mostly talking about ramifications here, not implementation
00:12:04 <johnnowak> possibly. you never can tell without trying seemingly silly things sometimes.
00:12:19 <RyanT5000> johnnowak: yeah
00:13:33 <Staz> Cale : thanks! -- yes I do remember function composition in algebra.
00:13:58 <johnnowak> RyanT5000: have you looked at the "macro" system in Kernel?
00:14:16 <RyanT5000> i haven't actually looked at Kernel, tbh
00:14:39 <johnnowak> kernel is basically a scheme that takes issue with non-first-class objects
00:14:43 <RyanT5000> ooh
00:14:45 <johnnowak> for better or for worse
00:14:47 <RyanT5000> sounds nice
00:14:48 <BMeph> G'night, all - see you ... later today (if it isn't tomorrow for you by then). :)
00:14:49 <johnnowak> so macros are first class
00:14:59 <RyanT5000> that's right up my alley
00:15:00 <johnnowak> applyable at runtime, etc
00:15:08 <RyanT5000> i don't really believe in non-first-class things either
00:16:10 <johnnowak> well it's worth considering that the lisp community collectively abandoned first-class macros awhile ago for some very good reasons
00:16:19 <RyanT5000> johnnowak: hm
00:16:33 <kaustuv> Any interesting submissions to ICFP this year from this crowd?
00:16:49 <RyanT5000> johnnowak: well i definitely need to learn more about lisp macros
00:17:01 <lament> lisp had first-class macros?
00:17:10 <lament> how would that even work
00:17:27 <johnnowak> lament: if you can call them macros.. it had fexprs which were essentially functions that could access the expressions passed to them without evaluating them
00:17:43 <RyanT5000> johnnowak: well that sounds like a terrible idea
00:17:49 <RyanT5000> my idea is to have functions
00:17:55 <RyanT5000> which you can add to the macro environment
00:17:57 <lament> johnnowak: hm, i think everything works like that in Io
00:18:00 <RyanT5000> (provided they have the correct type)
00:18:01 <johnnowak> it is I think, and that's what Kernel is doing
00:18:05 <johnnowak> yes, Io does the same thing
00:18:16 <RyanT5000> so it would look more like this:
00:18:42 <lament> doesn't sound so bad
00:18:42 <johnnowak> as does Joy, although Joy gets away with it more cleanly as there are no bindings
00:18:49 <RyanT5000> (to go back to list-applicative stuff like lisp does, rather than my left-associative thing, which i haven't figured out yet)
00:19:08 <johnnowak> actually, Joy is slightly different... Joy has non-opaque functions
00:19:11 <RyanT5000> f :: [SExpr] -> SExpr
00:19:15 <RyanT5000> f = ... something ...
00:19:20 <johnnowak> as does pico lisp i think...
00:19:24 <RyanT5000> addMacro f
00:19:54 <johnnowak> RyanT5000: so you have to do evaluation at "compile-time" then?
00:19:58 <RyanT5000> yeah
00:19:59 <johnnowak> instead of just macro expansion?
00:20:04 <RyanT5000> yeah
00:20:13 <RyanT5000> i'm all for running code at compile-time
00:20:24 <RyanT5000> that's practically an axiom of my system
00:20:43 <RyanT5000> i've never been remotely convinced by anything anyone's ever said to me against it
00:20:51 <RyanT5000> the argument is always "it might loop"
00:21:15 <RyanT5000> great; then don't let incompetent programmers write macros, and provide a meta-circular debugger for those who do!
00:21:34 <kaustuv> What about "type inference might become undecidable"?
00:21:34 <johnnowak> the real problem is just the additional complexity you get from that sort of staged compilation approach
00:21:48 <lament> compile-time is just run-time one metaprogramming step away
00:22:02 <lament> you could have several compile-times for that matter
00:22:07 <RyanT5000> kaustuv: so? if your type system ends up looping, you've obviously done something wrong
00:22:26 <RyanT5000> kaustuv: i'll certainly try to make it easy for programmers to avoid undecidability traps
00:22:26 <johnnowak> why would the type system end up looping?
00:22:37 <RyanT5000> johnnowak: well if it's undecidable, it theoretically could, right?
00:22:48 <johnnowak> but why is it undecidable?
00:22:55 <lament> RyanT5000: please make a good type system then
00:23:15 <lament> RyanT5000: haskell's system has to go through weird hoops to allow inference and remain decidable
00:23:22 <quicksilver> it's undecidable if you allow it to be turing complete.
00:23:26 <lament> without that requirement, you can have more powerful stuff
00:23:28 <RyanT5000> johnnowak: i'm not sure if it has to be, but that was kaustuv's complaint, and my point was just that i don't much care even if it is
00:23:29 <bockmabe_> johnowak you're looping :-)
00:23:30 <lament> cleaner
00:23:46 <quicksilver> a turing complete type system is an example of compile-time evaluation.
00:23:47 <johnnowak> kaustuv's complaint doesn't make any sense if you're just talking about staged compilation
00:23:49 <RyanT5000> lament: yeah, mine will probably be turing-complete
00:23:52 <quicksilver> I presume that's the point.
00:23:55 <johnnowak> oh.
00:24:04 <RyanT5000> lament: i might segregate it into turing-complete and decidable portions
00:24:16 <johnnowak> i thought this was supposed to be simple!
00:24:22 <quicksilver> in particulr, the only compile time computation you can do in haskell in in the type system, and it's not turing complete
00:24:26 <quicksilver> (haskell 98, that is)
00:24:32 <johnnowak> and here you go scaring the children
00:24:48 <RyanT5000> johnnowak: the language *will* be simple
00:24:49 <johnnowak> RyanT5000: you've looked at Qi I assume?
00:24:53 <RyanT5000> johnnowak: it'll just be recursive
00:24:56 <RyanT5000> johnnowak: yes, but not enough
00:25:07 <johnnowak> simple concepts and simple implications are two different things
00:25:10 <kaustuv> What do you people mean by "type system is undecidable"? Type checking or type-inference?
00:25:10 <RyanT5000> johnnowak: you may have to interpret certain parts of the program in order to compile others
00:25:18 <RyanT5000> johnnowak: oh, i don't really care whether the implementation is simple :P
00:25:25 <RyanT5000> johnnowak: i'll try to make it sort of simple
00:25:28 <lament> that's the spirit!
00:25:29 <johnnowak> i didn't say implementation, i said implications
00:25:36 <RyanT5000> johnnowak: oh, whoops, misread
00:25:55 <RyanT5000> johnnowak: yeah, the implications need to reasonably simple - at least somewhat *understandable*
00:26:10 <johnnowak> you can have a simple language that's impossible to reason about or make any sense of... Io would be my example here of a language you can learn in five minutes that'll humiliate you for years (if you were silly enough to actually use it that long)
00:27:02 <RyanT5000> hm
00:27:05 <RyanT5000> Io sounds pretty sweet
00:27:11 <johnnowak> hah
00:27:20 <RyanT5000> wait
00:27:27 <RyanT5000> "Perl-like regular expressions" is a feature?
00:27:40 <johnnowak> they're a library feature
00:27:43 <RyanT5000> oh, ok
00:27:47 <RyanT5000> that's fine :)
00:27:57 <johnnowak> the syntax is just a tree
00:28:18 <johnnowak> Io> message(foo(a, b, c)) arguments at(1)
00:28:18 <johnnowak> ==> b
00:28:51 <RyanT5000> oh nice! its comments are syntactically significant!
00:29:08 <johnnowak> i can't tell if that's sarcasm
00:29:10 <RyanT5000> i had that idea too :)
00:29:14 <RyanT5000> no, i'm totally serious
00:29:19 <kaustuv> Does it have significant whitespace?
00:29:25 <RyanT5000> but it's because i don't take input formats very seriously
00:29:44 <johnnowak> kaustuv: newlines
00:29:47 <RyanT5000> if you feel like filtering your input file with the C preprocessor before sending it to me, that's fine
00:30:00 <RyanT5000> my core spec won't even discuss text
00:30:20 <RyanT5000> the ascii/unicode source format is going to be an auxiliary spec
00:30:41 <johnnowak> this is the really crazy thing about Io:
00:30:51 <johnnowak> Io> foo := method(call argAt(1))
00:30:51 <johnnowak> Io> foo(a, b, c)
00:30:51 <johnnowak> ==> b
00:30:56 <johnnowak> full access to unevaluated arguments
00:31:13 <RyanT5000> johnnowak: yeah, i don't really think that's a good thing
00:31:19 <johnnowak> well.. er.. and access to the calling environment,e tc
00:31:26 <RyanT5000> referential transparency is Axiom #1
00:31:38 <lament> io is in the smalltalk tradition
00:31:44 <lament> everything in the open
00:31:57 <lament> everything accessible and modifiable
00:31:58 <johnnowak> io goes way past smalltalk though
00:31:58 <RyanT5000> i really like how Tcl is homoiconic
00:32:03 <lament> ...arguably the main reason nobody uses smalltalk :)
00:32:11 <RyanT5000> it's gotta be the most uselessly homoiconic language
00:32:21 <johnnowak> Io> foo := method(call sender x := 10); foo; x
00:32:22 <johnnowak> ==> 10
00:32:28 <lament> is tcl actually any good?
00:32:49 <RyanT5000> lament: everything's a string
00:32:51 <lament> johnnowak: ouch
00:33:05 <lament> RyanT5000: i know that much. Is it actually any good?
00:33:17 <johnnowak> io also has arbitrary scoping for blocks... it's madness. madness!
00:33:18 <RyanT5000> lament: i'm not sure; it's not fast
00:33:29 <dmwit> lament: It's very good for what it was made for.
00:33:32 <RyanT5000> johnnowak: sounds pretty insane
00:33:44 <lament> johnnowak: sounds like a good platform for building arbitrary programming languages on.
00:33:52 <johnnowak> RyanT5000: it's worth playing with
00:34:01 <johnnowak> nah, no good for that. because it's so dynamic, it's horribly slow
00:34:02 <RyanT5000> johnnowak: i will at some point
00:34:35 <lament> "everything is a" is always an interesting philosophy
00:34:36 <RyanT5000> johnnowak: i imagine that at some point in my life i'm going to spend a year or two doing nothing but learning languages
00:34:46 <lament> so many different choices for what to make everything, too
00:34:49 <RyanT5000> johnnowak: this'll either be while i have some sort of academic funding or after i retire
00:34:59 <RyanT5000> johnnowak: or if i'm disgustingly rich
00:35:18 <johnnowak> i wouldn't wait so long
00:35:44 <RyanT5000> johnnowak: i'm already sinking an irrationally large amount of time into working on my language
00:35:51 <lament> everything is an object. everything is a string. everything is a hash table. everything is an execution token. everything is a function. everything is a list. everything is data. everything is salmon.
00:36:02 <RyanT5000> lament: :D
00:36:06 <kaustuv> Are we ready for "everything is a type"?
00:36:09 <RyanT5000> lament: i have two kinds of things :)
00:36:25 <RyanT5000> lament: i have cons cells and atoms
00:36:42 <johnnowak> RyanT5000: no tuples/arrays/hash-tables?
00:36:46 <dmwit> lament: Which languages are "execution token" and "function"?
00:36:52 <lament> kaustuv: as i understand agda/coq/epigram do that
00:36:56 <dmwit> (I think I recognize all the other ones.)
00:37:04 <olsner> but types are probably isomorphic to some or all of the above, depending on how you use them
00:37:16 <RyanT5000> johnnowak: well, two-tuples, and no, i despise all those things as built-ins
00:37:20 <johnnowak> dmwit: function-level languages are "everything is a function" arguably... see FL, Joy, etc
00:37:24 <olsner> "everything is a list in the type system"
00:37:30 <RyanT5000> johnnowak: you want an array? make a list and convert it at compile-time
00:37:33 <lament> dmwit: forth and FP languages
00:37:45 <lament> (at least lambda calculus)
00:37:46 <RyanT5000> johnnowak: same with tuples, which are just more-complicatedly-typed arrays
00:37:51 <kaustuv> lament: At least Agda and Coq separate types and objects
00:37:58 <Twey> johnnowak: And Haskell?
00:38:18 <dmwit> Twey: Nah, there's data and class and stuff.
00:38:24 <RyanT5000> johnnowak: and i've never seen a language that does anything serious at compile time with hash tables
00:38:25 <lament> kaustuv: only by type, no?
00:38:37 <Twey> Ah, OK.
00:38:42 <johnnowak> Twey: arguably, but not in the same way as FL or Joy. in FL, you write your program entirely in terms of functions and functional forms. in haskell, you're writing in terms of functions, values, and application
00:38:50 <Twey> RyanT5000: Javascript!
00:38:53 <RyanT5000> johnnowak: (by which i mean anything that couldn't be gotten around by "make a list of key-value pairs and convert it at compile time")
00:39:01 <lament> Twey: what compile time? :)
00:39:01 <RyanT5000> Twey: lol :)
00:39:05 <johnnowak> RyanT5000: sure
00:39:08 <Twey> :-P
00:39:09 <kaustuv> lament: well, objects cannot be classifiers, so they are not technically a "type"
00:39:09 <olsner> lament: which programming language falls under "everything is salmon"?
00:39:14 <johnnowak> olsner: PHP
00:39:18 <Twey> Hahahaha
00:39:18 <Twey> No
00:39:21 <Twey> Salmon is tasty
00:39:23 <lament> olsner: Homespring
00:39:24 <johnnowak> good point
00:39:27 <RyanT5000> johnnowak: actually, "list" is going to be a thing you build at compile time too :P
00:39:28 <olsner> johnnowak: oh, because of the smell, I see
00:39:34 <johnnowak> olsner: ah! there we go.
00:39:39 <Twey> lament: I'm sure there's a Javascript compiler out there somewhere :-P
00:40:25 * dmwit is now worried that there is a Javascript compiler out there somewhere, lurking
00:40:33 <RyanT5000> dmwit: lol
00:40:52 <RyanT5000> dmwit: Tamarin from Adobe is a JIT compiler for it :)
00:40:57 <RyanT5000> which i know doesn't count
00:41:04 <RyanT5000> but it's moving in that direction
00:41:31 <olsner> spidermonkey is really a JS->bytecode compiler though
00:41:44 <kaustuv> http://www.mozilla.org/rhino/jsc.html claims "The JavaScript compiler translates JavaScript source into Java class files. The resulting Java class files can then be loaded and executed at another time, providing a convenient method for transfering JavaScript, and for avoiding translation cost."
00:41:44 <lambdabot> Title: JavaScript Compiler
00:41:51 <Twey> Oh
00:41:54 <Twey> Java does JS -> Java bytecode compilation
00:41:59 <Twey> Er, Rhino
00:42:07 <Twey> Yeah.
00:42:26 <Twey> And in Javascript... everything is a hashmap!
00:42:37 <Twey> Oh... except primitives.
00:42:40 <Twey> Dang.
00:42:52 <johnnowak> everything is a hash table in Io
00:42:58 <johnnowak> roughly..
00:43:07 <dmwit> Everything is a hash table in Python.
00:43:08 <dmwit> literally
00:43:15 <dmwit> Even arrays!
00:43:19 <olsner> integers?
00:43:23 <RyanT5000> johnnowak: is "is a" just the set of everything cross everything in Io?
00:43:35 <dmwit> olsner: well...
00:43:43 <RyanT5000> i think so, actually
00:43:46 <johnnowak> RyanT5000: hm?
00:43:49 <RyanT5000> python does a great job of pretending that kind of stuff
00:44:01 <RyanT5000> johnnowak: i mean, "everything is a everything", basically
00:44:28 <RyanT5000> johnnowak: [(a is_a t) | a <- things, b <- types_of_things]
00:45:14 <johnnowak> perhaps.
00:45:50 <RyanT5000> lol i've started over so many times on my language that i've created a Meta-Language-Directory
00:45:56 <RyanT5000> in which i just have numbered directories
00:46:07 <RyanT5000> i think i've got it this time, though
00:46:13 <olsner> hmm, how about "everything is a programming language"
00:46:18 <johnnowak> i said "i think i've got it this time" about 50 times
00:46:18 <RyanT5000> hahaha :)
00:46:31 <RyanT5000> johnnowak: yeah, i think i said it every time :P
00:50:43 <RyanT5000> i'm finally seeing why lisp separates function identifiers from value identifiers
00:50:48 <RyanT5000> i don't *agree* with it
00:50:54 <RyanT5000> but i understand it, i think
00:51:04 <Twey> Lisp doesn't
00:51:09 <RyanT5000> scheme does, then?
00:51:11 <RyanT5000> one of them does
00:51:14 <Twey> Common Lisp does
00:51:19 <RyanT5000> ah, well that's what i meant
00:51:22 <johnnowak> scheme has a single namespace
00:51:23 <Twey> Not all Lisps do -- Scheme doesn't
00:51:27 <RyanT5000> ok ok
00:51:33 <RyanT5000> common lisp
00:51:39 <johnnowak> RyanT5000: why do you think it is a good thing?
00:51:51 <RyanT5000> johnnowak: i said i don't agree with it
00:51:57 <johnnowak> ...
00:51:58 * johnnowak hits self
00:52:00 <RyanT5000> johnnowak: just that i'm beginning to understand it
00:52:01 <Twey> Heh
00:52:03 <dmwit> From "How to attach a rubber band to anything": This trick also works on topologically similar objects, like handbags, one-legged G-strings, and donuts.
00:52:51 <RyanT5000> dmwit: don't hate on the one-legged strippers
00:55:16 <RyanT5000> i really, really wish haskell had type closures
00:55:27 <RyanT5000> i really hate abstracting over the same type a billion times
00:55:34 <RyanT5000> i wish i could just put at the top of my module
00:55:39 <RyanT5000> \a ->
00:55:40 <Cale> wha?
00:56:16 <RyanT5000> (maybe "type closures" isn't the right term)
00:56:36 <RyanT5000> ok, so, e.g.:
00:57:35 <RyanT5000> \a -> {type Environment = Map a Value; extend :: Environment -> a -> Value -> Environment }
00:57:48 <RyanT5000> that's a pretty pointless example, but when stuff gets bigger, it gets super-annoying
00:58:13 <RyanT5000> e.g.: i imagine it was annoying when whoever was writing Data.Map
00:58:41 <RyanT5000> it would be much more convenient to just declare two type parameters at the very top, along with their class constraints, and go from there
00:58:45 <dmwit> Just so "Environment" doesn't have an argument?
00:58:50 <Cale> You can have  type Environment a = Map a Value
00:59:01 <dmwit> right
00:59:05 <RyanT5000> yeah, but the arguments are really annoying
00:59:08 <RyanT5000> i know i can have type arguments
00:59:30 <RyanT5000> the problem is really when you've written a big module
00:59:38 <RyanT5000> and then you decide that you need to abstract over another type
01:00:36 <RyanT5000> well, specifically when one of your type constructors "grows" a new parameter
01:00:41 <Cale> Then it's annoying because the type system informs you where things need to be generalised? ;)
01:01:16 <RyanT5000> Cale: it's annoying because the number of source code insertions is proportional to how many functions you use
01:01:23 <RyanT5000> er, how many functions you've already written
01:01:30 <dmwit> How about annotating less?
01:01:34 <RyanT5000> rather than, for example, how many functions actually depend on that test at all
01:01:36 <dmwit> GHC is pretty smart these days.
01:01:39 <RyanT5000> *type at all
01:02:12 <Jedai> Which is why I want HaRe to work witt GHC Haskell :-)
01:02:22 <RyanT5000> dmwit: i guess that's a solution, but i'm not convinced it's a *good* one
01:02:22 <Jedai> *with
01:02:38 <RyanT5000> dmwit: type annotations should be there to help you, not as a liability
01:02:47 <dmwit> RyanT5000: Oh?  What do you use the annotations for?
01:02:55 <Jedai> RyanT5000: What you're describing looks a little bit like Functor in OCaml
01:03:02 <Cale> Aren't they helping you to discover where the types have changed?
01:03:16 <RyanT5000> Cale: but sometimes i don't really care where the type has changed
01:03:35 <Cale> I suppose you could use a typeclass then.
01:03:51 <RyanT5000> Cale: any function, for example, that has the new parameter universally quantified
01:04:21 <RyanT5000> Cale: well, universally quantified and it doesn't appear outside of its position as an argument for the new parameter
01:04:43 <RyanT5000> if i'm writing the Map library
01:04:53 <RyanT5000> and at first i (foolishly) say "Keys will always be ints"
01:05:04 <RyanT5000> then i go ahead and write my map library
01:05:09 <RyanT5000> data Map v = something
01:05:42 <RyanT5000> i'm gonna write type annotations because i want to make sure everything has the type i expect, e.g. lookup
01:05:45 <RyanT5000> but now i realize
01:06:11 <RyanT5000> "oh no, i really need to abstract over the key type as well"
01:06:27 <johnnowak> annotations are for wimps
01:06:49 <Cale> So what would you like to be able to do? Leave the old notation in place somehow?
01:07:01 <Cale> Wouldn't that get confusing?
01:07:02 <RyanT5000> it would be *really* nice if i could just bracket my entire module in something like typeLambda Ord k => k ---> (old module)
01:07:24 <RyanT5000> and then change the type annotation only on those functions that actually use that type variable
01:07:31 <Cale> uhh...
01:07:39 <RyanT5000> yeah yeah i realize that's a lot of them for map
01:07:50 <RyanT5000> but not, e.g. values :: Map v -> [v]
01:07:51 <Cale> But then you still wouldn't have a type constructor of two parameters for Maps ?
01:07:57 <RyanT5000> no
01:08:11 <RyanT5000> data Map v = blah_involving_k
01:08:39 <Cale> So if you wanted maps with different key types, you have to apply the module at different k?
01:08:46 <RyanT5000> basically
01:08:57 <Cale> That sounds less convenient for the users.
01:09:23 <RyanT5000> Cale: i dunno; we're talking about Data.Map(k, v).Map rather than Data.Map.Map k v
01:09:48 <RyanT5000> it's a little more complicated if they don't want to qualify the name
01:10:05 <dmwit> Yes... but once for each possible k.
01:10:05 <dmwit> =/
01:10:15 <Cale> Heh, I already hate the amount of qualification I'm required to do ;)
01:10:51 <Staz> Is it possible to produce an error for a particular guard?
01:10:55 <RyanT5000> well if you imported Data.Map, it could just infer all the types that need to be passed to the module at each use
01:11:03 <RyanT5000> it's just like lambda-lifting, i think
01:11:18 <Staz> | (filtered == []) = error "uh oh"
01:11:30 <RyanT5000> the module system could just tack all the module-level type variables onto the beginning of the argument list of every type in the module
01:11:36 <dmwit> Staz: That looks right.
01:11:50 <dmwit> Staz: Though in that particular case, "null filtered" might be better.
01:12:04 <RyanT5000> so Data.(Map k v).Map becomes, at a lower level, Data.Map.Map k v, just like olden days
01:12:06 <Staz> I get a "Instance of Eq Expr required for definition.." error on that line
01:12:18 <dmwit> That's why "null" is better. =)
01:12:21 <RyanT5000> the only problem is you end up with useless type parameters to some constructors
01:12:40 <dmwit> Staz: But in reality, you'll probably want an Eq instance for Expr eventually, anyway.
01:12:58 <dmwit> Staz: You can ask the compiler to make one by sticking "deriving Eq" at the end of your data-type declaration.
01:13:20 <Staz> wow it worked!
01:14:27 <RyanT5000> Cale: does what i'm saying seem impossible?
01:14:31 <Staz> thanks very much dmwit
01:14:53 <MarcWeber> type SHM = StateT ShimState IO
01:15:24 <MarcWeber> Which is the way to catch within this monad ? get state ? run catch / handle within IO and within that IO do a runState again?
01:15:57 <Cale> RyanT5000: I'm not sure. It's probably possible. It just seems a bit strange to me for some reason. :)
01:16:17 <RyanT5000> Cale: there have just been too many times when i've been abstracting over like 8 type variables
01:16:25 <dolio> Agda has parameterized modules kind of like that (as does ML, of course).
01:16:29 <Cale> 8 type variables?
01:16:34 <RyanT5000> Cale: maybe i'm using bad style or something, but i could really use something that cuts down on that
01:16:46 <Cale> Do you actually vary all of them?
01:17:10 <dolio> Of course, I think Agda's syntax would boil down ot 'Data.Map.Map k v' in either case.
01:17:11 <RyanT5000> Cale: they're all things that nothing in the module really cares about
01:17:27 <Cale> Then why do they appear in the types?
01:18:39 <Cale> Are you doing some kind of Oleg-style type-level programming?
01:19:04 <RyanT5000> Cale: for example, i would have a module that evaluates a language, which abstracts over the input token type, the builtin-value type, and maybe a few other things
01:19:16 <RyanT5000> oh yeah, e.g. the error type
01:20:43 <RyanT5000> or a library to manipulate hexagonal game boards that abstracts over "data stored in each hex", "data stored on each edge", "data stored on each point"
01:20:59 <RyanT5000> i can't think of a way to reduce the number of type variables there
01:21:45 <RyanT5000> it's illogical to unify them, and it's a pain to thread them through everything
01:22:22 <Cale> Well, 3 is a more reasonable number :)
01:22:30 <dolio> Write everything inside a giant record. :)
01:22:33 <quicksilver> MarcWeber: if you want access to the state in your exception handler it's a bit tricky, as you have observed!
01:22:33 <RyanT5000> Cale: yeah, but it's still needlessly complicated
01:22:42 <RyanT5000> dolio: haha that would do it, wouldn't it
01:22:47 <quicksilver> MarcWeber: you can write a combinator to do it though.
01:22:54 <RyanT5000> dolio: that's ridiculous
01:22:56 <MarcWeber> quicksilver.. I've seen that shim already support catch and handleInShim doing exactly what I've proposed :)
01:23:01 <dolio> RyanT5000: They're a poor man's first class modules.
01:23:04 <quicksilver> MarcWeber: ah, good :)
01:23:10 <RyanT5000> dolio: a very, very poor man
01:23:19 <quicksilver> MarcWeber: basically your custom catch has to save a copy of the state and pass it to the exception handler.
01:23:33 <quicksilver> MarcWeber: this means that it is necessarily the state from the beginning of the failing operation.
01:23:44 <quicksilver> MarcWeber: but that's the nature of the beast (exceptions will roll back state)
01:23:56 <quicksilver> MarcWeber: that must be what the shim guys have implemented.
01:24:20 <MarcWeber> quicksilver: I'd like to talk to them :) (aeh.. Mostly him )
01:24:31 <MarcWeber> quicksilver: http://rafb.net/p/sqh2XW88.html
01:24:33 <lambdabot> Title: Nopaste - No description
01:25:16 <MarcWeber> quicksilver: he gets the staet and passes it on to runState the way I would have done it..
01:26:02 <LeCamarade> What's this stuff I've heard about Advance Australia Fair being found in GHC source code comments?
01:26:06 <LeCamarade> :o)
01:26:09 <MarcWeber> quicksilver: Which editor are you using for editing haskell?
01:26:44 <MarcWeber> Maybe you want to have a look at shim as well.
01:29:17 <quicksilver> emacs.
01:29:36 <quicksilver> yeah, taht's much like I suggested.
01:30:08 <MarcWeber> quicksilver: There is a backend for emacs already implemented (I think it's even the more supported editor..) You get function module completion and jump to source locations I guess.
01:31:11 <quicksilver> yes, I keep meaning to try it out.
01:31:26 <dolio> @where shim
01:31:27 <lambdabot> http://shim.haskellco.de/trac/
01:32:01 <dolio> That seems to be wrong.
01:32:08 <MarcWeber> quicksilver: Use the haskell.org search. I've updated the linke there.. It did take me a while to find the repository
01:32:12 <quicksilver> indeed it does.
01:33:06 <quicksilver> @where+ shim http://code.haskell.org/shim/
01:33:06 <lambdabot> It is stored.
01:35:26 <MarcWeber> quicksilver: If it works for you I can send you my patches enabling camelCase completion and "find module exporting <id>" or grep the whole pacakge scope for regex ..
01:43:42 <ski> would it make sense for `Control.Monad.State.get' and `Control.Monad.Reader.ask' to be the same operation (i.e. have a common superclass with it) ?
01:44:58 <dolio> I could see MonadReader being a superclass of MonadState, I suppose.
01:45:12 <quicksilver> ski: I favour an explicit embedding, I think
01:45:26 <ski> also i wonder how useful `Foo' in `State : Reader :: ST : Foo' would be
01:45:29 <quicksilver> ski: which lets you run Reader actions in State monads.
01:45:57 <dmwit> ski: Not useful at all, I think.
01:46:12 <dmwit> ski: The point of ST is that it allows mutations, so stateful things can sometimes be slightly faster.
01:46:22 <dmwit> ski: But for Reader, mutation doesn't really help...
01:46:31 <quicksilver> that's only one of the points of ST.
01:46:37 <quicksilver> the other is that is models a heap of typed references.
01:46:59 <ski> you've never wanted dynamically generated, locally modified, environment cells ?
01:47:01 <quicksilver> that is more interesting IMO because it's hard to write in pure haskell.
01:48:11 <dolio> Control.Monad.CC.Dynvar does that, more or less, although it allows State-like mutation, as well.
01:48:19 <ski> (istr sometime i wanted an "(>>=') :: State s a -> (a -> Reader s b) -> Reader s b", too ..)
01:48:20 <dolio> And I'm sure it's not as efficient as ST.
01:48:22 <dmwit> ski: Doesn't local modification require copying anyway?
01:48:34 <dmwit> ski: (Not sure I understand the "dynamically generated" bit, though.)
01:48:41 <ski> copying what ?
01:48:43 <quicksilver> ski: yes. Throwing away the ability to mutate.
01:49:13 <quicksilver> ski: although I'm not sure you have that type right.
01:49:23 <dmwit> Copying (some part of) the environment.
01:49:34 <quicksilver> State s a -> (a -> Reader s b) -> State s b
01:49:55 <ski> quicksilver : no, that's not what i meant
01:50:36 <ski> quicksilver : just a special tail-call variant of `(>>=)' for `State' that doesn't return the final state
01:50:36 <quicksilver> ski: Oh, I see.
01:50:53 <quicksilver> ski: the idea is the State action on the left does a "local" modification of the environment?
01:51:06 <quicksilver> ski: in effect, it's a variant on local...
01:51:19 <ski> yes, if you read it from outside-to-inside
01:51:21 * quicksilver nods
01:52:36 <ski> i'm not sure it would be worth it .. just that i at some point wanted to record the constraint of not caring about final states, but still allow intermediate state .. with some not too cumbersome notation
01:54:32 <ski> (btw, re `ST' and "`RT'", sometimes even a variant that just allows generation of new references, as well as reference equality, would be useful ..)
01:56:15 <ski> dmwit : by "dynamically generated" i meant that one have `newRTRef :: a -> RT r (RTRef r a)' for allocating new references dynamically, instead of having a fixed (concrete) environment type, as with `Reader'
01:57:01 <dmwit> Ah, interesting.
01:57:11 <quicksilver> you can't do it in haskell with a Typeable a constraint, can you?
01:57:19 <quicksilver> s/with/without/
01:57:32 <ski> not that i know
01:57:36 <dmwit> Why not?
01:58:01 <dmwit> Have a Map String (forall a. Typeable a => a)?
01:58:11 <dmwit> or something like that?
01:58:24 <quicksilver> "without a Typeable constraint"
01:58:25 <ski> "without a Typeable a constraint"
01:58:30 <dmwit> oh
01:59:48 <quicksilver> it's a shame, somehow.
01:59:57 <quicksilver> not quite sure I appreciate the deep reason why it's not possible.
02:00:03 <quicksilver> Although I appreciate various shallow reasons.
02:00:29 * johnnowak drowns
02:00:37 <ski> (dmwit : one could implement `RT' and `RTRef' by `ST' and `STRef', using mutation to implement `localRef', i think)
02:05:12 <dmwit> johnnowak must have found a deep reason
02:05:20 <dmwit> Too bad he's too dead to tell us what it was.
02:05:27 * johnnowak gurgles
02:05:38 <Twey> johnnowak: Take it to #gurgling please
02:05:47 <quicksilver> #haskell-gurgling is better
02:05:50 <quicksilver> it has lambdabot!
02:05:53 <Twey> Ooh.
02:06:05 <Twey> Lies :-(
02:06:07 <ski> @quote gurgle
02:06:07 <lambdabot> No quotes match. Are you on drugs?
02:06:24 <Twey> We had \bot in #gurgling, but she seems to be gone now
02:06:36 <Twey> We were trying to think of imaginitive ways to make her gurgle.
02:06:49 <Baughn> Shouldn't you take it to #haskell-zombies?
02:06:56 <quicksilver> @remember Twey We had \bot in #gurgling, but she seems to be gone now
02:06:57 <lambdabot> Good to know.
02:07:06 <dmwit> Oh, is there still traffic in #gurgling?
02:07:13 <Twey> There is indeed
02:07:23 <Twey> There's also an off-topic channel, #gurgling-blah
02:07:37 <Twey> For non-gurgling-related discussions
02:07:41 <dmwit> Stunning.
02:07:49 <Twey> Isn't it?  ^_^
02:10:48 <dolio> Control.Monad.CC.Dynvar doesn't have a Typeable constraint.
02:11:00 <dolio> But, of course, the delimited continuations require unsafeCoerce.
02:11:39 <quicksilver> that's interesting.
02:11:52 <quicksilver> how does it manage to be typesafe without storing a TypeRep?
02:12:16 <quicksilver> oh, because you create the variables "one at a time" rather than storing them in a hash?
02:12:32 <quicksilver> ehm, by 'hash' I mean 'Data.Map or similar'
02:12:35 <dolio> Well, it relies on the typed prompts for the delimited continuations.
02:13:00 <dolio> Which are internally implemented via integers provided uniquely by a monad.
02:14:46 <quicksilver> hmm. yes. actually you don't need Typeable to implement Refs
02:14:51 <quicksilver> if you are prepared to use unsafeCoerce.
02:14:59 <dolio> Yeah.
02:15:06 <quicksilver> the only reason to use Typeable is to avoid (hide) the unsafeCoerce
02:15:11 <quicksilver> but the 'cost' is storing a TypeRep
02:15:14 <quicksilver> which you don't actually need.
02:15:18 <quicksilver> because the refs are type-safe anyway.
02:15:49 <quicksilver> the point is "you need Typeable to implement it in 'haskell'"
02:15:52 <dolio> Right. And in this case, the delimited continuations hide the unsafeCoerce, more or less.
02:15:57 <quicksilver> where by 'haskell' I mean something that doesn't have unsafeCoerce.
02:16:34 <quicksilver> so maybe the deep question is 'why do you need unsafeCoerce to implement delimited continuations this way?'
02:18:11 <dolio> Well, it relies on an existentially quantified stack of functions and prompts, and you need unsafeCoerce when you split the stack, when you know the types match, even though you can't inform the type system of that.
02:18:36 <dolio> But I suppose that doesn't really explain it.
02:20:02 <dolio> I suppose the question is, what information would you have to add to the types to know what's what, and that I don't know.
02:22:17 * quicksilver nods
02:22:25 <dolio> Probably reflect the unique numbering of the prompt in its type, and have a type-level list of the types of the prompts.
02:22:29 <quicksilver> dolio: I'm intrigued because it so *nearly* fits into our type system.
02:22:31 <dolio> Or something along those lines.
02:22:40 <quicksilver> and yet, apparently, doesn't.
02:22:54 <quicksilver> when you have a use of unsafeCoerce like that, it seems like there must be a "small" gap in the typesystem.
02:23:08 <dolio> Yeah.
02:23:46 <dolio> Back when I was library-ifying all that, I think I asked on the mailing list if there was a way to do it without unsafeCoerce...
02:24:20 <dolio> And Oleg said you could implement it with ST, but I'm sure that uses unsafeCoerce internally (or, something else equivalent).
02:25:17 <quicksilver> well, newSTRef gives you a powerful way to create new types.
02:25:32 <quicksilver> since implementing STRef in pure haskell has a 'similar' problem to implementing delimited continuations
02:25:39 <quicksilver> and needs unsafeCoerce
02:25:47 <quicksilver> I'm not surprised to hear they are equally expressive.
02:30:27 <quicksilver> (I'm not saying it's obvious, mind. But not surprising)
02:30:41 <dolio> Yeah.
02:33:59 <quicksilver> so, the "deep reason" which I don't understand is likely the same in both cases :)
02:34:04 <quicksilver> and I still don't understand it.
02:38:05 <dolio> Lack of dependent types, clearly. :)
02:42:22 <quicksilver> dolio: in which case, would type families be enough?
02:43:25 <dolio> Well, since you mention it, this strikes me as a similar problem: http://hpaste.org/6305
02:43:57 <dolio> Where you want an interpreter with a heterogeneous environment.
02:44:58 <dolio> A guy here was writing such a thing, and was using unsafeCoerce in his function that looks up values in the environment.
02:45:44 <dolio> So that the looked up value would match the type that the GADT interpreter knows it should be.
02:46:26 <dolio> So I ported that from Idris to Agda to Haskell.
02:46:49 <dolio> Doesn't really use much in the way of type families, although I guess Lookup is key.
02:47:23 <quicksilver> dolio: Yes, I think there is a related "bug" with GADTs
02:47:37 <quicksilver> dolio: (that some of the things you naturally want to do with GADTs require unsafeCoerce)
02:48:00 <Tobsan> @pl foldl sleep $ replicate 4 lolkitten
02:48:00 <lambdabot> foldl sleep (replicate 4 lolkitten)
02:48:01 <quicksilver> somethign to do with the clumsiness of promoting information from the value level to the type level.
02:48:03 <Tobsan> hmm
02:48:47 <Tobsan> @pl \cat -> vcat (take 4 $ cycle [cat])
02:48:47 <lambdabot> vcat . take 4 . cycle . return
02:49:02 <dolio> Anyhow, that interpreter there does it all without unsafeCoerce, although it does de Bruijn indices rather than string variable names.
02:49:27 <dolio> Since reflecting strings into the type level was more pain than I wanted at the time.
02:50:05 <uccus> hi there o good haskellers, I have just logged in so i don't have any idea what dolio and quicksilver are talking about, but I do have a question on GADTs
02:50:35 <uccus> I honestly think the GADT syntax is thoroughly misleading
02:51:11 <ski> why so ?
02:51:49 <dolio> Maybe I'll take a shot at building a version of the delimited continuations without unsafeCoerce, although I don't know if I have enough Olegs.
02:52:03 <uccus> take data Nat n where Zero :: Nat Zero, Suc  :: Nat n -> Nat (Suc n), from dolio's hpaste, for example. what's the role of the first occurrence of n here?
02:52:12 <ski> it's useless
02:52:26 <uccus> my point exactly
02:52:33 <dolio> Yeah, you could write that as "data Nat :: * -> * where ..."
02:52:46 <ski> data Nat :: * .. *right*
02:52:48 <uccus> shouldn't that be the _required_ syntax then?
02:54:29 <ski> i suppose there could be some small value in giving names, to hint at the parameter role .. though this could be said about value signatures as well
02:54:51 <ski> data Map :: (key :: *) -> (value :: *) -> *  -- mayhaps
02:55:15 <uccus> is that bad?
02:55:23 <ski> bad ?
02:55:41 <uccus> what you just wrote down? looks sensible to me!
02:55:57 <uccus> and not unreadable... if that's what you are saying
02:56:01 <ski> this would be if you wanted to avoid `data Map key value', but still for some reason wanted to keep the names
02:57:41 <uccus> so basically data Map :: * -> * -> * ... and I see little value of having names where since Haskell function parameters don't have them (which makes the documentation somewhat awkward)
02:58:24 <uccus> on a conceptual level I have gathered that both GADTs and type families are basically functions on the type level... am I right?
02:59:19 <dolio> I'm not sure I'd look at GADTs that way, necessarily.
02:59:20 <ski> yes, since they have kind of the form `... -> ...'
02:59:27 <quicksilver> uccus: not just GADTs.
02:59:39 <quicksilver> uccus: even humble paramerised types like [a] are functions at the type level.
02:59:44 <ski> @kind []
02:59:45 <lambdabot> * -> *
02:59:47 <dolio> It's more like, they allow values to provide information to the type system.
02:59:53 <uccus> acknowledged
03:00:02 <quicksilver> the progression adt -> gadt -> type family allows you to express "more" functions at the type level though.
03:00:26 <uccus> type families seem more open-ended to me
03:01:16 <uccus> like an equational definition of a function
03:01:22 <uccus> [on the type level]
03:01:38 <uccus> is that a valid way to think about them?
03:02:13 <ski> yes, the type families are a way to partially define type functions
03:02:21 <dolio> Yeah, they're much like pattern matching function definitions on types.
03:02:48 <uccus> saying type families are the typeclasses for type?
03:02:52 <uccus> *types?
03:03:29 <ski> no
03:03:54 <ski> a "typeclass" for types would take kinds as parameters
03:03:55 <dolio> Well, type classes are like defining pattern matching logic-programming relations on types.
03:04:00 <ski> (iiuc what you mean)
03:04:11 <uccus> I think dolio said what I needed to say
03:04:22 <dolio> With functional dependencies, at least.
03:04:38 <uccus> so won't we run into non-termination at the type level?
03:05:01 <ski> we've restrictions that the argument sizes decrease
03:05:15 <uccus> to ensure that non-termination never happens?
03:05:37 <ski> yes (unless you enable specific option to avert this)
03:05:52 <ski> ("this" being "this restriction check")
03:06:47 <uccus> I understand. fascinating things. those specific options... are they necessary in practice? I mean, would not having them severely restrict what a programmer can do?
03:07:24 * ski hasn't played enough with these things to answer
03:07:59 <uccus> I mean to ask: where people use those options (I assume you are talking about dark things like undecidable instances and the like) in a practical situation, can those programs be rephrased efficiently?
03:08:16 <quicksilver> I don't find them necessary.
03:08:25 <quicksilver> In the sense that the real problems I have tried to solve have not required them.
03:08:40 <quicksilver> However, some people find them necessary - or at least useful - for real problems.
03:08:52 <uccus> I thought so. Haskell folklore would say that Oleg would know the answer ;)
03:09:00 <quicksilver> sometimes they enable a 'more elegant' way to solve tsomething
03:09:20 <uccus> the extensions like undecidable instances?
03:09:35 <gogonkt-``> alc: hi
03:09:37 <quicksilver> yes.
03:09:46 <alc> gogonkt-``, greetings =)
03:09:47 <ski> the corresponding thing on value level to type families would be roughly to first have an open algebraic type (corresponding to the kind `*'), which you can declare new constructors of .. and then the type family would correspond to a type signature; and the type instance declarations would correspond to defining equations, matching on some of the constructors
03:09:49 <quicksilver> I dont use undecidable instances. But then again, I don't use typeclasses very much.
03:09:54 <gogonkt-``> alc: saw you
03:09:57 <gogonkt-``> too
03:10:28 <quicksilver> I take the subjective view that typeclasses are overused and so I often don't use them.
03:10:42 <quicksilver> prefering higher-kinded data types and higher-order functions.
03:10:55 <uccus> thanks ski. your explanation seems to me a very intuitive one. which in turn implies it has a great probability of being absolutely correct.
03:11:03 <dolio> mtl uses undecidable instances, I believe.
03:11:09 <quicksilver> ski: some people would quite like that ability.
03:11:14 <quicksilver> ski: (open algebraic data types)
03:11:21 <ski> yes
03:11:22 <dolio> I think the type families version wouldn't need them, though.
03:12:05 <quicksilver> dolio: it uses them in an 'inessential but useful' way, I think?
03:12:09 <quicksilver> for the instance schemes
03:12:16 <dolio> Yeah.
03:12:21 <ski> quicksilver : hm, any example of using higher-kinded data types instead of classes ?
03:12:26 <quicksilver> are they actually -fundecidable, or just overlapping?
03:12:34 <uccus> I really enjoyed reading the draft paper on Manuel's page. things are making more sense now. many things converging towards coherence.
03:12:49 <dolio> Undecidable, I believe.
03:12:49 <ski> uccus : what draft paper ?
03:12:58 <uccus> on type families?
03:13:29 <uccus> http://www.cse.unsw.edu.au/~chak/papers/SPCS08.html
03:13:31 <lambdabot> Title: Research Papers of Manuel Chakravarty
03:13:39 <quicksilver> ski: I just pasted one on hpaste. hmm. bot not working?
03:13:46 <dolio> 'instance (MonadFoo f m) => MonadFoo f (BarT m) where ...' is undecidable due to the f not being guarded or something like that.
03:13:47 <quicksilver> ski: http://hpaste.org/6795
03:13:50 <ski> btw "Given the functionality provided by GADTs (Generalised Algebraic Data Types), it might seem as if a definition, such as the above, should be feasible. However, type families are - in contrast to GADTs - are open; i.e., new instances can always be added, possibly in other modules. Supporting pattern matching across different data instances would require a form of extensible case construct."
03:14:28 <quicksilver> dolio: -fundecidable, but not undecidable, I believe.
03:14:55 <quicksilver> dolio: that is, it fails the "simple decidability criterion" that ghc uses but isn't actually undecidable.
03:14:56 <dolio> But 'type instance Foozle (BarT m) = Foozle m' works within the limits of type families.
03:15:08 <dolio> Oh, right. It's decidable. The rules just forbid it.
03:15:12 * quicksilver nods
03:15:24 <ski> quicksilver : oh, you're calling it `Lens' ?. .. (i'm currently using `FRef')
03:16:51 <ski> quicksilver : though actually that is not an example .. it's not higher-order kinded (and i don't see either how you would instead use a type class)
03:17:22 <quicksilver> ski: many people would make Tunable a type class
03:17:31 <quicksilver> ski: class Tunable s v
03:17:39 * wli likes showing off his body after having lost 70 lbs.
03:17:57 <trez> webcam?
03:18:00 <ski> quicksilver : but the value isn't determined by the type, no ?
03:18:05 <wli> ugh, sorry
03:18:17 <ski> modify :: Lens s a -> (a -> a) -> s -> s
03:18:49 <quicksilver> ski: correct, there isn't a fundep either way.
03:18:54 <quicksilver> ski: one s can have many vs.
03:18:56 <quicksilver> indeed, that's the point.
03:19:08 <quicksilver> it's for interactive modification of values hidden in a 'large' state object.
03:19:16 <ski> tunableInc tun s = modify (tunLens tun) s
03:19:22 <quicksilver> yes, I know :)
03:19:46 <quicksilver> modify (tunLens tun) (tunInc tun) s
03:20:20 <ski> quicksilver : sorry, i was unclear .. i wasn't referring to fundep between class parameters .. i was referring to no fundep from all the class parameters to the member signatures
03:20:56 <ski> e.g., the same reason why `class (Functor f,Functor g) => NaturalTransformation where eta :: f a -> g a' isn't very useful
03:21:09 <ski> s/NaturalTransformation/NaturalTransformation f g/
03:21:23 <ski> *nod*
03:21:24 * quicksilver nods
03:21:32 <quicksilver> yes
03:21:56 <quicksilver> I think my point is people use typeclasses when they shouldn't and then get frustrated when they can't have more than one implementation per type.
03:22:18 <quicksilver> when you can do something more general and flexible using what you might call explicit dictionaries.
03:22:19 <ski> perhaps there's different problems here
03:22:57 <ski> i suppose people want to eat the cake and have it too
03:23:33 <ski> both have implicit environment, but still locally changeable
03:24:36 <ski> (in some cases it's more or less clear that there should be at most one instance .. in other cases, not so clear .. `Ord',`Monoid')
03:25:59 <ski> quicksilver : what do you think of `instance MonadState s m => MonadRef (Lens s) m' ?
03:26:24 <ski> (assuming `newRef' is not in `MonadRef' but in a subclass)
04:06:20 * wli quickly ponders methods of numerically solving diffeq's of irregular forms, e.g. (y'')^3 + 1 = y^2 + (y')^2
04:06:48 <wli> (esp. 2nd-order nonlinear like that)
04:12:52 <wli> One could always try to minimize the sum of squared residuals at a set of knots subject to spline constraints or some such.
04:23:34 <HunterXHunter> whats the best IDE and compiler for windows?
04:24:25 <ndm> HunterXHunter: Haskell or in general?
04:25:48 <cjs> Is there a way to assign specific, arbitrary numbers to an enumerated data type as I declare it, or do I need to write a mapping function?
04:27:07 <ndm> cjs: no, there isn't, unless you do them in order starting at 0
04:27:39 <cjs> And a quick reminder, when I do that, I derive Enum?
04:28:15 <cjs> And then just use fromEnum to get the number?
04:28:34 <ndm> indeed
04:28:42 <HunterXHunter> ndm: haskell
04:29:26 <ndm> HunterXHunter: i use TextPad and WinHugs, with occasional trips towards GHC
04:29:34 <ndm> HunterXHunter: there isn't really a good answer, unfortunately
04:30:38 <HunterXHunter> another question, whats the best book for learning haskell?
04:30:40 <rdtsc> there is eclipsefp if you like eclipse
04:30:56 <HunterXHunter> yes i like eclipse and word complete
04:31:04 <ndm> HunterXHunter: the Graham Hutton book is the standard one
04:31:09 <jgrimes> how is visualhaskell these days?
04:31:16 <ndm> @google graham hutton haskell book
04:31:18 <lambdabot> http://www.cs.nott.ac.uk/~gmh/book.html
04:31:18 <lambdabot> Title: Programming in Haskell
04:31:39 <ndm> jgrimes: it was not that great when i tried it, going towards more unsupported as time went by
04:32:12 <ski> @hoogle Ix i => (i,i) -> (i -> e) -> m (a i e)
04:32:12 <lambdabot> No matches, try a more general search
04:32:34 <jgrimes> ndm: I see.
04:39:32 <HunterXHunter> haskell is surprisingly easy to learn
04:39:41 <HunterXHunter> i'm starting to get the hang of it
04:39:50 <byorgey> HunterXHunter: awesome =)
04:42:12 <desegnis> I never understood code using the type family extension when I came across it, but now reading in that paper that "type family" means "type function", it suddenly makes sense :)
04:44:17 <wli> A better example would be the control system for the "cart and pole" inverted pendulum problem.
05:02:52 <vegai> Cale: you awake?
05:07:42 <vegai> @tell Cale latest lambdabot head seems to be missing something: http://hpaste.org/6796
05:07:42 <lambdabot> Consider it noted.
05:12:14 <dolio> Hmm... Anyone know off hand how to go about proving 'Length (Snoc ts a) ~ Succ (Length ts)'?
05:13:32 <dolio> Where by proving I mean generating a non-bottom value of type 'Equ (Length (Snoc ts a)) (Succ (Length ts))' so that I can substitute a value of one type for another. :)
05:14:06 <TomMD> Are you already using a proof assistant (HOL4, Isabelle)?
05:14:18 <dolio> Oh, where 'data Equ a b where Refl :: Equ a a'.
05:14:23 <dolio> I'm using Haskell. :)
05:14:55 <dolio> Maybe I should try my tomfoolery in Agda first.
05:14:58 <ndm> dolio: then you have no proofs abhout non-bottomness unless you use Catch and a termination checker
05:14:58 <TomMD> yes, but much can be done in Isabelle in the way of proofs and translated to Haskell.   It is done frequently.
05:16:42 <dolio> ndm: Well, I'm not so much worried about proving non-bottomness throughout the program as I am about it working in practice.
05:17:09 <meee> hello everyone; can i get a bit of help please..
05:17:34 <gbacon> meee: maybe
05:17:47 <gbacon> meee: we'll do our best!
05:17:52 <dolio> TomMD: Yes, but doesn't Isabelle prove things on its own and extract things using unsafeCoerce and such? I'm interested in using Haskell's (GHC's) type sytem to avoid unsafeCoercing in this case.
05:17:57 <meee> thank you gbacon :)
05:18:31 <gbacon> meee: the song you're looking for: http://www.youtube.com/watch?v=IC7iIttp6cY&fmt=18
05:18:32 <lambdabot> Title: YouTube - LL COOL J - GOING BACK TO CALI
05:18:33 <meee> its got to with lists.. what i am trying to do is to group the like terms in a list together
05:18:45 <gbacon> @hoogle group
05:18:45 <lambdabot> Data.List.group :: Eq a => [a] -> [[a]]
05:18:45 <lambdabot> Data.ByteString.group :: ByteString -> [ByteString]
05:18:45 <lambdabot> Data.ByteString.Char8.group :: ByteString -> [ByteString]
05:18:49 <gbacon> @hoogle groupBy
05:18:49 <lambdabot> Data.List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
05:18:49 <lambdabot> Data.ByteString.groupBy :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
05:18:49 <lambdabot> Data.ByteString.Char8.groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
05:18:52 <dolio> I mean, of course it doesn't extract to Haskell GADTs and type families and such.
05:19:23 <meee> yeah a bit of trouble with groupBy as im new on learning haskell :D sorry
05:19:49 <gbacon> meee: let's see some examples then
05:19:59 <gbacon> show the input and what you expect for the output
05:20:30 <meee> ok ive got a list for example [x,x,y,z,z,z,w]
05:20:47 <gbacon> heels tall.. she said.. she likes.. the o-cean
05:21:20 <meee> i want to group the elements together and make sublists so that i have [[x,x],[y],[z,z,z],[w]]
05:21:26 <s710b> > groupBy (==) "mississippi"
05:21:30 <lambdabot>  ["m","i","ss","i","ss","i","pp","i"]
05:21:37 <meee> oooh i c
05:21:38 <meee> :D
05:21:41 <meee> thank you
05:21:42 <opqdonut> > group "mississippi"
05:21:43 <lambdabot>  ["m","i","ss","i","ss","i","pp","i"]
05:21:52 <s710b> i learned that yesterday :)
05:21:55 <gbacon> meee: what had you tried?
05:22:11 <meee> i thought it must have been something complicated
05:22:35 <meee> but like s710b said, ill try to use the (==) operator
05:22:36 <meee> :)
05:22:40 <EvilTerran> > groupBy (const.(=='a')) "abracadabra"
05:22:42 <lambdabot>  ["abracadabra"]
05:22:46 <EvilTerran> hm
05:22:48 <s710b> > group "mississippi"
05:22:48 <lambdabot>  ["m","i","ss","i","ss","i","pp","i"]
05:22:52 <Deewiant> > (\xs -> map (\a -> filter (==a) xs) (nub xs)) "mississippi"
05:22:52 <lambdabot>  ["m","iiii","ssss","pp"]
05:22:55 <EvilTerran> > groupBy ((==)`on`(=='a')) "abracadabra"
05:22:56 <lambdabot>  ["a","br","a","c","a","d","a","br","a"]
05:23:10 <gbacon> meee: (==) isn't an operator: it's a section.. a funny way to write a function
05:23:14 <gbacon> @type (==)
05:23:15 <lambdabot> forall a. (Eq a) => a -> a -> Bool
05:23:30 <gbacon> > (==) True False
05:23:31 <lambdabot>  False
05:23:35 <gbacon> > (==) True True
05:23:36 <lambdabot>  True
05:23:46 <meee> ooh sorry :)
05:23:49 <meee> yea
05:23:52 <EvilTerran> > groupBy ((==)`on`isSpace) "A neat\nway to\tseparate  words and whitespace "
05:23:53 <lambdabot>  ["A"," ","neat","\n","way"," ","to","\t","separate","  ","words"," ","and","...
05:24:28 <s710b> :t on
05:24:29 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
05:24:35 <EvilTerran> ?src on
05:24:35 <lambdabot> (*) `on` f = \x y -> f x * f y
05:24:40 <gbacon> meee: no need to be sorry, but you'll see sections ALL OVER THE PLACE in Haskell code.. it's an important concept to grasp
05:24:46 <gbacon> @type (== 3)
05:24:47 <lambdabot> forall a. (Num a) => a -> Bool
05:25:00 <gbacon> > let f = (== 3) in f 4
05:25:01 <lambdabot>  False
05:25:03 <gbacon> > let f = (== 3) in f 2
05:25:03 <lambdabot>  False
05:25:05 <gbacon> > let f = (== 3) in f 3
05:25:06 <lambdabot>  True
05:25:41 <gbacon> > groupBy (\a b -> a == b) "mississippi"
05:25:41 <lambdabot>  ["m","i","ss","i","ss","i","pp","i"]
05:25:42 <EvilTerran> some people say equating = ((==)`on`), much like comparing = (compare`on`) in the 6.8 libs
05:26:07 <gbacon> meee: see how (==) is shorthand for that function?
05:26:08 <ZimaN> wow :)
05:26:17 <ziman> `on` is nice ;0
05:26:22 <s710b> > groupBy (isSpace) "mississippi"
05:26:22 <lambdabot>  Couldn't match expected type `Char -> Bool'
05:26:22 <EvilTerran> indeed
05:26:27 <gbacon> @karma+ on
05:26:27 <lambdabot> on's karma raised to 1.
05:26:44 <EvilTerran> ?type uncurry ((***) `on` ((/) `on` fromIntegral))
05:26:44 <lambdabot> forall b a. (Integral a, Fractional b) => (a, a) -> (a, a) -> (b, b)
05:27:06 <EvilTerran> > uncurry ((***) `on` ((/) `on` fromIntegral)) (1,2) (3,4) :: (Rational,Rational)
05:27:07 <lambdabot>  (1%3,1%2)
05:27:37 <meee> hmm
05:27:45 * EvilTerran has a bag of tricks like that :D
05:27:59 <gbacon> meee: still having trouble?
05:28:04 <EvilTerran> > var . ((++) <*> show) $ "> var . ((++) <*> show) $ "  -- here's another (unrelated) trick
05:28:05 <lambdabot>  > var . ((++) <*> show) $ "> var . ((++) <*> show) $ "
05:28:27 <opqdonut> :P
05:28:36 <meee> i am trying to absorb all of this first
05:29:03 <EvilTerran> > fix (\r -> 1 : do x <- r; [1+x, 1/(1+x)]) :: [Rational] -- i've opened the bag now, they're all flying out!
05:29:04 <lambdabot>  [1%1,2%1,1%2,3%1,1%3,3%2,2%3,4%1,1%4,4%3,3%4,5%2,2%5,5%3,3%5,5%1,1%5,5%4,4%5...
05:29:09 <ziman> why does lambdabot put an extra space before the expression? :)
05:29:09 <gbacon> meee: what can we help you understand better?
05:29:24 <gbacon> ziman: it's funkier that way
05:29:28 <EvilTerran> ziman, so you can't create an infinite loop if there's two bots on the channel
05:29:35 <ziman> oh :)
05:29:36 <EvilTerran> eg, with my quine there
05:29:46 <ziman> clever ;)
05:30:31 * EvilTerran opens another of his files - "1s.hs" :D
05:31:04 <EvilTerran> > iterate (fmap fix return) 1 -- this one in particular strikes me as gloriously obscure
05:31:05 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:31:31 <gbacon> EvilTerran: that's very clever.. how's that working out for you -- being clever?
05:31:36 <gbacon> :-)
05:31:42 <s710b> EvilTerran, has fix sthg to do with fixed points?
05:31:49 <EvilTerran> s710b, yes, it does
05:31:51 <gbacon> @ty fix
05:31:52 <lambdabot> forall a. (a -> a) -> a
05:31:54 <opqdonut> EvilTerran: well that's not really that obscure :)
05:32:08 <EvilTerran> gbacon, it's working brilliantly for me. oxford uni is great fun. :D
05:32:10 <s710b> thats why i dont like it :P
05:32:18 <opqdonut> once one realizes that fmap f g is f.g
05:32:27 <EvilTerran> opqdonut, well, once you realise fmap = (.) it becomes a lot simpler, yes
05:32:40 <EvilTerran> s710b, fix f = f (fix f)
05:32:48 <EvilTerran> @src fix
05:32:48 <lambdabot> fix f = let x = f x in x
05:33:02 <EvilTerran> ... is the actual definition. it comes to the same thing, but the sharing is better.
05:33:22 <EvilTerran> so, say, fix (1:) = 1 : fix (1:) = 1 : 1 : fix (1:) = ...
05:33:25 <opqdonut> and also return = const
05:33:27 <opqdonut> in the reader monad
05:33:43 <opqdonut> so that's just renaming :)
05:33:48 <EvilTerran> > fix (1:)
05:33:49 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:33:53 <opqdonut> iterate const == repeat
05:33:57 <opqdonut> is a nice observation tho
05:34:20 <opqdonut> as was remarked here earlier, it's kind of cute that the (->) monad is really just SKI calculus :)
05:34:52 <EvilTerran> ... isn't that iterate.const?
05:35:01 <ndm> EvilTerran: i suspect that map (+1) (iterate const 2) runs faster than map (+1) (repeat 2)
05:35:06 <EvilTerran> ?type iterate const
05:35:11 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
05:35:13 <lambdabot>     Probable cause: `const' is applied to too few arguments
05:35:15 <lambdabot>     In the first argument of `iterate', namely `const'
05:35:23 <ndm> ?type iterate id
05:35:24 <lambdabot> forall a. a -> [a]
05:35:26 <EvilTerran> ndm, really?
05:35:41 <ndm> EvilTerran: quite possibly, repeat has more sharing, but iterate has foldr/build fusion
05:35:47 <EvilTerran> ahh
05:36:01 <EvilTerran> optimising in the wrong direction, eh
05:36:03 <ndm> in Supero I redefined repeat to not have sharing, since that is usually a speed benefit if you deforest the resulting list
05:36:06 <ndm> indeed
05:36:29 <ndm> I have a big suspicion that letrec as a non-top-level construct is probably premature optimisation gone pessimistic
05:37:43 <pejo> ndm, how are they potentially more efficient? (And it's easy to fix - just lambda lift)
05:38:55 <ndm> pejo: let xs = x : xs in xs will only ever allocate one (:) cell, and does a tie back in memory
05:38:55 <opqdonut> EvilTerran: yeah iterate.const
05:39:05 <ndm> pejo: and i do lambda lift them out :)
05:44:11 <pejo> ndm, oh, you were talking about a specific function using local letrec, not letrec in general?
05:44:22 <ndm> pejo: yeah
05:51:21 <ndm> @seen dcoutts_
05:51:21 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #ghc and #haskell. I don't know when dcoutts_ last spoke.
05:51:48 <ndm> dcoutts_: i have a few cabal bugs, fighting each other to be more annoying and fatal :)
05:54:33 <Saizan_> ndm: tried sdist on windows with the new cabal-install?
05:54:45 <ndm> Saizan_: that one worked :)
05:54:49 <Saizan_> 7nick Saizan
05:55:00 <Saizan> nice :)
05:55:10 <ndm> Saizan_: i have cabal install failing, cabal upload being weird and cabal haddock failing
05:55:15 <ndm> but sdist works like a charm :)
05:56:19 <Saizan> it seems dcoutts_  won't be back for a few days, btw
05:57:20 <ndm> :(
05:57:37 <ndm> will upgrade my copy of cabal-install as well, and hit the mailing list then
05:59:14 <TOaO> > sum[1..999]
05:59:15 <lambdabot>  499500
05:59:33 <HunterXHunter> > sum[1..10]
05:59:33 <lambdabot>  55
05:59:45 <HunterXHunter> neat
05:59:55 <TOaO> lol
06:00:20 <oToom> @faq Can haskell beat up the bullies?
06:00:20 <lambdabot> The answer is: Yes! Haskell can do that.
06:05:33 <novaburst> Does anyone know of any Haskellers near the state of Indiana? I'm looking for one to do a demo or speak at our programming meetup April 23rd.
06:09:56 <HunterXHunter> is haskell 98 the latest standard?
06:10:17 <HunterXHunter> @faq is haskell 98 the latest standard?
06:10:17 <lambdabot> The answer is: Yes! Haskell can do that.
06:10:31 <HunterXHunter> @faq is haskell gay?
06:10:31 <lambdabot> The answer is: Yes! Haskell can do that.
06:10:35 <HunterXHunter> @faq
06:10:35 <lambdabot> The answer is: Yes! Haskell can do that.
06:10:39 <HunterXHunter> lol
06:11:21 <Saizan> HunterXHunter: yes, it is, they are working on Haskell' now
06:13:00 <s710b> @src return
06:13:00 <lambdabot> Source not found. Where did you learn to type?
06:16:39 <shepheb> s710b: return is specified by the Monad typeclass, the implementation is different for each monad. (ie. for lists: return = (:[])   for Maybe, return = Just )
06:19:00 <tromp> > pred 1
06:19:01 <lambdabot>  0
06:19:04 <tromp> > pred 0
06:19:05 <lambdabot>  -1
06:19:20 <tromp> > pred False
06:19:21 <lambdabot>  Exception: Prelude.Enum.Bool.pred: bad argument
06:19:53 <tromp> > pred (0,0)
06:19:53 <lambdabot>   add an instance declaration for (Enum (t, t1))
06:20:24 <s710b> shepheb, i see. i have to look into monads, i dont really understand how they work
06:20:24 <tromp> > pred 'a'
06:20:25 <lambdabot>  '`'
06:20:47 <tromp> > pred '\001'
06:20:48 <lambdabot>  '\NUL'
06:20:52 <tromp> > pred '\000'
06:20:53 <lambdabot>  Exception: Prelude.Enum.Char.pred: bad argument
06:23:26 <ski> @src Maybe return
06:23:26 <lambdabot> return              = Just
06:23:32 <ski> @src [] return
06:23:32 <lambdabot> return x    = [x]
06:23:38 <ski> s710b : ^
06:23:38 <ski> ^
06:23:58 <s710b> nice :)
06:25:02 <s710b> @src IO return
06:25:02 <lambdabot> return x    = returnIO x
06:26:26 <ski> @src Maybe (>>=)
06:26:26 <lambdabot> (Just x) >>= k      = k x
06:26:26 <lambdabot> Nothing  >>= _      = Nothing
06:26:55 <tromp> > succ (Just 0)
06:26:55 <lambdabot>   add an instance declaration for (Enum (Maybe t))
06:27:39 <tromp> @src returnIO
06:27:39 <lambdabot> Source not found. I feel much better now.
06:27:40 <ski> s710b : `IO' is an abstract (possibly primitive) type, similarly for its operations
06:29:59 <glen_quagmire> glen_quagmire has posted http://hpaste.org/6800  titled: [(a,b)] -> (b -> m b) -> m [(a,b)] combinator?
06:32:37 <ski> @type \abs f -> mapM (\(a,b) -> (,) a `liftM` f b) abs
06:32:39 <lambdabot> forall t t1 a1 (m :: * -> *). (Monad m) => [(t, t1)] -> (t1 -> m a1) -> m [(t, a1)]
06:32:46 <shepheb> @hoogle [(a,b)] -> (b -> m b) -> m [(a,b)]
06:32:47 <lambdabot> No matches, try a more general search
06:33:00 <shepheb> @ty sequence
06:33:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
06:33:13 <scook0> @type runKleisli . second . Kleisli
06:33:14 <lambdabot> forall d a (m :: * -> *) b. (Monad m) => (a -> m b) -> (d, a) -> m (d, b)
06:33:54 <scook0> sequence and (rK . s . K) should do the trick
06:34:21 <scook0> pity you need the Kleisli newtype
06:35:11 <ski> glen_quagmire : `let keys = map fst dict; let vals = map snd dict' could be replaced by `let (keys,vals) = unzip dict'
06:35:36 <HunterXHunter> eclipseFP is ownage
06:35:39 <glen_quagmire> ski: oh cool. kleisli stuff isn't my level
06:35:52 <scook0> heh
06:36:09 <scook0> it's not #haskell if nobody gets to show off
06:36:39 <glen_quagmire> when i get comfortable with monads, it'll be all about arrow i hear
06:36:44 <ski> glen_quagmire : 'twas scook0 who mentioned kleisli, not me
06:38:11 <quicksilver> this isn't really "using arrows".
06:38:38 <quicksilver> just observing that what you are doing, which is a natural thing, happens to correspond to an operation with a name in the arrow module :)
06:40:15 <ski> glen_quagmire : the `prev' stuff might be nicer to abstract into some `local'-like combinator
06:40:59 <ski> localState :: MonadState s m => (s -> s) -> m a -> m a
06:41:10 <ski> localState f ma = do
06:41:19 <ski>   prev <- get
06:41:35 <ski>   put (f prev)
06:41:40 <ski>   a <- ma
06:41:44 <ski>   put prev
06:41:46 <ski>   return a
06:42:16 <glen_quagmire> cool thanks
06:44:05 <ski> type Dict = [(String,Int)]
06:44:17 <ski> accum :: Dict -> Wrap Dict
06:44:25 <ski> accum dict = do
06:44:48 <ski> actually
06:45:08 <ski> accum dict = localState (const "0") $ do
06:46:31 <ski>   dict' <- forM dict $ \(key,val) -> do
06:46:44 <ski>     val' <- eval val
06:47:00 <ski>     return (key,val')
06:47:34 <ski>   println $ show (snd (last dict'))
06:47:38 <ski>   return dict'
06:47:54 <ski> glen_quagmire : how does that look ?
06:48:11 <glen_quagmire> it looks professional!
06:49:50 <ski> (one might perhaps avoid the "return dict'" thing by using some kind of "after" combinator)
06:50:04 <ski> er "before" ?
06:50:20 <glen_quagmire> your nick reflects your coding style: combinators
06:51:13 <glen_quagmire> unless ski is as in down the hill aggressive alpine skiing
06:51:49 <ski> no, the nick comes from the combinator calculus
06:52:20 <ski> @hoogle finally
06:52:26 <lambdabot> Control.Exception.finally :: IO a -> IO b -> IO a
06:52:34 <ski> @hoogle bracket
06:52:34 <lambdabot> Control.Exception.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
06:52:34 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
06:52:34 <lambdabot> Control.Exception.bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
06:52:51 <ski> not quite
06:53:38 <ski> then :: Monad m => m a -> (a -> m ()) -> m a  -- possibly a better name could be chosen
06:53:53 <ski> action `then` finish = do
06:53:58 <ski>   a <- action
06:54:03 <ski>   finish a
06:54:06 <ski>   return a
06:54:12 <desegnis> There's something in Control.Applicative that does that
06:54:17 <desegnis> I think
06:54:26 <ski> could be
06:54:31 <glen_quagmire> :t traverse
06:54:35 <lambdabot> Not in scope: `traverse'
06:54:47 <glen_quagmire> @hoogle traverse
06:54:47 <lambdabot> Data.Traversable.traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
06:54:47 <lambdabot> Data.Foldable.traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
06:55:29 <desegnis> hm, or maybe not, I cannot find it
06:56:34 <desegnis> ah, it couldn't even be in Control.Applicative because of the need for bind
06:57:04 <ski> quicksilver : did you have any comment on `instance MonadState s m => MonadRef (Lens s) m' ?
07:02:03 <quicksilver> ski: apart from being maybe confusing relative to other uses of the phrase 'Ref'.
07:02:06 <quicksilver> I like it :)
07:02:08 <quicksilver> but is it useful?
07:03:56 <ski> you could probably experiment with changing from `State' to `ST' and back, using this interface, i think
07:04:53 <ski> (though, note that `Lens' doesn't support `newRef' so we can't have that in the base `MonadRef' class)
07:06:16 <HunterXHunter> i just compiled my first exe, its 531kb big :S
07:08:01 <ski> but really, i think there's a clear analogy between e.g. `STRef s a' and `FRef s a' (s/FRef/Lens/). in the former case, `ST s b' threads a hidden (linearly used) state and the reference is just a "lens" inside that
07:09:26 * ski wonders how many separate monadic reference classes are needed, for the various instances
07:10:39 <ski> `FRef s' supports `readRef',`writeRef',`modifyRef',`localRef'
07:11:02 <ski> `STRef s' supports `newRef',`readRef',`writeRef',`modifyRef',`localRef'
07:11:20 <ski> (same with `IORef')
07:11:59 <ski> `RTRef s' would support `newRef',`readRef',`localRef'
07:12:28 <ski> what about `MVar',`TVar' ?
07:12:55 <quicksilver> MVars and TVars are non-deterministic IORefs
07:12:58 <quicksilver> I think.
07:13:08 <quicksilver> semantically there isn't much you can say about them.
07:13:10 <ski> also, one can imagine ones supporting `writeRef' but not `readRef'
07:13:30 <quicksilver> without a radically different semantics, at least.
07:13:39 <quicksilver> You could have a version of lens which supported a type-restricted newref, I guess
07:13:50 <ski> how do you mean ?
07:15:04 * ski 's library computer loan expires in less than a minute .. later
07:42:57 <mm_freak_work> hi there
07:45:01 <glen_quagmire> we're no strangers to love
07:55:32 <mknod> hi, is there any haskell modules system tutorial? I have looked at the "learning haskell" tutorial but I can't find anything, maybe some tutorials have a section about this theme?
07:56:03 <mknod> ops, I meant I looked at the "learning haskell" section of the wiki
07:57:52 <gnuvince> mknod: have you checked the wikibook?
07:58:23 <desegnis> There isn't really much to know about the module system. import and export lists, qualified imports, import "as", little cross-module optimization
07:58:58 <mknod> no gnuvince , I'll check it thanks
07:59:21 <kpreid> desegnis: well, there are some quite unobvious things, like how do you export constructors vs. type names
08:00:19 <desegnis> right
08:01:40 <mknod> humm, I just want to import a module from a file in the working directory, but the wikibook only shows how to create it
08:01:45 <desegnis> (What was the rule, data constructors are always given in parens after the type they belong to?)
08:02:28 <desegnis> mknod, name the file after the module, and "import ModuleName"?
08:02:33 <kpreid> mknod: for ghc/ghci, if you have Foo.hs in the cwd then "import Foo" suffices
08:03:45 <Beelsebob> >.<
08:03:55 <Beelsebob> the British embassy in brussels suck ass
08:04:25 <mknod> oh ok thanks, it works, there was a typo :S
08:14:16 <HunterXHunter> monad is an attempt at seperating side effects from functions?
08:17:15 <byorgey> HunterXHunter: that is one application of monads.
08:17:25 <Vq^> HunterXHunter: among other things yes, thought it's more than just an attempt at this point
08:17:47 <Saizan> can you pull from darcs.haskell.org/cabal or cabal-install
08:17:48 <Saizan> ?
08:18:27 <Baughn> Saizan: Were you asking anyone in particular?
08:19:21 <Saizan> Baughn: no, anyone will do :) it's not working for me
08:19:36 <Saizan> probably server slowness.. but
08:20:18 <Baughn> Saizan: Hm, you're right
08:20:34 <Baughn> Saizan: It seems to be overloaded a lot. I should hurry up on the authentication thing, so we can have mirrors. ;)
08:22:28 <Saizan> Baughn: what are you doing here then?:) lately it has been slower and slower..
08:28:55 * byorgey tosses marshmallow lambdas
08:28:58 * quicksilver glows with pride
08:29:09 <quicksilver> someone mentioned my tunnelling monads on the -cafe! :)
08:29:14 <quicksilver> next step, broadway.
08:29:18 <byorgey> quicksilver: heh, awesome =)
08:29:26 <byorgey> Tunneling Monads: The Musical!
08:29:37 <quicksilver> I cast Jim Barrowman as SPJ.
08:29:43 <quicksilver> John, even.
08:29:45 <quicksilver> whatever he's called.
08:29:56 <byorgey> I wouldn't know.
08:30:13 <Jos_> hi, i have a type Coordinate = (Int, Int) to represent cartesian coordinates. is it possible to add/subtract two of these coordinates with the (+)/(-) operators?
08:30:21 <Jos_> sorry for interruption btw
08:30:32 <quicksilver> if it's a question about haskell, it's not an interruption.
08:30:35 <quicksilver> ;)
08:30:40 <Jos_> true ;)
08:30:47 <quicksilver> You could make a Num instance for (Int,Int), yes.
08:30:55 <Beelsebob> you could
08:30:58 <quicksilver> Of course, (Int,Int) is in some ways not a "normal" Num instance.
08:31:01 <quicksilver> but it would work fine
08:31:05 <Beelsebob> but it would require overlapping instances
08:31:09 <quicksilver> for the purposes of getting (+) and (-) going.
08:31:11 <Beelsebob> I think
08:31:11 <byorgey> wha...?
08:31:16 <byorgey> no overlapping instances necessary
08:31:24 <Beelsebob> no, I'm being a moron
08:31:31 <quicksilver> you have a question about how you define (*)
08:31:33 <Jos_> so it might be better to define new operators instead?
08:31:36 <quicksilver> but the simplest answer is not to bother :)
08:31:44 <quicksilver> (you could define it like complex numbers, though)
08:31:48 <byorgey> instance Num (Int, Int) where  (x,y) + (z,w) = (x+z,y+w) ; ... and so on
08:32:00 <kpreid> Jos_: Why not use complex numbers instead of (Int, Int)?
08:32:00 <Jos_> ah, i see
08:32:04 <byorgey> and the correct answer is that WE DEMAND SANE NUMERIC CLASSES
08:32:04 <quicksilver> some people woudl argue that it's "better" to use new operators.
08:32:12 <quicksilver> because (Int,Int) isn't really like Num.
08:32:14 <quicksilver> But it's OK
08:32:24 <quicksilver> you wouldn't find anythiing particularly bad happened.
08:32:27 <Jos_> kpreid: because i only need addition and subtraction for now
08:32:51 <kpreid> Jos_: but having the other stuff costs nothing.
08:33:30 <byorgey> I'm with Jos_ here, it doesn't make sense to use an overgeneral data type
08:33:33 <Jos_> kpreid: yes but it looks like a weird solution
08:34:00 <byorgey> better to just define exactly what you need and let the type system help you out.
08:34:11 <HunterXHunter> [1,2,3]!!0 just look weird to me
08:34:30 <byorgey> Jos_: if I were you, I wouldn't bother with Num, just define new operators like (.+) and (.-) or something
08:34:38 <HunterXHunter> elem 3 [1,2,3] would look cleaner
08:34:46 <shepheb> is it theoretically possible to have a (Num a, Num b) => (a,b) deriving Num
08:35:09 <byorgey> I don't think you could do the deriving.
08:35:25 <Jos_> ok, thanks for all the feedback everyone, its clear for me now :)
08:35:40 <byorgey> I mean, of course it's *theoretically* possible, but it isn't clear what the "correct" choices of implementations would be
08:35:41 <Jos_> i'll try the (.+) solution
08:35:46 <EvilTerran> i think you might be able to with standalone deriving
08:35:50 <kpreid> Jos_: representing points as complex numbers is actually quite natural; it's done all the time
08:36:12 <shepheb> byorgey: yes, I know. is (*) just (a*c, b*d) or something else, and so on.
08:36:22 <bd_> shepheb: how do you implement Ord?
08:36:24 <EvilTerran> actually, no, nvm, as you can't derive Num except on newtypes of a Num type
08:36:36 <HunterXHunter> why isn't nested list allowed? [1,2,[3]] ?
08:36:41 <byorgey> shepheb: that one's actually one of the clearest.  But what would the definition of 'signum' be for instance?
08:36:47 <bd_> HunterXHunter: because [3] isn't a number :)
08:36:53 <bd_> HunterXHunter: You can do [ [1], [2], [3] ]
08:36:55 <conal> HunterXHunter: what would the type be?
08:37:02 <HunterXHunter> bd_: oh i see
08:37:04 <byorgey> HunterXHunter: lists are always homogeneous, i.e. all the elements must have the same type
08:37:10 <shepheb> yeah, there's no real one-size-fits-all implementation for any of that
08:37:17 <HunterXHunter> byorgey: yes i get it now thanks
08:37:21 <idnar> of course, you can have [[], [], [[]]
08:37:38 <byorgey> HunterXHunter: if you want to be able to represent something like [ 1, 2, [3] ], you can, but you have to create your own data type to represent it
08:37:41 <idnar> er, with a closing ]
08:37:44 <kpreid> HunterXHunter: You can do [Left 1, Left 2, Right [3]] though, which has type (Num a, Num b) => [Either a [b]]
08:38:56 <Beelsebob> or you could define your own type that looks very similar to Either but has rather more descriptive names than Left/Right
08:39:30 <HunterXHunter> > product [1..999]
08:39:33 <byorgey> data Nested a = Single a | List [Nested a]
08:39:33 <lambdabot>  4023872600770937735437024339230039857193748642107146325437999104299385123986...
08:40:02 <HunterXHunter> > 1 'div' 2
08:40:02 <lambdabot>  Improperly terminated character constant at "'div'" (column 3)
08:40:12 <Beelsebob> > 1 `div` 2
08:40:14 <lambdabot>  0
08:40:18 <Beelsebob> back ticks, not quotes
08:40:25 <HunterXHunter> > 1 `div` 2
08:40:26 <lambdabot>  0
08:40:31 <HunterXHunter> oh
08:40:42 <byorgey> single quotes are for literal Char values
08:40:56 <byorgey> > 'h' : 'e' : 'l' : 'l' : 'o' : []
08:40:56 <lambdabot>  "hello"
08:41:09 <byorgey> > div 1 2
08:41:10 <lambdabot>  0
08:41:21 <byorgey> the backticks just turn a prefix function into an infix operator
08:41:40 <Beelsebob> (similar to how parentheses turn an infix operator into a prefix function)
08:41:43 <Beelsebob> > (+) 2 1
08:41:44 <lambdabot>  3
08:41:51 <kpreid> > let x = id in const `x` "foo"
08:41:51 <lambdabot>  Add a type signature
08:42:18 <kpreid> > let x _ = id; y = id in x `y` "z"
08:42:19 <lambdabot>  Add a type signature
08:42:34 <HunterXHunter> > + 1 2
08:42:34 <lambdabot>   parse error on input `+'
08:42:37 <kpreid> > let x _ v = v; y = ($) in x `y` "z"
08:42:38 <lambdabot>  Add a type signature
08:42:44 <kpreid> > let x _ v = v; y = ($) in x 'y' "z"
08:42:45 <lambdabot>  "z"
08:42:53 <HunterXHunter> possible to turn infix into prefix?
08:43:02 <kpreid> HunterXHunter: (+)
08:43:05 <kpreid> > (+) 1 2
08:43:06 <lambdabot>  3
08:43:09 <HunterXHunter> oh
08:43:20 <HunterXHunter> how about postfix?
08:43:27 <tromp> nope
08:43:35 <kpreid> > let x _ v = v; y f v = f undefined v in x `y` "z"
08:43:36 <lambdabot>  "z"
08:43:39 <kpreid> > let x _ v = v; y f v = f undefined v in x 'y' "z"
08:43:40 <lambdabot>  "z"
08:43:50 <kpreid> there we go! equivalent 'y' and `y`
08:53:15 <MyCatVerbs> Is it safe to close a handle from under another thread's nose?
08:53:59 <Baughn> MyCatVerbs: Even if it is, it's very bad practice. I would avoid testing the idea
08:54:17 <quicksilver> MyCatVerbs: no, it's not
08:54:29 <quicksilver> MyCatVerbs: if you later re-open more files, the FD numbers are recycled.
08:54:36 <MyCatVerbs> Baughn, quicksilver: heh, thanks.
08:54:40 <quicksilver> MyCatVerbs: so the other thread ends up with a handle to the new file.
08:54:45 <MyCatVerbs> Come to think of it, that was a really stupid idea.
08:54:58 <quicksilver> my principle is this: file handles live in one and only one thread.
08:55:16 <quicksilver> other threads wanting to write to the same file should write to a Chan.
08:55:30 <Baughn> Oh, by the way - where can I find a select-alike?
08:55:59 <quicksilver> select() as in IO multiplexing?
08:56:06 <quicksilver> it's built in to GHC's IO implementation.
08:56:08 <MyCatVerbs> I have two process control problems at the moment: one set of processes need to be killable in the middle of their work, another set of processes need to be communicated with painlessly. Better to just handle the two cases seperately, heh.
08:56:10 <quicksilver> Just use threads and it just works.
08:56:14 <Baughn> Hm. I know that - bad question
08:56:30 <Baughn> I want to wait for input on a socket /while/ potentially having to write to that socket at any time
08:56:36 <MyCatVerbs> It would be really stupid to try to provide for both needs in one place. Sure, it could be done, but it'd be easily ten times as complicated.
08:56:38 <Baughn> I could use two threads for that, I suppose. Should I?
08:56:48 <quicksilver> yes
08:56:51 <quicksilver> it's actually simpler
08:56:53 <quicksilver> (IMO)
08:57:07 <quicksilver> blocking threads are a convenient abstraction over select() :)
08:57:28 <Baughn> So that's the exception to "one thread per handle", then. One thread per socket direction?
08:57:35 <quicksilver> yes, sorry.
08:57:40 <quicksilver> should have made that clearer.
08:57:47 <quicksilver> one thread per direction.
08:58:02 <quicksilver> (and you need a policy about whose "job" it is to kill the other thread at shutdown time)
08:58:04 * Baughn dreamt of monads last night. They made sense, too, but the Ancient Stone Construction (tm) using lazy evaluation of physics was quite a puzzle to bypass
08:58:41 <Baughn> ..now that I'm awake, it /still/ makes sense, which scares me
08:59:28 <MyCatVerbs> Baughn: please put it down on paper, and draw diagrams if necessary.
09:00:06 <Baughn> MyCatVerbs: I couldn't draw diagrams if I wanted to. The physics was reasonably sane, but also graph-based instead of dimension-based
09:00:28 <Baughn> MyCatVerbs: And no, you won't get to see my dream diary. Too much blackmail material.
09:00:30 <MyCatVerbs> Baughn: so describe the graph structure?
09:02:13 <MyCatVerbs> Baughn: also, directed or undirected graph?
09:02:39 <Baughn> MyCatVerbs: Eh, basically just the haskell RTS machinery, with thunks and evaluated data pointing at each other like you'd expect. There were some interesting consequences for being caught up in a thunk, though - if you aren't evaluated, you don't have a consciousness, but it'd get inserted more or less retroactively at need
09:03:38 <Baughn> MyCatVerbs: And of course the First Forcer. A particularily odd version of god, but what do you expect an atheist to dream of? :P
09:05:43 <MyCatVerbs> Baughn: Main.main? :)
09:06:05 <Baughn> MyCatVerbs: Yes, applied to the universe. ;)
09:06:07 <MyCatVerbs> Baughn: oooh! SPJ!
09:06:26 <Baughn> MyCatVerbs: SPJ?
09:06:37 <MyCatVerbs> Baughn: or McCarthy or Kernighan or Steele or Sussman or whoever your programming deity of choice might happen to be.
09:06:50 <MyCatVerbs> Baughn: Simon Peyton-Jones, in Haskell's case. :)
09:06:52 <Baughn> MyCatVerbs: Ada. ;)
09:07:22 <Baughn> Countess Lovelace
09:08:31 <CosmicRay> J. Presper Eckert?
09:09:17 <Baughn> If it's going to be the /first/ forcer, it has to be Ada.
09:09:18 <CosmicRay> I used J. Presper Eckert as the answer to "favorite historical person" for some website that we all use in my department.  last week, one of my coworkers came over and said "who in the world is J. Presper Eckert?"  So we of course had to describe the ENIAC
09:09:53 <MyCatVerbs> Baughn: ahhhh. Yes, true 'dat.
09:13:25 <HunterXHunter> > add =  \ x y -> x + y
09:13:25 <lambdabot>  Parse error at "=" (column 5)
09:13:49 <HunterXHunter> bah
09:13:57 <Baughn> @let add = \x y -> x+y
09:13:57 <lambdabot> Defined.
09:14:06 <Baughn> ..though I question the need
09:14:21 <byorgey> HunterXHunter: that's a perfectly valid way to define add, but by itself it is not an expression (it is a declaration) which is why you got an error there
09:14:26 <ydo> @let add = (+)
09:14:26 <lambdabot> <local>:5:0:     Multiple declarations of `L.add'     Declared at: <local>:4:...
09:14:31 <byorgey> > \let add = \ x y -> x + y  in add 3 5
09:14:31 <lambdabot>  Parse error at "let" (column 2)
09:14:38 <byorgey> err, oops =)
09:14:41 <byorgey> > let add = \ x y -> x + y  in add 3 5
09:14:41 <lambdabot>  8
09:14:45 <Baughn> > add 2 3
09:14:46 <lambdabot>  5
09:14:57 <Baughn> @undefine add
09:14:58 <lambdabot> Undefined.
09:15:01 <Baughn> @let add = (+)
09:15:02 <lambdabot> Defined.
09:15:26 <Baughn> It would be nice if you could /re/define them, but as it is, you need to know how to tickle lambdabot right
09:15:39 <ydo> > foldr add 0 [1,2,3,4]
09:15:40 <lambdabot>  10
09:15:56 <Baughn> > foldl' add 0 [1..40000
09:15:56 <lambdabot>  Parse error at end of input
09:15:57 <Baughn> > foldl' add 0 [1..40000]
09:15:58 <lambdabot>  800020000
09:16:24 * MyCatVerbs tickles \bot.
09:16:32 <ttt--> @src foldl'
09:16:32 <lambdabot> foldl' f a []     = a
09:16:32 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
09:16:34 <HunterXHunter> is it possible to define infix operators like + ?
09:16:39 <ttt--> @src foldl
09:16:39 <lambdabot> foldl f z []     = z
09:16:39 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:16:41 <Baughn> HunterXHunter: Yes
09:16:48 <HunterXHunter> how?
09:16:52 <HunterXHunter> without using ``
09:17:20 <byorgey> > let x <*?> y = 3*x + y  in 3 <*?> 2
09:17:21 <lambdabot>  11
09:17:22 <Baughn> > let a + b = a - (negate b - 1) in 1+1
09:17:23 <lambdabot>  3
09:17:53 <byorgey> you define them using the same syntax with which you use them
09:18:07 <Baughn> That works for `foo` too, incidentally
09:18:19 <Baughn> > (+) a b = 42 in a+b -- Or this
09:18:19 <lambdabot>  Parse error at "=" (column 9)
09:18:19 <byorgey> HunterXHunter: however, note that if you try to redefine + , you will probably get an error about ambiguous definitions, because + is already defined
09:18:23 <Baughn> > let (+) a b = 42 in a+b -- Or this
09:18:24 <lambdabot>  42
09:18:38 <HunterXHunter> ok
09:18:54 <Baughn> HunterXHunter: Shadowing is fine. Making your own prelude is fine too, but you shouldn't do that for a while yet. ;)
09:19:14 <HunterXHunter> Baughn: yeh I won't
09:22:52 <chessguy> making your own prelude could be a good exercise
09:25:43 <sclv> is there any code out there which makes sane use of gunfold?
09:26:07 <HunterXHunter> is this an example of currying: let rec = (1/) ?
09:27:02 <sclv> yep -- but its also an example of operator sections, which are the syntax for partial application of operators.
09:27:16 <Deewiant> almost every function in haskell is curried
09:29:37 <ddarius> That's an example of partial application.
09:31:02 <MyCatVerbs> @pl \size -> newArray_ (0,size)
09:31:02 <lambdabot> newArray_ . (,) 0
09:31:07 <Baughn> "foo x = let bar = doSomething x in \y -> doSomethingElse bar y" <-- How would I do this without such nasty syntax?
09:31:23 <JaffaCake> is HackageDB down?
09:31:34 <JaffaCake> http://hackage.haskell.org/packages/archive/pkg-list.html
09:31:35 <Baughn> Yeap
09:31:39 <Deewiant> @pl foo x = let bar = doSomething x in \y -> doSomethingElse bar y
09:31:39 <lambdabot> foo = doSomethingElse . fix . const . doSomething
09:31:46 <MyCatVerbs> JaffaCake: it seemed to be for me for the last twenty minutes, but it just came up again.
09:31:54 <JaffaCake> hmm
09:32:03 <JaffaCake> still down for me
09:32:08 <MyCatVerbs> Well, two pages loaded.
09:32:24 <Baughn> Deewiant: Does that preserve the performance characteristics of mine?
09:32:32 <MyCatVerbs> And now you mention it, actually clicking on library links causes nothing to happen.
09:32:45 <Deewiant> Baughn: no clue, compile and see what GHC outputs
09:32:53 <Baughn> Oh goodie
09:34:03 <MyCatVerbs> Baughn: foo x = doSomethingElse (doSomething x) -- yaay, currying
09:34:12 <MyCatVerbs> @pl \x -> doSomethingElse (doSomething x)
09:34:12 <lambdabot> doSomethingElse . doSomething
09:34:28 <quicksilver> Baughn: no, it does not.
09:34:40 <Deewiant> what's the difference?
09:34:41 <quicksilver> Baughn: @pl removes lets, and hence removes sharing.
09:34:46 <Baughn> ..that all /looks/ very pretty, but I'm trying specifically to preserve bar's sharing
09:34:56 <Deewiant> ah, right
09:35:17 <Deewiant> foo x = let bar = doSomething x in const . doSomethingElse $ bar
09:35:18 <Deewiant> I guess
09:35:23 <Baughn> Also, @pl should have a "fix . const = id" rule somewhere
09:35:39 <Baughn> foo = doSomethingElse . fix . const . doSomething <-- This just looks odd otherwise. ;)
09:35:58 <ddarius> Baughn: Which leads to MyCatVerbs' solution which should be what you want.
09:35:58 <Deewiant> @pl fix . const
09:35:58 <lambdabot> id
09:36:02 <MyCatVerbs> Baughn: try turning optimizations on. Doesn't lambda-floating get you the sharing of bar?
09:36:17 <Baughn> MyCatVerbs: I don't know. It doesn't seem to be specified anywhere.
09:36:31 <MyCatVerbs> Baughn: try it and tell us, please? :)
09:36:32 * JaffaCake just talked to the admin of hackage.haskell.org, it crashed this morning but should be back up now
09:36:37 <Baughn> I suppose that's the more general question - is there a document I can read that specifies how haskell is evaluated?
09:36:56 <MyCatVerbs> JaffaCake: and it's up again. Like a med student's drawers.
09:37:09 <Baughn> JaffaCake: It's up, but not responding to pings. Evil thing.
09:37:41 <ddarius> Baughn: Not for the Haskell language.  There are things that cover aspects of how GHC works.
09:38:32 <Baughn> Where can I read about let floating?
09:39:20 <JaffaCake> Baughn: there was some stuff about let-floating in Andre Santos' thesis
09:39:50 <Baughn> ..one thing's for sure, haskell is good at forcing me to further my studies
09:39:58 <Baughn> Is this really newbie-friendly, though
09:40:00 <Baughn> ?
09:40:06 <ddarius> http://hackage.haskell.org/trac/ghc/wiki/Commentary
09:40:08 <lambdabot> Title: Commentary - GHC - Trac
09:41:13 <MyCatVerbs> Baughn: nope.
09:41:30 <MyCatVerbs> Baughn: most certainly it isn't. Oh well.
09:46:54 <HunterXHunter> how do I undefine a variable in the GHCi shell?
09:47:11 <Baughn> HunterXHunter: You don't
09:47:18 <Baughn> HunterXHunter: You can redefine it, though
09:47:25 <HunterXHunter> ok
09:47:45 <Baughn> If you're trying to get it GCed, redefining to () or something should allow that. *Should*.
09:52:19 <quicksilver> Baughn: GHC seldom (rarely) let-floats in a way which increases sharing like that.
09:52:34 <quicksilver> Baughn: if it did, it would be a frequent source of memory leaks
09:52:42 <Baughn> quicksilver: So I should introduce an explicit let when I want sharing. That's what I thought.
09:52:42 <quicksilver> just like automatic memoisation.
09:52:45 <quicksilver> yes.
09:52:52 <quicksilver> GHC will do some "safe" let-floating.
09:52:56 <quicksilver> whatever that is.
09:53:00 <Baughn> How about wheres? Those are equivalent, right?
09:53:00 <quicksilver> I don't know the criterion.
09:53:05 <quicksilver> yes.
09:53:11 <quicksilver> erm
09:53:13 <quicksilver> I think so.
09:53:27 <quicksilver> the key point is bar x = \y ->
09:53:31 <quicksilver> you *return* a closure
09:53:36 <quicksilver> and the closure can have local bindings
09:53:46 <quicksilver> (which are therefore shared until the whole thing gets gced)
09:53:56 <Baughn> That's what I thought. Thanks
09:53:59 <quicksilver> where shold just be syntactic sugar for let.
09:54:02 <quicksilver> Core doesn't have where.
09:57:06 <shepheb> just out of curiousity, is it possible to supply handwritten Core to GHC? is there ever a conceivable reason to do so?
09:58:51 <quicksilver> I think it must be possible. I don't know how you do it.
09:59:06 <quicksilver> You might want to do it because you were adding a new front-end feature.
09:59:22 <quicksilver> But in most cases I can think of, you'd be happy targetting haskell, rather than core.
09:59:44 <quicksilver> the only reason not to would be to exploit some aspects of System Fc which haskell doesn't give you access to
09:59:52 <quicksilver> (some type equality tricks, perhaps?)
10:00:11 <quicksilver> From one perspective, haskell is just sugared core, after all.
10:00:40 <sclv> hpaste didn't announce :-( -- http://hpaste.org/6801
10:00:54 <Baughn> Is it possible to say "here's a class definition; don't complain if one already exists and it is identical to this one"?
10:01:11 * Baughn is wondering for the purpose of data accessors
10:01:32 <Lycurgus> about
10:01:58 <sclv> by class definition you mean actual class, or instance?
10:01:59 <quicksilver> Baughn: I don't think so. Classes are global and unique.
10:02:05 <byorgey> the hpaste bot seems to be down.
10:02:11 <byorgey> who owns the hpaste bot?
10:03:05 <Lycurgus> @hpaste
10:03:05 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:03:51 <Lycurgus> Bryan O'Sullivan?
10:05:24 <sclv> anyway, yeah, generic extensible way to marshall from heterogeneous tuples to a common type and back again -- super useful for making library syntax pretty.
10:05:55 <desegnis_> byorgey, Lycurgus, PasteBot.hs is part of glguy's hpaste repo, so he would be who to ask
10:06:14 <sclv> with it, instead of forcing ppl to do [toSql val, toSql othertypeofval] you can just let them do (val,otherval). whee!
10:06:43 <byorgey> sclv: neat! =)
10:07:06 * byorgey makes whiny noises in glguy's direction
10:07:34 <HunterXHunter> how do I define a recursive function in the shell?
10:07:36 <sclv> now to write irritating instances for tuples up to 25
10:08:01 <byorgey> sclv: Template Haskell? =D
10:08:08 <Baughn> HunterXHunter: Co-recursion?
10:08:21 <HunterXHunter> Baughn: whats that?
10:08:30 <byorgey> HunterXHunter: you could do, for example,  let fib 0 = 1 ; fib n = n * fib (n - 1)
10:08:33 <Baughn> HunterXHunter: Two (or more) functions calling each other
10:08:43 <HunterXHunter> oh
10:08:45 <Baughn> HunterXHunter: "let x=y; y=x" or thereabouts. Maybe something slightly less deadlocky
10:08:48 <sclv> > let f x = if x > 5 then x else x + 1 in f 0
10:08:51 <lambdabot>  1
10:08:59 <Baughn> HunterXHunter: Simple self-recursion should work automatically
10:09:10 <roconnor> oh crap, there are two different definitions of co-recursion.
10:09:13 <desegnis_> HunterXHunter: shell as in ghci? let ... (with everything on one line). or Data.Function.fix, if you prefer ;)
10:09:15 <sclv> > let fun x = if x > 5 then x else x + 1 in fun 0
10:09:15 <lambdabot>  1
10:09:45 <shepheb> @src fix
10:09:45 <lambdabot> fix f = let x = f x in x
10:09:49 <roconnor> Baughn: wait, that isn't Co-recursion, that is mutual recursion.
10:09:51 <sclv> oh right.
10:10:00 <Baughn> roconnor: You're right. Me bad.
10:10:00 <roconnor> Baughn: co-recursion is something different.
10:10:06 <sclv> > let fun x = if x > 5 then x else fun (x + 1) in fun 0
10:10:06 <Baughn> I just looked it up
10:10:06 <lambdabot>  6
10:10:21 <Baughn> Co-recursion is just tying the knot, then?
10:10:35 <sclv> byorgey: that would require me learning template haskell :-(
10:10:36 <shepheb> isn't fibs = 0 : 1 : zipWith (+) fibs (tail fibs)    an example of corecursion?
10:10:46 <byorgey> sclv: hehe, never mind then =)
10:10:53 <Baughn> shepheb: Yes
10:11:02 <Guftekar> selammm
10:11:03 <roconnor> Baughn: I use co-recursion to mean that all recursive calls are guareded by a constructor.
10:11:09 <byorgey> sclv: it could be interesting to go back at some later date and figure out how you could have done it with TH though
10:11:23 <roconnor> Baughn: which is the dual to all recursive calls being called on a substructure.
10:12:04 <sclv> yeah -- it shouldn't be too rough. if you wanted to engage in a quick tutorial now, based on my paste, I wouldn't mind in the least. :-)
10:12:07 <shepheb> byorgey: I finally get fixpoints. I was thinking about them the wrong way around.
10:12:13 <roconnor> I believe tying-the-knot is called data-recursion
10:12:31 <byorgey> shepheb: that's great!  explain, please. =)
10:12:32 <roconnor> but the whole subject of what is data and what are functions is a bit touchy.
10:12:37 <Saizan> yeah data- or value-recursion
10:12:54 <byorgey> sclv: oh, I don't know TH very well either ;)
10:13:11 <shepheb> byorgey: well, from the definition of a fixed point as a point such that f(x) = x, I kind of got the idea that fix f should find such an x.
10:13:13 <sclv> co-recursion is used two ways though -- the data vs. codata way, and then the more general two functions calling one another way.
10:13:28 <shepheb> which I believe is impossible in general
10:13:32 <byorgey> shepheb: ah, right.  a common misconception indeed.
10:13:37 <Zao> Is there anything one can't put co- in front of?
10:13:55 <sclv> ?faq can Haskell put a co- in front of anything?
10:13:55 <lambdabot> The answer is: Yes! Haskell can do that.
10:14:03 <Saizan> (fix f) does find such an x, the least defined one
10:14:20 <shepheb> Saizan: but not in the way I took it to mean originally.
10:14:29 <shepheb> :t fix
10:14:30 <lambdabot> forall a. (a -> a) -> a
10:14:53 <Baughn> shepheb: It does find such an x. [1,1..] is the fixed point of (1:), after all
10:15:11 <Baughn> shepheb: Of course it's only useful on a very limited subset of functions, and goes about it a particular way
10:15:34 <shepheb> > fix (\x -> x^2)
10:15:34 <lambdabot>  Exception: <<loop>>
10:15:36 <byorgey> right, but I understand shepheb's confusion.  It is easy to think that, for example, fix $ \x -> 2/x  should evaluate to  sqrt 2.
10:15:37 <mikeX> hello, how would I ago about printing a list, map putStrLn list doesn't work
10:15:51 <Zao> mikeX: mapM or mapM_
10:15:53 <shepheb> see, my original impression was that it would produce 0 or 1 for the above, for eaxmple
10:15:58 <Baughn> shepheb: Or, should I say, /when/ it finds a result, the result is a fixed point
10:15:58 <shepheb> clearly not.
10:16:00 <byorgey> mikeX: you can also just 'print list'
10:16:04 <desegnis_> mikeX: print?
10:16:06 <sclv> and i think ppl also use corecursion to mean generators/yield
10:16:08 <Zao> @src mapM
10:16:08 <lambdabot> mapM f as = sequence (map f as)
10:16:10 <byorgey> mikeX: which is the same as 'putStrLn $ show list'
10:16:41 <byorgey> mikeX: putStrLn expects a String as its argument, so if you want to print out something which is not a String, you must call 'show' on it first to convert to a String.
10:16:57 <byorgey> 'print' does this for you automatically.
10:17:00 * shepheb has a little "business" to discuss with his ISP behind the building.
10:17:08 <mikeX> thankks a lot Zao, byorgey
10:17:51 <shepheb> anyway, the impression I had at first was that fix (^2) would produce 0 or 1, which satisfy f(x) = x. but that's not it at all.
10:18:22 <shepheb> s/would/should/
10:18:31 <byorgey> shepheb: yup, right.
10:18:59 <Baughn> shepheb: It might, with the right representation of Num. Try list-based. ;)
10:19:24 <Baughn> ..I don't think it /would/, without some serious twisting, but it could
10:19:29 <shepheb> it was the container-holding-another-instance-of-itself thing from Bananas et al on Tuesday that made it click.
10:20:05 <shepheb> Baughn: you know someone's going to demonstrate such a Num
10:21:03 <Baughn> shepheb: But of course
10:21:18 <shepheb> well, if your Num instance is binary digits, LSB-first, in lists
10:21:28 <shepheb> fix (^2) should find 0 as a fixpoint.
10:21:39 <shepheb> (if you're truncating the lists to, say, 32 bits)
10:21:49 <Baughn> Hm. I wonder.
10:22:07 <Baughn> Anyhow. Fix is named because the result is a fixed point, not because it finds fixed points.
10:22:31 <shepheb> I think that's the crucial piece I was missing, pre-Tuesday.
10:22:36 <byorgey> of course, undefined is also a fixpoint of (^2)  =)
10:22:52 <Baughn> > fix (^2) -- Yes, and fix rightly returns bottom. So there.
10:22:53 <lambdabot>  Exception: <<loop>>
10:23:03 <shepheb> I'm actually a little disappointed that undefined isn't actually written _|_
10:23:28 <lament> me too!
10:23:29 <dons> some libraries define it that way
10:23:47 <dons> _L
10:23:47 <byorgey> oh, hehe
10:23:56 <byorgey> I was going to say that _|_ isn't even valid Haskell syntax, but _L works =)
10:24:04 <lament> _L looks ugley
10:24:14 <glen_quagmire> > let _L = 1 in _L
10:24:15 <lambdabot>  1
10:24:16 <lament> i would not guess it was bottom
10:24:22 <desegnis_> Now try and explain why undefined isn't the least defined fix point of many functions, _un_defined is certainly little defined? Stupid terminology :)
10:24:24 <glen_quagmire> w00t didn't know variables can start with _
10:24:24 <byorgey> of course, if Haskell supported Unicode in identifier names...
10:24:34 <dons> which it does.
10:24:43 <byorgey> desegnis_: because it isn't a fix point of some functions.
10:24:51 <Peaker> If _ can bit in types and variables, does the case sensitivity apply to the first letter? What if its "_1"?
10:24:55 <shepheb> > unsafePerformIO $ launchMissiles myBloodyISP   -- I don't care if it happens more than once! in fact, I hope it does!
10:24:56 <lambdabot>   Not in scope: `myBloodyISP'
10:25:00 <byorgey> undefined is certainly the least defined fixpoint of any function for which it *is* a fixpoint.
10:25:01 <Saizan> the point is that fix finds the *least* fixed point, where least is intended in the order of definedness where forall x. _|_ <= x, and so it's calculated ad f^{\inf}(_|_)
10:25:07 <Saizan> *as
10:25:07 <glen_quagmire> > let  = 1 in 
10:25:07 <lambdabot>  Illegal character ''\152''
10:25:07 <lambdabot>  at "" (column 6)
10:25:09 <shepheb> :t launchMissiles
10:25:10 <lambdabot> Not in scope: `launchMissiles'
10:25:10 <Baughn> shepheb: It might not happen at all
10:25:16 <shepheb> aww, it seemed like it might be
10:25:19 <byorgey> shepheb: hehe
10:25:23 <desegnis_> byorgey, ah ok
10:25:30 <Baughn> shepheb: Worse, it mignt happen in two years, after someone new has moved in
10:25:58 * shepheb learns his lesson. unsafePerformIO is not to be used, even for spite.
10:26:14 <byorgey> desegnis_: for example, (1:), when given undefined as input, produces 1:undefined, so undefined is not a fixpoint of (1:)
10:26:17 <lament> > unsafePerformIO $ return 42
10:26:17 <lambdabot>   Not in scope: `unsafePerformIO'
10:26:24 <lament> hey! :D
10:26:42 <shepheb> wow, the only part of my fake call that really existed was ($)
10:26:59 <lament> > let unsafePerformIO = head in unsafePerformIO $ return 42
10:26:59 <lambdabot>  42
10:27:04 <lament> win!
10:27:05 <Baughn> > let launchMissiles = "boom" in launchMissiles
10:27:05 <lambdabot>  "boom"
10:27:16 <desegnis_> byorgey, thanks, makes sense now
10:27:39 <shepheb> > let launchMissiles = "boom" in iterate (const launchMissiles)
10:27:40 <lambdabot>  <[Char] -> [[Char]]>
10:27:50 <shepheb> ?
10:27:58 <glen_quagmire> > let a :: b = (a :: Int) + fromIntegral b in 1 :: 1.0
10:27:58 <lambdabot>  Parse error at "=" (column 12)
10:28:02 <shepheb> oh, my bad
10:28:12 <shepheb> > let launchMissiles = "boom" in iterate (const launchMissiles) "take this!"
10:28:13 <lambdabot>  ["take this!","boom","boom","boom","boom","boom","boom","boom","boom","boom"...
10:29:37 <byorgey> > "take this!" : fix (:"boom")
10:29:37 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
10:29:50 <byorgey> > "take this!" : fix ("boom":)  -- err, oops
10:29:50 <lambdabot>  ["take this!","boom","boom","boom","boom","boom","boom","boom","boom","boom"...
10:29:51 <monochrom> <3 haskell and #haskell
10:30:15 <MyCatVerbs> > concat it
10:30:15 <lambdabot>   Not in scope: `it'
10:30:26 <MyCatVerbs> Ah well,
10:30:46 <byorgey> hm, that would be nifty to have 'it' available in \bot =)
10:30:51 <MyCatVerbs> Also, is it just me, or is the Cont monad just like the Identity monad, with but the option of early exit?
10:31:05 <byorgey> it's probably impossible for various technical and security-related reasons, but I can always dream =)
10:31:12 <MyCatVerbs> Or have I missed some important part of its semantics?
10:31:26 <shepheb> is there a compelling reason to go straight to grad school after my undergrad? I've been waffling for the last three years. it's a little late now, maybe (graduate 2010). I'll probably end up coming back after some years if I do end up doing grad school.
10:32:00 <byorgey> shepheb: what do you mean, it's a little late now?
10:32:19 <Baughn> shepheb: If you start working, most people make themselves a lifestyle that won't let them go back to studying
10:32:54 <byorgey> I don't think that's a compelling argument though, that's a conscious choice you can make
10:32:59 <shepheb> well, I know very little about what it takes for applications to grad school. it seems like my about-to-graduate musicology friend has been at it for ages.
10:33:14 <shepheb> well more than a year.
10:33:23 <dons> ndm uploaded yhc-core to hackage
10:33:23 <monochrom> Once you marry and have kids, it's hard to switch.
10:33:25 <dons> very intersting
10:33:26 <byorgey> more than a year!?
10:33:30 <Jedai> MyCatVerbs: The cont monad allows you to create unrestricted control structures, in other words, it allows you to use goto safely in the scope of the monad (ok, it's continuation, not goto with its semantics problems...)
10:33:58 <Jedai> MyCatVerbs: Do you understand what a continuation is ?
10:34:12 <byorgey> shepheb: for starting graduate school in the fall of year X, you probably need to start working on applications in the fall of (X-1)
10:34:29 <monochrom> I know someone who have a family.  He went back to academia for a while, but it was very tough.  Both money and time.
10:34:35 <byorgey> shepheb: in the US at least, most application deadlines are around Dec 15 or Dec 31 or Jan 15 or something like that
10:35:11 <MyCatVerbs> Jedai: the fuuuuuuutuuuuuuure!
10:35:21 <byorgey> shepheb: anyway, I am heading back to grad school this fall after 4 years out of undergrad, and I don't regret not going earlier
10:35:24 <shepheb> well, I believe the Canadian system is similar. we'll see. I don't plan on the whole family thing, but I'm a few months from 21 and almost no one is planning on a family then.
10:35:25 <MyCatVerbs> Jedai: yes, I understand what call/cc does in the context of scheme. :)
10:35:31 <Jedai> MyCatVerbs: One future anyway :-)
10:35:41 <MyCatVerbs> Ah, yes. *A* future.
10:35:59 <monochrom> Another factor to consider, even without family: Many friends tell me that after working for a while, reading academic books and papers becomes hard to their minds.  So, if you switch, expect to take a long while to re-adjust.
10:36:23 <Jedai> MyCatVerbs: Well the Cont monad allows you to do the same as call/cc but in the scope of the monad
10:36:45 <lament> also, smoking pot makes you dumb so don't do it too much.
10:36:48 <byorgey> monochrom: that was actually the opposite of my experience, but that's probably due to the fact that I have an extremely boring job.  So I've had lots of extra time and energy to read academic stuff.
10:37:37 <shepheb> byorgey: hear, hear! I read Bananas etc. because my boss was out for the day and I was in between-project limbo.
10:37:49 <monochrom> My sister has worked for some years and now going to grad school.  Actually she keeps her day job too.  Fortunately she is single.  Somehow she manages both well, but I see that she sleeps little.
10:37:52 <byorgey> hehe, awesome =)
10:38:03 <MyCatVerbs> Jedai: aight, so like call/cc but it can't escape.
10:38:16 <monochrom> Yes, boring job helps.
10:38:36 <shepheb> Haskell is keeping my brain supple between school terms
10:38:59 <Jedai> MyCatVerbs: Yes, you can't escape the monad (unrestricted call/cc has some dangerous effects on a language semantics)
10:39:01 <MyCatVerbs> Jedai: does ContT IO give you effectively something that can be abused with semantics just like Scheme's call/cc?
10:39:10 <desegnis_> Boring job helps only if it won't make your mind bend down
10:39:17 <byorgey> shepheb: hm, I should go back and reread that paper, actually, I think I would get a lot more out of it now than I did a year ago... =)
10:39:24 <Jedai> MyCatVerbs: Probably, but that's ok since you're in IO
10:39:38 <MyCatVerbs> Jedai: hehehe, fun times ahead.
10:40:07 <shepheb> I need to check my notebook from last summer's term and find "Haskell Day", the day I said "I'm in limbo at work and bored. Let's learn a new language." and looked into Haskell.
10:40:16 <MyCatVerbs> Jedai: just how freely can I hop about in Cont, anyway? I know you can use continuations for early exit from some subexpression, but anything else?
10:40:48 <MyCatVerbs> Jedai: I'm not actually quite clear on this point: you can write goto-alike loops using Cont, right?
10:40:50 <lament> shepheb: haha
10:40:54 <lament> shepheb: the story of my life
10:41:16 <Jedai> MyCatVerbs: Right
10:41:18 <shepheb> MyCatVerbs: elaborate higher-dimensional topologies for control-flow. linear is passe'
10:41:26 <byorgey> shepheb: and after that, everything changed... =)
10:42:32 <byorgey> MyCatVerbs: you can use Cont for time travel, and reading other computers' memory, actually
10:42:51 <byorgey> Oleg showed how to do this, let me see if I can find the article...
10:44:39 <shepheb> byorgey: I can't even really comprehend the difference. I find it almost hard to believe that I was a _good_ programmer before. I understood so little.
10:45:29 <byorgey> shepheb: hehe, I know exactly what you mean!
10:45:33 <MyCatVerbs> byorgey: heh. Sure, but the paper he'll actually *publish* is the one on doing it in the type system instead. ;)
10:45:50 <byorgey> MyCatVerbs: hehe, of course =)
10:46:06 <shepheb> time travel in Cont involves passing on a closure holding the current call's state?
10:46:50 <MyCatVerbs> @src mfail Cont
10:46:50 <lambdabot> Source not found. You type like i drive.
10:47:09 <Peaker> there is a saying: "With time travel and genetic engineering, ANYTHING is possible" :)
10:48:23 <MyCatVerbs> oO
10:48:26 <byorgey> shepheb: that, and a flux capacitor
10:48:38 <s710b> @faq What about  time travel and genetic engineering?
10:48:38 <lambdabot> The answer is: Yes! Haskell can do that.
10:49:07 * shepheb tunes the dilithium matrix.
10:49:17 <MyCatVerbs> How the Heck can callCC have type (((a -> m b) -> m a) -> m a)? Shouldn't it be something like (((a -> m a) -> m a) -> m a) or (((a -> m b) -> m a) -> m b)?
10:49:42 <MyCatVerbs> There's a type variable in there that just... disappears. And yet that unifies?
10:50:04 <Riastradh> The type is correct.
10:50:17 * MyCatVerbs is confused.
10:51:08 <Peaker> I guess callCC takes a function that knows how to make an "m b" "disappear" into an "m a", and does not care how its done, or if b and a are same
10:51:14 <Riastradh> The `escape procedure' passed to f in `callCC f' will yield an action that does not actually deliver a value to its own continuation, so it can accept a continuation no matter what type that continuation expects.
10:51:37 <mrd> it's like peirce's law
10:54:14 <MyCatVerbs> Riastradh: so, as far as the types are concerned, it's analogous to abuse of (return undefined) in: if predicate then hPutStrLn stderr "Poo!" else return undefined ?
10:58:58 * shepheb accelerates to 90 lambdas per hour and makes a hard Left
10:59:22 <MyCatVerbs> Look out for the stacks.
11:01:49 <lament> the monadic tunneling post looks interesting
11:02:38 * dons thinks quicksilver should get a blog
11:03:01 * shepheb read that as "get a job"
11:03:26 <lament> "get a blog, sheesh!"
11:03:37 <shepheb> "get a haircut, and get a real blog!"
11:04:19 * resiak thinks dons should twitter more
11:05:59 <dons> if lambdabot was connected to twitter, i might
11:06:03 <dolio> @seen quicksilver
11:06:03 <lambdabot> quicksilver is in #haskell-soc, #ghc and #haskell. I last heard quicksilver speak 1h 4m 4s ago.
11:08:10 <dolio> @tell quicksilver ST in Agda2. No unsafe coerce. http://hpaste.org/6802
11:08:10 <lambdabot> Consider it noted.
11:08:59 <gnuvince> > "hello" `isInfixOf` "hello world"
11:09:04 <lambdabot>  True
11:13:15 <Saizan> dolio: a good tutorial for Agda2?
11:13:50 <dolio> http://appserv.cs.chalmers.se/users/ulfn/wiki/agda.php?n=Main.TypesSummerSchool2007
11:13:53 <lambdabot> Title: 28 The Agda Wiki - Types Summer School 2007 4b, http://tinyurl.com/yuktth
11:14:00 <dolio> Following those exercises is pretty good, I'd say.
11:14:37 <dolio> If you follow the link to the main page of that wiki, there's links to a little more documentation to get started.
11:15:04 <dolio> It's all a bit sparse, though.
11:15:18 <MyCatVerbs> > all ((flip isInfixOf) "assume") ["ass","u","me"]
11:15:20 <lambdabot>  True
11:17:04 <Saizan> dolio: yes, i see, thanks! do you reccomend to get a stable release or pull from the darcs repo?
11:17:30 <dolio> darcs, because the stable release never built for me. :)
11:19:27 <Saizan> a strong reason :)
11:20:59 <glen_quagmire> how can darcs code hosted on darcs?
11:22:41 <byorgey> glen_quagmire: why not?
11:22:50 <byorgey> after all, ghc can compile ghc =)
11:23:52 <glen_quagmire> in the beginning, it gets hairy. "oh i can't code without repository. i have this great idea of distributed code repository... how should I start the project :("
11:24:30 <byorgey> well, yes, you start working using some other repo software, and then eventually move to self-hosting.
11:25:01 <sclv> any ideas why uncommenting the type signature breaks stuff?
11:25:01 <sclv> http://hpaste.org/6801#a1
11:25:59 <oklopol> byorgey: but what about the very first one?!?!?
11:26:15 <glen_quagmire> software development does build layer by layer
11:26:22 <Saizan> sclv: which error do you get?
11:26:23 <byorgey> oklopol: that one sprang fully formed from the head of Zeus.
11:26:23 <Lemmih> sclv: Are you sure the type is correct?
11:26:38 <sclv> its what I get from ghci...
11:26:40 <dons> sclv: infer the type in ghci, then compare?
11:26:43 <oklopol> :D
11:26:44 <dons> oh
11:27:10 <Saizan> oh, well, it's not always possible to use the type ghci infers
11:27:11 <byorgey> oklopol: the actual truth is probably no less impressive =)
11:27:53 <oklopol> i'm sticking with zeus
11:28:00 <oklopol> :)
11:28:07 <MyCatVerbs> oklopol: you pass patches around by hand on mailing lists?
11:28:15 <sclv> I get, e.g. "    Could not deduce (TupleUp ctx1 a1 Dynamic) from the context (TupleUp                          ctx2 a (String, ValidationFunc s String Dynamic), TupleUp ctx11 a1 Dynamic)"
11:28:29 <Saizan> sclv: the problm is that ctx and ctx1 don't appear in the body of the type and there's not fundep with them as targets, so they can't be connected to the actual type they are going to be instanced to
11:29:05 <sclv> ah -- that makes sense.
11:30:10 <sclv> i added the missing fundep and it works now!
11:30:18 <Saizan> yay :)
11:40:18 <takamu> hi
11:42:23 <byorgey> hi takamu
11:47:06 <gwern> so, I've been thinking. what would y'all make of a revamped import syntax? where instead of going 'import foo; import bar; import baz', you could write 'import foo\n        bar\n       baz\n' and so on? (if you follow, it'd be kind of like do syntax)
11:47:59 <Saizan> gwern: add something for subtrees too
11:48:05 <dons> import Foo, Bar, Baz would make me happy
11:48:22 <prb> gwern: Doesn't tickle me.
11:48:29 <prb> gwern: Doesn't not tickle me.
11:48:51 <gwern> prb: that's, uh, a ringing endorsement of 'meh'?
11:49:34 <gwern> dons: well, what about long module names? you wouldn't be able to do much in 80 columns if list were all you had, unless you mean you could indent parts of the list...?
11:49:58 <prb> gwern: Exactly.  Just saying that it's not something that I'd spend time on.  If it makes documentation any more complex, then it's a net loss.
11:50:21 <glen_quagmire> yay my let* works!!!!!! this feels manlier than making monad transformer work, which makes me feel manlier than to successfully compile parser written with C++ Boost.Spirit
11:50:33 <gwern> prb: hm. what do you mean by more complex docs?
11:50:41 <monochrom> I want imports to be allowed anywhere in the source file.
11:51:00 <prb> gwern: If it makes the documentation of the file format more complex.
11:51:22 <dons> import System.* would be more useful, I think
11:51:25 <dmwit> I want to control import/export of classes and instances.
11:51:42 <gwern> prb: oh, you mean if it made the grammar of the import section more complex?
11:51:48 <prb> dons: That is known to be evil in the Java world.
11:51:53 <prb> gwern: Yes.
11:52:10 <desegnis_> monochrom, that would be convenient for hacking, but tedious for reading
11:52:11 <gwern> dons: well, but as I understand it, that's asking for trouble - if .*, why not .*Lazy?
11:52:27 <gwern> and at that point, I suppose you'd be better off with a full ML module system? or something?
11:52:32 * sjanssen envisions major problems with import System.*
11:52:53 <gwern> (if you allow a few basic regexps/shortcuts, why not all of them? slippery slope)
11:53:04 <sjanssen> what happens when somebody adds a new module in that hierarchy?
11:53:18 <unenough> manlier?
11:53:21 <dmwit> Also nice would be import qualified Data.Map (member as elem) as M
11:53:42 <dmwit> -- so that: M.elem -> Data.Map.member
11:53:54 <desegnis_> also, aren't type signatures in import lists on some agenda?
11:54:02 <gwern> dmwit: yeah, I've noticed that, but I assumed I was simply messing up the syntax for qualified partial imports - you mean qualified has to import everything?
11:54:05 <unenough> dmwit, why is that neccesary?
11:54:11 <sjanssen> desegnis_: why would you want that?
11:54:25 <dmwit> gwern: No, I mean, the feature I want is to rename imported functions.
11:54:47 <dmwit> unenough: Well, for one thing, avoiding name clashes without qualification would be nice.
11:54:52 <unenough> is that a "typing shortcut" or does it make some semantic difference
11:55:04 <desegnis_> sjanssen: Maybe if you reexport the function, it's handy to document its type. Although you may simply put the type signature somewhere else, of course
11:55:10 <dmwit> unenough: There is a semantic difference: M.member would not exist.
11:55:31 <dmwit> unenough: (And analogously for non-qualified imports.)
11:55:33 <gwern> dmwit: ah, I see. interestingly enough, I vaguely recall doing something similar once with common lisp macros
11:55:58 <desegnis_> sjanssen, ah sorry, typo, I meant export lists
11:56:01 <unenough> dmwit, what name clashes? i'm a haskell newbie so you'll have to explain (if you wish)
11:56:25 <dmwit> unenough: Well, for example, Control.Applicative.pure and Control.Arrow.pure.
11:56:53 <EvilTerran> Applicative.many and Parsec.many
11:57:13 <glen_quagmire> > many 1
11:57:14 <unenough> dmwit, but don't you just import Applicative and Arrow from Control
11:57:15 <lambdabot>   add an instance declaration for (Num (f a))
11:57:17 <dmwit> It's not a great example, since you can import Control.Arrow hiding (pure) and not really use anything.
11:57:22 <dmwit> But you get the idea.
11:57:26 <unenough> and go Arrow.pure or Applicative.pure
11:57:27 <monochrom> I vote against "import X.*" too.  This is not because of any "evil" reasons.  This is purely a pragmatic reason.  In Java, "import X.*" is useful because their libraries are organized so that "X.*" are closely related.  In Haskell, "import X.*" is unneeded because our libraries are organized so that stuff under "X.*" are loosely related.
11:57:49 <dmwit> unenough: Yes.  But sometimes a better name is more readable than a qualified name.
11:57:49 <sjanssen> import Data.* -- :P
11:58:10 <sjanssen> desegnis_: ah, now that makes more sense
11:58:21 <unenough> dmwit, I see this as another by-product of working with textual editors
11:58:30 <TheLorax> I'm trying to create an alternating serise...[-1,1,-1,1,-1,1..] I tried alt = 1 : negate alt but that's not working.
11:58:31 <shepheb> java import java.util.* or whatever doesn't import things you don't use, though
11:58:33 <unenough> it's just a matter of a few characters on the screen
11:58:55 <dmwit> unenough: ...you have to have a name for it if you want to work with it conveniently.
11:59:00 <sjanssen> personally, I'd adopt something like import {Data.List, System.IO}
11:59:01 <Deewiant> > concat $ repeat [-1,1]
11:59:02 <lambdabot>  [-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,...
11:59:11 <dmwit> unenough: That's not restricted to textual editors.
11:59:12 <desegnis_> > let alt = 1 : map negate alt in alt
11:59:12 <sjanssen> and allow import System.{IO, Env}
11:59:12 <lambdabot>  [1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,...
11:59:14 <unenough> dmwit, only because you have to type that name and see the full qualified name
11:59:31 <desegnis_> > cycle [1,-1]
11:59:32 <lambdabot>  [1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,...
11:59:44 <TheLorax> thanks Deewinant and desegnis_
11:59:49 <Deewiant> ah, 'cycle'. I wondered what it was called. :-)
11:59:57 <unenough> if you could represent the full qualified name in a friendly, compact way and if you didn't have to type the whole name every time, then it wouldn't require changes to the language to make it convenient
12:00:14 <dmwit> > [(-1)^n | n <- [0..]]
12:00:15 <lambdabot>  [1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,...
12:00:20 <desegnis_> TheLorax, at least the last one will be a "true" cyclic linked list in run time
12:00:33 <desegnis_> TheLorax, the last one being cycle
12:00:39 <Deewiant> @src cycle
12:00:39 <lambdabot> cycle [] = undefined
12:00:39 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
12:01:18 <dmwit> desegnis_: Does this mean that cycle [expensive, expensive'] is actually quite efficient?
12:02:03 <Saizan> dmwit: those will be computed only once, yes
12:02:32 <desegnis_> oh, that's the case for (concat . repeat) too
12:02:43 <dmwit> It's always nice when things that can be fast are.
12:03:53 <Saizan> desegnis_: right, buut concat . repeat doesn't share cons cells
12:04:00 <desegnis_> dmwit, the point of the cyclic list is that unfolding the list is actually quite efficient, because there are only two pointers (one for 1, one for -1)
12:04:28 <dmwit> right
12:04:58 <desegnis_> Saizan, since I'm never sure about terminology: Did you address the same issue as I did?
12:05:54 <dmwit> yes
12:06:25 <desegnis_> ok :)
12:09:22 <glen_quagmire> can I help you with haskell? i'm getting good at it.
12:17:02 <int80_h> hey guys
12:18:01 <dmwit> Hiya, int80_h!
12:18:07 <dmwit> Haven't seen you in a while.
12:18:28 <int80_h> I'm the guy who has been going buggy over installing the latest stable of ghc, on haskell cafe
12:18:48 <int80_h> oh yeah, I have found my True Role in the haskell community. Tech Writer!
12:19:16 <dmwit> AWEsome!
12:19:30 <int80_h> I've taken on documenting happs, but I'm stuck on installing the rtight ghc right now. it's all on haskell-cafe right now
12:19:33 <dmwit> GHC is a huge program, is that what you're tech writing for?
12:19:46 <int80_h> no, for happs, but I need the right ghc for it
12:19:48 <dmwit> Oooh, happs, that needs a lot of docs, too. =)
12:20:10 <int80_h> sure does. soeone gave me a spec. now if I can just solve this current problem
12:20:23 <int80_h> I'll just write to the spec
12:20:45 <int80_h> do you think I should paste my problem on hpaste?
12:20:56 <gxng> hey all...im takn haskell in my course and finals are coming soon n dunno almost neting lol
12:20:58 <int80_h> I didn't want to duplcate if I didn't have to
12:21:32 <Lemmih> int80_h: I don't subscribe to haskell-cafe.
12:21:44 <dmwit> http://www.haskell.org/pipermail/haskell-cafe/2008-April/041270.html
12:21:46 <lambdabot> Title: [Haskell-cafe] installing ghc-6.8.2, http://tinyurl.com/35d6y3
12:21:48 <dmwit> I'm guessing it's that thread.
12:21:48 <int80_h> ah, well then I'll head to hpaste then.
12:22:13 <dmwit> gxng: May I humbly suggest a tutorial, then?
12:22:14 <unenough> is haskell ever gonna have a normal packaging system?
12:22:14 <int80_h> well I started a new thread, let me verify
12:22:20 <dmwit> ?learn
12:22:20 <lambdabot> http://www.haskell.org/learning.html
12:22:23 <unenough> (something like apt-get) ?
12:22:29 <gxng> been reading them for awhile...lol
12:22:48 <dmwit> gxng: Cool!  Do you have any specific questions about Haskell?
12:22:59 <gxng> ya...Y? lol j/k
12:23:04 <dmwit> unenough: cabal-install ?
12:23:09 <int80_h> dmwit, I started a new thread "trying to install ghc-6.8.2
12:23:34 <gxng> its funny my prof is agaisnt all languages n doing only haskell cuz its just barely irks his nerves...weird
12:23:42 <int80_h> I'll post it on hpaste, see if I can get something going here
12:23:52 <unenough> dmwit, yea, but it's not ready yet, right?
12:24:05 <gxng> im assumn some of u ppls are haskell gurus?
12:24:23 <dmwit> unenough: Right, but you asked if we'd ever have something.  I think the answer is probably "yes." =)
12:24:39 <unenough> great! because it's such a headache
12:24:52 <unenough> it should be easy as apt-get install  or dpkg-buildpackage
12:25:08 <gxng> mabye cuz ive been corrupted with imperative progrm. but well feel much comfortable with dat side of paradigm than haskell types
12:26:04 <Saizan> int80_h: have you tried the static-linked binary?
12:26:17 <gxng> any1 know neting about transactional/concurrency and stuff like atomic transactions?
12:26:52 <dmwit> int80_h: pwd is trying to make a timer? (?)
12:27:10 <dmwit> Saizan: Yes, apparently that doesn't even make it past configure.
12:27:31 <gxng> o and dis is besides haskell but neways...which u prefer mirc or dis mibbit irc web version?
12:28:08 <dmwit> gxng: Yes, there are people here who know about transactional memory and concurrency.  You should just go ahead and ask your question.
12:28:49 <unenough> prefferable with more consonants and vowels
12:29:01 <unenough> never mind, i can't spell
12:29:14 <unenough> :P
12:29:50 <gxng> this is what my last assignment must implement...:Let us add state to Haskell by defining a recursive type for a _mutable_ data
12:30:10 <gxng> structure that can be acted on by Haskell transactions.  (Actually, these are
12:30:15 <int80_h> dmwit, I have no idea what his version of pwd is trying to do
12:30:22 <gxng> Haskell++ transactional functions---so not even the latest GHC will compile
12:30:37 <gxng> them).
12:30:41 <int80_h> I tried replacing it with the standard pwd, and the same timer problem bit me in the back later on
12:31:10 <byorgey> what's Haskell++ ?
12:31:19 * dmwit guesses it is made up
12:31:22 <gxng> it's my prof's version of haskell++ :P
12:31:32 <byorgey> that's what I was afraid of =)
12:31:46 <gxng> nuts
12:31:58 <dmwit> int80_h: How old is the system you're installing on? =P
12:32:05 <gxng> We define a mutable binary search tree, suitable for state updating by
12:32:10 <byorgey> gxng: out of curiosity, who is your prof?
12:32:16 <int80_h> how old? I dunno. want the uname specs?
12:32:18 <gxng> concurrent 'insert' instructions; we leave concurrent 'delete' for later.
12:32:29 <int80_h> this isn't my machine. I'm just a user there
12:32:30 <tromp> shldnt that be readIORef Haskell >>= writeIORef Haskell ?
12:32:36 <gxng>   mutableData Tree = Empty | Root {string :: String} {count :: Integer}
12:32:41 <int80_h> believe me I wouldn't be running debian if it were my machine
12:32:45 <tromp> shldnt that be readIORef Haskell >>= writeIORef Haskell . (+1) ?
12:32:48 <gxng> {left :: Tree} {right :: Tree}
12:32:53 * int80_h ducks coming OS holy war
12:33:14 <gxng> any1 got an idea what i'm posting? lol
12:33:27 <shepheb> int80_h: actually, the mood here is usually "if it runs GHC, whatever."
12:33:53 <int80_h> well debian etch only has 6.6 packaged. grrr.
12:33:56 <dmwit> int80_h: Maybe you have to ./configure --prefix=$HOME --user?
12:34:02 <gxng> my prof is David Probst @ Concordia University in montreal, canada
12:34:07 * int80_h wonders if he will be the schmuck to package the lates stable
12:34:07 <dmwit> int80_h: It may be assuming you have some root powers...
12:34:18 <byorgey> gxng: if you have a more specific question someone could probably help you.  But 'mutableData' is not standard Haskell, I don't think anyone here knows anything about this 'Haskell++'
12:34:19 <tromp> modifyIORef haskell (+1)
12:34:22 <byorgey> although I could be wrong
12:34:23 <dmwit> int80_h: I could also be thinking of cabal.
12:34:31 <int80_h> I did that dmwit. it's going up on hpaste soon
12:34:34 <gxng> damn...i knew my prof is kinda nuts:P
12:34:46 <allbery_b> modify (+1) :: State Hashell
12:34:51 <allbery_b> modify (+1) :: State Haskell
12:35:17 <monochrom> Num Haskell ?
12:35:17 <gxng> o well...at least i asked lol
12:35:22 <dmwit> gxng: Nothing you posted is inherently impossible in current Haskell, I wonder what your prof is on about?
12:35:38 * EvilTerran notes that a haskell shell would almost certainly be called "hash"
12:35:44 <dmwit> gxng: (Just a bit of wrong syntax, but easily fixable, it seems.)
12:36:02 <tromp> cld be hashell
12:36:04 <gxng> he is trying to implement transactional actions in that regard i think that simon P J hasnt done yet
12:36:18 <dmwit> gxng: Also, I haven't seen an actual question yet, so I'm not sure what you want us to say. =P
12:36:27 <gxng> uh...wah i posted is the exact quote from assignment lol
12:36:53 * EvilTerran notes that "lol" is not a piece of punctuation
12:37:17 <Japsu> s/lol/desu/
12:37:26 <EvilTerran> s/desu/RON PAUL/
12:37:40 <gxng> lets just forget about it..since my prof is nutty..but then again he claims dat the future of multicore programming must use fuctional programming and wintel are finally gettn to do something in that regards...:P
12:38:06 <monochrom> I think exams are evil.
12:38:10 <gxng> hopefully he isnt here to read wah I wrote lol
12:38:29 <gxng> o well
12:38:36 <monochrom> Good academic people don't mind being called nuts.
12:38:53 <EvilTerran> monochrom, a popular opinion of exams amoung students, that
12:39:03 <gxng> i am sure most 'normal' programmers whos all imperative additcts prob tink functional programmers are nuts lol
12:40:03 <gxng> ya...ppls who label otehr ppls nuts do that out of ignorance...i heard that someplace
12:40:17 <monochrom> Or out of buddy jokes.
12:40:34 <shepheb> anyone recommend a good source for getting started with LaTeX?
12:40:48 <Cale> gxng: Actually, it very much seems that way to me as well -- that is, multicore programming does really look a good deal harder for imperative languages than pure ones.
12:40:49 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
12:40:49 <gxng> any1 seen that googletechtalk vid on youtube about them using haskell for apps on the Cell chip? seems coool
12:41:10 <monochrom> 99.9% of new ideas don't work out.  If every time you see a new idea you call it nuts, that's an extremely safe bet.
12:41:50 <monochrom> But a good innovator knows how to shoot down that 99.9% of his/her own bad ideas, or at least welcome colleagues to.
12:42:05 <gxng> well the way the industry is where most ppls use imperative programming i am sure itll take  an entire industry shift in mindset and tech education to shift from haskell language use in most apps then C++
12:42:26 <byorgey> shepheb: ctan.org, http://ctan.org/tex-archive/info/lshort/english/
12:42:29 <lambdabot> Title: CTAN: directory: /tex-archive/info/lshort/english
12:42:43 <int80_h> I wan't insane until I started delving into the Dark Arts known as functional programming.
12:43:08 <gxng> I thought living in quebec canada was insane..but neways lol
12:43:10 <durr> hmm what to do with two modules that depend on each other...
12:43:15 <conal> int80_h: or perhaps you were insane before and abnormal after
12:43:18 <int80_h> Hey my post got truncated. I'm just going to repost a link to the mailing-list entry
12:43:21 <Cale> gxng: There will perhaps be enough pressure to do that when everyone's applications won't use more than 1/80th or 1/40th of the available processing power in home computers.
12:43:41 <Cale> (and hence they need to parallelise)
12:44:24 <gxng> hmmm wonder if ne of u ppls done multicore parallel programmn with haskell
12:44:30 <monochrom> I have reservations about that, Cale.
12:44:35 <gxng> must b nuts
12:44:52 <Cale> gxng: Sure, it's actually pretty cool.
12:45:03 <gxng> wah kinda apps uve made?
12:45:20 <monochrom> I mean, I agree 87/88 of the capacity will be idle.  I don't agree that programmers or let's say big software companies care.
12:45:26 <gxng> they only follow the $ trail
12:45:58 <shepheb> depends on the app, I would think. game developers are more interested in harnessing everything they can, because it lowers the bar for people whose machines can run the game.
12:46:17 <monochrom> I mean this is regarding *home* users.  Server farms in industry are a different story, of course, and the big software companies care about that.
12:46:31 <Cale> gxng: Nothing too large -- I don't even have a multicore machine to run them on yet. But I've been interested in it, so I've been studying the kinds of abstractions that people are looking at.
12:46:35 <gxng> lol i read that valve software have been dev. new ways to program multicores but i am sure it aint wit haskell
12:47:08 <Cale> gxng: There's a really nice approach called nested data parallelism.
12:47:20 <Cale> gxng: (which will be in the next GHC, most likely)
12:47:21 <gxng> ive got 3 pc n its 3 intel pentium consequetive chips...p2/p3/p4 lol
12:47:38 <gxng> hmmm
12:47:50 <gxng> i just read someting regarding that yesterday on some site
12:48:20 <gxng> o i tink it was maybe either dat google vid iusing haaskell to program cell chip or someting
12:48:33 <Cale> Basically, the idea is that you write programs which use these special arrays, called parallel arrays, and the compiler/runtime automatically decides how to split up the work so that each processor gets a fair share.
12:48:50 <gxng> im assuming its with haskell
12:48:51 <Cale> gxng: Are you referring to the Coconut project?
12:49:18 <gxng> seems most of the languages thats used for the cell chip say is fortran/c or wahever as what i can tell from ibm's site
12:49:20 <monochrom> Dualization is an involution.  co-co-nut = nut.  <duck>
12:49:22 <gxng> o ya dat
12:49:25 <gxng> dats it
12:49:38 <gxng> i didnt actually watch da whole vid on youtube but neways
12:49:46 <Cale> gxng: I was involved with that one at the very beginning, I helped write some of the lower level stuff in their early on experiments (a pipeline scheduler for PPC/Altivec in Haskell)
12:50:02 <gxng> cool
12:50:03 <Cale> gxng: It's a neat project.
12:50:13 <gxng> must have been fun
12:50:14 <gxng> lol
12:50:27 <gxng> now if one can use haskell for say nasa n mission to mars
12:50:31 <gxng> now thatll be nice
12:50:56 <unenough> Cale, hey i've seen a presentation about something like that
12:51:04 <unenough> don't remember the name though
12:51:10 <gxng> lol theres a vid on youtube
12:51:11 <byorgey> gxng: oh, you haven't heard of the Virgle project?  They're using Haskell I think
12:51:17 <gxng> nope
12:51:21 <gxng> ima  newbie on dis language
12:51:23 <int80_h> did my hpaste get announced tohe room?
12:51:26 <smtms> "Realtime Haskell - coming to a nuclear facility near you" ;-)
12:51:26 <unenough> I mean a PPT presentation file
12:51:26 <int80_h> I don't see it
12:51:28 <Cale> Yeah. My scheduler was maybe 1200 lines (of which half was documentation), and according to my supervisor, who was an expert C programmer and understood what my scheduler was doing, would have easily been 50000 lines of C.
12:51:43 <byorgey> gxng: http://www.google.com/virgle/index.html
12:51:43 <lambdabot> Title: Virgle: The Adventure of Many Lifetimes
12:51:49 <gxng> haskell and nukes...i dont tink my prof was in on that idea lol
12:51:50 <Cale> Haskell can be pretty concise :)
12:51:59 <monochrom> int80_h: probably not.
12:52:10 <gxng> nice...
12:52:17 <unenough> Cale, well C is no comparison. We like to say here that a line of python is 10 lines of C
12:52:21 <unenough> (at least)
12:52:47 <gxng> lol well like everything in the universe..all can be broken down into math
12:52:49 <unenough> C is a low level language
12:52:54 <int80_h> okay well, for whatever reason it's not going into the room
12:52:55 <Cale> unenough: yeah, but this is almost another order of magnitude :)
12:53:10 <int80_h> if anyone wants to check out my ghc install woes, I would be very happy
12:53:10 <Cale> ~600 lines of real code vs. maybe 50000
12:53:16 <gxng> so when can we expect AI to be so advanced for robots and stuff to program themselves?
12:53:18 <gxng> lol
12:53:31 <monochrom> Tomorrow.
12:53:38 <int80_h> why can't a robot program itself now?
12:53:38 <gxng> nice... lol
12:53:57 <int80_h> if it has code with functions that return functions. there's your self programming right there
12:53:59 <Cale> The reason, I'm fairly sure is the extent to which I made use of laziness and a nondeterminism monad :)
12:54:22 <gxng> hmm i remember they used java to program their control interface giving commands to the mars rovers? forget
12:54:31 <monochrom> Yeah, if you need laziness, that's kind of cumbersome in C.
12:54:56 <gxng> i always found it funny ...monad...sounds like gonads..but hey..guess im ignorant eh? lol
12:55:11 <Cale> gxng: It's a portmanteau of monoid and triad.
12:55:22 <gxng> u lost me there
12:55:24 <gxng> lol
12:55:36 <Cale> That's okay, you don't have to know that to use them for programming :)
12:56:00 <gxng> so ur main language is haskell?
12:56:16 <theunixgeek> What theme is used in the screenshots here? http://www.haskell.org/gtk2hs/docs/tutorial/glade/
12:56:17 <lambdabot> Title: Gtk2Hs  Documentation  Glade Tutorial
12:56:30 <gxng> any1 try using haskell to make high perf., apps for the ps3? lol
12:56:33 <Cale> Yeah, if I was writing something for my own benefit these days, there would have to be a really good reason for me not to use Haskell.
12:57:39 <unenough> missing the H key
12:57:53 <gxng> o and i was wondering...is ATOMIC a keyword in haskell?
12:58:05 <Cale> gxng: No, but there's a function called atomically
12:58:14 <Cale> :t atomically
12:58:18 <lambdabot> Not in scope: `atomically'
12:58:23 <unenough> woops
12:58:24 <gxng> ok..my prof must be using it as a func. name for transactions
12:58:37 <Cale> :t Control.Concurrent.STM.atomically
12:58:38 <lambdabot> Couldn't find qualified module.
12:58:40 <Cale> hmm
12:58:52 <Cale> :t Control.Monad.STM.atomically
12:58:53 <lambdabot> Couldn't find qualified module.
12:58:58 <Cale> whaaa?
12:59:07 <gxng> funny how alot of his code from his notes dont even compile lol he doesnt even own a pc
12:59:08 <gxng> :P
12:59:09 <Cale> that's interesting
12:59:23 <Cale> :t GHC.Conc.atomically
12:59:24 <lambdabot> forall a. GHC.Conc.STM a -> IO a
12:59:26 <Cale> hmm
12:59:30 <Cale> So that one is there.
12:59:31 <gxng> says..human brain best compiler :P
12:59:38 <Cale> I wonder what happened to those other modules.
12:59:48 <unenough> he's like djikstra
12:59:52 <Cale> Oh, maybe no stm package.
12:59:58 <unenough> djikstra didn't own a computer for most of his life
12:59:59 <allbery_b> he's only allowed to say that if he's using MIX as the language :)
13:00:06 <gxng> damn haskell++:P
13:00:50 <jsnx> > let { list = [(1,'a'), (2,'b')] } in map (uncurry (flip (,))) list
13:00:52 <lambdabot>  [('a',1),('b',2)]
13:01:00 <gxng> huh
13:01:09 <int80_h> so, no takers on my ghc install problem eh?
13:01:23 <gxng> im using winhugss.. lol
13:01:51 <Cale> gxng: atomically takes an action in the STM monad (which is a monad which just allows you to read and write special memory cells called transactional variables, or TVars, but no other side effects), and runs it in the IO monad, and it occurs as if it happens thread-atomically.
13:01:51 <gxng> hmm guess da ol abacus cant match a cpu lol
13:02:03 <Cale> int80_h: what's the problem?
13:02:13 <int80_h> I've posted it Cale
13:02:19 <gxng> ok...
13:02:20 <Cale> On hpaste?
13:02:20 <int80_h> but I can say here
13:02:29 <int80_h> yeah, hpaste points tothe mailing list
13:02:43 <int80_h> because my first attempt to pasting got truncated
13:02:57 <gxng> i hope i wasnt the only newbie who had to rereread haskell tutorials to understand soemthing lol
13:03:00 <int80_h> I do have some new information
13:03:07 <Cale> First, do you absolutely have to compile GHC?
13:03:15 <Cale> What platform are you on?
13:03:20 <gxng> well thx for the chat...cya folks;)
13:03:23 <int80_h> no, if I can get these binaries to work I will
13:03:28 <Cale> gxng: see you around :)
13:03:28 <int80_h> whatever I can get to work
13:03:39 <int80_h> I'm using Debian Etch
13:03:55 <Cale> int80_h: I recommend the generic linux binaries.
13:04:03 <int80_h> let me give you the gcc I am using. Iinstalled another gcc withthe assumption the one installed was broken
13:04:10 <Cale> http://www.haskell.org/ghc/download_ghc_682.html#x86linux
13:04:10 <lambdabot> Title: GHC: Download version 6.8.2
13:04:17 <int80_h> Cale, those don't worj wither, my experience is documented.
13:04:26 <int80_h> either, even
13:05:13 <Cale> int80_h: What happen? Somebody set up us the bomb?
13:05:17 <jsnx> @hoogle ByteString
13:05:18 <lambdabot> Data.ByteString :: module
13:05:18 <lambdabot> Data.ByteString.ByteString :: data ByteString
13:05:18 <lambdabot> Data.ByteString.Internal.ByteString :: data ByteString
13:05:55 <int80_h> michael@schmong:~/Mail$ $HOME/bin/gcc -v
13:05:57 <int80_h> Reading specs from /home/michael/lib/gcc/i686-pc-linux-gnu/3.4.6/specs
13:05:59 <int80_h> Configured with: ../configure --prefix=/home/michael
13:06:01 <int80_h> Thread model: posix
13:06:03 <int80_h> gcc version 3.4.6
13:06:23 <int80_h> well here is the new information that has not been documented. It looks like a problem with a posix function
13:06:51 <Zao> At least the Solaris variant of GHC has issues with 3.x.
13:08:45 <int80_h> Cale, is that sufficient information?
13:10:08 <allbery_b> ghc/solaris(sparc) has a number of issues anyway
13:10:26 <int80_h> yeah I'm on x86 though
13:10:39 <int80_h> should I try and use gcc 4x? Ihad trouble compiling
13:12:41 <Cale> int80_h: hmm... what were your problems with the binary release of GHC?
13:12:45 <Zao> allbery_b: I'm painfully aware of that :)
13:12:56 <int80_h> hold on cale, I will look up exact errors
13:13:14 <Cale> checking for path to top of build tree... pwd: timer_create: Operation
13:13:14 <Cale> not supported
13:13:23 <Cale> (Is that it?)
13:14:30 <int80_h> ./configure --prefix=$HOME
13:14:30 <int80_h> checking build system type... i686-pc-linux-gnu
13:14:30 <int80_h> checking host system type... i686-pc-linux-gnu
13:14:30 <int80_h> checking target system type... i686-pc-linux-gnu
13:14:30 <int80_h> Which we'll further canonicalise into: i386-unknown-linux
13:14:30 <allbery_b> urgh, that one.  tripped over that too
13:14:30 <int80_h> checking for path to top of build tree... pwd: timer_create: Operation
13:14:32 <int80_h> not supported
13:14:34 <int80_h> configure: error: cannot determine current directory
13:14:50 <int80_h> soory, yes that is the problem
13:15:13 <int80_h> if we can get this binary working, I'm all for it
13:16:51 <Cale> hmm
13:17:08 <int80_h> I suspected my only choice was to compile
13:17:20 <allbery_b> that has a chicken and egg problem
13:17:46 <Cale> int80_h: Do you even have a working older version of GHC?
13:17:58 <allbery_b> (ok, you may be able to find working ghc binaries of some version for your platform)
13:18:01 <int80_h> Cale, yes I do. But it's not usable for happs
13:18:15 <int80_h> I need this one for happs
13:18:27 <int80_h> which I want to write docs for. if only I could install it
13:18:38 <int80_h> ghc, I mean
13:18:44 <Cale> yeah, this is strange...
13:20:04 <int80_h> would the number of the working version help?
13:20:19 <Cale> It's probably 6.6.1?
13:20:24 <int80_h> lemme check
13:20:46 <Saizan> there are deb of 6.8.2 somehwere
13:21:31 <int80_h> yeah 6.6.1
13:22:10 <Cale> I'm on Ubuntu, and they just pull the GHC packages from Debian, so I figured as much :)
13:22:18 <int80_h> saizan, please tell. my sys admin would install it if he new about it. we're running etch
13:22:23 <Cale> Interestingly enough, I've never had problems with timer_create
13:22:47 <Cale> (you'd think that Ubuntu and Debian would be pretty similar in that regard)
13:23:01 <int80_h> he says that 6.6 is what is in the repositories, and the ghc web page only has 6.6
13:23:18 <Saizan> int80_h: i was thinking of http://haskell-unsafe.alioth.debian.org/haskell-unsafe.html , but there's only one for amd64
13:23:24 <lambdabot> Title: Haskell Unsafe
13:24:04 <int80_h> hmm, can't use that
13:25:56 <Cale> On the building GHC yourself front, apparently Ian Lynagh at one point suggested adding the lines:
13:26:00 <Cale> SRC_HC_OPTS     = -fasm
13:26:00 <Cale> GhcStage1HcOpts = -fasm
13:26:08 <Cale> To mk/build.mk
13:26:23 <int80_h> that didnt't work
13:26:27 <int80_h> I tried it
13:26:37 <Cale> hmm
13:26:57 <int80_h> is there some other way to remove that option?
13:27:20 <Cale> I suppose you could grep for it. I have no idea what effect it has.
13:27:30 <dons> hackage will be down for 2 mins or so , in a few mins
13:28:39 <Cale> Oh, hmm, it sounds like the sort of thing which might actually be required...
13:28:46 <Cale> But I don't know.
13:29:47 * int80_h starts to despair
13:30:22 <int80_h> well, Ican stil install it on my local machine. Ijust won't be able to have my happs based blog until this gets fixed
13:30:42 <Cale> Etch is still using gcc 3.x?
13:31:03 <int80_h> unless, I can get an account somewhere. I thought it would be cool to document my work on happs documentation on a blog based on happs
13:31:14 <int80_h> cale, yeah
13:31:27 <Lemmih> int80_h: You can get an account on my box.
13:31:27 <int80_h> according to my sys admin. I'm no debian expert
13:31:34 <Cale> Well, that's one difference between our machines...
13:31:35 * int80_h hops up and down in joy
13:31:46 <Lemmih> int80_h: Mail me your public key.
13:31:47 <int80_h> lemmih, thanks!
13:32:01 <int80_h> um...no public key. stupid Iknow
13:32:13 <int80_h> okay Iwill see about making one
13:32:31 <Cale> It's pretty easy, if I remember correctly :)
13:32:41 <int80_h> I need gpg right?
13:32:57 <int80_h> lemmih, is your e-mail on haskell.org?
13:33:17 <allbery_b> I thought he meant ssh key
13:33:31 <allbery_b> being that he was talking about a machine account
13:33:39 <int80_h> oooh
13:33:39 <Lemmih> Right.
13:33:41 <Cale> Yeah, you just run ssh-keygen with some appropriate parameters.
13:33:49 <int80_h> I've totally forgotten how to make one of those
13:33:54 <int80_h> got it
13:34:18 <Cale> I forget what the appropriate encryption scheme which everyone expects you to use is though :)
13:35:10 <Cale> Probably dsa
13:36:22 <allbery_b> dsa these days
13:36:31 <int80_h> yeah Ijust made a dsa key
13:36:41 <int80_h> lemmih, where do I mail it?
13:36:43 <unenough> aes, no?
13:37:00 <Lemmih> int80_h: lemmih at gmail dot com
13:38:00 <Cale> unenough: Is AES a public key scheme?
13:38:33 <unenough> ahh...no
13:38:35 <unenough> sorry :(
13:38:40 <unenough> it's the replacement for DES
13:40:08 <bd_> hm, what's the recommended way to list a directory? There's System.Posix.Directory, but I'd rather a FilePath -> IO [FilePath] to the C-style loopy interface it gives
13:40:49 <Lemmih> bd_: System.Directory.getDirectoryContents?
13:40:58 <bos> @hoogle getDirectoryContents
13:40:59 <lambdabot> System.Directory.getDirectoryContents :: FilePath -> IO [FilePath]
13:41:12 <bos> @hoogle FilePath -> IO [FilePath]
13:41:12 <lambdabot> System.Directory.getDirectoryContents :: FilePath -> IO [FilePath]
13:41:15 <bd_> ... aha!
13:41:16 <bd_> thanks :)
13:41:17 <bos> well, there you go :-)
13:41:30 <bd_> I'm too tired to be doing this :)
13:41:33 <int80_h> lemmih did you get my pm?
13:41:47 <int80_h> thanks again :)
13:42:10 <int80_h> I'm going to take a nap. I've been working on this problem for about six hours :)
13:42:17 <Lemmih> int80_h: Thank you for looking at HAppS (:
13:42:26 <int80_h> I love happs :)
13:42:38 <int80_h> I'm excited about being able to make a meaningful contribution.
13:43:13 <int80_h> when it's time for me to turn pro, I'll have a portfolio I can be proud of.
13:43:15 <Cale> int80_h: It'll be interesting to see some documentation :)
13:43:23 <int80_h> someone gave me a spec
13:43:37 <int80_h> so I will try and write to the spec
13:43:43 <Cale> int80_h: I've not really looked at it very closely because there doesn't seem to be much documentation for it
13:43:56 <Cale> But it sounds cool what they're doing :)
13:44:22 <int80_h> I wouldn't be able to do squat without a spec.
13:45:50 <int80_h> okay I can't realy nap since my new account it pending
13:47:48 <int80_h> ooh
13:48:33 <bd_> @hoogle [(a,b)]->([a],[b])
13:48:34 <lambdabot> Prelude.unzip :: [(a, b)] -> ([a], [b])
13:48:34 <lambdabot> Data.List.unzip :: [(a, b)] -> ([a], [b])
14:01:45 <int80_h> I'm so happy top jhave a haskel friendly enviroment
14:05:29 <__pao__> @hoogle [a] -> [[a]]
14:05:29 <lambdabot> Data.List.inits :: [a] -> [[a]]
14:05:29 <lambdabot> Data.List.tails :: [a] -> [[a]]
14:05:29 <lambdabot> Data.List.group :: Eq a => [a] -> [[a]]
14:06:28 <__pao__> which is the best book for "advanced functional programming/advanced haskell"?
14:06:41 <opqdonut> hsoe is pretty good
14:07:10 <opqdonut> dunno how advanced it is, but it goes pretty deep into the large-scale structure and design of functional programs
14:07:22 <Lemmih> Craft of FP is also decent.
14:07:38 <__pao__> opqdonut: hsoe stands for...
14:07:55 <opqdonut> haskell school of expression
14:08:02 <opqdonut> craft of fp too yes
14:08:14 <opqdonut> and functional datastructures is a must-read
14:08:23 <opqdonut> ?where okasaki
14:08:23 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
14:08:27 <opqdonut> ^ that one
14:08:45 <MyCatVerbs> opqdonut: I read that as "craft of fp poo yes".
14:08:52 <opqdonut> :D
14:09:10 <__pao__> opqdonut: thanks
14:09:16 <__pao__> Lemmih: thanks
14:09:24 <__pao__> what about Hutton?
14:28:14 <elliottt_> sclv: is there a way to define a template that you can call with an argument in HStringTemplate?
14:29:54 <gwern> so I'm having a little trouble writing a fold; I want  ["foo", "bar", "baz"] -> (getEnv "foo" `catch` getEnv "bar" `catch` getEnv "baz)
14:30:10 <gwern> but writing a (\x -> catch (getEnv x)) doesn't seem to work
14:30:59 <gwern> :t catch
14:31:00 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
14:32:15 <MarcWeber> Do you prefer functions returning m result instead of Maybe result ? Because using m result you have a chance to pass an error message?
14:32:18 <gwern> so I was thinking the fold would become (catch (getEnv "foo) (catch (getEnv "bar") (catch (getEnv "baz")))) and I could then \_ -> return default"
14:32:34 <MarcWeber> m results is used by lookup (and Maybe is used by HTTP-Simple)
14:36:14 <gwern> (I could probably map (\x -> getEnv x `catch` \_ -> "") over the list and then dropUntil not == "", but that is inelegant, a downright hack, and inefficient)
14:37:39 <allbery_b> msum . map getEnv $ envNameList :)
14:38:16 <gwern> @hoogle msum -- what the heck is that?
14:38:16 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-- what th'
14:38:22 <TSC> monoid sum
14:38:38 <allbery_b> it uses the MonadPlus definition for IO
14:38:49 <allbery_b> @src IO mplus
14:38:49 <lambdabot> m `mplus` n = m `catch` \_ -> n
14:39:21 <gwern> hm. what does that turn into, as an IO sequence?
14:39:40 <gwern> I'd just as soon not need to getEnv on each element; there's an ordering there
14:40:16 <allbery_b> getEnv m0 `catch` getEnv m1 `catch` ... `catch` getEnv mN
14:40:40 <allbery_b> so the first one that succeeds is returned
14:40:45 <allbery_b> else:
14:40:46 <gwern> allbery_b: I mean, if getEnv m0 succeeds, do the others run?
14:40:50 <allbery_b> no
14:41:00 <gwern> ah. because catch is conditional on the two branches, right?
14:41:07 <allbery_b> `catch` only executes its 2nd arg if the first fails
14:43:23 <allbery_b> oh, that was a chain of `mplus` I meant.
14:43:37 <gwern> 'No instance for (MonadPlus IO)' fun
14:44:36 <allbery_b> compiler too old
14:44:47 <allbery_b> it's easy enough to add
14:44:52 <gwern> 6.8.2 is too old?
14:44:53 <allbery_b> @src IO MonadPlus
14:44:53 <lambdabot> Source not found. My pet ferret can type better than you!
14:44:57 <allbery_b> huh
14:45:01 <gwern> how new is this monadplus stuff?
14:45:05 <allbery_b> no, should be there.  import Control.Exception?
14:45:18 <gwern> ah, I think I was using prelude catch
14:45:38 <allbery_b> (it's misisng from my currently installed 6.6.1, but 6.8 has it if you import Control.Exception)
14:45:47 <allbery_b> @src IO mzero
14:45:47 <lambdabot> mzero       = ioError (userError "mzero")
14:45:51 <allbery_b> @src IO mplus
14:45:52 <lambdabot> m `mplus` n = m `catch` \_ -> n
14:48:13 <gwern> no, that doesn't fix it
14:49:54 <gwern> http://hpaste.org/6808
14:51:06 <gwern> @src msum
14:51:06 <lambdabot> msum =  foldr mplus mzero
14:52:07 <allbery_b> hmm.. come to think of it you want that directly, replacing mzero with your default case
14:54:09 <Japsu> @check \x -> msum x == concat (x :: [[Int]])
14:54:12 <lambdabot>  OK, passed 500 tests.
14:56:16 <dbpatterson> sclv: are you here?
14:56:38 <gwern> allbery_b: I'm afraid I lost you a while ago
15:04:52 <int80_h> what's a good port? the happs example uses 5000
15:05:04 <allbery_b> <lambdabot> msum =  foldr mplus mzero
15:05:30 <Lemmih> int80_h: Any port is fine.
15:05:30 <dmwit> gwern: Don't you actually want mapM?
15:05:31 <allbery_b> rather than msum, you probably want foldr mplus (default case) . map getEnv
15:06:05 <allbery_b> dmwit:  no.  map, which will turn [String] into [IO String]
15:06:14 <Consul> Hi, I'm a complete newcomer to Haskell and functional programming, and I have some general questions, if I may. Hi, everyone.
15:06:18 <dmwit> gwern: What is the goal here?
15:06:22 <allbery_b> and then msum (or the foldr mplus) to reduce it
15:06:25 <dmwit> Hi, Consul!  Shoot.
15:06:37 <dmwit> allbery_b: sequence
15:06:51 <allbery_b> <gwern> so I'm having a little trouble writing a fold; I want  ["foo", "bar", "baz"] -> (getEnv "foo" `catch` getEnv "bar" `catch` getEnv "baz)
15:06:52 <Consul> Well, a friend and I are aiming to create something like a Reaktor-like application, a synth and sampler builder, for Linux.
15:07:25 <dmwit> allbery_b: Oh!  That's just a fold, why are you using mplus?
15:07:26 <allbery_b> dmwit: which will throw an exception when the first getEnv fails
15:07:32 <Consul> And I have this really interesting idea for a "composition of functions" approach to the signal routing and creation of processing structures for both control and audio signals.
15:07:44 <Consul> And it just seems to me that a functional language is made for that kind of thing.
15:07:49 <allbery_b> that was Cale's idea from yesterday, using the MonadIO definition of mplus to handle exceptions
15:07:54 <dmwit> :t foldr1
15:07:55 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
15:08:03 <allbery_b> the pont is getEnv taises an exception when the envar doesn't exist
15:08:15 <allbery_b> it needs to be caught and the next alternatove tried
15:08:18 <int80_h> okay I'll use 8000 then. I'm referring to the MyProjects example on the splash page
15:08:37 <int80_h> oops
15:08:52 <agcorona> Consul: you are rigth
15:09:00 <gwern> dmwit: http://hpaste.org/6808#a1 <-- the goal is to generalize envs
15:09:01 <Consul> Anyway, I thought I'd poke around and take a look, kick the tires, ask some questions, etc.
15:09:09 <allbery_b> so you can fold (`catch` \_ ->) (or some such), or use instance MonadPlus IO
15:09:35 <Consul> We want to use FAUST for the making of fundamental DSP blocks, which is a functional language that compiles to C++ code.
15:09:40 <dmwit> gwern: That has too many (???) characters to be readable here; do you have a version with no Unicode or whatever?
15:09:51 <gwern> bleh. hold on
15:10:19 <dmwit> Oops, have to go, sorry. =/
15:10:31 <gwern> http://hpaste.org/6808#a2
15:10:38 <vss> hi
15:10:39 <gwern> wish hpaste wouldn't mess up the unicode
15:11:14 <vss> guys, can you point me to a right direction? I'm just starting and trying to build an application out of a few libraries of my own
15:11:32 <vss> one of my libraries requires external dependency on flock-0.1
15:12:10 <vss> I want the source to be completely self-contained, so that checking out the source tree would include flock-0.1 cabal package
15:12:52 <vss> the build procedure would then configure/build/register the flock package and proceed to my own libraries
15:12:56 <allbery_b> getEditors :: [String] -> IO String; getEditors = foldr mplus (return "vi") . map getEnv -- I think
15:13:07 <vss> should I use cabal'ized infrastructure for this kind of task?
15:13:20 <vss> should I use make(1) and my own custom scripts?
15:13:25 <vss> what is the way to go?
15:13:44 <allbery_b> it may need to be foldl, I'm being brainfried today.  the (return "vi" should happoen only if the getEnvs fail
15:14:10 <gwern> allbery_b: dunno. the compile problem is still the monadplus instance
15:14:35 <gwern> even importing Control.Exception
15:15:21 <allbery_b> hm, lemme poke, I know it's in there somewhere
15:15:35 <allbery_b> and it's foldl not foldr
15:16:03 <gwern> Control.Monad.MonadPlus ?
15:16:28 <allbery_b> @instances-importing Control.Exception Control.Monad MonadPlus
15:16:28 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
15:16:42 <PenguinOfDoom> I think I broke ghci somehow. I'm trying to go through a tutorial and I get this:
15:16:43 <allbery_b> sigh.
15:16:46 <PenguinOfDoom> Prelude> makeList = 1 : makeList
15:16:46 <allbery_b> @version
15:16:46 <lambdabot> lambdabot 4p603, GHC 6.8.2 (Linux i686 2.40GHz)
15:16:46 <lambdabot> darcs get http://code.haskell.org/lambdabot
15:16:48 <PenguinOfDoom> <interactive>:1:9: parse error on input `='
15:16:53 <PenguinOfDoom> It used to work just five minutes ago, somehow.
15:16:56 <Zao> PenguinOfDoom: let
15:17:00 <allbery_b> let makeList = ...
15:17:06 <gwern> no, that's the class definition, in Control.Monad
15:17:17 <allbery_b> IO is in the returned list
15:17:19 <PenguinOfDoom> oh hm
15:17:23 <PenguinOfDoom> Thanks!
15:17:25 <gwern> @hoogle MonadPlus
15:17:25 <lambdabot> Control.Monad.MonadPlus :: class Monad m => MonadPlus m
15:17:38 <gwern> @info MonadPlus
15:17:38 <lambdabot> MonadPlus
15:18:43 <allbery_b> Control.Monad.Error
15:19:37 <allbery_b> "instance MonadPlus IO -- Defined in Control.Monad.Error"
15:20:21 <gwern> seems to compile
15:22:08 <allbery_b> okay, it is folkd
15:22:09 <allbery_b> er
15:22:12 <allbery_b> foldr
15:22:17 <allbery_b> now I cant type :/
15:23:35 <allbery_b> foldr mplus (return "vi") . map getEnv . words $ "XMONAD_EDITOR VISUAL EDITOR"
15:23:39 <allbery_b> (my test case)
15:24:34 <allbery_b> (the "words" stuff just because it's easier to type than brackets and commas :)
15:25:30 <gwern> hm. both foldl and foldr compile. I wonder what the difference is - is that with foldr it tries the head, head+1, to the last entry, and foldl would start getEnving with the last item?
15:26:20 <allbery_b> foldr does the (return "vi") last, foldl does it first
15:26:51 <allbery_b> so foldl is just a fancy way of saying return "vi" :)
15:27:29 <allbery_b> hm, that is a good point though
15:28:10 <allbery_b> foldr DTRT for me
15:28:27 <allbery_b> each entry in the list in the given order, then the default fallthrough
15:28:46 * allbery_b is sad that he had to test that, wishes he knew where his brain went today
15:35:52 <lordrat> hi, I'm interested in GSoC. Is there any chance to be accepted? Is here anyone willing to talk about it with me?
15:36:12 <ddarius> lordrat: Unless they extended the deadline, the deadline was March 31st.
15:36:15 <allbery_b> #haskell-soc might be a better place to ask
15:36:19 <allbery_b> and they did extend it IIRC
15:36:57 <lordrat> nodeadilne was moved
15:37:09 <lordrat> thanks for info
15:40:15 <PenguinOfDoom> Does interactive ghc not have automatic line continuation?
15:40:35 <EvilTerran> PenguinOfDoom, if you're on 6.8*, you can start a multi-line section with :{
15:40:43 <EvilTerran> and close it with :} on a line on its own
15:40:47 <lordrat> new deadline for students is April 7
15:40:48 <PenguinOfDoom> hey, it's a smiley!
15:40:54 <ddarius> EvilTerran: Really?
15:41:04 <EvilTerran> yup :D
15:41:21 <EvilTerran> ask :?
15:41:47 * ddarius rarely uses GHCi anyway though.
15:54:04 <orzo> hello
15:54:13 <orzo> I want to use ghc on Mac Os X
15:55:08 <orzo> my project is building on Mac OS X 10.5 but for 10.4 or up
15:55:58 <orzo> i need some help/advise on which package to download
16:03:34 <halmos> Hello, as a newbie I had an idea of a program to implement in Haskell and I'm looking for advice. I want to build some sort of command line program I could use to record grades on homework and quizzes for a class and calculate simple statistics over the data set.
16:04:06 <jsnx> halmos: if you want to persist the data, look at the SQLite bindings...
16:06:22 <dons> hey halmos
16:06:40 <dons> halmos: grab ghc, use a Data.Map structure to store the grades, and manipulate them
16:09:35 <halmos> hmm, thanks for the advice, I'll start looking into Data.Map now. I'm a bit biased towards finding a way to do this completely in haskell.
16:12:01 <jsnx> Plareplane: union of sets in any order is the same
16:12:03 <jsnx> oops
16:26:54 <EvilTerran> jsnx, unless your "equality" relation isn't actually equality proper, and you can distinguish "equal" values another way
16:32:29 <SamB> only crazies do that in a way they care about!
16:32:46 <SamB> like, say, the designers of smalltalk!
16:33:06 <jsnx> EvilTerran: like, what kind of equality operation?
16:33:18 <jsnx> EvilTerran: i assume it is not disjoint union...
16:34:46 <EvilTerran> i mean doing the union based on an equivalence relation that isn't actually equality
16:35:15 <EvilTerran> say, unioning two sets of pairs, only comparing the fst element
16:35:26 <EvilTerran> (which basically gets you a Map, but never mind that)
16:35:55 <koninkje> (or a multimap...)
16:36:19 <SamB> EvilTerran: yes, that's what the smalltalk crazies did!
16:36:55 <EvilTerran> koninkje, it wouldn't be a multimap if you were only doing comparisons on the fst element, as there'd be no duplicate fsts
16:37:18 <jsnx> EvilTerran: well, if we're just going to redefine equal to mean whatever we damn well please....
16:37:20 <SamB> EvilTerran: well, that would be the case of a bag
16:37:23 <halmos> hmm, do I need anything more than ghc 6.8 to do stuff with Data.Map? I am trying to compile an example from part of the haskell wikibook and it's giving me an error
16:37:34 <SamB> a bag which does not do optimization
16:37:36 <jsnx> halmos: the error is?
16:37:52 <koninkje> EvilTerran: but if you're defining an equivalence class based on the fst element, given a query you can get multiple responses
16:38:09 <EvilTerran> never mind :P
16:38:14 <koninkje> :)
16:38:17 <halmos> ld: symbol(s) not found
16:38:17 <halmos> collect2: ld returned 1 exit status
16:38:26 <bos> halmos: compile with --make
16:42:25 <halmos> how do I compile with --make to create an executable
16:43:16 <halmos> I have a haskell file named PassDB.hs that contains a module called PassDB
16:43:59 <Saizan> halmos: which has a main function?
16:45:02 <halmos> oh so I need a module named Main to make an executable
16:55:01 <MyCatVerbs> hackage.haskell.org is still pretty damn unstable. Are there any, uh, mirrors?
16:55:39 <MyCatVerbs> Even trying to read the trac wiki is, if you'll excuse me, an intractable problem right now.
16:55:53 <dons> MyCatVerbs: unstable?
16:56:03 <dons> there was an upgrade this morning
16:56:11 <dons> so if something's not working, please let us know
16:56:28 <snhmib> uhm, how do i fix this so that i can make a graph with the fgl library? (http://rafb.net/p/glCJlr29.html)
16:56:29 <lambdabot> Title: Nopaste - No description
16:57:10 <MyCatVerbs> dons: short story, lots. The trac wiki for GHC is currently failing to load for me.
16:58:05 <MyCatVerbs> dons: hackageDB seems to be working, right up to the point where I try to navigate to one of the actual packages, at which point I just get no response.
16:59:54 <MyCatVerbs> Hrmn, the packages' pages are coming up now. Just very slowly.
17:00:11 <MyCatVerbs> The trac wiki is still failing to load. Can't read any of GHC's build instructions right now.
17:00:22 <MyCatVerbs> dons: here's the output of a quick netcat session: http://pastie.caboo.se/174964
17:00:28 <lambdabot> Title: #174964 - Pastie
17:10:01 <snhmib> do i have to use the Tree-Graph (Gr)? (have as "can i do without")
17:11:05 <dons> MyCatVerbs: ok.
17:12:42 <MyCatVerbs> dons: thanks for listening to me whinin', cryin' and bellyachin'. Anything else I can do?
17:12:57 <dons> i'll just talk to Paul and Igloo
17:14:08 <Igloo> dons: Is bandwidth to Galois in general OK?
17:15:23 <dobblego> ?check \xs -> foldr (:) [] xs == xs
17:15:25 <lambdabot>  OK, passed 500 tests.
17:15:31 <dobblego> ?check \xs -> foldr (:) [] xs == (xs :: [Int])
17:15:31 <lambdabot>  OK, passed 500 tests.
17:15:38 <Igloo> dons: Hmm, looks like the machine needs prodding
17:28:00 <jsnx> what's an efficient way to drop the last element of a list?
17:28:13 <mauke> > init [1 .. 9]
17:28:14 <lambdabot>  [1,2,3,4,5,6,7,8]
17:28:24 <jsnx> oh, neat
17:28:35 <MyCatVerbs> @index init
17:28:35 <lambdabot> Data.List, Prelude
17:28:38 <MyCatVerbs> Huh.
17:31:36 <Cale> jsnx: Of course, 'efficient' here is O(n) -- that's the best you can do.
17:32:29 * koninkje thinks one could do better with different internal representations of lists...
17:32:39 <EvilTerran> jsnx, note it's not particularly efficient
17:32:39 <koninkje> (but barring that)
17:33:38 <EvilTerran> koninkje, indeed - Data.Seq, for instance
17:34:10 <koninkje> I was thinking along the lines of Data.ByteString, but yeah
17:34:54 <EvilTerran> i think Seq is O(1) amortized add/remove from either end
17:36:37 <koninkje> Speaking of efficiency, is there any particular efficient implementation of multimaps out there? (I mean other than using map with another collection)
17:37:36 * koninkje will be catamorphing over the results of queries, if that matters
17:38:36 <jsnx> ach
17:38:55 <jsnx> so, another thing i have been wondering about -- generic list interfaces
17:39:18 <jsnx> it is so annoying that i need Data.ByteString.length, Prelude.length, and on and on
17:39:33 <Cale> Well, of course, you can do better for access to the end, but all the ways of doing this that I've seen have excluded the possibility of the list being infinite.
17:39:54 <jadrian> can I see the ghc source files online somewhere?
17:40:01 <jsnx> Cale: hehe
17:40:05 <jadrian> is there an interface for the darcs repository?
17:40:31 <Cale> jsnx: It would be easy enough to stick length in a typeclass, but the Prelude is hard to change.
17:40:47 <jadrian> I wanted to take a look at Control.Monad.Error
17:40:51 <jsnx> Cale: well, there has actually been some progress, right?
17:41:08 <jsnx> like, we've got Foldable
17:41:13 <Cale> Right.
17:41:20 <Cale> and you could implement a generic length in terms of that.
17:41:35 <jsnx> well, we could have Longable...
17:41:53 <MyCatVerbs> Cale: pray tell how on Earth you plan to be able to pick up the end of an infinite stream...? @_@
17:42:00 <Cale> MyCatVerbs: exactly.
17:42:05 <jsnx> What type classes are like Foldable in that they generify list behaviour?
17:42:21 <MyCatVerbs> Cale: so then it wouldn't matter how quickly you can get to the end, in that case, right?
17:42:21 <jsnx> MyCatVerbs: just make it the beginning?
17:42:24 <EvilTerran> ?source Control.Monad.Error
17:42:24 <lambdabot> http://darcs.haskell.org/packages/3/Control/Monad/Error.hs
17:42:25 <Cale> jsnx: There's also Traversable
17:42:26 <koninkje> jsnx: another thing to bear in mind is the whole lattice of collections, i.e. some of those common functions belong in a "collectable" class (very similar to monads), but others belong in a "sequenced, collectable" class
17:42:34 <Cale> jsnx: But Foldable does most of the work.
17:42:40 <jsnx> koninkje: oic
17:42:53 <jsnx> well, this is haskell
17:43:00 <jsnx> we're supposed to do the generic thing
17:43:05 <Cale> Of course, ByteStrings can't count.
17:43:08 <wagle> track the element count, and have the out-of-memory exception return the last element count of the infinite list
17:43:12 <jsnx> Cale: ?
17:43:27 <koninkje> jsnx: there's been some work on this (and generally reinventing Haskell's collections library), but I'm not sure whether it's still a living project or not
17:43:37 <Cale> ByteStrings don't fit into the Foldable interface because they're not parametrised over element type.
17:43:51 <jsnx> wagle: maybe all infinite lists should be in the Infitinitable class
17:44:12 <jadrian> EvilTerran: great Thanks!
17:44:44 <Cale> > init [1..]
17:44:45 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:44:58 <Cale> Of course, you have to be careful what you mean by O(n) :)
17:45:13 <Cale> > last [1..]
17:45:16 <lambdabot> Terminated
17:45:40 <wagle> > init $ reverse [1..]
17:45:43 <lambdabot> Terminated
17:46:06 <jadrian> EvilTerran: doesn't load though :S
17:46:13 <jadrian> EvilTerran: guess I'll just download the source
17:46:21 <EvilTerran> jadrian, er... do you have the docs locally?
17:46:29 <EvilTerran> they should have a "source" link in the top-right
17:46:31 <Cale> init is really O(k) where k is the number of cells of the resulting list which are matched against.
17:47:17 <jadrian> EvilTerran: I don't think my suse rpm included the docs
17:47:26 <EvilTerran> hang on a sec
17:47:31 <jadrian> EvilTerran: but I was checking the library documentation online
17:47:49 <jadrian> EvilTerran: oh
17:47:51 <EvilTerran> ... which similarly should have a source link in the top-right
17:47:55 <jadrian> EvilTerran: yeah there is a link :)
17:48:00 <EvilTerran> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-Error.html
17:48:01 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2knezz
17:48:01 <jadrian> EvilTerran: thanks
17:48:03 <EvilTerran> :)
17:50:13 * wagle suddenly wonders if there is an infinite loop currently running that will run until the end of time
17:52:57 <dmwit> forever (modify succ) :: State PlanckCounts ()
17:56:58 <jadrian> is Haskell' still going to require fail on the Monad class?
17:57:39 <jadrian> or was it factored out into some sort of new MonadFail class?
17:58:09 * koninkje wonders if fail would belong in MonadZero
17:58:34 <koninkje> ...or one of the error/exception classes
17:59:14 <jadrian> no no no
17:59:29 <jadrian> Monad zero has nothing to do with failure
18:00:20 <koninkje> excepting that many MonadPluses return their mzero on fail...
18:00:34 <koninkje> (not that I'm saying that's a best practice to carry over into haskell')
18:02:17 <koninkje> I mean logically, what is "failure"? Either it's the zero of the system or it's some manner of exception control (where having a zero of the system is the most primitive exception control around)
18:02:54 * koninkje , personally, thinks it belongs more in the error control classes; but still
18:03:01 <EvilTerran> except the zero of, say, Maybe, or (Either a) *is* an exception
18:03:29 <koninkje> exactly.
18:03:42 <SamB> I really would like a way to say that "fail should work just like mzero, except of course the message can be used for something"
18:04:01 <koninkje> Of course, (Either a) doesn't have a truly unique zero but rather a type of zero
18:04:04 <SamB> in a mathematically-reasonable way
18:04:15 <EvilTerran> SamB, i agree
18:04:53 <koninkje> The problem with that is that it's possible to have some (reasonable) monads where mzero is a valid non-error solution
18:04:54 <SamB> then MonadFail could be a subclass of MonadZero, I guess?
18:05:04 <LegendaryPenguin> if you have (a b c) in lambda calculus, are they all free variables?
18:05:18 <SamB> koninkje: and where fail does something entirely different?
18:05:24 <wagle> i see exceptions as unwinding the stack until a handler is found..  on the way to the handler, the code doesnt need to know how to handle the error value
18:05:30 <koninkje> SamB: indeed.
18:05:39 <SamB> koninkje: I was hoping for some sort of example
18:05:48 <jadrian> SamB: so you want fail to work just like []
18:05:50 <scook0> LegendaryPenguin: if all you have is a fragment
18:05:53 * EvilTerran too
18:06:01 <scook0> then any variable not bound by an enclosing abstraction is free
18:06:01 <koninkje> One example is in constructing a monad for nondeterminism.
18:06:18 <jadrian> brb
18:06:19 <EvilTerran> koninkje, in the list monad, fail s = mzero, tho
18:06:19 <koninkje> Lists are one such monad, but there're also more efficient continuation versions...
18:06:31 <SamB> koninkje: but what does fail do then?
18:06:45 <koninkje> and one may want to distinguish "there is no answer to that computation" from "ZOMG!!!"
18:06:51 <wagle> some say the purpose of an exception is to permit one piece of code that doesnt know how to handle the error to send the error to a piece of code that does (without knowing where that handler is before-hand)
18:06:53 <LegendaryPenguin> what if you have like, ((lambda (a) a) (lambda(b) b)), would you say they are all free or would you evaluate it
18:06:56 <scook0> bear in mind that (a b c) is only a valid lambda term if you have some convention about the associativity of application
18:07:10 <EvilTerran> koninkje, that's what MaybeT [] would be for
18:07:11 <LegendaryPenguin> er bound*
18:07:19 <SamB> scook0: which we have
18:07:33 <EvilTerran> LegendaryPenguin, assuming that means what i think it means, they're all bound
18:07:40 <EvilTerran> (or bindings)
18:08:01 <koninkje> The point is, while generally speaking mzero means failure, that's not always the case
18:08:06 <scook0> what you've given is a closed term, i.e. there are no free variables
18:08:17 <wagle> if you have an error >value<, then all the intermediate code between the source of that value and the handler needs to know how to pass it on
18:08:30 <EvilTerran> koninkje, i still don't see a convincing example
18:08:33 <scook0> SamB: yeah, I'm just being explicit about the fact that the convention is being used
18:08:39 <SamB> koninkje: I too am unconvinced
18:08:57 <EvilTerran> and i'm wracking my brains here
18:09:08 <scook0> LegendaryPenguin: are you trying to get an understanding of what a free variable is?
18:09:16 <scook0> or otherwise, what are you trying to do?
18:09:25 <LegendaryPenguin> is it just anything not preceded by a lambda expression with the name as a formal parameter?
18:09:30 <koninkje> EvilTerran: consider unification algorithms. There's a difference between "no, these terms don't unify" and "I've encountered an error in computing the answer to that unification query""
18:09:47 <scook0> a free variable is a variable not bound by its enclosing scope
18:09:56 <EvilTerran> koninkje, so you use MaybeT, say, or ErrorT, to indicate error
18:10:14 <scook0> so in the lambda-terms x and (lambda (y) x), the variable x is free
18:10:21 <scook0> but in (lambda (x) x), it's bound
18:10:35 <LegendaryPenguin> what about (lambda (x) (lambda (y) x)), is the x free
18:10:41 <EvilTerran> koninkje, the concept of "failure" is not very rigorously defined, but as it's used in haskell, it makes most sense - i feel - to unify it with the zero of a monadplus
18:10:58 <jadrian> EvilTerran: so if mzero is thought of as a "failure" what would mplus be?
18:11:06 <scook0> a variable is bound if it exists (arbitrarily deep) inside some abstraction (or other kind of term) that binds it
18:11:09 <EvilTerran> catch
18:11:13 <scook0> in that case, x is bound
18:11:15 <EvilTerran> like it is in Maybe and (Either e)
18:11:23 <jadrian> EvilTerran: so how does that work with lists?
18:11:27 <EvilTerran> (approximately)
18:11:36 <EvilTerran> jadrian, well, take the first result...
18:11:41 <scook0> because it's inside the body of the \y, which is inside the body of the \x
18:11:42 <koninkje> sure sure, you can use transformers to mix them together, but still there are two different sorts of "no" answers. Why force people to use a transformer stack when it's possible to combine them into the same (single) monad
18:12:08 <EvilTerran> koninkje, "do one thing, and do it well"
18:12:35 <SamB> mplus is a way to combine some computations such that if either succeeds, you get an answer. well, usually.
18:12:37 <jadrian> EvilTerran: it doesn't really take the first result
18:12:41 <EvilTerran> if you want more than one bit of functionality, i don't see the problem with forcing you to use more than one component
18:12:42 <jadrian> EvilTerran: it takes them all
18:13:25 <EvilTerran> jadrian, this is the Additive/Alternative distinction that has, IIRC, come up on -cafe. i'm afraid i'm not particularly well-versed in it, myself
18:13:31 <EvilTerran> jadrian, but what exactly are you getting at?
18:13:45 <koninkje> jadrian: then mplus is (a) a way of recovering from failure, and/or (b) a way of combining successes
18:14:41 <koninkje> EvilTerran: the problem comes in when maintaining a living code base. I.e. when you ahve to go and change the transformer stack to add in a new layer
18:14:48 <EvilTerran> jadrian, there's laws for how mzero and mplus are expected to behave. those equate well with mzero being failure, and mplus being - i like how koninkje put it there - combining successes and recovering failures
18:15:00 <jadrian> EvilTerran: my only point was about fail not being in monad
18:15:07 <EvilTerran> koninkje, there's the haskell equivalent of a design pattern for keeping that tidy, though
18:15:09 <koninkje> Given arrows this is much less of a problem, but with only a monad transformer stack things can get ugly quickly
18:15:15 <EvilTerran> and it does a very good job
18:15:24 <EvilTerran> for surprisingly little boilerplate
18:15:31 <scook0> LegendaryPenguin: note that in ((lambda (x) x) x), one of the xs is bound, and the other one is free
18:15:32 <EvilTerran> jadrian, what about fail not being in monad?
18:15:53 <jadrian> EvilTerran: personaly I wish it was not there
18:16:01 <EvilTerran> i agree
18:16:04 <jadrian> EvilTerran: fail has nothing to do with monads
18:16:08 <EvilTerran> i'd put it in MonadZero, along with mzero
18:16:21 <SamB> EvilTerran: yeah, I think I would too
18:16:24 <EvilTerran> it is a very convenient construction
18:16:26 <LegendaryPenguin> i understand now scook0, thx
18:16:28 <koninkje> jadrian: actually it's not quite "recovering" from failure, it's still "combining" success with failure (which by law is equivalent to the success). Again, the distinction can come up in practice (e.g. the unification code I was talking about)
18:16:35 <SamB> that was my plan a while back...
18:16:42 <EvilTerran> and sometimes theoretical purity must give way to pragmatism ;)
18:16:46 <jadrian> koninkje: agree
18:17:13 <jadrian> EvilTerran: but it complicates things
18:17:26 <EvilTerran> not significantly
18:17:29 <jadrian> EvilTerran: it complicates an instance of Monad for Either a
18:17:57 <Cale> I just wish they'd left things as they were in Haskell 1.4
18:18:06 <jadrian> EvilTerran: and if you want to use failure with your monad just import the appropriate module
18:18:26 <scook0> Cale: which was?
18:18:31 <EvilTerran> how would "importing the appropriate module" work with pattern-match failures?
18:18:38 <EvilTerran> that's the point of having fail in Monad
18:18:50 <Cale> scook0: Failable patterns occurring in do-blocks would cause a MonadZero constraint.
18:19:15 <scook0> ah
18:19:27 <EvilTerran> if you wanted to go to extremes, we could get lambda-match implemented, and do something with that
18:19:32 <jadrian> EvilTerran: I think you got me now... :S
18:19:34 <LegendaryPenguin> scook0, when substituting in for this ((lambda (a) (a b)) b), you don't need to rename anything right
18:19:37 <Cale> lambda-match?
18:19:41 <EvilTerran> but it's getting very much unlike haskell at this point
18:19:51 <Cale> EvilTerran: huh?
18:19:51 <EvilTerran> ?where lambda-match
18:19:51 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/ticket/114
18:20:25 <Cale> That's not loading...
18:20:30 <jadrian> EvilTerran: But I was going to go for what Cale just said
18:20:44 <EvilTerran> Cale, if (\x -> EXP) :: a -> b, then (|x -> EXP) :: MonadZero m => a -> m b, pretty much
18:20:53 <scook0> LegendaryPenguin: I guess not
18:21:05 <EvilTerran> that second one might need a "return" in there, i forget
18:21:05 <Cale> EvilTerran: that's... odd
18:21:12 <jadrian> Cale: any idea why it changed?
18:21:20 <jadrian> Cale: that seems to make perfect sense
18:21:22 <Cale> jadrian: People who don't like polymorphism
18:21:28 <scook0> though if you substituted in a term for b from the environment, and it contained free as, then you would need to
18:21:28 <Consul> Is hackage working for anyone else? It's timing out for me.
18:21:41 <Cale> Consul: It's been messed up for a lot of people
18:21:53 <Cale> Consul: apparently there were upgrades today and something's gone wrong
18:21:55 <EvilTerran> but the point is to get something which provides nothing but "pattern-matches with failure being a value instead of _|_"
18:22:01 <Consul> Cale: Okay, thanks. I just wanted to make sure it wasn't me. :-)
18:22:21 <Cale> EvilTerran: Doesn't case already handle that?
18:22:30 <EvilTerran> and then you could desugar other cases of that (do notation, list comprehensions, etc) into uses of lambda-match, and it'd potentially simplify the language somewhat
18:22:33 <EvilTerran> Cale, well, not tersely
18:22:43 <EvilTerran> you need to give the _ -> mzero case explicitly
18:23:05 <Cale> Yeah, but why should the failure be monadic?
18:23:09 <scook0> http://downforeveryoneorjustme.com/hackage.haskell.org
18:23:14 <lambdabot> Title: It's not just you!
18:23:15 <EvilTerran> it wouldn't have to be
18:23:30 <Cale> Monoidal failure might make more sense...
18:23:35 <EvilTerran> you could use jadrian's idea and have a separate Fail class or something
18:23:48 <EvilTerran> scook0, heh, handy
18:24:59 <Cale> I find that a little strange. I don't find myself typing enough lambdas with case expressions that have an mzero branch anyway.
18:26:36 <EvilTerran> the idea, i think, is that the existing means of pattern-matching aren't really compositional
18:27:04 <mrd> cool, wxhaskell was finally finally updated
18:27:06 <Cale> Compositional in what way?
18:27:20 <Twey> mrd: Some time ago
18:27:36 <Twey> It was announced here a few days back
18:27:39 <mrd> Apr 1
18:27:55 <EvilTerran> you can't say "try this thing that does a pattern match, and, if the pattern fails, try that one instead" without knowing the patterns in advance
18:28:20 <EvilTerran> or requiring people to do the wrapping in Maybe or whatever manually
18:28:41 <Cale> hmm
18:28:51 <EvilTerran> basically, it's a step towards first-class patterns :P
18:29:02 <Cale> I usually think of pattern matches as things which ought to be completel.
18:29:04 <Cale> complete*
18:32:07 <EvilTerran> that page justified it better than i, when it's working
18:33:13 <Tordek> hi
18:33:55 <Cale> hello
18:34:02 <Tordek> how can I define a function that works on the first two elements of a list? something like function (x:y:xs)
18:34:14 <Cale> yes
18:34:18 <Cale> that would be the pattern
18:35:13 <Tordek> and to recurse into every element except the first, given that call? function (x:y:xs) = 1 + function (y:xs)
18:35:22 <Cale> yep
18:35:35 <Tordek> (that was awesome)
18:35:38 <Cale> Just don't forget that you now have two base cases
18:35:47 <Tordek> also, why the f* am I getting a type error?
18:36:00 <Cale> Well, for that I'll have to see the code :)
18:36:01 <scook0> Tordek: hpaste?
18:36:06 <Cale> @paste
18:36:06 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:36:09 <Tordek> tanks
18:36:15 <Tordek> +h
18:36:19 <EvilTerran> or, you can write function (x:xs@(y:_)) = 1 + function xs -- if you like obfuscation and premature optimisation, anyway.
18:36:31 <Tordek> btw, freenode = awesome people
18:36:53 <scook0> another way might be the zipWith f xs (tail xs) approach
18:36:57 <scook0> depending on the function
18:37:00 <EvilTerran> (assuming you actually use x and y, there - as the function stands, it's a bit silly to do anything so fancy)
18:37:16 <scook0> i.e. pair each element with the one after it
18:37:23 <Tordek> http://hpaste.org/6809
18:37:45 <Tordek> hmm, zipping would be better, I guess
18:37:50 <Cale> Tordek: you want to apply greatest_gap to (y:xs), right?
18:37:58 <Cale> not just to y
18:37:58 <Tordek> Cale yes
18:38:07 <Cale> You'll need some parens then :)
18:38:17 <Tordek> ah, awesome
18:38:18 <Tordek> thanks
18:38:22 <Cale> greatest_gap y:xs  means  (greatest_gap y):xs
18:38:34 <Tordek> << lithper
18:39:04 <mauke> (greatest_gap ((:) y xs))
18:39:06 <scook0> yes, I think that function would be a good candidate for the zipWith approach
18:39:09 <scook0> if you're interested
18:39:10 <nornagon> @help
18:39:10 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:39:13 <nornagon> @list
18:39:13 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
18:39:58 <Cale> > (\xs -> maximum (zipWith (-) xs (tail xs)) [1,10,2,14,6,12]
18:39:59 <lambdabot> Unbalanced parentheses
18:40:02 <Cale> > (\xs -> maximum (zipWith (-) xs (tail xs))) [1,10,2,14,6,12]
18:40:07 <lambdabot>  8
18:40:16 <Cale> oh, hehe
18:40:23 <Cale> > (\xs -> maximum (zipWith (-) (tail xs) xs)) [1,10,2,14,6,12]
18:40:24 <lambdabot>  12
18:40:24 <Tordek> 
18:40:53 <nornagon> where's the series-recognition command? :(
18:41:02 <Cale> @oeis 1,1,2,3
18:41:02 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
18:41:02 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
18:41:22 <nornagon> oh, oeis
18:41:24 <nornagon> right :)
18:41:29 <nornagon> @oeis 0,1,36
18:41:30 <lambdabot> Numbers that are both triangular and square: a(n) = 34a(n-1) - a(n-2) + 2.
18:41:30 <lambdabot> [0,1,36,1225,41616,1413721,48024900,1631432881,55420693056,1882672131025,6395...
18:41:40 <scook0> Tordek: incidentally, that function (like yours) will only find the largest *decrease*
18:42:01 <Tordek> abs the -
18:42:10 <scook0> yeah
18:47:14 <Tordek> how do I make a lambda that takes multiple vars? (\x -> \y -> x - y)?
18:47:34 <Twey> Tordek: \x y -> x - y
18:47:41 <Tordek> thanks
18:47:49 <Cale> Tordek: your form will work too :)
18:47:51 <Twey> Which, yes, in Haskell is the same as \x -> \y -> x - y
18:48:04 <Twey> And, in fact, (-)
18:48:05 <Twey> :-)
18:48:10 <CosmicRay> @seen bos
18:48:10 <lambdabot> I saw bos leaving #haskell and #ghc 1h 32m 15s ago, and .
18:48:23 <Twey> > (-) 3 5
18:48:24 <lambdabot>  -2
18:48:29 <Tordek> well, yeah, obvious answer aside, Twey
18:49:05 <koninkje> Does anyone know what the W stands for in O(min(n,W)) for Data.IntMap operations?
18:49:28 <Cale> koninkje: Number of bits in an Int
18:49:30 <mauke> Many operations have a worst-case complexity of O(min(n,W)). This means that the operation can become linear in the number of elements with a maximum of W -- the number of bits in an Int  (32 or 64).
18:49:46 <koninkje> cool
18:49:47 <Tordek> greatest_z_gap xs = maximum (zipWith (\x y -> abs (x - y)) xs (tail xs))
18:50:29 <koninkje> so I take it Data.IntMap is just a basic hash + linked list implementation?
18:50:38 <Cale> koninkje: No.
18:50:55 <Cale> koninkje: It's based on Patricia trees.
18:51:09 <koninkje> ah, sure
18:51:17 <dobblego> are the any good quickcheck properties for foldl?
18:51:20 <Cale> koninkje: Hashes tend not to make very good pure datastructures. :)
18:51:27 <mauke> @free foldl
18:51:28 <lambdabot> (forall x. f . h x = k (f x) . g) => f . foldl h y = foldl k (f y) . $map g
18:51:39 <dobblego> what does @free do?
18:51:46 <mauke> @help free
18:51:46 <lambdabot> free <ident>. Generate theorems for free
18:51:59 <koninkje> Cale: I was meaning more that the hashing was already done to get the Int for your key; but point taken
18:52:01 <Tordek> no charge? cool!
18:52:01 <Twey> For free?!  Yay!
18:52:09 <Cale> @check \f xs -> foldl f (xs :: [Int]) == foldr (flip f) (reverse xs)
18:52:10 * Twey grins.
18:52:10 <lambdabot>   add an instance declaration for (Eq ([b] -> [Int]))
18:52:11 <Tordek> hi5 Twey
18:52:27 <Cale> @check \f xs -> foldl f 0 xs == foldr (flip f) 0 (reverse xs)
18:52:29 <lambdabot>  OK, passed 500 tests.
18:52:31 <dobblego> wtf is $map?
18:52:37 <dobblego> ah nice
18:52:40 <Cale> @check \f z xs -> foldl f z xs == foldr (flip f) (z :: Integer) (reverse xs)
18:52:41 <lambdabot>  OK, passed 500 tests.
18:52:52 <mauke> dobblego: map
18:53:01 <koninkje> dobblego: type-raised map?
18:53:15 <Cale> dobblego: It's just the Prelude map
18:53:19 <koninkje> (with parens, natch)
18:53:49 <Tordek> what's . for?
18:53:54 <dobblego> function composition
18:53:55 <Cale> Tordek: function composition
18:53:56 <jadrian> @free callCC
18:53:57 <lambdabot> Expected variable or '.'
18:54:03 <Tordek> and $?
18:54:03 <Cale> (f . g) x = f (g x)
18:54:15 <Twey> Tordek: Function application
18:54:15 <Cale> Tordek: function application (but with low precedence)
18:54:39 <Twey> f (f2 arg) == f $ f2 arg
18:54:39 <Cale> So instead of  f (g (h x)), you can write f . g . h $ x, if you like.
18:54:51 <Twey> It saves a load of brackets.
18:55:13 <Cale> It also helps to think in the functional mindset to be composing functions all the time :)
18:55:54 <Twey> Heh
18:56:02 <SamB> so, how many know about Control.Category?
18:56:04 <Tordek> so abs (x - y) == abs ((-) x y) == abs . (-) x y ?
18:56:26 <mauke> no, (abs . (-)) x y
18:56:32 <mauke> er, no
18:56:33 <Cale> uh, no :)
18:56:40 <mauke> (abs . (-) x) y
18:56:42 <Cale> (abs . (-) x) y
18:56:43 <Cale> yes
18:56:44 <Twey> Heh
18:57:05 <Tordek> so... just abs (x - y) ;P
18:57:13 <Twey> Or abs $ x - y
18:57:15 <Twey> :-)
18:57:20 <mauke> ((abs .) . (-)) x y
18:57:23 <SamB> @quote C-a-l-e
18:57:23 <lambdabot> C-a-l-e says: Welcome to #haskell where your questions are answered in majestic stereo!
18:57:23 <Cale> > ((abs .) . (-)) 10 5
18:57:24 <lambdabot>  5
18:57:31 <Cale> :t (abs .) . (-)
18:57:32 <lambdabot> forall a. (Num a) => a -> a -> a
18:57:33 <Tordek> (.) (.)
18:57:46 <mauke> > (.) . (.) abs (-) 5 10
18:57:46 <lambdabot>        add an instance declaration for
18:57:46 <lambdabot>       (Num (f (a -> b)), Num (f (a -> ...
18:57:52 <mauke> > ((.) . (.) abs (-)) 5 10
18:57:52 <lambdabot>        add an instance declaration for (Num (f a), Num (a -> a))
18:57:53 <EvilTerran> (.).(.)!
18:58:03 <mauke> > ((.) . (.)) abs (-) 5 10
18:58:03 <lambdabot>  5
18:58:12 <EvilTerran> > fmap fmap fmap abs (-) 5 10
18:58:13 <lambdabot>  5
18:58:25 <mauke> do not taunt happy fun fmap
18:58:28 <Tordek> (.) (.) causes fmap fmap fmap ?
18:58:35 <mauke> (.) == fmap
18:58:45 <EvilTerran> ((.) . (.)) = (.) (.) (.)
18:58:52 <Tordek> you did not get teh pr0n joke
18:58:57 <SamB> Cale: don't you know that (.) is already a method of Category?
18:58:58 <Cale> fmap is a generalisation of function composition -- In fact, lambdabot's (.) is the same as fmap
18:59:03 <Twey> Tordek: *groan*
18:59:07 <timemage> mauke, still legal in 13 states =)
18:59:13 <Cale> SamB: I don't believe in that generalisation ;)
18:59:30 <SamB> Cale: well, what are you going to do about it?
18:59:36 <SamB> request that it be renamed to >>> ?
18:59:39 <SamB> or <<<
18:59:45 <SamB> yeah, <<< it would be
19:00:09 <allbery_b> Tordek:  *headdesk*
19:00:09 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/ -- I don't see that module, btw.
19:00:16 <Tordek> \o/
19:00:18 <EvilTerran> ... is Control.Category just Control.Arrow without pure?
19:00:19 <SamB> Cale: see the darcs repository!
19:00:23 <EvilTerran> (or arr)
19:00:37 <SamB> EvilTerran: no! it is the superclass of Arrow, where id and . are
19:00:44 <Cale> SamB: I don't really keep up with that.
19:00:56 <Cale> SamB: Where's the darcs repo's haddock?
19:01:03 <SamB> Cale: not a clue!
19:01:08 <EvilTerran> SamB, that sounds like much the same thing to me, but okay
19:01:21 <SamB> EvilTerran: well, it lacks all the other methods for some reason
19:01:45 <Cale> Yeah, it should be <<<
19:01:52 <int80_h> test
19:01:54 <Cale> I thought that's what was suggested, anyway
19:01:55 <SamB> Cale: well, send mail to libraries@
19:01:59 <EvilTerran> i can think of cases where an Arrow instance would make sense, were it not for pure/arr
19:02:08 <SamB> the method was (.) last I checked
19:02:09 <Cale> When I saw it on the mailing list, that's what it was.
19:02:22 <SamB> I'll check again to be sure
19:02:27 <Cale> Maybe someone decided it should be different?
19:02:30 <SamB> they might have changed it
19:02:35 <timemage> is Network.Socket supposed to be missing from ghc 6.6.1 ?
19:02:55 <SamB> there is a <<< and a >>> in the module, but they aren't in the class
19:04:02 <Cale> Would someone submit a patch to rename it?
19:04:26 <SamB> I think the procedure involves a proposal first?
19:04:31 <SamB> at least, that would not hurt
19:04:31 <Cale> timemage: I don't know. Do you have the network package installed?
19:05:22 <timemage> Cale, well, in an older version of the package, i did.  when i upgraded to this version i didn't.  so it was part of the old package.  i'm just wondering if it was outmoded and i'm supposed to be using something else.
19:05:41 <Cale> timemage: Well, GHC 6.6.1 is a little old anyway
19:06:00 <Cale> timemage: But do a  ghc-pkg list network  and see if anything comes up
19:06:02 <timemage> Cale, yup.  still the latest available to me in the system.
19:06:29 <Cale> If you're using Ubuntu, the generic linux binary works rather well.
19:06:53 <SamB> Cale: hmm, darcs pull isn't working :-(
19:06:59 <Cale> (In case you don't want to wait until the next version of Ubuntu, shortly after which 6.10 will be released.)
19:07:24 <timemage> using gentoo (i've already asked in #haskell-gentoo btw).        ghc-pkg list network yields "/usr/lib64/ghc-6.6.1/package.conf:"
19:07:49 <Cale> timemage: okay, so it's just not installed
19:07:51 <SamB> who should I talk to about darcs.haskell.org being down?
19:08:09 <SamB> or is this common knowlege by now?
19:08:15 <timemage> Cale, that's what i was thinking.
19:08:22 <Cale> timemage: I'm almost certain there's a haskell overlay you could use for 6.8.2
19:08:22 <timemage> Cale, more wondering why.
19:08:46 <timemage> Cale, hmm, this is the latest in the haskell overlay.  near as i can tell anyways.
19:09:00 <conal> to compile for profiling in GHC + Cabal, is it enough to add -prof to the ghc-options: line?  i tried that with lib A, but then compiling lib B also -prof, which uses A, i get "Perhaps you haven't installed the profiling libraries for package A?"  am i missing something?
19:09:08 <Cale> There appears to be a 6.8.2 ebuild here: http://www.haskell.org/~gentoo/gentoo-haskell/dev-lang/ghc/
19:09:09 <lambdabot> Title: Index of /~gentoo/gentoo-haskell/dev-lang/ghc
19:09:23 <Tordek> myLength =  foldr (\x n -> n + 1) 0 << this is zero-point?
19:09:33 <Cale> Tordek: yeah
19:09:53 <Cale> Tordek: That is, what the empty list is replaced with.
19:10:07 <Cale> foldr f z  replaces each (:) with f and the [] at the end with z
19:10:11 <timemage> Cale, doesn't show up in my emerge -pv ghc.  i've run emerge --sync and layman -S
19:10:17 <mauke> [I--] [ ~] dev-lang/ghc-6.8.2 (0)
19:10:21 <Cale> dcoutts_: are you around?
19:10:45 <timemage> is it masked for anything?
19:10:54 <Cale> timemage: I'm afraid I don't actually use gentoo, so I'm not sure...
19:11:01 <Cale> It's possible? :)
19:11:10 <Tordek> what's foldr1 for?
19:11:17 <mauke> http://packages.gentoo.org/package/ghc
19:11:17 <lambdabot> Title: Gentoo Packages /package/ghc
19:11:21 <timemage> Cale, i'll check it out.  do appreciate you looking though.
19:12:05 <Cale> Tordek: for times that you don't have a natural element to replace the empty list with, and you'd rather just fail on the empty case
19:12:29 <Cale> Tordek: It uses the last element of the list as the final piece
19:12:37 <timemage> mauke, Cale, yup, it's masked because i'm on amd64.  i'll give it a try.
19:12:39 <Cale> > foldr1 f [a,b,c,d,e] :: Expr
19:12:39 <lambdabot>  f a (f b (f c (f d e)))
19:12:46 <Cale> > foldr f z [a,b,c,d,e] :: Expr
19:12:47 <lambdabot>  f a (f b (f c (f d (f e z))))
19:13:04 <Cale> > foldl f z [a,b,c,d,e] :: Expr
19:13:04 <lambdabot>  f (f (f (f (f z a) b) c) d) e
19:13:09 <Cale> > foldl1 f [a,b,c,d,e] :: Expr
19:13:09 <lambdabot>  f (f (f (f a b) c) d) e
19:13:27 <mauke> foldr1 f xs = foldr f (last xs) (init xs)
19:14:06 <Cale> @check \f xs -> foldr1 f xs = foldr f (last xs) (init (xs :: [Integer]))
19:14:07 <lambdabot>  Parse error at "=" (column 22)
19:14:17 <Tordek> so foldl1 (*) xs would be just like foldl (*) 1 xs, just "one element less"
19:14:19 <Cale> @check \f xs -> foldr1 f xs == foldr f (last xs :: Integer) (init xs)
19:14:19 <lambdabot>  Exception: Prelude.foldr1: empty list
19:14:34 <Cale> @check \f xs -> (not . null $ xs) ==> foldr1 f xs == foldr f (last xs :: Integer) (init xs)
19:14:35 <lambdabot>  OK, passed 500 tests.
19:14:37 <SamB> okay, I can get a SYN,ACK from darcs.haskell.org, but I don't seem to be recieving any packets after that...
19:14:47 <Cale> Tordek: yeah
19:14:56 <Tordek> <3
19:14:59 <Cale> Tordek: and it would fail on the empty case
19:15:12 <dons> SamB: it seems to be down. it was having some trouble this morning as well
19:15:19 <dons> SamB: the authorities have been notified
19:15:26 <SamB> dons: okay ;-)
19:15:42 <SamB> funny that I get a SYN,ACK
19:15:45 <SamB> isn't it?
19:16:28 <erg0t_> is sad :'(
19:16:46 <Tordek> compress :: Eq a => [a] -> [a]
19:16:51 <Tordek> what's Eq?
19:17:04 <conal> never mind the profiling question.  i found http://www.haskell.org/haskellwiki/How_to_profile_a_Haskell_program
19:17:06 <Cale> Tordek: a typeclass for types which have an equality comparison
19:17:09 <lambdabot> Title: How to profile a Haskell program - HaskellWiki, http://tinyurl.com/yq6bzf
19:17:10 <Cale> :t (==)
19:17:10 <Twey> A typeclass defining the == and /= functions
19:17:11 <lambdabot> forall a. (Eq a) => a -> a -> Bool
19:17:24 <Cale> :t (<)
19:17:25 <lambdabot> forall a. (Ord a) => a -> a -> Bool
19:17:56 <Tordek> (also, totally unrelated, how do you read a -> a -> Bool? (as in "it's a function of type ...?")
19:18:20 <dobblego> forall a. a -> a -> Bool
19:18:24 <Cale> -> associates to the right
19:18:32 <Cale> So it's really  a -> (a -> Bool)
19:18:35 <mauke> Tordek: a to a to Bool
19:18:35 <dobblego> a function that takes an 'a' and returns a function that takes an 'a' and returns a Bool
19:18:53 <dobblego> or what mauke said for brevity
19:18:58 <SamB> hmm, it eventually sent an RST... and darcs just went on and tried to download a different file!
19:19:10 <Cale> Or more colloquially, a function which takes two parameters of type a, and gives a Bool.
19:19:44 <Cale> (there's no distinction between taking multiple parameters and taking one parameter and returning a function)
19:20:25 <SamB> evidently, darcs doesn't know the difference between a 404 and an interrupion in the TCP connection!
19:22:20 <dons> darcs isn't a real machine, fwiw
19:23:11 <SamB> dons: oh?
19:23:38 <mauke> it's just some guy manually assembling tcp packets
19:23:39 <SamB> I never would have guessed
19:23:51 <SamB> mauke: I think he is saying that it runs in a VM
19:24:10 <SamB> I'm not sure how that's relevant, really...
19:24:52 <Cale> It's just me pushing a magnet back and forth through a coil of ethernet cable
19:25:44 <SamB> Cale: you need to learn some packet types other than SYN,ACK and RST
19:26:05 <Cale> heh
19:26:32 <allbery_b> @remember Cale <dons> darcs isn't a real machine, fwiw <Cale> It's just me pushing a magnet back and forth through a coil of ethernet cable
19:26:32 <lambdabot> Done.
19:40:32 <dolio> @yow!
19:40:33 <lambdabot> Now that I have my "APPLE", I comprehend COST ACCOUNTING!!
19:40:57 <dolio> @quote qwe1234
19:40:57 <lambdabot> qwe1234 says: go read a book or something
19:41:28 <Excedrin> good advice, as usual
19:42:04 <SamB> @quote advice
19:42:04 <lambdabot> No quotes match. stty: unknown mode: doofus
19:42:09 <SamB> @quote doofus
19:42:09 <lambdabot> No quotes match. Do you think like you type?
19:42:12 <SamB> @quote type
19:42:12 <lambdabot> edwardk says: well, dependent types fuck with compilers ability to get anything done
19:42:20 <TomMD> Anyone here who has read 'Types and Programming Languages'?
19:42:32 * SamB halts in the face of an actual conversation
19:43:49 <SamB> John Meacham has the funniest bank account number: repetae.netjohn
19:44:01 <TomMD> SamB: Don't worry about it, unless someone like d*ons wakes up, I don't expect an actual response.
19:44:16 <Cale> TomMD: I've read a good part of it
19:44:37 <TomMD> Oh- and what was your take?  It's came highly recommended to me and I've been given a guided tour.
19:45:14 <thoughtpolice> TomMD: it's good. i'm reading it now, and while i'm getting stuck on some of the more advanced parts (polymorphism section) it's pretty approachable.
19:45:31 <TomMD> As approachable as SPJs STM papers? ;-)
19:45:35 <Cale> It's quite good. I found it a little dry, but that comes with the territory, I think.
19:46:11 <timemage> Cale, mauke,  after a bit of thrashing around i've
19:46:20 <timemage> gotten it working. thanks again.
19:46:32 <SamB> Cale: yeah, me too
19:46:44 <SamB> I mean, think that being dry comes with the territory
19:46:58 <SamB> I haven't read any of TaPL
19:47:13 <SamB> mostly because I don't have it, and I haven't thought to check if the school library has it...
19:47:15 <Cale> It's formal logic, not algebraic topology :)
19:48:25 <Cale> I managed to find a copy of ATTaPL online which looks like it's probably what was sent to the publisher.
19:50:54 <SamB> Cale: where?
19:50:58 <SamB> how?
19:51:30 <Cale> I can't remember exactly at this point.
19:52:07 <Cale> I seem to recall it was on one of those free file-hosting services.
19:52:27 <TomMD> I've now ordered TaPL!
19:52:35 <scook0> it's a good book
19:52:54 <TomMD> Can't wait
19:52:58 <Pseudonym> Woo, pirate type theory!
19:53:17 <Pseudonym> Arrr, matey!  Let polymorphism be NP-hard!
19:54:14 <dolio> @seen hpaste
19:54:14 <lambdabot> I haven't seen hpaste.
19:54:20 <Cale> http://cale.yi.org/autoshare/Advanced%20Topics%20in%20Types%20and%20Programming%20Languages.pdf -- you can get what I found from here if you'd like to see. Probably not very legal, but whatever.
19:54:24 <lambdabot> http://tinyurl.com/3ahlpj
19:55:10 <SamB> is this just a .ps conversion?
19:55:30 <Cale> The text is selectable.
19:55:43 <Cale> So if it's a .ps conversion, it's a good one :)
19:55:48 <SamB> and when you paste it, it pastes ?
19:55:59 <Cale> mhm
19:56:15 <SamB> and ends up being the same text you had selected?
19:56:17 <SamB> that's pretty good
19:56:56 <dolio> When you paste, it generates text on the corresponding page of War and Peace.
19:57:30 <Cale> SamB: Provided that it doesn't have any special symbols -- those tend to get left out.
19:57:48 <Cale> Prove that exchange, weakening and contrac-
19:57:49 <Cale> tion lemmas hold for the simply-typed lambda calculus.
19:58:39 <TomMD> @seen
19:59:22 <Cale> It might be taken from an E-book copy.
19:59:29 <Cale> http://loadingreadyrun.com/videos/view/49/how_to_talk_like_a_pirate
19:59:30 <lambdabot> Title: Loading.Ready.Run. - How to Talk like a Pirate, http://tinyurl.com/25emcx
20:00:09 * dolio eagerly awaits hpastetwo so he won't have to comment unicode.
20:00:27 <TomMD> hpastetwo - the return of the paste.
20:04:37 <dobblego> what is the name of the rules for equations such as 4 + x <= 3 to find the values of x?
20:04:55 <Cale> Solving an inequality
20:05:08 <Cale> (that's not really an equation)
20:05:46 <dobblego> yeah I just found that, thanks :)
20:07:52 <shapr> It's an inequation!
20:08:18 <dolio> shapr: Where's hpaste hiding?
20:08:28 <shapr> umm
20:08:32 <shapr> !paste
20:08:34 <shapr> ahem
20:08:36 <sw17ch> did hackage.haskell.org go down?
20:08:36 <shapr> @seen hpaste
20:08:36 <lambdabot> I haven't seen hpaste.
20:08:40 <shapr> oops
20:08:46 * shapr fixes
20:09:29 <SamB> sw17ch: yes, it did
20:09:36 <sw17ch> :(
20:09:38 <SamB> dons said the authorities have been notified
20:09:43 <sw17ch> excellent
20:09:43 <TomMD> sw17ch: Its been up and down all day - very unproductive day.
20:09:56 <SamB> apparantly they tried to upgrade the server this morning or something
20:09:57 <sw17ch> right when i wanted to show off Haskell too
20:10:00 <shapr> dobblego: Got it.
20:10:01 <sw17ch> :)
20:10:14 <TomMD> Did he say they know they would fall behind in the public polls if it wasn't fixed?
20:10:17 <dobblego> *apparently
20:10:17 * shapr grins
20:10:27 <sw17ch> "but does it have a cpan or gems equivalent?"
20:10:34 <shapr> I'm tempted to add a restart button the admin section of hpaste.
20:10:46 <shapr> And give logins to the #haskell regulars
20:11:12 <TomMD> Just give it to lambdabot and make a plugin that will send the proper message from lambdabot to hpaste ;-)
20:11:35 <SamB> sw17ch: and it means I can't pull the latest sources, since the same VM session serves darcs.haskell.org!
20:11:49 <sw17ch> SamB, i hate computers
20:12:07 <TomMD> How dare they run a community service and not have six sigma up time!
20:12:18 <sw17ch> :p
20:12:27 <SamB> TomMD: I don't even understand that!
20:12:46 <SamB> is that better than five 9s?
20:12:56 <SamB> i.e. more than 9.9999% ?
20:13:00 <TomMD> Same concept.
20:13:55 <sw17ch> 9.9999%? i'd want better than that :P
20:13:56 <TomMD> Just remember: If any software development group indicates they have some sort of six sigma program - run!
20:14:04 <TomMD> sw17ch: I should hope so.
20:14:13 <shapr> I usually get the five nines after the decimal point somewhere.
20:14:21 * sw17ch is ashamed for nitpicking details we all understand
20:14:28 <SamB> so, where does  come from?
20:14:52 <shapr> sw17ch: Being pedantic isn't exactly out of character for #haskell.
20:15:08 <SamB> sw17ch: yeah, they had that joke in userfriendly recently ;-)
20:15:11 <allbery_b> 6 standard deviations from the norm
20:15:12 <Cale> SamB: not , 
20:15:16 <TomMD> Simply the idea that your shipped products should have fewer than (1 - 0.999999) defects.
20:15:25 <SamB> Cale: yeah, I didn't think the upper case was the right one ;-)
20:15:39 <TomMD> So if you have a single software bug, then every shipped piece of software will have that identical defect and you are utterly screwed ;-)
20:16:26 <SamB> sw17ch: I did that on purpose, actually ;-)
20:16:33 <Cale> The idea is to have six standard deviations of your process between the mean and the specification limit.
20:16:36 <allbery_b> s/norm/mean/ I think
20:16:37 <allbery_b> yeh
20:16:41 <Cale> (in every variable)
20:16:42 <SamB> Ah, standard deviations!
20:17:02 <SamB> thank you for enlightening me as to the meaning of "six sigmas" ;-)
20:17:06 <TomMD> Don't let the name fool you - they aren't so standard.
20:17:06 <sw17ch> yes, sigma... i remember now :)
20:17:41 <sw17ch> does the Networking package have support for sending binary blobs?
20:17:45 <sw17ch> or data structures?
20:18:03 <sw17ch> er... is it easy to do :)
20:18:06 <TomMD> network-bytestring has bytestring support... and then there is Data.Binary.
20:18:11 <TomMD> Is that what you want?
20:18:26 <SamB> allbery_b: I don't think it should make much difference?
20:18:59 <shapr> Gutentag ChilliX_
20:19:13 <SamB> but ... how does that work out to a 0.999999 uptime factor?
20:19:14 <allbery_b> SamB:  terminology.  when I learned it it was mean - median - mode.  "norm" is what?
20:19:30 <Cale> So if that's the case, then the probability of success is the integral from -6 to 6 of 1/sqrt(2 pi) exp(-x^2/2), which is erf(3 sqrt(2)), and is astoundingly close to 1.
20:19:36 <Cale> 0.99999999802682470
20:19:52 <SamB> Cale: ah.
20:20:11 <sw17ch> Hmm... ByteString would be mostly okay
20:20:12 <SamB> except that it's hard to have a standard deviation when the variable is a Bool
20:20:24 <sw17ch> i guess i haven't done a lot of Marshaling in Haskell yet
20:20:53 <TomMD> sw17ch: Also, IPC has Queues (Binary a => Queue [In, Out] a) but it isn't made for networking of coarse.  And just as above, you still need your structures to be instances of Binary.
20:21:01 <Cale> SamB: Yeah, in that case, you'd probably just want to rig the probability to be similar :)
20:21:21 <SamB> I think five 9s is considered pretty good
20:21:23 <sw17ch> mm. alright
20:21:35 <SamB> (assuming you place them as far to the left as possible)
20:22:32 * SamB goes off to bed
20:22:36 <sw17ch> SamB: 5 nines is 5 minutes per year
20:22:44 <sw17ch> that, to me, is just nuts :)
20:23:07 <SamB> yeah, 3 or 4 nines is probably good enough
20:23:21 <TomMD> I know what you mean.  If I couldn't get to #haskell 5 minutes a year I'd actually get some coding done.
20:23:21 <sw17ch> 4 nines is 52 minutes per year
20:23:22 * thoughtpolice thinks of erlang's 9 nines
20:23:24 <SamB> perhaps three 9s and a 5
20:23:50 <jsnx> 256 * 256
20:23:51 <SamB> so 3 nines would be less than 5 hours?
20:23:56 <sw17ch> 8.7 hours
20:23:56 <jsnx> > 256 * 256
20:23:57 <lambdabot>  65536
20:23:59 <sw17ch> i think
20:24:01 <jsnx> wow!
20:24:04 <mrd> 5 0s and a 1
20:24:18 <sw17ch> > (365.25 * 24) - (1 - 0.999)
20:24:18 <lambdabot>  8765.999
20:24:30 <sw17ch> > (365.25 * 24) * (1 - 0.999)
20:24:30 <lambdabot>  8.766000000000007
20:24:33 <sw17ch> there we go
20:25:16 <TomMD> > show (0.999999999 * (365.25 * 24 * 3600)) ++ " seconds per year of down time"
20:25:16 <lambdabot>  "3.15575999684424e7 seconds per year of down time"
20:25:31 <SamB> hmm, yes, three nines is probably a fairly realistic expectation, but you should try for four anyway ;-)
20:25:35 <TomMD> > show ((1 - 0.999999999) * (365.25 * 24 * 3600)) ++ " seconds per year of down time"
20:25:36 <lambdabot>  "3.155759910749012e-2 seconds per year of down time"
20:25:38 <TomMD> there
20:26:20 <SamB> Tomas: that's not pi!
20:26:23 <SamB> er. TomMD
20:27:21 <TomMD> yeah, well.  Don't you know that Alabama legislated pi to be 3.0 long ago* - so no one agrees on pi anyway.  (* reference to an April joke)
20:28:20 <sw17ch> The Bible also states Pi is 3.0. :)
20:28:21 <Pseudonym> The rule of thumb is that pi seconds is a nanocentury to within 1%.
20:28:44 <Pseudonym> sw17ch: That, BTW, is also incorrect.
20:28:46 <mauke> sw17ch: no, it doesn't
20:28:56 <sw17ch> oh dang, i'm misquoting! :(
20:29:01 <jsnx> yeah, it says pi is 2
20:29:07 <Pseudonym> jsnx: Heretic!
20:29:11 <jsnx> lolz
20:29:19 <bd_> pi seconds * 1 billion = 0.995531902 centuries <-- nice
20:29:22 <sw17ch> Pseudonym: i'm sure i'd be considered one any way :)
20:29:26 <sw17ch> by some..
20:29:36 <sw17ch> it's hard to be religious and consider your self a scientist
20:29:39 <sw17ch> you take crap from both sides
20:29:52 <Pseudonym> Everyone is a heretic to some.
20:29:56 <Pseudonym> Don't feel singled out.
20:30:15 <Pseudonym> If it's any consolation, Christopher Hitchens is a loony.
20:30:18 <jsnx> yeah, so, once upon a time i thought knuth was goof for writing all his books in assembly with explicit memory management -- but now i see the light
20:30:50 <sw17ch> Has there been much AI work with Haskell?
20:30:56 <TomMD> sw17ch: Some of the smartest people I know are quite religous.
20:31:10 <jsnx> i'm trying to figure out how to arrange a trie as a stream of bytes so that the first array to search over is in the front of the array -- and then i have some offsets, into the rest of the array, and so on
20:31:11 <SamB> sw17ch: what the heck is AI?
20:31:13 <sw17ch> TomMD: ah, but the question is, are you? :)
20:31:20 <Pseudonym> The overwhelming majority of the world's smartest people in history have been religious.
20:31:20 <sw17ch> Samb: artificial intelligence
20:31:26 <Cale> Actually, I don't see how they get this 3.4 defects per million opportunities number.
20:31:27 <TomMD> I usually call myself a theist.
20:31:32 <Pseudonym> TomMD: Knuth being a good example.
20:31:33 <jsnx> Pseudonym: well, so?
20:31:40 <SamB> sw17ch: oh, and the bible doesn't state that pi is 3!
20:31:43 <SamB> that was rounded!
20:31:55 <jsnx> Pseudonym: what is your point?
20:31:57 <Pseudonym> Actually, pi=3 is perfectly accurate, just quite imprecise.
20:31:58 <SamB> have you never heard of significant figures?
20:32:08 <jsnx> Pseudonym: the majority of the world's stupid people have been religious, too
20:32:08 <TomMD> SamB: I might be wrong, but I am fairly sure SPJ is another good example.
20:32:20 <TomMD> And some guy with a relative theory.
20:32:25 <jsnx> Pseudonym: and the majority of religious people are stupid...
20:32:33 <SamB> TomMD: I'm not contradicting you am I?
20:32:34 <Cale> 3.4 per million is way way more failures than I would think you'd get from a six sigma process.
20:32:40 <jsnx> (but that is only because there are so many religious people)
20:32:43 <sw17ch> TomMD: i don't mean to be a jerk or anything... i just don't think it matters of smart people think one way or another
20:32:48 <TomMD> SamB: No, I'm just piling it on.
20:32:52 <sw17ch> s/of/if/
20:33:05 <Pseudonym> jsnx: Yes, but the thesis that we're currently debunking is the one that science (or, in general, being smart) is incompatible with being religious.
20:33:13 <jsnx> Pseudonym: oic
20:33:19 <jsnx> i guess i came in late
20:33:19 <TomMD> hehe, wasn't meaning to try and shade this as a flame war - just throwing great counter examples out there.
20:33:26 <SamB> sw17ch: well, if us christians be right, it matters for any particular person if they agree...
20:33:31 <dons> http://www.kimsal.com/reldevsurvey/results.php?action=byLanguage&language=19#relbylang
20:33:32 <lambdabot> Title: Religious affiliation and software development languages, http://tinyurl.com/39xobg
20:33:36 <dobblego> they weren't religious; they submitted to authority while under duress
20:33:37 <Pseudonym> Oooh!
20:33:43 <dobblego> I do it every morning when I put clothes on for example
20:33:52 <SamB> and no, the intelligence of the people involved is not particularly relevant
20:34:04 <jsnx> many intelligent people are unhealthy
20:34:10 <dons> haskell programmers were the least religions programming group, iirc, from that survey
20:34:15 <jsnx> they eat cheap food, &c.
20:34:23 <jsnx> it is quite disappointing
20:34:25 <Pseudonym> dons: I know who responded "Discordianism".
20:34:42 <SamB> I still like the Thetan++ response
20:34:46 <sw17ch> hah
20:34:47 <sw17ch> :)
20:35:11 <jsnx> of course, i am religious, too
20:35:15 <SamB> that was a language response, of course
20:35:17 * araujo thinks the problem are religions .. not being religious
20:35:23 <jsnx> my jihad against tabs in source code is a never ending
20:35:25 <jsnx> battle
20:35:29 <SamB> by someone claiming to be a scientologist
20:35:30 <Cale> In fact, I'm not a statistician, but it seems to me that a six sigma process would produce 1.9 defects per *billion* opportunities.
20:35:42 <SamB> but I really don't think scientologists can write "Thetan++"
20:35:50 <Pseudonym> I note that a lot of Atheists responded.
20:35:53 <SamB> becase I'm pretty sure they don't have senses of humour
20:36:07 <jsnx> Pseudonym: most atheists are actually logical positivists
20:36:17 <jsnx> Pseudonym: they just don't know how religious they are
20:36:18 <SamB> another thing they probably don't have is Electrical Engineering degrees
20:36:34 <SamB> jsnx: what does that mean?
20:36:41 <sw17ch> :)
20:36:43 <dobblego> jsnx, many people who are logical positivists erroneously call themselves atheist
20:36:44 <jsnx> SamB: logical positivist?
20:36:46 <SamB> yeah
20:36:50 <Cale> jsnx: How is logical positivism a religion?
20:37:03 <SamB> Cale: well, if you adhere to it dogmatically...
20:37:09 <jsnx> it is a belief maintained in the face of evidence
20:37:14 <SamB> with those sharp teeth and so on...
20:37:17 <jsnx> i think that qualifies
20:37:22 <inimino> hoo boy
20:37:23 <SamB> never liking it if people hurt trees
20:37:47 * SamB wonders when someone is going to get the reference
20:37:54 <jsnx> SamB: ?
20:38:07 <Cale> Er, if this wikipedia article is an accurate definition of logical positivism, I don't think I can consider myself one of those.
20:38:10 <sw17ch> While I guess I'm considered a Christian, I have a lot of respect for calm Atheists who aren't about shoving their views in my face when I shove mine in theirs. :)
20:38:17 <inimino> so, vi vs emacs, anyone?
20:38:22 <jsnx> vim
20:38:29 <mauke> VIMACS
20:38:29 <cjb> emacs!
20:38:31 <sw17ch> inimino: Emacsers go to hell
20:38:34 <Cale> vim and emacs :)
20:38:34 <koninkje> @pl \s m -> put s >> m
20:38:34 <lambdabot> (>>) . put
20:38:38 <jeffz> emacs, M-x ansi-term RET RET vim
20:38:40 <sw17ch> Actually, it's special hell
20:38:42 <dobblego> sw17ch, "shoving views" is the very anti-thesis of atheism; I contest that you have never observed such a thing
20:38:43 <SamB> what I don't understand is jehovah's witnesses
20:38:52 <SamB> I don't see any point in being a jehovah's witness
20:38:54 <mauke> http://www.vimacs.com/
20:38:54 <lambdabot> Title: Invoice, Invoicing Software, Inventory Software, Billing Software, Inventory Con ...
20:39:01 <Pseudonym> Emacs users go to Ctrl-Alt-Meta-Hell.
20:39:07 <SamB> they aren't supposed to pray, they aren't supposed to go to church...
20:39:11 <jsnx> Cale: what di you think it meant?
20:39:32 <jsnx> ed is the standard text editor
20:39:35 <Cale> jsnx: Actually I'm not even sure that I agree that most atheists are logical positivists.
20:39:39 <SamB> (specifically, they explicitly forbidden from both)
20:39:49 <SamB> okay, bed now...
20:39:53 <jsnx> Cale: why not? don't they believe in, like, science and stuff?
20:39:58 <sw17ch> dobblego: you're right; i've never met a serious atheist (the kind who refrains from the d00d g0d suX0rz) language try to convince me of thigns without evidence
20:40:09 <Cale> jsnx: Depends on what you mean by 'believe in'
20:40:32 <SamB> some bad atheists might just not *want* to believe in a god
20:40:37 <SamB> those could be pushy
20:40:37 <dobblego> sw17ch, atheism is trendy these days; you'll meet a lot of people who claim to be atheist; indeed, you are at least mostly atheist
20:40:38 <Cale> I accept that science appears to be a useful tool for predicting observation.
20:40:47 <jsnx> Cale: i mean, they believe in the tenets of newtonian mechanics -- that the world evolves from one definite state to another
20:41:10 <sw17ch> dobblego: i'm not following everything following the second ';'
20:41:10 <SamB> Cale: that's about the most anyone can say, except the dogmatic Scientist
20:41:15 <araujo> most atheists are the main God believers :-]
20:41:15 <Cale> jsnx: Now, that I'm not sure most people who know quantum mechanics could agree with.
20:41:25 <jsnx> Cale: right
20:41:27 <SamB> empiracly, it would be silly to say more than that, wouldn't it?
20:41:33 <jsnx> but that's logical positivism
20:41:41 <dobblego> sw17ch, what are you thoughts on the Australian Aboriginal Dreamtime - that the Sun originated from an egg yolk?
20:41:53 <jsnx> and outside of math and physics, the vast majority of atheists are unaware of its falseness
20:42:02 <Pseudonym> dobblego: I don't think all of the Aboriginal Nations believe that.
20:42:03 <sw17ch> dobblego: ah, now i follow
20:42:04 <sw17ch> thanks
20:42:30 <Cale> jsnx: I don't believe in the existence of an objective reality, though I'm okay with using models which include such an assumption for simplicity.
20:42:40 <SamB> Cale: you don't?
20:42:42 <jsnx> Cale: oic
20:42:44 * araujo wants s t-shirt "In Haskell We Trust"
20:42:44 <SamB> I do.
20:42:48 <jsnx> Cale: what do you believe in?
20:43:01 <jsnx> Cale: are you an existentialist?
20:43:05 <SamB> but I admit wholeheartedly that such a belief can not be proven
20:43:05 <jsnx> burnination
20:43:06 <Cale> jsnx: Whatever seems useful at the time.
20:43:09 <facedown> m
20:43:12 <jsnx> Cale: heh
20:43:19 <Pseudonym> I'm with Cale on that.
20:43:20 <jsnx> a utilitarian
20:43:20 <SamB> I mean, I could in theory be the only thing that exists
20:43:27 <Cale> jsnx: Sort of.
20:43:27 <SamB> in some theories, I might not even exist
20:43:32 <Pseudonym> Example: As a mathematician, I'm a formalist.  As a computer scientist, I'm a constructivist.
20:43:38 * araujo doesn't believe in anything
20:43:47 <facedown> Dreamweaver is the best editor
20:43:48 <lament> as a drug user, i'm a pothead
20:43:49 <jsnx> Cale: if you are willing to put on having a consistent belief system, congratulations
20:43:53 <facedown> vim and emacs suck.
20:43:53 <jeffz> I typecheck, therefore I am?
20:43:55 <Pseudonym> araujo doesn't think, therefore he isn't.
20:43:55 <facedown> unproductiveeeeee
20:43:55 <Cale> jsnx: I don't believe that statements (which after all are just strings of symbols) can have intrinsic truth values.
20:43:59 <SamB> but it seems extremely silly to actually believe I might not exist
20:44:06 <Pseudonym> Cale: But derivations can.
20:44:13 <SamB> doesn't that seem like it would be extremely silly to you?
20:44:14 <Cale> Pseudonym: relative to a set of rules
20:44:15 <jsnx> Cale: why do you think truth is so special?
20:44:15 <lament> somebody ban facedown?
20:44:16 <sw17ch> Godel, Escher, Bach any one?
20:44:25 <facedown> Late april fools.. no ban please :)
20:44:35 <sw17ch> :)
20:44:41 <araujo> Pseudonym, if I am not ... what do I have to gain?, what can I lose? ...
20:44:43 <jsnx> Cale: i think we can have things which are formally true
20:44:52 <mauke> @vixen don't you wish your emacs was hot like vim?
20:44:52 <lambdabot> i'm on fire!
20:44:57 <SamB> Cale: hmm, well, I agree tha strings of symbols can't have intrinsic truth value ;-)
20:44:59 <dobblego> SamB, not silly, but not useful
20:45:01 <araujo> belief systems are what makes people going crazy
20:45:02 <Cale> jsnx: Sure, if we agree on a system in which to evaluate that truth.
20:45:03 <lament> @vixen what's the meaning of life?
20:45:03 <lambdabot> i'm not sure what i mean
20:45:04 <araujo> any of them
20:45:05 <jsnx> what we can't have is a concrete tie between those things and the world
20:45:13 <SamB> dobblego: how come not silly?
20:45:22 <jsnx> Cale: yes, right
20:45:33 <araujo> don't believe in anything is the way to live
20:45:34 <Pseudonym> Cale: One thing, though.  As an existentialist, I maintain that even strings of symbols have meaning, if you give meaning to them.
20:45:34 * johnnowak proudly manages to keep his mouth shut through a discussion on religion
20:45:35 <jsnx> Cale: though some systems get us a lot more mileage than others
20:45:38 <araujo> if you believe , you don't live
20:45:44 <araujo> you either live or believe
20:45:47 <dobblego> SamB, because empiricism is a utopian myth
20:45:47 <araujo> you can't have both
20:45:54 <SamB> Pseudonym: that sounds pretty much what I think, too
20:45:58 <jsnx> Cale: are you willing to believe in god if it is suitable to situation at hand?
20:46:02 <araujo> and life is for living
20:46:04 <sw17ch> Alright, so here's why I started this conversation. :) Can artificial intelligence arise from machines analogous to human intelligence?
20:46:04 <SamB> but I still believe that there is objective truth...
20:46:12 <SamB> though not all truths may be objective ones
20:46:13 <araujo> that's why no philosopher on earth will ever find the truth
20:46:16 <araujo> never ever
20:46:24 <araujo> they believe too much
20:46:26 <araujo> :-]
20:46:26 <lament> araujo: but a pothead will!
20:46:34 <araujo> hah
20:46:39 <araujo> now I am hungry
20:46:40 <johnnowak> sw17ch: do submarines swim?
20:46:46 <Cale> jsnx: Right, and they undergo a kind of Darwinian evolution over time, depending on how well they manage to work for us.
20:47:16 <SamB> I just don't think that strings of symbols have any kind of intrinsic meaning
20:47:30 * allbery_b thinks he accidentally wandered into #haskell-blah
20:47:35 <Cale> If someone doesn't accept the idea that walking out in front of trucks is dangerous, they tend not to live very much longer.
20:47:38 <SamB> I guess what I mean is that you need some kind of emergent linguistic framework before you can express objective truths
20:47:39 <sw17ch> johnnowak, submarines have a form which implies their functions. what is swim to us is submarining to a submarine.
20:47:46 <jsnx> Cale: aye
20:48:03 <Pseudonym> Trucks are an evolutionary pressure for humans.
20:48:47 <sw17ch> so, the question is, do machines have what it takes to come up with an intelligence fitting their form?
20:48:51 <jsnx> sw17ch: well, if we allow that, then ELIZA is already intelligent
20:49:01 <johnnowak> jsnx: exactly
20:49:05 <SamB> jsnx: eh?
20:49:10 <jsnx> so, we're done, then
20:49:12 <SamB> ELIZA, intelligent?
20:49:17 <sw17ch> jsnx, oh boo... :(
20:49:19 <SamB> absurd!
20:49:24 <jsnx> yes
20:49:26 <Pseudonym> We were discussing you --not me.
20:49:32 <SamB> I suppose I'm wasting my breath, eh?
20:49:44 <sw17ch> Alright , sorry to have started this. :) I need some sleep. Good night.
20:49:44 <SamB> since everyone already knows how ridiculous the idea is ;-)
20:49:49 <SamB> yah me too
20:49:50 <jsnx> SamB: i was arguing _ad absurdum_
20:49:51 <SamB> good night
20:49:59 <jsnx> SamB: okay
20:50:01 <sw17ch> SamB, youv'e been trying that for half an hour
20:50:12 <sw17ch> gnight
20:50:13 <jsnx> so, anyways, machines can not be intelligent
20:50:24 <jsnx> so let's just stop thinking about it right now
20:50:31 <jsnx> it is offensive to god, &c.
20:50:35 <Cale> jsnx: wha?
20:50:52 <araujo> machine can be intelligent
20:51:02 <jsnx> araujo: oh bah -- that is your false religion
20:51:18 <araujo> jsnx, no , I am not attached to that idea :-]
20:51:24 <jsnx> araujo: you have no objective reason to believe that, but you do
20:51:27 <araujo> I am fine with it
20:51:33 <jsnx> fine with what?
20:51:41 <araujo> with machines being intelligent
20:51:42 <lament> philosophy is a dangerous reactionary remnant of pre-scientific-method thinking. Nature of reality should be left to the physicists. Nature of truth should be left to mathematicians. Various human-related questions should be left to psychologists/sociologists. It seems the accepted theory today is that we could construct an exact model of the brain given enough computational power, and get intelligence that way.
20:51:53 <araujo> jsnx, I don't believe , it will happen
20:52:06 <Cale> It seems pretty likely though.
20:52:15 <jsnx> lament: well, unfortunately, there's a chicken and egg problem there
20:52:19 <araujo> jsnx, that's not a problem for me ... you know why?
20:52:20 <Cale> Given the success of, say, simulating rat cortex.
20:52:26 <araujo> jsnx, because i have no belief systems :-]
20:52:38 <jsnx> araujo: whatever
20:52:43 <TomMD> I blame myself for the fact that this conversation is continuing twenty minutes later.
20:52:45 <lament> araujo: do you think simulating a brain is computationally infeasible, ever?
20:52:47 <araujo> jsnx, anyone having a problem with artificial intelligent is because a pre-set belief system
20:52:53 <jsnx> araujo: no
20:53:04 <jsnx> araujo: i have a problem with its endless hope
20:53:09 <araujo> that's why most of them are religions groups and stuff
20:53:19 <araujo> they are the most polluted with these belief systems
20:53:35 <araujo> if you don't have belief systems ... you are free to explore
20:53:40 <Cale> jsnx: Obviously, the matter about whether machines will be considered intelligent in the future is one of speculation.
20:53:41 <inimino> TomMD: my emacs vs vi gambit failed ;-)
20:53:45 <BMeph> AI developers are polluted with belief systems? Eh?
20:53:51 <jsnx> Cale: right
20:53:52 <araujo> machines are getting intelligent and dominate the world? ... so what? :-]
20:54:28 <jsnx> BMeph: AI developers rarely believe in strong AI
20:54:33 * araujo wouldn't mind to meet a nice android girl like the one on blade-runner :-]
20:54:34 <Cale> jsnx: But looking at current progress regarding actual physical simulation of neurons would lead one to lean in the direction that simulating the physics of an entire human brain won't be too far off.
20:54:36 <jsnx> BMeph: mostly, they do A*
20:54:45 <jsnx> Cale: well, great
20:54:51 <araujo> lament, no, it's my point .. it's possible
20:55:03 <lament> the interesting question is not whether we get intelligence (very easy given enough computational resources; the issues are practical, not theoretical; we just simulate a brain) but whether we can come up with superhuman intelligence
20:55:05 <jsnx> Cale: so, when they can do the physics of a whole plane...
20:55:16 <jsnx> Cale: that would be a really slow intelligence
20:55:29 <Cale> jsnx: No, in real time :)
20:55:33 <araujo> lament, you only see this kind of stuff as unfeasible because of a pre-set belief system
20:55:38 <lament> jsnx: compare with how slow human intelligence is!
20:55:44 <jsnx> Cale: oh, bah
20:55:48 <lament> araujo: i don't think anything is infeasible
20:55:52 <jsnx> Cale: they will do all the fluids?
20:56:05 <Cale> jsnx: Have you seen the bit about simulating a cortical column of a rat?
20:56:06 * johnnowak readies a supply of rocks to throw
20:56:08 <araujo> lament, for you to believe that , you pretty much need to crack many belief systems
20:56:22 <araujo> lament, you won't find that kind of argument from a religion group
20:56:24 <lament> jsnx: on quantum time scale, human intelligence is amazigly slow. Why is it? Because the brain is complex, duh
20:56:28 <araujo> it's my point precisely
20:56:28 <jsnx> Cale: that is not really a whole brain though, man
20:56:44 <Cale> jsnx: yes, but it's a significant piece.
20:56:48 <jsnx> Cale: sure
20:57:07 <Cale> jsnx: You just have to scale it up maybe one or two orders of magnitude.
20:57:20 <lament> there's some worm with like 20 neurons, they simulate its brain perfectly :)
20:57:26 <jsnx> and then you will have a brain simulator
20:57:32 <jsnx> very good
20:57:38 <lament> not just simulate - they have a full map of the brain with the explanation of what each neuron does
20:57:57 <araujo> lament, we still need to define what 'intelligence' is ....
20:57:57 <johnnowak> lament: that's still a simulation
20:58:08 <jsnx> so, we have a brain simulator
20:58:10 <Cale> jsnx: Sure, and you can connect that up to inputs and outputs, and you'll have something which, if it's physically accurate, will be a machine that has human intelligence.
20:58:20 <jsnx> well, er, maybe
20:58:26 <jsnx> it won't have any state
20:58:27 <araujo> or at least, to have a road that gets us there , right now AI is pretty much researching and exploratory .....
20:58:39 <araujo> but it will happen at some point
20:58:46 <lament> araujo: we don't if we just simulate a human brain, we sidestep all practical issues that way
20:58:46 <johnnowak> a machine with a simulation of human intelligence
20:58:50 <Cale> jsnx: Of course, it will have to build that state.
20:59:01 <jsnx> Cale: most of my 'intelligence' is observable because of all this bromides and tropes i've picked up being alive
20:59:15 <jsnx> Cale: right, but they will take shortcuts
20:59:17 <araujo> lament, AI has _plenty_ of ways and roads ... simulating a human brain is just a small fraction of that road ...
20:59:25 <jsnx> and then it won't work right
20:59:26 <araujo> it's what makes AI so messy and confusing
20:59:33 <jsnx> and they will blame the shortcuts, of course
20:59:33 <Cale> jsnx: oh?
20:59:47 <lament> araujo: sure, it just conveniently steps retarded philosophical discussions like "what's intelligence"
20:59:57 <jsnx> Cale: well, you don't expect them to make hands and things so it can learn to write...
21:00:05 <lament> *sidesteps
21:00:11 <Cale> jsnx: At present, with the rat neurons, they have no idea how the neurons will join up a priori.
21:00:20 <jsnx> Cale: sure
21:00:34 <araujo> lament, offering no clear path?, or solution?
21:00:47 <araujo> lament, it's not something easy .. but it will happen at some point
21:00:59 <Cale> jsnx: Basically the only reasonable way to train such an intelligence is to actually do it :)
21:01:05 <araujo> let's spend 2000 more years talking about what intelligence is :-]
21:01:12 <jsnx> Cale: so, basically, if they want to make a plausible person, they will have to give this brain some person experience
21:01:27 <jsnx> Cale: which is just a terribly expensive proposition
21:01:37 <Cale> jsnx: If you've gone to all that trouble, why not hook up some cameras and actuators and such :)
21:01:44 <gwern> you could offer a good estimate on how much one ai would cost, extrapolating from the rat cortical simulations. unfortunately you'll probably end up with a figure in the trillions between scanning and building the thousands of Blue Genes you'd need
21:01:48 <jsnx> since you have to give it sex organs, of course, or else nothing is going to make any sense to it
21:01:49 <araujo> see how .. simulating a brain might involve thousands of factors , even non-technical or biologically related
21:02:24 <Cale> gwern: Except that technology has been getting cheaper at an exponential rate
21:02:37 <dobblego> --> #haskell-blah
21:03:19 <gwern> Cale: sure, but extrapolating from the rat cortical simulations is necessarily not taking into account progress
21:03:53 <Cale> gwern: why shouldn't it?
21:04:18 <Cale> (at least an estimate of progress)
21:04:24 <jsnx> so, what do you guys think about building a trie as a stream of bytes like this: [int array][indexes to other int arrays][int array 1][indexes...][int array 2][indexes ...]...
21:04:46 <Saizan> Main> :typeOf \f x -> f x ===> (f : _281) (x : _285 f) -> _286 f x <-- what an informative type :)
21:05:16 <Cale> Saizan: what is that from?
21:05:18 <dolio> Saizan: Yeah, it doesn't pick very nice variable names.
21:05:22 <dolio> Agda2
21:06:10 <Cale> The variable names aren't the only problem by the looks of it
21:06:18 <Saizan> dolio: apart from that i was expecting something mentioning a function arrow, but i guess that would be too restrictive?
21:06:23 <gwern> Cale: you can't say, 'hey guys, ai is in reach if you multiply the cost of a smaller-scale simulation by X; but that number is unpleasantly high so I'm gonna divide it by some Wild Assed Guess based on unpredictable teachnologicaly progress'
21:06:45 <gwern> it defeats the whole point of getting a reasonable number based on something that's already done
21:06:49 <dolio> Yeah, that is a bit weird.
21:07:15 <Cale> gwern: well, it's not just a terribly wild guess.
21:07:31 <gwern> it's like doing a back of the envelope calculation of how many cars there are in America, and then saying 'Ah, but I saw in the NY Times the other day that imports fell .5%, so we need to first adjust our number by that much'
21:07:54 <Cale> gwern: Look at the curve for computing power over the last few decades and you can make some reasonable predictions.
21:08:11 <gwern> Cale: sure, but then there's no call to reference the Blue Gene simulations
21:08:22 <Cale> huh?
21:08:29 <gwern> and referencing the Blue Gene simulations was the interesting point of my observation
21:09:03 <gwern> Cale: there were some high resolution simulations of a rat cortex carried out on one of the Blue Genes, which produced results like a real rat cortex would've
21:09:16 <Cale> right
21:09:43 <Cale> and together with that datapoint about how many neurons you can simulate with a given amount of computing power...
21:10:04 <dolio> Saizan: I don't know what it's doing exactly, but that expression could theoretically have a complicated type.
21:10:25 <gwern> and my point was, the simulations cost X millions, which give us a cost of how much AI would cost *right now*; as opposed to how much it might cost if trends continue
21:10:33 <Cale> sure, okay
21:10:36 <dolio> Saizan: For instance, the type of x could depend on f, or the codomain of f could depend on x.
21:11:03 <Cale> But I'm saying you can also ask the question in 5 years or in 10 years how much it's likely to cost.
21:11:25 <Cale> and that's probably not as terribly unreasonable as the number you'd get for today
21:12:19 <gwern> not terribly, but there are enough imponderables that adding in predictions of costs of computing power (not to mention types of power) makes things even worse
21:13:11 <Saizan> dolio: right, those are the only things that type states, it seems
21:13:52 <dolio> Yeah, more or less. :)
21:14:18 <Cale> Does Agda2 overload function application to the point that f might not be a function?
21:14:27 <Saizan> but shouldn't the type of x appear as the domain of f?
21:14:58 <Saizan> Cale: i only know that you can use types as arguments
21:15:51 <dolio> Well, x isn't the domain of f. x is a value of the type that's the domain of f, I guess.
21:16:19 <Cale> dolio: The *type* of x should be the domain of f though, no?
21:17:01 <dolio> Well, I'd think so, but if the type of x depends on f, that's a bit circular.
21:17:57 <Cale> dolio: I'd expect that the fact that f is a function would at least be represented somehow by the type...
21:18:19 <dolio> Well, it doesn't show what _281 is.
21:20:24 <dolio> Anyhow, loading up 'idf = \f x -> f x' in the emacs mode without a type signature results in unsolved metas.
21:20:36 <dolio> So you probably need to give it a type to direct it a bit.
21:21:26 <dolio> Which is probably why it doesn't have a sensible type there. It just gives up when it runs into the circularity.
21:21:36 <Saizan> it loads fine here
21:21:53 <Saizan> Main> :typeOf idf
21:21:54 <Saizan> (f : _208) (x : _212 f) -> _213 f x
21:22:13 <dolio> Yeah, type in :metas or something.
21:22:43 <dolio> The interactive interpreter doesn't tell you when it can't solve things.
21:23:02 <Saizan> oh
21:23:42 <Saizan> yeah, i get a lot of them at that type
21:23:51 <Saizan> s/type/line/
21:23:54 <dolio> In the emacs mode it gets colored yellow.
21:27:51 <hpaste>  clanehin pasted "Simple existential types conundrum?" at http://hpaste.org/6810
21:30:06 <Saizan> C-c C-x C-l to load? very weird since C-c C-x quits
21:30:31 <dolio> C-x C-c quits, no?
21:32:07 <hpaste>  dolio annotated "Simple existential types conundrum?" with "no need to deconstruct" at http://hpaste.org/6810#a1
21:34:13 <clanehin> dolio: right, x is made to type-equal y.  Thanks.
22:14:26 <Heffalump> morning conal
22:25:24 <dobblego> what is a good example of a corner case mistake in a function definition, that would be good to demonstrate QuickCheck, when it picks up the error?
22:27:53 <brad__`> hackage is down
22:42:30 <dons> bran_: yep
22:42:51 <dons> dobblego: hmm. some integer case that fails modulo N ?
22:42:55 <dons> or modulo N + M ?
22:42:59 <dobblego> is palomer a Haskell troll?
22:43:06 <dons> somewhat
22:43:11 <Cale> dons: hehe, it seems that brad left, leaving only bran :)
22:43:15 <dobblego> dons, yeah; I was hoping more "real life" in the eyes of the ignorant
22:43:32 <dobblego> oh, that explains his stupid remarks in #ocaml then :)
22:43:34 <dons> dobblego: john hughes had an exammple from a telephony system that involved mod 8 arithmetic
22:43:37 <Cale> @palomer
22:43:37 <lambdabot> xml stands for "xtremely mild lullaby"
22:43:39 <Cale> @palomer
22:43:39 <lambdabot> As someone who's studied GADTs, I've never found a use for them.
22:43:42 <Cale> @palomer
22:43:42 <lambdabot> That's a lie
22:43:52 <Cale> @palomer
22:43:52 <lambdabot> Brump!
22:43:54 <Cale> @palomer
22:43:54 <lambdabot> Learning vim is pointless
22:44:07 <dobblego> yeah those kind; I responded, unknowingly :)
22:44:32 <dons> #ocaml is where #haskell trolls hold their government of exile
22:44:40 <dolio> Heh.
22:46:17 <chadz> hey -- i'm using cgi & takusen, however, whenever I attempt to run a execDML query within the cgi monad, it drops me to a blank page
22:46:25 <dobblego> I am in awe at how big a dick head some people can be
22:46:34 * dobblego leaves #ocaml
22:46:37 <chadz> regular IO works, so, i'm thinking some exception is occuring that i'm not aware of
22:46:51 <dons> hmm. chadz yeah, maybe the db is tossing out an exception?
22:46:58 <dons> i think glguy looked into this at some point
22:47:05 <Nafai> If I'm getting this error "Prelude.read: no parse" is there a way to find out more info of what it isn't working?
22:47:40 <chadz> dons: i'll read into exception handling then. i've been putting that aside for far too long
22:47:50 <Cale> Nafai: GHCi's debugger might help
22:48:02 <Cale> Nafai: you can  :set -fbreak-on-exception
22:48:04 <dons> replacing read with maybeRead is also a good idea
22:48:32 <Cale> Nafai: and then when your read fails, you'll be able to look at the string -- you might have to :back one step
22:48:40 <chadz> what's the general opinion of DDC?
22:48:47 <dons> Cale, reminds me of you sometimes, http://xkcd.com/406
22:48:48 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
22:48:54 <Nafai> Cale: I'll try that
22:48:56 <chadz> i was actually doing a little reading on reddit today other than trolling, found it somewhat interesting
22:49:07 <chadz> the effect jazz looks nice.
22:50:13 <jsnx> i have a great idea -- what if we could compile any file into a Haskell module with a single value in it -- `raw`?
22:50:26 <jsnx> that would be a great way to have "data sections"
22:50:50 <jsnx> (raw would get you all the bytes in the file, in a ByteString)
22:51:01 <Cale> chadz: I think it's something worth trying, but it's making some rather costly concessions -- for instance, it uses strict evaluation by default in order to make the behaviour of higher order functions sane when you smash effects into them.
22:51:17 <chadz> yeah. the '@' operator.
22:51:27 <Cale> (so you really have to pay attention to evaluation order)
22:51:36 <hpaste>  Nafai pasted "Getting parse errors" at http://hpaste.org/6811
22:51:37 <jsnx> i think the "effects coercion" is not cool
22:52:20 <jsnx> but, at least it's tracked...
22:52:21 <chadz> sure, but i don't think that's too costly
22:52:26 <Cale> Nafai: Just so you know, handleLine is going to get the whole input and not just a line.
22:52:51 <Nafai> D'oh
22:52:59 <Nafai> That's probably my problem :)
22:53:07 <Cale> You can use  'lines'  to split it up.
22:53:30 <chadz> handleNew p = do
22:53:30 <chadz>     case p of
22:53:34 <chadz> ugh
22:53:43 <chadz> copy and paste in a windows vm is really confusing.
22:55:20 <chadz> how is 'http://nominolo.blogspot.com/2007/05/towards-better-error-handling.html' for a haskell error handling tutorial?
22:55:22 <lambdabot> http://tinyurl.com/2nrmps
22:56:27 <chadz> Cale: are there any DDC benchmarks?
22:56:32 <Cale> chadz: It's more directed at library authors than users, but it seems pretty sane.
22:57:43 <chadz> sane libraries are always a pro for users :)
22:58:22 <chadz> i think one of the largest problems with most haskell libraries is that they're lacking in consistancy or examples
22:58:27 * Nafai scratches head
22:58:43 <Cale> chadz: Usually looking at the types tells you most of what you need to know :)
22:58:44 <chadz> half the time you get things like: "foo :: String -> String -> a"
22:58:51 <chadz> and you have no idea which string is which.
22:59:11 <Cale> Uh, have you tried looking for the Haddock?
22:59:17 <chadz> yeah, that's in the haddock.
22:59:23 <Nafai> Is there a better function than interact to use here?
22:59:25 <Cale> Most Haskell libraries express that sort of thing there :)
22:59:34 <chadz> most haddock pages are rather minimal, in what I've discovered :)
22:59:40 <chadz> some do, for sure
23:00:02 <Cale> Nafai: You can just compose the function which you're applying interact to with lines
23:00:03 <jsnx> oh yeah, another part of my idea
23:00:19 <chadz> but, when you're working with something unfamiliar (I know nothing about http/cgi), and the library doens't do much to explain what routines do, it's a bit timeconsuming
23:00:38 <Cale> chadz: I've usually not had reason to complain, but it might just be which libraries I've tried.
23:00:47 <jsnx> the `raw` value in Module.Raw would be a of type Module.Raw.Data
23:01:05 <jsnx> so you could put it in type classes to do funky things with it
23:03:04 <Nafai> Cale: interact (handleLine . lines) ?
23:03:29 <Cale> Nafai: exactly
23:03:46 <hpaste>  Nafai annotated "Getting parse errors" with "Error" at http://hpaste.org/6811#a3
23:04:00 <Cale> Nafai: well, you might actually want  interact (unlines . map handleLine . lines)
23:04:04 <Cale> Depending.
23:04:34 <Cale> oh, it's already giving a list of lines?
23:04:45 <Nafai> That does what I want
23:05:05 <Cale> oh, I see, yeah
23:05:21 <Cale> (I was reading the type error wrong, it was giving types for lines)
23:05:47 <chadz> darcs.haskell.org up for anyone?
23:06:18 <Cale> Probably not, but I'll check
23:06:20 <chadz> galois seems to be dedzor
23:06:30 <Cale> It's been dead for hours
23:06:34 <chadz> ah.
23:06:46 <Cale> apparently people have been notified :)
23:06:56 <chadz> see, i can't even read haddock documentation :)
23:07:27 <Cale> Yeah, hackage.haskell.org also is down.
23:08:34 <Cale> The productivity of the Haskell world is extremely deflated until those servers come back :)
23:09:54 <dons> it went down just as work ended.
23:10:12 <dons> however, paul our guru admin knows about it, and will get to work early
23:10:17 <hpaste>  dolio annotated "ST in Agda (first go)" with "Safe ST in Haskell: the problem" at http://hpaste.org/6802#a3
23:13:15 <jsnx> woh, type families
23:13:17 <chadz> what happens when a cgi application prints to stdout?
23:13:23 <jsnx> what are those?
23:13:29 <chadz> does it go through the webserver's logsystem?
23:13:31 <jsnx> chadz: it gets sent to the client
23:13:45 <jsnx> chadz: stderr goes to the log system, i believe
23:13:55 <chadz> jsnx: ty
23:15:46 <jsnx> are type families a way to get pattern matching with sub-types?
23:17:19 <dolio> Type families are kind of like open pattern matching functions on types.
23:20:37 <chadz> hmm
23:21:07 <chadz> it segfaults for some odd reason.
23:21:23 <Cale> chadz: what segfaults?
23:21:23 <hpaste>  dolio annotated "ST in Agda (first go)" with "Type equality machinery" at http://hpaste.org/6802#a4
23:21:38 <chadz> my cgi code.
23:21:57 <Cale> chadz: Does it do any FFI?
23:22:50 <chadz> no. the takusen call from the cgi monad is dying.
