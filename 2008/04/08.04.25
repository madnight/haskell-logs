00:00:01 <dmwit> =)
00:03:34 <lispy> dmwit: Here is a puzzle for you
00:04:02 <dmwit> Gleeee!
00:04:08 <lispy> suppose I have a function, isFoo Foo = True; isFoo _ = False.  Can you make this so that isFoo Foo = True and isFoo undefined = False ?
00:04:53 <dmwit> Isn't it already?
00:05:13 <lispy> > let isFoo ~f = case f of Foo -> True; _ -> False in isFoo undefined
00:05:13 <dmwit> > let isThree 3 = True; isThree _ = False in isThree undefined
00:05:14 <lambdabot>   Not in scope: data constructor `Foo'
00:05:15 <lambdabot>  Exception: Prelude.undefined
00:05:35 <lispy> > let is3 ~f = case f of 3 -> True; _ -> False in isFoo undefined
00:05:36 <lambdabot>   Not in scope: `isFoo'
00:05:40 <lispy> > let is3 ~f = case f of 3 -> True; _ -> False in is3 undefined
00:05:42 <lambdabot>  Exception: Prelude.undefined
00:05:55 <dmwit> Ah.
00:06:06 <dmwit> It has to evaluate the first constructor to know whether or not it's Foo.
00:06:11 <dmwit> (or 3)
00:06:28 <dmwit> So no: that would be a solution to the halting problem.
00:06:52 <dmwit> Unless you allow catching exceptions. ;-)
00:07:02 <bd_> dmwit: nontermination isn't an exception :)
00:07:14 <lispy> Suppose I let you change the type signature of isFoo but keep spirit of the mechanics?
00:07:15 <dmwit> No, but "undefined" is an exception.
00:07:19 <dmwit> (@bd_)
00:07:32 <bd_> dmwit: I don't believe the formal semantics of haskell require that
00:07:56 <bd_> (ie, it would be legal to define undefined = undefined)
00:08:03 <dmwit> sure
00:08:05 <lispy> hmm...actually, I don't think the isFoo is my problem
00:08:20 <dmwit> Heh, real-world puzzles are my favorite. =)
00:08:46 <lispy> I have noticed that in darcs reading patches from pending is not lazy enough
00:08:56 <lispy> If you just want a summary, you have to wait for the whole patch to be read
00:09:12 <lispy> darcs add somehugefile; darcs whatsnew --summary <-- this will take ages
00:09:35 <dmwit> Maybe it is using strict IO?
00:09:45 <lispy> but if you didn't add the file, then darcs whatsnew --summary is fast
00:09:56 <lispy> no, darcs uses lazy IO everywhere
00:10:10 <lispy> But sometimes the functions built on top of the lazy IO are strict
00:10:58 <Korollary> profile?
00:12:07 <lispy> Yeah, I did that
00:12:47 <lispy> I have this in a do block: _pend <- read_pending repository, and _pend is not used anywhere
00:13:02 <lispy> If I remove that line, it's instantanious
00:13:12 <lispy> So read_pending has the problem
00:15:13 <dmwit> Wait, what's the bad effect if you take out that line?
00:15:46 <ziman> @pl \(x,y) -> (x+1,y)
00:15:46 <lambdabot> first (1 +)
00:15:58 <dmwit> first succ
00:16:02 <lispy> dmwit: well, if I remove that line then whatsnew is broken :)
00:16:19 <dmwit> Okay, I thought you said _pend is not used anywhere. =)
00:16:59 <lispy> Oh, sorry, I renamed pend to _pend
00:17:34 <lispy> hmm...actually, it's not instant with that line removed
00:18:54 <lispy> ah wel I should sleep
00:23:35 <ChaoticMind> want to write a function that takes a list of Integers and an Integer n and outputs the same list except+1 for the n'th element... can anyone help?
00:25:04 <glguy> what do you have so far?
00:25:44 <ChaoticMind> I'm not really sure how to tell it to add if it's the n'th element..
00:26:34 <glguy> keep a counter as you traverse
00:27:38 <ChaoticMind> can't "!!" be used to somehow acheive this/
00:27:47 <ChaoticMind> I was going to do it list comprehension
00:28:49 <dmwit> (!!) is only for reading, not writing.
00:29:01 <dmwit> A list comprehension could be made to work.
00:29:47 <ChaoticMind> well, i'll need to specify conditional add... how can i check the current itiration?
00:29:51 <dmwit> Philosophically, though, this function bothers me: it is a sign that the way you are writing your program is a little skewed.
00:30:06 <dmwit> ChaoticMind: Well, you could zip the list up with a counter.
00:30:08 <dmwit> Like so:
00:30:13 <dmwit> > zip "Hello!" [1..]
00:30:18 <lambdabot>  [('H',1),('e',2),('l',3),('l',4),('o',5),('!',6)]
00:31:02 <ChaoticMind> to what end?
00:31:23 <dmwit> That gives you a condition to check.
00:31:56 <dmwit> i.e. it tells "the current iteration," in your own words
00:31:59 <ChaoticMind> I want to update my "array", that's why i'm writing the function, do you think I should do it differently?
00:32:04 <ChaoticMind> aha
00:32:44 <mgsloan> > zip "Hello!" [1..]
00:32:45 <lambdabot>  [('H',1),('e',2),('l',3),('l',4),('o',5),('!',6)]
00:32:48 <mgsloan> doh
00:33:18 <mgsloan> > map (fst) . filter (even.snd) $ zip "Hello!" [1..]
00:33:19 <lambdabot>  "el!"
00:33:23 <mgsloan> :)
00:34:44 <dmwit> ChaoticMind: Well, it is a sign that you may be approaching the problem incorrectly.  But like all signs, there are some false positives.
00:34:57 <mgsloan> ChaoticMind: you might want to take a look at splitAt, in the prelude
00:35:01 <mgsloan> ?src splitAt
00:35:02 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
00:35:37 <ChaoticMind> okay dmwit
00:35:51 <mgsloan> but yeah, if you're mutating an item in a list, probably the wrong approach..
00:36:41 <ChaoticMind> okay ^^
00:36:46 <ChaoticMind> btw, what does $ do?
00:37:07 <mgsloan> it's a normal operator, but it's basically just syntactic sugar :)
00:37:10 <mgsloan> ?src ($)
00:37:10 <lambdabot> f $ x = f x
00:37:31 <ChaoticMind> i see
00:37:46 <mgsloan> without $, I would have had to wrap the rest of the expression in parenthesis
00:38:18 <ChaoticMind> aha okay, cool
00:41:35 <dmwit> ChaoticMind: Out of curiosity, what are you making (big picture)?
00:41:39 <dmwit> (If you don't mind sharing.)
00:42:04 <dmwit> We might be able to suggest an architecture that fits more naturally into the functional-programming paradigm.
00:43:08 <mgsloan> > let mutateIx f = (\a b -> a ++ ((f $ head b):tail b)) . splitAt in mutateIx (+1) 2 [1,2,3,4]
00:43:09 <lambdabot>  Couldn't match expected type `[a]'
00:43:36 <dmwit> You want \(a, b) -> ...
00:44:06 <mgsloan> oh right
00:44:29 <mgsloan>  > let mutateIx f = uncurry (\a b -> a ++ ((f $ head b):tail b)) . splitAt in mutateIx (+1) 2 [1,2,3,4]
00:44:36 <mgsloan> or that :P
00:44:41 <dmwit> You want less space at the beginning. ;-)
00:44:46 <mgsloan> yeah
00:44:56 <mgsloan> > let mutateIx f = uncurry (\a b -> a ++ ((f $ head b):tail b)) . splitAt in mutateIx (+1) 2 [1,2,3,4]
00:44:57 <lambdabot>  Couldn't match expected type `([a], [a])'
00:45:01 <mgsloan> bah well
00:45:51 <dmwit> > let mutateIx f n xs = let (b, e:es) = splitAt n xs in concat [b, [f e], es] in mutateIx (+1) 2 [1,2,3,4]
00:45:52 <lambdabot>  [1,2,4,4]
00:45:53 <dmwit> Surprise!
00:46:02 <mgsloan> hah, nice
00:46:17 <mgsloan> I suppose that is a nicer way to write it
00:46:38 <dmwit> > let mutateIx f = ((\(a, b) -> a ++ ((f $ head b) : tail b)) .) . splitAt in mutateIx (+1) 2 [1,2,3,4] -- maybe?
00:46:39 <lambdabot>  [1,2,4,4]
00:46:43 <ChaoticMind> I don't mind sharing dmwit, but it's part of a big homework, so it will need lots of explanation etc
00:47:20 <mgsloan> Oh, right, I was a bit loose and free with my composition there..
00:50:10 <dmwit> ?pl \f n xs -> take n xs ++ f (xs !! n) : drop (n + 1) xs
00:50:12 <lambdabot> ap (ap . ((++) .) . take) . (`ap` (drop . (1 +))) . (liftM2 (:) .) . (. flip (!!)) . (.)
00:50:16 <dmwit> eww
00:51:18 <dolio> @pl \f n xs -> let (h, e:t) = splitAt n xs in h ++ f e : t
00:51:19 <lambdabot> (line 1, column 16):
00:51:19 <lambdabot> unexpected "("
00:51:19 <lambdabot> expecting "()", natural, identifier or "in"
00:51:48 <dmwit> You can't do pattern-matching in ?pl.
00:51:54 <dolio> Yeah, yeah.
00:52:18 <dmwit> ?let split3 n xs = (take n xs, take 1 $ drop n xs, drop (n + 1) xs)
00:52:19 <lambdabot> Defined.
00:52:24 <dmwit> :t uncurry3
00:52:26 <lambdabot> Not in scope: `uncurry3'
00:52:52 <dolio> Wow, 3 traversals? :)
00:53:24 <dmwit> > let mutateIx f n = (\(a, b, c) -> concat [a, map f b, c]) . split3 n in mutateIx (+1) 2 [1..4]
00:53:25 <lambdabot>  [1,2,4,4]
00:53:30 <dmwit> No, *four* traversals. =)
00:55:17 <dolio> @pl \f n xs -> uncurry (++) . second (uncons id $ (:) . f) . splitAt n xs
00:55:17 <lambdabot> (((uncurry (++) .) .) .) . (. splitAt) . (.) . (.) . second . uncons id . ((:) .)
00:56:10 <mgsloan> it would be cool if sections could do stuff like (++(f x):) :: [a] -> [a] -> [a]
00:56:39 <dolio> @let uncons nil cons [] = nil ; uncons nil cons (x:xs) = cons x xs
00:56:40 <lambdabot> Defined.
00:56:44 <mgsloan> err i'm stupid lol
00:56:57 <mgsloan> I think it's become too late for reasonable haskelling :P
00:57:23 <dolio> let g f n xs -> uncurry (++) . second (uncons [] $ (:) . f) . splitAt n xs in g (+1) 5 [1..10]
00:57:33 <dolio> > let g f n xs = uncurry (++) . second (uncons [] $ (:) . f) . splitAt n xs in g (+1) 5 [1..10]
00:57:33 <lambdabot>  Couldn't match expected type `([a], [a])'
00:57:46 <dolio> Bah.
00:57:57 <dolio> Oh.
00:57:59 <Arnar_> @t catMaybes
00:58:00 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
00:58:13 <Arnar_> @type catMaybes
00:58:14 <lambdabot> forall a. [Maybe a] -> [a]
00:58:20 <Arnar_> wasn't there a shortcut for @type?
00:58:36 <dolio> > let g f n = uncurry (++) . second (uncons [] $ (:) . f) . splitAt n in g (+1) 5 [1..10]
00:58:36 <dmwit> :t
00:58:36 <lambdabot>  [1,2,3,4,5,7,7,8,9,10]
00:58:42 <dmwit> :t catMaybes -- Arnar_
00:58:44 <lambdabot> forall a. [Maybe a] -> [a]
00:58:49 <Arnar_> dmwit: thx
00:58:58 <dolio> @pl \f n = uncurry (++) . second (uncons [] $ (:) . f) . splitAt n
00:58:59 <lambdabot> (line 1, column 6):
00:58:59 <lambdabot> unexpected "="
00:58:59 <lambdabot> expecting pattern or "->"
00:59:04 <dolio> @pl \f n -> uncurry (++) . second (uncons [] $ (:) . f) . splitAt n
00:59:04 <lambdabot> ((uncurry (++) .) .) . (. splitAt) . (.) . second . uncons [] . ((:) .)
00:59:21 <dolio> How do you like them apples?
00:59:24 <mgsloan> lol
00:59:30 <mgsloan> pretty tasty i'd say
00:59:35 <mgsloan> even got some arrow foo goin on
01:01:19 <dmwit> :t foldl
01:01:21 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
01:02:10 <mgsloan> > let g f i = uncurry ((++).((f (x!!i):)) . splitAt i in g (+1) 5 [1..10]
01:02:11 <lambdabot> Unbalanced parentheses
01:02:29 <mgsloan>  > let g f i = uncurry ((++).((f (x!!i):))) . splitAt i in g (+1) 5 [1..10]
01:03:28 <dolio> Lucky me, my ubuntu upgrade is now scheduled to take a mere 3 hours, instead of 4 days.
01:03:50 <dmwit> > foldl' (flip (:)) [] "hello"
01:03:51 <lambdabot>  "olleh"
01:04:14 <dcoutts> kfish: no, that's just the kind of thing it cannot do, only package version checks atm
01:04:46 <mgsloan> > let g f i x=uncurry((++).((f (x!!i):))$splitAt i x in g (+1) 5 [1..10]
01:04:46 <lambdabot> Unbalanced parentheses
01:05:02 <mgsloan>  > let g f i x=uncurry((++).((f (x!!i):)))$splitAt i x in g (+1) 5 [1..10]
01:05:08 <mgsloan> > let g f i x=uncurry((++).((f (x!!i):)))$splitAt i x in g (+1) 5 [1..10]
01:05:09 <lambdabot>  [7,1,2,3,4,5,6,7,8,9,10]
01:05:14 <mgsloan> whoahh
01:05:16 <mgsloan> lol
01:06:09 <mgsloan> > let g f i x=uncurry(flip$(++).((f (x!!i):)))$splitAt i x in g (+1) 5 [1..10
01:06:10 <lambdabot>  Parse error at end of input
01:06:27 <mgsloan> > let g f i x=uncurry(flip$(++).((f (x!!i):)))$splitAt i x in g (+1) 5 [1..10]
01:06:28 <lambdabot>  [7,6,7,8,9,10,1,2,3,4,5]
01:06:32 <mgsloan> blah
01:06:39 <mgsloan> finch really blows for copy-pasting
01:07:27 <mgsloan> > let g f i x=uncurry(flip$(++).((
01:07:27 <lambdabot> Unbalanced parentheses
01:08:50 <mgsloan> > let g f i x=uncurry(flip$flip(++).((f (x!!i):).tail))$splitAt i x in g (+1) 5 [1..10
01:08:51 <lambdabot>  Parse error at end of input
01:09:01 <mgsloan> > let g f i x=uncurry(flip$flip(++).((f (x!!i):).tail))$splitAt i x in g (+1) 5 [1..10]
01:09:02 <lambdabot>  [1,2,3,4,5,7,7,8,9,10]
01:09:05 <mgsloan> yeesh
01:09:16 <mgsloan> after making a total asshat out of meself >.<
01:10:07 <glguy> what was your goal?
01:10:48 <mgsloan> find a very short and unreadable implementation of mutateIx
01:11:21 <dmwit> > let succIx n xs = let (b, m:e) = splitAt n xs in b ++ (1 + m) : e in succIx 5 [1..10]
01:11:22 <lambdabot>  [1,2,3,4,5,7,7,8,9,10]
01:11:54 <mgsloan> heh, yours would be shorter, too, with compressed spacing
01:11:57 <int-e> > let g f i x = uncurry((.(f(x!!i)).tail).(++))(splitAt i x) in g (+1) 5 [1..10]
01:11:57 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a] -> [a]
01:11:57 <lambdabot>     Pro...
01:12:44 <int-e> > let g f i x = uncurry((.(f(x!!i):).tail).(++))(splitAt i x) in g (+1) 5 [1..10]
01:12:45 <lambdabot>  [1,2,3,4,5,7,7,8,9,10]
01:13:01 <glguy> > let f 0 (x:xs) = (x+1):xs ; f n (x:xs) = x : f (n-1) xs in f 5 [1..10]
01:13:02 <lambdabot>  [1,2,3,4,5,7,7,8,9,10]
01:13:33 <mgsloan> lol, of course :P
01:13:42 <glguy> > let f 0(x:xs)=(x+1):xs;f n(x:xs)=x:f(n-1)xs in f 5 [1..10]
01:13:43 <lambdabot>  [1,2,3,4,5,7,7,8,9,10]
01:15:47 <mgsloan> victory of recursion over higher order functions?
01:16:41 <dmwit> > let f n xs = [if m == n then x else x + 1 | (m, x) <- zip [1..] xs] in f 5 [1..10]
01:16:42 <lambdabot>  [2,3,4,5,5,7,8,9,10,11]
01:16:54 <dmwit> Heh, exactly backwards.
01:17:15 <dmwit> > let mutateIx f n xs = [if m == n then f x else x | (m, x) <- zip [1..] xs] in mutateIx succ 5 [1..10]
01:17:16 <lambdabot>  [1,2,3,4,6,6,7,8,9,10]
01:17:29 <dmwit> Also, off-by-one. =P
01:18:15 <dmwit> ?let bool f t p = if p then t else f
01:18:16 <lambdabot> Defined.
01:18:26 <glguy> :t if'
01:18:27 <lambdabot> Not in scope: `if''
01:18:33 <mgsloan> I dunno, he asked for nth.  it did indeed increment the 5th
01:18:47 <mgsloan> so maybe all the others are off by one :P
01:18:56 <dmwit> > let mutateIx f n xs = [bool id f (m == n) x | (m, x) <- zip [0..] xs] in mutateIx succ 5 [1..10]
01:18:58 <lambdabot>  [1,2,3,4,5,7,7,8,9,10]
01:19:34 <int-e> > let splitAtConcat xs n ts = let (as, bs) = splitAt n xs in (as++ts,bs); mapHead f (x:xs) = f x:xs; mutateIx f n xs = let (as, bs) = splitAtConcat xs n (mapHead f bs) in as in mutateIx succ 5 [1..10]
01:19:35 <lambdabot>  [1,2,3,4,5,7,7,8,9,10]
01:21:03 <int-e> (splitAtConcat would make a nice primitive for a lot of knot tying fun)
01:21:03 <dmwit> ew
01:21:06 <glguy> ( scratchpad ) 10 [1,b] 5 cut unclip 1+ prefix append .
01:21:06 <glguy> { 1 2 3 4 5 7 7 8 9 10 }
01:24:20 <kfish> dcoutts, ok -- XMonadContrib breaks with ghc head because of Control.Arrow(>>>) atm :-(
01:25:53 <cedricshock> Is there anything more to combining haskell types than constructors/tuples and unions?
01:26:06 <mauke> recursion
01:26:30 <mgsloan> (\i -> map fst.groupBy((==Eq).comparing(compare i.snd)).zip[1..]) $ 3 [0,1,2,3,4,5,6]
01:26:35 <int-e> functions
01:26:49 <cedricshock> Ah yes, thanks. I'm not sure if I need to worry about recursion.
01:27:08 <dmwit> classes?
01:27:09 <mgsloan> probably won't work anyway, lol. that particular train of thought wasn't going anywhere fast.  Goodnight!
01:27:26 <dmwit> Dunno how general you want to be about "Haskell types."
01:27:43 <cedricshock> int-e: I think of the types of functions as sort of a set of built-in types.
01:28:23 <int-e> mgsloan: hmm. mutateIx f n xs = [if i == n then f x else x | (x, i) <- zip xs [0..]]
01:28:25 <cedricshock> dmwit: The sort of things you think of as objects, the sort of things people cover in the topic of "modeling"
01:29:16 <dmwit> Sum types?
01:29:23 <dmwit> (Is that what you call "unions"?)
01:29:29 <dmwit> data Foo = A | B
01:29:31 <cedricshock> Classes are an interesting problem. I'm not sure to what extent they'd be helpful.
01:29:57 <cedricshock> dmwit: Yeah, that's what I called unions. Union of the set of both types. I see types as sets all the time.
01:30:10 <dmwit> Okay, perfect.
01:30:27 <dmwit> In that case, yeah, Either and (,) get you pretty much everything.
01:30:45 <cedricshock> dmwit: That's what I suspected.
01:30:51 <dmwit> (modulo weird type-system extensions)
01:31:37 <cedricshock> Recursion is something of a problem, but it's more a language of expressing the types than an actual type problem.
01:32:37 <int-e> data BalancedBinaryTree a = Value a | Nest (BalancedBinaryTree (a,a))
01:33:05 <cedricshock> And classes aren't really necessary. They're really new less strictly functional union types with a set of functions that return functions.
01:34:39 <cedricshock> Or they are sum types bundled with a type with special methods of instantiation.
01:39:24 <cedricshock> So modeling is mostly a problem of deciding which things to normalize to. In haskell data types everything is pretty much normalized to tuples with a single exclusive or (Sum) constraint.
01:40:13 <dolio> Classes are kinds defined by specifying subsets of * of course.
01:41:28 <dolio> Or subsets of some higher kind, for constructor classes.
01:42:35 <cedricshock> I remember two kinds of class type statements in haskell, but not really clearly. There's the statement "every A is uniformly a B by", and another sort of statement that's slipping my mind.
01:45:23 <cedricshock> And the other is in order to make a B you must have something that's already an A, or something along those lines.
01:45:34 <dolio> Oh, I see what you're saying.
01:45:43 <dolio> 'instance Foo a => Bar a where ...' is the first.
01:45:48 <cedricshock> Yeah.
01:45:51 <dolio> 'class Foo a => Bar a where ...' is the second.
01:45:55 <cedricshock> yep
01:47:19 <cedricshock> The first says Foo is somehow a subset of bar, and the second says bar is a subset of foo, essentially deriving things in the opposite directions
01:49:41 <dolio> The former is less commonly used, I imagine, as it precludes all instances for things that aren't Foos (barring overlapping instances).
01:49:43 <dcoutts> kfish: you mean there's a new name and the old name removed rather than deprecated?
01:49:50 <quicksilver> the first says 'everything is a Bar, but only if it's a Foo'
01:50:03 <quicksilver> the second says 'to make a Bar you must first prove it is a Foo'
01:50:15 <quicksilver> (in the absence of overlaps)
01:50:17 <dolio> You'd be more likely to see 'instance Foo a => Bar (T a) where'.
01:51:14 <dcoutts> kfish: perhaps you can petition to keep the old name but deprecated, or just change the xmonad dependency to require an older version of that package
01:52:03 <dolio> Of course, I suspect the view that 'classes are kinds' goes out the window with multiparameter classes.
01:54:26 <cedricshock> I had a neat algebra system working somewhat based on overlapping everything forwards and backwards to ridiculous degrees. It all broke down around trying to get symbols like + to do nice things, and dealing with algebras with more than one operator.
01:54:46 <cedricshock> Which requires a new type per operator, which got ugly fast.
01:55:38 <cedricshock> Like the type constuctors in Monoid that are just used to keep track of which binary function goes with the monoid.
01:57:22 <cedricshock> I don't really get the kind's business yet, I should probably bury myself in them more.
01:58:13 <kfish> dcoutts, yeah it seems any code using >>> would break ...
01:59:11 <kfish> i don't know the reason for the change or anything though, just noticed it while setting up a new machine :-(
01:59:44 <cjs> How do I process a list in pairs of elements, e.g., first and second, then third and fourth, etc.?
02:00:23 <cedricshock> cjs: Use two constructors matching the list (one inside the tail of the other) and then recurse on the remaining tail.
02:00:56 <cjs> Ah, pattern matching. Of course.
02:01:01 <cedricshock> is_it_odd :: [a] -> Boolean
02:01:03 <dcoutts> kfish: oh, actually you're ok because the arrows package isn't a core package so you can just depend on the older one until you feel like upgrading
02:01:18 <cedricshock> is_it_odd [] = True
02:01:38 <cedricshock> is_it_odd (a: [] ) = False
02:02:02 <dcoutts> kfish: oh, no, that's not right, it's in base, Control.Arrow is in base but all the rest of Control.Arrow.* is in the arrow package
02:02:09 <cedricshock> is_it_odd (a : (b : t)) = is_it_odd t
02:02:12 <cedricshock> Something like that.
02:02:30 <dcoutts> kfish: so it would be a problem, I think in that case it's perfectly ok to ask for the old name but deprecated.
02:04:21 <dcoutts> kfish: ah! it's just that >>> was moved to Control.Category but not re-exported from Control.Arrow, so an easy fix I think, we just need to add a re-export
02:04:43 <kfish> dcoutts, ah, thanks for finding it :-)
02:04:59 <dcoutts> kfish: email Ross Patterson and ask
02:05:01 <kfish> i remember a conversation about moving the basic arrow operators
02:05:15 <dcoutts> and/or send a patch
02:08:36 <cjs> Ah, I ended up doing it a different way, anyway. But a question, in http://hpaste.org/7170 , what's the usual naming convention for things such as the chunk' function?
02:16:39 <kfish> hmm, Control/Arrow.hs is too pretty to patch :-( it reads like a math book
02:20:53 <johnnowak> glguy: what language was that before? '10 [1,b] 5 cut unclip 1+ prefix append .'?
02:21:09 <johnnowak> ah -- factor. nevermind.
02:21:33 <quicksilver> cjs: chunk_aux, chunk_helper, or chunk'
02:22:30 <quicksilver> cjs: if you're not fussed about the quality of the error messages, you could just case let Just("",match,...) =
02:22:42 <quicksilver> cjs: rather than naming 'before' and checking
02:23:16 <cjs> Yeah, I did that only to ge the error message.
02:23:52 <cjs> Though I wonder if a case would look better there.
02:27:18 <DRMacIver> Hm. Can anyone think of a good implementation for pickRandom :: (Gen a) => g -> Set a -> (g, a) ?
02:27:23 <DRMacIver> Ideally good means "not O(n)"
02:27:44 <DRMacIver> You can clearly do it if you have access to the structure of the set, but I don't think you can from the publicly available interface.
02:30:19 <dolio> let min = findMin s ; max = findMax s ; (r,g') = randomR (min, max) ; (u,l) = split r s in findMin l
02:30:59 <cedricshock> dolio: Is that O(ln(n))?
02:31:04 <DRMacIver> Sorry. Type signature screwup. That was meant to be Gen g
02:31:06 <dolio> Oh, actually, that should be (l,u) = ... and findMin u.
02:31:15 <DRMacIver> g is a generator. There's no way of randomly generating an a
02:31:22 <quicksilver> DRMacIver: based on what I think you meant, no.
02:31:27 <dolio> cedricshock: Probably.
02:31:33 <quicksilver> DRMacIver: set doesn't have a way to get fast access to member '6'
02:31:48 <quicksilver> it could, but it doesn't.
02:31:50 <DRMacIver> Well, it does. It just doesn't expose it in the module interface.
02:31:51 <quicksilver> maybe that's a bug in Data.Set.
02:31:55 <quicksilver> yeah, that's what I meant :)
02:32:04 <DRMacIver> But I don't actually care what the index of the element is
02:32:10 <DRMacIver> I just want "some random element of the set"
02:32:13 <quicksilver> I appreciate that.
02:32:18 <DRMacIver> And I was vaguely hoping there might be a trick to get at it. :)
02:32:25 <DRMacIver> Although I'm pretty sure you're right
02:32:25 <quicksilver> I was just pointing out the central thing which makes it impossible, imo.
02:32:42 <cedricshock> That's not really a bug in the interface, that really doesn't belong in the interface.
02:32:42 <quicksilver> you'd have better luck with Seq.
02:32:49 <quicksilver> cedricshock: why not?
02:33:07 <quicksilver> what's wrong with index :: Set a -> Int -> Maybe a
02:33:15 <quicksilver> it's a bit strange, perhaps, but I don't think it's wrong.
02:33:26 <DRMacIver> quicksilver: I know. I've done something similar with Sequence. I kinda needed this to be Set though.
02:33:33 <cedricshock> The only thing I can think of that would ever need an unspecified element of the set is something non-deterministic. I.e. exactly this problem.
02:34:17 <quicksilver> I might want the median element of a set.
02:34:34 <cedricshock> quicksilver: It adds a strange constraint to the implementation of set.
02:34:38 <ziman> it relies on the fact that the set is implemented as an indexable structure (a tree)
02:34:41 <DRMacIver> Given Data.Set is specified to be in a particular order it seems reasonable to get an index into it.
02:34:42 <cedricshock> Hmm, quantiles. That is interesting.
02:34:52 <sjanssen> quicksilver: adding such a function does constrain the implementation of Data.Set quite a bit
02:34:56 <DRMacIver> For a general Set as an abstract datatype it doesn't.
02:35:07 <quicksilver> cedricshock: Data.Set already specifies that it has an Ord constraint and O (lg n) findMin and findMax
02:35:16 <quicksilver> and O(n) toAscList
02:35:17 <sjanssen> ie. it must be a size balanced (or otherwise size cached) tree, AVL, red-black, etc. are are ruled out
02:35:26 <dolio> findMin u is probably the wrong result, too, because it could be empty. You need to try one and if that fails, try the other.
02:35:34 <quicksilver> sjanssen: size-cached AVL isn't ruled out.
02:35:36 <cedricshock> Yeah, so does the showTree function. I that's there then all sorts of strange things can be.
02:35:42 <DRMacIver> However I think my function makes sense on a general Set even if it's quite hard to implement for some.
02:36:11 <sjanssen> quicksilver: sure, if you want to pay that price just to support the index function
02:36:41 <cedricshock> DRMaclver: I agree, any finite set can have your function.
02:37:26 <dolio> Looking at the documentation, that code above should be O(log n).
02:37:30 <DRMacIver> cedricshock: It's kinda hard to implement in a way that's simultaneously fair and efficient for some of them.
02:37:52 <cedricshock> Yeah, it has the same "cost" as the index function.
02:37:55 <dolio> Given your original constraint (that the elements are in the Random class).
02:38:17 <dolio> Er, I suppose it wasn't.
02:38:25 <DRMacIver> dolio: My original constraint wasn't that the elements were in the Random class. It was that the elements where in the Gen class, which was a typo. :)
02:38:29 <dolio> But I'll assume they were. :)
02:38:41 <DRMacIver> dolio: I'm not 100% sure your method is fair.
02:38:58 <dolio> No, it isn't.
02:39:09 <DRMacIver> dolio: I think it doesn't work if the set is biased towards either side
02:39:11 <cedricshock> It's not. His method is uniform nearest neighbor.
02:39:15 <DRMacIver> ok
02:39:24 <dcoutts> kfish: I've sent off a patch
02:39:30 <dcoutts> kfish: it's only two lines
02:39:31 <dolio> [1, 99, 100, 101] will pick 1 or 99 most of the time (depending on which you try first).
02:39:36 <DRMacIver> ok
02:40:08 <DRMacIver> cedricshock: Having O(n) implementations of either index or pickRandom seems not unreasonable to me though, and there are obvious implementations of both.
02:40:27 <DRMacIver> So the general set contract could fall back to those if it's not a structure which efficiently supports the operation
02:40:50 <cedricshock> You can do O(n) already.
02:40:52 <DRMacIver> I know
02:40:59 <cedricshock> O(ln(n)) is the problem.
02:41:16 <DRMacIver> What I'm saying is that it's ok to add these to a general Set type without constraining the implementation if they're allowed an O(n) implementation
02:41:24 <DRMacIver> ANd then ones which can offer it efficiently should
02:41:27 <cedricshock> Ahh.
02:41:51 <dolio> Do tries have an efficient index?
02:41:59 <dolio> I suppose they might when size cached.
02:42:16 <DRMacIver> I think basically any size cached tree does, any non size cached tree doesn't.
02:42:18 <quicksilver> size cached would seem to add a lot of weight to a trie?
02:42:26 <quicksilver> because tries have a very high branching factor
02:42:27 <quicksilver> IYSWIM
02:42:31 <dolio> Yeah.
02:42:32 <DRMacIver> Yeah
02:42:41 <quicksilver> fingertrees, on the other hand
02:42:50 <quicksilver> support fast index.
02:43:00 <quicksilver> faster closer to the edges, too
02:43:05 <quicksilver> which is clever, but weird :)
02:43:06 <dolio> There's a Control.Category now?
02:43:10 <DRMacIver> Basically size cached trees and closed hashing are the only things I can think of where you can get a better implementation for this.
02:43:19 <dcoutts> dolio: yep, class with id and (.)
02:43:39 <dolio> Huh. I guess I'll have to pull that out of my local copy of category-extras.
02:44:07 <DRMacIver> Nearly size balanced trees and open hashing allow almost fair efficient implementations.
02:44:13 <DRMacIver> And everything else you're back to O(n) :)
02:44:44 <cjs> Well that's kinda weird. I was trying to write a text-crunching program in Ruby, found it difficult to get it perfectly correct, and ended up writing it in Haskell instead. http://hpaste.org/7171
02:45:21 <DRMacIver> You're totally ending up on the HWN quote page with that one. :)
02:45:30 <cedricshock> What's the cost of using cardinality on a subset? O(n)?
02:46:00 <DRMacIver> Depends how you specify the subset I suppose
02:46:19 <cedricshock> It'd have to be the same as the cost of figuring out how many are on each side in the tree.
02:46:20 <johnnowak> cjs: not sure what's weird about that
02:46:30 <kfish> dolio, Control.Category is awesome
02:46:41 <cjs> perl and ruby and crap are supposed to be the ones good for little text processing scripts.
02:46:46 <dolio> It needs some opposite category action.
02:47:07 <yitz> @remember cjs  I was trying to write a text-crunching program in Ruby, found it difficult to get it perfectly correct, and ended up writing it in Haskell instead.
02:47:07 <lambdabot> Good to know.
02:47:51 <mauke> what does the program do?
02:48:15 <dolio> Man, it was around last November? I'm behind the times.
02:48:31 <johnnowak> cjs: crap being the operative word
02:48:33 <mauke> mapM putStrLn x better written as putStr $ unlines x
02:48:42 <mauke> also, mapM_
02:49:06 <quicksilver> also, mapM ... (map ...) can be fused
02:49:14 <quicksilver> mapM_ (putStrLn . show) flows
02:49:21 <quicksilver> that's a question of taste I guess
02:49:22 <mauke> which is mapM_ print flows
02:49:48 <quicksilver> and then you won't need the return ()
02:49:49 <dcoutts> it's not just a question of taste, it's also performance
02:50:05 <dcoutts> the nicer one is also likely to be faster
02:50:15 <dcoutts> ie putStr (unlines x)
02:50:41 <mauke> what does matchRegexAll do?
02:50:43 <cjs> mauke: it parses the data out of tcpflow -c output. See the hpaste above.
02:50:57 <sjanssen> the lines are also guaranteed to be printed in order with the single putStr
02:50:58 <ChaoticMind> how can I do: If there is an item in list x obeying a condition, return True. Example, how can I, for a list x of integers, do: If x contains 1, return true?
02:51:10 <mauke> :t elem
02:51:11 <sjanssen> (not so when there are multiple threads writing to stdout)
02:51:12 <cjs> matchRegexAll returns either Nothing or Just (beforeMatch, match, afterMatch, [submatches]).
02:51:12 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
02:51:38 <mauke> where submatches = capture groups?
02:51:39 <aleator> ChaoticMind: use "any"
02:51:50 <ChaoticMind> thanks i'll look into it :)
02:52:38 <cjs> Yeah, I like mapM_ (putStrLn . show) flows.
02:52:40 <quicksilver> > any (==1) [2,3,4,1,5,6]
02:52:41 <lambdabot>  True
02:52:49 <quicksilver> although elem is of course this specific case
02:52:53 <quicksilver> but any is generally handy
02:53:00 <cjs> mauke: right.
02:53:04 <ChaoticMind> cool cool, thanks!
02:54:22 <sjanssen> cjs: at least use mapM_ print
02:54:57 <cjs> Actually, that show is sometimes replaced with netdata, that's why it's separate.
02:57:16 <yitz> dcoutts: are you saying that putStr . unlines is faster than mapM_ putStrLn?
02:57:51 <dcoutts> yitz: it has the potential to be faster, especially with bytestring, mainly due to lower Handle locking overheads
02:58:24 <yitz> ah, I see. too bad. to my eye mapM_ is definitely nicer.
02:59:29 <dcoutts> yitz: you'll have to retrain your eye :-)
02:59:48 <quicksilver> it's better to make one 'syscall'
02:59:50 <quicksilver> with a big string
02:59:51 <cjs> dcoutts: Interesting, I'd not thought of that.
02:59:51 <dcoutts> putStr $ unlines [ some nice list comprehension... ]
02:59:53 <yitz> funny, that's what my eye doctor says also.
02:59:56 <quicksilver> than make lots of little syscalls.
03:00:07 <quicksilver> even though putStr isn't really a syscall
03:00:11 <quicksilver> that's not a bad way of thinking of it
03:00:12 <dcoutts> quicksilver: though the handle will also do buffering
03:00:24 <dcoutts> but there is still the cost of locking the Handle
03:00:26 <quicksilver> dcoutts: yeah, I know, it was a bit of a metaphor rather than direct truth :)
03:01:10 <dcoutts> but it's also nicer from the pov of doing all IO at the top level and not letting it creep into pure code
03:01:14 <mauke> my $ipaddr = join '.', ("[0-9]{3}") x 4; my $port = '\.[0-9]{5}'; my $sourceDest = qr/$ipaddr$port-$ipaddr$port: /;  my $input = do {local $/; <STDIN>}; my @flows = split /^$sourceDest/m, $input; for my $i (map $_*2, reverse 0 .. $#flows/2) { if ($i > 1 && $flows[$i] eq $flows[$i - 2]) { $flows[$i - 1] .= $flows[$i + 1]; splice @flows, $i, 2; } }
03:01:23 <mauke> oops, that came out longer than expected
03:01:29 <dcoutts> heh
03:01:55 <yitz> I hate explicitly constructing a string full of platform-dependent EOL chars rather than using putStrLn, which says put them on separate lines in a platform-independent way that may not even use EOL chars at all.
03:02:09 <mauke> er, what?
03:02:37 <mauke> there is a portable end-of-line abstraction: it's called '\n'
03:02:44 <yitz> for unix
03:02:48 <dcoutts> and windows
03:02:50 <mauke> no, for everything
03:02:56 <yitz> not everything, no
03:03:00 <dcoutts> and even old macos
03:03:02 <mauke> everything with a C compiler
03:03:09 <mauke> that includes unix, windows, mac os, vms, ...
03:03:14 <dcoutts> yitz: you're thinking of binary rather than text files
03:03:14 <sjanssen> yitz: the runtime translates \n to the appropriate sequence of escape codes when the handle is in text mode
03:03:31 <cjs> mauke: I think your version is broken.
03:03:38 <mauke> :-(
03:03:55 <yitz> the old ASCII convention of "control characters" mixed into the same stream with text is a big kluge. It's not used in EBCDIC, for example.
03:04:24 <yitz> sjanssen: yes. ugly kluge, but it works.
03:04:25 <dcoutts> how does ebcdic represent multiple lines of text?
03:04:31 <cjs> It's subtle, but it's one thing that killed me in Ruby. Each flow string after the first has a newline prepended.
03:04:41 <yitz> dcoutt: it doesn't. it represents text.
03:04:49 <mauke> cjs: that's what the /^.../m is for
03:04:57 <dcoutts> yitz: no line breaks at all, anywhere in a text file?
03:05:02 <atsampson> it's less kludgy than what preceded ASCII, though: http://massis.lcs.mit.edu/telecom-archives/archives/technical/western-union-tech-review/18-2/p050.htm
03:05:04 <lambdabot> http://tinyurl.com/5crovd
03:05:21 <yitz> text is text. "lines" is an application-dependent concept.
03:06:14 <mauke> obviously, but does every application use its own representation?
03:06:20 <dcoutts> I like my text files with paragraph breaks, just like I like sentences with full stops and quotation marks
03:06:44 <yitz> mauke: groups of applications with the same concept of "line" can share an encoding, I suppose.
03:07:10 <sjanssen> yitz: why should '\n' receive any status different from ' '?
03:07:12 <mauke> so ... that's exactly what unix and windows do
03:07:21 <yitz> dcoutts: <p>That's fine, I also like paragraphs sometimes.</p>
03:07:30 <mauke> (unix uses LF, windows CR LF to encode the end of a line)
03:07:47 <cjs> Is there an equivalant of "print" or ruby's "inspect" in perl?
03:08:01 <mauke> cjs: use Data::Dumper; print Dumper(\@flows)
03:08:13 <cjs> mauke: you do have the bug. You need to remove that newline, because it's not part of the data.
03:08:23 <yitz> sjanssen: ' ' represents a physical piece of type that is set into the form on the printing press. '\n' doesn't.
03:08:36 <mauke> oh
03:09:17 <sjanssen> yitz: does that have any relevance at all when we're using a computer?
03:10:34 <yitz> sjanssen: it's just a metaphor, to show that ' ' is a natural part of the text flow in the Latin alphabet and '\n'. Anyway, it's not really relevant, because '\n' is not going away anytime soon. :)
03:11:08 <sjanssen> I don't see what you'd propose instead
03:11:17 <yitz> I was just saying why I think putStr . unlines is uglier than mapM_ putStrLn.
03:11:29 <cjs> mauke: also, I suspect that it may not error out properly on invalid input...
03:11:55 <ChaoticMind> I have a list of list of integers a [[Int]], and a list of integers b [Int]]. I want to check if there is an elemnent in a which has [b!!0, _, b!!1-1]. I can't figure it out! Apparently, we can't use _ in checking, but I don't want to care about the second element... any tips?
03:13:13 <ChaoticMind> I tried it with elem, but it didn't accept underscores
03:13:18 <yitz> sjanssen: banish control characters from Unicode, that should be only for text (i.e., glyphs in various languages). Use your favorite layout language if you want layout.
03:13:30 <yitz> but no, it's not going to happen. :)
03:14:03 <kfish> yitz, is switching from RTL to LTR a control character or layout?
03:14:46 <yitz> kfish: right, that's another bug in Unicode imo. A much messier one. In fact, I know some of the history about how that one got in there.
03:18:05 <yitz> Summary: in the days when MS Word was in the final stages of trouncing all of its competitors in the US, an Israeli startup came out with Accent, the first fully multi-lingual wysiwyg word processor. MS saw this as a threat, so hired away a lead developer. Much of their early work, combined with the ISO stuff, became what is now Unicode.
03:19:43 <AshyIsMe> didnt the plan9 guys come up with unicode?
03:19:58 <mauke> no, they invented utf-8
03:20:27 <yitz> AshyIsMe: I don't think Accent/MS invented Unicode, but that is where all the ugly RTL stuff came from.
03:21:06 <AshyIsMe> oh
04:00:16 <mm_freak_work> hmm…  i've written the RC4 key schedule, a monadic function muting an STArray
04:00:20 <mm_freak_work> i don't like it =/
04:01:16 <mm_freak_work> http://hpaste.org/7172
04:02:17 <mm_freak_work> i'm pretty sure there is a much easier way to do it
04:06:31 <DRMacIver> Vaguely related to my earlier speculation about randomness - it actually seems really hard to come up with a data structure which permits a fast method for removing a random element. Things which have log(n) concatenation, indexing and splitting seem to be the only real candidates.
04:06:57 <DRMacIver> In particular none of the standard mutable datastructures seem to be able to do it.
04:11:46 <mm_freak_work> DRMacIver: if there is an indication of the number of elements in the data structure and it has O(1) indexing, it should be easy
04:12:13 <quicksilver> lots of structures don't support removing of random elements
04:12:16 <quicksilver> or not in a sensible way
04:12:21 <quicksilver> s/random/arbitrary/
04:14:22 <mm_freak_work> quicksilver: MArray a (Maybe e) m
04:14:29 <mm_freak_work> but then adding elements is O(n)
04:17:28 <quicksilver> mm_freak_work: *nod*
04:17:42 <quicksilver> mm_freak_work: for certain kinds of tree structure it's not obvious what removal means
04:17:48 <quicksilver> there might be more than one way to patch it back together
04:17:51 <quicksilver> that's what I was getting at
04:18:56 <mm_freak_work> yeah, true…  it was just an example of a structure with O(1) random element removal
04:20:24 <DRMacIver> mm_freak_work: I'm thinking of actually removing the element this time, not just fetching it
04:21:00 <DRMacIver> So O(1) indexing clearly isn't enough - e.g. an array
04:22:52 <Bonus> > let consecutive = groupBy (\x y -> y-x == 1)
04:22:53 <lambdabot>  Parse error at end of input
04:23:06 <Bonus> wtf
04:23:25 <mm_freak_work> DRMacIver: yes, and an array of (Maybe e) is a possibility, but it turns adding elements into an O(n) operation, which likely isn't what you want
04:23:58 <quicksilver> well there are standard array resizing tricks
04:24:07 <quicksilver> to make adding elements amortized O(lg n)
04:24:19 <quicksilver> or is it amortized O(1)? I forget the maths
04:24:43 <mm_freak_work> quicksilver: O(1) if you regard memory reorganizing as a single step
04:25:37 <DRMacIver> mm_freak_work: It turns indexing into an O(n) operation as well, so you no longer have the efficient "grab a random element" operation.
04:25:49 <DRMacIver> Although I guess you could grab at random until you find something non-empty
04:26:11 <wjt> @let consecutive = groupBy (\x y -> y-x == 1)
04:26:14 <DRMacIver> ok. That works.
04:26:14 <lambdabot> Defined.
04:26:26 <wjt> > consecutive [1,3,4,5,7,8,9,77,79,373]
04:26:28 <lambdabot>  [[1],[3,4],[5],[7,8],[9],[77],[79],[373]]
04:27:36 <mm_freak_work> DRMacIver: sometimes this is sufficient…  you can implement a compactArray function, which closes the Nothing holes and marks the array as compact
04:28:18 <DRMacIver> Yeah. ok. That works. :)
04:28:29 <DRMacIver> Although it's a bit of an odd structure.
04:28:44 <mm_freak_work> yeah, but it works…  i've used it quite a few times in C =)
04:31:48 <Bonus> @let consecutive = (map . map) snd . groupBy (\(x, i) (y, j) ->  x-i == y-j) . zip [0..]
04:31:49 <lambdabot> <local>:5:0:     Multiple declarations of `L.consecutive'     Declared at: <l...
04:31:54 <Bonus> @let consecutive2 = (map . map) snd . groupBy (\(x, i) (y, j) ->  x-i == y-j) . zip [0..]
04:31:54 <lambdabot> Defined.
04:31:57 <Bonus> ah there we go
04:32:09 <Bonus> > consecutive2 [1,4,5,6,9,10,11,13]
04:32:10 <lambdabot>  [[1],[4,5,6],[9,10,11],[13]]
04:32:12 <Bonus> kewl
04:40:01 <ChaoticMind> I want to make a function that:
04:40:03 <ChaoticMind> takes [[2,4,5], [1,1,4], [4,5,10], [1,4,5], [4,1,5]], and outputs [2,4,5]
04:40:03 <ChaoticMind> ie removes elements where x!!0 == x!!0 && (x!!2 == x!!3 or x!!3==x!!2)
04:40:03 <ChaoticMind> trie with list comprehension [x| x<-a, y <-a, (condition)], but it doesn't work because it woult output [2,4,5] 4 times, since it tests it against all the others as opposed to once.
04:40:10 <ChaoticMind> any hints?
04:41:26 <ChaoticMind> (sorry about copying multiple lines)
04:41:49 <ulfdoz> ChaoticMind: For a one-liner, filter should do the trick.
04:41:57 <ulfdoz> in about O(n^2)
04:43:49 <Bonus> yeah just filter (\lst -> lst!!0 == lst!!0 && (lst!!2 == lst!!3 or lst!!3==lst!!2))
04:44:35 <ulfdoz> Bonus: Hint, there's probably an instance Eq a => Eq [a]
04:44:47 <mm_freak_work> that's highly redundant, isn't it?
04:44:57 <Bonus> hmm
04:45:27 <mm_freak_work> (lst!!0 == lst!!0 && (lst!!2 == lst!!3 or lst!!3==lst!!2)) should be equivalent to lst!!2 == lst!!3
04:46:09 <Bonus> yeah lst!!0 == lst!!0 will always evaluate to true
04:46:26 <Bonus> so you can drop it because it's being used with an &&
04:46:44 <mm_freak_work> yes, and (==) is commutative
04:46:54 <Bonus> yase
04:46:55 <mm_freak_work> a == b => b == a
04:46:57 <ChaoticMind> yeah i was trying to play around with filter, but i'm still new and struggling with the syntax
04:47:04 <ChaoticMind> thanks ^^
04:47:07 <Syzygy-> ?check \lst -> ((lst!!0 == lst!!0 && (lst!!2 == lst!!3 or lst!!3==lst!!2))) === (lst!!2) == (lst!!3)
04:47:10 <lambdabot>   Not in scope: `==='
04:47:14 <Bonus> locals lst = (map . map) fst . groupBy (\(a, b) (c, d) -> a `compare` b == c `compare` d) . zip lst . tail $ lst
04:47:20 <Bonus> i have this function
04:47:23 <Syzygy-> Pfeh. How -did- you use quickcheck again?
04:47:30 <mm_freak_work> ChaoticMind: your mind must be pretty chaotic…  have a close look at your condition =)
04:47:47 <Bonus> what it's supposed to do is divide a list into several parts where it's ascending and descending and then ascending again etc.
04:47:51 <Bonus> only it shops off the last element
04:47:55 <Bonus> because of the zip with tail
04:48:20 <ulfdoz> What about \lst@(x:xs) -> (replicate (length lst) x) == lst
04:48:21 <mm_freak_work> @pl \x -> x!!2 == x!!3
04:48:21 <lambdabot> liftM2 (==) (!! 2) (!! 3)
04:48:27 <ulfdoz> except, that it may not terminate.
04:48:53 <mm_freak_work> filter (\x -> x!!2 == x!!3)
04:49:16 <ChaoticMind> mm_freak_work, that was a sample condition, mine is actually (x!!0 /= y!!0 || (x!!1 /= y!!2+1 && x!!2 /= y!!1-1))
04:49:47 <mm_freak_work> that's a pretty different condition…  where does that 'y' come from?
04:49:48 <ulfdoz> Functions and, zipWith, curry and == could also do the trick.
04:50:07 <ChaoticMind> x and y are the same list*
04:50:26 <Bonus> thats a different condition from the one you wrote up there :[
04:50:38 <mm_freak_work> then you should clean up your condition first, and then just use 'filter'
04:50:58 <ChaoticMind> as i mentinoed before i was trying to make it with x<-a, and y<-a, a being my function input. (list of lists)
04:52:06 <ChaoticMind> I... didn't think it would matter.. :s
04:52:34 <mm_freak_work> your condition reduces to:  x!!1-1 != x!!2
04:53:04 <mm_freak_work> myFilter = filter (\lst -> lst!!1 - 1 /= lst!!2)
04:53:16 <mm_freak_work> uhm…  replace (!=) by (/=) of course =)
04:54:14 <yitz> mm_freak_work: have you been using Python again? tsk, tsk.
04:54:43 <ChaoticMind> mm it does
04:54:47 <mauke> Ｃ
04:54:56 <mm_freak_work> yitz: C
04:57:01 <Vq^> yitz: doesn't all python-programmers use <>? :o)
04:57:20 <pjd_> Vq^: of course not
04:57:31 <Bonus> no python has !=
04:57:42 <Bonus> i think <> is deprecated
04:57:49 <mm_freak_work> i once tried to learn python, but found it too complex
04:57:49 <Japsu> what, does python have <> :O
04:57:57 <Bonus> python too complex?
04:57:57 <Japsu> it does :o
04:57:59 <Japsu> evil
04:58:02 <pjd_> Japsu: not anymore, with Python 3
04:58:04 <Japsu> I've never known there's a <>
04:58:26 <mm_freak_work> Bonus: yes, a lot of memorizing before you can start
04:58:29 <Japsu> pjd_: bah, python 3 isn't here
04:58:31 <Japsu> yet
04:58:42 <pjd_> Japsu: define "here"
04:58:44 <mm_freak_work> i like about haskell that it's pretty simple
04:58:54 <Japsu> pjd_: released
04:58:54 <mm_freak_work> (not to be confused with "easy")
04:58:56 <Bonus> i don't know i think they're both pretty simple
04:59:00 <pjd_> Japsu: there have been several alpha releases
04:59:01 <Bonus> especially compared to C++ or C#
04:59:01 <Japsu> "current as of today"
04:59:12 <pjd_> beta's coming up
04:59:15 <mm_freak_work> Bonus: i found python more complex than C++
04:59:18 <Japsu> pjd_: which are utterly irrelevant for the larger picture as nobody uses them in production
04:59:24 <Bonus> that's preposterous
04:59:53 <mknod> hi, I have just upgraded to Ubuntu Hardy (GHC 6.8.2) and now the ghci interactive mode is terribly slow, any people with the same problem?
05:00:13 <Japsu> once python 3 is officially declared stable and most of the relevant libraries are ported, then we can say "python does not have <> any more" ;)
05:00:13 <Bonus> std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >
05:00:20 <Japsu> MY EYES :EEEEE
05:00:21 <mm_freak_work> but maybe i just didn't like its syntax and semantics (like the weird constructure/destructor names and stuff)
05:00:22 <Bonus> that's c++
05:00:30 <Japsu> eww, icky templates
05:00:38 <Bonus> yeah heres a cool link about c++ http://yosefk.com/c++fqa/defective.html
05:00:39 <lambdabot> Title: C++ FQA Lite: Defective C++
05:00:47 <mm_freak_work> mknod: can't confirm that…  i'm using GHC 6.8.2, too
05:00:54 <Bonus> i think python is pretty straightforward, doesn't have a lot of syntax and that everything's an object thing works well
05:01:09 <Japsu> yeah
05:01:20 <mm_freak_work> Bonus: i won't go into a flamewar about python or C++…  it's my personal taste
05:01:26 <mm_freak_work> i like C++ more than python, period
05:01:27 <mknod> mm_freak_work: ubuntu hardy or another distribution?
05:01:28 <Bonus> yeah of course
05:01:36 <cpoucet> :t even
05:01:37 <Bonus> i wasn't insinuating such a thing
05:01:40 <lambdabot> forall a. (Integral a) => a -> Bool
05:01:44 <Bonus> everyone's free to like what they like
05:01:47 <mm_freak_work> mknod: gentoo linux and arch linux…  both without problems
05:02:06 <yitz> Bonus, Jaspu: I agree that Python is very simple, but those side effects will get you every time.
05:02:22 <mknod> ok, maybe is this compilation only, or maybe it's my computer
05:02:31 <Bonus> i take up a mostly functional style with python
05:02:39 <Bonus> with the itertools and generators and such
05:02:52 <Bonus> so i try to keep the side effects to a minimum
05:03:08 <yitz> e.g.: def foo(x=[]): x.append("bar"); return x
05:03:20 <mm_freak_work> well…  one thing i've never seen in other languages (other than Clean):  building infinite lists and using a finite portion of it…  i love it =)
05:03:24 <yitz> Bonus: yes, that helps
05:03:31 <mm_freak_work> and not only with data, but with everything, including computations
05:03:38 <Bonus> yeah
05:04:09 <Bonus> what i love about haskell the most is the partial function application
05:04:12 <mm_freak_work> build an infinite list of computations, filter it and print the result of the remaining computations (which even doesn't need to be finite at all)
05:04:24 <Bonus> and of course the lazyness
05:06:09 <mm_freak_work> that is laziness in its greatest form
05:06:48 <mm_freak_work> no other language would feature such a thing as getContents…  take the content of the file and feed it into a parser
05:08:26 <pjd_> mm_freak_work: probably not the best of examples
05:09:04 <pjd_> getContents is really unsafeGetContents
05:09:18 <quicksilver> getContents is lazy in a subtly different sense of lazy
05:09:22 <quicksilver> subtly but importantly.
05:09:41 <mm_freak_work> true…  it can fail later
05:09:48 <pjd_> right, lazy I/O != lazy evaluation
05:10:00 <mm_freak_work> (i always asked myself where the exception is gonna be thrown _if_ it fails)
05:10:19 <pjd_> mm_freak_work: also, in Python, files are lazy iterators by default
05:12:55 <mm_freak_work> pjd_: so there is an analog to (hGetContents h >>= hPutStr h) in python?
05:14:22 <mm_freak_work> (that's how i implemented an echo server, and where imperative people told me that it cannot work)
05:15:00 <pjd_> mm_freak_work: while True: h.write(h.read()) ?
05:15:12 <pjd_> well, assuming you have a forever around that Haskell
05:15:57 <mm_freak_work> pjd_: that's different…  it's a read/write-loop, isn't it?
05:17:43 <mm_freak_work> pjd_: well, it's the same internally, but semantically it's completely different…  the haskell version "reads all data from h and writes it back to h"
05:21:33 <pjd_> mm_freak_work: you could do something like h.writelines(h)
05:22:14 <mm_freak_work> pjd_: isn't that still a loop, semantically?
05:22:16 <pjd_> but an important point is that the Haskell version only works by virtue of breaking referential transparency
05:22:46 <pjd_> mm_freak_work: only in the same sense that the Haskell version is still a loop, semantically :)
05:22:52 <mm_freak_work> pjd_: in what way?
05:23:32 <mm_freak_work> the haskell version is a lazily built list, semantically…  it's built when needed =)
05:23:52 <pjd_> mm_freak_work: right, so are Python iterators
05:25:11 <mm_freak_work> dunno
05:25:35 <mm_freak_work> your examples rather looked like loops
05:26:07 <EvilTerran> there's a pretty direct relationship between lazy lists and loops
05:26:26 <EvilTerran> particularly if you're looping with an iterator
05:26:51 <pjd_> mm_freak_work: the "while True" version was a loop
05:27:24 * Beelsebob_ ponders if he's in a conference call with ivan 
05:27:50 <pjd_> mm_freak_work:  the "writelines" wasn't;  writelines lazily consumes the iterable you pass to it
05:28:56 <pjd_> mm_freak_work: you could point out that writelines involves a loop internally, but that's the same as hPutStr looping over the sequence you pass to it
05:30:05 <pjd_> anyway, that Haskell is still a bad example, because referentially-transparent Haskell would indeed read the whole handle before starting to write any of it
05:31:17 <pjd_> so it only works as an echo server to the extent that it relies on side effects, like imperative code, unlike normal Haskell code
05:32:25 <mm_freak_work> true
05:52:03 <slarba> howdy ho
05:52:30 <Botje> hello!
05:53:22 <slarba> let's ask this here too: is there a template haskell stuff for autogenerating zippers for given type?
05:55:15 <EvilTerran> ... there *could* be
05:55:25 <EvilTerran> you could also do it with SYB, i think
05:55:30 <slarba> hmm
05:56:11 <EvilTerran> which of those would be uglier is a matter of opinion ;)
05:56:45 <EvilTerran> actually, you need a new type, don't you? so SYB wouldn't really be suitable
05:57:11 <slarba> yes. the result would be a context type
05:57:16 <EvilTerran> short of doing something horrible involving lots of dynamic typing and CPS
05:58:07 <sclv> there's a typesafe generic zipper that traverses any generic.
05:58:58 <sclv> one component is, unsurprisingly, a type-level zipper as well
05:59:08 * EvilTerran blinks
05:59:32 <sclv> paper is, i believe, linked from the functional pearls wiki page
05:59:41 <slarba> ok cool
06:00:16 <sclv> it's just a paper -- and might be a bit.. heavyweight. cool proof of concept though.
06:01:36 <Saizan> from oleg?
06:01:46 <sclv> a uniplate zipper would probably be relatively feasible?
06:02:51 <Saizan> if uniplate is enough
06:08:29 <edward1> hah! there _is_ a name for the dual of a histomorphism
06:12:18 <Saizan> almost quotable :)
06:14:02 <edwardk> heh
06:14:15 <edwardk> futumorphism
06:14:19 * Botje starts reading the species paper
06:14:36 <edwardk> i went and rederived it and then tried to figure out what it meant, then i punned a name off of histomorphism and googled it
06:14:41 <edwardk> and i found it =)
06:15:47 <edwardk> a futumorphism is a generalized anamorphism when the monad used is the free monad of the functor you are building. it lets you have an anamorphism that can 'skip steps' and return more of the structure than just one level.
06:16:30 <edwardk> whereas a histomorphism is a generalized catamorphism when the comonad used is the cofree comonad of the functor you are tearing apart
06:17:20 <edwardk> the generalized histomorphism stuff just lets you work with a different cofree comonad given a distributive law for its underlying functor, while a generalized futumorphism lets you work with a different free monad, given a distributive law for its underlying functor
06:17:36 <edwardk> i've never seen a generalized futumorphism written up though
06:18:36 <earthy> just so I get a feeling of how much I don't understand you
06:18:38 <edwardk> similarly, like the generalized hylomorphism stuff i posted up the other night, a 'tempo?morphism' would be a generalized hylomorphism where the monad and comonad are the free and cofree monad and comonad respectively of the functor
06:18:48 <earthy> catamorphisms are roughly folds, right? anamorphisms unfolds, right?
06:18:55 <edwardk> earthy: yep
06:20:20 <earthy> so a futumorphism allows you to go from a seed to an element in a datastructure
06:20:22 <edwardk> there doesn't appear to be a term for the 'tempomorphism' concept mentioned above, but its pretty general, and generalizes in the same fashion as the above stuff
06:20:46 <earthy> but in a more general fashion than an unfold allows?
06:20:57 <edwardk> a futumorphism lets you go from a seed to a 'partially constructed' structure, with place holders sprinkled multiple levels deep
06:21:07 <earthy> *AH*
06:21:10 <earthy> that clicked. :)
06:21:21 <earthy> much like my delayed zipper implementation, then. :)
06:21:27 <edwardk> yeah, that was the explanation that clicked it for shapr this morning too =)
06:21:43 <edwardk> sounds analogous
06:22:02 <edwardk> its actually a really nice construct, but no one but one paper even mentions it
06:22:13 <earthy> what's the paper?
06:22:18 <edwardk> i'm interested in it because it may give me a way to do some of the things i can't seem to do with HOAS.
06:22:19 <earthy> as I have a very nice use for it. :)
06:22:39 <edwardk> since it is defined in terms of the free monad rather than the cofree comonad, and yet is an anamorphism
06:23:25 * quicksilver goes in search of a coffee comonad
06:23:35 <IagoAbal> hi!, someone knows if there is any way in Parsec 2.* to run your stateful parser and gets not only the result but your parser state too?
06:23:35 <edwardk> so it doesn't appear have the 'diamond type' problems that anamorphisms do over 'exponential functors'. just not sure i can do what i want in terms of it yet
06:24:17 <edwardk> earthy: http://www.mii.lt/informatica/pdf/INFO141.pdf
06:24:38 <edwardk> which is of course (course of value even) Uustalu and Vene
06:24:49 <earthy> damn. uustalu and vene. :)
06:24:54 <edwardk> yeah
06:24:57 <earthy> I should've guessed. :)
06:25:49 <edwardk> i still have a few unique constructs for the day though, the notion of a generalized futumorphism isn't mentioned there. also the dynamorphism stuff for histomorphisms seems to dualize to futumorphisms leading to some weird form of 'dual' of dynamic programming i haven't found a use for
06:27:02 <edwardk> and i'm trying to figure out fusion laws/acid rain for 'generalized hylomorphisms', because that encompasses general recursion and general corecursion, so fusion laws there would be quite powerful.
06:28:40 <edwardk> and i'm curious what extra info you get if you just limit yourself to the' case of the 'tempomorphism' stuff above where you get a pair of monad/comonad distributive laws for free
06:29:18 <edwardk> that particular morphism seems interesting because it can 'consume arbitrarily many levels' and 'generate arbitrarily many levels' at the same time
06:29:59 <edwardk> it generalizes, but the generalization is a little painful
06:30:14 <edwardk> coz now you have to deal with manual distributive laws again
06:30:46 <Jedai> IagoAbal: Yes, it's in the API
06:31:14 <IagoAbal> Jedai, uhm, in the API of Parsec 3 exists runP, but in the API of Parsec 2 no
06:31:31 <IagoAbal> for Parsec 2 I only found runParser, but it forget the state
06:32:04 <atsampson> IagoAbal: make your top-level production return a pair (parsed output, state)
06:32:16 <atsampson> it's cheating, but it works for me ;)
06:32:33 <Philippa> yeah. You can even write a combinator to do that given your otherwise-top-level parser
06:33:16 <Saizan> edwardk: you mean that at that point you can't just pass the laws to the morphism but use them directly in the consuming/producing functions?
06:33:56 <IagoAbal> atsampson, thanks :P yes, I thought in a solution like this, I ask because perhaps there is a another way
06:35:16 <edwardk> Saizan: you can pass them in, its just like the g_ana, g_cata case you have to know them. the nice thing about working with the free monad/free comonad case is that you get them for free. the law in question for each is 'id' for the underlying functor (forall a.  f (f a) -> f (f a)) =)
06:35:51 <edwardk> when thats (forall a. f (g a) -> g (f a)) you have to actually think ;)
06:37:03 <Saizan> ah, i see :)
06:37:44 <Jedai> IagoAbal: Well there's no function true, but it's just addState p = p >>= \value -> gestState >>= \state -> return (state, value)
06:40:11 <IagoAbal> Jedai, yes, lot of thanks
06:41:30 <IagoAbal> well, Jedai
06:41:51 <IagoAbal> it's only works when the parser runs without errors
06:42:16 <IagoAbal> I use the state of the parser to save some information to get better error messages
06:42:51 <Jedai> IagoAbal: You can extract the state from a ParseError
06:42:58 <IagoAbal> or to re-run the parser in panic mode
06:43:45 <IagoAbal> Jedai, how?
06:43:54 <IagoAbal> I can't see any function for this http://www.haskell.org/ghc/dist/current/docs/libraries/parsec/Text-ParserCombinators-Parsec-Error.html#t%3AParseError
06:43:56 <lambdabot> http://tinyurl.com/56gj3v
06:45:28 <Jedai> IagoAbal: Ok, not exactly the state, you can get the SourcePos
06:45:39 <Jedai> What exactly do you need to do ?
06:46:11 <IagoAbal> my parser are: CharParser Context a
06:46:28 <IagoAbal> I need gets the context when the parser fails
06:46:34 <IagoAbal> are->is
06:52:09 <dzlk> Silly question for anyone who wants it. How would I go about modifying the library search path xmonad --recompile gives to the compiler?
06:52:20 <edwardk> does anyone have a better name than 'tempomorphism' for something that subsumes histo and futumorphisms?
06:52:24 <Jedai> IagoAbal: Yeah, I don't see any way to do that with the Parsec2 API, it forget the user state when it fails...
06:53:19 <janszn> @pl scanl (\x y -> y:x) []
06:53:19 <lambdabot> scanl (flip (:)) []
06:53:23 <IagoAbal> Jedai, well, thanks anyway, my only solution is get the source and changes it to export runP :P
06:53:36 <mib_2zt8xj> @type map
06:53:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:53:40 <jorick> @src unwords
06:53:40 <lambdabot> unwords [] = ""
06:53:40 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
06:53:52 <jorick> @src foldr1
06:53:52 <lambdabot> foldr1 _ [x]    = x
06:53:52 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
06:53:52 <lambdabot> foldr1 _ []     = undefined
06:54:03 <dzlk> (and corrollary to that is, why doesn't the xmonad slackware package I just installed not look in /usr/X11R6/lib ... )
06:57:22 <Jedai> IagoAbal: No that don't seem to be the problem
06:57:43 <Jedai> You should modify ParseError and parseFail
06:58:24 <IagoAbal> uhms
06:58:31 <IagoAbal> to put the state in ParseError
06:59:07 <Jedai> runP won't give you the user state when it failed (I'm a little bit surprised that there's no way to get it as it seems it would be useful to understand what was the problem....)
07:01:19 <Jedai> IagoAbal: ParserError only carry around the Parser state and message strings now
07:02:50 <IagoAbal> Jedai, data ParseError     = ParseError !SourcePos [Message]
07:03:01 <IagoAbal> well, I can add the state here
07:03:20 <IagoAbal> altought, parserReply (runP ...) gives you the state too
07:03:21 <Jedai> IagoAbal: If you have a Show/Read instance sure
07:06:06 <dzlk> Now I feel even sillier -- it's in the xmonad FAQ. Sorry. :)
07:06:57 <Jedai> IagoAbal: No it does not, if you parser fail, it will just give you (Error ParseError)
07:07:20 <IagoAbal> Jedai, yes, i know
07:08:17 <IagoAbal> I think there is "only" two solutions, and both implies get the source and change it, one is modify ParseError definition, and the other is redefine runParser
07:08:22 <IagoAbal> or define a new function et
07:08:22 <IagoAbal> c
07:08:47 <IagoAbal> Jedai, well, no, only one
07:08:50 <IagoAbal> :P
07:08:52 <IagoAbal> redefine ParseError
07:09:24 <IagoAbal> sorry, you have reason
07:09:49 <IagoAbal> parseReply only gets the state when the parser runs ok
07:10:20 <Jedai> I'm still surprised that it wasn't added in Parsec3 at least, since it wouldn't even change much the API (just add the user state to parseError and add a function to get it from this ParseError
07:10:50 <Jedai> We would need an expert of parsec to tell us why it wasn't done
07:11:05 <IagoAbal> add it haven't got any side effect, since the definition of ParseError is not exported
07:12:12 <IagoAbal> well, with Parsec3 you can have your State monad inside ParsecT
07:24:38 <byteshack> can someone help me understand why this seems so much slower than a tripply-nested loop in a procedural lang? [[a,b,c] | a <- [1..500], b <- [1..500], c <- [1..500], a+b+c==1000 && (a*a)+(b*b)==(c*c)]
07:24:39 <Jedai> IagoAbal: Ah you're right, though it seems a waste to add one more state monad to the mix when you already can put user state in the Parsec monad
07:25:16 <byteshack> yes, it is for proj euler.  Been using those simple problems to get me started with haskell
07:25:42 <Peaker> byteshack, you are checking a lot of identical options (a and b can be reversed), but that's only a factor of 2
07:26:18 <Peaker> byteshack, you are also iterating a lot of options to find which sum to 1000, where you could just use c=1000-(a+b)
07:26:21 <byteshack> I added b<a to the list of "filters", but it still seemed a lot slower tha my python code
07:26:29 <IagoAbal> Jedai, yes, altought perhaps would be better remove userState in Parsec
07:26:48 <Peaker> byteshack, that filter should be prior to the loop - so you don't create the iterations unnecessarily
07:27:29 <byteshack> ah, that's where python is comming out ahead
07:27:30 <nornagon> how about a <- [1..500], b <- [1..a]?
07:27:33 <edwardk> > [[a,b,c] | a <- [1..500], b <- [1..500], let c = 1000 - a - b in (a*a)+(b*b)==(c*c)]
07:27:34 <lambdabot>  [[200,375,c],[375,200,c]]
07:27:38 <byteshack> it breaks as soon as it finds a sol
07:27:39 <edwardk> er
07:28:13 <edwardk> > [[a,b,1000 - a - b] | a <- [1..500], b <- [1..500], let c = 1000 - a - b in (a*a)+(b*b)==(c*c)]
07:28:16 <ziman> i came over a similar problem a month ago
07:28:17 <ziman> http://hpaste.org/6386
07:28:17 <lambdabot>  [[200,375,425],[375,200,425]]
07:28:27 <ziman> the iterative version is faster than the list comprehension
07:28:39 <ziman> and nobody could give an explanation
07:28:40 <edwardk> > [[a,b,1000 - a - b] | a <- [1..500], b <- [1..a], let c = 1000 - a - b in (a*a)+(b*b)==(c*c)]
07:28:40 <lambdabot>  [[375,200,425]]
07:28:45 <Saizan> > [[a,b,c] | a <- [1..500], b <- [1..500], let c = 1000 - a - b, (a*a)+(b*b)==(c*c)]
07:28:45 <lambdabot>  [[200,375,425],[375,200,425]]
07:29:04 <byteshack> ziman: yes, that is what I'm confused about
07:29:10 <edwardk> saizan: yeah, though i'm amused that the 'c' showed up in the printed output above, what gives there?
07:29:12 <Jedai> ziman: You could ask for the head and then it would break as soon as it find a solution too
07:29:23 <byteshack> even if I don't break out of the loops in the other langs, it still seems faster
07:29:38 <edwardk> (10:27:34 AM) lambdabot:  [[200,375,c],[375,200,c]] ??
07:29:41 <edwardk> @type c
07:29:42 <ziman> Jedai, erm, i wasn't searching for an answer to project euler
07:29:42 <Saizan> edwardk: it0s a king of hack
07:29:43 <lambdabot> Expr
07:29:46 <edwardk> ah
07:29:55 <Saizan> > foldl f z [a,b,c]
07:29:56 <tromp> you didnt bind c in the list monad
07:29:56 <lambdabot>  f (f (f z a) b) c
07:29:57 <edwardk> i remember now
07:29:58 <ziman> Jedai, i needed to print out all triples
07:30:07 <edwardk> i read lennart's blog about it
07:30:42 <tromp> > [(a,b,c)] | a <- [1..500], b <- [1..a], let c = 1000-a-b, a*a+b*b=c*c]
07:30:43 <lambdabot>  Parse error at "|" (column 11)
07:30:45 <Jedai> ziman: Oh, but how could you break in the iterative version then ?
07:31:10 <tromp> > [(a,b,c) | a <- [1..500], b <- [1..a], let c = 1000-a-b, a*a+b*b=c*c]
07:31:11 <edwardk> > [(a,b,c) | a <- [1..500], b <- [1..a], let c = 1000-a-b, a*a+b*b=c*c]
07:31:11 <lambdabot>  Parse error at "=c*c]" (column 65)
07:31:11 <lambdabot>  Parse error at "=c*c]" (column 65)
07:31:19 <tromp> > [(a,b,c) | a <- [1..500], b <- [1..a], let c = 1000-a-b, a*a+b*b==c*c]
07:31:20 <lambdabot>  [(375,200,425)]
07:31:22 <Jedai> Note that the first version runs just for 6s on my computer
07:31:30 <edwardk> what tromp said =)
07:31:52 <ziman> Jedai, what do you mean by `break in'?
07:32:27 <Jedai> That don't seem that bad for 125000000  (*3 additions, * 3 mult)
07:33:42 <Jedai> ziman: In fact I was mistaken in sending you my first message, it was in response to byteshack's "it breaks as soon as it finds a sol" (speaking of his python solution)
07:34:03 <tromp> > [(a,b,c) | a <- [0..9], b <- [0..9], let c = 20-a-b, (a*a+b*b)`mod`10==(c*c)`mod`10]
07:34:04 <lambdabot>  [(0,0,20),(0,1,19),(0,2,18),(0,3,17),(0,4,16),(0,5,15),(0,6,14),(0,7,13),(0,...
07:34:09 <ziman> i see :)
07:34:50 <tromp> > [(a,b,c) | a <- [0..4], b <- [0..4], let c = 10-a-b, (a*a+b*b)`mod`5==(c*c)`mod`5]
07:34:51 <lambdabot>  [(0,0,10),(0,1,9),(0,2,8),(0,3,7),(0,4,6),(1,0,9),(2,0,8),(3,0,7),(4,0,6)]
07:35:19 <byteshack> so, I guess my lesson is: filter the sets before, not after
07:35:36 <tromp> a or b must be  multiple of 5
07:36:06 <edwardk> byteshack: yeah saves you a few orders of magnitude of work ;)
07:37:14 <dolio> edwardk: You mind if I add your g_hylo to category-extras when I get around to it?
07:37:22 <edwardk> dolio: go for it
07:38:22 <edwardk> dolio: if you have free monads you may want to add the futumorphism and generalized futumorphism as well
07:38:31 <byteshack> edwardk: no sql optimizing my query behind my back :)
07:38:49 <edwardk> byteshack: fraid not, what do you think this is, c#? =)
07:38:56 <byteshack> hehe!
07:39:47 <edwardk> futu :: FixPoint f t => (a -> f (Free f a)) -> a -> t
07:39:48 <dolio> edwardk: I'll look into it.
07:39:54 <edwardk> is the dual of 'histo' in there
07:40:01 <edwardk> g_futu generalizes similarly
07:41:58 <byorgey> "futumorphism"?
07:42:04 <edwardk> g_futu :: (Functor h, Fixpoint f t) => (forall b. h (f b) -> f (h b)) -> (a -> f (Free h a)) -> a -> t
07:42:08 <edwardk> is its generalization
07:42:17 <byorgey> but "futu" isn't a greek prefix!!
07:42:20 <edwardk> byorgey: think an 'anamorphism' that can return multiple layers
07:42:28 <edwardk> byorgey: blame vene and uustalu  =)
07:42:32 * byorgey has a language purist fit
07:42:37 <mauke> futamorphism
07:42:44 * mauke runs away, cackling
07:44:17 <edwardk> from that what i started doing was putting together a 'tempomorphism' in terms of a functor and the cofree comonad and the monad formed by the functor (for lack of a better term for something subsuming futu and histo)
07:45:17 <edwardk> tempo :: Functor f => (f (Cofree f b) -> b) -> (a -> (f (Free f a)) -> a -> b
07:45:46 <edwardk> which can generalize to allow the cofree comonad and the free monad to be constructed over arbitrary functors as long as they have appropriate distributive laws
07:45:52 <byorgey> tempo is Latin, you should call it a 'chronomorphism' =)
07:46:16 <edwardk> good point
07:46:22 <byorgey> which sounds better anyway, IMO ;)
07:46:28 <edwardk> chronomorphism it is =)
07:46:32 <byorgey> =D
07:48:15 <edwardk> i'm curious about the chronomorphism stuff because i think it might actually derive value from the sort of dessicated corpse of an 'eta' term that usually gets folded (no pun intended) into the catamorphism side of the hylomorphism.
07:48:25 <byorgey> edwardk: if I wanted to learn about some of this stuff from 'first principles', any suggestions as to what I should read?
07:48:46 <edwardk> hylo phi eta psi = phi . eta . map (hylo phi eta psi) . psi
07:49:01 <quicksilver> omg.
07:49:06 <quicksilver> the frat combinator
07:49:15 <edwardk> could clearly be written as hylo phi psi = phi . map (hylo phi psi) . psi
07:49:25 <byorgey> sigh, again with the Latin  ;)
07:49:43 <edwardk> quicksilver: heh
07:49:43 <Syzygy-> byorgey: I bet you were opposed to neologisms like TV too, right?
07:50:30 <byorgey> Syzygy-: I might have been if I were alive then. =)  But what's wrong with 'TV' in particular?
07:50:33 <edwardk> Syzygy-: i'd call him a barbarian, but i think the word is a bit too modern for his tastes ;)
07:51:11 <sclv_> ?remember edwardk hylo phi eta psi = phi . eta. map (hylo phi eta psi) . psi; quicksilver: omg. the frat combinator.
07:51:11 <lambdabot> Okay.
07:51:16 <sclv_> @quote frat
07:51:16 <lambdabot> edwardk says: hylo phi eta psi = phi . eta. map (hylo phi eta psi) . psi; quicksilver: omg. the frat combinator.
07:51:24 <edwardk> heh
07:51:42 <Syzygy-> byorgey: television <= tele is greek, vision stems from latin.
07:51:55 <edwardk> byorgey: as for a first principles thing? i dunno. i started exploring them in a toy untyped language and then they all made sense to me ;)
07:52:08 <byorgey> Syzygy-: oh, but the romans stole that from the Greeks ('video'), so that's ok =)
07:52:21 <edwardk> get rid of the occurs check and all of a sudden all the 'Mu' and 'outF' noise goes away
07:52:22 <Syzygy-> byorgey: You have etymology on that?
07:52:37 <desegnis> Syzygy-, hexadecimal is neater
07:53:16 <desegnis> byorgey, video is "I see" in Latin
07:53:31 <byorgey> desegnis: yes, I know that, it is also 'I see' in Greek =)
07:53:52 <desegnis> oh, that's funny to know
07:55:11 <quicksilver> byorgey: I don't think so, no
07:55:18 <quicksilver> byorgey: what do you claim the word would be?
07:55:24 <quicksilver> (the greeks didn't have a 'v')
07:55:50 <byorgey> well, it was a digamma which was later dropped
07:55:56 <Syzygy-> byorgey: Again, I'd like some backing links or references on the claim that 'video' is greek...
07:56:13 <byorgey> sure, just a minute =)
07:56:17 <edwardk> dolio: if you need definitions for futu, etc. i'll happily transcode them to haskell
07:56:43 <quicksilver> looks like the greek cognate is eido
07:56:48 <quicksilver> not really the same word IMO.
07:56:51 <byorgey> right, exactly
07:57:04 <dolio> edwardk: I got a couple papers that purport to contain futumorphisms, but that might be helpful, since I'm not well acquainted with this sort of thing.
07:57:09 <quicksilver> certainly the television thing is often cited as a poor coining because of the mismatch
07:57:13 <desegnis> doesn't eidos mean form or something?
07:57:21 <mauke> image?
07:57:24 <edwardk> dolio: the vene/uustalu one introduced them as i recall
07:57:31 <byorgey> image, which is related to seeing
07:57:31 <Syzygy-> I'm ready to buy relationships between eido and videre - but it's not close enough for it to be a refutation to the television thing.
07:57:40 <edwardk> dolio: i should also give you code for a dynamorphism and its dual, hrmm.
07:57:59 <dolio> edwardk: I'm about to go to bed, though, so you'll have to @tell it to me, or wait for later.
07:58:11 <edwardk> dolio: we'll pick it up later
07:58:12 <mauke> and our next topic: why AMD Athlon is a really bad name
07:58:14 <quicksilver> hence 'eidolon'
07:58:24 <quicksilver> and 'kaleidoscope'
07:58:34 <desegnis> mauke, byorgey, quicksilver, right, I remembered it only from Aristotle. the infamous wikipedia mentions eidein = to see
07:58:34 <dolio> edwardk: All right.
07:58:56 <byorgey> http://www.perseus.tufts.edu/cgi-bin/ptext?doc=Perseus%3Atext%3A1999.04.0057%3Aentry%3D%2330877
07:59:02 <lambdabot> Title: Henry George Liddell, Robert Scott, A Greek-English Lexicon, http://tinyurl.com/6yrfp6
07:59:19 <byorgey> see the first entry there which shows the link to videre in latin
07:59:23 <edwardk> i on the other hand had a pretty boring midwestern American middle-class education, and so my greek is er... well nonexistent ;)
07:59:48 <byorgey> the capital W is the digamma which was later dropped from the spelling (but possibly still pronounced)
07:59:50 <tromp> veni, vidi, vici
08:00:46 <mauke> @vixen vidi, vici, veni
08:00:47 <lambdabot> Most guys don't understand me, but we really seem to connect.
08:01:11 <byorgey> Syzygy-: maybe you're still right about 'television' though, it depends how picky you want to be I guess =)
08:04:32 <sw17ch> forkIO isn't the same as the unix fork i'm used to is it? light weight thread means a kernel thread, not a process right?
08:04:59 <edwardk> chrono :: Functor f => (f (Cofree f b) -> b) -> (a -> f (Free f a)) -> a -> b
08:05:38 <Saizan> sw17ch: it's not even kernel thread, it's a user-space thread
08:05:54 <sw17ch> oh, i see
08:06:04 <Saizan> much lighter :)
08:06:16 <sw17ch> and the user-space threads are spread out over N threads which we pass as a runtime argument
08:06:31 <Saizan> exactly, if you compile with -threaded
08:06:32 <sw17ch> cool :)
08:06:45 <Syzygy-> byorgey: If you relax too much you end up with the Big Happy Proto-indoeuropean family .. and in that case, I don't see how the futu-morphism is a bad thing.
08:07:11 <edwardk> g_chrono :: (Functor f, Functor w, Functor m) => (forall c. w (f c) -> f (w c)) -> (forall d. f (m d) -> m (f d)) -> (f (Cofree w b) -> b) -> (a -> f (Free m a)) -> a -> b
08:08:02 <byorgey> Syzygy-: well, fair enough, I guess. =)
08:08:20 <Syzygy-> byorgey: I wouldn't be picking on you but for your initial abhorrence to neologisms.
08:08:24 <edwardk> is what i have now, i'm trying to figure out if
08:08:26 <edwardk> g_chrono' :: (Functor f, Functor g, Functor w, Functor m) => (forall c. w (g c) -> g (w c)) -> (forall d. f (m d) -> m (f d)) -> (forall e. f e -> g e) -> (g (Cofree w b) -> b) -> (a -> f (Free m a)) -> a -> b
08:08:32 <edwardk> is realizable
08:08:33 <byorgey> It doesn't actually bother me... or rather, it bothers me very slightly and I was exaggerating for (intended) comic effect.
08:08:44 <edwardk> assuming i didn't typo that typing it in freehand =)
08:09:19 <byorgey> Syzygy-: no problem, pick on me all you want. =)
08:09:22 <Syzygy-> And I would NEVAH grab a comic exaggeration and push the interpretation of that to extreme excesses in a bid to match the comicity (??) of it. ;)
08:09:43 <byorgey> hehe =)
08:09:56 <edwardk> where g_chrono' k1 k2 eta phi psi regains the vestigial eta term that is unnecessary in hylo
08:10:00 <byorgey> What a coincidence, I never do that either!
08:10:08 <RobRobRob> Hi! how can i append an Integer to a [Integer]?
08:10:17 <edwardk> @type snoc
08:10:18 <quicksilver> > 1 : [2,3,4]
08:10:18 <lambdabot> Not in scope: `snoc'
08:10:20 <lambdabot>  [1,2,3,4]
08:10:27 <byorgey> > [1,2,3] ++ [4]
08:10:28 <lambdabot>  [1,2,3,4]
08:10:38 <quicksilver> > "Rob" : ["Rob","Rob"]
08:10:39 <lambdabot>  ["Rob","Rob","Rob"]
08:10:47 <edwardk> @type Data.List.snoc
08:10:48 <lambdabot> Not in scope: `Data.List.snoc'
08:10:50 <edwardk> gah
08:10:51 <mapreduce> > [1..] ++ [0]
08:10:52 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
08:11:02 <RobRobRob> ok, but if my input is an Integer, which i've called x, then can i do [1,2,3] ++ [x]?
08:11:03 <byorgey> RobRobRob: by 'append' you mean 'on the end', right?
08:11:07 <RobRobRob> yeah i do
08:11:08 <byorgey> RobRobRob: right.
08:11:08 <RobRobRob> lol
08:11:10 <RobRobRob> thanks for all the exaples
08:11:11 <mauke> > [1,2,3] ++ [x]
08:11:12 <lambdabot>  [1,2,3,x]
08:11:14 <mauke> huhu
08:11:22 <RobRobRob> ok i'll try... think it didn't work though
08:11:37 <mapreduce> mauke: Why does that work?
08:11:41 <byorgey> RobRobRob: maybe you haven't fed the elves recently enough
08:11:56 <byorgey> @where expr
08:11:57 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
08:12:00 <byorgey> mapreduce: ^^
08:12:01 <RobRobRob> sounds likely
08:12:34 <byorgey> mapreduce: a-z are specially defined in lambdabot
08:12:36 <edwardk> robrobrob note the []'s around the thing being appended
08:12:51 <sw17ch> RobRobRob, if you're going to be appending a lot of integers like that, it's best to do it in reverse and then reverse the list when you're done
08:12:54 <mapreduce> byorgey: hah.
08:12:58 <mapreduce> > x*y
08:12:59 <lambdabot>  x * y
08:13:02 <edwardk> > let snoc as a = as ++ [a] in snoc [1,2,3] 4
08:13:03 <lambdabot>  [1,2,3,4]
08:13:05 <sw17ch> > 9 : 8 : 7 : 6 : 5 : 4 : 3 : 2 : 1 : []
08:13:06 <lambdabot>  [9,8,7,6,5,4,3,2,1]
08:13:10 <sw17ch> > reverse $ 9 : 8 : 7 : 6 : 5 : 4 : 3 : 2 : 1 : []
08:13:11 <lambdabot>  [1,2,3,4,5,6,7,8,9]
08:13:12 <byorgey> RobRobRob: if you're having trouble with some particular code, feel free to paste it on hpaste.org and we can take a look.
08:13:13 <mapreduce> > x-x
08:13:13 <lambdabot>  x - x
08:13:15 <RobRobRob> this time i got Couldn't match expected type [Integer] against inferred type Integer -> [Integer]
08:13:50 <byorgey> RobRobRob: apparently you have something which you are trying to use as if it is a list, but which is actually a function which takes an Integer and returns a list.
08:13:52 <mapreduce> > [1..10] : 5
08:13:52 <lambdabot>   add an instance declaration for (Num [[t]])
08:13:53 <sw17ch> @where hpaste
08:13:53 <lambdabot> http://hpaste.org/
08:13:58 <Syzygy-> > let snoc a = reverse . (a:) . reverse in snoc 5 [1,2,3]
08:14:00 <lambdabot>  [1,2,3,5]
08:14:03 <Syzygy-> :)
08:14:03 <RobRobRob> um
08:14:06 <mapreduce> > [1..10] ++ 5
08:14:06 <lambdabot>   add an instance declaration for (Num [t])
08:14:14 <mapreduce> So that wasn't his error..
08:14:19 <RobRobRob> that sounds about right
08:14:57 <RobRobRob> i'll paste my cod
08:14:57 <RobRobRob> e
08:15:15 <ehird> http://www.coderoshi.com/2007/09/5-reasons-static-typing-sucks.html In which we laugh at how the author has never used a properly statically typed language, and believes that manifest typing == static typing
08:15:17 <lambdabot> Title: 過労死 Death by Overcoding: 5 Reasons Static Typing Sucks, http://tinyurl.com/2p25ys
08:15:42 <dzlk> Check if you forgot an argument to the function?
08:15:43 <mapreduce> ehird: A daily occurence.
08:16:04 <ehird> mapreduce: It's still a hilariously bad article by someone who knows that their language is 'obviously superior'
08:16:06 <dzlk> That'd get you an "expected a but inferred a -> a" error.
08:16:11 <RobRobRob> http://hpaste.org/7174
08:16:46 <RobRobRob> i hope that's ok for you
08:17:08 <RobRobRob> i expect i'm doing this in a very poor way anyway
08:17:09 <mauke> RobRobRob: missing argument in call to sadd (xs ++ [d])
08:17:19 <mapreduce> ehird: "static types are unreal" - the same logic could be used to ban numbers.
08:17:28 <ehird> mapreduce: tee hee hee
08:17:29 <RobRobRob> oh yeah
08:17:42 <sw17ch> mapreduce, i'm all for banning numbers
08:17:44 <sw17ch> :)
08:18:04 <RobRobRob> yay it compiled!
08:18:12 <RobRobRob> mauke: thanks!
08:18:19 <mauke> “Static typing is a pedantic construct, bred from experiments of the first Object Oriented languages” RAGE
08:18:37 <ehird> mauke: :-)
08:18:38 <byorgey> RobRobRob: what are you trying to do?
08:18:48 <dzlk> In the same way the Vienna Circle was an experiment with the Tractus [sic] ?!
08:19:01 <dzlk> Ye gods.
08:19:19 * byorgey advises everyone not to click on that link ehird posted, it will only drive you into a blithering stupor
08:19:36 <ehird> byorgey: You have uncovered my secret plot!!!!!
08:19:38 <sw17ch> byorgey, i find the internet has that effect on me
08:19:45 <byorgey> sw17ch: haha
08:19:59 <mauke> I believe the proper term is “NERD RAGE”
08:20:02 <sw17ch> the stupid is so pervasive, i have my doubts about man kind :)
08:20:02 <mapreduce> It's not offensive, it's just uninformed and illogical.  I bet with some electric shock therapy the author could be persuaded otherwise.
08:20:48 <ehird> mauke: 'NERD RAGE'? What a bunch of crap. You evidently don't understand how important this is - Someone is *WRONG* on the *INTERNET*!
08:20:56 <Syzygy-> #haskell - where bad blog posts are met with threats of torture.
08:21:04 <mauke> zOMG‼
08:21:17 <mapreduce> ehird: Ok, this is weird - I've already read, commented on, and forgotten that blog post (Ricky Clarkson in the comments)
08:21:31 <sw17ch> http://xkcd.com/386/
08:21:32 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
08:21:37 <Syzygy-> mapreduce: Only goes to show how relevant it was to your world view. :)
08:21:50 <quicksilver> oh, mapreduce is ricky_clarkson?
08:21:51 <ehird> mapreduce: HAHA. I love you.
08:21:52 <ehird> :P
08:21:55 <quicksilver> well there you go.
08:22:00 <ehird> sw17ch: I totally wasn't referencing that.
08:22:03 <sw17ch> =)
08:22:20 <sw17ch> ehird, yet it was the first thing i thought of
08:22:40 <ehird> sw17ch: Okay, since sarcasm doesn't work for you: I totally *was* referencing that.
08:23:13 <sw17ch> ehird, crap, my proxy_sarcasm_filter must have scraped it off... :(
08:23:38 <mapreduce> quicksilver: That's right.
08:24:43 <quicksilver> mapreduce: one more link added to my mental IRC wolrd map :)
08:26:39 <byorgey> RobRobRob: assuming 'isIn' does what I think, there is already a function to do this in the standard Prelude, called 'elem'
08:26:53 <byorgey> > elem 3 [1,3,4,7]
08:26:56 <lambdabot>  True
08:26:59 <byorgey> > elem 3 [1,2,4,7]
08:27:00 <lambdabot>  False
08:27:14 <quicksilver> > elem (x+1) [y,2,x,3]
08:27:15 <mapreduce> I find that an odd name.
08:27:15 <lambdabot>  False
08:27:20 <dzlk> Hm, he's as ignorant of philosophy as he is of type systems.
08:27:54 <byorgey> mapreduce: it is slightly odd, I suppose, but 'in' is already taken as syntax
08:27:55 <quicksilver> it's easy to call blog posters ignorant
08:28:05 <quicksilver> however, he certainly makes it particularly easy :)
08:28:08 <dzlk> In this case it's true, though. :)
08:28:27 <quicksilver> one of the reasons I don't have a blog is that I'm vain, and would hate all the people pointing out I was wrong.
08:28:27 <Espionage> can anyone help me with a pretty basic problem ? data RGB       = RGB Colour Colour Colour I dont really understand this
08:28:30 <quicksilver> ;)
08:28:34 <mapreduce> I forgot how much fun #haskell is. :)
08:28:35 <Espionage> why is the rgb repeated there?
08:28:38 <quicksilver> Espionage: that creates a new datatype called 'RGB'
08:28:44 <quicksilver> Espionage: which contains three 'Colours'
08:28:51 <quicksilver> Espionage: it also uses the constructor 'RGB'
08:28:59 <mapreduce> Espionage: The second RGB is the name of the constructor.
08:29:06 <quicksilver> (constructors can have the same name as datatypes which can be confusing, although it can be useful shortcut)
08:29:07 <ehird> <byorgey> mapreduce: it is slightly odd, I suppose, but 'in' is already taken as syntax     <-- elem is what CL uses for it. i think.
08:29:10 <mapreduce> @src Either
08:29:11 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
08:29:24 <sclv_> My advice for this dude: Whereof one cannot speak, thereof one must be silent.
08:29:42 <mapreduce> @go data Either haskell
08:29:43 <Espionage> so say I had a function that gave em a bool if a colour was between 0 and 255, how would i use that on an RGB ?
08:29:44 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Either.html
08:29:47 <sclv_> now *there's* some philosophy worth remembering.
08:29:48 * osfameron doesn't get the "Hey, tests will fix this" call of dynamists
08:29:52 <osfameron> writing tests takes *time*
08:29:58 <osfameron> though I think it's a good idea, it's not free
08:30:13 <ehird> tests are booooooooooooooring
08:30:14 <ehird> :)
08:30:14 <mapreduce> How many tests should I write for id?
08:30:17 <byorgey> yeah, there are many methods in the standard Prelude (like elem, nub) which could arguably have different names but are a nod to CL or Prolog or some other predecessor language.
08:30:22 <ehird> mapreduce: one:
08:30:25 <ehird> @check \x -> id x == x
08:30:27 <lambdabot>  OK, passed 500 tests.
08:30:40 <mapreduce> How did lambdabot decide on a type to use?
08:30:40 <quicksilver> Espionage: you'd have to choose which component to use it on
08:30:48 <EvilTerran> ?check \x y -> x == y
08:30:49 <lambdabot>  OK, passed 500 tests.
08:30:51 <EvilTerran> :D
08:30:56 <quicksilver> Espionage: suppose your funciton is called f.
08:30:58 <EvilTerran> mapreduce, "extended defaulting"
08:31:00 <scook0> or apply it to all three, and return a triple of results
08:31:00 <mapreduce> Has that changed recently?
08:31:09 <quicksilver> Espionage: you could write g like this : g (RGB a b c) = f a
08:31:12 <byorgey> Espionage: what exactly do you want to do? do you want to test whether all three components are between 0 and 255?
08:31:13 <osfameron> nub is a truly awful name, as bad as car or cdr
08:31:15 <quicksilver> Espionage: then it only checks the first component.
08:31:20 <Espionage> yeah byorgey
08:31:21 <mapreduce> car and cdr are wonderful
08:31:24 <quicksilver> Espionage: you could decide to check all three, I guess :)
08:31:26 <mapreduce> cdadr!
08:31:28 <EvilTerran> mapreduce, http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#extended-default-rules
08:31:29 <lambdabot> Title: 3.4. Interactive evaluation at the prompt, http://tinyurl.com/6j5p63
08:31:30 <mauke> osfameron: it's too short but ok otherwise
08:31:35 <quicksilver> car and cdr at least have abuilt-in history lesson.
08:31:39 <dzlk> cdadddaddaaaadddaddr
08:31:45 <ehird> i love car/cdr
08:31:46 <ehird> cadadr
08:31:52 <ehird> abra cadadr
08:31:53 <byorgey> Espionage: and how is an RBG value represented?
08:31:58 <byorgey> er, RGB
08:32:04 <ehird> ?check \x y z -> x+y == z
08:32:05 <lambdabot>  Falsifiable, after 1 tests: 1, -1, -2
08:32:06 <Espionage> first off I had an if (validColour r) == True && (validColour....
08:32:11 <ehird> ?check \x y z -> False
08:32:11 <Espionage> Int
08:32:12 <lambdabot>  Falsifiable, after 0 tests: (), (), ()
08:32:13 <osfameron> are all combinations of c[ad]+r recognized?
08:32:22 <ehird> ?check \x y z -> x/y `seq` False
08:32:23 <lambdabot>  Falsifiable, after 0 tests: 2.5, -5.0, ()
08:32:25 <mapreduce> osfameron: In what?
08:32:26 <quicksilver> osfameron: in most lisps, no.
08:32:30 <mauke> Espionage: (... == True) is pointless
08:32:31 <scook0> the spec gives a minimum upper bound
08:32:32 <quicksilver> osfameron: just up to 5 or 7 or something.
08:32:33 <ehird> osfameron: No, just the most common
08:32:41 <Espionage> oh yes mauke  :)
08:32:41 <ehird> In Scheme, up to 4 inner letters i Ithknk
08:32:45 <ehird> cadadr
08:32:45 <dzlk> Not in most lisps. A few are predefined, but after cadr and cddr there are no guarantees.
08:32:47 <scook0> much like haskell's zip-esque functions
08:32:48 <osfameron> in which case it's kinda silly
08:32:50 <mauke> c[ad]{1,4}r
08:32:52 <ehird> dzlk: No... More are guaranteed.
08:33:06 <mapreduce> osfameron: It's easy to implement them if they're not there.
08:33:08 <byorgey> Espionage: RGB is represented as Int?  how do you recover the red, green, and blue values?
08:33:09 <ehird> <osfameron> in which case it's kinda silly <-- err, not really, pattern matching on a symbol would be silly
08:33:11 <ehird> besides
08:33:13 <ehird> if you really need more
08:33:15 <osfameron> doesn't it amount to nth element's head or tail ?
08:33:18 <ehird> your data structure is wacked
08:33:21 <Espionage> oh no byorgey  I have
08:33:31 <Espionage> data RGB       = RGB Colour Colour Colour and Colour is an Int
08:34:00 <ehird> Oddness:
08:34:00 <ehird> <ehird> @check \a b c d e f g h i j k l m n o p q r s t u v w x y z -> False
08:34:00 <ehird> <lambdabot>  : {(t_a2bX -> t_a2bY) -> IO String}'           arising from a use of `myquickcheck' at <irc>:2:6-21
08:34:04 <ehird> @check \a b c d e f g h i j k l m n o p q r s t u v w x y z -> False
08:34:06 <lambdabot>  : {(t_a2bX -> t_a2bY) -> IO String}'           arising from a use of `myquic...
08:34:29 <conal> Espionage: what you call "Colour" is what some people call a "component" or "channel" of a colour
08:34:58 <mapreduce> Code may be overly British.
08:34:59 <dzlk> ehird: How many and by which lisps? I'm sure you're right and I've forgotten, I'm just curious.
08:35:02 <quicksilver> ehird: that's quite interesting.
08:35:10 <Espionage> haha mapreduce :)
08:35:16 <ehird> dzlk: Scheme specifies car to cddddr.
08:35:22 <ehird> dzlk: Common Lisp is similar, I believe.
08:35:29 <quicksilver> ehird: looks almost like a gch bug.
08:35:36 <ehird> quicksilver: Coooooool.
08:35:56 <osfameron> is cddddr just equivalent to (drop 4) ?
08:36:14 <mauke> yes
08:36:15 <conal> Espionage: perhaps: data Colour = RGB Channel Channel Channel, where type Channel = Int
08:36:20 * osfameron doesn't have a lisp handy to check
08:36:25 <ehird> osfameron: not really, no
08:36:34 <ehird> since the odd NIL behaviour in most lisps
08:36:41 <mapreduce> clisp (an implementation of common lisp) has cadddr but not caddddr
08:36:42 <mauke> drop 4 [] == []
08:36:50 <ehird> technically, though, cddddr is (cdr . cdddr)
08:36:51 <ehird> ;)
08:37:13 <Jedai> Espionage: check (RGB r g b) = (0 <= r) && (r < 256) && (0 <= g) && (g < 256) && (0 <= b) && (b < 256) <- was that what you searched ?
08:37:41 <mauke> > map (`replicateM` "ad") [1 .. 4]
08:37:41 <lambdabot>  [["a","d"],["aa","ad","da","dd"],["aaa","aad","ada","add","daa","dad","dda",...
08:37:47 <osfameron> meh.  It seems to make more sense to use the primitives than the abracadabra version, but I'll shut up now, as I've never seriously programmed lisp
08:37:53 <mauke> > concatMap (`replicateM` "ad") [1 .. 4]
08:37:54 <lambdabot>  ["a","d","aa","ad","da","dd","aaa","aad","ada","add","daa","dad","dda","ddd"...
08:37:55 <Espionage> well Jedai  I have another function to check if they are between the two numbers
08:37:58 <Espionage> but yeah
08:38:33 <mapreduce> mauke: Now make it generate CL defining them all. :)
08:38:50 <byorgey> Espionage: so, right, you can do  check (RBG r g b) = isValid r && isValid g && isValid b
08:39:03 <ehird> mapreduce: I've always thought lisps need a kinda inline-macro
08:39:05 <EvilTerran> you'll need a lazy symbol table to store them all in >:)
08:39:11 <ehird> can't think of a good name, but:
08:39:20 <byorgey> Espionage: you could also do something more general like  check (RBG r b g) = all isValid [r, g, b]
08:39:21 <ehird> (foo ...) is:
08:39:27 <dzlk> Ah, ok, R5RS provides arbitrary compositions up to four deep. Looks like CL does too, but the hyperspec doesn't say that, just lists them all.
08:39:29 <ehird> ((macro-lambda () ...))
08:39:34 <ehird> Kind of thing.
08:39:45 <mapreduce> ehird: There's macrolet, for 'temporary' macros.
08:39:55 <ehird> So, (foo CODE THAT GENERATES DEFINITIONS FOR THE CAR/CDR COMBINATIONS) does what you expect
08:39:58 <mapreduce> @go macrolet common lisp
08:40:00 <lambdabot> http://www.lisp.org/HyperSpec/Body/speope_fletcm_scm_macrolet.html
08:40:00 <lambdabot> Title: CLHS: Special Operator FLET, LABELS, MACROLET
08:40:03 <byorgey> Espionage: for just three things to check it's not a clear benefit, but you can see how the more general approach would be useful if you had a lot of individual things to check.
08:40:05 <ehird> mapreduce: Right, but a lot of the time you just want to include some compile-time code.
08:40:33 <mapreduce> Oh, you could write a reader macro to add in some code whenever caddadadadadadddadadr is encountered.. I think.
08:40:41 <mauke> #1=(progn #1#)
08:40:59 <dzlk> I usually feel like if I have to that many car/cdr compositions then I'm doing something wrong and should rethink the data structure, anyway :)
08:41:10 <Espionage> yeah byorgey  I agree
08:41:25 <Espionage> but im still getting a problem with validRGB   (RGB, r, b, g) = (validColour r) && (validColour b) && (validColour g)
08:41:47 <mapreduce> dzlk: Sure, but having them available (and tuples in Haskell) lets you do stuff before having to make named data structures.. so it helps in the thought process.
08:41:49 <byorgey> Espionage: that should be  validRBG (RGB r g b) = ...
08:41:52 <byorgey> no commas
08:41:55 <mapreduce> tuples and lists, I mean.
08:42:14 <Espionage> hmm , stupid mistake :P
08:42:27 <dzlk> mapreduce: True. Good point.
08:42:55 <ndm> i'm having difficulties with fixities
08:42:56 <lambdabot> ndm: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:43:06 <byorgey> > map (('c':) . (++"r")) $ concatMap (`replicateM` "ad") [1 .. 4]
08:43:07 <lambdabot>  ["car","cdr","caar","cadr","cdar","cddr","caaar","caadr","cadar","caddr","cd...
08:43:21 <ndm> i want to write: a |-> b & c
08:43:30 <ndm> and have it parse as a |-> (b
08:43:36 <Espionage> thanks alot byorgey
08:43:37 <ndm> and have it parse as a |-> (b & c)
08:43:44 <ndm> @messages
08:43:44 <byorgey> Espionage: you're welcome =)
08:43:45 <lambdabot> MarcWeber said 2d 1h 46m 53s ago: which are the option to be used to compile your option lib on ghc-6.8.2?
08:43:45 <lambdabot> dcoutts_ said 1d 1h 34m 33s ago: for a reference point, see http://docs.camlcity.org/docs/index.html and http://blog.camlcity.org/blog/lambdarank.html
08:43:51 <EvilTerran> ndm, ... so & needs a higher fixity than |-> ?
08:44:08 * byorgey guesses ndm's story doesn't end there...
08:44:23 <dzlk> map (('c':) . (++"r")) $ concatMap (`replicateM` "ad") [1..]
08:44:48 <ndm> that really is it
08:44:53 <ndm> c is a lambda, if that makes a difference
08:46:09 <ndm> hmm, i may have been getting some else wrong actually...
08:46:35 <mauke> *> 2 |-> 3 & \x -> sqrt x
08:46:35 <mauke> 3.732050807568877
08:47:38 <Deewiant> > 2 + sqrt 3
08:47:40 <lambdabot>  3.732050807568877
08:47:57 <ndm> thanks, i think i've probably got another type error, which was tripping me up - and merely made it look like fixities
08:49:03 <ndm> ah, got it - i had defined a local name tags and was calling (what i thought) was the global tags function
08:49:10 <ndm> hence the types were making little snese!
08:49:22 <byorgey> hehe, oops =)
08:49:46 <ndm> indeedly :)
08:49:53 <ndm> @seen MarcWebber
08:49:53 <lambdabot> I haven't seen MarcWebber.
08:49:56 <mauke> isn't ghc -Wall supposed to catch that?
08:50:03 <Deewiant> @seen MarcWeber
08:50:03 <lambdabot> MarcWeber is in #darcs, #ghc and #haskell. I last heard MarcWeber speak 1d 5h 38m 45s ago.
08:50:15 <ndm> @tell MarcWebber which project are you talking about options for?
08:50:16 <lambdabot> Consider it noted.
08:50:22 <ndm> mauke - I use Hugs
08:50:27 <mauke> oh, right
08:50:36 <Deewiant> ndm: too many 'b's in that Weber?
08:50:47 <ndm> quite perhaps
08:50:53 <ndm> @tell MarcWeber which project are you talking about options for?
08:50:54 <lambdabot> Consider it noted.
08:52:55 <Espionage> hmm what is the error " Not in Scope" ?
08:53:44 <mauke> > speng
08:53:45 <lambdabot>   Not in scope: `speng'
08:55:52 <dzlk> It means a word is undefined, in the scope of the expression it appears in.
08:56:04 <dzlk> > let speng = 2 in speng + 2
08:56:05 <lambdabot>  4
08:59:19 <dcoutts_> @seen Saizan
08:59:20 <lambdabot> Saizan is in #haskell-blah, #haskell-overflow, #haskell.it and #haskell. I last heard Saizan speak 8m 58s ago.
08:59:51 <dzlk> Ooh. Hey, I'm not who goes around telling people that if they don't know x they should go to their university and ask for their money back.
09:00:12 <mapreduce> dzlk: That would be me.
09:00:52 <dzlk> *nod* I'm reading Stop Sitting on the Type Fence.
09:01:40 <mapreduce> I would revise some of that if I could be bothered.  Or write a second edition of it and preserve the original so I can laugh at myself.
09:03:15 <dzlk> I think that of 99.9 percent of my nontrivial written output. :)
09:05:03 <Saizan> dcoutts_: pong
09:05:13 <dcoutts_> Saizan: hia :-)
09:05:26 <ChaoticMind|afk> hey, there was a function which is like filter, but stops at first violation, anyone remember off their top of their head? :d
09:05:37 <dcoutts_> Saizan: we should start thinking about the approach to take for the project
09:05:38 <mauke> takeWhile
09:05:41 <ChaoticMind|afk> thx
09:06:14 <Saizan> dcoutts_: ok, i was talking with paolino about his MakeMachine too
09:06:28 <dcoutts_> Saizan: right
09:07:06 <dcoutts_> Saizan: I don't yet understand the advantages and disadvantages of that approach
09:07:12 <dzlk> Hrr. And I only *just* noticed that I elided "the only one" in "I'm not the only one who... ". Clearly, more coffee is required.
09:08:58 <Saizan> dcoutts_: it seems to be less sketchy, mostly
09:09:16 <dcoutts_> Saizan: less sketchy?
09:10:39 <Saizan> dcoutts_: i mean wrt what has been implemented for the others
09:11:14 <dcoutts_> Saizan: the first prototype isn't so sketchy, the applicative stuff is very sketchy though, yes.
09:11:29 <dcoutts_> the first prototype passes some QC tests :-)
09:11:36 <Saizan> yeah :)
09:12:42 <Saizan> but it's not the system that finds what's not uptodate there, no?
09:13:23 <Espionage> can I map something to a list of lists and have it apply the function to every item ?
09:13:36 <Espionage> map isvalid [[bit]]
09:13:50 <Saizan> ?type \f -> map (map f)
09:13:52 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f1 (f a) -> f1 (f b)
09:14:13 <Saizan> ehm
09:14:48 <quicksilver> Espionage: (map.map) isvalid
09:15:10 <quicksilver> (map.map) (+1) [[2,3,4],[2,3],[7,8],[4]]
09:15:17 <quicksilver> > (map.map) (+1) [[2,3,4],[2,3],[7,8],[4]]
09:15:18 <lambdabot>  [[3,4,5],[3,4],[8,9],[5]]
09:15:25 <dcoutts_> Saizan: that prototype lets you modify files and then it rebuilds just the bits needed to make the target up to date
09:15:31 <quicksilver> initially it seems surprising that that works, because . is for combining unary functions and map is binary
09:15:37 <quicksilver> it's rather neat.
09:16:10 <dcoutts_> Saizan: there's a QC property that basically says, do make, touch a bunch of files, make again, check the property that everything is older than its targets
09:16:11 <Espionage> wow lambdabot  is an interpreter?
09:16:25 <quicksilver> it pretends to be
09:16:28 <quicksilver> actually it's a compiler :)
09:16:30 <quicksilver> it is cheating.
09:16:30 <mapreduce> Espionage: It has one.
09:16:32 <quicksilver> but it's useful.
09:16:34 <Espionage> haha nice :)
09:16:38 <EvilTerran> ?vixen are you an interpreter?
09:16:38 <lambdabot> yes, i am
09:16:45 <osfameron> an interpreter is just a forgetful compiler
09:16:48 <quicksilver> ?vixen do you say that to all the boys?
09:16:49 <lambdabot> i do occassionally, i guess
09:17:26 <EvilTerran> ?bot
09:17:26 <lambdabot> :)
09:18:07 <dzlk> > (map . map . map) (+1) [ [[2,3], [4,5]], [[6,7], [8,9] ]
09:18:08 <lambdabot>  Parse error at end of input
09:18:19 <dzlk> Eeh.
09:18:34 <mapreduce> I demoed lambdabot to someone looking over my shoulder yesterday and did appallingly badly.
09:18:53 <mapreduce> dzlk: What did you think of said article?
09:18:55 <dzlk> > (map . map . map) (+1) [ [[2,3], [4,5]], [[6,7], [8,9]] ]
09:18:56 <lambdabot>  [[[3,4],[5,6]],[[7,8],[9,10]]]
09:19:15 <cpoucet> Is there an easy way to split the natural numbers over a binary tree?
09:19:39 <mapreduce> Since writing that I've switched camps.
09:19:54 <Saizan> dcoutts_: yes, but it does so by recompiling everything
09:20:36 <dcoutts_> Saizan: oh right, well it's fixable :-)
09:20:50 <geezusfreeek> mapreduce: well, i personally liked the article, although it did seem, to me at least, to be a bit forgetful of the fact that static types don't necessarily have to hinder abstraction
09:21:00 <dzlk> I'd kinda guessed that. I was going to say that, from the article, it's not terribly clear why you are (were) on the dynamic side. :)
09:21:27 <geezusfreeek> but i do realize that you were aware of the fact, it just wasn't reflected very well in the article to me
09:21:32 <EvilTerran> cpoucet, what shape of binary tree? labelled nodes? labelled leaves?
09:21:51 <EvilTerran> in the first case, i think you can even make it balanced fairly easily
09:22:42 <cpoucet> EvilTerran: plain binary
09:22:49 <cpoucet> I want to distribute the entire [0...] over it
09:22:58 <mapreduce> dzlk: Because I didn't know enough.
09:22:58 <EvilTerran> (well, "balanced" - every branch of countable depth :P)
09:22:59 <EvilTerran> cpoucet, "plain binary" doesn't tell me anything
09:23:05 <dzlk> I like the way you made the case for exploratory programming (which is how I interpret the dynamic typing section).
09:23:05 <mapreduce> dzlk: I still think dynamic is easier for new programmers, but I'd love to be proved wrong on that.
09:23:06 <EvilTerran> what's the data decleration?
09:23:14 <cpoucet> data Tree a = Tree (Tree a) a (Tree a)
09:23:17 <cpoucet> EvilTerran: it's vincenz ;)
09:23:35 <EvilTerran> ah, i see... labelled branches, then
09:23:37 <cpoucet> EvilTerran: I want to statically distribute the naturals+0 over that
09:23:46 <geezusfreeek> i think the main appeal for dynamic types is that it is less frustrating… your program may be wrong, but at least it makes it past the compilation stage!
09:23:49 <cpoucet> but I can't come up with a scheme
09:23:52 <EvilTerran> (as compared to data Tree a = Leaf a | Branch (Tree a) (Tree a)
09:23:55 <cpoucet> eitiher I end up with multiple nodes for a value
09:23:58 <dzlk> mapreduce: I think I agree. With both clauses.
09:24:11 <cpoucet> Or I don't have 0
09:24:41 <mapreduce> geezusfreeek: Sure.  One great improvement for static compilers would be to show you why your code is broken, as well as telling you in terms of 'types don't match' etc.
09:24:52 <mapreduce> I can't think of a good example for that though, right now.
09:24:53 <geezusfreeek> yeah, that's exactly what i meant
09:25:00 <cpoucet> EvilTerran: The problem is defining a recurive function that defines the labels + a function that finds the right label
09:26:00 <EvilTerran> couldn't you include/exclude zero just by adding/subtracting one at each node?
09:26:05 <geezusfreeek> i think beginners to static typing are too often told "oh look, this doesn't compile. it's because this is the wrong type!" without really explaining what a type even is or how it works
09:26:17 <cpoucet> EvilTerran: ye,s that's true, but even if I start counting as 1, it's not trivial
09:26:41 <geezusfreeek> teaching beginners how the foundations of type theory, if they are able to handle it, would solve half the problem i think
09:26:52 <geezusfreeek> s/how the/the/
09:27:01 <EvilTerran> > iterate (concatMap$ \x -> [2*x, 2*x + 1]) [1]
09:27:02 <lambdabot>  [[1],[2,3],[4,5,6,7],[8,9,10,11,12,13,14,15],[16,17,18,19,20,21,22,23,24,25,...
09:27:06 <mapreduce> geezusfreeek: I'll reserve judgement until I know the foundations of type theory.
09:27:20 <cpoucet> EvilTerran: I had that
09:27:28 <cpoucet> EvilTerran: but how do you decide then where to go to find the node
09:27:33 <geezusfreeek> i probably should have qualified that statement a bit further
09:27:53 <cpoucet> EvilTerran: a boolean function for "left-right" at each node is less than trivial with that encoding
09:28:06 <EvilTerran> you can work out the path of left- and right- moves in reverse by repeated division by two, i think
09:28:13 <geezusfreeek> i'll just leave it unqualified… wording is not my thing today for some reason
09:28:23 <cpoucet> EvilTerran: nope
09:28:25 <dzlk> I think, also, that for beginners there's a tendency to "just get it to compile" rather than think about why it didn't and take the lesson, so the language maybe feels more pedantic than it really is.
09:28:30 <EvilTerran> no?
09:28:38 * cpoucet shakes his head
09:28:47 <cpoucet> I had that encoding
09:29:28 <EvilTerran> ... i'd expect positions to correspond to the bits of the number. oh well.
09:30:23 <geezusfreeek> i thing i don't think i've seen in any statically typed languages that would be nice for exploratory programming would be the ability to allow badly typed functions to simply throw a warning instead of an error if the compiler can tell that the function will not be used at runtime
09:30:49 <cpoucet> EvilTerran: :|
09:31:20 <EvilTerran> geezusfreeek, that reminds me of a suggestion i heard to replace badly-typed expressions with error "<the typechecking error message>" for debugging purposes
09:31:32 <cpoucet> EvilTerran: if it were simple I wouldn't be asking :)
09:31:39 <geezusfreeek> hmm, that's an interesting idea too
09:31:54 <geezusfreeek> removes some guesswork from the compiler too
09:32:22 <geezusfreeek> although the type error is already known from the compilation
09:32:35 <geezusfreeek> i don't really think that would be all that helpful
09:33:23 <EvilTerran> well, it'd let you load modules in ghci with some badly-typed declerations
09:34:09 <geezusfreeek> ooooh, unless the error message also outputs the known values of the subexpressions involved
09:34:26 <pejo> geezusfreeek, I don't think people should need to know type theory to be able to use a compiler. There's plenty of researchers who know type theory - let them figure out how to build useful tools.
09:35:02 <prunedtree> hello
09:35:16 <geezusfreeek> pejo: i also agree with that, but until we have a compiler that can explain what's wrong without using type theory terminology i think learning type theory is the only really sure way to be able to work with a compiler
09:35:23 <geezusfreeek> prunedtree!
09:35:54 <geezusfreeek> *learning _some_ type theory
09:35:59 <dzlk> It might be interesting to have a lang with a "type-error value" and let a program march on past a badly typed expression, adding information to the error as it goes, so you get something like a backtrace.
09:36:33 <prunedtree> I have a small question
09:36:54 <prunedtree> is there an easy way to give partial type declarations ?
09:37:11 <prunedtree> looks like type inference doesn't like monad transforms :/
09:37:11 <mrd> dzlk: march on past?
09:37:15 <pejo> geezusfreeek, do you have any examples of that "type theory terminology"?
09:37:32 <mrd> dzlk: normally an untyped expression is one which gets "stuck"
09:37:40 <mrd> s/untyped/poorly typed/
09:38:02 <dzlk> I'm trying to think of a good example.
09:38:03 <prunedtree> simple exemple:
09:38:04 <prunedtree> tmcode = lift (newArray (1,10) 0)
09:38:04 <prunedtree> tm = runSTArray (evalStateT tmcode (-1))
09:38:10 <prunedtree> doesn't type
09:38:15 <prunedtree> needs tmcode :: (Ix i, Num i, Num v) => StateT c (ST s) (STArray s i v)
09:38:24 <prunedtree> which is ... heavy
09:38:41 <mrd> you can annotate subterms
09:38:44 <geezusfreeek> pejo: anything that refers to types, really. you have to understand where they come from, how they are inferred, etc.
09:39:10 <pejo> geezusfreeek, people use Java quite happily without knowing anything about type theory though?
09:39:23 <quicksilver> prunedtree: turn off the dreaded monomorphism restriction.
09:39:29 <geezusfreeek> "Couldn't match expected type `a' against inferred type `b'" … without understanding the type inference algorithm, how am i to know why the compiler chose these 'a' and 'b' types?
09:39:40 <prunedtree> quicksilver : i can do that ? that would be great indeed
09:39:42 <quicksilver> prunedtree: as far as I can see there is no reason that wouldn't infer cleanly, apart from that.
09:39:50 <mrd> pejo: they know about subtyping, base types, and parametric polymorphism now
09:39:50 <quicksilver> -fno-monomorphism-restriction
09:39:53 <quicksilver> AFAIR
09:40:12 <dzlk> Okay, let's say you tried to do map f ([a] ++ a). [a] ++ a returns "this is an error", but the map happens anyway and returns an object that denotes "I would have mapped f over this if it weren't an error".
09:40:13 <geezusfreeek> pejo: they still had to learn a little bit. it helps that they have to put so many explicit annotations
09:40:34 <prunedtree> quicksilver : great, it works !
09:40:37 <dzlk> Maybe that's silly.
09:40:39 <quicksilver> prunedtree: yay :)
09:40:48 <quicksilver> dzlk: it's not silly.
09:40:54 <prunedtree> I have the feeling I'm starting to get haskell
09:41:08 <quicksilver> dzlk: but it would be a interestin UI challenge to produce comprehensible messages
09:41:13 <prunedtree> getting monads & monad transformers right was a real "haha" moment
09:41:15 <quicksilver> dzlk: I thin it might be quite hard :)
09:41:25 <prunedtree> the joy of writing code that actually types right on the first try ~~
09:41:39 <geezusfreeek> prunedtree: :)
09:41:52 <quicksilver> the further joy of writing code which, once it types + compiles, actually works first try.
09:41:56 <pejo> geezusfreeek, does it matter to you how the compiler infered the type?
09:42:08 <geezusfreeek> it does when i have to actually fix the problem
09:42:20 <prunedtree> I like how you can read the source of ghc's libs with hoogle
09:42:35 <prunedtree> I have to admit I really like all the low level hacking
09:42:37 <geezusfreeek> i have to understand the rules
09:42:42 <prunedtree> i'm an asm coder at heart after all :)
09:43:50 <prunedtree> are other functional language libraries also written so close to the bare metal ?
09:45:34 <cpoucet> prunedtree: oh wow, you in here :)
09:45:48 <cpoucet> prunedtree: jumped ship?
09:46:48 <dzlk> prunedtree: O'Caml?
09:47:04 <pjd_> prunedtree: MLKit?
09:47:52 <prunedtree> so SML/ocaml libraries are also written in a way similar to Haskell's ?
09:48:00 <prunedtree> (at least the ghc implementation)
09:48:20 <pejo> mrd, I'm not so sure students (for example) understand that, after talking to those who teach intro programming classes.
09:48:21 <prunedtree> i'm thinking about things like Data.Array.Base for instance
09:49:27 <mrd> pejo: frankly, most students just cargo cult their way through it
09:49:30 <geezusfreeek> i agree, they are not taught that way, and i see that as a problem
09:49:43 <mrd> pejo: (and sadly, many "professional" programmers too)
09:51:46 <pejo> mrd, heh, that was my next question - how many of the professional ones understand it.
09:53:15 <geezusfreeek> some day, we may be able to just feed some general specs to a computer, have it turn them into types, have it implement those types as function using a theorem prover, and then accept further refinements to the spec after the programmer tests the program, but until that day comes, programmers have to know how to perform those transformations themselves
09:53:32 <geezusfreeek> and doing each of those steps in an ad hoc way just adds more complexity to the process
09:54:01 <mrd> having a theorem prover capable of that is tantamount to AI
09:54:30 --- mode: ChanServ set -o shapr
09:54:53 <geezusfreeek> a sufficiently restrictive type system should make the theorem prover trivial. the hard part, i think, would be the translation of the specs to the types, because surely the type system would be a bit too complex for a human to efficiently manipulate it himself
09:55:06 <pejo> geezusfreeek, types are by nature "lossy". If they aren't, it's as hard to write the type signature as it is to write the function itself.
09:55:18 <geezusfreeek> pejo: right
09:55:37 <geezusfreeek> note the qualifier "may" at the beginning of what i said ;)
09:56:57 <mattam> pejo: you can have as precise types as you want. You may be overspecifying if you happen to reflect the function in the type.
09:58:45 <pejo> mattam, ah, you're just the type (!) of person needed! How do you get the correct implementation if your type isn't very precise?
09:59:22 <mofmog> is there any way to clear the input buffer?
09:59:44 <geezusfreeek> yeah, the idea in my mind is that the types can be very general at first, and the theorem prover can just choose the simplest implementation if it finds there is more than one satisfying implementation. then refinement of the specs can restrict the type further if needed
10:00:34 <geezusfreeek> so the prover would basically be just breadth first search
10:00:42 <ddarius> Writing a "general spec" that can be used to generate an implementation is just programming.
10:01:24 <geezusfreeek> yes, that's why the person doing it is still a programmer
10:01:48 <mattam> The less precise the spec, the easier to implement it. nat is trivial to implement, {x : nat | x = 0 -> halts(turing_maching(n)) } is next to impossible :)
10:01:50 <ziman> geezusfreeek, do you mean something like djinn?
10:02:07 <geezusfreeek> ziman: like a crazy djinn
10:02:09 <geezusfreeek> alright time to eat
10:02:49 <Bonus> guys i have this function
10:02:50 <Bonus> segments lst = (map . map) fst . groupBy (\(a, b) (c, d) -> a `compare` b == c `compare` d) . zip lst . tail $ lst
10:03:07 <Bonus> it's supposed to split a list as to when the elements are ascending and descending
10:03:14 <Bonus> but it chops off the last element :[
10:03:32 <Bonus> otherwise it works but the last element gets chopped off because of the zipping with tail
10:05:16 <Bonus> what i'm looking for is a function that will take something like
10:05:29 <Bonus> [4,3,2,1,2,3,4,5,6,7,5,4,3,1,-1,-4]
10:05:32 <Bonus> and split it into
10:06:12 <Bonus> [4,3,2], [1,2,3,4,5,6], [7,5,4,3,1,-1,-4]
10:08:24 <edwardk> EvilTerran: thats a fun typechecking rule. ghc -force? =)
10:08:47 <edwardk> er. i just realized i came back and responded to something 40 minutes late because my screen was rolled back ;)
10:09:25 <dzlk> Bonus: this is tangential, but, what's supposed to happen in the case that two consecutive elements are equal?
10:09:45 <conal> Bonus: how about repeating the last element in the tail?  or zip lst (head lst : lst) instead of tail?
10:09:59 <Bonus> hmmm
10:10:09 <Bonus> if they're equal hmm
10:10:09 <conal> Bonus: and tweaking the (map.map) fst if necessary.  just a guess.
10:10:15 <conal> yeah
10:10:30 <Bonus> it doesn't have to be strictly ascending or descending
10:10:36 <Bonus> just loosely
10:10:36 <Bonus> as in
10:10:39 <conal> Bonus: maybe use (<) instead of compare
10:10:40 <Bonus> [1,2,3,3,3,4]
10:10:49 <conal> Bonus: or (<=)
10:10:57 <Bonus> hmm yeah
10:11:08 <Bonus> i thought of just adding the last element
10:11:11 <Bonus> but what if there's
10:11:19 <Bonus> [1,2,3,-1]
10:11:37 <Bonus> then it would add it into the last segment which obviously wouldn't hold
10:12:49 <Bonus> there must be a really elegant solution hmph
10:13:55 <conal> Bonus: maybe if you specify the problem really clearly, some simple solutions will pop out.
10:14:18 <Bonus> yeah hmmm
10:14:19 <Cale> One thing which might be interesting is group (zipWith (<=) xs (tail xs))
10:14:43 <bogomipz> noob question; let's say i have a list of pairs and want to group by each pair's first element
10:14:47 <Cale> The last group is one element short, but the lengths are appropriate.
10:14:50 <bogomipz> wouldn't it be far more useful if i could just write groupBy fst theList ?
10:14:53 <Cale> (otherwise)
10:14:54 <bogomipz> the way groupBy is defined i must pass it \x y -> fst x == fst y
10:14:55 <cpoucet> :t filterM
10:14:58 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
10:15:04 <Bonus> won't zipWith (<=) xs (tail xs) just give me a list of [Bool]
10:15:15 <conal> Bonus: use that [Bool]
10:15:32 <conal> Bonus: to help the rest of the way
10:15:50 <Cale> bogomipz: Well, there's a function called "on" which is in Data.Function with which you can write:
10:16:08 <Cale> > groupBy ((==) `on` fst) [(1,2),(1,3),(2,3)]
10:16:09 <lambdabot>  [[(1,2),(1,3)],[(2,3)]]
10:16:10 <Bonus> hmm
10:16:28 <Bonus> i'll try playing with that, thanks
10:16:40 <Cale> bogomipz: The thing is, you don't always want to group by a property which is expressible in that way.
10:16:42 <conal> Bonus: great.  maybe i'tll lead to other ideas.
10:19:57 <Cale> @let splitInto _ [] = []; splitInto [] xs = [xs]; splitInto (n:ns) xs = let (us,vs) = splitAt n xs in us : splitInto ns vs
10:19:57 <lambdabot> Defined.
10:20:17 <conal> Bonus: try repeating the last element of that [Bool].  then zip the original list with the extended [Bool] and group by the bool, then drop the bools.
10:20:20 <Cale> @let groupMonotone xs = splitInto (init . map length . group $ zipWith (<=) xs (tail xs)) xs
10:20:21 <lambdabot> Defined.
10:20:34 <Cale> > groupMonotone [4,3,2,1,2,3,4,5,6,7,5,4,3,1,-1,-4]
10:20:35 <lambdabot>  [[4,3,2],[1,2,3,4,5,6],[7,5,4,3,1,-1,-4]]
10:21:16 <Bonus> oooooooh
10:21:19 <Bonus> freaking awesome
10:21:22 <cpoucet> :t liftM
10:21:23 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
10:21:25 <cpoucet> :t ap
10:21:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
10:21:31 <Bonus> @src splitInto
10:21:32 <lambdabot> Source not found. You speak an infinite deal of nothing
10:21:35 <Bonus> wtf
10:21:44 <Cale> Bonus: just defined it above
10:22:16 <bogomipz> Cale: kthx, that's a bit better at least, i see how the current definition is more general, but i thought most of the time you would want to test equality of some function applied to both elements
10:22:24 <Bonus> oh
10:22:26 <Bonus> didn't see that
10:22:30 <Bonus> c00l
10:22:45 <dons> mm. stream fusion is nice
10:23:29 <dcoutts_> :-)
10:23:34 <Cale> Bonus: There's something a bit wrong-seeming about computing the lengths like that. There ought to be a nice way which is closer to the directly recursive solution.
10:23:56 <dcoutts_> dons: so we're starting v.soon on the fusible unicode string project
10:24:03 <Jedai> bogomipz: Yes, that's true, even more often you want to regroup the elements that have the same "hash" without regards to wether they're adjacent or not. The best way to do that is to use Data.Map
10:24:24 <dcoutts_> dons: the student nearly broke the printer with the unicode specification :-)
10:24:55 <yav> dcoutts_: what's that project?
10:25:20 <tromp> @let ups xs = zipWith (<=) xs (tail xs)) xs
10:25:21 <lambdabot>  Parse error
10:25:30 <Cale> One rather handy use for groupBy with a strange function is groupBy (<), which is exactly what you need to pick out, say, the sections of a document from the heading levels.
10:25:31 <tromp> @let ups xs = zipWith (<=) xs (tail xs)
10:25:31 <lambdabot> Defined.
10:25:38 <tromp> > ups [4,3,2,1,2,3,4,5,6,7,5,4,3,1,-1,-4]
10:25:39 <lambdabot>  [False,False,False,True,True,True,True,True,True,False,False,False,False,Fal...
10:26:07 <Cale> > groupBy (<) [1,2,3,4,2,3,4,1,2,3,3,2,3,1,2,3]
10:26:07 <lambdabot>  [[1,2,3,4,2,3,4],[1,2,3,3,2,3],[1,2,3]]
10:26:33 <Cale> > map (tail . groupBy (<)) . groupBy (<) $ [1,2,3,4,2,3,4,1,2,3,3,2,3,1,2,3]
10:26:34 <lambdabot>  [[],[],[]]
10:26:36 <Cale> er...
10:26:44 <Cale> > map (groupBy (<) . tail) . groupBy (<) $ [1,2,3,4,2,3,4,1,2,3,3,2,3,1,2,3]
10:26:45 <lambdabot>  [[[2,3,4],[2,3,4]],[[2,3,3],[2,3]],[[2,3]]]
10:27:49 <dcoutts_> yav: to make a unicode version of bytestring
10:27:51 <Jedai> > let l = [4,3,2,1,2,3,4,5,6,7,5,4,3,1,-1,-4] in map snd . groupBy ((==) `on` fst) . zip ups l $ l
10:27:52 <lambdabot>  Couldn't match expected type `(a, b)'
10:28:11 * bogomipz has so much fp to learn
10:28:15 <Jedai> > let l = [4,3,2,1,2,3,4,5,6,7,5,4,3,1,-1,-4] in map snd . groupBy ((==) `on` fst) . zip (ups l) $ l
10:28:16 <lambdabot>  Couldn't match expected type `(a, b)'
10:28:31 <newsham> lambdabot build error: State/L.hs:4:0:  error: imports.h: No such file or directory
10:28:44 <newsham> solution: add link to imports.h in State directory.
10:29:10 <yav> dcoutts_: we have some support for that in the utf8string package
10:30:52 <dcoutts_> yav: oh yes, the generalised encoding/decoding for anything supporting certain uncons like operations
10:31:04 <Jedai> > let l = [4,3,2,1,2,3,4,5,6,7,5,4,3,1,-1,-4] in map (map snd) . groupBy ((==) `on` fst) . zip (ups l) $ l
10:31:05 <lambdabot>  [[4,3,2],[1,2,3,4,5,6],[7,5,4,3,1,-1]]
10:31:36 <yav> yeah, we used the generalized stuff so that it works with both strict and lazy bytestrings
10:31:37 <Cale> Bloody last element :)
10:31:46 <dcoutts_> yav: btw, I stole some code from that package to put into cabal, I lifted the testsuite too. I think I put the credits in appropriately.
10:32:15 <newsham> cale: how do you make lambdabot identify to nickserv?
10:32:18 <dcoutts_> yav: right, we've not decided yet if we should have strict or lazy or both for unicode text
10:32:22 <yav> that's ok, all the code is BSD.  please let us know if you notice bugs
10:33:10 <Cale> newsham: passwd.rc contains a command which sends an identify message to nickserv
10:33:17 <Cale> msg freenode:nickserv identify <password>
10:33:20 <dcoutts_> yav: how do you use that code then, you decode from bytestring direct into String ?
10:33:23 <newsham> ty
10:33:34 <tromp> @let ups2 xs = zipWith (<=) (0:xs) xs
10:33:35 <lambdabot> Defined.
10:33:40 <tromp> > ups2 [4,3,2,1,2,3,4,5,6,7,5,4,3,1,-1,-4]
10:33:41 <lambdabot>  [True,False,False,False,True,True,True,True,True,True,False,False,False,Fals...
10:33:41 <Cale> newsham: and then in online.rc, it's sourced as "rc passwd.rc"
10:34:01 <Jedai> > let l = [4,3,2,1,2,3,4,5,6,7,5,4,3,1,-1,-4] in map (map snd) . groupBy ((==) `on` fst) . zip (tail $ ups2 l) $ l
10:34:02 <lambdabot>  [[4,3,2],[1,2,3,4,5,6],[7,5,4,3,1,-1]]
10:34:19 <yav> dcoutts_:  most of the time you work with the bytestrings as the are
10:34:44 <yav> you only need to decode if you really need the string (e.g., to compute its length in characters)
10:34:46 <tromp> dont use tail on ups2
10:34:58 <Deewiant> > let l = [4,3,2,1,2,3,4,5,6,7,5,4,3,1,-1,-4] in map (map snd) . groupBy ((==) `on` fst) . zip (ups2 l) $ l
10:34:59 <lambdabot>  [[4],[3,2,1],[2,3,4,5,6,7],[5,4,3,1,-1,-4]]
10:35:05 <Jedai> tromp: That don't work either
10:35:17 <tromp> it wld if first run goes up:)
10:35:22 <dcoutts_> yav: so eg decoding xml you do as ascii and then just decode the text content etc?
10:35:45 <Jedai> @let ups3 (x:xs) = zipWith (<=) (x:x:xs) (x:xs)
10:35:46 <lambdabot> Defined.
10:35:59 <Jedai> > let l = [4,3,2,1,2,3,4,5,6,7,5,4,3,1,-1,-4] in map (map snd) . groupBy ((==) `on` fst) . zip (ups3 l) $ l
10:36:00 <lambdabot>  [[4],[3,2,1],[2,3,4,5,6,7],[5,4,3,1,-1,-4]]
10:36:33 <tromp> you'd need to put 2x-y in front of a list x:y:..
10:36:42 <dcoutts_> yav: anyway, our plan is to present the same interface as Data.ByteString.Char8 but with real Char, not Char8 fakery
10:36:47 <tromp> to preserve direction of 1st run
10:37:13 <Jedai> @let ups3 xs = (\b:bs -> b:b:bs) $ zipWith (<=) (xs) (tail xs)
10:37:14 <lambdabot>  Parse error
10:37:19 <yav> dcoutts_: yeah, that would be the idea, although i have not done it.  i think you could even leave the text data as is, as long as you dont really need to do anything.
10:37:21 <dcoutts_> yav: and underneath we'd use some sensible representation and provide functions for converting to external formats (as a bytestring) like utf8,16,32
10:37:25 <Jedai> @let ups4 xs = (\(b:bs) -> b:b:bs) $ zipWith (<=) (xs) (tail xs)
10:37:26 <lambdabot> Defined.
10:37:35 <Jedai> > let l = [4,3,2,1,2,3,4,5,6,7,5,4,3,1,-1,-4] in map (map snd) . groupBy ((==) `on` fst) . zip (ups4 l) $ l
10:37:36 <lambdabot>  [[4,3,2,1],[2,3,4,5,6,7],[5,4,3,1,-1,-4]]
10:37:46 <Jedai> Ah ! :P
10:37:58 <Deewiant> > let l = [-4,3,2,1,2,3,4,5,6,7,5,4,3,1,-1,-4] in map (map snd) . groupBy ((==) `on` fst) . zip (ups4 l) $ l
10:37:59 <lambdabot>  [[-4,3],[2,1],[2,3,4,5,6,7],[5,4,3,1,-1,-4]]
10:38:05 <dcoutts_> yav: it also means we don't need to validate the encoding except when converting from an external representation
10:38:35 <edwardk> jedai: nice
10:39:15 <Jedai> edwardk: It was an uphill battle ! On the other hand splitInto from Cale seems interesting as an addition to Data.List
10:39:37 <Cale> I should think about my implementation of splitInto a bit more.
10:39:41 <yav> dcoutts_: we do the validation when we decode (i.e., extract a character).
10:39:57 <Deewiant> > groupMonotone [-4,3,2,1,2,3,4,5,6,7,5,4,3,1,-1,-4]
10:39:58 <lambdabot>  [[-4],[3,2],[1,2,3,4,5,6],[7,5,4,3,1,-1,-4]]
10:40:04 <Jedai> Cale: It can do many interesting things easy
10:40:19 <Deewiant> doesn't quite work there :-)
10:40:20 <yav> i think that error handling with utf8 is a bit of a thorny issue, we use a replacement character to report malformed bytes
10:40:29 <tromp> > groupMonotone [3,5,1,2]
10:40:30 <lambdabot>  [[3],[5],[1,2]]
10:41:08 <edwardk> @source splitInto
10:41:08 <lambdabot> splitInto not available
10:41:09 <Syzygy-> I wrote a potential groupMonotone for my PhD-thesis... :)
10:41:19 <mofmog> so i have an input procedure that's nice and all but it keeps key presses in a buffer
10:41:25 <Cale> Syzygy-: oh?
10:41:28 <mofmog> i'm using hWaitForInput and getChar
10:41:40 <mofmog> so if hWaitForInput is true, then i getChar
10:41:58 <edwardk> ah--  splitInto _ [] = []; splitInto [] xs = [xs]; splitInto (n:ns) xs = let (us,vs) = splitAt n xs in us : splitInto ns vs -- found it
10:42:06 <Syzygy-> Cale: http://mpc723.mati.uni-jena.de/~mik/SaneblidzeUmbleSigns.pdf
10:42:30 <Syzygy-> Cale: It's one of the first functions that get defined in there.
10:42:46 <Cale> Syzygy-: :)
10:45:15 <dcoutts_> yav: yeah, it's hard to know what to do about that
10:45:33 <dcoutts_> yav: since at the point that we're decoding we don't really have the context to report good errors
10:45:56 <dcoutts_> yav: and it's important to do decoding lazily/incrementally
10:49:53 <edwardk> > let bitonic =  (<= 2) . length . groupMonotone in bitonic [1,2,3,2,1]
10:49:54 <lambdabot>  True
10:50:14 <Cale> Syzygy-: Jackson and Goulden have this thing called the Pattern Algebra which I learned about since I took Jackson's combinatorics courses. We actually used it to count the permutations which had rising partitions with parts of specified length and things like that.
10:50:28 <Syzygy-> Cale: Neat.
10:50:43 <Syzygy-> Cale: I mainly needed to be able to split things into rising and falling streaks.
10:54:02 <Cale> "Haskell is one of the stricter functional programming languages." -- a funny sounding comment to a Haskell programmer ;)
10:54:21 <Bonus> haha
10:54:37 <Bonus> who said that
10:55:14 <mrd> someone who is not a haskell programmer
10:55:22 <Cale> That's in Syzygy-'s thesis. He means it in the sense of formalism rather than evaluation strategy.
10:55:31 <Bonus> ah
10:55:37 <Bonus> yeah the funny is in the double entendre
10:56:27 <ehird> Bonus: i have no idea how you can interpret that line sexually
10:56:29 <ehird> but please do not tell me
10:56:45 <mrd> that's what -blah is for
10:56:52 <Bonus> haha
10:56:56 <Bonus> ah yes well you see,
10:57:16 <ehird> someone have any mind bleach
10:57:18 <ehird> quickly?
10:57:40 <Bonus> but srsly i think "double entendre" doesn't *have* to have a sexual connotation
10:58:04 <ehird> Bonus: no but most commonly.
10:58:22 <Bonus> ah
10:58:34 <Bonus> well i guess you learn about everything on this channel
10:58:56 <lament> Haskell is strict and likes to punish.
10:59:04 <Bonus> lol
10:59:19 <ehird> lament: if Bonus is into that kind of stuff i guess..
11:02:00 <edwardk> lament: it is a bondage and discipline language after all
11:04:10 <Syzygy-> Actually, it's probably in my (rejected) paper rather than the thesis. The code is in both, but the thesis doesn't discuss Haskell anywhere NEAR as much.
11:04:11 <bourbaki> hidiho
11:06:13 <bourbaki> suppose you had a graph with nodes that hold tokens of an attached type, and arrows beeing functions in that graph that you can use the usual arrow operations on, would a graph like that form a cartesian closed category if you can also uncurry all arrows that have more than one parameter?
11:08:58 <paolino> is that the question to use to see if there is a bot behind a nick ?
11:09:15 <bourbaki> no
11:09:46 <paolino> then I'm still not a bot :)
11:09:55 <Bonus> im a bot
11:09:56 <Bonus> beep boop
11:11:26 <czakey> so lets do some tricks
11:11:32 <czakey> like robo-dance
11:11:34 <czakey> and so on
11:11:35 <czakey> ;p
11:12:18 <newsham> binary solo:  one one one one zero one zero zero one one!
11:16:59 <paolino> rot-tom-bot-tom-rot-bot
11:24:49 <edwardk> bourbaki: since you say uncurry you imply that you have products, but i didn't see them mentioned in the description
11:25:02 <edwardk> bourbaki: or maybe i'm being slow
11:25:54 <edwardk> bourbaki: or do you mean arrows being 'Arrows' in the john hughes sense, so products are implicitly baked in?
11:27:33 <edwardk> if you have Hughes arrows you have a cartesian categoy, if you add an eval morphism and currying you get a cartesian closed category by construction
11:28:17 <edwardk> bourbaki: http://comonad.com/haskell/categories/dist/doc/html/categories/Control-Category-Cartesian-Closed.html -- for playing around with, the CCC stuff should be sound
11:28:18 <lambdabot> http://tinyurl.com/6jcqnq
11:28:20 <bourbaki> edwardk: yes
11:28:32 <bourbaki> OH!
11:29:12 <edwardk> bourbaki: be warned the 'Cartesian' class there should be called 'PreCartesian' or something, a real Cartesian category would be (Monoidal (Prod k) k, Cartesian k)
11:29:28 <edwardk> bourbaki: and that assumes you have 6.9 installed
11:30:24 <bourbaki> well i just wanted to know that because i wanted to build up a tool that allows you to compile graphs like that
11:30:26 <edwardk> oh, wait, i forgot you don't quite have a cartesian category from just hughes arrows iirc, let me check what it was
11:33:20 <bourbaki> is there any known gain for compiling in the programs beeing cartesian closed?
11:34:00 <edwardk> Hrmm. I guess you do get the rules for http://comonad.com/haskell/categories/dist/doc/html/categories/Control-Category-Bifunctor-Monoidal.html, since in haskell Bottom is a valid 'identity' for (,) bottom and you can use 'arr fst' and 'arr snd' to implement idr and idl.
11:34:01 <lambdabot> http://tinyurl.com/66c3qr
11:34:15 <edwardk> and you can abuse pure to define associate, etc.
11:35:33 <bourbaki> what is the gain of knowing that they are cartesian closed?
11:36:05 <edwardk> bourbaki: basically it just gives you that you have arbitrary products and 'exponentials', not sure that it wins you anything for your purposes
11:36:39 <bourbaki> well i thought that if you knew that you would maybe be able to build a system that rewrites your functions
11:37:05 <bourbaki> like in genetic programs, and then test their speeds to optimize a function
11:37:12 <edwardk> it gives you the ability to swap back and forth between curried and uncurried representation, etc. and enough power to express the lambda calculus
11:38:06 <edwardk> well, if you have it as a rewriting system, and you are cartesian closed, then you may have a _disadvantage_ because you can probably write non-terminating functions since its a nice lambda calculus setting ;)
11:38:54 <bourbaki> ok dang so i can not get these to be cartesian closed then right?
11:39:16 <bourbaki> is there something a little bit weaker?
11:39:18 <edwardk> well you can, but you open yourself up to nontermination unless you add some other set of constraints to their construction
11:39:55 <bourbaki> my idea is to use that for mathematical functions without cycles in these graphs
11:40:05 <edwardk> well, if you get rid of currying and eval morphisms you get a cartesian category, but i don't quite know what your goal is here
11:40:09 <bourbaki> so these should always terminate with a product
11:40:50 <edwardk> and i'm not really an expert in this domain so bear with anything i misspeak about =)
11:41:35 <edwardk> bourbaki: even without cycles you can express non-termination in the lambda calculus. (S I I) (S I I) is cycle free ;)
11:42:00 <bourbaki> i kind of try to see Arrows as small functions that i can work with in a compiler that will optimze the two functions into wo
11:42:06 <bourbaki> er one
11:42:42 <cpoucet> @hoogle (a -> Bool) -> [a] -> ([a], [a])
11:42:42 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
11:42:42 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
11:42:42 <lambdabot> Data.List.span :: (a -> Bool) -> [a] -> ([a], [a])
11:43:36 <cpoucet> :t partition
11:43:40 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
11:43:46 <cpoucet> :|
11:43:53 <edwardk> bourbaki: i'm not a huge fan of straight-up 'Arrows' simply because by rolling in 'arr' into the definition and assuming a particular form for product they give away too much of the farm
11:44:42 <edwardk> there aren't many arrows by that definition, you've already given up the dual category, lots of ways you can constrain argument types by construction, etc.
11:45:17 <edwardk> so there go CGI arrows or pipe arrows, etc =/
11:46:00 <bourbaki> what if my graphs/programs are expressible as directed graphs?
11:46:04 <edwardk> otoh, that control.category stuff i had there isn't a panacea either because my attempt to model functors/bifunctors over arbitrary categories runs afoul of haskell's type system
11:46:19 <bourbaki> A directed graph consists of a set of arrows and a set of vertices, and two functions from the arrow set to the vertex set, specifying each arrow's start and end vertex. The category of all directed graphs is thus nothing but the functor category SetC, where C is the category with two objects connected by two morphisms, and Set denotes the category of sets.
11:46:20 <edwardk> bourbaki: what is your reduction rule though?
11:46:48 <bourbaki> the rection rule would be baking two arrows into one?
11:47:07 <edwardk> bourbaki: well, you talked earlier about currying and application
11:47:36 <bourbaki> ah well if you have a function that would take two seperable parameters
11:47:51 <edwardk> bourbaki: if you can just take two arrows and concatenate them associatively, and you have identity arrows for everything then all you have is a category
11:48:11 <bourbaki> right but not a very interesting one
11:48:14 <edwardk> sure
11:48:23 <bourbaki> my programs would be interpreted
11:48:31 <bourbaki> so the nodes are token containers like in a petri net
11:48:43 <bourbaki> and the program tosses the tokens around in that network
11:48:58 <bourbaki> so just having a id on each node is not a real problem
11:49:22 <edwardk> *nods* but i think without some extra structure, like a type system, etc you don't have any guarantee that the tossing ever stops, right? or do you want this to be turing complete in which case thats not a problem
11:49:29 <bourbaki> currying and uncurring will modify the graph
11:50:15 <bourbaki> well i just want to use if for a toolbox for continuous functions
11:51:15 <edwardk> so you're willing to allow for non-terminating functions then?
11:52:00 <bourbaki> http://video.google.de/videoplay?docid=-979203120692178262
11:52:02 <lambdabot> Title: Real Time Fluid Solver 3
11:52:09 <bourbaki> thats what i want to apply it two
11:52:11 <bourbaki> er to
11:52:33 <bourbaki> i want to be able to build up functions that make up such a landscape
11:53:18 <bourbaki> so if you want to have something like a height map your graph would have two input values and then for example one output that is the height of your landscape
11:53:38 <edwardk> heh that brings me back, i helped some folks out with optimizing RealFlow a bunch of years back =)
11:53:51 <bourbaki> :)
11:54:01 <edwardk> bourbaki: sure, then in that case you probably want all of your functions to terminate
11:54:24 <bourbaki> my idea is to be able to build up functions for the forces like that and build a framework that optimizes them
11:54:26 <edwardk> so do the standard GP thing, take a small non-turing complete language fragment, and bang on it ;)
11:55:13 <bourbaki> edwardk: do you know of any ressoucre that worked on optimizing that kind of functions for speed?
11:56:56 <edwardk> bourbaki: i've never tried to optimize them for speed. i did some work during a graduate certficate I picked up on AI on trying to apply downward pressure on their size to help derive expression trees that had 'better explanatory adequacy' about why they worked, but never saw anything about speeding them up
11:58:03 <bourbaki> i guess you would have to go pretty deep into building up a basic math system for that i guess
11:58:19 <edwardk> the trick is if you use GP to generate them you tend to get a 'good' solution accumulating intron code to avoid random perturbation affecting its high placement with respect to your fitness function, so there very process of natural selection tends to cause you to accumulate a bunch of dead-code, simply because having a lot of it tends to cause your tweaks to occur someplace harmless
11:58:36 <bourbaki> it also would be cool to have operators on the arrows then that do derivation and getting you the gradient etc
11:59:10 <edwardk> have you read Koza?
11:59:15 <bourbaki> nope
11:59:27 <bourbaki> whats the book title?
12:00:10 <edwardk> John Koza. Genetic Programming - On Programming Of Computers By Means Of Natural Selection -- IIRC
12:00:20 <edwardk> fairly standard work in this space
12:00:30 <bourbaki> ah cool i might get it
12:00:57 <bourbaki> basically the idea is to get these to compile to faster code
12:00:59 <spelling2> what do you call when a group of people of city has one favorite race over another?
12:01:00 <edwardk> read the first 5-6 chapters, skim the rest, they start to be case studies saying more or less the same thing
12:01:14 <bourbaki> but you could apply any kind of fitness fuction for other problems
12:01:48 <edwardk> bourbaki: then tune your fitness function for it. i;ll tell you though that you need to be careful about how much 'pressure' you give that side of your fitness function or you'll get a lot of really boring terrain ;)
12:02:21 <geezusfreeek> spelling2: racism?
12:02:23 <bourbaki> the idea if that you might be able to rewrite the function in a way that its faster
12:02:45 <edwardk> iirc i was applying something with like log^3 'force' to get better explanatory structured trees and it was touchy to get right without causing degeneration.
12:02:51 <bourbaki> so i wouldnt go to the programs space totally blind
12:03:15 <edwardk> bourbaki: ok, so you have an existing function and you want to select for a comparable function with better performance?
12:03:34 <bourbaki> yep eg a for loop
12:03:41 <edwardk> or an exact function with better performance?
12:03:53 <bourbaki> right
12:04:29 <bourbaki> so lets say i start out with a graph i can apply certain rules that will geneate the same function just in another way
12:04:36 <edwardk> GP techniques will be 'pretty good' at the comparable, but generally suck at 'exact' problems. not sure you have enough different transformations you can apply to have good 'stock'
12:04:53 <bourbaki> like associativity or so
12:04:59 <edwardk> *nods*
12:05:20 <bourbaki> and maybe you are lucky and find some good heuristic in that search space
12:05:25 <edwardk> you have a function and a term rewriting system of valid transformations and you are hunting through 'rewrite' space for something that performs better
12:05:42 <bourbaki> right
12:05:51 <cpoucet> :t tmapM
12:05:55 <lambdabot> Not in scope: `tmapM'
12:06:44 <edwardk> sounds tricky if only because 'performance' generally only occurs is in context. is the cache primed? how does it interleave with other code, how is the data distributed, etc..
12:07:13 <edwardk> hard to find an objective measure that really 'optimizes', its kind of a classic compiler problem =)
12:07:28 <bourbaki> well one optimization would already be not to pass the object through two functions but one
12:07:50 <bourbaki> so i would not have to stack any data for the function call
12:09:53 <edwardk> *nods*
12:10:47 <edwardk> you are playing with a small enough problem domain with total functions which have a restricted type of domain/range, etc, so you can probably measure rather effectively, so don't let me rain on your parade ;)
12:11:07 <bourbaki> heh
12:11:36 <bourbaki> but since you have had a loot at something similar already, do you consider this interesting for that kind of purpose?
12:11:39 <quicksilver> @seen KatieHuber
12:11:40 <lambdabot> I haven't seen KatieHuber.
12:12:10 <edwardk> To be quite honest, my main take away from GP/GA was to use a different tool from my toolchest whenever I could ;)
12:12:22 <bourbaki> heh ok
12:12:53 <bourbaki> but i guess i can abuse a GP lib to get into my direction
12:13:22 <geezusfreeek> i've always liked GP because it's fun, but i have seen little practical use for it yet
12:14:10 <edwardk> geezusfreeek: yeah. most of the time i've used a GA i should have used simulated annealing over a slightly rephrased problem or something. and GP tends to derive blackboxes with weird failure cases.
12:14:48 <edwardk> you get something that does the right thing 99% of the time and then fires the booster rockets for your spaceship straight into the sun when no one is looking ;)
12:14:59 <geezusfreeek> i really have a strong but passive interest in artificial life and genetic programming and pretty much everything that is related… but it's completely useless to me :(
12:15:00 <bourbaki> heh
12:16:37 <edwardk> bourbaki: if you are looking for libs, iirc ECJ is fairly straightforward to use in Java, and lilgp is fine for small models in straight up C.
12:16:50 <geezusfreeek> hmm… then again… making a RTS game where the player manipulates the world such that his warriors will evolve in certain ways before sending them into battle might be a neat idea
12:16:52 <bourbaki> c# would be nice
12:17:11 <bourbaki> geezusfreeek: do you know mindrover?
12:17:15 <geezusfreeek> no
12:17:21 <bourbaki> sec
12:17:42 <bourbaki> http://www.cognitoy.com/minimindrover/
12:17:43 <lambdabot> Title: CogniToy -- MindRover
12:18:06 <geezusfreeek> wow i wish those images would load…
12:18:25 <tromp> @src groupBy
12:18:26 <lambdabot> groupBy _  []       =  []
12:18:26 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
12:18:26 <lambdabot>     where (ys,zs) = span (eq x) xs
12:18:31 <bourbaki> try this http://www.mindrover.com/
12:18:31 <lambdabot> Title: CogniToy -- MindRover
12:18:45 <cedricshock> Can thunks have side effects? Can you have an infinite data stucture on one computer and a piece of pure code on another computer that explores it inside a bind in the IO monad?
12:18:47 <edwardk> geezus: 'interactive' ai evolution always struck me as a bit crazy, the problem is training time. you don't have enough time to really reinforce any behaviors you want, at least not using traditional GP/GA training techniques. i don't want to wait for 30 generations of thousands of warriors to die stupidly while i manually punish and reward them ;)
12:18:50 <geezusfreeek> yeah i foudn that
12:19:09 <tromp> @src span
12:19:10 <lambdabot> Source not found.
12:19:27 <tromp> @src Data.List.span
12:19:28 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
12:19:41 <geezusfreeek> hmm, yeah, i have wanted something sort of like this for a while now
12:20:05 <geezusfreeek> but _breeding_ your warriors is something i just came up with a few minutes ago
12:20:22 <geezusfreeek> i will have to look further into mindrover later
12:20:33 * geezusfreeek has a final coming up to study for
12:20:42 <bourbaki> geezusfreeek: do you know http://aigamedev.com/ ?
12:20:42 <lambdabot> Title: Game AI for Developers &#8212; AiGameDev.com
12:21:05 <geezusfreeek> nope, but now i do :)
12:21:20 <bourbaki> you might get some info on your stuff there
12:21:58 <Saizan> cedricshock: no implementation let's you do that
12:22:26 <cedricshock> Saizan: I kind of suspect it's impossible due to IO being a real monad.
12:22:37 <bourbaki> well im off to bed thanks for the help
12:23:49 <cedricshock> But not really, because it's just a huge ugly side-effect that happens once. I'm not sure what it violates but my gut feels like it violates something.
12:23:56 <Saizan> cedricshock: you can imagine a protocol to do remote forcing, a little like rpc
12:24:50 <pjd_> cedricshock: you can do it in practice with unsafe*IO, of course
12:25:14 <cedricshock> I'm not worried about the protocol. I'm worried about whether or not the behaviour is possible.
12:26:36 <bos31337> yes, it's possible.
12:26:41 <Saizan> well once you've declared a pure value which threads forces it doesn't matter, i think this can extend to processes
12:26:56 <geezusfreeek> edwardk: oops, i missed what you said earlier… i of course haven't thought through this idea very far yet ;) while i think the most interesting games would also be the longest, the game times could be kept smaller by cheating with the genetic algorithms by weighting a bit toward certain kinds of ideal behaviors or even preprogramming certain complex things, like pathfinding
12:26:59 <bos31337> now, does it make sense? not really.
12:27:32 <edwardk> geezusfreeek: the only real practical way to do it on a human timescale is to just tune some metaparameters rather than really 'evolve' anything new
12:27:40 <geezusfreeek> right
12:27:53 <edwardk> thats fairly standard, adaptive bot stuff
12:28:08 <geezusfreeek> perhaps
12:28:11 <cedricshock> It makes sense to me. I don't like repeating myself, even when it's someone else.
12:28:16 <geezusfreeek> i will have to think about it more
12:30:08 <geezusfreeek> or maybe the overall structures of the algorithms could be written already with the genetic algorithm simply filling in some blanks
12:30:30 <geezusfreeek> that could still lead to interesting/unpredictable behavior while still guiding it with an invisible hand
12:30:31 <cedricshock> But I'm pretty sure it's not possible with the regular IO monad.
12:30:57 <geezusfreeek> kind of sound gimmicky now though, i admit
12:32:13 <kolmodin> mmm.. fixing a bug in binary
12:32:21 <edwardk> geezusfreeek: i figured i'd let you come to that conclusion on your own ;)
12:32:35 <geezusfreeek> i still think a median could be met somewhere
12:32:53 <geezusfreeek> it would be a boring trivial game to most gamers, but i think it could be interesting to some
12:33:26 <cedricshock> What's the model of the game (from the ai's point of view)?
12:33:42 <edwardk> its the 'boring trivial' part i'd be eager to avoid ;)
12:35:50 <cedricshock> That will, in a large part, determine what the ai needs to be like. If the model is something like: every soldier knows about the positions of everything in line of sight and can take the following .... actions with large real numbered parameters your ai is never going to get fun.
12:36:41 <cedricshock> If the model is much more local (a harder problem to solve) the ai might get fun very quickly.
12:37:03 <geezusfreeek> cedricshock: i would think it would be these goals: 1) survive, 2) do what the player wants you to do. sensory things might be provided on a cost basis of some sort, but they would ideally be kept to a minimum for simplicity
12:37:58 <spelling2> is it good for your business and financial security if others are jealous of you? would you get into jail or in trouble if people are jealous of you? who people are more jealous of blacks or brown? thank you
12:38:15 <geezusfreeek> might be cool to allow the player to rig up some templating structure for the ai himself before starting the breeding process
12:38:28 <geezusfreeek> in a simplified form, of course
12:38:28 <cedricshock> So you want to evolve the model of the soldiers as well as their intelligence.
12:38:30 <mauke> any ops here? spelling2 needs a kicking
12:38:34 <geezusfreeek> well
12:38:41 <Deewiant> @where op
12:38:41 <geezusfreeek> i don't know
12:38:42 <lambdabot> I know nothing about op.
12:39:09 <Deewiant> @where ops
12:39:10 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
12:39:26 <dcoutts> ah, too slow
12:39:29 <cedricshock> And there's the huge cheating possibility of using engineered pieces instead of bred ones.
12:40:15 <edwardk> its like someone lit the ops signal up in the sky, and no one came ;)
12:40:16 <dcoutts> edwardk: I did!
12:40:26 <edwardk> dcoutts: was teasing =)
12:40:31 <dcoutts> :-)
12:40:41 <cedricshock> geezusfreek: The "costs" to the critters are almost the hard part.
12:41:35 <geezusfreeek> cedricshock: right. it would be all about finding the right balance between direct manipulation and algorithmic discovery.
12:42:14 <cedricshock> geezusfreeek: The computer world could easily have an amount of true abundance that leads to: who makes the biggest sword first?
12:42:43 <cedricshock> The algorithms themselves need a cost too.
12:42:48 <geezusfreeek> right
12:43:28 <geezusfreeek> well it is time for me to go to my final
12:43:40 <cedricshock> geezusfreeek: Have fun. Think about ants some.
12:47:18 <kolmodin> dons: ping
13:10:22 <lispy> I probably shouldn't be listed as an op.  I don't actually know how to be an op.  I have to lookup the commands everytime I want to use them.
13:27:05 <mapreduce> lispy: I prefer that to trigger-happy. :)
13:27:11 <bugQ> ?pl flip (.)
13:27:11 <lambdabot> flip (.)
13:27:15 <bugQ> hm.
13:27:53 * lispy tries to remember how to ban mapreduce for his insolence ;)
13:28:11 <lispy> ?+b mapreduce
13:28:11 <lambdabot> Maybe you meant: . ? @ bf ft id pl rc v wn
13:28:23 <lispy> ?ft --what is this?
13:28:27 <lambdabot>  FTshell (version 0.2) - Automatic generation of free theorems
13:28:27 <lambdabot>  Press `:help' for help or `:quit' to quit.
13:28:27 <lambdabot>  Loading `/home/cgibbard/local/share/ftshell-0.2/ftshell-0.2/declarations.hs' ... found 187 declarations.
13:28:27 <lambdabot>  > > >
13:28:39 <lispy> Hrm
13:28:41 <mauke> lispy: hey, let me do it! :-)
13:28:43 <lispy> ?ft map
13:28:44 <lambdabot>  FTshell (version 0.2) - Automatic generation of free theorems
13:28:44 <lambdabot>  Press `:help' for help or `:quit' to quit.
13:28:44 <lambdabot>  Loading `/home/cgibbard/local/share/ftshell-0.2/ftshell-0.2/declarations.hs' ... found 187 declarations.
13:28:44 <lambdabot>  > >
13:28:57 <lispy> Cale: is  it supposed to be that broken?
13:29:11 <mauke> @free map
13:29:12 <lambdabot> Expected variable or '.'
13:29:19 <sjanssen> lispy: I probably broke it
13:29:24 <sjanssen> lispy: patches accepted :P
13:29:29 <lispy> sjanssen: heh
13:29:54 <lispy> sjanssen: yeah, I stopped using lambdabot around the time the config system was scrapped and then broken.  I have yet to learn how to hack it since.
13:30:46 <sjanssen> lispy: current lambdabot is pretty easy to build, if you have cabal install
13:30:50 <pjd_> bugQ: there's (>>>) in Control.Arrow
13:31:10 <bugQ> ?src (>>>)
13:31:11 <lambdabot> Source not found. Just what do you think you're doing Dave?
13:31:17 <bugQ> ?src Control.Arrow.(>>>)
13:31:18 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
13:32:03 <lispy> sjanssen: well, I was running lambdabot as a webservice.  And I couldn't figure out how to start lambdabot up in webservice mode...I'm 80% sure the person that broke the config system didn't know about the webservice mode
13:32:06 <Cale> lispy: uh, no
13:33:00 <bugQ> :t (>>>)
13:33:02 <Cale> (It's not supposed to be broken)
13:33:02 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
13:33:25 <bugQ> ah.
13:35:58 <Cale> hmm, who was it that had the patch to split off the ft stuff and use ftshell?
13:38:20 <lispy> Cale: sjanssen was just taking blame
13:38:39 <Cale> oh
13:38:50 <Cale> Heh, serves me right for not reading carefully :)
13:39:27 <Cale> Yeah, I wonder if ftshell has a mode in which it acts appropriately for lambdabot.
13:39:57 <lispy> ftshell --no-banner
13:40:09 <lispy> ftshell --cooperate-with-da-bot
13:42:55 <mauke> ftshell --bruce-banner
14:01:48 <bogomipz> is (reverse . tail . reverse) the most efficient way to drop last element?
14:02:21 <dons> nope.
14:02:26 <yav> you can use init
14:02:27 <dons> > init [1..100]
14:02:28 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:02:41 <dons> ?src init
14:02:42 <lambdabot> init [x]    = []
14:02:42 <lambdabot> init (x:xs) = x : init xs
14:02:42 <lambdabot> init []     = undefined
14:03:16 <bogomipz> ah, right
14:03:20 <bogomipz> thanks dons
14:15:41 <cpoucet> @pl \f (a,b) -> return (,) `ap` f a `ap` f b
14:15:42 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . liftM2 (,)) .))
14:15:46 <cpoucet> @pl \(a,b) -> return (,) `ap` f a `ap` f b
14:15:47 <lambdabot> uncurry ((. f) . ap . ((,) `fmap`) . f)
14:19:10 <cpoucet> :t <$>
14:19:11 <lambdabot> parse error on input `<$>'
14:19:17 <cpoucet> :t (<$>)
14:19:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:27:28 <agcorona> hi, I´m desperated with hs-plugins: it does not run in Windows. It does´nt compile with ghc 6.8.2. Please, we need a decent runtime eval for Haskkell
14:28:13 <Heffalump> desperate enough to pay? You could ask http://www.well-typed.com for help.
14:28:14 <lambdabot> Title: Well-Typed - The Haskell Consultants
14:28:24 <Lemmih> agcorona: What do you need it for?
14:28:47 <agcorona> I started a project with hs-plugins at the hearth and it does not work very well
14:29:14 <agcorona> fine advertising ;)
14:29:19 <Heffalump> where is the hs-plugins repo now?
14:29:31 <Heffalump> dons' webpage seems a bit out of date
14:29:45 <agcorona> I need it for runtime evaluating configuration files whrh functions in them
14:29:51 <Lemmih> Heffalump: The hackage version works with 6.8.2
14:29:58 <agcorona> just the functionality hs-plugins was made for
14:30:09 <dons> agcorona: grab the version on hackage
14:30:22 <Heffalump> dons: is it expected to work on windows too?
14:30:33 <dons> i think its not working on windows.
14:30:40 <dons> people are using ghc-api now days
14:30:57 <Lemmih> Really? Who?
14:30:58 <agcorona> Lemmih: I just tried and it provokes a bug on 6.8.2 : the impossib happened.... bla bla bla
14:31:03 <dons> Lemmih: Yi?
14:31:09 <Heffalump> is hs-plugins built on top of ghc-api?
14:31:17 <Lemmih> dons: Yi is a special case.
14:31:36 <dons> it is.
14:31:44 <dons> there's no hs-plugins on ghc-api yet, afaik
14:31:45 <Lemmih> dons: Yi uses ghc-api for more or less the same reasons hIDE did, no?
14:31:52 <dons> its the only way this will ever be maitnainable though
14:32:01 <dons> Lemmih: yeah, + interactive eval
14:32:03 <Heffalump> yeah, I was thinking it should be ported to that
14:32:15 <dons> the ghc plugins project may well produce this result
14:32:33 <Heffalump> as a byproduct?
14:32:33 <Lemmih> The current hs-plugins uses the ghc-api for loading hi files, afaik.
14:33:11 <agcorona> I have web server extensions that are loaded . and these loads have evals inside  for the configuration files. it does not work.
14:34:00 <Heffalump> agcorona: have you got it working on windows with any GHC version?
14:34:21 <agcorona> the ghc api is heavy. I have some examples but hs-plugins had a more reasonable interface, just the eval of lisp javascript etc
14:34:47 <dons> yeah, ideally you'd use the ghc-api eval interface to bytecode
14:34:56 <dons> its cheaper and faster than hs-plugins
14:34:58 <agcorona> hettalump: yes: 6.4.2 none after works
14:35:03 <dons> and reuses the compilers eval
14:35:40 <agcorona> dons ghc api has something like this? I have never read that
14:37:01 <Lemmih> agcorona: You most likely want to avoid runtime eval if you can.
14:37:52 <agcorona> do you mean want or must?
14:38:13 <agcorona> I _need_ runtime eval
14:38:18 <Lemmih> agcorona: Why?
14:38:46 <agcorona> because My configuration files are updated by user
14:39:05 <agcorona> configuration files incude little functions, so no way otherwise
14:39:44 <quicksilver> dons: in principle it would be nice ot have a compiler-agnostic interface to this stuff.
14:39:55 <quicksilver> dons: in practice I guess GHC is the only candidate for a while yet.
14:39:56 <mauke> agcorona: have you heard about this xmonad thing?
14:41:12 <MyCatVerbs> Gwuh. How many vertices does a hypercube have, please?
14:41:27 <Lemmih> Does xmonad do dynamic loading?
14:41:40 <mauke> not really
14:41:42 <agcorona> quicksilver: Yes but I prefer haskell rather that a limited DSL
14:41:46 <Zao> MyCatVerbs: I'd make a guess at 16.
14:41:49 <Heffalump> no, it just re-execs a newly compiled version
14:41:52 <MyCatVerbs> Lemmih: if you change xmonad.hs? Nah, it recompiles itself on the fly then execs the new executable.
14:42:01 <MyCatVerbs> Zao: danke.
14:42:13 <Lemmih> mauke: Then why is xmonad relevant?
14:42:13 <agcorona> mauke: I don´t need a window resizer
14:42:16 <Zao> MyCatVerbs: Imagine two cubes, connected at corresponding vertices.
14:42:17 <Heffalump> MyCatVerbs: 2^n surely?
14:42:31 <MyCatVerbs> Heffalump: I don't know for sure, that's why I'm asking.
14:42:34 * Zao interpreted hypercube as 4D.
14:42:36 <Heffalump> hypercube doesn't just mean 4D, does it?
14:42:40 <MyCatVerbs> Lemmih: the reason it works as well as it does is that they're really careful to preserve state when restarting. ^^
14:42:47 <Lemmih> agcorona: Have you tried testing hs-plugins in a simplified environment?
14:42:57 <mauke> Lemmih: because it shows that you can have user-defined functions in config files without dynamic loading
14:43:10 <agcorona> Lemmih:  yes, i did
14:43:11 <quicksilver> MyCatVerbs: a hypercube is two cubes joined together at every corresponding vertex.
14:43:15 <quicksilver> MyCatVerbs: so, 16, yes.
14:43:20 <MyCatVerbs> Heffalump: often it does. Strictly, I ought to be asking about a 4-cube, but oh well.
14:43:23 <MyCatVerbs> quicksilver: thanks. ^_^
14:43:24 <Zao> [4,8,16] seems to map well at map (2^) [2..4]
14:43:32 <geezusfreeek> i hypercube is any n-dimensional cube
14:44:19 <Heffalump> it seems completely obvious to me that an n-dimensional hypercube has 2^n vertices
14:44:19 <geezusfreeek> err… any n-dimensional analogue of a cube, i mean
14:44:25 <Heffalump> So obvious that I'm not sure how to explain it :-)
14:44:36 <MyCatVerbs> Heffalump: fair enough.
14:44:41 <agcorona> mauke: but my cofiguration files are modified and reloaded at runtime
14:44:41 <Heffalump> apart from that a (n+1)-D one is 2 n-D ones stuck together
14:44:43 <quicksilver> I don't think you do explain it. I think it's by definition.
14:44:50 <geezusfreeek> Heffalump: that would be a unit hypercube
14:44:51 <MyCatVerbs> geezusfreeek: well yeah, but if unspecified people conventionally assume four.
14:44:52 <mauke> agcorona: just like xmonad
14:45:01 <Heffalump> geezusfreeek: a what?
14:45:08 <agcorona> come on... We need a runtime eval for haskell with no compromises
14:45:14 <geezusfreeek> oops
14:45:16 <Heffalump> the edge lengths are irrelevant to the vertex count, if that's what you mean by unit..
14:45:22 <Heffalump> agcorona: yes, we do.
14:45:29 <geezusfreeek> my mind was moving somewhere else i guess
14:45:33 <geezusfreeek> i need to take a break from maths
14:45:34 <quicksilver> agcorona: and we have three, in a manner of speaking
14:45:38 <Heffalump> however no-one has written one that works perfectly yet
14:45:41 <MyCatVerbs> agcorona: can't be done. No matter what, you *will* have to make compromises.
14:45:43 <quicksilver> although runplugs isn't really different from ghc-api
14:45:54 <geezusfreeek> Heffalump: ignore my irrelevant mention of unit hypercubes
14:46:16 <Heffalump> I had the impression that you were desperate on behalf of a company from your original statement, which was why I suggested paying for what you need.
14:46:18 <agcorona> maukee: the added problem is that i have loaded modules that use cofiguration files loaded with eval´s and this does nor work
14:46:49 <MyCatVerbs> agcorona: for instance, do you want to run the type checker, or do you want to do everything dynamically? On the one paw, you have a heavy startup time penalty, on the other paw the performance degrades down closer to the speed of something like Perl.
14:47:15 <Heffalump> so hs-plugins worked with windows on ghc 6.4.2, and works on 6.8.2 on non-windows, but doesn't work with windows on 6.8.2? That seems a bit odd.
14:47:23 <MyCatVerbs> agcorona: "no compromises" is uniformly impossible. :P
14:48:55 <agcorona> No compromises for me means "a hs-plugins that works in any platform and permits evals inside loads". Just that. no new pardigm is necessary
14:49:24 <MyCatVerbs> agcorona: ah, right. Fair 'nuff.
14:49:34 <quicksilver> hs-plugins has to be rather closely tied to the issues of linking and executing, since it works by compilation.
14:49:47 <Heffalump> it could embed hugs
14:49:54 <mauke> heh
14:49:55 <quicksilver> therefore it doesn't work on windows because no one cares about windows
14:50:00 <quicksilver> of course you could choose to fix that.
14:50:09 <quicksilver> Heffalump: it could, but then it would be something different ;)
14:50:23 <Lemmih> Are we sure it doesn't work on Windows?
14:50:24 <quicksilver> Heffalump: I meant "under its current design..."
14:50:27 <mauke> ghc -> ffi -> hugs
14:50:29 <agcorona> quicksilver: that is a dangerous mistake in the side of haskell advocates
14:50:39 <quicksilver> haskell advocates are not a single body
14:50:46 <quicksilver> I have no access to windows, and I will not buy a copy
14:50:50 <quicksilver> therefore, I am not going to help.
14:50:58 <quicksilver> it may happen that other people will choose to work on it
14:51:04 <quicksilver> but you don't force volunteers
14:51:15 <quicksilver> it may happen that galois (say) discovers a business need to get it work on windows
14:51:18 <quicksilver> or it may not.
14:51:35 <quicksilver> it may happen that you are the person who makes it work
14:51:39 <quicksilver> if you care enough, and have time.
14:51:40 <agcorona> millions of people are looking for a language such is haskell, and the use windws. No good implementation in windows means no relevance for haskell
14:51:51 <quicksilver> there is an excellent haskell implementation for windows
14:51:55 <Cale> agcorona: There's GHC
14:51:56 <quicksilver> indeed, there are multiple such.
14:51:59 <siti> just not everything works :p
14:52:04 <quicksilver> eval is not part of haskell, as a language.
14:52:10 <quicksilver> hs plugins is a clever hack, granted
14:52:15 <agcorona> it should be
14:52:20 <quicksilver> but the vast majority of programs neither need, nor benefit from, eval.
14:52:43 <mauke> agcorona: lack of eval hasn't troubled C or C++
14:52:47 <Heffalump> I can't see it being standardised any time soon.
14:52:56 <Cale> Oh, if you *really* need eval, I'm pretty sure the GHC-API works on windows.
14:53:13 <quicksilver> or java.
14:53:14 <Cale> Really hs-plugins ought to be rewritten entirely in terms of the GHC API
14:53:17 <Heffalump> static typing and dynamic compilation are not easy bedfellows
14:53:19 <agcorona> they does not benefit nor need because it is not used in industrial programming
14:53:28 <MyCatVerbs> agcorona: IMO, people who need *eval* should be using Lisp anyway.
14:53:30 <Lemmih> Cale: It pretty much is, afaik.
14:53:41 <Cale> Lemmih: One part is at least.
14:53:50 <Cale> Lemmih: The hi parser is now.
14:54:09 <agcorona> hettalump: dymanyc typin must be the nest big extension of haskell, just like dylan
14:54:10 <Lemmih> Cale: That's pretty much the only part that needs the ghc-api.
14:54:10 <Heffalump> agcorona: it is used in industrial programming
14:54:37 <Cale> agcorona: We have dynamic typing. It's just awkward to use.
14:54:53 <Cale> agcorona: and the actual use cases are tiny.
14:55:13 <Cale> Static typing is great and people should use it :)
14:55:18 <qebab> I like the way haskell does typing
14:55:24 <agcorona> 'MyCatVerbs: I used Lisp, but i prefer haskell. I want it to be the best language. for that matter we need dynamic typing to permit eval , reflection etc
14:55:32 <qebab> beats for instance Java by miles
14:55:35 <quicksilver> reflection is a disaster.
14:55:44 <quicksilver> it encourages terrible programming practices.
14:55:46 <Cale> agcorona: You don't necessarily need dynamic typing for eval.
14:55:48 <mauke> we already have some of that in the form of Typeable and Dynamic
14:55:49 <MyCatVerbs> Cale: it's not the least bit inconvenient in languages that're designed to make it convenient. In Haskell, it's a pain in the butt to use. :P
14:56:00 <Cale> agcorona: You can have a typesafe eval which results in a Maybe value.
14:56:01 <pizza_> quicksilver: agreed
14:56:09 <qebab> or C, or any language based on C for that matter
14:56:13 <Cale> MyCatVerbs: What?
14:56:16 <agcorona> static typing is a must. dynamic typing is just an extension necessary for new types of industrial programming. programming is more and more dynamic
14:56:18 <Heffalump> Cale: one place Typeable is needed is to implement heterogenous heaps without using ST
14:56:19 <geezusfreeek> huh, this SuspendT and CoroutineT stuff of late is interesting
14:56:25 <quicksilver> agcorona: anyhow, you aroused some hyperbole because you approached the question in a provocative way.
14:56:35 <Cale> Heffalump: sure.
14:56:35 <MyCatVerbs> Cale: Data.Dynamic is a pain in the butt. Dynamic typing in any given Lisp is trivially easy to use. Fun, too.
14:56:49 <Cale> MyCatVerbs: Oh -- yes, of course.
14:56:51 <quicksilver> agcorona: if you actually want hs-plugins to work on windows, you should tell people what works and what doesn't work.
14:57:04 <Cale> MyCatVerbs: Though I'd argue it ends up being a pain in the butt anyway.
14:57:06 <quicksilver> agcorona: it used to work in previous versions, I daresay it's not particularly hard to make it work again.
14:57:12 <qebab> Lisps are trivially easy to use altogether :)
14:57:27 <qebab> the ones I've encountered at least
14:57:31 <Cale> MyCatVerbs: In fact, it made using lisp in my cognitive modelling course really painful. :)
14:57:41 <MyCatVerbs> Cale: how so?
14:57:41 <quicksilver> agcorona: but nobody here is paid to fix it. Nonetheless, people here are pretty helpful. And if no one here has the expertise, you should post the detailed problem to the -cafe.
14:57:56 <agcorona> quicksilver: it does not work because since ghc 6.4.2 deliberately has not been supported in windows. I suppose because the lack of resurces
14:58:00 <Cale> MyCatVerbs: Spending hours tracking down bugs only to realise that they would have been type errors.
14:58:14 <MyCatVerbs> Cale: I can't see how dynamic typing in Lisp would make things significantly painful provided you have good API documentation.
14:58:38 <agcorona> But many important applications depend on hs-plugins
14:58:40 <Cale> MyCatVerbs: It makes debugging at least 10 times more painful.
14:59:18 <quicksilver> agcorona: then, if you're interested in making it work you become part of the solution, by investigating and solving the problem together with the people who know the code.
14:59:19 <qebab> Cale: you are supposed to get it right the first time!! :p
14:59:20 <MyCatVerbs> Cale: admittedly there are places, particularly with exceedingly-complex combinators, where static typing comes in *really* handy to help you make sure you've used it correctly.
14:59:26 <mauke> agcorona: for example?
14:59:39 <Cale> Especially those cases where some data structure ends up having some value of the wrong type in it, and you have to go and look at every single piece of code which built that structure up in order to tell where things went wrong.
14:59:53 <MyCatVerbs> Cale: eek.
15:00:00 <MyCatVerbs> Cale: yuck, even.
15:00:17 <waern> http://hpaste.org/7176#a1 <- is this a bug in the derive package?
15:00:52 <MyCatVerbs> Cale: conversely, though, strongly-typed systems often run into things they can't model without extending their type systems. Lexically scoped type variables, etc.
15:01:52 <Cale> Well, if the static type system can't handle something, you can usually just resort to a more dynamic approach, especially as in most cases, your program can't really handle *any* type of thing, but a restricted set of expected things.
15:02:32 <agcorona> quicksilver: neither me neither other people have time to fix everythig. I Only want to say that a working hs-plugins is important
15:02:36 <Cale> I'll admit there are cases like modelling a heap of arbitrarily-typed objects where you need some sort of runtime reflection of types and dynamic typing, but they're pretty rare.
15:02:48 <Saizan> waern: what if not? use -ddump-splices to see the generated code and check
15:03:10 <agcorona> mauke: for example, lambdabot
15:03:20 <Heffalump> agcorona: I think if it was more important it would have received more love already :-)
15:03:25 <mauke> lambdabot could be done without dynamic eval
15:03:37 <Cale> agcorona: Which hs-plugins did you try to build on windows, and what error did you get?
15:03:51 <MyCatVerbs> Cale: e.g. newtype Talking a = forall b. Talking ((b -> a),Chan b) -- and then some function concentrate :: [Talking a] -> IO Chan a -- can't really be written nicely without lexically scoped type variables. (Sorry if I put the forall b. in the wrong place there, it's been a while).
15:04:02 <agcorona> Cale: ask Dons. He knows it very very well
15:04:04 <waern> Saizan: I've done that, but I didn't want to debug that code since it's a bit complex
15:04:21 <agcorona> The problem with windows, I mean
15:04:28 <Cale> agcorona: I was the last person to work on hs-plugins. I replaced a big chunk of it with calls into the GHC API.
15:04:49 <agcorona> when?
15:05:07 <Cale> A couple months back.
15:05:25 <Cale> Does your source directory have a subdirectory named "Language" anywhere in it?
15:05:51 <Cale> If so, then you're certainly not using my version :)
15:06:14 <TomMD> @users
15:06:15 <lambdabot> Maximum users seen in #haskell: 460, currently: 444 (96.5%), active: 23 (5.2%)
15:06:18 <agcorona> cale: no
15:06:23 <Cale> agcorona: Okay.
15:06:44 <Cale> agcorona: I'm interested in knowing what the error is...
15:06:59 <agcorona> not it the top level. yes in the second
15:07:12 <Cale> ah, what's the path look like?
15:07:44 <Cale> There's a Language/Hi/ tree?
15:07:52 <Cale> That's not my version then.
15:08:05 <agcorona> src/language
15:08:30 <agcorona> src/language/Hi
15:08:34 <Cale> yeah
15:08:36 <agcorona> yes
15:08:39 <agcorona> ok
15:08:43 <Cale> So you have the old version
15:08:57 <agcorona> in hackage can I download the new version?
15:09:07 <Cale> yep
15:09:21 <agcorona> I´ll do right not. thanks
15:09:22 <Cale> Give it a shot. I haven't tried it on windows.
15:09:37 <Cale> But I removed the part which is most likely to create problems.
15:09:45 <agcorona> right now i mean
15:10:06 <MyCatVerbs> agcorona: heh. For an instance, you accidentally sounded like a Wayne's World character.
15:10:14 <MyCatVerbs> s/instance/instant/, oops.
15:10:41 <agcorona> MyCatVerbs: what is that?
15:11:26 <agcorona> don´r care, wikipedia can give me an answer
15:11:27 <Heffalump> Cale: is there a canonical darcs repo for it, btw?
15:11:53 <MyCatVerbs> class Wayne w where \n makeFun :: w -> Garth -> IO Laughter \n rhapsody :: (w,[Dude]) -> Casette -> IO Rock
15:12:11 <MyCatVerbs> agcorona: Famous film. Terrible but fun. ^^
15:12:20 <Cale> Heffalump: There... was, but I can't find it now...
15:12:23 <Cale> @where darcs
15:12:23 <lambdabot> http://darcs.net/
15:12:29 <Cale> @where hs-plugins
15:12:30 <lambdabot> http://code.haskell.org/~dons/code/hs-plugins
15:12:37 <Cale> aha, that's it
15:13:04 <Heffalump> ah, it needs a project
15:13:34 <agcorona> MyCatVerbs: I will look for it.
15:14:07 <MyCatVerbs> agcorona: it was a bit topical. You might not find it the least bit funny unless you happen to be an American teenager in the 1980s. Ah, well.
15:20:47 <mofmo1> is there any way, with just the standard haskell libraries to get keyboard usable for games?
15:21:30 <mofmo1> i have a hack working with hWaitForInput, but if you hold down the key it "saves" the extra characters and so it becomes unresponsive for some time proportional to the extra characters given by the key held down
15:21:53 <mofmo1> I was thinking of flushing stdin if there was more than one character but of course, you can't flush stdin
15:22:27 <agcorona> MyCatVerbs: American teenagers in the 1980 is now universal I guess
15:22:38 <MyCatVerbs> agcorona: heh. ^_^
15:23:57 <mofmo1> anyone?
15:24:20 <agcorona> I heard years ago of countrymen form Morrocco watching Dinasty everyday
15:26:00 <MyCatVerbs> agcorona: :)
15:26:22 <MyCatVerbs> mofmo1: nope. If you really need to write games, use something designed for writing games.
15:27:09 <MyCatVerbs> mofmo1: if you're writing something that runs in a terminal, perhaps look into curses? Other than that, I think everyone uses GLUT.
15:27:59 <mofmo1> curses is terrible in haskell
15:28:55 <agcorona> I have a  collision in STM transactions apparently because the first is executed lazily. How can I make a computation strict?
15:29:45 <Zao> agcorona: $! and ! on pattern matches.
15:29:48 <agcorona> I am not sure if    f $! g    is strict when g return a list
15:29:49 <MyCatVerbs> mofmo1: no clue, then. Try haskell-cafe, you're much more likely to get a good answer there, I'll wager.
15:29:59 <Zao> seq abuse may help.
15:30:05 <Zao> Or just use the strict chans.
15:31:28 <agcorona> how  a general strict :: a -> a   could be defined. I read a mess of information, much of that not applicable to latest versiones of ghc, so I´m a bit lost
15:32:24 <mofmo1> hmm, even if i set it to NoBuffering it still apparently reads in more data than it should
15:32:24 <mux> @where xhtml
15:32:25 <lambdabot> http://www.cs.chalmers.se/~bringert/darcs/haskell-xhtml
15:33:34 <byorgey> ah, I love TEDD (Type-Error-Driven Development)  =)
15:36:08 <Heffalump> agcorona: id is strict
15:36:17 <mux> yes, it feels better than SDD (segfault driven development) :-)
15:36:27 <Heffalump> but it probably doesn't do what you actually want; for that you need seq and its cousins
15:36:52 <agcorona> id by default? greath
15:37:14 <Heffalump> agcorona: yes, but as I said that probably doesn't help you
15:37:21 <Heffalump> id is strict because id undefined = undefined
15:37:40 <byorgey> mux: hehe, indeed =)
15:38:28 <Heffalump> but that's not useful, because it gives you no control over evaluation order; id only gets called when its result is wanted, so its argument only gets called at that point.
15:38:41 <Heffalump> The point of seq is that it forces an ordering on the evaluation of two different things
15:38:53 <Heffalump> so you can say "I want this to be evaluated before the real result of my code is evaluated"
15:40:18 <Japsu> @oeis 1, 11, 21, 1211, 3112, 132112
15:40:18 <lambdabot> Say what you see in previous term, reporting total number for each digit enco...
15:40:18 <lambdabot> [1,11,21,1211,3112,132112,311322,232122,421311,14123113,41141223,24312213,321...
15:40:50 <Japsu> @oeis 1,2,2,4,6,6,8,10
15:40:50 <lambdabot> Length of n-th term in Look and Say sequence A005150.
15:40:50 <lambdabot> [1,2,2,4,6,6,8,10,14,20,26,34,46,62,78,102,134,176,226,302,408,528,678,904,11...
15:41:40 <agcorona> Heffalump: What about DeepSeq? i read that this module does a deep evaluation. But I thing it is not the way to do it in the lates versions of GHC
15:42:22 <Heffalump> agcorona: it does, but you still need something in the style of seq, with two arguments, to make it usable. I think in latest GHC the rnf combinator is the way to do it.
15:43:07 <agcorona> where is this combinator defined?
15:43:44 <Heffalump> Control.Parallel.Strategies IIRC
16:00:52 <byorgey> are there any packages on hackage which define a whole bunch of common color names in terms of RGB values?
16:03:37 <Arnar_> @pl \x -> (1,x)
16:03:37 <lambdabot> (,) 1
16:03:48 <Arnar_> :t (,)
16:03:51 <lambdabot> forall a b. a -> b -> (a, b)
16:04:03 <mauke> :t uncurry (,)
16:04:04 <lambdabot> forall a b. (a, b) -> (a, b)
16:10:26 <ziman> :t curry id
16:10:28 <lambdabot> forall a b. a -> b -> (a, b)
16:10:47 <ziman> :t uncurry.curry $ id
16:10:48 <lambdabot> forall a b. (a, b) -> (a, b)
16:11:34 <Arnar_> hrm...
16:12:46 <Arnar_> how can I do this -> http://hpaste.org/7177
16:12:48 <Arnar_> ?
16:13:15 <Arnar_> confused again about let-syntax
16:13:26 <Arnar_> inside a do-block
16:13:57 <twanvl> just drop the 'in'
16:14:17 <Arnar_> and align the expr with the "let"?
16:14:47 <twanvl> yes, put "shellPutStrLn" on the same column as "st <- ..."
16:15:19 <Arnar_> ok.. thx
16:15:21 <Arnar_> almost there..
16:15:36 <Arnar_> is case bla of ble -> ... not an expression?
16:15:48 <Arnar_> no wait..
16:15:57 <Arnar_> sorry, nm
16:32:28 <Arnar_> hmm package ghc-6.8.2 hidden?
16:32:43 <Arnar_> works fine with runhaskell.. but get that when compiling with ghc
16:33:04 <int-e> add --make to the command line? (or -package ghc)
16:34:05 <Arnar_> ah.. ok
16:34:19 <Arnar_> so ghc --make Main.hs is enough to compile the whole thing
16:34:21 <Arnar_> nice :)
16:34:28 <geezusfreeek> is there any way that anybody knows of to cache the resulting value of a part of an STM transaction assuming that the TVars it is dependent on are known not to change?
16:35:38 <geezusfreeek> up until a few days ago i had been using unsafePerformIO to start a new thread that would atomically calculate the result and store it in a new TVar when it became available, but i realized that this made the timing nondeterministic (the result might be available, but not stored in the new TVar)
16:37:18 <geezusfreeek> hmm, we seem to be getting a spike of beginners in here this week. is there any particular reason for this? a popular blog post perhaps?
16:39:12 <ehird> geezusfreeek: reddit maybe
16:43:39 <ptolomy2> Does GHC compile a 'case of' over a non-trivial number of options into a hard-coded binary search, a linear search, or something else altogether?
16:46:51 <dons> jump table
16:47:22 <Heffalump> based on the head constructor?
16:47:52 <dons> yeah, they get nested, iirc
16:48:43 <Heffalump> guards presumably have to be a linear search
16:49:00 <dons> yeah, i'd expect so
16:56:08 <romildo> Hi.
16:56:20 <Saizan__> hi
16:57:07 <romildo> I am just learning gtk2hs and I am intrigued with menu construction.
16:59:16 <ptolomy2> Sweet.
16:59:58 <ptolomy2> (in response to jump table/nested)
17:01:51 <romildo> Reading the gtk2hs tutorial, I see that to build a menu in a GUI, a UIManager is needed, and it is based on a string describing the menu structure.I am not happy with this solution, because it is not based on the language constructs to specify the menu. Is it the only way to build menus with gtk2hs?
17:03:37 <ehird> romildo: gtk2hs isn't exactly high-level
17:05:48 <romildo> I think I would prefer a set of functions to construct the menu, item by item, like we have in other bindings to gtk+, like lablgtk (OCaml). That would not be higher level either.
17:06:59 <mux> AFAIR you're not tied to UIManager at all
17:07:05 <mux> but I can't tell you where to look, sorry
17:07:25 <mux> however, maybe you should use glade and give your fingers some rest :)
17:07:56 <ehird> romildo: So use a nicer toolkit. :-)
17:09:23 <DRMacIver> Hm. I wonder why none of these are on hackage: http://city5.org/
17:09:33 <lambdabot> Title: City 5
17:09:37 <romildo> mux, when learning the toolkit, I like to write all the code of the application and see how things work. Maybe with later projects I would use glade, but not now.
17:09:37 <DRMacIver> Fairly complete looking bindings for QDBM and Hyper Estraier
17:11:14 <romildo> ehird, I want to use gtk+ in Haskell. I am just looking for alternative ways of coding a menu structure. As mux said, I am not tied to UIManager at all, but I don't find documentation on the alternatives.
17:11:38 <ehird> romildo: Maybe try wxWidgets, though? It'll use gtk+ if you want it to.
17:11:45 <ehird> And wxHaskell is pretty darned high-level.
17:11:51 <mux> don't you have access to the MenuFoo* widgets?
17:11:55 <ehird> (And mac users won't want to stab you repeatedly, that's worth something.)
17:12:12 <mux> they're a PITA though, even GTK+ guys recommend to use something like glade to design menus nowadays
17:12:29 <DRMacIver> ehird: As long as they're not using a recent version of OSX so wxhaskell is actually compatible with their systems...
17:12:38 <mux> it's not that it's hard, but you have to deal with tons of objects containing tons of other objects
17:12:44 <mux> MenuList MenuShell MenuItem and what not
17:12:48 <mux> I don't remember the specifics
17:12:56 <mux> pretty boring though
17:13:02 <ehird> DRMacIver: Hmm. odd.
17:13:19 <wadcom> hi
17:13:32 <DRMacIver> ehird: njbartlett complains about this a lot. :) Apparently wxhaskell is only compatible with versions of wxwidgets that don't work on the more recent OSX versions. I don't know the details.
17:13:51 <romildo> mux, I will try those types.
17:14:14 <wadcom> is there a way to mimic open() syscall with System.IO.*? I need to make sure the file doesn't exist (atomically), when I'm opening it for writing. Truncation shouldn't occur.
17:15:10 <ehird> DRMacIver: That's a shame.
17:15:16 <ehird> Is there any Haskell bindings for Qt?
17:15:22 <dons> ehird: yes
17:15:22 <ehird> Sure, the licensing sucks, but the toolkit rocks.
17:15:27 <dons> wadcom: maybe, in the 'unix' package
17:15:31 <ehird> dons: Decent ones?
17:15:31 <dons> System.Posix.Files  something
17:15:33 <mux> wadcom: you could use System.Posix.IO barring something better
17:15:35 <dons> ehird: only one.
17:15:37 <dons> QtHaskell
17:15:40 <DRMacIver> ehird: There are, but they're apparently mostly autogenerated and painfully low level
17:15:42 <ehird> Haskell really needs some kind of layer to help binding C++ and similar things.
17:15:45 <ehird> All the methods used are incompatible.
17:15:49 <mux> openFd his more or less like open()
17:15:52 <ehird> wxHaskell's is quite nice, I hear.
17:15:54 <mux> s/his/there/
17:15:56 <dons> C++ needs to get its symbol names together
17:16:13 <mux> wxWidgets is quite a dog if you ask me
17:16:25 <dons> gtk2hs forever!
17:16:25 <mux> and bare gtk+ runs on windows and mac os x nowadays
17:16:40 <wadcom> mux: thanks. will look at that now
17:17:25 <ehird> mux: you are evidently not a mac user
17:17:32 <ehird> gtk+ will never be native-looking or behaving on OS X
17:17:38 <ehird> It's just fundamentally incompatible with the toolkit.
17:17:57 <DRMacIver> Native looking is totally overrated. :)
17:18:08 <proq> you could create something with a UI like xmms with gtk for OS X
17:18:26 <proq> iTunes breaks apple's own UI look and feel quite often
17:18:35 <ehird> proq: it still wouldn't behave like an OS X app
17:18:37 <ehird> even trivial stuff
17:18:41 <DRMacIver> (And yes, I'm obviously not a mac user either)
17:18:56 <ehird> i have used windows, linux and os x a lot
17:19:05 <ehird> and i know what integrates with each
17:19:14 <ehird> gtk+ on os x is awful and always will be :-)
17:19:19 <proq> ehird: sure, depending on what widgets you used
17:19:34 <mux> ehird: I don't see what so fundamentally incompatible here, but there probably are improvements to do on the mac os x front (and yes I'm not a mac user :-)
17:19:35 <ehird> proq: no :)
17:19:47 <ehird> mux: not improvements... the design doesn't allow for it
17:19:57 <mux> still waiting for you to explain why
17:20:14 <proq> ehird: feeling contrary are we? I was agreeing with you
17:20:16 <mux> gtk's API is quite abstract
17:20:25 <mux> and it actually blends very well in windows nowadays
17:20:25 <ehird> it's 1am, i'm going to bed -- there's no point explaining right now
17:20:30 <ehird> but i assure you that i am right :-)
17:20:39 <ehird> windows is similar enough to linux that it can get it right
17:20:39 <mux> pussy, it's 2:20am here!
17:20:39 <proq> ehird: I assure you you're being pedantic
17:20:44 <DRMacIver> You're wrong about it being 1am. :)
17:20:50 <mux> it's not like mac os x is so terrible different
17:20:53 <mux> it's just glossy.
17:20:53 <ehird> proq: no, totally not
17:20:59 <ehird> mux: spoken like a true non-mac user
17:21:13 <mux> it has widgets people click on
17:21:15 <mux> it has menubars
17:21:27 <mux> it has text entries and buttons and what not.
17:21:35 <ehird> heh.
17:21:38 <proq> ehird: if I agree that they behave different, and you say "no", you're being pedantic
17:21:55 <DRMacIver> The menubar integration is actually a significant pain point. It behaves differently from windows's and most of the linux desktop environments'
17:21:58 <mux> I'm not a mac user indeed, but I have been using mac os x sufficiently here and there to be relatively confident with that.
17:22:07 <DRMacIver> Similarly system tray
17:22:21 <mux> right, the menubar causes problem since it's not attached to windows
17:22:25 <mux> but apart from that...
17:22:38 <mux> it's a no-brainer for most applications
17:22:42 <DRMacIver> Not really.
17:22:59 <DRMacIver> I don't know the details, but I do know that I develop cross platform GUI software and it never fucking works right on macs. :)
17:23:21 <DRMacIver> Even with toolkits that are supposed to
17:23:22 <mux> who cares :-P
17:23:27 <ehird> it's funny because if you do it on a mac you get your menu code etc independant enough that getting it on other platforms is painless
17:23:28 * mux grins
17:24:25 <proq> if that were true, people would have flocked to safari on windows. but they hated it
17:24:28 <DRMacIver> I'm just saying - your claim about mac being "just another platform" isn't borne out by the evidence, utterly independent of any theory. :)
17:24:43 <mux> now I'll agree that using just plain gtk+ is insufficient for applications where you want a very nice and slick UI etc, but it's still quite nice for goofing around and playing with haskell & GUIs
17:24:45 <DRMacIver> (of course, it's not like linux is without its issues. xmonad confuses everything)
17:25:02 <ehird> <proq> if that were true, people would have flocked to safari on windows. but they hated it
17:25:05 <ehird> apple suck at their own HIG
17:25:07 <ehird> :-)
17:25:16 <mux> safari 3.1 is nice.
17:25:26 <mux> I long for epiphany-webkit to mature and be usable
17:25:33 <siti> if you want to get pwned
17:25:35 <mux> that or ff3 being released, finally :-)
17:25:47 <DRMacIver> The FF3 beta is pretty stable
17:25:58 <mux> yup, been using b4 & 5 for some time now
17:26:16 <wolverian> stable enough for ubuntu :)
17:26:20 <mux> it finally has decent js speed, consumes much less memory
17:26:40 <proq> people use whatever UI on linux they want, so it is much harder for it all to be polished
17:26:45 <mux> I wish they'd have ditched XUL too but I'm happy for now
17:26:58 <Cale> But Final Fantasy 3 was released years ago! :)
17:27:04 <DRMacIver> proq: I'm ok with that. :)
17:28:08 <DRMacIver> I tend to minimize any parts of the UI that aren't actual content anyway.
17:28:09 <proq> even the term "OS X app" is misleading, since a carbon and cocoa app will behave differently
17:29:30 <mux> since mac os x contains a fair amount of FreeBSD, representing a (very small, admittedly) fraction of my own code, I feel entitled to bitch about it :-P
17:29:38 <mux> s/FreeBSD/FreeBSD's code/
17:30:09 <mux> and I like to piss of my apple fanboy friends
17:33:27 <dzlk> I can't figure out why OSX is supposed to be interesting. If you're not already an Apple fan.
17:33:57 <Heffalump> <aol>
17:33:57 <DRMacIver> Hm. Ok. What does it actually mean when it says "Could not find module blah. It is a member of package foo, which is hidden"? The module is in ghc-pkg, I can quite happily :m + it in ghci. I can't actually figure out why it can't use it.
17:34:16 <Heffalump> DRMacIver: use --make or -package foo
17:34:37 <DRMacIver> Or rather specifically I can't figure out why this library I'm trying to use can't find it. :
17:34:49 <Heffalump> you're trying to build the library with cabal?
17:34:51 <DRMacIver> Yes
17:34:54 <geezusfreeek> DRMacIver: you have to add that package as a dependenncy in the cabal file
17:34:56 <Heffalump> if so, that passes --hide-all-packages on the command-line
17:35:09 <Heffalump> thus forcing only packages that it explicitly lists as a dependency to be used
17:35:13 <Heffalump> so you need to fix that
17:35:20 <DRMacIver> But the library is probably bitrotted - I know the bytestring API has changed since this was last updated
17:35:28 <DRMacIver> Ah, I see.
17:35:31 <geezusfreeek> i hate it when libs do that
17:35:43 <inimino> mux: ditch XUL and what, rewrite everything?
17:36:30 <DRMacIver> Right, that fixed it. Thanks.
17:38:24 <DRMacIver> Yeah. I think this has bitrotted to the point where I'd rather continue with my original plan. Oh well.
17:39:16 <DRMacIver> (I was thinking of trying to put together a wrapper around qdbm using Data.Binary, mainly as an excuse to play with the FFI, only to discover something very similar and rather more complete already existed)
17:40:58 <jorick> is there an inline if? something like (foo? bar: baz) would be nice
17:41:09 <Botje> nope, sorry.
17:41:20 <Saizan__> it's already like that
17:41:24 <Cale> Well, there's  if foo then bar else baz, if that's what you mean?
17:41:52 <Cale> If you want it to be infix as well, it's possible to design something like that :)
17:42:00 <jorick> im trying to squeeze the last bits out of my newest project
17:42:01 <geezusfreeek> if can be written inline, but you can't pass it around as a function
17:42:45 <Botje> > let a ??? (b,c) = if a then b else c; (:::) = (,) in 42 > 2 ??? 1 ::: 2
17:42:47 <lambdabot>   Not in scope: data constructor `:::'
17:42:51 <Botje> aww
17:43:00 <Botje> > let a ??? (b,c) = if a then b else c; a ::: b = (a,b) in 42 > 2 ??? 1 ::: 2
17:43:00 <lambdabot>   Not in scope: data constructor `:::'
17:43:10 <Botje> > let a ??? (b,c) = if a then b else c; a :=: b = (a,b) in 42 > 2 ??? 1 :=: 2
17:43:10 <lambdabot>   Not in scope: data constructor `:=:'
17:43:14 <DRMacIver> You can't define functions starting with :
17:43:18 <Botje> oh
17:43:24 <Botje> that's silly
17:43:27 <Cale> Colon is the uppercase symbol character.
17:43:29 <geezusfreeek> Botje: if it starts with : then it's a type constructor
17:43:35 <Cale> Or a data constructor
17:43:39 <geezusfreeek> err
17:43:40 <geezusfreeek> yeah
17:43:49 <geezusfreeek> a constructor, period
17:44:30 <Cale> > let a <?> (b,c) = if a then b else c; a <:> b = (a,b) in 42 > 2 <?> 1 <:> 2
17:44:31 <lambdabot>   add an instance declaration for (Num (t, t))
17:44:36 <Cale> > let a <?> (b,c) = if a then b else c; a <:> b = (a,b) in 42 > 2 <?> (1 <:> 2)
17:44:36 <lambdabot>   add an instance declaration for (Num Bool)
17:44:48 <Cale> need infix decls to make it work :)
17:44:53 <Cale> > let a <?> (b,c) = if a then b else c; a <:> b = (a,b) in (42 > 2) <?> (1 <:> 2)
17:44:55 <lambdabot>  1
17:45:08 <Cale> With the right fixities, you wouldn't need the parens.
17:45:25 <Cale> Also, you could make the then/else part a datatype, and use a constructor starting with : if you want
17:45:57 <DRMacIver> Or you could just, you know, use multiple arguments...
17:46:36 <Cale> And have a prefix notation, sure.
17:47:20 <DRMacIver> Having this infix doesn't seem to gain you anyway.
17:47:29 <DRMacIver> Except being a cute syntactic hack
17:47:38 <Cale> Right, I think that was the goal :)
17:47:48 <OceanSpray> @index toImlibColor
17:47:49 <lambdabot> bzzt
17:47:51 <OceanSpray> shit.
17:47:52 <DRMacIver> ok. As long as we're clear on that. :)
17:48:25 <ddarius> OceanSpray: lambdabot doesn't know all yet
17:48:43 <OceanSpray> what's a good way to see where a Haskell program is in an infinite loop?
17:49:01 <OceanSpray> there's got to be a way to say to the program "hey, break here, and tell me what function you're in"
17:49:42 <ddarius> OceanSpray: Use the GHCi debugger.
17:50:49 <geezusfreeek> would a function that caches values of type (STM a) inside transactions (as opposed to recalculating them every time they are used even when it is known that the result will be the same because the TVars it depends on have not changed) be a nice addition to GHC's STM implementation? it's something i need and am thinking about looking into adding, but this is for a library and i don't want to make the library dependent on a spe
17:51:20 <geezusfreeek> basically, might something like that be accepted into HEAD?
17:51:24 <minivan> I was going to suggest gdb, but ghci makes more sense
17:52:33 * ddarius needs to write a library of combinators for manipulating mutable arrays conveniently.
17:53:00 <geezusfreeek> i don't even know how the STM implementation works yet, so i'm not even sure if the idea is very applicable as stated
17:57:40 <Cale> geezusfreeek: Uh, caches values of type (STM a)? Those are STM computations, and being values, they should already be subject to the usual amount of sharing memoisation which is present in Haskell, I should think.
17:58:07 <geezusfreeek> i mean across multiple calls to atomically
17:58:11 <Cale> Er, maybe I'm not understanding the question...
17:58:24 <Cale> hmm, caches the *results* of STM computations?
17:58:34 <geezusfreeek> the implementation as it is now will always reread TVars and recompute the result even if it is unchanged
17:58:37 <Cale> That is, the resulting values of type a?
17:58:41 <geezusfreeek> yes
17:58:53 <geezusfreeek> maybe i could do without a special function
17:58:55 <geezusfreeek> just make a change
17:58:58 <Cale> Of course, if there are no writes to any TVars in the transaction, that could be done.
17:59:02 <geezusfreeek> but that seems like it could be wasteful
17:59:24 <geezusfreeek> well, that's all i mean
17:59:57 <geezusfreeek> i really want it on a subtransactional level, is the real purpose
18:00:04 <geezusfreeek> something of type STM a -> STM a
18:00:57 <Cale> and you're having trouble arranging that the same STM transaction isn't run multiple times, but the results merely passed along?
18:01:49 <geezusfreeek> that sounds roughly like what i need to do, yes
18:02:24 <Cale> I think I see what you mean. If an STM action with no writes in between to the variables it read from is executed twice in the same call to atomically, then it must give the same result.
18:02:47 <Cale> So that's an optimisation which is available due to the semantics of STM which I'm not sure is actually made.
18:02:48 <geezusfreeek> as i said earlier today, i had written a solution involving unsafePerformIO and forkIO, but it destroyed some of the nice properties of STM
18:03:00 <geezusfreeek> right
18:03:29 <geezusfreeek> i don't think we would _want_ it to be made in all cases of course
18:03:40 <geezusfreeek> for the same reason that we don't actually memoize _everything_ in haskell
18:04:29 <geezusfreeek> but i definitely need this caching behavior for the FRP stuff i'm doing
18:05:10 <Cale> Well, I suspect it would usually be a win.
18:05:16 <Cale> hmm...
18:05:25 <conal> geezusfreeek: do you have a blog?  i'd be interested in reading a post about the issues you're running into.
18:05:34 <Saizan> but, why do you run it twice?
18:05:49 <conal> geezusfreeek: and it make make motivation clear to the STM implementors.
18:05:54 <geezusfreeek> Saizan: the TVars are write once read many
18:06:09 <conal> like IVars
18:06:17 <geezusfreeek> conal: i do have a private dev log that i'm keeping, but i haven't really made any details about this problem in it yet
18:06:29 <Cale> Actually, hey, that's a good idea.
18:06:36 <geezusfreeek> i have been too busy studying and fussing with stupid ISP this week
18:06:44 <Saizan> so you want to cache the reading from a TVar?
18:06:45 <geezusfreeek> yeah like IVars
18:06:52 <geezusfreeek> i need TIVars :)
18:07:02 <Cale> That's totally doable.
18:07:05 <conal> geezusfreeek: i bet if you write it up for external consumption, you'll get more clarity for yourself, as well as helpful input from others.
18:07:17 <geezusfreeek> Saizan: i want to cache the result of reading from one _or more_ TVars and performing calculations with them
18:07:48 <Cale> geezusfreeek: What if you were just to stash the result in another variable?
18:07:50 <geezusfreeek> conal: i will probably do that
18:07:59 <conal> :)
18:08:04 <geezusfreeek> Cale: that is what i have been doing so far
18:08:32 <Cale> Maybe have something like a TIVar which is such that a read when it's empty will cause a retry
18:08:41 <Cale> hmm
18:09:28 <jorick> im writing a computer language (yup :D). i'm using readline for the input and parsec for parsing. i'm wondering: is it possible to determine wether a parseError is due to "not enough data"
18:09:31 <geezusfreeek> Cale: since this is mid-transaction stuff, this involves creating a new TVar, forking a new thread with unsafePerformIO which gets the result of the transaction and stores it in the new TVar, and in the original thread returns (readTVar theNewTVar)
18:10:07 <jorick> because, then i can call readline again and simply ask for more
18:10:07 <geezusfreeek> the problem is that the other TVars this depends on might be updated with the information needed to perform the transaction, but the resulting cache TVar doesn't have this information yet
18:10:22 <geezusfreeek> so some transactional guarantees are lost
18:11:11 <geezusfreeek> well, not transactional guarantees, but other behavior necessary for an atomic transaction anyway
18:11:23 <Philippa> jorick: "expected ..., found eof"?
18:11:47 <Philippa> you'll want to poke through the docs to figure out how to spot that
18:12:03 <jorick> i dont get it
18:12:33 <Philippa> jorick: if the parser finds eof when it was expecting something, the parse error's due to "not enough data"
18:12:49 <Philippa> as in "I was expecting something here, but I didn't get anything/got EOF!"
18:12:59 <jorick> yes
18:13:12 <jorick> so how do i tell if that is what a ParseError says?
18:14:43 <Philippa> hmm. Sadly, it looks like the ParseError type doesn't quite expose enough :-(
18:15:29 <ddarius> Philippa: Really?
18:16:03 <Philippa> ddarius: Message gives strings rather than enough structure to spot that it was an EOF cleanly, no other appropriate query
18:16:32 <geezusfreeek> i guess i will write up a blog article and post it to the mailing list
18:16:51 <drguildo> is there any way of fetching the penultimate element of a list without knowing its length?
18:16:58 <dzlk> Can eof be made a valid input? Then you could recurse until eof with a one-liner as the base casse.
18:17:18 <Philippa> dzlk: eof's valid, yes
18:17:34 <Philippa> rather, any char's valid but what parsec takes as EOF is the end of the string
18:17:59 <BMeph> drguildo: last . init should do the trick.
18:18:02 <Saizan> > (\xs -> last $ zipWith const xs (drop 2 xs)) [1..10]
18:18:05 <lambdabot>  8
18:18:15 <Saizan> > (\xs -> last $ zipWith const xs (drop 1 xs)) [1..10]
18:18:16 <lambdabot>  9
18:18:38 <Saizan> drguildo: ^^^^
18:18:59 <drguildo> ok the reason i ask
18:19:02 <BMeph> > (last . init) [1..10]
18:19:03 <lambdabot>  9
18:19:10 <drguildo> http://book.realworldhaskell.org/beta/funcstypes.html
18:19:11 <lambdabot> Title: Chapter 2. Types and Functions
18:19:16 <drguildo> scroll to the bottom
18:19:20 <drguildo> the second exercise
18:19:46 <drguildo> from what i can tell there's no way of doing that given what's been taught in the preceding sections
18:20:00 <drguildo> the solutions you guys have given are too advanced
18:20:15 <drguildo> and the length function hasn't been mentioned from what i can tell
18:21:03 <Saizan> you can write it with direct recursion
18:21:22 <Saizan> does it teach about basic list pattern matching?
18:21:37 <drguildo> i don't think so
18:22:10 <drguildo> it only just mentions type signatures
18:22:17 <drguildo> and functions with more than 2 parameters
18:22:24 <drguildo> so i very much doubt it
18:25:12 <drguildo> no search results for "x:xs"
18:26:33 <roconnor> http://www.joachim-breitner.de/blog/archives/291-guid.html
18:26:34 <lambdabot> Title: Pausable IO actions for better GUI responsiveness - nomeata’s mind shares
18:30:59 <sebaseba> newbie question here
18:31:16 <BMeph> Newbie answers provided, free of charge. ;)
18:31:22 <sarehu> gah stupid me, I spent 20 minutes worrying about serialization instead of deriving Read :/
18:31:34 <sebaseba> I want to write a function opt2 which receives a list and two indexes into it, and return a list with those elements swapped.
18:31:56 <sarehu> don't use a list then
18:32:05 <BMeph> ?faq Can you do that in Haskell?
18:32:05 <lambdabot> The answer is: Yes! Haskell can do that.
18:32:08 <sebaseba> what should I use?
18:32:29 <BMeph> Use a Sequence instead! ;)
18:32:31 <sarehu> well if you are in the habit of using deep indices and doing weird stuff like that, why not Data.Sequence
18:32:48 <BMeph> Hah! I said it first. ;)
18:32:50 <sarehu> it depends on whether performance matters :)
18:32:54 <byorgey> drguildo: I think you might be right.  You should definitely leave a comment to that effect on the exercise in question.
18:33:33 <sebaseba> OK, so let's say I use a Sequence then. But I was thinking: what it my sequence contains only one element?
18:33:41 <sarehu> what if it does
18:33:48 <BMeph> drguildo, byorgey: Or at least, mention that it's much clunkier, with only the info given so far.
18:33:53 <sarehu> what if your indices are out of range?
18:33:56 <sarehu> that's the real question
18:34:01 <sebaseba> ah
18:34:06 <sarehu> if you have one element, both the indices could still be zero
18:34:22 <drguildo> byorgey: will do, thanks.
18:34:24 <sarehu> and then 'swapping' wouldn't do anything
18:35:08 <sebaseba> if we assume the indices could be out of range, then should i change the output type to a Maybe or something?
18:35:13 <byorgey> > let replace 0 r (x:xs) = (r:xs); replace n r (x:xs) = x : replace (n-1) r xs; swap m n xs = replace m (xs!!n) (replace n (xs!!m)) in swap 1 3 [0,4,3,2,6,4,4,3]
18:35:13 <lambdabot>  Couldn't match expected type `[a]'
18:35:14 <BMeph> Check for dup'd indices, no matter what, or for indices in range first?
18:35:27 <byorgey> > let replace 0 r (x:xs) = (r:xs); replace n r (x:xs) = x : replace (n-1) r xs; swap m n xs = replace m (xs!!n) (replace n (xs!!m) xs) in swap 1 3 [0,4,3,2,6,4,4,3]
18:35:28 <lambdabot>  [0,2,3,4,6,4,4,3]
18:36:00 <byorgey> but using something like Sequence is probably better, as others have said. =)
18:36:22 <sebaseba> OK, thanks. I'll meditate on that for a while. Might come back later!
18:36:32 <byorgey> sebaseba: even better would be to use an algorithm that doesn't require swapping elements of a list like that. =)  what exactly is it you're trying to accomplish?
18:36:53 <sebaseba> Do heuristic search on a scheduling optimization problem.
18:37:13 <byorgey> sebaseba: ok, and what does the list represent?
18:37:33 <sebaseba> The list, or sequence, would represent the ordering of tasks in the schedule.
18:38:02 <byorgey> ok, I see.  hmm.
18:38:33 <byorgey> you could also use something like a DiffArray.
18:38:52 <sebaseba> what is that?
18:38:54 <BMeph> Actually, seba^2, you should probably use an MArray.
18:39:27 <BMeph> Or the DiffArray, aye.
18:39:30 <byorgey> nooooo not an MArray!
18:39:33 <byorgey> those are so confusing.
18:40:10 <byorgey> a DiffArray gives you O(1) access to elements, and lets you update elements (thus producing a new array).
18:40:26 <sebaseba> sounds good
18:40:32 <byorgey> but the update secretly happens in-place, with various magic to hide this fact from you, so it is efficient but still functional
18:40:44 <sebaseba> that's why I love this channel: people actually help.
18:41:09 <sebaseba> you guys and gals are great!
18:41:46 <byorgey> http://haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-Diff.html
18:41:52 <lambdabot> http://tinyurl.com/5doahb
18:41:55 <byorgey> unfortunately there are no examples in the docs
18:42:08 <byorgey> but feel free to ask if you need help of course =)
18:42:17 <sebaseba> thanks!
18:42:40 <byorgey> you're welcome =)
18:43:20 <ddarius> DiffArrays are slow
18:44:11 <byorgey> well, if the speed ends up being important, it's not too big of a jump from a DiffArray to an IOUArray or something (is it?)
18:44:43 <ddarius> byorgey: It's going from pure code to monadic code.
18:45:40 <byorgey> well, that's true
18:45:49 <byorgey> but you do already have to construct a DiffArray in the IO monad, at least
18:45:54 <sebaseba> will try with the simplest option first, then go on from that
18:46:27 <Saizan> no, you can create them anywhere
18:46:49 <byorgey> Saizan: really?
18:47:08 <byorgey> sebaseba: can you predict in advance in what order you will examine the different task orderings? I'm guessing no, right?
18:48:19 <sebaseba> I'm not sure.
18:48:22 <sebaseba> probably not.
18:48:46 <gwern> 'Lies: there is no Republic of Haskell. The purely functional languages have no State.'
18:48:51 <Saizan> byorgey: they are instance of IArray so you can create them with listArray
18:49:05 <nejucomo> I'm having trouble with the pattern matching (deconstruction) syntax for a parameterized type...
18:49:19 <nejucomo> data Foo a b = X Y Z
18:49:41 <nejucomo> f :: Foo a b -> W -> U
18:49:43 <byorgey> Saizan: ah, right
18:50:03 <nejucomo> f (Foo a b ????) w = u
18:50:17 <byorgey> nejucomo: the first argument is of type Foo a b
18:50:20 <nejucomo> How do I write a function that takes a Foo with any a and b.
18:50:28 <byorgey> data Foo a b = X Y Z means, values of type Foo a b look like 'X Y Z'
18:50:40 <byorgey> so you get  f (X y z) ...
18:50:45 <nejucomo> byorgey: I feel I understand that declaration quite well (I wrote it).
18:50:56 <ddarius> nejucomo: Clearly you do not.
18:51:00 <nejucomo> hehe...
18:51:10 <byorgey> nejucomo: ok, I was trying to explain how understanding that declaration tells you how to write f.
18:51:33 <nejucomo> I'm sorry, I made a type, I really have:
18:51:34 <ddarius> @src Maybe
18:51:35 <lambdabot> data Maybe a = Nothing | Just a
18:51:43 <nejucomo> data Foo a b = Foo X Y Z
18:52:06 <ddarius> nejucomo: Okay, that's much better.
18:52:16 <byorgey> ah, ok, so that means values of type Foo a b  look like 'Foo x y z' where x, y, and z are any values of type X, Y, and Z respectively.
18:52:30 <ddarius> However, a and b are not being used.  This is a common pattern called "phantom types", but is that what you want here?
18:52:40 <nejucomo> Right, and my X, Y, and Z happen to be functions which have types related to a and b.
18:52:55 <nejucomo> I'll brb.
18:53:44 <Saizan> type parameter are passed at the type level, you don't get to pattern match on them
18:53:47 <byorgey> nejucomo: you mean, in your actual code you do not have 'Foo X Y Z', but something more complicated where X Y Z are replaced by things having to do with a and b?
18:54:09 <byorgey> or do you mean you literally have 'Foo X Y Z' and X, Y, Z are declared somewhere else?
18:54:34 <byorgey> in the latter case, even if the definitions of X Y and Z refer to a or b they will not be the *same* a and b.
18:58:39 <BMeph> nejucomo: hpaste is your (well, everyone's) friend... :)
19:00:45 <OceanSpray> Cale, you still here?
19:00:54 <nejucom1> So...  My X Y and Z are functions on a and/or b.
19:02:09 <conal> nejucom1: there's maybe some terminological static.  it might help if you spell out X, Y, and Z
19:02:41 <conal> nejucom1: in other words, if you give us your exact definition of Foo
19:02:54 <nejucom2> Grr...  Flaky public wifi...
19:02:54 <BMeph> As well as a and b. :)
19:03:09 <nejucom2> Sorry, could you repeat the last bit?
19:03:14 <Saizan> a and b are variables..
19:03:21 <BMeph> hpaste
19:03:25 <nejucom2> Type variables, right?
19:03:29 <Saizan> nejucom2: give us the real definition, it's better
19:03:30 <byorgey> right
19:03:32 <conal> reminds me of an old math joke: "Take a point P and call it Q..."
19:03:34 <nejucom2> Okay:
19:03:44 <BMeph> ".org" ;p
19:03:51 <nejucom2> data MDHash chainvar block = MDHash (chainvar,
19:03:51 <nejucom2>                                      String -> [block],
19:03:51 <nejucom2>                                      chainvar -> block -> chainvar,
19:03:51 <nejucom2>                                      chainvar -> String)
19:04:09 <byorgey> ah, well, you have a four-tuple there =)
19:04:16 <nejucom2> (Initially I began with a typeclass, but that's another story.
19:04:19 <byorgey> is that really what you want?
19:04:26 <nejucom2> Right, I was generalizing in the irc channel.
19:04:40 <byorgey> as opposed to  ... = MDHAsh chainvar (String -> [block]) (chainvar -> ...
19:04:44 <nejucom2> My question is:  "If I have a parameterized type, how do I write the pattern to deconstruct it?"
19:05:05 <byorgey> nejucomo: the same way you would a non-parameterized type.
19:05:10 <nejucom2> byorgey: Ah!  That's it.
19:05:15 <Saizan> pattern mathing on that looks like (MDHash (cv,f1,f2,f3))
19:05:19 <nejucom2> I just cut'n'pasted my working solution which used a tuple.
19:05:20 <byorgey> the parameterization makes no difference to pattern matching.
19:06:04 <nejucom2> Thanks.
19:06:27 <nejucom2> I'm still frequently confused by haskell syntax, but it's slowly sinking in.
19:06:34 <BMeph> ZOMG! It's a (Syntax)Ninja! o.O
19:06:35 <byorgey> right, and if you just defined MDHash as a constructor with four arguments, instead of one argument of a 4-tuple, then pattern matching it would look like (MDHash cv f1 f2 f3)
19:06:50 <nejucom2> Excellent.
19:06:57 <byorgey> nejucom2: no problem, we were all there once =)
19:07:24 <nejucom2> Now I think I have a good case for record syntax.
19:07:31 <byorgey> I agree =)
19:19:41 <zooko> nejucom3: I'm trying to learn a bit of Haskell in order to patch darcs to reject certain invalid patches as described here: http://bugs.darcs.net/issue815
19:19:43 <lambdabot> Title: Issue 815: corrupt patch in darcs-2 - Darcs bug tracker
19:20:10 <zooko> It would be really cool to hack darcs to write using HTTP PUT so that then it could write to the allmydata.org Tahoe "Least Authority Filesystem"./
19:20:54 <SamB> I thought someone done did that
19:21:15 <nejucom3> The patch or HTTP PUT?
19:21:50 <SamB> HTTP PUT
19:24:44 <nejucom1> zooko: Is your goal to write a unit test that reproduces the bug?
19:25:08 <zooko> nejucom*: that would be great, but actually I can't.
19:25:14 <zooko> Nobody knows how this bug came about.
19:25:41 <nejucom1> Hmm...  I'm not at all familiar with haskell debugging techniques.
19:26:04 <zooko> So, when I find a use of a name in Haskell, I generally am able to find a definition or import of that name elsewhere in the file.  But this name "mRemoveFile" in http://allmydata.org/trac/darcs-2/browser/src/Darcs/Patch/Apply.lhs doesn't seem to occur anywhere else in the file.
19:26:06 <lambdabot> Title: /src/Darcs/Patch/Apply.lhs – darcs-2 (demo trac instance) – Trac, http://tinyurl.com/63dmt7
19:26:26 <nejucom1> It seems like if you could trace an run against the bad input, you could begin developing unit tests from that.
19:26:52 <byorgey> zooko: you don't have to explicitly list functions being imported from another module.
19:27:02 <byorgey> zooko: if you just say 'import Foo' you get all the functions exported by Foo.
19:27:25 <nejucom1> The module definition explicitly names exported values.
19:27:42 <zooko> Oh, too bad for me trying to figure out how this name got into this module, then.
19:27:47 <zooko> Grepping shows me several candidates...
19:27:51 <byorgey> zooko: grep is your friend =)
19:28:02 <nejucom1> Yeah...  Sounds like a need for an IDE tool.
19:28:07 <byorgey> indeed.
19:28:26 <zooko> nejucom*: wait, so there are two things you could mean by "reproduce this bug": 1.  how did this corrupted patch come into existence?  2.  how does darcs-2+ handle such corrupted patches.
19:28:33 * nejucom1 reads the info on the xemacs haskell mode.
19:28:33 <zooko> The latter is easy to make test for.  Indeed, I should.
19:28:46 <nejucom1> I meant the latter.
19:29:08 <nejucom1> The former is tricky because you don't have a reproducable test, right?
19:29:09 <zooko> However, there is not a nice test infrastructure for darcs currently.  There are many tests, but they are written in sh or in perl, and developers do not like them because they raise the alarm in obscure and sometimes false ways.
19:29:18 <zooko> Right -- nobody knows how this corrupted patch came to be.
19:29:28 <nejucom1> Hrm...  No unittests?
19:29:32 <zooko> But to test how darcs handles such a patch would be very easy, if only I had a nice test framework to use.
19:29:46 <conal> zooko: you could ask ghci where mRemoveFile is.  start up ghci, load in Apply.hs, and type ":i mRemoveFile".
19:29:47 <zooko> What do you mean by "unittests".  There are hundreds of tests.  Probably some people call them "unit tests".
19:29:56 <zooko> conal: thanks!
19:30:02 <conal> zooko: :)
19:30:26 <zooko> conal: how do I load Apply?
19:30:31 <nejucom1> Ah...  I think of unit tests as being as "tightly" coupled to the tested code as possible, so launching processes from shell kind of makes me hesitant.
19:30:40 <zooko> "load Darcs.Patch.Apply" and "import Darcs.Patch.Apply" didn't work.
19:30:53 <nejucom1> :help
19:30:57 <zooko> Thanks.
19:31:11 <conal> zooko: in what directory did you start ghci?
19:31:38 <nejucom1> Actually, for my project I began writing a UnitTest module, but I had to export all of the innards of the modules I wanted to test, because UnitTest needed to import them.  Is there a better approach?
19:31:54 <conal> zooko: try ":m + Darcs.Patch.Apply", assuming you're in the src/ directory
19:32:23 <conal> zooko: :m is short for :module
19:32:26 <zooko> Ah, I was in the directory above src/.  Thanks.
19:32:47 <nejucom1> How does :load compare to :mod ?
19:32:57 <zooko> Prelude> :m + Darcs.Patch.Apply
19:32:57 <zooko> module main:Darcs.Patch.Apply is not loaded
19:33:04 <zooko> Prelude> :load Darcs.Patch.Apply
19:33:04 <zooko> Darcs/Patch/Apply.lhs:21:0:
19:33:04 <zooko>      error: gadts.h: No such file or directory
19:33:11 * zooko looks for gadts.h
19:33:36 <conal> oops.  out of my league.  can anyone help zooko with gadts.h?
19:33:39 <zooko> There it is http://allmydata.org/trac/darcs-2/browser/src
19:33:42 <lambdabot> Title: /src – darcs-2 (demo trac instance) – Trac
19:33:56 <nejucom1> A C header file?
19:34:14 <zooko> So grep tells me that mRemoveFile is either in http://allmydata.org/trac/darcs-2/browser/src/Darcs/FilePathMonad.lhs
19:34:16 <lambdabot> Title: /src/Darcs/FilePathMonad.lhs – darcs-2 (demo trac instance) – Trac, http://tinyurl.com/68pjbb
19:34:31 <zooko> Or http://allmydata.org/trac/darcs-2/browser/src/Darcs/IO.lhs
19:34:33 <lambdabot> Title: /src/Darcs/IO.lhs – darcs-2 (demo trac instance) – Trac
19:35:07 <zooko> Or http://allmydata.org/trac/darcs-2/browser/src/Darcs/Repository/HashedIO.lhs
19:35:09 <lambdabot> Title: /src/Darcs/Repository/HashedIO.lhs – darcs-2 (demo trac instance) – Trac, http://tinyurl.com/5kx2e7
19:35:19 <zooko> ("hashed IO"?  That's interesting.)
19:35:41 <zooko> Or finally http://allmydata.org/trac/darcs-2/browser/src/Darcs/SlurpDirectory.lhs
19:35:44 <lambdabot> Title: /src/Darcs/SlurpDirectory.lhs – darcs-2 (demo trac instance) – Trac, http://tinyurl.com/5cgyvf
19:35:56 <zooko> I suppose it is polymorphism which makes it so that mRemoveFile is different code depending on its arguments.
19:36:05 <zooko> And the different code is definied in different files.
19:38:12 <zooko> Hm.  Or is it that there are two or three different versions of the same thing in darcs and older ones are just being kept around for some reason...
19:38:15 <nejucom2> Did grep only return one result?  (I think if you grep for "mRemoveFile *=" you should find the only definition.)
19:38:38 <zooko> src/Darcs/IO.lhs:    mRemoveFile = removeFile . fn2fp
19:38:39 <zooko> src/Darcs/Repository/HashedIO.lhs:    mRemoveFile = rmThing
19:38:39 <zooko> src/Darcs/SlurpDirectory.lhs:    mRemoveFile = smRemoveFile
19:38:43 <zooko> See the URL's I've been posting.
19:39:23 <zooko> And your grep pattern missed the fourth one: src/Darcs/FilePathMonad.lhs:    mRemoveFile f = FPM $ \fs -> (filter (/= f) fs, ())
19:39:39 * nejucom2 realizes he's been disconnecting and reconnecting and his client hasn't indicated this, and he's missed some unknown part of the recent chat history, so he is now at http://tunes.org/~nef/logs/haskell/
19:39:41 <lambdabot> Title: Index of /~nef/logs/haskell
19:39:47 <zooko> Heh.
19:40:02 <zooko> It's like having hearing loss where you miss whole sentences with no indication.
19:40:56 <conal> or an alien abduction with memory loss
19:41:20 <zooko> nejucomo: It's like having hearing loss where you miss whole sentences with no indication.
19:41:30 <nejucom2> So which of those modules are imported in the one you are examining?
19:42:03 <zooko> nejucom*: oh, good question.  Thanks for helping me not get distracted into wondering if darcs needs to be refactored to have one, two, or three fewer file manipulation routines.  :-)
19:42:22 <nejucom2> You really want to grep for exported symbols which may be multiline.  I think the syntax is: "module Foo (a, b, c) where" where all spaces can be any whitespace.
19:43:01 <zooko> This is the module in question http://allmydata.org/trac/darcs-2/browser/src/Darcs/Patch/Apply.lhs
19:43:04 <lambdabot> Title: /src/Darcs/Patch/Apply.lhs – darcs-2 (demo trac instance) – Trac, http://tinyurl.com/63dmt7
19:43:41 <zooko> Hm.  So this one, for example, never exports the symbol, right? http://allmydata.org/trac/darcs-2/browser/src/Darcs/IO.lhs
19:43:43 <lambdabot> Title: /src/Darcs/IO.lhs – darcs-2 (demo trac instance) – Trac
19:45:05 <zooko> Actually none of them say "module Foo(mRemoveFile) where"
19:45:15 <zooko> So... none of them export that symbol?
19:45:48 <nejucom2> There's export and import syntax I haven't seen before, I'm not sure what "module Foo (... Bar(...) ...)" means,
19:46:11 <zooko> So Apply.lhs imports the following candidates: import Darcs.FilePathMonad ( withFilePaths )
19:46:12 <nejucom2> I assume "import Foo (a, b, c)" means only import those three symbols into the current module namespace.
19:46:27 <zooko> But I believe that means that it does *not* import any other symbols such as mRemoveFile from FilePathMonad.
19:46:53 <zooko> Ah: import Darcs.IO ( WriteableDirectory(..), ReadableDirectory(..) )
19:47:09 <zooko> The (..) must mean all the symbols, because WriteableDirectory in http://allmydata.org/trac/darcs-2/browser/src/Darcs/IO.lhs does define mRemoveFile.
19:47:10 <lambdabot> Title: /src/Darcs/IO.lhs – darcs-2 (demo trac instance) – Trac
19:47:27 <nejucom2> I believe "import Darcs.FilePathMonad ( withFilePaths )" only introduces a single symbol.
19:47:36 <zooko> Yeah, that's what I said.
19:48:06 <nejucom2> Yeah, I assume that nested parens is some kind of nested import.
19:48:08 <zooko> It's like having hearing loss where you miss whole sentences with no indication.
19:48:18 * nejucom2 finds Darcs.IO
19:48:36 <zooko> Apply.lhs does not import HashedIO...
19:48:47 <zooko> You can view it on my trac: http://allmydata.org/trac/darcs-2/browser/src/Darcs/IO.lhs
19:48:48 <lambdabot> Title: /src/Darcs/IO.lhs – darcs-2 (demo trac instance) – Trac
19:52:20 <nejucom2> So assuming the import of Darcs.IO(WriteableDirectory(..)) is what provides the name mRemoveFile, that does not tell you where the definition is, because WriteableDirectory is a type class.
19:52:40 <nejucom2> It's an interface specification, and mRemoveFile is part of the interface.
19:52:58 <zooko> Ok.
19:53:05 <nejucom2> This is where tracing or interactive debugging would be handy.
19:53:31 <nejucom2> To know which instance of mRemoveFile is referred to, I believe you have to know the types of the arguments given to it.
19:54:09 <nejucom2> Are you interested in Apply.lhs line 134?
19:55:09 <zooko> Sorry I got distracted installing new syntax-highlighting for literate Haskell on my trac.  :-)
19:55:18 <nejucom2> hehe...
19:55:41 <nejucom2> It's pretty cool/funny/strange that the source code is also latex input.
19:55:55 <zooko> Check it out: http://allmydata.org/trac/darcs-2/browser/src/Darcs/Patch/Apply.lhs#L134
19:55:58 <zooko> beautiful!
19:56:02 <lambdabot> Title: /src/Darcs/Patch/Apply.lhs – darcs-2 (demo trac instance) – Trac, http://tinyurl.com/63dmt7
19:56:49 <nejucom2> It's pretty, but I wish each symbol had a context menu.
19:56:56 <zooko> Yes.  To implement the change that we are talking about, we simply extend the remove-file operation from raising an error if the file doesn't exist, to raising an error if the file doesn't exist *or* is non-empty.
19:57:00 <zooko> :-)
19:57:15 <zooko> Argh!  You ask for so much!  Tomorrow I will look for the Trac-LiterateHaskell-ContextMenu plugin.
19:57:17 <zooko> Just kidding.
19:57:23 * nejucom2 is hunting for the type class Apply to find the type of line 134...
19:57:25 <zooko> I need to go to bed with my wife now.  It is 21:00 in UTC-6.
19:57:34 <nejucom2> Alright.
19:57:36 <zooko> I look forward to learning more Haskell with you!
19:57:38 <zooko> Good night!
19:57:42 <nejucom2> G'night.
19:57:46 <conal> later, zooko
19:57:51 <zooko> Thanks!
20:14:02 <dancor> @pl \ x -> (True, snd x)
20:14:02 <lambdabot> (,) True . snd
20:16:04 <solrize> is there a simple way with data.binary to 1) just dump out a bytestring literally into the Put monad, and 2) dump out a String as utf8-encoded bytes?
20:24:39 <jaredj> ... hdbc vs hsql?
20:26:34 <jaredj> am i netsplitted? normally people would have said a screenful by now
20:26:43 <solrize> channel is quiet
20:26:46 <jaredj> (about something)
20:26:53 <jaredj> hmm k
20:28:23 <gwern> we could discuss how awesome xmonad is
20:28:54 <jaredj> verranice
20:29:13 <jaredj> i switched from ratpoison
20:29:19 <gwern> I disagree. I think it is exceptionally nice
20:29:48 <gwern> hm. possible discussion topic: 'Dwm, ratpoison, awesome: threat or menace?'
20:29:53 <jaredj> NO ION IS TEH ROCK
20:29:57 <jaredj> awesome?
20:30:29 <gwern> a dwm fork, minus modest considerations like keeping the loc down
20:30:42 <jaredj> ...??
20:30:43 * jaredj googles
20:30:54 <jaredj> urrh.
20:31:02 * jaredj googles "awesome window manager"
20:31:25 * allbery_b can't help but wonder how well that works
20:33:05 <jaredj> bah, the website doesn't
20:33:23 <jaredj> i will not likely switch.
20:33:34 <jaredj> i thought ion was cool once
20:33:47 <jaredj> but tuomov said my multiple monitors were "penis enlargement"
20:34:10 <gwern> tuomov being a dick, he'd know
20:34:26 <jaredj> i guess that makes him a small one?
20:37:38 <jaredj> w00t, rez hd exists
20:37:58 <dancor> @pl \ (x, y) -> g (f x) (f y)
20:37:59 <lambdabot> uncurry ((. f) . g . f)
20:38:20 <dancor> @pl \ f (x, y) -> g (f x) (f y)
20:38:20 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . g) .))
20:42:05 <dolio> @seen edwardk
20:42:05 <lambdabot> edwardk is in ##logic and #haskell. I don't know when edwardk last spoke.
20:46:29 <dolio> @tell edwardk 'g_futu d = unfoldWith (free (fmap Return) (fmap Roll . d))'? (free :: Functor f => (a -> b) -> (f b -> b) -> Free f a -> b)
20:46:29 <lambdabot> Consider it noted.
20:54:33 <dolio> @type \f -> uncurry (g `on` f)
20:54:36 <lambdabot> forall b c a. (SimpleReflect.FromExpr c, Show b) => (a -> b) -> (a, a) -> c
20:54:43 <dolio> @type \g f -> uncurry (g `on` f)
20:54:44 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> (a, a) -> c
20:54:58 <dolio> dancor: ^^
20:55:41 <dancor> mm nice i should have known
20:55:46 <gwern> @src isDigit
20:55:46 <lambdabot> Source not found. The more you drive -- the dumber you get.
20:56:37 <dancor> > uncurry (sum `on` length) ("hi", "bai")
20:56:38 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a] -> c
20:56:38 <lambdabot>     Proba...
20:56:42 <dancor> > uncurry ((+) `on` length) ("hi", "bai")
20:56:44 <lambdabot>  5
20:56:55 <newsham> ?type \rice -> curry `on` rice
20:56:57 <lambdabot>     Occurs check: cannot construct the infinite type: a = (a, b) -> c
20:56:57 <lambdabot>     Probable cause: `curry' is applied to too few arguments
20:56:57 <lambdabot>     In the first argument of `on', namely `curry'
20:57:10 <newsham> ?type curry on
20:57:11 <lambdabot>     Couldn't match expected type `(a, b)'
20:57:11 <lambdabot>            against inferred type `b1 -> b1 -> c'
20:57:11 <lambdabot>     Probable cause: `on' is applied to too few arguments
20:57:29 <dancor> curry is applied to too few entrees
21:00:04 <dolio> @type on . curry
21:00:05 <lambdabot> forall a b c. ((b, b) -> c) -> (a -> b) -> a -> a -> c
21:00:27 <gwern> I wonder where the discussion about a more efficient isDigit is?
21:00:35 <gwern> @where haskell-libraries
21:00:35 <lambdabot> I know nothing about haskell-libraries.
21:01:00 <dolio> How bad is the current one?
21:01:15 <gwern> dolio: I dunno. I was told it's inefficient
21:07:48 <Cale> It's possibly inefficient relative to a non-unicode implementation?
21:09:24 <solrize> :t isDigit
21:09:25 <lambdabot> Char -> Bool
21:09:44 <solrize> @src isDigit
21:09:44 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
21:12:16 <gwern> @pl \(x,y) -> (unpackPS x, unpackPS y)
21:12:16 <lambdabot> unpackPS *** unpackPS
21:12:51 <edwardk> heya dolio
21:12:51 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
21:13:43 <edwardk> dolio: here let me put up a version of all the cruft we talked about. i was writing it up for a blog post anyways ;)
21:14:18 <edwardk> http://comonad.com/haskell/Chronomorphism.hs
21:14:52 <edwardk> futu in there is the version you want, also in there is a more efficient g_hylo
21:15:32 <edwardk> i observed that upon inlining the hylomorphism you get three fmaps over the same thing in a row. so you get a nice kernel to it
21:22:06 <dolio> On another note, you think I should rename Strf to Cofree?
21:22:19 <edwardk> personally yeah
21:22:45 <edwardk> the cofree comonad has a lot more said about it than the 'branching stream comonad'
21:24:50 * bos read that as "coffee comonad", and thought edwardk was making a joke about drinking coffee compared with its dual.
21:25:00 <edwardk> =)
21:25:20 <edwardk> i keep meaning to write up a blog post titled 'Anyone care for cofree?' ;)
21:29:50 <dolio> Your futu looks like what I came up with.
21:30:18 <edwardk> dolio: yeah its pretty straightforward
21:30:33 <edwardk> g_futu doesn't appear to exist in literature
21:30:48 <edwardk> and the chronomorphism stuff there works really nicely
21:32:25 <dolio> Yeah. The types wouldn't let me write anything incorrect. :)
21:32:34 <edwardk> heh
21:32:55 <edwardk> dolio: make sure to take this version of g_hylo too
21:33:16 <edwardk> the other one does 3 times as much work unless it gets fused across function call boundaries
21:34:55 <dolio> Heh, all right.
21:35:08 <dolio> I got a paper on dynamorphisms, too, so I'll look at that.
21:35:28 <edwardk> yeah i was going to write them in here but you got me before i'd finished writing the code to support my blog post ;)
21:36:22 <edwardk> they dualize as well, instead of guessing an algebra to go along with the coalgebra of a histomorphism you guess a coalgebra to go along with the algebra of a futumorphism
21:36:35 <edwardk> no idea what to call a 'co-dynamorphism' though
21:37:35 <edwardk> i'm sure once i get it all laid out in a language with types its use will jump out at me, but it didn't when i typed it up without them
21:44:14 <noohgodno> let's talk about how much python sucks
21:44:17 <noohgodno> PYTHON SUCKS
21:47:40 <zeno_> besides being slow whys it suck :?)
21:49:30 <noohgodno> the slowness
21:49:34 <noohgodno> mostly
21:49:41 <noohgodno> it bothers all my instincts as a programmer
21:50:00 <noohgodno> i don't mind freely importing modules and whatnot but
21:50:05 <noohgodno> using preset ones?
21:50:07 <dolio> Too many underscores.
21:50:12 <noohgodno> that too, and the tabs
21:50:17 <noohgodno> blocking
21:50:46 <Cale> If the convention were to use spaces, I'd probably like that better. :)
21:50:52 <minivan> python bash is so 2006, we should be bashing Ruby.
21:51:03 <solrize> lol
21:51:07 <noohgodno> let's just make fun of basic, that never gets old
21:51:15 <noohgodno> GOTO?? WTF?
21:51:18 <noohgodno> LOL.
21:51:28 * noohgodno does a handstand on the balcony
21:51:33 <noohgodno> no, it's ok, i do this all the time
21:51:37 * noohgodno falls
21:52:28 <newsham> # bas
21:52:28 <newsham> print "BASIC"
21:52:28 <newsham> BASIC
21:52:37 <noohgodno> # bas
21:52:41 <noohgodno> =-o
21:55:49 <newsham> http://unix-tree.huihoo.org/V4/usr/man/man1/bas.1.html
21:55:53 <lambdabot> Title: V4/usr/man/man1/bas.1
21:56:47 <noohgodno> what is this?
21:57:16 <newsham> man page for "bas"
21:58:18 <noohgodno> yikes
21:58:49 <noohgodno> it's like the blair witch project
21:59:12 <dolio> edwardk: You think all the primed functions in your file are worth having available generally?
21:59:47 <jaredj> exact floating point numbers. what are they called?
22:00:04 <SamB> jaredj: too big?
22:00:05 <jaredj> more to the point is there a type for money?
22:00:28 <SamB> > 3/4 :: Decimal 2
22:00:28 <lambdabot>  Parse error at "2" (column 16)
22:00:32 <jaredj> (i thought there was a module with exact numbers. maybe that was just rational ones)
22:00:34 <SamB> > 3/4 :: Dec 2
22:00:35 <lambdabot>  Parse error at "2" (column 12)
22:00:39 <SamB> @hoogle decimal
22:00:39 <lambdabot> Text.ParserCombinators.Parsec.Token.decimal :: TokenParser st -> CharParser st Integer
22:00:39 <lambdabot> Data.Char.DecimalNumber :: GeneralCategory
22:00:39 <lambdabot> Text.ParserCombinators.Parsec.Token.hexadecimal :: TokenParser st -> CharParser st Integer
22:01:01 <SamB> jaredj: there is a module with decimal numbers
22:01:03 <SamB> do you want that?
22:01:28 <edwardk> dolio: not sure, i wrote them in because i wanted them for purposes of my post, pointing out the fact that the 'kernels' are interesting in their own right because they let you do things like inspect 'how you got there' or work over an arbitrary monad rather than just the result of return, etc.
22:01:29 <newsham> > let money x = { let (d,c) = x `divMod` 100 in "$" ++ show d ++ "." ++ show c } in money 1056
22:01:29 <lambdabot>  Parse error at "{" (column 15)
22:01:40 <jaredj> SamB: likely. thanks a heap :)
22:01:46 <newsham> > let money x = (let (d,c) = x `divMod` 100 in "$" ++ show d ++ "." ++ show c) in money 1056
22:01:46 <edwardk> dolio: i suppose they wouldn't hurt
22:01:49 <lambdabot>  "$10.56"
22:02:50 <SamB> jaredj: the "Decimal" package on cabal
22:02:54 <SamB> er. hackage.
22:04:24 <jaredj> "...This is a useful property when doing financial arithmetic."
22:05:20 <jaredj> ! - not in apt
22:07:01 <OceanSpray> pretty much everybody here already wrote his own raytracer, right?
22:07:10 <newsham> not I
22:07:11 * jaredj didn't
22:07:24 * jaredj is a yellow belt
22:07:33 <jeffz> i was going to try a raycaster
22:12:35 <OceanSpray> well, damn
22:13:11 <OceanSpray> I'm getting some very strange images, and I suspect that there's something wrong with my algorithm.
22:16:05 <OceanSpray> also, hi johnnowak
22:16:17 <johnnowak> lo OceanSpray
22:40:28 <jaredj> http://hpaste.org/7179
22:40:42 <jaredj> i have a date written like 20080130160000
22:40:59 <jaredj> i'm trying to parse it with parsec
22:41:17 <jaredj> naming each part of the date is annoying because there are six parts (y, m, d, h, m, s)
22:41:41 <jaredj> i can sequence the parsers with... mapM, i reckon
22:42:10 <jaredj> but CalendarTime is one of those types with named members
22:42:32 <jaredj> (ctYear, ctMonth, etc)
22:52:27 <jaredj> forget that question. here's another one: in Python I can say xs = [1,2,3]; f(*xs) and f will get three arguments. is this possible in haskell?
22:52:44 <jaredj> > let {apply f [] = f; apply f (x:xs) = (f x) xs} in apply (+) [1,2]
22:52:46 <lambdabot>      Occurs check: cannot construct the infinite type: t = t1 -> t2 -> t
22:52:46 <lambdabot>     ...
22:53:51 <bd_> jaredj: apply is not possible in Haskell's type system. You'd have to create MagicCouldBeAnyFunctionWhatsoever -> [AnyTypeWhatsoever] -> SomeReturnTypeWhoKnows, which is not really possible because all those types (unless you use crazy Dynamic hacks or something) need to be fixed
22:53:56 <bd_> but!
22:53:58 <bd_> you can use currying to acheive something similar
22:54:15 <bd_> > let sumTwoLists = zipWith (+) ; sumTwoLists [1..3] [10..30]
22:54:16 <lambdabot>  Parse error at end of input
22:54:20 <bd_> > let sumTwoLists = zipWith (+) in sumTwoLists [1..3] [10..30]
22:54:22 <lambdabot>  [11,13,15]
22:54:28 <edwardk> jaredj not easily. there is some trickery you can do for variadic functions though
22:54:37 <bd_> granted, that function I made was named rather poorly, but it shows the idea
22:54:57 <jaredj> :i CalendarTime
22:55:06 <jaredj> > :i CalendarTime
22:55:07 <lambdabot>   parse error on input `:'
22:55:10 <jaredj> bleh
22:55:16 <bd_> jaredj: lambdabot doesn't do :i :)
22:55:20 <jaredj> anyway CalendarTime has a lot of arguments, and i have the first six in a list
22:55:22 <bd_> [it's often too long for IRC pasting anyway]
22:55:24 <jaredj> and i don't want to name them
22:55:34 <bd_> what module is it in?
22:55:36 <jaredj> heheh that was the point this time
22:55:42 <bd_> @hoogle CalendarTime
22:55:43 <lambdabot> System.Time.CalendarTime :: data CalendarTime
22:55:43 <lambdabot> System.Time.CalendarTime :: Int -> Month -> Int -> Int -> Int -> Int -> Integer -> Day -> Int -> String -> Int -> Bool -> CalendarTime
22:55:43 <lambdabot> System.Time.calendarTimeToString :: CalendarTime -> String
22:55:43 <jaredj> Time
22:56:06 <edwardk> jaredj: they aren't all the same type though
22:56:20 <bd_> yeah, you can't put different types in the same list
22:56:25 <jaredj> treu. Month isn't bad though, it's an Enum
22:56:38 <jaredj> and I don't care about any of the last ... six
22:57:30 <jaredj> beh, i can just
22:57:37 <jaredj> >  let (y:m:d:h:min:s:[]) = [1,2,3,4,5,6]
22:57:38 <lambdabot>  Parse error at end of input
22:57:38 <edwardk> calendarTimeFromList [a,b,c,d,e,f] = CalendarTime a (toEnum b) c d e f
22:58:09 <bd_> It's theoretically possibly to introspect with Dynamic's dynApply - but, that's not worth it (and kills much of the static validation haskell gives you)
22:58:10 <edwardk> then call calendarTimeFromList yourList your remaining arguments =P
22:58:17 <jaredj> yes. not worth it
22:58:36 <edwardk> i don't know that you have a cleaner way
22:58:41 <bd_> jaredj: I would just write a wrapper, naming the arguments you care about (the rest will be set to undefined)
22:59:06 <bd_> so, calendarTimeFromList [a,b,c,d,e,f] = CalendarTime { ctYear = a, ctMonth = toEnum b, ... }
23:02:39 <jaredj> OFX.hs:25:44:
23:02:39 <jaredj>     Warning: Fields of `CalendarTime' not initialised: ctPicosec,
23:02:39 <jaredj>                                                        ctWDay, ctYDay, ctTZName, ctTZ, ctIsDST
23:02:42 <jaredj> :P
23:03:45 <jaredj> bagh!
23:04:57 <jaredj> i don't think Time is meant for constructing arbitrary times so much as telling me nicely what weekday it is right now
23:05:10 <bd_> jaredj: ignore the warning :P
23:06:38 <bd_> but yeah, Time is modelled on the C gmtime API, which is not particularly nice for haskell use
23:06:50 <jaredj> ah - i should be using Data.Time.Format
23:08:09 <jaredj> actually since this is going in an sqlite database and i'll only ever compare complete date+time values, i shouldn't parse it into a date at all...
23:08:15 <jaredj> -_-
23:16:32 <ChaoticMind|afk> hey... why does this not work?
23:16:33 <ChaoticMind|afk> computeParity x
23:16:33 <ChaoticMind|afk>  | (mod (sum x) 2) == 1 = x++1
23:16:33 <ChaoticMind|afk>  | otherwise = x++0
23:18:32 <jaredj> are you passing it a list?
23:19:01 <ChaoticMind|afk> yes
23:19:08 <ChaoticMind|afk> but it gives me an error
23:19:16 <ChaoticMind|afk> before i pass it anything
23:19:31 <ChaoticMind|afk> "cannot infer instance"
23:20:03 <jaredj> ah - you want x ++ [1] and x ++ [0]. ++ concatenates lists, and needs two lists as params
23:20:10 <aleator> ChaoticMind: x++[1]
23:20:20 <ChaoticMind> omg.. yeah :)
23:20:28 <ChaoticMind> thanks :$
23:20:44 <jaredj> np
23:28:02 <johnnowak> does anyone have good examples for functions that require impredicativity?
23:29:21 <dolio> I was doing something that needed that a couple days ago. What was it...
23:30:41 <johnnowak> hmm...
23:31:12 <dolio> Oh yeah, I was trying to define 'natEq :: Nat m -> Nat n -> Bool' using inductive eliminators as much as possible, instead of pattern matching.
23:32:10 <dolio> And what I came up with used 'newtype Const a b = Const a', but instantiated at 'Const (forall m. Nat m -> Const Bool m) n'.
23:33:56 <johnnowak> ah
23:47:07 <Koobs> I think I'm doing more typing than is necessary.  Can someone take a look at my code (only 8 lines) and give me some style advice?
23:48:18 <Koobs> http://hpaste.org/7180#a0
23:49:45 <Koobs> Is there anyway to reduce the amount of code needed to make the instance of show?
23:49:47 <solrize> you show all 3 the same way?
23:49:58 <Koobs> Yes.
23:50:08 <Koobs> I should mention that I'm new at this.
23:50:09 <solrize> show (String a b) = show3 a b
23:50:16 <solrize> where you write show3 to take two string args
23:50:23 <solrize> and use it in the other two methods
23:50:42 <solrize> you're maybe also asking how to combine the 3 cases and i don't know if there's a way to do that
23:51:17 <Koobs> Yes, I would like to combine them, but you're suggestion would clean it up some.
23:52:09 <sjanssen> Koobs: I would recommend that you not override the Show instance at all
23:52:11 <solrize> i think in that example, you're not really using the gadt capabilities
23:52:19 <sjanssen> also, I'd recommend that you'd use standard data type syntax
23:52:28 <solrize> so you could just use standard syntax and "deriving Show"
23:53:15 <solrize> with gadt syntax from what i can tell, you don't get Show by default and you can't derive it
23:53:32 <solrize> so you have to supply your own implementation like you did
23:53:33 <Koobs> I'm using the gadt to create a heterogenous list and pattern match the elements.
23:53:46 <Koobs> That's right.  No deriving.
23:54:32 <sjanssen> Koobs: but you're not actually using a *G*ADT
23:54:44 <sjanssen> you're using GADT syntax to create a standard ADT
23:55:15 <solrize> data Attribute = String String String | Number String Number | Bool String Bool
23:56:06 <sjanssen>     deriving SHow
23:56:44 <solrize> yeah :)
23:56:56 <Koobs> Yeah, that'll work, I think.
23:57:42 <Koobs> Now, another issue.  I've defined Number as "type Number = forall a. (Ord a, Num a) => a"
23:57:57 <Koobs> Is that the wrong thing to do in this case?
23:58:10 <solrize> can you doooooooo that????
23:58:17 <Koobs> Apparently.
23:58:40 <sjanssen> Koobs: you probably don't want to do that
23:58:43 <Koobs> The code works, it's just longer than I'd like.
23:58:54 <sjanssen> Koobs: do you really need for Attribute to cointain all types of numbers?
23:59:37 <Koobs> What should I do instead?  I wan't floats and ints to both be considered the same type in my list.
23:59:58 <edwardk> Koobs: data Attribute = Float Float | Int Int
