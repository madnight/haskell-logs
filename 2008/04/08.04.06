00:06:15 <bd_> hmm
00:06:21 <bd_> there's no IsString instance for ByteString?
00:09:33 <dons> there is, in Data.ByteString.Char8
00:13:18 <bd_> hm, I have it imported (import qualified Data.ByteString.Char8)...
00:13:32 <bd_> but I still get: No instance for (IsString ByteString)
00:13:45 <bd_> GHC 6.8.2
00:17:37 <hpaste>  bd_ pasted "No IsString instance for ByteString?" at http://hpaste.org/6863
00:20:00 <dons> maybe you've an older bytestring version
00:20:05 <dons> you need 0.9.0.4 or later
00:20:36 <bd_> hm, I'm just using the ubuntu packages
00:20:43 <bd_> ah well, not worth fixing it for one string literal :)
00:21:14 <dons> ah, ubuntu would have the one shipped with ghc, which is the older one
00:22:32 * ddarius considers mapping -areas- of his keyboard to the same xmonad action.
00:23:23 <Twey> Haha
00:23:31 <Twey> For the 'smack it and pray' approach?
00:24:03 <dons> ddarius: that's wacky fun
00:24:13 <dons> smash and mash interfaces
00:24:18 <ddarius> Twey: Currently, it's more like the 'smack it and pray' approach.  If I mapped areas, then if I "miss" I'll still get what I want.
00:24:30 <Twey> True that.
00:28:40 * ddarius notices "Reimplement MTL using CPS also use Associated type synonyms/type families to lead to auto-flatten monad transformer stacks" in his ideas file.
00:31:46 <alc> bd_, isnt that caused by type mismatch?
00:31:55 <bd_> alc: hm?
00:32:04 <alc> bd_, ie. (BS.pack "test")
00:32:40 <bd_> alc: New versions of GHC have an OverloadedStrings extension, where "test" has type IsString a => a
00:33:00 <alc> i see
00:33:27 <bd_> problem is the only instance in the base is IsString String, IsString ByteString etc didn't make it in apparently
00:34:03 <alc> got it
00:34:06 <alc> are you using hardy?
00:34:15 <bd_> yeah
00:35:46 <alc> gutsy package is still 6.6
00:43:38 <povman> hihi
00:44:26 <povman> does anyone know if there's a conditional function in ghc standard libraries? eg f t a b = if t then a else b
00:45:08 <vincenz> povman: I don't think so
00:45:17 <vincenz> @hoogle Boolean -> a -> a -> a
00:45:18 <lambdabot> No matches, try a more general search
00:45:21 <vincenz> @hoogle Bool -> a -> a -> a
00:45:22 <lambdabot> No matches, try a more general search
00:45:32 <sjanssen> povman: no
00:45:41 <araujo> @pl (\ a -> if a then x else y)
00:45:41 <lambdabot> flip (flip if' x) y
00:45:54 <araujo> if' ... is ... your own if function
00:45:56 <araujo> :-P
00:46:14 <sjanssen> hmm, can we come up with a pointfree defn. of if' that only uses prelude functions?
00:46:36 <sjanssen> @pl \b x y -> [x, y] !! fromEnum b
00:46:36 <lambdabot> flip (flip . ((!!) .) . (. return) . (:)) . fromEnum
00:46:41 <sjanssen> can we do better?
00:47:01 <vincenz> I had something like that
00:47:42 <vincenz> hmm, not prelude only
00:47:58 <vincenz> but here is the syntax
00:48:00 <sjanssen> vincenz: oh?
00:48:02 <vincenz> main = print $ False ? 1 =: True ? 3 =: 4
00:48:14 <vincenz> a ? b = if a then Just b else Nothing
00:48:20 <sjanssen> definitely cheating
00:48:21 <vincenz> (Just x) =: y = x
00:48:21 <vincenz> Nothing  =: y = y
00:48:38 <vincenz> it's based on the ternary operator in other languages.
00:49:04 <sjanssen> but all of your functions aren't in the Prelude :)
00:49:10 <vincenz> They should be!
00:49:30 <povman> i concur
00:49:31 <vincenz> :t maybe
00:49:33 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
00:49:38 <sjanssen> vincenz: oh, =: is fromMaybe
00:49:38 <vincenz> the =: is basically
00:49:44 <vincenz> :t fromMaybe
00:49:45 <lambdabot> forall a. a -> Maybe a -> a
00:49:51 <vincenz> flip fromMaybe :)
00:50:21 <sjanssen> @pl \b x y -> fromMaybe y (guard b >> return x)
00:50:21 <lambdabot> (flip fromMaybe .) . (. return) . (>>) . guard
00:50:33 <sjanssen> with Data.Maybe and Control.Monad
00:51:59 <sjanssen> @pl \b x y -> fromJust $ lookup b [(True, x), (False, y)]
00:51:59 <lambdabot> ((fromJust .) .) . (. ((. (return . (,) False)) . (:) . (,) True)) . (.) . lookup
00:52:12 <idnar> ouch
00:52:31 <povman> what's @pl?
00:52:31 <idnar> :t fromJust
00:52:32 <lambdabot> forall a. Maybe a -> a
00:52:45 <idnar> povman: "pointless"; it generates "point-free" code
00:52:54 <povman> ah
00:53:15 <sjanssen> @pl \b x y -> head ([x | b] ++ [y])
00:53:16 <lambdabot> ((head .) .) . flip flip return . (((.) . (++)) .) . flip flip [] . ((:) .) . flip (|)
00:53:28 <idnar> @pl add a b = a + b
00:53:29 <lambdabot> add = (+)
00:53:45 <povman> actually, it'd be nice to have if' t a b = \x -> if t x then a x else b x
00:53:57 <vincenz> I still win \o/
00:54:09 <povman> @pl if' t a b = \x -> if t x then a x else b x
00:54:09 <lambdabot> if' = fix ((((ap .) . ap) .) . (.))
00:54:23 <vincenz> o.O
00:54:25 <sjanssen> vincenz: no, you cheated
00:54:36 <idnar> @type mapM
00:54:37 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
00:54:40 <idnar> @type mapM_
00:54:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
00:55:14 <povman> :t ap
00:55:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
00:57:31 <ddarius> @pl g t a b = \x -> g (t x) (a x) (b x)
00:57:31 <lambdabot> g = fix ((((ap .) . ap) .) . (.))
00:57:35 <sjanssen> @pl \b x y -> maybe y id (do True <- b; Just x)
00:57:35 <lambdabot> (line 1, column 35):
00:57:35 <lambdabot> unexpected ";"
00:57:35 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or ")"
00:57:47 <sjanssen> that should work, and it's Prelude only :)
00:58:48 <ddarius> @pl f id = id
00:58:48 <lambdabot> f = id
00:59:11 <vincenz> @pl foo t a b = \x -> if t x then a x else b x
00:59:11 <lambdabot> foo = (ap .) . liftM2 if'
00:59:14 <vincenz> woo
00:59:16 <vincenz> bug in @pl
00:59:26 <vincenz> Improper scoping
00:59:34 <vincenz> 09:54 < povman> @pl if' t a b = \x -> if t x then a x else b x
00:59:34 <vincenz> 09:54 < lambdabot> if' = fix ((((ap .) . ap) .) . (.))
00:59:41 <ddarius>  @pl has never been particularly keen on alpha renaming.
00:59:45 <vincenz> it must have replaced the 'if' by 'if''
00:59:58 <povman> ohh
01:00:06 <sjanssen> vincenz: @pl is chock full of bugs
01:00:06 <povman> :t if'
01:00:08 <lambdabot> Not in scope: `if''
01:00:10 <vincenz> povman++
01:00:29 <sjanssen> @pl f ()
01:00:29 <lambdabot> f ()
01:00:31 <povman> => 2
01:00:36 <sjanssen> ooh, that's been fixed!
01:00:44 * vincenz thinks if' should be in the prelude
01:01:10 <sjanssen> vincenz: actually, I'd prefer 'bool'
01:01:35 <sjanssen> bool f t b = if b then t else f
01:01:53 <vincenz> sjanssen: well sure :)
01:01:58 <sjanssen> which matches maybe, either, all the other paramorphisms in the Prelude
01:02:10 <vincenz> As long as the definition is in there :)
01:02:36 <povman> why not
01:02:50 <povman> bool f t b x = if b x then t x else f x
01:03:11 <povman> then you can do filtering on the argument and actually keep using it
01:03:15 <sjanssen> povman: that doesn't match how the other functions work
01:03:21 <sjanssen> @type either
01:03:22 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
01:03:22 <sjanssen> @type maybe
01:03:23 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
01:03:25 <sjanssen> @type foldr
01:03:26 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
01:03:37 <vincenz> erm
01:03:38 <ddarius> @pl \b t e -> [t,e] !! fromEnum b
01:03:38 <lambdabot> flip (flip . ((!!) .) . (. return) . (:)) . fromEnum
01:03:55 <ddarius> @pl \t e b -> [t,e] !! fromEnum b
01:03:55 <lambdabot> flip flip fromEnum . (((.) . (!!)) .) . (. return) . (:)
01:04:31 <povman> :t flip
01:04:32 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
01:05:40 <ddarius> :t uncurry . ([fst,snd] !!) . fromEnum
01:05:41 <lambdabot> forall b c a. (Enum a) => a -> ((b -> c, b -> c), b) -> c
01:05:47 <ttt--> :t flip flip
01:05:48 <povman> sjanssen: Bool doesn't have a value though
01:05:49 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
01:05:56 <vincenz> povman: Bool has two values
01:05:57 <ddarius> :t curry . ([fst,snd] !!) . fromEnum
01:05:58 <lambdabot> forall b a. (Enum a) => a -> b -> b -> b
01:06:02 <vincenz> povman: hence it should use two constants
01:06:03 <ttt--> :t flip . flip
01:06:04 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
01:06:06 <povman> er, it's not a container
01:06:14 <vincenz> povman: it's a trivial one :)
01:06:20 <vincenz> with 0 elements
01:06:24 <povman> ...
01:06:26 <sjanssen> povman: see what is done with the constructors containing nothing in [] and Maybe
01:06:31 <sjanssen> vincenz, povman: exactly
01:06:42 <povman> so it'd be hard to do something useful with bool
01:06:57 <ddarius> povman: bool is just if (with permuted arguments)
01:06:58 <sjanssen> povman: why?  You can use it everywhere you use if now
01:07:04 <vincenz> povman: the transformation from a datatype to a xxx-morphism is very straightforward
01:07:13 <vincenz> povman: a function for each data-constructor with the proper number of arguments
01:07:14 <ddarius> cata-
01:07:17 <vincenz> in thise case, 2 functions with 0 arguments
01:07:25 <vincenz> ddarius: thanks, I thought so, but sjanssen said 'para' earlier.
01:07:42 <sjanssen> vincenz: sorry, mistake
01:07:44 <ddarius> vincenz: It's both in the case of bool.
01:08:16 <povman> @pl if isAlpha then (chr.(+ ord 'a').(`mod` 26).(flip (-) (ord 'a')).(+2).ord) else id
01:08:17 <lambdabot> if' isAlpha (chr . (ord 'a' +) . (`mod` 26) . subtract (ord 'a') . (2 +) . ord) id
01:08:17 <ddarius> Well perhaps not, but the difference is trivial.
01:08:47 <povman> er..
01:08:48 <povman> @pl (\a -> if isAlpha a then (chr.(+ ord 'a').(`mod` 26).(flip (-) (ord 'a')).(+2).ord) a else id a)
01:08:48 <lambdabot> join (liftM2 if' isAlpha (chr . (ord 'a' +) . (`mod` 26) . subtract (ord 'a') . (2 +) . ord))
01:09:54 <povman> not in this case :)
01:16:13 <povman> @hoogle mix :: (b -> a -> t) -> (a -> b) -> a -> t
01:16:13 <lambdabot> hoogle: Hoogle.Parser.readType: ([mix,::,(,b,->,a,->,t,),->,(,a,->,b,),->,a,->,t],BItem ::)
01:16:13 <lambdabot>  
01:16:26 <povman> @hoogle (b -> a -> t) -> (a -> b) -> a -> t
01:16:26 <lambdabot> No matches, try a more general search
01:16:33 <povman> need that combinator as well
01:17:14 <povman> :t (.)
01:17:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:17:34 <Torment> @pl f g a -> f (g a) a
01:17:34 <lambdabot> (line 1, column 7):
01:17:34 <lambdabot> unexpected ">" or "-"
01:17:34 <lambdabot> expecting variable, "(", operator or end of input
01:17:35 <povman> :t mix to from arg = (to . from) arg arg
01:17:36 <lambdabot> parse error on input `='
01:17:42 <Torment> @pl \f g a -> f (g a) a
01:17:42 <lambdabot> flip flip id . liftM2
01:17:43 <wagle> could someone do me a favor and type in a e with an umlaut over it..  i lack an inputter for it
01:17:51 <Torment> Ã«
01:17:55 <povman> Ã¦
01:18:02 <Torment> Not really an umlaut though
01:18:09 <povman> Ã«
01:18:36 <Jedai> It's a trema, I don't know if unicode make the difference ??
01:18:38 <wagle> thanks
01:20:10 <wagle> Jedai, what is it?
01:20:32 <wagle> oh..  nm
01:23:34 <povman> Jedai: liftM2 isn't in the prelude
01:24:27 <povman> :t liftM2
01:24:27 <Jedai> povman: There's not that much combinators in the Prelude anyway.
01:24:28 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
01:25:21 <Jedai> :t flip flip
01:25:22 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
01:33:03 <ziman> :t on
01:33:04 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
01:52:28 <AndreWe> @index on
01:52:28 <lambdabot> bzzt
01:54:04 <vincenz> Data.Function
01:54:24 <povman> @hoogle b -> b -> c
01:54:25 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
01:54:25 <lambdabot> Data.Function.flip :: (a -> b -> c) -> b -> a -> c
01:54:25 <lambdabot> Prelude.curry :: ((a, b) -> c) -> a -> b -> c
02:07:54 <Jedai> povman: b -> b -> c has only one inhabitant : undefined
02:10:10 <povman> :t on
02:10:12 <povman> though
02:10:14 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
02:11:15 <Jedai> povman: Yes and ? a -> b is undefined though (a -> b) -> a -> a isn't
02:11:45 <Jedai> povman: (b -> b -> c) -> (a -> b) -> a -> a -> c is perfectly provable and inhabited
02:12:23 <pants1> is there an efficient way to take an unsorted list of elements at return grouped list of elements and there count? Right now I do strcntpr str = (map (\l -> (head l, length l))(group (sort str ))) but its kind of slow on large inputs
02:12:31 <povman> because it doesn't depend on there actually being a value of type a->b
02:12:32 <povman> ?
02:13:12 <Jedai> pants1: Use Map and fromListWith
02:13:52 <MarcWeber> Is there kind of ThisModule.identifier syntax? Or do I have to use <ThisModuleName>.identifier ?
02:14:33 <MarcWeber> The first one will also work when renaming the module.. (can be accomplished using cpp and one define as well)
02:14:42 <Jedai> povman: When you give a function to on, it doesn't have b -> b -> c as a type, it is a special instanciation of b and c, but to write a function of type T (other than unidentified), this type must be inhabited
02:15:04 <Jedai> povman: b -> b -> c isn't
02:15:47 <povman> right.
02:16:01 <Jedai> povman: You can't write a function that takes 2 argument of one type without knowing anything about this type and return an argument of one other arbitrary type
02:16:34 <MarcWeber> pants1: Map groupByKey (Set elem)
02:16:44 <povman> yeah
02:17:49 <pants1> MarcWeber: groupbykey is provided by data.map?
02:18:24 <MarcWeber> no.. you should read it as type annotation. Thus groupByKey is meant to be a type (probably the on of your list..)
02:18:45 <pants1> oks
02:19:00 <Jedai> :t Data.Map.fromListWith
02:19:01 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> M.Map k a
02:20:24 <MarcWeber> > Data.Map.fromListWith (Data.Set.union) $ [ (even i,Data.Set.singleton i) | i <- [1,20] ]
02:20:25 <lambdabot>   Not in scope: `Data.Set.singleton'
02:20:49 <MarcWeber> @ pants1
02:21:44 <pants1> hmms
02:21:57 <Jedai> For his objective, I think : "toList . fromListWith (+) . (flip (,) 1)" is better
02:22:37 <MarcWeber> pants1: Have you used Data.Map and Data.Set before ?
02:22:43 <Jedai> > Data.Map.toList . Data.Map.fromListWith (+) . map (flip (,) 1) $  [1..5] ++ [3..7]
02:22:43 <lambdabot>   Not in scope: `Data.Map.fromListWith'
02:22:59 <pants1> nope. I guess I have some reading to do :)
02:23:38 <MarcWeber> pants1: Map is just a lookup thing: associate keys with values. The value is a list / or Data.Set Propably a list is sufficient. Data.Set makes sense if you want to remove items again.
02:24:10 <Jedai> MarcWeber: He just want to count how many identics item he have, it seems
02:24:14 <MarcWeber> pants1:  Data.Map.fromListWith (++) $ [ (even i, [i]) | i <- [1..20] ] is sufficient for you :)
02:24:24 <MarcWeber> Jedai: And return them.
02:24:28 <pants1> awesome sauce
02:24:39 <pants1> thanks :)
02:25:05 <Jedai> MarcWeber: Well my function does that ? Doesn't it ? Though it don't generalize neatly to groupBy
02:27:40 <MarcWeber> Jedai Sorry. Of course it does. Depends on wether the group by type is the same as the list type. Of course your version is sufficent if the type is the same. If you start using Rec Int String and want to group by Int..
02:27:51 <MarcWeber> But pants1 did not ask for that.
02:28:49 <Jedai> MarcWeber: He did, my function is a drop-in replacement for his, except it's much faster
02:29:30 <Jedai> His function was : strcntpr str = (map (\l -> (head l, length l))(group (sort str )))
02:31:03 <Peaker> Hi, I have these types: http://hpaste.org/6865   and I get the feeling that instead of an ugly action container, I could use class/instance relationships, but I am having a hard time figuring out how to convert it to be that way
02:31:31 <Jedai> But your proposition is much more general (I remember reading a blog on a generalization of this idea, the functions were pretty nice)
02:32:06 <Peaker> If I make IntGUI a newtype, and GUI a class, and IntGUI an instance of GUI it could work, but then I have a hard time with the parametrized type within the GUI
02:32:43 <Peaker> (also, those actions don't really need the GUI as an argument, so I am not sure how to have those actions as something in the class)
02:34:29 <MarcWeber> Jedai: I'm working on a typed table representation right now which you can use as replacement for HAppS-IxSet in the near future. And I do need exactly this there. That's why this generalized version came to my mind
02:34:32 <Peaker> I saw in Simon's 15-years-of-Haskell presentation that a:  (Num a) => a -> a   can be converted to  Num a -> a -> a,  and I think that IntGUI in my example is basically like the second, and I want to make it like the first
02:35:50 <Jedai> MarcWeber: That's nice, I really ought to look a little bit into HAppS when I have the time :-)
02:37:47 <Peaker> can classes be parameterized on types?
02:38:52 <Peaker> class GUI gui where guiInitView :: gui -> view  -- I want 'view' to be a parameter of the GUI class
02:40:40 <Jedai> Peaker: You're probably entering functional dependancies (or type families) territory
02:41:15 <Peaker> Well, I am just trying to get rid of a type that contains a bunch of actions, and replace it with compile-time type-system information
02:41:38 <Peaker> the choice of which draw/handleEvents function can be made at compile-time, no need for runtime actions to be held
02:42:37 <MarcWeber> Peaker: Not sure what you are asking about.. of course you can just use class Classname typ1 type2 where f :: type1 -> type2
02:42:38 <Jedai> Peaker: But the view could differ from one Gui to the next even if they're the same type, no ?
02:43:30 <Peaker> Jedai, The type here: IntGUI specifies an exact GUI (I could later have IntSliderGui and IntTextGui
02:43:52 <Peaker> MarcWeber, ah, that seems to be what I want, thanks
02:44:04 <Jedai> Peaker: Yes, but view could change from one IntGUI to another, no ?
02:44:34 <Peaker> Jedai, its just the initial view, the view changes in the monad of the draw/handleEvents actions
02:44:47 <MarcWeber> Peaker Maybe you should konw about fundeps  as well. Then you can tell the compiler that gui is determined by view or vice versa or both. Then you don't need that much type annotations if this is what you want
02:44:48 <Peaker> (guiInitView returns the initial value to initialize the monad with)
02:45:51 <Jedai> class Gui gui view | gui -> view where ...
02:45:59 <Peaker> MarcWeber, I want to have:  myGui = intEditor (informationAboutMyInt) ; main = execute myGui -- so myGui can either "contain" the actions associated with its execution, or be associated with them via the type system, I am trying to convert from first to latter
02:46:15 <Peaker> Jedai, Does that need any "-f" options?
02:47:24 <Jedai> Peaker: The initial view could change between member of the same type, coudn't it ?
02:48:08 <Jedai> Peaker: That probably needs some options, but you're better off using LANGUAGE pragma
02:48:12 <Peaker> Jedai, that is possible to specify that way, that's why guiInitView does take a gui instance input, which can contain that information
02:49:11 <Jedai> Peaker: So, why can't you use Class Gui gui where ... ?
02:49:34 <Peaker> Jedai, Well, it requires me to take a gui argument in guiDrawer for example
02:49:49 <Peaker> Jedai, which doesn't need it because it lives in the monad that already has that information
02:50:28 <MarcWeber> Peaker: You want annotate myGui with some type so that you can make GHC infer actions base on the type of execute?
02:50:40 <MarcWeber> Peaker: Do you know about Phantom types?
02:50:47 <Peaker> MarcWeber, nope, I am new :)
02:51:19 <Peaker> this is how this lib is used:        myGui = MyGUI.intEditor someInteger ; main = MyGUI.execute myGui
02:51:57 <Peaker> I want this to remain the interface, but I want guiDrawer to not take unnecessary arguments and yet somehow find the correct implementation based on the executed GUI type
02:52:16 <Peaker> what are phantom types?
02:52:53 <vincenz> Peaker: types without values
02:53:00 <vincenz> well, that's poorly put
02:53:04 <vincenz> take for instance
02:53:07 <vincenz> data Foo a b = Foo a
02:53:08 <Jedai> Peaker: Since the gui type appears nowhere into guiDrawer, that appears to be quite impossible...
02:53:14 <vincenz> the 'b' is a phantom-type
02:53:14 <Peaker> I have a mainLoop action in which I have: ... (guiDrawer gui (envDisplay env)) ...  ; if that becomes (guiDrawer (envDisplay env)) -- how can ghc figure out which drawer to run? If it does take gui - its a redundant/unnecessary argument
02:53:30 <Peaker> ah I see
02:53:45 <vincenz> You can use this to lock things together typewise, and lock other things out.
02:53:54 <Peaker> Jedai, guiDrawer is a record getter inside GUI
02:53:58 <Peaker> Jedai, in my paste
02:54:01 <Peaker> http://hpaste.org/6865
02:54:04 <Jedai> Peaker: In your execute, you can get the Drawer from the Gui (into a local variable) and then use it
02:54:34 <Jedai> Peaker: Without unnecessary parameter, thanks to the currying
02:54:41 <Peaker> Jedai, Yeah, but its not that i am worried about passing the argument, I am worried about storing a runtime function when it could be associated in compile time
02:55:51 <Jedai> Peaker: You can put the getDrawer into a typeclass if you prefer (so it can't be modified at runtime)
02:56:07 <Peaker> Jedai, yeah, that's what I'm trying to do, unsuccessfully
02:56:33 <Jedai> Peaker: The getDrawer would have type : gui -> Drawer
02:56:53 <Jedai> Peaker: But at least you insure that the drawer of a gui can't change at runtime
02:57:36 <Peaker> its what I'm trying to do - in which case guiDrawer still takes an unnecessary argument, but that argument does not contain unnecessary stuff
02:58:50 <hpaste>  Peaker pasted "Here is how I tried" at http://hpaste.org/6866
02:59:34 <Peaker> but a call: (guiInitModel gui)  fails to compile because Could not deduce (GUI model1 gui) from the context (GUI model2 gui)
03:00:11 <Peaker> I think it does not like execute remaining in the dark about what kind of model it takes?
03:00:25 <hpaste>  Jedai annotated "How to classify?" with "Maybe ?" at http://hpaste.org/6865#a1
03:01:38 <Peaker> what does the  |gui->model   stuff do?
03:02:05 <Jedai> They say that the gui determine what the view and model are
03:02:30 <Peaker> but how do they?
03:02:32 <Jedai> the type of gui is sufficient to choose which instance to use in a particular call
03:02:35 <Peaker> how does the GUI say that?
03:02:44 <Peaker> s/say/determine
03:03:19 <Jedai> Well you must do : instance GUI IntGui Int MySDL.Color where ...
03:03:37 <Jedai> And now you can't do another instance for IntGui or it will protest
03:03:52 <Peaker> aha. Thanks!
03:04:48 <Jedai> There's another way to do that, with type families, but I don't know it. It's the future (maybe) so you'll do well to check how it works
03:05:11 <Peaker> type families? I thought parameterized types were type families
03:06:54 <Peaker> what is the name of the "|" clause in classes?
03:08:26 <Jedai> Peaker: That's functional dependancies
03:08:41 <laura85> hi ^^
03:09:02 <Peaker> Jedai, a functional dependency is specifically that?
03:09:16 <xerox> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#functional-dependencies
03:09:17 <lambdabot> Title: 8.6. Class and instances declarations, http://tinyurl.com/245leb
03:10:32 <laura85> i need to function to the given type: (((a->a) -> b) ->b). (\x -> x.x) is (((a->a)->a)->a) . any hints?
03:12:00 <RayNbow> hmm, LtU down?
03:12:55 <mapreduce> @djinn (((a -> a) -> b) -> b)
03:12:55 <lambdabot> f a = a (\ b -> b)
03:13:32 <vincenz> callcc?
03:14:19 <laura85> mapreduce, oh.. right. thanks ^^
03:14:50 <Jedai> laura85: There's an infinite family of such functions on the model that mapreduce just showed
03:15:10 <vincenz> laura85: Would you by any chance be located in Zurich?
03:15:41 <Peaker> xerox, thanks
03:16:41 <laura85> vincenz, yes
03:16:49 <vincenz> laura85: Great
03:17:02 <laura85> vincenz, why? ^^
03:17:04 <vincenz> laura85: I don't live there yet, but will be soon. I'm trying to start a Haskell User Group there.
03:17:18 <vincenz> laura85: http://oasis.yi.org/oasis/HUGZ
03:17:21 <lambdabot> Title: HUGZ - Oasis Wiki
03:18:14 <laura85> vincenz, cool. but you live in switzerland, right?
03:18:20 <vincenz> laura85: Not yet :)
03:18:39 <laura85> vincenz, in europe? ^^
03:18:42 * vincenz nods
03:18:54 <vincenz> I will be living in switzerland (Zurich) starting next month.
03:19:42 <profmakx> working at google, vincenz ;)
03:19:57 <vincenz> profmakx: yep
03:20:34 <ttt--> are you getting a free day a week to work on your own projects?
03:21:04 <vincenz> ttt--: Bit early to tell you that, no?  I don't work there yet o.O
03:21:23 <profmakx> hm. i already know quite a few people who work in zurich
03:21:23 <vincenz> Anywho, back to haskell
03:21:24 <mapreduce> I call that Saturday.
03:21:28 <profmakx> ;)
03:21:28 <vincenz> laura85: I saw the .ch, so I thought I'd ask.
03:21:41 <vincenz> profmakx: If they're haskellers, feel free to forward them to that page.
03:21:46 <laura85> vincenz, some think it means china ^^
03:21:48 * profmakx will be in switzerland next week. yay
03:22:56 <laura85> profmakx, also google?
03:23:34 <profmakx> laura85, no, just relaxing near gstaad. I just finished my diploma and will start my PhD in scotland afterwards
03:23:45 <EvilTerran> scotland!
03:23:54 * EvilTerran is scottish
03:25:02 <laura85> profmakx, congrats and enjoy your stay ^^
03:25:26 <profmakx> laura85, thx
03:26:15 <DaNGeRs> lol
03:26:28 <DaNGeRs> e ae galera tudo joia ?
03:26:39 <DaNGeRs> bomm dia a todos...
03:26:46 <ttt--> what's the PhD about?
03:31:34 <DaNGeRs> ola!!!
03:32:57 <vincenz> DaNGeRs: english :)
03:33:17 <vincenz> DaNGeRs: si quiere espanol, #haskell.es
03:33:24 <DaNGeRs> vincenz Portugues
03:33:52 <vincenz> ah, whoops :)
03:34:14 <DaNGeRs> vincenz kAOKAOSKaskASKoskAOSksóASKoa´skSKsp
03:34:37 <DaNGeRs> i am  from Brazil
03:45:38 <EvilTerran> @where ops
03:45:38 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
03:45:49 --- mode: ChanServ set +o Igloo
03:45:54 <EvilTerran> oh, he's gone
03:46:13 --- mode: Igloo set -o Igloo
03:46:30 * EvilTerran wandered in, saw an ad, did the obvious... dang colour codes confusing me
03:47:01 <nominolo> there were colors?
03:47:51 <EvilTerran> in his quit message. the url came up white (instead of the dark red for quit messages here), and was wrapped onto a newline for me, so i thought he'd said it
03:48:22 <oklofok> @die 1d2
03:48:23 <lambdabot> 1d2 => 2
03:49:39 <EvilTerran> sorry ops, i am not awake yet
03:52:56 <Jedai> @die 2d5
03:52:57 <lambdabot> 2d5 => 10
03:53:02 <Jedai> @die 2d5
03:53:03 <lambdabot> 2d5 => 8
03:54:37 <Olathe> @die 100000000000000d100000000000000
03:54:37 <lambdabot> 100000000000000d10000000000... => 5000000108225056645998927872
03:55:56 * vincenz wonders
04:02:03 * astrolabe wonders too
04:03:14 <profmakx> ttt--,  I dont really know yet ;) I think it will be about automatic semigroups or automatic groups
04:08:47 <laura85> Jedai?
04:20:19 <wagle> @die 1000000000d1000000000
04:20:19 <lambdabot> 1000000000d1000000000 => 500013629060148023
04:22:57 <Jaak> @dia 100000d3
04:22:57 <lambdabot> Maybe you meant: dice dict id
04:23:01 <Jaak> @die 100000d3
04:23:01 <lambdabot> 100000d3 => 199746
04:35:09 <forkiliens> hi everyone
04:35:58 <forkiliens> does somebody know any program in linux to find out what your own ipaddress is?
04:36:27 <ndm> ping <computername> does it in windows
04:36:39 <Olathe> forkiliens: ifconfig
04:37:26 <forkiliens> olathe: i found it out too, but what are the exactly parameters?
04:37:41 <mapreduce> ifconfig
04:37:48 <mapreduce> parameters as shown
04:37:53 <forkiliens> ok, but i'm behind a router
04:38:00 <forkiliens> i get the local address
04:38:05 <mapreduce> You might find whatismyipaddress.com useful.
04:38:21 <forkiliens> ok, i know already that such places exist,
04:38:38 <mapreduce> Your computer cannot know what IP address some router maps it to.
04:38:42 <forkiliens> but i was asking myself if i could do it with the help of a program.
04:38:50 <forkiliens> why?
04:39:03 <mapreduce> Yes.  wget whatismyipaddress.com | grep stuff
04:39:10 <mapreduce> or something.
04:39:53 <mapreduce> Imagine that when I talk to my friends, I call you Bob, so they send messages to Bob and I direct them to you, making it look like they were for forkiliens.
04:40:16 <mapreduce> How could you know that I do that without asking my friends?
04:41:11 <Olathe> Mind reading.
04:41:29 <forkiliens> ok, i think i get it... :)
04:41:30 <forkiliens> thanks
04:42:00 <vincenz> @remember mapreduce Imagine that when I talk to my friends, I call you Bob, ...
04:42:00 <lambdabot> Done.
04:42:44 <forkiliens> @where ifconfig
04:42:44 <lambdabot> I know nothing about ifconfig.
04:42:54 <forkiliens> @where monad
04:42:54 <lambdabot> I know nothing about monad.
04:43:01 <forkiliens> @where lambdabot
04:43:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
04:43:01 <Olathe> @where @where
04:43:01 <lambdabot> I know nothing about @where.
04:43:38 <Olathe> @where @where
04:43:38 <lambdabot>  @where @where
04:55:10 <vincenz> doserj: ping
04:59:21 <Jaak> ooh, mtl ported to take use of type families
04:59:58 <doserj> vincenz: pong
05:00:12 <vincenz> doserj: see pm
05:27:37 <povman> is there an infinite precision floating point library that isn't bigfloat?
05:28:31 <snhmib> hello
05:31:06 <povman> bigfloat isn't infinite precision
05:31:11 <povman> it goes up to 323
05:31:15 <povman> places
05:31:48 <Olathe> You could use rationals.
05:32:01 <povman> but i want piles of decimal places
05:32:39 <Olathe> It shouldn't be too hard to implement that with a few Integers.
05:33:06 <Olathe> Division might be a bit difficult.
05:33:12 <Olathe> I'm not sure about libraries.
05:34:04 <povman> mm ok tomorrow
05:34:05 <povman> :)
05:36:00 <vincenz> use rationals and calculate the decimal places on output?
05:37:58 <povman> i'm surprised it's not been done before
05:43:26 <unenough> povman, do you use povray?
05:43:39 <povman> no, pov stands for poverty
05:44:40 <unenough> oh :( :( :(
05:45:46 <povman> it's a nickname i acquired in highschool and it stuck
05:46:28 <unenough> was it justified?
05:48:07 <povman> the word 'pov' was used at our school as a lame insult, and one of my teachers used it on me :P
05:48:16 <povman> so, not in the way you were probably thinking
05:49:04 * Baughn will never understand humans
05:49:12 <vincenz> Baughn: You are one
05:49:19 <Baughn> vincenz: I know
05:49:30 <Baughn> If you just want to insult someone, and don't care whether it fits, why don't you just say "I insult you"?
05:49:41 <vincenz> Baughn: Doesn't hit as strongly emotionally
05:51:22 <povman> insulting is generally the use of words which people associate negative emotions to
05:51:46 <Baughn> ..you associate negative emotions to "pov"?
05:51:49 <povman> *intentional
05:52:21 <povman> i did say it was lame :P
05:54:36 <vincenz> Baughn: It's usually cultural and social, sort of lame to analyze it from the outside.
05:55:04 <vincenz> Just look at the progression of the term 'gay'
05:55:19 <Baughn> Around here, "gay" still means "happy"
05:56:31 <povman> Baughn: do people insult each other where you are?
05:57:04 <Baughn> povman: I live in northern norway, so.. yes. Horribly so. All the time.
05:57:07 <Baughn> In norwegian, though
05:58:31 <gwern> hm. this holumbus thing is nicelooking, but doesn't look like it knows types
05:58:55 <gwern> povman: hah. I always assumed it came from Wikipedia
05:59:38 <povman> where?
06:00:38 <atsampson> "point of view", presumably
06:01:03 <gwern> ayuh
06:01:08 <unenough> bah
06:01:15 <unenough> pov comes from pov-ray.
06:01:22 <unenough> Persistence Of Vision
06:01:55 <povman> how's that relate to wikipedia though?
06:02:18 <atsampson> I think the term "persistence of vision" somewhat predates povray ;)
06:02:33 <unenough> but as an acronym?
06:02:39 <takamu> hi
06:03:30 * povman places ratioToDecimalString on the backburner
06:03:42 <TomMD> > map succ "Gdkkn\USs`j`lt"
06:03:45 <lambdabot>  "Hello takamu"
06:03:58 <gwern> POV is the other part of NPOV, let's say
06:04:06 <gwern> :t succ
06:04:11 <lambdabot> forall a. (Enum a) => a -> a
06:04:32 <unenough> POV: "The physiological phenomena whereby a human eye retains perception of an image for a short time after the image is no longer visible"
06:05:16 <vincenz> Point Of View
06:05:50 <povman> everyone writes raytracers, they must be simple
06:06:09 <TomMD> Everyone I talk to seems to have a PhD - getting one must be simple.
06:06:27 <vincenz> Everyone I talk to has an opinion, they're simple too.
06:06:46 <TomMD> The opinions, the people or both?
06:06:56 * vincenz leaves it ambiguous
06:07:07 <povman> quite clever imo
06:07:27 <povman> it's the hello world of haskell
06:07:44 <unenough> almost everyone I talk to hears me
06:08:00 <snhmib> does anyone know the SOE (graphics) library?
06:08:08 <gwern> everyone I talk to can talk to me; English must be dead simple
06:08:18 <unenough> ma?
06:08:19 <vincenz> gwern: or you must be?
06:08:34 <unenough> qua?
06:08:39 <unenough> shto?
06:08:47 <snhmib> http://rafb.net/p/cMwer181.html <- i want to make a simple graphic (circle) follow the mouse
06:08:48 <lambdabot> Title: Nopaste - test.hs
06:08:48 <takamu> btw, SOE is still maintained?
06:08:56 <snhmib> but it is lagging behind the mouse and i'm not sure why
06:09:02 <Beelsebob> TomMD: more likely, writing Haskell is something that lends itself to heavily mathimatically minded people, who are likely also to be the kind of person who goes after a PhD
06:09:05 <gwern> unenough: yer not foolin' me, I saw you speakin
06:09:06 <vincenz> gwern: hmm, that came off a bit strong, sorry.
06:09:45 * unenough is proud of his first latex document. 4 pages so far! 
06:10:08 <TomMD> Beelsebob: Yes, I understand and agree with that - I was just playing on the above statement.  Also, I wasn't limiting my observation to Haskell programmers but in general I've been bouncing into numerous PhDs of late.
06:10:28 <vincenz> TomMD: they come in droves
06:10:40 <Beelsebob> yep, they're like sheep
06:10:48 <Beelsebob> they cling to each other in the hope of survival
06:10:56 <TomMD> I'll tell them next time I see them.
06:11:04 <atsampson> is that PhDs, or PhD students?
06:11:14 <snhmib> is it lagging because it stacks mouse-event-updates faster then it can draw at them?
06:11:14 <Beelsebob> PhD students I guess
06:11:41 <Beelsebob> PhDs I guess are rather more confident that no matter what gets chucked at them, they can spend 7 years going insane and eventually beat it
06:11:59 <vincenz> 7 years? where?
06:12:10 <TomMD> atsampson: PhDs, not students.
06:12:24 <vincenz> TomMD: you mean the documents?
06:12:40 <Beelsebob> vincenz: dunno, slight exaduration :P
06:12:45 <Beelsebob> it feels like 7 years now :P
06:12:54 <TomMD> vincenz: What is the question?  Perhaps I am simple :-(
06:13:42 * atsampson grins at Beelsebob -- it hasn't really been that long ;)
06:13:57 <Beelsebob> no, 3 and a half so far
06:13:57 <atsampson> also, "*going* insane"?
06:14:07 <Beelsebob> hopefully get to hand in in a month or so
06:14:13 <vincenz> atsampson: there are gradations
06:14:37 <vincenz> TomMD: It was a lame comment.  People holding a phd are usually called drs, so when you say you run into phds, I wondered whether you meant the actual documents.
06:15:34 <povman> a great majority of times when someone mentions x going insane, someone else jumps in and says, "*going* insane?"
06:15:35 <Beelsebob> yeh, third years are a different kind of insane to first years
06:15:40 <povman> hence it's time for bed
06:15:42 <Beelsebob> first years are just plain nuts
06:15:52 <Beelsebob> second years are worn out
06:15:59 <TomMD> @localtime povman
06:16:00 <lambdabot> Local time for povman is 2008-04-06 23:16:00 +1000
06:16:01 <Beelsebob> third years are clinically depressed
06:16:15 <povman> not not not
06:16:23 <povman> wait yea it is :P
06:16:30 <snhmib> should i use Graphics.HGL instead of SOE?
06:16:30 <TomMD> The night is young
06:16:43 <povman> i have an cold
06:17:06 * atsampson peers suspiciously at it snowing outside
06:17:19 <povman> @localtime atsampson
06:17:21 <lambdabot> Local time for atsampson is Sun Apr  6 14:17:19 2008
06:17:37 <povman> how come your formatting is so nice
06:18:00 <vincenz> @localtime vincenz
06:18:03 <lambdabot> Local time for vincenz is Sun Apr  6 15:18:00 2008
06:18:04 <atsampson> perhaps I'm in lambdabot's time zone?
06:18:07 <Beelsebob> atsampson: yeh, but not sticking
06:28:56 * vincenz sighs "How do you know you're stuck on a problem?  You can't figure out the proper type for the core function."
06:29:09 <vincenz> .. You can't -even- ..
06:30:47 <Jedai> @localtime Jedai
06:30:48 <lambdabot> Local time for Jedai is dim. 6. avr. 16:28:30 2008
06:32:11 <SamB> vincenz: so, if you are in the middle of figuring it out, does that still count as stuck?
06:32:42 <vincenz> As long as you odn't have a type, you can't code it
06:32:48 <vincenz> And I've been stuck on this one for a while
06:33:10 <SamB> what if the type is the hard part?
06:33:20 <vincenz> If I knew that :)
06:33:27 <vincenz> I'd be halfway home
06:33:47 <vincenz> what I'm stuck on is whether I need to pass in two continuations
06:33:48 <vincenz> or pass in one
06:33:52 <vincenz> and let it return one
06:36:16 <dcoutts> @seen lemmih
06:36:17 <lambdabot> lemmih is in #haskell. I don't know when lemmih last spoke.
06:40:11 <vincenz> SamB: getting closer :)
06:40:49 <SamB> vincenz: why can't you just pick one, then halfway through realize you have the wrong type and add/remove a parameter and change the return type?
06:41:06 <vincenz> SamB: cause it would change the logic considerably
06:41:11 <SamB> oh
06:41:21 <vincenz> but the one I have now seems sensible
06:41:29 <vincenz> and it seems to work for the simplest of cases :)
06:41:32 <SamB> well, still, that's better than being stuck isn't it?
06:41:49 <vincenz> the nastiness was the lack of side-effects
06:42:05 <vincenz> if I went or passing in two, I have no clue how I would'v'e done it without a lot of monads
06:42:10 <vincenz> s/or/for
06:42:20 <vincenz> But returning one continuation seems to work nicely so far :)
06:45:10 <vincenz> SamB: I tried to solve this once before and the code got all messy
06:45:13 <vincenz> this time I KISS :)
06:45:55 <vincenz> @src (++)
06:45:55 <lambdabot> (++) []     ys = ys
06:45:55 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
06:46:00 <vincenz> :t ++
06:46:03 <vincenz> :t (++)
06:46:04 <lambdabot> parse error on input `++'
06:46:05 <lambdabot> forall m. (Monoid m) => m -> m -> m
06:50:54 <SamB> okay, uh, trac is down
06:51:19 <SamB> Igloo: dons: you know this?
06:51:37 <SamB> maybe dcoutts ?
06:52:48 <dcoutts> SamB: which one?
06:52:53 <dcoutts> SoC seems ok to me
06:54:16 <Igloo> dcoutts: Can gtk2hs use the standard commit-messages script?
06:56:01 <dcoutts> Igloo: no, we use a full diff
06:56:30 <Igloo> OK
06:58:45 <Schmallon> Is there a non-blocking version of getChar?
07:00:26 <Schmallon> something like "getCharNB :: IO Maybe Char" which returns Nothing in case no key is currently being pressed
07:01:26 <scook0> I can see hGetBufNonBlocking, but it looks a little low-level
07:02:55 <scook0> and there's hGetNonBlocking in Data.ByteString
07:03:25 <scook0> it should be possible to construct getCharNB from one of those
07:03:29 <opqdonut> you'd probably want to use curses for that
07:03:29 <Baughn> Schmallon: "Currently"? What about keys that were pressed in the past?
07:03:36 <Baughn> Or SDL
07:03:41 <opqdonut> yeah
07:10:19 <Ogedei> I had, at one point, a PDF of "Implementing Functional Languages" in which all the examples were in Haskell, but right now I can only find the Miranda version online... anyone have a link?
07:10:54 <Schmallon> @Baughn: Hmm. Maybe I should elaborate on what I'm trying to build: I played a bit with the jackd (the audio daemon) binding, feeding it some signal which I want to change (e.g. change frequency) depending on keyboard input. My first approach would have been to check the state of the keyboard every time the signal callback gets called. Therefore I only need the current key.
07:10:54 <lambdabot> Unknown command, try @list
07:11:37 <scook0> reading from a keyboard buffer probably isn't going to work then, I'm afraid
07:12:30 <Ogedei> (never mind -- found what I was looking for)
07:12:55 <scook0> SDL might be your best bet
07:13:54 <Baughn> Schmallon: If you do decide you're okay with having a keyboard buffer, the usual approach is to forkIO and have one thread per i/o port
07:14:13 <Baughn> That is, /let/ it block
07:15:10 <scook0> this won't work if you want to handle keydown and keyup separately, but it will resolve the blocking problem
07:17:01 <Schmallon> right. haven't (consciously) worked with multi-threading in haskell yet. I'll give a try. Thanks for the advise to all!
07:18:45 <Baughn> Schmallon: The key thing to remember is that haskell threads are fairly cheap. We're not talking pthreads here.
07:19:07 <Schmallon> good to know
07:19:36 <atsampson> do the Haskell JACK bindings do buffering for you, or do you have to consider RT-safety when writing callbacks? if the latter, then doing IO in a callback isn't a good idea anyway...
07:19:53 <Baughn> In fact, blocking primitives (such as getChar) are implemented by having the RTS call select
07:21:51 <Schmallon> I'm not actually sure, whether they perform any internal buffering. You're pobably right, that doing IO in the callback might be to much of a cost. As long as I get my speakers to produce some output I'll be fine though (for the moment)
07:31:33 <vincenz> :t repeat
07:31:48 <lambdabot> thread killed
07:46:31 <vincenz> @src print
07:46:31 <lambdabot> print x = putStrLn (show x)
08:07:47 <syntaks> hello everyone
08:10:07 <syntaks> can I automatically put an imported type into Typeable as I'd do with my own types when writing data A = ... deriving (Typeable)?
08:17:30 <TomMD> syntaks deriving class instances for externally declared data types was once proposed, but I've never heard of or seen this working.
08:21:12 <Igloo> If the constructors are exposed then ghc can do it with its standalone deriving extension
08:22:10 <syntaks> Igloo, how do I do that?
08:22:39 <Igloo> "derive instance Class Type" IIRC
08:22:55 <Igloo> Check the manual if I'm wrong
08:23:15 <syntaks> I'll try that at once...
08:23:22 <nominolo> @seen edwinb
08:23:22 <lambdabot> edwinb is in #haskell. I don't know when edwinb last spoke.
08:24:00 <scook0> Igloo: so you can't standalone-derive Typeable for opaque types?
08:24:08 <Igloo> No
08:24:13 <scook0> is that just a quirk of the current implementation?
08:24:19 <Igloo> It's a design choice
08:24:54 <TomMD> And thank you for that
08:24:59 <scook0> I guess it would be a problem if two modules both tried to derive it
08:27:35 <Igloo> Yes, you get the normal overlapping instances error IIRC
08:27:53 <Igloo> Which I think is because it's the easy thing to do, rather than a design choice
08:28:07 <scook0> e.g. if you had two libraries that did that, and you imported both, you'd be in trouble
08:28:55 <Heffalump> anyone built GHC HEAD lately? I appear to be missing Cabal/Distribution/Compat/FilePath.hs, which has perhaps moved into a compat directory
08:29:28 <Igloo> I don't remember anything about that
08:30:08 <Igloo> Recently, that is
08:30:24 <Igloo> The files doesn't exist, though
08:30:29 <Igloo> Are all your repos up-to-date?
08:30:32 <Heffalump> I believe so, yes
08:30:39 <Heffalump> I've got the file in ./compat
08:30:57 * Heffalump tries another pull
08:31:08 <Igloo> Presumably that just #includes the one you don't have?
08:31:08 <syntaks> Igloo: deriving instance Typeable UTCTime does it (plus specifying StandaloneDeriving).... thanks a lot!
08:31:13 <Igloo> The compat one isn't supposed to exist either
08:31:27 <lemmih> dcoutts: yo?
08:32:45 <Heffalump> yes, it does
08:32:49 <Heffalump> (just #include)
08:33:18 <Heffalump> I've definitely checked that Cabal was up to date already, and I pulled everything last night or got it this morning, but I'm just doing another darcs-all pull just in case.
08:41:50 <hpaste>  ehird pasted "Experimenting with making (head []) a type error. This doesn't work :(" at http://hpaste.org/6867
08:44:22 <ehird_> :/
08:46:54 <Heffalump> ehird_: unless you make the datatype encode the precise length, you'll never be able to do that
08:47:11 <Heffalump> assuming you are really aiming at more interesting cases than just a literal head []
08:48:52 <ehird_> Heffalump: there was a paper about it sometime
08:48:53 <ehird_> :p
08:48:57 <ehird_> but really i just want that code to compile
08:48:57 <ehird_> heh
08:49:20 <ehird_> :t callCC
08:49:22 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
08:49:30 * Heffalump deletes a load of junk from compat and things start working better
08:49:46 <Heffalump> ehird_: what fails to compile?
08:50:09 <Heffalump> that type synonym looks pretty dubious to me
08:50:26 <Heffalump> if you made it a newtype/data it might work (with more tagging, obviously)
08:51:27 <fons> hi all
08:52:11 <fons> Does anyone know of an implementation of Data.Map without an Ord constraint in the keys?
08:52:22 <Heffalump> i.e. with an Eq one instead?
08:52:38 <fons> Heffalump: exactly
08:52:42 <Heffalump> if so, [] has at least some of the same operations
08:52:46 <Heffalump> like lookup
08:52:55 <fons> Heffalump: I'm doing that now
08:53:09 <Heffalump> I don't know of anything else.
08:53:21 <jaj> Hi! I was wondering, can I extract a value from an IO monad in a where clause?
08:53:27 <Botje> no
08:53:29 <fons> Heffalump: I have to define my own insert and so own, which is what I wanted to avoid by asking for a Map alternative
08:53:32 <Heffalump> jaj: no, you have to use do notation.
08:53:38 <fons> and so on*
08:53:56 <Heffalump> fons: fair enough. It's obviously fairly trivial to write the basic operations.
08:54:16 <fons> jaj: use let
08:54:47 <jaj> Heffalump: can you combine do notation with guards?
08:54:50 <fons> exampleIOFun :: a -> IO a
08:55:09 <Heffalump> jaj: umm, probably not, where do you want to put them?
08:55:35 <fons> do {a <- exampleIOFun whatever; let intermediateVal = pureFun a ...; ....}
08:56:08 <fons> jaj:  you can mix let expresions with do notation, which is probably what you want
08:56:51 <fons> jaj: if let is now enough then you probably need unsafeperformIO which at the same time normally means you need to rethink your design
08:57:06 <jaj> I have a function which does database lookups and it decides what kind of lookup to do with guards and pattern matching. but I have to connect to the database and do the query and I wanted to factorize this in a where statement
08:57:20 <jaj> but I think I'll just create an auxiliary function
08:58:04 <ehird_> FastCGI.hsc:59:21:  error: fcgiapp.h: No such file or directory
08:58:11 <ehird_> it's in /opt/local/include, how do I tell cabal about that dir?
08:59:24 <fons> jaj: I see what you mean, you need a common subexpression for various guards using IO
08:59:34 <fons> jaj: then let won't either help
08:59:42 <jaj> fons: yeah
09:00:05 <jaj> probably my design is bad
09:00:14 <fons> jaj: paste it
09:00:21 <fons> (in hpaste)
09:00:32 <cjb> hm, one of the language shootout examples isn't compiling on GHC anymore
09:00:37 <cjb> ghc-6.8.2: unknown package: regex-posix
09:00:40 <cjb> http://shootout.alioth.debian.org/gp4/benchmark.php?test=regexdna&lang=ghc&id=2
09:00:48 <lambdabot> Title: regex-dna Haskell GHC #2 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Com ..., http://tinyurl.com/5l8fzt
09:02:39 <fons> cjb: then regex-posix is not installed
09:02:55 <fons> (not saying anything new of course ;))
09:04:37 <ehird_> :/
09:05:48 <olsner> is this page out-of-date? http://www.haskell.org/haskellwiki/The_Monad.Reader
09:05:54 <lambdabot> Title: The Monad.Reader - HaskellWiki
09:07:07 <olsner> I know there was an article about assembler and mdo recently, but I think it's in the issue after the issue listed as the "latest issue" on that page
09:07:08 <fons> ehird_: check the includes field in Cabal's documentation
09:07:20 <dcoutts> ehird_: with the new Cabal there's an option
09:07:33 <dcoutts> with older Cabal you have to hack the .cabal file
09:07:45 <jaj> fons: I don't have any real code to post, I don't know how to write the function
09:08:08 <fons> jaj: paste what you have
09:08:19 <olsner> hmm, oh, it seems that article was in an *older* issue of the monad reader... I guess "never mind" then
09:08:29 <fons> even pseudo code can help
09:08:49 <bugQ> Freaking monad tutorials!  I grok monads now, no thanks to them.
09:09:21 <augustss> stop reading them!
09:09:30 <bugQ> already have.
09:09:38 <olsner> bugQ: you *write* monad tutorials to learn monads, not read them :P
09:10:10 <bugQ> ah, OK.  then why is there a list of them in the wiki if they're useless?
09:10:37 <lemmih> dcoutts: You wanted to see me earlier?
09:10:46 <snhmib> bugQ: to help you learn write them! o_O
09:11:18 <dcoutts> lemmih: oh yes, about meeting up later this week
09:11:26 <fons> bugQ: have you read all about monads?
09:11:33 <dcoutts> lemmih: I had a slight change of plan so have less travelling time
09:11:43 <bugQ> fons: more than I would like to have read, yes.
09:11:52 <fons> I meant All About Monads
09:11:57 <bugQ> oh, no.
09:12:06 <fons> its a tutoria
09:12:07 <lemmih> dcoutts: I won't be in Copenhagen. I'm traveling directly from Landskrona to Gothenburg.
09:12:11 <fons> tutorial
09:12:18 <fons> you should read that one
09:12:18 <dcoutts> lemmih: oh right
09:12:39 <bugQ> i'll look at it, I suppose.
09:13:49 <dcoutts> lemmih: what day are you traveling to Gothenburg?
09:14:44 <fons> I personally think that people find mondas difficult to understand because they pretend to understand them all at once. Every monad has its own semantics even if the share the same operations.
09:14:49 <lemmih> dcoutts: Thursday.
09:15:43 <dcoutts> lemmih: ah ok, I'll be arriving on the 9th I think
09:16:09 <dcoutts> lemmih: what are you doing in Landskrona? that's just north of Malmo right?
09:17:19 <lemmih> dcoutts: I live here. Yeah, north of Malmo. You're welcome to come visit me (: All trains to Gothenburg stop at Landskrona, I think.
09:17:52 <dcoutts> lemmih: I've got a flexible ticket so I could certainly drop by
09:18:14 <dcoutts> lemmih: did you move recently? I thought you lived in .dk
09:18:51 <newsham> morgen
09:18:57 <dcoutts> lemmih: I'm traveling from Utrecht on the 8th, to arrive in gbg on the evening of the 9th so I could probably drop in for a few hours
09:20:39 <lemmih> dcoutts: Yeah, I moved pretty recently. I don't even have a bed or (more importantly) a decent broadband connection yet.
09:20:52 <dcoutts> lemmih: heh heh
09:20:53 <gwern> it's interesting the things slocate can tell you sometimes when you collect haskell programs
09:21:09 <gwern> for example, I have no fewer than 5 projects each of which have 'SHA1.hs'
09:21:11 <dcoutts> lemmih: I'll check out the train times and see what time I could drop by
09:21:27 <gwern> jhc, yi, ginsu, conjure, and happs
09:22:36 <lemmih> Doesn't that mean that Crypto needs to be fixed?
09:22:49 <gwern> I wonder why there are so many implementations of SHA1?
09:22:52 <TomMD> gwern: Any idea why they don't add a crypto dependency?
09:23:03 <TomMD> gwern: Are you sure they are all separate implementations?
09:23:11 <gwern> lemmih: perhaps. although I think ginsu and conjure may predate any Crypto
09:23:30 <gwern> TomMD: actually, yi and jhc are probably copying from some ghc implementation. I really need to diff'em and track down the genealogy
09:23:37 <newsham> ... putting the sha back into sharedlibrary
09:24:07 <TomMD> That should be the crypto library logo.
09:24:18 <lemmih> We specifically avoided Crypto in HAppS and Conjure.
09:24:21 * gwern groans
09:24:43 <newsham> lemmih: so does HAppS still have unsecure cookie generation?
09:25:04 <TomMD> lemmih: What was the reason behind that?
09:25:41 <lemmih> TomMD: Bad license mix, horrible dependencies  and a non-intuitive interface.
09:25:43 <bugQ> yeah, woah, O'Haskell suddenly makes sense, too, after monads.
09:25:47 <gwern> lemmih: oh, so that's two explained then, which leaves ginsu, jhc, and yi
09:26:02 <atsampson> gwern: ginsu certainly used to have its own bindings to OpenSSL...
09:26:46 <gwern> atsampson: I've intended to eviscerate ginsu, but meachem has been hard to work with in the past - we kind of have philosophical differences re: hackage & cabal
09:26:52 <gwern> so dunno
09:26:54 <lemmih> newsham: Kinda. The built-in generator is still broken but you're not forced to use it.
09:27:18 <newsham> sure but most people will use the builtin session handling code
09:27:30 <newsham> (isnt that the point of using a framework in the first place?)
09:27:38 <TomMD> lemmih: So a BSD, ByteString, self contained crypto library would be... bliss?
09:27:38 <atsampson> gwern: having ginsu work with GHC 6.8 would be nice ;) (currently it depends on the guts of how UArray is implemented)
09:27:39 <dcoutts> gwern: aye, he doesn't like it that much, I try to understand and accommodate
09:27:50 <gwern> most people are smart and will use all the builtins as far as possible. it's not good to be insecure by default
09:28:31 <gwern> atsampson: yes, the array stuff is hard... uarrays torpedoed GeomAlgLib as well
09:29:03 * gwern looks through the 5 bindings. interesting. some are ffis, others are native, and so on.
09:29:09 <lemmih> newsham: Indeed, but HAppS isn't a web-framework. It just pretends to be one on weekends. (:
09:29:27 <lemmih> TomMD: It sure would.
09:30:57 <newsham> its sunday here
09:31:11 <atsampson> gwern: the sticking point for updating ginsu is its custom version of PackedString, with various UTF-8 stuff added; there isn't really a good replacement in the Haskell standard library at the moment (as far as I know)
09:32:02 <lemmih> TomMD: A rework of Crypto might come up at the hackathon.
09:32:17 <gwern> hm. I think happs might be using a updated and improved version of the ginsu module
09:32:21 <TomMD> As it should - I heard it came up last time.
09:32:44 <TomMD> My MD5 package is out there and ready to go into any such library.
09:34:26 <gwern> or... maybe the ginsu and happs bindings aren't so similar after all. hm
09:34:31 <lemmih> newsham: We'll fix it at some point. It's just not a priority right now. Feel free to send patches (:
09:35:05 <newsham> i think i did
09:35:50 <newsham> (basically base64 (encrypt secretkey sessionnumber))
09:36:05 <newsham> instead of just sessionnumber
09:37:35 <bugQ> Are there any data definitions that can made made in GADT that can't with existentials, et vice versa?
09:37:42 <vincenz> @hoogle basically
09:37:42 <lambdabot> No matches found
09:38:26 <newsham> you can express natural addition in gadt, no?  can you do that with existentials?
09:38:44 <lemmih> newsham: Oh, I can't find it. Send it again and I'll apply it.
09:38:56 <Heffalump> I think GADTs can always be translated to existentials.
09:39:11 <Heffalump> oh, perhaps not, the restricted return types probably can't be
09:39:22 <Heffalump> so data Foo a where FooUnit :: Foo ()
09:39:34 <bugQ> ah.
09:39:45 <snhmib> what are some (small-ish) programs that use the fgl library?
09:40:11 <newsham> havent used happs in a while.. dont know where clean patch might be (also it would be out of date)
09:40:28 <newsham> i have some code outside of the lib for doing it in my (old, outdated) program
09:46:48 <bugQ> ok, cool.  GADT syntax is more consistent, anyway.
09:47:05 <newsham> lemmih: what's your email addr?
09:48:28 <Heffalump> bugQ: yeah. Much nicer.
09:48:59 <Heffalump> and you don't actually have to realise you're using an existential (which can be both good and bad, but on balance I think it mostly encourages people to write natural code)
09:50:37 <gwern> snhmib: there is a game or two on hackage, iirc
09:51:03 <bugQ> heh, FOSDEM sounds like a pun on Mos Def.
09:52:31 <roconnor> @type forever
09:52:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
09:52:57 <mauke> > map ("FOSDEM" !!) [5,1,2,3,4,0]
09:52:59 <roconnor> I still don't get why forever returns m () instead of m b
09:52:59 <lambdabot>  "MOSDEF"
09:53:36 <newsham> > reverse "nufekop"
09:53:37 <lambdabot>  "pokefun"
09:54:00 <snhmib> thanks
09:54:11 <roconnor> @type fix ((>>) .)
09:54:12 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m b)
09:54:12 <lambdabot>       Expected type: f (m a) -> f (m a)
09:54:12 <lambdabot>       Inferred type: f (m a) -> f (m b -> m b)
09:54:22 <roconnor> @type fix (. (>>))
09:54:23 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m b)
09:54:23 <lambdabot>       Expected type: (m b -> m b) -> b1
09:54:23 <lambdabot>       Inferred type: m a -> b1
09:55:00 <roconnor> @pl \x -> fix (x >>)
09:55:00 <lambdabot> fix . (>>)
09:55:06 <roconnor> oh right
09:55:09 <bugQ> map ("kompmufd" !!) [7,5,2,4,0,1,3,6]
09:55:10 <bugQ> hee
09:55:10 <roconnor> @type fix . (>>)
09:55:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
09:56:36 <ehird_> @type guard
09:56:37 <snhmib> gwern: do you maybe know the name? all the ones in the Game category have no fgl dependency
09:56:41 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
09:57:37 <ehird_> > (guard False,guard True) :: ([()],[()])
09:57:38 <lambdabot>  ([],[()])
09:58:10 <mauke> http://quotes.burntelectrons.org/3608
09:58:19 <ehird_> > (unless False [],unless True [])
09:58:20 <lambdabot>  ([],[()])
09:59:14 <roconnor> @seen dons
09:59:14 <lambdabot> dons is in #haskell, #xmonad and #haskell-soc. I last heard dons speak 9h 35m 1s ago.
09:59:26 <shapr> @seen roconnor
09:59:26 <lambdabot> roconnor is in #haskell. I last heard roconnor speak 12s ago.
09:59:29 <shapr> Aha!
09:59:34 <shapr> @quote
09:59:34 <lambdabot> JonFairbarn says: I think we should call it "Abstraction Oriented Programming". It's got the "oriented" buzzword in it, and we don't need to tell folk that "abstraction" means more than one thing to
09:59:34 <lambdabot> us until we're sure they're OK.
09:59:39 <gwern> snhmib: wait, *f*gl? as in, functional? I'm sorry, I thougth you meant *h*gl
09:59:47 <roconnor> @seen shapr
09:59:47 <lambdabot> shapr is in #haskell-blah, #scannedinavian and #haskell. I last heard shapr speak 13s ago.
09:59:49 <shapr> aha!
09:59:50 <newsham> ?tell lemmih http://hpaste.org/6868
09:59:50 <lambdabot> Consider it noted.
09:59:51 <shapr> It's ME!
10:00:17 <roconnor> @tell shapr he is here
10:00:17 <lambdabot> Consider it noted.
10:00:26 <vincenz> @tell shapr ME is here
10:00:26 <lambdabot> Consider it noted.
10:00:29 <shapr> yay!
10:00:29 <lambdabot> shapr: You have 3 new messages. '/msg lambdabot @messages' to read them.
10:00:34 <shapr> @messages
10:00:34 <lambdabot> boegel said 14h 51m 18s ago: I've arrived in Boston, let me know when you're free to meet up... I'll be leaving again Wednesday evening.
10:00:34 <lambdabot> roconnor said 17s ago: he is here
10:00:34 <lambdabot> vincenz said 8s ago: ME is here
10:00:36 <shapr> ooh
10:01:04 <newsham> isnt it illegal to discriminate against a programmer based on his object orientation?
10:01:22 <bugQ> newsham++
10:01:48 <bugQ> almost fell off the chair.
10:02:00 * shapr laughs
10:02:01 <snhmib> gwern: oh sorry i ment the f one :) no prob though i found some more example usage for it
10:02:10 <shapr> @remember newsham isnt it illegal to discriminate against a programmer based on his object orientation?
10:02:10 <lambdabot> I will remember.
10:04:33 <hpaste>  ehird pasted "Kalotan puzzle in the list monad. Could possibly be cleaned up a bit." at http://hpaste.org/6869
10:05:04 <bugQ> only two genders?
10:05:19 <ehird_> bugQ: that's how the puzzle is stated
10:05:20 <ehird_> :p
10:05:24 <newsham> ehird: xor a b = not (a == b) ?
10:05:33 <ehird_> http://everything2.com/title/Teach%2520Yourself%2520Scheme%253A%252014.4%2520Logic%2520puzzles   the puzzle is at the start here
10:05:35 <lambdabot> Title: Teach Yourself Scheme: 14.4 Logic puzzles@Everything2.com, http://tinyurl.com/6rwcjx
10:06:00 <ehird_> newsham: that's a good point
10:06:00 <ehird_> thanks
10:06:22 <ddarius> newsham: /=
10:06:33 <newsham> one good point deserves another
10:06:40 <ehird_> incidentally, the Scheme version is quite hideous
10:06:58 <Botje> ehird_: if kibiLied then guard $ kibiClaims /= kibi else guard $ kibiClaims == kibi
10:07:16 <ehird_> hmm, of course :)
10:07:22 <ehird_> i just blindly translated the scheme, to clean up later
10:07:37 <newsham> who is this kibi?
10:07:48 <ehird_> newsham: the kibi in the puzzlei  just linked
10:08:24 <hpaste>  ehird annotated "Kalotan puzzle in the list monad. Could possibly be cleaned up a bit." with "improved kibi" at http://hpaste.org/6869#a1
10:09:01 <gwern> well, kibi is a binary prefix
10:09:06 <gwern> as in kibibyte
10:09:20 <ehird_> hah
10:09:39 <newsham> if thats what disk drive manufacturers use, then kibi definitely lied
10:09:42 <oerjan> guard $ (kibiClaims /= kibi) == kibiLied
10:09:43 <bugQ> Botje: guard $ if kibiLied then kibiClaims /= kibi else kibiClaims == kibi
10:10:00 <bugQ> wait, that's much better, oerjan
10:10:30 <ehird_> aha :)
10:10:50 <Botje> that's getting slightly obfuscated :)
10:11:14 <hpaste>  ehird annotated "Kalotan puzzle in the list monad. Could possibly be cleaned up a bit." with "kibi3" at http://hpaste.org/6869#a2
10:11:21 <ehird_> Botje: hardly
10:11:39 <ehird_> the 'parent1 == Male' clause is really ugly
10:12:08 <newsham> ehird: as ddarius said:  xor = (/=)
10:13:26 <ehird_> oh, duh
10:13:27 <ehird_> :D
10:13:36 <ehird_> i'll still define it as xor though
10:13:40 <oerjan> ehird_: applies to another not ( == ) as well
10:13:41 <ehird_> because of the type-safety
10:13:46 <ehird_> and it looks obfuscated with /=
10:13:48 <ehird_> so
10:13:56 <ehird_> xor a b = a /= b
10:14:12 <newsham> ?pl \a b -> a /= b
10:14:12 <lambdabot> (/=)
10:14:20 <ehird_> well, yes
10:14:23 <ehird_> but (/=) looks ugly
10:14:25 <ehird_> :D
10:14:39 <newsham> so does your mom!
10:14:43 <newsham> err..  wait.. i mean "not"
10:15:19 <oerjan> ehird_: i _think_ ((kibi == Female && kibiLied == False) `xor` (kibi == Male && kibiLied == True))
10:15:45 <ddarius> Why are we saying boolean == True and boolean == False?
10:15:53 <newsham> isnt the point of writing the puzzle in this form to keep it pretty faithful to the original wording?
10:16:00 <newsham> rather than going through the effort of doing logic minimalization?
10:16:03 <ehird_> ddarius: That is a good point
10:16:12 <ehird_> The answer is that the Scheme was crazy!
10:16:22 <ehird_> newsham: well, the original was ugly
10:16:22 <ehird_> so
10:16:23 <ehird_> :D
10:16:30 <newsham> if you minimize the logic, you could solve it without using haskell at all
10:16:36 <oerjan> is the same as that with || instead of xor
10:16:57 <oerjan> because only one of them can be true
10:16:59 <ehird_> oerjan: not sure
10:17:13 <ehird_> just checked
10:17:14 <ehird_> yep
10:17:38 <hpaste>  ehird annotated "Kalotan puzzle in the list monad. Could possibly be cleaned up a bit." with "kibi4" at http://hpaste.org/6869#a3
10:17:52 <oerjan> which again simplifies to (kibi == Female) `xor` kibiLied
10:17:55 <ehird_> its at that crucial point where it is a little hard to follow. one more minimalization should bring it to sanity
10:19:11 <bugQ> the whole thing reduces to (guard $ (kibi /= parent1) /= kibiLied), doesn't it?
10:19:23 <gwern> @hoogle Maybe String -> String
10:19:25 <lambdabot> System.Locale.iso8601DateFormat :: Maybe String -> String
10:19:44 <bugQ> wait, that doesn't take kibiBlaims into account...
10:19:49 <bugQ> Claims*
10:19:53 <ehird_> bugQ: no, it doens't, that produces:
10:19:56 <ehird_> [(Male,Male,Male),(Male,Male,Male),(Male,Male,Female),(Male,Male,Female),(Male,Female,Male),(Male,Female,Male),(Male,Female,Female),(Male,Female,Female),(Female,Male,Male),(Female,Male,Male),(Female,Male,Female),(Female,Male,Female),(Female,Female,Male),(Female,Female,Male),(Female,Female,Female),(Female,Female,Female)]
10:20:05 <newsham> what would karnaugh do?
10:20:12 <gwern> hm. that should pull up fromJust
10:20:31 <hpaste>  ehird annotated "Kalotan puzzle in the list monad. Could possibly be cleaned up a bit." with "kibi once again" at http://hpaste.org/6869#a4
10:20:36 <ehird_> its close to its ideal form i think
10:20:55 <newsham> ehird: http://paste.lisp.org/display/25690
10:21:51 <ehird_> newsham: excuse me if i prefer my version
10:21:52 <ehird_> ;)
10:22:06 <newsham> its not my version, its logic minimalization algorithm
10:22:26 <newsham> ?go quine mccluskey
10:22:27 <lambdabot> http://en.wikipedia.org/wiki/Quine-McCluskey_algorithm
10:24:36 <ehird_> hmm
10:24:42 <ehird_> Ithere's two kibiLied thingies
10:24:45 <ehird_> that seems wrong
10:24:45 <hpaste>  oerjan annotated "Kalotan puzzle in the list monad. Could possibly be cleaned up a bit." with "joining guards" at http://hpaste.org/6869#a5
10:24:57 <ehird_> oerjan: now that's ugly
10:25:03 <ehird_> also..
10:25:05 <ehird_> guard $ and [
10:25:06 <ehird_> would suffice
10:25:31 <oerjan> um the and is for checking all in the list
10:25:57 <ehird_> yes
10:26:17 <oerjan> actually my main point was to move the guard outside the if
10:27:20 <ehird_> anyone agree wiht me that oerjan's is ugly? :)
10:27:34 <oerjan> i think even i agree :D
10:28:08 <ehird_> why move the if into the guard, anyway?
10:28:26 <boyscared> has anyone managed to install ghc-6.8.2 on freebsd 7?
10:28:30 <vincenz> ehird_: lol, I read that ass "...oerjan is ugly"...
10:28:33 <vincenz> ehird_: and then I saw him agreeing
10:28:39 <oerjan> makes it clear the whole thing is a guard?
10:28:50 <ehird_> oerjan: hmm, no
10:28:58 <ehird_> since you're asserting something different based on the conditional
10:29:09 <vincenz> ugly
10:29:28 <ehird_> vincenz: does http://hpaste.org/6869#a4 look OK to you? any suggestinos?
10:29:42 <oerjan> otoh if you made it a list comprehension instead...
10:29:59 <ehird_> hmm
10:30:05 <ehird_> but that removes the 'amb'-ness of it
10:30:05 <ehird_> :)
10:30:24 <hpaste>  vincenz annotated "Kalotan puzzle in the list monad. Could possibly be cleaned up a bit." with "less ugly" at http://hpaste.org/6869#a6
10:30:48 <vincenz> why the hell don't you break earlier on parents?
10:30:52 <vincenz> whata cycle wastage
10:31:21 <vincenz> for (i...) { for 1....10000000 {if i is even fail}}
10:31:51 <vincenz> @hoogle (^^)
10:31:52 <lambdabot> Did you mean: (^^)
10:31:52 <lambdabot> Prelude.undefined :: a
10:31:52 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
10:31:53 <ehird_> vincenz: you are joking, right
10:32:09 <vincenz> ehird_: no
10:32:10 <oerjan> @index ^^
10:32:10 <lambdabot> Prelude
10:32:18 <ehird_> :/
10:32:19 <vincenz> I would also propose ^^ for xor
10:32:23 <vincenz> in trend with && and ||
10:32:29 <vincenz> but, that's minor
10:32:38 <ehird_> ^^ is taken
10:32:41 <ehird_> (^^) :: (Integral b, Fractional a) => a -> b -> a
10:32:45 <bugQ> vincenz is right, it will take 2x as long otherwise
10:32:55 <vincenz> you mean 8
10:32:56 <ehird_> bugQ: but vincenz code is ugly
10:32:58 <vincenz> 2^3
10:33:21 <bugQ> no, only 2, because 2/4 possibilites exist where parent1 /= parent2
10:33:28 <vincenz> bugQ: hmm, good point :)
10:33:37 <vincenz> bugQ: was looking at it in the wrong way :)
10:33:37 <oerjan> ehird_: oh i realized kibiLied   <- [True, False]; guard $ (kibiClaims /= kibi) == kibiLied
10:33:52 <vincenz> lol
10:33:54 <vincenz> use a let
10:33:54 <oerjan> is simply let kibiLied = kibiClaims /= kibi
10:34:25 <hpaste>  vincenz annotated "Kalotan puzzle in the list monad. Could possibly be cleaned up a bit." with "oerjan's note" at http://hpaste.org/6869#a7
10:34:37 * ehird_ is rewriting it as a list comprehension
10:35:00 <vincenz>  then guard $ kibiClaims == Male && ((kibi == Female) `xor` kibiLied)
10:35:05 <vincenz> this one is seriously odd
10:35:33 <vincenz> if he claims to be male
10:35:37 <vincenz> and he's female
10:35:43 <oerjan> vincenz: oh and let parent2 = not parent1
10:35:44 <vincenz> then how can that `xor` withy lying?
10:35:45 <hpaste>  ehird annotated "Kalotan puzzle in the list monad. Could possibly be cleaned up a bit." with "list comprehension" at http://hpaste.org/6869#a8
10:35:51 <oerjan> er wait
10:35:56 <oerjan> not a Boolean
10:36:34 <ehird_> oerjan: yes, that's a good point
10:36:40 <ehird_> hmm, is there a generic not?
10:36:50 <ehird_> like 'flip :: (Flippable a) => a -> a'
10:36:53 <hpaste>  vincenz annotated "Kalotan puzzle in the list monad. Could possibly be cleaned up a bit." with "clean" at http://hpaste.org/6869#a9
10:36:59 <bugQ> kibiClaims == Male && kibiLied covers the fact that kibi is Female
10:36:59 <ehird_> instance Flippable Sex where flip Male = Female; flip Female = Male
10:37:09 <ehird_> yeah
10:37:18 <vincenz> it's a paradox
10:37:22 <vincenz> if he claims to be male
10:37:24 <vincenz> and he is female
10:37:26 <vincenz> then he lied
10:37:28 <vincenz> so xor will give alse
10:37:32 <vincenz> cuase both are true
10:37:35 <vincenz> o.O
10:37:37 <ehird_> yep..
10:37:38 <vincenz> if he claims to be male
10:37:40 <vincenz> and he is male
10:37:42 <vincenz> then still false
10:37:45 <vincenz> cause false xor false is false
10:37:55 <vincenz> that statemnet is false whenver kibi claims to be mae
10:37:56 <bugQ> kibi == Female && kibiLied is the same thing
10:38:01 <vincenz> iow
10:38:11 <vincenz> guard $ kibiClaims /= Female
10:38:11 <bugQ> the if statement is useless
10:38:21 <vincenz> gotta run, dinner
10:40:31 <hpaste>  ehird annotated "Kalotan puzzle in the list monad. Could possibly be cleaned up a bit." with "TODO: remove paradox, thus possibly removing 'xor'" at http://hpaste.org/6869#a10
10:40:40 <ehird_> it occurs to me that we are incrementally manually solving the problem
10:40:52 <oerjan> ehird_: i was just thinking that too :D
10:40:56 <ehird_> i.e. converging onto manually writing `kalotan = [(Female,Male,Female)]`
10:41:15 <bugQ> heh, so we are.
10:41:38 <bugQ> this might even be easier with just some boolean algebra on paper
10:42:30 <ddarius> That's what newsham was saying earlier
10:42:48 <ddarius> [12:16] <newsham> if you minimize the logic, you could solve it without using haskell at all
10:43:22 <newsham> thats in effect what you're doing by manipulating your haskell program
10:43:25 <newsham> solving the problem
10:43:46 <newsham> wait you just said that.. sorry
10:44:06 <jsnx> Haskell strings are made of cons cells
10:44:16 <bugQ> hooray, we are all in agreement, let's stop now before it goes somewhere dangerous.
10:44:42 <ehird_> bugQ: it would be nice to get it down to a declarative style
10:44:42 <ehird_> like..
10:44:56 <jsnx> but ByteStrings are contiguous bytes in memory
10:44:56 <dons> hayoo looks cool
10:45:12 <ehird_> hmm
10:45:14 <ehird_> it would be very verbose
10:45:17 <ehird_> but i'll try it
10:45:34 <bugQ> isn't it technically declarative already (ya know, because it's Haskell)?
10:45:56 <newsham> i think the ideal haskell "solution" should read just like the problem statement
10:46:17 <newsham> not some minimalized boolean expression that bears no resemblance to the original declaration
10:46:18 <dons> http://holumbus.fh-wedel.de/ interesting
10:46:18 <lambdabot> Title: Holumbus
10:46:24 <ehird_> newsham: yeah
10:46:28 <ehird_> but it shouldn't read like my first paste
10:46:32 <ehird_> it should have factored stuff
10:46:40 <ehird_> like, the truth values should be a function thingy
10:46:47 <ehird_> so as to not hardcode the Male/Female thing
10:46:49 <ehird_> thingy
10:46:50 <ehird_> :)
10:46:50 <newsham> perhaps it would be better to start from the english problem statement rather than from the original scheme solution
10:46:55 <ehird_> yes
10:47:00 <ehird_> it is here: http://everything2.com/title/Teach%2520Yourself%2520Scheme%253A%252014.4%2520Logic%2520puzzles
10:47:02 <lambdabot> Title: Teach Yourself Scheme: 14.4 Logic puzzles@Everything2.com, http://tinyurl.com/6rwcjx
10:47:14 <ehird_> I guess, to start:
10:47:24 <ehird_> data Sex = Male | Female deriving (Show, Read, Enum, Eq)
10:47:30 <dons> http://reddit.com/info/6es80/details new web app stuff is cool
10:48:05 --- mode: irc.freenode.net set +o ChanServ
10:48:07 <ehird_> The Kalotans are a tribe with a peculiar quirk.6 Their males always tell the truth. Their females never make two consecutive true statements, or two consecutive untrue statements.
10:48:13 <ehird_> I guess we want:
10:48:17 <ehird_> truths :: [a] -> [[Bool]]
10:48:28 <ehird_> i.e. give it a list of statements (which are ignored), and it will give you all the possibilities
10:48:37 <ehird_> one possibility is a mapping of statements to truths
10:48:47 <ehird_> err
10:48:50 <ehird_> [a] -> Sex ->
10:48:52 <ehird_> so
10:49:06 <ehird_> truths [foo,bar,baz] Male ==> [[True,True,True]]
10:49:25 <ehird_> truths [foo,bar,baz] Female ==> [[True,False,True],[False,True,False]]
10:51:49 <ehird_> right?
10:52:11 <oerjan> actually what about Sex -> [Bool] -> Bool ?
10:52:21 <jsnx> are ByteStrings the only data structure in haskell that is mapped straight to a C style array?
10:52:24 <oerjan> checking if the list is consistent with the sex
10:52:39 <ehird_> oerjan: isn't that a bit inverse to the problem dsecription though?
10:53:04 <ddarius> jsnx: bytestrings aren't mapped straight to a C style array and the bytestring library is built atop the FFI
10:53:10 <oerjan> i don't see why
10:53:13 <sjanssen> jsnx: StorableArray
10:53:34 --- mode: irc.freenode.net set +o ChanServ
10:53:42 <jsnx> sjanssen: oic
10:54:16 <jsnx> ddarius: well, are they backed with a C style array?
10:54:41 <jsnx> sjanssen: thanks, i will look at that
10:55:00 <jsnx> ddarius: that's what i meant
10:55:21 <oerjan> ehird_: iiuc you set up the parents, the claimant and then you use that function to check the claimant's statement?
10:55:24 <ddarius> jsnx: Yes
10:55:41 <oerjan> *kibi
10:57:48 <oerjan> oh it's more complicated
10:57:49 <ehird_> oerjan: but my type ENCODES the facts about the sexes
10:59:50 <jsnx> i have a friend in java-land who had a neat way of explaining efficient, un-extendable data structures -- he said they should be "final", like classes that can not be extended
11:00:09 <jsnx> i imagine having "final" arrays could work well for many applications in haskell
11:00:29 <jsnx> does anybody else see a need for these things?
11:00:53 <SamB> don't we already have final arrays?
11:00:58 <Cale> Um, all Haskell datatypes are final by default?
11:01:08 <shapr> Yeah, I was wondering about that.
11:01:11 <Cale> We don't have subtype polymorphism
11:01:14 <jsnx> Cale: well, not really
11:01:14 <shapr> Nothing is mutable in Haskell.
11:01:19 <SamB> what do you mean by "extended"?
11:01:32 <jsnx> for example, lists
11:01:40 <Jaak> lists are final...
11:01:43 <jsnx> they are designed to have new elements tacked on the front
11:01:49 <Jaak> pretty darn final
11:01:49 <jsnx> so they can be "extended"
11:01:51 <SamB> well, are arrays are totally final
11:02:04 <SamB> of course, you also can't replace an element...
11:02:13 <Jaak> (:) makes a new array, old one doesnt get mutated
11:02:14 <ddarius> "final" is a horrible word for this.  It was a horrible keyword in Java too.
11:02:15 <jsnx> sure, you replace the whole array
11:02:17 <Jaak> erm, list*
11:02:24 <jsnx> ddarius: well, okay
11:02:34 <oerjan> jsnx: even the mutable arrays haskell provides are not extendable (unless there are some hidden away on hackage or something)
11:02:34 <jsnx> i guess what i mean is, read-optimized data structures
11:02:46 <SamB> ah
11:02:58 <SamB> isn't that what our arrays are?
11:03:25 <jsnx> it's not really possible to use our arrays to make 150,000 integer arrays, for example
11:03:40 <SamB> isn't it?
11:03:44 <Cale> Yes it is.
11:03:51 <jsnx> okay, hold
11:03:53 <jsnx> on
11:03:59 <SamB> just don't use // on them ;-)
11:04:01 <jsnx> it's not possible to do so *statically*
11:04:16 <SamB> probably not ;-)
11:04:18 <jsnx> you can't use these arrays to make data sections, in other words
11:04:35 <jsnx> we need some kind of type/module/class for that
11:04:40 <Cale> what?
11:04:42 <jsnx> (or, i need one)
11:04:45 <Cale> I don't understand
11:04:53 <SamB> you want to improve the compiler's handling of literal arrays?
11:05:07 <SamB> or what?
11:05:09 * ddarius just realized he's using GHC 6.8.1
11:05:34 <jsnx> module Big.Chinese.Dictionary where allOfChinese = [<lots of chinese>]
11:05:41 <SamB> ddarius: what did you think you were using?
11:05:49 <Cale> Oh, yeah, we don't have array literals, but that's not usually a problem, because if you put an array in a CAF, it will only be evaluated once.
11:05:55 <ddarius> SamB: 6.8.2
11:06:00 <jsnx> SamB: the compiler doesn't have 'literal arrays'
11:06:08 <SamB> details!
11:06:12 <Cale> jsnx: Usually you'd load that sort of thing from a file.
11:06:18 <SamB> true enough
11:06:30 <jsnx> Cale: wrong answer for "all in one" binary distribution, though
11:06:41 <jsnx> Cale: it also makes for longer load times
11:06:42 <SamB> I'm trying to think how you could get those through the compiler
11:06:49 <jsnx> SamB: so am i
11:06:53 <Cale> Then maybe "all in one" binary distribution isn't the answer for you?
11:06:58 <jsnx> right now, i use C :(
11:07:01 <SamB> without wasting an assload of RAM
11:07:11 <jsnx> Cale: well, there's always C
11:07:29 <jsnx> Cale: it just seems sill to have to switch languages for this, though
11:07:39 <hpaste>  newsham annotated "Kalotan puzzle in the list monad. Could possibly be cleaned up a bit." with "a different approach?" at http://hpaste.org/6869#a11
11:07:40 <Cale> Why not just load from a file? It only adds one file.
11:07:52 <SamB> jsnx: well, do you know about GHCs byte array literals?
11:08:00 <jsnx> SamB: yes i do
11:08:17 <SamB> have you tried using 'em?
11:08:25 <dbpatterson> any advice for http client library of choice for getting at (json) apis? (right now I'm looking at adam langleys network-minihttp and the curl binding...)
11:08:28 <SamB> does GHC run out of memory when you try?
11:08:36 <jsnx> SamB: it's not a good solution for a big list of ints
11:08:53 <jsnx> SamB: i mean, how many bytes are in an int?
11:08:58 <newsham> ehird_: thoughts?
11:09:05 <SexyGirL> #ChatworLD
11:09:06 <SexyGirL> #ChatworLD
11:09:07 <SamB> point, point
11:09:08 <SexyGirL> #ChatworLD
11:09:09 <SexyGirL> #ChatworLD
11:09:10 <SexyGirL> #ChatworLD
11:09:11 <dbpatterson> ban
11:09:13 <jsnx> SamB: and how many are in the string i make with an int?
11:09:23 <ehird_> newsham: on what
11:09:55 <TomMD> Any chance we can give lambdabot ops and a flood control plugin?
11:10:02 <SamB> jsnx: well, the idea is you would just use a string literal that would represent the bytes of the int (in big-endian)
11:10:16 <jsnx> SamB: why big-endian?
11:10:20 <SamB> well, a portion of the string literal
11:10:24 <jsnx> SamB: yeah, that's an idea
11:10:26 <Cale> TomMD: I wouldn't give lambdabot ops.
11:10:31 <SamB> jsnx: little endian would also work
11:10:32 <TomMD> Unsafe?
11:10:36 <Cale> TomMD: However, a much simpler bot, perhaps :)
11:10:41 <mauke> unsafeGiveOps
11:10:44 <SamB> but you'd want to be picking one
11:10:49 <jsnx> SamB: but basically, what happens there is i implement pointer arithmetic
11:10:59 <jsnx> SamB: which is okay
11:10:59 <TomMD> Lets prove an IRC bot in Isabelle, give it ops and a flood control plugin.
11:11:08 <jsnx> but it seems unnecessary
11:11:33 <newsham>  http://hpaste.org/6869#a11
11:11:35 <SamB> jsnx: I was thinking maybe you could have a bunch of several-k byte array literals
11:11:40 <Jedai> Couldn't you use the lift facility in Template Haskell to do "array literals" ?
11:11:48 <jsnx> SamB: i know there are existing solutions
11:12:01 <SamB> and lazilly transform them into a nicer datastructure
11:12:05 <jsnx> i'm just saying, they are a litte round-about for something so conceptually straight forward
11:12:28 * ddarius would just stick the literal in a C array in an .c file and link it in if not having extra files was a hard requirement.
11:12:29 <jsnx> SamB: the lazy is actually really bad in this case
11:12:37 <SamB> well, what you really don't want is for GHC to generate a Data.Map.Map statically ;-)
11:12:40 <jsnx> since i do a binary search on tens of thousands of ints
11:12:57 <SamB> jsnx: I meant, one chunk at a time
11:12:59 <jsnx> SamB: no, making every type 'static' would be a problem
11:13:14 <SamB> because that would have an insane number of relocations ;-)
11:13:15 <jsnx> SamB: yeah, but then there's all these damn thunks
11:13:44 <SamB> okay, why DO you want an all-in-one-file solution?
11:13:54 <jsnx> SamB: but it seems like the only "array literal" in haskell is the ByteString
11:14:01 <jsnx> SamB: it is easy for users
11:14:14 <jsnx> SamB: they don't care if i write their stuff in Haskell or not
11:14:16 <SamB> hey, I meant the primitive kind
11:14:35 <SamB> the ones that look like this "\124\241"#
11:14:39 <Jedai> Why aren't UArray lifted by template Haskell a good solution ??
11:14:55 <SamB> Jedai: how does TH lift those?
11:15:04 <jsnx> SamB: also, if the data is a haskell value, i don't have to worry about the IO Monad and all that mess
11:15:11 <SamB> does it use an array in all intermediate representations ?
11:15:52 <jsnx> SamB: i managed to frame my problem in a way that can be solved purely functionally -- it'd be nice if the program were purely functional, too. so i guess this aesthetic as well as practical
11:16:12 <ddarius> jsnx: Just link in a C literal.
11:16:20 <jsnx> ddarius: that's what i'm doing
11:16:23 <SamB> yeah, that's pretty much what I think too
11:16:30 <jsnx> ddarius: but damn, that's rough...
11:16:41 <ddarius> jsnx: Why?
11:16:41 <SamB> you could make an array of HsInts if you wanted
11:16:55 <jsnx> ddarius: because, i had to learn all this extra stuff
11:17:25 <SamB> jsnx: well, I'm not sure what else we can do for inherently low-level desires?
11:17:25 <jsnx> ddarius: i'm not trying to do any fancy C stuff, so the marginal return is pretty small on my investment
11:17:38 <jsnx> SamB: okay
11:17:48 <jsnx> SamB: just to clarify this for me
11:18:01 <ddarius> jsnx: All you needed to learn was a foreign import statement.
11:18:03 <SamB> yes?
11:18:13 <ehird_> @src Maybe mplus
11:18:13 <lambdabot> Nothing `mplus` ys  = ys
11:18:13 <lambdabot> xs      `mplus` _ys = xs
11:18:14 <jsnx> static/final/read-optimized random access arrays would not be just a module thing
11:18:16 <SamB> ddarius: and what to do with the Ptr after
11:18:40 <jsnx> they'd require some kind of compiler extension
11:18:47 <hpaste>  newsham annotated "Kalotan puzzle in the list monad. Could possibly be cleaned up a bit." with "ehird_: fleshed out" at http://hpaste.org/6869#a12
11:19:08 <jsnx> ddarius: i haven't used C in a long time -- had to relearn all that syntax, learn how to get Cabal to compile it -- it wasn't easy at all
11:19:10 <ehird_> newsham: cool
11:19:18 <ehird_> i will make a 'perfect' version in a second
11:19:18 <ehird_> :p
11:19:36 <SamB> jsnx: the compiler would need a way of passing unboxed data more-or-less directly through, without trying to put it in a list at any point, I think
11:19:36 <ddarius> jsnx: The only thing that needs to be in the C file is a C array literal.
11:19:41 <Jaak> why isn't there UArray instance of pairs (if both components have UArray instances)? pairs are not strict enough?
11:19:52 <Tordek> is _ on a function definition a special name that's discarded, or just stylistic?
11:19:58 <jsnx> ddarius: yeah
11:20:01 <jsnx> ddarius: and it's length
11:20:03 <SamB> Jaak: it is hard to write
11:20:07 <Jaak> > let _ = 1 in _
11:20:07 <lambdabot>  Parse error in expression at end of input
11:20:11 <SamB> Jaak: and just think of the alignment issues
11:20:14 <Jaak> > let f _ = 1 in f _
11:20:14 <lambdabot>  Parse error in expression at end of input
11:20:16 <Jaak> > let f _ = 1 in f 1
11:20:17 <lambdabot>  1
11:20:20 <SamB> Jaak: it would probably be really slow
11:20:21 <Jaak> bah
11:20:25 <Jaak> oh, okay
11:20:32 <Jaak> yeah, makes sense
11:20:49 <jsnx> SamB: so basically, if i want this to happen, i need to fiddle with GHC -- and make some 'magic' datatype or keyword or whatever that does this
11:21:17 <ehird_> Tordek: special
11:21:20 <jsnx> SamB: which is probably more work than doing all the C non-sense i've already done, but would be useful to a lot more people
11:21:39 <SamB> jsnx: something along those lines
11:21:46 <ehird_> newsham: also, Gender is a completely ridiculous term to use here
11:21:52 <ehird_> it's operating over sexes
11:21:53 <SamB> I would actually not want to add keywords for this
11:22:00 <jsnx> SamB: yeah, i agree
11:22:15 <SamB> I would probably come up with a way to represent these arrays in TH
11:22:15 <newsham> i dont understand.
11:22:23 <newsham> whats the diff btwn gender and sex?
11:22:35 <jsnx> SamB: ? without extending GHC in anyway?
11:22:44 <SamB> jsnx: no, GHC would need extending too
11:22:51 <ehird_> newsham: well, technically, sex is defined by biology.
11:22:54 <ehird_> but gender is defined mentally.
11:22:56 <SamB> anytime you actually extend TH, GHC needs to be changed too ;-)
11:23:00 <Tordek> words have gender; animals have sexes
11:23:05 <jsnx> SamB: why TH?
11:23:08 <SamB> (if you just add a utility function, that doesn't really count)
11:23:13 <ehird_> sex seems to be what the puzzle is about
11:23:15 <oerjan> newsham: gender is a word you use on forms to prevent people from answering "Yes, please"
11:23:20 <newsham> data Sex = Yes | No | Maybe;
11:23:25 <ehird_> and the use of gender where 'sex' would be right is a euphemism
11:23:34 <ehird_> oerjan: A++ would laugh again
11:24:07 <newsham> i dont mean to offend any trans-gendered type people, but umm.. arent you splitting hairs a little?
11:24:12 <ehird_> newsham: | Christian (forall a. a -> IO Baby)
11:24:15 <newsham> "completely ridiculous" is kind of a strong judgement
11:24:17 <ehird_> delayed until marriage
11:24:21 <SamB> jsnx: well, it would be handy to be able to snarf the array from wherever you wish, wouldn't it? also it's the only way I can think of that would (a) avoid having to add a new Haskell syntax and (b) not use huge amounts of RAM
11:24:32 <ehird_> newsham: i hate euphemisms
11:24:32 <Syzygy-> data Sex = Male | Female | Other | InTransit | Yes | No | Maybe
11:24:33 <ehird_> :)
11:24:54 <Botje> Syzygy-: you forgot FileNotFound
11:24:55 <ehird_> data Sex = Pineapple | March | Garden [Sex]
11:25:12 <jsnx> SamB: yeah, i see your point
11:25:21 <jsnx> SamB: points
11:25:31 <ehird_> also, Boy | Girl is funny
11:25:45 <ehird_> since its used for the parents too
11:25:52 <jsnx> SamB: so TH would generate the ByteString and generate the functions that read/write it
11:25:55 <Syzygy-> Boy | Girl | Butch | Femme | DiaperPlay | AgePlay | ....
11:26:11 <SamB> if you wanted to do it by having the compiler be extra smart, without extending the language, the compiler would have to build huge parse trees...
11:26:16 <newsham> male | female is way too formal :)
11:26:22 * jsnx /ban Syzygy- 
11:26:30 <Syzygy-> jsnx: Pbtbtbtbtbtbtbt
11:26:32 <SamB> jsnx: oh, that's a nice idea
11:26:43 <ehird_> data Statement = KibiSaidBoy | KibiIsGirl | KibiLied
11:26:44 <ehird_> hee
11:26:49 <ehird_> newsham: Guy | Gal
11:26:52 <newsham> anyway, i just wanted to write a program, not enter into a philosophical discussion (which should be continued on -blah) on gender, sex, age and social roles
11:27:10 <Botje> ehird_: StandUp | SitDown :p
11:27:11 <SamB> jsnx: I was thinking that it would be possible to add "array literals" to TH's AST datetypes
11:27:27 <ehird_> Botje: I would continue, but it would become NSFW
11:27:29 <jsnx> SamB: and then we'd have 'array indexing functions'
11:27:30 <SamB> a kind that actually used an array to represent the literal
11:27:38 <jsnx> SamB: (don't want to leave out the arrows)
11:27:39 <newsham> how does the kaloprop apply to transgendered individuals?
11:27:43 <newsham> the problem statement is incomplete
11:28:13 <ehird_> newsham: read the puzzle
11:28:17 <ehird_> it is defined over (male,female)
11:28:25 <jsnx> SamB: the only thing i care about with these massive arrays is randomAccess
11:28:41 <ehird_> @hoogle [a] -> [b] -> [b]
11:28:41 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
11:28:41 <lambdabot> Data.List.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
11:28:41 <lambdabot> Prelude.zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
11:28:46 <ehird_> hmm
11:28:52 <oerjan> newsham: actually doesn't the problem also assume that Kibi answers the question?  what if he/she said "None of your damn business"?
11:28:53 <ehird_> @type replicate
11:28:54 <lambdabot> forall a. Int -> a -> [a]
11:29:02 <ehird_> truths xs Male = replicate (length xs) True
11:29:05 <jsnx> there could be some operator like, uhm... /o\
11:29:09 <jsnx> or \o/
11:29:09 <SamB> jsnx: well, I was thinking that GHC could then generate constant array values, in the .rdata section
11:29:16 <jsnx> SamB: oic
11:29:25 <jsnx> SamB: go ahead
11:29:35 <jsnx> SamB: so, we'd just use !! ?
11:29:35 <newsham> oerjan: the problem statement says that these three individuals all gave statements in response to the question
11:30:17 <SamB> jsnx: well, hmm, I haven't figured out how they would be converted back to arrays proper ;-)
11:30:26 <oerjan> newsham: "That's none of your damn business" is a statement too :)
11:31:00 <hpaste>  ehird pasted "Starting over with kibi. This encodes the truth-telling of the Kalotans." at http://hpaste.org/6870
11:31:06 <ehird_> elegant function :)
11:31:15 <newsham> so I guess technically kibi could have said "none of your business" in which case parent1 lied by saying "kibi said kibi is a boy"
11:31:22 <newsham> which would make parent 1 the wife
11:31:27 <SamB> jsnx: anyway, you should go ahead and post a "feature request" to trac
11:31:27 <ehird_> I think my Statement is funny
11:31:27 <newsham> and parent 2 the husband
11:31:28 <ehird_> :)
11:31:37 <ehird_> hmm wait
11:31:38 <ehird_> we need
11:31:42 <newsham> which would mean that kibi lied (it was our business!) and kibi is a girl
11:31:42 <ehird_> IAmBoy | IAmGirl too
11:31:47 <ehird_> for kibi's statements
11:31:48 <ehird_> no?
11:31:48 <newsham> since parent 2 is the dad and truthful
11:31:54 <SamB> jsnx: if you do, go ahead and put me in the "cc" field (just type SamB)
11:31:59 <ehird_> yes, i think i do
11:32:00 <newsham> so there is a second solution!
11:32:52 <SamB> jsnx: you would do that by going here: http://hackage.haskell.org/trac/ghc/newticket?type=feature+request
11:32:52 <ehird_> anyway, with my 'truths' and Statement I think I can get a very elegant solution
11:32:54 <lambdabot> http://tinyurl.com/55dv46
11:33:29 <ehird_> solve :: ([Statement],[Statement]) -> (Sex,Sex,Sex)
11:33:32 <SamB> jsnx: but don't hold your breath waiting for someone to implement it ;-)
11:33:37 <ehird_> solve (parent1statements,parent2statements)
11:33:50 <oerjan> newsham: yay :)
11:34:01 <ehird_> hmm
11:34:07 <ehird_> I should hardcode the statements
11:34:10 <ehird_> otherwise it'll be ugly
11:34:31 <jsnx> SamB: yeah, thanks
11:35:00 <jsnx> SamB: i will put in the request and see if i can figure out how to do it
11:35:26 <ehird_>       kibiSaid <- [IAmBoy,IAmGirl], -- snippit from what i'm doing
11:36:31 <ehird_>       truths [KibiSaidBoy] p1 -- now figuring out what to do with this
11:39:04 <ddarius> sjanssen: Is StorableVector/StorableArray on hackage somewhere?
11:40:08 <dcoutts> Lemmih: so I might be able to stop in Landskrona between 11:30am - 5:30pm on Wednesday 9th, would that work for you?
11:40:10 <ehird_> hmm
11:40:12 <ehird_> this part is hard
11:40:13 <ehird_> :)
11:40:41 <hpaste>  newsham annotated "Kalotan puzzle in the list monad. Could possibly be cleaned up a bit." with "cleaned up a little" at http://hpaste.org/6869#a13
11:41:00 <SamB> ddarius: it isn't in the array package?
11:41:01 * ehird_ comprehensionifies newsham's
11:41:49 <newsham> this problem is sexist.
11:42:56 <ehird_> newsham: you don't need to [male,female] parent2
11:42:56 <ddarius> SamB: That's something else
11:42:59 <ehird_> the couple is hetero
11:42:59 <ehird_> so
11:43:07 <ehird_> let parent2 = case parent1 of Male -> Female; Female -> Male
11:43:16 <ddarius> (parent1,parent2) <- [(Male,Female),(Female,Male)]
11:43:18 <newsham> my first guard handles that constraint
11:43:25 <ehird_> newsham: uhh
11:43:29 <ehird_> at the cost of tons of efficiency
11:43:35 <ehird_> because it will TRY Male,Male and Female,Female
11:43:40 <ehird_> add that to the other constraints
11:43:41 <ehird_> and wooosh
11:43:47 <ehird_> ddarius: same problem
11:43:49 <newsham> if i was optimizing the solution I would solve it ahead of time
11:43:51 <ddarius> ehird_: It certainly won't be "tons" of efficiency.
11:43:51 <ehird_> I think
11:43:53 <ehird_> oh wait, no
11:43:53 <newsham> and solve it in O(0) time
11:43:54 <ehird_> hah
11:43:55 <ehird_> that's true
11:43:56 <ehird_> :)
11:46:21 <ehird_> newsham: drop 1 == tail
11:46:33 <newsham> point ehird_
11:46:38 <ddarius> ehird_: Not in general
11:46:52 <ehird_> newsham: yours solves [(Female,Female,Male)]
11:46:54 <ehird_> that's wrong
11:47:11 <EvilTerran> drop 1 [] = []; tail [] = _|_
11:47:23 <ehird_> ok, yeah
11:47:24 <ehird_> i guess
11:47:27 <newsham> err yes, mine requires drop 1 [] == []
11:47:32 <newsham> err i guess it doesnt
11:47:35 <newsham> nevermind
11:47:42 <ehird_> newsham: doesn't, but is wrong
11:48:03 <newsham> what is the proper solution?
11:48:21 <ehird_> female,male,female
11:48:22 <ehird_> iirc
11:48:38 <newsham> p1 cant be male if kibi is female
11:48:48 <newsham> err wait
11:49:11 <ehird_> > kalotan
11:49:11 <ehird_> [(Female,Male,Female)]
11:49:13 <ehird_> that's from mine
11:49:17 <lambdabot>   Not in scope: `kalotan'
11:49:26 <newsham> keep in mind that your output order differs from mine
11:50:11 <newsham> mine returns: kibi lied, kibi is female, p1 is female, p2 is male
11:50:22 <newsham> yours returns p1 is female, p2 is male, kibi is female
11:50:25 <newsham> we are in agreement
11:50:42 <jaj> is it possible to have a repeating pattern in a template when you use HStringTemplate? I want to write a blog for my site and I want to have 1 template for a post which is filled repeatedly with data from the database.
11:50:49 <Lemmih> dcoutts: Yeah, that would suit me fine.
11:50:49 <lambdabot> Lemmih: You have 1 new message. '/msg lambdabot @messages' to read it.
11:54:18 <hpaste>  ehird annotated "Kalotan puzzle in the list monad. Could possibly be cleaned up a bit." with "cleaned up newsham" at http://hpaste.org/6869#a14
11:55:23 <ehird_> http://hpaste.org/6869#a14 is definitely the most elegant so far
11:56:01 <ehird_> hmm
11:56:09 <ehird_> data Foo = Sure Sex | Unsure [Sex]
11:56:11 <ehird_> ?
11:56:14 <ehird_> bah
11:56:14 <newsham> ehird: now post that back on the original site?
11:56:16 <ehird_> *nah
11:56:21 <ehird_> newsham: ?
11:56:24 <ehird_> oh
11:56:27 <ehird_> that's on everything2
11:56:28 <ehird_> and iirc is a copy
11:56:30 <ehird_> of a real book
11:56:53 <roconnor> ehird_: (==) is associative
11:57:25 <ehird_> > zipWith (/=) [1,2,3] [2,3]
11:57:25 <lambdabot>  [True,True]
11:57:43 <ddarius> roconnor: Not between different types.
11:57:43 <ehird_> o.O
11:57:53 <newsham> roconnor: but the problem reads that parent1 said that kibi said that kibi is male
11:57:56 <ehird_> > zipWith (/=) [1,2,3] [2,3,4,5]
11:57:56 <roconnor> ddarius: oh right
11:57:56 <lambdabot>  [True,True,True]
11:57:58 <ehird_> err, wait
11:58:01 <ehird_> even wit th-
11:58:02 <ehird_> hmm
11:58:05 <roconnor> damn polymorphism
11:58:07 <ehird_> newsham: isTrue is weird
11:58:21 <ehird_> > (\xs -> and $ zipWith (/=) xs (tail xs)) [1,2,3]
11:58:22 <lambdabot>  True
11:58:23 <newsham> s/isTrue/kalotanStatements/
11:58:36 <ehird_> :/
11:58:42 <ehird_> > (\xs -> zipWith (/=) xs (tail xs)) [1,2,3]
11:58:42 <lambdabot>  [True,True]
11:58:46 <Heffalump> did something change with readline between 16/03 and 23/03 in ghc HEAD? backspace turns into ^H in the latter snapshot but not the former.
11:58:55 <newsham> ehird: 1 /= 2 && 2 /= 3
11:59:08 <ddarius> @users
11:59:08 <lambdabot> Maximum users seen in #haskell: 472, currently: 470 (99.6%), active: 16 (3.4%)
11:59:18 <ehird_> > let alternate 0 _ _ = []; alternate n a b = a : b : alternate (n-1) b a in alternate 3 'a' 'b'
11:59:19 <lambdabot>  "abbaab"
11:59:26 <ehird_> > let alternate 0 _ _ = []; alternate n a b = a : b : alternate (n-2) b a in alternate 3 'a' 'b'
11:59:27 <lambdabot>  "abbaabbaabbaabbaabbaabbaabbaabbaabbaabbaabbaabbaabbaabbaabbaabbaabbaabbaabb...
11:59:32 <ehird_> oh hm
11:59:42 <ehird_> > let alternate 0 _ _ = []; alternate n a b = a : alternate (n-1) b a in alternate 3 'a' 'b'
11:59:42 <lambdabot>  "aba"
11:59:58 <ehird_> > let alternate 0 _ _ = []; alternate n a b = a : alternate (n-1) b a in (alternate 3 True False,alternate 3 False True)
11:59:58 <lambdabot>  ([True,False,True],[False,True,False])
12:00:03 <ehird_> truth-info for females
12:00:38 <roconnor> for god's sake, a google search for `Kalotan puzzle' ranks hpaste.org/6869 at #4
12:00:49 <EvilTerran> > let alternate n x y = take n (fix $ (x:).(y:)) in alternate 5 'a'
12:00:51 <lambdabot>  <Char -> [Char]>
12:00:52 <EvilTerran> > let alternate n x y = take n (fix $ (x:).(y:)) in alternate 5 'a' 'b' -- er
12:00:52 <lambdabot>  "ababa"
12:00:57 <Botje> lol
12:00:59 <Botje> they're quick.
12:01:15 * EvilTerran notes that he should've just used cycle in that
12:01:24 <EvilTerran> > let alternate n x y = take n (cycle [x,y]) in alternate 5 'a' 'b' -- er
12:01:24 <lambdabot>  "ababa"
12:01:32 <ehird_> > let alternate n x y = take n (cycle [x,y]) in alternate 3 'a' 'b'
12:01:33 <lambdabot>  "aba"
12:01:34 <ehird_> hah!
12:01:51 <Botje> :t \x y -> (x:y:)
12:01:52 <lambdabot>     The operator `:' [infixr 5] of a section
12:01:52 <lambdabot>         must have lower precedence than the operand `(:)' [infixr 5]
12:01:52 <lambdabot>         in the section: `(x : y :)'
12:02:02 <Botje> aww, doesn't work
12:02:16 <ehird_> :t \x y -> (x:).(y:)
12:02:16 <lambdabot> forall a. a -> a -> [a] -> [a]
12:02:39 <Botje> yeah
12:02:43 <Botje> that's an option
12:02:44 <roconnor> ehird_: that is a pretty nice solution
12:02:54 <ehird_> roconnor: the katolan one?
12:03:00 <ehird_> if so, isTrue is the wrong name
12:03:02 <roconnor> yep
12:03:08 <ehird_> dunno what  agood name for it is
12:03:13 <roconnor> sure, isTrue is a crap name
12:03:14 <ehird_> also, kibiSaid is (not kibiLied)
12:03:20 <ehird_> gonna revise it
12:03:25 <roconnor> but you nicely restate all the facts
12:03:29 <roconnor> as guards
12:03:41 <newsham> yah, isTrue is the wrong name
12:03:47 * EvilTerran wishes sections worked so (x:y:) = (\z -> x:y:z)
12:03:51 <newsham> it should be something about kalotan statements
12:03:53 <SamB> how well does Cabal work with multiple GHC installations?
12:04:08 <EvilTerran> that'd involve splicing around with the syntax tree, but i think it'd be worth it
12:04:14 <newsham> kalotanStatementsBySex ?  ;-)
12:04:39 <ehird_> roconnor: I am trying to make kibiSaid a Sex
12:04:53 <newsham> kibiSaid is a statement that is either true or false
12:05:00 <newsham> other people make statements about kibiSaid
12:05:16 <SamB> I'm wondering whether to try installing this GHC 6.9 I built with a custom primitive...
12:05:20 <ehird_> newsham: no
12:05:23 <ehird_> kibiSaid == What kibi said
12:05:26 <ehird_> maybe you meant:
12:05:27 <ehird_> kibiLied
12:05:28 <EvilTerran> (EXP `op`) --> (\fresh -> EXP `op` fresh) as compared to the current version, (EXP `op`) -> (op (EXP)))
12:05:41 <roconnor> ehird_: i might call isTrue, validStatmentsBy
12:06:01 <ehird_> isTru kibi [kibiSaid] -- this isn't in the original description, actually
12:06:06 <newsham> ok, so how are you going to tie the statement "kibi said kibi is male" to kibiSaid and kibisSex?
12:06:09 <roconnor> ehird_: or perhaps call it `allowedToSay` and make it infix
12:06:57 <ehird_> ooh, wait a sec
12:07:01 <ehird_> i might have a very elegant solution
12:07:13 <newsham> i already gave one.  ;-)
12:08:35 <ehird_>       prop parent1 [kibiSaid == Male],
12:08:35 <ehird_>       prop parent2 [kibi == Female, kibiSaid == Female]
12:08:38 <ehird_> that's two lines i have right now
12:08:43 <ehird_> which is an EXACT translation of:
12:08:50 <ehird_> One of them says: ``Kibi said: `I am a boy.' '' The other adds: ``Kibi is a girl. Kibi lied.''
12:08:58 <ehird_> err wait
12:09:00 <ehird_> kibiSaid == Male
12:09:01 <ehird_> ofc
12:09:01 <ehird_> :)
12:09:35 <gwern> wow, you guys are still working on that kibi? must be an awfully hard problem
12:10:07 <ehird_>       prop kibi [kibi == kibiSaid],
12:10:08 <ehird_> :)
12:10:11 <ehird_> gwern: just making it elegant
12:11:26 * gwern means, when I left, you guys had been discussing it for a while. I then read half a book and finished it, did some chores, and came back to look up books by Stewart Brand - and y'all were still discussing it
12:11:29 <Pfft_> I'm trying to define a datatype like this:  data Type where { Base :: Type ; (-->) :: Type -> Type -> Type }
12:12:06 <Pfft_> But ghci chokes on the symbol -->  . Most other weird stuff, like (:->)  , works.
12:12:16 <mauke> needs to start with an uppercase symbol
12:12:17 <Pfft_> What's wrong with that particular sequence of characters?
12:12:21 <gwern> isn't -- a comment?
12:12:25 <Pfft_> Oh
12:12:25 <Saizan> Pfft_: it must start with (:)
12:12:41 <gwern> -- > example code for haddock appears the same as --> so far as I understand things
12:13:08 <Saizan> > let a ----> b = a + b in 1 ----> 2
12:13:08 <mauke> > let a --> b = 2 in a --> c
12:13:08 <lambdabot>  3
12:13:09 <lambdabot>  2
12:13:19 <ddarius> gwern: That's not the comment.
12:13:23 <ddarius> er problem
12:13:27 <ddarius> (jesus)
12:13:39 <Pfft_> Mm, you can define functions called -->, but not data constructors it seems.
12:13:53 <mauke> you can also define functions called 'foo', but not data constructors
12:14:00 <ddarius> Pfft_: Data constructors must start with capital letters, : is the "capital" operator character.
12:14:00 <Pfft_> So : counts as Uppercase, basically?
12:14:04 <mauke> yes
12:14:10 <Pfft_> Ok, thank you.
12:14:44 <fnord123> hey all. yaht and soe don't have much material on implementing a writer monad. I'm interested in writing one for some graphics stuff (playing with design) and was wondering if someone knew of some good pdfs that cover this material
12:14:55 <gwern> ddarius: it isn't? so comments must have spaces after... presumably you could define a {-- then?
12:15:07 <ddarius> gwern: { isn't an operator character
12:15:36 <mauke> @src Writer
12:15:36 <lambdabot> Source not found. Maybe if you used more than just two fingers...
12:16:28 <heatsink> gwern: You can define a --- operator though.
12:16:38 <gwern> heatsink: madness!
12:17:08 <mauke> <PoppaVic> .net is not much different than a new wrapper around lisps or forths, and I lean to the latter.
12:18:05 <ehird_> mauke: poppavic's stream of nonsense is so funny
12:18:07 <lament> PoppaVic is pretty famous
12:18:08 <ehird_> better than any markov chain
12:18:11 <lament> and the main reason i'm not in ##C
12:18:28 <heatsink> @poppavic
12:18:28 <lambdabot> Unknown command, try @list
12:18:40 <EvilTerran> ?quote poppavic
12:18:40 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
12:18:50 <lament> he makes any sort of an intelligent discussion there quite difficult
12:19:04 <mauke> lament: yeah :/
12:19:06 <lament> since all the speakers have to tacitly agree to ignore him completely
12:19:21 <ehird_> lament: unfortunately all of the most active people are fans of his
12:19:23 <ddarius> And they don't?
12:19:58 <fnord123> @src WriterT
12:19:58 <lambdabot> Source not found. Sorry.
12:20:00 <ehird_> ddarius: Pretyt much
12:20:09 <lament> ddarius: the other regulars are themselves somewhat irregular
12:20:18 <lament> (eg Zhivago)
12:20:41 <ehird_> http://66.102.9.104/search?q=cache:7pZIrCjdu0UJ:ortdotlove.net/poppavic_wisdom.html+poppavic&hl=en&ct=clnk&cd=7
12:20:44 <lambdabot> http://tinyurl.com/5n2fsn
12:20:57 <ddarius> Anyone who hangs out on IRC for extended periods of time is bound to be less than normal.
12:21:06 <gwern> (we are the curry street irregulars)
12:21:33 <lament> ddarius: certainly, but there're limits
12:21:35 <ehird_> unfortunately poppavic has a  high standing in ##C so he will remain there
12:21:41 <dons> ddarius: i prefer super-normal
12:21:50 <ehird_> ##C-sane would be nice
12:21:51 <ehird_> :p
12:21:59 <dons> uber-normal is also ok
12:22:21 <lament> ddarius: and it seems the usage of Forth in particular does a lot to bring people out of these limits (or maybe Forth is just the effect)
12:22:22 <ddarius> dons: I'm not really sure normality is part of an ordering anyway
12:22:28 <dons> :)
12:22:44 <ehird_> forthers tend to have really weird personalities, yeah
12:22:52 <lament> ddarius: consider http://www.colorforthray.info/
12:23:13 <lament> the author hangs out in #forth, and i won't question his sanity publicly
12:23:28 <fnord123> yeah, personalities weird really have to tend forthers
12:23:41 <gwern> 'I'm dealing with several illnesses,,,'
12:24:01 <gwern> I wonder how well haddock handles .lhs
12:24:12 <allbery_b> seye sih sllor em\
12:24:15 <lament> "colorForth can not help but be the one operating system in the world capable of being totally open and at the same time the most quickly understandable by children."
12:24:16 <ehird_> lament: the clue is 'ray' -- as in 'gene ray'
12:24:52 <ray> 4-day simultaneous harmonic operating system
12:25:01 <fnord123> ehird_: programs are not sequences of intructions. you have been taught stupid. programs are stacks
12:25:37 <lament> "Several keyboards that come with the editor are closely based on a Dvorak layout, while staying with-in the three-key-per finger idea. This I will call Chvorak, as it is slightly different to actual Dvorak. The Chvorak keyboard packs the letters you type into 32 bit words (with extensions if needed) in an encoding I will call Chuffman (combining Chuck with Huffman)"
12:25:43 <ehird_> fnord123: ahahahahaha
12:25:51 <roconnor> I thought programs were natural deductions in constructive logic.
12:25:55 <ehird_> structured execution is EVIL and STUPID
12:26:02 <ehird_> :D
12:26:04 <newsham>  prop kibi [kibi == kibiSaid] translates directly from "I am what I said I am"
12:26:12 <newsham> which is not in the problem descriptions ;-)
12:26:38 <fnord123> infix syntax is EVIL and WRONG. RPN is the true operational ordering.
12:26:42 <newsham> perhaps the confusion is that I called it "kibiSaid" rather than "kibisStatementIs"
12:27:10 <newsham> ordering operational true the RPN is
12:27:35 <roconnor> granted it is true that we have application backwards.
12:27:50 <heatsink> These Forth sentences all sound like Yoda to me.
12:28:04 <ehird_> the Joy creator has a point though
12:28:07 <newsham> yoda was japanese
12:28:28 <ehird_> haskell etc programs use application to simulate what is conceptually concatenation a lot
12:28:35 <ehird_> and:
12:28:39 <ehird_> (languages (applicative (in (backwards (is (composition (function))))))) --slava pestov
12:28:44 <ehird_> but even so, i am unconvince
12:28:44 <ehird_> d
12:29:04 <lament> ehird_: that's why we have monads, where the order is the other way around.
12:29:07 <newsham> and i am uninterested ;-)
12:29:50 <newsham> http://www.thenewsh.com/%7Enewsham/x/postfix.hs
12:29:51 <roconnor> (\a -> bla bla bla bla bla) x -- x binds to a; why are they so far apart?
12:29:57 <vegai> anyone checked Disciple? Looks quite fascinating
12:30:08 <heatsink> Newsham: Word order, you mean?
12:30:17 <roconnor> or rather a binds to x
12:30:19 <ehird_> roconnor: x (\a -> ...) would be interesting
12:30:29 <ehird_> newsham: that's not the essence
12:30:31 <lament> roconnor: because if you actually have a lambda and its argument directly next to each other in the source code, you must have been smoking pot when you wrote that?
12:30:35 <ehird_> the essence would be reverse-(.)
12:30:40 * SamB agrees about PoppaVic
12:31:01 <roconnor> ehird_: that is what I'm suggesting; modulo we are stuck with what we have.
12:31:07 <lament> roconnor: unless the argument is a big expression itself, in which case your example is far less dramatic
12:31:35 <fnord123> Monad Transformers are computationally wasteful and evil. One 'do' god for one monad. 4 Monads lifted into one 'do' is the queer ant-imotherhood.
12:31:40 <ehird_> roconnor: that's interesting
12:31:58 <fnord123> (im done now)
12:31:58 <ehird_> roconnor: multiple args are curried, still, right?
12:31:59 <ehird_> so
12:32:02 <ehird_> a b (\x y -> ...)
12:32:09 <ehird_> x = b, y = a
12:32:19 <SamB> eww
12:32:24 <heatsink> fnord123: One 'do' to bring them all and in the darkness (>>=) them?
12:32:30 <ehird_> or... y = b, x = a? roconnor?
12:32:32 <b_jonas> but it's one monad
12:32:46 <roconnor> ehird_: x = b and y = a.
12:32:55 <ehird_> roconnor: Cool.
12:32:59 <ehird_> roconnor: How does it react with infix?
12:33:14 <ehird_> actually, it should work fine
12:33:20 <roconnor> ehird_: I'm not sure infix changes
12:33:35 <ehird_> fact 0 = 1; fact n = n * (n-1) fact
12:33:54 <ehird_> fib 0 = 0; fib 1 = 1; fib n = (n-1) fib + (n-2) fib
12:33:57 <fnord123> heatsink: Four transformers for the dwarvern lords in their halls. 8 states for the elven kings. 11 Continuations for the rulers of men.
12:34:07 <newsham> why not   0 fact = 1 ?
12:34:15 <ehird_> newsham: that's a good point
12:34:15 <SamB> what newsham said
12:34:27 <ehird_> 0 fib = 0; 1 fib = 1; n fib = (n-1) fib + (n-2) fib
12:34:33 <bugQ> mm, me likey postfix.
12:34:34 <ehird_> that's actually quite an elegant idea
12:34:38 * ehird_ writes some more functions like that
12:34:53 <SamB> so, this is some crazy "reverse Haskell"
12:34:58 <ehird_> SamB: kind of
12:35:00 <newsham> i dont see why people make such a big fuss over syntax
12:35:09 <mauke> hey, I made my first channel: ##free-c
12:35:18 <newsham> ##hi-c ?
12:35:27 <heatsink> mauke: What does it do?
12:35:29 * roconnor goes to troll ##free-c
12:35:34 <fnord123> mauke: are you being paid by the CIA to protest?
12:35:36 <SamB> lol
12:35:36 <bugQ> ##exhibit-c?
12:35:41 * SamB lols at roconnor
12:36:25 <newsham> ##in-c##bin-c ?
12:36:39 <bugQ> it-c bit-c...
12:37:11 <newsham> teen-e ween-e
12:37:26 <ehird_> [] qsort = []; (x:xs) qsort = (filter (< x) xs) qsort ++ [x] ++ (filter (>= x) xs) qsort
12:37:36 <newsham> ?go wikipedia bitc
12:37:36 <ehird_> roconnor: your idea is really really nice
12:37:38 <lambdabot> http://en.wikipedia.org/wiki/BitC
12:37:38 <lambdabot> Title: BitC - Wikipedia, the free encyclopedia
12:37:42 <roconnor> ehird_: that's tree sort
12:37:44 <ddarius> ehird_: Your filters are in the wrong order.
12:37:46 <bugQ> newsham: well, I'm just so used to stack-based languages (computer and human alike) that postfix looks nicer to me
12:37:54 <ehird_> roconnor: it's what haskellwiki says qsort is
12:37:54 <ehird_> :)
12:37:59 <ehird_> qsort (x:xs) = qsort (filter (< x) xs) ++ [x] ++ qsort (filter (>= x) xs)
12:38:02 <roconnor> lemme fix that
12:38:03 <newsham> stack-based sounds too implementation-detail to me
12:38:18 <bugQ> I meant, SOV grammar.
12:38:19 <ddarius> "Monoid Based"
12:38:22 <byorgey> ehird_: why is filter still prefix there?
12:38:26 <newsham> language should explain what, not so much how
12:38:27 <ehird_> byorgey: oh
12:38:28 <ehird_> good point
12:38:28 <ehird_> sorry
12:38:43 <ehird_> [] qsort = []; (x:xs) qsort = ((< x) xs filter) qsort ++ [x] ++ ((>= x) xs filter) qsort
12:38:47 <bugQ> agreed, newsham
12:39:06 <byorgey> ehird_: and why is this a good thing?
12:39:10 <ddarius> ehird_: Arguments are still in the wrong order.
12:39:22 <ehird_> ddarius: No.
12:39:27 <ehird_> Roconnor said arg order stays the same
12:39:37 <ehird_> 1 2 (\x y -> (x,y)) ==> (2,1)
12:40:04 * byorgey is confused
12:40:31 <ddarius> ehird_: Then (< x) xs filter is filter xs (< x) which is wrong.
12:40:51 <heatsink> IMO, order of terms in application doesn't matter as much as minimizing the need for explicit ((grouping)).
12:41:12 <bugQ> ddarius: yeah, you'd write it xs (< x) filter.
12:41:18 <oklopol> @die 1d2
12:41:18 <lambdabot> 1d2 => 1
12:41:30 <ddarius> heatsink: Actually that's one issue I've noticed with this.  It's not clear whether parentheses are needed until you reach the "end" of the expression.
12:41:39 <ehird_> oh, true
12:41:51 <ehird_> [] qsort = []; (x:xs) qsort = (xs (< x) filter) qsort ++ [x] ++ (xs (>= x) filter) qsort
12:43:21 * heatsink thinks about that
12:45:02 <bugQ> type constraints would looks all screwy, of course
12:45:32 <heatsink> ddarius: I just see it as reversing the order of application and making it leftfix instead of righfix.  That doesn't introduce parenthesis.  Am I missing something?
12:46:24 <bugQ> it makes it harder to know where parentheses go beforehand.
12:46:34 <ddarius> heatsink: It's not clear that (xs (< x) filter) is nested in an application to qsort so the parentheses seem unnecessary until you reach the end (qsort)
12:47:25 <heatsink> Well the solution is obviously to type from right to left!
12:48:25 <heatsink> yeh, iswym.
12:49:08 <bugQ> postfix wouldn't work very well with the current bracket syntax, but it might with something like this: http://savingtheinternetwithhate.com/stackish.html
12:49:08 <lambdabot> Title: Utu: stackish
12:50:36 <ehird_> zed shaw is so fun to read
12:50:39 <roconnor> blarg, I would have to rewrite all these stupid haskell introductions on the wiki
12:50:58 <bugQ> I think it might make a neat variation on the syntax, not a replacement
12:55:13 <bugQ> ...like it says on the page.
12:59:09 <bugQ> say, is there a function like flip, but for (a -> b -> c -> d) -> (c -> a -> b -> d)?
12:59:24 <EvilTerran> sadly not
12:59:30 <bugQ> hmm.
12:59:43 <heatsink> @pl \f a b c -> f c a b
12:59:43 <lambdabot> (flip .) . flip
12:59:45 <EvilTerran> easy to write one, though
12:59:46 <bd_> @hoogle (a -> b -> c -> d) -> (c -> a -> b -> d)
12:59:47 <lambdabot> No matches, try a more general search
13:00:26 <heatsink> @pl \f c a b -> f a b c
13:00:26 <lambdabot> flip . (flip .)
13:01:50 <bugQ> it wouldn't be possible to do a generic form of that, would it?
13:02:10 <EvilTerran> not without TH or something like that
13:03:06 <EvilTerran> might be able to mung something horrible with SYB
13:03:58 <SamB> @djinn (a -> b -> c -> d) -> (c -> a -> b -> d)
13:03:59 <lambdabot> f a b c d = a c d b
13:04:40 <SamB> djinn isn't very good with variable naming conventions, is it?
13:05:29 <ddarius> djinn hangs around here too much
13:05:55 <SamB> yes, but so do I
13:06:01 <bugQ> ?pl \f a b c d -> d a b c
13:06:01 <lambdabot> const ((flip .) . flip . flip id)
13:06:05 <bugQ> ew.
13:06:23 <bugQ> ?pl \f a b c d -> b c d a
13:06:23 <lambdabot> const (flip (flip . (flip .)))
13:06:37 <bugQ> ah, maybe...
13:06:39 <SamB> and I would have written that f g a b c = g c a b
13:06:49 <bugQ> ?pl \f a b c d e -> b c d e a
13:06:49 <lambdabot> const (flip (flip . ((flip . (flip .)) .)))
13:06:53 <bugQ> yes.
13:08:05 <EvilTerran> do you really want that leading f?
13:09:02 <EvilTerran> btw, it'd be possible to write, eg, a generic version of flip if you were willing to use (x0, (x1, (..., (xn, ())...))) instead of (x0, ..., xN)
13:09:33 <EvilTerran> i think
13:14:23 <EvilTerran> actually, that's pretty hard
13:14:52 <bugQ> I almost have it...
13:16:20 <jsnx> maybe we can make flip a keyword...
13:16:35 <jsnx> (the pythonification of haskell begins :)
13:17:05 <shag> dons: thanks for your comments about hayoo/holumbus :) i know about the HPC button, but unfortunately it doesn't fit the style of the QuickCheck and Cabal button ;)
13:17:26 <dons> shag: oh, because its a little small?
13:17:38 <shag> dons: yes, and it uses different colors etc.
13:18:02 <dons> oh well.
13:18:08 <shag> dons: but i think i'll add it nevertheless
13:18:19 <dons> yeah, its a little annoying its not the same size
13:18:24 <dons> we could scale it up just slightly
13:18:49 <shag> dons: well, that would be a start
13:23:55 <roconnor> dons: did you fix your broken type for 'forever'?
13:24:39 <mauke> @index forever
13:24:40 <lambdabot> bzzt
13:25:23 <bugQ> yeah, ok.  not possible.
13:25:37 <bogner> is there any straightforward way to write functions like filterM? i need a groupByM and don't see a way to use groupBy to write it...
13:25:41 <bugQ> if it would work, it would be rot 1 = id; rot n = ((rot (n-1)) .) . flip
13:25:52 <dons> roconnor: yeah.
13:26:05 <dons> forever     :: (Monad m) => m a -> m b
13:26:06 <dons> forever a   = a >> forever a
13:26:09 <bugQ> but you can't infer any type on that.
13:26:24 <Cale> bogner: Typically, you can't use the pure versions. The reason is that the pure versions put no ordering on the computations to be performed, while the monadic generalisations must specify one.
13:26:56 <bogner> cale: thank you, that's unfortunate, but makes sense
13:27:26 <Heffalump> you could define the pure ones from the monadic ones using Identity
13:27:26 <roconnor> @type groupBy
13:27:27 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
13:27:42 <Cale> So which type would you like groupByM to have?
13:27:54 <Cale> (a -> a -> m Bool) -> [a] -> m [[a]] ?
13:29:24 <bogner> yes
13:29:27 <bogner> that's what i want
13:29:35 <roconnor> @go 1000 Higgs bosons per year in Higg bosons per day
13:29:36 <lambdabot> http://www.hpcwire.com/hpc/1572567.html
13:29:44 <roconnor> @go 1000 per year in per day
13:29:45 <lambdabot> http://arstechnica.com/news.ars/post/20080115-amazons-free-shipping-costing-1000-per-day-in-france.html
13:29:56 <roconnor> @go 1000 / year in / day
13:29:56 <lambdabot> 1,000 / ((year in) / day) = 107.791703 m^-1
13:30:09 <SamB> @go 1000 year^-1 in day^-1
13:30:10 <lambdabot> 1,000 (year^(-1)) = 2.73790926 day^(-1)
13:30:13 <bugQ> heh
13:30:35 <roconnor> damned year inches
13:30:43 <wolverian> heh
13:30:49 <dons> ?go 1 MB/sec in Rolling Stone Back Catalogues
13:30:50 <lambdabot> No Result Found.
13:30:50 <bugQ> glacial speeds
13:30:55 <dons> oh so sad
13:31:22 <SamB> ?go 1 MB/sec in Rolling Stone Back Catalogues/year
13:31:22 <lambdabot> No Result Found.
13:32:34 <bugQ> ?go 1 man mo in LOC
13:32:36 <lambdabot> http://crdo.risc.cnrs.fr/exist/crdo/Austronesian/AKR/crdo-AKR_CRABE_COCOTIER.xml
13:32:57 <bugQ> wow.
13:33:23 <hpaste>  Cale pasted "spanM, groupByM" at http://hpaste.org/6872
13:33:35 <bugQ> damned coconut crabs.
13:33:56 <Igloo> What's the right way to allocate enough space for 4 arbitrary wide characters on Windows?
13:34:24 <Heffalump> while(true) malloc(1);
13:34:43 <Cale> bogner: ^^
13:34:58 <roconnor> Igloo: doesn't that depend the the locale?
13:35:39 <roconnor> Igloo: wait is that (arbitrary wide) characters, or arbitrary (wide characters)?
13:35:40 <newsham> malloc(4 * sizeof(wchar_t)) ?
13:35:40 <Cale> bogner: The effects will occur in a predictable order, but it might require some thought to use.
13:36:00 <Igloo> roconnor: The latter, in the sense of the fooW (as opposed to fooA) functions
13:36:04 <bugQ> roconnor: that would be arbitrarily wide chars.
13:36:14 <roconnor> oh right
13:36:23 * roconnor votes with newsham
13:36:57 <newsham> beware malloc(n * sizeof(wchar_t)) integer overlow issues
13:37:20 <ddarius> sizeof(wchar_t) = 2^30?
13:37:34 <edwardk> newsham: wchar_t is compiler dependent and may be 8,16 or32 bits wide, on windows its 16 bits, if you need to support plane 1 characters you may need 2 wchar_t's to hold the character, in which case the answer is 8 * sizeof(char_t)
13:37:52 <Heffalump> 2 wchar_t's for one character? wow.
13:38:05 <bugQ> not a very wide char, then, is it?
13:38:07 <edwardk> because plane 1 characters are 21 bits, they don't fit
13:38:10 <Igloo> I need a Haskell answer, not a C one
13:38:17 <newsham> wchar_t *bad(size_t n) { wchar_t *p = malloc(n * sizeof p[0]); if(p) {for(i = 0; i < n; i++) p[i] = 0;} return p; }
13:38:31 <Heffalump> I realise they can be limited to 16 bits, but I hadn't realised you'd actually then be allowed to use multi-chunk characters in them
13:38:34 <newsham> if n >= 0x80000000, boom
13:39:04 <newsham> 2 * 0x80000000 == 0;  for(i =0; i < 0x80000000; i++) <- doh
13:39:39 <edwardk> yeah, utf16 actually allows for multicharacter characters, which kind of defeats the purpose of fattening it up to begin with, but its existence was largely a sop to things like windows that had already started using that format when all the asian nations started bitching that unicode was too small
13:39:49 <newsham> edwardk: I was assuming that "arbitrary character" meant 1 wchar_t.
13:39:53 <newsham> what representation does he want?
13:40:15 <edwardk> igloo: well, in haskel isn't char an 'int' anyways? so its 32 bits and should hold anything unicode
13:40:43 <Igloo> I'm calling RegEnumKeyW, so I need to pass it a buffer that is big enough
13:41:11 <newsham> cant you pass it a length of zero to get back an error code that says it doesnt fit and how big yoru buff needs to be?
13:41:18 <newsham> then call it again with a newly allocated buf of the right size?
13:41:32 <Zao> edwardk: If one is happy with just the BMP, 16 bits is quite adequate.
13:41:38 <Igloo> Is that error code going to tell me the answer in characters or bytes?
13:41:43 <Igloo> I already know the answer in characters
13:41:44 <edwardk> yeah, newsham hit on the kind of standard idiom for windows calls
13:41:50 <edwardk> its in bytes iirc
13:42:01 <newsham> i think it says how many bytes.. but my win32 api knowledge is flakey
13:42:13 <Zao> newsham: MSDN ought to know.
13:42:18 <newsham> yes
13:42:30 <edwardk> pretty much any variable-sized result in a windows call gives you back the number of bytes you need to allocate if you call it with a null buffer or one too small
13:43:26 <Cale> :t ap
13:43:28 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:44:29 <Igloo> I can't see how I actually get that value. Oh, I'll just use 4* for now, and add a note that someone might want to do it better in the future
13:45:36 <andyjgill> Anyone here submit to ICFP?
13:46:16 <Heffalump> we submitted an experience report
13:46:21 <atsampson> ditto
13:46:33 <dcoutts> not this year, got a thesis to finish :-)
13:46:35 <andyjgill> Great!
13:46:43 <newsham> igloo: isnt there a size pointer you pass in that gets filled in with the result size?
13:46:59 <edwardk> igloo: hrmm unlike most of the windows api i can't seem to find it for that function either.
13:47:02 <andyjgill> Good plan, dcoutts
13:47:19 <Igloo> newsham: No, there is a plain old value (size in tchars)
13:48:32 <edwardk> igloo: ahh, the idiom is to use RegQueryInfoKey to get the size of the name
13:48:54 <dcoutts> andyjgill: :-)
13:49:14 <nominolo> @seen edwinb
13:49:15 <lambdabot> edwinb is in #haskell. I don't know when edwinb last spoke.
13:49:17 <edwardk> lpcMaxSubKeyLen tells you the length of the longest subkey name, then you can use that to set the buffer size
13:49:27 * edwinb is coincidentally here, but very briefly...
13:49:34 <Igloo> edwardk: Yes, I'm doing that, and it tells me how many tchars the answer is. Now how do I allocate a buffer that can hold them?
13:49:48 <nominolo> edwinb: ok, then another time
13:50:08 * nominolo is reading edwinb's thesis
13:50:08 <newsham> if its always just 4 wide characters or less, overallocating the buffer isnt going to hurt that much
13:50:12 <bogner> Cale: thank you, these work nicely
13:50:14 <edwinb> yikes ;)
13:50:19 <edwardk> ah, it is in chars isn't it. checking to see windows policy on surrogate pairs, if they are 'one char' or two.
13:50:47 * nominolo is considering similar work for agda or continuing edwinb's work
13:50:54 <edwinb> oooh
13:50:56 <Cale> I just thought of another way you can monadically generalise higher order functions, if you know the arguments at which they'll apply the functions they are given.
13:51:17 <nominolo> edwinb: but i have to read a little more of what you did first
13:51:32 <edwinb> I'll be happy to answer questions!
13:51:33 <Cale> You can write a monadic computation to perform all the side effects up front and build a function which you can then pass to the higher order function.
13:51:48 <edwinb> I'm travelling tomorrow though, back around properly on Tuesday
13:52:01 <edwardk> *4 is safe, *2 is _probably_ safe ;)
13:52:04 <Cale> However, this tends to result in different kinds of effects than the way I just translated span and groupBy
13:52:06 <nominolo> edwinb: sure, np.  i won't read it all in one day
13:52:10 <edwinb> heh
13:52:11 <Heffalump> edwardk: come to the hackathon!
13:52:13 <nominolo> or two for that matter
13:52:20 <edwardk> ganesh: where?
13:52:21 <Heffalump> gah
13:52:27 <Heffalump> s/edwardk/edwinb/
13:52:30 <newsham> is there an easy way to test if *2 is safe over all possible characters that could be stored?
13:52:30 <edwardk> hah
13:52:31 <edwardk> =)
13:52:34 <edwinb> Heffalump: ooh, when is it?
13:52:40 <edwinb> I should pay attention to these things
13:52:41 <newsham> the experimental method is highly underrated
13:52:42 <Heffalump> though edwardk is mostly welcome too, but I think you are on the wrong major continent for it to be sane
13:52:44 <edwardk> *sniff* i see how it is. ;)
13:52:48 <edwardk> yeah
13:52:48 <nominolo> edwinb: next friday
13:52:51 <Heffalump> edwinb: this coming weekend in Gothenburg
13:53:01 <edwardk> i'm over by boston with shapr.
13:53:13 <edwinb> Ah. Now that would be great but I can't do this weekend at all :(
13:53:38 <edwinb> okay, really must go now!
13:53:38 <Heffalump> oh, and I meant "most welcome" above not "mostly welcome". My fast typing keeps insulting edwardk by accident :-)
13:53:44 <edwinb> heh
13:54:12 <nominolo> edwardk: you're merely welcome :P
13:54:15 <edwardk> heh
13:54:33 <SamB> that sounds insulting too
13:54:44 <Saizan> i.e. they'll make you pay for the beer
13:54:45 <nominolo> of course it does
13:55:45 <nominolo> does anyone know if ben lippmeier is on this channel?
13:56:24 <hpaste>  Cale annotated "spanM, groupByM" with "another route" at http://hpaste.org/6872#a1
13:57:03 <Cale> (not to mention that they're type constrained a bit more)
13:59:18 <edwardk> I should have quit while i was mostly welcome ;)
14:00:11 <litb> hello again guys and gals
14:00:16 <litb> oh, many ppls here today
14:00:19 <litb> !users
14:00:22 <litb> @users
14:00:22 <lambdabot> Maximum users seen in #haskell: 473, currently: 460 (97.3%), active: 25 (5.4%)
14:00:31 <litb> thumbs up
14:00:59 <litb> i want to write a virtual machine with haskell (a very simple one)
14:01:19 <nominolo> really?
14:01:21 <litb> essentially it is an intepreter for a silly bytecode language
14:01:42 <litb> nothing fancy like cpu and so on. VM was only chosen because it sounds cool :)
14:02:07 <Cale> I would recommend using Data.ByteString of course :)
14:02:15 <Binkley> Hi all, anyone know whether I can use Cabal on its own to check whether a C library is installed, or do I have to do some horrible autoconf stuff for that?
14:02:21 <nominolo> and lots of strictness annotations
14:02:38 <nominolo> uh
14:02:48 <Cale> Binkley: That's a good question. I think most packages simply assume that the appropriate C libraries are installed.
14:02:48 <dcoutts> Binkley: not yet, you'd have to use code in Setup.hs
14:02:52 <litb> and for this i have to read in a binary file, and interpret the bytes (4 bytes = one instruction, consisting one one byte op-code, and 3 bytes immediate value) accordingly. for example op-code 19 means "read in a value and push onto the stack"
14:03:06 <solrize_> litb, use data.binary
14:03:07 <Binkley> dcoutts: do you know offhand of an example library that does that? I couldn't find one easily
14:03:14 <dcoutts> Binkley: we're planning to add detection for C libs and header files, like autoconf does
14:03:14 <litb> how can i realize such a stack that is modifyable, or how is it done normally?
14:03:33 <solrize_> the most obvious way to implement a stack is with a list
14:03:35 <litb> solrize_: thanks, i will look into data.binary
14:03:38 <solrize_> push x xs = x:xs
14:03:40 <nominolo> a list is pretty cheap as a stack
14:03:59 <dcoutts> Binkley: look at some of the db libs, they call out to foo_config progs to find the cc flags
14:04:00 <litb> i see. well in haskell lists cannot be changed
14:04:03 <Binkley> dcoutts: thx
14:04:22 <nominolo> litb: your stack functions return the new stack
14:04:22 * ddarius gives storable vector a spni
14:04:24 <litb> i think what i need is i need to look at haskell again to get used to its recursive things
14:04:26 <dcoutts> Binkley: or if your C lib uses pkg-config then there's built-in support for that in Cabal
14:04:33 <dcoutts> Binkley: what C lib ooi?
14:04:48 <Binkley> dcoutts: GraphicsMagick... same stuff I was working on at the Hackathon, that I'm finally getting around to releasing
14:04:56 <litb> damnit C..
14:05:00 <Binkley> how would I figure out if it uses pkg-config?
14:05:21 <litb> how about the Yi editor?
14:05:27 <litb> has it grown up ?
14:05:27 <dcoutts> Binkley:  pkg-config --list-all | grep -i mag
14:05:31 <Binkley> cool
14:05:38 <nominolo> litb: kind of
14:05:52 <nominolo> litb: it's hackable, but not necessarily usable
14:06:24 <litb> :/
14:06:33 <litb> where are the docs on the lib again?
14:06:34 <Binkley> w00t, it does use pkg-config -- looks like that's exactly what I need
14:07:34 <Saizan> ?docs
14:07:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
14:09:22 <litb> thanks
14:11:14 <nominolo> litb: you probably want something like this:  run :: Code -> Stack -> Memory -> IO ()  and this function runs one command, then calls itself
14:11:27 <solrize_> hmm, i have a big pile of python data structures, what's a good way to dump them so i can read them into haskell efficiently?
14:11:41 <nominolo> litb: also, it should be strict in the stack
14:11:54 <newsham> if all the structures and substructures have good __repr__ definitions, then just print repr(obj)
14:12:00 <litb> nominolo: oh i see yeah now i remember again..
14:12:02 <litb> wait..
14:12:07 <litb> what does "strict in the stack" mean?
14:12:29 * litb hopes that it won't confuse the hell out of him
14:12:32 <nominolo> !Stack should do
14:12:37 <solrize_> newsham, yeah, that's what i have, but i don't have a good way to read the python reprs into haskell... i guess i could dump them with a json module and read them back in with an off-hackage haskell json module that i found
14:12:40 <nominolo> with -fbang-patterns
14:13:05 <solrize_> they are mostly dictionaries whose entries are unicode strings
14:13:11 <newsham> 1) make repr's that are compatibile with haskell "read"s  or 2) write a parsing function for the thing you're spitting out
14:13:26 <solrize_> i always have heard that haskell "read" is dog slow
14:14:01 <newsham> is performance a goal?
14:14:02 <nominolo> litb: http://haskell.org/haskellwiki/Performance/Strictness
14:14:05 <solrize_> i found this haskell json parser that uses bytestrings so i might try it
14:14:07 <solrize_> yes performance is a goal
14:14:10 <lambdabot> Title: Performance/Strictness - HaskellWiki
14:14:17 <newsham> so why is python part of the chain?
14:14:31 <solrize_> python is slow and that's why i want to rewrite it in haskell :)
14:14:38 <solrize_> the python version takes about 10 hours
14:14:40 <nominolo> heh
14:14:54 <newsham> after you rewrite it will python be out of the chain?
14:15:02 <newsham> if so, why does it have to be fast to "read" in the python structs?
14:15:08 <newsham> just convert it once?
14:15:21 <solrize_> there are several python progs involved
14:15:42 <solrize_> the one that gets the data in the first place makes the python structs and takes 2 hours or so
14:15:49 <solrize_> and i can make that write out json structs or something instead
14:16:03 <newsham> wait, your prog currently takes 10hrs, and you're worrieda bout the perf of "read"?
14:16:09 <MarcWeber> solrize_: Do you know about psyco .. (I like haskell as well. but if it works you may want to try just psyco to get more speed in python)
14:16:10 <newsham> i'm skeptical you'll be "read"ing for hours
14:16:29 * bugQ just realized that Î» is nearly the same as å¥
14:16:44 <solrize_> marcweber yeah i haven't tried psyco yet but the python progs really are spending most of their time reading and writing python structs and xml
14:16:53 <litb> i don't have a memory. i only have code and stack
14:16:56 <solrize_> i.e. spending most time in python eval and cElementTree
14:16:57 <litb> what should Memory be for?
14:16:59 <newsham> i think the reading isnt going to be your perf bottleneck
14:17:10 <solrize_> it's a significant bottleneck in the python prog
14:17:23 <solrize_> i.e. i'm reading the __repr__'s back in with eval
14:17:32 <MarcWeber> solrize_: All you have to do is adding some import i think. I've used it once. Maybe give it a try before rewriting everything :) If it fits your needs your done
14:17:37 <bugQ> å¥ is "to enter", which makes sense, because a lambda enters another scope.
14:17:37 <newsham> wow... why?
14:17:44 <mauke> bugQ: there's also one that looks like Ï
14:17:47 <solrize_> add some import?
14:18:02 <solrize_> oh for psyco
14:18:14 <bugQ> å?
14:18:24 <bugQ> sword?
14:18:45 <mauke> no
14:18:50 <Not> @pl all (== head xs) xs
14:18:50 <lambdabot> all (head xs ==) xs
14:18:57 <bugQ> hmm.
14:19:05 <solrize_> yeah, i might try that but i kind of doubt psyco is going to help much for this, i mainly want to get rid of the multiple layers of data conversion (read SQL table, write python reprs, read python reprs, dump xml, read xml, dump more xml, read the new xml, post to a java program through http)
14:19:07 <newsham> ?pl \xs -> all (== head xs) xs
14:19:08 <lambdabot> all =<< (==) . head
14:19:09 <mauke> the left foot was straight IIRC
14:19:15 <litb> as far as i know, all requires a list of bool
14:19:22 <litb> t all
14:19:27 <litb> > t all
14:19:28 <lambdabot>  Couldn't match expected type `((a -> Bool) -> [a] -> Bool) -> t'
14:19:34 <litb> hm
14:19:47 <litb> @type all
14:19:49 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
14:19:52 <bugQ> Well, if å is written as a radical (component of another kanji) the left leg is often straightened to save space.
14:19:53 <litb> ah
14:20:10 <shachaf> bugQ: It's also similar to the Hebrew Gimel ('×').
14:20:33 <newsham> boo, my font has blanks for hebrew runes
14:20:42 <solrize_> i.e. if i rewrote all that stuff in python to collapse the conversions down i could probably get it to under 4 hours but this just seems like a good excuse to use haskell for something
14:21:07 <litb> hm, there is no Data.Binary apparently :/
14:21:15 <solrize_> litb, it's in hackage
14:21:43 <mauke> U+5140 (e5 85 80): CJK UNIFIED IDEOGRAPH-5140 [å]
14:21:48 <ddarius> @hackage binary
14:21:48 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
14:21:50 <mauke> I think that's it
14:22:11 <solrize_> ok i'll try with haskell read
14:22:15 <solrize_> benchmark
14:22:41 <newsham> ?quote premature
14:22:41 <lambdabot> pcrs says: Premature carriage ret
14:23:07 <bugQ> mauke: ah, ok.
14:23:21 <solrize_> hmm i'm not even sure how to convert the string reprs to haskell, example: u'Ja\u0304ti\u0304ya Sa\u0304hitya Parishada'
14:23:36 <bugQ> Meaning: to cut off the feet
14:23:45 <mauke> heh
14:24:48 <bugQ> others: high & level, lofty, bald, dangerous
14:25:13 <bugQ> bald & dangerous...
14:25:16 <newsham> http://book.realworldhaskell.org/beta/escapes.html#id409776
14:25:17 <lambdabot> Title: AppendixÂ B.Â Characters, strings, and escaping rules
14:25:18 <ddarius> "\u0304"
14:25:22 <ddarius> > "\u0304"
14:25:22 <lambdabot>  Illegal escape sequence at ""\u03..." (column 1)
14:25:29 <ddarius> > "\x0304"
14:25:30 <lambdabot>  "\772"
14:26:09 <solrize_> oh cool newsham thanks, looking at that page
14:26:11 * roconnor is getting excited about conal's up and comming GUI kit
14:26:18 <solrize_> wow
14:26:19 <solrize_> frp?
14:27:30 <roconnor> I guess
14:28:02 <roconnor> the whole reactive bit is just icing as far as I am concerned.
14:28:11 <roconnor> I think
14:28:18 <roconnor> actually I don't know what all these terms really mean
14:28:30 <roconnor> the whole continuously changing variables bit is icing for me
14:29:01 <roconnor> data driven programming (with proper caching) is what I want
14:29:16 <solrize_> caching?
14:29:40 <solrize_> continuously changing variables like in tcl/tk?  (python tkinter)
14:29:52 <roconnor> solrize_: the first time I used GuiTV, everytime I moved a slider, it refeched my entire database from the web.
14:30:16 <solrize_> roconnor arggh hehe
14:30:25 * solrize_ doesn't know what guitv is
14:30:35 <roconnor> @where GuiTV
14:30:35 <lambdabot> I know nothing about guitv.
14:30:40 <solrize_> but can imagine
14:30:42 <roconnor> @wiki GuiTV
14:30:43 <lambdabot> http://www.haskell.org/haskellwiki/GuiTV
14:31:07 <roconnor> hmm
14:31:12 <solrize_> hmm this is kind of a screw because my python objects are heterogenous dicts
14:31:17 <roconnor> the wiki page not very compelling
14:31:36 <roconnor> TV's are tangable values
14:31:47 <litb> oh
14:31:57 <ddarius> As one can tell when one drops one on ones toe.
14:32:00 <roconnor> the associate UIs with values
14:32:01 <Cale> tangible
14:32:01 <litb> so $! makes all things after it strict. how to switch into non-strict mode again?
14:32:06 <solrize_> i don't understand why not just have a gui running in its own thread sending events through a Chan?
14:32:13 <roconnor> tangible
14:32:24 <Cale> litb: f $! x = x `seq` f x, basically
14:32:27 <ddarius> litb: No.  $! is just an operator
14:32:34 <roconnor> solrize_: because that isn't modular.
14:32:49 <solrize_> it's the usual way of implementing a gui, i thought
14:32:54 <Cale> litb: So x will be evaluated up to determining the top level constructor before the result of f x is returned.
14:32:54 <litb> @src $!
14:32:54 <lambdabot> Source not found. You type like i drive.
14:32:58 <litb> hm
14:33:00 <ddarius> @src ($!)
14:33:00 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:33:02 <roconnor> solrize_: that is the usual way.
14:33:17 <Cale> oh, looks like another gap in the source dictionary :)
14:33:24 <roconnor> but in Haskell we don't do things the usual way, we try to find the right way.
14:33:29 <solrize_> hmm
14:33:39 <roconnor> although it takes 20 years or more to figure it out.
14:33:40 <litb> @src seq
14:33:40 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
14:33:46 <ddarius> Cale: I thought that one was there.
14:33:47 <litb> damnit :/
14:33:52 <solrize_> roconnor :)
14:33:55 <ddarius> litb: seq is a primitive
14:34:13 <litb> oh
14:34:14 <Cale> @src ($!)
14:34:14 <lambdabot> Source not found. My brain just exploded
14:34:16 <Cale> hmm
14:34:23 <Cale> maybe needs to be reloaded
14:34:24 <wagle_home> lambdabot needs a webcrawler to hunt down haskell source..  8)
14:34:28 <Cale> (I added it anyway)
14:34:37 <ddarius> wagle_home: Write it.
14:34:43 <mauke> @src Reader
14:34:43 <lambdabot> Source not found. You speak an infinite deal of nothing
14:34:57 <roconnor> I suspect this applictive functor idea may end up being one of the keys to getting frp and Gui's working properly.
14:35:00 * wagle_home . . . o o o O O O { oops! }
14:35:06 <litb> everything before `seq` is strict in the things after `seq` ?
14:35:23 <roconnor> not sure yet, but it does seem to feature promenently in conal's most recent work.
14:35:41 <litb> where is this Data.Binary thing?
14:35:49 <Cale> litb: Evaluating the expression  seq x y  essentially causes x to be evaluated up to determining the top level constructor before resulting in y
14:35:50 <ddarius> @hackage binary
14:35:52 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
14:35:57 <mrd> on the internets
14:36:10 <Cale> litb: On the list type, for instance,  seq x y  is the same as  case x of [] -> y; _ -> y
14:36:12 <Jedai> litb: seq a b guarantee that a will be evaluated to weak head normal form when (seq a b) is demanded and return b
14:36:33 <wagle_home> > head $! [1..]
14:36:33 <lambdabot>  1
14:36:41 <ddarius> [1..] is in whnf
14:36:47 <Cale> almost
14:36:51 <Jedai> wagle_home: There $! is a noop
14:36:54 <ddarius> close enough
14:36:57 <Cale> 1 : [2..]  is its whnf
14:37:13 <wagle_home> i know!  i just wanted to know if lambdabot knew about $!
14:37:32 <Jedai> Cale: Nope, it's 1 : [1+1..]
14:37:41 <Cale> Jedai: good point
14:37:42 <ddarius> wagle_home: $! is a Prelude function
14:37:59 <wagle_home> well, then why cant lambdabot find the source?
14:38:27 <roconnor> because lambdabot is a bitch
14:38:28 <ddarius> Because @src is implemented using non-existant reflective features of Haskell
14:38:33 <roconnor> @slap lambdabot
14:38:33 <lambdabot> why on earth would I slap lambdabot?
14:38:35 <ddarius> s/is/isn't
14:38:39 <Cale> wagle_home: lambdabot has a database of the source for things in a separate text file
14:38:48 <Cale> wagle_home: That text file is incomplete
14:38:55 <roconnor> lambdabot: because you suck, bit for brains
14:39:00 <litb> Jedai: oh i see
14:39:08 <litb> thanks for explaining to poor litb
14:39:42 <Cale> Next time I restart lambdabot, it'll know the source for ($!)
14:39:55 * wagle_home is nibbling at the idea of improving @src
14:40:34 <ddarius> Connect Google Code with a Haskell parser and have the source for anything anywhere!
14:40:42 <Saizan> it could use hoogle to find the module and the @docs to get the source
14:40:58 <mrd> @src seq
14:40:58 <lambdabot> Source not found. My brain just exploded
14:41:07 <mrd> i bet it did
14:41:23 <shachaf> How about adding @src+?
14:41:46 <newsham> http://www.haskell.org/haskellwiki/GuiTV
14:41:48 <lambdabot> Title: GuiTV - HaskellWiki
14:41:50 <newsham> oops
14:41:51 <newsham> misfire
14:42:50 <yoyogirl> www.mylazysundays.com
14:43:01 <Saizan> shachaf: many srcs span multiple lines
14:43:14 --- mode: ChanServ set +o Cale
14:43:24 --- mode: ChanServ set +o Saizan
14:43:32 --- mode: Cale set +b *!*@adsl-157-130-204.cae.bellsouth.net
14:43:46 --- mode: Cale set -oo Cale Saizan
14:43:49 <shachaf> Saizan: Supporting something like \n, then?
14:44:18 <shachaf> Perhaps \b should have a system like Rodney's.
14:45:28 <dbpatterson> I'm trying to build HsOpenSSL, (debian), and it cant find the c library (libssl-dev / libssl0.9.8) - that it requires >=0.9.7l... ideas?
14:47:52 <Saizan> you installed the dev?
14:47:58 <idnar> hmm, for some reason I thought Cale opped Saizan, and was very confused
14:48:01 <dbpatterson> Saizan: yes..
14:48:22 <Cale> idnar: I deopped Saizan, after banning yoyogirl>
14:48:24 <dbpatterson> idnar: well, irssi says "mode/#haskell [+o Saizan] by ChanServ"
14:48:37 <idnar> Cale: yeah
14:48:44 <idnar> Cale: I think my brain confused your deop with chanserv's op
14:48:54 <solrize_> ghc tries to use link gmp externally?  :(
14:49:03 <idnar> so I thought chanserv opped you, you opped Saizan, banned the guy, then deopped both of you
14:49:09 <solrize_> $ ghc -O2 r.hs
14:49:09 <solrize_> compilation IS NOT required
14:49:09 <solrize_> /usr/bin/ld: cannot find -lgmp
14:49:09 <solrize_> collect2: ld returned 1 exit status
14:49:58 <dbpatterson> hmm... is there an easy way to override configure depends just to see if it will build anyway ?
14:50:23 <gwern> dbpatterson: remove items from the build-depends field?
14:51:23 <dbpatterson> gwern: it isnt haskell dependencies..
14:52:05 <dbpatterson> its from the configure script that is "extra-source-files'd
14:52:06 <gwern> oh. I think you can use the --force flag to dpkg if you have the debs?
14:53:32 <dbpatterson> have the debs for what? I'm runghc Setup.hs'ing HsOpenSSL...
14:54:09 <Saizan> dbpatterson: it uses a configure script?
14:54:18 <dbpatterson> Saizan: yeah...
14:54:32 <dbpatterson> and it is the configure script that is failing...
14:54:57 <dbpatterson> hmm. wait a second
14:55:06 <dbpatterson> maybe it wants pkg-config to figure things out?
14:55:24 <solrize_> newsham, the naive haskell benchmark for this is at least 100x slower than python
14:55:49 <dbpatterson> ahh yes, that did it...
14:56:32 <Cale> solrize_: for what?
14:56:59 <solrize_> hmm actually the python one is pretty slow too.  cale: reading in a bunch of literal structs
14:57:44 <Cale> I don't see why that should be 100 times slower than anything.
14:58:09 <solrize_> it's actually only about 20x slower
14:58:36 <solrize_> but i'm using runhaskell b/c i get a link error from ghc
14:59:01 <Cale> solrize_: What's the link error?
14:59:07 <newsham> he has a lot of computation phases with deserialization at the head end and serialization at the back end
14:59:13 <solrize_> /usr/bin/ld: cannot find -lgmp
14:59:20 <newsham> and he's rewriting one of them in haskell
14:59:21 <Cale> solrize_: Is the gmp library installed?
14:59:26 <solrize_> apparently not :)
14:59:35 <newsham> locate libgmp
14:59:50 <Cale> apt-get install libgmp3
15:00:03 <solrize_> i can't install stuff on this box, no root
15:00:19 <solrize_> there's another box i can move to, i guess
15:00:30 <solrize_> but i'd expect the read function is compiled?
15:00:36 <Cale> Hmm, I suppose you could either ask your sysadmin or download a copy of the library and set your LD_LIBRARY_PATH
15:00:39 <wagle_home> install it in ~/lib and set LD_LIBRARY_PATH
15:01:06 <solrize_> wagle hmm that's an idea, but i'd have to find a suitable .so somewhere or compile one, i.e. yet another mission
15:01:12 <Cale> It's a little unfair to compare performance of Haskell programs if you're not compiling them. :)
15:01:23 <vincenz> ghci is slow!
15:01:26 <vincenz> boo for debuggers!
15:01:31 <newsham> ftp.gnu.org /pub/gnu/gmp (probably), configure --prefix=$HOME
15:01:31 <solrize_> well i think i'm basically comparing the performance of two library routines
15:01:34 <newsham> not terribly difficult
15:01:36 <solrize_> both of which are compiled i'd hope
15:01:41 <solrize_> the python one is written in C
15:03:14 <solrize_> anyway i probably should just write this in python and mess with the haskell version some other time
15:03:40 <newsham> how about get rid of all the serialization/deserialization steps?
15:03:45 <newsham> that would prob make things a bit faster
15:03:47 <solrize_> newsham, yes, that's the idea :)
15:05:47 <solrize_> it would be great for python users, if there were a haskell function that deserialized python reprs.  i guess it would have to use data.dynamic.
15:06:01 <solrize_> i hand-converted this repr to use a haskell sum type
15:06:57 <solrize_> i guess json would also be ok
15:07:39 <newsham> i would think any general python repr reader would be large and awkward and that most cases could be solved just as easily by hand writing a specific one
15:08:19 <newsham> helpers like "read python string literal" would be useful to have around
15:08:40 <solrize_> newsham, yeah, i think json would be good enough.  it's just that the json support in both python and haskell isn't so hot
15:09:09 <newsham> do you really want to get a Map of dynamics to dynamics?
15:09:26 <newsham> when a hand coded one would give you something a lot more specific
15:09:32 <solrize_> the prob is this data looks like  { "a" : 23, "b" : "foo", "c": ["xyz", "quux"] }
15:09:57 <newsham> perhaps thats the problem :)
15:10:20 <solrize_> yeah, i could convert the sql schema to haskell data declarations
15:11:09 <solrize_> or maybe just dump out binary directly
15:11:35 <dbpatterson> does tagsoup >= 0.5 mean darcs?
15:11:43 <dbpatterson> (hackage has onlye .1 and .4)
15:20:20 <gwern> You know you're reading a geek's thesis when you see something like 'Particular thanks needs to go to Scott Paxton for his super-human efforts to distract me with horse simulators, movie scripts, and dictionaries of obscure fictitious languages.' :)
15:21:10 <ddarius> @google "horse simulator"
15:21:11 <lambdabot> No Result Found.
15:21:35 <newsham> ... well first I assumed that all the horses were perfect spheres...
15:22:56 <gwern> @quote horse
15:22:57 <lambdabot> No quotes match. :(
15:23:13 <solrize_> LOL
15:24:24 <vincenz> > let fib n = let arr = array (0, max 2 n) $ [(0,0), (1,1), (2,1)] [(i,e) | i <- [3..n], let x = i `div` 2, let e = (arr ! x) * (arr ! (i - x - 1)) + (arr ! (x + 1)) * (arr ! (i - x))] in arr ! n in fib 10
15:24:26 <lambdabot>  Couldn't match expected type `t1 -> [(t, e)]'
15:24:38 <vincenz> > let fib n = let arr = array (0, max 2 n) $ [(0,0), (1,1), (2,1)] ++ [(i,e) | i <- [3..n], let x = i `div` 2, let e = (arr ! x) * (arr ! (i - x - 1)) + (arr ! (x + 1)) * (arr ! (i - x))] in arr ! n in fib 10
15:24:39 <lambdabot>  55
15:24:46 <vincenz> > let fib n = let arr = array (0, max 2 n) $ [(0,0), (1,1), (2,1)] ++ [(i,e) | i <- [3..n], let x = i `div` 2, let e = (arr ! x) * (arr ! (i - x - 1)) + (arr ! (x + 1)) * (arr ! (i - x))] in arr ! n in fib 1000000
15:24:50 <lambdabot>  1953282128707757731632014947596256332443542996591873396953405194571625257887...
15:25:20 <newsham> http://www.cs.northwestern.edu/~riesbeck/mathphyseng.html /At the races/
15:25:21 <lambdabot> Title: Math Phys Eng
15:26:18 <bododo> hi folks :)
15:26:18 <lambdabot> bododo: You have 1 new message. '/msg lambdabot @messages' to read it.
15:27:01 <bododo> :) thanks TomMD
15:27:44 <bododo> guys, this my 3rd day with Haskell, and I'm stuck with a problem, I'm sure it's a silly one
15:28:22 <vincenz> bododo: if it's code, use @paste
15:28:24 <vincenz> @paste
15:28:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:28:39 <vincenz> EAsier to look at that way :)
15:28:41 <bododo> vincenz: yes it is :)
15:28:43 <vincenz> and people can iterate
15:28:53 <bododo> http://rafb.net/p/tTmxIf11.html
15:28:53 <lambdabot> Title: Nopaste - a Yaht exercise
15:29:02 <bododo> sorry used rafb
15:29:21 <hpaste>  vincenz pasted "bobodo's problem" at http://hpaste.org/6874
15:29:22 <newsham> we forgive you this time
15:29:30 <vincenz> bododo: @paste allows us to annote
15:29:33 <vincenz> bododo: it's great
15:29:38 <vincenz> bododo: what's the problem?
15:29:45 <hpaste>  bododo pasted "a yaht exercise" at http://hpaste.org/6875
15:29:59 <EvilTerran> hehe
15:30:12 <vincenz> bododo: btw "produkt" exists
15:30:14 <bododo> vincenz: thanks! :) The problem is with showing every read number's factorial
15:30:14 <vincenz> @src product
15:30:14 <lambdabot> product = foldl (*) 1
15:30:29 <vincenz> and foldl is better than foldr for numbers
15:30:38 <Jedai> bododo: The return here isn't good
15:30:38 <vincenz> foldl' is even better, but that's details
15:30:47 <bododo> vincenz: ah okay! and I thought i invented something! :p
15:30:50 <vincenz> bododo: you want mapM_
15:30:52 <newsham> lots of nits for 3rd day program
15:30:53 <vincenz> :t mapM_
15:30:54 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
15:30:54 * EvilTerran notes that you can express fact in terms of product
15:30:59 <Jedai> bododo: You should write "mapM_ ..."
15:31:02 <vincenz> newsham: best to teach as much as possible
15:31:06 <Jedai> And I'm slow...
15:31:23 <bododo> thanks guys, any example of mapM_ ?
15:31:33 <vincenz> @src mapM_
15:31:33 <lambdabot> mapM_ f as = sequence_ (map f as)
15:31:38 <Jedai> mapM_ printfact nums
15:31:39 <bododo> someone to correct my newbee exercise? :)
15:32:08 <bododo> Jedai: what's the real difference with map?
15:32:17 <bododo> is it because there's a DO ?
15:32:18 <vincenz> bododo: look at the types
15:32:20 <vincenz> :t map
15:32:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:32:25 <vincenz> :t mapM_
15:32:26 <EvilTerran> hah
15:32:26 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
15:32:32 * vincenz kicks Cale for the non standard src
15:32:35 <bododo> ah! yes! yes!!
15:32:37 <vincenz> monad )
15:32:38 <bododo> great!!
15:32:40 <Jedai> @type map
15:32:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:32:42 <newsham> mapM_ act [a,b,c,d] does     act 1; act b; act c; act d and results in ()
15:32:42 <vincenz> This case the IO monad
15:32:48 <mauke> :t P.map
15:32:48 <vincenz> mapM maps monadic actions
15:32:49 <Cale> vincenz: what?
15:32:49 <newsham> s/act 1/ act a/
15:32:49 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
15:32:50 <Baughn> Wait, what? map takes a Functor now?
15:32:52 <vincenz> and then does them in turn
15:32:54 <vincenz> Cale: map
15:32:59 <atsampson> it's also worth looking at mapM, since then you can see mapM_'s just the same but it throws away the result
15:33:07 <EvilTerran> it's just that using return and map will give you [m a], and using mapM will give you m [a]
15:33:11 <vincenz> @src mapM_
15:33:12 <lambdabot> mapM_ f as = sequence_ (map f as)
15:33:14 <vincenz> :t sequence_
15:33:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
15:33:18 <vincenz> see
15:33:21 <vincenz> it first maps the function
15:33:30 <vincenz> then sequences the resulting list of actions to be executed
15:33:31 <vincenz> in order
15:33:32 <newsham> mapM act [a,b,c,d] hsa the result of [act a, act b, act c, act d]
15:33:33 <EvilTerran> and then, as atsampson says, mapM_ throws away the result and just returns ()
15:33:37 <bododo> woow woow woow! guys! it's my 3rd dayyy! :)
15:33:45 <vincenz> newsham: you mean map
15:33:56 <vincenz> bododo: ok
15:34:01 <newsham> i think I mean act
15:34:02 <bododo> :)
15:34:04 <newsham> mapM
15:34:05 <vincenz> bododo: you know the difference between pure functions and monadic ones?
15:34:08 <newsham> did I get it wrong?
15:34:09 <Jedai> bododo: sequence is the most important function here, it takes a list of monadic actions (like IO effects here) and execute them in order
15:34:40 <vincenz> newsham: sorta :)
15:34:45 <bododo> vincenz: i guess yes, pure return the same value for the same argument, doesn't depend on and nor change real world, right?
15:34:51 <vincenz> bododo: correct
15:34:51 <Jedai> bododo: sequence_ does the same but throw away the result
15:34:53 <Peaker> @type sequence
15:34:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:35:00 <vincenz> bododo: monadic ones can do stuff, like in the IO monad you can print stuff
15:35:06 <Jedai> @type sequence_
15:35:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
15:35:12 <vincenz> bododo: so when you map monadic functoin over a list, you get a list of monadic actions
15:35:17 <newsham> sequence_ [print 1, print 2, print 3]     will print 1 then 2 then 3 and then result in ()
15:35:21 <vincenz> bododo: but the list just contains the actins, then these actions need to be executed
15:35:24 <vincenz> that is what sequence does
15:35:32 <vincenz> or sequence_ if you do not care about the return values
15:35:33 <newsham> mapM print [1,2,3] == sequence_ [print 1, print 2, print 3]
15:35:39 <vincenz> newsham: nope
15:35:42 <newsham> err mapM_
15:35:43 <EvilTerran> ?src sequence
15:35:43 <lambdabot> sequence []     = return []
15:35:43 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
15:35:43 <lambdabot> --OR
15:35:43 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
15:35:49 <EvilTerran> ?src sequence_
15:35:49 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
15:35:58 <vincenz> @src mapM_
15:35:58 <lambdabot> mapM_ f as = sequence_ (map f as)
15:35:59 <vincenz> @src mapM
15:35:59 <lambdabot> mapM f as = sequence (map f as)
15:36:11 <EvilTerran> if you prefer, sequence_ [] = return ]
15:36:20 <vincenz> EvilTerran: return ()
15:36:37 <EvilTerran> s/]/(); sequence (x:xs) = do x; sequence xs/
15:36:43 <EvilTerran> @quote pcrs
15:36:43 <lambdabot> pcrs says: Premature carriage ret
15:36:50 <Peaker> bododo, did you read about "do" being a syntax sugar for monadic bind operations?
15:37:04 <hpaste>  vincenz annotated "a yaht exercise" with "correction" at http://hpaste.org/6875#a1
15:37:11 <Jedai> I think bododo is a little bit lost, he don't react anymore (too much monad can be noxious to your health...) ^^
15:37:38 <bododo> aha!
15:37:38 <bododo> great
15:37:38 <bododo> so I should do: sequence printfact list?
15:37:38 <bododo> sequence_
15:37:39 <bododo> no, i'm wrong
15:37:52 <bododo> Peaker: no, not yet actually, i'm using the yaht
15:38:06 <bododo> Jedai: :)
15:38:07 <vincenz> :t sequence
15:38:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:38:09 <vincenz> :t sequence_
15:38:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
15:38:15 <Baughn> bododo: You should probably understand monads /before/ starting on sequence/mapM/other monad combinators
15:38:17 <bododo> ok i'll type this in ghci
15:38:17 <newsham> you broke the bodobo
15:38:24 <Cale> bododo: sequence takes a list of actions and turns them into a single action
15:38:24 <Jedai> bododo: Almost, but no, you should do : sequence_ (map printfact list)
15:38:33 * bododo is broke 
15:38:33 <vincenz> bododo: trust me, it gets better :)
15:38:38 <Peaker> bododo, what chapter are you in?
15:38:50 <Jedai> bododo: Which you could write with mapM_ to avoid the map
15:38:51 <bododo> Jedai: yes! that's it! :)
15:38:53 <vincenz> bododo: already quite well done for a noobie :)
15:39:17 <Cale> Let's look at how sequence works
15:39:22 <Cale> sequence [] = return []
15:39:39 <Jedai> Yes, you seems to catch up quickly !! ^^
15:39:41 <Cale> If you give it an empty list, it gives you an action which when run, does nothing and produces an empty list
15:39:54 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
15:39:56 <newsham> bodobo: do you know   foreach var in list : body?
15:40:13 <newsham> mapM_ (\var -> body) list    is sort of like that
15:40:50 <Cale> If you give it a nonempty list, it produces the action which when run, will run the first element in the list to get v, then sequence the rest of the elements of the list and run that to get vs, and then return the list (v:vs)
15:41:54 <Jedai> I think we're too many on the channel now, we should take turn responding to beginners, it gets confusing...
15:41:59 <Cale> So it's a kind of primordial loop -- you give it a list of actions to be performed, and it chains them together into an action which will perform them all and return a list of the results.
15:42:07 <vincenz> Jedai: When Cale speaks, I'm silent.
15:42:15 <dbpatterson> does anyone have examples using curl (the library)?
15:42:42 <Jedai> vincenz: Yes, Cale explains well
15:42:53 <Peaker> bododo, where do you stand with monads, what "do" means, etc?
15:43:21 <Cale> Then, to construct such a list of actions, we could map a function that constructs an action from a value over a list -- the result is much like a foreach loop. A loop body, if you think about it, is a function from the index to an action to be performed
15:43:41 <Cale> :t forM
15:43:41 <bododo> Peaker: the 3rd
15:43:41 <bododo> vincenz: thnks for the encouragement! really! :)
15:43:41 <bododo> so, correct me if i'm wrong
15:43:41 <bododo> i'll tell you what i've understood
15:43:41 <bododo> a monadic action, doesn't return something, but when executed it returns something
15:43:42 <bododo> newsham: no, actually no
15:43:42 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
15:43:46 <bododo> and sequence is like chaining actions to be executed as one action, am i right?
15:43:50 <bododo> and guess what??
15:43:52 <bododo> It works!! :)
15:43:54 <bododo> and I know why!! :)
15:43:56 <bododo> Cale: yes, thank you! :)
15:44:00 <bododo> thank you all guys! never seen a helpful cheerfull community as this one
15:44:02 <bododo> and btw please bear with my poor english
15:44:03 <Peaker> bododo, "Getting started"?
15:44:04 <bododo> it's my 4th language
15:44:06 <bododo> Peaker: yes exactly, actually I'm starting by considering monads as IO thingies, but I'm sure that there's a generalization somewhere ;)
15:44:21 <vincenz> bododo: yes, monads tend to blow people's minds after they get used to haskell
15:44:27 <newsham> thats prob a good plce to start
15:44:27 <vincenz> but they'r'e really great
15:44:30 <bododo> Peaker: well, the 3rd chapoter of the yaht
15:44:38 <newsham> you can generalize to non "IO thingies" later
15:44:47 * vincenz nods at what newsham  says
15:44:54 <Peaker> bododo, in most languages, a "sequence" of operations is what code is composed of... "statements" or lines of code.  In Haskell, a "sequence" of operations is composed with a special function (>>=).  "do" lets that composition look like a statement list looks like in other languages.  This means that unlike regular languages, you can define what (>>=) does, and treat pieces/sequences of code like values. This adds a lot of power to Haskell
15:44:54 <Peaker>  that normal languages don't have
15:44:57 <bododo> i guessed so, yes :)
15:45:05 <Cale> vincenz: I'm actually pretty convinced that it's not monads which blow people's minds, but the idea of values which are literally built out of functions.
15:45:18 <bododo> the imperative ones
15:45:23 <vincenz> Cale: well monad transforemrs are annoying
15:45:29 <vincenz> Cale: the upside down aspect, I always get that wrong
15:45:35 <newsham> cale: first class imperatives?
15:45:40 <bododo> because actually in functionnal languages order of "statements" doesn't matter
15:45:42 <Peaker> vincenz, because of the meaningful lift counts?
15:45:51 <vincenz> Peaker: no, figuring out which goes on top
15:45:58 <vincenz> Peaker: and then knowing that the run functions are inside out
15:46:02 <vincenz> cause it's like an onion
15:46:13 <bododo> so monads bring some of the imperative stuff to functionnal?
15:46:13 <vincenz> Peaker: most cases it doesn't matter, since they commute
15:46:20 <vincenz> bododo: yes
15:46:24 <Peaker> vincenz, is it meaningful which transformer is out of which?
15:46:25 <Cale> bododo: Essentially, instead of directly having language constructs for defining an order of computation, we instead have a library with operators that chain actions together in order, and actions are just values.
15:46:28 <EvilTerran> stuff like Error and List matter
15:46:31 <Peaker> cinimod, when don't they?
15:46:31 <vincenz> Peaker: it can be
15:46:35 <Peaker> oops
15:46:36 <vincenz> Peaker: like when you combine ContT with StateT
15:46:39 <Peaker> that was to vincenz
15:46:46 <Peaker> vincenz, I haven't used ContT yet
15:46:49 <vincenz> or List and State
15:46:50 <Cale> bododo: We then build all the usual control structures as library functions in terms of that
15:46:56 <bododo> wow! I really feel the power now! wow!
15:46:57 <vincenz> Peaker: if one is on top, your state is global
15:47:03 <vincenz> Peaker: if the other is on top, your state is backtracked
15:47:16 <Peaker> bododo, well,   a>>b  and b>>a  are different,  which means do { a ; b }  and do  {b ; a}  are different
15:47:24 <vincenz> don't ask me which :)
15:47:30 <EvilTerran> in ListT (ErrorT Identity), you get a single error, or n successes. in ErrorT (ListT Identity), you get a list of individual errors or successes
15:47:32 <bododo> Peaker: yes sure!
15:47:34 <vincenz> I always get ordering wrong
15:47:41 <EvilTerran> ?unmtl ListT (ErrorT Identity)
15:47:41 <lambdabot> err: `ListT (ErrorT Identity)' is not applied to enough arguments, giving `/\A B. [A] (Either Identity B)'
15:47:43 <vincenz> EvilTerran: ListT Identity == []
15:47:44 <EvilTerran> ?unmtl ListT (ErrorT Identity) a
15:47:44 <lambdabot> err: `ErrorT Identity [a]' is not applied to enough arguments, giving `/\A. [a] (Either Identity A)'
15:47:50 <bododo> but if a and b where pure functions, that order won't matter, right?
15:47:54 <EvilTerran> ?unmtl ListT (ErrorT e Identity) a
15:47:54 <lambdabot> Either e [a]
15:47:55 <vincenz> bododo: correct
15:48:04 <EvilTerran> ?unmtl ErrorT e (ListT Identity) a
15:48:04 <lambdabot> [Either e a]
15:48:05 <vincenz> bododo: but you can't put pure functions in a do-syntax
15:48:12 <vincenz> not in the way you think at least
15:48:14 <bododo> vincenz: sure, yes
15:48:20 <EvilTerran> vincenz, i know, but this way demonstrated the commutativity better
15:48:24 <bododo> i think i got it :)
15:48:28 <Cale> bododo: There are two processes going on: evaluation and execution
15:48:33 <vincenz> EvilTerran: fair enough :)
15:48:46 <Cale> bododo: Evaluation has no side effects, and for IO actions, is relatively trivial.
15:48:48 <vincenz> EvilTerran: so the bottom one is the most global one?
15:48:56 <vincenz> EvilTerran: makes sense if you think of IO, I guess
15:48:58 <bododo> Cale: evaluation maybe lazy, execution is imperative?
15:49:00 <Cale> bododo: It's what turns 10 + 10 into 20, for instance
15:49:08 <bododo> Cale: i see
15:49:11 <EvilTerran> yeah, the monad at the bottom of the transformer stack goes on the outside
15:49:25 <vincenz> EvilTerran: ah, thanks for that zenwhack, of course :)
15:49:26 <EvilTerran> indeed, i use "there's no IOT" as the mnemonic
15:49:38 <EvilTerran> :)
15:49:57 <vincenz> @remember EvilTerran indeed, i use "there's no IOT" as the mnemonic
15:49:57 <lambdabot> Done.
15:50:05 <bododo> are monads about execution? finally?
15:50:19 <Cale> Execution of IO actions is carried out by the runtime system and has all the side effects. The only action which is executed in a compiled Haskell program is main, and in turn, it's built up from smaller IO actions.
15:50:46 <Cale> Monads are actually about the way in which things are combined.
15:51:01 <Cale> The fact that IO happens to be a monad is really less important than you'd think.
15:51:16 <bododo> Cale: i think i got it, i actually do the same thing almost with python, separate things this way
15:51:21 <newsham> its sort of like at the very top ofyour program is "realMain = executeIO main"
15:51:33 <newsham> where "executeIO" is this IO executor program and "main" is your program
15:51:41 <vincenz> we need an IOT
15:51:42 <bododo> Cale: so it's about order in time?
15:51:54 <vincenz> in case we want some kind of distributed monad ala erlang under it
15:51:56 <Cale> bododo: The IO monad has to do with ordering things in time.
15:52:00 <SamB> time?
15:52:07 <SamB> what is this "time" you speak of?
15:52:09 <newsham> bodobo: the later actions happen "after" the earlier ones and get to see the side effects caused by the earlier ones
15:52:11 <bododo> yes, time? :)
15:52:20 <newsham> its kind of about the chaining of side effects
15:52:24 <vincenz> bododo: for IO that's a safe assumption
15:52:24 <Cale> bododo: But monads in general are just libraries which have these >>= and return operations
15:52:26 <vincenz> bododo: not for all monads
15:52:37 <newsham> for IO
15:52:41 <Cale> bododo: and >>= and return are required to satisfy a few laws
15:52:51 <bododo> newsham: monads are about things that depend on other things so strongly that an order has to be established?
15:52:59 <Cale> bododo: They're a general shape which shows up in a lot of libraries, so we generalise over it.
15:53:09 <SamB> yeah, I've had monads that seemed to execute in last-to-first order :-)
15:53:10 <Cale> bododo: But it means something different in each library.
15:53:11 <newsham> bodobo: monads are about things that can be combined using >>= :)
15:53:21 <bododo> ok, so I guess I still have a lot to learn! :)
15:53:32 <newsham> what that combination means depends on which particular instance of a monad you are talking about
15:53:33 <dobblego> ?type return -- lest we forget
15:53:34 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
15:53:59 <bododo> btw, only monads use "return" ?
15:54:05 <EvilTerran> yes
15:54:11 <bododo> okay!
15:54:20 <newsham> "return" changes a pure value into a type of "no-op" action that results in that value
15:54:22 <bododo> so they require "execution" to answer
15:54:31 <vincenz> for some meaning of 'execution'
15:54:35 <newsham> ie  "return 3 :: IO"   doesnt do any IO action, but results in the value 3
15:54:37 <EvilTerran> although there's a function Control.Applicative.pure that works on Applicative Functors, being a generalization of monads
15:54:39 <dobblego> bododo, the essence of a monad is (>>=) and the return function and some laws (relationships) between them
15:54:39 <mauke> 'return' is a virtual constructor
15:54:50 <bododo> vincenz: yes, and action, say an action?
15:55:07 <bododo> :)
15:55:12 <newsham> it turns "3 :: Int" into an IO action of type "IO Int"
15:55:20 * bododo is feeling good
15:55:30 <mauke> > return 3  :: [Int]
15:55:31 <lambdabot>  [3]
15:55:40 <mauke> > return 3  :: Maybe Int
15:55:41 <lambdabot>  Just 3
15:55:49 <mauke> > return 3  :: IO Int
15:55:49 <lambdabot>  <IO Int>
15:55:58 <dobblego> > return 3 :: [Int]
15:55:58 <lambdabot>  [3]
15:56:03 <gwern> @quote gibber
15:56:03 <lambdabot> LoganCapaldo says: I think it would require gibbering mad instances ;)
15:56:14 <bododo> can I safely carry on with the yaht and then get back to the gentle intro?
15:56:18 <newsham> > do { x <- Just 5; y <- Just 3; return (x+y) }
15:56:19 <lambdabot>  Just 8
15:56:23 <vincenz> bododo: yes
15:56:27 <bododo> :)
15:56:33 <vincenz> bododo: I found YAHT easier than Gentle
15:56:43 <dcoutts> we announce Well-Typed LLP, the new Haskell consultancy company!
15:56:44 <gwern> bododo: no! your mind will be irretriveably scarred, if not your soul devoured!
15:56:45 <dcoutts> @yarr!
15:56:45 <lambdabot> Yeh scurvy dog...
15:56:48 <bododo> if you guys were women, i'd marry you all! :)
15:56:52 <vincenz> dcoutts: website?
15:56:55 <newsham> "gentle introduction" holds to the trueism "if you have to call it gentle its probably not"
15:57:02 <gwern> as /haskell/ says, what has been comprehended cannot be uncomprehended!
15:57:05 <dcoutts> http://www.well-typed.com/
15:57:05 <lambdabot> Title: Well-Typed
15:57:16 <vincenz> dcoutts: this in the trend of the untyped company?
15:57:19 <bododo> newsham: yes, i love the trueism of it actually too
15:57:22 <tromp> > 271819+3855+14200
15:57:22 <lambdabot>  289874
15:57:29 <vincenz> dcoutts: congrats :)
15:57:33 <ddarius> Is there a Storable instance for (Storable a, Storable b) => (a,b) somewhere?
15:57:45 <mauke> unlikely
15:57:49 <dcoutts> http://haskell.org/pipermail/haskell/2008-April/020319.html
15:57:50 <lambdabot> Title: [Haskell] ANNOUNCE: Well-Typed LLP - The Haskell Consultants
15:57:53 <vincenz> dcoutts: Seems like a lot of fun!
15:57:56 <vincenz> dcoutts: clients lined up?
15:58:04 <dcoutts> vincenz: some, we hope :-)
15:58:15 <vincenz> dcoutts: Well great :)
15:58:21 <roconnor> dcoutts: $200 an hour?
15:58:23 <vincenz> dcoutts: and wow, all very active people
15:58:28 <dcoutts> not counting the chickens before they're hatched of course
15:58:44 <newsham> how many eggs do you have?
15:58:58 <dcoutts> that'd be a corporate secret :-)
15:58:59 <gwern> huh. no wonder bringert is so slow to respond to emails; he's busy consulting
15:59:03 <dcoutts> we'll see how it goes
15:59:03 <bododo> so, what it's all about, is actually let me write programs the way i design them in my mind and let the compiler generate a lower level binary/code whatever, right?
15:59:23 <TomMD> Is it possible to have a type instance over an entire class?
15:59:47 <vincenz> bododo: If you want a small way of how I look at it.  Usually when I'm stuck on a tough problem, I first try to device the type I need.  And typically once I have that, the code comes out
15:59:54 <dcoutts> newsham: we'll be pursuing all opportunities to get clients
16:00:08 <newsham> bodobo: i guess that depends on how they are in your mind and how well that fits with what haskell is like?
16:00:11 <dobblego> dcoutts, nice, good luck
16:00:12 * gwern feels a disturbance - as if a thousand -cafers cried out in greed, and were suddenly not hired
16:00:12 <vincenz> bododo: For instance I was stuck on a rather difficult problem, and the fact I could not find the proper type told me a lot.  Today I experimented with another type, and the code just came out.
16:00:19 <bododo> vincenz: :) thanks
16:00:31 <dcoutts> dobblego: thanks
16:00:43 <gwern> dcoutts: are there any potential clients yet?
16:00:51 <vincenz> bododo: Another tip, try to minimize the amount of monadic code, and keep it as a 'layer' around your pure code.
16:00:54 <bododo> newsham: right! I generally think in analogies, sometimes using notions and things that don't anything to have with computers
16:01:03 <vincenz> bododo: Last tip, think of lists as while loops
16:01:11 <dcoutts> gwern: yes, though don't ask me to name them
16:01:32 <bododo> vincenz: yeah! :) i guessed right then with the type numbers and end witn 0? :)
16:01:37 * roconnor often has monadic code at the very heart of his programs
16:01:54 * Valodim often has monadic code at the very heart of his
16:02:11 <SamB> well, you do generally want to limit the scope of the IO monadic code
16:02:34 <roconnor> sure, IO isn't at the heart of my programs.
16:02:47 <roconnor> it's at the it's fingertips
16:02:48 <EvilTerran> @quote \<IO\>
16:02:48 <lambdabot> ricky_clarkson says: I think IO should be called Kansas.
16:02:54 * bododo has monadic code in his monadic kernel (what biologists call a heart! come on! a heart??) :)
16:03:28 <SamB> @google monads and the catholic church
16:03:29 <lambdabot> No Result Found.
16:03:35 <SamB> @google monads church
16:03:38 <lambdabot> http://links.jstor.org/sici?sici=0002-9947(198510)291%3A2%3C629%3AEOFOFF%3E2.0.CO%3B2-8
16:03:38 <lambdabot> Title: Cookie Absent
16:03:40 <chessguy> bdcoutts, Igloo, best wishes in your new endeavor
16:03:43 <SamB> hmm...
16:03:48 <roconnor> dcoutts: boo, you are running apache. :)
16:03:50 <chessguy> s/bd/d/
16:04:10 <dcoutts> roconnor: heh
16:04:18 <Igloo> thanks chessguy
16:04:31 <dcoutts> roconnor: it's shared hosting or the moment
16:04:49 * roconnor rewrites xen in haskell
16:05:08 <SamB> roconnor: and assembler, I trust?
16:05:13 <bododo> again thanks guys! I'll get back to my course, and if ever I need help, i know where to ask  :)
16:05:38 <roconnor> SamB: I already wrote an assembler for the 2006 ICFP contest
16:05:57 <SamB> roconnor: no, I mean, you are using assembler code in your Xen, right?
16:06:05 <SamB> it won't work without any!
16:06:30 <roconnor> SamB: you mean I cannot just write denotational stuff?
16:06:42 <SamB> indeed
16:06:43 * siponen writes some stupid Vtes game simulator and fails miseraby (so far)
16:06:47 <roconnor> :(
16:07:00 <SamB> the idea with Xen is to actually be efficient
16:07:07 <SamB> otherwise, we would just use bochs
16:07:12 <roconnor> oh
16:07:24 <roconnor> The notion of efficiency isn't captured by denotations
16:07:30 <dons> woot, go well-typed! http://reddit.com/info/6esz1/comments/
16:07:59 <SamB> roconnor: which is the problem in a nutshell, I think
16:08:10 <roconnor> screw haskell
16:08:21 <Igloo> Oh, gmane has magically gravatar'd me!
16:08:25 <roconnor> haskell--
16:08:35 <olsner> @karma haskell
16:08:35 <lambdabot> haskell has a karma of 27
16:08:36 * Igloo ignores the country flag
16:08:55 <roconnor> asm++
16:09:06 <SamB> I suppose I should crop my facebook picture for gravitar, eh?
16:09:34 <olsner> just rewrite Xen in pure assembly
16:09:34 <dons> we welcome our new liechtenstein-based consultants :)
16:10:07 <Igloo> :-)
16:10:21 <SamB> olsner: that might run slower than if you wrote it in pure Haskell ;-P
16:10:43 <olsner> hmm, *only* assembly then? :P
16:11:08 <roconnor> no way, asm is pure operational semantics.  It has to be fast!
16:11:24 <SamB> no, I meant if you wrote it in nothing but assembler it would likely be slow
16:11:34 <siponen> Anything runs faster if written in 100% ASM. And makes your penis grow aswell.
16:11:36 <roconnor> oh if *I* wrote it
16:11:41 <roconnor> that's probably true
16:11:42 <newsham> depends on who wrote it in nothing but assembler
16:11:49 <SamB> if you write it in pure assembler, you probably use a horrible algorithm
16:11:53 <newsham> i'm sure if henry massalin wrote it in nothng but assembler it would be freeking fast
16:12:02 <SamB> because it's so much work to write anything in assembler
16:12:29 <siponen> SamB: You just need to organize your working.
16:12:50 <newsham> http://citeseer.ist.psu.edu/massalin92synthesi.html
16:12:51 <lambdabot> Title: Synthesis: An Efficient Implementation of Fundamental Operating System Services  ...
16:12:52 <roconnor> thanks to my assember monad, I can write it in assember and be writing in Haskell at the same time.
16:13:16 <roconnor> I might even write a few Haskell functions to automatically generate some asm code.
16:13:29 <mauke> @where harpy
16:13:29 <lambdabot> http://uebb.cs.tu-berlin.de/harpy/
16:13:31 <siponen> If you write it in asm and do it quick you are screwd. But if you write it in asm and take three years to do it it can work out.
16:13:54 <roconnor> harpy isn't mine :(
16:14:10 <SamB> but isn't it better to use assembler for a few things that you can't do in C at all, or can't do efficiently, thus saving effort so that you can put more into algorithms, and making it easier to restructure the program?
16:14:44 <SamB> siponen: that doesn't sound very cost effective
16:14:49 <roconnor> SamB: s/C/Haskell  ?
16:15:10 <siponen> C is basically a collection of macros. I'm convinced that you could write asm macros to do C
16:15:12 <Baughn> The most important thing about assembler.. its reason for existence....
16:15:17 <Baughn> You can use it to write compilers.
16:15:46 <siponen> And demos!
16:16:01 <roconnor> writing an assember in machine code must be tedious.
16:16:01 <Cale> siponen: Actually, hand-writing things in assembly is generally not quite as effective as it used to be, since processors are getting quite complicated, so taking advantage of that level of control by hand is difficult.
16:16:25 <Cale> siponen: A much more likely approach is to write a domain specific compiler for your problem, if you *really* need efficiency.
16:16:53 <Cale> (and even then, generating C can often be just as good)
16:18:06 <mapreduce> Cale: Not that I doubt you, but do you say that about hand-writing from experience?
16:18:12 <Cale> Computers can try lots of combinations which humans can't easily sort through, and can keep track of lots of little details, like when results from instructions will be ready.
16:18:41 <Cale> mapreduce: To some extent, and I've written a pipeline scheduler for PPC/Altivec.
16:19:01 <qebab> from the little x86 asm I know, I don't care enough about efficiency to write anything complicated in it
16:19:06 <dons> ?join #haskell-hac4
16:19:17 <Cale> If you want a really nice example, have a look at FFTW
16:19:19 <dons> Cale, could you add that channel to the auto list?
16:19:25 <gwern> dcoutts: are you ever going to name them? I'm wondering who outside the usual suspects would be hiring a haskell firm
16:19:34 <Cale> Which is an O'Caml program that writes C programs for fast Fourier transforms.
16:19:37 <Cale> sure
16:20:00 <Peaker> I dislike having to generate text in order to generate code...
16:20:01 <dons> gwern: from my experience, there's some surprising people using haskell , but they tend not to talk about it.
16:20:09 <dcoutts> gwern: we may do once things are firmed up and they're happy for us to use their names
16:20:15 <nominolo> Cale: what kind of scheduler?
16:20:25 <roconnor> dons: military?
16:20:29 <gwern> dcoutts: cool. 'sgood propaganda
16:20:56 <gwern> roconnor: they're the chief customer of galois, no? would make sense
16:20:56 <siponen> Actually I have not written anything in asm for anything more complicated than a MMX pentium. I just promote asm for the kicks :)
16:21:02 <dcoutts> gwern: aye, hopefully the fact that there is support available will encourage in-house commercial adoption
16:21:18 <Cale> nominolo: Basically something which scheduled the assembly instructions inside a piece of code which was doing a 'map', so as to maximise the number of units doing work in parallel (and minimise the number of clock cycles in the loop)
16:21:33 <siponen> I do use it for ZX Spectrum in the absense of a good haskell implementation though.
16:21:34 <roconnor> gwern: I thought the military thought that Haskell was too cute for it's own good
16:21:43 <nominolo> Cale: ah, software pipelining
16:21:45 <dcoutts> dons: any chance we could get a reddit link? ;-)
16:21:46 <Cale> yeah
16:21:53 <dons> roconnor: well, can't really say, but not just government clients directly, also hardware and software firms
16:21:55 <dcoutts> dons: we should think of a headline
16:22:03 <dons> http://reddit.com/r/programming/info/6esz1/details
16:22:04 <gwern> roconnor: really? I'd never heard that
16:22:04 <dobblego> dcoutts, he put one up there
16:22:06 <dons> dcoutts: done and done.
16:22:09 <dcoutts> yay!
16:22:12 <dcoutts> thanks dons
16:22:16 <dons> go team!
16:22:19 <Peaker> I think if you have optimized assembly for a special case, you should try to take the general form and ask which optimizations can be added so it knows to use those special-case optimizations...
16:22:23 <roconnor> @go Haskell "too cute for it's own good"
16:22:24 <lambdabot> No Result Found.
16:22:28 <roconnor> :/
16:22:31 <dcoutts> as gwern says, more haskell propaganda :-)
16:22:46 <gwern>  @go Haskell "too cute for its own good"
16:22:50 <roconnor> @go Haskell "too cute"
16:22:51 <lambdabot> http://www.haskell.org/papers/NSWC/jfp.ps
16:23:26 <nominolo> interesting hit
16:23:42 <roconnor> nominolo: ?
16:23:46 <gwern> an infamous paper, almost
16:24:13 <ddarius> "infamous"?
16:24:18 <nominolo> roconnor: it's kind of haskell propaganda
16:24:22 <gwern> I always wondered why that paper included awk as a language
16:24:37 <roconnor> nominolo: that it is
16:24:46 <gwern> ddarius: it's a pretty lousy study, which clueless haskell advocates like to cite, which makes us look bad
16:24:58 <gwern> (and what the heck was relational lisp anyway?)
16:25:11 <nominolo> to show how awkward programming can be .. muahahaha
16:25:15 <roconnor> nominolo: you will love how safe it is
16:25:30 <dons> dcoutts: I hope someone is keeping an eye on the server, fwiw. those statistics will be interesting.
16:25:45 <dcoutts> dons: we do have logs
16:26:00 <dons> would be worth mentioning on LtU if someone has an account there
16:26:16 <roconnor> gwern: why is it a bad study?
16:26:58 <nominolo> dons: you can always give a hint to Ehud
16:27:03 <nominolo> he'll probably post it
16:27:06 <gwern> roconnor: it's terrible statistics, it doesn't show a huge advantage for haskell - rlisp wins the content
16:27:09 <gwern> *contest
16:27:15 <gwern> and the example isn't particularly complex
16:27:52 <dons> there are no good studies in this area.
16:28:51 <gwern> which is the community's fault, in a way. we've had haskell 98 for a decade now, and we have had time to produce inumerable research papers
16:28:54 <nominolo> dons: i wonder if there ever will
16:29:34 <nominolo> dons: i mean it's extremely hard to convince people of objectiveness
16:29:47 <Peaker> Who's Ehud?
16:29:56 <Peaker> are there many Israeli names in Haskell? :)
16:30:02 <nominolo> Ehud Lamm, i think founder of LtU
16:30:09 <nominolo> not Haskell at all
16:30:12 <gwern> surely someone could get funding somewhere to do a decent in-depth study of the high level FP languages! especially given how strong haskell is in academia, which in introductory teaching offers perfect little control and test groups in large quantities!
16:30:42 <nominolo> gwern: you will always also compare the actual programmer's skills
16:31:18 <nominolo> gwern: so you have to take some measures to ensure that somehow the "intelligence" and language experience is well-distributed
16:31:22 <ddarius> gwern: There are almost no decent studies of these kinds of things at all.
16:32:34 <dons> Peaker: there's an israeli users group :)
16:32:37 <gwern> nominolo: right. take a class of freshman CS students, and randomly divvy them up. if all CS freshman have to take the same introductory class, that seems to me to be as fair a sample as you can reasonably get
16:32:49 <Peaker> the problem with these studies is that any developer using Haskell is likely to be more experienced than ones using C++/etc
16:32:55 <gwern> professors are in the best position to find comparable groups
16:33:06 <dons> i like the ICFP contest .. anyone can enter, and the C guys always end up segfaulting :)
16:33:23 <dons> ruby, python never win, despite heavy representation
16:33:37 <olsner> I think the really good C coders have already moved on to better languages
16:33:53 <roconnor> dons: well, the programer is far more important than the language
16:34:02 <dons> yep. definitely
16:34:11 <gwern> (now, this has a problem in that sore losers could claim that their language has virtues not apparent to mere beginniners and intermediate users, but if you wait for every language group to be satisfied their champions are experienced enough, then you no longer have comparable groups...)
16:34:16 <roconnor> factor of 5 or 10 as I recall
16:34:16 <dons> augustuss won the obfuscated C contest 3 times, after all :)
16:34:56 <tromp> twice more than me:)
16:35:03 <dons> hah
16:35:08 <dons> you won it 1.5 times?
16:35:08 <olsner> how do you win something half a time?
16:35:13 <roconnor> haskell and ocaml always have different metrics for better
16:35:16 <Philippa> olsner: that, or they're doing fairly specific things where C's comparatively appropriate
16:35:25 <tromp> just once:(
16:35:30 <roconnor> haskell says correctness, and ocaml says efficency
16:35:45 <gwern> olsner: some point systems make ties half a point
16:36:16 <Peaker> being efficiently incorrect sounds great :)
16:36:22 <dons> ocaml says limiting arrays to 4M is a good idea . for the speedz  ;)
16:36:30 <vincenz> dons: and 31 bit ints!
16:36:56 <dons> well, we must have the speedz!
16:36:57 <roconnor> Peaker: I agree with your sentement, but I am on #haskell
16:37:00 <Igloo> Hey, that's 2 more bits than Haskell gives you!
16:37:06 * roconnor goes trolls #ocaml
16:37:06 <vincenz> Haha, I had to laugh lately when some guy was writing a blog entry on how to represent colors in 31bits, as it was deep.  Not because O'Caml is simply limited
16:37:35 <gwern> hm. 'mai proofz. let me show you dem."
16:37:44 <olsner> hmm, I'd like to know how to represent a 32 bit color format in 31 bits
16:37:46 <vincenz> can i has speedz?
16:37:46 <dons> i can haz more bits plz?
16:37:51 <gwern> *haskell kitteh sez
16:37:58 <vincenz> olsner: well not all of the color space is equally accessed
16:38:07 <dons> haskell kitteh has a tag bits
16:38:11 <gwern> dons: is that what ocatml sez?
16:38:29 <dons> ocaml kitteh is confused about effectz
16:38:29 <vincenz> dons: palomer is now in #ocacml
16:38:38 <dons> vincenz: isn't that his seat of power?
16:38:45 <vincenz> haskell kitty likes warm fuzzy things
16:38:55 <dons> :)
16:39:07 <vincenz> I always wondered
16:39:10 <roconnor> olsner: you ignore the impossible colours due to the premultiplied alpha thing.
16:39:12 <vincenz> why not simply call 'Monad' 'Sequenced'
16:39:22 <olsner> vincenz: well, no, but if your image manipulation stuff swindles away a bit of color data somewhere, that could make some people quite annoyed (they could claim it's a "bug", even)
16:39:40 <gwern> actually... heh. 'mah warm fuzzy things. let me show you dem.' -> 'mah monads. let me show you dem.' sounds like -> 'mah gonads. let me show you dem.'
16:39:44 <vincenz> olsner: not defending the idea :)
16:39:56 <clanehin> @where lambdacats
16:39:56 <lambdabot> http://arcanux.org/lambdacats.html
16:40:12 <olsner> vincenz: *phew*, you had me worried for a bit there :)
16:40:56 <vincenz> 5 .+ 3
16:41:11 <Peaker> > 5 .+ 3
16:41:12 <lambdabot>   Not in scope: `.+'
16:41:21 <vincenz> oh, wait, +.
16:41:28 <Peaker> > 5 +. 3
16:41:28 <lambdabot>   Not in scope: `+.'
16:41:32 <roconnor> vincenz: it isn't a colour access thing, some colours are impossible because every channel must be less than the alpha channel.
16:41:49 <Peaker> why must every channel be less than the alpha channel?
16:42:18 <roconnor> Peaker: because essetially every image operation works with premultipled alpha.
16:42:32 <gwern> Peaker: it's the dominance hierarchy
16:42:54 <gwern> if a channel thought it was greater than the alpha channel, they'd inevitably have to fit over the bitches
16:43:01 <roconnor> Peaker: in the limit transparent black and transparent white are the same colour
16:43:28 <vincenz> only to the eye :P
16:46:21 <Baughn> I still say colors should be expressed with frequency/intensity splines
16:46:56 <Baughn> (RGB won't suffice when you want your screen to emit gamma)
16:47:18 * olsner wouldn't want to get gamma rays from his monitor
16:47:41 <PenguinOfDoom> A matter of system security, clearly.
16:47:52 <roconnor> Baughn: ideally
16:49:26 <pjd> Baughn: won't someone think of the tetrachromats?
16:49:58 <Baughn> pjd: Well, I do
16:50:05 <Peaker> Baughn, our eyes are equipped with RGB sensors though
16:50:35 <Baughn> Peaker: Not always. Pjd has a point - some women may have four kinds
16:50:50 <Peaker> really? what frequencies do they catch?
16:51:16 <Baughn> Apparently, something between red and green
16:51:24 <pjd> Peaker: each of R, G and B are frequency distributions themselves, though
16:51:26 <Baughn> ...which isn't yellow
16:52:05 <clanehin> I think that there are two different genes for red receptors, on slightly different frequencies, normal people may have either, but some people have both
16:52:16 <clanehin> That
16:52:21 <clanehin> s what I remember reading.
16:52:22 <Baughn> Mm. The brain is quite capable of extrapolating colors that an RGB screen simply can't pretend to show
16:52:30 <Baughn> Even *without* four different cones
16:52:51 <newsham> women can alse sense fear
16:53:16 <idnar> right, an RGB gamut isn't sufficient to cover the spectrum of visible light
16:53:57 <Baughn> Right, so we should be using (arbitrarily dense) splines over the frequency/intensity domain
16:54:35 <Baughn> As a bonus, it'd keep harddisk manufacturers happy
16:56:18 <Saizan> you have to show them on a screen anyway!
16:56:31 * Saizan hates printers
16:56:44 <Baughn> And every screen has a different gamut!
16:57:15 <Baughn> At least with a physical definition there's no question about what the values mean
16:57:25 <pjd> Baughn: you don't need splines;  C.I.E.!
16:57:36 <aFlag> @help
16:57:36 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:57:51 <roconnor> pjd: for proper image composition, you need splines.
16:58:10 <idnar> L*a*b
16:58:19 <Baughn> pjd: CIE isn'T future-proof. Eventually I'll want new, better eyes that can resolve a much larger spectrum.
16:59:31 <pjd> Baughn: then splines are also not future-proof;  what about polarity?
17:00:00 <pjd> seems to be one of the first things you'd want to augment
17:00:24 <Baughn> pjd: You have a point. We need a surface on a frequency-intensity-polarity volume instead, then
17:01:46 <Baughn> (That said, I'm not sure that seeing polarities would be all /that/ useful. I'd take it just because I can.)
17:02:10 <pjd> Baughn: think polarized sunglasses
17:02:11 <Cale> I'd love to be able to see the polarisation of light directly :)
17:02:35 <astrolabe> I think people can, with practice.
17:02:41 <Baughn> pjd: So I'd be able to tell that they're polarized and not simply tinted. And?
17:03:00 <Cale> astrolabe: I think people can, with polarimeters :)
17:03:12 <pjd> Baughn: no, i mean, have you ever tried looking through polarized glasses at various things, tilting them this way and that?
17:03:16 <astrolabe> Cale: http://polarization.com/haidinger/haidinger.html
17:03:16 <clanehin> Gregory Benford wrote quite a bit about humans with such enhanced visual abilities.
17:03:16 <lambdabot> Title: Haidinger's brush: the unknown sense
17:03:18 <pjd> at a car in the sun, for example
17:03:29 <Baughn> pjd: Hm. No; they don't sell them here
17:03:35 <Baughn> I should go borrow one from the physics lab
17:03:36 <pjd> tilt it one way, and you just see the sun reflection
17:03:45 <roconnor> the blue-yellow mechanism in the eye is slightly senetive to polarity.
17:03:54 <pjd> tilt it the other way, and you see the inside of the car instead
17:04:57 <pjd> similar for many other kinds of reflections off surfaces
17:05:55 <Baughn> pjd: If that's true, then seeing polarity would be *incredibly* useful
17:06:16 <Baughn> You'd be able to see both the inside and the reflection at once, without confusing them
17:06:26 <pjd> if you were able to perceive polarity more directly, i imagine you'd be able to experience it somewhat more like color
17:06:51 <pjd> different mixtures of polarity would lend a sort of "light texture" to things
17:07:15 <Baughn> We already use color for, well, color. Shouldn't it be an orthogonal qualia?
17:07:29 <pjd> yes, orthogonal
17:07:40 <Baughn> ..crafting new sensory modalities is still a bit unusual. Should be interesting when we can try it.
17:08:01 <pjd> i mean "like color" in the same way that we perceive color as an instantaneous thing, instead of separate sensations of R/G/B
17:08:17 <Baughn> Aha. Yes.
17:09:01 <pjd> so instead of tuning to a specific polarity like you can do with tilting polarized glass, you'd just sense whatever polarity/ies are there
17:09:10 <OceanSpray> are there any languages whose compilers were written in Haskell, and STAYED in Haskell?
17:09:14 <Baughn> At least increasing color resolution and range should be fairly straightforward. In comparison.
17:10:14 <gwern> OceanSpray: haskell? :) other FP langs?
17:10:18 <dons> OceanSpray: almost all of them?
17:10:33 <dons> OceanSpray: what ones didn't stay in haskell?
17:10:37 <dons> http://haskell.org/haskellwiki/Applications_and_libraries/Compilers_and_interpreters
17:10:40 <lambdabot> Title: Applications and libraries/Compilers and interpreters - HaskellWiki, http://tinyurl.com/2dt77g
17:15:01 <gwern> 'I told the story of why MediaWiki is written in PHP. (Magnus had read up on PHP to make some changes to NuPedia code, and decided he  needed a project. So Phase 2 is Magnus' first ever proper PHP program  ...)'
17:17:17 <dons> and a whole new industry was born
17:17:57 <gwern> mediawiki syntax doesn't even have a parser. it's 'a twisty pile of regexps'
17:21:30 <hpaste>  bododo annotated "a yaht exercise" with "(no title)" at http://hpaste.org/6875#a2
17:33:53 <TomMD> Why does 'length' for lazy bytestrings an Int64 while strict ByteStrings give an Int?  I suppose strict bytestrings not be over maximum :: Int, right?
17:34:24 <mofmog> how do i set a time delay?
17:34:24 <Baughn> TomMD: An Int is as large as a pointer on every platform haskell runs on
17:34:53 <Baughn> TomMD: A strict bytestring is all in memory at once, so it isn't possible for it to be longer than what an Int can represent
17:35:28 <newsham> the string is a proof
17:35:47 <clanehin> Baughn: but Int is signed.  :)
17:36:01 <ddarius> Int is only required to be 29-bits regardless of platform.
17:36:08 <gnuvince_> @help check
17:36:08 <lambdabot> check <expr>
17:36:08 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
17:36:10 <TomMD> And, depending on the implementation, is not a full machine int.
17:36:16 <TomMD> yeah, what ddarius said.
17:36:39 <Baughn> Hm. Then it depends on how large the elements are
17:36:42 * heatsink doesn't like to assume that an int is the same size as a pointer.
17:36:51 <Baughn> If they're always at least eight bytes, 29 bits (or 61) would be enough
17:37:08 <TomMD> Baughn: They are 8 bits
17:37:21 <Baughn> ..right. bytestring.
17:37:30 <Baughn> Why *shouldn't* Int be a full machine word, though? What does it need a type tag for?
17:38:08 <ddarius> Baughn: The Report only guarantees at least 29-bits.  In GHC, I think it is 31 or 32.
17:38:17 <ddarius> (on 32-bit platforms)
17:38:24 <TomMD> iirc, GHC uses 31 bit ints.
17:38:25 <Baughn> > maxBound :: Int
17:38:28 <lambdabot>  2147483647
17:38:36 <Baughn> That's 32 bits
17:38:42 <heatsink> Baughn: I think it's to allow for an implementation like some Lisp implementations, where 2 bits of each word are used for metdata.
17:39:06 <Baughn> heatsink: Reasonable, and the report never guarantees that Int is as large as a pointer either
17:39:24 <Baughn> Still, I'm pretty sure that assumption is why bytestring.length returns an Int and not an Integer
17:39:52 <newsham> > maxBound :: Int
17:39:52 <newsham> 9223372036854775807
17:39:53 <lambdabot>  2147483647
17:40:16 <TomMD> I appriciate that bytestring does that, but think such assumptions are more appropriate for ListLike than ByteString.
17:40:31 <heatsink> > log 9223372036854775807
17:40:32 <lambdabot>  43.66827237527655
17:40:39 <heatsink> > log 9223372036854775807 / log 2
17:40:40 <lambdabot>  63.0
17:40:56 <hpaste>  Paczesiowa pasted "shell pipe" at http://hpaste.org/6877
17:41:25 <newsham> > log (fromIntegral (maxBound :: Int)) / log 2
17:41:25 <newsham> 63.0
17:41:25 <lambdabot>  30.999999999328196
17:42:25 <paczesiowa> http://hpaste.org/6877 - any hints why it works for 2 processes and doesn't work for >2 ?
17:43:00 <Baughn> paczesiowa: In what sense does it not work?
17:43:25 <dons> TomMD: 32 and 64 bits for Int
17:43:33 <paczesiowa> it doesn't do "anything" no cpu usage, no ram usage and no output
17:43:55 <dons> Int64 for lazy bytestrings, fwiw
17:45:46 <dons> dcoutts, Igloo are you announcing something on the well-typed blog? :)
17:46:20 <dcoutts> dons: we've not set up a blog yet, but we probably will
17:46:33 <dons> i think its a good idea.
17:46:37 <dcoutts> me too
17:47:03 <Cale> http://cale.yi.org/autoshare/Physics-Pwnage.png -- ah, nothing like abusing the infelicities of Newtonian mechanics implementations to cheat at games.
17:47:04 <Baughn> paczesiowa: Got it. Try compiling with -threaded.
17:47:07 <dcoutts> dons: which is why I was asking the other day about what blog software you use or would use
17:47:18 <dons> dcoutts: yeah. maybe we can work out something during the hackathon
17:47:23 <dons> i'd like to get mine set up again
17:47:35 <newsham> The requested URL /autoshare/Physics-Pwnage.png - was not found on this server
17:47:45 <Cale> hmm
17:47:53 <Cale> I wonder...
17:47:56 <newsham> oops, added space-dash
17:47:58 <dcoutts> dons: what sort of thing were you imagining?
17:48:08 <dons> oh, something like jane streets
17:48:23 <dons> http://ocaml.janestcapital.com/
17:48:24 <lambdabot> Title: ocaml.janestcapital.com
17:48:24 <dcoutts> dons: I'd like static html on the server side with xhtml and css of the main website
17:48:25 <paczesiowa> Baughn: without -threaded it doesn't work even with 2 processes
17:48:29 <Cale> newsham: so it's there?
17:48:35 <dons> dcoutts: yep. agreed
17:48:40 <newsham> yah its there
17:48:56 <mofmog> hmm
17:48:56 <dons> the ability to accept comments , and to index/search/find popular posts
17:48:58 <dons> is also useful
17:49:05 <paczesiowa> maybe there is -threaded2 or -threadedN
17:49:09 <mofmog> is there any library function that simply pauses for a set amount of time?
17:49:18 <dons> threadDelay
17:49:19 <paczesiowa> threadDealy
17:49:25 <Baughn> paczesiowa: ..I /thought/ I figured it out, but nope
17:49:30 <mofmog> that works even if i'm not using threads?
17:49:39 <paczesiowa> mofmog: yes
17:49:42 <tromp> > 211674*0.03
17:49:42 <lambdabot>  6350.219999999999
17:49:48 <paczesiowa> mofmog: you always use at least 1 thread:>
17:49:50 <dons> dcoutts: with links to code you have available, projects you're working on in the community, etc.
17:50:06 <dons> people would come to the blog, and you build up exposure
17:50:18 <dcoutts> dons: I'm not convinced about the utility of commenting, a list of popular posts is useful
17:50:35 <dons> true enough, comments can be done via reddit.
17:50:53 <hpaste>  Baughn annotated "shell pipe" with "This fixes it" at http://hpaste.org/6877#a1
17:50:57 <dcoutts> dons: to be honest, I suspect most people read through a planet aggregateor or their rss feed reader
17:51:16 <dons> yes. though if they do click through, and explore around, its good to facilitate that
17:51:21 <Cale> newsham: (The idea being that when shapes overlap, there's an extra force which pushes them apart, which you can abuse :)
17:51:23 <tromp> > 6350*0.667
17:51:24 <lambdabot>  4235.45
17:51:31 <tromp> > 6350*0.66667
17:51:32 <lambdabot>  4233.3544999999995
17:51:56 <tromp> > 19837-4233
17:51:57 <lambdabot>  15604
17:52:11 <Baughn> paczesiowa: That said, I'm not sure /why/ it fixes it..
17:52:12 <newsham> i dont know what that magic pen thing is
17:52:26 <Cale> http://armorgames.com/play/1177/magic-pen
17:52:26 <lambdabot> Title: Magic Pen | Armor Games
17:52:31 <heatsink> Cale: You would probably enjoy Gish.
17:52:33 <PenguinOfDoom> I think it's broken, at least in the flash player I have.
17:52:34 <TomMD> lambdabot needs a Pentium plugin - it returns the results as computed by the original (buggy) Pentium.
17:52:41 <Cale> heatsink: yeah, Gish is pretty cool
17:52:44 <Baughn> paczesiowa: Well, I am, but rather.. it's not a good solution
17:53:12 <paczesiowa> Baughn: it still doesn't work
17:53:20 <mofmog> threadDelay seems to not be delaying 0_0
17:53:35 <Cale> mofmog: Note that the parameter is in microseconds
17:53:37 <paczesiowa> it takes sam microseconds
17:53:56 <mofmog> Cale: i know
17:54:08 <mofmog> that's why i put in 100000000000000 to see if there was an effect ;-P
17:54:08 <Baughn> paczesiowa: It does if you use 'cat' as all three programs
17:54:30 <Baughn> paczesiowa: stdin doesn't seem to close properly, though
17:54:44 <keseldude> Cale: About lambdabot... the replacement for setCPULimit in Resource.hs didn't work, so I removed that from RunPlugs.hs
17:54:49 <Cale> mofmog: That was the exact number?
17:54:50 <keseldude> is there anything particularly wrong with that?
17:54:57 <Cale> :t threadDelay
17:54:58 <lambdabot> Not in scope: `threadDelay'
17:54:59 <mofmog> 10000000000000000000000000000000
17:55:04 <Cale> :t Control.Concurrent.threadDelay
17:55:05 <lambdabot> Int -> IO ()
17:55:12 <Cale> > 10000000000000000000000000000000 :: Int
17:55:12 <lambdabot>  -2147483648
17:55:18 <mofmog> well that could be it
17:55:25 <TomMD> mofmog: try maxBound
17:55:32 <paczesiowa> Baughn: ok, it depends on commands
17:55:34 <mofmog> :t maxBound
17:55:35 <lambdabot> forall a. (Bounded a) => a
17:55:41 <dons> are you trying to time something out, instead of using rlimit?
17:55:45 <Cale> keseldude: That's fine
17:56:08 <keseldude> If it's fine, then how did it help before?
17:56:09 <Cale> keseldude: If setResourceLimit works better, then use that
17:56:22 <keseldude> I don't do either
17:56:23 <Cale> keseldude: setResourceLimit is broken on some systems.
17:56:32 <keseldude> I don't set any resource limit
17:56:37 <Cale> Oh, well, then there will be no CPU limit for evaluating Haskell expressions
17:56:43 <Cale> Which might be a problem for you.
17:56:47 <keseldude> it still kills the thread
17:56:49 <keseldude> if need be
17:56:52 <Cale> Interesting.
17:57:07 <Cale> Maybe we should drop it altogether then :)
17:57:08 <paczesiowa> Baughn: it doesn't want to work with any command but cat (no grep, no tail)
17:57:14 <keseldude> :)
17:57:28 <keseldude> want me to have it connect so you can do some intense tests on it?
17:57:31 <Baughn> paczesiowa: Something certainly isn't behaving right, but I'm not sure whether it's haskell or the system
17:57:35 <Cale> keseldude: sure
17:57:42 <keseldude> i'll just have it join #lbot
17:58:09 <hpaste>  Baughn annotated "shell pipe" with "paczesiowa: What does this give you?" at http://hpaste.org/6877#a2
17:59:27 <dancor> who do tell that http://www.haskell.org/tutorial/moretypes.html has !$ instead of $!.  or is it a hidden exercise for the reader
17:59:27 <lambdabot> Title: A Gentle Introduction to Haskell: Types, Again
17:59:42 <paczesiowa> Baughn: it doesn't help
17:59:50 <keseldude> or not
17:59:57 <keseldude> #lbot requires a key
18:00:07 <keseldude> how about #lbottest
18:00:09 <paczesiowa> maybe only charbychar commands work, other fail because handles stay open
18:00:13 <Baughn> paczesiowa: Wasn't supposed to. How many "closed"s does "echo foo|./a.out cat cat cat" give you?
18:00:56 <paczesiowa> Baughn: wait, didn't notice those strings, just copied last flush:P
18:01:49 <Baughn> paczesiowa: *Sometimes* I get "closed1foo", *sometimes* I get just "foo"
18:01:52 <Baughn> It's very odd
18:02:17 <paczesiowa> I don't get even one closed
18:02:29 <newsham> cale: ok this game is friggin fun
18:03:48 <dcoutts> dons: seems like pandoc would be the obvious choice for a haskell blog markup
18:04:37 <SamB> jhc's documentation is done with pandoc now, apparantly... I should really see what happens when you do it...
18:05:09 <paczesiowa> Baughn: maybe it's because hGetContents is lazy?
18:05:54 <Baughn> paczesiowa: Not /that/ lazy. I honestly don't understand this at all.
18:06:16 <SamB> has anyone ever asked the question "where the heck did this value come from"?
18:06:35 <allbery_b> just about everyone debugging a program :)
18:06:44 <SamB> I have an answer
18:06:57 <paczesiowa> 42?
18:07:13 <SamB> ... no
18:07:29 <SamB> my answer piggybacks on heap profiling!
18:07:37 <paczesiowa> yeah, that would work only for Num
18:07:50 <Baughn> paczesiowa: Hang on
18:08:51 <SamB> I wrote a primitive for GHC that will tell you what the cost center stack for a particular value is
18:09:40 <SamB> does that sound usefull?
18:10:05 <Baughn> paczesiowa: According to the strace output, the following things happen: "foo" is read from stdin, stdin is closed, foo is written to in1, in1 is closed, the first cat process reads foo, it writes foo, and it proceeds to never see a closed stdin
18:10:27 <Baughn> paczesiowa: That seems like a problem with the underlying OS, except that the exact same thing happens on OS X and linux
18:11:31 <SamB> it was inspired in part by -xc, and partly by the fact that just picking things out of the heap profile wasn't working too well.
18:12:11 <SamB> so I got to thinking, "wouldn't it be great if I could ask the RTS what the cost center stack for *this* value is?"
18:12:13 <Baughn> paczesiowa: Anyhow, the program never proceeds because the first cat never closes stdout - because it never realizes that stdin is closed, because read never returns 0..
18:12:39 <SamB> so eventually I wrote a feature request
18:12:51 <SamB> now I've implemented the primitive ;-)
18:13:03 <TomMD> And submitted the patch?
18:13:10 <SamB> indeed
18:13:22 <TomMD> Do you know which GHC release it will be in?
18:13:28 <SamB> no idea
18:13:32 <Saizan> SamB: you get a SCC name in the program?
18:13:46 <SamB> Saizan: well, actually it just gets printed onstderr
18:13:56 <paczesiowa> Baughn: so I've broken yet another thing? I'm one lucky sob
18:14:11 <TomMD> SamB: Based on your answers I can't give you a marketing job, but perhaps a programming job ;-)
18:14:14 <Baughn> paczesiowa: I'm not sure what yet, but SIGPIPE looks suspicious
18:14:33 <SamB> TomMD: that's good, because I would hate a marketing job
18:14:58 <paczesiowa> Baughn: maybe its ghc bug? do you have 6.6 to test with?
18:15:26 <Baughn> paczesiowa: I'd call it a ghc bug. On 6.8.2 here, though
18:15:39 * SamB decides that GHC has thrashed for long enough, kills the JHC compile
18:15:46 <paczesiowa> Baughn: same here
18:16:17 <TomMD> paczesiowa, Baughn: I've the GHC Head from today, if you want me to test something.
18:16:39 <Baughn> TomMD: http://hpaste.org/6877#a2 <-- Please, run the last paste (compile with -threaded) and tell me what you get
18:16:48 <Baughn> TomMD: A couple times. There seems to be a race condition too.
18:17:00 <Baughn> TomMD: Ah, run with "echo foo | ./a.out cat cat cat"
18:18:31 <TomMD> Baughn: 'closed1foo' every time.
18:19:01 <Baughn> TomMD: Bug's not fixed, then. Unless you can explain that behaviour..
18:19:03 <TomMD> compiled with --make -threaded and tested with (and without) +RTS -NX
18:19:16 <Baughn> TomMD: But I've got a truly mystifying strace readout here, too. :/
18:22:24 <koninkje_away> is there an efficient function for doing folds over arrays (without getting a list of the elements)?
18:22:30 <koninkje_away> ?nick koninkje
18:22:30 <lambdabot> Maybe you meant: dice dict
18:24:02 <Baughn> paczesiowa: Oh, wait. I get it now
18:24:24 <Baughn> paczesiowa: No pipe will be considered closed until *no* processes have handles to it, of course
18:24:29 <SamB> koninkje: yeah
18:24:49 <koninkje> SamB: where?
18:25:01 <Baughn> paczesiowa: ..and never mind. Drat. Thought I had it too.
18:25:03 <SamB> koninkje: you get someone to write a Streams enabled version of the function that gives you a list of elements
18:25:06 <Baughn> paczesiowa: I'll go sleep on this
18:25:14 <SamB> and rewrite rules to go with it
18:25:14 <paczesiowa> Baughn: thanks:P
18:25:27 <SamB> then you fold over the list of elements
18:26:01 <koninkje> alas, I'm stuck with 6.6 and no streams libraries for this project
18:28:33 <Baughn> paczesiowa: Alright. Following the foos.. one program writes it to FD #6, the open end of one pipe. It the promptly closes that fd, but the reader never notices that it's closed..
18:29:23 <Baughn> paczesiowa: The program calls vfork a total of 3 times, all after making the pipe; all three will have copies of the pipe
18:29:33 <Baughn> But said pipe is only closed *twice
18:29:53 <Baughn> Nailed it!
18:30:53 <Cale> http://uk.youtube.com/watch?v=Rjdo-RWQVIY -- New Catsters video!
18:30:53 <lambdabot> Title: YouTube - Eckmann-Hilton 1
18:30:57 <Baughn> paczesiowa: When you hClose a pipe, apparently only the OS thread that hClose happens to be running in actually calls close. The others don't.
18:31:24 <Baughn> paczesiowa: Meaning the OS doesn't know that it won't be written to, and so cat never knows that it'll get no further input
18:31:28 <Baughn> This is a definite bug
18:34:25 <paczesiowa> ghc or os bug? if os bug then I'll be famous:D
18:34:39 <Baughn> Nope, ghc bug
18:35:07 <SamB> is that a GHC bug?
18:35:15 <Baughn> I'm still not sure I understand what is going on here, though. Yes, that is part of it, but it also calls pipe way too many times
18:35:19 <SamB> what does POSIX say about close and threading?
18:35:20 <gwern> @where lambada
18:35:20 <lambdabot> I know nothing about lambada.
18:35:33 <cjb> @where lambda
18:35:33 <lambdabot> I know nothing about lambda.
18:35:53 <gwern> cjb: no, lambada
18:35:57 <cjb> oh :)
18:36:00 <gwern> as in, 'Lambada, Haskell as a Better Java'
18:36:31 <cjb> Ah.  http://research.microsoft.com/~emeijer/papers/lambada.pdf
18:36:36 <cjb> looks interesting!
18:36:37 <Baughn> SamB: "With CLONE_FILES, if one closes they all do"
18:36:48 <Baughn> SamB: This is getting interesting. Still ghc bug, but.. :)
18:37:16 <paczesiowa> could you file that bug? I don't understand all that stuff. in fact that was the first multithread program I wrote (my friend had to do that in C and I was trying to impress him with haskell 5liner:)
18:37:39 <Baughn> paczesiowa: Sure, once I'm sure I understand what'S going on
18:37:47 <mattr__> anyone ever seen an error like this out of ghc?
18:38:05 <hpaste>  mattr__ pasted "crazy error" at http://hpaste.org/6878
18:38:15 <gwern> I guess lambada is dead
18:38:16 <Baughn> SamB: ghc calls vfork a lot, I'm afraid
18:38:23 <solrize_> haskell progs generally aren't supposed to know the difference between an io thread and an os thread, so what should closing a pipe really do
18:38:39 <mattr__> or 200 of them in one hit?
18:38:40 <heatsink> mattr__: looks like an error in the C backend.  What system are you running on?
18:38:41 <dons> very cool, http://reddit.com/info/6etbz/comments/
18:38:52 <dons> pure haskell sound file hacking
18:38:58 <Baughn> solrize_: hClose should close it in every possible sense of the word. Simple. So nothing could ever even /think/ of reading from it again.
18:39:13 <mattr__> dons: nice
18:39:14 <solrize_> right, so what happens instead?
18:39:21 <Baughn> You get EOF
18:39:33 <solrize_> on writing?  not SIGPIPE?
18:40:06 <solrize_> hcodecs sounds nice
18:40:07 <Baughn> On writing you'd get EBADF, I bet
18:40:19 <solrize_> ok
18:40:26 <Baughn> For reading, both EOF and SIGPIPE
18:40:39 <Baughn> But what it seems is that ghc doesn'T quite manage to close all the handles
18:41:49 <solrize_> because the os forks have made extra ones.  hmm.
18:42:53 <Baughn> runInteractiveCommand makes pipes, vforks, dup2s the right ones into stdin/out/err and closes all the extraneous FDs including the other ends, but crucially /doesn't shut down any other FDs than the ones it made itself/
18:43:01 <Baughn> Now I need to find its source
18:43:39 <Baughn> (Also, why vfork? It rather sucks. Fork is nicer.)
18:44:07 <solrize_> ???
18:44:21 <solrize_> fork makes a separate heap
18:44:23 <solrize_> i thought
18:44:45 <Baughn> Yes
18:44:47 <Baughn> It does
18:45:24 <Baughn> You have to be extraordinarily careful with vfork to avoid corrupting your program. I suppose you could take advantage of it, but that sort of code would be fragile beyond belief
18:45:42 <solrize_> well, yeah, that's the traditional hazard of threading
18:45:47 <hpaste>  Baughn annotated "shell pipe" with "Relevant strace output - see what happens to fd 6 (and others)" at http://hpaste.org/6877#a3
18:46:02 <mattr__> has anyone else had a go at getting ghc to work on a ppc *AND* intel macosx install?
18:46:39 <paczesiowa> Baughn: why does it work with 2 commands?
18:47:29 <Baughn> paczesiowa: Pure chance
18:47:37 <gwern> @seen lispy
18:47:37 <lambdabot> lispy is in #darcs, ##logic, #ghc, #haskell-blah and #haskell. I last heard lispy speak 5h 8m 43s ago.
18:47:37 <heatsink> mattr__: Both?  You're only running on one architecture, right?
18:47:39 <SamB> http://hackage.haskell.org/trac/ghc/ticket/2191
18:47:39 <lambdabot> Title: #2191 (A way to programmatically cause GHC to report the cost center stack assoc ...
18:47:44 <gwern> @tell lispy http://hackage.haskell.org/cgi-bin/hackage-scripts/package/helisp-0.1
18:47:44 <lambdabot> Consider it noted.
18:47:52 <mattr__> heatsink: I run on both arcitectures
18:48:01 <SamB> that's the feature request ticket for my primitive ;-)
18:48:06 <Baughn> paczesiowa: The relevant input pipe /somehow/ ends up getting closed all the way, which allows the first program to quite - taking open FDs with it - it all unravels from there
18:48:07 <paczesiowa> Baughn: pure is good:P
18:48:10 <mattr__> not at once, but both in any one day - from the same boot disk
18:48:20 <Baughn> paczesiowa: Perhaps, but chance is in IO
18:48:29 <paczesiowa> Baughn: :D
18:49:09 <heatsink> A GHC build only targets one architecture though.
18:50:03 <mattr__> heatsink: indeed - but thanks to rosetta, I have been happily working away for a while now with a ppc build on the universal boot disk
18:50:27 <mattr__> until today, all was going well
18:50:50 <heatsink> So you're running a PPC emulator on x86?
18:51:13 <mattr__> I don't know how apple do it, but ppc binaries can run on an x86
18:51:32 <mattr__> that is how most of my command line programs are running
18:51:35 <SamB> apple always does that
18:51:39 <heatsink> Does your gcc generate x86 or PPC binaries?
18:51:45 <mattr__> and never a peep of trouble till today
18:51:53 <mattr__> heatsink: that is the question
18:52:00 <SamB> at least, since Mac OS began, they've always had a very smooth transition to the next architecture
18:52:03 <mattr__> I think it generated native since it is going via c
18:52:25 <mattr__> and the gcc in mac osx will target whatever you are compiling from
18:52:37 <mattr__> there is a tag to make fat binaries, but I don't bother with that
18:53:15 <heatsink> GHC generates inline assembly code on some architectures.  I think the problem is that GHC is generating assembly for PPC and GCC is trying to compile x86.
18:53:23 <mattr__> heatsink: sorry, I read gcc as ghc :)
18:53:35 <mattr__> i have tried the -fvia-C tag
18:53:51 <mattr__> it changed my errors, but didn't fix the problem
18:54:09 <mattr__> I have been working this way for 6 months now, sometimes I work in ghci, sometimes with ghc
18:54:19 <mattr__> and I can't remember if I have ever tried ghc on intel
18:54:24 <mattr__> I know I have done ghci on both
18:54:34 <mattr__> and I *thought* I had used ghc on both
18:54:38 <mattr__> but now I am not so sure
18:56:51 <heatsink> Does GHC work correctly on one of the architectures?
18:56:59 <mattr__> yes
18:57:05 <heatsink> Which compile/run combinations work?
18:57:08 <mattr__> I have used ghc to compile the code many times
18:57:28 <mattr__> I *thought* I had used all combintations, but now I am not so sure about ghc/intel
18:59:21 <mattr__> I just checked then and ghci and intel are happy
18:59:32 <mattr__> the program is loaded and run no problems
18:59:45 <mattr__> but I want to do some profiling
19:00:10 <SamB> ... and even if you build GHC for profiling, GHCi won't work that way...
19:00:30 <SamB> http://hackage.haskell.org/trac/ghc/ticket/2197
19:00:33 <lambdabot> Title: #2197 (GHCi doesn't work when built with way=p) - GHC - Trac
19:00:39 <mattr__> so I need ghc
19:02:30 <heatsink> Hmm.  It would help if we knew what architecture is assumed by ghc, and what architecture is assumed by gcc.  Does --version tell you anything about the architecture?
19:03:38 <SamB> ghc +RTS --info
19:03:44 <SamB> tells ALL
19:04:17 <SamB> well, for GHC
19:07:08 * Baughn notes that the Storable instance for FD is truly despicable - probably, if only I could find it
19:08:05 <Baughn> @hoogle alloca
19:08:05 <lambdabot> Foreign.Marshal.Alloc.alloca :: Storable a => (Ptr a -> IO b) -> IO b
19:08:05 <lambdabot> Foreign.Marshal.Alloc.allocaBytes :: Int -> (Ptr a -> IO b) -> IO b
19:08:05 <lambdabot> Foreign.Marshal.Array.allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
19:08:16 <SamB> gcc -dumpmachine
19:08:24 <SamB> heatsink: got all that?
19:09:02 <heatsink> SamB: ghc +RTS --info tells me that "--info" is an unrecognized option.  Is it a new ghc feature?
19:09:23 <SamB> heatsink: how ancient is your ghc ?
19:09:26 * heatsink has ghc 6.6
19:09:29 <heatsink> not 6.6.2
19:09:34 <mattr__> heatsink: gcc tells me it is on i686
19:09:35 <SamB> well, I have a 6.8
19:09:51 <mattr__> samb: I have 6.6.1 and it won't info me
19:10:11 <mattr__> if I had 6.8 I would be OK because I could use the ghci debugger!
19:10:25 <SamB> why would you want to do that?
19:10:39 <SamB> oh, I suppose that might work if you had a small enough progream
19:10:42 <mattr__> I finally found the ammouncement dons was talking about
19:10:50 <mattr__> there may be a 6.8.X I can user
19:11:11 <mattr__> I only ever debug a few methods at a time
19:11:25 <mattr__> is there something wrong with the ghci debugger?
19:11:36 <SamB> I meant, small enough that loading it in GHCi was tolerably fast
19:11:46 <TomMD> Only that it requires your first born to run.
19:11:58 <mattr__> :)
19:12:00 <SamB> I haven't tried the GHCi debugger
19:12:10 <SamB> because invariably the code is already compiled
19:12:21 <SamB> when I even so much as think about it, the code is compiled
19:12:32 <mattr__> :)
19:12:33 <TomMD> I really like it.  Damn g-machine eval order is a bit of a mind job, but hey - its fun.
19:12:47 <mattr__> I am really looking forward to fiddling with it
19:12:48 <gwern> anyone know if Conrad Parker is really busy or something? his hOgg doesn't even work on 6.8.x, but it's been a week since I sent my patches and emailed him and nothing
19:13:15 <TomMD> gwern: Conrad just got involved with a startup.
19:13:28 <TomMD> and he lives in DC so his cost of living is already high.
19:13:53 <TomMD> wait... sorry, wrong conrad... silly me.
19:13:56 <gwern> TomMD: oh. is he the kind of person who would take it amiss if I did a hackage upload?
19:14:00 <gwern> ...
19:14:56 <SamB> anyway, I eventually went and implemented this http://hackage.haskell.org/trac/ghc/ticket/2191
19:14:58 <lambdabot> Title: #2191 (A way to programmatically cause GHC to report the cost center stack assoc ...
19:25:12 <Baughn> Has anyone written a shell (that supports pipes) in haskell before?
19:26:13 <cjb> Baughn: http://changelog.complete.org/posts/492-Announcing-HSH,-the-Haskell-Shell.html
19:26:15 <lambdabot> Title: Announcing HSH, the Haskell Shell - The Changelog, http://tinyurl.com/5aemuf
19:26:17 <gwern> Baughn: yes
19:26:26 <gwern> but personally, I'd just use...
19:26:32 <gwern> ah, I see cjb linked hsh
19:27:19 <Baughn> ..I see. It /did/ seem odd that a bug that would prevent all pipe chains could have gone unnoticed.
19:27:40 <cjb> http://www.haskell.org/hashell/ seems different
19:27:42 <lambdabot> Title: Hashell :: Home Page
19:35:17 <cjb> you've gotta have guts to name your tool as a valid contraction of "haskell-hell".
19:39:01 <s710b> @src findIndex
19:39:01 <lambdabot> findIndex p     = listToMaybe . findIndices p
19:42:50 <s710b> Why does findIndex return Maybe Int and not just plain Int?
19:43:30 <Saizan> > findIndex (==0) [1..10]
19:43:31 <lambdabot>  Nothing
19:43:49 <Saizan> see?
19:43:51 <oklofok> @die 1d2
19:43:52 <lambdabot> 1d2 => 2
19:45:55 <s710b> Saizan, yeah. i had to use fromJust $ findIndex ... and thought it doesnt look so pretty
19:47:03 <s710b> but i can see the reason now
19:50:08 <gwern> hashell is kind of dead though
19:50:17 <gwern> so good for looking at and stealing code from
19:50:40 <aFlag> hashell is a shell in haskell?
20:16:12 <dobblego> when you download GHC source, do you get QuickCheck as well, these days?
20:16:36 <SamB> dobblego: well, it didn't install when I ran "make install"
20:16:46 <dobblego> uh oh, I'm going to have an annoyed client
20:16:50 <SamB> oh?
20:17:06 <dobblego> he just finished compiling GHC and asked "where is QuickCheck?"
20:17:50 <solrize_> quickcheck is included with 6.8.2 and maybe some earlier as well
20:17:52 <SamB> he needs to run ./darcs-all get ... uh ...
20:18:13 <SamB> --extra
20:18:34 <solrize_> *HSH> run $ ("ls", ["-l"]) -|- ("wc", ["-l"])
20:18:34 <solrize_> 12
20:18:36 <solrize_> hahaha
20:18:50 <dobblego> solrize, :m Test.QuickCheck -> Could not find module `Test.QuickCheck'
20:19:06 <SamB> dobblego: did you see what I wrote?
20:19:18 <SamB> also, he'll need to re-invoke make and make install...
20:19:20 <solrize_> Prelude> :m Test.QuickCheck
20:19:20 <solrize_> Prelude Test.QuickCheck>
20:19:22 <solrize_> wfm
20:19:23 <dobblego> SamB, yes I told him to get the extralibs and recompile GHC
20:19:34 <solrize_> oh right
20:19:38 <SamB> he doesn't actually need to *recompile* GHC
20:19:42 <solrize_> yeah
20:19:44 <dobblego> oh
20:19:49 <SamB> just re-run make
20:19:51 <solrize_> if you installed ghc from sources you have to get that other package
20:19:56 <ddarius> dobblego: QuickCheck is just a library
20:20:02 <dobblego> of course, cheers
20:20:13 <SamB> or, of course, he could use cabal-install
20:20:17 <SamB> if he had that installed
20:20:28 <dobblego> I'm nto familiar with that, but he does have it installed
20:20:33 <dobblego> cabal that is
20:20:43 <SamB> but of course the easiest way to install cabal-install is to use cabal-install -- except when the version you want isn't even on hackage
20:21:09 <SamB> (well actually I used it anyway today ;-)
20:21:10 <electron_x> hey can someone here give me some advice on a project i would like to do in haskell?
20:21:17 <dobblego> QuickCheck is a dependency of the stuff I wrote for him
20:21:54 <electron_x> i would like to write a commercial trading stock charting application in haskell and i would like to know if this is possible?
20:22:08 <dobblego> electron_x, yes, I'd like you to write something that I run in a directory of music files and reads the ID3 tag and the file name, then attempts to determine what the actual song is, then passes that information to another function that I write that is IO ()
20:22:14 <electron_x> is the laguage and api up to it?
20:22:40 <dobblego> basically, I want to sort my music out using a crontab
20:22:49 <dobblego> yes, it is
20:23:05 <bugQ> but are you up to it?
20:23:26 <electron_x> i am if if the language is up to it :)
20:23:42 <electron_x> i have been basically experimenting with erlang and haskell
20:23:45 <jsnx> electron_x: what you can't do in haskell, you can do in C
20:24:09 <bugQ> and that isn't a whole lot...
20:24:13 <jsnx> electron_x: the FFI makes it easy to C data structures coupled with Haskell for the pointer arithemtic, for example
20:24:19 <electron_x> the whole with doing it in haskell is to write better code and do it faster
20:24:20 <SamB> array literals, basically ;-P
20:24:39 <SamB> oh, and struct access
20:24:43 <jsnx> SamB: what about trie literals? or libs that have not been ported?
20:24:45 <SamB> Haskell can't do that either
20:24:57 <SamB> you don't have to write the libs
20:25:06 <electron_x> the app will have to do alot of gui and socket programming
20:25:16 <jsnx> electron_x: that is all done already
20:25:21 <electron_x> which is what i'm worried aboout
20:25:34 <jsnx> electron_x: well, no need to worry
20:25:38 <electron_x> :)
20:25:39 <dobblego> what about my music sorter!?
20:25:46 <scook0> on the GUI end, there's gtk2hs and wxHaskell
20:25:59 <electron_x> does haskell have support for distributed computing sort of like erlang?
20:26:18 <jsnx> electron_x: no
20:26:25 <electron_x> i really like that in erlang but the library support in erlang is terrible
20:26:40 <jsnx> electron_x: everything else in erlang is terrible, too
20:26:47 <electron_x> lol
20:26:49 <jsnx> electron_x: it's really too bad
20:26:58 <ddarius> dobblego: There is an ID3 reading library on Hackage (or somewhere)
20:27:19 <dobblego> ddarius, yeah, but I'm lazy :) thanks, I might write it myself some time
20:27:31 <electron_x> is there anyway to echieve distributed computing in haskell?
20:27:53 <electron_x> because i would like to implent neural nets and genetic programming
20:28:01 <bugQ> http://www.macs.hw.ac.uk/~dsg/gdh/
20:28:02 <lambdabot> Title: Glasgow Distributed Haskell
20:28:03 <sclv> sure, depending on your definition of distributed
20:28:11 <electron_x> multicore?
20:28:17 <sclv> multicore in haskell is great
20:28:17 <jsnx> electron_x: that's done already
20:28:18 <bugQ> first hit for "haskell distributed computing"
20:28:51 <SamB> hmm. my traceCcs# primitive isn't working right :-(
20:28:53 <electron_x> the site you gave me doesn't look very active :)
20:29:03 <SamB> the bugs keep dissapearing in it's presence!
20:29:10 <sclv> distributed as in multiple heterogenous boxes on a network is trickier -- the only difference between haskell and erlang i there is that haskell can't serialize closures.
20:29:35 <sclv> or at least not arbitrary ones.
20:29:56 <sclv> but for multicore processing, the current ghc is *more* than batteries included -- look up software transactional memory for one approach.
20:30:01 <ddarius> SamB: Author of buggy primitives
20:30:11 <mofmog> is there a built in function to detect arrow keys?
20:30:50 <bugQ> last updated June '07? not that bad.  how often does it need to be updated?
20:31:13 <electron_x> i feel like a pioneer going into uncharted territories
20:31:29 <scook0> mofmog: what are you trying to accomplish?
20:31:39 <electron_x> i don't think anyone has attempted to do a big project in haskell
20:31:40 <mofmog> making a game
20:31:42 <SamB> ddarius: well, they are!
20:31:45 <electron_x> no
20:31:52 <SamB> mysterious
20:31:54 <mofmog> so far i'm using aswd
20:31:55 <electron_x> an ai stock trading charting application
20:31:56 <clanehin_> Um.  When you're going in uncharted territories, there's no one to ask, "hey, is this possible?"
20:32:03 <SamB> I probably messed up something trivial or something
20:32:07 <jsnx> electron_x: my boss actually has an interest in this...if other people are into erlang style-concurrency in haskell, we basically need an ASN1 type class and some serialization functions and such
20:32:20 <SamB> honestly I'm surprised it's not segfaulting, the way it's acting
20:32:31 <jsnx> electron_x: erlang style concurrency, not AI stock trading
20:32:33 <scook0> mofmog: you might want to take a look at the SDL binding
20:32:39 <SamB> ddarius: at least it prints out lots of CCSes...
20:32:46 <bugQ> electron_x: no big projects? darcs doesn't look very small.
20:33:04 <mofmog> eh, it seems really difficult to get a text graphics game up and running
20:33:07 <dbpatter1on> sclv: is there an easy way to set headers with hvac?
20:33:24 <dbpatter1on> (something is caching my images, gah!)
20:33:37 <electron_x> bugQ: an ai stock trading / charting application is much bigger then darcs
20:33:44 <dbpatter1on> or is it just standard cgi?
20:33:47 <bugQ> electron_x: maybe not big if you try to compare it to C projects with 100,000+ LOC.
20:33:53 <scook0> mofmog: HsCurses might be more appropriate
20:33:59 <sclv> the Network.CGI primitives should all be available.
20:34:06 <sclv> Hmm... maybe I should document that more clearly.
20:34:08 <mofmog> scook0: i'm using ansi escape sequences -_-
20:34:08 <scook0> pretty sure that supports reading function keys (including arrows)
20:34:16 <mofmog> oh well, i'll stick to the alphanumerics
20:34:24 <scook0> eep
20:35:17 <electron_x> i'm wandering why has haskell never put on .net?
20:35:33 <bugQ> never wanted to, probably
20:35:41 <electron_x> it would instantly give you access to proven libraries
20:35:55 <bugQ> proven, proprietary libraries.
20:35:59 <mofmog> that only run on windows
20:36:00 <jeffz> some people consider .net either bloat or morally wrong.
20:36:00 <electron_x> lol
20:36:00 <bugQ> how does that work?
20:36:04 <shepheb> well, haskell needs a very specialized runtime system, too.
20:36:05 <mofmog> and very crippled on other systems
20:36:18 <mofmog> haskell just needs more libraries and docs
20:36:28 <jsnx> electron_x: they tried
20:36:28 <mofmog> or else it's going to suffer Scheme syndrome
20:36:29 <electron_x> mofmog: exactly
20:36:36 <dobblego> more libraries? pfft
20:36:47 <jsnx> Eelis: there's an impedance mismatch between the CLR data model and Haskell's
20:36:57 <mofmog> hahaha
20:37:07 <electron_x> what about java vm?
20:37:12 <dobblego> CAL
20:37:18 <jsnx> electron_x: that's not a good platform at all
20:37:20 <mofmog> go bears!
20:37:24 <electron_x> lol
20:37:30 <dobblego> @google CAL programming language
20:37:31 <jsnx> electron_x: you value libraries too highly
20:37:32 <lambdabot> http://en.wikipedia.org/wiki/CAL_programming_language
20:37:32 <lambdabot> Title: CAL (Joss family) - Wikipedia, the free encyclopedia
20:37:34 <SamB> if you need JVM, use scala
20:37:51 <mofmog> personally it's just the lack of docs that drives people away
20:37:59 <electron_x> jsnx: they are important for my project
20:38:12 <mofmog> also, how to use monads aren't any harder than wrapping your head around pointers anyways
20:38:14 <electron_x> imagine if i have to spend time writing libaries
20:38:14 <jsnx> electron_x: there's an alternative project, LLVM, that is more suitable for implementing diverse languages on a VM
20:38:24 <jsnx> electron_x: which libraries?
20:38:39 <electron_x> that would defeat the point of doing the project in haskell
20:38:52 <electron_x> jsnx; i'm not sure yet
20:38:55 <jsnx> electron_x: just remember that in Java, you are constantly rewriting monads and cons lists
20:39:11 <jsnx> electron_x: the point of doing the project in haskell is different for you than it is for me
20:39:22 <jeffz> electron_x: for someone who doesn't know anything about haskell yet, isn't it a bit presumptious to think that .net interop or jvm interop would even be useful?
20:39:23 <jsnx> electron_x: i'm looking for verifiable software
20:39:44 <jsnx> jeffz: well, if we consider his point of view...
20:39:48 <SamB> jeffz: well, he doesn't know how odd Haskell is
20:39:58 <jeffz> I don't think he can possibly have a point of view yet.
20:40:00 <SamB> most languages, such ideas would apply to
20:40:16 <jsnx> they even sort of apply to haskell
20:40:28 <bugQ> now watch him leave in 5 seconds...
20:40:34 <SamB> or would, if these libraries weren't so anti-functional
20:40:41 <bugQ> aw, shucks.
20:40:42 <jsnx> electron_x: i like you, you can stay
20:40:46 <electron_x> i have done programming in haskell, prolog and a bit in erlang and like what functional languages give me
20:40:47 <jsnx> SamB: aye
20:40:56 <electron_x> jsnx: :)
20:41:07 <SamB> C libraries are just low-level, not so bad...
20:41:30 <jsnx> SamB: yeah, haskell has brought back my appreciation for C
20:41:42 <electron_x> for me its like this i can spend 1 year writing the app in C++
20:41:59 <jsnx> SamB: C is really an elegant language as long as you stay away from functions and datastructures
20:42:02 <electron_x> or i can spend about 2 - 3 months writing it in Haskell
20:42:18 <jsnx> electron_x: i don't know what kind of specialized libs you need
20:42:19 <dobblego> electron_x, pure functional programming allows composability; as opposed to .NET/Java etc., where composition is difficult and often impossible. This results in high status applied to such things as libraries, since they must be rewritten each time - in Haskell, the libraries usually already exist, but where they don't, it's not such a big deal; you have composition
20:42:21 <bugQ> jsnx: hah, just macros, then?
20:42:29 <jsnx> bugQ: no, just pointers
20:42:32 <Cale> C would be a little nicer if its type language were cleaned up a bit.
20:42:38 <Cale> I don't like the syntax of C types.
20:42:38 <jsnx> bugQ: then link to some Haskell code...
20:43:10 <jsnx> Cale: it would also be cool if they would let you declare static arrays of arrays and pointers to other arrays and so forth
20:43:11 <Cale> It would be fun to do a language very much like C, but whose syntax was informed by Haskell :)
20:43:20 <jsnx> Cale: yeah :)
20:43:27 <electron_x> lol
20:43:34 <cjs> electron_x: "an ai stock trading charting application"?
20:43:42 <electron_x> yes
20:43:49 <jsnx> cjs: don't laugh, he means and XBox game
20:43:53 <electron_x> something like metastock
20:44:02 <electron_x> but more advanced
20:44:09 <jsnx> cjs: those XBox people come in here now and again, we don't want to blow their cover
20:44:34 <electron_x> because your implenting ai techniques like gp and nn
20:44:48 <bugQ> (off-topic) "Happy the Golden Prince" is a really uplifting song.
20:46:00 <Cale> http://video.google.ca/videoplay?docid=-4674461198051839963
20:46:01 <lambdabot> Title: Sidney Coleman: Quantum mechanics in your face
20:46:05 <electron_x> i just hope i'm not making a horrible mistake by finding out that its going to be way to slow etc etc
20:46:27 <Cale> (also offtopic, but quite interesting -- I've actually had a similar idea about how observation in QM works)
20:46:45 <jsnx> electron_x: if you hit a real bottle neck, doing that part in C will be easy
20:46:50 <cjs> electron_x: Well, if it's of any interest, I just happen to be building an automated options trading program in Haskell right now.
20:46:56 <bugQ> "Little Boxes" on the other hand, is quite depressing
20:47:02 <jsnx> electron_x: and the time you saved on all the other parts will pay for it
20:47:08 <electron_x> cjs: hehe
20:47:15 <dons> this is cute, http://reddit.com/r/programming/info/6etna/details
20:47:43 <cjs> I'd be curious as to what the term is, for it, since "automated trading" appears to still be driven by orders entered by human traders, whereas this program generates the orders itself from analysis of a market data feed.
20:47:46 <electron_x> jsnx: i have never interfaced c with haskell but i hope its as easyas you say it is
20:48:12 <cjs> Anyway, the lack of libraries is no big deal; it's a few days work to, e.g., get a GLTrade interface going.
20:48:17 <jsnx> electron_x: if you are on the channel and i'm around please feel free to get my help
20:48:20 <electron_x> can you call external dll functions in Haskell?
20:48:33 <jsnx> electron_x: you can do all that stuff, yeah
20:48:44 <jsnx> electron_x: though, i don't know how to on windows
20:48:50 <jsnx> electron_x: since i never use windows
20:49:03 <uebayasi> cjs, latency doesn't matter for that purpose?
20:49:12 <jsnx> electron_x: however, you use gcc one way or the other (WinGHC ships with GCC)
20:49:14 <electron_x> jsnx: thanks makes me feel better and there are also 424 users here so haskell has a moderate user base
20:50:33 <cjs> latency matters. We've not looked at speed issues yet, but I am strongly suspecting that Haskell's easy parallisim will be helpful.
20:51:16 <electron_x> jsnx: can you tell me how long the learning curve is for haskell (untill you can write clean a efficient code)?
20:51:24 <electron_x> and*
20:51:46 <jsnx> electron_x: 1 month if you do it all the time
20:51:55 <jsnx> electron_x: can be much longer if it is just a hobby
20:52:07 <jsnx> electron_x: it's really different
20:52:22 <jsnx> electron_x: coming from Ruby, i really had to have my head adjusted
20:52:29 <electron_x> assume the person has comp sci background
20:52:32 <cjs> It toook me about two weeks to start getting the hang of monads and suchlike.
20:52:40 <jsnx> electron_x: it's not the comp sci background
20:52:54 <jsnx> electron_x: it's the programming in other languages that makes it hard
20:53:10 <electron_x> changing the way you think?
20:53:16 <jsnx> electron_x: right
20:53:22 <jsnx> electron_x: exactly
20:53:42 <jsnx> electron_x: how do you build a trie without back-tracking, pointers or mutation?
20:53:48 <jsnx> it's interesting
20:53:51 <cjs> It's not really *that* bad. No worse than learning OO was for me back in the '90s.
20:54:52 <electron_x> ah OO
20:54:59 <electron_x> i really don't like it
20:55:23 <electron_x> i thinks is overused
20:55:31 <electron_x> maybe i'm wrong
20:55:44 <jsnx> electron_x: well, of course, we are all going to agree with you
20:55:53 <electron_x> lol
20:56:40 <jsnx> electron_x: you can build families of objects with but one function definition in haskell (assuming you are building function objects)
20:57:04 <jsnx> electron_x: it can be really short and clear
20:57:09 <jsnx> electron_x: it's eye opening
20:57:40 <electron_x> thats cool should i get a book on haskell or are the docs good enough?
20:57:48 <dobblego> @where yaht
20:57:48 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
20:57:51 <jsnx> electron_x: they are good
20:58:15 <jsnx> electron_x:  the "scheme in 48 hours" tutorial is one i really liked
20:58:28 <electron_x> very nice
20:58:31 <cjs> Yeah, that's a nice one.
20:58:35 <jeffz> electron_x: goto the haskell website, on the left hand side there is a section titled 'Learning', many links there.
20:58:36 <jsnx> electron_x: this channel is really helpful
20:58:37 <electron_x> thanks i have to go
20:58:42 <jsnx> electron_x: cheers
20:58:49 <electron_x> thanks for your help
20:59:14 * bugQ picks up the () that he left.
20:59:21 <cjs> I recommend buying Hutton's _Programming in Haskell_ and Hudak's _The Haskell School of Expression_, and reading them in that order.
20:59:45 <jsnx> cjs: i still need to do that :)
21:02:39 <ddarius> The people in here have really drank the Haskell Kool-Aid...
21:02:56 <jsnx> ddarius: please explain
21:03:03 <jsnx> ddarius: i guess i have
21:03:46 * bugQ chucks the () at ddarius.
21:03:48 <bugQ> don't be silly.
21:04:00 <jsnx> bugQ: let him speak
21:04:08 <bugQ> oh fine.
21:04:10 <pa-ching> Is there a pure equivalent for Data.HashTable?
21:04:20 <jsnx> he's been in here longer than any of us
21:04:30 <jsnx> pa-ching: Data.Map ?
21:04:37 <bugQ> Yeah, I just showed up yesterday...
21:04:40 <pa-ching> Oh haha.
21:04:44 <pa-ching> Right.
21:05:36 <jsnx> ddarius: do you think we were dishonest in leading poor electron_x into the whips and snares of true type safety?
21:05:56 <jsnx> ddarius: electron_x seemed like the sort of person who would get a lot out of it
21:06:19 <cjs> I'm two weeks ahead of him doing the same thing, and it's not killed me yet.
21:06:23 <Cale> jsnx: I think ddarius is just being silly :)
21:06:30 <jsnx> Cale: okay
21:06:40 <ddarius> Cale: Not exactly.
21:06:47 <cjs> Well, actually, he's going to need Haskell a lot more than I do, from the looks of it. Sounds as if his AI is rather more complex.
21:07:01 <jsnx> ddarius: well, then?
21:07:03 <ddarius> jsnx: I don't think anyone was being dishonest, inaccurate perhaps, but not dishonest.
21:07:25 <jsnx> ddarius: okay, what innacuracies do you see?
21:07:49 <jsnx> ddarius: i've only been using haskell for ~6 months, so it's quite possible i've made an error
21:08:09 <jsnx> ddarius: and in the long run, errors are not good for the reputation of the channel or the community
21:09:13 <Cale> I wasn't watching the conversation too closely
21:09:49 <Cale> 1 month seems a bit quick for the Haskell learning curve :)
21:09:58 <mrd> got any diet Kool aide
21:10:00 <Nafai> I agree :)
21:10:01 <Cale> But I suppose it depends how you measure :)
21:10:12 <Nafai> I've been trying off and off on for a year to learn Haskell
21:10:20 <jsnx> Cale: yes, i think you're right -- and i figured if it was his job, he'd learn very quick
21:10:20 <Nafai> And still don't feel very comfortable
21:10:30 <ddarius> Cale: I don't really have an issue with that.
21:10:41 <Cale> I don't think I felt like I could really accomplish anything for about 2 months, and it took about a year to become comfortable.
21:10:45 <jsnx> ddarius: hehe
21:11:03 <PenguinOfDoom> Type safety mechanisms fill me with searing rage. I suppose I'm a C programmer at heart.
21:11:18 <jsnx> ddarius: you keep saying "that's not it", "no, i really was serious" -- but you don't say what it was
21:11:27 <aFlag> I think you may be able to get stuff done in one month if you're not doing anything else but learning haskell
21:11:27 <Cale> ddarius: What is it that you have a problem with? I'm having a hard time guessing as I didn't really listen to the whole conversation, and I'm too lazy to read it all now.
21:11:34 <cjs> If you've poked at it a bit before, and have the general ideas, it's looking to me that a month full time will get you out of the tarpit in which you start.
21:11:35 <ddarius> Mostly I'd say it was the comments with negative portrayals of other languages.
21:11:36 <jsnx> PenguinOfDoom: well, uhm...what are you doing here?
21:11:42 <Cale> aFlag: that's probably true
21:11:43 <jsnx> ddarius: oic
21:11:54 <jsnx> ddarius: the things i said about erlang?
21:11:59 <mrd> being filled with rage, indubitably
21:12:05 <Cale> PenguinOfDoom: You prefer tracking down the corresponding runtime bugs?
21:12:06 <ddarius> There are things Haskell does better, there are things that OO and imperative languages do better.
21:12:13 <aFlag> if you have some programming background, of course
21:12:16 <jsnx> ddarius: oic, okay
21:12:20 <PenguinOfDoom> Cale: I even get *paid* for that.
21:12:28 <mrd> job security
21:12:29 <jsnx> ddarius: fair enough
21:12:45 <jsnx> PenguinOfDoom: think of how much it would be to get paid to add new features
21:12:46 <mrd> type safety causes unemployment, leading to recession
21:13:20 <PenguinOfDoom> jsnx: How much of what?
21:13:31 <Cale> PenguinOfDoom: I don't know about you, but I'd rather have the compiler just tell me where 90% of my bugs are, rather than having to use a debugger all the time :)
21:13:32 <mrd> why couldn't you have made me think of this oh say, 7 days ago
21:13:39 <PenguinOfDoom> Cale: But it's *fun*
21:13:40 <jsnx> s/how much/how much better/
21:13:56 <Cale> PenguinOfDoom: It's more fun when things actually work :)
21:14:17 <Cale> (of course, that's subjective, but...)
21:14:50 <PenguinOfDoom> But I like being a janitor :(
21:15:01 <sclv> what i'd be interested in is an attempt to bring haskell's fancier type features into an imperative language.
21:15:11 <sclv> or i suppose that's what scala is already..
21:15:18 <Cale> sclv: Or Haskell ;)
21:15:21 <Cale> sclv: hehe
21:15:24 <PenguinOfDoom> Clearly, if some people are willing to trade correctness for performance, there is a market for people who can add some of the correctness back.
21:15:30 <jsnx> sclv: that's the IO Monad
21:15:44 <jsnx> PenguinOfDoom: sure
21:15:50 <Cale> PenguinOfDoom: But static type systems don't cost performance, they add it.
21:16:05 <jsnx> PenguinOfDoom: the issue is that most people have been forced into a suboptimal performance/correctness ratio
21:16:15 <sclv> right -- i just mean that strong typing with lots of polymorphism and a purely functional approach play nice, and i happen to like both, but that it seems a shame those stuck in the imperative world can't at least drink half our kool-aid.
21:16:25 <jsnx> Cale: but none of these languages is as fast as C across the board
21:16:32 <jeffz> PenguinOfDoom: are you saying that performance is important in an incorrect program? that is lunacy.
21:16:42 <Cale> jsnx: That has nothing to do with C or Haskell's type system
21:16:45 <PenguinOfDoom> jsnx: That's a historical accident. A *lot* more people work on optimizing C compilers.
21:16:52 <jsnx> jeffz: it's TCP/IP actually (look up "type punning")
21:16:54 <PenguinOfDoom> jeffz: You say that because you are not a C programmer.
21:17:04 <dobblego> jeffz, sure, my main = return () is much faster than yours - never mind the fact that it is incorrect
21:17:05 <jeffz> PenguinOfDoom: formerly a C programmer.
21:17:10 <mrd> jsnx: Fortran compilers tend to be even better.  aliasing concerns play a part in that though.
21:17:25 <jsnx> mrd: well, they are better at numbers...
21:17:27 <PenguinOfDoom> jeffz: There are situations in which a large number of people would prefer slightly incorrect behavior, as long as it's slightly faster.
21:17:33 <mrd> C's unrestricted pointers and aliasing plays hell with optimizations
21:17:40 <sclv> I suppose one direction is scala or extending Ocaml's type system -- the other is the DDC.
21:18:10 <dobblego> PenguinOfDoom, they say it is incorrect, but they've really just shifted the bar and now it is correct - something a type system can potentially verify
21:18:12 <jeffz> PenguinOfDoom: yes, that is completely idiotic in my opinion, performance in a program which is incorrect is silly.
21:18:14 <sclv> i.e. you pretend IO effects have no type, or you develop an effects typing system.
21:18:32 <Cale> I can sort of see what PenguinOfDoom is getting at there
21:18:36 <jsnx> sclv: well, why is the haskell way so bad, honestly?
21:19:01 <Cale> Like, using a linear approximation in a physics simulation might not produce correct predictions, but might be more fun as a toy.
21:19:11 <sclv> its not, its awesome. i love it. i'd just like to see that language space explored.
21:19:13 <jsnx> PenguinOfDoom: i think it's not just a historical accident. C is just going to be a lot faster than Haskell, O'Caml and friends, if you treat it right
21:19:29 <Cale> But those aren't really the bugs we're talking about, I don't think...
21:19:33 <mrd> if you want faster approximations, use an approximation algorithm you understand, not some wacky machine dependent incorrect code
21:19:48 <Cale> Usually type errors just crash the program, or make it do something completely stupid.
21:19:56 <PenguinOfDoom> Cale: Ah, no, it's a victory of sufficiency over perfection.
21:20:00 <dons> system programs written in C make me sad
21:20:04 <dons> so many crashes
21:20:07 <mrd> Cale: or send the satellite careening past Mars
21:20:25 <sclv> jsnx: shootout-style experiments demonstrate that Haskell can be tuned to be just around 2 times as slow as tuned programs in C, which is pretty nice.
21:20:38 <dons> 2x on average, sclv :)
21:20:38 <PenguinOfDoom> Cale: Satellites falling from the sky is bad. Routers occasionally crashing? Who cares.
21:20:39 <jsnx> sclv: true
21:21:14 <sclv> a better compiler can probably reduce that to 1.5
21:21:14 <sclv> right -- threading is faster, other things might be slower.
21:21:18 <jsnx> sclv: that is vague and misleading
21:21:25 <sclv> how so?
21:21:38 <jsnx> sclv: using functional data structures is not something you can tune away
21:21:46 <dons> hmm, it looks more like 1.5x -- that's the number reported for raw speed.
21:21:52 <dons> how they calculate that 1.5x number i'm not sure
21:22:08 <jsnx> basically, you can't write "comparable programs" in many cases
21:22:09 <shepheb> isn't x always the time taken by the fastest solution?
21:22:10 <Cale> PenguinOfDoom: I care when I get disconnected and have to walk downstairs to reset the damn router. Also, if the type systems help bugs to get found more quickly, the development times decrease, and the price of the equipment can fall (or the company just makes more profit)
21:22:14 <PenguinOfDoom> jsnx: I don't see why C is inherently faster. Compiler writers get better as time goes on, but low level languages aren't getting more powerful.
21:22:16 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=gcc
21:22:18 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/2vdkpl
21:22:24 <dons> shows a lot of programs inside 1 - 1.5x range
21:22:44 <jsnx> PenguinOfDoom: it's because they let you do things that frustrate the type systems of languages like Haskell and O'Caml
21:22:49 <dons> 6 of 19 programs are closer than 1.5x
21:22:50 <aFlag> jeffz, it's very hard to find a correct program, don't you think? Most big programs have bugs (all the ones I know have them).
21:22:50 <mrd> it's just a matter of pouring more people power into compiler optimization development
21:22:58 <PenguinOfDoom> Cale: The company makes more profit by hiring cheap C programmers in India than by finding competent people.
21:23:27 <dons> oh, and faster than C on 4 programs
21:23:37 <PenguinOfDoom> jsnx: What things?
21:23:42 <dons> binary-trees still makes me smile
21:23:43 <Cale> PenguinOfDoom: That might be true, but perhaps Haskell programmers in India (in the future) would be somewhat more competent :)
21:23:47 <ddarius> GHC will almost certainly be getting significantly faster in the next release or two.
21:23:48 <jsnx> PenguinOfDoom: casts
21:23:58 <dons> yeah, the native codegen is the final bottleneck
21:24:05 <mrd> having a really in-depth understanding of the architecture helps too.  Intel's C compiler is much better than gcc, generally.
21:24:08 <sclv> jsnx: well, actually, it can be tuned away -- generally when you want a structure that's O(1) or O(log (n)) in some things, you can always get that in a functional structure too -- its just that it might be more than an equiv. imperative structure in others. but you generally don't need a structure that's fast at everything -- just a few specific things.
21:24:08 <Pseudonym> One important thing that shootout-like benchmarks don't measure, BTW, is maintainability.
21:24:09 <PenguinOfDoom> jsnx: Type casts don't make things faster.
21:24:09 <dons> 20 years of optimisations stacked up on top of a new native codegen == ghc ftw
21:24:18 <Pseudonym> I'd love to see a large-scale study that took maintainability into account.
21:24:21 <sclv> And when you really need mutable memory, you can always drop into IO or ST
21:24:28 <jsnx> PenguinOfDoom: if they don't cost anything, yeah, they do
21:24:44 <Cale> I'd also like to see some of the shootout programs replaced with more naive ones (which eventually, perform in the same way :)
21:24:55 <ddarius> Pseudonym: You and many many others, but anything even approaching that is rare.
21:24:55 <PenguinOfDoom> Cale: Programmers in India have no reason to learn Haskell. If they are so smart, they can hire their dumber fellows and become Important Vice Presidents.
21:25:02 <Pseudonym> BTW... the reason why C is inherently faster is the same reason why assembler is inherently faster.
21:25:15 <jeffz> aFlag: yeah, my beef is with people who are complacent about incorrect programs.  agreeably it's hard to find correct programs the larger they are.  greater diligence is required for things to be correct in C, which is often rare.
21:25:23 <Pseudonym> Assembler programmers get to use the C compiler to write _most_ of the code, then they code the inner loops in assembler.
21:25:24 <jsnx> PenguinOfDoom: do you really believe Haskell could be as fast as C, across the board?
21:25:32 <Cale> jsnx: I do.
21:25:36 <PenguinOfDoom> jsnx: Give me a horde of really, really smart people, and I'll find out.
21:25:37 <Pseudonym> C programmers, on the other hand, don't get to use assembler.
21:25:41 <PenguinOfDoom> (8ball says "probably")
21:25:42 <gwern> (gcc has some ideological hobbles as well, I've heard. something about RMS being afraid the front-ends could be stolen and loosely incorporated into nonfree stuff if they were more independently structured)
21:25:42 <Pseudonym> So assembler has the advantage.
21:25:49 <Cale> jsnx: Wait a couple years, when processors have 80 cores.
21:25:58 <jsnx> why do you guys believe that?
21:26:06 <Cale> jsnx: and Haskell has a really nice data parallelism system :)
21:26:09 <Pseudonym> Similarly, C programmers have an advantage over Haskell programmers, because theyc an use FFI.
21:26:11 <mrd> gwern: er? gccxml, no?
21:26:25 <gwern> so I asked this before, but does anyone know where Conrad Parker of hOgg has been later?
21:26:55 <jsnx> Cale: so, we'll use the IO Monad to do all the nasty pointer stuff that right now we'd do in C
21:27:06 <jsnx> Cale: and it will be just as fast
21:27:08 <ddarius> Pseudonym: Something that just has inner loops written in assembly but is otherwise C is usually still considered a C program, not an assembly program.
21:27:11 <gwern> mrd: I don't know first hand whether it's true, but given the whole egcc thing I wouldn't be surprised
21:27:13 <jsnx> maybe, that could happen
21:27:15 <Cale> jsnx: No, we won't even have to.
21:27:24 <jsnx> Cale: well, why not?
21:27:33 <Pseudonym> ddarius: Understood, however, I'm making the point that low-level programmers have the edge, assuming they can _also_ use high-level languages.
21:27:41 <Cale> jsnx: Because, well, just try to write a highly parallel program in C.
21:27:53 <jsnx> Cale: that is missing the point
21:27:55 <PenguinOfDoom> Cale: Just spawn some threads.
21:27:55 <Cale> jsnx: Suppose it has to take advantage of 80 cores.
21:28:04 <ddarius> Pseudonym: Yes, in theory they could always tweak the output of a higher level language, but that's not what happens.
21:28:05 <PenguinOfDoom> Cale: It's okay if they deadlock occasionally, because it's a C program.
21:28:09 <jsnx> Cale: I said "across the board" not "in haskell's sweet spot"
21:28:21 <Pseudonym> I wouldn't like to tweak the C output of GHC.
21:28:28 <Cale> jsnx: Lots of programs can take advantage of at least some parallelism.
21:28:42 <jsnx> Cale: sure
21:28:54 <PenguinOfDoom> jsnx: Hey guess what! The computer I can buy today is only like two times faster than the computer I could buy two years ago.
21:28:56 <Pseudonym> Anything with a sort in it could use parallelism in theory.
21:29:04 <PenguinOfDoom> jsnx: It just has more cores.
21:29:04 <jsnx> PenguinOfDoom: yes/
21:29:15 <jsnx> PenguinOfDoom: i don't get it, though
21:29:23 <Cale> PenguinOfDoom: You can make threads, but multithreaded programming is living hell.
21:29:29 <jsnx> PenguinOfDoom: oh, you mean, the programs can't go faster...
21:29:31 <Cale> PenguinOfDoom: *especially* in C
21:29:38 <dons> "After all, we're not about to use OCaml or Haskell for anything at Amazon; they're not popular enough, so we'd have a heck of a time hiring people, finding documentation, integrating with other languages and 3rd-party systems, etc." sigh
21:29:45 <scook0> @src Monoid
21:29:45 <lambdabot> class Monoid a where
21:29:46 <lambdabot>     mempty  :: a
21:29:46 <lambdabot>     mappend :: a -> a -> a
21:29:46 <lambdabot>     mconcat :: [a] -> a
21:29:47 * mrd notes that Cilk and OpenMP could get some basic parallelism going without too much trouble in C
21:29:55 <PenguinOfDoom> jsnx: If you want Doom 5 to run acceptably on the computers born in the same year, it'll have to take advantage of parallelism
21:29:58 <dobblego> dons, where is that from?
21:29:58 <jsnx> dons: that is Yegge?
21:29:59 <PenguinOfDoom> jsnx: No other way!
21:30:03 <dons> jsnx: yeah
21:30:05 <mrd> not nested, or anything more interesting than fork-join parallelism
21:30:08 <Cale> All this being said, I actually hope that Haskell doesn't get too popular quickly :)
21:30:10 <Pseudonym> I guess the point I was trying to make (badly) is that high-level vs low-level programming is not an either-or proposition.  Even GHC has bits of it written in C (i.e. the Rts).
21:30:13 <PenguinOfDoom> Cale: A lot of people either don't know any better or are convinced otherwise.
21:30:14 <dobblego> does anyone listen his shit?
21:30:20 <jsnx> dons: his problem is, he believes in dynamic typing
21:30:22 <dons> i know there's a bunch of guys in the amazon back rooms who know haskell .. and erlang and ocaml .. already
21:30:49 <dons> and we turn away far too many haskell programmers at galois. there's usually too many docs, and too many people
21:30:53 <dons> sigh
21:30:54 <Cale> PenguinOfDoom: I think anyone who has tried to write highly parallel programs in an imperative language will tell you that it's hard.
21:31:11 <jsnx> dons: really?
21:31:21 <ddarius> Cale: Depends.
21:31:27 <jsnx> dons: so the market is saturated already?
21:31:30 <dons> even if haskell's fully wikified, and has complete comprehensive cross linked docs on hackage, stereotypes still take time
21:31:35 <sclv> too many docs?
21:31:49 <Nafai> dons: The problem is getting a job at a place means you are very very good at Haskell
21:32:00 <Nafai> dons: Any Java weenie can get a job anywhere, practically
21:32:01 <dons> jsnx: the dozen or so places can't take the 500 people in this room :)
21:32:14 <Pseudonym> Nafai: So long as they're not picky.
21:32:20 <Cale> dons: Shouldn't you be trying to keep Haskell unpopular now that you're working at a company where it's part of your strategic advantage?
21:32:23 <ddarius> Hey!  I haven't applied for any Haskell jobs (yet)
21:32:31 <PenguinOfDoom> Nafai: Java weenies are rather cheap.
21:32:36 <Cale> :)
21:32:37 <Pseudonym> Cale: Actually, he should be encouraging _bad_ Haskell programmers.
21:32:39 <Nafai> PenguinOfDoom: Some, yes :)
21:32:40 <aFlag> Cale, but will people tell me that writing highly parallel programs in Haskell is easy?
21:32:43 <Pseudonym> Then dons can get paid to fix their code.
21:32:45 <scook0> @hoogle Max
21:32:45 <dons> Cale, it helps if other people also push on the code, write new libs, train devs, etc :)
21:32:45 <lambdabot> Prelude.max :: Ord a => a -> a -> a
21:32:46 <lambdabot> Data.Ord.max :: Ord a => a -> a -> a
21:32:46 <lambdabot> Prelude.maxBound :: Bounded a => a
21:32:49 * shapr pays dons
21:32:50 <gwern> heh heh. should we form #haskell Inc.? we could make history as the first IRC channel gone pro
21:32:54 <Cale> aFlag: It's not easy, but it's certainly less hard.
21:33:10 <Nafai> I wish I had the time to get the experience necessary to get a Haskell job
21:33:12 <aFlag> Cale, do you have examples? Maybe an article or something?
21:33:12 <PenguinOfDoom> gwern: What would we sell?
21:33:18 <mrd> gwern: #haskell Inc, a leading producer of hot air
21:33:24 <Pseudonym> I wish I had the capital needed to start a Haskell shop.
21:33:26 <jsnx> gwern: we'd have to cut SPJ, SM, & al., in
21:33:39 <Pseudonym> Actually, it'd be a something-else shop that just happened to hire Haskell programmers./
21:33:44 <dons> and congratulations to Well Typed, our newest haskell company!
21:33:46 <sclv> aFlag: the article linked from Control.Parallel.Strategies is a great place to start.
21:33:47 <gwern> PenguinOfDoom: we'll sell moand tutorials
21:33:57 <gwern> jsnx: we'll affiliate with MS
21:34:00 <sclv> as homework!
21:34:06 <scook0> hmm, is there no built-in Max monoid?
21:34:07 <Cale> aFlag: I think dons wrote a simple example a while back, of using par to parallelise something trivial like the naive implementation of the Fibonacci function.
21:34:09 * jsnx tazes gwern 
21:34:10 <scook0> lame
21:34:21 <dons> yeah, `par` is pretty easy to play with.
21:34:28 <ddarius> @hoogle Max
21:34:28 <lambdabot> Prelude.max :: Ord a => a -> a -> a
21:34:28 <lambdabot> Data.Ord.max :: Ord a => a -> a -> a
21:34:28 <lambdabot> Prelude.maxBound :: Bounded a => a
21:34:34 <Cale> aFlag: You can also have a look at the new nested data parallelism stuff which is going in to the next few versions of GHC.
21:34:36 <dons> you'll want a few cores to make it interesting
21:34:37 <gwern> jsnx: don't tase me bro!
21:34:41 <dons> 4 is good
21:34:42 <ddarius> scook0: There should be, or you should be able to use Dual or whatever to get it.
21:34:49 <sclv> scook0: I could have sworn there was.
21:34:58 <Cale> aFlag: Which is really where we want to be, though it's not 100% ready for use yet.
21:35:08 <Pseudonym> Well Typed doesn't sound like a very dynamic company.
21:35:09 <aFlag> sclv, this one? http://www.macs.hw.ac.uk/~dsg/gph/papers/html/Strategies/strategies.html
21:35:11 <lambdabot> Title: Algorithm + Strategy = Parallelism, http://tinyurl.com/2hysym
21:35:16 <scook0> actually, you'd still need to specify mzero
21:35:31 <scook0> mempty*
21:35:38 <scook0> so maybe that's why it doesn't exist
21:35:45 <sclv> huh, no min and no max. zowie.
21:35:54 <ddarius> mempty is minBound
21:36:00 <Cale> aFlag: Basically, with NDP, you just have to use a special datatype called the parallel array, and any operations on parallel arrays are automatically flattened out and load balanced across available cores.
21:36:01 <sclv> aFlag: yeah. that's an awesome paper.
21:36:20 <Cale> (that's different from the Strategies mechanism, which is a bit more manual)
21:36:25 <sclv> NDP is a bit still "in process" tho compared to the strategies stuff...
21:36:27 <dobblego> ?src Arbitrary Maybe
21:36:27 <lambdabot> Source not found. You untyped fool!
21:36:48 <dobblego> call dcoutts_ an untyped fool and you'll be yourself, an untyped fool!
21:36:56 <jsnx> Cale: how does NDP handle failure?
21:37:02 <Cale> jsnx: failure?
21:37:08 <mrd> NDP isn't complete so the code looks pretty "manual" too atm.  mapUP, foldUP etc
21:37:12 <jsnx> Cale: like, i shut off one of the computers
21:37:14 <Cale> jsnx: These are pure computations, they always succeed.
21:37:22 <Cale> jsnx: This is SMP only.
21:37:28 <mrd> however it's based on NESL which is 10 years old
21:37:29 <jsnx> Cale: oh, got it
21:38:04 <dobblego> can you write an Arbitrary for Maybe so that Nothing only comes up once?
21:39:04 <aFlag> Cale, hm, so if you use that parallel array and write an add function for adding them together each addition would be done in parallel without you having to do anything special besides using the datatypes?
21:39:14 <Cale> aFlag: right.
21:39:41 <Cale> aFlag: Well, for collapsing operations, I think there are some special combinators that you use.
21:39:52 <Cale> aFlag: But say, for adding two parallel arrays elementwise.
21:40:08 <Cale> That's 100% automatic.
21:40:17 <aFlag> interesting
21:40:33 <mrd> the ultimate goal is to have syntax in haskell like list comprehensions which gets translated into the appropriate combinators
21:40:44 <aFlag> hm
21:41:39 <Cale> dobblego: Well, I don't think so. You can make it very rare.
21:41:49 <sclv> dobblego: the instance provided is:
21:41:49 <dobblego> Cale, yeah I'll just do that, thanks
21:41:51 <sclv> instance (Arbitrary a) => Arbitrary (Maybe a) where
21:41:51 <sclv>   arbitrary            = sized arbMaybe
21:41:51 <sclv>    where
21:41:52 <sclv>     arbMaybe 0 = return Nothing
21:41:52 <sclv>     arbMaybe n = fmap Just (resize (n-1) arbitrary)
21:41:59 <mrd> the basic research is done, and pretty well established.  NDP is implanting it into a real general purpose programming language, though, which is interesting.
21:42:05 <dobblego> sclv, ah great, cheers
21:42:09 <sclv> which looks to be about right.
21:42:29 <Cale> mm... that's interesting
21:42:56 <sclv> as i recall, quickcheck always makes sure to provide a 0 early on, and gradually expands the range it gives...
21:43:01 <Cale> I didn't know about 'sized'
21:43:12 <aFlag> if that work goes well Haskell definetly would outperform most C programs when eventually you have 10+ cores in the same computer
21:43:14 <mrd> sized just lets you get ahold of the current "size"
21:43:36 <Cale> aFlag: This is my thinking as well.
21:44:13 <Cale> mrd: actually, I think this may be new -- this is the quickcheck which tries small parameters first?
21:44:42 <mrd> new? well, there was a "sized" in quickcheck always
21:44:47 <sclv> i thought all the new work was on quickcheck'? (where IS that anyway...)
21:45:21 <ddarius> There's still some relatively low hanging fruit for Haskell implementations on the purely sequential side.
21:45:21 <shapr> @seen sethk
21:45:22 <lambdabot> I saw sethk leaving #haskell-blah and #haskell 2d 7h 25m 33s ago, and .
21:45:26 <shapr> hmm
21:45:38 <shapr> sclv: QC2 is out, sort of.
21:46:20 <sclv> if its not on hackage, its not out.
21:46:37 <shapr> Talk to gwern ;-)
21:46:41 <mrd> cache coherancy and other memory issues are a problem for multicore programming.  in the Cilk and OpenMP programs I wrote, any speedups from distributing simple parallelism across multiple cores was washed out by the overhead compared to a straight up sequential tightly optimized loop
21:46:51 <sclv> ?seen gwern
21:46:51 <lambdabot> gwern is in #xmonad and #haskell. I last heard gwern speak 12m 14s ago.
21:47:20 <sclv> ?tell gwern -- hey! you might want to look into packaging the current state of the quickcheck2 repo up for hackage?
21:47:20 <lambdabot> Consider it noted.
21:47:41 <sclv> shapr: done.;
21:47:48 <shapr> yay!
21:47:58 <Nafai> Hi shapr!
21:48:04 <shapr> hiya Nafai!
21:48:21 <Nafai> How are you?
21:48:29 <shapr> I'm doing well, how are you?
21:48:37 <Nafai> Okay, tired a bit
21:48:41 <Nafai> Wishing I could focus more
21:49:43 <Cale> mrd: They are worrying about low level details like that in the implementation :)
21:50:19 <sclv> haha another haskell overload moment: I just read the word "MARRY" and thought, hmm, what does an MArray have to do with that?
21:56:35 <kaooos> ..
21:56:46 <Cale> hello
21:58:44 <kaooos> hola
22:00:07 <kaooos> duda      *** Term           : [y : ys]
22:00:18 <kaooos> *** Type           : [[a]]
22:00:26 <kaooos> *** Does not match : Valores
22:00:46 <araujo> kaooos, tenemos #haskell.es !
22:00:50 <araujo> :-]
22:00:52 <sclv> ooh have ppl seen this: http://wwwtcs.inf.tu-dresden.de/%7Evoigt/mpc08.pdf
22:02:00 <sclv> "Asymptotic Improvement of Computations over Free Monads"
22:02:10 <solrize_> looks neat
22:04:21 <sclv> http://wwwtcs.inf.tu-dresden.de/%7Evoigt/Improve.lhs is the code
22:04:57 <kaoss> .
22:05:47 <Cale> sclv: Looks neat :)
22:05:59 <Cale> Heh, I have the exact same comment as solrize_  :)
22:06:19 <Cale> Btw, did everyone catch the fact that there is a new Catsters video?
22:06:32 <solrize_> who?
22:06:44 <Cale> http://uk.youtube.com/watch?v=Rjdo-RWQVIY
22:06:45 <lambdabot> Title: YouTube - Eckmann-Hilton 1
22:06:54 <solrize_> no idea who that is
22:06:54 <Cale> http://uk.youtube.com/user/TheCatsters
22:06:55 <lambdabot> Title: YouTube - TheCatsters's Channel
22:07:09 <Cale> They do video lectures on category theory :)
22:07:29 <solrize_> cool :)
22:07:42 <solrize_> i cn haz adjoint functors?
22:07:58 <Cale> It's mostly Eugenia Cheng, and some with Simon Willerton
22:08:41 <Cale> http://cale.yi.org/autoshare/coequaliser.jpg
22:08:56 <solrize_> hehe
22:09:04 <ddarius> Holy crap, that paper is exactly what we were talking about not too long ago (several months ago)
22:09:13 <sclv> in theory you should be able to import that file and run improve over yr. monadic code and magically get a more efficient one.
22:09:26 <sclv> serious magic
22:09:32 * ddarius <3 Eugenia Cheng.
22:09:54 <Cale> She's so dreamy, hehe
22:09:56 <OceanSpray> fullTree (n + 1) = ...
22:10:26 <Cale> Hehe, nice, n+k patterns
22:10:27 <OceanSpray> that's not valid Haskell, is it?
22:10:29 <dons> whoa, new catsters video. yay
22:10:31 <Cale> Sure it is.
22:10:32 <sclv> i don't think that any of the monads i generally use are victim to quadratic behavior to begin with, but nice to know it can me magiced away.
22:10:33 <OceanSpray> oh?
22:10:50 <ddarius> sclv: Yes, this is recorded (with no reference to this paper as it was "rediscovered") on http://www.haskell.org/haskellwiki/Performance/Monads
22:10:52 <lambdabot> Title: Performance/Monads - HaskellWiki
22:10:55 <dons> do we have a catalog of the catsters videos on the wiki?
22:10:55 <Cale> OceanSpray: n+k patterns are just deprecated, but they're still supported in Haskell 98
22:11:04 <dons> not for long though :)
22:11:16 <dons> haskell' (now with less n+k)
22:11:27 <OceanSpray> why would they take something like this out?
22:11:34 <OceanSpray> seems useful at times.
22:11:39 <Cale> What? You mean they're not going to generalise to c*n+k patterns?
22:11:41 <dons> it makes no sense, and no one uses it
22:11:50 <dobblego> what does unital mean?
22:11:51 <sclv> that would have been great for april fools.
22:11:55 <Cale> dobblego: Has a unit
22:11:57 <dons> sclv: :)
22:12:01 <dobblego> ok thought so, cheers
22:12:04 <dons> sclv: gofer has n*m+k patterns
22:12:07 <Cale> dobblego: So there is some 1 such that 1*a = a*1 = a
22:12:16 <Cale> (for any a)
22:12:46 <Cale> I think we should have cos(x) patterns ;)
22:13:38 <sclv> Haskell' spec  -- including unsafePerformNullPtr and eliminating the (.) operator and, erm, etc.
22:14:05 <ddarius> OceanSpray: There are issues with n+k patterns
22:14:10 <OceanSpray> eliminate the (.) operator?
22:14:11 <OceanSpray> wtf?
22:14:23 <Cale> I wonder just how much of a pain it would be to switch the module path separator to |
22:14:25 <OceanSpray> ddarius, such as?
22:14:55 <sclv> it was an actual haskell' ticket -- precisely so it could be used for records, modules, etc.
22:15:16 <Cale> Of course, it's *so* rejected.
22:15:27 <roconnor> I could live with `o`
22:15:30 <ddarius> OceanSpray: Mostly broken expectations and potentially horribly ambiguous code.  It's also just a very special case for very little benefit.
22:15:30 <Cale> If it were accepted, I think the community would just totally reject Haskell'
22:15:31 <dons> there's been a bit of discussion about (.) last week, actually
22:15:33 <dons> some unicode fans.
22:15:49 <dobblego> is Haskell' a real thing?
22:15:51 <dons> or mandating space around (.)
22:15:56 <dons> dobblego: hell yeah.
22:16:01 <ddarius> roconnor: Doesn't ML use o as an operator.
22:16:07 <dobblego> yay! does it fix a lot of the warts? when can we see something?
22:16:08 <Cale> dobblego: Yes, it's an effort to standardise current practice for the most part.
22:16:11 <sclv> mandating space wouldn't be too painful.
22:16:12 <roconnor> I don't know
22:16:22 <Cale> No, it doesn't look like it's going to fix a whole lot.
22:16:25 <sclv> I wouldn't mind mandating space around a number of things...
22:16:35 <dobblego> is the type of (.) generalised to Functor? :)
22:16:40 <Cale> If we want a progressive new language, we'll have to do it ourselves.
22:16:42 <dobblego> oh ok
22:16:42 <OceanSpray> I like Cale's | for . idea.
22:16:44 <roconnor> of course removing (.) is hardly standardising current practice
22:16:44 <sclv> after a comma, for instance.
22:17:01 <roconnor> neither is using | as a module separator
22:17:02 <ddarius> sclv: That would annoy me.
22:17:05 <Cale> dobblego: But it will add support for things like multiparameter typeclasses
22:17:24 <Cale> dobblego: Things which everyone uses but which are not in the Haskell 98 standard.
22:17:30 <dobblego> right
22:17:38 <sclv> sometimes i write code without nice spaces, and kick myself later, so i wouldn't mind some enforecement there...
22:17:39 <ddarius> Aren't fundeps what Haskell' primarily stalled on?
22:17:56 <dobblego> @google haskell prime
22:17:57 <ddarius> sclv: Most of the time I have spaces, but sometimes I don't.
22:17:58 <lambdabot> http://hackage.haskell.org/trac/haskell-prime
22:17:58 <lambdabot> Title: Haskell Prime - Trac
22:18:04 <dons> the plan is to side step that for now
22:18:08 <ddarius> dons: How?
22:18:13 <dons> do the other 95%, then come back later
22:18:22 <dons> H'-alpha
22:18:33 <Cale> Heh, watch the description of MPTC's take 50% of the space in the report :)
22:18:46 <ddarius> MPTCs aren't bad.
22:18:50 <ddarius> It's just the fundeps.
22:18:56 <Cale> It's functional dependencies, yeah
22:18:56 <dons> we can remove the funn \SOH characters et al and save 2 pages :)
22:19:06 <Cale> nooooo...
22:19:07 <Cale> hehe
22:19:24 <dons> wipe out string gaps
22:19:37 <Cale> Actually, I rather like string gaps
22:19:41 <dons> actually, i like those too
22:19:47 <solrize_> ?
22:19:48 <ddarius> No monomorphism restriction saves like 0.5-1 page.
22:19:57 <Cale> I also actually sort of like the fact that Haskell was thoughtful enough to include those funny control characters.
22:20:25 <Cale> I remember when I was first learning the language, I saw that and wondered why it wasn't standard in all the other languages I'd used.
22:20:29 <dons> Cale, yeah, true hysterical reasons. just before the unicode java-led standardisation
22:20:40 <dons> now we just live with \xff et al
22:21:04 <dons> what about zero-width characters
22:21:07 <dons> \&
22:21:09 <ddarius> \&
22:21:13 <dons> hands up if you remember those
22:21:21 * ddarius raises his hand.
22:21:27 <dons> :)
22:22:57 <jsnx> dons: what are they?
22:23:27 <Twey> What's \&?  Equivalent to ~&?
22:23:35 <ddarius> > "\&"
22:23:38 <lambdabot>  ""
22:23:40 <sclv> they're not getting rid of the monomorphism restriction, tho, are they?
22:23:44 <Twey> Er
22:23:48 <Twey> There's nothing there?
22:23:54 <jsnx> ddarius: oh, interesting
22:24:05 <ddarius> Twey: dons didn't say "zero-width characters" for no reason
22:24:09 <roconnor> > (\& -> (&) 5 6) (+)
22:24:09 <lambdabot>  Parse error at "->" (column 5)
22:24:12 <dons> so you can append \SOH or friends with some other control char (something like that)
22:24:25 <Twey> Hm, I see
22:24:29 <bd_> > (\(&) -> (&) 5 6 ) (+)
22:24:30 <lambdabot>  11
22:24:34 <hpaste>  kaoos pasted "(no title)" at http://hpaste.org/6880
22:24:39 <ddarius> > "\xbbad"
22:24:40 <lambdabot>  "\48045"
22:24:42 <ddarius> > "\xb\&bad"
22:24:43 <lambdabot>  "\vbad"
22:24:50 * Twey nods.
22:24:57 <Twey> That's kind of useful.
22:25:12 <dons> anyone ever used it? :)
22:25:14 <newsham> damn you cale.  that magic pen game is way more addictive than games should be
22:25:24 <Cale> The escape character \& is provided as a "null character" to allow strings such as "\137\&9" and "\SO\&H" to be constructed (both of length two). Thus "\&" is equivalent to "" and the character '\&' is disallowed.
22:25:35 <roconnor> I wonder if GHC optimizes when I split lines with ++
22:25:45 <dons> roconnor: often , yes.
22:25:54 <ddarius> newsham: Not a game, but you may also like Phun if you haven't heard of it.
22:26:06 <Cale> Heh, that's funny \SO and \SOH are both escape sequences :)
22:26:33 <newsham> i dont know if i can handle anything else that addictive
22:26:37 <newsham> i have to work tomorow
22:26:57 <Cale> newsham: maybe cool down with "You Have To Burn The Rope": http://www.mazapan.se/games/BurnTheRope.php
22:26:58 <lambdabot> Title: Mazapán.se - You Have To Burn The Rope
22:27:04 <Twey> Haha
22:27:12 <Cale> (I promise it won't take long :)
22:27:16 <newsham> you are a bad man
22:27:36 <Trinithis> Cale: got a link for haskell string escapes?
22:27:39 <bd_> roconnor: foo = "abc"++"def" (with NOINLINE) optimizes to this at -O2: Test.foo = \u [] GHC.Base.unpackCString# "abcdef";
22:27:44 <Cale> In fact, if it takes you more than 3 minutes, there's something verifiably wrong with you ;)
22:27:47 <ddarius> Cale: That one doesn't work for me.
22:28:00 <roconnor> > sequence (replicate 2) [1..5]
22:28:01 <lambdabot>  Couldn't match expected type `[m a]'
22:28:02 <Cale> ddarius: Do you have the latest Flash installed?
22:28:12 <roconnor> > sequence (replicate 2 [1..5])
22:28:13 <lambdabot>  [[1,1],[1,2],[1,3],[1,4],[1,5],[2,1],[2,2],[2,3],[2,4],[2,5],[3,1],[3,2],[3,...
22:28:18 <dons> bd_: i think even an unlines in there might work
22:28:26 <ddarius> Cale: No, but I didn't really care enough to upgrade.
22:28:29 <roconnor> hmm, not right
22:28:33 <hpaste>  kaoos pasted "1" at http://hpaste.org/6881
22:28:39 <Cale> Heh, there's a video walkthrough :)
22:28:42 <bd_> dons: nope
22:28:46 <ddarius> If anything, I more and more lean toward removing the flash plugin altogether.
22:28:55 <dons> ah well
22:29:02 <Cale> http://uk.youtube.com/watch?v=hSmuaDvnCWI
22:29:02 <lambdabot> Title: YouTube - You Have To Burn The Rope Walkthrough
22:29:10 <Cale> http://uk.youtube.com/watch?v=VmuiwOGi5gA
22:29:10 <lambdabot> Title: YouTube - You have to burn the rope - credits
22:29:33 <Cale> (the credits are actually longer than the walkthrough :)
22:30:07 <Cale> Trinithis: the Report
22:30:18 <Cale> http://haskell.org/onlinereport/lexemes.html
22:30:20 <lambdabot> Title: Haskell 98 Lexical Structure
22:30:26 <Cale> section 2.6
22:31:17 <Cale> The things people are doing in Flash these days are pretty cool, though I wish we could get a sensible open alternative.
22:31:17 <Trinithis> cool. that game froze my firefox :(
22:31:25 <Cale> Trinithis: which game?
22:31:34 <Trinithis> http://www.mazapan.se/games/BurnTheRope.php
22:31:35 <lambdabot> Title: Mazapán.se - You Have To Burn The Rope
22:31:35 <newsham> they open sourced it recently
22:31:36 * sclv wants heredoc-style syntax for haskell.
22:31:52 <Cale> newsham: Oh? Cool!
22:32:04 <Trinithis> my computer I believe is dying. I constantly hear it thrashing
22:32:32 <solrize_> cale: gnash?
22:32:59 <awesame> how can "1 `div` 0" throw an exception when its type is "(Integral a) => a -> a -> a"
22:33:08 <awesame> should it need to know about the IO monad to do that?
22:33:44 <sclv> haskell has imprecise exceptions that can be thrown from pure code.
22:33:44 <roconnor> awesame: all code is force at least indirectly by main which is in IO.
22:33:51 <ddarius> sclv: GHC does.
22:33:53 <newsham> http://www.mozilla.org/projects/tamarin/
22:33:53 <roconnor> forced
22:33:54 <lambdabot> Title: Tamarin Project
22:34:15 <awesame> hm
22:34:24 <awesame> I think I still don't understand something about monads
22:34:45 <ddarius> Dividing by zero has nothing to do with monads.
22:34:46 <newsham> you're not supposed to understand everything at first
22:34:56 <awesame> I mean, okay, maybe my "1 `div` 0" is actually a "return (1 `div` 0)"
22:35:28 <awesame> but how does this function that doesn't deal directly with the IO monad throw an exception?
22:35:52 <jsnx> awesame: ultimately, yeah -- or `return (stuff wrapping (1 `div` 0))`
22:36:16 <ddarius> awesame: Uncatchable exceptions are no different, semantically, from undefined (or bottom or _|_).  Haskell 98 supports uncatcheable "exceptions".
22:36:34 <jsnx> awesame: there are different kinds of exceptions
22:36:52 <awesame> oh!
22:36:53 <jsnx> awesame: there's an 'expected error state' kind -- we use Maybe and Either for that
22:37:11 <jsnx> awesame: then there is 'the machine threw up when i tried to do this' kind
22:37:20 <jsnx> that's all, right?
22:37:25 <jsnx> i'm not missing any?
22:37:43 <Cale> awesame: return (1 `div` 0) and (1 `div` 0) wouldn't have the same type, so they can't be the same thing :)
22:37:45 <ddarius> jsnx: You are.
22:37:53 <jsnx> ddarius: okay
22:37:58 <jsnx> ddarius: what am i missing?
22:38:26 <ddarius> jsnx: IOExecptions, asynchronous exceptions, Control.Exception exceptions.
22:38:30 <Cale> Every type includes one value called bottom for representing computations which don't terminate, and that includes things like throwing uncatchable exceptions, like div does.
22:38:51 <jsnx> ddarius: okay, i'll go read about those
22:38:51 <awesame> Cale: right, I meant maybe its value is ultimately ending up in the IO monad
22:39:15 <Cale> awesame: yeah, it's not, don't worry :)
22:39:17 <awesame> I thought a function yielding _|_ would literally not terminate
22:39:45 <Cale> awesame: We've overloaded the meaning of 'not terminate' to include those sorts of failure.
22:39:51 <awesame> ah, okay
22:40:03 <Cale> awesame: In fact, if you write certain infinite loops, GHC will catch it and turn them into exceptions :)
22:40:09 <ddarius> They are observationally indistinguishable within the language.
22:40:23 <awesame> wait, but how does ghci end up printing "Exception: divide by zero"?
22:40:35 <Cale> > error "divide by zero"
22:40:35 <lambdabot>  Exception: divide by zero
22:40:41 <ddarius> GHCi isn't within the program.
22:40:46 <jeffz> solrize_: I don't think gnash makes flash open, iirc the terms under which the flash specification is licensed forbids development of flash players
22:40:57 <awesame> okay, so error, not ioError
22:40:58 <bd_> Some instances of the bottom can be caught by using Control.Exception
22:40:58 <sclv> "uncatchable exceptions" are really catchable in ghc it should be noted.
22:41:03 <newsham> jeffz: http://www.mozilla.org/projects/tamarin/
22:41:04 <lambdabot> Title: Tamarin Project
22:41:10 <bd_> but only in GHC, and not all of them will work that way
22:41:21 <bd_> eg, nontermination ;)
22:41:27 <ddarius> sclv: But only in the IO monad and they had to do a bit of sleight of hand to make it respectable ish.
22:41:28 <jeffz> newsham: not quite the same as flash, if you build tamarin, do you get a flash player that drops in as a replacement for the proprietary one?
22:41:40 <newsham> i think eventually...
22:41:52 <awesame> right, so I've used error, but never thought to ask why it doesn't change the type of the function you use it in
22:42:12 <jeffz> newsham: I don't think so, my understanding is that just the actionscript interpreter/jit known as tamarin is going to be open, the rest isn't.
22:42:57 <cjs> ES4 is far from a Flash player.
22:43:10 <awesame> its type is [Char] -> a, which says it takes a string and returns a value presumably of the type expected where it's found
22:43:12 <Cale> cjs: Tamarin also includes support for ActionScript
22:43:18 <cjs> Several projects have tried to do a free Flash player, but they've never caught up to Adobe.
22:43:18 <awesame> I guess that's _|_?
22:43:23 <Cale> cjs: Which does look somewhat hopeful.
22:43:26 <awesame> but what does it do with the string?
22:43:27 <cjs> ActionScript is only a small part of a Flash player.
22:43:37 <ddarius> awesame: _|_ is the only possibility
22:43:48 <Cale> awesame: The string is the message that the exception prints.
22:44:04 <cjs> In fact, come to think of it, it's not part of a Flash player at all. It's part of the IDE that generates SWF files, but in a SWF, it's all bytecode compiled from AS.
22:44:10 <Cale> awesame: So it's sort of like there are multiple bottoms, but the program has to end in order to tell them apart.
22:44:22 <jeffz> it's a shame that flash isn't as open and free as PostScript and PDF, Adobe's other formats
22:44:26 <awesame> so is this some special thing implemented in haskell itself, that I could only implement using a monad?
22:44:27 <Cale> awesame: So they might as well be the same thing as long as the program is running.
22:44:49 <Cale> awesame: Bottom really only exists in our mental model of how Haskell programs work.
22:44:56 <cjs> (I know quite a bit about SWF, BTW, since one of our products reads and writes those files.)
22:45:20 <dons> String -> a could be a compiler -- isn't that interesting.
22:45:34 <Cale> cjs: They also appear to have contributed the virtual machine?
22:46:03 <ddarius> dons: It wouldn't be type safe.
22:46:23 <Cale> awesame: The exception handler of course is something in the runtime system which stops your program and prints a message on the screen.
22:46:48 <dons> ddarius: yeah, there's a coerce required
22:47:18 <awesame> okay, I think I understand at least a little bit better
22:47:48 <Cale> cjs: Or perhaps they're just in the process of contributing that.
22:47:52 <newsham> when you say "just a as interpretter/jit" you mean to include running .swf files, right?
22:48:02 <cjs> Huh, so they are. Very good.
22:48:36 <awesame> dons: aren't actual haskell compilers String -> IO ()?
22:48:37 <cjs> Well, the only other big part is a vector rendering engine, so there's some hope here, really.
22:48:43 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6882
22:49:05 <Cale> Yeah, that would be pretty awesome if they come out with a 100% free implementation of Flash :)
22:49:08 <newsham> browser environment already largely has rendering engines
22:49:28 <dons> :t System.Eval.Haskell.eval
22:49:35 <cjs> Though getting enough info to build that without using Adobe's documents might be interesting. It's easy for earlier versions of SWF, but for the newest....
22:49:36 <lambdabot> forall a. (Typeable a) => String -> [System.Eval.Utils.Import] -> IO (Maybe a)
22:50:01 <awesame> close
22:50:14 <dons> well, it need not be in IO
22:50:27 <dons> its `eval`, but checked via the Typeable
23:00:46 <cjs> If I'm wanting to record timestamps for receipt times of network messages, what's the best thing to use for that?
23:03:09 <mgsloan> Data.Time.getCurrentTime ?
23:06:32 <cjs> Seems reasonable. Thanks.
23:08:42 <ivanm> this is pretty much off topic, but I'm starting to look for places to do my phd in next year... would anyone know of a good uni that does work in computational combinatorics, preferably in Haskell (or indeed just computational maths in general with haskell)?
23:10:39 <twb> So once again I have an afternoon off and am fantasizing about writing a seven-day roguelike in Haskell.
23:11:52 <TSC> Fantasising won't make it so
23:12:10 <twb> Last time I looked there was an old, unmaintained curses wrapper that was part of an old copy of yi, and a newer bare-minimum native library that the current yi used, which didn't do important things like SIGWINCH or colour.
23:12:48 <twb> http://members.cox.net/stefanor/vty/README
23:13:42 <sorear> vty handles SIGWINCH and color fine (I'm stefanor).
23:14:26 <sorear> it doesn't handle other important things, like $TERM (Hi, all the world is a VT102) and nontrivial deltas (noticably less efficient than curses)
23:14:48 <twb> sorear: I must misremember, sorry.
23:15:20 * sorear is actually very proud of vty's sigwinch handling, and thinks it's way better than everything else
23:15:30 <sorear> I think all the other aspects suck though
23:15:52 <glguy> Does anyone have a favorite intro to erlang URL?
23:19:51 <jeffz> glguy: http://www.erlang.org/white_paper.html is a brief one.
23:19:53 <lambdabot> Title: Erlang whitepaper
23:26:47 <cjs> Hm. What's an efficient way to serialize a DiffTime?
23:27:07 <cjs> And what are the portability concerns?
23:31:44 <cjs> Oh, and what's up with "No instance for (Show UTCTime)"? According to the docs, UTCTime is an instance of Show.
23:34:12 <TSC> Works for me:
23:34:27 <TSC> liftM show getCurrentTime ==> "2008-04-07 06:33:59.696063 UTC"
23:35:19 <sclv> cjs: DiffTime is an enum, no, so just fromEnum it to get an integral for serialization.
23:35:41 <cjs> Ah, I think I needed to import Data.Time, not just Data.Time.Clock.
23:36:01 <TSC> It even seems to have a Read instance, even though the docs don't mention it
23:36:40 <cjs> They do.
23:36:42 <TSC> Ah, the Read instance is in Data.Time.Format.Parse
23:36:56 <TSC> Yes, I can't read (:
23:37:05 <twb> sorear: know anything about "update-debian-haskell-files: vty.cabal:22: 'Executable' stanza starting with field 'build-depends'" ?
23:37:44 <sorear> twb: none at all
23:38:02 <twb> I get that when trying to debianizify the current unstable vty
23:38:50 <sorear> twb: dunno about debian-haskell, never used it; and I haven't used vty in quite a while
23:43:17 <sorear>  This is a scroll of acquirement!
23:43:24 <sorear> er mischan
23:44:09 <jsnx> welcom to hackers treasure zoo
23:44:20 <jsnx> does anybody even know what that's about?
23:47:44 * scook0 checks to see if this is #haskell or #nethack
23:48:30 <cjs> hmmm...but a DiffTime can be larger than an Int, which kinda breaks fromEnum....
23:49:52 <olsner> @ty fromEnum
23:49:55 <lambdabot> forall a. (Enum a) => a -> Int
23:50:13 <TSC> jsnx is clearly looking for #screen
23:50:24 <jsnx> TSC: well, no
23:50:43 <jsnx> TSC: i just thought maybe someone had played the game and knew where that came from
23:51:03 <cjs> Maybe I ought just to be recording deltas.
23:51:10 <jsnx> i actually bought the domain name "hackerstreasurezoo" because i like it so much
23:51:27 <TSC> When you enter a zoo, it says, "Welcome to David's treasure zoo."
23:51:53 <jsnx> TSC: oic
23:52:02 <idnar> Suddenly you can't see your bell!
23:52:15 <jsnx> TSC: so of course screen says "welcome to hacker's treasure zoo"
23:52:42 <TSC> I guess the text you copy is the "treasure"
23:54:20 <olsner> cjs: but what if your program gets scheduled out for 70-something years? :P
23:56:02 <cjs> That would screw me so badly that I wouldn't care what happened after that.
23:56:18 <cjs> Oh no! I'm falling into the trap of performance over correctness!
23:57:08 <jsnx> cjs: don't make fun
23:58:01 <olsner> and if you use deltas, make sure to correctly handle the case of time going backwards
23:58:30 <cjs> Actually, the delta would probably be picoseconds, so I'd need be unscheduled  for less than an hour.
23:58:40 <olsner> (since it does, sometimes)
23:59:10 <cjs> Oh, right. Crap.
23:59:44 <bparkis> why are there so many different logical systems? is there anything common to them all?
