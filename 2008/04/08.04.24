00:00:08 <cjs> ...and of course that awful, awful O'Caml book. :-)
00:00:14 <lety> :)
00:00:36 <uebayasi> is Haskell really popular in production? :)
00:00:40 <lety> i just want to make a choice whether ocaml or haskell and i'm having a hard time :)
00:00:54 <cjs> No question in my mind, Haskell, at this point. (Am I biased?)
00:00:56 <solrize> ocaml is sort of scheme with a type system and syntax
00:00:57 <sjanssen> uebayasi: you should ask Heffalump ;)
00:01:04 <cjs> I just made the choice about a month ago, so....
00:01:14 <solrize> haskell is a lot more interesting and difficult, so there's more to talk about.  that's why the channel is bigger :)
00:01:30 <lety> hehe
00:02:23 <lety> lets put it this if i start a large project and have trouble will short coming be more likely fixed in ocaml or haskell?
00:02:31 <Heffalump> haskell, I think
00:02:44 <lety> my god that was a horrible sentence srry
00:02:47 <solrize> do something small first
00:02:50 <Heffalump> there are significantly more people working on GHC
00:03:21 <Heffalump> the ocaml compiler just has fractions of people who work at INRIA, whereas GHC has 3 full-time people
00:03:22 <lety> solrize: is a poker bot small?
00:03:44 <Heffalump> I think a poker bot would be a good choice, as it'll be fairly self-contained
00:03:47 <solrize> it depends, i suppose.
00:03:53 <lety> who pays these people?
00:04:31 <bd_> microsoft research, isn't it?
00:04:37 <solrize> simon & simon = microsoft research.  who is person #3?
00:05:01 <lety> omg what if microsoft pulls the plug?
00:05:16 <sjanssen> solrize: Igloo (also funded by MS)
00:05:44 <bd_> lety: hope someone else funds it, I guess?
00:05:48 <solrize> ic
00:06:10 <lety> lol whos going to fund it? I don't think anyone has a big stake in haskell?
00:06:31 <bd_> IIRC a number of financial companies use it internally...
00:06:46 <cjs> Yeah, that Credit Suisse, for example.
00:06:54 <Heffalump> what, really? :-)
00:07:00 <cjs> But MS is spending on it.
00:07:01 <lety> i think those companies will just redo some code
00:07:06 * cjs bricks Heffalump.
00:07:14 <Heffalump> I doubt we would fund the entirety of GHC development if it came to that. (lety: I work for Credit Suisse)
00:07:15 <bd_> I'm sure they could affort to pay a few devs to hack on ghc
00:07:27 <bd_> I mean, if a few of them pooled funds anyway
00:07:32 <bd_> set up a GHC Foundation or something :)
00:07:42 <lety> lol
00:07:51 <cjs> Man, I saw a job advert from them the other day. Salary range was $200K-$300K/year.
00:07:53 <bd_> You laugh, but it's an entirely plausible result :)
00:07:59 <lety> so who fund projects like gcc?
00:08:02 <lety> funds*
00:08:12 <bd_> lety: GNU, which takes donations
00:08:16 <cjs> Chip and embedded systems vendors have done a reasonable amount.
00:08:18 <Heffalump> lety: mixture of volunteers and companies that want to use it
00:08:28 <cjs> Actually, I'm not sure that GNU has done more for it than Cygnus.
00:09:17 <lety> how many people here spend most of there time writing haskell code?
00:09:18 <OceanSpray> in a perfect world, these projects don't need funding, as they will be driven purely by awesomely productive programmers who have time to spare and are passionate despite sacrifice.
00:09:38 <OceanSpray> And then there's Walgreens.
00:09:43 <bd_> in practice that only works on nice simple projects that anyone can understand quickly
00:10:03 <lety> bd_: so true
00:10:12 <cjs> I do. About 80% FTE at this point.
00:10:25 <bd_> mind you there are a lot of such projects which do make useful and important software, so there you go
00:10:25 <lety> FTE?
00:10:38 <cjs> Full Time Equivalant.
00:10:43 <lety> ah
00:10:50 <cjs> Mon-Thu is Haskell, for me, and Friday is Ruby.
00:11:19 <lety> cjs: how do you programme in C/C++ after programming haskell?
00:11:33 <lety> i can't stand C/C++ anymore
00:11:38 <uebayasi> i thought you say "Friday is Beer" ;)
00:12:53 <cjs> How did I program in C even after Ruby? Even after Java, for that matter?
00:13:12 <lety> i look at my C++ code now and think how ugly and messy it is
00:13:28 <solrize> i never liked c++ but programming in c feels about the same as it always did
00:13:29 <lety> even though for C++ code its quite good
00:13:33 <cjs> But moving back to Ruby is not terribly painful for me at the moment, since I've only been doing Haskell for a month, now. And the language sucked before I started this, anyway. (Thus my presence here.)
00:13:54 <cjs> Unit testing in C is so painful....
00:13:56 <solrize> i use python for most day to day stuff and am wishing it was more like haskell
00:14:01 <augustss> C is a pretty good language, when you want to do low level programming.
00:14:28 <solrize> but i want a more reliable low level language than c.  cyclone looks interesting and i've been wondering why everyone hates ada so much
00:14:49 <solrize> my officemate used ada at his old job and liked it, so i've gotten a bit interested in it though i don't know it at all
00:14:52 <lety> cyclone?
00:15:14 <jeffz> lety: redhat hires people to work on gcc, last time I checked, too
00:15:14 <solrize> http://www.research.att.com/viewProject.cfm?prjID=67
00:15:16 <lambdabot> Title: AT&T Labs Research
00:15:47 <cjs> Wow, the NetBSD developers are out in force, today.
00:15:53 <cjs> Let's rewrite NetBSD in Haskell!
00:16:29 <lety> interesting thanks for the link
00:17:58 <uebayasi> i need a C replacement fitting nicely for embedded applications
00:18:22 <uebayasi> something not C, and not C++ :)
00:18:37 <jeffz> uebayasi: what does the embedded buzzword mean to you?
00:19:06 <uebayasi> routers running *nix, for example
00:19:11 <jeffz> uebayasi: I have seen "embedded" that is nearly no different to a desktop pc.
00:19:24 <solrize> those are big enuf boxes to run haskell
00:19:33 <lety> lol
00:19:36 <uebayasi> CPUs are much slower, and code space matters
00:20:07 <solrize> erlang was designed for phone switches
00:20:11 <solrize> and is much slower than haskell
00:20:19 <solrize> but appears fast enough for the application
00:20:31 <solrize> and seems to crush c++ in terms of reliability
00:21:03 <cjs> I was at dinner with some Erlang guys the other night. Their philosophy was very interesting; if a process has a problem, "let it crash."
00:21:09 <Svrog> uebayasi: i need a C replacement fitting nicely for embedded applicati <--- forth?
00:21:11 <Svrog> :)
00:21:14 <lety> rofl
00:21:20 <takamu> hey
00:21:22 <cjs> And then they started discussing writing an air traffic control system in it....
00:21:26 <solrize> lol
00:21:36 <cjs> Wow, FORTH. There's a blast from the past.
00:21:38 <janszn> @pl map (\n -> map (flip(,)n . id &&& cuboid n)xs) [1..r]
00:21:39 <lambdabot> map (flip map xs . ap ((&&&) . flip (,)) cuboid) [1..r]
00:22:21 <lety> has anyone written a 3d engine in haskell?
00:22:52 <solrize> http://www.haskell.org/haskellwiki/Frag
00:22:53 <lambdabot> Title: Frag - HaskellWiki
00:23:08 <Svrog> http://www.forthfreak.net/index.cgi?FunForth
00:23:14 <lambdabot> Title: FunForth - Kwiki
00:23:18 <solrize> http://www.cs.chalmers.se/~augustss/quakeh.html
00:23:20 <lambdabot> Title: Quake Haskell
00:23:31 <lety> still not a 3d engine :)
00:24:08 <lety> lol second link is in german
00:24:27 <solrize> that guy's german is even worse than mine in that case :)
00:24:28 <jeffz> doesn't look german to me
00:24:50 <solrize> http://www.st.cs.uni-sb.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf  this might interest you
00:24:51 <lambdabot> http://tinyurl.com/7cyhz
00:24:58 <lety> what language is it then?
00:25:11 <solrize> whatever they speak in .se
00:25:35 <lety> thanks lambdabot
00:26:19 <Svrog> cjs: one of the pdfs on the erlang web site with good coding practices suggests writing code like that - trusting only a really small part of the code and expecting everything else to fail
00:27:52 <_dolio> Ah ha!
00:27:59 <dolio> @yow!
00:28:00 <lambdabot> This PORCUPINE knows his ZIPCODE ... And he has "VISA"!!
00:29:13 * dolio just spent 20 minutes trying to figure out why 'Const $ expr :: Const (forall m. Nat m -> Const Bool m) (Succ n)' wasn't working.
00:30:08 <lety> interesting
00:30:27 <lety> so you think that a doom 4 can be written in haskell
00:31:02 <dolio> Answer: left-to-right impredicative instantiation has been removed in 6.9, apparently.
00:31:22 <cjs> Svrog: well, yes, that's the way to write a loosely integrated system.
00:34:57 <Svrog> yes - so my understanding of the erlang approach is that if the core of the system is reliable and can handle various processes crashing, then they simply dont bother to handle most errors in other parts of the code but let them propagate errors to the top
00:35:04 <Svrog> http://erlang.org/download/armstrong_thesis_2003.pdf
00:35:17 <Svrog> section 4.4 - Let it crash
00:35:36 <cjs> I'm quite aware of all this. I just found it amusing that you'd write an air traffic control system with the philosophy of, "let it crash." :-)
00:35:46 <Svrog> oh
00:35:48 <Svrog> hehe
00:36:18 <lety> meh one plain down who cares plenty more in the sky :)
00:36:30 <lety> plane*
01:02:09 <MarTHiNUS> hi.. how to load haskell file.. im new with haskell, let say my script file at d:\programming\haskell\Ex1.hs, i run hugs on windows
01:02:17 <MarTHiNUS> :l ..... ?
01:08:53 <dcoutts> MarTHiNUS: yes, :l and the filename
01:09:11 <dcoutts> MarTHiNUS: I usually find it easier to cd to the directory containing the .hs file you want
01:09:17 <dcoutts> before starting hugs
01:09:30 <cjs> is there something that will let me open a handle that writes to something in memory I can read later, a la Ruby's StringIO?
01:09:50 * quicksilver is boggled at the hyperbole arguing against changing ($) on haskell-prime
01:10:01 <dcoutts> MarTHiNUS: then it's easy, you just use: hugs Ex1.hs
01:10:02 <quicksilver> I recognise the irony therein given how fond I am on hyperbole myself :)
01:12:19 * dolio is insane!!!
01:16:00 <Baughn> dolio: ...no. I've seen insanity, and this isn't it.
01:16:01 <cjs> Is there a way I can tell the computer that a particular pattern match is not exhaustive on purpose?
01:16:19 <Baughn> cjs: Add "foo _ _ _ = undefined" at the end?
01:17:04 <cjs> Ah, thanks.
01:17:20 <cjs> Though that's really no different from error "..."
01:17:43 <Baughn> @src undefined
01:17:43 <lambdabot> undefined =  error "Prelude.undefined"
01:18:30 <quicksilver> cjs: normally I decide that partial functions are a fact of life and don't worry about that warning.
01:18:39 <quicksilver> which is sad, in a way.
01:19:03 <solrize> how do you get warnings for nonexhaustive matches?  i've thought of that as a missing feature from haskell
01:19:25 <solrize> there's an external tool for it but i hear that's a pain to use
01:20:10 <quicksilver> turn warnings on, afaik.
01:21:21 <cjs>     Warning: Pattern match(es) are non-exhaustive
01:21:21 <cjs>              In the definition of `connect': Patterns not matched: _ Refreshed
01:23:03 <solrize> ghc -W
01:42:08 <kalven> I noticed that Data.ByteString.UTF8 contains a bunch of functions like foldl, take etc. Is there no way to implement those in a generic way?
01:42:50 <Baughn> kalven: Nope. The implementation is quite different from the list versions.
01:42:59 <Baughn> It might be handy to have a common /interface/, but..
01:43:45 <dmwit> Isn't that what Data.Foldable is all about?
01:43:49 <dmwit> (a common interface?)
01:43:53 <quicksilver> in a sense, yes.
01:44:03 <quicksilver> But it doesn't give a common interface to an efficient 'take'
01:44:12 <quicksilver> (or even an inefficient take, actually)
01:44:31 <kalven> oh
01:44:31 <quicksilver> this is sort-of what 'ListLike' was designed for but it's not clear to me that there is much to be gained.
01:44:35 <dmwit> Data.Takeable ;-)
01:45:10 <quicksilver> it might be nice to have a ByteString interface to abstract over the difference between lazy and strict, sometimes
01:45:20 <quicksilver> but I'm not sure there is much value to a common interface for bytestring and list
01:45:31 <kalven> wouldn't it be of advantage to be able to implement an algorithm once?
01:46:06 <quicksilver> which algorithm?
01:46:15 <quicksilver> the algorithm *for* take? or some algorithm *using* take?
01:47:16 <solrize> :k Monad
01:47:17 <lambdabot> Class `Monad' used as a type
01:47:44 <kalven> quicksilver: a function like take (or map), that operates on a sequence.
01:47:53 <solrize> :k IO
01:47:54 <lambdabot> * -> *
01:48:00 <solrize> :k StateT
01:48:01 <lambdabot> * -> (* -> *) -> * -> *
01:48:12 <dmwit> kalven: I don't think that's really feasible in general.
01:48:20 <dmwit> There's just too many ways to implement a sequence.
01:48:26 <quicksilver> kalven: the whole point about ByteString take is it is a totally different algorithm from list take.
01:48:39 <quicksilver> kalven: if it was the same algorithm, bytestrings would be much less useful.
01:48:56 <solrize> what if take operated on some more general typeclass instead of on lists?
01:49:19 <quicksilver> well, that's what we've just been talking about.
01:49:21 <solrize> then bytestring and list could each have their own take without the user having to deal with it
01:49:30 <solrize> well you wouldn't have to say B.take
01:49:31 <quicksilver> I'm saying I don't think that's as useful as it sounds.
01:49:43 <quicksilver> ListLike exists but I've never wanted to use it.
01:55:07 <solrize> hmm, could be.  shrug
01:56:16 <Baughn> The point of typeclasses (in this respect) is so your code doesn't need to know what's underneath
01:56:29 <solrize> right
01:56:36 <Baughn> But bytestrings have vastly different performance characteristics from lists. To use them effectively, I /have/ to know I'm using them
01:56:37 <kalven> quicksilver: ok, so to get efficiency, one has to reimplement it?
01:56:49 <kalven> what about foldr then?
01:56:49 <cjs> I've always wondered why you can't do polymorphism on function arguments without a class.
01:56:59 <cjs> Maybe it's a silly question.
01:57:20 <cjs> Yes, you have to re-implement it because the data structure is different.
01:57:36 <cjs> There's a good set of slides from a presentation on Data.ByteString somewhere.
01:57:46 <Baughn> cjs: To begin with, it would break type inference. There's a reason you have to write the specific types a class instance covers..
01:58:34 <kalven> cjs: some languages use iterators to separate algorithms from data.
01:59:17 <quicksilver> Baughn: yes, that's roughly what I meant
01:59:29 <quicksilver> it's very unusual to write code which 'doesn't care' if its using lists or bytestrings
01:59:30 <cjs> Really? Why can't it just have both a 'cons :: Char -> [Char] -> [Char]' and a 'cons :: Char -> ByteString -> ByteString'? You could infer from that, could you not?
01:59:32 <quicksilver> normally you care deeply.
01:59:44 <quicksilver> in fact, when you don't care you might as well just use lists
02:00:19 <quicksilver> cjs: you could, but you totally change type inference.
02:00:31 <quicksilver> cjs: the typeclass system is a much more elegant solution.
02:00:36 <cjs> The compiler could basically just make up a class and a couple of instance declarations, could it not? How does it change type inference?
02:00:37 <quicksilver> (obviously you can do this, because C++ does)
02:00:44 <cjs> As does Java.
02:00:59 * quicksilver shrugs
02:01:12 <quicksilver> the effects are deep and I can't immediately pull up the key ones for you
02:01:20 <quicksilver> you're breaking the principle type property
02:01:23 <quicksilver> and that's important
02:01:30 <quicksilver> it's required to prove that type inference is sensible
02:01:44 <Baughn> cjs: It's not that you /can't/ do it, it's that if you do, you wouldn't have haskell any more. Existing programs would break
02:02:12 <Baughn> That is, you can't have that /and/ the current type system
02:03:21 <quicksilver> cjs: the typeclass system is, essentially, a very clever solution to the mess that ad-hoc polymorphism as in C++ gets you.
02:03:37 <quicksilver> I suspect there are some motivating examples in some of the early literature on it.
02:04:22 <cjs> Hm. I hope I run across one one day.
02:06:49 <kalven> qquicksilver: I'm not sure that writing code that doesn't care if the underlying sequence is a list or a bytestring is that uncommon. Is the implementation of a foldl really going to look that different for those two?
02:07:35 <quicksilver> kalven: no, the implementation of foldl looks essentially the same
02:07:43 <quicksilver> kalven: which is why foldl is in the Foldable class
02:07:46 <quicksilver> so that part works.
02:07:54 <quicksilver> some other things don't work as well, like take.
02:08:58 <kalven> why is it reimplemented in utf8 then?
02:09:01 <kalven> (foldl)
02:09:38 <quicksilver> because of fusion, I suspect.
02:10:25 <kalven> cold fusion?
02:10:51 <dmwit> Cold fusion doesn't exist.
02:10:54 <dmwit> (yet)
02:11:17 <quicksilver> stream fusion.
02:11:31 <quicksilver> another reason might just be fear of dictionary overhead.
02:11:32 <quicksilver> I don't know.
02:12:29 <kalven> ok, thanks for your time
02:13:10 <quicksilver> it might simply be that Foldable isn't in the base library and bytestring is, of course.
02:13:19 <quicksilver> or that foldable didn't exist when bytestring was being written.
02:16:18 <dolio> Foldable is in base.
02:16:34 <dolio> ByteString isn't anymore.
02:17:30 <quicksilver> oh, I thought it was? doesn't ghc depend on it?
02:17:39 <quicksilver> hmm
02:17:48 <quicksilver> there may be more than one sense of the word 'base'
02:17:53 <quicksilver> or I may be using the wrong word :)
02:18:01 <dolio> It's distributed with GHC, but it's in its own package now.
02:18:38 * quicksilver nods
02:19:53 <dolio> I don't think there's any way you could implement Foldable for byte strings, though, because they're not parameterized.
02:20:40 <quicksilver> oh yes, I forgot about that
02:22:39 <cjs> Is reading from an MVar quite fast if nobody else is accessing it?
02:24:09 <solrize> erm, wouldn't it have a lock ?
02:24:28 <solrize> ok, STM, there'd be a version number
02:24:42 <solrize> so that would be fast
02:25:01 <quicksilver> solrize: MVar is not STM.
02:25:34 <quicksilver> cjs: it's quite fast. I'm not sure exactly how fast.
02:25:37 <solrize> in that case reading the mvar may require getting a lock
02:26:27 <quicksilver> it's not locked in the usual sense
02:26:36 <cjs> Fast enough that 10,000 times per second is not going to have any significant overhead, then.
02:26:36 <quicksilver> with the non-threaded RTS there would be nothing to do at all.
02:26:48 <quicksilver> with the threaded RTS there must be some kind of mutex around takeMVar
02:27:04 <cjs> I'm threaded.
02:27:09 <quicksilver> I'm not sure I remember seeing it dcoumented anywhere.
02:27:22 <cjs> And the MVar will be changed by other threads, but not very frequently.
02:28:28 <solrize> the usual way to implement futex takes 100 or so cycles to acquire the lock and basically 0 to release it, i think
02:29:04 <cjs> I'd be surprised if it were changed more than a few dozen times per second, whereas I need to read it several thousand times per second, and do at least a bit of processing on what I've read, even if it's just to stick references to the packet into other MVars or STM so that other threads can do the heavy processing.
02:29:35 <solrize> several thousand a second is nothing, if you need to do millions/sec then think about STM
02:29:45 <cjs> Actually, come to think of it, if I do that, I'd update the mvar that it's reading much more rarely.
02:31:08 <quicksilver> hmm. The original Concurrent paper was written before the threaded RTS
02:31:11 <quicksilver> if I'm reading it correctly
02:31:13 <solrize> maybe in the single threaded case the compiler could generate special code every time you read an mvar, that acted like a lock without an actual atomic update
02:31:17 <quicksilver> so they didn't need to lock...
02:31:46 <cjs> I suppose in theory, on a gigabit network, I could be receiving something close to a million messages per second, but I can't see the exchange getting that busy. :-)
02:31:51 <solrize> i guess i wouldn't it past the simons to do an optmizatiion like that, but i think more normal is to just do an atomic set
02:31:54 <solrize> which is 100 cycles or so
02:32:19 <cjs> So STM is faster?
02:32:29 <quicksilver> cjs: I think the straight answer is that none of us know so you should just try it :)
02:32:34 <quicksilver> but I think MVar will be fast enough.
02:32:41 <quicksilver> JaffaCake woudl know if you spot him later.
02:33:19 <cjs> Oh, you bet I'll be trying it. :-)
02:33:40 <cjs> I wonder if they'll have eight core CPUs by the time I roll this out?
02:33:50 <solrize> they have them now
02:34:02 <cjs> I mean cheapish Intel or AMD ones. Do they have them now?
02:34:07 <solrize> mips
02:34:24 <cjs> Actually, I suppose we could always get a Sun box, though I bet that's expensive for the actual CPU power you get.
02:35:24 <solrize> http://www.cavium.com/OCTEON_CN38XX_CN36XX.html
02:35:25 <lambdabot> Title: Cavium Networks - Products > OCTEON MIPS64 Processors > Silicon > OCTEON&trade;  ...
02:37:05 <solrize> if you're really trying to do super high concurrency, much as i'll get flamed here i think haskell is probably not the answer
02:37:18 <solrize> http://www.kegel.com/c10k.html  this is the classic paper
02:37:20 <cjs> ???!!!
02:37:22 <lambdabot> Title: The C10K problem
02:37:29 <cjs> I'm quite familiar with that paper.
02:37:41 <cjs> Also, Gregory Pfister's _In Search of Clusters_.
02:38:05 <cjs> (Which is fantastic reading if you're interested in all the gory details of concurrency and parallel processing.)
02:38:10 <solrize> oh cool, i haven't read that
02:41:32 <sjanssen> solrize: I think GHC/Haskell is a reasonable choice for high concurrency
02:41:33 <solrize> http://www.massbookstore.com/rel/v2_basket.php?storenr=359   crap these guys have it for 5 bucks but only thru google checkout
02:41:35 <lambdabot> Title: - Basket
02:42:02 <cjs> Check the edition; there's a 1995 edition and a 1998 editiion with a blue cover.
02:42:08 <cjs> I'm not familiar with the older one.
02:42:18 <solrize> it says 2nd edition and shows a blue picture
02:42:24 <cjs> That's the one. Lucky guy!
02:42:34 <solrize> unlucky, unless i sign up for google checkout
02:42:37 <cjs> I just paid 3000 yen for mine.
02:44:41 <solrize> maybe i'll request it from the library
02:46:35 <cjs> It's a fairly long read.
02:51:50 <solrize> http://web.archive.org/web/20070701221306/wagerlabs.com/2006/01/01/haskell-vs-erlang-reloaded
02:51:53 <lambdabot> Title: Tenerife Skunkworks Haskell vs. Erlang, Reloaded, http://tinyurl.com/6x6jyg
02:52:51 <sjanssen> solrize: trust me, we've all seen that post far too many times :/
02:52:55 <solrize> hehe
02:54:03 <quicksilver> solrize: I would advise anyone against forming any opinion based on that post.
02:54:44 <quicksilver> solrize: if you're interested in the issues, it may be interesting to research the haskell mailing lists around the time, where you will find some threads on the subject of that project.
02:55:14 <solrize> a bunch of them are linked from that page and i did look at some of them
02:55:58 <solrize> i have some intellectual interest in those issues but am not too worried about massive concurrency for now.  i'm more desirous of insane speed for programs with just a few threads :)
02:58:39 <dolio> K is way better than Erlang, right?
02:58:45 <solrize> K?
02:58:55 <sjanssen> dolio: heh
02:59:15 <sjanssen> joelr does have some serious attention span issues
03:00:42 <dolio> Or maybe Q is better.
03:00:53 <solrize> i spoke to some guys who do VOIP code (stupendously large amounts of connections) and they are like DSP programmers, low level C and assembly
03:00:57 <dolio> K might not have enough 1-character operations.
03:01:27 <quicksilver> solrize: the fact that they do it that way does not, of course, indicate that that is the best way to do it :)
03:01:50 <quicksilver> they may for example have huge structures and libraries built up which make it easier, and so on, so it may be right to continue in the same vein.
03:01:51 <dolio> Oh, no, I guess Q is the one with the actual words.
03:02:14 <solrize> i don't think they could get anywhere near their current performance level with threads/microthreads
03:03:30 <quicksilver> solrize: are they using a completely single-threaded set up then? single cpus etc?
03:04:24 <solrize> i believe so, for the code they talked about with me.  maybe there's some more demultiplexing going on further out
03:04:33 <quicksilver> well, fine.
03:04:42 <solrize> although that may be done with special hardware these days
03:04:44 <quicksilver> if they're using a single threaded architecture and that works well
03:04:51 <solrize> cut-through routing on FPGA's
03:04:55 <quicksilver> then I'm sure hand-coded C and asm will serve them superbly
03:05:01 <quicksilver> but I thought we were discussing concurrency.
03:05:25 <solrize> concurrency in SPJ's sense, as distinct from parallelism
03:05:26 <quicksilver> the question I'm interested in is "what would be a good language to solve the voip routing problem on a 64-core machine"
03:05:53 <quicksilver> and I contend that C and asm would not be the answer in that case.
03:06:20 <solrize> i dunno offhand, but i'd spend some time thinking on oldfashioned lines, ring buffers, scatter-gather DMA on the network cards, etc
03:07:45 <solrize> there's not that much need for shared data between the threads
03:09:45 <solrize> seriously my guess is that big switches are programmed in fairly slow languages like erlang because the actual intense operations are done in hardware
03:11:43 <atsampson> and because smart algorithms generally beat hand-tuned brute force...
03:12:48 <atsampson> it's hard to be very clever if you're trying to write concurrent stuff in C; using a language that lets you express concurrent applications more effectively and reason about their correctness more easily means you can get away with more complex scheduling/routing approaches
03:13:31 <solrize> i don't think there's much complexity, it's just a matter of shovelling packets from one interface to another as fast as possible, with a fairly simple lookup structure
03:14:07 <atsampson> I've been pretty impressed with Haskell's concurrency performance -- I work with occam-pi (which is a language expressly designed for concurrency with a hand-tuned runtime), and Haskell's performance on trivial concurrency benchmarks is within an order of magnitude of occam, which is better than pretty much any other language I've seen
03:14:14 <solrize> actually now that i think of it maybe not so simple, a binary decision tree implemented in reconfigurable logic on an FPGA
03:14:41 <atsampson> (for "pretty impressed" read "really impressed", actually)
03:14:46 <solrize> did i just hear you say that haskell was slower than a properly optimized system by a factor of 10?  :)
03:15:20 <solrize> occam-pi sounds cool
03:15:23 <atsampson> it's more like a factor or five, and the "properly optimised" system is one where a communicating is a stack pointer load and a jump ;)
03:15:38 <solrize> there must be a way to eliminate the jump :)
03:16:32 <solrize> #
03:16:33 <solrize> # 70 nano-seconds context-switch/communication time (on an 800 MHz. P3)
03:16:33 <solrize> # 20 nano-seconds process startup/shutdown time (on an 800 MHz. P3)
03:16:34 <solrize> wow
03:17:52 <dcoutts_> compare that to lightweight ghc threads, and then to posix threads
03:19:46 <solrize> it looks like a sort of erlang-ish language with a real compiler built around a low level switching mechanism
03:19:55 <solrize> i don't see any sample code though
03:19:59 <solrize> does it have a type system?
03:20:13 <solrize> does it use a shared gc?
03:21:24 <solrize> anyway ghc threading is certainly fast enough for most real world uses, there's just still going to be some occasions for pushing things to extremes
03:21:25 <atsampson> it's a pretty primitive language (very Pascal-ish); extremely simple static type system; no GC at all
03:21:34 <atsampson> I'd rather use Haskell for anything non-trivial ;)
03:28:36 <solrize> ipc by data copying?
03:28:47 <solrize> anyway, yeah, it sounds specialized
03:29:46 <atsampson> by transferring references, usually, since copying's expensive
03:31:23 <solrize> is there automatic reference counting?
03:31:52 <atsampson> yup
03:31:55 <solrize> i guess you could write in a style without much complex structure
03:32:11 <solrize> or circular lists
03:32:37 <atsampson> but usually when you send a reference to someone else, you lose it ("mobile data"), so there's no need to track the ref count since there's always only one reference
03:33:04 <solrize> right, you lose the reference but the other end gains it
03:33:20 <solrize> anyway it sounds cool, maybe i'll find an application for it sometime
03:39:05 <HunterXHunter> @seen vagabond
03:39:06 <lambdabot> I haven't seen vagabond.
03:41:13 <aleator> quick strictness question: Does this do anything: bangReturn x = return x `demanding` rnf x ?
03:42:38 <dolio> It will evaluate x to normal form when 'return x' is evaluated.
03:43:10 <aleator> And within io this happens before next io action?
03:43:42 <dolio> I think so.
03:43:58 <solrize> normal form = fully evaluated all the way through?
03:44:19 <quicksilver> yes
03:44:30 <quicksilver> assuming rnf is defined correctly for that type, of course
03:44:40 <quicksilver> :t rnf
03:44:43 <lambdabot> forall a. (NFData a) => a -> Done
03:44:58 <quicksilver> you can make a broken instance of NFData which does less than normal form, or nothing at all :)
03:45:33 <aleator> I'm just looking for a way to do "avgs<- mapM (\x -> loadImage x >>= return.IMG.average) bigListOfFiles; print avgs"
03:45:53 <solrize> that looks useful even for sequential programs.
03:46:09 <aleator> which seems to think that it is good idea to load all images and then start storing averages..
03:47:28 <solrize> http://hpaste.org/7128#a6   from dcoutts last night, for maybe sort of a similar problem
03:48:24 <dcoutts_> I think it's different since each action here involves IO, ie loadImage right?
03:49:08 <dcoutts_> aleator: you should look at evaluate
03:49:14 <dcoutts_> @hoogle evaluate
03:49:15 <lambdabot> Control.Exception.evaluate :: a -> IO a
03:49:49 <dcoutts_> aleator: it's basically seq but for the IO monad, so the evaluation is well defined wrt to the other IO actions
03:49:50 <quicksilver> mapM (\x -> do loadImage x; avg <- evaluate IMG.average x; return avg )
03:50:01 <quicksilver> looks roughly right
03:51:03 <dcoutts_> or simpler: mapM (\x -> loadImage x >>= evaluate . IMG.average)
03:52:23 <aleator> dxcoudcoutts_: Ah thanks. I'll try.
03:53:11 <dcoutts_> > '\x007f'
03:53:13 <lambdabot>  '\DEL'
03:56:28 <solrize> heh
03:56:30 <vincenz> http://reddit.com/info/6gxtf/comments/  -- vote :)
03:57:36 <dcoutts_> vincenz: hmm, a lazily re-sizable array...
03:57:58 <vincenz> dcoutts_: based on where you access it
03:58:01 <dcoutts_> vincenz: you mean a 1-d array extensible at the top end?
03:58:14 <vincenz> dcoutts_: yes, or a 2-d array extensible on the right and bottom edge
03:58:37 <dcoutts_> vincenz: I guess it'd have to use some kind of tree underneath
03:58:40 <vincenz> (with O(1) access of course, after the first allocation)
03:58:46 <dcoutts_> a tree of dense chunks
03:58:51 * vincenz nods
03:59:08 <vincenz> but it would have to happen under the hood
03:59:19 <vincenz> so that consumption not production defines the index-range
03:59:35 <vincenz> then you could
03:59:41 <vincenz> (lazyArray [0..]) ! 100
03:59:53 <dcoutts_> vincenz: so, one defines the whole array space lazily and allocate and calculate when you access
03:59:58 <vincenz> Yep :)
04:00:06 <dcoutts_> vincenz: you want the array to be dense or sparse?
04:00:17 <vincenz> Been thinking about that, a sparse array might be nice
04:00:25 <vincenz> Certain memization problems are rather sparse
04:00:37 <vincenz> usually for dense cases you know your index-range
04:00:51 <sjanssen> vincenz: is O(1) truly required?
04:01:05 <vincenz> (an example of a sparse matrix would be the fibonacci function I once showed)
04:01:14 <dcoutts_> you can't have O(1) sparse arrays afik
04:01:16 <vincenz> sjanssen: well you could go the clojure way and have very flat trees
04:01:34 <sjanssen> it seems easy to do O(log n) -- a lazy trie, for example
04:01:35 <vincenz> O(log n) for big log factors ~ O(1)
04:01:57 <vincenz> sjanssen: does that work in a 2d case?
04:02:08 <sjanssen> vincenz: sure, why not?
04:02:14 <vincenz> Trie (Trie a) ?
04:02:30 * dolio has written a lazy memoizing trie before.
04:02:40 <sjanssen> dolio: hasn't everyone? :P
04:02:51 <dolio> Although I think it was broken in some way.
04:03:21 <dolio> For negative numbers perhaps. But who uses those?
04:03:23 <dcoutts_> vincenz: the array construction would have to be a bit different, not a list
04:03:33 <dcoutts_> @type Array.array
04:03:34 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
04:03:43 <sjanssen> yes, you really want a function here
04:03:47 <dcoutts_> yes
04:03:53 <vincenz> i -> e
04:04:12 <dcoutts_> larray :: Ix i => (i -> e) -> LArray i e
04:04:20 <vincenz> somethng like that :)
04:04:22 <vincenz> same interface as Array
04:04:28 <vincenz> without stuff like "length"
04:05:00 <vincenz> dcoutts_: that would make the memoization process even simpler, imho
04:05:05 <dcoutts_> yes
04:05:06 <vincenz> since usually you have
04:05:12 <vincenz> worker i = ... arr ! (i-x)
04:05:40 <vincenz> actually, that would be a very easy to use interface for memoization
04:05:46 <vincenz> I'd even call it LMemo i e
04:05:59 <sjanssen> why L?
04:06:09 <vincenz> dunno, wasn't sure about the L
04:06:20 <sjanssen> vincenz: I'd call it (i :->: e)
04:06:28 <vincenz> sjanssen: :)
04:06:32 <sjanssen> where :->: is an associated data type :)
04:06:41 * sjanssen tries to find this code
04:07:02 <vincenz> since your i is part of Ix
04:07:08 <vincenz> I'd make it very flat
04:07:12 <vincenz> like 32-branching factor
04:07:18 <tibbe> dcoutts: how's your students unicode stuff coming along?
04:07:18 <tibbe> dcoutts: I'm worried about lazy I/O ;)
04:07:28 <vincenz> you could potentially use Array's for the leafs
04:07:32 <dcoutts_> tibbe: don't worry about lazy io, be happy :-)
04:08:14 <vincenz> larray :: Ix i => i -> (i -> e) -> (i :-> e)
04:08:17 <dcoutts_> vincenz, sjanssen: or Cache i e, like memo but with the ability to limit the size using some cache eviction policy, but preserving a pure api
04:08:18 <vincenz> where you can choose the chunk size
04:08:36 <vincenz> s/larray/memo
04:08:46 <dcoutts_> tibbe: he's finished exams and is back from holiday tomorrow
04:09:14 <dcoutts_> tibbe: do you worry about lazy io wrt to unicode any more than you worry about lazy io generally?
04:10:00 <vincenz> dcoutts_: is the 'Ix' a requirement?
04:10:23 <vincenz> The question is, will this be an array-like thing, or a generic cache thing (more like a hashtable)
04:10:23 <dcoutts_> vincenz: how else do you map keys to locations in the array?
04:10:59 <vincenz> i :-> e indicates a more generic itnerface than a sequence
04:11:11 <vincenz> Ix is only really suitable for sequences
04:11:37 <sjanssen> why use an array at all?
04:12:01 <dcoutts_> sure, sure, you can generalise and pick specific representations depending on the key type
04:12:05 <vincenz> sjanssen: O(1) access to the chunks
04:12:13 <vincenz> dcoutts_: using type-families?
04:12:19 <dcoutts_> aye
04:12:25 <sjanssen> vincenz: meh, everything is O(1) -- you only have so much address space
04:14:10 <SamB> sjanssen: you can go through a lot of states even in 1GB of address space...
04:17:01 <SamB> 2^(8*1024^3) is a big number...
04:17:15 <Syzygy-> > 2^(8*1024^3)
04:17:22 <lambdabot> Terminated
04:17:45 <vincenz> dcoutts_: though the (i -> e) does not work well for infi-lists, cause then you'll constantly be doing l !! i
04:18:08 <SamB> Syzygy-: you did know that wasn't going to work, right?
04:18:16 <Syzygy-> Yeah :)
04:18:21 <vincenz> So I see two possibilities here, 1 = infinite from folding, the other = sparse
04:19:57 <sjanssen> SamB: yes, what I said makes no sense
04:20:17 <sjanssen> what I meant is that the key size is constrained, so even O(log n) is constant
04:20:48 <SamB> ah.
04:21:38 <SamB> log(1024^3) *is* a much more managable number, for reasonable bases ;-)
04:22:39 <SamB> (by reasonable I mean >= 2)
04:22:56 <vincenz> SamB: 1 would be rather painful :)
04:23:09 <Deewiant> what's wrong with base 1.5?
04:23:13 <SamB> I'm fairly certain that isn't legal
04:23:32 <SamB> Deewiant: well, I'm trying to rule out bases overly close to 1
04:24:11 <Deewiant> why's that
04:24:48 <SamB> > log (1024^3) / log 1.00000001
04:24:49 <lambdabot>  2.0794415647147892e9
04:24:54 <SamB> > log (1024^3) / log 1.000000000001
04:24:55 <lambdabot>  2.0792566945498938e13
04:25:03 <SamB> hmm.
04:25:13 <SamB> > log (1024^3) / log 1.00000000000000001
04:25:14 <lambdabot>  Infinity
04:25:18 <SamB> > log (1024^3) / log 1.000000000000001
04:25:19 <lambdabot>  1.8729944304496088e16
04:25:23 <sjanssen> SamB: do you know logBase?
04:25:31 <SamB> sjanssen: oh, heh
04:25:38 <sjanssen> @src logBase
04:25:38 <lambdabot> Source not found. Just what do you think you're doing Dave?
04:25:45 <Deewiant> @src log
04:25:45 <lambdabot> Source not found. Maybe you made a typo?
04:25:49 <SamB> > logBase 10 100
04:25:50 <lambdabot>  2.0
04:26:06 <SamB> > logBase 1.000000000000001 (1024^3)
04:26:07 <lambdabot>  1.8729944304496088e16
04:26:18 <SamB> > logBase 1.0000000000000001 (1024^3)
04:26:19 <lambdabot>  Infinity
04:26:26 <SamB> > logBase 1.0000000000000002 (1024^3)
04:26:27 <lambdabot>  9.36497215224804e16
04:26:33 <Deewiant> > logBase 1.5 (1024^3)
04:26:34 <lambdabot>  51.285338740543644
04:26:45 <SamB> > logBase 1.00000000000000015 (1024^3)
04:26:45 <lambdabot>  9.36497215224804e16
04:26:52 <SamB> > logBase 1.00000000000000011 (1024^3)
04:26:52 <lambdabot>  Infinity
04:26:56 <SamB> > logBase 1.00000000000000013 (1024^3)
04:26:57 <lambdabot>  9.36497215224804e16
04:26:58 <vincenz> spam
04:27:03 <SamB> sorry
04:27:34 <Deewiant> > map (`logBase` (1024^3)) (iterate (+ 0.000000000000001) 1.0)
04:27:37 <lambdabot>  [Infinity,1.8729944304496088e16,9.364972152248048e15,6.243314768165369e15,4....
04:28:08 <SamB> it's kind of funny that I get the same answer with 1.00000000000000015 and 1.00000000000000013..
04:28:15 <SamB> > 1.00000000000000015 == 1.00000000000000013
04:28:16 <lambdabot>  True
04:28:23 <SamB> ah. that explains that ;-)
04:29:06 <mauke> > 1.00000000000000015
04:29:07 <lambdabot>  1.0000000000000002
04:29:51 <Deewiant> > (1.00000000000000012, 1.00000000000000011)
04:29:52 <lambdabot>  (1.0000000000000002,1.0)
04:32:08 <byorgey> my eyes! the goggles, they do nothing!
04:33:44 <vincenz> byorgey: xml goggles?
04:34:01 <SamB> vincenz: I bet he's using those lisp goggles
04:34:05 <SamB> buggy as hell, them
04:34:10 <byorgey> heh
04:34:11 * vincenz shudders
04:34:21 <vincenz> (that was a reference to ICFPC '06)
04:34:44 <SamB> byorgey: use the ML goggles
04:35:25 <byorgey> well, I was TRYING to use the #haskell goggles, and then someone came along and filled them with FLOATING POINT
04:35:56 <mauke> Â·
04:36:12 <mauke> U+00B7: FLOATING POINT
04:36:21 <SamB> what?
04:36:33 <opqdonut> :D
04:36:36 <SamB> U+00B7 MIDDLE DOT
04:36:38 <vincenz> You're scaring the newbiees away with floating points and unicode!
04:36:39 <vincenz> Quicck!
04:36:55 <vincenz> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs !! 10
04:36:56 <lambdabot>  89
04:37:18 <SamB> vincenz: that isn't the answer
04:37:20 <SamB> 42 is
04:37:26 <SamB> now all we need is the question...
04:37:28 <Corun> As always.
04:37:38 <vincenz> 42 is only the answer in 8 -bit systems
04:37:55 <mauke> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs !! 12
04:37:56 <lambdabot>  144
04:37:59 <Corun> And in 42 bit systems.
04:38:06 <Deewiant> > let fibs = fix ((0:) . scanl (+) 1) in fibs !! 13
04:38:07 <lambdabot>  233
04:38:13 <byorgey> @go the answer to life, the universe, and everything
04:38:15 <lambdabot> http://en.wikipedia.org/wiki/Answer_to_Life,_the_Universe,_and_Everything
04:38:18 <vincenz> :D
04:38:28 <byorgey> aww, it was supposed to just print '42'
04:38:36 <mauke> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in filter (liftM2 (==) (fibs !!) (^2)) [0..]
04:38:42 <lambdabot>  [0,1,12Exception: Time limit exceeded
04:38:45 <vincenz> sorry, make that a 6-bit system
04:39:22 <byorgey> hehe, mauke, awesome =)
04:39:53 <mauke> [0,1,12]. coincidence?
04:39:54 <vincenz> mauke: I bet my fib version would handle that :)
04:40:20 <vincenz> IT goes up to 1M in lambdabot
04:41:29 <vincenz> But I still prefer this one: http://hpaste.org/7145
04:42:33 <SamB> hmm.
04:42:42 <mauke> http://mauke.ath.cx/stuff/perl/fibcheck.pl
04:47:15 * mux_ has spent the whole day so far twiddling his thumbs waiting for the clearcase server to get fixed
04:47:31 <mux_> how ridiculous is that?
04:47:50 <vincenz> mux_: write fib functons
04:47:51 <mux_> even an old crusty cvs would still let us work
04:48:42 <SamB> Narrator: There is a theory which states that if ever anyone discovers exactly what the Universe is for and why it is here, it will instantly disappear and be replaced by something even more bizarre and inexplicable.
04:48:42 <SamB> There is another theory which states that this has already happened.
04:48:43 <mux_> vincenz: I'm not so excited about writing fib functions :)
04:48:49 * SamB loves that quote
04:48:52 <mux_> SamB: heh, douglas adams rocks
04:49:14 <mauke> (douglas adams)++
04:49:15 <SamB> we got started on 42, so now I'm reading the wikipedia article on the question
04:49:33 <mux_> Joo Janta 200 Super-Chromatic Peril Sensitive Sunglasses have been specially designed to help people develop a relaxed attitude to danger. At the first hint of trouble, they turn totally black and thus prevent you from seeing anything that might alarm you.
04:49:34 <dolio> I think HHGG is the only book I've read where I actually started laughing while reading it.
04:49:35 <SamB> no, wait, the article is on the answer
04:49:45 <SamB> but talks more about the question, really
04:49:45 <dolio> When Arthur tells the story about the biscuits.
04:50:00 <quicksilver> I think that's so long and thanks for all the fish
04:50:06 <quicksilver> if you mean the biscuits at the train station
04:50:07 <quicksilver> in the cafe
04:50:15 <mux_> I've actually burst laughing in the subway going to work while reading adams books
04:50:28 <SamB> I really need to read the books
04:50:31 <vincenz> @let fibs n = let arr = array (0, max 2 n) $ [(0,0), (1,1), (2,1)] ++ [(i,e) | i <- [3..n], let i' = i `div` 2, let e = (arr ! i') * (arr ! (i-i'-1)) + (arr ! (i'+1))*(arr ! (i-i'))] in arr ! n
04:50:33 <dolio> Yeah. It's whichever one has him dating the girl.
04:50:36 <lambdabot> Defined.
04:50:37 <vincenz> > fibs 1000000
04:50:40 <lambdabot>  1953282128707757731632014947596256332443542996591873396953405194571625257887...
04:50:41 <mux_> yeah, Fenchurch
04:50:59 <SamB> quicksilver: I love how the jester says that in Zork 0
04:51:19 <SamB> I think that's where I first encountered it...
04:51:29 <vincenz> > filter (liftM2 (==) fibs (^2)) [0..]
04:51:35 <lambdabot>  [0,1,12Exception: Time limit exceeded
04:51:38 <SamB> and it really made no sense...
04:52:10 <vincenz> > length . show . fibs $ 1000000
04:52:13 <lambdabot>  208988
04:52:46 <mux_> I think one of my favourite pieces in the adams books is that spacecraft where the robots crew is trying to recharge their lemon-soaked napkins stock while maintaining the passengers strapped to their places
04:52:56 <mux_> for like, I don't remember how many thousand years
04:53:08 <mux_> that was awesome
04:53:28 <SamB> mux_: are the passengers still alive?
04:58:54 <MarTHiNUS> <dcoutts> before starting hugs --> oo thats mean.. cd to the specified directory then type hugs to run hugs ?
04:59:12 <dcoutts_> MarTHiNUS: yes
04:59:25 <dcoutts_> MarTHiNUS: even better, cd to the directory and say hugs Ex1.hs
04:59:34 <dcoutts_> so that it loads the module you want directly
05:01:55 <mux_> SamB: yes, they are kept alive with some life support device
05:02:08 <mux_> and they are like waken up every year to get a coffee and a biscuit :p
05:08:25 <mux_> > fix ((1:) . scanl (+) 1)
05:08:26 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
05:09:24 <mux_> > let fibs = fix ((1:) . scanl (+) 1) in length . show $ fibs !! 1000000
05:09:26 <lambdabot>  Exception: stack overflow
05:09:36 <profmakx> hm
05:09:40 <vincenz> > fibs 1000000
05:09:43 <lambdabot>  1953282128707757731632014947596256332443542996591873396953405194571625257887...
05:09:55 <Deewiant> > let fibs = fix ((1:) . scanl (+) 1) in if fibs !! 0 == 0 then "yay" else error "bad"
05:09:56 <lambdabot>  "Exception: bad
05:10:45 <mux_> though there is no definite starting values for the fibonacci sequence, most people start it with 1 and 1
05:11:16 <quicksilver> because the first season, one rabbit is born
05:11:21 <Deewiant> every place I've ever seen it defined it starts with zero :-)
05:11:22 <quicksilver> and the next season, still only one
05:11:34 <Deewiant> i.e. fib(0) == 0
05:11:53 <Deewiant> if you have zero rabbit pairs, none are born
05:12:08 <quicksilver> it's not a function from number of rabbit pairs
05:12:11 <quicksilver> it's a function from seasons
05:12:22 <quicksilver> fib(0) == 0 means "in the zeroth season, no rabbits are born"
05:12:29 <quicksilver> presumably because your seed pair are not yet mature
05:12:34 <Deewiant> right, good point
05:12:45 <quicksilver> mathematically you normally start it at 0 in my experience
05:12:48 <Deewiant> in the zeroth season, you have one pair of children
05:12:51 <quicksilver> but the rabbits would argue in favour of 1
05:13:08 <mux_> I thought using (1,1) as a starting point was more common, maybe not so
05:13:09 <Deewiant> heh
05:13:14 <mux_> but it doesn't matter much anyways
05:14:06 <quicksilver> it matters to the rabbits!
05:14:06 <Deewiant> > let fibs = fix ((0:) . scanl (+) 1) in fibs !! 100 :: Expr
05:14:07 <quicksilver> ;)
05:14:07 <lambdabot>  1 + 0 + 1 + (1 + 0) + (1 + 0 + 1) + (1 + 0 + 1 + (1 + 0)) + (1 + 0 + 1 + (1 ...
05:15:37 <mux_> poor rabbits :)
05:29:50 <childe> Hi. How to declare a Natural Number type that can only accept positive integers?
05:30:30 <matthew_-> data Nat = Zero | Succ Nat
05:31:25 <childe> Huh...then it would not be an easy job to write a 'show' function for this type, I suppose?
05:31:44 <matthew_-> well, it could convert to an int
05:32:06 <childe> How to do the conversion? Sorry I'm really new to Haskell (but I do like it).
05:32:11 <matthew_-> if you write fromInteger/toInteger (whatever) instances for it. I think
05:32:17 <ToRA> instance Show Nat where show = show . toInt ; toInt Zero = 0 ; toInt (Succ n) = 1 + (toInt n)
05:32:36 <childe> ToRA: Cool :-)
05:32:41 <matthew_-> my trusty side-kick shows up in time!
05:32:52 <ToRA> where ;'s need to turn into newlines and possibly a where clause, but you get the idea
05:33:49 <childe> Yeah, I do :-) Thank you very much! BTW where can I find some good Haskell exercises? The "99 Haskell Problems" are not focus on types, classes and monads.
05:34:11 <matthew_-> dunno, sorry. Have you tried YAHT?
05:34:13 <childe> I think I need to do some exercise to master this language.
05:34:15 <matthew_-> @where YAHT
05:34:15 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
05:34:25 <matthew_-> IIRC, there are exercises in that
05:34:50 <ToRA> you might find the haskell conversion of the ruby quiz helpful: http://www.haskell.org/haskellwiki/Haskell_Quiz, though i've not looked at in detail so I can't comment on how good the code quality is
05:34:51 <lambdabot> Title: Haskell Quiz - HaskellWiki
05:35:55 <childe> Hmmm...those quiz are just like the 99 problems, mostly about algorithms, not about types.
05:36:03 <ToRA> ah ok
05:36:06 <childe> I think types is a really cool thing about Haskell.
05:36:22 <matthew_-> you wont find disagreement here ;)
05:37:39 <quicksilver> and in particular, the cool thing about algorithms is that many of them are easier to write with the correct types directing you.
05:38:19 <childe> But I need to really know the types before doing them right.
05:38:46 <magthe> or even how the right type can allow you to "skip" things that obscure the algorithm (like proper error handling)
05:38:49 <childe> If I don't know what I can do with Haskell types, I can only write some C++ like code.
05:40:28 <childe> Sorry, have to go for supper...thank you everyone!
05:40:29 <magthe> childe: true to some extent, you don't need to know /everything/ about types (if that's even possible) to get started
05:42:49 <bringert> kosmikus: ping
05:45:20 <Japsu> > 8 * 60 * 60
05:45:20 <lambdabot>  28800
05:48:21 <bringert> kosmikus: I have a problem with lhs2TeX  1.13 not playing nice with \aligncolumn, see http://hpaste.org/7146
05:55:54 <dcoutts_> http://blog.well-typed.com/2008/04/the-dreaded-diamond-dependency-problem/
05:55:56 <lambdabot> Title: blog.well-typed.com » Blog Archive » The dreaded diamond dependency problem, http://tinyurl.com/6hbfwv
05:56:15 <dcoutts_> @seen jyp
05:56:16 <lambdabot> I haven't seen jyp.
06:00:11 <solrize> dcoutts_, to use haskell terminology, java uses some kind of (hash . reflection $ type (...)) to assign unique labels types, that survive across versions as long as the types don't change.  the java serialization stuff relies on that to get differing versions of programs to interoperate across networks exactly when the underlying objects haven't changed
06:00:18 <solrize> maybe that would help with this dependency stuff
06:00:35 <solrize> i was also thinking it would be nice for the data.binary instance deriving script to do something like that
06:03:36 <quicksilver> dcoutts_: fwiw, that problem exists in C libraries too
06:03:40 <quicksilver> dcoutts_: and it causes segfaults :)
06:03:57 <quicksilver> dcoutts_: debian package version dependencies are first-order only and ignore these second-order effects.
06:04:15 <quicksilver> dcoutts_: this caused massive pain when I was working for debian as people introduce more and more second-order libraries
06:04:20 <quicksilver> dcoutts_: like glib and so on.
06:04:37 <quicksilver> dcoutts_: of course, the most common second order library, libc, goes to some lengths to avoid the problem.
06:06:40 <pejo> dcoutts, what do you mean by garbage collecting packages?
06:09:11 <quicksilver> pejo: getting rid of particular package-version-compiles which are no longer depended on by any version
06:09:14 <quicksilver> of anything else
06:09:56 <quicksilver> I presume.
06:10:51 <pejo> quicksilver, yeah, I was more looking from the sysadmin pov. It sounds dangerous, and anyone doing large scale stuff probably values their systems never changing.
06:11:23 <quicksilver> pejo: I don't really see the conflict.
06:11:42 <quicksilver> pejo: do sysadmins like to have unused library packages compiled against 9-month old versions lying around un-needed?
06:12:01 <scook0> even if the system never uninstalls stuff of its own accord, it's helpful to have it prompt you with a list of stuff it thinks is useless
06:12:45 * solrize remembers the fury we had around here when ubuntu took the breezy distro packages off the net. saying it's no longer supporting it is one thing, but ripping down the repositories?
06:12:53 <Zao> Systems like Java RMI are rather brittle, requiring you to have complete control over the versions of all participating parties.
06:13:15 <quicksilver> solrize: different issue though I think
06:14:26 <pejo> quicksilver, discussing "unused" is like discussing "semantically dead". But sure, if something is truly unused and will remain that way forever it can be collected.
06:15:48 <pejo> Zao, du admar på acc?
06:19:28 <Zao> pejo: Admin-wannabe :)
06:21:24 <jberg> hmm, in the interpreter from emacs i cant use sort. says it cant find the function?
06:22:02 <quicksilver> :m Data.List
06:22:05 <quicksilver> @index sort
06:22:07 <lambdabot> Data.List
06:22:10 <quicksilver> @hoogle sort
06:22:12 <lambdabot> Data.List.sort :: Ord a => [a] -> [a]
06:22:12 <lambdabot> Data.ByteString.sort :: ByteString -> ByteString
06:22:12 <lambdabot> Data.ByteString.Char8.sort :: ByteString -> ByteString
06:22:20 <vincenz> > fibs . fibs $ 2
06:22:25 <lambdabot>  1
06:22:27 <vincenz> > fibs . fibs $ 3
06:22:29 <lambdabot>  1
06:22:33 <vincenz> > fibs . fibs $ 4
06:22:34 <jberg> ah ok. how can i import List?
06:22:35 <lambdabot>  2
06:22:37 <vincenz> > fibs . fibs $ 5
06:22:39 <lambdabot>  5
06:22:41 <vincenz> > fibs . fibs $ 6
06:22:42 <lambdabot>  21
06:22:43 <gnuvince> jberg: :m +Data.List
06:22:47 <jberg> thanks
06:22:48 <vincenz> > fibs . fibs . fibs . fibs $ 6
06:22:49 <lambdabot>  1695216512765707006912636688460460939847003870309508922628952074964839551507...
06:24:32 <jberg> > sortBy (>) [1,2,3]
06:24:33 <lambdabot>  Couldn't match expected type `Ordering'
06:24:45 <jberg> > is not in class Ordering?
06:24:45 <lambdabot>  Parse error at "in" (column 8)
06:24:52 <jberg> err
06:25:21 <quicksilver> > sortBy compare [1,2,3]
06:25:23 <lambdabot>  [1,2,3]
06:25:38 <quicksilver> jberg: (>) has type a -> a -> Bool, not a -> a -> Ordering
06:25:40 <jberg> :t compare
06:25:41 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
06:25:51 <jberg> okay
06:25:58 <quicksilver> you can of course derive it trivially
06:26:11 <quicksilver> compare x y == if x < y then LT else if x == y then EQ else GT
06:26:58 <scook0> @src filterM
06:26:59 <lambdabot> Source not found. Maybe if you used more than just two fingers...
06:27:22 <jberg> quicksilver: yes ok
06:27:54 <jberg> what if i want sortBy (compare . flip) [1,2,3]
06:28:31 <kosmikus> bringert: see annotation ...
06:29:38 <quicksilver> > sortBy (flip compare) [1,2,3]
06:29:39 <lambdabot>  [3,2,1]
06:29:43 <quicksilver> jberg: like that?
06:30:02 <jberg> yes :)
06:30:43 <quicksilver> jberg: dunno, then. No idea how to do that.
06:30:43 <quicksilver> :P
06:30:52 <jberg> doh
06:32:49 <vincenz> dcoutts_: so how would I keep the interface pure?
06:36:29 <dcoutts_> vincenz: interface to what?
06:36:37 * dcoutts_ is missing the context
06:37:07 <vincenz> dcoutts_: the Memo/Cache/LArray we spoke about earlier
06:37:53 <dcoutts_> vincenz: oh, so I was meaning a Cache where we actually unmemoise things according to some cache replacement algorithm
06:38:06 <vincenz> dcoutts_: oh right, I think that is a different problem
06:38:11 <dcoutts_> vincenz: that's obviously mutative underneath, but it can be pure on top
06:38:16 <vincenz> dcoutts_: I see a cache (which is more a hashmap) different from a sparse array
06:38:40 <vincenz> (different index-structure)
06:39:01 <dcoutts_> vincenz: by cache I really just mean a memo but with bounded storage and some replacement system
06:39:08 <dcoutts_> it could use any of the same data structures
06:39:14 <dcoutts_> it's an orthogonal issue
06:39:26 <vincenz> dcoutts_: Well, with a sequence you have more information about potential indices
06:39:35 <vincenz> you know that potentially they are contiguous
06:39:56 <dcoutts_> right, so you can choose a better data representation
06:40:10 <vincenz> Right, but this is not determined by the index type but by the usage-scenario
06:40:16 <vincenz> So I do think these are two different concepts
06:40:21 <dcoutts_> well, both
06:40:30 <vincenz> Not solely :)
06:40:55 <vincenz> I think we have two concepts: Cache/Memo vs LArray
06:41:03 <vincenz> In which case 'Cache' is a better name
06:42:47 <dcoutts_> Memo = Cache with an unbounded caching policy
06:42:54 * vincenz nods
06:43:28 <vincenz> My issue with that name is that you usually memoize in arrays, ini which case the LArray is a better choice (Due to extra knowledge about index-structure)
06:44:31 <dcoutts_> vincenz: any my point is that the underlying structure of the memo should depend on the index type (and the usage senario)
06:44:35 <dcoutts_> any/and
06:44:49 <dcoutts_> so yes, for int you'd use some array structure
06:45:04 <dcoutts_> if your indexes were dense
06:45:46 <vincenz> Even if they weren't dense I'd sttill work with a tree of arrays
06:45:57 <vincenz> You might have slightly more footprint, but determining where to go look in the tree is trivial
06:46:00 <vincenz> (and hence fast)
06:46:40 <vincenz> But again, this requires benchmarking
06:46:45 <vincenz> As most things :)
06:46:57 <vincenz> dcoutts_: what would you base the cache on? A Hashmap?
06:47:43 <dcoutts_> vincenz: depends on the index type :-)
06:47:55 <dcoutts_> any container with add and delete
06:48:16 <vincenz> GTrie :)
06:48:44 <vincenz> How would you guarantee atomic updates under the hood if the interface is pure?
06:48:55 <dcoutts_> locking
06:49:23 <vincenz> lock = unsafePerformIO createLock ?
06:49:34 <vincenz> {-# NOINLINE lock #-}
06:49:44 <dcoutts_> no, it's a lock per cache
06:49:49 <dcoutts_> no global vars
06:49:52 <vincenz> ah right
06:50:02 <dcoutts_> it's not the only way, but yes it'd be mutable underneath
06:50:13 <dcoutts_> so needs an unsafeSomthing to work
06:50:21 <vincenz> can you unsafely run STM?
06:50:27 <dcoutts_> no idea
06:50:41 <vincenz> I wonder how that works with references that are accessed in two separate unsafe's
06:51:08 <vincenz> @hoogle STM
06:51:09 <lambdabot> Control.Monad.STM :: module
06:51:09 <lambdabot> Control.Concurrent.STM :: module
06:51:09 <lambdabot> GHC.Conc.STM :: data STM a
06:51:15 <vincenz> @hoogle runSTM
06:51:16 <lambdabot> No matches found
06:51:33 <dcoutts_> vincenz: the replacement policy could even be time based, shrink caches after periods of lack of use
06:51:41 * vincenz nods
06:51:48 <Deewiant> "You cannot use atomically inside an unsafePerformIO or unsafeInterleaveIO. Any attempt to do so will result in a runtime error. (Reason: allowing this would effectively allow a transaction inside a transaction, depending on exactly when the thunk is evaluated.)"
06:51:50 <vincenz> and then a cache-policy-combinator system
06:51:55 <dcoutts_> right
06:52:05 <dcoutts_> sounds like a fun paper :-)
06:52:06 <vincenz> Deewiant: thanks
06:52:19 <vincenz> dcoutts_: yep :)
06:52:22 <dcoutts_> vincenz: just needs a killer application
06:52:23 <Deewiant> no problem
06:52:45 <dcoutts_> where we want to cache an expensive pure function
06:52:47 <vincenz> dcoutts_: cached web-app?
06:53:17 <dcoutts_> vincenz: they're usually based on some underlying mutating db state
06:53:41 <vincenz> well
06:53:48 <vincenz> you could change the cache system slightly
06:53:54 <vincenz> make it so you can add stuff
06:54:04 <vincenz> and then the consumption-generating-version would be a layer on top
06:54:52 <vincenz> although then it starts to look more like a weak-hash-map
06:55:06 <vincenz> (with a bit bigger longevity on entries)
06:55:26 <vincenz> dcoutts_: some recursive game-ai?
06:56:22 * dcoutts_ has no idea
06:57:02 <vincenz> dcoutts_: 'nother option is we write it and then ask for use-cases on ML
06:57:15 <dcoutts_> aye
07:02:59 <quicksilver> Linkedin freaks me out.
07:03:04 <quicksilver> It suggests that I may know Lemmih and conal.
07:03:10 <quicksilver> Which is true, in a manner of speaking.
07:03:13 <quicksilver> but how the hell did it know?
07:04:08 <ohub> :D
07:04:09 <tibbe> quicksilver: by looking at common friends?
07:04:12 <tibbe> ;)
07:04:18 <ohub> common friends?
07:04:37 <quicksilver> no, we have no common friends.
07:04:41 <quicksilver> not even 3rd degree.
07:04:43 <tibbe> if I add person X and another person adds person X we might now each other
07:04:47 <tibbe> hmm, ok
07:04:53 <quicksilver> there is nothing on my profile about haskell either
07:04:53 <tibbe> common interest?
07:04:56 <tibbe> attended the same event
07:05:00 <ohub> same workplace? :D
07:05:02 <tibbe> oh really?
07:05:10 <tibbe> magic
07:05:38 <quicksilver> phd in computer science, perhaps.
07:05:42 <Vq^> quicksilver: maybe it has an advanced haskell-detecting algorithm
07:05:48 <quicksilver> but there must be loads of people in linkedin with cs phds
07:06:10 * Lemmih doesn't have a PhD.
07:06:12 <vincenz> quicksilver: big brother
07:06:20 <quicksilver> yeah. Pretty scary if you ask me.
07:06:26 <quicksilver> Lemmih: maybe you know lots of people who do.
07:07:03 <Lemmih> quicksilver: Doctor by association? Neat.
07:07:18 <tromp> @src L.fibs
07:07:19 <lambdabot> Source not found. stty: unknown mode: doofus
07:07:25 <quicksilver> When I clicked on one of you (I forget which) it said "People who enjoyed this profile also enjoyed Igloo, andygill, bringert, SPJ....
07:07:29 <quicksilver> conal, it seems
07:07:46 <vincenz> tromp: oh that's mine
07:08:11 <vincenz> tromp: let fibs n = let arr = array (0, max 2 n) $ [(0,0), (1,1),  (2,1)] ++ [(i,e) | i <- [3..n], let i' = i `div` 2, let e =  (arr ! i') * (arr ! (i-i'-1)) + (arr ! (i'+1))*(arr ! (i-i'))]  in arr ! n
07:08:16 <tromp> lambdabot cant remember definitions?
07:09:11 <dcoutts_> @tell ndm for a reference point, see http://docs.camlcity.org/docs/index.html and http://blog.camlcity.org/blog/lambdarank.html
07:09:12 <lambdabot> Consider it noted.
07:09:47 <quicksilver> tromp: it's not that it can't.
07:09:52 <quicksilver> tromp: but that's not what @src is
07:09:58 <quicksilver> tromp: it's not actually the source of the real definitions.
07:10:09 <quicksilver> tromp: it's a manually produced hand-edited list, essentially.
07:11:05 <vincenz> \o/ for repetition
07:11:18 <saml> I have li :: [(Id, Val)]  how can I eliminate duplicate entries (by testing only Id's).  (Map.toList . Map.fromList) li    ok?
07:11:52 <quicksilver> saml: probably as good as anything.
07:11:59 <quicksilver> saml: why not use a map in the first place? :)
07:12:10 <tromp> :t Map.fromList
07:12:14 <lambdabot> Couldn't find qualified module.
07:12:23 <quicksilver> :t Data.Map.fromList
07:12:25 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
07:13:12 <saml> maybe i should refactor it with Map
07:15:20 <mib_2i4awnbd> Hi all, IÂ´m implenting a XML parser with HXT library. However, IÂ´m getting: couldnÂ´t match expected type (a -> m a) -> () -> IO () against inferred type IO [XmlTree]
07:15:48 <mib_2i4awnbd> any idea about this?
07:16:08 <Lemmih> ?paste
07:16:09 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:16:20 <mux_> @users
07:16:21 <lambdabot> Maximum users seen in #haskell: 460, currently: 420 (91.3%), active: 15 (3.6%)
07:17:41 <Lemmih> Our growth has stagnated.
07:18:05 <saml> > Data.Map.fromList [("X", 1), ("X", 2)]
07:18:06 <lambdabot>   Not in scope: `Data.Map.fromList'
07:18:24 <Deewiant> > M.fromList [("X", 1), ("X", 2)]
07:18:25 <lambdabot>  fromList [("X",2)]
07:18:28 <saml> i want the first ("X", 1) to be preserved
07:18:30 <mauke> > M.fromList [(x, 1), (x, 2)]
07:18:31 <lambdabot>  fromList [(x,2)]
07:18:39 <mauke> > M.fromList . reverse $ [(x, 1), (x, 2)]
07:18:40 <lambdabot>  fromList [(x,1)]
07:19:10 <saml> mauke: thanks
07:19:20 <quicksilver> there is also fromListWith
07:19:25 <quicksilver> which lets you choose how to handle it
07:19:28 <quicksilver> :t fromListWith
07:19:30 <lambdabot> Not in scope: `fromListWith'
07:19:36 <quicksilver> :t M.fromListWith
07:19:38 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> M.Map k a
07:19:45 <Deewiant> > M.fromListWith (flip const) [(x,1),(x,2)]
07:19:47 <lambdabot>  fromList [(x,1)]
07:19:51 <quicksilver> quite.
07:20:18 <quicksilver> > M.fromListWith (\x y -> y) [(x,1),(x,2)]
07:20:19 <Deewiant> for extra crypticness, replace "flip const" with "const id"
07:20:20 <lambdabot>  fromList [(x,1)]
07:20:33 <quicksilver> I generally prefer \x y -> y to flip const
07:20:40 <mauke> :t uncurry snd
07:20:41 <quicksilver> tells the story better, to my eyes
07:20:43 <lambdabot> forall a b c. ((a, b -> c), b) -> c
07:20:46 <mauke> :t curry snd
07:20:47 <lambdabot> forall a b. a -> b -> b
07:22:53 <saml> what's the semantics of M.fromListWith?  Build a map from a list of key/value pairs with a combining function ?? i can't comprehend this
07:23:05 <Deewiant> so if it gets the same key twice
07:23:06 <quicksilver> the combining function is used when the same key occurs more than once
07:23:11 <Deewiant> it calls the combining function to ask which value to use
07:23:13 <quicksilver> it combines the value
07:23:20 <Deewiant> or to compute a new value based on them
07:23:23 <saml> oh cool
07:23:56 <saml> > M.fromListWith (\x y -> y) [(x, 1), (x, 2), (y, 4), (x, 3)]
07:23:57 <lambdabot>  fromList [(x,1),(y,4)]
07:24:00 <quicksilver> > M.fromListWith (+) [(x,1),(x,2),(y,4)]
07:24:02 <lambdabot>  fromList [(x,3),(y,4)]
07:25:11 <saml> > let mapSums = M.fromListWith (+) in mapSums [(a,2), (a, 3), (b, 4), (b,54)]
07:25:12 <lambdabot>  fromList [(a,5),(b,58)]
07:27:04 <quicksilver> I wonder if the == instance for Expr is a good idea, really
07:27:14 <quicksilver> > x == y
07:27:16 <lambdabot>  False
07:27:23 <Deewiant> > x == x
07:27:24 <lambdabot>  True
07:27:26 <quicksilver> > x + y == y + x
07:27:27 <lambdabot>  False
07:27:38 <quicksilver> > 0 + 1 == (1 + 0 :: Expr)
07:27:39 <lambdabot>  True
07:27:43 <quicksilver> blink
07:27:43 <Deewiant> > x + (x + x) == (x + x) + x
07:27:45 <lambdabot>  False
07:28:11 <mauke> > x / 2 == x * 0.5
07:28:12 <lambdabot>  False
07:28:42 <ziman> Expr is an instance of Num?
07:28:50 <eugman|college> So, I'm going to be teaching one class on haskell and I am hoping to cover making a basic program and some of the unique things about haskell. I've started an outline I'm working on and was wondering if there was anything really important I missed. http://pastebin.com/d43adf542
07:29:41 <Deewiant> folds?
07:30:51 <PeakerWork> @src Expr
07:30:51 <lambdabot> Source not found.
07:31:02 <eugman|college> Oh yeah
07:31:02 <PeakerWork> > (1 == 1)::Expr
07:31:03 <lambdabot>  Couldn't match expected type `Expr' against inferred type `Bool'
07:31:21 <PeakerWork> what are Expr's useful for?
07:31:29 <Deewiant> > scanl (+) x [a,b,c]
07:31:30 <lambdabot>  [x,x + a,x + a + b,x + a + b + c]
07:31:31 <mauke> > foldr f z [a,b,c,d]
07:31:32 <lambdabot>  f a (f b (f c (f d z)))
07:31:32 <Deewiant> stuff like that
07:31:48 <Vq^> eugman|college: polymorphism?
07:33:55 <quicksilver> dcoutts_: why no comments on well-typed blog?
07:34:28 <vincenz> > scanl f z $ map (var . ('a':) . show) [0..]
07:34:31 <lambdabot>  [z,f z a0,f (f z a0) a1,f (f (f z a0) a1) a2,f (f (f (f z a0) a1) a2) a3,f (...
07:35:53 <Arnar_> @pl `f` x
07:35:53 <lambdabot> (line 1, column 1):
07:35:53 <lambdabot> unexpected "`"
07:35:54 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
07:36:24 <Deewiant> @unpl (`f` x)
07:36:25 <lambdabot> (\ a -> f a x)
07:36:44 <Arnar_> @unpl (flip f)
07:36:44 <lambdabot> (\ b c -> f c b)
07:36:52 <Arnar_> @unpl (flip f x)
07:36:52 <lambdabot> (\ c -> f c x)
07:37:01 <Arnar_> ok, thx
07:38:36 <Arnar_> so pointless/pointfree is referring to the "point" in lambda calculus?
07:39:15 <sieni> no, the parameters of the lambda
07:39:35 <Arnar_> ah, ok
07:40:01 <sieni> if you think a mathematical function, quite often they operate on points, e.g. functions defined on the real line
07:40:10 <Arnar_> sieni: right..
07:40:20 <sieni> so then the lambda expression explicitly tells you, what you are doing with your "points"
07:41:05 <Arnar_> @pl (\ a b -> f b a)
07:41:06 <lambdabot> flip f
07:41:39 <sieni> but, gotta go ->
07:42:19 <PeakerWork> it seems that Expr is limited to stuff that's class-y rather than type-y (== cannot generate an Expr, right?)
07:44:15 <Corun> ARGH, this is annoying me. Would anyone care to help: With natural deduction, prove: Â¬âx[p(x)] entails âx[Â¬p(x)]
07:44:29 <Corun> It should be so simple, but I just can't see it.
07:44:58 <pejo> Peaker, have you seen the blog posts about it?
07:45:06 <PeakerWork> pejo, nope, where?
07:45:21 <pejo> Peaker, http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details and http://augustss.blogspot.com/
07:45:24 <lambdabot> Title: Simple reflection of expressions - 21 thoughts, http://tinyurl.com/2yeszc
07:45:34 <PeakerWork> Will read
07:45:53 <pejo> The rest of augustss blog is definitely worth a read too, lots of interesting fp hacking.
07:49:46 <Duddle> hello everybody! I'm practicing haskell with custom data types, i.e. binary trees:  data Tree = Node Int Tree Tree | NIL
07:50:08 <dcoutts_> quicksilver: WordPress blogs get totally totally spammed if you allow comments
07:50:19 <dcoutts_> quicksilver: it's just not worth it
07:50:21 <Duddle> I have some functions (insert, etc). but how can I print out my custom datatype
07:51:04 <dcoutts_> quicksilver: but you can use trackbacks/pingacks I think, or email to mailing lists or irc :-)
07:51:04 <Duddle> if I had Int or String or whatever, I could use "show", but not with my custom type... I basically want to debug
07:51:19 <mauke> Duddle: data Tree = ... deriving (Show)
07:51:46 <Duddle> nice, thanks :)
07:55:36 <quicksilver> dcoutts_: *nod* not important, I was just curious.
07:55:58 <dcoutts_> quicksilver: did you have any comments? :-)
07:56:17 <quicksilver> dcoutts_: I was hoping someone else would comment on the preorder of the book
07:56:24 <quicksilver> dcoutts_: like tell me if amazon was the right place to order
07:56:30 <quicksilver> dcoutts_: cos I asked dons but he never answered :)
07:56:52 <dcoutts_> quicksilver: yeah, I asked dons and bos but neither came up with anything so I plumped for amazon
07:58:55 <Arnar_> you guys know when the planned publishing date is?
08:05:21 <magthe> dcoutts_: I've found akismet + moderated commenting to be an acceptable solution on WP
08:05:53 <magthe> the weeks when I attract more than 20 spam comments that make it through akismet are few
08:08:44 <Bonus> hmm
08:08:46 <Bonus> what does ! do
08:09:10 <mauke> strictness annotation, array indexing
08:09:16 <Bonus> aha
08:09:23 <vincenz> emphasizing of a sentence
08:09:33 <Bonus> haha
08:10:00 <mauke> dereferencing in OCaml
08:10:04 <[1]eugman|colleg> The more you use the more effective they are!!!!!
08:10:30 <Bonus> does anyone know when ubuntu 8.04 is coming out
08:10:41 <mauke> impressiveâ¼â¼â¼
08:10:54 <vincenz> ZOMG!!!!!!!
08:11:03 <mauke> ï¼
08:11:08 * vincenz wonders what the 'Z' stands for
08:11:12 <saml> > let eliminate id = filter (\x -> x /= id); el (x:xs) l = el xs (eliminate x l); el [] l = l; in el ['a', 'b'] "abac"
08:11:14 <lambdabot>  "c"
08:11:19 <idnar> Bonus: isn't it out?
08:11:22 <saml> is there a better way to do this?
08:11:42 <Bonus> on the site it says  coming soon
08:11:45 <Bonus> ahah oh no wait
08:11:46 <mauke> > filter (`notElem` "ab") "abac"
08:11:47 <lambdabot>  "c"
08:11:50 <Bonus> check it out www.ubuntu.com
08:12:14 <Bonus> Service Temporarily Unavailable
08:12:15 <saml> thanks mauke
08:12:32 <Bonus> oh yeah its out
08:12:32 <Bonus> w00
08:12:35 <Bonus> t
08:17:58 <tromp> > "abac" \\ "ab"
08:18:00 <lambdabot>  "ac"
08:18:16 <PeakerWork> @src (\\)
08:18:16 <lambdabot> (\\) = foldl (flip delete)
08:18:27 <tromp> :t delete
08:18:29 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
08:19:06 <tromp> > delete 'a' "aa"
08:19:07 <lambdabot>  "a"
08:19:19 <saml> let x1 = e1; x2 = e2; ... xN = eN in expr  <===> let x1 = e1 in let x2 = e2 in ... let xN = eN in expr   ??
08:19:38 <mauke> saml: no, you can have mutually recursive bindings in a single let
08:20:32 <saml> if I don't allow recursive bindings, can I claim above?
08:20:36 <tromp> > let a = 'a':b; b = 'b':a in a
08:20:37 <lambdabot>  "abababababababababababababababababababababababababababababababababababababa...
08:20:42 <mauke> I think so
08:20:57 <saml> and eJ can't have xI  where I < J
08:21:00 <tromp> > let a = 'a':b in let  b = 'b':a in a
08:21:01 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Expr'
08:21:31 <mapreduce> @hoogle Integer -> Double
08:21:33 <lambdabot> No matches, try a more general search
08:21:48 <mapreduce> @t fromIntegral
08:21:48 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
08:21:56 <mapreduce> :t fromIntegral
08:21:58 <lambdabot> forall a b. (Num b, Integral a) => a -> b
08:22:17 <mapreduce> @djinn Integer -> Double
08:22:17 <lambdabot> -- f cannot be realized.
08:27:33 <bringert> kosmikus: thanks!
08:30:38 <dmead> haskellers
08:30:49 <dmead> i can compile ghc in under an hour
08:30:52 <dmead> with mah quad core
08:31:28 <Saizan_> try JHC then
08:32:42 <bringert> dmead: I can compile ghc in under 8 min, with mah build.mk
08:32:51 <quicksilver> ISTR, someone (dcoutts?) had access to a machine which could compile it in 15 minutes.
08:32:52 <dmead> o rly
08:32:55 <saml> how can I foldl  a list with (a -> b -> a) function?
08:33:01 <bringert> dmead: see http://hackage.haskell.org/trac/ghc/wiki/Building/Hacking#HowtomakeGHCbuildquickly
08:33:05 <quicksilver> :t foldl
08:33:06 <lambdabot> http://tinyurl.com/y567ol
08:33:07 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
08:33:22 <quicksilver> saml: not sure I understand your question? that's exactly what foldl does...
08:33:30 <bringert> dmead: you probably don't want to use that unless you are hacking on GHC though
08:33:45 <saml> w00t! hah thanks. i was confused with foldl1. i think simple foldl would work
08:33:46 <Lemmih> Saizan_: JHC should only take a few minutes to build.
08:34:28 <dmead> hmm
08:34:33 <dmead> i'll have to time my build time at home
08:34:40 <dmead> i'm pretty sure it's well under an hour
08:34:43 <dmead> like 20 min
08:34:54 <dmead>  i just got a Q6600
08:34:58 <saml> oh no I have   f :: a -> b -> b
08:35:09 <conal> saml: flip
08:35:26 <quicksilver> foldl (flip (:)) [] [1,2,3]
08:35:28 <quicksilver> > foldl (flip (:)) [] [1,2,3]
08:35:30 <lambdabot>  [3,2,1]
08:36:36 <bringert> dmead: that sounds reasonable, if you used -j8 or something
08:36:44 <dmead> -5
08:36:47 <dmead> -j5
08:36:59 <dmead> yea
08:37:24 <bringert> if you have a quad core, -j8 may be even faster
08:37:27 <tromp> > foldr (:) [] "doesn't do much"
08:37:28 <lambdabot>  "doesn't do much"
08:37:30 <dmead> as i understand it giving it more than you're number of cores +1 is useuless
08:37:47 <dmead> otherwise you're just going to start paging and it'll take just as long
08:37:49 <bringert> depends on the cpu/io behavior of the compiles
08:37:54 <bringert> and memory usage
08:37:58 <dmead> ya i suppose
08:38:16 <bringert> if each process uses just a little memory or you have lots of ram, you won't have paging
08:38:20 <dmead> does anyone know why the haskell-mode ebuild is busted?
08:38:27 <dmead> hmm
08:38:29 <dmead> i have 2 gigs
08:38:34 <bringert> if everything is very cpu intensive, -j4 should be the best
08:38:57 <dmead> well with -j4 i can keep playing games or whatever
08:39:04 <dmead> and still compile whatever in the background
08:39:08 <bringert> if there is lots of io, having a large number of processes means that there is often one that can run when the others are blocked
08:41:18 <saml> yay!  foldr (Let . (:[])) expr keyValueList  -- turns let x1=e1, x2=e2... in expr ==> let x1=e1 in let x2=e2...
08:51:53 <vincenz> joricj: hey
08:52:01 <vincenz> joricj: ik wist niet dat jij van de kul was :)
08:54:09 <vincenz> joricj: nevermind, I confused your name with 'jorpic', the guy that left a comment on my blog
08:57:37 <audreyt> @google <$$>
08:57:41 <audreyt> @hoogle <$$>
08:57:41 <lambdabot> No Result Found.
08:57:42 <lambdabot> Text.ParserCombinators.Parsec.Perm.(<$$>) :: (a -> b) -> GenParser tok st a -> PermParser tok st b
08:58:06 <audreyt> hm. I wonder why there's no
08:58:06 <audreyt> (<$$>) :: Functor f => f a -> (a -> b) -> f b
08:58:07 <audreyt> (<$$>) = flip (<$>)
08:58:19 <audreyt> probably the same argument about normal function application order
08:58:28 <audreyt> but then there's "for" and "forM" already.
08:59:41 <sphynx-> hi!
09:00:55 <sphynx-> Is there some easy way to apply function to the list of monadic values? I need something like 'and [Just True, Just False]'
09:01:36 <conal> sphynx-: fmap.fmap
09:02:08 <Syzygy-> > fmap.fmap and [Just True, Just False]
09:02:11 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `Bool'
09:02:15 <Syzygy-> Tsk
09:02:16 <conal> oh: and
09:02:55 <Cale> > map (fmap not) [Just True, Just False]
09:02:57 <lambdabot>  [Just False,Just True]
09:03:16 <Syzygy-> > fmap.fmap not [Just True, Just False]
09:03:18 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `Bool'
09:03:23 <conal> > (fmap.fmap) not [Just True, Just False]
09:03:24 <lambdabot>  [Just False,Just True]
09:03:28 <Deewiant> > foldM (fmap.(&&)) True [Just True, Just False]
09:03:28 <Syzygy-> There we go.
09:03:31 <lambdabot>  Just False
09:03:35 <conal> (generalization of the (.).(.) trick)
09:03:40 <Cale> > sequence [Just True, Just False]
09:03:41 <lambdabot>  Just [True,False]
09:03:49 <Cale> > fmap and $ sequence [Just True, Just False]
09:03:50 <lambdabot>  Just False
09:04:14 <Syzygy-> :t sequence
09:04:15 <sphynx-> @src sequence
09:04:16 <lambdabot> sequence []     = return []
09:04:16 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
09:04:16 <lambdabot> --OR
09:04:16 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
09:04:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
09:04:33 <audreyt>  > fmap and $ sequence [Just True, Nothing, Just False]
09:04:39 <audreyt> > fmap and $ sequence [Just True, Nothing, Just False]
09:04:42 <lambdabot>  Nothing
09:04:49 <audreyt> is Nothing what you want? :)
09:05:09 <Syzygy-> I don't suppose that there is anything like sequence but for two "random" monads? Something that would be Monad m,n => m (n a) -> n (m a)
09:05:10 <sphynx-> I don't need Maybe monad at all :)
09:05:15 <sphynx-> It was just an example
09:05:39 <audreyt> ah k.
09:05:45 <quicksilver> Syzygy-: most monads don't commute in that way.
09:05:49 <Cale> Syzygy-: That's called a distributive law (if it satisfies a few additional axioms)
09:06:04 <Cale> Syzygy-: It doesn't generally exist, but in specific cases it does.
09:06:09 <quicksilver> :t traverse
09:06:11 <lambdabot> Not in scope: `traverse'
09:06:16 <quicksilver> :t T.traverse
09:06:18 <lambdabot> Couldn't find qualified module.
09:06:27 <quicksilver> :t Data.Traversable.traverse
09:06:29 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Applicative f, Data.Traversable.Traversable t) => (a -> f b) -> t a -> f (t b)
09:06:32 <Syzygy-> Cale: And the point of the MonadT special types are to do just that, right?
09:06:37 <quicksilver> hmm. that's not what I meant.
09:07:10 <Cale> Syzygy-: Some monad transformers can be considered secret distributive laws, others can't.
09:07:19 <Syzygy-> Ah
09:07:50 <quicksilver> :t Data.Traversable.sequence
09:07:51 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Monad m, Data.Traversable.Traversable t) => t (m a) -> m (t a)
09:07:56 <quicksilver> Syzygy-: there.
09:08:07 <quicksilver> Syzygy-: if your outer monad is a traversable, you can do it.
09:08:17 <quicksilver> traversables distribute over all other monads.
09:08:22 <Cale> But yeah, if you have a distributive law for distributing m over n, you can turn n composed with m into a monad.
09:08:22 <quicksilver> as a particular interesting special case.
09:08:40 <sphynx-> well thank you  all for the help! :)
09:09:03 <Syzygy-> Is every traversable a monad?
09:09:04 <Cale> However, I'm a bit uncertain about whether those will satisfy the laws they'd need to in order to form a monad.
09:09:19 <Cale> Not necessarily.
09:10:23 <Cale> Let me just translate the axioms...
09:11:10 <Cale> join . fmap dist . dist = dist . fmap join
09:11:40 <Cale> fmap join . dist . fmap dist = dist . join
09:11:51 <bugQ> ?pl join . fmap dist . dist
09:11:52 <lambdabot> (dist =<<) . dist
09:11:59 <bugQ> ?pl fmap join . dist . fmap dist
09:12:00 <lambdabot> fmap join . dist . fmap dist
09:12:09 <Cale> dist . fmap return = return
09:12:21 <Cale> dist . return = fmap return
09:12:35 <Cale> http://en.wikipedia.org/wiki/Distributive_law_between_monads
09:12:52 <Cale> (those state them in a somewhat different way which I'm translating from :)
09:15:00 <quicksilver> Syzygy-: no. But typically they are.
09:15:24 <quicksilver> Syzygy-: you normally just need to work out what 'concat' means
09:15:52 <quicksilver> Syzygy-: so Tree (Tree a) -> Tree a attaches the subtrees at the leaves
09:15:53 <quicksilver> etc
09:16:06 <quicksilver> so most traversables do turn out to be monads.
09:16:07 <Cale> But yeah, if you have a dist :: M (N a) -> N (M a) which satisfies those laws above, then you can define  join :: N (M (N (M a))) -> N (M a) by  fmap join . join . fmap dist
09:16:52 <Cale> and return and fmap are fairly obvious
09:17:07 <Cale> and that'll give you a new monad which satisfies the monad axioms
09:18:52 <Cale> quicksilver: But I wonder how many traversables are monads in such a way that  sequence  is a valid distributive law.
09:19:18 <Saizan_> has anyone compared this way of composing monads vs. monad transformers?
09:20:38 <Cale> Well, monad transformers are more general. There are ways to transform monads which don't correspond to composing them with others. I'm fairly certain that StateT doesn't correspond to a composite like this.
09:20:55 <quicksilver> Cale: I think if they represent, essentially, "collections of objects arranged in a shape"
09:21:03 <quicksilver> then they distribute nicely.
09:21:47 <Cale> quicksilver: I'm not even certain that the list monad distributes so nicely (if it does, why don't we have a proper ListT!)
09:21:49 <Syzygy-> Right
09:24:23 <gwern> @seen nomeata
09:24:23 <lambdabot> I saw nomeata leaving #darcs, #xmonad and #haskell 17h 56m 7s ago, and .
09:24:31 <b_pow> hey guys i am trying to use foldr to create a accumulate function that adds the tail of the list to the rest of the list sp accumulate [3,2,1] [6,3,1]
09:24:53 <gwern> @tell nomeata I don't have hosting, so there is no darcs repo with my cabalization patches
09:24:54 <lambdabot> Consider it noted.
09:25:50 <Cale> b_pow: So, it's equivalent to  accumulate (x:xs) = (x + sum xs) : xs ?
09:26:10 <Deewiant> Cale: : accumulate xs
09:26:12 <Cale> er...
09:26:19 <Cale> yeah
09:26:26 <Cale> [6,3,1] not [6,2,1] :)
09:27:17 <b_pow> 3+2+1 2+1, 1
09:27:58 <Cale> > scanr (+) 0 [3,2,1]
09:27:59 <lambdabot>  [6,3,1,0]
09:28:04 <Cale> > scanr1 (+) [3,2,1]
09:28:05 <lambdabot>  [6,3,1]
09:28:13 <dcoutts_> magthe: I uses to use askimet + moderation with the gtk2hs WP but in then end I switched off comments completely, it was too annoying
09:28:26 <b_pow> using foldr
09:28:27 <bugQ> Cale: he did say [6,3,1].
09:28:41 <mrd> ?oeis 1 1 2 1 3 2 3 1 4 3 5
09:28:42 <lambdabot> Stern's diatomic series: a(0) = 0, a(1) = 1; for n >= 0, a(2n) = a(n), a(2n+1...
09:28:42 <lambdabot> [0,1,1,2,1,3,2,3,1,4,3,5,2,5,3,4,1,5,4,7,3,8,5,7,2,7,5,8,3,7,4,5,1,6,5,9,4,11...
09:29:06 <quicksilver> starts to sounds like a homework question to me :)
09:30:29 <b_pow> thanks
09:30:44 <orzo> I want to put a hashtable into a Dynamic
09:30:46 <byorgey> mrd: that's one of my favorite sequences. =)
09:30:56 <orzo> there is no instance of Typeable2 for Hashtables
09:31:05 <mrd> heh
09:31:14 <orzo> Is difficult ot add one?
09:31:31 <orzo> how do i do it
09:31:39 <orzo> TypeRep doesn't seem to be documented
09:31:43 <orzo> very much
09:33:55 <wjt> bah.  the cabal in Sid's ghc6 package seems not to support data-files.  Is there some way short of replacing cabal from underneath the ghc6 package to include files in dist/... ?
09:34:13 <dcoutts_> wjt: adding a new version of cabal is no problem
09:34:22 <dcoutts_> you can have as many different versions as you like
09:34:22 <wjt> oh, it can be installed alongside the installed version?
09:34:27 <dcoutts_> yes
09:34:31 <dcoutts_> per-user or globally
09:34:39 <wjt> nice! *goes to do that*
09:36:55 <quicksilver> orzo: try standalone deriving it.
09:37:03 <quicksilver> orzo: (but do you really want hashtables? they sawk :P)
09:39:27 <magthe> dcoutts_: yes, it all depends on how much traffic on attracts I guess... do you allow pingbacks still?
09:39:44 <dcoutts_> magthe: for the company blog, yes.
09:40:29 <magthe> I've been considering turning off comments as well, but I want pingbacks
09:41:08 <magthe> I think it was Joel Sopolsky who wrote about turning off (anonymous) comments... "if you want to comment, then start your own blog"
09:41:20 <opqdonut> :)
09:41:31 <quicksilver> ;)
09:41:44 <quicksilver> I don't want to start my own blog, for fear of anonymous comments, though
09:43:16 <dcoutts_> quicksilver: :-)
09:43:47 <magthe> quicksilver: haha
09:44:33 <vincenz> What are pingbacks
09:45:10 <wjt> dcoutts_: hrm, but having done so, even if I use `ghc -package Cabal-1.2.3.0 --make Setup.lhs -o setup`, the data-files field is not recognised.  there's no older Cabal *package* listed in ghc-pkg list; am I out of luck?
09:45:17 <magthe> so far I've only gotten excellent comments, none that are anonymous, so I have comments enabled until I write something controversial and I get abused in words... and as I said, the spam is at a manageable level
09:45:26 <Tordek> vincenz: when someone makes a post linking to yours and lets you know
09:46:01 <vincenz> magthe: ditto, but then again my blog isn't that highly traffickced :)
09:46:07 <magthe> vincenz: the comment on this post is a pingback: http://therning.org/magnus/archives/344
09:46:16 <dcoutts_> wjt: are you sure you're using the data-files field right? it goes in the global section, not in the library or executable section
09:46:50 <vincenz> magthe: how does that work?
09:46:51 <magthe> vincenz: yeah, I was worried that being included on Planet Haskell would change things, but I've only seen "good traffic" coming my way so far
09:46:58 <wjt> dcoutts_: doh, you're right.  thanks!
09:47:25 <dcoutts_> wjt: but you wanted to upgrade Cabal anyway so it's ok :-)
09:47:32 <wjt> heh
09:48:03 <dcoutts_> wjt: it's a feature request actually to move the data-files into the per-lib/exe sections
09:48:09 <dcoutts_> there's an open bug on it
09:48:16 <magthe> vincenz: AFAIU WP will go off and inform the blog that I link to (there's some well-defined(?) interface for it) and it all results in a comment on the receiver's blog
09:48:46 <magthe> don't know the exact details though
09:50:18 <vincenz> magthe: net
09:50:22 <vincenz> s/net/neat
09:53:51 <magthe> vincenz: yes, I think so too... though not all blogs seem to support it (e.g. Neil Mitchell's doesn't)
09:56:20 <vincenz> magthe: you should write about my splendid blog, that way you can test whether my blog supports it ;)
09:57:27 <magthe> vincenz: or you can write about mine ;)
09:57:33 <magthe> what's the URL of yours?
09:57:58 <vincenz> http://notvincenz.blogspot.com
09:57:59 <lambdabot> Title: lambda.oasis
09:58:45 <IsoPallo> How this reminds me of my university time... "if you refer mine I'll refer yours"
09:58:53 <eugman|college> are any of the xml libraries included by default?
10:03:42 <IsoPallo> I have another stupid question... Now that I learned about arrows can I simply just forget about monad transformers? Since any monad automatically just jumps into an arrow and then I can combine different monads like I wish?
10:04:23 <dcoutts_> eugman|college: no but they're easy to install, even if they're not packaged for your distro
10:04:35 <dcoutts_> IsoPallo: I don't think it's quite that simple
10:04:48 <glguy> IsoPallo: Monad transformers are much more practical than arrows, so don't forget about them
10:05:03 <glguy> IsoPallo: you aren't likely to see arrow code in the wild
10:07:09 <Jaak> arrows are way too general... in general
10:07:30 <Jaak> arrows is just a category with some extra stuff
10:07:39 <Jaak> arrow*
10:07:42 <eugman|college> One other thing, if I compile a binary and it works on my linux comp should it work on a different linux comp even if haskell isn't installed?
10:08:10 <Jaak> not in general
10:08:20 <mrd> > fix $ \ a -> 1:concat [ [ a!!((n-1)`div`2), a!!((n-1)`div`2)+a!!(((n-1)`div`2)+1)] | n <- [1,3..] ]
10:08:22 <lambdabot>  [1,1,2,1,3,2,3,1,4,3,5,2,5,3,4,1,5,4,7,3,8,5,7,2,7,5,8,3,7,4,5,1,6,5,9,4,11,...
10:09:04 <IsoPallo> eugman: It might, but in general you shouldn't be tempted ty try.
10:09:09 <Jaak> eugman|college: endianness and machine word size may screw things up
10:09:58 <IsoPallo> And installed library version and a millon other things.
10:10:12 <Jaak> mhmhh
10:10:24 <magthe> eugman|college: if you look at the output from ldd on a Haskell bin you'll see that there aren't many required libs (at least not until we have .so support in GHC)
10:10:43 <magthe> so moving a binary from say a Debian/386 to a Fedore/386 should be painless
10:11:20 <Jaak> yeah, it might work but don't bet your money on this
10:12:03 <tromp> @let collatz n | even n = n `div` 2; | otherwise = (3*n+1) `div` 2
10:12:04 * magthe is leaving work
10:12:04 <lambdabot>  Parse error
10:12:22 <mrd> no ;
10:12:29 <tromp> @let collatz n =if even n then n `div` 2 else (3*n+1) `div` 2
10:12:33 <lambdabot> Defined.
10:12:44 <tromp> > iterate collatz 7
10:12:44 <vincenz> tromp: like the fibs?
10:12:46 <lambdabot>  [7,11,17,26,13,20,10,5,8,4,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
10:12:53 <mrd> @let collatz n | even n = n `div` 2 | otherwise = (3*n+1) `div` 2
10:12:54 <lambdabot> <local>:2:0:     Warning: Pattern match(es) are overlapped              In th...
10:12:58 <mrd> @undef
10:12:59 <mrd> @let collatz n | even n = n `div` 2 | otherwise = (3*n+1) `div` 2
10:12:59 <lambdabot> Undefined.
10:13:00 <lambdabot> Defined.
10:13:01 <vincenz> noooo
10:13:04 <vincenz> mrd: you cleared my fibs
10:13:16 <dons> yay, Word# literals
10:13:19 <vincenz> @let fibs n = let arr = array (0, max 2 n) $ [(0,0), (1,1),  (2,1)] ++ [(i,e) | i <- [3..n], let i' = i `div` 2, let e =  (arr ! i') * (arr ! (i-i'-1)) + (arr ! (i'+1))*(arr ! (i-i'))]  in arr ! n
10:13:20 <lambdabot> Defined.
10:13:20 <dons> Igloo++
10:13:22 <IsoPallo> eugman: Ofcourse if you know the target system, you can cross-compile to that. It just needs some work.
10:13:41 <vincenz> mrd, tromp: you need a case for  1
10:13:49 <vincenz> dons: what do they look like?
10:13:57 <tromp> 1 will happily cycle
10:13:57 <adiM> Is there a function which gives all possible combinations of two lists, combine [1,2,3] [4,5,6] should give [(1,4), (1,5), (1,6), (2,4), (2,5), (2,6), (3,4), (3,5), (3,6)] ?
10:14:05 <dons> 123##
10:14:07 <vincenz> adiM: yes
10:14:16 <mrd> > sequence [[1,2,3],[4,5,6]]
10:14:17 <lambdabot>  [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
10:14:27 <vincenz> > return (,) `ap` [1..3] `ap` [4..6]
10:14:28 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
10:14:36 <adiM> thans vincenz
10:14:38 <mrd> list monad
10:14:52 <vincenz> dons: why not simply the 'fromInteger' bit?
10:14:57 <awesame> so I've been reading the haskell-prime list, and I'm curious why people want ($) to be left-associative
10:15:00 <vincenz> dons: Word# is not Num?
10:15:12 <tromp> @let collength n = length (takeWhile (>1) (iterate collatz n))
10:15:14 <lambdabot> Defined.
10:15:17 <Jaak> > let combine xs ys = [(x, y) | x <- xs, y <- ys] in combine [1,2,3] [4,5,6]
10:15:18 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
10:15:23 <tromp> > collength 7
10:15:24 <lambdabot>  11
10:15:31 <vincenz> > collength 43
10:15:32 <lambdabot>  20
10:15:37 <tromp> > map collength [1..]
10:15:39 <lambdabot>  [0,1,5,2,4,6,11,3,13,5,10,7,7,12,12,4,9,14,14,6,6,11,11,8,16,8,70,13,13,13,6...
10:15:50 <adiM> thanks jaak
10:16:06 <vincenz> > maximumBy (compare `on` fst) $ map (id &&& collength) [1..100]
10:16:07 <lambdabot>  (100,18)
10:16:07 <dons> vincenz: Word# is not of kind *
10:16:17 <vincenz> dons: ah
10:16:26 <vincenz> > maximumBy (compare `on` snd) $ map (id &&& collength) [1..100]
10:16:27 <lambdabot>  (97,75)
10:16:38 <tromp> > map collength [21..]
10:16:40 <lambdabot>  [6,11,11,8,16,8,70,13,13,13,67,5,18,10,10,15,15,15,23,7,69,7,20,12,12,12,66,...
10:16:43 <vincenz> > maximumBy (compare `on` snd) $ map (id &&& collength) [1..10000]
10:16:45 <lambdabot>  (6171,165)
10:17:30 <tromp> > collength 165
10:17:32 <lambdabot>  71
10:17:42 <tromp> > collength 6171
10:17:43 <lambdabot>  165
10:18:09 <tromp> > collength 27
10:18:11 <lambdabot>  70
10:18:14 <gwern> @hoogle String -> IO String
10:18:14 <abrasive> i don't suppose there's anyone around with experience... bootstrapping ghc? :S
10:18:15 <lambdabot> System.Environment.getEnv :: String -> IO String
10:18:23 <tromp> > iterate collatz 27
10:18:24 <lambdabot>  [27,41,62,31,47,71,107,161,242,121,182,91,137,206,103,155,233,350,175,263,39...
10:18:40 <vincenz> > collatz 27
10:18:41 <lambdabot>  41
10:18:56 <mrd> > drop 100 $ collatz 27
10:18:57 <lambdabot>   add an instance declaration for (Integral [a])
10:19:04 <mrd> > drop 100 $ iterate collatz 27
10:19:05 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
10:19:14 <IsoPallo> abrasive: Hmm... What do you want to do?
10:19:14 <tromp> it's only 70 long
10:19:23 <vincenz> > maximumBy (compare `on` fst) $ map (id &&& collength) [1..1000000]
10:19:25 <lambdabot>  (1000000,101)
10:19:32 <vincenz> > maximumBy (compare `on` snd) $ map (id &&& collength) [1..1000000]
10:19:38 <lambdabot>  Exception: Time limit exceeded
10:19:42 <vincenz> > maximumBy (compare `on` snd) $ map (id &&& collength) [1..100000]
10:19:44 <lambdabot>  (77031,221)
10:19:51 <gwern> I want to run 'darcs changes | cat config.command' and get the stdout of it as a String (IO or otherwise); what's the simplest way to do this?
10:20:44 <dcoutts_> gwern: use dons's popen code or copy the equivalent from the cabal code
10:21:14 <gwern> dcoutts_: does cabal export the equivalent? that'd be good
10:21:23 <Jaak> > collength 1355036
10:21:24 <lambdabot>  60
10:21:31 <dcoutts_> gwern: yeah, but you don't want to depend on cabal just for that
10:21:40 <Jaak> uh
10:21:44 <dons> dcoutts_: got the unboxed vectors beating STUArrays on bit sieve :)
10:21:55 <dcoutts_> dons: nice
10:22:00 <gwern> dcoutts_: well, what's the function name?
10:22:04 <dcoutts_> dons: with or without fusion stuff?
10:22:18 <dons> without. just the low level mutable arrays (read/write)
10:22:24 <adiM> @pl prepend str values = unwords $ map ((str ++). show) values
10:22:24 <lambdabot> prepend = (unwords .) . map . (. show) . (++)
10:22:29 <dons> the pure streams on top ... we'll see.
10:22:40 <dons> pretty hard to write the prime sieve as a stream, actually
10:22:45 <dcoutts_> gwern: Distribution.Simple.Utils.rawSystemStdout :: Verbosity -> FilePath -> [String] -> IO String
10:22:52 <dcoutts_> dons: right
10:22:53 <Jaak> > collength 135451
10:22:53 <lambdabot>  95
10:23:19 <vincenz> > collength 123456789
10:23:21 <lambdabot>  119
10:23:31 * gwern noes that I was searching for String -> IO String; no wonder neither grep nor cabal turned that up
10:23:34 <Jaak> oh, right. i have forgat my own code
10:23:42 <vincenz> > iterate collength 10000
10:23:43 <lambdabot>  [10000,23,11,10,5,4,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
10:23:44 <dons> readProcess might make more sense
10:24:05 <dcoutts_> gwern: oh yes, that's calling a specific process, not a shell command
10:24:12 <gwern> dcoutts_: I note there's two definitions?
10:24:23 <gwern> oh. darn then
10:24:53 <mrd> > iterate collength 1000
10:24:54 <lambdabot>  [1000,72,16,4,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
10:24:59 <dons> http://www.cse.unsw.edu.au/~dons/code/newpopen/System/Process/Run.hs
10:25:00 <mrd> > iterate collength 10
10:25:01 <dons> gwern: ^
10:25:02 <lambdabot> http://tinyurl.com/2f7j8l
10:25:02 <lambdabot>  [10,5,4,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
10:25:07 <dcoutts_> gwern: there's no way to do it for a shell command except to direct into a file and read it back, readProcess is the same I think
10:25:07 <mrd> wild
10:25:15 <dcoutts_> gwern: one throws an exception, the other returns an ExitCode
10:25:26 <Jaak> > collength 847359
10:25:26 <gwern> maybe I'll look executeFile
10:25:27 <lambdabot>  264
10:26:19 <gwern> ...nope executefile returns IO ()
10:26:31 <gwern> wtf, why is basic shell stuff so hard? >.<
10:26:43 <gwern> if this weren't for darcs, I'd use HSH. :(
10:27:24 <abrasive> IsoPallo: sorry for disappearing... i'm compiling GHC 6.4.2 on a NetBSD box
10:27:41 <abrasive> x86_64 no less
10:27:57 <dcoutts_> dons: I think that readProcess will deadlock if the command produces more than 4k of stderr output
10:28:13 <dcoutts_> dons: compare to the rawSystemStdout in Cabal
10:28:16 <dons> i thought I checked that.
10:28:25 <dons> hmm, that might be the old code
10:28:27 <dcoutts_> dons: that code never touches errh
10:28:30 <dcoutts_> ok, right
10:28:33 <dons> ah, yes. its out of date.
10:28:37 <dcoutts_> ok
10:28:44 <gwern> where is dons' popen? I know the popen I uploaded to hackage, but no dons
10:28:57 <dons> gwern: its going into the process library
10:29:05 <tibbe> dons: any people at Galois had time to look at my proposal thing?
10:29:05 <dons> simon marlow's working on it.
10:29:11 <dcoutts_> dons: where is it at the moment?
10:30:05 <gwern> actually, that sort of raises a question - how the heck does darcs compile on windows with a makefile that uses commands like 'darcs changes --context | cat config.command - \ | ./stringify Context context > \src/Context.hs
10:30:27 <dcoutts_> gwern: it assumes mingw/msys
10:31:25 <gwern> dcoutts_: oh. how does mingw etc. interact with use of the System.Posix.* stuff?
10:31:29 <IsoPallo> abrasive: Ok, in that case I can't help... I bootstrapped GHC for a normal i386-PC
10:31:57 <IsoPallo> After some utility version changing it went smooth.
10:31:58 <dcoutts_> gwern: it doesn't, System.Posix is still not available (except .Types iirc)
10:32:08 <abrasive> I'm wishing I had an i386 compiler around :/
10:34:04 <gwern> dcoutts_: ack. this is looking harder by the second; is there no way to portably do 'darcs changes --context | cat config.command' from template haskell?
10:35:25 <abrasive> #define SIZEOF_VOID_P 4 when it should be 8 is a hack and a half :S
10:35:55 <abrasive> hopefully this kludge of a ghc compile will be enough to put a proper one together.
10:38:58 <quicksilver> abrasive: is there not a x64 port in the netbsd ports tree?
10:39:04 <abrasive> nope
10:39:11 <abrasive> because they distribute bootstrap binaries
10:39:16 <abrasive> or .hc rather
10:39:19 <abrasive> only for i386 :(
10:39:22 <quicksilver> strange
10:39:23 <abrasive> so i'm using those.
10:39:25 <IsoPallo> Mmm... So you can just do like that? Nice...
10:39:34 <abrasive> i can probably make this compile more... by using -m32 with gcc.
10:40:57 <Jaak> @src collength
10:40:58 <lambdabot> Source not found.
10:41:24 <Jaak> eithe my code is broken or this collength is :P
10:43:08 <quicksilver> abrasive: do you have linux binary support? You might find it works better to bootstrap with a linux binary for x64_64
10:44:31 <abrasive> quicksilver: not without upgrading the kernel to 4.x, unfortunately; it's running 3.1
10:44:38 <abrasive> which has linux compat... only on i386.
10:44:48 <abrasive> and it's a production server, so it's not getting upgraded soon.
10:45:13 <Deewiant> gwern: you might be able to adapt http://hpaste.org/7149 to your needs
10:48:15 <gwern> Deewiant: hm. what libraries is that using?
10:48:23 <gwern> @hoogle runInteractiveProcess
10:48:23 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
10:48:40 <Deewiant> what comes with GHC... 'process'?
10:48:52 <Deewiant> evidently so, process
10:48:59 <gwern> hm. so it should be portable then if it doesn't declare a win or posix dep
10:49:15 <Deewiant> yep, it should be
10:49:27 <Jedai> Jaak: given the way collength was defined it's highly improbable that it is wrong
10:49:33 <Deewiant> haven't used it very much but it seems to work on windows based on a few simple tests
10:49:46 <romildo> Hi.
10:49:59 <romildo> Where is the $ operator explained?
10:50:16 <gwern> @src ($)
10:50:16 <lambdabot> f $ x = f x
10:50:27 <abrasive> it's a precedence widget.
10:50:48 * gwern likes how mystifying that explanation seems if you don't already know what it does :)
10:50:49 <Deewiant> gwern: although there's this bug which may or may not be problematic... haven't tested on *nix so I don't know: http://hackage.haskell.org/trac/ghc/ticket/1780
10:50:50 <lambdabot> Title: #1780 (runInteractiveProcess broken with >2 processes on POSIX) - GHC - Trac
10:51:03 <Deewiant> gwern: it sounds like it would cause that to not work at all but I'm unsure.
10:51:29 <abrasive> romildo: the $ prevents the left operand from "grabbing" the right one, useful for chaining functions
10:51:39 <Cale> romildo: It's just function application, but it binds very weakly to its parameters, so for example, you can write  f . g . h $ x
10:52:03 <Cale> for  f (g (h x))
10:52:08 <gwern> Deewiant: uh oh. that could be a problem - does /bin/sh darcs changes | cat foo count as 3 processes I wonder...
10:52:12 * abrasive may be far off the mark with $ vs. .
10:52:32 <nomeata> Grr, iâm so often writing "something <- someAction; case something of (Just x) ->  ...", I wish there were a curried version of case that would allow me to write "someAction >>= cases (Just x) -> "...
10:52:32 <lambdabot> nomeata: You have 1 new message. '/msg lambdabot @messages' to read it.
10:52:35 <Cale> Or for example  f $ g x y, instead of f (g x y)
10:52:48 <Deewiant> gwern: if you're using runinteractiveprocess sh isn't used so that'd be one for darcs and one for cat
10:53:39 <bugQ> simpler explanation: (things over here $ things over there) is the same as ((things over here) (things over there))
10:53:40 <romildo> So, instead of writing 'onClicked button (do actions ...)', I can write 'onClicked button $ do actions ...', eliminating the need for the parentheses, right?
10:53:54 <gwern> Deewiant: hm hm. I kind of see. but if sh isn't involved then there's no pipe syntax to use...
10:54:03 <abrasive> romildo: yes, that's the idea.
10:54:07 <Cale> romildo: right
10:54:22 <dmead> does the standard lib have natural log?
10:54:51 <gwern> @hoogle ln
10:54:51 <lambdabot> Prelude.putStrLn :: String -> IO ()
10:54:51 <lambdabot> Prelude.readLn :: Read a => IO a
10:54:51 <lambdabot> System.IO.hPutStrLn :: Handle -> String -> IO ()
10:54:54 <abrasive> is it 'log' in the prelude?
10:54:58 <abrasive> @hoogle log
10:54:58 <lambdabot> Prelude.log :: Floating a => a -> a
10:54:59 <lambdabot> Prelude.logBase :: Floating a => a -> a -> a
10:54:59 <lambdabot> GHC.Conc.Logoff :: ConsoleEvent
10:55:11 <dmead> oh
10:55:14 <dmead> > log 2
10:55:15 <lambdabot>  0.6931471805599453
10:55:18 <abrasive> > log 2.7
10:55:19 <lambdabot>  0.9932517730102834
10:55:25 <dmead> > log 2.76
10:55:26 <lambdabot>  1.0152306797290584
10:55:28 <abrasive> hehe.
10:55:30 <dmead> > log 2.7643
10:55:30 <lambdabot>  1.01678743836578
10:55:35 <dmead> :P
10:55:37 <gwern> @src log
10:55:37 <lambdabot> Source not found. Sorry.
10:55:51 <gwern> can 'e' be represented as a floating without losing a lot of precision?
10:55:54 <dmead> how do you differentiate between log and ln then?
10:56:01 <abrasive> gwern: no more or less than any other float
10:56:09 <dmead> which could be alot
10:56:09 <Cale> dmead: log is the natural logarithm :)
10:56:15 <abrasive> dmead: in general circles 'log' on its own is usually log_e :)
10:56:24 <dmead> ah
10:56:26 <Deewiant> gwern: well, if you're using my pipe function, you'd do pipe [("cat", ["config.command"]), ("darcs", ["changes", "--context"])] <inputfile> <outputfile> or whatever
10:56:29 <quicksilver> dmead: only annoying calculator manufacturers disagree
10:56:32 <abrasive> and if you don't know what base you're in, just divide by log(baseyouwant)
10:56:33 <Cale> dmead: If you want the base 10 logarithm, you can use logBase or just divide by log 10
10:56:35 <glguy> > logBase 2 10
10:56:36 <lambdabot>  3.3219280948873626
10:56:44 <quicksilver> everyone else uses e
10:56:47 <dmead> >logBase e 10
10:56:50 <Deewiant> gwern: in this case I guess you'd lose the 'cat' and make config.command the input file
10:56:51 <dmead> > logBase e 10
10:56:52 <lambdabot>  log 10 / log e
10:56:58 <Cale> heh
10:57:00 <dmead> i guess it doesn't know e
10:57:07 <Cale> :t e
10:57:08 <lambdabot> Expr
10:57:09 <Deewiant> > exp 1
10:57:11 <lambdabot>  2.718281828459045
10:57:12 <dmead> > e
10:57:12 <lambdabot>  e
10:57:13 <gwern> Deewiant: well, my interesting is in ultimately returning an IO String/String
10:57:18 <gwern> *interest
10:57:21 <bugQ> > log (exp 1)
10:57:22 <lambdabot>  1.0
10:57:28 <dmead> :t exp
10:57:29 <lambdabot> forall a. (Floating a) => a -> a
10:57:33 <Deewiant> gwern: yeah, so you'd change it to not write to a file
10:57:38 <Cale> exp is the natural exponential function
10:57:51 <^Someone^> 10*10
10:58:02 <^Someone^> lambdabot: 10*10
10:58:11 * gwern needs to read this carefully
10:58:11 <Cale> ^Someone^: If you want it to evaluate, you have to prefix it with "> "
10:58:20 <Deewiant> gwern: which I guess would mean losing the last parameter to pipe and subPipe and changing the termination case of subPipe to just return str.
10:58:22 <Cale> > 10*10
10:58:23 <lambdabot>  100
10:58:29 <^Someone^> Oh
10:58:31 <gnuvince> > 10^2
10:58:32 <lambdabot>  100
10:58:33 <^Someone^> Thanks :)
10:58:45 <Cale> > log 100 / log 10
10:58:46 <lambdabot>  2.0
10:58:55 <^Someone^> > foldr [1,2,3]
10:58:55 <lambdabot>  Couldn't match expected type `a -> b -> b'
10:59:02 <^Someone^> > foldr 0 [1,2,3]
10:59:02 <Cale> > foldr f z [1,2,3]
10:59:03 <lambdabot>        add an instance declaration for (Num (a -> [t] -> [t]))
10:59:03 <lambdabot>  f 1 (f 2 (f 3 z))
10:59:06 <Deewiant> > (`foldr` [1,2,3])
10:59:07 <lambdabot>  Add a type signature
10:59:14 <vincenz> > foldr (+) 0 [1,2,3]
10:59:15 <Cale> > foldr (+) 0 [1,2,3]
10:59:16 <lambdabot>  6
10:59:16 <lambdabot>  6
10:59:18 <Cale> heh
10:59:21 <gnuvince> > foldr1 (+) [1..3]
10:59:22 <lambdabot>  6
10:59:25 <Cale> > foldr (*) 1 [1,2,3]
10:59:26 <lambdabot>  6
10:59:28 <Deewiant> > sum [1..3]
10:59:29 <lambdabot>  6
10:59:31 <vincenz> gnuvince: hey, thanks for the reddit comment :)
10:59:35 <bugQ> ?t (^)
10:59:35 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
10:59:40 <bugQ> :t (^)
10:59:42 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
10:59:56 <^Someone^> Oh yeah
11:00:12 <^Someone^> Forgot the function
11:00:25 <gnuvince> vincenz: my pleasure.  I hate people who say that something they've never seen before is cryptic.  One can't say that while (*dst++ = *src++) ; isn't cryptic.
11:00:25 <Deewiant> gwern: but like said, since you've essentially got only one command you want to run (darcs) you might get away with something a lot simpler using the functions in System.Process.
11:00:31 <gnuvince> (to the novice, of course)
11:00:43 <^Someone^> > foldr (-) 0 [1,2,3,4]
11:00:44 <lambdabot>  -2
11:00:47 <^Someone^> :D
11:00:50 <^Someone^> Cool
11:00:58 <gwern> Deewiant: I'll look there too
11:01:00 <Deewiant> > foldr subtract 0 [1,2,3,4]
11:01:01 <lambdabot>  -10
11:01:34 <gwern> @hoogle ProcessHandle
11:01:36 <lambdabot> System.Process.ProcessHandle :: data ProcessHandle
11:01:36 <Deewiant> > foldr (-) 0 [a,b,c,d]
11:01:37 <lambdabot>  a - (b - (c - (d - 0)))
11:01:38 <Deewiant> > foldr subtract 0 [a,b,c,d]
11:01:39 <lambdabot>  0 - d - c - b - a
11:02:07 <bugQ> > foldl (-) 0 [a,b,c]
11:02:09 <lambdabot>  0 - a - b - c
11:03:06 <vincenz> > let fibs n = let arr = array (0, max 2 n) $ [(0,a), (1,b), (2,c)] ++ [(i,e) | i <- [3..n], let i' = i `div` 2, let e =  (arr ! i') * (arr ! (i-i'-1)) + (arr ! (i'+1))*(arr ! (i-i'))]  in arr ! n in fibs 5
11:03:08 <lambdabot>  c * c + (b * b + c * c) * (b * b + c * c)
11:03:11 <vincenz> > let fibs n = let arr = array (0, max 2 n) $ [(0,a), (1,b), (2,c)] ++ [(i,e) | i <- [3..n], let i' = i `div` 2, let e =  (arr ! i') * (arr ! (i-i'-1)) + (arr ! (i'+1))*(arr ! (i-i'))]  in arr ! n in fibs 10
11:03:12 <lambdabot>  (c * c + (b * b + c * c) * (b * b + c * c)) * (c * b + (b * b + c * c) * c) ...
11:03:15 <Deewiant> @check \xs -> foldr subtract 0 xs == foldl (-) 0 xs
11:03:16 <lambdabot>  OK, passed 500 tests.
11:03:45 <gwern> dang. runCommand looks like what I want, but there's no explanation of what one does with a ProcessHandle
11:03:59 <vincenz> Cale: :)
11:04:20 <vincenz> > let fibs n = let arr = array (0, max 2 n) $ [(0,a), (1,b), (2,c)] ++ [(i,e) | i <- [3..n], let i' = i `div` 2, let e =  (arr ! i') * (arr ! (i-i'-1)) + (arr ! (i'+1))*(arr ! (i-i'))]  in arr ! n in map fibs [0..10]
11:04:21 <lambdabot>  [a,b,c,b * b + c * c,c * b + (b * b + c * c) * c,c * c + (b * b + c * c) * (...
11:04:42 <Deewiant> gwern: you waitForProcess, in general
11:04:57 <Cale> hmm :)
11:05:13 <Deewiant> gwern: note that you can't get output from runCommand. it's for stuff like runCommand "rm -r /". :-P
11:05:26 <Cale> ah, you're solving the general recurrence :)
11:05:35 <vincenz> Cale: yeah
11:05:35 <gwern> dammit
11:05:36 <Deewiant> gwern: runInteractiveCommand allows you to communicate.
11:05:44 <Cale> though perhaps you don't need c?
11:05:49 <vincenz> Cale: you do
11:06:01 <vincenz> well I could name it a+b
11:06:08 <Cale> > let fibs n = let arr = array (0, max 1 n) $ [(0,a), (1,b)] ++ [(i,e) | i <- [2..n], let i' = i `div` 2, let e =  (arr ! i') * (arr ! (i-i'-1)) + (arr ! (i'+1))*(arr ! (i-i'))]  in arr ! n in map fibs [0..10]
11:06:09 <lambdabot>  [a,b,b * a + (b * a + (b * a + (b * a + (b * a + (b * a + (b * a + (b * a + ...
11:06:12 <vincenz> but it will blow if you use the recurrence formula iir
11:06:23 <vincenz> index rounding
11:06:24 <Cale> mm, yeah
11:06:48 <Cale> Nice infinite expression going on there :)
11:06:51 <vincenz> :)
11:08:47 <Jaak> > collength 837799
11:08:48 <lambdabot>  329
11:11:51 <Jaak> > length . dropWhile (/= 1) $ iterate collatz 22
11:11:53 <lambdabot> Terminated
11:12:36 <vincenz> > collatz 22
11:12:37 <lambdabot>  11
11:12:40 <vincenz> > collatz 11
11:12:41 <lambdabot>  17
11:12:43 <vincenz> > collatz 17
11:12:53 <lambdabot>  26
11:12:54 <Deewiant> > dropWhile (/= 1) $ iterate collatz 22
11:12:55 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
11:13:05 <Jaak> oh, duh
11:13:11 <Jaak> take... not drop :)
11:13:14 <Deewiant> :-)
11:13:20 <Jaak> > length . takeWhile (/= 1) $ iterate collatz 22
11:13:20 <Deewiant> > takeWhile (/= 1) $ iterate collatz 22
11:13:21 <lambdabot>  11
11:13:21 <lambdabot>  [22,11,17,26,13,20,10,5,8,4,2]
11:13:42 <Jaak> > collength 22
11:13:43 <lambdabot>  11
11:14:42 <gwern> @hoogle unsafePerformIO
11:14:42 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
11:14:42 <lambdabot> System.IO.Unsafe.unsafePerformIO :: IO a -> a
11:15:16 <Jaak> what... collatz 11 == 17?
11:15:43 <Jaak> > 3*11 + 1
11:15:44 <lambdabot>  34
11:15:51 <gwern> it's kind of funny, but every time I look up one of the unsafe* functions, I half-expect someone to shout - "No, don't do it! It's not worth it gwern!"
11:16:03 <Deewiant> gwern: I was going to but decided against it. ;-)
11:16:08 <Valodim> You have fallen already
11:16:15 <shepheb> you have so much to live for!
11:16:31 <gwern> yes, that's what I meant :)
11:17:06 <Deewiant> Jaak: it appears to halve the result for odd numbers as well, is that right?
11:17:19 <shepheb> I think it's just an optimization
11:17:30 <shepheb> odd * 3 + 1 is always even, no?
11:17:36 <byorgey> indeed.
11:17:38 <Deewiant> well, it skips a step in the sequence
11:17:47 <Deewiant> you miss out on the intermediate value
11:17:50 <byorgey> that's a common alternative formulation of the problem
11:18:03 <byorgey> or, I should say, of the function
11:18:04 <Deewiant> fine
11:18:07 <Jaak> yeah, looks like it. but atleast now my own code works properly
11:18:10 <Deewiant> I don't know, just wondering :-)
11:18:41 <byorgey> Deewiant: I wasn't correcting you, just explaining =)
11:19:02 <Deewiant> byorgey: sure, just pointing out that I wasn't critizing :-)
11:19:15 <byorgey> heh, ok =)
11:20:01 <paolino> @hoogle isLeft
11:20:03 <lambdabot> No matches found
11:20:28 <Deewiant> @hoogle Either a b -> Bool
11:20:29 <lambdabot> No matches, try a more general search
11:21:00 <Deewiant> @ty either (const True) (const False)
11:21:01 <lambdabot> forall a b. Either a b -> Bool
11:21:22 <opqdonut> ?djinn Either a b -> Bool
11:21:23 <lambdabot> f a =
11:21:23 <lambdabot>     case a of
11:21:23 <lambdabot>     Left _ -> False
11:21:23 <lambdabot>     Right _ -> True
11:21:26 <opqdonut> :)
11:21:37 <paolino> :)
11:21:39 <vincenz> @pl \const -> either (const True) (const False)
11:21:40 <lambdabot> liftM2 either ($ True) ($ False)
11:22:00 <vincenz> > liftM2 either ($ True) ($ False) const $ Left "a"
11:22:02 <lambdabot>  True
11:22:05 <shepheb> byorgey: what happened to solution part II?
11:22:20 <byorgey> shepheb: hehe, I just knew someone was going to ask that =)
11:22:35 <paolino> vincenz , almost clear as isLeft :d
11:22:35 <shepheb> I assume it's a typo then?
11:23:01 <byorgey> shepheb: in part III I discuss the answer to problem #3.  I'll post the solution to #2 (which will be solution part II) later.
11:23:51 <paolino> vincenz is that (->) monad ?
11:24:08 <byorgey> I'm doing that one last since it's the most interesting, and will lead into a continuation of my series on "Recounting the Rationals"
11:24:10 <gwern> @hoogle IO String -> IO ()
11:24:10 <lambdabot> No matches, try a more general search
11:24:32 <Deewiant> @ty liftM (const ())
11:24:33 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m ()
11:24:48 <shepheb> byorgey: fair enough. the wording just throws off my compulsive side.
11:24:54 <vincenz> paolino: yep
11:24:57 <paolino> they are going to make a shiny hoogle for hsoc :)
11:27:54 <gwern> damn! a link error with template haskell
11:30:24 <gwern> http://hpaste.org/7150
11:32:24 <gwern> eh. I think I'll call it quits for now
11:35:34 <Cale> gwern: You're sure that's a problem with template haskell?
11:36:30 <gwern> Cale: well, given that darcs builds fine if context is manually defined as a normal String...
11:36:40 <gwern> it's either a problem in template haskell or my use of template haskell
11:37:01 <Cale> That error appears to suggest something is wrong with libz
11:45:35 <romildo> I have written my first gtk2hs program, and I would like to read comments on it.
11:45:40 <romildo> http://hpaste.org/7151
11:46:52 <romildo> It just counts how many times a button is clicked, displaying the result in a label.
11:48:24 <geezusfreeek> i have a hang in my program that i'm trying to find with profiling, but since i have to kill the program it looks like the RTS doesn't get a chance to write out its results. is there anything i can do about that?
11:54:30 <geezusfreeek> eh, nevermind, i found the problem
11:54:41 <desegnis_> romildo: looks like just normal gtk2hs to me
11:55:51 <desegnis_> that is, no surprises or bad things to be found
11:56:20 <romildo> desegnis_, yes. As it is my first one, and it does not have not have many examples to mimic, I want to know if I have done it right.
11:57:01 <romildo> Maybe some suggestions for better practice in the following applications I intend to write.
11:58:38 <romildo> In particular, is the way I have included the 2 buttons and the label into the horizontal box the easier one?
12:01:50 <desegnis_> Is there another way?
12:03:02 <romildo> desegnis_, I do not know. I have just started learning. So this question is mine.
12:03:22 <desegnis_> The way you've done it is what the API docs suggest
12:03:32 <desegnis_> So that should be how to do it
12:04:15 <desegnis_> It's also what is done in the sample files
12:05:32 <roconnor> what would you name the function (SymmetricMonoidalFunctor f) => (f a, f b) -> f (a, b) ?
12:05:46 <roconnor> @hoogle (f a, f b) -> f (a,b)
12:05:47 <lambdabot> Prelude.fst :: (a, b) -> a
12:05:47 <lambdabot> Prelude.snd :: (a, b) -> b
12:05:47 <lambdabot> Data.Tuple.fst :: (a, b) -> a
12:07:02 <desegnis_> couple, because that's another word for pair, just as sequence is another word for list :)
12:07:37 <byorgey> couple, I like it.  It also can be used as a verb, just as 'sequence' can.
12:07:47 <sclv_> excellent call.
12:08:01 <opqdonut> nice
12:08:02 <opqdonut> yeah
12:08:05 <kpreid> roconnor: fzip
12:08:58 <sclv_> ?hoogle traverse
12:08:58 <lambdabot> Data.Traversable.traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:08:58 <lambdabot> Data.Foldable.traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
12:10:52 <sclv_> ?ty Data.Traversable.traverse id
12:10:53 <lambdabot> forall (f :: * -> *) b (t :: * -> *). (Applicative f, Data.Traversable.Traversable t) => t (f b) -> f (t b)
12:10:54 <quicksilver> roconnor: it is 'sequence' for the obvious traversable instance for pairs.
12:11:22 <quicksilver> sclv_: traverse id == sequence, no?
12:11:50 <roconnor> what does sequence have to do with pairs?
12:12:01 <sclv_> its not quite enough -- the signature forces everything "inside" the functor into a uniformt ype
12:12:04 <quicksilver> roconnor: I was just making an observation.
12:12:26 <quicksilver> if your functor f is in fact applicative
12:12:35 <sclv_> you could probably write a generalized version for all traversables, but i can't think quite how at the moment.
12:12:37 <quicksilver> and you make the natural Traversable instance for (a,a)
12:12:38 <roconnor> f is a monad in my case
12:12:47 <quicksilver> then what you want is called 'sequence'
12:12:49 <roconnor> and commutative
12:12:52 <quicksilver> you don't have to like that name :)
12:12:58 <quicksilver> I quite like the name 'couple' too.
12:13:06 <roconnor> sequence doesn't seem to have anything to do with pairs
12:13:12 <quicksilver> :t Data.Traversable.sequence
12:13:13 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Monad m, Data.Traversable.Traversable t) => t (m a) -> m (t a)
12:13:15 <nomeata> Hi. If I want to conveniently abort in the middle of an monatic action (with IO), save the state in some IORef, and later either continue or abort that, whatâs the best approach? ContT?
12:13:34 <quicksilver> roconnor: set "m" = your functor and "t" = the traversable (a,a)
12:13:44 <nomeata> (Itâs slow a rendering that has to be stopped for user interaction, and aborted when the state has changed)
12:13:51 <roconnor> quicksilver: that's not the same as my type. :)
12:14:13 <quicksilver> oh, your a and b were different types?
12:14:35 <quicksilver> that's why you used different letters :)
12:14:35 <roconnor> in general they are
12:14:36 <quicksilver> fair enough.
12:14:54 <roconnor> ... although I must admit in my specific case a = b
12:16:24 <quicksilver> nomeata: there is the simpler 'ExitT' on the wiki for early exit
12:16:33 <quicksilver> it's implementable with Cont, Ibelieve
12:16:35 <quicksilver> exit is simpler
12:16:39 <nomeata> quicksilver: but does it support resume?
12:17:08 <Jedai> roconnor: curry zip ?
12:17:28 <Jedai> roconnor: uncurry zip ? (oops)
12:17:47 <Jedai> @hoogle zip
12:17:48 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
12:17:48 <lambdabot> Data.List.zip :: [a] -> [b] -> [(a, b)]
12:17:48 <lambdabot> Data.ByteString.zip :: ByteString -> ByteString -> [(Word8, Word8)]
12:19:21 <Jedai> Ah I see kpreid already made the suggestion :)
12:20:26 <Jedai> @hoogle f a -> f b -> f (a, b)
12:20:27 <lambdabot> Prelude.asTypeOf :: a -> a -> a
12:20:27 <lambdabot> Prelude.const :: a -> b -> a
12:20:27 <lambdabot> Prelude.seq :: a -> b -> b
12:21:06 <orzo> hello
12:21:39 <conal> @type liftA2 (,)
12:21:41 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
12:22:10 <opqdonut> @type uncurry (liftA2 (,))
12:22:12 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (f a, f b) -> f (a, b)
12:22:14 <opqdonut> :)
12:23:19 <orzo> I'm trying to write evaluate :: HashTable String Dynamic -> [String] -> Dynamic -> Integer
12:24:17 <Cale> orzo: Which HashTable implementation are you using. Don't use Data.HashTable
12:24:18 <czakey> @botsnack
12:24:19 <lambdabot> :)
12:24:22 <orzo> where the list is a list of variable names that will be looked up in the hash and the Dynamic is a function of precisely that number of arguments
12:24:27 <Cale> er s/./?/
12:24:27 <Jedai> > getZipList $ liftA2 (,) (ZipList [1, 2, 3]) (ZipList [3, 4, 5, 6])
12:24:29 <lambdabot>  [(1,3),(2,4),(3,5)]
12:24:33 <nomeata> everywhere I read that ContT can be used to interrupt and resume computation, but all the examples just show how to use runCC to abort early.
12:24:38 <orzo> Cale, I'm using Data.HashTAble
12:24:44 <Cale> orzo: You should use Data.Map
12:24:55 <orzo> why?
12:25:15 <Cale> orzo: It has a rich and easy to use interface which doesn't involve the IO monad, and it's consistently faster and more scalable than Data.Hashtable
12:25:35 <orzo> Oh
12:25:51 <Cale> Data.HashTable has no real reason to exist beyond backward compatibility with a few old programs.
12:25:53 <orzo> well does it have an evaluate function in its interface?
12:26:09 <Cale> Er, and I don't know, it at least used to be used internally in GHC, but they may have replaced it.
12:26:14 <Cale> Evaluate?
12:26:39 <orzo> i want to supply a function and a list of key names and i want it to look up the values of those keys and apply the function to it
12:27:04 <Cale> Well, doing a list of lookups is not hard
12:27:04 <orzo> the number of arguments the function takes dependson the size of the list
12:27:05 <sclv_> ?hoogle callCC
12:27:05 <lambdabot> Control.Monad.Cont.Class.callCC :: MonadCont m => (a -> m b -> m a) -> m a
12:27:16 <Cale> The function is of type Dynamic?
12:27:19 <orzo> yes
12:27:34 <orzo> i need a way to get the right type out of it
12:27:50 <Jedai> @src cycle
12:27:51 <lambdabot> cycle [] = undefined
12:27:51 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
12:28:22 <orzo> the type of the function depends on the length of the list
12:28:30 <sclv_> ?hoogle runCont
12:28:30 <lambdabot> Control.Monad.Cont.runCont :: Cont r a -> (a -> r) -> r
12:28:30 <lambdabot> Control.Monad.Cont.runContT :: ContT r m a -> (a -> m r) -> m r
12:28:59 <Cale> So you probably want to map (\k -> findWithDefault undefined k m) listOfArgs
12:29:15 <Bonus> wouldn't it make more sense if cycle [] was []?
12:29:45 <orzo> that will give me a list of values
12:29:59 <orzo> but how do i feed them to the dynamically typed function
12:30:27 <Cale> orzo: Right, and then you need to do a foldl with dynApp
12:30:33 <sclv_> ?hoogle dynApp
12:30:34 <lambdabot> Data.Dynamic.dynApp :: Dynamic -> Dynamic -> Dynamic
12:30:34 <lambdabot> Data.Dynamic.dynApply :: Dynamic -> Dynamic -> Maybe Dynamic
12:30:39 <Toxaris> orzo: that's independent of HashTable vs. Map :)
12:30:47 <orzo> i know, toxaris
12:30:50 <Cale> foldl dynApp myDynFunction theListOfDynamicArgs
12:31:42 <sclv_> I have a huge sensation that dynamics are probably silly here.
12:32:20 <orzo> i'm still trying to understand the foldl solution
12:32:22 <orzo> heh
12:32:45 <Cale> > foldl f z [1,2,3]
12:32:45 <lambdabot>  f (f (f z 1) 2) 3
12:32:58 <sclv_> if yr. learning haskell and reaching for hashtables and dynamics right away, it probably means you're trying to make it into perl/ruby/python without first understanding why its not.
12:33:19 <Cale> So replace f with dynApp and z with the function you're starting with.
12:33:41 <Cale> Yeah, and probably you should actually avoid Dynamics unless they're *really* the only solution to your problem.
12:33:41 <sclv_> e.g. can't yr functions just take a list to begin with?
12:34:00 <orzo> suppose f = toDyn (\x y z -> 0) and my list is [1,2,3]
12:34:10 <sclv_> (or unless the other solution involves HList :-) )
12:34:36 <Cale> orzo: You have to know the type of the result, or you'll get nothing useful out again of course.
12:36:09 <nomeata> http://hpaste.org/7155 is an example of what Iâd like to do with ContT. Can anyone help me out?
12:36:37 <sclv_> again, if yr. supplying the functions, and the args yr passing them are all apparently Strings, just have each function uniformly take a list of strings.
12:36:42 <orzo> > foldl dynApp (toDyn ( (\x y z -> 0) :: Integer -> Integer -> Integer -> Integer ) )  (map toDyn [1 .. 3] )
12:36:43 <lambdabot>  <<Integer>>
12:37:18 <Cale> > fromDyn $ foldl dynApp (toDyn ( (\x y z -> 0) :: Integer -> Integer -> Integer -> Integer ) )  (map toDyn [1 .. 3] ) :: Integer
12:37:18 <lambdabot>  Couldn't match expected type `Integer'
12:37:34 <Cale> > fromDynamic $ foldl dynApp (toDyn ( (\x y z -> 0) :: Integer -> Integer -> Integer -> Integer ) )  (map toDyn [1 .. 3] ) :: Maybe Integer
12:37:35 <lambdabot>  Just 0
12:37:54 <abrasive> ah, thanks to whoever mentioned Dynamic. that probably provides a workaround for one of my current problems
12:38:11 <abrasive> probably not an elegant one, but nonetheless.
12:38:29 <orzo> > foldl dynApp (toDyn ( (\x y z -> x*100+y*10+z) :: Integer -> Integer -> Integer -> Integer ) )  (map toDyn [1 .. 3] ) :: Maybe Integer
12:38:29 <lambdabot>  Couldn't match expected type `Maybe Integer'
12:39:31 <orzo> > fromDynamic $  foldl dynApp (toDyn ( (\x y z -> x*100+y*10+z) :: Integer -> Integer -> Integer -> Integer ) )  (map toDyn [1 .. 3] ) :: Maybe Integer
12:39:32 <lambdabot>  Just 123
12:39:41 <orzo> wow.
12:41:47 <Cale> Data.Dynamic is rarely the optimal solution to a problem.
12:41:51 <dmead> > 2 ^ 2
12:41:51 <lambdabot>  4
12:41:57 <Cale> > 0^0
12:41:58 <lambdabot>  1
12:42:43 <dmead> can someone explain what exp 1 means
12:42:47 <dmead> i know it gives you e
12:42:49 <Deewiant> exp(1)
12:42:50 <dmead> what does exp do :/
12:42:51 <Deewiant> e to the power of 1
12:42:54 <dmead> ahh
12:42:55 <dmead> oh
12:43:40 <Cale> exp x = 1 + x + x^2/2! + x^3/3! + ...
12:43:42 <abrasive> Dynamic looks like a good way to ugly solutions, to be sure.
12:45:10 <Cale> > sum [1 / product [1..n] | n <- [0..100]]
12:45:11 <lambdabot>  2.7182818284590455
12:45:15 <Cale> > exp 1
12:45:16 <lambdabot>  2.718281828459045
12:45:47 <Cale> > let x = 2 in sum [x^n / product [1..fromIntegral n] | n <- [0..100]]
12:45:48 <lambdabot>  7.389056098930649
12:45:53 <Cale> > exp 2
12:45:54 <lambdabot>  7.38905609893065
12:46:05 <byorgey> > (exp 1)^2
12:46:07 <lambdabot>  7.3890560989306495
12:47:16 <Cale> exp and log are actually how exponentiation is defined with a real exponent and positive base
12:47:29 <Cale> a^b = exp (b log a)
12:47:40 <opqdonut> mhmm
12:47:49 <abrasive> it's also how trig functions are defined.
12:47:51 <opqdonut> and "exp" can be defined in many fields
12:48:03 <opqdonut> for example for matrices
12:48:14 <abrasive> and the imaginary plane.
12:48:14 <Cale> right
12:48:20 <opqdonut> :)
12:48:27 <Cale> complex plane ;)
12:48:31 <abrasive> shhhh :P
12:49:44 <kpreid> newtype Imaginary a = Imaginary a; instance Num a => Imaginary a where ...
12:49:49 <Bonus> is there any convention as to when you should use f . g $ x and when to use f $ g $ x
12:50:05 <kpreid> Bonus: no, only differing opinions on which to use everywhere
12:50:08 <opqdonut> Bonus: never the $$ version
12:50:11 <opqdonut> ;)
12:50:18 <Cale> Bonus: My convention is to never use the second.
12:50:35 <abrasive> ...is there a difference between those two operators?
12:50:39 <Cale> abrasive: yes
12:50:39 <Bonus> ah
12:50:43 <Cale> (.) is function composition
12:50:47 <Cale> ($) is function application
12:50:52 <abrasive> ah, i see.
12:50:52 <Cale> :t (.)
12:50:52 <Bonus> $ is like (
12:50:53 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:50:57 <Cale> :t ($)
12:50:58 <lambdabot> forall a b. (a -> b) -> a -> b
12:51:08 <Cale> hehe, that's my generalisation of (.)
12:51:09 <opqdonut> heh, lambdabot has (.) = fmap
12:51:10 <opqdonut> :)
12:51:28 <Cale> The Haskell 98 prelude has  (.) :: (a -> b) -> (e -> a) -> (e -> b)
12:51:57 <Bonus> $ is equivalent to just adding )( and then matching parens at the end and beginning of the expression, right?
12:52:03 <Cale> But (e ->) is a functor, so you can generalise it ;)
12:52:19 <Cale> Bonus: kind of
12:52:39 <Cale> Bonus: you can think of it that way if it helps
12:52:56 <Cale> $ is just an ordinary function
12:52:59 <cpoucet> Cale: so (-> e) is a cofunctor?
12:53:05 <Cale> cpoucet: yeah
12:53:07 <Cale> @src ($)
12:53:07 <lambdabot> f $ x = f x
12:53:15 <Cale> @src (.)
12:53:15 <lambdabot> (f . g) x = f (g x)
12:53:15 <cpoucet> Cale: what's the structure of a cofunctor?
12:53:17 <Bonus> yeah that's what i though
12:53:24 <Cale> (that's the non-generalised version of (.), btw)
12:53:31 <cpoucet> :t (.)
12:53:31 <eugman|college> So should you use . for functions and $ for arguments?
12:53:32 <byorgey> cpoucet: you just need comap :: (a -> b) -> f b -> f a
12:53:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:53:45 <cpoucet> hmm
12:53:47 <Cale> eugman|college: Yeah, (.) combines functions, and ($) applies them
12:53:48 <cpoucet> byorgey: you sure?
12:53:56 <cpoucet> byorgey: I never know how to go from x to cox
12:54:09 <byorgey> cpoucet: yes, I'm sure =)
12:54:10 <opqdonut> any other cofunctors than (->e)?
12:54:10 <eugman|college> Ok, I think I can understand that explaination. i had trouble distinguishing the two myself.
12:54:17 <Cale> The funny thing is that ($) has the "wrong" associativity -- the opposite associativity from function application
12:54:20 <cpoucet> opqdonut: comonads :)
12:54:22 <conal> cpoucet: see TypeCompose
12:54:26 <Cale> and this is what makes things confusing
12:54:29 <cpoucet> conal: thx
12:54:35 <opqdonut> cpoucet: ah yes of course
12:54:43 <opqdonut> Cale: co-nfusing
12:54:44 <Cale> ($) in Haskell 98 is right associative, so that
12:54:49 <Cale> f $ g $ h $ x
12:54:51 <Cale> is the same as
12:55:00 <Cale> f $ (g $ (h $ x)))
12:55:09 <Bonus> yeah if it were a normal function, f $ g $ x would equal ((((f $) g) $) x)
12:55:11 <Cale> Whereas normally with function application:
12:55:14 <Cale> f g h x
12:55:15 <Bonus> i think
12:55:18 <Cale> would be the same as
12:55:21 <cpoucet> so co (a-> ,b->) == Either (-> a) (-> b) ?
12:55:22 <Cale> ((f g) h) x
12:55:39 <Saizan_> cpoucet: the comonads i've seen were functors
12:55:40 <Cale> If ($) were left-associative, we'd have
12:55:45 <Cale> f $ g $ h $ x
12:55:50 <Cale> is the same as
12:55:57 <Cale> ((f $ g) $ h) $ x
12:55:57 * qwr haven't found it to be confusing. probably some of the very first things, that i learned about haskell...
12:56:12 <Bonus> yeah
12:56:22 <Cale> Well, it makes beginners confused about the difference between (.) and ($)
12:56:33 <Cale> Since the appear interchangeable at some points because of it.
12:56:35 <Cale> they*
12:56:35 <Bonus> from the beginning i just thought of $ as making a )( and adding matching parens at the far left and right
12:57:03 <Cale> It's much better to write f . g . h $ x in place of f $ g $ h $ x
12:57:09 <qwr> :t ($)
12:57:10 <Cale> The reason is that g $ h is meaningless
12:57:10 <lambdabot> forall a b. (a -> b) -> a -> b
12:57:17 <Cale> But g . h will be meaningful
12:57:33 <Cale> and so it makes the expression easier to work with and think about
12:57:40 <Bonus> i agree
12:57:47 <eugman|college> hmm so assuming f and g were functions of a->a or something like that then foo = f g wouldn't work but foo = f . g would is that correct?
12:57:54 <cpoucet> eugman|college: yep
12:57:54 <Bonus> when you guys write expressions that end up looking like f . g . h $ x, do you start with h and then write g and f or the other way around?
12:57:55 <Cale> eugman|college: right
12:58:08 <Bonus> i usually start on the right side and then add stuff to the left of the expression
12:58:12 <Cale> Bonus: depends on how I'm feeling at the time :)
12:58:25 <Bonus> cause i think like
12:58:27 <Bonus> take x
12:58:29 <Bonus> apply h to it
12:58:33 <Cale> right
12:58:33 <Bonus> then apply g to the result
12:58:34 <olsner> and you can easily refactor (g.h) into gh = g . h if you write it f . g . h $ x, as an added bonus
12:58:36 <Bonus> then apply f to the result
12:58:42 <Bonus> yeah
12:58:59 <Cale> Bonus: As you get more fluent, you start to think in terms of combining functions, not just applying them directly to values.
12:59:09 <Bonus> yeah i guess
12:59:10 <Cale> But yeah, it really depends on your thought process.
12:59:10 <olsner> you can also think "hmm, I want the f of something applied to this thing x I have"
12:59:35 <olsner> where something = g . h, but of course you don't know that until the next train of thought
12:59:39 * shachaf misreads "Bonus:" messages. :-)
13:00:06 <Bonus> also cool with . is that instead of map f . map g . map h $ x you can do map (f . g . h) x
13:00:20 <Bonus> hehe
13:00:22 <Cale> right, it leads to all the natural manipulations on things
13:00:24 <olsner> shachaf: must be the IRC server giving you extra rewards for insightful messages
13:01:41 <eugman|college> I've managed to start understanding haskell but I really haven't "gotten" it. I don't know when idiomatic haskell would be a superior choice to some procedural alternative.
13:02:10 <Cale> It takes time...
13:02:23 <olsner> idiomatic haskell is always superior :P
13:02:24 <Bonus> i've found that usually haskell is a good choice when much of your program is doing transformation on data
13:02:39 <Toxaris> are there other programs?
13:02:43 <abrasive> I got the "when it is superior", that's why i'm using it for my current project
13:02:46 <Bonus> well
13:02:49 <Bonus> games for instance
13:02:55 <abrasive> but, learning the deep ins and outs takes a while.
13:02:56 <Cale> It was about 2 months for me to get to something about where you are, where I felt comfortable using Haskell, but not really fluent, and about a year before I was really comfortable.
13:03:03 <Toxaris> game :: State -> UserInput -> State
13:03:17 <abrasive> i still find myself battling the type system
13:03:33 <abrasive> "what do you MEAN i can't return two different types depending on guards or a case stmt!")
13:03:39 <Bonus> yeah but i think it's much more natural to represent a game as a group of objects
13:03:42 <Bonus> interacting with each other
13:03:44 <Bonus> and having state
13:03:57 <Cale> One big issue for people coming from dynamically typed languages is what the meaning of types are. Types express what you know statically about your program before it's run.
13:04:05 * olsner mumbles something about Simula, object orientation, and games being simulations
13:04:07 <abrasive> i'm definitely in the "data transformations" camp now... tried writing this thing in perl and it just was not going to happen
13:04:45 <eugman|college> olsner, haskell doesn't seem to be play nice with heavy io from what I understand
13:04:54 <abrasive> Cale: yes, but if my function returns "Expr a", i'd like to be able to return Expr Word32 specifically if I feel like it. :)
13:05:06 <Cale> If you want to return two different types of things from a function, you have to express that your function will do this in its type, by constructing an appropriate type that represents the options.
13:05:14 <conal> Bonus: careful not to mix up "natural" with habitual.
13:05:22 <abrasive> yeah, I'd prefer not to nest my types too deeply though.
13:05:32 <abrasive> it gets into code duplication at some point
13:05:35 <Bonus> yeah, but after some thinking about it
13:05:37 <Cale> abrasive: Returning an Expr a means that your function must be able to return an Expr a for *any* type a, not *some* type a.
13:05:55 <Cale> It's a matter of quantifiers.
13:06:12 <Cale> In fact, GHC with extensions turned on will explicitly write the foralls for you :)
13:06:15 <Cale> :t length
13:06:16 <abrasive> Yes, and me needing to learn the underlying rules before I can run around getting what I want :)
13:06:18 <lambdabot> forall a. [a] -> Int
13:06:21 <geezusfreeek> eugman|college: not really true once you really understand the reasons for the decisions made about IO
13:06:30 <eugman|college> I definitely want to learn more haskell. I may never code anything signifgant in it but it does affect things. I'm probably going to use gnerators more in python.
13:06:34 <geezusfreeek> eugman|college: i find the constraints liberating
13:06:49 <Bonus> yeah learning haskell made me a much better python programmer
13:06:55 <abrasive> the constraints are good. they guide your expression of algorithmic ideas
13:06:56 <Cale> eugman|college: In fact, I'd say the exact opposite -- Haskell plays *extremely* nicely with I/O.
13:07:16 <Cale> Haskell has one of the nicest systems for expressing I/O in any language.
13:07:28 <geezusfreeek> only in haskell can i manipulate io actions in a type safe way before actually executing them
13:07:29 <Bonus> yeah after learning how monads and the IO monad in specific work i was like: man this is a rather genius solution
13:07:44 <abrasive> i have yet to wrap my head around monads
13:07:46 <Cale> You can write your own control structures and actually know when things are going to happen without danger of them happening too early or too late.
13:07:50 <abrasive> slightly too much brain input at the moment.
13:07:55 <conal> the type system lets you program functionally or imperatively and tells you which you're doing when.
13:07:58 <geezusfreeek> i can't necessarily reorder them, but i can write my own control structures, in a sense, and it's very nice
13:08:04 <cpoucet> abrasive: welcome to haskell
13:08:04 <eugman|college> I hit a wall at state tranformers.
13:08:28 <Cale> What I really like is when you get to write functional programs that write imperative programs to solve your problem :)
13:08:35 <Bonus> haha
13:08:36 <abrasive> cpoucet: i was introduced to it three years ago :)
13:08:47 <geezusfreeek> Cale: that's really what you do every time you write a haskell program
13:08:52 <Cale> (which is essentially how the I/O system works in Haskell, yes)
13:08:53 <abrasive> Cale: I'm writing a functional program that reads an imperative program and writes another imperative program :P
13:09:15 <Cale> But you can make more or less use of that fact.
13:09:23 <Saizan_> it's a bit a pita that IO actions are opaque..
13:09:28 <Cale> Yeah
13:09:36 <Cale> I would actually like IO to be a GADT
13:09:52 <Cale> But it's hard to imagine optimisation will be as easy then.
13:09:52 <sclv_> abrasive: that's a perfect use for haskell!
13:10:05 <abrasive> sclv_: too right it is, that's why i chose to use it :>
13:10:20 <Toxaris> Cale: add it to lambdabot!
13:10:22 <abrasive> read program, do transformations on program, write new program
13:10:30 <Cale> Toxaris: add what to lambdabot?
13:10:32 <Toxaris> Cale: seriously, at the moment, we have no IO at all in \bot
13:10:33 <b_pow> >> let (x:xs) = [3,2,1] in con (x:xs) = (x + (sum xs)) : con xs
13:10:37 <Toxaris> Cale: data IO = ...
13:10:42 <Cale> Toxaris: ah
13:10:48 <geezusfreeek> Cale: what kind of a gadt? one that adds type extra type safety to the _effects_ of io actions?
13:10:55 <conal> abrasive: if you're reading & writing programs, i bet you'll bet better off staying clear of IO, except at the very endpoints.
13:10:56 <Toxaris> Cale: ok, it *is* a bit of work
13:10:59 <Cale> geezusfreeek: Not necessarily
13:11:08 <Cale> geezusfreeek: Just one which makes IO actions less opaque
13:11:08 <conal> abrasive: since functional programming composes much more nicely than imperative.
13:11:10 <b_pow> >> let (x:xs) = [3,2,1] in con (x:xs) = (x + (sum xs)) : con xs
13:11:10 <Cale> something like:
13:11:14 <Cale> data IO a where
13:11:17 <abrasive> conal: yes, that is exactly my plan, i haven't even written any io code yet.
13:11:21 <Cale>    ReturnIO :: a -> IO a
13:11:28 <conal> abrasive: great!
13:11:30 <Cale>    BindIO :: IO a -> (a -> IO b) -> IO b
13:11:41 <Cale>    PutChar :: Char -> IO ()
13:11:42 <geezusfreeek> oh, i see
13:11:44 <abrasive> i may be a haskell newbie, but i do have a rough idea of the Plan :)
13:11:47 <Cale>    GetChar :: IO Char
13:11:48 <b_pow> >> let (x:xs) = [3,2,1] in con ((x +sum xs)) : con xs
13:11:50 <Cale> and so on
13:11:55 <geezusfreeek> that would beâ¦ a massive gadt
13:11:59 <conal> Cale: the monad laws would fail, wouldn't they?
13:12:02 <Cale> Fairly massive.
13:12:03 <b_pow> >> 1 +2
13:12:03 <geezusfreeek> and how would FFI work?
13:12:06 <sclv_> (and then a careful use of lazy IO and you'll even get online processing of your reads "for free")
13:12:11 <conal> Cale: not to mention FFI etc.
13:12:34 <Cale> Yeah, FFI is tricky.
13:12:41 <Cale> You almost need an open datatype for that.
13:12:44 <cpoucet> who needs FFI?
13:12:49 <cpoucet> let's rewrite the world in haskell
13:12:49 <geezusfreeek> i don't think i like that idea
13:12:50 <nomeata> I just wrote a Coroutine monad transformer: http://hpaste.org/7155#a1
13:12:51 <b_pow> why is it my function ain't working
13:13:02 <nomeata> It seems to work, example included in the paste. What do you think?
13:13:04 <Cale> The monad laws would technically fail, but not up to some reasonable equivalence.
13:13:06 <sclv_> nomeata: cool!
13:13:07 <cpoucet> b_pow: one >
13:13:09 <conal> Cale: perhaps the monad laws could hold via smart constructors.
13:13:21 <cpoucet> nomeata: cool
13:13:26 <cpoucet> nomeata: did you look at DelCont?
13:13:30 <geezusfreeek> while it would be nice to bring things like that to the type level, i think it is nicer to not have to deal with it
13:13:43 <b_pow> i tried implementing it in foldr and it given folishness  acc list@(x:xs) = foldr ((:).((x+sum xs)+)) [] list
13:13:46 <geezusfreeek> i think we need more research in GADTs and dependent types in general before really trying to type actions like that
13:13:57 <nomeata> cpoucet: no, where is it?
13:14:02 <Cale> conal: You could also perhaps define return and bind so that they automatically normalise expressions in terms of themselves.
13:14:03 <b_pow> > let (x:xs) = [3,2,1] in con ((x +sum xs)) : con xs
13:14:04 <lambdabot>  Couldn't match expected type `[Sym t]'
13:14:07 <nomeata> (output of the example: http://hpaste.org/7155#a2)
13:14:18 <conal> Cale: yep: smart constructors.
13:14:19 <Cale> conal: Which is basically what you just said :)
13:14:21 <Cale> yeah
13:14:22 <conal> :)
13:14:23 <sclv_> you should maybe call it CoroutineT ?
13:14:32 <sclv_> and be sure to add it to the wiki new monads section!
13:14:48 <b_pow> > let (x:xs) = [3,2,1] in con = ((x +sum xs)) : con xs
13:14:48 <lambdabot>  Parse error at "=" (column 29)
13:14:58 <Cale> There might be a bit of a problem with the opacity of functions there, but I don't know.
13:15:03 <b_pow> > let (x:xs) = [3,2,1] in con (x:xs)= ((x +sum xs)) : con xs
13:15:04 <lambdabot>  Parse error at "=" (column 35)
13:15:07 <geezusfreeek> i don't know why i called that type level
13:15:12 <Cale> Actually, that's not likely much of a problem :)
13:15:36 <geezusfreeek> i misunderstood the ramifications of making it a gadt there
13:15:44 <nomeata> sclv_: yes, the T should be added. but otherwise Iâm not yet sure if itâs any good. maybe I should put it on haskell-cafe for comments
13:15:47 <geezusfreeek> now i see that it would really be a way of rewriting IO actions
13:15:59 <b_pow> >let list@(x:xs) = [3,2,1] in con (x:xs)= ((x +sum xs)) : con xs
13:16:14 <cpoucet> nomeata: can you explain: pause = Coroutine (return (Left (Coroutine (return (Right ())))))
13:16:45 <cpoucet> nomeata: http://www.haskell.org/haskellwiki/Library/CC-delcont
13:16:46 <lambdabot> Title: Library/CC-delcont - HaskellWiki
13:16:54 <nomeata> cpoucet: not really, but the type sytem told me to write that :-)
13:17:06 <b_pow> > let list@(x:xs) = [3,2,1] in con = (((head list) +sum (tail xs)) : con (tail list)
13:17:06 <lambdabot> Unbalanced parentheses
13:17:10 <conal> one could also play this algebraic data type game for lots of types, e.g., numbers & lists.  so i wouldn't expect to want to do something special for the IO type.
13:17:21 <nomeata> cpoucet: I think what it does that start a new unpaused Coroutine (Right ()) inside the paused Coroutine (Left ())
13:17:27 <b_pow> > let list@(x:xs) = [3,2,1] in con = (((head list) +sum (tail xs))) : con (tail list)
13:17:28 <lambdabot>  Parse error at "=" (column 34)
13:17:41 <cpoucet> nomeata: what about the remaining cocntext?
13:17:43 <glguy> > scanl (+) 0 [3,2,1]
13:17:44 <lambdabot>  [0,3,5,6]
13:17:47 <cpoucet> nomeata: how is that 'captured'?
13:17:58 <glguy> > scanr (+) 0 [3,2,1]
13:17:59 <lambdabot>  [6,3,1,0]
13:18:13 <cpoucet> oic
13:18:17 <nomeata> cpoucet: itâs put together correctly by >>=, I think. At least it works somehow :-)
13:18:28 <cpoucet> nomeata: yeah I saw :)
13:18:58 <b_pow> glguy
13:19:04 <b_pow> using foldr
13:19:21 <geezusfreeek> i'm trying to decide if the ability to completely change the side-effects of an IO action using pattern matching like that is beautiful or horrible
13:19:22 <b_pow> i know scan and recursion already
13:19:33 <b_pow> just the foldr that kinda bugging me
13:20:02 <cpoucet> nomeata: you could generalize it a bit
13:20:15 <b_pow> glguy show me using foldr PLEASE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
13:20:21 <cpoucet> b_pow: calm down
13:20:28 <geezusfreeek> @src scanr
13:20:29 <lambdabot> scanr _ q0 []     =  [q0]
13:20:29 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
13:20:29 <lambdabot>     where qs@(q:_) = scanr f q0 xs
13:20:30 <nomeata> cpoucet: in what way?
13:20:37 <conal> geezusfreeek: it sort of shifts from syntactic to semantic.  i'd keep it semantic and add a syntactic layer with a meaning function.
13:20:40 <glguy> b_pow: show you what specifically using foldr?
13:20:47 <conal> geezusfreeek: oops -- i meant shift from semantic to syntactic.
13:20:48 <cpoucet> nomeata: have it return a (a -> Coroutine m a)
13:21:05 <cpoucet> nomeata: have it return a (b -> Coroutine m a)
13:21:07 <geezusfreeek> conal: yeah
13:21:08 <cpoucet> tat way you could do
13:21:11 <cpoucet> x <- pause
13:21:14 <sclv_> for haskell' -- fmap to map, foldr to oldr !?
13:21:18 <cpoucet> and you could pass in values, if desired
13:21:30 <nomeata> cpoucet: interesting. but that would just be yield, right?
13:21:35 <conal> sclv_: and function to unction
13:21:37 <cpoucet> nomeata: sorta, yes :)
13:21:40 <cpoucet> nomeata: my roots are showing
13:21:41 <nomeata> ("just") :-)
13:21:45 <conal> haskell' will be an unctional programming language.
13:22:10 <allbery_b> f that?
13:22:16 <conal> lol
13:22:43 <cpoucet> let's not turn this into a coq discussion
13:22:43 <nomeata> cpoucet: actually for what I need it, I donât need to pass in values. But maybe I should call it PausableT instead
13:22:44 <cpoucet> pleasae
13:23:07 <cpoucet> nomeata: I did something similar for pure values iirc
13:23:10 <nomeata> cpoucet: I could generalize it, and then make a specialized PausableT interfaced based on that.
13:23:31 <nomeata> cpoucet: but maybe later, now I want to use it in my gtk2hs app :-)
13:23:52 <cpoucet> http://hpaste.org/7155#a3
13:24:06 <cpoucet> idea is the same
13:24:10 <cpoucet> I just encode the Either differently
13:24:53 <b_pow> my accumulate functyion
13:24:55 <b_pow> con (x:xs) = (x + (sum xs)) : con xs
13:25:07 <sclv_> forM to orM
13:26:14 <Botje> b_pow: that looks like a scanr
13:26:28 <byorgey> hehe
13:26:34 <tromp> > scanr [1..5]
13:26:35 <lambdabot>  Couldn't match expected type `a -> b -> b'
13:26:36 <b_pow> my teacher said foldr
13:26:37 <byorgey> b_pow: is this a homework assignment?
13:26:50 <tromp> > scanr 0 [1..5]
13:26:51 <lambdabot>        add an instance declaration for (Num (a -> [t] -> [t]))
13:26:52 <glguy> > foldr (\ x (y:ys) -> (x+y):y:ys) [0] [3,2,1]
13:26:52 <lambdabot>  [6,3,1,0]
13:27:04 <byorgey> it definitely is a scanr, but b_pow wants to implement it using foldr
13:27:06 <cpoucet> @quote homework
13:27:07 <lambdabot> vincenz says: sure, give us your homework and we'll email it straight to your teacher :)
13:27:11 <tromp> > scanr (+) 0 [1..5]
13:27:12 <lambdabot>  [15,14,12,9,5,0]
13:27:42 <gnuvince> @src scanr
13:27:42 <lambdabot> scanr _ q0 []     =  [q0]
13:27:42 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
13:27:42 <lambdabot>     where qs@(q:_) = scanr f q0 xs
13:27:46 <glguy> > foldr (\ x ys -> case ys of (z:zs) -> (x+z):ys; _ -> [x]) [] [3,2,1]
13:27:47 <lambdabot>  [6,3,1]
13:28:08 <gnuvince> :t (@)
13:28:09 <lambdabot> parse error on input `@'
13:28:16 <cpoucet> gnuvince: pattern
13:28:24 <gnuvince> cpoucet: first time I've seen that
13:28:29 <glguy> gnuvince: xs@(y:ys) means that xs is y:ys
13:28:38 <b_pow> can u cool down on the lambda calculus
13:28:39 <cpoucet> > let f l@(x:xs) in (l,xs) in f [1..3]
13:28:39 <lambdabot>  Parse error at "in" (column 16)
13:28:45 <b_pow> not at that stage yet
13:28:48 <cpoucet> > let f l@(x:xs) = (l,xs) in f [1..3]
13:28:49 <lambdabot>  ([1,2,3],[2,3])
13:28:49 <b_pow> simpler
13:28:53 <gnuvince> glguy: ah, that's nice
13:28:56 <b_pow>  noob friendly
13:29:08 <sclv_> for haskell' we should make foldl into foldl' and rename the current foldl to foldlYesReallyThisOne
13:29:20 <cpoucet> sclv_: unsafeFoldl
13:29:31 <sclv_> unpleasantFoldl
13:29:35 <glguy> b_pow: we can't know what the constraints of your homework are, you'll need to learn from the examples and write something that fits the requirements
13:29:53 <Zao> unfoldl
13:30:01 <cpoucet> Zao: -l
13:30:17 <cpoucet> :t unfold
13:30:18 <lambdabot> Not in scope: `unfold'
13:30:20 <cpoucet> :t unfoldl
13:30:21 <lambdabot> Not in scope: `unfoldl'
13:30:22 * cpoucet coughs
13:30:23 <cpoucet> :t unfoldr
13:30:25 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
13:30:41 <b_pow> darn
13:30:47 <b_pow> :(
13:37:00 <tromp> > collength 17
13:37:02 <lambdabot>  9
13:37:08 <tromp> > collength 27
13:37:09 <lambdabot>  70
13:38:03 <mauke> > collength 9
13:38:04 <lambdabot>  13
13:38:12 <tromp> @def collist n = takeWhile (/= 1) (iterate collatz n)
13:38:13 <lambdabot> Maybe you meant: bf let
13:38:21 <tromp> @let collist n = takeWhile (/= 1) (iterate collatz n)
13:38:22 <lambdabot> Defined.
13:38:30 <tromp> collist 27
13:38:34 <tromp> > collist 27
13:38:36 <lambdabot>  [27,41,62,31,47,71,107,161,242,121,182,91,137,206,103,155,233,350,175,263,39...
13:38:44 <tromp> max $ > collist 27
13:38:51 <tromp> > max $ collist 27
13:38:52 <lambdabot>  <[Integer] -> [Integer]>
13:39:09 <tromp> > maximum $ collist 27
13:39:10 <lambdabot>  4616
13:39:12 <mauke> > map collength [1..]
13:39:12 <lambdabot>  [0,1,5,2,4,6,11,3,13,5,10,7,7,12,12,4,9,14,14,6,6,11,11,8,16,8,70,13,13,13,6...
13:39:27 <mauke> @oeis 0 1 5 2 4 6
13:39:28 <lambdabot> Number of halving steps to reach 1 in `3x+1' problem.
13:39:28 <lambdabot> [0,1,5,2,4,6,11,3,13,5,10,7,7,12,12,4,9,14,14,6,6,11,11,8,16,8,70,13,13,13,67...
13:40:38 <tromp> > map (maximum . collist) [1..]
13:40:40 <lambdabot>  [Exception: Prelude.maximum: empty list
13:40:48 <tromp> > map (maximum . collist) [2..]
13:40:50 <lambdabot>  [2,8,4,8,8,26,8,26,10,26,12,20,26,80,16,26,26,44,20,32,26,80,24,44,26,4616,2...
13:41:03 <tromp> > drop 20 $ map (maximum . collist) [2..]
13:41:05 <lambdabot>  [26,80,24,44,26,4616,28,44,80,4616,32,50,34,80,36,56,44,152,40,4616,42,98,44...
13:41:13 <mauke> @. oeis run map (maximum . collist) [2..]
13:41:13 <tromp> > drop 40 $ map (maximum . collist) [2..]
13:41:15 <lambdabot> Sequence not found. My pet ferret can type better than you!
13:41:15 <lambdabot>  [42,98,44,68,80,4616,48,74,50,116,52,80,4616,4616,56,98,58,152,80,92,4616,46...
13:42:37 <tromp> @. oeis run map ((*2) . maximum . collist) [2..]
13:42:38 <lambdabot> Sequence not found. This mission is too important for me to allow you to jeop...
13:43:00 <tromp> > drop 60 $ map (maximum . collist) [2..]
13:43:01 <lambdabot>  [4616,4616,64,98,66,152,68,104,80,4616,72,4616,74,170,76,116,152,404,80,122,...
13:43:12 <tromp> > drop 80 $ map (maximum . collist) [2..]
13:43:14 <lambdabot>  [4616,4616,84,128,98,296,88,152,90,4616,92,140,4616,4616,96,4616,98,224,100,...
13:43:18 <Cale> @oeis 42,98,44,68,80,4616,48,74,50
13:43:19 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
13:43:35 <Cale> > map (maximum . collist) [2..]
13:43:36 <lambdabot>  [2,8,4,8,8,26,8,26,10,26,12,20,26,80,16,26,26,44,20,32,26,80,24,44,26,4616,2...
13:43:44 <Cale> @oeis 2,8,4,8,8,26,8,26,10,26,12,20,26,80,16
13:43:44 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
13:43:46 <sclv_> @oeis [42,98,44,68]
13:43:47 <lambdabot> Sequence not found. You speak an infinite deal of nothing
13:43:56 <tromp> > drop 100 $ map (maximum . collist) [2..]
13:43:57 <lambdabot>  [116,4616,104,404,106,4616,4616,4616,4616,4616,112,170,114,260,116,176,152,4...
13:43:58 <sclv_> @oeis [2,4,8,8,26]
13:43:58 <lambdabot> Sequence not found. My pet ferret can type better than you!
13:44:05 <sclv_> @oeis [2,4,8]
13:44:05 <lambdabot> Sequence not found. That's something I cannot allow to happen.
13:44:12 <tromp> hard to get pver 4616
13:44:13 <sclv_> @oeis  2 4 8
13:44:17 <lambdabot> Powers of 2: a(n) = 2^n.
13:44:17 <lambdabot> [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
13:44:27 <sclv_> @oeis 2 8 4 8 8 26
13:44:28 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
13:44:42 <dcoutts> do you suppose this is really necessary...
13:45:30 <tromp> > filter (>4616) $ map (maximum . collist) [2..]
13:45:31 <lambdabot>  [6560,6560,19682,7154,6560,19682,6560,5264,20762,10844,19682,19682,125252,55...
13:45:51 <b_pow> how do the pooly of a number
13:46:22 <sclv_> very carfully
13:46:30 <sclv_> erm, carefully.
13:47:13 <b_pow> poly 2 [1,2,3,4]
13:47:26 <tromp> > [(n,m) | n <- [2..], let m=maximum (collist n),m > 4616]
13:47:27 <lambdabot>  [(255,6560),(383,6560),(447,19682),(495,7154),(510,6560),(511,19682),(575,65...
13:47:38 <cpoucet> spammeriic
13:48:27 <tromp> > [(n,m) | n <- [2..], let m=maximum (collist n),m > 20000]
13:48:28 <lambdabot>  [(639,20762),(703,125252),(871,95498),(937,125252),(959,20762),(1023,59048),...
13:48:51 * cpoucet shoves tromp and cale into a private channel with lambdabot 
13:52:22 <tromp> > (4616/27,125252/703)
13:52:23 <lambdabot>  (170.96296296296296,178.1678520625889)
13:55:47 <tromp> how to filter a list for successively bigger numbers?
13:57:05 <cjb> tromp: when you ask a question, I know it's a trick one :)
13:57:19 <Cale> tromp: nubBy (>) ?
13:57:26 <cpoucet> Cale: won't work
13:57:33 <cpoucet> I think
13:57:36 <Cale> > nubBy (>) [1,2,3,2,4,1,2,5,3,6,2,4]
13:57:36 <lambdabot>  [1,2,3,4,5,6]
13:57:41 <cpoucet> nm
13:57:53 <eugman|college> > replicate 2 2
13:57:55 <lambdabot>  [2,2]
13:58:32 <Cale> > map (join replicate) [0..]
13:58:32 <lambdabot>  [[],[1],[2,2],[3,3,3],[4,4,4,4],[5,5,5,5,5],[6,6,6,6,6,6],[7,7,7,7,7,7,7],[8...
13:58:47 <tromp> nice, Cale, even if  O(n^2)
13:59:05 <tromp> any nice linear time solution?
14:00:36 <cpoucet> sure
14:00:41 <cpoucet> write it yourself ;)
14:00:46 <Cale> hmm, in terms of library functions directly, I don't know.
14:01:20 <Cale> It would be nice if nubBy knew how to take advantage of the fact that it's been given a transitive relation
14:01:51 <tromp> @let incr m []=[]; incr m (x:xs) = if x>m then x:incr x xs else incr m xs
14:01:52 <lambdabot> Defined.
14:01:58 <cpoucet> > let linear [] = []; linear [x] = [x]; linear (x:xs) = x:dolinear x xs; dolinear x [] = []; dolinear x (y:ys) = if x < y then y:dolinear y ys else dolinear x ys in dolinear [1,2,3,4,3,2,1]
14:02:00 <lambdabot>  <[[Integer]] -> [[Integer]]>
14:02:03 <cpoucet> > let linear [] = []; linear [x] = [x]; linear (x:xs) = x:dolinear x xs; dolinear x [] = []; dolinear x (y:ys) = if x < y then y:dolinear y ys else dolinear x ys in linear [1,2,3,4,3,2,1]
14:02:04 <lambdabot>  [1,2,3,4]
14:02:06 <tromp> > incr [1,2,3,2,4,1,2,5,3,6,2,4]
14:02:07 <lambdabot>  <[[Integer]] -> [[Integer]]>
14:02:07 <cpoucet> ;)
14:02:22 <tromp> > incr 0 [1,2,3,2,4,1,2,5,3,6,2,4]
14:02:23 <lambdabot>  [1,2,3,4,5,6]
14:02:26 <cpoucet> @let linear [] = []; linear [x] = [x]; linear (x:xs) = x:dolinear x xs; dolinear x [] = []; dolinear x (y:ys) = if x < y then y:dolinear y ys else dolinear x ys
14:02:27 <lambdabot> Defined.
14:02:37 <cpoucet> > linear . cycle $ [1..5]
14:02:44 <lambdabot>  [1,2,3,4,5
14:03:43 <tromp> well, there must be a way to compose this from library functions:)
14:03:58 <cpoucet> tromp: don't knkow, not many functions that drop arbitrary number of elements
14:04:06 <cpoucet> except filter, which will give you a O(n^2) solution
14:04:14 <quicksilver> you could write it as a fold, I think
14:04:19 <quicksilver> which carries the current maximum along with it
14:04:31 <cpoucet> quicksilver: like (a,[a])
14:04:34 <tromp> yes, need a state carrying fold
14:04:40 <quicksilver> cpoucet: yes, exactly
14:04:47 <quicksilver> followed by map (head . snd)
14:04:52 <quicksilver> to get the 'answer'
14:05:13 <tromp> maybe a scanl to pair every element with max so far
14:05:16 <cpoucet> you still need to specialcase
14:05:31 <tromp> > scanl max 0 [1..6]
14:05:32 <lambdabot>  [0,1,2,3,4,5,6]
14:05:48 <twanvl> > scanl1 max [1..6]
14:05:49 <lambdabot>  [1,2,3,4,5,6]
14:06:17 <tromp> > scanl max 0 [1,2,3,2,4,1,2,5,3,6,2,4]
14:06:18 <lambdabot>  [0,1,2,3,3,4,4,4,5,5,6,6,6]
14:06:47 <tromp> > zip [1,2,3,2,4,1,2,5,3,6,2,4] $ scanl max 0 [1,2,3,2,4,1,2,5,3,6,2,4]
14:06:48 <lambdabot>  [(1,0),(2,1),(3,2),(2,3),(4,3),(1,4),(2,4),(5,4),(3,5),(6,5),(2,6),(4,6)]
14:06:52 <cpoucet> > map head . group . scanl1 max [1,2,3,2,4,1,2,5,3,6,2,4]
14:06:54 <lambdabot>   add an instance declaration for (Num [a])
14:06:58 <cpoucet> > map head . group . scanl1 max $ [1,2,3,2,4,1,2,5,3,6,2,4]
14:06:59 <lambdabot>  [1,2,3,4,5,6]
14:07:23 <cpoucet> > map head . group . scanl1 max $ [1,2,3,2,1,4,1,2,5,3,6,2,4]
14:07:24 <lambdabot>  [1,2,3,4,5,6]
14:07:42 <cpoucet> @src group
14:07:43 <lambdabot> group = groupBy (==)
14:07:46 <cpoucet> @src groupBy
14:07:46 <lambdabot> groupBy _  []       =  []
14:07:46 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
14:07:46 <lambdabot>     where (ys,zs) = span (eq x) xs
14:07:56 <cpoucet> O(n)
14:08:07 <cpoucet> tromp: why zip?
14:08:32 <tromp> thinking wrong direction:(
14:08:52 <cpoucet> just do this
14:08:53 <mauke> cosolution
14:08:56 <cpoucet> > map head . group . scanl1 max $ [1,2,3,2,1,4,1,2,5,3,6,2,4]
14:08:57 <lambdabot>  [1,2,3,4,5,6]
14:09:02 <eugman|college> let utterMadness 1 = 1
14:09:05 <eugman|college> whoops
14:09:10 <eugman|college> > let utterMadness 1 = 1
14:09:11 <lambdabot>  Parse error at end of input
14:09:15 <cpoucet> let ... in ...
14:09:34 <cpoucet> > let utterMadness 1 = 1 in utterMadness 2
14:09:35 <lambdabot>   Non-exhaustive patterns in function utterMadness
14:11:48 <eugman|college> > utterMadness 1 = 1
14:11:49 <lambdabot>  Parse error at "=" (column 16)
14:12:56 <Heffalump> evening
14:15:33 <twanvl> > let utterMadness = True in  1 == 1313793                                                                     `asTypeOf` (0::Word8)
14:15:33 <lambdabot>  True
14:17:13 <quicksilver> twanvl: data MonadRef m s = MonadRef (m s , s -> m() )
14:17:14 <eugman|college> Gah, I fail at defining functions it seems
14:17:26 <tromp> makes you wonder if there's any simple useful function on lists you cant compose from basics
14:17:53 <quicksilver> tromp: foldl and scanl and filter and map are not turing complete, afaik.
14:18:00 <byorgey> twanvl: hahahaha =)
14:18:01 <quicksilver> tromp: add unfold and it is, though.
14:18:22 <quicksilver> tromp: I think excluding unfold you can make anything primitive recursive. not sure.
14:18:27 <quicksilver> unfold gives you general recursion.
14:18:31 <quicksilver> or so my gut tells me.
14:18:53 <dolio> Yep.
14:18:58 <ABoyNamedWooh> I'm having some problems getting stuff to fork properly. Should I hpaste my code, or break down the question?
14:19:09 <dolio> Unless your unfolds only work on codata or something.
14:19:12 <mauke> fork as in forkProcess?
14:19:13 <twanvl> quicksilver: How would you compose these? Maybe you could compose a MonadRef with a normal Ref
14:19:20 <quicksilver> twanvl: yes, you could.
14:19:21 <ABoyNamedWooh> mauke: forkIO
14:19:32 <quicksilver> twanvl: you could (and should!) compose MonadRefs with Refs. To get MonadRefs.
14:19:35 <mauke> ah, threads
14:19:38 <ABoyNamedWooh> yeah
14:19:49 <Cale> ABoyNamedWooh: maybe both?
14:19:50 * shachaf narrows his IRC window to get around twanvl's trickery.
14:19:55 <quicksilver> twanvl: so you can have an 'IORef BigFatState'
14:19:56 <ABoyNamedWooh> ok, sure, let me load it up
14:19:58 <ABoyNamedWooh> @paste
14:19:58 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:20:08 <quicksilver> twanvl: and find inside it a 'MonadRef LittleBitOfState'
14:20:20 <quicksilver> twanvl: via a FRef Big Little
14:20:21 <ABoyNamedWooh> http://hpaste.org/7156
14:20:25 <quicksilver> twanvl: IYSWIM
14:20:32 <ABoyNamedWooh> So here is my goal: a reader that keeps track of timestamps for keystrokes for 10 seconds
14:20:39 <ABoyNamedWooh> then flushes the mvar holding those values
14:20:41 <ABoyNamedWooh> and keeps doing it
14:20:54 <ABoyNamedWooh> I forked 2 threads: one that wakes up in 10 seconds and flushes it, and another that waits x<-getChar
14:21:03 <ABoyNamedWooh> but nothing is happening. I don't think the getChar thread is doing anything
14:21:17 <quicksilver> you probably need to turn off IO buffering
14:21:18 <twanvl> quicksilver: yes. You could also have class MonadState m s where state :: MonadRef m s
14:21:25 <quicksilver> twanvl: yes.
14:21:32 <quicksilver> twanvl: but without the fundep.
14:21:32 <ABoyNamedWooh> Ic urrently have hSetBuffering stdin NoBuffering
14:21:32 <ABoyNamedWooh>           hSetBuffering stdout NoBuffering
14:21:48 <quicksilver> (the fundep it conventionally has)
14:22:18 <twanvl> quicksilver: You still want the fundep
14:22:52 <twanvl> or rather, the associated type
14:24:17 <iamcalvo> help mode
14:25:24 <ello> HELP MODE ACTIVATED
14:26:45 <quicksilver> twanvl: I don't think so. I want my monad to be able to have more than one kind of state.
14:27:12 <quicksilver> twanvl: I might make a cafe post, I have some specific application in mind
14:27:22 <quicksilver> twanvl: It's possible I'm making it more complex than I need to :)
14:27:52 <twanvl> quicksilver: why do you need different kinds of state? Why not just a BigRecordWithAllState type?
14:28:20 <ABoyNamedWooh> if I am trying to fork off a separate thread to handle getChar inputs, are there any pitfalls?
14:28:35 <quicksilver> because I want to conveniently run more specifically typed actions
14:28:41 <quicksilver> inside larger states
14:28:48 <quicksilver> ABoyNamedWooh: no, that's a sensible way to do it
14:28:54 <quicksilver> ABoyNamedWooh: (one thread for reading)
14:28:59 <ABoyNamedWooh> quicksilver: for some reason my input isn't working at all
14:29:05 <quicksilver> multiple threads reading the same Handle probably isn't good.
14:29:14 <ABoyNamedWooh> what do you mean by same handle?
14:29:20 <quicksilver> stdin, in this case.
14:29:25 <ABoyNamedWooh> ohh
14:29:27 <quicksilver> I would only have one thread getChar'ing, normally.
14:29:32 <ABoyNamedWooh> yeah, that's what I have
14:29:38 <gwern> @src isDigit
14:29:38 <lambdabot> Source not found. I feel much better now.
14:29:49 <gwern> @hoogle isDigit
14:29:50 <lambdabot> Data.Char.isDigit :: Char -> Bool
14:30:14 <quicksilver> ABoyNamedWooh: I didn't notice you pasted your code. I'm reading itnow.
14:30:22 <ABoyNamedWooh> ah, thanks very much
14:30:52 <twanvl> class Contains a b where cont :: Ref a b;  myFunction :: (MonadState m s, Contains s Stuff) => ... -> m a
14:31:26 <quicksilver> ABoyNamedWooh: hmm. Your killcode will kill the reading thread every 10 milliseconds
14:31:48 <ABoyNamedWooh> it will?? that would be a problem indeed
14:31:55 <ABoyNamedWooh> for some reason I thought threadDelay was in miliseconds
14:31:58 <ABoyNamedWooh> milliseconds*
14:32:03 <quicksilver> microseconds
14:32:08 <quicksilver> you maybe want another *1000
14:32:09 <quicksilver> ;)
14:32:11 <ABoyNamedWooh> ah
14:32:11 <ABoyNamedWooh> wow
14:32:16 <ABoyNamedWooh> if that fixes it I'm gonna give you a penny
14:32:17 <ABoyNamedWooh> :O
14:32:19 <quicksilver> ;)
14:32:22 <ABoyNamedWooh> real internet dollars!
14:32:23 <ABoyNamedWooh> ;)
14:32:26 <quicksilver> twanvl: yes, you can do that too.
14:32:34 <quicksilver> twanvl: I'm not quite sure what I want :) There's more than one way.
14:32:44 <twanvl> there always is
14:33:10 <quicksilver> twanvl: I don't like the Contains class because a might contain more than one subvalue of type b
14:33:20 <quicksilver> twanvl: I prefer Contains to be a data than a class.
14:33:49 <quicksilver> typeclasses only work well when there is some kind of type-based-uniqueness
14:33:56 <quicksilver> some kind of type-indexed property
14:34:27 <bos> @src mapM
14:34:27 <lambdabot> mapM f as = sequence (map f as)
14:35:07 <sjanssen> @type mapM
14:35:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
14:35:24 <quicksilver> ABoyNamedWooh: there's no real need for the killcode to kilThread itself, either
14:35:39 <quicksilver> ABoyNamedWooh: it might as well just "finish quietly"
14:35:53 <gwern> anyone have any idea how to write a fast isDigit for bytestring?
14:35:59 <gwern> @seen dons
14:36:00 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc and #haskell. I last heard dons speak 39s ago.
14:36:20 <ABoyNamedWooh> quicksilver: I'm getting one last weird thing...the threads only seem to wake up if I hit enter
14:36:28 <ABoyNamedWooh> that is, for my getchar to work, I have to do 1 enter enter
14:36:33 <bos> gwern: where's the difficulty?
14:36:38 <ABoyNamedWooh> and for the thread to wake up and kill itself, I have to randomly hit enter
14:37:07 <sjanssen> gwern: there was a thread about Data.Char.isDigit on the libraries list a while back
14:37:16 <gwern> bos: well, it's straightforward to unpack the bytestring and run data.char.isDigit on entries, but I'm blocked in thinking of a fast short bytestring way
14:37:39 <gwern> sjanssen: ok, I'll look at that - was it about stringable/bytestring specifically?
14:37:43 <sjanssen> gwern: why unpack, can't you use Data.ByteString.head?
14:37:45 <bos> gwern: what do you want to do? filter?
14:37:57 <sjanssen> gwern: no, it was only about isChar (how it is slower than necessary)
14:38:06 <gwern> bos: no, it's a boolean test - map isDigit str
14:38:20 <ABoyNamedWooh> quicksilver: is there a way to force it to look (maybe eating say 50% cpu) instead of waiting for a keystroke to do so?
14:38:41 <bos> just write an isDigit for Word8, which should get you something fast enough
14:38:53 <ABoyNamedWooh> or to at least keep listening instead of needing a straight up enter to wake up
14:39:10 <bos> > let isDigitWord8 p = p >= 0x30 && p <= 0x39
14:39:11 <lambdabot>  Parse error at end of input
14:39:36 <bos> > let isDigitWord8 p = p >= 0x30 && p <= 0x39 in p (ord 'x')
14:39:39 <lambdabot>  Couldn't match expected type `Int -> t'
14:39:41 <gwern> bos: hm. I'm not familiar with word8 literals
14:39:45 <bos> > let isDigitWord8 p = p >= 0x30 && p <= 0x39 in isDigitWord8 (ord 'x')
14:39:48 <lambdabot>  False
14:39:51 <bos> > let isDigitWord8 p = p >= 0x30 && p <= 0x39 in isDigitWord8 (ord '3')
14:39:52 <lambdabot>  True
14:40:02 <bos> gwern: just use numbers
14:43:03 <adiM> @pl distortion2 x y = 0.5* (distortion1 x y)
14:43:03 <lambdabot> distortion2 = ((0 . 5 *) .) . distortion1
14:43:36 <tromp> > (1 :: Word8) - (2 :: Word8)
14:43:38 <lambdabot>  255
14:44:12 <Jaak> let distortion2 = (/ 2) .: distortion1
14:44:18 <tromp> let isDigitWord8 = (<10).(-0x30)
14:44:21 <Jaak> i think
14:44:27 <Bonus> how do i make a derivable class?
14:44:33 <quicksilver> ABoyNamedWooh: sounds like your terminal is in line mode
14:44:35 <adiM> Thanks jaak
14:45:15 <ABoyNamedWooh> quicksilver: hmm, but would that explain why for the thread that has threadDelay of 10 seconds it only wakes up and flushes the MVar if I hit enter?
14:45:27 <Jaak> @type let distortion1 = undefined; (.:) = (.).(.) in (/2) .: distortion1
14:45:42 <lambdabot> thread killed
14:46:02 <Jaak> even lambdabot rejects me :P
14:46:12 <quicksilver> ABoyNamedWooh: yeah, the terminal doesn't even give the input to the underlying process unless you turn off line mode
14:46:18 <ABoyNamedWooh> ohh
14:46:19 <quicksilver> ABoyNamedWooh: I can't remember how to do that in haskell
14:46:19 <ABoyNamedWooh> wow
14:46:22 <ABoyNamedWooh> hmm
14:46:31 <ABoyNamedWooh> oh so it's a haskell thing, not a cygwin or cmd prompt thing?
14:46:32 <quicksilver> worse than that I can't remember what phrase to google for even
14:46:36 <quicksilver> 'raw' or 'cooked'
14:46:44 <quicksilver> no, it's a cygwin/unix/command prompt thing
14:46:46 <quicksilver> not haskell
14:47:19 <krokodil_> hi. I need some help with Haskell problem related to Monads. It is blocking my project and I am looking for someone who is willing to spend an hour with me in chat one-to-one and help to solve it. msg me if you are interested.
14:47:20 <ABoyNamedWooh> ah, yeah, because on my friend's linux box I think his prompt is not in line mode
14:47:40 <shachaf> krokodil_: Why not just ask in the IRC channel?
14:47:49 * atsampson nods at shachaf
14:48:19 <krokodil_> schachaf: I tried already, it is kind of long discussion and involves more than a snippet of code
14:48:25 <quicksilver> ABoyNamedWooh: it's called putting the terminal in 'raw' mode
14:48:36 <ABoyNamedWooh> ah
14:48:50 <krokodil_> it is just a small part of my project and I need to move forward and this stuff blocks me
14:49:00 <ABoyNamedWooh> I am googling furiously now
14:49:13 <quicksilver> there is stuff in System.Posix.Terminal to fix it
14:49:21 <quicksilver> but that won't work on windows I guess
14:49:47 <ABoyNamedWooh> oh, so you can have haskell actually force it not to be in that mode?
14:49:52 <shachaf> It's probably not very likely that someone will do that without even knowing what the problem is. :-)
14:50:09 <ABoyNamedWooh> quicksilver: so I can either fix it on the cygwin end or the haskell end?
14:50:16 <shachaf> krokodil_: Or at least the general idea. It's bigger than what'd fit in @paste?
14:50:22 <quicksilver> there ought to be a call to sort it, yes
14:50:26 <quicksilver> but I'm not sure what
14:50:31 <ABoyNamedWooh> hmmm
14:50:34 <quicksilver> ABoyNamedWooh: if you can't work it out, ask haskell-cafe
14:50:56 <quicksilver> see http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Terminal.html
14:50:57 <ABoyNamedWooh> I don't want them to facecrush me haha
14:51:00 <lambdabot> http://tinyurl.com/2786zp
14:51:02 <quicksilver> but I don't think that works in Windows
14:51:02 <krokodil_> I am even willing pay a bit for small private chat tutroing session on this :)
14:51:14 <tromp> http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html
14:51:16 <lambdabot> Title: TIOBE Software: The Coding Standards Company
14:51:31 <tromp> top 20 programming languages....
14:51:40 <ABoyNamedWooh> yeah, quicksilver, system.posix.terminal doesn't exist for me
14:52:45 <shachaf> krokodil_: You could just mention what the problem is. "Monads" is very general (in fact, that's the point of them in the first place :-) ).
14:53:29 <ABoyNamedWooh> quicksilver: would you say this problem is hard enough to ask haskell-cafe or will they yell at me?
14:54:17 <krokodil_> shachaf: I have some haskell library, 3rd party which I could not modify. I would like to use monad to pass some information through the coputations perfomed by it.
14:54:53 <bos> krokodil_: you may or may not be able to do that.
14:55:07 <gwern> tromp: TIOBE is a standing joke
14:55:17 <krokodil_> shachaf: I made some progress, but I there are some unsolved issues. The library is designed to be extnded in this manner.
14:55:51 <atsampson> krokodil_: this is Lava you're talking about?
14:55:56 <krokodil_> right
14:56:12 <krokodil_> atsampson: Lava it is
14:56:32 <krokodil_> I am trying to implement kind of Symbolic interpretation
14:58:34 <atsampson> what have you tried since yesterday? (even if it's not working yet...)
14:58:43 <b_pow> any help with the poly??
14:59:05 <b_pow> poly 2 [1,2,3,4]
14:59:18 <b_pow> f (x) = x3 + 4x2 + 3x + 2
14:59:33 <b_pow> poly 2 [1,4,3,2] -> 32
14:59:52 <krokodil_> atsampson: I traced back from my idea of modifying function results from the monad. Now I use monad to carry some infromation, but I need to access it from outside at some point
15:00:29 <ABoyNamedWooh> @help poly
15:00:29 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:00:32 <ABoyNamedWooh> list
15:00:34 <ABoyNamedWooh> @list
15:00:35 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
15:00:37 <krokodil_> I am basically trying to build call trace, listing calls with arguments
15:00:54 <ABoyNamedWooh> @type poly
15:00:58 <Cale> b_pow: Note that x^3 + 4*x^2 + 3*x + 2 is the same as ((1*x + 4)*x + 3)*x + 2
15:01:10 <lambdabot> thread killed
15:01:17 <Cale> Or even...
15:01:29 <Cale> ((0*x + 1)*x + 4)*x + 3)*x + 2
15:01:32 <krokodil_> so code like this: http://hpaste.org/7157 returns now  Wiring (-1) (-4) [Operation CAnd [1,2],Operation CAnd [2,3],Operation COr [-1,-1]]
15:02:24 <Cale> > foldl (\a b -> a*x + b) 0 [1,4,3,2]
15:02:34 <Cale> ...
15:02:39 <lambdabot>  thread killed
15:02:43 <Cale> @undef
15:02:49 <lambdabot> Undefined.
15:02:51 <Cale> > foldl (\a b -> a*x + b) 0 [1,4,3,2]
15:02:53 <lambdabot>  (((0 * x + 1) * x + 4) * x + 3) * x + 2
15:03:14 <Cale> So it's a left fold.
15:03:42 <tromp> it makes more sense to let head be the least significant
15:03:56 <Cale> This is true :)
15:03:57 <tromp> and use a right fold
15:04:03 <tromp> then addition is easier too
15:04:53 <tromp> zip [] [0]
15:04:58 <tromp> > zip [] [0]
15:05:04 <Cale> zip doesn't quite work out for that
15:05:05 <Jaak> []
15:05:10 <lambdabot>  []
15:05:20 <tromp> right; need to pad shorter list with 0s
15:06:19 <gwern> :t read
15:06:23 <lambdabot> forall a. (Read a) => String -> a
15:09:37 <gwern> damnation. there is no read for ByteString
15:09:50 <gwern> that must be where the problem is, the String -> a part
15:10:34 <dons> Data.Binary is the read for bytestring (excepting readInt/readInteger)
15:10:57 <gwern> isn't Data.Binary a separate package?
15:11:49 <gwern> dons: actually, a readInt would be good, where's that?
15:11:55 <gwern> @hoogle readInt
15:12:05 <lambdabot> Numeric.readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
15:12:05 <lambdabot> Data.ByteString.Char8.readInt :: ByteString -> Maybe (Int, ByteString)
15:12:05 <lambdabot> Data.ByteString.Lazy.Char8.readInt :: ByteString -> Maybe (Int, ByteString)
15:14:53 <gwern> does 'read' throw an exception if there's a bad parse?
15:15:06 <ddarius> > read "adr" :: Int
15:15:21 <lambdabot>  thread killed
15:15:26 <ddarius> > read "adr" :: Int
15:15:29 <lambdabot>  Exception: Prelude.read: no parse
15:16:09 <Jaak> @type reads
15:16:11 <lambdabot> forall a. (Read a) => String -> [(a, String)]
15:16:27 <Jaak> use that instead if you don't want exceptions to happen
15:16:58 <Jaak> > reads "adr" :: [(Int, String)]
15:17:11 <lambdabot>  []
15:17:14 <gwern> no, I'm duplicating read with readInt, but readInt uses Maybe for error handling
15:17:57 <gwern> eh. I'll continue this later
15:20:43 <Cale> lambdabot seems kind of slow at the moment...
15:20:56 <Cale> I wonder what code.haskell.org is up to...
15:20:57 <ddarius> Cale: That's a bit rude
15:21:37 <Bonus> can | be used in function names?
15:21:44 <bos> no
15:21:48 <Bonus> welp
15:22:01 <Bonus> ah yeah of course it's the syntax for guards
15:22:15 <dons> ?let (.|') = x / y
15:22:16 <lambdabot>  Improperly terminated character constant
15:22:25 <dons> ?let (.|^) = x / y
15:22:28 <lambdabot> Defined.
15:22:29 <krokodil_> I have cleaned up my code and here is a condensed version: http://hpaste.org/7158
15:22:35 <dons> > 1 .|^ 2
15:22:37 <lambdabot>  Couldn't match expected type `t1 -> t2 -> t'
15:22:43 <Bonus> ooh
15:22:49 <dolio> @type (.) . ((.) . (.) .)
15:22:50 <lambdabot>     The operator `.' [infixr 9] of a section
15:22:50 <lambdabot>         must have lower precedence than the operand `(.)' [infixr 9]
15:22:50 <lambdabot>         in the section: `((.) . (.) .)'
15:22:56 <OceanSpray> lemme get something straight...
15:22:58 <dons> ?undefine
15:22:59 <lambdabot> Undefined.
15:23:03 <dolio> @type (.) . (((.) . (.)) .)
15:23:04 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *) a1 b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => (a -> a1 -> b) -> f a -> f (f1 (f2 a1) -> f1 (f2 b))
15:23:12 <OceanSpray> dependent types let you say something like
15:23:16 <Bonus> i was thinking about how useful a function of, say f (|) g = g . f
15:23:17 <krokodil_> the problem I have in how to define 'newVar'
15:23:26 <Bonus> would be
15:23:39 <dolio> I think | is reserved.
15:23:45 <OceanSpray> "A a is of type T if a is of type B"
15:23:49 <dolio> There's already (>>>).
15:23:49 <tromp> > let (*|*) = (+) in 1 *|* 2
15:23:51 <lambdabot>  3
15:23:57 <Bonus> >>> does that?
15:24:01 <dolio> Yeah.
15:24:10 <Bonus> in which module is it defined?
15:24:11 <OceanSpray> now, does the
15:24:13 <dolio> For general arrows, even (of which functions are a special case).
15:24:21 <OceanSpray> ...alright, nevermind.
15:24:56 <byorgey> Bonus: Control.Arrow
15:25:14 <Bonus> ah
15:25:15 <Bonus> kewl
15:26:09 <dolio> > let (|) a b = a + b in 5 | 6
15:26:09 <lambdabot>  Parse error at "|)" (column 6)
15:26:21 <dolio> Yep.
15:26:23 <Bonus> but i recon . is prefered to use in code instead of >>>
15:26:53 <dolio> >>> is longer. :)
15:27:21 <dolio> >>> does have some precedence benefits if you're working with other arrow combinators, as I recall.
15:27:30 <Bonus> ah
15:27:33 <dolio> Or, at least, it works differently than .
15:27:44 <Cale> :t (>>>)
15:27:45 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
15:27:51 <Cale> :t (<<<)
15:27:52 <lambdabot> forall (a :: * -> * -> *) c d b. (Arrow a) => a c d -> a b c -> a b d
15:28:06 <dolio> @type fst &&& snd . snd
15:28:07 <lambdabot> forall a a1 b. (a, (a1, b)) -> (a, b)
15:28:21 <dolio> @type snd >>> fst &&& snd
15:28:22 <lambdabot> forall a a1 b. (a, (a1, b)) -> (a1, b)
15:28:52 <krokodil_> ok, no luck here. I guess I will give up on Lava and use simple data structures of my own.
15:29:13 <dolio> That's "(fst) &&& (snd . snd)" and "(snd) >>> (fst &&& snd)"
15:29:48 <Bonus> hmmm
15:30:36 <dolio> So you can probably write: "f . g &&& h . g >>> i" and get "((f . g) &&& (h . g)) >>> i".
15:30:44 <dolio> And suchlike.
15:30:50 <Bonus> ah, interesting
15:31:10 <dolio> And require readers to do lots of mental precedence checking gymnastics. :)
15:31:43 <Arnar> hey folks
15:31:43 <Bonus> hehe yeah, i'm generally against cryptic code
15:32:03 <dons> what about crypto code?
15:32:17 <dolio> @type fst *** snd &&& snd *** fst
15:32:18 <lambdabot> forall a b a1 b1 a2 b2. ((a, b), ((a1, b1), (a2, b2))) -> (a, ((a2, b2), (b1, a2)))
15:32:18 <Bonus> haha
15:32:29 <conal> "cryptic" is fluid
15:32:30 <ddarius> @free (&&&)
15:32:30 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
15:32:56 <dolio> @type (fst *** snd) &&& (snd *** fst)
15:32:57 <lambdabot> forall a b a1 b1. ((a, b), (a1, b1)) -> ((a, b1), (b, a1))
15:33:29 <byorgey> http://wso.williams.edu/~byorgey/diagrams/diagram2.html   more progress! =D
15:34:44 <Arnar> I'm a little confused where/when I can use when-clauses.. is there a more concise reference than the hs98 report somewhere?
15:35:04 <conal> Arnar: "where" clauses?
15:35:07 <Jaak> byorgey: sweet
15:35:20 <byorgey> Jaak: thanks =)
15:35:29 <conal> Arnar: where is part of the syntax of definitions, not expressions.
15:35:37 <Arnar> conal: ah, ok
15:35:55 <Arnar> also, I want to do sth. like this -> http://hpaste.org/7159
15:36:02 <Arnar> which is obviously not legal
15:36:28 <conal> Arnar: yeah -- use where
15:36:52 <Bonus> yeah i think where is generally used to define functions and let is used to define variables
15:36:55 <Bonus> that's how i see it
15:37:01 <Bonus> but probably someone will correct me soon :)
15:37:04 <Arnar> conal: ok.. wanted to avoid that since the ... part is pretty long -- would move the def. way below the guards
15:37:15 <Arnar> s/def./def. of node/
15:37:38 <Bonus> how about you just define that function above the astar' function?
15:37:42 <conal> Bonus: do you mean defining names (variables) for functions vs for non-functions?
15:37:51 <Bonus> yeah
15:38:09 <mauke> let ... in case () of _ | cond1 -> ... | cond2 -> ...
15:38:30 <Arnar> ok.. so "let vars in expr" and "fun p1 p2 p3 = ... where ..."
15:39:14 <Arnar> mauke: ok.. there's no real difference between definition guards and using a case ?
15:39:21 <Bonus> there is
15:39:31 <mauke> definitions are just syntactic sugar for case
15:39:38 <ddarius> ferrers = hsep 3 . map (vsep 3 . flip replicate (circle 10)
15:39:39 <Arnar> ok
15:39:40 <ddarius> )
15:39:41 <Bonus> guards just test to see if the expression evaluates to True
15:39:46 <Bonus> whereas you can pattern match with case
15:40:36 <conal> though now there are pattern guards
15:40:44 <Bonus> rly?
15:40:51 <conal> yes, in ghc
15:41:06 <Bonus> gotta test that out
15:41:07 <conal> foo x | Just z <- x = ... z ...
15:47:02 <jberg> is there some unique function in haskell which removes duplicates from a list?
15:47:12 <conal> @type nub
15:47:13 <lambdabot> forall a. (Eq a) => [a] -> [a]
15:47:26 <jberg> nub [1, 2, 3, 3, 2]
15:47:33 <jberg> > nub [1, 2, 3, 3, 2]
15:47:33 <lambdabot>  [1,2,3]
15:47:37 <jberg> thanks :)
15:47:40 <conal> :)
15:47:43 <jberg> what does nub stand for?
15:48:07 <conal> i don't know.  anyone?
15:48:17 <dolio> "nub" means "essence" apparently.
15:48:27 <ddarius> @wn nub
15:48:27 <lambdabot> *** "nub" wn "WordNet (r) 2.0"
15:48:27 <lambdabot> nub
15:48:27 <lambdabot>      n 1: a small lump or protuberance [syn: {nubble}]
15:48:27 <lambdabot>      2: a small piece; "a nub of coal"; "a stub of a pencil" [syn: {stub}]
15:48:27 <lambdabot>      3: the choicest or most essential or most vital part of some
15:48:29 <lambdabot> [5 @more lines]
15:48:38 <conal> oh! :)
15:48:42 <Jaak> byorgey: is there source/api available that i can browse?
15:48:44 <conal> lambdabot++
15:48:45 <jberg> hehe okay
15:48:54 <jberg> why not go for unique?
15:49:13 <ddarius> jberg: I believe the term comes from older languages, Prolog or something.
15:49:17 <Arnar> ok.. one more scoping problem -> http://hpaste.org/7160
15:49:20 <jberg> ah ok
15:49:48 <Arnar> the addToOpen guy uses "node", which is defined in the let above (which has narrower scope)
15:50:09 <Arnar> can I bring the definition of addToOpen into that scope somehow?
15:50:35 <conal> Arnar: yes.  push it into the let with node, newstates, etc.
15:51:13 <conal> Arnar: and you could use (another) where instead of let there.
15:51:39 <Saizan_> or you could make addToOpen take "node" as a parameter and pass it normally
15:51:47 <conal> Arnar: i.e., "otherwise = astar' (d+1) open' closed' where node = ...."
15:52:19 <conal> Arnar: Saizan_'s suggestion might give you cleaner-looking code.
15:53:14 <Arnar> conal: ah.. like this
15:53:16 <Arnar> http://hpaste.org/7160#a1
15:53:50 <Arnar> Saizan_: oh right.. good idea.. foldl (addToOpen node) open newstates..
15:53:56 <Arnar> might look cleaner that way
15:54:17 <Arnar> thanks both
15:54:23 <conal> Arnar: yeah, like that.  or a where
15:54:32 <Arnar> conal++ Saizan_++
15:54:36 <wellwisher> I need some help with http://hpaste.org/7161
15:54:39 <conal> :)
15:54:48 <nomeata> I have described my CoroutineT monad transformer here: http://www.joachim-breitner.de/blog/archives/291-Pausable-IO-actions-for-better-GUI-responsiveness.html and now itâs time to go to bed â too late already, damn this exiting haskell stuff :-)
15:54:49 <lambdabot> Title: Pausable IO actions for better GUI responsiveness - nomeataâs mind shares, http://tinyurl.com/6cl3x6
15:54:56 <conal> @karma
15:54:56 <lambdabot> You have a karma of 3
15:55:03 <glguy> @type (.)
15:55:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:55:06 <conal> hey -- didn't increment
15:55:10 <glguy> ?karma- lambdabot
15:55:10 <lambdabot> lambdabot's karma lowered to 1.
15:55:14 <geezusfreeek> @karma
15:55:14 <lambdabot> You have a karma of 0
15:55:17 <geezusfreeek> aw :(
15:55:34 <dolio> @karma Saizan_
15:55:34 <lambdabot> Saizan_ has a karma of 1
15:55:45 <dolio> @karma Saizan
15:55:45 <lambdabot> Saizan has a karma of 6
15:55:48 <glguy> @karma emertens
15:55:49 <lambdabot> emertens has a karma of 2
15:57:00 <ddarius> @karma
15:57:00 <lambdabot> You have a karma of 8
15:57:06 <Bonus> @karma
15:57:06 <lambdabot> You have a karma of 0
15:57:07 <Bonus> kewl
15:57:12 <lament> awesome
15:57:26 <tensh> @karma
15:57:27 <lambdabot> You have a karma of 1
15:57:30 <tensh> :)
15:57:31 <ddarius> @karma audreyt
15:57:31 <lambdabot> audreyt has a karma of 116
15:57:35 <Bonus> lol
15:57:51 <ddarius> @karma lwall
15:57:51 <lambdabot> lwall has a karma of 74
15:57:53 <Bonus> how does that work
15:57:56 <ddarius> @karma Cale
15:57:56 <lambdabot> Cale has a karma of 74
15:58:00 <ddarius> Nice Cale
15:58:01 <johnnowak> @karma
15:58:01 <lambdabot> You have a karma of 0
15:58:04 <johnnowak> balls
15:58:18 <Jaak> @karma
15:58:18 <lambdabot> You have a karma of 1
15:58:21 <mauke> @karma
15:58:22 <lambdabot> You have a karma of 10
15:58:26 <Jaak> uh... when did that happen...
15:58:34 <dolio> Arnar: I wrote an A* implementation here, if you want to compare code: http://haskell.org/haskellwiki/Haskell_Quiz/Astar/Solution_Dolio
15:58:45 <Bonus> off to bed!
15:59:05 <wellwisher> Could someone help me with hpaste #7161?
16:00:50 <cpoucet> @karma
16:00:51 <lambdabot> You have a karma of 0
16:00:56 <vincenz> @karma
16:00:57 <lambdabot> You have a karma of 20
16:01:43 <glguy> @karma
16:01:43 <lambdabot> You have a karma of 51
16:02:10 <lament> @shwarma
16:02:10 <lambdabot> Unknown command, try @list
16:02:20 <lament> damn, i'll try some other dish
16:02:21 <lament> @korma
16:02:21 <lambdabot> You have a karma of 2
16:02:25 <awesame> wellwisher: I think the problem is the case where one of at or st is [], but the other isn't
16:02:50 <awesame> you cover the case where they're both [], and then the case where they both have a head
16:02:50 <wellwisher> ok
16:04:09 <Arnar> dolio: excellent.. thanks
16:07:45 <wellwisher> i think i found the problem
16:07:59 <Arnar> dolio: do you handle the case when you encounter a node that is already on the open list with a lower cost?
16:08:10 <wellwisher> init [] throws an exception instead of return []
16:09:02 <solrize> @karma
16:09:02 <lambdabot> You have a karma of 0
16:09:12 <Jaak> @karma karma
16:09:12 <lambdabot> karma has a karma of 5
16:09:22 <solrize> @karma chameleon
16:09:22 <Jaak> meta-karma
16:09:22 <lambdabot> chameleon has a karma of 2
16:09:40 <lament> karma--
16:09:44 <solrize> @modify (+1) chameleon
16:09:44 <lambdabot> Unknown command, try @list
16:09:51 <saml> @saml++
16:09:51 <lambdabot> Unknown command, try @list
16:16:12 <Arnar> @pl \ (pq,_) -> snd $ findMin pq
16:16:13 <lambdabot> snd . findMin . fst
16:16:56 <Arnar> I'm running GOA.. the lambdabot process dies occasionally, which is fine since I just call wakeup.. but I have to call setLambdabotHome every time
16:16:59 <Arnar> is that normal?
16:17:08 <Arnar> always seems to look for lambdabot in .
16:19:23 <Saizan_> maybe you can put that in .ghci?
16:19:31 <Arnar> Saizan_: it is there..
16:19:43 <Arnar> both setLambdabotHome and wakeup..
16:19:48 <Arnar> lambdabot starts up fine with ghci
16:20:12 <Arnar> but since my ghci session inside emacs runs for hours (or even days) - it loses the lambdabot process
16:20:23 <Arnar> I don't mind calling wakeup
16:20:44 <Arnar> but the path to lambdabot is long so setLambdabotHome is tedious to look up in the history every time
16:20:57 <Saizan_> i see
16:23:06 <TomMD> @src fromIntegral
16:23:07 <lambdabot> fromIntegral = fromInteger . toInteger
16:23:31 <MyCatVerbs> Put "let wakeUpYouGoddamnBot = wakeup >> setLambdabotHome ..." in .ghci?
16:23:59 <Botje> .oO(drLambdaBot in emacs)
16:24:19 <Arnar> MyCatVerbs: yeah.. good idea. Still think it's a bug not to remember the path :)
16:25:08 <cpoucet> sjanssen: ping
16:25:17 <sjanssen> pong
16:25:21 <MyCatVerbs> Arnar: true. I'm only suggesting a bad workaround, after all.
16:25:22 <cpoucet> sjanssen: got a websie?
16:25:30 <sjanssen> cpoucet: no, not really
16:25:36 <cpoucet> sjanssen: anywhere I can link?
16:26:05 <sjanssen> cpoucet: you can use my email address if you'd like
16:26:12 <cpoucet> sjanssen: well it's to link to you in my blog entry
16:26:15 * sjanssen is suddenly curious what is going on
16:26:17 <sjanssen> ah
16:26:17 <cpoucet> regarding the earlier dscussion
16:26:36 <sjanssen> no link is fine too
16:26:43 <orzo> HI
16:28:22 <orzo> I need to handle a bunch of cases for a Dynamic object
16:28:53 <orzo> I could use fromDynamic and next the case ..of operator
16:28:56 <orzo> but that's ugly
16:29:05 <orzo> what's a nice way to write this?
16:29:27 <sjanssen> orzo: you need to check it against many different types?
16:29:52 <byorgey> Jaak: not yet, I'm still developing it
16:29:55 <byorgey> there will be soon
16:30:37 <orzo> sjanssen, right
16:30:55 <orzo> well, maybe around 5 types
16:31:11 <mauke> PatternGuards!
16:32:46 * BMeph Nods appreciatively at mauke
16:33:08 <ddarius> Pattern guards do make a decent typecase
16:33:50 <orzo> i could use a mapM_ on a list of cases
16:35:04 * BMeph shakes his head sadly at orzo's reluctance to do things "imperatively"...
16:35:18 <orzo> heh
16:35:30 <orzo> i just dont want nested case..of stuff
16:35:40 * BMeph meant "to do things other than 'imperatively'"
16:35:41 <orzo> i don't mind imperative
16:35:41 <mauke> why nested?
16:36:41 <orzo> case fromDynamic d :: Integer of { ... Nothing -> case fromDynamic d :: [Dynamic] of { ...
16:36:45 <BMeph> I.e., why not use pattern guards, >wink, wink<, (he said Knowingly)...
16:37:43 <mauke> case () of _ | Just i <- fromDynamic d -> ... | Just ds <- fromDynamic d -> ...
16:40:00 <sjanssen> orzo: http://hpaste.org/7163
16:41:29 <sjanssen> Data.Monoid ftw
16:42:38 <mauke> Data.Monoid++
16:43:10 * BMeph isn't feeling the "Data.Monoid" love today...
16:43:56 <sjanssen> @karma Data.Monoid
16:43:56 <lambdabot> Data.Monoid has a karma of 1
16:44:02 <sjanssen> Data.Monoid++
16:45:33 <saml> @where monoid
16:45:34 <lambdabot> I know nothing about monoid.
16:45:45 <mauke> @src Monoid
16:45:45 <lambdabot> class Monoid a where
16:45:45 <lambdabot>     mempty  :: a
16:45:45 <lambdabot>     mappend :: a -> a -> a
16:45:45 <lambdabot>     mconcat :: [a] -> a
16:49:44 <cpoucet> :i Monoid
16:50:41 <cpoucet> What do you call a Monoid without empty?
16:51:03 <gwern> half-full
16:51:19 * gwern giggles uncontrollably
16:51:24 * cpoucet thwaps gwern 
16:51:36 <tibbe> @src MonadPlus
16:51:37 <lambdabot> Source not found. I am sorry.
16:51:52 <mauke> a magma?
16:52:06 <tibbe> @src MonadZero
16:52:06 <lambdabot> Source not found. You speak an infinite deal of nothing
16:54:39 <wagle> @src MonadSchmonad
16:54:39 <lambdabot> Source not found. Are you on drugs?
16:56:51 <gwern> ah, it's a pity old Parsecs didn't use ByteString
16:57:30 <gwern> fortunately, I believe stuff like 'packString ""' will get turned into a bytestring constant at compile time
17:00:00 <yav> :q
17:07:25 <orzo> thanks sjanssen
17:21:47 <vgax> hello can someone help me with the following code http://hpaste.org/7164
17:22:22 <vgax> runs really really slow (because i'm using lists) but i don't know how else to do it
17:23:49 <mauke> > (13 * 4) ^ 5
17:23:51 <lambdabot>  380204032
17:23:56 <vgax> anyone?
17:24:06 <mauke> main = print 380204032
17:24:11 <dons> vgax: looking
17:24:16 <conal> vgax: looks good to me, if you really want to enumerate the possibilities.
17:24:27 <vgax> thanks
17:24:36 <dons> did you compile it, or run it in ghci?
17:24:38 <vgax> yeah but its way to slow
17:25:13 <vgax> i compiled with -ml-windows and it doesn't seems to work
17:25:34 <Cale> vgax: That's not slow because of lists, but because it's actually enumerating all the possibilities.
17:25:35 <vgax> gives me hCharPut error
17:25:53 <vgax> anyway in the console it never finishes
17:26:08 <vgax> Cale: c code takes less then a second
17:26:09 <sjanssen> vgax: do you realize how many possiblities there are?
17:26:18 <conal> vgax: 380204032 is a big number
17:26:26 <vgax> yes
17:26:36 <conal> vgax: did you compile with -02?
17:26:39 <dons> :)
17:26:41 <mauke> I'd like to see the C code
17:26:57 <conal> i'd expect ghc to do a bang-up job on this code.
17:27:08 <dons> yeah
17:27:09 <vgax> c code is just 5 nested for loops
17:27:34 <dons> at least it runs in constant space
17:27:35 <conal> dons: could we expect ghc to fuse vgax's code into nested loops?
17:27:44 <dons> yeah
17:27:50 <dons> its classic build/foldr-able
17:27:52 <mauke> vgax: does it shuffle linked lists around?
17:27:57 <dons> $ time ./A
17:27:57 <dons> "Count 5 Card Permutations\n"
17:27:57 <dons> 380204032
17:27:58 <dons> ./A  14.72s user 0.37s system 99% cpu 15.099 total
17:27:58 <Cale> vgax: Also, just so you know, there are tabs in your code
17:28:00 <vgax> and an array of cards all 53 are given
17:28:02 <dons> 15 seconds seems ok
17:28:15 <vgax> so c has almost no overhead in mem
17:28:25 <dons> well, the haskell one also runs in constant space.
17:28:52 <vgax> dons: the haskell one is not even evaluating the hand strength
17:28:55 <dons> http://hpaste.org/7164#a1
17:29:16 <dons> shows how to make it a bit shorter.
17:29:45 <conal> dons: i like the .., but why the "do"?
17:29:45 <vgax> ooh cool
17:29:54 <dons> oh, that was in the original
17:30:06 <conal> oh
17:30:27 <Cale> http://hpaste.org/7164#a2
17:30:28 <sjanssen> liftM5 (,,,,) cards cards cards cards cards
17:30:28 <conal> to get even shorter, liftA2 (,) and liftA5 (,,,,)
17:30:33 <conal> !
17:30:34 <vgax> i didn't know you could use .. on you own data types
17:30:36 <Cale> replicateM 5 cards
17:30:41 <vgax> your*
17:30:49 <conal> oooh, good one, Cale
17:31:05 <conal> though different representation.
17:31:12 <dons> oh, the 'length' doesn't fuse.
17:31:24 <conal> too bad :(
17:31:25 <vgax> >:type replicateM
17:31:45 <conal> @type replicateM
17:31:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
17:31:53 <sjanssen> also, there is a good chance GHC will try to cache listPermutations
17:32:01 <vgax> what do you mean the length doesn't fuse?
17:32:11 <dons> oh, its an optimisation. let me se...
17:32:11 <sjanssen> (I think only ghc -O will avoid that)
17:32:47 <vgax> can you test it for me with full optimization
17:33:02 <conal> dons: do you know why length doesn't fuse?
17:33:09 <dons> yeah, its a left fold
17:33:29 <dons>     8 fold/build
17:33:31 <dons> yay
17:33:32 <sjanssen> dons: any progress on streams fusion in base?
17:33:42 <dons> ok. down to 3 seconds
17:33:43 <dons> from 15.
17:33:46 <dons> by fusing length
17:33:47 <dons> :)
17:33:59 <conal> awesome!
17:34:04 <vgax> cool
17:34:11 <vgax> can i see code
17:34:29 <dons> http://hpaste.org/7164#a3
17:34:45 <vgax> also how would i make show work on the cards?
17:34:45 <sjanssen> that doesn't blow the stack?
17:34:48 <dons> it uses a foldr for length, so that optimises away th eintermediate lists
17:34:57 <dons> sjanssen: strictness analysis should catch it
17:35:12 <saml> > foldr f init [a,b,c,d,e]
17:35:12 <Cale> const (+1)
17:35:12 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr [a])
17:35:16 <dons> so that should run in a bit less constant space too
17:35:16 <sjanssen> dons: strictness analysis can turn that right fold into a left fold?
17:35:27 <dons> sjanssen: oh, no. if it was a foldl, that would be fine
17:35:47 <dons> hmm, the foldr / build fuses away though
17:35:55 <dons> let's see what the final loop looks like
17:36:08 <dons> vgax: so compile that with ghc -O2
17:36:46 <conal> http://hpaste.org/7164#a4 (cards via liftA2)
17:36:55 <vgax> ok
17:37:24 <dons> does the result fit in an Int ?
17:37:25 * EvilTerran would make that Card <$> [minBound ..] <*> [minBound ..] ;)
17:37:29 <vgax> so what does the !Rank !Suit do?
17:37:35 <conal> EvilTerran: i like it!
17:37:37 <mauke> > length $ show 380204032
17:37:37 <lambdabot>  9
17:37:39 <mauke> yes
17:37:57 <dons> down to 2secs then
17:38:04 <conal> is there a standard name for [minBound ..] ?
17:38:09 <EvilTerran> vgax, it makes those parameters of the constructor strict
17:38:12 <vgax> :)
17:38:32 <vgax> what does that mean?
17:38:35 <EvilTerran> a Card is only defined if both of its parameters are
17:38:40 <dolio> > enumFrom minBound
17:38:41 <lambdabot>  [()]
17:38:52 <conal> haskell, ghc, fusion ftw!
17:38:55 <sjanssen> -fextended-default ftw
17:38:56 <vgax> ah ok
17:39:09 <EvilTerran> if it was only = Card !Rank Suit, say, then you could have a Card of undefined suit, but not of undefined rank
17:39:25 <sjanssen> conal: do you think GHC will optimize the applicative version as well?
17:39:32 <dons> http://hpaste.org/7164#a5 seems pretty good
17:39:36 <dons> just shy of 2 seconds
17:39:41 <vgax> okay i got it
17:39:48 <conal> sjanssen: i'd sure hope so.  all simple defs.
17:39:54 <EvilTerran> having all the parameters strict has the handy side-effect of allowing ghc to optimise the constructor away completely
17:39:54 <dons> compared to 15se before, with fairly minimal, obvious changes
17:40:08 <sjanssen> dons: I still want to know why that foldr doesn't blow the stack
17:40:12 <EvilTerran> saving on memory, pointer dereferences, thunk evaluations, etc
17:40:30 <vgax> yeah thats much better
17:40:57 <dons> Main.$wgo :: [Main.Card] -> Int#
17:41:03 <dons> Main.go3 :: Int# -> [Main.Card]
17:41:08 <dons> are the two loops we get
17:41:14 <dons> tagToEnum# @ Main.Rank x1_aCG  :)
17:41:21 <vgax> how would you eliminate permutations and just go with combinations
17:41:25 <dons> so all those nice data types are just raw tags
17:41:55 <dons> sjanssen: the foldr disappears inside some weird generator loop
17:41:58 <saml> what is fuse?
17:42:07 <Cale> dons: I'd also hope that  const (+ 1::Int)  would work just as well :)
17:42:10 <dons> sjanssen: look at the -ddump-simpl output
17:42:17 <dons> Cale, yeah. should be fine :)
17:42:51 <dons> a lovely mixture of high level description (list comprehensions, ADTs), and low level performance optimisations
17:42:52 <mauke> saml: turning f . g into fg :-)
17:44:28 <ddarius> @pl \x -> map f (map g x) -- a simple example
17:44:28 <lambdabot> map (f . g)
17:45:18 <mauke> map f . map g: as written, a list flows from the first function into the second
17:45:23 <dons> someone should put that little optimisation story we just did onto a blog post.
17:45:28 <EvilTerran> ?pl filter p . filter q
17:45:28 <lambdabot> filter p . filter q
17:45:28 <dons> since its got some good lesssons
17:45:30 <EvilTerran> bah
17:45:32 <mauke> by turning it into map (f . g) we can get rid of the intermediate list
17:45:49 <ddarius> EvilTerran: Hoping for filter (liftM2 (&&) p q) ?
17:45:57 <EvilTerran> i guess "filter (liftA2 (&&) p q)" isn't really nicer for most purposes...
17:46:17 <vgax> yeah that would be a good idea
17:46:40 <dons> strict pairs should be in the base lib
17:46:43 <EvilTerran> we could have ?fuse, too...
17:47:02 <ddarius> head strict lists should be in the base libraries too
17:47:02 <EvilTerran> "eliminates as many intermediate data structures as possible" :P
17:48:39 <saml> mauke: list flows from g to f for (map f . map g) ?
17:49:02 <mauke> no, from map g to map f
17:49:09 <mauke> map g returns a list, map f takes a list
17:49:12 <sjanssen> dons: I don't understand how GHC is able to do this?
17:49:26 <sjanssen> oh duh, I get it
17:49:36 <sjanssen> + evaluates the LHS first
17:49:37 <ddarius> sjanssen: Good, I was gettintg worried.
17:49:39 <vgax> do you know how i can make show work on the Card type?
17:49:52 <mauke> vgax: ... deriving (Show)
17:49:52 <dons> oh, strict int +#, sjanssen ?
17:49:54 <dibblego> dons, data List a = Nil | Cons !a (List a) -- head strict list?
17:50:05 <ddarius> dibblego: Yes.
17:50:09 <dons> its a useful type
17:50:19 <dibblego> I agree, it needs to be in the library
17:50:33 <saml> mauke: oh i see. and fusing them eliminates the intermediate list because the compiler can't fuse automatically
17:50:35 <sjanssen> actually, I'm still confused
17:50:36 <ddarius> Clean has syntactical support for it.
17:50:40 <sjanssen> ddarius: is it really so obvious?
17:50:49 <ddarius> sjanssen: I'll have to look.
17:50:52 <mauke> saml: huh? the compiler can and does fuse automatically
17:51:11 <dons> saml: yeah, the compiler can fuse foldr-like functions automatically
17:51:19 <dons> those known as "good producers" with "good consumers"
17:51:30 <sjanssen> dons: how can (1 + (1 + ...)) execute in constant stack?
17:51:57 <SamB> dons: whatever happened to your stream fusion?
17:51:58 <dons> hmm.
17:52:08 <saml> oh so, map (f . g)   and map f . map g  would be same. I just have to write whatever that says what I want to do better.
17:52:12 <dons> SamB: ? its on hackage. and soon to be available for a new arrays library too
17:52:22 <dons> in fact, the arrays interface will only be via fusible functions
17:52:28 <EvilTerran> ... wasn't it dcoutts' stream fusion?
17:52:50 <SamB> EvilTerran: weren't they both authors of those papers?
17:52:55 <EvilTerran> or was it a collaborative effort?
17:53:06 <SamB> and, uh, the code too ;-)
17:53:18 <SamB> dons: what about *base*?
17:53:22 <sjanssen> dons: I think SamB is asking why it isn't in base
17:53:37 * sjanssen types too slowly
17:53:43 <dons> sjanssen: so did you look at the  loop that gets generated?
17:53:53 <ddarius> saml: In cases that obvious you'd probably write the former.  The important thing is when you write someFunc . someOtherFunc which happens to lead to composed maps.
17:53:53 <SamB> sjanssen: to your credit, your sentance was longer than mine
17:53:58 <EvilTerran> sjanssen, well, typing is an exponentially hard problem... :P
17:54:08 <dons> its a funky tail recursive 4-nested loop
17:54:10 <SamB> EvilTerran: hahahaha
17:54:25 <SamB> nice pun ;-)
17:54:30 <EvilTerran> thankyou, thankyou, i'm here all week :)
17:54:32 <dons> oh, because concatMap isn't optimised predictably enough yet
17:54:58 <SamB> dons: what is because of that?
17:55:02 <SamB> stream fusion not being in base?
17:55:08 <dons> that's why its not in base.
17:55:11 <sjanssen> dons: it looks like GHC somehow turned it into an accumulator passing version
17:55:16 <dons> sjanssen: yeah.
17:55:26 * sjanssen was not aware of this optimization
17:55:47 <dons> i mean, the transforms that happen turning: foldr . concatMap (concatMap ...) into a loop are going to move things around a lot
17:55:55 <dons> so i'm not too surprised :)
17:56:02 <sjanssen> dons: actually, it looks like the final list wasn't fused out
17:56:05 <solrize> @pl \x -> x{foo=bar}
17:56:05 <lambdabot> (line 1, column 8):
17:56:05 <lambdabot> unexpected "{"
17:56:05 <lambdabot> expecting letter or digit, variable, "(", operator or end of input
17:56:13 <dons> sjanssen: right. there's still a list being generated
17:56:23 <EvilTerran> solrize, there is no pointsfree version of record update
17:56:27 <EvilTerran> much to everyone's irritation
17:56:45 <dons> sjanssen: the foldr. concatMap  still takes the enums
17:56:46 <ddarius> EvilTerran: Just write a function
17:56:54 <dons> ah, i know
17:56:55 <EvilTerran> well, yes...
17:57:01 <dons> there's no general fusion for enumFromTo
17:57:05 <dons> only for specific types
17:57:14 * dons has an idea
17:57:22 <ddarius> custom enumFromTo?
17:57:33 <dolio> unfold fusion!
17:57:38 <dons> yeah,  [Ace ..] has to fuse
17:57:45 <dons> which isn't too hard
17:57:49 <sjanssen> dons: simpler examples, like foldr (\_ acc -> acc + 1) (0 :: Int) [1 :: Int ..] blow the stack
17:58:09 <dons> oh, isn't that due to [1 ..] being lazy?
17:58:21 <dons> try [1 .. 10000000000]
17:58:31 <dons> so you get a strict enumFrom
17:58:48 <sjanssen> I tried both
17:59:57 <sjanssen> dons: I remember that GHC used to turn length into a foldr, but they removed this because of stack overflows
18:00:07 <dons> ah
18:00:11 <dons> yeah, that's right.
18:00:29 <sjanssen> so what is special about this example?
18:00:44 <dons> lots of concatMaps getting medieval
18:00:46 <dons> ?
18:01:01 <sw17ch> > :t lookup
18:01:02 <lambdabot>   parse error on input `:'
18:01:08 <sw17ch> @type lookup
18:01:09 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
18:01:17 <sw17ch> is there a function that checks b instead of a?
18:01:26 <dons> 1.890 s
18:01:26 <ddarius> Ask not for whom the fold fuses.
18:01:32 <dons> with the enumFroms fusing
18:01:34 <mauke> . map swap
18:01:50 <vgax> @type replicateM
18:01:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
18:01:55 <sw17ch> is swap defined in prelude? i figured that's how it would work, but wasn't sure if i should define swap or not
18:02:00 <dolio> @hoogle foldr'
18:02:00 <lambdabot> Data.Foldable.foldr' :: Foldable t => (a -> b -> b) -> b -> t a -> b
18:02:01 <lambdabot> Data.ByteString.foldr' :: (Word8 -> a -> a) -> a -> ByteString -> a
18:02:01 <lambdabot> Data.ByteString.Char8.foldr' :: (Char -> a -> a) -> a -> ByteString -> a
18:02:03 <mauke> it isn't :/
18:02:11 <sw17ch> that's odd... why not?
18:02:13 <mauke> :t (snd &&& fst)
18:02:14 <EvilTerran> swap is sadly missing
18:02:14 <lambdabot> forall a b. (a, b) -> (b, a)
18:02:18 <EvilTerran> lord only knows.
18:02:31 <sw17ch> who must i speak to so it may be so? :)
18:02:37 <Cale> Or just (\(x,y) -> (y,x))
18:02:44 <saml> sw17ch: elem . Map.elems
18:03:05 <EvilTerran> er...
18:03:22 <sw17ch> saml... ?
18:03:25 <saml> > a `elem` M.elems $ M.fromList [(a, b), (c, d)]
18:03:26 <lambdabot>  Couldn't match expected type `[Expr]'
18:03:41 <EvilTerran> sw17ch, #ghc would be a start, i think
18:03:47 <ziman> @djinn (a, b) -> (b, a)
18:03:48 <lambdabot> f (a, b) = (b, a)
18:03:49 <saml> > "foo" `elem` M.elems $ M.fromList [(1, "bar"), (2, "foo")]
18:03:50 <lambdabot>  Couldn't match expected type `[[Char]]'
18:03:53 <ziman> heh
18:04:10 <EvilTerran> seeing as it'd be a ghc-specific change, not a change to the std
18:04:15 <ziman> @pl \(x,y) -> (y,x)
18:04:16 <lambdabot> uncurry (flip (,))
18:04:25 <ddarius> EvilTerran: Why would it be GHC specific?
18:04:45 <sw17ch> i just defined swap as (a,b) = (b,a)
18:04:59 <sw17ch> i guess i'm just looking for a build in rlookup :P
18:05:03 <EvilTerran> well, implementation-dependent. it's not like they're gonna add it to the report
18:05:12 <ddarius> EvilTerran: Why not?
18:05:38 <Cale> It'd be put in Data.Tuple
18:05:50 <EvilTerran> well, how often does the report get updated again? :P
18:05:57 <EvilTerran> Cale, indeed
18:05:58 <ddarius> Haskell' is back in gear.
18:06:09 <sw17ch> is there an efficiency difference when we use a swap function? does GHC know well enough to optimize that part out?
18:06:10 * EvilTerran had not heard this
18:06:20 <Cale> Hehe, and I'm busily starting flamewars on the haskell-prime list it seems
18:06:41 <geezusfreeek> what'd you do now?
18:06:42 <SamB> sw17ch: might depend on strictness...
18:06:51 <SamB> Cale: flame on!
18:06:59 * geezusfreeek subscribes to haskell-prime like he always meant to do
18:07:05 <SamB> Cale: ideally, Haskell' will be fireproof
18:07:09 <Cale> 68 messages about flipping ($)'s associativity, then I posted about renaming fmap to map and making (.) a synonym of that.
18:07:14 <EvilTerran> btw, that should probably be swap ~(x,y) = (y,x)
18:07:25 <geezusfreeek> lol
18:07:33 <geezusfreeek> i personally think those are grand ideas
18:07:33 <ddarius> Cale: Why not just suggest that we start the process from the Haskell 1.4 Report?
18:07:36 <Cale> (obviously the 68 messages were not all me)
18:07:45 <Cale> ddarius: That is a good idea actually :)
18:07:45 <EvilTerran> "obviously" ;)
18:07:51 <geezusfreeek> Cale: no mention of making IO a GADT yet? ;)
18:07:57 <SamB> ddarius: ... you mean you didn't get the memo that you should do that?
18:08:00 <SamB> ddarius: duh!
18:08:09 <Cale> geezusfreeek: I'm not as sure about that one. It would make optimisations harder I think.
18:08:14 <geezusfreeek> yeah
18:08:30 <geezusfreeek> well, i mainly am just wary of it :P
18:08:32 <SamB> geezusfreeek: how would that work???
18:08:36 <dolio> IO is abstract. You shouldn't care if it's implemented using a GADT. :)
18:08:42 <SamB> indeed
18:08:48 <Cale> dolio: It doesn't really *have* to be abstract though.
18:08:55 <SamB> Cale: yes... it does!
18:08:59 <Cale> data IO a where
18:09:03 <geezusfreeek> SamB: wasn't my idea, but basically it would allow you to pattern match known IO functions and rewrite them :\
18:09:04 <Cale>    ReturnIO :: a -> IO a
18:09:08 <SamB> it MUST BE ABSTRACT
18:09:13 <Cale>    BindIO :: IO a -> (a -> IO b) -> IO b
18:09:19 <Cale>    GetChar :: IO Char
18:09:30 <Cale>    PutChar :: Char -> IO ()
18:09:31 <EvilTerran> eeew
18:09:35 <SamB> I guarentee that making it non-abstract would be more trouble than it's worth
18:09:48 <Cale>    ForkIO :: IO a -> IO ThreadId
18:09:51 <Cale> and so on.
18:09:58 <dolio> So, we're supporting "foo (ReturnIO a) = a" and so on?
18:10:02 <SamB> I will wager $10 on it
18:10:26 <Cale> dolio: That'd be fine, it'd just be undefined for a lot of IO actions.
18:10:39 <SamB> but not my school of engineering "your majors are our electives" t-shirt
18:10:40 <EvilTerran> i repeat - eeew
18:10:52 <Cale> EvilTerran: What's wrong with it?
18:11:13 <lament> "your majors are our electives" doesn't even mean anything
18:11:22 <Cale> EvilTerran: It's nicer than the impure implementation in terms of RealWorld
18:11:23 <EvilTerran> it's... er... it smells bad.
18:11:32 <SamB> lament: yes, it does
18:11:38 <Cale> Which abuses the fact that -> is not really ->
18:11:39 <lament> oh, i suppose it means "we're in the wrong major"
18:11:40 <geezusfreeek> Cale: hmm, you do have a point thereâ¦ besides FFI
18:11:45 <SamB> lament: no!
18:11:48 <lament> no? :)
18:11:51 * EvilTerran was just about to mention FFI
18:11:52 <Cale> geezusfreeek: Right, for FFI we'd need open datatypes.
18:12:07 <Cale> (I think)
18:12:13 <lament> SamB: if you take electives, presumably you're interested in the subject... so why not major in it?
18:12:13 <EvilTerran> even-further-G ADTs
18:12:15 <Cale> hmm
18:12:19 <Cale> actually, maybe not.
18:12:19 <SamB> it means that our elective courses cover their entire majors
18:12:29 <lament> SamB: if you were interested in engineering, wouldn't your electives be in engineering?
18:12:31 <geezusfreeek> i haven't read much about them (is there even much material on them?), but my impression has always been that open datatypes would open a big can of worms
18:12:42 <EvilTerran> yes
18:12:43 <Cale> Well, okay, the parameters to FFI calls would be tricky.
18:12:44 <geezusfreeek> unless there is some sort of typechecking that i don't know about
18:12:44 <SamB> lament: well, not all of them
18:12:45 <lament> SamB: oh, well that's just ignorant bs
18:12:56 <SamB> lament: there are distribution requirements...
18:13:18 <SamB> lament: plus that's why we majored in engineering
18:13:35 <dolio> There was an open datatypes proposal a while back, but I don't know how far it went.
18:13:44 <SamB> anyway, the implication is that we learn way more than everyone else ;-)
18:14:01 <geezusfreeek> probably the only way to do FFI with IO in a GADT would be to include extra IO functions that can link to external libraries and construct arbitrary calls to C functions that way instead of including headers and such
18:14:53 <lament> SamB: yeah, very clever
18:15:03 <geezusfreeek> maybe something that takes a tuple of arguments along with a symbol name or something
18:15:26 <geezusfreeek> well, it could be curried of course
18:15:28 <vgax> just wandering is anyone doing any large projects in haskell?
18:15:42 <BMeph> SamB: Well, more like we study more than everyone else. As for learning...
18:15:47 <SamB> lament: anyway, my program requires 6 social science or ... was it liberal arts ? classes...
18:15:55 <SamB> BMeph: well, okay...
18:16:03 <geezusfreeek> vgax: define large
18:16:04 <lament> BMeph: i dunno, arts people study a lot
18:16:26 <SamB> lament: art is a stupid major
18:16:32 <SamB> why do I say this?
18:16:33 <vgax> geezusfreeek: 30k LOC or more
18:16:46 <lament> SamB: probably cause you're unsure of your career path? :)
18:17:33 <SamB> no, more along the lines of I read too many webcomics where art professors were portrayed as complete assholes ;-)
18:17:58 <lament> oh, that's the danger of webcomics :)
18:18:06 <geezusfreeek> i only asked so others could seeâ¦ i personally don't keep up with lines of code in other projects, and i know none of _mine_ are that large
18:18:14 <lament> i can see myself doing English if i were to go to uni again
18:18:16 <BMeph> Basically, the whole "engineering students study a semester's worth of Humanities/Social Studies...so that they can understand what the Liberal Arts majors are asking for. ;)
18:18:55 <vgax> geezusfreeek: what do you programme in haskell?
18:18:57 <SamB> along with the horrible papers about art I've seen on the internet by people who are supposed to be experts...
18:19:07 <SamB> the things they can write about something that frankly sucks...
18:19:16 <geezusfreeek> vgax: well, my current project is a little game library which i hope to make some games with
18:19:36 <geezusfreeek> i also diddle around with compilers/interpreters and such
18:19:47 <SamB> they would have written good reviews of the kind of art people inflict on Lehigh university
18:20:20 <BMeph> geezusfreeek: I hope you're using a condom. ;p
18:20:45 <SamB> anyway, it seems like art history are the only sane academics who study art to me...
18:21:00 <geezusfreeek> i could have chosen a better word
18:21:19 <SamB> geezusfreeek: doodle?
18:21:25 <SamB> putter?
18:21:29 <SamB> fiddle?
18:21:34 <BMeph> Fiddle?
18:21:36 <geezusfreeek> no, diddle means what i meant to say, but it has alternate meanings
18:21:37 <BMeph> Jinx!
18:21:57 <geezusfreeek> fiddle would have worked
18:22:07 * SamB pulls out his bow
18:22:28 * BMeph hides the Arrows.
18:22:40 * vgax gives SamB and Arrow
18:22:57 * vgax an*
18:22:58 * geezusfreeek kicks SamB in the monads before he has a chance to shoot
18:23:02 <vgax> lol
18:23:16 <geezusfreeek> Functor you!
18:26:44 <SamB> I think the jinx wore off by now
18:26:59 <SamB> so I switch to zora form and throw my fins at you
18:29:57 * EvilTerran bomberangs SamB
18:30:22 <SamB> EvilTerran: I've switched to goron form in #xmonad
18:30:37 <EvilTerran> hehe. yay zelda! :D
18:31:38 <gwern> > tail "foo"
18:31:40 <lambdabot>  "oo"
18:37:26 <daveux> What's a good way to trasnform "AStringLikeThis" to "A String Like This"?
18:37:33 <daveux> *transform
18:39:12 <gwern> hm. 'map (\x -> if isCapital x then ' ':x else x) str' is one strategy
18:39:29 <gwern> I suppose you'd need to define isCapital then
18:39:48 <daveux> yeah, I see, map is a good way
18:39:48 <dolio> That'd have to be a fold.
18:39:50 <qwr> gwern: foldr or concatMap then maybe?
18:40:09 <daveux> concatMap with f :: Char -> String
18:40:11 <dolio> Or a concatMap, yeah.
18:40:28 <gwern> qwr: perhaps. the trouble is the string needs functions with some quasi semantic understanding
18:40:39 <gwern> you have to know what a capital letter is
18:40:42 <mauke> > groupBy ((==) `on` isUpper) "AStringLikeThis"
18:40:43 <lambdabot>  ["AS","tring","L","ike","T","his"]
18:41:15 <gwern> oh, isUpper; can't believe I forgot what isCapital's real name is
18:41:34 <dolio> > "AStringLikeThis" >>= \c -> if c `elem` ['A' .. 'Z'] then [' ', c] else [c]
18:41:35 <lambdabot>  " A String Like This"
18:42:04 <qwr> > (concatMap (' ':) . groupBy ((==) `on` isUpper)) "AStringLikeThis"
18:42:05 <lambdabot>  " AS tring L ike T his"
18:42:12 <mauke> > groupBy (\a b -> not (isUpper a) || not (isUpper b) ) "AStringLikeThis"
18:42:12 <lambdabot>  ["A","String","Like","This"]
18:42:28 <gwern> daveux: I take it you're relatively new to haskell?
18:42:41 <daveux> Relative to you people, yes.
18:42:54 <daveux> I am very impressed with some of the responses.
18:42:56 <mauke> > groupBy (not . (&&) `on` isUpper) "AStringLikeThis"
18:42:56 <lambdabot>  Couldn't match expected type `b -> c' against inferred type `Bool'
18:43:10 <mauke> > groupBy ((not .) . (&&) `on` isUpper) "AStringLikeThis"
18:43:10 <lambdabot>  ["A","String","Like","This"]
18:43:16 <daveux> I've also been hacking Haskore for 4 hours, so I was in need of some cognitive assistance.
18:43:17 <gwern> daveux: yes, I often had that experience too when I first began visiting #haskell
18:43:17 <mauke> > intercalate " " $ groupBy ((not .) . (&&) `on` isUpper) "AStringLikeThis"
18:43:18 <lambdabot>  "A String Like This"
18:44:22 <qwr> nice :)
18:44:25 <dolio> > unwords $ $ groupBy ((not .) . (&&) `on` isUpper) "AStringLikeThis"
18:44:25 <lambdabot>  Parse error at "$" (column 11)
18:44:30 <dolio> > unwords $ groupBy ((not .) . (&&) `on` isUpper) "AStringLikeThis"
18:44:30 <lambdabot>  "A String Like This"
18:45:08 <daveux> I ended up using:
18:45:37 <daveux> concatMap (\c -> if isUpper c then [' ',c] else c) "AStringLikeThis"
18:45:48 <EvilTerran> > concatMap (\c -> if isUpper c then [' ',c] else [c]) "AStringLikeThis"
18:45:49 <lambdabot>  " A String Like This"
18:46:03 <daveux> yes, [c] not c
18:46:44 <Woo1> > 1+1
18:46:44 <lambdabot>  2
18:46:45 <mauke>  > concatMap (\c -> (if isUpper c then (' ' :) else id) $ [c]) "AStringLikeThis"
18:46:51 <Woo1> > show [1..]
18:46:51 <lambdabot>  "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
18:46:54 <mauke> > concatMap (\c -> (if isUpper c then (' ' :) else id) $ [c]) "AStringLikeThis"
18:46:55 <Woo1> smart bot
18:46:55 <lambdabot>  " A String Like This"
18:47:22 <EvilTerran> > foldr (\c -> (if isUpper c then (' ':) else id) . (c:)) "" "AStringLikeThis"
18:47:23 <lambdabot>  " A String Like This"
18:47:49 <mauke> fails for leading space
18:47:53 <EvilTerran> eh, true
18:48:36 <EvilTerran> i'd go for the groupBy one, if it weren't such an abuse of groupBy
18:49:03 <mauke> groupBy and nubBy want to be abused
18:49:08 <mauke> considering the interface
18:49:40 <EvilTerran> > unwords $ groupBy ((not .) . (&&) `on` isUpper) "aStringLikeThis"
18:49:41 <lambdabot>  "aStringLikeThis"
18:49:45 <EvilTerran> problem
18:51:28 <mauke> (True,True) -> False; (True,False) -> True; (False,True) -> False; (False, False) -> True
18:51:52 <mauke> what function is that?
18:51:57 <EvilTerran> > unwords $ groupBy ((. not . isUpper) . (&&) . isUpper) "aStringLikeThis"
18:51:58 <lambdabot>  "a String Like This"
18:52:37 <EvilTerran> mauke, not .: (==>)
18:53:22 <dolio> False ==> False = True, no?
18:53:29 <mauke> > unwords $ groupBy ((. not . isUpper) . (&&) . isUpper) "astringLikeThis"
18:53:30 <lambdabot>  "a s t r i n g Like This"
18:53:33 <mauke> EvilTerran: fail
18:53:35 <EvilTerran> oh, wait, yeah
18:53:38 <chessguy> 'evening haskellers
18:53:49 <EvilTerran> mauke, well, it's a little closer than yours :P
18:54:26 <mauke> > unwords $ groupBy (\a b -> case (isUpper a, isUpper b) of (True,True) -> False; (True,False) -> True; (False,True) -> False; (False, False) -> True) "andAStringLikeThis"
18:54:27 <lambdabot>  "and A String Like This"
18:55:32 <mauke> > unwords $ groupBy (\a b -> (if isUpper a then not else id) $ isUpper b) "andAStringLikeThis"
18:55:33 <lambdabot>  "a n dAS t r i n gL i k eT h i s"
18:55:49 <dolio> > let f _ b = not b in map (uncurry f) ((,) <$> [True, False] <*> [True, False])
18:55:50 <lambdabot>  [False,True,False,True]
18:56:07 <dolio> > let f _ b = not b in ((,) <$> [True, False] <*> [True, False])
18:56:08 <lambdabot>  [(True,True),(True,False),(False,True),(False,False)]
18:56:28 <dolio> f = const not
18:56:28 <mauke> what the
18:56:31 <EvilTerran> yes, of course, it's const not
18:56:37 <mauke> I just noticed
18:56:43 * EvilTerran was trying to think of one involving xor
18:56:54 <EvilTerran> ... but (const not) makes perfect sense in context too
18:56:56 <mauke> > unwords $ groupBy (\a b -> isUpper b) "andAStringLikeThis"
18:56:57 <lambdabot>  "a n dAS t r i n gL i k eT h i s"
18:57:07 <EvilTerran> ... wait what
18:57:20 <mauke> > unwords $ groupBy (const $ not . isUpper) "andAStringLikeThis"
18:57:21 <lambdabot>  "and A String Like This"
18:57:30 <qwr> > (intercalate " " . groupBy (const $ not . isUpper)) "AStringLikeThis"
18:57:31 <lambdabot>  "A String Like This"
18:57:35 <EvilTerran> ... damn, beaten to the copy-and-paste
18:57:37 <EvilTerran> ... twice.
18:58:14 <EvilTerran> aside from the odd use of intercalate there ;P
19:01:09 <gwern> anyone here want to read the entrails of some profiling output for me?
19:01:20 <mauke> s/(?<=.)(?=[[:upper:]])/ /sg
19:01:42 <gwern> http://lists.osuosl.org/pipermail/darcs-devel/attachments/20080412/7854901d/attachment-0026.obj <-- I don't entirely understand 'filetype_function' - what is it calling that is so expensive that makes it ~70% of time?
19:01:44 <lambdabot> http://tinyurl.com/6dc7es
19:09:59 <edwardk> heh my irc client at work is rather persistent apparently
19:10:44 <araujo> http://www.bitc-lang.org/index.html
19:10:48 <lambdabot> Title: The BitC Programming Language
19:28:46 <SamB> whao, finally proved a transitivity property in coq...
19:40:52 <zgold> Haskell is the coolest language.  Ever.
19:41:28 <Beelsebob> yes, yes it is :P
19:41:29 <dibblego> go tell your friends!
19:42:59 <dons> zgold: :)
19:43:43 <zgold> I just had a particularly rewarding experience with a polymorphic function i wrote last week
19:44:44 <dons> polymorphism is awesome bananas
19:52:39 <Woo1> Is it possible to keep the input buffer from accumulating?
19:52:50 <Woo1> I tried hFlush stdin but that did not work
19:53:10 <Woo1> and I don't want the user to have to hit enter to be able to keep putting in characters
19:55:26 <scook0> hSetBuffering?
19:55:46 <Woo1> I have it set to NoBuffering, should I set it to block buffering?
19:56:32 <Woo1> :q
19:56:34 <Woo1> oops
19:57:13 <Woo1> basically the issue is it's catching all the input until I have 8 or so, then I have to hit enter to clear the buffer...I'd like to avoid that
19:59:35 <performance> hi
20:01:09 <performance> is there a comparison/shootout of basic file operations performance between different languages?
20:01:34 <dons> basic file performance doing what?
20:01:42 <ddarius> Languages would hardly matter for that.
20:02:19 <performance> open a 20MB file, seek to a particular line, read it, close the file, 10,000 times.
20:02:34 <dons> so that's just unix calls, i doubt there's a benchmark for that
20:02:36 <performance> my guess was teh file operations would be from teh same library for all languages
20:02:40 <dons> its a kernel thing.
20:02:55 <dons> there probably are benchmarks for different filesystem types
20:02:59 <dons> and different OSs
20:03:49 <performance> hmm..
20:04:42 <dons> if its not 'seek' you're interested in, but actually manipulating arrays in memory, then there's going to be vast differences
20:05:31 <performance> basically im updating a counter based on some value on the line extracted from each of the 10K files
20:06:02 <performance> thigns like lines and unlines are useless. i just need one particular line in a huge file with thousands of lines..
20:06:23 <dons> ah, so you're processing the file
20:06:34 <dons> that's a bit like the sum-file benchmark
20:06:38 <dons> which adds each line of a file
20:06:49 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=all
20:06:55 <lambdabot> Title: sum-file benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language ..., http://tinyurl.com/o8pll
20:07:14 <dons> it depends on how you filter the lines you're interested in
20:07:23 <dons> is it a regex? a substring? a prefix?
20:07:29 <dons> do you have to parse the line in some way?
20:07:34 <dons> is it at a fixed offset?
20:08:00 <dons> how often do you have to do it? once a day? once a month?
20:08:01 <Woo1> is there a way to flush the input buffer?
20:08:02 <dons> every 30 seconds?
20:08:11 <performance> yeah basically it is the output of purecov,  the line looks like li <num> <num> ... <num> i need the nums
20:08:13 <dons> Woo1: the input or the output buffer?
20:08:26 <Woo1> dons: input buffer, ideally
20:08:27 <dons> Woo1: hFlush stdout will flush
20:08:55 <performance> on demand!! when a user queries, i have to get the info from the files, it is not feasible to store such a huge db.
20:09:08 <ABoyNamedWooh> dons: my goal is to be able to have a user infinitely satisfy a getChar loop
20:09:49 <dons> performance: sounds like an on disk structure would be good. -- better algorithms, rather than faster languages
20:10:18 <dons> that said, parsing a file is pretty quick with lazy bytestrings
20:10:29 <dons> or you could write in C if speed is the only concern
20:12:04 <performance> actually i dont need to parse teh whole file, just seek to a particular line and get it and close the file handle. what happens after that is a pure function + state
20:15:13 <performance> dons:  what is an on disk structure?  google is not of much help yet
20:15:27 <dons> so something lazy will outperform something strict here. an hseek (os-level laziness), or lazy bytestrings perhaps
20:16:45 <performance> thanks dons
20:17:25 <shapr> whee!
20:18:37 <sw17ch> oh dear, Ubuntu 8.02 has ghc 6.8.2... i'm running out of reasons not to switch from gentoo...
20:18:42 <edwardk> heya shapr
20:19:01 <shapr> hiya edwardk!
20:19:07 <shapr> How's code?
20:19:11 <edwardk> shapr: the result of my beating on the hylo/etc stuff from the car earlier: http://comonad.com/reader/2008/generalized-hylomorphisms/
20:19:12 <lambdabot> Title: The Comonad.Reader » Generalized Hylomorphisms
20:19:12 * Korollary high fives edwardk
20:19:32 * edwardk is high fived ;)
20:19:44 <shapr> yay!
20:19:53 <shapr> We had pizza, I had my mind blown.
20:20:23 <edwardk> shapr: it seems to cover generalized recursion and generalized corecursion, and generalized histomorphisms in one cheesy little data structure
20:20:32 <edwardk> er one cheesy little function, i should say
20:20:34 <shapr> cool!
20:21:00 <edwardk> also i noticed that the 'branching stream' comonad is the cofree comonad by yet ANOTHER name. =/
20:21:56 <edwardk> i started puttering to see if there is an generalized acid rain/generalized hylo fusion law or something that could play nicely with the generalized form.
20:22:33 <edwardk> overall a productive evening, except not productive at all on what i was planning on coding ;)
20:23:59 <shapr> acid rain?
20:24:06 <shapr> heh
20:24:10 <shapr> No more kata?
20:24:30 <edwardk> well, i tripped over the g_histo stuff while working on the kata prelude actually
20:24:40 <edwardk> then i tried to give it a type =)
20:24:49 <shapr> heh
20:24:54 <Stars> hey hi all
20:24:55 <shapr> In your typeless language, even
20:25:01 <Stars> i from bulgaria and dont speak english
20:25:06 <chessguy> @get-slap
20:25:07 <lambdabot> shapr!!
20:25:10 <Stars> get 1 easy shell
20:25:14 * chessguy grind
20:25:14 <Stars> ;-)
20:25:14 <shapr> What?
20:25:16 <chessguy> grins
20:25:22 <edwardk> acid rain is a theorem for fusing certain hylomorphisms
20:25:23 <Stars> hey!
20:25:29 <shapr> oh
20:25:48 <shapr> Hi stars, how's Michigan?
20:25:51 <Stars> get 1 shell i using for eggdrop
20:26:04 <cjb> shapr: hey dude, how's it going?
20:26:07 <Stars> shapr dont speak
20:26:08 <Stars> :)
20:26:13 <shapr> cjb: Swimmingly, how's life with you?
20:26:18 * chessguy tries to get xcode going on his macbook, to hopefully get a step closer to putting GHC on it
20:26:19 <shapr> cjb: I mentioned you on lwn.net, did you see?
20:26:28 <shapr> Stars: Talar du svenska kanske?
20:26:31 <cjb> shapr: Nope, didn't see.  Gotta link?
20:26:36 <shapr> Stars: Spraak u nederlands?
20:26:39 <cjb> shapr: life with OLPC could be better :)
20:26:41 <shapr> Stars: parlez vous francais?
20:26:48 <Stars> i speak BULGARIAN
20:26:51 <chessguy> shapr: hablas espanol?
20:26:51 <Stars> i form bulgaria
20:26:51 <Stars> :)
20:26:52 <shapr> cjb: Yeah, I've heard.. that's why I was mentioning you...
20:27:03 <shapr> chessguy: no habla espanol...
20:27:13 <chessguy> que lastima!
20:27:23 <shapr> Stars: Are you seriously trying to get a free shell account?
20:27:37 --- mode: ChanServ set +o shapr
20:27:43 <Stars> dont speak this "seriously"
20:27:59 <shapr> Stars: #haskell is to learn Haskell
20:28:05 <shapr> Not shell accounts.
20:28:07 <edwardk> curious here because the generalized hylomorphism covers general recursion (((,)e) comonad and identity monad) and general corecursion (with the identity comonad and the 'Either e' monad) respectively and histomorphisms when working with the cofree comonad and identity monad
20:28:13 <cjb> shapr: hm, I see a few OLPC stories, but can't find comments from you :)
20:28:25 <shapr> cjb: http://lwn.net/Articles/279218/
20:28:25 <lambdabot> Title: Low-cost laptop program sees a key leadership defection (AP) [LWN.net]
20:28:39 <shapr> Yay, I didn't have to kick him.
20:29:39 * chessguy crosses his fingers
20:30:15 <edwardk> shapr: agreed. hi cjb, nice to see you again
20:31:25 <cjb> shapr: danke
20:32:28 <edwardk> cjb: we really do need to get down to cambridge again and see about trying to start up that CHUG thing that shapr was so gung-ho about.
20:33:20 <chessguy> edwardk: is that a beer-chugging event?
20:33:25 <cjb> edwardk: indeed!  do you guys not come to Cambridge much?
20:33:31 <edwardk> that is if I didn't terrorize mike stone too much. ;)
20:33:49 <edwardk> well we are a whole couple of miles away, its soo onerous to visit ;)
20:34:12 <edwardk> chessguy: shapr seems to think it should be. haskell and beer, great combination
20:34:26 <chessguy> that was a question, not a suggestion :)
20:34:35 <shapr> heh
20:34:39 <shapr> I agree, Haskell and beer!
20:35:00 <Korollary> blackjack?
20:35:09 * chessguy has never cared for alcohol, and certainly wouldn't want to code while consuming it
20:35:10 <edwardk> chessguy: well, it was either 'CHUG' or SHRUG (somerville haskell regional user group? or some other pun) =)
20:35:22 <chessguy> nice
20:35:31 <chessguy> hey, if the mug fits :)
20:35:44 <edwardk> heh
20:36:17 <shapr> Thing is... how do we persuade Cale to make a logo for CHUG?
20:36:21 <edwardk> cjb: in practice we mostly make it down there when shapr finds out there will be someone from the #haskell channel in town ;)
20:36:23 <shapr> Or maybe we should ask someone local?
20:36:28 <shapr> Yeah, truly
20:36:37 <shapr> I met boegel downtown recently.
20:36:53 <Cale> The logo for CHUG should be a beer glass.
20:37:01 <Cale> With a lambda on it.
20:37:02 <edwardk> with a lambda on the side
20:37:03 <edwardk> yeah
20:37:03 <shapr> heh
20:37:14 <shapr> Cale: Oh ye of more graphical skills than I ...
20:37:16 * shapr grins
20:38:42 * chessguy succeeds in getting macports to at least _start_ installing ghc
20:38:51 <chessguy> i suspect this could take a while though
20:39:12 <shapr> Ooh, I could cut a lambda out of paper... and stick it on a cold beer glass in the warm summer evening.. and take a picture!
20:39:16 <chessguy> it just configured, built, and installed gmp, and now it's going after perl
20:39:25 * saml reads every single word of installation progress message
20:39:25 <ddarius> shapr: Go for it.
20:40:11 <chessguy> saml: if it bothers you, /ignore me
20:40:42 * bos uses "darcs annotate", and cries.
20:40:48 <dolio> Put a cat in the photo, too.
20:44:02 <shapr> Good idea! Lambda drunken cats!
20:44:22 <saml> haskell user groups are male dominant. so it should be a dog
20:44:45 <chessguy> @type unfoldTree
20:44:47 <lambdabot> forall b a. (b -> (a, [b])) -> b -> Tree a
20:44:58 <shapr> saml: Do guys like dogs and women like cats or something?
20:45:26 <saml> > unfoldTree (\x -> (1, "a")) 'X'
20:45:27 <lambdabot>  Node {rootLabel = 1, subForest = [Node {rootLabel = 1, subForest = [Node {ro...
20:46:30 <saml> shapr: maybe not. it's my stereotype. dogs :: Male, cats :: Female
20:46:33 <chessguy> > let f x = map read . take x . drop x $ show pi in f 5
20:46:34 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
20:46:45 <shapr> Strange, I've always preferred cats.
20:46:52 <ABoyNamedWooh> Is there a better way to take a continuous stream of input from a user than to just use a getChar loop?
20:46:59 * ddarius much much prefers dogs.
20:47:05 <ddarius> Albeit kittens are hard to resist.
20:47:31 <chessguy> > let f x = map digitToInt . take x . drop x $ show pi in f 5
20:47:32 <lambdabot>  [5,9,2,6,5]
20:48:14 <saml> > getChar
20:48:14 <lambdabot>  <IO Char>
20:48:45 <ABoyNamedWooh> saml: I mean, all I need are characters...the problem is that my getchar loop sometimes just breaks
20:48:52 <ABoyNamedWooh> and it doesn't "catch" initially
20:48:53 <BMeph> ddarius: Yes, I know what you mean. I could never eat just one... ;p
20:49:01 <chessguy> > let f x = map digitToInt . take x . drop x $ show pi; g x = (x, f x) in unfoldTree g 8
20:49:02 <lambdabot>  Node {rootLabel = 8, subForest = [Node {rootLabel = 6, subForest = [Node {ro...
20:50:20 <ABoyNamedWooh> let f = do {x <- getChar; putChar x; } in f
20:50:29 <ABoyNamedWooh> > lï»¿et f = do {x <- getChar; putChar x; } in f
20:50:30 <lambdabot>  Illegal character ''\187''
20:50:30 <lambdabot>  at "»¿et" (column 3)
20:50:40 <ddarius> BMeph: Exactly!
20:51:21 <chessguy> @undo do {x <- getChar; putChar x}
20:51:22 <lambdabot> getChar >>= \ x -> putChar x
20:51:37 <ABoyNamedWooh> > getChar >>= \x -> putChar x
20:51:37 <lambdabot>  <IO ()>
20:51:47 <chessguy> @pl \x -> putChar x
20:51:48 <lambdabot> putChar
20:51:58 <ABoyNamedWooh> > "hello" >>= \s -> putStr s
20:51:59 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
20:52:27 <chessguy> ABoyNamedWooh: so your f translates to getChar >>= putChar
20:52:53 <edwardk> @ty forever
20:52:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
20:53:04 <ABoyNamedWooh> I'm not so worried about prettying it up, I was just curious how it'd go...my problem isn't with getChar per se it's with I think 2 threads
20:53:11 <edwardk> @ty forever (getchar >>= putchar)
20:53:12 <lambdabot> Not in scope: `getchar'
20:53:12 <lambdabot> Not in scope: `putchar'
20:53:12 <ABoyNamedWooh> and a getchar loop that doesn't want to catch
20:53:15 <edwardk> er
20:53:25 <edwardk> @ty forever (getChar >>= putChar)
20:53:26 <lambdabot> IO ()
20:53:37 <ABoyNamedWooh> what is forever?
20:53:49 <ABoyNamedWooh> is it a construct to avoid doing something like loop; where loop = stuff; loop
20:53:54 <edwardk> @source forever
20:53:54 <lambdabot> forever not available
20:54:08 <edwardk> forever f = do f; forever f
20:54:14 <ABoyNamedWooh> ah
20:54:19 <ABoyNamedWooh> well I mean I basically have that
20:54:32 <ABoyNamedWooh> I mean the problem is that for some reason when I do it it doesn't always take from the buffer right away
20:54:49 <OceanSpray> I'm still iffy on what the hell dependent types are.
20:55:07 <shapr> They're like ... the first type is free man!
20:55:08 <edwardk> ABoyNamedWooh: is it a setvbuf thing?
20:55:16 <shapr> @quote toke
20:55:16 <lambdabot> Heffalump says: (re the RealWorld# token) The compiler knows that it can implement the token using the  arrow of time
20:55:19 <shapr> @quote toked
20:55:20 <lambdabot> shapr says: I've toked on so many lambdas I'm getting dependent types
20:55:21 <ABoyNamedWooh> setvbuf? what's that? right now I have things set to NoBuffered
20:55:22 <shapr> Yeah!
20:55:34 <shapr> OceanSpray: no seriously... have you read Types and Programming Languages by BC Pierce?
20:55:40 <edwardk> i don't know the haskell stuff for nonbuffering i admit =)
20:55:42 <OceanSpray> no, I haven't.
20:55:49 <OceanSpray> where can I find that?
20:55:54 <ABoyNamedWooh> ï»¿(11:55:34 PM) shapr: OceanSpray: no seriously... have you read Types and Programming Languages by BC Pierce? <== haha he's my professors o_O people read his stuff?
20:56:06 <dolio> At a book store, if you're lucky.
20:56:19 <dolio> You'll probably have to order it online, though.
20:56:21 <edwardk> i just know the traditional posix form of it
20:56:32 <shapr> ABoyNamedWooh: Seriously? He writes cool stuff.
20:56:37 * cjb has a copy, found it pretty boring.  ;-)
20:56:41 <ABoyNamedWooh> edwardk: so what should my goal be? simply to turn off buffering or do I need to do more?
20:56:47 <ABoyNamedWooh> shapr: yeah, he's a great guy. very tall.
20:56:53 <shapr> um
20:56:59 <OceanSpray> also, are dependent types just a way to tell the compiler "forall x, if a, b, and c, then x is of type y"?
20:57:02 <shapr> It's funny you mention his height rather than his type theory stuff.
20:57:15 <chessguy> shapr: he writes on type theory? :)
20:57:16 <ABoyNamedWooh> I mean, I'm taking a class on Haskell with him...the theory comes in less
20:57:27 <ABoyNamedWooh> I mean he brings up the theory but it's driven by other things
20:57:32 <ABoyNamedWooh> he does teach a type theory class though
20:57:32 <edwardk> ABoyNamedWooh: so you are opening it and setting buffering already?
20:57:49 <ABoyNamedWooh> edwardk: I open it and set no input or output buffering
20:57:52 <ABoyNamedWooh> is that what I want?
20:57:58 <ABoyNamedWooh> or do I only want output and not input or something?
20:58:32 <OceanSpray> Oh hey, you go to UPenn?
20:58:36 <ABoyNamedWooh> I do
21:00:12 <chessguy> i didn't know pierce taught there
21:00:19 <ABoyNamedWooh> yeah
21:00:24 <ABoyNamedWooh> he's tenured here I do believe
21:00:31 <chessguy> i'm sure
21:00:33 <dolio> OceanSpray: It can be hard to pin down a definition of dependent types. In general it means that types can be indexed by values, although various languages take that to different degrees.
21:00:37 <ABoyNamedWooh> he has taught elsewhere though
21:00:41 <ABoyNamedWooh> like CMU and oxford I thikn
21:01:01 <OceanSpray> dolio, "indexed by values"?
21:01:15 <OceanSpray> also, http://www.amazon.com/Types-Programming-Languages-Benjamin-Pierce/dp/0262162091
21:01:18 <lambdabot> http://tinyurl.com/632sav
21:01:18 <chessguy> OceanSpray: like building the size of an array into a type
21:01:19 <OceanSpray> god damn that's steep.
21:01:20 <dolio> OceanSpray: The key in most of them is that instead of just "f :: A -> B" you can have "f :: (a :: A) -> B a"
21:01:58 <dolio> OceanSpray: Like, instead of just "Array Int" you can have, say, "Array 5 Int".
21:02:03 <OceanSpray> huh.
21:02:12 <edwardk> OceanSpray: think of 'array [1..10] of int' or something like that in pascal or one of those languages. the length of the array is a number, its a term. now in a language with dependent types you can define operations that would concatenate two arrays of given lengths giving you an array with a length that is the sum of the two lengths, or which you have to perform another arbitrary term-level calculation to check the types
21:02:15 <dolio> Although that isn't a particularly good example of what dependent types can do.
21:02:45 <chessguy> dolio: for some definition of good
21:02:47 <dolio> Although it is, I guess, the limit of what some particular depedent type systems can do.
21:03:34 <dolio> Apparently Dependent ML only let you use statically known integers at the type level.
21:03:40 <dolio> Which isn't particularly exciting.
21:03:41 <edwardk> in general full dependent types give you the full power of your 'term' language in your 'type' language. they don't have to be different. the calculus of constructions used by coq is a very simple pure type system in which terms and types are represented by the same basic thing.
21:03:58 <sclv> can't we do the accumulating mapM with a dlist and keep laziness?
21:04:02 <sclv> or am I missing something?
21:04:09 <OceanSpray> I'm sorta kinda getting it.
21:04:15 <OceanSpray> But then again, I'm still confused.
21:04:21 <OceanSpray> what's a 'term'?
21:04:45 <edwardk> oceanspray: a term is something like 12 or map (const ()) [1,2,3]
21:04:49 <edwardk> terms have types
21:05:03 <OceanSpray> terms = expressions ?
21:05:04 <edwardk> types are things like Int or a -> [a]
21:05:07 <edwardk> yeah
21:05:13 <OceanSpray> ah.
21:05:48 <chessguy> mm, i would tend to say terms = values
21:05:52 <edwardk> in a non-dependently typed language you have terms, and terms depend on terms. you can go a little farther and let terms depend on types. but in general types only depend on other types. they don't depend on terms.
21:06:05 <chessguy> though i could be wrong
21:06:34 <ddarius> chessguy: values is usually restricted to "evaluated" or "self-evaluating" forms.
21:06:44 <dolio> chessguy: Some people might not consider "map (const ()) [1,2,3]" a "value" per se.
21:06:48 <conal> OceanSpray: terms = value expressions (as opposed to type expressions)
21:06:50 <ddarius> chessguy: 2+2 is a term or an expression, but not (usually) a value
21:07:16 <chessguy> ddarius: oh, ok, i was mis-understanding the term 'term' then
21:07:31 <edwardk> in a dependently typed language you can have your 'types' depend on terms, so you sort of flatten the system out impredicatively or make a predicative tower of types or both.
21:08:14 <OceanSpray> doesn't that mess with compile-time/run-time distinctions?
21:08:14 <edwardk> there are lots of things people cheat and call 'dependently' typed so you have to watch out.
21:08:21 <edwardk> oceanspray: exactly! =)
21:08:45 <edwardk> in order to compile you have to be able to perform any computation in the term language that you want to allow to be lifted up into the type language
21:08:52 <conal> OceanSpray: and messes with decidability of type checking and inference
21:09:08 <edwardk> some weak dependent type systems just allow a few easy total operations and disallow general recursion
21:09:29 <edwardk> the cayenne approach is to throw open the floodgates to undecidable typechecking and just timeout after a while
21:09:39 <OceanSpray> hmm.
21:09:51 <edwardk> coq requires that you can only write terminating programs and hence the type checking will also terminate, etc.
21:10:03 <conal> edwardk: does cayenne do any type/term inference?  or just checking?
21:10:14 <edwardk> there are a number of mechanisms you can use to reign in the chaos that ensues
21:10:28 <edwardk> conal: as i recall its all type checking. you have to be painfully explicit about types
21:11:02 <edwardk> speak of the devil. i suppose you could just ask him ;)
21:11:29 <OceanSpray> who?
21:12:07 <edwardk> ocean: augustss wrote cayenne
21:12:11 <OceanSpray> oh.
21:12:59 <chessguy> @where cayenne
21:12:59 <lambdabot> http://www.cs.chalmers.se/~augustss/cayenne/index.html
21:14:30 <edwardk> You might also look at agda if you like Haskell for similar reasons: http://unit.aist.go.jp/cvs/Agda/
21:14:32 <lambdabot> Title: Agda (ver. 1) Official Web Site
21:14:43 <OceanSpray> "Hotter than Haskell"
21:14:45 <OceanSpray> lol
21:16:15 <shapr> edwardk: You wanna drive tomorrow?
21:16:38 <edwardk> shapr: not particularly, but i suppose i could be talked into it
21:16:45 * shapr talks more
21:17:18 <lispy> Can someone kindly explain what the Ints in the return value of this function mean? http://www.haskell.org/ghc/docs/6.6/html/libraries/base/Data-ByteString-Base.html#v%3AtoForeignPtr
21:17:19 <lambdabot> http://tinyurl.com/54vxcs
21:18:05 <edwardk> shapr: otoh, if you drive i can write more kata tonight and you'll be closer to having a working compiler to play with ;)
21:18:17 <ddarius> lispy: Probably a start and length or a start and end index
21:20:01 <lispy> ddarius: ah, seems to be documented in this haddock version: http://hackage.haskell.org/packages/archive/bytestring/0.9.0.4/doc/html/Data-ByteString-Internal.html#v%3AtoForeignPtr
21:20:03 <lambdabot> http://tinyurl.com/6bjfhc
21:20:07 <lispy> (ptr, offset, length)
21:23:03 <jberg> hm i think the auto indenting in my emacs mode is fucked.. when i write a where expression for example, i should just press tab and it should indent correctly?
21:23:08 <OceanSpray> "To use a constructor of a data type you need to give both the name of the constructor and the type that it belongs to."
21:23:15 <OceanSpray> augustss, why?
21:24:47 <edwardk> oceanspray: because you can use that constructor in multiple types
21:25:03 <sclv> jberg: there are multiple possible indentations -- tab cycles through them.
21:25:38 <ABoyNamedWooh> does anyone here have experience with event handlers?
21:26:04 <conal> ABoyNamedWooh: event handlers in what system?
21:26:13 <ABoyNamedWooh> Haskell
21:26:21 <ABoyNamedWooh> although if I have to do it in another language I will ;__;
21:26:27 <conal> ABoyNamedWooh: for a particular gui library?
21:26:32 <conal> ABoyNamedWooh: or what?
21:26:35 <ABoyNamedWooh> just the command prompt
21:26:41 <ABoyNamedWooh> although I can use a library if I have to
21:26:51 <ABoyNamedWooh> I thought I could avoid it because my needs are relatively simple
21:26:55 <ddarius> ABoyNamedWooh: I don't think anyone knows what you are talking about.
21:27:02 <ABoyNamedWooh> ddarius: that's fair
21:27:24 <conal> ABoyNamedWooh: some gui or graphics libs have notions of event handlers, but nothing generic
21:27:28 <ABoyNamedWooh> I basically want the user to be able to press the keyboard at will and the program will save the record of their keystroke and the time when they pressed it. every 10 seconds, the record is whiped
21:27:50 <ABoyNamedWooh> wiped*
21:28:05 <sclv> that's easy to do in haskell.
21:28:12 <ddarius> We use threads for that.
21:28:16 <ABoyNamedWooh> I tried having 2 threads. one that wakes up every 10 seconds, and one that does x <-getChar
21:28:22 <ddarius> (Threads and events are dual.)
21:28:33 <ABoyNamedWooh> yeah, I am using threads, the problem is it often sleeps the thread that gets the input
21:28:50 <ABoyNamedWooh> should I paste the code into hpaste? it's short
21:28:55 <sclv> are you compiling with -threaded ?
21:29:08 <ABoyNamedWooh> no
21:29:11 <ABoyNamedWooh> what does -threaded do?
21:29:25 <sclv> builds with the threaded runtime.
21:29:34 <ABoyNamedWooh> because it compiles, it just doesn't always work properly
21:29:38 <ABoyNamedWooh> is the threaded runtime more robust?
21:29:56 <sclv> lots of errors with threads and IO are because you only get nonblocking IO with -threaded.
21:30:10 <ABoyNamedWooh> yeah I just compiled with threaded and nothing changed
21:30:14 <shapr> edwardk: Hard to choose!
21:30:21 <sclv> then hpaste away!
21:30:24 <ABoyNamedWooh> @paste
21:30:25 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:31:27 <ABoyNamedWooh> http://hpaste.org/7167
21:32:05 <ABoyNamedWooh> the problem seems to be that when user input slows, it jumps from the thread that gets input to the thread that is sleeping, and doesn't always go back
21:32:37 <OceanSpray> Does your prof require so much whitespace?
21:32:47 <ABoyNamedWooh> I don't know why it's double spaced
21:32:53 <ABoyNamedWooh> and yeah I mean he prefers prettier code
21:33:06 <ABoyNamedWooh> obeying 80 character width and all that
21:33:18 <edwardk> ok, shapr drives. back to code ;)
21:33:50 <OceanSpray> shapr, you live with edwardk?
21:34:06 <lament> i hate the 80 char limit :(
21:34:12 <sclv> my toy ORM so far: http://hpaste.org/7168
21:34:33 <shapr> OceanSpray: No, about a mile away. But we work at the same place.
21:34:41 <OceanSpray> ah.
21:35:03 <ABoyNamedWooh> sclv: what is an ORM?
21:35:17 <sclv> object relational mapping
21:35:27 <sclv> its not really one, because they're records, not objects.
21:35:34 <sclv> DRM I suppose.
21:35:51 <ABoyNamedWooh> ah
21:36:17 <ABoyNamedWooh> what does it do haha
21:36:24 * ABoyNamedWooh is showing his ignorance tonight
21:38:19 <sclv> lets you work with a database backend relatively transparently.
21:38:42 <ABoyNamedWooh> ah
21:39:17 <sclv> why is your killcode thread killing itself?
21:39:30 <ABoyNamedWooh> well, it creates a new one with a new thread delay
21:39:34 <ABoyNamedWooh> can I just loop it?
21:39:43 <sclv> yeah
21:39:51 <sclv> ?hoogle forever
21:39:52 <lambdabot> Control.Monad.forever :: Monad m => m a -> m ()
21:40:02 <sclv> ?src forever
21:40:02 <lambdabot> Source not found. Wrong!  You cheating scum!
21:40:27 <sclv> bleh. you may want to use forever though to make things even easier.
21:40:46 <ABoyNamedWooh> I'll try that. I'm still afraid of it jumping out of the readcode thread, though
21:40:53 <ABoyNamedWooh> for some reason if keystrokes become sparse it just stops
21:43:37 <ABoyNamedWooh> my code is certainly a bit more elegant now but it's still not working :/
21:43:45 <ABoyNamedWooh> see the readcode loop will catch it
21:43:48 <ABoyNamedWooh> and do its thing for a while
21:43:51 <ABoyNamedWooh> but then it loses it
21:46:17 <ABoyNamedWooh> > reverse [1..]
21:46:20 <lambdabot> Terminated
21:46:26 <sclv> whatever your code is doing is weird.
21:46:36 <sclv> I tried compiling your hpaste and it just dies immediately.
21:46:43 <sclv> I'm surprised you get anything at all.
21:46:47 <ABoyNamedWooh> oh, right
21:46:48 <ABoyNamedWooh> well
21:46:53 <ABoyNamedWooh> the initial thread dies
21:46:55 <ABoyNamedWooh> I should probably fix that
21:46:59 <ABoyNamedWooh> but if you sort of
21:47:02 <ABoyNamedWooh> hit one a couple times
21:47:04 <ABoyNamedWooh> like
21:47:08 <ABoyNamedWooh> one, enter, one, enter
21:47:15 <ABoyNamedWooh> the reading loop will catch it
21:47:17 <ABoyNamedWooh> it's really weird
21:48:05 <ABoyNamedWooh> omg I got it to work
21:48:06 <ABoyNamedWooh> I think
21:48:09 <ABoyNamedWooh> yes
21:48:10 <ABoyNamedWooh> I did
21:48:13 <ABoyNamedWooh> your point awakened it
21:48:17 <ABoyNamedWooh> let me hpaste the new one
21:48:34 <ABoyNamedWooh> @paste
21:48:35 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:48:51 <sclv> annotate yr old paste
21:49:11 <ABoyNamedWooh> oh, ok
21:49:49 <ABoyNamedWooh> http://hpaste.org/7167#a1
21:51:30 <sclv> nice! you don't need the yield either, I think., or the return () in killcode.
21:51:57 <sclv> and the else case x of thing can be just reduced to else return ()
21:52:12 <ABoyNamedWooh> ah well I am leaving that there because we're going to extend it. the other stuff I'll try removing
21:52:25 <sclv> I'd suspect the hFlush calls are extraneous too.
21:52:36 <ABoyNamedWooh> it may be now
21:53:09 * ABoyNamedWooh credits switching to linux for being able to fix this problem..yeah..
21:53:15 <sclv> and then its starting to look like a real program :-)
21:53:20 <ABoyNamedWooh> haha
21:53:24 <ABoyNamedWooh> isn't it funny how that happens?
21:53:43 <ABoyNamedWooh> the annoying thing about IO () is that the rule of "if it typechecks it probably works" is so grossly violated
21:54:22 <mgsloan> is there a fast way to resize an array? Eg, realloc & copy
21:55:10 <mgsloan> I can't seem to find a function for it in the docs
21:55:56 <ABoyNamedWooh> take n array? or what is your goal?
21:56:16 <mgsloan> increase array size
21:56:19 <ABoyNamedWooh> ah
21:56:58 <ddarius> mgsloan: For mutable arrays, (the only type this question makes sense for) there isn't, but then that's just how arrays are.
21:57:12 <nkallen> silly question: is there an operator or combinator that is like: foo XXX bar = bar(foo) ?
21:57:19 <mgsloan> ddarius: Bah :P
21:57:27 <ddarius> nkallen: $ or id
21:57:35 <ddarius> Er, nevermind.
21:57:42 <nkallen> it's like $ but backwards
21:57:55 <ddarius> return for Cont is that modulo wrapping.
21:58:08 <nkallen> Â¢ maybe ;)
21:58:36 <chessguy> hm, apparently it's hard to play mario brothers in the background while ghc is building...
21:58:36 <ddarius> I don't think there is something predefined in the "standard" libraries.
21:58:36 <nkallen> is there a standard combinator or name for something like this tho?
21:59:26 <ddarius> nkallen: Not really.
22:00:26 <od> any tips on what gui library to use? i need some graphs / tables mainly.
22:00:31 <Cale> chessguy: Which Mario Bros?
22:00:58 <chessguy> Cale: the original
22:01:40 <chessguy> Cale: http://nintendo8.com/game/629/super_mario_brothers/
22:01:42 <lambdabot> Title: Super Mario Brothers - Play the Nintendo game Super Mario Brothers online
22:02:04 <mgsloan> seems to me like array growth would be a pretty basic function.. and needs to be implemented natively to be fast
22:02:53 <mgsloan> but i guess if it's not there, it's not there.
22:04:11 <sclv> its hard to read email while ghc is building :-)
22:04:12 <dolio> I don't think you're going to run any flash applets nicely during a big compile.
22:04:21 <chessguy> geez, how long does this take? :(
22:05:00 <sclv> sunday i'll be on irc and you can tell me then, if its done yet. :P
22:05:08 <Cale> chessguy: http://mx.truveo.com/Super-Mario-Bros-Frustration/id/1631434001
22:05:09 <lambdabot> Title: Super Mario Bros: Frustration - BÃºsqueda de vÃ­deos de Truveo
22:05:24 <Cale> (that has "some" profanity in it)
22:05:26 <chessguy> sclv: lol
22:05:32 <Cale> chessguy: Compiling GHC?
22:05:39 <Cale> chessguy: It takes forever and a day.
22:05:45 <chessguy> Cale: yeah, via macport
22:05:46 <chessguy> s
22:05:55 <Cale> chessguy: You shouldn't compile it unless you really really have to.
22:07:03 <Cale> actually, that URL sucks, http://video.google.ca/videoplay?docid=6204903272262158881 is the real one :)
22:07:03 <lambdabot> Title: Super Mario Bros: Frustration
22:09:02 <chessguy> Cale: i think this is the only way i can get it for mac
22:09:20 <sclv> no way! there are nice binaries on haskell.org!
22:09:23 <Cale> chessguy: Which mac?
22:09:29 <chessguy> macbook pro
22:09:35 <Cale> Tiger?
22:09:43 <chessguy> leopard
22:09:54 <sclv> totally nice binaries.
22:10:14 <chessguy> hm
22:10:36 <sclv> i gave up on macports some time ago as an insanely failed concept.
22:10:54 <Cale> http://www.haskell.org/ghc/download_ghc_682.html#macosxppc
22:10:55 <lambdabot> Title: GHC: Download version 6.8.2
22:11:14 <sclv> its like an out of date distro, but lamer, and buggy.
22:11:19 <Cale> Er, oh, is that ppc or intel?
22:11:32 <Cale> If it's Intel, there's one for Leopard :)
22:11:34 <chessguy> hm, i was going by http://haskell.org/ghc/distribution_packages.html#macosx
22:11:57 <Cale> Oh, yeah, that's not the page you want :)
22:12:03 <Cale> You want the downloads page :)
22:16:42 <chessguy> hey, it finished!
22:20:32 <lispy> ?slap loudly
22:20:33 <lambdabot> why on earth would I slap loudly?
22:20:43 <lispy> ?slap slowly
22:20:44 * lambdabot smacks slowly about with a large trout
22:20:50 <lispy> ;)
22:23:41 <zgold> I asked this question the other day but was left still confused.  I have some class, "Data blah a = ..."  Is it possible to define a default for a?  SOmething like Blah String
22:24:16 <lispy> zgold: no
22:24:35 <mgsloan> you could, however, create a type synonym for Blah String
22:24:39 <lispy> zgold: But you could make an alias to Blah String
22:24:51 <zgold> Hm
22:25:07 <zgold> But then some function taking that alis wouldn't accept a general Blah
22:25:37 <mgsloan> right, that is as it should be
22:25:57 <lispy> Why would you parameterize a type if you're not going to use the parameterization?
22:26:00 <zgold> mkay, I'll live with having to do :: Blah String on all my declarations where a isn't bound
22:26:10 <zgold> I use it in some of the constructors, not all
22:26:12 <dmwit> eh?
22:26:22 <dmwit> Why not do :: Blah a ?
22:26:35 <zgold> It doesn't know what a is and complains
22:26:43 <dmwit> So give a context.
22:26:58 <dmwit> If you need to use (==), for example, do (Eq a) => f :: Blah a.
22:27:24 <dmwit> Or just leave off the type annotation completely and the compiler will figure it out for you.
22:27:45 <chessguy> GHCi, version 6.8.2: http://www.haskell.org/ghc/  :? for help
22:27:45 <chessguy> Loading package base ... linking ... done.
22:27:45 <chessguy> Prelude>
22:27:46 <lambdabot> Title: The Glasgow Haskell Compiler
22:27:48 <chessguy> shazam!
22:28:08 <dmwit> Yes, 6.8!
22:28:13 <dolio> You were compiling 6.8.2?
22:28:34 <chessguy> dolio: apparently so :)
22:28:52 <chessguy> i just told macports to go grab ghc for me, and that's what it got me
22:29:21 <dolio> Ah, I see.
22:29:30 <dolio> Maybe it was compiling with 6.6. That'd be slow.
22:30:03 <dolio> Although even compiling with 6.8+ takes a while to build all of GHC.
23:04:30 <solrize> ghcp seems to sort of double its heap size once in a while rather than growing steadily
23:04:40 <solrize> now using 2.4G :(
23:14:27 <lispy> ghcp?
23:14:31 <solrize> typo
23:14:39 <solrize> ghc-compiled program
23:14:49 <lispy> glorious haskell cp ;)
23:15:15 <solrize> i'm getting crushed by small strings
23:15:29 <solrize> is there still such a thing as packed strings and are they smaller than bytestrings?
23:18:40 <Cale> solrize: Packed strings were what bytestrings are now.
23:19:24 <solrize> hmm, i have 5-10 million strings, 10-20 chars each, should that burn GB?
23:19:57 <solrize> if i use bytestrings will that at least be smaller than [Char]'s?
23:20:24 <quicksilver> solrize: only slightly.
23:20:37 <quicksilver> the crossover point is 8 on a 64bit machine and 12 on a 32bit machine
23:20:39 <quicksilver> IIRC
23:20:59 <solrize> sigh, thanks
23:21:01 <quicksilver> solrize: you can do slightly better if they are squashed together
23:21:12 <quicksilver> I.e. a smaller number of big bytestrings
23:21:20 <solrize> yeah i figure they're packed
23:21:20 <quicksilver> and the actual strings are just zero-copy substrings
23:21:36 <quicksilver> so you have 5-10 1MB bytestrings, sack
23:21:38 <quicksilver> say
23:21:56 <quicksilver> and each has 1 million zero-copy sub-byte-strings
23:21:58 <quicksilver> sharing storage
23:22:01 <solrize> yeah
23:23:03 <solrize> i might do something like that, or maybe even just store int indices into an mmap'd region in my table
23:23:41 <quicksilver> yes, but my point is that bytestrings work like that automatically
23:23:46 <quicksilver> so you don't need to do any work.
23:23:54 <solrize> do the substrings fit in 1 word?
23:24:02 <solrize> i mean they have a pointer and a length i guess
23:24:07 <quicksilver> smallbs = B.take 10 . B.drop 104500 $ bigbs
23:24:11 <quicksilver> ^^ doesn't copy data
23:24:20 <quicksilver> yeah, they have pointer, offset and length
23:24:26 <solrize> 3 words
23:24:35 <solrize> i guess that's ok
23:24:40 <quicksilver> you can do slightly better if you do it by hand, you can omit the pointer
23:24:48 <quicksilver> becuase you 'already know'
23:24:49 <solrize> 3 words x 10M = 120 MB
23:24:52 <solrize> i can live with that
23:25:03 <solrize> i'm on a 4GB machine
23:25:10 <quicksilver> I think you have a 4th word for the thunk pointer.
23:25:15 <quicksilver> (boxed data)
23:25:28 <solrize> yikes i hope these are strict i need to access them randomly
23:26:19 <sw17ch> can pattern matches be dynamic?
23:26:31 <quicksilver> if you mean what I suspect you mean, no.
23:26:34 <quicksilver> guards help though.
23:26:34 <sw17ch> i just realized i did something horridly stupid and it's kept me up quite late :)
23:26:52 <sw17ch> let someVal = "waht I want to match"
23:27:01 <sw17ch> let (Data someVal x) = x
23:27:05 <sw17ch> hahaha... yeah, that's really bad
23:27:06 <sw17ch> :(
23:27:08 <sw17ch> i'm depressed now
23:27:32 <solrize> sw17ch that doesn't look promising
23:27:39 <sw17ch> oh, i know
23:27:47 <sw17ch> i *just* figured it out after staring at it for too long
23:28:05 <solrize> quicksilver, thanks, i think i can get this to work and fit in the machine ok but eventually it will have to handle larger input so i'll have to figure out a more careful scheme
23:28:36 <sw17ch> now that i've made this mistake, there really is no way to do what i'm thinking is there?
23:28:53 <solrize> sw17ch i can't tell what you're thinking
23:29:14 <sw17ch> data SomeType = SomeType Int String
23:29:26 <sw17ch> let (SomeType x "matchVal") = x
23:29:37 <sw17ch> i want to pull "matchVal" into a variable :)
23:29:48 <sw17ch> let (SomeType x matchValVar) = x
23:30:13 <sw17ch> but i finally realized i'm pulling the String value into matchValVar...
23:30:18 <solrize> let y = Sometype x "matchVal"
23:30:19 <sw17ch> i can't believe it took me that long to figure this out
23:31:01 <sw17ch> i think i'm looking for more of a #define MATCHVAL = "matchVal"
23:31:17 <sw17ch> let (SomeType x MATCHVAL) = x
23:31:25 <sw17ch> a macro
23:31:36 <solrize> x is an int?
23:32:23 <solrize> i mean it looks like you're trying to extract x fro mitself
23:32:26 <solrize> from itself
23:40:19 <bos> > take 3 $ sort [50000,49999..0]
23:40:22 <lambdabot>  [0,1,2]
23:40:27 <bos> > take 3 $ sort [500000,499999..0]
23:40:28 <lambdabot>  [0,1,2]
23:40:33 <bos> > take 3 $ sort [5000000,4999999..0]
23:40:37 <lambdabot> Terminated
23:40:41 <bos> > take 3 $ sort [5000000,4999999..0]
23:40:44 <lambdabot> Terminated
23:40:50 <bos> oh well.
23:41:03 <dolio> > minimum [5000000,4999999..0]
23:41:04 <lambdabot>  0
23:42:29 <bos> the last "take 3 . sort" above made my ghci go deeply into swap.
23:43:23 <dolio> > last $ sort [500000,499999..0]
23:43:25 <lambdabot>  500000
23:43:49 <solrize> :t [5000000,4999999..0]
23:43:51 <lambdabot> forall t. (Enum t, Num t) => [t]
23:44:19 <solrize> take 3 $ sort ( [5000000,4999999..0] :: [Int32])
23:44:40 <lispy> ?slurp loudly
23:44:41 * lambdabot submits loudly's email address to a dozen spam lists
23:44:48 <lispy> ?slurp loudly
23:44:48 * lambdabot will count to five...
23:44:57 <solrize> > take 3 $ sort ( [5000000,4999999..0] :: [Int32])
23:45:00 <lambdabot> Terminated
23:45:15 <solrize> > take 3 $ sort ( [2000000,1999999..0] :: [Int32])
23:45:17 <lambdabot> Terminated
23:45:23 <solrize> > take 3 $ sort ( [2000000,1999998..0] :: [Int32])
23:45:25 <lambdabot>  [0,2,4]
23:45:28 <solrize> hehe
23:45:33 <lispy> ?. leet > take 3 $ sort ( [5000000,4999999..0] :: [Int32])
23:45:34 <lambdabot> Plugin `compose' failed with: Unknown command: "leet"
23:45:45 <lispy> ?leet What?
23:45:46 <lambdabot>  Parse error
23:45:48 <lispy> Hmm
23:46:05 <solrize> :t UArray
23:46:06 <lambdabot> Not in scope: data constructor `UArray'
23:48:06 <solrize> anyway laterz all
23:48:48 <dolio> > head $ sort [5000000,4999999..0]
23:48:51 <lambdabot> Terminated
23:53:31 <dmwit> ?. elite run take 3 $ sort ([5000000,4999999..0] :: [Int32])
23:53:35 <lambdabot> 73rmiN4T3d
23:53:39 <dmwit> =)
23:55:24 <dmwit> Come on, #haskell, entertain me!
23:56:51 <Korollary> d00d
23:57:07 <kfish> anyone know how to use cabal flags to check if Control.Arrow exports >>> or ^>> ?
23:59:18 * Twey hits dmwit over the head with a catamorphism.
23:59:37 * dmwit falls apart into his constituent atoms
23:59:44 <dmwit> err...
23:59:44 <Twey> Heh
23:59:48 <dmwit> *atams*
23:59:55 <Twey> :-)
