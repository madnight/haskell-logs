00:00:08 <dancor> sjanssen: i'm having trouble using a Handle (after fdToHandle) to do stuff with a pty
00:00:11 <nolrai_> geezusfreeek: how?
00:00:19 <geezusfreeek> nolrai_: for example, if i'm not mutilating this, on lists pure f <$> xs <*> ys == zipWith f xs ys
00:00:33 <geezusfreeek> somebody who know applicative better than i, is that correct?
00:01:09 <Cale> Well, that's one applicative instance... it's not the default one.
00:01:31 <dancor> when i have two threads, one writing like "ls\n" over and over (to `sh` running on a pty), and the other reading, it ends up reading "sh-3.2$ ls\nls\n..
00:01:33 <geezusfreeek> oh
00:01:40 <Cale> There's a ZipList newtype for that.
00:01:47 <dancor> not ls\nfile1 file2..  as i would expect
00:01:54 <geezusfreeek> ah okay
00:01:58 <dancor> i think i really need to wait on the fd
00:02:38 <dancor> i guess i can try ffi to get select
00:02:42 <sjanssen> dancor: it sounds like the first thread is writing faster than sh is responding
00:02:43 <geezusfreeek> does the default instance apply all xs to all ys or something?
00:02:56 <Cale> yeah, it's the same as the list monad
00:03:00 <dancor> sjanssen: yeah.. hm
00:03:07 <geezusfreeek> (and is there a way to check an instance definition with lambdabot?)
00:03:29 <geezusfreeek> ah okay that makes sense then, i wasn't thinking about it in relation to the monad definition
00:04:11 <sjanssen> dancor: I also don't see how select will help you
00:04:54 <dancor> sjanssen: ok i will keep trying stuff and not go the select route
00:06:30 <sjanssen> dancor: have you seen hWaitForInput?
00:06:41 <nolrai_> i just want to be able to zipWith on trees. oh well.
00:06:56 <geezusfreeek> nolrai_: that shouldn't be too hard
00:07:08 <geezusfreeek> just define an applicative instance for your tree type
00:07:46 <nolrai_> hmm.
00:09:38 <sjanssen> hmm, hpaste is down
00:10:14 <sjanssen> treezip f (Node x xs) (Node y ys) = Node (f x y) $ zipWith (treezip f) xs ys
00:13:10 <geezusfreeek> i bet there might even be a cool way to do it with SYB, but frankly SYB scares me
00:13:57 <nolrai_> whats SYB?
00:14:05 <sjanssen> scrap your boilerplate
00:14:13 <nolrai_> ahh
00:14:25 <geezusfreeek> generic programming and fun stuff like that
00:16:27 <nolrai_> as it turns out zipWith wouldn't work any way, (I was trying to define a Eq instance and zipWith is close but not quite)
00:16:58 <geezusfreeek> can you not use "deriving"?
00:18:10 <nolrai_> there was a reason i thought i couldn't but i think i was wrong. deriving it is.
00:18:38 <geezusfreeek> i think the main restriction on deriving you can't use it for record types
00:18:54 <geezusfreeek> no idea why
00:19:07 <geezusfreeek> i might even be wrong. i just remember having trouble with it once
00:19:08 <sjanssen> geezusfreeek: you can use deriving on record types
00:19:18 <geezusfreeek> ah, see, i was wrong ;)
00:19:25 <sjanssen> geezusfreeek: perhaps you're thinking of GADTs?
00:19:52 <geezusfreeek> yes, that's it
00:19:57 <geezusfreeek> and that makes more sense too
00:22:45 <lament> wooow, i just realized that unicode does work in ghc
00:22:50 <lament> ï¿½~F~R'ï¿½~F~R
00:22:50 <lament> test âˆ· Int â†’ Int
00:22:52 <lament> whoops
00:23:04 <lament> unicode works, my paste not so much.
00:35:39 <Twey> lament: Wha'?
00:35:44 <Twey> When was that instated?
00:35:53 <Twey> That's pretty cool.
00:41:39 <lament> two years ago
00:42:26 <Twey> Oh.  :-P
00:51:08 <lispy> :t (â†’)
00:51:08 <lambdabot> parse error on input `’'
00:51:17 <lispy> :t (->)
00:51:18 <lambdabot> parse error on input `->'
00:51:20 <lispy> oh
00:51:25 <lispy> :k (->)
00:51:25 <lambdabot> ?? -> ? -> *
00:51:29 <Twey> Heh
00:51:31 <lispy> :k (â†’)
00:51:32 <lambdabot> ?? -> ? -> *
00:51:43 <Twey> Isn't that awesome?
00:51:48 <Twey> :k (Â»)
00:51:49 <lambdabot> Not in scope: type variable `»'
00:51:53 <mauke> > id :: a â†’ a
00:51:53 <lambdabot>  Illegal character ''\134''
00:51:53 <lambdabot>  at "†’" (column 10)
00:51:53 <Twey> Aww.
00:51:56 <Twey> :t (Â»)
00:51:57 <lambdabot> Not in scope: `»'
00:52:00 <lispy> Kind of.  With my astigmatism, I prefer the -> arrow because it's easier to read
00:52:19 <Twey> Need a better font perhaps
00:52:42 <lispy> Well, this font is normally very nice for programming. l, L, I, 1 are all very distinct
00:52:52 <lispy> and 0 and O
00:53:10 <lispy> I just have bad eye sight even correct
00:53:14 <lispy> er corrected
00:53:24 <lispy> I'm using monaco 12pt
00:54:35 <Twey> But does that contain â†’?
01:10:18 <dancor> killThread won't stop a current call to getChar?
01:10:27 <dancor> this complicates things
01:10:39 <dancor> i guess killThread isn't portable anyway..
01:33:55 <sjanssen> dancor: killThread should interrupt getChar I think
01:34:26 <quicksilver> well, getChar shouldn't need "interrupting"
01:34:31 <quicksilver> it's non-blocking
01:34:38 <quicksilver> (or, at one level of abstraction it is)
01:34:59 <quicksilver> dancor: killThread can't interrupt blocking FFI calls, but fortunately, getChar isn't a blocking FFI call.
01:35:11 <quicksilver> (none of the standard haskell IO suite is blocking)
01:48:12 <dancor> hm well i've hacked up something that works heh
01:48:31 <dancor> not sure what i was seeing with killThread and getChar, maybe laziness subtlety
01:52:28 <dancor> > return 'a' >> return 'b'
01:52:30 <lambdabot>   add an instance declaration for (Show (m Char))
01:53:15 <dancor> well anyway, couldn't it mess ppl up to allow multiple returns
01:54:08 <mauke> > return 'a' >> return 'b' :: [Char]
01:54:10 <lambdabot>  "b"
01:54:13 <dancor> it would be cool to have a -W for that maybe?
01:55:27 <mauke> > do { x <- "dancor"; return x >> return 'b' }
01:55:28 <lambdabot>  "bbbbbb"
01:55:54 <glguy> @tell dons the popcon graph gets more interesting with percents enabled http://people.debian.org/~igloo/popcon-graphs/index.php?packages=darcs%2Cgit-core%2Cmercurial&show_installed=on&want_percent=on&want_legend=on&want_ticks=on&from_date=2003-10-01&to_date=&hlght_date=&date_fmt=%25Y-%25m&beenhere=1
01:55:54 <lambdabot> Consider it noted.
01:56:08 <sjanssen> mauke: same result without return x >>
02:51:49 <kaustuv> In haskell-mode, how can one force inferior-haskell-load-file to not split the current window if the *haskell* buffer is visible in some frame?
02:52:18 <solrize_> you have to look at git-core
02:52:30 <solrize_> oh it's there now
02:53:47 <solrize_> and heck: http://people.debian.org/~igloo/popcon-graphs/index.php?packages=darcs%2Cgit-core%2Cmercurial%2Ccvs&show_installed=on&want_percent=on&want_legend=on&want_ticks=on&from_date=2003-10-01&to_date=&hlght_date=&date_fmt=%25Y-%25m&beenhere=1
02:53:48 <lambdabot> Title: popcon graph, http://tinyurl.com/58kkzp
02:58:09 <quicksilver> solrize_: in that case, I'm adding bzr :)
02:58:10 <quicksilver> http://people.debian.org/~igloo/popcon-graphs/index.php?packages=darcs%2Cgit-core%2Cmercurial%2Cbzr&show_installed=on&want_percent=on&want_legend=on&want_ticks=on&from_date=2003-10-01&to_date=&hlght_date=&date_fmt=%25Y-%25m&beenhere=1
02:58:13 <lambdabot> Title: popcon graph, http://tinyurl.com/65qarm
02:59:08 <solrize_> Computer experts stage street protest in Oslo against Microsoft document format as standard (news.theage.com.au)
02:59:09 <solrize_> wow
03:06:23 <resiak> it's quite funny to watch what happens when you throw cvs and subversion into the mix :)
03:08:09 <quicksilver> they don't really compare.
03:08:13 <quicksilver> they're broken by design.
03:08:20 <quicksilver> I added svk in, though.
03:11:11 <quicksilver> igloo++ # popcon graphs are neat :)
03:13:39 <TSC> Maybe it's time to install popcon here
03:14:26 <resiak> quicksilver: sure, i know :)
03:22:54 <dancor> if  grabChar :: IO Char  and  processList :: String -> IO ()  is it possible to make  doList :: IO ()  which lazily only calls grabChar as longer prefixes are needed by processList
03:23:40 <sjanssen> dancor: you can use unsafeInterleaveIO
03:23:46 <dancor> yike
03:23:47 <dancor> s
03:24:19 <sjanssen> it is significantly less dangerous than unsafePerformIO -- but it still has some pitfalls
03:24:20 <opqdonut> ... or you can use hGetContents
03:24:34 <EvilTerran> which uses unsafeInterleaveIO
03:24:34 <quicksilver> opqdonut: which doesn't use grabChar :P
03:24:39 <dancor> heh
03:24:45 <sjanssen> opqdonut: which uses unsafeInterleaveIO :)
03:25:00 <sjanssen> opqdonut: btw, I'm using your irssi theme!
03:25:05 <slava> @src unsafePerformIO
03:25:06 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
03:25:38 <opqdonut> sjanssen: which one? simplicity?
03:25:38 <sjanssen> @src unsafeInterleaveIO
03:25:38 <lambdabot> unsafeInterleaveIO (IO m) = IO ( \ s -> let r = case m s of (# _, res #) -> res in (# s, r #))
03:25:43 <sjanssen> opqdonut: yep
03:25:47 <opqdonut> nice to hear :)
03:26:31 <sjanssen> I don't understand why irssi has such an anti-white-background theme as the default
03:26:47 <quicksilver> tradition
03:26:47 <dancor> leetness
03:26:47 <opqdonut> quicksilver: well if grabChar doesn't do anything too complicated it can probably be replaced with mapping over the input string
03:26:52 <opqdonut> sjanssen: me neither
03:26:55 <EvilTerran> dancor, if you can separate "how much list do i need?" out from processList, you could write grabList :: IO String, and then processList can use that
03:26:58 <quicksilver> IRC was traditionally black background
03:26:59 <quicksilver> dunno why.
03:27:05 <opqdonut> well everything was
03:27:09 * EvilTerran still uses IRC on a black background
03:27:25 * dancor is extremely pro-black-bg, internet be damned
03:27:26 <sjanssen> EvilTerran: but white backgrounds for everything else?
03:27:30 <opqdonut> the point is, the default theme uses _white explicitly_ and not "the opposite of the bg"
03:27:47 <Deewiant> light on dark is much easier to read than dark on light on monitors
03:27:49 <EvilTerran> and vim, and i've set foxit to override the back- and foreground colours of PDFs to black and light gray, too
03:27:50 * dancor paper be damned, also
03:27:56 <opqdonut> Deewiant: depends
03:28:22 <EvilTerran> unfortunately, the webbitubes break spectacularly if you try to do the same to them
03:28:38 <opqdonut> i prefer a white bg, enhanced brightness with the cost of some contrast
03:29:06 <quicksilver> sjanssen: yes, black background for this one iTerm, white for every other one.
03:29:09 <quicksilver> *shrug*
03:29:19 <quicksilver> just fixing the foreground colour isn't necessarily enouguh.
03:29:29 <quicksilver> all the other colours make assumptions about contrast too
03:29:34 <quicksilver> you need to fix the whole palette
03:29:45 <opqdonut> well that's why i made simplicity
03:29:52 <opqdonut> it works on b-on-w and w-on-b
03:29:56 <EvilTerran> quicksilver, well, that sounds like bad design, anyway
03:30:27 <opqdonut> (uses mostly only the default colours and only "good" colours for emphasis)
03:30:32 <opqdonut> (e.g red and cyan)
03:30:32 <quicksilver> it's not bad design.
03:30:37 <quicksilver> it's a fact of life about colours.
03:30:47 <quicksilver> You can't design a single palette which looks good against black and white
03:30:50 <EvilTerran> well, yes
03:30:56 <quicksilver> (well you probably can, but it restricts your choices quite a lot)
03:31:07 <EvilTerran> but, with the right style-specification language, it should be possible to have something which adapts
03:31:12 <quicksilver> so the default palette is designed to look good agains the default background.
03:31:14 <quicksilver> sure. that woudl be neat.
03:31:18 <quicksilver> but not trivial :)
03:31:24 <EvilTerran> make it haskell!
03:31:49 <quicksilver> @faq can haskell make a style-specification language which adapts color schemes to my background of choice?
03:31:49 <lambdabot> The answer is: Yes! Haskell can do that.
03:31:59 <EvilTerran> each bit of styling could be a function Style -> Style, and you'd pass in the default style (inc. background colour)
03:32:19 <EvilTerran> so you could do clever stuff like XORing with the background colour or something
03:32:29 <EvilTerran> (NB: not sure how clever that would be)
03:33:15 <opqdonut> the putty port on my mobile phone has reverse video
03:33:27 <EvilTerran> altho this strikes me as another one of those applications that'd really benefit from co-recursion/recursion proper being encoded in the type system
03:33:30 <opqdonut> that is, _real_ reverse video with all colours reversed
03:33:33 <EvilTerran> config files
03:33:58 * EvilTerran would sometimes be tempted to browse the web with reverse video, if any browser supported it
03:34:17 <EvilTerran> tire out different cones for a change ;)
03:34:28 <quicksilver> EvilTerran: such a typicall #haskeller
03:34:40 <EvilTerran> quicksilver, what?
03:34:46 <quicksilver> EvilTerran: "I could solve this reasonably well in haskell, but it would be much better with an experimental type system which I'll go write a paper on"
03:34:49 <quicksilver> :)
03:34:51 <EvilTerran> oh, i see
03:34:52 * Twey grins.
03:35:04 <sjanssen> yes, clearly the solution to color themes is co-recursion :P
03:35:12 <Twey> Haha
03:35:31 <EvilTerran> not colour themes in particular, haskell as configuration files in general
03:36:04 <quicksilver> co(lor)recursion
03:36:07 <EvilTerran> heh
03:36:21 <EvilTerran> i get antsy about the thought of using hsPlugins, say, for making my programs configurable
03:36:50 <EvilTerran> as, if a large community of trading config files springs up, you're gonna get non-terminating ones popping up
03:37:12 <EvilTerran> s/of/of people/
03:37:34 <quicksilver> I agree.
03:37:46 <EvilTerran> encoding safe recursions in the type system just strikes me as generally useful, actually
03:40:47 * EvilTerran is occasionally tempted to have a bash at writing a Catch-esque static checker to identify unsafe recursions
03:40:55 <EvilTerran> but i have no idea how easy or hard that would be
03:41:27 <solrize_> hedgehog lisp has a real simple useful hack to recognize tail recursion
03:41:52 <solrize_> just say (tailcall (f ...)) and the tailcall is a no-op except gets a compiler error if the call is not a tail call
03:42:28 <sjanssen> EvilTerran: the correct response to bad configs is: screw 'em
03:42:37 <EvilTerran> i guess
03:42:38 <sjanssen> :)
03:42:46 <opqdonut> solrize_: mm, nice
03:43:52 <EvilTerran> but, as i say, i think it'd be generally useful to have an automated checker that could identify safe recursions. i'd find it interesting to try to code within such a restriction.
03:44:48 <ski> color schemas specifying one of foreground and background color but not the other is quite aggravating, indeed
03:45:04 <EvilTerran> and, given we have the IO monad and Catch, non-termination is the only undesirable behaviour left in haskell :P
03:45:24 <idnar> haha
03:45:28 <EvilTerran> (well, in non-IO, Catch-tested haskell)
03:45:32 <ski> the only side-effect we've left
03:45:49 <ski> well
03:46:10 <ski> the IO-monad isn't a side-effect
03:46:17 <EvilTerran> ndm++
03:46:43 <gour> hi, anyone knows nick of BjÃ¶rn Bringert?
03:47:13 <ski> gour : bringert (not here atm)
03:47:14 <sjanssen> gour: bringert
03:47:28 <gour> thanks
03:47:42 <EvilTerran> ?seen bringert
03:47:42 <lambdabot> I saw bringert leaving #haskell-hac4, #ghc, #haskell.se and #haskell 2h 36m 19s ago, and .
03:47:51 <gour> :-(
03:48:10 <ski> gour : you could always @tell him something, i supposae
03:48:21 <EvilTerran> (or @ask him)
03:48:29 <gour> ski: yes, but i'd like to discuss something
03:48:50 <gour> we'll wait...
03:48:55 <ski> (interactively, i suppose you mean)
03:49:07 <gour> yep
03:51:25 <zenhacker_rouan> hi everyone
03:51:57 <ski> lo zenhacker_rouan
03:52:02 <zenhacker_rouan> how suited is haskell for use in production environment with regards to database connectivity and speed / resource efficiency
03:53:02 <zenhacker_rouan> i see haskell (GHC) has bumped up a few places in the language shootout
03:53:39 <zenhacker_rouan> i know this is an old question for you guys
03:54:09 <zenhacker_rouan> im a newcomer to haskell and am wondering if it is worth my time to invest in learning haskell
03:55:02 <ski> there's a database binding .. however i don't recall its name (hint : i haven't used it)
03:55:05 <nominolo> zenhacker_rouan: it definitely usable, there's a company that uses it for highly reliable things
03:55:34 <nominolo> zenhacker_rouan: but getting very good performance requires a bit of experience
03:56:08 <zenhacker_rouan> nominolo: thnx
03:56:10 <EvilTerran> you can get things going fast enough for most purposes fairly easily, though
03:56:33 <nominolo> EvilTerran: but you have to at least understand space leaks and strictness annotations
03:56:56 <EvilTerran> the stuff on the shoot-out is all very highly tuned, but that level of tuning isn't usually necessary unless you're actually competing
03:57:14 <EvilTerran> nominolo, true. i didn't find that that hard, myself, but i guess YMMV
03:57:50 <nominolo> if you want to write production code you have to look out for those things
03:58:22 <zenhacker_rouan> true
03:58:30 <nominolo> basically, whenever you use tail recursion you have to look closer
03:58:52 <nominolo> zenhacker_rouan: the tools to find those things are getting better, though
03:58:56 <quicksilver> it's no worse than, e.g., looking for space leaks in perl or C++
03:59:01 <quicksilver> but it is different
03:59:09 <zenhacker_rouan> :)
03:59:14 <zenhacker_rouan> i don't mind different
03:59:27 <nominolo> zenhacker_rouan: and you can always ask on the mailing list or here for help
03:59:43 <nominolo> zenhacker_rouan: but there are also helpful wiki pages
04:00:02 <zenhacker_rouan> thnx guys
04:00:11 <zenhacker_rouan> its good to know haskell has a good community
04:00:26 <zenhacker_rouan> i will read up on haskell a bit more
04:00:32 <zenhacker_rouan> i have got GHC installed
04:00:38 <nominolo> which version?
04:00:44 <zenhacker_rouan> 6.8.2
04:00:48 <nominolo> good
04:01:02 <nominolo> that one's up to 20% faster than 6.6.1
04:01:07 <zenhacker_rouan> i always use the latest version of the dev tools :)
04:02:05 <zenhacker_rouan> does anyone here have an opinion about mozart-oz
04:02:11 <mxc> can you set ghc to warn on unused varialbes or non-exhaustive matches?
04:02:20 <nominolo> mxc: -Wall
04:02:22 <mxc> ala ocaml
04:02:25 <mxc> ty
04:03:23 <quicksilver> haskell has the best community I've ever encountered.
04:03:27 <quicksilver> Not sure why.
04:03:44 <zenhacker_rouan> its because you get a good answer, even if your new
04:03:48 <zenhacker_rouan> :)
04:06:02 * quicksilver nods
04:06:07 <quicksilver> that's not the 'why' that I meant, though.
04:06:21 <quicksilver> I can't find a rational explanation for the haskell communities extraordinary friendliness.
04:06:25 <quicksilver> :)
04:06:48 <mxc> quicksilver - if it wasn't for the community, there'd be like 4 people who use it
04:06:57 <mxc> mostly named simon
04:07:05 <zenhacker_rouan> lol
04:07:13 <quicksilver> ;)
04:07:16 <quicksilver> I don't think that's true.
04:07:17 <nominolo> i think a those things rub off from the original community
04:07:26 <Zao> Avoid success at all costs.
04:07:28 <zenhacker_rouan> what about the fact that most smart people are friendly
04:07:30 <quicksilver> only 50% would be named simon.
04:07:33 <quicksilver> That's not quite 'most'.
04:07:33 <mxc> haskell is very very difficult to learn
04:07:39 <nominolo> zenhacker_rouan: not in Lisp
04:07:41 <quicksilver> java is much harder.
04:07:43 <Zao> quicksilver: Simon, Simon, Oleg and?
04:07:47 <mxc> so its kind of like how current and former navy seals have a tight community
04:07:49 <nominolo> zenhacker_rouan: and i think they're smart, too
04:08:10 <zenhacker_rouan> true
04:08:11 <mxc> phil i guess
04:08:16 <quicksilver> all programming languages are hard to learn, haskell is one of the easiest.
04:08:26 <mxc> excuse me?
04:08:29 <quicksilver> it is.
04:08:32 <Nafai> quicksilver: right...
04:08:46 <quicksilver> it's only hard for people whose brains have been broken by previous imperative or, worse, OO languages.
04:08:50 <nominolo> it all depends on yoar background
04:08:51 <quicksilver> and those are *hard* to learn.
04:09:17 <zenhacker_rouan> nominolo: i agree
04:09:18 <mxc> quicksilver - i think you migh ahve a point with Caml
04:09:26 <mxc> (screw the 'O' no one uses objects)
04:10:08 <nominolo> @users
04:10:08 <lambdabot> Maximum users seen in #haskell: 477, currently: 432 (90.6%), active: 18 (4.2%)
04:10:21 <quicksilver> the point I'm making
04:10:24 <quicksilver> and I'm making it clumsily
04:10:29 <quicksilver> because I enojy hyperbole
04:10:33 <quicksilver> is that programming is *hard8
04:10:42 <quicksilver> it takes people months and months to learn, e.g., Java from scratch.
04:10:57 <quicksilver> now, after java, they find other languages quicker
04:11:04 <quicksilver> because they're basically quite similar to java.
04:11:11 <quicksilver> However, haskell is basically not remotely similar.
04:11:11 <mxc> whats the difference between  import Data.Time.Calendar and  import Data.Time.Calendar()
04:11:19 <quicksilver> so it's like starting again from the beginning.
04:11:23 <quicksilver> however if you *were* at the beginning
04:11:24 <mxc> pls dont say '()'
04:11:27 <quicksilver> (knowing no languages)
04:11:30 <quicksilver> then haskell is no harder than java
04:11:31 <kalven> haskell is easy to learn, especially with all the good tutorials. there are hundreds of them available just on monads alone!
04:11:32 <quicksilver> I imagine it's easier
04:11:33 <Deewiant> mxc: when importing, you can also choose what identifiers to import
04:11:35 <quicksilver> hard to prove.
04:11:43 <quicksilver> mxc: () means 'import no identifiers)
04:11:47 <Deewiant> mxc: those identifiers are given in a list following the import, like import Foo (blaa, blaa)
04:11:51 <mxc> ah righ
04:11:52 <Deewiant> mxc: in your case, the list is empty, so it imports nothing.
04:11:53 <mxc> right
04:11:57 <mxc> i knew that
04:12:42 <quicksilver> leaving off the () means import everything.
04:13:48 <mxc> hm, not sure how to handle this warning:
04:13:59 <mxc>    Warning: This binding for `pred' shadows an existing binding
04:13:59 <mxc>              In the definition of `until_'
04:13:59 <mxc> on this code:
04:13:59 <mxc>   until_ :: Monad m => (a -> Bool) -> m a -> (a -> m ()) -> m ()
04:14:00 <mxc>   until_ pred prompt action = do
04:14:00 <mxc>     result <- prompt
04:14:02 <mxc>     if pred result
04:14:04 <mxc>        then return ()
04:14:06 <mxc>        else action result >> until_ pred prompt action
04:15:54 <ivanm> mxc: something that big, you should paste it somewhere...
04:15:56 <Deewiant> @index pred
04:15:56 <lambdabot> Prelude
04:16:15 <Deewiant> mxc: a pred exists in the Prelude, it's warning you that you're reusing that name in that code.
04:16:18 <mxc> sry, hpaste.org for isntance?  apologies
04:16:24 <mxc> ah, thanks
04:16:35 <quicksilver> mxc: that's a daft warning. ignore it :P
04:17:14 <mxc> one company i worked for (ocaml heavy) had a rule on the build system:
04:17:22 <quicksilver> shadowing is common when you import a bunch of stuff
04:17:23 <mxc> compiler warnings = failed build
04:17:29 <quicksilver> and some stuff exports quite short names
04:17:43 <quicksilver> life is too short to never shadow 'pred' and 'on'
04:17:50 <mxc> and the build system wouldn't build it
04:18:04 <quicksilver> I can understand why you imagine a rule like that
04:18:10 <quicksilver> but whether or not it is sensible depends on the compiler.
04:18:20 <mxc> true
04:18:22 <quicksilver> warning for all shadowing rather defeats the point of having lexical scope, IMO.
04:18:30 <mxc> true
04:18:44 <quicksilver> there are certain kinds of shadowing which look particularly suspect
04:18:47 <mxc> the ocamlc warnings seem like they were more substantive than GHCs
04:19:34 <mxc> shadowing is definitely  perfectly good thing to do, as opposed to non-exhaustive pattern macthes, which i htink you want to catch
04:19:59 <scook0> on the other hand, shadowing is a perfectly reasonable thing to have a warning for
04:20:09 <scook0> but it's probably not the sort of thing you want to combine with -Werror
04:20:53 <scook0> it would be nice to have finer control over which warnings are considered fatal
04:21:13 <mxc> agree
04:21:58 <scook0> and it would be nice to be able to say "this usage is acceptable" without having to turn off the warning altogether
04:22:06 <scook0> also, I want a pony
04:23:10 * ivanm points scook0 towards the nearest toy store
04:24:34 <mapreduce> I don't know about Haskell but I tend to shadow on purpose in Scala.  I'm really happy that it didn't inherit Java's anti-shadowing rules.
04:25:10 <TSC> I like using _varname to indicate an acceptable-unused-identifier; it would be nice to similar things for other warnings
04:25:32 <TSC> Such as "definition but no explicit type given"
04:26:09 <TSC> f :: please_infer_the_type_thx
04:26:47 <Deewiant> f :: type
04:28:03 <mib_vnbfeg> anyone can help me with the Text.XHtml library ?
04:30:18 <quicksilver> mib_vnbfeg: no. not until you ask a question :)
04:30:50 <quicksilver> TSC: f :: i_can_haz_type?
04:31:20 <mib_vnbfeg> :)
04:31:28 <mib_vnbfeg> sorry
04:31:58 <mib_vnbfeg> I am trying to generate the onload attribute of the body tag
04:32:27 <mib_vnbfeg> and there's no symbol onload in that library
04:33:18 <mib_vnbfeg> in general how do I approach such missing symbol, since there seems to be many ?
04:33:47 <mib_vnbfeg> maybe my question is stupid :s
04:34:05 <quicksilver> no, not a stupid question.
04:34:12 <quicksilver> the library doesn't have any of the 'onfoo' attributes
04:34:57 <mib_vnbfeg> can I still works those around by hand?
04:35:40 <quicksilver> does seem odd, since they are part of XHTML 1.0 Transitional
04:35:43 <quicksilver> according to the DTD
04:35:46 <quicksilver> I wonder why they're not there
04:36:18 <quicksilver> I think it's extremely simple to add though
04:36:25 <quicksilver> mib_vnbfeg: have a look at http://www.cs.chalmers.se/~bringert/darcs/hope/Hope/Util/XHtml.hs
04:36:34 <quicksilver> mib_vnbfeg: seems to contain a definition for onLoad
04:37:41 <mib_vnbfeg> ok, let me have a look
04:37:45 <Baughn> Is there any reason to use Map Int instead of IntMap?
04:39:22 <quicksilver> Baughn: to make it run slower?
04:39:54 <Deewiant> can't IntMap be implemented as a specialization of Map?
04:39:59 <Baughn> Ah. No thanks, then.
04:40:52 <quicksilver> Baughn: more seriously, to run code which is polymorphic over it
04:40:59 <quicksilver> Baughn: you might have useful code which works on Map k v
04:41:20 <Baughn> I might
04:41:32 <quicksilver> Deewiant: specialization is the enemy of parametric polymorphism :)
04:43:32 <Deewiant> or rewrite rules, rather, I guess
04:44:31 <mib_vnbfeg> it really is that simple strAttr "name" "value"; 10x
04:44:42 <quicksilver> mib_vnbfeg: yay ;)
05:17:52 <gour> bringert: hello. i've a problem with c2hs and saw your msg http://haskell.org/pipermail/c2hs/2007-June/000797.html. i'd like to use something like: allocaArray n as inmarshaller in fun hook, but it looks it's not possible. have you worked on adding such feature or there is some workaround?
05:19:40 <bringert> gour: no, I haven't purpused that
05:19:50 <gour> bringert: any workaround?
05:20:07 <bringert> gour: a where-definition
05:20:42 <gour> bringert: i'm trying that, but cannot figure out what's wrong. any example at hand?
05:21:26 <bringert> gour: see http://code.haskell.org/alsa/Sound/Alsa/Core.chs
05:22:13 <gour> bringert: thanks a lot
05:23:49 <gour> bringert: should it work with inmarshaller as well?
05:24:07 <bringert> gour: oh, dunno if I've tried that
05:24:13 <bringert> but I don't see why not
05:26:35 <gour> bringert: i need something like: 'allocaArray n' instead of 'alloca'
05:28:13 <gour> as inmarshaller
06:15:25 <yuriyp> couple of years ago the following paper was published
06:15:30 <yuriyp> http://www.informatik.uni-kiel.de/~fhu/PUBLICATIONS/1999/ifl.html
06:15:31 <lambdabot> Title: Erlang-Style Distributed Haskell
06:15:45 <yuriyp> does anybody know what happend to that idea?
06:16:32 * ivanm guess the same thing that happens with a lot of Haskell projects, e.g. hIDE
06:16:50 <yuriyp> it's a shame
06:17:35 <yuriyp> it was a good idea
06:19:54 <pejo> yurip, Frank Huch has a couple of more recent papers citing that one, perhaps they provide more information?
06:20:05 <pejo> Sorry, mistyped your name.
06:20:32 <yuriyp> pejo: thanks for the tip, will check them out
06:25:06 <shepheb> any Blogger users share their advice on embedding Haskell code?
06:27:33 <ivanm> shepheb: depends on what blogging engine you use
06:27:39 <pejo> shepheb, some blogging software (?) out there can embed latex.
06:28:01 <shepheb> okay. but I'm using the stock Blogger.com engine for now.
06:28:20 <pejo> shepheb, http://conal.net/blog/ - look at the bottom for technical details.
06:28:21 <lambdabot> Title: Conal Elliott
06:28:36 <idnar> ivanm: Blogger supports different engines?
06:28:48 <pejo> (And also watch the beautiful symbols in "Pairs, Sums and reactivity ".)
06:29:26 <ivanm> idnar: ahh, I misread it as "any bloggers" ;-)
06:30:13 <shepheb> ndm uses <pre> tags on Blogger. I guess I'll use that for now. I'm in the early stages of playing with LaTeX, so I may eventually move to such an engine.
06:32:17 <MarcWeber> Does hslogger provide Int -> Priority ?
06:37:20 <shapr`> @quote
06:37:20 <lambdabot> Cale says: "Betta watch your back when I'm packin' a nine/I'll pump you fulla holes like the rational line"
06:37:44 <mauke> Ã´_o
06:37:58 <shapr`> ?
06:38:05 <shapr`> @quote
06:38:05 <lambdabot> directory says: http://darcs.haskell.org/packages/directory/
06:38:10 <opqdonut> :D
06:38:14 <shapr`> ??
06:38:18 <shapr`> @quote
06:38:18 <lambdabot> <shapr> says: GHC has more flags than the UN.
06:38:24 <mauke> heh. that was supposed to go to @where
06:38:34 <shapr`> Did the quote collection get wiped or something?
06:38:45 <opqdonut> i guess
06:38:51 <mauke> @quote
06:38:51 <lambdabot> directory says: http://darcs.haskell.org/packages/directory/
06:38:51 <opqdonut> ?quote stereo
06:38:51 <lambdabot> No quotes match. stty: unknown mode: doofus
06:38:59 <opqdonut> look, no stereo-quote
06:39:02 <mauke> @quote fugue
06:39:02 <lambdabot> No quotes match. You untyped fool!
06:39:06 <shapr`> Um, where are all the quotes?
06:39:11 <shapr`> @quote shapr
06:39:11 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
06:39:13 <shapr`> !!
06:39:28 <opqdonut> :D
06:39:29 <shapr`> Everything got wiped?
06:39:29 <mauke> @quote mauke
06:39:29 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
06:39:37 <mauke> looks like it
06:39:38 <opqdonut> lambdabot: that's your mind
06:39:45 <shapr`> @version
06:39:46 <lambdabot> lambdabot 4p603, GHC 6.8.2 (Linux i686 2.40GHz)
06:39:46 <lambdabot> darcs get http://code.haskell.org/lambdabot
06:39:46 <mauke> @karma mauke
06:39:46 <lambdabot> You have a karma of 10
06:39:51 <Deewiant> lambdabot--
06:39:52 <shapr`> @karma
06:39:52 <lambdabot> You have a karma of 0
06:39:55 <shapr`> oh
06:40:04 <shapr`> @karma shapr
06:40:04 <lambdabot> shapr has a karma of 41
06:40:06 <mauke> @karma shapr
06:40:06 <lambdabot> shapr has a karma of 41
06:40:10 <shapr`> well, some stuff is left
06:40:23 <Deewiant> @karma lambdabot
06:40:24 <lambdabot> lambdabot has a karma of 0
06:41:36 <pejo> Can one manually instruct lambdabot to save its quotes/facts/etc to permanent storage?
06:41:43 <mauke> yes, @flush
06:42:19 <shapr`> meeting time, bbl
06:47:34 <shepheb> @index Monad
06:47:34 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
06:47:40 <shepheb> ?instances Monad
06:47:42 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
06:51:21 <shepheb> my ghci is having trouble finding the instance for Monad ((->) r), but I'm importing Control.Monad
06:51:57 <mauke> it's in Control.Monad.Reader
06:52:11 <Deewiant> looks like it's in Control.Monad.Instances actually
06:52:20 <Deewiant> instance Monad ((->) r) -- Defined in Control.Monad.Instances
06:52:21 <shepheb> argh. thanks.
06:52:27 <mauke> you and your newfangled 6.8
06:52:36 <Deewiant> :-)
06:56:41 <allbery_b> Instances isn't supposed to be imported directly, though, is it?
06:58:02 <quicksilver> sure, if you want to.
07:04:20 <mxc> any suggestions for a statistics package?
07:11:55 <romildo> Hi.
07:12:59 <romildo> Is there any facilities in the Haskell library for formatting output messages in Haskell programs. Maybe something similar (in functionality) to printf from C.
07:13:08 <Zao> romildo: There's printf :P
07:13:12 <Deewiant> @index printf
07:13:12 <lambdabot> Text.Printf
07:13:17 <sw17ch> hehehe
07:13:28 <romildo> thanks.
07:13:33 <Deewiant> > printf "%d %d" 15 10
07:13:34 <sw17ch> :t Text.Printf
07:13:38 <lambdabot>  <Plugins.Eval>:1:10: parse error on input `='
07:13:40 <lambdabot> Couldn't find qualified module.
07:13:43 <Deewiant> O_o
07:13:44 <sw17ch> :t printf
07:13:45 <mauke> > 2+@
07:13:45 <lambdabot>   parse error on input `}'
07:13:45 <lambdabot> forall r. (PrintfType r) => String -> r
07:13:47 <mauke> > 2+2
07:13:48 <lambdabot>  4
07:13:55 <Deewiant> > printf "foo"
07:13:56 <lambdabot>  Add a type signature
07:14:03 <Deewiant> > printf "foo" :: String
07:14:04 <lambdabot>  "foo"
07:14:13 <mauke> > "" ++ printf "%d" 15
07:14:14 <lambdabot>  "15"
07:14:19 <Deewiant> > printf "%d" 1
07:14:20 <lambdabot>  Add a type signature
07:14:22 <mauke> > "" ++ printf "%d %d" 15 10
07:14:23 <lambdabot>  "15 10"
07:14:28 <Deewiant> > printf "%d %d" 15 10
07:14:28 <lambdabot>  Add a type signature
07:14:32 <mauke> ok, why didn't it work before?
07:14:39 <Deewiant> randomness
07:14:41 <Deewiant> > printf "%d %d" 15 10
07:14:41 <lambdabot>  Add a type signature
07:14:43 <Deewiant> :t Text.Printf
07:14:43 <Deewiant> > printf "%d %d" 15 10
07:14:44 <lambdabot> Couldn't find qualified module.
07:14:44 <lambdabot>  Add a type signature
07:14:51 <sw17ch> @where printf
07:14:51 <lambdabot> I know nothing about printf.
07:14:52 <Deewiant> guess it wasn't that :-P
07:15:04 <sw17ch> so, how does it handle variable arguments?
07:15:14 <Deewiant> major hackery as I understand it
07:15:21 <sw17ch> :t Text.Printf.printf
07:15:22 <lambdabot> forall r. (PrintfType r) => String -> r
07:15:39 <Deewiant> @instances PrintfType
07:15:40 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
07:15:43 * vincenz points out that lambdabot can be used via PMs
07:16:55 <sebell> @instances Text.Printf.PrintfType
07:16:55 <lambdabot> IO a
07:17:01 <Deewiant> @instances-importing Text.Printf PrintfType
07:17:02 <lambdabot> (a -> r), IO a, [c]
07:17:25 * sebell boggles
07:19:10 <quicksilver> well there is two kinds of overloading, really
07:19:19 <quicksilver> the simple one to explain is the IO a / String business
07:19:28 <quicksilver> basically it's sprintf and printf combined
07:19:34 <quicksilver> that's an "obvious" use of typeclasses
07:19:38 <vincenz> And the other one is to support multiple arguments :)
07:19:42 <quicksilver> the second is the (a -> r) part
07:20:02 <quicksilver> that says, printf either has the type "I'm finished" (aka IO () or String)
07:20:20 <quicksilver> or it has the type "I'm awaiting another argument and then I'm a printf type again"
07:20:28 <quicksilver> i.e. PrintfType r => (a -> r)
07:22:21 <sebell> quicksilver: That's a good explanation.
07:25:03 <pejo> Igloo, bostream.se?
07:27:58 <Igloo> pejo: Hackathon B&B wireless
07:30:11 <pejo> Ah, the Hackathon is now. Cool!
07:33:15 <quicksilver> sebell: thanks :)
07:33:26 <nolrai_> @src FoldM
07:33:26 <lambdabot> Source not found. Are you on drugs?
07:33:31 <nolrai_> @src foldM
07:33:32 <lambdabot> foldM _ a []     = return a
07:33:32 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
07:33:52 <Deewiant> it's a fax machine
07:34:24 <nolrai_> foldM is a alteration of foldl, right?
07:34:52 <nolrai_> Is there a simmilar alteration of foldr, and if not why not?
07:35:33 <allbery_b> @src foldM
07:35:33 <lambdabot> foldM _ a []     = return a
07:35:33 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
07:35:52 <nolrai_> @src foldl
07:35:52 <lambdabot> foldl f z []     = z
07:35:52 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:35:52 <quicksilver> nolrai_: because there is a notion of 'order'
07:36:06 <quicksilver> nolrai_: it 'matters' which order the side effects are performed.
07:36:11 <quicksilver> so reversing it doesn't make sense
07:36:20 <quicksilver> you have to do effect 1 before you get result 1 to pass to action 2
07:36:29 <quicksilver> I think foldM is a right fold, isn't it?
07:36:32 <quicksilver> @src foldr
07:36:33 <lambdabot> foldr f z []     = z
07:36:33 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:36:36 <Deewiant> no, it's left alright
07:36:50 <quicksilver> ah yes, it's left.
07:37:27 <tromp> foldr would be like reversing time order
07:43:03 <yuriyp> @hoogle Int -> [IO String]
07:43:04 <lambdabot> No matches, try a more general search
07:43:11 <yuriyp> @hoogle Int -> [IO a]
07:43:11 <lambdabot> No matches, try a more general search
07:43:16 <yuriyp> @hoogle [IO a]
07:43:17 <lambdabot> No matches, try a more general search
07:43:21 <yuriyp> @hoogle IO [a]
07:43:22 <lambdabot> Control.Concurrent.Chan.getChanContents :: Chan a -> IO [a]
07:43:22 <lambdabot> Control.Concurrent.nmergeIO :: [[a]] -> IO [a]
07:43:22 <lambdabot> Control.Concurrent.mergeIO :: [a] -> [a] -> IO [a]
07:48:17 <nolrai_> "reverseTimefoldM f a (x:xs) = do {os <- reverseTimefoldM f a xs; o  <- f x; return (o:os)}" make sense?
07:50:10 <kaustuv> Why is that a fold and not a map? And when is "a" used?
07:50:37 <quicksilver> kaustuv: it's a fold because it takes a list of values and reduces it to a single value
07:50:55 <quicksilver> kaustuv: "a" is fed into "f"  which is a binary action.
07:51:06 <Deewiant> except that it isn't, in the above.
07:51:14 <kaustuv> ==Deewiant
07:51:33 <nolrai_> I ment "reverseTimefoldM f a (x:xs) = do {o : os <- reverseTimefoldM f a xs; o'  <- f o; return (o':o:os)}" and a is used in the [] case.
07:52:35 <nolrai_> wait.
07:52:57 <quicksilver> oh, sorry.
07:53:05 <quicksilver> thought you mean foldM :)
07:55:55 <nolrai_> I realy mean "let f a (x:xs) = do {o <- revrseTimefoldM f a xs; o' <- f o x; return o';}"
07:56:13 <nolrai_> the type at least is right.
07:57:22 <nolrai_> Well it will ether work or it wont.
07:59:15 <kaustuv> @hoogle [[a]] -> [a]
07:59:15 <lambdabot> Prelude.concat :: [[a]] -> [a]
07:59:15 <lambdabot> Data.List.concat :: [[a]] -> [a]
07:59:15 <lambdabot> Data.List.intercalate :: [a] -> [[a]] -> [a]
08:08:29 <takamu> hi
08:10:43 <tromp> why not simply reverseTimefold f a = foldM f a . reverse ?
08:13:36 <nolrai_> oh thats close, would "reverseTimefold f a = foldM (swap f) a . reverse" be right or am i confused?
08:14:27 <nolrai_> :t foldM f a . reverse
08:14:28 <lambdabot> forall (m :: * -> *) a. (Monad m, SimpleReflect.FromExpr (m Expr), Show a) => [a] -> m Expr
08:14:45 <nolrai_> :t \f a -> foldM f a . reverse
08:14:46 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a -> a1 -> m a) -> a -> [a1] -> m a
08:17:30 <quicksilver> nolrai_: flip, not swap.
08:17:45 <nolrai_> :t swap
08:17:46 <lambdabot> Not in scope: `swap'
08:18:00 <nolrai_> ok
08:18:02 <quicksilver> nolrai_: foldl1 f  xs = reverse . foldr1 (flip f) . reverse $ xs
08:18:16 <quicksilver> it get a bit more fiddly when you have foldl not foldl1
08:18:22 <quicksilver> have to put the 'unit' in the right place
08:19:18 <nolrai_> :t \f a-> FoldM (flip f) a . reverse
08:19:19 <lambdabot> Not in scope: data constructor `FoldM'
08:19:24 <nolrai_> :t \f a-> foldM (flip f) a . reverse
08:19:25 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> a -> m a) -> a -> [a1] -> m a
08:20:48 <Gilly> any ideas which to use, hpdf or hsharupdf?
08:22:46 <Gilly> hmm... actually hsharupdf doesn't look 'ready' yet :)
08:35:01 <skorpan> @src Maybe.bind
08:35:01 <lambdabot> Source not found. Do you think like you type?
08:35:12 <skorpan> @src Maybe
08:35:12 <lambdabot> data Maybe a = Nothing | Just a
08:37:53 <Feuerbach> skorpan: what are you looking for? binding operator is just (>>=)
08:38:19 <allbery_b> @src Maybe (>>=)
08:38:19 <lambdabot> (Just x) >>= k      = k x
08:38:19 <lambdabot> Nothing  >>= _      = Nothing
08:55:10 <dancor> hm if src/Main.hs imports src/System/Process/Pty.hsc, cabal flips out
08:55:30 <opqdonut> NINJAS FLIP OUT AND KILL PEOPLE
08:55:32 <opqdonut> sry, nvm me
08:55:34 <dancor> but it's fine if Main is an hsc, or if Pty is an hs
08:55:38 <dancor> discuss
08:55:43 <dancor> DISCUSS
08:57:44 <Saizan> dancor: is System.Process.Pty liste in other-modules?
08:57:54 <Saizan> dancor: if not there's no hope that cabal can preprocess it
08:58:24 <dancor> ah.
09:01:03 <skorpan> Warning: This binding for `exp' shadows an existing binding In the definition of `checkStm'
09:01:07 <skorpan> exactly what does that mean?
09:01:35 <sethk> skorpan, means a symbol is used twice and the second use hides the first
09:01:49 <Saizan> ?type exp
09:01:50 <lambdabot> forall a. (Floating a) => a -> a
09:02:03 <Saizan> by defining your own exp you are shadowing the Prelude one
09:02:13 <skorpan> ah, did not know there was such a function in Prelude
09:02:16 <skorpan> thanks a lot
09:02:27 <desegnis> skorpan, exp is an established name for the exponentiation function of base e
09:04:31 <realspace> hpaste down?
09:04:43 <Deewiant> evidently
09:05:14 <realspace> uhm. ok, i have a problem:
09:05:38 <realspace> line 1 contains: import qualified Data.ByteString as B
09:05:51 <realspace> line 2 contains: main = putStrLn "Hello World"
09:06:27 <realspace> but, when i try to compile and link with ghc, i get: (.text+0x14f): undefined reference to `__stginit_bytestringzm0zi9zi0zi1_DataziByteString_'
09:06:32 <skorpan> lol
09:06:37 <realspace> any ideas?
09:06:49 <chessguy> ou7ch
09:07:00 <dv\> realspace, try --make
09:07:23 <realspace> wow!
09:07:31 <realspace> that work. but why?
09:07:49 <chessguy> @quote ghc
09:07:49 <lambdabot> bos says:  i'm very pleased by the recent progress of the C++ standard.  it's gradually eroding the performance advantage of C++ compilers over GHC, without the simons having to do anything.
09:08:04 <chessguy> @ghc
09:08:04 <lambdabot> <shapr> says: GHC has more flags than the UN.
09:08:13 <chessguy> ooh, that's a nie one
09:08:22 <chessguy> @ghc
09:08:22 <lambdabot> bos says:  i'm very pleased by the recent progress of the C++ standard.  it's gradually eroding the performance advantage of C++ compilers over GHC, without the simons having to do anything.
09:16:13 <desegnis> realspace, --make tells the linker the right libraries to link in, in this case, ByteString
09:16:19 <dancor> realspace: it's because you need to say the libraries for the linker (like in ghc you need e.g. -lutil to use openpty)
09:16:30 <dancor> (in gcc, rather)
09:18:51 <realspace> dancor, dasignis: i thought, ghc will this automagically when i just juse "ghc foo.hs -o foo". but anyway, i changed my makefile in the meantime to use --make for the haskell stuff
09:19:32 <pa-ching> Hmm, what's a nice concise idiom for turning a list of numbers into cumulative sums...
09:19:46 <quicksilver> pa-ching: scanl
09:19:53 <pa-ching> Ooh.
09:19:59 <quicksilver> > scanl (+) 0 [1,2,3,4,5,6]
09:20:00 <pa-ching> Never got to use that before
09:20:02 <lambdabot>  [0,1,3,6,10,15,21]
09:20:06 <pa-ching> Thanks!
09:20:06 <quicksilver> well, that's what it does :)
09:20:28 <chessguy> pa-ching, you didn't think you were going to get to implement something like that from scratch did you?
09:20:30 <chessguy> :)
09:21:27 <pa-ching> Nah, I knew there had to be some solution in less than ten characters ;D
09:25:11 <lament> in haskell, all programs can be written in less than ten characters
09:25:51 <sieni> that's better than with sha-1!
09:26:06 <therp> in this weird 1st april programming language that consists only of whitespaces, any program can be written with 0 characters :)
09:26:18 <Deewiant> whitespace is characters
09:26:19 <lament> sieni: but not as good as CRC
09:27:36 <sieni> except that crc isn't very reliable as a programming language
09:28:22 <therp> deewiant: I wouldn't say that whitespace is a legitimate character, http://www.merriam-webster.com/dictionary/character
09:28:22 <lambdabot> Title: character - Definition from the Merriam-Webster Online Dictionary
09:29:04 <Deewiant> "a significant visual mark or symbol."
09:32:19 <takamura> well, withespace is a significant no-mark
09:37:25 <zooko> Greetings, people of #haskell!
09:44:30 <shepheb> hi, zooko
09:45:33 <zooko> Folks: yesterday you helped me compile darcs-2.0.0 on Ubuntu Dapper with ghc-6.4.1.
09:45:38 <zooko> I submitted a patch to darcs.
09:45:51 <zooko> Today I'm trying to compile darcs-2.0.0 on Windows with ghc-6.8.2, and I get this:
09:45:56 <zooko> http://bugs.darcs.net/issue789
09:46:00 <lambdabot> Title: Issue 789: compilation failure on Windows - Darcs bug tracker
09:46:11 <zooko> Does anyone know how to fix src/Darcs/Arguments.lhs:88:39:
09:46:11 <zooko>      Warning: Imported from `Darcs.Hopefully' but not used: `info'
09:46:49 <zooko> Here is the source code in question:
09:46:50 <zooko> http://allmydata.org/trac/darcs-2/browser/src/Darcs/Arguments.lhs
09:46:55 <lambdabot> Title: /src/Darcs/Arguments.lhs â€“ darcs-2 (demo trac instance) â€“ Trac
09:47:06 <zooko> more precisely:
09:47:06 <zooko> http://allmydata.org/trac/darcs-2/browser/src/Darcs/Arguments.lhs#L88
09:47:14 <lambdabot> Title: /src/Darcs/Arguments.lhs â€“ darcs-2 (demo trac instance) â€“ Trac, http://tinyurl.com/62cwtf
09:47:43 <xerox> did you try removing |info| from the import list?
09:47:53 * zooko tries that.
09:48:09 <zooko> (Good idea...)
09:48:44 <zooko> Hm..  Although I guess I need to conditionalize this on the platform, since this warning doesn't appear when compiling it on other platforms.
09:48:47 <Saizan> zooko: have you cleaned and reconfigure after installing cygwin?
09:49:17 <zooko> This is a clean checkout of darcs, followed by autoconf, followed by configure, followed by make.
09:49:19 <zooko> Why?
09:50:11 <zooko> I see that the use of info is conditionalized with ifndef WIN32...
09:50:37 <zooko> See: http://allmydata.org/trac/darcs-2/browser/src/Darcs/Arguments.lhs#L1073
09:50:40 <lambdabot> Title: /src/Darcs/Arguments.lhs â€“ darcs-2 (demo trac instance) â€“ Trac, http://tinyurl.com/62cwtf
09:50:57 <Saizan> so it's inferring your platform correctly, but -Werror is killing it..
09:51:45 <zooko> Ok, I can put all the imports of the unused bits inside #ifndef or #ifdef...
09:54:05 <zooko> Say, while I'm on the subject, I really want an autoconf macro which acts like AC_CHECK_LIB, but for ghc, not for gcc.
09:54:19 <zooko> The darcs autoconf currently uses AC_CHECK_LIB (or some such macro) to tell whether libz is usable.
09:54:53 <zooko> But the way it does this is checking whether libz is usable *by gcc*.  It turns out on Windows, and possibly on other system configurations, that libz being usable by gcc does not imply that libz is usable by ghc.
09:55:14 <zooko> Now, we could use this macro and try a haskell program that requires ghc: http://www.haskell.org/pipermail/haskell-cafe/2005-August/010979.html
09:55:15 <lambdabot> Title: [Haskell-cafe] Creating a Haskell section in Autoconf Macro Archive, http://tinyurl.com/299tfn
09:55:40 <zooko> Could someone show me a haskell program that I could put in there which would succeed if it can link to libz and fail if it can't?
09:55:58 <zooko> Or, even better, could someone define an AC_CHECK_LIB for ghc that checks exactly this condition?
09:57:26 <glen_quagmire> where can I find stuff about class ... | ..   where ?
09:57:29 <glen_quagmire> that bar thingy
09:57:36 <mrd> functional dependencies
09:57:47 <glen_quagmire> thank you
09:58:07 <xerox> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#functional-dependencies
09:58:08 <lambdabot> Title: 8.6. Class and instances declarations, http://tinyurl.com/245leb
09:58:18 <nominolo> a -> b means if I know the "a" then there's one unique "b"
09:58:54 <zooko> Here is the TRY_COMPILE_GHC that we already have: http://allmydata.org/trac/darcs-2/browser/aclocal.m4
09:58:57 <lambdabot> Title: /aclocal.m4 â€“ darcs-2 (demo trac instance) â€“ Trac
10:25:49 <Gilly> Ok, say that I have some parameters that affect how functions behave. I'd like to let user specify those parameters only once and then every function should be able to access that context. What would be the best way to do this? Write a monad?
10:26:35 <Cale> Gilly: You could perhaps use a reader monad -- of course, behind the scenes, that's just function parameters :)
10:27:01 <Gilly> everything is fine as long as it's behind the scenes :)
10:27:48 <Gilly> but yea, let me clarify my problem: i'm writing a geometry drawing software. i'd like to be able to decide the part of the plane that is going to be of interest to the program in the very beginning
10:28:11 <Gilly> and then make use of that information in internal calculations (stopping when we reach the border etc)
10:29:15 <shepheb> Gilly: the reader monad will definitely help you thread that through your program without having to manually pass it on.
10:29:15 <Gilly> but for the user taking an intersection of two paths should just show as intersect path1 path2 to get a list of points, not as intersect area path1 path2
10:29:38 <Gilly> ok thanks, i'll look at it
10:29:43 <Otoom> > [(x,y,z) | x <- [1..9], y <- [1..3], z <- [1..18] ]
10:29:44 <lambdabot>  [(1,1,1),(1,1,2),(1,1,3),(1,1,4),(1,1,5),(1,1,6),(1,1,7),(1,1,8),(1,1,9),(1,...
10:30:07 <shepheb> Gilly: oh, hmm. that might force you to have a general Geom monad that your users would have to work inside of.
10:31:06 <Cale> Gilly: Of course, that means that you end up with a monadic-looking sort of interface. If that doesn't bother you, then that's great.
10:31:22 <Gilly> well i think it could be clear for the user :)
10:31:43 <Gilly> like runGeom <area> <other opts> blockofgeometry
10:32:42 <Gilly> but the thing is, should i just do my own monad or use some existing one?
10:33:23 <lament> is foldr or foldl the "standard" one?
10:34:22 <EvilTerran> foldr is the catamorphism
10:34:39 <geezusfreeek> foldr also has better laziness properties
10:34:49 <geezusfreeek> or use foldl' for those cases where you need strictness
10:34:58 <geezusfreeek> but foldl often makes a lot of thunks
11:11:49 <glen_quagmire> > Int :: *
11:11:49 <lambdabot>  Parse error at "*" (column 8)
11:17:46 <paczesiowa> @seen dcoutts
11:17:46 <lambdabot> I saw dcoutts leaving #haskell-hac4, #haskell-soc, #gentoo-haskell, #haskell and #ghc 1h 16m 54s ago, and .
11:18:20 <laura85> hi ^^
11:18:34 <takamura> hi, laura85
11:25:22 <bd_>     Illegal polymorphic or qualified type: forall t. [t] -> [t]
11:25:22 <bd_>     In the type signature for `foo':
11:25:22 <bd_>       foo :: (forall t. [t] -> [t]) -> [a] -> Int
11:25:30 <bd_> ^^what extension do I need for types like this?
11:27:06 <xerox> bd_ http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#universal-quantification
11:27:07 <lambdabot> Title: 8.7. Other type system extensions, http://tinyurl.com/3c7ura
11:27:31 <ivan_salazar> Hello, I'm having trouble grouping some files in a module.
11:28:08 <bd_> aha, Rank2Types, thanks
11:28:20 <ivan_salazar> I have some modules that I'd like to group in a module (in the way that HashTable, List, and others are grouped inside Data)
11:28:39 <ivan_salazar> And then include those modules in other modules
11:28:48 <paczesiowa> put them in directory Data
11:28:56 <paczesiowa> and name them Data.*
11:29:28 <ivan_salazar> OK, I've already done that, but those modules have "interdependencies"
11:29:44 <ivan_salazar> And I don't know how to include those inside them.
11:29:47 <bd_> ivan_salazar: avoid that :)
11:29:55 <bd_> there's a workaround but it's really painful
11:30:15 <bd_> If there's a lot of interdependencies it suggests you might need to break them out into more modules
11:30:54 <ivan_salazar> OK, I'll try to explain myself a little more so maybe it makes sense and you may suggest me something.
11:31:02 <ivan_salazar> I have these files:
11:31:45 <ivan_salazar> Salsa.Types, Salsa.Lexer, Salsa.Parser, Salsa.Interpreter and one last named Tito.
11:32:14 <gnuth> back
11:32:20 <ivan_salazar> Parser includes Lexer and Types, Interpreter includes Types and Parser, and at last, Tito includes Interpreter
11:32:56 <paczesiowa> ivan_salazar: put Types Lexer Parser and Interpreter in dir Salsa
11:32:58 <ivan_salazar> Or at least I included them before trying to group them inside the Salsa directory.
11:33:10 <paczesiowa> remember to name them "Data.Types"
11:33:18 <bd_> ivan_salazar: It should just work then, as long as there are no loops, and you put it in the right directory
11:33:27 <ivan_salazar> paczesiowa: OK, Check.
11:33:33 <Deewiant> "Salsa.Types" rather.
11:33:37 <paczesiowa> yeah
11:33:42 <paczesiowa> my bad
11:33:52 <Deewiant> and not name them, but specify that in the module declaration.
11:34:22 <paczesiowa> that's what I meant
11:34:30 <ivan_salazar> Deewiant: something like "module Salsa.Types where " ?
11:34:42 <Deewiant> ivan_salazar: exactly.
11:34:58 <paczesiowa> ivan_salazar: it must work, I have exactly the same structure for my interpreter (even module names:)
11:35:04 <ivan_salazar> And how do I include Types inside, Salsa.Parser?
11:35:08 <paczesiowa> yes
11:35:16 <paczesiowa> import Salsa.TYpes
11:35:30 <ivan_salazar> mmm... ghc says this:
11:36:23 <Deewiant> ivan_salazar: you will need to pass "-i.." to GHC if you're compiling from within the Salsa directory
11:36:28 <ivan_salazar> ivan@EVA-00:~/lambada/Salsa$ ghc --make Parser.hsParser.hs:3:7:    Could not find module `Salsa.Lexer':      Use -v to see a list of the files searched for.
11:36:46 <paczesiowa> ivan_salazar: compile it from parent dir
11:36:51 <Deewiant> ivan_salazar: what I said.
11:36:55 <paczesiowa> ghc --make Salsa/Parser.hs
11:36:55 <ivan_salazar> oh, thanks...
11:37:07 <ivan_salazar> Both of you, paczesiowa and Deewiant.
11:37:10 <Deewiant> ivan_salazar: because it looks for "Foo.Bar" in the directory Foo.
11:37:15 <Deewiant> no problem.
11:37:21 <ivan_salazar> Oh, thanks.
11:37:37 <gnuth> Deewiant: (mapcar copy-blob ...) will obviously create copies of the object themselves :)
11:38:38 <Deewiant> gnuth: wrong channel or person, mayhaps? I have no idea what you're talking about. ;-)
11:38:57 <paczesiowa> and wrong language:>
11:40:13 <gnuth> Deewiant: wtf
11:40:29 <Deewiant> gnuth: I agree with your sentiment.
11:44:47 <zooko> What is Salsa?
11:46:10 <ivan_salazar> zooko: I'm working on a school project where I have to build an MVC framework for webdevelopment, including an interpreted language that will be embedded in order to implement dynamic web pages.
11:46:33 <kpreid> Deewiant: gnuth is an annoyance bot which has been bothering #lisp for a while. it seems to copy lines between channels
11:48:26 <ivan_salazar> zooko: I named the framework "Lambada (as in the brazilian dance)" (as I am the only one using a functional language rather than Python as my classmates are), and I named my interpreted language "Salsa" (it's Lisp/Scheme-like).
11:49:02 <ivan_salazar> zooko: That's Salsa (nothing important at all XD)
11:49:45 <zooko> :-)
11:49:56 <Deewiant> kpreid: that's weird. :-P
11:50:29 <lament> ivan_salazar: are you kicking your classmates' asses?
11:50:34 <AndreWe> I would like to print the contents of a string list one after the other. Seems like a simple task. The function signature should be [String] -> IO ()
11:50:48 <kpreid> AndreWe: mapM_ putStrLn
11:50:51 <gnuth> Deewiant: er
11:51:23 <kpreid> Deewiant: "pyguyy_" has just admitted to owning it.
11:51:25 <AndreWe> kpreid: Thanks.
11:51:50 <kpreid> AndreWe: if you want no breaks then mapM_ putStr
11:51:58 <kpreid> or putStr . concat
11:52:08 <zookoafk> kpreid: I'm embarassed for a Python enthusiast to be rude.  :-(
11:52:12 <Cale> putStr . unlines
11:52:13 <kpreid> Or for breaks another way: putStr . unlines
11:52:23 <zookoafk> I remember when Python community was notable for being much more polite and friendly than Perl community.
11:52:35 <zookoafk> I guess that's one of the advantages of avoiding success at all costs -- Python was small back then.
11:52:39 --- mode: ChanServ set +o glguy
11:52:47 --- kick: gnuth was kicked by glguy (glguy)
11:52:55 <kpreid> zookoafk: judging by the interaction on #lisp, I think he wasn't being malicious, just misguided
11:53:01 <ivan_salazar> lament: Kind of, our teacher is almost spoon-feeding them. I'm having a hard and very fun time, it's the first time I ever program in Haskell.
11:53:01 <kpreid> attempt to be entertaining
11:53:11 <zookoafk> Oh good.
11:53:12 <lament> ivan_salazar: ah
11:53:19 --- mode: ChanServ set -o glguy
11:53:22 <kpreid> zookoafk: but I'm inferring a lot from a couple lines, so.
11:53:43 <ivan_salazar> lament: I think I'm doing a good job XD or at least it has been very fun.
11:54:26 <ivan_salazar> lament: I'm having hard times with Monads, but it's been interesting.
11:55:07 <lament> ivan_salazar: cool :)
11:55:41 <Baughn> I wonder if it would make sense to have a #popularlanguage-secret channel you could only get into after demonstrating some ability, or at least politeness..
11:55:56 <ivan_salazar> lament: Thanks :)
11:56:12 <glguy> Baughn: a lot of channels (not necessarily language ones) have those
11:56:13 <cjb> I think measures like that tend to destroy community more than they help it.
11:56:46 <Baughn> So what's the alternative? Aggressive policing of the one channel to eliminate troublemakers?
11:57:50 <Adamant> set minimum standards for politeness and enforce them
11:57:57 <audreyt> deploying Robot9000 from #xkcd-signal?
11:58:00 <lament> it's good #haskell does not have such a channel. And even if it did, which it doesn't, nobody would go there anyway, but of course this channel does not exist. And never existed.
11:58:30 <Baughn> #haskell doesn't /need/ one
11:58:50 <lament> I would like to stress that fact. There is NO secret invite-only Haskell-related channel. None.
11:59:07 <Baughn> lament: And it isn't named #lambda-knights?
11:59:24 <lament> it's not named #lambda-knights or anything else, because it does not exist.
11:59:33 <Baughn> That's what I thought.
11:59:36 <Twey> Hahahaha
12:00:56 <Baughn> Twey: He spoke the truth, you know. There is no such channel.
12:01:24 <Twey> Aw dang.
12:01:34 <lament> nope, none at all.
12:01:47 <Twey> I was half-expecting half of #haskell to join and make it, like #gurgling.  :-)
12:01:53 <vincenz> It's' not lambda-knights
12:02:03 <glguy> is this the kind of stuff we are supposed to aggressively police and stamp out?
12:02:20 <Baughn> Only if it interferes with useful talk
12:02:32 <glguy> silence is golden ;)
12:02:41 <vincenz> and your tongue is like siver?
12:02:42 <vincenz> silver
12:02:56 <lament> and glguy's banhammer is solid iron
12:02:57 <glguy> you've pegged me
12:03:06 <Baughn> On that note.. anyone happen to know if there's a function-call graph of ghc (specifically, the rts/library) somewhere?
12:03:24 * glguy isn't trying to squelch the conversation :0D
12:06:38 <gnuvince> @hpaste
12:06:38 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:07:01 * vincenz quietly whispers that #lambda-knights is actually called #oasis, don't pass on this secret.
12:07:56 <gnuvince> hpaste is down for anyone else?
12:08:38 <Deewiant> all day
12:09:27 <gnuvince> k
12:09:43 <thunc> back
12:10:05 <mmorrow> whats happened to hpaste?
12:10:12 <gnuvince> Could anybody comment on this code to find the percentage of vowels and consonants in a file: http://pastebin.ca/980022
12:10:16 <gnuvince> Thank you
12:13:51 <mmorrow> hpaste.org (i mean)
12:15:25 <xerox> audreyt: that's actually a good idea :)
12:18:45 <vincenz> gnuvince: looks good?
12:19:06 <gnuvince> vincenz: yeah?
12:19:44 <Gwern-away> hm. when is GHC going to have shared libraries?
12:19:47 <Gwern-away> 6.10?
12:21:01 <vincenz> gnuvince: I think so
12:21:14 <gnuvince> vincenz: cool, thanks.
12:24:25 <Cale> gnuvince: One thing I can see that might be a problem for larger cases is that you compute the length of vowels and consonants twice.
12:24:43 <Gwern-away> hm. how big is a python interpreter?
12:25:10 <gnuvince> Cale: ah, yes.
12:25:21 <Baughn> Gwern-away: Download cpython, check? ;)
12:25:39 <vincenz> Gwern-away: about 10 centimeter cubed
12:25:50 <Gwern-away> vincenz: and by density?
12:25:55 <vincenz> 1 kilo
12:26:14 <Gwern-away> Baughn: too much trouble. runnig du on /usr/bin/python2.5 gives me the ridiculous figure of 8k
12:26:21 <Gwern-away> which obviously isn't right...
12:26:26 <vincenz> /usr/lib
12:26:44 <olsner> my python's 62MB
12:26:46 <vincenz> 27.5MB
12:26:49 <Baughn> Gwern-away: Script? Mine's 1.3M, but normally source would be more interesting
12:27:00 <Cale> gnuvince: Although this is a toy program obviously, I'd also encourage greater separation between what your program is doing and the IO in it.
12:27:31 <Gwern-away> hm, thanks
12:28:24 <thunc> front
12:28:45 <EvilTerran> ?hoogle genericLength
12:28:45 <lambdabot> Data.List.genericLength :: Num i => [b] -> i
12:28:54 <EvilTerran> gnuvince, that may be of use to you
12:29:41 <tromp> hmm, any use in having genericLength return a Float or Double?
12:29:42 <Baughn> @type (++)
12:29:42 <lambdabot> forall m. (Monoid m) => m -> m -> m
12:29:49 <Baughn> ..where is that ++ defined?
12:29:55 <gnuvince> EvilTerran: thanks
12:29:58 <Cale> Baughn: In lambdabot
12:30:10 <gnuvince> Cale: yeah, I thought of that as well.
12:30:15 <Cale> Baughn: I just defined it to be the same as mappend
12:30:16 <Baughn> Cale: Mine seems to be lacking it. Odd.
12:30:22 <gnuvince> I'll work on it and post another version soon.
12:30:26 <thunc> gnuvince: you'll have to loop over all the entries
12:30:32 <Cale> Baughn: this is fairly recent
12:30:33 <tromp> :t length
12:30:34 <lambdabot> forall a. [a] -> Int
12:30:51 <Baughn> Cale: I updated it yesterday. I'm getting "++: no such thing"
12:31:05 <Cale> hmm
12:31:14 <Cale> Baughn: Look in State/Pristine.hs
12:31:18 <tromp> is there any performance penalty for making the standard length return Integral a => a
12:31:49 <Baughn> Cale: Ah. It didn't complain about the lack.
12:31:57 <Cale> tromp: Not really, with the right compiler pragmas to specialise the Int case.
12:32:07 <Baughn> Cale: I'm maintaining my own State dir too, which sometimes gets ugly. Hm, did you ever see that runplugs patch I sent?
12:32:26 <Cale> Baughn: I'm not sure... sorry if I missed it.
12:32:33 <mmorrow> gnuvince: this is faster: http://pastebin.ca/980044
12:33:03 <Cale> mmorrow: heheh
12:33:06 <Baughn> Cale: My email has been on the fritz. I'll need to check it thoroughly now, though
12:33:20 <mmorrow> ;)
12:34:00 <Cale> I'm not sure much is gained from that approach relative to just not recomputing the lengths though.
12:34:53 <Cale> Tail recursion is evil :)
12:35:05 <Cale> (well, explicit tail recursion anyway :)
12:35:25 <mmorrow> evil as in genius?
12:35:32 <glen_quagmire> => in instance means "instance of"  while => in class means "extends", right?
12:35:56 <Baughn> glen_quagmire: No, they pretty much mean the same thing
12:36:42 <glen_quagmire> instance definitoin can have | also? as in functional dependencies?
12:36:55 <Cale> Evil as in usually an awkward premature optimisation :)
12:37:00 <Saizan> no, only class declarations
12:37:04 <mmorrow> heh
12:37:22 <Cale> (which often makes one miss the chance to find an efficient and abstract solution)
12:38:22 <mmorrow> true. but a whole second faster on /usr/share/dict/words :)
12:39:06 <mmorrow> so i guess it depends on the goal
12:39:24 <Baughn> @version
12:39:24 <lambdabot> lambdabot 4p603, GHC 6.8.2 (Linux i686 2.40GHz)
12:39:24 <lambdabot> darcs get http://code.haskell.org/lambdabot
12:39:29 <orzo> hey
12:39:36 <byorgey_> hi orzo
12:39:48 <orzo> are you familiar with Numerix?
12:39:51 <orzo> a multiprecision library
12:40:24 <orzo> it could be used instead of GMP
12:40:31 <orzo> it's license is more permisive
12:41:30 <Baughn> Cale: ..who wrote the Resource.hs thing?
12:41:46 <glen_quagmire> @where precedence
12:41:46 <lambdabot> I know nothing about precedence.
12:42:05 <glen_quagmire> which precedence should I use normally?  5?
12:42:23 <Cale> Baughn: uh, I forget exactly who it was. There was a problem with the posix library on the machine where lambdabot was running and some other 64 bit machines.
12:42:30 <Baughn> Cale: cgibbard. Aha..
12:42:38 <Cale> I checked it in :)
12:42:51 <Baughn> Cale: That is /interesting/, since the posix library works fine for me but this version just crashes. ^^;
12:43:43 <Baughn> strace output: setrlimit(RLIMIT_CPU, {rlim_cur=21474836485, rlim_max=0})= -1 EINVAL
12:44:23 <Baughn> (Or 0x500000005. Fun.)
12:45:27 <Cale> mmorrow: Using a strict pair and foldl' is just as fast.
12:45:40 <Baughn> Cale: It does seem to be trying to do the right thing, but I don't see why it's poking 5 into both the high and low quad
12:46:27 <mmorrow> Cale: yeah, i wanted to get rid of import Data.List though...
12:46:44 <Baughn> Cale: ..wait, is this a workaround for some 64-bit system using a 32-bit setrlimit?
12:46:51 <Cale> Baughn: It might be :)
12:47:23 <Baughn> Is hardcoding a bug into lambdabot really the best way to deal with a bug in libc? Two lefts making one right?
12:47:51 <Cale> Baughn: Well, I have no admin privileges on the machine where lambdabot is running.
12:48:26 <Baughn> Cale: You're the boss, but personally I wouldn't push such a local fix to the main repository
12:48:37 <Baughn> Oh well. I'll just work around it here.
12:48:41 <byorgey_> glen_quagmire: operators have precedence 9 by default.  check out http://www.haskell.org/onlinereport/decls.html#prelude-fixities to see what precedence other standard operators have.
12:48:42 <lambdabot> Title: The Haskell 98 Report: Declarations
12:49:03 <Cale> Baughn: You're right that I should probably remove it from the main repo.
12:49:05 <byorgey_> glen_quagmire: you should usually make new operators have the same precedence as whatever standard operators they are most "like"
12:49:28 <Cale> Baughn: Or at least comment it out. I've had at least one other person with the same problem who actually needed that fix.
12:50:13 <glen_quagmire> byorgey_, oh i see. thank you
12:50:17 <Cale> Baughn: Basically you can edit the setCPULimit (or whatever it was called) in Resource.hs to use the System.Posix.Resource library.
12:51:01 <byorgey_> glen_quagmire: if you click on that link you may have to scroll up a bit to find the actual table
12:51:24 <Baughn> Cale: I'm already working on that. I'll just do that for you and send you the patch, okay? ;)
12:51:30 <thunc> Baughn: The problem here is. squid doesn't answer the call at times. requests on port 80 time out at times
12:51:55 <awesame> I want to define my own instance of Show for a list of one of my types
12:51:59 <Baughn> thunc: ..what?
12:52:04 <thunc> Baughn: You could think this... But what about Imaginary? etc...
12:52:11 <thunc> Baughn: i asked my question first?
12:52:19 <awesame> but GHC complains because it already has an instance (Show a) => Show [a]
12:52:31 <awesame> how do I make it let me define my own special case?
12:52:39 <glen_quagmire> how come `elem` has different precedence from `seq` ? is it customizable?
12:52:40 <Baughn> thunc: You're making no sense. What question?
12:52:54 <thunc> Baughn: who is this
12:53:18 <Cale> awesame: Right. There actually happens to be a hack just for you in the Haskell 98 prelude. Simply define the showList function for the instance of Show on your type.
12:54:02 <Cale> (that's the mechanism by which strings are shown differently than lists of integers)
12:54:17 <Cale> :t showList
12:54:17 <lambdabot> forall a. (Show a) => [a] -> String -> String
12:54:21 <Peaker> Without String being newtype'd?
12:54:27 <Cale> Peaker: right.
12:54:27 <awesame> ah, I see
12:54:43 <Cale> awesame: It's like shows, if you know about that.
12:54:45 <Peaker> it is kind of a hack
12:54:46 <Deewiant> glen_quagmire: sure, "infixl 6 `elem`" or whatever
12:54:57 <Peaker> why isn't String newtype'd, btw?
12:54:58 <lament> > showList [1,2] "@"
12:55:05 <lambdabot>  "[1,2]@"
12:55:07 <Cale> Peaker: convenience.
12:55:20 <lament> > showList "dangle" "@"
12:55:21 <lambdabot>  "\"dangle\"@"
12:55:25 <Baughn> ..darcs doesn't have an ununpull command, does it?
12:56:51 <Cale> Peaker: small programs often want to do pattern matching against strings, which is a bit lighter if they're not newtyped.
12:57:34 <Cale> If you're going to have such an inefficient representation for strings, they might as well be convenient :)
12:57:57 <Peaker> Cale, heh, but maybe the right way is to make sure that newtype'ing doesn't cost convenience
12:58:10 <Cale> It does by necessity.
12:58:24 <Peaker> Cale, maybe a String newtype could somehow specify how to pattern-match (x:xs) without unpacking the newtype?
12:58:39 <Peaker> and how to build x:xs back, too
12:58:43 <Cale> Wouldn't that mess with type inference?
12:58:53 <Peaker> I don't know :)
12:58:53 <Cale> What's the type of (:) then?
12:59:06 <Peaker> Is there anything else about String's which would become less convenient as a newtype, except cons-pair-packing/unpacking?
12:59:24 <Cale> Well, the ability to apply all the list functions to them.
12:59:56 <Cale> So you'd end up applying things under the newtype constructor all the time.
12:59:58 <Peaker> hmm.. if list was a typeclass maybe? (evil) :)
13:00:50 <Peaker> if list was a type-class then all the list functions would work on strings because string would be an instance
13:00:51 <lament> just what we need! more typeclasses!
13:01:10 <Cale> Peaker: Just use Data.ByteString :)
13:01:50 <lament> isn't Data.Foldable sort of the "list typeclass"
13:01:57 <Cale> lament: yeah
13:02:00 <Peaker> Cale, now that I think of it, though, I think many Haskell libraries are hard-coded for lists, rather than using arbitrary sequence data structures.. not sure if that's a bad thing, but in Python its great to only depend on __iter__/__getitem__
13:02:02 <Cale> Sort of :)
13:02:19 <lament> Peaker: I agree that this is ugly.
13:02:28 <Cale> Peaker: the basic assumption is that lists represent iteration, and you can always convert things to lists.
13:02:50 <Cale> A way of iterating over something is a function which transforms it into a list.
13:03:08 <Cale> (ideally, lazily)
13:03:12 <Peaker> Cale, well, I guess a lazy list is not that bad.. other languages that force you to list'ify have awful consequences for that
13:03:31 <lament> Peaker: Python does pretty much the same thing (iterators=lists)
13:03:41 <Cale> Right, we don't have to pay for that :)
13:03:42 <lament> but the issue with type classes is still ugly.
13:03:47 <Cale> Lists can just be our loops.
13:03:53 <Peaker> lament, yeah, I guess you can draw a parallel between list and iter..
13:04:02 <Peaker> so a String newtype could "convert" itself to a List when required?
13:04:12 <Baughn> @src IO fmap
13:04:12 <lambdabot> fmap f x = x >>= (return . f)
13:04:24 <Peaker> I dislike "convenience" as a reason to destroy elegance :)
13:04:26 <Cale> Sure, that's what the newtype unwrapper would likely do :)
13:04:38 <Cale> It's not that inelegant.
13:04:54 <Cale> If the Prelude was rewritten today, we might have used an overlapping instance.
13:04:57 <Peaker> Cale, I think having a showList as an ad-hoc solution to the Show [Char] problem is very inelegant
13:04:59 <lament> What's stopping Haskell from defining a type class for every type, by the way?
13:05:11 <Peaker> Cale, oh, those exist? How are they prioritized?
13:05:38 <Cale> Peaker: more specific wins, iirc.
13:05:48 <Cale> Peaker: if there's a tie, you get an error.
13:05:52 <Peaker> Cale, ah, cool
13:06:23 <Cale> lament: What methods would it define?
13:06:57 <lament> Cale: all those which use that type anywhere in the signature get magically rewritten to use the class.
13:07:11 <lament> so all functions become instance methods of something or other
13:07:27 <lament> i don't see problems with this...
13:07:27 <Cale> lament: uh... I mean what are the methods of the new typeclass?
13:07:30 <Peaker> lament, might as well unify types and type-classes as done in other languages?
13:07:41 <Cale> I don't understand.
13:08:06 <lament> Cale: any function that uses the type is actually the method of the type class.
13:08:47 <Peaker> if it pattern-matches on the type, then it is a required method. If it only calls other methods, it is a default implementation?
13:09:47 <Cale> lament: That doesn't make sense.
13:09:58 <lament> Cale: why not?
13:10:02 <Baughn> > [1..3] ++ [last [1..]] -- How come this doesn't run in constant space?
13:10:03 <Cale> lament: Typeclasses have a finite number of methods.
13:10:07 <lambdabot> Terminated
13:10:27 <Peaker> > last [1..]
13:10:31 <lambdabot>  Terminated
13:10:38 <Peaker> Baughn, does that run in constant space?
13:10:52 <lament> Cale: do they have to?
13:11:05 <Peaker> lament, if they don't, then you cannot instantiate them meaningfully..
13:11:08 <EvilTerran> lament, yes, as you need to give a definition for each one in the instance decleration
13:11:22 <Cale> lament: Well, if you want to even write an instance, then yes.
13:11:26 <Baughn> Peaker: No.
13:11:31 <Baughn> Peaker: WHich is insane.
13:11:35 <Peaker> Baughn, weird
13:11:37 <Cale> lament: Unless all instances will somehow be incomplete?
13:11:39 <Peaker> @src last
13:11:39 <lambdabot> last [x]    = x
13:11:39 <lambdabot> last (_:xs) = last xs
13:11:39 <lambdabot> last []     = undefined
13:11:58 <Baughn> I assume something is holding on to the head inside runplugs somewhere
13:12:26 <Peaker> Cale, lament : If only functions that pattern match against the data constructor are methods, then you have a finite set
13:12:52 <Peaker> (maybe)
13:13:24 <lament> yeah... that sounds about right
13:13:29 <Cale> Baughn: I think something is getting lifted to a CAF which shouldn't be.
13:13:39 <Cale> Baughn: That's certainly a GHC bug.
13:13:42 <Baughn> Same thing happens in ghci
13:14:04 <lament> i guess what i'm describing is simply newtype
13:14:55 <Baughn> Cale: I've already got two ghc bugs on my hands, and I wouldn't know where to start with this one
13:14:58 <Cale> Peaker: Uh, no you don't.
13:15:01 <monochrom> "newbie needs help on newtype. will work for code."
13:15:31 <Peaker> I love emacs macros.  I just "wrote" a program to reorganize a directory structure by recording a macro in dired.  I want example-based programming to go general-purpose already...
13:15:56 <Baughn> Peaker: It's nice in some cases, but you have to admit that it's awfully fragile
13:16:09 <Baughn> Peaker: (Also, MS Office supports the same thing. I'd say it's already mainstream.)
13:16:18 <lament> nice but fragile... the opposite of Haskell
13:16:41 <Baughn> Quick'n'dirty, for programs that will only be run once
13:16:42 <monochrom> Evolution is example-based.
13:17:00 <vincenz> monochrom: you want t owrite a program in 100 Million years?
13:17:03 <Peaker> Baughn, Macros need powerful operations to be powerful, and they need sane specificity to be useful.. Excel macros, for example, record with the cell ID's *in* the macro, making them useless
13:17:17 <monochrom> Not me.  Those who want example-based programming.
13:17:31 <monochrom> I'm sure I said I believe in Intelligent Design instead.
13:17:57 <vincenz> Peaker: I'm sorry, but examlpe-based programming sound really terrible
13:18:07 <Peaker> Baughn, Usually you record a macro and THEN iterate it.  if you could specify the iteration first, and then record, you could see it working on everything and "fix"/undo as you see mistakes in some of the cases.. making it easier to hit the correct specificity.  Add an online viewer of the "program" being built and the ability to later edit it properly (on an example) and you have a very powerful programming environment
13:18:28 <vincenz> that's not programming, taht's editing
13:18:28 <Peaker> vincenz, At least for some tasks its already proven itself by far the most productive method
13:18:32 <lament> 1 is prime, 3 is prime, 5 is prime, 7 is prime, 9 is prime, 11 is prime...
13:18:32 <vincenz> welcome to VIM
13:18:48 <vincenz> Peaker: Such as?
13:18:55 <Peaker> vincenz, It is writing something that takes an input, processes it, and generates an output.. why is it not programming?
13:19:01 <vincenz> Peaker: Only for very concrete and minor things
13:19:09 <Peaker> vincenz, Such as restructuring a directory as I just have
13:19:15 <vincenz> Example-based programming is incrediby fragile
13:19:35 <Peaker> vincenz, Writing that as a program would take me minutes, with a macro it took seconds
13:19:57 <Peaker> vincenz, why is it fragile?
13:19:58 <vincenz> Peaker: yes, and next time your directory structure is slightly iferent
13:20:02 <vincenz> or you have an extra space somewhere
13:20:03 <vincenz> boom
13:20:04 <vincenz> it goes wrong
13:20:17 <Cale> Baughn: It looks like somehow [1..] is getting turned into a CAF. I'm not sure that's the case, but it appears so.
13:20:20 <Baughn> That's probably why emacs doesn't let you /save/ keyboard macros
13:20:35 <Peaker> vincenz, that is true of a program too, if you specify the wrong level of specifity.  A macro may make that a little more likely, shifting the kinds of skills you require
13:20:37 <monochrom> "example-based" is just a new name. all programming is example-based since the dawn of programming as a craft.
13:20:43 <Peaker> Baughn, it does :)
13:20:50 <Baughn> Peaker: Hush
13:21:07 <Peaker> Baughn, And I used to save some, but its not recording a program, but a set of key presses, which sucks :P
13:21:32 <Baughn> Peaker: Luckily, it would be simple to turn the keypresses into a program if you want that. ^_^
13:21:38 <Peaker> monochrom, Yeah, but "example based" just means you see the program executing on an example as you create it
13:21:49 <Peaker> Baughn, it uses the current key bindings
13:21:55 <Peaker> Baughn, I don't want that indirection its silly
13:22:18 <Baughn> Peaker: So write a save-as-function-calls function that indirects /before/ saving
13:22:35 <Peaker> Baughn, that would be useful. but it would require using a lot of elisp :)
13:23:11 <Baughn> Peaker: Actually, I expect it would be a relatively minuscule amount of elisp
13:23:12 <lament> > concatMap ((++" is prime, ").show) [1,3..]
13:23:13 <lambdabot>  "1 is prime, 3 is prime, 5 is prime, 7 is prime, 9 is prime, 11 is prime, 13...
13:23:14 <monochrom> Then that is an ill-chosen name. It is not based on examples. It is based on making coding and execution concurrent.
13:23:21 <Peaker> vincenz, now I want to download a bunch of links into a bunch of directories, and I cannot automate that reasonably.  With an emacs macro, I could easily :(
13:23:23 <Cale> Baughn: oh, right, it was this bug: http://hackage.haskell.org/trac/ghc/ticket/2038
13:23:29 <lambdabot> Title: #2038 (System.Posix.Resource.setResourceLimit gives &#34;setResourceLimit: inval ...
13:23:32 <Cale> (the setCPULimit thing)
13:23:42 <Peaker> monochrom, unifying edit-time and run-time is another name, yes
13:24:01 <lament> that's Smalltalk
13:24:02 <monochrom> You could as well call it "test-based" because "you see the program executing on a test case as you create it".
13:24:05 <lament> smalltalk <3
13:24:33 <monochrom> Snake-oil people really choose very poor names.
13:24:48 <Baughn> Cale: Cute. Should be fixed for 6.8.3 then, probably
13:24:57 <Peaker> monochrom, snake oil? I just mentioned at least 2 examples where I benefit/would benefit from this
13:25:14 <monochrom> First they summarize their stuff in a sentence. So far so good.  Then they choose the least important noun in that sentence as the name!
13:25:28 <lament> at least it's a noun!
13:25:33 <monochrom> All snake oils work excellent on five examples.
13:25:36 <lament> "The-based programming"
13:25:55 <Baughn> " -based programming"
13:26:01 <Peaker> monochrom, I find the most important aspect in this case to be the fact I operate on an example, rather than write a program in the abstract
13:26:08 <Baughn> Whitespace, that is
13:26:10 <monochrom> don't forget "-oriented".
13:26:14 <Peaker> monochrom, if they work great on five things, then they are useful, and not snake oil
13:26:21 <Peaker> monochrom, snake oil is useless by definition
13:26:22 <mrd> snake oil oriented programming, SOOP.  yum.
13:26:35 <Baughn> Peaker: Sometimes you have a need for snake oil
13:26:51 <mrd> for example, when cooking Beef fried in Snake oil
13:26:58 <monochrom> You operated on a test case.
13:26:59 <Vq^> mrd: isn't that mostly shortened to OOP?
13:27:04 <Peaker> well, I often wish I could automate stuff, especially in the web.. and by far the easiest way to automate would be powerful "macro recorders"
13:27:12 <mrd> Vq^: these days
13:27:22 <monochrom> This is just test-driven programming rehashed.
13:27:35 <Peaker> monochrom, Why is the distinction between an example and a test case is important here?  In fact I operated on the first item of a list of items I needed done
13:27:53 <vincenz> Peaker: That's not programming, that's scripting
13:27:55 <monochrom> The point is there is no distinction, so why invent a new name?
13:27:57 <Peaker> monochrom, not quite - test-driven just means you first write the tests, and make them pass.  "Recording a macro" is quite a different thing
13:28:03 <Peaker> vincenz, I don't believe in such a distinction
13:28:29 <Peaker> monochrom, who says a "test case" is the first name, and "example" is the latter name? :)
13:28:37 <lament> That's not OOOOHprogramming, it's EWWWWscripting!
13:28:46 <Cale> Baughn: ah, and that last [1..] thing, I think is maybe a bug in the instance of Enum for Integer
13:28:53 <monochrom> Not by me. By the whole programming community.
13:28:55 <Peaker> vincenz, scripting and programming are the same thing
13:29:19 <Peaker> monochrom, well, I didn't know "test case" was the official name.  s/example/test case/  if you prefer :)
13:29:32 <lament> monochrom: "test case" is something you test your code on, no?
13:29:38 <Cale> Baughn: note that at the Int type, it doesn't have any difficulty running in constant space.
13:29:43 <lament> not something you define your code with
13:29:46 <monochrom> Just ask the "extreme programming" people.  They have been there for a decade.
13:29:48 <Baughn> Cale: Heh. You know, I already ordered more memory because, bizarrely, the server started lagging whenever I tested simple bottoms like [1..].
13:29:57 <lament> extreme programming people don't generate code from their test cases
13:29:58 <Peaker> monochrom, are you saying that TDD and macro recording are the same thing?
13:30:35 <vincenz> Peaker: No they're not
13:30:40 <monochrom> The "macro recording" part simply means you use a different IDE or a different programming language.
13:30:42 <Cale> enumDeltaInteger :: Integer -> Integer -> [Integer]
13:30:42 <Cale> enumDeltaInteger x d = x : enumDeltaInteger (x+d) d
13:30:54 <Cale> It's possibly that x+d which is building up all the memory usage.
13:31:13 <Cale> last doesn't force the elements of the list.
13:31:21 <Peaker> monochrom, it means you don't have to visualize in your mind the execution of the program, because its being visualized on a test case as you create it. Its an important feature, a defining one
13:31:32 <Cale> So the "current number" is held as an expression which forever grows in size.
13:31:45 <monochrom> It just means you have a better debugger.
13:32:02 <thunc> front
13:32:18 <Cale> let last' [x] = [x]; last' (x:xs) = x `seq` last' xs
13:32:26 <Peaker> monochrom, no, it means my program editing environment can do things that abstract code editing cannot do - like offer different key bindings based on what the test case is looking like
13:32:39 <Cale> Try that version of last, and you'll see that the space remains constant.
13:32:43 <Baughn> Peaker: However, one of the major twists of learning haskell is that you're supposed to stop thinking about transformations of data and start thinking about transformations of algorithms
13:32:58 <Baughn> Peaker: In which case the examples become halfway useless
13:33:10 <lament> but he's not talking about haskell!
13:33:32 <Baughn> True, but I like to think Haskell can be applied to anything
13:33:49 <Peaker> Baughn, Well, maybe it is less useful for Haskell (I hope even higher-order programming can be visualized meaningfully), but there are many cases where data transformations are useful to write
13:34:28 <Peaker> Baughn, note that conal's Eros has a couple of examples of visualizations of higher-order functions, and they do seem to be somewhat helpful, IMO
13:34:29 <monochrom> One can make an IDE for Haskell in which you write code by macro recording.
13:34:30 <lament> adjusting your directory structure with haskell instead of using a macro in emacs is just nuts
13:34:35 <monochrom> > [1,2,3]
13:34:35 <Cale> Hmm, where's the instance of Enum for Int in GHC?
13:34:35 <lambdabot>  [1,2,3]
13:34:42 <monochrom> > map (+ 2) [1,2,3]
13:34:43 <lambdabot>  [3,4,5]
13:34:49 <monochrom> > length $ map (+ 2) [1,2,3]
13:34:50 <lambdabot>  3
13:34:56 <monochrom> > sum $ map (+ 2) [1,2,3]
13:34:57 <lambdabot>  12
13:35:03 <Cale> n/m, found it
13:35:05 <monochrom> There, I just did it with lambdabot.
13:35:06 <Deewiant> Cale: GHC.Base I think
13:35:06 <Peaker> monochrom, that would be great
13:35:13 <Cale> GHC.Enum
13:35:26 <Peaker> monochrom, heh, you did something alright :)
13:36:03 <monochrom> I have been doing that with calculators and REPLs since infancy.  There is no need to name it, except "common sense".
13:36:30 <Peaker> monochrom, ideally if you have a list of ints, you'd get list-of-ints-specific key bindings available to apply to it (as long with an accessible Hoogle of [Int] ->  or (x a) => a->  (for all applicable x's)
13:36:55 <Peaker> s/as long with/as well as/
13:37:46 <Peaker> hey, in such an environment, functions could have keybindings rather than just names..
13:38:16 <lament> yeah, who needs map when you have Ctrl-Meta-M?
13:38:25 <Peaker> ;)
13:38:30 <Cale> Peaker: and the names of the functions can be written on the keycaps!
13:38:36 <Peaker> Note I said "just names" and not "names" :)
13:38:45 <lament> Cale: YES!
13:39:02 <lament> who needs Ctrl-Meta-M when you can have Ctrl-Meta-Map?
13:39:05 * Baughn has finally breached the Emacs Event Horizon
13:39:10 <Baughn> My .emacs file has gone sentient.
13:39:31 <mrd> Baughn: M-x large-stick
13:39:37 <monochrom> can it solve the halting problem now?
13:39:43 <Baughn> Yes, in some limited cases
13:40:29 <Cale> http://en.wikipedia.org/wiki/Image:Zx81-timex.jpg
13:40:30 <lambdabot> Title: Image:Zx81-timex.jpg - Wikipedia, the free encyclopedia
13:40:37 <lament> "- Hi, which key do I press to write a parser? -Try [Parsec]. -Thanks!"
13:41:12 <Baughn> Cale: Oh, that brings back memories..
13:41:15 <lament> Cale: interesting how much expressivity you would have in haskell with a total vocabulary of 26 functions
13:41:30 <lament> (and how should you choose 26 functions for maximum expressivity)
13:41:48 <mrd> SK
13:41:52 <Peaker> lament, you only have 26 key bindings? :)
13:42:32 <Peaker> lament, I have 4 modifiers and about 80 keys they can be combined with for just 1-long key bindings :)
13:42:53 <Baughn> Peaker: It's not one-key if you use modifiers. -_-
13:43:08 <lament> Peaker: i have a very small brain that can't handle that much information at once
13:43:11 <mrd> Baughn: is S one key or two
13:43:17 <Peaker> 1-long, no prefixes :)
13:43:21 <Baughn> mrd: 2
13:43:25 <mrd> oklofok:)
13:43:35 <mrd> whups completion
13:44:00 <Vulpyne> Not if caps lock was on!
13:44:08 <Peaker> vincenz, I'm sorry, I missed your reply. Why are they not the same?
13:44:12 <Cale> Heh, if I was to design a pocket calculator, there would be no multiplication key. We already want exp, log, and addition, so there's no need for that.
13:44:34 <Peaker> Cale, hurray for floats :)
13:44:52 <lament> Cale: there would be no addition, only subtraction
13:44:55 <Peaker> Cale, I'd like to see how close your exp of sum of logs would be to the result :)
13:45:12 <Cale> Peaker: That's how they used to compute products.
13:45:28 <Cale> Peaker: log and antilog tables :)
13:45:32 <Peaker> Cale, yeah I know :)
13:45:35 <lament> Cale: or rulers many meters long
13:45:44 <Peaker> Cale, but that's because they didn't have bits :)
13:45:45 <dolio> His calculator could run on a perspex machine, and do exact real arithmetic.
13:45:58 <Peaker> Cale, well, half-adders on them and all that
13:46:30 <Cale> > exp (log 3 + log 4)
13:46:31 <lambdabot>  12.0
13:46:44 <Cale> > exp (log 300 + log 400)
13:46:45 <lambdabot>  119999.99999999984
13:46:51 <Peaker> ;)
13:47:02 <lament> http://www.sliderulemuseum.com/SR_Images/KE_1933_EnglewoodHS_class.jpg
13:47:04 <lambdabot> http://tinyurl.com/6memr5
13:47:07 <Peaker> that won't sink your ship, but it will get you a tax audit :)
13:47:16 <Peaker> (maybe)
13:47:21 <lament> i dunno how much precision that slide rule has, but it's evidently not enough since longer ones existed too
13:48:35 <Cale> On a more serious note, I don't see the point in including special log base 10 buttons.
13:48:49 <lament> supposedly somebody uses them for something
13:48:55 <Cale> There should be one button labelled 'log' and when you press it, you get the natural log.
13:49:00 <EvilTerran> all you need is ln. log_n as well if you're feeling generous
13:49:09 <lament> Cale: people use all sorts of weird stuff though
13:49:17 <roconnor> Cale: maybe someone want's to calculate decibals
13:49:19 <Cale> None of this ln frenchness either :)
13:49:25 <roconnor> decibells
13:49:31 <lament> my calculator had a "grad" mode where a 90-degree angle corresponds to a 100-grad angle
13:49:32 <roconnor> deciBells?
13:49:32 <EvilTerran> decibels?
13:49:34 <Peaker> yeah, deciballs  are something else
13:49:44 <lament> which seems really retarded, but evidently somebody needs those for something
13:49:53 <EvilTerran> lament, engineers, i believe
13:49:55 <Cale> lament: yeah, some engineers use grads
13:50:08 <lament> probably they're also the ones using base 10 logs
13:50:19 <Peaker> wait.. I just realized.. you guys have _calculators_?  As in real physical ones?
13:50:23 <lament> if you actually use some operation often, you do want an easy way to get to it (ideally, a button)
13:50:40 <Cale> The one true measure of angles is radians of course.
13:50:42 * EvilTerran has seen a graphics lib that had a full circle of 256, and used 16.16 fixed-point to represent angles
13:50:46 * Peaker just uses a Python prompt as a calculator
13:50:49 <Deewiant> but pi is defined wrong
13:50:50 <vixey> greetings
13:50:52 <Deewiant> it should be 2*pi
13:50:54 <lament> Cale: yes, and the one true system of coordinates is cartesian.
13:51:09 <vixey> @seen gwern
13:51:09 <lambdabot> I saw gwern leaving #darcs, #xmonad and #haskell 13h 26m 23s ago, and .
13:51:13 <Deewiant> (http://www.math.utah.edu/~palais/pi.pdf for any who are interested)
13:51:37 <lament> a math paper coming from Utah that wants to redefine Pi? HMMMM
13:51:40 <Cale> Deewiant: yeah -- but I don't think it's worth changing.
13:51:54 <Deewiant> well of course it's not worth changing
13:51:57 <lament> Peaker: i have a slide rule, too :)
13:52:00 <Deewiant> just like it's not worth changing the QWERTY keyboard layout
13:52:08 <roconnor> Deewiant: I thought that before, but I'm told that pi is in fact correct
13:52:14 <Cale> There are enough formulas where pi occurs on its own that you'd have to write pi/2
13:52:21 <Deewiant> roconnor: how's that
13:52:24 <vixey> what's pi ln(-1) or something?
13:52:31 <lament> current pi is better because 2pi is easier to write than pi/2
13:52:41 <Peaker> lament, I was just about to write that
13:52:48 <Deewiant> I like his point about the 1/2 x y^2 relations though
13:52:52 <lament> but i'm faster at typing, because i use dvorak :)
13:53:00 <Peaker> lament, heh :)
13:53:03 <Deewiant> there are a lot of those, and most cases where you'd get pi/2 you'd get something like that
13:53:10 <Deewiant> which is pretty in some sense
13:53:11 <roconnor> Deewiant: I'm not sure.  I think maybe the idea was to look at volumes of high dimentional sphere, and you see that pi is better than 2*pi
13:53:15 * EvilTerran recalls doing lots of working involving n/pi, and took to writing a pi turned upside-down instead of 1/po
13:53:18 <EvilTerran> *pi
13:53:30 <lament> EvilTerran: :D
13:53:32 <Cale> vixey: log(-1) is (at least in one branch of the logarithm)  i pi
13:53:35 <EvilTerran> :D
13:53:38 <roconnor> co-pi
13:53:40 <lament> copi
13:53:49 <Cale> So pi = -i log(-1)
13:54:03 <monochrom> If Cale was to design a calculator, I would add a macro to it for multiplication.  <duck>
13:54:35 <Cale> It would be fun to design a calculator which was actually useful to mathematics students.
13:54:46 <EvilTerran> he would probably devise something so that "adding a macro" would be an arduous, multi-step process
13:54:48 <roconnor> a*b := exp (ln a + ln b)
13:54:53 <lament> Cale: Haskell? :D
13:54:56 <EvilTerran> but each step could also be used in loads of other cool stuff
13:55:03 <sieni> Cale: like an assistant professor?
13:55:05 <lament> Cale: i mean... Coq?
13:55:07 <paczesiowa> basic operators like +,-,=,proof
13:55:17 <Cale> Haskell is pretty useful. GAP is more useful.
13:55:24 <monochrom> Someone would brag about "example based programming" since macro recording would be arduous and non-trivial. :)
13:55:37 <vixey> @where GAP
13:55:37 <lambdabot> I know nothing about gap.
13:55:48 <vixey> what's GAP?
13:55:49 <Cale> @google GAP programming
13:55:49 <EvilTerran> ?where+ GAP http://www.gap-system.org/
13:55:50 <lambdabot> No Result Found.
13:55:50 <lambdabot> It is stored.
13:55:52 <lament> it would be cool to have for all, there exists and stuff as buttons
13:56:03 <Cale> Yeah, there you go.
13:56:03 <dejones> any support for Design by Contact, such as pre-conditions, invariants, post-conditions of functions, in Haskell?
13:56:08 * EvilTerran wants a "QED" button
13:56:10 <monochrom> It's damn hard to calculate forall's and exist's.
13:56:14 <Cale> I would love to see GAP reimplemented on top of Haskell.
13:56:16 <EvilTerran> dejones, yeah, types ;)
13:56:24 <dejones> EvilTerran: lol, they do help!
13:56:31 <EvilTerran> parameter type = precondition, return type = postcondition
13:56:41 <Cale> GAP the programming language is not so great, but GAP the library is incredibly awesome.
13:56:53 <EvilTerran> nothing else matters, 'cos of enforced purity :P
13:57:07 <monochrom> fix f where f :: X -> X  -- X is an invariant.
13:57:18 <EvilTerran> (ah, if only the type system were more expressive...)
13:57:24 <EvilTerran> oleg++
13:57:26 <dejones> EvilTerran: They do help, but they are not as powerful as explicit as pre-conditions.
13:57:48 <EvilTerran> unfortunately, i think that's all we've got. as pure haskell, anyway.
13:57:52 <EvilTerran> ?hoogle assert
13:57:53 <lambdabot> Control.Exception.assert :: Bool -> a -> a
13:57:53 <lambdabot> Control.Exception.assertions :: Exception -> Maybe String
13:57:53 <lambdabot> Control.Exception.AssertionFailed :: String -> Exception
13:58:04 <dejones> EvilTerran: Yeah..  hmm
13:58:06 <Deewiant> @karma oleg
13:58:06 <lambdabot> oleg has a karma of 1
13:58:08 <EvilTerran> assert would help with sanity checking, but not automated testing
13:58:19 <EvilTerran> dejones, there's also ndm's Catch
13:58:24 <EvilTerran> ?where catch
13:58:24 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
13:59:00 <lament> "oleg has a karma of Succ Zero"
13:59:01 <dejones> EvilTerran: maybe QuickCheck can enforce pre/post conditions..?  Probably not invariants though.
13:59:05 <EvilTerran> which does a certain amount of automated testing for potential calls to error. no false negatives, but comes up with the odd false positive
13:59:22 <dejones> heh
13:59:27 <EvilTerran> Catch also doesn't do potential non-termination, either
13:59:56 <EvilTerran> (false positives - for example, if a parameter list has to be at least two (or more) elements long, it'll think it has to be infinite)
14:00:18 <EvilTerran> it uses gross simplifications of types to keep the analysis tractable
14:00:45 <EvilTerran> IIRC, it simplifies Integer to "less than zero/zero/one/more than one"
14:00:56 <monochrom> Recall that invariant = the same pre and post conditions for the body of a loop. If you have no loop, invariants disappear as an isolate notion.
14:01:27 <lament> GAP does seem interesting
14:01:32 <Peaker> EvilTerran, I think maybe asserts can be used instead of "dependent types" for proofs.. have them be "red" when they are unproven (converted to runtime tests) or "green" if they are proven.  To "prove" them add more intermediate assertions
14:01:32 <monochrom> There is no loop in functional programming. Only explicit recursion of explicit functions.  You just need pre and post for your inner functions.
14:02:06 <dejones> EvilTerran: Thanks for the pointer to Catch.  Looks interesting.  :)
14:03:09 <EvilTerran> Peaker, that's a possible application, but i don't think anything does that for haskell
14:03:58 <EvilTerran> i was thinking at one point of some kind of assertion you could put inside comments, say, which a static analyser could try to prove, and turn into quickcheck properties if it couldn't
14:05:45 <Peaker> I dislike storing program metadata inside comments.. I believe program encodings should be extensible to support such extra information
14:06:28 <vixey> they're only comments from the point of view of a haskell compiler
14:06:39 <EvilTerran> {-# ASSERT forall f g. fmap f . fmap g = fmap (f . g) #-}, say - which'd then be proven or have quickcheck properties generated for each instance of Functor
14:07:31 <Peaker> I find it clumsy.. but the solution is a bit radical :-)
14:08:12 <EvilTerran> {-# ... #-} is defined in the report for annotations, iirc
14:09:48 <dejones> EvilTerran, Peaker: It's useful to have the assertions or pre/post conditions inside comments because then it allows the Haskell code to be ran by a compiler that doesn't support those features.
14:10:17 <EvilTerran> indeed
14:10:25 <dejones> The placing assertions / pre or post-conditions in comments is what the Spark language does, so that it is still Ada code.
14:12:59 <EvilTerran> ehird, ?!
14:13:12 <ehird> EvilTerran: ignore me
14:13:16 <EvilTerran> k
14:14:36 <vixey> http://rosettacode.org/wiki/Talk:Pattern_Matching
14:14:37 <lambdabot> Title: Talk:Pattern Matching - Rosetta Code
14:14:42 <vixey> grr
14:14:47 <vixey> wrong channel. sorry
14:27:21 <__pao__> hi all :-)
14:27:35 <EvilTerran> allo allo
14:28:04 <__pao__> eta reduction has a use or is as useless exercise?
14:30:10 <monochrom> What is eta reduction again?  From (\x -> f x) to f ?
14:30:22 <__pao__> yep
14:30:32 <__pao__> I wasn't really clear
14:30:47 <monochrom> Don't worry, I just forgot.
14:30:55 <monochrom> I think it's useful.
14:31:08 <dolio> People generally prefer their haskell eta reduced.
14:31:15 <dejones> anyone know if Neil Mitchel comes here on IRC?  He's the developer of Tag Soup library.
14:31:24 <dolio> Yeah, he's ndm.
14:31:26 <__pao__> I just discovered how to got from the recursive definition of (++) to foldr ((.) . (:)) id
14:31:42 <dejones> dolio: thanks
14:31:55 <__pao__> I was wondering what the use for that other than obfuscation :-)
14:31:58 <vixey> > let (++) = foldr ((.) . (:)) id in "foo" ++ "bar>
14:31:58 <lambdabot>  Improperly terminated string at ""bar>" (column 45)
14:32:17 <vixey> > let (++) = foldr ((.) . (:)) id in "foo" ++ "bar"
14:32:27 <monochrom> Haha. Obfuscation is subjective.
14:32:31 <lambdabot>  "foobar"
14:32:49 <monochrom> Some people here swear that all C code ever written is obfuscated.
14:33:23 <__pao__> pls, don't tell me that foldr ((.) . (:)) is clearer to you... my ego would suffer ;-)
14:33:34 <monochrom> It is not clear to me.
14:33:48 <__pao__> monochrom: thanks I feel better :-)
14:33:58 <roconnor> > let (++) = foldr (:) in "foo" ++ "bar
14:33:58 <lambdabot>  Improperly terminated string at ""bar" (column 34)
14:34:00 <monochrom> But why? Because I wasn't trained to read it.
14:34:03 <roconnor> > let (++) = foldr (:) in "foo" ++ "bar"
14:34:04 <lambdabot>  "barfoo"
14:34:05 * EvilTerran prefers flip (foldr (:))
14:34:14 <roconnor> > let (++) = flip $ foldr (:) in "foo" ++ "bar"
14:34:15 <lambdabot>  "foobar"
14:34:25 <vixey> @src (++)
14:34:25 <lambdabot> (++) []     ys = ys
14:34:25 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
14:34:33 <dolio> That's probably what I'd go with, too.
14:34:39 <vixey> __pao__: You should read Algebra of programming
14:34:55 <monochrom> I can start writing some Chinese sentences here. 99% of you will find it obfuscated. 0.5% of you will invoke the Chinese Room argument.
14:34:59 <vixey> It will help you to see why pointfree definitions are usefel
14:35:11 <__pao__> vixey: thanks ... that's exactly the useful advice I like to read on #haskell
14:35:22 <dolio> dejones: If you want to talk to him, he's usually around in the morning (Eastern US time) in my experience.
14:35:33 <lament> chinese is not obfuscated, it's just chinese
14:35:44 <monochrom> The remaining 0.5% of you, including me, will swear that Chinese is less obfuscated than English or Haskell.
14:35:45 <lament> Lojban is obfuscated
14:36:06 <dejones> dolio: thanks.  I was mostly just curious why the Tag Soup library is "for situations where the author of the HTML is not cooperating with the person trying to extract the information, but is also not trying to hide the information."
14:36:13 <dejones> quoted from the Tag Soup web page
14:36:14 <__pao__> @src flip
14:36:14 <lambdabot> flip f x y = f y x
14:36:34 <EvilTerran> dejones, because that's how most html comes
14:36:35 <YourA1gebra> afternoon
14:36:39 <vixey> flip f = \y x -> f x y
14:36:49 <lament> monochrom: "incomprehensible" and "obfuscated" mean different things. Incomprehensibility may, or may not, be caused by obfuscation. Obfuscation is intentional.
14:37:04 <lament> Chinese is incomprehensible to those who do not speak it.
14:37:14 <EvilTerran> it's not perfectly-valid beautifully-id'd and class'd XHTML, it's full of quirks through incompetence or compatibility hacking
14:37:18 <dejones> EvilTerran: well, I was curious if building a web framework where you would want to be able to get html tags and insert data, would TagSoup be the wrong library to use?
14:37:27 <thunc> front
14:37:42 <monochrom> I can't say (.) . (:) is intentionally obfuscated.  The author may very well see it clear as blue sky.
14:37:49 <EvilTerran> dejones, if you're writing the html yourself, there are better libraries to use, yeah
14:38:02 <dejones> EvilTerran: Ok, what library would you recommend?
14:38:12 <dejones> EvilTerran: Haxml?
14:38:13 <tromp> :t (.) . (:)
14:38:14 <lambdabot> forall (f :: * -> *) a. (Functor f) => a -> f [a] -> f [a]
14:38:22 <EvilTerran> tagsoup gives you pretty low-level information, i believe. libraries that assume your html is well structured can give you more expressivity
14:38:37 <EvilTerran> i don't really know, beyond that
14:38:39 <__pao__> monochrom: infact my question wasn't rethorical
14:38:50 <dejones> EvilTerran: I see.  Thanks for the info.  :)
14:38:58 <laura85> g night everybody
14:39:00 <laura85> wish me luck (midterm tomorrow) ^^
14:39:13 <EvilTerran> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:XML <- something in here, anyway
14:39:14 <dejones> laura85: gl, hf.  :)
14:39:26 <EvilTerran> i believe haxml and hxt are the popular ones
14:39:26 <vincenz> laura85: break a leg
14:39:31 <monochrom> laura85: I wish you logic and calculated reasoning.
14:39:50 <laura85> thanks ^_^
14:40:04 <vixey> good luck laura85!
14:40:09 <dejones> laura85: what course?
14:40:19 <laura85> functional programming (Haskell stuff)
14:40:25 <vincenz> ooh
14:40:29 <dolio> __pao__: Eta expansion also occasionally plays an important role in strict languages, where you change 'foo' to something like '\() -> foo' to delay its evaluation (although that's unrelated to point-freeness).
14:40:31 <dejones> laura85: you'll be fine!  :)
14:40:32 <tromp> we all envy you:)
14:40:40 <dejones> tromp: quite true.
14:40:40 <monochrom> Bring a spare brain in case the main one explodes.
14:40:47 <laura85> dejones, ^^
14:40:50 <vixey> lol
14:40:51 <laura85> g night
14:40:56 <YourA1gebra> night
14:41:18 <monochrom> General advice for exams: bring four pens, three calculators, two brains.
14:41:41 <dolio> __pao__: I suppose that makes more sense in Scheme, where '(lambda () foo)' is actuall a zero-argument procedure.
14:42:01 <dolio> \() -> foo technically isn't eta expansion.
14:42:15 <__pao__> dolio: thanks
14:42:29 <ADEpt> dejones: HaXml makes too many assumprtions about HTML to parse most of it
14:42:36 <ADEpt> dejones: i speak from experience
14:42:36 <__pao__> so... can you "read" (.) . (:) at first sight?
14:42:52 <monochrom> I can't.
14:42:54 <vixey> :t (.) . (:)
14:42:55 <lambdabot> forall (f :: * -> *) a. (Functor f) => a -> f [a] -> f [a]
14:42:57 <ADEpt> dejones: you might be much better off with xht
14:43:02 <vixey> hehehehe
14:43:05 <thunc> lambdabot: or c99?
14:43:06 <vixey> Hi Cale
14:43:18 <vixey> thunc is a spam bot
14:43:26 <dolio> I recognize 'foldr ((.) . (:)) id' because I've seen it before.
14:43:40 <Botje_> @quote oleg
14:43:40 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
14:43:44 <dejones> ADEpt: Thank you.  I definitely would like a library that is easier to work with since I'm not really trying to do very complex stuff... just parse html tags and insert data.  :)
14:43:45 --- mode: ChanServ set +o dibblego
14:43:48 <Botje_> @quote write
14:43:48 <lambdabot> No quotes match. :(
14:43:54 <dolio> Most quotes are gone.
14:44:02 <dibblego> vixey, how can you be sure?
14:44:07 <dolio> There are only a few left.
14:44:15 <dolio> @quote Cale
14:44:15 <lambdabot> Cale says: "Betta watch your back when I'm packin' a nine/I'll pump you fulla holes like the rational line"
14:44:20 * EvilTerran blinks
14:44:25 <vixey>  <vixey>  * thunc (n=thunc@bas1-toronto35-1279627401.dsl.bell.ca) has joined #haskell
14:44:25 <vixey>  <vixey>  <thunc> front
14:44:25 <vixey>  <vixey>  * thunc (n=thunc@bas1-toronto35-1279627401.dsl.bell.ca) has joined #scheme
14:44:25 <vixey>  <vixey>  <thunc> back
14:44:28 <Botje_> hmmm
14:44:32 <Botje_> has the @quote db been emptied?
14:44:35 <vixey> dibblego: They've been doing it for days
14:44:48 <vixey> (in other channels too)
14:44:51 --- kick: thunc was kicked by dibblego (dibblego)
14:45:00 --- mode: dibblego set -o dibblego
14:45:09 <vincenz> dibblego: what was that for?
14:45:22 <dibblego> vincenz, request (spam bot)
14:45:52 <vixey> vincenz: Have you noticed them in #scheme?
14:45:57 <vincenz> dibblego: I didn't see much spam
14:46:04 <araujo> mmm.
14:46:07 <araujo> is it a spam bot?
14:46:13 <vixey> araujo: Yes
14:46:19 <araujo> ok
14:46:24 <vincenz> vixey: how do you know?
14:46:28 <vincenz> all it said was "front" and "back"
14:46:40 <araujo> right
14:46:44 <araujo> what does it say?
14:46:48 <vincenz> vixey: seem like you're just blaming someone to say 'bot'
14:46:56 <dolio> Baughn was talking to it earlier. :)
14:46:58 <vixey> "bot"?
14:46:58 <vincenz> vixey: you blamed thunc of being a bot in #scheme as well
14:47:07 <vixey> no I did not
14:47:09 <vincenz> Erm, someone of being a bot, I'm tired
14:47:16 <__pao__> which interpreter engine does lambdabot runs on?
14:47:17 <vixey>  <vixey> is it bots that come in and say "back"?
14:47:20 <vixey> I asked if it was
14:47:26 <monochrom> lambdabot uses ghci
14:47:27 <vixey> because Scheme was having problems with bots
14:47:41 <Peaker> why would a bot come in and say back?
14:47:48 <dibblego> dolio, looking at Baughn's conversation, it still seems like a bot
14:47:53 <dolio> <thunc> Baughn: The problem here is. squid doesn't answer the call at times. requests on port 80 time out at times
14:48:00 <vincenz> hmm
14:48:02 <vincenz> ok
14:48:03 <dolio> Markov chain?
14:48:13 <__pao__> monochrom: why does my ghci 6.8.2 returns Prelude> :t ((.) . (:))
14:48:13 <__pao__> ((.) . (:)) :: a1 -> (a -> [a1]) -> a -> [a1]
14:48:22 <__pao__> and don't mention functor?
14:48:30 <monochrom> Because Cale added customizations :)
14:48:32 <araujo> so .. is it a bot or not?
14:48:43 <vincenz> araujo: that -is- the question
14:48:53 <vixey> it is a bot
14:48:53 <__pao__> monochrom: which ones? :-)
14:48:54 <dibblego> maybe I was a bit hasty, oops
14:49:00 <vincenz> to bot or not to bot
14:49:02 <araujo> vixey, what does it do?
14:49:05 <monochrom> He aliased (.) to fmap.
14:49:08 <TomM1> ?vixen is it a bot or not?
14:49:09 <lambdabot> i can't stand bots
14:49:16 <vixey> araujo: Joins channels and says "back" or "front"
14:49:24 <vincenz> vixey: are you a bot?
14:49:27 <vixey> no
14:49:31 <__pao__> monochrom: thanks
14:49:31 <monochrom> @quote lambdabot i can't stand bots
14:49:31 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
14:49:41 <monochrom> @remember lambdabot i can't stand bots
14:49:41 <lambdabot> Done.
14:49:50 <TomM1> ?where lambdabot
14:49:50 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
14:49:58 <TomM1> ?where bots
14:49:58 <lambdabot> I know nothing about bots.
14:50:06 <dibblego> looking at the log, I am pretty sure it is a bot
14:50:15 <araujo> vixey, only that? ... I have seen the nick joining other channels, but says nothing
14:50:18 <vixey> It's observationally equivalent :P
14:50:28 <vixey> araujo: it did it here a min ago
14:50:48 <vixey>  * thunc (n=thunc@bas1-toronto35-1279627401.dsl.bell.ca) has joined #haskell
14:50:48 <vixey>  <thunc> front
14:50:55 <dibblego> take a look at the discussion 2 hours ago; it's a bot
14:51:06 <araujo> mmm.. it was banned from #lisp a few minutes ago too ...
14:51:09 <TomM1> I need to make a bot that recognises other bots and calls them out for it.
14:51:13 <orzo> my program is crashing with the message <<loop>>
14:51:16 <orzo> what does that mean?
14:51:17 <vixey> and banned from #scheme a couple mins ago
14:51:27 <vixey> anyway
14:51:30 <TomM1> > f x = f x
14:51:30 <lambdabot>  Parse error at "=" (column 5)
14:51:32 <dibblego> TomM1, the IRC network admins usually have those
14:51:33 * araujo wonders if he should ban it from ##c too
14:51:47 <TomM1> > let f x = f x in f 0
14:51:48 <lambdabot>  Exception: <<loop>>
14:52:01 <vincenz> vixey: I still don't see on what basis, except that you asked whether it was a bot, Riastradh told it to talk, and it was silent
14:52:04 <TomM1> orzo: It means you have hit an infinate loop like that.
14:52:10 <vincenz> vixey: Could've been someone that says "back" as in, I'm back, and then was afk for an instant.
14:52:12 <glguy> ?seen dons
14:52:12 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc and #haskell. I last heard dons speak 5h 52m 34s ago.
14:52:15 <dibblego> vincenz, the discussion 2 hours ago* makes it clear that it is a bot
14:52:15 <Peaker> what is the purpose of a silly spambot spouting meaningless sentences?
14:52:27 <vixey> vincenz: That's possible but I've decided that it's a bot
14:52:32 <monochrom> To annoy people. To show that its owner has no life.
14:52:34 <glguy> is the spam bot still here?
14:52:44 <dibblego> glguy, no
14:52:49 <vixey> vincenz: It's true there's no way I could know but I cant prove much more than my own existence
14:52:49 <vincenz> Yes, I am.
14:52:57 <vincenz> vixey: Even that is shakey :)
14:52:59 <Peaker> maybe they're preparing a bot in order to pass the Turing test
14:53:08 <monochrom> I can prove your existence.
14:53:13 <vincenz> monochrom: no you can't
14:54:21 <monochrom> It is a weaker meaning of "prove". It just means that I persuade you.
14:54:48 <monochrom> Surely you exist, you should agree to that much.
14:54:57 <monochrom> Maybe I don't exist, but you do.
14:55:20 <glguy> whoa, the banlist is short
14:56:08 <vincenz> monochrom: i'm a figment of your imagniation
14:56:40 <vincenz> \o/ IRSeekBot was banned
14:57:11 <thunc> front
14:57:23 <monochrom> That's fine, because my POV is irrelevant.  I'm saying that from your POV you exist.
14:57:23 <stepcut> anyone remember which Haskell tutorial has the exercises where you implement decimal numbers as a list of digits ?
14:57:23 --- mode: ChanServ set +o glguy
14:57:23 --- mode: glguy set +b *!*n=thunc@*.dsl.bell.ca
14:57:23 --- kick: thunc was kicked by glguy (glguy)
14:57:24 * EvilTerran was thinking thunc might be an IRSeek bot
14:57:32 <glguy> he's a different kind of bot
14:57:44 <EvilTerran> given that they've been caught fibbing in the past about what their bots look like
14:57:47 <monochrom> what kind? what does it do?
14:57:59 <glguy> the kind that talks
14:58:01 <EvilTerran> and it doesn't say much
14:58:07 <orzo> how do i go about finding the infinite loop?
14:58:25 <vincenz> orzo: it's in the land of bottoms
14:58:25 --- mode: glguy set +b *!*@bas1-toronto35-1279627401.dsl.bell.ca
14:58:30 --- mode: glguy set -b *!*n=thunc@*.dsl.bell.ca
14:58:55 <monochrom> orzo: Try to prove termination of your program. Where your proof attempt fails, there is the bug.
14:59:12 --- mode: ChanServ set -o glguy
14:59:31 <monochrom> All programs should be assumed guilty until proven innocent.
14:59:57 <glguy> clog: has been in #haskell logging since 2001
15:00:08 <kaol> I just packaged and uploaded tagsoup for Debian. In case anyone cares about that.
15:00:49 <glguy> I don't know what bot is logging for tunes.org
15:01:11 <glguy> oh
15:01:12 <glguy> heh, nvm
15:01:20 <glguy> that's the tunes logger
15:02:31 <orzo> what if i dont want the program to terminate
15:02:42 <ddarius> monochrom: All programs are guilty.
15:02:50 <orzo> what causes haskell to print "<<loop>>" specifically?
15:02:59 <Botje_> > let loop=loop in loop
15:03:00 <lambdabot>  Exception: <<loop>>
15:03:01 <kaol> then your CPU will get hot
15:03:11 <monochrom> TomM1 had a great example. Study it.
15:03:28 <ddarius> kaol: You CPU will get hot whether or not the program terminates.  Servers don't terminate.
15:03:38 <monochrom> You don't want the program to terminate as a whole, but certainly you want some intermediate steps to terminate.
15:03:51 <orzo> well
15:03:59 <orzo> as far as i can tell the program is completing
15:04:14 <ddarius> If you don't want the program to terminate, then you probably want it to be productive.
15:04:16 <monochrom> Then good! There is no problem.
15:04:16 <orzo> but there is a <<loop>> message printed
15:04:23 <kaol> I meant in the sense that monochrom said. and I was being somewhat flippant too. sorry.
15:05:11 <monochrom> Some ghc profiling flags will probably find it, but I don't know which.
15:11:29 <orzo> is it important to call hs_exit() for some reason when embedding?
15:11:52 <monochrom> I think yes.
15:11:56 <orzo> i am calling it too early
15:12:08 <orzo> i'm tempted to just not call it
15:12:36 <EvilTerran> you could install it as an atexit()
15:12:53 <EvilTerran> maybe
15:24:48 <monochrom> Oh great, hxt 7.5 depends on parsec 3.  Not sure if that's an improvement.  parsec 3 is even slower. :)
15:25:57 <monochrom> Hrm, I spoke too soon.
15:26:34 <Jaak> but it is, no?
15:26:35 * monochrom tries parsec 2 and sees what happens.
15:27:34 <monochrom> Yes parsec 3 is slower. :)
15:28:15 <monochrom> But I mean I can't be sure what hxt 7.5 wants. It likely doesn't care.
15:28:32 <orzo> it's not finding the profiling libraries
15:28:34 <orzo> heh
15:28:34 <Jaak> but you could have bytestring parser with parsec 3... if i understand it correctly
15:29:02 <Jaak> that might be faster :P
15:29:15 <monochrom> Oh! Yes, that route is faster.
15:29:15 <vixey> maybe I should write a Tomb Raider level viewer in haskell :o
15:29:24 * vixey did this in C but lost the code
15:29:59 <monochrom> Haha, dependency hell, I haven't installed HTTP on this computer.
15:30:42 <monochrom> It looks like it wants tagsoup for the first time too.
15:31:08 * monochrom leeches more
15:32:35 <ZenGeek> hello
15:33:08 <orzo> hmm
15:33:15 <orzo> with profiling finally enabled, i get <MAIN.SYSTEM><MAIN.SYSTEM>a.out: <<loop>>
15:33:24 <orzo> that's not helpful, heh
15:33:52 <ZenGeek> hi
15:33:58 <ZenGeek> i need help!
15:34:09 <ZenGeek> i really really need someones help
15:34:18 <fophillips> ZenGeek: Just ask the question.
15:34:21 <glguy> homework due?
15:34:46 <Gwern-away> glguy: he has exams soon
15:34:59 <ZenGeek> okay.. in wxhaskell how can i add colour to text
15:35:10 <vixey> hi Gwern
15:35:16 <ZenGeek> using xwhaskell
15:35:54 <Gwern-away> vixey: ho
15:36:01 <Gwern-away> vixey: got my question I takes it
15:36:08 <vixey> yeah
15:36:37 <vixey> gwern: well the thing is the self interpreter from the paper doesn't work, so I haven't released my code
15:36:57 <vixey> everything else seems to work though
15:37:33 <Gwern-away> vixey: is the problem in your implementation or the interpreter written in the paper? might just be buggy
15:37:55 * vixey thinks it's probably the code from the paper that's wrong :p
15:38:20 <Gwern-away> yeah, I mean, how often do people actually try to run code straight from the papers?
15:38:34 <ZenGeek> does anyone here know haskell.. i have a bunch of questions about making an editor using wxhaskell
15:38:46 * ddarius ran code straight from a paper yesterday.
15:38:54 <Baughn> ZenGeek: ..this /is/ #haskell, yes.
15:39:00 <vincenz> ddarius: wow
15:39:06 <vincenz> ddarius: there's' a paper-interface for ghc?
15:39:15 <ddarius> vincenz: It was C code.
15:39:15 <Jaak> I have run code out of paper and found bugs :P
15:39:24 <ZenGeek> baughn
15:39:38 <ZenGeek> can you help me then.. would you have some time?
15:39:39 <Baughn> Whenever I run code in my head, it always works. It's very frustrating. :/
15:39:40 <monochrom> No one here knows Haskell.
15:39:45 <vincenz> ddarius: that makes it even more impressive :)
15:40:02 <vincenz> ZenGeek: ask your quesiton, those that can help will help then
15:40:06 <vincenz> ZenGeek: don't target specific people
15:40:08 <Jaak> finding bug in C code is impressive?
15:40:11 <ZenGeek> okay
15:40:12 <Jaak> i think not!
15:40:14 <vixey> ZenGeek: Have you already started coding and come up against some obstacle or are you wondering if what you want to do is possible?
15:40:18 <Gwern-away> bloody hell!
15:40:23 <vincenz> Jaak: no, running c-code directly from paper on ghc
15:40:24 <monochrom> I think the "zen" part in the name "zengeek" is important. :)
15:40:25 <Gwern-away> so the hackage package of directory *was* broken!
15:40:35 <Jaak> yeah, i got it :P
15:40:36 <ZenGeek> well i have ten million obstacles
15:40:55 <Gwern-away> I is half-tempted to just upload a working Directory tarball and to hell with anyone who tells me that's impolite
15:41:06 <vincenz> ZenGeek: start with step 1
15:41:33 <ZenGeek> okay how can i colour text
15:41:55 <ZenGeek> okay also.. i can write the fuctions needed
15:41:58 <vixey> ZenGeek: Have you checked the documentation for wxhaskell?
15:42:08 <ZenGeek> but i can exactly get them to work with the GUI
15:42:12 <ZenGeek> yes
15:42:19 <vixey> and it wasn't there?
15:42:20 <ZenGeek> i have but i dont understand it
15:42:26 <ZenGeek> they tell me the type
15:42:33 <ZenGeek> but i cant find a function
15:42:59 <Baughn> ZenGeek: You are allowed to write lines with more than six words
15:43:19 <ZenGeek> okay
15:43:45 <vixey> could you use FRP to write a text editor..?
15:43:56 <ZenGeek> what is FRP
15:44:09 <ZenGeek> i need to make a text editor yes
15:44:30 <Baughn> ZenGeek: Why? What's wrong with the ones we already have?
15:44:38 <ZenGeek> also.. how do you manipulate the cursor.. in wxhaskell
15:44:42 <ZenGeek> its for school
15:44:46 <ZenGeek> a project
15:44:47 <glguy> Baughn: can't turn in vim for homework
15:45:42 <mauke> ã€Œ<ZenGeek> computers arent even my thingã€-- good luck
15:47:13 <resiak> mauke: fancy brackets!  how do you type them?
15:47:36 <mauke> compose < |, compose > |
15:47:54 <vixey> http://www.cs.nott.ac.uk/~nhn/FoPAD2007/Talks/nhn-FoPAD2007.pdf
15:48:00 <resiak> hmm.  i guess you added them to .XCompose yourself?
15:48:28 <mauke> hmm ... indeed I did
15:48:49 * BMeph wants to see resiak command someone to ".XCompose yourself"
15:50:30 <resiak> mauke: i don't suppose you know how to reload .XCompose without restarting X, do you?
15:51:41 <solrize> @seen shapr
15:51:41 <lambdabot> shapr is in #scannedinavian, #haskell-blah and #haskell. I last heard shapr speak 22h 53m 56s ago.
15:51:48 <lament> is there a way to use parsec without writing "try" all the time?
15:51:53 <ZenGeek> thanks vixey
15:51:59 <ZenGeek> i'm reading it
15:52:19 <Baughn> lament: Stop needing to backtrack all the time?
15:52:23 <glguy> lament: that depends on the grammar
15:52:41 <Baughn> lament: Write your own primitives that already backtrack?
15:52:52 <glguy> ReadP doesn't need the explicit try :)
15:52:56 <mauke> resiak: .XCompose is client-side
15:53:06 <mauke> resiak: just restart your terminal or whatever
15:53:46 <resiak> mauke: so it is!
15:53:48 <lament> but i do need to backtrack all the time :(
15:54:05 <lament> so i just make primitives tryChar, tryString...
15:54:08 <lament> ?
15:54:23 <vixey> no
15:54:29 <vixey> write your parser without using try
15:54:39 <vixey> add it in the 3 crucial places that need it
15:54:49 <Jaak> i like that parsec has explicit try
15:54:57 <orzo> let loop = loop in loop -- doesn't  output "<<loop>>"  it just simply goes on forever without terminating.  Are you sure "<<loop>>" means infinite loop?
15:55:16 <Jaak> if you are writing simple parser and need try you have probably gone wrong
15:55:17 <orzo> i mean, i typed that into ghci
15:55:22 <Baughn> orzo: No, <<loop>> means deadlock
15:55:23 <vixey> > let loop x = loop x in loop 5
15:55:24 <lambdabot>  Exception: <<loop>>
15:55:48 <vixey> > let spin x = spin x in spn 5
15:55:48 <lambdabot>   Not in scope: `spn'
15:55:51 <vixey> > let spin x = spin x in spin 5
15:55:52 <lambdabot>  Exception: <<loop>>
15:55:57 <lament> Jaak: i need to distinguish between things like "bar" and "baz"
15:56:03 <orzo> hm, ghci doesnt give an exception on that
15:56:11 <Baughn> orzo: The RTS will have detected that no threads are able to make any progress, perhaps because a thunk eventually depends on itself. It's a very fragile mechanism, for debugging, not to be relied on.
15:56:12 <resiak> mauke: thanks!
15:56:30 <Jaak> lament: write a tokenizer and build parser on top of tokens
15:56:36 <Baughn> orzo: (Also, it works much better with threading turned on)
15:57:05 <lament> Jaak: why not just put try everywhere?
15:57:14 <EvilTerran> because that makes it much less efficient
15:57:17 <vixey> you should definitely parse in two stages
15:57:36 <Jaak> lament: backtracking is slow?
15:57:37 <EvilTerran> it's good style to lex then parse when possible, anyway, even in parser libs that backtrack implicitly
15:57:54 <EvilTerran> makes for two very simple things instead of one complicated one
15:58:06 <EvilTerran> s/makes/can make/
15:58:06 <lament> hmm
15:58:12 <monochrom> lament: the parsers "string", "char", ... each one alone has an implicit try already.  It is when you compose them, e.g., (char 'x' >> char 'y') instead of (string "xy") that you need try.
15:58:14 <vixey> Jaak: only redundant backtracking is inefficien
15:58:23 <Jaak> right, yes
15:58:48 * EvilTerran wasn't aware string had an implicit try
15:58:50 <Baughn> vixey: Or reparsing lexemes when you backtrack because those aren't being parsed separately
15:58:55 <Cale> On the other hand, it's often enough just to build very simple parsers which lex individual tokens, and then build on top of that. For larger things, I agree though that more separation between the phases is better.
15:58:56 <Baughn> That's very situational, though
15:59:24 <lament> monochrom: oh, really?
15:59:41 <monochrom> Try this example.  p1 = (char 'x' >> char 'y') <|> (char 'x' >> char 'z'); p2 = string "xy" <|> string "xz".  You will find that they behave differently when you input xz
16:00:00 <lament> monochrom: that contradicts the parsec page
16:00:12 * EvilTerran would just look in the source, personally
16:00:35 <lament> monochrom: parsec page says (string "(a)") <|> (string "(b)") will die when given input "(b)"
16:01:22 <vixey> unexpected "b" expecting "(a)"
16:01:30 <resiak> lament: you want to do   char '(' >> (char 'a' <|> char 'b') >> char ')'
16:01:35 <monochrom> I will re-verify with parsec 2.1
16:01:57 * resiak reads the scrollback and silences himself
16:02:04 <lament> resiak: i'm sure you appreciate the ugliness of that
16:02:11 <resiak> yeah :)
16:02:23 <resiak> hmm, isn't there a 'parens' combinator?
16:02:47 <lament> monochrom: yeah, it fails for me with 2.1
16:03:13 <lament> monochrom: string "xx" <|> string "xy" fails on "xy"
16:03:26 <vixey> xx = string "xx"
16:03:30 <vixey> xy = string "xy"
16:03:42 <vixey> token = try xx <|> try yy
16:03:48 <vincenz> vixey: no need for the second try
16:03:58 <vixey> (I actually elide the second try but it illustrates the pattern)
16:04:09 <monochrom> Oh great, that invalidates lots of things I said on comp.lang.haskell :)
16:04:27 <lament> trystr = try string
16:04:47 <vixey> trystr = ugly
16:04:52 <lament> xx = trystr "xx"; yy = trystr "yy"
16:04:58 <lament> token = xx <|> yy
16:05:04 <monochrom> Perhaps the behaviour I remember belongs to an older version.
16:05:05 <lament> i think that's what i'll do!
16:05:25 <kpreid> lament: itym trystr = try . string
16:05:33 <lament> er, right
16:05:34 <monochrom> If you use the Token module, all backtrackings are done for you.
16:05:53 <vincenz> vixey: where's the definition of ugly?
16:06:02 <monochrom> Also, adding try and backtracking to small things like string "xxx" doesn't hurt all that much.
16:06:17 <vixey> It's too long to paste :p
16:06:27 <vixey> and uses n+k patterns
16:06:32 <vincenz> oy
16:12:44 <vixey> @where Parsec
16:12:45 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
16:13:57 <monochrom> Hrm!  I issued "ghc-pkg hide parsec-3.0.0" before I configured and built hxt. But somehow it still built against parsec-3.0.0.  Is that good or bad?
16:15:56 <gwern> what does an error like '/usr/lib/gcc/x86_64-pc-linux-gnu/4.2.3/../../../../x86_64-pc-linux-gnu/bin/ld: cannot find -lHSdirectory-1.0.0.0_p
16:15:57 <gwern> indicate?
16:16:07 <gwern> I just installed the profiling lib for directory, so far as I knew
16:16:52 <gwern> actually, wait, that was locally, but maybe darcs needs'em installed globally...
16:17:30 <gwern> no, that doesn't help
16:17:34 <gwern> any ideas?
16:17:48 <ddarius> The main rule for using try is not to have big nested subparsers, or in particular, recursive calls.  That said, Parsec already has several predefined parsers for handling lexing like problems.
16:19:22 <gwern> (a make clean and reconfigure doesn't solve it)
16:20:06 <ZenGeek> i think
16:20:23 <ZenGeek> i might be because they are in different folders
16:20:31 <ZenGeek> gwen
16:20:45 <ZenGeek> gwem
16:21:19 <gwern> ZenGeek: use the tab-completion!
16:21:28 <ZenGeek> what is that?
16:21:48 <gwern> ZenGeek: also, unlikely, since directory is a separate library from the darcs I'm compiling, and should now be installed system-wide
16:22:58 <gwern> what is what?
16:23:06 <ZenGeek> nm
16:23:26 <ZenGeek> i'm not sure why you are get that error
16:23:38 <ZenGeek> i got a similiar error
16:24:09 <ZenGeek> but after i put everything installed into the same folder
16:24:16 <gwern> hmm... so I installed by hand directory-1.0, but the error is about directory-1.0.0.0
16:24:18 <ZenGeek> it worked.. but i dont know the ans to ur question
16:24:19 <ZenGeek> sorry
16:24:44 * gwern wonders whether directory-1.0.0.0 is seen as bigger/newer than 1.0 :)
16:26:55 <gwern> interesting. if I force an unregister of directory-1.0.0.0, leaving directory-1.0 alone, I get configuration errors
16:28:33 <gwern> uh oh. and now I can't build directory from darcs
16:29:29 <gwern> (guess I'll need to reinstall ghc...)
16:31:02 <gwern> (I begin to understand why no one ever seems to profile their applications)
16:31:10 <wadcom> hi
16:32:19 <wadcom> I need to create a unique directory (with random number in its name) and return its name to the caller
16:32:34 <wadcom> what way would you suggest to structure such a function?
16:33:22 <wadcom> I thought of having an (infinite) [lazy] list of names to try creating (and return as soon as it succeeds)
16:33:55 <wadcom> or creating a recursive function which would use randomIO to get just a single number
16:34:19 <gwern> wadcom: honestly, I'd just shell out to mktemp
16:34:41 <gwern> (why reinvent a wheel? It's not like I ever itnend to run my programs on non-POSIX stuff)
16:35:06 <wadcom> it's different from mktemp
16:35:46 <wadcom> gwern: oh, you mean /usr/bin/mktemp
16:36:07 <gwern> sounds exactly like mktemp to me. make a temporary directory with random/unique number appended
16:44:54 <monochrom> I am too lazy to look up this (actually don't know where to look). In a *.cabal file listing build dependencies, what are the version operators?  >=, <=, is there also ==?
16:45:47 <jberryman> greater than or equal too, etc...?
16:45:57 <monochrom> Yeah.
16:45:58 <ehird> @src foldl
16:45:59 <lambdabot> foldl f z []     = z
16:45:59 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:46:14 <monochrom> Heh, it doesn't hurt for me to just try == :)
16:47:47 <monochrom> "parsec == 2.1.0.0" works. :)
16:48:52 <realspace> hmm, the more i code in haskell the more i like haskell. really interesting...
16:49:31 <jberryman> could someone give me some pointers on generating all the permutation of elements of a list?
16:49:37 <jberryman> without regard to order
16:49:48 <ZenGeek> realspace..haskell is kool
16:49:50 <monochrom> Yes, Haskell is very likable.
16:50:09 <ZenGeek> its strick
16:50:15 <mauke> > filterM (return [True, False]) "abc"
16:50:16 <lambdabot>  ["abc","ab","ac","a","bc","b","c",""]
16:50:21 <mauke> no, wait
16:50:42 <jberryman> WITCH!
16:50:51 <mauke> jberryman: I'd write a helper function that extracts an element from a list, returning it and the remaining elements
16:51:00 <cjb> I think we decided that there is no permute function in the prelude
16:51:14 <vixey> jberryman: think about it recursively, permutations [] = [[]], permutations (x:xs) = concatMap (every way to insert x into) permutations xs
16:51:17 <cjb> @let permute (x:y:xs) = (map (x:) $ permute (y:xs)) ++ (map (y:) $ permute (x:xs)); permute xs = [xs]
16:51:18 <monochrom> jberryman: it was a much discussed and worked subject. But I don't remember where to find it.
16:51:19 <lambdabot> Defined.
16:51:23 <vixey> (permutations xs)*
16:51:25 <cjb> > permute [1,2,3,4]
16:51:26 <lambdabot>  [[1,2,3,4],[1,2,4,3],[1,3,2,4],[1,3,4,2],[2,1,3,4],[2,1,4,3],[2,3,1,4],[2,3,...
16:51:39 * monochrom goes search
16:51:48 <ehird> [00:50]  <ZenGeek> its strick
16:51:49 <ehird> it's lazy
16:52:13 <tromp> cjb: that is broken
16:52:23 <realspace> yes, but the beginning is/was really very hard. if you coded about 20 years imperativ, the functional way is not so easy. and the "curious" syntax is at the beginning not very helpful.
16:52:46 <ZenGeek> i'm at the beginning
16:52:49 <tromp> @let pick [] = []; pick (x:xs) = (x,xs) : map (second (x:)) (pick xs)
16:52:52 <lambdabot> Defined.
16:52:57 <ZenGeek> they are teaching us haskell
16:53:00 <ehird> realspace: have you come to the part where you realise the curious syntax is an advantage yet? :)
16:53:12 <tromp> @let perm = join (evalStateT . mapM (const (StateT pick)))
16:53:13 <lambdabot> Defined.
16:53:38 <tromp> > perm "perm"
16:53:38 <lambdabot>  ["perm","pemr","prem","prme","pmer","pmre","eprm","epmr","erpm","ermp","empr...
16:53:53 <ZenGeek> tromp
16:54:02 <tromp> > length . perm $ "perm"
16:54:02 <lambdabot>  24
16:54:04 <realspace> ehird: yes somewhat. I like the pattern matching and the guards very well. no more if/then/else nightmare...
16:54:10 <vixey> :t evalStateT
16:54:16 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m a
16:54:22 <monochrom> Cale: where is your "permute elements in list" code?  jberryman is interested.
16:54:38 <tromp> that is Cale's code
16:54:45 <tromp> i just renamed things
16:54:56 <cjb> ah :)
16:54:58 <ZenGeek> what is lambdadot?
16:55:10 <cjb> ZenGeek: it is a Haskell IRC bot
16:55:13 <allbery_b> @version
16:55:13 <lambdabot> lambdabot 4p603, GHC 6.8.2 (Linux i686 2.40GHz)
16:55:13 <lambdabot> darcs get http://code.haskell.org/lambdabot
16:55:14 <monochrom> Oh ok great, thanks tromp.
16:55:29 <ZenGeek> kool
16:55:33 <realspace> oh, i did't mean "somewhat", but "somehow" (i'm not a native english speaker)
16:55:47 <vixey> @src evalStateT
16:55:47 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
16:56:08 <ZenGeek> realspace
16:56:17 <ZenGeek> have you tried wxhaskell?
16:56:43 <tromp> > evalStateT (replicateM 2 (StateT pick)) "perm"
16:56:44 <lambdabot>  ["pe","pr","pm","ep","er","em","rp","re","rm","mp","me","mr"]
16:56:51 <tromp> > evalStateT (replicateM 3 (StateT pick)) "perm"
16:56:52 <lambdabot>  ["per","pem","pre","prm","pme","pmr","epr","epm","erp","erm","emp","emr","rp...
16:57:05 <ehird> [00:55]  <realspace> oh, i did't mean "somewhat", but "somehow" (i'm not a native english speaker)    <-- you don't have to correct things like that in here :)
16:57:21 <ehird> on another note, a Haskell implementation of MapReduce would be very interesting
16:57:21 <realspace> no. currently i'm using haskell for a calculating kernel and small command line tools
16:57:23 <tromp> > evalStateT (replicateM 4 (StateT pick)) "perm"
16:57:23 <lambdabot>  ["perm","pemr","prem","prme","pmer","pmre","eprm","epmr","erpm","ermp","empr...
16:57:26 <tromp> > evalStateT (replicateM 5 (StateT pick)) "perm"
16:57:27 <lambdabot>  []
16:57:28 <ehird> i imagine laziness could make everything far cooler
16:57:51 <Pseudonym> Laziness makes everything cooler.
16:59:41 <ddarius> Pseudonym: Even liquid He?
16:59:50 <ehird> Pseudonym: Yes!
17:00:08 <Pseudonym> ddarius: Don't knock it until you've played with lazy liquid He.
17:00:24 <ehird> But yeah, I want sum of 'dat lazy, pure, parallel stuff.
17:05:24 <jberryman> thanks for the replies. it will take me a bit of time to sort them out :)
17:06:13 <realspace> ok, it is really late here, some hundred lines of haskell is written so  now it is time to take some sleep. goodnight *
17:17:30 <gxng> @
17:41:06 <shapr> @users
17:41:06 <lambdabot> Maximum users seen in #haskell: 477, currently: 425 (89.1%), active: 2 (0.5%)
17:51:08 <gxng> hello ppl
17:53:05 <TSC> Howdy
17:55:05 <ZenGeek> TSC
17:55:10 <ZenGeek> you there?
17:55:43 <wagle_home> @seen TSC
17:55:43 <lambdabot> TSC is in #xmonad, #haskell-blah and #haskell. I last heard TSC speak 2m 38s ago.
17:56:13 <haskelln00b> hi
17:56:16 <haskelln00b> yes
17:56:18 <vixey> hi TSC
17:56:25 <haskelln00b> i got my name changed
17:56:44 <Botje_> zomg mutation!
17:57:53 <haskelln00b> who wants to help me?
17:57:55 <haskelln00b> :)
17:58:09 <TSC> Everyone; #haskell is such a nice place
17:58:28 <haskelln00b> it is
17:58:46 <haskelln00b> i'm trying to get an editor to work in wxhaskell
17:58:51 <haskelln00b> its written in that
17:59:16 <haskelln00b> i'm having a problem connecting the functions written
17:59:20 <haskelln00b> to the GUI
18:00:15 <haskelln00b> everything looks pretty
18:00:22 <haskelln00b> but harly anything works
18:00:31 <haskelln00b> hardly**
18:02:37 <TSC> That indeed is a problem
18:03:05 <kpreid> haskelln00b: I don't know if there's anyone that knows wxHaskell around at the moment, but I do know that you'll need to be more specific about what the problem is.
18:03:29 <haskelln00b> for example
18:03:42 <haskelln00b> i open a new window
18:04:04 <haskelln00b> like on of those which would pop up if you want to find a word in a doctument
18:04:12 <haskelln00b> one**
18:04:21 <haskelln00b> and i have to write
18:04:25 <haskelln00b> on command
18:04:32 <haskelln00b> do so and so
18:04:39 <haskelln00b> on command :=
18:04:53 <haskelln00b> now if i write a helper function
18:05:04 <haskelln00b> i'm supposed to be able to locally define it
18:05:14 <haskelln00b> using the word 'where'
18:05:22 <haskelln00b> but i get an error
18:06:09 <haskelln00b> even if i try to define the function globally i get an error
18:06:20 <haskelln00b> i guess i dont understand IO functions
18:08:21 <haskelln00b> okay
18:08:32 <haskelln00b> what not not in scope mean
18:08:35 <sgillespie> hello
18:08:39 <haskelln00b> find :: TextCtrl a -> IO ()
18:08:41 <haskelln00b> hi
18:08:47 <dibblego> not . not == id
18:08:48 <haskelln00b> how are you?
18:09:07 <kpreid> haskelln00b: that sounds like you have basic haskell syntax problems, not anything to do with wxhaskell
18:09:15 <fons> hi all
18:09:20 <haskelln00b> yes i think so
18:09:26 <haskelln00b> hi  fons
18:09:30 <fons> I'm curious about the primitive nature of seq
18:09:32 <kpreid> haskelln00b: if you post a suitable portion of your code on hpaste we'll tell you where the problem is.
18:09:39 <vixey> @src seq
18:09:40 <lambdabot> Source not found. You type like i drive.
18:09:42 <kpreid> ?paste
18:09:42 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:09:46 <sgillespie> I'm looking at the following HM implementation in haskell (its written in ocaml)
18:09:48 <fons> AS far as I undersntand it can be defined without using primitives
18:09:57 <sgillespie> http://groups.google.com/group/comp.lang.functional/browse_thread/thread/8f811d71b5357d47/f7b7e94e40928298?lnk=st&q=polymorphic+type+systems#f7b7e94e40928298
18:09:59 <lambdabot> Title: Polymorphic Type Systems - comp.lang.functional | Google Groups, http://tinyurl.com/69swyk
18:10:12 <kpreid> fons: it can be defined for any particular type but not every type
18:10:21 <haskelln00b> hpaste is what"?
18:10:22 <lament> in haskell written in ocaml?
18:10:24 <fons> kpreid: uhm, how about this
18:10:25 <haskelln00b> kp
18:10:28 <kpreid> ?paste
18:10:28 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:10:30 <sgillespie> sorry
18:10:33 <kpreid> there
18:10:41 <fons> data Strict a = Strict !a
18:10:43 <sgillespie> its in ocaml...I'm trying to port it to haskell
18:11:04 <sgillespie> (because most hm implementations I've seen are in ocaml)
18:11:41 <kpreid> fons: well, you'd need a second field to get seq's behavior, but...hm. dunno how that wouldn't work
18:11:49 <haskelln00b> find :: TextCtrl a -> IO (); find txtCtrl; = do   g  <- get inp text; txt <- get txtCtrl text; set txtCtrl [text := finder g txt]
18:12:03 <fons> seq a b = let forceStrict (Strict a) b = b in forceStrict (Strict a) b
18:12:26 <fons> kpreid: this definition of seq seems to wokr just fine
18:12:31 <vixey> sgillespie: You may want to look at a Prolog implementation too
18:13:02 <fons> does lambdabot accept type definitions?
18:13:11 <sgillespie> vixey: prolog? you mean the implementation of prolog, or an implementation in prolog
18:13:28 <vixey> type inference in Prolog
18:13:32 <sgillespie> I guess what I'm looking for is a more functional approach
18:13:52 <vixey> more than ..?
18:13:59 <kpreid> haskelln00b: what is the error?
18:14:32 <fons> I must be missing something, otherwise seq wouldn't be a primitive in the standard
18:14:42 <fons> but it seems to work just fine
18:15:10 <sgillespie> Look at the url i just posted and scroll down to Neelakantan's post
18:15:53 <jsnx> haskelln00b: could you please put your code in hpaste?
18:16:45 <shapr> @yow !
18:16:45 <lambdabot> CONGRATULATIONS!  Now should I make thinly veiled comments about
18:16:45 <lambdabot> DIGNITY, self-esteem and finding TRUE FUN in your RIGHT VENTRICLE??
18:17:56 <jsnx> haskelln00b: how did you get a `:=` operator?
18:18:28 <vixey> := is a type constructor
18:18:32 <haskelln00b> its like my where is not in scope
18:19:09 <haskelln00b> jsnx
18:19:14 <haskelln00b> sorry kp
18:19:24 <haskelln00b> i didnt see all that you'll wrote
18:19:41 <haskelln00b> my chat bar was higer up.. i thought the chat went dead
18:19:59 <haskelln00b> jsnx := is used in wxhaskell
18:20:38 <haskelln00b> kp error.. is not in scope
18:20:50 <haskelln00b> for inp
18:21:01 <haskelln00b> even though i defined inp b4
18:21:14 <haskelln00b> and that funtion came after where
18:21:44 <Cale> fons: Strictness annotations in data constructors are defined in terms of seq
18:22:11 <Cale> fons: Also, seq can almost be defined using a typeclass.
18:22:20 <fons> Cale: does the report mention that?
18:22:22 <Cale> fons: at least, it can be defined for most types
18:22:43 <Cale> Yeah, the report mentions how strictness annotations in data decls get translated
18:22:44 <fons> (seq being used to implement strict fields)
18:22:49 <Cale> yeah
18:23:04 <fons> ok, then I didn't do anything suprprising since my definition depends on seq
18:23:10 <fons> thanks Cale
18:23:26 <Cale> For instance, to define seq for lists, you can write  seq x y = case x of [] -> y; (_:_) -> y
18:23:38 <dolio> What wouldn't work in the class? Functions?
18:23:42 <Cale> yeah
18:23:47 <dolio> That shouldn't work anyway. :)
18:24:26 <fons> uhm, OK
18:24:29 <koninkje> sgillespie: what exactly are you looking for as being "more functional"?
18:25:17 <fons> Cale: BTW I have read about deepSeq in the Haskell' wiki, is there something like that already available? The ghci debugger has :force, which must be implemented similarly to deepSeq
18:25:55 <Saizan> fons: we have rnf in Control.Parallel.Strategies
18:25:57 <Cale> I'm pretty sure that :force just does the same amount of evaluation that seq does
18:26:08 <Cale> But I might be wrong about that.
18:26:17 <Cale> Yeah, there's rnf.
18:26:37 <Cale> deepSeq is needed surprisingly rarely though
18:27:56 <fons> Cale: Quting the ghci debugger manual "we can use :force instead of :print. The :force command behaves exactly like :print, except that it forces the evaluation of any thunks it encounters"
18:28:01 <fons> Quoting*
18:28:08 <Cale> ah
18:28:13 <fons> :print seems to behave like seq
18:28:26 <Cale> No, print does no evaluation at all.
18:29:02 <fons> Right
18:29:23 <fons> anyway, :force seems to be equivalent to deepSeq
18:29:39 <Cale> hmm...
18:29:42 <Cale> Prelude> let xs = [1..]
18:29:45 <Cale> Prelude> :force xs
18:29:46 <Cale> xs = _
18:29:54 <Cale> Prelude> :print xs
18:29:54 <Cale> xs = (_t1::[t])
18:30:17 <fons> uhm, then its not evaluating all the thunks it encounters ...
18:30:26 <Cale> ah, I see.
18:30:29 <fons> according to the manual, it should
18:30:33 <Cale> xs is polymorphic?
18:30:41 <haskelln00b> what does parse error on input where mean?
18:30:48 <Cale> When I give xs a type signature [Integer] instead, :force takes forever
18:30:52 <fons> [qsort.hs:2:15-46] *Main> :force left
18:30:52 <fons> left = [4,0,3,1]
18:31:02 <haskelln00b> what does parse error on input 'where' mean?
18:31:05 <Cale> haskelln00b: It means that you put a 'where' somewhere that there shouldn't be one :)
18:31:18 <fons> left is polymorphic in the example
18:31:19 <Cale> haskelln00b: What are you trying to do?
18:31:20 <haskelln00b> thanks
18:31:30 <haskelln00b> trying to
18:31:35 <pan993> http://ninja-net.blogspot.com/
18:31:37 <pan993> -_-
18:31:41 <haskelln00b> define a function
18:31:41 <pan993> inspiring stuff
18:31:45 <haskelln00b> that i called
18:31:47 <Botje_> kick pan993 please
18:31:49 <Cale> haskelln00b: Note that you're not meant to type declarations into GHCi/hugs
18:31:57 <haskelln00b> ohh
18:31:58 <Botje_> he said the exact same stuff on #perl
18:32:00 --- mode: ChanServ set +o Cale
18:32:02 <haskelln00b> that may be why
18:32:08 --- kick: pan993 was kicked by Cale (Cale)
18:32:12 --- mode: Cale set -o Cale
18:32:13 <haskelln00b> so what should i write?
18:32:21 <Botje_> thanks!
18:32:34 <Cale> haskelln00b: You should keep an editor window open alongside GHCi
18:32:44 <kilimanjaro> Cale, next time you should let us summon you, captain planet style. Earth, Wind, Fire, Water, Heart!
18:32:46 <Cale> haskelln00b: Declarations go into a file with the extension .hs
18:32:55 <Cale> kilimanjaro: ahaha
18:33:00 <Botje_> can't we have a "Cale" sign in the iar?
18:33:04 <Botje_> *air
18:33:14 <haskelln00b> oh yes.. its in that file.. but i still get the error
18:33:26 <kilimanjaro> Botje_, good idea, I say we have the letters "Cale" but replace the l with a lambda
18:33:32 <Cale> haskelln00b: can you use a pastebin to paste the file for us?
18:33:32 <koninkje> haskelln00b: you can use 'let'...'in' directly in ghci
18:33:49 <haskelln00b> can you tell me how?
18:34:04 <Cale> hpaste seems down, so...
18:34:16 <Cale> http://paste.lisp.org/
18:34:23 <koninkje> "let blah in yar" =:= "yar where blah"
18:34:34 <haskelln00b> okay
18:34:40 <haskelln00b> ill do that
18:34:44 <haskelln00b> thanks
18:34:53 <Cale> Except that 'where' is part of declaration syntax, and 'let' is part of expression syntax :)
18:34:58 <koninkje> but if you're doing anything more than brief prototyping, you really should be doing it it some file you've loaded
18:35:07 <Cale> koninkje: Apparently he is.
18:35:16 <haskelln00b> i think its a syntax error
18:35:26 <Cale> It might also be an indenting problem.
18:35:38 <dolio> > let f = let g = x where x = 5 in g + y where y = 3 in f
18:35:40 <lambdabot>  8
18:35:48 <haskelln00b> because its now in ghc.. i just use ghci to compile
18:35:48 <Cale> heh
18:35:55 <fons> haskelln00b: it would be a good idea to paste your code at the link suggested by Cale so that we have a look at it
18:37:01 <Cale> btw, where has hpaste gone?
18:37:11 <Cale> @seen glguy
18:37:11 <lambdabot> I saw glguy leaving #haskell 46m 37s ago, and .
18:37:16 <Cale> hmm
18:37:23 <dolio> !paste
18:37:23 <hpaste> Haskell paste bin: http://hpaste.org/
18:37:31 <dolio> It's running.
18:37:38 <dolio> But the website is broken or something.
18:39:20 <fons> the server is responding to ICMP traffic at least ...
18:40:34 <fons> time to go to bed
18:40:45 <fons> bye guys
18:41:05 <Cale> haskelln00b: are you having trouble pasting?
18:42:54 <haskelln00b> this channel
18:43:00 <haskelln00b> is haskell.hr?
18:43:15 <Cale> uh, no, just leave that blank
18:43:34 <Cale> lisppaste has an announce bot which isn't in this channel
18:43:48 <haskelln00b> okay i pressed sent
18:44:02 <Cale> have a url?
18:44:18 <Cale> http://paste.lisp.org/display/58956
18:44:19 <Cale> ?
18:44:25 <haskelln00b> yes
18:44:36 <Cale> ah, I see
18:44:46 <Cale> Yeah, you can't place a where inside of a do-block like that
18:44:54 <Cale> It's not an expression form
18:45:05 <Cale> It attaches to function declarations
18:45:05 <haskelln00b> you have Graphics.UI.WX
18:45:23 <haskelln00b> oh yes
18:45:30 <haskelln00b> i'll send you that as well
18:45:32 <Cale> What you want is let
18:46:04 <Cale> as a line of your do-block for finderWindow:
18:46:06 <Cale> let find :: TextCtrl a -> IO ()
18:46:13 <Cale>     find txtCtrl = ...
18:46:22 <Cale> but <- button f [...]
18:48:27 <haskelln00b> yes
18:48:45 <haskelln00b> where you see where
18:49:09 <Cale> yeah, that's a syntax error because 'where' isn't for expressions
18:49:15 <haskelln00b> there have no curse words in that version right?
18:49:22 <haskelln00b> ohh
18:49:33 <haskelln00b> that is an expression?
18:49:38 <Cale> ...
18:49:48 <haskelln00b> the find thing is an expression?
18:49:53 <Cale> uhh...
18:50:02 <Cale> find itself is a declaration
18:50:17 <Cale> Like, you have a declaration for find inside that 'where'
18:50:39 <haskelln00b> so instead of where
18:50:42 <shepheb> http://www.snotr.com/video/1002
18:50:43 <haskelln00b> what can i say?
18:50:43 <Cale> But the 'where' looks like it's intended as part of the expression starting with button f [...]
18:50:47 <shepheb> awesome wooden binary adding machine
18:50:51 <Cale> <Cale> let find :: TextCtrl a -> IO ()
18:50:52 <Cale> <Cale>     find txtCtrl = ...
18:50:52 <Cale> <Cale> but <- button f [...]
18:51:54 <haskelln00b> no
18:51:56 <haskelln00b> that button
18:52:07 <haskelln00b> is supposed to make it find
18:52:12 <haskelln00b> whatever
18:53:01 <kpreid> haskelln00b: Cale's advice is correct
18:53:31 <kpreid> you put the 'let find ...' in the do block just before but <- and after inp <-
18:54:20 <haskelln00b> i put let find txtCtrl = do...
18:54:21 <haskelln00b> ?
18:55:44 <koninkje> haskelln00b: do { x <- foo ; let bar = baz ; y <- bar quux }
18:56:49 <haskelln00b> okay so do i have to change the type
18:56:55 <haskelln00b> of the finder window
18:57:20 <haskelln00b> to TextCtrl a -> IO
18:57:23 <haskelln00b> ?
19:01:42 <TomMD> > let f = const "pong" in f "ping"
19:01:43 <lambdabot>  "pong"
19:01:58 <haskelln00b> i got error on input '='
19:01:58 <haskelln00b> then i changed it
19:01:58 <haskelln00b> and got .. the last statement in a do construct must be and expression
19:02:37 <TomMD> haskelln00b: If you are looking for help on code then post the offending snippet @ hpaste
19:02:39 <TomMD> @where paste
19:02:39 <lambdabot> http://hpaste.org/new
19:03:00 <koninkje> whenever you have a do-block the last line must say what it is you're returning, otherwise how would we know what the value of running that block is?
19:03:21 <TomMD> and '=' generally needs to be in a 'let' block.
19:03:32 <kpreid> TomMD: hpaste is down
19:03:58 <haskelln00b> now its parse error on input 'but'
19:04:10 <koninkje> haskelln00b: you needn't necessarily use `return` but the last line of a do-block must be an expression, not (a) a 'let' definition, not (b) a "foo <- bar" binding
19:04:20 <TomMD> Oh!  Well... if someone is looking for help then post the offending snippet under the wikipedia page of a US politician...
19:09:46 <koninkje> haskelln00b: if you've done a "(x:xs)" pattern, you can just use "x" instead of "head (x:xs)" and can use "xs" instead of "tail (x:xs)"
19:13:14 <nornagon> > head (a:undefined)
19:13:18 <lambdabot>  a
19:13:31 <nornagon> > tail (undefined:as)
19:13:32 <lambdabot>   Not in scope: `as'
19:13:42 <nornagon> > tail (undefined:1)
19:13:42 <lambdabot>   add an instance declaration for (Num [a])
19:13:51 <nornagon> er
19:13:58 <nornagon> > tail (undefined:[1])
19:13:59 <lambdabot>  [1]
19:14:37 <haskelln00b> .
19:15:18 <Pseudonym> > head (2:undefined)
19:15:19 <lambdabot>  2
19:15:26 <fnoble> the idea is that the ":" in (x:xs) is the same as the ":" the cons operator
19:15:59 <TomMD> > 1 : 2 : 3 : 4 : []
19:16:00 <lambdabot>  [1,2,3,4]
19:16:20 <fnoble> so saying match (x:xs) means match the list with head x and tail xs
19:16:20 <TomMD> 1 : [2,3,4]
19:17:06 <koninkje> i.e. "head (x:xs)" is building up a new list with a head x and tail xs and then taking the ehad of that new list (which you already had)
19:19:37 <haskelln00b> i should give up right?
19:19:37 <haskelln00b> someone say yes... anyone
19:19:48 <fnoble> it gets a lot easier
19:20:12 <koninkje> haskelln00b: are you new to funcional languages, or just new to haskell?
19:20:47 <kpreid> ..
19:26:41 <heatsink> I noticed that Id is a lot like Haskell.  How are they related?
19:27:24 <shapr> whoa, heatsink is back?
19:27:41 <jsnx> well, that didn't end well
19:27:47 <heatsink> Dun dun dunnnn.
19:28:48 <TomMD> Urge to make a library... but I don't know what.
19:28:50 <heatsink> shapr: I was here when you were talking about BUGs too.  Yesterday, I think.
19:29:06 <jsnx> TomMD: finish the ASN.1 library
19:29:16 <jsnx> add GSER
19:29:54 <TomMD> I'll stear clear of ASN... and probably anything else that has a heavy parsing component.
19:32:32 <shapr> TomMD: There's already an ASN.1 library.
19:32:40 <shapr> Dominic Steinitz wrote it.
19:32:43 <geezusfreeek> i hate seeing stuff like that: <haskelln00b> i should give up right?
19:32:56 <jsnx> it's sad
19:33:00 <shapr> geezusfreeek: Hey, people choose their own path in life.
19:33:13 <jsnx> what is the canonical way to dump the bytes in an Int?
19:33:17 <shapr> Those who give up often and easy won't hang out here.
19:33:39 <TomMD> jsnx: Data.Binary?
19:34:20 <lament> shapr: that's not true!
19:34:24 <geezusfreeek> of course that is true, but it's still frustrating to see somebody get so frustrated
19:34:28 <lament> i'm still here \o/
19:35:24 <heatsink> geezusfreeek: that's true.
19:35:24 <geezusfreeek> especially if it is over something i think they would genuinely find enlightening if they would be able to "get it"
19:35:31 <geezusfreeek> like haskell :)
19:35:37 <Pseudonym> geezusfreeek: That's so self-referential.
19:35:39 <dibblego> geezusfreeek, I get the same feeling of frustration
19:36:31 <geezusfreeek> your mom is self-referential
19:36:35 <geezusfreeek> ooooooooh!
19:54:47 <dainanaki> how come this doesn't work
19:54:50 <dainanaki> optLittleC :: [FilePath] -> IO [FilePath]
19:54:50 <dainanaki> optLittleC list = do
19:54:50 <dainanaki> 	modTime <- mapM getModificationTime list
19:54:51 <dainanaki> 	zipped <- zip modTime list
19:54:51 <dainanaki> 	sorted <- sortBy (compare . fst) zipped
19:54:51 <dainanaki> 	return (map snd sorted)
19:54:53 <dainanaki> ?
19:55:29 <kpreid> dainanaki: because zip ... and sortBy ... don't return actions
19:55:43 <kpreid> you can write let zipped = zip ... instead
19:58:18 <dainanaki> ok thanks
20:00:49 * shapr kills hpaste for restarting, hopefully.
20:03:14 <dejones> @seen Cale
20:03:14 <lambdabot> Cale is in #haskell-overflow, #haskell-blah, #ghc and #haskell. I last heard Cale speak 1h 12m 21s ago.
20:03:21 <roconnor> @go 1 troy oz in oz
20:03:23 <lambdabot> http://en.wikipedia.org/wiki/Troy_weight
20:03:29 * SamB wonders how one gets packages made by "apt-build" to authenticate
20:03:36 <shapr> put in your own key
20:03:43 <dejones> isXText t@(NTree (XText _) _) =  [t] --- this line of Haskell code is not clear to me... what is the @ for?
20:03:59 <SamB> shapr: I don't know that the packages are built with any key
20:04:11 <dejones> :t @
20:04:12 <lambdabot> parse error on input `@'
20:04:17 <roconnor> @go 31.1034768 g in oz
20:04:18 <lambdabot> http://en.wikipedia.org/wiki/Ounce
20:04:18 <lambdabot> Title: Ounce - Wikipedia, the free encyclopedia
20:04:25 <bd_> dejones: the value of the (NTree (XText _) _) bit is assigned to t
20:04:27 <roconnor> @go 31.1034768 g in ounce
20:04:28 <lambdabot> http://www.goldcalculator.com/index_files/page0033.htm
20:04:28 <lambdabot> Title: Troy Ounce Weight Measure Units-Gold Calculator Software
20:04:41 <bd_> dejones: so, basically the first arg goes into t - but it also checks that it matches that pattern
20:05:51 <dejones> bd_: so it an in place pattern match but assigns to t, so t can be used in the function?
20:05:57 <dejones> * it is an...
20:06:07 <bd_> right
20:06:39 <dejones> bd_: thank you.  :)
20:06:55 <Tordek> is there some standardizedish order for function variables? rule of thumb, style, whatever
20:09:00 <bd_> typically you'd put the more constant things first
20:09:07 <bd_> that way you can use partial application easily
20:09:28 <bd_> eg, with map, it's map f l, not map l f, because you can just have doSomethingToAList = map someFunction  easily enough
20:11:24 <Tordek> so what if I had defined it as map l f; is there a way to make that work with partial app?
20:11:28 <lament> doAnythingToAList = (`map` myList)
20:11:48 <lament> Tordek: see flip
20:11:53 <Tordek> what does ` ` do?
20:11:56 <SamB> doAnythingToMyList = (`map` myList)
20:11:57 <lament> :t flip map
20:11:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
20:12:23 <SamB> Tordek: (`f` y) = (\x -> f x y)
20:12:37 <Tordek> thanks :)
20:12:41 <SamB> actually, `` just makes the name work as an infix operator
20:12:42 <koninkje> Tordek: `foo` makes foo an infix operator
20:12:54 <lament> errrrrrrrr, don't look at that type signature for map
20:13:05 <SamB> and yeah, Cale made map crazy
20:13:11 <lament> just trust me: (flip fn) switches the first and second argument of fn :)
20:13:27 <SamB> :t flip (.)
20:13:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
20:13:31 <mauke> :t flip P.map
20:13:32 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
20:13:42 <shachaf> Cale made map reasonable.
20:13:47 <SamB> whatever
20:14:07 <lament> cale single-handedly fixed haskell!
20:14:10 <shachaf> Call it mapList (or P.map, or something) if you want to refer to the [] version.
20:14:48 <lament> shachaf: the point here is that it confuses newbies
20:15:06 <lament> makes it harder to use lambdabot for pedagogical purposes
20:15:16 <lament> as just happened right now
20:15:18 <shachaf> lament: So use another name for the specialized version.
20:15:27 <SamB> shachaf: still complicates things
20:15:37 <lament> shachaf: um, that's exactly what would confuse newcomers
20:15:38 <SamB> I'm not saying this is necessarily bad
20:15:46 <SamB> just complicated
20:16:02 <lament> also
20:16:06 <lament> @src map
20:16:06 <lambdabot> map _ []     = []
20:16:06 <lambdabot> map f (x:xs) = f x : map f xs
20:16:17 * shachaf agrees that it could be confusing, but not that the solution is to cripple a good name.
20:16:18 * lament is not a fan
20:16:27 <lament> shachaf: dude, it's Haskell.
20:16:32 <shachaf> lament: Well, that can be fixed. :-)
20:16:38 <dolio> At least it's not '(Functor f (~>) (~~>)) => (a ~> b) -> (f a ~~> f b)' :)
20:16:41 <SamB> I think whenever you use a Calaskell name in @type, it should warn you
20:16:46 <SamB> Cale: what say you?
20:17:03 <lament> shachaf: people come here to learn Haskell, not Haskell Prime or whatever
20:17:05 <Cale> SamB: That would be good :)
20:17:31 <mauke> how about using the H98 version in @type but fmap in @run?
20:17:35 <Cale> Who was it that was making an attempt at the dual-version lambdabot?
20:17:43 <SamB> mauke: that would be worse, â€ŽI think
20:17:49 <lament> dolio: :D
20:17:52 <dibblego> why does a generalisation confuse newbies and not the other way around?
20:18:02 <SamB> when you get confused about how something is well-typed, you use @type
20:18:17 <mauke> .oO( in soviet russia, newbie confuses generalisations )
20:18:18 <dolio> dibblego: The issue is that it's different from what they'll get on their own computer.
20:18:19 <Cale> dibblego: A newbie confuses generalisations?
20:18:20 <lament> dibblego: not generalization, but the fact that lambdabot is different from the rest of the world (including the docs)
20:18:30 <dibblego> ok agreed
20:18:49 <SamB> so that's why I think @type would be the ideal place to head-off confusion
20:19:03 <Cale> I really do agree that these changes should be made to the libraries and not *really* in lambdabot :)
20:19:35 <lament> Cale: add "I wish it were" to the signature :)
20:19:52 <SamB> hah
20:19:57 <SamB> as in:
20:20:04 <SamB> @type (.)
20:20:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:20:20 <SamB> <lambdabot> I wish it were: forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:20:33 <awesame> I'm trying to get Network.URI's unEscapeString to hand me a UTF-8 String, but for some reason it's not working
20:20:38 <SamB> ?
20:20:57 <awesame> looking at the source, it looks like it calls chr on each encoded Int
20:21:09 <SamB> awesame: might it, perhaps, be handing you a proper String?
20:21:25 <awesame> sorry, what I want is a proper string
20:21:26 <SamB> that is, in Unicode, as a String should be?
20:21:27 <awesame> String
20:21:29 <Tordek> what's a functor? :S
20:21:38 <mauke> @src Functor
20:21:38 <lambdabot> class  Functor f  where
20:21:38 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
20:21:46 <vixey> @index whileM
20:21:46 <lambdabot> bzzt
20:22:04 <awesame> instead, it's handing me a string where each character is what you get when you call chr on the Int that was urlencoded
20:22:13 <awesame> so multibyte characters are getting split
20:22:31 <SamB> awesame: oh. you mean URL encoding encodes UTF-8 as seperate bytes?
20:22:37 <awesame> yeah
20:22:41 <SamB> is UTF-8 now standard for URLs?
20:22:56 <awesame> like %e3%81
20:23:26 <koninkje> @info (%)
20:23:26 <lambdabot> (%)
20:23:28 <SamB> so you ARE getting a string encoded in UTF-8
20:23:32 <koninkje> @src (%)
20:23:32 <lambdabot> x % y = reduce (x * signum y) (abs y)
20:23:32 <awesame> I'm not sure what the standards are, but a urlencoded string of utf8 bytes usually works everywhere
20:23:36 <SamB> but you WANT a string that isn
20:23:37 <SamB> 't
20:23:39 <awesame> SamB: right
20:23:51 <koninkje> bah! what's the command to find the module?
20:23:54 <lament> Tordek: a functor is a generalized container type: if you have a function fn that you can apply to its elements, then you can apply the function to the entire container with fmap fn
20:24:02 <awesame> I know how to decode a utf8 ByteString to a unicode String
20:24:03 <SamB> @hoogle (%)
20:24:03 <lambdabot> Did you mean: (%)
20:24:03 <lambdabot> Prelude.undefined :: a
20:24:03 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
20:24:07 <SamB> @index (%)
20:24:07 <lambdabot> Data.Ratio
20:24:21 <awesame> but I don't know how to get a utf8 String into a ByteString
20:24:46 <SamB> well, Data.ByteString.Char8.pack would do it
20:24:51 <awesame> maybe I have to iterate calling ord to get Ints, then build a ByteString out of the Ints?
20:25:32 <SamB> @hoogle String -> ByteString
20:25:32 <lambdabot> Data.ByteString.Char8.pack :: String -> ByteString
20:25:37 <awesame> ahah!  Char8
20:25:43 <awesame> that's what I was looking for
20:25:44 <awesame> thanks
20:26:00 <paczesiowa> @seen dcoutts
20:26:01 <lambdabot> I saw dcoutts leaving #haskell-hac4, #haskell-soc, #gentoo-haskell, #haskell and #ghc 10h 25m 8s ago, and .
20:26:01 <SamB> same ByteString, different interpretation
20:31:35 <Zootal> I have a function, where I pass a list of list of Ints [ [Int] ]
20:31:50 <Zootal> And I recurse the function. How can I tell when I reach the end of the function?
20:31:53 <Zootal> This is what I'm doing:
20:31:53 <Zootal> refs5:: [[Int]] -> [(Int,Int)]
20:31:53 <Zootal> refs5 [][] = (0,0)
20:32:06 <mauke> that's invalid
20:32:07 <Botje_> uh. that's a compile error.
20:32:12 <Botje_> do you mean [[]] ?
20:32:29 <paczesiowa> or just []
20:32:29 <Zootal> no - it's a list of int lists
20:32:37 <mauke> Zootal: no, [] [] is two empty lists
20:32:43 <paczesiowa> :t []
20:32:43 <TSC> Depends on what "the end" is ; it might be [] or [[]] or something else
20:32:44 <lambdabot> forall a. [a]
20:32:44 <Zootal> hmm   [[]]...oh, I see...let me try that
20:32:47 <paczesiowa> :t [[]]
20:32:47 <lambdabot> forall a. [[a]]
20:32:58 <paczesiowa> > length [[]]
20:32:59 <lambdabot>  1
20:33:48 <s710b> isnt it [(0,0)] aswell?
20:34:06 <s710b> instead of (0,0)
20:34:10 <mauke> yes
20:34:28 <SamB> s710b: at least that would be a type error, not a (more or less) syntax error
20:34:55 <Zootal> oh, yeah...that is right...all my other functions return (Int,Int), but this one has to return a list of (Int,Int)
20:35:02 <Zootal> <sigh>....
20:36:06 <SamB> oh, in that case, perhaps you don't even want a (0,0) ?
20:36:10 <SamB> maybe just []?
20:36:38 <Zootal> can I retun [] if it's expecting (0,0)? That would make things easier
20:36:54 <Zootal> otherwise, I have to remove all of the (0,0) from my final resulting list, which isn't that difficult
20:36:55 <paczesiowa> maybe start with telling us what do you want to do
20:37:08 <Zootal> um...that is a long story....
20:37:39 <paczesiowa> how about few examples?
20:37:44 <Zootal> It's a school assignment, with a long list of requirements.
20:37:51 <Zootal> This particular function is passed
20:37:59 <Zootal> a list of list of Ints
20:38:13 <Zootal> and I simply parse them, form Int pairs (Int,Int) and return them
20:38:27 <Zootal> The length of the list is unknown, so I recurse it
20:38:29 <mauke> parse them how?
20:38:43 <Zootal> Oh, each list of Ints falls into one of two patterns
20:38:44 <paczesiowa> so [0,1,2,3] -> [(0,1),(2,3)] ?
20:38:58 <Zootal> [1,1,...] -> (0,0)
20:39:09 <Zootal> oops, that isn't right
20:39:29 <Zootal> [ [1], [n,n,n], [n,n,n] ] -> (0,0)
20:39:32 <Zootal> or
20:40:12 <Zootal> [ [2], [n,n], [n,n],.. ] ->[(n,n), (n,n), (n,n)...]
20:40:25 <Zootal> if that makes sense....it actually works, except I hit the end of the list
20:40:31 <mauke> no, it doesn't
20:40:32 <Zootal> and without a trap for the end of the list, it generates an error
20:40:45 <Zootal> oh...sorry...I didn't explain it very well - but that part works
20:40:50 <mauke> (0,0) and [...] don't even have the same type
20:41:14 <Zootal> [...] indicates an indeterminate number of [n,n] lists
20:41:33 <Zootal> anyhow...that part work....
20:41:39 <mauke> no, it doesn't
20:42:04 <Zootal> well, what I typed here isn't complete and may not work right - but the actual code does what I expect :)
20:44:17 <paczesiowa> someone should change channel topic
20:44:49 <SamB> @topic-tail
20:44:49 <lambdabot> Plugin `topic' failed with: Prelude.last: empty list
20:45:08 <SamB> @help topic
20:45:09 <lambdabot> topic provides: topic-tell topic-cons topic-snoc topic-tail topic-init topic-null
20:45:20 <paczesiowa> @topic-tell
20:45:20 <lambdabot> Plugin `topic' failed with: Prelude.last: empty list
20:45:41 <SamB> that plugin has been doing that forever, hasn't it?
20:46:10 <paczesiowa> that's why I hate head,tail,last and other partial functions
20:46:55 <SamB> Cale: are you a chanop?
20:47:00 <SamB> the topic is locked
20:48:25 --- mode: ChanServ set +o Cale
20:48:26 --- mode: Cale set -t
20:48:26 --- mode: ChanServ set +t
20:48:31 <Cale> uhh...
20:49:10 <vixey> /msg chanserv set #haskell mode -t
20:49:20 --- topic: set to '["The Haskell programming language" ,"http://haskell.org " ,"Paste: http://hpaste.org " ,"Logs: http://tunes.org/~nef/logs/haskell/"]' by Cale
20:49:36 --- mode: ChanServ set -t
20:49:41 --- mode: Cale set -o Cale
20:53:23 <SamB> I don't suppose any of you folks know how to build a working copy of trang in debian?
20:53:55 <gwern> what is trang?
20:54:03 <gwern> sounds like an extrastellar warlord
20:54:08 <SamB> I keep getting gcj ABI version mismatches
20:54:19 <SamB> even though I just built the damn thing!
20:54:35 <SamB> how is that even possible?
20:56:22 <joed> it was last updated 2003 something?
20:56:35 <SamB> joed: wasn't it 2004?
20:56:57 <joed> SamB: if you need a working one, I know openlaszlo has it.
20:57:01 <SamB> anyway, how can it be an ABI mismatch when I *JUST BUILT* the package?
20:57:19 <joed> I think it is in their thaiopensource.jar
20:57:43 <joed> Dunno, I stay away from gcj
21:00:10 <YourAlgebra> #dreamweaver
21:00:18 <YourAlgebra> sorry!
21:06:51 <dainanaki> could anyone tell me what's wrong with this now?
21:06:53 <dainanaki> optLittleC :: [FilePath] -> IO [FilePath]
21:06:53 <dainanaki> optLittleC list = do
21:06:53 <dainanaki> 	modTime <- mapM getModificationTime list
21:06:53 <dainanaki> 	let
21:06:54 <dainanaki> 		zipped = zip modTime list
21:06:56 <dainanaki> 		sorted = sortBy (compare . fst) zipped
21:06:58 <dainanaki> 	return (map snd sorted)
21:07:10 <newsham> ?paste
21:07:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:07:21 <Cale> :t compare . fst
21:07:23 <lambdabot> forall a b. (Ord a) => (a, b) -> a -> Ordering
21:07:40 <Cale> :t sortBy
21:07:41 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
21:07:50 <Cale> :t sortBy (compare . fst)
21:07:51 <lambdabot>     Occurs check: cannot construct the infinite type: a = (a, b)
21:07:51 <lambdabot>       Expected type: (a, b) -> (a, b)
21:07:51 <lambdabot>       Inferred type: (a, b) -> a
21:07:55 <Cale> :t sortBy (comparing fst)
21:07:56 <lambdabot> forall a b. (Ord a) => [(a, b)] -> [(a, b)]
21:08:07 <vixey> @src comparing
21:08:07 <lambdabot> Source not found. Wrong!  You cheating scum!
21:08:15 <dainanaki> oh right
21:08:20 <Cale> comparing p x y = compare (p x) (p y)
21:08:21 <vixey> comparing f = compare`on`f -- ?
21:08:31 <paczesiowa> @src on
21:08:31 <lambdabot> (*) `on` f = \x y -> f x * f y
21:08:35 <Cale> It's in Data.Ord
21:08:50 <paczesiowa> @info on
21:08:50 <lambdabot> on
21:08:57 <vixey> lol
21:09:05 <Cale> I wonder which module @info really is.
21:09:11 <Cale> @help info
21:09:12 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:09:30 <vixey> @help on
21:09:30 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:09:31 <Cale> @info join (+)
21:09:31 <lambdabot> join (+)
21:09:33 <Cale> @info join (+) 5
21:09:33 <lambdabot> join (+) 5
21:09:37 <Cale> not unpl
21:09:43 <Cale> @info \x y -> x + y
21:09:43 <lambdabot> \ x y -> x + y
21:09:45 <vixey> @info checking something
21:09:45 <lambdabot> checking something
21:09:51 <vixey> O_o
21:09:59 <Cale> @info do { x <- getLine; return (reverse x) }
21:09:59 <lambdabot> getLine >>= \ x -> return (reverse x)
21:10:01 <Cale> aha
21:10:03 <Cale> it's undo
21:10:26 <Cale> (the spell corrector is rather generous)
21:10:30 <Zootal> Here is a more basic question: Given a list of Ints: [Int]
21:10:39 <Zootal> head [1,2,3] gives 1
21:10:45 <Zootal> tail [1,2,3] gives 3
21:10:49 <Cale> no
21:10:54 <Cale> tail [1,2,3] gives [2,3]
21:10:54 <vixey> > tail [1,2,3]
21:10:58 <lambdabot>  [2,3]
21:11:00 <Zootal> Sorry...tail gives [2,3]
21:11:10 <Zootal> and I just answered my own question......
21:11:23 <Zootal> I want head( tail [1,2,3] )
21:11:29 <Cale> > [1,2,3] !! 1
21:11:30 <lambdabot>  2
21:11:47 <newsham> ?src (!!)
21:11:47 <lambdabot> xs     !! n | n < 0 = undefined
21:11:47 <lambdabot> []     !! _         = undefined
21:11:47 <lambdabot> (x:_)  !! 0         = x
21:11:47 <lambdabot> (_:xs) !! n         = xs !! (n-1)
21:11:54 <Zootal> yah. I realized the answer as I was typing the question. I should have asked before I spent 5 minutes staring at the screen....
21:13:04 <Zootal> huh...[1,2,3] !! 1...substr( var, 2, 1 )?
21:13:10 <vixey> no
21:13:22 <Zootal> what does !! do?
21:13:24 <vixey> substr is PHP or something not haskell
21:13:37 <vixey> > "lax" !! 0
21:13:37 <lambdabot>  'l'
21:13:38 <vixey> > "lax" !! 1
21:13:39 <lambdabot>  'a'
21:13:39 <vixey> > "lax" !! 2
21:13:40 <lambdabot>  'x'
21:13:41 <Cale> Zootal: !! indexes a list
21:13:50 <Zootal> I know - I was trying to equate [1,2,3] !! 1 with a function from another language
21:13:53 <Cale> ah
21:13:58 <vixey> that's not a good idea
21:13:59 <Cale> xs !! n is the nth element of xs, 0-indexed
21:14:05 <Zootal> Ahhh.... very handy, dang, I wish I would have known that 2 hours ago <sigh>
21:14:29 <paczesiowa> don't tell me you haven't written it yourself
21:14:37 <Zootal> I have a grand total of about 20 hours experience with Haskell
21:14:54 <bos> @seen dons
21:14:54 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc and #haskell. I last heard dons speak 12h 15m 16s ago.
21:15:45 <jsnx> i was so wrong to use C -- i could have used Data.Binary and Data.ByteString and made some elegant walker thingy and it would have been great
21:16:01 <jsnx> and now i have all this weird C code instead,
21:16:03 <jsnx> bleh
21:16:44 <newsham> live and learn
21:16:51 * bos frets over where to introduce monoids in the book.
21:17:15 <jsnx> in a monoid, all arrows have to be endofunctors, right?
21:17:43 <Cale> jsnx: hmm, by a monoid, you mean a one-object category?
21:17:53 <jsnx> Cale: yes, so...
21:18:11 <Cale> "endofunctors" perhaps isn't quite the word"
21:18:21 <jsnx> Cale: oh, why is that?
21:18:27 <dainanaki> ok so here's the part that's messed up
21:18:29 <Cale> but yeah, they have to have the same domain and codomain
21:18:36 <Cale> jsnx: That would imply they were functors.
21:18:43 <dainanaki> :t sortBy (compare . fst)
21:18:44 <jsnx> oh, got it
21:18:44 <lambdabot>     Occurs check: cannot construct the infinite type: a = (a, b)
21:18:44 <lambdabot>       Expected type: (a, b) -> (a, b)
21:18:44 <lambdabot>       Inferred type: (a, b) -> a
21:18:46 <Cale> jsnx: (which are mappings between categories)
21:18:53 <jsnx> i always get these things wrong
21:18:54 <dainanaki> how could I fix that?
21:19:00 <jsnx> Cale: thank you for correcting that
21:19:01 <bos> homomorphisms might be better.,
21:19:02 <Cale> jsnx: You might say that they were endomorphisms
21:19:16 <vixey> dainanaki: Cale just showed how a second ago
21:19:41 <bos> although i think not. a homomorphism could map from one monoid to another.
21:19:44 <bos> never mind me.
21:19:48 <jsnx> :t sortBy $ comparing fst
21:19:49 <lambdabot> forall a b. (Ord a) => [(a, b)] -> [(a, b)]
21:21:14 <dainanaki> okiedoke
21:21:15 <dainanaki> thanks
21:21:21 <dainanaki> I missed that the first time around
21:22:22 <newsham> > sortBy $ comapring fst $ map (\x -> length x, x) $ words "this is a test"
21:22:23 <lambdabot>   Not in scope: `comapring'
21:22:31 <newsham> > sortBy $ comparing fst $ map (\x -> length x, x) $ words "this is a test"
21:22:32 <lambdabot>  Couldn't match expected type `a -> b'
21:24:05 <dolio> > sortBy (comparing fst) . map (length &&& id) $ words "this is a test"
21:24:07 <lambdabot>  [(1,"a"),(2,"is"),(4,"this"),(4,"test")]
21:27:11 <Zootal> OK, here is another noobie question: I have a list of Int pairs:
21:27:24 <Zootal> [(1,1),(2,2),(3,3)]
21:27:43 <Zootal> How would I remove the (2,2) without knowing what position it is in?
21:28:01 <Cale> > [(1,1),(2,2),(3,3)] \\ [(2,2)]
21:28:02 <lambdabot>  [(1,1),(3,3)]
21:28:08 <Zootal> Ahhhhh....
21:28:09 <Cale> > delete (2,2) [(1,1),(2,2),(3,3)]
21:28:09 <lambdabot>  [(1,1),(3,3)]
21:28:17 <roconnor> @src delete
21:28:18 <lambdabot> delete = deleteBy (==)
21:28:20 <Cale> > filter (/= (2,2)) [(1,1),(2,2),(3,3)]
21:28:20 <lambdabot>  [(1,1),(3,3)]
21:28:23 <roconnor> @src (\\)
21:28:23 <lambdabot> (\\) = foldl (flip delete)
21:28:26 <Zootal> hmm...that lamdabot looks like it can be handy
21:28:37 <Cale> (note that the filter way is a bit different, since:
21:28:42 <Cale> > filter (/= (2,2)) [(1,1),(2,2),(3,3),(2,2)]
21:28:42 <lambdabot>  [(1,1),(3,3)]
21:28:49 <Cale> > delete (2,2) [(1,1),(2,2),(3,3),(2,2)]
21:28:50 <lambdabot>  [(1,1),(3,3),(2,2)]
21:29:01 <Cale> > [(1,1),(2,2),(3,3),(2,2)] \\ [(2,2)]
21:29:02 <lambdabot>  [(1,1),(3,3),(2,2)]
21:29:05 <Cale> > [(1,1),(2,2),(3,3),(2,2)] \\ [(2,2),(2,2)]
21:29:06 <lambdabot>  [(1,1),(3,3)]
21:29:14 <Zootal> I see. filter removes all instances, which is actually what I want
21:29:23 * Zootal goes off to try it.....
21:29:52 <paczesiowa> Zootal: take a look at http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html there are plenty of useful functions, if you don't know the list you will reimplement them unnecessary yourself
21:29:54 <lambdabot> http://tinyurl.com/wfo7q
21:30:20 <Zootal> ahh, I see it. tnx :)
21:55:42 <Zootal> concat [ [1],[2] ]
21:55:52 <Zootal> > concat [ [1],[2] ]
21:55:52 <lambdabot>  [1,2]
21:55:55 <Zootal> sweeeeet
21:59:34 <shachaf> Cale: Should \bot get rid of concat for join? :-)
21:59:58 <lament> > concat ["Hello, ", "world!"]
21:59:59 <lambdabot>  "Hello, world!"
22:01:25 <shachaf> > sequence (join [pure concat, return join]) ["a", "b"]
22:01:25 <lambdabot>  ["ab","ab"]
22:01:26 <sjanssen> shachaf: don't encourage him!
22:01:51 <shachaf> sjanssen: Why not? It has to start somewhere.
22:02:14 * sjanssen thinks it has already gone too far
22:02:33 <shachaf> "Fixing Haskell 98, one bot at a time."
22:02:55 <lament> shachaf: note that haskell prime seems to have no problems with these synonyms
22:03:36 <shachaf> lament: They might actually add that?
22:03:45 <shachaf> @where haskell'
22:03:45 <lambdabot> http://hackage.haskell.org/trac/haskell-prime
22:04:17 <lament> shachaf: i doubt it
22:05:26 <lament> it's not like generalizing all these functions accomplishes anything useful
22:05:43 <lament> you just get many ways to say exactly the same thing, which is stupid
22:05:59 <lament> and you lose some typechecking
22:09:30 <Cale> lament: The idea is actually to reduce the number of ways to say the same thing.
22:09:57 <Cale> lament: There are too many monomorphic specialisations of things in the libraries.
22:11:31 <lament> Cale: you can't throw them out. Backwards compatibility.
22:11:45 <dolio> Hah.
22:12:07 <dolio> H98 wasn't backwards compatible with H1.4 when it monomorphized all the stuff. :)
22:12:08 <Cale> We'll just edit old code to meet the new base libraries.
22:12:34 <lament> well
22:12:43 <lament> i'm all for throwing them out
22:12:56 <lament> but making them synonyms is silly
22:12:59 <Cale> At least for all the stuff in Hackage, this shouldn't be too hard to track down.
22:13:35 <Cale> The idea with (.) and map is that they should be the only names for functor application.
22:13:45 <Cale> (sometimes it's nice to have an infix one)
22:13:55 <sjanssen> Cale: do you remember how long it took to update all the packages for GHC 6.8
22:13:57 <sjanssen> ?
22:14:06 <jeffz> they're still being updated?
22:14:16 <Cale> sjanssen: It's doable.
22:14:22 <sjanssen> this took months -- and none of these changes were source changes -- just packaging changes
22:14:25 <sjanssen> Cale: sure
22:14:38 <sjanssen> but we can't do this incredibly often
22:14:42 <Cale> Especially if Hackage compiles everything and reports build errors.
22:14:58 <Cale> I'm not saying we should break the world every month or something.
22:15:04 <Cale> Maybe once every couple years?
22:15:13 <sjanssen> IMO, these changes should either happen in Haskell' or not at all
22:16:10 <Cale> My confidence level in Haskell' isn't so high at the moment
22:16:27 <sjanssen> yeah :(
22:16:41 <Cale> Haskell' is 1.6, when it should be 2.0
22:16:44 <sjanssen> though I do see patches from Simon M on that mailing list
22:17:45 <solrize> anyone look at dons' blog post about running shell commands from a haskell program?  it refers to a Process module that doesn't seem to exist?
22:17:48 <solrize> @hoogle run
22:17:48 <lambdabot> Control.Concurrent.runInBoundThread :: IO a -> IO a
22:17:48 <lambdabot> Control.Concurrent.runInUnboundThread :: IO a -> IO a
22:17:48 <lambdabot> Control.Arrow.runKleisli :: Kleisli m a b -> a -> m b
22:19:17 <solrize> is there a simple way to run a command and get the output?
22:20:32 <dolio> @hoogle runProcess
22:20:33 <lambdabot> System.Process.runProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> Maybe Handle -> Maybe Handle -> Maybe Handle -> IO ProcessHandle
22:20:53 <Cale> solrize: I'd probably get the HSH library.
22:21:19 <Cale> solrize: since it makes that sort of thing nice, as you don't have to worry so much about handles and so on.
22:21:30 <solrize> hmm
22:21:33 <solrize> hackage?
22:22:04 <solrize> the weird thing is dons' post indicates there's a Process module that has a nice interface, but System.Process doesn't have those calls and there doesn't seem to be anything that does
22:22:06 <solrize> @hoogle popen
22:22:06 <lambdabot> No matches found
22:22:09 <solrize> @hoogle system
22:22:09 <lambdabot> System.Cmd.system :: String -> IO ExitCode
22:22:09 <lambdabot> Distribution.System :: module
22:22:09 <lambdabot> System.Cmd.rawSystem :: String -> [String] -> IO ExitCode
22:22:30 <solrize> @hoogle pipe
22:22:31 <lambdabot> Foreign.C.Error.ePIPE :: Errno
22:22:31 <lambdabot> Foreign.C.Error.eSPIPE :: Errno
22:22:46 * solrize looking at hsh
22:23:16 <Cale> "This code uses the Process module, a small wrapper over System.Process."
22:23:37 <solrize> oh i see
22:23:39 <Cale> You would have to ask him what that was :)
22:23:50 <solrize> http://www.cse.unsw.edu.au/~dons/code/cpuperf/Process.hs
22:23:52 <solrize> there's a link
22:23:55 <solrize> thanks
22:23:57 <Cale> aha
22:23:58 <solrize> i had missed that
22:32:15 <Zootal> Is there a quick and easy way to take two lists,
22:32:28 <Zootal> and remove from the first list any matching entries that exist in the second list?
22:33:19 <bos> twiddle first second = filter (`notElem` second) first
22:33:33 <Zootal> twiddle?
22:33:46 <bos> every program needs a function named twiddle.
22:33:53 <Zootal> oh, lol
22:35:00 * Zootal goes off to play with this....
22:35:05 <mrd> i use'frob'
22:38:53 <hpaste>  solrize pasted "set the computer's time" at http://hpaste.org/6934
22:39:01 <solrize> whee, i did something useful with haskell
22:40:26 <Cale> :)
22:41:27 <Zootal> bos: Dang - that works sweet!
22:41:35 <RickedRoger> Check out my ad! http://atlanta.craigslist.org/tag/638144159.html (quick before they flag!)
22:41:36 * Zootal has sooo much to learn....<sigh>
22:41:37 <lambdabot> Title: Nintendo Wii
22:41:49 <solrize> hey bos, your regexp chapter is indispensible
22:41:57 --- mode: ChanServ set +o bos
22:42:22 --- mode: bos set +b *!*n=asefg@207.138.47.*
22:42:22 --- kick: RickedRoger was kicked by bos (bos)
22:42:33 <bos> solrize: cool!
22:43:00 <bos> it's a shame that it's indispensable, really. the regexp API is awful.
22:43:06 --- mode: bos set -o bos
22:43:17 <geezusfreeek> anybody know if there happens to be an operator somewhere defined for mappend already? i see a lot of `mappend` in my near future
22:43:36 <geezusfreeek> it seems that hoogle is being too weird to really help me
22:43:39 <mrd> ++ !
22:43:40 <solrize> it's clever as hell, which i guess is orthogonal to being awful.  it's unusable from the regular doc but the book chapter explains it pretty well
22:43:47 <geezusfreeek> ++ really?
22:43:50 <geezusfreeek> wow, i lose
22:43:53 <bos> geezusfreeek: no, there isn't.
22:43:58 <geezusfreeek> darn
22:44:09 <solrize> @hoogle mappend
22:44:09 <lambdabot> Data.Monoid.mappend :: Monoid a => a -> a -> a
22:44:14 <Cale> geezusfreeek: I did that to (++) in lambdabot :)
22:44:35 <geezusfreeek> i really wish (++) was mappend. that would be sexy
22:44:36 <bos> solrize: the problem is that it is completely non-sticky.  i have to read my own damn tutorial every time i want to use a regexp in anything other than the most basic context.
22:44:44 <solrize> nod
22:45:10 <Cale> geezusfreeek: You can import the Prelude and Data.List hiding (++), and then redefine (++) yourself, as a holdover until we get some polymorphism fanatics into a standarisation committee.
22:45:15 <Cale> d*
22:45:19 <geezusfreeek> yuck :)
22:45:23 <solrize> brb
22:45:56 <geezusfreeek> whenever that happens let's remember to fix map/fmap as well :P
22:45:58 <bos> i've nothing against return-type polymorphism, but the return type of =~ should have no more than about two possible candidates.
22:46:17 <bos> two, give or take zero.
22:46:32 <geezusfreeek> actually, that would be map/fmap/(<$>)
22:46:45 <Cale> bos: It would be okay to be that polymorphic if the return types were real datatypes, and not just compositions of various existing types.
22:47:12 <Cale> bos: That way the datatype you used would express more clearly what you were asking for, and the documentation would be clearer.
22:47:35 <Cale> geezusfreeek: don't forget (.)
22:47:40 <Cale> geezusfreeek: It's fmap too :)
22:47:56 <Cale> and there's liftM and liftA
22:48:00 <solrize> having to use explicit annotation did seem a bit ugly, as did having to use the 4-tuple return just to get the groups out (unless i missed something)
22:48:09 <geezusfreeek> :t (.)
22:48:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:48:11 <bos> Cale: yes.
22:48:20 <geezusfreeek> oh jeez
22:48:21 <Cale> geezusfreeek: hehe, in lambdabot it *really is* fmap :)
22:48:34 <mrd> lambdabot, what a rebel
22:48:34 <geezusfreeek> lambdabot cheats!
22:48:54 <Cale> geezusfreeek: The functor in question is the partial application: (->) e
22:49:02 <geezusfreeek> right
22:49:06 <Cale> So you get  (a -> b) -> (e -> a) -> (e -> b)
22:51:39 <geezusfreeek> well now you got me wanting to use (.) instead of (<$>)!
22:52:59 <geezusfreeek> i guess the lower precedence of (<$>) is still too useful to give up like that though
22:57:18 <Trinithis> @src Data.Monoid.mappend
22:57:18 <lambdabot> Source not found. You untyped fool!
22:57:45 <geezusfreeek> Trinithis: it's a function of the Monoid type class
22:57:56 <geezusfreeek> it has many definitions :)
22:58:20 <Trinithis> oh. and basically ++ is the list instance of it?
22:58:24 <geezusfreeek> yes
22:58:37 <Trinithis> ty
22:59:00 <s710b> when i try to install the Process package, i get this error: /usr/local/lib/ghc-6.8.2/lib/Cabal-1.2.3.0/HSCabal-1.2.3.0.o: unknown symbol `processzm1zi0zi0zi0_SystemziProcessziInternals_a14_info'
23:00:01 <s710b> does somebody know what it means?
23:01:02 <Heffalump> hi ChilliX_!
23:01:23 <Cale> s710b: It means that you should compile with --make ;)
23:01:48 <Cale> s710b: More precisely, it means that you need the process package. You could also use -package process to specify that.
23:01:54 <Cale> er...
23:01:56 <geezusfreeek> such a confusing error message for such a simple solution
23:01:59 <Cale> wait...
23:02:13 <Cale> You're installing the process package and getting an error like that?
23:02:21 <Cale> hmmm
23:02:24 <s710b> hm, i downloaded the package from hackage
23:02:59 <s710b> after 'runghc Setup.hs configure' the error occurs
23:03:22 <Cale> Very odd...
23:03:45 <s710b> also: " unable to load package `Cabal-1.2.3.0'"
23:04:08 <Cale> ah, if you  ghc-pkg list Cabal, what do you get?
23:04:20 <Cale> Does it find it?
23:04:43 <s710b> yeah
23:04:50 <s710b> /usr/local/lib/ghc-6.8.2/package.conf:
23:04:52 <s710b> Cabal-1.2.3.0
23:05:17 <Cale> hmm, okay
23:06:31 <s710b> Cale, well, not that important for now, just wanted to try solrize's program
23:06:41 <Cale> s710b: that's a really odd error though
23:06:59 <Cale> also, usually the process package comes with ghc
23:07:02 <solrize> i didn't install it, i just downloaded it into the same directory where the script was, and imported it
23:07:10 <solrize> cale, there's System.Process which is different
23:07:20 <solrize> it's really silly that the core lib doesn't come with something like "popen"
23:07:22 <Cale> solrize: Yeah, the process package contains System.Process
23:07:32 <Cale> solrize: and it usually comes with ghc
23:07:54 <solrize> System.Process does not contain a function like don's module's "run" func
23:08:32 <Cale> Yeah, it's pretty deficient.
23:08:51 <Cale> Really, something like HSH coming with GHC would be way cooler :)
23:09:26 <Cale> http://hackage.haskell.org/packages/archive/HSH/1.2.6/doc/html/HSH.html
23:09:30 <lambdabot> http://tinyurl.com/5olmj5
23:11:30 <solrize> i guess so.  but even HSH didn't seem to have something as simple to use as don's module
23:11:53 <solrize> i think haskell is just starting to ramp up in terms of having easy to use libraries like this
23:13:57 <awesame> is reverse O(n)?
23:14:34 <Twey> @src reverse
23:14:34 <lambdabot> reverse = foldl (flip (:)) []
23:14:44 <shachaf> awesame: It's )n(O, actually.
23:14:45 <Twey> awesame: Yes
23:14:51 <Twey> shachaf: Haha
23:15:00 <awesame> shachaf: ha
23:15:23 <Cale> solrize: uh, it's even easier :)
23:15:56 <Cale> Or, well, just as easy :)
23:15:57 <awesame> yeah, so that says, recurse down the list to the end, then start returning flipped conses back up the stack
23:16:09 <Cale> solrize:  run "foo" :: IO String
23:16:37 <Cale> awesame: right
23:16:38 <solrize> oh, neat :)
23:17:06 <Cale> solrize: except that with HSH, you can also construct shell pipelines with -|-
23:17:22 <awesame> which I guess is faster than foo (x:xs) = xs ++ [x]
23:17:23 <Cale> run $ "foo" -|- "bar" -|- "baz"
23:17:32 <solrize> why not just run "foo | bar" :: IO String    ?
23:17:58 <Cale> Because not only strings can be combined with -|- but haskell functions can be stuck in there as well
23:18:14 <awesame> er, foo (x:xs) = foo xs ++ [x]
23:18:18 <Cale> run $ ("ls", ["-l"]) -|- countLines -|- filter (isSuffixOf "hs")
23:18:20 <Twey> Oohhhh
23:18:25 <Twey> That's *nice*
23:18:49 <Deewiant> HSH apparently doesn't support Windows though
23:18:54 <solrize> oh neat, it figures that out from the types?
23:19:01 <Cale> solrize: yeah, typeclasses :)
23:19:07 <solrize> uhmmmm, hmmm.
23:19:23 <solrize> it sort of gets away from what i think of as a statically typed language...
23:19:47 <Twey> solrize: Your definition is too limited then :-P
23:19:52 <Cale> That's because you're used to statically typed languages with impoverished type systems :)
23:19:54 <Twey> It's still safe
23:20:02 <mlh_> now to make it less ugly by trapping undefined args and automatically invoke the command :-)
23:20:18 <mlh_> s/args/functions/
23:20:35 <awesame> haskell is really good at feeling like a dynamicly typed language most of the time
23:20:44 <Twey> Can qualified operators still be used infix?
23:20:50 <awesame> except for when it catches bugs for you
23:21:05 <Twey> "a" MyModule.++ "b"
23:21:06 <lament> awesame: you must have never used fromIntegral
23:22:07 <Cale> Twey: yep
23:22:13 <awesame> lament: okay, guilty
23:22:20 <Twey> Heh
23:22:22 <Twey> Cale: Thanks
23:22:26 <Cale> Twey: It's ugly as sin, but it can be done :)
23:22:29 <Twey> Yeah :-P
23:22:51 <Twey> Uglier if it were "a" `MyModule.(++)` "b" :-)
23:23:00 <Cale> I think it's made even worse by the fact that . is the module path separator.
23:23:17 <Twey> Well, Haskell is kind of greedy for punctuation.
23:23:36 <Cale> If I got to choose, I would have picked |
23:23:51 <opqdonut> :: would've been nice too
23:23:56 <opqdonut> except it's used for everything else
23:23:58 <opqdonut> :P
23:23:59 <Twey> What does | do normally?
23:24:02 <Twey> opqdonut: Yeah :-P
23:24:10 <Cale> Be parts of other syntax -- guards mostly.
23:24:13 <opqdonut> well | is syntax in case
23:24:14 <Twey> Oh, of course
23:24:15 <opqdonut> and guards
23:24:15 <opqdonut> yeah
23:24:17 <geezusfreeek> is (-|-) another operator for mappend? :P
23:24:19 <Twey> D'oh
23:24:26 <Cale> geezusfreeek: Not the right type
23:24:32 <geezusfreeek> darn
23:24:34 <solrize> laterz
23:24:35 <Cale> geezusfreeek: It's way too polymorphic for that.
23:24:56 <awesame> lament: what's so weird about fromIntegral?  do you just mean the context-declaring stuff you have to do with functions like this, and e.g. read?
23:25:07 <geezusfreeek> i wasn't really paying attentionâ€¦ i just saw something that looked like an associative operation and jumped at it
23:25:16 <Cale> awesame: The fact that you have to explicitly convert between numeric types.
23:25:29 <Cale> awesame: (which is good but very different from most dynamically typed languages)
23:25:58 <Cale> geezusfreeek: It's a good guess. If it were restricted to only putting together shell commands, it would work.
23:26:13 <dolio> It's different from most statically typed languages. :)
23:26:23 <Cale> dolio: really?
23:26:23 <dolio> At least, the popular ones.
23:26:32 <Cale> hmm
23:26:35 <awesame> hm, I think maybe I do that kind of thing in python anyway
23:26:39 <dolio> C, C++, Java all auto-promote.
23:26:53 <awesame> > 1.5 + 3
23:26:54 <lambdabot>  4.5
23:27:12 <Cale> awesame: that's a bit different, as 3 is a polymorphic literal
23:27:34 <Cale> awesame: and the context is forcing it to become a Double
23:27:40 <Cale> > 1.5 + (3 :: Integer)
23:27:40 <lambdabot>   add an instance declaration for (Fractional Integer)
23:27:59 <Cale> So there are some subtle points here :)
23:28:01 <geezusfreeek> well, C and C++ auto-demote as well, which just makes me gag
23:28:03 <dolio> I suppose that's not really most statically typed languages. But it accounts for a lot of the use.
23:28:05 <awesame> I see
23:28:26 <geezusfreeek> actually i think most C++ compilers don't do that anymore
23:28:31 <awesame> I think anywhere much more complicated than that, I do explicit conversions in all languages
23:29:21 <Cale> > mean xs = sum xs / length xs -- this doesn't work because length has a stupid type
23:29:21 <lambdabot>  Parse error at "=" (column 9)
23:29:33 <Cale> er, didn't mean that as a >  :)
23:29:54 <Cale> > let mean xs = sum xs / length xs in mean [1,2,3]
23:29:55 <lambdabot>   add an instance declaration for (Fractional Int)
23:29:55 <lambdabot>     In the expression: sum...
23:29:55 <awesame> :t length
23:29:56 <lambdabot> forall a. [a] -> Int
23:30:03 <Cale> > let mean xs = sum xs / genericLength xs in mean [1,2,3]
23:30:03 <lambdabot>  Couldn't match expected type `[b] -> a'
23:30:07 <shachaf> Of course: length should always return a Double. :-)
23:30:21 <Cale> er...
23:30:28 <shachaf> s/:/;/
23:30:56 <Cale> hmm... what's going on there?
23:31:01 <Cale> > let mean xs = sum xs / genericLength xs in mean [1,2,3]
23:31:01 <lambdabot>  2.0
23:31:07 <Cale> ... okay.
23:31:31 <Cale> Computers are strange sometimes.
23:31:45 <dolio> lambdabot is becoming senile.
23:31:49 <Twey> Haha
23:31:50 <geezusfreeek> whaâ€”?
23:31:57 <geezusfreeek> > let mean xs = sum xs / genericLength xs in mean [1,2,3]
23:31:58 <lambdabot>  2.0
23:32:09 <shachaf> It's all because of Cale's additions.
23:32:28 <Cale> heh
23:33:00 <Cale> It might have something to do with the way that I centralised the import declarations.
23:33:26 <awesame> :t genericLength
23:33:27 <lambdabot> forall b i. (Num i) => [b] -> i
23:33:56 <Cale> (which makes use of the C preprocessor, and is a bit hacky, due to the need to pump input into GHCi half the time, and build compiled files the other half)
23:34:04 <awesame> ugh, s/length/genericLength/plz
23:34:23 <Cale> Int is stupid, and should be moved out of the Prelude.
23:34:29 <Trinithis> what exactly is the (-|-) operator?
23:34:33 <Twey> Where is genericLength defined?
23:34:37 <Cale> It's usually a premature optimisation.
23:34:42 <Cale> Twey: Data.List
23:34:45 <Twey> Ah, thanks
23:34:52 <Cale> Trinithis: It's from HSH, it builds shell pipelines.
23:35:02 <Cale> http://hackage.haskell.org/packages/archive/HSH/1.2.6/doc/html/HSH.html
23:35:04 <lambdabot> http://tinyurl.com/5olmj5
23:35:06 <awesame> I assume Num can even provide a default implementation of genericLength based on other stuff you have to define anyway
23:35:08 <Cale> (that has some examples)
23:35:22 <Cale> Oh, of course
23:35:32 <Cale> genericLength has the exact same definition as length
23:35:40 <Cale> But it has a different type signature.
23:35:51 <Cale> (actually that's not quite true in GHC)
23:36:02 <Twey> @pl \x -> a x / b x
23:36:02 <lambdabot> liftM2 (/) a b
23:36:20 <Cale> Yes, I could have used liftM2 :)
23:36:58 <Cale> Or do notation, just for kicks
23:37:02 <Twey> Heh
23:37:08 <Twey> I was just curious
23:37:21 <Cale> > (do s <- sum; n <- genericLength; return (s/n)) [1,2,3]
23:37:21 <lambdabot>  2.0
23:37:27 <Twey> Nice :-P
23:37:36 <Twey> Which monad is that?
23:37:40 <Cale> (->) e
23:37:41 <Trinithis> is there documentation (or w/e) on the (->) monad?
23:37:45 <Twey> Ah
23:37:55 <Cale> (well,  (->) [Integer] )
23:38:10 <Cale> er, [Double] rather :)
23:38:43 <Trinithis> or at least some place where I could learn more about (->)
23:38:48 <Cale> Trinithis: The basic idea is that "running" a function is just applying it to the argument which the computation as a whole has been applied to
23:39:14 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
23:39:15 <lambdabot>  ("hello","olleh","HELLO")
23:39:32 <Cale> So x is obtained from id by applying it to "hello"
23:39:44 <Cale> and then y is obtained from reverse by applying reverse to "hello"
23:39:46 <Cale> and so on
23:39:53 <Trinithis> ok
23:40:03 <Cale> The definitions of return and bind reflect that.
23:40:17 <Cale> (It might be a good exercise to try to figure them out :)
23:40:29 <Cale> join and fmap are easier though
23:40:40 <Cale> well, return is easy :)
23:40:57 <Cale> If you think about the types, there's only one way to define things.
23:40:59 <Trinithis> > return "hello" >>= reverse
23:41:00 <lambdabot>  "olleh"
23:41:09 <Trinithis> > return "hello" >>= reverse >>= reverse
23:41:09 <lambdabot>  Couldn't match expected type `Char' against inferred type `[a]'
23:42:16 <Cale> Wait, let's think about which monad that would have to be :)
23:42:41 <Cale> The second parameter to >>= is a function of type a -> m b
23:42:45 <Cale> :t reverse
23:42:46 <lambdabot> forall a. [a] -> [a]
23:42:52 <Cale> So that would be the list monad.
23:43:25 <Trinithis> :t (>>=)
23:43:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
23:43:33 <Cale> > (return "hello" >>= \k -> (k ++)) " world!"
23:43:34 <lambdabot>  "hello world!"
23:44:19 <Trinithis> :t return "" >>= reverse
23:44:20 <lambdabot> [Char]
23:44:51 <dancor> why does hs_init (in HsFFI.h) take  char **argv[]  ? doesn't that mean a static number of string pointers?  shouldn't it take char *argv[], like main?
23:45:00 * dancor exposes his c noobery
23:45:12 <Trinithis> oh i feel dumb. the whole (->) thing threw me off and made me think i was dealing with the (->) monad
23:45:29 <Cale> dancor: It wants a pointer to your argv, so it can modify it.
23:46:40 <Cale> Trinithis: it's okay :) I was thrown off for a moment as well.
23:47:05 <Cale> Trinithis: return :: a -> m a
23:47:11 <Cale> and here m = (->) e
23:47:25 <Cale> So,  return :: a -> (->) e a
23:47:29 <Cale> Which is,
23:47:34 <Cale> return :: a -> (e -> a)
23:47:42 <Cale> What function has that type? :)
23:48:32 <Cale> If section syntax were allowed at the type level, calling this monad (e ->) would be much easier to follow.
23:50:24 <Trinithis> what do you mean by 'what function has that type'?
23:50:50 <Cale> What function has the type I just suggested that return should have in the (e ->) monad?
23:51:09 <Cale> (apart from return, of course ;)
23:51:32 <Cale> a -> (e -> a)
23:51:38 <Cale> We could ask djinn...
23:51:48 <Cale> @djinn a -> (e -> a)
23:51:48 <lambdabot> f a _ = a
23:51:49 <Trinithis> hold on maybe ill get it
23:51:58 <Trinithis> :t const
23:51:59 <lambdabot> forall a b. a -> b -> a
23:52:04 <Cale> exactly :)
23:52:13 <Trinithis> what is const used for?
23:52:20 <Cale> Making constant functions
23:52:42 <Cale> You give it a value, and it gives you a function which always gives that value, regardless of the input.
23:53:29 <Cale> Of course, you could always use a lambda which doesn't use its bound variable, but sometimes writing const looks nicer.
23:53:49 <Cale> > filterM (const [True, False]) [1,2,3]
23:53:49 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
23:54:19 <Trinithis> > filterM (const [True]) [1,2,3]
23:54:19 <Cale> (that effectively says "for each element of the list, regardless of what it is, keep it or drop it")
23:54:19 <lambdabot>  [[1,2,3]]
23:54:27 <Trinithis> > filterM (const [False]) [1,2,3]
23:54:27 <lambdabot>  [[]]
23:54:51 <Cale> > filterM (\x -> if even x then [True, False] else [True]) [1,2,3]
23:54:52 <lambdabot>  [[1,2,3],[1,3]]
23:55:14 <Trinithis> @hoogle filterM
23:55:15 <lambdabot> Control.Monad.filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
23:55:44 <Cale> Do you understand that last output from filterM?
23:56:07 <Cale> The function I supplied basically says "if it's even, then keep it or drop it, otherwise, keep it."
23:56:31 <Cale> That's the list monad
23:56:52 <Trinithis> i see
23:57:06 <Trinithis> really neat
23:58:08 <Cale> So, back to the (e ->) monad, let's look at join
23:58:18 <Cale> join :: (Monad m) => m (m a) -> m a
23:58:44 <Cale> So in this case, we have  join :: (e -> e -> a) -> (e -> a)
23:58:56 <Trinithis> mm
23:59:08 <Cale> It takes a function of two parameters of the same type and turns it into a function of one parameter
23:59:41 <Cale> Or, it takes a function (e -> e -> a), and a value of type e, and produces a value of type a somehow :)
23:59:55 <Cale> Clearly there are not many options for how this has to work.
