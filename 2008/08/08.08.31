00:07:57 <dons> anyone else miss the fact hbi let us define anything top level at the interpreter prompt?
00:08:10 <dons> maybe we can do an alternative ghci, called 'ghbi', using ghc-api
00:08:19 <dons> to implement hbi's top level interpreter semantics.
00:08:25 <dons> augustss: whaddya think?
00:14:52 <mmorrow> dons: wow, what is hbi??
00:15:35 <dons> hbc's interpreter
00:15:41 <ivanm> so hbi was a "real" haskell repl?
00:15:56 <dons> sure
00:16:02 <ivanm> :o
00:16:28 * mmorrow is downloading http://haskell.org/hbc/hbc-2004-06-29.src.tar.gz now
00:16:46 <dons> i should write something about it.
00:17:17 <mmorrow> dons: i think being able to define eg data A = A | B at the ghci> would be friggin awesome
00:17:21 <ivanm> looks like it isn't cabalized, strangely enough ;-)
00:17:29 <dons> it needs lazy ml to build :)
00:17:33 <mmorrow> ivanm: heh, read about it here
00:17:36 <dons> but you can get linux binaries from a build in 2004.
00:17:39 <mmorrow> lazy ml??!!
00:17:42 <mmorrow> crap
00:17:48 <mmorrow> ahh,
00:17:49 <dons> take that, bitches.
00:17:54 <mmorrow> heh
00:18:00 <ivanm> dons: so have you made a pkgbuild for it? :p
00:18:07 <dons> hehe. actually, that's not a bad idea.
00:18:08 * mmorrow is downloading http://haskell.org/hbc/hbc-2004-06-29.bin-i386-linux.tar.gz
00:18:12 <dons> yeah, that's it.
00:18:31 <ivanm> what compiler does it need? any old ml or specifically lazy ml?
00:18:41 <mmorrow> ivanm: uh, i meant read about it here: http://www.haskell.org/haskellwiki/Implementations#HBI_and_HBC.2C_Chalmers.27_Haskell_Interpreter_and_Compiler
00:18:44 <dons> lazy ml. for real.
00:18:44 <lambdabot> Title: Implementations - HaskellWiki, http://tinyurl.com/go4x3
00:18:57 <ivanm> mmorrow: lol
00:19:37 <ivanm> well, I've got a choice of SMLs, but no lazy ml by the looks of things :s
00:20:42 <dons> $ hbi
00:20:42 <dons> Welcome to interactive Haskell98 version 0.9999.5c Pentium 2004 Jun 29!
00:20:42 <dons> Loading prelude... 1 values, 4 libraries, 200 types found.
00:20:42 <dons> Type "help;" to get help.
00:20:42 <dons> > data T a = T Int [a] deriving Show;
00:20:44 <lambdabot>  mueval: Prelude.read: no parse
00:20:44 <dons> data T b = T Int [b] deriving (Show)
00:20:47 <dons> > T 7 "haskell";
00:20:48 <lambdabot>  mueval: Prelude.read: no parse
00:20:49 <dons> T 7 "haskell"
00:21:01 <ivanm> 0.9999.5c? another one of those apps that never reached 1.0?
00:21:16 <rwbarton> ivanm: nah, it's a pentium floating-point bug
00:21:19 <ivanm> dons: is there any particular reason you know of that ghci and hugs can't do that?
00:21:21 <ivanm> rwbarton: lol
00:21:35 <dons> i don't know of a reason.
00:22:45 <mmorrow> ivanm: it looks like there's a lazyml compiler included in that tarball for the hbc binary
00:22:47 <dons> if hbi can do it.
00:22:55 <ivanm> mmorrow: hmmm...
00:24:32 <dons> oh, that's sad, i lost my hbc performance graph
00:27:19 <Axman6> hbc?
00:27:43 <b\6> how does matching several things but discarding them look in parsec using applicative style? like match a, match but discard b c d e f. maybe you're only interested in the first of several space delimited fields but want to make sure the record is sane.
00:29:48 <chrisdone> lookAhead?
00:30:19 <mmorrow> oh snap
00:30:21 <mmorrow> [m@ganon hbi]$ hbi
00:30:21 <mmorrow> Welcome to interactive Haskell98 version 0.9999.5c Pentium 2004 Jun 29!
00:30:21 <mmorrow> Loading prelude... 1 values, 4 libraries, 200 types found.
00:30:21 <mmorrow> Type "help;" to get help.
00:30:21 <mmorrow> >
00:30:26 <dons> rocking!
00:30:51 <dons> ok. now write a list of all the ways hbi is so cool.
00:30:57 <dons> then we hack ghc-api to do the same.
00:31:11 <mmorrow> excellent
00:31:49 <chrisdone> b\6: http://haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec-Combinator.html#v%3AlookAhead
00:31:50 <ivanm> dons: and then we take over the world?
00:31:52 <lambdabot> Title: Text.ParserCombinators.Parsec.Combinator, http://tinyurl.com/2jrz2m
00:31:56 <mmorrow> > data A = A | B deriving(Show);
00:31:56 <mmorrow> data A = A | B deriving (Show)
00:31:56 <mmorrow> > A;
00:31:56 <mmorrow> A
00:31:59 <lambdabot>  mueval: Prelude.read: no parse
00:31:59 <lambdabot> Terminated
00:33:18 <chrisdone> mmorrow: niiice
00:33:21 <dons> ivanm: of course.
00:33:37 <b\6> chrisdone: meaning more like a <* b saves a, discards b. but how to do like a <* (b c d)?
00:33:40 <mmorrow> chrisdone: checkitout http://haskell.org/hbc/hbc-2004-06-29.bin-i386-linux.tar.gz
00:40:08 <chrisdone> b\6: is that parsec2?
00:40:40 <b\6> chrisdone: yeah, new school applicative style instead of normal do notation.
00:40:54 <chrisdone> ah, nice. I was confused for a moment there
00:41:34 <chrisdone> or parsec3? I can't remember
00:41:39 <jeffz> parsec3 is the new one
00:41:46 <chrisdone> ah
00:42:49 <chrisdone> I translated a PEG grammar to parsec to parse lojban words and it was slow as hell
00:43:02 <chrisdone> hopefully I can either make Frisby less cumbersome to use or try out parsec3
00:44:47 <chrisdone> unless I've done some major mistake in my parsec code. do you guys spot anything that you just /don't do/ in parsec? http://paste.lisp.org/display/66115
00:48:36 <ddarius> chrisdone: You are using try quite a lot.
00:48:46 <psyklops_> 
00:50:21 <chrisdone> ddarius: hm. I will try to reduce the number of try uses
00:53:53 <ddarius> If you are representing PEG operators, you shouldn't need try much at all.
00:56:38 <b\6> stuff like multiline smtp responses end with a line like ".\r\n". but previous lines can contain '.'. if i say a response looks like many lines followed by terminator, not sure how to deal with the overlap.
01:01:42 <chrisdone> ddarius: so / requires try right? in “a / b”, if `a' consumes input and then fails, we want it to go to `b'.
01:08:49 <ddarius> chrisdone: Yes...
01:11:55 <yitz> > 1+1
01:11:57 <lambdabot>  2
01:12:38 <yitz> hi. nice to see that \bot is with us today.
01:21:42 <Axman6> dons: i didn't know Arch linux had such nice support for haskell. luckily it's one of the few (only?) distros that i don't hate
01:21:50 <b\6> i felt bad when lambdabot was missing and thought about dressing up as larndabot and just trying to watch and answer stuff as fast as i could.
01:22:55 <dons> hehe we have done that in the past
01:22:59 <dons> it can be fun but tiring
01:26:49 <yitz> b\6: let repeatM=sequence.repeat in(takeWhile(not.null).evalState(repeatM.State.splitAt$7))"qewrtyuiopasdfghjkl"
01:26:59 <yitz> quick
01:27:00 <b\6> ERRAR
01:27:11 <b\6> COMMEND FALED SARRY
01:27:23 <yitz> thread deleted
01:27:35 <b\6> TIMEOUT
01:27:59 <idnar> evalState, eek
01:28:16 <yitz> > let repeatM=sequence.repeat in(takeWhile(not.null).evalState(repeatM.State.splitAt$7))"qewrtyuiopasdfghjkl"
01:28:18 <lambdabot>      Failed to load interface for `State':
01:28:18 <lambdabot>       Use -v to see a list of the ...
01:28:24 <yitz> awww
01:29:06 <ziman> mislexed, you need a space between Space and the dot
01:29:06 <mmorrow> if anyone is looking for something to do, this game is probably one of the best of all time: http://www.dyson.co.uk/about/games/telescope.asp
01:29:07 <lambdabot> Title: The Dyson Telescope Game - Games
01:29:12 <ziman> *State
01:29:13 <ziman> :)
01:33:14 * chrisdone tries to think of a project for which aasamatingreceiptsty could be a name
01:33:16 <yitz> > let repeatM=sequence.repeat in(takeWhile(not.null).evalState(repeatM.State .splitAt$7))"qewrtyuiopasdfghjkl"
01:33:18 <lambdabot>  ["qewrtyu","iopasdf","ghjkl"]
01:33:30 <yitz> ziman: right
01:40:07 <chrisdone> ddarius: well, it doesn't parse everything properly now. but the bits it does parse are now instantaneous rather than taking five seconds for one word like “fu'ivla”. the lack of try is screwing something up somewhere, but when I include it, it's slow as hell. it's not very obvious to me right now. oh well, I'll get some sleep and examine the operators individually tomorrow
01:41:38 <chrisdone> bah, I'm going to dream about parsing now, I just know it
01:45:49 <mmorrow> chrisdone: ReadP-style parsers parse alternatives in parallel ==> breadth first as opposed to parsec's depth first
01:47:13 <yitz> chrisdone: I'm sure someone said this earlier, but when having try problems with Parsec the usual answer is - refactor. That's sometimes painful thought.
01:47:16 <yitz> though
02:42:13 <consolers> anyone point me to sqlite bindings and an application with code that deals with a sql db?
02:42:51 <jeffz> consolers: have you looked on hackage?
02:43:58 <consolers> (not yet. asked here first.)
02:44:44 <consolers> 1. is available
02:45:48 <jsnx> this looks like haskell
02:45:49 <jsnx> http://research.microsoft.com/users/lamport/pubs/pubs.html#lamport-howtowrite
02:45:51 <lambdabot> Title: The Writings of Leslie Lamport, http://tinyurl.com/4czcy
02:48:54 <consolers> hdbc is served from a gopher server!
02:50:53 <goltrpoat> so i'm getting that "cabal: recv: resource vanished (Connection reset by peer)" deal on cabal update that i've gotten on every platform ive tried it on
02:50:57 <Vq^> quux.org?
02:51:11 <goltrpoat> google says one other person has had that problem
02:51:21 <goltrpoat> and it wasn't resolved.
02:52:47 <goltrpoat> this happens on freebsd (machine's upstairs, girlfriend's sleeping, can't try it), and on linux.  this network has been up for ages, both machines have been up for ages.  haven't tried it on windows.
02:53:54 <goltrpoat> (network's been up for years, literally, not an issue there)
02:55:16 <goltrpoat> i can wget the file manually.
02:55:40 <goltrpoat> ideas?
02:56:18 <goltrpoat> looking at the code, it doesn't do anything special, so probably Network.HTTP that's at fault
02:56:44 <goltrpoat> but ive used that a fair bit (although, on windows), and it's given me no trouble whatsoever
02:57:02 <Vq^> have you tried tracing the network calls with strace?
02:57:19 <goltrpoat> i haven't.  sec.
02:58:30 <Vq^> writing small testprograms in C and Haskell and checking the syscalls with strace is probably the best strategy to isolate the error
02:58:49 <goltrpoat> good call.
02:58:54 <Vq^> (or truss on bsd)
02:59:43 <goltrpoat> looks like it gets an EAGAIN and decides to call it quits.
02:59:53 <goltrpoat> (from recv() i mean)
03:00:58 <goltrpoat> no im lying.  recv(3, 0xb7c7e2d0, 1000, 0)            = -1 ECONNRESET (Connection reset by peer)
03:03:22 <goltrpoat> i don't know much about http, is the server rejecting the useragent or something?  looks like Distribution.Client.mkRequest is composing it out of "cabal-install/" and something on the automake side
03:03:41 <Vq^> doesn't look like a http problem to me
03:05:12 <Vq^> and because you actually get that error from the syscall i think the difference has to be in some socket setting
03:05:33 <goltrpoat> strace says.. im doing a sendto() with a GET, this comes back with an EAGAIN, then there's a gettimeofday() cfor some reaosn, a select(), and then it all goes downhill with ECONNRESET etc.
03:06:16 <goltrpoat> er, pardon the typos, was looking in the other window while typing.
03:09:31 <Vq^> how about calls to socket and fcntl?
03:11:49 <goltrpoat> socket(PF_INET, SOCK_DGRAM (why??), IPPROTO_IP)
03:11:52 <Vq^> and what happens when you try wget with strace (im thinking maybe wget just retries an succeeds because of that)
03:12:04 <goltrpoat> i bet it retries and succeeds
03:12:13 <Vq^> DGRAM? is this really http?
03:12:33 <goltrpoat> yeah that makes no sense at all
03:12:46 <Vq^> no, that can't be right
03:13:09 <Vq^> i was a bit surprised about the sendto(2) call but DGRAM is certainly not right
03:14:00 <goltrpoat> let me hack together a Network.HTTP app and see what it does
03:14:04 <jeffz> why don't you just look at the library code
03:14:32 <goltrpoat> i did
03:14:49 <goltrpoat> went through cabal code and bits of http code, nothing seemed to jump out
03:15:08 <goltrpoat> like i said, ive used Network.HTTP before, worked fine
03:17:11 <goltrpoat> it's particularly wacky since cabal does nothing terribly special
03:17:29 <goltrpoat> sec, smoke
03:18:00 * EvilTerran hopes goltrpoat doesn't mean his computer is smoking
03:19:01 <Vq^> nah, it's probably just goltrpoat himself that caught fire
03:19:15 <consolers> I think `takusen' is the way to go. the source seems to be http://darcs.haskell.org/takusen -- the link at http://www.sqlite.org/cvstrac/wiki?p=SqliteWrappers points to a defunct sf project
03:19:16 <lambdabot> Title: Index of /takusen
03:20:25 <b\6> hope he has a backup. of his dna.
03:21:33 <b\6> i keep meaning to ask him why his machine is 'arkansas'.
03:22:10 <Vq^> goltrpoat: could it be the dns-lookup connection you're looking at?
03:22:52 <jeffz> from a quick glimpse at the library, it seems to catch and rethrow any error it encounters while sending the request
03:22:53 <Vq^> goltrpoat: if thats the case you should see a "sin_port=htons(53)" in the associated connect(2) call
03:24:48 <goltrpoat> there's a socket(PF_INIT, SOCK_DGRAM, IPPROTO_IP) from running strace on the get.hs example from Network.HTTP
03:25:02 <goltrpoat> but it's preceded by three socket() calls with SOCK_STREAM
03:25:24 <goltrpoat> that's three too many, but it does work.
03:25:36 <Vq^> sounds right
03:26:02 <Vq^> it should only be preceded by two calls to connect though
03:26:32 <Vq^> try running strace on wget and grep for ECONNRESET
03:26:58 <Vq^> it could just be faulty hardware and your other programs handle it better
03:27:16 <goltrpoat> nothing
03:27:27 <Vq^> :/
03:27:33 <goltrpoat> vlad@the-beast:~$ strace wget http://www.google.com >& test_wget.txt
03:27:33 <goltrpoat> vlad@the-beast:~$ cat test_wget.txt | grep ECONNRESET
03:27:33 <goltrpoat> vlad@the-beast:~$
03:27:34 <lambdabot> Title: Google
03:27:43 <jeffz> like I said, look at the library.
03:27:48 <goltrpoat> did.
03:28:01 <jeffz> yes and did you see that it just throws whatever exception it encounters?
03:28:11 <Vq^> jeffz: this is pretty lowlevel, he does actually receive a ECONNRESET from the OS
03:28:52 <Vq^> jeffz: where the other programs seemingly doesn't
03:29:31 <goltrpoat> the get.hs example doesn't either
03:29:36 <Vq^> goltrpoat: is it always reproducable? wget never gets ECONNRESET and get.hs always fails?
03:29:39 <goltrpoat> and it's literally the same code.
03:29:45 <goltrpoat> no, get.hs works fine.
03:29:55 <Vq^> does cabal always fail?
03:30:00 <goltrpoat> it's not a Network.HTTP issue, i don't think
03:30:00 <goltrpoat> yep
03:30:34 <Vq^> then the issue has to be connected with the peer cabal communicates with
03:30:45 <goltrpoat> no, i can access the peer.
03:31:03 <goltrpoat> (through anything but cabal install, that is)
03:31:06 <goltrpoat> er upgrade
03:31:08 <goltrpoat> er update.
03:31:10 <goltrpoat> jesus.
03:31:11 <agcorona> hello
03:31:13 <goltrpoat> long day, sorry.
03:31:26 <Vq^> agcorona: hello and welcome
03:31:29 <Saizan> the only fancy thing cabal does is trying to use the proxy configured in your system if there's one
03:31:32 <Vq^> goltrpoat: thats a bit weird :/
03:31:40 <goltrpoat> right, i did look at that, saizan
03:31:45 <goltrpoat> it doesn't hit that
03:32:11 <jeffz> goltrpoat: did you look at a network capture?
03:32:20 <agcorona> Haskell seems to me like Pascal in the 80s. You have quicker ways to do it. In Fortran, for example. But the good thing of Pascal at that time was that it was Beatiful, not that it was a faster way to get things done. He made us to think about the structure of the program
03:32:20 <Vq^> does cabal only use http?
03:32:35 <goltrpoat> i didn't, but look at the strace, i'm not sure there'd be much to look at.  i'll check it out, though.
03:32:41 <Vq^> agcorona: no it doesn't
03:32:52 <goltrpoat> vq:  it gets the package info via http.
03:32:58 <Vq^> goltrpoat: ok
03:33:08 <jeffz> goltrpoat: it might show why the connection is being closed or when exactly
03:33:16 <agcorona> ust like smalltalk afterwards. Haskell is just that, He will succeed because is beatiful, and , thus, it is addictive. allthout I don´t know if Haskell will succed in the present form
03:33:42 <goltrpoat> agcorona:  pascal was a dumbed down algol.
03:33:58 <agcorona> I hope so, this time. I think that the foundations of Haskell are so flexible that Haskell could mature without altering itself at the core.
03:34:02 <Vq^> agcorona: smalltalk is a better comparison i guess
03:34:06 <goltrpoat> not sure where the parallels lie.
03:34:22 * EvilTerran was forced to use a dumbed down pascal in first year at uni. that was painful.
03:34:31 <EvilTerran> oberon FTL
03:34:42 <Saizan> agcorona: except haskell can be as fast as C, if you optimize in the right places, and compilers are getting smarter :)
03:34:49 <goltrpoat> et:  with the OS and all?
03:34:56 <agcorona> because smalltalk created a new wave of programming languages.
03:35:01 <EvilTerran> not with the OS, thank fortune
03:35:05 <goltrpoat> hehe
03:35:19 <agcorona> Saizan: yes
03:35:32 <agcorona> I just read an article about how to incrementally add algebraic data types without recompilation and to discriminate different IO effects via the type system.
03:35:44 <EvilTerran> but i'm still pained by the thought that there's someone out there who'd willingly create a language where "", "foo", '', and 'foo' are all strings, but "a" and 'a' are characters
03:35:47 <goltrpoat> vq:  thanks a ton, i'll keep digging.  going to give up on this for tonight, getting tired
03:35:53 <EvilTerran> (different types)
03:35:57 <agcorona> http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf              winderful!
03:35:59 <lambdabot> Title: cache:http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf - Google  ...
03:36:27 <EvilTerran> also it's got no character escapes, null-terminated strings, uppercase keywords...
03:36:28 <goltrpoat> agcorona:  what do you mean "without recompilation?"
03:36:31 * EvilTerran shudders
03:36:36 <agcorona> I though that these two things were shortcomings never supassable in current Haskell, but that was not true!!. Haskell is wonderful.
03:37:12 <agcorona> goltrpoat: read the abstact of the article
03:37:20 <goltrpoat> ive read the paper, ive used the technique
03:37:43 <goltrpoat> i think you might be expecting more from it than what it actually does
03:37:50 <Saizan> you don't need to alter code which doesn't use the new variants
03:37:53 <agcorona> I mean to create  data  A= B b | C c     and, in other module, extend it with an additional  D d
03:37:54 <goltrpoat> right
03:38:01 <goltrpoat> ah sure.
03:38:51 <goltrpoat> it does push those problems into an arguably more painful area, but, good stuff nonetheless
03:38:53 <agcorona> goltrpoat: it means a lot for DSLs
03:38:53 <Vq^> by nesting datatypes?
03:39:15 <agcorona> It means no monolitic development of DSLs for example.
03:39:29 <agcorona> by extending the syntax
03:39:42 <agcorona> in additional modules
03:39:59 <agcorona> branching grammmars for different purposes and so on
03:40:02 <goltrpoat> i wrote a logic programming DSL that i eventually converted to swierstra's stuff, and honestly, it caused more problems than it fixed
03:40:22 <goltrpoat> but, de gustibus non est disputandum
03:40:29 <Saizan> Vq^: not really nesting, you write them in functor + fixpoint style, so you can compose functors with Either
03:40:47 <EvilTerran> Vq^, that paper's pretty readable - it'd probably be easier to read it yourself than to read our attempts to water it down :)
03:40:58 <Saizan> yeah
03:40:58 <goltrpoat> et:  definitely true.
03:41:19 <Saizan> edwardk's blog posts are nice too
03:41:28 <agcorona> And the solution for effect enforcement at the end of the article is very elegant and powerful
03:42:10 <agcorona> My doubt is if this last one is worth the pain
03:42:21 <Vq^> goltrpoat: whats "swierstra's stuff"?
03:44:20 <ivanm> the so-called "Richard Feynman" method of problem solving listed here sounds a lot like how to program haskell code: write down type sig, think very hard, write down code ;-) http://www.reddit.com/r/programming/comments/6yuct/ask_progit_how_do_you_come_up_withchoose_names/
03:44:23 <lambdabot> Title: Ask Progit: How do you come up with/choose names for your projects? : programmin ..., http://tinyurl.com/66afl4
03:44:26 <Saizan> Vq^: swierstra is the author of this paper
03:44:59 <Vq^> ah, i better just read it at once :)
03:45:12 <goltrpoat> yah you should.
03:45:34 <goltrpoat> it's a great paper, and a brilliant idea, it's just that i don't think it's as useful as people make it out to be
03:45:42 <agcorona> goltrpoat: what where the problems?
03:46:06 <goltrpoat> your instance declarations get huge, for one -- and not easy to write
03:46:32 <goltrpoat> in a DSL, i'll usually have a lot of classes, and it took me ages to rewrite the instances
03:46:57 <goltrpoat> types become hard to think about, in general.
03:47:30 <agcorona> maybe a new haskell extensión could simplify that, because i´m sure that some of the extension stuff is more repetitive and big than really complex
03:48:52 <agcorona> or a new compiler annotation
03:49:12 <agcorona> Just a wild speculation
03:49:42 <goltrpoat> i don't know if it's possible to do much work for the programmer here, since the idea is to move type summation into the type signature
03:49:52 <goltrpoat> so you still declare types and their properties in isolation
03:50:40 <goltrpoat> oh, another problem was that i kept getting the associativity confused, which results in a pageful of errors.  compiler support would do wonders there
03:51:27 <agcorona> I see
03:52:12 <agcorona> The effect enforcement part I think does not have these problems
03:52:20 <goltrpoat> looking back, i'd probably still use it for a logic DSL, but i'd write it very differently from the get go
03:53:04 <Saizan> they fownd better ways of defining (:>:), though
03:53:04 <goltrpoat> so maybe it's just me :)
03:53:13 <goltrpoat> oh?
03:54:24 <Saizan> goltrpoat: in the comments here, http://wadler.blogspot.com/2008/02/data-types-la-carte.html , eve if i've not looked much at the code
03:54:25 <lambdabot> Title: Wadler's Blog: Data Types a la Carte
03:54:54 <goltrpoat> i keep forgetting wadler has a blog
03:55:20 <agcorona> url?
03:55:29 <agcorona> ah, above
03:55:44 <goltrpoat> argh.  i spent some time trying to figure this out.
03:55:57 <goltrpoat> thanks a ton
03:56:13 <Saizan> np
03:56:59 <_zenon_> Who controls lambdabot for this channel?
03:56:59 <lambdabot> _zenon_: You have 1 new message. '/msg lambdabot @messages' to read it.
03:57:43 <goltrpoat> i think you might have your answer.
03:57:56 <_zenon_> mm
03:58:41 <goltrpoat> if lambdabot told you that it's self-aware -- don't trust it.
03:58:58 <_zenon_> hehe
04:02:18 <agcorona> Lambdabot is a self aware structure?
04:02:57 <goltrpoat> it's a single haskell'3000 record.
04:03:32 <goltrpoat> john titor coded it.
04:03:43 <agcorona> this his the name of inteligent beings in Cosmology jargon (Off topic)
04:13:47 <EvilTerran> @vixen are you a self-aware structure?
04:13:47 <lambdabot> i truely am
04:15:55 <ziman> @vixen are you a conscious structure?
04:15:55 <lambdabot> i truely am
04:17:46 <binrapt> @vixen Are you a fascist?
04:17:46 <lambdabot> isn't it obvious?
04:17:51 <binrapt> I figured
04:22:49 <yitz> @vixen I deny that you are self-aware.
04:22:50 <lambdabot> Math is hard. Let's go shopping.
04:22:58 <goltrpoat> long shot, but, i don't suppose anyone here is into CA and has an online resource on wu's method that they absolutely want to share?
04:23:37 <Saizan> CA?
04:23:43 <goltrpoat> computer algebra
04:23:51 <Lycurgus> Alices answers to those 2: "Am I a fascist? Maybe" and "Why?"
04:25:06 <Lycurgus> when I responded to "why?" with "because of your answers": "Interesting explanation. That is something I haven't heard of."
04:25:39 <goltrpoat> saizan:  i vaguely remember you being a mathematician, actually
04:25:45 <goltrpoat> or am i thinking of someone else
04:27:31 <Lycurgus> s/two questions/question and statement/
04:28:02 <agcorona> we all are algorithmic compressors for making inductions in orde to control the future  (kolmogorov-solomonoff-darwin)
04:28:34 * Lycurgus lives in the eternal now.
04:28:43 <agcorona> just comes to my mid
04:28:44 <agcorona> mind
04:29:37 <Lycurgus> scientists tend to be weak sauce as philosophers.
04:30:01 <Lycurgus> mathematicians doubly so.
04:30:02 <goltrpoat> i think we can trim that down to just kolmogorov
04:30:57 <goltrpoat> lycurgus:  case in point, descartes
04:31:11 <goltrpoat> shouldve stayed a mathematician, but NO.
04:31:22 <Lycurgus> especially with the more or less complete modern divorcement between metaphysics and science in the west.
04:31:41 <agcorona> algorithmic induction theory is more related with solomonoff
04:31:57 <binrapt> Divorce? Replacement!
04:32:03 <osfameron> his dualism is pretty important
04:32:13 <goltrpoat> but solomonoff hasn't actually done anything
04:32:27 <agcorona> a good theory
04:32:37 <Lycurgus> binrapt: No!
04:32:54 <goltrpoat> osfameron:  cartesian dualism?  important?  in this century? :)
04:33:03 <agcorona> greath programmers do not use computers
04:33:11 <Lycurgus> there is no replacement for metaphysics in the modern western scientific world view.
04:33:54 <osfameron> well, it /was/, and remains part of the background
04:33:58 <goltrpoat> oh please.  it just evolves into the other unquantifiable questions.  like, look at what a jackass searle is, but he's popular.
04:34:06 <Lycurgus> there is no religion of reason as such in the modern capitalist and still nominally christian west.
04:34:15 <Lycurgus> Ask Sarah Palin.
04:34:20 <agcorona> because any metaphisic change need a metaphisical explanation
04:34:37 <binrapt> Religion is a nasty relic of the unscientific unenlightened past
04:34:37 <goltrpoat> huh?
04:34:50 <goltrpoat> why are we bringing sarah palin into this
04:34:50 <binrapt> It is our duty to rid mankind of this cancer
04:34:51 <goltrpoat> hehe
04:35:08 <binrapt> And all the other supernaturalist beliefs with it
04:35:37 <Lycurgus> I did because of her purported stance on teaching creationism in schools.
04:35:40 <agcorona> Lycurgus: whatever point of view that you adopt, that is a matter of faith
04:36:08 <Lycurgus> agcorona: that opinion epitomizes what I was saying.
04:36:26 <gwern> dcoutts: there's nothing special about the reproduction - I just run configure. the question is why my system now emits those warnings, and I don't know where to start
04:36:27 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
04:36:27 <goltrpoat> binrapt:  i spent several hours explaining to my girlfriend of six years why random rocks could not, possibly, bring you love/prosperity/etc, and why it would be disingenuous to sell them as part of her jewelry business
04:36:51 <binrapt> goltrpoat ew, jewelry :[
04:36:56 <binrapt> What rocks?
04:37:03 <binrapt> Does she believe in magical rocks or something like that?
04:37:23 <agcorona> I think that evolution as is teached without any reference to the theory that explain it: Darwinism,  Is pure indoctrination. Evolution is not a scientific theory. Darwinism does
04:37:32 <goltrpoat> well, she's agnostic to a fault, so she figures, those new age types with crystals and whatnot might have something going on.
04:38:14 <goltrpoat> i don't think i managed to impress upon her just how ridiculous that idea is
04:38:51 <binrapt> Have you considered dumping her? Maybe she is beyond repair.
04:38:54 <gwern> @messages
04:38:54 <lambdabot> dcoutts said 4h 44m 40s ago: I'm confused by those macro redefine errors, can you give me instructions on how to reproduce it? or better yet file a ticket with the instructions
04:39:17 <EvilTerran> i know one of those pagans-with-crystals. he's one of the sanest people i know, in many respects
04:39:18 <goltrpoat> binrapt:  haha that's a tad drastic
04:39:55 <EvilTerran> and his belief system does seem to be freer of contradiction than your average dusty-tome-based faith
04:40:06 <EvilTerran> of course, this is all off-topic
04:40:13 <goltrpoat> yeah, remarkably so.
04:40:36 <binrapt> Who cares as long as it doesn't prevent anybody from getting help and it entertains the participants of the conversation
04:40:55 <Lycurgus> agcorona started it.
04:41:20 <goltrpoat> i still want to know what sarah palin has to do with anything
04:41:20 <goltrpoat> hehe
04:41:23 <Lycurgus> and you might learn something *really* important.
04:41:54 <Mitar> could somebody give me an example of how to make unfoldr work on a monadic function (b -> Monad (Maybe (a, b)))
04:41:56 <Lycurgus> goltrpoat: did you miss my answer to your question?
04:42:07 <goltrpoat> oh, so i did.  sorry.
04:42:40 <Lycurgus> perhaps as a European the possiblity of such a thing didn't occur to you.
04:42:53 <goltrpoat> ive been in the states for 15 years
04:43:08 <goltrpoat> im fairly familiar with the phenomenon
04:43:39 <EvilTerran> Mitar, wouldn't that require some kind of unfoldrM ?
04:43:45 <EvilTerran> ?type unfoldr
04:43:46 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
04:43:51 <EvilTerran> ?src unfoldr
04:43:51 <lambdabot> unfoldr f b  = case f b of
04:43:51 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
04:43:51 <lambdabot>    Nothing        -> []
04:44:34 <Mitar> yes ... does there is some unfoldrM?
04:44:39 <EvilTerran> don't think so
04:44:43 <mauke> :t unfoldM
04:44:44 <lambdabot> Not in scope: `unfoldM'
04:44:46 <EvilTerran> you could define it yourself
04:44:50 <EvilTerran> ?hoogle unfold
04:44:51 <lambdabot> Data.Tree unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
04:44:51 <lambdabot> Data.Tree unfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
04:44:51 <lambdabot> Data.Tree unfoldForestM_BF :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
04:44:56 <EvilTerran> hm. unhelpful.
04:45:54 <Toxaris> sarah
04:45:56 <EvilTerran> @type let unfoldM f x = do fx <- f x; case fx of Just (y,x') -> liftM (y:) (unfoldM f x'); Nothing -> return [] in unfoldM
04:45:58 <lambdabot> forall t (t1 :: * -> *) t2. (Monad t1) => (t -> t1 (Maybe (t2, t))) -> t -> t1 [t2]
04:46:10 <EvilTerran> that would do it
04:46:48 * EvilTerran wishes for "case of" notation so that could be "f x >>= case of ..."
04:46:54 <Mitar> thanks
04:47:10 <EvilTerran> Mitar, be sure to lay that out more sensibly if you're planning on using it ;)
04:47:20 <Mitar> :-)
04:47:42 <goltrpoat> is "of" really that much shorter than "\fx ->" ? :)
04:48:00 <EvilTerran> goltrpoat, the point of the "case of" proposal is that you can do case-analysis
04:48:05 <mauke> it's shorter than \fx -> case fx of
04:48:42 <goltrpoat> et:  i know, just didn't seem like much of a win in this case
04:48:43 <EvilTerran> without having to give the parameter a name just so you can give it to case
04:48:59 <EvilTerran> goltrpoat, well, single-use names bug me
04:49:30 <Toxaris> @type let unfoldM f x = do fx <- f x; case fx of Just (y,x') -> liftM (y:) (unfoldM f x'); Nothing -> return [] in unfoldM
04:49:32 <lambdabot> forall t (t1 :: * -> *) t2. (Monad t1) => (t -> t1 (Maybe (t2, t))) -> t -> t1 [t2]
04:49:55 * Toxaris hates XChat destroying his clipboard
04:50:04 <EvilTerran> yeah =/
04:50:19 <Toxaris> @type let unfoldM f x = f x >>= maybe (return []) (\(y, x') -> liftM (y:) (unfoldM f x')) in unfoldM
04:50:20 <lambdabot> forall t (m :: * -> *) a. (Monad m) => (t -> m (Maybe (a, t))) -> t -> m [a]
04:50:21 <goltrpoat> ircii is only vaguely aware of my clipboard
04:50:45 <EvilTerran> ?type \(y, x') -> liftM (y:) (unfoldM f x')
04:50:47 <lambdabot> Not in scope: `unfoldM'
04:50:51 <EvilTerran> ...
04:50:56 <goltrpoat> that's new
04:51:02 <Toxaris> now that's my point: if you don't like how case works, don't use it
04:51:25 <Toxaris> @pl \(y, x') -> liftM (y:) (unfoldM f x')
04:51:25 <lambdabot> uncurry ((. unfoldM f) . fmap . (:))
04:51:47 <EvilTerran> @type let unfoldM f x = f x >>= maybe (return []) (uncurry liftM . ((:) *** unfoldM f)) in unfoldM
04:51:48 <lambdabot> forall b' (m :: * -> *) b. (Monad m) => (b' -> m (Maybe (b, b'))) -> b' -> m [b]
04:51:49 <_zenon_> Where do you find the Data.Number.Symbolic package?
04:52:31 <_zenon_> Never mind
04:52:31 <_zenon_> found it
04:52:45 <goltrpoat> zenon:  numbers
04:52:48 <goltrpoat> oh
04:52:55 <goltrpoat> nm
04:54:52 <Toxaris> @type let unfoldM f x = f x >>= maybe (return []) (((:) >>> liftM) *** unfoldM f >>> app) in unfoldM
04:54:54 <lambdabot> forall b' (m :: * -> *) a. (Monad m) => (b' -> m (Maybe (a, b'))) -> b' -> m [a]
04:54:59 <Toxaris> no need for uncurry
04:57:32 <araujo> morning
04:57:32 <lambdabot> araujo: You have 1 new message. '/msg lambdabot @messages' to read it.
04:58:23 <Lycurgus> does anybody use Haskell in their day job?
04:58:36 <Lycurgus> (not in a uni)
04:58:53 <araujo> I think yes
04:59:02 <araujo> Of course
04:59:03 <EvilTerran> they may not be here currently
04:59:08 <araujo> many people use Haskell for job
04:59:12 <Lycurgus> I wanna know for sure.
04:59:20 <araujo> For sure
04:59:22 <araujo> :-)
04:59:23 <EvilTerran> http://haskell.org/haskellwiki/Haskell_in_industry
04:59:24 <lambdabot> Title: Haskell in industry - HaskellWiki
04:59:46 <sheyll_> Lycurgus: I do
05:00:24 * Lycurgus wonders about the veracity of the Deutsche Bank statement.
05:00:45 <goltrpoat> lycurgus:  i did for a while.
05:01:12 <sheyll_> Lycurgus: you have a link to the statement?
05:01:14 <Lycurgus> but it's clearly more than I thought in any case.
05:01:25 <Lycurgus> on the page Evil Terran gave.
05:01:52 <Lycurgus> and my statement was a euphemism for "bullshit".
05:02:42 <Lycurgus> if true it would make Deutsche bank the darcs of industrial apps.
05:02:45 <FordCortina> is there a word that describes something not in "normal form"
05:02:47 <FordCortina> ?
05:02:51 <Lycurgus> is perl6 still in haskell?
05:02:54 <trofi> @instanceof ByteString
05:02:54 <lambdabot> Couldn't find class `ByteString'. Try @instances-importing
05:03:00 <trofi> :t ByteString
05:03:02 <lambdabot> Not in scope: data constructor `ByteString'
05:03:06 <FordCortina> as in lambda calculus
05:03:07 <Toxaris> FordCortina: denormalized (for IEEE floating point numbers)
05:03:09 <trofi> :k ByteString
05:03:11 <lambdabot>     Not in scope: type constructor or class `ByteString'
05:03:22 <gwern> pugs is, but is that 'perl 6'? you'd have to ask the perl hackers
05:03:38 <FordCortina> Toxaris: guess that might do :)
05:03:46 <Toxaris> well, ghc is not Haskell, so I would assume pugs is not perl6
05:04:29 <Lycurgus> gwern: thanks. I'm guessing perl6 will remain permanent vaporware.
05:04:42 <Toxaris> why? because it is written in Haskell?
05:04:59 <osfameron> there are a handful of perl6 implementations
05:05:03 <gwern> Toxaris: it isn't? then what else are haskellers using? :)
05:05:13 <osfameron> pugs is most complete
05:05:23 <goltrpoat> heard audrey was sick or something.  and pugs has changed hands.
05:05:28 <goltrpoat> but, i'm not a perl guy.
05:05:44 <Toxaris> heard audrey is better
05:05:45 <osfameron> but bootstrapping one in perl6 is getting more love these days
05:05:49 <Lycurgus> it was just a utility that got out of hand after all.
05:05:58 <mauke> what, perl?
05:06:04 <Lycurgus> y
05:06:07 <gwern> audrey got better, apparently
05:06:11 <goltrpoat> ah
05:06:20 <mauke> preflex: seen audreyt
05:06:20 <preflex>  audreyt was last seen on #perl6 1 day, 18 hours, 50 minutes and 33 seconds ago, saying: wow :)
05:07:16 <Lycurgus> s/industrial apps/industry adopters/
05:07:28 <Toxaris> gwern: still, it *is* not Haskell, even if it is the only serious Haskell implementation.
05:07:41 <_zenon_> Okay, I built the darcs lambdabot, seems to work nicely, however, it outputs everything twice?
05:08:06 <gwern> ghc == ghc-haskell
05:08:20 <gwern> _zenon_: how do you mean?
05:08:39 <_zenon_> gwern, when giving > 2 + 3 it outputs > 5  two times, and everything else two times as well
05:08:40 <gwern> oh. you're right. how curious
05:09:06 <gwern> @seen sjanssen
05:09:06 <lambdabot> sjanssen is in #xmonad and #haskell. I last heard sjanssen speak 3h 35m 44s ago.
05:09:29 <_zenon_> gwern, you can see it happen in #mobileread
05:10:19 <Lycurgus> @version
05:10:19 <lambdabot> lambdabot 4.2
05:10:19 <lambdabot> darcs get http://code.haskell.org/lambdabot
05:10:25 <Lycurgus> > 2 + 3
05:10:27 <lambdabot>  5
05:11:23 <_zenon_> Likewise, when initializing lambdabot it outputs everything 2 times in the console
05:12:07 <gwern> @ask sjanssen Have you noticed that, apparently after your TH patches, lb duplicates output? any idea why?
05:12:08 <lambdabot> Consider it noted.
05:12:10 <mauke> fmap (uncurry mappend)
05:12:19 <Lycurgus> gwern: why did you agree? on the basis of what version of the bot?
05:12:41 <gwern> Lycurgus: the one I installed last night from darcs
05:12:49 <Lycurgus> thx
05:13:14 <Lycurgus> so version doesn't track the actual codeset
05:13:31 <gwern> _zenon_: I'm not entirely sure why, but I suspect it has to do with changes to the boilerplate-generating code - I'm pretty sure it's none of the other changes since they are all generally confined to one or two modules - if the duplication were just in @type or @djinn or @run, then maybe we could blame one of those patches
05:13:35 <gwern> Lycurgus: no.
05:13:39 <Lycurgus> or doesn't report the minor version.
05:14:11 <GremlinHunter> It isnt just twice for me, I will hpaste the weirdness
05:14:36 <_zenon_> gwern, okay then, I'll live with it until it's fixed.
05:14:46 <GremlinHunter> Results get printed twice, but sometimes one doesnt print till the next result is printed
05:15:03 <gwern> Lycurgus: alas, we have been remiss in incrementing version numbers to reflect changes
05:15:18 <Lycurgus> what was the last good code point?
05:15:41 <GremlinHunter> http://hpaste.org/10042
05:15:44 <Lycurgus> gwern: np I'm familiar with the haskell ethos.
05:15:51 <Lycurgus> and tolerant of it.
05:16:09 <gwern> lambdabot has no good code points...
05:16:26 <Lycurgus> least bad?
05:16:42 <Lycurgus> reasonably health?
05:16:45 <Lycurgus> sane?
05:16:48 <gwern> well, that's the way to think of it, yes
05:17:13 <Lycurgus> I mean for darcs pulling purposes?
05:17:24 <Lycurgus> s/pull/get/
05:17:59 <Lycurgus> *healthy
05:18:31 <Lycurgus> since the current state is what I would call "broken ass".
05:18:47 <Lycurgus> crippledy fuck
05:18:51 <Lycurgus> and the like
05:22:34 <_zenon_> gwern, will you message me when the new version is void of duplication?
05:22:35 <FordCortina> can you only have one module declaration per file in haskell?
05:22:40 <Heffalump> FordCortina: yes :-(
05:22:50 <mauke> file == module
05:22:51 <FordCortina> :(
05:23:13 <Heffalump> it would be nice if you could define submodules (in the hierarchical module sense) in the same file.
05:23:17 <Lycurgus> odd that there's only a few days of entries at HaskellWiki
05:23:42 <FordCortina> i miss it mainly when I want to work on several small modules at once
05:23:59 <FordCortina> it would be nice to have them in one file, while im still prototyping
05:23:59 <Heffalump> yeah, or for namespacing purposes
05:24:04 <FordCortina> yeah
05:24:15 <Heffalump> especially given the records mess
05:24:32 * araujo recommends multiple frames at emacs for FordCortina 
05:25:46 <FordCortina> araujo: yes that's what i do instead, but that just means more window management :)
05:27:03 <araujo> ?
05:27:14 <araujo> FordCortina, just divide frames into smaller windows!
05:27:15 <araujo> :-)
05:27:35 <Toxaris> mauke:  I think (file == module) is not an Haskell requirement
05:27:54 <Toxaris> but existing Haskell implementations do it that way
05:28:21 <mauke> just use Perl™
05:28:44 <Lycurgus> _zenon_: I would (and might) back out recent changes until I got a version that worked like the one in this channel.
05:28:50 <Toxaris> a preprocessor would be easy
05:29:57 <Toxaris> FordCortina: I would not recommend submodules. The hierarchical module namespace does not mean inclusion of modules into each other, but just names with dots in between
05:30:14 <Toxaris> FordCortina: but multiple module ... where ... declerations in one file would make sense to me
05:31:13 <FordCortina> Toxaris: I was wondering about the latter not the former. "submodules" sound complicated to me
05:31:58 <Toxaris> FordCortina: oh I see, "submodules" came from Heffalump
05:33:04 <Lycurgus> "submodules" sounds plain wrong.
05:33:18 <Heffalump> I was proposing multiple module declarations, but restricted to "submodules".
05:33:57 <Heffalump> it would be easy for implementations to find the code, because they could walk up the directory tree
05:34:06 <Lycurgus> (i.e. cognitively dissonanat with "module" or "modularity")
05:34:17 <Heffalump> well, call it what you like, the name isn't important
05:34:18 <Lycurgus> *dissonant
05:34:27 <Heffalump> I'd just like to be able to declare Foo.Bar in the same file as Foo.
05:36:06 <Toxaris> Heffalump: yeah that makes sense, to have a reliable module name to file mapping given a directory and its contents
05:36:39 <Toxaris> a file A/B/C.hs may only define modules wich have A.B.C as a prefix
05:36:58 <Heffalump> it would be very useful for namespacing and implementation hiding
05:37:41 <Lycurgus> it's a matter of taste. I wouldn't be surprised to see haskell come out more on the C++ than the Java side of this issue.
05:37:51 <Heffalump> for example, my work project is a library used by end-users, so there is a distinction between what we export to the rest of our library and what we export to end-users.
05:38:09 <Heffalump> and we end up having to maintain two export lists in two files
05:38:27 <Toxaris> vs two export lists in one file
05:38:32 <Heffalump> right
05:38:39 <Toxaris> seems that the two export lists are the problem, not the two files
05:38:40 <Heffalump> it just means more jumping around
05:38:54 <Heffalump> well, they are a problem, but an inevitable one. It'd be easier with a singlefile.
05:39:32 <Heffalump> also, when changing a module that has everything exported to users to have some "private" exports, it means moving the file right now.
05:39:35 <Toxaris> module Library.Internal (module Library.External, unsafeCastSpell) where import Library.External; import Library.Magic
05:39:46 <Heffalump> no, that's not how it works
05:39:55 <Heffalump> Library.External imports Library.Internal and re-exports some stuff.
05:40:06 <Heffalump> the real code is always in one place, Library.Internal
05:40:45 <Toxaris> well, in my proposal, Library.Internal and Library.External both do only reexporting, and the real code is in Library.Magic
05:41:02 <Heffalump> oh, right. There's no point in that (for us)
05:41:12 <Toxaris> may not be applicable, of course
05:41:57 <Toxaris> module Library.External (castWhiteMagicOnly) where import Library.Magic
05:42:25 <Heffalump> sure, that's fine. I'd just like to put all this stuff in one file, because it logically belongs together.
05:42:36 <Toxaris> hmm doesn't really help, because Library.Magic now has to export everything :(
05:47:42 <Toxaris> multiple modules per file would also make the use of code generators easier
05:51:40 <Heffalump> I'd also like for qualified names to nest, i.e. to be able to export Foo.splat, and have someone else import you as Bar, getting Bar.Foo.splat
06:02:53 <sheyll_> why is $ defined with "infixr" instead of "infixl" ?
06:03:41 <RayNbow> > (+1) $ (*2) $ 4
06:03:43 <lambdabot>  9
06:03:45 <dmhouse> sheyll_: because of lameness.
06:04:43 <RayNbow> :t showHex 32
06:04:45 <lambdabot> String -> String
06:04:55 <RayNbow> > showHex 32 "foo"
06:04:56 <lambdabot>  mueval: Prelude.read: no parse
06:05:22 <RayNbow> > showHex 32 ""
06:05:23 <lambdabot>  mueval: Prelude.read: no parse
06:05:49 <mmorrow> sheyll_: hmm, just use (.). it's infixr because then it saves parens and it seems to me it'd be a less useful (.) if it was infixl
06:06:11 <mmorrow> > (+1) `id` 42
06:06:13 <lambdabot>  43
06:06:52 <Saizan> mmorrow: it's the opposite
06:07:43 <mmorrow> Saizan: assume it /is/ infixl. what would be a line of code using ($)?
06:08:15 <Saizan> (+) $ foo bar baz $ foo1 bar1 baz1
06:08:19 <mauke> mappend $ f x $ g y
06:08:50 <Saizan> instead every chain of $ infixr can be substituted with (.)
06:08:54 <Saizan> and a final $
06:09:02 <mmorrow> yes, i like that
06:09:40 <Saizan> f . g . h $ x still works with $ infixl
06:10:03 <mmorrow> i also like using it for         something 42 $ \k -> another "asdf" $ \z -> k (z 9)
06:10:21 <mauke> that doesn't use fixity
06:10:30 <mauke> lambda extends all the way to the right
06:10:35 <RayNbow> is there a reason why showHex has type Integral a => a -> ShowS instead of a -> String?
06:10:37 <mmorrow> if that'd still be possible with infixl, then my mind is changed
06:10:47 <Heffalump> it would be
06:11:06 <mmorrow> hmm, then what possible use does it have be3ing infixr?
06:11:14 <mauke> none
06:11:16 <Heffalump> it's mainly historical reasons
06:11:24 <sheyll_> ah
06:11:25 <mmorrow> what about saving parens?
06:11:28 <Saizan> RayNbow: because ShowS is more efficient for appending
06:11:34 <mmorrow> sheyll_: :)
06:11:37 <Heffalump> but it does mean you can add things to the front of an expression without having to think about fixity
06:11:45 <Heffalump> or decide whether to use . or $
06:11:49 <RayNbow> Saizan: ah right
06:12:28 <mmorrow> Heffalump: ahh, i see. actually i think i prefer it being infixr then.
06:12:56 <Heffalump> it's way too late to change, anyway
06:13:05 <Heffalump> I don't think I'd mind if it had been infixl from the start.
06:13:51 <Saizan> however you could save more parens with infixl
06:13:57 <sheyll_> thanks for clearing things up
06:14:59 <mmorrow> hmm, i have to think about what it would mean for ($) to be infixl, since i am slightly confused now. what would be an example of a situation where something would work with it as infixr, but be broken with an infixl ($)?
06:15:43 <Heffalump> I don't understand the question. Obviously existing code would change in meaning if you change the fixity.
06:16:05 <Heffalump> (probably just stop compiling, but there might be an extreme situation with weird type classes where it actually changed behaviour)
06:17:00 <mmorrow> exactly, i'm trying to contruct a concrete example not of what you /could/ do if it's infixl, but what you can't do if it's infixl.
06:17:09 <Saizan> f $ g $ x == (f g) x, which is not what you'd like
06:17:37 <Heffalump> there's nothing you can't do if it's infixl, because any existing right-associative chain can be translated by changing all the $s except the last one into .s
06:18:14 <mmorrow> yeah, i meant syntactically w/out translation... n/m, Saizan just made it crystal clear
06:18:16 <Heffalump> oh, wait, (.) has different precedence.
06:18:31 <mmorrow> infixr 9
06:18:37 <Heffalump> right
06:18:53 <Heffalump> so perhaps the translation doesn't work reliably either
06:18:54 <mmorrow> yeah, i think i definitely prefer infixr
06:19:44 <Saizan> if you have operators in the middle you can have problems, not that it's common to have them in a chain
06:20:31 <ivanm> is there an inbuilt way of sorting decreasingly?
06:20:47 <Heffalump> not in a single function
06:20:54 <mauke> sortBy (flip compare)
06:20:55 <Heffalump> sortBy (flip compare) is the standard idiom
06:20:56 <_zenon_> Lycurgus, sorry, I was out for a while. okay.
06:21:02 <ivanm> Heffalump: *nod*
06:21:09 <ivanm> that'll do it ;-)
06:21:16 <Heffalump> or reverse . sort, but that's not stable
06:21:19 <ivanm> I presume (flip compare `on` f) works as well?
06:21:31 <Heffalump> don't see why not
06:22:23 <Igloo> reverse . sort . reverse is stable, but flipping compare makes more sense to me
06:23:37 <mmorrow> it seems to me it's infixr because if infixl, then f $ g $ h $ x === f g h x  ,but if infixr f $ g $ h $ x /== f g h x
06:25:40 <mmorrow> so it provides a way to do application in a right-associative way, instead of the default/implicit associativity of application
06:25:51 <Saizan> yes, it's that, and the fact (.) was not so used i guess, since f $ g $ h $ x === f g h x is useful when one of g,h,x is a complex espression
06:26:39 <Heffalump> I would find it harder to teach people to use ($) if it was infixl, too.
06:28:31 <|Steve|> How would you use it if it were left associative?
06:29:14 <mauke> mappend $ f x $ g y
06:29:30 <sclv> Lycurgus: re yr. deutsche question earlier... not quite sure what you were driving at?
06:31:06 <sclv> you can see the scale of the use there (real, but in a single trading group) in the abstract for the cufp talk: http://cufp.galois.com/2008/abstracts.html
06:31:11 <lambdabot> Title: Commercial Users of Functional Programming 2008 Program
06:32:17 <mmorrow> f x `mappend` g y
06:32:47 <Heffalump> Lycurgus: I use Haskell in my day job
06:33:10 <mauke> liftM3 $ flip f $ g x $ h y
06:34:27 <PeakerWork> liftMn a b c d ... -> a <$> b <*> c <*> d ... ?
06:37:12 <mmorrow> let (<>) = liftM3 . flip $ f in g x <> h y
06:37:16 <mmorrow> ;)
06:38:44 <ivanm> @type mapAccumL
06:38:46 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
06:39:29 <augustss> Heffalump: I see that you have also given up arguing with Adrian Hey. :)
06:40:40 <Heffalump> augustss: not exactly. I just haven't got started for today yet :-)
06:40:44 <Heffalump> (and I'm not sure if I will)
06:49:59 <mmorrow> i just noticed yesterday that jhc already has a top-level <- implemented: http://repetae.net/computer/jhc/manual.html#top-level-actions
06:54:59 <Lycurgus> Heffalump: at Deutsche Bank?
06:55:08 <Heffalump> no, Credit Suisse
06:56:22 <Lycurgus> ah, and I see the statement about DB was just a trading group, not the whole institution as at 1st thought.
06:57:10 <Lycurgus> i still think it's basically a situation of the creeps humouring the chumps
06:57:45 <Lycurgus> "creeps and chumps" is what I call the game of capitalism.
06:58:22 <Heffalump> meaning?
06:59:08 <Lycurgus> but then I your basic bomb thrower.
06:59:41 <Lycurgus> and politically incorrect in the extreme
07:00:20 <Lycurgus> my POV page at wiki gives background.
07:00:46 <mmorrow> Lycurgus: link?
07:01:28 <Lycurgus> http://en.wikipedia.org/wiki/user:lycurgus
07:01:47 <mmorrow> :)
07:02:03 <Heffalump> it seems to have some content that disappears as the page loads
07:02:14 <Lycurgus> in what browser?
07:02:26 <Heffalump> FF
07:02:34 * Heffalump clicks some "Show" links and it reappears
07:02:38 <Heffalump> what are you referring to specifically?
07:03:03 <Lycurgus> oh, yeah there's about 4 or 5 elements like that.
07:03:21 <mmorrow> this is pretty cool: http://upload.wikimedia.org/wikipedia/en/0/00/IBM360-01.jpg
07:03:25 <Lycurgus> that's a FF quirk
07:03:49 <Lycurgus> yeah that's one of mine I believe
07:04:16 <Lycurgus> the whole card is linked from user space
07:04:23 <Lycurgus> *my user space
07:04:45 <Lycurgus> PDP-11 and Univac 1108 are the only incomplete ones.
07:05:14 <Heffalump> I'm no nearer understanding what you mean about "humouring".
07:05:31 <Heffalump> oh, I see the POVs link now.
07:05:56 <Lycurgus> are you a native speaker of english?
07:06:01 <Heffalump> yes
07:07:33 <mmorrow> Lycurgus: all those images are pretty sweet
07:07:35 <gwern> hm. this bites. I'd like to start recording my essays and musings into a database/website like urticator.net or everything2.com, but urticator isn't public and e2 is in perl and hard to set up
07:07:37 * mmorrow wgets :)
07:08:03 <gwern> and I don't know of any haskell software which I could roll my own in, except happs which frightens me
07:08:13 <mmorrow> gwern: build hpaste2
07:08:28 <gwern> (mediawiki would be a possibility except it's ugly and doesn't do softlinks or backtracks like urticator or e2)
07:08:36 <mmorrow> i have it up and running here: http://moonpatio.com:8080
07:08:37 <Lycurgus> mmorrow: thx
07:09:08 <mmorrow> gwern: http://code.haskell.org/hpaste.git/
07:09:15 <gwern> how would hpaste2 help me?
07:09:17 <Lycurgus> Heffalump: you can legitimately view it as an attitude/perspective problem on my part.
07:10:12 <Heffalump> Lycurgus: that's fine, but I have no idea what you're talking about :-)
07:10:17 <gwern> mmorrow: I don't think hpaste is really aimed at the same problem as I am thinking of
07:10:43 <gwern> looks nice though
07:10:49 <PeakerWork> what's the difference between everything2 and a wiki?
07:10:54 <gwern> hm, no diffs?
07:10:59 <mmorrow> gwern: hmm, maybe i'm misunderstanding what you're looking for, but i have hpaste2 running locally on my laptop as well and i use it all the time to save code snippets, or take notes/ideas down, all kinds of misc stuff
07:11:14 * gwern wonders whether it'd be useful to make each paste a git repo
07:12:18 <mmorrow> gwern: maybe with some hacking you could make hpaste2 do what you want. it uses an sqlite3 db as its store.
07:12:21 <gwern> PeakerWork: well, the right analogy is e2 : WP :: everything engine : mediawiki
07:12:42 <gwern> PeakerWork: but e2 has one killer feature for me - the soft linkes from node to node
07:13:00 <PeakerWork> are those like WikiWords?
07:13:01 <gwern> I don't like the handling of images or having to write in HTML, but I love the soft link feature to death
07:13:05 <mmorrow> hmm
07:13:27 * mmorrow refreshes his memory about what e2 looks like
07:14:13 <mmorrow> gwern: ahhh, i see what you mean. that's nice.
07:15:27 <gwern> no
07:15:56 <PeakerWork> what's the difference between soft links and inter-wiki-item links?
07:16:03 <Lycurgus> HL: well it's consistent with your name style. If were to interact further you'd be in a permanent state of apoplexy.
07:16:04 <gwern> soft links work like this: everytime a reader of a particular page clicks on a link, or does a search, that page records it and increments a field; the top n links are then displayed at the bottom
07:16:11 <Lycurgus> *we were
07:16:40 <gwern> so if you have some interesting links to [[History of Haskell]] and [[Haskell Curry]], but the hundred other wikilinks are boring, those two links will be mentioned first at the bottom of the page
07:17:03 <gwern> if you've ever seen WP articles, think of softlinks as automatically generated see alsos
07:17:04 <Lycurgus> so let's stay (more) on topic.
07:17:29 <gwern> automatic in this case == better
07:18:27 <Lycurgus> softlinks are just links from nodes that a logged in user visited before visiting the node softlinked
07:18:34 <Heffalump> Lycurgus: ok..
07:18:57 <gwern> ah well. time to go
07:23:14 <mmorrow> mauke: ping
07:34:00 <mauke> mmorrow: pong
07:35:37 <mmorrow> mauke: hey, i was playing preflex, and i've got it built and have wrote a file with a shown Config. the thing i don't understand though is, what type of file is it expecting as it's second arg and how does one construct one
07:35:39 <mmorrow> ?
07:36:12 <mauke> it expects a socket
07:36:37 <mmorrow> so i did mksock preflex.sock
07:36:50 <mauke> and on that socket there should be a data server listening
07:37:15 <mmorrow> ah, ok. what sort of server/what's the protocol?
07:37:22 <mauke> I have one at http://mauke.ath.cx/dserve/
07:37:27 <lambdabot> Title: Index of /dserve
07:37:39 <mauke> the protocol is rather ad-hoc :-)
07:37:47 <mmorrow> mauke: awesome, thanks. :)
07:38:19 <mauke> wait, no darcs?
07:38:26 <mauke> oh well
07:38:31 <mmorrow> err, doesn't look like it
07:38:54 <mmorrow> haha
07:39:32 <mauke> you need dserve.cabal, Main.hs, Setup.lhs and everything in DServe/
07:39:54 <mmorrow> cool
07:39:55 <dcoutts> dons_: re loading data files, yeah, that'll do. There's also fname <- getDataFile "test-pattern-1024x768.png"
07:42:10 <b\6> confused how to approach parsec problem. http://hpaste.org/10043
07:45:27 <Mitar> is there "gets" for state monad like there is "asks" for reader monad?
07:45:32 <mauke> :t gets
07:45:34 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
07:46:06 <Mitar> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State-Lazy.html << nothing here?
07:46:08 <lambdabot> Title: Control.Monad.State.Lazy, http://tinyurl.com/2dn8t6
07:46:42 <mauke> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State-Class.html
07:46:43 <lambdabot> Title: Control.Monad.State.Class, http://tinyurl.com/37tgec
07:47:57 <Mitar> ok, so if I have my state represented by a record, that I can use constructor with "gets" to get its data?
07:48:05 <Mitar> what about setting some value?
07:48:45 <mauke> modify (\s -> s{ field = value })
07:49:24 <EvilTerran> sadly, there's no pointsfree syntax for record updates
07:49:37 <mauke> @where funref
07:49:37 <lambdabot> I know nothing about funref.
07:49:53 <Mitar> hmm
07:50:06 <EvilTerran> @go haskell functional references
07:50:13 <lambdabot> http://www.brandonwerner.com/2008/01/13/the-rise-of-functional-programming-fscalahaskell-and-the-failing-of-lisp/
07:50:13 <lambdabot> Title: e Brandon Werner 1 15 » Blog Archive 1 55 » The Rise Of Functional Programming ...
07:50:26 <EvilTerran> huh
07:50:28 <EvilTerran> @go haskell functional-references
07:50:28 <Stinger> heh
07:50:30 <lambdabot> No Result Found.
07:51:09 <EvilTerran> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
07:51:15 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
07:54:59 <Mitar> http://hpaste.org/10044 << is this valid syntax?
07:55:49 <mauke> yes
07:56:01 <olsner> yep, as long as 'something' is defined :)
07:57:22 <Mitar> of course
07:57:30 <Mitar> because i am getting an error in similar code ... hm
07:57:43 <Mitar> parse error on input `|'
08:00:13 <trofi> @instanceof String
08:00:14 <lambdabot> Couldn't find class `String'. Try @instances-importing
08:02:21 <Mitar> http://haskell.org/haskellwiki/Image:Haskell-current.png << how was this made?
08:02:22 <lambdabot> Title: Image:Haskell-current.png - HaskellWiki
08:03:18 <mauke> Generated by haskellsocialnet  on irc.freenode.net using PieSpy 0.4.0
08:05:38 <mmorrow> mauke: works :)
08:05:56 <mauke> cool :-)
08:06:20 <mauke> I didn't really write this with other users or portability in mind
08:07:51 <mmorrow> mauke: heh, it's everything i'm looking for. i want to add haskell eval to it :)
08:09:06 <mauke> good luck
08:09:19 <mmorrow> thx
08:09:41 <mauke> hmm, maybe I should have put a backdoor in the code :-)
08:10:23 <bjrn> How do I create a type class instance covering all types in another typeclass? "instance MyTypeClass (all types in the RealFrac type class) where..."
08:10:33 <mauke> you can't
08:10:53 <bjrn> So I have to create different instances for Float and Double?
08:10:56 <mmorrow> mauke: haha, i looked through thoroughly to make sure you didn't
08:11:03 <mauke> :-)
08:11:30 <mmorrow> hopefully i didn't miss it
08:11:32 <mauke> .oO( Preflex.Magic )
08:12:43 <ddarius> Actually mauke hacked you compiler so that the code will be compiled with a backdoor.
08:13:29 <Mitar> why i am getting
08:13:29 <Mitar> No instance for (Read UTCTime)
08:13:43 <mmorrow> mauke: oh crap gotta change Magic
08:13:43 <Mitar> but in documentation is written that Read UTCTime exists?
08:14:04 <mauke> Mitar: import Data.Time
08:14:22 <mauke> or even import Data.Time ()
08:14:59 <Mitar> thanks
08:15:40 <Baughn> "module main:Math is not loaded" <-- I get this when trying to load a module into ghci in the directory with the source file. Any ideas?
08:15:51 <Mitar> what would be the simplest way to set "zero" UTCTime ?
08:15:55 <Baughn> The module is, of course, called Math - not main:Math
08:15:59 <Mitar> (to make a zero UTCTime value)
08:18:14 * shapr boings furiously
08:18:40 * araujo throws a lambda web at shapr 
08:18:59 <mauke>  UTCTime (ModifiedJulianDay 0) 0
08:19:28 <Mitar> ah, i was trying to call v
08:19:30 <Mitar> toModifiedJulianDay
08:26:27 <Mitar> if I run bracket initialize terminate run in a State monad
08:26:43 <Mitar> which state does terminate gets, one from initialize or the one from run?
08:26:50 <mauke> :t bracket
08:26:52 <lambdabot> Not in scope: `bracket'
08:27:00 <dmhouse> ?hoogle bracket
08:27:01 <lambdabot> Control.Exception bracket :: IO a -> a -> IO b -> a -> IO c -> IO c
08:27:01 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
08:27:01 <lambdabot> Control.Exception bracketOnError :: IO a -> a -> IO b -> a -> IO c -> IO c
08:27:16 <mauke> bracket needs IO, not State
08:29:04 <Mitar> initialize terminate and run uses state ...
08:29:11 <bjrn> So there's no way to do this? http://hpaste.org/10045
08:29:42 <bjrn> There are probably reasons if it's not possible, but it seems messy
08:30:21 * shapr boings cheerfully
08:30:31 * shapr wraps araujo in a lambda net!
08:30:38 <Mitar> so I have initialize :: IO MyState, terminate :: MyState -> IO () and and run
08:30:48 <Heffalump> bjrn: instance RealFrac a => MyTypeClass a where ...
08:30:56 <Heffalump> but you need to enable some language extensions
08:31:07 <Heffalump> and you'll have annoying type errors when an instance isn't found
08:31:43 <bjrn> Heffalump: Ah nice. So it's possible but not encouraged atm?
08:31:47 <Heffalump> correct
08:31:48 * araujo jumps around trapped and get his way out of it through a monadic state
08:32:07 <dafra> hi, is there some way to produce random numbers without entering the IO manod ?
08:32:10 <Heffalump> and it won't be encouraged unless type class resolution ever starts backtracking
08:32:28 <mauke> dafra: yes, by explicitly passing a generator
08:32:43 <bjrn> Heffalump: Thanks for answering, appreciate it
08:33:05 <dafra> mauke: using wich function ?
08:33:17 <mauke> huh?
08:33:41 <mauke> :t random
08:33:43 <lambdabot> forall g a. (RandomGen g, Random a) => g -> (a, g)
08:34:53 <mapreduce> Why not have a list of random numbers generated from a starting seed?
08:35:07 <mauke> :t randoms
08:35:08 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
08:35:27 <mapreduce> > randoms 5
08:35:29 <lambdabot>  Add a type signature
08:35:49 <mmorrow> > random (mkStdGen 0)
08:35:51 <lambdabot>  (-117157315039303149,1346387765 2103410263)
08:35:54 <mmorrow> > random (mkStdGen 0) :: Int
08:35:56 <lambdabot>  Couldn't match expected type `Int'
08:36:07 <mmorrow> > random (mkStdGen 0) :: (Int,StdGen)
08:36:09 <lambdabot>  (-117157315039303149,1346387765 2103410263)
08:36:15 <mmorrow> > random (mkStdGen 0) :: (Double,StdGen)
08:36:17 <lambdabot>  (0.9872770354820595,1601120196 1655838864)
08:36:21 <mauke> > maxBound :: Int
08:36:22 <lambdabot>  9223372036854775807
08:36:31 <mauke> nice
08:36:34 <mmorrow> wow
08:36:39 <mauke> > randoms (mkStdGen 42) :: String
08:36:41 <lambdabot>  "\41423\368463\206725\161530\914412\1094711\15230\345119\1035538\358835\8904...
08:36:59 <ziman> > maxBound :: Char
08:37:01 <lambdabot>  '\1114111'
08:37:25 <bjrn> Heh, some kind of dirac delta string
08:37:36 <dmhouse> ;)
08:38:10 <dmhouse> > replicate 10 '.' ++ "|" ++ replicate 10 '.'
08:38:12 <lambdabot>  "..........|.........."
08:38:13 <mmorrow> > error (randoms (mkStdGen 42) :: String)
08:38:29 <lambdabot>  thread killed
08:38:37 <mauke> > error . randoms . mkStdGen $ 13
08:38:46 <mmorrow> > error (take 40 (randoms (mkStdGen 42) :: String))
08:38:48 <ziman> > error (take 10 $ randoms (mkStdGen 42) :: String)
08:38:52 <mmorrow> haha
08:39:00 <lambdabot>  mueval: Prelude.read: no parse
08:39:02 <lambdabot>  thread killed
08:39:02 <ziman> :)
08:39:03 <lambdabot>  thread killed
08:39:04 <mauke> your type annotations are futile
08:39:10 <mmorrow> heh, true
08:39:12 <ziman> poor lambdabot
08:39:19 <mauke> > error "x"
08:39:22 <lambdabot>  mueval: Prelude.read: no parse
08:39:22 <lambdabot> mueval: *** Exception: x
08:39:31 <mauke> > error (error "x")
08:39:31 <mmorrow> > error "\41423\368463\206725\161530\914412\1094711\15230\345119\1035538\358835"
08:39:33 <lambdabot>  mueval: Prelude.read: no parse
08:39:33 <lambdabot> mueval: *** Exception: O7~
08:39:33 <lambdabot> Terminated
08:39:42 <mmorrow> there we go
08:40:10 <ziman> hm
08:40:38 <mauke> > fix printf
08:40:39 <mmorrow> > error [chr 0x2200]
08:40:41 <lambdabot>  mueval: Prelude.read: no parse
08:40:41 <lambdabot> mueval: "*** Exception: stack overflow
08:40:41 <lambdabot> Terminated
08:40:44 <ziman> > error "\r\nprivmsg #haskell :test"
08:40:46 <lambdabot>  mueval: Prelude.read: no parse
08:40:46 <lambdabot> mueval: *** Exception:
08:40:46 <lambdabot> privmsg #haskell :test
08:40:59 <mauke> haha, what
08:41:08 <mmorrow> whoa
08:41:19 <mmorrow> oh
08:41:28 <mauke> > error (concat $ replicate 10 "\n.")
08:41:30 <lambdabot>  mueval: Prelude.read: no parse
08:41:30 <lambdabot> mueval: *** Exception:
08:41:30 <lambdabot> .
08:41:30 <lambdabot> .
08:41:30 <lambdabot> .
08:41:32 <lambdabot> [7 @more lines]
08:41:37 <mauke> > error (concat $ replicate 10 "\n")
08:41:38 <mmorrow> > error "\r\n> fix show"
08:41:40 <r3m0t> @more
08:41:40 <lambdabot>  mueval: Prelude.read: no parse
08:41:40 <lambdabot> mueval: *** Exception:
08:41:40 <lambdabot> > fix show
08:41:40 <lambdabot> Terminated
08:42:24 <Saizan> do you think we should excape \n from error messages?
08:42:27 <mauke> > error "\npreflex, 8ball am I broken?"
08:42:28 <lambdabot>  mueval: Prelude.read: no parse
08:42:29 <lambdabot> mueval: *** Exception:
08:42:29 <lambdabot> preflex, 8ball am I b...
08:42:29 <preflex>  it is decidedly so
08:42:48 <mmorrow> Saizan: we probably should
08:42:50 <mmorrow> heh
08:44:33 <Stinger> I can see horrible things happening with multiple versions of lambabot and some sort of simple quine
08:44:41 <Saizan> \lb uses the mueval from hackage, right?
08:44:53 <ziman> does preflex have mueval?
08:44:58 <mauke> ziman: no
08:45:11 <ziman> :\
08:45:13 <ziman> :)
08:45:32 <mmorrow> Saizan: yeah mueval, but probably not the hackage version...gwern updates that thing constantly
08:45:40 <Saizan> oh, you can already get infinite recursion with other commands if you have 2 \lb, iirc
08:45:44 <mmorrow> ziman: no
08:46:05 <mmorrow> ah, what mauke said
08:46:39 <Saizan> mmorrow: yeah, but it's not the one from darcs, since the one in \lb clearly lacks some of my patches, also it's Cale that builds lb
08:46:46 * shapr boings furiously!
08:46:57 * mapreduce falls off his unicycle.
08:47:04 <mauke> preflex: calc 2 2 +
08:47:05 <preflex>  4
08:47:20 <mapreduce> preflex: calc 2 dup +
08:47:20 <preflex>  Lexical error
08:47:25 <mmorrow> Saizan: hmm, maybe it is
08:47:41 <mauke> mapreduce: it's not stack based
08:49:02 <Baughn> preflex: 2 dup
08:49:08 <Baughn> preflex: calc 2 dup
08:49:08 <preflex>  Lexical error
08:49:22 <Baughn> *Lexical* error? Where?
08:49:25 <mauke> dup
08:49:39 <Baughn> Oh. The function names are embedded in the grammar?
08:49:57 <mauke> everything is :-)
08:52:45 <Ilmuri> even the programs?
08:52:49 <mauke> preflex: karma linode
08:52:49 <preflex>  karma for linode: 27
08:53:06 <mauke> preflex: karmatop
08:53:07 <preflex>  c: 28367; g: 1481; ##c: 932; c/c: 759; vc: 579; #c: 420; notepad: 325; which focuses on standard c: 254; "c: 223; ac: 201
08:53:33 <mmorrow> preflex: zenc _oo_an_ang
08:53:33 <preflex>  zuoozuanzuang
08:55:10 <drigz> testing testing++ testing
08:56:24 <drigz> why have so many people said 'which focuses on standard c++' and why are there spaces in it?
08:57:18 <ddarius> preflex: karma foo bar
08:57:18 <preflex>  foo bar has no karma
08:57:27 <ddarius> (foo bar++)
08:57:32 <ddarius> preflex: karma foo bar
08:57:32 <preflex>  karma for foo bar: 1
08:57:36 <Baughn> preflex: karma testing testing
08:57:36 <preflex>  testing testing has no karma
08:57:41 <ddarius> drigz: There you go.
08:57:53 <Baughn> ..people don't normally use parantheses like that
08:58:06 <mauke> it's a side effect of the hacky parser :-)
08:58:27 <mauke> it splits the input into words, using ( ) to escape spaces
08:58:34 <mauke> then it looks whether the "word" ends in ++ or --
08:58:49 <mmorrow> > error ("\npreflex: zenc !\"#$%&'()*+,-./0123456789:;<=>?@")
08:58:51 <lambdabot>  mueval: Prelude.read: no parse
08:58:51 <lambdabot> mueval: *** Exception:
08:58:51 <lambdabot> preflex: zenc !"#$%&'...
08:58:51 <preflex>  znz22Uzhzdzvzazqzizizi
08:59:22 <mauke> and I bet the '(which focuses on standard c++)' thing is part of a factoid over in ##c++.
09:00:15 <mmorrow> preflex: ? 42
09:00:15 <preflex>  factoid not found
09:00:26 <mmorrow> preflex: + 42 42
09:00:28 <mmorrow> preflex: ? 42
09:00:28 <preflex>  42
09:00:30 <mmorrow> :)
09:12:30 <titto> hi, is there any way to reexport a qualified module ? As in: module X (module Out)  where import Out qualified as O
09:13:45 <Heffalump> titto: no
09:14:06 <Heffalump> you'd need name qualification to be hierarchical to support that, otherwise an importer wouldn't be able to avoid the namespace pollution of all those O.* values
09:17:03 <titto> well pity, though I am not sure that I see why reexporting the module qualified would be a problem.
09:17:34 <Heffalump> if I import qualified X, I expect all the names I get to be X.something
09:17:43 <Heffalump> how would it work in your proposal?
09:19:22 <dafra> is there a standard function to split a list between odd and even positions ?
09:19:54 <mauke> partition { $i++ } @xs
09:20:22 <dafra> :i partition
09:20:35 <mauke> won't help you; this isn't Perl :/
09:20:35 <dafra> :t partition
09:20:43 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
09:20:48 <dafra> :)
09:22:32 <Saizan> > map snd . partition (even . fst) . zip [0..] $ "hello world"
09:22:34 <lambdabot>  Couldn't match expected type `[(a, b)]'
09:22:51 <Saizan> > (map snd  *** map snd) . partition (even . fst) . zip [0..] $ "hello world"
09:22:53 <lambdabot>  mueval: Prelude.read: no parse
09:23:06 <Saizan> missing Control.Arrow?
09:23:27 <Saizan> > (\(a,b) -> (map snd a,map snd b)) . partition (even . fst) . zip [0..] $ "hello world"
09:23:29 <lambdabot>  ("hlowrd","el ol")
09:23:33 <dafra> mauke: found it
09:23:39 <dafra> :t unintrleave
09:23:41 <lambdabot> Not in scope: `unintrleave'
09:23:43 <dafra> :t uninterleave
09:23:45 <lambdabot> Not in scope: `uninterleave'
09:24:06 <Stinger> prelude seriously needs a groupInto :P
09:24:23 <dafra> :i DSP.Basic
09:24:59 <titto> heffalump: I have no proposal :-) I just don't see why rexeporting qualified would be more of a problem then importing directly qualified in the target module. thanks for your help.
09:25:37 <dafra> DSP.Basic.uninterleave does the job
09:27:31 <dafra> uninterleave = foldr (\x ~(xs,ys) -> (x:ys,xs)) ([],[])
09:27:49 <dafra> what does this "~" stand for ?
09:28:09 <ddarius> An irrefutable (lazy) pattern match.
09:28:10 <dafra> foldr (\x ~(xs,ys) -> (x:ys,xs)) ([],[]) [1,2,3?4,5]
09:28:20 <dafra> > foldr (\x ~(xs,ys) -> (x:ys,xs)) ([],[]) [1,2,3?4,5]
09:28:22 <lambdabot>  mueval: Prelude.read: no parse
09:28:26 <dafra> > foldr (\x ~(xs,ys) -> (x:ys,xs)) ([],[]) [1,2,3,4,5]
09:28:28 <lambdabot>  ([1,3,5],[2,4])
09:28:50 <dafra> darius: does it need a GHC extension ?
09:28:57 <ddarius> No.
09:29:08 <dafra> darius: thanks
09:31:31 <mmorrow> > (foldr (zipWith (:)) [[],[]] . takeWhile (not . null) . uncurry (:) . fmap go . splitAt 2) [0..9]
09:31:33 <lambdabot>  mueval: Prelude.read: no parse
09:31:48 <mauke> > [0..9]
09:31:50 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
09:31:59 <mmorrow> > /msg lambdabot > 42
09:32:01 <lambdabot>  mueval: Prelude.read: no parse
09:32:03 <mmorrow> crap
09:33:09 <MarcWeber> @seen mwallace
09:33:09 <lambdabot> I haven't seen mwallace.
09:33:25 <MarcWeber> @seen malcolmw
09:33:25 <Olathe> Well, we know what sorts of conversations mmorrow has with lambdabot now.
09:33:25 <lambdabot> I haven't seen malcolmw.
09:33:37 <mmorrow> Olathe: heh
09:33:58 <mauke> preflex: seen malcolmw
09:33:58 <preflex>  malcolmw was last seen on #ghc 2 days, 3 minutes and 56 seconds ago, saying: quicksilver: I'm impressed you have discovered the ability to un-know things
09:35:11 <mmorrow> ah, i figured out why
09:35:36 <yitz> > uncurry preflex (zenc, ['!'..'~']) :: Expr
09:35:38 <lambdabot>  mueval: Prelude.read: no parse
09:36:17 <mauke> > var "a b c"
09:36:19 <lambdabot>      Ambiguous occurrence `var'
09:36:19 <lambdabot>     It could refer to either `Data.Number.Sym...
09:36:21 <mmorrow> > let go = takeWhile (not . null) . uncurry (:) . fmap go . splitAt 2 in foldr (zipWith (:)) [[],[]] . go $ [0..9]
09:36:23 <lambdabot> Terminated
09:36:24 <mauke> haha, what
09:36:37 <mmorrow> > let go = takeWhile (not . null) . uncurry (:) . fmap go . splitAt 2 in foldr (zipWith (:)) [[],[]] . go $ [0..9]
09:36:39 <lambdabot>  [[0,2,4,6,8],[1,3,5,7,9]]
09:36:58 <mauke> > fun "a b c"
09:36:59 <lambdabot>  Add a type signature
09:37:02 <mauke> > fun "a b c" x
09:37:04 <lambdabot>  Add a type signature
09:37:12 <mauke> > fun "a b c" :: Expr
09:37:14 <lambdabot>  a b c
09:37:18 <mmorrow> whoa
09:37:28 <yitz> > uncurry f (a, ['!'..'~']) :: Expr
09:37:29 <mmorrow> @type fun
09:37:31 <lambdabot> forall a. (SimpleReflect.FromExpr a) => String -> a
09:37:31 <lambdabot>  f a "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcde...
09:37:36 <ddarius> dafra: The interesting question is: "Why is a lazy pattern match being used there?" (It is there for a reason.)
09:37:40 <ziman> > var "x" :: Expr
09:37:41 <lambdabot>      Ambiguous occurrence `var'
09:37:41 <lambdabot>     It could refer to either `Data.Number.Sym...
09:37:42 <mauke> :t var
09:37:44 <lambdabot> forall a. String -> Sym a
09:37:45 <Olathe> > fun "omg hi!" :: Expr
09:37:47 <lambdabot>  omg hi!
09:38:01 <ziman> > fun "\nomg hi!" :: Expr
09:38:03 <lambdabot>  omg hi!
09:38:33 <Olathe> > fun ((chr 1):"ACTION waves.") :: Expr
09:38:35 <lambdabot>  ACTION waves.
09:38:38 <Olathe> :(
09:38:47 <mmorrow> > chr 1
09:38:49 <ziman> there's a space
09:38:49 <lambdabot>  '\SOH'
09:38:53 <yitz> > preflex + foo
09:38:53 <Olathe> Ahh.
09:38:54 <lambdabot>  mueval: Prelude.read: no parse
09:39:13 <mauke> > fun "\1ACTION waves\1" :: Expr
09:39:15 <lambdabot>  ACTION waves
09:39:15 <ziman> > fun "blah\n\SOHACTION\SOH waves"
09:39:17 <lambdabot>  Add a type signature
09:39:18 <dafra> ddarius: don't know, just discovered lazy paatrn, and still wondering when to use them
09:39:19 <yitz> looks like there's a new lambdabot rule that rejects preflex hacks
09:39:23 <mmorrow> > fun [chr 0x2200] :: Expr
09:39:24 <ziman> > fun "blah\n\SOHACTION\SOH waves" :: Expr
09:39:26 <lambdabot>  blah
09:39:26 <lambdabot> ACTION waves
09:39:26 <lambdabot> Terminated
09:39:35 <mmorrow> > fun [chr 0x2200] :: Expr
09:39:37 <lambdabot>  mueval: Prelude.read: no parse
09:39:37 <lambdabot> mueval: Enum.toEnum{Word8}: tag (8704) is out...
09:39:40 <Olathe> @let say x = fun x :: Expr
09:39:41 <lambdabot> Defined.
09:39:45 <Olathe> > say "Hi !"
09:39:47 <lambdabot>  Hi !
09:39:53 <yitz> probably a good idea
09:40:06 <mauke> > fun "blah\n\SOHACTION waves\1" :: Expr
09:40:08 <lambdabot>  blah
09:40:08 * lambdabot waves
09:40:15 <dafra> :pl  foldr (\x ~(xs,ys) -> (x:ys,xs)) ([],[])
09:40:20 <mauke> yitz: what
09:40:29 <dafra> @pl  foldr (\x ~(xs,ys) -> (x:ys,xs)) ([],[])
09:40:29 <lambdabot> (line 1, column 11):
09:40:29 <lambdabot> unexpected "~"
09:40:29 <lambdabot> expecting operator, pattern or "->"
09:40:31 <mauke> yitz: 'preflex' is not a variable
09:40:32 <ziman> mauke, yay! :)
09:40:32 <Olathe> > say "\n\SOHACTION tests.\SOH"
09:40:34 <lambdabot>  ACTION tests.
09:40:38 <dafra> @pl  foldr (\x (xs,ys) -> (x:ys,xs)) ([],[])
09:40:38 <lambdabot> foldr ((`ap` snd) . (. fst) . flip . ((,) .) . (:)) ([], [])
09:40:43 <Olathe> > say " \n\SOHACTION tests.\SOH"
09:40:45 * lambdabot tests.
09:40:51 <yitz> mauke: they have to be a single character?
09:41:03 <dafra> \bot smiling :)
09:41:07 <mauke> yitz: no, variables just have to be defined before you use them
09:41:08 <Olathe> @let act x = say (" \n\SOHACTION " ++ x ++ "\SOH")
09:41:10 <lambdabot> Defined.
09:41:13 <Olathe> > act waves.
09:41:14 <lambdabot>  mueval: Prelude.read: no parse
09:41:26 <mauke> > act "surfs"
09:41:28 * lambdabot surfs
09:41:31 <Olathe> Oh.
09:41:36 <Olathe> > act "waves."
09:41:38 * lambdabot waves.
09:41:42 <yitz> What Olathe is doing is really dangerous.
09:41:42 <ziman> neat :)
09:41:48 <Olathe> Yes.
09:41:54 <Olathe> It should probably be patched a bit.
09:42:00 <yitz> How did you define "say"?
09:42:08 <Olathe> (11:39.39) (Olathe) @let say x = fun x :: Expr
09:42:17 <yitz> How did you define "fun"?
09:42:21 <Olathe> @src fun
09:42:21 <lambdabot> Source not found. It can only be attributed to human error.
09:42:25 <Olathe> I'm not sure.
09:42:35 <mauke> provided by SimpleReflext
09:42:36 <mmorrow> > say "\182"
09:42:38 <lambdabot>  �
09:42:38 <mauke> *c
09:43:18 <yitz> > say $ "preflex: zenc " ++ ['!'..'~']
09:43:19 <mmorrow> > say "\194\182"
09:43:21 <lambdabot>  preflex: zenc !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^...
09:43:22 <lambdabot> Terminated
09:43:25 <mmorrow> > say "\194\182"
09:43:27 <lambdabot>  ¶
09:43:29 <mmorrow> yes!
09:43:29 <Olathe> > act "pokes Cale."
09:43:31 * lambdabot pokes Cale.
09:43:37 <Heffalump> well, it's not that dangerous; all you can do is get lambdabot to do dodgy things with the server.
09:43:42 <yitz> > say $ "preflex: zenc " ++ ['!'..'~']
09:43:44 <lambdabot>  preflex: zenc !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^...
09:43:44 <Heffalump> as opposed to hacking the machine it's running on
09:43:46 <mmorrow> unicode via SimpleReflect!
09:43:48 <Heffalump> but that's still not ideal..
09:44:27 <yitz> You could get lambdabot to quit, for example. (Please don't)
09:44:48 <mauke> oh. how?
09:44:52 <ziman> can you issue arbitrary irc commands?
09:44:58 <yitz> looks that way
09:45:04 <Olathe> No, just PRIVMSG.
09:45:09 <Olathe> You can send CTCPs, though.
09:45:09 <mmorrow> heh, another hole found
09:45:45 <yitz> Olathe: you got it to send ACTION
09:45:53 <Olathe> Sure, that's a privmsg.
09:46:23 <Olathe> CTCPs are regular messages that start with \1.
09:46:23 <yitz> You could send provmsg to NickServ. That wouldn't be very polite.
09:46:33 <yitz> privms
09:46:34 <SamB_XP> Olathe: ACTION isn't PRIVMSG ...
09:46:35 <mauke> how can you retarget replies?
09:46:36 <yitz> privmsg
09:46:43 <mauke> SamB_XP: there is no ACTION
09:46:46 <Olathe> SamB_XP: It is.
09:46:55 <SamB_XP> mauke: what the heck?
09:46:57 <Olathe> > (chr 1):""
09:46:59 <lambdabot>  "\SOH"
09:47:02 <Olathe> Bah.
09:47:06 <SamB_XP> everything I had believed is a lie!
09:47:15 <Deewiant> SamB_XP: it's CTCP ACTION
09:47:17 <Olathe> > say ((chr 1):"ACTION tests.")
09:47:18 <lambdabot> Terminated
09:47:24 <yitz> preflex: list
09:47:24 <preflex>  Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; ZCode: [zdec, zenc]
09:47:31 <Olathe> > say ((chr 1):"ACTION tests.")
09:47:33 <lambdabot>  ACTION tests.
09:47:40 <Olathe> Copy and paste that.
09:47:47 <yitz> preflex zenc "abcd"
09:47:48 <preflex>  z22Uabcdz22U
09:47:49 <Olathe> ACTION tests.
09:47:51 <Olathe> Bah.
09:47:53 <Olathe> Hmm...
09:47:53 <mauke> SamB_XP: PRIVMSG #haskell :\1ACTION waves.\1
09:47:57 <Heffalump> ah, so it does unlines the text and send that as separate PRIVMSGs
09:48:00 <Olathe> Yeah, that's how it works.
09:48:03 <yitz> > say "preflex zenc " ++ "abcd"
09:48:05 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Expr'
09:48:05 <Heffalump> it's not that the \ns are providing an injection bug
09:48:07 <Olathe> Yeah.
09:48:12 <yitz> > say $ "preflex zenc " ++ "abcd"
09:48:14 <lambdabot>  preflex zenc abcd
09:48:30 <Heffalump> how would you send a message to NickServ, in that case?
09:48:32 <yitz> it put in a space
09:48:35 <Olathe> It won't send messages to anyone other than the channel or private chat it got the command in, so NickServ is safe.
09:48:36 <Heffalump> the #haskell bit seems to be being prefixed too
09:48:36 <ziman> > say $ "blah\npreflex zenc " ++ ['!'..'~']
09:48:38 <lambdabot>  blah
09:48:38 <lambdabot> preflex zenc !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ...
09:48:38 <preflex>  znz22UzhzdzvzazqZLZRztzpz2cUzmzizs0123456789ZCz3bUzlzezgz3fUz40UABCDEFGHIJKLMNOPQRSTUVWXYZZzizizi
09:48:43 <Heffalump> right
09:48:45 <Heffalump> that sounds fine then
09:49:06 <ziman> i think you can manipulate the PRIVMSG payload only
09:49:49 <yitz> preflex zenc " "
09:49:49 <preflex>  z22Uz20Uz22U
09:50:20 <yitz> > succ 'Z'
09:50:22 <lambdabot>  '['
09:50:30 <yitz> > pred 'a'
09:50:32 <lambdabot>  '`'
09:50:38 <yitz> > succ 'z'
09:50:40 <lambdabot>  '{'
09:51:12 <Olathe> > (say . show) $ map (\x -> x^2) [1..]
09:51:14 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
09:51:18 <Olathe> Bah :)
09:51:23 <mauke> preflex: zenc λbot
09:51:23 <preflex>  z3bbUbot
09:51:39 <Olathe> > length "[1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484"
09:51:41 <lambdabot>  76
09:52:36 <yitz> > say $ concat ["z\npreflex zenc ", ['!'..'/'],[':'..'@'],['['..'`'],['{'..'~']]
09:52:38 <lambdabot>  z
09:52:38 <lambdabot> preflex zenc !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
09:52:38 <preflex>  znz22UzhzdzvzazqZLZRztzpz2cUzmzizsZCz3bUzlzezgz3fUz40UZMzrZNzczuz60Uz7bUzbz7dUz7eU
09:53:19 <Olathe> > say ((take 75 x) ++ "\n" ++ (((take 75).(drop 75)) x)) where x = show $ map (\x -> x^2) [1..]
09:53:21 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48
09:53:21 <lambdabot> ...
09:53:30 <Saizan> say = fun?
09:53:31 <Olathe> Well, at least it's not a flood risk.
09:53:45 <Olathe> Saizan: Yeah.
09:53:54 <Olathe> say x = fun x :: Expr
09:54:03 <mauke> > x where x = ()
09:54:05 <lambdabot>  ()
09:54:07 <mauke> since when does that work?
09:54:25 <mauke> > 1 + 1 where 1 = 2
09:54:25 <Saizan> mauke: since we switched to ghc-api i guess
09:54:27 <lambdabot>  2
09:54:58 <Saizan> this means it's not checking that it parses as an expression?
09:55:38 <mauke> > 1 where _ = (); data X = X
09:55:39 <lambdabot>  mueval: Prelude.read: no parse
09:56:40 <yitz> @type fun
09:56:42 <lambdabot> forall a. (SimpleReflect.FromExpr a) => String -> a
09:57:01 <yitz> > fun "abcd"
09:57:02 <lambdabot>  Add a type signature
09:57:13 <yitz> > fun "abcd" :: Expr
09:57:15 <lambdabot>  abcd
09:58:15 * rwbarton still sees a flood risk...
09:59:13 <yitz> @seen Cale
09:59:14 <lambdabot> Cale is in #haskell-overflow, #haskell and #ghc. I last heard Cale speak 21h 16m 55s ago.
10:00:42 <mmorrow> just defined a utf8 encode oneliner
10:00:46 <mmorrow> > utf8 '\2200'
10:00:46 <FordCortina> in haskell every function has to return exactly the same type for every parameter?
10:00:48 <lambdabot>  "\224\162\152"
10:01:12 <mmorrow> > say (utf8 '\2200')
10:01:14 <FordCortina> for instance you cant return a Foo Bool for one paramter and Foo Int for another
10:01:14 <lambdabot>  mueval: Prelude.read: no parse
10:01:14 <mauke> FordCortina: huh?
10:01:33 <mauke> FordCortina: right, unless you do something like a -> Foo a
10:01:43 <mauke> in which case you return Foo Bool when passed a Bool, etc
10:02:00 <mmorrow> > fun (utf8 '\2200') :: Expr
10:02:01 <yitz> @tell Cale oh oh. Olathe found this: > fun " \n\SOHACTION is p0wnd\SOH" :: Expr
10:02:02 <lambdabot>  ࢘
10:02:02 <lambdabot> Consider it noted.
10:02:29 <yitz> mmorrow: you've left a black mark on our irc channel.
10:02:37 <mmorrow> oh my
10:02:55 <mmorrow> > utf8 '\182'
10:02:56 <lambdabot>  mueval: Prelude.read: no parse
10:03:07 <mauke> > say (utf8 '\x2200')
10:03:08 <lambdabot>  mueval: Prelude.read: no parse
10:03:22 <mmorrow> someone undefined it i think
10:03:30 <mauke> > fun (utf8 '\2200') :: Expr
10:03:31 <lambdabot>  mueval: Prelude.read: no parse
10:03:35 <mmorrow> > utf8 '\182'
10:03:36 <lambdabot>  "\194\182"
10:03:51 <FordCortina> mauke: i was actually trying to write a function that had type "forall a . Foo a -> Bar a"
10:03:59 <FordCortina> where a was variable
10:04:00 <mauke> FordCortina: that looks fine
10:04:04 <mmorrow> > fun (utf8 '\182') :: Expr
10:04:06 <lambdabot>  ¶
10:04:21 <mauke> > fun (utf8 '\182') :: Expr
10:04:22 <lambdabot>  ¶
10:04:24 <mauke> > fun (utf8 '\1821') :: Expr
10:04:25 <lambdabot>  ܝ
10:04:29 <mmorrow> yay!
10:04:33 <Saizan> FordCortina: you can't "pattern match" on the type 'a' will be though
10:04:34 <mauke> > fun (utf8 '\8704') :: Expr
10:04:36 <lambdabot>  ∀
10:04:38 <Olathe> @let sayu x = fun (utf8 x) :: Expr
10:04:40 <lambdabot> Defined.
10:04:41 <Saizan> FordCortina: for that you need type classes
10:04:46 <Olathe> > sayu '\182'
10:04:48 <lambdabot>  ¶
10:05:08 <Olathe> > sayu 'm'
10:05:09 <FordCortina> Saizan: actually what I really want is for the type inference to go backwards. Ill paste my code.
10:05:10 <lambdabot>  m
10:05:16 <Saizan> FordCortina: ok
10:05:20 <mauke> @let utf8s = concatMap utf8
10:05:22 <lambdabot> Defined.
10:07:02 <mmorrow> @let say8 x = fun (utf8s x) :: Expr
10:07:03 <lambdabot> Defined.
10:07:17 <mmorrow> > say8 "\8704 a. a -> a"
10:07:19 <lambdabot>  ∀ a. a -> a
10:07:23 <Olathe> > fun (utf8s "\8704 \182: proofread(\182)") :: Expr
10:07:24 <lambdabot>  ∀ ¶: proofread(¶)
10:08:05 <SamB_XP> ∀?
10:08:16 <Olathe> SamB: for-all
10:08:21 <mauke> U+2200 (e2 88 80): FOR ALL [∀]
10:08:25 <ziman> > say "∃"
10:08:26 <lambdabot>  mueval: Prelude.read: no parse
10:08:35 <mauke> U+2203 (e2 88 83): THERE EXISTS [∃]
10:08:36 <SamB_XP> it just looks like a rectangle here ...
10:08:42 <mauke> font issue
10:08:43 <SamB_XP> that too
10:08:45 <Olathe> What is utf8 ?
10:08:56 <Taejo> SamB_XP: using mIRC?
10:08:58 <mauke> a unicode encoding
10:09:01 <mmorrow> Olathe: a utf8 encode one-liner
10:09:03 <SamB_XP> Taejo: no, x-chat
10:09:05 <Olathe> I mean the function.
10:09:16 <SamB_XP> lacking the necessary fonts, I assume
10:09:17 <mmorrow> ok, i'll paste (it's long so be warned)
10:09:22 <FordCortina> Saizan: ok here it is. its a bit crazy http://hpaste.org/10046
10:09:34 <mmorrow> utf8 = map chr.((let{fi=fromIntegral;multi x n=fi(x`shiftR`n.&.0x3f.|.0x80);first x n y=fi(x`shiftR`n.|.y);test n = span((/=0).(.&.(n::Int)))[0xffffff80,0xfffff800,0xffff0000,0xffe00000];setup n = (take 1.reverse.snd.unzip)(zip(snd(test n))(reverse(zip([0,6,12,18])([0,0xc0,0xe0,0xf0]))))}in(\n->concatMap(\(a,b)->first n a b:(fmap(multi n).takeWhile(>=0))(iterate(subtract 6)(a-6)))(setup n)))).ord
10:09:40 <mauke> haha
10:09:41 <mmorrow> heh
10:09:45 <_zenon_> Is the darcs lambdabot fixed yet? It was spamming 2fold
10:09:46 <Taejo> SamB_XP: yeah, but usually unicode fail on IRC is caused by mIRC
10:10:13 <FordCortina> Saizan: its the "grammar" function that is currently posing the problem
10:10:14 <mmorrow> that took me about 20 minutes to figure out how to one-liner it
10:10:39 <SamB_XP> Taejo: not having a font with a given codepoint in it, or special application support for that codepoint, is a pretty surefire way to prevent it from displaying ;-)
10:10:52 <Taejo> SamB_XP: indeed
10:11:03 <FordCortina> Saizan: it doesnt like the fact that Expr's production has span "Undefined" while Const is just "One"
10:11:13 <_zenon_> mmorrow, you tried to pl it as well?
10:11:26 <mmorrow> heh, not yet
10:11:30 <_zenon_> :)
10:11:43 <_zenon_> Well.... let's try now?
10:12:09 <mmorrow> you'd have to pull out the individual defs in that inner let i think
10:12:29 <SamB_XP> (obviously, neglecting such things as normalization and stand-ins ...)
10:12:57 <mmorrow> @pl \x n -> fi(x`shiftR`n.&.0x3f.|.0x80)
10:12:57 <lambdabot> (fi .) . flip flip 128 . ((.|.) .) . flip flip 63 . ((.&.) .) . shiftR
10:13:12 <mmorrow> \x n y -> fi(x`shiftR`n.|.y)
10:13:14 <Myoma> hiya
10:13:18 <mmorrow> @pl \x n y -> fi(x`shiftR`n.|.y)
10:13:19 <lambdabot> (((fi .) . (.|.)) .) . shiftR
10:13:35 <mmorrow> hi
10:13:42 <Saizan> FordCortina: a solution to that would be defining Expr :: NT Undefined; Const :: NT One
10:13:56 <mmorrow> \n -> span((/=0).(.&.(n::Int)))[0xffffff80,0xfffff800,0xffff0000,0xffe00000]
10:14:02 * Myoma is so tired -_-
10:14:04 <mmorrow> @pl \n -> span((/=0).(.&.(n::Int)))[0xffffff80,0xfffff800,0xffff0000,0xffe00000]
10:14:04 <lambdabot> flip span [4294967168, 4294965248, 4294901760, 4292870144] . ((0 /=) .) . flip (.&.) . (:: Int)
10:14:07 <FordCortina> Saizan: i see
10:14:20 <mauke> heh
10:14:27 <FordCortina> Saizan: im wondering if I can get the compiler to infer that somehow :S
10:14:31 <mauke> a type annotation section
10:14:40 <mmorrow> hahaha
10:14:45 <mmorrow> i didn't notice at first
10:15:02 <mmorrow> map (::Int) ['a'..'z']
10:15:20 <Saizan> FordCortina: i'd say that would break parametricity
10:15:22 <rwbarton> @type (::Int)
10:15:24 <lambdabot> parse error on input `::'
10:15:36 <ddarius>  @pl doesn't know about any syntactic sugar.  It treats anything that matches the operator character rules as an operator.
10:15:45 <ddarius> @ pl [f x | x <- xs]
10:15:55 <ddarius> @pl [f x | x <- xs]
10:15:55 <lambdabot> [f x | x <- xs]
10:15:56 <mmorrow> @pl \f x -> map (f x . (x::Int)) [x,x,x]
10:15:57 <lambdabot> (`ap` ap (:) (ap (:) return)) . (map .) . (`ap` (:: Int)) . ((.) .)
10:16:03 <ddarius> @pl \f xs -> [f x | x <- xs]
10:16:03 <lambdabot> flip flip [] . ((:) .) . (<-) . (| x) . ($ x)
10:16:09 <mmorrow> hah
10:16:15 <Saizan> FordCortina: because with my fix the GADT constructors are a proof that span = Undefined, or = One, respectively, if you just use a span variable instead there's no proof to use
10:16:23 <Myoma> my favorite is how it's untyped
10:16:30 <Myoma> @pl (\u -> u u) (\u -> u u)
10:16:34 <lambdabot> ap id id (ap id id)
10:16:34 <lambdabot> optimization suspended, use @pl-resume to continue.
10:16:35 <Myoma> @pl-resume
10:16:42 <lambdabot> ap id id (ap id id)
10:16:42 <lambdabot> optimization suspended, use @pl-resume to continue.
10:16:46 <FordCortina> Saizan: hmm
10:17:13 <mauke> @pl (\u _ -> u u) (\u _ -> u u)
10:17:17 <lambdabot> (const . ap id id) (const . ap id id)
10:17:17 <lambdabot> optimization suspended, use @pl-resume to continue.
10:17:47 <FordCortina> Saizan: I hadnt looked at the NT GADT in that way.
10:20:19 <Saizan> FordCortina: the starting point is that in expr :: forall a. Bar a, expr cannot make any assumptions on 'a', instead the caller has the freedom to choose one type for it
10:21:10 <FordCortina> Saizan: i see
10:21:21 <Deewiant> @. pl undo \f xs -> [f x | x <- xs]
10:21:24 <lambdabot> (=<<) . flip flip [] . ((:) .)
10:21:39 <Myoma> :t flip flip [] . ((:) .)
10:21:41 <lambdabot> forall b a. (a -> b) -> a -> [b]
10:22:00 <Myoma> :t flip flip []
10:22:02 <lambdabot> forall a c a1. (a -> [a1] -> c) -> a -> c
10:22:41 <Deewiant> :t \f -> flip flip [] . f
10:22:43 <Olathe> There's a @pl-resume
10:22:44 <lambdabot> forall a c a1 a2. (a2 -> a -> [a1] -> c) -> a2 -> a -> c
10:22:44 <Myoma> > flip flip [] (\e xs -> e) ()
10:22:48 <lambdabot>  ()
10:22:49 <Saizan> with exists a. Bar a you'll get the opposite :)
10:22:55 <mauke> @pl-resumé
10:22:57 <lambdabot> pointless: sorry, nothing to resume.
10:22:58 <Olathe> @pl let setup n = (take 1.reverse.snd.unzip)(zip(snd(test n))(reverse(zip([0,6,12,18])([0,0xc0,0xe0,0xf0])))) in setup
10:23:08 <Myoma> lol
10:23:16 <lambdabot> Plugin `pl' failed with: thread killed
10:23:19 <Olathe> Bah.
10:23:20 <Olathe> @pl let setup n = (take 1.reverse.snd.unzip)(zip(snd(test n))(reverse(zip([0,6,12,18])([0,0xc0,0xe0,0xf0])))) in setup
10:23:33 <Saizan> (where exists a. Bar a  is encoded as (forall a. Bar a -> r) -> r)
10:23:48 <Olathe> Try it in private, I suppose.
10:25:42 <mmorrow> Olathe: i don't think @pl does let
10:25:47 <Saizan> @bot
10:25:55 <Deewiant> @pl \x -> let y = x in y
10:26:01 <Olathe> It does, but lambdabot appears dead.
10:26:03 <FordCortina> Saizan: ah
10:26:06 <rwbarton> Sorry, I may have broken lamdabot doing this:
10:26:08 <rwbarton> > say $ ap (++) show "\n> say $ ap (++) show "
10:26:14 <Myoma> :D
10:26:16 <mmorrow> heh
10:26:19 <Deewiant> O_o
10:26:24 <Myoma> :t say
10:26:25 <Deewiant> "may have"? :-P
10:26:30 <mauke> I don't think so
10:26:34 <Olathe> Hahah
10:26:40 <rwbarton> I thought it would process them as they got sent to the IRC channel, and I could @undef to stop it
10:26:41 <mauke> lambdabot shouldn't listen for commands in its own output
10:26:54 <Olathe> It listens to its own output ?
10:27:00 <Olathe> @undefine
10:27:04 <ddarius> She shouldn't.
10:27:05 <mauke> I don't think so
10:27:07 <rwbarton> ("the IRC channel" = #haskell-overflow) but it never printed anything there.
10:27:14 <mauke> that requires extra coding
10:27:18 <Olathe> > 5
10:27:31 <Saizan> FordCortina: more on existential types if you're interested http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
10:28:03 <Olathe> lambdabot has been idle 4mins 32secs, signed on Fri Aug 29 20:59:16
10:28:33 <FordCortina> Saizan: thanks
10:29:22 <Saizan> ddarius: she shouldn't as in you know that the code didn't work like that, or as in it should be fixed?
10:29:55 <mauke> "shouldn't" as in "extremely unlikely to be doing it"
10:30:13 <ddarius> Saizan: As in she definitely didn't in the past and no should have changed that.
10:30:18 <ddarius> +one
10:30:41 <mmorrow> where is she running?
10:30:52 <Saizan> lispy's machine
10:31:11 <mmorrow> preflex: seen lispy
10:31:11 <preflex>  lispy was last seen on #haskell-blah 1 day, 10 hours, 57 minutes and 17 seconds ago, saying: oh good call
10:32:40 <mmorrow> we need more evalbots
10:32:54 <mauke> evilbots
10:33:08 <mmorrow> precisely!!
10:33:12 <mauke> we could get buubot in here; it evals perl
10:33:18 <Olathe> Oh dear.
10:33:23 <Saizan> or less people trying to break them :)
10:33:28 <Olathe> Hahaha
10:33:39 <yitz> preflex seen lambdabot
10:33:40 <preflex>  lambdabot was last seen on #haskell 10 minutes and 23 seconds ago, saying: Plugin `pl' failed with: thread killed
10:33:52 <Olathe> preflex zenc lambdabot
10:33:52 <preflex>  lambdabot
10:34:18 <Myoma> preflex zenc o\no
10:34:18 <preflex>  ozrno
10:34:38 <Myoma> preflex zenc o\y
10:34:38 <preflex>  ozry
10:34:43 <Olathe> preflex help zenc
10:34:43 <preflex>  zenc TEXT - z-encode some text
10:34:47 <mauke> preflex: zenc std::basic_string<char>::size
10:34:47 <preflex>  stdZCZCbasiczustringzlcharzgZCZCsizze
10:34:48 <Myoma> preflex zenc \/\/\/\
10:34:49 <preflex>  zrzszrzszrzszr
10:35:03 <yitz> preflex zdec az0aUb
10:35:03 <preflex>  a
10:35:09 <Myoma> preflex zenc \/\/\/\/\/\/\/\/\\//\/\/\/\/\/
10:35:09 <preflex>  zrzszrzszrzszrzszrzszrzszrzszrzszrzrzszszrzszrzszrzszrzszrzs
10:35:12 <Olathe> What is z encoding ?
10:35:20 <mauke> name mangling scheme used by ghc
10:35:22 <Myoma> preflex zenc z
10:35:22 <preflex>  zz
10:35:24 <Olathe> Oh.
10:35:34 <mmorrow> Olathe: do $ nm Main | less       on a ghc binary
10:35:50 <yitz> preflex zdec az0aUz01UACTION tooz01U
10:35:50 <preflex>  a
10:35:53 <Olathe> I'm evil and don't have Linux.
10:36:01 <mauke> yitz: crap, that might actually work
10:36:08 <yitz> didn't
10:36:17 <yitz> lucky mauke
10:36:27 <Myoma> preflex zdec z0daaaa
10:36:27 <preflex>  z0daaaa
10:36:39 <FordCortina> Saizan: in "(forall a. Bar a -> r) -> r)" is "r" some specific given rigid (user chosen) type?
10:36:42 <Olathe> preflex zdec zazbzczdzezf
10:36:42 <preflex>  &|^$=zf
10:36:59 <mauke> preflex: zdec az0dUz0aUPRIVMSGz32U#haskellz32U:hi
10:36:59 <preflex>  a
10:37:23 <yitz> mauke: that preflex is pretty smart
10:37:26 <Myoma> preflex zdec z30a
10:37:26 <preflex>  z30a
10:37:27 <Myoma> preflex zdec z30U
10:37:27 <preflex>  0
10:37:31 <Myoma> preflex zdec z32U
10:37:31 <preflex>  2
10:37:38 <Myoma> preflex zdec az32Ua
10:37:38 <preflex>  a2a
10:37:41 <mauke> oh, d'oh
10:37:49 <Myoma> preflex zdec az3Ua
10:37:49 <preflex>  aa
10:37:51 <Myoma> preflex zdec azUa
10:37:51 <preflex>  azUa
10:37:53 <Myoma> preflex zdec azaa
10:37:53 <preflex>  a&a
10:37:53 <mauke> preflex: zdec az0dUz0aUPRIVMSG #haskell :hi
10:37:54 <preflex>  a
10:37:54 <preflex> hi
10:37:57 <Heffalump> FordCortina: yes
10:38:08 <Myoma> preflex: zdec az0dUz0aUPRIVMSG #haskell :> 1+1
10:38:08 <preflex>  a
10:38:08 <preflex> > 1+1
10:38:11 <Myoma> :(
10:38:16 <FordCortina> Heffalump: thanks
10:38:20 <yitz> mauke: groan
10:38:33 <Heffalump> well, I'm not sure that rigid==user chosen
10:38:37 <Heffalump> but it's certainly user chosen
10:38:43 <mauke> gnargh
10:38:51 <yitz> mauke: we now have a cross-bot loop attack
10:38:52 * Myoma is shocked!
10:38:59 <mmorrow> yitz: nice one
10:39:04 <Saizan> FordCortina: no, add a forall r. in front of that, i forgot it
10:39:05 <Heffalump> (I think of rigid types as ones that are exposed when you unwrap an existential, but I could be wrong about that)
10:39:06 <mauke> except you don't because I killed preflex :-)
10:39:13 <yitz> :)
10:39:19 <FordCortina> Saizan: ah thanks
10:39:26 <Saizan> FordCortina: it's basically in continuation passing style
10:39:29 <Heffalump> yitz: only if you can make the response of one be a valid command for the other that provokes another response, etc.
10:39:29 <yitz> mauke: you're safe until \bot comes back on line
10:39:43 <yitz> Heffalump: not too hard
10:39:52 <ziman> a biquine :)
10:39:55 <mmorrow> botslayors
10:40:06 <ziman> latest fashion! :)
10:40:10 <Heffalump> I can see how you can cause n levels of recursion for a fixed n, but not how to get infinite recursion.
10:40:20 <Heffalump> but yes, what ziman said :-)
10:41:04 <mauke> blargh, now I have to deal with multiple bytestring versions before I can rebuild preflex
10:41:25 <mmorrow> mauke: ugh
10:41:36 <guenni> when I encode a value through the binary package I get back a Bytestring ... that is a Chunk data contructor then followed by a literal string and then Empty
10:41:36 <yitz> @tell Cale and it also works for preflex using zdec, yielding a cross-bot attack :(
10:41:50 <mauke> yitz: ENOBOT
10:41:52 <Olathe> @tell is dead, since lambdabot is in loony-land
10:41:57 <mmorrow> haha
10:42:00 <yitz> oops hehe
10:42:04 <guenni> depending on the size of the data structure it might also be nested ..
10:42:19 <yitz> I guess preflex tell won't fare much better, will it?
10:42:23 <guenni> how exactly does one use that?
10:42:52 <Olathe> yitz: No, it's not here.
10:42:56 <Olathe> Maybe MemoServ.
10:43:22 <guenni> > :t Chunk
10:48:06 * ddarius doesn't think he's used nm on anything but Windows.
10:51:05 <Trollinator> why does this not work: foo :: Char -> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=Char -> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=Char
10:51:18 <Trollinator> wtf?
10:51:27 <Trollinator> foo :: Char -> [ [ Char ] ] -> [ [ Char ] ]
10:51:34 <Trollinator> split :: [Char] -> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=Char
10:51:39 <Trollinator> split :: [Char] -> [ [ Char ] ]
10:51:42 <Olathe> Hahaha
10:51:47 <Trollinator> split x = foldr foo [ [ ] ]
10:52:08 <Trollinator> ghci says:
10:52:13 <Trollinator> Couldn't match expected type `http://en.wikipedia.org/wiki/Special:Search?go=Go&search=Char'
10:52:17 <Trollinator> Oh fuck it
10:52:21 <Trollinator> i'm giving up
10:53:09 <ziman> preflex: zdec az0dUz0aUPRIVMSG #haskell :> 1+1
10:53:17 <preflex>  a
10:53:21 <ziman> okay ;)
10:53:25 <mauke> preflex: zdec az0dUz0aUPRIVMSG #haskell :hi
10:53:26 <preflex>  a
10:54:10 <Myoma> Trollinator: lol
10:54:51 <mauke> preflex: seen lambdabot
10:54:52 <preflex>  lambdabot was last seen on #haskell 31 minutes and 35 seconds ago, saying: Plugin `pl' failed with: thread killed
10:55:12 <monochrom> Yeah, URLs in type signatures is a bad idea. :)
10:55:18 <Stinger> hahaha
10:55:20 <mauke> preflex++  # state intact after being killed
10:55:35 <Olathe> search :: [Char] -> www.google.com -> [Char]
10:55:35 <monochrom> Use hpaste.org
10:55:56 <Baughn> @let rr 0 k = []; rr n k = k `mod` n : rr (n-1) (k `div` n)
10:56:07 <mauke> monochrom: foo :: Char -> hpaste.org -> hpaste.org?
10:56:08 <lispy> did someone say something to me or adverbify me?
10:56:09 <mauke> :-)
10:56:10 <Myoma> Baughn, there is no lambdabot
10:56:12 <monochrom> mapReduce :: [Char] -> GoogleIO [Char]
10:56:19 <Baughn> Myoma: But.. it's right there...
10:56:21 * Baughn points
10:56:42 * Myoma points out that it's laying on the floor face down
10:56:50 <mauke> *lying
10:56:52 <Trollinator> http://hpaste.org/10047
10:56:56 <Baughn> It's just resting!
10:56:57 <Trollinator> why does that not work?
10:57:19 <mauke> what's the error?
10:57:22 <Olathe> > "lispy"
10:57:28 <Myoma> Trollinator: What's it supposed to doa
10:57:42 <Olathe> Oh !
10:57:45 <Trollinator> Couldn't match expected type `[[Char]]'
10:57:47 <Trollinator>            against inferred type `[Char] -> [[Char]]'
10:57:51 <Olathe> That's what the URL was.
10:57:56 <Trollinator> In the expression: foldr foo [[]]
10:58:06 <lispy> oh, I see people discussing lambdabot
10:58:06 <mauke> Trollinator: x is unused
10:58:12 <monochrom> s/split x/split/
10:58:24 <Trollinator> mauke: right!
10:58:26 <Trollinator> thaks
10:58:28 <Trollinator> thanks
10:58:47 <Trollinator> OK, i removed the x and it worked, thanks!
10:59:32 <Saizan> lispy: lb is stuck and we're not sure why, is the process consuming CPU?
11:00:12 <lispy> I will go check
11:00:34 <lispy> 4928 cale      39  19 98724  47m  176 R  100  4.7   1729:30 mueval
11:00:41 <lispy> heh, you could say it's consuming some CPU yeah :)
11:01:18 <lispy> gwern, cale: you want I should just kill it?
11:01:53 <Saizan> just kill mueval
11:02:18 <lispy> dead
11:03:33 <Saizan> @bot
11:03:38 <lambdabot> :)
11:04:43 <Stinger> oh man that is cool
11:04:59 <lelf> ?read ":-)"
11:05:01 <Stinger> I never noticed emacs highlights parens in strings seperate from parens in code
11:05:03 <lambdabot>  :-)
11:05:15 <mauke> what
11:05:20 <mauke> @help read
11:05:20 <lambdabot> read "<foo>". Print <foo>
11:05:24 <ziman> :D
11:05:38 <trofi> ShiT!
11:05:51 <trofi> ?read "hello\nworld"
11:05:52 <lambdabot>  helloworld
11:06:05 <trofi> hey!
11:06:16 <trofi> where is my '\n' ?
11:06:17 <Olathe> @read "\1ACTION waves.\1"
11:06:17 <lambdabot>  ACTION waves.
11:06:28 <Myoma> @write "hello"
11:06:29 <lambdabot> Maybe you meant: elite gsite
11:06:35 <ziman> @show "hello"
11:06:36 <lambdabot> "\"hello\""
11:06:36 <Myoma> @gsite "hello"
11:06:38 <lambdabot> No Result Found.
11:07:11 <Myoma> Stinger: Oh, I don't use it for haskell but some do -- paredit.el is really really neat
11:07:55 <ziman> @read "hello\r\nworld"
11:07:55 <lambdabot>  helloworld
11:08:52 <lispy> ?help gsite
11:08:52 <lambdabot> gsite <site> <expr>. Search <site> for <expr> using google
11:09:30 <trofi> > read $ fix ("a"++)
11:09:44 <lambdabot>  mueval: Prelude.read: no parse
11:09:58 <trofi> @. read run $ fix ("a"++)
11:10:01 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
11:12:51 <guenni> >/msg lambdabot > 4 + 5
11:13:07 <Myoma> 9
11:21:54 <lilac> > fix show
11:21:55 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
11:26:02 <Baughn> > foldl (+) 1 [1..]
11:26:14 <_zenon__> netsplit?
11:26:15 <lambdabot>  mueval: Prelude.read: no parse
11:26:58 <Baughn> Why did it switch to mueval?
11:27:06 <Baughn> Throwing out code that at least /mostly/ worked..
11:28:00 <vininim> possibly because the person who owns it wanted
11:28:13 <_zenon__> someone with op? please kick _zenon_ (me)
11:28:17 <chrisdone> http://www.haskell.org/sitewiki/images/a/a0/Spj-has-fun-11.jpg
11:28:22 <chrisdone> I laughed hard
11:28:23 <sclv> I thought mueval reduced the dependency on plugins and gave more control...
11:28:36 <vininim> _zenon__: /quote nickserv help ghost
11:29:19 <_zenon__> vininim, sweeet
11:29:43 <Saizan> Baughn: i'm not sure, but that works in the latest mueval, i.e. triggering a timeout
11:31:12 <Saizan> sclv: it removed the dependency on hs-plugins, it uses the ghc-api via hint now
11:34:02 <shapr> chrisdone: haha
11:34:33 <shapr> @quote chrisdone
11:34:40 <lambdabot> chrisdone says: it's neat how you learn haskell because you are drawn in by the purely functional paradigm, and then you find loads more things like algebraic data types, monad abstractions, arrows
11:34:44 <shapr> Who runs animaforge?
11:34:46 <lambdabot> and applicative, lack of objects... so that when people say "well, it's not haskell, but at least X is functional", it's just not the same at all
11:35:01 <shapr> chrisdone: Oh, that's so true.
11:35:20 <dcoutts> Saizan: so, now that the GSoC is done, wanna set up a repo for the little standalone tool?
11:35:20 * Baughn *likes* objects, dang it
11:35:21 <shapr> Someone recently tried to tell me that C# is a functional language because it has type parameterization, lambdas, etc
11:35:25 <Baughn> They're a nice option, on occasion
11:35:27 <dcoutts> Saizan: Arrg, but the hardest decision is what to call it! :-)
11:35:36 <shapr> What's the tool?
11:36:00 <Saizan> dcoutts: aaah, right! i'm no good for names..
11:36:03 <dcoutts> Saizan: hmake is misleading, as i makes one think that it does what make does, ie extensible, but it's not, it's a Haskell build tool.
11:36:09 <shapr> Oh, I like to come up with names!
11:36:14 <dcoutts> Saizan: clearly hbuild then :-)
11:36:20 <jsnx> shapr: i think the ML family is somewhat similar to haskell
11:36:29 <shapr> jsnx: Yeah, Lisp is a lot like Haskell too.
11:36:32 <Myoma> :SS
11:36:40 <Myoma> I don't like the sound of 'hmake'
11:36:41 <shapr> So is C#, now that I think of it.
11:36:42 <Heffalump> shapr: well, isn't it?
11:36:44 <jsnx> shapr: well, when did lisp have type inference?
11:36:50 <Myoma>  can one not add features to ghc -make
11:36:51 <shapr> jsnx: I'm joking :-)
11:36:57 <Myoma> jsnk: It's pretty easy to add :)
11:36:59 <Saizan> shapr: what do you think of hbuild? ;)
11:37:06 <shapr> Heffalump: Yeah sure, for some value of 'like'
11:37:11 <shapr> Saizan: Sure!
11:37:15 <Myoma> jsnx: SBCL does a lot of inference too by the way
11:37:23 <shapr> Since I know nothing about the tool, sounds great!
11:37:38 <jsnx> Myoma: it's true, even javascript does type inference these days
11:37:52 <Saizan> dcoutts: so ok, hbuild looks right
11:38:06 <jsnx> in the ML family, though, strong typing and type inference are really core to the language
11:38:14 <Myoma> and modules ??
11:38:34 <jsnx> yeah, modules
11:39:12 <jsnx> shapr: i don't mean to imply that haskell is not special
11:39:31 <Myoma> jsnx: Haskell isn't really an ML,
11:39:39 <dcoutts> CosmicRay: good discussion on configuration/build/packaging last few days. I think the way to move forward is to come up with a design document for Cabal-2 and incorporate our experience from the current implementation and the criticism of what we need to cope more flexibly with bigger projects.
11:39:43 <jsnx> Myoma: yes, i know
11:39:43 <lucca> haskell is an ml done right
11:39:50 <jsnx> lucca: hahaha
11:39:51 <dcoutts> CosmicRay: It'd also help to clarify what is a limitation of the model vs a limitation of the implementation of the model.
11:39:56 <shapr> jsnx: I'm just being silly, no worries.
11:40:03 <jsnx> lucca: you aren't really cardelli are you?
11:40:11 <Heffalump> that would be one 'c'
11:40:12 <lucca> heh, no
11:40:25 <CosmicRay> dcoutts: I don't know if I'm really the right person to help with that.  I am not very current with Cabal these days.
11:40:45 <jsnx> Heffalump: aha
11:40:51 <CosmicRay> dcoutts: I mean, I use it for everything I write, but I don't use most of its features.
11:40:59 <dcoutts> CosmicRay: I'm not asking you to write it, but your feedback would be much appreciated when we have a draft.
11:41:39 <CosmicRay> oh, sure I'd be happy to do that
11:41:41 <lilac> > iterate (concatMap (uncurry (++) . ((show . length) &&& take 1)) . group) "1"
11:41:42 <lambdabot>  mueval: Prelude.read: no parse
11:42:01 <dcoutts> CosmicRay: thanks, having the input of experienced autoconf/make users is certainly useful.
11:42:26 <dcoutts> CosmicRay: to give us perspective and keep us honest :-)
11:42:54 <CosmicRay> dcoutts: Just to clarify, I am also not experienced with autoconf or automake ;-)
11:42:58 * CosmicRay sets up low expectations :-)
11:43:05 <dcoutts> heh heh
11:43:43 <dcoutts> CosmicRay: I've used autoconf/automake it a bit to implement a non-trivial Haskell build system that cabal currently cannot cope with. (gtk2hs)
11:43:43 <CosmicRay> in all seriousness, I try my absolute hardest to avoid autoconf and automake in my own software
11:43:55 <lilac> > (id &&& id) 1
11:43:56 <lambdabot>  mueval: Prelude.read: no parse
11:44:00 <CosmicRay> ah yes I imagine gtk2hs could be complex enough to require it
11:44:00 <lilac> impressive
11:44:07 <Myoma> :t (&&&)
11:44:07 <SamB> shapr: I thought VB.NET was the functional one ;-P
11:44:08 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
11:44:09 <Myoma> > (&&&)
11:44:10 <lambdabot>      Overlapping instances for Show (a b c -> a b c' -> a b (c, c'))
11:44:10 <lambdabot>       ar...
11:44:11 <Baughn> CosmicRay: Even to the point of writing your own configure scripts?
11:44:17 <Myoma> > (&&&) id id 1
11:44:18 <lambdabot>  mueval: Prelude.read: no parse
11:44:22 <Myoma> how odd
11:44:23 <dcoutts> CosmicRay: yes, but also shows up many of the problems with it.
11:44:26 <Myoma> is it doing this in two stages
11:44:31 <rwbarton> Myoma: I've complained about this a bit to gwern
11:44:33 <Myoma> one with and one without Control.Arrow
11:44:37 <rwbarton> Myoma: Yes, exactly
11:44:44 <Myoma> that is very odd ...
11:44:48 <rwbarton> Myoma: type checking with, then evaluated without
11:45:04 <Myoma> hm ...
11:45:09 <shapr> SamB: oh right!
11:45:12 <Myoma> ghci does it all in one movement
11:45:17 <SamB> rwbarton: what the???
11:45:35 <lilac> > let (&&&) f g x = (f x, g x) in iterate (concatMap (uncurry (++) . ((show . length) &&& take 1)) . group) "1"
11:45:36 <lambdabot>  ["1","11","21","1211","111221","312211","13112221","1113213211","31131211131...
11:46:12 <SamB> gwern: you've been a bad boy, gwern!
11:46:21 <Myoma> > let (&&&) f g x = (f x, g x) in describeSequence (map read $ take 30 $ iterate (concatMap (uncurry (++) . ((show . length) &&& take 1)) . group) "1")
11:46:22 <lilac> is mueval better than the old eval in any way?
11:46:23 <lambdabot>  Nothing
11:46:26 <Myoma> :(
11:46:38 <Myoma> @oies 1 11 21 1211 111221
11:46:38 <lambdabot> Look and Say sequence: describe the previous term! (method A - initial term i...
11:46:38 <lambdabot> [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,13211311123113...
11:46:45 <Myoma> > let (&&&) f g x = (f x, g x) in (map read $ take 30 $ iterate (concatMap (uncurry (++) . ((show . length) &&& take 1)) . group) "1")
11:46:46 <lambdabot>  mueval: Prelude.read: no parse
11:46:46 <lambdabot> mueval: [*** Exception: Prelude.read: no parse
11:46:54 <Myoma> why didn't that work..
11:47:04 <rwbarton> Myoma: bad defaulting
11:47:48 <rwbarton> > let (&&&) f g x = (f x, g x) in (map (read :: String -> Integer) $ take 30 $ iterate (concatMap (uncurry (++) . ((show . length) &&& take 1)) . group) "1")
11:47:49 * SamB wonders if the look-and-say sequence is reversible
11:47:50 <lambdabot>  [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,1321131112311...
11:48:07 <rwbarton> > let (&&&) f g x = (f x, g x) in describeSequence (map (read :: String -> Integer) $ take 30 $ iterate (concatMap (uncurry (++) . ((show . length) &&& take 1)) . group) "1")
11:48:09 <lambdabot>  Nothing
11:48:10 <Myoma> > let (&&&) f g x = (f x, g x) in describeSequence (map read $ take 12 $ iterate (concatMap (uncurry (++) . ((show . length) &&& take 1)) . group) "1")
11:48:12 <lambdabot>  Just "Look and Say sequence: describe the previous term! (method A - initial...
11:48:14 <Myoma> > let (&&&) f g x = (f x, g x) in describeSequence (map read $ take 13 $ iterate (concatMap (uncurry (++) . ((show . length) &&& take 1)) . group) "1")
11:48:16 <lambdabot>  Nothing
11:48:20 <Myoma> that's weird !
11:48:40 <Myoma> maybe it got truncated somewhere down the line ?
11:48:43 <lelf> > let (&&&) f g x = (f x, g x) in (map read $ take 30 $ iterate (concatMap (uncurry (++) . ((show . length) &&& take 1)) . group) "1") :: [Integer]
11:48:44 <lambdabot>  [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,1321131112311...
11:48:46 <rwbarton> Could be
11:49:21 <Myoma> > let (&&&) f g x = (f x, g x) in (map read $ drop 12 $ iterate (concatMap (uncurry (++) . ((show . length) &&& take 1)) . group) "1")
11:49:25 <lambdabot>  mueval: Prelude.read: no parse
11:49:27 <lambdabot> mueval: [*** Exception: Prelude.read: no parse
11:49:28 <Myoma> > let (&&&) f g x = (f x, g x) in (map read $ drop 12 $ iterate (concatMap (uncurry (++) . ((show . length) &&& take 1)) . group) "1") :: [Integer]
11:49:29 <lambdabot>  [1321132132111213122112311311222113111221131221,1113122113121113123112111311...
11:49:54 <lelf> > let (&&&) f g x = (f x, g x) in describeSequence ((map read $ take 30 $ iterate (concatMap (uncurry (++) . ((show . length) &&& take 1)) . group) "1") :: [Integer])
11:49:55 <lambdabot>  Nothing
11:50:05 <Myoma> @let let (f & g) x = (f x, g x)
11:50:05 <lambdabot>  Parse error
11:50:07 <Myoma> @ let (f & g) x = (f x, g x)
11:50:10 <Myoma> @let (f & g) x = (f x, g x)
11:50:12 <lambdabot> Defined.
11:51:02 <jleedev> @type \x -> fmap Just x `mplus` return Nothing
11:51:03 <lambdabot> forall a (m :: * -> *). (MonadPlus m, Functor m) => m a -> m (Maybe a)
11:51:16 <Myoma> :t (&&&)
11:51:17 <lambdabot>     Ambiguous occurrence `&&&'
11:51:17 <lambdabot>     It could refer to either `L.&&&', defined at <local>:3:0
11:51:17 <lambdabot>                           or `Control.Arrow.&&&', imported from Control.Arrow at State/L.hs:4:0-33
11:51:18 <Myoma> > (&&&)
11:51:19 <lambdabot>      Ambiguous occurrence `&&&'
11:51:19 <lambdabot>     It could refer to either `L.&&&', defined...
11:51:41 <Myoma> @type \x -> fmap Just x
11:51:42 <rwbarton> Is L.hs for @let-bindings?
11:51:42 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f (Maybe a)
11:51:58 <Myoma> I think so
11:51:59 <Myoma> :t (.)
11:52:00 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
11:52:03 <Myoma> :/
11:52:32 * shapr frobs hs-boot files
11:52:34 <jleedev> Myoma: this function converts io errors into maybes
11:53:00 <Myoma> hmmm
11:53:00 <dcoutts> Saizan: ok, want me to set up code.h.o:hbuild ?
11:53:31 <shapr> hej bringert!
11:53:42 <bringert> hej shapr
11:53:52 <shapr> How's code?
11:54:09 <lelf> > let (&&&) f g x = (f x, g x) in describeSequence $ take 10 $ (map read $ take 30 $ iterate (concatMap (uncurry (++) . ((show . length) &&& take 1)) . group) "1")
11:54:11 <lambdabot> Terminated
11:54:29 <lelf> > let (&&&) f g x = (f x, g x) in describeSequence $ take 10 $ (map read $ take 30 $ iterate (concatMap (uncurry (++) . ((show . length) &&& take 1)) . group) "1")
11:54:31 <lambdabot>  Just "Look and Say sequence: describe the previous term! (method A - initial...
11:54:48 <dmwit_> method A?
11:54:51 <yitz> dcoutts: in cabal can one specify a list of the source files to be built, without using --make?
11:54:54 <lilac> > let (&&&) f g x = (f x, g x) in take 1 . drop 30 $ iterate (concatMap (uncurry (++) . ((show . length) &&& take 1)) . group) "1"
11:54:55 <lambdabot>  ["13211321322113311213212312311211131122211213211331121321123123211231131122...
11:55:23 <Myoma> > let (&&&) f g x = (f x, g x) in '4' `elem` (concat . take 1 . drop 30 $ iterate (concatMap (uncurry (++) . ((show . length) &&& take 1)) . group) "1")
11:55:24 <lambdabot>  False
11:55:25 <dcoutts> yitz: I'm not sure I understand the question
11:55:26 <rwbarton> > let (&&&) f g x = (f x, g x) in describeSequence (map read $ take 12 $ iterate (concatMap (uncurry (++) . (take 1 &&& (show . length))) . group) "1")
11:55:27 <lambdabot>  Just "Describe the previous term! (method B - initial term is 1)."
11:55:34 <Myoma> > let (&&&) f g x = (f x, g x) in '4' `elem` (concat . take 1 $ iterate (concatMap (uncurry (++) . ((show . length) &&& take 1)) . group) "1")
11:55:35 <lambdabot> Terminated
11:55:42 <Myoma> > let (&&&) f g x = (f x, g x) in '4' `elem` (concat $ iterate (concatMap (uncurry (++) . ((show . length) &&& take 1)) . group) "1")
11:55:47 <lilac> > let f [] = Nothing; f (a:b:c) = Just (replicate (read [a]) b, c) in iterate (concat . unfoldr f) "1321132132111213122112311311222113111221131221"
11:55:49 <lambdabot>  mueval: Prelude.read: no parse
11:55:49 <lambdabot> mueval: ["13211321321112131221123113112221131...
11:55:55 <Myoma> is there ever a 4 in that sequence?
11:55:57 <lambdabot>  thread killed
11:56:02 <yitz> dcoutts: e.g., if the file names are not the same as the names of the modules inside. ghc can do that. does cabal support it?
11:56:25 <dcoutts> yitz: of you mean ghc's main-is thing ?
11:56:26 <lilac> > let f [] = Nothing; f (a:b:c) = Just (replicate (read [a]) b, c) in iterate (concat . unfoldr f) "31131211131221"
11:56:29 <dcoutts> of/oh
11:56:36 <lilac> Myoma: no, there's never a 4.
11:56:40 <jleedev> Myoma: If there's a 4, that meant the previous row had an 'nnnn', which can't happen
11:56:40 <Myoma> Why?
11:56:42 <rwbarton> Myoma: no.  To get the first 4, you need a sequence xxxx, but then two of those x's are the digits appearing in consecutive blocks, which is impossible
11:56:50 <dcoutts> yitz: afaik, ghc --make expects the names to correspond to the module names
11:56:54 <lambdabot>  thread killed
11:57:07 <MarcWeber> I remmember there was an extension letting you write something like [ func | .........\n \n \n \n ] so that func was used to create some value ? Do you recall the name so that I can look it up?
11:57:14 <Myoma> ah !
11:57:20 <yitz> dcoutts: mm not really. if I say ghc Foo.hs, then Foo.hs is allowed to have "module Bar where..." inside
11:57:23 <dmwit_> rwbarton: What if it was xxx x, i.e. there were hundreds of x in a row?
11:57:25 <dcoutts> yitz: so, no, .cabal files specify module names, and we rely on the standard convention to find the source modules for those.
11:57:29 <dmwit_> say, 333 3's...
11:57:52 <rwbarton> dmwit_: Well yes, you do have to phrase the argument more carefully
11:57:55 <lilac> dmwit_: there's never more than 3 of any digit in a row, unless the initial sequence contains same.
11:58:10 <yitz> dcoutts: so if I want to organize the directory structure differently - often desirable in large projects - then cabal is out?
11:58:57 <lelf> MarcWeber: [ x^2 | x <- [1..10] ] ?
11:59:14 <dcoutts> yitz: if we wanted to specify file names irrespective of module name then you'd need to specify both the module names *and* the original source files (not sure about pre-processors we can probably chase them even if you only give .hs files)
11:59:49 <dcoutts> yitz: ooi, what is wrong with the standard convention for large projects ?
12:00:44 <MarcWeber> lelf: Not at all. It took a string such as an embedded language syntax and checks the given multiline string using the function taking its result
12:00:45 <dcoutts> yitz: so ghc --make may be able to get away with just the file names but we need the module names for the exposed modules anyway, as that's used for the package registration.
12:00:57 <yitz> dcoutts: e.g. if I want to organize my version control by team, let each team check out the files they need. easiest to organize by directories.
12:01:12 <mauke> MarcWeber: quasiquoting?
12:01:17 <dcoutts> yitz: you can of course use as many source search dirs as you like
12:01:19 <lelf> MarcWeber: something to template haskell
12:01:31 <MarcWeber> mauke ah - thanks !
12:01:53 <yitz> dcoutts: how hard would it be to add an option to specify both separately in cabal?
12:02:03 <dcoutts> yitz: eg team1/Foo/Bar.hs, team2/Baz.hs
12:02:04 <jleedev> > "a" <|> "b" ++ "c" `mplus` "d"
12:02:06 <lambdabot>  "abcd"
12:02:11 <yitz> yeah
12:02:22 <Myoma> :t (<|>)
12:02:25 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
12:02:31 <Myoma> @instances Alternative
12:02:31 <lambdabot> Couldn't find class `Alternative'. Try @instances-importing
12:02:35 <dcoutts> yitz: so we can already do that of course, just with hs-source-dirs: team1 team2
12:02:51 <jleedev> i'm wondering why there's no MonadPlus m => Alternative m
12:03:15 <Saizan> dcoutts: yeah, it's better to use a project rather than putting it under ~Saizan, i think
12:03:33 <dcoutts> Saizan: if you want patches from others, yes.
12:03:39 <yitz> I may want team1 to see a subtree of the Foo tree and team2 a different overlapping one.
12:04:06 <yitz> it could be done that way, but it can get messy
12:04:10 <dcoutts> yitz: I'm not sure. There's several things to think about. How to specify it in the .cabal file, how to check that the exposed/other module names are consistent with the files.
12:04:22 <yitz> consistent?
12:04:43 <dcoutts> yitz: files: team/Foo.hs; exposed-modules: Bar
12:04:53 <dcoutts> yitz: how do we know that these things are 1:1 without checking ?
12:04:54 <yitz> that's OK.
12:05:09 <dcoutts> yitz: so file a ticket, say what you need exactly and suggest how you might like to specify it.
12:05:09 <yitz> ghc will let you know when you try to build :)
12:05:27 <dcoutts> yitz: huh? it can't, it does not have enough info.
12:05:47 <yitz> if it doesn't find what it's looking for, it will let you know.
12:06:07 <dcoutts> yitz: but it needs less than we do
12:06:38 <dcoutts> yitz: you're providing a bunch of source files and claiming it provides a bunch of module names, names which are then exposed in the package registration info.
12:06:42 <yitz> true. do you think that consistency check is essential?
12:06:59 <dcoutts> yitz: we'll make broken packages otherwise
12:07:24 <yitz> so that is a cabal guarantee?
12:07:39 <dcoutts> yitz: no, but people will blame us regardless :-)
12:07:44 <yitz> hehe
12:08:19 <dcoutts> yitz: we may need to know the exact mapping anyway, since the .hi files must follow the standard layout for ghc to be able to find them.
12:08:27 <dcoutts> yitz: once the package is installed
12:08:57 <yitz> well, in ghc, you give it a list of files that may or may not be complete. if not complete, then ghc goes off looking for it needs by mapping module names into filesystem space, based at concat . -i.
12:09:15 <yitz> so that logic would have to be re-implemented in cabal?
12:09:17 <dcoutts> yitz: and once cabal does batch mode invocation of ghc, rather than ghc --make then we'll definitely have to know
12:09:48 <yitz> there is a plan for that? then, how are we checking for consistency?
12:09:50 <dcoutts> yitz: though by that time we'll be able to grok module headers, pragmas and imports. So we will be able to check. But that stuff is a ways off.
12:10:07 <yitz> oh i see
12:10:37 <dcoutts> yitz: the problem is not that ghc --make might complain. But there are cases where it'll work fine and we'll still make a broken package I think.
12:10:45 <yitz> right now if I do import Foo.Bar but it's not there, cabal will catch that?
12:10:54 <Myoma>  http://www.cs.mu.oz.au/~sulzmann/chameleon/download/haskell.html
12:10:56 <lambdabot> Title: A Haskell Programmer's Guide to Chameleon
12:11:22 <sjanssen> yitz: why do you want file names that don't match module names?  Won't that make it harder for humans to navigate your source?
12:11:25 <guenni> how do I create a ByteString literal?
12:11:45 <dzlk> is it possible to set default values for haddock commandline options? (I'm interested in --odir and --css in particular)
12:12:12 <dons_> guenni: pack "foo"
12:12:12 <dcoutts> yitz: the problem is if you say that you want to build the module contained in Foo.hs, but expose the module Bar then if Foo.hs does not contain Bar then we've made an incorrect package registration file and ghc --make knows nothing about that and cannot help us.
12:12:20 <guenni> thx
12:12:28 <yitz> sjanssen: no. projects can have their own conventions that are most convenient for the particular project. this is one of the pitas of Java that it forces you to use up the filesystem tree in its own way.
12:14:24 <yitz> dcoutts: you mean if none of my files contain bar. I'm not saying that Foo.hs in particular was supposed to contain it, just that it exists somewhere. that problem already exists now, doesn't it?
12:14:36 <dcoutts> yitz: no, it does not exist now.
12:15:06 <yitz> if I say import Foo.Bar in a module, but then don't supply Foo.Bar anywhere, what happens?
12:15:16 <dcoutts> yitz: because we look source files for all the exposed and other modules
12:15:36 <yitz> we parse all import statements already now?
12:15:40 <dcoutts> yitz: if you do that then of course ghc --make fails
12:15:48 <dcoutts> so you're still protected
12:15:58 <yitz> so why is this any worse?
12:16:17 <dcoutts> yitz: rather than getting to the stage of installing and registering a package and then discovering when you try to use it that it's broken
12:17:05 <dcoutts> yitz: the package registration info will say that the package exposes a module, but there will be no corresponding .hi file.
12:17:20 <yitz> so your case is that in cabal I claim to provide Bar, but then don't provide it?
12:17:43 <dcoutts> yitz: right. I guess that's one way to check it is to look for a .hi file after ghc --make is done.
12:17:54 <dcoutts> that'd let us fail at build time
12:18:22 <yitz> right. as you say, best is to be able to parse dependencies out of the sources.
12:18:38 <yitz> but that's much harder
12:19:46 <dcoutts> yitz: yeah, we'll do that eventually, but not yet. Saizan's GSoC code does exactly that.
12:20:21 <yitz> ok. nice.
12:20:29 <dcoutts> yitz: ooi, what layout are you trying to use that does not correspond to src dirs + standard convention ?
12:22:09 <dcoutts> yitz: so you'll file a ticket?
12:22:11 <yitz> dcoutts: I'm not at the moment, but it's certainly something I've done (in other languages) in the past when managing multiple teams. It's a great tool to keep VC under control, so people don't mess up other's work.
12:23:01 <sjanssen> yitz: you use a source directory for each team?
12:23:24 <yitz> dcoutts: except in Java it was a big pain. I thought Haskell was stuck in Java's rut, but really it's not. You can do the Java thing when it's convenient - and sometimes it is certainly - but it's also smart enough to be flexible. which is the best of both worlds.
12:24:26 <dcoutts> yitz: I'm still not exactly sure what you mean. What convention does not fit when we allow multiple src dirs?
12:24:33 <chrisdone> keep keeping version control under control under control
12:24:47 <yitz> sjanssen: yeah. well, virtual teams really. when working on system X, you check out a whole directory tree that allows you to work on that and build and check-in etc. without work on other subsystems messing you up.
12:25:03 <dcoutts> yitz: I mean I know there are conventions that would not match, but I'm just wondering concretely what you'd want that does not fit.
12:25:28 <sjanssen> yitz: why can't each team directory have fully qualified module file names in them?  I think  Cabal already supports this
12:25:39 <dcoutts> sjanssen: yes it does
12:27:17 <jn> anyone got a term for a linked "list" of heterogeneously typed elements?
12:27:19 <sjanssen> yitz: also, Cabal won't be able to build the subtree you check out anyway (unless you put a dummy .cabal in each subtree)
12:27:21 <yitz> sjanssen, dcoutts: well, for example, let's say team1/Foo/Bar need to be the same as team2/Foo/Bar, but team1/Foo/Baz and team2/Foo/Baz need to be different branches. that kind of thing.
12:27:24 <edwardk> jn: HList
12:27:36 <edwardk> jn: thats what oleg called it anyways ;)
12:27:55 <jn> edwardk: doesnt the term "list" imply homogeneity?
12:28:12 <edwardk> h in that case i believe stands for heterogeneous ;)
12:28:20 <sjanssen> yitz: sounds like a job better filled by source control branches
12:28:23 <dcoutts> yitz: that will not work. The module names cannot overlap.
12:28:26 <jn> edwardk: ok :)
12:29:24 <yitz> dcoutts: yes, you arrange for only one of each module of course.
12:29:59 <yitz> dcoutts: the idea is to have different cabal files for each team, that lists what goes into that team's environment.
12:30:14 <dcoutts> yitz: ohh, then none of this is a problem at all then
12:31:04 <dcoutts> yitz: you just stick the .cabal file under team1/ or 2/
12:31:08 <yitz> sjanssen: yeah with darcs you would use branches - a bit of a pain since darcs doesn't support nested repos. In cvs-style vc these are virtuals. no idea how git handles this - also probably a brach thing.
12:31:18 <yitz> branch
12:32:13 <yitz> uh - wait - they were called "modules" in cvs. wow, it's been a long time since I used cvs/svn!
12:32:41 <Heffalump> with darcs you just need to make sure that patches don't straddle the team1 and team2 directories
12:32:51 <SamB> uh, modules are something else ;-)
12:33:29 <yitz> SamB: ah, relief, back to Haskell-land.
12:33:35 <dcoutts> yitz: I think we must be talking at cross purposes or something, the things we understand you to mean can already be done so I expect we're not fully understanding what you need.
12:35:10 <yitz> dcoutts: mm, well, dividing into projects with separate cabal files of course works. But I'm saying that for complex VC setups, you don't want to have to tie down your directory structure to the module structure, it's convenient to use that for other things.
12:36:40 <dcoutts> yitz: but each sub-tree seems to follow the standard convention, so the question is if using the existing src search dir mechanism is enough.
12:37:13 <Stinger> anyone happen to use hdbc with sqlite?
12:37:23 <dcoutts> yitz: I mean you do not seem to be doing anything crazy like Foo.hs containing Bar, just putting Foo.hs under team1/ etc
12:37:51 <dcoutts> yitz: and you also seem to be using the convention that '.' in module names map to '/' in file name.
12:38:39 <dcoutts> yitz: so at first appearance it does not look like you need the full generality of specifying file names separate from module name. The hope is that src search dirs is enough.
12:39:06 <yitz> dcoutts: not necessarily. let's say my teams form a tree, and I want to organize their files in directories that follow that structure. so then I would like to have, Foo.Bar in Foo.Bar.hs instead of Foo/Bar.hs, or even some other naming convention if it fits my project better.
12:39:55 <dcoutts> yitz: yeah, so we could support mapping '.' to '.', but that does not seem to be the critical thing in your examples
12:40:02 <sjanssen> dcoutts: it would be nice to support the Foo.Bar.hs notation in Cabal once it has the required module parsing stuff
12:40:19 <dcoutts> sjanssen: aye maybe so, jhc does it I know.
12:40:24 <TomMD> Setting up a private hackage clone looks like it is a rarly traveled and not smoothed path.  Would patches that help smooth this path be accepted by the relative projects (ex: cabal-install)?
12:41:14 <dcoutts> TomMD: the hackage-server is trivially installable with cabal-install
12:41:29 <yitz> dcoutts: that would help. don't you agree though that any dependency between module names and filesystem conventions seems a bit ad hoc? Having some default convention is OK as a simple default, but if it's not too hard, the nicest thing would be to decouple them completely.
12:41:47 <dcoutts> TomMD: the existing hackage-script is of course much harder as it relies on apache and the layout of files and cgi progs.
12:41:58 <yitz> dcoutts: (like for most other programming languages)
12:42:20 <TomMD> dcoutts: Yes, but someone was working on a happs version, weren't they?  Or was that just an IRC conversation?
12:42:36 <dcoutts> TomMD: hackage-server is the happs version, it's on code.h.o
12:42:45 <dcoutts> TomMD: it's not quite feature complete
12:43:08 <TomMD> hummm... ok.  Sounds like something I should play with.  I don't see a hackage-server package, am I blind?
12:43:12 <TomMD> @hackage hackage-server
12:43:12 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hackage-server
12:43:18 <TomMD> guess so
12:43:31 <dcoutts> yitz: yes, in principle people can use non-standard conventions, but few do, and the thing I've not understood with your examples is why src dirs are not enough.
12:43:48 <dcoutts> TomMD: it's not on hackage yet
12:43:50 <TomMD> humm, 404.  What does this @hackage package do then, just construct a url?
12:43:57 <Deewiant> @hackage asdf
12:43:58 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/asdf
12:43:58 <dcoutts> @hackage foobarbaz
12:43:58 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/foobarbaz
12:44:02 <Deewiant> apparently yes
12:46:37 <Myoma> @wiki hackgae
12:46:38 <lambdabot> http://www.haskell.org/haskellwiki/hackgae
12:46:52 <TomMD> Myoma:
12:46:52 <TomMD> @go hackage-server
12:46:54 <lambdabot> http://code.haskell.org/hackage-server/
12:46:54 <lambdabot> Title: Index of /hackage-server
12:47:08 <dcoutts> yitz: my point is, I'd like to understand the use case, because if we can avoid adding a mechanism that nobody is going to use then we win. The general mechanism would require a lot more info in the .cabal file and be less convenient, so if we can concisely express the thing complex project need just by playing with the src dirs then everyone wins.
12:47:50 <dcoutts> sjanssen: do you know what the rule is to do the '.' convention with just a linear number of stats rather than 2^n?
12:48:20 <dcoutts> sjanssen: something like, we allow Foo/Bar.Baz but not Foo.Bar/Baz right ?
12:48:57 <sjanssen> dcoutts: I don't think that is enough to make it O(n)
12:49:26 <sjanssen> actually, yes it is
12:49:42 <dcoutts> sjanssen: good, I'm not going mad :-)
12:50:15 <yitz> dcoutts: playing with the src dirs is on the other hand much more complicated and inconvenient from the project management pov. it will be used only for big projects - but it would be nice if Haskell in general could scale for those. obviously. we'd only like to do it at this stage if a) it's not too hard to do b) it doesn't affect the usual simple workflow for small to medium projects.
12:50:24 <Heffalump> you can support the general case in O(n) too, if the user doesn't actually create enough directories to make the O(2^n) search necessary.
12:50:45 <Heffalump> Because you can terminate parts of the search space early when you don't find the directory in question.
12:51:17 <Heffalump> OK, not O(n), O(something * n) where something depends on how difficult the user wants to be
12:51:32 <sjanssen> dcoutts: I suppose you could also just recursively stat all files, then query that tree
12:51:56 <sjanssen> then the user only pays for the size of the source tree, which seems fair
12:52:22 <dcoutts> sjanssen: that's an optimisation, we still need to know which files we looked at first, as they are shadow positions we have to check for again on rebuilds.
12:53:09 <Deewiant> n isn't exactly big anyway (in 99% of cases) so does it really matter
12:53:21 <dcoutts> yitz: I'm sorry, I think we need to talk about much more concrete examples for me to see why it's less convenient or does not work.
12:53:54 <dcoutts> Deewiant: n does not need to be big if the algorithm is 2^n :-)
12:54:26 <Deewiant> dcoutts: I think it's very rare for n to go even above 5
12:54:33 <Deewiant> and 2^5 isn't that much
12:56:27 <yitz> dcoutts: I'll have to think it through - look back at some old projects. I don't think it's "does not work" - just less convenient. but for scaling - that's significant. I'm not sure how important it is for Haskell to support that kind of scale now though.
12:56:54 <yitz> dcoutts: Supporting the dots thing is already a help - but a bit weird because it's different than any compiler.
12:57:17 <dcoutts> yitz: great, if you could email some examples to cabal-devel I think that'd really help people to understand the need.
12:57:30 <dcoutts> yitz: jhc does it actually
12:57:40 <yitz> what, the dots?
12:57:58 <yitz> or full generality?
12:59:03 <dcoutts> yitz: jhc supports mapping '.' in module name to '.' in file name
13:00:30 <yitz> dcoutts: as an additional way to search for missing modules, but still supporting general file names? or does it enforce that scheme?
13:01:18 <dcoutts> yitz: I've no idea if it works with arbitrary user-specified mappings but it certainly supports '.' in addition to the standard '/' convention.
13:04:38 <newsham> anyone here use HsOpenSSL?
13:05:17 <mmorrow> > upsidown "hello"
13:05:18 <lambdabot>  ollǝɥ
13:05:36 <Deewiant> ?ty upsidown
13:05:37 <newsham> I cant get the "readPublicKey" function to work, even though the "readPrivateKey" function works perfectly for me
13:05:37 <lambdabot> [Char] -> Expr
13:05:41 <skorpan> > upsidown "don't fear the reaper"
13:05:42 <lambdabot>  ɹǝbɐǝɹ ǝɥʇ ɹɐǝɟ ʇ,uop
13:05:49 <skorpan> awesome
13:05:54 <Heffalump> hehe
13:05:59 <newsham> ?src upsidedown
13:05:59 <lambdabot> Source not found. Just try something else.
13:06:08 <skorpan> > upsidown "ɹǝbɐǝɹ ǝɥʇ ɹɐǝɟ ʇ,uop"
13:06:09 <lambdabot>  bon,ʇ ɟǝɐɹ ʇɥǝ ɹǝɐqǝɹ
13:06:09 <mmorrow> hehe
13:06:13 <skorpan> lol
13:06:16 <Deewiant> fail
13:06:20 <_zenon_> aawww fail
13:06:24 <Heffalump> ?src upsidown
13:06:24 <lambdabot> Source not found. Sorry.
13:06:25 <newsham> p <-> b ?
13:06:25 <mmorrow> i'll hpaste the src
13:06:37 <skorpan> it's not "bijective"? is that the word for it?
13:06:38 <Deewiant> > upsidown "pbd"
13:06:39 <lambdabot>  pqb
13:06:42 <_zenon_> idempotent
13:06:47 <yitz> newsham: I wish Network.HTTP used it.
13:06:50 <mmorrow> i did it with @let
13:06:54 <mmorrow> in /msg
13:06:58 <Heffalump> self-inverse, surely.
13:07:14 <mmorrow> yeah, i only have a utf8 /encode/ one-liner so far
13:07:23 <Heffalump> it does form a Galois connection with itself, I think.
13:07:52 <Heffalump> or it would if it was correct, which it apparently isn't
13:08:18 <newsham> > upsidedown "pq"
13:08:19 <lambdabot>  mueval: Prelude.read: no parse
13:08:20 <Cale> 'involution'
13:08:29 <skorpan> > upsidown "pq"
13:08:30 <mmorrow> well, it does the lookup with utf32 chars, then encodes to utf8 to show, /and/ the catch is that it's using the fact that the Expr fun function actually lets utf8 through
13:08:31 <lambdabot>  db
13:08:36 <yitz> hi Cale
13:08:38 <Cale> hi
13:08:43 <skorpan> wait, that's not right
13:08:46 <newsham> exactly
13:08:53 <mmorrow> skorpan: heh, nice catch.
13:08:55 <yitz> did you hear about what happened to our bots today?
13:09:07 <yitz> Cale: I sent you an email
13:09:07 <Cale> no
13:09:10 <Cale> oh
13:09:19 <Cale> I'll check my mail then :)
13:09:35 <yitz> Cale: a gmail account.
13:09:51 <dcoutts> Saizan: hbuild project space now on code.h.o. You and I are initial group members.
13:11:37 <Cale> oh, right, fun isn't meant to be imported, but I'm not sure mueval can import anything less than a full module. Then again, I think it's probably best if newlines in text that plugins print don't end up just creating new commands.
13:12:04 <Cale> (there must be a broken abstraction there, if there's one at all...)
13:12:19 <yitz> Cale: no need to print any control characters at all
13:12:48 <_zenon_> someone developing on lb that fixed the duplicate output issue?
13:12:59 <mmorrow> Cale: but utf8 is ok :)
13:13:20 <rwbarton> surely "@help list" and so on should be able to print multiple lines
13:13:28 <yitz> mmorrow: yeah fun is actually really nice, if it can be made safe.
13:13:48 <yitz> (oh, oh, don't quote me on that)
13:14:19 <mmorrow> yitz: i'll put that on my todo list (seriously) :)
13:14:30 <mmorrow> here's the src for upsidown http://hpaste.org/10049
13:15:04 <mmorrow> (the b and d upsidown are the opposite of what they should be (oops))
13:15:13 <rwbarton> > upsidown "()"
13:15:14 <lambdabot>  mueval: Prelude.read: no parse
13:15:18 <yitz> Cale, rwbarton: hmm, yeah, \n can be useful - but if it is allowed, we must at least add a space after each \n.
13:15:40 <Cale> It shouldn't allow one to start new IRC commands, surely.
13:15:52 <Olathe> mmorrow: Are you interested in a shortened version of the utf8 one-liner ?
13:16:03 <mmorrow> Cale: heh, definitely not :)
13:16:10 <mmorrow> Olathe: bring it on!
13:16:21 <yitz> Cale: right. that needed \SOH though.
13:16:37 <yitz> Cale: cross-bot loops is another problem
13:16:40 <Olathe> mmorrow: I'm still working on it, but I've gotten it down a bit.
13:17:24 <Olathe> mmorrow: setup=take 1.reverse.snd.unzip.flip zip(zip[18,12,6,0][240,224,192,0]).snd.test
13:17:30 <Olathe> That's what I've gotten so far.
13:17:40 <mmorrow> Olathe: cool. i wanna one-linerify the decode too... it'd be sweet if we got utf8 enc/dec as nice compact one-liners
13:18:18 <mmorrow> Olathe: nice
13:21:26 <Vq^> i seem to recall that there were some paper that compared the performance between a couple of concurrent haskell programs and also showed the different STM optimizations, i don't seem to find it now, does it ring a bell for someone else?
13:23:21 <Cale> > fun "\nhello"
13:23:29 <lambdabot>   Add a type signature
13:23:36 <yitz> :: Expt
13:23:37 <Deewiant> > fun "\nhello" :: Expr
13:23:39 <yitz> :: Expr
13:23:45 <lambdabot>   hello
13:23:58 <Olathe> > fun "How are you today ?" :: Expr
13:24:00 <yitz> > fun "hello\ngoodbye"
13:24:05 <yitz> > fun "hello\ngoodbye" :: Expr
13:24:08 <lambdabot>   How are you today ?
13:24:09 <Cale> > fun "\n\SOHACTION is p0wned\SOH" :: Expr
13:24:10 <lambdabot>   Add a type signature
13:24:18 <lambdabot>   hello
13:24:20 <lambdabot>   ACTION is p0wned
13:24:24 <yitz> he
13:24:32 <Olathe> > fun " \n\SOHACTION is p0wned\SOH" :: Expr
13:24:38 <lambdabot>  ACTION is p0wned
13:24:42 <Deewiant> filter (not.(< 0x20).ord) ? :-P
13:24:46 <Olathe> Ahh. Does it strip it now ?
13:24:57 <lucca> so why is the maybe variant Just, rather than like... Actually
13:24:58 <yitz> > fun "hello\ngoodbye" :: Expr
13:25:00 <Cale> filter (\x -> isSpace x || not (isControl x))
13:25:06 <lambdabot>   hello
13:25:09 <Olathe> Ahh, cool.
13:25:14 <Deewiant> lucca: that's Just what it is. ;-)
13:25:14 <yitz> Cale?
13:25:21 <Cale> It also adds an extra space to the beginning of every line it emits.
13:25:36 <lucca> Deewiant: heh
13:25:37 <Cale> This does mean that there are places where it's adding 2 now, but I think it's a bit safer.
13:26:14 <Olathe> Well, I'm happy that we can emit strings without escaping now.
13:26:19 <rwbarton> > fun "\8704" :: Expr
13:26:20 <lambdabot>   mueval: Prelude.read: no parse
13:26:20 <lambdabot>  mueval: Enum.toEnum{Word8}: tag (8704) is o...
13:26:42 <Olathe> > fun "\226\136\128" :: Expr
13:26:43 <lambdabot>   
13:26:45 <rwbarton> ah
13:27:20 <yitz> Cale: it just truncates when it hits a \n?
13:27:33 <Cale> > fun "手すト"
13:27:34 <lambdabot>   Add a type signature
13:27:34 <mmorrow> Cale: did you kill utf8 output for fun as well?
13:27:38 <Cale> > "手すト"
13:27:40 <lambdabot>   "\25163\12377\12488"
13:27:47 <rwbarton> mmorrow: no, see ^^Olathe
13:27:48 <Cale> > fun "手すト" :: Expr
13:27:49 <lambdabot>   mueval: Prelude.read: no parse
13:27:49 <lambdabot>  mueval: Enum.toEnum{Word8}: tag (25163) is ...
13:27:55 <mmorrow> > "∀"
13:27:56 <lambdabot>   "\8704"
13:28:01 <mmorrow> > fun "∀" :: Expr
13:28:03 <lambdabot>   mueval: Prelude.read: no parse
13:28:03 <lambdabot>  mueval: Enum.toEnum{Word8}: tag (8704) is o...
13:28:06 <Cale> Huh, I don't know why that's not working.
13:28:15 <mmorrow> > fun (utf8s "∀") :: Expr
13:28:16 <lambdabot>   
13:28:22 <mmorrow> damn
13:28:26 <rwbarton> oh, hmm
13:28:28 <Cale> > fun (utf8s "手すト") :: Expr
13:28:30 <lambdabot>   
13:28:31 <Deewiant> > toEnum 25163 :: Word8
13:28:32 <lambdabot>   mueval: Prelude.read: no parse
13:28:32 <Cale> heh
13:28:32 <lambdabot>  mueval: *** Exception: Enum.toEnum{Word8}: ...
13:28:38 <mmorrow> > utf8s "∀"
13:28:39 <lambdabot>   "\226\136\128"
13:28:44 <Cale> Yeah... that didn't quite work there :)
13:28:53 <mmorrow> heh
13:29:07 <mmorrow> > (utf8s . utf8s) "∀"
13:29:08 <lambdabot>   "\195\162\194\136\194\128"
13:29:39 <Capso> Cale: Get your new row yet?
13:30:03 <mmorrow> Cale: i think it's getting utf8 encoded one two many times or something weird like that
13:30:05 * rwbarton got a second row, then got bored
13:30:17 <mmorrow> heh, *one s/two/too/ many ...
13:30:25 <yitz> mauke ping
13:30:30 <mauke> yitz: pong
13:30:33 <Cale> Capso: no
13:31:07 <yitz> Cale fixed \bot so it won't be shooting at preflex anymore if you want to start it up
13:31:23 <mauke> preflex: seen preflex
13:31:24 <preflex>  what
13:31:40 <Capso> Cale: I got mine. :D
13:32:40 <Olathe> > b
13:32:41 <lambdabot>   b
13:32:53 <Olathe> What is b ?
13:32:58 <Cale> It is an Expr
13:32:59 <mauke> > c
13:33:00 <lambdabot>   c
13:33:02 <Cale> :t b
13:33:03 <lambdabot> Expr
13:33:04 <Deewiant> > foldr1 f (repeat b)
13:33:05 <lambdabot>   f b (f b (f b (f b (f b (f b (f b (f b (f b (f b (f b (f b (f b (f b (f b (...
13:33:07 <mauke> > [a,b,c,d]
13:33:08 <lambdabot>   [a,b,c,d]
13:33:19 <Cale> :t f
13:33:21 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
13:33:31 <Deewiant> :t b
13:33:33 <lambdabot> Expr
13:33:42 <sjanssen> preflex: seen gwern
13:33:42 <preflex>  gwern was last seen on #haskell 6 hours, 14 minutes and 45 seconds ago, saying: ah well. time to go
13:34:07 <Cale> Basically, they're values with clever instances of Show, as well as a number of other classes.
13:34:12 <Cale> > a + b
13:34:13 <lambdabot>   a + b
13:34:36 <Cale> > gcd 15 x
13:34:52 <lambdabot>   thread killed
13:34:58 <EvilTerran> (^) doesn't work, either
13:35:01 <gwern> sjanssen: yes?
13:35:05 <Deewiant> > a ^ 2
13:35:07 <lambdabot>   a * a
13:35:09 <Deewiant> ;-)
13:35:15 <EvilTerran> with an Expr on the right, i mean
13:35:17 <dons> $factorial *= $_ for 2..$x;     --   foldl (*) 1 [2..x]
13:35:20 <EvilTerran> > 2 ^ x
13:35:20 <yitz> > a ++ a
13:35:21 <Cale> > gcd 15 18 :: Expr
13:35:22 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
13:35:23 <lambdabot>  Terminated
13:35:23 <lambdabot>  Terminated
13:35:24 <dons> that infix `for` is interesting
13:35:30 <Cale> > gcd 15 18 :: Expr
13:35:32 <lambdabot>   abs 18 `rem` (abs 15 `rem` abs 18)
13:35:51 <Cale> > abs 18 `rem` (abs 15 `rem` abs 18)
13:35:53 <Deewiant> dons: isn't it just `map`? (or mapM or mapM_...)
13:35:53 <lambdabot>   3
13:36:08 <dons> Deewiant: foldl in this case, scalar context.
13:36:10 <EvilTerran> dons, yeah, the infix control structures perl has are a curious little quirk
13:36:16 <sjanssen> gwern, Cale: is lambdabot in a releasable state?
13:36:16 <dons> but we can't easily write the same syntax,
13:36:24 <dons>   (*) `for1` [2..n]
13:36:30 <sjanssen> it would be really nice to have a real release on hackage
13:36:33 <Deewiant> dons: isn't that ($factorial *= $_) for 2..$x
13:36:39 <dons> yep
13:36:45 <Deewiant> dons: which means it's just mapM_, modifying an IORef
13:36:50 <rwbarton> > (*) `foldl1` [1..5]
13:36:52 <lambdabot>   120
13:36:54 <dons> well, you could htink of it that way.
13:36:55 <EvilTerran> "if" and "while" can be written the same way can be written the same way
13:36:58 <dons> but its really a fold :)
13:37:04 <Deewiant> :-P
13:37:09 <gwern> sjanssen: dunno
13:37:11 * EvilTerran wonders how that got typed twice
13:37:27 <gwern> sjanssen: it has a ton of bugs all over, so I guess the question is whether the bugs are acceptable
13:37:39 <ziman> > "\"if\" and \"while\" " ++ cycle "can be written the same way "
13:37:41 <lambdabot>  Terminated
13:37:45 <ziman> :(
13:37:47 <gwern> also, I'm blocking on hs-source-exts for updated mueval
13:37:51 <sjanssen> gwern: are these new bugs?
13:38:04 <mauke> $factorial = eval join '*', 1..$x;
13:38:27 <gwern> sjanssen: it's hard to tell. I never know whether Cale is up to date or not, and people complain all the time
13:39:01 <sjanssen> gwern: are you speaking mostly to @eval/mueval bugs, or is there something else?
13:39:42 <gwern> sjanssen: both :( for example, did the double print get fixed?
13:39:46 <gwern> I dunno
13:39:53 <gwern> supposedly @let was fixed but I haven't tested it
13:40:12 <gwern> and is Cale running lambdabot from ~/ to test those patches out? I suspect he isn't
13:40:17 <chrisdone> for a PEG grammar, foo <- &bar mu, bar <- 'a' 'b' 'c', mu <- 'a' 'b' 'c' 'd', for input “abcd” should the &bar parse the “abc” but not consume input, and then mu consumes the whole “abcd”?
13:40:22 <yitz> sjanssen: Cale needs to "put out fires" all the time on #haskell. that probably make darcs a bit of a mess.
13:40:38 <Cale> gwern: I tend to just apply patches and hope that all goes well :)
13:40:39 <Saizan> gwern: you're not releasing a new mueval because of hint?
13:40:57 <gwern> Saizan: no, because of haskell-src-exts I said
13:41:10 <sjanssen> gwern, yitz: well, as far as I know, the lambdabot on hackage doesn't even build
13:41:11 <Cale> gwern: I do try to stay up to date with mueval and the related tools, but it's good if you let me know when new versions are up :)
13:41:20 <gwern> mueval uses it thanks to mmorrow for parsing stuff and needs stff in -exts darcs
13:41:24 <gwern> Cale: I do!
13:41:33 <gwern> Cale: for example, I added Control.Arrow to default scope, did you pull that?
13:41:40 <Cale> I believe that I did :)
13:41:44 <Cale> :t (>>>)
13:41:46 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
13:41:55 <rwbarton> :t isn't relevant
13:41:57 <lambdabot> Not in scope: `isn't'
13:41:57 <lambdabot> Not in scope: `relevant'
13:41:58 <mauke> > (succ *** pred) (1, 'a')
13:42:00 <lambdabot>   mueval: Prelude.read: no parse
13:42:02 <Cale> hmm
13:42:05 <gwern> :t doesn't go through mueval does it?
13:42:07 <lambdabot> parse error (possibly incorrect indentation)
13:42:19 <Saizan> it just calls ghci
13:42:28 <gwern> I mean, I've pondered making :t go through mueval, but that'd require still more options or changes
13:42:34 <rwbarton> > (succ *** pred)
13:42:36 <lambdabot>       Overlapping instances for Show ((a, b') -> (a, b'))
13:42:36 <lambdabot>        arising from...
13:42:53 <sjanssen> gwern: can :t go through mueval?  Mueval requires monomorphic types, AFAIK
13:42:56 <mmorrow> gwern: the darcs haskell-src-exts is on acount of the recent addition of unicode chars as acceptable. so you can go with an earlier version, but there would be a parse error every time it sees a char > '\127'
13:43:02 <mmorrow> *account
13:43:09 <mauke> > (succ *** pred) (a,b)
13:43:12 <lambdabot>   mueval: Prelude.read: no parse
13:43:15 <mauke> what
13:43:22 <rwbarton> > succ a
13:43:26 <lambdabot>   succ a
13:43:33 <Cale> Well, if mueval isn't up to date, it's now the one on hackage.
13:43:40 <mauke> > (succ *** pred) ()
13:43:41 <lambdabot>   Couldn't match expected type `(a, b')' against inferred type `()'
13:43:47 <rwbarton> this is the same behavior as before, the typechecker knows about Control.Arrow, but not the evaluator
13:43:50 <yitz> > first succ (2,4)
13:43:52 <lambdabot>   mueval: Prelude.read: no parse
13:43:58 <EvilTerran> > (succ &&& pred) EQ
13:44:00 <lambdabot>   mueval: Prelude.read: no parse
13:44:07 <EvilTerran> > (succ EQ, pred EQ)
13:44:08 <Cale> > Control.Arrow.first succ (2,4)
13:44:09 <lambdabot>   (GT,LT)
13:44:10 <lambdabot>  Terminated
13:44:11 <yitz> > first (+1) (2,4)
13:44:13 <lambdabot>   mueval: Prelude.read: no parse
13:44:17 <Cale> > Control.Arrow.first succ (2,4)
13:44:19 <lambdabot>   mueval: Prelude.read: no parse
13:44:22 <sjanssen> what the heck is this "no parse" business?
13:44:34 <Cale> Maybe gwern knows?
13:44:36 <EvilTerran> i think it's producing it for all errors just now
13:44:41 <Saizan> i don't know, but it's not occurring in the darcs mueval
13:44:44 <Deewiant> > asdf
13:44:45 <lambdabot>   mueval: Prelude.read: no parse
13:44:49 <EvilTerran> i guess the syntax of error messages must've changed or something
13:44:55 <Deewiant> > error "foo"
13:44:57 <lambdabot>   mueval: Prelude.read: no parse
13:44:57 <lambdabot>  mueval: *** Exception: foo
13:45:02 <Cale> I don't even know where the darcs repository for mueval is :)
13:45:12 <yitz> > undefined
13:45:14 <lambdabot>   mueval: Prelude.read: no parse
13:45:14 <lambdabot>  mueval: *** Exception: Prelude.undefined
13:45:28 <Saizan> http://code.haskell.org/mubot
13:45:29 <lambdabot> Title: Index of /mubot
13:45:37 <Deewiant> yes, the new syntax is error x = Prelude.error $ "mueval: Prelude.read: no parse\n" ++ x
13:45:40 * gwern quietly bwa ha ha has. perhaps I will start deliberating introducing errors into hackage mueval so I can go 'is fixed in teh HEAD!'
13:46:59 <Olathe> What does span do ?
13:46:59 <Saizan> gwern: it's the condamn for having users :)
13:47:06 <yitz> @type span
13:47:07 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
13:47:26 <yitz> > span even [2,4,5,6,7]
13:47:27 <Olathe> > span (\x -> x `mod` 2 == 0) [1..10]
13:47:29 <lambdabot>   ([],[1,2,3,4,5,6,7,8,9,10])
13:47:29 <lambdabot>  Terminated
13:47:37 <Deewiant> > span even [2,4,5,6,7]
13:47:39 <lambdabot>   ([2,4],[5,6,7])
13:47:41 <Olathe> Ahh, thanks.
13:47:56 <mmorrow> > span (/='.') "127.0.0.1"
13:47:58 <lambdabot>   ("127",".0.0.1")
13:48:07 <ac> why does my program take rediculously long to link?
13:48:21 <Deewiant> @check \p x -> span p x == (takeWhile p x, dropWhile (not.p) x)
13:48:22 <lambdabot>       Overlapping instances for Show (a -> Bool)
13:48:22 <lambdabot>        arising from a use of...
13:48:32 <Cale> > span (not . isSpace) "This is not a sentence."
13:48:34 <lambdabot>   ("This"," is not a sentence.")
13:48:34 <drigz> span p is break (not p), right?
13:48:39 <Deewiant> @src break
13:48:40 <lambdabot> break p =  span (not . p)
13:48:52 <drigz> Deewiant: thanks
13:49:04 <Olathe> So, snd.span == dropWhile ?
13:49:16 <drigz> @src span
13:49:16 <lambdabot> Source not found. That's something I cannot allow to happen.
13:49:21 <mmorrow> @src dropWhile
13:49:21 <lambdabot> Source not found. There are some things that I just don't know.
13:49:22 <Cale> span p xs = (takeWhile p xs, dropWhile p xs)
13:49:24 <Deewiant> @check \x -> let p = even in span p x == (takeWhile p x, dropWhile p x)
13:49:25 <lambdabot>   "OK, passed 500 tests."
13:49:26 <Olathe> > dropWhile (not.isSpace) "This is not a sentence."
13:49:28 <lambdabot>   " is not a sentence."
13:49:41 <Olathe> > snd.scan (not.isSpace) "This is not a sentence."
13:49:43 <lambdabot>   mueval: Prelude.read: no parse
13:49:47 <Olathe> Oh, wait.
13:49:49 <gwern> hm, I just thought of one benefit to mueval instead of hs-plugins
13:49:50 <Olathe> IT's almost.
13:49:54 <gwern> Cale can install from darcs over the old mueval and not need to restart lb
13:50:00 <Cale> Yes. :)
13:50:16 <Cale> Though I could actually rebuild runplugs on its own before too.
13:50:26 <Olathe> > snd (scan (not.isSpace) "This is not a sentence.")
13:50:26 <mmorrow> > let split p = fmap (drop 1) . span p in split (/='.') "127.0.0.1"
13:50:28 <lambdabot>   ("127","0.0.1")
13:50:28 <lambdabot>  Terminated
13:50:29 <Cale> But installing from cabal is nice :)
13:50:36 <Cale> er, hackage :)
13:50:42 <mmorrow> > fmap (+1) (1,1)
13:50:43 <Olathe> > snd (span (not.isSpace) "This is not a sentence.")
13:50:44 <lambdabot>   (1,2)
13:50:45 <lambdabot>   " is not a sentence."
13:50:53 <Olathe> > dropWhile (not.isSpace) "This is not a sentence."
13:50:55 <lambdabot>   " is not a sentence."
13:51:21 <drigz> Olathe: you could have used $
13:51:21 <humasect> > snd$break isSpace "This is not .."
13:51:23 <lambdabot>   " is not .."
13:51:40 <drigz> > snd $ span (not.isSpace) "aoe uid htn"
13:51:42 <lambdabot>   " uid htn"
13:52:00 <drigz> too slow :(
13:52:06 <gwern> Cale: lies! you could not rebuild runplugs, I refuse to accept that!
13:52:19 <Cale> gwern: heh
13:52:28 <Olathe> Ahh, OK.
13:53:17 <sjanssen> gwern: huh, what is this weird double print thing
13:53:41 <Saizan> which double print?
13:53:42 <sjanssen> does this happen in IRC mode?
13:53:57 <sjanssen> Saizan: in console mode, lambdabot prints every line twice
13:54:23 <Olathe> :t fmap
13:54:24 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:54:29 <sjanssen> how long has this been around?
13:54:33 <Olathe> That doesn't work in private (:t)
13:54:36 <gwern> sjanssen: the bug I mentioned earlier
13:54:38 <gwern> I suspect your th patches introduced it
13:54:52 <guenni> how do I update a package via ghc?
13:54:53 <sjanssen> gwern: "-threaded is only effective if you run LB with something like +RTS -N4 -RTS" wrong
13:54:56 <Olathe> Cale: I can't get :t to work in private.
13:55:01 <guenni> ghc-pkg
13:55:04 <sjanssen> gwern: maybe in lambdabot's case, but not at all in the general case
13:55:08 <Myoma> Olathe: @type must be used
13:55:12 <Olathe> Ahh, thanks.
13:55:14 <Myoma> Olathe: I think this is a bug in lambdabot
13:55:23 <Olathe> @type fmap
13:55:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:55:28 <Olathe> Ahh, OK.
13:55:30 <gwern> sjanssen: waaah?
13:55:34 <sjanssen> gwern: RTFM
13:55:50 <mmorrow> how could the TH patches have added it, since they only operate at compile-time?
13:55:52 <dons> yeah.
13:56:00 <sjanssen> -threaded has *major* implications with foreign calls
13:56:02 <dons> it's needed, gwern, for blocking IO.
13:56:12 <dons> a correctness issue.
13:56:23 <gwern> mmorrow: because they generate functions and stuff
13:56:35 <gwern> sjanssen: well, ok. but lb isn't doing ffi is it?
13:56:35 <sjanssen> dons: it isn't needed for plain IO
13:56:43 <sjanssen> (the non threaded RTS handles this perfectly well)
13:56:59 <dons> right. the blocking foreign calls that lambdabot does though.
13:57:07 <dons> and the process waiting
13:57:22 * mmorrow checks to see what the TH is outputting
13:57:23 <dons> i think there's even a comment i put in to the effect "don't disable this or you get a slap upside the head"
13:57:55 <Saizan> double printing of any output or just from @run? i'm not getting it anyhow
13:58:06 <gwern> grep shows nothing about disable
13:58:26 <gwern> Saizan: all output, which is why I suspected the TH patches - they were the last ones to affect all plugins
13:58:43 <gwern> if it was just @run or @type or something, that would've made me suspicious of the other recent ones
13:58:47 <gwern> but all of them?
14:02:28 <_zenon_> sjanssen, you can see lb output everything twice in #mobileread, it's built from darcs (downed it today)
14:03:39 <sjanssen> _zenon_: thanks
14:03:49 <sjanssen> gwern: yeah, it seems to be gone when the TH patches are gone
14:04:02 <sjanssen> (though I had to remove a bunch of others at the same time)
14:04:11 <guenni> how can I update package in ghc?
14:04:17 <gwern> sjanssen: all the ones after?
14:04:22 <gwern> you mean?
14:04:52 * gwern notes that my laziness post to reddit seems to be astonishing controversial - 80 something votes, and it's still at +1!
14:05:04 <gwern> http://www.reddit.com/r/programming/comments/6yuwq/laziness_means_never_having_to_say_youre_sorry/
14:05:07 <lambdabot> Title: Laziness means never having to say you're sorry... for premature optimization [P ..., http://tinyurl.com/57kwty
14:07:20 <FordCortina> does anybody know if real world haskell covers existential types?
14:08:14 <sjanssen> gwern: yeah, TH seems to be the culprit
14:08:24 <gwern> FordCortina: ask one of the authors like dons
14:08:32 <dons> FordCortina: i don't think we talk about them.
14:08:41 <chrisdone> can anyone see any problems in my PEG operators that would cause exponential growth? http://paste.lisp.org/display/66142 I've gone through them all individually and I'm fairly confident they all behave correctly, but I may be missing something. I hope I am missing something, because the prospect of searching through this whole grammar for problems is not very pleasing
14:08:46 <dons> FordCortina: for the sequel.
14:09:02 <FordCortina> dons: :) i see thanks!
14:11:31 <sjanssen> hmm, is it possible that the order in which plugins are loaded matters?
14:12:54 <mmorrow> here's the code the TH functions in Plugin.hs are generating http://hpaste.org/10050
14:13:04 <dons> sjanssen: not really.
14:13:16 <sjanssen> dons: how sure are you on that?
14:13:58 <sjanssen> even, say, Base?
14:14:12 * gwern winces. obviously reading TH generated code is a skill like reading Core
14:14:24 <sjanssen> gwern: look at the first part
14:14:46 <mmorrow> gwern: i prettyprinted it in the first two
14:15:19 <EvilTerran> which seems to do a fairly good job of deparsing it
14:15:30 <sjanssen> crap, base is listed twice
14:15:48 <EvilTerran> that can't be good
14:16:33 * EvilTerran thinks about the arrow calculus paper
14:16:54 <gwern> where?
14:16:57 <Saizan> for?
14:17:02 * EvilTerran notes that it'd probably be very difficult to implement as a haskell extension, as it involves introducing a new flavour of typing judgement
14:17:06 <EvilTerran> hang on
14:17:43 <EvilTerran> http://homepages.inf.ed.ac.uk/wadler/papers/arrows/arrows.pdf
14:17:45 <lambdabot> Title: The Arrow Calculus (Functional Pearl)
14:18:05 <dons> sjanssen: you have to load Base first, and the other sticky ones.
14:18:12 <dons> after  that, should be fine.
14:18:13 <zandax_> Can I do something like "Chars = ["A".."z"]" in Haskell?
14:18:15 <EvilTerran> it's terribly clever, but, as i said, wouldn't really mesh with the design of haskell
14:18:17 <dons> but who knows what the code does now...
14:18:18 <sjanssen> dons: documentation of that would have been nice
14:18:21 <EvilTerran> > ['a'..'z']
14:18:23 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
14:18:25 <Deewiant> > ['A'..'z']
14:18:27 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz"
14:18:33 <sjanssen> it seems to work if base is loaded after, but perhaps I'll change it just to be safe
14:18:52 <chrisdone> ^_`
14:19:12 <dons> sjanssen: any documentation at all is an innovation.
14:19:14 <EvilTerran> @@ 'a' :: (@type 'a'); "a" :: (@type "a")
14:19:17 <zandax_> thanks ;)
14:19:17 <lambdabot>  'a' :: Char; "a" :: [Char]
14:19:22 <EvilTerran> note the distinction
14:19:34 <gwern> huh. how do [,],^,_, etc come between A and z?
14:19:39 <EvilTerran> > ["a".."z"] -- which is why this doesn't work
14:19:40 <lambdabot>       No instance for (Enum [Char])
14:19:40 <lambdabot>        arising from the arithmetic sequen...
14:19:42 <opqdonut> gwern: see ascii
14:19:47 <EvilTerran> gwern, because it's in asciibetical order
14:19:53 <EvilTerran> well, unicode order
14:19:55 <Deewiant> unicodebetical
14:20:08 <gwern> oh
14:20:08 <opqdonut> gwern: the point is that lower and upper case differ in one bit
14:20:09 <dmwit__> unicodeal?
14:20:27 <EvilTerran> unicographic ordering?
14:20:30 <dmwit__> opqdonut: Something about "premature optimization"...
14:20:38 <EvilTerran> (as compared to lexicographic, being dictionary order)
14:20:41 <opqdonut> no, about legacy hardware ;)
14:21:00 <Deewiant> > chr $ ord 'z' `xor` (ord 'a' - ord 'A')
14:21:02 <lambdabot>   'Z'
14:21:10 <dmwit__> :t ('a', "a")
14:21:11 <lambdabot> (Char, [Char])
14:21:12 <EvilTerran> gwern, opqdonut - note people have arranged the uppercase and lowercase letters in one contiguous block before, and that got us EBCDIC
14:21:18 <EvilTerran> where they alternated
14:21:23 <opqdonut> :)
14:22:15 <gwern> EvilTerran: alternated? hm, that makes more sense to me actually. keep like with like
14:22:28 <sjanssen> I think it makes lots of sense
14:22:37 <sjanssen> case detection becomes a simple parity test
14:23:00 <EvilTerran> @check \c -> isAlpha c ==> ord (toLower c) == ord c .|. (ord 'a' `xor` ord 'A')
14:23:01 <lambdabot>   "Falsifiable, after 1 tests:\n'\\155089'\n"
14:23:09 <EvilTerran> bah. durn unicode.
14:23:21 <EvilTerran> sjanssen, well, it's still a simple bit test
14:23:29 <EvilTerran> gwern, yeah, but then ['a'..'z'] wouldn't DWIM
14:23:30 <sjanssen> EvilTerran: interesting, didn't know that
14:23:49 <Olathe> @check \c -> isAlpha c && ord c < 256 ==> ord (toLower c) == ord c .|. (ord 'a' `xor` ord 'A')
14:23:51 <lambdabot>   "Arguments exhausted after 0 tests."
14:23:52 <opqdonut> yeah and ebcdic alphabetises better
14:24:05 <sjanssen> _zenon_: that double print issue is now fixed in darcs
14:24:08 <Olathe> EBCDIC is totally unalphebatized.
14:24:12 <EvilTerran> actually, i think it depends on which EBCDIC spec you're using, they may not alternate
14:24:15 <Olathe> E does not come before B.
14:24:17 <EvilTerran> in all of them
14:24:22 * sjanssen <3 running lambdabot in ghci
14:24:33 <opqdonut> though i do prefer "unix" case, big caps coming before small caps
14:24:35 <Adamant> EBCDIC is dead
14:24:44 <_zenon_> sjanssen, nice.
14:25:30 <_zenon_> sjanssen, uhm, how do you do the same ad update in svn, with darcs??
14:25:43 <_zenon_> as*
14:26:12 <Deewiant> the problem with EBCDIC is mostly that 'I'+1 /= 'J'
14:26:18 <EvilTerran> @check \c' -> let c = c' `mod` 128 in isAlpha c ==> ord (toLower c) == ord c .|. (ord 'a' `xor` ord 'A')
14:26:19 <lambdabot>       No instance for (Integral Char)
14:26:19 <lambdabot>        arising from a use of `mod' at <...
14:26:37 * gwern thinks the problem there is 'I'+1 == anything
14:26:56 <sjanssen> _zenon_: darcs pull
14:27:21 <dcoutts> gwern: would you mind checking gcc -dumpversion on your platform?
14:27:21 <EvilTerran> Deewiant, yeah - similar problem to ['a'..'z'] doing something unexpected, really
14:27:44 <Deewiant> EvilTerran: yeah, although I wouldn't expect ['A'..'z'] to work anyway :-)
14:27:52 <gwern> dcoutts: 4.3.2, as I said last time
14:28:03 <_zenon_> sjanssen, thanks
14:28:04 <EvilTerran> Deewiant, ah, but that one *would* work if you alternated upper and lowercase!
14:28:14 <dcoutts> gwern: sorry, I missed it last time. Thanks. I'll use that as it seems more regular than gcc --version.
14:28:15 <EvilTerran> albeit in an unexpected ordering
14:28:17 <Deewiant> yes, but I wouldn't expect it to. :-P
14:28:19 <EvilTerran> yeah
14:28:26 <EvilTerran> i believe it DWIM in perl
14:28:42 <gwern> yeah, --version is pretty ugly
14:29:00 <EvilTerran> but perl is made from DWIM vaguely held together by punctuation characters
14:29:02 <mauke> "A" .. "z" is the same as "A" .. "Z" in Perl
14:29:26 <chrisdone> valid perl code
14:29:56 <Olathe> What's bitwise not ?
14:30:02 <Olathe> I mean the operator
14:30:11 <mauke> :t complement
14:30:12 <lambdabot> forall a. (Bits a) => a -> a
14:30:14 <Olathe> What operator is bitwise not ?
14:30:14 <EvilTerran> mauke, ah. well, that's a little more DWIM than what it does in haskell - it's got the unpredictable semantics that come with DWIM, without actually being that useful
14:30:16 <Olathe> Ahh.
14:30:28 <dcoutts> Olathe: check out the docs for Data.Bits
14:30:30 <Olathe> @hoogle (Bits a) => a -> a
14:30:31 <lambdabot> Data.Bits complement :: Bits a => a -> a
14:30:31 <lambdabot> Data.Bits (.&.) :: Bits a => a -> a -> a
14:30:31 <lambdabot> Data.Bits (.|.) :: Bits a => a -> a -> a
14:30:59 <mauke> EvilTerran: well, the real issue is that perl allows stuff like "aa" .. "zz"
14:31:09 <mauke> so it has to use a completely different algorithm
14:31:12 <EvilTerran> it does? i don't think i've dared try it :P
14:31:35 <dons> it's all in the type classes.
14:31:41 * EvilTerran did once think about writing an instance (Enum a, Bounded a) => Enum [a], but abandoned it as folly
14:31:48 <dons> import PerlString ; instance Enum PerlString ...
14:32:05 <_zenon_> sjanssen, runs smooth as a snake in a barrel of butter now
14:32:16 <EvilTerran> O.o
14:32:24 <EvilTerran> ... wait, snakes have no legs, how can they run?
14:32:32 <mauke> you know perl lets you increment strings, right? :-)
14:32:45 <EvilTerran> mauke, again, i don't think it ever occurred to me to try it
14:32:58 <dzlk> perl is DWLWTIM.
14:33:03 <gwern> wait, how does "aa".."zz" work? what does that make?
14:33:04 <EvilTerran> anyway, i'm a haskeller now. stop reminding me of the bad old days. :P
14:33:12 <dzlk> ("Do What Larry Wall Thinks I Mean")
14:33:22 <mauke> gwern: are you in any channel with buubot? if not, join #perl
14:33:49 <gwern> ...are they going to try to convert me to #perl?
14:33:58 <mauke> probably not
14:34:05 <Myoma> as soon as you see the wonder of "aa".."zz" you will want to use perl forever
14:34:07 <EvilTerran> gwern, it works like '00'..'99' works in perl, only in base 26
14:34:10 <mauke> or /join #buubot
14:34:22 <EvilTerran> using ['a'..'z'] as digits
14:34:30 <mauke> this stuff is easier to demonstrate than to explain
14:34:51 <EvilTerran> it's even easier to avoid like the plague :P
14:35:36 <opqdonut> :
14:35:37 <opqdonut> D
14:35:44 <opqdonut> woops, spurious line feed
14:35:51 <EvilTerran> opqdonut, picasso would be proud ;)
14:36:08 <Saizan> would there be another reasonable instance for lists?
14:36:27 <EvilTerran> Saizan, you mean an Enum instance?
14:36:41 <lilac> @hoogle Int -> (Int -> Char) -> Int -> String
14:36:42 <EvilTerran> the one i started implementing seemed to me to be the only vaguely intuitive one
14:36:43 <Saizan> yeah
14:36:45 <lambdabot> Data.Generics.Basics gmapQi :: Data a => Int -> (a -> u) -> a -> u
14:36:45 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
14:37:08 <EvilTerran> lilac, er, what do you intend such a function to do?
14:37:24 <lilac> > let enc = foldl (\t n -> 1114112 * t + toInteger (ord n)) 0; dec = reverse . unfoldr (\n -> if n == 0 then Nothing else Just . first (chr . fromIntegral) . uncurry (flip (,)) $ n `divMod` 1114112) in length $ map dec [enc "hello" .. enc "world"]
14:37:26 <lambdabot>   mueval: Prelude.read: no parse
14:37:32 <EvilTerran> zoiks
14:37:34 <lilac> EvilTerran: int to string in base N
14:37:48 <Saizan> there's something in Numeric, iirc
14:37:48 <EvilTerran> ?type showIntAtBase
14:37:50 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
14:38:03 <lilac> thanks :)
14:38:14 <EvilTerran> > showIntAtBase 26 (['a'..'z']!!) 12345 ""
14:38:15 <lambdabot>   mueval: Prelude.read: no parse
14:38:18 <EvilTerran> ...
14:38:33 <EvilTerran> ?type showIntAtBase 26 (['a'..'z']!!) 12345 ""
14:38:34 <lambdabot> String
14:38:56 <EvilTerran> ?vixen *poke*
14:38:57 <lambdabot> i really hate arabs!
14:39:00 <EvilTerran> :O
14:39:16 <SamB> ?. vixen yow
14:39:17 <lambdabot> What is your favorite cheese?  Mines baloney.
14:39:26 <SamB> ?. yow vixen
14:39:26 <lambdabot> I'm wearing PAMPERS!!
14:39:30 <SamB> ?. vixen yow
14:39:30 <lambdabot> i love fun
14:39:32 <lilac> > showIntAtBase 1114112 chr 160231952896827401058386031 ""
14:39:34 <lambdabot>   mueval: Prelude.read: no parse
14:39:41 <SamB> ?. vixen yow
14:39:41 <lambdabot> i'll hafta plead the fifth on that one.
14:39:56 <SamB> ?yow
14:39:57 <lambdabot> I put aside my copy of "BOWLING WORLD" and think about GUN CONTROL
14:39:58 <lambdabot> legislation...
14:40:32 <jeffwheeler> I've made a mess of setting up HOC, and now I can't seem to get it to install properly.
14:40:54 <glguy> cool, I guess GHCi works on FreeBSD-amd64 now
14:41:20 <jeffwheeler> The main HOC.cabal works fine, and it succeeds, and I can install the HOC-Foundation cabal, but the HOC-QuartzCore and HOC-Cocoa installations fail.
14:42:07 <jeffwheeler> The Cocoa one because of the QuartzCore one. QuartzCore fails because of an "unknown symbol: " with some gobbledygoop, then it fails to load the package "HOC-1.0"
14:42:43 <EvilTerran> @@ @@ @read @run let s = (@show @yow) in "<zippy> " ++ s ++ " <vixen> @vixen " ++ s
14:42:45 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
14:42:48 <EvilTerran> hm
14:42:50 <EvilTerran> it worked in pm
14:42:52 <EvilTerran> @@ @@ @read @run let s = (@show @yow) in "<zippy> " ++ s ++ " <vixen> @vixen " ++ s
14:42:54 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
14:42:56 <EvilTerran> grr
14:43:09 <EvilTerran> <EvilTerran> @@ @@ @read @run let s = (@show @yow) in "<zippy> " ++ s ++ " <vixen> @vixen " ++ s
14:43:09 <EvilTerran> <lambdabot>  <zippy> ANN JILLIAN'S HAIR makes LONI ANDERSON'S HAIR look like RICARDOMONTALBAN'S HAIR! <vixen> I have a boyfriend, but he likes to watch.
14:43:53 <jeffwheeler> This is from the read-only SVN repo "hoc-read-only" mirroring some CVS repo.
14:45:16 <EvilTerran> it suddenly occurs to me that it might be possible to create an infinite loop of @@s with a little ingenuity. DOS risk?
14:45:59 <opqdonut> hmm, writing omega with @@s?
14:46:09 <EvilTerran> effectively, yeah
14:46:18 <EvilTerran> or a quine, depending on how you look at it
14:46:20 <jeffwheeler> What is @@? It's hard to search for...
14:46:24 <EvilTerran> @help @
14:46:24 <lambdabot>  @ [args].
14:46:24 <lambdabot>  @ executes plugin invocations in its arguments, parentheses can be used.
14:46:24 <lambdabot>  The commands are right associative.
14:46:24 <lambdabot>  For example:    @ @pl @undo code
14:46:24 <lambdabot>  is the same as: @ (@pl (@undo code))
14:46:46 <opqdonut> @. elite yarr
14:46:47 <lambdabot> i waNT m3 GRoG!
14:46:50 <opqdonut> :)
14:47:04 <EvilTerran> @@ 'a' :: (@type 'a'); "a" :: (@type "a") -- i used it more usefully for this, earlier
14:47:07 <lambdabot>  'a' :: Char; "a" :: [Char] -- i used it more usefully for this, earlier
14:47:12 <ziman> @yarr
14:47:12 <lambdabot> Gangway!
14:47:54 <quicksilver> EvilTerran: a quine wouldn't matter, LB doesn't execute its own output, does it?
14:48:08 <EvilTerran> quicksilver, well, a quine cleverly wrapped in @@, i mean
14:48:26 <quicksilver> I think you need recursion at the @@-level for that
14:48:29 <quicksilver> I'm not sure we have that.
14:48:30 <EvilTerran> i'm not sure if it's even possible, it was just a thought
14:48:45 <EvilTerran> i used @@ @@ a couple of minutes ago, if that's what you mean
14:49:54 <EvilTerran> actually, i think it's ok - in order for an outputted @command to be run again, you need to have another @@ before i
14:50:27 <EvilTerran> t, so the recursive depth is limited by the line length
14:50:46 <EvilTerran> although you could potentially cause exponential blowup
14:51:09 <EvilTerran> ... did that forkbomb get fixed?
14:51:35 <MarcWeber> l
14:51:40 <SamB> mwahahahaha
14:51:43 <EvilTerran> l?
14:52:28 * EvilTerran wonders if MarcWeber and SamB have some bizarre inside joke involving "l"
14:52:44 <gwern> 301!
14:52:46 <SamB> no, I was going mwahahaha because I wrote the forkbomb ;-P
14:53:02 * EvilTerran recalls contributing to ti
14:53:19 <gwern> SamB: what is the fork bomb?
14:53:20 <SamB> perhaps you *ran* the forkbomb before I did ?"
14:53:29 <lilac> @@ @run fix ("@@ " ++)
14:53:31 <lambdabot>   "@@ @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ @@...
14:54:06 <gwern> hm. running that locally doesn't crash lambdabot
14:54:13 <gwern> a fair amount of output but it does terminate
14:54:36 <SamB> gwern: we somehow crashed lambdabot by running a forkbomb from "> "
14:54:56 <EvilTerran> SamB, i've pm'd gwern it
14:55:07 <gwern> > 1+1
14:55:09 <lambdabot>   2
14:55:17 <SamB> gwern: it was very unexpected, actually -- it was supposed to demonstrate how such things were harmless to lambdabot
14:55:25 <opqdonut> heh
14:55:34 <EvilTerran> much ... ensued
14:55:36 <gwern> oh the irony
14:55:39 <dmwit> ...
14:55:40 <dmwit> ...
14:55:41 <dmwit> ...
14:55:43 <SamB> apparantly the rlimits weren't set right or something ?
14:55:44 <dmwit> much ...
14:55:58 <EvilTerran> dmwit, exactly! :)
14:57:58 <mmorrow> rwbarton dealt a knockout blow earlier with > say $ ap (++) show "\n> say $ ap (++) show "
14:58:22 <mmorrow> where say was > say x = fun (utf8s x) :: Expr
14:58:35 <mmorrow> and \n we're actually printed
14:58:52 <mmorrow> heh, *were
14:58:57 <Olathe> > let utf8 = map chr.((let{fi=fromIntegral;multi x n=fi(x`div`2^n.&.63+128);first x n y=fi(x`div`2^n.|.y);setup=take 1.reverse.snd.unzip.flip zip(zip[18,12..0][240,224,192,0]).snd.(\n->span((/=0).(.&.(n::Int)))(map(2^32-)[128,2048,65536,2097152]))}in(\n->concatMap(\(a,b)->first n a b:(fmap(multi n).takeWhile(>=0))(map(a-)[6,12..]))(setup n)))).ord in utf8 '\8704'
14:58:59 <lambdabot>   "\226\136\128"
14:59:08 <mmorrow> l33t
14:59:09 <Olathe> That's the most I've gotten so far.
14:59:18 <Olathe> I'm going to go eat and I might forget to continue.
14:59:33 <dmwit> > fun $ expr "\226\136\128"
14:59:35 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[Char]'
14:59:48 <mmorrow> Olathe: heh, nice.
14:59:49 <Saizan> mmorrow: i wasn't able to reproduce that, though
15:00:13 * mmorrow copy/pastes the new par
15:00:34 <mmorrow> Saizan: really? maybe there was a rogue /msg er
15:00:48 <rwbarton> Yeah, it could have been a coincidence of timing
15:01:09 <mmorrow> yeah, because i can't see how that would loop her
15:01:38 <Saizan> > show "\n"
15:01:40 <lambdabot>   "\"\\n\""
15:01:55 <rwbarton> > say "\n"
15:01:55 <Saizan> so there's not even a real \n in the output
15:01:57 <lambdabot>   mueval: Prelude.read: no parse
15:02:09 <mmorrow> dmwit: cale "fixed" fun to not print control chars, and in doing so killed it's utf8 printing capability
15:02:10 <rwbarton> There was, when say was "working"
15:02:26 <rwbarton> > ap (++) show "\n> say $ ap (++) show "
15:02:32 <lambdabot>  Terminated
15:02:35 <rwbarton> > ap (++) show "\n> say $ ap (++) show "
15:02:37 <lambdabot>   "\n> say $ ap (++) show \"\\n> say $ ap (++) show \""
15:02:49 <Saizan> oh, right, sorry
15:02:51 <Cale> mmorrow: I will accept patches if you want to fix it some more :)
15:03:01 <quicksilver> EvilTerran: I think there will always be exponential blowups in lambdabot
15:03:18 <quicksilver> EvilTerran: for example, there are known exponential blowups in type-checking.
15:03:21 <mmorrow> Cale: ok, for sure. could you point me in the right direction?
15:03:57 <Cale> mmorrow: Well, the thing where I added my fix was in the ios80 function, which is in Plugin.hs
15:04:06 <EvilTerran> quicksilver, eh, yeah, i guess so. are we protected from those blowups by rlimits?
15:04:18 <mmorrow> Cale: ah, excellent. i happen to know /exactly/ where that is :)
15:04:29 <Saizan> mmorrow: if i'm right with the darcs mueval you don't need that utf8
15:04:33 <Cale> oh wait
15:04:38 <Cale> I think I forgot to push
15:04:46 <quicksilver> EvilTerran: no, not at the moment. typechecking doesn't happen in a sub-process.
15:04:53 <quicksilver> EvilTerran: you'd have to do *everything* in subprocesses.
15:05:42 <mmorrow> Saizan: yeah, i noticed your comment while pulling. i was wondering about that.
15:06:10 <lilac> > say "\010> test"
15:06:12 <lambdabot>   > test
15:06:43 <waynemokane> can someone give me a tip on using Text.JSON?
15:06:43 <mmorrow> > utf8s "\8704"
15:06:45 <lambdabot>   "\226\136\128"
15:07:26 <mmorrow> > utf8s "∀"
15:07:28 <lambdabot>   "\226\136\128"
15:07:37 <mmorrow> > fun (utf8s "∀") :: Expr
15:07:39 <lambdabot>   
15:07:56 <mmorrow> it seems to be double-encoding it or something weird like that
15:08:05 <mmorrow> > fun ("∀") :: Expr
15:08:07 <lambdabot>   mueval: Prelude.read: no parse
15:08:07 <lambdabot>  mueval: Enum.toEnum{Word8}: tag (8704) is o...
15:08:44 <waynemokane> how can one distinguish between deriveable and non-deriveable type classes?  can't tell anything from the source...
15:09:11 <mmorrow> check out the haskell report for a list
15:09:15 <Saizan> in h98 there's a fixed set of built-in derivable classes
15:09:21 <mmorrow> ghc adds Data and Typeable to that
15:09:49 <Saizan> and then there's newtype deriving
15:11:59 <TomMD> What the heck is with Data.Time.UTCTime?  It uses Data.Fixed.Pico == Data.Fixed.E12 which seems to be nearly worthless.  Except for using 'Show' I can't see a great way to make an instance of Binary for it.
15:12:50 <eu-prleu-peupeu> hello people from planet haskell
15:16:36 <SamB> eu-prleu-peupeu: I told you, I don't even *have* a blog
15:17:06 <Saizan> SamB: maybe he's only greeting the ones who do
15:17:20 <TomMD> In that case - Hi eu-prieu-peupeu!
15:17:30 <TomMD> errr, you know who I mean.
15:18:34 <SamB> Saizan: how wuude!
15:18:37 <TomMD> But seriously, this Data.Time issue bugs me.  If anyone has found a _good_ solution then please let me know.
15:19:03 <Saizan> ?docs Data.Time.UTCTime
15:19:03 <lambdabot> Data.Time.UTCTime not available
15:19:20 <TomMD> ?docs Data.Time.Clock
15:19:20 <lambdabot> Data.Time.Clock not available
15:19:28 <TomMD> hum.  Bad docs!  Bad!
15:21:14 <eu-prleu-peupeu> :D
15:21:23 <eu-prleu-peupeu> sorry, i was trying out this great firefox extension
15:21:25 <eu-prleu-peupeu> ubiquity
15:21:28 <eu-prleu-peupeu> its really great stuff
15:21:36 <eu-prleu-peupeu> check it out: https://wiki.mozilla.org/Labs/Ubiquity/Ubiquity_0.1_User_Tutorial#Welcome
15:21:43 <Myoma> `:/
15:21:46 <Myoma> I don't want to check it out
15:21:49 <eu-prleu-peupeu> you can write scripts on the address bar
15:22:07 <eu-prleu-peupeu> it would be great to run haskell on the address bar :P
15:22:25 <mauke> omg a command line interface!!1
15:23:51 <eu-prleu-peupeu> i think this is really great... opens a real world of possibilities for the user on the browser
15:24:00 <eu-prleu-peupeu> instant web scripts :)
15:24:58 <Myoma> :/
15:25:08 <Myoma> OK
15:27:39 <mmorrow> Cale: ok, fixed http://hpaste.org/10051
15:28:11 <Cale> mmorrow: cool :)
15:28:37 <mmorrow> :)
15:30:03 <Cale> dcoutts: Btw, there's something strange about the dependency resolution in cabal that I've found...
15:30:46 <dcoutts> Cale: yeah?
15:31:02 <dcoutts> Cale: it's not very smart :-)
15:31:17 <Cale> dcoutts: When I modify lambdabot in some way, and try to cabal install, it will first complain that:
15:31:21 <Cale> cabal: dependencies conflict: lambdabot-utils-4.2 requires bytestring
15:31:21 <Cale> ==0.9.0.1.1 however
15:31:21 <Cale> bytestring-0.9.0.1.1 was excluded because lambdabot-utils-4.2 requires
15:31:21 <Cale> bytestring ==0.9.1.2
15:31:37 <Cale> Then, if I cd to lambdabot-utils and cabal install there first, everything is fine.
15:31:47 <Cale> And then I can go up a level and cabal install lambdabot again
15:32:00 <jeffwheeler> I frequently have similar problems on things like Gtk and Cairo.
15:32:27 <dcoutts> Cale: that'll be because when it's doing the planning for lambdabot, it does not know that it can rebuild lambdabot-utils.
15:32:59 <dcoutts> Cale: so it is forced to use the installed version of lambdabot-utils and thus it is forced to use the exact versions of things that lambdabot-utils was built against.
15:33:18 <Cale> hmm
15:33:30 <Cale> but this happens every single time...
15:33:49 <dcoutts> Cale: wait, though you're saying it says lambdabot-utils-4.2 requires two inconsistent versions ?
15:34:01 <Cale> yes
15:34:09 <dcoutts> Cale: ok, that's very odd.
15:35:43 <dcoutts> Cale: I wonder if we can figure out where it's getting these two from. cabal looks at the complete transitive set of deps of installed packages.
15:36:44 <dcoutts> Cale: if you save me a copy of your package.conf files (global and user) I might be able to figure something out.
15:37:19 <dcoutts> Cale: or perhaps I can reproduce it directly here. What repos do I need?
15:37:41 <Cale> @version
15:37:41 <lambdabot> lambdabot 4.2
15:37:41 <lambdabot> darcs get http://code.haskell.org/lambdabot
15:37:50 <Cale> that darcs command should get it :)
15:37:53 <dcoutts> ok
15:38:06 <Cale> try just cabal installing from the root directory of lambdabot
15:38:24 <dcoutts> Cale: and what about lambdabot-utils ?
15:38:32 <Cale> lambdabot-utils is in a subdirectory
15:38:36 <dcoutts> 'k
15:42:46 <Cale> > "手すト"
15:42:53 <lambdabot>   "\25163\12377\12488"
15:43:07 <Cale> > fun "手すト" :: Expr
15:43:15 <lambdabot>   mueval: Prelude.read: no parse
15:43:21 <lambdabot>  mueval: Enum.toEnum{Word8}: tag (25163) is ...
15:43:26 <dons> sweet.
15:43:35 <dons> you tweaked the parser?
15:43:35 <Cale> Well... I have no idea.
15:43:36 <mmorrow> i'll @let utf8 sgain
15:43:41 <mmorrow> one sec
15:43:45 <dons> or ... disabled the haskell expr. parse check?
15:44:36 <Cale> dons: It's been doing UTF-8 encoding for a while now... a recent patch of mine to strip control characters from the output had broken that, but mmorrow gave me a patch to hopefully fix it again :)
15:44:43 <mmorrow> > say "\8704"
15:44:45 <lambdabot>   ∀
15:44:47 <mmorrow> boom
15:44:52 <Myoma> yay
15:45:06 <dons> 'say'?
15:45:09 <mmorrow> > upsidown "hello"
15:45:10 <Myoma> > let (×) = (,) in 1 × 2
15:45:10 <lambdabot>   ollǝɥ
15:45:11 <lambdabot>   (1,2)
15:45:14 <dons> hah
15:45:16 <Myoma> great!
15:45:17 <mmorrow> haha
15:45:26 <dons> that should be in a library...
15:45:30 <Myoma> :t say
15:45:32 <lambdabot> [Char] -> Expr
15:45:34 <Olathe> > upsidown "upside down"
15:45:35 <lambdabot>   uʍoq ǝqısbn
15:45:36 <mmorrow> it is :) (utf8-light)
15:45:37 <dons> its a sort of cute pretty printer lib.
15:45:40 <mmorrow> dons: http://hpaste.org/10049
15:45:51 <Myoma> > upsidown . upsidown $ "upsidown"
15:45:52 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Expr'
15:45:58 <gwern> Yow! I can feel my ego being eaten by my id!
15:46:15 <dons> good work
15:46:23 <mmorrow> dons: oh yeah, just stick 'say' and 'upsidown' in one, that'd be perfect.
15:46:27 <mmorrow> :)
15:46:41 <bjrn> Challenge: implement APL in Haskell usuing unicode characters.
15:46:47 <mmorrow> Myoma: ah, i don't have the utf8 /de/code one-liner yet
15:46:56 * dons goes back to hacking on bytestring-trie
15:47:44 <Myoma> @let (∈) = elem
15:47:45 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
15:47:54 <Cale> ... How can there be conflicts when there are no remote changes?
15:47:57 <Myoma> > let (∈) = elem in 3 ∈ [1..10]
15:47:58 <lambdabot>   True
15:48:02 <mmorrow> oh snap!
15:48:14 <Olathe> > upsidown "uʍoq ǝqısbn"
15:48:16 <lambdabot>   upsıdǝ doʍn
15:48:19 <Olathe> Eww !
15:48:36 <Olathe> @check \x -> (upsidown.upsidown) x == x
15:48:37 <lambdabot>  Terminated
15:48:42 <Olathe> @check (upsidown.upsidown) x == x
15:48:43 <lambdabot>  Terminated
15:48:48 <Olathe> I'll terminate you !
15:48:50 <gwern> cool
15:48:56 <Cale> Do I really have to ssh into the machine of the remote repo and pull my changes from there?
15:49:15 <mmorrow> heh, this is what we have to one-linerify to get the inverse: http://hpaste.org/10052
15:49:41 <dons> so why don't we have a prelude-unicode package?
15:49:42 <mmorrow> it's complicated by the fact that it's taking a ByteString as input instead of a String like encodeUTF8
15:49:48 <dons> with (.) as dot and so on.
15:49:59 <dons> just a few things rebound with nice unicode equivalents.
15:50:11 <dons> then we could do a @markup that gives the unicode version (and it would be valid code)
15:50:19 <dons> for htings like \x -> f . g . x >> ...
15:50:27 <mmorrow> dons: hmm. i could put something like that together, i've been messing with unicode stuff recently a fair amount.
15:50:37 <dons> yeah, that sounds like a job for mmorrow and Cale
15:50:43 <dons> utf8 / math symbols fans.
15:50:43 <mmorrow> heh
15:50:47 <Cale> Pulling from "cgibbard@code.haskell.org:/srv/code/lambdabot"...
15:50:47 <Cale> No remote changes to pull in!
15:50:52 <Cale> cale@olive:~/lambdabot$ darcs push
15:50:52 <Cale> Pushing to "cgibbard@code.haskell.org:/srv/code/lambdabot"...
15:50:54 <Cale> ...
15:50:54 <dons> and Cale's been hating on the prelude for yonks. :)
15:50:57 <Cale> darcs failed:  Refusing to apply patches leading to conflicts.
15:51:10 <Cale> How can that possibly happen?
15:51:19 <dons> hmm. that's a weird cross-cultural sentence "hating on" == america, "yonks" == .au. /me feels like a global citizen.
15:51:23 <Igloo> Cale: What does "darcs resolve" say?
15:51:49 <Igloo> Cale: And what does "darcs what" in the remote repo say?
15:51:57 <Cale> It says that it will trash unrecorded changes in the working directory...
15:52:39 <Igloo> Hmm, I'm not sure if that necessarily means you have conflicts in your local repo OTTOMH
15:53:14 <Cale> okay, well... I recorded the rest of the changes and then resolved... let's see if it fixes it :)
15:53:53 <Cale> darcs failed:  Refusing to apply patches leThere are conflicts in the following files:
15:53:53 <Cale> ./Plugin.hs
15:53:53 <Cale> ading to conflicts.
15:53:53 <Cale> If you would rather apply the patch and mark the conflicts,
15:53:53 <Cale> use the --mark-conflicts option to apply.
15:54:02 <Cale> (yes, it actually printed like that :)
15:54:37 <Cale> I guess I could do mark-conflicts and then log into the remote machine and fix things up...
15:55:04 <Cale> oh, but that's not an option for push.
15:56:15 <eu-prleu-peupeu> do you guys read this journal called "the monad reader" ?
15:56:19 <eu-prleu-peupeu> is it any worth reading ?
15:56:31 <Cale> yeah, it's usually not bad :)
15:56:31 <dcoutts> eu-prleu-peupeu: yes and yes.
15:56:40 <eu-prleu-peupeu> oh ok
15:56:47 <eu-prleu-peupeu> ill read it then, thanks
15:57:16 <Myoma> > let (℘) = filterM (const [False,True]) in (℘) "foo"
15:57:18 <lambdabot>   ["","o","o","oo","f","fo","fo","foo"]
15:57:23 <Adamant_> dons: I for one welcome our new Anglophone overlords
15:57:28 <Adamant_> wait, wrong century
15:57:56 <dcoutts> dons: so yonks means bashing eh? here it means ages, like a long time. as in "that was yonks ago!"
15:58:01 <Myoma> @let (☣☠☣) = unsafePerformIO
15:58:01 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
15:58:24 <dons> dcoutts: oh, no, "a long time"
15:58:44 <Cale> Myoma: that is the symbol for the Weierstrass elliptic function :)
15:58:48 <gwern> Myoma: that's brillaint. we ought to rename unsafePerformIO that immediately
15:59:00 <Myoma> I never met the Weierstrass elliptic function
15:59:07 <dcoutts> dons: ah, ok. so .au English is ok then :-)
15:59:10 <gwern> maybe just skull, though, so we have symbols for the reallyUnsafe functions
15:59:51 <dcoutts> gwern: mm, like a suffix char, like unboxedFoo#
16:00:06 * lilac needs to turn on UTF8 in his terminal
16:00:19 <gwern> might make dictating haskell kind of wonky tho
16:00:21 <dcoutts> performIO☠
16:00:30 <Myoma> > var "possible bug" :: Expr
16:00:31 <lambdabot>       Ambiguous occurrence `var'
16:00:31 <lambdabot>      It could refer to either `Data.Number.S...
16:00:40 <Cale> I guess some people like to use it for powerset, but these people usually just don't know how to get a different script P :)
16:00:58 <gwern> 'box penis dot dot var equals perform IO skull squiggly squiggly squiggly'
16:01:07 <Olathe> Hahah
16:01:19 <dcoutts> gwern: :-)
16:01:38 <Myoma> > ( ☂ )
16:01:39 <lambdabot>   mueval: Prelude.read: no parse
16:01:43 <Myoma> odd
16:01:45 * gwern can't ne the only one who thinks bottom looks like a phallus
16:02:03 <mmorrow> > say . repeat $ "☂"
16:02:04 <lambdabot>   mueval: Prelude.read: no parse
16:02:13 <mmorrow> > say . repeat $ '☂'
16:02:14 <lambdabot>   mueval: Prelude.read: no parse
16:02:25 <gwern> > repeat "☂"
16:02:26 <lambdabot>   ["\9730","\9730","\9730","\9730","\9730","\9730","\9730","\9730","\9730","\...
16:02:32 <Myoma> > let (♪) = (++)`on`return in 'x' ♪ 'y' ♪ 'z'
16:02:33 <mgsloan> hey, is there a way for me to decode a bytestring given a Data.Binary.Get?  The sigs for encode / decode seem rather restrictive (you need an actual binary instance)
16:02:39 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
16:02:46 <gwern> woot, got lb built again
16:02:53 <Myoma> > let (♪) = (++) in "x" ♪ "y" ♪ "z"
16:02:55 <lambdabot>   "xyz"
16:02:57 <Corun> :-D
16:03:05 <gwern> and the double print works
16:03:11 <mgsloan> encode :: Binary a => a -> ByteString
16:03:11 <mgsloan> decode :: Binary a => ByteString -> a
16:03:31 <gwern> Cale: if no bad bugs surface today or tomorrow, I'm going to do a lb upload
16:03:34 <Saizan> mgsloan: use runGet
16:03:34 <Cale> okay... what the fuck is going on here...  I do 'darcs resolve', it says "Finished resolving." (and fails to mention any conflicts). I notice that Plugin.hs has some marked conflicts all of a sudden, so I resolve them by hand and record a patch. I still can't push on account of conflicts. Darcs resolve puts the *very same* conflict markers back in the file.
16:04:23 <mgsloan> Saizan - ah thanks!
16:04:25 <Cale> (the ones which I just removed and recorded a patch for)
16:04:34 <stepcut> unicode is going to make the next obfuscated Haskell contest more interesting...
16:04:52 * gwern is just testing build from sdist right now
16:04:52 <Cale> gwern: I have some patches which I can't seem to push, because darcs is being stupid.
16:04:59 <mmorrow> Cale: i think it wiped out the state as well (at least the @lets), or possibly that's unrelated
16:05:04 <rwbarton> > unsafeLaunch☢
16:05:04 <lambdabot>   mueval: Unsafe functions to use mentioned.
16:05:16 <Olathe> Hahah
16:05:25 <Cale> @undefine
16:05:34 <Cale> ...
16:05:41 <Cale> @let x = 42
16:05:42 <lambdabot>  Defined.
16:05:52 <gwern> > x
16:05:53 <mmorrow> excellent
16:05:53 <lambdabot>       Ambiguous occurrence `x'
16:05:53 <lambdabot>      It could refer to either `L.x', defined a...
16:05:54 <Cale> > x
16:05:55 <lambdabot>       Ambiguous occurrence `x'
16:05:55 <lambdabot>      It could refer to either `L.x', defined a...
16:05:58 <Cale> > L.x
16:05:59 <lambdabot>   42
16:06:02 <Cale> @undefine
16:06:10 <gwern> nooo sdist fails
16:06:13 <Cale> > L.x
16:06:14 <lambdabot>   mueval: Prelude.read: no parse
16:06:27 * Cale goes to dinner.
16:06:41 <gwern> ah well I will try later too
16:07:08 <Myoma> > 1+999999999
16:07:16 <lambdabot>   1000000000
16:08:00 <mmorrow> > say (take 10 ['☂'..])
16:08:01 <lambdabot>   ☂☃☄★☆☇☈☉☊☋
16:08:10 <Myoma> cool!
16:08:11 <Olathe> Neat.
16:08:15 <Myoma> > say (take 100= ['☂'..])
16:08:16 <lambdabot>   mueval: Prelude.read: no parse
16:08:18 <Myoma> > say (take 100 ['☂'..])
16:08:19 <lambdabot>   ☂☃☄★☆☇☈☉☊☋☌☍☎☏☐☑☒☓☔☕☖☗☘☙☚☛☜☝☞☟☠☡☢☣☤☥☦☧☨☩☪☫☬☭☮☯☰☱☲☳☴☵☶☷☸☹☺☻☼☽☾☿♀♁♂
16:08:19 <lambdabot> ♄♅♆♇♈♉♊♋♌...
16:08:27 <Myoma> ââââââââââââââââââââââââââ¿
16:08:34 <mmorrow> haha
16:08:57 <mmorrow> it seems to have problem with really long ones for some reason
16:09:05 <mmorrow> > say (take 20 ['☂'..])
16:09:18 <lambdabot>   ☂☃☄★☆☇☈☉☊☋☌☍☎☏☐☑☒☓☔☕
16:09:30 <monochrom> nice!
16:09:57 <Twey> Hahaha
16:10:37 <mmorrow> enumerating from the umbrella ...
16:10:46 <mmorrow> lol
16:10:49 <Myoma> :D
16:11:02 <Myoma> > say (take 20 . drop 1234 $ ['☂'..])
16:11:03 <lambdabot>   ⫔⫕⫖⫗⫘⫙⫚⫛⫝̸⫝⫞⫟⫠⫡⫢⫣⫤⫥⫦⫧
16:11:15 <Myoma> > say (take 20 . drop 6234 $ ['☂'..])
16:11:16 <lambdabot>   㹜㹝㹞㹟㹠㹡㹢㹣㹤㹥㹦㹧㹨㹩㹪㹫㹬㹭㹮㹯
16:11:21 <Myoma> this is wonderful
16:12:05 <dons> i wonder if we did an official transition to utf8 in here?
16:12:11 <Twey> > say (take 100 ['あ'..])
16:12:12 <lambdabot>   あぃいぅうぇえぉおかがきぎくぐけげこごさざしじすずせぜそぞただちぢっつづてでとどなにぬねのはばぱひびぴふぶぷへべぺほぼぽまみむめも
16:12:12 <lambdabot> やゅゆょよらりるれ...
16:12:14 <dons> remember the kaffufle about colours?
16:12:17 <Twey> Oo-er
16:12:30 <Twey> It buggers up a little there
16:12:41 <Myoma> yes pretty weird ..
16:12:47 <Myoma> > say (take 50 ['あ'..])
16:12:51 <lambdabot>  Terminated
16:12:53 <Myoma> > say (take 50 ['あ'..])
16:12:55 <lambdabot>   あぃいぅうぇえぉおかがきぎくぐけげこごさざしじすずせぜそぞただちぢっつづてでとどなにぬねのはばぱひび
16:13:00 <Twey> I think it's when it goes onto the next line
16:13:03 <rwbarton> > say (replicate 98 'â' ++ ">> say \"foo\"")
16:13:05 <lambdabot>   âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ...
16:13:13 <rwbarton> aw, worked in privmsg
16:13:14 <monochrom> What happens without "say"?
16:13:16 <Twey> It doesn't apply 'say' correctly to it
16:13:23 <Myoma> > take 50 ['あ'..]
16:13:25 <lambdabot>   "\12354\12355\12356\12357\12358\12359\12360\12361\12362\12363\12364\12365\1...
16:13:30 <monochrom> OK cool.
16:13:43 <mmorrow> > utf8s "あ"
16:13:45 <lambdabot>   "\227\129\130"
16:13:54 <monochrom> Interesting!
16:13:55 <mmorrow> > utf8s "\12354"
16:13:56 <lambdabot>   "\227\129\130"
16:14:02 <Myoma> > utf8s "?"
16:14:03 <lambdabot>   "?"
16:14:35 <mmorrow> > utf8s "∀"
16:14:36 <lambdabot>   "\226\136\128"
16:14:44 <mmorrow> > say "∀ a. a -> a"
16:14:45 <lambdabot>   ∀ a. a -> a
16:15:32 <Myoma> > say "へ(ー∀ー)"
16:15:33 <lambdabot>   へ(ー∀ー)
16:15:58 <monochrom> Oh! HWN was released yesterday.
16:16:02 <dmwit> ...that right-quote is... right
16:16:15 <dmwit> Also, those characters are not all one-character wide!
16:19:01 <mauke> someone explain http://hackage.haskell.org/packages/archive/sqlite/0.4.1/doc/html/Database-SQLite.html to me
16:19:07 <lambdabot> Title: Database.SQLite, http://tinyurl.com/5dmcrf
16:19:15 <mauke> especially why execParamStatement returns [[Row a]] and not [Row a]
16:19:58 <rwbarton> mauke: I think there's a [Row a] for each statement in the query
16:20:17 <mauke> :-|
16:20:26 <monochrom> Isn't there only one query?
16:20:37 <monochrom> Err, isn't there only one statement?
16:21:21 <rwbarton> I think you can specify more than one statement if you like.  This is just my recollection, haven't looked at the docs recently
16:21:35 <rwbarton> > say (replicate 65 'あ' ++ ">>> foo")
16:21:36 <lambdabot>   あああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああ>>
16:21:36 <lambdabot> > foo
16:21:48 <mauke> looking at the source, you might be right
16:22:00 <mmorrow> rwbarton: crap
16:22:10 <dons> http://www.reddit.com/r/programming/comments/6yyto/a_neighborhood_of_infinity_untangling_with/ woot!
16:22:12 <lambdabot> Title: A Neighborhood of Infinity: Untangling with Continued Fractions: Part 3 : progra ..., http://tinyurl.com/5uc465
16:22:13 <dons> sigfpe part 3.
16:23:09 <mauke> also, creative use of IO (Either e a)
16:23:12 <dons> it seems to me that someone should go through sigfpe's blog, and pakcage up the different monads and abstractions
16:23:19 <dons> sigfpe-extras
16:23:21 <dons> or something.
16:23:32 <Myoma> I don't get it
16:23:42 <Myoma> You'd have all this haskell code in boxes
16:23:44 <Myoma> then what?
16:24:03 <mauke> rwbarton: thanks
16:25:02 <Olathe> > say ['あ'..]
16:25:04 <lambdabot>   あぃいぅうぇえぉおかがきぎくぐけげこごさざしじすずせぜそぞただちぢっつづてでとどなにぬねのはばぱひびぴふぶぷへべぺほぼぽまみむめも
16:25:04 <lambdabot> やゅゆょよらりるれ...
16:25:07 <Myoma> lol
16:25:12 <Olathe> That didn't work out.
16:25:16 <mmorrow> ok, i think i fixed the problem
16:25:18 <Myoma> @remember  <lambdabot>   ããããããããããããããããããããããããããããããã ã¡ã¢ã£ã¤ã¥ã¦ã§ã¨ã©ãªã«ã¬ã­ã®ã¯ã°ã±ã²ã³ã´ãµã¶ã·ã¸ã¹ãºã»ã¼ã½ã¾ã¿ãããã
16:25:18 <Myoma>  <lambdabot> ããããããããã...
16:25:18 <lambdabot> I will never forget.
16:27:23 <rwbarton> Has anyone here used Uustalu+Vene's LV comonad?
16:27:55 <mmorrow> Cale:  minor fix: http://hpaste.org/10051#a1
16:28:19 <mmorrow> Cale: (i should have re-encoded /before/ lim instead of after....
16:28:20 <mmorrow> )
16:28:24 <waynemokane> does anyone know where a package's README file, for example, would be put by cabal, if I am running in --user mode?
16:28:42 <dcoutts> waynemokane: typically it would not be installed.
16:29:52 <mmorrow> @tell Cale i should have re-encoded /before/ lim instead of after: fix => http://hpaste.org/10051#a1
16:29:52 <lambdabot> Consider it noted.
16:30:01 <waynemokane> dcoutts: OK.. I found the .tar.gz under packages, and when I unzipped that I found the file, I just wasn't sure if that got put somewhere by cabal install
16:30:05 <Olathe> It's noted !
16:30:29 <dcoutts> waynemokane: arguably these things should be installed. It does install the license file.
16:31:12 <waynemokane> also, while we're at it, is there some command to cabal to show a list of all files installed for some package?
16:31:31 <dcoutts> waynemokane: no, it does not track the installed files yet. That's why there's no uninstall command.
16:31:48 <waynemokane> basically I'm trying to figure out how gchi "knows" about new packages... don't see how that could be
16:31:54 <waynemokane> since I did not run cabal install as root
16:32:12 <dcoutts> waynemokane: ah, all library packages are registered with ghc-pkg
16:32:24 <dcoutts> waynemokane: so ghc-pkg list will tell you what is known to be installed
16:33:17 <waynemokane> dcoutts: cool, didn't know that
16:33:19 <dcoutts> waynemokane: so although we know what packages are installed, we do not know exactly all the files
16:36:51 <FordCortina> :t say
16:36:52 <lambdabot> [Char] -> Expr
16:37:57 <Olathe> Are Exprs new ?
16:38:05 <Myoma> no
16:38:08 <Olathe> I don't remember seeing them before.
16:38:13 <Olathe> Alright.
16:38:14 <Cale> They've been around for quite a while.
16:38:16 <rwbarton> @type a + b
16:38:21 <Cale> > foldr f z [1,2,3,4,5]
16:38:27 <FordCortina> @hoogle say
16:38:34 <lilac> @bot
16:38:38 <Cale> actually...
16:38:39 <Olathe> say is something we made up today.
16:38:42 <lambdabot> thread killed
16:38:42 <lambdabot>   thread killed
16:38:44 <lambdabot> No results found
16:38:44 <lambdabot> :)
16:38:46 <dmwit> FordCortina: say is a ?let
16:38:53 <FordCortina> Olathe: i see
16:38:53 <Cale> gah, our requests killed the linker :)
16:38:55 <Myoma> > x`gcd`y
16:39:10 <lambdabot>   thread killed
16:39:17 <dmwit> Myoma: That's mean. =P
16:39:25 <Cale> @flush
16:39:28 <Olathe> It's something like say x = fun (utf8s x) :: Expr
16:39:55 <Olathe> You flushed lambdabot !
16:40:18 <Cale> okay, this time the patches pushed... for some reason
16:40:35 <Cale> > say (replicate 65 'あ' ++ ">>> foo")
16:40:42 <lambdabot>   あああああああああああああああああああああああああ...
16:40:49 <Olathe> Is say permanent ?
16:40:52 <Cale> no
16:40:54 <Olathe> Oh, OK.
16:40:55 <Cale> It's in L.hs
16:41:06 <Olathe> Ahh.
16:41:22 <Cale> That's a rather short line now :)
16:41:23 <Olathe> > say ['あ'...]
16:41:30 <lambdabot>   mueval: Prelude.read: no parse
16:41:32 <Olathe> > say ['あ'..]
16:41:38 <lambdabot>   あぃいぅうぇえぉおかがきぎくぐけげこごさざしじすず...
16:41:45 <Olathe> Neat.
16:42:07 <Philonous> > say "@bot"
16:42:08 <lambdabot>   @bot
16:42:36 <Cale> The extra spaces should prevent most bot loops :)
16:43:12 <dmwit> > say "\nfoo"
16:43:13 <lambdabot>   foo
16:43:15 <Olathe> @bot
16:43:15 <lambdabot> :)
16:43:18 * dmwit nods
16:43:27 <Cale>  @bot
16:43:34 <Olathe> Neat.
16:43:44 <Olathe> My IRC client sort of sucks for spaces at the moment.
16:43:57 <Twey> How about we just have lambdabot ignore her own output...?
16:44:46 <mauke> Twey: and how do you identify a lambdabot?
16:45:06 <Twey> There's more than one in here?
16:45:15 <mauke> currently no
16:45:20 <Botje> don't lambdabots live in herds,
16:45:25 <Botje> ?
16:45:26 <Twey> Heh
16:45:31 <Twey> I suggest a CTCP VERSION
16:45:33 <Olathe> Yes, but they trick you by having one out in the open...
16:45:43 <binrapt> > say ['ä'..]
16:45:45 <Olathe> then, when you watch it, the other one springs out from behind you !!
16:45:45 <lambdabot>   äåæçèéêëìíîïðñòóôõö÷øùúûüýþÿĀāĂăĄąĆćĈ...
16:45:45 <Botje> ah, so they hunt in packs :)
16:45:45 <EvilTerran> the rest are hiding in tunnels
16:45:47 <binrapt> o_o
16:45:54 <Twey> Olathe: Ahh!
16:45:56 <mauke> Twey: anyway, bot loops don't require two bots of the same kind
16:46:00 <Myoma> @quote lambdabot
16:46:00 <lambdabot> lambdabot says: @quote lambdabot
16:46:01 <Botje> we should start a lambdabot awareness society :)
16:46:01 <Myoma> @quote lambdabot
16:46:02 <lambdabot> lambdabot says: Couldn't match kind `?? -> ? -> *' against `(* -> *) -> * -> *'
16:46:02 <Olathe> Twey: I know !
16:46:03 <Twey> Aye, mauke
16:46:14 * EvilTerran notes that lambdabot appears to not reply to ctcp version
16:46:15 <Olathe> EvilTerran: Haha
16:46:18 <Twey> But if someone wants to make a bot that just spams everything, there's no need to have a bot loop
16:46:20 <Cale> binrapt: I wonder what happened there...
16:46:29 <binrapt> Cale some Unicode drama
16:46:32 <Twey> It can just > "blah" repeatedly
16:46:49 <Cale> > say "文字化け"
16:46:51 <lambdabot>   文字化け
16:47:05 <Twey> Ironically, it's not
16:47:14 <Cale> > say "ä"
16:47:15 <lambdabot>   ä
16:47:16 <EvilTerran> Olathe, there's exits to the tunnel system hiding everywhere - the only one visible acts as a watchbot and a lure, and then, when you get close enough to another exit, it gives the signal and another one pops out of the ground
16:47:21 <Cale> > say ['ä'..]
16:47:22 <lambdabot>   äåæçèéêëìíîïðñòóôõö÷øùúûüýþÿĀāĂăĄąĆćĈ...
16:47:32 <EvilTerran> and BAM, you've been eta-reduced
16:47:34 <Cale> okaaay...
16:47:37 <Twey> > say ?
16:47:38 <lambdabot>   mueval: Prelude.read: no parse
16:47:39 <Twey> Ah
16:47:44 <Twey> Erwhat
16:47:47 <binrapt> > say ['ت'..]
16:47:48 <lambdabot>   تثجحخدذرزسشصضطظعغػؼؽؾؿـفقكلمنهوىيًٌٍَ...
16:47:49 * Twey blinks.
16:47:51 <binrapt> :(
16:47:53 <Twey> I didn't type that!
16:48:00 <Myoma> > say (take 50 ['ت'..])
16:48:01 <lambdabot>   تثجحخدذرزسشصضطظعغػؼؽؾؿـفقكلمنهوىيًٌٍَ...
16:48:07 <Myoma> > say (take 10 ['ت'..])
16:48:08 <EvilTerran> ?type say
16:48:08 <lambdabot>   تثجحخدذرزس
16:48:09 <lambdabot> [Char] -> Expr
16:48:11 <binrapt> Heh
16:48:15 <Myoma> > say (take 20 ['ت'..])
16:48:16 <lambdabot>   تثجحخدذرزسشصضطظعغػؼؽ
16:48:33 <Cale> Wery strange...
16:49:00 <Philonous> > say "\b\b\b@bot"
16:49:01 <lambdabot>   @bot
16:49:11 <dmwit> I have a professor that says "very" with that exact same accent.
16:49:15 <Philonous> Ok, it seams to be foresightedly coded
16:49:18 <Philonous> seems*
16:49:33 <Riastradh> When did lambdabot learn Arabic?
16:49:49 <Olathe> It took Unicode classes at the university.
16:49:53 <Riastradh> ...oh, I see, users taught him.
16:49:57 <Cale> I think a more important question is *where* did it learn Arabic. :)
16:50:01 <dmwit> Myoma: Aaah!
16:50:42 <dmwit> I bet the (...) comes at a time that takes valid Unicode -> invalid Unicode, so the client displays it as some other encoding...
16:51:09 <Cale> ah
16:51:10 <dmwit> err...
16:51:18 <dmwit> valid UTF-8 -> invalid UTF-8, of course
16:51:46 <EvilTerran> > say "\1571\1606\1575 \1604\1587\1578 \1573\1585\1607\1575\1576\1610"
16:51:48 <lambdabot>   أنا لست إرهابي
16:52:59 <dmwit> EvilTerran: Now try sticking an RTL control character in there... =P
16:53:32 <Olathe> > say "\x1d130"
16:53:33 <lambdabot>   𝄰
16:53:49 <Olathe> > say "\x1d160"
16:53:51 <lambdabot>   
16:53:56 <Olathe> Bah.
16:54:10 <EvilTerran> dmwit, it seems to be RTLing anyway, here
16:54:26 <EvilTerran> i blame windows. gtk is probably contributing, too.
16:55:01 <dmwit> EvilTerran: If it's RTL there, you *may* have typed it in backwards. =)
16:55:18 <dmwit> err... no, you didn't
16:55:18 <dmwit> huh
16:55:22 <EvilTerran> i copied-and-pasted it, i may've picked up an RTL along the way
16:55:30 <Olathe> > say "♪"
16:55:32 <lambdabot>   ♪
16:55:57 <dmwit> It seems magically correct here, too.  I wonder how.
16:56:07 <Olathe> @let sing x = '♪':(x ++ "♪")
16:56:09 <lambdabot>  Defined.
16:56:21 <Olathe> > sing "Test !"
16:56:22 <lambdabot>   "\9834Test !\9834"
16:56:25 <dmwit> > say $ fix sing
16:56:27 <lambdabot>   ♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪♪...
16:56:27 <Olathe> Bah.
16:56:30 <Olathe> Hahah
16:56:41 <Olathe> @let sing x = say $ '♪':(x ++ "♪")
16:56:42 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
16:56:47 <Olathe> @undefine sing
16:56:53 <dmwit> fail
16:56:53 <Olathe> @forget sing
16:56:54 <lambdabot> Incorrect arguments to quote
16:57:02 <dmwit> You've now undefined say and utf8s as well.
16:57:08 <Olathe> Bah, sorry.
16:57:17 <dmwit> > sing x
16:57:18 <lambdabot>   mueval: Prelude.read: no parse
16:57:23 <dmwit> > say "x"
16:57:23 <lambdabot>   mueval: Prelude.read: no parse
16:57:28 * Twey headdesks.
16:57:58 <dmwit> That's *got* to be one of the most-made mistakes here. =P
16:58:05 <Twey> Heh
16:58:54 <Twey> dons: 'Yonks' is used here in England too. :)
16:58:56 <Myoma> > 100
16:58:57 <lambdabot>   100
16:59:34 <Olathe> > sing "Tests"
16:59:35 <lambdabot>   ♪ Tests ♪
16:59:52 <dmwit> > echo
16:59:53 <lambdabot>   echo
16:59:58 <Olathe> Heheh
17:00:01 <Myoma> > sing "¿"
17:00:05 <lambdabot>   ♪ ¿ ♪
17:00:14 * Twey laughs.
17:00:17 <Olathe> > sing "Chitty Chitty Bang Bang we love you"
17:00:17 <Twey> That's skilled singing.
17:00:18 <lambdabot>   ♪ Chitty Chitty Bang Bang we love you ♪
17:00:36 <Myoma> > sing "¿\n?"
17:00:37 <lambdabot>   ♪ ¿
17:00:37 <lambdabot>  ? ♪
17:00:49 <Olathe> O-o
17:00:56 <Pseudonym> That's pretty annoying, though.
17:01:06 <Pseudonym> The non-ASCII characters.
17:01:09 <Olathe> Ahh.
17:01:21 <Pseudonym> How about o/~ singing o/~
17:01:25 <Pseudonym> That's an old MUD thing.
17:01:35 <monochrom> I absolutely like ♪
17:01:42 <Pseudonym> I see aYa
17:01:44 <Myoma> looks like a tadpole under the guillotine..
17:01:55 <Cale> Pseudonym: You should configure your client for UTF-8
17:02:03 <Twey> > say $ replicate 3 "\na"
17:02:04 <Olathe> I've seen # sing #
17:02:05 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
17:02:08 <Twey> Oops
17:02:18 <Cale>  /set encoding utf-8   usually works, iirc.
17:02:27 <Pseudonym> Cale: You find a SSH client for Windows that's free and handles UTF-8 and we'll both be laughing.
17:02:43 <Cale> Does putty not? That's a bit of a shame.
17:02:53 <monochrom> putty does
17:03:09 <Zao> putty does it quite well.
17:03:23 <Cale> Ah, well then there's your answer :)
17:03:24 <Pseudonym> I'm not happy with putty for a bunch of reasons.
17:03:25 <Twey> > say . (take 3) $ cycle "\na"
17:03:25 <monochrom> Please don't hold back progress just for a few people who haven't installed unicode software.
17:03:26 <lambdabot>   a
17:03:38 * Twey is with monochrom
17:03:53 <Twey> Huh?
17:03:59 <Twey> > sing "a\na"
17:04:01 <lambdabot>   ♪ a
17:04:01 <lambdabot>  a ♪
17:04:05 <Twey> > sing "a\na\na"
17:04:06 <lambdabot>   ♪ a
17:04:06 <lambdabot>  a
17:04:06 <lambdabot>  a ♪
17:04:10 <Myoma> nooo
17:04:25 <Cale> I wish the unicode reference characters were an actual font.
17:04:30 <lilac> monochrom: my combination of konsole + screen + irssi simply doesn't play nicely with utf-8, despite all of them individually claiming to support it
17:04:32 <monochrom> Most haskell implementations are in this miserable cant-do-utf8 state precisely because a vocal minority of old-software users hijack the roadmap.
17:04:33 <Twey>  > sing $ cycle "a\na\na"
17:04:36 <Twey> ... bang?
17:04:38 <Zao> Set putty to use Translation->UTF-8, set LANG=ro_FL.UTF-8, start screen with -U, run irssi, enjoy.
17:04:47 <Pseudonym> Please show me the IRC RFC which mentions utf-8.
17:04:59 <Zao> Pseudonym: 7 bits ought to be enough for anyone.
17:05:04 <Pseudonym> Indeed.
17:05:05 <dmwit> > sing $ cycle "a\na\na"
17:05:06 * Twey laughs.
17:05:06 <Myoma> Pseudonym: encoding is obviously not part of IRC RFCs
17:05:07 <lambdabot>   ♪ a
17:05:07 <lambdabot>  a
17:05:07 <lambdabot>  aa
17:05:07 <lambdabot>  a
17:05:07 <lambdabot>  aa
17:05:09 <lambdabot> [16 @more lines]
17:05:12 <Twey> Aha
17:05:13 <dmwit> Twey: nope
17:05:16 <Twey> Only 16?
17:05:19 <Twey> @more
17:05:20 <lambdabot>  a
17:05:20 <lambdabot>  aa
17:05:20 <lambdabot>  a
17:05:20 <lambdabot>  aa
17:05:20 <lambdabot>  a
17:05:22 <lambdabot> [11 @more lines]
17:05:26 <Zao> Pseudonym: Show me the IRC RFC that allows you to use anything else than latin-1 on it.
17:05:31 <dmwit> Twey: Yes, there's a horizontal limit, too.
17:05:34 <Zao> Or whatever charset the spoony finns used.
17:05:36 <Twey> Aha.
17:05:37 <Twey> Nice.
17:05:45 <Cale> Pseudonym: The IRC RFC sucks anyway :)
17:05:51 <Pseudonym> True.
17:05:58 <Twey> IRC is encoding-agnostic!
17:05:59 <Pseudonym> OK, does ptty handle SOCKS over SSH?
17:06:00 <Pseudonym> putty
17:06:05 <monochrom> The IRC RFC doesn't specify chanserv or nickserv or ...  yet we gladly embrace those new things.
17:06:17 <Twey> 'cept \r\n.
17:06:19 <Olathe> IRC can handle anything without \r \n and \0, I think.
17:06:37 <Zao> Pseudonym: Elaborate?
17:06:42 <Olathe> So, if UTF-8 has those, that can suck.
17:06:43 <dmwit> And even \0 is only to protect against stupid C programmers.
17:06:51 <Zao> It does SSH over SOCKS and other proxies.
17:07:03 <Pseudonym> No, SOCKS over SSH.
17:07:14 <Pseudonym> You can tunnel SOCKS over SSH with most clients.
17:07:15 <Zao> Pseudonym: So you want putty to be a socks proxy?
17:07:19 <Pseudonym> I'm just asking, I don't know the answer.
17:07:22 <Olathe> No, you put the shoes over the socks...oh...wait.
17:07:23 <Pseudonym> Yes.
17:07:24 <monochrom> utf8 is designed to be completely safe of \r \n \0
17:07:32 <Olathe> Ahh, good design.
17:08:13 <SamB> yes, \r \n and \0 are self-encoded in utf-8
17:08:21 <monochrom> safe of lots of other things too.
17:08:51 <SamB> and all non-self-encoded chars are non-ASCII chars, and encoded using non-ASCII bytes
17:08:53 <monochrom> You know how most forum software has bugs concerning the \ character as an escape.
17:08:58 <Zao> Olathe: All lead bytes and their following bytes have the high bit set.
17:09:00 <dzlk> by design, utf-8 \r \n \0 are just ascii \r \n \0, so if it's safe for ascii it's safe for utf-8.
17:09:27 <Twey> UTF-8 is ASCII-compatible.
17:09:31 <Zao> The first 128 codepoints of Unicode are low ASCII.
17:09:43 <monochrom> The Big5 encoding for Chinese uses two bytes for each character. Some characters have second byte being \ .  That confuses buggy forum software big time.
17:10:19 <Twey> No real reason to use anything but UTF-8 or UTF-16, these days
17:10:20 <monochrom> With utf8 there is no such problem.  If you see a \ in a byte stream, that byte must be for \ itself.  Chinese characters don't accidentally introduce \ .
17:10:42 <monochrom> The downside of all this safety is as a result utf8 takes up more bits.
17:10:48 <Twey> Aye
17:10:50 <SamB> nor do Japanese or maths chars
17:10:53 <Twey> 1.5 times
17:11:03 <Twey> But UTF-16 doesn't
17:11:57 <SamB> Twey: but I bet UTF-16 can't confuse buggy forum software either
17:12:09 <Zao> An unicode codepoint encoded in UTF-8 takes 1-4 bytes, UTF-16 1-2 16-bit integers, UTF-32 1-1 32-bit integers.
17:12:13 <Olathe> What's the highest value for a Unicode character ?
17:12:27 <Twey> SamB: I don't think it does, no
17:12:33 <Zao> Olathe: That'd be the last character on plane 16.
17:12:37 <Zao> Olathe: 21 bits all set.
17:12:37 <SamB> > maxBound :: Char
17:12:38 <lambdabot>   '\1114111'
17:12:39 <Olathe> Ahh.
17:12:45 <SamB> it's that one
17:12:49 <Olathe> > maxBound :: Int
17:12:50 <lambdabot>   9223372036854775807
17:13:00 <Olathe> > ord $ maxBound :: Char
17:13:01 <lambdabot>   Couldn't match expected type `Char' against inferred type `Int'
17:13:07 <Olathe> > ord $ (maxBound :: Char)
17:13:08 <lambdabot>   1114111
17:13:12 <Olathe> Okey dokey.
17:13:13 <Zao> \U10FFFF or so.
17:13:20 <Olathe> I guess :: is lower than $
17:13:30 <Twey> Eh
17:13:37 <Twey> Mm
17:13:39 <SamB> > 0x10FFFF
17:13:40 <lambdabot>   1114111
17:13:51 <SamB> Zao: on the nose!
17:14:01 <Olathe> > 2^32 - ord (maxBound :: Char)
17:14:03 <lambdabot>   4293853185
17:14:06 <Olathe> Wow.
17:14:22 <Olathe> > 2^32 `div` ord (maxBound :: Char)
17:14:23 <lambdabot>   3855
17:15:21 <dmwit> > showHex (ord maxBound) ""
17:15:22 <lambdabot>   mueval: Prelude.read: no parse
17:15:27 <dmwit> > showHex 32
17:15:28 <lambdabot>       Overlapping instances for Show (String -> String)
17:15:28 <lambdabot>        arising from a...
17:15:32 <dmwit> > showHex 32 ""
17:15:33 <lambdabot>   mueval: Prelude.read: no parse
17:15:36 <dmwit> sigh
17:15:40 <dmwit> :t showHex
17:15:41 <lambdabot> forall a. (Integral a) => a -> String -> String
17:15:49 <Zao> Becuse the consortium decided to limit the plane count to 17 an UTF-8 cluster could be up to 6 bytes long.
17:15:54 <Zao> s/Because/Before/
17:18:13 <Myoma> @type let (∘) = (.) in  ?f ∘ ?g ∘ ?h
17:18:14 <lambdabot> forall b c b1 a. (?h::a -> b1, ?g::b1 -> b, ?f::b -> c) => a -> c
17:18:36 <dmwit> > (ord maxBound, 0x10ffff)
17:18:38 <lambdabot>   (1114111,1114111)
17:19:10 <Olathe> @pl \(a, b) -> a == b
17:19:10 <lambdabot> uncurry (==)
17:19:35 <Olathe> @pl \a b -> uncurry (==) (a, b)
17:19:36 <lambdabot> (uncurry (==) .) . (,)
17:19:38 <Olathe> Heheh
17:20:05 <Myoma> @let coffee = say "☕"
17:20:07 <lambdabot>  Defined.
17:25:18 <Myoma> time is too damn slow
17:26:23 <dmwit> Err... does that mean you have too much time, or not enough?
17:26:44 <dmwit> Consider: does "move the meeting back" mean to make it start later, or to make it start sooner?
17:27:06 <dmwit> How come we park on a driveway, and drive on a parkway?
17:27:16 <dmwit> Life is full of little mysteries.
17:27:24 <monochrom> Haskell variables can't be changed.
17:27:41 <dmwit> Then why are they called variables, if they can't vary??
17:27:51 <monochrom> Haskell constants get mutated from thunk to value.
17:27:59 <Pseudonym> Excuse me a moment.
17:28:07 <monochrom> Life is full of little mysteries. :)
17:28:20 <monochrom> Haskell "data" isn't data and "type" isn't type. :)
17:28:25 <dmwit> Pseudonym: welcome back
17:28:27 <Cale> They can vary, in a sense.
17:28:43 <Cale> Function parameters are variables, and they vary between applications of the function.
17:35:17 <Myoma> hm
17:35:30 <dmwit> double hm
17:35:49 <dmwit> double welcome back
17:36:32 <Pseudonym> One more go.
17:39:48 <dmwit> Wow, createDirectoryIfMissing :: Bool -> FilePath -> IO ()
17:39:55 <dmwit> That Bool really threw me for a loop until I read the docs.
17:40:16 <monochrom> Heh
17:41:00 <Pseudonym> i can uas utf-8
17:41:03 <Pseudonym> has
17:41:09 <Pseudonym> Bleah, can't even spell that.
17:41:14 <monochrom> season greetings
17:41:14 <dmwit> > say "hey?"
17:41:15 <lambdabot>   hey?
17:41:19 <Myoma> ロロ
17:41:20 <dmwit> > say "\1654"
17:41:21 <lambdabot>   ٶ
17:41:53 <Pseudonym> That doesn't mean my current font can has all utf-8 characters, of course.
17:42:00 <dmwit> ah, true
17:42:03 <Pseudonym> Details.
17:42:07 <dmwit> Okay, what's it most likely to have?
17:42:12 <dmwit> > say "\128"
17:42:19 <Pseudonym> "sing" works
17:42:26 <Olathe> > sing "La la la"
17:42:28 <lambdabot>   ♪ La la la ♪
17:42:37 <r3m0t> wtf
17:42:40 <r3m0t> :t sing
17:42:41 <lambdabot> [Char] -> Expr
17:42:46 <monochrom> Gödel loved ∀x . x = ¬x
17:43:05 <Olathe> sing x = say ("musicy " ++ x ++ " musicy")
17:43:07 <Pseudonym> So what fonts are you peoples using?
17:43:11 <dmwit> r3m0t: utf8s, say, sing are new ?let's, each defined in terms of the previous
17:43:25 <monochrom> I use whatever Ubuntu sets up.
17:43:33 <dmwit> =monochrom
17:43:42 <Pseudonym> Right.
17:43:48 <Pseudonym> Helpful. :-)
17:44:06 <dmwit> Which is... Monospace 12.
17:44:09 <dmwit> Is that more helpful?
17:44:10 <dmwit> =P
17:44:24 * T55555 slaps T55555 around a bit with a large trout
17:44:36 <dmwit> ?slap T55555
17:44:37 * lambdabot smacks T55555 about with a large trout
17:44:47 <Olathe> @slap lambdabot
17:44:47 * lambdabot decomposes lambdabot into several parts using the Banach-Tarski theorem and reassembles them to get two copies of lambdabot!
17:44:48 <monochrom> My experience is people who are picky "I insist on this version of irssi, over this version of screen, over this version of conduit, under this version of OS, running this version of ..." suffer the most trouble as they deserve.
17:44:57 <Olathe> OMG ! Two lambdabots !
17:44:57 <dmwit> Oh noes!
17:45:04 <dmwit> Automated bot-loops via Banach-Tarski!
17:45:08 <Olathe> Hahaha
17:45:13 <Ilmuri> I INSIST ON INSISTING INSISTING
17:45:25 <Myoma> heh
17:45:43 <dmwit> You may or may not insist on insisting insisting!
17:45:59 <dmwit> I DEMAND that you may or may not insist on insisting insisting.
17:46:00 <monochrom> "picky" is an understatement. those people are control freaks.
17:47:31 <monochrom> Anyway, the moment I let go and said "just slap Ubuntu on my computer and let it make most choices for me except for a few fringe things" everything began to work fine and I'm happy thereafter.
17:47:31 <Myoma> > (?) = (*2) in   ((((1 ?) ?) ?) ?)
17:47:32 <lambdabot>   mueval: Prelude.read: no parse
17:48:05 <dmwit> > let (?) = (*2) in ((((1 ?) ?) ?) ?)
17:48:06 <lambdabot>   16
17:50:19 <Olathe> > ((((1 ?) ?) ?) ?) where (?) = (?)
17:50:35 <lambdabot>   thread killed
17:50:57 <Olathe> > ((((1 ?) ?) ?) ?) where (?) = (*2)
17:50:58 <lambdabot>   16
17:51:18 <Myoma> cool how come where works now
17:51:25 <Myoma> > () where
17:51:26 <lambdabot>   ()
17:51:32 <Myoma> > () where where where
17:51:33 <lambdabot>   mueval: Prelude.read: no parse
17:51:38 <Myoma> > let in () where
17:51:40 <lambdabot>   ()
17:51:48 <dmwit> That's just odd.
17:51:49 <pastorn_> let i = id
17:51:55 <pastorn_> let came = True
17:52:04 <pastorn_> > let i = id
17:52:05 <lambdabot>   mueval: Prelude.read: no parse
17:52:08 <pastorn_> > let came = True
17:52:09 <lambdabot>   mueval: Prelude.read: no parse
17:52:11 <pastorn_> > i came
17:52:12 <lambdabot>   mueval: Prelude.read: no parse
17:52:19 <dmwit> > let i = not; came = False in i came
17:52:20 <lambdabot>   True
17:52:28 <pastorn_> yay
17:52:30 <Myoma> pastorn_, maybe open a /query with lambdabot
17:52:41 <dmwit> /query?
17:52:44 <pastorn_> Myoma: maybe that, but i wanna share the joy
17:52:48 <dmwit> Maybe you meant /msg?
17:52:49 <pastorn_> dmwit: /msg
17:53:06 <dmwit> Now I feel like a pedantic prick.
17:53:43 <pastorn_>  /query opens a a separate tab/window/whatever usually without sending a message
17:53:54 <pastorn_> oh, sorry, you were being a prick
17:55:03 <pastorn_> well
17:55:14 <pastorn_> screw you guise - i'm going home!
17:57:54 <dmwit> ?src readFile
17:57:54 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
17:58:00 <dmwit> ?src hGetContents
17:58:00 <lambdabot> Source not found. My mind is going. I can feel it.
17:58:06 <dmwit> No closeFile. =/
17:59:09 <dmwit> What does "semi-closed" mean?
18:01:12 <rwbarton> > let f (3 `Just`) = 5 in f 3
18:01:13 <lambdabot>   mueval: Prelude.read: no parse
18:02:34 <rwbarton> dmwit: It means the file handle isn't literally closed, because hGetContents is still going to read more from it; but you shouldn't do anything with the file handle or you'll break hGetContents.
18:02:53 <dmwit> urgh
18:03:02 <dmwit> Practically: it means I have to manage the handle myself. =/
18:03:59 <dmwit> Actually, maybe not...
18:04:02 <rwbarton> In simple cases, it means you should just forget about the handle's existence.  It'll get closed when you read past EOF.
18:04:16 <dmwit> Well, I want to read the file, mangle it, and write it back.
18:04:28 <dmwit> But of course I can't open it for writing, because the mangling is too lazy.
18:04:47 <dmwit> But I think it shouldn't be so hard to write an interactFile or so that does what I want...
18:05:00 <dmwit> Leave all my handle-handling in there.
18:05:01 <Cale> Yeah, there ought to be an interactFile in the libraries :)
18:05:09 <Cale> (but there is not)
18:05:32 <dmwit> I suspect that, like splitBy, there's too many possible semantics for the edge cases.
18:05:47 <SamB> such as running out of disk space?
18:06:05 <SamB> or race conditions with other programs?
18:06:20 <dmwit> I don't know... maybe dealing with files that don't exist?
18:06:32 <bd_> dmwit: exception out, then
18:06:39 <Cale> Those should probably be dealt with by applying the function to the empty input. :)
18:06:46 <SamB> dmwit: that could be parameterized or something
18:06:46 <bd_> it's easy enough on platforms that support atomic-rename (and/or unlink-while-open)
18:06:47 <dmwit> bd_: SEEEEE
18:06:59 <bd_> which is all of OSX+*nix+WinNT :)
18:07:02 <dmwit> There are already at least two possible behaviors.
18:07:08 <dmwit> s/two/three/
18:07:19 <bd_> although in the case of WinNT you need to specify some magic flags when opening the source file
18:07:25 <SamB> dmwit: doesn't mean it's not valueable to have an implementation in the library which supports all of them
18:07:38 <dibblego> http://hpaste.org/10054 Is there an Applicative or something for this function?
18:07:59 <dmwit> :t right
18:08:00 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either d b) (Either d c)
18:08:30 <SamB> dmwit: considering that none can be implemented well in portable Haskell, and even if they could there would be so many ways to screw it up
18:09:03 <SamB> of course, that's the same argument I gave for top-level <-, and we saw how well THAT turned out ...
18:09:06 <dmwit> dibblego: That's likely to be the nicest implementation of that.
18:09:19 <SamB> (nobody agreed with me :-())
18:09:23 <dibblego> dmwit, thanks
18:09:35 <SamB> (well, maybe one person agreed)
18:09:48 <dmwit> I bet SamB_XP agreed.
18:09:59 <SamB> SamB_XP is not a different person
18:10:04 <SamB> he's me, on another computer
18:10:16 <dmwit> (I know.)
18:10:27 <Pseudonym> It's your troll account, right?
18:10:37 <SamB> hah
18:10:48 <Pseudonym> lambdabot is my troll account./
18:10:50 <SamB> no, I just don't feel comfortable with irssi yet
18:11:13 <seydar> when i install a cabal package, how do i use it?
18:11:34 <dmwit> :t catch
18:11:36 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
18:11:37 <dmwit> :t bracket
18:11:38 <lambdabot> Not in scope: `bracket'
18:11:45 <dmwit> ?index bracket
18:11:45 <lambdabot> Control.Exception, Distribution.Compat.Exception, Graphics.HGL.Draw.Monad, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL
18:13:50 * SamB loves http://www.theonion.com/content/video/bush_tours_america_to_survey
18:13:52 <lambdabot> Title: Bush Tours America To Survey Damage Caused By His Disastrous Presidency | The On ..., http://tinyurl.com/5ooplv
18:14:26 * SamB also enjoyed http://www.theonion.com/content/video/diebold_accidentally_leaks
18:14:27 <lambdabot> Title: Diebold Accidentally Leaks Results Of 2008 Election Early | The Onion - America' ...
18:22:42 <bjrn> I have a program made of several modules I have built with GHC separately. How do I tell ghc to link in these compiled modules when building the main program? I've always used ghc --make but now I'd like some more control
18:24:01 <rwbarton> Is there a way to make ghci expand all type synonyms?
18:24:44 <monochrom> You can try "ghc -o myexe Module0.o Module1.o Module2.o ..."
18:25:10 <dmwit> rwbarton: No, but you can chase them down with :info
18:25:16 <bjrn> monochrom: Thanks. I tried -l as with gcc but that didn't work that well. :)
18:25:54 <rwbarton> dmwit: Yeah, that's a start
18:26:23 <rwbarton> dmwit: I feel like if they hadn't put in some work to get good error messages, this would happen automatically :)
18:26:47 <dmwit> heh
18:26:53 <adu> ok
18:27:02 <adu> so I need help with my type checker
18:27:15 <dmwit> It's broken.
18:27:17 <dmwit> Can you make it go?
18:27:31 <seydar> how do I tell where a cabal package was installed to? I'd like to use HsSyck
18:28:22 <Myoma> adu, what about it?
18:31:04 <adu> well I implemented (Ap f x) for f :: (Fn a b), x::a, but I ran into some problems when I tried to check for f :: (ForAll a (Fn a b)), so I'm wondering how "forall" is usually handled in typecheckers... because this seems like something thats been done before...
18:31:30 <dmwit> seydar: Usually, the "install" step either puts it in /usr/local/bin, or $PREFIX/bin, where $PREFIX is as specified in the --prefix option to the "configure" step.
18:31:53 <seydar> dmwit: how do i know what to use in "import X"?
18:32:00 <adu> or is "forall" something thats more syntax sugar that gets filtered out somehow before getting to the core language?
18:32:02 <dmwit> seydar: Oh!
18:32:08 <Myoma> there's usually a rule:     f :: forall a. a -> b |- f :: x -> b
18:32:22 <dmwit> seydar: Either look at the docs or the exposed-modules: section of the .cabal file.
18:32:35 <seydar> dmwit: thanks!
18:32:38 <Myoma> (not that specifically, but that's a relevant instance of it)
18:32:41 <seydar> checking it out now...
18:33:21 <dmwit> But you'd better look at the docs, or your next question will be "Okay, I've imported X, what functions are available now?". =)
18:33:29 <adu> Myoma: so "|-" is like the Prolog ":-"?
18:34:03 <Myoma> |- is closer to -:
18:34:42 <adu> oh ok
18:34:50 <Cale> adu: It means "entails" or "proves", that is, that it's possible to conclude the second thing, given the first.
18:35:03 <Cale> So I guess it's not far off. :)
18:35:17 <adu> sadly I'm more familiar with Prolog than rigorous math...
18:35:21 <seydar> dmwit: where is my '.cabal' file? I only see my directory
18:35:35 <dmwit> seydar: Wherever you installed it from.
18:35:39 <Myoma> x, y z |- c   is   c :- x, y, z.
18:35:52 <Myoma> roughly.
18:35:52 <dmwit> seydar: If you're using cabal-install, check out the page on hackage; it will list the exposed modules.
18:36:09 <seydar> dmwit: is cabal-install the same as just plain cabal?
18:36:14 <adu> Myoma: got it
18:36:15 <dmwit> no
18:37:25 <adu> Myoma: but I think this is evidence that I need a proper unification algorithm, and cannot rely on datatype equality...
18:37:44 <Myoma> adu: You can steal my unification code if you like :)
18:37:54 <adu> o right, you mentioned that...
18:38:04 <adu> Myoma: where is your unification code?
18:38:11 <Myoma> ?go rascal haskell
18:38:12 <lambdabot> No Result Found.
18:38:18 <Myoma> somewhere on google code ..
18:38:19 <seydar> dmwit: what do i do for just plain cabal?
18:38:23 <Myoma> Infer.hs
18:38:25 <seydar> the help page is the same
18:38:32 <dmwit> "the same"?
18:38:41 <adu> Myoma: I remember this one article that talked about call/pass/fail/back or something and all unification is based on those four phases... is that right?
18:38:55 <Myoma> never heard of that
18:39:11 <adu> maybe that's just the Warren machine
18:39:23 <Myoma> hm no doesn't sound like WAM
18:39:34 <Myoma> tehy use get_structure try_me_else_fail etc
18:40:07 <dmwit> What do you people think of this?
18:40:13 <dmwit> http://hpaste.org/10055
18:41:14 <seydar> dmwit: yay i got it to work!
18:41:20 <dmwit> great
18:41:24 <TSC> @type readFile
18:41:25 <lambdabot> FilePath -> IO String
18:41:29 <Myoma> adu,
18:41:30 <Myoma> @go prolog without cut in haskell
18:41:32 <lambdabot> http://muaddibspace.blogspot.com/2008/07/interpreter-for-prolog-without-cut.html
18:41:32 <lambdabot> Title: Muad`Dib: Interpreter for Prolog without cut
18:41:36 <Myoma> that is a unification algorithm
18:41:39 <dmwit> TSC: It doesn't close the handle, even if you read the entire file. =/
18:41:42 <TSC> Ah
18:41:55 <Myoma> using closures for state instead of STRefs
18:41:55 <TSC> Really?
18:41:55 <adu> dmwit: where does "f" appear in the first one?
18:42:04 <dmwit> TSC: Empirically, really.
18:42:06 <seydar> what does `seq` do?
18:42:12 <dmwit> TSC: Not sure what the standard says about that.
18:42:19 <TSC> That's bizarre
18:42:23 <dmwit> seydar: `seq` forces the evaluation of the first argument before the second.
18:42:26 <Myoma> seydar: I think of it as  a `seq` b means to take the WHNF of b you must first take the WHNF of a
18:42:35 <dmwit> adu: In the call to interactFileSuccess
18:42:44 <adu> Myoma: Muadib? I love Dune!
18:42:49 <seydar> gotcha
18:42:52 <Myoma> dune is great :)
18:42:57 <rwbarton> dmwit: You have to read past the end of the file (i.e., force the [] at the end of the list)
18:43:07 <dmwit> rwbarton: I am... right?
18:43:14 <rwbarton> dmwit: With the s==s, yes
18:43:30 <rwbarton> dmwit: (I was responding to "readFile doesn't close the handle")
18:43:35 <dmwit> I've actually changed the argument order locally, but the function bodies are the same.
18:43:40 <dmwit> rwbarton: Even then, it doesn't, here.
18:43:45 <adu> dmwit: why is it an argument to the first function if you don't use it?
18:43:53 <dmwit> adu: ...I *do* use it.
18:44:03 <dmwit> adu: In the call to the Success function.
18:44:06 <dmwit> (?)
18:44:25 <adu> dmwit: but interactFileSuccess doesn't use f in any way...
18:44:27 <TSC> in interactFileSuccess
18:44:32 <rwbarton> dmwit: If you don't want to worry about this kind of thing...
18:44:34 <rwbarton> @hackage strict
18:44:35 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/strict
18:44:36 <dmwit> adu: Oh, good point. =)
18:44:49 <adu> dmwit: so why does interactFileSuccess require f?
18:44:58 <dmwit> interactFileSuccess -> readFile'
18:45:04 <dmwit> New name, shorter argument list. =)
18:45:13 <adu> :)
18:45:15 <dmwit> I'll annotate in a second.
18:45:26 <seydar> dmwit: what exactly does that first function do? it looks like it just returns the content of the file
18:46:40 <dmwit> seydar: exactly
18:46:43 <dmwit> Okay, annotated.
18:46:59 <dmwit> seydar: The key is that it does it strictly, and closes the associated file handle before returning.
18:46:59 <seydar> what was the point of testing if it was the same as itself?
18:47:10 <dmwit> seydar: It forces hGetContents to read the entire file.
18:47:35 <adu> also, that reminds me, why does (withFile path ReadMode hGetContents) not the same as (readFile path)?
18:47:42 <seydar> why did you need the (s==s)? couldn't you just have hClose h?
18:47:47 <dmwit> hGetContents reads only until an hClose.
18:48:09 <dmwit> seydar: If you don't force the string you get from hGetContents, it remains lazy.
18:48:11 <seydar> bwah? explain
18:48:14 <seydar> oooh
18:48:18 <dmwit> seydar: An hClose terminates the read early.
18:48:27 <rwbarton> dmwit: were you saying this readFile' doesn't work?
18:48:28 <seydar> s == s evaluates s, and then you close it
18:48:38 <dmwit> rwbarton: No, it does work; it's more an RFC than anything.
18:49:09 <adu> dmwit: you should replace the implementation of readFile with that, because the last time I read the source, readFile does NOT close the handle...
18:49:24 <dmwit> I disagree.
18:49:32 <rwbarton> dmwit: Oh, OK.
18:49:33 <dmwit> Lazy IO is very nice for some things.
18:49:36 <Twey> 024813 < dmwit> seydar: If you don't force the string you get from hGetContents, it remains lazy.
18:49:42 <Twey> -- HACK :(
18:49:46 * dmwit nods
18:50:02 <dmwit> The other option is to, like, hGetLine in a loop, then unlines.
18:50:08 <rwbarton> dmwit: Replacing  (s==s) `seq` hClose h  with  evaluate (s==s)  would be more natural to me (I think it *should* get closed after that)
18:50:10 <dmwit> That doesn't seem much nicer to me, really.
18:50:16 <Twey> Or hRead the length of the file?
18:50:20 <dmwit> :t evaluate
18:50:21 <lambdabot> forall a. (Testable a) => a -> Gen Result
18:50:26 <rwbarton> @hoogle evaluate
18:50:27 <lambdabot> Control.Exception evaluate :: a -> IO a
18:50:27 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
18:50:36 <seydar> does GHC have an open commit policy?
18:51:05 <dmwit> rwbarton: Let me test.
18:51:36 <Twey> Huh
18:51:53 <SamB> seydar: no! only those of us who have somehow managed to get ssh access to darcs.haskell.org can commit ;-P
18:51:54 <Twey> What, no hRead :: Handle -> Integer -> IO String?
18:52:10 <Twey> None at all?  :-\
18:52:23 <dmwit> rwbarton: Cool!  That does seem to work.
18:52:40 <dmwit> (Although I have to admit, it seems a bit weird to me.  Probably just because I've never seen evaluate used before.)
18:53:15 <dmwit> Does evaluate only go to WHNF, too?
18:53:24 <dmwit> You need something fancier to go deep, right?
18:53:42 <Myoma> @hoogle rnf
18:53:42 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
18:54:16 <dmwit> Actually, looking at it now, I'm not sure I like the "evaluate" approach.
18:54:29 <dmwit> It hides the important part: hClose becomes implicit.
18:55:27 <rwbarton> dmwit: Well, if you already know that hGetContents is going to close the file, then the extra hClose seems redundant.  So it's a matter of opinion
18:55:35 <dmwit> yeah
18:55:38 <rwbarton> dmwit: But of course, two closes are not really wrong while zero closes are.
18:55:47 <dmwit> ah
18:55:53 <dmwit> That's an interesting point.
18:55:59 <dmwit> I think I'm actually doing two closes in the old one.
18:56:09 <dmwit> (s == s) `seq` hClose h -- right here are both of them
18:56:36 <rwbarton> anyways, the "right" way is to use the strict package
18:56:59 <dmwit> agreed
18:57:08 <adu> Myoma: I'll take a look at the Prolog code, and let you know if understand it/can use it...
18:57:56 <Myoma> adu, I hope it helps but also check out rascal/Infer.hs if you like -- that is the thing which I think is more likely to be of actual use (I just linked that page as a short description of unification algorithm)
18:58:27 <chrisdone> 30,000 lines in this channel. ERC becomes really slow. do you guys just /clear regularly or something?
18:58:46 <adu> ok, but I'm wondering what the fancy arrows mean?
18:58:49 <Twey> Haha, ERC :-\
18:59:04 <dmwit> chrisdone: Most IRC clients have a way to limit the scrollback.
18:59:14 * Myoma does not know what fancy arrows you mean
18:59:42 <chrisdone> dmwit: yeah, good point. I'll set a limit
18:59:52 <EvanR> ahttp://www.haskell.org/haskellwiki/Research_papers/Monads_and_arrows
18:59:53 <SamB> my client is currently set to 5000
18:59:58 <SamB> I should so up that ...
19:00:04 <lambdabot> Title: Research papers/Monads and arrows - HaskellWiki, http://tinyurl.com/yyte4n
19:00:12 * SamB tries 15000
19:00:14 <adu> Myoma: the arrows defined on the line after "variables (Var v) = [v] ; variables (_:>vs)"
19:00:39 <chrisdone> I generally like searching the scrollback with emacs's C-s, and the ability to split the buffer so that I can scroll up while still being able to see what people are saying...
19:00:46 <Myoma> Var v   is  V,  "foo":>[Var x, ...] is  foo(X,...)
19:02:04 <dmwit> dcoutts: ping
19:04:02 <dmwit> ?tell dcoutts Installing cabal-install, bootstrap.sh uses pushd and popd.  Apparently my /bin/sh doesn't have pushd and popd...  dunno if this is (ought to be) my problem or whether bootstrap.sh should be changed.
19:04:02 <lambdabot> Consider it noted.
19:04:36 <seydar> Twey: why was the lazy file contents a hack?
19:05:29 <bd_> seydar: once you read a file lazily, you can't safely do anything with that file until you force the entire string
19:05:48 <dmwit> seydar: It's a hack because there *ought* to be a strict file read function available.
19:05:55 <shapr> Because the filesystem can change?
19:05:58 <bd_> :t Data.ByteString.getContents
19:05:59 <lambdabot> IO BSC.ByteString
19:06:02 <seydar> oh! gotcha
19:06:03 <bd_> ^^^ there is :)
19:06:20 <bd_> :t fmap BSC.unpack Data.ByteString.getContents
19:06:21 <lambdabot> IO [Char]
19:06:23 <Twey> And because it depends on the assumption that == will have to read all of the list
19:06:25 <seydar> the contents of the string may not be what was in the file at the time of calling the function
19:06:31 <Twey> Which is not a safe assumption
19:06:40 <dmwit> Twey: Oh, go on then.
19:06:47 <Twey> Heh
19:06:57 <bd_> unfortunately, popular filesystems have yet to implement snapshot-on-open semantics :|
19:07:03 <bd_> although a few have the pieces for it
19:07:08 <dmwit> Twey: I dare you to find a single implementation that can make *that* optimization.
19:07:09 <Twey> I would rather write a strict one using hGetChar
19:07:20 <Twey> Yes, yes, but it's still a hack
19:07:28 * dmwit nods
19:07:33 <Twey> It's not guaranteed to work by the language.
19:07:36 <bd_> Twey: seriously, use Data.Bytestring's implementation. More memory efficient too :)
19:07:37 <dmwit> length might work better
19:08:04 <dmwit> But as rwbarton says, the strict package is the right answer.
19:13:04 <dmwit> Can anybody help with cabal-install?
19:13:05 <dmwit> http://hpaste.org/10057
19:14:02 <chrisdone> yeah, sod erc
19:14:43 <mmorrow> > (say . unlines) (["♖♘♗♔♕♗♘♖"] ++ fmap (replicate 8) "♙♟" ++ ["♜♞♝♛♚♝♞♜"])
19:14:44 <lambdabot>   ♖♘♗♔♕♗♘♖
19:14:44 <lambdabot>  ♙♙♙♙♙♙♙♙
19:14:44 <lambdabot>  ♟♟♟♟♟♟♟...
19:15:01 <chrisdone> woah
19:15:04 <mmorrow> it'd be pretty cool if lambdabot could play chess
19:15:10 <chrisdone> haha
19:15:13 <mmorrow> ha
19:15:22 <SamB> wtf? â™Ÿâ™Ÿâ™Ÿâ™Ÿâ™Ÿâ™Ÿâ™Ÿâ™
19:15:26 <chrisdone> I so never knew those chars existed
19:15:46 <dmwit> SamB: My guess is that the ... cuts in at an inopportune time, turning valid UTF-8 to invalid UTF-8.
19:15:54 <dmwit> So your client drops to some other encoding.
19:15:54 <mmorrow> yeah, have to add a lengthUTF8 function, then use that to make sure we're not hopping a utf8char in two
19:15:57 <SamB> chrisdone: how do you think they write up those chess boards in the newspaper?
19:16:12 <mmorrow> s/hopping/chopping/
19:16:14 <chrisdone> SamB: uh, word art?
19:16:33 * SamB is kidding ;-P
19:16:44 <chrisdone> so was I, Word is lame
19:17:11 <chrisdone> mmorrow: that's cool
19:17:39 <chrisdone> a String class would make it all go away :P
19:17:46 <mmorrow> chrisdone: one could make a killer console chess game i'm thinking
19:17:56 <chrisdone> stringLength :: String a => a -> Integer
19:17:57 <dmwit> rwbarton++
19:18:01 <chrisdone> mmorrow: haha, yeah
19:18:58 <chrisdone> mmorrow: you sunk my battle ship. huh huh
19:19:15 <mmorrow> here's length in chars for utf8 (it's judging based on the examining the first byte, and if that byte isn't the first in a multibyte char, it just sayd 0 len): http://hpaste.org/10052#a1
19:19:51 <mmorrow> chrisdone: heh, battleship is a classic
19:20:53 <mmorrow> s/chars/bytes/
19:22:07 <Myoma> mmorrow: I thought about doing it with HTTP
19:22:15 <Myoma> in a <table>
19:22:35 <mmorrow> Myoma: nice, with the unicode chess pieces?
19:22:38 <Myoma> you just go to 127.0.0.1:8080 and play chess against LogicT
19:22:43 <mmorrow> haha
19:22:53 <Myoma> maybe I will code it if I get bored of what I am doing currently
19:23:16 <chrisdone> nice
19:23:51 <chrisdone> mmorrow: lengthUTF = sum . map lenUTF8?
19:24:18 <rwbarton> ghc 6.8.2 doesn't have view patterns?
19:24:30 <Myoma> I think it only came in with 6.9
19:24:41 <rwbarton> ok
19:26:15 <mmorrow> Myoma: if you decide to do it, here's a mini httpd that might help http://code.haskell.org/~morrow/code/haskell/misc/neutron.hs
19:26:33 <dmwit> Why not take the length *before* converting to UTF-8?
19:27:11 <mmorrow> chrisdone: err, say you have a [Word8], then you'd find the len of the first Word8, then skip that many Word8s, and repeat
19:27:39 <chrisdone> mmorrow: ah ok
19:28:22 <mmorrow> dmwit: because an encoded char could be between 1-4 bytes, so you don't really know how long a utf8 encoded string will turn out just based on the length of the initial string
19:28:47 <dmwit> I don't get it.
19:28:52 <dmwit> What length are you measuring?
19:28:53 <EvanR> utf8, it can be longer than 4
19:29:02 <dmwit> Number of codepoints, or length in bytes of the UTF-8?
19:29:02 <mmorrow> > utf8s "\14400"
19:29:04 <lambdabot>   "\227\161\128"
19:29:24 <mmorrow> oh, actually you can do utf8 length like this ...
19:29:50 <glguy> EvanR: utf8 is 1 - 4 bytes
19:30:00 <dmwit> glguy, EvanR: for now
19:30:24 <mmorrow> > sum . fmap (length . utf8) $ "asdfgfds" ++ "\8704" ++ take 5 ['\15344'..]
19:30:25 <dmwit> The Unicode standard makes no guarantees about the maximum number of bits in a codepoint.
19:30:25 <lambdabot>   26
19:30:36 <mauke> 21
19:30:39 <mmorrow> > length $ "asdfgfds" ++ "\8704" ++ take 5 ['\15344'..]
19:30:40 <lambdabot>   14
19:30:47 <chrisdone> guys what music track should I listen to?
19:30:49 <mmorrow> > length $ "asdfgfds" ++ "\8704" ++ take 5 ['a'..]
19:30:51 <lambdabot>   14
19:30:55 <dmwit> chrisdone: Metroid Metal!
19:30:57 <mmorrow> > sum . fmap (length . utf8) $ "asdfgfds" ++ "\8704" ++ take 5 ['a'..]
19:30:58 <lambdabot>   16
19:31:10 * chrisdone listens
19:31:38 <Twey> chrisdone: 'Wrong Foot Forward'
19:31:46 <dmwit> wget -rl1 -A mp3 http://metroidmetal.com/songs.html # wget FTW
19:31:46 <lambdabot> Title: MetroidMetal.com
19:31:55 <mmorrow> dmwit: the max number of /bytes/ a utf32 char maps to under the utf8 encoding is 4
19:31:59 <chrisdone> dmwit: haha
19:32:26 <dmwit> mmorrow: As I said... for now.
19:32:45 <chrisdone> Twey: nice
19:32:49 <dmwit> A Char might eventually need to be 64 bits wide to fit all the codepoints.
19:32:55 <mmorrow> oh, sure. when the spec changes, we'll update our length functions :)
19:32:57 <dmwit> (It's not likely, but...)
19:33:50 <glguy> dmwit: well, for now the utf8 spec defines 10ffff as the upper bound, so no sense in speculating
19:34:31 <mauke> > showHex (2 ^ 21 -1) ""
19:34:32 <lambdabot>   mueval: Prelude.read: no parse
19:36:18 <mmorrow> dmwit: i used the utf8 section here for ref (on-paper-page 103 == pdf-page 41) http://www.unicode.org/versions/Unicode5.0.0/ch03.pdf
19:36:20 <lambdabot> Title: cache:http://www.unicode.org/versions/Unicode5.0.0/ch03.pdf - Google Search
19:36:30 <mmorrow> which i got to from http://www.unicode.org/versions/Unicode5.1.0/
19:36:30 <lambdabot> Title: Unicode 5.1.0
19:36:37 <mmorrow> interesting stuff
19:36:54 * dmwit accepts defeat
19:37:13 <mmorrow> heh
19:37:19 <dmwit> ...for now
19:37:21 <dmwit> ;-)
19:37:22 <mmorrow> haha
19:37:30 <chrisdone> ~_~"
19:37:40 <mauke> http://mauke.ath.cx/tmp/dev.html
19:37:44 <lambdabot> Title: Developers Developers Developers Developers Developers Developers Developers Dev ...
19:38:08 <mmorrow> haha
19:38:13 <chrisdone> oh man
19:38:22 <chrisdone> I'm going to listen to the remix of that now
19:38:24 <dmwit> pretty short <body>
19:38:40 <mmorrow> i wonder it it'd crash browsers if you just never stopped sending more and more title
19:40:16 <mmorrow> main = runCGI (output . renderHtml $ head ! [title (repeat 'a')])
19:40:26 <mmorrow> main = runCGI (output . renderHtml $ head ! [title (repeat 'a')] << noHtml)
19:40:40 <mmorrow> err, header i think
19:54:49 <dmwit> ?index stdout
19:54:49 <lambdabot> System.IO
19:57:33 <dmwit> ?index comparing
19:57:33 <lambdabot> bzzt
19:57:36 <dmwit> huh
19:57:41 <dmwit> ?index compare
19:57:41 <lambdabot> Prelude
19:57:45 <dmwit> ?index on
19:57:45 <lambdabot> bzzt
19:57:48 <dmwit> boooo
19:58:53 <seydar> why is ghc giving me this error? http://hpaste.org/10058
19:59:38 <dmwit> pos doesn't have the type you think it does
19:59:44 <dmwit> You'll have to paste more code to get a better answer.
20:03:46 <seydar> hmm
20:03:56 <seydar> i'm gonna pull out a can of Raid and get back to you
20:04:35 <dmwit> Raid?
20:04:36 <rwbarton> (How/why did ghc turn (>=) into flip (<=)?)
20:04:50 <dmwit> rwbarton: I think seydar did that transformation via a bad paste.
20:05:17 <dmwit> Also: (>=) = flip (<=) is a default definition in the Ord class.
20:05:20 <dmwit> ?src Ord
20:05:20 <lambdabot> class  (Eq a) => Ord a  where
20:05:20 <lambdabot>     compare      :: a -> a -> Ordering
20:05:20 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
20:05:20 <lambdabot>     max, min         :: a -> a -> a
20:05:28 <dmwit> (Not shown here. =)
20:05:30 <seydar> rwbarton: yea, that was a bad paste
20:06:34 <chylli> how to compile a file which use 'forall' ?
20:06:53 <rwbarton> (Yeah, it was more 'why' than 'how')
20:07:21 <dmwit> chylli: Doesn't GHC suggest a LANGUAGE pragma for you?
20:07:47 <seydar> d'oh. pos is a function and wasn't defined as a variable. i needed to use pc
20:07:49 <chylli> dmwit: oh sorry, I forget that pragma. thanks
20:09:01 <dmwit> ghc -Wall seems broken in 6.8
20:09:37 <dzlk> J
20:10:15 <seydar> Twey: how do mutable unboxed arrays work in haskell?
20:10:17 <dmwit> Oh, I see what it's doing...
20:12:02 <dzlk> ...is an interesting language, but that mention of it was purely a keyboard accident. (oops.)
20:12:29 <dmwit> hehe
20:12:50 <dmwit> seydar: Check out the STUArray module.
20:13:09 <seydar> dmwit: but how does the concept of mutable even exist?
20:13:10 <dmwit> (Also the check out the ST monad.)
20:13:16 <dmwit> Monads!
20:13:41 <dmwit> The ST monad allows mutation inside the monad; once you've run the monad, however, ST guarantees that no more mutation can happen.
20:13:56 <dmwit> It's all very, very clever, and uses some type-system hacks that aren't really Haskell at all. =)
20:14:10 <dmwit> Well... s/Haskell/Haskell 98/
20:14:21 <dmwit> Some would argue that Haskell 98 isn't Haskell any more. =P
20:14:34 <seydar> i'm confused... How can i use monads to represent mutability? any reference docs?
20:14:55 <dmwit> seydar: Have you ever used the State monad?
20:15:02 <dmwit> ST is very similar.
20:15:06 <seydar> a few times
20:15:07 <dmwit> If not, you should maybe start there.
20:15:16 <dmwit> Basically:
20:15:32 <dmwit> You make a reference object, which acts a bit like a pointer.
20:15:52 <dmwit> The reference itself doesn't change, but what it references can be modified with a special ST-specific interface.
20:16:08 <dmwit> I don't know if there's a good tutorial on it.
20:16:19 <dmwit> But once you grok State, the docs for ST should get you most of the way there.
20:16:46 <bd_> Hmm, given that STRef's argument is not qualified with Dynamic, is it possible to make a pure-haskell ST implementation without using unsafeCast?
20:17:20 <seydar> dammit this sucks! i spent like 5 hours learning and mildly grokking state, and now i forgot it all
20:17:21 <dzlk> dmwit: sounds like set! in scheme, sort of.
20:17:40 <dmwit> bd_: no
20:17:51 <dmwit> bd_: At some point, you have to do something unsafe.
20:18:05 <bd_> dzlk: sort of, but it's confined to the ST monad. That is, a function using ST can be proven to be pure, even though it uses runST, because none of the variable references are allowed to leave the ST monad.
20:18:21 <dmwit> seydar: I found this helpful, for State: http://scienceblogs.com/goodmath/2007/01/more_monads_stateful_programmi_1.php
20:18:23 <lambdabot> Title: Good Math, Bad Math : More Monads: Stateful Programming, http://tinyurl.com/34gwz7
20:18:25 <bd_> dmwit: Darn. I was hoping there would be some typeclass cleverness that'd save us here.
20:20:09 <seydar> dmwit: thanks!
20:21:11 <seydar> newsham: can you show me those State  monad examples again?
20:24:11 <seydar> whew, i had that monad stuff bookmarked
20:28:10 <newsham> > runState (do { x <- get; put (2*x); return (3+x) } ) 10
20:28:12 <lambdabot>   (13,20)
20:28:49 <newsham> > runState (do { modify (*2); gets (*3) } ) 10
20:28:50 <lambdabot>   (60,20)
20:28:58 <cmars232> > sum [1..]
20:29:33 <lambdabot>   thread killed
20:29:36 <cmars232> lol
20:30:03 <cmars232> sorry, i had to satisfy my curiosity lambdabot
20:32:48 <Twey> > runState (modify (*2) >> gets (*3)) 10
20:32:52 <lambdabot>   (60,20)
20:33:00 <Twey> Oh, that's how it works
20:39:55 <ddarius_> > sum [1..] :: Expr
20:40:55 <lambdabot>   thread killed
20:42:06 <rwbarton> > foldr (+) 0 [1..] :: Expr -- foldl ftl
20:42:07 <lambdabot>   1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + (11 + (12 + (13 + (14 + (...
20:43:03 <TSC> > sum [1..20] :: Expr
20:43:05 <lambdabot>   0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + ...
21:00:23 <chrisdone> oh wow I just discovered the jon harrop appreciation blog
21:01:50 <chrisdone> http://harrop-highly.blogspot.com/
21:01:50 <lambdabot> Title: Jon Harrop Does Not Think Highly of Your Language
21:02:04 * chrisdone giggles
21:06:06 <shapr> uh oh
21:06:24 <shapr> Whatever happened to the Harrop defamation thread on reddit?
21:07:53 <tessier> You can't swing a brain-dead php coder on reddit without hitting a haskell tutorial.
21:08:15 <shapr> And Harrop is there to respond!
21:08:53 <dzlk> tessier: that's a great image. I want to try it just to see what happens on impact. :)
21:09:26 <Twey> Explosm
21:09:49 <tessier> dzlk: PHP coders are very soft and squishy like a rotten tomato and haskell monad tutorials are sharp like a razor so I'm sure the results would be interesting.
21:10:35 <thoughtpolice> language.c is lots o' fun :] http://hpaste.org/10059
21:13:41 <shapr> thoughtpolice: Er, what is this? intellisense for emacs?
21:14:12 <shapr> Anyone know how close C# is to C? I'm guessing not very close at all...
21:14:20 <dmwit> shapr: It's closer to Java.
21:14:31 <shapr> I've never heard of a Language.Java
21:14:49 <dmwit> Anybody know how cabal decides what subdirectory of dist/build to make?
21:15:00 <shapr> thoughtpolice: Oh that's cool! I get it!
21:15:24 <dmwit> ack, never mind
21:15:29 <shapr> dmwit: I always get dist/build/$PROJECTNAME
21:15:29 <thoughtpolice> hehe, yeah I just decided to play with language.c today
21:15:34 <thoughtpolice> lack of examples, really fun project :]
21:15:52 <shapr> I tried to parse through GHC's Linker.c with Language.C, but I couldn't figure out how includes work.
21:15:58 <dmwit> shapr: It's dist/build/$Executablename, in case you care. =)
21:16:02 <shapr> ah
21:16:04 <shapr> Good to know
21:16:11 <dmwit> You probably just name your projects after their executables.
21:16:14 <tessier> If Willie Nelson were a haskell coder: http://www.muitovar.com/monad/moncow.xhtml
21:16:15 <dmwit> Now, I am doing that, too.
21:16:17 <dmwit> =)
21:16:28 <Twey> Argh
21:16:34 <Twey> I wasn't aware of Harrop before
21:16:42 * tessier either
21:16:50 <tessier> I mean, who reads Usenet anymore anyway?
21:16:52 <Twey> This is homicide-inducingly amusing
21:17:03 <SamB_XP> dmwit: or vice-versa
21:17:10 <shapr> I think Harrop is really unhappy that OCaml is not as successful as Haskell community-wise.
21:17:36 <dons> thoughtpolice: yeah, we need an examples wiki.
21:17:39 <dons> start collecting examples now.
21:17:44 <SamB_XP> shapr: didn't anyone tell him that the proper way to rectify the situation is to get you entusiastic about ocaml?
21:17:52 <shapr> haha
21:17:55 <tessier> shapr: Isn't Harrop advocating F# not OCaml?
21:17:58 <dons> shapr: he can't make money from haskell.
21:18:07 <shapr> Funny, some people can...
21:18:09 <dons> shapr: since we give away for free the kinds of things he tries to sell.
21:18:12 * shapr looks at dons 
21:18:14 <dons> our community is an effective market for ideas.
21:18:25 <shapr> Er, what's he selling?
21:18:29 <shapr> I don't even remember.
21:18:36 <shapr> OCaml something for scientists...
21:18:41 <SamB_XP> dons: wait, so if ocaml had that kind of community that would also mess up his plans?
21:18:44 * shapr shrugs
21:18:49 <SamB_XP> I don't get his problem then
21:18:54 <dons> he sells books about how to use the languages to solve particular "scientific" problems.
21:19:02 <shapr> oookay
21:19:07 <SamB_XP> what are "scientific" problems?
21:19:15 <dons> but we just put that kind of stuff on a wiki.
21:19:18 <ike_> integral f(x)
21:19:22 <Myoma> lets all talk about jon harrop in #jonharrop
21:19:25 <dons> he also sells the kinds of libraries we put on hackage for free.
21:19:31 <Myoma> (I wont be there)
21:19:38 <SamB_XP> so basically he'd be f'd if they had our kind of community!
21:19:39 <dmwit> =Myoma
21:19:47 <SamB_XP> and yet he complains that they don't~!
21:19:50 <thoughtpolice> dons: should we just use the wiki set up for Language.c to record examples or haskell.org's?
21:19:52 <SamB_XP> s/~//
21:19:56 <dons> thoughtpolice: i think so.
21:20:02 <SamB_XP> dons: which?
21:20:06 <dmwit> Myoma: Although Harrop spam is better than some of the off-topic stuff that comes in here. =)
21:20:07 <thoughtpolice> dons: it is a really fun package, so recording examples is a good idea
21:20:13 <SamB_XP> dmwit: what?
21:20:19 <dons> there are some nice Language.C examples we've been playing with at galois that'll come out in the next couple of week.s
21:20:28 <dons> did you know it can parse the full linux kernel source... ?
21:20:29 * SamB also enjoyed http://www.theonion.com/content/video/diebold_accidentally_leaks
21:20:30 <lambdabot> Title: Diebold Accidentally Leaks Results Of 2008 Election Early | The Onion - America' ...
21:20:38 <shapr> Anyway, to be more on-topic, I think I got Fermat's Last Margin working again, but I'm having problems configuring Apache :-/
21:20:50 <SamB_XP> shapr: why apache?
21:21:11 <shapr> Because I tried to get lighttpd to do userdir cgi stuff, and couldn't figure it out.
21:21:17 <thoughtpolice> dons: impressive. :] the AST is a little awkward although I think I have gotten the hang of using it, lots of little functions to build the various AST pieces helps a lot
21:21:22 <shapr> SamB_XP: Do you know how to do that?
21:21:30 <SamB_XP> no
21:21:38 <ike_> I'm looking for a lightweight web-server which is written in Haskell
21:21:44 <SamB_XP> I'd use twisted.web for some reason
21:21:44 <shapr> ike_: ooh, me too!
21:21:50 <ike_> I mean "a lightweight" as lighttpd
21:21:50 <Myoma> mm
21:21:52 <Myoma> what about
21:22:00 <ike_> and if there is not, then I try to work for it
21:22:00 <shapr> ike_: Why not use lighttpd and cgi?
21:22:05 * Myoma is going to try something out with http://code.haskell.org/~morrow/code/haskell/misc/neutron.hs soon
21:22:08 <shapr> or lighttpd and fastcgi?
21:22:11 <dmwit> Or better, lighttpd and fastcgi
21:22:19 <Myoma> but I don't know what it is/does anything
21:22:20 * shapr hugs Myoma
21:22:30 <ike_> shapr: If you see the source of lighttpd, you realize how it is NOT clean
21:22:50 <shapr> I haven't looked.
21:22:51 <ike_> sorry for develoers of lighttpd, but I think so
21:22:58 <shapr> Hey, if it's your opinion.
21:23:11 <SamB_XP> I don't expect they're here
21:23:15 <Myoma> :)))
21:23:21 <SamB_XP> or if they are, they'll probably agree with you
21:23:23 <dons> ike_: tibbe's writing one.
21:23:24 <shapr> There was a Haskell Web Server called HWS, I don't know where it is now.
21:23:32 <dons> ike_: there's one in happs as well, of course.
21:23:41 <ike_> hmm
21:23:44 <shapr> I didn't think HWS was particularly clean either.
21:24:08 <ike_> happs is one way, but it is a large project
21:24:14 <dons> port some the erlang one to a fast multicore concurrency implementation?
21:24:26 <mmorrow> could someone give me a quick run through of de Bruijn levels
21:24:28 <mmorrow> ?
21:24:30 <dons> is the happs server part standalone?
21:24:35 <Myoma> mmorrow: I can try
21:24:43 <mmorrow> Myoma: awesome
21:24:54 <shapr> mmorrow: You have to fight the boss at the end of all the levels.
21:25:03 <mmorrow> shapr: heh
21:25:03 <thoughtpolice> tibbe's webserver has left folds - oleg-win! :]
21:25:10 <Myoma> \x -> \y -> x  ~~> λλ1
21:25:11 <Myoma> \x -> \y -> y  ~~> λλ0
21:25:26 <mmorrow> ahh, ok.
21:25:28 <Myoma> 0 is the closest lambda
21:25:43 <ike_> I see an example of HappS: a simple hello server
21:25:43 <Myoma> and succ each time gives the next outer binding
21:25:53 <Myoma> \u -> u u ~~> λ(0 0)
21:26:33 <Myoma> \a b c d -> (b d) (a c) ~~> λλλλ((2 0) (3 1))
21:26:47 <ike_> and there seems no "blacklist" which is contained of webbots
21:26:53 <mmorrow> so \f -> \x -> f x --> \\10 ?
21:26:59 <Myoma> yes
21:27:28 <mmorrow> ahhh, ok. i was thinking it was the other way around.
21:27:33 <ike_> webbot send a webserver to illegal HTTP messages
21:27:56 <mmorrow> Myoma: i'm going through this: http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=95
21:27:58 <lambdabot> Title: FP Lunch » Blog Archive » The shortest beta-normalizer
21:28:02 <mmorrow> pretty slick
21:28:05 <SamB_XP> how do you send the server to the messages?
21:28:11 <SamB_XP> ... isn't it the other way around?
21:28:14 <ike_> I say, we need not only lightweight but also (almost) safe web server
21:28:54 <ike_> unfortunately, (in my opinion), lighttpd seems not so safe(but lightweight)
21:28:56 <mmorrow> Myoma: and i've got the code running in ghci, but was unsure of how to construct terms.
21:28:59 <mmorrow> Myoma: thanks
21:29:21 <ike_> apache seems safer than lighttpd but heavier than others
21:29:41 <Myoma> mmorrow: also fun is
21:29:42 <Myoma> data Bruijn i where
21:29:42 <Myoma>  Var :: i -> Bruijn i
21:29:42 <Myoma>  Lam :: Bruijn (Maybe i) -> Bruijn i
21:29:42 <Myoma>  App :: Bruijn i -> Bruijn i -> Bruijn i
21:30:02 <ike_> we know a trade-off and I want the middle of them
21:30:07 <geezusfreeek> HAppS-Server basically offers a web server through its SimpleHTTP module. it is pretty easy to set it up as a plain file server, but it also can used for basically any custom web serving you could want. it is pretty light weight as far as i know. you just would have to do all your configuration through a haskell main function and compile it
21:30:20 <Myoma> mmorrow: So each Lam gives you a new 'Maybe' or scope, and each Var Nothing eats a single scope.. Var (Just (Just Nothing)) eats two scopes
21:30:38 <Myoma> mmorrow: This way you can check how many free variables or if a term is closed in the type
21:31:02 <Myoma> (If you imagine: Nothing = 0, Just = (1+))
21:31:15 <ike_> geezusfreek: thanks, I'll first try how HAppS-Server can be "safe", as I mean
21:31:16 <mmorrow> Myoma: whoa, nice.
21:32:00 <geezusfreeek> ike_: i'm sorry, i am having trouble understanding your english
21:32:34 * mmorrow goes to write some terms
21:32:36 <Myoma> *Main> :t Lam (Lam (App (Var Nothing) (Var (Just Nothing)))) -- λλ(0 1)
21:32:36 <Myoma> Lam (Lam (App (Var Nothing) (Var (Just Nothing)))) :: Bruijn i
21:32:36 <ike_> geezusfreek: don't warry. it's because I'm not native english speaker
21:32:48 <mmorrow> Lam(Var(0)!Var(0))!Lam(Var(0)!Var(0))
21:32:51 <mmorrow> :)
21:32:55 <dons> you want a small web server whose code you can trust, ike_ ?
21:32:57 <geezusfreeek> i was assuming that was it ;)
21:33:06 <ike_> dons: right!
21:33:12 <geezusfreeek> ah!
21:33:59 <mmorrow> ike_: why does lighttpd seem not so safe?
21:34:08 <SamB_XP> dons: trust not to have any non-obvious vulnerabilities
21:34:43 <ike_> not only code but also "web security
21:34:56 <geezusfreeek> ike_: safe defaults?
21:34:56 <ike_> uhh, unfortunately, my boss is comming
21:35:10 <ike_> let discuss later again, thanks all
21:35:41 <SamB_XP> ike_: what, they didn't tell you about the boss key?
21:36:03 <ike_> hehe
21:36:29 <ike_> geezusfreek: safe defaults based on Haskell Type system is better
21:39:07 <ivanm> dons: so when can we expect RWH in book stores, rather than just pre-orders?
21:40:08 <Myoma> :SS
21:40:17 <SamB_XP> ivanm: what you do is you go to the bookstore and tell them you want the book
21:40:18 <Myoma> I just look at any programming problem and it's a fold
21:40:32 <Myoma> I got folditis
21:40:42 <SamB_XP> ivanm: they'll be happy to order it for you and tell you when it gets there
21:40:42 <humasect> =)
21:40:54 <Twey> Myoma: Good!  Good!  That's good!
21:40:58 <ivanm> SamB_XP: yeah, but aussie bookstores are too expensive :(
21:40:59 <Twey> Next step is, uhm
21:41:10 <ivanm> if I was going to get it, it'd be cheaper to get it through amazon :s
21:41:12 <Twey> Using scanl!
21:41:12 <SamB_XP> ivanm: well, then you don't do it
21:41:37 <SamB_XP> but isn't amazon cheaper in most places for expensive books?
21:43:26 <ivanm> yes, but cheaper even including international postage? :s
21:43:41 <dons> ivanm: 6-8 weeks?
21:44:00 <ivanm> dons: *nod* so ready _before_ the christmas rush? :P
21:44:43 <dons> yep
21:52:34 <gwern> yow! I just had an EPIPHANY - republicans and democrats are as alike as two peas in a peanut butter jar!
21:54:13 <ivanm> gwern: right...
21:54:33 <gwern> @yow
21:54:33 <lambdabot> I want you to organize my PASTRY trays ... my TEA-TINS are gleaming in
21:54:33 <lambdabot> formation like a ROW of DRUM MAJORETTES -- please don't be FURIOUS with me --
21:54:51 <gwern> ivanm: try coming up with yowisms manually. they're kind of fun
21:55:01 <ivanm> ...or not...
21:55:53 <SamB_XP> gwern: isn't there someone who gets payed to do that?
21:56:00 <SamB_XP> also they are called zippyisms
21:56:22 <Myoma> I thought they were randomly generated!
21:56:59 <SamB_XP> no, they come from Zippy the Pinhead by way of the debian package fortunes-off
21:57:02 <gwern> SamB_XP: alas, the Zippy cartoonist does get paid to do it
21:57:05 <gwern> or possibly spayed
21:57:25 * gwern is unsure; I swing from thinking Zippy is genius to pretentious nonsense on a reglar basis
21:57:40 <Myoma> @yay
21:57:41 <lambdabot> Maybe you meant: faq map yarr yow
21:57:43 <Myoma> @yaw
21:57:43 <lambdabot> Kids, the seven basic food groups are GUM, PUFF PASTRY, PIZZA,
21:57:43 <lambdabot> PESTICIDES, ANTIBIOTICS, NUTRA-SWEET and MILK DUDS!!
21:58:21 * Twey laughs.
21:58:30 <SamB_XP> for some reason fortunes-off still has them even though GNU Emacs apparantly got scared and dropped 'em, apparantly for reasons of copyright...
21:58:39 <Twey> What on Earth is a 'milk dud'?  :-D
21:58:48 <Myoma> I think it's a kind of sweet
21:58:49 <SamB> Twey: it's a kind of candy
21:58:53 <Twey> Oh, right
21:58:54 <Twey> Haha
21:59:12 <Myoma> @. leet yaw
21:59:13 <lambdabot> Plugin `compose' failed with: Unknown command: "leet"
21:59:19 <Myoma> @. elete yaw
21:59:19 <lambdabot> Plugin `compose' failed with: Unknown command: "elete"
21:59:22 <SamB> chocolate-covered spheres of something
21:59:23 <Myoma> what's the elite one
21:59:39 <SamB> @. elite yow
21:59:40 <lambdabot> YOu 5h0u|d 4|L JUMp uP aND D0\/\/n 4 +Wo |-|ouR5 WhI|3 i D3cId3 on a nEW (areer!!
21:59:53 <Myoma> @. elite yow
21:59:54 <lambdabot> ... 7he /\/\yS+ErI4ns aRe In |-|er3 \/\/I+h MY CORdUrOy S0ap DISH!!
22:00:21 <Myoma> zippy can be read online?
22:00:37 <Myoma> It's a comic not some kind of tv show?
22:00:43 <SamB> yes, a comic
22:01:25 <Myoma> I just watched half of metropolisa
22:02:32 * SamB tries to view the zippy strips for december 2008
22:02:57 <gwern> Myoma: which metropolis?
22:03:00 <SamB> (it's in the dropdown box!)
22:03:01 <Myoma> the film
22:03:32 <gwern> er...
22:03:39 <Myoma> german silent black and white ..
22:05:06 <gwern> ok. is it the one with the recently announced recovered footage?
22:05:20 <Myoma> oh I don't know anything about that
22:05:34 <shapr> I've been watching babylon 5, it's cool!
22:05:35 <gwern> probably not then
22:05:54 * Myoma has trouble concentrating on it though so has taken a break ..
22:07:02 <Myoma> I think I used to see babylon 5 on tv a long time ago
22:07:23 <gwern> in korea, only old people watch babylon V
22:07:33 <Myoma> haha ?
22:07:37 <SamB> how about soviet russia?
22:08:05 <gwern> in soviet russia, tv watchs you!
22:08:46 <Myoma> in soviet russia tv doesn't really watch me
22:10:19 <Pseudonym> In Soviet Russia, your programming language hates Jon Harrop.
22:12:15 <gwern> In Soviet Russia, Harrop would be in the gulag for profiteering, where he would most likely die of exposure and disease, becoming yet another grim statistic in one of history's most murderous regimes.
22:12:22 <gwern> Totaliarianism - it's not a joke kids.
22:12:35 <dons> profiteering eh?
22:12:57 <dons> i guess that is the case.
22:14:42 <SamB> gwern: either that, or he'd be a Party official
22:14:53 <SamB> hmm, possibly both ;-P
22:15:19 <gwern> party members certainly aren't exempt from the gulag...
22:15:35 <chrisdone> in soviet russia jokes are made baout the rest of the world
22:16:20 <Myoma> @@ @run say$ (++"♬").reverse . (++"♬").tail.reverse$ @show  @yow
22:16:21 <lambdabot>   ♬Wait ... is this a FUN THING or the END of LIFE in Petticoat Junction??♬
22:16:41 <gwern> so we are still messing with unicode?
22:17:00 <chrisdone> woah since when did that work
22:18:33 <gwern> today, it seems
22:21:08 <disturbed22> hey
22:22:28 <mmorrow> Myoma: here's a little more messing around with that: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=28  what's slightly confusing is that it seems he's using the levels in the opposite way??
22:22:41 <Dzlk1> Hello world, Καλημέρα κόσμε, コンニチハ
22:23:15 <mmorrow> hola
22:24:03 <mmorrow> @@ @run say$ (++"♬").reverse . (++"♬").tail.reverse$ @show  @yow
22:24:05 <lambdabot>   ♬A can of ASPARAGUS, 73 pigeons, some LIVE ammo, and a FROZEN DAQUIRI!!♬
22:24:33 <dzlk> what's funny is that pidgin's spell check marks the Greek not the Japanese.
22:25:27 <dzlk> s/not/but not/ ... maybe it is misspelled. I wouldn't know. :)
22:25:32 <mmorrow> heh
22:27:25 <dmwit> Maybe you just don't have the Greek dictionaries installed.
22:27:55 <dmwit> Maybe ALL WORDS MEAN SOMETHING in Japanese!
22:27:57 * dmwit boggles
22:28:23 <dmwit> What if you had an alphabet such that you simply could not write something that was not a word.
22:28:59 <dibblego> isn't that a theorem prover?
22:29:01 <dmwit> ...but not like Chinese, that's cheating.
22:29:25 <Twey> dmwit: こんにちは
22:29:29 <Twey> Er
22:29:35 <Twey> dzlk
22:29:35 <mmorrow> would that be a lang where every possible combinations of letters is a word?
22:29:39 <mmorrow> "letters"
22:29:45 <dmwit> yeah
22:29:54 <Twey> dmwit: No, all wordsdo not mean something in Japanese, but it's tricky to tell word boundaries :-P
22:29:58 <Twey> words do**
22:30:00 <Twey> Ugh
22:30:07 <Twey> I HAS THE DUMB
22:31:17 <gwern> a language where every combo of letters is a word would be hell in ECC terms
22:31:28 <mmorrow> Myoma: hmm, i may have flipped flip then, but that doesn't make any sense either i feel...
22:31:39 <Myoma> :S
22:31:40 <gwern> evern your basic spell checker would need to do semantic analysis...
22:31:47 <Myoma> what is going on
22:32:00 <dzlk> It'd have either a very small alphabet or a very large lexicon.
22:32:19 <dmwit> gwern: Nah, just "isValidWord = const True". =)
22:32:27 <mmorrow> if would have an infinite lexicon assuming a nonempty alphabet i believe
22:32:45 <Myoma> @find 0 0 0
22:32:46 <lambdabot> Only unit numeric type pattern is valid
22:32:46 <lambdabot> Only unit numeric type pattern is valid
22:32:46 <lambdabot> Only unit numeric type pattern is valid
22:32:50 <dmwit> mmorrow: Yeah, but you could probably pull it off with some kind of German-style word concatenation rules.
22:32:52 <dzlk> unless there's an upper bound on word length.
22:33:14 <dzlk> or if there's an upper bound on basic word length and anything longer than that is a compound.
22:33:21 <dmwit> right
22:33:28 <mmorrow> dmwit: ahh, i've always meant to read about those rules
22:33:39 <dmwit> Tricky to tell about how to break up compound words, though...
22:33:56 <dmwit> (Since all possible breaks form legitimate words...)
22:34:11 <dzlk> or words have a fixed length.
22:34:19 <dmwit> That would probably be best.
22:34:25 <mmorrow> it's just the free language generated by whatever alphabet you chose
22:34:49 <dmwit> tar++
22:35:05 <dzlk> then an ideographic language would just be a fixed-word-length language with a length of one.
22:35:44 <mmorrow> true
22:36:03 <Myoma> @fact
22:36:03 <lambdabot> I can not handle empty facts.
22:36:07 <mmorrow> haha
22:36:44 <Myoma> @@ @run unwords.reverse.words$ @show @farmer
22:36:44 <lambdabot> Plugin `compose' failed with: Unknown command: "farmer"
22:36:49 <Myoma> @@ @run unwords.reverse.words$ @show @farber
22:36:50 <lambdabot>   "problems. with wrought It's"
22:37:26 <mmorrow> @farber
22:37:26 <lambdabot> It's a sight for sore ears.
22:37:50 <Myoma> @nazi-on
22:37:50 <lambdabot> Not enough privileges
22:38:54 <dons> i'm amazed the toplevel <- thread is still running.
22:39:42 <dons> why don't we have any parallel/multicore data structure libraries yet?
22:40:19 <dmwit> Where's my NDP?
22:40:29 <dons> couldn't we do `par`-based Data.Map updates?
22:40:43 <dons> lots of nice structures with implicit parallelism
22:41:06 <dons> `par`-ifying the containers library is a research result, i guess.
22:41:17 <dons> mmm...
22:42:59 <quicksilver> dons: the top-level <- represents totally irreconcilable beliefs.
22:43:05 <quicksilver> dons: there is no way to stop it ;)
22:43:28 <Myoma> ghc says: Exotic Stmt in meta brackets
22:43:29 <dons> it's a cultural divide
22:44:08 * dons imagines a new okasaki-like career `par`-ifying purely functional structures.
22:44:17 <gwern> religious wars yay
22:44:24 <dons> "purely functional parallel datastructures" would be a nice book
22:44:30 <Myoma> what's the <- thing
22:44:48 <Myoma> does it mean global mutable variables?
22:44:57 <mmorrow> dons: what would that mean? would that need to be in STM or equivalent if the same tree is being updated in par?
22:45:15 <Twey> mmorrow: It works with philosophical languages, if you consider a semantic unit to be a 'letter'
22:45:17 <dmwit> ewww, global mutable variables?
22:45:21 <dmwit> In MY Haskell?
22:45:24 <Twey> Hahaha
22:45:36 <dons> gwern: i don't believe this is on hackage yet, http://repetae.net/recent/out/HsASA.html
22:45:37 <Myoma> can GMP support KealDigit? I invent KealDigit
22:45:41 <lambdabot> Title: HsASA
22:45:47 <mmorrow> Twey: it works with the Integers and primes as well :)
22:45:53 <dons> mmorrow: no, just the underlying pure `par` sparks
22:45:57 <Twey> Aye :)
22:46:04 <dons> but the operations would use multiple cores to traverse and do things.
22:46:09 <mmorrow> dons: hmm, i have to read up on `par`
22:46:31 <dons> one nice example is the `par` enabled (sum list / length list)
22:46:36 <dons> that runs in constant space due to `par`
22:47:13 <Myoma> genericLength*
22:47:20 <dons> gwern: actually, a lot of john meacham stuff isn't on hackage.
22:47:37 <gwern> dons: yeah, there's a reason for that...
22:47:44 <mmorrow> interesting, is that something like    let x = sum list ; y = length list in x `par` y `seq` x / y ?
22:47:54 <dons> gwern: sure, but that shouldn't stop us.
22:47:58 <dons> esp. the libs.
22:48:33 <gwern> ie. I put on his derive stuff, and realized no one would ever use it from hackage and he'd never accept the patches and that I'd wasted my time, and I vowed to never again bother with his stuff
22:48:42 <dons> hmm
22:49:55 <gwern> that was, iirc, a solid evening of work. you can understand why I don't care to repeat the experience
22:54:39 * gwern notes that this is not the first time dons and I have discussed exactly this issue
22:54:54 <Myoma> > let (p & q) o (x,y) = (p o x, q o y) in uncurry (/) $ foldr ((+) & const (+1)) (0, 0) [x,y,z]
22:54:55 <lambdabot>   (x + (y + (z + 0))) / (0 + 1 + 1 + 1)
22:55:24 <opqdonut> >  uncurry (/) $ foldr  ((+) & const (+1)) (0, 0) [x,y,z]
22:55:25 <lambdabot>   mueval: Prelude.read: no parse
22:55:27 <opqdonut> woops
22:55:30 <Myoma> @let (p & q) o (x,y) = (p o x, q o y)
22:55:31 <lambdabot>  Defined.
22:55:31 <opqdonut> mispaste
22:55:46 <gwern> (this may not be the second or even third time, now that I think about it)
22:56:02 <opqdonut> > uncurry (/) $ foldr  ((+) *** const (+1)) (0, 0) [x,y,z]
22:56:03 <lambdabot>   Couldn't match expected type `b -> b'
22:56:11 <Myoma> :t (***)
22:56:12 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
22:56:17 <Myoma> I will make some tuple combinators
22:57:50 <dmwit> (&) = liftM2 (&&&)
22:57:54 <dmwit> :t liftM2 (&&&)
22:57:55 <lambdabot> forall (a :: * -> * -> *) b c c' (m :: * -> *). (Monad m, Arrow a) => m (a b c) -> m (a b c') -> m (a b (c, c'))
22:58:09 <opqdonut> dmwit: yeah, that should do it
22:58:53 <opqdonut> > uncurry (/) $ foldr  (\x -> (+x) *** (+1)) (0, 0) [x,y,z]
22:58:54 <lambdabot>   mueval: Prelude.read: no parse
22:59:02 <opqdonut> hmm?
22:59:24 <opqdonut> worked in ghci
23:00:04 <mmorrow> holy shit. `par` brought main = print (mean [0..10000000])  +RTS -N2 -RTS  down from real    0m13.852s  to  real    0m2.244s
23:00:05 <dmwit> It's a lot uglier when you have to merge the two passes yourself, isn't it? =P
23:00:26 <Myoma> mmorrow:  wow what is th e code?
23:00:32 <mmorrow> i'll paste it
23:00:51 <opqdonut> > uncurry (/) $ foldr  (\x -> (+x) *** (+1)) (0, 0) [1,2,3]
23:00:53 <lambdabot>   mueval: Prelude.read: no parse
23:01:09 <opqdonut> hrmm, i'd like to know whats wrong with that
23:01:17 <opqdonut> pasted verbatim from ghci
23:01:27 <opqdonut> :t uncurry (/) $ foldr  (\x -> (+x) *** (+1)) (0, 0) [x,y,z]
23:01:28 <lambdabot> Expr
23:01:58 <gwern> opqdonut: Cale's mueval does not import control.arrow
23:01:59 <thoughtpolice> language.c is really a lot of fun. :]
23:02:37 <Cale> gwern: You might put one which does on Hackage. :)  Of course, I guess I could just darcs get the newer mueval too...
23:03:09 <quicksilver> Interesting that jcc should object to a feature on the grounds that he doesn't want Haskell to be usable for day-to-day programming.
23:03:16 <quicksilver> that's a sad attitude.
23:03:45 <mmorrow> Myoma: http://hpaste.org/10060
23:04:04 <gwern> Cale: I told you, I can't put it on hackage until haskell-src-exts does
23:04:37 * gwern feels a little trapped here. I can't do qualified imports until hint hacks around ghc or ghc fixes it, I can't release mueval because of haskell-src-exts, etc etc
23:05:04 <dons> CosmicRay: cabalised, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HsASA-0.1 . cabal install HsASA
23:05:12 <lambdabot> Title: HackageDB: HsASA-0.1, http://tinyurl.com/5vx3nw
23:05:33 <Cale> gwern: What's holding up haskell-src-exts?
23:05:59 <gwern> dunno
23:06:02 <gwern> haven't asked lately
23:06:42 <opqdonut> gwern: ah, okay
23:07:14 <mmorrow> gwern: fork it and put a branch into a mubot subdir until they do put it on hackage?
23:07:48 <gwern> mmorrow: that is a silly suggestion. I'd need to add a ton to the cabal file to get a nonbroken sdist
23:07:57 * gwern thwaps mmorrow for't
23:08:52 <mmorrow> huh. i've already done that same thing with about 4 different packages i'm writing/using on a daily basis. it's not much trouble at all really.
23:09:20 <gwern> but it's the Wrong Thing
23:09:34 <mmorrow> well, then lb won't be on hackage
23:10:02 <mmorrow> of course the fork wouldn't be permanent or malicious
23:10:13 <mmorrow> just a temporary necessity
23:10:55 * gwern is in no real hurry.
23:10:59 <dmwit> I suggest that gwern continue to refuse on moral grounds, and mmorrow hop to it.
23:11:05 <dmwit> ;-)
23:11:35 <Myoma> @let foldrN fs is = foldr (zipWith3 ($) fs) is . map (replicate (length fs))
23:11:37 <lambdabot>  Defined.
23:11:42 <Myoma> > (\[sum,length]->sum/length) $ foldrN [(+),const (+1)] [0,0] $ [1,2,3,4]
23:11:44 <lambdabot>   2.5
23:11:47 <gwern> 'These war powers are necessary to defend the republic; cmmander cody, execute fork 66.'
23:13:17 <dmwit> Myoma: Try transpose . replicate (length fs)
23:13:28 <dmwit> (rather than map (replicate (length fs)))
23:14:04 <mmorrow> gwern: we can't him in the war rooom, hell see the big booard!
23:15:05 * gwern has a bad feeling about this discussion
23:30:28 <mmorrow> gwern: which discussion, dr strangelove or route66?
23:31:41 <quicksilver> "How I stopped worrying and learned to love the lambda"
23:32:03 <skorpan> "i kissed a lambda and i liked it"
23:32:32 <profmakx> have you seen the post about the girl whose name was haskell ;)
23:32:37 <skorpan> "no i don't even know your name, it doesn't matter"
23:32:45 <skorpan> no, what?
23:32:54 <skorpan> i know there's a swedish girl named haskel
23:33:01 <profmakx> it was on programming.reddit
23:33:04 <profmakx> yesterday
23:33:37 <skorpan> i'll check it out, it's bound to still be there
23:34:04 <skorpan> http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html
23:34:10 <lambdabot> Title: [FoRK] And then there's Haskell... (was: Bone / Greenspun, etc.), http://tinyurl.com/5c7uj5
23:36:00 <profmakx> yeah, that
23:36:03 <profmakx> 's it
23:46:24 <ike_> I've read two papers for writing web server in Haskell: one is written by Simon Marlow and another Peng Li and Steve Zdancewic
23:48:10 <ike_> the latter used Linux pthread and also same performance as apache (in thier paper)
23:49:49 <ike_> oh not pthread but AIO
23:50:03 <ike_> I dont know about AIO of Linux, anyway
23:51:40 <dons> ok. so what's your plan now? :)
23:51:50 <dons> fast, bytestring-based, concurrent server ?
23:52:26 <ike_> dons: now is not ready; just reading :)
23:52:44 <dons> also you should talk to tibbe
23:53:00 <dons> he's got a new fast server (5000 hits/sec or something, was his entry level)
23:53:11 <ike_> hew
23:53:20 <vegai> dons: dynamic pages?
23:53:47 <dons> dynamic in what way?
23:53:54 <dons> (probably not)
23:54:06 <vegai> ok, so 5000hits/sec is not bad
23:54:10 <thoughtpolice> @seen mmorrow
23:54:10 <lambdabot> mmorrow is in #ghc, #haskell, #darcs and #haskell-blah. I last heard mmorrow speak 23m 41s ago.
23:54:28 <vegai> nginx gets easily over 10k, though
23:54:53 <dons> i don't think its been tuned yet.
23:55:04 <dons> he mentioned 5k as the initial numbers
23:55:20 <ike_> @seen tibbe
23:55:20 <lambdabot> I saw tibbe leaving #haskell-soc, #xmonad, #ghc and #haskell 30m 51s ago, and .
23:55:30 <dons> i'd imagine a good concurrent haskell server could be rathe zippy
23:55:32 <ike_> I missed him
23:55:55 <thoughtpolice> mmorrow: i remember you posted something about a javascript quasiquoter (using that webbits library,) do you still have an example of that?
23:56:22 <vegai> yeah, and nginx is the best for raw performance. If a haskell server would get close, it would be very impressive
